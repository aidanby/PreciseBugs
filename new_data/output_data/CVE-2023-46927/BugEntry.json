{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/constants.h>\n#include <gpac/iso639.h>\n\n\n#if !defined(GPAC_DISABLE_ISOM) && !defined(GPAC_DISABLE_ISOM_WRITE)\n\nGF_Err CanAccessMovie(GF_ISOFile *movie, GF_ISOOpenMode Mode)\n{\n\tif (!movie) return GF_BAD_PARAM;\n\tif (movie->openMode < Mode) return GF_ISOM_INVALID_MODE;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) return GF_ISOM_INVALID_MODE;\n#endif\n\treturn GF_OK;\n}\n\nstatic GF_Err unpack_track(GF_TrackBox *trak)\n{\n\tGF_Err e = GF_OK;\n\tif (!trak->is_unpacked) {\n\t\te = stbl_UnpackOffsets(trak->Media->information->sampleTable);\n\t\tif (e) return e;\n\t\te = stbl_unpackCTS(trak->Media->information->sampleTable);\n\t\ttrak->is_unpacked = GF_TRUE;\n\t}\n\treturn e;\n}\n\n\nGF_Err FlushCaptureMode(GF_ISOFile *movie)\n{\n\tGF_Err e;\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) {\n\t\tif (!movie->editFileMap) return GF_ISOM_INVALID_MODE;\n\t\treturn GF_OK;\n\t}\n\t/*make sure nothing was added*/\n\tif (gf_bs_get_position(movie->editFileMap->bs)) return GF_OK;\n\n\tif (!strcmp(movie->fileName, \"_gpac_isobmff_redirect\")) {\n\t\tif (!movie->on_block_out) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Missing output block callback, cannot write\\n\"));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\n\t\tgf_bs_del(movie->editFileMap->bs);\n\t\tmovie->editFileMap->bs = gf_bs_new_cbk(isom_on_block_out, movie, movie->on_block_out_block_size);\n\t}\n\n\t/*add all first boxes*/\n\tif (movie->brand) {\n\t\te = gf_isom_box_size((GF_Box *)movie->brand);\n\t\tif (e) return e;\n\t\te = gf_isom_box_write((GF_Box *)movie->brand, movie->editFileMap->bs);\n\t\tif (e) return e;\n\t}\n\tif (movie->pdin) {\n\t\te = gf_isom_box_size((GF_Box *)movie->pdin);\n\t\tif (e) return e;\n\t\te = gf_isom_box_write((GF_Box *)movie->pdin, movie->editFileMap->bs);\n\t\tif (e) return e;\n\t}\n\tmovie->mdat->bsOffset = gf_bs_get_position(movie->editFileMap->bs);\n\n\t/*we have a trick here: the data will be stored on the fly, so the first\n\tthing in the file is the MDAT. As we don't know if we have a large file (>4 GB) or not\n\tdo as if we had one and write 16 bytes: 4 (type) + 4 (size) + 8 (largeSize)...*/\n\tgf_bs_write_long_int(movie->editFileMap->bs, 0, 64);\n\tgf_bs_write_long_int(movie->editFileMap->bs, 0, 64);\n\treturn GF_OK;\n}\n\nstatic GF_Err CheckNoData(GF_ISOFile *movie)\n{\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) return GF_OK;\n\tif (gf_bs_get_position(movie->editFileMap->bs)) return GF_BAD_PARAM;\n\treturn GF_OK;\n}\n\n/**************************************************************\n\t\t\t\t\tFile Writing / Editing\n**************************************************************/\n//quick function to add an IOD/OD to the file if not present (iods is optional)\nGF_Err AddMovieIOD(GF_MovieBox *moov, u8 isIOD)\n{\n\tGF_Descriptor *od;\n\tGF_ObjectDescriptorBox *iods;\n\n\t//do we have an IOD ?? If not, create one.\n\tif (moov->iods) return GF_OK;\n\n\tif (isIOD) {\n\t\tod = gf_odf_desc_new(GF_ODF_ISOM_IOD_TAG);\n\t} else {\n\t\tod = gf_odf_desc_new(GF_ODF_ISOM_OD_TAG);\n\t}\n\tif (!od) return GF_OUT_OF_MEM;\n\t((GF_IsomObjectDescriptor *)od)->objectDescriptorID = 1;\n\n\tiods = (GF_ObjectDescriptorBox *) gf_isom_box_new_parent(&moov->child_boxes, GF_ISOM_BOX_TYPE_IODS);\n\tif (!iods) return GF_OUT_OF_MEM;\n\tiods->descriptor = od;\n\treturn moov_on_child_box((GF_Box*)moov, (GF_Box *)iods, GF_FALSE);\n}\n\n//add a track to the root OD\nGF_EXPORT\nGF_Err gf_isom_add_track_to_root_od(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_Err e;\n\tGF_ES_ID_Inc *inc;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (!movie->moov->iods) AddMovieIOD(movie->moov, 0);\n\n\tif (gf_isom_is_track_in_root_od(movie, trackNumber) == 1) return GF_OK;\n\n\tinc = (GF_ES_ID_Inc *) gf_odf_desc_new(GF_ODF_ESD_INC_TAG);\n\tinc->trackID = gf_isom_get_track_id(movie, trackNumber);\n\tif (!inc->trackID) {\n\t\tgf_odf_desc_del((GF_Descriptor *)inc);\n\t\treturn movie->LastError;\n\t}\n\tif ( (movie->LastError = gf_isom_add_desc_to_root_od(movie, (GF_Descriptor *)inc) ) ) {\n\t\treturn movie->LastError;\n\t}\n\tgf_odf_desc_del((GF_Descriptor *)inc);\n\treturn GF_OK;\n}\n\n//remove the root OD\nGF_EXPORT\nGF_Err gf_isom_remove_root_od(GF_ISOFile *movie)\n{\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\tif (!movie->moov || !movie->moov->iods) return GF_OK;\n\tgf_isom_box_del_parent(&movie->moov->child_boxes, (GF_Box *)movie->moov->iods);\n\tmovie->moov->iods = NULL;\n\treturn GF_OK;\n}\n\n//remove a track to the root OD\nGF_EXPORT\nGF_Err gf_isom_remove_track_from_root_od(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_List *esds;\n\tGF_ES_ID_Inc *inc;\n\tu32 i;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\tif (!movie->moov) return GF_OK;\n\n\tif (!gf_isom_is_track_in_root_od(movie, trackNumber)) return GF_OK;\n\n\tif (!movie->moov->iods) {\n\t\te = AddMovieIOD(movie->moov, 0);\n\t\tif (e) return e;\n\t}\n\tswitch (movie->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tesds = ((GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor)->ES_ID_IncDescriptors;\n\t\tbreak;\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tesds = ((GF_IsomObjectDescriptor *)movie->moov->iods->descriptor)->ES_ID_IncDescriptors;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//get the desc\n\ti=0;\n\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(esds, &i))) {\n\t\tif (inc->trackID == (u32) gf_isom_get_track_id(movie, trackNumber)) {\n\t\t\tgf_odf_desc_del((GF_Descriptor *)inc);\n\t\t\tgf_list_rem(esds, i-1);\n\t\t\tbreak;\n\t\t}\n\t}\n\t//we don't remove the iod for P&Ls and other potential info\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_creation_time(GF_ISOFile *movie, u64 ctime, u64 mtime)\n{\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\tmovie->moov->mvhd->creationTime = ctime;\n\tmovie->moov->mvhd->modificationTime = mtime;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_creation_time(GF_ISOFile *movie,u32 trackNumber, u64 ctime, u64 mtime)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\ttrak->Header->creationTime = ctime;\n\ttrak->Header->modificationTime = mtime;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_media_creation_time(GF_ISOFile *movie,u32 trackNumber, u64 ctime, u64 mtime)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media || !trak->Media->mediaHeader) return GF_ISOM_INVALID_FILE;\n\n\ttrak->Media->mediaHeader->creationTime = ctime;\n\ttrak->Media->mediaHeader->modificationTime = mtime;\n\treturn GF_OK;\n}\n\n//sets the enable flag of a track\nGF_EXPORT\nGF_Err gf_isom_set_track_enabled(GF_ISOFile *movie, u32 trackNumber, Bool enableTrack)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (enableTrack) {\n\t\ttrak->Header->flags |= 1;\n\t} else {\n\t\ttrak->Header->flags &= ~1;\n\t}\n\treturn GF_OK;\n}\n\n//sets the enable flag of a track\nGF_EXPORT\nGF_Err gf_isom_set_track_flags(GF_ISOFile *movie, u32 trackNumber, u32 flags, GF_ISOMTrackFlagOp op)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (op==GF_ISOM_TKFLAGS_ADD)\n\t\ttrak->Header->flags |= flags;\n\telse if (op==GF_ISOM_TKFLAGS_REM)\n\t\ttrak->Header->flags &= ~flags;\n\telse\n\t\ttrak->Header->flags = flags;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_media_language(GF_ISOFile *movie, u32 trackNumber, char *code)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !code) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\t// Old language-storage processing\n\t// if the new code is on 3 chars, we use it\n\t// otherwise, we find the associated 3 chars code and use it\n\tif (strlen(code) == 3) {\n\t\tmemcpy(trak->Media->mediaHeader->packedLanguage, code, sizeof(char)*3);\n\t} else {\n\t\ts32 lang_idx;\n\t\tconst char *code_3cc;\n\t\tlang_idx = gf_lang_find(code);\n\t\tif (lang_idx == -1) {\n\t\t\tif (code[0]!=0) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"The given code is not a valid one: %s, using 'und' as 3-letter code\\n\", code));\n\t\t\t}\n\t\t\tcode_3cc = \"und\";\n\t\t} else {\n\t\t\tcode_3cc = gf_lang_get_3cc(lang_idx);\n\t\t}\n\t\tmemcpy(trak->Media->mediaHeader->packedLanguage, code_3cc, sizeof(char)*3);\n\t}\n\n\t// New language-storage processing\n\t// change the code in the extended language box (if any)\n\t// otherwise add an extended language box only if the given code is not 3 chars\n\t{\n\t\tu32 i, count;\n\t\tGF_ExtendedLanguageBox *elng;\n\t\telng = NULL;\n\t\tcount = gf_list_count(trak->Media->child_boxes);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tGF_Box *box = (GF_Box *)gf_list_get(trak->Media->child_boxes, i);\n\t\t\tif (box->type == GF_ISOM_BOX_TYPE_ELNG) {\n\t\t\t\telng = (GF_ExtendedLanguageBox *)box;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!elng && (strlen(code) > 3)) {\n\t\t\telng = (GF_ExtendedLanguageBox *)gf_isom_box_new_parent(&trak->Media->child_boxes, GF_ISOM_BOX_TYPE_ELNG);\n\t\t\tif (!elng) return GF_OUT_OF_MEM;\n\t\t}\n\t\tif (elng) {\n\t\t\tif (elng->extended_language) {\n\t\t\t\tgf_free(elng->extended_language);\n\t\t\t}\n\t\t\telng->extended_language = gf_strdup(code);\n\t\t}\n\t}\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_isom_set_root_iod(GF_ISOFile *movie)\n{\n\tGF_IsomInitialObjectDescriptor *iod;\n\tGF_IsomObjectDescriptor *od;\n\tGF_Err e;\n\t\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\tif (!movie->moov->iods) {\n\t\tAddMovieIOD(movie->moov, 1);\n\t\treturn GF_OK;\n\t}\n\t//if OD, switch to IOD\n\tif (movie->moov->iods->descriptor->tag == GF_ODF_ISOM_IOD_TAG) return GF_OK;\n\tod = (GF_IsomObjectDescriptor *) movie->moov->iods->descriptor;\n\tiod = (GF_IsomInitialObjectDescriptor*)gf_malloc(sizeof(GF_IsomInitialObjectDescriptor));\n\tif (!iod) return GF_OUT_OF_MEM;\n\n\tmemset(iod, 0, sizeof(GF_IsomInitialObjectDescriptor));\n\n\tiod->ES_ID_IncDescriptors = od->ES_ID_IncDescriptors;\n\tod->ES_ID_IncDescriptors = NULL;\n\t//not used in root OD\n\tiod->ES_ID_RefDescriptors = NULL;\n\tiod->extensionDescriptors = od->extensionDescriptors;\n\tod->extensionDescriptors = NULL;\n\tiod->IPMP_Descriptors = od->IPMP_Descriptors;\n\tod->IPMP_Descriptors = NULL;\n\tiod->objectDescriptorID = od->objectDescriptorID;\n\tiod->OCIDescriptors = od->OCIDescriptors;\n\tod->OCIDescriptors = NULL;\n\tiod->tag = GF_ODF_ISOM_IOD_TAG;\n\tiod->URLString = od->URLString;\n\tod->URLString = NULL;\n\n\tgf_odf_desc_del((GF_Descriptor *) od);\n\tmovie->moov->iods->descriptor = (GF_Descriptor *)iod;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_desc_to_root_od(GF_ISOFile *movie, const GF_Descriptor *theDesc)\n{\n\tGF_Err e;\n\tGF_Descriptor *desc, *dupDesc;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (!movie->moov->iods) {\n\t\te = AddMovieIOD(movie->moov, 0);\n\t\tif (e) return e;\n\t}\n\tif (theDesc->tag==GF_ODF_IPMP_TL_TAG) gf_isom_set_root_iod(movie);\n\n\tdesc = movie->moov->iods->descriptor;\n\t//the type of desc is handled at the OD/IOD level, we'll be notified\n\t//if the desc is not allowed\n\tswitch (desc->tag) {\n\tcase GF_ODF_ISOM_IOD_TAG:\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\t//duplicate the desc\n\t\te = gf_odf_desc_copy((GF_Descriptor *)theDesc, &dupDesc);\n\t\tif (e) return e;\n\t\t//add it (MUST BE  (I)OD level desc)\n\t\tmovie->LastError = gf_odf_desc_add_desc(desc, dupDesc);\n\t\tif (movie->LastError) gf_odf_desc_del((GF_Descriptor *)dupDesc);\n\t\tbreak;\n\tdefault:\n\t\tmovie->LastError = GF_ISOM_INVALID_FILE;\n\t\tbreak;\n\t}\n\treturn movie->LastError;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_timescale(GF_ISOFile *movie, u32 timeScale)\n{\n\tGF_TrackBox *trak;\n\tu32 i;\n\tGF_Err e;\n\tif (!timeScale) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (movie->moov->mvhd->timeScale == timeScale) return GF_OK;\n\n\t/*rewrite all durations and edit lists*/\n\tmovie->moov->mvhd->duration *= timeScale;\n\tmovie->moov->mvhd->duration /= movie->moov->mvhd->timeScale;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (movie->moov->mvex && movie->moov->mvex->mehd) {\n\t\tmovie->moov->mvex->mehd->fragment_duration *= timeScale;\n\t\tmovie->moov->mvex->mehd->fragment_duration /= movie->moov->mvhd->timeScale;\n\t}\n#endif\n\n\ti=0;\n\twhile ((trak = (GF_TrackBox*)gf_list_enum(movie->moov->trackList, &i))) {\n\t\ttrak->Header->duration *= timeScale;\n\t\ttrak->Header->duration /= movie->moov->mvhd->timeScale;\n\n\t\tif (trak->editBox && trak->editBox->editList) {\n\t\t\tu32 j, count = gf_list_count(trak->editBox->editList->entryList);\n\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\tGF_EdtsEntry *ent = (GF_EdtsEntry *)gf_list_get(trak->editBox->editList->entryList, j);\n\t\t\t\tent->segmentDuration *= timeScale;\n\t\t\t\tent->segmentDuration /= movie->moov->mvhd->timeScale;\n\t\t\t}\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (movie->moov->mvex && movie->moov->mvex->mehd) {\n\t\tmovie->moov->mvex->mehd->fragment_duration *= timeScale;\n\t\tmovie->moov->mvex->mehd->fragment_duration /= movie->moov->mvhd->timeScale;\n\t}\n#endif\n\tmovie->moov->mvhd->timeScale = timeScale;\n\tmovie->interleavingTime = timeScale;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_pl_indication(GF_ISOFile *movie, GF_ISOProfileLevelType PL_Code, u8 ProfileLevel)\n{\n\tGF_IsomInitialObjectDescriptor *iod;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\te = gf_isom_set_root_iod(movie);\n\tif (e) return e;\n\n\tiod = (GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor;\n\n\tswitch (PL_Code) {\n\tcase GF_ISOM_PL_AUDIO:\n\t\tiod->audio_profileAndLevel = ProfileLevel;\n\t\tbreak;\n\tcase GF_ISOM_PL_GRAPHICS:\n\t\tiod->graphics_profileAndLevel = ProfileLevel;\n\t\tbreak;\n\tcase GF_ISOM_PL_OD:\n\t\tiod->OD_profileAndLevel = ProfileLevel;\n\t\tbreak;\n\tcase GF_ISOM_PL_SCENE:\n\t\tiod->scene_profileAndLevel = ProfileLevel;\n\t\tbreak;\n\tcase GF_ISOM_PL_VISUAL:\n\t\tiod->visual_profileAndLevel = ProfileLevel;\n\t\tbreak;\n\tcase GF_ISOM_PL_INLINE:\n\t\tiod->inlineProfileFlag = ProfileLevel ? 1 : 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_root_od_id(GF_ISOFile *movie, u32 OD_ID)\n{\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\tif (!movie->moov->iods) {\n\t\te = AddMovieIOD(movie->moov, 0);\n\t\tif (e) return e;\n\t}\n\n\tswitch (movie->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\t((GF_IsomObjectDescriptor *)movie->moov->iods->descriptor)->objectDescriptorID = OD_ID;\n\t\tbreak;\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\t((GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor)->objectDescriptorID = OD_ID;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_root_od_url(GF_ISOFile *movie, const char *url_string)\n{\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (!movie->moov->iods) {\n\t\te = AddMovieIOD(movie->moov, 0);\n\t\tif (e) return e;\n\t}\n\n\tswitch (movie->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tif (((GF_IsomObjectDescriptor *)movie->moov->iods->descriptor)->URLString) gf_free(((GF_IsomObjectDescriptor *)movie->moov->iods->descriptor)->URLString);\n\t\t((GF_IsomObjectDescriptor *)movie->moov->iods->descriptor)->URLString = url_string ? gf_strdup(url_string) : NULL;\n\t\tbreak;\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tif (((GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor)->URLString) gf_free(((GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor)->URLString);\n\t\t((GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor)->URLString = url_string ? gf_strdup(url_string) : NULL;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_ISOTrackID gf_isom_get_last_created_track_id(GF_ISOFile *movie)\n{\n\treturn movie ? movie->last_created_track_id : 0;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_load_extra_boxes(GF_ISOFile *movie, u8 *moov_boxes, u32 moov_boxes_size, Bool udta_only)\n{\n\tGF_BitStream *bs;\n\n\tGF_Err e = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tbs = gf_bs_new(moov_boxes, moov_boxes_size, GF_BITSTREAM_READ);\n\n\t//we may have terminators in some QT files (4 bytes set to 0 ...)\n\twhile (gf_bs_available(bs) >= 8) {\n\t\tGF_Box *a_box;\n\t\te = gf_isom_box_parse_ex((GF_Box**)&a_box, bs, GF_ISOM_BOX_TYPE_MOOV, GF_FALSE, 0);\n\t\tif (e || !a_box) goto exit;\n\n\t\tif (a_box->type == GF_ISOM_BOX_TYPE_UDTA) {\n\t\t\tif (movie->moov->udta) gf_isom_box_del_parent(&movie->moov->child_boxes, (GF_Box*)movie->moov->udta);\n\t\t\tmovie->moov->udta = (GF_UserDataBox*) a_box;\n\n\t\t\tif (!movie->moov->child_boxes) movie->moov->child_boxes = gf_list_new();\n\t\t\tgf_list_add(movie->moov->child_boxes, a_box);\n\n\t\t} else if (!udta_only && (a_box->type!=GF_ISOM_BOX_TYPE_PSSH) ) {\n\t\t\tif (!movie->moov->child_boxes) movie->moov->child_boxes = gf_list_new();\n\t\t\tgf_list_add(movie->moov->child_boxes, a_box);\n\t\t} else {\n\t\t\tgf_isom_box_del(a_box);\n\t\t}\n\t}\nexit:\n\tgf_bs_del(bs);\n\treturn e;\n}\n\n//creates a new Track. If trackID = 0, the trackID is chosen by the API\n//returns the track number or 0 if error\nGF_EXPORT\nu32 gf_isom_new_track_from_template(GF_ISOFile *movie, GF_ISOTrackID trakID, u32 MediaType, u32 TimeScale, u8 *tk_box, u32 tk_box_size, Bool udta_only)\n{\n\tGF_Err e;\n\tu64 now;\n\tu8 isHint;\n\tGF_TrackBox *trak;\n\tGF_TrackHeaderBox *tkhd;\n\tGF_MediaBox *mdia;\n\tGF_UserDataBox *udta = NULL;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) {\n\t\tgf_isom_set_last_error(movie, e);\n\t\treturn 0;\n\t}\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\n\tisHint = 0;\n\t//we're creating a hint track... it's the same, but mode HAS TO BE EDIT\n\tif (MediaType == GF_ISOM_MEDIA_HINT) {\n//\t\tif (movie->openMode != GF_ISOM_OPEN_EDIT) return 0;\n\t\tisHint = 1;\n\t}\n\n\tmdia = NULL;\n\ttkhd = NULL;\n\ttrak = NULL;\n\tif (trakID) {\n\t\t//check if we are in ES_ID boundaries\n\t\tif (!isHint && (trakID > 0xFFFF)) {\n\t\t\tgf_isom_set_last_error(movie, GF_BAD_PARAM);\n\t\t\treturn 0;\n\t\t}\n\t\t//here we should look for available IDs ...\n\t\tif (!RequestTrack(movie->moov, trakID)) return 0;\n\t} else {\n\t\ttrakID = movie->moov->mvhd->nextTrackID;\n\t\tif (!trakID) trakID = 1;\n\t\t/*ESIDs are on 16 bits*/\n\t\tif (! isHint && (trakID > 0xFFFF)) trakID = 1;\n\n\t\twhile (1) {\n\t\t\tif (RequestTrack(movie->moov, trakID)) break;\n\t\t\ttrakID += 1;\n\t\t\tif (trakID == 0xFFFFFFFF) break;\n\t\t}\n\t\tif (trakID == 0xFFFFFFFF) {\n\t\t\tgf_isom_set_last_error(movie, GF_BAD_PARAM);\n\t\t\treturn 0;\n\t\t}\n\t\tif (! isHint && (trakID > 0xFFFF)) {\n\t\t\tgf_isom_set_last_error(movie, GF_BAD_PARAM);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (tk_box) {\n\t\tGF_BitStream *bs = gf_bs_new(tk_box, tk_box_size, GF_BITSTREAM_READ);\n\t\tgf_bs_set_cookie(bs, GF_ISOM_BS_COOKIE_NO_LOGS|GF_ISOM_BS_COOKIE_CLONE_TRACK);\n\n\t\te = gf_isom_box_parse_ex((GF_Box**)&trak, bs, GF_ISOM_BOX_TYPE_MOOV, GF_FALSE, 0);\n\t\tgf_bs_del(bs);\n\t\tif (e) trak = NULL;\n\t\telse if (udta_only) {\n\t\t\tudta = trak->udta;\n\t\t\ttrak->udta = NULL;\n\t\t\tgf_list_del_item(trak->child_boxes, udta);\n\t\t\tgf_isom_box_del((GF_Box*)trak);\n\t\t\ttrak = NULL;\n\t\t} else {\n\t\t\tBool tpl_ok = GF_TRUE;\n\t\t\tif (!trak->Header || !trak->Media || !trak->Media->handler || !trak->Media->mediaHeader || !trak->Media->information) tpl_ok = GF_FALSE;\n\n\t\t\telse {\n\t\t\t\tif (!MediaType) MediaType = trak->Media->handler->handlerType;\n\t\t\t\te = NewMedia(&trak->Media, MediaType, TimeScale);\n\t\t\t\tif (e) tpl_ok = GF_FALSE;\n\t\t\t}\n\t\t\tif (!tpl_ok) {\n\t\t\t\tudta = trak->udta;\n\t\t\t\ttrak->udta = NULL;\n\t\t\t\tgf_isom_box_del((GF_Box*)trak);\n\t\t\t}\n\t\t}\n\t}\n\tnow = gf_isom_get_mp4time();\n\tif (!trak) {\n\t\t//OK, now create a track...\n\t\ttrak = (GF_TrackBox *) gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_TRAK);\n\t\tif (!trak) {\n\t\t\tgf_isom_set_last_error(movie, GF_OUT_OF_MEM);\n\t\t\treturn 0;\n\t\t}\n\t\ttkhd = (GF_TrackHeaderBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TKHD);\n\t\tif (!tkhd) {\n\t\t\tgf_isom_set_last_error(movie, GF_OUT_OF_MEM);\n\t\t\treturn 0;\n\t\t}\n\n\t\t//OK, set up the media trak\n\t\te = NewMedia(&mdia, MediaType, TimeScale);\n\t\tif (e) {\n\t\t\tgf_isom_box_del((GF_Box *)mdia);\n\t\t\treturn 0;\n\t\t}\n\t\tassert(trak->child_boxes);\n\t\tgf_list_add(trak->child_boxes, mdia);\n\n\t\t//OK, add this media to our track\n\t\tmdia->mediaTrack = trak;\n\n\t\te = trak_on_child_box((GF_Box*)trak, (GF_Box *) tkhd, GF_FALSE);\n\t\tif (e) goto err_exit;\n\t\te = trak_on_child_box((GF_Box*)trak, (GF_Box *) mdia, GF_FALSE);\n\t\tif (e) goto err_exit;\n\t\ttkhd->trackID = trakID;\n\n\t\tif (gf_sys_is_test_mode() ) {\n\t\t\ttkhd->creationTime = 0;\n\t\t\tmdia->mediaHeader->creationTime = 0;\n\t\t} else {\n\t\t\ttkhd->creationTime = now;\n\t\t\tmdia->mediaHeader->creationTime = now;\n\t\t}\n\n\t} else {\n\t\ttkhd = trak->Header;\n\t\ttkhd->trackID = trakID;\n\t\tmdia = trak->Media;\n\t\tmdia->mediaTrack = trak;\n\t\tmdia->mediaHeader->timeScale = TimeScale;\n\t\tif (mdia->handler->handlerType != MediaType) {\n\t\t\tmdia->handler->handlerType = MediaType;\n\t\t\ttkhd->width = 0;\n\t\t\ttkhd->height = 0;\n\t\t\ttkhd->volume = 0;\n\t\t} else {\n\t\t\tMediaType = 0;\n\t\t}\n\t\ttrak->Header->duration = 0;\n\t\tmdia->mediaHeader->duration = 0;\n\n\t\tif (!movie->moov->child_boxes) movie->moov->child_boxes = gf_list_new();\n\t\tgf_list_add(movie->moov->child_boxes, trak);\n\t}\n\tif (MediaType) {\n\t\t//some default properties for Audio, Visual or private tracks\n\t\tswitch (MediaType) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\tcase GF_ISOM_MEDIA_PICT:\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\tcase GF_ISOM_MEDIA_SUBT:\n\t\t\t/*320-240 pix in 16.16*/\n\t\t\ttkhd->width = 0x01400000;\n\t\t\ttkhd->height = 0x00F00000;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\ttkhd->volume = 0x0100;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmovie->last_created_track_id = tkhd->trackID;\n\t\n\tif (!movie->keep_utc && !gf_sys_is_test_mode() ) {\n\t\ttkhd->modificationTime = now;\n\t \tmdia->mediaHeader->modificationTime = now;\n\t}\n\n\t//OK, add our trak\n\te = moov_on_child_box((GF_Box*)movie->moov, (GF_Box *)trak, GF_FALSE);\n\tif (e) goto err_exit;\n\t//set the next track ID available\n\tif (trakID >= movie->moov->mvhd->nextTrackID)\n\t\tmovie->moov->mvhd->nextTrackID = trakID+1;\n\n\tif (udta) {\n\t\ttrak->udta = udta;\n\t\tgf_list_add(trak->child_boxes, udta);\n\t}\n\n\t//and return our track number\n\treturn gf_isom_get_track_by_id(movie, trakID);\n\nerr_exit:\n\t//tkhd is registered with track and will be destroyed there\n\tif (trak) gf_isom_box_del((GF_Box *)trak);\n\tif (mdia) gf_isom_box_del((GF_Box *)mdia);\n\treturn 0;\n}\n\nGF_Err gf_isom_set_track_stsd_templates(GF_ISOFile *movie, u32 trackNumber, u8 *stsd_data, u32 stsd_data_size)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_SampleDescriptionBox *stsd=NULL;\n\tGF_List *tmp;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tif (gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes))\n\t\treturn GF_BAD_PARAM;\n\n\tGF_BitStream *bs = gf_bs_new(stsd_data, stsd_data_size, GF_BITSTREAM_READ);\n\te = gf_isom_box_parse_ex((GF_Box **) &stsd, bs, GF_ISOM_BOX_TYPE_STBL, GF_FALSE, 0);\n\tgf_bs_del(bs);\n\tif (!e && (stsd->type==GF_ISOM_BOX_TYPE_STSD)) {\n\t\ttmp = trak->Media->information->sampleTable->SampleDescription->child_boxes;\n\t\ttrak->Media->information->sampleTable->SampleDescription->child_boxes = stsd->child_boxes;\n\t\tstsd->child_boxes = tmp;\n\t}\n\tif (stsd) gf_isom_box_del((GF_Box*)stsd);\n\treturn e;\n}\n\nGF_EXPORT\nu32 gf_isom_new_track(GF_ISOFile *movie, GF_ISOTrackID trakID, u32 MediaType, u32 TimeScale)\n{\n\treturn gf_isom_new_track_from_template(movie, trakID, MediaType, TimeScale, NULL, 0, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_stream_description(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_SampleEntryBox *entry;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tentry = (GF_SampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex - 1);\n\tif (!entry) return GF_BAD_PARAM;\n\tgf_list_rem(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex - 1);\n\tgf_isom_box_del((GF_Box *)entry);\n\treturn GF_OK;\n}\n\n//Create a new StreamDescription in the file. The URL and URN are used to describe external media\nGF_EXPORT\nGF_Err gf_isom_new_mpeg4_description(GF_ISOFile *movie,\n                                     u32 trackNumber,\n                                     const GF_ESD *esd,\n                                     const char *URLname,\n                                     const char *URNname,\n                                     u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 dataRefIndex;\n\tGF_ESD *new_esd;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media ||\n\t        !esd || !esd->decoderConfig ||\n\t        !esd->slConfig) return GF_BAD_PARAM;\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(movie, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\t//duplicate our desc\n\te = gf_odf_desc_copy((GF_Descriptor *)esd, (GF_Descriptor **)&new_esd);\n\tif (e) return e;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\te = Track_SetStreamDescriptor(trak, 0, dataRefIndex, new_esd, outDescriptionIndex);\n\tif (e) {\n\t\tgf_odf_desc_del((GF_Descriptor *)new_esd);\n\t\treturn e;\n\t}\n\treturn e;\n}\n\nGF_Err gf_isom_flush_chunk(GF_TrackBox *trak, Bool is_final)\n{\n\tGF_Err e;\n\tu64 data_offset;\n\tu32 sample_number;\n\tu8 *chunk_data;\n\tu32 chunk_size, chunk_alloc;\n\tif (!trak->chunk_cache) return GF_OK;\n\n\tgf_bs_get_content_no_truncate(trak->chunk_cache, &chunk_data, &chunk_size, &chunk_alloc);\n\n\tdata_offset = gf_isom_datamap_get_offset(trak->Media->information->dataHandler);\n\n\te = gf_isom_datamap_add_data(trak->Media->information->dataHandler, chunk_data, chunk_size);\n\tif (e) return e;\n\n\tsample_number = 1 + trak->Media->information->sampleTable->SampleSize->sampleCount;\n\tsample_number -= trak->nb_samples_in_cache;\n\n\te = stbl_AddChunkOffset(trak->Media, sample_number, trak->chunk_stsd_idx, data_offset, trak->nb_samples_in_cache);\n\n\tif (is_final) {\n\t\tgf_free(chunk_data);\n\t\tgf_bs_del(trak->chunk_cache);\n\t\ttrak->chunk_cache = NULL;\n\t} else {\n\t\tgf_bs_reassign_buffer(trak->chunk_cache, chunk_data, chunk_alloc);\n\t}\n\treturn e;\n}\n\nstatic GF_Err trak_add_sample(GF_ISOFile *movie, GF_TrackBox *trak, const GF_ISOSample *sample, u32 descIndex, u64 data_offset, u32 syncShadowSampleNum)\n{\n\tBool skip_data = GF_FALSE;\n\tGF_Err e;\n\n\t//faststart mode with interleaving time, cache data until we have a full chunk\n\tif ((movie->storageMode==GF_ISOM_STORE_FASTSTART) && movie->interleavingTime) {\n\t\tBool flush_chunk = GF_FALSE;\n\t\tu64 stime = sample->DTS;\n\t\tstime *= movie->moov->mvhd->timeScale;\n\t\tstime /= trak->Media->mediaHeader->timeScale;\n\n\t\tif (stime - trak->first_dts_chunk > movie->interleavingTime)\n\t\t\tflush_chunk = GF_TRUE;\n\n\t\tif (movie->next_flush_chunk_time < stime)\n\t\t\tflush_chunk = GF_TRUE;\n\n\t\tif (trak->chunk_stsd_idx != descIndex)\n\t\t\tflush_chunk = GF_TRUE;\n\n\t\tif (trak->Media->information->sampleTable->MaxChunkSize && trak->Media->information->sampleTable->MaxChunkSize < trak->chunk_cache_size + sample->dataLength)\n\t\t\tflush_chunk = GF_TRUE;\n\n\t\tif (flush_chunk) {\n\t\t\tmovie->next_flush_chunk_time = stime + movie->interleavingTime;\n\t\t\tif (trak->chunk_cache) {\n\t\t\t\te = gf_isom_flush_chunk(trak, GF_FALSE);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\ttrak->nb_samples_in_cache = 0;\n\t\t\ttrak->chunk_cache_size = 0;\n\t\t\ttrak->first_dts_chunk = stime;\n\t\t}\n\t\tif (!trak->chunk_cache)\n\t\t\ttrak->chunk_cache = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_data(trak->chunk_cache, sample->data, sample->dataLength);\n\t\ttrak->nb_samples_in_cache += sample->nb_pack ? sample->nb_pack : 1;\n\t\ttrak->chunk_cache_size += sample->dataLength;\n\t\ttrak->chunk_stsd_idx = descIndex;\n\n\t\tskip_data = GF_TRUE;\n\t}\n\n\te = Media_AddSample(trak->Media, data_offset, sample, descIndex, syncShadowSampleNum);\n\tif (e) return e;\n\n\tif (!skip_data && sample->dataLength) {\n\t\te = gf_isom_datamap_add_data(trak->Media->information->dataHandler, sample->data, sample->dataLength);\n\t\tif (e) return e;\n\t}\n\n\treturn GF_OK;\n}\n\n//Add samples to a track. Use streamDescriptionIndex to specify the desired stream (if several)\nGF_EXPORT\nGF_Err gf_isom_add_sample(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, const GF_ISOSample *sample)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tu32 dataRefIndex;\n\tu64 data_offset;\n\tu32 descIndex;\n\tGF_DataEntryURLBox *Dentry;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = FlushCaptureMode(movie);\n\tif (e) return e;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\n\t//OK, add the sample\n\t//1- Get the streamDescriptionIndex and dataRefIndex\n\t//not specified, get the latest used...\n\tdescIndex = StreamDescriptionIndex;\n\tif (!StreamDescriptionIndex) {\n\t\tdescIndex = trak->Media->information->sampleTable->currentEntryIndex;\n\t}\n\te = Media_GetSampleDesc(trak->Media, descIndex, &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry || !dataRefIndex) return GF_BAD_PARAM;\n\t//set the current to this one\n\ttrak->Media->information->sampleTable->currentEntryIndex = descIndex;\n\n\n\t//get this dataRef and return false if not self contained\n\tDentry = (GF_DataEntryURLBox*)gf_list_get(trak->Media->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\tif (!Dentry || Dentry->flags != 1) return GF_BAD_PARAM;\n\n\t//Open our data map. We are adding stuff, so use EDIT\n\te = gf_isom_datamap_open(trak->Media, dataRefIndex, 1);\n\tif (e) return e;\n\n\t//Get the offset...\n\tdata_offset = gf_isom_datamap_get_offset(trak->Media->information->dataHandler);\n\n\t/*rewrite OD frame*/\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\tGF_ISOSample *od_sample = NULL;\n\n\t\te = Media_ParseODFrame(trak->Media, sample, &od_sample);\n\t\tif (e) return e;\n\n\t\te = trak_add_sample(movie, trak, od_sample, descIndex, data_offset, 0);\n\n\t\tif (od_sample)\n\t\t\tgf_isom_sample_del(&od_sample);\n\t} else {\n\t\te = trak_add_sample(movie, trak, sample, descIndex, data_offset, 0);\n\t}\n\tif (e) return e;\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\t//update media duration\n\tif ((s64)sample->DTS + sample->CTS_Offset>=0) {\n\t\tGF_TimeToSampleBox *stts = trak->Media->information->sampleTable->TimeToSample;\n\t\tu64 dur = sample->DTS + sample->CTS_Offset;\n\t\tdur += stts->entries[stts->nb_entries-1].sampleDelta;\n\n\t\tif (dur > trak->Media->mediaHeader->duration) {\n\t\t\ttrak->Media->mediaHeader->duration = dur;\n\t\t}\n\t}\n\t//do not update track duration yet, this is done on close\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_sample_shadow(GF_ISOFile *movie, u32 trackNumber, GF_ISOSample *sample)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *prev;\n\tGF_SampleEntryBox *entry;\n\tu32 dataRefIndex;\n\tu64 data_offset;\n\tu32 descIndex;\n\tu32 sampleNum, prevSampleNum;\n\tGF_DataEntryURLBox *Dentry;\n\tBool offset_times = GF_FALSE;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !sample) return GF_BAD_PARAM;\n\n\te = FlushCaptureMode(movie);\n\tif (e) return e;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\n\te = stbl_findEntryForTime(trak->Media->information->sampleTable, sample->DTS, 0, &sampleNum, &prevSampleNum);\n\tif (e) return e;\n\t/*we need the EXACT match*/\n\tif (!sampleNum) return GF_BAD_PARAM;\n\n\tprev = gf_isom_get_sample_info(movie, trackNumber, sampleNum, &descIndex, NULL);\n\tif (!prev) return gf_isom_last_error(movie);\n\t/*for conformance*/\n\tif (sample->DTS==prev->DTS) offset_times = GF_TRUE;\n\tgf_isom_sample_del(&prev);\n\n\te = Media_GetSampleDesc(trak->Media, descIndex, &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry || !dataRefIndex) return GF_BAD_PARAM;\n\ttrak->Media->information->sampleTable->currentEntryIndex = descIndex;\n\n\t//get this dataRef and return false if not self contained\n\tDentry = (GF_DataEntryURLBox*)gf_list_get(trak->Media->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\tif (!Dentry || Dentry->flags != 1) return GF_BAD_PARAM;\n\n\t//Open our data map. We are adding stuff, so use EDIT\n\te = gf_isom_datamap_open(trak->Media, dataRefIndex, 1);\n\tif (e) return e;\n\n\tdata_offset = gf_isom_datamap_get_offset(trak->Media->information->dataHandler);\n\tif (offset_times) sample->DTS += 1;\n\n\t/*REWRITE ANY OD STUFF*/\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\tGF_ISOSample *od_sample = NULL;\n\t\te = Media_ParseODFrame(trak->Media, sample, &od_sample);\n\t\tif (e) return e;\n\n\t\te = trak_add_sample(movie, trak, od_sample, descIndex, data_offset, sampleNum);\n\t\tif (od_sample)\n\t\t\tgf_isom_sample_del(&od_sample);\n\t} else {\n\t\te = trak_add_sample(movie, trak, sample, descIndex, data_offset, sampleNum);\n\t}\n\tif (e) return e;\n\tif (offset_times) sample->DTS -= 1;\n\n\t//OK, update duration\n\te = Media_SetDuration(trak);\n\tif (e) return e;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\treturn SetTrackDuration(trak);\n}\n\nGF_EXPORT\nGF_Err gf_isom_append_sample_data(GF_ISOFile *movie, u32 trackNumber, u8 *data, u32 data_size)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tu32 dataRefIndex;\n\tu32 descIndex;\n\tGF_DataEntryURLBox *Dentry;\n\n\tif (!data_size) return GF_OK;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) return GF_BAD_PARAM;\n\n\t//OK, add the sample\n\tdescIndex = trak->Media->information->sampleTable->currentEntryIndex;\n\n\te = Media_GetSampleDesc(trak->Media, descIndex, &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry || !dataRefIndex) return GF_BAD_PARAM;\n\n\t//get this dataRef and return false if not self contained\n\tDentry = (GF_DataEntryURLBox*)gf_list_get(trak->Media->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\tif (!Dentry || Dentry->flags != 1) return GF_BAD_PARAM;\n\n\t//Open our data map. We are adding stuff, so use EDIT\n\te = gf_isom_datamap_open(trak->Media, dataRefIndex, 1);\n\tif (e) return e;\n\n\t//add the media data\n\tif (trak->chunk_cache) {\n\t\tgf_bs_write_data(trak->chunk_cache, data, data_size);\n\t\ttrak->chunk_cache_size += data_size;\n\t} else {\n\t\te = gf_isom_datamap_add_data(trak->Media->information->dataHandler, data, data_size);\n\t\tif (e) return e;\n\t}\n\t//update data size\n\treturn stbl_SampleSizeAppend(trak->Media->information->sampleTable->SampleSize, data_size);\n}\n\n\n//Add sample reference to a track. The SampleOffset is the offset of the data in the referenced file\n//you must have created a StreamDescription with URL or URN specifying your referenced file\n//the data offset specifies the beginning of the chunk\n//Use streamDescriptionIndex to specify the desired stream (if several)\nGF_EXPORT\nGF_Err gf_isom_add_sample_reference(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, GF_ISOSample *sample, u64 dataOffset)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tu32 dataRefIndex;\n\tu32 descIndex;\n\tGF_DataEntryURLBox *Dentry;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\n\t//OD is not allowed as a data ref\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\t//OK, add the sample\n\t//1- Get the streamDescriptionIndex and dataRefIndex\n\t//not specified, get the latest used...\n\tdescIndex = StreamDescriptionIndex;\n\tif (!StreamDescriptionIndex) {\n\t\tdescIndex = trak->Media->information->sampleTable->currentEntryIndex;\n\t}\n\te = Media_GetSampleDesc(trak->Media, descIndex, &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry || !dataRefIndex) return GF_BAD_PARAM;\n\t//set the current to this one\n\ttrak->Media->information->sampleTable->currentEntryIndex = descIndex;\n\n\n\t//get this dataRef and return false if self contained\n\tDentry =(GF_DataEntryURLBox*) gf_list_get(trak->Media->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\tif (Dentry->flags == 1) return GF_BAD_PARAM;\n\n\t//add the meta data\n\te = Media_AddSample(trak->Media, dataOffset, sample, descIndex, 0);\n\tif (e) return e;\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\t//OK, update duration\n\te = Media_SetDuration(trak);\n\tif (e) return e;\n\treturn SetTrackDuration(trak);\n\n}\n\n//set the duration of the last media sample. If not set, the duration of the last sample is the\n//duration of the previous one if any, or 1000 (default value).\nstatic GF_Err gf_isom_set_last_sample_duration_internal(GF_ISOFile *movie, u32 trackNumber, u64 dur_num, u32 dur_den, u32 mode)\n{\n\tGF_TrackBox *trak;\n\tGF_SttsEntry *ent;\n\tGF_TimeToSampleBox *stts;\n\tu64 mdur;\n\tu32 duration;\n\tGF_Err e;\n\tBool is_patch = GF_FALSE;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (mode==0) {\n\t\tduration = (u32) dur_num;\n\t} else if (mode==1) {\n\t\tduration = (u32) dur_num;\n\t\tif (dur_den) {\n\t\t\tduration *= trak->Media->mediaHeader->timeScale;\n\t\t\tduration /= dur_den;\n\t\t}\n\t} else {\n\t\tis_patch = GF_TRUE;\n\t}\n\tmdur = trak->Media->mediaHeader->duration;\n\tstts = trak->Media->information->sampleTable->TimeToSample;\n\tif (!stts->nb_entries) return GF_BAD_PARAM;\n\n\tif (is_patch) {\n\t\tu32 i, avg_dur, nb_samp=0;\n\t\tu64 cum_dur=0;\n\t\tfor (i=0; i<stts->nb_entries; i++) {\n\t\t\tent = (GF_SttsEntry*) &stts->entries[i];\n\t\t\tcum_dur += ent->sampleCount*ent->sampleDelta;\n\t\t\tnb_samp += ent->sampleCount;\n\t\t}\n\t\tif (cum_dur <= dur_num || !nb_samp) return GF_OK;\n\t\tavg_dur = (u32) (dur_num / nb_samp);\n\n\t\tstts->entries[0].sampleDelta = avg_dur;\n\t\tstts->entries[0].sampleCount = nb_samp;\n\t\tstts->nb_entries = 1;\n\t\tstts->w_LastDTS = dur_num - avg_dur;\n\t\treturn GF_OK;\n\t}\n\t//get the last entry\n\tent = (GF_SttsEntry*) &stts->entries[stts->nb_entries-1];\n\tif ((mode==1) && !duration && !dur_den) {\n\t\t//same as previous, nothing to adjust\n\t\tif (ent->sampleCount>1) return GF_OK;\n\t\tif (stts->nb_entries==1) return GF_OK;\n\t\tduration = stts->entries[stts->nb_entries-2].sampleDelta;\n\t}\n\n\tmdur -= ent->sampleDelta;\n\tmdur += duration;\n\n\t//we only have one sample\n\tif (ent->sampleCount == 1) {\n\t\tent->sampleDelta = (u32) duration;\n\t\tif (mode && (stts->nb_entries>1) && (stts->entries[stts->nb_entries-2].sampleDelta==duration)) {\n\t\t\tstts->entries[stts->nb_entries-2].sampleCount++;\n\t\t\tstts->nb_entries--;\n\t\t\t//and update the write cache\n\t\t\tstts->w_currentSampleNum = trak->Media->information->sampleTable->SampleSize->sampleCount;\n\t\t}\n\t} else {\n\t\tif (ent->sampleDelta == duration) return GF_OK;\n\t\tent->sampleCount -= 1;\n\n\t\tif (stts->nb_entries==stts->alloc_size) {\n\t\t\tstts->alloc_size++;\n\t\t\tstts->entries = (GF_SttsEntry*)gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);\n\t\t\tif (!stts->entries) return GF_OUT_OF_MEM;\n\t\t}\n\t\tstts->entries[stts->nb_entries].sampleCount = 1;\n\t\tstts->entries[stts->nb_entries].sampleDelta = (u32) duration;\n\t\tstts->nb_entries++;\n\t\t//and update the write cache\n\t\tstts->w_currentSampleNum = trak->Media->information->sampleTable->SampleSize->sampleCount;\n\t}\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\t//update media duration if duration was set\n\tif (trak->Media->mediaHeader->duration)\n\t\ttrak->Media->mediaHeader->duration = mdur;\n\t//do not update track duration yet, this is done on close\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_last_sample_duration(GF_ISOFile *movie, u32 trackNumber, u32 duration)\n{\n\treturn gf_isom_set_last_sample_duration_internal(movie, trackNumber, duration, 0, 0);\n}\n\nGF_EXPORT\nGF_Err gf_isom_patch_last_sample_duration(GF_ISOFile *movie, u32 trackNumber, u64 next_dts)\n{\n\treturn gf_isom_set_last_sample_duration_internal(movie, trackNumber, next_dts, 0, 2);\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_last_sample_duration_ex(GF_ISOFile *movie, u32 trackNumber, u32 dur_num, u32 dur_den)\n{\n\treturn gf_isom_set_last_sample_duration_internal(movie, trackNumber, dur_num, dur_den, 1);\n}\n\n//update a sample data in the media. Note that the sample MUST exists\nGF_EXPORT\nGF_Err gf_isom_update_sample(GF_ISOFile *movie, u32 trackNumber, u32 sampleNumber, GF_ISOSample *sample, Bool data_only)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_EDIT);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\n\t//block for hint tracks\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_HINT) return GF_BAD_PARAM;\n\n\t//REWRITE ANY OD STUFF\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\tGF_ISOSample *od_sample = NULL;\n\t\te = Media_ParseODFrame(trak->Media, sample, &od_sample);\n\t\tif (!e) e = Media_UpdateSample(trak->Media, sampleNumber, od_sample, data_only);\n\t\tif (od_sample) gf_isom_sample_del(&od_sample);\n\t} else {\n\t\te = Media_UpdateSample(trak->Media, sampleNumber, sample, data_only);\n\t}\n\tif (e) return e;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tgf_isom_disable_inplace_rewrite(movie);\n\treturn GF_OK;\n}\n\n//update a sample data in the media. Note that the sample MUST exists,\n//that sample->data MUST be NULL and sample->dataLength must be NON NULL;\nGF_EXPORT\nGF_Err gf_isom_update_sample_reference(GF_ISOFile *movie, u32 trackNumber, u32 sampleNumber, GF_ISOSample *sample, u64 data_offset)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_EDIT);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//block for hint tracks\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_HINT) return GF_BAD_PARAM;\n\n\tif (!sampleNumber || !sample) return GF_BAD_PARAM;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\n\t//OD is not allowed as a data ref\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\t//OK, update it\n\te = Media_UpdateSampleReference(trak->Media, sampleNumber, sample, data_offset);\n\tif (e) return e;\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\treturn GF_OK;\n}\n\n//for gf_isom_remove_sample and gf_isom_remove_track: check all items sharing their data with a sample being removed\n//and remove sharing flag\n// sample_number can be 0 for complete track removal\nstatic void gf_isom_meta_track_remove(GF_ISOFile *movie, GF_TrackBox *trak, u32 sample_number)\n{\n\tu32 i, count;\n\tif (!movie || !movie->meta || !movie->meta->use_item_sample_sharing)\n\t\treturn;\n\n\tcount = gf_list_count(movie->meta->item_locations->location_entries);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j;\n\t\tGF_ItemLocationEntry *iloc = (GF_ItemLocationEntry *)gf_list_get(movie->meta->item_locations->location_entries, i);\n\t\t/*get item info*/\n\t\tGF_ItemInfoEntryBox *iinf = NULL;\n\t\tj=0;\n\t\twhile ((iinf = (GF_ItemInfoEntryBox *)gf_list_enum(movie->meta->item_infos->item_infos, &j))) {\n\t\t\tif (iinf->item_ID==iloc->item_ID) break;\n\t\t}\n\t\tif (!iinf || !iinf->tk_id) continue;\n\t\tif (iinf->tk_id != trak->Header->trackID) continue;\n\n\t\tif (sample_number && (iinf->sample_num != sample_number)) continue;\n\t\tiinf->tk_id = 0;\n\t\tiinf->sample_num = 0;\n\t}\n}\n\n\n\n//Remove a given sample\nGF_EXPORT\nGF_Err gf_isom_remove_sample(GF_ISOFile *movie, u32 trackNumber, u32 sampleNumber)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_EDIT);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !sampleNumber || (sampleNumber > trak->Media->information->sampleTable->SampleSize->sampleCount) )\n\t\treturn GF_BAD_PARAM;\n\n\t//block for hint tracks\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_HINT) return GF_BAD_PARAM;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\t//do NOT change the order DTS, CTS, size chunk\n\n\t//remove DTS\n\te = stbl_RemoveDTS(trak->Media->information->sampleTable, sampleNumber, 1, trak->Media->mediaHeader->timeScale);\n\tif (e) return e;\n\t//remove CTS if any\n\tif (trak->Media->information->sampleTable->CompositionOffset) {\n\t\te = stbl_RemoveCTS(trak->Media->information->sampleTable, sampleNumber, 1);\n\t\tif (e) return e;\n\t}\n\t//remove size\n\te = stbl_RemoveSize(trak->Media->information->sampleTable, sampleNumber, 1);\n\tif (e) return e;\n\t//remove sampleToChunk and chunk\n\te = stbl_RemoveChunk(trak->Media->information->sampleTable, sampleNumber, 1);\n\tif (e) return e;\n\t//remove sync\n\tif (trak->Media->information->sampleTable->SyncSample) {\n\t\te = stbl_RemoveRAP(trak->Media->information->sampleTable, sampleNumber);\n\t\tif (e) return e;\n\t}\n\t//remove sample dep\n\tif (trak->Media->information->sampleTable->SampleDep) {\n\t\te = stbl_RemoveRedundant(trak->Media->information->sampleTable, sampleNumber, 1);\n\t\tif (e) return e;\n\t}\n\t//remove shadow\n\te = stbl_RemoveShadow(trak->Media->information->sampleTable, sampleNumber);\n\tif (e) return e;\n\n\t//remove padding\n\te = stbl_RemovePaddingBits(trak->Media->information->sampleTable, sampleNumber);\n\tif (e) return e;\n\n\te = stbl_RemoveSubSample(trak->Media->information->sampleTable, sampleNumber);\n\tif (e) return e;\n\n\te = stbl_RemoveSampleGroup(trak->Media->information->sampleTable, sampleNumber);\n\tif (e) return e;\n\n\tgf_isom_disable_inplace_rewrite(movie);\n\n\tgf_isom_meta_track_remove(movie, trak, sampleNumber);\n\n\treturn SetTrackDuration(trak);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_final_name(GF_ISOFile *movie, char *filename)\n{\n\tGF_Err e;\n\tif (!movie ) return GF_BAD_PARAM;\n\n\t//if mode is not OPEN_EDIT file was created under the right name\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_EDIT);\n\tif (e) return e;\n\n\tif (filename) {\n\t\t//we don't allow file overwriting\n\t\tif ( (movie->openMode == GF_ISOM_OPEN_EDIT)\n\t\t        && movie->fileName && !strcmp(filename, movie->fileName))\n\t\t\treturn GF_BAD_PARAM;\n\t\tif (movie->finalName) gf_free(movie->finalName);\n\t\tmovie->finalName = gf_strdup(filename);\n\t\tif (!movie->finalName) return GF_OUT_OF_MEM;\n\t\tgf_isom_disable_inplace_rewrite(movie);\n\t}\n\treturn GF_OK;\n}\n\n//Add a system descriptor to the ESD of a stream(EDIT or WRITE mode only)\nGF_EXPORT\nGF_Err gf_isom_add_desc_to_description(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, const GF_Descriptor *theDesc)\n{\n\tGF_IPIPtr *ipiD;\n\tGF_Err e;\n\tu16 tmpRef;\n\tGF_TrackBox *trak;\n\tGF_Descriptor *desc;\n\tGF_ESD *esd;\n\tGF_TrackReferenceBox *tref;\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tu32 msubtype;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t/*GETS NATIVE DESCRIPTOR ONLY*/\n\te = Media_GetESD(trak->Media, StreamDescriptionIndex, &esd, GF_TRUE);\n\tif (e) return e;\n\n\tentry = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tmsubtype = entry->type;\n\tif ((msubtype==GF_ISOM_BOX_TYPE_ENCV) || (msubtype==GF_ISOM_BOX_TYPE_ENCA))\n\t\tgf_isom_get_original_format_type(movie, trackNumber, StreamDescriptionIndex, &msubtype);\n\n\t//duplicate the desc\n\te = gf_odf_desc_copy((GF_Descriptor *)theDesc, &desc);\n\tif (e) return e;\n\n\t//and add it to the ESD EXCEPT IPI PTR (we need to translate from ES_ID to TrackID!!!\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tswitch (desc->tag) {\n\tcase GF_ODF_IPI_PTR_TAG:\n\t\tgoto insertIPI;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif ((msubtype==GF_ISOM_BOX_TYPE_MP4S) || (msubtype==GF_ISOM_BOX_TYPE_MP4V) || (msubtype==GF_ISOM_BOX_TYPE_MP4A)) {\n\t\treturn gf_odf_desc_add_desc((GF_Descriptor *)esd, desc);\n\t}\n\n\tif (trak->Media->handler->handlerType!=GF_ISOM_MEDIA_VISUAL) {\n\t\tgf_odf_desc_del(desc);\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tGF_MPEG4ExtensionDescriptorsBox *mdesc = (GF_MPEG4ExtensionDescriptorsBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_M4DS);\n\tif (!mdesc) {\n\t\tmdesc = (GF_MPEG4ExtensionDescriptorsBox *) gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_M4DS);\n\t}\n\treturn gf_list_add(mdesc->descriptors, desc);\n\ninsertIPI:\n\tif (esd->ipiPtr) {\n\t\tgf_odf_desc_del((GF_Descriptor *) esd->ipiPtr);\n\t\tesd->ipiPtr = NULL;\n\t}\n\n\tipiD = (GF_IPIPtr *) desc;\n\t//find a tref\n\tif (!trak->References) {\n\t\ttref = (GF_TrackReferenceBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TREF);\n\t\tif (!tref) return GF_OUT_OF_MEM;\n\t\te = trak_on_child_box((GF_Box*)trak, (GF_Box *)tref, GF_FALSE);\n\t\tif (e) return e;\n\t}\n\ttref = trak->References;\n\n\te = Track_FindRef(trak, GF_ISOM_REF_IPI, &dpnd);\n\tif (e) return e;\n\tif (!dpnd) {\n\t\ttmpRef = 0;\n\t\tdpnd = (GF_TrackReferenceTypeBox *) gf_isom_box_new_parent(&tref->child_boxes, GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!dpnd) return GF_OUT_OF_MEM;\n\t\tdpnd->reference_type = GF_ISOM_BOX_TYPE_IPIR;\n\t\te = reftype_AddRefTrack(dpnd, ipiD->IPI_ES_Id, &tmpRef);\n\t\tif (e) return e;\n\t\t//and replace the tag and value...\n\t\tipiD->IPI_ES_Id = tmpRef;\n\t\tipiD->tag = GF_ODF_ISOM_IPI_PTR_TAG;\n\t} else {\n\t\t//Watch out! ONLY ONE IPI dependency is allowed per stream\n\t\tdpnd->trackIDCount = 1;\n\t\tdpnd->trackIDs[0] = ipiD->IPI_ES_Id;\n\t\t//and replace the tag and value...\n\t\tipiD->IPI_ES_Id = 1;\n\t\tipiD->tag = GF_ODF_ISOM_IPI_PTR_TAG;\n\t}\n\t//and add the desc to the esd...\n\treturn gf_odf_desc_add_desc((GF_Descriptor *)esd, desc);\n}\n\n\n//use carefully. Very useful when you made a lot of changes (IPMP, IPI, OCI, ...)\n//THIS WILL REPLACE THE WHOLE DESCRIPTOR ...\nGF_EXPORT\nGF_Err gf_isom_change_mpeg4_description(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, const GF_ESD *newESD)\n{\n\tGF_Err e;\n\tGF_ESD *esd;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\t//duplicate our desc\n\te = gf_odf_desc_copy((GF_Descriptor *)newESD, (GF_Descriptor **)&esd);\n\tif (e) return e;\n\te = Track_SetStreamDescriptor(trak, StreamDescriptionIndex, entry->dataReferenceIndex, esd, NULL);\n\tif (e != GF_OK) {\n\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t}\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_visual_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 Width, u32 Height)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) {\n\t\treturn movie->LastError = GF_ISOM_INVALID_FILE;\n\t}\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type == GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t((GF_VisualSampleEntryBox*)entry)->Width = Width;\n\t\t((GF_VisualSampleEntryBox*)entry)->Height = Height;\n\t\ttrak->Header->width = Width<<16;\n\t\ttrak->Header->height = Height<<16;\n\t\treturn GF_OK;\n\t} else if (trak->Media->handler->handlerType==GF_ISOM_MEDIA_SCENE) {\n\t\ttrak->Header->width = Width<<16;\n\t\ttrak->Header->height = Height<<16;\n\t\treturn GF_OK;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_visual_bit_depth(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u16 bitDepth)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_VISUAL:\n\tcase GF_ISOM_MEDIA_PICT:\n\tcase GF_ISOM_MEDIA_AUXV:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_OK;\n\t}\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) {\n\t\treturn movie->LastError = GF_ISOM_INVALID_FILE;\n\t}\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_MPEGVisualSampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tentry->bit_depth = bitDepth;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_pixel_aspect_ratio(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, s32 hSpacing, s32 vSpacing, Bool force_par)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tif (hSpacing<0) hSpacing = 1;\n\tif (vSpacing<0) vSpacing = 1;\n\n\tGF_PixelAspectRatioBox *pasp = (GF_PixelAspectRatioBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_PASP);\n\tif (!hSpacing || !vSpacing || ((hSpacing == vSpacing) && !force_par))  {\n\t\tif (pasp) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box *)pasp);\n\t\treturn GF_OK;\n\t}\n\tif (!pasp) {\n\t\tpasp = (GF_PixelAspectRatioBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_PASP);\n\t\tif (!pasp) return GF_OUT_OF_MEM;\n\t}\n\tpasp->hSpacing = (u32) hSpacing;\n\tpasp->vSpacing = (u32) vSpacing;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_visual_color_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 colour_type, u16 colour_primaries, u16 transfer_characteristics, u16 matrix_coefficients, Bool full_range_flag, u8 *icc_data, u32 icc_size)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_ColourInformationBox *clr=NULL;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_OK;\n\n\tclr = (GF_ColourInformationBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_COLR);\n\tif (!colour_type) {\n\t\tif (clr) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box *)clr);\n\t\treturn GF_OK;\n\t}\n\tif (clr) {\n\t\t//create another color box\n\t\tif (clr->opaque && !icc_data) clr = NULL;\n\t\telse if (!clr->opaque && icc_data) clr = NULL;\n\t}\n\n\tif (!clr) {\n\t\tclr = (GF_ColourInformationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_COLR);\n\t\tif (!clr) return GF_OUT_OF_MEM;\n\t}\n\tclr->colour_type = colour_type;\n\tclr->colour_primaries = colour_primaries;\n\tclr->transfer_characteristics = transfer_characteristics;\n\tclr->matrix_coefficients = matrix_coefficients;\n\tclr->full_range_flag = full_range_flag;\n\tif (clr->opaque) gf_free(clr->opaque);\n\tclr->opaque = NULL;\n\tclr->opaque_size = 0;\n\tif ((colour_type==GF_ISOM_SUBTYPE_RICC) || (colour_type==GF_ISOM_SUBTYPE_PROF)) {\n\t\tclr->opaque_size = icc_data ? icc_size : 0;\n\t\tif (clr->opaque_size) {\n\t\t\tclr->opaque = gf_malloc(sizeof(char)*clr->opaque_size);\n\t\t\tif (!clr->opaque) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(clr->opaque, icc_data, sizeof(char)*clr->opaque_size);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_dolby_vision_profile(GF_ISOFile* movie, u32 trackNumber, u32 StreamDescriptionIndex, GF_DOVIDecoderConfigurationRecord *dvcc)\n{\n\tGF_Err e;\n\tGF_TrackBox* trak;\n\tGF_Box *dv_cfge = NULL;\n\tGF_MPEGVisualSampleEntryBox* entry;\n\tBool switch_type = GF_FALSE;\n\tBool is_avc = GF_FALSE;\n\tGF_SampleDescriptionBox* stsd;\n\tGF_DOVIConfigurationBox* dovi = NULL;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_OK;\n\n\tif (dvcc) {\n\t\tswitch_type = dvcc->force_dv;\n\t\tswitch (dvcc->dv_profile) {\n\t\tcase 1:\n\t\tcase 3:\n\t\tcase 5:\n\t\t\tswitch_type = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HEV2:\n\tcase GF_ISOM_BOX_TYPE_DVHE:\n\t\tentry->type = switch_type ? GF_ISOM_BOX_TYPE_DVHE : GF_ISOM_BOX_TYPE_HEV1;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HVC2:\n\tcase GF_ISOM_BOX_TYPE_DVH1:\n\t\tentry->type = switch_type ? GF_ISOM_BOX_TYPE_DVH1 : GF_ISOM_BOX_TYPE_HVC1;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_DVA1:\n\t\tis_avc = GF_TRUE;\n\t\tentry->type = switch_type ? GF_ISOM_BOX_TYPE_DVA1 : GF_ISOM_BOX_TYPE_AVC1;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_DVAV:\n\t\tis_avc = GF_TRUE;\n\t\tentry->type = switch_type ? GF_ISOM_BOX_TYPE_DVAV : GF_ISOM_BOX_TYPE_AVC3;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AV01:\n\tcase GF_ISOM_BOX_TYPE_DAV1:\n\t\tentry->type = switch_type ? GF_ISOM_BOX_TYPE_DAV1 : GF_ISOM_BOX_TYPE_AV01;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tu32 dve_type = is_avc ? GF_ISOM_BOX_TYPE_AVCE : GF_ISOM_BOX_TYPE_HVCE;\n\tdv_cfge = gf_isom_box_find_child(entry->child_boxes, dve_type);\n\n\tdovi = entry->dovi_config;\n\tif (!dvcc) {\n\t\tif (dovi) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)dovi);\n\t\tentry->dovi_config = NULL;\n\n\t\tif (dv_cfge) gf_isom_box_del_parent(&entry->child_boxes, dv_cfge);\n\t\t//reverse entry type\n\t\tswitch (entry->type) {\n\t\tcase GF_ISOM_BOX_TYPE_DVHE:\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_HEV1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DVH1:\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_HVC1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DVA1:\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_AVC1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DVAV:\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_AVC3;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DAV1:\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_AV01;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (!dovi) {\n\t\tdovi = (GF_DOVIConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_DVCC);\n\t\tif (!dovi) return GF_OUT_OF_MEM;\n\t\tentry->dovi_config = dovi;\n\t}\n\tif (dvcc->dv_profile < 8) {\n\t\tdovi->type = GF_ISOM_BOX_TYPE_DVCC;\n\t} else {\n\t\tdovi->type = GF_ISOM_BOX_TYPE_DVVC;\n\t}\n\tdovi->DOVIConfig = *dvcc;\n\n\tif (dv_cfge) gf_isom_box_del_parent(&entry->child_boxes, dv_cfge);\n\tdv_cfge = NULL;\n\n\t//inject avcE / hvcE if enhancement layer and RPU present in single-track case\n\t//not clear from the spec what is supposed to be in these, we just clone avcC/hvcC\n\tif (dvcc->bl_present_flag && dvcc->el_present_flag && dvcc->rpu_present_flag) {\n\t\tGF_Box *src = is_avc ? (GF_Box *)entry->avc_config : (GF_Box *)entry->hevc_config;\n\t\tif (!src) return GF_BAD_PARAM;\n\t\te = gf_isom_clone_box(src, &dv_cfge);\n\t\tif (e) return e;\n\t\tdv_cfge->type = dve_type;\n\t\tgf_list_add(entry->child_boxes, dv_cfge);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_high_dynamic_range_info(GF_ISOFile* movie, u32 trackNumber, u32 StreamDescriptionIndex, GF_MasteringDisplayColourVolumeInfo* mdcv, GF_ContentLightLevelInfo* clli)\n{\n\tGF_Err e;\n\tGF_TrackBox* trak;\n\tGF_SampleEntryBox* entry;\n\tGF_SampleDescriptionBox* stsd;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox*)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_MasteringDisplayColourVolumeBox *mdcvb = (GF_MasteringDisplayColourVolumeBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_MDCV);\n\tif (mdcv) {\n\t\tif (!mdcvb) {\n\t\t\tmdcvb = (GF_MasteringDisplayColourVolumeBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_MDCV);\n\t\t\tif (!mdcvb) return GF_OUT_OF_MEM;\n\t\t}\n\t\tmdcvb->mdcv = *mdcv;\n\t} else {\n\t\tif (mdcvb) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box *) mdcvb);\n\t}\n\n\t/*clli*/\n\tGF_ContentLightLevelBox *cllib = (GF_ContentLightLevelBox *)gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_CLLI);\n\tif (clli) {\n\t\tif (!cllib) {\n\t\t\tcllib = (GF_ContentLightLevelBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_CLLI);\n\t\t\tif (!cllib) return GF_OUT_OF_MEM;\n\t\t}\n\t\tcllib->clli = *clli;\n\t} else {\n\t\tif (cllib) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box *) cllib);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_clean_aperture(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 cleanApertureWidthN, u32 cleanApertureWidthD, u32 cleanApertureHeightN, u32 cleanApertureHeightD, s32 horizOffN, u32 horizOffD, s32 vertOffN, u32 vertOffD)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_CleanApertureBox *clap = (GF_CleanApertureBox *)gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_CLAP);\n\tif (!cleanApertureHeightD || !cleanApertureWidthD || !horizOffD || !vertOffD) {\n\t\tif (clap) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)clap);\n\t\treturn GF_OK;\n\t}\n\tif (!clap) {\n\t\tclap = (GF_CleanApertureBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_CLAP);\n\t\tif (!clap) return GF_OUT_OF_MEM;\n\t}\n\n\tclap->cleanApertureWidthN = cleanApertureWidthN;\n\tclap->cleanApertureWidthD = cleanApertureWidthD;\n\tclap->cleanApertureHeightN = cleanApertureHeightN;\n\tclap->cleanApertureHeightD = cleanApertureHeightD;\n\tclap->horizOffN = horizOffN;\n\tclap->horizOffD = horizOffD;\n\tclap->vertOffN = vertOffN;\n\tclap->vertOffD = vertOffD;\n\treturn GF_OK;\n}\n\n#include <gpac/maths.h>\nGF_Err gf_isom_update_aperture_info(GF_ISOFile *movie, u32 trackNumber, Bool remove)\n{\n\tGF_Err e;\n\tGF_Box *box, *enof, *prof, *clef;\n\tGF_TrackBox *trak;\n\tGF_VisualSampleEntryBox *ventry;\n\tGF_PixelAspectRatioBox *pasp;\n\tGF_CleanApertureBox *clap;\n\tu32 j, hspacing, vspacing, clap_width_num, clap_width_den, clap_height_num, clap_height_den, high, low;\n\tDouble width, height;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (remove) {\n\t\tif (trak->Aperture) {\n\t\t\tgf_isom_box_del(trak->Aperture);\n\t\t\ttrak->Aperture = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tenof = prof = clef = NULL;\n\tif (!trak->Aperture) {\n\t\ttrak->Aperture = gf_isom_box_new_parent(&trak->child_boxes, GF_QT_BOX_TYPE_TAPT);\n\t\tif (!trak->Aperture) return GF_OUT_OF_MEM;\n\t}\n\tif (!trak->Aperture->child_boxes) {\n\t\ttrak->Aperture->child_boxes = gf_list_new();\n\t\tif (!trak->Aperture->child_boxes)\n\t\t\treturn GF_OUT_OF_MEM;\n\t}\n\n\tj=0;\n\twhile ( (box = gf_list_enum(trak->Aperture->child_boxes, &j))) {\n\t\tswitch (box->type) {\n\t\tcase GF_QT_BOX_TYPE_CLEF: clef = box; break;\n\t\tcase GF_QT_BOX_TYPE_PROF: prof = box; break;\n\t\tcase GF_QT_BOX_TYPE_ENOF: enof = box; break;\n\t\t}\n\t}\n\tif (!clef) {\n\t\tclef = gf_isom_box_new(GF_QT_BOX_TYPE_CLEF);\n\t\tif (!clef) return GF_OUT_OF_MEM;\n\t\tgf_list_add(trak->Aperture->child_boxes, clef);\n\t}\n\tif (!enof) {\n\t\tenof = gf_isom_box_new(GF_QT_BOX_TYPE_ENOF);\n\t\tif (!enof) return GF_OUT_OF_MEM;\n\t\tgf_list_add(trak->Aperture->child_boxes, enof);\n\t}\n\tif (!prof) {\n\t\tprof = gf_isom_box_new(GF_QT_BOX_TYPE_PROF);\n\t\tif (!prof) return GF_OUT_OF_MEM;\n\t\tgf_list_add(trak->Aperture->child_boxes, prof);\n\t}\n\n\tventry = (GF_VisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (ventry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (ventry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tpasp = (GF_PixelAspectRatioBox *) gf_isom_box_find_child(ventry->child_boxes, GF_ISOM_BOX_TYPE_PASP);\n\thspacing = vspacing = 0;\n\tif (pasp) {\n\t\thspacing = pasp->hSpacing;\n\t\tvspacing = pasp->vSpacing;\n\t}\n\tclap_width_num = ventry->Width;\n\tclap_width_den = 1;\n\tclap_height_num = ventry->Height;\n\tclap_height_den = 1;\n\tclap = (GF_CleanApertureBox *) gf_isom_box_find_child(ventry->child_boxes, GF_ISOM_BOX_TYPE_CLAP);\n\tif (clap) {\n\t\tclap_width_num = clap->cleanApertureWidthN;\n\t\tclap_width_den = clap->cleanApertureWidthD;\n\t\tclap_height_num = clap->cleanApertureHeightN;\n\t\tclap_height_den = clap->cleanApertureHeightD;\n\t}\n\t//enof: encoded pixels in 16.16\n\t((GF_ApertureBox *)enof)->width = (ventry->Width)<<16;\n\t((GF_ApertureBox *)enof)->height = (ventry->Height)<<16;\n\n\t//prof: encoded pixels + pasp in 16.16\n\twidth = (Float) (ventry->Width * hspacing);\n\twidth /= vspacing;\n\thigh = (u32) floor((Float)width);\n\tlow = (u32) ( 0xFFFF * (width - (Double)high) );\n\t((GF_ApertureBox *)prof)->width = (high)<<16 | low;\n\t((GF_ApertureBox *)prof)->height = (ventry->Height)<<16;\n\n\t//clef: encoded pixels + pasp + clap in 16.16\n\twidth = (Double) (clap_width_num * hspacing);\n\twidth /= clap_width_den * vspacing;\n\theight = (Float) clap_height_num;\n\theight /= clap_height_den;\n\n\thigh = (u32) floor((Float)width);\n\tlow = (u32) (0xFFFF * (width - (Double)high));\n\t((GF_ApertureBox *)clef)->width = (high)<<16 | low;\n\thigh = (u32) floor((Float)height);\n\tlow = (u32) (0xFFFF * (height - (Double)high));\n\t((GF_ApertureBox *)clef)->height = (high)<<16 | low;\n\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_image_sequence_coding_constraints(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, Bool remove, Bool all_ref_pics_intra, Bool intra_pred_used, u32 max_ref_per_pic)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_CodingConstraintsBox*ccst = (GF_CodingConstraintsBox*) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_CCST);\n\tif (remove)  {\n\t\tif (ccst) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)ccst);\n\t\treturn GF_OK;\n\t}\n\tif (!ccst) {\n\t\tccst = (GF_CodingConstraintsBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_CCST);\n\t\tif (!ccst) return GF_OUT_OF_MEM;\n\t}\n\tccst->all_ref_pics_intra = all_ref_pics_intra;\n\tccst->intra_pred_used = intra_pred_used;\n\tccst->max_ref_per_pic = max_ref_per_pic;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_image_sequence_alpha(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, Bool remove)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_AuxiliaryTypeInfoBox *auxi = (GF_AuxiliaryTypeInfoBox *)gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_AUXI);\n\tif (remove)  {\n\t\tif (auxi) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)auxi);\n\t\treturn GF_OK;\n\t}\n\tif (!auxi) {\n\t\tauxi = (GF_AuxiliaryTypeInfoBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_AUXI);\n\t\tif (!auxi) return GF_OUT_OF_MEM;\n\t}\n\tauxi->aux_track_type = gf_strdup(\"urn:mpeg:mpegB:cicp:systems:auxiliary:alpha\");\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_audio_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 sampleRate, u32 nbChannels, u8 bitsPerSample, GF_AudioSampleEntryImportMode asemode)\n{\n\tGF_Err e;\n\tu32 i, old_qtff_mode=GF_ISOM_AUDIO_QTFF_NONE;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_AudioSampleEntryBox*aud_entry;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_Box *wave_box = NULL;\n\tGF_Box *gf_isom_audio_sample_get_audio_codec_cfg_box(GF_AudioSampleEntryBox *ptr);\n\tGF_Box *codec_ext = NULL;\n#if 0\n\tGF_ChannelLayoutInfoBox *chan=NULL;\n#endif\n\tGF_OriginalFormatBox *frma=NULL;\n\tGF_ChromaInfoBox *enda=NULL;\n\tGF_ESDBox *esds=NULL;\n\tGF_Box *terminator=NULL;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) {\n\t\treturn movie->LastError = GF_ISOM_INVALID_FILE;\n\t}\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO) return GF_BAD_PARAM;\n\taud_entry = (GF_AudioSampleEntryBox*) entry;\n\n\tif (entry->type==GF_ISOM_BOX_TYPE_MLPA) {\n\t\taud_entry->samplerate_hi = sampleRate>>16;\n\t\taud_entry->samplerate_lo = sampleRate & 0x0000FFFF;\n\t} else {\n\t\taud_entry->samplerate_hi = sampleRate;\n\t\taud_entry->samplerate_lo = 0;\n\t}\n\taud_entry->bitspersample = bitsPerSample;\n\n\tswitch (asemode) {\n\tcase GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_2:\n\t\tstsd->version = 0;\n\t\taud_entry->version = 0;\n\t\taud_entry->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\taud_entry->channel_count = 2;\n\t\tbreak;\n\tcase GF_IMPORT_AUDIO_SAMPLE_ENTRY_NOT_SET:\n\tcase GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_BS:\n\t\tstsd->version = 0;\n\t\taud_entry->version = 0;\n\t\taud_entry->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\taud_entry->channel_count = nbChannels;\n\t\tbreak;\n\tcase GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_MPEG:\n\t\tstsd->version = 1;\n\t\taud_entry->version = 1;\n\t\taud_entry->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\taud_entry->channel_count = nbChannels;\n\t\tbreak;\n\tcase GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF:\n\t\tstsd->version = 0;\n\t\t//don't change if already v2\n\t\tif ((aud_entry->version==2) && aud_entry->qtff_mode) {\n\t\t\tbreak;\n\t\t}\n\t\taud_entry->version = 1;\n\t\taud_entry->channel_count = nbChannels;\n\t\told_qtff_mode = aud_entry->qtff_mode;\n\t\tif (aud_entry->qtff_mode != GF_ISOM_AUDIO_QTFF_ON_EXT_VALID)\n\t\t\taud_entry->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_NOEXT;\n\t\tbreak;\n\t}\n\n\taud_entry->compression_id = 0;\n\n\t//check for wave+children and chan for QTFF or remove them for isobmff\n\tfor (i=0; i<gf_list_count(aud_entry->child_boxes); i++) {\n\t\tGF_Box *b = gf_list_get(aud_entry->child_boxes, i);\n\t\tif ((b->type != GF_QT_BOX_TYPE_WAVE) && (b->type != GF_QT_BOX_TYPE_CHAN) ) continue;\n\t\tif (asemode==GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF) {\n\t\t\tif (b->type == GF_QT_BOX_TYPE_WAVE) wave_box = b;\n#if 0\n\t\t\telse chan = (GF_ChannelLayoutInfoBox *)b;\n#endif\n\n\t\t} else {\n\t\t\tgf_isom_box_del_parent(&aud_entry->child_boxes, b);\n\t\t\ti--;\n\t\t}\n\t}\n\n\t//TODO: insert channelLayout for ISOBMFF\n\tif (asemode!=GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF) return GF_OK;\n\n\tif (aud_entry->type==GF_ISOM_BOX_TYPE_MP4A)\n\t\taud_entry->compression_id = -2;\n\n\tif (!aud_entry->child_boxes) aud_entry->child_boxes = gf_list_new();\n\n#if 0\n\tif (!chan) {\n\t\tchan = (GF_ChannelLayoutInfoBox *) gf_isom_box_new_parent(&aud_entry->child_boxes, GF_QT_BOX_TYPE_CHAN);\n\t}\n\t//TODO, proper channel mapping\n\tchan->layout_tag = (nbChannels==2) ? 6750210 : 6553601;\n#endif\n\n\tcodec_ext = gf_isom_audio_sample_get_audio_codec_cfg_box((GF_AudioSampleEntryBox *)aud_entry);\n\tif (!codec_ext) return GF_OK;\n\n\tif (!wave_box) {\n\t\twave_box = gf_isom_box_new_parent(&aud_entry->child_boxes, GF_QT_BOX_TYPE_WAVE);\n\t}\n\n\tfor (i=0; i<gf_list_count(wave_box->child_boxes); i++) {\n\t\tGF_Box *b = gf_list_get(wave_box->child_boxes, i);\n\t\tswitch (b->type) {\n\t\tcase GF_QT_BOX_TYPE_ENDA:\n\t\t\tenda = (GF_ChromaInfoBox *)b;\n\t\t\tbreak;\n\t\tcase GF_QT_BOX_TYPE_FRMA:\n\t\t\tfrma = (GF_OriginalFormatBox *)b;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_ESDS:\n\t\t\tesds = (GF_ESDBox *)b;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\t\tif ( ((GF_UnknownBox*)b)->original_4cc == 0)\n\t\t\t\tterminator = b;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tterminator = b;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!wave_box->child_boxes) wave_box->child_boxes = gf_list_new();\n\n\t//do not use new_parent, we do this manually to ensure the order\n\taud_entry->qtff_mode = old_qtff_mode ? old_qtff_mode : GF_ISOM_AUDIO_QTFF_ON_NOEXT;\n\tif (!frma) {\n\t\tfrma = (GF_OriginalFormatBox *)gf_isom_box_new(GF_QT_BOX_TYPE_FRMA);\n\t} else {\n\t\tgf_list_del_item(wave_box->child_boxes, frma);\n\t}\n\tgf_list_add(wave_box->child_boxes, frma);\n\n\tif (esds) gf_list_del_item(wave_box->child_boxes, esds);\n\tif (!esds && (aud_entry->type==GF_ISOM_BOX_TYPE_MP4A) && ((GF_MPEGAudioSampleEntryBox*)aud_entry)->esd) {\n\t\tgf_list_del_item(entry->child_boxes, (GF_Box *) ((GF_MPEGAudioSampleEntryBox*)aud_entry)->esd);\n\t\tgf_list_add(wave_box->child_boxes, (GF_Box *) ((GF_MPEGAudioSampleEntryBox*)aud_entry)->esd);\n\t}\n\n\tif (!enda) {\n\t\tenda = (GF_ChromaInfoBox *)gf_isom_box_new(GF_QT_BOX_TYPE_ENDA);\n\t} else {\n\t\tgf_list_del_item(wave_box->child_boxes, enda);\n\t}\n\tenda->chroma=1;\n\tgf_list_add(wave_box->child_boxes, enda);\n\n\tif (!terminator) {\n\t\tterminator = gf_isom_box_new(0);\n\t} else {\n\t\tgf_list_del_item(wave_box->child_boxes, terminator);\n\t}\n\tgf_list_add(wave_box->child_boxes, terminator);\n\n\tif (aud_entry->type==GF_ISOM_BOX_TYPE_GNRA) {\n\t\tfrma->data_format = ((GF_GenericAudioSampleEntryBox*) aud_entry)->EntryType;\n\t} else {\n\t\tfrma->data_format = aud_entry->type;\n\t}\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_audio_layout(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescriptionIndex, GF_AudioChannelLayout *layout)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_AudioSampleEntryBox*aud_entry;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_ChannelLayoutBox *chnl;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!layout) return GF_BAD_PARAM;\n\tif ((layout->stream_structure & 1) && (layout->definedLayout==0) && (layout->channels_count>=64))\n\t\treturn GF_BAD_PARAM;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) {\n\t\treturn movie->LastError = GF_ISOM_INVALID_FILE;\n\t}\n\tif (!sampleDescriptionIndex || sampleDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, sampleDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO) return GF_BAD_PARAM;\n\taud_entry = (GF_AudioSampleEntryBox*) entry;\n\tif (aud_entry->qtff_mode) {\n\t\tu32 sr = aud_entry->samplerate_hi;\n\t\tif (aud_entry->type==GF_ISOM_BOX_TYPE_MLPA) {\n\t\t\tsr <<= 16;\n\t\t\tsr |= aud_entry->samplerate_lo;\n\t\t}\n\t\te = gf_isom_set_audio_info(movie, trackNumber, sampleDescriptionIndex, sr, aud_entry->channel_count, (u8) aud_entry->bitspersample, GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_MPEG);\n\t\tif (e) return e;\n\t}\n\tchnl = (GF_ChannelLayoutBox *) gf_isom_box_find_child(aud_entry->child_boxes, GF_ISOM_BOX_TYPE_CHNL);\n\tif (!chnl) {\n\t\tchnl = (GF_ChannelLayoutBox *)gf_isom_box_new_parent(&aud_entry->child_boxes, GF_ISOM_BOX_TYPE_CHNL);\n\t\tif (!chnl) return GF_OUT_OF_MEM;\n\t}\n\taud_entry->channel_count = layout->channels_count;\n\tmemcpy(&chnl->layout, layout, sizeof(GF_AudioChannelLayout));\n\treturn GF_OK;\n}\n\n//set the storage mode of a file (FLAT, STREAMABLE, INTERLEAVED)\nGF_EXPORT\nGF_Err gf_isom_set_storage_mode(GF_ISOFile *movie, GF_ISOStorageMode storageMode)\n{\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tswitch (storageMode) {\n\tcase GF_ISOM_STORE_FLAT:\n\tcase GF_ISOM_STORE_STREAMABLE:\n\tcase GF_ISOM_STORE_INTERLEAVED:\n\tcase GF_ISOM_STORE_DRIFT_INTERLEAVED:\n\tcase GF_ISOM_STORE_TIGHT:\n\tcase GF_ISOM_STORE_FASTSTART:\n\t\tmovie->storageMode = storageMode;\n\t\t//specifying a storage mode disables inplace rewrite\n\t\tgf_isom_disable_inplace_rewrite(movie);\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_enable_compression(GF_ISOFile *file, GF_ISOCompressMode compress_mode, u32 compress_flags)\n{\n\tif (!file) return GF_BAD_PARAM;\n\tfile->compress_mode = compress_mode;\n\tfile->compress_flags = compress_flags;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_force_64bit_chunk_offset(GF_ISOFile *file, Bool set_on)\n{\n\tif (!file) return GF_BAD_PARAM;\n\tfile->force_co64 = set_on;\n\treturn GF_OK;\n}\n\n\n//update or insert a new edit segment in the track time line. Edits are used to modify\n//the media normal timing. EditTime and EditDuration are expressed in Movie TimeScale\n//If a segment with EditTime already exists, IT IS ERASED\nstatic GF_Err gf_isom_set_edit_internal(GF_ISOFile *movie, u32 trackNumber, u64 EditTime, u64 EditDuration, u64 MediaTime, u32 media_rate, GF_ISOEditType EditMode)\n{\n\tGF_TrackBox *trak;\n\tGF_EditBox *edts;\n\tGF_EditListBox *elst;\n\tGF_EdtsEntry *ent, *newEnt;\n\tu32 i;\n\tGF_Err e;\n\tu64 startTime;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tedts = trak->editBox;\n\tif (! edts) {\n\t\tedts = (GF_EditBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_EDTS);\n\t\tif (!edts) return GF_OUT_OF_MEM;\n\t\ttrak_on_child_box((GF_Box*)trak, (GF_Box *)edts, GF_FALSE);\n\t}\n\telst = edts->editList;\n\tif (!elst) {\n\t\telst = (GF_EditListBox *) gf_isom_box_new_parent(&edts->child_boxes, GF_ISOM_BOX_TYPE_ELST);\n\t\tif (!elst) return GF_OUT_OF_MEM;\n\t\tedts_on_child_box((GF_Box*)edts, (GF_Box *)elst, GF_FALSE);\n\t}\n\n\tstartTime = 0;\n\tent = NULL;\n\t//get the prev entry to this startTime if any\n\ti=0;\n\twhile ((ent = (GF_EdtsEntry *)gf_list_enum(elst->entryList, &i))) {\n\t\tif ( (startTime <= EditTime) && (startTime + ent->segmentDuration > EditTime) )\n\t\t\tgoto found;\n\t\tstartTime += ent->segmentDuration;\n\t}\n\n\t//not found, add a new entry, insert empty one if gap\n\tif (!ent) {\n\t\tBool empty_inserted = GF_FALSE;\n\t\tif (startTime != EditTime) {\n\t\t\tnewEnt = CreateEditEntry(EditTime - startTime, 0, 0, GF_ISOM_EDIT_EMPTY);\n\t\t\tif (!newEnt) return GF_OUT_OF_MEM;\n\t\t\tempty_inserted = GF_TRUE;\n\t\t\tgf_list_add(elst->entryList, newEnt);\n\t\t}\n\t\tnewEnt = CreateEditEntry(EditDuration, MediaTime, media_rate, EditMode);\n\t\tif (!newEnt) return GF_OUT_OF_MEM;\n\t\tgf_list_add(elst->entryList, newEnt);\n\t\te = SetTrackDuration(trak);\n\t\tif (e) return e;\n\t\treturn empty_inserted ? GF_EOS : GF_OK;\n\t}\n\n\tstartTime -= ent->segmentDuration;\n\nfound:\n\n\t//if same time, we erase the current one...\n\tif (startTime == EditTime) {\n\t\tent->segmentDuration = EditDuration;\n\t\tswitch (EditMode) {\n\t\tcase GF_ISOM_EDIT_EMPTY:\n\t\t\tent->mediaRate = 0x10000;\n\t\t\tent->mediaTime = -1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_EDIT_DWELL:\n\t\t\tent->mediaRate = 0;\n\t\t\tent->mediaTime = MediaTime;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tent->mediaRate = media_rate;\n\t\t\tent->mediaTime = MediaTime;\n\t\t\tbreak;\n\t\t}\n\t\treturn SetTrackDuration(trak);\n\t}\n\n\t//adjust so that the prev ent leads to EntryTime\n\t//Note: we don't change the next one as it is unknown to us in\n\t//a lot of case (the author's changes)\n\tent->segmentDuration = EditTime - startTime;\n\tnewEnt = CreateEditEntry(EditDuration, MediaTime, media_rate, EditMode);\n\tif (!newEnt) return GF_OUT_OF_MEM;\n\t//is it the last entry ???\n\tif (i >= gf_list_count(elst->entryList) - 1) {\n\t\t//add the new entry at the end\n\t\tgf_list_add(elst->entryList, newEnt);\n\t\treturn SetTrackDuration(trak);\n\t} else {\n\t\t//insert after the current entry (which is i)\n\t\tgf_list_insert(elst->entryList, newEnt, i+1);\n\t\treturn SetTrackDuration(trak);\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_edit(GF_ISOFile *movie, u32 trackNumber, u64 EditTime, u64 EditDuration, u64 MediaTime, GF_ISOEditType EditMode)\n{\n\treturn gf_isom_set_edit_internal(movie, trackNumber, EditTime, EditDuration, MediaTime, 0x10000, EditMode);\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_edit_with_rate(GF_ISOFile *movie, u32 trackNumber, u64 EditTime, u64 EditDuration, u64 MediaTime, u32 media_rate)\n{\n\treturn gf_isom_set_edit_internal(movie, trackNumber, EditTime, EditDuration, MediaTime, media_rate, GF_ISOM_EDIT_NORMAL);\n\n}\n\n//remove the edit segments for the whole track\nGF_EXPORT\nGF_Err gf_isom_remove_edits(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!trak->editBox || !trak->editBox->editList) return GF_OK;\n\n\twhile (gf_list_count(trak->editBox->editList->entryList)) {\n\t\tGF_EdtsEntry *ent = (GF_EdtsEntry*)gf_list_get(trak->editBox->editList->entryList, 0);\n\t\tgf_free(ent);\n\t\te = gf_list_rem(trak->editBox->editList->entryList, 0);\n\t\tif (e) return e;\n\t}\n\t//then delete the GF_EditBox...\n\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->editBox);\n\ttrak->editBox = NULL;\n\treturn SetTrackDuration(trak);\n}\n\n\n//remove the edit segments for the whole track\nGF_EXPORT\nGF_Err gf_isom_remove_edit(GF_ISOFile *movie, u32 trackNumber, u32 seg_index)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_EdtsEntry *ent, *next_ent;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !seg_index) return GF_BAD_PARAM;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!trak->editBox || !trak->editBox->editList) return GF_OK;\n\tif (gf_list_count(trak->editBox->editList->entryList)<=1) return gf_isom_remove_edits(movie, trackNumber);\n\n\tent = (GF_EdtsEntry*) gf_list_get(trak->editBox->editList->entryList, seg_index-1);\n\tgf_list_rem(trak->editBox->editList->entryList, seg_index-1);\n\tnext_ent = (GF_EdtsEntry *)gf_list_get(trak->editBox->editList->entryList, seg_index-1);\n\tif (next_ent) next_ent->segmentDuration += ent->segmentDuration;\n\tgf_free(ent);\n\treturn SetTrackDuration(trak);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_append_edit(GF_ISOFile *movie, u32 trackNumber, u64 EditDuration, u64 MediaTime, GF_ISOEditType EditMode)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_EdtsEntry *ent;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!trak->editBox) {\n\t\tGF_EditBox *edts = (GF_EditBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_EDTS);\n\t\tif (!edts) return GF_OUT_OF_MEM;\n\t\ttrak_on_child_box((GF_Box*)trak, (GF_Box *)edts, GF_FALSE);\n\t\tassert(trak->editBox);\n\t}\n\tif (!trak->editBox->editList) {\n\t\tGF_EditListBox *elst = (GF_EditListBox *) gf_isom_box_new_parent(&trak->editBox->child_boxes, GF_ISOM_BOX_TYPE_ELST);\n\t\tif (!elst) return GF_OUT_OF_MEM;\n\t\tedts_on_child_box((GF_Box*)trak->editBox, (GF_Box *)elst, GF_FALSE);\n\t\tassert(trak->editBox->editList);\n\t}\n\tent = (GF_EdtsEntry *)gf_malloc(sizeof(GF_EdtsEntry));\n\tif (!ent) return GF_OUT_OF_MEM;\n\n\tent->segmentDuration = EditDuration;\n\tswitch (EditMode) {\n\tcase GF_ISOM_EDIT_EMPTY:\n\t\tent->mediaRate = 0x10000;\n\t\tent->mediaTime = -1;\n\t\tbreak;\n\tcase GF_ISOM_EDIT_DWELL:\n\t\tent->mediaRate = 0;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\tdefault:\n\t\tent->mediaRate = 0x10000;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\t}\n\tgf_list_add(trak->editBox->editList->entryList, ent);\n\treturn SetTrackDuration(trak);\n}\n\nGF_EXPORT\nGF_Err gf_isom_modify_edit(GF_ISOFile *movie, u32 trackNumber, u32 seg_index, u64 EditDuration, u64 MediaTime, GF_ISOEditType EditMode)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_EdtsEntry *ent;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !seg_index) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!trak->editBox || !trak->editBox->editList) return GF_OK;\n\tif (gf_list_count(trak->editBox->editList->entryList)<seg_index) return GF_BAD_PARAM;\n\tent = (GF_EdtsEntry*) gf_list_get(trak->editBox->editList->entryList, seg_index-1);\n\n\tent->segmentDuration = EditDuration;\n\tswitch (EditMode) {\n\tcase GF_ISOM_EDIT_EMPTY:\n\t\tent->mediaRate = 0x10000;\n\t\tent->mediaTime = -1;\n\t\tbreak;\n\tcase GF_ISOM_EDIT_DWELL:\n\t\tent->mediaRate = 0;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\tdefault:\n\t\tent->mediaRate = 0x10000;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\t}\n\treturn SetTrackDuration(trak);\n}\n\nstatic void update_next_track_id(GF_ISOFile *movie)\n{\n\tGF_TrackBox *trak;\n\t/*update next track ID*/\n\tmovie->moov->mvhd->nextTrackID = 0;\n\tu32 i=0;\n\twhile ((trak = (GF_TrackBox *)gf_list_enum(movie->moov->trackList, &i))) {\n\t\tif (trak->Header->trackID>movie->moov->mvhd->nextTrackID)\n\t\t\tmovie->moov->mvhd->nextTrackID = trak->Header->trackID;\n\t}\n\t//shall be larger than the largest track_ID in use\n\tmovie->moov->mvhd->nextTrackID++;\n}\n\n//removes the desired track\nGF_EXPORT\nGF_Err gf_isom_remove_track(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_Err e;\n\tGF_TrackBox *the_trak, *trak;\n\tGF_TrackReferenceTypeBox *tref;\n\tu32 i, j, k, descIndex;\n\tGF_ISOTrackID *newRefs;\n\tu8 found;\n\tGF_ISOSample *samp;\n\tthe_trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!the_trak) return GF_BAD_PARAM;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (movie->moov->iods && movie->moov->iods->descriptor) {\n\t\tGF_Descriptor *desc;\n\t\tGF_ES_ID_Inc *inc;\n\t\tGF_List *ESDs;\n\t\tdesc = movie->moov->iods->descriptor;\n\t\tif (desc->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\tESDs = ((GF_IsomInitialObjectDescriptor *)desc)->ES_ID_IncDescriptors;\n\t\t} else if (desc->tag == GF_ODF_ISOM_OD_TAG) {\n\t\t\tESDs = ((GF_IsomObjectDescriptor *)desc)->ES_ID_IncDescriptors;\n\t\t} else {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\t//remove the track ref from the root OD if any\n\t\ti=0;\n\t\twhile ((inc = (GF_ES_ID_Inc *)gf_list_enum(ESDs, &i))) {\n\t\t\tif (inc->trackID == the_trak->Header->trackID) {\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)inc);\n\t\t\t\ti--;\n\t\t\t\tgf_list_rem(ESDs, i);\n\t\t\t}\n\t\t}\n\t}\n\n\t//remove the track from the movie\n\tgf_list_del_item(movie->moov->trackList, the_trak);\n\n\t//rewrite any OD tracks\n\ti=0;\n\twhile ((trak = (GF_TrackBox *)gf_list_enum(movie->moov->trackList, &i))) {\n\t\tif (trak->Media->handler->handlerType != GF_ISOM_MEDIA_OD) continue;\n\n\t\t//this is an OD track...\n\t\tj = gf_isom_get_sample_count(movie, i);\n\t\tfor (k=0; k < j; k++) {\n\t\t\t//getting the sample will remove the references to the deleted track in the output OD frame\n\t\t\tsamp = gf_isom_get_sample(movie, i, k+1, &descIndex);\n\t\t\tif (!samp) break;\n\t\t\t//so let's update with the new OD frame ! If the sample is empty, remove it\n\t\t\tif (!samp->dataLength) {\n\t\t\t\te = gf_isom_remove_sample(movie, i, k+1);\n\t\t\t\tif (e) return e;\n\t\t\t} else {\n\t\t\t\te = gf_isom_update_sample(movie, i, k+1, samp, GF_TRUE);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\t//and don't forget to delete the sample\n\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t}\n\n\t//remove the track ref from any \"tref\" box in all tracks, except the one to delete\n\t//note that we don't touch scal references, as we don't want to rewrite AVC/HEVC samples ...\n\ti=0;\n\twhile ((trak = (GF_TrackBox *)gf_list_enum(movie->moov->trackList, &i))) {\n\t\tif (! trak->References || ! gf_list_count(trak->References->child_boxes)) continue;\n\n\t\tj=0;\n\t\twhile ((tref = (GF_TrackReferenceTypeBox *)gf_list_enum(trak->References->child_boxes, &j))) {\n\t\t\tif (tref->reference_type==GF_ISOM_REF_SCAL)\n\t\t\t\tcontinue;\n\n\t\t\tfound = 0;\n\t\t\tfor (k=0; k<tref->trackIDCount; k++) {\n\t\t\t\tif (tref->trackIDs[k] == the_trak->Header->trackID) found++;\n\t\t\t}\n\t\t\tif (!found) continue;\n\t\t\t//no more refs, remove this ref_type\n\t\t\tif (found == tref->trackIDCount) {\n\t\t\t\tgf_isom_box_del_parent(&trak->References->child_boxes, (GF_Box *)tref);\n\t\t\t\tj--;\n\t\t\t} else {\n\t\t\t\tnewRefs = (GF_ISOTrackID*)gf_malloc(sizeof(GF_ISOTrackID) * (tref->trackIDCount - found));\n\t\t\t\tif (!newRefs) return GF_OUT_OF_MEM;\n\t\t\t\tfound = 0;\n\t\t\t\tfor (k = 0; k < tref->trackIDCount; k++) {\n\t\t\t\t\tif (tref->trackIDs[k] != the_trak->Header->trackID) {\n\t\t\t\t\t\tnewRefs[k-found] = tref->trackIDs[k];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfound++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_free(tref->trackIDs);\n\t\t\t\ttref->trackIDs = newRefs;\n\t\t\t\ttref->trackIDCount -= found;\n\t\t\t}\n\t\t}\n\t\t//a little opt: remove the ref box if empty...\n\t\tif (! gf_list_count(trak->References->child_boxes)) {\n\t\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->References);\n\t\t\ttrak->References = NULL;\n\t\t}\n\t}\n\n\tgf_isom_disable_inplace_rewrite(movie);\n\n\tgf_isom_meta_track_remove(movie, the_trak, 0);\n\n\t//delete the track\n\tgf_isom_box_del_parent(&movie->moov->child_boxes, (GF_Box *)the_trak);\n\n\t/*update next track ID*/\n\tupdate_next_track_id(movie);\n\n\tif (!gf_list_count(movie->moov->trackList)) {\n\t\tgf_list_del_item(movie->TopBoxes, movie->moov);\n\t\tgf_isom_box_del((GF_Box *)movie->moov);\n\t\tmovie->moov = NULL;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_copyright(GF_ISOFile *movie, const char *threeCharCode, char *notice)\n{\n\tGF_Err e;\n\tGF_CopyrightBox *ptr;\n\tGF_UserDataMap *map;\n\tu32 count, i;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!notice || !threeCharCode) return GF_BAD_PARAM;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (!movie->moov->udta) {\n\t\te = moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tif (e) return e;\n\t}\n\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_CPRT, NULL);\n\n\tif (map) {\n\t\t//try to find one in our language...\n\t\tcount = gf_list_count(map->boxes);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tptr = (GF_CopyrightBox*)gf_list_get(map->boxes, i);\n\t\t\tif (!strcmp(threeCharCode, (const char *) ptr->packedLanguageCode)) {\n\t\t\t\tgf_free(ptr->notice);\n\t\t\t\tptr->notice = (char*)gf_malloc(sizeof(char) * (strlen(notice) + 1));\n\t\t\t\tif (!ptr->notice) return GF_OUT_OF_MEM;\n\t\t\t\tstrcpy(ptr->notice, notice);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t}\n\t//nope, create one\n\tptr = (GF_CopyrightBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_CPRT);\n\tif (!ptr) return GF_OUT_OF_MEM;\n\n\tmemcpy(ptr->packedLanguageCode, threeCharCode, 4);\n\tptr->notice = (char*)gf_malloc(sizeof(char) * (strlen(notice)+1));\n\tif (!ptr->notice) return GF_OUT_OF_MEM;\n\tstrcpy(ptr->notice, notice);\n\treturn udta_on_child_box((GF_Box *)movie->moov->udta, (GF_Box *) ptr, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_track_kind(GF_ISOFile *movie, u32 trackNumber, const char *schemeURI, const char *value)\n{\n\tGF_Err e;\n\tGF_KindBox *ptr;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\tu32 i, count;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) {\n\t\t\te = trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\tudta = trak->udta;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_KIND, NULL);\n\tif (map) {\n\t\tcount = gf_list_count(map->boxes);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_Box *b = (GF_Box *)gf_list_get(map->boxes, i);\n\t\t\tif (b->type == GF_ISOM_BOX_TYPE_KIND) {\n\t\t\t\tGF_KindBox *kb = (GF_KindBox *)b;\n\t\t\t\tif (!strcmp(kb->schemeURI, schemeURI) &&\n\t\t\t\t        ((value && kb->value && !strcmp(value, kb->value)) || (!value && !kb->value))) {\n\t\t\t\t\t// Already there\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tptr = (GF_KindBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_KIND);\n\tif (e) return e;\n\n\tptr->schemeURI = gf_strdup(schemeURI);\n\tif (value) ptr->value = gf_strdup(value);\n\treturn udta_on_child_box((GF_Box *)udta, (GF_Box *) ptr, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_track_kind(GF_ISOFile *movie, u32 trackNumber, const char *schemeURI, const char *value)\n{\n\tGF_Err e;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\tu32 i;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) {\n\t\t\te = trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\tudta = trak->udta;\n\t} else {\n\t\treturn GF_OK;\n\t}\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_KIND, NULL);\n\tif (map) {\n\t\tfor (i=0; i<gf_list_count(map->boxes); i++) {\n\t\t\tGF_Box *b = (GF_Box *)gf_list_get(map->boxes, i);\n\t\t\tif (b->type == GF_ISOM_BOX_TYPE_KIND) {\n\t\t\t\tGF_KindBox *kb = (GF_KindBox *)b;\n\t\t\t\tif (!schemeURI ||\n\t\t\t\t        (!strcmp(kb->schemeURI, schemeURI) &&\n\t\t\t\t         ((value && kb->value && !strcmp(value, kb->value)) || (!value && !kb->value)))) {\n\t\t\t\t\tgf_isom_box_del_parent(&map->boxes, b);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_chapter(GF_ISOFile *movie, u32 trackNumber, u64 timestamp, char *name)\n{\n\tGF_Err e;\n\tGF_ChapterListBox *ptr;\n\tu32 i, count;\n\tGF_ChapterEntry *ce;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) {\n\t\t\te = trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov->udta) {\n\t\t\te = moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\tudta = movie->moov->udta;\n\t}\n\n\tptr = NULL;\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_CHPL, NULL);\n\tif (!map) {\n\t\tptr = (GF_ChapterListBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_CHPL);\n\t\te = udta_on_child_box((GF_Box *)udta, (GF_Box *) ptr, GF_FALSE);\n\t\tif (e) return e;\n\t\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_CHPL, NULL);\n\t} else {\n\t\tptr = (GF_ChapterListBox*)gf_list_get(map->boxes, 0);\n\t}\n\tif (!map) return GF_OUT_OF_MEM;\n\n\t/*this may happen if original MP4 is not properly formatted*/\n\tif (!ptr) {\n\t\tptr = (GF_ChapterListBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_CHPL);\n\t\tif (!ptr) return GF_OUT_OF_MEM;\n\t\tgf_list_add(map->boxes, ptr);\n\t}\n\n\tGF_SAFEALLOC(ce, GF_ChapterEntry);\n\tif (!ce) return GF_OUT_OF_MEM;\n\n\tce->start_time = timestamp * 10000L;\n\tce->name = name ? gf_strdup(name) : NULL;\n\n\t/*insert in order*/\n\tcount = gf_list_count(ptr->list);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ChapterEntry *ace = (GF_ChapterEntry *)gf_list_get(ptr->list, i);\n\t\tif (ace->start_time == ce->start_time) {\n\t\t\tif (ace->name) gf_free(ace->name);\n\t\t\tace->name = ce->name;\n\t\t\tgf_free(ce);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (ace->start_time >= ce->start_time)\n\t\t\treturn gf_list_insert(ptr->list, ce, i);\n\t}\n\treturn gf_list_add(ptr->list, ce);\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_chapter(GF_ISOFile *movie, u32 trackNumber, u32 index)\n{\n\tGF_Err e;\n\tGF_ChapterListBox *ptr;\n\tGF_ChapterEntry *ce;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) return GF_OK;\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov->udta) return GF_OK;\n\t\tudta = movie->moov->udta;\n\t}\n\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_CHPL, NULL);\n\tif (!map) return GF_OK;\n\tptr = (GF_ChapterListBox*)gf_list_get(map->boxes, 0);\n\tif (!ptr) return GF_OK;\n\n\tif (index) {\n\t\tce = (GF_ChapterEntry *)gf_list_get(ptr->list, index-1);\n\t\tif (!ce) return GF_BAD_PARAM;\n\t\tif (ce->name) gf_free(ce->name);\n\t\tgf_free(ce);\n\t\tgf_list_rem(ptr->list, index-1);\n\t} else {\n\t\twhile (gf_list_count(ptr->list)) {\n\t\t\tce = (GF_ChapterEntry *)gf_list_get(ptr->list, 0);\n\t\t\tif (ce->name) gf_free(ce->name);\n\t\t\tgf_free(ce);\n\t\t\tgf_list_rem(ptr->list, 0);\n\t\t}\n\t}\n\tif (!gf_list_count(ptr->list)) {\n\t\tgf_list_del_item(udta->recordList, map);\n\t\tgf_isom_box_array_del(map->boxes);\n\t\tgf_free(map);\n\t}\n\treturn GF_OK;\n}\n\n#if 0 //unused\nGF_Err gf_isom_remove_copyright(GF_ISOFile *movie, u32 index)\n{\n\tGF_Err e;\n\tGF_CopyrightBox *ptr;\n\tGF_UserDataMap *map;\n\tu32 count;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (!index) return GF_BAD_PARAM;\n\tif (!movie->moov->udta) return GF_OK;\n\n\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_CPRT, NULL);\n\tif (!map) return GF_OK;\n\n\tcount = gf_list_count(map->boxes);\n\tif (index>count) return GF_BAD_PARAM;\n\n\tptr = (GF_CopyrightBox*)gf_list_get(map->boxes, index-1);\n\tif (ptr) {\n\t\tgf_list_rem(map->boxes, index-1);\n\t\tif (ptr->notice) gf_free(ptr->notice);\n\t\tgf_free(ptr);\n\t}\n\t/*last copyright, remove*/\n\tif (!gf_list_count(map->boxes)) {\n\t\tgf_list_del_item(movie->moov->udta->recordList, map);\n\t\tgf_list_del(map->boxes);\n\t\tgf_free(map);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_set_watermark(GF_ISOFile *movie, bin128 UUID, u8* data, u32 length)\n{\n\tGF_Err e;\n\tGF_UnknownUUIDBox *ptr;\n\tGF_UserDataMap *map;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\tif (!movie->moov->udta) {\n\t\te = moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA));\n\t\tif (e) return e;\n\t}\n\n\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_UUID, (bin128 *) & UUID);\n\tif (map) {\n\t\tptr = (GF_UnknownUUIDBox *)gf_list_get(map->boxes, 0);\n\t\tif (ptr) {\n\t\t\tgf_free(ptr->data);\n\t\t\tptr->data = (char*)gf_malloc(length);\n\t\t\tif (!ptr->data) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(ptr->data, data, length);\n\t\t\tptr->dataSize = length;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\t//nope, create one\n\tptr = (GF_UnknownUUIDBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_UUID);\n\tif (!ptr) return GF_OUT_OF_MEM;\n\n\tmemcpy(ptr->uuid, UUID, 16);\n\tptr->data = (char*)gf_malloc(length);\n\tif (!ptr->data) return GF_OUT_OF_MEM;\n\tmemcpy(ptr->data, data, length);\n\tptr->dataSize = length;\n\treturn udta_on_child_box((GF_Box *)movie->moov->udta, (GF_Box *) ptr);\n}\n#endif\n\n//set the interleaving time of media data (INTERLEAVED mode only)\n//InterleaveTime is in MovieTimeScale\nGF_EXPORT\nGF_Err gf_isom_set_interleave_time(GF_ISOFile *movie, u32 InterleaveTime)\n{\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!InterleaveTime || !movie->moov) return GF_OK;\n\tmovie->interleavingTime = InterleaveTime;\n\treturn GF_OK;\n}\n\n\n\n//use a compact track version for sample size. This is not usually recommended\n//except for speech codecs where the track has a lot of small samples\n//compaction is done automatically while writing based on the track's sample sizes\nGF_EXPORT\nGF_Err gf_isom_use_compact_size(GF_ISOFile *movie, u32 trackNumber, Bool CompactionOn)\n{\n\tGF_TrackBox *trak;\n\tu32 i, size;\n\tGF_SampleSizeBox *stsz;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (!trak->Media || !trak->Media->information\n\t        || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tstsz = trak->Media->information->sampleTable->SampleSize;\n\n\t//switch to regular table\n\tif (!CompactionOn) {\n\t\tif (stsz->type == GF_ISOM_BOX_TYPE_STSZ) return GF_OK;\n\t\tstsz->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\t//invalidate the sampleSize and recompute it\n\t\tstsz->sampleSize = 0;\n\t\tif (!stsz->sampleCount) return GF_OK;\n\t\t//if the table is empty we can only assume the track is empty (no size indication)\n\t\tif (!stsz->sizes) return GF_OK;\n\t\tsize = stsz->sizes[0];\n\t\t//check whether the sizes are all the same or not\n\t\tfor (i=1; i<stsz->sampleCount; i++) {\n\t\t\tif (size != stsz->sizes[i]) {\n\t\t\t\tsize = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (size) {\n\t\t\tgf_free(stsz->sizes);\n\t\t\tstsz->sizes = NULL;\n\t\t\tstsz->sampleSize = size;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\t//switch to compact table\n\tif (stsz->type == GF_ISOM_BOX_TYPE_STZ2) return GF_OK;\n\t//fill the table. Although it seems weird , this is needed in case of edition\n\t//after the function is called. NOte however than we force regular table\n\t//at write time if all samples are of same size\n\tif (stsz->sampleSize) {\n\t\t//this is a weird table indeed ;)\n\t\tif (stsz->sizes) gf_free(stsz->sizes);\n\t\tstsz->sizes = (u32*) gf_malloc(sizeof(u32)*stsz->sampleCount);\n\t\tif (!stsz->sizes) return GF_OUT_OF_MEM;\n\t\tmemset(stsz->sizes, stsz->sampleSize, sizeof(u32));\n\t}\n\t//set the SampleSize to 0 while the file is open\n\tstsz->sampleSize = 0;\n\tstsz->type = GF_ISOM_BOX_TYPE_STZ2;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_disable_brand_rewrite(GF_ISOFile *movie, Bool do_disable)\n{\n\tif (!movie) return GF_BAD_PARAM;\n\tmovie->disable_brand_rewrite = do_disable ? 1: 0;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_brand_info(GF_ISOFile *movie, u32 MajorBrand, u32 MinorVersion)\n{\n\tu32 i, *p;\n\n\tif (!movie) return GF_BAD_PARAM;\n\tif (movie->disable_brand_rewrite) return GF_OK;\n\tif (!MajorBrand) return GF_BAD_PARAM;\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (! (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY)) {\n\t\tGF_Err e = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\tif (e) return e;\n\n\t\te = CheckNoData(movie);\n\t\tif (e) return e;\n\t}\n#endif\n\n\tif (!movie->brand) {\n\t\tmovie->brand = (GF_FileTypeBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_FTYP);\n\t\tif (!movie->brand) return GF_OUT_OF_MEM;\n\t\tgf_list_add(movie->TopBoxes, movie->brand);\n\t}\n\n\tmovie->brand->majorBrand = MajorBrand;\n\tmovie->brand->minorVersion = MinorVersion;\n\n\tif (!movie->brand->altBrand) {\n\t\tmovie->brand->altBrand = (u32*)gf_malloc(sizeof(u32));\n\t\tif (!movie->brand->altBrand) return GF_OUT_OF_MEM;\n\t\tmovie->brand->altBrand[0] = MajorBrand;\n\t\tmovie->brand->altCount = 1;\n\t\treturn GF_OK;\n\t}\n\n\t//if brand already present don't change anything\n\tfor (i=0; i<movie->brand->altCount; i++) {\n\t\tif (movie->brand->altBrand[i] == MajorBrand) return GF_OK;\n\t}\n\tp = (u32*)gf_malloc(sizeof(u32)*(movie->brand->altCount + 1));\n\tif (!p) return GF_OUT_OF_MEM;\n\tmemcpy(p, movie->brand->altBrand, sizeof(u32)*movie->brand->altCount);\n\tp[movie->brand->altCount] = MajorBrand;\n\tmovie->brand->altCount += 1;\n\tgf_free(movie->brand->altBrand);\n\tmovie->brand->altBrand = p;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_modify_alternate_brand(GF_ISOFile *movie, u32 Brand, Bool AddIt)\n{\n\tu32 i, k, *p;\n\n\tif (!movie) return GF_BAD_PARAM;\n\tif (movie->disable_brand_rewrite) return GF_OK;\n\tif (!Brand) return GF_BAD_PARAM;\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (! (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY)) {\n\t\tGF_Err e = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\tif (e) return e;\n\n\t\te = CheckNoData(movie);\n\t\tif (e) return e;\n\t}\n#endif\n\n\tif (!movie->brand && AddIt) {\n\t\tmovie->brand = (GF_FileTypeBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_FTYP);\n\t\tif (!movie->brand) return GF_OUT_OF_MEM;\n\t\tgf_list_add(movie->TopBoxes, movie->brand);\n\t}\n\tif (!AddIt && !movie->brand) return GF_OK;\n\n\t//do not mofify major one\n\tif (!AddIt && movie->brand->majorBrand == Brand) return GF_OK;\n\n\tif (!AddIt && movie->brand->altCount == 1) {\n\t\t//fixes it in case\n\t\tmovie->brand->altBrand[0] = movie->brand->majorBrand;\n\t\treturn GF_OK;\n\t}\n\t//check for the brand\n\tfor (i=0; i<movie->brand->altCount; i++) {\n\t\tif (movie->brand->altBrand[i] == Brand) goto found;\n\t}\n\t//Not found\n\tif (!AddIt) return GF_OK;\n\t//add it\n\tp = (u32*)gf_malloc(sizeof(u32)*(movie->brand->altCount + 1));\n\tif (!p) return GF_OUT_OF_MEM;\n\tif (movie->brand->altBrand) {\n\t\tmemcpy(p, movie->brand->altBrand, sizeof(u32)*movie->brand->altCount);\n\t\tgf_free(movie->brand->altBrand);\n\t}\n\tp[movie->brand->altCount] = Brand;\n\tmovie->brand->altCount += 1;\n\tmovie->brand->altBrand = p;\n\treturn GF_OK;\n\nfound:\n\n\t//found\n\tif (AddIt) return GF_OK;\n\tassert(movie->brand->altCount>1);\n\n\t//remove it\n\tp = (u32*)gf_malloc(sizeof(u32)*(movie->brand->altCount - 1));\n\tif (!p) return GF_OUT_OF_MEM;\n\tk = 0;\n\tfor (i=0; i<movie->brand->altCount; i++) {\n\t\tif (movie->brand->altBrand[i] == Brand) continue;\n\t\telse {\n\t\t\tp[k] = movie->brand->altBrand[i];\n\t\t\tk++;\n\t\t}\n\t}\n\tmovie->brand->altCount -= 1;\n\tgf_free(movie->brand->altBrand);\n\tmovie->brand->altBrand = p;\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_reset_alt_brands_ex(GF_ISOFile *movie, Bool leave_empty)\n{\n\tu32 *p;\n\n\tif (!movie) return GF_BAD_PARAM;\n\tif (movie->disable_brand_rewrite) return GF_OK;\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (! (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY)) {\n\t\tGF_Err e = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\tif (e) return e;\n\n\t\te = CheckNoData(movie);\n\t\tif (e) return e;\n\t}\n#endif\n\n\tif (!movie->brand) {\n\t\tmovie->brand = (GF_FileTypeBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_FTYP);\n\t\tif (!movie->brand) return GF_OUT_OF_MEM;\n\t\tgf_list_add(movie->TopBoxes, movie->brand);\n\t}\n\tgf_free(movie->brand->altBrand);\n\tif (leave_empty) {\n\t\tmovie->brand->altCount = 0;\n\t\tmovie->brand->altBrand = NULL;\n\t} else {\n\t\tp = (u32*)gf_malloc(sizeof(u32));\n\t\tif (!p) return GF_OUT_OF_MEM;\n\t\tp[0] = movie->brand->majorBrand;\n\t\tmovie->brand->altCount = 1;\n\t\tmovie->brand->altBrand = p;\n\t}\n\treturn GF_OK;\n}\nGF_EXPORT\nGF_Err gf_isom_reset_alt_brands(GF_ISOFile *movie)\n{\n\treturn gf_isom_reset_alt_brands_ex(movie, GF_FALSE);\n}\n\n#if 0 //unused\nGF_Err gf_isom_set_sample_padding_bits(GF_ISOFile *movie, u32 trackNumber, u32 sampleNumber, u8 NbBits)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || NbBits > 7) return GF_BAD_PARAM;\n\n\t//set Padding info\n\treturn stbl_SetPaddingBits(trak->Media->information->sampleTable, sampleNumber, NbBits);\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_remove_user_data_item(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID, u32 UserDataIndex)\n{\n\tGF_UserDataMap *map;\n\tGF_Box *a;\n\tu32 i;\n\tbin128 t;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\tmemset(t, 1, 16);\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov) return GF_BAD_PARAM;\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_BAD_PARAM;\n\tif (!UserDataIndex) return GF_BAD_PARAM;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {\n\t\tif ((map->boxType == GF_ISOM_BOX_TYPE_UUID)  && !memcmp(map->uuid, UUID, 16)) goto found;\n\t\telse if (map->boxType == UserDataType) goto found;\n\t}\n\t//not found\n\treturn GF_OK;\n\nfound:\n\n\tif (UserDataIndex > gf_list_count(map->boxes) ) return GF_BAD_PARAM;\n\t//delete the box\n\ta = (GF_Box*)gf_list_get(map->boxes, UserDataIndex-1);\n\tgf_isom_box_del_parent(&map->boxes, a);\n\n\t//remove the map if empty\n\tif (!gf_list_count(map->boxes)) {\n\t\tgf_list_rem(udta->recordList, i-1);\n\t\tgf_isom_box_array_del(map->boxes);\n\t\tgf_free(map);\n\t}\n\t//but we keep the UDTA no matter what\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_user_data(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID)\n{\n\tGF_UserDataMap *map;\n\tu32 i;\n\tGF_Err e;\n\tbin128 t;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\tmemset(t, 1, 16);\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_EOS;\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov) return GF_BAD_PARAM;\n\t\tudta = movie->moov->udta;\n\t}\n\t//do not return any error if no udta\n\tif (!udta) return GF_EOS;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {\n\t\tif ((map->boxType == GF_ISOM_BOX_TYPE_UUID)  && !memcmp(map->uuid, UUID, 16)) goto found;\n\t\telse if (map->boxType == UserDataType) goto found;\n\t}\n\t//not found\n\treturn GF_OK;\n\nfound:\n\n\tgf_list_rem(udta->recordList, i-1);\n\tgf_isom_box_array_del(map->boxes);\n\tgf_free(map);\n\n\t//but we keep the UDTA no matter what\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_user_data(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID, u8 *data, u32 DataLength)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov) return GF_BAD_PARAM;\n\t\tif (!movie->moov->udta) moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_OUT_OF_MEM;\n\n\t//create a default box\n\tif (UserDataType) {\n\t\tGF_UnknownBox *a = (GF_UnknownBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_UNKNOWN);\n\t\tif (!a) return GF_OUT_OF_MEM;\n\t\ta->original_4cc = UserDataType;\n\t\tif (DataLength) {\n\t\t\ta->data = (char*)gf_malloc(sizeof(char)*DataLength);\n\t\t\tif (!a->data) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(a->data, data, DataLength);\n\t\t\ta->dataSize = DataLength;\n\t\t}\n\t\treturn udta_on_child_box((GF_Box *)udta, (GF_Box *) a, GF_FALSE);\n\t} else if (UUID) {\n\t\tGF_UnknownUUIDBox *a = (GF_UnknownUUIDBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_UUID);\n\t\tif (!a) return GF_OUT_OF_MEM;\n\t\tmemcpy(a->uuid, UUID, 16);\n\t\tif (DataLength) {\n\t\t\ta->data = (char*)gf_malloc(sizeof(char)*DataLength);\n\t\t\tif (!a->data) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(a->data, data, DataLength);\n\t\t\ta->dataSize = DataLength;\n\t\t}\n\t\treturn udta_on_child_box((GF_Box *)udta, (GF_Box *) a, GF_FALSE);\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_user_data_boxes(GF_ISOFile *movie, u32 trackNumber, u8 *data, u32 DataLength)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\tGF_BitStream *bs;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov) return GF_BAD_PARAM;\n\t\tif (!movie->moov->udta) moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_OUT_OF_MEM;\n\n\tbs = gf_bs_new(data, DataLength, GF_BITSTREAM_READ);\n\twhile (gf_bs_available(bs)) {\n\t\tGF_Box *a;\n\t\te = gf_isom_box_parse(&a, bs);\n\t\tif (e) break;\n\t\te = udta_on_child_box((GF_Box *)udta, a, GF_FALSE);\n\t\tif (e) break;\n\t}\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_clone_pl_indications(GF_ISOFile *orig, GF_ISOFile *dest)\n{\n\tGF_IsomInitialObjectDescriptor *iod_d;\n\tif (!orig || !dest) return GF_BAD_PARAM;\n\tif (!orig->moov->iods || !orig->moov->iods->descriptor) return GF_OK;\n\tif (orig->moov->iods->descriptor->tag != GF_ODF_ISOM_IOD_TAG) return GF_OK;\n\n\tAddMovieIOD(dest->moov, 1);\n\tgf_odf_desc_del((GF_Descriptor *)dest->moov->iods->descriptor);\n\tgf_odf_desc_copy((GF_Descriptor *)orig->moov->iods->descriptor, (GF_Descriptor **)&dest->moov->iods->descriptor);\n\tiod_d = (GF_IsomInitialObjectDescriptor *) dest->moov->iods->descriptor;\n\twhile (gf_list_count(iod_d->ES_ID_IncDescriptors)) {\n\t\tGF_Descriptor *d = (GF_Descriptor *)gf_list_get(iod_d->ES_ID_IncDescriptors, 0);\n\t\tgf_list_rem(iod_d->ES_ID_IncDescriptors, 0);\n\t\tgf_odf_desc_del(d);\n\t}\n\twhile (gf_list_count(iod_d->ES_ID_RefDescriptors)) {\n\t\tGF_Descriptor *d = (GF_Descriptor *)gf_list_get(iod_d->ES_ID_RefDescriptors, 0);\n\t\tgf_list_rem(iod_d->ES_ID_RefDescriptors, 0);\n\t\tgf_odf_desc_del(d);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_clone_box(GF_Box *src, GF_Box **dst)\n{\n\tGF_Err e;\n\tu8 *data;\n\tu32 data_size;\n\tGF_BitStream *bs;\n\n\tif (*dst) {\n\t\tgf_isom_box_del(*dst);\n\t\t*dst=NULL;\n\t}\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (!bs) return GF_OUT_OF_MEM;\n\te = gf_isom_box_size( (GF_Box *) src);\n\tif (!e) e = gf_isom_box_write((GF_Box *) src, bs);\n\tgf_bs_get_content(bs, &data, &data_size);\n\tgf_bs_del(bs);\n\tif (e) {\n\t\tif (data) gf_free(data);\n\t\treturn e;\n\t}\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\tif (!bs) {\n\t\tif (data) gf_free(data);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\te = gf_isom_box_parse(dst, bs);\n\tgf_bs_del(bs);\n\tgf_free(data);\n\treturn e;\n}\n\n#if 0 //unused\n/*clones the entire movie file to destination. Tracks can be cloned if clone_tracks is set, in which case hint tracks can be\nkept if keep_hint_tracks is set\nif keep_pssh, all pssh boxes will be kept\nfragment information (mvex) is not kept*/\nGF_Err gf_isom_clone_movie(GF_ISOFile *orig_file, GF_ISOFile *dest_file, Bool clone_tracks, Bool keep_hint_tracks, Bool keep_pssh)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_Box *box;\n\n\te = CanAccessMovie(dest_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (orig_file->brand) {\n\t\tgf_list_del_item(dest_file->TopBoxes, dest_file->brand);\n\t\tgf_isom_box_del((GF_Box *)dest_file->brand);\n\t\tdest_file->brand = NULL;\n\t\tgf_isom_clone_box((GF_Box *)orig_file->brand, (GF_Box **)&dest_file->brand);\n\t\tif (dest_file->brand) gf_list_add(dest_file->TopBoxes, dest_file->brand);\n\t}\n\n\tif (orig_file->meta) {\n\t\tgf_list_del_item(dest_file->TopBoxes, dest_file->meta);\n\t\tgf_isom_box_del((GF_Box *)dest_file->meta);\n\t\tdest_file->meta = NULL;\n\t\t/*fixme - check imports*/\n\t\tgf_isom_clone_box((GF_Box *)orig_file->meta, (GF_Box **)&dest_file->meta);\n\t\tif (dest_file->meta) gf_list_add(dest_file->TopBoxes, dest_file->meta);\n\t}\n\tif (orig_file->moov) {\n\t\tu32 i, dstTrack;\n\t\tGF_Box *iods;\n\t\tGF_List *tracks = gf_list_new();\n\t\tGF_List *old_tracks = orig_file->moov->trackList;\n\t\torig_file->moov->trackList = tracks;\n\t\tiods = (GF_Box*)orig_file->moov->iods;\n\t\torig_file->moov->iods = NULL;\n\t\te = gf_isom_clone_box((GF_Box *)orig_file->moov, (GF_Box **)&dest_file->moov);\n\t\tif (e) {\n\t\t\tgf_list_del(tracks);\n\t\t\torig_file->moov->trackList = old_tracks;\n\t\t\treturn e;\n\t\t}\n\t\torig_file->moov->trackList = old_tracks;\n\t\tgf_list_del(tracks);\n\t\torig_file->moov->iods = (GF_ObjectDescriptorBox*)iods;\n\t\tgf_list_add(dest_file->TopBoxes, dest_file->moov);\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (dest_file->moov->mvex) {\n\t\t\tgf_isom_box_del_parent(&dest_file->moov->child_boxes, (GF_Box *)dest_file->moov->mvex);\n\t\t\tdest_file->moov->mvex = NULL;\n\t\t}\n#endif\n\n\t\tif (clone_tracks) {\n\t\t\tfor (i=0; i<gf_list_count(orig_file->moov->trackList); i++) {\n\t\t\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get( orig_file->moov->trackList, i);\n\t\t\t\tif (!trak) continue;\n\t\t\t\tif (keep_hint_tracks || (trak->Media->handler->handlerType != GF_ISOM_MEDIA_HINT)) {\n\t\t\t\t\te = gf_isom_clone_track(orig_file, i+1, dest_file, 0, &dstTrack);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (iods)\n\t\t\t\tgf_isom_clone_box((GF_Box *)orig_file->moov->iods, (GF_Box **)dest_file->moov->iods);\n\t\t} else {\n\t\t\tdest_file->moov->mvhd->nextTrackID = 1;\n\t\t\tgf_isom_clone_pl_indications(orig_file, dest_file);\n\t\t}\n\t\tdest_file->moov->mov = dest_file;\n\t}\n\n\tif (!keep_pssh) {\n\t\ti=0;\n\t\twhile ((box = (GF_Box*)gf_list_get(dest_file->moov->child_boxes, i++))) {\n\t\t\tif (box->type == GF_ISOM_BOX_TYPE_PSSH) {\n\t\t\t\ti--;\n\t\t\t\tgf_isom_box_del_parent(&dest_file->moov->child_boxes, box);\n\t\t\t}\n\t\t}\n\t}\n\n\t//duplicate other boxes\n\ti=0;\n\twhile ((box = (GF_Box*)gf_list_get(orig_file->TopBoxes, i++))) {\n\t\tswitch(box->type) {\n\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\tcase GF_ISOM_BOX_TYPE_STYP:\n\t\tcase GF_ISOM_BOX_TYPE_SIDX:\n\t\tcase GF_ISOM_BOX_TYPE_SSIX:\n\t\tcase GF_ISOM_BOX_TYPE_MOOF:\n#endif\n\t\tcase GF_ISOM_BOX_TYPE_JP:\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_PSSH:\n\t\t\tif (!keep_pssh)\n\t\t\t\tbreak;\n\n\t\tdefault:\n\t\t{\n\t\t\tGF_Box *box2 = NULL;\n\t\t\tgf_isom_clone_box(box, &box2);\n\t\t\tgf_list_add(dest_file->TopBoxes, box2);\n\t\t}\n\t\tbreak;\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n#endif\n\n\nGF_EXPORT\nGF_Err gf_isom_get_raw_user_data(GF_ISOFile *file, u8 **output, u32 *output_size)\n{\n\tGF_BitStream *bs;\n\tGF_Err e;\n\tGF_Box *b;\n\tu32 i;\n\n\t*output = NULL;\n\t*output_size = 0;\n\tif (!file || !file->moov || (!file->moov->udta && !file->moov->child_boxes)) return GF_OK;\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tif (file->moov->udta) {\n\t\te = gf_isom_box_size( (GF_Box *) file->moov->udta);\n\t\tif (e) goto exit;\n\t\te = gf_isom_box_write((GF_Box *) file->moov->udta, bs);\n\t\tif (e) goto exit;\n\t}\n\te = GF_OK;\n\ti=0;\n\twhile ((b = gf_list_enum(file->moov->child_boxes, &i))) {\n\t\tswitch (b->type) {\n\t\tcase GF_ISOM_BOX_TYPE_TRAK:\n\t\tcase GF_ISOM_BOX_TYPE_MVHD:\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tcase GF_ISOM_BOX_TYPE_MVEX:\n#endif\n\t\tcase GF_ISOM_BOX_TYPE_IODS:\n\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\tcontinue;\n\t\t}\n\t\te = gf_isom_box_size( (GF_Box *) b);\n\t\tif (e) goto exit;\n\t\te = gf_isom_box_write((GF_Box *) b, bs);\n\t\tif (e) goto exit;\n\t}\n\n\tgf_bs_get_content(bs, output, output_size);\n\nexit:\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_track_template(GF_ISOFile *file, u32 track, u8 **output, u32 *output_size)\n{\n\tGF_TrackBox *trak;\n\tGF_BitStream *bs;\n\tGF_DataReferenceBox *dref;\n\tGF_SampleTableBox *stbl, *stbl_temp;\n\tGF_SampleEncryptionBox *senc;\n\tGF_List *gpac_internals = NULL;\n\tu32 i, count;\n\n\t*output = NULL;\n\t*output_size = 0;\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\t//don't serialize dref\n\tdref = NULL;\n\tif (trak->Media->information->dataInformation) {\n\t\tdref = trak->Media->information->dataInformation->dref;\n\t\ttrak->Media->information->dataInformation->dref = NULL;\n\t\tgf_list_del_item(trak->Media->information->dataInformation->child_boxes, dref);\n\t}\n\n\t//don't serialize stbl but create a temp one\n\tstbl_temp = (GF_SampleTableBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STBL);\n\tif (!stbl_temp->child_boxes) stbl_temp->child_boxes = gf_list_new();\n\tstbl = trak->Media->information->sampleTable;\n\tgf_list_del_item(trak->Media->information->child_boxes, stbl);\n\n\ttrak->Media->information->sampleTable = stbl_temp;\n\tgf_list_add(trak->Media->information->child_boxes, stbl_temp);\n\n\t/*do not clone sampleDescription table but create an empty one*/\n\tstbl_temp->SampleDescription = (GF_SampleDescriptionBox *) gf_isom_box_new_parent(&stbl_temp->child_boxes, GF_ISOM_BOX_TYPE_STSD);\n\n\t/*clone sampleGroups description tables if any*/\n\tstbl_temp->sampleGroupsDescription = stbl->sampleGroupsDescription;\n\tcount = gf_list_count(stbl->sampleGroupsDescription);\n\tfor (i=0;i<count; i++) {\n\t\tGF_SampleGroupDescriptionBox *b = gf_list_get(stbl->sampleGroupsDescription, i);\n\t\t//don't add our internal sample groups\n\t\tif (b->grouping_type==GF_4CC('E','M','S','G'))\n\t\t\tcontinue;\n\t\tif (b->grouping_type==GF_4CC('P','S','S','H'))\n\t\t\tcontinue;\n\t\tgf_list_add(stbl_temp->child_boxes, b);\n\t}\n\t/*clone CompositionToDecode table, we may remove it later*/\n\tstbl_temp->CompositionToDecode = stbl->CompositionToDecode;\n\tgf_list_add(stbl_temp->child_boxes, stbl->CompositionToDecode);\n\n\n\tcount = gf_list_count(trak->child_boxes);\n\tfor (i=0;i<count; i++) {\n\t\tGF_UnknownBox *b = gf_list_get(trak->child_boxes, i);\n\t\tif (b->type != GF_ISOM_BOX_TYPE_UNKNOWN) continue;\n\t\tif (b->original_4cc==GF_ISOM_BOX_TYPE_GDAT) {\n\t\t\tif (!gpac_internals) gpac_internals = gf_list_new();\n\t\t\tgf_list_add(gpac_internals, b);\n\t\t\tgf_list_rem(trak->child_boxes, i);\n\t\t\ti--;\n\t\t\tcount--;\n\t\t}\n\t}\n\n\t//don't serialize senc\n\tsenc = trak->sample_encryption;\n\tif (senc) {\n\t\tassert(trak->child_boxes);\n\t\tgf_list_del_item(trak->child_boxes, senc);\n\t\ttrak->sample_encryption = NULL;\n\t}\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tgf_isom_box_size( (GF_Box *) trak);\n\tgf_isom_box_write((GF_Box *) trak, bs);\n\tgf_bs_get_content(bs, output, output_size);\n\tgf_bs_del(bs);\n\n\t//restore our pointers\n\tif (dref) {\n\t\ttrak->Media->information->dataInformation->dref = dref;\n\t\tgf_list_add(trak->Media->information->dataInformation->child_boxes, dref);\n\t}\n\ttrak->Media->information->sampleTable = stbl;\n\tgf_list_add(trak->Media->information->child_boxes, stbl);\n\tgf_list_del_item(trak->Media->information->child_boxes, stbl_temp);\n\tif (senc) {\n\t\ttrak->sample_encryption = senc;\n\t\tgf_list_add(trak->child_boxes, senc);\n\t}\n\n\tstbl_temp->sampleGroupsDescription = NULL;\n\tcount = gf_list_count(stbl->sampleGroupsDescription);\n\tfor (i=0;i<count; i++) {\n\t\tGF_Box *b = gf_list_get(stbl->sampleGroupsDescription, i);\n\t\tgf_list_del_item(stbl_temp->child_boxes, b);\n\t}\n\n\tstbl_temp->CompositionToDecode = NULL;\n\tgf_list_del_item(stbl_temp->child_boxes, stbl->CompositionToDecode);\n\tgf_isom_box_del((GF_Box *)stbl_temp);\n\n\tif (gpac_internals) {\n\t\tgf_list_transfer(trak->child_boxes, gpac_internals);\n\t\tgf_list_del(gpac_internals);\n\t}\n\treturn GF_OK;\n\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_trex_template(GF_ISOFile *file, u32 track, u8 **output, u32 *output_size)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_TrackBox *trak;\n\tGF_BitStream *bs;\n\tu32 i;\n\tGF_TrackExtendsBox *trex = NULL;\n\tGF_TrackExtensionPropertiesBox *trexprop = NULL;\n\n\t*output = NULL;\n\t*output_size = 0;\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tif (!file->moov->mvex) return GF_NOT_FOUND;\n\tfor (i=0; i<gf_list_count(file->moov->mvex->TrackExList); i++) {\n\t\ttrex = gf_list_get(file->moov->mvex->TrackExList, i);\n\t\tif (trex->trackID == trak->Header->trackID) break;\n\t\ttrex = NULL;\n\t}\n\tif (!trex) return GF_NOT_FOUND;\n\n\tfor (i=0; i<gf_list_count(file->moov->mvex->TrackExPropList); i++) {\n\t\ttrexprop = gf_list_get(file->moov->mvex->TrackExPropList, i);\n\t\tif (trexprop->trackID== trak->Header->trackID) break;\n\t\ttrexprop = NULL;\n\t}\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_box_size( (GF_Box *) trex);\n\tgf_isom_box_write((GF_Box *) trex, bs);\n\n\tif (trexprop) {\n\t\tgf_isom_box_size( (GF_Box *) trexprop);\n\t\tgf_isom_box_write((GF_Box *) trexprop, bs);\n\t}\n\tgf_bs_get_content(bs, output, output_size);\n\tgf_bs_del(bs);\n\n#else\n\t*output = NULL;\n\t*output_size = 0;\n#endif\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_stsd_template(GF_ISOFile *file, u32 track, u32 stsd_idx, u8 **output, u32 *output_size)\n{\n\tGF_TrackBox *trak;\n\tGF_BitStream *bs;\n\tGF_Box *ent;\n\n\t*output = NULL;\n\t*output_size = 0;\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleDescription) return GF_BAD_PARAM;\n\n\tif (stsd_idx) {\n\t\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, stsd_idx-1);\n\t\tif (!ent) return GF_BAD_PARAM;\n\t} else {\n\t\tent = (GF_Box*) trak->Media->information->sampleTable->SampleDescription;\n\t}\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tgf_isom_box_size(ent);\n\tgf_isom_box_write(ent, bs);\n\tgf_bs_get_content(bs, output, output_size);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_clone_track(GF_ISOFile *orig_file, u32 orig_track, GF_ISOFile *dest_file, GF_ISOTrackCloneFlags flags, u32 *dest_track)\n{\n\tGF_TrackBox *trak, *new_tk;\n\tGF_BitStream *bs;\n\tu8 *data;\n\tconst u8 *buffer;\n\tu32 data_size;\n\tu32 i, count;\n\tGF_Err e;\n\tGF_SampleTableBox *stbl, *stbl_temp;\n\tGF_SampleEncryptionBox *senc;\n\n\te = CanAccessMovie(dest_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(dest_file);\n\tif (e) return e;\n\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(orig_file, orig_track);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tstbl_temp = (GF_SampleTableBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STBL);\n\tif (!stbl_temp->child_boxes) stbl_temp->child_boxes = gf_list_new();\n\n\ttrak->Media->information->sampleTable = stbl_temp;\n\tgf_list_add(trak->Media->information->child_boxes, stbl_temp);\n\tgf_list_del_item(trak->Media->information->child_boxes, stbl);\n\n\tif (!stbl_temp->child_boxes) stbl_temp->child_boxes = gf_list_new();\n\n\t/*clone sampleDescription table*/\n\tstbl_temp->SampleDescription = stbl->SampleDescription;\n\tgf_list_add(stbl_temp->child_boxes, stbl->SampleDescription);\n\t/*also clone sampleGroups description tables if any*/\n\tstbl_temp->sampleGroupsDescription = stbl->sampleGroupsDescription;\n\tcount = gf_list_count(stbl->sampleGroupsDescription);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *b = gf_list_get(stbl->sampleGroupsDescription, i);\n\t\tgf_list_add(stbl_temp->child_boxes, b);\n\t}\n\t/*clone CompositionToDecode table, we may remove it later*/\n\tstbl_temp->CompositionToDecode = stbl->CompositionToDecode;\n\tgf_list_add(stbl_temp->child_boxes, stbl->CompositionToDecode);\n\n\tsenc = trak->sample_encryption;\n\tif (senc) {\n\t\tassert(trak->child_boxes);\n\t\tgf_list_del_item(trak->child_boxes, senc);\n\t\ttrak->sample_encryption = NULL;\n\t}\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tgf_isom_box_size( (GF_Box *) trak);\n\tgf_isom_box_write((GF_Box *) trak, bs);\n\tgf_bs_get_content(bs, &data, &data_size);\n\tgf_bs_del(bs);\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\tif (flags & GF_ISOM_CLONE_TRACK_NO_QT)\n\t\tgf_bs_set_cookie(bs, GF_ISOM_BS_COOKIE_QT_CONV | GF_ISOM_BS_COOKIE_CLONE_TRACK);\n\telse\n\t\tgf_bs_set_cookie(bs, GF_ISOM_BS_COOKIE_CLONE_TRACK);\n\n\te = gf_isom_box_parse((GF_Box **) &new_tk, bs);\n\tgf_bs_del(bs);\n\tgf_free(data);\n\n\ttrak->Media->information->sampleTable = stbl;\n\tgf_list_del_item(trak->Media->information->child_boxes, stbl_temp);\n\tgf_list_add(trak->Media->information->child_boxes, stbl);\n\n\tif (senc) {\n\t\ttrak->sample_encryption = senc;\n\t\tgf_list_add(trak->child_boxes, senc);\n\t}\n\tgf_list_del_item(stbl_temp->child_boxes, stbl_temp->SampleDescription);\n\tstbl_temp->SampleDescription = NULL;\n\n\tcount = gf_list_count(stbl->sampleGroupsDescription);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *b = gf_list_get(stbl->sampleGroupsDescription, i);\n\t\tgf_list_del_item(stbl_temp->child_boxes, b);\n\t}\n\tstbl_temp->sampleGroupsDescription = NULL;\n\n\tgf_list_del_item(stbl_temp->child_boxes, stbl_temp->CompositionToDecode);\n\tstbl_temp->CompositionToDecode = NULL;\n\tgf_isom_box_del((GF_Box *)stbl_temp);\n\n\tif (e) {\n\t\tif (new_tk) gf_isom_box_del((GF_Box *)new_tk);\n\t\treturn e;\n\t}\n\n\tgf_isom_disable_inplace_rewrite(dest_file);\n\n\t/*create default boxes*/\n\tstbl = new_tk->Media->information->sampleTable;\n\tstbl->ChunkOffset = gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STCO);\n\tif (!stbl->ChunkOffset) return GF_OUT_OF_MEM;\n\tstbl->SampleSize = (GF_SampleSizeBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSZ);\n\tif (!stbl->SampleSize) return GF_OUT_OF_MEM;\n\tstbl->SampleToChunk = (GF_SampleToChunkBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSC);\n\tif (!stbl->SampleToChunk) return GF_OUT_OF_MEM;\n\tstbl->TimeToSample = (GF_TimeToSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STTS);\n\tif (!stbl->TimeToSample) return GF_OUT_OF_MEM;\n\n\tif (flags & GF_ISOM_CLONE_TRACK_DROP_ID)\n\t\tnew_tk->Header->trackID = 0;\n\n\t/*check trackID validity before adding track*/\n\tif (!new_tk->Header->trackID || gf_isom_get_track_by_id(dest_file, new_tk->Header->trackID)) {\n\t\tu32 ID = 1;\n\t\twhile (1) {\n\t\t\tif (RequestTrack(dest_file->moov, ID)) break;\n\t\t\tID += 1;\n\t\t\tif (ID == 0xFFFFFFFF) break;\n\t\t}\n\t\tnew_tk->Header->trackID = ID;\n\t}\n\tif (!dest_file->moov->child_boxes) dest_file->moov->child_boxes = gf_list_new();\n\tgf_list_add(dest_file->moov->child_boxes, new_tk);\n\tmoov_on_child_box((GF_Box*)dest_file->moov, (GF_Box *)new_tk, GF_FALSE);\n\n\t/*set originalID*/\n\tnew_tk->originalID = trak->Header->trackID;\n\t/*set originalFile*/\n\tbuffer = gf_isom_get_filename(orig_file);\n\tnew_tk->originalFile = gf_crc_32(buffer, (u32) strlen(buffer));\n\n\t/*rewrite edit list segmentDuration to new movie timescale*/\n\tif (dest_file->moov->mvhd->timeScale != orig_file->moov->mvhd->timeScale) {\n\t\tDouble ts_scale = dest_file->moov->mvhd->timeScale;\n\t\tts_scale /= orig_file->moov->mvhd->timeScale;\n\t\tnew_tk->Header->duration = (u64) (new_tk->Header->duration * ts_scale);\n\t\tif (new_tk->editBox && new_tk->editBox->editList) {\n\t\t\tcount = gf_list_count(new_tk->editBox->editList->entryList);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_EdtsEntry *ent = (GF_EdtsEntry *)gf_list_get(new_tk->editBox->editList->entryList, i);\n\t\t\t\tent->segmentDuration = (u64) (ent->segmentDuration * ts_scale);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (flags & GF_ISOM_CLONE_RESET_DURATION)\n\t\tnew_tk->Media->mediaHeader->duration = 0;\n\n\tif (!new_tk->Media->information->dataInformation->dref) return GF_BAD_PARAM;\n\n\t/*reset data ref*/\n\tif (! (flags & GF_ISOM_CLONE_TRACK_KEEP_DREF) ) {\n\t\tGF_SampleEntryBox *entry;\n\t\tBool use_alis = GF_FALSE;\n\t\tif (! (flags & GF_ISOM_CLONE_TRACK_NO_QT)) {\n\t\t\tGF_Box *b = gf_list_get(new_tk->Media->information->dataInformation->dref->child_boxes, 0);\n\t\t\tif (b && (b->type==GF_QT_BOX_TYPE_ALIS))\n\t\t\t\tuse_alis = GF_TRUE;\n\t\t}\n\t\tgf_isom_box_array_del(new_tk->Media->information->dataInformation->dref->child_boxes);\n\t\tnew_tk->Media->information->dataInformation->dref->child_boxes = gf_list_new();\n\t\t/*update data ref*/\n\t\tentry = (GF_SampleEntryBox*)gf_list_get(new_tk->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\tif (entry) {\n\t\t\tu32 dref;\n\t\t\tMedia_CreateDataRef(dest_file, new_tk->Media->information->dataInformation->dref, use_alis ?  \"alis\" : NULL, NULL, &dref);\n\t\t\tentry->dataReferenceIndex = dref;\n\t\t}\n\t} else {\n\t\tfor (i=0; i<gf_list_count(new_tk->Media->information->dataInformation->dref->child_boxes); i++) {\n\t\t\tGF_DataEntryBox *dref_entry = (GF_DataEntryBox *)gf_list_get(new_tk->Media->information->dataInformation->dref->child_boxes, i);\n\t\t\tif (dref_entry->flags & 1) {\n\t\t\t\tdref_entry->flags &= ~1;\n\t\t\t\te = Media_SetDrefURL((GF_DataEntryURLBox *)dref_entry, orig_file->fileName, dest_file->finalName);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t}\n\t}\n\n\t//purge all 'gpac' boxes at track level\n\tfor (i=0; i<gf_list_count(new_tk->child_boxes); i++) {\n\t\tGF_UnknownBox *b = (GF_UnknownBox *)gf_list_get(new_tk->child_boxes, i);\n\t\tif (b->type != GF_ISOM_BOX_TYPE_UNKNOWN) continue;\n\t\tif (b->original_4cc==GF_ISOM_BOX_TYPE_GDAT) {\n\t\t\tgf_list_rem(new_tk->child_boxes, i);\n\t\t\ti--;\n\t\t\tgf_isom_box_del((GF_Box*)b);\n\t\t}\n\t}\n\n\t*dest_track = gf_list_count(dest_file->moov->trackList);\n\n\tif (dest_file->moov->mvhd->nextTrackID <= new_tk->Header->trackID)\n\t\tdest_file->moov->mvhd->nextTrackID = new_tk->Header->trackID+1;\n\n\treturn GF_OK;\n}\n\n#if 0\n/*clones all sampleDescription entries in new track, after an optional reset of existing entries*/\nGF_Err gf_isom_clone_sample_descriptions(GF_ISOFile *the_file, u32 trackNumber, GF_ISOFile *orig_file, u32 orig_track, Bool reset_existing)\n{\n\tu32 i;\n\tGF_TrackBox *dst_trak, *src_trak;\n\tGF_Err e = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tdst_trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!dst_trak || !dst_trak->Media) return GF_BAD_PARAM;\n\tsrc_trak = gf_isom_get_track_from_file(orig_file, orig_track);\n\tif (!src_trak || !src_trak->Media) return GF_BAD_PARAM;\n\n\tif (reset_existing) {\n\t\tgf_isom_box_array_del(dst_trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\t\tdst_trak->Media->information->sampleTable->SampleDescription->child_boxes = gf_list_new();\n\t}\n\n\tfor (i=0; i<gf_list_count(src_trak->Media->information->sampleTable->SampleDescription->child_boxes); i++) {\n\t\tu32 outDesc;\n\t\te = gf_isom_clone_sample_description(the_file, trackNumber, orig_file, orig_track, i+1, NULL, NULL, &outDesc);\n\t\tif (e) break;\n\t}\n\treturn e;\n}\n#endif\n\n\nGF_EXPORT\nGF_Err gf_isom_clone_sample_description(GF_ISOFile *the_file, u32 trackNumber, GF_ISOFile *orig_file, u32 orig_track, u32 orig_desc_index, const char *URLname, const char *URNname, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_BitStream *bs;\n\tu8 *data;\n\tu32 data_size;\n\tGF_Box *entry;\n\tGF_Err e;\n\tu32 dataRefIndex;\n    u32 mtype;\n\tu32 internal_type;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(orig_file, orig_track);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tentry = (GF_Box*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, orig_desc_index-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tinternal_type = ((GF_SampleEntryBox *)entry)->internal_type;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tgf_isom_box_size(entry);\n\tgf_isom_box_write(entry, bs);\n\tgf_bs_get_content(bs, &data, &data_size);\n\tgf_bs_del(bs);\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\te = gf_isom_box_parse(&entry, bs);\n\tgf_bs_del(bs);\n\tgf_free(data);\n\tif (e) return e;\n\tif (entry->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\tGF_UnknownBox *ubox = (GF_UnknownBox*)entry;\n\t\tif (internal_type == GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t\tGF_GenericVisualSampleEntryBox *ve = (GF_GenericVisualSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRV);\n\t\t\tve->EntryType = ubox->type;\n\t\t\tve->data = ubox->data;\n\t\t\tve->data_size = ubox->dataSize;\n\t\t\tentry = (GF_Box *) ve;\n\t\t}\n\t\telse if (internal_type == GF_ISOM_SAMPLE_ENTRY_AUDIO) {\n\t\t\tGF_GenericAudioSampleEntryBox *ae = (GF_GenericAudioSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRA);\n\t\t\tae->EntryType = ubox->type;\n\t\t\tae->data = ubox->data;\n\t\t\tae->data_size = ubox->dataSize;\n\t\t\tentry = (GF_Box *) ae;\n\t\t}\n\t\telse {\n\t\t\tGF_GenericSampleEntryBox *ge = (GF_GenericSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRM);\n\t\t\tge->EntryType = ubox->type;\n\t\t\tge->data = ubox->data;\n\t\t\tge->data_size = ubox->dataSize;\n\t\t\tentry = (GF_Box *) ge;\n\t\t}\n\t\tubox->data = NULL;\n\t\tubox->dataSize = 0;\n\t\tgf_isom_box_del((GF_Box *)ubox);\n\t}\n\n\t/*get new track and insert clone*/\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media) goto exit;\n\n\t/*get or create the data ref*/\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) goto exit;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(the_file, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) goto exit;\n\t}\n\tif (!the_file->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\t/*overwrite dref*/\n\t((GF_SampleEntryBox *)entry)->dataReferenceIndex = dataRefIndex;\n\te = gf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, entry);\n\t*outDescriptionIndex = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\n\t/*also clone track w/h info*/\n    mtype = gf_isom_get_media_type(the_file, trackNumber);\n\tif (gf_isom_is_video_handler_type(mtype) ) {\n\t\tgf_isom_set_visual_info(the_file, trackNumber, (*outDescriptionIndex), ((GF_VisualSampleEntryBox*)entry)->Width, ((GF_VisualSampleEntryBox*)entry)->Height);\n\t}\n\treturn e;\n\nexit:\n\tgf_isom_box_del(entry);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_new_generic_sample_description(GF_ISOFile *movie, u32 trackNumber, const char *URLname, const char *URNname, GF_GenericSampleDescription *udesc, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu8 **wrap_data;\n\tu32 *wrap_size;\n\tu32 dataRefIndex;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !udesc) return GF_BAD_PARAM;\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(movie, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (gf_isom_is_video_handler_type(trak->Media->handler->handlerType)) {\n\t\tGF_GenericVisualSampleEntryBox *entry;\n\t\t//create a new entry\n\t\tentry = (GF_GenericVisualSampleEntryBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRV);\n\t\tif (!entry) return GF_OUT_OF_MEM;\n\n\t\tif (!udesc->codec_tag) {\n\t\t\tentry->EntryType = GF_ISOM_BOX_TYPE_UUID;\n\t\t\tmemcpy(entry->uuid, udesc->UUID, sizeof(bin128));\n\t\t} else {\n\t\t\tentry->EntryType = udesc->codec_tag;\n\t\t}\n\t\tif (entry->EntryType == 0) {\n\t\t\tgf_isom_box_del((GF_Box *)entry);\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\n\t\tentry->dataReferenceIndex = dataRefIndex;\n\t\tentry->vendor = udesc->vendor_code;\n\t\tentry->version = udesc->version;\n\t\tentry->revision = udesc->revision;\n\t\tentry->temporal_quality = udesc->temporal_quality;\n\t\tentry->spatial_quality = udesc->spatial_quality;\n\t\tentry->Width = udesc->width;\n\t\tentry->Height = udesc->height;\n\t\tstrcpy(entry->compressor_name, udesc->compressor_name);\n\t\tentry->color_table_index = -1;\n\t\tentry->frames_per_sample = 1;\n\t\tentry->horiz_res = udesc->h_res ? udesc->h_res : 0x00480000;\n\t\tentry->vert_res = udesc->v_res ? udesc->v_res : 0x00480000;\n\t\tentry->bit_depth = udesc->depth ? udesc->depth : 0x18;\n\t\twrap_data = &entry->data;\n\t\twrap_size = &entry->data_size;\n\t\te = gf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, entry);\n\t}\n\telse if (trak->Media->handler->handlerType==GF_ISOM_MEDIA_AUDIO) {\n\t\tGF_GenericAudioSampleEntryBox *gena;\n\t\t//create a new entry\n\t\tgena = (GF_GenericAudioSampleEntryBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRA);\n\t\tif (!gena) return GF_OUT_OF_MEM;\n\n\t\tif (!udesc->codec_tag) {\n\t\t\tgena->EntryType = GF_ISOM_BOX_TYPE_UUID;\n\t\t\tmemcpy(gena->uuid, udesc->UUID, sizeof(bin128));\n\t\t} else {\n\t\t\tgena->EntryType = udesc->codec_tag;\n\t\t}\n\t\tif (gena->EntryType == 0) {\n\t\t\tgf_isom_box_del((GF_Box *)gena);\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\n\t\tgena->dataReferenceIndex = dataRefIndex;\n\t\tgena->vendor = udesc->vendor_code;\n\t\tgena->version = udesc->version;\n\t\tgena->revision = udesc->revision;\n\t\tgena->bitspersample = udesc->bits_per_sample ? udesc->bits_per_sample : 16;\n\t\tgena->channel_count = udesc->nb_channels ? udesc->nb_channels : 2;\n\t\tgena->samplerate_hi = udesc->samplerate;\n\t\tgena->samplerate_lo = 0;\n\t\tgena->qtff_mode = udesc->is_qtff ? GF_ISOM_AUDIO_QTFF_ON_NOEXT : GF_ISOM_AUDIO_QTFF_NONE;\n\t\tif (gena->EntryType==GF_QT_SUBTYPE_LPCM) {\n\t\t\tgena->version = 2;\n\t\t\tgena->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_EXT_VALID;\n\t\t\tGF_BitStream *bs = gf_bs_new(gena->extensions, 36, GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_u32(bs, 72);\n\t\t\tgf_bs_write_double(bs, udesc->samplerate);\n\t\t\tgf_bs_write_u32(bs, udesc->nb_channels);\n\t\t\tgf_bs_write_u32(bs, 0x7F000000);\n\t\t\tgf_bs_write_u32(bs, gena->bitspersample);\n\t\t\tgf_bs_write_u32(bs, udesc->lpcm_flags);\n\t\t\tgf_bs_write_u32(bs, udesc->nb_channels*gena->bitspersample/8); //constBytesPerAudioPacket\n\t\t\tgf_bs_write_u32(bs, 1); //constLPCMFramesPerAudioPacket\n\t\t\tgf_bs_del(bs);\n\t\t\tgena->revision = 0;\n\t\t\tgena->vendor = 0;\n\t\t\tgena->channel_count = 3;\n\t\t\tgena->bitspersample = 16;\n\t\t\tgena->compression_id = 0xFFFE;\n\t\t\tgena->packet_size = 0;\n\t\t\tgena->samplerate_hi = 1;\n\t\t} else if (udesc->is_qtff) {\n\t\t\tGF_Box *b = gf_isom_box_new_parent(&gena->child_boxes, GF_QT_BOX_TYPE_WAVE);\n\t\t\tGF_ChromaInfoBox *enda = (GF_ChromaInfoBox*) gf_isom_box_new_parent(&b->child_boxes, GF_QT_BOX_TYPE_ENDA);\n\t\t\t((GF_ChromaInfoBox *)enda)->chroma = (udesc->lpcm_flags & (1<<1)) ? 0 : 1;\n\n\t\t\tGF_UnknownBox *term = (GF_UnknownBox*) gf_isom_box_new_parent(&b->child_boxes, GF_ISOM_BOX_TYPE_UNKNOWN);\n\t\t\tif (term) term->original_4cc = 0;\n\t\t}\n\n\t\twrap_data = &gena->data;\n\t\twrap_size = &gena->data_size;\n\t\te = gf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, gena);\n\t}\n\telse {\n\t\tGF_GenericSampleEntryBox *genm;\n\t\t//create a new entry\n\t\tgenm = (GF_GenericSampleEntryBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRM);\n\t\tif (!genm) return GF_OUT_OF_MEM;\n\n\t\tif (!udesc->codec_tag) {\n\t\t\tgenm->EntryType = GF_ISOM_BOX_TYPE_UUID;\n\t\t\tmemcpy(genm->uuid, udesc->UUID, sizeof(bin128));\n\t\t} else {\n\t\t\tgenm->EntryType = udesc->codec_tag;\n\t\t}\n\t\tif (genm->EntryType == 0) {\n\t\t\tgf_isom_box_del((GF_Box *)genm);\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t\tgenm->dataReferenceIndex = dataRefIndex;\n\t\twrap_data = &genm->data;\n\t\twrap_size = &genm->data_size;\n\t\te = gf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, genm);\n\t}\n\t*outDescriptionIndex = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\n\tif (udesc->extension_buf && udesc->extension_buf_size) {\n\t\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tif (udesc->ext_box_wrap) {\n\t\t\tgf_bs_write_u32(bs, 8+udesc->extension_buf_size);\n\t\t\tgf_bs_write_u32(bs, udesc->ext_box_wrap);\n\t\t}\n\t\tgf_bs_write_data(bs, udesc->extension_buf, udesc->extension_buf_size);\n\t\tgf_bs_get_content(bs, wrap_data, wrap_size);\n\t\tgf_bs_del(bs);\n\t}\n\treturn e;\n}\n\n//use carefully. Very useful when you made a lot of changes (IPMP, IPI, OCI, ...)\n//THIS WILL REPLACE THE WHOLE DESCRIPTOR ...\n#if 0 //unused\n/*change the data field of an unknown sample description*/\nGF_Err gf_isom_change_generic_sample_description(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, GF_GenericSampleDescription *udesc)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_GenericVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !StreamDescriptionIndex) return GF_BAD_PARAM;\n\n\tentry = (GF_GenericVisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tif (entry->type == GF_ISOM_BOX_TYPE_GNRV) {\n\t\tentry->vendor = udesc->vendor_code;\n\t\tentry->version = udesc->version;\n\t\tentry->revision = udesc->revision;\n\t\tentry->temporal_quality = udesc->temporal_quality;\n\t\tentry->spatial_quality = udesc->spatial_quality;\n\t\tentry->Width = udesc->width;\n\t\tentry->Height = udesc->height;\n\t\tstrcpy(entry->compressor_name, udesc->compressor_name);\n\t\tentry->color_table_index = -1;\n\t\tentry->frames_per_sample = 1;\n\t\tentry->horiz_res = udesc->h_res ? udesc->h_res : 0x00480000;\n\t\tentry->vert_res = udesc->v_res ? udesc->v_res : 0x00480000;\n\t\tentry->bit_depth = udesc->depth ? udesc->depth : 0x18;\n\t\tif (entry->data) gf_free(entry->data);\n\t\tentry->data = NULL;\n\t\tentry->data_size = 0;\n\t\tif (udesc->extension_buf && udesc->extension_buf_size) {\n\t\t\tentry->data = (char*)gf_malloc(sizeof(char) * udesc->extension_buf_size);\n\t\t\tif (!entry->data) {\n\t\t\t\tgf_isom_box_del((GF_Box *) entry);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tmemcpy(entry->data, udesc->extension_buf, udesc->extension_buf_size);\n\t\t\tentry->data_size = udesc->extension_buf_size;\n\t\t}\n\t\treturn GF_OK;\n\t} else if (entry->type == GF_ISOM_BOX_TYPE_GNRA) {\n\t\tGF_GenericAudioSampleEntryBox *gena = (GF_GenericAudioSampleEntryBox *)entry;\n\t\tgena->vendor = udesc->vendor_code;\n\t\tgena->version = udesc->version;\n\t\tgena->revision = udesc->revision;\n\t\tgena->bitspersample = udesc->bits_per_sample ? udesc->bits_per_sample : 16;\n\t\tgena->channel_count = udesc->nb_channels ? udesc->nb_channels : 2;\n\t\tgena->samplerate_hi = udesc->samplerate;\n\t\tgena->samplerate_lo = 0;\n\t\tif (gena->data) gf_free(gena->data);\n\t\tgena->data = NULL;\n\t\tgena->data_size = 0;\n\n\t\tif (udesc->extension_buf && udesc->extension_buf_size) {\n\t\t\tgena->data = (char*)gf_malloc(sizeof(char) * udesc->extension_buf_size);\n\t\t\tif (!gena->data) {\n\t\t\t\tgf_isom_box_del((GF_Box *) gena);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tmemcpy(gena->data, udesc->extension_buf, udesc->extension_buf_size);\n\t\t\tgena->data_size = udesc->extension_buf_size;\n\t\t}\n\t\treturn GF_OK;\n\t} else if (entry->type == GF_ISOM_BOX_TYPE_GNRM) {\n\t\tGF_GenericSampleEntryBox *genm = (GF_GenericSampleEntryBox *)entry;\n\t\tif (genm->data) gf_free(genm->data);\n\t\tgenm->data = NULL;\n\t\tgenm->data_size = 0;\n\n\t\tif (udesc->extension_buf && udesc->extension_buf_size) {\n\t\t\tgenm->data = (char*)gf_malloc(sizeof(char) * udesc->extension_buf_size);\n\t\t\tif (!genm->data) {\n\t\t\t\tgf_isom_box_del((GF_Box *) genm);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tmemcpy(genm->data, udesc->extension_buf, udesc->extension_buf_size);\n\t\t\tgenm->data_size = udesc->extension_buf_size;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\treturn GF_BAD_PARAM;\n}\n#endif\n\n#if 0\n/*removes given stream description*/\nGF_Err gf_isom_remove_sample_description(GF_ISOFile *movie, u32 trackNumber, u32 streamDescIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_Box *entry;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !streamDescIndex) return GF_BAD_PARAM;\n\tentry = (GF_Box*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, streamDescIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tgf_list_rem(trak->Media->information->sampleTable->SampleDescription->child_boxes, streamDescIndex-1);\n\tgf_isom_box_del(entry);\n\treturn GF_OK;\n}\n#endif\n\n//sets a track reference\nGF_EXPORT\nGF_Err gf_isom_set_track_reference(GF_ISOFile *the_file, u32 trackNumber, u32 referenceType, GF_ISOTrackID ReferencedTrackID)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceBox *tref;\n\tGF_TrackReferenceTypeBox *dpnd;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//no tref, create one\n\ttref = trak->References;\n\tif (!tref) {\n\t\ttref = (GF_TrackReferenceBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TREF);\n\t\tif (!tref) return GF_OUT_OF_MEM;\n\t\te = trak_on_child_box((GF_Box*)trak, (GF_Box *) tref, GF_FALSE);\n\t\tif (e) return e;\n\t}\n\t//find a ref of the given type\n\te = Track_FindRef(trak, referenceType, &dpnd);\n\tif (e) return e;\n\n\tif (!dpnd) {\n\t\tdpnd = (GF_TrackReferenceTypeBox *) gf_isom_box_new_parent(&tref->child_boxes, GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!dpnd) return GF_OUT_OF_MEM;\n\t\tdpnd->reference_type = referenceType;\n\t}\n\t//add the ref\n\treturn reftype_AddRefTrack(dpnd, ReferencedTrackID, NULL);\n}\n\nGF_EXPORT\nGF_Err gf_isom_purge_track_reference(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *ref;\n\tu32 i=0;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//no tref, nothing to remove\n\tif (!trak->References) return GF_OK;\n\n\twhile ((ref = gf_list_enum(trak->References->child_boxes, &i))) {\n\t\tu32 k;\n\t\tif (!ref->reference_type) continue;\n\n\t\tfor (k=0; k<ref->trackIDCount; k++) {\n\t\t\tu32 tk = gf_isom_get_track_by_id(the_file, ref->trackIDs[k]);\n\t\t\tif (!tk) {\n\t\t\t\tmemmove(&ref->trackIDs[k], &ref->trackIDs[k+1], ref->trackIDCount-k-1);\n\t\t\t\tk--;\n\t\t\t\tref->trackIDCount--;\n\t\t\t}\n\t\t}\n\t\tif (!ref->trackIDCount) {\n\t\t\ti--;\n\t\t\tgf_isom_box_del_parent(&trak->References->child_boxes, (GF_Box *) ref);\n\t\t}\n\t}\n\tif (!trak->References->child_boxes || !gf_list_count(trak->References->child_boxes)) {\n\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *) trak->References);\n\t\ttrak->References = NULL;\n\t}\n\treturn GF_OK;\n}\n\n//sets a track reference\nGF_EXPORT\nGF_Err gf_isom_remove_track_references(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (trak->References) {\n\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->References);\n\t\ttrak->References = NULL;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_track_reference(GF_ISOFile *isom_file, u32 trackNumber, u32 ref_type)\n{\n\tGF_TrackBox *trak;\n\tu32 i=0;\n\tGF_TrackReferenceTypeBox *ref;\n\ttrak = gf_isom_get_track_from_file(isom_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (!trak->References) return GF_OK;\n\twhile ((ref = gf_list_enum(trak->References->child_boxes, &i))) {\n\t\tif (ref->reference_type == ref_type) {\n\t\t\tgf_isom_box_del_parent(&trak->References->child_boxes, (GF_Box *)ref);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!gf_list_count(trak->References->child_boxes)) {\n\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->References);\n\t\ttrak->References = NULL;\n\t}\n\treturn GF_OK;\n\n}\n\n//changes track ID\nGF_EXPORT\nGF_Err gf_isom_set_track_id(GF_ISOFile *movie, u32 trackNumber, GF_ISOTrackID trackID)\n{\n\tGF_TrackReferenceTypeBox *ref;\n\tGF_TrackBox *trak, *a_trak;\n\tu32 i, j, k;\n\n\tif (!movie) return GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (trak && (trak->Header->trackID==trackID)) return GF_OK;\n\ta_trak = gf_isom_get_track_from_id(movie->moov, trackID);\n\tif (!trak || a_trak) return GF_BAD_PARAM;\n\n\t/*rewrite all dependencies*/\n\ti=0;\n\twhile ((a_trak = (GF_TrackBox*)gf_list_enum(movie->moov->trackList, &i))) {\n\t\tif (!a_trak->References) continue;\n\t\tj=0;\n\t\twhile ((ref = (GF_TrackReferenceTypeBox *)gf_list_enum(a_trak->References->child_boxes, &j))) {\n\t\t\tfor (k=0; k<ref->trackIDCount; k++) {\n\t\t\t\tif (ref->trackIDs[k]==trak->Header->trackID) {\n\t\t\t\t\tref->trackIDs[k] = trackID;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*and update IOD if any*/\n\tif (movie->moov->iods && movie->moov->iods->descriptor) {\n\t\tGF_ES_ID_Inc *inc;\n\t\tGF_IsomObjectDescriptor *od = (GF_IsomObjectDescriptor *)movie->moov->iods->descriptor;\n\n\t\ti=0;\n\t\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(od->ES_ID_IncDescriptors, &i))) {\n\t\t\tif (inc->trackID==trak->Header->trackID) inc->trackID = trackID;\n\t\t}\n\t}\n\ttrak->Header->trackID = trackID;\n\tupdate_next_track_id(movie);\n\treturn GF_OK;\n}\n\n/*force to rewrite all dependencies when the trackID of referenced track changes*/\nGF_EXPORT\nGF_Err gf_isom_rewrite_track_dependencies(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackReferenceTypeBox *ref;\n\tGF_TrackBox *trak, *a_trak;\n\tu32 i, k;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak)\n\t\treturn GF_BAD_PARAM;\n\tif (!trak->References)\n\t\treturn GF_OK;\n\n\ti=0;\n\twhile ((ref = (GF_TrackReferenceTypeBox *)gf_list_enum(trak->References->child_boxes, &i))) {\n\t\tfor (k=0; k < ref->trackIDCount; k++) {\n\t\t\ta_trak = gf_isom_get_track_from_original_id(movie->moov, ref->trackIDs[k], trak->originalFile);\n\t\t\tif (a_trak) {\n\t\t\t\tref->trackIDs[k] = a_trak->Header->trackID;\n\t\t\t} else {\n\t\t\t\ta_trak = gf_isom_get_track_from_id(movie->moov, ref->trackIDs[k]);\n\t\t\t\t/*we should have a track with no original ID (not imported) - should we rewrite the dependency ?*/\n\t\t\t\tif (! a_trak || a_trak->originalID) return GF_BAD_PARAM;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\n#if 0 //unused\n\n/*! changes the sample description index of a sample\n\\param isom_file the destination ISO file\n\\param trackNumber the destination track\n\\param sampleNum the target sample number\n\\param fnewSampleDescIndex the new sample description index to assign to the sample\n\\return error if any\n*/\nGF_EXPORT\nGF_Err gf_isom_change_sample_desc_index(GF_ISOFile *the_file, u32 trackNumber, u32 sample_number, u32 newSampleDescIndex)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !sample_number || !newSampleDescIndex) return GF_BAD_PARAM;\n\tif (!trak->is_unpacked) {\n\t\tunpack_track(trak);\n\t}\n\tif (!trak->Media->information->sampleTable->SampleToChunk) return GF_BAD_PARAM;\n\tif (trak->Media->information->sampleTable->SampleToChunk->nb_entries < sample_number) return GF_BAD_PARAM;\n\ttrak->Media->information->sampleTable->SampleToChunk->entries[sample_number-1].sampleDescriptionIndex = newSampleDescIndex;\n\treturn GF_OK;\n}\n\n/*modify CTS offset of a given sample (used for B-frames) - MUST be called in unpack mode only*/\nGF_EXPORT\nGF_Err gf_isom_modify_cts_offset(GF_ISOFile *the_file, u32 trackNumber, u32 sample_number, u32 offset)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->CompositionOffset) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->CompositionOffset->unpack_mode) return GF_BAD_PARAM;\n\t/*we're in unpack mode: one entry per sample*/\n\ttrak->Media->information->sampleTable->CompositionOffset->entries[sample_number - 1].decodingOffset = offset;\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_shift_cts_offset(GF_ISOFile *the_file, u32 trackNumber, s32 offset_shift)\n{\n\tu32 i;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->CompositionOffset) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->CompositionOffset->unpack_mode) return GF_BAD_PARAM;\n\n\tGF_CompositionOffsetBox *ctso = trak->Media->information->sampleTable->CompositionOffset;\n\tfor (i=0; i<ctso->nb_entries; i++) {\n\t\ts64 new_ts = ctso->entries[i].decodingOffset;\n\t\tnew_ts -= offset_shift;\n\t\t/*we're in unpack mode: one entry per sample*/\n\t\tctso->entries[i].decodingOffset = (s32) new_ts;\n\t}\n\tif (trak->Media->mediaHeader->duration >= -offset_shift) {\n\t\ts64 new_dur = trak->Media->mediaHeader->duration;\n\t\tnew_dur -= offset_shift;\n\t\tif (new_dur<0) new_dur = 0;\n\t\ttrak->Media->mediaHeader->duration = (u32) new_dur;\n\t}\n\treturn GF_OK;\n}\n\n#if 0 //unused\nGF_Err gf_isom_remove_cts_info(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_SampleTableBox *stbl;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl->CompositionOffset) return GF_OK;\n\n\tgf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *)stbl->CompositionOffset);\n\tstbl->CompositionOffset = NULL;\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_set_cts_packing(GF_ISOFile *the_file, u32 trackNumber, Bool unpack)\n{\n\tGF_Err e;\n\tGF_Err stbl_repackCTS(GF_CompositionOffsetBox *ctts);\n\tGF_Err stbl_unpackCTS(GF_SampleTableBox *stbl);\n\tGF_SampleTableBox *stbl;\n\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (unpack) {\n\t\tif (!stbl->CompositionOffset) {\n\t\t\tstbl->CompositionOffset = (GF_CompositionOffsetBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_CTTS);\n\t\t\tif (!stbl->CompositionOffset) return GF_OUT_OF_MEM;\n\t\t}\n\t\te = stbl_unpackCTS(stbl);\n\t} else {\n\t\tif (!stbl->CompositionOffset) return GF_OK;\n\t\te = stbl_repackCTS(stbl->CompositionOffset);\n\t}\n\tif (e) return e;\n\treturn SetTrackDuration(trak);\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_matrix(GF_ISOFile *the_file, u32 trackNumber, s32 matrix[9])\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Header) return GF_BAD_PARAM;\n\tmemcpy(trak->Header->matrix, matrix, sizeof(trak->Header->matrix));\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_layout_info(GF_ISOFile *the_file, u32 trackNumber, u32 width, u32 height, s32 translation_x, s32 translation_y, s16 layer)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Header) return GF_BAD_PARAM;\n\ttrak->Header->width = width;\n\ttrak->Header->height = height;\n\ttrak->Header->matrix[6] = translation_x;\n\ttrak->Header->matrix[7] = translation_y;\n\ttrak->Header->layer = layer;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_media_timescale(GF_ISOFile *the_file, u32 trackNumber, u32 newTS, u32 new_tsinc, u32 force_rescale_type)\n{\n\tDouble scale;\n\tu32 old_ts_inc=0;\n\tu32 old_timescale;\n\tGF_TrackBox *trak;\n\tGF_SampleTableBox *stbl;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->mediaHeader) return GF_BAD_PARAM;\n\tif ((trak->Media->mediaHeader->timeScale==newTS) && !new_tsinc)\n\t\treturn GF_EOS;\n\n\tif (!newTS) newTS = trak->Media->mediaHeader->timeScale;\n\tscale = newTS;\n\tscale /= trak->Media->mediaHeader->timeScale;\n\told_timescale = trak->Media->mediaHeader->timeScale;\n\ttrak->Media->mediaHeader->timeScale = newTS;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (new_tsinc) {\n\t\tu32 i;\n\t\tif (!stbl->TimeToSample || !stbl->TimeToSample->nb_entries)\n\t\t\treturn GF_BAD_PARAM;\n\n\t\tfor (i=0; i<stbl->TimeToSample->nb_entries; i++) {\n\t\t\tif (!old_ts_inc)\n\t\t\t\told_ts_inc = stbl->TimeToSample->entries[i].sampleDelta;\n\t\t\telse if (old_ts_inc<stbl->TimeToSample->entries[i].sampleDelta)\n\t\t\t\told_ts_inc = stbl->TimeToSample->entries[i].sampleDelta;\n\t\t}\n\n\t\tif ((old_timescale==newTS) && (old_ts_inc==new_tsinc) && (force_rescale_type!=2) )\n\t\t\treturn GF_EOS;\n\n\t\tif (!force_rescale_type)\n\t\t\tforce_rescale_type = 1;\n\t\telse if (force_rescale_type==2) {\n\t\t\tgf_free(stbl->TimeToSample->entries);\n\t\t\tstbl->TimeToSample->alloc_size = 1;\n\t\t\tstbl->TimeToSample->nb_entries = 1;\n\t\t\tstbl->TimeToSample->entries = gf_malloc(sizeof(GF_SttsEntry));\n\t\t\tstbl->TimeToSample->entries[0].sampleDelta = new_tsinc;\n\t\t\tstbl->TimeToSample->entries[0].sampleCount = stbl->SampleSize->sampleCount;\n\t\t}\n\n\n\t\tfor (i=0; i<stbl->TimeToSample->nb_entries; i++) {\n\t\t\tstbl->TimeToSample->entries[i].sampleDelta = new_tsinc;\n\t\t}\n\n\t\tif (stbl->CompositionOffset) {\n\t\t\tfor (i=0; i<stbl->CompositionOffset->nb_entries; i++) {\n\t\t\t\tu32 old_offset = stbl->CompositionOffset->entries[i].decodingOffset;\n\t\t\t\tif (force_rescale_type==2) {\n\t\t\t\t\tu32 val = old_offset ;\n\t\t\t\t\t//get number of TS delta\n\t\t\t\t\told_offset /= old_ts_inc;\n\t\t\t\t\tif (old_offset * old_ts_inc < val)\n\t\t\t\t\t\told_offset++;\n\t\t\t\t\told_offset *= new_tsinc;\n\t\t\t\t} else {\n\t\t\t\t\told_offset *= new_tsinc;\n\t\t\t\t\told_offset /= old_ts_inc;\n\t\t\t\t}\n\t\t\t\tstbl->CompositionOffset->entries[i].decodingOffset = old_offset;\n\t\t\t}\n\t\t}\n\n#define RESCALE_TSVAL(_tsval) {\\\n\t\t\ts64 val = ((s64) _tsval) * new_tsinc;\\\n\t\t\tval /= old_ts_inc;\\\n\t\t\t_tsval = (s32) val;\\\n\t\t}\n\n\t\tif (stbl->CompositionToDecode) {\n\t\t\tRESCALE_TSVAL(stbl->CompositionToDecode->compositionEndTime)\n\t\t\tRESCALE_TSVAL(stbl->CompositionToDecode->compositionStartTime)\n\t\t\tRESCALE_TSVAL(stbl->CompositionToDecode->compositionToDTSShift)\n\t\t\tRESCALE_TSVAL(stbl->CompositionToDecode->greatestDecodeToDisplayDelta)\n\t\t\tRESCALE_TSVAL(stbl->CompositionToDecode->leastDecodeToDisplayDelta)\n\t\t}\n\t\tif (trak->editBox) {\n\t\t\tGF_EdtsEntry *ent;\n\t\t\ti=0;\n\t\t\twhile ((ent = (GF_EdtsEntry*)gf_list_enum(trak->editBox->editList->entryList, &i))) {\n\t\t\t\tRESCALE_TSVAL(ent->mediaTime)\n\t\t\t}\n\t\t}\n#undef RESCALE_TSVAL\n\t\t//force recompute of duration\n\t\ttrak->Media->mediaHeader->duration=0;\n\t\treturn SetTrackDuration(trak);\n\t}\n\n\t//rescale timings\n\tu32 i, k, idx, last_delta;\n\tu64 cur_dts;\n\tu64*DTSs = NULL;\n\ts64*CTSs = NULL;\n\n\tif (trak->editBox) {\n\t\tGF_EdtsEntry *ent;\n\t\ti=0;\n\t\twhile ((ent = (GF_EdtsEntry*)gf_list_enum(trak->editBox->editList->entryList, &i))) {\n\t\t\t//only update if media time is >=0 (neg means empty edit)\n\t\t\tif (ent->mediaTime>=0)\n\t\t\t\tent->mediaTime = (u32) (scale*ent->mediaTime);\n\t\t}\n\t}\n\tif (! stbl || !stbl->TimeToSample || !stbl->TimeToSample->nb_entries) {\n\t\treturn SetTrackDuration(trak);\n\t}\n\n\tidx = 0;\n\tcur_dts = 0;\n\t//unpack the DTSs\n\tDTSs = (u64*)gf_malloc(sizeof(u64) * (stbl->SampleSize->sampleCount) );\n\tif (!DTSs) return GF_OUT_OF_MEM;\n\n\tCTSs = NULL;\n\tif (stbl->CompositionOffset) {\n\t\tCTSs = (s64*)gf_malloc(sizeof(u64) * (stbl->SampleSize->sampleCount) );\n\t\tif (!CTSs) return GF_OUT_OF_MEM;\n\t}\n\n\tfor (i=0; i<stbl->TimeToSample->nb_entries; i++) {\n\t\tfor (k=0; k<stbl->TimeToSample->entries[i].sampleCount; k++) {\n\t\t\tcur_dts += stbl->TimeToSample->entries[i].sampleDelta;\n\t\t\tDTSs[idx] = (u64) (cur_dts * scale);\n\n\t\t\tif (stbl->CompositionOffset) {\n\t\t\t\ts32 cts_o;\n\t\t\t\tstbl_GetSampleCTS(stbl->CompositionOffset, idx+1, &cts_o);\n\t\t\t\tCTSs[idx] = (s64) ( ((s64) cur_dts + cts_o) * scale);\n\t\t\t}\n\t\t\tidx++;\n\t\t}\n\t}\n\tlast_delta = (u32) (stbl->TimeToSample->entries[stbl->TimeToSample->nb_entries-1].sampleDelta * scale);\n\n\t//repack DTS\n\tif (stbl->SampleSize->sampleCount) {\n\t\tstbl->TimeToSample->entries = gf_realloc(stbl->TimeToSample->entries, sizeof(GF_SttsEntry)*stbl->SampleSize->sampleCount);\n\t\tmemset(stbl->TimeToSample->entries, 0, sizeof(GF_SttsEntry)*stbl->SampleSize->sampleCount);\n\t\tstbl->TimeToSample->entries[0].sampleDelta = (u32) DTSs[0];\n\t\tstbl->TimeToSample->entries[0].sampleCount = 1;\n\t\tidx=0;\n\t\tfor (i=1; i< stbl->SampleSize->sampleCount - 1; i++) {\n\t\t\tif (DTSs[i+1] - DTSs[i] == stbl->TimeToSample->entries[idx].sampleDelta) {\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleCount++;\n\t\t\t} else {\n\t\t\t\tidx++;\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleDelta = (u32) ( DTSs[i+1] - DTSs[i] );\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleCount=1;\n\t\t\t}\n\t\t}\n\t\tif (stbl->SampleSize->sampleCount > 1) {\n\t\t\t//add the sample delta for the last sample\n\t\t\tif (stbl->TimeToSample->entries[idx].sampleDelta == last_delta) {\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleCount++;\n\t\t\t} else {\n\t\t\t\tidx++;\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleDelta = last_delta;\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleCount=1;\n\t\t\t}\n\n\t\t\tstbl->TimeToSample->nb_entries = idx+1;\n\t\t\tstbl->TimeToSample->entries = gf_realloc(stbl->TimeToSample->entries, sizeof(GF_SttsEntry)*stbl->TimeToSample->nb_entries);\n\t\t}\n\t}\n\n\tif (CTSs && stbl->SampleSize->sampleCount>0) {\n\t\t//repack CTS\n\t\tstbl->CompositionOffset->entries = gf_realloc(stbl->CompositionOffset->entries, sizeof(GF_DttsEntry)*stbl->SampleSize->sampleCount);\n\t\tmemset(stbl->CompositionOffset->entries, 0, sizeof(GF_DttsEntry)*stbl->SampleSize->sampleCount);\n\t\tstbl->CompositionOffset->entries[0].decodingOffset = (s32) (CTSs[0] - DTSs[0]);\n\t\tstbl->CompositionOffset->entries[0].sampleCount = 1;\n\t\tidx=0;\n\t\tfor (i=1; i< stbl->SampleSize->sampleCount; i++) {\n\t\t\ts32 cts_o = (s32) (CTSs[i] - DTSs[i]);\n\t\t\tif (cts_o == stbl->CompositionOffset->entries[idx].decodingOffset) {\n\t\t\t\tstbl->CompositionOffset->entries[idx].sampleCount++;\n\t\t\t} else {\n\t\t\t\tidx++;\n\t\t\t\tstbl->CompositionOffset->entries[idx].decodingOffset = cts_o;\n\t\t\t\tstbl->CompositionOffset->entries[idx].sampleCount=1;\n\t\t\t}\n\t\t}\n\t\tstbl->CompositionOffset->nb_entries = idx+1;\n\t\tstbl->CompositionOffset->entries = gf_realloc(stbl->CompositionOffset->entries, sizeof(GF_DttsEntry)*stbl->CompositionOffset->nb_entries);\n\n\t\tgf_free(CTSs);\n\t}\n\tgf_free(DTSs);\n\n\tif (stbl->CompositionToDecode) {\n\t\tstbl->CompositionToDecode->compositionEndTime = (s32) (stbl->CompositionToDecode->compositionEndTime * scale);\n\t\tstbl->CompositionToDecode->compositionStartTime = (s32)(stbl->CompositionToDecode->compositionStartTime * scale);\n\t\tstbl->CompositionToDecode->compositionToDTSShift = (s32)(stbl->CompositionToDecode->compositionToDTSShift * scale);\n\t\tstbl->CompositionToDecode->greatestDecodeToDisplayDelta = (s32)(stbl->CompositionToDecode->greatestDecodeToDisplayDelta * scale);\n\t\tstbl->CompositionToDecode->leastDecodeToDisplayDelta = (s32)(stbl->CompositionToDecode->leastDecodeToDisplayDelta * scale);\n\t}\n\n\treturn SetTrackDuration(trak);\n}\n\nGF_EXPORT\nBool gf_isom_box_equal(GF_Box *a, GF_Box *b)\n{\n\tBool ret;\n\tu8 *data1, *data2;\n\tu32 data1_size, data2_size;\n\tGF_BitStream *bs;\n\n\tif (a == b) return GF_TRUE;\n\tif (!a || !b) return GF_FALSE;\n\n\tdata1 = data2 = NULL;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_box_size(a);\n\tgf_isom_box_write(a, bs);\n\tgf_bs_get_content(bs, &data1, &data1_size);\n\tgf_bs_del(bs);\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_box_size(b);\n\tgf_isom_box_write(b, bs);\n\tgf_bs_get_content(bs, &data2, &data2_size);\n\tgf_bs_del(bs);\n\n\tret = GF_FALSE;\n\tif (data1_size == data2_size) {\n\t\tret = (memcmp(data1, data2, sizeof(char)*data1_size) == 0) ? GF_TRUE : GF_FALSE;\n\t}\n\tgf_free(data1);\n\tgf_free(data2);\n\treturn ret;\n}\n\nstatic u32 base_sample_entry_type(u32 type)\n{\n\tif (type==GF_ISOM_SUBTYPE_DVH1) return GF_ISOM_SUBTYPE_HVC1;\n\tif (type==GF_ISOM_SUBTYPE_DVHE) return GF_ISOM_SUBTYPE_HEV1;\n\tif (type==GF_ISOM_SUBTYPE_DVA1) return GF_ISOM_SUBTYPE_AVC_H264;\n\tif (type==GF_ISOM_SUBTYPE_DVAV) return GF_ISOM_SUBTYPE_AVC3_H264;\n\tif (type==GF_ISOM_SUBTYPE_DAV1) return GF_ISOM_SUBTYPE_AV01;\n\treturn type;\n}\n\nGF_EXPORT\nBool gf_isom_is_same_sample_description(GF_ISOFile *f1, u32 tk1, u32 sdesc_index1, GF_ISOFile *f2, u32 tk2, u32 sdesc_index2)\n{\n\tu32 i, count;\n\tGF_TrackBox *trak1, *trak2;\n\tGF_ESD *esd1, *esd2;\n\tBool need_memcmp, ret;\n\tGF_Box *a, *b;\n\n\t/*get orig sample desc and clone it*/\n\ttrak1 = gf_isom_get_track_from_file(f1, tk1);\n\tif (!trak1 || !trak1->Media) return GF_FALSE;\n\ttrak2 = gf_isom_get_track_from_file(f2, tk2);\n\tif (!trak2 || !trak2->Media) return GF_FALSE;\n\n\tif (trak1->Media->handler->handlerType != trak2->Media->handler->handlerType) return GF_FALSE;\n\tcount = gf_list_count(trak1->Media->information->sampleTable->SampleDescription->child_boxes);\n\tif (count != gf_list_count(trak2->Media->information->sampleTable->SampleDescription->child_boxes)) {\n\t\tif (!sdesc_index1 && !sdesc_index2) return GF_FALSE;\n\t}\n\n\tneed_memcmp = GF_TRUE;\n\tfor (i=0; i<count; i++) {\n\t\tu32 type1, type2;\n\t\tGF_SampleEntryBox *ent1 = (GF_SampleEntryBox *)gf_list_get(trak1->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\tGF_SampleEntryBox *ent2 = (GF_SampleEntryBox *)gf_list_get(trak2->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\n\t\tif (sdesc_index1) ent1 = (GF_SampleEntryBox *)gf_list_get(trak1->Media->information->sampleTable->SampleDescription->child_boxes, sdesc_index1 - 1);\n\t\tif (sdesc_index2) ent2 = (GF_SampleEntryBox *)gf_list_get(trak2->Media->information->sampleTable->SampleDescription->child_boxes, sdesc_index2 - 1);\n\n\t\tif (!ent1 || !ent2) return GF_FALSE;\n\t\tif (ent1->internal_type != ent2->internal_type) return GF_FALSE;\n\t\ttype1 = base_sample_entry_type(ent1->type);\n\t\ttype2 = base_sample_entry_type(ent2->type);\n\t\tif (type1 != type2) return GF_FALSE;\n\n\t\tswitch (ent1->type) {\n\t\t/*for MPEG-4 streams, only compare decSpecInfo (bitrate may not be the same but that's not an issue)*/\n\t\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tcase GF_ISOM_BOX_TYPE_ENCA:\n\t\tcase GF_ISOM_BOX_TYPE_ENCV:\n\t\tcase GF_ISOM_BOX_TYPE_RESV:\n\t\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\t\tMedia_GetESD(trak1->Media, sdesc_index1 ? sdesc_index1 : i+1, &esd1, GF_TRUE);\n\t\t\tMedia_GetESD(trak2->Media, sdesc_index2 ? sdesc_index2 : i+1, &esd2, GF_TRUE);\n\t\t\tif (!esd1 || !esd2) continue;\n\t\t\tneed_memcmp = GF_FALSE;\n\t\t\tif (esd1->decoderConfig->streamType != esd2->decoderConfig->streamType) return GF_FALSE;\n\t\t\tif (esd1->decoderConfig->objectTypeIndication != esd2->decoderConfig->objectTypeIndication) return GF_FALSE;\n\t\t\tif (!esd1->decoderConfig->decoderSpecificInfo && esd2->decoderConfig->decoderSpecificInfo) return GF_FALSE;\n\t\t\tif (esd1->decoderConfig->decoderSpecificInfo && !esd2->decoderConfig->decoderSpecificInfo) return GF_FALSE;\n\t\t\tif (!esd1->decoderConfig->decoderSpecificInfo || !esd2->decoderConfig->decoderSpecificInfo) continue;\n\t\t\tif (esd1->decoderConfig->decoderSpecificInfo->dataLength != esd2->decoderConfig->decoderSpecificInfo->dataLength)\n\t\t\t\treturn GF_FALSE;\n\t\t\tif (memcmp(esd1->decoderConfig->decoderSpecificInfo->data, esd2->decoderConfig->decoderSpecificInfo->data, sizeof(char)*esd1->decoderConfig->decoderSpecificInfo->dataLength)!=0) return GF_FALSE;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\t\treturn GF_TRUE;\n\t\tcase GF_ISOM_BOX_TYPE_AVC1:\n\t\tcase GF_ISOM_BOX_TYPE_AVC2:\n\t\tcase GF_ISOM_BOX_TYPE_AVC3:\n\t\tcase GF_ISOM_BOX_TYPE_AVC4:\n\t\tcase GF_ISOM_BOX_TYPE_SVC1:\n\t\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HEV1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC2:\n\t\tcase GF_ISOM_BOX_TYPE_HEV2:\n\t\tcase GF_ISOM_BOX_TYPE_LHE1:\n\t\tcase GF_ISOM_BOX_TYPE_LHV1:\n\t\tcase GF_ISOM_BOX_TYPE_AV01:\n\t\tcase GF_ISOM_BOX_TYPE_VVC1:\n\t\tcase GF_ISOM_BOX_TYPE_VVI1:\n\t\tcase GF_ISOM_BOX_TYPE_DVHE:\n\t\tcase GF_ISOM_BOX_TYPE_DVH1:\n\t\tcase GF_ISOM_BOX_TYPE_DVA1:\n\t\tcase GF_ISOM_BOX_TYPE_DVAV:\n\t\tcase GF_ISOM_BOX_TYPE_DAV1:\n\t\t{\n\t\t\tGF_MPEGVisualSampleEntryBox *avc1 = (GF_MPEGVisualSampleEntryBox *)ent1;\n\t\t\tGF_MPEGVisualSampleEntryBox *avc2 = (GF_MPEGVisualSampleEntryBox *)ent2;\n\n\t\t\tif (avc1->hevc_config)\n\t\t\t\ta = (GF_Box *) avc1->hevc_config;\n\t\t\telse if (avc1->lhvc_config)\n\t\t\t\ta = (GF_Box *) avc1->lhvc_config;\n\t\t\telse if (avc1->svc_config)\n\t\t\t\ta = (GF_Box *) avc1->svc_config;\n\t\t\telse if (avc1->mvc_config)\n\t\t\t\ta = (GF_Box *) avc1->mvc_config;\n\t\t\telse if (avc1->av1_config)\n\t\t\t\ta = (GF_Box *)avc1->av1_config;\n\t\t\telse\n\t\t\t\ta = (GF_Box *) avc1->avc_config;\n\n\t\t\tif (avc2->hevc_config)\n\t\t\t\tb = (GF_Box *) avc2->hevc_config;\n\t\t\telse if (avc2->lhvc_config)\n\t\t\t\tb = (GF_Box *) avc2->lhvc_config;\n\t\t\telse if (avc2->svc_config)\n\t\t\t\tb = (GF_Box *) avc2->svc_config;\n\t\t\telse if (avc2->mvc_config)\n\t\t\t\tb = (GF_Box *) avc2->mvc_config;\n\t\t\telse if (avc2->av1_config)\n\t\t\t\tb = (GF_Box *)avc2->av1_config;\n\t\t\telse\n\t\t\t\tb = (GF_Box *) avc2->avc_config;\n\n\t\t\treturn gf_isom_box_equal(a,b);\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_LSR1:\n\t\t{\n\t\t\tGF_LASeRSampleEntryBox *lsr1 = (GF_LASeRSampleEntryBox *)ent1;\n\t\t\tGF_LASeRSampleEntryBox *lsr2 = (GF_LASeRSampleEntryBox *)ent2;\n\t\t\tif (lsr1->lsr_config && lsr2->lsr_config\n\t\t\t        && lsr1->lsr_config->hdr && lsr2->lsr_config->hdr\n\t\t\t        && (lsr1->lsr_config->hdr_size==lsr2->lsr_config->hdr_size)\n\t\t\t        && !memcmp(lsr1->lsr_config->hdr, lsr2->lsr_config->hdr, lsr2->lsr_config->hdr_size)\n\t\t\t   ) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tbreak;\n#ifndef GPAC_DISABLE_VTT\n\t\tcase GF_ISOM_BOX_TYPE_WVTT:\n\t\t{\n\t\t\tGF_WebVTTSampleEntryBox *wvtt1 = (GF_WebVTTSampleEntryBox *)ent1;\n\t\t\tGF_WebVTTSampleEntryBox *wvtt2 = (GF_WebVTTSampleEntryBox *)ent2;\n\t\t\tif (wvtt1->config && wvtt2->config &&\n\t\t\t        (wvtt1->config->string && wvtt2->config->string && !strcmp(wvtt1->config->string, wvtt2->config->string))) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tbreak;\n#endif\n\t\tcase GF_ISOM_BOX_TYPE_STPP:\n\t\t{\n\t\t\tGF_MetaDataSampleEntryBox *stpp1 = (GF_MetaDataSampleEntryBox *)ent1;\n\t\t\tGF_MetaDataSampleEntryBox *stpp2 = (GF_MetaDataSampleEntryBox *)ent2;\n\t\t\tif (stpp1->xml_namespace && stpp2->xml_namespace && !strcmp(stpp1->xml_namespace, stpp2->xml_namespace)) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_SBTT:\n\t\t{\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_STXT:\n\t\t{\n\t\t\tGF_MetaDataSampleEntryBox *stxt1 = (GF_MetaDataSampleEntryBox *)ent1;\n\t\t\tGF_MetaDataSampleEntryBox *stxt2 = (GF_MetaDataSampleEntryBox *)ent2;\n\t\t\tif (stxt1->mime_type && stxt2->mime_type &&\n\t\t\t        ( (!stxt1->config && !stxt2->config) ||\n\t\t\t          (stxt1->config && stxt2->config && stxt1->config->config && stxt2->config->config &&\n\t\t\t           !strcmp(stxt1->config->config, stxt2->config->config)))) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tcase GF_ISOM_BOX_TYPE_MP3:\n\t\tcase GF_QT_SUBTYPE_RAW_AUD:\n\t\tcase GF_QT_SUBTYPE_TWOS:\n\t\tcase GF_QT_SUBTYPE_SOWT:\n\t\tcase GF_QT_SUBTYPE_FL32:\n\t\tcase GF_QT_SUBTYPE_FL64:\n\t\tcase GF_QT_SUBTYPE_IN24:\n\t\tcase GF_QT_SUBTYPE_IN32:\n\t\tcase GF_QT_SUBTYPE_ULAW:\n\t\tcase GF_QT_SUBTYPE_ALAW:\n\t\tcase GF_QT_SUBTYPE_ADPCM:\n\t\tcase GF_QT_SUBTYPE_IMA_ADPCM:\n\t\tcase GF_QT_SUBTYPE_DVCA:\n\t\tcase GF_QT_SUBTYPE_QDMC:\n\t\tcase GF_QT_SUBTYPE_QDMC2:\n\t\tcase GF_QT_SUBTYPE_QCELP:\n\t\tcase GF_QT_SUBTYPE_kMP3:\n\t\tcase GF_QT_SUBTYPE_APCH:\n\t\tcase GF_QT_SUBTYPE_APCO:\n\t\tcase GF_QT_SUBTYPE_APCN:\n\t\tcase GF_QT_SUBTYPE_APCS:\n\t\tcase GF_QT_SUBTYPE_AP4X:\n\t\tcase GF_QT_SUBTYPE_AP4H:\n\t\tcase GF_QT_SUBTYPE_RAW_VID:\n\t\tcase GF_QT_SUBTYPE_YUYV:\n\t\tcase GF_QT_SUBTYPE_UYVY:\n\t\tcase GF_QT_SUBTYPE_YUV444:\n\t\tcase GF_QT_SUBTYPE_YUVA444:\n\t\tcase GF_QT_SUBTYPE_YUV422_10:\n\t\tcase GF_QT_SUBTYPE_YUV444_10:\n\t\tcase GF_QT_SUBTYPE_YUV422_16:\n\t\tcase GF_QT_SUBTYPE_YUV420:\n\t\tcase GF_QT_SUBTYPE_I420:\n\t\tcase GF_QT_SUBTYPE_IYUV:\n\t\tcase GF_QT_SUBTYPE_YV12:\n\t\tcase GF_QT_SUBTYPE_YVYU:\n\t\tcase GF_QT_SUBTYPE_RGBA:\n\t\tcase GF_QT_SUBTYPE_ABGR:\n\t\tdefault:\n\t\t\tif (ent1->internal_type == GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t\t\tGF_VisualSampleEntryBox *vent1 = (GF_VisualSampleEntryBox *) ent1;\n\t\t\t\tGF_VisualSampleEntryBox *vent2 = (GF_VisualSampleEntryBox *) ent2;\n\t\t\t\tif (vent1->Width != vent2->Width) return GF_FALSE;\n\t\t\t\tif (vent1->Height != vent2->Height) return GF_FALSE;\n\t\t\t}\n\t\t\telse if (ent1->internal_type == GF_ISOM_SAMPLE_ENTRY_AUDIO) {\n\t\t\t\tGF_AudioSampleEntryBox *aent1 = (GF_AudioSampleEntryBox *) ent1;\n\t\t\t\tGF_AudioSampleEntryBox *aent2 = (GF_AudioSampleEntryBox *) ent2;\n\t\t\t\tif (aent1->samplerate_hi != aent2->samplerate_hi) return GF_FALSE;\n\t\t\t\tif (aent1->samplerate_lo != aent2->samplerate_lo) return GF_FALSE;\n\t\t\t\tif (aent1->channel_count != aent2->channel_count) return GF_FALSE;\n\t\t\t}\n\t\t\treturn GF_TRUE;\n\t\t}\n\n\t\tif (sdesc_index1 && sdesc_index2) break;\n\t}\n\tif (!need_memcmp) return GF_TRUE;\n\ta = (GF_Box *)trak1->Media->information->sampleTable->SampleDescription;\n\tb = (GF_Box *)trak2->Media->information->sampleTable->SampleDescription;\n\t//we ignore all bitrate boxes when comparing the box, disable their writing\n\tgf_isom_registry_disable(GF_ISOM_BOX_TYPE_BTRT, GF_TRUE);\n\tret = gf_isom_box_equal(a,b);\n\t//re-enable btrt writing\n\tgf_isom_registry_disable(GF_ISOM_BOX_TYPE_BTRT, GF_FALSE);\n\n\treturn ret;\n}\n\nGF_EXPORT\nu64 gf_isom_estimate_size(GF_ISOFile *movie)\n{\n\tGF_Err e;\n\tGF_Box *a;\n\tu32 i, count;\n\tu64 mdat_size;\n\tif (!movie || !movie->moov) return 0;\n\n\tmdat_size = 0;\n\tcount = gf_list_count(movie->moov->trackList);\n\tfor (i=0; i<count; i++) {\n\t\tmdat_size += gf_isom_get_media_data_size(movie, i+1);\n\t}\n\tif (mdat_size) {\n\t\tmdat_size += 8;\n\t\tif (mdat_size > 0xFFFFFFFF) mdat_size += 8;\n\t}\n\n\ti=0;\n\twhile ((a = (GF_Box*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\te = gf_isom_box_size(a);\n\t\tif (e == GF_OK)\n\t\t\tmdat_size += a->size;\n\t}\n\treturn mdat_size;\n}\n\n\n//set shadowing on/off\n#if 0 //unused\nGF_Err gf_isom_remove_sync_shadows(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleTableBox *stbl;\n\n\tif (movie->openMode == GF_ISOM_OPEN_READ) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (stbl->ShadowSync) {\n\t\tgf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *) stbl->ShadowSync);\n\t\tstbl->ShadowSync = NULL;\n\t}\n\treturn GF_OK;\n}\n\n/*Use this function to do the shadowing if you use shadowing.\nthe sample to be shadowed MUST be a non-sync sample (ignored if not)\nthe sample shadowing must be a Sync sample (error if not)*/\nGF_Err gf_isom_set_sync_shadow(GF_ISOFile *movie, u32 trackNumber, u32 sampleNumber, u32 syncSample)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleTableBox *stbl;\n\tGF_ISOSAPType isRAP;\n\tGF_Err e;\n\n\tif (movie->openMode == GF_ISOM_OPEN_READ) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !sampleNumber || !syncSample) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl->ShadowSync) {\n\t\tstbl->ShadowSync = (GF_ShadowSyncBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSH);\n\t\tif (!stbl->ShadowSync) return GF_OUT_OF_MEM;\n\t}\n\n\t//if no sync, skip\n\tif (!stbl->SyncSample) return GF_OK;\n\t//else set the sync shadow.\n\t//if the sample is sync, ignore\n\te = stbl_GetSampleRAP(stbl->SyncSample, sampleNumber, &isRAP, NULL, NULL);\n\tif (e) return e;\n\tif (isRAP) return GF_OK;\n\t//if the shadowing sample is not sync, error\n\te = stbl_GetSampleRAP(stbl->SyncSample, syncSample, &isRAP, NULL, NULL);\n\tif (e) return e;\n\tif (!isRAP) return GF_BAD_PARAM;\n\n\treturn stbl_SetSyncShadow(stbl->ShadowSync, sampleNumber, syncSample);\n}\n#endif\n\n//set the GroupID of a track (only used for interleaving)\nGF_EXPORT\nGF_Err gf_isom_set_track_interleaving_group(GF_ISOFile *movie, u32 trackNumber, u32 GroupID)\n{\n\tGF_TrackBox *trak;\n\n\tif (movie->openMode != GF_ISOM_OPEN_EDIT) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !GroupID) return GF_BAD_PARAM;\n\n\ttrak->Media->information->sampleTable->groupID = GroupID;\n\treturn GF_OK;\n}\n\n\n//set the Priority of a track within a Group (only used for tight interleaving)\n//Priority ranges from 1 to 9\nGF_EXPORT\nGF_Err gf_isom_set_track_priority_in_group(GF_ISOFile *movie, u32 trackNumber, u32 Priority)\n{\n\tGF_TrackBox *trak;\n\n\tif (movie->openMode != GF_ISOM_OPEN_EDIT) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !Priority) return GF_BAD_PARAM;\n\n\ttrak->Media->information->sampleTable->trackPriority = Priority > 255 ? 255 : Priority;\n\treturn GF_OK;\n}\n\n//set the max SamplesPerChunk (for file optimization)\nGF_EXPORT\nGF_Err gf_isom_hint_max_chunk_size(GF_ISOFile *movie, u32 trackNumber, u32 maxChunkSize)\n{\n\tGF_TrackBox *trak;\n\n\tif (movie->openMode == GF_ISOM_OPEN_READ) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !maxChunkSize) return GF_BAD_PARAM;\n\n\ttrak->Media->information->sampleTable->MaxChunkSize = maxChunkSize;\n\treturn GF_OK;\n}\n\n\n//set the max SamplesPerChunk (for file optimization)\nGF_EXPORT\nGF_Err gf_isom_hint_max_chunk_duration(GF_ISOFile *movie, u32 trackNumber, u32 maxChunkDur)\n{\n\tGF_TrackBox *trak;\n\n\tif (movie->openMode == GF_ISOM_OPEN_READ) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\ttrak->Media->information->sampleTable->MaxChunkDur = maxChunkDur;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_extraction_slc(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, const GF_SLConfig *slConfig)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_Err e;\n\tGF_SLConfig **slc;\n\tGF_ESDBox *esds;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex, &entry, NULL);\n\tif (e) return e;\n\n\t//we must be sure we are not using a remote ESD\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tesds = ((GF_MPEGSampleEntryBox *)entry)->esd;\n\t\tif (!esds || !esds->desc || !esds->desc->slConfig || (esds->desc->slConfig->predefined != SLPredef_MP4))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tslc = & ((GF_MPEGSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tesds = ((GF_MPEGAudioSampleEntryBox *)entry)->esd;\n\t\tif (!esds || !esds->desc || !esds->desc->slConfig || (esds->desc->slConfig->predefined != SLPredef_MP4))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tslc = & ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tesds = ((GF_MPEGVisualSampleEntryBox *)entry)->esd;\n\t\tif (!esds || !esds->desc || !esds->desc->slConfig || (esds->desc->slConfig->predefined != SLPredef_MP4))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tslc = & ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_OK;\n\t}\n\n\tif (*slc) {\n\t\tgf_odf_desc_del((GF_Descriptor *)*slc);\n\t\t*slc = NULL;\n\t}\n\tif (!slConfig) return GF_OK;\n\t//finally duplicate the SL\n\treturn gf_odf_desc_copy((GF_Descriptor *) slConfig, (GF_Descriptor **) slc);\n}\n\n#if 0 //unused\nGF_Err gf_isom_get_extraction_slc(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, GF_SLConfig **slConfig)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_Err e;\n\tGF_SLConfig *slc;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex, &entry, NULL);\n\tif (e) return e;\n\n\t//we must be sure we are not using a remote ESD\n\tslc = NULL;\n\t*slConfig = NULL;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tif (((GF_MPEGSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = ((GF_MPEGSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tif (((GF_MPEGAudioSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tif (((GF_MPEGVisualSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (!slc) return GF_OK;\n\t//finally duplicate the SL\n\treturn gf_odf_desc_copy((GF_Descriptor *) slc, (GF_Descriptor **) slConfig);\n}\n\nu32 gf_isom_get_track_group(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->Media->information->sampleTable->groupID;\n}\n\nu32 gf_isom_get_track_priority_in_group(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->Media->information->sampleTable->trackPriority;\n}\n#endif\n\n\nGF_EXPORT\nGF_Err gf_isom_make_interleave_ex(GF_ISOFile *file, GF_Fraction *fTimeInSec)\n{\n\tGF_Err e;\n\tu64 itime;\n\tif (!file || !fTimeInSec->den || (fTimeInSec->num<=0)) return GF_BAD_PARAM;\n\n\titime = (u64) fTimeInSec->num;\n\titime *= gf_isom_get_timescale(file);\n\titime /= fTimeInSec->den;\n\tif (file->storageMode==GF_ISOM_STORE_FASTSTART) {\n\t\treturn gf_isom_set_interleave_time(file, (u32) itime);\n\t}\n\tif (gf_isom_get_mode(file) < GF_ISOM_OPEN_EDIT) return GF_BAD_PARAM;\n\te = gf_isom_set_storage_mode(file, GF_ISOM_STORE_DRIFT_INTERLEAVED);\n\tif (e) return e;\n\treturn gf_isom_set_interleave_time(file, (u32) itime);\n}\n\nGF_EXPORT\nGF_Err gf_isom_make_interleave(GF_ISOFile *file, Double TimeInSec)\n{\n\tGF_Fraction f;\n\tf.num = (s32) (TimeInSec * 1000);\n\tf.den = 1000;\n\treturn gf_isom_make_interleave_ex(file, &f);\n\n}\nGF_EXPORT\nGF_Err gf_isom_set_handler_name(GF_ISOFile *the_file, u32 trackNumber, const char *nameUTF8)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (trak->Media->handler->nameUTF8) gf_free(trak->Media->handler->nameUTF8);\n\ttrak->Media->handler->nameUTF8 = NULL;\n\n\tif (!nameUTF8) return GF_OK;\n\n\tif (!strnicmp(nameUTF8, \"file://\", 7)) {\n\t\tu8 BOM[4];\n\t\tFILE *f = gf_fopen(nameUTF8+7, \"rb\");\n\t\tu64 size;\n\t\tif (!f) return GF_URL_ERROR;\n\t\tsize = gf_fsize(f);\n\t\tif (3!=gf_fread(BOM, 3, f)) {\n\t\t\tgf_fclose(f);\n\t\t\treturn GF_CORRUPTED_DATA;\n\t\t}\n\t\t/*skip BOM if any*/\n\t\tif ((BOM[0]==0xEF) && (BOM[1]==0xBB) && (BOM[2]==0xBF)) size -= 3;\n\t\telse if ((BOM[0]==0xEF) || (BOM[0]==0xFF)) {\n\t\t\tgf_fclose(f);\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\telse gf_fseek(f, 0, SEEK_SET);\n\t\ttrak->Media->handler->nameUTF8 = (char*)gf_malloc(sizeof(char)*(size_t)(size+1));\n\t\tif (!trak->Media->handler->nameUTF8) {\n\t\t\tgf_fclose(f);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tsize = gf_fread(trak->Media->handler->nameUTF8, (size_t)size, f);\n\t\ttrak->Media->handler->nameUTF8[size] = 0;\n\t\tgf_fclose(f);\n\t} else {\n\t\tu32 i, j, len;\n\t\tchar szOrig[1024], szLine[1024];\n\t\tstrcpy(szOrig, nameUTF8);\n\t\tj=0;\n\t\tlen = (u32) strlen(szOrig);\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif (szOrig[i] & 0x80) {\n\t\t\t\t/*non UTF8 (likely some win-CP)*/\n\t\t\t\tif ( (szOrig[i+1] & 0xc0) != 0x80) {\n\t\t\t\t\tszLine[j] = 0xc0 | ( (szOrig[i] >> 6) & 0x3 );\n\t\t\t\t\tj++;\n\t\t\t\t\tszOrig[i] &= 0xbf;\n\t\t\t\t}\n\t\t\t\t/*UTF8 2 bytes char */\n\t\t\t\telse if ( (szOrig[i] & 0xe0) == 0xc0) {\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 3 bytes char */\n\t\t\t\telse if ( (szOrig[i] & 0xf0) == 0xe0) {\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 4 bytes char */\n\t\t\t\telse if ( (szOrig[i] & 0xf8) == 0xf0) {\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tszLine[j] = szOrig[i];\n\t\t\tj++;\n\t\t}\n\t\tszLine[j] = 0;\n\t\ttrak->Media->handler->nameUTF8 = gf_strdup(szLine);\n\t}\n\treturn GF_OK;\n}\n\n#if 0 //unused\n/*clones root OD from input to output file, without copying root OD track references*/\nGF_Err gf_isom_clone_root_od(GF_ISOFile *input, GF_ISOFile *output)\n{\n\tGF_List *esds;\n\tGF_Err e;\n\tu32 i;\n\tGF_Descriptor *desc;\n\n\te = gf_isom_remove_root_od(output);\n\tif (e) return e;\n\tif (!input->moov || !input->moov->iods || !input->moov->iods->descriptor) return GF_OK;\n\te = gf_isom_insert_moov(output);\n\tif (e) return e;\n\te = AddMovieIOD(output->moov, 0);\n\tif (e) return e;\n\tif (output->moov->iods->descriptor) gf_odf_desc_del(output->moov->iods->descriptor);\n\toutput->moov->iods->descriptor = NULL;\n\tgf_odf_desc_copy(input->moov->iods->descriptor, &output->moov->iods->descriptor);\n\n\tswitch (output->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tesds = ((GF_IsomInitialObjectDescriptor *)output->moov->iods->descriptor)->ES_ID_IncDescriptors;\n\t\tbreak;\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tesds = ((GF_IsomObjectDescriptor *)output->moov->iods->descriptor)->ES_ID_IncDescriptors;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//get the desc\n\ti=0;\n\twhile ((desc = (GF_Descriptor*)gf_list_enum(esds, &i))) {\n\t\tgf_odf_desc_del(desc);\n\t\tgf_list_rem(esds, i-1);\n\t}\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_set_media_type(GF_ISOFile *movie, u32 trackNumber, u32 new_type)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !new_type) return GF_BAD_PARAM;\n\ttrak->Media->handler->handlerType = new_type;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_media_subtype(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescriptionIndex, u32 new_type)\n{\n\tGF_SampleEntryBox*entry;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !sampleDescriptionIndex || !new_type) return GF_BAD_PARAM;\n\n\tentry = (GF_SampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex - 1);\n\tif (!entry) return GF_BAD_PARAM;\n\tif (entry->type==GF_ISOM_BOX_TYPE_GNRV) {\n\t\t((GF_GenericVisualSampleEntryBox *)entry)->EntryType = new_type;\n\t} else if (entry->type==GF_ISOM_BOX_TYPE_GNRA) {\n\t\t((GF_GenericAudioSampleEntryBox *)entry)->EntryType = new_type;\n\t} else if (entry->type==GF_ISOM_BOX_TYPE_GNRM) {\n\t\t((GF_GenericSampleEntryBox *)entry)->EntryType = new_type;\n\t} else {\n\t\tentry->type = new_type;\n\t}\n\treturn GF_OK;\n}\n\n\n#if 0 //unused\nGF_Err gf_isom_set_JPEG2000(GF_ISOFile *mov, Bool set_on)\n{\n\tif (!mov) return GF_BAD_PARAM;\n\tmov->is_jp2 = set_on;\n\treturn GF_OK;\n}\n#endif\n\nGF_Err gf_isom_remove_uuid(GF_ISOFile *movie, u32 trackNumber, bin128 UUID)\n{\n\tu32 i, count;\n\tGF_List *list;\n\n\tif (trackNumber==(u32) -1) {\n\t\tif (!movie) return GF_BAD_PARAM;\n\t\tlist = movie->TopBoxes;\n\t} else if (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tlist = trak->child_boxes;\n\t} else {\n\t\tif (!movie) return GF_BAD_PARAM;\n\t\tlist = movie->moov->child_boxes;\n\t}\n\n\tcount = list ? gf_list_count(list) : 0;\n\tfor (i=0; i<count; i++) {\n\t\tGF_UnknownUUIDBox *uuid = (GF_UnknownUUIDBox *)gf_list_get(list, i);\n\t\tif (uuid->type != GF_ISOM_BOX_TYPE_UUID) continue;\n\t\tif (memcmp(UUID, uuid->uuid, sizeof(bin128))) continue;\n\t\tgf_list_rem(list, i);\n\t\ti--;\n\t\tcount--;\n\t\tgf_isom_box_del((GF_Box*)uuid);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_uuid(GF_ISOFile *movie, u32 trackNumber, bin128 UUID, const u8 *data, u32 data_size)\n{\n\tGF_List *list;\n    u32 btype;\n\tGF_Box *box;\n\tGF_UnknownUUIDBox *uuidb;\n\n\tif (data_size && !data) return GF_BAD_PARAM;\n\tif (trackNumber==(u32) -1) {\n\t\tif (!movie) return GF_BAD_PARAM;\n\t\tlist = movie->TopBoxes;\n\t} else if (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->child_boxes) trak->child_boxes = gf_list_new();\n\t\tlist = trak->child_boxes;\n\t} else {\n\t\tif (!movie) return GF_BAD_PARAM;\n\t\tif (!movie->moov->child_boxes) movie->moov->child_boxes = gf_list_new();\n\t\tlist = movie->moov->child_boxes;\n\t}\n    btype = gf_isom_solve_uuid_box((char *) UUID);\n    if (!btype) btype = GF_ISOM_BOX_TYPE_UUID;\n    box = gf_isom_box_new(btype);\n    if (!box) return GF_OUT_OF_MEM;\n\tuuidb = (GF_UnknownUUIDBox*)box;\n\tuuidb->internal_4cc = gf_isom_solve_uuid_box((char *) UUID);\n\tmemcpy(uuidb->uuid, UUID, sizeof(bin128));\n\tuuidb->dataSize = data_size;\n\tif (data_size) {\n\t\tuuidb->data = (char*)gf_malloc(sizeof(char)*data_size);\n\t\tif (!uuidb->data) return GF_OUT_OF_MEM;\n\t\tmemcpy(uuidb->data, data, sizeof(char)*data_size);\n\t}\n\tgf_list_add(list, uuidb);\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_apple_set_tag(GF_ISOFile *mov, GF_ISOiTunesTag tag, const u8 *data, u32 data_len, u64 int_val, u32 int_val2)\n{\n\tGF_Err e;\n\tGF_ItemListBox *ilst;\n\tGF_MetaBox *meta;\n\tGF_ListItemBox *info;\n\tu32 btype, i, itype;\n\ts32 tag_idx;\n\tu32 n=0, d=0;\n\tu8 loc_data[10];\n\tu32 int_flags = 0x15;\n\tGF_DataBox *dbox;\n\n\te = CanAccessMovie(mov, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttag_idx = gf_itags_find_by_itag(tag);\n\tif (tag_idx<0) {\n\t\titype = GF_ITAG_STR;\n\t} else {\n\t\titype = gf_itags_get_type(tag_idx);\n\t}\n\tmeta = (GF_MetaBox *) gf_isom_create_meta_extensions(mov, GF_FALSE);\n\tif (!meta) return GF_BAD_PARAM;\n\n\tilst = gf_isom_locate_box(meta->child_boxes, GF_ISOM_BOX_TYPE_ILST, NULL);\n\tif (!ilst) {\n\t\tilst = (GF_ItemListBox *) gf_isom_box_new_parent(&meta->child_boxes, GF_ISOM_BOX_TYPE_ILST);\n\t}\n\n\tif (tag==GF_ISOM_ITUNE_RESET) {\n\t\tgf_isom_box_del_parent(&meta->child_boxes, (GF_Box *) ilst);\n\t\t//if last, delete udta - we may still have a handler box remaining\n\t\tif ((gf_list_count(meta->child_boxes) <= 1) && (gf_list_count(mov->moov->udta->recordList)==1)) {\n\t\t\tgf_isom_box_del_parent(&mov->moov->child_boxes, (GF_Box *) mov->moov->udta);\n\t\t\tmov->moov->udta = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tif (tag==GF_ISOM_ITUNE_GENRE) {\n\t\tif (!int_val && data) {\n\t\t\tint_val = gf_id3_get_genre_tag(data);\n\t\t\tif (int_val) {\n\t\t\t\tdata = NULL;\n\t\t\t\tdata_len = 0;\n\t\t\t\titype = GF_ITAG_INT16;\n\t\t\t\tint_flags = 0;\n\t\t\t}\n\t\t}\n\t\tbtype = data ? GF_ISOM_ITUNE_GENRE_USER : GF_ISOM_ITUNE_GENRE;\n\t} else {\n\t\tbtype = tag;\n\t}\n\t/*remove tag*/\n\ti = 0;\n\twhile ((info = (GF_ListItemBox*)gf_list_enum(ilst->child_boxes, &i))) {\n\t\tif (info->type==btype) {\n\t\t\tgf_isom_box_del_parent(&ilst->child_boxes, (GF_Box *) info);\n\t\t\tinfo = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (info->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\tGF_UnknownBox *u = (GF_UnknownBox *) info;\n\t\t\tif (u->original_4cc==btype) {\n\t\t\t\tgf_isom_box_del_parent(&ilst->child_boxes, (GF_Box *) info);\n\t\t\t\tinfo = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!data && data_len) {\n\t\tif (!gf_list_count(ilst->child_boxes) )\n\t\t\tgf_isom_box_del_parent(&meta->child_boxes, (GF_Box *) ilst);\n\t\treturn GF_OK;\n\t}\n\n\t//watch out for cprt, we don't want to create a regular cprt box\n\tif (btype==GF_ISOM_ITUNE_COPYRIGHT) {\n\t\tinfo = (GF_ListItemBox *)gf_isom_box_new(GF_ISOM_ITUNE_TOOL);\n\t\tinfo->type = GF_ISOM_ITUNE_COPYRIGHT;\n\t} else {\n\t\tinfo = (GF_ListItemBox *)gf_isom_box_new(btype);\n\t}\n\tif (info == NULL) return GF_OUT_OF_MEM;\n\n\tdbox = (GF_DataBox *)gf_isom_box_new_parent(&info->child_boxes, GF_ISOM_BOX_TYPE_DATA);\n\tif (!dbox) {\n\t\tgf_isom_box_del((GF_Box *)info);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tif (info->type!=GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\tinfo->data = dbox;\n\t}\n\n\tswitch (itype) {\n\tcase GF_ITAG_FRAC6:\n\tcase GF_ITAG_FRAC8:\n\t\tif (data && data_len) {\n\t\t\tif (sscanf(data, \"%u/%u\", &n, &d) != 2) {\n\t\t\t\tn = d = 0;\n\t\t\t\tif (sscanf(data, \"%u\", &n) != 1)\n\t\t\t\t\tn = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tn = (u32) int_val;\n\t\t\td = int_val2;\n\t\t}\n\t\tif (n) {\n\t\t\tmemset(loc_data, 0, sizeof(char) * 8);\n\t\t\tdata_len = (itype == GF_ITAG_FRAC6) ? 6 : 8;\n\t\t\tloc_data[3] = n;\n\t\t\tloc_data[2] = n >> 8;\n\t\t\tloc_data[5] = d;\n\t\t\tloc_data[4] = d >> 8;\n\t\t\tdata = loc_data;\n\t\t} else {\n\t\t\tdata = NULL;\n\t\t}\n\t\tdbox->flags = 0x15;\n\t\tbreak;\n\tcase GF_ITAG_BOOL:\n\t\tloc_data[0] = 0;\n\t\tif (data && data_len) {\n\t\t\tif ( !strcmp(data, \"yes\") || !strcmp(data, \"1\") || !strcmp(data, \"true\"))\n\t\t\t\tloc_data[0] = 1;\n\t\t} else {\n\t\t\tloc_data[0] = int_val ? 1 : 0;\n\t\t}\n\t\tdata = loc_data;\n\t\tdata_len = 1;\n\t\tdbox->flags = int_flags;\n\t\tbreak;\n\tcase GF_ITAG_INT8:\n\t\tloc_data[0] = 0;\n\t\tif (data && data_len) int_val = atoi(data);\n\t\tloc_data[0] = (u8) int_val;\n\t\tdata = loc_data;\n\t\tdata_len = 1;\n\t\tdbox->flags = int_flags;\n\t\tbreak;\n\tcase GF_ITAG_INT16:\n\t\tloc_data[0] = 0;\n\t\tif (data && data_len) int_val = atoi(data);\n\t\tloc_data[1] = (u8) int_val;\n\t\tloc_data[0] = (u8) (int_val>>8);\n\t\tdata = loc_data;\n\t\tdata_len = 2;\n\t\tdbox->flags = int_flags;\n\t\tbreak;\n\tcase GF_ITAG_INT32:\n\t\tloc_data[0] = 0;\n\t\tif (data && data_len) int_val = atoi(data);\n\t\tloc_data[3] = (u8) int_val;\n\t\tloc_data[2] = (u8) (int_val>>8);\n\t\tloc_data[1] = (u8) (int_val>>16);\n\t\tloc_data[0] = (u8) (int_val>>24);\n\t\tdata = loc_data;\n\t\tdata_len = 4;\n\t\tdbox->flags = int_flags;\n\t\tbreak;\n\tcase GF_ITAG_INT64:\n\t\tloc_data[0] = 0;\n\t\tif (data && data_len) sscanf(data, LLU, &int_val);\n\t\tloc_data[7] = (u8) int_val;\n\t\tloc_data[6] = (u8) (int_val>>8);\n\t\tloc_data[5] = (u8) (int_val>>16);\n\t\tloc_data[4] = (u8) (int_val>>24);\n\t\tloc_data[3] = (u8) (int_val>>32);\n\t\tloc_data[2] = (u8) (int_val>>40);\n\t\tloc_data[1] = (u8) (int_val>>48);\n\t\tloc_data[0] = (u8) (int_val>>56);\n\t\tdata = loc_data;\n\t\tdata_len = 8;\n\t\tdbox->flags = int_flags;\n\t\tbreak;\n\tdefault:\n\t\tdbox->flags = 1;\n\t\tbreak;\n\t}\n\n\tif (!data) return GF_BAD_PARAM;\n\n\n\tif (tag==GF_ISOM_ITUNE_COVER_ART) {\n\t\tinfo->data->flags = 0;\n\t\t/*check for PNG sig*/\n\t\tif ((data_len>4) && (data[0] == 0x89) && (data[1] == 0x50) && (data[2] == 0x4E) && (data[3] == 0x47) ) {\n\t\t\tinfo->data->flags = 14;\n\t\t}\n\t\t//JPG and JFIF - do not check second tag type\n\t\telse if ((data_len>4) && (data[0] == 0xFF) && (data[1] == 0xD8) && (data[2] == 0xFF) /*&& ((data[3] == 0xE0) || (data[3] == 0xDB))*/ ) {\n\t\t\tinfo->data->flags = 13;\n\t\t}\n\t\t//GIF\n\t\telse if ((data_len>3) && (data[0] == 'G') && (data[1] == 'I') && (data[2] == 'F') ) {\n\t\t\tinfo->data->flags = 12;\n\t\t}\n\t}\n\n\tdbox->dataSize = data_len;\n\tdbox->data = (char*)gf_malloc(sizeof(char)*data_len);\n\tif (!dbox->data) return GF_OUT_OF_MEM;\n\tmemcpy(dbox->data, data, sizeof(char)*data_len);\n\n\tif (!info && !gf_list_count(ilst->child_boxes) ) {\n\t\tgf_isom_box_del_parent(&meta->child_boxes, (GF_Box *) ilst);\n\t\treturn GF_OK;\n\t}\n\tif (!ilst->child_boxes) ilst->child_boxes = gf_list_new();\n\t\n\treturn gf_list_add(ilst->child_boxes, info);\n}\n\n#include <gpac/utf.h>\n\nGF_EXPORT\nGF_Err gf_isom_wma_set_tag(GF_ISOFile *mov, char *name, char *value)\n{\n\tGF_Err e;\n\tGF_XtraTag *tag=NULL;\n\tu32 count, i;\n\tGF_XtraBox *xtra;\n\n\te = CanAccessMovie(mov, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tgf_isom_create_meta_extensions(mov, GF_FALSE);\n\n\txtra = (GF_XtraBox *) gf_isom_create_meta_extensions(mov, GF_TRUE);\n\tif (!xtra) return GF_BAD_PARAM;\n\n\tcount = gf_list_count(xtra->tags);\n\tfor (i=0; i<count; i++) {\n\t\ttag = gf_list_get(xtra->tags, i);\n\t\tif (name && tag->name && !strcmp(tag->name, name)) {\n\n\t\t} else {\n\t\t\ttag = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!value) {\n\t\t\tgf_list_rem(xtra->tags, i);\n\t\t\tgf_free(tag->name);\n\t\t\tif (tag->prop_value) gf_free(tag->prop_value);\n\t\t\tgf_free(tag);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tgf_free(tag->prop_value);\n\t\ttag->prop_value = 0;\n\t}\n\tif (!tag) {\n\t\tif (!name) return GF_OK;\n\n\t\tGF_SAFEALLOC(tag, GF_XtraTag);\n\t\ttag->name = gf_strdup(name);\n\t\ttag->prop_type = 0;\n\t\ttag->flags = 1;\n\t\tgf_list_add(xtra->tags, tag);\n\t}\n\n\tu32 len = (u32) strlen(value);\n\ttag->prop_value = gf_malloc(sizeof(u16) * (len+1) );\n\tmemset(tag->prop_value, 0, sizeof(u16) * (len+1) );\n\tif (len) {\n\t\tu32 _len = gf_utf8_mbstowcs((u16 *) tag->prop_value, len, (const char **) &value);\n\t\tif (_len == GF_UTF8_FAIL) _len = 0;\n\t\ttag->prop_value[2 * _len] = 0;\n\t\ttag->prop_value[2 * _len + 1] = 0;\n\t\ttag->prop_size = 2 * _len + 2;\n\t} else {\n\t\ttag->prop_size = 2;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_qt_key(GF_ISOFile *movie, GF_QT_UDTAKey *key)\n{\n\tGF_Err e;\n\tGF_MetaBox *meta;\n\tGF_ItemListBox *ilst;\n\tGF_MetaKeysBox *keys;\n\tu32 i, nb_keys;\n\n\tif (!movie) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) {\n\t\tgf_isom_set_last_error(movie, e);\n\t\treturn 0;\n\t}\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tmeta = (GF_MetaBox *) gf_isom_create_meta_extensions(movie, 2);\n\tif (!meta) return GF_BAD_PARAM;\n\n\tkeys = (GF_MetaKeysBox *) gf_isom_locate_box(meta->child_boxes, GF_ISOM_BOX_TYPE_KEYS, NULL);\n\tif (!keys) {\n\t\tkeys = (GF_MetaKeysBox *) gf_isom_box_new_parent(&meta->child_boxes, GF_ISOM_BOX_TYPE_KEYS);\n\t\tmeta->keys = keys;\n\t}\n\tilst = (GF_ItemListBox *) gf_isom_locate_box(meta->child_boxes, GF_ISOM_BOX_TYPE_ILST, NULL);\n\tif (!ilst) {\n\t\tilst = (GF_ItemListBox *) gf_isom_box_new_parent(&meta->child_boxes, GF_ISOM_BOX_TYPE_ILST);\n\t}\n\tif (!keys || !ilst) return GF_OUT_OF_MEM;\n\n\tnb_keys = gf_list_count(keys->keys);\n\tif (!key) {\n\t\tgf_isom_box_del_parent(&meta->child_boxes, (GF_Box *) keys);\n\t\tfor (i=0; i<gf_list_count(ilst->child_boxes); i++) {\n\t\t\tGF_ListItemBox *info = gf_list_get(ilst->child_boxes, i);\n\t\t\tif (info->type <= nb_keys) {\n\t\t\t\tgf_isom_box_del_parent(&ilst->child_boxes, (GF_Box *) info);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\tif (!gf_list_count(ilst->child_boxes)) {\n\t\t\tgf_isom_box_del_parent(&meta->child_boxes, (GF_Box *) ilst);\n\t\t\t//if last, delete udta - we may still have a handler box remaining\n\t\t\tif ((gf_list_count(meta->child_boxes) <= 1) && (gf_list_count(movie->moov->udta->recordList)==1)) {\n\t\t\t\tgf_isom_box_del_parent(&movie->moov->child_boxes, (GF_Box *) movie->moov->udta);\n\t\t\t\tmovie->moov->udta = NULL;\n\t\t\t}\n\t\t}\n\t\treturn GF_OK;\n\t}\n\t//locate key\n\tGF_MetaKey *o_key = NULL;\n\tu32 ksize = (u32) strlen(key->name);\n\tfor (i=0; i<nb_keys; i++) {\n\t\to_key = gf_list_get(keys->keys, i);\n\t\tif ((o_key->ns == key->ns) && (o_key->size==ksize) && !strcmp(o_key->data, key->name))\n\t\t\tbreak;\n\t\to_key = NULL;\n\t}\n\tif (!o_key) {\n\t\tif (key->type==GF_QT_KEY_REMOVE) return GF_OK;\n\t\tGF_SAFEALLOC(o_key, GF_MetaKey);\n\t\to_key->ns = key->ns;\n\t\to_key->data = gf_strdup(key->name);\n\t\to_key->size = ksize;\n\t\tgf_list_add(keys->keys, o_key);\n\t}\n\tu32 key_idx = gf_list_find(keys->keys, o_key)+1;\n\tGF_UnknownBox *info=NULL;\n\tfor (i=0; i<gf_list_count(ilst->child_boxes); i++) {\n\t\tinfo = gf_list_get(ilst->child_boxes, i);\n\t\tif (info->original_4cc == key_idx) break;\n\t\tinfo = NULL;\n\t}\n\n\tif (key->type==GF_QT_KEY_REMOVE) {\n\t\tgf_list_del_item(keys->keys, o_key);\n\t\tif (o_key->data) gf_free(o_key->data);\n\t\tgf_free(o_key);\n\t\tfor (i=0; i<gf_list_count(ilst->child_boxes); i++) {\n\t\t\tinfo = gf_list_get(ilst->child_boxes, i);\n\t\t\tif (info->type!=GF_ISOM_BOX_TYPE_UNKNOWN) continue;\n\t\t\tif (info->original_4cc==key_idx) {\n\t\t\t\tgf_isom_box_del_parent(&ilst->child_boxes, (GF_Box *)info);\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (info->original_4cc>key_idx) {\n\t\t\t\tinfo->original_4cc--;\n\t\t\t}\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (!info) {\n\t\tinfo = (GF_UnknownBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_UNKNOWN);\n\t\tif (!info) return GF_OUT_OF_MEM;\n\t\tif (!ilst->child_boxes) ilst->child_boxes = gf_list_new();\n\t\tgf_list_add(ilst->child_boxes, info);\n\t}\n\n\tGF_DataBox *dbox = (GF_DataBox *) gf_isom_box_find_child(info->child_boxes, GF_ISOM_BOX_TYPE_DATA);\n\tif (!dbox) {\n\t\tdbox = (GF_DataBox *)gf_isom_box_new_parent(&info->child_boxes, GF_ISOM_BOX_TYPE_DATA);\n\t\tif (!dbox) {\n\t\t\tgf_isom_box_del((GF_Box *)info);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t}\n\tu32 nb_bits=0;\n\tinfo->original_4cc = key_idx;\n\tdbox->version = 0;\n\tdbox->flags = key->type;\n\t//serialize\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tswitch (key->type) {\n\tcase GF_QT_KEY_UTF8:\n\tcase GF_QT_KEY_UTF8_SORT:\n\t\tif (key->value.string)\n\t\t\tgf_bs_write_data(bs, key->value.string, (u32) strlen(key->value.string));\n\t\tbreak;\n\n\tcase GF_QT_KEY_SIGNED_VSIZE:\n\t\tif (ABS(key->value.sint)<=0x7F) nb_bits=8;\n\t\telse if (ABS(key->value.sint)<=0x7FFF) nb_bits=16;\n\t\telse if (ABS(key->value.sint)<=0x7FFFFF) nb_bits=24;\n\t\telse nb_bits = 32;\n\t\tgf_bs_write_int(bs, (s32) key->value.sint, nb_bits);\n\t\tbreak;\n\tcase GF_QT_KEY_UNSIGNED_VSIZE:\n\t\tif (key->value.uint<=0xFF) nb_bits=8;\n\t\telse if (key->value.uint<=0xFFFF) nb_bits=16;\n\t\telse if (key->value.uint<=0xFFFFFF) nb_bits=24;\n\t\telse nb_bits = 32;\n\t\tgf_bs_write_int(bs, (u32) key->value.uint, nb_bits);\n\t\tbreak;\n\tcase GF_QT_KEY_FLOAT:\n\t\tgf_bs_write_float(bs, (Float) key->value.number);\n\t\tbreak;\n\tcase GF_QT_KEY_DOUBLE:\n\t\tgf_bs_write_double(bs, key->value.number);\n\t\tbreak;\n\tcase GF_QT_KEY_SIGNED_8:\n\t\tgf_bs_write_int(bs, (s32) key->value.sint, 8);\n\t\tbreak;\n\tcase GF_QT_KEY_SIGNED_16:\n\t\tgf_bs_write_int(bs, (s32) key->value.sint, 16);\n\t\tbreak;\n\tcase GF_QT_KEY_SIGNED_32:\n\t\tgf_bs_write_int(bs, (s32) key->value.sint, 32);\n\t\tbreak;\n\tcase GF_QT_KEY_SIGNED_64:\n\t\tgf_bs_write_long_int(bs, key->value.sint, 64);\n\t\tbreak;\n\tcase GF_QT_KEY_POINTF:\n\tcase GF_QT_KEY_SIZEF:\n\t\tgf_bs_write_float(bs, key->value.pos_size.x);\n\t\tgf_bs_write_float(bs, key->value.pos_size.y);\n\t\tbreak;\n\tcase GF_QT_KEY_RECTF:\n\t\tgf_bs_write_float(bs, key->value.rect.x);\n\t\tgf_bs_write_float(bs, key->value.rect.y);\n\t\tgf_bs_write_float(bs, key->value.rect.w);\n\t\tgf_bs_write_float(bs, key->value.rect.h);\n\t\tbreak;\n\n\tcase GF_QT_KEY_UNSIGNED_8:\n\t\tgf_bs_write_int(bs, (s32) key->value.uint, 8);\n\t\tbreak;\n\tcase GF_QT_KEY_UNSIGNED_16:\n\t\tgf_bs_write_int(bs, (s32) key->value.uint, 16);\n\t\tbreak;\n\tcase GF_QT_KEY_UNSIGNED_32:\n\t\tgf_bs_write_int(bs, (s32) key->value.uint, 32);\n\t\tbreak;\n\tcase GF_QT_KEY_UNSIGNED_64:\n\t\tgf_bs_write_long_int(bs, key->value.uint, 64);\n\t\tbreak;\n\tcase GF_QT_KEY_MATRIXF:\n\t\tfor (i=0; i<9; i++)\n\t\t\tgf_bs_write_float(bs, (Float) key->value.matrix[i] );\n\t\tbreak;\n\n\tcase GF_QT_KEY_OPAQUE:\n\tcase GF_QT_KEY_UTF16_BE:\n\tcase GF_QT_KEY_JIS:\n\tcase GF_QT_KEY_UTF16_SORT:\n\tcase GF_QT_KEY_JPEG:\n\tcase GF_QT_KEY_PNG:\n\tcase GF_QT_KEY_BMP:\n\tcase GF_QT_KEY_METABOX:\n\tdefault:\n\t\tgf_bs_write_data(bs, key->value.data.data, key->value.data.data_len);\n\t\tbreak;\n\t}\n\t//write extra 0 at end, not serialized\n\tgf_bs_write_u8(bs, 0);\n\tif (dbox->data) gf_free(dbox->data);\n\n\tgf_bs_get_content(bs, &dbox->data, &i);\n\tif (i) i--;\n\tdbox->dataSize = i;\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_alternate_group_id(GF_ISOFile *movie, u32 trackNumber, u32 groupId)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\ttrak->Header->alternate_group = groupId;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber, u32 trackRefGroup, Bool is_switch_group, u32 *switchGroupID, u32 *criteriaList, u32 criteriaListCount)\n{\n\tGF_TrackSelectionBox *tsel;\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_Err e;\n\tu32 alternateGroupID = 0;\n\tu32 next_switch_group_id = 0;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !switchGroupID) return GF_BAD_PARAM;\n\n\n\tif (trackRefGroup) {\n\t\tGF_TrackBox *trak_ref = gf_isom_get_track_from_file(movie, trackRefGroup);\n\t\tif (trak_ref != trak) {\n\t\t\tif (!trak_ref || !trak_ref->Header->alternate_group) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"Track %d has not an alternate group - skipping\\n\", trak_ref ? trak_ref->Header->trackID : 0));\n\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t}\n\t\t\talternateGroupID = trak_ref->Header->alternate_group;\n\t\t} else {\n\t\t\talternateGroupID = trak->Header->alternate_group;\n\t\t}\n\t}\n\tif (!alternateGroupID) {\n\t\t/*there is a function for this ....*/\n\t\tif (trak->Header->alternate_group) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"Track %d has already an alternate group - skipping\\n\", trak->Header->trackID));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\talternateGroupID = gf_isom_get_next_alternate_group_id(movie);\n\t}\n\n\tif (is_switch_group) {\n\t\tu32 i=0;\n\t\twhile (i< gf_isom_get_track_count(movie) ) {\n\t\t\t//locate first available ID\n\t\t\tGF_TrackBox *a_trak = gf_isom_get_track_from_file(movie, i+1);\n\n\t\t\tif (a_trak->udta) {\n\t\t\t\tu32 j, count;\n\t\t\t\tmap = udta_getEntry(a_trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\t\t\t\tif (map) {\n\t\t\t\t\tcount = gf_list_count(map->boxes);\n\t\t\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\t\t\ttsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, j);\n\n\t\t\t\t\t\tif (*switchGroupID) {\n\t\t\t\t\t\t\tif (tsel->switchGroup==next_switch_group_id) {\n\t\t\t\t\t\t\t\tif (a_trak->Header->alternate_group != alternateGroupID) return GF_BAD_PARAM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (tsel->switchGroup && (tsel->switchGroup>=next_switch_group_id) )\n\t\t\t\t\t\t\t\tnext_switch_group_id = tsel->switchGroup;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif (! *switchGroupID) *switchGroupID = next_switch_group_id+1;\n\t}\n\n\n\ttrak->Header->alternate_group = alternateGroupID;\n\n\ttsel = NULL;\n\tif (*switchGroupID) {\n\t\tif (!trak->udta) {\n\t\t\te = trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\n\t\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\n\t\t/*locate tsel box with no switch group*/\n\t\tif (map)  {\n\t\t\tu32 j, count = gf_list_count(map->boxes);\n\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\ttsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, j);\n\t\t\t\tif (tsel->switchGroup == *switchGroupID) break;\n\t\t\t\ttsel = NULL;\n\t\t\t}\n\t\t}\n\t\tif (!tsel) {\n\t\t\ttsel = (GF_TrackSelectionBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_TSEL);\n\t\t\tif (!tsel) return GF_OUT_OF_MEM;\n\t\t\te = udta_on_child_box((GF_Box *)trak->udta, (GF_Box *) tsel, GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\n\t\ttsel->switchGroup = *switchGroupID;\n\t\ttsel->attributeListCount = criteriaListCount;\n\t\tif (tsel->attributeList) gf_free(tsel->attributeList);\n\t\ttsel->attributeList = (u32*)gf_malloc(sizeof(u32)*criteriaListCount);\n\t\tif (!tsel->attributeList) return GF_OUT_OF_MEM;\n\t\tmemcpy(tsel->attributeList, criteriaList, sizeof(u32)*criteriaListCount);\n\t}\n\treturn GF_OK;\n}\n\nvoid reset_tsel_box(GF_TrackBox *trak)\n{\n\tGF_UserDataMap *map;\n\ttrak->Header->alternate_group = 0;\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\tif (map) {\n\t\tgf_list_del_item(trak->udta->recordList, map);\n\t\tgf_isom_box_array_del(map->boxes);\n\t\tgf_free(map);\n\t}\n\n}\n\nGF_EXPORT\nGF_Err gf_isom_reset_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber, Bool reset_all_group)\n{\n\tGF_TrackBox *trak;\n\tu32 alternateGroupID = 0;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Header->alternate_group) return GF_OK;\n\n\talternateGroupID = trak->Header->alternate_group;\n\tif (reset_all_group) {\n\t\tu32 i=0;\n\t\twhile (i< gf_isom_get_track_count(movie) ) {\n\t\t\t//locate first available ID\n\t\t\tGF_TrackBox *a_trak = gf_isom_get_track_from_file(movie, i+1);\n\t\t\tif (a_trak->Header->alternate_group == alternateGroupID) reset_tsel_box(a_trak);\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\treset_tsel_box(trak);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_reset_switch_parameters(GF_ISOFile *movie)\n{\n\tu32 i=0;\n\twhile (i< gf_isom_get_track_count(movie) ) {\n\t\t//locate first available ID\n\t\tGF_TrackBox *a_trak = gf_isom_get_track_from_file(movie, i+1);\n\t\treset_tsel_box(a_trak);\n\t\ti++;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_add_subsample(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 flags, u32 subSampleSize, u8 priority, u32 reserved, Bool discardable)\n{\n\tu32 i, count;\n\tGF_SubSampleInformationBox *sub_samples;\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak || !trak->Media || !trak->Media->information->sampleTable)\n\t\treturn GF_BAD_PARAM;\n\n\tif (!trak->Media->information->sampleTable->sub_samples) {\n\t\ttrak->Media->information->sampleTable->sub_samples=gf_list_new();\n\t}\n\n\tsub_samples = NULL;\n\tcount = gf_list_count(trak->Media->information->sampleTable->sub_samples);\n\tfor (i=0; i<count; i++) {\n\t\tsub_samples = gf_list_get(trak->Media->information->sampleTable->sub_samples, i);\n\t\tif (sub_samples->flags==flags) break;\n\t\tsub_samples = NULL;\n\t}\n\tif (!sub_samples) {\n\t\tsub_samples = (GF_SubSampleInformationBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_SUBS);\n\t\tif (!sub_samples) return GF_OUT_OF_MEM;\n\t\tgf_list_add(trak->Media->information->sampleTable->sub_samples, sub_samples);\n\t\tsub_samples->version = (subSampleSize>0xFFFF) ? 1 : 0;\n\t\tsub_samples->flags = flags;\n\t}\n\treturn gf_isom_add_subsample_info(sub_samples, sampleNumber, subSampleSize, priority, reserved, discardable);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_rvc_config(GF_ISOFile *movie, u32 track, u32 sampleDescriptionIndex, u16 rvc_predefined, char *mime, u8 *data, u32 size)\n{\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex-1);\n\tif (!entry ) return GF_BAD_PARAM;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_RVCConfigurationBox *rvcc = (GF_RVCConfigurationBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_RVCC);\n\tif (rvcc && rvcc->rvc_meta_idx) {\n\t\tgf_isom_remove_meta_item(movie, GF_FALSE, track, rvcc->rvc_meta_idx, GF_FALSE, NULL);\n\t\trvcc->rvc_meta_idx = 0;\n\t}\n\n\tif (!rvcc) {\n\t\trvcc = (GF_RVCConfigurationBox *) gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_RVCC);\n\t\tif (!rvcc) return GF_OUT_OF_MEM;\n\t}\n\trvcc->predefined_rvc_config = rvc_predefined;\n\tif (!rvc_predefined) {\n\t\tu32 it_id=0;\n\t\te = gf_isom_set_meta_type(movie, GF_FALSE, track, GF_META_TYPE_RVCI);\n\t\tif (e) return e;\n\t\tgf_isom_modify_alternate_brand(movie, GF_ISOM_BRAND_ISO2, GF_TRUE);\n\t\te = gf_isom_add_meta_item_memory(movie, GF_FALSE, track, \"rvcconfig.xml\", &it_id, GF_META_ITEM_TYPE_MIME, mime, NULL, NULL, data, size, NULL);\n\t\tif (e) return e;\n\t\trvcc->rvc_meta_idx = gf_isom_get_meta_item_count(movie, GF_FALSE, track);\n\t}\n\treturn GF_OK;\n}\n\n/*for now not exported*/\n/*expands sampleGroup table for the given grouping type and sample_number. If sample_number is 0, just appends an entry at the end of the table*/\nstatic GF_Err gf_isom_add_sample_group_entry(GF_List *sampleGroups, u32 sample_number, GF_SampleGroupDescriptionBox *sgdesc, u32 grouping_type_parameter, u32 sampleGroupDescriptionIndex, GF_List *parent, GF_SampleTableBox *stbl)\n{\n\tGF_SampleGroupBox *sgroup = NULL;\n\tu32 i, count, last_sample_in_entry;\n\tBool all_samples = GF_FALSE;\n\tassert(sampleGroups);\n\tif (!sgdesc) return GF_BAD_PARAM;\n\tcount = gf_list_count(sampleGroups);\n\tfor (i=0; i<count; i++) {\n\t\tsgroup = (GF_SampleGroupBox*)gf_list_get(sampleGroups, i);\n\t\tif (sgroup->grouping_type==sgdesc->grouping_type) break;\n\t\tsgroup = NULL;\n\t}\n\tif (!sgroup) {\n\t\tsgroup = (GF_SampleGroupBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_SBGP);\n\t\tif (!sgroup) return GF_OUT_OF_MEM;\n\t\tsgroup->grouping_type = sgdesc->grouping_type;\n\t\tsgroup->grouping_type_parameter = grouping_type_parameter;\n//\t\tgf_list_add(sampleGroups, sgroup);\n\t\t//crude patch to align old arch and filters\n\t\tgf_list_insert(sampleGroups, sgroup, 0);\n\t\tassert(parent);\n\t\tgf_list_add(parent, sgroup);\n\t}\n\tu32 def_insert_value = (sgdesc && (sgdesc->version==2)) ? sgdesc->default_description_index : 0;\n\n\t/*used in fragments, means we are adding the last sample*/\n\tif (!sample_number) {\n\t\tsample_number = 1;\n\t\tif (sgroup->entry_count) {\n\t\t\tfor (i=0; i<sgroup->entry_count; i++) {\n\t\t\t\tsample_number += sgroup->sample_entries[i].sample_count;\n\t\t\t}\n\t\t}\n\t} else if (sample_number==(u32) -1) {\n\t\tall_samples = GF_TRUE;\n\t\tsample_number = 1;\n\t}\n\n\tif (!sgroup->entry_count) {\n\t\tu32 idx = 0;\n\t\tsgroup->entry_count = (sample_number>1) ? 2 : 1;\n\t\tsgroup->sample_entries = (GF_SampleGroupEntry*)gf_malloc(sizeof(GF_SampleGroupEntry) * sgroup->entry_count );\n\t\tif (!sgroup->sample_entries) return GF_OUT_OF_MEM;\n\t\tif (sample_number>1) {\n\t\t\tsgroup->sample_entries[0].sample_count = sample_number-1;\n\t\t\tsgroup->sample_entries[0].group_description_index = sampleGroupDescriptionIndex ? def_insert_value : 1;\n\t\t\tidx = 1;\n\t\t}\n\t\tsgroup->sample_entries[idx].sample_count = 1;\n\t\tsgroup->sample_entries[idx].group_description_index = sampleGroupDescriptionIndex;\n\t\tif (all_samples && stbl) {\n\t\t\tsgroup->sample_entries[idx].sample_count = stbl->SampleSize->sampleCount;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (all_samples && stbl) {\n\t\tsgroup->entry_count = 1;\n\t\tsgroup->sample_entries[0].group_description_index = sampleGroupDescriptionIndex;\n\t\tsgroup->sample_entries[0].sample_count = stbl->SampleSize->sampleCount;\n\t\treturn GF_OK;\n\t}\n\tlast_sample_in_entry = 0;\n\tfor (i=0; i<sgroup->entry_count; i++) {\n\t\t/*TODO*/\n\t\tif (last_sample_in_entry + sgroup->sample_entries[i].sample_count > sample_number)\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\tlast_sample_in_entry += sgroup->sample_entries[i].sample_count;\n\t}\n\n\tif (last_sample_in_entry == sample_number) {\n\t\tif (sgroup->sample_entries[sgroup->entry_count-1].group_description_index==sampleGroupDescriptionIndex)\n\t\t\treturn GF_OK;\n\t\telse\n\t\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tif ((sgroup->sample_entries[sgroup->entry_count-1].group_description_index==sampleGroupDescriptionIndex) && (last_sample_in_entry+1==sample_number)) {\n\t\tsgroup->sample_entries[sgroup->entry_count-1].sample_count++;\n\t\treturn GF_OK;\n\t}\n\t/*last entry was an empty desc (no group associated), just add the number of samples missing until new one, then add new one*/\n\tif (! sgroup->sample_entries[sgroup->entry_count-1].group_description_index) {\n\t\tsgroup->sample_entries[sgroup->entry_count-1].sample_count += sample_number - 1 - last_sample_in_entry;\n\t\tsgroup->sample_entries = (GF_SampleGroupEntry*)gf_realloc(sgroup->sample_entries, sizeof(GF_SampleGroupEntry) * (sgroup->entry_count + 1) );\n\t\tsgroup->sample_entries[sgroup->entry_count].sample_count = 1;\n\t\tsgroup->sample_entries[sgroup->entry_count].group_description_index = sampleGroupDescriptionIndex;\n\t\tsgroup->entry_count++;\n\t\treturn GF_OK;\n\t}\n\t/*we are adding a sample with no desc, add entry at the end*/\n\tif (!sampleGroupDescriptionIndex || (sample_number - 1 - last_sample_in_entry==0) ) {\n\t\tsgroup->sample_entries = (GF_SampleGroupEntry*)gf_realloc(sgroup->sample_entries, sizeof(GF_SampleGroupEntry) * (sgroup->entry_count + 1) );\n\t\tsgroup->sample_entries[sgroup->entry_count].sample_count = 1;\n\t\tsgroup->sample_entries[sgroup->entry_count].group_description_index = sampleGroupDescriptionIndex;\n\t\tsgroup->entry_count++;\n\t\treturn GF_OK;\n\t}\n\t/*need to insert two entries ...*/\n\tsgroup->sample_entries = (GF_SampleGroupEntry*)gf_realloc(sgroup->sample_entries, sizeof(GF_SampleGroupEntry) * (sgroup->entry_count + 2) );\n\n\tsgroup->sample_entries[sgroup->entry_count].sample_count = sample_number - 1 - last_sample_in_entry;\n\tsgroup->sample_entries[sgroup->entry_count].group_description_index = def_insert_value;\n\n\tsgroup->sample_entries[sgroup->entry_count+1].sample_count = 1;\n\tsgroup->sample_entries[sgroup->entry_count+1].group_description_index = sampleGroupDescriptionIndex;\n\tsgroup->entry_count+=2;\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nstatic GF_SampleGroupDescriptionBox *get_sgdp(GF_SampleTableBox *stbl, GF_TrackFragmentBox *traf, u32 grouping_type, Bool *is_traf_sgdp)\n#else\nstatic GF_SampleGroupDescriptionBox *get_sgdp(GF_SampleTableBox *stbl, void *traf, u32 grouping_type, Bool *is_traf_sgdp)\n#endif /* GPAC_DISABLE_ISOM_FRAGMENTS */\n{\n\tGF_List *groupList=NULL;\n\tGF_List **parent=NULL;\n\tGF_SampleGroupDescriptionBox *sgdesc=NULL;\n\tu32 count, i;\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!stbl && traf && traf->trex->track->Media->information->sampleTable)\n\t\tstbl = traf->trex->track->Media->information->sampleTable;\n#endif\n\tif (stbl) {\n\t\tif (!stbl->sampleGroupsDescription && !traf)\n\t\t\tstbl->sampleGroupsDescription = gf_list_new();\n\n\t\tgroupList = stbl->sampleGroupsDescription;\n\t\tif (is_traf_sgdp) *is_traf_sgdp = GF_FALSE;\n\t\tparent = &stbl->child_boxes;\n\n\t\tcount = gf_list_count(groupList);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(groupList, i);\n\t\t\tif (sgdesc->grouping_type==grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n\t\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t/*look in stbl or traf for sample sampleGroupsDescription*/\n\tif (!sgdesc && traf) {\n\t\tif (!traf->sampleGroupsDescription)\n\t\t\ttraf->sampleGroupsDescription = gf_list_new();\n\t\tgroupList = traf->sampleGroupsDescription;\n\t\tparent = &traf->child_boxes;\n\t\tif (is_traf_sgdp) *is_traf_sgdp = GF_TRUE;\n\n\t\tcount = gf_list_count(groupList);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(groupList, i);\n\t\t\tif (sgdesc->grouping_type==grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#endif\n\n\tif (!sgdesc) {\n\t\tsgdesc = (GF_SampleGroupDescriptionBox *) gf_isom_box_new_parent(parent, GF_ISOM_BOX_TYPE_SGPD);\n\t\tif (!sgdesc) return NULL;\n\t\tsgdesc->grouping_type = grouping_type;\n\t\tassert(groupList);\n\t\tgf_list_add(groupList, sgdesc);\n\t}\n\treturn sgdesc;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nstatic GF_Err gf_isom_set_sample_group_info_ex(GF_SampleTableBox *stbl, GF_TrackFragmentBox *traf, u32 sample_number, u32 grouping_type, u32 grouping_type_parameter, void *udta, void *(*sg_create_entry)(void *udta), Bool (*sg_compare_entry)(void *udta, void *entry))\n#else\nstatic GF_Err gf_isom_set_sample_group_info_ex(GF_SampleTableBox *stbl, void *traf, u32 sample_number, u32 grouping_type, u32 grouping_type_parameter, void *udta, void *(*sg_create_entry)(void *udta), Bool (*sg_compare_entry)(void *udta, void *entry))\n#endif /* GPAC_DISABLE_ISOM_FRAGMENTS */\n{\n\tGF_List *groupList, *parent;\n\tvoid *entry;\n\tBool is_traf_sgpd;\n\tGF_SampleGroupDescriptionBox *sgdesc = NULL;\n\tu32 i, entry_idx;\n\n\tif (!stbl && !traf) return GF_BAD_PARAM;\n\n\tsgdesc = get_sgdp(stbl, traf, grouping_type, &is_traf_sgpd);\n\tif (!sgdesc) return GF_OUT_OF_MEM;\n\n\tentry = NULL;\n\tif (sg_compare_entry) {\n\t\tfor (i=0; i<gf_list_count(sgdesc->group_descriptions); i++) {\n\t\t\tentry = gf_list_get(sgdesc->group_descriptions, i);\n\t\t\tif (sg_compare_entry(udta, entry)) break;\n\t\t\tentry = NULL;\n\t\t}\n\t}\n\tif (!entry && sg_create_entry) {\n\t\tentry = sg_create_entry(udta);\n\t\tif (!entry) return GF_IO_ERR;\n\t\tif (traf && !is_traf_sgpd) {\n\t\t\tsgdesc = get_sgdp(NULL, traf, grouping_type, &is_traf_sgpd);\n\t\t}\n\t\tgf_list_add(sgdesc->group_descriptions, entry);\n\t}\n\tif (!entry)\n\t\tentry_idx = 0;\n\telse\n\t\tentry_idx = 1 + gf_list_find(sgdesc->group_descriptions, entry);\n\n\t/*look in stbl or traf for sample sampleGroups*/\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (traf) {\n\t\tif (!traf->sampleGroups)\n\t\t\ttraf->sampleGroups = gf_list_new();\n\t\tgroupList = traf->sampleGroups;\n\t\tparent = traf->child_boxes;\n\t\tif (entry_idx && is_traf_sgpd)\n\t\t\tentry_idx |= 0x10000;\n\t} else\n#endif\n\t{\n\t\tif (!stbl->sampleGroups)\n\t\t\tstbl->sampleGroups = gf_list_new();\n\t\tgroupList = stbl->sampleGroups;\n\t\tparent = stbl->child_boxes;\n\t}\n\n\treturn gf_isom_add_sample_group_entry(groupList, sample_number, sgdesc, grouping_type_parameter, entry_idx, parent, stbl);\n}\n\nstatic GF_Err gf_isom_set_sample_group_info_internal(GF_ISOFile *movie, u32 track, u32 trafID, u32 sample_number, u32 grouping_type, u32 grouping_type_parameter, void *udta, void *(*sg_create_entry)(void *udta), Bool (*sg_compare_entry)(void *udta, void *entry))\n{\n\tGF_Err e;\n\tGF_TrackBox *trak=NULL;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_TrackFragmentBox *traf=NULL;\n#endif\n\tif (!trafID && (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY)) {\n\t\ttrak = gf_isom_get_track_from_file(movie, track);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\ttrafID = trak->Header->trackID;\n\t}\n\n\tif (trafID) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (!movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) )\n\t\t\treturn GF_BAD_PARAM;\n\n\t\ttraf = gf_isom_get_traf(movie, trafID);\n#else\n\t\treturn GF_NOT_SUPPORTED;\n#endif\n\n\t} else if (track) {\n\t\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\tif (e) return e;\n\n\t\ttrak = gf_isom_get_track_from_file(movie, track);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\treturn gf_isom_set_sample_group_info_ex(trak ? trak->Media->information->sampleTable : NULL, traf, sample_number, grouping_type, grouping_type_parameter, udta, sg_create_entry, sg_compare_entry);\n#else\n\treturn gf_isom_set_sample_group_info_ex(trak->Media->information->sampleTable, NULL, sample_number, grouping_type, grouping_type_parameter, udta, sg_create_entry, sg_compare_entry);\n#endif\n\n}\n\nvoid *sgpd_parse_entry(GF_SampleGroupDescriptionBox *p, GF_BitStream *bs, s32 bytes_in_box, u32 entry_size, u32 *total_bytes);\n\nGF_Err gf_isom_add_sample_group_info_internal(GF_ISOFile *movie, u32 track, u32 grouping_type, void *data, u32 data_size, u32 sgpd_flags, u32 *sampleGroupDescriptionIndex, Bool *is_traf_sgpd, Bool check_access, Bool *use_default, GF_SampleGroupDescriptionBox **out_sgdesc)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak=NULL;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_TrackFragmentBox *traf=NULL;\n#else\n\tvoid *traf=NULL;\n#endif\n\tu32 trafID=0;\n\tGF_DefaultSampleGroupDescriptionEntry *entry=NULL;\n\tGF_SampleGroupDescriptionBox *sgdesc = NULL;\n\tBool is_default = sgpd_flags & 0x80000000;\n\n\tif (sampleGroupDescriptionIndex) *sampleGroupDescriptionIndex = 0;\n\n\tif (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) {\n\t\ttrak = gf_isom_get_track_from_file(movie, track);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\ttrafID = trak->Header->trackID;\n\t}\n\n\tif (trafID) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (!movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) )\n\t\t\treturn GF_BAD_PARAM;\n\n\t\ttraf = gf_isom_get_traf(movie, trafID);\n#else\n\t\treturn GF_NOT_SUPPORTED;\n#endif\n\t} else {\n\t\tif (check_access) {\n\t\t\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\t\tif (e) return e;\n\t\t}\n\n\t\ttrak = gf_isom_get_track_from_file(movie, track);\n\t}\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//get sample group desc for this grouping type\n\tsgdesc = get_sgdp(trak->Media->information->sampleTable, traf, grouping_type, is_traf_sgpd);\n\tif (!sgdesc) return GF_OUT_OF_MEM;\n\t//first time we create the sample group description, set flags\n\tif (!gf_list_count(sgdesc->group_descriptions) && !traf) {\n\t\tif (sgpd_flags&1) sgdesc->flags |= 1;\n\t\tif (sgpd_flags&2) sgdesc->flags |= 2;\n\t\tif (sgpd_flags&0x40000000) sgdesc->version=3;\n\t}\n\n\n\tGF_BitStream *bs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\tu32 bytes;\n\tentry = sgpd_parse_entry(sgdesc, bs, data_size, data_size, &bytes);\n\tgf_bs_del(bs);\n\tif (!entry) return GF_NON_COMPLIANT_BITSTREAM;\n\n\tif (out_sgdesc) *out_sgdesc = sgdesc;\n\n\n\t//find the same entry\n\tu32 k;\n\tfor (k=0; k<gf_list_count(sgdesc->group_descriptions); k++) {\n\t\tvoid *sgde_dst = gf_list_get(sgdesc->group_descriptions, k);\n\t\tif (gf_isom_is_identical_sgpd(entry, sgde_dst, sgdesc->grouping_type)) {\n\t\t\tif (sampleGroupDescriptionIndex) *sampleGroupDescriptionIndex = k+1;\n\t\t\tsgpd_del_entry(sgdesc->grouping_type, entry);\n\t\t\tif (use_default) {\n\t\t\t\tu32 idx = k+1;\n\t\t\t\tif (is_traf_sgpd && *is_traf_sgpd) idx |= 0x10000;\n\t\t\t\t*use_default = (sgdesc->default_description_index==idx) ? GF_TRUE : GF_FALSE;\n\t\t\t}\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tif (traf && ! *is_traf_sgpd) {\n\t\tsgdesc = get_sgdp(NULL, traf, grouping_type, is_traf_sgpd);\n\t\tif (!sgdesc) return GF_OUT_OF_MEM;\n\t}\n\tif (out_sgdesc) *out_sgdesc = sgdesc;\n\n\te = gf_list_add(sgdesc->group_descriptions, entry);\n\tif (e) {\n\t\tsgpd_del_entry(sgdesc->grouping_type, entry);\n\t\treturn e;\n\t}\n\n#if 0\n\tif (grouping_type==GF_ISOM_SAMPLE_GROUP_OINF) {\n\t\tGF_OperatingPointsInformation *ptr = gf_isom_oinf_new_entry();\n\t\tGF_BitStream *bs=gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\t\te = gf_isom_oinf_read_entry(ptr, bs);\n\t\tgf_bs_del(bs);\n\t\tif (e) {\n\t\t\tgf_isom_oinf_del_entry(ptr);\n\t\t\treturn e;\n\t\t}\n\t\t//not in track, create new sgdp\n\t\tif (traf && ! *is_traf_sgpd) {\n\t\t\tsgdesc  = get_sgdp(NULL, traf, grouping_type, is_traf_sgpd);\n\t\t\tif (!sgdesc) return GF_OUT_OF_MEM;\n\t\t}\n\t\te = gf_list_add(sgdesc->group_descriptions, ptr);\n\t\tif (e) return e;\n\t\tentry = (GF_DefaultSampleGroupDescriptionEntry *) ptr;\n\t} else if (grouping_type==GF_ISOM_SAMPLE_GROUP_LINF) {\n\t\tGF_LHVCLayerInformation *ptr = gf_isom_linf_new_entry();\n\t\tGF_BitStream *bs=gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\t\te = gf_isom_linf_read_entry(ptr, bs);\n\t\tgf_bs_del(bs);\n\t\tif (e) {\n\t\t\tgf_isom_linf_del_entry(ptr);\n\t\t\treturn e;\n\t\t}\n\n\t\tif (traf && ! *is_traf_sgpd) {\n\t\t\tsgdesc = get_sgdp(NULL, traf, grouping_type, is_traf_sgpd);\n\t\t\tif (!sgdesc) return GF_OUT_OF_MEM;\n\t\t}\n\n\t\te = gf_list_add(sgdesc->group_descriptions, ptr);\n\t\tif (e) return e;\n\t\tentry = (GF_DefaultSampleGroupDescriptionEntry *) ptr;\n\t} else {\n\t\tu32 i, count=gf_list_count(sgdesc->group_descriptions);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_DefaultSampleGroupDescriptionEntry *ent = gf_list_get(sgdesc->group_descriptions, i);\n\t\t\tif ((ent->length == data_size) && !memcmp(ent->data, data, data_size)) {\n\t\t\t\tentry = ent;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tentry=NULL;\n\t\t}\n\t\tif (!entry) {\n\t\t\tGF_SAFEALLOC(entry, GF_DefaultSampleGroupDescriptionEntry);\n\t\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\t\tentry->data = (u8*)gf_malloc(sizeof(char) * data_size);\n\t\t\tif (!entry->data) {\n\t\t\t\tgf_free(entry);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tentry->length = data_size;\n\t\t\tmemcpy(entry->data, data, sizeof(char) * data_size);\n\n\t\t\tif (traf && ! *is_traf_sgpd) {\n\t\t\t\tsgdesc = get_sgdp(NULL, traf, grouping_type, is_traf_sgpd);\n\t\t\t\tif (!sgdesc) return GF_OUT_OF_MEM;\n\t\t\t}\n\n\t\t\te = gf_list_add(sgdesc->group_descriptions, entry);\n\t\t\tif (e) {\n\t\t\t\tgf_free(entry->data);\n\t\t\t\tgf_free(entry);\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\n\tif (is_default && !sgdesc->default_description_index) {\n\t\tsgdesc->default_description_index = 1 + gf_list_find(sgdesc->group_descriptions, entry);\n\t\tif (sgdesc->version < 2) sgdesc->version = 2;\n\t\tif (is_traf_sgpd && *is_traf_sgpd) {\n\t\t\tsgdesc->default_description_index |= 0x10000;\n\t\t}\n\t}\n\tu32 grp_idx =  1 + gf_list_find(sgdesc->group_descriptions, entry);\n\tif (sampleGroupDescriptionIndex) *sampleGroupDescriptionIndex = grp_idx;\n\tif (use_default) {\n\t\tif (*is_traf_sgpd)\n\t\t\tgrp_idx |= 0x10000;\n\t\t*use_default = (sgdesc->default_description_index==grp_idx) ? GF_TRUE : GF_FALSE;\n\t}\n\treturn GF_OK;\n}\nGF_EXPORT\nGF_Err gf_isom_add_sample_group_info(GF_ISOFile *movie, u32 track, u32 grouping_type, void *data, u32 data_size, Bool is_default, u32 *sampleGroupDescriptionIndex)\n{\n\treturn gf_isom_add_sample_group_info_internal(movie, track, grouping_type, data, data_size, is_default ? 0x80000000 : 0, sampleGroupDescriptionIndex, NULL, GF_TRUE, NULL, NULL);\n}\n\nGF_Err gf_isom_set_sample_group_description_internal(GF_ISOFile *movie, u32 track, u32 sample_number, u32 grouping_type, u32 grouping_type_parameter, void *data, u32 data_size, Bool check_access, u32 sgpd_flags)\n{\n\tu32 sampleGroupDescriptionIndex, trafID=0;\n\tGF_Err e;\n\tGF_SampleGroupDescriptionBox *sgdesc=NULL;\n\tBool is_traf_sgpd, use_default=GF_FALSE;\n\tGF_List *groupList=NULL, *parent=NULL;\n\n\te = gf_isom_add_sample_group_info_internal(movie, track, grouping_type, data, data_size, sgpd_flags, &sampleGroupDescriptionIndex, &is_traf_sgpd, check_access, &use_default, &sgdesc);\n\tif (e) return e;\n\tif (use_default) return GF_OK;\n\n\tGF_SampleTableBox *stbl=NULL;\n\tGF_TrackBox *trak=NULL;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_TrackFragmentBox *traf=NULL;\n#endif\n\tif (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) {\n\t\ttrak = gf_isom_get_track_from_file(movie, track);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\ttrafID = trak->Header->trackID;\n\t}\n\n\tif (trafID) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (!movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) )\n\t\t\treturn GF_BAD_PARAM;\n\n\t\ttraf = gf_isom_get_traf(movie, trafID);\n#else\n\t\treturn GF_NOT_SUPPORTED;\n#endif\n\n\t} else if (track) {\n\t\tif (check_access) {\n\t\t\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\t\tif (e) return e;\n\t\t}\n\n\t\ttrak = gf_isom_get_track_from_file(movie, track);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t}\n\n\t/*look in stbl or traf for sample sampleGroups*/\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (traf) {\n\t\tif (!traf->sampleGroups)\n\t\t\ttraf->sampleGroups = gf_list_new();\n\t\tgroupList = traf->sampleGroups;\n\t\tparent = traf->child_boxes;\n\t\tif (sampleGroupDescriptionIndex && is_traf_sgpd)\n\t\t\tsampleGroupDescriptionIndex |= 0x10000;\n\t} else\n#endif\n\t{\n\t\tstbl = trak->Media->information->sampleTable;\n\t\tif (!stbl->sampleGroups)\n\t\t\tstbl->sampleGroups = gf_list_new();\n\t\tgroupList = stbl->sampleGroups;\n\t\tparent = stbl->child_boxes;\n\t}\n\n\treturn gf_isom_add_sample_group_entry(groupList, sample_number, sgdesc, grouping_type_parameter, sampleGroupDescriptionIndex, parent, stbl);\n\n}\n\nGF_Err gf_isom_set_sample_group_description(GF_ISOFile *movie, u32 track, u32 sample_number, u32 grouping_type, u32 grouping_type_parameter, void *data, u32 data_size, u32 sgpd_flags)\n{\n\treturn gf_isom_set_sample_group_description_internal(movie, track, sample_number, grouping_type, grouping_type_parameter, data, data_size, GF_TRUE, sgpd_flags);\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_sample_group(GF_ISOFile *movie, u32 track, u32 grouping_type)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tu32 count, i;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (trak->Media->information->sampleTable->sampleGroupsDescription) {\n\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\t\tif (sgdesc->grouping_type==grouping_type) {\n\t\t\t\tgf_isom_box_del_parent(&trak->Media->information->sampleTable->child_boxes, (GF_Box*)sgdesc);\n\t\t\t\tgf_list_rem(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\t\t\ti--;\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\t}\n\tif (trak->Media->information->sampleTable->sampleGroups) {\n\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroups);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SampleGroupBox *sgroup = gf_list_get(trak->Media->information->sampleTable->sampleGroups, i);\n\t\t\tif (sgroup->grouping_type==grouping_type) {\n\t\t\t\tgf_isom_box_del_parent(&trak->Media->information->sampleTable->child_boxes, (GF_Box*)sgroup);\n\t\t\t\tgf_list_rem(trak->Media->information->sampleTable->sampleGroups, i);\n\t\t\t\ti--;\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_sample_info(GF_ISOFile *movie, u32 track, u32 sample_number, u32 grouping_type, u32 sampleGroupDescriptionIndex, u32 grouping_type_parameter)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_List *groupList;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (!trak->Media->information->sampleTable->sampleGroups)\n\t\ttrak->Media->information->sampleTable->sampleGroups = gf_list_new();\n\n\n\tGF_SampleGroupDescriptionBox *sgdesc = get_sgdp(trak->Media->information->sampleTable, NULL, grouping_type, NULL);\n\tif (!sgdesc) return GF_BAD_PARAM;\n\n\tgroupList = trak->Media->information->sampleTable->sampleGroups;\n\treturn gf_isom_add_sample_group_entry(groupList, sample_number, sgdesc, grouping_type_parameter, sampleGroupDescriptionIndex, trak->Media->information->sampleTable->child_boxes, trak->Media->information->sampleTable);\n}\n\nvoid *sg_rap_create_entry(void *udta)\n{\n\tGF_VisualRandomAccessEntry *entry;\n\tu32 *num_leading_samples = (u32 *) udta;\n\tassert(udta);\n\tGF_SAFEALLOC(entry, GF_VisualRandomAccessEntry);\n\tif (!entry) return NULL;\n\tentry->num_leading_samples = *num_leading_samples;\n\tentry->num_leading_samples_known = entry->num_leading_samples ? 1 : 0;\n\treturn entry;\n}\n\nBool sg_rap_compare_entry(void *udta, void *entry)\n{\n\tu32 *num_leading_samples = (u32 *) udta;\n\tif (*num_leading_samples == ((GF_VisualRandomAccessEntry *)entry)->num_leading_samples) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_sample_rap_group(GF_ISOFile *movie, u32 track, u32 sample_number, Bool is_rap, u32 num_leading_samples)\n{\n\treturn gf_isom_set_sample_group_info_internal(movie, track, 0, sample_number, GF_ISOM_SAMPLE_GROUP_RAP, 0, &num_leading_samples, is_rap ? sg_rap_create_entry : NULL, is_rap ? sg_rap_compare_entry : NULL);\n}\n\nGF_Err gf_isom_fragment_set_sample_rap_group(GF_ISOFile *movie, GF_ISOTrackID trackID, u32 sample_number_in_frag, Bool is_rap, u32 num_leading_samples)\n{\n\treturn gf_isom_set_sample_group_info_internal(movie, 0, trackID, sample_number_in_frag, GF_ISOM_SAMPLE_GROUP_RAP, 0, &num_leading_samples, is_rap ? sg_rap_create_entry : NULL, is_rap ? sg_rap_compare_entry : NULL);\n}\n\n\n\nvoid *sg_roll_create_entry(void *udta)\n{\n\tGF_RollRecoveryEntry *entry;\n\ts16 *roll_distance = (s16 *) udta;\n\tGF_SAFEALLOC(entry, GF_RollRecoveryEntry);\n\tif (!entry) return NULL;\n\tentry->roll_distance = *roll_distance;\n\treturn entry;\n}\n\nBool sg_roll_compare_entry(void *udta, void *entry)\n{\n\ts16 *roll_distance = (s16 *) udta;\n\tif (*roll_distance == ((GF_RollRecoveryEntry *)entry)->roll_distance) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_sample_roll_group(GF_ISOFile *movie, u32 track, u32 sample_number, GF_ISOSampleRollType roll_type, s16 roll_distance)\n{\n\tu32 grp_type = (roll_type>=GF_ISOM_SAMPLE_PREROLL) ? GF_ISOM_SAMPLE_GROUP_PROL : GF_ISOM_SAMPLE_GROUP_ROLL;\n\tif (roll_type==GF_ISOM_SAMPLE_PREROLL_NONE)\n\t\troll_type = 0;\n\n\treturn gf_isom_set_sample_group_info_internal(movie, track, 0, sample_number, grp_type, 0, &roll_distance, roll_type ? sg_roll_create_entry : NULL, roll_type ? sg_roll_compare_entry : NULL);\n}\n\nGF_EXPORT\nGF_Err gf_isom_fragment_set_sample_roll_group(GF_ISOFile *movie, GF_ISOTrackID trackID, u32 sample_number_in_frag, GF_ISOSampleRollType roll_type, s16 roll_distance)\n{\n\tu32 grp_type = (roll_type>=GF_ISOM_SAMPLE_PREROLL) ? GF_ISOM_SAMPLE_GROUP_PROL : GF_ISOM_SAMPLE_GROUP_ROLL;\n\tif (roll_type==GF_ISOM_SAMPLE_PREROLL_NONE)\n\t\troll_type = 0;\n\n\treturn gf_isom_set_sample_group_info_internal(movie, 0, trackID, sample_number_in_frag, grp_type, 0, &roll_distance, roll_type ? sg_roll_create_entry : NULL, roll_type ? sg_roll_compare_entry : NULL);\n}\n\n\nvoid *sg_encryption_create_entry(void *udta)\n{\n\tGF_CENCSampleEncryptionGroupEntry *entry, *from_entry;\n\tGF_SAFEALLOC(entry, GF_CENCSampleEncryptionGroupEntry);\n\tif (!entry) return NULL;\n\tfrom_entry = (GF_CENCSampleEncryptionGroupEntry *)udta;\n\tmemcpy(entry, from_entry, sizeof(GF_CENCSampleEncryptionGroupEntry) );\n\tentry->key_info = gf_malloc(sizeof(u8) * entry->key_info_size);\n\tif (!entry->key_info) {\n\t\tgf_free(entry);\n\t\treturn NULL;\n\t}\n\tmemcpy(entry->key_info, from_entry->key_info, entry->key_info_size);\n\treturn entry;\n}\n\nBool sg_encryption_compare_entry(void *udta, void *_entry)\n{\n\tGF_CENCSampleEncryptionGroupEntry *entry = (GF_CENCSampleEncryptionGroupEntry *)_entry;\n\tGF_CENCSampleEncryptionGroupEntry *with_entry = (GF_CENCSampleEncryptionGroupEntry *)udta;\n\n\tif (entry->IsProtected != with_entry->IsProtected) return GF_FALSE;\n\tif (entry->skip_byte_block != with_entry->skip_byte_block) return GF_FALSE;\n\tif (entry->crypt_byte_block != with_entry->crypt_byte_block) return GF_FALSE;\n\tif (entry->key_info_size != with_entry->key_info_size) return GF_FALSE;\n\n\tif (!memcmp(entry->key_info, with_entry->key_info, with_entry->key_info_size))\n\t\treturn GF_TRUE;\n\treturn GF_FALSE;\n}\n\n\n/*sample encryption information group can be in stbl or traf*/\nGF_EXPORT\nGF_Err gf_isom_set_sample_cenc_group(GF_ISOFile *movie, u32 track, u32 sample_number, u8 isEncrypted, u8 crypt_byte_block, u8 skip_byte_block, u8 *key_info, u32 key_info_size)\n{\n\tGF_CENCSampleEncryptionGroupEntry entry;\n\tif (!key_info || (key_info_size<19))\n\t\treturn GF_BAD_PARAM;\n\n\tmemset(&entry, 0, sizeof(GF_CENCSampleEncryptionGroupEntry));\n\tentry.crypt_byte_block = crypt_byte_block;\n\tentry.skip_byte_block = skip_byte_block;\n\tentry.IsProtected = isEncrypted;\n\tentry.key_info = key_info;\n\tentry.key_info_size = key_info_size;\n\n\treturn gf_isom_set_sample_group_info_internal(movie, track, 0, sample_number, GF_ISOM_SAMPLE_GROUP_SEIG, 0, &entry, sg_encryption_create_entry, sg_encryption_compare_entry);\n}\n\n\n\nGF_EXPORT\nGF_Err gf_isom_set_sample_cenc_default_group(GF_ISOFile *movie, u32 track, u32 sample_number)\n{\n\treturn gf_isom_set_sample_group_info_internal(movie, track, 0, sample_number, GF_ISOM_SAMPLE_GROUP_SEIG, 0, NULL, NULL, NULL);\n}\n\nGF_Err gf_isom_force_ctts(GF_ISOFile *file, u32 track)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n \ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (trak->Media->information->sampleTable->CompositionOffset) return GF_OK;\n\n\ttrak->Media->information->sampleTable->CompositionOffset = (GF_CompositionOffsetBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_CTTS);\n\tif (!trak->Media->information->sampleTable->CompositionOffset) return GF_OUT_OF_MEM;\n\ttrak->Media->information->sampleTable->CompositionOffset->nb_entries = 1;\n\ttrak->Media->information->sampleTable->CompositionOffset->entries = gf_malloc(sizeof(GF_DttsEntry));\n\ttrak->Media->information->sampleTable->CompositionOffset->entries[0].decodingOffset = 0;\n\ttrak->Media->information->sampleTable->CompositionOffset->entries[0].sampleCount = \ttrak->Media->information->sampleTable->SampleSize->sampleCount;\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_set_ctts_v1(GF_ISOFile *file, u32 track, u32 ctts_shift)\n{\n\tu32 i, shift;\n\tu64 duration;\n\tGF_CompositionOffsetBox *ctts;\n\tGF_CompositionToDecodeBox *cslg;\n\ts32 leastCTTS, greatestCTTS;\n\tGF_TrackBox *trak;\n\tGF_Err e = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n \ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tctts = trak->Media->information->sampleTable->CompositionOffset;\n\tif (ctts->version) {\n\t\tshift = ctts_shift;\n\t} else {\n\t\tshift = ctts->nb_entries ? ctts->entries[0].decodingOffset : 0;\n\t}\n\tleastCTTS = GF_INT_MAX;\n\tgreatestCTTS = 0;\n\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\tif (!ctts->version)\n\t\t\tctts->entries[i].decodingOffset -= shift;\n\n\t\tif ((s32)ctts->entries[i].decodingOffset < leastCTTS)\n\t\t\tleastCTTS = ctts->entries[i].decodingOffset;\n\t\tif ((s32)ctts->entries[i].decodingOffset > greatestCTTS)\n\t\t\tgreatestCTTS = ctts->entries[i].decodingOffset;\n\t}\n\tif (!ctts->version) {\n\t\tctts->version = 1;\n\t\t//if we had edit lists, shift all media times by the given amount\n\t\tif (trak->editBox && trak->editBox->editList) {\n\t\t\tfor (i=0; i<gf_list_count(trak->editBox->editList->entryList); i++) {\n\t\t\t\tGF_EdtsEntry *ent = (GF_EdtsEntry*)gf_list_get(trak->editBox->editList->entryList, i);\n\t\t\t\t//empty edit\n\t\t\t\tif (ent->mediaTime<0) continue;\n\t\t\t\tif (ent->mediaTime>=shift) ent->mediaTime -= shift;\n\t\t\t\telse ent->mediaTime = 0;\n\t\t\t\t//no offset and last entry, trash edit\n\t\t\t\tif (!ent->mediaTime && (gf_list_count(trak->editBox->editList->entryList)==1)) {\n\t\t\t\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->editBox);\n\t\t\t\t\ttrak->editBox = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSetTrackDuration(trak);\n\t\t}\n\t}\n\n\tif (!trak->Media->information->sampleTable->CompositionToDecode) {\n\t\ttrak->Media->information->sampleTable->CompositionToDecode = (GF_CompositionToDecodeBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_CSLG);\n\t\tif (!trak->Media->information->sampleTable->CompositionToDecode)\n\t\t\treturn GF_OUT_OF_MEM;\n\t}\n\n\tcslg = trak->Media->information->sampleTable->CompositionToDecode;\n\tif (cslg) {\n\t\tcslg->compositionToDTSShift = shift;\n\t\tcslg->leastDecodeToDisplayDelta = leastCTTS;\n\t\tcslg->greatestDecodeToDisplayDelta = greatestCTTS;\n\t\tcslg->compositionStartTime = 0;\n\t\t/*for our use case (first CTS set to 0), the composition end time is the media duration if it fits on 32 bits*/\n\t\tduration = gf_isom_get_media_duration(file, track);\n\t\tcslg->compositionEndTime = (duration<0x7FFFFFFF) ? (s32) duration : 0;\n\t}\n\n\tgf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_ISO4, GF_TRUE);\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_isom_set_ctts_v0(GF_ISOFile *file, GF_TrackBox *trak)\n{\n\tu32 i;\n\ts32 shift;\n\tGF_CompositionOffsetBox *ctts;\n\tGF_CompositionToDecodeBox *cslg;\n\n\tctts = trak->Media->information->sampleTable->CompositionOffset;\n\n\tif (!trak->Media->information->sampleTable->CompositionToDecode)\n\t{\n\t\tshift = 0;\n\t\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\t\tif (-ctts->entries[i].decodingOffset > shift)\n\t\t\t\tshift = -ctts->entries[i].decodingOffset;\n\t\t}\n\t\tif (shift > 0)\n\t\t{\n\t\t\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\t\t\ts64 new_ts = ctts->entries[i].decodingOffset;\n\t\t\t\tnew_ts += shift;\n\t\t\t\tctts->entries[i].decodingOffset = (s32) new_ts;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tcslg = trak->Media->information->sampleTable->CompositionToDecode;\n\t\tshift = cslg->compositionToDTSShift;\n\t\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\t\ts64 new_ts = ctts->entries[i].decodingOffset;\n\t\t\tnew_ts += shift;\n\t\t\tctts->entries[i].decodingOffset = (s32) new_ts;\n\t\t}\n\t\tgf_isom_box_del_parent(&trak->Media->information->sampleTable->child_boxes, (GF_Box *)cslg);\n\t\ttrak->Media->information->sampleTable->CompositionToDecode = NULL;\n\t}\n\tif (shift>0) {\n\t\t//no edits, insert one\n\t\tif (! trak->editBox) {\n\t\t\tu64 dur = trak->Media->mediaHeader->duration;\n\t\t\tdur *= file->moov->mvhd->timeScale;\n\t\t\tdur /= trak->Media->mediaHeader->timeScale;\n\t\t\tgf_isom_set_edit(file, gf_list_find(file->moov->trackList, trak)+1, 0, dur, shift, GF_ISOM_EDIT_NORMAL);\n\t\t} else {\n\t\t\t//otherwise shift media times in all entries\n\t\t\tfor (i=0; i<gf_list_count(trak->editBox->editList->entryList); i++) {\n\t\t\t\tGF_EdtsEntry *ent = (GF_EdtsEntry*)gf_list_get(trak->editBox->editList->entryList, i);\n\t\t\t\t//empty edit\n\t\t\t\tif (ent->mediaTime<0) continue;\n\t\t\t\tent->mediaTime += shift;\n\t\t\t}\n\t\t\tSetTrackDuration(trak);\n\t\t}\n\t}\n\tctts->version = 0;\n\tgf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_ISO4, GF_FALSE);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_composition_offset_mode(GF_ISOFile *file, u32 track, Bool use_negative_offsets)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_CompositionOffsetBox *ctts;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tctts = trak->Media->information->sampleTable->CompositionOffset;\n\tif (!ctts) {\n\t\tif (!use_negative_offsets && trak->Media->information->sampleTable->CompositionToDecode) {\n\t\t\tgf_isom_box_del_parent(&trak->Media->information->sampleTable->child_boxes, (GF_Box *)trak->Media->information->sampleTable->CompositionToDecode);\n\t\t\ttrak->Media->information->sampleTable->CompositionToDecode = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tif (use_negative_offsets) {\n\t\treturn gf_isom_set_ctts_v1(file, track, 0);\n\t} else {\n\t\tif (ctts->version==0) return GF_OK;\n\t\treturn gf_isom_set_ctts_v0(file, trak);\n\t}\n}\n\n#if 0 //unused\nGF_Err gf_isom_set_sync_table(GF_ISOFile *file, u32 track)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (!trak->Media->information->sampleTable->SyncSample) {\n\t\ttrak->Media->information->sampleTable->SyncSample = (GF_SyncSampleBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSS);\n\n\t\tif (!trak->Media->information->sampleTable->SyncSample)\n\t\t\treturn GF_OUT_OF_MEM;\n\t}\n\treturn GF_OK;\n}\n#endif\n\nGF_Err gf_isom_set_sample_flags(GF_ISOFile *file, u32 track, u32 sampleNumber, u32 isLeading, u32 dependsOn, u32 dependedOn, u32 redundant)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\treturn stbl_SetDependencyType(trak->Media->information->sampleTable, sampleNumber, isLeading, dependsOn, dependedOn, redundant);\n}\n\n#if 0 //unused\nGF_Err gf_isom_sample_set_dep_info(GF_ISOFile *file, u32 track, u32 sampleNumber, u32 isLeading, u32 dependsOn, u32 dependedOn, u32 redundant)\n{\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\treturn stbl_AddDependencyType(trak->Media->information->sampleTable, sampleNumber, isLeading, dependsOn, dependedOn, redundant);\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_copy_sample_info(GF_ISOFile *dst, u32 dst_track, GF_ISOFile *src, u32 src_track, u32 sampleNumber)\n{\n\tu32 i, count, idx, dst_sample_num, subs_flags;\n\tGF_SubSampleInfoEntry *sub_sample;\n\tGF_Err e;\n\tGF_TrackBox *src_trak, *dst_trak;\n\n\tsrc_trak = gf_isom_get_track_from_file(src, src_track);\n\tif (!src_trak) return GF_BAD_PARAM;\n\n\tdst_trak = gf_isom_get_track_from_file(dst, dst_track);\n\tif (!dst_trak) return GF_BAD_PARAM;\n\n\tdst_sample_num = dst_trak->Media->information->sampleTable->SampleSize->sampleCount;\n\n\t/*modify depends flags*/\n\tif (src_trak->Media->information->sampleTable->SampleDep) {\n\t\tu32 isLeading, dependsOn, dependedOn, redundant;\n\n\t\tisLeading = dependsOn = dependedOn = redundant = 0;\n\n\t\te = stbl_GetSampleDepType(src_trak->Media->information->sampleTable->SampleDep, sampleNumber, &isLeading, &dependsOn, &dependedOn, &redundant);\n\t\tif (e) return e;\n\n\t\te = stbl_AppendDependencyType(dst_trak->Media->information->sampleTable, isLeading, dependsOn, dependedOn, redundant);\n\t\tif (e) return e;\n\t}\n\n\t/*copy subsample info if any*/\n\tidx=1;\n\twhile (gf_isom_get_subsample_types(src, src_track, idx, &subs_flags)) {\n\t\tGF_SubSampleInformationBox *dst_subs=NULL;\n\t\tidx++;\n\n\t\tif ( ! gf_isom_sample_get_subsample_entry(src, src_track, sampleNumber, subs_flags, &sub_sample))\n\t\t\tcontinue;\n\n\t\t/*create subsample if needed*/\n\t\tif (!dst_trak->Media->information->sampleTable->sub_samples) {\n\t\t\tdst_trak->Media->information->sampleTable->sub_samples = gf_list_new();\n\t\t}\n\t\tcount = gf_list_count(dst_trak->Media->information->sampleTable->sub_samples);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tdst_subs = gf_list_get(dst_trak->Media->information->sampleTable->sub_samples, i);\n\t\t\tif (dst_subs->flags==subs_flags) break;\n\t\t\tdst_subs=NULL;\n\t\t}\n\t\tif (!dst_subs) {\n\t\t\tdst_subs = (GF_SubSampleInformationBox *) gf_isom_box_new_parent(&dst_trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_SUBS);\n\t\t\tif (!dst_subs) return GF_OUT_OF_MEM;\n\t\t\tdst_subs->version=0;\n\t\t\tdst_subs->flags = subs_flags;\n\t\t\tgf_list_add(dst_trak->Media->information->sampleTable->sub_samples, dst_subs);\n\t\t}\n\n\t\tcount = gf_list_count(sub_sample->SubSamples);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SubSampleEntry *entry = (GF_SubSampleEntry*)gf_list_get(sub_sample->SubSamples, i);\n\t\t\te = gf_isom_add_subsample_info(dst_subs, dst_sample_num, entry->subsample_size, entry->subsample_priority, entry->reserved, entry->discardable);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\n\t/*copy sampleToGroup info if any*/\n\tcount = 0;\n\tif (src_trak->Media->information->sampleTable->sampleGroups)\n\t\tcount = gf_list_count(src_trak->Media->information->sampleTable->sampleGroups);\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupBox *sg;\n\t\tu32 j, k, default_index;\n\t\tu32 first_sample_in_entry, last_sample_in_entry, group_desc_index_src, group_desc_index_dst;\n\t\tfirst_sample_in_entry = 1;\n\n\t\tsg = (GF_SampleGroupBox*)gf_list_get(src_trak->Media->information->sampleTable->sampleGroups, i);\n\t\tfor (j=0; j<sg->entry_count; j++) {\n\t\t\tGF_SampleGroupDescriptionBox *sgd_dst = NULL;\n\t\t\tlast_sample_in_entry = first_sample_in_entry + sg->sample_entries[j].sample_count - 1;\n\t\t\tif ((sampleNumber<first_sample_in_entry) || (sampleNumber>last_sample_in_entry)) {\n\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!dst_trak->Media->information->sampleTable->sampleGroups)\n\t\t\t\tdst_trak->Media->information->sampleTable->sampleGroups = gf_list_new();\n\n\t\t\tgroup_desc_index_src = group_desc_index_dst = sg->sample_entries[j].group_description_index;\n\n\t\t\tif (group_desc_index_src) {\n\t\t\t\tGF_SampleGroupDescriptionBox *sgd_src;\n\t\t\t\tvoid *sgde_src, *sgde_dst;\n\n\t\t\t\tgroup_desc_index_dst = 0;\n\t\t\t\t//check that the sample group description exists !!\n\t\t\t\tsgde_src = gf_isom_get_sample_group_info_entry(src, src_trak, sg->grouping_type, sg->sample_entries[j].group_description_index, &default_index, &sgd_src);\n\n\t\t\t\tif (!sgde_src) break;\n\n\t\t\t\tif (!dst_trak->Media->information->sampleTable->sampleGroupsDescription)\n\t\t\t\t\tdst_trak->Media->information->sampleTable->sampleGroupsDescription = gf_list_new();\n\n\t\t\t\tsgd_dst = NULL;\n\t\t\t\tfor (k=0; k< gf_list_count(dst_trak->Media->information->sampleTable->sampleGroupsDescription); k++) {\n\t\t\t\t\tsgd_dst = gf_list_get(dst_trak->Media->information->sampleTable->sampleGroupsDescription, k);\n\t\t\t\t\tif (sgd_dst->grouping_type==sgd_src->grouping_type) break;\n\t\t\t\t\tsgd_dst = NULL;\n\t\t\t\t}\n\t\t\t\tif (!sgd_dst) {\n\t\t\t\t\tgf_isom_clone_box( (GF_Box *) sgd_src, (GF_Box **) &sgd_dst);\n\t\t\t\t\tif (!sgd_dst) return GF_OUT_OF_MEM;\n\t\t\t\t\tgf_list_add(dst_trak->Media->information->sampleTable->sampleGroupsDescription, sgd_dst);\n\t\t\t\t\tgf_list_add(dst_trak->Media->information->sampleTable->child_boxes, sgd_dst);\n\t\t\t\t}\n\n\t\t\t\t//find the same entry\n\t\t\t\tfor (k=0; k<gf_list_count(sgd_dst->group_descriptions); k++) {\n\t\t\t\t\tsgde_dst = gf_list_get(sgd_dst->group_descriptions, k);\n\t\t\t\t\tif (gf_isom_is_identical_sgpd(sgde_src, sgde_dst, sgd_src->grouping_type)) {\n\t\t\t\t\t\tgroup_desc_index_dst = k+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!group_desc_index_dst) {\n\t\t\t\t\tGF_SampleGroupDescriptionBox *cloned=NULL;\n\t\t\t\t\tgf_isom_clone_box( (GF_Box *) sgd_src, (GF_Box **)  &cloned);\n\t\t\t\t\tif (!cloned) return GF_OUT_OF_MEM;\n\t\t\t\t\tsgde_dst = gf_list_get(cloned->group_descriptions, group_desc_index_dst);\n\t\t\t\t\tgf_list_rem(cloned->group_descriptions, group_desc_index_dst);\n\t\t\t\t\tgf_isom_box_del( (GF_Box *) cloned);\n\t\t\t\t\tgf_list_add(sgd_dst->group_descriptions, sgde_dst);\n\t\t\t\t\tgroup_desc_index_dst = gf_list_count(sgd_dst->group_descriptions);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_isom_get_sample_group_info_entry(dst, dst_trak, sg->grouping_type, 1, NULL, &sgd_dst);\n\t\t\t\tif (!sgd_dst) continue;\n\t\t\t}\n\n\t\t\t/*found our sample, add it to trak->sampleGroups*/\n\t\t\te = gf_isom_add_sample_group_entry(dst_trak->Media->information->sampleTable->sampleGroups, dst_sample_num, sgd_dst, sg->grouping_type_parameter, group_desc_index_dst, dst_trak->Media->information->sampleTable->child_boxes, NULL);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t//copy auxiliary info\n\tcount = gf_list_count(src_trak->Media->information->sampleTable->sai_sizes);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j;\n\t\tGF_SampleAuxiliaryInfoOffsetBox *saio = NULL;\n\t\tGF_SampleAuxiliaryInfoSizeBox *saiz = gf_list_get(src_trak->Media->information->sampleTable->sai_sizes, i);\n\n\t\tswitch (saiz->aux_info_type) {\n\t\tcase GF_ISOM_CENC_SCHEME:\n\t\tcase GF_ISOM_CBC_SCHEME:\n\t\tcase GF_ISOM_CENS_SCHEME:\n\t\tcase GF_ISOM_CBCS_SCHEME:\n\t\tcase GF_ISOM_PIFF_SCHEME:\n\t\tcase 0:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\t//no aux sample associated\n\t\tif (saiz->sample_count<sampleNumber) continue;\n\t\t//no size associated\n\t\tif (!saiz->default_sample_info_size && !saiz->sample_info_size[sampleNumber-1]) continue;\n\n\t\tfor (j=0; j<gf_list_count(src_trak->Media->information->sampleTable->sai_offsets); j++) {\n\t\t\tsaio = gf_list_get(src_trak->Media->information->sampleTable->sai_offsets, j);\n\t\t\tif ((saio->aux_info_type==saiz->aux_info_type) && (saio->aux_info_type_parameter==saiz->aux_info_type_parameter)) break;\n\t\t\tsaio=NULL;\n\t\t}\n\t\tif (!saio) continue;\n\t\tif (!saio->offsets && !saio->sai_data) continue;\n\n\t\tu64 offset = saio->offsets ? saio->offsets[0] : 0;\n\t\tu32 nb_saio = saio->entry_count;\n\t\tif ((nb_saio>1) && (saio->entry_count != saiz->sample_count)) continue;\n\n\t\tu32 size;\n\n\t\tif (nb_saio == 1) {\n\t\t\tfor (j=0; j < sampleNumber-1; j++) {\n\t\t\t\tsize = saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[j];\n\t\t\t\toffset += size;\n\t\t\t}\n\t\t} else {\n\t\t\toffset = saio->offsets[sampleNumber-1];\n\t\t}\n\n\t\tsize = saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[j];\n\n\t\tif (saio->sai_data) {\n\t\t\te = gf_isom_add_sample_aux_info_internal(dst_trak, NULL, j+1, saiz->aux_info_type, saiz->aux_info_type_parameter, saio->sai_data->data + offset, size);\n\t\t} else {\n\t\t\tu8 *sai = gf_malloc(size);\n\t\t\tif (!sai) return GF_OUT_OF_MEM;\n\n\t\t\tu64 cur_position = gf_bs_get_position(src_trak->moov->mov->movieFileMap->bs);\n\t\t\tgf_bs_seek(src_trak->moov->mov->movieFileMap->bs, offset);\n\n\t\t\tgf_bs_read_data(src_trak->moov->mov->movieFileMap->bs, sai, size);\n\t\t\tgf_bs_seek(src_trak->moov->mov->movieFileMap->bs, cur_position);\n\t\t\te = gf_isom_add_sample_aux_info_internal(dst_trak, NULL, j+1, saiz->aux_info_type, saiz->aux_info_type_parameter, sai, size);\n\t\t\tgf_free(sai);\n\t\t}\n\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isobmf] Failed to clone sai data: %s\\n\", gf_error_to_string(e) ));\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_set_display_flags(GF_ISOFile *file, u32 track, u32 desc_index, u32 flags, GF_TextFlagsMode op_type)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tfor (i=0; i < gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes); i++) {\n\t\tGF_Tx3gSampleEntryBox *txt;\n\t\tif (desc_index && (i+1 != desc_index)) continue;\n\n\t\ttxt = (GF_Tx3gSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\tif (txt->type != GF_ISOM_BOX_TYPE_TX3G) continue;\n\n\t\tswitch (op_type) {\n\t\tcase GF_ISOM_TEXT_FLAGS_TOGGLE:\n\t\t\ttxt->displayFlags |= flags;\n\t\t\tbreak;\n\t\tcase GF_ISOM_TEXT_FLAGS_UNTOGGLE:\n\t\t\ttxt->displayFlags &= ~flags;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttxt->displayFlags = flags;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_update_duration(GF_ISOFile *movie)\n{\n\tu32 i;\n\tu64 maxDur;\n\tGF_TrackBox *trak;\n\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\n\t//if file was open in Write or Edit mode, recompute the duration\n\t//the duration of a movie is the MaxDuration of all the tracks...\n\n\tmaxDur = 0;\n\ti=0;\n\twhile ((trak = (GF_TrackBox *)gf_list_enum(movie->moov->trackList, &i))) {\n\t\tif( (movie->LastError = SetTrackDuration(trak))\t) return movie->LastError;\n\t\tif (trak->Header && (trak->Header->duration > maxDur))\n\t\t\tmaxDur = trak->Header->duration;\n\t}\n\tmovie->moov->mvhd->duration = maxDur;\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_update_edit_list_duration(GF_ISOFile *file, u32 track)\n{\n\tu32 i;\n\tu64 trackDuration;\n\tGF_EdtsEntry *ent;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\n\t//the total duration is the media duration: adjust it in case...\n\te = Media_SetDuration(trak);\n\tif (e) return e;\n\n\t//assert the timeScales are non-NULL\n\tif (!trak->moov->mvhd->timeScale || !trak->Media->mediaHeader->timeScale) return GF_ISOM_INVALID_FILE;\n\ttrackDuration = (trak->Media->mediaHeader->duration * trak->moov->mvhd->timeScale) / trak->Media->mediaHeader->timeScale;\n\n\t//if we have an edit list, the duration is the sum of all the editList\n\t//entries' duration (always expressed in MovieTimeScale)\n\tif (trak->editBox && trak->editBox->editList) {\n\t\tu64 editListDuration = 0;\n\t\tGF_EditListBox *elst = trak->editBox->editList;\n\t\ti=0;\n\t\twhile ((ent = (GF_EdtsEntry*)gf_list_enum(elst->entryList, &i))) {\n\t\t\tif ((ent->mediaTime>=0) && (ent->mediaRate==0x10000) && (ent->segmentDuration > trackDuration))\n\t\t\t\tent->segmentDuration = trackDuration;\n\n\t\t\tif (!ent->segmentDuration) {\n\t\t\t\tu64 diff;\n\t\t\t\tent->segmentDuration = trackDuration;\n\t\t\t\tif (ent->mediaTime>0) {\n\t\t\t\t\tdiff = ent->mediaTime;\n\t\t\t\t\tdiff *= trak->moov->mvhd->timeScale;\n\t\t\t\t\tdiff /= trak->Media->mediaHeader->timeScale;\n\t\t\t\t\tif (diff < ent->segmentDuration)\n\t\t\t\t\t\tent->segmentDuration -= diff;\n\t\t\t\t\t/*\n\t\t\t\t\telse\n\t\t\t\t\t\tdiff = 0;\n\t\t\t\t\t*/\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((ent->mediaTime>=0) && ((u64) ent->mediaTime>=trak->Media->mediaHeader->duration)) {\n\t\t\t\tent->mediaTime = trak->Media->mediaHeader->duration;\n\t\t\t}\n\t\t\teditListDuration += ent->segmentDuration;\n\t\t}\n\t\ttrackDuration = editListDuration;\n\t}\n\tif (!trackDuration) {\n\t\ttrackDuration = (trak->Media->mediaHeader->duration * trak->moov->mvhd->timeScale) / trak->Media->mediaHeader->timeScale;\n\t}\n\ttrak->Header->duration = trackDuration;\n\n\treturn GF_OK;\n\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_clone_pssh(GF_ISOFile *output, GF_ISOFile *input, Bool in_moof) {\n\tGF_Box *a;\n\tu32 i;\n\ti = 0;\n\n\twhile ((a = (GF_Box *)gf_list_enum(input->moov->child_boxes, &i))) {\n\t\tif (a->type == GF_ISOM_BOX_TYPE_PSSH) {\n\t\t\tGF_List **child_boxes = &output->moov->child_boxes;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (in_moof)\n\t\t\t\tchild_boxes = &output->moof->child_boxes;\n#endif\n\n\t\t\tGF_ProtectionSystemHeaderBox *pssh = (GF_ProtectionSystemHeaderBox *)gf_isom_box_new_parent(child_boxes, GF_ISOM_BOX_TYPE_PSSH);\n\t\t\tif (!pssh) return GF_OUT_OF_MEM;\n\t\t\tmemmove(pssh->SystemID, ((GF_ProtectionSystemHeaderBox *)a)->SystemID, 16);\n\t\t\tif (((GF_ProtectionSystemHeaderBox *)a)->KIDs && ((GF_ProtectionSystemHeaderBox *)a)->KID_count > 0) {\n\t\t\t\tpssh->KID_count = ((GF_ProtectionSystemHeaderBox *)a)->KID_count;\n\t\t\t\tpssh->KIDs = (bin128 *)gf_malloc(pssh->KID_count*sizeof(bin128));\n\t\t\t\tif (!pssh->KIDs) return GF_OUT_OF_MEM;\n\t\t\t\tmemmove(pssh->KIDs, ((GF_ProtectionSystemHeaderBox *)a)->KIDs, pssh->KID_count*sizeof(bin128));\n\t\t\t}\n\t\t\tpssh->private_data_size = ((GF_ProtectionSystemHeaderBox *)a)->private_data_size;\n\t\t\tpssh->private_data = (u8 *)gf_malloc(pssh->private_data_size*sizeof(char));\n\t\t\tif (!pssh->private_data) return GF_OUT_OF_MEM;\n\t\t\tmemmove(pssh->private_data, ((GF_ProtectionSystemHeaderBox *)a)->private_data, pssh->private_data_size);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_group(GF_ISOFile *file, u32 track_number, u32 track_group_id, u32 group_type, Bool do_add)\n{\n\tu32 i, j;\n\tGF_TrackGroupTypeBox *trgt;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track_number);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->groups) trak->groups = (GF_TrackGroupBox*) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TRGR);\n\tif (!trak->groups) return GF_OUT_OF_MEM;\n\n\tfor (j=0; j<gf_list_count(file->moov->trackList); j++) {\n\t\tGF_TrackBox *a_trak = gf_list_get(file->moov->trackList, j);\n\t\tif (!a_trak->groups) continue;\n\n\t\tfor (i=0; i<gf_list_count(a_trak->groups->groups); i++) {\n\t\t\ttrgt = gf_list_get(a_trak->groups->groups, i);\n\n\t\t\tif (trgt->track_group_id==track_group_id) {\n\t\t\t\tif (trgt->group_type != group_type) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"A track with same group ID is already defined for different group type %s\\n\", gf_4cc_to_str(trgt->group_type) ));\n\t\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t\t}\n\t\t\t\tif (a_trak==trak) {\n\t\t\t\t\tif (!do_add) {\n\t\t\t\t\t\tgf_list_rem(trak->groups->groups, i);\n\t\t\t\t\t\tgf_isom_box_del_parent(&trak->groups->child_boxes, (GF_Box *)trgt);\n\t\t\t\t\t}\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//not found, add new group\n\ttrgt = (GF_TrackGroupTypeBox*) gf_isom_box_new_parent(&trak->groups->child_boxes, GF_ISOM_BOX_TYPE_TRGT);\n\tif (!trgt) return GF_OUT_OF_MEM;\n\ttrgt->track_group_id = track_group_id;\n\ttrgt->group_type = group_type;\n\treturn gf_list_add(trak->groups->groups, trgt);\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_nalu_length_field(GF_ISOFile *file, u32 track, u32 StreamDescriptionIndex, u32 nalu_size_length)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_MPEGVisualSampleEntryBox *ve;\n\tGF_SampleDescriptionBox *stsd;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd || !StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (!entry || ! gf_isom_is_nalu_based_entry(trak->Media, entry)) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tve = (GF_MPEGVisualSampleEntryBox*)entry;\n\tif (ve->avc_config) ve->avc_config->config->nal_unit_size = nalu_size_length;\n\tif (ve->svc_config) ve->svc_config->config->nal_unit_size = nalu_size_length;\n\tif (ve->hevc_config) ve->hevc_config->config->nal_unit_size = nalu_size_length;\n\tif (ve->lhvc_config) ve->lhvc_config->config->nal_unit_size = nalu_size_length;\n\tif (ve->vvc_config) ve->vvc_config->config->nal_unit_size = nalu_size_length;\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_set_sample_group_in_traf(GF_ISOFile *file)\n{\n\tGF_Err e;\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tfile->sample_groups_in_traf = GF_TRUE;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nvoid gf_isom_set_progress_callback(GF_ISOFile *file, void (*progress_cbk)(void *udta, u64 nb_done, u64 nb_total), void *progress_cbk_udta)\n{\n\tif (file) {\n\t\tfile->progress_cbk = progress_cbk;\n\t\tfile->progress_cbk_udta = progress_cbk_udta;\n\n\t}\n}\n\nGF_Err gf_isom_update_video_sample_entry_fields(GF_ISOFile *file, u32 track, u32 stsd_idx, u16 revision, u32 vendor, u32 temporalQ, u32 spatialQ, u32 horiz_res, u32 vert_res, u16 frames_per_sample, const char *compressor_name, s16 color_table_index)\n{\n\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *vid_ent;\n\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak || !stsd_idx) return GF_BAD_PARAM;\n\n\tif (!trak->Media || !trak->Media->handler || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleDescription)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_VISUAL:\n    case GF_ISOM_MEDIA_AUXV:\n    case GF_ISOM_MEDIA_PICT:\n    \tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\tvid_ent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, stsd_idx-1);\n\tif (!vid_ent)\n\t\treturn GF_BAD_PARAM;\n\n\tvid_ent->revision = revision;\n\tvid_ent->vendor = vendor;\n\tvid_ent->temporal_quality = temporalQ;\n\tvid_ent->spatial_quality = spatialQ;\n\tvid_ent->horiz_res = horiz_res;\n\tvid_ent->vert_res = vert_res;\n\tvid_ent->frames_per_sample = frames_per_sample;\n\tif (compressor_name)\n\t\tstrncpy(vid_ent->compressor_name, compressor_name, 32);\n\n\tvid_ent->color_table_index = color_table_index;\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_update_sample_description_from_template(GF_ISOFile *file, u32 track, u32 sampleDescriptionIndex, u8 *data, u32 size)\n{\n\tGF_BitStream *bs;\n\tGF_TrackBox *trak;\n\tGF_Box *ent, *tpl_ent;\n\tGF_Err e;\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak || !sampleDescriptionIndex) return GF_BAD_PARAM;\n\n\tif (!trak->Media || !trak->Media->handler || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleDescription)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex-1);\n\tif (!ent) return GF_BAD_PARAM;\n\n\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n//\te = gf_isom_box_parse(&tpl_ent, bs);\n\te = gf_isom_box_parse_ex(&tpl_ent, bs, GF_ISOM_BOX_TYPE_STSD, GF_FALSE, 0);\n\tgf_bs_del(bs);\n\tif (e) return e;\n\n\twhile (gf_list_count(tpl_ent->child_boxes)) {\n\t\tu32 j=0;\n\t\tBool found = GF_FALSE;\n\t\tGF_Box *abox = gf_list_pop_front(tpl_ent->child_boxes);\n\n\t\tswitch (abox->type) {\n\t\tcase GF_ISOM_BOX_TYPE_SINF:\n\t\tcase GF_ISOM_BOX_TYPE_RINF:\n\t\tcase GF_ISOM_BOX_TYPE_BTRT:\n\t\t\tfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (found) {\n\t\t\tgf_isom_box_del(abox);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (!ent->child_boxes) ent->child_boxes = gf_list_new();\n\t\tfor (j=0; j<gf_list_count(ent->child_boxes); j++) {\n\t\t\tGF_Box *b = gf_list_get(ent->child_boxes, j);\n\t\t\tif (b->type == abox->type) {\n\t\t\t\tfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tgf_list_add(ent->child_boxes, abox);\n\t\t} else {\n\t\t\tgf_isom_box_del(abox);\n\t\t}\n\t}\n\tgf_isom_box_del(tpl_ent);\n\n\t//patch for old export\n\tGF_Box *abox = gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\tif (abox) {\n\t\tgf_list_del_item(ent->child_boxes, abox);\n\t\tgf_list_add(ent->child_boxes, abox);\n\t}\n\treturn GF_OK;\n}\n\n\n#include <gpac/xml.h>\nGF_EXPORT\nGF_Err gf_isom_apply_box_patch(GF_ISOFile *file, GF_ISOTrackID globalTrackID, const char *box_patch_filename, Bool for_fragments)\n{\n\tGF_Err e;\n\tGF_DOMParser *dom;\n\tu32 i;\n\tGF_XMLNode *root;\n\tu8 *box_data=NULL;\n\tu32 box_data_size;\n\tif (!file || !box_patch_filename) return GF_BAD_PARAM;\n#ifdef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (for_fragments) return GF_NOT_SUPPORTED;\n#endif\n\tdom = gf_xml_dom_new();\n\tif (strstr(box_patch_filename, \"<?xml\")) {\n\t\te = gf_xml_dom_parse_string(dom, (char *) box_patch_filename);\n\t} else {\n\t\te = gf_xml_dom_parse(dom, box_patch_filename, NULL, NULL);\n\t}\n\tif (e) goto err_exit;\n\n\troot = gf_xml_dom_get_root(dom);\n\tif (!root || strcmp(root->name, \"GPACBOXES\")) {\n\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\tgoto err_exit;\n\t}\n\n\t//compute size of each child boxes to freeze the order\n\tif (for_fragments) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tu32 count = file->moof ? gf_list_count(file->moof->child_boxes) : 0;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_Box *box = gf_list_get(file->moof->child_boxes, i);\n\t\t\tif (!(box->internal_flags & GF_ISOM_ORDER_FREEZE)) {\n\t\t\t\tgf_isom_box_size(box);\n\t\t\t\tgf_isom_box_freeze_order(box);\n\t\t\t}\n\t\t}\n#endif\n\t} else {\n\t\tfor (i=0; i<gf_list_count(file->TopBoxes); i++) {\n\t\t\tGF_Box *box = gf_list_get(file->TopBoxes, i);\n\t\t\tif (!(box->internal_flags & GF_ISOM_ORDER_FREEZE)) {\n\t\t\t\tgf_isom_box_size(box);\n\t\t\t\tgf_isom_box_freeze_order(box);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i=0; i<gf_list_count(root->content); i++) {\n\t\tu32 j;\n\t\tu32 path_len;\n\t\tBool essential_prop=GF_FALSE;\n\t\tu32 trackID=globalTrackID;\n\t\tu32 item_id=trackID;\n\t\tBool is_frag_box;\n\t\tchar *box_path=NULL;\n\t\tGF_Box *parent_box = NULL;\n\t\tGF_XMLNode *box_edit = gf_list_get(root->content, i);\n\t\tif (!box_edit->name || strcmp(box_edit->name, \"Box\")) continue;\n\n\t\tfor (j=0; j<gf_list_count(box_edit->attributes);j++) {\n\t\t\tGF_XMLAttribute *att = gf_list_get(box_edit->attributes, j);\n\t\t\tif (!strcmp(att->name, \"path\")) box_path = att->value;\n\t\t\telse if (!strcmp(att->name, \"essential\")) {\n\t\t\t\tif (!strcmp(att->value, \"yes\") || !strcmp(att->value, \"true\") || !strcmp(att->value, \"1\")) {\n\t\t\t\t\tessential_prop=GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!strcmp(att->name, \"itemID\"))\n\t\t\t\titem_id = atoi(att->value);\n\t\t\telse if (!globalTrackID && !strcmp(att->name, \"trackID\"))\n\t\t\t\ttrackID = atoi(att->value);\n\t\t}\n\n\t\tif (!box_path) continue;\n\t\tpath_len = (u32) strlen(box_path);\n\n\t\tis_frag_box = !strncmp(box_path, \"traf\", 4) ? GF_TRUE : GF_FALSE;\n\n\t\tif (for_fragments && !is_frag_box) continue;\n\t\telse if (!for_fragments && is_frag_box) continue;\n\n\t\tgf_xml_parse_bit_sequence(box_edit, box_patch_filename, &box_data, &box_data_size);\n\t\tif (box_data_size && (box_data_size<4) ) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Wrong BS specification for box, shall either be empty or at least 4 bytes for box type\\n\"));\n\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tgoto err_exit;\n\t\t}\n\n\t\twhile (box_path && (path_len>=4)) {\n\t\t\tu32 parent_list_box_type;\n\t\t\tGF_List **parent_list;\n\t\t\tu32 box_type = GF_4CC(box_path[0],box_path[1],box_path[2],box_path[3]);\n\t\t\tGF_Box *box=NULL;\n\t\t\tGF_BitStream *bs;\n\t\t\ts32 insert_pos = -1;\n\t\t\tbox_path+=4;\n\t\t\tpath_len-=4;\n\n\t\t\tif (!parent_box) {\n\t\t\t\tbox=gf_isom_box_find_child(file->TopBoxes, box_type);\n\t\t\t\tif (!box) {\n\t\t\t\t\tif (box_type==GF_ISOM_BOX_TYPE_TRAK) {\n\t\t\t\t\t\tif (trackID) {\n\t\t\t\t\t\t\tbox = (GF_Box *) gf_isom_get_track_from_file(file, gf_isom_get_track_by_id(file, trackID) );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!box && gf_list_count(file->moov->trackList)==1) {\n\t\t\t\t\t\t\tbox = gf_list_get(file->moov->trackList, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\t\telse if (box_type==GF_ISOM_BOX_TYPE_TRAF) {\n\t\t\t\t\t\tif (trackID) {\n\t\t\t\t\t\t\tbox = (GF_Box *) gf_isom_get_traf(file, trackID);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!box && file->moof && gf_list_count(file->moof->TrackList)==1) {\n\t\t\t\t\t\t\tbox = gf_list_get(file->moof->TrackList, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\t\t\t\tif (!box) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Cannot locate box type %s at root or as track\\n\", gf_4cc_to_str(box_type) ));\n\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbox = gf_isom_box_find_child(parent_box->child_boxes, box_type);\n\t\t\t\tif (!box) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Cannot locate box type %s at child of %s\\n\", gf_4cc_to_str(box_type), gf_4cc_to_str(parent_box->type)));\n\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// '.' is child access\n\t\t\tif (path_len && (box_path[0]=='.')) {\n\t\t\t\tbox_path += 1;\n\t\t\t\tpath_len-=1;\n\t\t\t\tparent_box = box;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (parent_box && !parent_box->child_boxes) parent_box->child_boxes = gf_list_new();\n\t\t\tparent_list = parent_box ? &parent_box->child_boxes : &file->TopBoxes;\n\t\t\tparent_list_box_type = parent_box ? parent_box->type : 0;\n\n\t\t\t// '+' is append after, '-' is insert before\n\t\t\tif (path_len && ((box_path[0]=='-') || (box_path[0]=='+')) ) {\n\t\t\t\ts32 idx = gf_list_find(*parent_list, box);\n\t\t\t\tassert(idx>=0);\n\t\t\t\tif (box_path[0]=='+') insert_pos = idx+1;\n\t\t\t\telse insert_pos = idx;\n\t\t\t}\n\t\t\telse if (path_len) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Invalid path %s, expecting either '-', '+' or '.' as separators\\n\", box_path));\n\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\n\t\t\tif (!box_data) {\n\t\t\t\tif (insert_pos>=0) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[ISOBMFF] Invalid path %s for box removal, ignoring position\\n\", box_path));\n\t\t\t\t}\n\t\t\t\tswitch (box->type) {\n\t\t\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\t\t\t\tfile->moov = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\t\t\t\tfile->mdat = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n\t\t\t\t\tfile->pdin = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\t\t\t\tfile->brand = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\t\t\tif ((GF_Box *) file->meta == box) file->meta = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (parent_box) {\n\t\t\t\t\tgf_isom_box_remove_from_parent(parent_box, box);\n\t\t\t\t}\n\t\t\t\tgf_isom_box_del_parent(parent_list, box);\n\t\t\t} else {\n\t\t\t\tu32 size;\n\n\t\t\t\tbs = gf_bs_new(box_data, box_data_size, GF_BITSTREAM_READ);\n\t\t\t\tsize = gf_bs_read_u32(bs);\n\t\t\t\tif (size != box_data_size) {\n\t\t\t\t\tGF_UnknownBox *new_box = (GF_UnknownBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_UNKNOWN);\n\t\t\t\t\tnew_box->original_4cc = size;\n\t\t\t\t\tnew_box->dataSize = (u32) gf_bs_available(bs);\n\t\t\t\t\tnew_box->data = gf_malloc(sizeof(u8)*new_box->dataSize);\n\t\t\t\t\tgf_bs_read_data(bs, new_box->data, new_box->dataSize);\n\t\t\t\t\tif (insert_pos<0) {\n\t\t\t\t\t\tgf_list_add(box->child_boxes, new_box);\n\t\t\t\t\t\tinsert_pos = gf_list_find(box->child_boxes, new_box);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_list_insert(*parent_list, new_box, insert_pos);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (parent_box && (parent_box->type==GF_ISOM_BOX_TYPE_IPRP)) {\n\t\t\t\t\t\tGF_ItemPropertyAssociationBox *ipma = (GF_ItemPropertyAssociationBox *) gf_isom_box_find_child(parent_box->child_boxes, GF_ISOM_BOX_TYPE_IPMA);\n\t\t\t\t\t\tif (!item_id) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[ISOBMFF] Inserting box in ipco without itemID, no association added\\n\"));\n\t\t\t\t\t\t} else if (ipma) {\n\t\t\t\t\t\t\tu32 nb_asso, k;\n\t\t\t\t\t\t\tGF_ItemPropertyAssociationEntry *entry = NULL;\n\t\t\t\t\t\t\tnb_asso = gf_list_count(ipma->entries);\n\t\t\t\t\t\t\tfor (k=0; k<nb_asso;k++) {\n\t\t\t\t\t\t\t\tentry = gf_list_get(ipma->entries, k);\n\t\t\t\t\t\t\t\tif (entry->item_id==item_id) break;\n\t\t\t\t\t\t\t\tentry = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!entry) {\n\t\t\t\t\t\t\t\tGF_SAFEALLOC(entry, GF_ItemPropertyAssociationEntry);\n\t\t\t\t\t\t\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\t\t\t\t\t\t\tgf_list_add(ipma->entries, entry);\n\t\t\t\t\t\t\t\tentry->item_id = item_id;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tentry->associations = gf_realloc(entry->associations, sizeof(GF_ItemPropertyAssociationSlot) * (entry->nb_associations+1));\n\t\t\t\t\t\t\tentry->associations[entry->nb_associations].essential = essential_prop;\n\t\t\t\t\t\t\tentry->associations[entry->nb_associations].index = 1+insert_pos;\n\t\t\t\t\t\t\tentry->nb_associations++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tu32 box_idx = 0;\n\n\t\t\t\t\tgf_bs_seek(bs, 0);\n\t\t\t\t\twhile (gf_bs_available(bs)) {\n\t\t\t\t\t\tGF_Box *new_box;\n\t\t\t\t\t\te = gf_isom_box_parse_ex(&new_box, bs, (insert_pos<0) ? box->type : parent_list_box_type, parent_box ? GF_FALSE : GF_TRUE, 0);\n\t\t\t\t\t\tif (e) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] failed to parse box\\n\", box_path));\n\t\t\t\t\t\t\tgf_bs_del(bs);\n\t\t\t\t\t\t\tgoto err_exit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (insert_pos<0) {\n\t\t\t\t\t\t\tgf_list_add(box->child_boxes, new_box);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_list_insert(*parent_list, new_box, insert_pos+box_idx);\n\t\t\t\t\t\t\tbox_idx++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_bs_del(bs);\n\n\t\t\t}\n\t\t\tgf_free(box_data);\n\t\t\tbox_data = NULL;\n\t\t\tbox_path = NULL;\n\t\t}\n\t}\n\nerr_exit:\n\n\tgf_xml_dom_del(dom);\n\tif (box_data) gf_free(box_data);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_magic(GF_ISOFile *movie, u32 trackNumber, u64 magic)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\ttrak->magic = magic;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_index(GF_ISOFile *movie, u32 trackNumber, u32 index, void (*track_num_changed)(void *udta, u32 old_track_num, u32 new_track_num), void *udta)\n{\n\tu32 i, j, count;\n\tGF_List *tracks;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !index) return GF_BAD_PARAM;\n\ttrak->index = index;\n\ttracks = gf_list_new();\n\tcount = gf_list_count(movie->moov->trackList);\n\t//sort tracks in new list\n\tfor (i=0; i<count; i++) {\n\t\tGF_TrackBox *a_tk = gf_list_get(movie->moov->trackList, i);\n\t\tif (!a_tk->index) {\n\t\t\tgf_list_insert(tracks, a_tk, 0);\n\t\t} else {\n\t\t\tfor (j=0; j<gf_list_count(tracks); j++) {\n\t\t\t\tGF_TrackBox *a_tki = gf_list_get(tracks, j);\n\t\t\t\tif (a_tki->index<a_tk->index) continue;\n\t\t\t\tgf_list_insert(tracks, a_tk, j);\n\t\t\t\ta_tk = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (a_tk)\n\t\t\t\tgf_list_add(tracks, a_tk);\n\t\t}\n\t}\n\tif (gf_list_count(tracks) != count) {\n\t\tgf_list_del(tracks);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tif (track_num_changed) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_TrackBox *a_tk = gf_list_get(tracks, i);\n\t\t\ts32 old_pos = gf_list_find(movie->moov->trackList, a_tk);\n\t\t\tassert(old_pos>=0);\n\t\t\tif (old_pos != i)\n\t\t\t\ttrack_num_changed(udta, old_pos+1, i+1);\n\t\t}\n\t}\n\tgf_list_del(movie->moov->trackList);\n\tmovie->moov->trackList = tracks;\n\tfor (j=0; j<gf_list_count(tracks); j++) {\n\t\tGF_TrackBox *tki = gf_list_get(tracks, j);\n\t\tif (tki->index != 0xFFFE) // special value meaning always last\n\t\t\ttki->index = j + 1;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_ipod_compatible(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\tif (!entry) return GF_OK;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_OK;\n\t}\n\n\tif (!entry->ipod_ext) {\n\t\tentry->ipod_ext = (GF_UnknownUUIDBox *) gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_UUID);\n\t\tif (!entry->ipod_ext) return GF_OUT_OF_MEM;\n\t}\n\tmemcpy(entry->ipod_ext->uuid, GF_ISOM_IPOD_EXT, sizeof(u8)*16);\n\tentry->ipod_ext->dataSize = 4;\n\tentry->ipod_ext->data = gf_malloc(sizeof(u8)*4);\n\tif (!entry->ipod_ext->data) return GF_OUT_OF_MEM;\n\tmemset(entry->ipod_ext->data, 0, sizeof(u8)*4);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nBool gf_isom_is_inplace_rewrite(GF_ISOFile *movie)\n{\n\tif (!movie) return GF_FALSE;\n\tif (!movie->no_inplace_rewrite) {\n\t\t//things where added to the file, no inplace rewrite\n\t\tif (movie->editFileMap && gf_bs_get_size(movie->editFileMap->bs))\n\t\t\tmovie->no_inplace_rewrite = GF_TRUE;\n\t\t//block redirect (used by mp4mx), no inplace rewrite\n\t\telse if (movie->on_block_out || !strcmp(movie->finalName, \"_gpac_isobmff_redirect\"))\n\t\t\tmovie->no_inplace_rewrite = GF_TRUE;\n\t\t//stdout redirect, no inplace rewrite\n\t\telse if (!strcmp(movie->finalName, \"std\"))\n\t\t\tmovie->no_inplace_rewrite = GF_TRUE;\n\t\t//new file, no inplace rewrite\n\t\telse if (!movie->fileName)\n\t\t\tmovie->no_inplace_rewrite = GF_TRUE;\n\t}\n\tif (movie->no_inplace_rewrite) return GF_FALSE;\n\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nvoid gf_isom_disable_inplace_rewrite(GF_ISOFile *movie)\n{\n\tif (movie)\n\t\tmovie->no_inplace_rewrite = GF_TRUE;\n}\n\n\nGF_Err gf_isom_set_y3d_info(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescriptionIndex, GF_ISOM_Y3D_Info *info)\n{\n\tGF_Err e;\n\tu32 proj_type;\n\tGF_SampleEntryBox *ent;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !info) return GF_BAD_PARAM;\n\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex-1);\n\tif (!ent) return GF_BAD_PARAM;\n\n\tif (info->projection_type > GF_PROJ360_EQR) return GF_NOT_SUPPORTED;\n\n\tGF_Stereo3DBox *st3d = (GF_Stereo3DBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\tif (st3d) {\n\t\tif (info->stereo_type) {\n\t\t\tst3d->stereo_type = info->stereo_type;\n\t\t} else {\n\t\t\tgf_isom_box_del_parent(&ent->child_boxes, (GF_Box *) st3d);\n\t\t}\n\t} else if (info->stereo_type) {\n\t\tst3d = (GF_Stereo3DBox *) gf_isom_box_new_parent(&ent->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\t\tif (!st3d) return GF_OUT_OF_MEM;\n\t\tst3d->stereo_type = info->stereo_type;\n\t}\n\n\n\tGF_Box *sv3d = gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\tif (sv3d && !info->projection_type) {\n\t\tgf_isom_box_del_parent(&ent->child_boxes, sv3d);\n\t\treturn GF_OK;\n\t}\n\n\tif (!sv3d && !info->projection_type) {\n\t\treturn GF_OK;\n\t}\n\tif (!sv3d) {\n\t\tsv3d = gf_isom_box_new_parent(&ent->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\t\tif (!sv3d) return GF_OUT_OF_MEM;\n\t}\n\n\t//svhd mandatory\n\tGF_SphericalVideoInfoBox *svhd = (GF_SphericalVideoInfoBox *) gf_isom_box_find_child(sv3d->child_boxes, GF_ISOM_BOX_TYPE_SVHD);\n\tif (svhd) {\n\t\tif (svhd->string) gf_free(svhd->string);\n\t} else {\n\t\tsvhd = (GF_SphericalVideoInfoBox *) gf_isom_box_new_parent(&sv3d->child_boxes, GF_ISOM_BOX_TYPE_SVHD);\n\t\tif (!svhd) return GF_OUT_OF_MEM;\n\t}\n\tsvhd->string = gf_strdup(info->meta_data ? info->meta_data : \"\");\n\n\t//proj mandatory\n\tGF_Box *proj = gf_isom_box_find_child(sv3d->child_boxes, GF_ISOM_BOX_TYPE_PROJ);\n\tif (!proj) {\n\t\tproj = gf_isom_box_new_parent(&sv3d->child_boxes, GF_ISOM_BOX_TYPE_PROJ);\n\t\tif (!proj) return GF_OUT_OF_MEM;\n\t}\n\n\tGF_ProjectionHeaderBox *projh = (GF_ProjectionHeaderBox *) gf_isom_box_find_child(proj->child_boxes, GF_ISOM_BOX_TYPE_PRHD);\n\t//prj header mandatory\n\tif (!projh) {\n\t\tprojh = (GF_ProjectionHeaderBox *) gf_isom_box_new_parent(&proj->child_boxes, GF_ISOM_BOX_TYPE_PRHD);\n\t\tif (!projh) return GF_OUT_OF_MEM;\n\t}\n\tprojh->yaw = info->yaw;\n\tprojh->pitch = info->pitch;\n\tprojh->roll = info->roll;\n\n\tproj_type = (info->projection_type==GF_PROJ360_CUBE_MAP) ? GF_ISOM_BOX_TYPE_CBMP : GF_ISOM_BOX_TYPE_EQUI;\n\n\tGF_ProjectionTypeBox *projt = (GF_ProjectionTypeBox *) gf_isom_box_find_child(proj->child_boxes, proj_type);\n\tif (!projt) {\n\t\tprojt = (GF_ProjectionTypeBox *) gf_isom_box_new_parent(&proj->child_boxes, proj_type);\n\t\tif (!projt) return GF_OUT_OF_MEM;\n\t}\n\tif (info->projection_type==GF_PROJ360_CUBE_MAP) {\n\t\tprojt->layout = info->layout;\n\t\tprojt->padding = info->padding;\n\t} else {\n\t\tprojt->bounds_top = info->top;\n\t\tprojt->bounds_bottom = info->bottom;\n\t\tprojt->bounds_left = info->left;\n\t\tprojt->bounds_right = info->right;\n\t}\n\n\t//remove other ones\n\tGF_Box *b = gf_isom_box_new_parent(&proj->child_boxes, GF_ISOM_BOX_TYPE_MSHP);\n\tif (b) gf_isom_box_del_parent(&proj->child_boxes, b);\n\tif (info->projection_type==GF_PROJ360_CUBE_MAP) {\n\t\tb = gf_isom_box_new_parent(&proj->child_boxes, GF_ISOM_BOX_TYPE_EQUI);\n\t\tif (b) gf_isom_box_del_parent(&proj->child_boxes, b);\n\t} else {\n\t\tb = gf_isom_box_new_parent(&proj->child_boxes, GF_ISOM_BOX_TYPE_EQUI);\n\t\tif (b) gf_isom_box_del_parent(&proj->child_boxes, b);\n\n\t}\n\treturn GF_OK;\n}\n\n#endif //!defined(GPAC_DISABLE_ISOM_WRITE)\n\n#ifndef GPAC_DISABLE_ISOM\n\nGF_Err gf_isom_add_sample_aux_info_internal(GF_TrackBox *trak, void *_traf, u32 sampleNumber, u32 aux_type, u32 aux_info, u8 *data, u32 size)\n{\n\tu32 i, count;\n\tGF_List **child_box_cont, **child_box_sai, **child_box_saiz, **child_box_saio;\n\tGF_UnknownBox *sai_cont = NULL;\n\n\tif (!trak && !_traf) return GF_BAD_PARAM;\n\n\tif (trak) {\n\t\tchild_box_cont = &trak->child_boxes;\n\t\tchild_box_sai = &trak->Media->information->sampleTable->child_boxes;\n\t\tchild_box_saiz = &trak->Media->information->sampleTable->sai_sizes;\n\t\tchild_box_saio = &trak->Media->information->sampleTable->sai_offsets;\n\t} else {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tGF_TrackFragmentBox *traf = (GF_TrackFragmentBox *)_traf;\n\n\t\tchild_box_cont = &traf->child_boxes;\n\t\tchild_box_sai = &traf->child_boxes;\n\t\tchild_box_saiz = &traf->sai_sizes;\n\t\tchild_box_saio = &traf->sai_offsets;\n#endif\n\t}\n\n\tcount = gf_list_count(*child_box_cont);\n\tfor (i=0; i<count; i++) {\n\t\tGF_UnknownBox *unkn = gf_list_get(*child_box_cont, i);\n\t\tif (unkn->type != GF_ISOM_BOX_TYPE_UNKNOWN) continue;\n\t\tif (unkn->original_4cc != GF_ISOM_BOX_TYPE_GDAT) continue;\n\t\tif (unkn->sai_type != aux_type) continue;\n\t\tif (unkn->sai_aux_info != aux_info) continue;\n\t\tsai_cont = unkn;\n\t\tbreak;\n\t}\n\tif (!sai_cont) {\n\t\tsai_cont = (GF_UnknownBox *) gf_isom_box_new_parent(child_box_cont, GF_ISOM_BOX_TYPE_UNKNOWN);\n\t\tif (!sai_cont) return GF_OUT_OF_MEM;\n\t\tsai_cont->original_4cc = GF_ISOM_BOX_TYPE_GDAT;\n\t\tsai_cont->sai_type = aux_type;\n\t\tsai_cont->sai_aux_info = aux_info;\n\t}\n\tsai_cont->data = gf_realloc(sai_cont->data, (size+sai_cont->dataSize));\n\tif (!sai_cont->data) return GF_OUT_OF_MEM;\n\tmemcpy(sai_cont->data+sai_cont->dataSize, data, size);\n\tsai_cont->dataSize += size;\n\n\tGF_SampleAuxiliaryInfoSizeBox *saiz=NULL;\n\tGF_SampleAuxiliaryInfoOffsetBox *saio=NULL;\n\tcount = gf_list_count(*child_box_saiz);\n\tfor (i=0; i<count; i++) {\n\t\tsaiz = gf_list_get(*child_box_saiz, i);\n\t\tif ((saiz->aux_info_type==aux_type) && (saiz->aux_info_type_parameter==aux_info)) break;\n\t\tsaiz = NULL;\n\t}\n\tif (!saiz) {\n\t\tsaiz = (GF_SampleAuxiliaryInfoSizeBox *) gf_isom_box_new_parent(child_box_sai, GF_ISOM_BOX_TYPE_SAIZ);\n\t\tif (!saiz) return GF_OUT_OF_MEM;\n\t\tif (! *child_box_saiz) *child_box_saiz = gf_list_new();\n\t\tgf_list_add(*child_box_saiz, saiz);\n\n\t\tsaiz->aux_info_type = aux_type;\n\t\tsaiz->aux_info_type_parameter = aux_info;\n\t}\n\n\tif (saiz->sample_count >= sampleNumber)\n\t\treturn GF_BAD_PARAM;\n\n\tif ( (!saiz->sample_count && (sampleNumber==1))\n\t\t|| ((saiz->default_sample_info_size==size) && size)\n\t) {\n\t\tsaiz->sample_count ++;\n\t\tsaiz->default_sample_info_size = size;\n\t} else {\n\t\tif (sampleNumber > saiz->sample_alloc) {\n\t\t\tsaiz->sample_alloc = sampleNumber+10;\n\t\t\tsaiz->sample_info_size = (u8*)gf_realloc(saiz->sample_info_size, sizeof(u8)*(saiz->sample_alloc));\n\t\t}\n\n\t\tif (saiz->default_sample_info_size) {\n\t\t\tfor (i=0; i<saiz->sample_count; i++)\n\t\t\t\tsaiz->sample_info_size[i] = saiz->default_sample_info_size;\n\t\t\tsaiz->default_sample_info_size = 0;\n\t\t}\n\t\tfor (i=saiz->sample_count; i<sampleNumber-1; i++)\n\t\t\tsaiz->sample_info_size[i] = 0;\n\n\t\tsaiz->sample_info_size[sampleNumber-1] = size;\n\t\tsaiz->sample_count = sampleNumber;\n\t}\n\n\n\tcount = gf_list_count(*child_box_saio);\n\tfor (i=0; i<count; i++) {\n\t\tsaio = gf_list_get(*child_box_saio, i);\n\t\tif ((saio->aux_info_type==aux_type) && (saio->aux_info_type_parameter==aux_info)) break;\n\t\tsaio = NULL;\n\t}\n\tif (!saio) {\n\t\tsaio = (GF_SampleAuxiliaryInfoOffsetBox *) gf_isom_box_new_parent(child_box_sai, GF_ISOM_BOX_TYPE_SAIO);\n\t\tif (!saio) return GF_OUT_OF_MEM;\n\t\tif (! *child_box_saio) *child_box_saio = gf_list_new();\n\t\tgf_list_add(*child_box_saio, saio);\n\t\tsaio->aux_info_type = aux_type;\n\t\tsaio->aux_info_type_parameter = aux_info;\n\t}\n\tif (!saio->sai_data) saio->sai_data = sai_cont;\n\tsaio->version = 1;\n\tsaio->entry_count = 1;\n\n\treturn GF_OK;\n}\n#endif // GPAC_DISABLE_ISOM\n\n\n#if !defined(GPAC_DISABLE_ISOM_WRITE)\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nGF_Err gf_isom_fragment_set_sample_aux_info(GF_ISOFile *movie, u32 trackID, u32 sample_number_in_frag, u32 aux_type, u32 aux_info, u8 *data, u32 size)\n{\n\tGF_TrackFragmentBox *traf;\n\tif (!movie || !movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) return GF_BAD_PARAM;\n\n\ttraf = gf_isom_get_traf(movie, trackID);\n\tif (!traf) return GF_BAD_PARAM;\n\treturn gf_isom_add_sample_aux_info_internal(NULL, traf, sample_number_in_frag, aux_type, aux_info, data, size);\n}\n#endif\n\nGF_Err gf_isom_add_sample_aux_info(GF_ISOFile *file, u32 track, u32 sampleNumber, u32 aux_type, u32 aux_info, u8 *data, u32 size)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\treturn gf_isom_add_sample_aux_info_internal(trak, NULL, sampleNumber, aux_type, aux_info, data, size);\n}\n\n\nGF_Err gf_isom_set_meta_qt(GF_ISOFile *file)\n{\n\tu32 i, count;\n\tif (!file) return GF_BAD_PARAM;\n\tGF_Err e = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\tif (file->moov->meta)\n\t\tfile->moov->meta->write_qt = 1;\n\n\tcount = gf_list_count(file->moov->trackList);\n\tfor (i=0; i<count; i++) {\n\t\tGF_TrackBox *trak = gf_list_get(file->moov->trackList, i);\n\t\tif (trak->meta)\n\t\t\ttrak->meta->write_qt = 1;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_mpegh_compatible_profiles(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescIndex, const u32 *profiles, u32 nb_compat_profiles)\n{\n\tu32 i, type;\n\tGF_SampleEntryBox *ent;\n\tGF_MHACompatibleProfilesBox *mhap;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescIndex-1);\n\tif (!ent) return GF_BAD_PARAM;\n\ttype = ent->type;\n\tif (type==GF_ISOM_BOX_TYPE_GNRA)\n\t\ttype = ((GF_GenericAudioSampleEntryBox *)ent)->EntryType;\n\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_MHA1:\n\tcase GF_ISOM_BOX_TYPE_MHA2:\n\tcase GF_ISOM_BOX_TYPE_MHM1:\n\tcase GF_ISOM_BOX_TYPE_MHM2:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\tmhap = (GF_MHACompatibleProfilesBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_MHAP);\n\tif (!mhap) {\n\t\tif (! profiles || !nb_compat_profiles) return GF_OK;\n\t\tmhap = (GF_MHACompatibleProfilesBox *) gf_isom_box_new_parent(&ent->child_boxes, GF_ISOM_BOX_TYPE_MHAP);\n\t} else if (! profiles || !nb_compat_profiles) {\n\t\tgf_isom_box_del_parent(&ent->child_boxes, (GF_Box*)mhap);\n\t\treturn GF_OK;\n\t}\n\tif (mhap->compat_profiles) gf_free(mhap->compat_profiles);\n\tmhap->compat_profiles = gf_malloc(sizeof(u8) * nb_compat_profiles);\n\tif (!mhap->compat_profiles) return GF_OUT_OF_MEM;\n\tfor (i=0; i<nb_compat_profiles; i++) {\n\t\tmhap->compat_profiles[i] = (u8) profiles[i];\n\t}\n\tmhap->num_profiles = nb_compat_profiles;\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_set_sample_description_restricted(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescIndex, u32 scheme_type)\n{\n\tu32 type;\n\tGF_SampleEntryBox *ent;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescIndex-1);\n\tif (!ent) return GF_BAD_PARAM;\n\ttype = ent->type;\n\n\tu32 original_format = type;\n\tu32 gnr_type=0;\n\tif (original_format==GF_ISOM_BOX_TYPE_GNRA) {\n\t\tgnr_type = original_format;\n\t\ttype = ((GF_GenericAudioSampleEntryBox*)ent)->EntryType;\n\t} else if (original_format==GF_ISOM_BOX_TYPE_GNRV) {\n\t\tgnr_type = original_format;\n\t\ttype = ((GF_GenericVisualSampleEntryBox*)ent)->EntryType;\n\t} else if (original_format==GF_ISOM_BOX_TYPE_GNRM) {\n\t\tgnr_type = original_format;\n\t\ttype = ((GF_GenericSampleEntryBox*)ent)->EntryType;\n\t}\n\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_RESV:\n\tcase GF_ISOM_BOX_TYPE_RESA:\n\tcase GF_ISOM_BOX_TYPE_RESM:\n\tcase GF_ISOM_BOX_TYPE_REST:\n\tcase GF_ISOM_BOX_TYPE_RESU:\n\tcase GF_ISOM_BOX_TYPE_RESS:\n\tcase GF_ISOM_BOX_TYPE_RESF:\n\tcase GF_ISOM_BOX_TYPE_RESP:\n\tcase GF_ISOM_BOX_TYPE_RES3:\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_STXT:\n\t\ttype = GF_ISOM_BOX_TYPE_REST;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STPP:\n\t\ttype = GF_ISOM_BOX_TYPE_RESU;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_METX:\n\tcase GF_ISOM_BOX_TYPE_METT:\n\tcase GF_ISOM_BOX_TYPE_URIM:\n\tcase GF_ISOM_BOX_TYPE_MEBX:\n\t\ttype = GF_ISOM_BOX_TYPE_RESM;\n\t\tbreak;\n\tdefault:\n\t\ttype=0;\n\t\tswitch (trak->Media->handler->handlerType) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t\ttype = GF_ISOM_BOX_TYPE_RESV;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\ttype = GF_ISOM_BOX_TYPE_RESA;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\tcase GF_ISOM_MEDIA_OCR:\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\tcase GF_ISOM_MEDIA_MPEG7:\n\t\tcase GF_ISOM_MEDIA_OCI:\n\t\tcase GF_ISOM_MEDIA_IPMP:\n\t\tcase GF_ISOM_MEDIA_MPEGJ:\n\t\t\ttype = GF_ISOM_BOX_TYPE_RESS;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tif (!type) return GF_NOT_SUPPORTED;\n\n\tGF_ProtectionSchemeInfoBox *rinf;\n\trinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_RINF);\n\tif (rinf) gf_isom_box_del_parent(&ent->child_boxes, (GF_Box *)rinf);\n\n\trinf = (GF_ProtectionSchemeInfoBox *)gf_isom_box_new_parent(&ent->child_boxes, GF_ISOM_BOX_TYPE_RINF);\n\tif (!rinf) return GF_OUT_OF_MEM;\n\n\n\trinf->original_format = (GF_OriginalFormatBox *)gf_isom_box_new_parent(&rinf->child_boxes, GF_ISOM_BOX_TYPE_FRMA);\n\tif (!rinf->original_format) return GF_OUT_OF_MEM;\n\tif (gnr_type) {\n\t\trinf->original_format->data_format = gnr_type;\n\t\trinf->original_format->gnr_type = original_format;\n\t} else {\n\t\trinf->original_format->data_format = original_format;\n\t}\n\t//common to isma, cenc and oma\n\trinf->scheme_type = (GF_SchemeTypeBox *)gf_isom_box_new_parent(&rinf->child_boxes, GF_ISOM_BOX_TYPE_SCHM);\n\tif (!rinf->scheme_type) return GF_OUT_OF_MEM;\n\trinf->scheme_type->scheme_type  = scheme_type;\n\n\tent->type = type;\n\treturn GF_OK;\n}\n\n\n#endif\t/*!defined(GPAC_DISABLE_ISOM) && !defined(GPAC_DISABLE_ISOM_WRITE)*/\n\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/constants.h>\n#include <gpac/iso639.h>\n\n\n#if !defined(GPAC_DISABLE_ISOM) && !defined(GPAC_DISABLE_ISOM_WRITE)\n\nGF_Err CanAccessMovie(GF_ISOFile *movie, GF_ISOOpenMode Mode)\n{\n\tif (!movie) return GF_BAD_PARAM;\n\tif (movie->openMode < Mode) return GF_ISOM_INVALID_MODE;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) return GF_ISOM_INVALID_MODE;\n#endif\n\treturn GF_OK;\n}\n\nstatic GF_Err unpack_track(GF_TrackBox *trak)\n{\n\tGF_Err e = GF_OK;\n\tif (!trak->is_unpacked) {\n\t\te = stbl_UnpackOffsets(trak->Media->information->sampleTable);\n\t\tif (e) return e;\n\t\te = stbl_unpackCTS(trak->Media->information->sampleTable);\n\t\ttrak->is_unpacked = GF_TRUE;\n\t}\n\treturn e;\n}\n\n\nGF_Err FlushCaptureMode(GF_ISOFile *movie)\n{\n\tGF_Err e;\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) {\n\t\tif (!movie->editFileMap) return GF_ISOM_INVALID_MODE;\n\t\treturn GF_OK;\n\t}\n\t/*make sure nothing was added*/\n\tif (gf_bs_get_position(movie->editFileMap->bs)) return GF_OK;\n\n\tif (!strcmp(movie->fileName, \"_gpac_isobmff_redirect\")) {\n\t\tif (!movie->on_block_out) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Missing output block callback, cannot write\\n\"));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\n\t\tgf_bs_del(movie->editFileMap->bs);\n\t\tmovie->editFileMap->bs = gf_bs_new_cbk(isom_on_block_out, movie, movie->on_block_out_block_size);\n\t}\n\n\t/*add all first boxes*/\n\tif (movie->brand) {\n\t\te = gf_isom_box_size((GF_Box *)movie->brand);\n\t\tif (e) return e;\n\t\te = gf_isom_box_write((GF_Box *)movie->brand, movie->editFileMap->bs);\n\t\tif (e) return e;\n\t}\n\tif (movie->pdin) {\n\t\te = gf_isom_box_size((GF_Box *)movie->pdin);\n\t\tif (e) return e;\n\t\te = gf_isom_box_write((GF_Box *)movie->pdin, movie->editFileMap->bs);\n\t\tif (e) return e;\n\t}\n\tmovie->mdat->bsOffset = gf_bs_get_position(movie->editFileMap->bs);\n\n\t/*we have a trick here: the data will be stored on the fly, so the first\n\tthing in the file is the MDAT. As we don't know if we have a large file (>4 GB) or not\n\tdo as if we had one and write 16 bytes: 4 (type) + 4 (size) + 8 (largeSize)...*/\n\tgf_bs_write_long_int(movie->editFileMap->bs, 0, 64);\n\tgf_bs_write_long_int(movie->editFileMap->bs, 0, 64);\n\treturn GF_OK;\n}\n\nstatic GF_Err CheckNoData(GF_ISOFile *movie)\n{\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) return GF_OK;\n\tif (gf_bs_get_position(movie->editFileMap->bs)) return GF_BAD_PARAM;\n\treturn GF_OK;\n}\n\n/**************************************************************\n\t\t\t\t\tFile Writing / Editing\n**************************************************************/\n//quick function to add an IOD/OD to the file if not present (iods is optional)\nGF_Err AddMovieIOD(GF_MovieBox *moov, u8 isIOD)\n{\n\tGF_Descriptor *od;\n\tGF_ObjectDescriptorBox *iods;\n\n\t//do we have an IOD ?? If not, create one.\n\tif (moov->iods) return GF_OK;\n\n\tif (isIOD) {\n\t\tod = gf_odf_desc_new(GF_ODF_ISOM_IOD_TAG);\n\t} else {\n\t\tod = gf_odf_desc_new(GF_ODF_ISOM_OD_TAG);\n\t}\n\tif (!od) return GF_OUT_OF_MEM;\n\t((GF_IsomObjectDescriptor *)od)->objectDescriptorID = 1;\n\n\tiods = (GF_ObjectDescriptorBox *) gf_isom_box_new_parent(&moov->child_boxes, GF_ISOM_BOX_TYPE_IODS);\n\tif (!iods) return GF_OUT_OF_MEM;\n\tiods->descriptor = od;\n\treturn moov_on_child_box((GF_Box*)moov, (GF_Box *)iods, GF_FALSE);\n}\n\n//add a track to the root OD\nGF_EXPORT\nGF_Err gf_isom_add_track_to_root_od(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_Err e;\n\tGF_ES_ID_Inc *inc;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (!movie->moov->iods) AddMovieIOD(movie->moov, 0);\n\n\tif (gf_isom_is_track_in_root_od(movie, trackNumber) == 1) return GF_OK;\n\n\tinc = (GF_ES_ID_Inc *) gf_odf_desc_new(GF_ODF_ESD_INC_TAG);\n\tinc->trackID = gf_isom_get_track_id(movie, trackNumber);\n\tif (!inc->trackID) {\n\t\tgf_odf_desc_del((GF_Descriptor *)inc);\n\t\treturn movie->LastError;\n\t}\n\tif ( (movie->LastError = gf_isom_add_desc_to_root_od(movie, (GF_Descriptor *)inc) ) ) {\n\t\treturn movie->LastError;\n\t}\n\tgf_odf_desc_del((GF_Descriptor *)inc);\n\treturn GF_OK;\n}\n\n//remove the root OD\nGF_EXPORT\nGF_Err gf_isom_remove_root_od(GF_ISOFile *movie)\n{\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\tif (!movie->moov || !movie->moov->iods) return GF_OK;\n\tgf_isom_box_del_parent(&movie->moov->child_boxes, (GF_Box *)movie->moov->iods);\n\tmovie->moov->iods = NULL;\n\treturn GF_OK;\n}\n\n//remove a track to the root OD\nGF_EXPORT\nGF_Err gf_isom_remove_track_from_root_od(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_List *esds;\n\tGF_ES_ID_Inc *inc;\n\tu32 i;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\tif (!movie->moov) return GF_OK;\n\n\tif (!gf_isom_is_track_in_root_od(movie, trackNumber)) return GF_OK;\n\n\tif (!movie->moov->iods) {\n\t\te = AddMovieIOD(movie->moov, 0);\n\t\tif (e) return e;\n\t}\n\tswitch (movie->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tesds = ((GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor)->ES_ID_IncDescriptors;\n\t\tbreak;\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tesds = ((GF_IsomObjectDescriptor *)movie->moov->iods->descriptor)->ES_ID_IncDescriptors;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//get the desc\n\ti=0;\n\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(esds, &i))) {\n\t\tif (inc->trackID == (u32) gf_isom_get_track_id(movie, trackNumber)) {\n\t\t\tgf_odf_desc_del((GF_Descriptor *)inc);\n\t\t\tgf_list_rem(esds, i-1);\n\t\t\tbreak;\n\t\t}\n\t}\n\t//we don't remove the iod for P&Ls and other potential info\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_creation_time(GF_ISOFile *movie, u64 ctime, u64 mtime)\n{\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\tmovie->moov->mvhd->creationTime = ctime;\n\tmovie->moov->mvhd->modificationTime = mtime;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_creation_time(GF_ISOFile *movie,u32 trackNumber, u64 ctime, u64 mtime)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\ttrak->Header->creationTime = ctime;\n\ttrak->Header->modificationTime = mtime;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_media_creation_time(GF_ISOFile *movie,u32 trackNumber, u64 ctime, u64 mtime)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media || !trak->Media->mediaHeader) return GF_ISOM_INVALID_FILE;\n\n\ttrak->Media->mediaHeader->creationTime = ctime;\n\ttrak->Media->mediaHeader->modificationTime = mtime;\n\treturn GF_OK;\n}\n\n//sets the enable flag of a track\nGF_EXPORT\nGF_Err gf_isom_set_track_enabled(GF_ISOFile *movie, u32 trackNumber, Bool enableTrack)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (enableTrack) {\n\t\ttrak->Header->flags |= 1;\n\t} else {\n\t\ttrak->Header->flags &= ~1;\n\t}\n\treturn GF_OK;\n}\n\n//sets the enable flag of a track\nGF_EXPORT\nGF_Err gf_isom_set_track_flags(GF_ISOFile *movie, u32 trackNumber, u32 flags, GF_ISOMTrackFlagOp op)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (op==GF_ISOM_TKFLAGS_ADD)\n\t\ttrak->Header->flags |= flags;\n\telse if (op==GF_ISOM_TKFLAGS_REM)\n\t\ttrak->Header->flags &= ~flags;\n\telse\n\t\ttrak->Header->flags = flags;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_media_language(GF_ISOFile *movie, u32 trackNumber, char *code)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !code) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\t// Old language-storage processing\n\t// if the new code is on 3 chars, we use it\n\t// otherwise, we find the associated 3 chars code and use it\n\tif (strlen(code) == 3) {\n\t\tmemcpy(trak->Media->mediaHeader->packedLanguage, code, sizeof(char)*3);\n\t} else {\n\t\ts32 lang_idx;\n\t\tconst char *code_3cc;\n\t\tlang_idx = gf_lang_find(code);\n\t\tif (lang_idx == -1) {\n\t\t\tif (code[0]!=0) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"The given code is not a valid one: %s, using 'und' as 3-letter code\\n\", code));\n\t\t\t}\n\t\t\tcode_3cc = \"und\";\n\t\t} else {\n\t\t\tcode_3cc = gf_lang_get_3cc(lang_idx);\n\t\t}\n\t\tmemcpy(trak->Media->mediaHeader->packedLanguage, code_3cc, sizeof(char)*3);\n\t}\n\n\t// New language-storage processing\n\t// change the code in the extended language box (if any)\n\t// otherwise add an extended language box only if the given code is not 3 chars\n\t{\n\t\tu32 i, count;\n\t\tGF_ExtendedLanguageBox *elng;\n\t\telng = NULL;\n\t\tcount = gf_list_count(trak->Media->child_boxes);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tGF_Box *box = (GF_Box *)gf_list_get(trak->Media->child_boxes, i);\n\t\t\tif (box->type == GF_ISOM_BOX_TYPE_ELNG) {\n\t\t\t\telng = (GF_ExtendedLanguageBox *)box;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!elng && (strlen(code) > 3)) {\n\t\t\telng = (GF_ExtendedLanguageBox *)gf_isom_box_new_parent(&trak->Media->child_boxes, GF_ISOM_BOX_TYPE_ELNG);\n\t\t\tif (!elng) return GF_OUT_OF_MEM;\n\t\t}\n\t\tif (elng) {\n\t\t\tif (elng->extended_language) {\n\t\t\t\tgf_free(elng->extended_language);\n\t\t\t}\n\t\t\telng->extended_language = gf_strdup(code);\n\t\t}\n\t}\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_isom_set_root_iod(GF_ISOFile *movie)\n{\n\tGF_IsomInitialObjectDescriptor *iod;\n\tGF_IsomObjectDescriptor *od;\n\tGF_Err e;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\tif (!movie->moov->iods) {\n\t\tAddMovieIOD(movie->moov, 1);\n\t\treturn GF_OK;\n\t}\n\t//if OD, switch to IOD\n\tif (movie->moov->iods->descriptor->tag == GF_ODF_ISOM_IOD_TAG) return GF_OK;\n\tod = (GF_IsomObjectDescriptor *) movie->moov->iods->descriptor;\n\tiod = (GF_IsomInitialObjectDescriptor*)gf_malloc(sizeof(GF_IsomInitialObjectDescriptor));\n\tif (!iod) return GF_OUT_OF_MEM;\n\n\tmemset(iod, 0, sizeof(GF_IsomInitialObjectDescriptor));\n\n\tiod->ES_ID_IncDescriptors = od->ES_ID_IncDescriptors;\n\tod->ES_ID_IncDescriptors = NULL;\n\t//not used in root OD\n\tiod->ES_ID_RefDescriptors = NULL;\n\tiod->extensionDescriptors = od->extensionDescriptors;\n\tod->extensionDescriptors = NULL;\n\tiod->IPMP_Descriptors = od->IPMP_Descriptors;\n\tod->IPMP_Descriptors = NULL;\n\tiod->objectDescriptorID = od->objectDescriptorID;\n\tiod->OCIDescriptors = od->OCIDescriptors;\n\tod->OCIDescriptors = NULL;\n\tiod->tag = GF_ODF_ISOM_IOD_TAG;\n\tiod->URLString = od->URLString;\n\tod->URLString = NULL;\n\n\tgf_odf_desc_del((GF_Descriptor *) od);\n\tmovie->moov->iods->descriptor = (GF_Descriptor *)iod;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_desc_to_root_od(GF_ISOFile *movie, const GF_Descriptor *theDesc)\n{\n\tGF_Err e;\n\tGF_Descriptor *desc, *dupDesc;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (!movie->moov->iods) {\n\t\te = AddMovieIOD(movie->moov, 0);\n\t\tif (e) return e;\n\t}\n\tif (theDesc->tag==GF_ODF_IPMP_TL_TAG) gf_isom_set_root_iod(movie);\n\n\tdesc = movie->moov->iods->descriptor;\n\t//the type of desc is handled at the OD/IOD level, we'll be notified\n\t//if the desc is not allowed\n\tswitch (desc->tag) {\n\tcase GF_ODF_ISOM_IOD_TAG:\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\t//duplicate the desc\n\t\te = gf_odf_desc_copy((GF_Descriptor *)theDesc, &dupDesc);\n\t\tif (e) return e;\n\t\t//add it (MUST BE  (I)OD level desc)\n\t\tmovie->LastError = gf_odf_desc_add_desc(desc, dupDesc);\n\t\tif (movie->LastError) gf_odf_desc_del((GF_Descriptor *)dupDesc);\n\t\tbreak;\n\tdefault:\n\t\tmovie->LastError = GF_ISOM_INVALID_FILE;\n\t\tbreak;\n\t}\n\treturn movie->LastError;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_timescale(GF_ISOFile *movie, u32 timeScale)\n{\n\tGF_TrackBox *trak;\n\tu32 i;\n\tGF_Err e;\n\tif (!timeScale) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (movie->moov->mvhd->timeScale == timeScale) return GF_OK;\n\n\t/*rewrite all durations and edit lists*/\n\tmovie->moov->mvhd->duration *= timeScale;\n\tmovie->moov->mvhd->duration /= movie->moov->mvhd->timeScale;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (movie->moov->mvex && movie->moov->mvex->mehd) {\n\t\tmovie->moov->mvex->mehd->fragment_duration *= timeScale;\n\t\tmovie->moov->mvex->mehd->fragment_duration /= movie->moov->mvhd->timeScale;\n\t}\n#endif\n\n\ti=0;\n\twhile ((trak = (GF_TrackBox*)gf_list_enum(movie->moov->trackList, &i))) {\n\t\ttrak->Header->duration *= timeScale;\n\t\ttrak->Header->duration /= movie->moov->mvhd->timeScale;\n\n\t\tif (trak->editBox && trak->editBox->editList) {\n\t\t\tu32 j, count = gf_list_count(trak->editBox->editList->entryList);\n\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\tGF_EdtsEntry *ent = (GF_EdtsEntry *)gf_list_get(trak->editBox->editList->entryList, j);\n\t\t\t\tent->segmentDuration *= timeScale;\n\t\t\t\tent->segmentDuration /= movie->moov->mvhd->timeScale;\n\t\t\t}\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (movie->moov->mvex && movie->moov->mvex->mehd) {\n\t\tmovie->moov->mvex->mehd->fragment_duration *= timeScale;\n\t\tmovie->moov->mvex->mehd->fragment_duration /= movie->moov->mvhd->timeScale;\n\t}\n#endif\n\tmovie->moov->mvhd->timeScale = timeScale;\n\tmovie->interleavingTime = timeScale;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_pl_indication(GF_ISOFile *movie, GF_ISOProfileLevelType PL_Code, u8 ProfileLevel)\n{\n\tGF_IsomInitialObjectDescriptor *iod;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\te = gf_isom_set_root_iod(movie);\n\tif (e) return e;\n\n\tiod = (GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor;\n\n\tswitch (PL_Code) {\n\tcase GF_ISOM_PL_AUDIO:\n\t\tiod->audio_profileAndLevel = ProfileLevel;\n\t\tbreak;\n\tcase GF_ISOM_PL_GRAPHICS:\n\t\tiod->graphics_profileAndLevel = ProfileLevel;\n\t\tbreak;\n\tcase GF_ISOM_PL_OD:\n\t\tiod->OD_profileAndLevel = ProfileLevel;\n\t\tbreak;\n\tcase GF_ISOM_PL_SCENE:\n\t\tiod->scene_profileAndLevel = ProfileLevel;\n\t\tbreak;\n\tcase GF_ISOM_PL_VISUAL:\n\t\tiod->visual_profileAndLevel = ProfileLevel;\n\t\tbreak;\n\tcase GF_ISOM_PL_INLINE:\n\t\tiod->inlineProfileFlag = ProfileLevel ? 1 : 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_root_od_id(GF_ISOFile *movie, u32 OD_ID)\n{\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\tif (!movie->moov->iods) {\n\t\te = AddMovieIOD(movie->moov, 0);\n\t\tif (e) return e;\n\t}\n\n\tswitch (movie->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\t((GF_IsomObjectDescriptor *)movie->moov->iods->descriptor)->objectDescriptorID = OD_ID;\n\t\tbreak;\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\t((GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor)->objectDescriptorID = OD_ID;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_root_od_url(GF_ISOFile *movie, const char *url_string)\n{\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (!movie->moov->iods) {\n\t\te = AddMovieIOD(movie->moov, 0);\n\t\tif (e) return e;\n\t}\n\n\tswitch (movie->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tif (((GF_IsomObjectDescriptor *)movie->moov->iods->descriptor)->URLString) gf_free(((GF_IsomObjectDescriptor *)movie->moov->iods->descriptor)->URLString);\n\t\t((GF_IsomObjectDescriptor *)movie->moov->iods->descriptor)->URLString = url_string ? gf_strdup(url_string) : NULL;\n\t\tbreak;\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tif (((GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor)->URLString) gf_free(((GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor)->URLString);\n\t\t((GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor)->URLString = url_string ? gf_strdup(url_string) : NULL;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_ISOTrackID gf_isom_get_last_created_track_id(GF_ISOFile *movie)\n{\n\treturn movie ? movie->last_created_track_id : 0;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_load_extra_boxes(GF_ISOFile *movie, u8 *moov_boxes, u32 moov_boxes_size, Bool udta_only)\n{\n\tGF_BitStream *bs;\n\n\tGF_Err e = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tbs = gf_bs_new(moov_boxes, moov_boxes_size, GF_BITSTREAM_READ);\n\n\t//we may have terminators in some QT files (4 bytes set to 0 ...)\n\twhile (gf_bs_available(bs) >= 8) {\n\t\tGF_Box *a_box;\n\t\te = gf_isom_box_parse_ex((GF_Box**)&a_box, bs, GF_ISOM_BOX_TYPE_MOOV, GF_FALSE, 0);\n\t\tif (e || !a_box) goto exit;\n\n\t\tif (a_box->type == GF_ISOM_BOX_TYPE_UDTA) {\n\t\t\tif (movie->moov->udta) gf_isom_box_del_parent(&movie->moov->child_boxes, (GF_Box*)movie->moov->udta);\n\t\t\tmovie->moov->udta = (GF_UserDataBox*) a_box;\n\n\t\t\tif (!movie->moov->child_boxes) movie->moov->child_boxes = gf_list_new();\n\t\t\tgf_list_add(movie->moov->child_boxes, a_box);\n\n\t\t} else if (!udta_only && (a_box->type!=GF_ISOM_BOX_TYPE_PSSH) ) {\n\t\t\tif (!movie->moov->child_boxes) movie->moov->child_boxes = gf_list_new();\n\t\t\tgf_list_add(movie->moov->child_boxes, a_box);\n\t\t} else {\n\t\t\tgf_isom_box_del(a_box);\n\t\t}\n\t}\nexit:\n\tgf_bs_del(bs);\n\treturn e;\n}\n\n//creates a new Track. If trackID = 0, the trackID is chosen by the API\n//returns the track number or 0 if error\nGF_EXPORT\nu32 gf_isom_new_track_from_template(GF_ISOFile *movie, GF_ISOTrackID trakID, u32 MediaType, u32 TimeScale, u8 *tk_box, u32 tk_box_size, Bool udta_only)\n{\n\tGF_Err e;\n\tu64 now;\n\tu8 isHint;\n\tGF_TrackBox *trak;\n\tGF_TrackHeaderBox *tkhd;\n\tGF_MediaBox *mdia;\n\tGF_UserDataBox *udta = NULL;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) {\n\t\tgf_isom_set_last_error(movie, e);\n\t\treturn 0;\n\t}\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\n\tisHint = 0;\n\t//we're creating a hint track... it's the same, but mode HAS TO BE EDIT\n\tif (MediaType == GF_ISOM_MEDIA_HINT) {\n//\t\tif (movie->openMode != GF_ISOM_OPEN_EDIT) return 0;\n\t\tisHint = 1;\n\t}\n\n\tmdia = NULL;\n\ttkhd = NULL;\n\ttrak = NULL;\n\tif (trakID) {\n\t\t//check if we are in ES_ID boundaries\n\t\tif (!isHint && (trakID > 0xFFFF)) {\n\t\t\tgf_isom_set_last_error(movie, GF_BAD_PARAM);\n\t\t\treturn 0;\n\t\t}\n\t\t//here we should look for available IDs ...\n\t\tif (!RequestTrack(movie->moov, trakID)) return 0;\n\t} else {\n\t\ttrakID = movie->moov->mvhd->nextTrackID;\n\t\tif (!trakID) trakID = 1;\n\t\t/*ESIDs are on 16 bits*/\n\t\tif (! isHint && (trakID > 0xFFFF)) trakID = 1;\n\n\t\twhile (1) {\n\t\t\tif (RequestTrack(movie->moov, trakID)) break;\n\t\t\ttrakID += 1;\n\t\t\tif (trakID == 0xFFFFFFFF) break;\n\t\t}\n\t\tif (trakID == 0xFFFFFFFF) {\n\t\t\tgf_isom_set_last_error(movie, GF_BAD_PARAM);\n\t\t\treturn 0;\n\t\t}\n\t\tif (! isHint && (trakID > 0xFFFF)) {\n\t\t\tgf_isom_set_last_error(movie, GF_BAD_PARAM);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (tk_box) {\n\t\tGF_BitStream *bs = gf_bs_new(tk_box, tk_box_size, GF_BITSTREAM_READ);\n\t\tgf_bs_set_cookie(bs, GF_ISOM_BS_COOKIE_NO_LOGS|GF_ISOM_BS_COOKIE_CLONE_TRACK);\n\n\t\te = gf_isom_box_parse_ex((GF_Box**)&trak, bs, GF_ISOM_BOX_TYPE_MOOV, GF_FALSE, 0);\n\t\tgf_bs_del(bs);\n\t\tif (e) trak = NULL;\n\t\telse if (udta_only) {\n\t\t\tudta = trak->udta;\n\t\t\ttrak->udta = NULL;\n\t\t\tgf_list_del_item(trak->child_boxes, udta);\n\t\t\tgf_isom_box_del((GF_Box*)trak);\n\t\t\ttrak = NULL;\n\t\t} else {\n\t\t\tBool tpl_ok = GF_TRUE;\n\t\t\tif (!trak->Header || !trak->Media || !trak->Media->handler || !trak->Media->mediaHeader || !trak->Media->information) tpl_ok = GF_FALSE;\n\n\t\t\telse {\n\t\t\t\tif (!MediaType) MediaType = trak->Media->handler->handlerType;\n\t\t\t\te = NewMedia(&trak->Media, MediaType, TimeScale);\n\t\t\t\tif (e) tpl_ok = GF_FALSE;\n\t\t\t}\n\t\t\tif (!tpl_ok) {\n\t\t\t\tudta = trak->udta;\n\t\t\t\ttrak->udta = NULL;\n\t\t\t\tgf_isom_box_del((GF_Box*)trak);\n\t\t\t}\n\t\t}\n\t}\n\tnow = gf_isom_get_mp4time();\n\tif (!trak) {\n\t\t//OK, now create a track...\n\t\ttrak = (GF_TrackBox *) gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_TRAK);\n\t\tif (!trak) {\n\t\t\tgf_isom_set_last_error(movie, GF_OUT_OF_MEM);\n\t\t\treturn 0;\n\t\t}\n\t\ttkhd = (GF_TrackHeaderBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TKHD);\n\t\tif (!tkhd) {\n\t\t\tgf_isom_set_last_error(movie, GF_OUT_OF_MEM);\n\t\t\treturn 0;\n\t\t}\n\n\t\t//OK, set up the media trak\n\t\te = NewMedia(&mdia, MediaType, TimeScale);\n\t\tif (e) {\n\t\t\tgf_isom_box_del((GF_Box *)mdia);\n\t\t\treturn 0;\n\t\t}\n\t\tassert(trak->child_boxes);\n\t\tgf_list_add(trak->child_boxes, mdia);\n\n\t\t//OK, add this media to our track\n\t\tmdia->mediaTrack = trak;\n\n\t\te = trak_on_child_box((GF_Box*)trak, (GF_Box *) tkhd, GF_FALSE);\n\t\tif (e) goto err_exit;\n\t\te = trak_on_child_box((GF_Box*)trak, (GF_Box *) mdia, GF_FALSE);\n\t\tif (e) goto err_exit;\n\t\ttkhd->trackID = trakID;\n\n\t\tif (gf_sys_is_test_mode() ) {\n\t\t\ttkhd->creationTime = 0;\n\t\t\tmdia->mediaHeader->creationTime = 0;\n\t\t} else {\n\t\t\ttkhd->creationTime = now;\n\t\t\tmdia->mediaHeader->creationTime = now;\n\t\t}\n\n\t} else {\n\t\ttkhd = trak->Header;\n\t\ttkhd->trackID = trakID;\n\t\tmdia = trak->Media;\n\t\tmdia->mediaTrack = trak;\n\t\tmdia->mediaHeader->timeScale = TimeScale;\n\t\tif (mdia->handler->handlerType != MediaType) {\n\t\t\tmdia->handler->handlerType = MediaType;\n\t\t\ttkhd->width = 0;\n\t\t\ttkhd->height = 0;\n\t\t\ttkhd->volume = 0;\n\t\t} else {\n\t\t\tMediaType = 0;\n\t\t}\n\t\ttrak->Header->duration = 0;\n\t\tmdia->mediaHeader->duration = 0;\n\n\t\tif (!movie->moov->child_boxes) movie->moov->child_boxes = gf_list_new();\n\t\tgf_list_add(movie->moov->child_boxes, trak);\n\t}\n\tif (MediaType) {\n\t\t//some default properties for Audio, Visual or private tracks\n\t\tswitch (MediaType) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\tcase GF_ISOM_MEDIA_PICT:\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\tcase GF_ISOM_MEDIA_SUBT:\n\t\t\t/*320-240 pix in 16.16*/\n\t\t\ttkhd->width = 0x01400000;\n\t\t\ttkhd->height = 0x00F00000;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\ttkhd->volume = 0x0100;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmovie->last_created_track_id = tkhd->trackID;\n\n\tif (!movie->keep_utc && !gf_sys_is_test_mode() ) {\n\t\ttkhd->modificationTime = now;\n\t \tmdia->mediaHeader->modificationTime = now;\n\t}\n\n\t//OK, add our trak\n\te = moov_on_child_box((GF_Box*)movie->moov, (GF_Box *)trak, GF_FALSE);\n\tif (e) goto err_exit;\n\t//set the next track ID available\n\tif (trakID >= movie->moov->mvhd->nextTrackID)\n\t\tmovie->moov->mvhd->nextTrackID = trakID+1;\n\n\tif (udta) {\n\t\ttrak->udta = udta;\n\t\tgf_list_add(trak->child_boxes, udta);\n\t}\n\n\t//and return our track number\n\treturn gf_isom_get_track_by_id(movie, trakID);\n\nerr_exit:\n\t//tkhd is registered with track and will be destroyed there\n\tif (trak) gf_isom_box_del((GF_Box *)trak);\n\tif (mdia) gf_isom_box_del((GF_Box *)mdia);\n\treturn 0;\n}\n\nGF_Err gf_isom_set_track_stsd_templates(GF_ISOFile *movie, u32 trackNumber, u8 *stsd_data, u32 stsd_data_size)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_SampleDescriptionBox *stsd=NULL;\n\tGF_List *tmp;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tif (gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes))\n\t\treturn GF_BAD_PARAM;\n\n\tGF_BitStream *bs = gf_bs_new(stsd_data, stsd_data_size, GF_BITSTREAM_READ);\n\te = gf_isom_box_parse_ex((GF_Box **) &stsd, bs, GF_ISOM_BOX_TYPE_STBL, GF_FALSE, 0);\n\tgf_bs_del(bs);\n\tif (!e && (stsd->type==GF_ISOM_BOX_TYPE_STSD)) {\n\t\ttmp = trak->Media->information->sampleTable->SampleDescription->child_boxes;\n\t\ttrak->Media->information->sampleTable->SampleDescription->child_boxes = stsd->child_boxes;\n\t\tstsd->child_boxes = tmp;\n\t}\n\tif (stsd) gf_isom_box_del((GF_Box*)stsd);\n\treturn e;\n}\n\nGF_EXPORT\nu32 gf_isom_new_track(GF_ISOFile *movie, GF_ISOTrackID trakID, u32 MediaType, u32 TimeScale)\n{\n\treturn gf_isom_new_track_from_template(movie, trakID, MediaType, TimeScale, NULL, 0, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_stream_description(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_SampleEntryBox *entry;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tentry = (GF_SampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex - 1);\n\tif (!entry) return GF_BAD_PARAM;\n\tgf_list_rem(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex - 1);\n\tgf_isom_box_del((GF_Box *)entry);\n\treturn GF_OK;\n}\n\n//Create a new StreamDescription in the file. The URL and URN are used to describe external media\nGF_EXPORT\nGF_Err gf_isom_new_mpeg4_description(GF_ISOFile *movie,\n                                     u32 trackNumber,\n                                     const GF_ESD *esd,\n                                     const char *URLname,\n                                     const char *URNname,\n                                     u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 dataRefIndex;\n\tGF_ESD *new_esd;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media ||\n\t        !esd || !esd->decoderConfig ||\n\t        !esd->slConfig) return GF_BAD_PARAM;\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(movie, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\t//duplicate our desc\n\te = gf_odf_desc_copy((GF_Descriptor *)esd, (GF_Descriptor **)&new_esd);\n\tif (e) return e;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\te = Track_SetStreamDescriptor(trak, 0, dataRefIndex, new_esd, outDescriptionIndex);\n\tif (e) {\n\t\tgf_odf_desc_del((GF_Descriptor *)new_esd);\n\t\treturn e;\n\t}\n\treturn e;\n}\n\nGF_Err gf_isom_flush_chunk(GF_TrackBox *trak, Bool is_final)\n{\n\tGF_Err e;\n\tu64 data_offset;\n\tu32 sample_number;\n\tu8 *chunk_data;\n\tu32 chunk_size, chunk_alloc;\n\tif (!trak->chunk_cache) return GF_OK;\n\n\tgf_bs_get_content_no_truncate(trak->chunk_cache, &chunk_data, &chunk_size, &chunk_alloc);\n\n\tdata_offset = gf_isom_datamap_get_offset(trak->Media->information->dataHandler);\n\n\te = gf_isom_datamap_add_data(trak->Media->information->dataHandler, chunk_data, chunk_size);\n\tif (e) return e;\n\n\tsample_number = 1 + trak->Media->information->sampleTable->SampleSize->sampleCount;\n\tsample_number -= trak->nb_samples_in_cache;\n\n\te = stbl_AddChunkOffset(trak->Media, sample_number, trak->chunk_stsd_idx, data_offset, trak->nb_samples_in_cache);\n\n\tif (is_final) {\n\t\tgf_free(chunk_data);\n\t\tgf_bs_del(trak->chunk_cache);\n\t\ttrak->chunk_cache = NULL;\n\t} else {\n\t\tgf_bs_reassign_buffer(trak->chunk_cache, chunk_data, chunk_alloc);\n\t}\n\treturn e;\n}\n\nstatic GF_Err trak_add_sample(GF_ISOFile *movie, GF_TrackBox *trak, const GF_ISOSample *sample, u32 descIndex, u64 data_offset, u32 syncShadowSampleNum)\n{\n\tBool skip_data = GF_FALSE;\n\tGF_Err e;\n\n\t//faststart mode with interleaving time, cache data until we have a full chunk\n\tif ((movie->storageMode==GF_ISOM_STORE_FASTSTART) && movie->interleavingTime) {\n\t\tBool flush_chunk = GF_FALSE;\n\t\tu64 stime = sample->DTS;\n\t\tstime *= movie->moov->mvhd->timeScale;\n\t\tstime /= trak->Media->mediaHeader->timeScale;\n\n\t\tif (stime - trak->first_dts_chunk > movie->interleavingTime)\n\t\t\tflush_chunk = GF_TRUE;\n\n\t\tif (movie->next_flush_chunk_time < stime)\n\t\t\tflush_chunk = GF_TRUE;\n\n\t\tif (trak->chunk_stsd_idx != descIndex)\n\t\t\tflush_chunk = GF_TRUE;\n\n\t\tif (trak->Media->information->sampleTable->MaxChunkSize && trak->Media->information->sampleTable->MaxChunkSize < trak->chunk_cache_size + sample->dataLength)\n\t\t\tflush_chunk = GF_TRUE;\n\n\t\tif (flush_chunk) {\n\t\t\tmovie->next_flush_chunk_time = stime + movie->interleavingTime;\n\t\t\tif (trak->chunk_cache) {\n\t\t\t\te = gf_isom_flush_chunk(trak, GF_FALSE);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\ttrak->nb_samples_in_cache = 0;\n\t\t\ttrak->chunk_cache_size = 0;\n\t\t\ttrak->first_dts_chunk = stime;\n\t\t}\n\t\tif (!trak->chunk_cache)\n\t\t\ttrak->chunk_cache = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_data(trak->chunk_cache, sample->data, sample->dataLength);\n\t\ttrak->nb_samples_in_cache += sample->nb_pack ? sample->nb_pack : 1;\n\t\ttrak->chunk_cache_size += sample->dataLength;\n\t\ttrak->chunk_stsd_idx = descIndex;\n\n\t\tskip_data = GF_TRUE;\n\t}\n\n\te = Media_AddSample(trak->Media, data_offset, sample, descIndex, syncShadowSampleNum);\n\tif (e) return e;\n\n\tif (!skip_data && sample->dataLength) {\n\t\te = gf_isom_datamap_add_data(trak->Media->information->dataHandler, sample->data, sample->dataLength);\n\t\tif (e) return e;\n\t}\n\n\treturn GF_OK;\n}\n\n//Add samples to a track. Use streamDescriptionIndex to specify the desired stream (if several)\nGF_EXPORT\nGF_Err gf_isom_add_sample(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, const GF_ISOSample *sample)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tu32 dataRefIndex;\n\tu64 data_offset;\n\tu32 descIndex;\n\tGF_DataEntryURLBox *Dentry;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = FlushCaptureMode(movie);\n\tif (e) return e;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\n\t//OK, add the sample\n\t//1- Get the streamDescriptionIndex and dataRefIndex\n\t//not specified, get the latest used...\n\tdescIndex = StreamDescriptionIndex;\n\tif (!StreamDescriptionIndex) {\n\t\tdescIndex = trak->Media->information->sampleTable->currentEntryIndex;\n\t}\n\te = Media_GetSampleDesc(trak->Media, descIndex, &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry || !dataRefIndex) return GF_BAD_PARAM;\n\t//set the current to this one\n\ttrak->Media->information->sampleTable->currentEntryIndex = descIndex;\n\n\n\t//get this dataRef and return false if not self contained\n\tDentry = (GF_DataEntryURLBox*)gf_list_get(trak->Media->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\tif (!Dentry || Dentry->flags != 1) return GF_BAD_PARAM;\n\n\t//Open our data map. We are adding stuff, so use EDIT\n\te = gf_isom_datamap_open(trak->Media, dataRefIndex, 1);\n\tif (e) return e;\n\n\t//Get the offset...\n\tdata_offset = gf_isom_datamap_get_offset(trak->Media->information->dataHandler);\n\n\t/*rewrite OD frame*/\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\tGF_ISOSample *od_sample = NULL;\n\n\t\te = Media_ParseODFrame(trak->Media, sample, &od_sample);\n\t\tif (e) return e;\n\n\t\te = trak_add_sample(movie, trak, od_sample, descIndex, data_offset, 0);\n\n\t\tif (od_sample)\n\t\t\tgf_isom_sample_del(&od_sample);\n\t} else {\n\t\te = trak_add_sample(movie, trak, sample, descIndex, data_offset, 0);\n\t}\n\tif (e) return e;\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\t//update media duration\n\tif ((s64)sample->DTS + sample->CTS_Offset>=0) {\n\t\tGF_TimeToSampleBox *stts = trak->Media->information->sampleTable->TimeToSample;\n\t\tu64 dur = sample->DTS + sample->CTS_Offset;\n\t\tdur += stts->entries[stts->nb_entries-1].sampleDelta;\n\n\t\tif (dur > trak->Media->mediaHeader->duration) {\n\t\t\ttrak->Media->mediaHeader->duration = dur;\n\t\t}\n\t}\n\t//do not update track duration yet, this is done on close\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_sample_shadow(GF_ISOFile *movie, u32 trackNumber, GF_ISOSample *sample)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *prev;\n\tGF_SampleEntryBox *entry;\n\tu32 dataRefIndex;\n\tu64 data_offset;\n\tu32 descIndex;\n\tu32 sampleNum, prevSampleNum;\n\tGF_DataEntryURLBox *Dentry;\n\tBool offset_times = GF_FALSE;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !sample) return GF_BAD_PARAM;\n\n\te = FlushCaptureMode(movie);\n\tif (e) return e;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\n\te = stbl_findEntryForTime(trak->Media->information->sampleTable, sample->DTS, 0, &sampleNum, &prevSampleNum);\n\tif (e) return e;\n\t/*we need the EXACT match*/\n\tif (!sampleNum) return GF_BAD_PARAM;\n\n\tprev = gf_isom_get_sample_info(movie, trackNumber, sampleNum, &descIndex, NULL);\n\tif (!prev) return gf_isom_last_error(movie);\n\t/*for conformance*/\n\tif (sample->DTS==prev->DTS) offset_times = GF_TRUE;\n\tgf_isom_sample_del(&prev);\n\n\te = Media_GetSampleDesc(trak->Media, descIndex, &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry || !dataRefIndex) return GF_BAD_PARAM;\n\ttrak->Media->information->sampleTable->currentEntryIndex = descIndex;\n\n\t//get this dataRef and return false if not self contained\n\tDentry = (GF_DataEntryURLBox*)gf_list_get(trak->Media->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\tif (!Dentry || Dentry->flags != 1) return GF_BAD_PARAM;\n\n\t//Open our data map. We are adding stuff, so use EDIT\n\te = gf_isom_datamap_open(trak->Media, dataRefIndex, 1);\n\tif (e) return e;\n\n\tdata_offset = gf_isom_datamap_get_offset(trak->Media->information->dataHandler);\n\tif (offset_times) sample->DTS += 1;\n\n\t/*REWRITE ANY OD STUFF*/\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\tGF_ISOSample *od_sample = NULL;\n\t\te = Media_ParseODFrame(trak->Media, sample, &od_sample);\n\t\tif (e) return e;\n\n\t\te = trak_add_sample(movie, trak, od_sample, descIndex, data_offset, sampleNum);\n\t\tif (od_sample)\n\t\t\tgf_isom_sample_del(&od_sample);\n\t} else {\n\t\te = trak_add_sample(movie, trak, sample, descIndex, data_offset, sampleNum);\n\t}\n\tif (e) return e;\n\tif (offset_times) sample->DTS -= 1;\n\n\t//OK, update duration\n\te = Media_SetDuration(trak);\n\tif (e) return e;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\treturn SetTrackDuration(trak);\n}\n\nGF_EXPORT\nGF_Err gf_isom_append_sample_data(GF_ISOFile *movie, u32 trackNumber, u8 *data, u32 data_size)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tu32 dataRefIndex;\n\tu32 descIndex;\n\tGF_DataEntryURLBox *Dentry;\n\n\tif (!data_size) return GF_OK;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) return GF_BAD_PARAM;\n\n\t//OK, add the sample\n\tdescIndex = trak->Media->information->sampleTable->currentEntryIndex;\n\n\te = Media_GetSampleDesc(trak->Media, descIndex, &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry || !dataRefIndex) return GF_BAD_PARAM;\n\n\t//get this dataRef and return false if not self contained\n\tDentry = (GF_DataEntryURLBox*)gf_list_get(trak->Media->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\tif (!Dentry || Dentry->flags != 1) return GF_BAD_PARAM;\n\n\t//Open our data map. We are adding stuff, so use EDIT\n\te = gf_isom_datamap_open(trak->Media, dataRefIndex, 1);\n\tif (e) return e;\n\n\t//add the media data\n\tif (trak->chunk_cache) {\n\t\tgf_bs_write_data(trak->chunk_cache, data, data_size);\n\t\ttrak->chunk_cache_size += data_size;\n\t} else {\n\t\te = gf_isom_datamap_add_data(trak->Media->information->dataHandler, data, data_size);\n\t\tif (e) return e;\n\t}\n\t//update data size\n\treturn stbl_SampleSizeAppend(trak->Media->information->sampleTable->SampleSize, data_size);\n}\n\n\n//Add sample reference to a track. The SampleOffset is the offset of the data in the referenced file\n//you must have created a StreamDescription with URL or URN specifying your referenced file\n//the data offset specifies the beginning of the chunk\n//Use streamDescriptionIndex to specify the desired stream (if several)\nGF_EXPORT\nGF_Err gf_isom_add_sample_reference(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, GF_ISOSample *sample, u64 dataOffset)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tu32 dataRefIndex;\n\tu32 descIndex;\n\tGF_DataEntryURLBox *Dentry;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\n\t//OD is not allowed as a data ref\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\t//OK, add the sample\n\t//1- Get the streamDescriptionIndex and dataRefIndex\n\t//not specified, get the latest used...\n\tdescIndex = StreamDescriptionIndex;\n\tif (!StreamDescriptionIndex) {\n\t\tdescIndex = trak->Media->information->sampleTable->currentEntryIndex;\n\t}\n\te = Media_GetSampleDesc(trak->Media, descIndex, &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry || !dataRefIndex) return GF_BAD_PARAM;\n\t//set the current to this one\n\ttrak->Media->information->sampleTable->currentEntryIndex = descIndex;\n\n\n\t//get this dataRef and return false if self contained\n\tDentry =(GF_DataEntryURLBox*) gf_list_get(trak->Media->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\tif (Dentry->flags == 1) return GF_BAD_PARAM;\n\n\t//add the meta data\n\te = Media_AddSample(trak->Media, dataOffset, sample, descIndex, 0);\n\tif (e) return e;\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\t//OK, update duration\n\te = Media_SetDuration(trak);\n\tif (e) return e;\n\treturn SetTrackDuration(trak);\n\n}\n\n//set the duration of the last media sample. If not set, the duration of the last sample is the\n//duration of the previous one if any, or 1000 (default value).\nstatic GF_Err gf_isom_set_last_sample_duration_internal(GF_ISOFile *movie, u32 trackNumber, u64 dur_num, u32 dur_den, u32 mode)\n{\n\tGF_TrackBox *trak;\n\tGF_SttsEntry *ent;\n\tGF_TimeToSampleBox *stts;\n\tu64 mdur;\n\tu32 duration;\n\tGF_Err e;\n\tBool is_patch = GF_FALSE;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (mode==0) {\n\t\tduration = (u32) dur_num;\n\t} else if (mode==1) {\n\t\tduration = (u32) dur_num;\n\t\tif (dur_den) {\n\t\t\tduration *= trak->Media->mediaHeader->timeScale;\n\t\t\tduration /= dur_den;\n\t\t}\n\t} else {\n\t\tis_patch = GF_TRUE;\n\t}\n\tmdur = trak->Media->mediaHeader->duration;\n\tstts = trak->Media->information->sampleTable->TimeToSample;\n\tif (!stts->nb_entries) return GF_BAD_PARAM;\n\n\tif (is_patch) {\n\t\tu32 i, avg_dur, nb_samp=0;\n\t\tu64 cum_dur=0;\n\t\tfor (i=0; i<stts->nb_entries; i++) {\n\t\t\tent = (GF_SttsEntry*) &stts->entries[i];\n\t\t\tcum_dur += ent->sampleCount*ent->sampleDelta;\n\t\t\tnb_samp += ent->sampleCount;\n\t\t}\n\t\tif (cum_dur <= dur_num || !nb_samp) return GF_OK;\n\t\tavg_dur = (u32) (dur_num / nb_samp);\n\n\t\tstts->entries[0].sampleDelta = avg_dur;\n\t\tstts->entries[0].sampleCount = nb_samp;\n\t\tstts->nb_entries = 1;\n\t\tstts->w_LastDTS = dur_num - avg_dur;\n\t\treturn GF_OK;\n\t}\n\t//get the last entry\n\tent = (GF_SttsEntry*) &stts->entries[stts->nb_entries-1];\n\tif ((mode==1) && !duration && !dur_den) {\n\t\t//same as previous, nothing to adjust\n\t\tif (ent->sampleCount>1) return GF_OK;\n\t\tif (stts->nb_entries==1) return GF_OK;\n\t\tduration = stts->entries[stts->nb_entries-2].sampleDelta;\n\t}\n\n\tmdur -= ent->sampleDelta;\n\tmdur += duration;\n\n\t//we only have one sample\n\tif (ent->sampleCount == 1) {\n\t\tent->sampleDelta = (u32) duration;\n\t\tif (mode && (stts->nb_entries>1) && (stts->entries[stts->nb_entries-2].sampleDelta==duration)) {\n\t\t\tstts->entries[stts->nb_entries-2].sampleCount++;\n\t\t\tstts->nb_entries--;\n\t\t\t//and update the write cache\n\t\t\tstts->w_currentSampleNum = trak->Media->information->sampleTable->SampleSize->sampleCount;\n\t\t}\n\t} else {\n\t\tif (ent->sampleDelta == duration) return GF_OK;\n\t\tent->sampleCount -= 1;\n\n\t\tif (stts->nb_entries==stts->alloc_size) {\n\t\t\tstts->alloc_size++;\n\t\t\tstts->entries = (GF_SttsEntry*)gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);\n\t\t\tif (!stts->entries) return GF_OUT_OF_MEM;\n\t\t}\n\t\tstts->entries[stts->nb_entries].sampleCount = 1;\n\t\tstts->entries[stts->nb_entries].sampleDelta = (u32) duration;\n\t\tstts->nb_entries++;\n\t\t//and update the write cache\n\t\tstts->w_currentSampleNum = trak->Media->information->sampleTable->SampleSize->sampleCount;\n\t}\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\t//update media duration if duration was set\n\tif (trak->Media->mediaHeader->duration)\n\t\ttrak->Media->mediaHeader->duration = mdur;\n\t//do not update track duration yet, this is done on close\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_last_sample_duration(GF_ISOFile *movie, u32 trackNumber, u32 duration)\n{\n\treturn gf_isom_set_last_sample_duration_internal(movie, trackNumber, duration, 0, 0);\n}\n\nGF_EXPORT\nGF_Err gf_isom_patch_last_sample_duration(GF_ISOFile *movie, u32 trackNumber, u64 next_dts)\n{\n\treturn gf_isom_set_last_sample_duration_internal(movie, trackNumber, next_dts, 0, 2);\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_last_sample_duration_ex(GF_ISOFile *movie, u32 trackNumber, u32 dur_num, u32 dur_den)\n{\n\treturn gf_isom_set_last_sample_duration_internal(movie, trackNumber, dur_num, dur_den, 1);\n}\n\n//update a sample data in the media. Note that the sample MUST exists\nGF_EXPORT\nGF_Err gf_isom_update_sample(GF_ISOFile *movie, u32 trackNumber, u32 sampleNumber, GF_ISOSample *sample, Bool data_only)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_EDIT);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\n\t//block for hint tracks\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_HINT) return GF_BAD_PARAM;\n\n\t//REWRITE ANY OD STUFF\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\tGF_ISOSample *od_sample = NULL;\n\t\te = Media_ParseODFrame(trak->Media, sample, &od_sample);\n\t\tif (!e) e = Media_UpdateSample(trak->Media, sampleNumber, od_sample, data_only);\n\t\tif (od_sample) gf_isom_sample_del(&od_sample);\n\t} else {\n\t\te = Media_UpdateSample(trak->Media, sampleNumber, sample, data_only);\n\t}\n\tif (e) return e;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tgf_isom_disable_inplace_rewrite(movie);\n\treturn GF_OK;\n}\n\n//update a sample data in the media. Note that the sample MUST exists,\n//that sample->data MUST be NULL and sample->dataLength must be NON NULL;\nGF_EXPORT\nGF_Err gf_isom_update_sample_reference(GF_ISOFile *movie, u32 trackNumber, u32 sampleNumber, GF_ISOSample *sample, u64 data_offset)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_EDIT);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//block for hint tracks\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_HINT) return GF_BAD_PARAM;\n\n\tif (!sampleNumber || !sample) return GF_BAD_PARAM;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\n\t//OD is not allowed as a data ref\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\t//OK, update it\n\te = Media_UpdateSampleReference(trak->Media, sampleNumber, sample, data_offset);\n\tif (e) return e;\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\treturn GF_OK;\n}\n\n//for gf_isom_remove_sample and gf_isom_remove_track: check all items sharing their data with a sample being removed\n//and remove sharing flag\n// sample_number can be 0 for complete track removal\nstatic void gf_isom_meta_track_remove(GF_ISOFile *movie, GF_TrackBox *trak, u32 sample_number)\n{\n\tu32 i, count;\n\tif (!movie || !movie->meta || !movie->meta->use_item_sample_sharing)\n\t\treturn;\n\n\tcount = gf_list_count(movie->meta->item_locations->location_entries);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j;\n\t\tGF_ItemLocationEntry *iloc = (GF_ItemLocationEntry *)gf_list_get(movie->meta->item_locations->location_entries, i);\n\t\t/*get item info*/\n\t\tGF_ItemInfoEntryBox *iinf = NULL;\n\t\tj=0;\n\t\twhile ((iinf = (GF_ItemInfoEntryBox *)gf_list_enum(movie->meta->item_infos->item_infos, &j))) {\n\t\t\tif (iinf->item_ID==iloc->item_ID) break;\n\t\t}\n\t\tif (!iinf || !iinf->tk_id) continue;\n\t\tif (iinf->tk_id != trak->Header->trackID) continue;\n\n\t\tif (sample_number && (iinf->sample_num != sample_number)) continue;\n\t\tiinf->tk_id = 0;\n\t\tiinf->sample_num = 0;\n\t}\n}\n\n\n\n//Remove a given sample\nGF_EXPORT\nGF_Err gf_isom_remove_sample(GF_ISOFile *movie, u32 trackNumber, u32 sampleNumber)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_EDIT);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !sampleNumber || (sampleNumber > trak->Media->information->sampleTable->SampleSize->sampleCount) )\n\t\treturn GF_BAD_PARAM;\n\n\t//block for hint tracks\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_HINT) return GF_BAD_PARAM;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\t//do NOT change the order DTS, CTS, size chunk\n\n\t//remove DTS\n\te = stbl_RemoveDTS(trak->Media->information->sampleTable, sampleNumber, 1, trak->Media->mediaHeader->timeScale);\n\tif (e) return e;\n\t//remove CTS if any\n\tif (trak->Media->information->sampleTable->CompositionOffset) {\n\t\te = stbl_RemoveCTS(trak->Media->information->sampleTable, sampleNumber, 1);\n\t\tif (e) return e;\n\t}\n\t//remove size\n\te = stbl_RemoveSize(trak->Media->information->sampleTable, sampleNumber, 1);\n\tif (e) return e;\n\t//remove sampleToChunk and chunk\n\te = stbl_RemoveChunk(trak->Media->information->sampleTable, sampleNumber, 1);\n\tif (e) return e;\n\t//remove sync\n\tif (trak->Media->information->sampleTable->SyncSample) {\n\t\te = stbl_RemoveRAP(trak->Media->information->sampleTable, sampleNumber);\n\t\tif (e) return e;\n\t}\n\t//remove sample dep\n\tif (trak->Media->information->sampleTable->SampleDep) {\n\t\te = stbl_RemoveRedundant(trak->Media->information->sampleTable, sampleNumber, 1);\n\t\tif (e) return e;\n\t}\n\t//remove shadow\n\te = stbl_RemoveShadow(trak->Media->information->sampleTable, sampleNumber);\n\tif (e) return e;\n\n\t//remove padding\n\te = stbl_RemovePaddingBits(trak->Media->information->sampleTable, sampleNumber);\n\tif (e) return e;\n\n\te = stbl_RemoveSubSample(trak->Media->information->sampleTable, sampleNumber);\n\tif (e) return e;\n\n\te = stbl_RemoveSampleGroup(trak->Media->information->sampleTable, sampleNumber);\n\tif (e) return e;\n\n\tgf_isom_disable_inplace_rewrite(movie);\n\n\tgf_isom_meta_track_remove(movie, trak, sampleNumber);\n\n\treturn SetTrackDuration(trak);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_final_name(GF_ISOFile *movie, char *filename)\n{\n\tGF_Err e;\n\tif (!movie ) return GF_BAD_PARAM;\n\n\t//if mode is not OPEN_EDIT file was created under the right name\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_EDIT);\n\tif (e) return e;\n\n\tif (filename) {\n\t\t//we don't allow file overwriting\n\t\tif ( (movie->openMode == GF_ISOM_OPEN_EDIT)\n\t\t        && movie->fileName && !strcmp(filename, movie->fileName))\n\t\t\treturn GF_BAD_PARAM;\n\t\tif (movie->finalName) gf_free(movie->finalName);\n\t\tmovie->finalName = gf_strdup(filename);\n\t\tif (!movie->finalName) return GF_OUT_OF_MEM;\n\t\tgf_isom_disable_inplace_rewrite(movie);\n\t}\n\treturn GF_OK;\n}\n\n//Add a system descriptor to the ESD of a stream(EDIT or WRITE mode only)\nGF_EXPORT\nGF_Err gf_isom_add_desc_to_description(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, const GF_Descriptor *theDesc)\n{\n\tGF_IPIPtr *ipiD;\n\tGF_Err e;\n\tu16 tmpRef;\n\tGF_TrackBox *trak;\n\tGF_Descriptor *desc;\n\tGF_ESD *esd;\n\tGF_TrackReferenceBox *tref;\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tu32 msubtype;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t/*GETS NATIVE DESCRIPTOR ONLY*/\n\te = Media_GetESD(trak->Media, StreamDescriptionIndex, &esd, GF_TRUE);\n\tif (e) return e;\n\n\tentry = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tmsubtype = entry->type;\n\tif ((msubtype==GF_ISOM_BOX_TYPE_ENCV) || (msubtype==GF_ISOM_BOX_TYPE_ENCA))\n\t\tgf_isom_get_original_format_type(movie, trackNumber, StreamDescriptionIndex, &msubtype);\n\n\t//duplicate the desc\n\te = gf_odf_desc_copy((GF_Descriptor *)theDesc, &desc);\n\tif (e) return e;\n\n\t//and add it to the ESD EXCEPT IPI PTR (we need to translate from ES_ID to TrackID!!!\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tswitch (desc->tag) {\n\tcase GF_ODF_IPI_PTR_TAG:\n\t\tgoto insertIPI;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif ((msubtype==GF_ISOM_BOX_TYPE_MP4S) || (msubtype==GF_ISOM_BOX_TYPE_MP4V) || (msubtype==GF_ISOM_BOX_TYPE_MP4A)) {\n\t\treturn gf_odf_desc_add_desc((GF_Descriptor *)esd, desc);\n\t}\n\n\tif (trak->Media->handler->handlerType!=GF_ISOM_MEDIA_VISUAL) {\n\t\tgf_odf_desc_del(desc);\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tGF_MPEG4ExtensionDescriptorsBox *mdesc = (GF_MPEG4ExtensionDescriptorsBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_M4DS);\n\tif (!mdesc) {\n\t\tmdesc = (GF_MPEG4ExtensionDescriptorsBox *) gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_M4DS);\n\t}\n\treturn gf_list_add(mdesc->descriptors, desc);\n\ninsertIPI:\n\tif (esd->ipiPtr) {\n\t\tgf_odf_desc_del((GF_Descriptor *) esd->ipiPtr);\n\t\tesd->ipiPtr = NULL;\n\t}\n\n\tipiD = (GF_IPIPtr *) desc;\n\t//find a tref\n\tif (!trak->References) {\n\t\ttref = (GF_TrackReferenceBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TREF);\n\t\tif (!tref) return GF_OUT_OF_MEM;\n\t\te = trak_on_child_box((GF_Box*)trak, (GF_Box *)tref, GF_FALSE);\n\t\tif (e) return e;\n\t}\n\ttref = trak->References;\n\n\te = Track_FindRef(trak, GF_ISOM_REF_IPI, &dpnd);\n\tif (e) return e;\n\tif (!dpnd) {\n\t\ttmpRef = 0;\n\t\tdpnd = (GF_TrackReferenceTypeBox *) gf_isom_box_new_parent(&tref->child_boxes, GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!dpnd) return GF_OUT_OF_MEM;\n\t\tdpnd->reference_type = GF_ISOM_BOX_TYPE_IPIR;\n\t\te = reftype_AddRefTrack(dpnd, ipiD->IPI_ES_Id, &tmpRef);\n\t\tif (e) return e;\n\t\t//and replace the tag and value...\n\t\tipiD->IPI_ES_Id = tmpRef;\n\t\tipiD->tag = GF_ODF_ISOM_IPI_PTR_TAG;\n\t} else {\n\t\t//Watch out! ONLY ONE IPI dependency is allowed per stream\n\t\tdpnd->trackIDCount = 1;\n\t\tdpnd->trackIDs[0] = ipiD->IPI_ES_Id;\n\t\t//and replace the tag and value...\n\t\tipiD->IPI_ES_Id = 1;\n\t\tipiD->tag = GF_ODF_ISOM_IPI_PTR_TAG;\n\t}\n\t//and add the desc to the esd...\n\treturn gf_odf_desc_add_desc((GF_Descriptor *)esd, desc);\n}\n\n\n//use carefully. Very useful when you made a lot of changes (IPMP, IPI, OCI, ...)\n//THIS WILL REPLACE THE WHOLE DESCRIPTOR ...\nGF_EXPORT\nGF_Err gf_isom_change_mpeg4_description(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, const GF_ESD *newESD)\n{\n\tGF_Err e;\n\tGF_ESD *esd;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\t//duplicate our desc\n\te = gf_odf_desc_copy((GF_Descriptor *)newESD, (GF_Descriptor **)&esd);\n\tif (e) return e;\n\te = Track_SetStreamDescriptor(trak, StreamDescriptionIndex, entry->dataReferenceIndex, esd, NULL);\n\tif (e != GF_OK) {\n\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t}\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_visual_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 Width, u32 Height)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) {\n\t\treturn movie->LastError = GF_ISOM_INVALID_FILE;\n\t}\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type == GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t((GF_VisualSampleEntryBox*)entry)->Width = Width;\n\t\t((GF_VisualSampleEntryBox*)entry)->Height = Height;\n\t\ttrak->Header->width = Width<<16;\n\t\ttrak->Header->height = Height<<16;\n\t\treturn GF_OK;\n\t} else if (trak->Media->handler->handlerType==GF_ISOM_MEDIA_SCENE) {\n\t\ttrak->Header->width = Width<<16;\n\t\ttrak->Header->height = Height<<16;\n\t\treturn GF_OK;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_visual_bit_depth(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u16 bitDepth)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_VISUAL:\n\tcase GF_ISOM_MEDIA_PICT:\n\tcase GF_ISOM_MEDIA_AUXV:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_OK;\n\t}\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) {\n\t\treturn movie->LastError = GF_ISOM_INVALID_FILE;\n\t}\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_MPEGVisualSampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tentry->bit_depth = bitDepth;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_pixel_aspect_ratio(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, s32 hSpacing, s32 vSpacing, Bool force_par)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tif (hSpacing<0) hSpacing = 1;\n\tif (vSpacing<0) vSpacing = 1;\n\n\tGF_PixelAspectRatioBox *pasp = (GF_PixelAspectRatioBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_PASP);\n\tif (!hSpacing || !vSpacing || ((hSpacing == vSpacing) && !force_par))  {\n\t\tif (pasp) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box *)pasp);\n\t\treturn GF_OK;\n\t}\n\tif (!pasp) {\n\t\tpasp = (GF_PixelAspectRatioBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_PASP);\n\t\tif (!pasp) return GF_OUT_OF_MEM;\n\t}\n\tpasp->hSpacing = (u32) hSpacing;\n\tpasp->vSpacing = (u32) vSpacing;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_visual_color_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 colour_type, u16 colour_primaries, u16 transfer_characteristics, u16 matrix_coefficients, Bool full_range_flag, u8 *icc_data, u32 icc_size)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_ColourInformationBox *clr=NULL;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_OK;\n\n\tclr = (GF_ColourInformationBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_COLR);\n\tif (!colour_type) {\n\t\tif (clr) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box *)clr);\n\t\treturn GF_OK;\n\t}\n\tif (clr) {\n\t\t//create another color box\n\t\tif (clr->opaque && !icc_data) clr = NULL;\n\t\telse if (!clr->opaque && icc_data) clr = NULL;\n\t}\n\n\tif (!clr) {\n\t\tclr = (GF_ColourInformationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_COLR);\n\t\tif (!clr) return GF_OUT_OF_MEM;\n\t}\n\tclr->colour_type = colour_type;\n\tclr->colour_primaries = colour_primaries;\n\tclr->transfer_characteristics = transfer_characteristics;\n\tclr->matrix_coefficients = matrix_coefficients;\n\tclr->full_range_flag = full_range_flag;\n\tif (clr->opaque) gf_free(clr->opaque);\n\tclr->opaque = NULL;\n\tclr->opaque_size = 0;\n\tif ((colour_type==GF_ISOM_SUBTYPE_RICC) || (colour_type==GF_ISOM_SUBTYPE_PROF)) {\n\t\tclr->opaque_size = icc_data ? icc_size : 0;\n\t\tif (clr->opaque_size) {\n\t\t\tclr->opaque = gf_malloc(sizeof(char)*clr->opaque_size);\n\t\t\tif (!clr->opaque) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(clr->opaque, icc_data, sizeof(char)*clr->opaque_size);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_dolby_vision_profile(GF_ISOFile* movie, u32 trackNumber, u32 StreamDescriptionIndex, GF_DOVIDecoderConfigurationRecord *dvcc)\n{\n\tGF_Err e;\n\tGF_TrackBox* trak;\n\tGF_Box *dv_cfge = NULL;\n\tGF_MPEGVisualSampleEntryBox* entry;\n\tBool switch_type = GF_FALSE;\n\tBool is_avc = GF_FALSE;\n\tGF_SampleDescriptionBox* stsd;\n\tGF_DOVIConfigurationBox* dovi = NULL;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_OK;\n\n\tif (dvcc) {\n\t\tswitch_type = dvcc->force_dv;\n\t\tswitch (dvcc->dv_profile) {\n\t\tcase 1:\n\t\tcase 3:\n\t\tcase 5:\n\t\t\tswitch_type = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HEV2:\n\tcase GF_ISOM_BOX_TYPE_DVHE:\n\t\tentry->type = switch_type ? GF_ISOM_BOX_TYPE_DVHE : GF_ISOM_BOX_TYPE_HEV1;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HVC2:\n\tcase GF_ISOM_BOX_TYPE_DVH1:\n\t\tentry->type = switch_type ? GF_ISOM_BOX_TYPE_DVH1 : GF_ISOM_BOX_TYPE_HVC1;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_DVA1:\n\t\tis_avc = GF_TRUE;\n\t\tentry->type = switch_type ? GF_ISOM_BOX_TYPE_DVA1 : GF_ISOM_BOX_TYPE_AVC1;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_DVAV:\n\t\tis_avc = GF_TRUE;\n\t\tentry->type = switch_type ? GF_ISOM_BOX_TYPE_DVAV : GF_ISOM_BOX_TYPE_AVC3;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AV01:\n\tcase GF_ISOM_BOX_TYPE_DAV1:\n\t\tentry->type = switch_type ? GF_ISOM_BOX_TYPE_DAV1 : GF_ISOM_BOX_TYPE_AV01;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tu32 dve_type = is_avc ? GF_ISOM_BOX_TYPE_AVCE : GF_ISOM_BOX_TYPE_HVCE;\n\tdv_cfge = gf_isom_box_find_child(entry->child_boxes, dve_type);\n\n\tdovi = entry->dovi_config;\n\tif (!dvcc) {\n\t\tif (dovi) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)dovi);\n\t\tentry->dovi_config = NULL;\n\n\t\tif (dv_cfge) gf_isom_box_del_parent(&entry->child_boxes, dv_cfge);\n\t\t//reverse entry type\n\t\tswitch (entry->type) {\n\t\tcase GF_ISOM_BOX_TYPE_DVHE:\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_HEV1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DVH1:\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_HVC1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DVA1:\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_AVC1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DVAV:\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_AVC3;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DAV1:\n\t\t\tentry->type = GF_ISOM_BOX_TYPE_AV01;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (!dovi) {\n\t\tdovi = (GF_DOVIConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_DVCC);\n\t\tif (!dovi) return GF_OUT_OF_MEM;\n\t\tentry->dovi_config = dovi;\n\t}\n\tif (dvcc->dv_profile < 8) {\n\t\tdovi->type = GF_ISOM_BOX_TYPE_DVCC;\n\t} else {\n\t\tdovi->type = GF_ISOM_BOX_TYPE_DVVC;\n\t}\n\tdovi->DOVIConfig = *dvcc;\n\n\tif (dv_cfge) gf_isom_box_del_parent(&entry->child_boxes, dv_cfge);\n\tdv_cfge = NULL;\n\n\t//inject avcE / hvcE if enhancement layer and RPU present in single-track case\n\t//not clear from the spec what is supposed to be in these, we just clone avcC/hvcC\n\tif (dvcc->bl_present_flag && dvcc->el_present_flag && dvcc->rpu_present_flag) {\n\t\tGF_Box *src = is_avc ? (GF_Box *)entry->avc_config : (GF_Box *)entry->hevc_config;\n\t\tif (!src) return GF_BAD_PARAM;\n\t\te = gf_isom_clone_box(src, &dv_cfge);\n\t\tif (e) return e;\n\t\tdv_cfge->type = dve_type;\n\t\tgf_list_add(entry->child_boxes, dv_cfge);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_high_dynamic_range_info(GF_ISOFile* movie, u32 trackNumber, u32 StreamDescriptionIndex, GF_MasteringDisplayColourVolumeInfo* mdcv, GF_ContentLightLevelInfo* clli)\n{\n\tGF_Err e;\n\tGF_TrackBox* trak;\n\tGF_SampleEntryBox* entry;\n\tGF_SampleDescriptionBox* stsd;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox*)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_MasteringDisplayColourVolumeBox *mdcvb = (GF_MasteringDisplayColourVolumeBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_MDCV);\n\tif (mdcv) {\n\t\tif (!mdcvb) {\n\t\t\tmdcvb = (GF_MasteringDisplayColourVolumeBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_MDCV);\n\t\t\tif (!mdcvb) return GF_OUT_OF_MEM;\n\t\t}\n\t\tmdcvb->mdcv = *mdcv;\n\t} else {\n\t\tif (mdcvb) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box *) mdcvb);\n\t}\n\n\t/*clli*/\n\tGF_ContentLightLevelBox *cllib = (GF_ContentLightLevelBox *)gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_CLLI);\n\tif (clli) {\n\t\tif (!cllib) {\n\t\t\tcllib = (GF_ContentLightLevelBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_CLLI);\n\t\t\tif (!cllib) return GF_OUT_OF_MEM;\n\t\t}\n\t\tcllib->clli = *clli;\n\t} else {\n\t\tif (cllib) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box *) cllib);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_clean_aperture(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 cleanApertureWidthN, u32 cleanApertureWidthD, u32 cleanApertureHeightN, u32 cleanApertureHeightD, s32 horizOffN, u32 horizOffD, s32 vertOffN, u32 vertOffD)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_CleanApertureBox *clap = (GF_CleanApertureBox *)gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_CLAP);\n\tif (!cleanApertureHeightD || !cleanApertureWidthD || !horizOffD || !vertOffD) {\n\t\tif (clap) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)clap);\n\t\treturn GF_OK;\n\t}\n\tif (!clap) {\n\t\tclap = (GF_CleanApertureBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_CLAP);\n\t\tif (!clap) return GF_OUT_OF_MEM;\n\t}\n\n\tclap->cleanApertureWidthN = cleanApertureWidthN;\n\tclap->cleanApertureWidthD = cleanApertureWidthD;\n\tclap->cleanApertureHeightN = cleanApertureHeightN;\n\tclap->cleanApertureHeightD = cleanApertureHeightD;\n\tclap->horizOffN = horizOffN;\n\tclap->horizOffD = horizOffD;\n\tclap->vertOffN = vertOffN;\n\tclap->vertOffD = vertOffD;\n\treturn GF_OK;\n}\n\n#include <gpac/maths.h>\nGF_Err gf_isom_update_aperture_info(GF_ISOFile *movie, u32 trackNumber, Bool remove)\n{\n\tGF_Err e;\n\tGF_Box *box, *enof, *prof, *clef;\n\tGF_TrackBox *trak;\n\tGF_VisualSampleEntryBox *ventry;\n\tGF_PixelAspectRatioBox *pasp;\n\tGF_CleanApertureBox *clap;\n\tu32 j, hspacing, vspacing, clap_width_num, clap_width_den, clap_height_num, clap_height_den, high, low;\n\tDouble width, height;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (remove) {\n\t\tif (trak->Aperture) {\n\t\t\tgf_isom_box_del(trak->Aperture);\n\t\t\ttrak->Aperture = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tenof = prof = clef = NULL;\n\tif (!trak->Aperture) {\n\t\ttrak->Aperture = gf_isom_box_new_parent(&trak->child_boxes, GF_QT_BOX_TYPE_TAPT);\n\t\tif (!trak->Aperture) return GF_OUT_OF_MEM;\n\t}\n\tif (!trak->Aperture->child_boxes) {\n\t\ttrak->Aperture->child_boxes = gf_list_new();\n\t\tif (!trak->Aperture->child_boxes)\n\t\t\treturn GF_OUT_OF_MEM;\n\t}\n\n\tj=0;\n\twhile ( (box = gf_list_enum(trak->Aperture->child_boxes, &j))) {\n\t\tswitch (box->type) {\n\t\tcase GF_QT_BOX_TYPE_CLEF: clef = box; break;\n\t\tcase GF_QT_BOX_TYPE_PROF: prof = box; break;\n\t\tcase GF_QT_BOX_TYPE_ENOF: enof = box; break;\n\t\t}\n\t}\n\tif (!clef) {\n\t\tclef = gf_isom_box_new(GF_QT_BOX_TYPE_CLEF);\n\t\tif (!clef) return GF_OUT_OF_MEM;\n\t\tgf_list_add(trak->Aperture->child_boxes, clef);\n\t}\n\tif (!enof) {\n\t\tenof = gf_isom_box_new(GF_QT_BOX_TYPE_ENOF);\n\t\tif (!enof) return GF_OUT_OF_MEM;\n\t\tgf_list_add(trak->Aperture->child_boxes, enof);\n\t}\n\tif (!prof) {\n\t\tprof = gf_isom_box_new(GF_QT_BOX_TYPE_PROF);\n\t\tif (!prof) return GF_OUT_OF_MEM;\n\t\tgf_list_add(trak->Aperture->child_boxes, prof);\n\t}\n\n\tventry = (GF_VisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (ventry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (ventry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tpasp = (GF_PixelAspectRatioBox *) gf_isom_box_find_child(ventry->child_boxes, GF_ISOM_BOX_TYPE_PASP);\n\thspacing = vspacing = 0;\n\tif (pasp) {\n\t\thspacing = pasp->hSpacing;\n\t\tvspacing = pasp->vSpacing;\n\t}\n\tclap_width_num = ventry->Width;\n\tclap_width_den = 1;\n\tclap_height_num = ventry->Height;\n\tclap_height_den = 1;\n\tclap = (GF_CleanApertureBox *) gf_isom_box_find_child(ventry->child_boxes, GF_ISOM_BOX_TYPE_CLAP);\n\tif (clap) {\n\t\tclap_width_num = clap->cleanApertureWidthN;\n\t\tclap_width_den = clap->cleanApertureWidthD;\n\t\tclap_height_num = clap->cleanApertureHeightN;\n\t\tclap_height_den = clap->cleanApertureHeightD;\n\t}\n\t//enof: encoded pixels in 16.16\n\t((GF_ApertureBox *)enof)->width = (ventry->Width)<<16;\n\t((GF_ApertureBox *)enof)->height = (ventry->Height)<<16;\n\n\t//prof: encoded pixels + pasp in 16.16\n\twidth = (Float) (ventry->Width * hspacing);\n\twidth /= vspacing;\n\thigh = (u32) floor((Float)width);\n\tlow = (u32) ( 0xFFFF * (width - (Double)high) );\n\t((GF_ApertureBox *)prof)->width = (high)<<16 | low;\n\t((GF_ApertureBox *)prof)->height = (ventry->Height)<<16;\n\n\t//clef: encoded pixels + pasp + clap in 16.16\n\twidth = (Double) (clap_width_num * hspacing);\n\twidth /= clap_width_den * vspacing;\n\theight = (Float) clap_height_num;\n\theight /= clap_height_den;\n\n\thigh = (u32) floor((Float)width);\n\tlow = (u32) (0xFFFF * (width - (Double)high));\n\t((GF_ApertureBox *)clef)->width = (high)<<16 | low;\n\thigh = (u32) floor((Float)height);\n\tlow = (u32) (0xFFFF * (height - (Double)high));\n\t((GF_ApertureBox *)clef)->height = (high)<<16 | low;\n\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_image_sequence_coding_constraints(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, Bool remove, Bool all_ref_pics_intra, Bool intra_pred_used, u32 max_ref_per_pic)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_CodingConstraintsBox*ccst = (GF_CodingConstraintsBox*) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_CCST);\n\tif (remove)  {\n\t\tif (ccst) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)ccst);\n\t\treturn GF_OK;\n\t}\n\tif (!ccst) {\n\t\tccst = (GF_CodingConstraintsBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_CCST);\n\t\tif (!ccst) return GF_OUT_OF_MEM;\n\t}\n\tccst->all_ref_pics_intra = all_ref_pics_intra;\n\tccst->intra_pred_used = intra_pred_used;\n\tccst->max_ref_per_pic = max_ref_per_pic;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_image_sequence_alpha(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, Bool remove)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_AuxiliaryTypeInfoBox *auxi = (GF_AuxiliaryTypeInfoBox *)gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_AUXI);\n\tif (remove)  {\n\t\tif (auxi) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)auxi);\n\t\treturn GF_OK;\n\t}\n\tif (!auxi) {\n\t\tauxi = (GF_AuxiliaryTypeInfoBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_AUXI);\n\t\tif (!auxi) return GF_OUT_OF_MEM;\n\t}\n\tauxi->aux_track_type = gf_strdup(\"urn:mpeg:mpegB:cicp:systems:auxiliary:alpha\");\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_audio_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 sampleRate, u32 nbChannels, u8 bitsPerSample, GF_AudioSampleEntryImportMode asemode)\n{\n\tGF_Err e;\n\tu32 i, old_qtff_mode=GF_ISOM_AUDIO_QTFF_NONE;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_AudioSampleEntryBox*aud_entry;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_Box *wave_box = NULL;\n\tGF_Box *gf_isom_audio_sample_get_audio_codec_cfg_box(GF_AudioSampleEntryBox *ptr);\n\tGF_Box *codec_ext = NULL;\n#if 0\n\tGF_ChannelLayoutInfoBox *chan=NULL;\n#endif\n\tGF_OriginalFormatBox *frma=NULL;\n\tGF_ChromaInfoBox *enda=NULL;\n\tGF_ESDBox *esds=NULL;\n\tGF_Box *terminator=NULL;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) {\n\t\treturn movie->LastError = GF_ISOM_INVALID_FILE;\n\t}\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO) return GF_BAD_PARAM;\n\taud_entry = (GF_AudioSampleEntryBox*) entry;\n\n\tif (entry->type==GF_ISOM_BOX_TYPE_MLPA) {\n\t\taud_entry->samplerate_hi = sampleRate>>16;\n\t\taud_entry->samplerate_lo = sampleRate & 0x0000FFFF;\n\t} else {\n\t\taud_entry->samplerate_hi = sampleRate;\n\t\taud_entry->samplerate_lo = 0;\n\t}\n\taud_entry->bitspersample = bitsPerSample;\n\n\tswitch (asemode) {\n\tcase GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_2:\n\t\tstsd->version = 0;\n\t\taud_entry->version = 0;\n\t\taud_entry->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\taud_entry->channel_count = 2;\n\t\tbreak;\n\tcase GF_IMPORT_AUDIO_SAMPLE_ENTRY_NOT_SET:\n\tcase GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_BS:\n\t\tstsd->version = 0;\n\t\taud_entry->version = 0;\n\t\taud_entry->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\taud_entry->channel_count = nbChannels;\n\t\tbreak;\n\tcase GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_MPEG:\n\t\tstsd->version = 1;\n\t\taud_entry->version = 1;\n\t\taud_entry->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\taud_entry->channel_count = nbChannels;\n\t\tbreak;\n\tcase GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF:\n\t\tstsd->version = 0;\n\t\t//don't change if already v2\n\t\tif ((aud_entry->version==2) && aud_entry->qtff_mode) {\n\t\t\tbreak;\n\t\t}\n\t\taud_entry->version = 1;\n\t\taud_entry->channel_count = nbChannels;\n\t\told_qtff_mode = aud_entry->qtff_mode;\n\t\tif (aud_entry->qtff_mode != GF_ISOM_AUDIO_QTFF_ON_EXT_VALID)\n\t\t\taud_entry->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_NOEXT;\n\t\tbreak;\n\t}\n\n\taud_entry->compression_id = 0;\n\n\t//check for wave+children and chan for QTFF or remove them for isobmff\n\tfor (i=0; i<gf_list_count(aud_entry->child_boxes); i++) {\n\t\tGF_Box *b = gf_list_get(aud_entry->child_boxes, i);\n\t\tif ((b->type != GF_QT_BOX_TYPE_WAVE) && (b->type != GF_QT_BOX_TYPE_CHAN) ) continue;\n\t\tif (asemode==GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF) {\n\t\t\tif (b->type == GF_QT_BOX_TYPE_WAVE) wave_box = b;\n#if 0\n\t\t\telse chan = (GF_ChannelLayoutInfoBox *)b;\n#endif\n\n\t\t} else {\n\t\t\tgf_isom_box_del_parent(&aud_entry->child_boxes, b);\n\t\t\ti--;\n\t\t}\n\t}\n\n\t//TODO: insert channelLayout for ISOBMFF\n\tif (asemode!=GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF) return GF_OK;\n\n\tif (aud_entry->type==GF_ISOM_BOX_TYPE_MP4A)\n\t\taud_entry->compression_id = -2;\n\n\tif (!aud_entry->child_boxes) aud_entry->child_boxes = gf_list_new();\n\n#if 0\n\tif (!chan) {\n\t\tchan = (GF_ChannelLayoutInfoBox *) gf_isom_box_new_parent(&aud_entry->child_boxes, GF_QT_BOX_TYPE_CHAN);\n\t}\n\t//TODO, proper channel mapping\n\tchan->layout_tag = (nbChannels==2) ? 6750210 : 6553601;\n#endif\n\n\tcodec_ext = gf_isom_audio_sample_get_audio_codec_cfg_box((GF_AudioSampleEntryBox *)aud_entry);\n\tif (!codec_ext) return GF_OK;\n\n\tif (!wave_box) {\n\t\twave_box = gf_isom_box_new_parent(&aud_entry->child_boxes, GF_QT_BOX_TYPE_WAVE);\n\t}\n\n\tfor (i=0; i<gf_list_count(wave_box->child_boxes); i++) {\n\t\tGF_Box *b = gf_list_get(wave_box->child_boxes, i);\n\t\tswitch (b->type) {\n\t\tcase GF_QT_BOX_TYPE_ENDA:\n\t\t\tenda = (GF_ChromaInfoBox *)b;\n\t\t\tbreak;\n\t\tcase GF_QT_BOX_TYPE_FRMA:\n\t\t\tfrma = (GF_OriginalFormatBox *)b;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_ESDS:\n\t\t\tesds = (GF_ESDBox *)b;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\t\tif ( ((GF_UnknownBox*)b)->original_4cc == 0)\n\t\t\t\tterminator = b;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tterminator = b;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!wave_box->child_boxes) wave_box->child_boxes = gf_list_new();\n\n\t//do not use new_parent, we do this manually to ensure the order\n\taud_entry->qtff_mode = old_qtff_mode ? old_qtff_mode : GF_ISOM_AUDIO_QTFF_ON_NOEXT;\n\tif (!frma) {\n\t\tfrma = (GF_OriginalFormatBox *)gf_isom_box_new(GF_QT_BOX_TYPE_FRMA);\n\t} else {\n\t\tgf_list_del_item(wave_box->child_boxes, frma);\n\t}\n\tgf_list_add(wave_box->child_boxes, frma);\n\n\tif (esds) gf_list_del_item(wave_box->child_boxes, esds);\n\tif (!esds && (aud_entry->type==GF_ISOM_BOX_TYPE_MP4A) && ((GF_MPEGAudioSampleEntryBox*)aud_entry)->esd) {\n\t\tgf_list_del_item(entry->child_boxes, (GF_Box *) ((GF_MPEGAudioSampleEntryBox*)aud_entry)->esd);\n\t\tgf_list_add(wave_box->child_boxes, (GF_Box *) ((GF_MPEGAudioSampleEntryBox*)aud_entry)->esd);\n\t}\n\n\tif (!enda) {\n\t\tenda = (GF_ChromaInfoBox *)gf_isom_box_new(GF_QT_BOX_TYPE_ENDA);\n\t} else {\n\t\tgf_list_del_item(wave_box->child_boxes, enda);\n\t}\n\tenda->chroma=1;\n\tgf_list_add(wave_box->child_boxes, enda);\n\n\tif (!terminator) {\n\t\tterminator = gf_isom_box_new(0);\n\t} else {\n\t\tgf_list_del_item(wave_box->child_boxes, terminator);\n\t}\n\tgf_list_add(wave_box->child_boxes, terminator);\n\n\tif (aud_entry->type==GF_ISOM_BOX_TYPE_GNRA) {\n\t\tfrma->data_format = ((GF_GenericAudioSampleEntryBox*) aud_entry)->EntryType;\n\t} else {\n\t\tfrma->data_format = aud_entry->type;\n\t}\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_audio_layout(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescriptionIndex, GF_AudioChannelLayout *layout)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_AudioSampleEntryBox*aud_entry;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_ChannelLayoutBox *chnl;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!layout) return GF_BAD_PARAM;\n\tif ((layout->stream_structure & 1) && (layout->definedLayout==0) && (layout->channels_count>=64))\n\t\treturn GF_BAD_PARAM;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) {\n\t\treturn movie->LastError = GF_ISOM_INVALID_FILE;\n\t}\n\tif (!sampleDescriptionIndex || sampleDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, sampleDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO) return GF_BAD_PARAM;\n\taud_entry = (GF_AudioSampleEntryBox*) entry;\n\tif (aud_entry->qtff_mode) {\n\t\tu32 sr = aud_entry->samplerate_hi;\n\t\tif (aud_entry->type==GF_ISOM_BOX_TYPE_MLPA) {\n\t\t\tsr <<= 16;\n\t\t\tsr |= aud_entry->samplerate_lo;\n\t\t}\n\t\te = gf_isom_set_audio_info(movie, trackNumber, sampleDescriptionIndex, sr, aud_entry->channel_count, (u8) aud_entry->bitspersample, GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_MPEG);\n\t\tif (e) return e;\n\t}\n\tchnl = (GF_ChannelLayoutBox *) gf_isom_box_find_child(aud_entry->child_boxes, GF_ISOM_BOX_TYPE_CHNL);\n\tif (!chnl) {\n\t\tchnl = (GF_ChannelLayoutBox *)gf_isom_box_new_parent(&aud_entry->child_boxes, GF_ISOM_BOX_TYPE_CHNL);\n\t\tif (!chnl) return GF_OUT_OF_MEM;\n\t}\n\taud_entry->channel_count = layout->channels_count;\n\tmemcpy(&chnl->layout, layout, sizeof(GF_AudioChannelLayout));\n\treturn GF_OK;\n}\n\n//set the storage mode of a file (FLAT, STREAMABLE, INTERLEAVED)\nGF_EXPORT\nGF_Err gf_isom_set_storage_mode(GF_ISOFile *movie, GF_ISOStorageMode storageMode)\n{\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tswitch (storageMode) {\n\tcase GF_ISOM_STORE_FLAT:\n\tcase GF_ISOM_STORE_STREAMABLE:\n\tcase GF_ISOM_STORE_INTERLEAVED:\n\tcase GF_ISOM_STORE_DRIFT_INTERLEAVED:\n\tcase GF_ISOM_STORE_TIGHT:\n\tcase GF_ISOM_STORE_FASTSTART:\n\t\tmovie->storageMode = storageMode;\n\t\t//specifying a storage mode disables inplace rewrite\n\t\tgf_isom_disable_inplace_rewrite(movie);\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_enable_compression(GF_ISOFile *file, GF_ISOCompressMode compress_mode, u32 compress_flags)\n{\n\tif (!file) return GF_BAD_PARAM;\n\tfile->compress_mode = compress_mode;\n\tfile->compress_flags = compress_flags;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_force_64bit_chunk_offset(GF_ISOFile *file, Bool set_on)\n{\n\tif (!file) return GF_BAD_PARAM;\n\tfile->force_co64 = set_on;\n\treturn GF_OK;\n}\n\n\n//update or insert a new edit segment in the track time line. Edits are used to modify\n//the media normal timing. EditTime and EditDuration are expressed in Movie TimeScale\n//If a segment with EditTime already exists, IT IS ERASED\nstatic GF_Err gf_isom_set_edit_internal(GF_ISOFile *movie, u32 trackNumber, u64 EditTime, u64 EditDuration, u64 MediaTime, u32 media_rate, GF_ISOEditType EditMode)\n{\n\tGF_TrackBox *trak;\n\tGF_EditBox *edts;\n\tGF_EditListBox *elst;\n\tGF_EdtsEntry *ent, *newEnt;\n\tu32 i;\n\tGF_Err e;\n\tu64 startTime;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tedts = trak->editBox;\n\tif (! edts) {\n\t\tedts = (GF_EditBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_EDTS);\n\t\tif (!edts) return GF_OUT_OF_MEM;\n\t\ttrak_on_child_box((GF_Box*)trak, (GF_Box *)edts, GF_FALSE);\n\t}\n\telst = edts->editList;\n\tif (!elst) {\n\t\telst = (GF_EditListBox *) gf_isom_box_new_parent(&edts->child_boxes, GF_ISOM_BOX_TYPE_ELST);\n\t\tif (!elst) return GF_OUT_OF_MEM;\n\t\tedts_on_child_box((GF_Box*)edts, (GF_Box *)elst, GF_FALSE);\n\t}\n\n\tstartTime = 0;\n\tent = NULL;\n\t//get the prev entry to this startTime if any\n\ti=0;\n\twhile ((ent = (GF_EdtsEntry *)gf_list_enum(elst->entryList, &i))) {\n\t\tif ( (startTime <= EditTime) && (startTime + ent->segmentDuration > EditTime) )\n\t\t\tgoto found;\n\t\tstartTime += ent->segmentDuration;\n\t}\n\n\t//not found, add a new entry, insert empty one if gap\n\tif (!ent) {\n\t\tBool empty_inserted = GF_FALSE;\n\t\tif (startTime != EditTime) {\n\t\t\tnewEnt = CreateEditEntry(EditTime - startTime, 0, 0, GF_ISOM_EDIT_EMPTY);\n\t\t\tif (!newEnt) return GF_OUT_OF_MEM;\n\t\t\tempty_inserted = GF_TRUE;\n\t\t\tgf_list_add(elst->entryList, newEnt);\n\t\t}\n\t\tnewEnt = CreateEditEntry(EditDuration, MediaTime, media_rate, EditMode);\n\t\tif (!newEnt) return GF_OUT_OF_MEM;\n\t\tgf_list_add(elst->entryList, newEnt);\n\t\te = SetTrackDuration(trak);\n\t\tif (e) return e;\n\t\treturn empty_inserted ? GF_EOS : GF_OK;\n\t}\n\n\tstartTime -= ent->segmentDuration;\n\nfound:\n\n\t//if same time, we erase the current one...\n\tif (startTime == EditTime) {\n\t\tent->segmentDuration = EditDuration;\n\t\tswitch (EditMode) {\n\t\tcase GF_ISOM_EDIT_EMPTY:\n\t\t\tent->mediaRate = 0x10000;\n\t\t\tent->mediaTime = -1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_EDIT_DWELL:\n\t\t\tent->mediaRate = 0;\n\t\t\tent->mediaTime = MediaTime;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tent->mediaRate = media_rate;\n\t\t\tent->mediaTime = MediaTime;\n\t\t\tbreak;\n\t\t}\n\t\treturn SetTrackDuration(trak);\n\t}\n\n\t//adjust so that the prev ent leads to EntryTime\n\t//Note: we don't change the next one as it is unknown to us in\n\t//a lot of case (the author's changes)\n\tent->segmentDuration = EditTime - startTime;\n\tnewEnt = CreateEditEntry(EditDuration, MediaTime, media_rate, EditMode);\n\tif (!newEnt) return GF_OUT_OF_MEM;\n\t//is it the last entry ???\n\tif (i >= gf_list_count(elst->entryList) - 1) {\n\t\t//add the new entry at the end\n\t\tgf_list_add(elst->entryList, newEnt);\n\t\treturn SetTrackDuration(trak);\n\t} else {\n\t\t//insert after the current entry (which is i)\n\t\tgf_list_insert(elst->entryList, newEnt, i+1);\n\t\treturn SetTrackDuration(trak);\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_edit(GF_ISOFile *movie, u32 trackNumber, u64 EditTime, u64 EditDuration, u64 MediaTime, GF_ISOEditType EditMode)\n{\n\treturn gf_isom_set_edit_internal(movie, trackNumber, EditTime, EditDuration, MediaTime, 0x10000, EditMode);\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_edit_with_rate(GF_ISOFile *movie, u32 trackNumber, u64 EditTime, u64 EditDuration, u64 MediaTime, u32 media_rate)\n{\n\treturn gf_isom_set_edit_internal(movie, trackNumber, EditTime, EditDuration, MediaTime, media_rate, GF_ISOM_EDIT_NORMAL);\n\n}\n\n//remove the edit segments for the whole track\nGF_EXPORT\nGF_Err gf_isom_remove_edits(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!trak->editBox || !trak->editBox->editList) return GF_OK;\n\n\twhile (gf_list_count(trak->editBox->editList->entryList)) {\n\t\tGF_EdtsEntry *ent = (GF_EdtsEntry*)gf_list_get(trak->editBox->editList->entryList, 0);\n\t\tgf_free(ent);\n\t\te = gf_list_rem(trak->editBox->editList->entryList, 0);\n\t\tif (e) return e;\n\t}\n\t//then delete the GF_EditBox...\n\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->editBox);\n\ttrak->editBox = NULL;\n\treturn SetTrackDuration(trak);\n}\n\n\n//remove the edit segments for the whole track\nGF_EXPORT\nGF_Err gf_isom_remove_edit(GF_ISOFile *movie, u32 trackNumber, u32 seg_index)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_EdtsEntry *ent, *next_ent;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !seg_index) return GF_BAD_PARAM;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!trak->editBox || !trak->editBox->editList) return GF_OK;\n\tif (gf_list_count(trak->editBox->editList->entryList)<=1) return gf_isom_remove_edits(movie, trackNumber);\n\n\tent = (GF_EdtsEntry*) gf_list_get(trak->editBox->editList->entryList, seg_index-1);\n\tgf_list_rem(trak->editBox->editList->entryList, seg_index-1);\n\tnext_ent = (GF_EdtsEntry *)gf_list_get(trak->editBox->editList->entryList, seg_index-1);\n\tif (next_ent) next_ent->segmentDuration += ent->segmentDuration;\n\tgf_free(ent);\n\treturn SetTrackDuration(trak);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_append_edit(GF_ISOFile *movie, u32 trackNumber, u64 EditDuration, u64 MediaTime, GF_ISOEditType EditMode)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_EdtsEntry *ent;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!trak->editBox) {\n\t\tGF_EditBox *edts = (GF_EditBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_EDTS);\n\t\tif (!edts) return GF_OUT_OF_MEM;\n\t\ttrak_on_child_box((GF_Box*)trak, (GF_Box *)edts, GF_FALSE);\n\t\tassert(trak->editBox);\n\t}\n\tif (!trak->editBox->editList) {\n\t\tGF_EditListBox *elst = (GF_EditListBox *) gf_isom_box_new_parent(&trak->editBox->child_boxes, GF_ISOM_BOX_TYPE_ELST);\n\t\tif (!elst) return GF_OUT_OF_MEM;\n\t\tedts_on_child_box((GF_Box*)trak->editBox, (GF_Box *)elst, GF_FALSE);\n\t\tassert(trak->editBox->editList);\n\t}\n\tent = (GF_EdtsEntry *)gf_malloc(sizeof(GF_EdtsEntry));\n\tif (!ent) return GF_OUT_OF_MEM;\n\n\tent->segmentDuration = EditDuration;\n\tswitch (EditMode) {\n\tcase GF_ISOM_EDIT_EMPTY:\n\t\tent->mediaRate = 0x10000;\n\t\tent->mediaTime = -1;\n\t\tbreak;\n\tcase GF_ISOM_EDIT_DWELL:\n\t\tent->mediaRate = 0;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\tdefault:\n\t\tent->mediaRate = 0x10000;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\t}\n\tgf_list_add(trak->editBox->editList->entryList, ent);\n\treturn SetTrackDuration(trak);\n}\n\nGF_EXPORT\nGF_Err gf_isom_modify_edit(GF_ISOFile *movie, u32 trackNumber, u32 seg_index, u64 EditDuration, u64 MediaTime, GF_ISOEditType EditMode)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_EdtsEntry *ent;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !seg_index) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!trak->editBox || !trak->editBox->editList) return GF_OK;\n\tif (gf_list_count(trak->editBox->editList->entryList)<seg_index) return GF_BAD_PARAM;\n\tent = (GF_EdtsEntry*) gf_list_get(trak->editBox->editList->entryList, seg_index-1);\n\n\tent->segmentDuration = EditDuration;\n\tswitch (EditMode) {\n\tcase GF_ISOM_EDIT_EMPTY:\n\t\tent->mediaRate = 0x10000;\n\t\tent->mediaTime = -1;\n\t\tbreak;\n\tcase GF_ISOM_EDIT_DWELL:\n\t\tent->mediaRate = 0;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\tdefault:\n\t\tent->mediaRate = 0x10000;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\t}\n\treturn SetTrackDuration(trak);\n}\n\nstatic void update_next_track_id(GF_ISOFile *movie)\n{\n\tGF_TrackBox *trak;\n\t/*update next track ID*/\n\tmovie->moov->mvhd->nextTrackID = 0;\n\tu32 i=0;\n\twhile ((trak = (GF_TrackBox *)gf_list_enum(movie->moov->trackList, &i))) {\n\t\tif (trak->Header->trackID>movie->moov->mvhd->nextTrackID)\n\t\t\tmovie->moov->mvhd->nextTrackID = trak->Header->trackID;\n\t}\n\t//shall be larger than the largest track_ID in use\n\tmovie->moov->mvhd->nextTrackID++;\n}\n\n//removes the desired track\nGF_EXPORT\nGF_Err gf_isom_remove_track(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_Err e;\n\tGF_TrackBox *the_trak, *trak;\n\tGF_TrackReferenceTypeBox *tref;\n\tu32 i, j, k, descIndex;\n\tGF_ISOTrackID *newRefs;\n\tu8 found;\n\tGF_ISOSample *samp;\n\tthe_trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!the_trak) return GF_BAD_PARAM;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (movie->moov->iods && movie->moov->iods->descriptor) {\n\t\tGF_Descriptor *desc;\n\t\tGF_ES_ID_Inc *inc;\n\t\tGF_List *ESDs;\n\t\tdesc = movie->moov->iods->descriptor;\n\t\tif (desc->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\tESDs = ((GF_IsomInitialObjectDescriptor *)desc)->ES_ID_IncDescriptors;\n\t\t} else if (desc->tag == GF_ODF_ISOM_OD_TAG) {\n\t\t\tESDs = ((GF_IsomObjectDescriptor *)desc)->ES_ID_IncDescriptors;\n\t\t} else {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\t//remove the track ref from the root OD if any\n\t\ti=0;\n\t\twhile ((inc = (GF_ES_ID_Inc *)gf_list_enum(ESDs, &i))) {\n\t\t\tif (inc->trackID == the_trak->Header->trackID) {\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)inc);\n\t\t\t\ti--;\n\t\t\t\tgf_list_rem(ESDs, i);\n\t\t\t}\n\t\t}\n\t}\n\n\t//remove the track from the movie\n\tgf_list_del_item(movie->moov->trackList, the_trak);\n\n\t//rewrite any OD tracks\n\ti=0;\n\twhile ((trak = (GF_TrackBox *)gf_list_enum(movie->moov->trackList, &i))) {\n\t\tif (trak->Media->handler->handlerType != GF_ISOM_MEDIA_OD) continue;\n\n\t\t//this is an OD track...\n\t\tj = gf_isom_get_sample_count(movie, i);\n\t\tfor (k=0; k < j; k++) {\n\t\t\t//getting the sample will remove the references to the deleted track in the output OD frame\n\t\t\tsamp = gf_isom_get_sample(movie, i, k+1, &descIndex);\n\t\t\tif (!samp) break;\n\t\t\t//so let's update with the new OD frame ! If the sample is empty, remove it\n\t\t\tif (!samp->dataLength) {\n\t\t\t\te = gf_isom_remove_sample(movie, i, k+1);\n\t\t\t\tif (e) return e;\n\t\t\t} else {\n\t\t\t\te = gf_isom_update_sample(movie, i, k+1, samp, GF_TRUE);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\t//and don't forget to delete the sample\n\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t}\n\n\t//remove the track ref from any \"tref\" box in all tracks, except the one to delete\n\t//note that we don't touch scal references, as we don't want to rewrite AVC/HEVC samples ...\n\ti=0;\n\twhile ((trak = (GF_TrackBox *)gf_list_enum(movie->moov->trackList, &i))) {\n\t\tif (! trak->References || ! gf_list_count(trak->References->child_boxes)) continue;\n\n\t\tj=0;\n\t\twhile ((tref = (GF_TrackReferenceTypeBox *)gf_list_enum(trak->References->child_boxes, &j))) {\n\t\t\tif (tref->reference_type==GF_ISOM_REF_SCAL)\n\t\t\t\tcontinue;\n\n\t\t\tfound = 0;\n\t\t\tfor (k=0; k<tref->trackIDCount; k++) {\n\t\t\t\tif (tref->trackIDs[k] == the_trak->Header->trackID) found++;\n\t\t\t}\n\t\t\tif (!found) continue;\n\t\t\t//no more refs, remove this ref_type\n\t\t\tif (found == tref->trackIDCount) {\n\t\t\t\tgf_isom_box_del_parent(&trak->References->child_boxes, (GF_Box *)tref);\n\t\t\t\tj--;\n\t\t\t} else {\n\t\t\t\tnewRefs = (GF_ISOTrackID*)gf_malloc(sizeof(GF_ISOTrackID) * (tref->trackIDCount - found));\n\t\t\t\tif (!newRefs) return GF_OUT_OF_MEM;\n\t\t\t\tfound = 0;\n\t\t\t\tfor (k = 0; k < tref->trackIDCount; k++) {\n\t\t\t\t\tif (tref->trackIDs[k] != the_trak->Header->trackID) {\n\t\t\t\t\t\tnewRefs[k-found] = tref->trackIDs[k];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfound++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_free(tref->trackIDs);\n\t\t\t\ttref->trackIDs = newRefs;\n\t\t\t\ttref->trackIDCount -= found;\n\t\t\t}\n\t\t}\n\t\t//a little opt: remove the ref box if empty...\n\t\tif (! gf_list_count(trak->References->child_boxes)) {\n\t\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->References);\n\t\t\ttrak->References = NULL;\n\t\t}\n\t}\n\n\tgf_isom_disable_inplace_rewrite(movie);\n\n\tgf_isom_meta_track_remove(movie, the_trak, 0);\n\n\t//delete the track\n\tgf_isom_box_del_parent(&movie->moov->child_boxes, (GF_Box *)the_trak);\n\n\t/*update next track ID*/\n\tupdate_next_track_id(movie);\n\n\tif (!gf_list_count(movie->moov->trackList)) {\n\t\tgf_list_del_item(movie->TopBoxes, movie->moov);\n\t\tgf_isom_box_del((GF_Box *)movie->moov);\n\t\tmovie->moov = NULL;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_copyright(GF_ISOFile *movie, const char *threeCharCode, char *notice)\n{\n\tGF_Err e;\n\tGF_CopyrightBox *ptr;\n\tGF_UserDataMap *map;\n\tu32 count, i;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!notice || !threeCharCode) return GF_BAD_PARAM;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (!movie->moov->udta) {\n\t\te = moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tif (e) return e;\n\t}\n\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_CPRT, NULL);\n\n\tif (map) {\n\t\t//try to find one in our language...\n\t\tcount = gf_list_count(map->boxes);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tptr = (GF_CopyrightBox*)gf_list_get(map->boxes, i);\n\t\t\tif (!strcmp(threeCharCode, (const char *) ptr->packedLanguageCode)) {\n\t\t\t\tgf_free(ptr->notice);\n\t\t\t\tptr->notice = (char*)gf_malloc(sizeof(char) * (strlen(notice) + 1));\n\t\t\t\tif (!ptr->notice) return GF_OUT_OF_MEM;\n\t\t\t\tstrcpy(ptr->notice, notice);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t}\n\t//nope, create one\n\tptr = (GF_CopyrightBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_CPRT);\n\tif (!ptr) return GF_OUT_OF_MEM;\n\n\tmemcpy(ptr->packedLanguageCode, threeCharCode, 4);\n\tptr->notice = (char*)gf_malloc(sizeof(char) * (strlen(notice)+1));\n\tif (!ptr->notice) return GF_OUT_OF_MEM;\n\tstrcpy(ptr->notice, notice);\n\treturn udta_on_child_box((GF_Box *)movie->moov->udta, (GF_Box *) ptr, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_track_kind(GF_ISOFile *movie, u32 trackNumber, const char *schemeURI, const char *value)\n{\n\tGF_Err e;\n\tGF_KindBox *ptr;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\tu32 i, count;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) {\n\t\t\te = trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\tudta = trak->udta;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_KIND, NULL);\n\tif (map) {\n\t\tcount = gf_list_count(map->boxes);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_Box *b = (GF_Box *)gf_list_get(map->boxes, i);\n\t\t\tif (b->type == GF_ISOM_BOX_TYPE_KIND) {\n\t\t\t\tGF_KindBox *kb = (GF_KindBox *)b;\n\t\t\t\tif (!strcmp(kb->schemeURI, schemeURI) &&\n\t\t\t\t        ((value && kb->value && !strcmp(value, kb->value)) || (!value && !kb->value))) {\n\t\t\t\t\t// Already there\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tptr = (GF_KindBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_KIND);\n\tif (e) return e;\n\n\tptr->schemeURI = gf_strdup(schemeURI);\n\tif (value) ptr->value = gf_strdup(value);\n\treturn udta_on_child_box((GF_Box *)udta, (GF_Box *) ptr, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_track_kind(GF_ISOFile *movie, u32 trackNumber, const char *schemeURI, const char *value)\n{\n\tGF_Err e;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\tu32 i;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) {\n\t\t\te = trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\tudta = trak->udta;\n\t} else {\n\t\treturn GF_OK;\n\t}\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_KIND, NULL);\n\tif (map) {\n\t\tfor (i=0; i<gf_list_count(map->boxes); i++) {\n\t\t\tGF_Box *b = (GF_Box *)gf_list_get(map->boxes, i);\n\t\t\tif (b->type == GF_ISOM_BOX_TYPE_KIND) {\n\t\t\t\tGF_KindBox *kb = (GF_KindBox *)b;\n\t\t\t\tif (!schemeURI ||\n\t\t\t\t        (!strcmp(kb->schemeURI, schemeURI) &&\n\t\t\t\t         ((value && kb->value && !strcmp(value, kb->value)) || (!value && !kb->value)))) {\n\t\t\t\t\tgf_isom_box_del_parent(&map->boxes, b);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_chapter(GF_ISOFile *movie, u32 trackNumber, u64 timestamp, char *name)\n{\n\tGF_Err e;\n\tGF_ChapterListBox *ptr;\n\tu32 i, count;\n\tGF_ChapterEntry *ce;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) {\n\t\t\te = trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov->udta) {\n\t\t\te = moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\tudta = movie->moov->udta;\n\t}\n\n\tptr = NULL;\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_CHPL, NULL);\n\tif (!map) {\n\t\tptr = (GF_ChapterListBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_CHPL);\n\t\te = udta_on_child_box((GF_Box *)udta, (GF_Box *) ptr, GF_FALSE);\n\t\tif (e) return e;\n\t\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_CHPL, NULL);\n\t} else {\n\t\tptr = (GF_ChapterListBox*)gf_list_get(map->boxes, 0);\n\t}\n\tif (!map) return GF_OUT_OF_MEM;\n\n\t/*this may happen if original MP4 is not properly formatted*/\n\tif (!ptr) {\n\t\tptr = (GF_ChapterListBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_CHPL);\n\t\tif (!ptr) return GF_OUT_OF_MEM;\n\t\tgf_list_add(map->boxes, ptr);\n\t}\n\n\tGF_SAFEALLOC(ce, GF_ChapterEntry);\n\tif (!ce) return GF_OUT_OF_MEM;\n\n\tce->start_time = timestamp * 10000L;\n\tce->name = name ? gf_strdup(name) : NULL;\n\n\t/*insert in order*/\n\tcount = gf_list_count(ptr->list);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ChapterEntry *ace = (GF_ChapterEntry *)gf_list_get(ptr->list, i);\n\t\tif (ace->start_time == ce->start_time) {\n\t\t\tif (ace->name) gf_free(ace->name);\n\t\t\tace->name = ce->name;\n\t\t\tgf_free(ce);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (ace->start_time >= ce->start_time)\n\t\t\treturn gf_list_insert(ptr->list, ce, i);\n\t}\n\treturn gf_list_add(ptr->list, ce);\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_chapter(GF_ISOFile *movie, u32 trackNumber, u32 index)\n{\n\tGF_Err e;\n\tGF_ChapterListBox *ptr;\n\tGF_ChapterEntry *ce;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) return GF_OK;\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov->udta) return GF_OK;\n\t\tudta = movie->moov->udta;\n\t}\n\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_CHPL, NULL);\n\tif (!map) return GF_OK;\n\tptr = (GF_ChapterListBox*)gf_list_get(map->boxes, 0);\n\tif (!ptr) return GF_OK;\n\n\tif (index) {\n\t\tce = (GF_ChapterEntry *)gf_list_get(ptr->list, index-1);\n\t\tif (!ce) return GF_BAD_PARAM;\n\t\tif (ce->name) gf_free(ce->name);\n\t\tgf_free(ce);\n\t\tgf_list_rem(ptr->list, index-1);\n\t} else {\n\t\twhile (gf_list_count(ptr->list)) {\n\t\t\tce = (GF_ChapterEntry *)gf_list_get(ptr->list, 0);\n\t\t\tif (ce->name) gf_free(ce->name);\n\t\t\tgf_free(ce);\n\t\t\tgf_list_rem(ptr->list, 0);\n\t\t}\n\t}\n\tif (!gf_list_count(ptr->list)) {\n\t\tgf_list_del_item(udta->recordList, map);\n\t\tgf_isom_box_array_del(map->boxes);\n\t\tgf_free(map);\n\t}\n\treturn GF_OK;\n}\n\n#if 0 //unused\nGF_Err gf_isom_remove_copyright(GF_ISOFile *movie, u32 index)\n{\n\tGF_Err e;\n\tGF_CopyrightBox *ptr;\n\tGF_UserDataMap *map;\n\tu32 count;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (!index) return GF_BAD_PARAM;\n\tif (!movie->moov->udta) return GF_OK;\n\n\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_CPRT, NULL);\n\tif (!map) return GF_OK;\n\n\tcount = gf_list_count(map->boxes);\n\tif (index>count) return GF_BAD_PARAM;\n\n\tptr = (GF_CopyrightBox*)gf_list_get(map->boxes, index-1);\n\tif (ptr) {\n\t\tgf_list_rem(map->boxes, index-1);\n\t\tif (ptr->notice) gf_free(ptr->notice);\n\t\tgf_free(ptr);\n\t}\n\t/*last copyright, remove*/\n\tif (!gf_list_count(map->boxes)) {\n\t\tgf_list_del_item(movie->moov->udta->recordList, map);\n\t\tgf_list_del(map->boxes);\n\t\tgf_free(map);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_set_watermark(GF_ISOFile *movie, bin128 UUID, u8* data, u32 length)\n{\n\tGF_Err e;\n\tGF_UnknownUUIDBox *ptr;\n\tGF_UserDataMap *map;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\tif (!movie->moov->udta) {\n\t\te = moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA));\n\t\tif (e) return e;\n\t}\n\n\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_UUID, (bin128 *) & UUID);\n\tif (map) {\n\t\tptr = (GF_UnknownUUIDBox *)gf_list_get(map->boxes, 0);\n\t\tif (ptr) {\n\t\t\tgf_free(ptr->data);\n\t\t\tptr->data = (char*)gf_malloc(length);\n\t\t\tif (!ptr->data) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(ptr->data, data, length);\n\t\t\tptr->dataSize = length;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\t//nope, create one\n\tptr = (GF_UnknownUUIDBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_UUID);\n\tif (!ptr) return GF_OUT_OF_MEM;\n\n\tmemcpy(ptr->uuid, UUID, 16);\n\tptr->data = (char*)gf_malloc(length);\n\tif (!ptr->data) return GF_OUT_OF_MEM;\n\tmemcpy(ptr->data, data, length);\n\tptr->dataSize = length;\n\treturn udta_on_child_box((GF_Box *)movie->moov->udta, (GF_Box *) ptr);\n}\n#endif\n\n//set the interleaving time of media data (INTERLEAVED mode only)\n//InterleaveTime is in MovieTimeScale\nGF_EXPORT\nGF_Err gf_isom_set_interleave_time(GF_ISOFile *movie, u32 InterleaveTime)\n{\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!InterleaveTime || !movie->moov) return GF_OK;\n\tmovie->interleavingTime = InterleaveTime;\n\treturn GF_OK;\n}\n\n\n\n//use a compact track version for sample size. This is not usually recommended\n//except for speech codecs where the track has a lot of small samples\n//compaction is done automatically while writing based on the track's sample sizes\nGF_EXPORT\nGF_Err gf_isom_use_compact_size(GF_ISOFile *movie, u32 trackNumber, Bool CompactionOn)\n{\n\tGF_TrackBox *trak;\n\tu32 i, size;\n\tGF_SampleSizeBox *stsz;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (!trak->Media || !trak->Media->information\n\t        || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tstsz = trak->Media->information->sampleTable->SampleSize;\n\n\t//switch to regular table\n\tif (!CompactionOn) {\n\t\tif (stsz->type == GF_ISOM_BOX_TYPE_STSZ) return GF_OK;\n\t\tstsz->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\t//invalidate the sampleSize and recompute it\n\t\tstsz->sampleSize = 0;\n\t\tif (!stsz->sampleCount) return GF_OK;\n\t\t//if the table is empty we can only assume the track is empty (no size indication)\n\t\tif (!stsz->sizes) return GF_OK;\n\t\tsize = stsz->sizes[0];\n\t\t//check whether the sizes are all the same or not\n\t\tfor (i=1; i<stsz->sampleCount; i++) {\n\t\t\tif (size != stsz->sizes[i]) {\n\t\t\t\tsize = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (size) {\n\t\t\tgf_free(stsz->sizes);\n\t\t\tstsz->sizes = NULL;\n\t\t\tstsz->sampleSize = size;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\t//switch to compact table\n\tif (stsz->type == GF_ISOM_BOX_TYPE_STZ2) return GF_OK;\n\t//fill the table. Although it seems weird , this is needed in case of edition\n\t//after the function is called. NOte however than we force regular table\n\t//at write time if all samples are of same size\n\tif (stsz->sampleSize && stsz->sampleCount) {\n\t\t//this is a weird table indeed ;)\n\t\tif (stsz->sizes) gf_free(stsz->sizes);\n\t\tstsz->sizes = (u32*) gf_malloc(sizeof(u32)*stsz->sampleCount);\n\t\tif (!stsz->sizes) return GF_OUT_OF_MEM;\n\t\tmemset(stsz->sizes, stsz->sampleSize, sizeof(u32));\n\t}\n\t//set the SampleSize to 0 while the file is open\n\tstsz->sampleSize = 0;\n\tstsz->type = GF_ISOM_BOX_TYPE_STZ2;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_disable_brand_rewrite(GF_ISOFile *movie, Bool do_disable)\n{\n\tif (!movie) return GF_BAD_PARAM;\n\tmovie->disable_brand_rewrite = do_disable ? 1: 0;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_brand_info(GF_ISOFile *movie, u32 MajorBrand, u32 MinorVersion)\n{\n\tu32 i, *p;\n\n\tif (!movie) return GF_BAD_PARAM;\n\tif (movie->disable_brand_rewrite) return GF_OK;\n\tif (!MajorBrand) return GF_BAD_PARAM;\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (! (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY)) {\n\t\tGF_Err e = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\tif (e) return e;\n\n\t\te = CheckNoData(movie);\n\t\tif (e) return e;\n\t}\n#endif\n\n\tif (!movie->brand) {\n\t\tmovie->brand = (GF_FileTypeBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_FTYP);\n\t\tif (!movie->brand) return GF_OUT_OF_MEM;\n\t\tgf_list_add(movie->TopBoxes, movie->brand);\n\t}\n\n\tmovie->brand->majorBrand = MajorBrand;\n\tmovie->brand->minorVersion = MinorVersion;\n\n\tif (!movie->brand->altBrand) {\n\t\tmovie->brand->altBrand = (u32*)gf_malloc(sizeof(u32));\n\t\tif (!movie->brand->altBrand) return GF_OUT_OF_MEM;\n\t\tmovie->brand->altBrand[0] = MajorBrand;\n\t\tmovie->brand->altCount = 1;\n\t\treturn GF_OK;\n\t}\n\n\t//if brand already present don't change anything\n\tfor (i=0; i<movie->brand->altCount; i++) {\n\t\tif (movie->brand->altBrand[i] == MajorBrand) return GF_OK;\n\t}\n\tp = (u32*)gf_malloc(sizeof(u32)*(movie->brand->altCount + 1));\n\tif (!p) return GF_OUT_OF_MEM;\n\tmemcpy(p, movie->brand->altBrand, sizeof(u32)*movie->brand->altCount);\n\tp[movie->brand->altCount] = MajorBrand;\n\tmovie->brand->altCount += 1;\n\tgf_free(movie->brand->altBrand);\n\tmovie->brand->altBrand = p;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_modify_alternate_brand(GF_ISOFile *movie, u32 Brand, Bool AddIt)\n{\n\tu32 i, k, *p;\n\n\tif (!movie) return GF_BAD_PARAM;\n\tif (movie->disable_brand_rewrite) return GF_OK;\n\tif (!Brand) return GF_BAD_PARAM;\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (! (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY)) {\n\t\tGF_Err e = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\tif (e) return e;\n\n\t\te = CheckNoData(movie);\n\t\tif (e) return e;\n\t}\n#endif\n\n\tif (!movie->brand && AddIt) {\n\t\tmovie->brand = (GF_FileTypeBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_FTYP);\n\t\tif (!movie->brand) return GF_OUT_OF_MEM;\n\t\tgf_list_add(movie->TopBoxes, movie->brand);\n\t}\n\tif (!AddIt && !movie->brand) return GF_OK;\n\n\t//do not mofify major one\n\tif (!AddIt && movie->brand->majorBrand == Brand) return GF_OK;\n\n\tif (!AddIt && movie->brand->altCount == 1) {\n\t\t//fixes it in case\n\t\tmovie->brand->altBrand[0] = movie->brand->majorBrand;\n\t\treturn GF_OK;\n\t}\n\t//check for the brand\n\tfor (i=0; i<movie->brand->altCount; i++) {\n\t\tif (movie->brand->altBrand[i] == Brand) goto found;\n\t}\n\t//Not found\n\tif (!AddIt) return GF_OK;\n\t//add it\n\tp = (u32*)gf_malloc(sizeof(u32)*(movie->brand->altCount + 1));\n\tif (!p) return GF_OUT_OF_MEM;\n\tif (movie->brand->altBrand) {\n\t\tmemcpy(p, movie->brand->altBrand, sizeof(u32)*movie->brand->altCount);\n\t\tgf_free(movie->brand->altBrand);\n\t}\n\tp[movie->brand->altCount] = Brand;\n\tmovie->brand->altCount += 1;\n\tmovie->brand->altBrand = p;\n\treturn GF_OK;\n\nfound:\n\n\t//found\n\tif (AddIt) return GF_OK;\n\tassert(movie->brand->altCount>1);\n\n\t//remove it\n\tp = (u32*)gf_malloc(sizeof(u32)*(movie->brand->altCount - 1));\n\tif (!p) return GF_OUT_OF_MEM;\n\tk = 0;\n\tfor (i=0; i<movie->brand->altCount; i++) {\n\t\tif (movie->brand->altBrand[i] == Brand) continue;\n\t\telse {\n\t\t\tp[k] = movie->brand->altBrand[i];\n\t\t\tk++;\n\t\t}\n\t}\n\tmovie->brand->altCount -= 1;\n\tgf_free(movie->brand->altBrand);\n\tmovie->brand->altBrand = p;\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_reset_alt_brands_ex(GF_ISOFile *movie, Bool leave_empty)\n{\n\tu32 *p;\n\n\tif (!movie) return GF_BAD_PARAM;\n\tif (movie->disable_brand_rewrite) return GF_OK;\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (! (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY)) {\n\t\tGF_Err e = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\tif (e) return e;\n\n\t\te = CheckNoData(movie);\n\t\tif (e) return e;\n\t}\n#endif\n\n\tif (!movie->brand) {\n\t\tmovie->brand = (GF_FileTypeBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_FTYP);\n\t\tif (!movie->brand) return GF_OUT_OF_MEM;\n\t\tgf_list_add(movie->TopBoxes, movie->brand);\n\t}\n\tgf_free(movie->brand->altBrand);\n\tif (leave_empty) {\n\t\tmovie->brand->altCount = 0;\n\t\tmovie->brand->altBrand = NULL;\n\t} else {\n\t\tp = (u32*)gf_malloc(sizeof(u32));\n\t\tif (!p) return GF_OUT_OF_MEM;\n\t\tp[0] = movie->brand->majorBrand;\n\t\tmovie->brand->altCount = 1;\n\t\tmovie->brand->altBrand = p;\n\t}\n\treturn GF_OK;\n}\nGF_EXPORT\nGF_Err gf_isom_reset_alt_brands(GF_ISOFile *movie)\n{\n\treturn gf_isom_reset_alt_brands_ex(movie, GF_FALSE);\n}\n\n#if 0 //unused\nGF_Err gf_isom_set_sample_padding_bits(GF_ISOFile *movie, u32 trackNumber, u32 sampleNumber, u8 NbBits)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || NbBits > 7) return GF_BAD_PARAM;\n\n\t//set Padding info\n\treturn stbl_SetPaddingBits(trak->Media->information->sampleTable, sampleNumber, NbBits);\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_remove_user_data_item(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID, u32 UserDataIndex)\n{\n\tGF_UserDataMap *map;\n\tGF_Box *a;\n\tu32 i;\n\tbin128 t;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\tmemset(t, 1, 16);\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov) return GF_BAD_PARAM;\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_BAD_PARAM;\n\tif (!UserDataIndex) return GF_BAD_PARAM;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {\n\t\tif ((map->boxType == GF_ISOM_BOX_TYPE_UUID)  && !memcmp(map->uuid, UUID, 16)) goto found;\n\t\telse if (map->boxType == UserDataType) goto found;\n\t}\n\t//not found\n\treturn GF_OK;\n\nfound:\n\n\tif (UserDataIndex > gf_list_count(map->boxes) ) return GF_BAD_PARAM;\n\t//delete the box\n\ta = (GF_Box*)gf_list_get(map->boxes, UserDataIndex-1);\n\tgf_isom_box_del_parent(&map->boxes, a);\n\n\t//remove the map if empty\n\tif (!gf_list_count(map->boxes)) {\n\t\tgf_list_rem(udta->recordList, i-1);\n\t\tgf_isom_box_array_del(map->boxes);\n\t\tgf_free(map);\n\t}\n\t//but we keep the UDTA no matter what\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_user_data(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID)\n{\n\tGF_UserDataMap *map;\n\tu32 i;\n\tGF_Err e;\n\tbin128 t;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\tmemset(t, 1, 16);\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_EOS;\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov) return GF_BAD_PARAM;\n\t\tudta = movie->moov->udta;\n\t}\n\t//do not return any error if no udta\n\tif (!udta) return GF_EOS;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {\n\t\tif ((map->boxType == GF_ISOM_BOX_TYPE_UUID)  && !memcmp(map->uuid, UUID, 16)) goto found;\n\t\telse if (map->boxType == UserDataType) goto found;\n\t}\n\t//not found\n\treturn GF_OK;\n\nfound:\n\n\tgf_list_rem(udta->recordList, i-1);\n\tgf_isom_box_array_del(map->boxes);\n\tgf_free(map);\n\n\t//but we keep the UDTA no matter what\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_user_data(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID, u8 *data, u32 DataLength)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov) return GF_BAD_PARAM;\n\t\tif (!movie->moov->udta) moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_OUT_OF_MEM;\n\n\t//create a default box\n\tif (UserDataType) {\n\t\tGF_UnknownBox *a = (GF_UnknownBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_UNKNOWN);\n\t\tif (!a) return GF_OUT_OF_MEM;\n\t\ta->original_4cc = UserDataType;\n\t\tif (DataLength) {\n\t\t\ta->data = (char*)gf_malloc(sizeof(char)*DataLength);\n\t\t\tif (!a->data) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(a->data, data, DataLength);\n\t\t\ta->dataSize = DataLength;\n\t\t}\n\t\treturn udta_on_child_box((GF_Box *)udta, (GF_Box *) a, GF_FALSE);\n\t} else if (UUID) {\n\t\tGF_UnknownUUIDBox *a = (GF_UnknownUUIDBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_UUID);\n\t\tif (!a) return GF_OUT_OF_MEM;\n\t\tmemcpy(a->uuid, UUID, 16);\n\t\tif (DataLength) {\n\t\t\ta->data = (char*)gf_malloc(sizeof(char)*DataLength);\n\t\t\tif (!a->data) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(a->data, data, DataLength);\n\t\t\ta->dataSize = DataLength;\n\t\t}\n\t\treturn udta_on_child_box((GF_Box *)udta, (GF_Box *) a, GF_FALSE);\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_user_data_boxes(GF_ISOFile *movie, u32 trackNumber, u8 *data, u32 DataLength)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\tGF_BitStream *bs;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov) return GF_BAD_PARAM;\n\t\tif (!movie->moov->udta) moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_OUT_OF_MEM;\n\n\tbs = gf_bs_new(data, DataLength, GF_BITSTREAM_READ);\n\twhile (gf_bs_available(bs)) {\n\t\tGF_Box *a;\n\t\te = gf_isom_box_parse(&a, bs);\n\t\tif (e) break;\n\t\te = udta_on_child_box((GF_Box *)udta, a, GF_FALSE);\n\t\tif (e) break;\n\t}\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_clone_pl_indications(GF_ISOFile *orig, GF_ISOFile *dest)\n{\n\tGF_IsomInitialObjectDescriptor *iod_d;\n\tif (!orig || !dest) return GF_BAD_PARAM;\n\tif (!orig->moov->iods || !orig->moov->iods->descriptor) return GF_OK;\n\tif (orig->moov->iods->descriptor->tag != GF_ODF_ISOM_IOD_TAG) return GF_OK;\n\n\tAddMovieIOD(dest->moov, 1);\n\tgf_odf_desc_del((GF_Descriptor *)dest->moov->iods->descriptor);\n\tgf_odf_desc_copy((GF_Descriptor *)orig->moov->iods->descriptor, (GF_Descriptor **)&dest->moov->iods->descriptor);\n\tiod_d = (GF_IsomInitialObjectDescriptor *) dest->moov->iods->descriptor;\n\twhile (gf_list_count(iod_d->ES_ID_IncDescriptors)) {\n\t\tGF_Descriptor *d = (GF_Descriptor *)gf_list_get(iod_d->ES_ID_IncDescriptors, 0);\n\t\tgf_list_rem(iod_d->ES_ID_IncDescriptors, 0);\n\t\tgf_odf_desc_del(d);\n\t}\n\twhile (gf_list_count(iod_d->ES_ID_RefDescriptors)) {\n\t\tGF_Descriptor *d = (GF_Descriptor *)gf_list_get(iod_d->ES_ID_RefDescriptors, 0);\n\t\tgf_list_rem(iod_d->ES_ID_RefDescriptors, 0);\n\t\tgf_odf_desc_del(d);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_clone_box(GF_Box *src, GF_Box **dst)\n{\n\tGF_Err e;\n\tu8 *data;\n\tu32 data_size;\n\tGF_BitStream *bs;\n\n\tif (*dst) {\n\t\tgf_isom_box_del(*dst);\n\t\t*dst=NULL;\n\t}\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (!bs) return GF_OUT_OF_MEM;\n\te = gf_isom_box_size( (GF_Box *) src);\n\tif (!e) e = gf_isom_box_write((GF_Box *) src, bs);\n\tgf_bs_get_content(bs, &data, &data_size);\n\tgf_bs_del(bs);\n\tif (e) {\n\t\tif (data) gf_free(data);\n\t\treturn e;\n\t}\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\tif (!bs) {\n\t\tif (data) gf_free(data);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\te = gf_isom_box_parse(dst, bs);\n\tgf_bs_del(bs);\n\tgf_free(data);\n\treturn e;\n}\n\n#if 0 //unused\n/*clones the entire movie file to destination. Tracks can be cloned if clone_tracks is set, in which case hint tracks can be\nkept if keep_hint_tracks is set\nif keep_pssh, all pssh boxes will be kept\nfragment information (mvex) is not kept*/\nGF_Err gf_isom_clone_movie(GF_ISOFile *orig_file, GF_ISOFile *dest_file, Bool clone_tracks, Bool keep_hint_tracks, Bool keep_pssh)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_Box *box;\n\n\te = CanAccessMovie(dest_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (orig_file->brand) {\n\t\tgf_list_del_item(dest_file->TopBoxes, dest_file->brand);\n\t\tgf_isom_box_del((GF_Box *)dest_file->brand);\n\t\tdest_file->brand = NULL;\n\t\tgf_isom_clone_box((GF_Box *)orig_file->brand, (GF_Box **)&dest_file->brand);\n\t\tif (dest_file->brand) gf_list_add(dest_file->TopBoxes, dest_file->brand);\n\t}\n\n\tif (orig_file->meta) {\n\t\tgf_list_del_item(dest_file->TopBoxes, dest_file->meta);\n\t\tgf_isom_box_del((GF_Box *)dest_file->meta);\n\t\tdest_file->meta = NULL;\n\t\t/*fixme - check imports*/\n\t\tgf_isom_clone_box((GF_Box *)orig_file->meta, (GF_Box **)&dest_file->meta);\n\t\tif (dest_file->meta) gf_list_add(dest_file->TopBoxes, dest_file->meta);\n\t}\n\tif (orig_file->moov) {\n\t\tu32 i, dstTrack;\n\t\tGF_Box *iods;\n\t\tGF_List *tracks = gf_list_new();\n\t\tGF_List *old_tracks = orig_file->moov->trackList;\n\t\torig_file->moov->trackList = tracks;\n\t\tiods = (GF_Box*)orig_file->moov->iods;\n\t\torig_file->moov->iods = NULL;\n\t\te = gf_isom_clone_box((GF_Box *)orig_file->moov, (GF_Box **)&dest_file->moov);\n\t\tif (e) {\n\t\t\tgf_list_del(tracks);\n\t\t\torig_file->moov->trackList = old_tracks;\n\t\t\treturn e;\n\t\t}\n\t\torig_file->moov->trackList = old_tracks;\n\t\tgf_list_del(tracks);\n\t\torig_file->moov->iods = (GF_ObjectDescriptorBox*)iods;\n\t\tgf_list_add(dest_file->TopBoxes, dest_file->moov);\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (dest_file->moov->mvex) {\n\t\t\tgf_isom_box_del_parent(&dest_file->moov->child_boxes, (GF_Box *)dest_file->moov->mvex);\n\t\t\tdest_file->moov->mvex = NULL;\n\t\t}\n#endif\n\n\t\tif (clone_tracks) {\n\t\t\tfor (i=0; i<gf_list_count(orig_file->moov->trackList); i++) {\n\t\t\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get( orig_file->moov->trackList, i);\n\t\t\t\tif (!trak) continue;\n\t\t\t\tif (keep_hint_tracks || (trak->Media->handler->handlerType != GF_ISOM_MEDIA_HINT)) {\n\t\t\t\t\te = gf_isom_clone_track(orig_file, i+1, dest_file, 0, &dstTrack);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (iods)\n\t\t\t\tgf_isom_clone_box((GF_Box *)orig_file->moov->iods, (GF_Box **)dest_file->moov->iods);\n\t\t} else {\n\t\t\tdest_file->moov->mvhd->nextTrackID = 1;\n\t\t\tgf_isom_clone_pl_indications(orig_file, dest_file);\n\t\t}\n\t\tdest_file->moov->mov = dest_file;\n\t}\n\n\tif (!keep_pssh) {\n\t\ti=0;\n\t\twhile ((box = (GF_Box*)gf_list_get(dest_file->moov->child_boxes, i++))) {\n\t\t\tif (box->type == GF_ISOM_BOX_TYPE_PSSH) {\n\t\t\t\ti--;\n\t\t\t\tgf_isom_box_del_parent(&dest_file->moov->child_boxes, box);\n\t\t\t}\n\t\t}\n\t}\n\n\t//duplicate other boxes\n\ti=0;\n\twhile ((box = (GF_Box*)gf_list_get(orig_file->TopBoxes, i++))) {\n\t\tswitch(box->type) {\n\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\tcase GF_ISOM_BOX_TYPE_STYP:\n\t\tcase GF_ISOM_BOX_TYPE_SIDX:\n\t\tcase GF_ISOM_BOX_TYPE_SSIX:\n\t\tcase GF_ISOM_BOX_TYPE_MOOF:\n#endif\n\t\tcase GF_ISOM_BOX_TYPE_JP:\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_PSSH:\n\t\t\tif (!keep_pssh)\n\t\t\t\tbreak;\n\n\t\tdefault:\n\t\t{\n\t\t\tGF_Box *box2 = NULL;\n\t\t\tgf_isom_clone_box(box, &box2);\n\t\t\tgf_list_add(dest_file->TopBoxes, box2);\n\t\t}\n\t\tbreak;\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n#endif\n\n\nGF_EXPORT\nGF_Err gf_isom_get_raw_user_data(GF_ISOFile *file, u8 **output, u32 *output_size)\n{\n\tGF_BitStream *bs;\n\tGF_Err e;\n\tGF_Box *b;\n\tu32 i;\n\n\t*output = NULL;\n\t*output_size = 0;\n\tif (!file || !file->moov || (!file->moov->udta && !file->moov->child_boxes)) return GF_OK;\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tif (file->moov->udta) {\n\t\te = gf_isom_box_size( (GF_Box *) file->moov->udta);\n\t\tif (e) goto exit;\n\t\te = gf_isom_box_write((GF_Box *) file->moov->udta, bs);\n\t\tif (e) goto exit;\n\t}\n\te = GF_OK;\n\ti=0;\n\twhile ((b = gf_list_enum(file->moov->child_boxes, &i))) {\n\t\tswitch (b->type) {\n\t\tcase GF_ISOM_BOX_TYPE_TRAK:\n\t\tcase GF_ISOM_BOX_TYPE_MVHD:\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tcase GF_ISOM_BOX_TYPE_MVEX:\n#endif\n\t\tcase GF_ISOM_BOX_TYPE_IODS:\n\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\tcontinue;\n\t\t}\n\t\te = gf_isom_box_size( (GF_Box *) b);\n\t\tif (e) goto exit;\n\t\te = gf_isom_box_write((GF_Box *) b, bs);\n\t\tif (e) goto exit;\n\t}\n\n\tgf_bs_get_content(bs, output, output_size);\n\nexit:\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_track_template(GF_ISOFile *file, u32 track, u8 **output, u32 *output_size)\n{\n\tGF_TrackBox *trak;\n\tGF_BitStream *bs;\n\tGF_DataReferenceBox *dref;\n\tGF_SampleTableBox *stbl, *stbl_temp;\n\tGF_SampleEncryptionBox *senc;\n\tGF_List *gpac_internals = NULL;\n\tu32 i, count;\n\n\t*output = NULL;\n\t*output_size = 0;\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\t//don't serialize dref\n\tdref = NULL;\n\tif (trak->Media->information->dataInformation) {\n\t\tdref = trak->Media->information->dataInformation->dref;\n\t\ttrak->Media->information->dataInformation->dref = NULL;\n\t\tgf_list_del_item(trak->Media->information->dataInformation->child_boxes, dref);\n\t}\n\n\t//don't serialize stbl but create a temp one\n\tstbl_temp = (GF_SampleTableBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STBL);\n\tif (!stbl_temp->child_boxes) stbl_temp->child_boxes = gf_list_new();\n\tstbl = trak->Media->information->sampleTable;\n\tgf_list_del_item(trak->Media->information->child_boxes, stbl);\n\n\ttrak->Media->information->sampleTable = stbl_temp;\n\tgf_list_add(trak->Media->information->child_boxes, stbl_temp);\n\n\t/*do not clone sampleDescription table but create an empty one*/\n\tstbl_temp->SampleDescription = (GF_SampleDescriptionBox *) gf_isom_box_new_parent(&stbl_temp->child_boxes, GF_ISOM_BOX_TYPE_STSD);\n\n\t/*clone sampleGroups description tables if any*/\n\tstbl_temp->sampleGroupsDescription = stbl->sampleGroupsDescription;\n\tcount = gf_list_count(stbl->sampleGroupsDescription);\n\tfor (i=0;i<count; i++) {\n\t\tGF_SampleGroupDescriptionBox *b = gf_list_get(stbl->sampleGroupsDescription, i);\n\t\t//don't add our internal sample groups\n\t\tif (b->grouping_type==GF_4CC('E','M','S','G'))\n\t\t\tcontinue;\n\t\tif (b->grouping_type==GF_4CC('P','S','S','H'))\n\t\t\tcontinue;\n\t\tgf_list_add(stbl_temp->child_boxes, b);\n\t}\n\t/*clone CompositionToDecode table, we may remove it later*/\n\tstbl_temp->CompositionToDecode = stbl->CompositionToDecode;\n\tgf_list_add(stbl_temp->child_boxes, stbl->CompositionToDecode);\n\n\n\tcount = gf_list_count(trak->child_boxes);\n\tfor (i=0;i<count; i++) {\n\t\tGF_UnknownBox *b = gf_list_get(trak->child_boxes, i);\n\t\tif (b->type != GF_ISOM_BOX_TYPE_UNKNOWN) continue;\n\t\tif (b->original_4cc==GF_ISOM_BOX_TYPE_GDAT) {\n\t\t\tif (!gpac_internals) gpac_internals = gf_list_new();\n\t\t\tgf_list_add(gpac_internals, b);\n\t\t\tgf_list_rem(trak->child_boxes, i);\n\t\t\ti--;\n\t\t\tcount--;\n\t\t}\n\t}\n\n\t//don't serialize senc\n\tsenc = trak->sample_encryption;\n\tif (senc) {\n\t\tassert(trak->child_boxes);\n\t\tgf_list_del_item(trak->child_boxes, senc);\n\t\ttrak->sample_encryption = NULL;\n\t}\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tgf_isom_box_size( (GF_Box *) trak);\n\tgf_isom_box_write((GF_Box *) trak, bs);\n\tgf_bs_get_content(bs, output, output_size);\n\tgf_bs_del(bs);\n\n\t//restore our pointers\n\tif (dref) {\n\t\ttrak->Media->information->dataInformation->dref = dref;\n\t\tgf_list_add(trak->Media->information->dataInformation->child_boxes, dref);\n\t}\n\ttrak->Media->information->sampleTable = stbl;\n\tgf_list_add(trak->Media->information->child_boxes, stbl);\n\tgf_list_del_item(trak->Media->information->child_boxes, stbl_temp);\n\tif (senc) {\n\t\ttrak->sample_encryption = senc;\n\t\tgf_list_add(trak->child_boxes, senc);\n\t}\n\n\tstbl_temp->sampleGroupsDescription = NULL;\n\tcount = gf_list_count(stbl->sampleGroupsDescription);\n\tfor (i=0;i<count; i++) {\n\t\tGF_Box *b = gf_list_get(stbl->sampleGroupsDescription, i);\n\t\tgf_list_del_item(stbl_temp->child_boxes, b);\n\t}\n\n\tstbl_temp->CompositionToDecode = NULL;\n\tgf_list_del_item(stbl_temp->child_boxes, stbl->CompositionToDecode);\n\tgf_isom_box_del((GF_Box *)stbl_temp);\n\n\tif (gpac_internals) {\n\t\tgf_list_transfer(trak->child_boxes, gpac_internals);\n\t\tgf_list_del(gpac_internals);\n\t}\n\treturn GF_OK;\n\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_trex_template(GF_ISOFile *file, u32 track, u8 **output, u32 *output_size)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_TrackBox *trak;\n\tGF_BitStream *bs;\n\tu32 i;\n\tGF_TrackExtendsBox *trex = NULL;\n\tGF_TrackExtensionPropertiesBox *trexprop = NULL;\n\n\t*output = NULL;\n\t*output_size = 0;\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tif (!file->moov->mvex) return GF_NOT_FOUND;\n\tfor (i=0; i<gf_list_count(file->moov->mvex->TrackExList); i++) {\n\t\ttrex = gf_list_get(file->moov->mvex->TrackExList, i);\n\t\tif (trex->trackID == trak->Header->trackID) break;\n\t\ttrex = NULL;\n\t}\n\tif (!trex) return GF_NOT_FOUND;\n\n\tfor (i=0; i<gf_list_count(file->moov->mvex->TrackExPropList); i++) {\n\t\ttrexprop = gf_list_get(file->moov->mvex->TrackExPropList, i);\n\t\tif (trexprop->trackID== trak->Header->trackID) break;\n\t\ttrexprop = NULL;\n\t}\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_box_size( (GF_Box *) trex);\n\tgf_isom_box_write((GF_Box *) trex, bs);\n\n\tif (trexprop) {\n\t\tgf_isom_box_size( (GF_Box *) trexprop);\n\t\tgf_isom_box_write((GF_Box *) trexprop, bs);\n\t}\n\tgf_bs_get_content(bs, output, output_size);\n\tgf_bs_del(bs);\n\n#else\n\t*output = NULL;\n\t*output_size = 0;\n#endif\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_stsd_template(GF_ISOFile *file, u32 track, u32 stsd_idx, u8 **output, u32 *output_size)\n{\n\tGF_TrackBox *trak;\n\tGF_BitStream *bs;\n\tGF_Box *ent;\n\n\t*output = NULL;\n\t*output_size = 0;\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleDescription) return GF_BAD_PARAM;\n\n\tif (stsd_idx) {\n\t\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, stsd_idx-1);\n\t\tif (!ent) return GF_BAD_PARAM;\n\t} else {\n\t\tent = (GF_Box*) trak->Media->information->sampleTable->SampleDescription;\n\t}\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tgf_isom_box_size(ent);\n\tgf_isom_box_write(ent, bs);\n\tgf_bs_get_content(bs, output, output_size);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_clone_track(GF_ISOFile *orig_file, u32 orig_track, GF_ISOFile *dest_file, GF_ISOTrackCloneFlags flags, u32 *dest_track)\n{\n\tGF_TrackBox *trak, *new_tk;\n\tGF_BitStream *bs;\n\tu8 *data;\n\tconst u8 *buffer;\n\tu32 data_size;\n\tu32 i, count;\n\tGF_Err e;\n\tGF_SampleTableBox *stbl, *stbl_temp;\n\tGF_SampleEncryptionBox *senc;\n\n\te = CanAccessMovie(dest_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(dest_file);\n\tif (e) return e;\n\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(orig_file, orig_track);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tstbl_temp = (GF_SampleTableBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STBL);\n\tif (!stbl_temp->child_boxes) stbl_temp->child_boxes = gf_list_new();\n\n\ttrak->Media->information->sampleTable = stbl_temp;\n\tgf_list_add(trak->Media->information->child_boxes, stbl_temp);\n\tgf_list_del_item(trak->Media->information->child_boxes, stbl);\n\n\tif (!stbl_temp->child_boxes) stbl_temp->child_boxes = gf_list_new();\n\n\t/*clone sampleDescription table*/\n\tstbl_temp->SampleDescription = stbl->SampleDescription;\n\tgf_list_add(stbl_temp->child_boxes, stbl->SampleDescription);\n\t/*also clone sampleGroups description tables if any*/\n\tstbl_temp->sampleGroupsDescription = stbl->sampleGroupsDescription;\n\tcount = gf_list_count(stbl->sampleGroupsDescription);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *b = gf_list_get(stbl->sampleGroupsDescription, i);\n\t\tgf_list_add(stbl_temp->child_boxes, b);\n\t}\n\t/*clone CompositionToDecode table, we may remove it later*/\n\tstbl_temp->CompositionToDecode = stbl->CompositionToDecode;\n\tgf_list_add(stbl_temp->child_boxes, stbl->CompositionToDecode);\n\n\tsenc = trak->sample_encryption;\n\tif (senc) {\n\t\tassert(trak->child_boxes);\n\t\tgf_list_del_item(trak->child_boxes, senc);\n\t\ttrak->sample_encryption = NULL;\n\t}\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tgf_isom_box_size( (GF_Box *) trak);\n\tgf_isom_box_write((GF_Box *) trak, bs);\n\tgf_bs_get_content(bs, &data, &data_size);\n\tgf_bs_del(bs);\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\tif (flags & GF_ISOM_CLONE_TRACK_NO_QT)\n\t\tgf_bs_set_cookie(bs, GF_ISOM_BS_COOKIE_QT_CONV | GF_ISOM_BS_COOKIE_CLONE_TRACK);\n\telse\n\t\tgf_bs_set_cookie(bs, GF_ISOM_BS_COOKIE_CLONE_TRACK);\n\n\te = gf_isom_box_parse((GF_Box **) &new_tk, bs);\n\tgf_bs_del(bs);\n\tgf_free(data);\n\n\ttrak->Media->information->sampleTable = stbl;\n\tgf_list_del_item(trak->Media->information->child_boxes, stbl_temp);\n\tgf_list_add(trak->Media->information->child_boxes, stbl);\n\n\tif (senc) {\n\t\ttrak->sample_encryption = senc;\n\t\tgf_list_add(trak->child_boxes, senc);\n\t}\n\tgf_list_del_item(stbl_temp->child_boxes, stbl_temp->SampleDescription);\n\tstbl_temp->SampleDescription = NULL;\n\n\tcount = gf_list_count(stbl->sampleGroupsDescription);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *b = gf_list_get(stbl->sampleGroupsDescription, i);\n\t\tgf_list_del_item(stbl_temp->child_boxes, b);\n\t}\n\tstbl_temp->sampleGroupsDescription = NULL;\n\n\tgf_list_del_item(stbl_temp->child_boxes, stbl_temp->CompositionToDecode);\n\tstbl_temp->CompositionToDecode = NULL;\n\tgf_isom_box_del((GF_Box *)stbl_temp);\n\n\tif (e) {\n\t\tif (new_tk) gf_isom_box_del((GF_Box *)new_tk);\n\t\treturn e;\n\t}\n\n\tgf_isom_disable_inplace_rewrite(dest_file);\n\n\t/*create default boxes*/\n\tstbl = new_tk->Media->information->sampleTable;\n\tstbl->ChunkOffset = gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STCO);\n\tif (!stbl->ChunkOffset) return GF_OUT_OF_MEM;\n\tstbl->SampleSize = (GF_SampleSizeBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSZ);\n\tif (!stbl->SampleSize) return GF_OUT_OF_MEM;\n\tstbl->SampleToChunk = (GF_SampleToChunkBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSC);\n\tif (!stbl->SampleToChunk) return GF_OUT_OF_MEM;\n\tstbl->TimeToSample = (GF_TimeToSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STTS);\n\tif (!stbl->TimeToSample) return GF_OUT_OF_MEM;\n\n\tif (flags & GF_ISOM_CLONE_TRACK_DROP_ID)\n\t\tnew_tk->Header->trackID = 0;\n\n\t/*check trackID validity before adding track*/\n\tif (!new_tk->Header->trackID || gf_isom_get_track_by_id(dest_file, new_tk->Header->trackID)) {\n\t\tu32 ID = 1;\n\t\twhile (1) {\n\t\t\tif (RequestTrack(dest_file->moov, ID)) break;\n\t\t\tID += 1;\n\t\t\tif (ID == 0xFFFFFFFF) break;\n\t\t}\n\t\tnew_tk->Header->trackID = ID;\n\t}\n\tif (!dest_file->moov->child_boxes) dest_file->moov->child_boxes = gf_list_new();\n\tgf_list_add(dest_file->moov->child_boxes, new_tk);\n\tmoov_on_child_box((GF_Box*)dest_file->moov, (GF_Box *)new_tk, GF_FALSE);\n\n\t/*set originalID*/\n\tnew_tk->originalID = trak->Header->trackID;\n\t/*set originalFile*/\n\tbuffer = gf_isom_get_filename(orig_file);\n\tnew_tk->originalFile = gf_crc_32(buffer, (u32) strlen(buffer));\n\n\t/*rewrite edit list segmentDuration to new movie timescale*/\n\tif (dest_file->moov->mvhd->timeScale != orig_file->moov->mvhd->timeScale) {\n\t\tDouble ts_scale = dest_file->moov->mvhd->timeScale;\n\t\tts_scale /= orig_file->moov->mvhd->timeScale;\n\t\tnew_tk->Header->duration = (u64) (new_tk->Header->duration * ts_scale);\n\t\tif (new_tk->editBox && new_tk->editBox->editList) {\n\t\t\tcount = gf_list_count(new_tk->editBox->editList->entryList);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_EdtsEntry *ent = (GF_EdtsEntry *)gf_list_get(new_tk->editBox->editList->entryList, i);\n\t\t\t\tent->segmentDuration = (u64) (ent->segmentDuration * ts_scale);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (flags & GF_ISOM_CLONE_RESET_DURATION)\n\t\tnew_tk->Media->mediaHeader->duration = 0;\n\n\tif (!new_tk->Media->information->dataInformation->dref) return GF_BAD_PARAM;\n\n\t/*reset data ref*/\n\tif (! (flags & GF_ISOM_CLONE_TRACK_KEEP_DREF) ) {\n\t\tGF_SampleEntryBox *entry;\n\t\tBool use_alis = GF_FALSE;\n\t\tif (! (flags & GF_ISOM_CLONE_TRACK_NO_QT)) {\n\t\t\tGF_Box *b = gf_list_get(new_tk->Media->information->dataInformation->dref->child_boxes, 0);\n\t\t\tif (b && (b->type==GF_QT_BOX_TYPE_ALIS))\n\t\t\t\tuse_alis = GF_TRUE;\n\t\t}\n\t\tgf_isom_box_array_del(new_tk->Media->information->dataInformation->dref->child_boxes);\n\t\tnew_tk->Media->information->dataInformation->dref->child_boxes = gf_list_new();\n\t\t/*update data ref*/\n\t\tentry = (GF_SampleEntryBox*)gf_list_get(new_tk->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\tif (entry) {\n\t\t\tu32 dref;\n\t\t\tMedia_CreateDataRef(dest_file, new_tk->Media->information->dataInformation->dref, use_alis ?  \"alis\" : NULL, NULL, &dref);\n\t\t\tentry->dataReferenceIndex = dref;\n\t\t}\n\t} else {\n\t\tfor (i=0; i<gf_list_count(new_tk->Media->information->dataInformation->dref->child_boxes); i++) {\n\t\t\tGF_DataEntryBox *dref_entry = (GF_DataEntryBox *)gf_list_get(new_tk->Media->information->dataInformation->dref->child_boxes, i);\n\t\t\tif (dref_entry->flags & 1) {\n\t\t\t\tdref_entry->flags &= ~1;\n\t\t\t\te = Media_SetDrefURL((GF_DataEntryURLBox *)dref_entry, orig_file->fileName, dest_file->finalName);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t}\n\t}\n\n\t//purge all 'gpac' boxes at track level\n\tfor (i=0; i<gf_list_count(new_tk->child_boxes); i++) {\n\t\tGF_UnknownBox *b = (GF_UnknownBox *)gf_list_get(new_tk->child_boxes, i);\n\t\tif (b->type != GF_ISOM_BOX_TYPE_UNKNOWN) continue;\n\t\tif (b->original_4cc==GF_ISOM_BOX_TYPE_GDAT) {\n\t\t\tgf_list_rem(new_tk->child_boxes, i);\n\t\t\ti--;\n\t\t\tgf_isom_box_del((GF_Box*)b);\n\t\t}\n\t}\n\n\t*dest_track = gf_list_count(dest_file->moov->trackList);\n\n\tif (dest_file->moov->mvhd->nextTrackID <= new_tk->Header->trackID)\n\t\tdest_file->moov->mvhd->nextTrackID = new_tk->Header->trackID+1;\n\n\treturn GF_OK;\n}\n\n#if 0\n/*clones all sampleDescription entries in new track, after an optional reset of existing entries*/\nGF_Err gf_isom_clone_sample_descriptions(GF_ISOFile *the_file, u32 trackNumber, GF_ISOFile *orig_file, u32 orig_track, Bool reset_existing)\n{\n\tu32 i;\n\tGF_TrackBox *dst_trak, *src_trak;\n\tGF_Err e = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tdst_trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!dst_trak || !dst_trak->Media) return GF_BAD_PARAM;\n\tsrc_trak = gf_isom_get_track_from_file(orig_file, orig_track);\n\tif (!src_trak || !src_trak->Media) return GF_BAD_PARAM;\n\n\tif (reset_existing) {\n\t\tgf_isom_box_array_del(dst_trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\t\tdst_trak->Media->information->sampleTable->SampleDescription->child_boxes = gf_list_new();\n\t}\n\n\tfor (i=0; i<gf_list_count(src_trak->Media->information->sampleTable->SampleDescription->child_boxes); i++) {\n\t\tu32 outDesc;\n\t\te = gf_isom_clone_sample_description(the_file, trackNumber, orig_file, orig_track, i+1, NULL, NULL, &outDesc);\n\t\tif (e) break;\n\t}\n\treturn e;\n}\n#endif\n\n\nGF_EXPORT\nGF_Err gf_isom_clone_sample_description(GF_ISOFile *the_file, u32 trackNumber, GF_ISOFile *orig_file, u32 orig_track, u32 orig_desc_index, const char *URLname, const char *URNname, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_BitStream *bs;\n\tu8 *data;\n\tu32 data_size;\n\tGF_Box *entry;\n\tGF_Err e;\n\tu32 dataRefIndex;\n    u32 mtype;\n\tu32 internal_type;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(orig_file, orig_track);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tentry = (GF_Box*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, orig_desc_index-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tinternal_type = ((GF_SampleEntryBox *)entry)->internal_type;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tgf_isom_box_size(entry);\n\tgf_isom_box_write(entry, bs);\n\tgf_bs_get_content(bs, &data, &data_size);\n\tgf_bs_del(bs);\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\te = gf_isom_box_parse(&entry, bs);\n\tgf_bs_del(bs);\n\tgf_free(data);\n\tif (e) return e;\n\tif (entry->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\tGF_UnknownBox *ubox = (GF_UnknownBox*)entry;\n\t\tif (internal_type == GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t\tGF_GenericVisualSampleEntryBox *ve = (GF_GenericVisualSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRV);\n\t\t\tve->EntryType = ubox->type;\n\t\t\tve->data = ubox->data;\n\t\t\tve->data_size = ubox->dataSize;\n\t\t\tentry = (GF_Box *) ve;\n\t\t}\n\t\telse if (internal_type == GF_ISOM_SAMPLE_ENTRY_AUDIO) {\n\t\t\tGF_GenericAudioSampleEntryBox *ae = (GF_GenericAudioSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRA);\n\t\t\tae->EntryType = ubox->type;\n\t\t\tae->data = ubox->data;\n\t\t\tae->data_size = ubox->dataSize;\n\t\t\tentry = (GF_Box *) ae;\n\t\t}\n\t\telse {\n\t\t\tGF_GenericSampleEntryBox *ge = (GF_GenericSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRM);\n\t\t\tge->EntryType = ubox->type;\n\t\t\tge->data = ubox->data;\n\t\t\tge->data_size = ubox->dataSize;\n\t\t\tentry = (GF_Box *) ge;\n\t\t}\n\t\tubox->data = NULL;\n\t\tubox->dataSize = 0;\n\t\tgf_isom_box_del((GF_Box *)ubox);\n\t}\n\n\t/*get new track and insert clone*/\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media) goto exit;\n\n\t/*get or create the data ref*/\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) goto exit;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(the_file, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) goto exit;\n\t}\n\tif (!the_file->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\t/*overwrite dref*/\n\t((GF_SampleEntryBox *)entry)->dataReferenceIndex = dataRefIndex;\n\te = gf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, entry);\n\t*outDescriptionIndex = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\n\t/*also clone track w/h info*/\n    mtype = gf_isom_get_media_type(the_file, trackNumber);\n\tif (gf_isom_is_video_handler_type(mtype) ) {\n\t\tgf_isom_set_visual_info(the_file, trackNumber, (*outDescriptionIndex), ((GF_VisualSampleEntryBox*)entry)->Width, ((GF_VisualSampleEntryBox*)entry)->Height);\n\t}\n\treturn e;\n\nexit:\n\tgf_isom_box_del(entry);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_new_generic_sample_description(GF_ISOFile *movie, u32 trackNumber, const char *URLname, const char *URNname, GF_GenericSampleDescription *udesc, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu8 **wrap_data;\n\tu32 *wrap_size;\n\tu32 dataRefIndex;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !udesc) return GF_BAD_PARAM;\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(movie, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (gf_isom_is_video_handler_type(trak->Media->handler->handlerType)) {\n\t\tGF_GenericVisualSampleEntryBox *entry;\n\t\t//create a new entry\n\t\tentry = (GF_GenericVisualSampleEntryBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRV);\n\t\tif (!entry) return GF_OUT_OF_MEM;\n\n\t\tif (!udesc->codec_tag) {\n\t\t\tentry->EntryType = GF_ISOM_BOX_TYPE_UUID;\n\t\t\tmemcpy(entry->uuid, udesc->UUID, sizeof(bin128));\n\t\t} else {\n\t\t\tentry->EntryType = udesc->codec_tag;\n\t\t}\n\t\tif (entry->EntryType == 0) {\n\t\t\tgf_isom_box_del((GF_Box *)entry);\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\n\t\tentry->dataReferenceIndex = dataRefIndex;\n\t\tentry->vendor = udesc->vendor_code;\n\t\tentry->version = udesc->version;\n\t\tentry->revision = udesc->revision;\n\t\tentry->temporal_quality = udesc->temporal_quality;\n\t\tentry->spatial_quality = udesc->spatial_quality;\n\t\tentry->Width = udesc->width;\n\t\tentry->Height = udesc->height;\n\t\tstrcpy(entry->compressor_name, udesc->compressor_name);\n\t\tentry->color_table_index = -1;\n\t\tentry->frames_per_sample = 1;\n\t\tentry->horiz_res = udesc->h_res ? udesc->h_res : 0x00480000;\n\t\tentry->vert_res = udesc->v_res ? udesc->v_res : 0x00480000;\n\t\tentry->bit_depth = udesc->depth ? udesc->depth : 0x18;\n\t\twrap_data = &entry->data;\n\t\twrap_size = &entry->data_size;\n\t\te = gf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, entry);\n\t}\n\telse if (trak->Media->handler->handlerType==GF_ISOM_MEDIA_AUDIO) {\n\t\tGF_GenericAudioSampleEntryBox *gena;\n\t\t//create a new entry\n\t\tgena = (GF_GenericAudioSampleEntryBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRA);\n\t\tif (!gena) return GF_OUT_OF_MEM;\n\n\t\tif (!udesc->codec_tag) {\n\t\t\tgena->EntryType = GF_ISOM_BOX_TYPE_UUID;\n\t\t\tmemcpy(gena->uuid, udesc->UUID, sizeof(bin128));\n\t\t} else {\n\t\t\tgena->EntryType = udesc->codec_tag;\n\t\t}\n\t\tif (gena->EntryType == 0) {\n\t\t\tgf_isom_box_del((GF_Box *)gena);\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\n\t\tgena->dataReferenceIndex = dataRefIndex;\n\t\tgena->vendor = udesc->vendor_code;\n\t\tgena->version = udesc->version;\n\t\tgena->revision = udesc->revision;\n\t\tgena->bitspersample = udesc->bits_per_sample ? udesc->bits_per_sample : 16;\n\t\tgena->channel_count = udesc->nb_channels ? udesc->nb_channels : 2;\n\t\tgena->samplerate_hi = udesc->samplerate;\n\t\tgena->samplerate_lo = 0;\n\t\tgena->qtff_mode = udesc->is_qtff ? GF_ISOM_AUDIO_QTFF_ON_NOEXT : GF_ISOM_AUDIO_QTFF_NONE;\n\t\tif (gena->EntryType==GF_QT_SUBTYPE_LPCM) {\n\t\t\tgena->version = 2;\n\t\t\tgena->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_EXT_VALID;\n\t\t\tGF_BitStream *bs = gf_bs_new(gena->extensions, 36, GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_u32(bs, 72);\n\t\t\tgf_bs_write_double(bs, udesc->samplerate);\n\t\t\tgf_bs_write_u32(bs, udesc->nb_channels);\n\t\t\tgf_bs_write_u32(bs, 0x7F000000);\n\t\t\tgf_bs_write_u32(bs, gena->bitspersample);\n\t\t\tgf_bs_write_u32(bs, udesc->lpcm_flags);\n\t\t\tgf_bs_write_u32(bs, udesc->nb_channels*gena->bitspersample/8); //constBytesPerAudioPacket\n\t\t\tgf_bs_write_u32(bs, 1); //constLPCMFramesPerAudioPacket\n\t\t\tgf_bs_del(bs);\n\t\t\tgena->revision = 0;\n\t\t\tgena->vendor = 0;\n\t\t\tgena->channel_count = 3;\n\t\t\tgena->bitspersample = 16;\n\t\t\tgena->compression_id = 0xFFFE;\n\t\t\tgena->packet_size = 0;\n\t\t\tgena->samplerate_hi = 1;\n\t\t} else if (udesc->is_qtff) {\n\t\t\tGF_Box *b = gf_isom_box_new_parent(&gena->child_boxes, GF_QT_BOX_TYPE_WAVE);\n\t\t\tGF_ChromaInfoBox *enda = (GF_ChromaInfoBox*) gf_isom_box_new_parent(&b->child_boxes, GF_QT_BOX_TYPE_ENDA);\n\t\t\t((GF_ChromaInfoBox *)enda)->chroma = (udesc->lpcm_flags & (1<<1)) ? 0 : 1;\n\n\t\t\tGF_UnknownBox *term = (GF_UnknownBox*) gf_isom_box_new_parent(&b->child_boxes, GF_ISOM_BOX_TYPE_UNKNOWN);\n\t\t\tif (term) term->original_4cc = 0;\n\t\t}\n\n\t\twrap_data = &gena->data;\n\t\twrap_size = &gena->data_size;\n\t\te = gf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, gena);\n\t}\n\telse {\n\t\tGF_GenericSampleEntryBox *genm;\n\t\t//create a new entry\n\t\tgenm = (GF_GenericSampleEntryBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRM);\n\t\tif (!genm) return GF_OUT_OF_MEM;\n\n\t\tif (!udesc->codec_tag) {\n\t\t\tgenm->EntryType = GF_ISOM_BOX_TYPE_UUID;\n\t\t\tmemcpy(genm->uuid, udesc->UUID, sizeof(bin128));\n\t\t} else {\n\t\t\tgenm->EntryType = udesc->codec_tag;\n\t\t}\n\t\tif (genm->EntryType == 0) {\n\t\t\tgf_isom_box_del((GF_Box *)genm);\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t\tgenm->dataReferenceIndex = dataRefIndex;\n\t\twrap_data = &genm->data;\n\t\twrap_size = &genm->data_size;\n\t\te = gf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, genm);\n\t}\n\t*outDescriptionIndex = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\n\tif (udesc->extension_buf && udesc->extension_buf_size) {\n\t\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tif (udesc->ext_box_wrap) {\n\t\t\tgf_bs_write_u32(bs, 8+udesc->extension_buf_size);\n\t\t\tgf_bs_write_u32(bs, udesc->ext_box_wrap);\n\t\t}\n\t\tgf_bs_write_data(bs, udesc->extension_buf, udesc->extension_buf_size);\n\t\tgf_bs_get_content(bs, wrap_data, wrap_size);\n\t\tgf_bs_del(bs);\n\t}\n\treturn e;\n}\n\n//use carefully. Very useful when you made a lot of changes (IPMP, IPI, OCI, ...)\n//THIS WILL REPLACE THE WHOLE DESCRIPTOR ...\n#if 0 //unused\n/*change the data field of an unknown sample description*/\nGF_Err gf_isom_change_generic_sample_description(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, GF_GenericSampleDescription *udesc)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_GenericVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !StreamDescriptionIndex) return GF_BAD_PARAM;\n\n\tentry = (GF_GenericVisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tif (entry->type == GF_ISOM_BOX_TYPE_GNRV) {\n\t\tentry->vendor = udesc->vendor_code;\n\t\tentry->version = udesc->version;\n\t\tentry->revision = udesc->revision;\n\t\tentry->temporal_quality = udesc->temporal_quality;\n\t\tentry->spatial_quality = udesc->spatial_quality;\n\t\tentry->Width = udesc->width;\n\t\tentry->Height = udesc->height;\n\t\tstrcpy(entry->compressor_name, udesc->compressor_name);\n\t\tentry->color_table_index = -1;\n\t\tentry->frames_per_sample = 1;\n\t\tentry->horiz_res = udesc->h_res ? udesc->h_res : 0x00480000;\n\t\tentry->vert_res = udesc->v_res ? udesc->v_res : 0x00480000;\n\t\tentry->bit_depth = udesc->depth ? udesc->depth : 0x18;\n\t\tif (entry->data) gf_free(entry->data);\n\t\tentry->data = NULL;\n\t\tentry->data_size = 0;\n\t\tif (udesc->extension_buf && udesc->extension_buf_size) {\n\t\t\tentry->data = (char*)gf_malloc(sizeof(char) * udesc->extension_buf_size);\n\t\t\tif (!entry->data) {\n\t\t\t\tgf_isom_box_del((GF_Box *) entry);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tmemcpy(entry->data, udesc->extension_buf, udesc->extension_buf_size);\n\t\t\tentry->data_size = udesc->extension_buf_size;\n\t\t}\n\t\treturn GF_OK;\n\t} else if (entry->type == GF_ISOM_BOX_TYPE_GNRA) {\n\t\tGF_GenericAudioSampleEntryBox *gena = (GF_GenericAudioSampleEntryBox *)entry;\n\t\tgena->vendor = udesc->vendor_code;\n\t\tgena->version = udesc->version;\n\t\tgena->revision = udesc->revision;\n\t\tgena->bitspersample = udesc->bits_per_sample ? udesc->bits_per_sample : 16;\n\t\tgena->channel_count = udesc->nb_channels ? udesc->nb_channels : 2;\n\t\tgena->samplerate_hi = udesc->samplerate;\n\t\tgena->samplerate_lo = 0;\n\t\tif (gena->data) gf_free(gena->data);\n\t\tgena->data = NULL;\n\t\tgena->data_size = 0;\n\n\t\tif (udesc->extension_buf && udesc->extension_buf_size) {\n\t\t\tgena->data = (char*)gf_malloc(sizeof(char) * udesc->extension_buf_size);\n\t\t\tif (!gena->data) {\n\t\t\t\tgf_isom_box_del((GF_Box *) gena);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tmemcpy(gena->data, udesc->extension_buf, udesc->extension_buf_size);\n\t\t\tgena->data_size = udesc->extension_buf_size;\n\t\t}\n\t\treturn GF_OK;\n\t} else if (entry->type == GF_ISOM_BOX_TYPE_GNRM) {\n\t\tGF_GenericSampleEntryBox *genm = (GF_GenericSampleEntryBox *)entry;\n\t\tif (genm->data) gf_free(genm->data);\n\t\tgenm->data = NULL;\n\t\tgenm->data_size = 0;\n\n\t\tif (udesc->extension_buf && udesc->extension_buf_size) {\n\t\t\tgenm->data = (char*)gf_malloc(sizeof(char) * udesc->extension_buf_size);\n\t\t\tif (!genm->data) {\n\t\t\t\tgf_isom_box_del((GF_Box *) genm);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tmemcpy(genm->data, udesc->extension_buf, udesc->extension_buf_size);\n\t\t\tgenm->data_size = udesc->extension_buf_size;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\treturn GF_BAD_PARAM;\n}\n#endif\n\n#if 0\n/*removes given stream description*/\nGF_Err gf_isom_remove_sample_description(GF_ISOFile *movie, u32 trackNumber, u32 streamDescIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_Box *entry;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !streamDescIndex) return GF_BAD_PARAM;\n\tentry = (GF_Box*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, streamDescIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tgf_list_rem(trak->Media->information->sampleTable->SampleDescription->child_boxes, streamDescIndex-1);\n\tgf_isom_box_del(entry);\n\treturn GF_OK;\n}\n#endif\n\n//sets a track reference\nGF_EXPORT\nGF_Err gf_isom_set_track_reference(GF_ISOFile *the_file, u32 trackNumber, u32 referenceType, GF_ISOTrackID ReferencedTrackID)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceBox *tref;\n\tGF_TrackReferenceTypeBox *dpnd;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//no tref, create one\n\ttref = trak->References;\n\tif (!tref) {\n\t\ttref = (GF_TrackReferenceBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TREF);\n\t\tif (!tref) return GF_OUT_OF_MEM;\n\t\te = trak_on_child_box((GF_Box*)trak, (GF_Box *) tref, GF_FALSE);\n\t\tif (e) return e;\n\t}\n\t//find a ref of the given type\n\te = Track_FindRef(trak, referenceType, &dpnd);\n\tif (e) return e;\n\n\tif (!dpnd) {\n\t\tdpnd = (GF_TrackReferenceTypeBox *) gf_isom_box_new_parent(&tref->child_boxes, GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!dpnd) return GF_OUT_OF_MEM;\n\t\tdpnd->reference_type = referenceType;\n\t}\n\t//add the ref\n\treturn reftype_AddRefTrack(dpnd, ReferencedTrackID, NULL);\n}\n\nGF_EXPORT\nGF_Err gf_isom_purge_track_reference(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *ref;\n\tu32 i=0;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//no tref, nothing to remove\n\tif (!trak->References) return GF_OK;\n\n\twhile ((ref = gf_list_enum(trak->References->child_boxes, &i))) {\n\t\tu32 k;\n\t\tif (!ref->reference_type) continue;\n\n\t\tfor (k=0; k<ref->trackIDCount; k++) {\n\t\t\tu32 tk = gf_isom_get_track_by_id(the_file, ref->trackIDs[k]);\n\t\t\tif (!tk) {\n\t\t\t\tmemmove(&ref->trackIDs[k], &ref->trackIDs[k+1], ref->trackIDCount-k-1);\n\t\t\t\tk--;\n\t\t\t\tref->trackIDCount--;\n\t\t\t}\n\t\t}\n\t\tif (!ref->trackIDCount) {\n\t\t\ti--;\n\t\t\tgf_isom_box_del_parent(&trak->References->child_boxes, (GF_Box *) ref);\n\t\t}\n\t}\n\tif (!trak->References->child_boxes || !gf_list_count(trak->References->child_boxes)) {\n\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *) trak->References);\n\t\ttrak->References = NULL;\n\t}\n\treturn GF_OK;\n}\n\n//sets a track reference\nGF_EXPORT\nGF_Err gf_isom_remove_track_references(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (trak->References) {\n\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->References);\n\t\ttrak->References = NULL;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_track_reference(GF_ISOFile *isom_file, u32 trackNumber, u32 ref_type)\n{\n\tGF_TrackBox *trak;\n\tu32 i=0;\n\tGF_TrackReferenceTypeBox *ref;\n\ttrak = gf_isom_get_track_from_file(isom_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (!trak->References) return GF_OK;\n\twhile ((ref = gf_list_enum(trak->References->child_boxes, &i))) {\n\t\tif (ref->reference_type == ref_type) {\n\t\t\tgf_isom_box_del_parent(&trak->References->child_boxes, (GF_Box *)ref);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!gf_list_count(trak->References->child_boxes)) {\n\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->References);\n\t\ttrak->References = NULL;\n\t}\n\treturn GF_OK;\n\n}\n\n//changes track ID\nGF_EXPORT\nGF_Err gf_isom_set_track_id(GF_ISOFile *movie, u32 trackNumber, GF_ISOTrackID trackID)\n{\n\tGF_TrackReferenceTypeBox *ref;\n\tGF_TrackBox *trak, *a_trak;\n\tu32 i, j, k;\n\n\tif (!movie) return GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (trak && (trak->Header->trackID==trackID)) return GF_OK;\n\ta_trak = gf_isom_get_track_from_id(movie->moov, trackID);\n\tif (!trak || a_trak) return GF_BAD_PARAM;\n\n\t/*rewrite all dependencies*/\n\ti=0;\n\twhile ((a_trak = (GF_TrackBox*)gf_list_enum(movie->moov->trackList, &i))) {\n\t\tif (!a_trak->References) continue;\n\t\tj=0;\n\t\twhile ((ref = (GF_TrackReferenceTypeBox *)gf_list_enum(a_trak->References->child_boxes, &j))) {\n\t\t\tfor (k=0; k<ref->trackIDCount; k++) {\n\t\t\t\tif (ref->trackIDs[k]==trak->Header->trackID) {\n\t\t\t\t\tref->trackIDs[k] = trackID;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*and update IOD if any*/\n\tif (movie->moov->iods && movie->moov->iods->descriptor) {\n\t\tGF_ES_ID_Inc *inc;\n\t\tGF_IsomObjectDescriptor *od = (GF_IsomObjectDescriptor *)movie->moov->iods->descriptor;\n\n\t\ti=0;\n\t\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(od->ES_ID_IncDescriptors, &i))) {\n\t\t\tif (inc->trackID==trak->Header->trackID) inc->trackID = trackID;\n\t\t}\n\t}\n\ttrak->Header->trackID = trackID;\n\tupdate_next_track_id(movie);\n\treturn GF_OK;\n}\n\n/*force to rewrite all dependencies when the trackID of referenced track changes*/\nGF_EXPORT\nGF_Err gf_isom_rewrite_track_dependencies(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackReferenceTypeBox *ref;\n\tGF_TrackBox *trak, *a_trak;\n\tu32 i, k;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak)\n\t\treturn GF_BAD_PARAM;\n\tif (!trak->References)\n\t\treturn GF_OK;\n\n\ti=0;\n\twhile ((ref = (GF_TrackReferenceTypeBox *)gf_list_enum(trak->References->child_boxes, &i))) {\n\t\tfor (k=0; k < ref->trackIDCount; k++) {\n\t\t\ta_trak = gf_isom_get_track_from_original_id(movie->moov, ref->trackIDs[k], trak->originalFile);\n\t\t\tif (a_trak) {\n\t\t\t\tref->trackIDs[k] = a_trak->Header->trackID;\n\t\t\t} else {\n\t\t\t\ta_trak = gf_isom_get_track_from_id(movie->moov, ref->trackIDs[k]);\n\t\t\t\t/*we should have a track with no original ID (not imported) - should we rewrite the dependency ?*/\n\t\t\t\tif (! a_trak || a_trak->originalID) return GF_BAD_PARAM;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\n#if 0 //unused\n\n/*! changes the sample description index of a sample\n\\param isom_file the destination ISO file\n\\param trackNumber the destination track\n\\param sampleNum the target sample number\n\\param fnewSampleDescIndex the new sample description index to assign to the sample\n\\return error if any\n*/\nGF_EXPORT\nGF_Err gf_isom_change_sample_desc_index(GF_ISOFile *the_file, u32 trackNumber, u32 sample_number, u32 newSampleDescIndex)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !sample_number || !newSampleDescIndex) return GF_BAD_PARAM;\n\tif (!trak->is_unpacked) {\n\t\tunpack_track(trak);\n\t}\n\tif (!trak->Media->information->sampleTable->SampleToChunk) return GF_BAD_PARAM;\n\tif (trak->Media->information->sampleTable->SampleToChunk->nb_entries < sample_number) return GF_BAD_PARAM;\n\ttrak->Media->information->sampleTable->SampleToChunk->entries[sample_number-1].sampleDescriptionIndex = newSampleDescIndex;\n\treturn GF_OK;\n}\n\n/*modify CTS offset of a given sample (used for B-frames) - MUST be called in unpack mode only*/\nGF_EXPORT\nGF_Err gf_isom_modify_cts_offset(GF_ISOFile *the_file, u32 trackNumber, u32 sample_number, u32 offset)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->CompositionOffset) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->CompositionOffset->unpack_mode) return GF_BAD_PARAM;\n\t/*we're in unpack mode: one entry per sample*/\n\ttrak->Media->information->sampleTable->CompositionOffset->entries[sample_number - 1].decodingOffset = offset;\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_shift_cts_offset(GF_ISOFile *the_file, u32 trackNumber, s32 offset_shift)\n{\n\tu32 i;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->CompositionOffset) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->CompositionOffset->unpack_mode) return GF_BAD_PARAM;\n\n\tGF_CompositionOffsetBox *ctso = trak->Media->information->sampleTable->CompositionOffset;\n\tfor (i=0; i<ctso->nb_entries; i++) {\n\t\ts64 new_ts = ctso->entries[i].decodingOffset;\n\t\tnew_ts -= offset_shift;\n\t\t/*we're in unpack mode: one entry per sample*/\n\t\tctso->entries[i].decodingOffset = (s32) new_ts;\n\t}\n\tif (trak->Media->mediaHeader->duration >= -offset_shift) {\n\t\ts64 new_dur = trak->Media->mediaHeader->duration;\n\t\tnew_dur -= offset_shift;\n\t\tif (new_dur<0) new_dur = 0;\n\t\ttrak->Media->mediaHeader->duration = (u32) new_dur;\n\t}\n\treturn GF_OK;\n}\n\n#if 0 //unused\nGF_Err gf_isom_remove_cts_info(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_SampleTableBox *stbl;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl->CompositionOffset) return GF_OK;\n\n\tgf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *)stbl->CompositionOffset);\n\tstbl->CompositionOffset = NULL;\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_set_cts_packing(GF_ISOFile *the_file, u32 trackNumber, Bool unpack)\n{\n\tGF_Err e;\n\tGF_Err stbl_repackCTS(GF_CompositionOffsetBox *ctts);\n\tGF_Err stbl_unpackCTS(GF_SampleTableBox *stbl);\n\tGF_SampleTableBox *stbl;\n\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (unpack) {\n\t\tif (!stbl->CompositionOffset) {\n\t\t\tstbl->CompositionOffset = (GF_CompositionOffsetBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_CTTS);\n\t\t\tif (!stbl->CompositionOffset) return GF_OUT_OF_MEM;\n\t\t}\n\t\te = stbl_unpackCTS(stbl);\n\t} else {\n\t\tif (!stbl->CompositionOffset) return GF_OK;\n\t\te = stbl_repackCTS(stbl->CompositionOffset);\n\t}\n\tif (e) return e;\n\treturn SetTrackDuration(trak);\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_matrix(GF_ISOFile *the_file, u32 trackNumber, s32 matrix[9])\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Header) return GF_BAD_PARAM;\n\tmemcpy(trak->Header->matrix, matrix, sizeof(trak->Header->matrix));\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_layout_info(GF_ISOFile *the_file, u32 trackNumber, u32 width, u32 height, s32 translation_x, s32 translation_y, s16 layer)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Header) return GF_BAD_PARAM;\n\ttrak->Header->width = width;\n\ttrak->Header->height = height;\n\ttrak->Header->matrix[6] = translation_x;\n\ttrak->Header->matrix[7] = translation_y;\n\ttrak->Header->layer = layer;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_media_timescale(GF_ISOFile *the_file, u32 trackNumber, u32 newTS, u32 new_tsinc, u32 force_rescale_type)\n{\n\tDouble scale;\n\tu32 old_ts_inc=0;\n\tu32 old_timescale;\n\tGF_TrackBox *trak;\n\tGF_SampleTableBox *stbl;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->mediaHeader) return GF_BAD_PARAM;\n\tif ((trak->Media->mediaHeader->timeScale==newTS) && !new_tsinc)\n\t\treturn GF_EOS;\n\n\tif (!newTS) newTS = trak->Media->mediaHeader->timeScale;\n\tscale = newTS;\n\tscale /= trak->Media->mediaHeader->timeScale;\n\told_timescale = trak->Media->mediaHeader->timeScale;\n\ttrak->Media->mediaHeader->timeScale = newTS;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (new_tsinc) {\n\t\tu32 i;\n\t\tif (!stbl->TimeToSample || !stbl->TimeToSample->nb_entries)\n\t\t\treturn GF_BAD_PARAM;\n\n\t\tfor (i=0; i<stbl->TimeToSample->nb_entries; i++) {\n\t\t\tif (!old_ts_inc)\n\t\t\t\told_ts_inc = stbl->TimeToSample->entries[i].sampleDelta;\n\t\t\telse if (old_ts_inc<stbl->TimeToSample->entries[i].sampleDelta)\n\t\t\t\told_ts_inc = stbl->TimeToSample->entries[i].sampleDelta;\n\t\t}\n\n\t\tif ((old_timescale==newTS) && (old_ts_inc==new_tsinc) && (force_rescale_type!=2) )\n\t\t\treturn GF_EOS;\n\n\t\tif (!force_rescale_type)\n\t\t\tforce_rescale_type = 1;\n\t\telse if (force_rescale_type==2) {\n\t\t\tgf_free(stbl->TimeToSample->entries);\n\t\t\tstbl->TimeToSample->alloc_size = 1;\n\t\t\tstbl->TimeToSample->nb_entries = 1;\n\t\t\tstbl->TimeToSample->entries = gf_malloc(sizeof(GF_SttsEntry));\n\t\t\tstbl->TimeToSample->entries[0].sampleDelta = new_tsinc;\n\t\t\tstbl->TimeToSample->entries[0].sampleCount = stbl->SampleSize->sampleCount;\n\t\t}\n\n\n\t\tfor (i=0; i<stbl->TimeToSample->nb_entries; i++) {\n\t\t\tstbl->TimeToSample->entries[i].sampleDelta = new_tsinc;\n\t\t}\n\n\t\tif (stbl->CompositionOffset) {\n\t\t\tfor (i=0; i<stbl->CompositionOffset->nb_entries; i++) {\n\t\t\t\tu32 old_offset = stbl->CompositionOffset->entries[i].decodingOffset;\n\t\t\t\tif (force_rescale_type==2) {\n\t\t\t\t\tu32 val = old_offset ;\n\t\t\t\t\t//get number of TS delta\n\t\t\t\t\told_offset /= old_ts_inc;\n\t\t\t\t\tif (old_offset * old_ts_inc < val)\n\t\t\t\t\t\told_offset++;\n\t\t\t\t\told_offset *= new_tsinc;\n\t\t\t\t} else {\n\t\t\t\t\told_offset *= new_tsinc;\n\t\t\t\t\told_offset /= old_ts_inc;\n\t\t\t\t}\n\t\t\t\tstbl->CompositionOffset->entries[i].decodingOffset = old_offset;\n\t\t\t}\n\t\t}\n\n#define RESCALE_TSVAL(_tsval) {\\\n\t\t\ts64 val = ((s64) _tsval) * new_tsinc;\\\n\t\t\tval /= old_ts_inc;\\\n\t\t\t_tsval = (s32) val;\\\n\t\t}\n\n\t\tif (stbl->CompositionToDecode) {\n\t\t\tRESCALE_TSVAL(stbl->CompositionToDecode->compositionEndTime)\n\t\t\tRESCALE_TSVAL(stbl->CompositionToDecode->compositionStartTime)\n\t\t\tRESCALE_TSVAL(stbl->CompositionToDecode->compositionToDTSShift)\n\t\t\tRESCALE_TSVAL(stbl->CompositionToDecode->greatestDecodeToDisplayDelta)\n\t\t\tRESCALE_TSVAL(stbl->CompositionToDecode->leastDecodeToDisplayDelta)\n\t\t}\n\t\tif (trak->editBox) {\n\t\t\tGF_EdtsEntry *ent;\n\t\t\ti=0;\n\t\t\twhile ((ent = (GF_EdtsEntry*)gf_list_enum(trak->editBox->editList->entryList, &i))) {\n\t\t\t\tRESCALE_TSVAL(ent->mediaTime)\n\t\t\t}\n\t\t}\n#undef RESCALE_TSVAL\n\t\t//force recompute of duration\n\t\ttrak->Media->mediaHeader->duration=0;\n\t\treturn SetTrackDuration(trak);\n\t}\n\n\t//rescale timings\n\tu32 i, k, idx, last_delta;\n\tu64 cur_dts;\n\tu64*DTSs = NULL;\n\ts64*CTSs = NULL;\n\n\tif (trak->editBox) {\n\t\tGF_EdtsEntry *ent;\n\t\ti=0;\n\t\twhile ((ent = (GF_EdtsEntry*)gf_list_enum(trak->editBox->editList->entryList, &i))) {\n\t\t\t//only update if media time is >=0 (neg means empty edit)\n\t\t\tif (ent->mediaTime>=0)\n\t\t\t\tent->mediaTime = (u32) (scale*ent->mediaTime);\n\t\t}\n\t}\n\tif (! stbl || !stbl->TimeToSample || !stbl->TimeToSample->nb_entries) {\n\t\treturn SetTrackDuration(trak);\n\t}\n\n\tidx = 0;\n\tcur_dts = 0;\n\t//unpack the DTSs\n\tDTSs = (u64*)gf_malloc(sizeof(u64) * (stbl->SampleSize->sampleCount) );\n\tif (!DTSs) return GF_OUT_OF_MEM;\n\n\tCTSs = NULL;\n\tif (stbl->CompositionOffset) {\n\t\tCTSs = (s64*)gf_malloc(sizeof(u64) * (stbl->SampleSize->sampleCount) );\n\t\tif (!CTSs) return GF_OUT_OF_MEM;\n\t}\n\n\tfor (i=0; i<stbl->TimeToSample->nb_entries; i++) {\n\t\tfor (k=0; k<stbl->TimeToSample->entries[i].sampleCount; k++) {\n\t\t\tcur_dts += stbl->TimeToSample->entries[i].sampleDelta;\n\t\t\tDTSs[idx] = (u64) (cur_dts * scale);\n\n\t\t\tif (stbl->CompositionOffset) {\n\t\t\t\ts32 cts_o;\n\t\t\t\tstbl_GetSampleCTS(stbl->CompositionOffset, idx+1, &cts_o);\n\t\t\t\tCTSs[idx] = (s64) ( ((s64) cur_dts + cts_o) * scale);\n\t\t\t}\n\t\t\tidx++;\n\t\t}\n\t}\n\tlast_delta = (u32) (stbl->TimeToSample->entries[stbl->TimeToSample->nb_entries-1].sampleDelta * scale);\n\n\t//repack DTS\n\tif (stbl->SampleSize->sampleCount) {\n\t\tstbl->TimeToSample->entries = gf_realloc(stbl->TimeToSample->entries, sizeof(GF_SttsEntry)*stbl->SampleSize->sampleCount);\n\t\tmemset(stbl->TimeToSample->entries, 0, sizeof(GF_SttsEntry)*stbl->SampleSize->sampleCount);\n\t\tstbl->TimeToSample->entries[0].sampleDelta = (u32) DTSs[0];\n\t\tstbl->TimeToSample->entries[0].sampleCount = 1;\n\t\tidx=0;\n\t\tfor (i=1; i< stbl->SampleSize->sampleCount - 1; i++) {\n\t\t\tif (DTSs[i+1] - DTSs[i] == stbl->TimeToSample->entries[idx].sampleDelta) {\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleCount++;\n\t\t\t} else {\n\t\t\t\tidx++;\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleDelta = (u32) ( DTSs[i+1] - DTSs[i] );\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleCount=1;\n\t\t\t}\n\t\t}\n\t\tif (stbl->SampleSize->sampleCount > 1) {\n\t\t\t//add the sample delta for the last sample\n\t\t\tif (stbl->TimeToSample->entries[idx].sampleDelta == last_delta) {\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleCount++;\n\t\t\t} else {\n\t\t\t\tidx++;\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleDelta = last_delta;\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleCount=1;\n\t\t\t}\n\n\t\t\tstbl->TimeToSample->nb_entries = idx+1;\n\t\t\tstbl->TimeToSample->entries = gf_realloc(stbl->TimeToSample->entries, sizeof(GF_SttsEntry)*stbl->TimeToSample->nb_entries);\n\t\t}\n\t}\n\n\tif (CTSs && stbl->SampleSize->sampleCount>0) {\n\t\t//repack CTS\n\t\tstbl->CompositionOffset->entries = gf_realloc(stbl->CompositionOffset->entries, sizeof(GF_DttsEntry)*stbl->SampleSize->sampleCount);\n\t\tmemset(stbl->CompositionOffset->entries, 0, sizeof(GF_DttsEntry)*stbl->SampleSize->sampleCount);\n\t\tstbl->CompositionOffset->entries[0].decodingOffset = (s32) (CTSs[0] - DTSs[0]);\n\t\tstbl->CompositionOffset->entries[0].sampleCount = 1;\n\t\tidx=0;\n\t\tfor (i=1; i< stbl->SampleSize->sampleCount; i++) {\n\t\t\ts32 cts_o = (s32) (CTSs[i] - DTSs[i]);\n\t\t\tif (cts_o == stbl->CompositionOffset->entries[idx].decodingOffset) {\n\t\t\t\tstbl->CompositionOffset->entries[idx].sampleCount++;\n\t\t\t} else {\n\t\t\t\tidx++;\n\t\t\t\tstbl->CompositionOffset->entries[idx].decodingOffset = cts_o;\n\t\t\t\tstbl->CompositionOffset->entries[idx].sampleCount=1;\n\t\t\t}\n\t\t}\n\t\tstbl->CompositionOffset->nb_entries = idx+1;\n\t\tstbl->CompositionOffset->entries = gf_realloc(stbl->CompositionOffset->entries, sizeof(GF_DttsEntry)*stbl->CompositionOffset->nb_entries);\n\n\t\tgf_free(CTSs);\n\t}\n\tgf_free(DTSs);\n\n\tif (stbl->CompositionToDecode) {\n\t\tstbl->CompositionToDecode->compositionEndTime = (s32) (stbl->CompositionToDecode->compositionEndTime * scale);\n\t\tstbl->CompositionToDecode->compositionStartTime = (s32)(stbl->CompositionToDecode->compositionStartTime * scale);\n\t\tstbl->CompositionToDecode->compositionToDTSShift = (s32)(stbl->CompositionToDecode->compositionToDTSShift * scale);\n\t\tstbl->CompositionToDecode->greatestDecodeToDisplayDelta = (s32)(stbl->CompositionToDecode->greatestDecodeToDisplayDelta * scale);\n\t\tstbl->CompositionToDecode->leastDecodeToDisplayDelta = (s32)(stbl->CompositionToDecode->leastDecodeToDisplayDelta * scale);\n\t}\n\n\treturn SetTrackDuration(trak);\n}\n\nGF_EXPORT\nBool gf_isom_box_equal(GF_Box *a, GF_Box *b)\n{\n\tBool ret;\n\tu8 *data1, *data2;\n\tu32 data1_size, data2_size;\n\tGF_BitStream *bs;\n\n\tif (a == b) return GF_TRUE;\n\tif (!a || !b) return GF_FALSE;\n\n\tdata1 = data2 = NULL;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_box_size(a);\n\tgf_isom_box_write(a, bs);\n\tgf_bs_get_content(bs, &data1, &data1_size);\n\tgf_bs_del(bs);\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_box_size(b);\n\tgf_isom_box_write(b, bs);\n\tgf_bs_get_content(bs, &data2, &data2_size);\n\tgf_bs_del(bs);\n\n\tret = GF_FALSE;\n\tif (data1_size == data2_size) {\n\t\tret = (memcmp(data1, data2, sizeof(char)*data1_size) == 0) ? GF_TRUE : GF_FALSE;\n\t}\n\tgf_free(data1);\n\tgf_free(data2);\n\treturn ret;\n}\n\nstatic u32 base_sample_entry_type(u32 type)\n{\n\tif (type==GF_ISOM_SUBTYPE_DVH1) return GF_ISOM_SUBTYPE_HVC1;\n\tif (type==GF_ISOM_SUBTYPE_DVHE) return GF_ISOM_SUBTYPE_HEV1;\n\tif (type==GF_ISOM_SUBTYPE_DVA1) return GF_ISOM_SUBTYPE_AVC_H264;\n\tif (type==GF_ISOM_SUBTYPE_DVAV) return GF_ISOM_SUBTYPE_AVC3_H264;\n\tif (type==GF_ISOM_SUBTYPE_DAV1) return GF_ISOM_SUBTYPE_AV01;\n\treturn type;\n}\n\nGF_EXPORT\nBool gf_isom_is_same_sample_description(GF_ISOFile *f1, u32 tk1, u32 sdesc_index1, GF_ISOFile *f2, u32 tk2, u32 sdesc_index2)\n{\n\tu32 i, count;\n\tGF_TrackBox *trak1, *trak2;\n\tGF_ESD *esd1, *esd2;\n\tBool need_memcmp, ret;\n\tGF_Box *a, *b;\n\n\t/*get orig sample desc and clone it*/\n\ttrak1 = gf_isom_get_track_from_file(f1, tk1);\n\tif (!trak1 || !trak1->Media) return GF_FALSE;\n\ttrak2 = gf_isom_get_track_from_file(f2, tk2);\n\tif (!trak2 || !trak2->Media) return GF_FALSE;\n\n\tif (trak1->Media->handler->handlerType != trak2->Media->handler->handlerType) return GF_FALSE;\n\tcount = gf_list_count(trak1->Media->information->sampleTable->SampleDescription->child_boxes);\n\tif (count != gf_list_count(trak2->Media->information->sampleTable->SampleDescription->child_boxes)) {\n\t\tif (!sdesc_index1 && !sdesc_index2) return GF_FALSE;\n\t}\n\n\tneed_memcmp = GF_TRUE;\n\tfor (i=0; i<count; i++) {\n\t\tu32 type1, type2;\n\t\tGF_SampleEntryBox *ent1 = (GF_SampleEntryBox *)gf_list_get(trak1->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\tGF_SampleEntryBox *ent2 = (GF_SampleEntryBox *)gf_list_get(trak2->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\n\t\tif (sdesc_index1) ent1 = (GF_SampleEntryBox *)gf_list_get(trak1->Media->information->sampleTable->SampleDescription->child_boxes, sdesc_index1 - 1);\n\t\tif (sdesc_index2) ent2 = (GF_SampleEntryBox *)gf_list_get(trak2->Media->information->sampleTable->SampleDescription->child_boxes, sdesc_index2 - 1);\n\n\t\tif (!ent1 || !ent2) return GF_FALSE;\n\t\tif (ent1->internal_type != ent2->internal_type) return GF_FALSE;\n\t\ttype1 = base_sample_entry_type(ent1->type);\n\t\ttype2 = base_sample_entry_type(ent2->type);\n\t\tif (type1 != type2) return GF_FALSE;\n\n\t\tswitch (ent1->type) {\n\t\t/*for MPEG-4 streams, only compare decSpecInfo (bitrate may not be the same but that's not an issue)*/\n\t\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tcase GF_ISOM_BOX_TYPE_ENCA:\n\t\tcase GF_ISOM_BOX_TYPE_ENCV:\n\t\tcase GF_ISOM_BOX_TYPE_RESV:\n\t\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\t\tMedia_GetESD(trak1->Media, sdesc_index1 ? sdesc_index1 : i+1, &esd1, GF_TRUE);\n\t\t\tMedia_GetESD(trak2->Media, sdesc_index2 ? sdesc_index2 : i+1, &esd2, GF_TRUE);\n\t\t\tif (!esd1 || !esd2) continue;\n\t\t\tneed_memcmp = GF_FALSE;\n\t\t\tif (esd1->decoderConfig->streamType != esd2->decoderConfig->streamType) return GF_FALSE;\n\t\t\tif (esd1->decoderConfig->objectTypeIndication != esd2->decoderConfig->objectTypeIndication) return GF_FALSE;\n\t\t\tif (!esd1->decoderConfig->decoderSpecificInfo && esd2->decoderConfig->decoderSpecificInfo) return GF_FALSE;\n\t\t\tif (esd1->decoderConfig->decoderSpecificInfo && !esd2->decoderConfig->decoderSpecificInfo) return GF_FALSE;\n\t\t\tif (!esd1->decoderConfig->decoderSpecificInfo || !esd2->decoderConfig->decoderSpecificInfo) continue;\n\t\t\tif (esd1->decoderConfig->decoderSpecificInfo->dataLength != esd2->decoderConfig->decoderSpecificInfo->dataLength)\n\t\t\t\treturn GF_FALSE;\n\t\t\tif (memcmp(esd1->decoderConfig->decoderSpecificInfo->data, esd2->decoderConfig->decoderSpecificInfo->data, sizeof(char)*esd1->decoderConfig->decoderSpecificInfo->dataLength)!=0) return GF_FALSE;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\t\treturn GF_TRUE;\n\t\tcase GF_ISOM_BOX_TYPE_AVC1:\n\t\tcase GF_ISOM_BOX_TYPE_AVC2:\n\t\tcase GF_ISOM_BOX_TYPE_AVC3:\n\t\tcase GF_ISOM_BOX_TYPE_AVC4:\n\t\tcase GF_ISOM_BOX_TYPE_SVC1:\n\t\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HEV1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC2:\n\t\tcase GF_ISOM_BOX_TYPE_HEV2:\n\t\tcase GF_ISOM_BOX_TYPE_LHE1:\n\t\tcase GF_ISOM_BOX_TYPE_LHV1:\n\t\tcase GF_ISOM_BOX_TYPE_AV01:\n\t\tcase GF_ISOM_BOX_TYPE_VVC1:\n\t\tcase GF_ISOM_BOX_TYPE_VVI1:\n\t\tcase GF_ISOM_BOX_TYPE_DVHE:\n\t\tcase GF_ISOM_BOX_TYPE_DVH1:\n\t\tcase GF_ISOM_BOX_TYPE_DVA1:\n\t\tcase GF_ISOM_BOX_TYPE_DVAV:\n\t\tcase GF_ISOM_BOX_TYPE_DAV1:\n\t\t{\n\t\t\tGF_MPEGVisualSampleEntryBox *avc1 = (GF_MPEGVisualSampleEntryBox *)ent1;\n\t\t\tGF_MPEGVisualSampleEntryBox *avc2 = (GF_MPEGVisualSampleEntryBox *)ent2;\n\n\t\t\tif (avc1->hevc_config)\n\t\t\t\ta = (GF_Box *) avc1->hevc_config;\n\t\t\telse if (avc1->lhvc_config)\n\t\t\t\ta = (GF_Box *) avc1->lhvc_config;\n\t\t\telse if (avc1->svc_config)\n\t\t\t\ta = (GF_Box *) avc1->svc_config;\n\t\t\telse if (avc1->mvc_config)\n\t\t\t\ta = (GF_Box *) avc1->mvc_config;\n\t\t\telse if (avc1->av1_config)\n\t\t\t\ta = (GF_Box *)avc1->av1_config;\n\t\t\telse\n\t\t\t\ta = (GF_Box *) avc1->avc_config;\n\n\t\t\tif (avc2->hevc_config)\n\t\t\t\tb = (GF_Box *) avc2->hevc_config;\n\t\t\telse if (avc2->lhvc_config)\n\t\t\t\tb = (GF_Box *) avc2->lhvc_config;\n\t\t\telse if (avc2->svc_config)\n\t\t\t\tb = (GF_Box *) avc2->svc_config;\n\t\t\telse if (avc2->mvc_config)\n\t\t\t\tb = (GF_Box *) avc2->mvc_config;\n\t\t\telse if (avc2->av1_config)\n\t\t\t\tb = (GF_Box *)avc2->av1_config;\n\t\t\telse\n\t\t\t\tb = (GF_Box *) avc2->avc_config;\n\n\t\t\treturn gf_isom_box_equal(a,b);\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_LSR1:\n\t\t{\n\t\t\tGF_LASeRSampleEntryBox *lsr1 = (GF_LASeRSampleEntryBox *)ent1;\n\t\t\tGF_LASeRSampleEntryBox *lsr2 = (GF_LASeRSampleEntryBox *)ent2;\n\t\t\tif (lsr1->lsr_config && lsr2->lsr_config\n\t\t\t        && lsr1->lsr_config->hdr && lsr2->lsr_config->hdr\n\t\t\t        && (lsr1->lsr_config->hdr_size==lsr2->lsr_config->hdr_size)\n\t\t\t        && !memcmp(lsr1->lsr_config->hdr, lsr2->lsr_config->hdr, lsr2->lsr_config->hdr_size)\n\t\t\t   ) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tbreak;\n#ifndef GPAC_DISABLE_VTT\n\t\tcase GF_ISOM_BOX_TYPE_WVTT:\n\t\t{\n\t\t\tGF_WebVTTSampleEntryBox *wvtt1 = (GF_WebVTTSampleEntryBox *)ent1;\n\t\t\tGF_WebVTTSampleEntryBox *wvtt2 = (GF_WebVTTSampleEntryBox *)ent2;\n\t\t\tif (wvtt1->config && wvtt2->config &&\n\t\t\t        (wvtt1->config->string && wvtt2->config->string && !strcmp(wvtt1->config->string, wvtt2->config->string))) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tbreak;\n#endif\n\t\tcase GF_ISOM_BOX_TYPE_STPP:\n\t\t{\n\t\t\tGF_MetaDataSampleEntryBox *stpp1 = (GF_MetaDataSampleEntryBox *)ent1;\n\t\t\tGF_MetaDataSampleEntryBox *stpp2 = (GF_MetaDataSampleEntryBox *)ent2;\n\t\t\tif (stpp1->xml_namespace && stpp2->xml_namespace && !strcmp(stpp1->xml_namespace, stpp2->xml_namespace)) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_SBTT:\n\t\t{\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_STXT:\n\t\t{\n\t\t\tGF_MetaDataSampleEntryBox *stxt1 = (GF_MetaDataSampleEntryBox *)ent1;\n\t\t\tGF_MetaDataSampleEntryBox *stxt2 = (GF_MetaDataSampleEntryBox *)ent2;\n\t\t\tif (stxt1->mime_type && stxt2->mime_type &&\n\t\t\t        ( (!stxt1->config && !stxt2->config) ||\n\t\t\t          (stxt1->config && stxt2->config && stxt1->config->config && stxt2->config->config &&\n\t\t\t           !strcmp(stxt1->config->config, stxt2->config->config)))) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tcase GF_ISOM_BOX_TYPE_MP3:\n\t\tcase GF_QT_SUBTYPE_RAW_AUD:\n\t\tcase GF_QT_SUBTYPE_TWOS:\n\t\tcase GF_QT_SUBTYPE_SOWT:\n\t\tcase GF_QT_SUBTYPE_FL32:\n\t\tcase GF_QT_SUBTYPE_FL64:\n\t\tcase GF_QT_SUBTYPE_IN24:\n\t\tcase GF_QT_SUBTYPE_IN32:\n\t\tcase GF_QT_SUBTYPE_ULAW:\n\t\tcase GF_QT_SUBTYPE_ALAW:\n\t\tcase GF_QT_SUBTYPE_ADPCM:\n\t\tcase GF_QT_SUBTYPE_IMA_ADPCM:\n\t\tcase GF_QT_SUBTYPE_DVCA:\n\t\tcase GF_QT_SUBTYPE_QDMC:\n\t\tcase GF_QT_SUBTYPE_QDMC2:\n\t\tcase GF_QT_SUBTYPE_QCELP:\n\t\tcase GF_QT_SUBTYPE_kMP3:\n\t\tcase GF_QT_SUBTYPE_APCH:\n\t\tcase GF_QT_SUBTYPE_APCO:\n\t\tcase GF_QT_SUBTYPE_APCN:\n\t\tcase GF_QT_SUBTYPE_APCS:\n\t\tcase GF_QT_SUBTYPE_AP4X:\n\t\tcase GF_QT_SUBTYPE_AP4H:\n\t\tcase GF_QT_SUBTYPE_RAW_VID:\n\t\tcase GF_QT_SUBTYPE_YUYV:\n\t\tcase GF_QT_SUBTYPE_UYVY:\n\t\tcase GF_QT_SUBTYPE_YUV444:\n\t\tcase GF_QT_SUBTYPE_YUVA444:\n\t\tcase GF_QT_SUBTYPE_YUV422_10:\n\t\tcase GF_QT_SUBTYPE_YUV444_10:\n\t\tcase GF_QT_SUBTYPE_YUV422_16:\n\t\tcase GF_QT_SUBTYPE_YUV420:\n\t\tcase GF_QT_SUBTYPE_I420:\n\t\tcase GF_QT_SUBTYPE_IYUV:\n\t\tcase GF_QT_SUBTYPE_YV12:\n\t\tcase GF_QT_SUBTYPE_YVYU:\n\t\tcase GF_QT_SUBTYPE_RGBA:\n\t\tcase GF_QT_SUBTYPE_ABGR:\n\t\tdefault:\n\t\t\tif (ent1->internal_type == GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t\t\tGF_VisualSampleEntryBox *vent1 = (GF_VisualSampleEntryBox *) ent1;\n\t\t\t\tGF_VisualSampleEntryBox *vent2 = (GF_VisualSampleEntryBox *) ent2;\n\t\t\t\tif (vent1->Width != vent2->Width) return GF_FALSE;\n\t\t\t\tif (vent1->Height != vent2->Height) return GF_FALSE;\n\t\t\t}\n\t\t\telse if (ent1->internal_type == GF_ISOM_SAMPLE_ENTRY_AUDIO) {\n\t\t\t\tGF_AudioSampleEntryBox *aent1 = (GF_AudioSampleEntryBox *) ent1;\n\t\t\t\tGF_AudioSampleEntryBox *aent2 = (GF_AudioSampleEntryBox *) ent2;\n\t\t\t\tif (aent1->samplerate_hi != aent2->samplerate_hi) return GF_FALSE;\n\t\t\t\tif (aent1->samplerate_lo != aent2->samplerate_lo) return GF_FALSE;\n\t\t\t\tif (aent1->channel_count != aent2->channel_count) return GF_FALSE;\n\t\t\t}\n\t\t\treturn GF_TRUE;\n\t\t}\n\n\t\tif (sdesc_index1 && sdesc_index2) break;\n\t}\n\tif (!need_memcmp) return GF_TRUE;\n\ta = (GF_Box *)trak1->Media->information->sampleTable->SampleDescription;\n\tb = (GF_Box *)trak2->Media->information->sampleTable->SampleDescription;\n\t//we ignore all bitrate boxes when comparing the box, disable their writing\n\tgf_isom_registry_disable(GF_ISOM_BOX_TYPE_BTRT, GF_TRUE);\n\tret = gf_isom_box_equal(a,b);\n\t//re-enable btrt writing\n\tgf_isom_registry_disable(GF_ISOM_BOX_TYPE_BTRT, GF_FALSE);\n\n\treturn ret;\n}\n\nGF_EXPORT\nu64 gf_isom_estimate_size(GF_ISOFile *movie)\n{\n\tGF_Err e;\n\tGF_Box *a;\n\tu32 i, count;\n\tu64 mdat_size;\n\tif (!movie || !movie->moov) return 0;\n\n\tmdat_size = 0;\n\tcount = gf_list_count(movie->moov->trackList);\n\tfor (i=0; i<count; i++) {\n\t\tmdat_size += gf_isom_get_media_data_size(movie, i+1);\n\t}\n\tif (mdat_size) {\n\t\tmdat_size += 8;\n\t\tif (mdat_size > 0xFFFFFFFF) mdat_size += 8;\n\t}\n\n\ti=0;\n\twhile ((a = (GF_Box*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\te = gf_isom_box_size(a);\n\t\tif (e == GF_OK)\n\t\t\tmdat_size += a->size;\n\t}\n\treturn mdat_size;\n}\n\n\n//set shadowing on/off\n#if 0 //unused\nGF_Err gf_isom_remove_sync_shadows(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleTableBox *stbl;\n\n\tif (movie->openMode == GF_ISOM_OPEN_READ) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (stbl->ShadowSync) {\n\t\tgf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *) stbl->ShadowSync);\n\t\tstbl->ShadowSync = NULL;\n\t}\n\treturn GF_OK;\n}\n\n/*Use this function to do the shadowing if you use shadowing.\nthe sample to be shadowed MUST be a non-sync sample (ignored if not)\nthe sample shadowing must be a Sync sample (error if not)*/\nGF_Err gf_isom_set_sync_shadow(GF_ISOFile *movie, u32 trackNumber, u32 sampleNumber, u32 syncSample)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleTableBox *stbl;\n\tGF_ISOSAPType isRAP;\n\tGF_Err e;\n\n\tif (movie->openMode == GF_ISOM_OPEN_READ) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !sampleNumber || !syncSample) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl->ShadowSync) {\n\t\tstbl->ShadowSync = (GF_ShadowSyncBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSH);\n\t\tif (!stbl->ShadowSync) return GF_OUT_OF_MEM;\n\t}\n\n\t//if no sync, skip\n\tif (!stbl->SyncSample) return GF_OK;\n\t//else set the sync shadow.\n\t//if the sample is sync, ignore\n\te = stbl_GetSampleRAP(stbl->SyncSample, sampleNumber, &isRAP, NULL, NULL);\n\tif (e) return e;\n\tif (isRAP) return GF_OK;\n\t//if the shadowing sample is not sync, error\n\te = stbl_GetSampleRAP(stbl->SyncSample, syncSample, &isRAP, NULL, NULL);\n\tif (e) return e;\n\tif (!isRAP) return GF_BAD_PARAM;\n\n\treturn stbl_SetSyncShadow(stbl->ShadowSync, sampleNumber, syncSample);\n}\n#endif\n\n//set the GroupID of a track (only used for interleaving)\nGF_EXPORT\nGF_Err gf_isom_set_track_interleaving_group(GF_ISOFile *movie, u32 trackNumber, u32 GroupID)\n{\n\tGF_TrackBox *trak;\n\n\tif (movie->openMode != GF_ISOM_OPEN_EDIT) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !GroupID) return GF_BAD_PARAM;\n\n\ttrak->Media->information->sampleTable->groupID = GroupID;\n\treturn GF_OK;\n}\n\n\n//set the Priority of a track within a Group (only used for tight interleaving)\n//Priority ranges from 1 to 9\nGF_EXPORT\nGF_Err gf_isom_set_track_priority_in_group(GF_ISOFile *movie, u32 trackNumber, u32 Priority)\n{\n\tGF_TrackBox *trak;\n\n\tif (movie->openMode != GF_ISOM_OPEN_EDIT) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !Priority) return GF_BAD_PARAM;\n\n\ttrak->Media->information->sampleTable->trackPriority = Priority > 255 ? 255 : Priority;\n\treturn GF_OK;\n}\n\n//set the max SamplesPerChunk (for file optimization)\nGF_EXPORT\nGF_Err gf_isom_hint_max_chunk_size(GF_ISOFile *movie, u32 trackNumber, u32 maxChunkSize)\n{\n\tGF_TrackBox *trak;\n\n\tif (movie->openMode == GF_ISOM_OPEN_READ) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !maxChunkSize) return GF_BAD_PARAM;\n\n\ttrak->Media->information->sampleTable->MaxChunkSize = maxChunkSize;\n\treturn GF_OK;\n}\n\n\n//set the max SamplesPerChunk (for file optimization)\nGF_EXPORT\nGF_Err gf_isom_hint_max_chunk_duration(GF_ISOFile *movie, u32 trackNumber, u32 maxChunkDur)\n{\n\tGF_TrackBox *trak;\n\n\tif (movie->openMode == GF_ISOM_OPEN_READ) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\ttrak->Media->information->sampleTable->MaxChunkDur = maxChunkDur;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_extraction_slc(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, const GF_SLConfig *slConfig)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_Err e;\n\tGF_SLConfig **slc;\n\tGF_ESDBox *esds;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex, &entry, NULL);\n\tif (e) return e;\n\n\t//we must be sure we are not using a remote ESD\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tesds = ((GF_MPEGSampleEntryBox *)entry)->esd;\n\t\tif (!esds || !esds->desc || !esds->desc->slConfig || (esds->desc->slConfig->predefined != SLPredef_MP4))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tslc = & ((GF_MPEGSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tesds = ((GF_MPEGAudioSampleEntryBox *)entry)->esd;\n\t\tif (!esds || !esds->desc || !esds->desc->slConfig || (esds->desc->slConfig->predefined != SLPredef_MP4))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tslc = & ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tesds = ((GF_MPEGVisualSampleEntryBox *)entry)->esd;\n\t\tif (!esds || !esds->desc || !esds->desc->slConfig || (esds->desc->slConfig->predefined != SLPredef_MP4))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tslc = & ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_OK;\n\t}\n\n\tif (*slc) {\n\t\tgf_odf_desc_del((GF_Descriptor *)*slc);\n\t\t*slc = NULL;\n\t}\n\tif (!slConfig) return GF_OK;\n\t//finally duplicate the SL\n\treturn gf_odf_desc_copy((GF_Descriptor *) slConfig, (GF_Descriptor **) slc);\n}\n\n#if 0 //unused\nGF_Err gf_isom_get_extraction_slc(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, GF_SLConfig **slConfig)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_Err e;\n\tGF_SLConfig *slc;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex, &entry, NULL);\n\tif (e) return e;\n\n\t//we must be sure we are not using a remote ESD\n\tslc = NULL;\n\t*slConfig = NULL;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tif (((GF_MPEGSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = ((GF_MPEGSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tif (((GF_MPEGAudioSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tif (((GF_MPEGVisualSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (!slc) return GF_OK;\n\t//finally duplicate the SL\n\treturn gf_odf_desc_copy((GF_Descriptor *) slc, (GF_Descriptor **) slConfig);\n}\n\nu32 gf_isom_get_track_group(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->Media->information->sampleTable->groupID;\n}\n\nu32 gf_isom_get_track_priority_in_group(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->Media->information->sampleTable->trackPriority;\n}\n#endif\n\n\nGF_EXPORT\nGF_Err gf_isom_make_interleave_ex(GF_ISOFile *file, GF_Fraction *fTimeInSec)\n{\n\tGF_Err e;\n\tu64 itime;\n\tif (!file || !fTimeInSec->den || (fTimeInSec->num<=0)) return GF_BAD_PARAM;\n\n\titime = (u64) fTimeInSec->num;\n\titime *= gf_isom_get_timescale(file);\n\titime /= fTimeInSec->den;\n\tif (file->storageMode==GF_ISOM_STORE_FASTSTART) {\n\t\treturn gf_isom_set_interleave_time(file, (u32) itime);\n\t}\n\tif (gf_isom_get_mode(file) < GF_ISOM_OPEN_EDIT) return GF_BAD_PARAM;\n\te = gf_isom_set_storage_mode(file, GF_ISOM_STORE_DRIFT_INTERLEAVED);\n\tif (e) return e;\n\treturn gf_isom_set_interleave_time(file, (u32) itime);\n}\n\nGF_EXPORT\nGF_Err gf_isom_make_interleave(GF_ISOFile *file, Double TimeInSec)\n{\n\tGF_Fraction f;\n\tf.num = (s32) (TimeInSec * 1000);\n\tf.den = 1000;\n\treturn gf_isom_make_interleave_ex(file, &f);\n\n}\nGF_EXPORT\nGF_Err gf_isom_set_handler_name(GF_ISOFile *the_file, u32 trackNumber, const char *nameUTF8)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (trak->Media->handler->nameUTF8) gf_free(trak->Media->handler->nameUTF8);\n\ttrak->Media->handler->nameUTF8 = NULL;\n\n\tif (!nameUTF8) return GF_OK;\n\n\tif (!strnicmp(nameUTF8, \"file://\", 7)) {\n\t\tu8 BOM[4];\n\t\tFILE *f = gf_fopen(nameUTF8+7, \"rb\");\n\t\tu64 size;\n\t\tif (!f) return GF_URL_ERROR;\n\t\tsize = gf_fsize(f);\n\t\tif (3!=gf_fread(BOM, 3, f)) {\n\t\t\tgf_fclose(f);\n\t\t\treturn GF_CORRUPTED_DATA;\n\t\t}\n\t\t/*skip BOM if any*/\n\t\tif ((BOM[0]==0xEF) && (BOM[1]==0xBB) && (BOM[2]==0xBF)) size -= 3;\n\t\telse if ((BOM[0]==0xEF) || (BOM[0]==0xFF)) {\n\t\t\tgf_fclose(f);\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\telse gf_fseek(f, 0, SEEK_SET);\n\t\ttrak->Media->handler->nameUTF8 = (char*)gf_malloc(sizeof(char)*(size_t)(size+1));\n\t\tif (!trak->Media->handler->nameUTF8) {\n\t\t\tgf_fclose(f);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tsize = gf_fread(trak->Media->handler->nameUTF8, (size_t)size, f);\n\t\ttrak->Media->handler->nameUTF8[size] = 0;\n\t\tgf_fclose(f);\n\t} else {\n\t\tu32 i, j, len;\n\t\tchar szOrig[1024], szLine[1024];\n\t\tstrcpy(szOrig, nameUTF8);\n\t\tj=0;\n\t\tlen = (u32) strlen(szOrig);\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif (szOrig[i] & 0x80) {\n\t\t\t\t/*non UTF8 (likely some win-CP)*/\n\t\t\t\tif ( (szOrig[i+1] & 0xc0) != 0x80) {\n\t\t\t\t\tszLine[j] = 0xc0 | ( (szOrig[i] >> 6) & 0x3 );\n\t\t\t\t\tj++;\n\t\t\t\t\tszOrig[i] &= 0xbf;\n\t\t\t\t}\n\t\t\t\t/*UTF8 2 bytes char */\n\t\t\t\telse if ( (szOrig[i] & 0xe0) == 0xc0) {\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 3 bytes char */\n\t\t\t\telse if ( (szOrig[i] & 0xf0) == 0xe0) {\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 4 bytes char */\n\t\t\t\telse if ( (szOrig[i] & 0xf8) == 0xf0) {\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tszLine[j] = szOrig[i];\n\t\t\tj++;\n\t\t}\n\t\tszLine[j] = 0;\n\t\ttrak->Media->handler->nameUTF8 = gf_strdup(szLine);\n\t}\n\treturn GF_OK;\n}\n\n#if 0 //unused\n/*clones root OD from input to output file, without copying root OD track references*/\nGF_Err gf_isom_clone_root_od(GF_ISOFile *input, GF_ISOFile *output)\n{\n\tGF_List *esds;\n\tGF_Err e;\n\tu32 i;\n\tGF_Descriptor *desc;\n\n\te = gf_isom_remove_root_od(output);\n\tif (e) return e;\n\tif (!input->moov || !input->moov->iods || !input->moov->iods->descriptor) return GF_OK;\n\te = gf_isom_insert_moov(output);\n\tif (e) return e;\n\te = AddMovieIOD(output->moov, 0);\n\tif (e) return e;\n\tif (output->moov->iods->descriptor) gf_odf_desc_del(output->moov->iods->descriptor);\n\toutput->moov->iods->descriptor = NULL;\n\tgf_odf_desc_copy(input->moov->iods->descriptor, &output->moov->iods->descriptor);\n\n\tswitch (output->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tesds = ((GF_IsomInitialObjectDescriptor *)output->moov->iods->descriptor)->ES_ID_IncDescriptors;\n\t\tbreak;\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tesds = ((GF_IsomObjectDescriptor *)output->moov->iods->descriptor)->ES_ID_IncDescriptors;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//get the desc\n\ti=0;\n\twhile ((desc = (GF_Descriptor*)gf_list_enum(esds, &i))) {\n\t\tgf_odf_desc_del(desc);\n\t\tgf_list_rem(esds, i-1);\n\t}\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_set_media_type(GF_ISOFile *movie, u32 trackNumber, u32 new_type)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !new_type) return GF_BAD_PARAM;\n\ttrak->Media->handler->handlerType = new_type;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_media_subtype(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescriptionIndex, u32 new_type)\n{\n\tGF_SampleEntryBox*entry;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !sampleDescriptionIndex || !new_type) return GF_BAD_PARAM;\n\n\tentry = (GF_SampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex - 1);\n\tif (!entry) return GF_BAD_PARAM;\n\tif (entry->type==GF_ISOM_BOX_TYPE_GNRV) {\n\t\t((GF_GenericVisualSampleEntryBox *)entry)->EntryType = new_type;\n\t} else if (entry->type==GF_ISOM_BOX_TYPE_GNRA) {\n\t\t((GF_GenericAudioSampleEntryBox *)entry)->EntryType = new_type;\n\t} else if (entry->type==GF_ISOM_BOX_TYPE_GNRM) {\n\t\t((GF_GenericSampleEntryBox *)entry)->EntryType = new_type;\n\t} else {\n\t\tentry->type = new_type;\n\t}\n\treturn GF_OK;\n}\n\n\n#if 0 //unused\nGF_Err gf_isom_set_JPEG2000(GF_ISOFile *mov, Bool set_on)\n{\n\tif (!mov) return GF_BAD_PARAM;\n\tmov->is_jp2 = set_on;\n\treturn GF_OK;\n}\n#endif\n\nGF_Err gf_isom_remove_uuid(GF_ISOFile *movie, u32 trackNumber, bin128 UUID)\n{\n\tu32 i, count;\n\tGF_List *list;\n\n\tif (trackNumber==(u32) -1) {\n\t\tif (!movie) return GF_BAD_PARAM;\n\t\tlist = movie->TopBoxes;\n\t} else if (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tlist = trak->child_boxes;\n\t} else {\n\t\tif (!movie) return GF_BAD_PARAM;\n\t\tlist = movie->moov->child_boxes;\n\t}\n\n\tcount = list ? gf_list_count(list) : 0;\n\tfor (i=0; i<count; i++) {\n\t\tGF_UnknownUUIDBox *uuid = (GF_UnknownUUIDBox *)gf_list_get(list, i);\n\t\tif (uuid->type != GF_ISOM_BOX_TYPE_UUID) continue;\n\t\tif (memcmp(UUID, uuid->uuid, sizeof(bin128))) continue;\n\t\tgf_list_rem(list, i);\n\t\ti--;\n\t\tcount--;\n\t\tgf_isom_box_del((GF_Box*)uuid);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_uuid(GF_ISOFile *movie, u32 trackNumber, bin128 UUID, const u8 *data, u32 data_size)\n{\n\tGF_List *list;\n    u32 btype;\n\tGF_Box *box;\n\tGF_UnknownUUIDBox *uuidb;\n\n\tif (data_size && !data) return GF_BAD_PARAM;\n\tif (trackNumber==(u32) -1) {\n\t\tif (!movie) return GF_BAD_PARAM;\n\t\tlist = movie->TopBoxes;\n\t} else if (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->child_boxes) trak->child_boxes = gf_list_new();\n\t\tlist = trak->child_boxes;\n\t} else {\n\t\tif (!movie) return GF_BAD_PARAM;\n\t\tif (!movie->moov->child_boxes) movie->moov->child_boxes = gf_list_new();\n\t\tlist = movie->moov->child_boxes;\n\t}\n    btype = gf_isom_solve_uuid_box((char *) UUID);\n    if (!btype) btype = GF_ISOM_BOX_TYPE_UUID;\n    box = gf_isom_box_new(btype);\n    if (!box) return GF_OUT_OF_MEM;\n\tuuidb = (GF_UnknownUUIDBox*)box;\n\tuuidb->internal_4cc = gf_isom_solve_uuid_box((char *) UUID);\n\tmemcpy(uuidb->uuid, UUID, sizeof(bin128));\n\tuuidb->dataSize = data_size;\n\tif (data_size) {\n\t\tuuidb->data = (char*)gf_malloc(sizeof(char)*data_size);\n\t\tif (!uuidb->data) return GF_OUT_OF_MEM;\n\t\tmemcpy(uuidb->data, data, sizeof(char)*data_size);\n\t}\n\tgf_list_add(list, uuidb);\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_apple_set_tag(GF_ISOFile *mov, GF_ISOiTunesTag tag, const u8 *data, u32 data_len, u64 int_val, u32 int_val2)\n{\n\tGF_Err e;\n\tGF_ItemListBox *ilst;\n\tGF_MetaBox *meta;\n\tGF_ListItemBox *info;\n\tu32 btype, i, itype;\n\ts32 tag_idx;\n\tu32 n=0, d=0;\n\tu8 loc_data[10];\n\tu32 int_flags = 0x15;\n\tGF_DataBox *dbox;\n\n\te = CanAccessMovie(mov, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttag_idx = gf_itags_find_by_itag(tag);\n\tif (tag_idx<0) {\n\t\titype = GF_ITAG_STR;\n\t} else {\n\t\titype = gf_itags_get_type(tag_idx);\n\t}\n\tmeta = (GF_MetaBox *) gf_isom_create_meta_extensions(mov, GF_FALSE);\n\tif (!meta) return GF_BAD_PARAM;\n\n\tilst = gf_isom_locate_box(meta->child_boxes, GF_ISOM_BOX_TYPE_ILST, NULL);\n\tif (!ilst) {\n\t\tilst = (GF_ItemListBox *) gf_isom_box_new_parent(&meta->child_boxes, GF_ISOM_BOX_TYPE_ILST);\n\t}\n\n\tif (tag==GF_ISOM_ITUNE_RESET) {\n\t\tgf_isom_box_del_parent(&meta->child_boxes, (GF_Box *) ilst);\n\t\t//if last, delete udta - we may still have a handler box remaining\n\t\tif ((gf_list_count(meta->child_boxes) <= 1) && (gf_list_count(mov->moov->udta->recordList)==1)) {\n\t\t\tgf_isom_box_del_parent(&mov->moov->child_boxes, (GF_Box *) mov->moov->udta);\n\t\t\tmov->moov->udta = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tif (tag==GF_ISOM_ITUNE_GENRE) {\n\t\tif (!int_val && data) {\n\t\t\tint_val = gf_id3_get_genre_tag(data);\n\t\t\tif (int_val) {\n\t\t\t\tdata = NULL;\n\t\t\t\tdata_len = 0;\n\t\t\t\titype = GF_ITAG_INT16;\n\t\t\t\tint_flags = 0;\n\t\t\t}\n\t\t}\n\t\tbtype = data ? GF_ISOM_ITUNE_GENRE_USER : GF_ISOM_ITUNE_GENRE;\n\t} else {\n\t\tbtype = tag;\n\t}\n\t/*remove tag*/\n\ti = 0;\n\twhile ((info = (GF_ListItemBox*)gf_list_enum(ilst->child_boxes, &i))) {\n\t\tif (info->type==btype) {\n\t\t\tgf_isom_box_del_parent(&ilst->child_boxes, (GF_Box *) info);\n\t\t\tinfo = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (info->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\tGF_UnknownBox *u = (GF_UnknownBox *) info;\n\t\t\tif (u->original_4cc==btype) {\n\t\t\t\tgf_isom_box_del_parent(&ilst->child_boxes, (GF_Box *) info);\n\t\t\t\tinfo = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!data && data_len) {\n\t\tif (!gf_list_count(ilst->child_boxes) )\n\t\t\tgf_isom_box_del_parent(&meta->child_boxes, (GF_Box *) ilst);\n\t\treturn GF_OK;\n\t}\n\n\t//watch out for cprt, we don't want to create a regular cprt box\n\tif (btype==GF_ISOM_ITUNE_COPYRIGHT) {\n\t\tinfo = (GF_ListItemBox *)gf_isom_box_new(GF_ISOM_ITUNE_TOOL);\n\t\tinfo->type = GF_ISOM_ITUNE_COPYRIGHT;\n\t} else {\n\t\tinfo = (GF_ListItemBox *)gf_isom_box_new(btype);\n\t}\n\tif (info == NULL) return GF_OUT_OF_MEM;\n\n\tdbox = (GF_DataBox *)gf_isom_box_new_parent(&info->child_boxes, GF_ISOM_BOX_TYPE_DATA);\n\tif (!dbox) {\n\t\tgf_isom_box_del((GF_Box *)info);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tif (info->type!=GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\tinfo->data = dbox;\n\t}\n\n\tswitch (itype) {\n\tcase GF_ITAG_FRAC6:\n\tcase GF_ITAG_FRAC8:\n\t\tif (data && data_len) {\n\t\t\tif (sscanf(data, \"%u/%u\", &n, &d) != 2) {\n\t\t\t\tn = d = 0;\n\t\t\t\tif (sscanf(data, \"%u\", &n) != 1)\n\t\t\t\t\tn = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tn = (u32) int_val;\n\t\t\td = int_val2;\n\t\t}\n\t\tif (n) {\n\t\t\tmemset(loc_data, 0, sizeof(char) * 8);\n\t\t\tdata_len = (itype == GF_ITAG_FRAC6) ? 6 : 8;\n\t\t\tloc_data[3] = n;\n\t\t\tloc_data[2] = n >> 8;\n\t\t\tloc_data[5] = d;\n\t\t\tloc_data[4] = d >> 8;\n\t\t\tdata = loc_data;\n\t\t} else {\n\t\t\tdata = NULL;\n\t\t}\n\t\tdbox->flags = 0x15;\n\t\tbreak;\n\tcase GF_ITAG_BOOL:\n\t\tloc_data[0] = 0;\n\t\tif (data && data_len) {\n\t\t\tif ( !strcmp(data, \"yes\") || !strcmp(data, \"1\") || !strcmp(data, \"true\"))\n\t\t\t\tloc_data[0] = 1;\n\t\t} else {\n\t\t\tloc_data[0] = int_val ? 1 : 0;\n\t\t}\n\t\tdata = loc_data;\n\t\tdata_len = 1;\n\t\tdbox->flags = int_flags;\n\t\tbreak;\n\tcase GF_ITAG_INT8:\n\t\tloc_data[0] = 0;\n\t\tif (data && data_len) int_val = atoi(data);\n\t\tloc_data[0] = (u8) int_val;\n\t\tdata = loc_data;\n\t\tdata_len = 1;\n\t\tdbox->flags = int_flags;\n\t\tbreak;\n\tcase GF_ITAG_INT16:\n\t\tloc_data[0] = 0;\n\t\tif (data && data_len) int_val = atoi(data);\n\t\tloc_data[1] = (u8) int_val;\n\t\tloc_data[0] = (u8) (int_val>>8);\n\t\tdata = loc_data;\n\t\tdata_len = 2;\n\t\tdbox->flags = int_flags;\n\t\tbreak;\n\tcase GF_ITAG_INT32:\n\t\tloc_data[0] = 0;\n\t\tif (data && data_len) int_val = atoi(data);\n\t\tloc_data[3] = (u8) int_val;\n\t\tloc_data[2] = (u8) (int_val>>8);\n\t\tloc_data[1] = (u8) (int_val>>16);\n\t\tloc_data[0] = (u8) (int_val>>24);\n\t\tdata = loc_data;\n\t\tdata_len = 4;\n\t\tdbox->flags = int_flags;\n\t\tbreak;\n\tcase GF_ITAG_INT64:\n\t\tloc_data[0] = 0;\n\t\tif (data && data_len) sscanf(data, LLU, &int_val);\n\t\tloc_data[7] = (u8) int_val;\n\t\tloc_data[6] = (u8) (int_val>>8);\n\t\tloc_data[5] = (u8) (int_val>>16);\n\t\tloc_data[4] = (u8) (int_val>>24);\n\t\tloc_data[3] = (u8) (int_val>>32);\n\t\tloc_data[2] = (u8) (int_val>>40);\n\t\tloc_data[1] = (u8) (int_val>>48);\n\t\tloc_data[0] = (u8) (int_val>>56);\n\t\tdata = loc_data;\n\t\tdata_len = 8;\n\t\tdbox->flags = int_flags;\n\t\tbreak;\n\tdefault:\n\t\tdbox->flags = 1;\n\t\tbreak;\n\t}\n\n\tif (!data) return GF_BAD_PARAM;\n\n\n\tif (tag==GF_ISOM_ITUNE_COVER_ART) {\n\t\tinfo->data->flags = 0;\n\t\t/*check for PNG sig*/\n\t\tif ((data_len>4) && (data[0] == 0x89) && (data[1] == 0x50) && (data[2] == 0x4E) && (data[3] == 0x47) ) {\n\t\t\tinfo->data->flags = 14;\n\t\t}\n\t\t//JPG and JFIF - do not check second tag type\n\t\telse if ((data_len>4) && (data[0] == 0xFF) && (data[1] == 0xD8) && (data[2] == 0xFF) /*&& ((data[3] == 0xE0) || (data[3] == 0xDB))*/ ) {\n\t\t\tinfo->data->flags = 13;\n\t\t}\n\t\t//GIF\n\t\telse if ((data_len>3) && (data[0] == 'G') && (data[1] == 'I') && (data[2] == 'F') ) {\n\t\t\tinfo->data->flags = 12;\n\t\t}\n\t}\n\n\tdbox->dataSize = data_len;\n\tdbox->data = (char*)gf_malloc(sizeof(char)*data_len);\n\tif (!dbox->data) return GF_OUT_OF_MEM;\n\tmemcpy(dbox->data, data, sizeof(char)*data_len);\n\n\tif (!info && !gf_list_count(ilst->child_boxes) ) {\n\t\tgf_isom_box_del_parent(&meta->child_boxes, (GF_Box *) ilst);\n\t\treturn GF_OK;\n\t}\n\tif (!ilst->child_boxes) ilst->child_boxes = gf_list_new();\n\n\treturn gf_list_add(ilst->child_boxes, info);\n}\n\n#include <gpac/utf.h>\n\nGF_EXPORT\nGF_Err gf_isom_wma_set_tag(GF_ISOFile *mov, char *name, char *value)\n{\n\tGF_Err e;\n\tGF_XtraTag *tag=NULL;\n\tu32 count, i;\n\tGF_XtraBox *xtra;\n\n\te = CanAccessMovie(mov, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tgf_isom_create_meta_extensions(mov, GF_FALSE);\n\n\txtra = (GF_XtraBox *) gf_isom_create_meta_extensions(mov, GF_TRUE);\n\tif (!xtra) return GF_BAD_PARAM;\n\n\tcount = gf_list_count(xtra->tags);\n\tfor (i=0; i<count; i++) {\n\t\ttag = gf_list_get(xtra->tags, i);\n\t\tif (name && tag->name && !strcmp(tag->name, name)) {\n\n\t\t} else {\n\t\t\ttag = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!value) {\n\t\t\tgf_list_rem(xtra->tags, i);\n\t\t\tgf_free(tag->name);\n\t\t\tif (tag->prop_value) gf_free(tag->prop_value);\n\t\t\tgf_free(tag);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tgf_free(tag->prop_value);\n\t\ttag->prop_value = 0;\n\t}\n\tif (!tag) {\n\t\tif (!name) return GF_OK;\n\n\t\tGF_SAFEALLOC(tag, GF_XtraTag);\n\t\ttag->name = gf_strdup(name);\n\t\ttag->prop_type = 0;\n\t\ttag->flags = 1;\n\t\tgf_list_add(xtra->tags, tag);\n\t}\n\n\tu32 len = (u32) strlen(value);\n\ttag->prop_value = gf_malloc(sizeof(u16) * (len+1) );\n\tmemset(tag->prop_value, 0, sizeof(u16) * (len+1) );\n\tif (len) {\n\t\tu32 _len = gf_utf8_mbstowcs((u16 *) tag->prop_value, len, (const char **) &value);\n\t\tif (_len == GF_UTF8_FAIL) _len = 0;\n\t\ttag->prop_value[2 * _len] = 0;\n\t\ttag->prop_value[2 * _len + 1] = 0;\n\t\ttag->prop_size = 2 * _len + 2;\n\t} else {\n\t\ttag->prop_size = 2;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_qt_key(GF_ISOFile *movie, GF_QT_UDTAKey *key)\n{\n\tGF_Err e;\n\tGF_MetaBox *meta;\n\tGF_ItemListBox *ilst;\n\tGF_MetaKeysBox *keys;\n\tu32 i, nb_keys;\n\n\tif (!movie) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) {\n\t\tgf_isom_set_last_error(movie, e);\n\t\treturn 0;\n\t}\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tmeta = (GF_MetaBox *) gf_isom_create_meta_extensions(movie, 2);\n\tif (!meta) return GF_BAD_PARAM;\n\n\tkeys = (GF_MetaKeysBox *) gf_isom_locate_box(meta->child_boxes, GF_ISOM_BOX_TYPE_KEYS, NULL);\n\tif (!keys) {\n\t\tkeys = (GF_MetaKeysBox *) gf_isom_box_new_parent(&meta->child_boxes, GF_ISOM_BOX_TYPE_KEYS);\n\t\tmeta->keys = keys;\n\t}\n\tilst = (GF_ItemListBox *) gf_isom_locate_box(meta->child_boxes, GF_ISOM_BOX_TYPE_ILST, NULL);\n\tif (!ilst) {\n\t\tilst = (GF_ItemListBox *) gf_isom_box_new_parent(&meta->child_boxes, GF_ISOM_BOX_TYPE_ILST);\n\t}\n\tif (!keys || !ilst) return GF_OUT_OF_MEM;\n\n\tnb_keys = gf_list_count(keys->keys);\n\tif (!key) {\n\t\tgf_isom_box_del_parent(&meta->child_boxes, (GF_Box *) keys);\n\t\tfor (i=0; i<gf_list_count(ilst->child_boxes); i++) {\n\t\t\tGF_ListItemBox *info = gf_list_get(ilst->child_boxes, i);\n\t\t\tif (info->type <= nb_keys) {\n\t\t\t\tgf_isom_box_del_parent(&ilst->child_boxes, (GF_Box *) info);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\tif (!gf_list_count(ilst->child_boxes)) {\n\t\t\tgf_isom_box_del_parent(&meta->child_boxes, (GF_Box *) ilst);\n\t\t\t//if last, delete udta - we may still have a handler box remaining\n\t\t\tif ((gf_list_count(meta->child_boxes) <= 1) && (gf_list_count(movie->moov->udta->recordList)==1)) {\n\t\t\t\tgf_isom_box_del_parent(&movie->moov->child_boxes, (GF_Box *) movie->moov->udta);\n\t\t\t\tmovie->moov->udta = NULL;\n\t\t\t}\n\t\t}\n\t\treturn GF_OK;\n\t}\n\t//locate key\n\tGF_MetaKey *o_key = NULL;\n\tu32 ksize = (u32) strlen(key->name);\n\tfor (i=0; i<nb_keys; i++) {\n\t\to_key = gf_list_get(keys->keys, i);\n\t\tif ((o_key->ns == key->ns) && (o_key->size==ksize) && !strcmp(o_key->data, key->name))\n\t\t\tbreak;\n\t\to_key = NULL;\n\t}\n\tif (!o_key) {\n\t\tif (key->type==GF_QT_KEY_REMOVE) return GF_OK;\n\t\tGF_SAFEALLOC(o_key, GF_MetaKey);\n\t\to_key->ns = key->ns;\n\t\to_key->data = gf_strdup(key->name);\n\t\to_key->size = ksize;\n\t\tgf_list_add(keys->keys, o_key);\n\t}\n\tu32 key_idx = gf_list_find(keys->keys, o_key)+1;\n\tGF_UnknownBox *info=NULL;\n\tfor (i=0; i<gf_list_count(ilst->child_boxes); i++) {\n\t\tinfo = gf_list_get(ilst->child_boxes, i);\n\t\tif (info->original_4cc == key_idx) break;\n\t\tinfo = NULL;\n\t}\n\n\tif (key->type==GF_QT_KEY_REMOVE) {\n\t\tgf_list_del_item(keys->keys, o_key);\n\t\tif (o_key->data) gf_free(o_key->data);\n\t\tgf_free(o_key);\n\t\tfor (i=0; i<gf_list_count(ilst->child_boxes); i++) {\n\t\t\tinfo = gf_list_get(ilst->child_boxes, i);\n\t\t\tif (info->type!=GF_ISOM_BOX_TYPE_UNKNOWN) continue;\n\t\t\tif (info->original_4cc==key_idx) {\n\t\t\t\tgf_isom_box_del_parent(&ilst->child_boxes, (GF_Box *)info);\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (info->original_4cc>key_idx) {\n\t\t\t\tinfo->original_4cc--;\n\t\t\t}\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (!info) {\n\t\tinfo = (GF_UnknownBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_UNKNOWN);\n\t\tif (!info) return GF_OUT_OF_MEM;\n\t\tif (!ilst->child_boxes) ilst->child_boxes = gf_list_new();\n\t\tgf_list_add(ilst->child_boxes, info);\n\t}\n\n\tGF_DataBox *dbox = (GF_DataBox *) gf_isom_box_find_child(info->child_boxes, GF_ISOM_BOX_TYPE_DATA);\n\tif (!dbox) {\n\t\tdbox = (GF_DataBox *)gf_isom_box_new_parent(&info->child_boxes, GF_ISOM_BOX_TYPE_DATA);\n\t\tif (!dbox) {\n\t\t\tgf_isom_box_del((GF_Box *)info);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t}\n\tu32 nb_bits=0;\n\tinfo->original_4cc = key_idx;\n\tdbox->version = 0;\n\tdbox->flags = key->type;\n\t//serialize\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tswitch (key->type) {\n\tcase GF_QT_KEY_UTF8:\n\tcase GF_QT_KEY_UTF8_SORT:\n\t\tif (key->value.string)\n\t\t\tgf_bs_write_data(bs, key->value.string, (u32) strlen(key->value.string));\n\t\tbreak;\n\n\tcase GF_QT_KEY_SIGNED_VSIZE:\n\t\tif (ABS(key->value.sint)<=0x7F) nb_bits=8;\n\t\telse if (ABS(key->value.sint)<=0x7FFF) nb_bits=16;\n\t\telse if (ABS(key->value.sint)<=0x7FFFFF) nb_bits=24;\n\t\telse nb_bits = 32;\n\t\tgf_bs_write_int(bs, (s32) key->value.sint, nb_bits);\n\t\tbreak;\n\tcase GF_QT_KEY_UNSIGNED_VSIZE:\n\t\tif (key->value.uint<=0xFF) nb_bits=8;\n\t\telse if (key->value.uint<=0xFFFF) nb_bits=16;\n\t\telse if (key->value.uint<=0xFFFFFF) nb_bits=24;\n\t\telse nb_bits = 32;\n\t\tgf_bs_write_int(bs, (u32) key->value.uint, nb_bits);\n\t\tbreak;\n\tcase GF_QT_KEY_FLOAT:\n\t\tgf_bs_write_float(bs, (Float) key->value.number);\n\t\tbreak;\n\tcase GF_QT_KEY_DOUBLE:\n\t\tgf_bs_write_double(bs, key->value.number);\n\t\tbreak;\n\tcase GF_QT_KEY_SIGNED_8:\n\t\tgf_bs_write_int(bs, (s32) key->value.sint, 8);\n\t\tbreak;\n\tcase GF_QT_KEY_SIGNED_16:\n\t\tgf_bs_write_int(bs, (s32) key->value.sint, 16);\n\t\tbreak;\n\tcase GF_QT_KEY_SIGNED_32:\n\t\tgf_bs_write_int(bs, (s32) key->value.sint, 32);\n\t\tbreak;\n\tcase GF_QT_KEY_SIGNED_64:\n\t\tgf_bs_write_long_int(bs, key->value.sint, 64);\n\t\tbreak;\n\tcase GF_QT_KEY_POINTF:\n\tcase GF_QT_KEY_SIZEF:\n\t\tgf_bs_write_float(bs, key->value.pos_size.x);\n\t\tgf_bs_write_float(bs, key->value.pos_size.y);\n\t\tbreak;\n\tcase GF_QT_KEY_RECTF:\n\t\tgf_bs_write_float(bs, key->value.rect.x);\n\t\tgf_bs_write_float(bs, key->value.rect.y);\n\t\tgf_bs_write_float(bs, key->value.rect.w);\n\t\tgf_bs_write_float(bs, key->value.rect.h);\n\t\tbreak;\n\n\tcase GF_QT_KEY_UNSIGNED_8:\n\t\tgf_bs_write_int(bs, (s32) key->value.uint, 8);\n\t\tbreak;\n\tcase GF_QT_KEY_UNSIGNED_16:\n\t\tgf_bs_write_int(bs, (s32) key->value.uint, 16);\n\t\tbreak;\n\tcase GF_QT_KEY_UNSIGNED_32:\n\t\tgf_bs_write_int(bs, (s32) key->value.uint, 32);\n\t\tbreak;\n\tcase GF_QT_KEY_UNSIGNED_64:\n\t\tgf_bs_write_long_int(bs, key->value.uint, 64);\n\t\tbreak;\n\tcase GF_QT_KEY_MATRIXF:\n\t\tfor (i=0; i<9; i++)\n\t\t\tgf_bs_write_float(bs, (Float) key->value.matrix[i] );\n\t\tbreak;\n\n\tcase GF_QT_KEY_OPAQUE:\n\tcase GF_QT_KEY_UTF16_BE:\n\tcase GF_QT_KEY_JIS:\n\tcase GF_QT_KEY_UTF16_SORT:\n\tcase GF_QT_KEY_JPEG:\n\tcase GF_QT_KEY_PNG:\n\tcase GF_QT_KEY_BMP:\n\tcase GF_QT_KEY_METABOX:\n\tdefault:\n\t\tgf_bs_write_data(bs, key->value.data.data, key->value.data.data_len);\n\t\tbreak;\n\t}\n\t//write extra 0 at end, not serialized\n\tgf_bs_write_u8(bs, 0);\n\tif (dbox->data) gf_free(dbox->data);\n\n\tgf_bs_get_content(bs, &dbox->data, &i);\n\tif (i) i--;\n\tdbox->dataSize = i;\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_alternate_group_id(GF_ISOFile *movie, u32 trackNumber, u32 groupId)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\ttrak->Header->alternate_group = groupId;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber, u32 trackRefGroup, Bool is_switch_group, u32 *switchGroupID, u32 *criteriaList, u32 criteriaListCount)\n{\n\tGF_TrackSelectionBox *tsel;\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_Err e;\n\tu32 alternateGroupID = 0;\n\tu32 next_switch_group_id = 0;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !switchGroupID) return GF_BAD_PARAM;\n\n\n\tif (trackRefGroup) {\n\t\tGF_TrackBox *trak_ref = gf_isom_get_track_from_file(movie, trackRefGroup);\n\t\tif (trak_ref != trak) {\n\t\t\tif (!trak_ref || !trak_ref->Header->alternate_group) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"Track %d has not an alternate group - skipping\\n\", trak_ref ? trak_ref->Header->trackID : 0));\n\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t}\n\t\t\talternateGroupID = trak_ref->Header->alternate_group;\n\t\t} else {\n\t\t\talternateGroupID = trak->Header->alternate_group;\n\t\t}\n\t}\n\tif (!alternateGroupID) {\n\t\t/*there is a function for this ....*/\n\t\tif (trak->Header->alternate_group) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"Track %d has already an alternate group - skipping\\n\", trak->Header->trackID));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\talternateGroupID = gf_isom_get_next_alternate_group_id(movie);\n\t}\n\n\tif (is_switch_group) {\n\t\tu32 i=0;\n\t\twhile (i< gf_isom_get_track_count(movie) ) {\n\t\t\t//locate first available ID\n\t\t\tGF_TrackBox *a_trak = gf_isom_get_track_from_file(movie, i+1);\n\n\t\t\tif (a_trak->udta) {\n\t\t\t\tu32 j, count;\n\t\t\t\tmap = udta_getEntry(a_trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\t\t\t\tif (map) {\n\t\t\t\t\tcount = gf_list_count(map->boxes);\n\t\t\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\t\t\ttsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, j);\n\n\t\t\t\t\t\tif (*switchGroupID) {\n\t\t\t\t\t\t\tif (tsel->switchGroup==next_switch_group_id) {\n\t\t\t\t\t\t\t\tif (a_trak->Header->alternate_group != alternateGroupID) return GF_BAD_PARAM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (tsel->switchGroup && (tsel->switchGroup>=next_switch_group_id) )\n\t\t\t\t\t\t\t\tnext_switch_group_id = tsel->switchGroup;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif (! *switchGroupID) *switchGroupID = next_switch_group_id+1;\n\t}\n\n\n\ttrak->Header->alternate_group = alternateGroupID;\n\n\ttsel = NULL;\n\tif (*switchGroupID) {\n\t\tif (!trak->udta) {\n\t\t\te = trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\n\t\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\n\t\t/*locate tsel box with no switch group*/\n\t\tif (map)  {\n\t\t\tu32 j, count = gf_list_count(map->boxes);\n\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\ttsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, j);\n\t\t\t\tif (tsel->switchGroup == *switchGroupID) break;\n\t\t\t\ttsel = NULL;\n\t\t\t}\n\t\t}\n\t\tif (!tsel) {\n\t\t\ttsel = (GF_TrackSelectionBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_TSEL);\n\t\t\tif (!tsel) return GF_OUT_OF_MEM;\n\t\t\te = udta_on_child_box((GF_Box *)trak->udta, (GF_Box *) tsel, GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\n\t\ttsel->switchGroup = *switchGroupID;\n\t\ttsel->attributeListCount = criteriaListCount;\n\t\tif (tsel->attributeList) gf_free(tsel->attributeList);\n\t\ttsel->attributeList = (u32*)gf_malloc(sizeof(u32)*criteriaListCount);\n\t\tif (!tsel->attributeList) return GF_OUT_OF_MEM;\n\t\tmemcpy(tsel->attributeList, criteriaList, sizeof(u32)*criteriaListCount);\n\t}\n\treturn GF_OK;\n}\n\nvoid reset_tsel_box(GF_TrackBox *trak)\n{\n\tGF_UserDataMap *map;\n\ttrak->Header->alternate_group = 0;\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\tif (map) {\n\t\tgf_list_del_item(trak->udta->recordList, map);\n\t\tgf_isom_box_array_del(map->boxes);\n\t\tgf_free(map);\n\t}\n\n}\n\nGF_EXPORT\nGF_Err gf_isom_reset_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber, Bool reset_all_group)\n{\n\tGF_TrackBox *trak;\n\tu32 alternateGroupID = 0;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Header->alternate_group) return GF_OK;\n\n\talternateGroupID = trak->Header->alternate_group;\n\tif (reset_all_group) {\n\t\tu32 i=0;\n\t\twhile (i< gf_isom_get_track_count(movie) ) {\n\t\t\t//locate first available ID\n\t\t\tGF_TrackBox *a_trak = gf_isom_get_track_from_file(movie, i+1);\n\t\t\tif (a_trak->Header->alternate_group == alternateGroupID) reset_tsel_box(a_trak);\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\treset_tsel_box(trak);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_reset_switch_parameters(GF_ISOFile *movie)\n{\n\tu32 i=0;\n\twhile (i< gf_isom_get_track_count(movie) ) {\n\t\t//locate first available ID\n\t\tGF_TrackBox *a_trak = gf_isom_get_track_from_file(movie, i+1);\n\t\treset_tsel_box(a_trak);\n\t\ti++;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_add_subsample(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 flags, u32 subSampleSize, u8 priority, u32 reserved, Bool discardable)\n{\n\tu32 i, count;\n\tGF_SubSampleInformationBox *sub_samples;\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak || !trak->Media || !trak->Media->information->sampleTable)\n\t\treturn GF_BAD_PARAM;\n\n\tif (!trak->Media->information->sampleTable->sub_samples) {\n\t\ttrak->Media->information->sampleTable->sub_samples=gf_list_new();\n\t}\n\n\tsub_samples = NULL;\n\tcount = gf_list_count(trak->Media->information->sampleTable->sub_samples);\n\tfor (i=0; i<count; i++) {\n\t\tsub_samples = gf_list_get(trak->Media->information->sampleTable->sub_samples, i);\n\t\tif (sub_samples->flags==flags) break;\n\t\tsub_samples = NULL;\n\t}\n\tif (!sub_samples) {\n\t\tsub_samples = (GF_SubSampleInformationBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_SUBS);\n\t\tif (!sub_samples) return GF_OUT_OF_MEM;\n\t\tgf_list_add(trak->Media->information->sampleTable->sub_samples, sub_samples);\n\t\tsub_samples->version = (subSampleSize>0xFFFF) ? 1 : 0;\n\t\tsub_samples->flags = flags;\n\t}\n\treturn gf_isom_add_subsample_info(sub_samples, sampleNumber, subSampleSize, priority, reserved, discardable);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_rvc_config(GF_ISOFile *movie, u32 track, u32 sampleDescriptionIndex, u16 rvc_predefined, char *mime, u8 *data, u32 size)\n{\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex-1);\n\tif (!entry ) return GF_BAD_PARAM;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_RVCConfigurationBox *rvcc = (GF_RVCConfigurationBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_RVCC);\n\tif (rvcc && rvcc->rvc_meta_idx) {\n\t\tgf_isom_remove_meta_item(movie, GF_FALSE, track, rvcc->rvc_meta_idx, GF_FALSE, NULL);\n\t\trvcc->rvc_meta_idx = 0;\n\t}\n\n\tif (!rvcc) {\n\t\trvcc = (GF_RVCConfigurationBox *) gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_RVCC);\n\t\tif (!rvcc) return GF_OUT_OF_MEM;\n\t}\n\trvcc->predefined_rvc_config = rvc_predefined;\n\tif (!rvc_predefined) {\n\t\tu32 it_id=0;\n\t\te = gf_isom_set_meta_type(movie, GF_FALSE, track, GF_META_TYPE_RVCI);\n\t\tif (e) return e;\n\t\tgf_isom_modify_alternate_brand(movie, GF_ISOM_BRAND_ISO2, GF_TRUE);\n\t\te = gf_isom_add_meta_item_memory(movie, GF_FALSE, track, \"rvcconfig.xml\", &it_id, GF_META_ITEM_TYPE_MIME, mime, NULL, NULL, data, size, NULL);\n\t\tif (e) return e;\n\t\trvcc->rvc_meta_idx = gf_isom_get_meta_item_count(movie, GF_FALSE, track);\n\t}\n\treturn GF_OK;\n}\n\n/*for now not exported*/\n/*expands sampleGroup table for the given grouping type and sample_number. If sample_number is 0, just appends an entry at the end of the table*/\nstatic GF_Err gf_isom_add_sample_group_entry(GF_List *sampleGroups, u32 sample_number, GF_SampleGroupDescriptionBox *sgdesc, u32 grouping_type_parameter, u32 sampleGroupDescriptionIndex, GF_List *parent, GF_SampleTableBox *stbl)\n{\n\tGF_SampleGroupBox *sgroup = NULL;\n\tu32 i, count, last_sample_in_entry;\n\tBool all_samples = GF_FALSE;\n\tassert(sampleGroups);\n\tif (!sgdesc) return GF_BAD_PARAM;\n\tcount = gf_list_count(sampleGroups);\n\tfor (i=0; i<count; i++) {\n\t\tsgroup = (GF_SampleGroupBox*)gf_list_get(sampleGroups, i);\n\t\tif (sgroup->grouping_type==sgdesc->grouping_type) break;\n\t\tsgroup = NULL;\n\t}\n\tif (!sgroup) {\n\t\tsgroup = (GF_SampleGroupBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_SBGP);\n\t\tif (!sgroup) return GF_OUT_OF_MEM;\n\t\tsgroup->grouping_type = sgdesc->grouping_type;\n\t\tsgroup->grouping_type_parameter = grouping_type_parameter;\n//\t\tgf_list_add(sampleGroups, sgroup);\n\t\t//crude patch to align old arch and filters\n\t\tgf_list_insert(sampleGroups, sgroup, 0);\n\t\tassert(parent);\n\t\tgf_list_add(parent, sgroup);\n\t}\n\tu32 def_insert_value = (sgdesc && (sgdesc->version==2)) ? sgdesc->default_description_index : 0;\n\n\t/*used in fragments, means we are adding the last sample*/\n\tif (!sample_number) {\n\t\tsample_number = 1;\n\t\tif (sgroup->entry_count) {\n\t\t\tfor (i=0; i<sgroup->entry_count; i++) {\n\t\t\t\tsample_number += sgroup->sample_entries[i].sample_count;\n\t\t\t}\n\t\t}\n\t} else if (sample_number==(u32) -1) {\n\t\tall_samples = GF_TRUE;\n\t\tsample_number = 1;\n\t}\n\n\tif (!sgroup->entry_count) {\n\t\tu32 idx = 0;\n\t\tsgroup->entry_count = (sample_number>1) ? 2 : 1;\n\t\tsgroup->sample_entries = (GF_SampleGroupEntry*)gf_malloc(sizeof(GF_SampleGroupEntry) * sgroup->entry_count );\n\t\tif (!sgroup->sample_entries) return GF_OUT_OF_MEM;\n\t\tif (sample_number>1) {\n\t\t\tsgroup->sample_entries[0].sample_count = sample_number-1;\n\t\t\tsgroup->sample_entries[0].group_description_index = sampleGroupDescriptionIndex ? def_insert_value : 1;\n\t\t\tidx = 1;\n\t\t}\n\t\tsgroup->sample_entries[idx].sample_count = 1;\n\t\tsgroup->sample_entries[idx].group_description_index = sampleGroupDescriptionIndex;\n\t\tif (all_samples && stbl) {\n\t\t\tsgroup->sample_entries[idx].sample_count = stbl->SampleSize->sampleCount;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (all_samples && stbl) {\n\t\tsgroup->entry_count = 1;\n\t\tsgroup->sample_entries[0].group_description_index = sampleGroupDescriptionIndex;\n\t\tsgroup->sample_entries[0].sample_count = stbl->SampleSize->sampleCount;\n\t\treturn GF_OK;\n\t}\n\tlast_sample_in_entry = 0;\n\tfor (i=0; i<sgroup->entry_count; i++) {\n\t\t/*TODO*/\n\t\tif (last_sample_in_entry + sgroup->sample_entries[i].sample_count > sample_number)\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\tlast_sample_in_entry += sgroup->sample_entries[i].sample_count;\n\t}\n\n\tif (last_sample_in_entry == sample_number) {\n\t\tif (sgroup->sample_entries[sgroup->entry_count-1].group_description_index==sampleGroupDescriptionIndex)\n\t\t\treturn GF_OK;\n\t\telse\n\t\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tif ((sgroup->sample_entries[sgroup->entry_count-1].group_description_index==sampleGroupDescriptionIndex) && (last_sample_in_entry+1==sample_number)) {\n\t\tsgroup->sample_entries[sgroup->entry_count-1].sample_count++;\n\t\treturn GF_OK;\n\t}\n\t/*last entry was an empty desc (no group associated), just add the number of samples missing until new one, then add new one*/\n\tif (! sgroup->sample_entries[sgroup->entry_count-1].group_description_index) {\n\t\tsgroup->sample_entries[sgroup->entry_count-1].sample_count += sample_number - 1 - last_sample_in_entry;\n\t\tsgroup->sample_entries = (GF_SampleGroupEntry*)gf_realloc(sgroup->sample_entries, sizeof(GF_SampleGroupEntry) * (sgroup->entry_count + 1) );\n\t\tsgroup->sample_entries[sgroup->entry_count].sample_count = 1;\n\t\tsgroup->sample_entries[sgroup->entry_count].group_description_index = sampleGroupDescriptionIndex;\n\t\tsgroup->entry_count++;\n\t\treturn GF_OK;\n\t}\n\t/*we are adding a sample with no desc, add entry at the end*/\n\tif (!sampleGroupDescriptionIndex || (sample_number - 1 - last_sample_in_entry==0) ) {\n\t\tsgroup->sample_entries = (GF_SampleGroupEntry*)gf_realloc(sgroup->sample_entries, sizeof(GF_SampleGroupEntry) * (sgroup->entry_count + 1) );\n\t\tsgroup->sample_entries[sgroup->entry_count].sample_count = 1;\n\t\tsgroup->sample_entries[sgroup->entry_count].group_description_index = sampleGroupDescriptionIndex;\n\t\tsgroup->entry_count++;\n\t\treturn GF_OK;\n\t}\n\t/*need to insert two entries ...*/\n\tsgroup->sample_entries = (GF_SampleGroupEntry*)gf_realloc(sgroup->sample_entries, sizeof(GF_SampleGroupEntry) * (sgroup->entry_count + 2) );\n\n\tsgroup->sample_entries[sgroup->entry_count].sample_count = sample_number - 1 - last_sample_in_entry;\n\tsgroup->sample_entries[sgroup->entry_count].group_description_index = def_insert_value;\n\n\tsgroup->sample_entries[sgroup->entry_count+1].sample_count = 1;\n\tsgroup->sample_entries[sgroup->entry_count+1].group_description_index = sampleGroupDescriptionIndex;\n\tsgroup->entry_count+=2;\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nstatic GF_SampleGroupDescriptionBox *get_sgdp(GF_SampleTableBox *stbl, GF_TrackFragmentBox *traf, u32 grouping_type, Bool *is_traf_sgdp)\n#else\nstatic GF_SampleGroupDescriptionBox *get_sgdp(GF_SampleTableBox *stbl, void *traf, u32 grouping_type, Bool *is_traf_sgdp)\n#endif /* GPAC_DISABLE_ISOM_FRAGMENTS */\n{\n\tGF_List *groupList=NULL;\n\tGF_List **parent=NULL;\n\tGF_SampleGroupDescriptionBox *sgdesc=NULL;\n\tu32 count, i;\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!stbl && traf && traf->trex->track->Media->information->sampleTable)\n\t\tstbl = traf->trex->track->Media->information->sampleTable;\n#endif\n\tif (stbl) {\n\t\tif (!stbl->sampleGroupsDescription && !traf)\n\t\t\tstbl->sampleGroupsDescription = gf_list_new();\n\n\t\tgroupList = stbl->sampleGroupsDescription;\n\t\tif (is_traf_sgdp) *is_traf_sgdp = GF_FALSE;\n\t\tparent = &stbl->child_boxes;\n\n\t\tcount = gf_list_count(groupList);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(groupList, i);\n\t\t\tif (sgdesc->grouping_type==grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t/*look in stbl or traf for sample sampleGroupsDescription*/\n\tif (!sgdesc && traf) {\n\t\tif (!traf->sampleGroupsDescription)\n\t\t\ttraf->sampleGroupsDescription = gf_list_new();\n\t\tgroupList = traf->sampleGroupsDescription;\n\t\tparent = &traf->child_boxes;\n\t\tif (is_traf_sgdp) *is_traf_sgdp = GF_TRUE;\n\n\t\tcount = gf_list_count(groupList);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(groupList, i);\n\t\t\tif (sgdesc->grouping_type==grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#endif\n\n\tif (!sgdesc) {\n\t\tsgdesc = (GF_SampleGroupDescriptionBox *) gf_isom_box_new_parent(parent, GF_ISOM_BOX_TYPE_SGPD);\n\t\tif (!sgdesc) return NULL;\n\t\tsgdesc->grouping_type = grouping_type;\n\t\tassert(groupList);\n\t\tgf_list_add(groupList, sgdesc);\n\t}\n\treturn sgdesc;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nstatic GF_Err gf_isom_set_sample_group_info_ex(GF_SampleTableBox *stbl, GF_TrackFragmentBox *traf, u32 sample_number, u32 grouping_type, u32 grouping_type_parameter, void *udta, void *(*sg_create_entry)(void *udta), Bool (*sg_compare_entry)(void *udta, void *entry))\n#else\nstatic GF_Err gf_isom_set_sample_group_info_ex(GF_SampleTableBox *stbl, void *traf, u32 sample_number, u32 grouping_type, u32 grouping_type_parameter, void *udta, void *(*sg_create_entry)(void *udta), Bool (*sg_compare_entry)(void *udta, void *entry))\n#endif /* GPAC_DISABLE_ISOM_FRAGMENTS */\n{\n\tGF_List *groupList, *parent;\n\tvoid *entry;\n\tBool is_traf_sgpd;\n\tGF_SampleGroupDescriptionBox *sgdesc = NULL;\n\tu32 i, entry_idx;\n\n\tif (!stbl && !traf) return GF_BAD_PARAM;\n\n\tsgdesc = get_sgdp(stbl, traf, grouping_type, &is_traf_sgpd);\n\tif (!sgdesc) return GF_OUT_OF_MEM;\n\n\tentry = NULL;\n\tif (sg_compare_entry) {\n\t\tfor (i=0; i<gf_list_count(sgdesc->group_descriptions); i++) {\n\t\t\tentry = gf_list_get(sgdesc->group_descriptions, i);\n\t\t\tif (sg_compare_entry(udta, entry)) break;\n\t\t\tentry = NULL;\n\t\t}\n\t}\n\tif (!entry && sg_create_entry) {\n\t\tentry = sg_create_entry(udta);\n\t\tif (!entry) return GF_IO_ERR;\n\t\tif (traf && !is_traf_sgpd) {\n\t\t\tsgdesc = get_sgdp(NULL, traf, grouping_type, &is_traf_sgpd);\n\t\t}\n\t\tgf_list_add(sgdesc->group_descriptions, entry);\n\t}\n\tif (!entry)\n\t\tentry_idx = 0;\n\telse\n\t\tentry_idx = 1 + gf_list_find(sgdesc->group_descriptions, entry);\n\n\t/*look in stbl or traf for sample sampleGroups*/\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (traf) {\n\t\tif (!traf->sampleGroups)\n\t\t\ttraf->sampleGroups = gf_list_new();\n\t\tgroupList = traf->sampleGroups;\n\t\tparent = traf->child_boxes;\n\t\tif (entry_idx && is_traf_sgpd)\n\t\t\tentry_idx |= 0x10000;\n\t} else\n#endif\n\t{\n\t\tif (!stbl->sampleGroups)\n\t\t\tstbl->sampleGroups = gf_list_new();\n\t\tgroupList = stbl->sampleGroups;\n\t\tparent = stbl->child_boxes;\n\t}\n\n\treturn gf_isom_add_sample_group_entry(groupList, sample_number, sgdesc, grouping_type_parameter, entry_idx, parent, stbl);\n}\n\nstatic GF_Err gf_isom_set_sample_group_info_internal(GF_ISOFile *movie, u32 track, u32 trafID, u32 sample_number, u32 grouping_type, u32 grouping_type_parameter, void *udta, void *(*sg_create_entry)(void *udta), Bool (*sg_compare_entry)(void *udta, void *entry))\n{\n\tGF_Err e;\n\tGF_TrackBox *trak=NULL;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_TrackFragmentBox *traf=NULL;\n#endif\n\tif (!trafID && (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY)) {\n\t\ttrak = gf_isom_get_track_from_file(movie, track);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\ttrafID = trak->Header->trackID;\n\t}\n\n\tif (trafID) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (!movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) )\n\t\t\treturn GF_BAD_PARAM;\n\n\t\ttraf = gf_isom_get_traf(movie, trafID);\n#else\n\t\treturn GF_NOT_SUPPORTED;\n#endif\n\n\t} else if (track) {\n\t\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\tif (e) return e;\n\n\t\ttrak = gf_isom_get_track_from_file(movie, track);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\treturn gf_isom_set_sample_group_info_ex(trak ? trak->Media->information->sampleTable : NULL, traf, sample_number, grouping_type, grouping_type_parameter, udta, sg_create_entry, sg_compare_entry);\n#else\n\treturn gf_isom_set_sample_group_info_ex(trak->Media->information->sampleTable, NULL, sample_number, grouping_type, grouping_type_parameter, udta, sg_create_entry, sg_compare_entry);\n#endif\n\n}\n\nvoid *sgpd_parse_entry(GF_SampleGroupDescriptionBox *p, GF_BitStream *bs, s32 bytes_in_box, u32 entry_size, u32 *total_bytes);\n\nGF_Err gf_isom_add_sample_group_info_internal(GF_ISOFile *movie, u32 track, u32 grouping_type, void *data, u32 data_size, u32 sgpd_flags, u32 *sampleGroupDescriptionIndex, Bool *is_traf_sgpd, Bool check_access, Bool *use_default, GF_SampleGroupDescriptionBox **out_sgdesc)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak=NULL;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_TrackFragmentBox *traf=NULL;\n#else\n\tvoid *traf=NULL;\n#endif\n\tu32 trafID=0;\n\tGF_DefaultSampleGroupDescriptionEntry *entry=NULL;\n\tGF_SampleGroupDescriptionBox *sgdesc = NULL;\n\tBool is_default = sgpd_flags & 0x80000000;\n\n\tif (sampleGroupDescriptionIndex) *sampleGroupDescriptionIndex = 0;\n\n\tif (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) {\n\t\ttrak = gf_isom_get_track_from_file(movie, track);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\ttrafID = trak->Header->trackID;\n\t}\n\n\tif (trafID) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (!movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) )\n\t\t\treturn GF_BAD_PARAM;\n\n\t\ttraf = gf_isom_get_traf(movie, trafID);\n#else\n\t\treturn GF_NOT_SUPPORTED;\n#endif\n\t} else {\n\t\tif (check_access) {\n\t\t\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\t\tif (e) return e;\n\t\t}\n\n\t\ttrak = gf_isom_get_track_from_file(movie, track);\n\t}\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//get sample group desc for this grouping type\n\tsgdesc = get_sgdp(trak->Media->information->sampleTable, traf, grouping_type, is_traf_sgpd);\n\tif (!sgdesc) return GF_OUT_OF_MEM;\n\t//first time we create the sample group description, set flags\n\tif (!gf_list_count(sgdesc->group_descriptions) && !traf) {\n\t\tif (sgpd_flags&1) sgdesc->flags |= 1;\n\t\tif (sgpd_flags&2) sgdesc->flags |= 2;\n\t\tif (sgpd_flags&0x40000000) sgdesc->version=3;\n\t}\n\n\n\tGF_BitStream *bs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\tu32 bytes;\n\tentry = sgpd_parse_entry(sgdesc, bs, data_size, data_size, &bytes);\n\tgf_bs_del(bs);\n\tif (!entry) return GF_NON_COMPLIANT_BITSTREAM;\n\n\tif (out_sgdesc) *out_sgdesc = sgdesc;\n\n\n\t//find the same entry\n\tu32 k;\n\tfor (k=0; k<gf_list_count(sgdesc->group_descriptions); k++) {\n\t\tvoid *sgde_dst = gf_list_get(sgdesc->group_descriptions, k);\n\t\tif (gf_isom_is_identical_sgpd(entry, sgde_dst, sgdesc->grouping_type)) {\n\t\t\tif (sampleGroupDescriptionIndex) *sampleGroupDescriptionIndex = k+1;\n\t\t\tsgpd_del_entry(sgdesc->grouping_type, entry);\n\t\t\tif (use_default) {\n\t\t\t\tu32 idx = k+1;\n\t\t\t\tif (is_traf_sgpd && *is_traf_sgpd) idx |= 0x10000;\n\t\t\t\t*use_default = (sgdesc->default_description_index==idx) ? GF_TRUE : GF_FALSE;\n\t\t\t}\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tif (traf && ! *is_traf_sgpd) {\n\t\tsgdesc = get_sgdp(NULL, traf, grouping_type, is_traf_sgpd);\n\t\tif (!sgdesc) return GF_OUT_OF_MEM;\n\t}\n\tif (out_sgdesc) *out_sgdesc = sgdesc;\n\n\te = gf_list_add(sgdesc->group_descriptions, entry);\n\tif (e) {\n\t\tsgpd_del_entry(sgdesc->grouping_type, entry);\n\t\treturn e;\n\t}\n\n#if 0\n\tif (grouping_type==GF_ISOM_SAMPLE_GROUP_OINF) {\n\t\tGF_OperatingPointsInformation *ptr = gf_isom_oinf_new_entry();\n\t\tGF_BitStream *bs=gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\t\te = gf_isom_oinf_read_entry(ptr, bs);\n\t\tgf_bs_del(bs);\n\t\tif (e) {\n\t\t\tgf_isom_oinf_del_entry(ptr);\n\t\t\treturn e;\n\t\t}\n\t\t//not in track, create new sgdp\n\t\tif (traf && ! *is_traf_sgpd) {\n\t\t\tsgdesc  = get_sgdp(NULL, traf, grouping_type, is_traf_sgpd);\n\t\t\tif (!sgdesc) return GF_OUT_OF_MEM;\n\t\t}\n\t\te = gf_list_add(sgdesc->group_descriptions, ptr);\n\t\tif (e) return e;\n\t\tentry = (GF_DefaultSampleGroupDescriptionEntry *) ptr;\n\t} else if (grouping_type==GF_ISOM_SAMPLE_GROUP_LINF) {\n\t\tGF_LHVCLayerInformation *ptr = gf_isom_linf_new_entry();\n\t\tGF_BitStream *bs=gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\t\te = gf_isom_linf_read_entry(ptr, bs);\n\t\tgf_bs_del(bs);\n\t\tif (e) {\n\t\t\tgf_isom_linf_del_entry(ptr);\n\t\t\treturn e;\n\t\t}\n\n\t\tif (traf && ! *is_traf_sgpd) {\n\t\t\tsgdesc = get_sgdp(NULL, traf, grouping_type, is_traf_sgpd);\n\t\t\tif (!sgdesc) return GF_OUT_OF_MEM;\n\t\t}\n\n\t\te = gf_list_add(sgdesc->group_descriptions, ptr);\n\t\tif (e) return e;\n\t\tentry = (GF_DefaultSampleGroupDescriptionEntry *) ptr;\n\t} else {\n\t\tu32 i, count=gf_list_count(sgdesc->group_descriptions);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_DefaultSampleGroupDescriptionEntry *ent = gf_list_get(sgdesc->group_descriptions, i);\n\t\t\tif ((ent->length == data_size) && !memcmp(ent->data, data, data_size)) {\n\t\t\t\tentry = ent;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tentry=NULL;\n\t\t}\n\t\tif (!entry) {\n\t\t\tGF_SAFEALLOC(entry, GF_DefaultSampleGroupDescriptionEntry);\n\t\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\t\tentry->data = (u8*)gf_malloc(sizeof(char) * data_size);\n\t\t\tif (!entry->data) {\n\t\t\t\tgf_free(entry);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tentry->length = data_size;\n\t\t\tmemcpy(entry->data, data, sizeof(char) * data_size);\n\n\t\t\tif (traf && ! *is_traf_sgpd) {\n\t\t\t\tsgdesc = get_sgdp(NULL, traf, grouping_type, is_traf_sgpd);\n\t\t\t\tif (!sgdesc) return GF_OUT_OF_MEM;\n\t\t\t}\n\n\t\t\te = gf_list_add(sgdesc->group_descriptions, entry);\n\t\t\tif (e) {\n\t\t\t\tgf_free(entry->data);\n\t\t\t\tgf_free(entry);\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\n\tif (is_default && !sgdesc->default_description_index) {\n\t\tsgdesc->default_description_index = 1 + gf_list_find(sgdesc->group_descriptions, entry);\n\t\tif (sgdesc->version < 2) sgdesc->version = 2;\n\t\tif (is_traf_sgpd && *is_traf_sgpd) {\n\t\t\tsgdesc->default_description_index |= 0x10000;\n\t\t}\n\t}\n\tu32 grp_idx =  1 + gf_list_find(sgdesc->group_descriptions, entry);\n\tif (sampleGroupDescriptionIndex) *sampleGroupDescriptionIndex = grp_idx;\n\tif (use_default) {\n\t\tif (*is_traf_sgpd)\n\t\t\tgrp_idx |= 0x10000;\n\t\t*use_default = (sgdesc->default_description_index==grp_idx) ? GF_TRUE : GF_FALSE;\n\t}\n\treturn GF_OK;\n}\nGF_EXPORT\nGF_Err gf_isom_add_sample_group_info(GF_ISOFile *movie, u32 track, u32 grouping_type, void *data, u32 data_size, Bool is_default, u32 *sampleGroupDescriptionIndex)\n{\n\treturn gf_isom_add_sample_group_info_internal(movie, track, grouping_type, data, data_size, is_default ? 0x80000000 : 0, sampleGroupDescriptionIndex, NULL, GF_TRUE, NULL, NULL);\n}\n\nGF_Err gf_isom_set_sample_group_description_internal(GF_ISOFile *movie, u32 track, u32 sample_number, u32 grouping_type, u32 grouping_type_parameter, void *data, u32 data_size, Bool check_access, u32 sgpd_flags)\n{\n\tu32 sampleGroupDescriptionIndex, trafID=0;\n\tGF_Err e;\n\tGF_SampleGroupDescriptionBox *sgdesc=NULL;\n\tBool is_traf_sgpd, use_default=GF_FALSE;\n\tGF_List *groupList=NULL, *parent=NULL;\n\n\te = gf_isom_add_sample_group_info_internal(movie, track, grouping_type, data, data_size, sgpd_flags, &sampleGroupDescriptionIndex, &is_traf_sgpd, check_access, &use_default, &sgdesc);\n\tif (e) return e;\n\tif (use_default) return GF_OK;\n\n\tGF_SampleTableBox *stbl=NULL;\n\tGF_TrackBox *trak=NULL;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_TrackFragmentBox *traf=NULL;\n#endif\n\tif (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) {\n\t\ttrak = gf_isom_get_track_from_file(movie, track);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\ttrafID = trak->Header->trackID;\n\t}\n\n\tif (trafID) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (!movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) )\n\t\t\treturn GF_BAD_PARAM;\n\n\t\ttraf = gf_isom_get_traf(movie, trafID);\n#else\n\t\treturn GF_NOT_SUPPORTED;\n#endif\n\n\t} else if (track) {\n\t\tif (check_access) {\n\t\t\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\t\tif (e) return e;\n\t\t}\n\n\t\ttrak = gf_isom_get_track_from_file(movie, track);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t}\n\n\t/*look in stbl or traf for sample sampleGroups*/\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (traf) {\n\t\tif (!traf->sampleGroups)\n\t\t\ttraf->sampleGroups = gf_list_new();\n\t\tgroupList = traf->sampleGroups;\n\t\tparent = traf->child_boxes;\n\t\tif (sampleGroupDescriptionIndex && is_traf_sgpd)\n\t\t\tsampleGroupDescriptionIndex |= 0x10000;\n\t} else\n#endif\n\t{\n\t\tstbl = trak->Media->information->sampleTable;\n\t\tif (!stbl->sampleGroups)\n\t\t\tstbl->sampleGroups = gf_list_new();\n\t\tgroupList = stbl->sampleGroups;\n\t\tparent = stbl->child_boxes;\n\t}\n\n\treturn gf_isom_add_sample_group_entry(groupList, sample_number, sgdesc, grouping_type_parameter, sampleGroupDescriptionIndex, parent, stbl);\n\n}\n\nGF_Err gf_isom_set_sample_group_description(GF_ISOFile *movie, u32 track, u32 sample_number, u32 grouping_type, u32 grouping_type_parameter, void *data, u32 data_size, u32 sgpd_flags)\n{\n\treturn gf_isom_set_sample_group_description_internal(movie, track, sample_number, grouping_type, grouping_type_parameter, data, data_size, GF_TRUE, sgpd_flags);\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_sample_group(GF_ISOFile *movie, u32 track, u32 grouping_type)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tu32 count, i;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (trak->Media->information->sampleTable->sampleGroupsDescription) {\n\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\t\tif (sgdesc->grouping_type==grouping_type) {\n\t\t\t\tgf_isom_box_del_parent(&trak->Media->information->sampleTable->child_boxes, (GF_Box*)sgdesc);\n\t\t\t\tgf_list_rem(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\t\t\ti--;\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\t}\n\tif (trak->Media->information->sampleTable->sampleGroups) {\n\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroups);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SampleGroupBox *sgroup = gf_list_get(trak->Media->information->sampleTable->sampleGroups, i);\n\t\t\tif (sgroup->grouping_type==grouping_type) {\n\t\t\t\tgf_isom_box_del_parent(&trak->Media->information->sampleTable->child_boxes, (GF_Box*)sgroup);\n\t\t\t\tgf_list_rem(trak->Media->information->sampleTable->sampleGroups, i);\n\t\t\t\ti--;\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_sample_info(GF_ISOFile *movie, u32 track, u32 sample_number, u32 grouping_type, u32 sampleGroupDescriptionIndex, u32 grouping_type_parameter)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_List *groupList;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (!trak->Media->information->sampleTable->sampleGroups)\n\t\ttrak->Media->information->sampleTable->sampleGroups = gf_list_new();\n\n\n\tGF_SampleGroupDescriptionBox *sgdesc = get_sgdp(trak->Media->information->sampleTable, NULL, grouping_type, NULL);\n\tif (!sgdesc) return GF_BAD_PARAM;\n\n\tgroupList = trak->Media->information->sampleTable->sampleGroups;\n\treturn gf_isom_add_sample_group_entry(groupList, sample_number, sgdesc, grouping_type_parameter, sampleGroupDescriptionIndex, trak->Media->information->sampleTable->child_boxes, trak->Media->information->sampleTable);\n}\n\nvoid *sg_rap_create_entry(void *udta)\n{\n\tGF_VisualRandomAccessEntry *entry;\n\tu32 *num_leading_samples = (u32 *) udta;\n\tassert(udta);\n\tGF_SAFEALLOC(entry, GF_VisualRandomAccessEntry);\n\tif (!entry) return NULL;\n\tentry->num_leading_samples = *num_leading_samples;\n\tentry->num_leading_samples_known = entry->num_leading_samples ? 1 : 0;\n\treturn entry;\n}\n\nBool sg_rap_compare_entry(void *udta, void *entry)\n{\n\tu32 *num_leading_samples = (u32 *) udta;\n\tif (*num_leading_samples == ((GF_VisualRandomAccessEntry *)entry)->num_leading_samples) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_sample_rap_group(GF_ISOFile *movie, u32 track, u32 sample_number, Bool is_rap, u32 num_leading_samples)\n{\n\treturn gf_isom_set_sample_group_info_internal(movie, track, 0, sample_number, GF_ISOM_SAMPLE_GROUP_RAP, 0, &num_leading_samples, is_rap ? sg_rap_create_entry : NULL, is_rap ? sg_rap_compare_entry : NULL);\n}\n\nGF_Err gf_isom_fragment_set_sample_rap_group(GF_ISOFile *movie, GF_ISOTrackID trackID, u32 sample_number_in_frag, Bool is_rap, u32 num_leading_samples)\n{\n\treturn gf_isom_set_sample_group_info_internal(movie, 0, trackID, sample_number_in_frag, GF_ISOM_SAMPLE_GROUP_RAP, 0, &num_leading_samples, is_rap ? sg_rap_create_entry : NULL, is_rap ? sg_rap_compare_entry : NULL);\n}\n\n\n\nvoid *sg_roll_create_entry(void *udta)\n{\n\tGF_RollRecoveryEntry *entry;\n\ts16 *roll_distance = (s16 *) udta;\n\tGF_SAFEALLOC(entry, GF_RollRecoveryEntry);\n\tif (!entry) return NULL;\n\tentry->roll_distance = *roll_distance;\n\treturn entry;\n}\n\nBool sg_roll_compare_entry(void *udta, void *entry)\n{\n\ts16 *roll_distance = (s16 *) udta;\n\tif (*roll_distance == ((GF_RollRecoveryEntry *)entry)->roll_distance) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_sample_roll_group(GF_ISOFile *movie, u32 track, u32 sample_number, GF_ISOSampleRollType roll_type, s16 roll_distance)\n{\n\tu32 grp_type = (roll_type>=GF_ISOM_SAMPLE_PREROLL) ? GF_ISOM_SAMPLE_GROUP_PROL : GF_ISOM_SAMPLE_GROUP_ROLL;\n\tif (roll_type==GF_ISOM_SAMPLE_PREROLL_NONE)\n\t\troll_type = 0;\n\n\treturn gf_isom_set_sample_group_info_internal(movie, track, 0, sample_number, grp_type, 0, &roll_distance, roll_type ? sg_roll_create_entry : NULL, roll_type ? sg_roll_compare_entry : NULL);\n}\n\nGF_EXPORT\nGF_Err gf_isom_fragment_set_sample_roll_group(GF_ISOFile *movie, GF_ISOTrackID trackID, u32 sample_number_in_frag, GF_ISOSampleRollType roll_type, s16 roll_distance)\n{\n\tu32 grp_type = (roll_type>=GF_ISOM_SAMPLE_PREROLL) ? GF_ISOM_SAMPLE_GROUP_PROL : GF_ISOM_SAMPLE_GROUP_ROLL;\n\tif (roll_type==GF_ISOM_SAMPLE_PREROLL_NONE)\n\t\troll_type = 0;\n\n\treturn gf_isom_set_sample_group_info_internal(movie, 0, trackID, sample_number_in_frag, grp_type, 0, &roll_distance, roll_type ? sg_roll_create_entry : NULL, roll_type ? sg_roll_compare_entry : NULL);\n}\n\n\nvoid *sg_encryption_create_entry(void *udta)\n{\n\tGF_CENCSampleEncryptionGroupEntry *entry, *from_entry;\n\tGF_SAFEALLOC(entry, GF_CENCSampleEncryptionGroupEntry);\n\tif (!entry) return NULL;\n\tfrom_entry = (GF_CENCSampleEncryptionGroupEntry *)udta;\n\tmemcpy(entry, from_entry, sizeof(GF_CENCSampleEncryptionGroupEntry) );\n\tentry->key_info = gf_malloc(sizeof(u8) * entry->key_info_size);\n\tif (!entry->key_info) {\n\t\tgf_free(entry);\n\t\treturn NULL;\n\t}\n\tmemcpy(entry->key_info, from_entry->key_info, entry->key_info_size);\n\treturn entry;\n}\n\nBool sg_encryption_compare_entry(void *udta, void *_entry)\n{\n\tGF_CENCSampleEncryptionGroupEntry *entry = (GF_CENCSampleEncryptionGroupEntry *)_entry;\n\tGF_CENCSampleEncryptionGroupEntry *with_entry = (GF_CENCSampleEncryptionGroupEntry *)udta;\n\n\tif (entry->IsProtected != with_entry->IsProtected) return GF_FALSE;\n\tif (entry->skip_byte_block != with_entry->skip_byte_block) return GF_FALSE;\n\tif (entry->crypt_byte_block != with_entry->crypt_byte_block) return GF_FALSE;\n\tif (entry->key_info_size != with_entry->key_info_size) return GF_FALSE;\n\n\tif (!memcmp(entry->key_info, with_entry->key_info, with_entry->key_info_size))\n\t\treturn GF_TRUE;\n\treturn GF_FALSE;\n}\n\n\n/*sample encryption information group can be in stbl or traf*/\nGF_EXPORT\nGF_Err gf_isom_set_sample_cenc_group(GF_ISOFile *movie, u32 track, u32 sample_number, u8 isEncrypted, u8 crypt_byte_block, u8 skip_byte_block, u8 *key_info, u32 key_info_size)\n{\n\tGF_CENCSampleEncryptionGroupEntry entry;\n\tif (!key_info || (key_info_size<19))\n\t\treturn GF_BAD_PARAM;\n\n\tmemset(&entry, 0, sizeof(GF_CENCSampleEncryptionGroupEntry));\n\tentry.crypt_byte_block = crypt_byte_block;\n\tentry.skip_byte_block = skip_byte_block;\n\tentry.IsProtected = isEncrypted;\n\tentry.key_info = key_info;\n\tentry.key_info_size = key_info_size;\n\n\treturn gf_isom_set_sample_group_info_internal(movie, track, 0, sample_number, GF_ISOM_SAMPLE_GROUP_SEIG, 0, &entry, sg_encryption_create_entry, sg_encryption_compare_entry);\n}\n\n\n\nGF_EXPORT\nGF_Err gf_isom_set_sample_cenc_default_group(GF_ISOFile *movie, u32 track, u32 sample_number)\n{\n\treturn gf_isom_set_sample_group_info_internal(movie, track, 0, sample_number, GF_ISOM_SAMPLE_GROUP_SEIG, 0, NULL, NULL, NULL);\n}\n\nGF_Err gf_isom_force_ctts(GF_ISOFile *file, u32 track)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n \ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (trak->Media->information->sampleTable->CompositionOffset) return GF_OK;\n\n\ttrak->Media->information->sampleTable->CompositionOffset = (GF_CompositionOffsetBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_CTTS);\n\tif (!trak->Media->information->sampleTable->CompositionOffset) return GF_OUT_OF_MEM;\n\ttrak->Media->information->sampleTable->CompositionOffset->nb_entries = 1;\n\ttrak->Media->information->sampleTable->CompositionOffset->entries = gf_malloc(sizeof(GF_DttsEntry));\n\ttrak->Media->information->sampleTable->CompositionOffset->entries[0].decodingOffset = 0;\n\ttrak->Media->information->sampleTable->CompositionOffset->entries[0].sampleCount = \ttrak->Media->information->sampleTable->SampleSize->sampleCount;\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_set_ctts_v1(GF_ISOFile *file, u32 track, u32 ctts_shift)\n{\n\tu32 i, shift;\n\tu64 duration;\n\tGF_CompositionOffsetBox *ctts;\n\tGF_CompositionToDecodeBox *cslg;\n\ts32 leastCTTS, greatestCTTS;\n\tGF_TrackBox *trak;\n\tGF_Err e = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n \ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tctts = trak->Media->information->sampleTable->CompositionOffset;\n\tif (ctts->version) {\n\t\tshift = ctts_shift;\n\t} else {\n\t\tshift = ctts->nb_entries ? ctts->entries[0].decodingOffset : 0;\n\t}\n\tleastCTTS = GF_INT_MAX;\n\tgreatestCTTS = 0;\n\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\tif (!ctts->version)\n\t\t\tctts->entries[i].decodingOffset -= shift;\n\n\t\tif ((s32)ctts->entries[i].decodingOffset < leastCTTS)\n\t\t\tleastCTTS = ctts->entries[i].decodingOffset;\n\t\tif ((s32)ctts->entries[i].decodingOffset > greatestCTTS)\n\t\t\tgreatestCTTS = ctts->entries[i].decodingOffset;\n\t}\n\tif (!ctts->version) {\n\t\tctts->version = 1;\n\t\t//if we had edit lists, shift all media times by the given amount\n\t\tif (trak->editBox && trak->editBox->editList) {\n\t\t\tfor (i=0; i<gf_list_count(trak->editBox->editList->entryList); i++) {\n\t\t\t\tGF_EdtsEntry *ent = (GF_EdtsEntry*)gf_list_get(trak->editBox->editList->entryList, i);\n\t\t\t\t//empty edit\n\t\t\t\tif (ent->mediaTime<0) continue;\n\t\t\t\tif (ent->mediaTime>=shift) ent->mediaTime -= shift;\n\t\t\t\telse ent->mediaTime = 0;\n\t\t\t\t//no offset and last entry, trash edit\n\t\t\t\tif (!ent->mediaTime && (gf_list_count(trak->editBox->editList->entryList)==1)) {\n\t\t\t\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->editBox);\n\t\t\t\t\ttrak->editBox = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSetTrackDuration(trak);\n\t\t}\n\t}\n\n\tif (!trak->Media->information->sampleTable->CompositionToDecode) {\n\t\ttrak->Media->information->sampleTable->CompositionToDecode = (GF_CompositionToDecodeBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_CSLG);\n\t\tif (!trak->Media->information->sampleTable->CompositionToDecode)\n\t\t\treturn GF_OUT_OF_MEM;\n\t}\n\n\tcslg = trak->Media->information->sampleTable->CompositionToDecode;\n\tif (cslg) {\n\t\tcslg->compositionToDTSShift = shift;\n\t\tcslg->leastDecodeToDisplayDelta = leastCTTS;\n\t\tcslg->greatestDecodeToDisplayDelta = greatestCTTS;\n\t\tcslg->compositionStartTime = 0;\n\t\t/*for our use case (first CTS set to 0), the composition end time is the media duration if it fits on 32 bits*/\n\t\tduration = gf_isom_get_media_duration(file, track);\n\t\tcslg->compositionEndTime = (duration<0x7FFFFFFF) ? (s32) duration : 0;\n\t}\n\n\tgf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_ISO4, GF_TRUE);\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_isom_set_ctts_v0(GF_ISOFile *file, GF_TrackBox *trak)\n{\n\tu32 i;\n\ts32 shift;\n\tGF_CompositionOffsetBox *ctts;\n\tGF_CompositionToDecodeBox *cslg;\n\n\tctts = trak->Media->information->sampleTable->CompositionOffset;\n\n\tif (!trak->Media->information->sampleTable->CompositionToDecode)\n\t{\n\t\tshift = 0;\n\t\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\t\tif (-ctts->entries[i].decodingOffset > shift)\n\t\t\t\tshift = -ctts->entries[i].decodingOffset;\n\t\t}\n\t\tif (shift > 0)\n\t\t{\n\t\t\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\t\t\ts64 new_ts = ctts->entries[i].decodingOffset;\n\t\t\t\tnew_ts += shift;\n\t\t\t\tctts->entries[i].decodingOffset = (s32) new_ts;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tcslg = trak->Media->information->sampleTable->CompositionToDecode;\n\t\tshift = cslg->compositionToDTSShift;\n\t\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\t\ts64 new_ts = ctts->entries[i].decodingOffset;\n\t\t\tnew_ts += shift;\n\t\t\tctts->entries[i].decodingOffset = (s32) new_ts;\n\t\t}\n\t\tgf_isom_box_del_parent(&trak->Media->information->sampleTable->child_boxes, (GF_Box *)cslg);\n\t\ttrak->Media->information->sampleTable->CompositionToDecode = NULL;\n\t}\n\tif (shift>0) {\n\t\t//no edits, insert one\n\t\tif (! trak->editBox) {\n\t\t\tu64 dur = trak->Media->mediaHeader->duration;\n\t\t\tdur *= file->moov->mvhd->timeScale;\n\t\t\tdur /= trak->Media->mediaHeader->timeScale;\n\t\t\tgf_isom_set_edit(file, gf_list_find(file->moov->trackList, trak)+1, 0, dur, shift, GF_ISOM_EDIT_NORMAL);\n\t\t} else {\n\t\t\t//otherwise shift media times in all entries\n\t\t\tfor (i=0; i<gf_list_count(trak->editBox->editList->entryList); i++) {\n\t\t\t\tGF_EdtsEntry *ent = (GF_EdtsEntry*)gf_list_get(trak->editBox->editList->entryList, i);\n\t\t\t\t//empty edit\n\t\t\t\tif (ent->mediaTime<0) continue;\n\t\t\t\tent->mediaTime += shift;\n\t\t\t}\n\t\t\tSetTrackDuration(trak);\n\t\t}\n\t}\n\tctts->version = 0;\n\tgf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_ISO4, GF_FALSE);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_composition_offset_mode(GF_ISOFile *file, u32 track, Bool use_negative_offsets)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_CompositionOffsetBox *ctts;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tctts = trak->Media->information->sampleTable->CompositionOffset;\n\tif (!ctts) {\n\t\tif (!use_negative_offsets && trak->Media->information->sampleTable->CompositionToDecode) {\n\t\t\tgf_isom_box_del_parent(&trak->Media->information->sampleTable->child_boxes, (GF_Box *)trak->Media->information->sampleTable->CompositionToDecode);\n\t\t\ttrak->Media->information->sampleTable->CompositionToDecode = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tif (use_negative_offsets) {\n\t\treturn gf_isom_set_ctts_v1(file, track, 0);\n\t} else {\n\t\tif (ctts->version==0) return GF_OK;\n\t\treturn gf_isom_set_ctts_v0(file, trak);\n\t}\n}\n\n#if 0 //unused\nGF_Err gf_isom_set_sync_table(GF_ISOFile *file, u32 track)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (!trak->Media->information->sampleTable->SyncSample) {\n\t\ttrak->Media->information->sampleTable->SyncSample = (GF_SyncSampleBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSS);\n\n\t\tif (!trak->Media->information->sampleTable->SyncSample)\n\t\t\treturn GF_OUT_OF_MEM;\n\t}\n\treturn GF_OK;\n}\n#endif\n\nGF_Err gf_isom_set_sample_flags(GF_ISOFile *file, u32 track, u32 sampleNumber, u32 isLeading, u32 dependsOn, u32 dependedOn, u32 redundant)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\treturn stbl_SetDependencyType(trak->Media->information->sampleTable, sampleNumber, isLeading, dependsOn, dependedOn, redundant);\n}\n\n#if 0 //unused\nGF_Err gf_isom_sample_set_dep_info(GF_ISOFile *file, u32 track, u32 sampleNumber, u32 isLeading, u32 dependsOn, u32 dependedOn, u32 redundant)\n{\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\treturn stbl_AddDependencyType(trak->Media->information->sampleTable, sampleNumber, isLeading, dependsOn, dependedOn, redundant);\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_copy_sample_info(GF_ISOFile *dst, u32 dst_track, GF_ISOFile *src, u32 src_track, u32 sampleNumber)\n{\n\tu32 i, count, idx, dst_sample_num, subs_flags;\n\tGF_SubSampleInfoEntry *sub_sample;\n\tGF_Err e;\n\tGF_TrackBox *src_trak, *dst_trak;\n\n\tsrc_trak = gf_isom_get_track_from_file(src, src_track);\n\tif (!src_trak) return GF_BAD_PARAM;\n\n\tdst_trak = gf_isom_get_track_from_file(dst, dst_track);\n\tif (!dst_trak) return GF_BAD_PARAM;\n\n\tdst_sample_num = dst_trak->Media->information->sampleTable->SampleSize->sampleCount;\n\n\t/*modify depends flags*/\n\tif (src_trak->Media->information->sampleTable->SampleDep) {\n\t\tu32 isLeading, dependsOn, dependedOn, redundant;\n\n\t\tisLeading = dependsOn = dependedOn = redundant = 0;\n\n\t\te = stbl_GetSampleDepType(src_trak->Media->information->sampleTable->SampleDep, sampleNumber, &isLeading, &dependsOn, &dependedOn, &redundant);\n\t\tif (e) return e;\n\n\t\te = stbl_AppendDependencyType(dst_trak->Media->information->sampleTable, isLeading, dependsOn, dependedOn, redundant);\n\t\tif (e) return e;\n\t}\n\n\t/*copy subsample info if any*/\n\tidx=1;\n\twhile (gf_isom_get_subsample_types(src, src_track, idx, &subs_flags)) {\n\t\tGF_SubSampleInformationBox *dst_subs=NULL;\n\t\tidx++;\n\n\t\tif ( ! gf_isom_sample_get_subsample_entry(src, src_track, sampleNumber, subs_flags, &sub_sample))\n\t\t\tcontinue;\n\n\t\t/*create subsample if needed*/\n\t\tif (!dst_trak->Media->information->sampleTable->sub_samples) {\n\t\t\tdst_trak->Media->information->sampleTable->sub_samples = gf_list_new();\n\t\t}\n\t\tcount = gf_list_count(dst_trak->Media->information->sampleTable->sub_samples);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tdst_subs = gf_list_get(dst_trak->Media->information->sampleTable->sub_samples, i);\n\t\t\tif (dst_subs->flags==subs_flags) break;\n\t\t\tdst_subs=NULL;\n\t\t}\n\t\tif (!dst_subs) {\n\t\t\tdst_subs = (GF_SubSampleInformationBox *) gf_isom_box_new_parent(&dst_trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_SUBS);\n\t\t\tif (!dst_subs) return GF_OUT_OF_MEM;\n\t\t\tdst_subs->version=0;\n\t\t\tdst_subs->flags = subs_flags;\n\t\t\tgf_list_add(dst_trak->Media->information->sampleTable->sub_samples, dst_subs);\n\t\t}\n\n\t\tcount = gf_list_count(sub_sample->SubSamples);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SubSampleEntry *entry = (GF_SubSampleEntry*)gf_list_get(sub_sample->SubSamples, i);\n\t\t\te = gf_isom_add_subsample_info(dst_subs, dst_sample_num, entry->subsample_size, entry->subsample_priority, entry->reserved, entry->discardable);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\n\t/*copy sampleToGroup info if any*/\n\tcount = 0;\n\tif (src_trak->Media->information->sampleTable->sampleGroups)\n\t\tcount = gf_list_count(src_trak->Media->information->sampleTable->sampleGroups);\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupBox *sg;\n\t\tu32 j, k, default_index;\n\t\tu32 first_sample_in_entry, last_sample_in_entry, group_desc_index_src, group_desc_index_dst;\n\t\tfirst_sample_in_entry = 1;\n\n\t\tsg = (GF_SampleGroupBox*)gf_list_get(src_trak->Media->information->sampleTable->sampleGroups, i);\n\t\tfor (j=0; j<sg->entry_count; j++) {\n\t\t\tGF_SampleGroupDescriptionBox *sgd_dst = NULL;\n\t\t\tlast_sample_in_entry = first_sample_in_entry + sg->sample_entries[j].sample_count - 1;\n\t\t\tif ((sampleNumber<first_sample_in_entry) || (sampleNumber>last_sample_in_entry)) {\n\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!dst_trak->Media->information->sampleTable->sampleGroups)\n\t\t\t\tdst_trak->Media->information->sampleTable->sampleGroups = gf_list_new();\n\n\t\t\tgroup_desc_index_src = group_desc_index_dst = sg->sample_entries[j].group_description_index;\n\n\t\t\tif (group_desc_index_src) {\n\t\t\t\tGF_SampleGroupDescriptionBox *sgd_src;\n\t\t\t\tvoid *sgde_src, *sgde_dst;\n\n\t\t\t\tgroup_desc_index_dst = 0;\n\t\t\t\t//check that the sample group description exists !!\n\t\t\t\tsgde_src = gf_isom_get_sample_group_info_entry(src, src_trak, sg->grouping_type, sg->sample_entries[j].group_description_index, &default_index, &sgd_src);\n\n\t\t\t\tif (!sgde_src) break;\n\n\t\t\t\tif (!dst_trak->Media->information->sampleTable->sampleGroupsDescription)\n\t\t\t\t\tdst_trak->Media->information->sampleTable->sampleGroupsDescription = gf_list_new();\n\n\t\t\t\tsgd_dst = NULL;\n\t\t\t\tfor (k=0; k< gf_list_count(dst_trak->Media->information->sampleTable->sampleGroupsDescription); k++) {\n\t\t\t\t\tsgd_dst = gf_list_get(dst_trak->Media->information->sampleTable->sampleGroupsDescription, k);\n\t\t\t\t\tif (sgd_dst->grouping_type==sgd_src->grouping_type) break;\n\t\t\t\t\tsgd_dst = NULL;\n\t\t\t\t}\n\t\t\t\tif (!sgd_dst) {\n\t\t\t\t\tgf_isom_clone_box( (GF_Box *) sgd_src, (GF_Box **) &sgd_dst);\n\t\t\t\t\tif (!sgd_dst) return GF_OUT_OF_MEM;\n\t\t\t\t\tgf_list_add(dst_trak->Media->information->sampleTable->sampleGroupsDescription, sgd_dst);\n\t\t\t\t\tgf_list_add(dst_trak->Media->information->sampleTable->child_boxes, sgd_dst);\n\t\t\t\t}\n\n\t\t\t\t//find the same entry\n\t\t\t\tfor (k=0; k<gf_list_count(sgd_dst->group_descriptions); k++) {\n\t\t\t\t\tsgde_dst = gf_list_get(sgd_dst->group_descriptions, k);\n\t\t\t\t\tif (gf_isom_is_identical_sgpd(sgde_src, sgde_dst, sgd_src->grouping_type)) {\n\t\t\t\t\t\tgroup_desc_index_dst = k+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!group_desc_index_dst) {\n\t\t\t\t\tGF_SampleGroupDescriptionBox *cloned=NULL;\n\t\t\t\t\tgf_isom_clone_box( (GF_Box *) sgd_src, (GF_Box **)  &cloned);\n\t\t\t\t\tif (!cloned) return GF_OUT_OF_MEM;\n\t\t\t\t\tsgde_dst = gf_list_get(cloned->group_descriptions, group_desc_index_dst);\n\t\t\t\t\tgf_list_rem(cloned->group_descriptions, group_desc_index_dst);\n\t\t\t\t\tgf_isom_box_del( (GF_Box *) cloned);\n\t\t\t\t\tgf_list_add(sgd_dst->group_descriptions, sgde_dst);\n\t\t\t\t\tgroup_desc_index_dst = gf_list_count(sgd_dst->group_descriptions);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_isom_get_sample_group_info_entry(dst, dst_trak, sg->grouping_type, 1, NULL, &sgd_dst);\n\t\t\t\tif (!sgd_dst) continue;\n\t\t\t}\n\n\t\t\t/*found our sample, add it to trak->sampleGroups*/\n\t\t\te = gf_isom_add_sample_group_entry(dst_trak->Media->information->sampleTable->sampleGroups, dst_sample_num, sgd_dst, sg->grouping_type_parameter, group_desc_index_dst, dst_trak->Media->information->sampleTable->child_boxes, NULL);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t//copy auxiliary info\n\tcount = gf_list_count(src_trak->Media->information->sampleTable->sai_sizes);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j;\n\t\tGF_SampleAuxiliaryInfoOffsetBox *saio = NULL;\n\t\tGF_SampleAuxiliaryInfoSizeBox *saiz = gf_list_get(src_trak->Media->information->sampleTable->sai_sizes, i);\n\n\t\tswitch (saiz->aux_info_type) {\n\t\tcase GF_ISOM_CENC_SCHEME:\n\t\tcase GF_ISOM_CBC_SCHEME:\n\t\tcase GF_ISOM_CENS_SCHEME:\n\t\tcase GF_ISOM_CBCS_SCHEME:\n\t\tcase GF_ISOM_PIFF_SCHEME:\n\t\tcase 0:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\t//no aux sample associated\n\t\tif (saiz->sample_count<sampleNumber) continue;\n\t\t//no size associated\n\t\tif (!saiz->default_sample_info_size && !saiz->sample_info_size[sampleNumber-1]) continue;\n\n\t\tfor (j=0; j<gf_list_count(src_trak->Media->information->sampleTable->sai_offsets); j++) {\n\t\t\tsaio = gf_list_get(src_trak->Media->information->sampleTable->sai_offsets, j);\n\t\t\tif ((saio->aux_info_type==saiz->aux_info_type) && (saio->aux_info_type_parameter==saiz->aux_info_type_parameter)) break;\n\t\t\tsaio=NULL;\n\t\t}\n\t\tif (!saio) continue;\n\t\tif (!saio->offsets && !saio->sai_data) continue;\n\n\t\tu64 offset = saio->offsets ? saio->offsets[0] : 0;\n\t\tu32 nb_saio = saio->entry_count;\n\t\tif ((nb_saio>1) && (saio->entry_count != saiz->sample_count)) continue;\n\n\t\tu32 size;\n\n\t\tif (nb_saio == 1) {\n\t\t\tfor (j=0; j < sampleNumber-1; j++) {\n\t\t\t\tsize = saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[j];\n\t\t\t\toffset += size;\n\t\t\t}\n\t\t} else {\n\t\t\toffset = saio->offsets[sampleNumber-1];\n\t\t}\n\n\t\tsize = saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[j];\n\n\t\tif (saio->sai_data) {\n\t\t\te = gf_isom_add_sample_aux_info_internal(dst_trak, NULL, j+1, saiz->aux_info_type, saiz->aux_info_type_parameter, saio->sai_data->data + offset, size);\n\t\t} else {\n\t\t\tu8 *sai = gf_malloc(size);\n\t\t\tif (!sai) return GF_OUT_OF_MEM;\n\n\t\t\tu64 cur_position = gf_bs_get_position(src_trak->moov->mov->movieFileMap->bs);\n\t\t\tgf_bs_seek(src_trak->moov->mov->movieFileMap->bs, offset);\n\n\t\t\tgf_bs_read_data(src_trak->moov->mov->movieFileMap->bs, sai, size);\n\t\t\tgf_bs_seek(src_trak->moov->mov->movieFileMap->bs, cur_position);\n\t\t\te = gf_isom_add_sample_aux_info_internal(dst_trak, NULL, j+1, saiz->aux_info_type, saiz->aux_info_type_parameter, sai, size);\n\t\t\tgf_free(sai);\n\t\t}\n\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isobmf] Failed to clone sai data: %s\\n\", gf_error_to_string(e) ));\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_set_display_flags(GF_ISOFile *file, u32 track, u32 desc_index, u32 flags, GF_TextFlagsMode op_type)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tfor (i=0; i < gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes); i++) {\n\t\tGF_Tx3gSampleEntryBox *txt;\n\t\tif (desc_index && (i+1 != desc_index)) continue;\n\n\t\ttxt = (GF_Tx3gSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\tif (txt->type != GF_ISOM_BOX_TYPE_TX3G) continue;\n\n\t\tswitch (op_type) {\n\t\tcase GF_ISOM_TEXT_FLAGS_TOGGLE:\n\t\t\ttxt->displayFlags |= flags;\n\t\t\tbreak;\n\t\tcase GF_ISOM_TEXT_FLAGS_UNTOGGLE:\n\t\t\ttxt->displayFlags &= ~flags;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttxt->displayFlags = flags;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_update_duration(GF_ISOFile *movie)\n{\n\tu32 i;\n\tu64 maxDur;\n\tGF_TrackBox *trak;\n\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\n\t//if file was open in Write or Edit mode, recompute the duration\n\t//the duration of a movie is the MaxDuration of all the tracks...\n\n\tmaxDur = 0;\n\ti=0;\n\twhile ((trak = (GF_TrackBox *)gf_list_enum(movie->moov->trackList, &i))) {\n\t\tif( (movie->LastError = SetTrackDuration(trak))\t) return movie->LastError;\n\t\tif (trak->Header && (trak->Header->duration > maxDur))\n\t\t\tmaxDur = trak->Header->duration;\n\t}\n\tmovie->moov->mvhd->duration = maxDur;\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_update_edit_list_duration(GF_ISOFile *file, u32 track)\n{\n\tu32 i;\n\tu64 trackDuration;\n\tGF_EdtsEntry *ent;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\n\t//the total duration is the media duration: adjust it in case...\n\te = Media_SetDuration(trak);\n\tif (e) return e;\n\n\t//assert the timeScales are non-NULL\n\tif (!trak->moov->mvhd->timeScale || !trak->Media->mediaHeader->timeScale) return GF_ISOM_INVALID_FILE;\n\ttrackDuration = (trak->Media->mediaHeader->duration * trak->moov->mvhd->timeScale) / trak->Media->mediaHeader->timeScale;\n\n\t//if we have an edit list, the duration is the sum of all the editList\n\t//entries' duration (always expressed in MovieTimeScale)\n\tif (trak->editBox && trak->editBox->editList) {\n\t\tu64 editListDuration = 0;\n\t\tGF_EditListBox *elst = trak->editBox->editList;\n\t\ti=0;\n\t\twhile ((ent = (GF_EdtsEntry*)gf_list_enum(elst->entryList, &i))) {\n\t\t\tif ((ent->mediaTime>=0) && (ent->mediaRate==0x10000) && (ent->segmentDuration > trackDuration))\n\t\t\t\tent->segmentDuration = trackDuration;\n\n\t\t\tif (!ent->segmentDuration) {\n\t\t\t\tu64 diff;\n\t\t\t\tent->segmentDuration = trackDuration;\n\t\t\t\tif (ent->mediaTime>0) {\n\t\t\t\t\tdiff = ent->mediaTime;\n\t\t\t\t\tdiff *= trak->moov->mvhd->timeScale;\n\t\t\t\t\tdiff /= trak->Media->mediaHeader->timeScale;\n\t\t\t\t\tif (diff < ent->segmentDuration)\n\t\t\t\t\t\tent->segmentDuration -= diff;\n\t\t\t\t\t/*\n\t\t\t\t\telse\n\t\t\t\t\t\tdiff = 0;\n\t\t\t\t\t*/\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((ent->mediaTime>=0) && ((u64) ent->mediaTime>=trak->Media->mediaHeader->duration)) {\n\t\t\t\tent->mediaTime = trak->Media->mediaHeader->duration;\n\t\t\t}\n\t\t\teditListDuration += ent->segmentDuration;\n\t\t}\n\t\ttrackDuration = editListDuration;\n\t}\n\tif (!trackDuration) {\n\t\ttrackDuration = (trak->Media->mediaHeader->duration * trak->moov->mvhd->timeScale) / trak->Media->mediaHeader->timeScale;\n\t}\n\ttrak->Header->duration = trackDuration;\n\n\treturn GF_OK;\n\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_clone_pssh(GF_ISOFile *output, GF_ISOFile *input, Bool in_moof) {\n\tGF_Box *a;\n\tu32 i;\n\ti = 0;\n\n\twhile ((a = (GF_Box *)gf_list_enum(input->moov->child_boxes, &i))) {\n\t\tif (a->type == GF_ISOM_BOX_TYPE_PSSH) {\n\t\t\tGF_List **child_boxes = &output->moov->child_boxes;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (in_moof)\n\t\t\t\tchild_boxes = &output->moof->child_boxes;\n#endif\n\n\t\t\tGF_ProtectionSystemHeaderBox *pssh = (GF_ProtectionSystemHeaderBox *)gf_isom_box_new_parent(child_boxes, GF_ISOM_BOX_TYPE_PSSH);\n\t\t\tif (!pssh) return GF_OUT_OF_MEM;\n\t\t\tmemmove(pssh->SystemID, ((GF_ProtectionSystemHeaderBox *)a)->SystemID, 16);\n\t\t\tif (((GF_ProtectionSystemHeaderBox *)a)->KIDs && ((GF_ProtectionSystemHeaderBox *)a)->KID_count > 0) {\n\t\t\t\tpssh->KID_count = ((GF_ProtectionSystemHeaderBox *)a)->KID_count;\n\t\t\t\tpssh->KIDs = (bin128 *)gf_malloc(pssh->KID_count*sizeof(bin128));\n\t\t\t\tif (!pssh->KIDs) return GF_OUT_OF_MEM;\n\t\t\t\tmemmove(pssh->KIDs, ((GF_ProtectionSystemHeaderBox *)a)->KIDs, pssh->KID_count*sizeof(bin128));\n\t\t\t}\n\t\t\tpssh->private_data_size = ((GF_ProtectionSystemHeaderBox *)a)->private_data_size;\n\t\t\tpssh->private_data = (u8 *)gf_malloc(pssh->private_data_size*sizeof(char));\n\t\t\tif (!pssh->private_data) return GF_OUT_OF_MEM;\n\t\t\tmemmove(pssh->private_data, ((GF_ProtectionSystemHeaderBox *)a)->private_data, pssh->private_data_size);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_group(GF_ISOFile *file, u32 track_number, u32 track_group_id, u32 group_type, Bool do_add)\n{\n\tu32 i, j;\n\tGF_TrackGroupTypeBox *trgt;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track_number);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->groups) trak->groups = (GF_TrackGroupBox*) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TRGR);\n\tif (!trak->groups) return GF_OUT_OF_MEM;\n\n\tfor (j=0; j<gf_list_count(file->moov->trackList); j++) {\n\t\tGF_TrackBox *a_trak = gf_list_get(file->moov->trackList, j);\n\t\tif (!a_trak->groups) continue;\n\n\t\tfor (i=0; i<gf_list_count(a_trak->groups->groups); i++) {\n\t\t\ttrgt = gf_list_get(a_trak->groups->groups, i);\n\n\t\t\tif (trgt->track_group_id==track_group_id) {\n\t\t\t\tif (trgt->group_type != group_type) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"A track with same group ID is already defined for different group type %s\\n\", gf_4cc_to_str(trgt->group_type) ));\n\t\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t\t}\n\t\t\t\tif (a_trak==trak) {\n\t\t\t\t\tif (!do_add) {\n\t\t\t\t\t\tgf_list_rem(trak->groups->groups, i);\n\t\t\t\t\t\tgf_isom_box_del_parent(&trak->groups->child_boxes, (GF_Box *)trgt);\n\t\t\t\t\t}\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//not found, add new group\n\ttrgt = (GF_TrackGroupTypeBox*) gf_isom_box_new_parent(&trak->groups->child_boxes, GF_ISOM_BOX_TYPE_TRGT);\n\tif (!trgt) return GF_OUT_OF_MEM;\n\ttrgt->track_group_id = track_group_id;\n\ttrgt->group_type = group_type;\n\treturn gf_list_add(trak->groups->groups, trgt);\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_nalu_length_field(GF_ISOFile *file, u32 track, u32 StreamDescriptionIndex, u32 nalu_size_length)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_MPEGVisualSampleEntryBox *ve;\n\tGF_SampleDescriptionBox *stsd;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd || !StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (!entry || ! gf_isom_is_nalu_based_entry(trak->Media, entry)) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tve = (GF_MPEGVisualSampleEntryBox*)entry;\n\tif (ve->avc_config) ve->avc_config->config->nal_unit_size = nalu_size_length;\n\tif (ve->svc_config) ve->svc_config->config->nal_unit_size = nalu_size_length;\n\tif (ve->hevc_config) ve->hevc_config->config->nal_unit_size = nalu_size_length;\n\tif (ve->lhvc_config) ve->lhvc_config->config->nal_unit_size = nalu_size_length;\n\tif (ve->vvc_config) ve->vvc_config->config->nal_unit_size = nalu_size_length;\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_set_sample_group_in_traf(GF_ISOFile *file)\n{\n\tGF_Err e;\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tfile->sample_groups_in_traf = GF_TRUE;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nvoid gf_isom_set_progress_callback(GF_ISOFile *file, void (*progress_cbk)(void *udta, u64 nb_done, u64 nb_total), void *progress_cbk_udta)\n{\n\tif (file) {\n\t\tfile->progress_cbk = progress_cbk;\n\t\tfile->progress_cbk_udta = progress_cbk_udta;\n\n\t}\n}\n\nGF_Err gf_isom_update_video_sample_entry_fields(GF_ISOFile *file, u32 track, u32 stsd_idx, u16 revision, u32 vendor, u32 temporalQ, u32 spatialQ, u32 horiz_res, u32 vert_res, u16 frames_per_sample, const char *compressor_name, s16 color_table_index)\n{\n\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *vid_ent;\n\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak || !stsd_idx) return GF_BAD_PARAM;\n\n\tif (!trak->Media || !trak->Media->handler || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleDescription)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_VISUAL:\n    case GF_ISOM_MEDIA_AUXV:\n    case GF_ISOM_MEDIA_PICT:\n    \tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\tvid_ent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, stsd_idx-1);\n\tif (!vid_ent)\n\t\treturn GF_BAD_PARAM;\n\n\tvid_ent->revision = revision;\n\tvid_ent->vendor = vendor;\n\tvid_ent->temporal_quality = temporalQ;\n\tvid_ent->spatial_quality = spatialQ;\n\tvid_ent->horiz_res = horiz_res;\n\tvid_ent->vert_res = vert_res;\n\tvid_ent->frames_per_sample = frames_per_sample;\n\tif (compressor_name)\n\t\tstrncpy(vid_ent->compressor_name, compressor_name, 32);\n\n\tvid_ent->color_table_index = color_table_index;\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_update_sample_description_from_template(GF_ISOFile *file, u32 track, u32 sampleDescriptionIndex, u8 *data, u32 size)\n{\n\tGF_BitStream *bs;\n\tGF_TrackBox *trak;\n\tGF_Box *ent, *tpl_ent;\n\tGF_Err e;\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak || !sampleDescriptionIndex) return GF_BAD_PARAM;\n\n\tif (!trak->Media || !trak->Media->handler || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleDescription)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex-1);\n\tif (!ent) return GF_BAD_PARAM;\n\n\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n//\te = gf_isom_box_parse(&tpl_ent, bs);\n\te = gf_isom_box_parse_ex(&tpl_ent, bs, GF_ISOM_BOX_TYPE_STSD, GF_FALSE, 0);\n\tgf_bs_del(bs);\n\tif (e) return e;\n\n\twhile (gf_list_count(tpl_ent->child_boxes)) {\n\t\tu32 j=0;\n\t\tBool found = GF_FALSE;\n\t\tGF_Box *abox = gf_list_pop_front(tpl_ent->child_boxes);\n\n\t\tswitch (abox->type) {\n\t\tcase GF_ISOM_BOX_TYPE_SINF:\n\t\tcase GF_ISOM_BOX_TYPE_RINF:\n\t\tcase GF_ISOM_BOX_TYPE_BTRT:\n\t\t\tfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (found) {\n\t\t\tgf_isom_box_del(abox);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ent->child_boxes) ent->child_boxes = gf_list_new();\n\t\tfor (j=0; j<gf_list_count(ent->child_boxes); j++) {\n\t\t\tGF_Box *b = gf_list_get(ent->child_boxes, j);\n\t\t\tif (b->type == abox->type) {\n\t\t\t\tfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tgf_list_add(ent->child_boxes, abox);\n\t\t} else {\n\t\t\tgf_isom_box_del(abox);\n\t\t}\n\t}\n\tgf_isom_box_del(tpl_ent);\n\n\t//patch for old export\n\tGF_Box *abox = gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\tif (abox) {\n\t\tgf_list_del_item(ent->child_boxes, abox);\n\t\tgf_list_add(ent->child_boxes, abox);\n\t}\n\treturn GF_OK;\n}\n\n\n#include <gpac/xml.h>\nGF_EXPORT\nGF_Err gf_isom_apply_box_patch(GF_ISOFile *file, GF_ISOTrackID globalTrackID, const char *box_patch_filename, Bool for_fragments)\n{\n\tGF_Err e;\n\tGF_DOMParser *dom;\n\tu32 i;\n\tGF_XMLNode *root;\n\tu8 *box_data=NULL;\n\tu32 box_data_size;\n\tif (!file || !box_patch_filename) return GF_BAD_PARAM;\n#ifdef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (for_fragments) return GF_NOT_SUPPORTED;\n#endif\n\tdom = gf_xml_dom_new();\n\tif (strstr(box_patch_filename, \"<?xml\")) {\n\t\te = gf_xml_dom_parse_string(dom, (char *) box_patch_filename);\n\t} else {\n\t\te = gf_xml_dom_parse(dom, box_patch_filename, NULL, NULL);\n\t}\n\tif (e) goto err_exit;\n\n\troot = gf_xml_dom_get_root(dom);\n\tif (!root || strcmp(root->name, \"GPACBOXES\")) {\n\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\tgoto err_exit;\n\t}\n\n\t//compute size of each child boxes to freeze the order\n\tif (for_fragments) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tu32 count = file->moof ? gf_list_count(file->moof->child_boxes) : 0;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_Box *box = gf_list_get(file->moof->child_boxes, i);\n\t\t\tif (!(box->internal_flags & GF_ISOM_ORDER_FREEZE)) {\n\t\t\t\tgf_isom_box_size(box);\n\t\t\t\tgf_isom_box_freeze_order(box);\n\t\t\t}\n\t\t}\n#endif\n\t} else {\n\t\tfor (i=0; i<gf_list_count(file->TopBoxes); i++) {\n\t\t\tGF_Box *box = gf_list_get(file->TopBoxes, i);\n\t\t\tif (!(box->internal_flags & GF_ISOM_ORDER_FREEZE)) {\n\t\t\t\tgf_isom_box_size(box);\n\t\t\t\tgf_isom_box_freeze_order(box);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i=0; i<gf_list_count(root->content); i++) {\n\t\tu32 j;\n\t\tu32 path_len;\n\t\tBool essential_prop=GF_FALSE;\n\t\tu32 trackID=globalTrackID;\n\t\tu32 item_id=trackID;\n\t\tBool is_frag_box;\n\t\tchar *box_path=NULL;\n\t\tGF_Box *parent_box = NULL;\n\t\tGF_XMLNode *box_edit = gf_list_get(root->content, i);\n\t\tif (!box_edit->name || strcmp(box_edit->name, \"Box\")) continue;\n\n\t\tfor (j=0; j<gf_list_count(box_edit->attributes);j++) {\n\t\t\tGF_XMLAttribute *att = gf_list_get(box_edit->attributes, j);\n\t\t\tif (!strcmp(att->name, \"path\")) box_path = att->value;\n\t\t\telse if (!strcmp(att->name, \"essential\")) {\n\t\t\t\tif (!strcmp(att->value, \"yes\") || !strcmp(att->value, \"true\") || !strcmp(att->value, \"1\")) {\n\t\t\t\t\tessential_prop=GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!strcmp(att->name, \"itemID\"))\n\t\t\t\titem_id = atoi(att->value);\n\t\t\telse if (!globalTrackID && !strcmp(att->name, \"trackID\"))\n\t\t\t\ttrackID = atoi(att->value);\n\t\t}\n\n\t\tif (!box_path) continue;\n\t\tpath_len = (u32) strlen(box_path);\n\n\t\tis_frag_box = !strncmp(box_path, \"traf\", 4) ? GF_TRUE : GF_FALSE;\n\n\t\tif (for_fragments && !is_frag_box) continue;\n\t\telse if (!for_fragments && is_frag_box) continue;\n\n\t\tgf_xml_parse_bit_sequence(box_edit, box_patch_filename, &box_data, &box_data_size);\n\t\tif (box_data_size && (box_data_size<4) ) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Wrong BS specification for box, shall either be empty or at least 4 bytes for box type\\n\"));\n\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tgoto err_exit;\n\t\t}\n\n\t\twhile (box_path && (path_len>=4)) {\n\t\t\tu32 parent_list_box_type;\n\t\t\tGF_List **parent_list;\n\t\t\tu32 box_type = GF_4CC(box_path[0],box_path[1],box_path[2],box_path[3]);\n\t\t\tGF_Box *box=NULL;\n\t\t\tGF_BitStream *bs;\n\t\t\ts32 insert_pos = -1;\n\t\t\tbox_path+=4;\n\t\t\tpath_len-=4;\n\n\t\t\tif (!parent_box) {\n\t\t\t\tbox=gf_isom_box_find_child(file->TopBoxes, box_type);\n\t\t\t\tif (!box) {\n\t\t\t\t\tif (box_type==GF_ISOM_BOX_TYPE_TRAK) {\n\t\t\t\t\t\tif (trackID) {\n\t\t\t\t\t\t\tbox = (GF_Box *) gf_isom_get_track_from_file(file, gf_isom_get_track_by_id(file, trackID) );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!box && gf_list_count(file->moov->trackList)==1) {\n\t\t\t\t\t\t\tbox = gf_list_get(file->moov->trackList, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\t\telse if (box_type==GF_ISOM_BOX_TYPE_TRAF) {\n\t\t\t\t\t\tif (trackID) {\n\t\t\t\t\t\t\tbox = (GF_Box *) gf_isom_get_traf(file, trackID);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!box && file->moof && gf_list_count(file->moof->TrackList)==1) {\n\t\t\t\t\t\t\tbox = gf_list_get(file->moof->TrackList, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\t\t\t\tif (!box) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Cannot locate box type %s at root or as track\\n\", gf_4cc_to_str(box_type) ));\n\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbox = gf_isom_box_find_child(parent_box->child_boxes, box_type);\n\t\t\t\tif (!box) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Cannot locate box type %s at child of %s\\n\", gf_4cc_to_str(box_type), gf_4cc_to_str(parent_box->type)));\n\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// '.' is child access\n\t\t\tif (path_len && (box_path[0]=='.')) {\n\t\t\t\tbox_path += 1;\n\t\t\t\tpath_len-=1;\n\t\t\t\tparent_box = box;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (parent_box && !parent_box->child_boxes) parent_box->child_boxes = gf_list_new();\n\t\t\tparent_list = parent_box ? &parent_box->child_boxes : &file->TopBoxes;\n\t\t\tparent_list_box_type = parent_box ? parent_box->type : 0;\n\n\t\t\t// '+' is append after, '-' is insert before\n\t\t\tif (path_len && ((box_path[0]=='-') || (box_path[0]=='+')) ) {\n\t\t\t\ts32 idx = gf_list_find(*parent_list, box);\n\t\t\t\tassert(idx>=0);\n\t\t\t\tif (box_path[0]=='+') insert_pos = idx+1;\n\t\t\t\telse insert_pos = idx;\n\t\t\t}\n\t\t\telse if (path_len) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Invalid path %s, expecting either '-', '+' or '.' as separators\\n\", box_path));\n\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\n\t\t\tif (!box_data) {\n\t\t\t\tif (insert_pos>=0) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[ISOBMFF] Invalid path %s for box removal, ignoring position\\n\", box_path));\n\t\t\t\t}\n\t\t\t\tswitch (box->type) {\n\t\t\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\t\t\t\tfile->moov = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\t\t\t\tfile->mdat = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n\t\t\t\t\tfile->pdin = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\t\t\t\tfile->brand = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\t\t\tif ((GF_Box *) file->meta == box) file->meta = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (parent_box) {\n\t\t\t\t\tgf_isom_box_remove_from_parent(parent_box, box);\n\t\t\t\t}\n\t\t\t\tgf_isom_box_del_parent(parent_list, box);\n\t\t\t} else {\n\t\t\t\tu32 size;\n\n\t\t\t\tbs = gf_bs_new(box_data, box_data_size, GF_BITSTREAM_READ);\n\t\t\t\tsize = gf_bs_read_u32(bs);\n\t\t\t\tif (size != box_data_size) {\n\t\t\t\t\tGF_UnknownBox *new_box = (GF_UnknownBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_UNKNOWN);\n\t\t\t\t\tnew_box->original_4cc = size;\n\t\t\t\t\tnew_box->dataSize = (u32) gf_bs_available(bs);\n\t\t\t\t\tnew_box->data = gf_malloc(sizeof(u8)*new_box->dataSize);\n\t\t\t\t\tgf_bs_read_data(bs, new_box->data, new_box->dataSize);\n\t\t\t\t\tif (insert_pos<0) {\n\t\t\t\t\t\tgf_list_add(box->child_boxes, new_box);\n\t\t\t\t\t\tinsert_pos = gf_list_find(box->child_boxes, new_box);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_list_insert(*parent_list, new_box, insert_pos);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (parent_box && (parent_box->type==GF_ISOM_BOX_TYPE_IPRP)) {\n\t\t\t\t\t\tGF_ItemPropertyAssociationBox *ipma = (GF_ItemPropertyAssociationBox *) gf_isom_box_find_child(parent_box->child_boxes, GF_ISOM_BOX_TYPE_IPMA);\n\t\t\t\t\t\tif (!item_id) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[ISOBMFF] Inserting box in ipco without itemID, no association added\\n\"));\n\t\t\t\t\t\t} else if (ipma) {\n\t\t\t\t\t\t\tu32 nb_asso, k;\n\t\t\t\t\t\t\tGF_ItemPropertyAssociationEntry *entry = NULL;\n\t\t\t\t\t\t\tnb_asso = gf_list_count(ipma->entries);\n\t\t\t\t\t\t\tfor (k=0; k<nb_asso;k++) {\n\t\t\t\t\t\t\t\tentry = gf_list_get(ipma->entries, k);\n\t\t\t\t\t\t\t\tif (entry->item_id==item_id) break;\n\t\t\t\t\t\t\t\tentry = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!entry) {\n\t\t\t\t\t\t\t\tGF_SAFEALLOC(entry, GF_ItemPropertyAssociationEntry);\n\t\t\t\t\t\t\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\t\t\t\t\t\t\tgf_list_add(ipma->entries, entry);\n\t\t\t\t\t\t\t\tentry->item_id = item_id;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tentry->associations = gf_realloc(entry->associations, sizeof(GF_ItemPropertyAssociationSlot) * (entry->nb_associations+1));\n\t\t\t\t\t\t\tentry->associations[entry->nb_associations].essential = essential_prop;\n\t\t\t\t\t\t\tentry->associations[entry->nb_associations].index = 1+insert_pos;\n\t\t\t\t\t\t\tentry->nb_associations++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tu32 box_idx = 0;\n\n\t\t\t\t\tgf_bs_seek(bs, 0);\n\t\t\t\t\twhile (gf_bs_available(bs)) {\n\t\t\t\t\t\tGF_Box *new_box;\n\t\t\t\t\t\te = gf_isom_box_parse_ex(&new_box, bs, (insert_pos<0) ? box->type : parent_list_box_type, parent_box ? GF_FALSE : GF_TRUE, 0);\n\t\t\t\t\t\tif (e) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] failed to parse box\\n\", box_path));\n\t\t\t\t\t\t\tgf_bs_del(bs);\n\t\t\t\t\t\t\tgoto err_exit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (insert_pos<0) {\n\t\t\t\t\t\t\tgf_list_add(box->child_boxes, new_box);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_list_insert(*parent_list, new_box, insert_pos+box_idx);\n\t\t\t\t\t\t\tbox_idx++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_bs_del(bs);\n\n\t\t\t}\n\t\t\tgf_free(box_data);\n\t\t\tbox_data = NULL;\n\t\t\tbox_path = NULL;\n\t\t}\n\t}\n\nerr_exit:\n\n\tgf_xml_dom_del(dom);\n\tif (box_data) gf_free(box_data);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_magic(GF_ISOFile *movie, u32 trackNumber, u64 magic)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\ttrak->magic = magic;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_index(GF_ISOFile *movie, u32 trackNumber, u32 index, void (*track_num_changed)(void *udta, u32 old_track_num, u32 new_track_num), void *udta)\n{\n\tu32 i, j, count;\n\tGF_List *tracks;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !index) return GF_BAD_PARAM;\n\ttrak->index = index;\n\ttracks = gf_list_new();\n\tcount = gf_list_count(movie->moov->trackList);\n\t//sort tracks in new list\n\tfor (i=0; i<count; i++) {\n\t\tGF_TrackBox *a_tk = gf_list_get(movie->moov->trackList, i);\n\t\tif (!a_tk->index) {\n\t\t\tgf_list_insert(tracks, a_tk, 0);\n\t\t} else {\n\t\t\tfor (j=0; j<gf_list_count(tracks); j++) {\n\t\t\t\tGF_TrackBox *a_tki = gf_list_get(tracks, j);\n\t\t\t\tif (a_tki->index<a_tk->index) continue;\n\t\t\t\tgf_list_insert(tracks, a_tk, j);\n\t\t\t\ta_tk = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (a_tk)\n\t\t\t\tgf_list_add(tracks, a_tk);\n\t\t}\n\t}\n\tif (gf_list_count(tracks) != count) {\n\t\tgf_list_del(tracks);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tif (track_num_changed) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_TrackBox *a_tk = gf_list_get(tracks, i);\n\t\t\ts32 old_pos = gf_list_find(movie->moov->trackList, a_tk);\n\t\t\tassert(old_pos>=0);\n\t\t\tif (old_pos != i)\n\t\t\t\ttrack_num_changed(udta, old_pos+1, i+1);\n\t\t}\n\t}\n\tgf_list_del(movie->moov->trackList);\n\tmovie->moov->trackList = tracks;\n\tfor (j=0; j<gf_list_count(tracks); j++) {\n\t\tGF_TrackBox *tki = gf_list_get(tracks, j);\n\t\tif (tki->index != 0xFFFE) // special value meaning always last\n\t\t\ttki->index = j + 1;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_ipod_compatible(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\tif (!entry) return GF_OK;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_OK;\n\t}\n\n\tif (!entry->ipod_ext) {\n\t\tentry->ipod_ext = (GF_UnknownUUIDBox *) gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_UUID);\n\t\tif (!entry->ipod_ext) return GF_OUT_OF_MEM;\n\t}\n\tmemcpy(entry->ipod_ext->uuid, GF_ISOM_IPOD_EXT, sizeof(u8)*16);\n\tentry->ipod_ext->dataSize = 4;\n\tentry->ipod_ext->data = gf_malloc(sizeof(u8)*4);\n\tif (!entry->ipod_ext->data) return GF_OUT_OF_MEM;\n\tmemset(entry->ipod_ext->data, 0, sizeof(u8)*4);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nBool gf_isom_is_inplace_rewrite(GF_ISOFile *movie)\n{\n\tif (!movie) return GF_FALSE;\n\tif (!movie->no_inplace_rewrite) {\n\t\t//things where added to the file, no inplace rewrite\n\t\tif (movie->editFileMap && gf_bs_get_size(movie->editFileMap->bs))\n\t\t\tmovie->no_inplace_rewrite = GF_TRUE;\n\t\t//block redirect (used by mp4mx), no inplace rewrite\n\t\telse if (movie->on_block_out || !strcmp(movie->finalName, \"_gpac_isobmff_redirect\"))\n\t\t\tmovie->no_inplace_rewrite = GF_TRUE;\n\t\t//stdout redirect, no inplace rewrite\n\t\telse if (!strcmp(movie->finalName, \"std\"))\n\t\t\tmovie->no_inplace_rewrite = GF_TRUE;\n\t\t//new file, no inplace rewrite\n\t\telse if (!movie->fileName)\n\t\t\tmovie->no_inplace_rewrite = GF_TRUE;\n\t}\n\tif (movie->no_inplace_rewrite) return GF_FALSE;\n\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nvoid gf_isom_disable_inplace_rewrite(GF_ISOFile *movie)\n{\n\tif (movie)\n\t\tmovie->no_inplace_rewrite = GF_TRUE;\n}\n\n\nGF_Err gf_isom_set_y3d_info(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescriptionIndex, GF_ISOM_Y3D_Info *info)\n{\n\tGF_Err e;\n\tu32 proj_type;\n\tGF_SampleEntryBox *ent;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !info) return GF_BAD_PARAM;\n\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex-1);\n\tif (!ent) return GF_BAD_PARAM;\n\n\tif (info->projection_type > GF_PROJ360_EQR) return GF_NOT_SUPPORTED;\n\n\tGF_Stereo3DBox *st3d = (GF_Stereo3DBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\tif (st3d) {\n\t\tif (info->stereo_type) {\n\t\t\tst3d->stereo_type = info->stereo_type;\n\t\t} else {\n\t\t\tgf_isom_box_del_parent(&ent->child_boxes, (GF_Box *) st3d);\n\t\t}\n\t} else if (info->stereo_type) {\n\t\tst3d = (GF_Stereo3DBox *) gf_isom_box_new_parent(&ent->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\t\tif (!st3d) return GF_OUT_OF_MEM;\n\t\tst3d->stereo_type = info->stereo_type;\n\t}\n\n\n\tGF_Box *sv3d = gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\tif (sv3d && !info->projection_type) {\n\t\tgf_isom_box_del_parent(&ent->child_boxes, sv3d);\n\t\treturn GF_OK;\n\t}\n\n\tif (!sv3d && !info->projection_type) {\n\t\treturn GF_OK;\n\t}\n\tif (!sv3d) {\n\t\tsv3d = gf_isom_box_new_parent(&ent->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\t\tif (!sv3d) return GF_OUT_OF_MEM;\n\t}\n\n\t//svhd mandatory\n\tGF_SphericalVideoInfoBox *svhd = (GF_SphericalVideoInfoBox *) gf_isom_box_find_child(sv3d->child_boxes, GF_ISOM_BOX_TYPE_SVHD);\n\tif (svhd) {\n\t\tif (svhd->string) gf_free(svhd->string);\n\t} else {\n\t\tsvhd = (GF_SphericalVideoInfoBox *) gf_isom_box_new_parent(&sv3d->child_boxes, GF_ISOM_BOX_TYPE_SVHD);\n\t\tif (!svhd) return GF_OUT_OF_MEM;\n\t}\n\tsvhd->string = gf_strdup(info->meta_data ? info->meta_data : \"\");\n\n\t//proj mandatory\n\tGF_Box *proj = gf_isom_box_find_child(sv3d->child_boxes, GF_ISOM_BOX_TYPE_PROJ);\n\tif (!proj) {\n\t\tproj = gf_isom_box_new_parent(&sv3d->child_boxes, GF_ISOM_BOX_TYPE_PROJ);\n\t\tif (!proj) return GF_OUT_OF_MEM;\n\t}\n\n\tGF_ProjectionHeaderBox *projh = (GF_ProjectionHeaderBox *) gf_isom_box_find_child(proj->child_boxes, GF_ISOM_BOX_TYPE_PRHD);\n\t//prj header mandatory\n\tif (!projh) {\n\t\tprojh = (GF_ProjectionHeaderBox *) gf_isom_box_new_parent(&proj->child_boxes, GF_ISOM_BOX_TYPE_PRHD);\n\t\tif (!projh) return GF_OUT_OF_MEM;\n\t}\n\tprojh->yaw = info->yaw;\n\tprojh->pitch = info->pitch;\n\tprojh->roll = info->roll;\n\n\tproj_type = (info->projection_type==GF_PROJ360_CUBE_MAP) ? GF_ISOM_BOX_TYPE_CBMP : GF_ISOM_BOX_TYPE_EQUI;\n\n\tGF_ProjectionTypeBox *projt = (GF_ProjectionTypeBox *) gf_isom_box_find_child(proj->child_boxes, proj_type);\n\tif (!projt) {\n\t\tprojt = (GF_ProjectionTypeBox *) gf_isom_box_new_parent(&proj->child_boxes, proj_type);\n\t\tif (!projt) return GF_OUT_OF_MEM;\n\t}\n\tif (info->projection_type==GF_PROJ360_CUBE_MAP) {\n\t\tprojt->layout = info->layout;\n\t\tprojt->padding = info->padding;\n\t} else {\n\t\tprojt->bounds_top = info->top;\n\t\tprojt->bounds_bottom = info->bottom;\n\t\tprojt->bounds_left = info->left;\n\t\tprojt->bounds_right = info->right;\n\t}\n\n\t//remove other ones\n\tGF_Box *b = gf_isom_box_new_parent(&proj->child_boxes, GF_ISOM_BOX_TYPE_MSHP);\n\tif (b) gf_isom_box_del_parent(&proj->child_boxes, b);\n\tif (info->projection_type==GF_PROJ360_CUBE_MAP) {\n\t\tb = gf_isom_box_new_parent(&proj->child_boxes, GF_ISOM_BOX_TYPE_EQUI);\n\t\tif (b) gf_isom_box_del_parent(&proj->child_boxes, b);\n\t} else {\n\t\tb = gf_isom_box_new_parent(&proj->child_boxes, GF_ISOM_BOX_TYPE_EQUI);\n\t\tif (b) gf_isom_box_del_parent(&proj->child_boxes, b);\n\n\t}\n\treturn GF_OK;\n}\n\n#endif //!defined(GPAC_DISABLE_ISOM_WRITE)\n\n#ifndef GPAC_DISABLE_ISOM\n\nGF_Err gf_isom_add_sample_aux_info_internal(GF_TrackBox *trak, void *_traf, u32 sampleNumber, u32 aux_type, u32 aux_info, u8 *data, u32 size)\n{\n\tu32 i, count;\n\tGF_List **child_box_cont, **child_box_sai, **child_box_saiz, **child_box_saio;\n\tGF_UnknownBox *sai_cont = NULL;\n\n\tif (!trak && !_traf) return GF_BAD_PARAM;\n\n\tif (trak) {\n\t\tchild_box_cont = &trak->child_boxes;\n\t\tchild_box_sai = &trak->Media->information->sampleTable->child_boxes;\n\t\tchild_box_saiz = &trak->Media->information->sampleTable->sai_sizes;\n\t\tchild_box_saio = &trak->Media->information->sampleTable->sai_offsets;\n\t} else {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tGF_TrackFragmentBox *traf = (GF_TrackFragmentBox *)_traf;\n\n\t\tchild_box_cont = &traf->child_boxes;\n\t\tchild_box_sai = &traf->child_boxes;\n\t\tchild_box_saiz = &traf->sai_sizes;\n\t\tchild_box_saio = &traf->sai_offsets;\n#endif\n\t}\n\n\tcount = gf_list_count(*child_box_cont);\n\tfor (i=0; i<count; i++) {\n\t\tGF_UnknownBox *unkn = gf_list_get(*child_box_cont, i);\n\t\tif (unkn->type != GF_ISOM_BOX_TYPE_UNKNOWN) continue;\n\t\tif (unkn->original_4cc != GF_ISOM_BOX_TYPE_GDAT) continue;\n\t\tif (unkn->sai_type != aux_type) continue;\n\t\tif (unkn->sai_aux_info != aux_info) continue;\n\t\tsai_cont = unkn;\n\t\tbreak;\n\t}\n\tif (!sai_cont) {\n\t\tsai_cont = (GF_UnknownBox *) gf_isom_box_new_parent(child_box_cont, GF_ISOM_BOX_TYPE_UNKNOWN);\n\t\tif (!sai_cont) return GF_OUT_OF_MEM;\n\t\tsai_cont->original_4cc = GF_ISOM_BOX_TYPE_GDAT;\n\t\tsai_cont->sai_type = aux_type;\n\t\tsai_cont->sai_aux_info = aux_info;\n\t}\n\tsai_cont->data = gf_realloc(sai_cont->data, (size+sai_cont->dataSize));\n\tif (!sai_cont->data) return GF_OUT_OF_MEM;\n\tmemcpy(sai_cont->data+sai_cont->dataSize, data, size);\n\tsai_cont->dataSize += size;\n\n\tGF_SampleAuxiliaryInfoSizeBox *saiz=NULL;\n\tGF_SampleAuxiliaryInfoOffsetBox *saio=NULL;\n\tcount = gf_list_count(*child_box_saiz);\n\tfor (i=0; i<count; i++) {\n\t\tsaiz = gf_list_get(*child_box_saiz, i);\n\t\tif ((saiz->aux_info_type==aux_type) && (saiz->aux_info_type_parameter==aux_info)) break;\n\t\tsaiz = NULL;\n\t}\n\tif (!saiz) {\n\t\tsaiz = (GF_SampleAuxiliaryInfoSizeBox *) gf_isom_box_new_parent(child_box_sai, GF_ISOM_BOX_TYPE_SAIZ);\n\t\tif (!saiz) return GF_OUT_OF_MEM;\n\t\tif (! *child_box_saiz) *child_box_saiz = gf_list_new();\n\t\tgf_list_add(*child_box_saiz, saiz);\n\n\t\tsaiz->aux_info_type = aux_type;\n\t\tsaiz->aux_info_type_parameter = aux_info;\n\t}\n\n\tif (saiz->sample_count >= sampleNumber)\n\t\treturn GF_BAD_PARAM;\n\n\tif ( (!saiz->sample_count && (sampleNumber==1))\n\t\t|| ((saiz->default_sample_info_size==size) && size)\n\t) {\n\t\tsaiz->sample_count ++;\n\t\tsaiz->default_sample_info_size = size;\n\t} else {\n\t\tif (sampleNumber > saiz->sample_alloc) {\n\t\t\tsaiz->sample_alloc = sampleNumber+10;\n\t\t\tsaiz->sample_info_size = (u8*)gf_realloc(saiz->sample_info_size, sizeof(u8)*(saiz->sample_alloc));\n\t\t}\n\n\t\tif (saiz->default_sample_info_size) {\n\t\t\tfor (i=0; i<saiz->sample_count; i++)\n\t\t\t\tsaiz->sample_info_size[i] = saiz->default_sample_info_size;\n\t\t\tsaiz->default_sample_info_size = 0;\n\t\t}\n\t\tfor (i=saiz->sample_count; i<sampleNumber-1; i++)\n\t\t\tsaiz->sample_info_size[i] = 0;\n\n\t\tsaiz->sample_info_size[sampleNumber-1] = size;\n\t\tsaiz->sample_count = sampleNumber;\n\t}\n\n\n\tcount = gf_list_count(*child_box_saio);\n\tfor (i=0; i<count; i++) {\n\t\tsaio = gf_list_get(*child_box_saio, i);\n\t\tif ((saio->aux_info_type==aux_type) && (saio->aux_info_type_parameter==aux_info)) break;\n\t\tsaio = NULL;\n\t}\n\tif (!saio) {\n\t\tsaio = (GF_SampleAuxiliaryInfoOffsetBox *) gf_isom_box_new_parent(child_box_sai, GF_ISOM_BOX_TYPE_SAIO);\n\t\tif (!saio) return GF_OUT_OF_MEM;\n\t\tif (! *child_box_saio) *child_box_saio = gf_list_new();\n\t\tgf_list_add(*child_box_saio, saio);\n\t\tsaio->aux_info_type = aux_type;\n\t\tsaio->aux_info_type_parameter = aux_info;\n\t}\n\tif (!saio->sai_data) saio->sai_data = sai_cont;\n\tsaio->version = 1;\n\tsaio->entry_count = 1;\n\n\treturn GF_OK;\n}\n#endif // GPAC_DISABLE_ISOM\n\n\n#if !defined(GPAC_DISABLE_ISOM_WRITE)\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nGF_Err gf_isom_fragment_set_sample_aux_info(GF_ISOFile *movie, u32 trackID, u32 sample_number_in_frag, u32 aux_type, u32 aux_info, u8 *data, u32 size)\n{\n\tGF_TrackFragmentBox *traf;\n\tif (!movie || !movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) return GF_BAD_PARAM;\n\n\ttraf = gf_isom_get_traf(movie, trackID);\n\tif (!traf) return GF_BAD_PARAM;\n\treturn gf_isom_add_sample_aux_info_internal(NULL, traf, sample_number_in_frag, aux_type, aux_info, data, size);\n}\n#endif\n\nGF_Err gf_isom_add_sample_aux_info(GF_ISOFile *file, u32 track, u32 sampleNumber, u32 aux_type, u32 aux_info, u8 *data, u32 size)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\treturn gf_isom_add_sample_aux_info_internal(trak, NULL, sampleNumber, aux_type, aux_info, data, size);\n}\n\n\nGF_Err gf_isom_set_meta_qt(GF_ISOFile *file)\n{\n\tu32 i, count;\n\tif (!file) return GF_BAD_PARAM;\n\tGF_Err e = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\tif (file->moov->meta)\n\t\tfile->moov->meta->write_qt = 1;\n\n\tcount = gf_list_count(file->moov->trackList);\n\tfor (i=0; i<count; i++) {\n\t\tGF_TrackBox *trak = gf_list_get(file->moov->trackList, i);\n\t\tif (trak->meta)\n\t\t\ttrak->meta->write_qt = 1;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_mpegh_compatible_profiles(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescIndex, const u32 *profiles, u32 nb_compat_profiles)\n{\n\tu32 i, type;\n\tGF_SampleEntryBox *ent;\n\tGF_MHACompatibleProfilesBox *mhap;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescIndex-1);\n\tif (!ent) return GF_BAD_PARAM;\n\ttype = ent->type;\n\tif (type==GF_ISOM_BOX_TYPE_GNRA)\n\t\ttype = ((GF_GenericAudioSampleEntryBox *)ent)->EntryType;\n\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_MHA1:\n\tcase GF_ISOM_BOX_TYPE_MHA2:\n\tcase GF_ISOM_BOX_TYPE_MHM1:\n\tcase GF_ISOM_BOX_TYPE_MHM2:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\tmhap = (GF_MHACompatibleProfilesBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_MHAP);\n\tif (!mhap) {\n\t\tif (! profiles || !nb_compat_profiles) return GF_OK;\n\t\tmhap = (GF_MHACompatibleProfilesBox *) gf_isom_box_new_parent(&ent->child_boxes, GF_ISOM_BOX_TYPE_MHAP);\n\t} else if (! profiles || !nb_compat_profiles) {\n\t\tgf_isom_box_del_parent(&ent->child_boxes, (GF_Box*)mhap);\n\t\treturn GF_OK;\n\t}\n\tif (mhap->compat_profiles) gf_free(mhap->compat_profiles);\n\tmhap->compat_profiles = gf_malloc(sizeof(u8) * nb_compat_profiles);\n\tif (!mhap->compat_profiles) return GF_OUT_OF_MEM;\n\tfor (i=0; i<nb_compat_profiles; i++) {\n\t\tmhap->compat_profiles[i] = (u8) profiles[i];\n\t}\n\tmhap->num_profiles = nb_compat_profiles;\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_set_sample_description_restricted(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescIndex, u32 scheme_type)\n{\n\tu32 type;\n\tGF_SampleEntryBox *ent;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescIndex-1);\n\tif (!ent) return GF_BAD_PARAM;\n\ttype = ent->type;\n\n\tu32 original_format = type;\n\tu32 gnr_type=0;\n\tif (original_format==GF_ISOM_BOX_TYPE_GNRA) {\n\t\tgnr_type = original_format;\n\t\ttype = ((GF_GenericAudioSampleEntryBox*)ent)->EntryType;\n\t} else if (original_format==GF_ISOM_BOX_TYPE_GNRV) {\n\t\tgnr_type = original_format;\n\t\ttype = ((GF_GenericVisualSampleEntryBox*)ent)->EntryType;\n\t} else if (original_format==GF_ISOM_BOX_TYPE_GNRM) {\n\t\tgnr_type = original_format;\n\t\ttype = ((GF_GenericSampleEntryBox*)ent)->EntryType;\n\t}\n\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_RESV:\n\tcase GF_ISOM_BOX_TYPE_RESA:\n\tcase GF_ISOM_BOX_TYPE_RESM:\n\tcase GF_ISOM_BOX_TYPE_REST:\n\tcase GF_ISOM_BOX_TYPE_RESU:\n\tcase GF_ISOM_BOX_TYPE_RESS:\n\tcase GF_ISOM_BOX_TYPE_RESF:\n\tcase GF_ISOM_BOX_TYPE_RESP:\n\tcase GF_ISOM_BOX_TYPE_RES3:\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_STXT:\n\t\ttype = GF_ISOM_BOX_TYPE_REST;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STPP:\n\t\ttype = GF_ISOM_BOX_TYPE_RESU;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_METX:\n\tcase GF_ISOM_BOX_TYPE_METT:\n\tcase GF_ISOM_BOX_TYPE_URIM:\n\tcase GF_ISOM_BOX_TYPE_MEBX:\n\t\ttype = GF_ISOM_BOX_TYPE_RESM;\n\t\tbreak;\n\tdefault:\n\t\ttype=0;\n\t\tswitch (trak->Media->handler->handlerType) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t\ttype = GF_ISOM_BOX_TYPE_RESV;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\ttype = GF_ISOM_BOX_TYPE_RESA;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\tcase GF_ISOM_MEDIA_OCR:\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\tcase GF_ISOM_MEDIA_MPEG7:\n\t\tcase GF_ISOM_MEDIA_OCI:\n\t\tcase GF_ISOM_MEDIA_IPMP:\n\t\tcase GF_ISOM_MEDIA_MPEGJ:\n\t\t\ttype = GF_ISOM_BOX_TYPE_RESS;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tif (!type) return GF_NOT_SUPPORTED;\n\n\tGF_ProtectionSchemeInfoBox *rinf;\n\trinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_RINF);\n\tif (rinf) gf_isom_box_del_parent(&ent->child_boxes, (GF_Box *)rinf);\n\n\trinf = (GF_ProtectionSchemeInfoBox *)gf_isom_box_new_parent(&ent->child_boxes, GF_ISOM_BOX_TYPE_RINF);\n\tif (!rinf) return GF_OUT_OF_MEM;\n\n\n\trinf->original_format = (GF_OriginalFormatBox *)gf_isom_box_new_parent(&rinf->child_boxes, GF_ISOM_BOX_TYPE_FRMA);\n\tif (!rinf->original_format) return GF_OUT_OF_MEM;\n\tif (gnr_type) {\n\t\trinf->original_format->data_format = gnr_type;\n\t\trinf->original_format->gnr_type = original_format;\n\t} else {\n\t\trinf->original_format->data_format = original_format;\n\t}\n\t//common to isma, cenc and oma\n\trinf->scheme_type = (GF_SchemeTypeBox *)gf_isom_box_new_parent(&rinf->child_boxes, GF_ISOM_BOX_TYPE_SCHM);\n\tif (!rinf->scheme_type) return GF_OUT_OF_MEM;\n\trinf->scheme_type->scheme_type  = scheme_type;\n\n\tent->type = type;\n\treturn GF_OK;\n}\n\n\n#endif\t/*!defined(GPAC_DISABLE_ISOM) && !defined(GPAC_DISABLE_ISOM_WRITE)*/\n"], "filenames": ["src/isomedia/isom_write.c"], "buggy_code_start_loc": [362], "buggy_code_end_loc": [9171], "fixing_code_start_loc": [362], "fixing_code_end_loc": [9169], "type": "CWE-787", "message": "GPAC 2.3-DEV-rev605-gfc9e29089-master contains a heap-buffer-overflow in gf_isom_use_compact_size gpac/src/isomedia/isom_write.c:3403:3 in gpac/MP4Box.", "other": {"cve": {"id": "CVE-2023-46927", "sourceIdentifier": "cve@mitre.org", "published": "2023-11-01T15:15:08.707", "lastModified": "2023-11-08T19:35:56.783", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "GPAC 2.3-DEV-rev605-gfc9e29089-master contains a heap-buffer-overflow in gf_isom_use_compact_size gpac/src/isomedia/isom_write.c:3403:3 in gpac/MP4Box."}, {"lang": "es", "value": "GPAC 2.3-DEV-rev605-gfc9e29089-master contiene un desbordamiento de b\u00fafer de mont\u00f3n en gf_isom_use_compact_size gpac/src/isomedia/isom_write.c:3403:3 en gpac/MP4Box. "}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:2.3-dev-rev605-gfc9e29089-master:*:*:*:*:*:*:*", "matchCriteriaId": "276701A5-2ABB-4EDB-9E2A-96A6A9EA62D9"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/a7b467b151d9b54badbc4dd71e7a366b7c391817", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/2657", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/a7b467b151d9b54badbc4dd71e7a366b7c391817"}}