{"buggy_code": ["/*\n *      FarSync WAN driver for Linux (2.6.x kernel version)\n *\n *      Actually sync driver for X.21, V.35 and V.24 on FarSync T-series cards\n *\n *      Copyright (C) 2001-2004 FarSite Communications Ltd.\n *      www.farsite.co.uk\n *\n *      This program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n *\n *      Author:      R.J.Dunlop    <bob.dunlop@farsite.co.uk>\n *      Maintainer:  Kevin Curtis  <kevin.curtis@farsite.co.uk>\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/pci.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/if.h>\n#include <linux/hdlc.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n\n#include \"farsync.h\"\n\n/*\n *      Module info\n */\nMODULE_AUTHOR(\"R.J.Dunlop <bob.dunlop@farsite.co.uk>\");\nMODULE_DESCRIPTION(\"FarSync T-Series WAN driver. FarSite Communications Ltd.\");\nMODULE_LICENSE(\"GPL\");\n\n/*      Driver configuration and global parameters\n *      ==========================================\n */\n\n/*      Number of ports (per card) and cards supported\n */\n#define FST_MAX_PORTS           4\n#define FST_MAX_CARDS           32\n\n/*      Default parameters for the link\n */\n#define FST_TX_QUEUE_LEN        100\t/* At 8Mbps a longer queue length is\n\t\t\t\t\t * useful */\n#define FST_TXQ_DEPTH           16\t/* This one is for the buffering\n\t\t\t\t\t * of frames on the way down to the card\n\t\t\t\t\t * so that we can keep the card busy\n\t\t\t\t\t * and maximise throughput\n\t\t\t\t\t */\n#define FST_HIGH_WATER_MARK     12\t/* Point at which we flow control\n\t\t\t\t\t * network layer */\n#define FST_LOW_WATER_MARK      8\t/* Point at which we remove flow\n\t\t\t\t\t * control from network layer */\n#define FST_MAX_MTU             8000\t/* Huge but possible */\n#define FST_DEF_MTU             1500\t/* Common sane value */\n\n#define FST_TX_TIMEOUT          (2*HZ)\n\n#ifdef ARPHRD_RAWHDLC\n#define ARPHRD_MYTYPE   ARPHRD_RAWHDLC\t/* Raw frames */\n#else\n#define ARPHRD_MYTYPE   ARPHRD_HDLC\t/* Cisco-HDLC (keepalives etc) */\n#endif\n\n/*\n * Modules parameters and associated variables\n */\nstatic int fst_txq_low = FST_LOW_WATER_MARK;\nstatic int fst_txq_high = FST_HIGH_WATER_MARK;\nstatic int fst_max_reads = 7;\nstatic int fst_excluded_cards = 0;\nstatic int fst_excluded_list[FST_MAX_CARDS];\n\nmodule_param(fst_txq_low, int, 0);\nmodule_param(fst_txq_high, int, 0);\nmodule_param(fst_max_reads, int, 0);\nmodule_param(fst_excluded_cards, int, 0);\nmodule_param_array(fst_excluded_list, int, NULL, 0);\n\n/*      Card shared memory layout\n *      =========================\n */\n#pragma pack(1)\n\n/*      This information is derived in part from the FarSite FarSync Smc.h\n *      file. Unfortunately various name clashes and the non-portability of the\n *      bit field declarations in that file have meant that I have chosen to\n *      recreate the information here.\n *\n *      The SMC (Shared Memory Configuration) has a version number that is\n *      incremented every time there is a significant change. This number can\n *      be used to check that we have not got out of step with the firmware\n *      contained in the .CDE files.\n */\n#define SMC_VERSION 24\n\n#define FST_MEMSIZE 0x100000\t/* Size of card memory (1Mb) */\n\n#define SMC_BASE 0x00002000L\t/* Base offset of the shared memory window main\n\t\t\t\t * configuration structure */\n#define BFM_BASE 0x00010000L\t/* Base offset of the shared memory window DMA\n\t\t\t\t * buffers */\n\n#define LEN_TX_BUFFER 8192\t/* Size of packet buffers */\n#define LEN_RX_BUFFER 8192\n\n#define LEN_SMALL_TX_BUFFER 256\t/* Size of obsolete buffs used for DOS diags */\n#define LEN_SMALL_RX_BUFFER 256\n\n#define NUM_TX_BUFFER 2\t\t/* Must be power of 2. Fixed by firmware */\n#define NUM_RX_BUFFER 8\n\n/* Interrupt retry time in milliseconds */\n#define INT_RETRY_TIME 2\n\n/*      The Am186CH/CC processors support a SmartDMA mode using circular pools\n *      of buffer descriptors. The structure is almost identical to that used\n *      in the LANCE Ethernet controllers. Details available as PDF from the\n *      AMD web site: http://www.amd.com/products/epd/processors/\\\n *                    2.16bitcont/3.am186cxfa/a21914/21914.pdf\n */\nstruct txdesc {\t\t\t/* Transmit descriptor */\n\tvolatile u16 ladr;\t/* Low order address of packet. This is a\n\t\t\t\t * linear address in the Am186 memory space\n\t\t\t\t */\n\tvolatile u8 hadr;\t/* High order address. Low 4 bits only, high 4\n\t\t\t\t * bits must be zero\n\t\t\t\t */\n\tvolatile u8 bits;\t/* Status and config */\n\tvolatile u16 bcnt;\t/* 2s complement of packet size in low 15 bits.\n\t\t\t\t * Transmit terminal count interrupt enable in\n\t\t\t\t * top bit.\n\t\t\t\t */\n\tu16 unused;\t\t/* Not used in Tx */\n};\n\nstruct rxdesc {\t\t\t/* Receive descriptor */\n\tvolatile u16 ladr;\t/* Low order address of packet */\n\tvolatile u8 hadr;\t/* High order address */\n\tvolatile u8 bits;\t/* Status and config */\n\tvolatile u16 bcnt;\t/* 2s complement of buffer size in low 15 bits.\n\t\t\t\t * Receive terminal count interrupt enable in\n\t\t\t\t * top bit.\n\t\t\t\t */\n\tvolatile u16 mcnt;\t/* Message byte count (15 bits) */\n};\n\n/* Convert a length into the 15 bit 2's complement */\n/* #define cnv_bcnt(len)   (( ~(len) + 1 ) & 0x7FFF ) */\n/* Since we need to set the high bit to enable the completion interrupt this\n * can be made a lot simpler\n */\n#define cnv_bcnt(len)   (-(len))\n\n/* Status and config bits for the above */\n#define DMA_OWN         0x80\t/* SmartDMA owns the descriptor */\n#define TX_STP          0x02\t/* Tx: start of packet */\n#define TX_ENP          0x01\t/* Tx: end of packet */\n#define RX_ERR          0x40\t/* Rx: error (OR of next 4 bits) */\n#define RX_FRAM         0x20\t/* Rx: framing error */\n#define RX_OFLO         0x10\t/* Rx: overflow error */\n#define RX_CRC          0x08\t/* Rx: CRC error */\n#define RX_HBUF         0x04\t/* Rx: buffer error */\n#define RX_STP          0x02\t/* Rx: start of packet */\n#define RX_ENP          0x01\t/* Rx: end of packet */\n\n/* Interrupts from the card are caused by various events which are presented\n * in a circular buffer as several events may be processed on one physical int\n */\n#define MAX_CIRBUFF     32\n\nstruct cirbuff {\n\tu8 rdindex;\t\t/* read, then increment and wrap */\n\tu8 wrindex;\t\t/* write, then increment and wrap */\n\tu8 evntbuff[MAX_CIRBUFF];\n};\n\n/* Interrupt event codes.\n * Where appropriate the two low order bits indicate the port number\n */\n#define CTLA_CHG        0x18\t/* Control signal changed */\n#define CTLB_CHG        0x19\n#define CTLC_CHG        0x1A\n#define CTLD_CHG        0x1B\n\n#define INIT_CPLT       0x20\t/* Initialisation complete */\n#define INIT_FAIL       0x21\t/* Initialisation failed */\n\n#define ABTA_SENT       0x24\t/* Abort sent */\n#define ABTB_SENT       0x25\n#define ABTC_SENT       0x26\n#define ABTD_SENT       0x27\n\n#define TXA_UNDF        0x28\t/* Transmission underflow */\n#define TXB_UNDF        0x29\n#define TXC_UNDF        0x2A\n#define TXD_UNDF        0x2B\n\n#define F56_INT         0x2C\n#define M32_INT         0x2D\n\n#define TE1_ALMA        0x30\n\n/* Port physical configuration. See farsync.h for field values */\nstruct port_cfg {\n\tu16 lineInterface;\t/* Physical interface type */\n\tu8 x25op;\t\t/* Unused at present */\n\tu8 internalClock;\t/* 1 => internal clock, 0 => external */\n\tu8 transparentMode;\t/* 1 => on, 0 => off */\n\tu8 invertClock;\t\t/* 0 => normal, 1 => inverted */\n\tu8 padBytes[6];\t\t/* Padding */\n\tu32 lineSpeed;\t\t/* Speed in bps */\n};\n\n/* TE1 port physical configuration */\nstruct su_config {\n\tu32 dataRate;\n\tu8 clocking;\n\tu8 framing;\n\tu8 structure;\n\tu8 interface;\n\tu8 coding;\n\tu8 lineBuildOut;\n\tu8 equalizer;\n\tu8 transparentMode;\n\tu8 loopMode;\n\tu8 range;\n\tu8 txBufferMode;\n\tu8 rxBufferMode;\n\tu8 startingSlot;\n\tu8 losThreshold;\n\tu8 enableIdleCode;\n\tu8 idleCode;\n\tu8 spare[44];\n};\n\n/* TE1 Status */\nstruct su_status {\n\tu32 receiveBufferDelay;\n\tu32 framingErrorCount;\n\tu32 codeViolationCount;\n\tu32 crcErrorCount;\n\tu32 lineAttenuation;\n\tu8 portStarted;\n\tu8 lossOfSignal;\n\tu8 receiveRemoteAlarm;\n\tu8 alarmIndicationSignal;\n\tu8 spare[40];\n};\n\n/* Finally sling all the above together into the shared memory structure.\n * Sorry it's a hodge podge of arrays, structures and unused bits, it's been\n * evolving under NT for some time so I guess we're stuck with it.\n * The structure starts at offset SMC_BASE.\n * See farsync.h for some field values.\n */\nstruct fst_shared {\n\t/* DMA descriptor rings */\n\tstruct rxdesc rxDescrRing[FST_MAX_PORTS][NUM_RX_BUFFER];\n\tstruct txdesc txDescrRing[FST_MAX_PORTS][NUM_TX_BUFFER];\n\n\t/* Obsolete small buffers */\n\tu8 smallRxBuffer[FST_MAX_PORTS][NUM_RX_BUFFER][LEN_SMALL_RX_BUFFER];\n\tu8 smallTxBuffer[FST_MAX_PORTS][NUM_TX_BUFFER][LEN_SMALL_TX_BUFFER];\n\n\tu8 taskStatus;\t\t/* 0x00 => initialising, 0x01 => running,\n\t\t\t\t * 0xFF => halted\n\t\t\t\t */\n\n\tu8 interruptHandshake;\t/* Set to 0x01 by adapter to signal interrupt,\n\t\t\t\t * set to 0xEE by host to acknowledge interrupt\n\t\t\t\t */\n\n\tu16 smcVersion;\t\t/* Must match SMC_VERSION */\n\n\tu32 smcFirmwareVersion;\t/* 0xIIVVRRBB where II = product ID, VV = major\n\t\t\t\t * version, RR = revision and BB = build\n\t\t\t\t */\n\n\tu16 txa_done;\t\t/* Obsolete completion flags */\n\tu16 rxa_done;\n\tu16 txb_done;\n\tu16 rxb_done;\n\tu16 txc_done;\n\tu16 rxc_done;\n\tu16 txd_done;\n\tu16 rxd_done;\n\n\tu16 mailbox[4];\t\t/* Diagnostics mailbox. Not used */\n\n\tstruct cirbuff interruptEvent;\t/* interrupt causes */\n\n\tu32 v24IpSts[FST_MAX_PORTS];\t/* V.24 control input status */\n\tu32 v24OpSts[FST_MAX_PORTS];\t/* V.24 control output status */\n\n\tstruct port_cfg portConfig[FST_MAX_PORTS];\n\n\tu16 clockStatus[FST_MAX_PORTS];\t/* lsb: 0=> present, 1=> absent */\n\n\tu16 cableStatus;\t/* lsb: 0=> present, 1=> absent */\n\n\tu16 txDescrIndex[FST_MAX_PORTS];\t/* transmit descriptor ring index */\n\tu16 rxDescrIndex[FST_MAX_PORTS];\t/* receive descriptor ring index */\n\n\tu16 portMailbox[FST_MAX_PORTS][2];\t/* command, modifier */\n\tu16 cardMailbox[4];\t/* Not used */\n\n\t/* Number of times the card thinks the host has\n\t * missed an interrupt by not acknowledging\n\t * within 2mS (I guess NT has problems)\n\t */\n\tu32 interruptRetryCount;\n\n\t/* Driver private data used as an ID. We'll not\n\t * use this as I'd rather keep such things\n\t * in main memory rather than on the PCI bus\n\t */\n\tu32 portHandle[FST_MAX_PORTS];\n\n\t/* Count of Tx underflows for stats */\n\tu32 transmitBufferUnderflow[FST_MAX_PORTS];\n\n\t/* Debounced V.24 control input status */\n\tu32 v24DebouncedSts[FST_MAX_PORTS];\n\n\t/* Adapter debounce timers. Don't touch */\n\tu32 ctsTimer[FST_MAX_PORTS];\n\tu32 ctsTimerRun[FST_MAX_PORTS];\n\tu32 dcdTimer[FST_MAX_PORTS];\n\tu32 dcdTimerRun[FST_MAX_PORTS];\n\n\tu32 numberOfPorts;\t/* Number of ports detected at startup */\n\n\tu16 _reserved[64];\n\n\tu16 cardMode;\t\t/* Bit-mask to enable features:\n\t\t\t\t * Bit 0: 1 enables LED identify mode\n\t\t\t\t */\n\n\tu16 portScheduleOffset;\n\n\tstruct su_config suConfig;\t/* TE1 Bits */\n\tstruct su_status suStatus;\n\n\tu32 endOfSmcSignature;\t/* endOfSmcSignature MUST be the last member of\n\t\t\t\t * the structure and marks the end of shared\n\t\t\t\t * memory. Adapter code initializes it as\n\t\t\t\t * END_SIG.\n\t\t\t\t */\n};\n\n/* endOfSmcSignature value */\n#define END_SIG                 0x12345678\n\n/* Mailbox values. (portMailbox) */\n#define NOP             0\t/* No operation */\n#define ACK             1\t/* Positive acknowledgement to PC driver */\n#define NAK             2\t/* Negative acknowledgement to PC driver */\n#define STARTPORT       3\t/* Start an HDLC port */\n#define STOPPORT        4\t/* Stop an HDLC port */\n#define ABORTTX         5\t/* Abort the transmitter for a port */\n#define SETV24O         6\t/* Set V24 outputs */\n\n/* PLX Chip Register Offsets */\n#define CNTRL_9052      0x50\t/* Control Register */\n#define CNTRL_9054      0x6c\t/* Control Register */\n\n#define INTCSR_9052     0x4c\t/* Interrupt control/status register */\n#define INTCSR_9054     0x68\t/* Interrupt control/status register */\n\n/* 9054 DMA Registers */\n/*\n * Note that we will be using DMA Channel 0 for copying rx data\n * and Channel 1 for copying tx data\n */\n#define DMAMODE0        0x80\n#define DMAPADR0        0x84\n#define DMALADR0        0x88\n#define DMASIZ0         0x8c\n#define DMADPR0         0x90\n#define DMAMODE1        0x94\n#define DMAPADR1        0x98\n#define DMALADR1        0x9c\n#define DMASIZ1         0xa0\n#define DMADPR1         0xa4\n#define DMACSR0         0xa8\n#define DMACSR1         0xa9\n#define DMAARB          0xac\n#define DMATHR          0xb0\n#define DMADAC0         0xb4\n#define DMADAC1         0xb8\n#define DMAMARBR        0xac\n\n#define FST_MIN_DMA_LEN 64\n#define FST_RX_DMA_INT  0x01\n#define FST_TX_DMA_INT  0x02\n#define FST_CARD_INT    0x04\n\n/* Larger buffers are positioned in memory at offset BFM_BASE */\nstruct buf_window {\n\tu8 txBuffer[FST_MAX_PORTS][NUM_TX_BUFFER][LEN_TX_BUFFER];\n\tu8 rxBuffer[FST_MAX_PORTS][NUM_RX_BUFFER][LEN_RX_BUFFER];\n};\n\n/* Calculate offset of a buffer object within the shared memory window */\n#define BUF_OFFSET(X)   (BFM_BASE + offsetof(struct buf_window, X))\n\n#pragma pack()\n\n/*      Device driver private information\n *      =================================\n */\n/*      Per port (line or channel) information\n */\nstruct fst_port_info {\n        struct net_device *dev; /* Device struct - must be first */\n\tstruct fst_card_info *card;\t/* Card we're associated with */\n\tint index;\t\t/* Port index on the card */\n\tint hwif;\t\t/* Line hardware (lineInterface copy) */\n\tint run;\t\t/* Port is running */\n\tint mode;\t\t/* Normal or FarSync raw */\n\tint rxpos;\t\t/* Next Rx buffer to use */\n\tint txpos;\t\t/* Next Tx buffer to use */\n\tint txipos;\t\t/* Next Tx buffer to check for free */\n\tint start;\t\t/* Indication of start/stop to network */\n\t/*\n\t * A sixteen entry transmit queue\n\t */\n\tint txqs;\t\t/* index to get next buffer to tx */\n\tint txqe;\t\t/* index to queue next packet */\n\tstruct sk_buff *txq[FST_TXQ_DEPTH];\t/* The queue */\n\tint rxqdepth;\n};\n\n/*      Per card information\n */\nstruct fst_card_info {\n\tchar __iomem *mem;\t/* Card memory mapped to kernel space */\n\tchar __iomem *ctlmem;\t/* Control memory for PCI cards */\n\tunsigned int phys_mem;\t/* Physical memory window address */\n\tunsigned int phys_ctlmem;\t/* Physical control memory address */\n\tunsigned int irq;\t/* Interrupt request line number */\n\tunsigned int nports;\t/* Number of serial ports */\n\tunsigned int type;\t/* Type index of card */\n\tunsigned int state;\t/* State of card */\n\tspinlock_t card_lock;\t/* Lock for SMP access */\n\tunsigned short pci_conf;\t/* PCI card config in I/O space */\n\t/* Per port info */\n\tstruct fst_port_info ports[FST_MAX_PORTS];\n\tstruct pci_dev *device;\t/* Information about the pci device */\n\tint card_no;\t\t/* Inst of the card on the system */\n\tint family;\t\t/* TxP or TxU */\n\tint dmarx_in_progress;\n\tint dmatx_in_progress;\n\tunsigned long int_count;\n\tunsigned long int_time_ave;\n\tvoid *rx_dma_handle_host;\n\tdma_addr_t rx_dma_handle_card;\n\tvoid *tx_dma_handle_host;\n\tdma_addr_t tx_dma_handle_card;\n\tstruct sk_buff *dma_skb_rx;\n\tstruct fst_port_info *dma_port_rx;\n\tstruct fst_port_info *dma_port_tx;\n\tint dma_len_rx;\n\tint dma_len_tx;\n\tint dma_txpos;\n\tint dma_rxpos;\n};\n\n/* Convert an HDLC device pointer into a port info pointer and similar */\n#define dev_to_port(D)  (dev_to_hdlc(D)->priv)\n#define port_to_dev(P)  ((P)->dev)\n\n\n/*\n *      Shared memory window access macros\n *\n *      We have a nice memory based structure above, which could be directly\n *      mapped on i386 but might not work on other architectures unless we use\n *      the readb,w,l and writeb,w,l macros. Unfortunately these macros take\n *      physical offsets so we have to convert. The only saving grace is that\n *      this should all collapse back to a simple indirection eventually.\n */\n#define WIN_OFFSET(X)   ((long)&(((struct fst_shared *)SMC_BASE)->X))\n\n#define FST_RDB(C,E)    readb ((C)->mem + WIN_OFFSET(E))\n#define FST_RDW(C,E)    readw ((C)->mem + WIN_OFFSET(E))\n#define FST_RDL(C,E)    readl ((C)->mem + WIN_OFFSET(E))\n\n#define FST_WRB(C,E,B)  writeb ((B), (C)->mem + WIN_OFFSET(E))\n#define FST_WRW(C,E,W)  writew ((W), (C)->mem + WIN_OFFSET(E))\n#define FST_WRL(C,E,L)  writel ((L), (C)->mem + WIN_OFFSET(E))\n\n/*\n *      Debug support\n */\n#if FST_DEBUG\n\nstatic int fst_debug_mask = { FST_DEBUG };\n\n/* Most common debug activity is to print something if the corresponding bit\n * is set in the debug mask. Note: this uses a non-ANSI extension in GCC to\n * support variable numbers of macro parameters. The inverted if prevents us\n * eating someone else's else clause.\n */\n#define dbg(F, fmt, args...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (fst_debug_mask & (F))\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(fmt), ##args);\t\t\\\n} while (0)\n#else\n#define dbg(F, fmt, args...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (0)\t\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(fmt), ##args);\t\t\\\n} while (0)\n#endif\n\n/*\n *      PCI ID lookup table\n */\nstatic DEFINE_PCI_DEVICE_TABLE(fst_pci_dev_id) = {\n\t{PCI_VENDOR_ID_FARSITE, PCI_DEVICE_ID_FARSITE_T2P, PCI_ANY_ID, \n\t PCI_ANY_ID, 0, 0, FST_TYPE_T2P},\n\n\t{PCI_VENDOR_ID_FARSITE, PCI_DEVICE_ID_FARSITE_T4P, PCI_ANY_ID, \n\t PCI_ANY_ID, 0, 0, FST_TYPE_T4P},\n\n\t{PCI_VENDOR_ID_FARSITE, PCI_DEVICE_ID_FARSITE_T1U, PCI_ANY_ID, \n\t PCI_ANY_ID, 0, 0, FST_TYPE_T1U},\n\n\t{PCI_VENDOR_ID_FARSITE, PCI_DEVICE_ID_FARSITE_T2U, PCI_ANY_ID, \n\t PCI_ANY_ID, 0, 0, FST_TYPE_T2U},\n\n\t{PCI_VENDOR_ID_FARSITE, PCI_DEVICE_ID_FARSITE_T4U, PCI_ANY_ID, \n\t PCI_ANY_ID, 0, 0, FST_TYPE_T4U},\n\n\t{PCI_VENDOR_ID_FARSITE, PCI_DEVICE_ID_FARSITE_TE1, PCI_ANY_ID, \n\t PCI_ANY_ID, 0, 0, FST_TYPE_TE1},\n\n\t{PCI_VENDOR_ID_FARSITE, PCI_DEVICE_ID_FARSITE_TE1C, PCI_ANY_ID, \n\t PCI_ANY_ID, 0, 0, FST_TYPE_TE1},\n\t{0,}\t\t\t/* End */\n};\n\nMODULE_DEVICE_TABLE(pci, fst_pci_dev_id);\n\n/*\n *      Device Driver Work Queues\n *\n *      So that we don't spend too much time processing events in the \n *      Interrupt Service routine, we will declare a work queue per Card \n *      and make the ISR schedule a task in the queue for later execution.\n *      In the 2.4 Kernel we used to use the immediate queue for BH's\n *      Now that they are gone, tasklets seem to be much better than work \n *      queues.\n */\n\nstatic void do_bottom_half_tx(struct fst_card_info *card);\nstatic void do_bottom_half_rx(struct fst_card_info *card);\nstatic void fst_process_tx_work_q(unsigned long work_q);\nstatic void fst_process_int_work_q(unsigned long work_q);\n\nstatic DECLARE_TASKLET(fst_tx_task, fst_process_tx_work_q, 0);\nstatic DECLARE_TASKLET(fst_int_task, fst_process_int_work_q, 0);\n\nstatic struct fst_card_info *fst_card_array[FST_MAX_CARDS];\nstatic spinlock_t fst_work_q_lock;\nstatic u64 fst_work_txq;\nstatic u64 fst_work_intq;\n\nstatic void\nfst_q_work_item(u64 * queue, int card_index)\n{\n\tunsigned long flags;\n\tu64 mask;\n\n\t/*\n\t * Grab the queue exclusively\n\t */\n\tspin_lock_irqsave(&fst_work_q_lock, flags);\n\n\t/*\n\t * Making an entry in the queue is simply a matter of setting\n\t * a bit for the card indicating that there is work to do in the\n\t * bottom half for the card.  Note the limitation of 64 cards.\n\t * That ought to be enough\n\t */\n\tmask = (u64)1 << card_index;\n\t*queue |= mask;\n\tspin_unlock_irqrestore(&fst_work_q_lock, flags);\n}\n\nstatic void\nfst_process_tx_work_q(unsigned long /*void **/work_q)\n{\n\tunsigned long flags;\n\tu64 work_txq;\n\tint i;\n\n\t/*\n\t * Grab the queue exclusively\n\t */\n\tdbg(DBG_TX, \"fst_process_tx_work_q\\n\");\n\tspin_lock_irqsave(&fst_work_q_lock, flags);\n\twork_txq = fst_work_txq;\n\tfst_work_txq = 0;\n\tspin_unlock_irqrestore(&fst_work_q_lock, flags);\n\n\t/*\n\t * Call the bottom half for each card with work waiting\n\t */\n\tfor (i = 0; i < FST_MAX_CARDS; i++) {\n\t\tif (work_txq & 0x01) {\n\t\t\tif (fst_card_array[i] != NULL) {\n\t\t\t\tdbg(DBG_TX, \"Calling tx bh for card %d\\n\", i);\n\t\t\t\tdo_bottom_half_tx(fst_card_array[i]);\n\t\t\t}\n\t\t}\n\t\twork_txq = work_txq >> 1;\n\t}\n}\n\nstatic void\nfst_process_int_work_q(unsigned long /*void **/work_q)\n{\n\tunsigned long flags;\n\tu64 work_intq;\n\tint i;\n\n\t/*\n\t * Grab the queue exclusively\n\t */\n\tdbg(DBG_INTR, \"fst_process_int_work_q\\n\");\n\tspin_lock_irqsave(&fst_work_q_lock, flags);\n\twork_intq = fst_work_intq;\n\tfst_work_intq = 0;\n\tspin_unlock_irqrestore(&fst_work_q_lock, flags);\n\n\t/*\n\t * Call the bottom half for each card with work waiting\n\t */\n\tfor (i = 0; i < FST_MAX_CARDS; i++) {\n\t\tif (work_intq & 0x01) {\n\t\t\tif (fst_card_array[i] != NULL) {\n\t\t\t\tdbg(DBG_INTR,\n\t\t\t\t    \"Calling rx & tx bh for card %d\\n\", i);\n\t\t\t\tdo_bottom_half_rx(fst_card_array[i]);\n\t\t\t\tdo_bottom_half_tx(fst_card_array[i]);\n\t\t\t}\n\t\t}\n\t\twork_intq = work_intq >> 1;\n\t}\n}\n\n/*      Card control functions\n *      ======================\n */\n/*      Place the processor in reset state\n *\n * Used to be a simple write to card control space but a glitch in the latest\n * AMD Am186CH processor means that we now have to do it by asserting and de-\n * asserting the PLX chip PCI Adapter Software Reset. Bit 30 in CNTRL register\n * at offset 9052_CNTRL.  Note the updates for the TXU.\n */\nstatic inline void\nfst_cpureset(struct fst_card_info *card)\n{\n\tunsigned char interrupt_line_register;\n\tunsigned long j = jiffies + 1;\n\tunsigned int regval;\n\n\tif (card->family == FST_FAMILY_TXU) {\n\t\tif (pci_read_config_byte\n\t\t    (card->device, PCI_INTERRUPT_LINE, &interrupt_line_register)) {\n\t\t\tdbg(DBG_ASS,\n\t\t\t    \"Error in reading interrupt line register\\n\");\n\t\t}\n\t\t/*\n\t\t * Assert PLX software reset and Am186 hardware reset\n\t\t * and then deassert the PLX software reset but 186 still in reset\n\t\t */\n\t\toutw(0x440f, card->pci_conf + CNTRL_9054 + 2);\n\t\toutw(0x040f, card->pci_conf + CNTRL_9054 + 2);\n\t\t/*\n\t\t * We are delaying here to allow the 9054 to reset itself\n\t\t */\n\t\tj = jiffies + 1;\n\t\twhile (jiffies < j)\n\t\t\t/* Do nothing */ ;\n\t\toutw(0x240f, card->pci_conf + CNTRL_9054 + 2);\n\t\t/*\n\t\t * We are delaying here to allow the 9054 to reload its eeprom\n\t\t */\n\t\tj = jiffies + 1;\n\t\twhile (jiffies < j)\n\t\t\t/* Do nothing */ ;\n\t\toutw(0x040f, card->pci_conf + CNTRL_9054 + 2);\n\n\t\tif (pci_write_config_byte\n\t\t    (card->device, PCI_INTERRUPT_LINE, interrupt_line_register)) {\n\t\t\tdbg(DBG_ASS,\n\t\t\t    \"Error in writing interrupt line register\\n\");\n\t\t}\n\n\t} else {\n\t\tregval = inl(card->pci_conf + CNTRL_9052);\n\n\t\toutl(regval | 0x40000000, card->pci_conf + CNTRL_9052);\n\t\toutl(regval & ~0x40000000, card->pci_conf + CNTRL_9052);\n\t}\n}\n\n/*      Release the processor from reset\n */\nstatic inline void\nfst_cpurelease(struct fst_card_info *card)\n{\n\tif (card->family == FST_FAMILY_TXU) {\n\t\t/*\n\t\t * Force posted writes to complete\n\t\t */\n\t\t(void) readb(card->mem);\n\n\t\t/*\n\t\t * Release LRESET DO = 1\n\t\t * Then release Local Hold, DO = 1\n\t\t */\n\t\toutw(0x040e, card->pci_conf + CNTRL_9054 + 2);\n\t\toutw(0x040f, card->pci_conf + CNTRL_9054 + 2);\n\t} else {\n\t\t(void) readb(card->ctlmem);\n\t}\n}\n\n/*      Clear the cards interrupt flag\n */\nstatic inline void\nfst_clear_intr(struct fst_card_info *card)\n{\n\tif (card->family == FST_FAMILY_TXU) {\n\t\t(void) readb(card->ctlmem);\n\t} else {\n\t\t/* Poke the appropriate PLX chip register (same as enabling interrupts)\n\t\t */\n\t\toutw(0x0543, card->pci_conf + INTCSR_9052);\n\t}\n}\n\n/*      Enable card interrupts\n */\nstatic inline void\nfst_enable_intr(struct fst_card_info *card)\n{\n\tif (card->family == FST_FAMILY_TXU) {\n\t\toutl(0x0f0c0900, card->pci_conf + INTCSR_9054);\n\t} else {\n\t\toutw(0x0543, card->pci_conf + INTCSR_9052);\n\t}\n}\n\n/*      Disable card interrupts\n */\nstatic inline void\nfst_disable_intr(struct fst_card_info *card)\n{\n\tif (card->family == FST_FAMILY_TXU) {\n\t\toutl(0x00000000, card->pci_conf + INTCSR_9054);\n\t} else {\n\t\toutw(0x0000, card->pci_conf + INTCSR_9052);\n\t}\n}\n\n/*      Process the result of trying to pass a received frame up the stack\n */\nstatic void\nfst_process_rx_status(int rx_status, char *name)\n{\n\tswitch (rx_status) {\n\tcase NET_RX_SUCCESS:\n\t\t{\n\t\t\t/*\n\t\t\t * Nothing to do here\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\tcase NET_RX_DROP:\n\t\t{\n\t\t\tdbg(DBG_ASS, \"%s: Received packet dropped\\n\", name);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/*      Initilaise DMA for PLX 9054\n */\nstatic inline void\nfst_init_dma(struct fst_card_info *card)\n{\n\t/*\n\t * This is only required for the PLX 9054\n\t */\n\tif (card->family == FST_FAMILY_TXU) {\n\t        pci_set_master(card->device);\n\t\toutl(0x00020441, card->pci_conf + DMAMODE0);\n\t\toutl(0x00020441, card->pci_conf + DMAMODE1);\n\t\toutl(0x0, card->pci_conf + DMATHR);\n\t}\n}\n\n/*      Tx dma complete interrupt\n */\nstatic void\nfst_tx_dma_complete(struct fst_card_info *card, struct fst_port_info *port,\n\t\t    int len, int txpos)\n{\n\tstruct net_device *dev = port_to_dev(port);\n\n\t/*\n\t * Everything is now set, just tell the card to go\n\t */\n\tdbg(DBG_TX, \"fst_tx_dma_complete\\n\");\n\tFST_WRB(card, txDescrRing[port->index][txpos].bits,\n\t\tDMA_OWN | TX_STP | TX_ENP);\n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += len;\n\tdev->trans_start = jiffies;\n}\n\n/*\n * Mark it for our own raw sockets interface\n */\nstatic __be16 farsync_type_trans(struct sk_buff *skb, struct net_device *dev)\n{\n\tskb->dev = dev;\n\tskb_reset_mac_header(skb);\n\tskb->pkt_type = PACKET_HOST;\n\treturn htons(ETH_P_CUST);\n}\n\n/*      Rx dma complete interrupt\n */\nstatic void\nfst_rx_dma_complete(struct fst_card_info *card, struct fst_port_info *port,\n\t\t    int len, struct sk_buff *skb, int rxp)\n{\n\tstruct net_device *dev = port_to_dev(port);\n\tint pi;\n\tint rx_status;\n\n\tdbg(DBG_TX, \"fst_rx_dma_complete\\n\");\n\tpi = port->index;\n\tmemcpy(skb_put(skb, len), card->rx_dma_handle_host, len);\n\n\t/* Reset buffer descriptor */\n\tFST_WRB(card, rxDescrRing[pi][rxp].bits, DMA_OWN);\n\n\t/* Update stats */\n\tdev->stats.rx_packets++;\n\tdev->stats.rx_bytes += len;\n\n\t/* Push upstream */\n\tdbg(DBG_RX, \"Pushing the frame up the stack\\n\");\n\tif (port->mode == FST_RAW)\n\t\tskb->protocol = farsync_type_trans(skb, dev);\n\telse\n\t\tskb->protocol = hdlc_type_trans(skb, dev);\n\trx_status = netif_rx(skb);\n\tfst_process_rx_status(rx_status, port_to_dev(port)->name);\n\tif (rx_status == NET_RX_DROP)\n\t\tdev->stats.rx_dropped++;\n}\n\n/*\n *      Receive a frame through the DMA\n */\nstatic inline void\nfst_rx_dma(struct fst_card_info *card, dma_addr_t skb,\n\t   dma_addr_t mem, int len)\n{\n\t/*\n\t * This routine will setup the DMA and start it\n\t */\n\n\tdbg(DBG_RX, \"In fst_rx_dma %lx %lx %d\\n\",\n\t    (unsigned long) skb, (unsigned long) mem, len);\n\tif (card->dmarx_in_progress) {\n\t\tdbg(DBG_ASS, \"In fst_rx_dma while dma in progress\\n\");\n\t}\n\n\toutl(skb, card->pci_conf + DMAPADR0);\t/* Copy to here */\n\toutl(mem, card->pci_conf + DMALADR0);\t/* from here */\n\toutl(len, card->pci_conf + DMASIZ0);\t/* for this length */\n\toutl(0x00000000c, card->pci_conf + DMADPR0);\t/* In this direction */\n\n\t/*\n\t * We use the dmarx_in_progress flag to flag the channel as busy\n\t */\n\tcard->dmarx_in_progress = 1;\n\toutb(0x03, card->pci_conf + DMACSR0);\t/* Start the transfer */\n}\n\n/*\n *      Send a frame through the DMA\n */\nstatic inline void\nfst_tx_dma(struct fst_card_info *card, unsigned char *skb,\n\t   unsigned char *mem, int len)\n{\n\t/*\n\t * This routine will setup the DMA and start it.\n\t */\n\n\tdbg(DBG_TX, \"In fst_tx_dma %p %p %d\\n\", skb, mem, len);\n\tif (card->dmatx_in_progress) {\n\t\tdbg(DBG_ASS, \"In fst_tx_dma while dma in progress\\n\");\n\t}\n\n\toutl((unsigned long) skb, card->pci_conf + DMAPADR1);\t/* Copy from here */\n\toutl((unsigned long) mem, card->pci_conf + DMALADR1);\t/* to here */\n\toutl(len, card->pci_conf + DMASIZ1);\t/* for this length */\n\toutl(0x000000004, card->pci_conf + DMADPR1);\t/* In this direction */\n\n\t/*\n\t * We use the dmatx_in_progress to flag the channel as busy\n\t */\n\tcard->dmatx_in_progress = 1;\n\toutb(0x03, card->pci_conf + DMACSR1);\t/* Start the transfer */\n}\n\n/*      Issue a Mailbox command for a port.\n *      Note we issue them on a fire and forget basis, not expecting to see an\n *      error and not waiting for completion.\n */\nstatic void\nfst_issue_cmd(struct fst_port_info *port, unsigned short cmd)\n{\n\tstruct fst_card_info *card;\n\tunsigned short mbval;\n\tunsigned long flags;\n\tint safety;\n\n\tcard = port->card;\n\tspin_lock_irqsave(&card->card_lock, flags);\n\tmbval = FST_RDW(card, portMailbox[port->index][0]);\n\n\tsafety = 0;\n\t/* Wait for any previous command to complete */\n\twhile (mbval > NAK) {\n\t\tspin_unlock_irqrestore(&card->card_lock, flags);\n\t\tschedule_timeout_uninterruptible(1);\n\t\tspin_lock_irqsave(&card->card_lock, flags);\n\n\t\tif (++safety > 2000) {\n\t\t\tpr_err(\"Mailbox safety timeout\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tmbval = FST_RDW(card, portMailbox[port->index][0]);\n\t}\n\tif (safety > 0) {\n\t\tdbg(DBG_CMD, \"Mailbox clear after %d jiffies\\n\", safety);\n\t}\n\tif (mbval == NAK) {\n\t\tdbg(DBG_CMD, \"issue_cmd: previous command was NAK'd\\n\");\n\t}\n\n\tFST_WRW(card, portMailbox[port->index][0], cmd);\n\n\tif (cmd == ABORTTX || cmd == STARTPORT) {\n\t\tport->txpos = 0;\n\t\tport->txipos = 0;\n\t\tport->start = 0;\n\t}\n\n\tspin_unlock_irqrestore(&card->card_lock, flags);\n}\n\n/*      Port output signals control\n */\nstatic inline void\nfst_op_raise(struct fst_port_info *port, unsigned int outputs)\n{\n\toutputs |= FST_RDL(port->card, v24OpSts[port->index]);\n\tFST_WRL(port->card, v24OpSts[port->index], outputs);\n\n\tif (port->run)\n\t\tfst_issue_cmd(port, SETV24O);\n}\n\nstatic inline void\nfst_op_lower(struct fst_port_info *port, unsigned int outputs)\n{\n\toutputs = ~outputs & FST_RDL(port->card, v24OpSts[port->index]);\n\tFST_WRL(port->card, v24OpSts[port->index], outputs);\n\n\tif (port->run)\n\t\tfst_issue_cmd(port, SETV24O);\n}\n\n/*\n *      Setup port Rx buffers\n */\nstatic void\nfst_rx_config(struct fst_port_info *port)\n{\n\tint i;\n\tint pi;\n\tunsigned int offset;\n\tunsigned long flags;\n\tstruct fst_card_info *card;\n\n\tpi = port->index;\n\tcard = port->card;\n\tspin_lock_irqsave(&card->card_lock, flags);\n\tfor (i = 0; i < NUM_RX_BUFFER; i++) {\n\t\toffset = BUF_OFFSET(rxBuffer[pi][i][0]);\n\n\t\tFST_WRW(card, rxDescrRing[pi][i].ladr, (u16) offset);\n\t\tFST_WRB(card, rxDescrRing[pi][i].hadr, (u8) (offset >> 16));\n\t\tFST_WRW(card, rxDescrRing[pi][i].bcnt, cnv_bcnt(LEN_RX_BUFFER));\n\t\tFST_WRW(card, rxDescrRing[pi][i].mcnt, LEN_RX_BUFFER);\n\t\tFST_WRB(card, rxDescrRing[pi][i].bits, DMA_OWN);\n\t}\n\tport->rxpos = 0;\n\tspin_unlock_irqrestore(&card->card_lock, flags);\n}\n\n/*\n *      Setup port Tx buffers\n */\nstatic void\nfst_tx_config(struct fst_port_info *port)\n{\n\tint i;\n\tint pi;\n\tunsigned int offset;\n\tunsigned long flags;\n\tstruct fst_card_info *card;\n\n\tpi = port->index;\n\tcard = port->card;\n\tspin_lock_irqsave(&card->card_lock, flags);\n\tfor (i = 0; i < NUM_TX_BUFFER; i++) {\n\t\toffset = BUF_OFFSET(txBuffer[pi][i][0]);\n\n\t\tFST_WRW(card, txDescrRing[pi][i].ladr, (u16) offset);\n\t\tFST_WRB(card, txDescrRing[pi][i].hadr, (u8) (offset >> 16));\n\t\tFST_WRW(card, txDescrRing[pi][i].bcnt, 0);\n\t\tFST_WRB(card, txDescrRing[pi][i].bits, 0);\n\t}\n\tport->txpos = 0;\n\tport->txipos = 0;\n\tport->start = 0;\n\tspin_unlock_irqrestore(&card->card_lock, flags);\n}\n\n/*      TE1 Alarm change interrupt event\n */\nstatic void\nfst_intr_te1_alarm(struct fst_card_info *card, struct fst_port_info *port)\n{\n\tu8 los;\n\tu8 rra;\n\tu8 ais;\n\n\tlos = FST_RDB(card, suStatus.lossOfSignal);\n\trra = FST_RDB(card, suStatus.receiveRemoteAlarm);\n\tais = FST_RDB(card, suStatus.alarmIndicationSignal);\n\n\tif (los) {\n\t\t/*\n\t\t * Lost the link\n\t\t */\n\t\tif (netif_carrier_ok(port_to_dev(port))) {\n\t\t\tdbg(DBG_INTR, \"Net carrier off\\n\");\n\t\t\tnetif_carrier_off(port_to_dev(port));\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Link available\n\t\t */\n\t\tif (!netif_carrier_ok(port_to_dev(port))) {\n\t\t\tdbg(DBG_INTR, \"Net carrier on\\n\");\n\t\t\tnetif_carrier_on(port_to_dev(port));\n\t\t}\n\t}\n\n\tif (los)\n\t\tdbg(DBG_INTR, \"Assert LOS Alarm\\n\");\n\telse\n\t\tdbg(DBG_INTR, \"De-assert LOS Alarm\\n\");\n\tif (rra)\n\t\tdbg(DBG_INTR, \"Assert RRA Alarm\\n\");\n\telse\n\t\tdbg(DBG_INTR, \"De-assert RRA Alarm\\n\");\n\n\tif (ais)\n\t\tdbg(DBG_INTR, \"Assert AIS Alarm\\n\");\n\telse\n\t\tdbg(DBG_INTR, \"De-assert AIS Alarm\\n\");\n}\n\n/*      Control signal change interrupt event\n */\nstatic void\nfst_intr_ctlchg(struct fst_card_info *card, struct fst_port_info *port)\n{\n\tint signals;\n\n\tsignals = FST_RDL(card, v24DebouncedSts[port->index]);\n\n\tif (signals & (((port->hwif == X21) || (port->hwif == X21D))\n\t\t       ? IPSTS_INDICATE : IPSTS_DCD)) {\n\t\tif (!netif_carrier_ok(port_to_dev(port))) {\n\t\t\tdbg(DBG_INTR, \"DCD active\\n\");\n\t\t\tnetif_carrier_on(port_to_dev(port));\n\t\t}\n\t} else {\n\t\tif (netif_carrier_ok(port_to_dev(port))) {\n\t\t\tdbg(DBG_INTR, \"DCD lost\\n\");\n\t\t\tnetif_carrier_off(port_to_dev(port));\n\t\t}\n\t}\n}\n\n/*      Log Rx Errors\n */\nstatic void\nfst_log_rx_error(struct fst_card_info *card, struct fst_port_info *port,\n\t\t unsigned char dmabits, int rxp, unsigned short len)\n{\n\tstruct net_device *dev = port_to_dev(port);\n\n\t/*\n\t * Increment the appropriate error counter\n\t */\n\tdev->stats.rx_errors++;\n\tif (dmabits & RX_OFLO) {\n\t\tdev->stats.rx_fifo_errors++;\n\t\tdbg(DBG_ASS, \"Rx fifo error on card %d port %d buffer %d\\n\",\n\t\t    card->card_no, port->index, rxp);\n\t}\n\tif (dmabits & RX_CRC) {\n\t\tdev->stats.rx_crc_errors++;\n\t\tdbg(DBG_ASS, \"Rx crc error on card %d port %d\\n\",\n\t\t    card->card_no, port->index);\n\t}\n\tif (dmabits & RX_FRAM) {\n\t\tdev->stats.rx_frame_errors++;\n\t\tdbg(DBG_ASS, \"Rx frame error on card %d port %d\\n\",\n\t\t    card->card_no, port->index);\n\t}\n\tif (dmabits == (RX_STP | RX_ENP)) {\n\t\tdev->stats.rx_length_errors++;\n\t\tdbg(DBG_ASS, \"Rx length error (%d) on card %d port %d\\n\",\n\t\t    len, card->card_no, port->index);\n\t}\n}\n\n/*      Rx Error Recovery\n */\nstatic void\nfst_recover_rx_error(struct fst_card_info *card, struct fst_port_info *port,\n\t\t     unsigned char dmabits, int rxp, unsigned short len)\n{\n\tint i;\n\tint pi;\n\n\tpi = port->index;\n\t/* \n\t * Discard buffer descriptors until we see the start of the\n\t * next frame.  Note that for long frames this could be in\n\t * a subsequent interrupt. \n\t */\n\ti = 0;\n\twhile ((dmabits & (DMA_OWN | RX_STP)) == 0) {\n\t\tFST_WRB(card, rxDescrRing[pi][rxp].bits, DMA_OWN);\n\t\trxp = (rxp+1) % NUM_RX_BUFFER;\n\t\tif (++i > NUM_RX_BUFFER) {\n\t\t\tdbg(DBG_ASS, \"intr_rx: Discarding more bufs\"\n\t\t\t    \" than we have\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tdmabits = FST_RDB(card, rxDescrRing[pi][rxp].bits);\n\t\tdbg(DBG_ASS, \"DMA Bits of next buffer was %x\\n\", dmabits);\n\t}\n\tdbg(DBG_ASS, \"There were %d subsequent buffers in error\\n\", i);\n\n\t/* Discard the terminal buffer */\n\tif (!(dmabits & DMA_OWN)) {\n\t\tFST_WRB(card, rxDescrRing[pi][rxp].bits, DMA_OWN);\n\t\trxp = (rxp+1) % NUM_RX_BUFFER;\n\t}\n\tport->rxpos = rxp;\n\treturn;\n\n}\n\n/*      Rx complete interrupt\n */\nstatic void\nfst_intr_rx(struct fst_card_info *card, struct fst_port_info *port)\n{\n\tunsigned char dmabits;\n\tint pi;\n\tint rxp;\n\tint rx_status;\n\tunsigned short len;\n\tstruct sk_buff *skb;\n\tstruct net_device *dev = port_to_dev(port);\n\n\t/* Check we have a buffer to process */\n\tpi = port->index;\n\trxp = port->rxpos;\n\tdmabits = FST_RDB(card, rxDescrRing[pi][rxp].bits);\n\tif (dmabits & DMA_OWN) {\n\t\tdbg(DBG_RX | DBG_INTR, \"intr_rx: No buffer port %d pos %d\\n\",\n\t\t    pi, rxp);\n\t\treturn;\n\t}\n\tif (card->dmarx_in_progress) {\n\t\treturn;\n\t}\n\n\t/* Get buffer length */\n\tlen = FST_RDW(card, rxDescrRing[pi][rxp].mcnt);\n\t/* Discard the CRC */\n\tlen -= 2;\n\tif (len == 0) {\n\t\t/*\n\t\t * This seems to happen on the TE1 interface sometimes\n\t\t * so throw the frame away and log the event.\n\t\t */\n\t\tpr_err(\"Frame received with 0 length. Card %d Port %d\\n\",\n\t\t       card->card_no, port->index);\n\t\t/* Return descriptor to card */\n\t\tFST_WRB(card, rxDescrRing[pi][rxp].bits, DMA_OWN);\n\n\t\trxp = (rxp+1) % NUM_RX_BUFFER;\n\t\tport->rxpos = rxp;\n\t\treturn;\n\t}\n\n\t/* Check buffer length and for other errors. We insist on one packet\n\t * in one buffer. This simplifies things greatly and since we've\n\t * allocated 8K it shouldn't be a real world limitation\n\t */\n\tdbg(DBG_RX, \"intr_rx: %d,%d: flags %x len %d\\n\", pi, rxp, dmabits, len);\n\tif (dmabits != (RX_STP | RX_ENP) || len > LEN_RX_BUFFER - 2) {\n\t\tfst_log_rx_error(card, port, dmabits, rxp, len);\n\t\tfst_recover_rx_error(card, port, dmabits, rxp, len);\n\t\treturn;\n\t}\n\n\t/* Allocate SKB */\n\tif ((skb = dev_alloc_skb(len)) == NULL) {\n\t\tdbg(DBG_RX, \"intr_rx: can't allocate buffer\\n\");\n\n\t\tdev->stats.rx_dropped++;\n\n\t\t/* Return descriptor to card */\n\t\tFST_WRB(card, rxDescrRing[pi][rxp].bits, DMA_OWN);\n\n\t\trxp = (rxp+1) % NUM_RX_BUFFER;\n\t\tport->rxpos = rxp;\n\t\treturn;\n\t}\n\n\t/*\n\t * We know the length we need to receive, len.\n\t * It's not worth using the DMA for reads of less than\n\t * FST_MIN_DMA_LEN\n\t */\n\n\tif ((len < FST_MIN_DMA_LEN) || (card->family == FST_FAMILY_TXP)) {\n\t\tmemcpy_fromio(skb_put(skb, len),\n\t\t\t      card->mem + BUF_OFFSET(rxBuffer[pi][rxp][0]),\n\t\t\t      len);\n\n\t\t/* Reset buffer descriptor */\n\t\tFST_WRB(card, rxDescrRing[pi][rxp].bits, DMA_OWN);\n\n\t\t/* Update stats */\n\t\tdev->stats.rx_packets++;\n\t\tdev->stats.rx_bytes += len;\n\n\t\t/* Push upstream */\n\t\tdbg(DBG_RX, \"Pushing frame up the stack\\n\");\n\t\tif (port->mode == FST_RAW)\n\t\t\tskb->protocol = farsync_type_trans(skb, dev);\n\t\telse\n\t\t\tskb->protocol = hdlc_type_trans(skb, dev);\n\t\trx_status = netif_rx(skb);\n\t\tfst_process_rx_status(rx_status, port_to_dev(port)->name);\n\t\tif (rx_status == NET_RX_DROP)\n\t\t\tdev->stats.rx_dropped++;\n\t} else {\n\t\tcard->dma_skb_rx = skb;\n\t\tcard->dma_port_rx = port;\n\t\tcard->dma_len_rx = len;\n\t\tcard->dma_rxpos = rxp;\n\t\tfst_rx_dma(card, card->rx_dma_handle_card,\n\t\t\t   BUF_OFFSET(rxBuffer[pi][rxp][0]), len);\n\t}\n\tif (rxp != port->rxpos) {\n\t\tdbg(DBG_ASS, \"About to increment rxpos by more than 1\\n\");\n\t\tdbg(DBG_ASS, \"rxp = %d rxpos = %d\\n\", rxp, port->rxpos);\n\t}\n\trxp = (rxp+1) % NUM_RX_BUFFER;\n\tport->rxpos = rxp;\n}\n\n/*\n *      The bottom halfs to the ISR\n *\n */\n\nstatic void\ndo_bottom_half_tx(struct fst_card_info *card)\n{\n\tstruct fst_port_info *port;\n\tint pi;\n\tint txq_length;\n\tstruct sk_buff *skb;\n\tunsigned long flags;\n\tstruct net_device *dev;\n\n\t/*\n\t *  Find a free buffer for the transmit\n\t *  Step through each port on this card\n\t */\n\n\tdbg(DBG_TX, \"do_bottom_half_tx\\n\");\n\tfor (pi = 0, port = card->ports; pi < card->nports; pi++, port++) {\n\t\tif (!port->run)\n\t\t\tcontinue;\n\n\t\tdev = port_to_dev(port);\n\t\twhile (!(FST_RDB(card, txDescrRing[pi][port->txpos].bits) &\n\t\t\t DMA_OWN) &&\n\t\t       !(card->dmatx_in_progress)) {\n\t\t\t/*\n\t\t\t * There doesn't seem to be a txdone event per-se\n\t\t\t * We seem to have to deduce it, by checking the DMA_OWN\n\t\t\t * bit on the next buffer we think we can use\n\t\t\t */\n\t\t\tspin_lock_irqsave(&card->card_lock, flags);\n\t\t\tif ((txq_length = port->txqe - port->txqs) < 0) {\n\t\t\t\t/*\n\t\t\t\t * This is the case where one has wrapped and the\n\t\t\t\t * maths gives us a negative number\n\t\t\t\t */\n\t\t\t\ttxq_length = txq_length + FST_TXQ_DEPTH;\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&card->card_lock, flags);\n\t\t\tif (txq_length > 0) {\n\t\t\t\t/*\n\t\t\t\t * There is something to send\n\t\t\t\t */\n\t\t\t\tspin_lock_irqsave(&card->card_lock, flags);\n\t\t\t\tskb = port->txq[port->txqs];\n\t\t\t\tport->txqs++;\n\t\t\t\tif (port->txqs == FST_TXQ_DEPTH) {\n\t\t\t\t\tport->txqs = 0;\n\t\t\t\t}\n\t\t\t\tspin_unlock_irqrestore(&card->card_lock, flags);\n\t\t\t\t/*\n\t\t\t\t * copy the data and set the required indicators on the\n\t\t\t\t * card.\n\t\t\t\t */\n\t\t\t\tFST_WRW(card, txDescrRing[pi][port->txpos].bcnt,\n\t\t\t\t\tcnv_bcnt(skb->len));\n\t\t\t\tif ((skb->len < FST_MIN_DMA_LEN) ||\n\t\t\t\t    (card->family == FST_FAMILY_TXP)) {\n\t\t\t\t\t/* Enqueue the packet with normal io */\n\t\t\t\t\tmemcpy_toio(card->mem +\n\t\t\t\t\t\t    BUF_OFFSET(txBuffer[pi]\n\t\t\t\t\t\t\t       [port->\n\t\t\t\t\t\t\t\ttxpos][0]),\n\t\t\t\t\t\t    skb->data, skb->len);\n\t\t\t\t\tFST_WRB(card,\n\t\t\t\t\t\ttxDescrRing[pi][port->txpos].\n\t\t\t\t\t\tbits,\n\t\t\t\t\t\tDMA_OWN | TX_STP | TX_ENP);\n\t\t\t\t\tdev->stats.tx_packets++;\n\t\t\t\t\tdev->stats.tx_bytes += skb->len;\n\t\t\t\t\tdev->trans_start = jiffies;\n\t\t\t\t} else {\n\t\t\t\t\t/* Or do it through dma */\n\t\t\t\t\tmemcpy(card->tx_dma_handle_host,\n\t\t\t\t\t       skb->data, skb->len);\n\t\t\t\t\tcard->dma_port_tx = port;\n\t\t\t\t\tcard->dma_len_tx = skb->len;\n\t\t\t\t\tcard->dma_txpos = port->txpos;\n\t\t\t\t\tfst_tx_dma(card,\n\t\t\t\t\t\t   (char *) card->\n\t\t\t\t\t\t   tx_dma_handle_card,\n\t\t\t\t\t\t   (char *)\n\t\t\t\t\t\t   BUF_OFFSET(txBuffer[pi]\n\t\t\t\t\t\t\t      [port->txpos][0]),\n\t\t\t\t\t\t   skb->len);\n\t\t\t\t}\n\t\t\t\tif (++port->txpos >= NUM_TX_BUFFER)\n\t\t\t\t\tport->txpos = 0;\n\t\t\t\t/*\n\t\t\t\t * If we have flow control on, can we now release it?\n\t\t\t\t */\n\t\t\t\tif (port->start) {\n\t\t\t\t\tif (txq_length < fst_txq_low) {\n\t\t\t\t\t\tnetif_wake_queue(port_to_dev\n\t\t\t\t\t\t\t\t (port));\n\t\t\t\t\t\tport->start = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Nothing to send so break out of the while loop\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void\ndo_bottom_half_rx(struct fst_card_info *card)\n{\n\tstruct fst_port_info *port;\n\tint pi;\n\tint rx_count = 0;\n\n\t/* Check for rx completions on all ports on this card */\n\tdbg(DBG_RX, \"do_bottom_half_rx\\n\");\n\tfor (pi = 0, port = card->ports; pi < card->nports; pi++, port++) {\n\t\tif (!port->run)\n\t\t\tcontinue;\n\n\t\twhile (!(FST_RDB(card, rxDescrRing[pi][port->rxpos].bits)\n\t\t\t & DMA_OWN) && !(card->dmarx_in_progress)) {\n\t\t\tif (rx_count > fst_max_reads) {\n\t\t\t\t/*\n\t\t\t\t * Don't spend forever in receive processing\n\t\t\t\t * Schedule another event\n\t\t\t\t */\n\t\t\t\tfst_q_work_item(&fst_work_intq, card->card_no);\n\t\t\t\ttasklet_schedule(&fst_int_task);\n\t\t\t\tbreak;\t/* Leave the loop */\n\t\t\t}\n\t\t\tfst_intr_rx(card, port);\n\t\t\trx_count++;\n\t\t}\n\t}\n}\n\n/*\n *      The interrupt service routine\n *      Dev_id is our fst_card_info pointer\n */\nstatic irqreturn_t\nfst_intr(int dummy, void *dev_id)\n{\n\tstruct fst_card_info *card = dev_id;\n\tstruct fst_port_info *port;\n\tint rdidx;\t\t/* Event buffer indices */\n\tint wridx;\n\tint event;\t\t/* Actual event for processing */\n\tunsigned int dma_intcsr = 0;\n\tunsigned int do_card_interrupt;\n\tunsigned int int_retry_count;\n\n\t/*\n\t * Check to see if the interrupt was for this card\n\t * return if not\n\t * Note that the call to clear the interrupt is important\n\t */\n\tdbg(DBG_INTR, \"intr: %d %p\\n\", card->irq, card);\n\tif (card->state != FST_RUNNING) {\n\t\tpr_err(\"Interrupt received for card %d in a non running state (%d)\\n\",\n\t\t       card->card_no, card->state);\n\n\t\t/* \n\t\t * It is possible to really be running, i.e. we have re-loaded\n\t\t * a running card\n\t\t * Clear and reprime the interrupt source \n\t\t */\n\t\tfst_clear_intr(card);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t/* Clear and reprime the interrupt source */\n\tfst_clear_intr(card);\n\n\t/*\n\t * Is the interrupt for this card (handshake == 1)\n\t */\n\tdo_card_interrupt = 0;\n\tif (FST_RDB(card, interruptHandshake) == 1) {\n\t\tdo_card_interrupt += FST_CARD_INT;\n\t\t/* Set the software acknowledge */\n\t\tFST_WRB(card, interruptHandshake, 0xEE);\n\t}\n\tif (card->family == FST_FAMILY_TXU) {\n\t\t/*\n\t\t * Is it a DMA Interrupt\n\t\t */\n\t\tdma_intcsr = inl(card->pci_conf + INTCSR_9054);\n\t\tif (dma_intcsr & 0x00200000) {\n\t\t\t/*\n\t\t\t * DMA Channel 0 (Rx transfer complete)\n\t\t\t */\n\t\t\tdbg(DBG_RX, \"DMA Rx xfer complete\\n\");\n\t\t\toutb(0x8, card->pci_conf + DMACSR0);\n\t\t\tfst_rx_dma_complete(card, card->dma_port_rx,\n\t\t\t\t\t    card->dma_len_rx, card->dma_skb_rx,\n\t\t\t\t\t    card->dma_rxpos);\n\t\t\tcard->dmarx_in_progress = 0;\n\t\t\tdo_card_interrupt += FST_RX_DMA_INT;\n\t\t}\n\t\tif (dma_intcsr & 0x00400000) {\n\t\t\t/*\n\t\t\t * DMA Channel 1 (Tx transfer complete)\n\t\t\t */\n\t\t\tdbg(DBG_TX, \"DMA Tx xfer complete\\n\");\n\t\t\toutb(0x8, card->pci_conf + DMACSR1);\n\t\t\tfst_tx_dma_complete(card, card->dma_port_tx,\n\t\t\t\t\t    card->dma_len_tx, card->dma_txpos);\n\t\t\tcard->dmatx_in_progress = 0;\n\t\t\tdo_card_interrupt += FST_TX_DMA_INT;\n\t\t}\n\t}\n\n\t/*\n\t * Have we been missing Interrupts\n\t */\n\tint_retry_count = FST_RDL(card, interruptRetryCount);\n\tif (int_retry_count) {\n\t\tdbg(DBG_ASS, \"Card %d int_retry_count is  %d\\n\",\n\t\t    card->card_no, int_retry_count);\n\t\tFST_WRL(card, interruptRetryCount, 0);\n\t}\n\n\tif (!do_card_interrupt) {\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t/* Scehdule the bottom half of the ISR */\n\tfst_q_work_item(&fst_work_intq, card->card_no);\n\ttasklet_schedule(&fst_int_task);\n\n\t/* Drain the event queue */\n\trdidx = FST_RDB(card, interruptEvent.rdindex) & 0x1f;\n\twridx = FST_RDB(card, interruptEvent.wrindex) & 0x1f;\n\twhile (rdidx != wridx) {\n\t\tevent = FST_RDB(card, interruptEvent.evntbuff[rdidx]);\n\t\tport = &card->ports[event & 0x03];\n\n\t\tdbg(DBG_INTR, \"Processing Interrupt event: %x\\n\", event);\n\n\t\tswitch (event) {\n\t\tcase TE1_ALMA:\n\t\t\tdbg(DBG_INTR, \"TE1 Alarm intr\\n\");\n\t\t\tif (port->run)\n\t\t\t\tfst_intr_te1_alarm(card, port);\n\t\t\tbreak;\n\n\t\tcase CTLA_CHG:\n\t\tcase CTLB_CHG:\n\t\tcase CTLC_CHG:\n\t\tcase CTLD_CHG:\n\t\t\tif (port->run)\n\t\t\t\tfst_intr_ctlchg(card, port);\n\t\t\tbreak;\n\n\t\tcase ABTA_SENT:\n\t\tcase ABTB_SENT:\n\t\tcase ABTC_SENT:\n\t\tcase ABTD_SENT:\n\t\t\tdbg(DBG_TX, \"Abort complete port %d\\n\", port->index);\n\t\t\tbreak;\n\n\t\tcase TXA_UNDF:\n\t\tcase TXB_UNDF:\n\t\tcase TXC_UNDF:\n\t\tcase TXD_UNDF:\n\t\t\t/* Difficult to see how we'd get this given that we\n\t\t\t * always load up the entire packet for DMA.\n\t\t\t */\n\t\t\tdbg(DBG_TX, \"Tx underflow port %d\\n\", port->index);\n\t\t\tport_to_dev(port)->stats.tx_errors++;\n\t\t\tport_to_dev(port)->stats.tx_fifo_errors++;\n\t\t\tdbg(DBG_ASS, \"Tx underflow on card %d port %d\\n\",\n\t\t\t    card->card_no, port->index);\n\t\t\tbreak;\n\n\t\tcase INIT_CPLT:\n\t\t\tdbg(DBG_INIT, \"Card init OK intr\\n\");\n\t\t\tbreak;\n\n\t\tcase INIT_FAIL:\n\t\t\tdbg(DBG_INIT, \"Card init FAILED intr\\n\");\n\t\t\tcard->state = FST_IFAILED;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"intr: unknown card event %d. ignored\\n\", event);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Bump and wrap the index */\n\t\tif (++rdidx >= MAX_CIRBUFF)\n\t\t\trdidx = 0;\n\t}\n\tFST_WRB(card, interruptEvent.rdindex, rdidx);\n        return IRQ_HANDLED;\n}\n\n/*      Check that the shared memory configuration is one that we can handle\n *      and that some basic parameters are correct\n */\nstatic void\ncheck_started_ok(struct fst_card_info *card)\n{\n\tint i;\n\n\t/* Check structure version and end marker */\n\tif (FST_RDW(card, smcVersion) != SMC_VERSION) {\n\t\tpr_err(\"Bad shared memory version %d expected %d\\n\",\n\t\t       FST_RDW(card, smcVersion), SMC_VERSION);\n\t\tcard->state = FST_BADVERSION;\n\t\treturn;\n\t}\n\tif (FST_RDL(card, endOfSmcSignature) != END_SIG) {\n\t\tpr_err(\"Missing shared memory signature\\n\");\n\t\tcard->state = FST_BADVERSION;\n\t\treturn;\n\t}\n\t/* Firmware status flag, 0x00 = initialising, 0x01 = OK, 0xFF = fail */\n\tif ((i = FST_RDB(card, taskStatus)) == 0x01) {\n\t\tcard->state = FST_RUNNING;\n\t} else if (i == 0xFF) {\n\t\tpr_err(\"Firmware initialisation failed. Card halted\\n\");\n\t\tcard->state = FST_HALTED;\n\t\treturn;\n\t} else if (i != 0x00) {\n\t\tpr_err(\"Unknown firmware status 0x%x\\n\", i);\n\t\tcard->state = FST_HALTED;\n\t\treturn;\n\t}\n\n\t/* Finally check the number of ports reported by firmware against the\n\t * number we assumed at card detection. Should never happen with\n\t * existing firmware etc so we just report it for the moment.\n\t */\n\tif (FST_RDL(card, numberOfPorts) != card->nports) {\n\t\tpr_warn(\"Port count mismatch on card %d.  Firmware thinks %d we say %d\\n\",\n\t\t\tcard->card_no,\n\t\t\tFST_RDL(card, numberOfPorts), card->nports);\n\t}\n}\n\nstatic int\nset_conf_from_info(struct fst_card_info *card, struct fst_port_info *port,\n\t\t   struct fstioc_info *info)\n{\n\tint err;\n\tunsigned char my_framing;\n\n\t/* Set things according to the user set valid flags \n\t * Several of the old options have been invalidated/replaced by the \n\t * generic hdlc package.\n\t */\n\terr = 0;\n\tif (info->valid & FSTVAL_PROTO) {\n\t\tif (info->proto == FST_RAW)\n\t\t\tport->mode = FST_RAW;\n\t\telse\n\t\t\tport->mode = FST_GEN_HDLC;\n\t}\n\n\tif (info->valid & FSTVAL_CABLE)\n\t\terr = -EINVAL;\n\n\tif (info->valid & FSTVAL_SPEED)\n\t\terr = -EINVAL;\n\n\tif (info->valid & FSTVAL_PHASE)\n\t\tFST_WRB(card, portConfig[port->index].invertClock,\n\t\t\tinfo->invertClock);\n\tif (info->valid & FSTVAL_MODE)\n\t\tFST_WRW(card, cardMode, info->cardMode);\n\tif (info->valid & FSTVAL_TE1) {\n\t\tFST_WRL(card, suConfig.dataRate, info->lineSpeed);\n\t\tFST_WRB(card, suConfig.clocking, info->clockSource);\n\t\tmy_framing = FRAMING_E1;\n\t\tif (info->framing == E1)\n\t\t\tmy_framing = FRAMING_E1;\n\t\tif (info->framing == T1)\n\t\t\tmy_framing = FRAMING_T1;\n\t\tif (info->framing == J1)\n\t\t\tmy_framing = FRAMING_J1;\n\t\tFST_WRB(card, suConfig.framing, my_framing);\n\t\tFST_WRB(card, suConfig.structure, info->structure);\n\t\tFST_WRB(card, suConfig.interface, info->interface);\n\t\tFST_WRB(card, suConfig.coding, info->coding);\n\t\tFST_WRB(card, suConfig.lineBuildOut, info->lineBuildOut);\n\t\tFST_WRB(card, suConfig.equalizer, info->equalizer);\n\t\tFST_WRB(card, suConfig.transparentMode, info->transparentMode);\n\t\tFST_WRB(card, suConfig.loopMode, info->loopMode);\n\t\tFST_WRB(card, suConfig.range, info->range);\n\t\tFST_WRB(card, suConfig.txBufferMode, info->txBufferMode);\n\t\tFST_WRB(card, suConfig.rxBufferMode, info->rxBufferMode);\n\t\tFST_WRB(card, suConfig.startingSlot, info->startingSlot);\n\t\tFST_WRB(card, suConfig.losThreshold, info->losThreshold);\n\t\tif (info->idleCode)\n\t\t\tFST_WRB(card, suConfig.enableIdleCode, 1);\n\t\telse\n\t\t\tFST_WRB(card, suConfig.enableIdleCode, 0);\n\t\tFST_WRB(card, suConfig.idleCode, info->idleCode);\n#if FST_DEBUG\n\t\tif (info->valid & FSTVAL_TE1) {\n\t\t\tprintk(\"Setting TE1 data\\n\");\n\t\t\tprintk(\"Line Speed = %d\\n\", info->lineSpeed);\n\t\t\tprintk(\"Start slot = %d\\n\", info->startingSlot);\n\t\t\tprintk(\"Clock source = %d\\n\", info->clockSource);\n\t\t\tprintk(\"Framing = %d\\n\", my_framing);\n\t\t\tprintk(\"Structure = %d\\n\", info->structure);\n\t\t\tprintk(\"interface = %d\\n\", info->interface);\n\t\t\tprintk(\"Coding = %d\\n\", info->coding);\n\t\t\tprintk(\"Line build out = %d\\n\", info->lineBuildOut);\n\t\t\tprintk(\"Equaliser = %d\\n\", info->equalizer);\n\t\t\tprintk(\"Transparent mode = %d\\n\",\n\t\t\t       info->transparentMode);\n\t\t\tprintk(\"Loop mode = %d\\n\", info->loopMode);\n\t\t\tprintk(\"Range = %d\\n\", info->range);\n\t\t\tprintk(\"Tx Buffer mode = %d\\n\", info->txBufferMode);\n\t\t\tprintk(\"Rx Buffer mode = %d\\n\", info->rxBufferMode);\n\t\t\tprintk(\"LOS Threshold = %d\\n\", info->losThreshold);\n\t\t\tprintk(\"Idle Code = %d\\n\", info->idleCode);\n\t\t}\n#endif\n\t}\n#if FST_DEBUG\n\tif (info->valid & FSTVAL_DEBUG) {\n\t\tfst_debug_mask = info->debug;\n\t}\n#endif\n\n\treturn err;\n}\n\nstatic void\ngather_conf_info(struct fst_card_info *card, struct fst_port_info *port,\n\t\t struct fstioc_info *info)\n{\n\tint i;\n\n\tmemset(info, 0, sizeof (struct fstioc_info));\n\n\ti = port->index;\n\tinfo->kernelVersion = LINUX_VERSION_CODE;\n\tinfo->nports = card->nports;\n\tinfo->type = card->type;\n\tinfo->state = card->state;\n\tinfo->proto = FST_GEN_HDLC;\n\tinfo->index = i;\n#if FST_DEBUG\n\tinfo->debug = fst_debug_mask;\n#endif\n\n\t/* Only mark information as valid if card is running.\n\t * Copy the data anyway in case it is useful for diagnostics\n\t */\n\tinfo->valid = ((card->state == FST_RUNNING) ? FSTVAL_ALL : FSTVAL_CARD)\n#if FST_DEBUG\n\t    | FSTVAL_DEBUG\n#endif\n\t    ;\n\n\tinfo->lineInterface = FST_RDW(card, portConfig[i].lineInterface);\n\tinfo->internalClock = FST_RDB(card, portConfig[i].internalClock);\n\tinfo->lineSpeed = FST_RDL(card, portConfig[i].lineSpeed);\n\tinfo->invertClock = FST_RDB(card, portConfig[i].invertClock);\n\tinfo->v24IpSts = FST_RDL(card, v24IpSts[i]);\n\tinfo->v24OpSts = FST_RDL(card, v24OpSts[i]);\n\tinfo->clockStatus = FST_RDW(card, clockStatus[i]);\n\tinfo->cableStatus = FST_RDW(card, cableStatus);\n\tinfo->cardMode = FST_RDW(card, cardMode);\n\tinfo->smcFirmwareVersion = FST_RDL(card, smcFirmwareVersion);\n\n\t/*\n\t * The T2U can report cable presence for both A or B\n\t * in bits 0 and 1 of cableStatus.  See which port we are and \n\t * do the mapping.\n\t */\n\tif (card->family == FST_FAMILY_TXU) {\n\t\tif (port->index == 0) {\n\t\t\t/*\n\t\t\t * Port A\n\t\t\t */\n\t\t\tinfo->cableStatus = info->cableStatus & 1;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Port B\n\t\t\t */\n\t\t\tinfo->cableStatus = info->cableStatus >> 1;\n\t\t\tinfo->cableStatus = info->cableStatus & 1;\n\t\t}\n\t}\n\t/*\n\t * Some additional bits if we are TE1\n\t */\n\tif (card->type == FST_TYPE_TE1) {\n\t\tinfo->lineSpeed = FST_RDL(card, suConfig.dataRate);\n\t\tinfo->clockSource = FST_RDB(card, suConfig.clocking);\n\t\tinfo->framing = FST_RDB(card, suConfig.framing);\n\t\tinfo->structure = FST_RDB(card, suConfig.structure);\n\t\tinfo->interface = FST_RDB(card, suConfig.interface);\n\t\tinfo->coding = FST_RDB(card, suConfig.coding);\n\t\tinfo->lineBuildOut = FST_RDB(card, suConfig.lineBuildOut);\n\t\tinfo->equalizer = FST_RDB(card, suConfig.equalizer);\n\t\tinfo->loopMode = FST_RDB(card, suConfig.loopMode);\n\t\tinfo->range = FST_RDB(card, suConfig.range);\n\t\tinfo->txBufferMode = FST_RDB(card, suConfig.txBufferMode);\n\t\tinfo->rxBufferMode = FST_RDB(card, suConfig.rxBufferMode);\n\t\tinfo->startingSlot = FST_RDB(card, suConfig.startingSlot);\n\t\tinfo->losThreshold = FST_RDB(card, suConfig.losThreshold);\n\t\tif (FST_RDB(card, suConfig.enableIdleCode))\n\t\t\tinfo->idleCode = FST_RDB(card, suConfig.idleCode);\n\t\telse\n\t\t\tinfo->idleCode = 0;\n\t\tinfo->receiveBufferDelay =\n\t\t    FST_RDL(card, suStatus.receiveBufferDelay);\n\t\tinfo->framingErrorCount =\n\t\t    FST_RDL(card, suStatus.framingErrorCount);\n\t\tinfo->codeViolationCount =\n\t\t    FST_RDL(card, suStatus.codeViolationCount);\n\t\tinfo->crcErrorCount = FST_RDL(card, suStatus.crcErrorCount);\n\t\tinfo->lineAttenuation = FST_RDL(card, suStatus.lineAttenuation);\n\t\tinfo->lossOfSignal = FST_RDB(card, suStatus.lossOfSignal);\n\t\tinfo->receiveRemoteAlarm =\n\t\t    FST_RDB(card, suStatus.receiveRemoteAlarm);\n\t\tinfo->alarmIndicationSignal =\n\t\t    FST_RDB(card, suStatus.alarmIndicationSignal);\n\t}\n}\n\nstatic int\nfst_set_iface(struct fst_card_info *card, struct fst_port_info *port,\n\t      struct ifreq *ifr)\n{\n\tsync_serial_settings sync;\n\tint i;\n\n\tif (ifr->ifr_settings.size != sizeof (sync)) {\n\t\treturn -ENOMEM;\n\t}\n\n\tif (copy_from_user\n\t    (&sync, ifr->ifr_settings.ifs_ifsu.sync, sizeof (sync))) {\n\t\treturn -EFAULT;\n\t}\n\n\tif (sync.loopback)\n\t\treturn -EINVAL;\n\n\ti = port->index;\n\n\tswitch (ifr->ifr_settings.type) {\n\tcase IF_IFACE_V35:\n\t\tFST_WRW(card, portConfig[i].lineInterface, V35);\n\t\tport->hwif = V35;\n\t\tbreak;\n\n\tcase IF_IFACE_V24:\n\t\tFST_WRW(card, portConfig[i].lineInterface, V24);\n\t\tport->hwif = V24;\n\t\tbreak;\n\n\tcase IF_IFACE_X21:\n\t\tFST_WRW(card, portConfig[i].lineInterface, X21);\n\t\tport->hwif = X21;\n\t\tbreak;\n\n\tcase IF_IFACE_X21D:\n\t\tFST_WRW(card, portConfig[i].lineInterface, X21D);\n\t\tport->hwif = X21D;\n\t\tbreak;\n\n\tcase IF_IFACE_T1:\n\t\tFST_WRW(card, portConfig[i].lineInterface, T1);\n\t\tport->hwif = T1;\n\t\tbreak;\n\n\tcase IF_IFACE_E1:\n\t\tFST_WRW(card, portConfig[i].lineInterface, E1);\n\t\tport->hwif = E1;\n\t\tbreak;\n\n\tcase IF_IFACE_SYNC_SERIAL:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (sync.clock_type) {\n\tcase CLOCK_EXT:\n\t\tFST_WRB(card, portConfig[i].internalClock, EXTCLK);\n\t\tbreak;\n\n\tcase CLOCK_INT:\n\t\tFST_WRB(card, portConfig[i].internalClock, INTCLK);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tFST_WRL(card, portConfig[i].lineSpeed, sync.clock_rate);\n\treturn 0;\n}\n\nstatic int\nfst_get_iface(struct fst_card_info *card, struct fst_port_info *port,\n\t      struct ifreq *ifr)\n{\n\tsync_serial_settings sync;\n\tint i;\n\n\t/* First check what line type is set, we'll default to reporting X.21\n\t * if nothing is set as IF_IFACE_SYNC_SERIAL implies it can't be\n\t * changed\n\t */\n\tswitch (port->hwif) {\n\tcase E1:\n\t\tifr->ifr_settings.type = IF_IFACE_E1;\n\t\tbreak;\n\tcase T1:\n\t\tifr->ifr_settings.type = IF_IFACE_T1;\n\t\tbreak;\n\tcase V35:\n\t\tifr->ifr_settings.type = IF_IFACE_V35;\n\t\tbreak;\n\tcase V24:\n\t\tifr->ifr_settings.type = IF_IFACE_V24;\n\t\tbreak;\n\tcase X21D:\n\t\tifr->ifr_settings.type = IF_IFACE_X21D;\n\t\tbreak;\n\tcase X21:\n\tdefault:\n\t\tifr->ifr_settings.type = IF_IFACE_X21;\n\t\tbreak;\n\t}\n\tif (ifr->ifr_settings.size == 0) {\n\t\treturn 0;\t/* only type requested */\n\t}\n\tif (ifr->ifr_settings.size < sizeof (sync)) {\n\t\treturn -ENOMEM;\n\t}\n\n\ti = port->index;\n\tsync.clock_rate = FST_RDL(card, portConfig[i].lineSpeed);\n\t/* Lucky card and linux use same encoding here */\n\tsync.clock_type = FST_RDB(card, portConfig[i].internalClock) ==\n\t    INTCLK ? CLOCK_INT : CLOCK_EXT;\n\tsync.loopback = 0;\n\n\tif (copy_to_user(ifr->ifr_settings.ifs_ifsu.sync, &sync, sizeof (sync))) {\n\t\treturn -EFAULT;\n\t}\n\n\tifr->ifr_settings.size = sizeof (sync);\n\treturn 0;\n}\n\nstatic int\nfst_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tstruct fst_card_info *card;\n\tstruct fst_port_info *port;\n\tstruct fstioc_write wrthdr;\n\tstruct fstioc_info info;\n\tunsigned long flags;\n\tvoid *buf;\n\n\tdbg(DBG_IOCTL, \"ioctl: %x, %p\\n\", cmd, ifr->ifr_data);\n\n\tport = dev_to_port(dev);\n\tcard = port->card;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase FSTCPURESET:\n\t\tfst_cpureset(card);\n\t\tcard->state = FST_RESET;\n\t\treturn 0;\n\n\tcase FSTCPURELEASE:\n\t\tfst_cpurelease(card);\n\t\tcard->state = FST_STARTING;\n\t\treturn 0;\n\n\tcase FSTWRITE:\t\t/* Code write (download) */\n\n\t\t/* First copy in the header with the length and offset of data\n\t\t * to write\n\t\t */\n\t\tif (ifr->ifr_data == NULL) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (copy_from_user(&wrthdr, ifr->ifr_data,\n\t\t\t\t   sizeof (struct fstioc_write))) {\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t/* Sanity check the parameters. We don't support partial writes\n\t\t * when going over the top\n\t\t */\n\t\tif (wrthdr.size > FST_MEMSIZE || wrthdr.offset > FST_MEMSIZE ||\n\t\t    wrthdr.size + wrthdr.offset > FST_MEMSIZE) {\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t\t/* Now copy the data to the card. */\n\n\t\tbuf = memdup_user(ifr->ifr_data + sizeof(struct fstioc_write),\n\t\t\t\t  wrthdr.size);\n\t\tif (IS_ERR(buf))\n\t\t\treturn PTR_ERR(buf);\n\n\t\tmemcpy_toio(card->mem + wrthdr.offset, buf, wrthdr.size);\n\t\tkfree(buf);\n\n\t\t/* Writes to the memory of a card in the reset state constitute\n\t\t * a download\n\t\t */\n\t\tif (card->state == FST_RESET) {\n\t\t\tcard->state = FST_DOWNLOAD;\n\t\t}\n\t\treturn 0;\n\n\tcase FSTGETCONF:\n\n\t\t/* If card has just been started check the shared memory config\n\t\t * version and marker\n\t\t */\n\t\tif (card->state == FST_STARTING) {\n\t\t\tcheck_started_ok(card);\n\n\t\t\t/* If everything checked out enable card interrupts */\n\t\t\tif (card->state == FST_RUNNING) {\n\t\t\t\tspin_lock_irqsave(&card->card_lock, flags);\n\t\t\t\tfst_enable_intr(card);\n\t\t\t\tFST_WRB(card, interruptHandshake, 0xEE);\n\t\t\t\tspin_unlock_irqrestore(&card->card_lock, flags);\n\t\t\t}\n\t\t}\n\n\t\tif (ifr->ifr_data == NULL) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tgather_conf_info(card, port, &info);\n\n\t\tif (copy_to_user(ifr->ifr_data, &info, sizeof (info))) {\n\t\t\treturn -EFAULT;\n\t\t}\n\t\treturn 0;\n\n\tcase FSTSETCONF:\n\n\t\t/*\n\t\t * Most of the settings have been moved to the generic ioctls\n\t\t * this just covers debug and board ident now\n\t\t */\n\n\t\tif (card->state != FST_RUNNING) {\n\t\t\tpr_err(\"Attempt to configure card %d in non-running state (%d)\\n\",\n\t\t\t       card->card_no, card->state);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (copy_from_user(&info, ifr->ifr_data, sizeof (info))) {\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\treturn set_conf_from_info(card, port, &info);\n\n\tcase SIOCWANDEV:\n\t\tswitch (ifr->ifr_settings.type) {\n\t\tcase IF_GET_IFACE:\n\t\t\treturn fst_get_iface(card, port, ifr);\n\n\t\tcase IF_IFACE_SYNC_SERIAL:\n\t\tcase IF_IFACE_V35:\n\t\tcase IF_IFACE_V24:\n\t\tcase IF_IFACE_X21:\n\t\tcase IF_IFACE_X21D:\n\t\tcase IF_IFACE_T1:\n\t\tcase IF_IFACE_E1:\n\t\t\treturn fst_set_iface(card, port, ifr);\n\n\t\tcase IF_PROTO_RAW:\n\t\t\tport->mode = FST_RAW;\n\t\t\treturn 0;\n\n\t\tcase IF_GET_PROTO:\n\t\t\tif (port->mode == FST_RAW) {\n\t\t\t\tifr->ifr_settings.type = IF_PROTO_RAW;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn hdlc_ioctl(dev, ifr, cmd);\n\n\t\tdefault:\n\t\t\tport->mode = FST_GEN_HDLC;\n\t\t\tdbg(DBG_IOCTL, \"Passing this type to hdlc %x\\n\",\n\t\t\t    ifr->ifr_settings.type);\n\t\t\treturn hdlc_ioctl(dev, ifr, cmd);\n\t\t}\n\n\tdefault:\n\t\t/* Not one of ours. Pass through to HDLC package */\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n\t}\n}\n\nstatic void\nfst_openport(struct fst_port_info *port)\n{\n\tint signals;\n\tint txq_length;\n\n\t/* Only init things if card is actually running. This allows open to\n\t * succeed for downloads etc.\n\t */\n\tif (port->card->state == FST_RUNNING) {\n\t\tif (port->run) {\n\t\t\tdbg(DBG_OPEN, \"open: found port already running\\n\");\n\n\t\t\tfst_issue_cmd(port, STOPPORT);\n\t\t\tport->run = 0;\n\t\t}\n\n\t\tfst_rx_config(port);\n\t\tfst_tx_config(port);\n\t\tfst_op_raise(port, OPSTS_RTS | OPSTS_DTR);\n\n\t\tfst_issue_cmd(port, STARTPORT);\n\t\tport->run = 1;\n\n\t\tsignals = FST_RDL(port->card, v24DebouncedSts[port->index]);\n\t\tif (signals & (((port->hwif == X21) || (port->hwif == X21D))\n\t\t\t       ? IPSTS_INDICATE : IPSTS_DCD))\n\t\t\tnetif_carrier_on(port_to_dev(port));\n\t\telse\n\t\t\tnetif_carrier_off(port_to_dev(port));\n\n\t\ttxq_length = port->txqe - port->txqs;\n\t\tport->txqe = 0;\n\t\tport->txqs = 0;\n\t}\n\n}\n\nstatic void\nfst_closeport(struct fst_port_info *port)\n{\n\tif (port->card->state == FST_RUNNING) {\n\t\tif (port->run) {\n\t\t\tport->run = 0;\n\t\t\tfst_op_lower(port, OPSTS_RTS | OPSTS_DTR);\n\n\t\t\tfst_issue_cmd(port, STOPPORT);\n\t\t} else {\n\t\t\tdbg(DBG_OPEN, \"close: port not running\\n\");\n\t\t}\n\t}\n}\n\nstatic int\nfst_open(struct net_device *dev)\n{\n\tint err;\n\tstruct fst_port_info *port;\n\n\tport = dev_to_port(dev);\n\tif (!try_module_get(THIS_MODULE))\n          return -EBUSY;\n\n\tif (port->mode != FST_RAW) {\n\t\terr = hdlc_open(dev);\n\t\tif (err) {\n\t\t\tmodule_put(THIS_MODULE);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tfst_openport(port);\n\tnetif_wake_queue(dev);\n\treturn 0;\n}\n\nstatic int\nfst_close(struct net_device *dev)\n{\n\tstruct fst_port_info *port;\n\tstruct fst_card_info *card;\n\tunsigned char tx_dma_done;\n\tunsigned char rx_dma_done;\n\n\tport = dev_to_port(dev);\n\tcard = port->card;\n\n\ttx_dma_done = inb(card->pci_conf + DMACSR1);\n\trx_dma_done = inb(card->pci_conf + DMACSR0);\n\tdbg(DBG_OPEN,\n\t    \"Port Close: tx_dma_in_progress = %d (%x) rx_dma_in_progress = %d (%x)\\n\",\n\t    card->dmatx_in_progress, tx_dma_done, card->dmarx_in_progress,\n\t    rx_dma_done);\n\n\tnetif_stop_queue(dev);\n\tfst_closeport(dev_to_port(dev));\n\tif (port->mode != FST_RAW) {\n\t\thdlc_close(dev);\n\t}\n\tmodule_put(THIS_MODULE);\n\treturn 0;\n}\n\nstatic int\nfst_attach(struct net_device *dev, unsigned short encoding, unsigned short parity)\n{\n\t/*\n\t * Setting currently fixed in FarSync card so we check and forget\n\t */\n\tif (encoding != ENCODING_NRZ || parity != PARITY_CRC16_PR1_CCITT)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic void\nfst_tx_timeout(struct net_device *dev)\n{\n\tstruct fst_port_info *port;\n\tstruct fst_card_info *card;\n\n\tport = dev_to_port(dev);\n\tcard = port->card;\n\tdev->stats.tx_errors++;\n\tdev->stats.tx_aborted_errors++;\n\tdbg(DBG_ASS, \"Tx timeout card %d port %d\\n\",\n\t    card->card_no, port->index);\n\tfst_issue_cmd(port, ABORTTX);\n\n\tdev->trans_start = jiffies;\n\tnetif_wake_queue(dev);\n\tport->start = 0;\n}\n\nstatic netdev_tx_t\nfst_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct fst_card_info *card;\n\tstruct fst_port_info *port;\n\tunsigned long flags;\n\tint txq_length;\n\n\tport = dev_to_port(dev);\n\tcard = port->card;\n\tdbg(DBG_TX, \"fst_start_xmit: length = %d\\n\", skb->len);\n\n\t/* Drop packet with error if we don't have carrier */\n\tif (!netif_carrier_ok(dev)) {\n\t\tdev_kfree_skb(skb);\n\t\tdev->stats.tx_errors++;\n\t\tdev->stats.tx_carrier_errors++;\n\t\tdbg(DBG_ASS,\n\t\t    \"Tried to transmit but no carrier on card %d port %d\\n\",\n\t\t    card->card_no, port->index);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t/* Drop it if it's too big! MTU failure ? */\n\tif (skb->len > LEN_TX_BUFFER) {\n\t\tdbg(DBG_ASS, \"Packet too large %d vs %d\\n\", skb->len,\n\t\t    LEN_TX_BUFFER);\n\t\tdev_kfree_skb(skb);\n\t\tdev->stats.tx_errors++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t/*\n\t * We are always going to queue the packet\n\t * so that the bottom half is the only place we tx from\n\t * Check there is room in the port txq\n\t */\n\tspin_lock_irqsave(&card->card_lock, flags);\n\tif ((txq_length = port->txqe - port->txqs) < 0) {\n\t\t/*\n\t\t * This is the case where the next free has wrapped but the\n\t\t * last used hasn't\n\t\t */\n\t\ttxq_length = txq_length + FST_TXQ_DEPTH;\n\t}\n\tspin_unlock_irqrestore(&card->card_lock, flags);\n\tif (txq_length > fst_txq_high) {\n\t\t/*\n\t\t * We have got enough buffers in the pipeline.  Ask the network\n\t\t * layer to stop sending frames down\n\t\t */\n\t\tnetif_stop_queue(dev);\n\t\tport->start = 1;\t/* I'm using this to signal stop sent up */\n\t}\n\n\tif (txq_length == FST_TXQ_DEPTH - 1) {\n\t\t/*\n\t\t * This shouldn't have happened but such is life\n\t\t */\n\t\tdev_kfree_skb(skb);\n\t\tdev->stats.tx_errors++;\n\t\tdbg(DBG_ASS, \"Tx queue overflow card %d port %d\\n\",\n\t\t    card->card_no, port->index);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t/*\n\t * queue the buffer\n\t */\n\tspin_lock_irqsave(&card->card_lock, flags);\n\tport->txq[port->txqe] = skb;\n\tport->txqe++;\n\tif (port->txqe == FST_TXQ_DEPTH)\n\t\tport->txqe = 0;\n\tspin_unlock_irqrestore(&card->card_lock, flags);\n\n\t/* Scehdule the bottom half which now does transmit processing */\n\tfst_q_work_item(&fst_work_txq, card->card_no);\n\ttasklet_schedule(&fst_tx_task);\n\n\treturn NETDEV_TX_OK;\n}\n\n/*\n *      Card setup having checked hardware resources.\n *      Should be pretty bizarre if we get an error here (kernel memory\n *      exhaustion is one possibility). If we do see a problem we report it\n *      via a printk and leave the corresponding interface and all that follow\n *      disabled.\n */\nstatic char *type_strings[] = {\n\t\"no hardware\",\t\t/* Should never be seen */\n\t\"FarSync T2P\",\n\t\"FarSync T4P\",\n\t\"FarSync T1U\",\n\t\"FarSync T2U\",\n\t\"FarSync T4U\",\n\t\"FarSync TE1\"\n};\n\nstatic void\nfst_init_card(struct fst_card_info *card)\n{\n\tint i;\n\tint err;\n\n\t/* We're working on a number of ports based on the card ID. If the\n\t * firmware detects something different later (should never happen)\n\t * we'll have to revise it in some way then.\n\t */\n\tfor (i = 0; i < card->nports; i++) {\n                err = register_hdlc_device(card->ports[i].dev);\n                if (err < 0) {\n\t\t\tint j;\n\t\t\tpr_err(\"Cannot register HDLC device for port %d (errno %d)\\n\",\n\t\t\t       i, -err);\n\t\t\tfor (j = i; j < card->nports; j++) {\n\t\t\t\tfree_netdev(card->ports[j].dev);\n\t\t\t\tcard->ports[j].dev = NULL;\n\t\t\t}\n                        card->nports = i;\n                        break;\n                }\n\t}\n\n\tpr_info(\"%s-%s: %s IRQ%d, %d ports\\n\",\n\t\tport_to_dev(&card->ports[0])->name,\n\t\tport_to_dev(&card->ports[card->nports - 1])->name,\n\t\ttype_strings[card->type], card->irq, card->nports);\n}\n\nstatic const struct net_device_ops fst_ops = {\n\t.ndo_open       = fst_open,\n\t.ndo_stop       = fst_close,\n\t.ndo_change_mtu = hdlc_change_mtu,\n\t.ndo_start_xmit = hdlc_start_xmit,\n\t.ndo_do_ioctl   = fst_ioctl,\n\t.ndo_tx_timeout = fst_tx_timeout,\n};\n\n/*\n *      Initialise card when detected.\n *      Returns 0 to indicate success, or errno otherwise.\n */\nstatic int\nfst_add_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstatic int no_of_cards_added = 0;\n\tstruct fst_card_info *card;\n\tint err = 0;\n\tint i;\n\n\tprintk_once(KERN_INFO\n\t\t    pr_fmt(\"FarSync WAN driver \" FST_USER_VERSION\n\t\t\t   \" (c) 2001-2004 FarSite Communications Ltd.\\n\"));\n#if FST_DEBUG\n\tdbg(DBG_ASS, \"The value of debug mask is %x\\n\", fst_debug_mask);\n#endif\n\t/*\n\t * We are going to be clever and allow certain cards not to be\n\t * configured.  An exclude list can be provided in /etc/modules.conf\n\t */\n\tif (fst_excluded_cards != 0) {\n\t\t/*\n\t\t * There are cards to exclude\n\t\t *\n\t\t */\n\t\tfor (i = 0; i < fst_excluded_cards; i++) {\n\t\t\tif ((pdev->devfn) >> 3 == fst_excluded_list[i]) {\n\t\t\t\tpr_info(\"FarSync PCI device %d not assigned\\n\",\n\t\t\t\t\t(pdev->devfn) >> 3);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Allocate driver private data */\n\tcard = kzalloc(sizeof(struct fst_card_info), GFP_KERNEL);\n\tif (card == NULL)\n\t\treturn -ENOMEM;\n\n\t/* Try to enable the device */\n\tif ((err = pci_enable_device(pdev)) != 0) {\n\t\tpr_err(\"Failed to enable card. Err %d\\n\", -err);\n\t\tkfree(card);\n\t\treturn err;\n\t}\n\n\tif ((err = pci_request_regions(pdev, \"FarSync\")) !=0) {\n\t\tpr_err(\"Failed to allocate regions. Err %d\\n\", -err);\n\t\tpci_disable_device(pdev);\n\t\tkfree(card);\n\t        return err;\n\t}\n\n\t/* Get virtual addresses of memory regions */\n\tcard->pci_conf = pci_resource_start(pdev, 1);\n\tcard->phys_mem = pci_resource_start(pdev, 2);\n\tcard->phys_ctlmem = pci_resource_start(pdev, 3);\n\tif ((card->mem = ioremap(card->phys_mem, FST_MEMSIZE)) == NULL) {\n\t\tpr_err(\"Physical memory remap failed\\n\");\n\t\tpci_release_regions(pdev);\n\t\tpci_disable_device(pdev);\n\t\tkfree(card);\n\t\treturn -ENODEV;\n\t}\n\tif ((card->ctlmem = ioremap(card->phys_ctlmem, 0x10)) == NULL) {\n\t\tpr_err(\"Control memory remap failed\\n\");\n\t\tpci_release_regions(pdev);\n\t\tpci_disable_device(pdev);\n\t\tiounmap(card->mem);\n\t\tkfree(card);\n\t\treturn -ENODEV;\n\t}\n\tdbg(DBG_PCI, \"kernel mem %p, ctlmem %p\\n\", card->mem, card->ctlmem);\n\n\t/* Register the interrupt handler */\n\tif (request_irq(pdev->irq, fst_intr, IRQF_SHARED, FST_DEV_NAME, card)) {\n\t\tpr_err(\"Unable to register interrupt %d\\n\", card->irq);\n\t\tpci_release_regions(pdev);\n\t\tpci_disable_device(pdev);\n\t\tiounmap(card->ctlmem);\n\t\tiounmap(card->mem);\n\t\tkfree(card);\n\t\treturn -ENODEV;\n\t}\n\n\t/* Record info we need */\n\tcard->irq = pdev->irq;\n\tcard->type = ent->driver_data;\n\tcard->family = ((ent->driver_data == FST_TYPE_T2P) ||\n\t\t\t(ent->driver_data == FST_TYPE_T4P))\n\t    ? FST_FAMILY_TXP : FST_FAMILY_TXU;\n\tif ((ent->driver_data == FST_TYPE_T1U) ||\n\t    (ent->driver_data == FST_TYPE_TE1))\n\t\tcard->nports = 1;\n\telse\n\t\tcard->nports = ((ent->driver_data == FST_TYPE_T2P) ||\n\t\t\t\t(ent->driver_data == FST_TYPE_T2U)) ? 2 : 4;\n\n\tcard->state = FST_UNINIT;\n        spin_lock_init ( &card->card_lock );\n\n        for ( i = 0 ; i < card->nports ; i++ ) {\n\t\tstruct net_device *dev = alloc_hdlcdev(&card->ports[i]);\n\t\thdlc_device *hdlc;\n\t\tif (!dev) {\n\t\t\twhile (i--)\n\t\t\t\tfree_netdev(card->ports[i].dev);\n\t\t\tpr_err(\"FarSync: out of memory\\n\");\n                        free_irq(card->irq, card);\n                        pci_release_regions(pdev);\n                        pci_disable_device(pdev);\n                        iounmap(card->ctlmem);\n                        iounmap(card->mem);\n                        kfree(card);\n                        return -ENODEV;\n\t\t}\n\t\tcard->ports[i].dev    = dev;\n                card->ports[i].card   = card;\n                card->ports[i].index  = i;\n                card->ports[i].run    = 0;\n\n\t\thdlc = dev_to_hdlc(dev);\n\n                /* Fill in the net device info */\n\t\t/* Since this is a PCI setup this is purely\n\t\t * informational. Give them the buffer addresses\n\t\t * and basic card I/O.\n\t\t */\n                dev->mem_start   = card->phys_mem\n                                 + BUF_OFFSET ( txBuffer[i][0][0]);\n                dev->mem_end     = card->phys_mem\n                                 + BUF_OFFSET ( txBuffer[i][NUM_TX_BUFFER][0]);\n                dev->base_addr   = card->pci_conf;\n                dev->irq         = card->irq;\n\n\t\tdev->netdev_ops = &fst_ops;\n\t\tdev->tx_queue_len = FST_TX_QUEUE_LEN;\n\t\tdev->watchdog_timeo = FST_TX_TIMEOUT;\n                hdlc->attach = fst_attach;\n                hdlc->xmit   = fst_start_xmit;\n\t}\n\n\tcard->device = pdev;\n\n\tdbg(DBG_PCI, \"type %d nports %d irq %d\\n\", card->type,\n\t    card->nports, card->irq);\n\tdbg(DBG_PCI, \"conf %04x mem %08x ctlmem %08x\\n\",\n\t    card->pci_conf, card->phys_mem, card->phys_ctlmem);\n\n\t/* Reset the card's processor */\n\tfst_cpureset(card);\n\tcard->state = FST_RESET;\n\n\t/* Initialise DMA (if required) */\n\tfst_init_dma(card);\n\n\t/* Record driver data for later use */\n\tpci_set_drvdata(pdev, card);\n\n\t/* Remainder of card setup */\n\tfst_card_array[no_of_cards_added] = card;\n\tcard->card_no = no_of_cards_added++;\t/* Record instance and bump it */\n\tfst_init_card(card);\n\tif (card->family == FST_FAMILY_TXU) {\n\t\t/*\n\t\t * Allocate a dma buffer for transmit and receives\n\t\t */\n\t\tcard->rx_dma_handle_host =\n\t\t    pci_alloc_consistent(card->device, FST_MAX_MTU,\n\t\t\t\t\t &card->rx_dma_handle_card);\n\t\tif (card->rx_dma_handle_host == NULL) {\n\t\t\tpr_err(\"Could not allocate rx dma buffer\\n\");\n\t\t\tfst_disable_intr(card);\n\t\t\tpci_release_regions(pdev);\n\t\t\tpci_disable_device(pdev);\n\t\t\tiounmap(card->ctlmem);\n\t\t\tiounmap(card->mem);\n\t\t\tkfree(card);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tcard->tx_dma_handle_host =\n\t\t    pci_alloc_consistent(card->device, FST_MAX_MTU,\n\t\t\t\t\t &card->tx_dma_handle_card);\n\t\tif (card->tx_dma_handle_host == NULL) {\n\t\t\tpr_err(\"Could not allocate tx dma buffer\\n\");\n\t\t\tfst_disable_intr(card);\n\t\t\tpci_release_regions(pdev);\n\t\t\tpci_disable_device(pdev);\n\t\t\tiounmap(card->ctlmem);\n\t\t\tiounmap(card->mem);\n\t\t\tkfree(card);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\t\t/* Success */\n}\n\n/*\n *      Cleanup and close down a card\n */\nstatic void\nfst_remove_one(struct pci_dev *pdev)\n{\n\tstruct fst_card_info *card;\n\tint i;\n\n\tcard = pci_get_drvdata(pdev);\n\n\tfor (i = 0; i < card->nports; i++) {\n\t\tstruct net_device *dev = port_to_dev(&card->ports[i]);\n\t\tunregister_hdlc_device(dev);\n\t}\n\n\tfst_disable_intr(card);\n\tfree_irq(card->irq, card);\n\n\tiounmap(card->ctlmem);\n\tiounmap(card->mem);\n\tpci_release_regions(pdev);\n\tif (card->family == FST_FAMILY_TXU) {\n\t\t/*\n\t\t * Free dma buffers\n\t\t */\n\t\tpci_free_consistent(card->device, FST_MAX_MTU,\n\t\t\t\t    card->rx_dma_handle_host,\n\t\t\t\t    card->rx_dma_handle_card);\n\t\tpci_free_consistent(card->device, FST_MAX_MTU,\n\t\t\t\t    card->tx_dma_handle_host,\n\t\t\t\t    card->tx_dma_handle_card);\n\t}\n\tfst_card_array[card->card_no] = NULL;\n}\n\nstatic struct pci_driver fst_driver = {\n        .name\t\t= FST_NAME,\n        .id_table\t= fst_pci_dev_id,\n        .probe\t\t= fst_add_one,\n        .remove\t= fst_remove_one,\n        .suspend\t= NULL,\n        .resume\t= NULL,\n};\n\nstatic int __init\nfst_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < FST_MAX_CARDS; i++)\n\t\tfst_card_array[i] = NULL;\n\tspin_lock_init(&fst_work_q_lock);\n\treturn pci_register_driver(&fst_driver);\n}\n\nstatic void __exit\nfst_cleanup_module(void)\n{\n\tpr_info(\"FarSync WAN driver unloading\\n\");\n\tpci_unregister_driver(&fst_driver);\n}\n\nmodule_init(fst_init);\nmodule_exit(fst_cleanup_module);\n"], "fixing_code": ["/*\n *      FarSync WAN driver for Linux (2.6.x kernel version)\n *\n *      Actually sync driver for X.21, V.35 and V.24 on FarSync T-series cards\n *\n *      Copyright (C) 2001-2004 FarSite Communications Ltd.\n *      www.farsite.co.uk\n *\n *      This program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n *\n *      Author:      R.J.Dunlop    <bob.dunlop@farsite.co.uk>\n *      Maintainer:  Kevin Curtis  <kevin.curtis@farsite.co.uk>\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/pci.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/if.h>\n#include <linux/hdlc.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n\n#include \"farsync.h\"\n\n/*\n *      Module info\n */\nMODULE_AUTHOR(\"R.J.Dunlop <bob.dunlop@farsite.co.uk>\");\nMODULE_DESCRIPTION(\"FarSync T-Series WAN driver. FarSite Communications Ltd.\");\nMODULE_LICENSE(\"GPL\");\n\n/*      Driver configuration and global parameters\n *      ==========================================\n */\n\n/*      Number of ports (per card) and cards supported\n */\n#define FST_MAX_PORTS           4\n#define FST_MAX_CARDS           32\n\n/*      Default parameters for the link\n */\n#define FST_TX_QUEUE_LEN        100\t/* At 8Mbps a longer queue length is\n\t\t\t\t\t * useful */\n#define FST_TXQ_DEPTH           16\t/* This one is for the buffering\n\t\t\t\t\t * of frames on the way down to the card\n\t\t\t\t\t * so that we can keep the card busy\n\t\t\t\t\t * and maximise throughput\n\t\t\t\t\t */\n#define FST_HIGH_WATER_MARK     12\t/* Point at which we flow control\n\t\t\t\t\t * network layer */\n#define FST_LOW_WATER_MARK      8\t/* Point at which we remove flow\n\t\t\t\t\t * control from network layer */\n#define FST_MAX_MTU             8000\t/* Huge but possible */\n#define FST_DEF_MTU             1500\t/* Common sane value */\n\n#define FST_TX_TIMEOUT          (2*HZ)\n\n#ifdef ARPHRD_RAWHDLC\n#define ARPHRD_MYTYPE   ARPHRD_RAWHDLC\t/* Raw frames */\n#else\n#define ARPHRD_MYTYPE   ARPHRD_HDLC\t/* Cisco-HDLC (keepalives etc) */\n#endif\n\n/*\n * Modules parameters and associated variables\n */\nstatic int fst_txq_low = FST_LOW_WATER_MARK;\nstatic int fst_txq_high = FST_HIGH_WATER_MARK;\nstatic int fst_max_reads = 7;\nstatic int fst_excluded_cards = 0;\nstatic int fst_excluded_list[FST_MAX_CARDS];\n\nmodule_param(fst_txq_low, int, 0);\nmodule_param(fst_txq_high, int, 0);\nmodule_param(fst_max_reads, int, 0);\nmodule_param(fst_excluded_cards, int, 0);\nmodule_param_array(fst_excluded_list, int, NULL, 0);\n\n/*      Card shared memory layout\n *      =========================\n */\n#pragma pack(1)\n\n/*      This information is derived in part from the FarSite FarSync Smc.h\n *      file. Unfortunately various name clashes and the non-portability of the\n *      bit field declarations in that file have meant that I have chosen to\n *      recreate the information here.\n *\n *      The SMC (Shared Memory Configuration) has a version number that is\n *      incremented every time there is a significant change. This number can\n *      be used to check that we have not got out of step with the firmware\n *      contained in the .CDE files.\n */\n#define SMC_VERSION 24\n\n#define FST_MEMSIZE 0x100000\t/* Size of card memory (1Mb) */\n\n#define SMC_BASE 0x00002000L\t/* Base offset of the shared memory window main\n\t\t\t\t * configuration structure */\n#define BFM_BASE 0x00010000L\t/* Base offset of the shared memory window DMA\n\t\t\t\t * buffers */\n\n#define LEN_TX_BUFFER 8192\t/* Size of packet buffers */\n#define LEN_RX_BUFFER 8192\n\n#define LEN_SMALL_TX_BUFFER 256\t/* Size of obsolete buffs used for DOS diags */\n#define LEN_SMALL_RX_BUFFER 256\n\n#define NUM_TX_BUFFER 2\t\t/* Must be power of 2. Fixed by firmware */\n#define NUM_RX_BUFFER 8\n\n/* Interrupt retry time in milliseconds */\n#define INT_RETRY_TIME 2\n\n/*      The Am186CH/CC processors support a SmartDMA mode using circular pools\n *      of buffer descriptors. The structure is almost identical to that used\n *      in the LANCE Ethernet controllers. Details available as PDF from the\n *      AMD web site: http://www.amd.com/products/epd/processors/\\\n *                    2.16bitcont/3.am186cxfa/a21914/21914.pdf\n */\nstruct txdesc {\t\t\t/* Transmit descriptor */\n\tvolatile u16 ladr;\t/* Low order address of packet. This is a\n\t\t\t\t * linear address in the Am186 memory space\n\t\t\t\t */\n\tvolatile u8 hadr;\t/* High order address. Low 4 bits only, high 4\n\t\t\t\t * bits must be zero\n\t\t\t\t */\n\tvolatile u8 bits;\t/* Status and config */\n\tvolatile u16 bcnt;\t/* 2s complement of packet size in low 15 bits.\n\t\t\t\t * Transmit terminal count interrupt enable in\n\t\t\t\t * top bit.\n\t\t\t\t */\n\tu16 unused;\t\t/* Not used in Tx */\n};\n\nstruct rxdesc {\t\t\t/* Receive descriptor */\n\tvolatile u16 ladr;\t/* Low order address of packet */\n\tvolatile u8 hadr;\t/* High order address */\n\tvolatile u8 bits;\t/* Status and config */\n\tvolatile u16 bcnt;\t/* 2s complement of buffer size in low 15 bits.\n\t\t\t\t * Receive terminal count interrupt enable in\n\t\t\t\t * top bit.\n\t\t\t\t */\n\tvolatile u16 mcnt;\t/* Message byte count (15 bits) */\n};\n\n/* Convert a length into the 15 bit 2's complement */\n/* #define cnv_bcnt(len)   (( ~(len) + 1 ) & 0x7FFF ) */\n/* Since we need to set the high bit to enable the completion interrupt this\n * can be made a lot simpler\n */\n#define cnv_bcnt(len)   (-(len))\n\n/* Status and config bits for the above */\n#define DMA_OWN         0x80\t/* SmartDMA owns the descriptor */\n#define TX_STP          0x02\t/* Tx: start of packet */\n#define TX_ENP          0x01\t/* Tx: end of packet */\n#define RX_ERR          0x40\t/* Rx: error (OR of next 4 bits) */\n#define RX_FRAM         0x20\t/* Rx: framing error */\n#define RX_OFLO         0x10\t/* Rx: overflow error */\n#define RX_CRC          0x08\t/* Rx: CRC error */\n#define RX_HBUF         0x04\t/* Rx: buffer error */\n#define RX_STP          0x02\t/* Rx: start of packet */\n#define RX_ENP          0x01\t/* Rx: end of packet */\n\n/* Interrupts from the card are caused by various events which are presented\n * in a circular buffer as several events may be processed on one physical int\n */\n#define MAX_CIRBUFF     32\n\nstruct cirbuff {\n\tu8 rdindex;\t\t/* read, then increment and wrap */\n\tu8 wrindex;\t\t/* write, then increment and wrap */\n\tu8 evntbuff[MAX_CIRBUFF];\n};\n\n/* Interrupt event codes.\n * Where appropriate the two low order bits indicate the port number\n */\n#define CTLA_CHG        0x18\t/* Control signal changed */\n#define CTLB_CHG        0x19\n#define CTLC_CHG        0x1A\n#define CTLD_CHG        0x1B\n\n#define INIT_CPLT       0x20\t/* Initialisation complete */\n#define INIT_FAIL       0x21\t/* Initialisation failed */\n\n#define ABTA_SENT       0x24\t/* Abort sent */\n#define ABTB_SENT       0x25\n#define ABTC_SENT       0x26\n#define ABTD_SENT       0x27\n\n#define TXA_UNDF        0x28\t/* Transmission underflow */\n#define TXB_UNDF        0x29\n#define TXC_UNDF        0x2A\n#define TXD_UNDF        0x2B\n\n#define F56_INT         0x2C\n#define M32_INT         0x2D\n\n#define TE1_ALMA        0x30\n\n/* Port physical configuration. See farsync.h for field values */\nstruct port_cfg {\n\tu16 lineInterface;\t/* Physical interface type */\n\tu8 x25op;\t\t/* Unused at present */\n\tu8 internalClock;\t/* 1 => internal clock, 0 => external */\n\tu8 transparentMode;\t/* 1 => on, 0 => off */\n\tu8 invertClock;\t\t/* 0 => normal, 1 => inverted */\n\tu8 padBytes[6];\t\t/* Padding */\n\tu32 lineSpeed;\t\t/* Speed in bps */\n};\n\n/* TE1 port physical configuration */\nstruct su_config {\n\tu32 dataRate;\n\tu8 clocking;\n\tu8 framing;\n\tu8 structure;\n\tu8 interface;\n\tu8 coding;\n\tu8 lineBuildOut;\n\tu8 equalizer;\n\tu8 transparentMode;\n\tu8 loopMode;\n\tu8 range;\n\tu8 txBufferMode;\n\tu8 rxBufferMode;\n\tu8 startingSlot;\n\tu8 losThreshold;\n\tu8 enableIdleCode;\n\tu8 idleCode;\n\tu8 spare[44];\n};\n\n/* TE1 Status */\nstruct su_status {\n\tu32 receiveBufferDelay;\n\tu32 framingErrorCount;\n\tu32 codeViolationCount;\n\tu32 crcErrorCount;\n\tu32 lineAttenuation;\n\tu8 portStarted;\n\tu8 lossOfSignal;\n\tu8 receiveRemoteAlarm;\n\tu8 alarmIndicationSignal;\n\tu8 spare[40];\n};\n\n/* Finally sling all the above together into the shared memory structure.\n * Sorry it's a hodge podge of arrays, structures and unused bits, it's been\n * evolving under NT for some time so I guess we're stuck with it.\n * The structure starts at offset SMC_BASE.\n * See farsync.h for some field values.\n */\nstruct fst_shared {\n\t/* DMA descriptor rings */\n\tstruct rxdesc rxDescrRing[FST_MAX_PORTS][NUM_RX_BUFFER];\n\tstruct txdesc txDescrRing[FST_MAX_PORTS][NUM_TX_BUFFER];\n\n\t/* Obsolete small buffers */\n\tu8 smallRxBuffer[FST_MAX_PORTS][NUM_RX_BUFFER][LEN_SMALL_RX_BUFFER];\n\tu8 smallTxBuffer[FST_MAX_PORTS][NUM_TX_BUFFER][LEN_SMALL_TX_BUFFER];\n\n\tu8 taskStatus;\t\t/* 0x00 => initialising, 0x01 => running,\n\t\t\t\t * 0xFF => halted\n\t\t\t\t */\n\n\tu8 interruptHandshake;\t/* Set to 0x01 by adapter to signal interrupt,\n\t\t\t\t * set to 0xEE by host to acknowledge interrupt\n\t\t\t\t */\n\n\tu16 smcVersion;\t\t/* Must match SMC_VERSION */\n\n\tu32 smcFirmwareVersion;\t/* 0xIIVVRRBB where II = product ID, VV = major\n\t\t\t\t * version, RR = revision and BB = build\n\t\t\t\t */\n\n\tu16 txa_done;\t\t/* Obsolete completion flags */\n\tu16 rxa_done;\n\tu16 txb_done;\n\tu16 rxb_done;\n\tu16 txc_done;\n\tu16 rxc_done;\n\tu16 txd_done;\n\tu16 rxd_done;\n\n\tu16 mailbox[4];\t\t/* Diagnostics mailbox. Not used */\n\n\tstruct cirbuff interruptEvent;\t/* interrupt causes */\n\n\tu32 v24IpSts[FST_MAX_PORTS];\t/* V.24 control input status */\n\tu32 v24OpSts[FST_MAX_PORTS];\t/* V.24 control output status */\n\n\tstruct port_cfg portConfig[FST_MAX_PORTS];\n\n\tu16 clockStatus[FST_MAX_PORTS];\t/* lsb: 0=> present, 1=> absent */\n\n\tu16 cableStatus;\t/* lsb: 0=> present, 1=> absent */\n\n\tu16 txDescrIndex[FST_MAX_PORTS];\t/* transmit descriptor ring index */\n\tu16 rxDescrIndex[FST_MAX_PORTS];\t/* receive descriptor ring index */\n\n\tu16 portMailbox[FST_MAX_PORTS][2];\t/* command, modifier */\n\tu16 cardMailbox[4];\t/* Not used */\n\n\t/* Number of times the card thinks the host has\n\t * missed an interrupt by not acknowledging\n\t * within 2mS (I guess NT has problems)\n\t */\n\tu32 interruptRetryCount;\n\n\t/* Driver private data used as an ID. We'll not\n\t * use this as I'd rather keep such things\n\t * in main memory rather than on the PCI bus\n\t */\n\tu32 portHandle[FST_MAX_PORTS];\n\n\t/* Count of Tx underflows for stats */\n\tu32 transmitBufferUnderflow[FST_MAX_PORTS];\n\n\t/* Debounced V.24 control input status */\n\tu32 v24DebouncedSts[FST_MAX_PORTS];\n\n\t/* Adapter debounce timers. Don't touch */\n\tu32 ctsTimer[FST_MAX_PORTS];\n\tu32 ctsTimerRun[FST_MAX_PORTS];\n\tu32 dcdTimer[FST_MAX_PORTS];\n\tu32 dcdTimerRun[FST_MAX_PORTS];\n\n\tu32 numberOfPorts;\t/* Number of ports detected at startup */\n\n\tu16 _reserved[64];\n\n\tu16 cardMode;\t\t/* Bit-mask to enable features:\n\t\t\t\t * Bit 0: 1 enables LED identify mode\n\t\t\t\t */\n\n\tu16 portScheduleOffset;\n\n\tstruct su_config suConfig;\t/* TE1 Bits */\n\tstruct su_status suStatus;\n\n\tu32 endOfSmcSignature;\t/* endOfSmcSignature MUST be the last member of\n\t\t\t\t * the structure and marks the end of shared\n\t\t\t\t * memory. Adapter code initializes it as\n\t\t\t\t * END_SIG.\n\t\t\t\t */\n};\n\n/* endOfSmcSignature value */\n#define END_SIG                 0x12345678\n\n/* Mailbox values. (portMailbox) */\n#define NOP             0\t/* No operation */\n#define ACK             1\t/* Positive acknowledgement to PC driver */\n#define NAK             2\t/* Negative acknowledgement to PC driver */\n#define STARTPORT       3\t/* Start an HDLC port */\n#define STOPPORT        4\t/* Stop an HDLC port */\n#define ABORTTX         5\t/* Abort the transmitter for a port */\n#define SETV24O         6\t/* Set V24 outputs */\n\n/* PLX Chip Register Offsets */\n#define CNTRL_9052      0x50\t/* Control Register */\n#define CNTRL_9054      0x6c\t/* Control Register */\n\n#define INTCSR_9052     0x4c\t/* Interrupt control/status register */\n#define INTCSR_9054     0x68\t/* Interrupt control/status register */\n\n/* 9054 DMA Registers */\n/*\n * Note that we will be using DMA Channel 0 for copying rx data\n * and Channel 1 for copying tx data\n */\n#define DMAMODE0        0x80\n#define DMAPADR0        0x84\n#define DMALADR0        0x88\n#define DMASIZ0         0x8c\n#define DMADPR0         0x90\n#define DMAMODE1        0x94\n#define DMAPADR1        0x98\n#define DMALADR1        0x9c\n#define DMASIZ1         0xa0\n#define DMADPR1         0xa4\n#define DMACSR0         0xa8\n#define DMACSR1         0xa9\n#define DMAARB          0xac\n#define DMATHR          0xb0\n#define DMADAC0         0xb4\n#define DMADAC1         0xb8\n#define DMAMARBR        0xac\n\n#define FST_MIN_DMA_LEN 64\n#define FST_RX_DMA_INT  0x01\n#define FST_TX_DMA_INT  0x02\n#define FST_CARD_INT    0x04\n\n/* Larger buffers are positioned in memory at offset BFM_BASE */\nstruct buf_window {\n\tu8 txBuffer[FST_MAX_PORTS][NUM_TX_BUFFER][LEN_TX_BUFFER];\n\tu8 rxBuffer[FST_MAX_PORTS][NUM_RX_BUFFER][LEN_RX_BUFFER];\n};\n\n/* Calculate offset of a buffer object within the shared memory window */\n#define BUF_OFFSET(X)   (BFM_BASE + offsetof(struct buf_window, X))\n\n#pragma pack()\n\n/*      Device driver private information\n *      =================================\n */\n/*      Per port (line or channel) information\n */\nstruct fst_port_info {\n        struct net_device *dev; /* Device struct - must be first */\n\tstruct fst_card_info *card;\t/* Card we're associated with */\n\tint index;\t\t/* Port index on the card */\n\tint hwif;\t\t/* Line hardware (lineInterface copy) */\n\tint run;\t\t/* Port is running */\n\tint mode;\t\t/* Normal or FarSync raw */\n\tint rxpos;\t\t/* Next Rx buffer to use */\n\tint txpos;\t\t/* Next Tx buffer to use */\n\tint txipos;\t\t/* Next Tx buffer to check for free */\n\tint start;\t\t/* Indication of start/stop to network */\n\t/*\n\t * A sixteen entry transmit queue\n\t */\n\tint txqs;\t\t/* index to get next buffer to tx */\n\tint txqe;\t\t/* index to queue next packet */\n\tstruct sk_buff *txq[FST_TXQ_DEPTH];\t/* The queue */\n\tint rxqdepth;\n};\n\n/*      Per card information\n */\nstruct fst_card_info {\n\tchar __iomem *mem;\t/* Card memory mapped to kernel space */\n\tchar __iomem *ctlmem;\t/* Control memory for PCI cards */\n\tunsigned int phys_mem;\t/* Physical memory window address */\n\tunsigned int phys_ctlmem;\t/* Physical control memory address */\n\tunsigned int irq;\t/* Interrupt request line number */\n\tunsigned int nports;\t/* Number of serial ports */\n\tunsigned int type;\t/* Type index of card */\n\tunsigned int state;\t/* State of card */\n\tspinlock_t card_lock;\t/* Lock for SMP access */\n\tunsigned short pci_conf;\t/* PCI card config in I/O space */\n\t/* Per port info */\n\tstruct fst_port_info ports[FST_MAX_PORTS];\n\tstruct pci_dev *device;\t/* Information about the pci device */\n\tint card_no;\t\t/* Inst of the card on the system */\n\tint family;\t\t/* TxP or TxU */\n\tint dmarx_in_progress;\n\tint dmatx_in_progress;\n\tunsigned long int_count;\n\tunsigned long int_time_ave;\n\tvoid *rx_dma_handle_host;\n\tdma_addr_t rx_dma_handle_card;\n\tvoid *tx_dma_handle_host;\n\tdma_addr_t tx_dma_handle_card;\n\tstruct sk_buff *dma_skb_rx;\n\tstruct fst_port_info *dma_port_rx;\n\tstruct fst_port_info *dma_port_tx;\n\tint dma_len_rx;\n\tint dma_len_tx;\n\tint dma_txpos;\n\tint dma_rxpos;\n};\n\n/* Convert an HDLC device pointer into a port info pointer and similar */\n#define dev_to_port(D)  (dev_to_hdlc(D)->priv)\n#define port_to_dev(P)  ((P)->dev)\n\n\n/*\n *      Shared memory window access macros\n *\n *      We have a nice memory based structure above, which could be directly\n *      mapped on i386 but might not work on other architectures unless we use\n *      the readb,w,l and writeb,w,l macros. Unfortunately these macros take\n *      physical offsets so we have to convert. The only saving grace is that\n *      this should all collapse back to a simple indirection eventually.\n */\n#define WIN_OFFSET(X)   ((long)&(((struct fst_shared *)SMC_BASE)->X))\n\n#define FST_RDB(C,E)    readb ((C)->mem + WIN_OFFSET(E))\n#define FST_RDW(C,E)    readw ((C)->mem + WIN_OFFSET(E))\n#define FST_RDL(C,E)    readl ((C)->mem + WIN_OFFSET(E))\n\n#define FST_WRB(C,E,B)  writeb ((B), (C)->mem + WIN_OFFSET(E))\n#define FST_WRW(C,E,W)  writew ((W), (C)->mem + WIN_OFFSET(E))\n#define FST_WRL(C,E,L)  writel ((L), (C)->mem + WIN_OFFSET(E))\n\n/*\n *      Debug support\n */\n#if FST_DEBUG\n\nstatic int fst_debug_mask = { FST_DEBUG };\n\n/* Most common debug activity is to print something if the corresponding bit\n * is set in the debug mask. Note: this uses a non-ANSI extension in GCC to\n * support variable numbers of macro parameters. The inverted if prevents us\n * eating someone else's else clause.\n */\n#define dbg(F, fmt, args...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (fst_debug_mask & (F))\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(fmt), ##args);\t\t\\\n} while (0)\n#else\n#define dbg(F, fmt, args...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (0)\t\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(fmt), ##args);\t\t\\\n} while (0)\n#endif\n\n/*\n *      PCI ID lookup table\n */\nstatic DEFINE_PCI_DEVICE_TABLE(fst_pci_dev_id) = {\n\t{PCI_VENDOR_ID_FARSITE, PCI_DEVICE_ID_FARSITE_T2P, PCI_ANY_ID, \n\t PCI_ANY_ID, 0, 0, FST_TYPE_T2P},\n\n\t{PCI_VENDOR_ID_FARSITE, PCI_DEVICE_ID_FARSITE_T4P, PCI_ANY_ID, \n\t PCI_ANY_ID, 0, 0, FST_TYPE_T4P},\n\n\t{PCI_VENDOR_ID_FARSITE, PCI_DEVICE_ID_FARSITE_T1U, PCI_ANY_ID, \n\t PCI_ANY_ID, 0, 0, FST_TYPE_T1U},\n\n\t{PCI_VENDOR_ID_FARSITE, PCI_DEVICE_ID_FARSITE_T2U, PCI_ANY_ID, \n\t PCI_ANY_ID, 0, 0, FST_TYPE_T2U},\n\n\t{PCI_VENDOR_ID_FARSITE, PCI_DEVICE_ID_FARSITE_T4U, PCI_ANY_ID, \n\t PCI_ANY_ID, 0, 0, FST_TYPE_T4U},\n\n\t{PCI_VENDOR_ID_FARSITE, PCI_DEVICE_ID_FARSITE_TE1, PCI_ANY_ID, \n\t PCI_ANY_ID, 0, 0, FST_TYPE_TE1},\n\n\t{PCI_VENDOR_ID_FARSITE, PCI_DEVICE_ID_FARSITE_TE1C, PCI_ANY_ID, \n\t PCI_ANY_ID, 0, 0, FST_TYPE_TE1},\n\t{0,}\t\t\t/* End */\n};\n\nMODULE_DEVICE_TABLE(pci, fst_pci_dev_id);\n\n/*\n *      Device Driver Work Queues\n *\n *      So that we don't spend too much time processing events in the \n *      Interrupt Service routine, we will declare a work queue per Card \n *      and make the ISR schedule a task in the queue for later execution.\n *      In the 2.4 Kernel we used to use the immediate queue for BH's\n *      Now that they are gone, tasklets seem to be much better than work \n *      queues.\n */\n\nstatic void do_bottom_half_tx(struct fst_card_info *card);\nstatic void do_bottom_half_rx(struct fst_card_info *card);\nstatic void fst_process_tx_work_q(unsigned long work_q);\nstatic void fst_process_int_work_q(unsigned long work_q);\n\nstatic DECLARE_TASKLET(fst_tx_task, fst_process_tx_work_q, 0);\nstatic DECLARE_TASKLET(fst_int_task, fst_process_int_work_q, 0);\n\nstatic struct fst_card_info *fst_card_array[FST_MAX_CARDS];\nstatic spinlock_t fst_work_q_lock;\nstatic u64 fst_work_txq;\nstatic u64 fst_work_intq;\n\nstatic void\nfst_q_work_item(u64 * queue, int card_index)\n{\n\tunsigned long flags;\n\tu64 mask;\n\n\t/*\n\t * Grab the queue exclusively\n\t */\n\tspin_lock_irqsave(&fst_work_q_lock, flags);\n\n\t/*\n\t * Making an entry in the queue is simply a matter of setting\n\t * a bit for the card indicating that there is work to do in the\n\t * bottom half for the card.  Note the limitation of 64 cards.\n\t * That ought to be enough\n\t */\n\tmask = (u64)1 << card_index;\n\t*queue |= mask;\n\tspin_unlock_irqrestore(&fst_work_q_lock, flags);\n}\n\nstatic void\nfst_process_tx_work_q(unsigned long /*void **/work_q)\n{\n\tunsigned long flags;\n\tu64 work_txq;\n\tint i;\n\n\t/*\n\t * Grab the queue exclusively\n\t */\n\tdbg(DBG_TX, \"fst_process_tx_work_q\\n\");\n\tspin_lock_irqsave(&fst_work_q_lock, flags);\n\twork_txq = fst_work_txq;\n\tfst_work_txq = 0;\n\tspin_unlock_irqrestore(&fst_work_q_lock, flags);\n\n\t/*\n\t * Call the bottom half for each card with work waiting\n\t */\n\tfor (i = 0; i < FST_MAX_CARDS; i++) {\n\t\tif (work_txq & 0x01) {\n\t\t\tif (fst_card_array[i] != NULL) {\n\t\t\t\tdbg(DBG_TX, \"Calling tx bh for card %d\\n\", i);\n\t\t\t\tdo_bottom_half_tx(fst_card_array[i]);\n\t\t\t}\n\t\t}\n\t\twork_txq = work_txq >> 1;\n\t}\n}\n\nstatic void\nfst_process_int_work_q(unsigned long /*void **/work_q)\n{\n\tunsigned long flags;\n\tu64 work_intq;\n\tint i;\n\n\t/*\n\t * Grab the queue exclusively\n\t */\n\tdbg(DBG_INTR, \"fst_process_int_work_q\\n\");\n\tspin_lock_irqsave(&fst_work_q_lock, flags);\n\twork_intq = fst_work_intq;\n\tfst_work_intq = 0;\n\tspin_unlock_irqrestore(&fst_work_q_lock, flags);\n\n\t/*\n\t * Call the bottom half for each card with work waiting\n\t */\n\tfor (i = 0; i < FST_MAX_CARDS; i++) {\n\t\tif (work_intq & 0x01) {\n\t\t\tif (fst_card_array[i] != NULL) {\n\t\t\t\tdbg(DBG_INTR,\n\t\t\t\t    \"Calling rx & tx bh for card %d\\n\", i);\n\t\t\t\tdo_bottom_half_rx(fst_card_array[i]);\n\t\t\t\tdo_bottom_half_tx(fst_card_array[i]);\n\t\t\t}\n\t\t}\n\t\twork_intq = work_intq >> 1;\n\t}\n}\n\n/*      Card control functions\n *      ======================\n */\n/*      Place the processor in reset state\n *\n * Used to be a simple write to card control space but a glitch in the latest\n * AMD Am186CH processor means that we now have to do it by asserting and de-\n * asserting the PLX chip PCI Adapter Software Reset. Bit 30 in CNTRL register\n * at offset 9052_CNTRL.  Note the updates for the TXU.\n */\nstatic inline void\nfst_cpureset(struct fst_card_info *card)\n{\n\tunsigned char interrupt_line_register;\n\tunsigned long j = jiffies + 1;\n\tunsigned int regval;\n\n\tif (card->family == FST_FAMILY_TXU) {\n\t\tif (pci_read_config_byte\n\t\t    (card->device, PCI_INTERRUPT_LINE, &interrupt_line_register)) {\n\t\t\tdbg(DBG_ASS,\n\t\t\t    \"Error in reading interrupt line register\\n\");\n\t\t}\n\t\t/*\n\t\t * Assert PLX software reset and Am186 hardware reset\n\t\t * and then deassert the PLX software reset but 186 still in reset\n\t\t */\n\t\toutw(0x440f, card->pci_conf + CNTRL_9054 + 2);\n\t\toutw(0x040f, card->pci_conf + CNTRL_9054 + 2);\n\t\t/*\n\t\t * We are delaying here to allow the 9054 to reset itself\n\t\t */\n\t\tj = jiffies + 1;\n\t\twhile (jiffies < j)\n\t\t\t/* Do nothing */ ;\n\t\toutw(0x240f, card->pci_conf + CNTRL_9054 + 2);\n\t\t/*\n\t\t * We are delaying here to allow the 9054 to reload its eeprom\n\t\t */\n\t\tj = jiffies + 1;\n\t\twhile (jiffies < j)\n\t\t\t/* Do nothing */ ;\n\t\toutw(0x040f, card->pci_conf + CNTRL_9054 + 2);\n\n\t\tif (pci_write_config_byte\n\t\t    (card->device, PCI_INTERRUPT_LINE, interrupt_line_register)) {\n\t\t\tdbg(DBG_ASS,\n\t\t\t    \"Error in writing interrupt line register\\n\");\n\t\t}\n\n\t} else {\n\t\tregval = inl(card->pci_conf + CNTRL_9052);\n\n\t\toutl(regval | 0x40000000, card->pci_conf + CNTRL_9052);\n\t\toutl(regval & ~0x40000000, card->pci_conf + CNTRL_9052);\n\t}\n}\n\n/*      Release the processor from reset\n */\nstatic inline void\nfst_cpurelease(struct fst_card_info *card)\n{\n\tif (card->family == FST_FAMILY_TXU) {\n\t\t/*\n\t\t * Force posted writes to complete\n\t\t */\n\t\t(void) readb(card->mem);\n\n\t\t/*\n\t\t * Release LRESET DO = 1\n\t\t * Then release Local Hold, DO = 1\n\t\t */\n\t\toutw(0x040e, card->pci_conf + CNTRL_9054 + 2);\n\t\toutw(0x040f, card->pci_conf + CNTRL_9054 + 2);\n\t} else {\n\t\t(void) readb(card->ctlmem);\n\t}\n}\n\n/*      Clear the cards interrupt flag\n */\nstatic inline void\nfst_clear_intr(struct fst_card_info *card)\n{\n\tif (card->family == FST_FAMILY_TXU) {\n\t\t(void) readb(card->ctlmem);\n\t} else {\n\t\t/* Poke the appropriate PLX chip register (same as enabling interrupts)\n\t\t */\n\t\toutw(0x0543, card->pci_conf + INTCSR_9052);\n\t}\n}\n\n/*      Enable card interrupts\n */\nstatic inline void\nfst_enable_intr(struct fst_card_info *card)\n{\n\tif (card->family == FST_FAMILY_TXU) {\n\t\toutl(0x0f0c0900, card->pci_conf + INTCSR_9054);\n\t} else {\n\t\toutw(0x0543, card->pci_conf + INTCSR_9052);\n\t}\n}\n\n/*      Disable card interrupts\n */\nstatic inline void\nfst_disable_intr(struct fst_card_info *card)\n{\n\tif (card->family == FST_FAMILY_TXU) {\n\t\toutl(0x00000000, card->pci_conf + INTCSR_9054);\n\t} else {\n\t\toutw(0x0000, card->pci_conf + INTCSR_9052);\n\t}\n}\n\n/*      Process the result of trying to pass a received frame up the stack\n */\nstatic void\nfst_process_rx_status(int rx_status, char *name)\n{\n\tswitch (rx_status) {\n\tcase NET_RX_SUCCESS:\n\t\t{\n\t\t\t/*\n\t\t\t * Nothing to do here\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\tcase NET_RX_DROP:\n\t\t{\n\t\t\tdbg(DBG_ASS, \"%s: Received packet dropped\\n\", name);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/*      Initilaise DMA for PLX 9054\n */\nstatic inline void\nfst_init_dma(struct fst_card_info *card)\n{\n\t/*\n\t * This is only required for the PLX 9054\n\t */\n\tif (card->family == FST_FAMILY_TXU) {\n\t        pci_set_master(card->device);\n\t\toutl(0x00020441, card->pci_conf + DMAMODE0);\n\t\toutl(0x00020441, card->pci_conf + DMAMODE1);\n\t\toutl(0x0, card->pci_conf + DMATHR);\n\t}\n}\n\n/*      Tx dma complete interrupt\n */\nstatic void\nfst_tx_dma_complete(struct fst_card_info *card, struct fst_port_info *port,\n\t\t    int len, int txpos)\n{\n\tstruct net_device *dev = port_to_dev(port);\n\n\t/*\n\t * Everything is now set, just tell the card to go\n\t */\n\tdbg(DBG_TX, \"fst_tx_dma_complete\\n\");\n\tFST_WRB(card, txDescrRing[port->index][txpos].bits,\n\t\tDMA_OWN | TX_STP | TX_ENP);\n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += len;\n\tdev->trans_start = jiffies;\n}\n\n/*\n * Mark it for our own raw sockets interface\n */\nstatic __be16 farsync_type_trans(struct sk_buff *skb, struct net_device *dev)\n{\n\tskb->dev = dev;\n\tskb_reset_mac_header(skb);\n\tskb->pkt_type = PACKET_HOST;\n\treturn htons(ETH_P_CUST);\n}\n\n/*      Rx dma complete interrupt\n */\nstatic void\nfst_rx_dma_complete(struct fst_card_info *card, struct fst_port_info *port,\n\t\t    int len, struct sk_buff *skb, int rxp)\n{\n\tstruct net_device *dev = port_to_dev(port);\n\tint pi;\n\tint rx_status;\n\n\tdbg(DBG_TX, \"fst_rx_dma_complete\\n\");\n\tpi = port->index;\n\tmemcpy(skb_put(skb, len), card->rx_dma_handle_host, len);\n\n\t/* Reset buffer descriptor */\n\tFST_WRB(card, rxDescrRing[pi][rxp].bits, DMA_OWN);\n\n\t/* Update stats */\n\tdev->stats.rx_packets++;\n\tdev->stats.rx_bytes += len;\n\n\t/* Push upstream */\n\tdbg(DBG_RX, \"Pushing the frame up the stack\\n\");\n\tif (port->mode == FST_RAW)\n\t\tskb->protocol = farsync_type_trans(skb, dev);\n\telse\n\t\tskb->protocol = hdlc_type_trans(skb, dev);\n\trx_status = netif_rx(skb);\n\tfst_process_rx_status(rx_status, port_to_dev(port)->name);\n\tif (rx_status == NET_RX_DROP)\n\t\tdev->stats.rx_dropped++;\n}\n\n/*\n *      Receive a frame through the DMA\n */\nstatic inline void\nfst_rx_dma(struct fst_card_info *card, dma_addr_t skb,\n\t   dma_addr_t mem, int len)\n{\n\t/*\n\t * This routine will setup the DMA and start it\n\t */\n\n\tdbg(DBG_RX, \"In fst_rx_dma %lx %lx %d\\n\",\n\t    (unsigned long) skb, (unsigned long) mem, len);\n\tif (card->dmarx_in_progress) {\n\t\tdbg(DBG_ASS, \"In fst_rx_dma while dma in progress\\n\");\n\t}\n\n\toutl(skb, card->pci_conf + DMAPADR0);\t/* Copy to here */\n\toutl(mem, card->pci_conf + DMALADR0);\t/* from here */\n\toutl(len, card->pci_conf + DMASIZ0);\t/* for this length */\n\toutl(0x00000000c, card->pci_conf + DMADPR0);\t/* In this direction */\n\n\t/*\n\t * We use the dmarx_in_progress flag to flag the channel as busy\n\t */\n\tcard->dmarx_in_progress = 1;\n\toutb(0x03, card->pci_conf + DMACSR0);\t/* Start the transfer */\n}\n\n/*\n *      Send a frame through the DMA\n */\nstatic inline void\nfst_tx_dma(struct fst_card_info *card, unsigned char *skb,\n\t   unsigned char *mem, int len)\n{\n\t/*\n\t * This routine will setup the DMA and start it.\n\t */\n\n\tdbg(DBG_TX, \"In fst_tx_dma %p %p %d\\n\", skb, mem, len);\n\tif (card->dmatx_in_progress) {\n\t\tdbg(DBG_ASS, \"In fst_tx_dma while dma in progress\\n\");\n\t}\n\n\toutl((unsigned long) skb, card->pci_conf + DMAPADR1);\t/* Copy from here */\n\toutl((unsigned long) mem, card->pci_conf + DMALADR1);\t/* to here */\n\toutl(len, card->pci_conf + DMASIZ1);\t/* for this length */\n\toutl(0x000000004, card->pci_conf + DMADPR1);\t/* In this direction */\n\n\t/*\n\t * We use the dmatx_in_progress to flag the channel as busy\n\t */\n\tcard->dmatx_in_progress = 1;\n\toutb(0x03, card->pci_conf + DMACSR1);\t/* Start the transfer */\n}\n\n/*      Issue a Mailbox command for a port.\n *      Note we issue them on a fire and forget basis, not expecting to see an\n *      error and not waiting for completion.\n */\nstatic void\nfst_issue_cmd(struct fst_port_info *port, unsigned short cmd)\n{\n\tstruct fst_card_info *card;\n\tunsigned short mbval;\n\tunsigned long flags;\n\tint safety;\n\n\tcard = port->card;\n\tspin_lock_irqsave(&card->card_lock, flags);\n\tmbval = FST_RDW(card, portMailbox[port->index][0]);\n\n\tsafety = 0;\n\t/* Wait for any previous command to complete */\n\twhile (mbval > NAK) {\n\t\tspin_unlock_irqrestore(&card->card_lock, flags);\n\t\tschedule_timeout_uninterruptible(1);\n\t\tspin_lock_irqsave(&card->card_lock, flags);\n\n\t\tif (++safety > 2000) {\n\t\t\tpr_err(\"Mailbox safety timeout\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tmbval = FST_RDW(card, portMailbox[port->index][0]);\n\t}\n\tif (safety > 0) {\n\t\tdbg(DBG_CMD, \"Mailbox clear after %d jiffies\\n\", safety);\n\t}\n\tif (mbval == NAK) {\n\t\tdbg(DBG_CMD, \"issue_cmd: previous command was NAK'd\\n\");\n\t}\n\n\tFST_WRW(card, portMailbox[port->index][0], cmd);\n\n\tif (cmd == ABORTTX || cmd == STARTPORT) {\n\t\tport->txpos = 0;\n\t\tport->txipos = 0;\n\t\tport->start = 0;\n\t}\n\n\tspin_unlock_irqrestore(&card->card_lock, flags);\n}\n\n/*      Port output signals control\n */\nstatic inline void\nfst_op_raise(struct fst_port_info *port, unsigned int outputs)\n{\n\toutputs |= FST_RDL(port->card, v24OpSts[port->index]);\n\tFST_WRL(port->card, v24OpSts[port->index], outputs);\n\n\tif (port->run)\n\t\tfst_issue_cmd(port, SETV24O);\n}\n\nstatic inline void\nfst_op_lower(struct fst_port_info *port, unsigned int outputs)\n{\n\toutputs = ~outputs & FST_RDL(port->card, v24OpSts[port->index]);\n\tFST_WRL(port->card, v24OpSts[port->index], outputs);\n\n\tif (port->run)\n\t\tfst_issue_cmd(port, SETV24O);\n}\n\n/*\n *      Setup port Rx buffers\n */\nstatic void\nfst_rx_config(struct fst_port_info *port)\n{\n\tint i;\n\tint pi;\n\tunsigned int offset;\n\tunsigned long flags;\n\tstruct fst_card_info *card;\n\n\tpi = port->index;\n\tcard = port->card;\n\tspin_lock_irqsave(&card->card_lock, flags);\n\tfor (i = 0; i < NUM_RX_BUFFER; i++) {\n\t\toffset = BUF_OFFSET(rxBuffer[pi][i][0]);\n\n\t\tFST_WRW(card, rxDescrRing[pi][i].ladr, (u16) offset);\n\t\tFST_WRB(card, rxDescrRing[pi][i].hadr, (u8) (offset >> 16));\n\t\tFST_WRW(card, rxDescrRing[pi][i].bcnt, cnv_bcnt(LEN_RX_BUFFER));\n\t\tFST_WRW(card, rxDescrRing[pi][i].mcnt, LEN_RX_BUFFER);\n\t\tFST_WRB(card, rxDescrRing[pi][i].bits, DMA_OWN);\n\t}\n\tport->rxpos = 0;\n\tspin_unlock_irqrestore(&card->card_lock, flags);\n}\n\n/*\n *      Setup port Tx buffers\n */\nstatic void\nfst_tx_config(struct fst_port_info *port)\n{\n\tint i;\n\tint pi;\n\tunsigned int offset;\n\tunsigned long flags;\n\tstruct fst_card_info *card;\n\n\tpi = port->index;\n\tcard = port->card;\n\tspin_lock_irqsave(&card->card_lock, flags);\n\tfor (i = 0; i < NUM_TX_BUFFER; i++) {\n\t\toffset = BUF_OFFSET(txBuffer[pi][i][0]);\n\n\t\tFST_WRW(card, txDescrRing[pi][i].ladr, (u16) offset);\n\t\tFST_WRB(card, txDescrRing[pi][i].hadr, (u8) (offset >> 16));\n\t\tFST_WRW(card, txDescrRing[pi][i].bcnt, 0);\n\t\tFST_WRB(card, txDescrRing[pi][i].bits, 0);\n\t}\n\tport->txpos = 0;\n\tport->txipos = 0;\n\tport->start = 0;\n\tspin_unlock_irqrestore(&card->card_lock, flags);\n}\n\n/*      TE1 Alarm change interrupt event\n */\nstatic void\nfst_intr_te1_alarm(struct fst_card_info *card, struct fst_port_info *port)\n{\n\tu8 los;\n\tu8 rra;\n\tu8 ais;\n\n\tlos = FST_RDB(card, suStatus.lossOfSignal);\n\trra = FST_RDB(card, suStatus.receiveRemoteAlarm);\n\tais = FST_RDB(card, suStatus.alarmIndicationSignal);\n\n\tif (los) {\n\t\t/*\n\t\t * Lost the link\n\t\t */\n\t\tif (netif_carrier_ok(port_to_dev(port))) {\n\t\t\tdbg(DBG_INTR, \"Net carrier off\\n\");\n\t\t\tnetif_carrier_off(port_to_dev(port));\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Link available\n\t\t */\n\t\tif (!netif_carrier_ok(port_to_dev(port))) {\n\t\t\tdbg(DBG_INTR, \"Net carrier on\\n\");\n\t\t\tnetif_carrier_on(port_to_dev(port));\n\t\t}\n\t}\n\n\tif (los)\n\t\tdbg(DBG_INTR, \"Assert LOS Alarm\\n\");\n\telse\n\t\tdbg(DBG_INTR, \"De-assert LOS Alarm\\n\");\n\tif (rra)\n\t\tdbg(DBG_INTR, \"Assert RRA Alarm\\n\");\n\telse\n\t\tdbg(DBG_INTR, \"De-assert RRA Alarm\\n\");\n\n\tif (ais)\n\t\tdbg(DBG_INTR, \"Assert AIS Alarm\\n\");\n\telse\n\t\tdbg(DBG_INTR, \"De-assert AIS Alarm\\n\");\n}\n\n/*      Control signal change interrupt event\n */\nstatic void\nfst_intr_ctlchg(struct fst_card_info *card, struct fst_port_info *port)\n{\n\tint signals;\n\n\tsignals = FST_RDL(card, v24DebouncedSts[port->index]);\n\n\tif (signals & (((port->hwif == X21) || (port->hwif == X21D))\n\t\t       ? IPSTS_INDICATE : IPSTS_DCD)) {\n\t\tif (!netif_carrier_ok(port_to_dev(port))) {\n\t\t\tdbg(DBG_INTR, \"DCD active\\n\");\n\t\t\tnetif_carrier_on(port_to_dev(port));\n\t\t}\n\t} else {\n\t\tif (netif_carrier_ok(port_to_dev(port))) {\n\t\t\tdbg(DBG_INTR, \"DCD lost\\n\");\n\t\t\tnetif_carrier_off(port_to_dev(port));\n\t\t}\n\t}\n}\n\n/*      Log Rx Errors\n */\nstatic void\nfst_log_rx_error(struct fst_card_info *card, struct fst_port_info *port,\n\t\t unsigned char dmabits, int rxp, unsigned short len)\n{\n\tstruct net_device *dev = port_to_dev(port);\n\n\t/*\n\t * Increment the appropriate error counter\n\t */\n\tdev->stats.rx_errors++;\n\tif (dmabits & RX_OFLO) {\n\t\tdev->stats.rx_fifo_errors++;\n\t\tdbg(DBG_ASS, \"Rx fifo error on card %d port %d buffer %d\\n\",\n\t\t    card->card_no, port->index, rxp);\n\t}\n\tif (dmabits & RX_CRC) {\n\t\tdev->stats.rx_crc_errors++;\n\t\tdbg(DBG_ASS, \"Rx crc error on card %d port %d\\n\",\n\t\t    card->card_no, port->index);\n\t}\n\tif (dmabits & RX_FRAM) {\n\t\tdev->stats.rx_frame_errors++;\n\t\tdbg(DBG_ASS, \"Rx frame error on card %d port %d\\n\",\n\t\t    card->card_no, port->index);\n\t}\n\tif (dmabits == (RX_STP | RX_ENP)) {\n\t\tdev->stats.rx_length_errors++;\n\t\tdbg(DBG_ASS, \"Rx length error (%d) on card %d port %d\\n\",\n\t\t    len, card->card_no, port->index);\n\t}\n}\n\n/*      Rx Error Recovery\n */\nstatic void\nfst_recover_rx_error(struct fst_card_info *card, struct fst_port_info *port,\n\t\t     unsigned char dmabits, int rxp, unsigned short len)\n{\n\tint i;\n\tint pi;\n\n\tpi = port->index;\n\t/* \n\t * Discard buffer descriptors until we see the start of the\n\t * next frame.  Note that for long frames this could be in\n\t * a subsequent interrupt. \n\t */\n\ti = 0;\n\twhile ((dmabits & (DMA_OWN | RX_STP)) == 0) {\n\t\tFST_WRB(card, rxDescrRing[pi][rxp].bits, DMA_OWN);\n\t\trxp = (rxp+1) % NUM_RX_BUFFER;\n\t\tif (++i > NUM_RX_BUFFER) {\n\t\t\tdbg(DBG_ASS, \"intr_rx: Discarding more bufs\"\n\t\t\t    \" than we have\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tdmabits = FST_RDB(card, rxDescrRing[pi][rxp].bits);\n\t\tdbg(DBG_ASS, \"DMA Bits of next buffer was %x\\n\", dmabits);\n\t}\n\tdbg(DBG_ASS, \"There were %d subsequent buffers in error\\n\", i);\n\n\t/* Discard the terminal buffer */\n\tif (!(dmabits & DMA_OWN)) {\n\t\tFST_WRB(card, rxDescrRing[pi][rxp].bits, DMA_OWN);\n\t\trxp = (rxp+1) % NUM_RX_BUFFER;\n\t}\n\tport->rxpos = rxp;\n\treturn;\n\n}\n\n/*      Rx complete interrupt\n */\nstatic void\nfst_intr_rx(struct fst_card_info *card, struct fst_port_info *port)\n{\n\tunsigned char dmabits;\n\tint pi;\n\tint rxp;\n\tint rx_status;\n\tunsigned short len;\n\tstruct sk_buff *skb;\n\tstruct net_device *dev = port_to_dev(port);\n\n\t/* Check we have a buffer to process */\n\tpi = port->index;\n\trxp = port->rxpos;\n\tdmabits = FST_RDB(card, rxDescrRing[pi][rxp].bits);\n\tif (dmabits & DMA_OWN) {\n\t\tdbg(DBG_RX | DBG_INTR, \"intr_rx: No buffer port %d pos %d\\n\",\n\t\t    pi, rxp);\n\t\treturn;\n\t}\n\tif (card->dmarx_in_progress) {\n\t\treturn;\n\t}\n\n\t/* Get buffer length */\n\tlen = FST_RDW(card, rxDescrRing[pi][rxp].mcnt);\n\t/* Discard the CRC */\n\tlen -= 2;\n\tif (len == 0) {\n\t\t/*\n\t\t * This seems to happen on the TE1 interface sometimes\n\t\t * so throw the frame away and log the event.\n\t\t */\n\t\tpr_err(\"Frame received with 0 length. Card %d Port %d\\n\",\n\t\t       card->card_no, port->index);\n\t\t/* Return descriptor to card */\n\t\tFST_WRB(card, rxDescrRing[pi][rxp].bits, DMA_OWN);\n\n\t\trxp = (rxp+1) % NUM_RX_BUFFER;\n\t\tport->rxpos = rxp;\n\t\treturn;\n\t}\n\n\t/* Check buffer length and for other errors. We insist on one packet\n\t * in one buffer. This simplifies things greatly and since we've\n\t * allocated 8K it shouldn't be a real world limitation\n\t */\n\tdbg(DBG_RX, \"intr_rx: %d,%d: flags %x len %d\\n\", pi, rxp, dmabits, len);\n\tif (dmabits != (RX_STP | RX_ENP) || len > LEN_RX_BUFFER - 2) {\n\t\tfst_log_rx_error(card, port, dmabits, rxp, len);\n\t\tfst_recover_rx_error(card, port, dmabits, rxp, len);\n\t\treturn;\n\t}\n\n\t/* Allocate SKB */\n\tif ((skb = dev_alloc_skb(len)) == NULL) {\n\t\tdbg(DBG_RX, \"intr_rx: can't allocate buffer\\n\");\n\n\t\tdev->stats.rx_dropped++;\n\n\t\t/* Return descriptor to card */\n\t\tFST_WRB(card, rxDescrRing[pi][rxp].bits, DMA_OWN);\n\n\t\trxp = (rxp+1) % NUM_RX_BUFFER;\n\t\tport->rxpos = rxp;\n\t\treturn;\n\t}\n\n\t/*\n\t * We know the length we need to receive, len.\n\t * It's not worth using the DMA for reads of less than\n\t * FST_MIN_DMA_LEN\n\t */\n\n\tif ((len < FST_MIN_DMA_LEN) || (card->family == FST_FAMILY_TXP)) {\n\t\tmemcpy_fromio(skb_put(skb, len),\n\t\t\t      card->mem + BUF_OFFSET(rxBuffer[pi][rxp][0]),\n\t\t\t      len);\n\n\t\t/* Reset buffer descriptor */\n\t\tFST_WRB(card, rxDescrRing[pi][rxp].bits, DMA_OWN);\n\n\t\t/* Update stats */\n\t\tdev->stats.rx_packets++;\n\t\tdev->stats.rx_bytes += len;\n\n\t\t/* Push upstream */\n\t\tdbg(DBG_RX, \"Pushing frame up the stack\\n\");\n\t\tif (port->mode == FST_RAW)\n\t\t\tskb->protocol = farsync_type_trans(skb, dev);\n\t\telse\n\t\t\tskb->protocol = hdlc_type_trans(skb, dev);\n\t\trx_status = netif_rx(skb);\n\t\tfst_process_rx_status(rx_status, port_to_dev(port)->name);\n\t\tif (rx_status == NET_RX_DROP)\n\t\t\tdev->stats.rx_dropped++;\n\t} else {\n\t\tcard->dma_skb_rx = skb;\n\t\tcard->dma_port_rx = port;\n\t\tcard->dma_len_rx = len;\n\t\tcard->dma_rxpos = rxp;\n\t\tfst_rx_dma(card, card->rx_dma_handle_card,\n\t\t\t   BUF_OFFSET(rxBuffer[pi][rxp][0]), len);\n\t}\n\tif (rxp != port->rxpos) {\n\t\tdbg(DBG_ASS, \"About to increment rxpos by more than 1\\n\");\n\t\tdbg(DBG_ASS, \"rxp = %d rxpos = %d\\n\", rxp, port->rxpos);\n\t}\n\trxp = (rxp+1) % NUM_RX_BUFFER;\n\tport->rxpos = rxp;\n}\n\n/*\n *      The bottom halfs to the ISR\n *\n */\n\nstatic void\ndo_bottom_half_tx(struct fst_card_info *card)\n{\n\tstruct fst_port_info *port;\n\tint pi;\n\tint txq_length;\n\tstruct sk_buff *skb;\n\tunsigned long flags;\n\tstruct net_device *dev;\n\n\t/*\n\t *  Find a free buffer for the transmit\n\t *  Step through each port on this card\n\t */\n\n\tdbg(DBG_TX, \"do_bottom_half_tx\\n\");\n\tfor (pi = 0, port = card->ports; pi < card->nports; pi++, port++) {\n\t\tif (!port->run)\n\t\t\tcontinue;\n\n\t\tdev = port_to_dev(port);\n\t\twhile (!(FST_RDB(card, txDescrRing[pi][port->txpos].bits) &\n\t\t\t DMA_OWN) &&\n\t\t       !(card->dmatx_in_progress)) {\n\t\t\t/*\n\t\t\t * There doesn't seem to be a txdone event per-se\n\t\t\t * We seem to have to deduce it, by checking the DMA_OWN\n\t\t\t * bit on the next buffer we think we can use\n\t\t\t */\n\t\t\tspin_lock_irqsave(&card->card_lock, flags);\n\t\t\tif ((txq_length = port->txqe - port->txqs) < 0) {\n\t\t\t\t/*\n\t\t\t\t * This is the case where one has wrapped and the\n\t\t\t\t * maths gives us a negative number\n\t\t\t\t */\n\t\t\t\ttxq_length = txq_length + FST_TXQ_DEPTH;\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&card->card_lock, flags);\n\t\t\tif (txq_length > 0) {\n\t\t\t\t/*\n\t\t\t\t * There is something to send\n\t\t\t\t */\n\t\t\t\tspin_lock_irqsave(&card->card_lock, flags);\n\t\t\t\tskb = port->txq[port->txqs];\n\t\t\t\tport->txqs++;\n\t\t\t\tif (port->txqs == FST_TXQ_DEPTH) {\n\t\t\t\t\tport->txqs = 0;\n\t\t\t\t}\n\t\t\t\tspin_unlock_irqrestore(&card->card_lock, flags);\n\t\t\t\t/*\n\t\t\t\t * copy the data and set the required indicators on the\n\t\t\t\t * card.\n\t\t\t\t */\n\t\t\t\tFST_WRW(card, txDescrRing[pi][port->txpos].bcnt,\n\t\t\t\t\tcnv_bcnt(skb->len));\n\t\t\t\tif ((skb->len < FST_MIN_DMA_LEN) ||\n\t\t\t\t    (card->family == FST_FAMILY_TXP)) {\n\t\t\t\t\t/* Enqueue the packet with normal io */\n\t\t\t\t\tmemcpy_toio(card->mem +\n\t\t\t\t\t\t    BUF_OFFSET(txBuffer[pi]\n\t\t\t\t\t\t\t       [port->\n\t\t\t\t\t\t\t\ttxpos][0]),\n\t\t\t\t\t\t    skb->data, skb->len);\n\t\t\t\t\tFST_WRB(card,\n\t\t\t\t\t\ttxDescrRing[pi][port->txpos].\n\t\t\t\t\t\tbits,\n\t\t\t\t\t\tDMA_OWN | TX_STP | TX_ENP);\n\t\t\t\t\tdev->stats.tx_packets++;\n\t\t\t\t\tdev->stats.tx_bytes += skb->len;\n\t\t\t\t\tdev->trans_start = jiffies;\n\t\t\t\t} else {\n\t\t\t\t\t/* Or do it through dma */\n\t\t\t\t\tmemcpy(card->tx_dma_handle_host,\n\t\t\t\t\t       skb->data, skb->len);\n\t\t\t\t\tcard->dma_port_tx = port;\n\t\t\t\t\tcard->dma_len_tx = skb->len;\n\t\t\t\t\tcard->dma_txpos = port->txpos;\n\t\t\t\t\tfst_tx_dma(card,\n\t\t\t\t\t\t   (char *) card->\n\t\t\t\t\t\t   tx_dma_handle_card,\n\t\t\t\t\t\t   (char *)\n\t\t\t\t\t\t   BUF_OFFSET(txBuffer[pi]\n\t\t\t\t\t\t\t      [port->txpos][0]),\n\t\t\t\t\t\t   skb->len);\n\t\t\t\t}\n\t\t\t\tif (++port->txpos >= NUM_TX_BUFFER)\n\t\t\t\t\tport->txpos = 0;\n\t\t\t\t/*\n\t\t\t\t * If we have flow control on, can we now release it?\n\t\t\t\t */\n\t\t\t\tif (port->start) {\n\t\t\t\t\tif (txq_length < fst_txq_low) {\n\t\t\t\t\t\tnetif_wake_queue(port_to_dev\n\t\t\t\t\t\t\t\t (port));\n\t\t\t\t\t\tport->start = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Nothing to send so break out of the while loop\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void\ndo_bottom_half_rx(struct fst_card_info *card)\n{\n\tstruct fst_port_info *port;\n\tint pi;\n\tint rx_count = 0;\n\n\t/* Check for rx completions on all ports on this card */\n\tdbg(DBG_RX, \"do_bottom_half_rx\\n\");\n\tfor (pi = 0, port = card->ports; pi < card->nports; pi++, port++) {\n\t\tif (!port->run)\n\t\t\tcontinue;\n\n\t\twhile (!(FST_RDB(card, rxDescrRing[pi][port->rxpos].bits)\n\t\t\t & DMA_OWN) && !(card->dmarx_in_progress)) {\n\t\t\tif (rx_count > fst_max_reads) {\n\t\t\t\t/*\n\t\t\t\t * Don't spend forever in receive processing\n\t\t\t\t * Schedule another event\n\t\t\t\t */\n\t\t\t\tfst_q_work_item(&fst_work_intq, card->card_no);\n\t\t\t\ttasklet_schedule(&fst_int_task);\n\t\t\t\tbreak;\t/* Leave the loop */\n\t\t\t}\n\t\t\tfst_intr_rx(card, port);\n\t\t\trx_count++;\n\t\t}\n\t}\n}\n\n/*\n *      The interrupt service routine\n *      Dev_id is our fst_card_info pointer\n */\nstatic irqreturn_t\nfst_intr(int dummy, void *dev_id)\n{\n\tstruct fst_card_info *card = dev_id;\n\tstruct fst_port_info *port;\n\tint rdidx;\t\t/* Event buffer indices */\n\tint wridx;\n\tint event;\t\t/* Actual event for processing */\n\tunsigned int dma_intcsr = 0;\n\tunsigned int do_card_interrupt;\n\tunsigned int int_retry_count;\n\n\t/*\n\t * Check to see if the interrupt was for this card\n\t * return if not\n\t * Note that the call to clear the interrupt is important\n\t */\n\tdbg(DBG_INTR, \"intr: %d %p\\n\", card->irq, card);\n\tif (card->state != FST_RUNNING) {\n\t\tpr_err(\"Interrupt received for card %d in a non running state (%d)\\n\",\n\t\t       card->card_no, card->state);\n\n\t\t/* \n\t\t * It is possible to really be running, i.e. we have re-loaded\n\t\t * a running card\n\t\t * Clear and reprime the interrupt source \n\t\t */\n\t\tfst_clear_intr(card);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t/* Clear and reprime the interrupt source */\n\tfst_clear_intr(card);\n\n\t/*\n\t * Is the interrupt for this card (handshake == 1)\n\t */\n\tdo_card_interrupt = 0;\n\tif (FST_RDB(card, interruptHandshake) == 1) {\n\t\tdo_card_interrupt += FST_CARD_INT;\n\t\t/* Set the software acknowledge */\n\t\tFST_WRB(card, interruptHandshake, 0xEE);\n\t}\n\tif (card->family == FST_FAMILY_TXU) {\n\t\t/*\n\t\t * Is it a DMA Interrupt\n\t\t */\n\t\tdma_intcsr = inl(card->pci_conf + INTCSR_9054);\n\t\tif (dma_intcsr & 0x00200000) {\n\t\t\t/*\n\t\t\t * DMA Channel 0 (Rx transfer complete)\n\t\t\t */\n\t\t\tdbg(DBG_RX, \"DMA Rx xfer complete\\n\");\n\t\t\toutb(0x8, card->pci_conf + DMACSR0);\n\t\t\tfst_rx_dma_complete(card, card->dma_port_rx,\n\t\t\t\t\t    card->dma_len_rx, card->dma_skb_rx,\n\t\t\t\t\t    card->dma_rxpos);\n\t\t\tcard->dmarx_in_progress = 0;\n\t\t\tdo_card_interrupt += FST_RX_DMA_INT;\n\t\t}\n\t\tif (dma_intcsr & 0x00400000) {\n\t\t\t/*\n\t\t\t * DMA Channel 1 (Tx transfer complete)\n\t\t\t */\n\t\t\tdbg(DBG_TX, \"DMA Tx xfer complete\\n\");\n\t\t\toutb(0x8, card->pci_conf + DMACSR1);\n\t\t\tfst_tx_dma_complete(card, card->dma_port_tx,\n\t\t\t\t\t    card->dma_len_tx, card->dma_txpos);\n\t\t\tcard->dmatx_in_progress = 0;\n\t\t\tdo_card_interrupt += FST_TX_DMA_INT;\n\t\t}\n\t}\n\n\t/*\n\t * Have we been missing Interrupts\n\t */\n\tint_retry_count = FST_RDL(card, interruptRetryCount);\n\tif (int_retry_count) {\n\t\tdbg(DBG_ASS, \"Card %d int_retry_count is  %d\\n\",\n\t\t    card->card_no, int_retry_count);\n\t\tFST_WRL(card, interruptRetryCount, 0);\n\t}\n\n\tif (!do_card_interrupt) {\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t/* Scehdule the bottom half of the ISR */\n\tfst_q_work_item(&fst_work_intq, card->card_no);\n\ttasklet_schedule(&fst_int_task);\n\n\t/* Drain the event queue */\n\trdidx = FST_RDB(card, interruptEvent.rdindex) & 0x1f;\n\twridx = FST_RDB(card, interruptEvent.wrindex) & 0x1f;\n\twhile (rdidx != wridx) {\n\t\tevent = FST_RDB(card, interruptEvent.evntbuff[rdidx]);\n\t\tport = &card->ports[event & 0x03];\n\n\t\tdbg(DBG_INTR, \"Processing Interrupt event: %x\\n\", event);\n\n\t\tswitch (event) {\n\t\tcase TE1_ALMA:\n\t\t\tdbg(DBG_INTR, \"TE1 Alarm intr\\n\");\n\t\t\tif (port->run)\n\t\t\t\tfst_intr_te1_alarm(card, port);\n\t\t\tbreak;\n\n\t\tcase CTLA_CHG:\n\t\tcase CTLB_CHG:\n\t\tcase CTLC_CHG:\n\t\tcase CTLD_CHG:\n\t\t\tif (port->run)\n\t\t\t\tfst_intr_ctlchg(card, port);\n\t\t\tbreak;\n\n\t\tcase ABTA_SENT:\n\t\tcase ABTB_SENT:\n\t\tcase ABTC_SENT:\n\t\tcase ABTD_SENT:\n\t\t\tdbg(DBG_TX, \"Abort complete port %d\\n\", port->index);\n\t\t\tbreak;\n\n\t\tcase TXA_UNDF:\n\t\tcase TXB_UNDF:\n\t\tcase TXC_UNDF:\n\t\tcase TXD_UNDF:\n\t\t\t/* Difficult to see how we'd get this given that we\n\t\t\t * always load up the entire packet for DMA.\n\t\t\t */\n\t\t\tdbg(DBG_TX, \"Tx underflow port %d\\n\", port->index);\n\t\t\tport_to_dev(port)->stats.tx_errors++;\n\t\t\tport_to_dev(port)->stats.tx_fifo_errors++;\n\t\t\tdbg(DBG_ASS, \"Tx underflow on card %d port %d\\n\",\n\t\t\t    card->card_no, port->index);\n\t\t\tbreak;\n\n\t\tcase INIT_CPLT:\n\t\t\tdbg(DBG_INIT, \"Card init OK intr\\n\");\n\t\t\tbreak;\n\n\t\tcase INIT_FAIL:\n\t\t\tdbg(DBG_INIT, \"Card init FAILED intr\\n\");\n\t\t\tcard->state = FST_IFAILED;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"intr: unknown card event %d. ignored\\n\", event);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Bump and wrap the index */\n\t\tif (++rdidx >= MAX_CIRBUFF)\n\t\t\trdidx = 0;\n\t}\n\tFST_WRB(card, interruptEvent.rdindex, rdidx);\n        return IRQ_HANDLED;\n}\n\n/*      Check that the shared memory configuration is one that we can handle\n *      and that some basic parameters are correct\n */\nstatic void\ncheck_started_ok(struct fst_card_info *card)\n{\n\tint i;\n\n\t/* Check structure version and end marker */\n\tif (FST_RDW(card, smcVersion) != SMC_VERSION) {\n\t\tpr_err(\"Bad shared memory version %d expected %d\\n\",\n\t\t       FST_RDW(card, smcVersion), SMC_VERSION);\n\t\tcard->state = FST_BADVERSION;\n\t\treturn;\n\t}\n\tif (FST_RDL(card, endOfSmcSignature) != END_SIG) {\n\t\tpr_err(\"Missing shared memory signature\\n\");\n\t\tcard->state = FST_BADVERSION;\n\t\treturn;\n\t}\n\t/* Firmware status flag, 0x00 = initialising, 0x01 = OK, 0xFF = fail */\n\tif ((i = FST_RDB(card, taskStatus)) == 0x01) {\n\t\tcard->state = FST_RUNNING;\n\t} else if (i == 0xFF) {\n\t\tpr_err(\"Firmware initialisation failed. Card halted\\n\");\n\t\tcard->state = FST_HALTED;\n\t\treturn;\n\t} else if (i != 0x00) {\n\t\tpr_err(\"Unknown firmware status 0x%x\\n\", i);\n\t\tcard->state = FST_HALTED;\n\t\treturn;\n\t}\n\n\t/* Finally check the number of ports reported by firmware against the\n\t * number we assumed at card detection. Should never happen with\n\t * existing firmware etc so we just report it for the moment.\n\t */\n\tif (FST_RDL(card, numberOfPorts) != card->nports) {\n\t\tpr_warn(\"Port count mismatch on card %d.  Firmware thinks %d we say %d\\n\",\n\t\t\tcard->card_no,\n\t\t\tFST_RDL(card, numberOfPorts), card->nports);\n\t}\n}\n\nstatic int\nset_conf_from_info(struct fst_card_info *card, struct fst_port_info *port,\n\t\t   struct fstioc_info *info)\n{\n\tint err;\n\tunsigned char my_framing;\n\n\t/* Set things according to the user set valid flags \n\t * Several of the old options have been invalidated/replaced by the \n\t * generic hdlc package.\n\t */\n\terr = 0;\n\tif (info->valid & FSTVAL_PROTO) {\n\t\tif (info->proto == FST_RAW)\n\t\t\tport->mode = FST_RAW;\n\t\telse\n\t\t\tport->mode = FST_GEN_HDLC;\n\t}\n\n\tif (info->valid & FSTVAL_CABLE)\n\t\terr = -EINVAL;\n\n\tif (info->valid & FSTVAL_SPEED)\n\t\terr = -EINVAL;\n\n\tif (info->valid & FSTVAL_PHASE)\n\t\tFST_WRB(card, portConfig[port->index].invertClock,\n\t\t\tinfo->invertClock);\n\tif (info->valid & FSTVAL_MODE)\n\t\tFST_WRW(card, cardMode, info->cardMode);\n\tif (info->valid & FSTVAL_TE1) {\n\t\tFST_WRL(card, suConfig.dataRate, info->lineSpeed);\n\t\tFST_WRB(card, suConfig.clocking, info->clockSource);\n\t\tmy_framing = FRAMING_E1;\n\t\tif (info->framing == E1)\n\t\t\tmy_framing = FRAMING_E1;\n\t\tif (info->framing == T1)\n\t\t\tmy_framing = FRAMING_T1;\n\t\tif (info->framing == J1)\n\t\t\tmy_framing = FRAMING_J1;\n\t\tFST_WRB(card, suConfig.framing, my_framing);\n\t\tFST_WRB(card, suConfig.structure, info->structure);\n\t\tFST_WRB(card, suConfig.interface, info->interface);\n\t\tFST_WRB(card, suConfig.coding, info->coding);\n\t\tFST_WRB(card, suConfig.lineBuildOut, info->lineBuildOut);\n\t\tFST_WRB(card, suConfig.equalizer, info->equalizer);\n\t\tFST_WRB(card, suConfig.transparentMode, info->transparentMode);\n\t\tFST_WRB(card, suConfig.loopMode, info->loopMode);\n\t\tFST_WRB(card, suConfig.range, info->range);\n\t\tFST_WRB(card, suConfig.txBufferMode, info->txBufferMode);\n\t\tFST_WRB(card, suConfig.rxBufferMode, info->rxBufferMode);\n\t\tFST_WRB(card, suConfig.startingSlot, info->startingSlot);\n\t\tFST_WRB(card, suConfig.losThreshold, info->losThreshold);\n\t\tif (info->idleCode)\n\t\t\tFST_WRB(card, suConfig.enableIdleCode, 1);\n\t\telse\n\t\t\tFST_WRB(card, suConfig.enableIdleCode, 0);\n\t\tFST_WRB(card, suConfig.idleCode, info->idleCode);\n#if FST_DEBUG\n\t\tif (info->valid & FSTVAL_TE1) {\n\t\t\tprintk(\"Setting TE1 data\\n\");\n\t\t\tprintk(\"Line Speed = %d\\n\", info->lineSpeed);\n\t\t\tprintk(\"Start slot = %d\\n\", info->startingSlot);\n\t\t\tprintk(\"Clock source = %d\\n\", info->clockSource);\n\t\t\tprintk(\"Framing = %d\\n\", my_framing);\n\t\t\tprintk(\"Structure = %d\\n\", info->structure);\n\t\t\tprintk(\"interface = %d\\n\", info->interface);\n\t\t\tprintk(\"Coding = %d\\n\", info->coding);\n\t\t\tprintk(\"Line build out = %d\\n\", info->lineBuildOut);\n\t\t\tprintk(\"Equaliser = %d\\n\", info->equalizer);\n\t\t\tprintk(\"Transparent mode = %d\\n\",\n\t\t\t       info->transparentMode);\n\t\t\tprintk(\"Loop mode = %d\\n\", info->loopMode);\n\t\t\tprintk(\"Range = %d\\n\", info->range);\n\t\t\tprintk(\"Tx Buffer mode = %d\\n\", info->txBufferMode);\n\t\t\tprintk(\"Rx Buffer mode = %d\\n\", info->rxBufferMode);\n\t\t\tprintk(\"LOS Threshold = %d\\n\", info->losThreshold);\n\t\t\tprintk(\"Idle Code = %d\\n\", info->idleCode);\n\t\t}\n#endif\n\t}\n#if FST_DEBUG\n\tif (info->valid & FSTVAL_DEBUG) {\n\t\tfst_debug_mask = info->debug;\n\t}\n#endif\n\n\treturn err;\n}\n\nstatic void\ngather_conf_info(struct fst_card_info *card, struct fst_port_info *port,\n\t\t struct fstioc_info *info)\n{\n\tint i;\n\n\tmemset(info, 0, sizeof (struct fstioc_info));\n\n\ti = port->index;\n\tinfo->kernelVersion = LINUX_VERSION_CODE;\n\tinfo->nports = card->nports;\n\tinfo->type = card->type;\n\tinfo->state = card->state;\n\tinfo->proto = FST_GEN_HDLC;\n\tinfo->index = i;\n#if FST_DEBUG\n\tinfo->debug = fst_debug_mask;\n#endif\n\n\t/* Only mark information as valid if card is running.\n\t * Copy the data anyway in case it is useful for diagnostics\n\t */\n\tinfo->valid = ((card->state == FST_RUNNING) ? FSTVAL_ALL : FSTVAL_CARD)\n#if FST_DEBUG\n\t    | FSTVAL_DEBUG\n#endif\n\t    ;\n\n\tinfo->lineInterface = FST_RDW(card, portConfig[i].lineInterface);\n\tinfo->internalClock = FST_RDB(card, portConfig[i].internalClock);\n\tinfo->lineSpeed = FST_RDL(card, portConfig[i].lineSpeed);\n\tinfo->invertClock = FST_RDB(card, portConfig[i].invertClock);\n\tinfo->v24IpSts = FST_RDL(card, v24IpSts[i]);\n\tinfo->v24OpSts = FST_RDL(card, v24OpSts[i]);\n\tinfo->clockStatus = FST_RDW(card, clockStatus[i]);\n\tinfo->cableStatus = FST_RDW(card, cableStatus);\n\tinfo->cardMode = FST_RDW(card, cardMode);\n\tinfo->smcFirmwareVersion = FST_RDL(card, smcFirmwareVersion);\n\n\t/*\n\t * The T2U can report cable presence for both A or B\n\t * in bits 0 and 1 of cableStatus.  See which port we are and \n\t * do the mapping.\n\t */\n\tif (card->family == FST_FAMILY_TXU) {\n\t\tif (port->index == 0) {\n\t\t\t/*\n\t\t\t * Port A\n\t\t\t */\n\t\t\tinfo->cableStatus = info->cableStatus & 1;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Port B\n\t\t\t */\n\t\t\tinfo->cableStatus = info->cableStatus >> 1;\n\t\t\tinfo->cableStatus = info->cableStatus & 1;\n\t\t}\n\t}\n\t/*\n\t * Some additional bits if we are TE1\n\t */\n\tif (card->type == FST_TYPE_TE1) {\n\t\tinfo->lineSpeed = FST_RDL(card, suConfig.dataRate);\n\t\tinfo->clockSource = FST_RDB(card, suConfig.clocking);\n\t\tinfo->framing = FST_RDB(card, suConfig.framing);\n\t\tinfo->structure = FST_RDB(card, suConfig.structure);\n\t\tinfo->interface = FST_RDB(card, suConfig.interface);\n\t\tinfo->coding = FST_RDB(card, suConfig.coding);\n\t\tinfo->lineBuildOut = FST_RDB(card, suConfig.lineBuildOut);\n\t\tinfo->equalizer = FST_RDB(card, suConfig.equalizer);\n\t\tinfo->loopMode = FST_RDB(card, suConfig.loopMode);\n\t\tinfo->range = FST_RDB(card, suConfig.range);\n\t\tinfo->txBufferMode = FST_RDB(card, suConfig.txBufferMode);\n\t\tinfo->rxBufferMode = FST_RDB(card, suConfig.rxBufferMode);\n\t\tinfo->startingSlot = FST_RDB(card, suConfig.startingSlot);\n\t\tinfo->losThreshold = FST_RDB(card, suConfig.losThreshold);\n\t\tif (FST_RDB(card, suConfig.enableIdleCode))\n\t\t\tinfo->idleCode = FST_RDB(card, suConfig.idleCode);\n\t\telse\n\t\t\tinfo->idleCode = 0;\n\t\tinfo->receiveBufferDelay =\n\t\t    FST_RDL(card, suStatus.receiveBufferDelay);\n\t\tinfo->framingErrorCount =\n\t\t    FST_RDL(card, suStatus.framingErrorCount);\n\t\tinfo->codeViolationCount =\n\t\t    FST_RDL(card, suStatus.codeViolationCount);\n\t\tinfo->crcErrorCount = FST_RDL(card, suStatus.crcErrorCount);\n\t\tinfo->lineAttenuation = FST_RDL(card, suStatus.lineAttenuation);\n\t\tinfo->lossOfSignal = FST_RDB(card, suStatus.lossOfSignal);\n\t\tinfo->receiveRemoteAlarm =\n\t\t    FST_RDB(card, suStatus.receiveRemoteAlarm);\n\t\tinfo->alarmIndicationSignal =\n\t\t    FST_RDB(card, suStatus.alarmIndicationSignal);\n\t}\n}\n\nstatic int\nfst_set_iface(struct fst_card_info *card, struct fst_port_info *port,\n\t      struct ifreq *ifr)\n{\n\tsync_serial_settings sync;\n\tint i;\n\n\tif (ifr->ifr_settings.size != sizeof (sync)) {\n\t\treturn -ENOMEM;\n\t}\n\n\tif (copy_from_user\n\t    (&sync, ifr->ifr_settings.ifs_ifsu.sync, sizeof (sync))) {\n\t\treturn -EFAULT;\n\t}\n\n\tif (sync.loopback)\n\t\treturn -EINVAL;\n\n\ti = port->index;\n\n\tswitch (ifr->ifr_settings.type) {\n\tcase IF_IFACE_V35:\n\t\tFST_WRW(card, portConfig[i].lineInterface, V35);\n\t\tport->hwif = V35;\n\t\tbreak;\n\n\tcase IF_IFACE_V24:\n\t\tFST_WRW(card, portConfig[i].lineInterface, V24);\n\t\tport->hwif = V24;\n\t\tbreak;\n\n\tcase IF_IFACE_X21:\n\t\tFST_WRW(card, portConfig[i].lineInterface, X21);\n\t\tport->hwif = X21;\n\t\tbreak;\n\n\tcase IF_IFACE_X21D:\n\t\tFST_WRW(card, portConfig[i].lineInterface, X21D);\n\t\tport->hwif = X21D;\n\t\tbreak;\n\n\tcase IF_IFACE_T1:\n\t\tFST_WRW(card, portConfig[i].lineInterface, T1);\n\t\tport->hwif = T1;\n\t\tbreak;\n\n\tcase IF_IFACE_E1:\n\t\tFST_WRW(card, portConfig[i].lineInterface, E1);\n\t\tport->hwif = E1;\n\t\tbreak;\n\n\tcase IF_IFACE_SYNC_SERIAL:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (sync.clock_type) {\n\tcase CLOCK_EXT:\n\t\tFST_WRB(card, portConfig[i].internalClock, EXTCLK);\n\t\tbreak;\n\n\tcase CLOCK_INT:\n\t\tFST_WRB(card, portConfig[i].internalClock, INTCLK);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tFST_WRL(card, portConfig[i].lineSpeed, sync.clock_rate);\n\treturn 0;\n}\n\nstatic int\nfst_get_iface(struct fst_card_info *card, struct fst_port_info *port,\n\t      struct ifreq *ifr)\n{\n\tsync_serial_settings sync;\n\tint i;\n\n\t/* First check what line type is set, we'll default to reporting X.21\n\t * if nothing is set as IF_IFACE_SYNC_SERIAL implies it can't be\n\t * changed\n\t */\n\tswitch (port->hwif) {\n\tcase E1:\n\t\tifr->ifr_settings.type = IF_IFACE_E1;\n\t\tbreak;\n\tcase T1:\n\t\tifr->ifr_settings.type = IF_IFACE_T1;\n\t\tbreak;\n\tcase V35:\n\t\tifr->ifr_settings.type = IF_IFACE_V35;\n\t\tbreak;\n\tcase V24:\n\t\tifr->ifr_settings.type = IF_IFACE_V24;\n\t\tbreak;\n\tcase X21D:\n\t\tifr->ifr_settings.type = IF_IFACE_X21D;\n\t\tbreak;\n\tcase X21:\n\tdefault:\n\t\tifr->ifr_settings.type = IF_IFACE_X21;\n\t\tbreak;\n\t}\n\tif (ifr->ifr_settings.size == 0) {\n\t\treturn 0;\t/* only type requested */\n\t}\n\tif (ifr->ifr_settings.size < sizeof (sync)) {\n\t\treturn -ENOMEM;\n\t}\n\n\ti = port->index;\n\tmemset(&sync, 0, sizeof(sync));\n\tsync.clock_rate = FST_RDL(card, portConfig[i].lineSpeed);\n\t/* Lucky card and linux use same encoding here */\n\tsync.clock_type = FST_RDB(card, portConfig[i].internalClock) ==\n\t    INTCLK ? CLOCK_INT : CLOCK_EXT;\n\tsync.loopback = 0;\n\n\tif (copy_to_user(ifr->ifr_settings.ifs_ifsu.sync, &sync, sizeof (sync))) {\n\t\treturn -EFAULT;\n\t}\n\n\tifr->ifr_settings.size = sizeof (sync);\n\treturn 0;\n}\n\nstatic int\nfst_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tstruct fst_card_info *card;\n\tstruct fst_port_info *port;\n\tstruct fstioc_write wrthdr;\n\tstruct fstioc_info info;\n\tunsigned long flags;\n\tvoid *buf;\n\n\tdbg(DBG_IOCTL, \"ioctl: %x, %p\\n\", cmd, ifr->ifr_data);\n\n\tport = dev_to_port(dev);\n\tcard = port->card;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase FSTCPURESET:\n\t\tfst_cpureset(card);\n\t\tcard->state = FST_RESET;\n\t\treturn 0;\n\n\tcase FSTCPURELEASE:\n\t\tfst_cpurelease(card);\n\t\tcard->state = FST_STARTING;\n\t\treturn 0;\n\n\tcase FSTWRITE:\t\t/* Code write (download) */\n\n\t\t/* First copy in the header with the length and offset of data\n\t\t * to write\n\t\t */\n\t\tif (ifr->ifr_data == NULL) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (copy_from_user(&wrthdr, ifr->ifr_data,\n\t\t\t\t   sizeof (struct fstioc_write))) {\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t/* Sanity check the parameters. We don't support partial writes\n\t\t * when going over the top\n\t\t */\n\t\tif (wrthdr.size > FST_MEMSIZE || wrthdr.offset > FST_MEMSIZE ||\n\t\t    wrthdr.size + wrthdr.offset > FST_MEMSIZE) {\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t\t/* Now copy the data to the card. */\n\n\t\tbuf = memdup_user(ifr->ifr_data + sizeof(struct fstioc_write),\n\t\t\t\t  wrthdr.size);\n\t\tif (IS_ERR(buf))\n\t\t\treturn PTR_ERR(buf);\n\n\t\tmemcpy_toio(card->mem + wrthdr.offset, buf, wrthdr.size);\n\t\tkfree(buf);\n\n\t\t/* Writes to the memory of a card in the reset state constitute\n\t\t * a download\n\t\t */\n\t\tif (card->state == FST_RESET) {\n\t\t\tcard->state = FST_DOWNLOAD;\n\t\t}\n\t\treturn 0;\n\n\tcase FSTGETCONF:\n\n\t\t/* If card has just been started check the shared memory config\n\t\t * version and marker\n\t\t */\n\t\tif (card->state == FST_STARTING) {\n\t\t\tcheck_started_ok(card);\n\n\t\t\t/* If everything checked out enable card interrupts */\n\t\t\tif (card->state == FST_RUNNING) {\n\t\t\t\tspin_lock_irqsave(&card->card_lock, flags);\n\t\t\t\tfst_enable_intr(card);\n\t\t\t\tFST_WRB(card, interruptHandshake, 0xEE);\n\t\t\t\tspin_unlock_irqrestore(&card->card_lock, flags);\n\t\t\t}\n\t\t}\n\n\t\tif (ifr->ifr_data == NULL) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tgather_conf_info(card, port, &info);\n\n\t\tif (copy_to_user(ifr->ifr_data, &info, sizeof (info))) {\n\t\t\treturn -EFAULT;\n\t\t}\n\t\treturn 0;\n\n\tcase FSTSETCONF:\n\n\t\t/*\n\t\t * Most of the settings have been moved to the generic ioctls\n\t\t * this just covers debug and board ident now\n\t\t */\n\n\t\tif (card->state != FST_RUNNING) {\n\t\t\tpr_err(\"Attempt to configure card %d in non-running state (%d)\\n\",\n\t\t\t       card->card_no, card->state);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (copy_from_user(&info, ifr->ifr_data, sizeof (info))) {\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\treturn set_conf_from_info(card, port, &info);\n\n\tcase SIOCWANDEV:\n\t\tswitch (ifr->ifr_settings.type) {\n\t\tcase IF_GET_IFACE:\n\t\t\treturn fst_get_iface(card, port, ifr);\n\n\t\tcase IF_IFACE_SYNC_SERIAL:\n\t\tcase IF_IFACE_V35:\n\t\tcase IF_IFACE_V24:\n\t\tcase IF_IFACE_X21:\n\t\tcase IF_IFACE_X21D:\n\t\tcase IF_IFACE_T1:\n\t\tcase IF_IFACE_E1:\n\t\t\treturn fst_set_iface(card, port, ifr);\n\n\t\tcase IF_PROTO_RAW:\n\t\t\tport->mode = FST_RAW;\n\t\t\treturn 0;\n\n\t\tcase IF_GET_PROTO:\n\t\t\tif (port->mode == FST_RAW) {\n\t\t\t\tifr->ifr_settings.type = IF_PROTO_RAW;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn hdlc_ioctl(dev, ifr, cmd);\n\n\t\tdefault:\n\t\t\tport->mode = FST_GEN_HDLC;\n\t\t\tdbg(DBG_IOCTL, \"Passing this type to hdlc %x\\n\",\n\t\t\t    ifr->ifr_settings.type);\n\t\t\treturn hdlc_ioctl(dev, ifr, cmd);\n\t\t}\n\n\tdefault:\n\t\t/* Not one of ours. Pass through to HDLC package */\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n\t}\n}\n\nstatic void\nfst_openport(struct fst_port_info *port)\n{\n\tint signals;\n\tint txq_length;\n\n\t/* Only init things if card is actually running. This allows open to\n\t * succeed for downloads etc.\n\t */\n\tif (port->card->state == FST_RUNNING) {\n\t\tif (port->run) {\n\t\t\tdbg(DBG_OPEN, \"open: found port already running\\n\");\n\n\t\t\tfst_issue_cmd(port, STOPPORT);\n\t\t\tport->run = 0;\n\t\t}\n\n\t\tfst_rx_config(port);\n\t\tfst_tx_config(port);\n\t\tfst_op_raise(port, OPSTS_RTS | OPSTS_DTR);\n\n\t\tfst_issue_cmd(port, STARTPORT);\n\t\tport->run = 1;\n\n\t\tsignals = FST_RDL(port->card, v24DebouncedSts[port->index]);\n\t\tif (signals & (((port->hwif == X21) || (port->hwif == X21D))\n\t\t\t       ? IPSTS_INDICATE : IPSTS_DCD))\n\t\t\tnetif_carrier_on(port_to_dev(port));\n\t\telse\n\t\t\tnetif_carrier_off(port_to_dev(port));\n\n\t\ttxq_length = port->txqe - port->txqs;\n\t\tport->txqe = 0;\n\t\tport->txqs = 0;\n\t}\n\n}\n\nstatic void\nfst_closeport(struct fst_port_info *port)\n{\n\tif (port->card->state == FST_RUNNING) {\n\t\tif (port->run) {\n\t\t\tport->run = 0;\n\t\t\tfst_op_lower(port, OPSTS_RTS | OPSTS_DTR);\n\n\t\t\tfst_issue_cmd(port, STOPPORT);\n\t\t} else {\n\t\t\tdbg(DBG_OPEN, \"close: port not running\\n\");\n\t\t}\n\t}\n}\n\nstatic int\nfst_open(struct net_device *dev)\n{\n\tint err;\n\tstruct fst_port_info *port;\n\n\tport = dev_to_port(dev);\n\tif (!try_module_get(THIS_MODULE))\n          return -EBUSY;\n\n\tif (port->mode != FST_RAW) {\n\t\terr = hdlc_open(dev);\n\t\tif (err) {\n\t\t\tmodule_put(THIS_MODULE);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tfst_openport(port);\n\tnetif_wake_queue(dev);\n\treturn 0;\n}\n\nstatic int\nfst_close(struct net_device *dev)\n{\n\tstruct fst_port_info *port;\n\tstruct fst_card_info *card;\n\tunsigned char tx_dma_done;\n\tunsigned char rx_dma_done;\n\n\tport = dev_to_port(dev);\n\tcard = port->card;\n\n\ttx_dma_done = inb(card->pci_conf + DMACSR1);\n\trx_dma_done = inb(card->pci_conf + DMACSR0);\n\tdbg(DBG_OPEN,\n\t    \"Port Close: tx_dma_in_progress = %d (%x) rx_dma_in_progress = %d (%x)\\n\",\n\t    card->dmatx_in_progress, tx_dma_done, card->dmarx_in_progress,\n\t    rx_dma_done);\n\n\tnetif_stop_queue(dev);\n\tfst_closeport(dev_to_port(dev));\n\tif (port->mode != FST_RAW) {\n\t\thdlc_close(dev);\n\t}\n\tmodule_put(THIS_MODULE);\n\treturn 0;\n}\n\nstatic int\nfst_attach(struct net_device *dev, unsigned short encoding, unsigned short parity)\n{\n\t/*\n\t * Setting currently fixed in FarSync card so we check and forget\n\t */\n\tif (encoding != ENCODING_NRZ || parity != PARITY_CRC16_PR1_CCITT)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic void\nfst_tx_timeout(struct net_device *dev)\n{\n\tstruct fst_port_info *port;\n\tstruct fst_card_info *card;\n\n\tport = dev_to_port(dev);\n\tcard = port->card;\n\tdev->stats.tx_errors++;\n\tdev->stats.tx_aborted_errors++;\n\tdbg(DBG_ASS, \"Tx timeout card %d port %d\\n\",\n\t    card->card_no, port->index);\n\tfst_issue_cmd(port, ABORTTX);\n\n\tdev->trans_start = jiffies;\n\tnetif_wake_queue(dev);\n\tport->start = 0;\n}\n\nstatic netdev_tx_t\nfst_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct fst_card_info *card;\n\tstruct fst_port_info *port;\n\tunsigned long flags;\n\tint txq_length;\n\n\tport = dev_to_port(dev);\n\tcard = port->card;\n\tdbg(DBG_TX, \"fst_start_xmit: length = %d\\n\", skb->len);\n\n\t/* Drop packet with error if we don't have carrier */\n\tif (!netif_carrier_ok(dev)) {\n\t\tdev_kfree_skb(skb);\n\t\tdev->stats.tx_errors++;\n\t\tdev->stats.tx_carrier_errors++;\n\t\tdbg(DBG_ASS,\n\t\t    \"Tried to transmit but no carrier on card %d port %d\\n\",\n\t\t    card->card_no, port->index);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t/* Drop it if it's too big! MTU failure ? */\n\tif (skb->len > LEN_TX_BUFFER) {\n\t\tdbg(DBG_ASS, \"Packet too large %d vs %d\\n\", skb->len,\n\t\t    LEN_TX_BUFFER);\n\t\tdev_kfree_skb(skb);\n\t\tdev->stats.tx_errors++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t/*\n\t * We are always going to queue the packet\n\t * so that the bottom half is the only place we tx from\n\t * Check there is room in the port txq\n\t */\n\tspin_lock_irqsave(&card->card_lock, flags);\n\tif ((txq_length = port->txqe - port->txqs) < 0) {\n\t\t/*\n\t\t * This is the case where the next free has wrapped but the\n\t\t * last used hasn't\n\t\t */\n\t\ttxq_length = txq_length + FST_TXQ_DEPTH;\n\t}\n\tspin_unlock_irqrestore(&card->card_lock, flags);\n\tif (txq_length > fst_txq_high) {\n\t\t/*\n\t\t * We have got enough buffers in the pipeline.  Ask the network\n\t\t * layer to stop sending frames down\n\t\t */\n\t\tnetif_stop_queue(dev);\n\t\tport->start = 1;\t/* I'm using this to signal stop sent up */\n\t}\n\n\tif (txq_length == FST_TXQ_DEPTH - 1) {\n\t\t/*\n\t\t * This shouldn't have happened but such is life\n\t\t */\n\t\tdev_kfree_skb(skb);\n\t\tdev->stats.tx_errors++;\n\t\tdbg(DBG_ASS, \"Tx queue overflow card %d port %d\\n\",\n\t\t    card->card_no, port->index);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t/*\n\t * queue the buffer\n\t */\n\tspin_lock_irqsave(&card->card_lock, flags);\n\tport->txq[port->txqe] = skb;\n\tport->txqe++;\n\tif (port->txqe == FST_TXQ_DEPTH)\n\t\tport->txqe = 0;\n\tspin_unlock_irqrestore(&card->card_lock, flags);\n\n\t/* Scehdule the bottom half which now does transmit processing */\n\tfst_q_work_item(&fst_work_txq, card->card_no);\n\ttasklet_schedule(&fst_tx_task);\n\n\treturn NETDEV_TX_OK;\n}\n\n/*\n *      Card setup having checked hardware resources.\n *      Should be pretty bizarre if we get an error here (kernel memory\n *      exhaustion is one possibility). If we do see a problem we report it\n *      via a printk and leave the corresponding interface and all that follow\n *      disabled.\n */\nstatic char *type_strings[] = {\n\t\"no hardware\",\t\t/* Should never be seen */\n\t\"FarSync T2P\",\n\t\"FarSync T4P\",\n\t\"FarSync T1U\",\n\t\"FarSync T2U\",\n\t\"FarSync T4U\",\n\t\"FarSync TE1\"\n};\n\nstatic void\nfst_init_card(struct fst_card_info *card)\n{\n\tint i;\n\tint err;\n\n\t/* We're working on a number of ports based on the card ID. If the\n\t * firmware detects something different later (should never happen)\n\t * we'll have to revise it in some way then.\n\t */\n\tfor (i = 0; i < card->nports; i++) {\n                err = register_hdlc_device(card->ports[i].dev);\n                if (err < 0) {\n\t\t\tint j;\n\t\t\tpr_err(\"Cannot register HDLC device for port %d (errno %d)\\n\",\n\t\t\t       i, -err);\n\t\t\tfor (j = i; j < card->nports; j++) {\n\t\t\t\tfree_netdev(card->ports[j].dev);\n\t\t\t\tcard->ports[j].dev = NULL;\n\t\t\t}\n                        card->nports = i;\n                        break;\n                }\n\t}\n\n\tpr_info(\"%s-%s: %s IRQ%d, %d ports\\n\",\n\t\tport_to_dev(&card->ports[0])->name,\n\t\tport_to_dev(&card->ports[card->nports - 1])->name,\n\t\ttype_strings[card->type], card->irq, card->nports);\n}\n\nstatic const struct net_device_ops fst_ops = {\n\t.ndo_open       = fst_open,\n\t.ndo_stop       = fst_close,\n\t.ndo_change_mtu = hdlc_change_mtu,\n\t.ndo_start_xmit = hdlc_start_xmit,\n\t.ndo_do_ioctl   = fst_ioctl,\n\t.ndo_tx_timeout = fst_tx_timeout,\n};\n\n/*\n *      Initialise card when detected.\n *      Returns 0 to indicate success, or errno otherwise.\n */\nstatic int\nfst_add_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstatic int no_of_cards_added = 0;\n\tstruct fst_card_info *card;\n\tint err = 0;\n\tint i;\n\n\tprintk_once(KERN_INFO\n\t\t    pr_fmt(\"FarSync WAN driver \" FST_USER_VERSION\n\t\t\t   \" (c) 2001-2004 FarSite Communications Ltd.\\n\"));\n#if FST_DEBUG\n\tdbg(DBG_ASS, \"The value of debug mask is %x\\n\", fst_debug_mask);\n#endif\n\t/*\n\t * We are going to be clever and allow certain cards not to be\n\t * configured.  An exclude list can be provided in /etc/modules.conf\n\t */\n\tif (fst_excluded_cards != 0) {\n\t\t/*\n\t\t * There are cards to exclude\n\t\t *\n\t\t */\n\t\tfor (i = 0; i < fst_excluded_cards; i++) {\n\t\t\tif ((pdev->devfn) >> 3 == fst_excluded_list[i]) {\n\t\t\t\tpr_info(\"FarSync PCI device %d not assigned\\n\",\n\t\t\t\t\t(pdev->devfn) >> 3);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Allocate driver private data */\n\tcard = kzalloc(sizeof(struct fst_card_info), GFP_KERNEL);\n\tif (card == NULL)\n\t\treturn -ENOMEM;\n\n\t/* Try to enable the device */\n\tif ((err = pci_enable_device(pdev)) != 0) {\n\t\tpr_err(\"Failed to enable card. Err %d\\n\", -err);\n\t\tkfree(card);\n\t\treturn err;\n\t}\n\n\tif ((err = pci_request_regions(pdev, \"FarSync\")) !=0) {\n\t\tpr_err(\"Failed to allocate regions. Err %d\\n\", -err);\n\t\tpci_disable_device(pdev);\n\t\tkfree(card);\n\t        return err;\n\t}\n\n\t/* Get virtual addresses of memory regions */\n\tcard->pci_conf = pci_resource_start(pdev, 1);\n\tcard->phys_mem = pci_resource_start(pdev, 2);\n\tcard->phys_ctlmem = pci_resource_start(pdev, 3);\n\tif ((card->mem = ioremap(card->phys_mem, FST_MEMSIZE)) == NULL) {\n\t\tpr_err(\"Physical memory remap failed\\n\");\n\t\tpci_release_regions(pdev);\n\t\tpci_disable_device(pdev);\n\t\tkfree(card);\n\t\treturn -ENODEV;\n\t}\n\tif ((card->ctlmem = ioremap(card->phys_ctlmem, 0x10)) == NULL) {\n\t\tpr_err(\"Control memory remap failed\\n\");\n\t\tpci_release_regions(pdev);\n\t\tpci_disable_device(pdev);\n\t\tiounmap(card->mem);\n\t\tkfree(card);\n\t\treturn -ENODEV;\n\t}\n\tdbg(DBG_PCI, \"kernel mem %p, ctlmem %p\\n\", card->mem, card->ctlmem);\n\n\t/* Register the interrupt handler */\n\tif (request_irq(pdev->irq, fst_intr, IRQF_SHARED, FST_DEV_NAME, card)) {\n\t\tpr_err(\"Unable to register interrupt %d\\n\", card->irq);\n\t\tpci_release_regions(pdev);\n\t\tpci_disable_device(pdev);\n\t\tiounmap(card->ctlmem);\n\t\tiounmap(card->mem);\n\t\tkfree(card);\n\t\treturn -ENODEV;\n\t}\n\n\t/* Record info we need */\n\tcard->irq = pdev->irq;\n\tcard->type = ent->driver_data;\n\tcard->family = ((ent->driver_data == FST_TYPE_T2P) ||\n\t\t\t(ent->driver_data == FST_TYPE_T4P))\n\t    ? FST_FAMILY_TXP : FST_FAMILY_TXU;\n\tif ((ent->driver_data == FST_TYPE_T1U) ||\n\t    (ent->driver_data == FST_TYPE_TE1))\n\t\tcard->nports = 1;\n\telse\n\t\tcard->nports = ((ent->driver_data == FST_TYPE_T2P) ||\n\t\t\t\t(ent->driver_data == FST_TYPE_T2U)) ? 2 : 4;\n\n\tcard->state = FST_UNINIT;\n        spin_lock_init ( &card->card_lock );\n\n        for ( i = 0 ; i < card->nports ; i++ ) {\n\t\tstruct net_device *dev = alloc_hdlcdev(&card->ports[i]);\n\t\thdlc_device *hdlc;\n\t\tif (!dev) {\n\t\t\twhile (i--)\n\t\t\t\tfree_netdev(card->ports[i].dev);\n\t\t\tpr_err(\"FarSync: out of memory\\n\");\n                        free_irq(card->irq, card);\n                        pci_release_regions(pdev);\n                        pci_disable_device(pdev);\n                        iounmap(card->ctlmem);\n                        iounmap(card->mem);\n                        kfree(card);\n                        return -ENODEV;\n\t\t}\n\t\tcard->ports[i].dev    = dev;\n                card->ports[i].card   = card;\n                card->ports[i].index  = i;\n                card->ports[i].run    = 0;\n\n\t\thdlc = dev_to_hdlc(dev);\n\n                /* Fill in the net device info */\n\t\t/* Since this is a PCI setup this is purely\n\t\t * informational. Give them the buffer addresses\n\t\t * and basic card I/O.\n\t\t */\n                dev->mem_start   = card->phys_mem\n                                 + BUF_OFFSET ( txBuffer[i][0][0]);\n                dev->mem_end     = card->phys_mem\n                                 + BUF_OFFSET ( txBuffer[i][NUM_TX_BUFFER][0]);\n                dev->base_addr   = card->pci_conf;\n                dev->irq         = card->irq;\n\n\t\tdev->netdev_ops = &fst_ops;\n\t\tdev->tx_queue_len = FST_TX_QUEUE_LEN;\n\t\tdev->watchdog_timeo = FST_TX_TIMEOUT;\n                hdlc->attach = fst_attach;\n                hdlc->xmit   = fst_start_xmit;\n\t}\n\n\tcard->device = pdev;\n\n\tdbg(DBG_PCI, \"type %d nports %d irq %d\\n\", card->type,\n\t    card->nports, card->irq);\n\tdbg(DBG_PCI, \"conf %04x mem %08x ctlmem %08x\\n\",\n\t    card->pci_conf, card->phys_mem, card->phys_ctlmem);\n\n\t/* Reset the card's processor */\n\tfst_cpureset(card);\n\tcard->state = FST_RESET;\n\n\t/* Initialise DMA (if required) */\n\tfst_init_dma(card);\n\n\t/* Record driver data for later use */\n\tpci_set_drvdata(pdev, card);\n\n\t/* Remainder of card setup */\n\tfst_card_array[no_of_cards_added] = card;\n\tcard->card_no = no_of_cards_added++;\t/* Record instance and bump it */\n\tfst_init_card(card);\n\tif (card->family == FST_FAMILY_TXU) {\n\t\t/*\n\t\t * Allocate a dma buffer for transmit and receives\n\t\t */\n\t\tcard->rx_dma_handle_host =\n\t\t    pci_alloc_consistent(card->device, FST_MAX_MTU,\n\t\t\t\t\t &card->rx_dma_handle_card);\n\t\tif (card->rx_dma_handle_host == NULL) {\n\t\t\tpr_err(\"Could not allocate rx dma buffer\\n\");\n\t\t\tfst_disable_intr(card);\n\t\t\tpci_release_regions(pdev);\n\t\t\tpci_disable_device(pdev);\n\t\t\tiounmap(card->ctlmem);\n\t\t\tiounmap(card->mem);\n\t\t\tkfree(card);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tcard->tx_dma_handle_host =\n\t\t    pci_alloc_consistent(card->device, FST_MAX_MTU,\n\t\t\t\t\t &card->tx_dma_handle_card);\n\t\tif (card->tx_dma_handle_host == NULL) {\n\t\t\tpr_err(\"Could not allocate tx dma buffer\\n\");\n\t\t\tfst_disable_intr(card);\n\t\t\tpci_release_regions(pdev);\n\t\t\tpci_disable_device(pdev);\n\t\t\tiounmap(card->ctlmem);\n\t\t\tiounmap(card->mem);\n\t\t\tkfree(card);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\t\t/* Success */\n}\n\n/*\n *      Cleanup and close down a card\n */\nstatic void\nfst_remove_one(struct pci_dev *pdev)\n{\n\tstruct fst_card_info *card;\n\tint i;\n\n\tcard = pci_get_drvdata(pdev);\n\n\tfor (i = 0; i < card->nports; i++) {\n\t\tstruct net_device *dev = port_to_dev(&card->ports[i]);\n\t\tunregister_hdlc_device(dev);\n\t}\n\n\tfst_disable_intr(card);\n\tfree_irq(card->irq, card);\n\n\tiounmap(card->ctlmem);\n\tiounmap(card->mem);\n\tpci_release_regions(pdev);\n\tif (card->family == FST_FAMILY_TXU) {\n\t\t/*\n\t\t * Free dma buffers\n\t\t */\n\t\tpci_free_consistent(card->device, FST_MAX_MTU,\n\t\t\t\t    card->rx_dma_handle_host,\n\t\t\t\t    card->rx_dma_handle_card);\n\t\tpci_free_consistent(card->device, FST_MAX_MTU,\n\t\t\t\t    card->tx_dma_handle_host,\n\t\t\t\t    card->tx_dma_handle_card);\n\t}\n\tfst_card_array[card->card_no] = NULL;\n}\n\nstatic struct pci_driver fst_driver = {\n        .name\t\t= FST_NAME,\n        .id_table\t= fst_pci_dev_id,\n        .probe\t\t= fst_add_one,\n        .remove\t= fst_remove_one,\n        .suspend\t= NULL,\n        .resume\t= NULL,\n};\n\nstatic int __init\nfst_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < FST_MAX_CARDS; i++)\n\t\tfst_card_array[i] = NULL;\n\tspin_lock_init(&fst_work_q_lock);\n\treturn pci_register_driver(&fst_driver);\n}\n\nstatic void __exit\nfst_cleanup_module(void)\n{\n\tpr_info(\"FarSync WAN driver unloading\\n\");\n\tpci_unregister_driver(&fst_driver);\n}\n\nmodule_init(fst_init);\nmodule_exit(fst_cleanup_module);\n"], "filenames": ["drivers/net/wan/farsync.c"], "buggy_code_start_loc": [1974], "buggy_code_end_loc": [1974], "fixing_code_start_loc": [1975], "fixing_code_end_loc": [1976], "type": "CWE-399", "message": "The fst_get_iface function in drivers/net/wan/farsync.c in the Linux kernel before 3.11.7 does not properly initialize a certain data structure, which allows local users to obtain sensitive information from kernel memory by leveraging the CAP_NET_ADMIN capability for an SIOCWANDEV ioctl call.", "other": {"cve": {"id": "CVE-2014-1444", "sourceIdentifier": "cve@mitre.org", "published": "2014-01-18T22:55:03.257", "lastModified": "2017-08-29T01:34:24.950", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The fst_get_iface function in drivers/net/wan/farsync.c in the Linux kernel before 3.11.7 does not properly initialize a certain data structure, which allows local users to obtain sensitive information from kernel memory by leveraging the CAP_NET_ADMIN capability for an SIOCWANDEV ioctl call."}, {"lang": "es", "value": "La funci\u00f3n fst_get_iface en drivers/net/wan/farsync.c del kernel Linux anteriores a 3.11.7 no inicializa apropiadamente cierta estructura de datos, lo cual permite a usuarios locales obtener informaci\u00f3n sensible de la memoria dle kernel, aprovechando la funcionalidad CAP_NET_ADMIN para una llamada SIOCWANDEV ioctl."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 1.7}, "baseSeverity": "LOW", "exploitabilityScore": 3.1, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.11.6", "matchCriteriaId": "C3D55C7B-D6AF-4DB4-8CCC-3BFC8C15F45D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11:*:*:*:*:*:*:*", "matchCriteriaId": "639E3A57-A9E7-40E6-8929-81CCC0060EFB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.1:*:*:*:*:*:*:*", "matchCriteriaId": "07012ADD-F521-40A8-B067-E87C2238A3D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.2:*:*:*:*:*:*:*", "matchCriteriaId": "3F5FF393-3F89-4274-B82B-F671358072ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.3:*:*:*:*:*:*:*", "matchCriteriaId": "E348698F-54D1-4F5E-B701-CFAF50881E0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.4:*:*:*:*:*:*:*", "matchCriteriaId": "932205D9-3514-4289-9B55-C7A169276930"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.5:*:*:*:*:*:*:*", "matchCriteriaId": "2ECB2D33-F517-480F-8A6F-99D9D6C49596"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=96b340406724d87e4621284ebac5e059d67b2194", "source": "cve@mitre.org"}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.11.7", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2014/01/15/3", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://www.securityfocus.com/bid/64952", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2128-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2129-1", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1053610", "source": "cve@mitre.org"}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/90443", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/96b340406724d87e4621284ebac5e059d67b2194", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/96b340406724d87e4621284ebac5e059d67b2194"}}