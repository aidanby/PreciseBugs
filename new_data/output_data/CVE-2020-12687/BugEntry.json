{"buggy_code": ["require 'sinatra'\nrequire 'zip'\n\nconfig_options = JSON.parse(File.read('./config.json'))\n\n# set the report_assessment_types for <1.2 versions of Serpico\nunless config_options['report_assessment_types']\n  config_options['report_assessment_types'] = ['Network Internal', 'External', 'Web application', 'Physical', 'Social engineering', 'Configuration audit']\nend\n\n######\n# Admin Interfaces\n######\n\nget '/admin/' do\n  redirect to('/no_access') unless is_administrator?\n  @admin = true\n\n  haml :admin\nend\n\nget '/admin/add_user' do\n  redirect to('/no_access') unless is_administrator?\n  @admin = true\n\n  haml :add_user\nend\n\n# serve a copy of the code\nget '/admin/pull' do\n  redirect to('/no_access') unless is_administrator?\n\n  if File.exist?('./export.zip')\n    send_file './export.zip', filename: 'export.zip', type: 'Application/octet-stream'\n    serpico_log(\"Copy of code exported\")\n  else\n    'No copy of the code available. Run scripts/make_export.sh.'\n  end\nend\n\n# create DB backup\nget '/admin/dbbackup' do\n  redirect to('/no_access') unless is_administrator?\n  bdate = Time.now\n  filename = './tmp/master' + '-' + (bdate.strftime('%Y%m%d%H%M%S') + '.bak')\n  FileUtils.copy_file('./db/master.db', filename)\n  if !File.zero?(filename)\n    send_file filename, filename: filename.to_s, type: 'Application/octet-stream'\n    serpico_log(\"DB backup created\")\n  else\n    'No copy of the database is available. Please try again.'\n    sleep(5)\n    redirect to('/admin/')\n   end\nend\n\n# create backup of all attachments\nget '/admin/attacments_backup' do\n  bdate = Time.now\n  zip_file = './tmp/Attachments' + '-' + (bdate.strftime('%Y%m%d%H%M%S') + '.zip')\n  Zip::File.open(zip_file, Zip::File::CREATE) do |zipfile|\n    Dir['./attachments/*'].each do |name|\n      zipfile.add(name.split('/').last, name)\n    end\n  end\n  send_file zip_file, type: 'zip', filename: zip_file\n  # File.delete(rand_zip) should the temp file be deleted?\n  serpico_log(\"Backup of attachments created\")\nend\n\n# Create a new user\npost '/admin/add_user' do\n  redirect to('/no_access') unless is_administrator?\n\n  user = User.first(username: params[:username])\n\n  if user\n    if params[:password] && (params[:password].size > 1)\n      # we have to hardcode the input params to prevent param pollution\n      user.update(type: params[:type], auth_type: params[:auth_type], password: params[:password])\n    else\n      # we have to hardcode the params to prevent param pollution\n      user.update(type: params[:type], auth_type: params[:auth_type])\n    end\n  else\n    user = User.new\n    user.username = params[:username]\n    user.password = params[:password]\n    user.type = params[:type]\n    user.auth_type = params[:auth_type]\n    user.save\n  end\n\n  serpico_log(\"User #{user.username} created\")\n  redirect to('/admin/list_user')\nend\n\nget '/admin/list_user' do\n  redirect to('/no_access') unless is_administrator?\n  @admin = true\n  @users = User.all\n  @plugin = is_plugin?\n\n  haml :list_user\nend\n\nget '/admin/edit_user/:id' do\n  redirect to('/no_access') unless is_administrator?\n\n  @user = User.first(id: params[:id])\n  haml :add_user\nend\n\nget '/admin/delete/:id' do\n  redirect to('/no_access') unless is_administrator?\n\n  @user = User.first(id: params[:id])\n  @user.destroy if @user\n\n  serpico_log(\"User #{@user.username} deleted\")\n\n  redirect to('/admin/list_user')\nend\n\nget '/admin/add_user/:id' do\n  unless is_administrator?\n    id = params[:id]\n    redirect to('/no_access') unless get_report(id)\n  end\n\n  @users = User.all(order: [:username.asc])\n  @report = Reports.first(id: params[:id])\n\n  @admin = true if is_administrator?\n\n  haml :add_user_report\nend\n\npost '/admin/add_user/:id' do\n  unless is_administrator?\n    id = params[:id]\n    redirect to('/no_access') unless get_report(id)\n  end\n\n  report = Reports.first(id: params[:id])\n\n  return 'No Such Report' if report.nil?\n\n  authors = report.authors\n\n  authors = if authors\n              authors.push(params[:author])\n            else\n              [params[:author].to_s]\n            end\n\n  report.authors = authors\n  report.save\n  serpico_log(\"User added to report\")\n  redirect to(\"/admin/add_user/#{params[:id]}\")\nend\n\nget '/admin/del_user_report/:id/:author' do\n  unless is_administrator?\n    id = params[:id]\n    redirect to('/no_access') unless get_report(id)\n  end\n\n  report = Reports.first(id: params[:id])\n\n  return 'No Such Report' if report.nil?\n\n  authors = report.authors\n\n  authors -= [params[:author].to_s] if authors\n\n  report.authors = authors\n  report.save\n  serpico_log(\"User removed from report\")\n  redirect to(\"/admin/add_user/#{params[:id]}\")\nend\n\nget '/admin/config' do\n  redirect to('/no_access') unless is_administrator?\n\n  @config = config_options\n  @scoring = if config_options['cvss']\n               'cvss'\n             elsif config_options['cvssv3']\n               'cvssv3'\n             elsif config_options['dread']\n               'dread'\n             elsif config_options['riskmatrix']\n               'riskmatrix'\n             elsif config_options[\"nist800\"]\n               'nist800'\n              else\n               'default'\n             end\n\n  haml :config\nend\n\npost '/admin/config' do\n  redirect to('/no_access') unless is_administrator?\n\n  ft = params['finding_types'].split(',')\n  udv = params['user_defined_variables'].split(',')\n  rat = params['report_assessment_types'].split(',')\n  lang = params['languages'].delete(' ').split(',')\n\n  config_options['effort'] = params['effort'].split(',') if params['effort']\n\n  config_options['finding_types'] = ft\n  config_options['user_defined_variables'] = udv\n  config_options['port'] = params['port']\n  config_options['report_assessment_types'] = rat\n  config_options['languages'] = lang\n  config_options['use_ssl'] = params['use_ssl'] ? true : false\n  config_options['bind_address'] = params['bind_address']\n  config_options['ldap'] = params['ldap'] ? true : false\n  config_options['ldap_domain'] = params['ldap_domain']\n  config_options['ldap_dc'] = params['ldap_dc']\n  config_options['burpmap'] = params['burpmap'] ? true : false\n  config_options['nessusmap'] = params['nessusmap'] ? true : false\n  config_options['vulnmap'] = params['vulnmap'] ? true : false\n  config_options['logo'] = params['logo']\n  config_options['auto_import'] = params['auto_import'] ? true : false\n  config_options['chart'] = params['chart'] ? true : false\n  config_options['threshold'] = params['threshold']\n  config_options['show_exceptions'] = params['show_exceptions'] ? true : false\n  config_options['cvssv2_scoring_override'] = params['cvssv2_scoring_override'] ? true : false\n\n  if params['risk_scoring'] == 'CVSSv2'\n    config_options['dread'] = false\n    config_options['cvss'] = true\n    config_options['cvssv3'] = false\n    config_options['riskmatrix'] = false\n    config_options['nist800'] = false\n  elsif params['risk_scoring'] == 'CVSSv3'\n    config_options['dread'] = false\n    config_options['cvss'] = false\n    config_options['cvssv3'] = true\n    config_options['riskmatrix'] = false\n    config_options['nist800'] = false\n  elsif params['risk_scoring'] == 'DREAD'\n    config_options['dread'] = true\n    config_options['cvss'] = false\n    config_options['cvssv3'] = false\n    config_options['riskmatrix'] = false\n    config_options['nist800'] = false\n  elsif params['risk_scoring'] == 'RISKMATRIX'\n    config_options['dread'] = false\n    config_options['cvss'] = false\n    config_options['cvssv3'] = false\n    config_options['riskmatrix'] = true\n    config_options['nist800'] = false\n  elsif params['risk_scoring'] == 'NIST800-30'\n  \tconfig_options['dread'] = false\n    config_options['cvss'] = false\n    config_options['cvssv3'] = false\n    config_options['riskmatrix'] = false\n    config_options['nist800'] = true\n  else\n    config_options['dread'] = false\n    config_options['cvss'] = false\n    config_options['cvssv3'] = false\n    config_options['riskmatrix'] = false\n    config_options['nist800'] = false\n  end\n\n  File.open('./config.json', 'w') do |f|\n    f.write(JSON.pretty_generate(config_options))\n    serpico_log(\"Configuration file modified\")\n  end\n  redirect to('/admin/config')\nend\n\n# get plugins available\nget '/admin/plugins' do\n  redirect to('/no_access') unless is_administrator?\n\n  @plugins = []\n  Dir[File.join(File.dirname(__FILE__), '../plugins/**/', '*.json')].each do |lib|\n    @plugins.push(JSON.parse(File.open(lib).read))\n  end\n\n  @admin = true if is_administrator?\n  @plugin = true if is_plugin?\n\n  haml :plugins\nend\n\n# enable plugins\npost '/admin/plugins' do\n  redirect to('/no_access') unless is_administrator?\n\n  @plugins = []\n  Dir[File.join(File.dirname(__FILE__), '../plugins/**/', '*.json')].each do |lib|\n    @plugins.push(JSON.parse(File.open(lib).read))\n  end\n\n  @plugins.each do |plug|\n    if params[plug['name']]\n      plug['enabled'] = true\n      File.open(\"./plugins/#{plug['name']}/plugin.json\", 'w') do |f|\n        f.write(JSON.pretty_generate(plug))\n        serpico_log(\"Plugin #{plug['name']} enabled\")\n      end\n    else\n      plug['enabled'] = false\n      File.open(\"./plugins/#{plug['name']}/plugin.json\", 'w') do |f|\n        f.write(JSON.pretty_generate(plug))\n        serpico_log(\"Plugin #{plug['name']} disabled\")\n      end\n    end\n  end\n\n  redirect to('/admin/plugins')\nend\n\n# upload plugin zip\npost '/admin/plugin_upload' do\n  redirect to('/no_access') unless is_administrator?\n  redirect to('/no_access') unless is_plugin?\n\n  # take each zip in turn\n  params['files'].map do |upf|\n    # We use a random filename\n    rand_file = \"./tmp/#{rand(36**36).to_s(36)}\"\n\n    # reject if the file is above a certain limit\n    return 'File too large. 100MB limit' if upf[:tempfile].size > 100_000_000\n\n    # unzip the plugin and write it to the fs, writing the OS is possible but so is RCE\n    File.open(rand_file, 'wb') { |f| f.write(upf[:tempfile].read) }\n\n    # find the config.json file\n    config = ''\n    Zip::File.open(rand_file) do |zipfile|\n      # read the config file\n      zipfile.each do |entry|\n        if entry.name == 'plugin.json'\n          configj = entry.get_input_stream.read\n          config = JSON.parse(configj)\n          serpico_log(\"Custom plugin uploaded\")\n        end\n      end\n    end\n\n    return 'plugin.json does not exist in zip.' if config == ''\n\n    Zip::File.open(rand_file) do |zipfile|\n      # read the config file\n      zipfile.each do |entry|\n        # Extract to file/directory/symlink\n        fn = \"./plugins/#{config['name']}/\" + entry.name\n\n        # create the directory if dne\n        dirj = fn.split('/')\n        dirj.pop\n        FileUtils.mkdir_p(dirj.join('/')) unless File.directory?(dirj.join('/'))\n\n        next if fn[-1] == '/'\n        # Read into memory\n        content = entry.get_input_stream.read\n\n        File.open(fn, 'a') do |f|\n          f.write(content)\n        end\n      end\n    end\n  end\n  redirect to('/admin/plugins')\nend\n\n# Manage Templated Reports\nget '/admin/templates' do\n  redirect to('/no_access') unless is_administrator?\n\n  @admin = true\n\n  # Query for all Findings\n  @templates = Xslt.all(order: [:report_type.asc])\n\n  haml :template_list\nend\n\n# Manage Templated Reports\nget '/admin/templates/add' do\n  redirect to('/no_access') unless is_administrator?\n\n  @admin = true\n\n  haml :add_template\nend\n\n# Manage Templated Reports\nget '/admin/templates/:id/download' do\n  redirect to('/no_access') unless is_administrator?\n\n  @admin = true\n\n  xslt = Xslt.first(id: params[:id])\n\n  send_file xslt.docx_location, type: 'docx', filename: \"#{xslt.report_type}.docx\"\nend\n\nget '/admin/delete/templates/:id' do\n  redirect to('/no_access') unless is_administrator?\n\n  @xslt = Xslt.first(id: params[:id])\n\n  if @xslt\n    @xslt.components.destroy\n    @xslt.destroy\n    File.delete(@xslt.xslt_location) if File.file?(@xslt.xslt_location)\n    File.delete(@xslt.docx_location) if File.file?(@xslt.docx_location)\n    serpico_log(\"Report template deleted\")\n  end\n  redirect to('/admin/templates')\nend\n\n# Manage Templated Reports\npost '/admin/templates/add' do\n  redirect to('/no_access') unless is_administrator?\n\n  @admin = true\n\n  xslt_file = \"./templates/#{rand(36**36).to_s(36)}.xslt\"\n\n  redirect to('/admin/templates/add') unless params[:file]\n\n  # reject if the file is above a certain limit\n  if params[:file][:tempfile].size > 100_000_000\n    return 'File too large. 10MB limit'\n  end\n\n  docx = \"./templates/#{rand(36**36).to_s(36)}.docx\"\n  File.open(docx, 'wb') { |f| f.write(params[:file][:tempfile].read) }\n\n  error = false\n  detail = ''\n  begin\n    xslt = generate_xslt(docx)\n    xslt_components = generate_xslt_components(docx)\n  rescue TemplateVerificationError => detail\n    @error_message = CGI::escapeHTML(detail.errorString)\n    @tree = CGI::escapeHTML(detail.template_tree)\n    return haml :template_error\n  rescue ReportingError => detail\n    error = true\n  end\n\n  if error\n    \"The report template you uploaded threw an error when parsing:<p><p> #{detail.errorString}\"\n  else\n    # open up a file handle and write the attachment\n    File.open(xslt_file, 'wb') { |f| f.write(xslt) }\n    # extract the screenshot names from the file\n    screenshot_names = xslt.scan(/\\[!!(.*?)!!\\]/)\n    # delete the file data from the attachment\n    datax = {}\n    # to prevent traversal we hardcode this\n    datax['docx_location'] = docx.to_s\n    datax['xslt_location'] = xslt_file.to_s\n    datax['description'] =\tparams[:description]\n    datax['report_type'] = params[:report_type]\n    datax['screenshot_names'] = screenshot_names.join(',')\n    data = url_escape_hash(datax)\n    data['finding_template'] = params[:finding_template] ? true : false\n    data['status_template'] = params[:status_template] ? true : false\n\n    @template = Xslt.first(report_type: data['report_type'])\n\n    if @template\n      @template.update(xslt_location: data['xslt_location'], docx_location: data['docx_location'], description: data['description'], screenshot_names: data['screenshot_names'])\n      @template.components.destroy\n    else\n      @template = Xslt.new(data)\n      @template.save\n    end\n\n    # create a xslt file for each component\n    list_components_files = []\n    xslt_components.each do |component_name, component_xslt|\n      componentHash = {}\n      componentHash['xslt_location'] = \"./templates/#{rand(36**36).to_s(36)}.xslt\"\n      componentHash['name'] = component_name\n      componentHash['xslt'] = @template\n      File.open(componentHash['xslt_location'], 'wb') { |f| f.write(component_xslt) }\n      list_components_files.push(componentHash)\n    end\n\n    # insert components into the db\n    list_components_files.each do |component|\n      @component = Xslt_component.new(component)\n      @component.save\n    end\n    serpico_log(\"New report template successfully added\")\n    redirect to('/admin/templates')\n\n    haml :add_template\n  end\nend\n\nget '/admin/templates/:id/tree' do\n  redirect to('/no_access') unless is_administrator?\n  @admin = true\n  xslt = Xslt.first(id: params[:id])\n  document = read_rels(xslt.docx_location,\"word/document.xml\")\n  @tree = verify_document(document)\n  @tree = @tree[2]\n\n  haml :template_tree\nend\n# Manage Templated Reports\nget '/admin/templates/:id/edit' do\n  redirect to('/no_access') unless is_administrator?\n\n  @admin = true\n  @template = Xslt.first(id: params[:id])\n\n  haml :edit_template\nend\n\n# Manage Templated Reports\npost '/admin/templates/edit' do\n  redirect to('/no_access') unless is_administrator?\n\n  @admin = true\n  template = Xslt.first(id: params[:id])\n\n  xslt_file = template.xslt_location\n\n  redirect to(\"/admin/templates/#{params[:id]}/edit\") unless params[:file]\n\n  # reject if the file is above a certain limit\n  if params[:file][:tempfile].size > 100_000_000\n    return 'File too large. 10MB limit'\n  end\n\n  docx = \"./templates/#{rand(36**36).to_s(36)}.docx\"\n  File.open(docx, 'wb') { |f| f.write(params[:file][:tempfile].read) }\n\n  error = false\n  detail = ''\n  begin\n    xslt = generate_xslt(docx)\n    xslt_components = generate_xslt_components(docx)\n  rescue TemplateVerificationError => detail\n    @error_message = CGI::escapeHTML(detail.errorString)\n    @tree = CGI::escapeHTML(detail.template_tree)\n    return haml :template_error\n  rescue ReportingError => detail\n    error = true\n  end\n\n  if error\n    \"The report template you uploaded threw an error when parsing:<p><p> #{detail.errorString}\"\n  else\n\n    # open up a file handle and write the attachment\n    File.open(xslt_file, 'wb') { |f| f.write(xslt) }\n    # extract the screenshot names from the file\n    screenshot_names = xslt.scan(/\\[!!(.*?)!!\\]/)\n    # delete the file data from the attachment\n    datax = {}\n    # to prevent traversal we hardcode this\n    datax['docx_location'] = docx.to_s\n    datax['xslt_location'] = xslt_file.to_s\n    datax['description'] =\tparams[:description]\n    datax['report_type'] = params[:report_type]\n    datax['screenshot_names'] = screenshot_names.join(',')\n    data = url_escape_hash(datax)\n    data['finding_template'] = params[:finding_template] ? true : false\n    data['status_template'] = params[:status_template] ? true : false\n\n    @template = Xslt.first(report_type: data['report_type'])\n\n    if @template\n      @template.update(xslt_location: data['xslt_location'], docx_location: data['docx_location'], description: data['description'], screenshot_names: data['screenshot_names'])\n      @template.components.destroy\n    else\n      @template = Xslt.new(data)\n      @template.save\n    end\n\n    # create a xslt file for each component\n    list_components_files = []\n    xslt_components.each do |component_name, component_xslt|\n      componentHash = {}\n      componentHash['xslt_location'] = \"./templates/#{rand(36**36).to_s(36)}.xslt\"\n      componentHash['name'] = component_name\n      componentHash['xslt'] = @template\n      File.open(componentHash['xslt_location'], 'wb') { |f| f.write(component_xslt) }\n      list_components_files.push(componentHash)\n    end\n\n    # insert components into the db\n    list_components_files.each do |component|\n      @component = Xslt_component.new(component)\n      @component.save\n    end\n    serpico_log(\"Report template modified\")\n    redirect to('/admin/templates')\nend\nend\n\n# get enabled plugins\nget '/admin/admin_plugins' do\n\n  @admin = true if is_administrator?\n  @plugin = true if is_plugin?\n\n  @menu = get_plugin_list('admin')\n  haml :enabled_plugins\nend\n\nget '/admin/udo_templates' do\n  redirect to('/no_access') unless is_administrator?\n\n  # delete UDO template part\n  if params[:delete]\n    udo_template = UserDefinedObjectTemplates.get(params[:delete])\n    return 'UDO Template not found' if udo_template.nil?\n    udo_template.destroy\n  end\n  @udos_templates = UserDefinedObjectTemplates.all\n\n  @admin = true if is_administrator?\n  @plugin = true if is_plugin?\n\n  haml :user_defined_object_templates\nend\n\npost '/admin/udo_templates' do\n  redirect to('/no_access') unless is_administrator?\n  data = url_escape_hash(request.POST)\n\n  # Save new UDO template part\n  if data['action'] = 'Save'\n    new_udo_template = UserDefinedObjectTemplates.new\n    new_udo_template.type = data['object_type']\n    udo_properties = {}\n    # we extract the udo properties from the posted data\n    data.each do |param, value|\n      if param =~ /property_/\n        udo_properties[value] = '' unless value.to_s.empty?\n      end\n    end\n    new_udo_template.udo_properties = udo_properties.to_json\n    new_udo_template.save\n  end\n\n  @udos_templates = UserDefinedObjectTemplates.all\n\n  serpico_log(\"UDO template added\")\n  redirect to('/admin/udo_templates')\nend\n\n# edit udo template\nget '/admin/udo_template/:template_id/edit' do\n  redirect to('/no_access') unless is_administrator?\n  @udo_to_edit = UserDefinedObjectTemplates.get(params[:template_id])\n  return 'No such UDO Template' if @udo_to_edit.nil?\n  @udo_to_edit_properties = JSON.parse(@udo_to_edit.udo_properties)\n\n  @admin = true if is_administrator?\n  @plugin = true if is_plugin?\n\n  haml :udo_template_edit\nend\n\npost '/admin/udo_template/:template_id/edit' do\n  redirect to('/no_access') unless is_administrator?\n  data = url_escape_hash(request.POST)\n  @udo_to_edit = UserDefinedObjectTemplates.get(params[:template_id])\n  return 'No such UDO Template' if @udo_to_edit.nil?\n  @udo_to_edit_properties = JSON.parse(@udo_to_edit.udo_properties)\n\n  udo_properties = {}\n  # we extract the udo properties from the posted data\n  data.each do |param1, value1|\n    unless value1.to_s.empty?\n      # we add the new properties\n      if param1 =~ /prop_new_\\d+/\n        id = param1.split('_')[2]\n        data.each do |param2, value2|\n          next unless param2 =~ /default_new_#{id}/\n          udo_properties[value1] = if value2 !~ /\\<paragraph\\>/\n                                     \"<paragraph>#{value2}</paragraph>\"\n                                   else\n                                     value2\n                                   end\n        end\n\n        # we edit the already existing properties\n      elsif param1 =~ /prop_/\n        data.each do |param2, value2|\n          next unless param2 =~ /default_#{param1.split(\"_\")[-1]}/\n          udo_properties[value1] = if value2 !~ /\\<paragraph\\>/\n                                     \"<paragraph>#{value2}</paragraph>\"\n                                   else\n                                     value2\n                                   end\n        end\n      end\n    end\n  end\n  @udo_to_edit.udo_properties = udo_properties.to_json\n  @udo_to_edit.save\n  serpico_log(\"UDO template modified\")\n  redirect to('/admin/udo_templates')\nend\n"], "fixing_code": ["require 'sinatra'\nrequire 'zip'\n\nconfig_options = JSON.parse(File.read('./config.json'))\n\n# set the report_assessment_types for <1.2 versions of Serpico\nunless config_options['report_assessment_types']\n  config_options['report_assessment_types'] = ['Network Internal', 'External', 'Web application', 'Physical', 'Social engineering', 'Configuration audit']\nend\n\n######\n# Admin Interfaces\n######\n\nget '/admin/' do\n  redirect to('/no_access') unless is_administrator?\n  @admin = true\n\n  haml :admin\nend\n\nget '/admin/add_user' do\n  redirect to('/no_access') unless is_administrator?\n  @admin = true\n\n  haml :add_user\nend\n\n# serve a copy of the code\nget '/admin/pull' do\n  redirect to('/no_access') unless is_administrator?\n\n  if File.exist?('./export.zip')\n    send_file './export.zip', filename: 'export.zip', type: 'Application/octet-stream'\n    serpico_log(\"Copy of code exported\")\n  else\n    'No copy of the code available. Run scripts/make_export.sh.'\n  end\nend\n\n# create DB backup\nget '/admin/dbbackup' do\n  redirect to('/no_access') unless is_administrator?\n  bdate = Time.now\n  filename = './tmp/master' + '-' + (bdate.strftime('%Y%m%d%H%M%S') + '.bak')\n  FileUtils.copy_file('./db/master.db', filename)\n  if !File.zero?(filename)\n    send_file filename, filename: filename.to_s, type: 'Application/octet-stream'\n    serpico_log(\"DB backup created\")\n  else\n    'No copy of the database is available. Please try again.'\n    sleep(5)\n    redirect to('/admin/')\n   end\nend\n\n# create backup of all attachments\nget '/admin/attacments_backup' do\n  redirect to('/no_access') unless is_administrator?\n  bdate = Time.now\n  zip_file = './tmp/Attachments' + '-' + (bdate.strftime('%Y%m%d%H%M%S') + '.zip')\n  Zip::File.open(zip_file, Zip::File::CREATE) do |zipfile|\n    Dir['./attachments/*'].each do |name|\n      zipfile.add(name.split('/').last, name)\n    end\n  end\n  send_file zip_file, type: 'zip', filename: zip_file\n  # File.delete(rand_zip) should the temp file be deleted?\n  serpico_log(\"Backup of attachments created\")\nend\n\n# Create a new user\npost '/admin/add_user' do\n  redirect to('/no_access') unless is_administrator?\n\n  user = User.first(username: params[:username])\n\n  if user\n    if params[:password] && (params[:password].size > 1)\n      # we have to hardcode the input params to prevent param pollution\n      user.update(type: params[:type], auth_type: params[:auth_type], password: params[:password])\n    else\n      # we have to hardcode the params to prevent param pollution\n      user.update(type: params[:type], auth_type: params[:auth_type])\n    end\n  else\n    user = User.new\n    user.username = params[:username]\n    user.password = params[:password]\n    user.type = params[:type]\n    user.auth_type = params[:auth_type]\n    user.save\n  end\n\n  serpico_log(\"User #{user.username} created\")\n  redirect to('/admin/list_user')\nend\n\nget '/admin/list_user' do\n  redirect to('/no_access') unless is_administrator?\n  @admin = true\n  @users = User.all\n  @plugin = is_plugin?\n\n  haml :list_user\nend\n\nget '/admin/edit_user/:id' do\n  redirect to('/no_access') unless is_administrator?\n\n  @user = User.first(id: params[:id])\n  haml :add_user\nend\n\nget '/admin/delete/:id' do\n  redirect to('/no_access') unless is_administrator?\n\n  @user = User.first(id: params[:id])\n  @user.destroy if @user\n\n  serpico_log(\"User #{@user.username} deleted\")\n\n  redirect to('/admin/list_user')\nend\n\nget '/admin/add_user/:id' do\n  unless is_administrator?\n    id = params[:id]\n    redirect to('/no_access') unless get_report(id)\n  end\n\n  @users = User.all(order: [:username.asc])\n  @report = Reports.first(id: params[:id])\n\n  @admin = true if is_administrator?\n\n  haml :add_user_report\nend\n\npost '/admin/add_user/:id' do\n  unless is_administrator?\n    id = params[:id]\n    redirect to('/no_access') unless get_report(id)\n  end\n\n  report = Reports.first(id: params[:id])\n\n  return 'No Such Report' if report.nil?\n\n  authors = report.authors\n\n  authors = if authors\n              authors.push(params[:author])\n            else\n              [params[:author].to_s]\n            end\n\n  report.authors = authors\n  report.save\n  serpico_log(\"User added to report\")\n  redirect to(\"/admin/add_user/#{params[:id]}\")\nend\n\nget '/admin/del_user_report/:id/:author' do\n  unless is_administrator?\n    id = params[:id]\n    redirect to('/no_access') unless get_report(id)\n  end\n\n  report = Reports.first(id: params[:id])\n\n  return 'No Such Report' if report.nil?\n\n  authors = report.authors\n\n  authors -= [params[:author].to_s] if authors\n\n  report.authors = authors\n  report.save\n  serpico_log(\"User removed from report\")\n  redirect to(\"/admin/add_user/#{params[:id]}\")\nend\n\nget '/admin/config' do\n  redirect to('/no_access') unless is_administrator?\n\n  @config = config_options\n  @scoring = if config_options['cvss']\n               'cvss'\n             elsif config_options['cvssv3']\n               'cvssv3'\n             elsif config_options['dread']\n               'dread'\n             elsif config_options['riskmatrix']\n               'riskmatrix'\n             elsif config_options[\"nist800\"]\n               'nist800'\n              else\n               'default'\n             end\n\n  haml :config\nend\n\npost '/admin/config' do\n  redirect to('/no_access') unless is_administrator?\n\n  ft = params['finding_types'].split(',')\n  udv = params['user_defined_variables'].split(',')\n  rat = params['report_assessment_types'].split(',')\n  lang = params['languages'].delete(' ').split(',')\n\n  config_options['effort'] = params['effort'].split(',') if params['effort']\n\n  config_options['finding_types'] = ft\n  config_options['user_defined_variables'] = udv\n  config_options['port'] = params['port']\n  config_options['report_assessment_types'] = rat\n  config_options['languages'] = lang\n  config_options['use_ssl'] = params['use_ssl'] ? true : false\n  config_options['bind_address'] = params['bind_address']\n  config_options['ldap'] = params['ldap'] ? true : false\n  config_options['ldap_domain'] = params['ldap_domain']\n  config_options['ldap_dc'] = params['ldap_dc']\n  config_options['burpmap'] = params['burpmap'] ? true : false\n  config_options['nessusmap'] = params['nessusmap'] ? true : false\n  config_options['vulnmap'] = params['vulnmap'] ? true : false\n  config_options['logo'] = params['logo']\n  config_options['auto_import'] = params['auto_import'] ? true : false\n  config_options['chart'] = params['chart'] ? true : false\n  config_options['threshold'] = params['threshold']\n  config_options['show_exceptions'] = params['show_exceptions'] ? true : false\n  config_options['cvssv2_scoring_override'] = params['cvssv2_scoring_override'] ? true : false\n\n  if params['risk_scoring'] == 'CVSSv2'\n    config_options['dread'] = false\n    config_options['cvss'] = true\n    config_options['cvssv3'] = false\n    config_options['riskmatrix'] = false\n    config_options['nist800'] = false\n  elsif params['risk_scoring'] == 'CVSSv3'\n    config_options['dread'] = false\n    config_options['cvss'] = false\n    config_options['cvssv3'] = true\n    config_options['riskmatrix'] = false\n    config_options['nist800'] = false\n  elsif params['risk_scoring'] == 'DREAD'\n    config_options['dread'] = true\n    config_options['cvss'] = false\n    config_options['cvssv3'] = false\n    config_options['riskmatrix'] = false\n    config_options['nist800'] = false\n  elsif params['risk_scoring'] == 'RISKMATRIX'\n    config_options['dread'] = false\n    config_options['cvss'] = false\n    config_options['cvssv3'] = false\n    config_options['riskmatrix'] = true\n    config_options['nist800'] = false\n  elsif params['risk_scoring'] == 'NIST800-30'\n  \tconfig_options['dread'] = false\n    config_options['cvss'] = false\n    config_options['cvssv3'] = false\n    config_options['riskmatrix'] = false\n    config_options['nist800'] = true\n  else\n    config_options['dread'] = false\n    config_options['cvss'] = false\n    config_options['cvssv3'] = false\n    config_options['riskmatrix'] = false\n    config_options['nist800'] = false\n  end\n\n  File.open('./config.json', 'w') do |f|\n    f.write(JSON.pretty_generate(config_options))\n    serpico_log(\"Configuration file modified\")\n  end\n  redirect to('/admin/config')\nend\n\n# get plugins available\nget '/admin/plugins' do\n  redirect to('/no_access') unless is_administrator?\n\n  @plugins = []\n  Dir[File.join(File.dirname(__FILE__), '../plugins/**/', '*.json')].each do |lib|\n    @plugins.push(JSON.parse(File.open(lib).read))\n  end\n\n  @admin = true if is_administrator?\n  @plugin = true if is_plugin?\n\n  haml :plugins\nend\n\n# enable plugins\npost '/admin/plugins' do\n  redirect to('/no_access') unless is_administrator?\n\n  @plugins = []\n  Dir[File.join(File.dirname(__FILE__), '../plugins/**/', '*.json')].each do |lib|\n    @plugins.push(JSON.parse(File.open(lib).read))\n  end\n\n  @plugins.each do |plug|\n    if params[plug['name']]\n      plug['enabled'] = true\n      File.open(\"./plugins/#{plug['name']}/plugin.json\", 'w') do |f|\n        f.write(JSON.pretty_generate(plug))\n        serpico_log(\"Plugin #{plug['name']} enabled\")\n      end\n    else\n      plug['enabled'] = false\n      File.open(\"./plugins/#{plug['name']}/plugin.json\", 'w') do |f|\n        f.write(JSON.pretty_generate(plug))\n        serpico_log(\"Plugin #{plug['name']} disabled\")\n      end\n    end\n  end\n\n  redirect to('/admin/plugins')\nend\n\n# upload plugin zip\npost '/admin/plugin_upload' do\n  redirect to('/no_access') unless is_administrator?\n  redirect to('/no_access') unless is_plugin?\n\n  # take each zip in turn\n  params['files'].map do |upf|\n    # We use a random filename\n    rand_file = \"./tmp/#{rand(36**36).to_s(36)}\"\n\n    # reject if the file is above a certain limit\n    return 'File too large. 100MB limit' if upf[:tempfile].size > 100_000_000\n\n    # unzip the plugin and write it to the fs, writing the OS is possible but so is RCE\n    File.open(rand_file, 'wb') { |f| f.write(upf[:tempfile].read) }\n\n    # find the config.json file\n    config = ''\n    Zip::File.open(rand_file) do |zipfile|\n      # read the config file\n      zipfile.each do |entry|\n        if entry.name == 'plugin.json'\n          configj = entry.get_input_stream.read\n          config = JSON.parse(configj)\n          serpico_log(\"Custom plugin uploaded\")\n        end\n      end\n    end\n\n    return 'plugin.json does not exist in zip.' if config == ''\n\n    Zip::File.open(rand_file) do |zipfile|\n      # read the config file\n      zipfile.each do |entry|\n        # Extract to file/directory/symlink\n        fn = \"./plugins/#{config['name']}/\" + entry.name\n\n        # create the directory if dne\n        dirj = fn.split('/')\n        dirj.pop\n        FileUtils.mkdir_p(dirj.join('/')) unless File.directory?(dirj.join('/'))\n\n        next if fn[-1] == '/'\n        # Read into memory\n        content = entry.get_input_stream.read\n\n        File.open(fn, 'a') do |f|\n          f.write(content)\n        end\n      end\n    end\n  end\n  redirect to('/admin/plugins')\nend\n\n# Manage Templated Reports\nget '/admin/templates' do\n  redirect to('/no_access') unless is_administrator?\n\n  @admin = true\n\n  # Query for all Findings\n  @templates = Xslt.all(order: [:report_type.asc])\n\n  haml :template_list\nend\n\n# Manage Templated Reports\nget '/admin/templates/add' do\n  redirect to('/no_access') unless is_administrator?\n\n  @admin = true\n\n  haml :add_template\nend\n\n# Manage Templated Reports\nget '/admin/templates/:id/download' do\n  redirect to('/no_access') unless is_administrator?\n\n  @admin = true\n\n  xslt = Xslt.first(id: params[:id])\n\n  send_file xslt.docx_location, type: 'docx', filename: \"#{xslt.report_type}.docx\"\nend\n\nget '/admin/delete/templates/:id' do\n  redirect to('/no_access') unless is_administrator?\n\n  @xslt = Xslt.first(id: params[:id])\n\n  if @xslt\n    @xslt.components.destroy\n    @xslt.destroy\n    File.delete(@xslt.xslt_location) if File.file?(@xslt.xslt_location)\n    File.delete(@xslt.docx_location) if File.file?(@xslt.docx_location)\n    serpico_log(\"Report template deleted\")\n  end\n  redirect to('/admin/templates')\nend\n\n# Manage Templated Reports\npost '/admin/templates/add' do\n  redirect to('/no_access') unless is_administrator?\n\n  @admin = true\n\n  xslt_file = \"./templates/#{rand(36**36).to_s(36)}.xslt\"\n\n  redirect to('/admin/templates/add') unless params[:file]\n\n  # reject if the file is above a certain limit\n  if params[:file][:tempfile].size > 100_000_000\n    return 'File too large. 10MB limit'\n  end\n\n  docx = \"./templates/#{rand(36**36).to_s(36)}.docx\"\n  File.open(docx, 'wb') { |f| f.write(params[:file][:tempfile].read) }\n\n  error = false\n  detail = ''\n  begin\n    xslt = generate_xslt(docx)\n    xslt_components = generate_xslt_components(docx)\n  rescue TemplateVerificationError => detail\n    @error_message = CGI::escapeHTML(detail.errorString)\n    @tree = CGI::escapeHTML(detail.template_tree)\n    return haml :template_error\n  rescue ReportingError => detail\n    error = true\n  end\n\n  if error\n    \"The report template you uploaded threw an error when parsing:<p><p> #{detail.errorString}\"\n  else\n    # open up a file handle and write the attachment\n    File.open(xslt_file, 'wb') { |f| f.write(xslt) }\n    # extract the screenshot names from the file\n    screenshot_names = xslt.scan(/\\[!!(.*?)!!\\]/)\n    # delete the file data from the attachment\n    datax = {}\n    # to prevent traversal we hardcode this\n    datax['docx_location'] = docx.to_s\n    datax['xslt_location'] = xslt_file.to_s\n    datax['description'] =\tparams[:description]\n    datax['report_type'] = params[:report_type]\n    datax['screenshot_names'] = screenshot_names.join(',')\n    data = url_escape_hash(datax)\n    data['finding_template'] = params[:finding_template] ? true : false\n    data['status_template'] = params[:status_template] ? true : false\n\n    @template = Xslt.first(report_type: data['report_type'])\n\n    if @template\n      @template.update(xslt_location: data['xslt_location'], docx_location: data['docx_location'], description: data['description'], screenshot_names: data['screenshot_names'])\n      @template.components.destroy\n    else\n      @template = Xslt.new(data)\n      @template.save\n    end\n\n    # create a xslt file for each component\n    list_components_files = []\n    xslt_components.each do |component_name, component_xslt|\n      componentHash = {}\n      componentHash['xslt_location'] = \"./templates/#{rand(36**36).to_s(36)}.xslt\"\n      componentHash['name'] = component_name\n      componentHash['xslt'] = @template\n      File.open(componentHash['xslt_location'], 'wb') { |f| f.write(component_xslt) }\n      list_components_files.push(componentHash)\n    end\n\n    # insert components into the db\n    list_components_files.each do |component|\n      @component = Xslt_component.new(component)\n      @component.save\n    end\n    serpico_log(\"New report template successfully added\")\n    redirect to('/admin/templates')\n\n    haml :add_template\n  end\nend\n\nget '/admin/templates/:id/tree' do\n  redirect to('/no_access') unless is_administrator?\n  @admin = true\n  xslt = Xslt.first(id: params[:id])\n  document = read_rels(xslt.docx_location,\"word/document.xml\")\n  @tree = verify_document(document)\n  @tree = @tree[2]\n\n  haml :template_tree\nend\n# Manage Templated Reports\nget '/admin/templates/:id/edit' do\n  redirect to('/no_access') unless is_administrator?\n\n  @admin = true\n  @template = Xslt.first(id: params[:id])\n\n  haml :edit_template\nend\n\n# Manage Templated Reports\npost '/admin/templates/edit' do\n  redirect to('/no_access') unless is_administrator?\n\n  @admin = true\n  template = Xslt.first(id: params[:id])\n\n  xslt_file = template.xslt_location\n\n  redirect to(\"/admin/templates/#{params[:id]}/edit\") unless params[:file]\n\n  # reject if the file is above a certain limit\n  if params[:file][:tempfile].size > 100_000_000\n    return 'File too large. 10MB limit'\n  end\n\n  docx = \"./templates/#{rand(36**36).to_s(36)}.docx\"\n  File.open(docx, 'wb') { |f| f.write(params[:file][:tempfile].read) }\n\n  error = false\n  detail = ''\n  begin\n    xslt = generate_xslt(docx)\n    xslt_components = generate_xslt_components(docx)\n  rescue TemplateVerificationError => detail\n    @error_message = CGI::escapeHTML(detail.errorString)\n    @tree = CGI::escapeHTML(detail.template_tree)\n    return haml :template_error\n  rescue ReportingError => detail\n    error = true\n  end\n\n  if error\n    \"The report template you uploaded threw an error when parsing:<p><p> #{detail.errorString}\"\n  else\n\n    # open up a file handle and write the attachment\n    File.open(xslt_file, 'wb') { |f| f.write(xslt) }\n    # extract the screenshot names from the file\n    screenshot_names = xslt.scan(/\\[!!(.*?)!!\\]/)\n    # delete the file data from the attachment\n    datax = {}\n    # to prevent traversal we hardcode this\n    datax['docx_location'] = docx.to_s\n    datax['xslt_location'] = xslt_file.to_s\n    datax['description'] =\tparams[:description]\n    datax['report_type'] = params[:report_type]\n    datax['screenshot_names'] = screenshot_names.join(',')\n    data = url_escape_hash(datax)\n    data['finding_template'] = params[:finding_template] ? true : false\n    data['status_template'] = params[:status_template] ? true : false\n\n    @template = Xslt.first(report_type: data['report_type'])\n\n    if @template\n      @template.update(xslt_location: data['xslt_location'], docx_location: data['docx_location'], description: data['description'], screenshot_names: data['screenshot_names'])\n      @template.components.destroy\n    else\n      @template = Xslt.new(data)\n      @template.save\n    end\n\n    # create a xslt file for each component\n    list_components_files = []\n    xslt_components.each do |component_name, component_xslt|\n      componentHash = {}\n      componentHash['xslt_location'] = \"./templates/#{rand(36**36).to_s(36)}.xslt\"\n      componentHash['name'] = component_name\n      componentHash['xslt'] = @template\n      File.open(componentHash['xslt_location'], 'wb') { |f| f.write(component_xslt) }\n      list_components_files.push(componentHash)\n    end\n\n    # insert components into the db\n    list_components_files.each do |component|\n      @component = Xslt_component.new(component)\n      @component.save\n    end\n    serpico_log(\"Report template modified\")\n    redirect to('/admin/templates')\nend\nend\n\n# get enabled plugins\nget '/admin/admin_plugins' do\n\n  @admin = true if is_administrator?\n  @plugin = true if is_plugin?\n\n  @menu = get_plugin_list('admin')\n  haml :enabled_plugins\nend\n\nget '/admin/udo_templates' do\n  redirect to('/no_access') unless is_administrator?\n\n  # delete UDO template part\n  if params[:delete]\n    udo_template = UserDefinedObjectTemplates.get(params[:delete])\n    return 'UDO Template not found' if udo_template.nil?\n    udo_template.destroy\n  end\n  @udos_templates = UserDefinedObjectTemplates.all\n\n  @admin = true if is_administrator?\n  @plugin = true if is_plugin?\n\n  haml :user_defined_object_templates\nend\n\npost '/admin/udo_templates' do\n  redirect to('/no_access') unless is_administrator?\n  data = url_escape_hash(request.POST)\n\n  # Save new UDO template part\n  if data['action'] = 'Save'\n    new_udo_template = UserDefinedObjectTemplates.new\n    new_udo_template.type = data['object_type']\n    udo_properties = {}\n    # we extract the udo properties from the posted data\n    data.each do |param, value|\n      if param =~ /property_/\n        udo_properties[value] = '' unless value.to_s.empty?\n      end\n    end\n    new_udo_template.udo_properties = udo_properties.to_json\n    new_udo_template.save\n  end\n\n  @udos_templates = UserDefinedObjectTemplates.all\n\n  serpico_log(\"UDO template added\")\n  redirect to('/admin/udo_templates')\nend\n\n# edit udo template\nget '/admin/udo_template/:template_id/edit' do\n  redirect to('/no_access') unless is_administrator?\n  @udo_to_edit = UserDefinedObjectTemplates.get(params[:template_id])\n  return 'No such UDO Template' if @udo_to_edit.nil?\n  @udo_to_edit_properties = JSON.parse(@udo_to_edit.udo_properties)\n\n  @admin = true if is_administrator?\n  @plugin = true if is_plugin?\n\n  haml :udo_template_edit\nend\n\npost '/admin/udo_template/:template_id/edit' do\n  redirect to('/no_access') unless is_administrator?\n  data = url_escape_hash(request.POST)\n  @udo_to_edit = UserDefinedObjectTemplates.get(params[:template_id])\n  return 'No such UDO Template' if @udo_to_edit.nil?\n  @udo_to_edit_properties = JSON.parse(@udo_to_edit.udo_properties)\n\n  udo_properties = {}\n  # we extract the udo properties from the posted data\n  data.each do |param1, value1|\n    unless value1.to_s.empty?\n      # we add the new properties\n      if param1 =~ /prop_new_\\d+/\n        id = param1.split('_')[2]\n        data.each do |param2, value2|\n          next unless param2 =~ /default_new_#{id}/\n          udo_properties[value1] = if value2 !~ /\\<paragraph\\>/\n                                     \"<paragraph>#{value2}</paragraph>\"\n                                   else\n                                     value2\n                                   end\n        end\n\n        # we edit the already existing properties\n      elsif param1 =~ /prop_/\n        data.each do |param2, value2|\n          next unless param2 =~ /default_#{param1.split(\"_\")[-1]}/\n          udo_properties[value1] = if value2 !~ /\\<paragraph\\>/\n                                     \"<paragraph>#{value2}</paragraph>\"\n                                   else\n                                     value2\n                                   end\n        end\n      end\n    end\n  end\n  @udo_to_edit.udo_properties = udo_properties.to_json\n  @udo_to_edit.save\n  serpico_log(\"UDO template modified\")\n  redirect to('/admin/udo_templates')\nend\n"], "filenames": ["routes/admin.rb"], "buggy_code_start_loc": [58], "buggy_code_end_loc": [58], "fixing_code_start_loc": [59], "fixing_code_end_loc": [60], "type": "CWE-668", "message": "An issue was discovered in Serpico before 1.3.3. The /admin/attacments_backup endpoint can be requested by non-admin authenticated users. This means that an attacker with a user account can retrieve all of the attachments of all users (including administrators) from the database.", "other": {"cve": {"id": "CVE-2020-12687", "sourceIdentifier": "cve@mitre.org", "published": "2020-05-07T16:15:11.267", "lastModified": "2020-05-12T14:21:47.127", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in Serpico before 1.3.3. The /admin/attacments_backup endpoint can be requested by non-admin authenticated users. This means that an attacker with a user account can retrieve all of the attachments of all users (including administrators) from the database."}, {"lang": "es", "value": "Se detect\u00f3 un problema en Serpico versiones anteriores a 1.3.3. El endpoint /admin/attacments_backup puede ser solicitado por usuarios autenticados que no sean administradores. Esto significa que un atacante con una cuenta de usuario puede recuperar todos los archivos adjuntos de todos los usuarios (incluidos los administradores) desde la base de datos."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-668"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:serpico_project:serpico:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.3.3", "matchCriteriaId": "D0658DBF-F69E-4DBC-B779-EDE017882722"}]}]}], "references": [{"url": "https://github.com/SerpicoProject/Serpico/commit/0b8600414976a5ad733604c7b1428071baf239c2", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/SerpicoProject/Serpico/releases/tag/1.3.3", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/SerpicoProject/Serpico/commit/0b8600414976a5ad733604c7b1428071baf239c2"}}