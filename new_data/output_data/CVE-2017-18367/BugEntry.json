{"buggy_code": ["// +build linux\n\n// Internal functions for libseccomp Go bindings\n// No exported functions\n\npackage seccomp\n\nimport (\n\t\"fmt\"\n\t\"syscall\"\n)\n\n// Unexported C wrapping code - provides the C-Golang interface\n// Get the seccomp header in scope\n// Need stdlib.h for free() on cstrings\n\n// #cgo pkg-config: libseccomp\n/*\n#include <stdlib.h>\n#include <seccomp.h>\n\n#if SCMP_VER_MAJOR < 2\n#error Minimum supported version of Libseccomp is v2.2.0\n#elif SCMP_VER_MAJOR == 2 && SCMP_VER_MINOR < 2\n#error Minimum supported version of Libseccomp is v2.2.0\n#endif\n\n#define ARCH_BAD ~0\n\nconst uint32_t C_ARCH_BAD = ARCH_BAD;\n\n#ifndef SCMP_ARCH_PPC\n#define SCMP_ARCH_PPC ARCH_BAD\n#endif\n\n#ifndef SCMP_ARCH_PPC64\n#define SCMP_ARCH_PPC64 ARCH_BAD\n#endif\n\n#ifndef SCMP_ARCH_PPC64LE\n#define SCMP_ARCH_PPC64LE ARCH_BAD\n#endif\n\n#ifndef SCMP_ARCH_S390\n#define SCMP_ARCH_S390 ARCH_BAD\n#endif\n\n#ifndef SCMP_ARCH_S390X\n#define SCMP_ARCH_S390X ARCH_BAD\n#endif\n\nconst uint32_t C_ARCH_NATIVE       = SCMP_ARCH_NATIVE;\nconst uint32_t C_ARCH_X86          = SCMP_ARCH_X86;\nconst uint32_t C_ARCH_X86_64       = SCMP_ARCH_X86_64;\nconst uint32_t C_ARCH_X32          = SCMP_ARCH_X32;\nconst uint32_t C_ARCH_ARM          = SCMP_ARCH_ARM;\nconst uint32_t C_ARCH_AARCH64      = SCMP_ARCH_AARCH64;\nconst uint32_t C_ARCH_MIPS         = SCMP_ARCH_MIPS;\nconst uint32_t C_ARCH_MIPS64       = SCMP_ARCH_MIPS64;\nconst uint32_t C_ARCH_MIPS64N32    = SCMP_ARCH_MIPS64N32;\nconst uint32_t C_ARCH_MIPSEL       = SCMP_ARCH_MIPSEL;\nconst uint32_t C_ARCH_MIPSEL64     = SCMP_ARCH_MIPSEL64;\nconst uint32_t C_ARCH_MIPSEL64N32  = SCMP_ARCH_MIPSEL64N32;\nconst uint32_t C_ARCH_PPC          = SCMP_ARCH_PPC;\nconst uint32_t C_ARCH_PPC64        = SCMP_ARCH_PPC64;\nconst uint32_t C_ARCH_PPC64LE      = SCMP_ARCH_PPC64LE;\nconst uint32_t C_ARCH_S390         = SCMP_ARCH_S390;\nconst uint32_t C_ARCH_S390X        = SCMP_ARCH_S390X;\n\nconst uint32_t C_ACT_KILL          = SCMP_ACT_KILL;\nconst uint32_t C_ACT_TRAP          = SCMP_ACT_TRAP;\nconst uint32_t C_ACT_ERRNO         = SCMP_ACT_ERRNO(0);\nconst uint32_t C_ACT_TRACE         = SCMP_ACT_TRACE(0);\nconst uint32_t C_ACT_ALLOW         = SCMP_ACT_ALLOW;\n\nconst uint32_t C_ATTRIBUTE_DEFAULT = (uint32_t)SCMP_FLTATR_ACT_DEFAULT;\nconst uint32_t C_ATTRIBUTE_BADARCH = (uint32_t)SCMP_FLTATR_ACT_BADARCH;\nconst uint32_t C_ATTRIBUTE_NNP     = (uint32_t)SCMP_FLTATR_CTL_NNP;\nconst uint32_t C_ATTRIBUTE_TSYNC   = (uint32_t)SCMP_FLTATR_CTL_TSYNC;\n\nconst int      C_CMP_NE            = (int)SCMP_CMP_NE;\nconst int      C_CMP_LT            = (int)SCMP_CMP_LT;\nconst int      C_CMP_LE            = (int)SCMP_CMP_LE;\nconst int      C_CMP_EQ            = (int)SCMP_CMP_EQ;\nconst int      C_CMP_GE            = (int)SCMP_CMP_GE;\nconst int      C_CMP_GT            = (int)SCMP_CMP_GT;\nconst int      C_CMP_MASKED_EQ     = (int)SCMP_CMP_MASKED_EQ;\n\n#if SCMP_VER_MAJOR == 2 && SCMP_VER_MINOR >= 3\nunsigned int get_major_version()\n{\n       return seccomp_version()->major;\n}\n\nunsigned int get_minor_version()\n{\n       return seccomp_version()->minor;\n}\n\nunsigned int get_micro_version()\n{\n       return seccomp_version()->micro;\n}\n#else\nunsigned int get_major_version()\n{\n       return (unsigned int)SCMP_MAJOR_VERSION;\n}\n\nunsigned int get_minor_version()\n{\n       return (unsigned int)SCMP_MINOR_VERSION;\n}\n\nunsigned int get_micro_version()\n{\n       return (unsigned int)SCMP_MICRO_VERSION;\n}\n#endif\n\ntypedef struct scmp_arg_cmp* scmp_cast_t;\n\n// Wrapper to create an scmp_arg_cmp struct\nvoid*\nmake_struct_arg_cmp(\n                    unsigned int arg,\n                    int compare,\n                    uint64_t a,\n                    uint64_t b\n                   )\n{\n\tstruct scmp_arg_cmp *s = malloc(sizeof(struct scmp_arg_cmp));\n\n\ts->arg = arg;\n\ts->op = compare;\n\ts->datum_a = a;\n\ts->datum_b = b;\n\n\treturn s;\n}\n*/\nimport \"C\"\n\n// Nonexported types\ntype scmpFilterAttr uint32\n\n// Nonexported constants\n\nconst (\n\tfilterAttrActDefault scmpFilterAttr = iota\n\tfilterAttrActBadArch scmpFilterAttr = iota\n\tfilterAttrNNP        scmpFilterAttr = iota\n\tfilterAttrTsync      scmpFilterAttr = iota\n)\n\nconst (\n\t// An error return from certain libseccomp functions\n\tscmpError C.int = -1\n\t// Comparison boundaries to check for architecture validity\n\tarchStart ScmpArch = ArchNative\n\tarchEnd   ScmpArch = ArchS390X\n\t// Comparison boundaries to check for action validity\n\tactionStart ScmpAction = ActKill\n\tactionEnd   ScmpAction = ActAllow\n\t// Comparison boundaries to check for comparison operator validity\n\tcompareOpStart ScmpCompareOp = CompareNotEqual\n\tcompareOpEnd   ScmpCompareOp = CompareMaskedEqual\n)\n\nvar (\n\t// Error thrown on bad filter context\n\terrBadFilter = fmt.Errorf(\"filter is invalid or uninitialized\")\n\t// Constants representing library major, minor, and micro versions\n\tverMajor = uint(C.get_major_version())\n\tverMinor = uint(C.get_minor_version())\n\tverMicro = uint(C.get_micro_version())\n)\n\n// Nonexported functions\n\n// Check if library version is greater than or equal to the given one\nfunc checkVersionAbove(major, minor, micro uint) bool {\n\treturn (verMajor > major) ||\n\t\t(verMajor == major && verMinor > minor) ||\n\t\t(verMajor == major && verMinor == minor && verMicro >= micro)\n}\n\n// Ensure that the library is supported, i.e. >= 2.2.0.\nfunc ensureSupportedVersion() error {\n\tif !checkVersionAbove(2, 2, 0) {\n\t\treturn VersionError{}\n\t}\n\treturn nil\n}\n\n// Filter helpers\n\n// Filter finalizer - ensure that kernel context for filters is freed\nfunc filterFinalizer(f *ScmpFilter) {\n\tf.Release()\n}\n\n// Get a raw filter attribute\nfunc (f *ScmpFilter) getFilterAttr(attr scmpFilterAttr) (C.uint32_t, error) {\n\tf.lock.Lock()\n\tdefer f.lock.Unlock()\n\n\tif !f.valid {\n\t\treturn 0x0, errBadFilter\n\t}\n\n\tvar attribute C.uint32_t\n\n\tretCode := C.seccomp_attr_get(f.filterCtx, attr.toNative(), &attribute)\n\tif retCode != 0 {\n\t\treturn 0x0, syscall.Errno(-1 * retCode)\n\t}\n\n\treturn attribute, nil\n}\n\n// Set a raw filter attribute\nfunc (f *ScmpFilter) setFilterAttr(attr scmpFilterAttr, value C.uint32_t) error {\n\tf.lock.Lock()\n\tdefer f.lock.Unlock()\n\n\tif !f.valid {\n\t\treturn errBadFilter\n\t}\n\n\tretCode := C.seccomp_attr_set(f.filterCtx, attr.toNative(), value)\n\tif retCode != 0 {\n\t\treturn syscall.Errno(-1 * retCode)\n\t}\n\n\treturn nil\n}\n\n// DOES NOT LOCK OR CHECK VALIDITY\n// Assumes caller has already done this\n// Wrapper for seccomp_rule_add_... functions\nfunc (f *ScmpFilter) addRuleWrapper(call ScmpSyscall, action ScmpAction, exact bool, cond C.scmp_cast_t) error {\n\tvar length C.uint\n\tif cond != nil {\n\t\tlength = 1\n\t} else {\n\t\tlength = 0\n\t}\n\n\tvar retCode C.int\n\tif exact {\n\t\tretCode = C.seccomp_rule_add_exact_array(f.filterCtx, action.toNative(), C.int(call), length, cond)\n\t} else {\n\t\tretCode = C.seccomp_rule_add_array(f.filterCtx, action.toNative(), C.int(call), length, cond)\n\t}\n\n\tif syscall.Errno(-1*retCode) == syscall.EFAULT {\n\t\treturn fmt.Errorf(\"unrecognized syscall\")\n\t} else if syscall.Errno(-1*retCode) == syscall.EPERM {\n\t\treturn fmt.Errorf(\"requested action matches default action of filter\")\n\t} else if retCode != 0 {\n\t\treturn syscall.Errno(-1 * retCode)\n\t}\n\n\treturn nil\n}\n\n// Generic add function for filter rules\nfunc (f *ScmpFilter) addRuleGeneric(call ScmpSyscall, action ScmpAction, exact bool, conds []ScmpCondition) error {\n\tf.lock.Lock()\n\tdefer f.lock.Unlock()\n\n\tif !f.valid {\n\t\treturn errBadFilter\n\t}\n\n\tif len(conds) == 0 {\n\t\tif err := f.addRuleWrapper(call, action, exact, nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\t// We don't support conditional filtering in library version v2.1\n\t\tif !checkVersionAbove(2, 2, 1) {\n\t\t\treturn VersionError{\n\t\t\t\tmessage: \"conditional filtering is not supported\",\n\t\t\t\tminimum: \"2.2.1\",\n\t\t\t}\n\t\t}\n\n\t\tfor _, cond := range conds {\n\t\t\tcmpStruct := C.make_struct_arg_cmp(C.uint(cond.Argument), cond.Op.toNative(), C.uint64_t(cond.Operand1), C.uint64_t(cond.Operand2))\n\t\t\tdefer C.free(cmpStruct)\n\n\t\t\tif err := f.addRuleWrapper(call, action, exact, C.scmp_cast_t(cmpStruct)); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Generic Helpers\n\n// Helper - Sanitize Arch token input\nfunc sanitizeArch(in ScmpArch) error {\n\tif in < archStart || in > archEnd {\n\t\treturn fmt.Errorf(\"unrecognized architecture\")\n\t}\n\n\tif in.toNative() == C.C_ARCH_BAD {\n\t\treturn fmt.Errorf(\"architecture is not supported on this version of the library\")\n\t}\n\n\treturn nil\n}\n\nfunc sanitizeAction(in ScmpAction) error {\n\tinTmp := in & 0x0000FFFF\n\tif inTmp < actionStart || inTmp > actionEnd {\n\t\treturn fmt.Errorf(\"unrecognized action\")\n\t}\n\n\tif inTmp != ActTrace && inTmp != ActErrno && (in&0xFFFF0000) != 0 {\n\t\treturn fmt.Errorf(\"highest 16 bits must be zeroed except for Trace and Errno\")\n\t}\n\n\treturn nil\n}\n\nfunc sanitizeCompareOp(in ScmpCompareOp) error {\n\tif in < compareOpStart || in > compareOpEnd {\n\t\treturn fmt.Errorf(\"unrecognized comparison operator\")\n\t}\n\n\treturn nil\n}\n\nfunc archFromNative(a C.uint32_t) (ScmpArch, error) {\n\tswitch a {\n\tcase C.C_ARCH_X86:\n\t\treturn ArchX86, nil\n\tcase C.C_ARCH_X86_64:\n\t\treturn ArchAMD64, nil\n\tcase C.C_ARCH_X32:\n\t\treturn ArchX32, nil\n\tcase C.C_ARCH_ARM:\n\t\treturn ArchARM, nil\n\tcase C.C_ARCH_NATIVE:\n\t\treturn ArchNative, nil\n\tcase C.C_ARCH_AARCH64:\n\t\treturn ArchARM64, nil\n\tcase C.C_ARCH_MIPS:\n\t\treturn ArchMIPS, nil\n\tcase C.C_ARCH_MIPS64:\n\t\treturn ArchMIPS64, nil\n\tcase C.C_ARCH_MIPS64N32:\n\t\treturn ArchMIPS64N32, nil\n\tcase C.C_ARCH_MIPSEL:\n\t\treturn ArchMIPSEL, nil\n\tcase C.C_ARCH_MIPSEL64:\n\t\treturn ArchMIPSEL64, nil\n\tcase C.C_ARCH_MIPSEL64N32:\n\t\treturn ArchMIPSEL64N32, nil\n\tcase C.C_ARCH_PPC:\n\t\treturn ArchPPC, nil\n\tcase C.C_ARCH_PPC64:\n\t\treturn ArchPPC64, nil\n\tcase C.C_ARCH_PPC64LE:\n\t\treturn ArchPPC64LE, nil\n\tcase C.C_ARCH_S390:\n\t\treturn ArchS390, nil\n\tcase C.C_ARCH_S390X:\n\t\treturn ArchS390X, nil\n\tdefault:\n\t\treturn 0x0, fmt.Errorf(\"unrecognized architecture\")\n\t}\n}\n\n// Only use with sanitized arches, no error handling\nfunc (a ScmpArch) toNative() C.uint32_t {\n\tswitch a {\n\tcase ArchX86:\n\t\treturn C.C_ARCH_X86\n\tcase ArchAMD64:\n\t\treturn C.C_ARCH_X86_64\n\tcase ArchX32:\n\t\treturn C.C_ARCH_X32\n\tcase ArchARM:\n\t\treturn C.C_ARCH_ARM\n\tcase ArchARM64:\n\t\treturn C.C_ARCH_AARCH64\n\tcase ArchMIPS:\n\t\treturn C.C_ARCH_MIPS\n\tcase ArchMIPS64:\n\t\treturn C.C_ARCH_MIPS64\n\tcase ArchMIPS64N32:\n\t\treturn C.C_ARCH_MIPS64N32\n\tcase ArchMIPSEL:\n\t\treturn C.C_ARCH_MIPSEL\n\tcase ArchMIPSEL64:\n\t\treturn C.C_ARCH_MIPSEL64\n\tcase ArchMIPSEL64N32:\n\t\treturn C.C_ARCH_MIPSEL64N32\n\tcase ArchPPC:\n\t\treturn C.C_ARCH_PPC\n\tcase ArchPPC64:\n\t\treturn C.C_ARCH_PPC64\n\tcase ArchPPC64LE:\n\t\treturn C.C_ARCH_PPC64LE\n\tcase ArchS390:\n\t\treturn C.C_ARCH_S390\n\tcase ArchS390X:\n\t\treturn C.C_ARCH_S390X\n\tcase ArchNative:\n\t\treturn C.C_ARCH_NATIVE\n\tdefault:\n\t\treturn 0x0\n\t}\n}\n\n// Only use with sanitized ops, no error handling\nfunc (a ScmpCompareOp) toNative() C.int {\n\tswitch a {\n\tcase CompareNotEqual:\n\t\treturn C.C_CMP_NE\n\tcase CompareLess:\n\t\treturn C.C_CMP_LT\n\tcase CompareLessOrEqual:\n\t\treturn C.C_CMP_LE\n\tcase CompareEqual:\n\t\treturn C.C_CMP_EQ\n\tcase CompareGreaterEqual:\n\t\treturn C.C_CMP_GE\n\tcase CompareGreater:\n\t\treturn C.C_CMP_GT\n\tcase CompareMaskedEqual:\n\t\treturn C.C_CMP_MASKED_EQ\n\tdefault:\n\t\treturn 0x0\n\t}\n}\n\nfunc actionFromNative(a C.uint32_t) (ScmpAction, error) {\n\taTmp := a & 0xFFFF\n\tswitch a & 0xFFFF0000 {\n\tcase C.C_ACT_KILL:\n\t\treturn ActKill, nil\n\tcase C.C_ACT_TRAP:\n\t\treturn ActTrap, nil\n\tcase C.C_ACT_ERRNO:\n\t\treturn ActErrno.SetReturnCode(int16(aTmp)), nil\n\tcase C.C_ACT_TRACE:\n\t\treturn ActTrace.SetReturnCode(int16(aTmp)), nil\n\tcase C.C_ACT_ALLOW:\n\t\treturn ActAllow, nil\n\tdefault:\n\t\treturn 0x0, fmt.Errorf(\"unrecognized action\")\n\t}\n}\n\n// Only use with sanitized actions, no error handling\nfunc (a ScmpAction) toNative() C.uint32_t {\n\tswitch a & 0xFFFF {\n\tcase ActKill:\n\t\treturn C.C_ACT_KILL\n\tcase ActTrap:\n\t\treturn C.C_ACT_TRAP\n\tcase ActErrno:\n\t\treturn C.C_ACT_ERRNO | (C.uint32_t(a) >> 16)\n\tcase ActTrace:\n\t\treturn C.C_ACT_TRACE | (C.uint32_t(a) >> 16)\n\tcase ActAllow:\n\t\treturn C.C_ACT_ALLOW\n\tdefault:\n\t\treturn 0x0\n\t}\n}\n\n// Internal only, assumes safe attribute\nfunc (a scmpFilterAttr) toNative() uint32 {\n\tswitch a {\n\tcase filterAttrActDefault:\n\t\treturn uint32(C.C_ATTRIBUTE_DEFAULT)\n\tcase filterAttrActBadArch:\n\t\treturn uint32(C.C_ATTRIBUTE_BADARCH)\n\tcase filterAttrNNP:\n\t\treturn uint32(C.C_ATTRIBUTE_NNP)\n\tcase filterAttrTsync:\n\t\treturn uint32(C.C_ATTRIBUTE_TSYNC)\n\tdefault:\n\t\treturn 0x0\n\t}\n}\n"], "fixing_code": ["// +build linux\n\n// Internal functions for libseccomp Go bindings\n// No exported functions\n\npackage seccomp\n\nimport (\n\t\"fmt\"\n\t\"syscall\"\n)\n\n// Unexported C wrapping code - provides the C-Golang interface\n// Get the seccomp header in scope\n// Need stdlib.h for free() on cstrings\n\n// #cgo pkg-config: libseccomp\n/*\n#include <stdlib.h>\n#include <seccomp.h>\n\n#if SCMP_VER_MAJOR < 2\n#error Minimum supported version of Libseccomp is v2.2.0\n#elif SCMP_VER_MAJOR == 2 && SCMP_VER_MINOR < 2\n#error Minimum supported version of Libseccomp is v2.2.0\n#endif\n\n#define ARCH_BAD ~0\n\nconst uint32_t C_ARCH_BAD = ARCH_BAD;\n\n#ifndef SCMP_ARCH_PPC\n#define SCMP_ARCH_PPC ARCH_BAD\n#endif\n\n#ifndef SCMP_ARCH_PPC64\n#define SCMP_ARCH_PPC64 ARCH_BAD\n#endif\n\n#ifndef SCMP_ARCH_PPC64LE\n#define SCMP_ARCH_PPC64LE ARCH_BAD\n#endif\n\n#ifndef SCMP_ARCH_S390\n#define SCMP_ARCH_S390 ARCH_BAD\n#endif\n\n#ifndef SCMP_ARCH_S390X\n#define SCMP_ARCH_S390X ARCH_BAD\n#endif\n\nconst uint32_t C_ARCH_NATIVE       = SCMP_ARCH_NATIVE;\nconst uint32_t C_ARCH_X86          = SCMP_ARCH_X86;\nconst uint32_t C_ARCH_X86_64       = SCMP_ARCH_X86_64;\nconst uint32_t C_ARCH_X32          = SCMP_ARCH_X32;\nconst uint32_t C_ARCH_ARM          = SCMP_ARCH_ARM;\nconst uint32_t C_ARCH_AARCH64      = SCMP_ARCH_AARCH64;\nconst uint32_t C_ARCH_MIPS         = SCMP_ARCH_MIPS;\nconst uint32_t C_ARCH_MIPS64       = SCMP_ARCH_MIPS64;\nconst uint32_t C_ARCH_MIPS64N32    = SCMP_ARCH_MIPS64N32;\nconst uint32_t C_ARCH_MIPSEL       = SCMP_ARCH_MIPSEL;\nconst uint32_t C_ARCH_MIPSEL64     = SCMP_ARCH_MIPSEL64;\nconst uint32_t C_ARCH_MIPSEL64N32  = SCMP_ARCH_MIPSEL64N32;\nconst uint32_t C_ARCH_PPC          = SCMP_ARCH_PPC;\nconst uint32_t C_ARCH_PPC64        = SCMP_ARCH_PPC64;\nconst uint32_t C_ARCH_PPC64LE      = SCMP_ARCH_PPC64LE;\nconst uint32_t C_ARCH_S390         = SCMP_ARCH_S390;\nconst uint32_t C_ARCH_S390X        = SCMP_ARCH_S390X;\n\nconst uint32_t C_ACT_KILL          = SCMP_ACT_KILL;\nconst uint32_t C_ACT_TRAP          = SCMP_ACT_TRAP;\nconst uint32_t C_ACT_ERRNO         = SCMP_ACT_ERRNO(0);\nconst uint32_t C_ACT_TRACE         = SCMP_ACT_TRACE(0);\nconst uint32_t C_ACT_ALLOW         = SCMP_ACT_ALLOW;\n\nconst uint32_t C_ATTRIBUTE_DEFAULT = (uint32_t)SCMP_FLTATR_ACT_DEFAULT;\nconst uint32_t C_ATTRIBUTE_BADARCH = (uint32_t)SCMP_FLTATR_ACT_BADARCH;\nconst uint32_t C_ATTRIBUTE_NNP     = (uint32_t)SCMP_FLTATR_CTL_NNP;\nconst uint32_t C_ATTRIBUTE_TSYNC   = (uint32_t)SCMP_FLTATR_CTL_TSYNC;\n\nconst int      C_CMP_NE            = (int)SCMP_CMP_NE;\nconst int      C_CMP_LT            = (int)SCMP_CMP_LT;\nconst int      C_CMP_LE            = (int)SCMP_CMP_LE;\nconst int      C_CMP_EQ            = (int)SCMP_CMP_EQ;\nconst int      C_CMP_GE            = (int)SCMP_CMP_GE;\nconst int      C_CMP_GT            = (int)SCMP_CMP_GT;\nconst int      C_CMP_MASKED_EQ     = (int)SCMP_CMP_MASKED_EQ;\n\n#if SCMP_VER_MAJOR == 2 && SCMP_VER_MINOR >= 3\nunsigned int get_major_version()\n{\n       return seccomp_version()->major;\n}\n\nunsigned int get_minor_version()\n{\n       return seccomp_version()->minor;\n}\n\nunsigned int get_micro_version()\n{\n       return seccomp_version()->micro;\n}\n#else\nunsigned int get_major_version()\n{\n       return (unsigned int)SCMP_MAJOR_VERSION;\n}\n\nunsigned int get_minor_version()\n{\n       return (unsigned int)SCMP_MINOR_VERSION;\n}\n\nunsigned int get_micro_version()\n{\n       return (unsigned int)SCMP_MICRO_VERSION;\n}\n#endif\n\ntypedef struct scmp_arg_cmp* scmp_cast_t;\n\nvoid* make_arg_cmp_array(unsigned int length)\n{\n        return calloc(length, sizeof(struct scmp_arg_cmp));\n}\n\n// Wrapper to add an scmp_arg_cmp struct to an existing arg_cmp array\nvoid add_struct_arg_cmp(\n                        struct scmp_arg_cmp* arr,\n                        unsigned int pos,\n                        unsigned int arg,\n                        int compare,\n                        uint64_t a,\n                        uint64_t b\n                       )\n{\n        arr[pos].arg = arg;\n        arr[pos].op = compare;\n        arr[pos].datum_a = a;\n        arr[pos].datum_b = b;\n\n        return;\n}\n*/\nimport \"C\"\n\n// Nonexported types\ntype scmpFilterAttr uint32\n\n// Nonexported constants\n\nconst (\n\tfilterAttrActDefault scmpFilterAttr = iota\n\tfilterAttrActBadArch scmpFilterAttr = iota\n\tfilterAttrNNP        scmpFilterAttr = iota\n\tfilterAttrTsync      scmpFilterAttr = iota\n)\n\nconst (\n\t// An error return from certain libseccomp functions\n\tscmpError C.int = -1\n\t// Comparison boundaries to check for architecture validity\n\tarchStart ScmpArch = ArchNative\n\tarchEnd   ScmpArch = ArchS390X\n\t// Comparison boundaries to check for action validity\n\tactionStart ScmpAction = ActKill\n\tactionEnd   ScmpAction = ActAllow\n\t// Comparison boundaries to check for comparison operator validity\n\tcompareOpStart ScmpCompareOp = CompareNotEqual\n\tcompareOpEnd   ScmpCompareOp = CompareMaskedEqual\n)\n\nvar (\n\t// Error thrown on bad filter context\n\terrBadFilter = fmt.Errorf(\"filter is invalid or uninitialized\")\n\t// Constants representing library major, minor, and micro versions\n\tverMajor = uint(C.get_major_version())\n\tverMinor = uint(C.get_minor_version())\n\tverMicro = uint(C.get_micro_version())\n)\n\n// Nonexported functions\n\n// Check if library version is greater than or equal to the given one\nfunc checkVersionAbove(major, minor, micro uint) bool {\n\treturn (verMajor > major) ||\n\t\t(verMajor == major && verMinor > minor) ||\n\t\t(verMajor == major && verMinor == minor && verMicro >= micro)\n}\n\n// Ensure that the library is supported, i.e. >= 2.2.0.\nfunc ensureSupportedVersion() error {\n\tif !checkVersionAbove(2, 2, 0) {\n\t\treturn VersionError{}\n\t}\n\treturn nil\n}\n\n// Filter helpers\n\n// Filter finalizer - ensure that kernel context for filters is freed\nfunc filterFinalizer(f *ScmpFilter) {\n\tf.Release()\n}\n\n// Get a raw filter attribute\nfunc (f *ScmpFilter) getFilterAttr(attr scmpFilterAttr) (C.uint32_t, error) {\n\tf.lock.Lock()\n\tdefer f.lock.Unlock()\n\n\tif !f.valid {\n\t\treturn 0x0, errBadFilter\n\t}\n\n\tvar attribute C.uint32_t\n\n\tretCode := C.seccomp_attr_get(f.filterCtx, attr.toNative(), &attribute)\n\tif retCode != 0 {\n\t\treturn 0x0, syscall.Errno(-1 * retCode)\n\t}\n\n\treturn attribute, nil\n}\n\n// Set a raw filter attribute\nfunc (f *ScmpFilter) setFilterAttr(attr scmpFilterAttr, value C.uint32_t) error {\n\tf.lock.Lock()\n\tdefer f.lock.Unlock()\n\n\tif !f.valid {\n\t\treturn errBadFilter\n\t}\n\n\tretCode := C.seccomp_attr_set(f.filterCtx, attr.toNative(), value)\n\tif retCode != 0 {\n\t\treturn syscall.Errno(-1 * retCode)\n\t}\n\n\treturn nil\n}\n\n// DOES NOT LOCK OR CHECK VALIDITY\n// Assumes caller has already done this\n// Wrapper for seccomp_rule_add_... functions\nfunc (f *ScmpFilter) addRuleWrapper(call ScmpSyscall, action ScmpAction, exact bool, length C.uint, cond C.scmp_cast_t) error {\n\tif length != 0 && cond == nil {\n\t\treturn fmt.Errorf(\"null conditions list, but length is nonzero\")\n\t}\n\n\tvar retCode C.int\n\tif exact {\n\t\tretCode = C.seccomp_rule_add_exact_array(f.filterCtx, action.toNative(), C.int(call), length, cond)\n\t} else {\n\t\tretCode = C.seccomp_rule_add_array(f.filterCtx, action.toNative(), C.int(call), length, cond)\n\t}\n\n\tif syscall.Errno(-1*retCode) == syscall.EFAULT {\n\t\treturn fmt.Errorf(\"unrecognized syscall\")\n\t} else if syscall.Errno(-1*retCode) == syscall.EPERM {\n\t\treturn fmt.Errorf(\"requested action matches default action of filter\")\n\t} else if syscall.Errno(-1*retCode) == syscall.EINVAL {\n\t\treturn fmt.Errorf(\"two checks on same syscall argument\")\n\t} else if retCode != 0 {\n\t\treturn syscall.Errno(-1 * retCode)\n\t}\n\n\treturn nil\n}\n\n// Generic add function for filter rules\nfunc (f *ScmpFilter) addRuleGeneric(call ScmpSyscall, action ScmpAction, exact bool, conds []ScmpCondition) error {\n\tf.lock.Lock()\n\tdefer f.lock.Unlock()\n\n\tif !f.valid {\n\t\treturn errBadFilter\n\t}\n\n\tif len(conds) == 0 {\n\t\tif err := f.addRuleWrapper(call, action, exact, 0, nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\t// We don't support conditional filtering in library version v2.1\n\t\tif !checkVersionAbove(2, 2, 1) {\n\t\t\treturn VersionError{\n\t\t\t\tmessage: \"conditional filtering is not supported\",\n\t\t\t\tminimum: \"2.2.1\",\n\t\t\t}\n\t\t}\n\n\t\targsArr := C.make_arg_cmp_array(C.uint(len(conds)))\n\t\tif argsArr == nil {\n\t\t\treturn fmt.Errorf(\"error allocating memory for conditions\")\n\t\t}\n\t\tdefer C.free(argsArr)\n\n\t\tfor i, cond := range conds {\n\t\t\tC.add_struct_arg_cmp(C.scmp_cast_t(argsArr), C.uint(i),\n\t\t\t\tC.uint(cond.Argument), cond.Op.toNative(),\n\t\t\t\tC.uint64_t(cond.Operand1), C.uint64_t(cond.Operand2))\n\t\t}\n\n\t\tif err := f.addRuleWrapper(call, action, exact, C.uint(len(conds)), C.scmp_cast_t(argsArr)); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Generic Helpers\n\n// Helper - Sanitize Arch token input\nfunc sanitizeArch(in ScmpArch) error {\n\tif in < archStart || in > archEnd {\n\t\treturn fmt.Errorf(\"unrecognized architecture\")\n\t}\n\n\tif in.toNative() == C.C_ARCH_BAD {\n\t\treturn fmt.Errorf(\"architecture is not supported on this version of the library\")\n\t}\n\n\treturn nil\n}\n\nfunc sanitizeAction(in ScmpAction) error {\n\tinTmp := in & 0x0000FFFF\n\tif inTmp < actionStart || inTmp > actionEnd {\n\t\treturn fmt.Errorf(\"unrecognized action\")\n\t}\n\n\tif inTmp != ActTrace && inTmp != ActErrno && (in&0xFFFF0000) != 0 {\n\t\treturn fmt.Errorf(\"highest 16 bits must be zeroed except for Trace and Errno\")\n\t}\n\n\treturn nil\n}\n\nfunc sanitizeCompareOp(in ScmpCompareOp) error {\n\tif in < compareOpStart || in > compareOpEnd {\n\t\treturn fmt.Errorf(\"unrecognized comparison operator\")\n\t}\n\n\treturn nil\n}\n\nfunc archFromNative(a C.uint32_t) (ScmpArch, error) {\n\tswitch a {\n\tcase C.C_ARCH_X86:\n\t\treturn ArchX86, nil\n\tcase C.C_ARCH_X86_64:\n\t\treturn ArchAMD64, nil\n\tcase C.C_ARCH_X32:\n\t\treturn ArchX32, nil\n\tcase C.C_ARCH_ARM:\n\t\treturn ArchARM, nil\n\tcase C.C_ARCH_NATIVE:\n\t\treturn ArchNative, nil\n\tcase C.C_ARCH_AARCH64:\n\t\treturn ArchARM64, nil\n\tcase C.C_ARCH_MIPS:\n\t\treturn ArchMIPS, nil\n\tcase C.C_ARCH_MIPS64:\n\t\treturn ArchMIPS64, nil\n\tcase C.C_ARCH_MIPS64N32:\n\t\treturn ArchMIPS64N32, nil\n\tcase C.C_ARCH_MIPSEL:\n\t\treturn ArchMIPSEL, nil\n\tcase C.C_ARCH_MIPSEL64:\n\t\treturn ArchMIPSEL64, nil\n\tcase C.C_ARCH_MIPSEL64N32:\n\t\treturn ArchMIPSEL64N32, nil\n\tcase C.C_ARCH_PPC:\n\t\treturn ArchPPC, nil\n\tcase C.C_ARCH_PPC64:\n\t\treturn ArchPPC64, nil\n\tcase C.C_ARCH_PPC64LE:\n\t\treturn ArchPPC64LE, nil\n\tcase C.C_ARCH_S390:\n\t\treturn ArchS390, nil\n\tcase C.C_ARCH_S390X:\n\t\treturn ArchS390X, nil\n\tdefault:\n\t\treturn 0x0, fmt.Errorf(\"unrecognized architecture\")\n\t}\n}\n\n// Only use with sanitized arches, no error handling\nfunc (a ScmpArch) toNative() C.uint32_t {\n\tswitch a {\n\tcase ArchX86:\n\t\treturn C.C_ARCH_X86\n\tcase ArchAMD64:\n\t\treturn C.C_ARCH_X86_64\n\tcase ArchX32:\n\t\treturn C.C_ARCH_X32\n\tcase ArchARM:\n\t\treturn C.C_ARCH_ARM\n\tcase ArchARM64:\n\t\treturn C.C_ARCH_AARCH64\n\tcase ArchMIPS:\n\t\treturn C.C_ARCH_MIPS\n\tcase ArchMIPS64:\n\t\treturn C.C_ARCH_MIPS64\n\tcase ArchMIPS64N32:\n\t\treturn C.C_ARCH_MIPS64N32\n\tcase ArchMIPSEL:\n\t\treturn C.C_ARCH_MIPSEL\n\tcase ArchMIPSEL64:\n\t\treturn C.C_ARCH_MIPSEL64\n\tcase ArchMIPSEL64N32:\n\t\treturn C.C_ARCH_MIPSEL64N32\n\tcase ArchPPC:\n\t\treturn C.C_ARCH_PPC\n\tcase ArchPPC64:\n\t\treturn C.C_ARCH_PPC64\n\tcase ArchPPC64LE:\n\t\treturn C.C_ARCH_PPC64LE\n\tcase ArchS390:\n\t\treturn C.C_ARCH_S390\n\tcase ArchS390X:\n\t\treturn C.C_ARCH_S390X\n\tcase ArchNative:\n\t\treturn C.C_ARCH_NATIVE\n\tdefault:\n\t\treturn 0x0\n\t}\n}\n\n// Only use with sanitized ops, no error handling\nfunc (a ScmpCompareOp) toNative() C.int {\n\tswitch a {\n\tcase CompareNotEqual:\n\t\treturn C.C_CMP_NE\n\tcase CompareLess:\n\t\treturn C.C_CMP_LT\n\tcase CompareLessOrEqual:\n\t\treturn C.C_CMP_LE\n\tcase CompareEqual:\n\t\treturn C.C_CMP_EQ\n\tcase CompareGreaterEqual:\n\t\treturn C.C_CMP_GE\n\tcase CompareGreater:\n\t\treturn C.C_CMP_GT\n\tcase CompareMaskedEqual:\n\t\treturn C.C_CMP_MASKED_EQ\n\tdefault:\n\t\treturn 0x0\n\t}\n}\n\nfunc actionFromNative(a C.uint32_t) (ScmpAction, error) {\n\taTmp := a & 0xFFFF\n\tswitch a & 0xFFFF0000 {\n\tcase C.C_ACT_KILL:\n\t\treturn ActKill, nil\n\tcase C.C_ACT_TRAP:\n\t\treturn ActTrap, nil\n\tcase C.C_ACT_ERRNO:\n\t\treturn ActErrno.SetReturnCode(int16(aTmp)), nil\n\tcase C.C_ACT_TRACE:\n\t\treturn ActTrace.SetReturnCode(int16(aTmp)), nil\n\tcase C.C_ACT_ALLOW:\n\t\treturn ActAllow, nil\n\tdefault:\n\t\treturn 0x0, fmt.Errorf(\"unrecognized action\")\n\t}\n}\n\n// Only use with sanitized actions, no error handling\nfunc (a ScmpAction) toNative() C.uint32_t {\n\tswitch a & 0xFFFF {\n\tcase ActKill:\n\t\treturn C.C_ACT_KILL\n\tcase ActTrap:\n\t\treturn C.C_ACT_TRAP\n\tcase ActErrno:\n\t\treturn C.C_ACT_ERRNO | (C.uint32_t(a) >> 16)\n\tcase ActTrace:\n\t\treturn C.C_ACT_TRACE | (C.uint32_t(a) >> 16)\n\tcase ActAllow:\n\t\treturn C.C_ACT_ALLOW\n\tdefault:\n\t\treturn 0x0\n\t}\n}\n\n// Internal only, assumes safe attribute\nfunc (a scmpFilterAttr) toNative() uint32 {\n\tswitch a {\n\tcase filterAttrActDefault:\n\t\treturn uint32(C.C_ATTRIBUTE_DEFAULT)\n\tcase filterAttrActBadArch:\n\t\treturn uint32(C.C_ATTRIBUTE_BADARCH)\n\tcase filterAttrNNP:\n\t\treturn uint32(C.C_ATTRIBUTE_NNP)\n\tcase filterAttrTsync:\n\t\treturn uint32(C.C_ATTRIBUTE_TSYNC)\n\tdefault:\n\t\treturn 0x0\n\t}\n}\n"], "filenames": ["seccomp_internal.go"], "buggy_code_start_loc": [123], "buggy_code_end_loc": [297], "fixing_code_start_loc": [123], "fixing_code_end_loc": [307], "type": "CWE-20", "message": "libseccomp-golang 0.9.0 and earlier incorrectly generates BPFs that OR multiple arguments rather than ANDing them. A process running under a restrictive seccomp filter that specified multiple syscall arguments could bypass intended access restrictions by specifying a single matching argument.", "other": {"cve": {"id": "CVE-2017-18367", "sourceIdentifier": "cve@mitre.org", "published": "2019-04-24T21:29:00.243", "lastModified": "2020-10-14T22:15:12.450", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "libseccomp-golang 0.9.0 and earlier incorrectly generates BPFs that OR multiple arguments rather than ANDing them. A process running under a restrictive seccomp filter that specified multiple syscall arguments could bypass intended access restrictions by specifying a single matching argument."}, {"lang": "es", "value": "libseccomp-golang versi\u00f3n 0.9.0 y anteriores, BPF generan incorrectamente m\u00faltiples argumentos OR en lugar de ANDing. Un proceso que se realiza bajo un filtro seccomp restrictivo que especific\u00f3 m\u00faltiples argumentos de syscall podr\u00eda omitir las restricciones de acceso previstas al especificar un \u00fanico argumento coincidente."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libseccomp-golang_project:libseccomp-golang:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.9.0", "matchCriteriaId": "6BE659D4-728B-49ED-878F-D0F43E9C2B31"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2019/04/25/6", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:4087", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:4090", "source": "cve@mitre.org"}, {"url": "https://github.com/seccomp/libseccomp-golang/commit/06e7a29f36a34b8cf419aeb87b979ee508e58f9e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/seccomp/libseccomp-golang/issues/22", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/08/msg00016.html", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4574-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/seccomp/libseccomp-golang/commit/06e7a29f36a34b8cf419aeb87b979ee508e58f9e"}}