{"buggy_code": ["package org.thp.cortex.controllers\n\nimport javax.inject.{ Inject, Singleton }\n\nimport scala.concurrent.{ ExecutionContext, Future }\nimport scala.util.Try\n\nimport play.api.Logger\nimport play.api.http.Status\nimport play.api.libs.json.{ JsObject, Json }\nimport play.api.mvc._\n\nimport org.thp.cortex.models.{ OrganizationStatus, Roles }\nimport org.thp.cortex.services.{ OrganizationSrv, UserSrv }\n\nimport org.elastic4play.models.JsonFormat.baseModelEntityWrites\nimport org.elastic4play.services.JsonFormat.queryReads\nimport org.elastic4play.controllers.{ Authenticated, Fields, FieldsBodyParser, Renderer }\nimport org.elastic4play.services.{ AuthContext, AuthSrv, QueryDSL, QueryDef }\nimport org.elastic4play._\n\n@Singleton\nclass UserCtrl @Inject() (\n    userSrv: UserSrv,\n    authSrv: AuthSrv,\n    organizationSrv: OrganizationSrv,\n    authenticated: Authenticated,\n    renderer: Renderer,\n    fieldsBodyParser: FieldsBodyParser,\n    components: ControllerComponents,\n    implicit val ec: ExecutionContext) extends AbstractController(components) with Status {\n\n  private[UserCtrl] lazy val logger = Logger(getClass)\n\n  @Timed\n  def create: Action[Fields] = authenticated(Roles.orgAdmin, Roles.superAdmin).async(fieldsBodyParser) { implicit request \u21d2\n    (for {\n      userOrganizationId \u2190 if (request.userId == \"init\") Future.successful(\"cortex\") else userSrv.getOrganizationId(request.userId)\n      organizationId = request.body.getString(\"organization\").getOrElse(userOrganizationId)\n      // Check if organization is valid\n      organization \u2190 organizationSrv.get(organizationId)\n      if organization.status() == OrganizationStatus.Active &&\n        (request.roles.contains(Roles.superAdmin) ||\n          (userOrganizationId == organizationId &&\n            !request.body.getStrings(\"roles\").getOrElse(Nil).contains(Roles.superAdmin.toString)))\n      user \u2190 userSrv.create(request.body.set(\"organization\", organizationId))\n    } yield renderer.toOutput(CREATED, user))\n      .recoverWith {\n        case _: NoSuchElementException \u21d2 Future.failed(AuthorizationError(\"You are not authorized to perform this action\"))\n      }\n  }\n\n  @Timed\n  def get(userId: String): Action[AnyContent] = authenticated(Roles.read, Roles.superAdmin).async { implicit request \u21d2\n    val isSuperAdmin = request.authContext.roles.contains(Roles.superAdmin)\n    (for {\n      user \u2190 userSrv.get(userId)\n      organizationId \u2190 userSrv.getOrganizationId(request.userId)\n      if isSuperAdmin || organizationId == user.organization()\n    } yield renderer.toOutput(OK, user))\n      .recoverWith {\n        case _: NoSuchElementException \u21d2 Future.failed(NotFoundError(s\"user $userId not found\"))\n      }\n  }\n\n  @Timed\n  def update(userId: String): Action[Fields] = authenticated().async(fieldsBodyParser) { implicit request \u21d2\n    val fields = request.body\n\n    def superAdminChecks: Future[Unit] = {\n      for {\n        userOrganizationId \u2190 fields.getString(\"organization\").fold(userSrv.getOrganizationId(userId))(Future.successful)\n        organization \u2190 organizationSrv.get(userOrganizationId)\n        _ \u2190 if (organization.status() == OrganizationStatus.Active) Future.successful(()) else Future.failed(BadRequestError(s\"Organization $userOrganizationId is locked\"))\n        // check roles and organization\n        _ \u2190 fields.getStrings(\"roles\").map(_.flatMap(Roles.withName)).fold(Future.successful(())) {\n          case roles if userOrganizationId == \"cortex\" && roles == Seq(Roles.superAdmin) \u21d2 Future.successful(())\n          case roles if userOrganizationId != \"cortex\" && !roles.contains(Roles.superAdmin) \u21d2 Future.successful(())\n          case _ if userOrganizationId == \"cortex\" \u21d2 Future.failed(BadRequestError(\"The organization \\\"cortex\\\" can contain only superadmin users\"))\n          case _ \u21d2 Future.failed(BadRequestError(\"The organization \\\"cortex\\\" alone can contain superadmin users\"))\n        }\n        // check status\n        _ \u2190 fields.getString(\"status\").fold(Future.successful(())) {\n          case _ if userId != request.userId \u21d2 Future.successful(())\n          case _                             \u21d2 Future.failed(BadRequestError(\"You can't modify your status\"))\n        }\n      } yield ()\n    }\n\n    def orgAdminChecks: Future[Unit] = {\n      for {\n        subjectUserOrganization \u2190 userSrv.getOrganizationId(request.userId)\n        targetUserOrganization \u2190 userSrv.getOrganizationId(userId)\n        _ \u2190 if (subjectUserOrganization == targetUserOrganization) Future.successful(()) else Future.failed(NotFoundError(s\"user $userId not found\"))\n        // check roles\n        _ \u2190 fields.getStrings(\"roles\").map(_.flatMap(Roles.withName)).fold(Future.successful(())) {\n          case roles if !roles.contains(Roles.superAdmin) \u21d2 Future.successful(())\n          case _                                          \u21d2 Future.failed(AuthorizationError(\"You can't give superadmin right to an user\"))\n        }\n        // check organization\n        _ \u2190 if (fields.getString(\"organization\").fold(true)(_ == targetUserOrganization)) Future.successful(()) else Future.failed(AuthorizationError(\"You can't move an user to another organization\"))\n      } yield ()\n    }\n\n    def userChecks: Future[Unit] = {\n      if (fields.contains(\"organization\")) Future.failed(AuthorizationError(\"You can't change your organization\"))\n      else if (fields.contains(\"roles\")) Future.failed(AuthorizationError(\"You can't change your role\"))\n      else if (fields.contains(\"status\")) Future.failed(AuthorizationError(\"You can't change your status\"))\n      else Future.successful(())\n    }\n\n    def authChecks: Future[Unit] = {\n      if (request.body.contains(\"password\")) Future.failed(AuthorizationError(\"You must use dedicated API (setPassword, changePassword) to update password\"))\n      else if (request.body.contains(\"key\")) Future.failed(AuthorizationError(\"You must use dedicated API (renewKey, removeKey) to update key\"))\n      else Future.successful(())\n    }\n\n    for {\n      _ \u2190 if (userId == request.authContext.userId) userChecks\n      else if (request.authContext.roles.contains(Roles.superAdmin)) superAdminChecks\n      else if (request.authContext.roles.contains(Roles.orgAdmin)) orgAdminChecks\n      else Future.failed(AuthorizationError(\"You are not permitted to change user settings\"))\n      _ \u2190 authChecks\n      user \u2190 userSrv.update(userId, request.body)\n    } yield renderer.toOutput(OK, user)\n  }\n\n  @Timed\n  def setPassword(userId: String): Action[Fields] = authenticated(Roles.orgAdmin, Roles.superAdmin).async(fieldsBodyParser) { implicit request \u21d2\n    val isSuperAdmin = request.authContext.roles.contains(Roles.superAdmin)\n    request.body.getString(\"password\").fold(Future.failed[Result](MissingAttributeError(\"password\"))) { password \u21d2\n      for {\n        targetOrganization \u2190 userSrv.getOrganizationId(userId)\n        userOrganization \u2190 userSrv.getOrganizationId(request.userId)\n        if targetOrganization == userOrganization || isSuperAdmin\n        _ \u2190 authSrv.setPassword(userId, password)\n      } yield NoContent\n    }\n      .recoverWith { case _: NoSuchElementException \u21d2 Future.failed(NotFoundError(s\"user $userId not found\")) }\n  }\n\n  @Timed\n  def changePassword(userId: String): Action[Fields] = authenticated().async(fieldsBodyParser) { implicit request \u21d2\n    if (userId == request.authContext.userId) {\n      for {\n        password \u2190 request.body.getString(\"password\").fold(Future.failed[String](MissingAttributeError(\"password\")))(Future.successful)\n        currentPassword \u2190 request.body.getString(\"currentPassword\").fold(Future.failed[String](MissingAttributeError(\"currentPassword\")))(Future.successful)\n        _ \u2190 authSrv.changePassword(userId, currentPassword, password)\n      } yield NoContent\n    }\n    else\n      Future.failed(AuthorizationError(\"You can't change password of another user\"))\n  }\n\n  @Timed\n  def delete(userId: String): Action[AnyContent] = authenticated(Roles.orgAdmin, Roles.superAdmin).async { implicit request \u21d2\n    val isSuperAdmin = request.authContext.roles.contains(Roles.superAdmin)\n    for {\n      targetOrganization \u2190 userSrv.getOrganizationId(userId)\n      userOrganization \u2190 userSrv.getOrganizationId(request.userId)\n      _ \u2190 if (targetOrganization == userOrganization || isSuperAdmin) Future.successful(()) else Future.failed(NotFoundError(s\"user $userId not found\"))\n      _ \u2190 if (userId != request.userId) Future.successful(()) else Future.failed(BadRequestError(s\"You cannot disable your own account\"))\n      _ \u2190 userSrv.delete(userId)\n    } yield NoContent\n  }\n\n  @Timed\n  def currentUser: Action[AnyContent] = Action.async { implicit request \u21d2\n    for {\n      authContext \u2190 authenticated.getContext(request)\n      user \u2190 userSrv.get(authContext.userId)\n      preferences = Try(Json.parse(user.preferences()))\n        .getOrElse {\n          logger.warn(s\"User ${authContext.userId} has invalid preference format: ${user.preferences()}\")\n          JsObject.empty\n        }\n      json = user.toJson + (\"preferences\" \u2192 preferences)\n    } yield renderer.toOutput(OK, json)\n  }\n\n  @Timed\n  def find: Action[Fields] = authenticated(Roles.superAdmin).async(fieldsBodyParser) { implicit request \u21d2\n    val query = request.body.getValue(\"query\").fold[QueryDef](QueryDSL.any)(_.as[QueryDef])\n    val range = request.body.getString(\"range\")\n    val sort = request.body.getStrings(\"sort\").getOrElse(Nil)\n    val (users, total) = userSrv.find(query, range, sort)\n    renderer.toOutput(OK, users, total)\n\n  }\n\n  def findForOrganization(organizationId: String): Action[Fields] = authenticated(Roles.orgAdmin, Roles.superAdmin).async(fieldsBodyParser) { implicit request \u21d2\n    import org.elastic4play.services.QueryDSL._\n    val isSuperAdmin = request.roles.contains(Roles.superAdmin)\n    val query = request.body.getValue(\"query\").fold[QueryDef](QueryDSL.any)(_.as[QueryDef])\n    val range = request.body.getString(\"range\")\n    val sort = request.body.getStrings(\"sort\").getOrElse(Nil)\n    val (users, total) = if (isSuperAdmin) userSrv.findForOrganization(organizationId, query, range, sort)\n    else userSrv.findForUser(request.userId, and(\"organization\" ~= organizationId, query), range, sort)\n    renderer.toOutput(OK, users, total)\n  }\n\n  private def checkUserOrganization(userId: String)(implicit authContext: AuthContext): Future[Unit] = {\n    if (authContext.roles.contains(Roles.superAdmin)) Future.successful(())\n    else (for {\n      userOrganization1 \u2190 userSrv.getOrganizationId(authContext.userId)\n      userOrganization2 \u2190 userSrv.getOrganizationId(userId)\n      if userOrganization1 == userOrganization2\n    } yield ())\n      .recoverWith { case _ \u21d2 Future.failed(NotFoundError(s\"user $userId not found\")) }\n  }\n\n  @Timed\n  def getKey(userId: String): Action[AnyContent] = authenticated().async { implicit request \u21d2\n    for {\n      _ \u2190 checkUserOrganization(userId)\n      _ \u2190 if (userId == request.userId || request.roles.contains(Roles.orgAdmin) || request.roles.contains(Roles.superAdmin)) Future.successful(())\n      else Future.failed(AuthorizationError(\"You are not authorized to perform this operation\"))\n      key \u2190 authSrv.getKey(userId)\n    } yield Ok(key)\n  }\n\n  @Timed\n  def removeKey(userId: String): Action[AnyContent] = authenticated(Roles.orgAdmin, Roles.superAdmin).async { implicit request \u21d2\n    for {\n      _ \u2190 checkUserOrganization(userId)\n      _ \u2190 authSrv.removeKey(userId)\n    } yield NoContent\n  }\n\n  @Timed\n  def renewKey(userId: String): Action[AnyContent] = authenticated().async { implicit request \u21d2\n    for {\n      _ \u2190 checkUserOrganization(userId)\n      _ \u2190 if (userId == request.userId || request.roles.contains(Roles.orgAdmin) || request.roles.contains(Roles.superAdmin)) Future.successful(())\n      else Future.failed(AuthorizationError(\"You are not authorized to perform this operation\"))\n      key \u2190 authSrv.renewKey(userId)\n    } yield Ok(key)\n  }\n}"], "fixing_code": ["package org.thp.cortex.controllers\n\nimport javax.inject.{ Inject, Singleton }\n\nimport scala.concurrent.{ ExecutionContext, Future }\nimport scala.util.Try\n\nimport play.api.Logger\nimport play.api.http.Status\nimport play.api.libs.json.{ JsObject, Json }\nimport play.api.mvc._\n\nimport org.thp.cortex.models.{ OrganizationStatus, Roles }\nimport org.thp.cortex.services.{ OrganizationSrv, UserSrv }\n\nimport org.elastic4play.models.JsonFormat.baseModelEntityWrites\nimport org.elastic4play.services.JsonFormat.queryReads\nimport org.elastic4play.controllers.{ Authenticated, Fields, FieldsBodyParser, Renderer }\nimport org.elastic4play.services.{ AuthContext, AuthSrv, QueryDSL, QueryDef }\nimport org.elastic4play._\n\n@Singleton\nclass UserCtrl @Inject() (\n    userSrv: UserSrv,\n    authSrv: AuthSrv,\n    organizationSrv: OrganizationSrv,\n    authenticated: Authenticated,\n    renderer: Renderer,\n    fieldsBodyParser: FieldsBodyParser,\n    components: ControllerComponents,\n    implicit val ec: ExecutionContext) extends AbstractController(components) with Status {\n\n  private[UserCtrl] lazy val logger = Logger(getClass)\n\n  @Timed\n  def create: Action[Fields] = authenticated(Roles.orgAdmin, Roles.superAdmin).async(fieldsBodyParser) { implicit request \u21d2\n    (for {\n      userOrganizationId \u2190 if (request.userId == \"init\") Future.successful(\"cortex\") else userSrv.getOrganizationId(request.userId)\n      organizationId = request.body.getString(\"organization\").getOrElse(userOrganizationId)\n      // Check if organization is valid\n      organization \u2190 organizationSrv.get(organizationId)\n      if organization.status() == OrganizationStatus.Active &&\n        (request.roles.contains(Roles.superAdmin) ||\n          (userOrganizationId == organizationId &&\n            !request.body.getStrings(\"roles\").getOrElse(Nil).contains(Roles.superAdmin.name)))\n      user \u2190 userSrv.create(request.body.set(\"organization\", organizationId))\n    } yield renderer.toOutput(CREATED, user))\n      .recoverWith {\n        case _: NoSuchElementException \u21d2 Future.failed(AuthorizationError(\"You are not authorized to perform this action\"))\n      }\n  }\n\n  @Timed\n  def get(userId: String): Action[AnyContent] = authenticated(Roles.read, Roles.superAdmin).async { implicit request \u21d2\n    val isSuperAdmin = request.authContext.roles.contains(Roles.superAdmin)\n    (for {\n      user \u2190 userSrv.get(userId)\n      organizationId \u2190 userSrv.getOrganizationId(request.userId)\n      if isSuperAdmin || organizationId == user.organization()\n    } yield renderer.toOutput(OK, user))\n      .recoverWith {\n        case _: NoSuchElementException \u21d2 Future.failed(NotFoundError(s\"user $userId not found\"))\n      }\n  }\n\n  @Timed\n  def update(userId: String): Action[Fields] = authenticated().async(fieldsBodyParser) { implicit request \u21d2\n    val fields = request.body\n\n    def superAdminChecks: Future[Unit] = {\n      for {\n        userOrganizationId \u2190 fields.getString(\"organization\").fold(userSrv.getOrganizationId(userId))(Future.successful)\n        organization \u2190 organizationSrv.get(userOrganizationId)\n        _ \u2190 if (organization.status() == OrganizationStatus.Active) Future.successful(()) else Future.failed(BadRequestError(s\"Organization $userOrganizationId is locked\"))\n        // check roles and organization\n        _ \u2190 fields.getStrings(\"roles\").map(_.flatMap(Roles.withName)).fold(Future.successful(())) {\n          case roles if userOrganizationId == \"cortex\" && roles == Seq(Roles.superAdmin) \u21d2 Future.successful(())\n          case roles if userOrganizationId != \"cortex\" && !roles.contains(Roles.superAdmin) \u21d2 Future.successful(())\n          case _ if userOrganizationId == \"cortex\" \u21d2 Future.failed(BadRequestError(\"The organization \\\"cortex\\\" can contain only superadmin users\"))\n          case _ \u21d2 Future.failed(BadRequestError(\"The organization \\\"cortex\\\" alone can contain superadmin users\"))\n        }\n        // check status\n        _ \u2190 fields.getString(\"status\").fold(Future.successful(())) {\n          case _ if userId != request.userId \u21d2 Future.successful(())\n          case _                             \u21d2 Future.failed(BadRequestError(\"You can't modify your status\"))\n        }\n      } yield ()\n    }\n\n    def orgAdminChecks: Future[Unit] = {\n      for {\n        subjectUserOrganization \u2190 userSrv.getOrganizationId(request.userId)\n        targetUserOrganization \u2190 userSrv.getOrganizationId(userId)\n        _ \u2190 if (subjectUserOrganization == targetUserOrganization) Future.successful(()) else Future.failed(NotFoundError(s\"user $userId not found\"))\n        // check roles\n        _ \u2190 fields.getStrings(\"roles\").map(_.flatMap(Roles.withName)).fold(Future.successful(())) {\n          case roles if !roles.contains(Roles.superAdmin) \u21d2 Future.successful(())\n          case _                                          \u21d2 Future.failed(AuthorizationError(\"You can't give superadmin right to an user\"))\n        }\n        // check organization\n        _ \u2190 if (fields.getString(\"organization\").fold(true)(_ == targetUserOrganization)) Future.successful(()) else Future.failed(AuthorizationError(\"You can't move an user to another organization\"))\n      } yield ()\n    }\n\n    def userChecks: Future[Unit] = {\n      if (fields.contains(\"organization\")) Future.failed(AuthorizationError(\"You can't change your organization\"))\n      else if (fields.contains(\"roles\")) Future.failed(AuthorizationError(\"You can't change your role\"))\n      else if (fields.contains(\"status\")) Future.failed(AuthorizationError(\"You can't change your status\"))\n      else Future.successful(())\n    }\n\n    def authChecks: Future[Unit] = {\n      if (request.body.contains(\"password\")) Future.failed(AuthorizationError(\"You must use dedicated API (setPassword, changePassword) to update password\"))\n      else if (request.body.contains(\"key\")) Future.failed(AuthorizationError(\"You must use dedicated API (renewKey, removeKey) to update key\"))\n      else Future.successful(())\n    }\n\n    for {\n      _ \u2190 if (userId == request.authContext.userId) userChecks\n      else if (request.authContext.roles.contains(Roles.superAdmin)) superAdminChecks\n      else if (request.authContext.roles.contains(Roles.orgAdmin)) orgAdminChecks\n      else Future.failed(AuthorizationError(\"You are not permitted to change user settings\"))\n      _ \u2190 authChecks\n      user \u2190 userSrv.update(userId, request.body)\n    } yield renderer.toOutput(OK, user)\n  }\n\n  @Timed\n  def setPassword(userId: String): Action[Fields] = authenticated(Roles.orgAdmin, Roles.superAdmin).async(fieldsBodyParser) { implicit request \u21d2\n    val isSuperAdmin = request.authContext.roles.contains(Roles.superAdmin)\n    request.body.getString(\"password\").fold(Future.failed[Result](MissingAttributeError(\"password\"))) { password \u21d2\n      for {\n        targetOrganization \u2190 userSrv.getOrganizationId(userId)\n        userOrganization \u2190 userSrv.getOrganizationId(request.userId)\n        if targetOrganization == userOrganization || isSuperAdmin\n        _ \u2190 authSrv.setPassword(userId, password)\n      } yield NoContent\n    }\n      .recoverWith { case _: NoSuchElementException \u21d2 Future.failed(NotFoundError(s\"user $userId not found\")) }\n  }\n\n  @Timed\n  def changePassword(userId: String): Action[Fields] = authenticated().async(fieldsBodyParser) { implicit request \u21d2\n    if (userId == request.authContext.userId) {\n      for {\n        password \u2190 request.body.getString(\"password\").fold(Future.failed[String](MissingAttributeError(\"password\")))(Future.successful)\n        currentPassword \u2190 request.body.getString(\"currentPassword\").fold(Future.failed[String](MissingAttributeError(\"currentPassword\")))(Future.successful)\n        _ \u2190 authSrv.changePassword(userId, currentPassword, password)\n      } yield NoContent\n    }\n    else\n      Future.failed(AuthorizationError(\"You can't change password of another user\"))\n  }\n\n  @Timed\n  def delete(userId: String): Action[AnyContent] = authenticated(Roles.orgAdmin, Roles.superAdmin).async { implicit request \u21d2\n    val isSuperAdmin = request.authContext.roles.contains(Roles.superAdmin)\n    for {\n      targetOrganization \u2190 userSrv.getOrganizationId(userId)\n      userOrganization \u2190 userSrv.getOrganizationId(request.userId)\n      _ \u2190 if (targetOrganization == userOrganization || isSuperAdmin) Future.successful(()) else Future.failed(NotFoundError(s\"user $userId not found\"))\n      _ \u2190 if (userId != request.userId) Future.successful(()) else Future.failed(BadRequestError(s\"You cannot disable your own account\"))\n      _ \u2190 userSrv.delete(userId)\n    } yield NoContent\n  }\n\n  @Timed\n  def currentUser: Action[AnyContent] = Action.async { implicit request \u21d2\n    for {\n      authContext \u2190 authenticated.getContext(request)\n      user \u2190 userSrv.get(authContext.userId)\n      preferences = Try(Json.parse(user.preferences()))\n        .getOrElse {\n          logger.warn(s\"User ${authContext.userId} has invalid preference format: ${user.preferences()}\")\n          JsObject.empty\n        }\n      json = user.toJson + (\"preferences\" \u2192 preferences)\n    } yield renderer.toOutput(OK, json)\n  }\n\n  @Timed\n  def find: Action[Fields] = authenticated(Roles.superAdmin).async(fieldsBodyParser) { implicit request \u21d2\n    val query = request.body.getValue(\"query\").fold[QueryDef](QueryDSL.any)(_.as[QueryDef])\n    val range = request.body.getString(\"range\")\n    val sort = request.body.getStrings(\"sort\").getOrElse(Nil)\n    val (users, total) = userSrv.find(query, range, sort)\n    renderer.toOutput(OK, users, total)\n\n  }\n\n  def findForOrganization(organizationId: String): Action[Fields] = authenticated(Roles.orgAdmin, Roles.superAdmin).async(fieldsBodyParser) { implicit request \u21d2\n    import org.elastic4play.services.QueryDSL._\n    val isSuperAdmin = request.roles.contains(Roles.superAdmin)\n    val query = request.body.getValue(\"query\").fold[QueryDef](QueryDSL.any)(_.as[QueryDef])\n    val range = request.body.getString(\"range\")\n    val sort = request.body.getStrings(\"sort\").getOrElse(Nil)\n    val (users, total) = if (isSuperAdmin) userSrv.findForOrganization(organizationId, query, range, sort)\n    else userSrv.findForUser(request.userId, and(\"organization\" ~= organizationId, query), range, sort)\n    renderer.toOutput(OK, users, total)\n  }\n\n  private def checkUserOrganization(userId: String)(implicit authContext: AuthContext): Future[Unit] = {\n    if (authContext.roles.contains(Roles.superAdmin)) Future.successful(())\n    else (for {\n      userOrganization1 \u2190 userSrv.getOrganizationId(authContext.userId)\n      userOrganization2 \u2190 userSrv.getOrganizationId(userId)\n      if userOrganization1 == userOrganization2\n    } yield ())\n      .recoverWith { case _ \u21d2 Future.failed(NotFoundError(s\"user $userId not found\")) }\n  }\n\n  @Timed\n  def getKey(userId: String): Action[AnyContent] = authenticated().async { implicit request \u21d2\n    for {\n      _ \u2190 checkUserOrganization(userId)\n      _ \u2190 if (userId == request.userId || request.roles.contains(Roles.orgAdmin) || request.roles.contains(Roles.superAdmin)) Future.successful(())\n      else Future.failed(AuthorizationError(\"You are not authorized to perform this operation\"))\n      key \u2190 authSrv.getKey(userId)\n    } yield Ok(key)\n  }\n\n  @Timed\n  def removeKey(userId: String): Action[AnyContent] = authenticated(Roles.orgAdmin, Roles.superAdmin).async { implicit request \u21d2\n    for {\n      _ \u2190 checkUserOrganization(userId)\n      _ \u2190 authSrv.removeKey(userId)\n    } yield NoContent\n  }\n\n  @Timed\n  def renewKey(userId: String): Action[AnyContent] = authenticated().async { implicit request \u21d2\n    for {\n      _ \u2190 checkUserOrganization(userId)\n      _ \u2190 if (userId == request.userId || request.roles.contains(Roles.orgAdmin) || request.roles.contains(Roles.superAdmin)) Future.successful(())\n      else Future.failed(AuthorizationError(\"You are not authorized to perform this operation\"))\n      key \u2190 authSrv.renewKey(userId)\n    } yield Ok(key)\n  }\n}"], "filenames": ["app/org/thp/cortex/controllers/UserCtrl.scala"], "buggy_code_start_loc": [45], "buggy_code_end_loc": [46], "fixing_code_start_loc": [45], "fixing_code_end_loc": [46], "type": "NVD-CWE-noinfo", "message": "An organization administrator can add a super administrator in THEHIVE PROJECT Cortex before 2.1.3 due to the lack of overriding the Role.toString method.", "other": {"cve": {"id": "CVE-2018-20226", "sourceIdentifier": "cve@mitre.org", "published": "2018-12-21T23:29:00.853", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An organization administrator can add a super administrator in THEHIVE PROJECT Cortex before 2.1.3 due to the lack of overriding the Role.toString method."}, {"lang": "es", "value": "Un administrador de la organizaci\u00f3n puede a\u00f1adir un superadministrador en THEHIVE PROJECT Cortex, en versiones anteriores a la 2.1.3, debido a la falta de anulaci\u00f3n del m\u00e9todo Role.toString."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:thehive-project:cortex:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.3", "matchCriteriaId": "67012CAD-69C5-4D19-9555-61CA1A5D0495"}]}]}], "references": [{"url": "https://github.com/TheHive-Project/Cortex/blob/2.1.3/CHANGELOG.md", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/TheHive-Project/Cortex/commit/1aaf2182a6b722ad539e2717bc11967d1bde723a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/TheHive-Project/Cortex/issues/158", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/TheHive-Project/Cortex/commit/1aaf2182a6b722ad539e2717bc11967d1bde723a"}}