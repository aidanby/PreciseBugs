{"buggy_code": [";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(in-ns 'clojure.core)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;; proxy ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(import\n '(clojure.asm ClassWriter ClassVisitor Opcodes Type) \n '(java.lang.reflect Modifier Constructor)\n '(clojure.asm.commons Method GeneratorAdapter)\n '(clojure.lang IProxy Reflector DynamicClassLoader IPersistentMap PersistentHashMap RT))\n\n(defn method-sig [^java.lang.reflect.Method meth]\n  [(. meth (getName)) (seq (. meth (getParameterTypes))) (. meth getReturnType)])\n\n(defn- most-specific [rtypes]\n  (or (some (fn [t] (when (every? #(isa? t %) rtypes) t)) rtypes)\n    (throw (Exception. \"Incompatible return types\"))))\n\n(defn- group-by-sig [coll]\n \"takes a collection of [msig meth] and returns a seq of maps from return-types to meths.\"\n  (vals (reduce1 (fn [m [msig meth]]\n                  (let [rtype (peek msig)\n                        argsig (pop msig)]\n                    (assoc m argsig (assoc (m argsig {}) rtype meth))))\n          {} coll)))\n\n(defn proxy-name\n {:tag String} \n [^Class super interfaces]\n  (let [inames (into1 (sorted-set) (map #(.getName ^Class %) interfaces))]\n    (apply str (.replace (str *ns*) \\- \\_) \".proxy\"\n      (interleave (repeat \"$\")\n        (concat\n          [(.getName super)]\n          (map #(subs % (inc (.lastIndexOf ^String % \".\"))) inames)\n          [(Integer/toHexString (hash inames))])))))\n\n(defn- generate-proxy [^Class super interfaces]\n  (let [cv (new ClassWriter (. ClassWriter COMPUTE_MAXS))\n        cname (.replace (proxy-name super interfaces) \\. \\/) ;(str \"clojure/lang/\" (gensym \"Proxy__\"))\n        ctype (. Type (getObjectType cname))\n        iname (fn [^Class c] (.. Type (getType c) (getInternalName)))\n        fmap \"__clojureFnMap\"\n        totype (fn [^Class c] (. Type (getType c)))\n        to-types (fn [cs] (if (pos? (count cs))\n                            (into-array (map totype cs))\n                            (make-array Type 0)))\n        super-type ^Type (totype super)\n        imap-type ^Type (totype IPersistentMap)\n        ifn-type (totype clojure.lang.IFn)\n        obj-type (totype Object)\n        sym-type (totype clojure.lang.Symbol)\n        rt-type  (totype clojure.lang.RT)\n        ex-type  (totype java.lang.UnsupportedOperationException)\n        gen-bridge \n        (fn [^java.lang.reflect.Method meth ^java.lang.reflect.Method dest]\n            (let [pclasses (. meth (getParameterTypes))\n                  ptypes (to-types pclasses)\n                  rtype ^Type (totype (. meth (getReturnType)))\n                  m (new Method (. meth (getName)) rtype ptypes)\n                  dtype (totype (.getDeclaringClass dest))\n                  dm (new Method (. dest (getName)) (totype (. dest (getReturnType))) (to-types (. dest (getParameterTypes))))\n                  gen (new GeneratorAdapter (bit-or (. Opcodes ACC_PUBLIC) (. Opcodes ACC_BRIDGE)) m nil nil cv)]\n              (. gen (visitCode))\n              (. gen (loadThis))\n              (dotimes [i (count ptypes)]\n                  (. gen (loadArg i)))\n              (if (-> dest .getDeclaringClass .isInterface)\n                (. gen (invokeInterface dtype dm))\n                (. gen (invokeVirtual dtype dm)))\n              (. gen (returnValue))\n              (. gen (endMethod))))\n        gen-method\n        (fn [^java.lang.reflect.Method meth else-gen]\n            (let [pclasses (. meth (getParameterTypes))\n                  ptypes (to-types pclasses)\n                  rtype ^Type (totype (. meth (getReturnType)))\n                  m (new Method (. meth (getName)) rtype ptypes)\n                  gen (new GeneratorAdapter (. Opcodes ACC_PUBLIC) m nil nil cv)\n                  else-label (. gen (newLabel))\n                  end-label (. gen (newLabel))\n                  decl-type (. Type (getType (. meth (getDeclaringClass))))]\n              (. gen (visitCode))\n              (if (> (count pclasses) 18)\n                (else-gen gen m)\n                (do\n                  (. gen (loadThis))\n                  (. gen (getField ctype fmap imap-type))\n                  \n                  (. gen (push (. meth (getName))))\n                                        ;lookup fn in map\n                  (. gen (invokeStatic rt-type (. Method (getMethod \"Object get(Object, Object)\"))))\n                  (. gen (dup))\n                  (. gen (ifNull else-label))\n                                        ;if found\n                  (.checkCast gen ifn-type)\n                  (. gen (loadThis))\n                                        ;box args\n                  (dotimes [i (count ptypes)]\n                      (. gen (loadArg i))\n                    (. clojure.lang.Compiler$HostExpr (emitBoxReturn nil gen (nth pclasses i))))\n                                        ;call fn\n                  (. gen (invokeInterface ifn-type (new Method \"invoke\" obj-type \n                                                        (into-array (cons obj-type \n                                                                          (replicate (count ptypes) obj-type))))))\n                                        ;unbox return\n                  (. gen (unbox rtype))\n                  (when (= (. rtype (getSort)) (. Type VOID))\n                    (. gen (pop)))\n                  (. gen (goTo end-label))\n                  \n                                        ;else call supplied alternative generator\n                  (. gen (mark else-label))\n                  (. gen (pop))\n                  \n                  (else-gen gen m)\n                  \n                  (. gen (mark end-label))))\n              (. gen (returnValue))\n              (. gen (endMethod))))]\n    \n                                        ;start class definition\n    (. cv (visit (. Opcodes V1_5) (+ (. Opcodes ACC_PUBLIC) (. Opcodes ACC_SUPER))\n                 cname nil (iname super) \n                 (into-array (map iname (cons IProxy interfaces)))))\n                                        ;add field for fn mappings\n    (. cv (visitField (+ (. Opcodes ACC_PRIVATE) (. Opcodes ACC_VOLATILE))\n                      fmap (. imap-type (getDescriptor)) nil nil))          \n                                        ;add ctors matching/calling super's\n    (doseq [^Constructor ctor (. super (getDeclaredConstructors))]\n        (when-not (. Modifier (isPrivate (. ctor (getModifiers))))\n          (let [ptypes (to-types (. ctor (getParameterTypes)))\n                m (new Method \"<init>\" (. Type VOID_TYPE) ptypes)\n                gen (new GeneratorAdapter (. Opcodes ACC_PUBLIC) m nil nil cv)]\n            (. gen (visitCode))\n                                        ;call super ctor\n            (. gen (loadThis))\n            (. gen (dup))\n            (. gen (loadArgs))\n            (. gen (invokeConstructor super-type m))\n            \n            (. gen (returnValue))\n            (. gen (endMethod)))))\n                                        ;add IProxy methods\n    (let [m (. Method (getMethod \"void __initClojureFnMappings(clojure.lang.IPersistentMap)\"))\n          gen (new GeneratorAdapter (. Opcodes ACC_PUBLIC) m nil nil cv)]\n      (. gen (visitCode))\n      (. gen (loadThis))\n      (. gen (loadArgs))\n      (. gen (putField ctype fmap imap-type))\n      \n      (. gen (returnValue))\n      (. gen (endMethod)))\n    (let [m (. Method (getMethod \"void __updateClojureFnMappings(clojure.lang.IPersistentMap)\"))\n          gen (new GeneratorAdapter (. Opcodes ACC_PUBLIC) m nil nil cv)]\n      (. gen (visitCode))\n      (. gen (loadThis))\n      (. gen (dup))\n      (. gen (getField ctype fmap imap-type))\n      (.checkCast gen (totype clojure.lang.IPersistentCollection))\n      (. gen (loadArgs))\n      (. gen (invokeInterface (totype clojure.lang.IPersistentCollection)\n                              (. Method (getMethod \"clojure.lang.IPersistentCollection cons(Object)\"))))\n      (. gen (checkCast imap-type))\n      (. gen (putField ctype fmap imap-type))\n      \n      (. gen (returnValue))\n      (. gen (endMethod)))\n    (let [m (. Method (getMethod \"clojure.lang.IPersistentMap __getClojureFnMappings()\"))\n          gen (new GeneratorAdapter (. Opcodes ACC_PUBLIC) m nil nil cv)]\n      (. gen (visitCode))\n      (. gen (loadThis))\n      (. gen (getField ctype fmap imap-type))\n      (. gen (returnValue))\n      (. gen (endMethod)))\n    \n                                        ;calc set of supers' non-private instance methods\n    (let [[mm considered]\n            (loop [mm {} considered #{} c super]\n              (if c\n                (let [[mm considered]\n                      (loop [mm mm \n                             considered considered \n                             meths (concat \n                                    (seq (. c (getDeclaredMethods)))\n                                    (seq (. c (getMethods))))]\n                        (if (seq meths)\n                          (let [^java.lang.reflect.Method meth (first meths)\n                                mods (. meth (getModifiers))\n                                mk (method-sig meth)]\n                            (if (or (considered mk)\n                                    (not (or (Modifier/isPublic mods) (Modifier/isProtected mods)))\n                                    ;(. Modifier (isPrivate mods)) \n                                    (. Modifier (isStatic mods))\n                                    (. Modifier (isFinal mods))\n                                    (= \"finalize\" (.getName meth)))\n                              (recur mm (conj considered mk) (next meths))\n                              (recur (assoc mm mk meth) (conj considered mk) (next meths))))\n                          [mm considered]))]\n                  (recur mm considered (. c (getSuperclass))))\n                [mm considered]))\n          ifaces-meths (into1 {} \n                         (for [^Class iface interfaces meth (. iface (getMethods))\n                               :let [msig (method-sig meth)] :when (not (considered msig))]\n                           {msig meth}))\n          ;; Treat abstract methods as interface methods\n          [mm ifaces-meths] (let [abstract? (fn [[_ ^Method meth]]\n                                              (Modifier/isAbstract (. meth (getModifiers))))\n                                  mm-no-abstract (remove abstract? mm)\n                                  abstract-meths (filter abstract? mm)]\n                              [mm-no-abstract (concat ifaces-meths abstract-meths)])\n          mgroups (group-by-sig (concat mm ifaces-meths))\n          rtypes (map #(most-specific (keys %)) mgroups)\n          mb (map #(vector (%1 %2) (vals (dissoc %1 %2))) mgroups rtypes)\n          bridge? (reduce1 into1 #{} (map second mb))\n          ifaces-meths (remove bridge? (vals ifaces-meths))\n          mm (remove bridge? (vals mm))]\n                                        ;add methods matching supers', if no mapping -> call super\n      (doseq [[^java.lang.reflect.Method dest bridges] mb\n              ^java.lang.reflect.Method meth bridges]\n          (gen-bridge meth dest))\n      (doseq [^java.lang.reflect.Method meth mm]\n          (gen-method meth \n                      (fn [^GeneratorAdapter gen ^Method m]\n                          (. gen (loadThis))\n                                        ;push args\n                        (. gen (loadArgs))\n                                        ;call super\n                        (. gen (visitMethodInsn (. Opcodes INVOKESPECIAL) \n                                                (. super-type (getInternalName))\n                                                (. m (getName))\n                                                (. m (getDescriptor)))))))\n      \n                                        ;add methods matching interfaces', if no mapping -> throw\n      (doseq [^java.lang.reflect.Method meth ifaces-meths]\n                (gen-method meth \n                            (fn [^GeneratorAdapter gen ^Method m]\n                                (. gen (throwException ex-type (. m (getName))))))))\n    \n                                        ;finish class def\n    (. cv (visitEnd))\n    [cname (. cv toByteArray)]))\n\n(defn- get-super-and-interfaces [bases]\n  (if (. ^Class (first bases) (isInterface))\n    [Object bases]\n    [(first bases) (next bases)]))\n\n(defn get-proxy-class \n  \"Takes an optional single class followed by zero or more\n  interfaces. If not supplied class defaults to Object.  Creates an\n  returns an instance of a proxy class derived from the supplied\n  classes. The resulting value is cached and used for any subsequent\n  requests for the same class set. Returns a Class object.\"\n  {:added \"1.0\"}\n  [& bases]\n    (let [[super interfaces] (get-super-and-interfaces bases)\n          pname (proxy-name super interfaces)]\n      (or (RT/loadClassForName pname)\n          (let [[cname bytecode] (generate-proxy super interfaces)]\n            (. ^DynamicClassLoader (deref clojure.lang.Compiler/LOADER) (defineClass pname bytecode [super interfaces]))))))\n\n(defn construct-proxy\n  \"Takes a proxy class and any arguments for its superclass ctor and\n  creates and returns an instance of the proxy.\"\n  {:added \"1.0\"}\n  [c & ctor-args]\n    (. Reflector (invokeConstructor c (to-array ctor-args))))\n\n(defn init-proxy\n  \"Takes a proxy instance and a map of strings (which must\n  correspond to methods of the proxy superclass/superinterfaces) to\n  fns (which must take arguments matching the corresponding method,\n  plus an additional (explicit) first arg corresponding to this, and\n  sets the proxy's fn map.  Returns the proxy.\"\n  {:added \"1.0\"}\n  [^IProxy proxy mappings]\n    (. proxy (__initClojureFnMappings mappings))\n    proxy)\n\n(defn update-proxy\n  \"Takes a proxy instance and a map of strings (which must\n  correspond to methods of the proxy superclass/superinterfaces) to\n  fns (which must take arguments matching the corresponding method,\n  plus an additional (explicit) first arg corresponding to this, and\n  updates (via assoc) the proxy's fn map. nil can be passed instead of\n  a fn, in which case the corresponding method will revert to the\n  default behavior. Note that this function can be used to update the\n  behavior of an existing instance without changing its identity.\n  Returns the proxy.\"\n  {:added \"1.0\"}\n  [^IProxy proxy mappings]\n    (. proxy (__updateClojureFnMappings mappings))\n    proxy)\n\n(defn proxy-mappings\n  \"Takes a proxy instance and returns the proxy's fn map.\"\n  {:added \"1.0\"}\n  [^IProxy proxy]\n    (. proxy (__getClojureFnMappings)))\n\n(defmacro proxy\n  \"class-and-interfaces - a vector of class names\n\n  args - a (possibly empty) vector of arguments to the superclass\n  constructor.\n\n  f => (name [params*] body) or\n  (name ([params*] body) ([params+] body) ...)\n\n  Expands to code which creates a instance of a proxy class that\n  implements the named class/interface(s) by calling the supplied\n  fns. A single class, if provided, must be first. If not provided it\n  defaults to Object.\n\n  The interfaces names must be valid interface types. If a method fn\n  is not provided for a class method, the superclass methd will be\n  called. If a method fn is not provided for an interface method, an\n  UnsupportedOperationException will be thrown should it be\n  called. Method fns are closures and can capture the environment in\n  which proxy is called. Each method fn takes an additional implicit\n  first arg, which is bound to 'this. Note that while method fns can\n  be provided to override protected methods, they have no other access\n  to protected members, nor to super, as these capabilities cannot be\n  proxied.\"\n  {:added \"1.0\"}\n  [class-and-interfaces args & fs]\n   (let [bases (map #(or (resolve %) (throw (Exception. (str \"Can't resolve: \" %)))) \n                    class-and-interfaces)\n         [super interfaces] (get-super-and-interfaces bases)\n         compile-effect (when *compile-files*\n                          (let [[cname bytecode] (generate-proxy super interfaces)]\n                            (clojure.lang.Compiler/writeClassFile cname bytecode)))\n         pc-effect (apply get-proxy-class bases)\n         pname (proxy-name super interfaces)]\n     ;remember the class to prevent it from disappearing before use\n     (intern *ns* (symbol pname) pc-effect)\n     `(let [;pc# (get-proxy-class ~@class-and-interfaces)\n            p# (new ~(symbol pname) ~@args)] ;(construct-proxy pc# ~@args)]   \n        (init-proxy p#\n         ~(loop [fmap {} fs fs]\n            (if fs\n              (let [[sym & meths] (first fs)\n                    meths (if (vector? (first meths))\n                            (list meths)\n                            meths)\n                    meths (map (fn [[params & body]]\n                                   (cons (apply vector 'this params) body))\n                               meths)]\n                (if-not (contains? fmap (name sym))\t\t  \n                (recur (assoc fmap (name sym) (cons `fn meths)) (next fs))\n\t\t           (throw (IllegalArgumentException.\n\t\t\t              (str \"Method '\" (name sym) \"' redefined\")))))\n              fmap)))\n        p#)))\n\n(defn proxy-call-with-super [call this meth]\n (let [m (proxy-mappings this)]\n    (update-proxy this (assoc m meth nil))\n    (try\n      (call)\n      (finally (update-proxy this m)))))\n\n(defmacro proxy-super \n  \"Use to call a superclass method in the body of a proxy method. \n  Note, expansion captures 'this\"\n  {:added \"1.0\"}\n  [meth & args]\n `(proxy-call-with-super (fn [] (. ~'this ~meth ~@args))  ~'this ~(name meth)))\n\n(defn bean\n  \"Takes a Java object and returns a read-only implementation of the\n  map abstraction based upon its JavaBean properties.\"\n  {:added \"1.0\"}\n  [^Object x]\n  (let [c (. x (getClass))\n\tpmap (reduce1 (fn [m ^java.beans.PropertyDescriptor pd]\n\t\t\t (let [name (. pd (getName))\n\t\t\t       method (. pd (getReadMethod))]\n\t\t\t   (if (and method (zero? (alength (. method (getParameterTypes)))))\n\t\t\t     (assoc m (keyword name) (fn [] (clojure.lang.Reflector/prepRet (.getPropertyType pd) (. method (invoke x nil)))))\n\t\t\t     m)))\n\t\t     {}\n\t\t     (seq (.. java.beans.Introspector\n\t\t\t      (getBeanInfo c)\n\t\t\t      (getPropertyDescriptors))))\n\tv (fn [k] ((pmap k)))\n        snapshot (fn []\n                   (reduce1 (fn [m e]\n                             (assoc m (key e) ((val e))))\n                           {} (seq pmap)))]\n    (proxy [clojure.lang.APersistentMap]\n           []\n      (iterator [] (.iterator ^Iterable pmap))\n      (containsKey [k] (contains? pmap k))\n      (entryAt [k] (when (contains? pmap k) (clojure.lang.MapEntry/create k (v k))))\n      (valAt ([k] (when (contains? pmap k) (v k)))\n\t     ([k default] (if (contains? pmap k) (v k) default)))\n      (cons [m] (conj (snapshot) m))\n      (count [] (count pmap))\n      (assoc [k v] (assoc (snapshot) k v))\n      (without [k] (dissoc (snapshot) k))\n      (seq [] ((fn thisfn [plseq]\n\t\t  (lazy-seq\n                   (when-let [pseq (seq plseq)]\n                     (cons (clojure.lang.MapEntry/create (first pseq) (v (first pseq)))\n                           (thisfn (rest pseq)))))) (keys pmap))))))\n\n\n\n", ";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n; Author: Frantisek Sodomka\n\n\n(ns clojure.test-clojure.java-interop\n  (:use clojure.test))\n\n; http://clojure.org/java_interop\n; http://clojure.org/compilation\n\n\n(deftest test-dot\n  ; (.instanceMember instance args*)\n  (are [x] (= x \"FRED\")\n      (.toUpperCase \"fred\") \n      (. \"fred\" toUpperCase)\n      (. \"fred\" (toUpperCase)) )\n\n  (are [x] (= x true)\n      (.startsWith \"abcde\" \"ab\")\n      (. \"abcde\" startsWith \"ab\")\n      (. \"abcde\" (startsWith \"ab\")) )\n\n  ; (.instanceMember Classname args*)\n  (are [x] (= x \"java.lang.String\")\n      (.getName String)\n      (. (identity String) getName)\n      (. (identity String) (getName)) )\n\n  ; (Classname/staticMethod args*)\n  (are [x] (= x 7)\n      (Math/abs -7)\n      (. Math abs -7)\n      (. Math (abs -7)) )\n\n  ; (. target -prop)\n  (let [p (java.awt.Point. 1 2)]\n    (are [x y] (= x y)\n       1 (.-x p)\n       2 (.-y p)\n       1 (. p -x)\n       2 (. p -y)\n       1 (. (java.awt.Point. 1 2) -x)\n       2 (. (java.awt.Point. 1 2) -y)))\n  \n  ; Classname/staticField\n  (are [x] (= x 2147483647)\n      Integer/MAX_VALUE\n      (. Integer MAX_VALUE) ))\n\n(definterface I (a []))\n(deftype T [a] I (a [_] \"method\"))\n\n(deftest test-reflective-field-name-ambiguous\n  (let [t (->T \"field\")]\n    (is (= \"method\" (. ^T t a)))\n    (is (= \"field\" (. ^T t -a)))\n    (is (= \"method\" (. t a)))\n    (is (= \"field\" (. t -a)))\n    (is (thrown? IllegalArgumentException (. t -BOGUS)))))\n\n(deftest test-double-dot\n  (is (= (.. System (getProperties) (get \"os.name\"))\n         (. (. System (getProperties)) (get \"os.name\")))))\n\n\n(deftest test-doto\n  (let [m (doto (new java.util.HashMap)\n            (.put \"a\" 1)\n            (.put \"b\" 2))]\n    (are [x y] (= x y)\n        (class m) java.util.HashMap\n        m {\"a\" 1 \"b\" 2} )))\n\n\n(deftest test-new\n  ; Integer\n  (are [expr cls value] (and (= (class expr) cls)\n                            (= expr value))\n      (new java.lang.Integer 42) java.lang.Integer 42\n      (java.lang.Integer. 123) java.lang.Integer 123 )\n\n  ; Date\n  (are [x] (= (class x) java.util.Date)\n      (new java.util.Date)\n      (java.util.Date.) ))\n\n\n(deftest test-instance?\n  ; evaluation\n  (are [x y] (= x y)\n      (instance? java.lang.Integer (+ 1 2)) false\n      (instance? java.lang.Long (+ 1 2)) true )\n\n  ; different types\n  (are [type literal] (instance? literal type)\n      1   java.lang.Long\n      1.0 java.lang.Double\n      1M  java.math.BigDecimal\n      \\a  java.lang.Character\n      \"a\" java.lang.String )\n\n  ; it is a Long, nothing else\n  (are [x y] (= (instance? x 42) y)\n      java.lang.Integer false\n      java.lang.Long true\n      java.lang.Character false\n      java.lang.String false )\n\n  ; test compiler macro\n  (is (let [Long String] (instance? Long \"abc\")))\n  (is (thrown? clojure.lang.ArityException (instance? Long))))\n\n; set!\n\n(defprotocol p (f [_]))\n(deftype t [^:unsynchronized-mutable x] p (f [_] (set! (.x _) 1)))\n\n(deftest test-set!\n  (is (= 1 (f (t. 1)))))\n\n; memfn\n\n\n(deftest test-bean\n  (let [b (bean java.awt.Color/black)]\n    (are [x y] (= x y)\n        (map? b) true\n\n        (:red b) 0\n        (:green b) 0\n        (:blue b) 0\n        (:RGB b) -16777216\n\n        (:alpha b) 255\n        (:transparency b) 1\n\n        (:missing b) nil\n        (:missing b :default) :default\n        (get b :missing) nil\n        (get b :missing :default) :default\n\n        (:class b) java.awt.Color )))\n\n(deftest test-iterable-bean\n  (is (.iterator ^Iterable (bean (java.util.Date.))))\n  (is (hash (bean (java.util.Date.)))))\n\n; proxy, proxy-super\n\n(deftest test-proxy-chain\n  (testing \"That the proxy functions can chain\"\n    (are [x y] (= x y)\n        (-> (get-proxy-class Object) \n            construct-proxy\n            (init-proxy {}) \n            (update-proxy {\"toString\" (fn [_] \"chain chain chain\")}) \n            str)\n        \"chain chain chain\"\n\n        (-> (proxy [Object] [] (toString [] \"superfuzz bigmuff\")) \n            (update-proxy {\"toString\" (fn [_] \"chain chain chain\")}) \n            str)\n        \"chain chain chain\")))\n\n\n(deftest test-bases\n  (are [x y] (= x y)\n      (bases java.lang.Math)\n        (list java.lang.Object)\n      (bases java.util.Collection)\n        (list java.lang.Iterable)\n      (bases java.lang.Object)\n        nil\n      (bases java.lang.Comparable)\n        nil\n      (bases java.lang.Integer)\n        (list java.lang.Number java.lang.Comparable) ))\n\n(deftest test-supers\n  (are [x y] (= x y)\n      (supers java.lang.Math)\n        #{java.lang.Object}\n      (supers java.lang.Integer)\n        #{java.lang.Number java.lang.Object\n          java.lang.Comparable java.io.Serializable} ))\n\n(deftest test-proxy-super\n  (let [d (proxy [java.util.BitSet] []\n            (flip [bitIndex]\n              (try\n                (proxy-super flip bitIndex)\n                (catch IndexOutOfBoundsException e\n                  (throw (IllegalArgumentException. \"replaced\"))))))]\n    ;; normal call\n    (is (nil? (.flip d 0)))\n    ;; exception should use proxied form and return IllegalArg\n    (is (thrown? IllegalArgumentException (.flip d -1)))\n    ;; same behavior on second call\n    (is (thrown? IllegalArgumentException (.flip d -1)))))\n\n;; http://dev.clojure.org/jira/browse/CLJ-1657\n(deftest test-proxy-abstract-super\n  (let [p (proxy [java.io.Writer] [])]\n    (is (thrown? UnsupportedOperationException (.close p)))))\n\n; Arrays: [alength] aget aset [make-array to-array into-array to-array-2d aclone]\n;   [float-array, int-array, etc]\n;   amap, areduce\n\n(defmacro deftest-type-array [type-array type]\n  `(deftest ~(symbol (str \"test-\" type-array))\n      ; correct type\n      #_(is (= (class (first (~type-array [1 2]))) (class (~type 1))))\n\n      ; given size (and empty)\n      (are [x] (and (= (alength (~type-array x)) x)\n                    (= (vec (~type-array x)) (repeat x 0)))\n          0 1 5 )\n\n      ; copy of a sequence\n      (are [x] (and (= (alength (~type-array x)) (count x))\n                    (= (vec (~type-array x)) x))\n          []\n          [1]\n          [1 -2 3 0 5] )\n\n      ; given size and init-value\n      (are [x] (and (= (alength (~type-array x 42)) x)\n                    (= (vec (~type-array x 42)) (repeat x 42)))\n          0 1 5 )\n\n      ; given size and init-seq\n      (are [x y z] (and (= (alength (~type-array x y)) x)\n                        (= (vec (~type-array x y)) z))\n          0 [] []\n          0 [1] []\n          0 [1 2 3] []\n          1 [] [0]\n          1 [1] [1]\n          1 [1 2 3] [1]\n          5 [] [0 0 0 0 0]\n          5 [1] [1 0 0 0 0]\n          5 [1 2 3] [1 2 3 0 0]\n          5 [1 2 3 4 5] [1 2 3 4 5]\n          5 [1 2 3 4 5 6 7] [1 2 3 4 5] )))\n\n(deftest-type-array int-array int)\n(deftest-type-array long-array long)\n;todo, fix, test broken for float/double, should compare to 1.0 2.0 etc\n#_(deftest-type-array float-array float)\n#_(deftest-type-array double-array double)\n\n; separate test for exceptions (doesn't work with above macro...)\n(deftest test-type-array-exceptions\n  (are [x] (thrown? NegativeArraySizeException x)\n       (int-array -1)\n       (long-array -1)\n       (float-array -1)\n       (double-array -1) ))\n\n\n(deftest test-make-array\n  ; negative size\n  (is (thrown? NegativeArraySizeException (make-array Integer -1)))\n\n  ; one-dimensional\n  (are [x] (= (alength (make-array Integer x)) x)\n      0 1 5 )\n\n  (let [a (make-array Long 5)]\n    (aset a 3 42)\n    (are [x y] (= x y)\n        (aget a 3) 42\n        (class (aget a 3)) Long ))\n      \n  ; multi-dimensional\n  (let [a (make-array Long 3 2 4)]\n    (aset a 0 1 2 987)\n    (are [x y] (= x y)\n        (alength a) 3\n        (alength (first a)) 2\n        (alength (first (first a))) 4\n\n        (aget a 0 1 2) 987\n        (class (aget a 0 1 2)) Long )))\n\n\n(deftest test-to-array\n  (let [v [1 \"abc\" :kw \\c []]\n        a (to-array v)]\n    (are [x y] (= x y)\n        ; length\n        (alength a) (count v)\n\n        ; content\n        (vec a) v\n        (class (aget a 0)) (class (nth v 0))\n        (class (aget a 1)) (class (nth v 1))\n        (class (aget a 2)) (class (nth v 2))\n        (class (aget a 3)) (class (nth v 3))\n        (class (aget a 4)) (class (nth v 4)) ))\n\n  ; different kinds of collections\n  (are [x] (and (= (alength (to-array x)) (count x))\n                (= (vec (to-array x)) (vec x)))\n      ()\n      '(1 2)\n      []\n      [1 2]\n      (sorted-set)\n      (sorted-set 1 2)\n      \n      (int-array 0)\n      (int-array [1 2 3])\n\n      (to-array [])\n      (to-array [1 2 3]) ))\n\n(defn queue [& contents]\n  (apply conj (clojure.lang.PersistentQueue/EMPTY) contents))\n\n(defn array-typed-equals [expected actual]\n  (and (= (class expected) (class actual))\n       (java.util.Arrays/equals expected actual)))\n\n(defmacro test-to-passed-array-for [collection-type]\n  `(deftest ~(symbol (str \"test-to-passed-array-for-\" collection-type))\n     (let [string-array# (make-array String 5)\n           shorter# (~collection-type \"1\" \"2\" \"3\")\n           same-length# (~collection-type \"1\" \"2\" \"3\" \"4\" \"5\")\n           longer# (~collection-type \"1\" \"2\" \"3\" \"4\" \"5\" \"6\")]\n       (are [expected actual] (array-typed-equals expected actual)\n            (into-array String [\"1\" \"2\" \"3\" nil nil]) (.toArray shorter# string-array#)\n            (into-array String [\"1\" \"2\" \"3\" \"4\" \"5\"]) (.toArray same-length# string-array#)\n            (into-array String [\"1\" \"2\" \"3\" \"4\" \"5\" \"6\"]) (.toArray longer# string-array#)))))\n\n\n(test-to-passed-array-for vector)\n(test-to-passed-array-for list)\n;;(test-to-passed-array-for hash-set)\n(test-to-passed-array-for queue)\n\n(deftest test-into-array\n  ; compatible types only\n  (is (thrown? IllegalArgumentException (into-array [1 \"abc\" :kw])))\n  (is (thrown? IllegalArgumentException (into-array [1.2 4])))\n  (is (thrown? IllegalArgumentException (into-array [(byte 2) (short 3)])))\n  (is (thrown? IllegalArgumentException (into-array Byte/TYPE [100000000000000])))\n  \n  ; simple case\n  (let [v [1 2 3 4 5]\n        a (into-array v)]\n    (are [x y] (= x y)\n        (alength a) (count v)\n        (vec a) v\n        (class (first a)) (class (first v)) ))\n\n  (is (= \\a (aget (into-array Character/TYPE [\\a \\b \\c]) 0)))\n\n  (is (= [nil 1 2] (seq (into-array [nil 1 2]))))\n  \n  (let [types [Integer/TYPE\n               Byte/TYPE\n               Float/TYPE\n               Short/TYPE\n               Double/TYPE\n               Long/TYPE]\n        values [(byte 2) (short 3) (int 4) 5]]\n    (for [t types]\n      (let [a (into-array t values)]\n        (is (== (aget a 0) 2))\n        (is (== (aget a 1) 3))\n        (is (== (aget a 2) 4))\n        (is (== (aget a 3) 5)))))\n  \n  ; different kinds of collections\n  (are [x] (and (= (alength (into-array x)) (count x))\n                (= (vec (into-array x)) (vec x))\n                (= (alength (into-array Long/TYPE x)) (count x))\n                (= (vec (into-array Long/TYPE x)) (vec x)))\n      ()\n      '(1 2)\n      []\n      [1 2]\n      (sorted-set)\n      (sorted-set 1 2)\n\n      (int-array 0)\n      (int-array [1 2 3])\n\n      (to-array [])\n      (to-array [1 2 3]) ))\n\n\n(deftest test-to-array-2d\n  ; needs to be a collection of collection(s)\n  (is (thrown? Exception (to-array-2d [1 2 3])))\n\n  ; ragged array\n  (let [v [[1] [2 3] [4 5 6]]\n        a (to-array-2d v)]\n    (are [x y] (= x y)\n        (alength a) (count v)\n        (alength (aget a 0)) (count (nth v 0))\n        (alength (aget a 1)) (count (nth v 1))\n        (alength (aget a 2)) (count (nth v 2))\n\n        (vec (aget a 0)) (nth v 0)\n        (vec (aget a 1)) (nth v 1)\n        (vec (aget a 2)) (nth v 2) ))\n\n  ; empty array\n  (let [a (to-array-2d [])]\n    (are [x y] (= x y)\n        (alength a) 0\n        (vec a) [] )))\n\n\n(deftest test-alength\n  (are [x] (= (alength x) 0)\n      (int-array 0)\n      (long-array 0)\n      (float-array 0)\n      (double-array 0)\n      (boolean-array 0)\n      (byte-array 0)\n      (char-array 0)\n      (short-array 0)\n      (make-array Integer/TYPE 0)\n      (to-array [])\n      (into-array [])\n      (to-array-2d []) )\n\n  (are [x] (= (alength x) 1)\n      (int-array 1)\n      (long-array 1)\n      (float-array 1)\n      (double-array 1)\n      (boolean-array 1)\n      (byte-array 1)\n      (char-array 1)\n      (short-array 1)\n      (make-array Integer/TYPE 1)\n      (to-array [1])\n      (into-array [1])\n      (to-array-2d [[1]]) )\n\n  (are [x] (= (alength x) 3)\n      (int-array 3)\n      (long-array 3)\n      (float-array 3)\n      (double-array 3)\n      (boolean-array 3)\n      (byte-array 3)\n      (char-array 3)\n      (short-array 3)\n      (make-array Integer/TYPE 3)\n      (to-array [1 \"a\" :k])\n      (into-array [1 2 3])\n      (to-array-2d [[1] [2 3] [4 5 6]]) ))\n\n\n(deftest test-aclone\n  ; clone all arrays except 2D\n  (are [x] (and (= (alength (aclone x)) (alength x))\n                (= (vec (aclone x)) (vec x)))\n      (int-array 0)\n      (long-array 0)\n      (float-array 0)\n      (double-array 0)\n      (boolean-array 0)\n      (byte-array 0)\n      (char-array 0)\n      (short-array 0)\n      (make-array Integer/TYPE 0)\n      (to-array [])\n      (into-array [])\n\n      (int-array [1 2 3])\n      (long-array [1 2 3])\n      (float-array [1 2 3])\n      (double-array [1 2 3])\n      (boolean-array [true false])\n      (byte-array [(byte 1) (byte 2)])\n      (byte-array [1 2])\n      (byte-array 2 [1 2])\n      (char-array [\\a \\b \\c])\n      (short-array [(short 1) (short 2)])\n      (short-array [1 2])\n      (short-array 2 [1 2])\n      (make-array Integer/TYPE 3)\n      (to-array [1 \"a\" :k])\n      (into-array [1 2 3]) )\n\n  ; clone 2D\n  (are [x] (and (= (alength (aclone x)) (alength x))\n                (= (map alength (aclone x)) (map alength x))\n                (= (map vec (aclone x)) (map vec x)))\n      (to-array-2d [])\n      (to-array-2d [[1] [2 3] [4 5 6]]) ))\n\n\n; Type Hints, *warn-on-reflection*\n;   #^ints, #^floats, #^longs, #^doubles\n\n; Coercions: [int, long, float, double, char, boolean, short, byte]\n;   num\n;   ints/longs/floats/doubles\n\n(deftest test-boolean\n  (are [x y] (and (instance? java.lang.Boolean (boolean x))\n                  (= (boolean x) y))\n      nil false\n      false false\n      true true\n\n      0 true\n      1 true\n      () true\n      [1] true\n\n      \"\" true\n      \\space true\n      :kw true ))\n\n\n(deftest test-char\n  ; int -> char\n  (is (instance? java.lang.Character (char 65)))\n\n  ; char -> char\n  (is (instance? java.lang.Character (char \\a)))\n  (is (= (char \\a) \\a)))\n\n;; Note: More coercions in numbers.clj\n"], "fixing_code": [";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(in-ns 'clojure.core)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;; proxy ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(import\n '(clojure.asm ClassWriter ClassVisitor Opcodes Type) \n '(java.lang.reflect Modifier Constructor)\n '(java.io Serializable NotSerializableException)\n '(clojure.asm.commons Method GeneratorAdapter)\n '(clojure.lang IProxy Reflector DynamicClassLoader IPersistentMap PersistentHashMap RT))\n\n(defn method-sig [^java.lang.reflect.Method meth]\n  [(. meth (getName)) (seq (. meth (getParameterTypes))) (. meth getReturnType)])\n\n(defn- most-specific [rtypes]\n  (or (some (fn [t] (when (every? #(isa? t %) rtypes) t)) rtypes)\n    (throw (Exception. \"Incompatible return types\"))))\n\n(defn- group-by-sig [coll]\n \"takes a collection of [msig meth] and returns a seq of maps from return-types to meths.\"\n  (vals (reduce1 (fn [m [msig meth]]\n                  (let [rtype (peek msig)\n                        argsig (pop msig)]\n                    (assoc m argsig (assoc (m argsig {}) rtype meth))))\n          {} coll)))\n\n(defn proxy-name\n {:tag String} \n [^Class super interfaces]\n  (let [inames (into1 (sorted-set) (map #(.getName ^Class %) interfaces))]\n    (apply str (.replace (str *ns*) \\- \\_) \".proxy\"\n      (interleave (repeat \"$\")\n        (concat\n          [(.getName super)]\n          (map #(subs % (inc (.lastIndexOf ^String % \".\"))) inames)\n          [(Integer/toHexString (hash inames))])))))\n\n(defn- generate-proxy [^Class super interfaces]\n  (let [cv (new ClassWriter (. ClassWriter COMPUTE_MAXS))\n        pname (proxy-name super interfaces)\n        cname (.replace pname \\. \\/) ;(str \"clojure/lang/\" (gensym \"Proxy__\"))\n        ctype (. Type (getObjectType cname))\n        iname (fn [^Class c] (.. Type (getType c) (getInternalName)))\n        fmap \"__clojureFnMap\"\n        totype (fn [^Class c] (. Type (getType c)))\n        to-types (fn [cs] (if (pos? (count cs))\n                            (into-array (map totype cs))\n                            (make-array Type 0)))\n        super-type ^Type (totype super)\n        imap-type ^Type (totype IPersistentMap)\n        ifn-type (totype clojure.lang.IFn)\n        obj-type (totype Object)\n        sym-type (totype clojure.lang.Symbol)\n        rt-type  (totype clojure.lang.RT)\n        ex-type  (totype java.lang.UnsupportedOperationException)\n        gen-bridge \n        (fn [^java.lang.reflect.Method meth ^java.lang.reflect.Method dest]\n            (let [pclasses (. meth (getParameterTypes))\n                  ptypes (to-types pclasses)\n                  rtype ^Type (totype (. meth (getReturnType)))\n                  m (new Method (. meth (getName)) rtype ptypes)\n                  dtype (totype (.getDeclaringClass dest))\n                  dm (new Method (. dest (getName)) (totype (. dest (getReturnType))) (to-types (. dest (getParameterTypes))))\n                  gen (new GeneratorAdapter (bit-or (. Opcodes ACC_PUBLIC) (. Opcodes ACC_BRIDGE)) m nil nil cv)]\n              (. gen (visitCode))\n              (. gen (loadThis))\n              (dotimes [i (count ptypes)]\n                  (. gen (loadArg i)))\n              (if (-> dest .getDeclaringClass .isInterface)\n                (. gen (invokeInterface dtype dm))\n                (. gen (invokeVirtual dtype dm)))\n              (. gen (returnValue))\n              (. gen (endMethod))))\n        gen-method\n        (fn [^java.lang.reflect.Method meth else-gen]\n            (let [pclasses (. meth (getParameterTypes))\n                  ptypes (to-types pclasses)\n                  rtype ^Type (totype (. meth (getReturnType)))\n                  m (new Method (. meth (getName)) rtype ptypes)\n                  gen (new GeneratorAdapter (. Opcodes ACC_PUBLIC) m nil nil cv)\n                  else-label (. gen (newLabel))\n                  end-label (. gen (newLabel))\n                  decl-type (. Type (getType (. meth (getDeclaringClass))))]\n              (. gen (visitCode))\n              (if (> (count pclasses) 18)\n                (else-gen gen m)\n                (do\n                  (. gen (loadThis))\n                  (. gen (getField ctype fmap imap-type))\n                  \n                  (. gen (push (. meth (getName))))\n                                        ;lookup fn in map\n                  (. gen (invokeStatic rt-type (. Method (getMethod \"Object get(Object, Object)\"))))\n                  (. gen (dup))\n                  (. gen (ifNull else-label))\n                                        ;if found\n                  (.checkCast gen ifn-type)\n                  (. gen (loadThis))\n                                        ;box args\n                  (dotimes [i (count ptypes)]\n                      (. gen (loadArg i))\n                    (. clojure.lang.Compiler$HostExpr (emitBoxReturn nil gen (nth pclasses i))))\n                                        ;call fn\n                  (. gen (invokeInterface ifn-type (new Method \"invoke\" obj-type \n                                                        (into-array (cons obj-type \n                                                                          (replicate (count ptypes) obj-type))))))\n                                        ;unbox return\n                  (. gen (unbox rtype))\n                  (when (= (. rtype (getSort)) (. Type VOID))\n                    (. gen (pop)))\n                  (. gen (goTo end-label))\n                  \n                                        ;else call supplied alternative generator\n                  (. gen (mark else-label))\n                  (. gen (pop))\n                  \n                  (else-gen gen m)\n                  \n                  (. gen (mark end-label))))\n              (. gen (returnValue))\n              (. gen (endMethod))))]\n    \n                                        ;start class definition\n    (. cv (visit (. Opcodes V1_5) (+ (. Opcodes ACC_PUBLIC) (. Opcodes ACC_SUPER))\n                 cname nil (iname super) \n                 (into-array (map iname (cons IProxy interfaces)))))\n                                        ;add field for fn mappings\n    (. cv (visitField (+ (. Opcodes ACC_PRIVATE) (. Opcodes ACC_VOLATILE))\n                      fmap (. imap-type (getDescriptor)) nil nil))          \n                                        ;add ctors matching/calling super's\n    (doseq [^Constructor ctor (. super (getDeclaredConstructors))]\n        (when-not (. Modifier (isPrivate (. ctor (getModifiers))))\n          (let [ptypes (to-types (. ctor (getParameterTypes)))\n                m (new Method \"<init>\" (. Type VOID_TYPE) ptypes)\n                gen (new GeneratorAdapter (. Opcodes ACC_PUBLIC) m nil nil cv)]\n            (. gen (visitCode))\n                                        ;call super ctor\n            (. gen (loadThis))\n            (. gen (dup))\n            (. gen (loadArgs))\n            (. gen (invokeConstructor super-type m))\n            \n            (. gen (returnValue))\n            (. gen (endMethod)))))\n                                        ;disable serialization\n    (when (some #(isa? % Serializable) (cons super interfaces))\n      (let [m (. Method (getMethod \"void writeObject(java.io.ObjectOutputStream)\"))\n            gen (new GeneratorAdapter (. Opcodes ACC_PRIVATE) m nil nil cv)]\n        (. gen (visitCode))\n        (. gen (loadThis))\n        (. gen (loadArgs))\n        (. gen (throwException (totype NotSerializableException) pname))\n        (. gen (endMethod)))\n      (let [m (. Method (getMethod \"void readObject(java.io.ObjectInputStream)\"))\n            gen (new GeneratorAdapter (. Opcodes ACC_PRIVATE) m nil nil cv)]\n        (. gen (visitCode))\n        (. gen (loadThis))\n        (. gen (loadArgs))\n        (. gen (throwException (totype NotSerializableException) pname))\n        (. gen (endMethod))))\n                                        ;add IProxy methods\n    (let [m (. Method (getMethod \"void __initClojureFnMappings(clojure.lang.IPersistentMap)\"))\n          gen (new GeneratorAdapter (. Opcodes ACC_PUBLIC) m nil nil cv)]\n      (. gen (visitCode))\n      (. gen (loadThis))\n      (. gen (loadArgs))\n      (. gen (putField ctype fmap imap-type))\n      \n      (. gen (returnValue))\n      (. gen (endMethod)))\n    (let [m (. Method (getMethod \"void __updateClojureFnMappings(clojure.lang.IPersistentMap)\"))\n          gen (new GeneratorAdapter (. Opcodes ACC_PUBLIC) m nil nil cv)]\n      (. gen (visitCode))\n      (. gen (loadThis))\n      (. gen (dup))\n      (. gen (getField ctype fmap imap-type))\n      (.checkCast gen (totype clojure.lang.IPersistentCollection))\n      (. gen (loadArgs))\n      (. gen (invokeInterface (totype clojure.lang.IPersistentCollection)\n                              (. Method (getMethod \"clojure.lang.IPersistentCollection cons(Object)\"))))\n      (. gen (checkCast imap-type))\n      (. gen (putField ctype fmap imap-type))\n      \n      (. gen (returnValue))\n      (. gen (endMethod)))\n    (let [m (. Method (getMethod \"clojure.lang.IPersistentMap __getClojureFnMappings()\"))\n          gen (new GeneratorAdapter (. Opcodes ACC_PUBLIC) m nil nil cv)]\n      (. gen (visitCode))\n      (. gen (loadThis))\n      (. gen (getField ctype fmap imap-type))\n      (. gen (returnValue))\n      (. gen (endMethod)))\n    \n                                        ;calc set of supers' non-private instance methods\n    (let [[mm considered]\n            (loop [mm {} considered #{} c super]\n              (if c\n                (let [[mm considered]\n                      (loop [mm mm \n                             considered considered \n                             meths (concat \n                                    (seq (. c (getDeclaredMethods)))\n                                    (seq (. c (getMethods))))]\n                        (if (seq meths)\n                          (let [^java.lang.reflect.Method meth (first meths)\n                                mods (. meth (getModifiers))\n                                mk (method-sig meth)]\n                            (if (or (considered mk)\n                                    (not (or (Modifier/isPublic mods) (Modifier/isProtected mods)))\n                                    ;(. Modifier (isPrivate mods)) \n                                    (. Modifier (isStatic mods))\n                                    (. Modifier (isFinal mods))\n                                    (= \"finalize\" (.getName meth)))\n                              (recur mm (conj considered mk) (next meths))\n                              (recur (assoc mm mk meth) (conj considered mk) (next meths))))\n                          [mm considered]))]\n                  (recur mm considered (. c (getSuperclass))))\n                [mm considered]))\n          ifaces-meths (into1 {} \n                         (for [^Class iface interfaces meth (. iface (getMethods))\n                               :let [msig (method-sig meth)] :when (not (considered msig))]\n                           {msig meth}))\n          ;; Treat abstract methods as interface methods\n          [mm ifaces-meths] (let [abstract? (fn [[_ ^Method meth]]\n                                              (Modifier/isAbstract (. meth (getModifiers))))\n                                  mm-no-abstract (remove abstract? mm)\n                                  abstract-meths (filter abstract? mm)]\n                              [mm-no-abstract (concat ifaces-meths abstract-meths)])\n          mgroups (group-by-sig (concat mm ifaces-meths))\n          rtypes (map #(most-specific (keys %)) mgroups)\n          mb (map #(vector (%1 %2) (vals (dissoc %1 %2))) mgroups rtypes)\n          bridge? (reduce1 into1 #{} (map second mb))\n          ifaces-meths (remove bridge? (vals ifaces-meths))\n          mm (remove bridge? (vals mm))]\n                                        ;add methods matching supers', if no mapping -> call super\n      (doseq [[^java.lang.reflect.Method dest bridges] mb\n              ^java.lang.reflect.Method meth bridges]\n          (gen-bridge meth dest))\n      (doseq [^java.lang.reflect.Method meth mm]\n          (gen-method meth \n                      (fn [^GeneratorAdapter gen ^Method m]\n                          (. gen (loadThis))\n                                        ;push args\n                        (. gen (loadArgs))\n                                        ;call super\n                        (. gen (visitMethodInsn (. Opcodes INVOKESPECIAL) \n                                                (. super-type (getInternalName))\n                                                (. m (getName))\n                                                (. m (getDescriptor)))))))\n      \n                                        ;add methods matching interfaces', if no mapping -> throw\n      (doseq [^java.lang.reflect.Method meth ifaces-meths]\n                (gen-method meth \n                            (fn [^GeneratorAdapter gen ^Method m]\n                                (. gen (throwException ex-type (. m (getName))))))))\n    \n                                        ;finish class def\n    (. cv (visitEnd))\n    [cname (. cv toByteArray)]))\n\n(defn- get-super-and-interfaces [bases]\n  (if (. ^Class (first bases) (isInterface))\n    [Object bases]\n    [(first bases) (next bases)]))\n\n(defn get-proxy-class \n  \"Takes an optional single class followed by zero or more\n  interfaces. If not supplied class defaults to Object.  Creates an\n  returns an instance of a proxy class derived from the supplied\n  classes. The resulting value is cached and used for any subsequent\n  requests for the same class set. Returns a Class object.\"\n  {:added \"1.0\"}\n  [& bases]\n    (let [[super interfaces] (get-super-and-interfaces bases)\n          pname (proxy-name super interfaces)]\n      (or (RT/loadClassForName pname)\n          (let [[cname bytecode] (generate-proxy super interfaces)]\n            (. ^DynamicClassLoader (deref clojure.lang.Compiler/LOADER) (defineClass pname bytecode [super interfaces]))))))\n\n(defn construct-proxy\n  \"Takes a proxy class and any arguments for its superclass ctor and\n  creates and returns an instance of the proxy.\"\n  {:added \"1.0\"}\n  [c & ctor-args]\n    (. Reflector (invokeConstructor c (to-array ctor-args))))\n\n(defn init-proxy\n  \"Takes a proxy instance and a map of strings (which must\n  correspond to methods of the proxy superclass/superinterfaces) to\n  fns (which must take arguments matching the corresponding method,\n  plus an additional (explicit) first arg corresponding to this, and\n  sets the proxy's fn map.  Returns the proxy.\"\n  {:added \"1.0\"}\n  [^IProxy proxy mappings]\n    (. proxy (__initClojureFnMappings mappings))\n    proxy)\n\n(defn update-proxy\n  \"Takes a proxy instance and a map of strings (which must\n  correspond to methods of the proxy superclass/superinterfaces) to\n  fns (which must take arguments matching the corresponding method,\n  plus an additional (explicit) first arg corresponding to this, and\n  updates (via assoc) the proxy's fn map. nil can be passed instead of\n  a fn, in which case the corresponding method will revert to the\n  default behavior. Note that this function can be used to update the\n  behavior of an existing instance without changing its identity.\n  Returns the proxy.\"\n  {:added \"1.0\"}\n  [^IProxy proxy mappings]\n    (. proxy (__updateClojureFnMappings mappings))\n    proxy)\n\n(defn proxy-mappings\n  \"Takes a proxy instance and returns the proxy's fn map.\"\n  {:added \"1.0\"}\n  [^IProxy proxy]\n    (. proxy (__getClojureFnMappings)))\n\n(defmacro proxy\n  \"class-and-interfaces - a vector of class names\n\n  args - a (possibly empty) vector of arguments to the superclass\n  constructor.\n\n  f => (name [params*] body) or\n  (name ([params*] body) ([params+] body) ...)\n\n  Expands to code which creates a instance of a proxy class that\n  implements the named class/interface(s) by calling the supplied\n  fns. A single class, if provided, must be first. If not provided it\n  defaults to Object.\n\n  The interfaces names must be valid interface types. If a method fn\n  is not provided for a class method, the superclass methd will be\n  called. If a method fn is not provided for an interface method, an\n  UnsupportedOperationException will be thrown should it be\n  called. Method fns are closures and can capture the environment in\n  which proxy is called. Each method fn takes an additional implicit\n  first arg, which is bound to 'this. Note that while method fns can\n  be provided to override protected methods, they have no other access\n  to protected members, nor to super, as these capabilities cannot be\n  proxied.\"\n  {:added \"1.0\"}\n  [class-and-interfaces args & fs]\n   (let [bases (map #(or (resolve %) (throw (Exception. (str \"Can't resolve: \" %)))) \n                    class-and-interfaces)\n         [super interfaces] (get-super-and-interfaces bases)\n         compile-effect (when *compile-files*\n                          (let [[cname bytecode] (generate-proxy super interfaces)]\n                            (clojure.lang.Compiler/writeClassFile cname bytecode)))\n         pc-effect (apply get-proxy-class bases)\n         pname (proxy-name super interfaces)]\n     ;remember the class to prevent it from disappearing before use\n     (intern *ns* (symbol pname) pc-effect)\n     `(let [;pc# (get-proxy-class ~@class-and-interfaces)\n            p# (new ~(symbol pname) ~@args)] ;(construct-proxy pc# ~@args)]   \n        (init-proxy p#\n         ~(loop [fmap {} fs fs]\n            (if fs\n              (let [[sym & meths] (first fs)\n                    meths (if (vector? (first meths))\n                            (list meths)\n                            meths)\n                    meths (map (fn [[params & body]]\n                                   (cons (apply vector 'this params) body))\n                               meths)]\n                (if-not (contains? fmap (name sym))\t\t  \n                (recur (assoc fmap (name sym) (cons `fn meths)) (next fs))\n\t\t           (throw (IllegalArgumentException.\n\t\t\t              (str \"Method '\" (name sym) \"' redefined\")))))\n              fmap)))\n        p#)))\n\n(defn proxy-call-with-super [call this meth]\n (let [m (proxy-mappings this)]\n    (update-proxy this (assoc m meth nil))\n    (try\n      (call)\n      (finally (update-proxy this m)))))\n\n(defmacro proxy-super \n  \"Use to call a superclass method in the body of a proxy method. \n  Note, expansion captures 'this\"\n  {:added \"1.0\"}\n  [meth & args]\n `(proxy-call-with-super (fn [] (. ~'this ~meth ~@args))  ~'this ~(name meth)))\n\n(defn bean\n  \"Takes a Java object and returns a read-only implementation of the\n  map abstraction based upon its JavaBean properties.\"\n  {:added \"1.0\"}\n  [^Object x]\n  (let [c (. x (getClass))\n\tpmap (reduce1 (fn [m ^java.beans.PropertyDescriptor pd]\n\t\t\t (let [name (. pd (getName))\n\t\t\t       method (. pd (getReadMethod))]\n\t\t\t   (if (and method (zero? (alength (. method (getParameterTypes)))))\n\t\t\t     (assoc m (keyword name) (fn [] (clojure.lang.Reflector/prepRet (.getPropertyType pd) (. method (invoke x nil)))))\n\t\t\t     m)))\n\t\t     {}\n\t\t     (seq (.. java.beans.Introspector\n\t\t\t      (getBeanInfo c)\n\t\t\t      (getPropertyDescriptors))))\n\tv (fn [k] ((pmap k)))\n        snapshot (fn []\n                   (reduce1 (fn [m e]\n                             (assoc m (key e) ((val e))))\n                           {} (seq pmap)))]\n    (proxy [clojure.lang.APersistentMap]\n           []\n      (iterator [] (.iterator ^Iterable pmap))\n      (containsKey [k] (contains? pmap k))\n      (entryAt [k] (when (contains? pmap k) (clojure.lang.MapEntry/create k (v k))))\n      (valAt ([k] (when (contains? pmap k) (v k)))\n\t     ([k default] (if (contains? pmap k) (v k) default)))\n      (cons [m] (conj (snapshot) m))\n      (count [] (count pmap))\n      (assoc [k v] (assoc (snapshot) k v))\n      (without [k] (dissoc (snapshot) k))\n      (seq [] ((fn thisfn [plseq]\n\t\t  (lazy-seq\n                   (when-let [pseq (seq plseq)]\n                     (cons (clojure.lang.MapEntry/create (first pseq) (v (first pseq)))\n                           (thisfn (rest pseq)))))) (keys pmap))))))\n\n\n\n", ";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n; Author: Frantisek Sodomka\n\n\n(ns clojure.test-clojure.java-interop\n  (:use clojure.test)\n  (:require [clojure.inspector]))\n\n; http://clojure.org/java_interop\n; http://clojure.org/compilation\n\n\n(deftest test-dot\n  ; (.instanceMember instance args*)\n  (are [x] (= x \"FRED\")\n      (.toUpperCase \"fred\") \n      (. \"fred\" toUpperCase)\n      (. \"fred\" (toUpperCase)) )\n\n  (are [x] (= x true)\n      (.startsWith \"abcde\" \"ab\")\n      (. \"abcde\" startsWith \"ab\")\n      (. \"abcde\" (startsWith \"ab\")) )\n\n  ; (.instanceMember Classname args*)\n  (are [x] (= x \"java.lang.String\")\n      (.getName String)\n      (. (identity String) getName)\n      (. (identity String) (getName)) )\n\n  ; (Classname/staticMethod args*)\n  (are [x] (= x 7)\n      (Math/abs -7)\n      (. Math abs -7)\n      (. Math (abs -7)) )\n\n  ; (. target -prop)\n  (let [p (java.awt.Point. 1 2)]\n    (are [x y] (= x y)\n       1 (.-x p)\n       2 (.-y p)\n       1 (. p -x)\n       2 (. p -y)\n       1 (. (java.awt.Point. 1 2) -x)\n       2 (. (java.awt.Point. 1 2) -y)))\n  \n  ; Classname/staticField\n  (are [x] (= x 2147483647)\n      Integer/MAX_VALUE\n      (. Integer MAX_VALUE) ))\n\n(definterface I (a []))\n(deftype T [a] I (a [_] \"method\"))\n\n(deftest test-reflective-field-name-ambiguous\n  (let [t (->T \"field\")]\n    (is (= \"method\" (. ^T t a)))\n    (is (= \"field\" (. ^T t -a)))\n    (is (= \"method\" (. t a)))\n    (is (= \"field\" (. t -a)))\n    (is (thrown? IllegalArgumentException (. t -BOGUS)))))\n\n(deftest test-double-dot\n  (is (= (.. System (getProperties) (get \"os.name\"))\n         (. (. System (getProperties)) (get \"os.name\")))))\n\n\n(deftest test-doto\n  (let [m (doto (new java.util.HashMap)\n            (.put \"a\" 1)\n            (.put \"b\" 2))]\n    (are [x y] (= x y)\n        (class m) java.util.HashMap\n        m {\"a\" 1 \"b\" 2} )))\n\n\n(deftest test-new\n  ; Integer\n  (are [expr cls value] (and (= (class expr) cls)\n                            (= expr value))\n      (new java.lang.Integer 42) java.lang.Integer 42\n      (java.lang.Integer. 123) java.lang.Integer 123 )\n\n  ; Date\n  (are [x] (= (class x) java.util.Date)\n      (new java.util.Date)\n      (java.util.Date.) ))\n\n\n(deftest test-instance?\n  ; evaluation\n  (are [x y] (= x y)\n      (instance? java.lang.Integer (+ 1 2)) false\n      (instance? java.lang.Long (+ 1 2)) true )\n\n  ; different types\n  (are [type literal] (instance? literal type)\n      1   java.lang.Long\n      1.0 java.lang.Double\n      1M  java.math.BigDecimal\n      \\a  java.lang.Character\n      \"a\" java.lang.String )\n\n  ; it is a Long, nothing else\n  (are [x y] (= (instance? x 42) y)\n      java.lang.Integer false\n      java.lang.Long true\n      java.lang.Character false\n      java.lang.String false )\n\n  ; test compiler macro\n  (is (let [Long String] (instance? Long \"abc\")))\n  (is (thrown? clojure.lang.ArityException (instance? Long))))\n\n; set!\n\n(defprotocol p (f [_]))\n(deftype t [^:unsynchronized-mutable x] p (f [_] (set! (.x _) 1)))\n\n(deftest test-set!\n  (is (= 1 (f (t. 1)))))\n\n; memfn\n\n\n(deftest test-bean\n  (let [b (bean java.awt.Color/black)]\n    (are [x y] (= x y)\n        (map? b) true\n\n        (:red b) 0\n        (:green b) 0\n        (:blue b) 0\n        (:RGB b) -16777216\n\n        (:alpha b) 255\n        (:transparency b) 1\n\n        (:missing b) nil\n        (:missing b :default) :default\n        (get b :missing) nil\n        (get b :missing :default) :default\n\n        (:class b) java.awt.Color )))\n\n(deftest test-iterable-bean\n  (is (.iterator ^Iterable (bean (java.util.Date.))))\n  (is (hash (bean (java.util.Date.)))))\n\n; proxy, proxy-super\n\n(deftest test-proxy-chain\n  (testing \"That the proxy functions can chain\"\n    (are [x y] (= x y)\n        (-> (get-proxy-class Object) \n            construct-proxy\n            (init-proxy {}) \n            (update-proxy {\"toString\" (fn [_] \"chain chain chain\")}) \n            str)\n        \"chain chain chain\"\n\n        (-> (proxy [Object] [] (toString [] \"superfuzz bigmuff\")) \n            (update-proxy {\"toString\" (fn [_] \"chain chain chain\")}) \n            str)\n        \"chain chain chain\")))\n\n\n;; serialized-proxy can be regenerated using a modified version of\n;; Clojure with the proxy serialization prohibition disabled and the\n;; following code:\n#_(let [baos (java.io.ByteArrayOutputStream.) ]\n    (with-open [baos baos]\n      (.writeObject (java.io.ObjectOutputStream. baos) (clojure.inspector/list-model nil)))\n    (println (apply str (for [c (String. (.toByteArray baos) \"ISO-8859-1\")]\n                          (if (<= 32 (int c) (int \\z)) c (format \"\\\\%03o\" (int c)))))))\n(def serialized-proxy \"\\254\\355\\000\\005sr\\000Eclojure.inspector.proxy$javax.swing.table.AbstractTableModel$ff19274art\\330\\266_\\010ME\\002\\000\\001L\\000\\016__clojureFnMapt\\000\\035Lclojure/lang/IPersistentMap;xr\\000$javax.swing.table.AbstractTableModelr\\313\\3538\\256\\001\\377\\276\\002\\000\\001L\\000\\014listenerListt\\000%Ljavax/swing/event/EventListenerList;xpsr\\000#javax.swing.event.EventListenerList\\2616\\306\\175\\204\\352\\326D\\003\\000\\000xppxsr\\000\\037clojure.lang.PersistentArrayMap\\3437p\\017\\230\\305\\364\\337\\002\\000\\002L\\000\\005_metaq\\000\\176\\000\\001[\\000\\005arrayt\\000\\023[Ljava/lang/Object;xr\\000\\033clojure.lang.APersistentMap]\\174/\\003t r\\173\\002\\000\\002I\\000\\005_hashI\\000\\007_hasheqxp\\000\\000\\000\\000\\000\\000\\000\\000pur\\000\\023[Ljava.lang.Object;\\220\\316X\\237\\020s)l\\002\\000\\000xp\\000\\000\\000\\006t\\000\\016getColumnCountsr\\000%clojure.inspector$list_model$fn__8816H\\252\\320\\325b\\371!+\\002\\000\\000xr\\000\\026clojure.lang.AFunction>\\006p\\234\\236F\\375\\313\\002\\000\\001L\\000\\021__methodImplCachet\\000\\036Lclojure/lang/MethodImplCache;xppt\\000\\013getRowCountsr\\000%clojure.inspector$list_model$fn__8818-\\037I\\247\\234/U\\226\\002\\000\\001L\\000\\005nrowst\\000\\022Ljava/lang/Object;xq\\000\\176\\000\\017ppt\\000\\012getValueAtsr\\000%clojure.inspector$list_model$fn__8820\\323\\331\\174ke\\233\\370\\034\\002\\000\\002L\\000\\011get_labelq\\000\\176\\000\\024L\\000\\011get_valueq\\000\\176\\000\\024xq\\000\\176\\000\\017ppp\")\n\n(deftest test-proxy-non-serializable\n  (testing \"That proxy classes refuse serialization and deserialization\"\n    ;; Serializable listed directly in interface list:\n    (is (thrown? java.io.NotSerializableException\n                 (-> (java.io.ByteArrayOutputStream.)\n                     (java.io.ObjectOutputStream.)\n                     (.writeObject (proxy [Object java.io.Serializable] [])))))\n    ;; Serializable included via inheritence:\n    (is (thrown? java.io.NotSerializableException\n                 (-> (java.io.ByteArrayOutputStream.)\n                     (java.io.ObjectOutputStream.)\n                     (.writeObject (clojure.inspector/list-model nil)))))\n    ;; Deserialization also prohibited:\n    (is (thrown? java.io.NotSerializableException\n                 (-> serialized-proxy (.getBytes \"ISO-8859-1\")\n                     java.io.ByteArrayInputStream. java.io.ObjectInputStream.\n                     .readObject)))))\n\n(deftest test-bases\n  (are [x y] (= x y)\n      (bases java.lang.Math)\n        (list java.lang.Object)\n      (bases java.util.Collection)\n        (list java.lang.Iterable)\n      (bases java.lang.Object)\n        nil\n      (bases java.lang.Comparable)\n        nil\n      (bases java.lang.Integer)\n        (list java.lang.Number java.lang.Comparable) ))\n\n(deftest test-supers\n  (are [x y] (= x y)\n      (supers java.lang.Math)\n        #{java.lang.Object}\n      (supers java.lang.Integer)\n        #{java.lang.Number java.lang.Object\n          java.lang.Comparable java.io.Serializable} ))\n\n(deftest test-proxy-super\n  (let [d (proxy [java.util.BitSet] []\n            (flip [bitIndex]\n              (try\n                (proxy-super flip bitIndex)\n                (catch IndexOutOfBoundsException e\n                  (throw (IllegalArgumentException. \"replaced\"))))))]\n    ;; normal call\n    (is (nil? (.flip d 0)))\n    ;; exception should use proxied form and return IllegalArg\n    (is (thrown? IllegalArgumentException (.flip d -1)))\n    ;; same behavior on second call\n    (is (thrown? IllegalArgumentException (.flip d -1)))))\n\n;; http://dev.clojure.org/jira/browse/CLJ-1657\n(deftest test-proxy-abstract-super\n  (let [p (proxy [java.io.Writer] [])]\n    (is (thrown? UnsupportedOperationException (.close p)))))\n\n; Arrays: [alength] aget aset [make-array to-array into-array to-array-2d aclone]\n;   [float-array, int-array, etc]\n;   amap, areduce\n\n(defmacro deftest-type-array [type-array type]\n  `(deftest ~(symbol (str \"test-\" type-array))\n      ; correct type\n      #_(is (= (class (first (~type-array [1 2]))) (class (~type 1))))\n\n      ; given size (and empty)\n      (are [x] (and (= (alength (~type-array x)) x)\n                    (= (vec (~type-array x)) (repeat x 0)))\n          0 1 5 )\n\n      ; copy of a sequence\n      (are [x] (and (= (alength (~type-array x)) (count x))\n                    (= (vec (~type-array x)) x))\n          []\n          [1]\n          [1 -2 3 0 5] )\n\n      ; given size and init-value\n      (are [x] (and (= (alength (~type-array x 42)) x)\n                    (= (vec (~type-array x 42)) (repeat x 42)))\n          0 1 5 )\n\n      ; given size and init-seq\n      (are [x y z] (and (= (alength (~type-array x y)) x)\n                        (= (vec (~type-array x y)) z))\n          0 [] []\n          0 [1] []\n          0 [1 2 3] []\n          1 [] [0]\n          1 [1] [1]\n          1 [1 2 3] [1]\n          5 [] [0 0 0 0 0]\n          5 [1] [1 0 0 0 0]\n          5 [1 2 3] [1 2 3 0 0]\n          5 [1 2 3 4 5] [1 2 3 4 5]\n          5 [1 2 3 4 5 6 7] [1 2 3 4 5] )))\n\n(deftest-type-array int-array int)\n(deftest-type-array long-array long)\n;todo, fix, test broken for float/double, should compare to 1.0 2.0 etc\n#_(deftest-type-array float-array float)\n#_(deftest-type-array double-array double)\n\n; separate test for exceptions (doesn't work with above macro...)\n(deftest test-type-array-exceptions\n  (are [x] (thrown? NegativeArraySizeException x)\n       (int-array -1)\n       (long-array -1)\n       (float-array -1)\n       (double-array -1) ))\n\n\n(deftest test-make-array\n  ; negative size\n  (is (thrown? NegativeArraySizeException (make-array Integer -1)))\n\n  ; one-dimensional\n  (are [x] (= (alength (make-array Integer x)) x)\n      0 1 5 )\n\n  (let [a (make-array Long 5)]\n    (aset a 3 42)\n    (are [x y] (= x y)\n        (aget a 3) 42\n        (class (aget a 3)) Long ))\n      \n  ; multi-dimensional\n  (let [a (make-array Long 3 2 4)]\n    (aset a 0 1 2 987)\n    (are [x y] (= x y)\n        (alength a) 3\n        (alength (first a)) 2\n        (alength (first (first a))) 4\n\n        (aget a 0 1 2) 987\n        (class (aget a 0 1 2)) Long )))\n\n\n(deftest test-to-array\n  (let [v [1 \"abc\" :kw \\c []]\n        a (to-array v)]\n    (are [x y] (= x y)\n        ; length\n        (alength a) (count v)\n\n        ; content\n        (vec a) v\n        (class (aget a 0)) (class (nth v 0))\n        (class (aget a 1)) (class (nth v 1))\n        (class (aget a 2)) (class (nth v 2))\n        (class (aget a 3)) (class (nth v 3))\n        (class (aget a 4)) (class (nth v 4)) ))\n\n  ; different kinds of collections\n  (are [x] (and (= (alength (to-array x)) (count x))\n                (= (vec (to-array x)) (vec x)))\n      ()\n      '(1 2)\n      []\n      [1 2]\n      (sorted-set)\n      (sorted-set 1 2)\n      \n      (int-array 0)\n      (int-array [1 2 3])\n\n      (to-array [])\n      (to-array [1 2 3]) ))\n\n(defn queue [& contents]\n  (apply conj (clojure.lang.PersistentQueue/EMPTY) contents))\n\n(defn array-typed-equals [expected actual]\n  (and (= (class expected) (class actual))\n       (java.util.Arrays/equals expected actual)))\n\n(defmacro test-to-passed-array-for [collection-type]\n  `(deftest ~(symbol (str \"test-to-passed-array-for-\" collection-type))\n     (let [string-array# (make-array String 5)\n           shorter# (~collection-type \"1\" \"2\" \"3\")\n           same-length# (~collection-type \"1\" \"2\" \"3\" \"4\" \"5\")\n           longer# (~collection-type \"1\" \"2\" \"3\" \"4\" \"5\" \"6\")]\n       (are [expected actual] (array-typed-equals expected actual)\n            (into-array String [\"1\" \"2\" \"3\" nil nil]) (.toArray shorter# string-array#)\n            (into-array String [\"1\" \"2\" \"3\" \"4\" \"5\"]) (.toArray same-length# string-array#)\n            (into-array String [\"1\" \"2\" \"3\" \"4\" \"5\" \"6\"]) (.toArray longer# string-array#)))))\n\n\n(test-to-passed-array-for vector)\n(test-to-passed-array-for list)\n;;(test-to-passed-array-for hash-set)\n(test-to-passed-array-for queue)\n\n(deftest test-into-array\n  ; compatible types only\n  (is (thrown? IllegalArgumentException (into-array [1 \"abc\" :kw])))\n  (is (thrown? IllegalArgumentException (into-array [1.2 4])))\n  (is (thrown? IllegalArgumentException (into-array [(byte 2) (short 3)])))\n  (is (thrown? IllegalArgumentException (into-array Byte/TYPE [100000000000000])))\n  \n  ; simple case\n  (let [v [1 2 3 4 5]\n        a (into-array v)]\n    (are [x y] (= x y)\n        (alength a) (count v)\n        (vec a) v\n        (class (first a)) (class (first v)) ))\n\n  (is (= \\a (aget (into-array Character/TYPE [\\a \\b \\c]) 0)))\n\n  (is (= [nil 1 2] (seq (into-array [nil 1 2]))))\n  \n  (let [types [Integer/TYPE\n               Byte/TYPE\n               Float/TYPE\n               Short/TYPE\n               Double/TYPE\n               Long/TYPE]\n        values [(byte 2) (short 3) (int 4) 5]]\n    (for [t types]\n      (let [a (into-array t values)]\n        (is (== (aget a 0) 2))\n        (is (== (aget a 1) 3))\n        (is (== (aget a 2) 4))\n        (is (== (aget a 3) 5)))))\n  \n  ; different kinds of collections\n  (are [x] (and (= (alength (into-array x)) (count x))\n                (= (vec (into-array x)) (vec x))\n                (= (alength (into-array Long/TYPE x)) (count x))\n                (= (vec (into-array Long/TYPE x)) (vec x)))\n      ()\n      '(1 2)\n      []\n      [1 2]\n      (sorted-set)\n      (sorted-set 1 2)\n\n      (int-array 0)\n      (int-array [1 2 3])\n\n      (to-array [])\n      (to-array [1 2 3]) ))\n\n\n(deftest test-to-array-2d\n  ; needs to be a collection of collection(s)\n  (is (thrown? Exception (to-array-2d [1 2 3])))\n\n  ; ragged array\n  (let [v [[1] [2 3] [4 5 6]]\n        a (to-array-2d v)]\n    (are [x y] (= x y)\n        (alength a) (count v)\n        (alength (aget a 0)) (count (nth v 0))\n        (alength (aget a 1)) (count (nth v 1))\n        (alength (aget a 2)) (count (nth v 2))\n\n        (vec (aget a 0)) (nth v 0)\n        (vec (aget a 1)) (nth v 1)\n        (vec (aget a 2)) (nth v 2) ))\n\n  ; empty array\n  (let [a (to-array-2d [])]\n    (are [x y] (= x y)\n        (alength a) 0\n        (vec a) [] )))\n\n\n(deftest test-alength\n  (are [x] (= (alength x) 0)\n      (int-array 0)\n      (long-array 0)\n      (float-array 0)\n      (double-array 0)\n      (boolean-array 0)\n      (byte-array 0)\n      (char-array 0)\n      (short-array 0)\n      (make-array Integer/TYPE 0)\n      (to-array [])\n      (into-array [])\n      (to-array-2d []) )\n\n  (are [x] (= (alength x) 1)\n      (int-array 1)\n      (long-array 1)\n      (float-array 1)\n      (double-array 1)\n      (boolean-array 1)\n      (byte-array 1)\n      (char-array 1)\n      (short-array 1)\n      (make-array Integer/TYPE 1)\n      (to-array [1])\n      (into-array [1])\n      (to-array-2d [[1]]) )\n\n  (are [x] (= (alength x) 3)\n      (int-array 3)\n      (long-array 3)\n      (float-array 3)\n      (double-array 3)\n      (boolean-array 3)\n      (byte-array 3)\n      (char-array 3)\n      (short-array 3)\n      (make-array Integer/TYPE 3)\n      (to-array [1 \"a\" :k])\n      (into-array [1 2 3])\n      (to-array-2d [[1] [2 3] [4 5 6]]) ))\n\n\n(deftest test-aclone\n  ; clone all arrays except 2D\n  (are [x] (and (= (alength (aclone x)) (alength x))\n                (= (vec (aclone x)) (vec x)))\n      (int-array 0)\n      (long-array 0)\n      (float-array 0)\n      (double-array 0)\n      (boolean-array 0)\n      (byte-array 0)\n      (char-array 0)\n      (short-array 0)\n      (make-array Integer/TYPE 0)\n      (to-array [])\n      (into-array [])\n\n      (int-array [1 2 3])\n      (long-array [1 2 3])\n      (float-array [1 2 3])\n      (double-array [1 2 3])\n      (boolean-array [true false])\n      (byte-array [(byte 1) (byte 2)])\n      (byte-array [1 2])\n      (byte-array 2 [1 2])\n      (char-array [\\a \\b \\c])\n      (short-array [(short 1) (short 2)])\n      (short-array [1 2])\n      (short-array 2 [1 2])\n      (make-array Integer/TYPE 3)\n      (to-array [1 \"a\" :k])\n      (into-array [1 2 3]) )\n\n  ; clone 2D\n  (are [x] (and (= (alength (aclone x)) (alength x))\n                (= (map alength (aclone x)) (map alength x))\n                (= (map vec (aclone x)) (map vec x)))\n      (to-array-2d [])\n      (to-array-2d [[1] [2 3] [4 5 6]]) ))\n\n\n; Type Hints, *warn-on-reflection*\n;   #^ints, #^floats, #^longs, #^doubles\n\n; Coercions: [int, long, float, double, char, boolean, short, byte]\n;   num\n;   ints/longs/floats/doubles\n\n(deftest test-boolean\n  (are [x y] (and (instance? java.lang.Boolean (boolean x))\n                  (= (boolean x) y))\n      nil false\n      false false\n      true true\n\n      0 true\n      1 true\n      () true\n      [1] true\n\n      \"\" true\n      \\space true\n      :kw true ))\n\n\n(deftest test-char\n  ; int -> char\n  (is (instance? java.lang.Character (char 65)))\n\n  ; char -> char\n  (is (instance? java.lang.Character (char \\a)))\n  (is (= (char \\a) \\a)))\n\n;; Note: More coercions in numbers.clj\n"], "filenames": ["src/clj/clojure/core_proxy.clj", "test/clojure/test_clojure/java_interop.clj"], "buggy_code_start_loc": [15, 13], "buggy_code_end_loc": [150, 172], "fixing_code_start_loc": [16, 13], "fixing_code_end_loc": [169, 202], "type": "CWE-502", "message": "In Clojure before 1.9.0, classes can be used to construct a serialized object that executes arbitrary code upon deserialization. This is relevant if a server deserializes untrusted objects.", "other": {"cve": {"id": "CVE-2017-20189", "sourceIdentifier": "cve@mitre.org", "published": "2024-01-22T06:15:07.563", "lastModified": "2024-01-30T23:01:53.763", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Clojure before 1.9.0, classes can be used to construct a serialized object that executes arbitrary code upon deserialization. This is relevant if a server deserializes untrusted objects."}, {"lang": "es", "value": "En Clojure anterior a 1.9.0, las clases se pueden usar para construir un objeto serializado que ejecuta c\u00f3digo arbitrario tras la deserializaci\u00f3n. Esto es relevante si un servidor deserializa objetos que no son de confianza."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-502"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:clojure:clojure:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.9.0", "matchCriteriaId": "BF6C5ABE-97CB-400C-880A-453F5CA13383"}]}]}], "references": [{"url": "https://clojure.atlassian.net/browse/CLJ-2204", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/clojure/clojure/commit/271674c9b484d798484d134a5ac40a6df15d3ac3", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/frohoff/ysoserial/pull/68/files", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://hackmd.io/%40fe1w0/HyefvRQKp", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://security.snyk.io/vuln/SNYK-JAVA-ORGCLOJURE-5740378", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/clojure/clojure/commit/271674c9b484d798484d134a5ac40a6df15d3ac3"}}