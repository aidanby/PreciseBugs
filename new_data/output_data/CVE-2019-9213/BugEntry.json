{"buggy_code": ["/*\n * mm/mmap.c\n *\n * Written by obz.\n *\n * Address space accounting code\t<alan@lxorguk.ukuu.org.uk>\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/vmacache.h>\n#include <linux/shm.h>\n#include <linux/mman.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/personality.h>\n#include <linux/security.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n#include <linux/mount.h>\n#include <linux/mempolicy.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mmdebug.h>\n#include <linux/perf_event.h>\n#include <linux/audit.h>\n#include <linux/khugepaged.h>\n#include <linux/uprobes.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/notifier.h>\n#include <linux/memory.h>\n#include <linux/printk.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/moduleparam.h>\n#include <linux/pkeys.h>\n#include <linux/oom.h>\n\n#include <linux/uaccess.h>\n#include <asm/cacheflush.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n\n#include \"internal.h\"\n\n#ifndef arch_mmap_check\n#define arch_mmap_check(addr, len, flags)\t(0)\n#endif\n\n#ifdef CONFIG_HAVE_ARCH_MMAP_RND_BITS\nconst int mmap_rnd_bits_min = CONFIG_ARCH_MMAP_RND_BITS_MIN;\nconst int mmap_rnd_bits_max = CONFIG_ARCH_MMAP_RND_BITS_MAX;\nint mmap_rnd_bits __read_mostly = CONFIG_ARCH_MMAP_RND_BITS;\n#endif\n#ifdef CONFIG_HAVE_ARCH_MMAP_RND_COMPAT_BITS\nconst int mmap_rnd_compat_bits_min = CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MIN;\nconst int mmap_rnd_compat_bits_max = CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MAX;\nint mmap_rnd_compat_bits __read_mostly = CONFIG_ARCH_MMAP_RND_COMPAT_BITS;\n#endif\n\nstatic bool ignore_rlimit_data;\ncore_param(ignore_rlimit_data, ignore_rlimit_data, bool, 0644);\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);\n\n/* description of effects of mapping type and prot in current implementation.\n * this is due to the limited x86 page protection hardware.  The expected\n * behavior is in parens:\n *\n * map_type\tprot\n *\t\tPROT_NONE\tPROT_READ\tPROT_WRITE\tPROT_EXEC\n * MAP_SHARED\tr: (no) no\tr: (yes) yes\tr: (no) yes\tr: (no) yes\n *\t\tw: (no) no\tw: (no) no\tw: (yes) yes\tw: (no) no\n *\t\tx: (no) no\tx: (no) yes\tx: (no) yes\tx: (yes) yes\n *\n * MAP_PRIVATE\tr: (no) no\tr: (yes) yes\tr: (no) yes\tr: (no) yes\n *\t\tw: (no) no\tw: (no) no\tw: (copy) copy\tw: (no) no\n *\t\tx: (no) no\tx: (no) yes\tx: (no) yes\tx: (yes) yes\n *\n * On arm64, PROT_EXEC has the following behaviour for both MAP_SHARED and\n * MAP_PRIVATE:\n *\t\t\t\t\t\t\t\tr: (no) no\n *\t\t\t\t\t\t\t\tw: (no) no\n *\t\t\t\t\t\t\t\tx: (yes) yes\n */\npgprot_t protection_map[16] __ro_after_init = {\n\t__P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111,\n\t__S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111\n};\n\n#ifndef CONFIG_ARCH_HAS_FILTER_PGPROT\nstatic inline pgprot_t arch_filter_pgprot(pgprot_t prot)\n{\n\treturn prot;\n}\n#endif\n\npgprot_t vm_get_page_prot(unsigned long vm_flags)\n{\n\tpgprot_t ret = __pgprot(pgprot_val(protection_map[vm_flags &\n\t\t\t\t(VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)]) |\n\t\t\tpgprot_val(arch_vm_get_page_prot(vm_flags)));\n\n\treturn arch_filter_pgprot(ret);\n}\nEXPORT_SYMBOL(vm_get_page_prot);\n\nstatic pgprot_t vm_pgprot_modify(pgprot_t oldprot, unsigned long vm_flags)\n{\n\treturn pgprot_modify(oldprot, vm_get_page_prot(vm_flags));\n}\n\n/* Update vma->vm_page_prot to reflect vma->vm_flags. */\nvoid vma_set_page_prot(struct vm_area_struct *vma)\n{\n\tunsigned long vm_flags = vma->vm_flags;\n\tpgprot_t vm_page_prot;\n\n\tvm_page_prot = vm_pgprot_modify(vma->vm_page_prot, vm_flags);\n\tif (vma_wants_writenotify(vma, vm_page_prot)) {\n\t\tvm_flags &= ~VM_SHARED;\n\t\tvm_page_prot = vm_pgprot_modify(vm_page_prot, vm_flags);\n\t}\n\t/* remove_protection_ptes reads vma->vm_page_prot without mmap_sem */\n\tWRITE_ONCE(vma->vm_page_prot, vm_page_prot);\n}\n\n/*\n * Requires inode->i_mapping->i_mmap_rwsem\n */\nstatic void __remove_shared_vm_struct(struct vm_area_struct *vma,\n\t\tstruct file *file, struct address_space *mapping)\n{\n\tif (vma->vm_flags & VM_DENYWRITE)\n\t\tatomic_inc(&file_inode(file)->i_writecount);\n\tif (vma->vm_flags & VM_SHARED)\n\t\tmapping_unmap_writable(mapping);\n\n\tflush_dcache_mmap_lock(mapping);\n\tvma_interval_tree_remove(vma, &mapping->i_mmap);\n\tflush_dcache_mmap_unlock(mapping);\n}\n\n/*\n * Unlink a file-based vm structure from its interval tree, to hide\n * vma from rmap and vmtruncate before freeing its page tables.\n */\nvoid unlink_file_vma(struct vm_area_struct *vma)\n{\n\tstruct file *file = vma->vm_file;\n\n\tif (file) {\n\t\tstruct address_space *mapping = file->f_mapping;\n\t\ti_mmap_lock_write(mapping);\n\t\t__remove_shared_vm_struct(vma, file, mapping);\n\t\ti_mmap_unlock_write(mapping);\n\t}\n}\n\n/*\n * Close a vm structure and free it, returning the next.\n */\nstatic struct vm_area_struct *remove_vma(struct vm_area_struct *vma)\n{\n\tstruct vm_area_struct *next = vma->vm_next;\n\n\tmight_sleep();\n\tif (vma->vm_ops && vma->vm_ops->close)\n\t\tvma->vm_ops->close(vma);\n\tif (vma->vm_file)\n\t\tfput(vma->vm_file);\n\tmpol_put(vma_policy(vma));\n\tvm_area_free(vma);\n\treturn next;\n}\n\nstatic int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);\nSYSCALL_DEFINE1(brk, unsigned long, brk)\n{\n\tunsigned long retval;\n\tunsigned long newbrk, oldbrk, origbrk;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *next;\n\tunsigned long min_brk;\n\tbool populate;\n\tbool downgraded = false;\n\tLIST_HEAD(uf);\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\torigbrk = mm->brk;\n\n#ifdef CONFIG_COMPAT_BRK\n\t/*\n\t * CONFIG_COMPAT_BRK can still be overridden by setting\n\t * randomize_va_space to 2, which will still cause mm->start_brk\n\t * to be arbitrarily shifted\n\t */\n\tif (current->brk_randomized)\n\t\tmin_brk = mm->start_brk;\n\telse\n\t\tmin_brk = mm->end_data;\n#else\n\tmin_brk = mm->start_brk;\n#endif\n\tif (brk < min_brk)\n\t\tgoto out;\n\n\t/*\n\t * Check against rlimit here. If this check is done later after the test\n\t * of oldbrk with newbrk then it can escape the test and let the data\n\t * segment grow beyond its set limit the in case where the limit is\n\t * not page aligned -Ram Gupta\n\t */\n\tif (check_data_rlimit(rlimit(RLIMIT_DATA), brk, mm->start_brk,\n\t\t\t      mm->end_data, mm->start_data))\n\t\tgoto out;\n\n\tnewbrk = PAGE_ALIGN(brk);\n\toldbrk = PAGE_ALIGN(mm->brk);\n\tif (oldbrk == newbrk) {\n\t\tmm->brk = brk;\n\t\tgoto success;\n\t}\n\n\t/*\n\t * Always allow shrinking brk.\n\t * __do_munmap() may downgrade mmap_sem to read.\n\t */\n\tif (brk <= mm->brk) {\n\t\tint ret;\n\n\t\t/*\n\t\t * mm->brk must to be protected by write mmap_sem so update it\n\t\t * before downgrading mmap_sem. When __do_munmap() fails,\n\t\t * mm->brk will be restored from origbrk.\n\t\t */\n\t\tmm->brk = brk;\n\t\tret = __do_munmap(mm, newbrk, oldbrk-newbrk, &uf, true);\n\t\tif (ret < 0) {\n\t\t\tmm->brk = origbrk;\n\t\t\tgoto out;\n\t\t} else if (ret == 1) {\n\t\t\tdowngraded = true;\n\t\t}\n\t\tgoto success;\n\t}\n\n\t/* Check against existing mmap mappings. */\n\tnext = find_vma(mm, oldbrk);\n\tif (next && newbrk + PAGE_SIZE > vm_start_gap(next))\n\t\tgoto out;\n\n\t/* Ok, looks good - let it rip. */\n\tif (do_brk_flags(oldbrk, newbrk-oldbrk, 0, &uf) < 0)\n\t\tgoto out;\n\tmm->brk = brk;\n\nsuccess:\n\tpopulate = newbrk > oldbrk && (mm->def_flags & VM_LOCKED) != 0;\n\tif (downgraded)\n\t\tup_read(&mm->mmap_sem);\n\telse\n\t\tup_write(&mm->mmap_sem);\n\tuserfaultfd_unmap_complete(mm, &uf);\n\tif (populate)\n\t\tmm_populate(oldbrk, newbrk - oldbrk);\n\treturn brk;\n\nout:\n\tretval = origbrk;\n\tup_write(&mm->mmap_sem);\n\treturn retval;\n}\n\nstatic long vma_compute_subtree_gap(struct vm_area_struct *vma)\n{\n\tunsigned long max, prev_end, subtree_gap;\n\n\t/*\n\t * Note: in the rare case of a VM_GROWSDOWN above a VM_GROWSUP, we\n\t * allow two stack_guard_gaps between them here, and when choosing\n\t * an unmapped area; whereas when expanding we only require one.\n\t * That's a little inconsistent, but keeps the code here simpler.\n\t */\n\tmax = vm_start_gap(vma);\n\tif (vma->vm_prev) {\n\t\tprev_end = vm_end_gap(vma->vm_prev);\n\t\tif (max > prev_end)\n\t\t\tmax -= prev_end;\n\t\telse\n\t\t\tmax = 0;\n\t}\n\tif (vma->vm_rb.rb_left) {\n\t\tsubtree_gap = rb_entry(vma->vm_rb.rb_left,\n\t\t\t\tstruct vm_area_struct, vm_rb)->rb_subtree_gap;\n\t\tif (subtree_gap > max)\n\t\t\tmax = subtree_gap;\n\t}\n\tif (vma->vm_rb.rb_right) {\n\t\tsubtree_gap = rb_entry(vma->vm_rb.rb_right,\n\t\t\t\tstruct vm_area_struct, vm_rb)->rb_subtree_gap;\n\t\tif (subtree_gap > max)\n\t\t\tmax = subtree_gap;\n\t}\n\treturn max;\n}\n\n#ifdef CONFIG_DEBUG_VM_RB\nstatic int browse_rb(struct mm_struct *mm)\n{\n\tstruct rb_root *root = &mm->mm_rb;\n\tint i = 0, j, bug = 0;\n\tstruct rb_node *nd, *pn = NULL;\n\tunsigned long prev = 0, pend = 0;\n\n\tfor (nd = rb_first(root); nd; nd = rb_next(nd)) {\n\t\tstruct vm_area_struct *vma;\n\t\tvma = rb_entry(nd, struct vm_area_struct, vm_rb);\n\t\tif (vma->vm_start < prev) {\n\t\t\tpr_emerg(\"vm_start %lx < prev %lx\\n\",\n\t\t\t\t  vma->vm_start, prev);\n\t\t\tbug = 1;\n\t\t}\n\t\tif (vma->vm_start < pend) {\n\t\t\tpr_emerg(\"vm_start %lx < pend %lx\\n\",\n\t\t\t\t  vma->vm_start, pend);\n\t\t\tbug = 1;\n\t\t}\n\t\tif (vma->vm_start > vma->vm_end) {\n\t\t\tpr_emerg(\"vm_start %lx > vm_end %lx\\n\",\n\t\t\t\t  vma->vm_start, vma->vm_end);\n\t\t\tbug = 1;\n\t\t}\n\t\tspin_lock(&mm->page_table_lock);\n\t\tif (vma->rb_subtree_gap != vma_compute_subtree_gap(vma)) {\n\t\t\tpr_emerg(\"free gap %lx, correct %lx\\n\",\n\t\t\t       vma->rb_subtree_gap,\n\t\t\t       vma_compute_subtree_gap(vma));\n\t\t\tbug = 1;\n\t\t}\n\t\tspin_unlock(&mm->page_table_lock);\n\t\ti++;\n\t\tpn = nd;\n\t\tprev = vma->vm_start;\n\t\tpend = vma->vm_end;\n\t}\n\tj = 0;\n\tfor (nd = pn; nd; nd = rb_prev(nd))\n\t\tj++;\n\tif (i != j) {\n\t\tpr_emerg(\"backwards %d, forwards %d\\n\", j, i);\n\t\tbug = 1;\n\t}\n\treturn bug ? -1 : i;\n}\n\nstatic void validate_mm_rb(struct rb_root *root, struct vm_area_struct *ignore)\n{\n\tstruct rb_node *nd;\n\n\tfor (nd = rb_first(root); nd; nd = rb_next(nd)) {\n\t\tstruct vm_area_struct *vma;\n\t\tvma = rb_entry(nd, struct vm_area_struct, vm_rb);\n\t\tVM_BUG_ON_VMA(vma != ignore &&\n\t\t\tvma->rb_subtree_gap != vma_compute_subtree_gap(vma),\n\t\t\tvma);\n\t}\n}\n\nstatic void validate_mm(struct mm_struct *mm)\n{\n\tint bug = 0;\n\tint i = 0;\n\tunsigned long highest_address = 0;\n\tstruct vm_area_struct *vma = mm->mmap;\n\n\twhile (vma) {\n\t\tstruct anon_vma *anon_vma = vma->anon_vma;\n\t\tstruct anon_vma_chain *avc;\n\n\t\tif (anon_vma) {\n\t\t\tanon_vma_lock_read(anon_vma);\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tanon_vma_interval_tree_verify(avc);\n\t\t\tanon_vma_unlock_read(anon_vma);\n\t\t}\n\n\t\thighest_address = vm_end_gap(vma);\n\t\tvma = vma->vm_next;\n\t\ti++;\n\t}\n\tif (i != mm->map_count) {\n\t\tpr_emerg(\"map_count %d vm_next %d\\n\", mm->map_count, i);\n\t\tbug = 1;\n\t}\n\tif (highest_address != mm->highest_vm_end) {\n\t\tpr_emerg(\"mm->highest_vm_end %lx, found %lx\\n\",\n\t\t\t  mm->highest_vm_end, highest_address);\n\t\tbug = 1;\n\t}\n\ti = browse_rb(mm);\n\tif (i != mm->map_count) {\n\t\tif (i != -1)\n\t\t\tpr_emerg(\"map_count %d rb %d\\n\", mm->map_count, i);\n\t\tbug = 1;\n\t}\n\tVM_BUG_ON_MM(bug, mm);\n}\n#else\n#define validate_mm_rb(root, ignore) do { } while (0)\n#define validate_mm(mm) do { } while (0)\n#endif\n\nRB_DECLARE_CALLBACKS(static, vma_gap_callbacks, struct vm_area_struct, vm_rb,\n\t\t     unsigned long, rb_subtree_gap, vma_compute_subtree_gap)\n\n/*\n * Update augmented rbtree rb_subtree_gap values after vma->vm_start or\n * vma->vm_prev->vm_end values changed, without modifying the vma's position\n * in the rbtree.\n */\nstatic void vma_gap_update(struct vm_area_struct *vma)\n{\n\t/*\n\t * As it turns out, RB_DECLARE_CALLBACKS() already created a callback\n\t * function that does exacltly what we want.\n\t */\n\tvma_gap_callbacks_propagate(&vma->vm_rb, NULL);\n}\n\nstatic inline void vma_rb_insert(struct vm_area_struct *vma,\n\t\t\t\t struct rb_root *root)\n{\n\t/* All rb_subtree_gap values must be consistent prior to insertion */\n\tvalidate_mm_rb(root, NULL);\n\n\trb_insert_augmented(&vma->vm_rb, root, &vma_gap_callbacks);\n}\n\nstatic void __vma_rb_erase(struct vm_area_struct *vma, struct rb_root *root)\n{\n\t/*\n\t * Note rb_erase_augmented is a fairly large inline function,\n\t * so make sure we instantiate it only once with our desired\n\t * augmented rbtree callbacks.\n\t */\n\trb_erase_augmented(&vma->vm_rb, root, &vma_gap_callbacks);\n}\n\nstatic __always_inline void vma_rb_erase_ignore(struct vm_area_struct *vma,\n\t\t\t\t\t\tstruct rb_root *root,\n\t\t\t\t\t\tstruct vm_area_struct *ignore)\n{\n\t/*\n\t * All rb_subtree_gap values must be consistent prior to erase,\n\t * with the possible exception of the \"next\" vma being erased if\n\t * next->vm_start was reduced.\n\t */\n\tvalidate_mm_rb(root, ignore);\n\n\t__vma_rb_erase(vma, root);\n}\n\nstatic __always_inline void vma_rb_erase(struct vm_area_struct *vma,\n\t\t\t\t\t struct rb_root *root)\n{\n\t/*\n\t * All rb_subtree_gap values must be consistent prior to erase,\n\t * with the possible exception of the vma being erased.\n\t */\n\tvalidate_mm_rb(root, vma);\n\n\t__vma_rb_erase(vma, root);\n}\n\n/*\n * vma has some anon_vma assigned, and is already inserted on that\n * anon_vma's interval trees.\n *\n * Before updating the vma's vm_start / vm_end / vm_pgoff fields, the\n * vma must be removed from the anon_vma's interval trees using\n * anon_vma_interval_tree_pre_update_vma().\n *\n * After the update, the vma will be reinserted using\n * anon_vma_interval_tree_post_update_vma().\n *\n * The entire update must be protected by exclusive mmap_sem and by\n * the root anon_vma's mutex.\n */\nstatic inline void\nanon_vma_interval_tree_pre_update_vma(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc;\n\n\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\tanon_vma_interval_tree_remove(avc, &avc->anon_vma->rb_root);\n}\n\nstatic inline void\nanon_vma_interval_tree_post_update_vma(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc;\n\n\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\tanon_vma_interval_tree_insert(avc, &avc->anon_vma->rb_root);\n}\n\nstatic int find_vma_links(struct mm_struct *mm, unsigned long addr,\n\t\tunsigned long end, struct vm_area_struct **pprev,\n\t\tstruct rb_node ***rb_link, struct rb_node **rb_parent)\n{\n\tstruct rb_node **__rb_link, *__rb_parent, *rb_prev;\n\n\t__rb_link = &mm->mm_rb.rb_node;\n\trb_prev = __rb_parent = NULL;\n\n\twhile (*__rb_link) {\n\t\tstruct vm_area_struct *vma_tmp;\n\n\t\t__rb_parent = *__rb_link;\n\t\tvma_tmp = rb_entry(__rb_parent, struct vm_area_struct, vm_rb);\n\n\t\tif (vma_tmp->vm_end > addr) {\n\t\t\t/* Fail if an existing vma overlaps the area */\n\t\t\tif (vma_tmp->vm_start < end)\n\t\t\t\treturn -ENOMEM;\n\t\t\t__rb_link = &__rb_parent->rb_left;\n\t\t} else {\n\t\t\trb_prev = __rb_parent;\n\t\t\t__rb_link = &__rb_parent->rb_right;\n\t\t}\n\t}\n\n\t*pprev = NULL;\n\tif (rb_prev)\n\t\t*pprev = rb_entry(rb_prev, struct vm_area_struct, vm_rb);\n\t*rb_link = __rb_link;\n\t*rb_parent = __rb_parent;\n\treturn 0;\n}\n\nstatic unsigned long count_vma_pages_range(struct mm_struct *mm,\n\t\tunsigned long addr, unsigned long end)\n{\n\tunsigned long nr_pages = 0;\n\tstruct vm_area_struct *vma;\n\n\t/* Find first overlaping mapping */\n\tvma = find_vma_intersection(mm, addr, end);\n\tif (!vma)\n\t\treturn 0;\n\n\tnr_pages = (min(end, vma->vm_end) -\n\t\tmax(addr, vma->vm_start)) >> PAGE_SHIFT;\n\n\t/* Iterate over the rest of the overlaps */\n\tfor (vma = vma->vm_next; vma; vma = vma->vm_next) {\n\t\tunsigned long overlap_len;\n\n\t\tif (vma->vm_start > end)\n\t\t\tbreak;\n\n\t\toverlap_len = min(end, vma->vm_end) - vma->vm_start;\n\t\tnr_pages += overlap_len >> PAGE_SHIFT;\n\t}\n\n\treturn nr_pages;\n}\n\nvoid __vma_link_rb(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tstruct rb_node **rb_link, struct rb_node *rb_parent)\n{\n\t/* Update tracking information for the gap following the new vma. */\n\tif (vma->vm_next)\n\t\tvma_gap_update(vma->vm_next);\n\telse\n\t\tmm->highest_vm_end = vm_end_gap(vma);\n\n\t/*\n\t * vma->vm_prev wasn't known when we followed the rbtree to find the\n\t * correct insertion point for that vma. As a result, we could not\n\t * update the vma vm_rb parents rb_subtree_gap values on the way down.\n\t * So, we first insert the vma with a zero rb_subtree_gap value\n\t * (to be consistent with what we did on the way down), and then\n\t * immediately update the gap to the correct value. Finally we\n\t * rebalance the rbtree after all augmented values have been set.\n\t */\n\trb_link_node(&vma->vm_rb, rb_parent, rb_link);\n\tvma->rb_subtree_gap = 0;\n\tvma_gap_update(vma);\n\tvma_rb_insert(vma, &mm->mm_rb);\n}\n\nstatic void __vma_link_file(struct vm_area_struct *vma)\n{\n\tstruct file *file;\n\n\tfile = vma->vm_file;\n\tif (file) {\n\t\tstruct address_space *mapping = file->f_mapping;\n\n\t\tif (vma->vm_flags & VM_DENYWRITE)\n\t\t\tatomic_dec(&file_inode(file)->i_writecount);\n\t\tif (vma->vm_flags & VM_SHARED)\n\t\t\tatomic_inc(&mapping->i_mmap_writable);\n\n\t\tflush_dcache_mmap_lock(mapping);\n\t\tvma_interval_tree_insert(vma, &mapping->i_mmap);\n\t\tflush_dcache_mmap_unlock(mapping);\n\t}\n}\n\nstatic void\n__vma_link(struct mm_struct *mm, struct vm_area_struct *vma,\n\tstruct vm_area_struct *prev, struct rb_node **rb_link,\n\tstruct rb_node *rb_parent)\n{\n\t__vma_link_list(mm, vma, prev, rb_parent);\n\t__vma_link_rb(mm, vma, rb_link, rb_parent);\n}\n\nstatic void vma_link(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\tstruct vm_area_struct *prev, struct rb_node **rb_link,\n\t\t\tstruct rb_node *rb_parent)\n{\n\tstruct address_space *mapping = NULL;\n\n\tif (vma->vm_file) {\n\t\tmapping = vma->vm_file->f_mapping;\n\t\ti_mmap_lock_write(mapping);\n\t}\n\n\t__vma_link(mm, vma, prev, rb_link, rb_parent);\n\t__vma_link_file(vma);\n\n\tif (mapping)\n\t\ti_mmap_unlock_write(mapping);\n\n\tmm->map_count++;\n\tvalidate_mm(mm);\n}\n\n/*\n * Helper for vma_adjust() in the split_vma insert case: insert a vma into the\n * mm's list and rbtree.  It has already been inserted into the interval tree.\n */\nstatic void __insert_vm_struct(struct mm_struct *mm, struct vm_area_struct *vma)\n{\n\tstruct vm_area_struct *prev;\n\tstruct rb_node **rb_link, *rb_parent;\n\n\tif (find_vma_links(mm, vma->vm_start, vma->vm_end,\n\t\t\t   &prev, &rb_link, &rb_parent))\n\t\tBUG();\n\t__vma_link(mm, vma, prev, rb_link, rb_parent);\n\tmm->map_count++;\n}\n\nstatic __always_inline void __vma_unlink_common(struct mm_struct *mm,\n\t\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\t\tstruct vm_area_struct *prev,\n\t\t\t\t\t\tbool has_prev,\n\t\t\t\t\t\tstruct vm_area_struct *ignore)\n{\n\tstruct vm_area_struct *next;\n\n\tvma_rb_erase_ignore(vma, &mm->mm_rb, ignore);\n\tnext = vma->vm_next;\n\tif (has_prev)\n\t\tprev->vm_next = next;\n\telse {\n\t\tprev = vma->vm_prev;\n\t\tif (prev)\n\t\t\tprev->vm_next = next;\n\t\telse\n\t\t\tmm->mmap = next;\n\t}\n\tif (next)\n\t\tnext->vm_prev = prev;\n\n\t/* Kill the cache */\n\tvmacache_invalidate(mm);\n}\n\nstatic inline void __vma_unlink_prev(struct mm_struct *mm,\n\t\t\t\t     struct vm_area_struct *vma,\n\t\t\t\t     struct vm_area_struct *prev)\n{\n\t__vma_unlink_common(mm, vma, prev, true, vma);\n}\n\n/*\n * We cannot adjust vm_start, vm_end, vm_pgoff fields of a vma that\n * is already present in an i_mmap tree without adjusting the tree.\n * The following helper function should be used when such adjustments\n * are necessary.  The \"insert\" vma (if any) is to be inserted\n * before we drop the necessary locks.\n */\nint __vma_adjust(struct vm_area_struct *vma, unsigned long start,\n\tunsigned long end, pgoff_t pgoff, struct vm_area_struct *insert,\n\tstruct vm_area_struct *expand)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *next = vma->vm_next, *orig_vma = vma;\n\tstruct address_space *mapping = NULL;\n\tstruct rb_root_cached *root = NULL;\n\tstruct anon_vma *anon_vma = NULL;\n\tstruct file *file = vma->vm_file;\n\tbool start_changed = false, end_changed = false;\n\tlong adjust_next = 0;\n\tint remove_next = 0;\n\n\tif (next && !insert) {\n\t\tstruct vm_area_struct *exporter = NULL, *importer = NULL;\n\n\t\tif (end >= next->vm_end) {\n\t\t\t/*\n\t\t\t * vma expands, overlapping all the next, and\n\t\t\t * perhaps the one after too (mprotect case 6).\n\t\t\t * The only other cases that gets here are\n\t\t\t * case 1, case 7 and case 8.\n\t\t\t */\n\t\t\tif (next == expand) {\n\t\t\t\t/*\n\t\t\t\t * The only case where we don't expand \"vma\"\n\t\t\t\t * and we expand \"next\" instead is case 8.\n\t\t\t\t */\n\t\t\t\tVM_WARN_ON(end != next->vm_end);\n\t\t\t\t/*\n\t\t\t\t * remove_next == 3 means we're\n\t\t\t\t * removing \"vma\" and that to do so we\n\t\t\t\t * swapped \"vma\" and \"next\".\n\t\t\t\t */\n\t\t\t\tremove_next = 3;\n\t\t\t\tVM_WARN_ON(file != next->vm_file);\n\t\t\t\tswap(vma, next);\n\t\t\t} else {\n\t\t\t\tVM_WARN_ON(expand != vma);\n\t\t\t\t/*\n\t\t\t\t * case 1, 6, 7, remove_next == 2 is case 6,\n\t\t\t\t * remove_next == 1 is case 1 or 7.\n\t\t\t\t */\n\t\t\t\tremove_next = 1 + (end > next->vm_end);\n\t\t\t\tVM_WARN_ON(remove_next == 2 &&\n\t\t\t\t\t   end != next->vm_next->vm_end);\n\t\t\t\tVM_WARN_ON(remove_next == 1 &&\n\t\t\t\t\t   end != next->vm_end);\n\t\t\t\t/* trim end to next, for case 6 first pass */\n\t\t\t\tend = next->vm_end;\n\t\t\t}\n\n\t\t\texporter = next;\n\t\t\timporter = vma;\n\n\t\t\t/*\n\t\t\t * If next doesn't have anon_vma, import from vma after\n\t\t\t * next, if the vma overlaps with it.\n\t\t\t */\n\t\t\tif (remove_next == 2 && !next->anon_vma)\n\t\t\t\texporter = next->vm_next;\n\n\t\t} else if (end > next->vm_start) {\n\t\t\t/*\n\t\t\t * vma expands, overlapping part of the next:\n\t\t\t * mprotect case 5 shifting the boundary up.\n\t\t\t */\n\t\t\tadjust_next = (end - next->vm_start) >> PAGE_SHIFT;\n\t\t\texporter = next;\n\t\t\timporter = vma;\n\t\t\tVM_WARN_ON(expand != importer);\n\t\t} else if (end < vma->vm_end) {\n\t\t\t/*\n\t\t\t * vma shrinks, and !insert tells it's not\n\t\t\t * split_vma inserting another: so it must be\n\t\t\t * mprotect case 4 shifting the boundary down.\n\t\t\t */\n\t\t\tadjust_next = -((vma->vm_end - end) >> PAGE_SHIFT);\n\t\t\texporter = vma;\n\t\t\timporter = next;\n\t\t\tVM_WARN_ON(expand != importer);\n\t\t}\n\n\t\t/*\n\t\t * Easily overlooked: when mprotect shifts the boundary,\n\t\t * make sure the expanding vma has anon_vma set if the\n\t\t * shrinking vma had, to cover any anon pages imported.\n\t\t */\n\t\tif (exporter && exporter->anon_vma && !importer->anon_vma) {\n\t\t\tint error;\n\n\t\t\timporter->anon_vma = exporter->anon_vma;\n\t\t\terror = anon_vma_clone(importer, exporter);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\nagain:\n\tvma_adjust_trans_huge(orig_vma, start, end, adjust_next);\n\n\tif (file) {\n\t\tmapping = file->f_mapping;\n\t\troot = &mapping->i_mmap;\n\t\tuprobe_munmap(vma, vma->vm_start, vma->vm_end);\n\n\t\tif (adjust_next)\n\t\t\tuprobe_munmap(next, next->vm_start, next->vm_end);\n\n\t\ti_mmap_lock_write(mapping);\n\t\tif (insert) {\n\t\t\t/*\n\t\t\t * Put into interval tree now, so instantiated pages\n\t\t\t * are visible to arm/parisc __flush_dcache_page\n\t\t\t * throughout; but we cannot insert into address\n\t\t\t * space until vma start or end is updated.\n\t\t\t */\n\t\t\t__vma_link_file(insert);\n\t\t}\n\t}\n\n\tanon_vma = vma->anon_vma;\n\tif (!anon_vma && adjust_next)\n\t\tanon_vma = next->anon_vma;\n\tif (anon_vma) {\n\t\tVM_WARN_ON(adjust_next && next->anon_vma &&\n\t\t\t   anon_vma != next->anon_vma);\n\t\tanon_vma_lock_write(anon_vma);\n\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\tif (adjust_next)\n\t\t\tanon_vma_interval_tree_pre_update_vma(next);\n\t}\n\n\tif (root) {\n\t\tflush_dcache_mmap_lock(mapping);\n\t\tvma_interval_tree_remove(vma, root);\n\t\tif (adjust_next)\n\t\t\tvma_interval_tree_remove(next, root);\n\t}\n\n\tif (start != vma->vm_start) {\n\t\tvma->vm_start = start;\n\t\tstart_changed = true;\n\t}\n\tif (end != vma->vm_end) {\n\t\tvma->vm_end = end;\n\t\tend_changed = true;\n\t}\n\tvma->vm_pgoff = pgoff;\n\tif (adjust_next) {\n\t\tnext->vm_start += adjust_next << PAGE_SHIFT;\n\t\tnext->vm_pgoff += adjust_next;\n\t}\n\n\tif (root) {\n\t\tif (adjust_next)\n\t\t\tvma_interval_tree_insert(next, root);\n\t\tvma_interval_tree_insert(vma, root);\n\t\tflush_dcache_mmap_unlock(mapping);\n\t}\n\n\tif (remove_next) {\n\t\t/*\n\t\t * vma_merge has merged next into vma, and needs\n\t\t * us to remove next before dropping the locks.\n\t\t */\n\t\tif (remove_next != 3)\n\t\t\t__vma_unlink_prev(mm, next, vma);\n\t\telse\n\t\t\t/*\n\t\t\t * vma is not before next if they've been\n\t\t\t * swapped.\n\t\t\t *\n\t\t\t * pre-swap() next->vm_start was reduced so\n\t\t\t * tell validate_mm_rb to ignore pre-swap()\n\t\t\t * \"next\" (which is stored in post-swap()\n\t\t\t * \"vma\").\n\t\t\t */\n\t\t\t__vma_unlink_common(mm, next, NULL, false, vma);\n\t\tif (file)\n\t\t\t__remove_shared_vm_struct(next, file, mapping);\n\t} else if (insert) {\n\t\t/*\n\t\t * split_vma has split insert from vma, and needs\n\t\t * us to insert it before dropping the locks\n\t\t * (it may either follow vma or precede it).\n\t\t */\n\t\t__insert_vm_struct(mm, insert);\n\t} else {\n\t\tif (start_changed)\n\t\t\tvma_gap_update(vma);\n\t\tif (end_changed) {\n\t\t\tif (!next)\n\t\t\t\tmm->highest_vm_end = vm_end_gap(vma);\n\t\t\telse if (!adjust_next)\n\t\t\t\tvma_gap_update(next);\n\t\t}\n\t}\n\n\tif (anon_vma) {\n\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\tif (adjust_next)\n\t\t\tanon_vma_interval_tree_post_update_vma(next);\n\t\tanon_vma_unlock_write(anon_vma);\n\t}\n\tif (mapping)\n\t\ti_mmap_unlock_write(mapping);\n\n\tif (root) {\n\t\tuprobe_mmap(vma);\n\n\t\tif (adjust_next)\n\t\t\tuprobe_mmap(next);\n\t}\n\n\tif (remove_next) {\n\t\tif (file) {\n\t\t\tuprobe_munmap(next, next->vm_start, next->vm_end);\n\t\t\tfput(file);\n\t\t}\n\t\tif (next->anon_vma)\n\t\t\tanon_vma_merge(vma, next);\n\t\tmm->map_count--;\n\t\tmpol_put(vma_policy(next));\n\t\tvm_area_free(next);\n\t\t/*\n\t\t * In mprotect's case 6 (see comments on vma_merge),\n\t\t * we must remove another next too. It would clutter\n\t\t * up the code too much to do both in one go.\n\t\t */\n\t\tif (remove_next != 3) {\n\t\t\t/*\n\t\t\t * If \"next\" was removed and vma->vm_end was\n\t\t\t * expanded (up) over it, in turn\n\t\t\t * \"next->vm_prev->vm_end\" changed and the\n\t\t\t * \"vma->vm_next\" gap must be updated.\n\t\t\t */\n\t\t\tnext = vma->vm_next;\n\t\t} else {\n\t\t\t/*\n\t\t\t * For the scope of the comment \"next\" and\n\t\t\t * \"vma\" considered pre-swap(): if \"vma\" was\n\t\t\t * removed, next->vm_start was expanded (down)\n\t\t\t * over it and the \"next\" gap must be updated.\n\t\t\t * Because of the swap() the post-swap() \"vma\"\n\t\t\t * actually points to pre-swap() \"next\"\n\t\t\t * (post-swap() \"next\" as opposed is now a\n\t\t\t * dangling pointer).\n\t\t\t */\n\t\t\tnext = vma;\n\t\t}\n\t\tif (remove_next == 2) {\n\t\t\tremove_next = 1;\n\t\t\tend = next->vm_end;\n\t\t\tgoto again;\n\t\t}\n\t\telse if (next)\n\t\t\tvma_gap_update(next);\n\t\telse {\n\t\t\t/*\n\t\t\t * If remove_next == 2 we obviously can't\n\t\t\t * reach this path.\n\t\t\t *\n\t\t\t * If remove_next == 3 we can't reach this\n\t\t\t * path because pre-swap() next is always not\n\t\t\t * NULL. pre-swap() \"next\" is not being\n\t\t\t * removed and its next->vm_end is not altered\n\t\t\t * (and furthermore \"end\" already matches\n\t\t\t * next->vm_end in remove_next == 3).\n\t\t\t *\n\t\t\t * We reach this only in the remove_next == 1\n\t\t\t * case if the \"next\" vma that was removed was\n\t\t\t * the highest vma of the mm. However in such\n\t\t\t * case next->vm_end == \"end\" and the extended\n\t\t\t * \"vma\" has vma->vm_end == next->vm_end so\n\t\t\t * mm->highest_vm_end doesn't need any update\n\t\t\t * in remove_next == 1 case.\n\t\t\t */\n\t\t\tVM_WARN_ON(mm->highest_vm_end != vm_end_gap(vma));\n\t\t}\n\t}\n\tif (insert && file)\n\t\tuprobe_mmap(insert);\n\n\tvalidate_mm(mm);\n\n\treturn 0;\n}\n\n/*\n * If the vma has a ->close operation then the driver probably needs to release\n * per-vma resources, so we don't attempt to merge those.\n */\nstatic inline int is_mergeable_vma(struct vm_area_struct *vma,\n\t\t\t\tstruct file *file, unsigned long vm_flags,\n\t\t\t\tstruct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\t/*\n\t * VM_SOFTDIRTY should not prevent from VMA merging, if we\n\t * match the flags but dirty bit -- the caller should mark\n\t * merged VMA as dirty. If dirty bit won't be excluded from\n\t * comparison, we increase pressue on the memory system forcing\n\t * the kernel to generate new VMAs when old one could be\n\t * extended instead.\n\t */\n\tif ((vma->vm_flags ^ vm_flags) & ~VM_SOFTDIRTY)\n\t\treturn 0;\n\tif (vma->vm_file != file)\n\t\treturn 0;\n\tif (vma->vm_ops && vma->vm_ops->close)\n\t\treturn 0;\n\tif (!is_mergeable_vm_userfaultfd_ctx(vma, vm_userfaultfd_ctx))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic inline int is_mergeable_anon_vma(struct anon_vma *anon_vma1,\n\t\t\t\t\tstruct anon_vma *anon_vma2,\n\t\t\t\t\tstruct vm_area_struct *vma)\n{\n\t/*\n\t * The list_is_singular() test is to avoid merging VMA cloned from\n\t * parents. This can improve scalability caused by anon_vma lock.\n\t */\n\tif ((!anon_vma1 || !anon_vma2) && (!vma ||\n\t\tlist_is_singular(&vma->anon_vma_chain)))\n\t\treturn 1;\n\treturn anon_vma1 == anon_vma2;\n}\n\n/*\n * Return true if we can merge this (vm_flags,anon_vma,file,vm_pgoff)\n * in front of (at a lower virtual address and file offset than) the vma.\n *\n * We cannot merge two vmas if they have differently assigned (non-NULL)\n * anon_vmas, nor if same anon_vma is assigned but offsets incompatible.\n *\n * We don't check here for the merged mmap wrapping around the end of pagecache\n * indices (16TB on ia32) because do_mmap_pgoff() does not permit mmap's which\n * wrap, nor mmaps which cover the final page at index -1UL.\n */\nstatic int\ncan_vma_merge_before(struct vm_area_struct *vma, unsigned long vm_flags,\n\t\t     struct anon_vma *anon_vma, struct file *file,\n\t\t     pgoff_t vm_pgoff,\n\t\t     struct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\tif (is_mergeable_vma(vma, file, vm_flags, vm_userfaultfd_ctx) &&\n\t    is_mergeable_anon_vma(anon_vma, vma->anon_vma, vma)) {\n\t\tif (vma->vm_pgoff == vm_pgoff)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * Return true if we can merge this (vm_flags,anon_vma,file,vm_pgoff)\n * beyond (at a higher virtual address and file offset than) the vma.\n *\n * We cannot merge two vmas if they have differently assigned (non-NULL)\n * anon_vmas, nor if same anon_vma is assigned but offsets incompatible.\n */\nstatic int\ncan_vma_merge_after(struct vm_area_struct *vma, unsigned long vm_flags,\n\t\t    struct anon_vma *anon_vma, struct file *file,\n\t\t    pgoff_t vm_pgoff,\n\t\t    struct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\tif (is_mergeable_vma(vma, file, vm_flags, vm_userfaultfd_ctx) &&\n\t    is_mergeable_anon_vma(anon_vma, vma->anon_vma, vma)) {\n\t\tpgoff_t vm_pglen;\n\t\tvm_pglen = vma_pages(vma);\n\t\tif (vma->vm_pgoff + vm_pglen == vm_pgoff)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * Given a mapping request (addr,end,vm_flags,file,pgoff), figure out\n * whether that can be merged with its predecessor or its successor.\n * Or both (it neatly fills a hole).\n *\n * In most cases - when called for mmap, brk or mremap - [addr,end) is\n * certain not to be mapped by the time vma_merge is called; but when\n * called for mprotect, it is certain to be already mapped (either at\n * an offset within prev, or at the start of next), and the flags of\n * this area are about to be changed to vm_flags - and the no-change\n * case has already been eliminated.\n *\n * The following mprotect cases have to be considered, where AAAA is\n * the area passed down from mprotect_fixup, never extending beyond one\n * vma, PPPPPP is the prev vma specified, and NNNNNN the next vma after:\n *\n *     AAAA             AAAA                AAAA          AAAA\n *    PPPPPPNNNNNN    PPPPPPNNNNNN    PPPPPPNNNNNN    PPPPNNNNXXXX\n *    cannot merge    might become    might become    might become\n *                    PPNNNNNNNNNN    PPPPPPPPPPNN    PPPPPPPPPPPP 6 or\n *    mmap, brk or    case 4 below    case 5 below    PPPPPPPPXXXX 7 or\n *    mremap move:                                    PPPPXXXXXXXX 8\n *        AAAA\n *    PPPP    NNNN    PPPPPPPPPPPP    PPPPPPPPNNNN    PPPPNNNNNNNN\n *    might become    case 1 below    case 2 below    case 3 below\n *\n * It is important for case 8 that the the vma NNNN overlapping the\n * region AAAA is never going to extended over XXXX. Instead XXXX must\n * be extended in region AAAA and NNNN must be removed. This way in\n * all cases where vma_merge succeeds, the moment vma_adjust drops the\n * rmap_locks, the properties of the merged vma will be already\n * correct for the whole merged range. Some of those properties like\n * vm_page_prot/vm_flags may be accessed by rmap_walks and they must\n * be correct for the whole merged range immediately after the\n * rmap_locks are released. Otherwise if XXXX would be removed and\n * NNNN would be extended over the XXXX range, remove_migration_ptes\n * or other rmap walkers (if working on addresses beyond the \"end\"\n * parameter) may establish ptes with the wrong permissions of NNNN\n * instead of the right permissions of XXXX.\n */\nstruct vm_area_struct *vma_merge(struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *prev, unsigned long addr,\n\t\t\tunsigned long end, unsigned long vm_flags,\n\t\t\tstruct anon_vma *anon_vma, struct file *file,\n\t\t\tpgoff_t pgoff, struct mempolicy *policy,\n\t\t\tstruct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\tpgoff_t pglen = (end - addr) >> PAGE_SHIFT;\n\tstruct vm_area_struct *area, *next;\n\tint err;\n\n\t/*\n\t * We later require that vma->vm_flags == vm_flags,\n\t * so this tests vma->vm_flags & VM_SPECIAL, too.\n\t */\n\tif (vm_flags & VM_SPECIAL)\n\t\treturn NULL;\n\n\tif (prev)\n\t\tnext = prev->vm_next;\n\telse\n\t\tnext = mm->mmap;\n\tarea = next;\n\tif (area && area->vm_end == end)\t\t/* cases 6, 7, 8 */\n\t\tnext = next->vm_next;\n\n\t/* verify some invariant that must be enforced by the caller */\n\tVM_WARN_ON(prev && addr <= prev->vm_start);\n\tVM_WARN_ON(area && end > area->vm_end);\n\tVM_WARN_ON(addr >= end);\n\n\t/*\n\t * Can it merge with the predecessor?\n\t */\n\tif (prev && prev->vm_end == addr &&\n\t\t\tmpol_equal(vma_policy(prev), policy) &&\n\t\t\tcan_vma_merge_after(prev, vm_flags,\n\t\t\t\t\t    anon_vma, file, pgoff,\n\t\t\t\t\t    vm_userfaultfd_ctx)) {\n\t\t/*\n\t\t * OK, it can.  Can we now merge in the successor as well?\n\t\t */\n\t\tif (next && end == next->vm_start &&\n\t\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t\t     anon_vma, file,\n\t\t\t\t\t\t     pgoff+pglen,\n\t\t\t\t\t\t     vm_userfaultfd_ctx) &&\n\t\t\t\tis_mergeable_anon_vma(prev->anon_vma,\n\t\t\t\t\t\t      next->anon_vma, NULL)) {\n\t\t\t\t\t\t\t/* cases 1, 6 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t next->vm_end, prev->vm_pgoff, NULL,\n\t\t\t\t\t prev);\n\t\t} else\t\t\t\t\t/* cases 2, 5, 7 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t end, prev->vm_pgoff, NULL, prev);\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(prev, vm_flags);\n\t\treturn prev;\n\t}\n\n\t/*\n\t * Can this new request be merged in front of next?\n\t */\n\tif (next && end == next->vm_start &&\n\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t     anon_vma, file, pgoff+pglen,\n\t\t\t\t\t     vm_userfaultfd_ctx)) {\n\t\tif (prev && addr < prev->vm_end)\t/* case 4 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t addr, prev->vm_pgoff, NULL, next);\n\t\telse {\t\t\t\t\t/* cases 3, 8 */\n\t\t\terr = __vma_adjust(area, addr, next->vm_end,\n\t\t\t\t\t next->vm_pgoff - pglen, NULL, next);\n\t\t\t/*\n\t\t\t * In case 3 area is already equal to next and\n\t\t\t * this is a noop, but in case 8 \"area\" has\n\t\t\t * been removed and next was expanded over it.\n\t\t\t */\n\t\t\tarea = next;\n\t\t}\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(area, vm_flags);\n\t\treturn area;\n\t}\n\n\treturn NULL;\n}\n\n/*\n * Rough compatbility check to quickly see if it's even worth looking\n * at sharing an anon_vma.\n *\n * They need to have the same vm_file, and the flags can only differ\n * in things that mprotect may change.\n *\n * NOTE! The fact that we share an anon_vma doesn't _have_ to mean that\n * we can merge the two vma's. For example, we refuse to merge a vma if\n * there is a vm_ops->close() function, because that indicates that the\n * driver is doing some kind of reference counting. But that doesn't\n * really matter for the anon_vma sharing case.\n */\nstatic int anon_vma_compatible(struct vm_area_struct *a, struct vm_area_struct *b)\n{\n\treturn a->vm_end == b->vm_start &&\n\t\tmpol_equal(vma_policy(a), vma_policy(b)) &&\n\t\ta->vm_file == b->vm_file &&\n\t\t!((a->vm_flags ^ b->vm_flags) & ~(VM_READ|VM_WRITE|VM_EXEC|VM_SOFTDIRTY)) &&\n\t\tb->vm_pgoff == a->vm_pgoff + ((b->vm_start - a->vm_start) >> PAGE_SHIFT);\n}\n\n/*\n * Do some basic sanity checking to see if we can re-use the anon_vma\n * from 'old'. The 'a'/'b' vma's are in VM order - one of them will be\n * the same as 'old', the other will be the new one that is trying\n * to share the anon_vma.\n *\n * NOTE! This runs with mm_sem held for reading, so it is possible that\n * the anon_vma of 'old' is concurrently in the process of being set up\n * by another page fault trying to merge _that_. But that's ok: if it\n * is being set up, that automatically means that it will be a singleton\n * acceptable for merging, so we can do all of this optimistically. But\n * we do that READ_ONCE() to make sure that we never re-load the pointer.\n *\n * IOW: that the \"list_is_singular()\" test on the anon_vma_chain only\n * matters for the 'stable anon_vma' case (ie the thing we want to avoid\n * is to return an anon_vma that is \"complex\" due to having gone through\n * a fork).\n *\n * We also make sure that the two vma's are compatible (adjacent,\n * and with the same memory policies). That's all stable, even with just\n * a read lock on the mm_sem.\n */\nstatic struct anon_vma *reusable_anon_vma(struct vm_area_struct *old, struct vm_area_struct *a, struct vm_area_struct *b)\n{\n\tif (anon_vma_compatible(a, b)) {\n\t\tstruct anon_vma *anon_vma = READ_ONCE(old->anon_vma);\n\n\t\tif (anon_vma && list_is_singular(&old->anon_vma_chain))\n\t\t\treturn anon_vma;\n\t}\n\treturn NULL;\n}\n\n/*\n * find_mergeable_anon_vma is used by anon_vma_prepare, to check\n * neighbouring vmas for a suitable anon_vma, before it goes off\n * to allocate a new anon_vma.  It checks because a repetitive\n * sequence of mprotects and faults may otherwise lead to distinct\n * anon_vmas being allocated, preventing vma merge in subsequent\n * mprotect.\n */\nstruct anon_vma *find_mergeable_anon_vma(struct vm_area_struct *vma)\n{\n\tstruct anon_vma *anon_vma;\n\tstruct vm_area_struct *near;\n\n\tnear = vma->vm_next;\n\tif (!near)\n\t\tgoto try_prev;\n\n\tanon_vma = reusable_anon_vma(near, vma, near);\n\tif (anon_vma)\n\t\treturn anon_vma;\ntry_prev:\n\tnear = vma->vm_prev;\n\tif (!near)\n\t\tgoto none;\n\n\tanon_vma = reusable_anon_vma(near, near, vma);\n\tif (anon_vma)\n\t\treturn anon_vma;\nnone:\n\t/*\n\t * There's no absolute need to look only at touching neighbours:\n\t * we could search further afield for \"compatible\" anon_vmas.\n\t * But it would probably just be a waste of time searching,\n\t * or lead to too many vmas hanging off the same anon_vma.\n\t * We're trying to allow mprotect remerging later on,\n\t * not trying to minimize memory used for anon_vmas.\n\t */\n\treturn NULL;\n}\n\n/*\n * If a hint addr is less than mmap_min_addr change hint to be as\n * low as possible but still greater than mmap_min_addr\n */\nstatic inline unsigned long round_hint_to_min(unsigned long hint)\n{\n\thint &= PAGE_MASK;\n\tif (((void *)hint != NULL) &&\n\t    (hint < mmap_min_addr))\n\t\treturn PAGE_ALIGN(mmap_min_addr);\n\treturn hint;\n}\n\nstatic inline int mlock_future_check(struct mm_struct *mm,\n\t\t\t\t     unsigned long flags,\n\t\t\t\t     unsigned long len)\n{\n\tunsigned long locked, lock_limit;\n\n\t/*  mlock MCL_FUTURE? */\n\tif (flags & VM_LOCKED) {\n\t\tlocked = len >> PAGE_SHIFT;\n\t\tlocked += mm->locked_vm;\n\t\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\t\tlock_limit >>= PAGE_SHIFT;\n\t\tif (locked > lock_limit && !capable(CAP_IPC_LOCK))\n\t\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}\n\nstatic inline u64 file_mmap_size_max(struct file *file, struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn MAX_LFS_FILESIZE;\n\n\tif (S_ISBLK(inode->i_mode))\n\t\treturn MAX_LFS_FILESIZE;\n\n\t/* Special \"we do even unsigned file positions\" case */\n\tif (file->f_mode & FMODE_UNSIGNED_OFFSET)\n\t\treturn 0;\n\n\t/* Yes, random drivers might want more. But I'm tired of buggy drivers */\n\treturn ULONG_MAX;\n}\n\nstatic inline bool file_mmap_ok(struct file *file, struct inode *inode,\n\t\t\t\tunsigned long pgoff, unsigned long len)\n{\n\tu64 maxsize = file_mmap_size_max(file, inode);\n\n\tif (maxsize && len > maxsize)\n\t\treturn false;\n\tmaxsize -= len;\n\tif (pgoff > maxsize >> PAGE_SHIFT)\n\t\treturn false;\n\treturn true;\n}\n\n/*\n * The caller must hold down_write(&current->mm->mmap_sem).\n */\nunsigned long do_mmap(struct file *file, unsigned long addr,\n\t\t\tunsigned long len, unsigned long prot,\n\t\t\tunsigned long flags, vm_flags_t vm_flags,\n\t\t\tunsigned long pgoff, unsigned long *populate,\n\t\t\tstruct list_head *uf)\n{\n\tstruct mm_struct *mm = current->mm;\n\tint pkey = 0;\n\n\t*populate = 0;\n\n\tif (!len)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Does the application expect PROT_READ to imply PROT_EXEC?\n\t *\n\t * (the exception is when the underlying filesystem is noexec\n\t *  mounted, in which case we dont add PROT_EXEC.)\n\t */\n\tif ((prot & PROT_READ) && (current->personality & READ_IMPLIES_EXEC))\n\t\tif (!(file && path_noexec(&file->f_path)))\n\t\t\tprot |= PROT_EXEC;\n\n\t/* force arch specific MAP_FIXED handling in get_unmapped_area */\n\tif (flags & MAP_FIXED_NOREPLACE)\n\t\tflags |= MAP_FIXED;\n\n\tif (!(flags & MAP_FIXED))\n\t\taddr = round_hint_to_min(addr);\n\n\t/* Careful about overflows.. */\n\tlen = PAGE_ALIGN(len);\n\tif (!len)\n\t\treturn -ENOMEM;\n\n\t/* offset overflow? */\n\tif ((pgoff + (len >> PAGE_SHIFT)) < pgoff)\n\t\treturn -EOVERFLOW;\n\n\t/* Too many mappings? */\n\tif (mm->map_count > sysctl_max_map_count)\n\t\treturn -ENOMEM;\n\n\t/* Obtain the address to map to. we verify (or select) it and ensure\n\t * that it represents a valid section of the address space.\n\t */\n\taddr = get_unmapped_area(file, addr, len, pgoff, flags);\n\tif (offset_in_page(addr))\n\t\treturn addr;\n\n\tif (flags & MAP_FIXED_NOREPLACE) {\n\t\tstruct vm_area_struct *vma = find_vma(mm, addr);\n\n\t\tif (vma && vma->vm_start < addr + len)\n\t\t\treturn -EEXIST;\n\t}\n\n\tif (prot == PROT_EXEC) {\n\t\tpkey = execute_only_pkey(mm);\n\t\tif (pkey < 0)\n\t\t\tpkey = 0;\n\t}\n\n\t/* Do simple checking here so the lower-level routines won't have\n\t * to. we assume access permissions have been handled by the open\n\t * of the memory object, so we don't do any here.\n\t */\n\tvm_flags |= calc_vm_prot_bits(prot, pkey) | calc_vm_flag_bits(flags) |\n\t\t\tmm->def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;\n\n\tif (flags & MAP_LOCKED)\n\t\tif (!can_do_mlock())\n\t\t\treturn -EPERM;\n\n\tif (mlock_future_check(mm, vm_flags, len))\n\t\treturn -EAGAIN;\n\n\tif (file) {\n\t\tstruct inode *inode = file_inode(file);\n\t\tunsigned long flags_mask;\n\n\t\tif (!file_mmap_ok(file, inode, pgoff, len))\n\t\t\treturn -EOVERFLOW;\n\n\t\tflags_mask = LEGACY_MAP_MASK | file->f_op->mmap_supported_flags;\n\n\t\tswitch (flags & MAP_TYPE) {\n\t\tcase MAP_SHARED:\n\t\t\t/*\n\t\t\t * Force use of MAP_SHARED_VALIDATE with non-legacy\n\t\t\t * flags. E.g. MAP_SYNC is dangerous to use with\n\t\t\t * MAP_SHARED as you don't know which consistency model\n\t\t\t * you will get. We silently ignore unsupported flags\n\t\t\t * with MAP_SHARED to preserve backward compatibility.\n\t\t\t */\n\t\t\tflags &= LEGACY_MAP_MASK;\n\t\t\t/* fall through */\n\t\tcase MAP_SHARED_VALIDATE:\n\t\t\tif (flags & ~flags_mask)\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\tif ((prot&PROT_WRITE) && !(file->f_mode&FMODE_WRITE))\n\t\t\t\treturn -EACCES;\n\n\t\t\t/*\n\t\t\t * Make sure we don't allow writing to an append-only\n\t\t\t * file..\n\t\t\t */\n\t\t\tif (IS_APPEND(inode) && (file->f_mode & FMODE_WRITE))\n\t\t\t\treturn -EACCES;\n\n\t\t\t/*\n\t\t\t * Make sure there are no mandatory locks on the file.\n\t\t\t */\n\t\t\tif (locks_verify_locked(file))\n\t\t\t\treturn -EAGAIN;\n\n\t\t\tvm_flags |= VM_SHARED | VM_MAYSHARE;\n\t\t\tif (!(file->f_mode & FMODE_WRITE))\n\t\t\t\tvm_flags &= ~(VM_MAYWRITE | VM_SHARED);\n\n\t\t\t/* fall through */\n\t\tcase MAP_PRIVATE:\n\t\t\tif (!(file->f_mode & FMODE_READ))\n\t\t\t\treturn -EACCES;\n\t\t\tif (path_noexec(&file->f_path)) {\n\t\t\t\tif (vm_flags & VM_EXEC)\n\t\t\t\t\treturn -EPERM;\n\t\t\t\tvm_flags &= ~VM_MAYEXEC;\n\t\t\t}\n\n\t\t\tif (!file->f_op->mmap)\n\t\t\t\treturn -ENODEV;\n\t\t\tif (vm_flags & (VM_GROWSDOWN|VM_GROWSUP))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tswitch (flags & MAP_TYPE) {\n\t\tcase MAP_SHARED:\n\t\t\tif (vm_flags & (VM_GROWSDOWN|VM_GROWSUP))\n\t\t\t\treturn -EINVAL;\n\t\t\t/*\n\t\t\t * Ignore pgoff.\n\t\t\t */\n\t\t\tpgoff = 0;\n\t\t\tvm_flags |= VM_SHARED | VM_MAYSHARE;\n\t\t\tbreak;\n\t\tcase MAP_PRIVATE:\n\t\t\t/*\n\t\t\t * Set pgoff according to addr for anon_vma.\n\t\t\t */\n\t\t\tpgoff = addr >> PAGE_SHIFT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * Set 'VM_NORESERVE' if we should not account for the\n\t * memory use of this mapping.\n\t */\n\tif (flags & MAP_NORESERVE) {\n\t\t/* We honor MAP_NORESERVE if allowed to overcommit */\n\t\tif (sysctl_overcommit_memory != OVERCOMMIT_NEVER)\n\t\t\tvm_flags |= VM_NORESERVE;\n\n\t\t/* hugetlb applies strict overcommit unless MAP_NORESERVE */\n\t\tif (file && is_file_hugepages(file))\n\t\t\tvm_flags |= VM_NORESERVE;\n\t}\n\n\taddr = mmap_region(file, addr, len, vm_flags, pgoff, uf);\n\tif (!IS_ERR_VALUE(addr) &&\n\t    ((vm_flags & VM_LOCKED) ||\n\t     (flags & (MAP_POPULATE | MAP_NONBLOCK)) == MAP_POPULATE))\n\t\t*populate = len;\n\treturn addr;\n}\n\nunsigned long ksys_mmap_pgoff(unsigned long addr, unsigned long len,\n\t\t\t      unsigned long prot, unsigned long flags,\n\t\t\t      unsigned long fd, unsigned long pgoff)\n{\n\tstruct file *file = NULL;\n\tunsigned long retval;\n\n\tif (!(flags & MAP_ANONYMOUS)) {\n\t\taudit_mmap_fd(fd, flags);\n\t\tfile = fget(fd);\n\t\tif (!file)\n\t\t\treturn -EBADF;\n\t\tif (is_file_hugepages(file))\n\t\t\tlen = ALIGN(len, huge_page_size(hstate_file(file)));\n\t\tretval = -EINVAL;\n\t\tif (unlikely(flags & MAP_HUGETLB && !is_file_hugepages(file)))\n\t\t\tgoto out_fput;\n\t} else if (flags & MAP_HUGETLB) {\n\t\tstruct user_struct *user = NULL;\n\t\tstruct hstate *hs;\n\n\t\ths = hstate_sizelog((flags >> MAP_HUGE_SHIFT) & MAP_HUGE_MASK);\n\t\tif (!hs)\n\t\t\treturn -EINVAL;\n\n\t\tlen = ALIGN(len, huge_page_size(hs));\n\t\t/*\n\t\t * VM_NORESERVE is used because the reservations will be\n\t\t * taken when vm_ops->mmap() is called\n\t\t * A dummy user value is used because we are not locking\n\t\t * memory so no accounting is necessary\n\t\t */\n\t\tfile = hugetlb_file_setup(HUGETLB_ANON_FILE, len,\n\t\t\t\tVM_NORESERVE,\n\t\t\t\t&user, HUGETLB_ANONHUGE_INODE,\n\t\t\t\t(flags >> MAP_HUGE_SHIFT) & MAP_HUGE_MASK);\n\t\tif (IS_ERR(file))\n\t\t\treturn PTR_ERR(file);\n\t}\n\n\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n\n\tretval = vm_mmap_pgoff(file, addr, len, prot, flags, pgoff);\nout_fput:\n\tif (file)\n\t\tfput(file);\n\treturn retval;\n}\n\nSYSCALL_DEFINE6(mmap_pgoff, unsigned long, addr, unsigned long, len,\n\t\tunsigned long, prot, unsigned long, flags,\n\t\tunsigned long, fd, unsigned long, pgoff)\n{\n\treturn ksys_mmap_pgoff(addr, len, prot, flags, fd, pgoff);\n}\n\n#ifdef __ARCH_WANT_SYS_OLD_MMAP\nstruct mmap_arg_struct {\n\tunsigned long addr;\n\tunsigned long len;\n\tunsigned long prot;\n\tunsigned long flags;\n\tunsigned long fd;\n\tunsigned long offset;\n};\n\nSYSCALL_DEFINE1(old_mmap, struct mmap_arg_struct __user *, arg)\n{\n\tstruct mmap_arg_struct a;\n\n\tif (copy_from_user(&a, arg, sizeof(a)))\n\t\treturn -EFAULT;\n\tif (offset_in_page(a.offset))\n\t\treturn -EINVAL;\n\n\treturn ksys_mmap_pgoff(a.addr, a.len, a.prot, a.flags, a.fd,\n\t\t\t       a.offset >> PAGE_SHIFT);\n}\n#endif /* __ARCH_WANT_SYS_OLD_MMAP */\n\n/*\n * Some shared mappigns will want the pages marked read-only\n * to track write events. If so, we'll downgrade vm_page_prot\n * to the private version (using protection_map[] without the\n * VM_SHARED bit).\n */\nint vma_wants_writenotify(struct vm_area_struct *vma, pgprot_t vm_page_prot)\n{\n\tvm_flags_t vm_flags = vma->vm_flags;\n\tconst struct vm_operations_struct *vm_ops = vma->vm_ops;\n\n\t/* If it was private or non-writable, the write bit is already clear */\n\tif ((vm_flags & (VM_WRITE|VM_SHARED)) != ((VM_WRITE|VM_SHARED)))\n\t\treturn 0;\n\n\t/* The backer wishes to know when pages are first written to? */\n\tif (vm_ops && (vm_ops->page_mkwrite || vm_ops->pfn_mkwrite))\n\t\treturn 1;\n\n\t/* The open routine did something to the protections that pgprot_modify\n\t * won't preserve? */\n\tif (pgprot_val(vm_page_prot) !=\n\t    pgprot_val(vm_pgprot_modify(vm_page_prot, vm_flags)))\n\t\treturn 0;\n\n\t/* Do we need to track softdirty? */\n\tif (IS_ENABLED(CONFIG_MEM_SOFT_DIRTY) && !(vm_flags & VM_SOFTDIRTY))\n\t\treturn 1;\n\n\t/* Specialty mapping? */\n\tif (vm_flags & VM_PFNMAP)\n\t\treturn 0;\n\n\t/* Can the mapping track the dirty pages? */\n\treturn vma->vm_file && vma->vm_file->f_mapping &&\n\t\tmapping_cap_account_dirty(vma->vm_file->f_mapping);\n}\n\n/*\n * We account for memory if it's a private writeable mapping,\n * not hugepages and VM_NORESERVE wasn't set.\n */\nstatic inline int accountable_mapping(struct file *file, vm_flags_t vm_flags)\n{\n\t/*\n\t * hugetlb has its own accounting separate from the core VM\n\t * VM_HUGETLB may not be set yet so we cannot check for that flag.\n\t */\n\tif (file && is_file_hugepages(file))\n\t\treturn 0;\n\n\treturn (vm_flags & (VM_NORESERVE | VM_SHARED | VM_WRITE)) == VM_WRITE;\n}\n\nunsigned long mmap_region(struct file *file, unsigned long addr,\n\t\tunsigned long len, vm_flags_t vm_flags, unsigned long pgoff,\n\t\tstruct list_head *uf)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma, *prev;\n\tint error;\n\tstruct rb_node **rb_link, *rb_parent;\n\tunsigned long charged = 0;\n\n\t/* Check against address space limit. */\n\tif (!may_expand_vm(mm, vm_flags, len >> PAGE_SHIFT)) {\n\t\tunsigned long nr_pages;\n\n\t\t/*\n\t\t * MAP_FIXED may remove pages of mappings that intersects with\n\t\t * requested mapping. Account for the pages it would unmap.\n\t\t */\n\t\tnr_pages = count_vma_pages_range(mm, addr, addr + len);\n\n\t\tif (!may_expand_vm(mm, vm_flags,\n\t\t\t\t\t(len >> PAGE_SHIFT) - nr_pages))\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Clear old maps */\n\twhile (find_vma_links(mm, addr, addr + len, &prev, &rb_link,\n\t\t\t      &rb_parent)) {\n\t\tif (do_munmap(mm, addr, len, uf))\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * Private writable mapping: check memory availability\n\t */\n\tif (accountable_mapping(file, vm_flags)) {\n\t\tcharged = len >> PAGE_SHIFT;\n\t\tif (security_vm_enough_memory_mm(mm, charged))\n\t\t\treturn -ENOMEM;\n\t\tvm_flags |= VM_ACCOUNT;\n\t}\n\n\t/*\n\t * Can we just expand an old mapping?\n\t */\n\tvma = vma_merge(mm, prev, addr, addr + len, vm_flags,\n\t\t\tNULL, file, pgoff, NULL, NULL_VM_UFFD_CTX);\n\tif (vma)\n\t\tgoto out;\n\n\t/*\n\t * Determine the object being mapped and call the appropriate\n\t * specific mapper. the address has already been validated, but\n\t * not unmapped, but the maps are removed from the list.\n\t */\n\tvma = vm_area_alloc(mm);\n\tif (!vma) {\n\t\terror = -ENOMEM;\n\t\tgoto unacct_error;\n\t}\n\n\tvma->vm_start = addr;\n\tvma->vm_end = addr + len;\n\tvma->vm_flags = vm_flags;\n\tvma->vm_page_prot = vm_get_page_prot(vm_flags);\n\tvma->vm_pgoff = pgoff;\n\n\tif (file) {\n\t\tif (vm_flags & VM_DENYWRITE) {\n\t\t\terror = deny_write_access(file);\n\t\t\tif (error)\n\t\t\t\tgoto free_vma;\n\t\t}\n\t\tif (vm_flags & VM_SHARED) {\n\t\t\terror = mapping_map_writable(file->f_mapping);\n\t\t\tif (error)\n\t\t\t\tgoto allow_write_and_free_vma;\n\t\t}\n\n\t\t/* ->mmap() can change vma->vm_file, but must guarantee that\n\t\t * vma_link() below can deny write-access if VM_DENYWRITE is set\n\t\t * and map writably if VM_SHARED is set. This usually means the\n\t\t * new file must not have been exposed to user-space, yet.\n\t\t */\n\t\tvma->vm_file = get_file(file);\n\t\terror = call_mmap(file, vma);\n\t\tif (error)\n\t\t\tgoto unmap_and_free_vma;\n\n\t\t/* Can addr have changed??\n\t\t *\n\t\t * Answer: Yes, several device drivers can do it in their\n\t\t *         f_op->mmap method. -DaveM\n\t\t * Bug: If addr is changed, prev, rb_link, rb_parent should\n\t\t *      be updated for vma_link()\n\t\t */\n\t\tWARN_ON_ONCE(addr != vma->vm_start);\n\n\t\taddr = vma->vm_start;\n\t\tvm_flags = vma->vm_flags;\n\t} else if (vm_flags & VM_SHARED) {\n\t\terror = shmem_zero_setup(vma);\n\t\tif (error)\n\t\t\tgoto free_vma;\n\t} else {\n\t\tvma_set_anonymous(vma);\n\t}\n\n\tvma_link(mm, vma, prev, rb_link, rb_parent);\n\t/* Once vma denies write, undo our temporary denial count */\n\tif (file) {\n\t\tif (vm_flags & VM_SHARED)\n\t\t\tmapping_unmap_writable(file->f_mapping);\n\t\tif (vm_flags & VM_DENYWRITE)\n\t\t\tallow_write_access(file);\n\t}\n\tfile = vma->vm_file;\nout:\n\tperf_event_mmap(vma);\n\n\tvm_stat_account(mm, vm_flags, len >> PAGE_SHIFT);\n\tif (vm_flags & VM_LOCKED) {\n\t\tif ((vm_flags & VM_SPECIAL) || vma_is_dax(vma) ||\n\t\t\t\t\tis_vm_hugetlb_page(vma) ||\n\t\t\t\t\tvma == get_gate_vma(current->mm))\n\t\t\tvma->vm_flags &= VM_LOCKED_CLEAR_MASK;\n\t\telse\n\t\t\tmm->locked_vm += (len >> PAGE_SHIFT);\n\t}\n\n\tif (file)\n\t\tuprobe_mmap(vma);\n\n\t/*\n\t * New (or expanded) vma always get soft dirty status.\n\t * Otherwise user-space soft-dirty page tracker won't\n\t * be able to distinguish situation when vma area unmapped,\n\t * then new mapped in-place (which must be aimed as\n\t * a completely new data area).\n\t */\n\tvma->vm_flags |= VM_SOFTDIRTY;\n\n\tvma_set_page_prot(vma);\n\n\treturn addr;\n\nunmap_and_free_vma:\n\tvma->vm_file = NULL;\n\tfput(file);\n\n\t/* Undo any partial mapping done by a device driver. */\n\tunmap_region(mm, vma, prev, vma->vm_start, vma->vm_end);\n\tcharged = 0;\n\tif (vm_flags & VM_SHARED)\n\t\tmapping_unmap_writable(file->f_mapping);\nallow_write_and_free_vma:\n\tif (vm_flags & VM_DENYWRITE)\n\t\tallow_write_access(file);\nfree_vma:\n\tvm_area_free(vma);\nunacct_error:\n\tif (charged)\n\t\tvm_unacct_memory(charged);\n\treturn error;\n}\n\nunsigned long unmapped_area(struct vm_unmapped_area_info *info)\n{\n\t/*\n\t * We implement the search by looking for an rbtree node that\n\t * immediately follows a suitable gap. That is,\n\t * - gap_start = vma->vm_prev->vm_end <= info->high_limit - length;\n\t * - gap_end   = vma->vm_start        >= info->low_limit  + length;\n\t * - gap_end - gap_start >= length\n\t */\n\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tunsigned long length, low_limit, high_limit, gap_start, gap_end;\n\n\t/* Adjust search length to account for worst case alignment overhead */\n\tlength = info->length + info->align_mask;\n\tif (length < info->length)\n\t\treturn -ENOMEM;\n\n\t/* Adjust search limits by the desired length */\n\tif (info->high_limit < length)\n\t\treturn -ENOMEM;\n\thigh_limit = info->high_limit - length;\n\n\tif (info->low_limit > high_limit)\n\t\treturn -ENOMEM;\n\tlow_limit = info->low_limit + length;\n\n\t/* Check if rbtree root looks promising */\n\tif (RB_EMPTY_ROOT(&mm->mm_rb))\n\t\tgoto check_highest;\n\tvma = rb_entry(mm->mm_rb.rb_node, struct vm_area_struct, vm_rb);\n\tif (vma->rb_subtree_gap < length)\n\t\tgoto check_highest;\n\n\twhile (true) {\n\t\t/* Visit left subtree if it looks promising */\n\t\tgap_end = vm_start_gap(vma);\n\t\tif (gap_end >= low_limit && vma->vm_rb.rb_left) {\n\t\t\tstruct vm_area_struct *left =\n\t\t\t\trb_entry(vma->vm_rb.rb_left,\n\t\t\t\t\t struct vm_area_struct, vm_rb);\n\t\t\tif (left->rb_subtree_gap >= length) {\n\t\t\t\tvma = left;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tgap_start = vma->vm_prev ? vm_end_gap(vma->vm_prev) : 0;\ncheck_current:\n\t\t/* Check if current node has a suitable gap */\n\t\tif (gap_start > high_limit)\n\t\t\treturn -ENOMEM;\n\t\tif (gap_end >= low_limit &&\n\t\t    gap_end > gap_start && gap_end - gap_start >= length)\n\t\t\tgoto found;\n\n\t\t/* Visit right subtree if it looks promising */\n\t\tif (vma->vm_rb.rb_right) {\n\t\t\tstruct vm_area_struct *right =\n\t\t\t\trb_entry(vma->vm_rb.rb_right,\n\t\t\t\t\t struct vm_area_struct, vm_rb);\n\t\t\tif (right->rb_subtree_gap >= length) {\n\t\t\t\tvma = right;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* Go back up the rbtree to find next candidate node */\n\t\twhile (true) {\n\t\t\tstruct rb_node *prev = &vma->vm_rb;\n\t\t\tif (!rb_parent(prev))\n\t\t\t\tgoto check_highest;\n\t\t\tvma = rb_entry(rb_parent(prev),\n\t\t\t\t       struct vm_area_struct, vm_rb);\n\t\t\tif (prev == vma->vm_rb.rb_left) {\n\t\t\t\tgap_start = vm_end_gap(vma->vm_prev);\n\t\t\t\tgap_end = vm_start_gap(vma);\n\t\t\t\tgoto check_current;\n\t\t\t}\n\t\t}\n\t}\n\ncheck_highest:\n\t/* Check highest gap, which does not precede any rbtree node */\n\tgap_start = mm->highest_vm_end;\n\tgap_end = ULONG_MAX;  /* Only for VM_BUG_ON below */\n\tif (gap_start > high_limit)\n\t\treturn -ENOMEM;\n\nfound:\n\t/* We found a suitable gap. Clip it with the original low_limit. */\n\tif (gap_start < info->low_limit)\n\t\tgap_start = info->low_limit;\n\n\t/* Adjust gap address to the desired alignment */\n\tgap_start += (info->align_offset - gap_start) & info->align_mask;\n\n\tVM_BUG_ON(gap_start + info->length > info->high_limit);\n\tVM_BUG_ON(gap_start + info->length > gap_end);\n\treturn gap_start;\n}\n\nunsigned long unmapped_area_topdown(struct vm_unmapped_area_info *info)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tunsigned long length, low_limit, high_limit, gap_start, gap_end;\n\n\t/* Adjust search length to account for worst case alignment overhead */\n\tlength = info->length + info->align_mask;\n\tif (length < info->length)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Adjust search limits by the desired length.\n\t * See implementation comment at top of unmapped_area().\n\t */\n\tgap_end = info->high_limit;\n\tif (gap_end < length)\n\t\treturn -ENOMEM;\n\thigh_limit = gap_end - length;\n\n\tif (info->low_limit > high_limit)\n\t\treturn -ENOMEM;\n\tlow_limit = info->low_limit + length;\n\n\t/* Check highest gap, which does not precede any rbtree node */\n\tgap_start = mm->highest_vm_end;\n\tif (gap_start <= high_limit)\n\t\tgoto found_highest;\n\n\t/* Check if rbtree root looks promising */\n\tif (RB_EMPTY_ROOT(&mm->mm_rb))\n\t\treturn -ENOMEM;\n\tvma = rb_entry(mm->mm_rb.rb_node, struct vm_area_struct, vm_rb);\n\tif (vma->rb_subtree_gap < length)\n\t\treturn -ENOMEM;\n\n\twhile (true) {\n\t\t/* Visit right subtree if it looks promising */\n\t\tgap_start = vma->vm_prev ? vm_end_gap(vma->vm_prev) : 0;\n\t\tif (gap_start <= high_limit && vma->vm_rb.rb_right) {\n\t\t\tstruct vm_area_struct *right =\n\t\t\t\trb_entry(vma->vm_rb.rb_right,\n\t\t\t\t\t struct vm_area_struct, vm_rb);\n\t\t\tif (right->rb_subtree_gap >= length) {\n\t\t\t\tvma = right;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\ncheck_current:\n\t\t/* Check if current node has a suitable gap */\n\t\tgap_end = vm_start_gap(vma);\n\t\tif (gap_end < low_limit)\n\t\t\treturn -ENOMEM;\n\t\tif (gap_start <= high_limit &&\n\t\t    gap_end > gap_start && gap_end - gap_start >= length)\n\t\t\tgoto found;\n\n\t\t/* Visit left subtree if it looks promising */\n\t\tif (vma->vm_rb.rb_left) {\n\t\t\tstruct vm_area_struct *left =\n\t\t\t\trb_entry(vma->vm_rb.rb_left,\n\t\t\t\t\t struct vm_area_struct, vm_rb);\n\t\t\tif (left->rb_subtree_gap >= length) {\n\t\t\t\tvma = left;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* Go back up the rbtree to find next candidate node */\n\t\twhile (true) {\n\t\t\tstruct rb_node *prev = &vma->vm_rb;\n\t\t\tif (!rb_parent(prev))\n\t\t\t\treturn -ENOMEM;\n\t\t\tvma = rb_entry(rb_parent(prev),\n\t\t\t\t       struct vm_area_struct, vm_rb);\n\t\t\tif (prev == vma->vm_rb.rb_right) {\n\t\t\t\tgap_start = vma->vm_prev ?\n\t\t\t\t\tvm_end_gap(vma->vm_prev) : 0;\n\t\t\t\tgoto check_current;\n\t\t\t}\n\t\t}\n\t}\n\nfound:\n\t/* We found a suitable gap. Clip it with the original high_limit. */\n\tif (gap_end > info->high_limit)\n\t\tgap_end = info->high_limit;\n\nfound_highest:\n\t/* Compute highest gap address at the desired alignment */\n\tgap_end -= info->length;\n\tgap_end -= (gap_end - info->align_offset) & info->align_mask;\n\n\tVM_BUG_ON(gap_end < info->low_limit);\n\tVM_BUG_ON(gap_end < gap_start);\n\treturn gap_end;\n}\n\n\n#ifndef arch_get_mmap_end\n#define arch_get_mmap_end(addr)\t(TASK_SIZE)\n#endif\n\n#ifndef arch_get_mmap_base\n#define arch_get_mmap_base(addr, base) (base)\n#endif\n\n/* Get an address range which is currently unmapped.\n * For shmat() with addr=0.\n *\n * Ugly calling convention alert:\n * Return value with the low bits set means error value,\n * ie\n *\tif (ret & ~PAGE_MASK)\n *\t\terror = ret;\n *\n * This function \"knows\" that -ENOMEM has the bits set.\n */\n#ifndef HAVE_ARCH_UNMAPPED_AREA\nunsigned long\narch_get_unmapped_area(struct file *filp, unsigned long addr,\n\t\tunsigned long len, unsigned long pgoff, unsigned long flags)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma, *prev;\n\tstruct vm_unmapped_area_info info;\n\tconst unsigned long mmap_end = arch_get_mmap_end(addr);\n\n\tif (len > mmap_end - mmap_min_addr)\n\t\treturn -ENOMEM;\n\n\tif (flags & MAP_FIXED)\n\t\treturn addr;\n\n\tif (addr) {\n\t\taddr = PAGE_ALIGN(addr);\n\t\tvma = find_vma_prev(mm, addr, &prev);\n\t\tif (mmap_end - len >= addr && addr >= mmap_min_addr &&\n\t\t    (!vma || addr + len <= vm_start_gap(vma)) &&\n\t\t    (!prev || addr >= vm_end_gap(prev)))\n\t\t\treturn addr;\n\t}\n\n\tinfo.flags = 0;\n\tinfo.length = len;\n\tinfo.low_limit = mm->mmap_base;\n\tinfo.high_limit = mmap_end;\n\tinfo.align_mask = 0;\n\treturn vm_unmapped_area(&info);\n}\n#endif\n\n/*\n * This mmap-allocator allocates new areas top-down from below the\n * stack's low limit (the base):\n */\n#ifndef HAVE_ARCH_UNMAPPED_AREA_TOPDOWN\nunsigned long\narch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,\n\t\t\t  const unsigned long len, const unsigned long pgoff,\n\t\t\t  const unsigned long flags)\n{\n\tstruct vm_area_struct *vma, *prev;\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long addr = addr0;\n\tstruct vm_unmapped_area_info info;\n\tconst unsigned long mmap_end = arch_get_mmap_end(addr);\n\n\t/* requested length too big for entire address space */\n\tif (len > mmap_end - mmap_min_addr)\n\t\treturn -ENOMEM;\n\n\tif (flags & MAP_FIXED)\n\t\treturn addr;\n\n\t/* requesting a specific address */\n\tif (addr) {\n\t\taddr = PAGE_ALIGN(addr);\n\t\tvma = find_vma_prev(mm, addr, &prev);\n\t\tif (mmap_end - len >= addr && addr >= mmap_min_addr &&\n\t\t\t\t(!vma || addr + len <= vm_start_gap(vma)) &&\n\t\t\t\t(!prev || addr >= vm_end_gap(prev)))\n\t\t\treturn addr;\n\t}\n\n\tinfo.flags = VM_UNMAPPED_AREA_TOPDOWN;\n\tinfo.length = len;\n\tinfo.low_limit = max(PAGE_SIZE, mmap_min_addr);\n\tinfo.high_limit = arch_get_mmap_base(addr, mm->mmap_base);\n\tinfo.align_mask = 0;\n\taddr = vm_unmapped_area(&info);\n\n\t/*\n\t * A failed mmap() very likely causes application failure,\n\t * so fall back to the bottom-up function here. This scenario\n\t * can happen with large stack limits and large mmap()\n\t * allocations.\n\t */\n\tif (offset_in_page(addr)) {\n\t\tVM_BUG_ON(addr != -ENOMEM);\n\t\tinfo.flags = 0;\n\t\tinfo.low_limit = TASK_UNMAPPED_BASE;\n\t\tinfo.high_limit = mmap_end;\n\t\taddr = vm_unmapped_area(&info);\n\t}\n\n\treturn addr;\n}\n#endif\n\nunsigned long\nget_unmapped_area(struct file *file, unsigned long addr, unsigned long len,\n\t\tunsigned long pgoff, unsigned long flags)\n{\n\tunsigned long (*get_area)(struct file *, unsigned long,\n\t\t\t\t  unsigned long, unsigned long, unsigned long);\n\n\tunsigned long error = arch_mmap_check(addr, len, flags);\n\tif (error)\n\t\treturn error;\n\n\t/* Careful about overflows.. */\n\tif (len > TASK_SIZE)\n\t\treturn -ENOMEM;\n\n\tget_area = current->mm->get_unmapped_area;\n\tif (file) {\n\t\tif (file->f_op->get_unmapped_area)\n\t\t\tget_area = file->f_op->get_unmapped_area;\n\t} else if (flags & MAP_SHARED) {\n\t\t/*\n\t\t * mmap_region() will call shmem_zero_setup() to create a file,\n\t\t * so use shmem's get_unmapped_area in case it can be huge.\n\t\t * do_mmap_pgoff() will clear pgoff, so match alignment.\n\t\t */\n\t\tpgoff = 0;\n\t\tget_area = shmem_get_unmapped_area;\n\t}\n\n\taddr = get_area(file, addr, len, pgoff, flags);\n\tif (IS_ERR_VALUE(addr))\n\t\treturn addr;\n\n\tif (addr > TASK_SIZE - len)\n\t\treturn -ENOMEM;\n\tif (offset_in_page(addr))\n\t\treturn -EINVAL;\n\n\terror = security_mmap_addr(addr);\n\treturn error ? error : addr;\n}\n\nEXPORT_SYMBOL(get_unmapped_area);\n\n/* Look up the first VMA which satisfies  addr < vm_end,  NULL if none. */\nstruct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct rb_node *rb_node;\n\tstruct vm_area_struct *vma;\n\n\t/* Check the cache first. */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\trb_node = mm->mm_rb.rb_node;\n\n\twhile (rb_node) {\n\t\tstruct vm_area_struct *tmp;\n\n\t\ttmp = rb_entry(rb_node, struct vm_area_struct, vm_rb);\n\n\t\tif (tmp->vm_end > addr) {\n\t\t\tvma = tmp;\n\t\t\tif (tmp->vm_start <= addr)\n\t\t\t\tbreak;\n\t\t\trb_node = rb_node->rb_left;\n\t\t} else\n\t\t\trb_node = rb_node->rb_right;\n\t}\n\n\tif (vma)\n\t\tvmacache_update(addr, vma);\n\treturn vma;\n}\n\nEXPORT_SYMBOL(find_vma);\n\n/*\n * Same as find_vma, but also return a pointer to the previous VMA in *pprev.\n */\nstruct vm_area_struct *\nfind_vma_prev(struct mm_struct *mm, unsigned long addr,\n\t\t\tstruct vm_area_struct **pprev)\n{\n\tstruct vm_area_struct *vma;\n\n\tvma = find_vma(mm, addr);\n\tif (vma) {\n\t\t*pprev = vma->vm_prev;\n\t} else {\n\t\tstruct rb_node *rb_node = mm->mm_rb.rb_node;\n\t\t*pprev = NULL;\n\t\twhile (rb_node) {\n\t\t\t*pprev = rb_entry(rb_node, struct vm_area_struct, vm_rb);\n\t\t\trb_node = rb_node->rb_right;\n\t\t}\n\t}\n\treturn vma;\n}\n\n/*\n * Verify that the stack growth is acceptable and\n * update accounting. This is shared with both the\n * grow-up and grow-down cases.\n */\nstatic int acct_stack_growth(struct vm_area_struct *vma,\n\t\t\t     unsigned long size, unsigned long grow)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long new_start;\n\n\t/* address space limit tests */\n\tif (!may_expand_vm(mm, vma->vm_flags, grow))\n\t\treturn -ENOMEM;\n\n\t/* Stack limit test */\n\tif (size > rlimit(RLIMIT_STACK))\n\t\treturn -ENOMEM;\n\n\t/* mlock limit tests */\n\tif (vma->vm_flags & VM_LOCKED) {\n\t\tunsigned long locked;\n\t\tunsigned long limit;\n\t\tlocked = mm->locked_vm + grow;\n\t\tlimit = rlimit(RLIMIT_MEMLOCK);\n\t\tlimit >>= PAGE_SHIFT;\n\t\tif (locked > limit && !capable(CAP_IPC_LOCK))\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Check to ensure the stack will not grow into a hugetlb-only region */\n\tnew_start = (vma->vm_flags & VM_GROWSUP) ? vma->vm_start :\n\t\t\tvma->vm_end - size;\n\tif (is_hugepage_only_range(vma->vm_mm, new_start, size))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Overcommit..  This must be the final test, as it will\n\t * update security statistics.\n\t */\n\tif (security_vm_enough_memory_mm(mm, grow))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n#if defined(CONFIG_STACK_GROWSUP) || defined(CONFIG_IA64)\n/*\n * PA-RISC uses this for its stack; IA64 for its Register Backing Store.\n * vma is the last one with address > vma->vm_end.  Have to extend vma.\n */\nint expand_upwards(struct vm_area_struct *vma, unsigned long address)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *next;\n\tunsigned long gap_addr;\n\tint error = 0;\n\n\tif (!(vma->vm_flags & VM_GROWSUP))\n\t\treturn -EFAULT;\n\n\t/* Guard against exceeding limits of the address space. */\n\taddress &= PAGE_MASK;\n\tif (address >= (TASK_SIZE & PAGE_MASK))\n\t\treturn -ENOMEM;\n\taddress += PAGE_SIZE;\n\n\t/* Enforce stack_guard_gap */\n\tgap_addr = address + stack_guard_gap;\n\n\t/* Guard against overflow */\n\tif (gap_addr < address || gap_addr > TASK_SIZE)\n\t\tgap_addr = TASK_SIZE;\n\n\tnext = vma->vm_next;\n\tif (next && next->vm_start < gap_addr &&\n\t\t\t(next->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) {\n\t\tif (!(next->vm_flags & VM_GROWSUP))\n\t\t\treturn -ENOMEM;\n\t\t/* Check that both stack segments have the same anon_vma? */\n\t}\n\n\t/* We must make sure the anon_vma is allocated. */\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * vma->vm_start/vm_end cannot change under us because the caller\n\t * is required to hold the mmap_sem in read mode.  We need the\n\t * anon_vma lock to serialize against concurrent expand_stacks.\n\t */\n\tanon_vma_lock_write(vma->anon_vma);\n\n\t/* Somebody else might have raced and expanded it already */\n\tif (address > vma->vm_end) {\n\t\tunsigned long size, grow;\n\n\t\tsize = address - vma->vm_start;\n\t\tgrow = (address - vma->vm_end) >> PAGE_SHIFT;\n\n\t\terror = -ENOMEM;\n\t\tif (vma->vm_pgoff + (size >> PAGE_SHIFT) >= vma->vm_pgoff) {\n\t\t\terror = acct_stack_growth(vma, size, grow);\n\t\t\tif (!error) {\n\t\t\t\t/*\n\t\t\t\t * vma_gap_update() doesn't support concurrent\n\t\t\t\t * updates, but we only hold a shared mmap_sem\n\t\t\t\t * lock here, so we need to protect against\n\t\t\t\t * concurrent vma expansions.\n\t\t\t\t * anon_vma_lock_write() doesn't help here, as\n\t\t\t\t * we don't guarantee that all growable vmas\n\t\t\t\t * in a mm share the same root anon vma.\n\t\t\t\t * So, we reuse mm->page_table_lock to guard\n\t\t\t\t * against concurrent vma expansions.\n\t\t\t\t */\n\t\t\t\tspin_lock(&mm->page_table_lock);\n\t\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\t\tmm->locked_vm += grow;\n\t\t\t\tvm_stat_account(mm, vma->vm_flags, grow);\n\t\t\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\t\t\tvma->vm_end = address;\n\t\t\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\t\t\tif (vma->vm_next)\n\t\t\t\t\tvma_gap_update(vma->vm_next);\n\t\t\t\telse\n\t\t\t\t\tmm->highest_vm_end = vm_end_gap(vma);\n\t\t\t\tspin_unlock(&mm->page_table_lock);\n\n\t\t\t\tperf_event_mmap(vma);\n\t\t\t}\n\t\t}\n\t}\n\tanon_vma_unlock_write(vma->anon_vma);\n\tkhugepaged_enter_vma_merge(vma, vma->vm_flags);\n\tvalidate_mm(mm);\n\treturn error;\n}\n#endif /* CONFIG_STACK_GROWSUP || CONFIG_IA64 */\n\n/*\n * vma is the first one with address < vma->vm_start.  Have to extend vma.\n */\nint expand_downwards(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long address)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *prev;\n\tint error;\n\n\taddress &= PAGE_MASK;\n\terror = security_mmap_addr(address);\n\tif (error)\n\t\treturn error;\n\n\t/* Enforce stack_guard_gap */\n\tprev = vma->vm_prev;\n\t/* Check that both stack segments have the same anon_vma? */\n\tif (prev && !(prev->vm_flags & VM_GROWSDOWN) &&\n\t\t\t(prev->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) {\n\t\tif (address - prev->vm_end < stack_guard_gap)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* We must make sure the anon_vma is allocated. */\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * vma->vm_start/vm_end cannot change under us because the caller\n\t * is required to hold the mmap_sem in read mode.  We need the\n\t * anon_vma lock to serialize against concurrent expand_stacks.\n\t */\n\tanon_vma_lock_write(vma->anon_vma);\n\n\t/* Somebody else might have raced and expanded it already */\n\tif (address < vma->vm_start) {\n\t\tunsigned long size, grow;\n\n\t\tsize = vma->vm_end - address;\n\t\tgrow = (vma->vm_start - address) >> PAGE_SHIFT;\n\n\t\terror = -ENOMEM;\n\t\tif (grow <= vma->vm_pgoff) {\n\t\t\terror = acct_stack_growth(vma, size, grow);\n\t\t\tif (!error) {\n\t\t\t\t/*\n\t\t\t\t * vma_gap_update() doesn't support concurrent\n\t\t\t\t * updates, but we only hold a shared mmap_sem\n\t\t\t\t * lock here, so we need to protect against\n\t\t\t\t * concurrent vma expansions.\n\t\t\t\t * anon_vma_lock_write() doesn't help here, as\n\t\t\t\t * we don't guarantee that all growable vmas\n\t\t\t\t * in a mm share the same root anon vma.\n\t\t\t\t * So, we reuse mm->page_table_lock to guard\n\t\t\t\t * against concurrent vma expansions.\n\t\t\t\t */\n\t\t\t\tspin_lock(&mm->page_table_lock);\n\t\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\t\tmm->locked_vm += grow;\n\t\t\t\tvm_stat_account(mm, vma->vm_flags, grow);\n\t\t\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\t\t\tvma->vm_start = address;\n\t\t\t\tvma->vm_pgoff -= grow;\n\t\t\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\t\t\tvma_gap_update(vma);\n\t\t\t\tspin_unlock(&mm->page_table_lock);\n\n\t\t\t\tperf_event_mmap(vma);\n\t\t\t}\n\t\t}\n\t}\n\tanon_vma_unlock_write(vma->anon_vma);\n\tkhugepaged_enter_vma_merge(vma, vma->vm_flags);\n\tvalidate_mm(mm);\n\treturn error;\n}\n\n/* enforced gap between the expanding stack and other mappings. */\nunsigned long stack_guard_gap = 256UL<<PAGE_SHIFT;\n\nstatic int __init cmdline_parse_stack_guard_gap(char *p)\n{\n\tunsigned long val;\n\tchar *endptr;\n\n\tval = simple_strtoul(p, &endptr, 10);\n\tif (!*endptr)\n\t\tstack_guard_gap = val << PAGE_SHIFT;\n\n\treturn 0;\n}\n__setup(\"stack_guard_gap=\", cmdline_parse_stack_guard_gap);\n\n#ifdef CONFIG_STACK_GROWSUP\nint expand_stack(struct vm_area_struct *vma, unsigned long address)\n{\n\treturn expand_upwards(vma, address);\n}\n\nstruct vm_area_struct *\nfind_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma, *prev;\n\n\taddr &= PAGE_MASK;\n\tvma = find_vma_prev(mm, addr, &prev);\n\tif (vma && (vma->vm_start <= addr))\n\t\treturn vma;\n\tif (!prev || expand_stack(prev, addr))\n\t\treturn NULL;\n\tif (prev->vm_flags & VM_LOCKED)\n\t\tpopulate_vma_page_range(prev, addr, prev->vm_end, NULL);\n\treturn prev;\n}\n#else\nint expand_stack(struct vm_area_struct *vma, unsigned long address)\n{\n\treturn expand_downwards(vma, address);\n}\n\nstruct vm_area_struct *\nfind_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long start;\n\n\taddr &= PAGE_MASK;\n\tvma = find_vma(mm, addr);\n\tif (!vma)\n\t\treturn NULL;\n\tif (vma->vm_start <= addr)\n\t\treturn vma;\n\tif (!(vma->vm_flags & VM_GROWSDOWN))\n\t\treturn NULL;\n\tstart = vma->vm_start;\n\tif (expand_stack(vma, addr))\n\t\treturn NULL;\n\tif (vma->vm_flags & VM_LOCKED)\n\t\tpopulate_vma_page_range(vma, addr, start, NULL);\n\treturn vma;\n}\n#endif\n\nEXPORT_SYMBOL_GPL(find_extend_vma);\n\n/*\n * Ok - we have the memory areas we should free on the vma list,\n * so release them, and do the vma updates.\n *\n * Called with the mm semaphore held.\n */\nstatic void remove_vma_list(struct mm_struct *mm, struct vm_area_struct *vma)\n{\n\tunsigned long nr_accounted = 0;\n\n\t/* Update high watermark before we lower total_vm */\n\tupdate_hiwater_vm(mm);\n\tdo {\n\t\tlong nrpages = vma_pages(vma);\n\n\t\tif (vma->vm_flags & VM_ACCOUNT)\n\t\t\tnr_accounted += nrpages;\n\t\tvm_stat_account(mm, vma->vm_flags, -nrpages);\n\t\tvma = remove_vma(vma);\n\t} while (vma);\n\tvm_unacct_memory(nr_accounted);\n\tvalidate_mm(mm);\n}\n\n/*\n * Get rid of page table information in the indicated region.\n *\n * Called with the mm semaphore held.\n */\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end)\n{\n\tstruct vm_area_struct *next = prev ? prev->vm_next : mm->mmap;\n\tstruct mmu_gather tlb;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, start, end);\n\tupdate_hiwater_rss(mm);\n\tunmap_vmas(&tlb, vma, start, end);\n\tfree_pgtables(&tlb, vma, prev ? prev->vm_end : FIRST_USER_ADDRESS,\n\t\t\t\t next ? next->vm_start : USER_PGTABLES_CEILING);\n\ttlb_finish_mmu(&tlb, start, end);\n}\n\n/*\n * Create a list of vma's touched by the unmap, removing them from the mm's\n * vma list as we go..\n */\nstatic void\ndetach_vmas_to_be_unmapped(struct mm_struct *mm, struct vm_area_struct *vma,\n\tstruct vm_area_struct *prev, unsigned long end)\n{\n\tstruct vm_area_struct **insertion_point;\n\tstruct vm_area_struct *tail_vma = NULL;\n\n\tinsertion_point = (prev ? &prev->vm_next : &mm->mmap);\n\tvma->vm_prev = NULL;\n\tdo {\n\t\tvma_rb_erase(vma, &mm->mm_rb);\n\t\tmm->map_count--;\n\t\ttail_vma = vma;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\n\t*insertion_point = vma;\n\tif (vma) {\n\t\tvma->vm_prev = prev;\n\t\tvma_gap_update(vma);\n\t} else\n\t\tmm->highest_vm_end = prev ? vm_end_gap(prev) : 0;\n\ttail_vma->vm_next = NULL;\n\n\t/* Kill the cache */\n\tvmacache_invalidate(mm);\n}\n\n/*\n * __split_vma() bypasses sysctl_max_map_count checking.  We use this where it\n * has already been checked or doesn't make sense to fail.\n */\nint __split_vma(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long addr, int new_below)\n{\n\tstruct vm_area_struct *new;\n\tint err;\n\n\tif (vma->vm_ops && vma->vm_ops->split) {\n\t\terr = vma->vm_ops->split(vma, addr);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tnew = vm_area_dup(vma);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (new_below)\n\t\tnew->vm_end = addr;\n\telse {\n\t\tnew->vm_start = addr;\n\t\tnew->vm_pgoff += ((addr - vma->vm_start) >> PAGE_SHIFT);\n\t}\n\n\terr = vma_dup_policy(vma, new);\n\tif (err)\n\t\tgoto out_free_vma;\n\n\terr = anon_vma_clone(new, vma);\n\tif (err)\n\t\tgoto out_free_mpol;\n\n\tif (new->vm_file)\n\t\tget_file(new->vm_file);\n\n\tif (new->vm_ops && new->vm_ops->open)\n\t\tnew->vm_ops->open(new);\n\n\tif (new_below)\n\t\terr = vma_adjust(vma, addr, vma->vm_end, vma->vm_pgoff +\n\t\t\t((addr - new->vm_start) >> PAGE_SHIFT), new);\n\telse\n\t\terr = vma_adjust(vma, vma->vm_start, addr, vma->vm_pgoff, new);\n\n\t/* Success. */\n\tif (!err)\n\t\treturn 0;\n\n\t/* Clean everything up if vma_adjust failed. */\n\tif (new->vm_ops && new->vm_ops->close)\n\t\tnew->vm_ops->close(new);\n\tif (new->vm_file)\n\t\tfput(new->vm_file);\n\tunlink_anon_vmas(new);\n out_free_mpol:\n\tmpol_put(vma_policy(new));\n out_free_vma:\n\tvm_area_free(new);\n\treturn err;\n}\n\n/*\n * Split a vma into two pieces at address 'addr', a new vma is allocated\n * either for the first part or the tail.\n */\nint split_vma(struct mm_struct *mm, struct vm_area_struct *vma,\n\t      unsigned long addr, int new_below)\n{\n\tif (mm->map_count >= sysctl_max_map_count)\n\t\treturn -ENOMEM;\n\n\treturn __split_vma(mm, vma, addr, new_below);\n}\n\n/* Munmap is split into 2 main parts -- this part which finds\n * what needs doing, and the areas themselves, which do the\n * work.  This now handles partial unmappings.\n * Jeremy Fitzhardinge <jeremy@goop.org>\n */\nint __do_munmap(struct mm_struct *mm, unsigned long start, size_t len,\n\t\tstruct list_head *uf, bool downgrade)\n{\n\tunsigned long end;\n\tstruct vm_area_struct *vma, *prev, *last;\n\n\tif ((offset_in_page(start)) || start > TASK_SIZE || len > TASK_SIZE-start)\n\t\treturn -EINVAL;\n\n\tlen = PAGE_ALIGN(len);\n\tif (len == 0)\n\t\treturn -EINVAL;\n\n\t/* Find the first overlapping VMA */\n\tvma = find_vma(mm, start);\n\tif (!vma)\n\t\treturn 0;\n\tprev = vma->vm_prev;\n\t/* we have  start < vma->vm_end  */\n\n\t/* if it doesn't overlap, we have nothing.. */\n\tend = start + len;\n\tif (vma->vm_start >= end)\n\t\treturn 0;\n\n\t/*\n\t * If we need to split any vma, do it now to save pain later.\n\t *\n\t * Note: mremap's move_vma VM_ACCOUNT handling assumes a partially\n\t * unmapped vm_area_struct will remain in use: so lower split_vma\n\t * places tmp vma above, and higher split_vma places tmp vma below.\n\t */\n\tif (start > vma->vm_start) {\n\t\tint error;\n\n\t\t/*\n\t\t * Make sure that map_count on return from munmap() will\n\t\t * not exceed its limit; but let map_count go just above\n\t\t * its limit temporarily, to help free resources as expected.\n\t\t */\n\t\tif (end < vma->vm_end && mm->map_count >= sysctl_max_map_count)\n\t\t\treturn -ENOMEM;\n\n\t\terror = __split_vma(mm, vma, start, 0);\n\t\tif (error)\n\t\t\treturn error;\n\t\tprev = vma;\n\t}\n\n\t/* Does it split the last one? */\n\tlast = find_vma(mm, end);\n\tif (last && end > last->vm_start) {\n\t\tint error = __split_vma(mm, last, end, 1);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tvma = prev ? prev->vm_next : mm->mmap;\n\n\tif (unlikely(uf)) {\n\t\t/*\n\t\t * If userfaultfd_unmap_prep returns an error the vmas\n\t\t * will remain splitted, but userland will get a\n\t\t * highly unexpected error anyway. This is no\n\t\t * different than the case where the first of the two\n\t\t * __split_vma fails, but we don't undo the first\n\t\t * split, despite we could. This is unlikely enough\n\t\t * failure that it's not worth optimizing it for.\n\t\t */\n\t\tint error = userfaultfd_unmap_prep(vma, start, end, uf);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * unlock any mlock()ed ranges before detaching vmas\n\t */\n\tif (mm->locked_vm) {\n\t\tstruct vm_area_struct *tmp = vma;\n\t\twhile (tmp && tmp->vm_start < end) {\n\t\t\tif (tmp->vm_flags & VM_LOCKED) {\n\t\t\t\tmm->locked_vm -= vma_pages(tmp);\n\t\t\t\tmunlock_vma_pages_all(tmp);\n\t\t\t}\n\n\t\t\ttmp = tmp->vm_next;\n\t\t}\n\t}\n\n\t/* Detach vmas from rbtree */\n\tdetach_vmas_to_be_unmapped(mm, vma, prev, end);\n\n\t/*\n\t * mpx unmap needs to be called with mmap_sem held for write.\n\t * It is safe to call it before unmap_region().\n\t */\n\tarch_unmap(mm, vma, start, end);\n\n\tif (downgrade)\n\t\tdowngrade_write(&mm->mmap_sem);\n\n\tunmap_region(mm, vma, prev, start, end);\n\n\t/* Fix up all other VM information */\n\tremove_vma_list(mm, vma);\n\n\treturn downgrade ? 1 : 0;\n}\n\nint do_munmap(struct mm_struct *mm, unsigned long start, size_t len,\n\t      struct list_head *uf)\n{\n\treturn __do_munmap(mm, start, len, uf, false);\n}\n\nstatic int __vm_munmap(unsigned long start, size_t len, bool downgrade)\n{\n\tint ret;\n\tstruct mm_struct *mm = current->mm;\n\tLIST_HEAD(uf);\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tret = __do_munmap(mm, start, len, &uf, downgrade);\n\t/*\n\t * Returning 1 indicates mmap_sem is downgraded.\n\t * But 1 is not legal return value of vm_munmap() and munmap(), reset\n\t * it to 0 before return.\n\t */\n\tif (ret == 1) {\n\t\tup_read(&mm->mmap_sem);\n\t\tret = 0;\n\t} else\n\t\tup_write(&mm->mmap_sem);\n\n\tuserfaultfd_unmap_complete(mm, &uf);\n\treturn ret;\n}\n\nint vm_munmap(unsigned long start, size_t len)\n{\n\treturn __vm_munmap(start, len, false);\n}\nEXPORT_SYMBOL(vm_munmap);\n\nSYSCALL_DEFINE2(munmap, unsigned long, addr, size_t, len)\n{\n\tprofile_munmap(addr);\n\treturn __vm_munmap(addr, len, true);\n}\n\n\n/*\n * Emulation of deprecated remap_file_pages() syscall.\n */\nSYSCALL_DEFINE5(remap_file_pages, unsigned long, start, unsigned long, size,\n\t\tunsigned long, prot, unsigned long, pgoff, unsigned long, flags)\n{\n\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tunsigned long populate = 0;\n\tunsigned long ret = -EINVAL;\n\tstruct file *file;\n\n\tpr_warn_once(\"%s (%d) uses deprecated remap_file_pages() syscall. See Documentation/vm/remap_file_pages.rst.\\n\",\n\t\t     current->comm, current->pid);\n\n\tif (prot)\n\t\treturn ret;\n\tstart = start & PAGE_MASK;\n\tsize = size & PAGE_MASK;\n\n\tif (start + size <= start)\n\t\treturn ret;\n\n\t/* Does pgoff wrap? */\n\tif (pgoff + (size >> PAGE_SHIFT) < pgoff)\n\t\treturn ret;\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tvma = find_vma(mm, start);\n\n\tif (!vma || !(vma->vm_flags & VM_SHARED))\n\t\tgoto out;\n\n\tif (start < vma->vm_start)\n\t\tgoto out;\n\n\tif (start + size > vma->vm_end) {\n\t\tstruct vm_area_struct *next;\n\n\t\tfor (next = vma->vm_next; next; next = next->vm_next) {\n\t\t\t/* hole between vmas ? */\n\t\t\tif (next->vm_start != next->vm_prev->vm_end)\n\t\t\t\tgoto out;\n\n\t\t\tif (next->vm_file != vma->vm_file)\n\t\t\t\tgoto out;\n\n\t\t\tif (next->vm_flags != vma->vm_flags)\n\t\t\t\tgoto out;\n\n\t\t\tif (start + size <= next->vm_end)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!next)\n\t\t\tgoto out;\n\t}\n\n\tprot |= vma->vm_flags & VM_READ ? PROT_READ : 0;\n\tprot |= vma->vm_flags & VM_WRITE ? PROT_WRITE : 0;\n\tprot |= vma->vm_flags & VM_EXEC ? PROT_EXEC : 0;\n\n\tflags &= MAP_NONBLOCK;\n\tflags |= MAP_SHARED | MAP_FIXED | MAP_POPULATE;\n\tif (vma->vm_flags & VM_LOCKED) {\n\t\tstruct vm_area_struct *tmp;\n\t\tflags |= MAP_LOCKED;\n\n\t\t/* drop PG_Mlocked flag for over-mapped range */\n\t\tfor (tmp = vma; tmp->vm_start >= start + size;\n\t\t\t\ttmp = tmp->vm_next) {\n\t\t\t/*\n\t\t\t * Split pmd and munlock page on the border\n\t\t\t * of the range.\n\t\t\t */\n\t\t\tvma_adjust_trans_huge(tmp, start, start + size, 0);\n\n\t\t\tmunlock_vma_pages_range(tmp,\n\t\t\t\t\tmax(tmp->vm_start, start),\n\t\t\t\t\tmin(tmp->vm_end, start + size));\n\t\t}\n\t}\n\n\tfile = get_file(vma->vm_file);\n\tret = do_mmap_pgoff(vma->vm_file, start, size,\n\t\t\tprot, flags, pgoff, &populate, NULL);\n\tfput(file);\nout:\n\tup_write(&mm->mmap_sem);\n\tif (populate)\n\t\tmm_populate(ret, populate);\n\tif (!IS_ERR_VALUE(ret))\n\t\tret = 0;\n\treturn ret;\n}\n\n/*\n *  this is really a simplified \"do_mmap\".  it only handles\n *  anonymous maps.  eventually we may be able to do some\n *  brk-specific accounting here.\n */\nstatic int do_brk_flags(unsigned long addr, unsigned long len, unsigned long flags, struct list_head *uf)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma, *prev;\n\tstruct rb_node **rb_link, *rb_parent;\n\tpgoff_t pgoff = addr >> PAGE_SHIFT;\n\tint error;\n\n\t/* Until we need other flags, refuse anything except VM_EXEC. */\n\tif ((flags & (~VM_EXEC)) != 0)\n\t\treturn -EINVAL;\n\tflags |= VM_DATA_DEFAULT_FLAGS | VM_ACCOUNT | mm->def_flags;\n\n\terror = get_unmapped_area(NULL, addr, len, 0, MAP_FIXED);\n\tif (offset_in_page(error))\n\t\treturn error;\n\n\terror = mlock_future_check(mm, mm->def_flags, len);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Clear old maps.  this also does some error checking for us\n\t */\n\twhile (find_vma_links(mm, addr, addr + len, &prev, &rb_link,\n\t\t\t      &rb_parent)) {\n\t\tif (do_munmap(mm, addr, len, uf))\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Check against address space limits *after* clearing old maps... */\n\tif (!may_expand_vm(mm, flags, len >> PAGE_SHIFT))\n\t\treturn -ENOMEM;\n\n\tif (mm->map_count > sysctl_max_map_count)\n\t\treturn -ENOMEM;\n\n\tif (security_vm_enough_memory_mm(mm, len >> PAGE_SHIFT))\n\t\treturn -ENOMEM;\n\n\t/* Can we just expand an old private anonymous mapping? */\n\tvma = vma_merge(mm, prev, addr, addr + len, flags,\n\t\t\tNULL, NULL, pgoff, NULL, NULL_VM_UFFD_CTX);\n\tif (vma)\n\t\tgoto out;\n\n\t/*\n\t * create a vma struct for an anonymous mapping\n\t */\n\tvma = vm_area_alloc(mm);\n\tif (!vma) {\n\t\tvm_unacct_memory(len >> PAGE_SHIFT);\n\t\treturn -ENOMEM;\n\t}\n\n\tvma_set_anonymous(vma);\n\tvma->vm_start = addr;\n\tvma->vm_end = addr + len;\n\tvma->vm_pgoff = pgoff;\n\tvma->vm_flags = flags;\n\tvma->vm_page_prot = vm_get_page_prot(flags);\n\tvma_link(mm, vma, prev, rb_link, rb_parent);\nout:\n\tperf_event_mmap(vma);\n\tmm->total_vm += len >> PAGE_SHIFT;\n\tmm->data_vm += len >> PAGE_SHIFT;\n\tif (flags & VM_LOCKED)\n\t\tmm->locked_vm += (len >> PAGE_SHIFT);\n\tvma->vm_flags |= VM_SOFTDIRTY;\n\treturn 0;\n}\n\nint vm_brk_flags(unsigned long addr, unsigned long request, unsigned long flags)\n{\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long len;\n\tint ret;\n\tbool populate;\n\tLIST_HEAD(uf);\n\n\tlen = PAGE_ALIGN(request);\n\tif (len < request)\n\t\treturn -ENOMEM;\n\tif (!len)\n\t\treturn 0;\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tret = do_brk_flags(addr, len, flags, &uf);\n\tpopulate = ((mm->def_flags & VM_LOCKED) != 0);\n\tup_write(&mm->mmap_sem);\n\tuserfaultfd_unmap_complete(mm, &uf);\n\tif (populate && !ret)\n\t\tmm_populate(addr, len);\n\treturn ret;\n}\nEXPORT_SYMBOL(vm_brk_flags);\n\nint vm_brk(unsigned long addr, unsigned long len)\n{\n\treturn vm_brk_flags(addr, len, 0);\n}\nEXPORT_SYMBOL(vm_brk);\n\n/* Release all mmaps. */\nvoid exit_mmap(struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tunsigned long nr_accounted = 0;\n\n\t/* mm's last user has gone, and its about to be pulled down */\n\tmmu_notifier_release(mm);\n\n\tif (unlikely(mm_is_oom_victim(mm))) {\n\t\t/*\n\t\t * Manually reap the mm to free as much memory as possible.\n\t\t * Then, as the oom reaper does, set MMF_OOM_SKIP to disregard\n\t\t * this mm from further consideration.  Taking mm->mmap_sem for\n\t\t * write after setting MMF_OOM_SKIP will guarantee that the oom\n\t\t * reaper will not run on this mm again after mmap_sem is\n\t\t * dropped.\n\t\t *\n\t\t * Nothing can be holding mm->mmap_sem here and the above call\n\t\t * to mmu_notifier_release(mm) ensures mmu notifier callbacks in\n\t\t * __oom_reap_task_mm() will not block.\n\t\t *\n\t\t * This needs to be done before calling munlock_vma_pages_all(),\n\t\t * which clears VM_LOCKED, otherwise the oom reaper cannot\n\t\t * reliably test it.\n\t\t */\n\t\t(void)__oom_reap_task_mm(mm);\n\n\t\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\t\tdown_write(&mm->mmap_sem);\n\t\tup_write(&mm->mmap_sem);\n\t}\n\n\tif (mm->locked_vm) {\n\t\tvma = mm->mmap;\n\t\twhile (vma) {\n\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\tmunlock_vma_pages_all(vma);\n\t\t\tvma = vma->vm_next;\n\t\t}\n\t}\n\n\tarch_exit_mmap(mm);\n\n\tvma = mm->mmap;\n\tif (!vma)\t/* Can happen if dup_mmap() received an OOM */\n\t\treturn;\n\n\tlru_add_drain();\n\tflush_cache_mm(mm);\n\ttlb_gather_mmu(&tlb, mm, 0, -1);\n\t/* update_hiwater_rss(mm) here? but nobody should be looking */\n\t/* Use -1 here to ensure all VMAs in the mm are unmapped */\n\tunmap_vmas(&tlb, vma, 0, -1);\n\tfree_pgtables(&tlb, vma, FIRST_USER_ADDRESS, USER_PGTABLES_CEILING);\n\ttlb_finish_mmu(&tlb, 0, -1);\n\n\t/*\n\t * Walk the list again, actually closing and freeing it,\n\t * with preemption enabled, without holding any MM locks.\n\t */\n\twhile (vma) {\n\t\tif (vma->vm_flags & VM_ACCOUNT)\n\t\t\tnr_accounted += vma_pages(vma);\n\t\tvma = remove_vma(vma);\n\t}\n\tvm_unacct_memory(nr_accounted);\n}\n\n/* Insert vm structure into process list sorted by address\n * and into the inode's i_mmap tree.  If vm_file is non-NULL\n * then i_mmap_rwsem is taken here.\n */\nint insert_vm_struct(struct mm_struct *mm, struct vm_area_struct *vma)\n{\n\tstruct vm_area_struct *prev;\n\tstruct rb_node **rb_link, *rb_parent;\n\n\tif (find_vma_links(mm, vma->vm_start, vma->vm_end,\n\t\t\t   &prev, &rb_link, &rb_parent))\n\t\treturn -ENOMEM;\n\tif ((vma->vm_flags & VM_ACCOUNT) &&\n\t     security_vm_enough_memory_mm(mm, vma_pages(vma)))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * The vm_pgoff of a purely anonymous vma should be irrelevant\n\t * until its first write fault, when page's anon_vma and index\n\t * are set.  But now set the vm_pgoff it will almost certainly\n\t * end up with (unless mremap moves it elsewhere before that\n\t * first wfault), so /proc/pid/maps tells a consistent story.\n\t *\n\t * By setting it to reflect the virtual start address of the\n\t * vma, merges and splits can happen in a seamless way, just\n\t * using the existing file pgoff checks and manipulations.\n\t * Similarly in do_mmap_pgoff and in do_brk.\n\t */\n\tif (vma_is_anonymous(vma)) {\n\t\tBUG_ON(vma->anon_vma);\n\t\tvma->vm_pgoff = vma->vm_start >> PAGE_SHIFT;\n\t}\n\n\tvma_link(mm, vma, prev, rb_link, rb_parent);\n\treturn 0;\n}\n\n/*\n * Copy the vma structure to a new location in the same mm,\n * prior to moving page table entries, to effect an mremap move.\n */\nstruct vm_area_struct *copy_vma(struct vm_area_struct **vmap,\n\tunsigned long addr, unsigned long len, pgoff_t pgoff,\n\tbool *need_rmap_locks)\n{\n\tstruct vm_area_struct *vma = *vmap;\n\tunsigned long vma_start = vma->vm_start;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *new_vma, *prev;\n\tstruct rb_node **rb_link, *rb_parent;\n\tbool faulted_in_anon_vma = true;\n\n\t/*\n\t * If anonymous vma has not yet been faulted, update new pgoff\n\t * to match new location, to increase its chance of merging.\n\t */\n\tif (unlikely(vma_is_anonymous(vma) && !vma->anon_vma)) {\n\t\tpgoff = addr >> PAGE_SHIFT;\n\t\tfaulted_in_anon_vma = false;\n\t}\n\n\tif (find_vma_links(mm, addr, addr + len, &prev, &rb_link, &rb_parent))\n\t\treturn NULL;\t/* should never get here */\n\tnew_vma = vma_merge(mm, prev, addr, addr + len, vma->vm_flags,\n\t\t\t    vma->anon_vma, vma->vm_file, pgoff, vma_policy(vma),\n\t\t\t    vma->vm_userfaultfd_ctx);\n\tif (new_vma) {\n\t\t/*\n\t\t * Source vma may have been merged into new_vma\n\t\t */\n\t\tif (unlikely(vma_start >= new_vma->vm_start &&\n\t\t\t     vma_start < new_vma->vm_end)) {\n\t\t\t/*\n\t\t\t * The only way we can get a vma_merge with\n\t\t\t * self during an mremap is if the vma hasn't\n\t\t\t * been faulted in yet and we were allowed to\n\t\t\t * reset the dst vma->vm_pgoff to the\n\t\t\t * destination address of the mremap to allow\n\t\t\t * the merge to happen. mremap must change the\n\t\t\t * vm_pgoff linearity between src and dst vmas\n\t\t\t * (in turn preventing a vma_merge) to be\n\t\t\t * safe. It is only safe to keep the vm_pgoff\n\t\t\t * linear if there are no pages mapped yet.\n\t\t\t */\n\t\t\tVM_BUG_ON_VMA(faulted_in_anon_vma, new_vma);\n\t\t\t*vmap = vma = new_vma;\n\t\t}\n\t\t*need_rmap_locks = (new_vma->vm_pgoff <= vma->vm_pgoff);\n\t} else {\n\t\tnew_vma = vm_area_dup(vma);\n\t\tif (!new_vma)\n\t\t\tgoto out;\n\t\tnew_vma->vm_start = addr;\n\t\tnew_vma->vm_end = addr + len;\n\t\tnew_vma->vm_pgoff = pgoff;\n\t\tif (vma_dup_policy(vma, new_vma))\n\t\t\tgoto out_free_vma;\n\t\tif (anon_vma_clone(new_vma, vma))\n\t\t\tgoto out_free_mempol;\n\t\tif (new_vma->vm_file)\n\t\t\tget_file(new_vma->vm_file);\n\t\tif (new_vma->vm_ops && new_vma->vm_ops->open)\n\t\t\tnew_vma->vm_ops->open(new_vma);\n\t\tvma_link(mm, new_vma, prev, rb_link, rb_parent);\n\t\t*need_rmap_locks = false;\n\t}\n\treturn new_vma;\n\nout_free_mempol:\n\tmpol_put(vma_policy(new_vma));\nout_free_vma:\n\tvm_area_free(new_vma);\nout:\n\treturn NULL;\n}\n\n/*\n * Return true if the calling process may expand its vm space by the passed\n * number of pages\n */\nbool may_expand_vm(struct mm_struct *mm, vm_flags_t flags, unsigned long npages)\n{\n\tif (mm->total_vm + npages > rlimit(RLIMIT_AS) >> PAGE_SHIFT)\n\t\treturn false;\n\n\tif (is_data_mapping(flags) &&\n\t    mm->data_vm + npages > rlimit(RLIMIT_DATA) >> PAGE_SHIFT) {\n\t\t/* Workaround for Valgrind */\n\t\tif (rlimit(RLIMIT_DATA) == 0 &&\n\t\t    mm->data_vm + npages <= rlimit_max(RLIMIT_DATA) >> PAGE_SHIFT)\n\t\t\treturn true;\n\n\t\tpr_warn_once(\"%s (%d): VmData %lu exceed data ulimit %lu. Update limits%s.\\n\",\n\t\t\t     current->comm, current->pid,\n\t\t\t     (mm->data_vm + npages) << PAGE_SHIFT,\n\t\t\t     rlimit(RLIMIT_DATA),\n\t\t\t     ignore_rlimit_data ? \"\" : \" or use boot option ignore_rlimit_data\");\n\n\t\tif (!ignore_rlimit_data)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid vm_stat_account(struct mm_struct *mm, vm_flags_t flags, long npages)\n{\n\tmm->total_vm += npages;\n\n\tif (is_exec_mapping(flags))\n\t\tmm->exec_vm += npages;\n\telse if (is_stack_mapping(flags))\n\t\tmm->stack_vm += npages;\n\telse if (is_data_mapping(flags))\n\t\tmm->data_vm += npages;\n}\n\nstatic vm_fault_t special_mapping_fault(struct vm_fault *vmf);\n\n/*\n * Having a close hook prevents vma merging regardless of flags.\n */\nstatic void special_mapping_close(struct vm_area_struct *vma)\n{\n}\n\nstatic const char *special_mapping_name(struct vm_area_struct *vma)\n{\n\treturn ((struct vm_special_mapping *)vma->vm_private_data)->name;\n}\n\nstatic int special_mapping_mremap(struct vm_area_struct *new_vma)\n{\n\tstruct vm_special_mapping *sm = new_vma->vm_private_data;\n\n\tif (WARN_ON_ONCE(current->mm != new_vma->vm_mm))\n\t\treturn -EFAULT;\n\n\tif (sm->mremap)\n\t\treturn sm->mremap(sm, new_vma);\n\n\treturn 0;\n}\n\nstatic const struct vm_operations_struct special_mapping_vmops = {\n\t.close = special_mapping_close,\n\t.fault = special_mapping_fault,\n\t.mremap = special_mapping_mremap,\n\t.name = special_mapping_name,\n};\n\nstatic const struct vm_operations_struct legacy_special_mapping_vmops = {\n\t.close = special_mapping_close,\n\t.fault = special_mapping_fault,\n};\n\nstatic vm_fault_t special_mapping_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tpgoff_t pgoff;\n\tstruct page **pages;\n\n\tif (vma->vm_ops == &legacy_special_mapping_vmops) {\n\t\tpages = vma->vm_private_data;\n\t} else {\n\t\tstruct vm_special_mapping *sm = vma->vm_private_data;\n\n\t\tif (sm->fault)\n\t\t\treturn sm->fault(sm, vmf->vma, vmf);\n\n\t\tpages = sm->pages;\n\t}\n\n\tfor (pgoff = vmf->pgoff; pgoff && *pages; ++pages)\n\t\tpgoff--;\n\n\tif (*pages) {\n\t\tstruct page *page = *pages;\n\t\tget_page(page);\n\t\tvmf->page = page;\n\t\treturn 0;\n\t}\n\n\treturn VM_FAULT_SIGBUS;\n}\n\nstatic struct vm_area_struct *__install_special_mapping(\n\tstruct mm_struct *mm,\n\tunsigned long addr, unsigned long len,\n\tunsigned long vm_flags, void *priv,\n\tconst struct vm_operations_struct *ops)\n{\n\tint ret;\n\tstruct vm_area_struct *vma;\n\n\tvma = vm_area_alloc(mm);\n\tif (unlikely(vma == NULL))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvma->vm_start = addr;\n\tvma->vm_end = addr + len;\n\n\tvma->vm_flags = vm_flags | mm->def_flags | VM_DONTEXPAND | VM_SOFTDIRTY;\n\tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\n\tvma->vm_ops = ops;\n\tvma->vm_private_data = priv;\n\n\tret = insert_vm_struct(mm, vma);\n\tif (ret)\n\t\tgoto out;\n\n\tvm_stat_account(mm, vma->vm_flags, len >> PAGE_SHIFT);\n\n\tperf_event_mmap(vma);\n\n\treturn vma;\n\nout:\n\tvm_area_free(vma);\n\treturn ERR_PTR(ret);\n}\n\nbool vma_is_special_mapping(const struct vm_area_struct *vma,\n\tconst struct vm_special_mapping *sm)\n{\n\treturn vma->vm_private_data == sm &&\n\t\t(vma->vm_ops == &special_mapping_vmops ||\n\t\t vma->vm_ops == &legacy_special_mapping_vmops);\n}\n\n/*\n * Called with mm->mmap_sem held for writing.\n * Insert a new vma covering the given region, with the given flags.\n * Its pages are supplied by the given array of struct page *.\n * The array can be shorter than len >> PAGE_SHIFT if it's null-terminated.\n * The region past the last page supplied will always produce SIGBUS.\n * The array pointer and the pages it points to are assumed to stay alive\n * for as long as this mapping might exist.\n */\nstruct vm_area_struct *_install_special_mapping(\n\tstruct mm_struct *mm,\n\tunsigned long addr, unsigned long len,\n\tunsigned long vm_flags, const struct vm_special_mapping *spec)\n{\n\treturn __install_special_mapping(mm, addr, len, vm_flags, (void *)spec,\n\t\t\t\t\t&special_mapping_vmops);\n}\n\nint install_special_mapping(struct mm_struct *mm,\n\t\t\t    unsigned long addr, unsigned long len,\n\t\t\t    unsigned long vm_flags, struct page **pages)\n{\n\tstruct vm_area_struct *vma = __install_special_mapping(\n\t\tmm, addr, len, vm_flags, (void *)pages,\n\t\t&legacy_special_mapping_vmops);\n\n\treturn PTR_ERR_OR_ZERO(vma);\n}\n\nstatic DEFINE_MUTEX(mm_all_locks_mutex);\n\nstatic void vm_lock_anon_vma(struct mm_struct *mm, struct anon_vma *anon_vma)\n{\n\tif (!test_bit(0, (unsigned long *) &anon_vma->root->rb_root.rb_root.rb_node)) {\n\t\t/*\n\t\t * The LSB of head.next can't change from under us\n\t\t * because we hold the mm_all_locks_mutex.\n\t\t */\n\t\tdown_write_nest_lock(&anon_vma->root->rwsem, &mm->mmap_sem);\n\t\t/*\n\t\t * We can safely modify head.next after taking the\n\t\t * anon_vma->root->rwsem. If some other vma in this mm shares\n\t\t * the same anon_vma we won't take it again.\n\t\t *\n\t\t * No need of atomic instructions here, head.next\n\t\t * can't change from under us thanks to the\n\t\t * anon_vma->root->rwsem.\n\t\t */\n\t\tif (__test_and_set_bit(0, (unsigned long *)\n\t\t\t\t       &anon_vma->root->rb_root.rb_root.rb_node))\n\t\t\tBUG();\n\t}\n}\n\nstatic void vm_lock_mapping(struct mm_struct *mm, struct address_space *mapping)\n{\n\tif (!test_bit(AS_MM_ALL_LOCKS, &mapping->flags)) {\n\t\t/*\n\t\t * AS_MM_ALL_LOCKS can't change from under us because\n\t\t * we hold the mm_all_locks_mutex.\n\t\t *\n\t\t * Operations on ->flags have to be atomic because\n\t\t * even if AS_MM_ALL_LOCKS is stable thanks to the\n\t\t * mm_all_locks_mutex, there may be other cpus\n\t\t * changing other bitflags in parallel to us.\n\t\t */\n\t\tif (test_and_set_bit(AS_MM_ALL_LOCKS, &mapping->flags))\n\t\t\tBUG();\n\t\tdown_write_nest_lock(&mapping->i_mmap_rwsem, &mm->mmap_sem);\n\t}\n}\n\n/*\n * This operation locks against the VM for all pte/vma/mm related\n * operations that could ever happen on a certain mm. This includes\n * vmtruncate, try_to_unmap, and all page faults.\n *\n * The caller must take the mmap_sem in write mode before calling\n * mm_take_all_locks(). The caller isn't allowed to release the\n * mmap_sem until mm_drop_all_locks() returns.\n *\n * mmap_sem in write mode is required in order to block all operations\n * that could modify pagetables and free pages without need of\n * altering the vma layout. It's also needed in write mode to avoid new\n * anon_vmas to be associated with existing vmas.\n *\n * A single task can't take more than one mm_take_all_locks() in a row\n * or it would deadlock.\n *\n * The LSB in anon_vma->rb_root.rb_node and the AS_MM_ALL_LOCKS bitflag in\n * mapping->flags avoid to take the same lock twice, if more than one\n * vma in this mm is backed by the same anon_vma or address_space.\n *\n * We take locks in following order, accordingly to comment at beginning\n * of mm/rmap.c:\n *   - all hugetlbfs_i_mmap_rwsem_key locks (aka mapping->i_mmap_rwsem for\n *     hugetlb mapping);\n *   - all i_mmap_rwsem locks;\n *   - all anon_vma->rwseml\n *\n * We can take all locks within these types randomly because the VM code\n * doesn't nest them and we protected from parallel mm_take_all_locks() by\n * mm_all_locks_mutex.\n *\n * mm_take_all_locks() and mm_drop_all_locks are expensive operations\n * that may have to take thousand of locks.\n *\n * mm_take_all_locks() can fail if it's interrupted by signals.\n */\nint mm_take_all_locks(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tstruct anon_vma_chain *avc;\n\n\tBUG_ON(down_read_trylock(&mm->mmap_sem));\n\n\tmutex_lock(&mm_all_locks_mutex);\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (signal_pending(current))\n\t\t\tgoto out_unlock;\n\t\tif (vma->vm_file && vma->vm_file->f_mapping &&\n\t\t\t\tis_vm_hugetlb_page(vma))\n\t\t\tvm_lock_mapping(mm, vma->vm_file->f_mapping);\n\t}\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (signal_pending(current))\n\t\t\tgoto out_unlock;\n\t\tif (vma->vm_file && vma->vm_file->f_mapping &&\n\t\t\t\t!is_vm_hugetlb_page(vma))\n\t\t\tvm_lock_mapping(mm, vma->vm_file->f_mapping);\n\t}\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (signal_pending(current))\n\t\t\tgoto out_unlock;\n\t\tif (vma->anon_vma)\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tvm_lock_anon_vma(mm, avc->anon_vma);\n\t}\n\n\treturn 0;\n\nout_unlock:\n\tmm_drop_all_locks(mm);\n\treturn -EINTR;\n}\n\nstatic void vm_unlock_anon_vma(struct anon_vma *anon_vma)\n{\n\tif (test_bit(0, (unsigned long *) &anon_vma->root->rb_root.rb_root.rb_node)) {\n\t\t/*\n\t\t * The LSB of head.next can't change to 0 from under\n\t\t * us because we hold the mm_all_locks_mutex.\n\t\t *\n\t\t * We must however clear the bitflag before unlocking\n\t\t * the vma so the users using the anon_vma->rb_root will\n\t\t * never see our bitflag.\n\t\t *\n\t\t * No need of atomic instructions here, head.next\n\t\t * can't change from under us until we release the\n\t\t * anon_vma->root->rwsem.\n\t\t */\n\t\tif (!__test_and_clear_bit(0, (unsigned long *)\n\t\t\t\t\t  &anon_vma->root->rb_root.rb_root.rb_node))\n\t\t\tBUG();\n\t\tanon_vma_unlock_write(anon_vma);\n\t}\n}\n\nstatic void vm_unlock_mapping(struct address_space *mapping)\n{\n\tif (test_bit(AS_MM_ALL_LOCKS, &mapping->flags)) {\n\t\t/*\n\t\t * AS_MM_ALL_LOCKS can't change to 0 from under us\n\t\t * because we hold the mm_all_locks_mutex.\n\t\t */\n\t\ti_mmap_unlock_write(mapping);\n\t\tif (!test_and_clear_bit(AS_MM_ALL_LOCKS,\n\t\t\t\t\t&mapping->flags))\n\t\t\tBUG();\n\t}\n}\n\n/*\n * The mmap_sem cannot be released by the caller until\n * mm_drop_all_locks() returns.\n */\nvoid mm_drop_all_locks(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tstruct anon_vma_chain *avc;\n\n\tBUG_ON(down_read_trylock(&mm->mmap_sem));\n\tBUG_ON(!mutex_is_locked(&mm_all_locks_mutex));\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->anon_vma)\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tvm_unlock_anon_vma(avc->anon_vma);\n\t\tif (vma->vm_file && vma->vm_file->f_mapping)\n\t\t\tvm_unlock_mapping(vma->vm_file->f_mapping);\n\t}\n\n\tmutex_unlock(&mm_all_locks_mutex);\n}\n\n/*\n * initialise the percpu counter for VM\n */\nvoid __init mmap_init(void)\n{\n\tint ret;\n\n\tret = percpu_counter_init(&vm_committed_as, 0, GFP_KERNEL);\n\tVM_BUG_ON(ret);\n}\n\n/*\n * Initialise sysctl_user_reserve_kbytes.\n *\n * This is intended to prevent a user from starting a single memory hogging\n * process, such that they cannot recover (kill the hog) in OVERCOMMIT_NEVER\n * mode.\n *\n * The default value is min(3% of free memory, 128MB)\n * 128MB is enough to recover with sshd/login, bash, and top/kill.\n */\nstatic int init_user_reserve(void)\n{\n\tunsigned long free_kbytes;\n\n\tfree_kbytes = global_zone_page_state(NR_FREE_PAGES) << (PAGE_SHIFT - 10);\n\n\tsysctl_user_reserve_kbytes = min(free_kbytes / 32, 1UL << 17);\n\treturn 0;\n}\nsubsys_initcall(init_user_reserve);\n\n/*\n * Initialise sysctl_admin_reserve_kbytes.\n *\n * The purpose of sysctl_admin_reserve_kbytes is to allow the sys admin\n * to log in and kill a memory hogging process.\n *\n * Systems with more than 256MB will reserve 8MB, enough to recover\n * with sshd, bash, and top in OVERCOMMIT_GUESS. Smaller systems will\n * only reserve 3% of free pages by default.\n */\nstatic int init_admin_reserve(void)\n{\n\tunsigned long free_kbytes;\n\n\tfree_kbytes = global_zone_page_state(NR_FREE_PAGES) << (PAGE_SHIFT - 10);\n\n\tsysctl_admin_reserve_kbytes = min(free_kbytes / 32, 1UL << 13);\n\treturn 0;\n}\nsubsys_initcall(init_admin_reserve);\n\n/*\n * Reinititalise user and admin reserves if memory is added or removed.\n *\n * The default user reserve max is 128MB, and the default max for the\n * admin reserve is 8MB. These are usually, but not always, enough to\n * enable recovery from a memory hogging process using login/sshd, a shell,\n * and tools like top. It may make sense to increase or even disable the\n * reserve depending on the existence of swap or variations in the recovery\n * tools. So, the admin may have changed them.\n *\n * If memory is added and the reserves have been eliminated or increased above\n * the default max, then we'll trust the admin.\n *\n * If memory is removed and there isn't enough free memory, then we\n * need to reset the reserves.\n *\n * Otherwise keep the reserve set by the admin.\n */\nstatic int reserve_mem_notifier(struct notifier_block *nb,\n\t\t\t     unsigned long action, void *data)\n{\n\tunsigned long tmp, free_kbytes;\n\n\tswitch (action) {\n\tcase MEM_ONLINE:\n\t\t/* Default max is 128MB. Leave alone if modified by operator. */\n\t\ttmp = sysctl_user_reserve_kbytes;\n\t\tif (0 < tmp && tmp < (1UL << 17))\n\t\t\tinit_user_reserve();\n\n\t\t/* Default max is 8MB.  Leave alone if modified by operator. */\n\t\ttmp = sysctl_admin_reserve_kbytes;\n\t\tif (0 < tmp && tmp < (1UL << 13))\n\t\t\tinit_admin_reserve();\n\n\t\tbreak;\n\tcase MEM_OFFLINE:\n\t\tfree_kbytes = global_zone_page_state(NR_FREE_PAGES) << (PAGE_SHIFT - 10);\n\n\t\tif (sysctl_user_reserve_kbytes > free_kbytes) {\n\t\t\tinit_user_reserve();\n\t\t\tpr_info(\"vm.user_reserve_kbytes reset to %lu\\n\",\n\t\t\t\tsysctl_user_reserve_kbytes);\n\t\t}\n\n\t\tif (sysctl_admin_reserve_kbytes > free_kbytes) {\n\t\t\tinit_admin_reserve();\n\t\t\tpr_info(\"vm.admin_reserve_kbytes reset to %lu\\n\",\n\t\t\t\tsysctl_admin_reserve_kbytes);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block reserve_mem_nb = {\n\t.notifier_call = reserve_mem_notifier,\n};\n\nstatic int __meminit init_reserve_notifier(void)\n{\n\tif (register_hotmemory_notifier(&reserve_mem_nb))\n\t\tpr_err(\"Failed registering memory add/remove notifier for admin reserve\\n\");\n\n\treturn 0;\n}\nsubsys_initcall(init_reserve_notifier);\n"], "fixing_code": ["/*\n * mm/mmap.c\n *\n * Written by obz.\n *\n * Address space accounting code\t<alan@lxorguk.ukuu.org.uk>\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/vmacache.h>\n#include <linux/shm.h>\n#include <linux/mman.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/personality.h>\n#include <linux/security.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n#include <linux/mount.h>\n#include <linux/mempolicy.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mmdebug.h>\n#include <linux/perf_event.h>\n#include <linux/audit.h>\n#include <linux/khugepaged.h>\n#include <linux/uprobes.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/notifier.h>\n#include <linux/memory.h>\n#include <linux/printk.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/moduleparam.h>\n#include <linux/pkeys.h>\n#include <linux/oom.h>\n\n#include <linux/uaccess.h>\n#include <asm/cacheflush.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n\n#include \"internal.h\"\n\n#ifndef arch_mmap_check\n#define arch_mmap_check(addr, len, flags)\t(0)\n#endif\n\n#ifdef CONFIG_HAVE_ARCH_MMAP_RND_BITS\nconst int mmap_rnd_bits_min = CONFIG_ARCH_MMAP_RND_BITS_MIN;\nconst int mmap_rnd_bits_max = CONFIG_ARCH_MMAP_RND_BITS_MAX;\nint mmap_rnd_bits __read_mostly = CONFIG_ARCH_MMAP_RND_BITS;\n#endif\n#ifdef CONFIG_HAVE_ARCH_MMAP_RND_COMPAT_BITS\nconst int mmap_rnd_compat_bits_min = CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MIN;\nconst int mmap_rnd_compat_bits_max = CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MAX;\nint mmap_rnd_compat_bits __read_mostly = CONFIG_ARCH_MMAP_RND_COMPAT_BITS;\n#endif\n\nstatic bool ignore_rlimit_data;\ncore_param(ignore_rlimit_data, ignore_rlimit_data, bool, 0644);\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);\n\n/* description of effects of mapping type and prot in current implementation.\n * this is due to the limited x86 page protection hardware.  The expected\n * behavior is in parens:\n *\n * map_type\tprot\n *\t\tPROT_NONE\tPROT_READ\tPROT_WRITE\tPROT_EXEC\n * MAP_SHARED\tr: (no) no\tr: (yes) yes\tr: (no) yes\tr: (no) yes\n *\t\tw: (no) no\tw: (no) no\tw: (yes) yes\tw: (no) no\n *\t\tx: (no) no\tx: (no) yes\tx: (no) yes\tx: (yes) yes\n *\n * MAP_PRIVATE\tr: (no) no\tr: (yes) yes\tr: (no) yes\tr: (no) yes\n *\t\tw: (no) no\tw: (no) no\tw: (copy) copy\tw: (no) no\n *\t\tx: (no) no\tx: (no) yes\tx: (no) yes\tx: (yes) yes\n *\n * On arm64, PROT_EXEC has the following behaviour for both MAP_SHARED and\n * MAP_PRIVATE:\n *\t\t\t\t\t\t\t\tr: (no) no\n *\t\t\t\t\t\t\t\tw: (no) no\n *\t\t\t\t\t\t\t\tx: (yes) yes\n */\npgprot_t protection_map[16] __ro_after_init = {\n\t__P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111,\n\t__S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111\n};\n\n#ifndef CONFIG_ARCH_HAS_FILTER_PGPROT\nstatic inline pgprot_t arch_filter_pgprot(pgprot_t prot)\n{\n\treturn prot;\n}\n#endif\n\npgprot_t vm_get_page_prot(unsigned long vm_flags)\n{\n\tpgprot_t ret = __pgprot(pgprot_val(protection_map[vm_flags &\n\t\t\t\t(VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)]) |\n\t\t\tpgprot_val(arch_vm_get_page_prot(vm_flags)));\n\n\treturn arch_filter_pgprot(ret);\n}\nEXPORT_SYMBOL(vm_get_page_prot);\n\nstatic pgprot_t vm_pgprot_modify(pgprot_t oldprot, unsigned long vm_flags)\n{\n\treturn pgprot_modify(oldprot, vm_get_page_prot(vm_flags));\n}\n\n/* Update vma->vm_page_prot to reflect vma->vm_flags. */\nvoid vma_set_page_prot(struct vm_area_struct *vma)\n{\n\tunsigned long vm_flags = vma->vm_flags;\n\tpgprot_t vm_page_prot;\n\n\tvm_page_prot = vm_pgprot_modify(vma->vm_page_prot, vm_flags);\n\tif (vma_wants_writenotify(vma, vm_page_prot)) {\n\t\tvm_flags &= ~VM_SHARED;\n\t\tvm_page_prot = vm_pgprot_modify(vm_page_prot, vm_flags);\n\t}\n\t/* remove_protection_ptes reads vma->vm_page_prot without mmap_sem */\n\tWRITE_ONCE(vma->vm_page_prot, vm_page_prot);\n}\n\n/*\n * Requires inode->i_mapping->i_mmap_rwsem\n */\nstatic void __remove_shared_vm_struct(struct vm_area_struct *vma,\n\t\tstruct file *file, struct address_space *mapping)\n{\n\tif (vma->vm_flags & VM_DENYWRITE)\n\t\tatomic_inc(&file_inode(file)->i_writecount);\n\tif (vma->vm_flags & VM_SHARED)\n\t\tmapping_unmap_writable(mapping);\n\n\tflush_dcache_mmap_lock(mapping);\n\tvma_interval_tree_remove(vma, &mapping->i_mmap);\n\tflush_dcache_mmap_unlock(mapping);\n}\n\n/*\n * Unlink a file-based vm structure from its interval tree, to hide\n * vma from rmap and vmtruncate before freeing its page tables.\n */\nvoid unlink_file_vma(struct vm_area_struct *vma)\n{\n\tstruct file *file = vma->vm_file;\n\n\tif (file) {\n\t\tstruct address_space *mapping = file->f_mapping;\n\t\ti_mmap_lock_write(mapping);\n\t\t__remove_shared_vm_struct(vma, file, mapping);\n\t\ti_mmap_unlock_write(mapping);\n\t}\n}\n\n/*\n * Close a vm structure and free it, returning the next.\n */\nstatic struct vm_area_struct *remove_vma(struct vm_area_struct *vma)\n{\n\tstruct vm_area_struct *next = vma->vm_next;\n\n\tmight_sleep();\n\tif (vma->vm_ops && vma->vm_ops->close)\n\t\tvma->vm_ops->close(vma);\n\tif (vma->vm_file)\n\t\tfput(vma->vm_file);\n\tmpol_put(vma_policy(vma));\n\tvm_area_free(vma);\n\treturn next;\n}\n\nstatic int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);\nSYSCALL_DEFINE1(brk, unsigned long, brk)\n{\n\tunsigned long retval;\n\tunsigned long newbrk, oldbrk, origbrk;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *next;\n\tunsigned long min_brk;\n\tbool populate;\n\tbool downgraded = false;\n\tLIST_HEAD(uf);\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\torigbrk = mm->brk;\n\n#ifdef CONFIG_COMPAT_BRK\n\t/*\n\t * CONFIG_COMPAT_BRK can still be overridden by setting\n\t * randomize_va_space to 2, which will still cause mm->start_brk\n\t * to be arbitrarily shifted\n\t */\n\tif (current->brk_randomized)\n\t\tmin_brk = mm->start_brk;\n\telse\n\t\tmin_brk = mm->end_data;\n#else\n\tmin_brk = mm->start_brk;\n#endif\n\tif (brk < min_brk)\n\t\tgoto out;\n\n\t/*\n\t * Check against rlimit here. If this check is done later after the test\n\t * of oldbrk with newbrk then it can escape the test and let the data\n\t * segment grow beyond its set limit the in case where the limit is\n\t * not page aligned -Ram Gupta\n\t */\n\tif (check_data_rlimit(rlimit(RLIMIT_DATA), brk, mm->start_brk,\n\t\t\t      mm->end_data, mm->start_data))\n\t\tgoto out;\n\n\tnewbrk = PAGE_ALIGN(brk);\n\toldbrk = PAGE_ALIGN(mm->brk);\n\tif (oldbrk == newbrk) {\n\t\tmm->brk = brk;\n\t\tgoto success;\n\t}\n\n\t/*\n\t * Always allow shrinking brk.\n\t * __do_munmap() may downgrade mmap_sem to read.\n\t */\n\tif (brk <= mm->brk) {\n\t\tint ret;\n\n\t\t/*\n\t\t * mm->brk must to be protected by write mmap_sem so update it\n\t\t * before downgrading mmap_sem. When __do_munmap() fails,\n\t\t * mm->brk will be restored from origbrk.\n\t\t */\n\t\tmm->brk = brk;\n\t\tret = __do_munmap(mm, newbrk, oldbrk-newbrk, &uf, true);\n\t\tif (ret < 0) {\n\t\t\tmm->brk = origbrk;\n\t\t\tgoto out;\n\t\t} else if (ret == 1) {\n\t\t\tdowngraded = true;\n\t\t}\n\t\tgoto success;\n\t}\n\n\t/* Check against existing mmap mappings. */\n\tnext = find_vma(mm, oldbrk);\n\tif (next && newbrk + PAGE_SIZE > vm_start_gap(next))\n\t\tgoto out;\n\n\t/* Ok, looks good - let it rip. */\n\tif (do_brk_flags(oldbrk, newbrk-oldbrk, 0, &uf) < 0)\n\t\tgoto out;\n\tmm->brk = brk;\n\nsuccess:\n\tpopulate = newbrk > oldbrk && (mm->def_flags & VM_LOCKED) != 0;\n\tif (downgraded)\n\t\tup_read(&mm->mmap_sem);\n\telse\n\t\tup_write(&mm->mmap_sem);\n\tuserfaultfd_unmap_complete(mm, &uf);\n\tif (populate)\n\t\tmm_populate(oldbrk, newbrk - oldbrk);\n\treturn brk;\n\nout:\n\tretval = origbrk;\n\tup_write(&mm->mmap_sem);\n\treturn retval;\n}\n\nstatic long vma_compute_subtree_gap(struct vm_area_struct *vma)\n{\n\tunsigned long max, prev_end, subtree_gap;\n\n\t/*\n\t * Note: in the rare case of a VM_GROWSDOWN above a VM_GROWSUP, we\n\t * allow two stack_guard_gaps between them here, and when choosing\n\t * an unmapped area; whereas when expanding we only require one.\n\t * That's a little inconsistent, but keeps the code here simpler.\n\t */\n\tmax = vm_start_gap(vma);\n\tif (vma->vm_prev) {\n\t\tprev_end = vm_end_gap(vma->vm_prev);\n\t\tif (max > prev_end)\n\t\t\tmax -= prev_end;\n\t\telse\n\t\t\tmax = 0;\n\t}\n\tif (vma->vm_rb.rb_left) {\n\t\tsubtree_gap = rb_entry(vma->vm_rb.rb_left,\n\t\t\t\tstruct vm_area_struct, vm_rb)->rb_subtree_gap;\n\t\tif (subtree_gap > max)\n\t\t\tmax = subtree_gap;\n\t}\n\tif (vma->vm_rb.rb_right) {\n\t\tsubtree_gap = rb_entry(vma->vm_rb.rb_right,\n\t\t\t\tstruct vm_area_struct, vm_rb)->rb_subtree_gap;\n\t\tif (subtree_gap > max)\n\t\t\tmax = subtree_gap;\n\t}\n\treturn max;\n}\n\n#ifdef CONFIG_DEBUG_VM_RB\nstatic int browse_rb(struct mm_struct *mm)\n{\n\tstruct rb_root *root = &mm->mm_rb;\n\tint i = 0, j, bug = 0;\n\tstruct rb_node *nd, *pn = NULL;\n\tunsigned long prev = 0, pend = 0;\n\n\tfor (nd = rb_first(root); nd; nd = rb_next(nd)) {\n\t\tstruct vm_area_struct *vma;\n\t\tvma = rb_entry(nd, struct vm_area_struct, vm_rb);\n\t\tif (vma->vm_start < prev) {\n\t\t\tpr_emerg(\"vm_start %lx < prev %lx\\n\",\n\t\t\t\t  vma->vm_start, prev);\n\t\t\tbug = 1;\n\t\t}\n\t\tif (vma->vm_start < pend) {\n\t\t\tpr_emerg(\"vm_start %lx < pend %lx\\n\",\n\t\t\t\t  vma->vm_start, pend);\n\t\t\tbug = 1;\n\t\t}\n\t\tif (vma->vm_start > vma->vm_end) {\n\t\t\tpr_emerg(\"vm_start %lx > vm_end %lx\\n\",\n\t\t\t\t  vma->vm_start, vma->vm_end);\n\t\t\tbug = 1;\n\t\t}\n\t\tspin_lock(&mm->page_table_lock);\n\t\tif (vma->rb_subtree_gap != vma_compute_subtree_gap(vma)) {\n\t\t\tpr_emerg(\"free gap %lx, correct %lx\\n\",\n\t\t\t       vma->rb_subtree_gap,\n\t\t\t       vma_compute_subtree_gap(vma));\n\t\t\tbug = 1;\n\t\t}\n\t\tspin_unlock(&mm->page_table_lock);\n\t\ti++;\n\t\tpn = nd;\n\t\tprev = vma->vm_start;\n\t\tpend = vma->vm_end;\n\t}\n\tj = 0;\n\tfor (nd = pn; nd; nd = rb_prev(nd))\n\t\tj++;\n\tif (i != j) {\n\t\tpr_emerg(\"backwards %d, forwards %d\\n\", j, i);\n\t\tbug = 1;\n\t}\n\treturn bug ? -1 : i;\n}\n\nstatic void validate_mm_rb(struct rb_root *root, struct vm_area_struct *ignore)\n{\n\tstruct rb_node *nd;\n\n\tfor (nd = rb_first(root); nd; nd = rb_next(nd)) {\n\t\tstruct vm_area_struct *vma;\n\t\tvma = rb_entry(nd, struct vm_area_struct, vm_rb);\n\t\tVM_BUG_ON_VMA(vma != ignore &&\n\t\t\tvma->rb_subtree_gap != vma_compute_subtree_gap(vma),\n\t\t\tvma);\n\t}\n}\n\nstatic void validate_mm(struct mm_struct *mm)\n{\n\tint bug = 0;\n\tint i = 0;\n\tunsigned long highest_address = 0;\n\tstruct vm_area_struct *vma = mm->mmap;\n\n\twhile (vma) {\n\t\tstruct anon_vma *anon_vma = vma->anon_vma;\n\t\tstruct anon_vma_chain *avc;\n\n\t\tif (anon_vma) {\n\t\t\tanon_vma_lock_read(anon_vma);\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tanon_vma_interval_tree_verify(avc);\n\t\t\tanon_vma_unlock_read(anon_vma);\n\t\t}\n\n\t\thighest_address = vm_end_gap(vma);\n\t\tvma = vma->vm_next;\n\t\ti++;\n\t}\n\tif (i != mm->map_count) {\n\t\tpr_emerg(\"map_count %d vm_next %d\\n\", mm->map_count, i);\n\t\tbug = 1;\n\t}\n\tif (highest_address != mm->highest_vm_end) {\n\t\tpr_emerg(\"mm->highest_vm_end %lx, found %lx\\n\",\n\t\t\t  mm->highest_vm_end, highest_address);\n\t\tbug = 1;\n\t}\n\ti = browse_rb(mm);\n\tif (i != mm->map_count) {\n\t\tif (i != -1)\n\t\t\tpr_emerg(\"map_count %d rb %d\\n\", mm->map_count, i);\n\t\tbug = 1;\n\t}\n\tVM_BUG_ON_MM(bug, mm);\n}\n#else\n#define validate_mm_rb(root, ignore) do { } while (0)\n#define validate_mm(mm) do { } while (0)\n#endif\n\nRB_DECLARE_CALLBACKS(static, vma_gap_callbacks, struct vm_area_struct, vm_rb,\n\t\t     unsigned long, rb_subtree_gap, vma_compute_subtree_gap)\n\n/*\n * Update augmented rbtree rb_subtree_gap values after vma->vm_start or\n * vma->vm_prev->vm_end values changed, without modifying the vma's position\n * in the rbtree.\n */\nstatic void vma_gap_update(struct vm_area_struct *vma)\n{\n\t/*\n\t * As it turns out, RB_DECLARE_CALLBACKS() already created a callback\n\t * function that does exacltly what we want.\n\t */\n\tvma_gap_callbacks_propagate(&vma->vm_rb, NULL);\n}\n\nstatic inline void vma_rb_insert(struct vm_area_struct *vma,\n\t\t\t\t struct rb_root *root)\n{\n\t/* All rb_subtree_gap values must be consistent prior to insertion */\n\tvalidate_mm_rb(root, NULL);\n\n\trb_insert_augmented(&vma->vm_rb, root, &vma_gap_callbacks);\n}\n\nstatic void __vma_rb_erase(struct vm_area_struct *vma, struct rb_root *root)\n{\n\t/*\n\t * Note rb_erase_augmented is a fairly large inline function,\n\t * so make sure we instantiate it only once with our desired\n\t * augmented rbtree callbacks.\n\t */\n\trb_erase_augmented(&vma->vm_rb, root, &vma_gap_callbacks);\n}\n\nstatic __always_inline void vma_rb_erase_ignore(struct vm_area_struct *vma,\n\t\t\t\t\t\tstruct rb_root *root,\n\t\t\t\t\t\tstruct vm_area_struct *ignore)\n{\n\t/*\n\t * All rb_subtree_gap values must be consistent prior to erase,\n\t * with the possible exception of the \"next\" vma being erased if\n\t * next->vm_start was reduced.\n\t */\n\tvalidate_mm_rb(root, ignore);\n\n\t__vma_rb_erase(vma, root);\n}\n\nstatic __always_inline void vma_rb_erase(struct vm_area_struct *vma,\n\t\t\t\t\t struct rb_root *root)\n{\n\t/*\n\t * All rb_subtree_gap values must be consistent prior to erase,\n\t * with the possible exception of the vma being erased.\n\t */\n\tvalidate_mm_rb(root, vma);\n\n\t__vma_rb_erase(vma, root);\n}\n\n/*\n * vma has some anon_vma assigned, and is already inserted on that\n * anon_vma's interval trees.\n *\n * Before updating the vma's vm_start / vm_end / vm_pgoff fields, the\n * vma must be removed from the anon_vma's interval trees using\n * anon_vma_interval_tree_pre_update_vma().\n *\n * After the update, the vma will be reinserted using\n * anon_vma_interval_tree_post_update_vma().\n *\n * The entire update must be protected by exclusive mmap_sem and by\n * the root anon_vma's mutex.\n */\nstatic inline void\nanon_vma_interval_tree_pre_update_vma(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc;\n\n\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\tanon_vma_interval_tree_remove(avc, &avc->anon_vma->rb_root);\n}\n\nstatic inline void\nanon_vma_interval_tree_post_update_vma(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc;\n\n\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\tanon_vma_interval_tree_insert(avc, &avc->anon_vma->rb_root);\n}\n\nstatic int find_vma_links(struct mm_struct *mm, unsigned long addr,\n\t\tunsigned long end, struct vm_area_struct **pprev,\n\t\tstruct rb_node ***rb_link, struct rb_node **rb_parent)\n{\n\tstruct rb_node **__rb_link, *__rb_parent, *rb_prev;\n\n\t__rb_link = &mm->mm_rb.rb_node;\n\trb_prev = __rb_parent = NULL;\n\n\twhile (*__rb_link) {\n\t\tstruct vm_area_struct *vma_tmp;\n\n\t\t__rb_parent = *__rb_link;\n\t\tvma_tmp = rb_entry(__rb_parent, struct vm_area_struct, vm_rb);\n\n\t\tif (vma_tmp->vm_end > addr) {\n\t\t\t/* Fail if an existing vma overlaps the area */\n\t\t\tif (vma_tmp->vm_start < end)\n\t\t\t\treturn -ENOMEM;\n\t\t\t__rb_link = &__rb_parent->rb_left;\n\t\t} else {\n\t\t\trb_prev = __rb_parent;\n\t\t\t__rb_link = &__rb_parent->rb_right;\n\t\t}\n\t}\n\n\t*pprev = NULL;\n\tif (rb_prev)\n\t\t*pprev = rb_entry(rb_prev, struct vm_area_struct, vm_rb);\n\t*rb_link = __rb_link;\n\t*rb_parent = __rb_parent;\n\treturn 0;\n}\n\nstatic unsigned long count_vma_pages_range(struct mm_struct *mm,\n\t\tunsigned long addr, unsigned long end)\n{\n\tunsigned long nr_pages = 0;\n\tstruct vm_area_struct *vma;\n\n\t/* Find first overlaping mapping */\n\tvma = find_vma_intersection(mm, addr, end);\n\tif (!vma)\n\t\treturn 0;\n\n\tnr_pages = (min(end, vma->vm_end) -\n\t\tmax(addr, vma->vm_start)) >> PAGE_SHIFT;\n\n\t/* Iterate over the rest of the overlaps */\n\tfor (vma = vma->vm_next; vma; vma = vma->vm_next) {\n\t\tunsigned long overlap_len;\n\n\t\tif (vma->vm_start > end)\n\t\t\tbreak;\n\n\t\toverlap_len = min(end, vma->vm_end) - vma->vm_start;\n\t\tnr_pages += overlap_len >> PAGE_SHIFT;\n\t}\n\n\treturn nr_pages;\n}\n\nvoid __vma_link_rb(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tstruct rb_node **rb_link, struct rb_node *rb_parent)\n{\n\t/* Update tracking information for the gap following the new vma. */\n\tif (vma->vm_next)\n\t\tvma_gap_update(vma->vm_next);\n\telse\n\t\tmm->highest_vm_end = vm_end_gap(vma);\n\n\t/*\n\t * vma->vm_prev wasn't known when we followed the rbtree to find the\n\t * correct insertion point for that vma. As a result, we could not\n\t * update the vma vm_rb parents rb_subtree_gap values on the way down.\n\t * So, we first insert the vma with a zero rb_subtree_gap value\n\t * (to be consistent with what we did on the way down), and then\n\t * immediately update the gap to the correct value. Finally we\n\t * rebalance the rbtree after all augmented values have been set.\n\t */\n\trb_link_node(&vma->vm_rb, rb_parent, rb_link);\n\tvma->rb_subtree_gap = 0;\n\tvma_gap_update(vma);\n\tvma_rb_insert(vma, &mm->mm_rb);\n}\n\nstatic void __vma_link_file(struct vm_area_struct *vma)\n{\n\tstruct file *file;\n\n\tfile = vma->vm_file;\n\tif (file) {\n\t\tstruct address_space *mapping = file->f_mapping;\n\n\t\tif (vma->vm_flags & VM_DENYWRITE)\n\t\t\tatomic_dec(&file_inode(file)->i_writecount);\n\t\tif (vma->vm_flags & VM_SHARED)\n\t\t\tatomic_inc(&mapping->i_mmap_writable);\n\n\t\tflush_dcache_mmap_lock(mapping);\n\t\tvma_interval_tree_insert(vma, &mapping->i_mmap);\n\t\tflush_dcache_mmap_unlock(mapping);\n\t}\n}\n\nstatic void\n__vma_link(struct mm_struct *mm, struct vm_area_struct *vma,\n\tstruct vm_area_struct *prev, struct rb_node **rb_link,\n\tstruct rb_node *rb_parent)\n{\n\t__vma_link_list(mm, vma, prev, rb_parent);\n\t__vma_link_rb(mm, vma, rb_link, rb_parent);\n}\n\nstatic void vma_link(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\tstruct vm_area_struct *prev, struct rb_node **rb_link,\n\t\t\tstruct rb_node *rb_parent)\n{\n\tstruct address_space *mapping = NULL;\n\n\tif (vma->vm_file) {\n\t\tmapping = vma->vm_file->f_mapping;\n\t\ti_mmap_lock_write(mapping);\n\t}\n\n\t__vma_link(mm, vma, prev, rb_link, rb_parent);\n\t__vma_link_file(vma);\n\n\tif (mapping)\n\t\ti_mmap_unlock_write(mapping);\n\n\tmm->map_count++;\n\tvalidate_mm(mm);\n}\n\n/*\n * Helper for vma_adjust() in the split_vma insert case: insert a vma into the\n * mm's list and rbtree.  It has already been inserted into the interval tree.\n */\nstatic void __insert_vm_struct(struct mm_struct *mm, struct vm_area_struct *vma)\n{\n\tstruct vm_area_struct *prev;\n\tstruct rb_node **rb_link, *rb_parent;\n\n\tif (find_vma_links(mm, vma->vm_start, vma->vm_end,\n\t\t\t   &prev, &rb_link, &rb_parent))\n\t\tBUG();\n\t__vma_link(mm, vma, prev, rb_link, rb_parent);\n\tmm->map_count++;\n}\n\nstatic __always_inline void __vma_unlink_common(struct mm_struct *mm,\n\t\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\t\tstruct vm_area_struct *prev,\n\t\t\t\t\t\tbool has_prev,\n\t\t\t\t\t\tstruct vm_area_struct *ignore)\n{\n\tstruct vm_area_struct *next;\n\n\tvma_rb_erase_ignore(vma, &mm->mm_rb, ignore);\n\tnext = vma->vm_next;\n\tif (has_prev)\n\t\tprev->vm_next = next;\n\telse {\n\t\tprev = vma->vm_prev;\n\t\tif (prev)\n\t\t\tprev->vm_next = next;\n\t\telse\n\t\t\tmm->mmap = next;\n\t}\n\tif (next)\n\t\tnext->vm_prev = prev;\n\n\t/* Kill the cache */\n\tvmacache_invalidate(mm);\n}\n\nstatic inline void __vma_unlink_prev(struct mm_struct *mm,\n\t\t\t\t     struct vm_area_struct *vma,\n\t\t\t\t     struct vm_area_struct *prev)\n{\n\t__vma_unlink_common(mm, vma, prev, true, vma);\n}\n\n/*\n * We cannot adjust vm_start, vm_end, vm_pgoff fields of a vma that\n * is already present in an i_mmap tree without adjusting the tree.\n * The following helper function should be used when such adjustments\n * are necessary.  The \"insert\" vma (if any) is to be inserted\n * before we drop the necessary locks.\n */\nint __vma_adjust(struct vm_area_struct *vma, unsigned long start,\n\tunsigned long end, pgoff_t pgoff, struct vm_area_struct *insert,\n\tstruct vm_area_struct *expand)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *next = vma->vm_next, *orig_vma = vma;\n\tstruct address_space *mapping = NULL;\n\tstruct rb_root_cached *root = NULL;\n\tstruct anon_vma *anon_vma = NULL;\n\tstruct file *file = vma->vm_file;\n\tbool start_changed = false, end_changed = false;\n\tlong adjust_next = 0;\n\tint remove_next = 0;\n\n\tif (next && !insert) {\n\t\tstruct vm_area_struct *exporter = NULL, *importer = NULL;\n\n\t\tif (end >= next->vm_end) {\n\t\t\t/*\n\t\t\t * vma expands, overlapping all the next, and\n\t\t\t * perhaps the one after too (mprotect case 6).\n\t\t\t * The only other cases that gets here are\n\t\t\t * case 1, case 7 and case 8.\n\t\t\t */\n\t\t\tif (next == expand) {\n\t\t\t\t/*\n\t\t\t\t * The only case where we don't expand \"vma\"\n\t\t\t\t * and we expand \"next\" instead is case 8.\n\t\t\t\t */\n\t\t\t\tVM_WARN_ON(end != next->vm_end);\n\t\t\t\t/*\n\t\t\t\t * remove_next == 3 means we're\n\t\t\t\t * removing \"vma\" and that to do so we\n\t\t\t\t * swapped \"vma\" and \"next\".\n\t\t\t\t */\n\t\t\t\tremove_next = 3;\n\t\t\t\tVM_WARN_ON(file != next->vm_file);\n\t\t\t\tswap(vma, next);\n\t\t\t} else {\n\t\t\t\tVM_WARN_ON(expand != vma);\n\t\t\t\t/*\n\t\t\t\t * case 1, 6, 7, remove_next == 2 is case 6,\n\t\t\t\t * remove_next == 1 is case 1 or 7.\n\t\t\t\t */\n\t\t\t\tremove_next = 1 + (end > next->vm_end);\n\t\t\t\tVM_WARN_ON(remove_next == 2 &&\n\t\t\t\t\t   end != next->vm_next->vm_end);\n\t\t\t\tVM_WARN_ON(remove_next == 1 &&\n\t\t\t\t\t   end != next->vm_end);\n\t\t\t\t/* trim end to next, for case 6 first pass */\n\t\t\t\tend = next->vm_end;\n\t\t\t}\n\n\t\t\texporter = next;\n\t\t\timporter = vma;\n\n\t\t\t/*\n\t\t\t * If next doesn't have anon_vma, import from vma after\n\t\t\t * next, if the vma overlaps with it.\n\t\t\t */\n\t\t\tif (remove_next == 2 && !next->anon_vma)\n\t\t\t\texporter = next->vm_next;\n\n\t\t} else if (end > next->vm_start) {\n\t\t\t/*\n\t\t\t * vma expands, overlapping part of the next:\n\t\t\t * mprotect case 5 shifting the boundary up.\n\t\t\t */\n\t\t\tadjust_next = (end - next->vm_start) >> PAGE_SHIFT;\n\t\t\texporter = next;\n\t\t\timporter = vma;\n\t\t\tVM_WARN_ON(expand != importer);\n\t\t} else if (end < vma->vm_end) {\n\t\t\t/*\n\t\t\t * vma shrinks, and !insert tells it's not\n\t\t\t * split_vma inserting another: so it must be\n\t\t\t * mprotect case 4 shifting the boundary down.\n\t\t\t */\n\t\t\tadjust_next = -((vma->vm_end - end) >> PAGE_SHIFT);\n\t\t\texporter = vma;\n\t\t\timporter = next;\n\t\t\tVM_WARN_ON(expand != importer);\n\t\t}\n\n\t\t/*\n\t\t * Easily overlooked: when mprotect shifts the boundary,\n\t\t * make sure the expanding vma has anon_vma set if the\n\t\t * shrinking vma had, to cover any anon pages imported.\n\t\t */\n\t\tif (exporter && exporter->anon_vma && !importer->anon_vma) {\n\t\t\tint error;\n\n\t\t\timporter->anon_vma = exporter->anon_vma;\n\t\t\terror = anon_vma_clone(importer, exporter);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\nagain:\n\tvma_adjust_trans_huge(orig_vma, start, end, adjust_next);\n\n\tif (file) {\n\t\tmapping = file->f_mapping;\n\t\troot = &mapping->i_mmap;\n\t\tuprobe_munmap(vma, vma->vm_start, vma->vm_end);\n\n\t\tif (adjust_next)\n\t\t\tuprobe_munmap(next, next->vm_start, next->vm_end);\n\n\t\ti_mmap_lock_write(mapping);\n\t\tif (insert) {\n\t\t\t/*\n\t\t\t * Put into interval tree now, so instantiated pages\n\t\t\t * are visible to arm/parisc __flush_dcache_page\n\t\t\t * throughout; but we cannot insert into address\n\t\t\t * space until vma start or end is updated.\n\t\t\t */\n\t\t\t__vma_link_file(insert);\n\t\t}\n\t}\n\n\tanon_vma = vma->anon_vma;\n\tif (!anon_vma && adjust_next)\n\t\tanon_vma = next->anon_vma;\n\tif (anon_vma) {\n\t\tVM_WARN_ON(adjust_next && next->anon_vma &&\n\t\t\t   anon_vma != next->anon_vma);\n\t\tanon_vma_lock_write(anon_vma);\n\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\tif (adjust_next)\n\t\t\tanon_vma_interval_tree_pre_update_vma(next);\n\t}\n\n\tif (root) {\n\t\tflush_dcache_mmap_lock(mapping);\n\t\tvma_interval_tree_remove(vma, root);\n\t\tif (adjust_next)\n\t\t\tvma_interval_tree_remove(next, root);\n\t}\n\n\tif (start != vma->vm_start) {\n\t\tvma->vm_start = start;\n\t\tstart_changed = true;\n\t}\n\tif (end != vma->vm_end) {\n\t\tvma->vm_end = end;\n\t\tend_changed = true;\n\t}\n\tvma->vm_pgoff = pgoff;\n\tif (adjust_next) {\n\t\tnext->vm_start += adjust_next << PAGE_SHIFT;\n\t\tnext->vm_pgoff += adjust_next;\n\t}\n\n\tif (root) {\n\t\tif (adjust_next)\n\t\t\tvma_interval_tree_insert(next, root);\n\t\tvma_interval_tree_insert(vma, root);\n\t\tflush_dcache_mmap_unlock(mapping);\n\t}\n\n\tif (remove_next) {\n\t\t/*\n\t\t * vma_merge has merged next into vma, and needs\n\t\t * us to remove next before dropping the locks.\n\t\t */\n\t\tif (remove_next != 3)\n\t\t\t__vma_unlink_prev(mm, next, vma);\n\t\telse\n\t\t\t/*\n\t\t\t * vma is not before next if they've been\n\t\t\t * swapped.\n\t\t\t *\n\t\t\t * pre-swap() next->vm_start was reduced so\n\t\t\t * tell validate_mm_rb to ignore pre-swap()\n\t\t\t * \"next\" (which is stored in post-swap()\n\t\t\t * \"vma\").\n\t\t\t */\n\t\t\t__vma_unlink_common(mm, next, NULL, false, vma);\n\t\tif (file)\n\t\t\t__remove_shared_vm_struct(next, file, mapping);\n\t} else if (insert) {\n\t\t/*\n\t\t * split_vma has split insert from vma, and needs\n\t\t * us to insert it before dropping the locks\n\t\t * (it may either follow vma or precede it).\n\t\t */\n\t\t__insert_vm_struct(mm, insert);\n\t} else {\n\t\tif (start_changed)\n\t\t\tvma_gap_update(vma);\n\t\tif (end_changed) {\n\t\t\tif (!next)\n\t\t\t\tmm->highest_vm_end = vm_end_gap(vma);\n\t\t\telse if (!adjust_next)\n\t\t\t\tvma_gap_update(next);\n\t\t}\n\t}\n\n\tif (anon_vma) {\n\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\tif (adjust_next)\n\t\t\tanon_vma_interval_tree_post_update_vma(next);\n\t\tanon_vma_unlock_write(anon_vma);\n\t}\n\tif (mapping)\n\t\ti_mmap_unlock_write(mapping);\n\n\tif (root) {\n\t\tuprobe_mmap(vma);\n\n\t\tif (adjust_next)\n\t\t\tuprobe_mmap(next);\n\t}\n\n\tif (remove_next) {\n\t\tif (file) {\n\t\t\tuprobe_munmap(next, next->vm_start, next->vm_end);\n\t\t\tfput(file);\n\t\t}\n\t\tif (next->anon_vma)\n\t\t\tanon_vma_merge(vma, next);\n\t\tmm->map_count--;\n\t\tmpol_put(vma_policy(next));\n\t\tvm_area_free(next);\n\t\t/*\n\t\t * In mprotect's case 6 (see comments on vma_merge),\n\t\t * we must remove another next too. It would clutter\n\t\t * up the code too much to do both in one go.\n\t\t */\n\t\tif (remove_next != 3) {\n\t\t\t/*\n\t\t\t * If \"next\" was removed and vma->vm_end was\n\t\t\t * expanded (up) over it, in turn\n\t\t\t * \"next->vm_prev->vm_end\" changed and the\n\t\t\t * \"vma->vm_next\" gap must be updated.\n\t\t\t */\n\t\t\tnext = vma->vm_next;\n\t\t} else {\n\t\t\t/*\n\t\t\t * For the scope of the comment \"next\" and\n\t\t\t * \"vma\" considered pre-swap(): if \"vma\" was\n\t\t\t * removed, next->vm_start was expanded (down)\n\t\t\t * over it and the \"next\" gap must be updated.\n\t\t\t * Because of the swap() the post-swap() \"vma\"\n\t\t\t * actually points to pre-swap() \"next\"\n\t\t\t * (post-swap() \"next\" as opposed is now a\n\t\t\t * dangling pointer).\n\t\t\t */\n\t\t\tnext = vma;\n\t\t}\n\t\tif (remove_next == 2) {\n\t\t\tremove_next = 1;\n\t\t\tend = next->vm_end;\n\t\t\tgoto again;\n\t\t}\n\t\telse if (next)\n\t\t\tvma_gap_update(next);\n\t\telse {\n\t\t\t/*\n\t\t\t * If remove_next == 2 we obviously can't\n\t\t\t * reach this path.\n\t\t\t *\n\t\t\t * If remove_next == 3 we can't reach this\n\t\t\t * path because pre-swap() next is always not\n\t\t\t * NULL. pre-swap() \"next\" is not being\n\t\t\t * removed and its next->vm_end is not altered\n\t\t\t * (and furthermore \"end\" already matches\n\t\t\t * next->vm_end in remove_next == 3).\n\t\t\t *\n\t\t\t * We reach this only in the remove_next == 1\n\t\t\t * case if the \"next\" vma that was removed was\n\t\t\t * the highest vma of the mm. However in such\n\t\t\t * case next->vm_end == \"end\" and the extended\n\t\t\t * \"vma\" has vma->vm_end == next->vm_end so\n\t\t\t * mm->highest_vm_end doesn't need any update\n\t\t\t * in remove_next == 1 case.\n\t\t\t */\n\t\t\tVM_WARN_ON(mm->highest_vm_end != vm_end_gap(vma));\n\t\t}\n\t}\n\tif (insert && file)\n\t\tuprobe_mmap(insert);\n\n\tvalidate_mm(mm);\n\n\treturn 0;\n}\n\n/*\n * If the vma has a ->close operation then the driver probably needs to release\n * per-vma resources, so we don't attempt to merge those.\n */\nstatic inline int is_mergeable_vma(struct vm_area_struct *vma,\n\t\t\t\tstruct file *file, unsigned long vm_flags,\n\t\t\t\tstruct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\t/*\n\t * VM_SOFTDIRTY should not prevent from VMA merging, if we\n\t * match the flags but dirty bit -- the caller should mark\n\t * merged VMA as dirty. If dirty bit won't be excluded from\n\t * comparison, we increase pressue on the memory system forcing\n\t * the kernel to generate new VMAs when old one could be\n\t * extended instead.\n\t */\n\tif ((vma->vm_flags ^ vm_flags) & ~VM_SOFTDIRTY)\n\t\treturn 0;\n\tif (vma->vm_file != file)\n\t\treturn 0;\n\tif (vma->vm_ops && vma->vm_ops->close)\n\t\treturn 0;\n\tif (!is_mergeable_vm_userfaultfd_ctx(vma, vm_userfaultfd_ctx))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic inline int is_mergeable_anon_vma(struct anon_vma *anon_vma1,\n\t\t\t\t\tstruct anon_vma *anon_vma2,\n\t\t\t\t\tstruct vm_area_struct *vma)\n{\n\t/*\n\t * The list_is_singular() test is to avoid merging VMA cloned from\n\t * parents. This can improve scalability caused by anon_vma lock.\n\t */\n\tif ((!anon_vma1 || !anon_vma2) && (!vma ||\n\t\tlist_is_singular(&vma->anon_vma_chain)))\n\t\treturn 1;\n\treturn anon_vma1 == anon_vma2;\n}\n\n/*\n * Return true if we can merge this (vm_flags,anon_vma,file,vm_pgoff)\n * in front of (at a lower virtual address and file offset than) the vma.\n *\n * We cannot merge two vmas if they have differently assigned (non-NULL)\n * anon_vmas, nor if same anon_vma is assigned but offsets incompatible.\n *\n * We don't check here for the merged mmap wrapping around the end of pagecache\n * indices (16TB on ia32) because do_mmap_pgoff() does not permit mmap's which\n * wrap, nor mmaps which cover the final page at index -1UL.\n */\nstatic int\ncan_vma_merge_before(struct vm_area_struct *vma, unsigned long vm_flags,\n\t\t     struct anon_vma *anon_vma, struct file *file,\n\t\t     pgoff_t vm_pgoff,\n\t\t     struct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\tif (is_mergeable_vma(vma, file, vm_flags, vm_userfaultfd_ctx) &&\n\t    is_mergeable_anon_vma(anon_vma, vma->anon_vma, vma)) {\n\t\tif (vma->vm_pgoff == vm_pgoff)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * Return true if we can merge this (vm_flags,anon_vma,file,vm_pgoff)\n * beyond (at a higher virtual address and file offset than) the vma.\n *\n * We cannot merge two vmas if they have differently assigned (non-NULL)\n * anon_vmas, nor if same anon_vma is assigned but offsets incompatible.\n */\nstatic int\ncan_vma_merge_after(struct vm_area_struct *vma, unsigned long vm_flags,\n\t\t    struct anon_vma *anon_vma, struct file *file,\n\t\t    pgoff_t vm_pgoff,\n\t\t    struct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\tif (is_mergeable_vma(vma, file, vm_flags, vm_userfaultfd_ctx) &&\n\t    is_mergeable_anon_vma(anon_vma, vma->anon_vma, vma)) {\n\t\tpgoff_t vm_pglen;\n\t\tvm_pglen = vma_pages(vma);\n\t\tif (vma->vm_pgoff + vm_pglen == vm_pgoff)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * Given a mapping request (addr,end,vm_flags,file,pgoff), figure out\n * whether that can be merged with its predecessor or its successor.\n * Or both (it neatly fills a hole).\n *\n * In most cases - when called for mmap, brk or mremap - [addr,end) is\n * certain not to be mapped by the time vma_merge is called; but when\n * called for mprotect, it is certain to be already mapped (either at\n * an offset within prev, or at the start of next), and the flags of\n * this area are about to be changed to vm_flags - and the no-change\n * case has already been eliminated.\n *\n * The following mprotect cases have to be considered, where AAAA is\n * the area passed down from mprotect_fixup, never extending beyond one\n * vma, PPPPPP is the prev vma specified, and NNNNNN the next vma after:\n *\n *     AAAA             AAAA                AAAA          AAAA\n *    PPPPPPNNNNNN    PPPPPPNNNNNN    PPPPPPNNNNNN    PPPPNNNNXXXX\n *    cannot merge    might become    might become    might become\n *                    PPNNNNNNNNNN    PPPPPPPPPPNN    PPPPPPPPPPPP 6 or\n *    mmap, brk or    case 4 below    case 5 below    PPPPPPPPXXXX 7 or\n *    mremap move:                                    PPPPXXXXXXXX 8\n *        AAAA\n *    PPPP    NNNN    PPPPPPPPPPPP    PPPPPPPPNNNN    PPPPNNNNNNNN\n *    might become    case 1 below    case 2 below    case 3 below\n *\n * It is important for case 8 that the the vma NNNN overlapping the\n * region AAAA is never going to extended over XXXX. Instead XXXX must\n * be extended in region AAAA and NNNN must be removed. This way in\n * all cases where vma_merge succeeds, the moment vma_adjust drops the\n * rmap_locks, the properties of the merged vma will be already\n * correct for the whole merged range. Some of those properties like\n * vm_page_prot/vm_flags may be accessed by rmap_walks and they must\n * be correct for the whole merged range immediately after the\n * rmap_locks are released. Otherwise if XXXX would be removed and\n * NNNN would be extended over the XXXX range, remove_migration_ptes\n * or other rmap walkers (if working on addresses beyond the \"end\"\n * parameter) may establish ptes with the wrong permissions of NNNN\n * instead of the right permissions of XXXX.\n */\nstruct vm_area_struct *vma_merge(struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *prev, unsigned long addr,\n\t\t\tunsigned long end, unsigned long vm_flags,\n\t\t\tstruct anon_vma *anon_vma, struct file *file,\n\t\t\tpgoff_t pgoff, struct mempolicy *policy,\n\t\t\tstruct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\tpgoff_t pglen = (end - addr) >> PAGE_SHIFT;\n\tstruct vm_area_struct *area, *next;\n\tint err;\n\n\t/*\n\t * We later require that vma->vm_flags == vm_flags,\n\t * so this tests vma->vm_flags & VM_SPECIAL, too.\n\t */\n\tif (vm_flags & VM_SPECIAL)\n\t\treturn NULL;\n\n\tif (prev)\n\t\tnext = prev->vm_next;\n\telse\n\t\tnext = mm->mmap;\n\tarea = next;\n\tif (area && area->vm_end == end)\t\t/* cases 6, 7, 8 */\n\t\tnext = next->vm_next;\n\n\t/* verify some invariant that must be enforced by the caller */\n\tVM_WARN_ON(prev && addr <= prev->vm_start);\n\tVM_WARN_ON(area && end > area->vm_end);\n\tVM_WARN_ON(addr >= end);\n\n\t/*\n\t * Can it merge with the predecessor?\n\t */\n\tif (prev && prev->vm_end == addr &&\n\t\t\tmpol_equal(vma_policy(prev), policy) &&\n\t\t\tcan_vma_merge_after(prev, vm_flags,\n\t\t\t\t\t    anon_vma, file, pgoff,\n\t\t\t\t\t    vm_userfaultfd_ctx)) {\n\t\t/*\n\t\t * OK, it can.  Can we now merge in the successor as well?\n\t\t */\n\t\tif (next && end == next->vm_start &&\n\t\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t\t     anon_vma, file,\n\t\t\t\t\t\t     pgoff+pglen,\n\t\t\t\t\t\t     vm_userfaultfd_ctx) &&\n\t\t\t\tis_mergeable_anon_vma(prev->anon_vma,\n\t\t\t\t\t\t      next->anon_vma, NULL)) {\n\t\t\t\t\t\t\t/* cases 1, 6 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t next->vm_end, prev->vm_pgoff, NULL,\n\t\t\t\t\t prev);\n\t\t} else\t\t\t\t\t/* cases 2, 5, 7 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t end, prev->vm_pgoff, NULL, prev);\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(prev, vm_flags);\n\t\treturn prev;\n\t}\n\n\t/*\n\t * Can this new request be merged in front of next?\n\t */\n\tif (next && end == next->vm_start &&\n\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t     anon_vma, file, pgoff+pglen,\n\t\t\t\t\t     vm_userfaultfd_ctx)) {\n\t\tif (prev && addr < prev->vm_end)\t/* case 4 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t addr, prev->vm_pgoff, NULL, next);\n\t\telse {\t\t\t\t\t/* cases 3, 8 */\n\t\t\terr = __vma_adjust(area, addr, next->vm_end,\n\t\t\t\t\t next->vm_pgoff - pglen, NULL, next);\n\t\t\t/*\n\t\t\t * In case 3 area is already equal to next and\n\t\t\t * this is a noop, but in case 8 \"area\" has\n\t\t\t * been removed and next was expanded over it.\n\t\t\t */\n\t\t\tarea = next;\n\t\t}\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(area, vm_flags);\n\t\treturn area;\n\t}\n\n\treturn NULL;\n}\n\n/*\n * Rough compatbility check to quickly see if it's even worth looking\n * at sharing an anon_vma.\n *\n * They need to have the same vm_file, and the flags can only differ\n * in things that mprotect may change.\n *\n * NOTE! The fact that we share an anon_vma doesn't _have_ to mean that\n * we can merge the two vma's. For example, we refuse to merge a vma if\n * there is a vm_ops->close() function, because that indicates that the\n * driver is doing some kind of reference counting. But that doesn't\n * really matter for the anon_vma sharing case.\n */\nstatic int anon_vma_compatible(struct vm_area_struct *a, struct vm_area_struct *b)\n{\n\treturn a->vm_end == b->vm_start &&\n\t\tmpol_equal(vma_policy(a), vma_policy(b)) &&\n\t\ta->vm_file == b->vm_file &&\n\t\t!((a->vm_flags ^ b->vm_flags) & ~(VM_READ|VM_WRITE|VM_EXEC|VM_SOFTDIRTY)) &&\n\t\tb->vm_pgoff == a->vm_pgoff + ((b->vm_start - a->vm_start) >> PAGE_SHIFT);\n}\n\n/*\n * Do some basic sanity checking to see if we can re-use the anon_vma\n * from 'old'. The 'a'/'b' vma's are in VM order - one of them will be\n * the same as 'old', the other will be the new one that is trying\n * to share the anon_vma.\n *\n * NOTE! This runs with mm_sem held for reading, so it is possible that\n * the anon_vma of 'old' is concurrently in the process of being set up\n * by another page fault trying to merge _that_. But that's ok: if it\n * is being set up, that automatically means that it will be a singleton\n * acceptable for merging, so we can do all of this optimistically. But\n * we do that READ_ONCE() to make sure that we never re-load the pointer.\n *\n * IOW: that the \"list_is_singular()\" test on the anon_vma_chain only\n * matters for the 'stable anon_vma' case (ie the thing we want to avoid\n * is to return an anon_vma that is \"complex\" due to having gone through\n * a fork).\n *\n * We also make sure that the two vma's are compatible (adjacent,\n * and with the same memory policies). That's all stable, even with just\n * a read lock on the mm_sem.\n */\nstatic struct anon_vma *reusable_anon_vma(struct vm_area_struct *old, struct vm_area_struct *a, struct vm_area_struct *b)\n{\n\tif (anon_vma_compatible(a, b)) {\n\t\tstruct anon_vma *anon_vma = READ_ONCE(old->anon_vma);\n\n\t\tif (anon_vma && list_is_singular(&old->anon_vma_chain))\n\t\t\treturn anon_vma;\n\t}\n\treturn NULL;\n}\n\n/*\n * find_mergeable_anon_vma is used by anon_vma_prepare, to check\n * neighbouring vmas for a suitable anon_vma, before it goes off\n * to allocate a new anon_vma.  It checks because a repetitive\n * sequence of mprotects and faults may otherwise lead to distinct\n * anon_vmas being allocated, preventing vma merge in subsequent\n * mprotect.\n */\nstruct anon_vma *find_mergeable_anon_vma(struct vm_area_struct *vma)\n{\n\tstruct anon_vma *anon_vma;\n\tstruct vm_area_struct *near;\n\n\tnear = vma->vm_next;\n\tif (!near)\n\t\tgoto try_prev;\n\n\tanon_vma = reusable_anon_vma(near, vma, near);\n\tif (anon_vma)\n\t\treturn anon_vma;\ntry_prev:\n\tnear = vma->vm_prev;\n\tif (!near)\n\t\tgoto none;\n\n\tanon_vma = reusable_anon_vma(near, near, vma);\n\tif (anon_vma)\n\t\treturn anon_vma;\nnone:\n\t/*\n\t * There's no absolute need to look only at touching neighbours:\n\t * we could search further afield for \"compatible\" anon_vmas.\n\t * But it would probably just be a waste of time searching,\n\t * or lead to too many vmas hanging off the same anon_vma.\n\t * We're trying to allow mprotect remerging later on,\n\t * not trying to minimize memory used for anon_vmas.\n\t */\n\treturn NULL;\n}\n\n/*\n * If a hint addr is less than mmap_min_addr change hint to be as\n * low as possible but still greater than mmap_min_addr\n */\nstatic inline unsigned long round_hint_to_min(unsigned long hint)\n{\n\thint &= PAGE_MASK;\n\tif (((void *)hint != NULL) &&\n\t    (hint < mmap_min_addr))\n\t\treturn PAGE_ALIGN(mmap_min_addr);\n\treturn hint;\n}\n\nstatic inline int mlock_future_check(struct mm_struct *mm,\n\t\t\t\t     unsigned long flags,\n\t\t\t\t     unsigned long len)\n{\n\tunsigned long locked, lock_limit;\n\n\t/*  mlock MCL_FUTURE? */\n\tif (flags & VM_LOCKED) {\n\t\tlocked = len >> PAGE_SHIFT;\n\t\tlocked += mm->locked_vm;\n\t\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\t\tlock_limit >>= PAGE_SHIFT;\n\t\tif (locked > lock_limit && !capable(CAP_IPC_LOCK))\n\t\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}\n\nstatic inline u64 file_mmap_size_max(struct file *file, struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn MAX_LFS_FILESIZE;\n\n\tif (S_ISBLK(inode->i_mode))\n\t\treturn MAX_LFS_FILESIZE;\n\n\t/* Special \"we do even unsigned file positions\" case */\n\tif (file->f_mode & FMODE_UNSIGNED_OFFSET)\n\t\treturn 0;\n\n\t/* Yes, random drivers might want more. But I'm tired of buggy drivers */\n\treturn ULONG_MAX;\n}\n\nstatic inline bool file_mmap_ok(struct file *file, struct inode *inode,\n\t\t\t\tunsigned long pgoff, unsigned long len)\n{\n\tu64 maxsize = file_mmap_size_max(file, inode);\n\n\tif (maxsize && len > maxsize)\n\t\treturn false;\n\tmaxsize -= len;\n\tif (pgoff > maxsize >> PAGE_SHIFT)\n\t\treturn false;\n\treturn true;\n}\n\n/*\n * The caller must hold down_write(&current->mm->mmap_sem).\n */\nunsigned long do_mmap(struct file *file, unsigned long addr,\n\t\t\tunsigned long len, unsigned long prot,\n\t\t\tunsigned long flags, vm_flags_t vm_flags,\n\t\t\tunsigned long pgoff, unsigned long *populate,\n\t\t\tstruct list_head *uf)\n{\n\tstruct mm_struct *mm = current->mm;\n\tint pkey = 0;\n\n\t*populate = 0;\n\n\tif (!len)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Does the application expect PROT_READ to imply PROT_EXEC?\n\t *\n\t * (the exception is when the underlying filesystem is noexec\n\t *  mounted, in which case we dont add PROT_EXEC.)\n\t */\n\tif ((prot & PROT_READ) && (current->personality & READ_IMPLIES_EXEC))\n\t\tif (!(file && path_noexec(&file->f_path)))\n\t\t\tprot |= PROT_EXEC;\n\n\t/* force arch specific MAP_FIXED handling in get_unmapped_area */\n\tif (flags & MAP_FIXED_NOREPLACE)\n\t\tflags |= MAP_FIXED;\n\n\tif (!(flags & MAP_FIXED))\n\t\taddr = round_hint_to_min(addr);\n\n\t/* Careful about overflows.. */\n\tlen = PAGE_ALIGN(len);\n\tif (!len)\n\t\treturn -ENOMEM;\n\n\t/* offset overflow? */\n\tif ((pgoff + (len >> PAGE_SHIFT)) < pgoff)\n\t\treturn -EOVERFLOW;\n\n\t/* Too many mappings? */\n\tif (mm->map_count > sysctl_max_map_count)\n\t\treturn -ENOMEM;\n\n\t/* Obtain the address to map to. we verify (or select) it and ensure\n\t * that it represents a valid section of the address space.\n\t */\n\taddr = get_unmapped_area(file, addr, len, pgoff, flags);\n\tif (offset_in_page(addr))\n\t\treturn addr;\n\n\tif (flags & MAP_FIXED_NOREPLACE) {\n\t\tstruct vm_area_struct *vma = find_vma(mm, addr);\n\n\t\tif (vma && vma->vm_start < addr + len)\n\t\t\treturn -EEXIST;\n\t}\n\n\tif (prot == PROT_EXEC) {\n\t\tpkey = execute_only_pkey(mm);\n\t\tif (pkey < 0)\n\t\t\tpkey = 0;\n\t}\n\n\t/* Do simple checking here so the lower-level routines won't have\n\t * to. we assume access permissions have been handled by the open\n\t * of the memory object, so we don't do any here.\n\t */\n\tvm_flags |= calc_vm_prot_bits(prot, pkey) | calc_vm_flag_bits(flags) |\n\t\t\tmm->def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;\n\n\tif (flags & MAP_LOCKED)\n\t\tif (!can_do_mlock())\n\t\t\treturn -EPERM;\n\n\tif (mlock_future_check(mm, vm_flags, len))\n\t\treturn -EAGAIN;\n\n\tif (file) {\n\t\tstruct inode *inode = file_inode(file);\n\t\tunsigned long flags_mask;\n\n\t\tif (!file_mmap_ok(file, inode, pgoff, len))\n\t\t\treturn -EOVERFLOW;\n\n\t\tflags_mask = LEGACY_MAP_MASK | file->f_op->mmap_supported_flags;\n\n\t\tswitch (flags & MAP_TYPE) {\n\t\tcase MAP_SHARED:\n\t\t\t/*\n\t\t\t * Force use of MAP_SHARED_VALIDATE with non-legacy\n\t\t\t * flags. E.g. MAP_SYNC is dangerous to use with\n\t\t\t * MAP_SHARED as you don't know which consistency model\n\t\t\t * you will get. We silently ignore unsupported flags\n\t\t\t * with MAP_SHARED to preserve backward compatibility.\n\t\t\t */\n\t\t\tflags &= LEGACY_MAP_MASK;\n\t\t\t/* fall through */\n\t\tcase MAP_SHARED_VALIDATE:\n\t\t\tif (flags & ~flags_mask)\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\tif ((prot&PROT_WRITE) && !(file->f_mode&FMODE_WRITE))\n\t\t\t\treturn -EACCES;\n\n\t\t\t/*\n\t\t\t * Make sure we don't allow writing to an append-only\n\t\t\t * file..\n\t\t\t */\n\t\t\tif (IS_APPEND(inode) && (file->f_mode & FMODE_WRITE))\n\t\t\t\treturn -EACCES;\n\n\t\t\t/*\n\t\t\t * Make sure there are no mandatory locks on the file.\n\t\t\t */\n\t\t\tif (locks_verify_locked(file))\n\t\t\t\treturn -EAGAIN;\n\n\t\t\tvm_flags |= VM_SHARED | VM_MAYSHARE;\n\t\t\tif (!(file->f_mode & FMODE_WRITE))\n\t\t\t\tvm_flags &= ~(VM_MAYWRITE | VM_SHARED);\n\n\t\t\t/* fall through */\n\t\tcase MAP_PRIVATE:\n\t\t\tif (!(file->f_mode & FMODE_READ))\n\t\t\t\treturn -EACCES;\n\t\t\tif (path_noexec(&file->f_path)) {\n\t\t\t\tif (vm_flags & VM_EXEC)\n\t\t\t\t\treturn -EPERM;\n\t\t\t\tvm_flags &= ~VM_MAYEXEC;\n\t\t\t}\n\n\t\t\tif (!file->f_op->mmap)\n\t\t\t\treturn -ENODEV;\n\t\t\tif (vm_flags & (VM_GROWSDOWN|VM_GROWSUP))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tswitch (flags & MAP_TYPE) {\n\t\tcase MAP_SHARED:\n\t\t\tif (vm_flags & (VM_GROWSDOWN|VM_GROWSUP))\n\t\t\t\treturn -EINVAL;\n\t\t\t/*\n\t\t\t * Ignore pgoff.\n\t\t\t */\n\t\t\tpgoff = 0;\n\t\t\tvm_flags |= VM_SHARED | VM_MAYSHARE;\n\t\t\tbreak;\n\t\tcase MAP_PRIVATE:\n\t\t\t/*\n\t\t\t * Set pgoff according to addr for anon_vma.\n\t\t\t */\n\t\t\tpgoff = addr >> PAGE_SHIFT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * Set 'VM_NORESERVE' if we should not account for the\n\t * memory use of this mapping.\n\t */\n\tif (flags & MAP_NORESERVE) {\n\t\t/* We honor MAP_NORESERVE if allowed to overcommit */\n\t\tif (sysctl_overcommit_memory != OVERCOMMIT_NEVER)\n\t\t\tvm_flags |= VM_NORESERVE;\n\n\t\t/* hugetlb applies strict overcommit unless MAP_NORESERVE */\n\t\tif (file && is_file_hugepages(file))\n\t\t\tvm_flags |= VM_NORESERVE;\n\t}\n\n\taddr = mmap_region(file, addr, len, vm_flags, pgoff, uf);\n\tif (!IS_ERR_VALUE(addr) &&\n\t    ((vm_flags & VM_LOCKED) ||\n\t     (flags & (MAP_POPULATE | MAP_NONBLOCK)) == MAP_POPULATE))\n\t\t*populate = len;\n\treturn addr;\n}\n\nunsigned long ksys_mmap_pgoff(unsigned long addr, unsigned long len,\n\t\t\t      unsigned long prot, unsigned long flags,\n\t\t\t      unsigned long fd, unsigned long pgoff)\n{\n\tstruct file *file = NULL;\n\tunsigned long retval;\n\n\tif (!(flags & MAP_ANONYMOUS)) {\n\t\taudit_mmap_fd(fd, flags);\n\t\tfile = fget(fd);\n\t\tif (!file)\n\t\t\treturn -EBADF;\n\t\tif (is_file_hugepages(file))\n\t\t\tlen = ALIGN(len, huge_page_size(hstate_file(file)));\n\t\tretval = -EINVAL;\n\t\tif (unlikely(flags & MAP_HUGETLB && !is_file_hugepages(file)))\n\t\t\tgoto out_fput;\n\t} else if (flags & MAP_HUGETLB) {\n\t\tstruct user_struct *user = NULL;\n\t\tstruct hstate *hs;\n\n\t\ths = hstate_sizelog((flags >> MAP_HUGE_SHIFT) & MAP_HUGE_MASK);\n\t\tif (!hs)\n\t\t\treturn -EINVAL;\n\n\t\tlen = ALIGN(len, huge_page_size(hs));\n\t\t/*\n\t\t * VM_NORESERVE is used because the reservations will be\n\t\t * taken when vm_ops->mmap() is called\n\t\t * A dummy user value is used because we are not locking\n\t\t * memory so no accounting is necessary\n\t\t */\n\t\tfile = hugetlb_file_setup(HUGETLB_ANON_FILE, len,\n\t\t\t\tVM_NORESERVE,\n\t\t\t\t&user, HUGETLB_ANONHUGE_INODE,\n\t\t\t\t(flags >> MAP_HUGE_SHIFT) & MAP_HUGE_MASK);\n\t\tif (IS_ERR(file))\n\t\t\treturn PTR_ERR(file);\n\t}\n\n\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n\n\tretval = vm_mmap_pgoff(file, addr, len, prot, flags, pgoff);\nout_fput:\n\tif (file)\n\t\tfput(file);\n\treturn retval;\n}\n\nSYSCALL_DEFINE6(mmap_pgoff, unsigned long, addr, unsigned long, len,\n\t\tunsigned long, prot, unsigned long, flags,\n\t\tunsigned long, fd, unsigned long, pgoff)\n{\n\treturn ksys_mmap_pgoff(addr, len, prot, flags, fd, pgoff);\n}\n\n#ifdef __ARCH_WANT_SYS_OLD_MMAP\nstruct mmap_arg_struct {\n\tunsigned long addr;\n\tunsigned long len;\n\tunsigned long prot;\n\tunsigned long flags;\n\tunsigned long fd;\n\tunsigned long offset;\n};\n\nSYSCALL_DEFINE1(old_mmap, struct mmap_arg_struct __user *, arg)\n{\n\tstruct mmap_arg_struct a;\n\n\tif (copy_from_user(&a, arg, sizeof(a)))\n\t\treturn -EFAULT;\n\tif (offset_in_page(a.offset))\n\t\treturn -EINVAL;\n\n\treturn ksys_mmap_pgoff(a.addr, a.len, a.prot, a.flags, a.fd,\n\t\t\t       a.offset >> PAGE_SHIFT);\n}\n#endif /* __ARCH_WANT_SYS_OLD_MMAP */\n\n/*\n * Some shared mappigns will want the pages marked read-only\n * to track write events. If so, we'll downgrade vm_page_prot\n * to the private version (using protection_map[] without the\n * VM_SHARED bit).\n */\nint vma_wants_writenotify(struct vm_area_struct *vma, pgprot_t vm_page_prot)\n{\n\tvm_flags_t vm_flags = vma->vm_flags;\n\tconst struct vm_operations_struct *vm_ops = vma->vm_ops;\n\n\t/* If it was private or non-writable, the write bit is already clear */\n\tif ((vm_flags & (VM_WRITE|VM_SHARED)) != ((VM_WRITE|VM_SHARED)))\n\t\treturn 0;\n\n\t/* The backer wishes to know when pages are first written to? */\n\tif (vm_ops && (vm_ops->page_mkwrite || vm_ops->pfn_mkwrite))\n\t\treturn 1;\n\n\t/* The open routine did something to the protections that pgprot_modify\n\t * won't preserve? */\n\tif (pgprot_val(vm_page_prot) !=\n\t    pgprot_val(vm_pgprot_modify(vm_page_prot, vm_flags)))\n\t\treturn 0;\n\n\t/* Do we need to track softdirty? */\n\tif (IS_ENABLED(CONFIG_MEM_SOFT_DIRTY) && !(vm_flags & VM_SOFTDIRTY))\n\t\treturn 1;\n\n\t/* Specialty mapping? */\n\tif (vm_flags & VM_PFNMAP)\n\t\treturn 0;\n\n\t/* Can the mapping track the dirty pages? */\n\treturn vma->vm_file && vma->vm_file->f_mapping &&\n\t\tmapping_cap_account_dirty(vma->vm_file->f_mapping);\n}\n\n/*\n * We account for memory if it's a private writeable mapping,\n * not hugepages and VM_NORESERVE wasn't set.\n */\nstatic inline int accountable_mapping(struct file *file, vm_flags_t vm_flags)\n{\n\t/*\n\t * hugetlb has its own accounting separate from the core VM\n\t * VM_HUGETLB may not be set yet so we cannot check for that flag.\n\t */\n\tif (file && is_file_hugepages(file))\n\t\treturn 0;\n\n\treturn (vm_flags & (VM_NORESERVE | VM_SHARED | VM_WRITE)) == VM_WRITE;\n}\n\nunsigned long mmap_region(struct file *file, unsigned long addr,\n\t\tunsigned long len, vm_flags_t vm_flags, unsigned long pgoff,\n\t\tstruct list_head *uf)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma, *prev;\n\tint error;\n\tstruct rb_node **rb_link, *rb_parent;\n\tunsigned long charged = 0;\n\n\t/* Check against address space limit. */\n\tif (!may_expand_vm(mm, vm_flags, len >> PAGE_SHIFT)) {\n\t\tunsigned long nr_pages;\n\n\t\t/*\n\t\t * MAP_FIXED may remove pages of mappings that intersects with\n\t\t * requested mapping. Account for the pages it would unmap.\n\t\t */\n\t\tnr_pages = count_vma_pages_range(mm, addr, addr + len);\n\n\t\tif (!may_expand_vm(mm, vm_flags,\n\t\t\t\t\t(len >> PAGE_SHIFT) - nr_pages))\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Clear old maps */\n\twhile (find_vma_links(mm, addr, addr + len, &prev, &rb_link,\n\t\t\t      &rb_parent)) {\n\t\tif (do_munmap(mm, addr, len, uf))\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * Private writable mapping: check memory availability\n\t */\n\tif (accountable_mapping(file, vm_flags)) {\n\t\tcharged = len >> PAGE_SHIFT;\n\t\tif (security_vm_enough_memory_mm(mm, charged))\n\t\t\treturn -ENOMEM;\n\t\tvm_flags |= VM_ACCOUNT;\n\t}\n\n\t/*\n\t * Can we just expand an old mapping?\n\t */\n\tvma = vma_merge(mm, prev, addr, addr + len, vm_flags,\n\t\t\tNULL, file, pgoff, NULL, NULL_VM_UFFD_CTX);\n\tif (vma)\n\t\tgoto out;\n\n\t/*\n\t * Determine the object being mapped and call the appropriate\n\t * specific mapper. the address has already been validated, but\n\t * not unmapped, but the maps are removed from the list.\n\t */\n\tvma = vm_area_alloc(mm);\n\tif (!vma) {\n\t\terror = -ENOMEM;\n\t\tgoto unacct_error;\n\t}\n\n\tvma->vm_start = addr;\n\tvma->vm_end = addr + len;\n\tvma->vm_flags = vm_flags;\n\tvma->vm_page_prot = vm_get_page_prot(vm_flags);\n\tvma->vm_pgoff = pgoff;\n\n\tif (file) {\n\t\tif (vm_flags & VM_DENYWRITE) {\n\t\t\terror = deny_write_access(file);\n\t\t\tif (error)\n\t\t\t\tgoto free_vma;\n\t\t}\n\t\tif (vm_flags & VM_SHARED) {\n\t\t\terror = mapping_map_writable(file->f_mapping);\n\t\t\tif (error)\n\t\t\t\tgoto allow_write_and_free_vma;\n\t\t}\n\n\t\t/* ->mmap() can change vma->vm_file, but must guarantee that\n\t\t * vma_link() below can deny write-access if VM_DENYWRITE is set\n\t\t * and map writably if VM_SHARED is set. This usually means the\n\t\t * new file must not have been exposed to user-space, yet.\n\t\t */\n\t\tvma->vm_file = get_file(file);\n\t\terror = call_mmap(file, vma);\n\t\tif (error)\n\t\t\tgoto unmap_and_free_vma;\n\n\t\t/* Can addr have changed??\n\t\t *\n\t\t * Answer: Yes, several device drivers can do it in their\n\t\t *         f_op->mmap method. -DaveM\n\t\t * Bug: If addr is changed, prev, rb_link, rb_parent should\n\t\t *      be updated for vma_link()\n\t\t */\n\t\tWARN_ON_ONCE(addr != vma->vm_start);\n\n\t\taddr = vma->vm_start;\n\t\tvm_flags = vma->vm_flags;\n\t} else if (vm_flags & VM_SHARED) {\n\t\terror = shmem_zero_setup(vma);\n\t\tif (error)\n\t\t\tgoto free_vma;\n\t} else {\n\t\tvma_set_anonymous(vma);\n\t}\n\n\tvma_link(mm, vma, prev, rb_link, rb_parent);\n\t/* Once vma denies write, undo our temporary denial count */\n\tif (file) {\n\t\tif (vm_flags & VM_SHARED)\n\t\t\tmapping_unmap_writable(file->f_mapping);\n\t\tif (vm_flags & VM_DENYWRITE)\n\t\t\tallow_write_access(file);\n\t}\n\tfile = vma->vm_file;\nout:\n\tperf_event_mmap(vma);\n\n\tvm_stat_account(mm, vm_flags, len >> PAGE_SHIFT);\n\tif (vm_flags & VM_LOCKED) {\n\t\tif ((vm_flags & VM_SPECIAL) || vma_is_dax(vma) ||\n\t\t\t\t\tis_vm_hugetlb_page(vma) ||\n\t\t\t\t\tvma == get_gate_vma(current->mm))\n\t\t\tvma->vm_flags &= VM_LOCKED_CLEAR_MASK;\n\t\telse\n\t\t\tmm->locked_vm += (len >> PAGE_SHIFT);\n\t}\n\n\tif (file)\n\t\tuprobe_mmap(vma);\n\n\t/*\n\t * New (or expanded) vma always get soft dirty status.\n\t * Otherwise user-space soft-dirty page tracker won't\n\t * be able to distinguish situation when vma area unmapped,\n\t * then new mapped in-place (which must be aimed as\n\t * a completely new data area).\n\t */\n\tvma->vm_flags |= VM_SOFTDIRTY;\n\n\tvma_set_page_prot(vma);\n\n\treturn addr;\n\nunmap_and_free_vma:\n\tvma->vm_file = NULL;\n\tfput(file);\n\n\t/* Undo any partial mapping done by a device driver. */\n\tunmap_region(mm, vma, prev, vma->vm_start, vma->vm_end);\n\tcharged = 0;\n\tif (vm_flags & VM_SHARED)\n\t\tmapping_unmap_writable(file->f_mapping);\nallow_write_and_free_vma:\n\tif (vm_flags & VM_DENYWRITE)\n\t\tallow_write_access(file);\nfree_vma:\n\tvm_area_free(vma);\nunacct_error:\n\tif (charged)\n\t\tvm_unacct_memory(charged);\n\treturn error;\n}\n\nunsigned long unmapped_area(struct vm_unmapped_area_info *info)\n{\n\t/*\n\t * We implement the search by looking for an rbtree node that\n\t * immediately follows a suitable gap. That is,\n\t * - gap_start = vma->vm_prev->vm_end <= info->high_limit - length;\n\t * - gap_end   = vma->vm_start        >= info->low_limit  + length;\n\t * - gap_end - gap_start >= length\n\t */\n\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tunsigned long length, low_limit, high_limit, gap_start, gap_end;\n\n\t/* Adjust search length to account for worst case alignment overhead */\n\tlength = info->length + info->align_mask;\n\tif (length < info->length)\n\t\treturn -ENOMEM;\n\n\t/* Adjust search limits by the desired length */\n\tif (info->high_limit < length)\n\t\treturn -ENOMEM;\n\thigh_limit = info->high_limit - length;\n\n\tif (info->low_limit > high_limit)\n\t\treturn -ENOMEM;\n\tlow_limit = info->low_limit + length;\n\n\t/* Check if rbtree root looks promising */\n\tif (RB_EMPTY_ROOT(&mm->mm_rb))\n\t\tgoto check_highest;\n\tvma = rb_entry(mm->mm_rb.rb_node, struct vm_area_struct, vm_rb);\n\tif (vma->rb_subtree_gap < length)\n\t\tgoto check_highest;\n\n\twhile (true) {\n\t\t/* Visit left subtree if it looks promising */\n\t\tgap_end = vm_start_gap(vma);\n\t\tif (gap_end >= low_limit && vma->vm_rb.rb_left) {\n\t\t\tstruct vm_area_struct *left =\n\t\t\t\trb_entry(vma->vm_rb.rb_left,\n\t\t\t\t\t struct vm_area_struct, vm_rb);\n\t\t\tif (left->rb_subtree_gap >= length) {\n\t\t\t\tvma = left;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tgap_start = vma->vm_prev ? vm_end_gap(vma->vm_prev) : 0;\ncheck_current:\n\t\t/* Check if current node has a suitable gap */\n\t\tif (gap_start > high_limit)\n\t\t\treturn -ENOMEM;\n\t\tif (gap_end >= low_limit &&\n\t\t    gap_end > gap_start && gap_end - gap_start >= length)\n\t\t\tgoto found;\n\n\t\t/* Visit right subtree if it looks promising */\n\t\tif (vma->vm_rb.rb_right) {\n\t\t\tstruct vm_area_struct *right =\n\t\t\t\trb_entry(vma->vm_rb.rb_right,\n\t\t\t\t\t struct vm_area_struct, vm_rb);\n\t\t\tif (right->rb_subtree_gap >= length) {\n\t\t\t\tvma = right;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* Go back up the rbtree to find next candidate node */\n\t\twhile (true) {\n\t\t\tstruct rb_node *prev = &vma->vm_rb;\n\t\t\tif (!rb_parent(prev))\n\t\t\t\tgoto check_highest;\n\t\t\tvma = rb_entry(rb_parent(prev),\n\t\t\t\t       struct vm_area_struct, vm_rb);\n\t\t\tif (prev == vma->vm_rb.rb_left) {\n\t\t\t\tgap_start = vm_end_gap(vma->vm_prev);\n\t\t\t\tgap_end = vm_start_gap(vma);\n\t\t\t\tgoto check_current;\n\t\t\t}\n\t\t}\n\t}\n\ncheck_highest:\n\t/* Check highest gap, which does not precede any rbtree node */\n\tgap_start = mm->highest_vm_end;\n\tgap_end = ULONG_MAX;  /* Only for VM_BUG_ON below */\n\tif (gap_start > high_limit)\n\t\treturn -ENOMEM;\n\nfound:\n\t/* We found a suitable gap. Clip it with the original low_limit. */\n\tif (gap_start < info->low_limit)\n\t\tgap_start = info->low_limit;\n\n\t/* Adjust gap address to the desired alignment */\n\tgap_start += (info->align_offset - gap_start) & info->align_mask;\n\n\tVM_BUG_ON(gap_start + info->length > info->high_limit);\n\tVM_BUG_ON(gap_start + info->length > gap_end);\n\treturn gap_start;\n}\n\nunsigned long unmapped_area_topdown(struct vm_unmapped_area_info *info)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tunsigned long length, low_limit, high_limit, gap_start, gap_end;\n\n\t/* Adjust search length to account for worst case alignment overhead */\n\tlength = info->length + info->align_mask;\n\tif (length < info->length)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Adjust search limits by the desired length.\n\t * See implementation comment at top of unmapped_area().\n\t */\n\tgap_end = info->high_limit;\n\tif (gap_end < length)\n\t\treturn -ENOMEM;\n\thigh_limit = gap_end - length;\n\n\tif (info->low_limit > high_limit)\n\t\treturn -ENOMEM;\n\tlow_limit = info->low_limit + length;\n\n\t/* Check highest gap, which does not precede any rbtree node */\n\tgap_start = mm->highest_vm_end;\n\tif (gap_start <= high_limit)\n\t\tgoto found_highest;\n\n\t/* Check if rbtree root looks promising */\n\tif (RB_EMPTY_ROOT(&mm->mm_rb))\n\t\treturn -ENOMEM;\n\tvma = rb_entry(mm->mm_rb.rb_node, struct vm_area_struct, vm_rb);\n\tif (vma->rb_subtree_gap < length)\n\t\treturn -ENOMEM;\n\n\twhile (true) {\n\t\t/* Visit right subtree if it looks promising */\n\t\tgap_start = vma->vm_prev ? vm_end_gap(vma->vm_prev) : 0;\n\t\tif (gap_start <= high_limit && vma->vm_rb.rb_right) {\n\t\t\tstruct vm_area_struct *right =\n\t\t\t\trb_entry(vma->vm_rb.rb_right,\n\t\t\t\t\t struct vm_area_struct, vm_rb);\n\t\t\tif (right->rb_subtree_gap >= length) {\n\t\t\t\tvma = right;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\ncheck_current:\n\t\t/* Check if current node has a suitable gap */\n\t\tgap_end = vm_start_gap(vma);\n\t\tif (gap_end < low_limit)\n\t\t\treturn -ENOMEM;\n\t\tif (gap_start <= high_limit &&\n\t\t    gap_end > gap_start && gap_end - gap_start >= length)\n\t\t\tgoto found;\n\n\t\t/* Visit left subtree if it looks promising */\n\t\tif (vma->vm_rb.rb_left) {\n\t\t\tstruct vm_area_struct *left =\n\t\t\t\trb_entry(vma->vm_rb.rb_left,\n\t\t\t\t\t struct vm_area_struct, vm_rb);\n\t\t\tif (left->rb_subtree_gap >= length) {\n\t\t\t\tvma = left;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* Go back up the rbtree to find next candidate node */\n\t\twhile (true) {\n\t\t\tstruct rb_node *prev = &vma->vm_rb;\n\t\t\tif (!rb_parent(prev))\n\t\t\t\treturn -ENOMEM;\n\t\t\tvma = rb_entry(rb_parent(prev),\n\t\t\t\t       struct vm_area_struct, vm_rb);\n\t\t\tif (prev == vma->vm_rb.rb_right) {\n\t\t\t\tgap_start = vma->vm_prev ?\n\t\t\t\t\tvm_end_gap(vma->vm_prev) : 0;\n\t\t\t\tgoto check_current;\n\t\t\t}\n\t\t}\n\t}\n\nfound:\n\t/* We found a suitable gap. Clip it with the original high_limit. */\n\tif (gap_end > info->high_limit)\n\t\tgap_end = info->high_limit;\n\nfound_highest:\n\t/* Compute highest gap address at the desired alignment */\n\tgap_end -= info->length;\n\tgap_end -= (gap_end - info->align_offset) & info->align_mask;\n\n\tVM_BUG_ON(gap_end < info->low_limit);\n\tVM_BUG_ON(gap_end < gap_start);\n\treturn gap_end;\n}\n\n\n#ifndef arch_get_mmap_end\n#define arch_get_mmap_end(addr)\t(TASK_SIZE)\n#endif\n\n#ifndef arch_get_mmap_base\n#define arch_get_mmap_base(addr, base) (base)\n#endif\n\n/* Get an address range which is currently unmapped.\n * For shmat() with addr=0.\n *\n * Ugly calling convention alert:\n * Return value with the low bits set means error value,\n * ie\n *\tif (ret & ~PAGE_MASK)\n *\t\terror = ret;\n *\n * This function \"knows\" that -ENOMEM has the bits set.\n */\n#ifndef HAVE_ARCH_UNMAPPED_AREA\nunsigned long\narch_get_unmapped_area(struct file *filp, unsigned long addr,\n\t\tunsigned long len, unsigned long pgoff, unsigned long flags)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma, *prev;\n\tstruct vm_unmapped_area_info info;\n\tconst unsigned long mmap_end = arch_get_mmap_end(addr);\n\n\tif (len > mmap_end - mmap_min_addr)\n\t\treturn -ENOMEM;\n\n\tif (flags & MAP_FIXED)\n\t\treturn addr;\n\n\tif (addr) {\n\t\taddr = PAGE_ALIGN(addr);\n\t\tvma = find_vma_prev(mm, addr, &prev);\n\t\tif (mmap_end - len >= addr && addr >= mmap_min_addr &&\n\t\t    (!vma || addr + len <= vm_start_gap(vma)) &&\n\t\t    (!prev || addr >= vm_end_gap(prev)))\n\t\t\treturn addr;\n\t}\n\n\tinfo.flags = 0;\n\tinfo.length = len;\n\tinfo.low_limit = mm->mmap_base;\n\tinfo.high_limit = mmap_end;\n\tinfo.align_mask = 0;\n\treturn vm_unmapped_area(&info);\n}\n#endif\n\n/*\n * This mmap-allocator allocates new areas top-down from below the\n * stack's low limit (the base):\n */\n#ifndef HAVE_ARCH_UNMAPPED_AREA_TOPDOWN\nunsigned long\narch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,\n\t\t\t  const unsigned long len, const unsigned long pgoff,\n\t\t\t  const unsigned long flags)\n{\n\tstruct vm_area_struct *vma, *prev;\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long addr = addr0;\n\tstruct vm_unmapped_area_info info;\n\tconst unsigned long mmap_end = arch_get_mmap_end(addr);\n\n\t/* requested length too big for entire address space */\n\tif (len > mmap_end - mmap_min_addr)\n\t\treturn -ENOMEM;\n\n\tif (flags & MAP_FIXED)\n\t\treturn addr;\n\n\t/* requesting a specific address */\n\tif (addr) {\n\t\taddr = PAGE_ALIGN(addr);\n\t\tvma = find_vma_prev(mm, addr, &prev);\n\t\tif (mmap_end - len >= addr && addr >= mmap_min_addr &&\n\t\t\t\t(!vma || addr + len <= vm_start_gap(vma)) &&\n\t\t\t\t(!prev || addr >= vm_end_gap(prev)))\n\t\t\treturn addr;\n\t}\n\n\tinfo.flags = VM_UNMAPPED_AREA_TOPDOWN;\n\tinfo.length = len;\n\tinfo.low_limit = max(PAGE_SIZE, mmap_min_addr);\n\tinfo.high_limit = arch_get_mmap_base(addr, mm->mmap_base);\n\tinfo.align_mask = 0;\n\taddr = vm_unmapped_area(&info);\n\n\t/*\n\t * A failed mmap() very likely causes application failure,\n\t * so fall back to the bottom-up function here. This scenario\n\t * can happen with large stack limits and large mmap()\n\t * allocations.\n\t */\n\tif (offset_in_page(addr)) {\n\t\tVM_BUG_ON(addr != -ENOMEM);\n\t\tinfo.flags = 0;\n\t\tinfo.low_limit = TASK_UNMAPPED_BASE;\n\t\tinfo.high_limit = mmap_end;\n\t\taddr = vm_unmapped_area(&info);\n\t}\n\n\treturn addr;\n}\n#endif\n\nunsigned long\nget_unmapped_area(struct file *file, unsigned long addr, unsigned long len,\n\t\tunsigned long pgoff, unsigned long flags)\n{\n\tunsigned long (*get_area)(struct file *, unsigned long,\n\t\t\t\t  unsigned long, unsigned long, unsigned long);\n\n\tunsigned long error = arch_mmap_check(addr, len, flags);\n\tif (error)\n\t\treturn error;\n\n\t/* Careful about overflows.. */\n\tif (len > TASK_SIZE)\n\t\treturn -ENOMEM;\n\n\tget_area = current->mm->get_unmapped_area;\n\tif (file) {\n\t\tif (file->f_op->get_unmapped_area)\n\t\t\tget_area = file->f_op->get_unmapped_area;\n\t} else if (flags & MAP_SHARED) {\n\t\t/*\n\t\t * mmap_region() will call shmem_zero_setup() to create a file,\n\t\t * so use shmem's get_unmapped_area in case it can be huge.\n\t\t * do_mmap_pgoff() will clear pgoff, so match alignment.\n\t\t */\n\t\tpgoff = 0;\n\t\tget_area = shmem_get_unmapped_area;\n\t}\n\n\taddr = get_area(file, addr, len, pgoff, flags);\n\tif (IS_ERR_VALUE(addr))\n\t\treturn addr;\n\n\tif (addr > TASK_SIZE - len)\n\t\treturn -ENOMEM;\n\tif (offset_in_page(addr))\n\t\treturn -EINVAL;\n\n\terror = security_mmap_addr(addr);\n\treturn error ? error : addr;\n}\n\nEXPORT_SYMBOL(get_unmapped_area);\n\n/* Look up the first VMA which satisfies  addr < vm_end,  NULL if none. */\nstruct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct rb_node *rb_node;\n\tstruct vm_area_struct *vma;\n\n\t/* Check the cache first. */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\trb_node = mm->mm_rb.rb_node;\n\n\twhile (rb_node) {\n\t\tstruct vm_area_struct *tmp;\n\n\t\ttmp = rb_entry(rb_node, struct vm_area_struct, vm_rb);\n\n\t\tif (tmp->vm_end > addr) {\n\t\t\tvma = tmp;\n\t\t\tif (tmp->vm_start <= addr)\n\t\t\t\tbreak;\n\t\t\trb_node = rb_node->rb_left;\n\t\t} else\n\t\t\trb_node = rb_node->rb_right;\n\t}\n\n\tif (vma)\n\t\tvmacache_update(addr, vma);\n\treturn vma;\n}\n\nEXPORT_SYMBOL(find_vma);\n\n/*\n * Same as find_vma, but also return a pointer to the previous VMA in *pprev.\n */\nstruct vm_area_struct *\nfind_vma_prev(struct mm_struct *mm, unsigned long addr,\n\t\t\tstruct vm_area_struct **pprev)\n{\n\tstruct vm_area_struct *vma;\n\n\tvma = find_vma(mm, addr);\n\tif (vma) {\n\t\t*pprev = vma->vm_prev;\n\t} else {\n\t\tstruct rb_node *rb_node = mm->mm_rb.rb_node;\n\t\t*pprev = NULL;\n\t\twhile (rb_node) {\n\t\t\t*pprev = rb_entry(rb_node, struct vm_area_struct, vm_rb);\n\t\t\trb_node = rb_node->rb_right;\n\t\t}\n\t}\n\treturn vma;\n}\n\n/*\n * Verify that the stack growth is acceptable and\n * update accounting. This is shared with both the\n * grow-up and grow-down cases.\n */\nstatic int acct_stack_growth(struct vm_area_struct *vma,\n\t\t\t     unsigned long size, unsigned long grow)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long new_start;\n\n\t/* address space limit tests */\n\tif (!may_expand_vm(mm, vma->vm_flags, grow))\n\t\treturn -ENOMEM;\n\n\t/* Stack limit test */\n\tif (size > rlimit(RLIMIT_STACK))\n\t\treturn -ENOMEM;\n\n\t/* mlock limit tests */\n\tif (vma->vm_flags & VM_LOCKED) {\n\t\tunsigned long locked;\n\t\tunsigned long limit;\n\t\tlocked = mm->locked_vm + grow;\n\t\tlimit = rlimit(RLIMIT_MEMLOCK);\n\t\tlimit >>= PAGE_SHIFT;\n\t\tif (locked > limit && !capable(CAP_IPC_LOCK))\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Check to ensure the stack will not grow into a hugetlb-only region */\n\tnew_start = (vma->vm_flags & VM_GROWSUP) ? vma->vm_start :\n\t\t\tvma->vm_end - size;\n\tif (is_hugepage_only_range(vma->vm_mm, new_start, size))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Overcommit..  This must be the final test, as it will\n\t * update security statistics.\n\t */\n\tif (security_vm_enough_memory_mm(mm, grow))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n#if defined(CONFIG_STACK_GROWSUP) || defined(CONFIG_IA64)\n/*\n * PA-RISC uses this for its stack; IA64 for its Register Backing Store.\n * vma is the last one with address > vma->vm_end.  Have to extend vma.\n */\nint expand_upwards(struct vm_area_struct *vma, unsigned long address)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *next;\n\tunsigned long gap_addr;\n\tint error = 0;\n\n\tif (!(vma->vm_flags & VM_GROWSUP))\n\t\treturn -EFAULT;\n\n\t/* Guard against exceeding limits of the address space. */\n\taddress &= PAGE_MASK;\n\tif (address >= (TASK_SIZE & PAGE_MASK))\n\t\treturn -ENOMEM;\n\taddress += PAGE_SIZE;\n\n\t/* Enforce stack_guard_gap */\n\tgap_addr = address + stack_guard_gap;\n\n\t/* Guard against overflow */\n\tif (gap_addr < address || gap_addr > TASK_SIZE)\n\t\tgap_addr = TASK_SIZE;\n\n\tnext = vma->vm_next;\n\tif (next && next->vm_start < gap_addr &&\n\t\t\t(next->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) {\n\t\tif (!(next->vm_flags & VM_GROWSUP))\n\t\t\treturn -ENOMEM;\n\t\t/* Check that both stack segments have the same anon_vma? */\n\t}\n\n\t/* We must make sure the anon_vma is allocated. */\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * vma->vm_start/vm_end cannot change under us because the caller\n\t * is required to hold the mmap_sem in read mode.  We need the\n\t * anon_vma lock to serialize against concurrent expand_stacks.\n\t */\n\tanon_vma_lock_write(vma->anon_vma);\n\n\t/* Somebody else might have raced and expanded it already */\n\tif (address > vma->vm_end) {\n\t\tunsigned long size, grow;\n\n\t\tsize = address - vma->vm_start;\n\t\tgrow = (address - vma->vm_end) >> PAGE_SHIFT;\n\n\t\terror = -ENOMEM;\n\t\tif (vma->vm_pgoff + (size >> PAGE_SHIFT) >= vma->vm_pgoff) {\n\t\t\terror = acct_stack_growth(vma, size, grow);\n\t\t\tif (!error) {\n\t\t\t\t/*\n\t\t\t\t * vma_gap_update() doesn't support concurrent\n\t\t\t\t * updates, but we only hold a shared mmap_sem\n\t\t\t\t * lock here, so we need to protect against\n\t\t\t\t * concurrent vma expansions.\n\t\t\t\t * anon_vma_lock_write() doesn't help here, as\n\t\t\t\t * we don't guarantee that all growable vmas\n\t\t\t\t * in a mm share the same root anon vma.\n\t\t\t\t * So, we reuse mm->page_table_lock to guard\n\t\t\t\t * against concurrent vma expansions.\n\t\t\t\t */\n\t\t\t\tspin_lock(&mm->page_table_lock);\n\t\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\t\tmm->locked_vm += grow;\n\t\t\t\tvm_stat_account(mm, vma->vm_flags, grow);\n\t\t\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\t\t\tvma->vm_end = address;\n\t\t\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\t\t\tif (vma->vm_next)\n\t\t\t\t\tvma_gap_update(vma->vm_next);\n\t\t\t\telse\n\t\t\t\t\tmm->highest_vm_end = vm_end_gap(vma);\n\t\t\t\tspin_unlock(&mm->page_table_lock);\n\n\t\t\t\tperf_event_mmap(vma);\n\t\t\t}\n\t\t}\n\t}\n\tanon_vma_unlock_write(vma->anon_vma);\n\tkhugepaged_enter_vma_merge(vma, vma->vm_flags);\n\tvalidate_mm(mm);\n\treturn error;\n}\n#endif /* CONFIG_STACK_GROWSUP || CONFIG_IA64 */\n\n/*\n * vma is the first one with address < vma->vm_start.  Have to extend vma.\n */\nint expand_downwards(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long address)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *prev;\n\tint error = 0;\n\n\taddress &= PAGE_MASK;\n\tif (address < mmap_min_addr)\n\t\treturn -EPERM;\n\n\t/* Enforce stack_guard_gap */\n\tprev = vma->vm_prev;\n\t/* Check that both stack segments have the same anon_vma? */\n\tif (prev && !(prev->vm_flags & VM_GROWSDOWN) &&\n\t\t\t(prev->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) {\n\t\tif (address - prev->vm_end < stack_guard_gap)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* We must make sure the anon_vma is allocated. */\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * vma->vm_start/vm_end cannot change under us because the caller\n\t * is required to hold the mmap_sem in read mode.  We need the\n\t * anon_vma lock to serialize against concurrent expand_stacks.\n\t */\n\tanon_vma_lock_write(vma->anon_vma);\n\n\t/* Somebody else might have raced and expanded it already */\n\tif (address < vma->vm_start) {\n\t\tunsigned long size, grow;\n\n\t\tsize = vma->vm_end - address;\n\t\tgrow = (vma->vm_start - address) >> PAGE_SHIFT;\n\n\t\terror = -ENOMEM;\n\t\tif (grow <= vma->vm_pgoff) {\n\t\t\terror = acct_stack_growth(vma, size, grow);\n\t\t\tif (!error) {\n\t\t\t\t/*\n\t\t\t\t * vma_gap_update() doesn't support concurrent\n\t\t\t\t * updates, but we only hold a shared mmap_sem\n\t\t\t\t * lock here, so we need to protect against\n\t\t\t\t * concurrent vma expansions.\n\t\t\t\t * anon_vma_lock_write() doesn't help here, as\n\t\t\t\t * we don't guarantee that all growable vmas\n\t\t\t\t * in a mm share the same root anon vma.\n\t\t\t\t * So, we reuse mm->page_table_lock to guard\n\t\t\t\t * against concurrent vma expansions.\n\t\t\t\t */\n\t\t\t\tspin_lock(&mm->page_table_lock);\n\t\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\t\tmm->locked_vm += grow;\n\t\t\t\tvm_stat_account(mm, vma->vm_flags, grow);\n\t\t\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\t\t\tvma->vm_start = address;\n\t\t\t\tvma->vm_pgoff -= grow;\n\t\t\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\t\t\tvma_gap_update(vma);\n\t\t\t\tspin_unlock(&mm->page_table_lock);\n\n\t\t\t\tperf_event_mmap(vma);\n\t\t\t}\n\t\t}\n\t}\n\tanon_vma_unlock_write(vma->anon_vma);\n\tkhugepaged_enter_vma_merge(vma, vma->vm_flags);\n\tvalidate_mm(mm);\n\treturn error;\n}\n\n/* enforced gap between the expanding stack and other mappings. */\nunsigned long stack_guard_gap = 256UL<<PAGE_SHIFT;\n\nstatic int __init cmdline_parse_stack_guard_gap(char *p)\n{\n\tunsigned long val;\n\tchar *endptr;\n\n\tval = simple_strtoul(p, &endptr, 10);\n\tif (!*endptr)\n\t\tstack_guard_gap = val << PAGE_SHIFT;\n\n\treturn 0;\n}\n__setup(\"stack_guard_gap=\", cmdline_parse_stack_guard_gap);\n\n#ifdef CONFIG_STACK_GROWSUP\nint expand_stack(struct vm_area_struct *vma, unsigned long address)\n{\n\treturn expand_upwards(vma, address);\n}\n\nstruct vm_area_struct *\nfind_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma, *prev;\n\n\taddr &= PAGE_MASK;\n\tvma = find_vma_prev(mm, addr, &prev);\n\tif (vma && (vma->vm_start <= addr))\n\t\treturn vma;\n\tif (!prev || expand_stack(prev, addr))\n\t\treturn NULL;\n\tif (prev->vm_flags & VM_LOCKED)\n\t\tpopulate_vma_page_range(prev, addr, prev->vm_end, NULL);\n\treturn prev;\n}\n#else\nint expand_stack(struct vm_area_struct *vma, unsigned long address)\n{\n\treturn expand_downwards(vma, address);\n}\n\nstruct vm_area_struct *\nfind_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long start;\n\n\taddr &= PAGE_MASK;\n\tvma = find_vma(mm, addr);\n\tif (!vma)\n\t\treturn NULL;\n\tif (vma->vm_start <= addr)\n\t\treturn vma;\n\tif (!(vma->vm_flags & VM_GROWSDOWN))\n\t\treturn NULL;\n\tstart = vma->vm_start;\n\tif (expand_stack(vma, addr))\n\t\treturn NULL;\n\tif (vma->vm_flags & VM_LOCKED)\n\t\tpopulate_vma_page_range(vma, addr, start, NULL);\n\treturn vma;\n}\n#endif\n\nEXPORT_SYMBOL_GPL(find_extend_vma);\n\n/*\n * Ok - we have the memory areas we should free on the vma list,\n * so release them, and do the vma updates.\n *\n * Called with the mm semaphore held.\n */\nstatic void remove_vma_list(struct mm_struct *mm, struct vm_area_struct *vma)\n{\n\tunsigned long nr_accounted = 0;\n\n\t/* Update high watermark before we lower total_vm */\n\tupdate_hiwater_vm(mm);\n\tdo {\n\t\tlong nrpages = vma_pages(vma);\n\n\t\tif (vma->vm_flags & VM_ACCOUNT)\n\t\t\tnr_accounted += nrpages;\n\t\tvm_stat_account(mm, vma->vm_flags, -nrpages);\n\t\tvma = remove_vma(vma);\n\t} while (vma);\n\tvm_unacct_memory(nr_accounted);\n\tvalidate_mm(mm);\n}\n\n/*\n * Get rid of page table information in the indicated region.\n *\n * Called with the mm semaphore held.\n */\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end)\n{\n\tstruct vm_area_struct *next = prev ? prev->vm_next : mm->mmap;\n\tstruct mmu_gather tlb;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, start, end);\n\tupdate_hiwater_rss(mm);\n\tunmap_vmas(&tlb, vma, start, end);\n\tfree_pgtables(&tlb, vma, prev ? prev->vm_end : FIRST_USER_ADDRESS,\n\t\t\t\t next ? next->vm_start : USER_PGTABLES_CEILING);\n\ttlb_finish_mmu(&tlb, start, end);\n}\n\n/*\n * Create a list of vma's touched by the unmap, removing them from the mm's\n * vma list as we go..\n */\nstatic void\ndetach_vmas_to_be_unmapped(struct mm_struct *mm, struct vm_area_struct *vma,\n\tstruct vm_area_struct *prev, unsigned long end)\n{\n\tstruct vm_area_struct **insertion_point;\n\tstruct vm_area_struct *tail_vma = NULL;\n\n\tinsertion_point = (prev ? &prev->vm_next : &mm->mmap);\n\tvma->vm_prev = NULL;\n\tdo {\n\t\tvma_rb_erase(vma, &mm->mm_rb);\n\t\tmm->map_count--;\n\t\ttail_vma = vma;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\n\t*insertion_point = vma;\n\tif (vma) {\n\t\tvma->vm_prev = prev;\n\t\tvma_gap_update(vma);\n\t} else\n\t\tmm->highest_vm_end = prev ? vm_end_gap(prev) : 0;\n\ttail_vma->vm_next = NULL;\n\n\t/* Kill the cache */\n\tvmacache_invalidate(mm);\n}\n\n/*\n * __split_vma() bypasses sysctl_max_map_count checking.  We use this where it\n * has already been checked or doesn't make sense to fail.\n */\nint __split_vma(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long addr, int new_below)\n{\n\tstruct vm_area_struct *new;\n\tint err;\n\n\tif (vma->vm_ops && vma->vm_ops->split) {\n\t\terr = vma->vm_ops->split(vma, addr);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tnew = vm_area_dup(vma);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (new_below)\n\t\tnew->vm_end = addr;\n\telse {\n\t\tnew->vm_start = addr;\n\t\tnew->vm_pgoff += ((addr - vma->vm_start) >> PAGE_SHIFT);\n\t}\n\n\terr = vma_dup_policy(vma, new);\n\tif (err)\n\t\tgoto out_free_vma;\n\n\terr = anon_vma_clone(new, vma);\n\tif (err)\n\t\tgoto out_free_mpol;\n\n\tif (new->vm_file)\n\t\tget_file(new->vm_file);\n\n\tif (new->vm_ops && new->vm_ops->open)\n\t\tnew->vm_ops->open(new);\n\n\tif (new_below)\n\t\terr = vma_adjust(vma, addr, vma->vm_end, vma->vm_pgoff +\n\t\t\t((addr - new->vm_start) >> PAGE_SHIFT), new);\n\telse\n\t\terr = vma_adjust(vma, vma->vm_start, addr, vma->vm_pgoff, new);\n\n\t/* Success. */\n\tif (!err)\n\t\treturn 0;\n\n\t/* Clean everything up if vma_adjust failed. */\n\tif (new->vm_ops && new->vm_ops->close)\n\t\tnew->vm_ops->close(new);\n\tif (new->vm_file)\n\t\tfput(new->vm_file);\n\tunlink_anon_vmas(new);\n out_free_mpol:\n\tmpol_put(vma_policy(new));\n out_free_vma:\n\tvm_area_free(new);\n\treturn err;\n}\n\n/*\n * Split a vma into two pieces at address 'addr', a new vma is allocated\n * either for the first part or the tail.\n */\nint split_vma(struct mm_struct *mm, struct vm_area_struct *vma,\n\t      unsigned long addr, int new_below)\n{\n\tif (mm->map_count >= sysctl_max_map_count)\n\t\treturn -ENOMEM;\n\n\treturn __split_vma(mm, vma, addr, new_below);\n}\n\n/* Munmap is split into 2 main parts -- this part which finds\n * what needs doing, and the areas themselves, which do the\n * work.  This now handles partial unmappings.\n * Jeremy Fitzhardinge <jeremy@goop.org>\n */\nint __do_munmap(struct mm_struct *mm, unsigned long start, size_t len,\n\t\tstruct list_head *uf, bool downgrade)\n{\n\tunsigned long end;\n\tstruct vm_area_struct *vma, *prev, *last;\n\n\tif ((offset_in_page(start)) || start > TASK_SIZE || len > TASK_SIZE-start)\n\t\treturn -EINVAL;\n\n\tlen = PAGE_ALIGN(len);\n\tif (len == 0)\n\t\treturn -EINVAL;\n\n\t/* Find the first overlapping VMA */\n\tvma = find_vma(mm, start);\n\tif (!vma)\n\t\treturn 0;\n\tprev = vma->vm_prev;\n\t/* we have  start < vma->vm_end  */\n\n\t/* if it doesn't overlap, we have nothing.. */\n\tend = start + len;\n\tif (vma->vm_start >= end)\n\t\treturn 0;\n\n\t/*\n\t * If we need to split any vma, do it now to save pain later.\n\t *\n\t * Note: mremap's move_vma VM_ACCOUNT handling assumes a partially\n\t * unmapped vm_area_struct will remain in use: so lower split_vma\n\t * places tmp vma above, and higher split_vma places tmp vma below.\n\t */\n\tif (start > vma->vm_start) {\n\t\tint error;\n\n\t\t/*\n\t\t * Make sure that map_count on return from munmap() will\n\t\t * not exceed its limit; but let map_count go just above\n\t\t * its limit temporarily, to help free resources as expected.\n\t\t */\n\t\tif (end < vma->vm_end && mm->map_count >= sysctl_max_map_count)\n\t\t\treturn -ENOMEM;\n\n\t\terror = __split_vma(mm, vma, start, 0);\n\t\tif (error)\n\t\t\treturn error;\n\t\tprev = vma;\n\t}\n\n\t/* Does it split the last one? */\n\tlast = find_vma(mm, end);\n\tif (last && end > last->vm_start) {\n\t\tint error = __split_vma(mm, last, end, 1);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tvma = prev ? prev->vm_next : mm->mmap;\n\n\tif (unlikely(uf)) {\n\t\t/*\n\t\t * If userfaultfd_unmap_prep returns an error the vmas\n\t\t * will remain splitted, but userland will get a\n\t\t * highly unexpected error anyway. This is no\n\t\t * different than the case where the first of the two\n\t\t * __split_vma fails, but we don't undo the first\n\t\t * split, despite we could. This is unlikely enough\n\t\t * failure that it's not worth optimizing it for.\n\t\t */\n\t\tint error = userfaultfd_unmap_prep(vma, start, end, uf);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * unlock any mlock()ed ranges before detaching vmas\n\t */\n\tif (mm->locked_vm) {\n\t\tstruct vm_area_struct *tmp = vma;\n\t\twhile (tmp && tmp->vm_start < end) {\n\t\t\tif (tmp->vm_flags & VM_LOCKED) {\n\t\t\t\tmm->locked_vm -= vma_pages(tmp);\n\t\t\t\tmunlock_vma_pages_all(tmp);\n\t\t\t}\n\n\t\t\ttmp = tmp->vm_next;\n\t\t}\n\t}\n\n\t/* Detach vmas from rbtree */\n\tdetach_vmas_to_be_unmapped(mm, vma, prev, end);\n\n\t/*\n\t * mpx unmap needs to be called with mmap_sem held for write.\n\t * It is safe to call it before unmap_region().\n\t */\n\tarch_unmap(mm, vma, start, end);\n\n\tif (downgrade)\n\t\tdowngrade_write(&mm->mmap_sem);\n\n\tunmap_region(mm, vma, prev, start, end);\n\n\t/* Fix up all other VM information */\n\tremove_vma_list(mm, vma);\n\n\treturn downgrade ? 1 : 0;\n}\n\nint do_munmap(struct mm_struct *mm, unsigned long start, size_t len,\n\t      struct list_head *uf)\n{\n\treturn __do_munmap(mm, start, len, uf, false);\n}\n\nstatic int __vm_munmap(unsigned long start, size_t len, bool downgrade)\n{\n\tint ret;\n\tstruct mm_struct *mm = current->mm;\n\tLIST_HEAD(uf);\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tret = __do_munmap(mm, start, len, &uf, downgrade);\n\t/*\n\t * Returning 1 indicates mmap_sem is downgraded.\n\t * But 1 is not legal return value of vm_munmap() and munmap(), reset\n\t * it to 0 before return.\n\t */\n\tif (ret == 1) {\n\t\tup_read(&mm->mmap_sem);\n\t\tret = 0;\n\t} else\n\t\tup_write(&mm->mmap_sem);\n\n\tuserfaultfd_unmap_complete(mm, &uf);\n\treturn ret;\n}\n\nint vm_munmap(unsigned long start, size_t len)\n{\n\treturn __vm_munmap(start, len, false);\n}\nEXPORT_SYMBOL(vm_munmap);\n\nSYSCALL_DEFINE2(munmap, unsigned long, addr, size_t, len)\n{\n\tprofile_munmap(addr);\n\treturn __vm_munmap(addr, len, true);\n}\n\n\n/*\n * Emulation of deprecated remap_file_pages() syscall.\n */\nSYSCALL_DEFINE5(remap_file_pages, unsigned long, start, unsigned long, size,\n\t\tunsigned long, prot, unsigned long, pgoff, unsigned long, flags)\n{\n\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tunsigned long populate = 0;\n\tunsigned long ret = -EINVAL;\n\tstruct file *file;\n\n\tpr_warn_once(\"%s (%d) uses deprecated remap_file_pages() syscall. See Documentation/vm/remap_file_pages.rst.\\n\",\n\t\t     current->comm, current->pid);\n\n\tif (prot)\n\t\treturn ret;\n\tstart = start & PAGE_MASK;\n\tsize = size & PAGE_MASK;\n\n\tif (start + size <= start)\n\t\treturn ret;\n\n\t/* Does pgoff wrap? */\n\tif (pgoff + (size >> PAGE_SHIFT) < pgoff)\n\t\treturn ret;\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tvma = find_vma(mm, start);\n\n\tif (!vma || !(vma->vm_flags & VM_SHARED))\n\t\tgoto out;\n\n\tif (start < vma->vm_start)\n\t\tgoto out;\n\n\tif (start + size > vma->vm_end) {\n\t\tstruct vm_area_struct *next;\n\n\t\tfor (next = vma->vm_next; next; next = next->vm_next) {\n\t\t\t/* hole between vmas ? */\n\t\t\tif (next->vm_start != next->vm_prev->vm_end)\n\t\t\t\tgoto out;\n\n\t\t\tif (next->vm_file != vma->vm_file)\n\t\t\t\tgoto out;\n\n\t\t\tif (next->vm_flags != vma->vm_flags)\n\t\t\t\tgoto out;\n\n\t\t\tif (start + size <= next->vm_end)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!next)\n\t\t\tgoto out;\n\t}\n\n\tprot |= vma->vm_flags & VM_READ ? PROT_READ : 0;\n\tprot |= vma->vm_flags & VM_WRITE ? PROT_WRITE : 0;\n\tprot |= vma->vm_flags & VM_EXEC ? PROT_EXEC : 0;\n\n\tflags &= MAP_NONBLOCK;\n\tflags |= MAP_SHARED | MAP_FIXED | MAP_POPULATE;\n\tif (vma->vm_flags & VM_LOCKED) {\n\t\tstruct vm_area_struct *tmp;\n\t\tflags |= MAP_LOCKED;\n\n\t\t/* drop PG_Mlocked flag for over-mapped range */\n\t\tfor (tmp = vma; tmp->vm_start >= start + size;\n\t\t\t\ttmp = tmp->vm_next) {\n\t\t\t/*\n\t\t\t * Split pmd and munlock page on the border\n\t\t\t * of the range.\n\t\t\t */\n\t\t\tvma_adjust_trans_huge(tmp, start, start + size, 0);\n\n\t\t\tmunlock_vma_pages_range(tmp,\n\t\t\t\t\tmax(tmp->vm_start, start),\n\t\t\t\t\tmin(tmp->vm_end, start + size));\n\t\t}\n\t}\n\n\tfile = get_file(vma->vm_file);\n\tret = do_mmap_pgoff(vma->vm_file, start, size,\n\t\t\tprot, flags, pgoff, &populate, NULL);\n\tfput(file);\nout:\n\tup_write(&mm->mmap_sem);\n\tif (populate)\n\t\tmm_populate(ret, populate);\n\tif (!IS_ERR_VALUE(ret))\n\t\tret = 0;\n\treturn ret;\n}\n\n/*\n *  this is really a simplified \"do_mmap\".  it only handles\n *  anonymous maps.  eventually we may be able to do some\n *  brk-specific accounting here.\n */\nstatic int do_brk_flags(unsigned long addr, unsigned long len, unsigned long flags, struct list_head *uf)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma, *prev;\n\tstruct rb_node **rb_link, *rb_parent;\n\tpgoff_t pgoff = addr >> PAGE_SHIFT;\n\tint error;\n\n\t/* Until we need other flags, refuse anything except VM_EXEC. */\n\tif ((flags & (~VM_EXEC)) != 0)\n\t\treturn -EINVAL;\n\tflags |= VM_DATA_DEFAULT_FLAGS | VM_ACCOUNT | mm->def_flags;\n\n\terror = get_unmapped_area(NULL, addr, len, 0, MAP_FIXED);\n\tif (offset_in_page(error))\n\t\treturn error;\n\n\terror = mlock_future_check(mm, mm->def_flags, len);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Clear old maps.  this also does some error checking for us\n\t */\n\twhile (find_vma_links(mm, addr, addr + len, &prev, &rb_link,\n\t\t\t      &rb_parent)) {\n\t\tif (do_munmap(mm, addr, len, uf))\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Check against address space limits *after* clearing old maps... */\n\tif (!may_expand_vm(mm, flags, len >> PAGE_SHIFT))\n\t\treturn -ENOMEM;\n\n\tif (mm->map_count > sysctl_max_map_count)\n\t\treturn -ENOMEM;\n\n\tif (security_vm_enough_memory_mm(mm, len >> PAGE_SHIFT))\n\t\treturn -ENOMEM;\n\n\t/* Can we just expand an old private anonymous mapping? */\n\tvma = vma_merge(mm, prev, addr, addr + len, flags,\n\t\t\tNULL, NULL, pgoff, NULL, NULL_VM_UFFD_CTX);\n\tif (vma)\n\t\tgoto out;\n\n\t/*\n\t * create a vma struct for an anonymous mapping\n\t */\n\tvma = vm_area_alloc(mm);\n\tif (!vma) {\n\t\tvm_unacct_memory(len >> PAGE_SHIFT);\n\t\treturn -ENOMEM;\n\t}\n\n\tvma_set_anonymous(vma);\n\tvma->vm_start = addr;\n\tvma->vm_end = addr + len;\n\tvma->vm_pgoff = pgoff;\n\tvma->vm_flags = flags;\n\tvma->vm_page_prot = vm_get_page_prot(flags);\n\tvma_link(mm, vma, prev, rb_link, rb_parent);\nout:\n\tperf_event_mmap(vma);\n\tmm->total_vm += len >> PAGE_SHIFT;\n\tmm->data_vm += len >> PAGE_SHIFT;\n\tif (flags & VM_LOCKED)\n\t\tmm->locked_vm += (len >> PAGE_SHIFT);\n\tvma->vm_flags |= VM_SOFTDIRTY;\n\treturn 0;\n}\n\nint vm_brk_flags(unsigned long addr, unsigned long request, unsigned long flags)\n{\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long len;\n\tint ret;\n\tbool populate;\n\tLIST_HEAD(uf);\n\n\tlen = PAGE_ALIGN(request);\n\tif (len < request)\n\t\treturn -ENOMEM;\n\tif (!len)\n\t\treturn 0;\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tret = do_brk_flags(addr, len, flags, &uf);\n\tpopulate = ((mm->def_flags & VM_LOCKED) != 0);\n\tup_write(&mm->mmap_sem);\n\tuserfaultfd_unmap_complete(mm, &uf);\n\tif (populate && !ret)\n\t\tmm_populate(addr, len);\n\treturn ret;\n}\nEXPORT_SYMBOL(vm_brk_flags);\n\nint vm_brk(unsigned long addr, unsigned long len)\n{\n\treturn vm_brk_flags(addr, len, 0);\n}\nEXPORT_SYMBOL(vm_brk);\n\n/* Release all mmaps. */\nvoid exit_mmap(struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tunsigned long nr_accounted = 0;\n\n\t/* mm's last user has gone, and its about to be pulled down */\n\tmmu_notifier_release(mm);\n\n\tif (unlikely(mm_is_oom_victim(mm))) {\n\t\t/*\n\t\t * Manually reap the mm to free as much memory as possible.\n\t\t * Then, as the oom reaper does, set MMF_OOM_SKIP to disregard\n\t\t * this mm from further consideration.  Taking mm->mmap_sem for\n\t\t * write after setting MMF_OOM_SKIP will guarantee that the oom\n\t\t * reaper will not run on this mm again after mmap_sem is\n\t\t * dropped.\n\t\t *\n\t\t * Nothing can be holding mm->mmap_sem here and the above call\n\t\t * to mmu_notifier_release(mm) ensures mmu notifier callbacks in\n\t\t * __oom_reap_task_mm() will not block.\n\t\t *\n\t\t * This needs to be done before calling munlock_vma_pages_all(),\n\t\t * which clears VM_LOCKED, otherwise the oom reaper cannot\n\t\t * reliably test it.\n\t\t */\n\t\t(void)__oom_reap_task_mm(mm);\n\n\t\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\t\tdown_write(&mm->mmap_sem);\n\t\tup_write(&mm->mmap_sem);\n\t}\n\n\tif (mm->locked_vm) {\n\t\tvma = mm->mmap;\n\t\twhile (vma) {\n\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\tmunlock_vma_pages_all(vma);\n\t\t\tvma = vma->vm_next;\n\t\t}\n\t}\n\n\tarch_exit_mmap(mm);\n\n\tvma = mm->mmap;\n\tif (!vma)\t/* Can happen if dup_mmap() received an OOM */\n\t\treturn;\n\n\tlru_add_drain();\n\tflush_cache_mm(mm);\n\ttlb_gather_mmu(&tlb, mm, 0, -1);\n\t/* update_hiwater_rss(mm) here? but nobody should be looking */\n\t/* Use -1 here to ensure all VMAs in the mm are unmapped */\n\tunmap_vmas(&tlb, vma, 0, -1);\n\tfree_pgtables(&tlb, vma, FIRST_USER_ADDRESS, USER_PGTABLES_CEILING);\n\ttlb_finish_mmu(&tlb, 0, -1);\n\n\t/*\n\t * Walk the list again, actually closing and freeing it,\n\t * with preemption enabled, without holding any MM locks.\n\t */\n\twhile (vma) {\n\t\tif (vma->vm_flags & VM_ACCOUNT)\n\t\t\tnr_accounted += vma_pages(vma);\n\t\tvma = remove_vma(vma);\n\t}\n\tvm_unacct_memory(nr_accounted);\n}\n\n/* Insert vm structure into process list sorted by address\n * and into the inode's i_mmap tree.  If vm_file is non-NULL\n * then i_mmap_rwsem is taken here.\n */\nint insert_vm_struct(struct mm_struct *mm, struct vm_area_struct *vma)\n{\n\tstruct vm_area_struct *prev;\n\tstruct rb_node **rb_link, *rb_parent;\n\n\tif (find_vma_links(mm, vma->vm_start, vma->vm_end,\n\t\t\t   &prev, &rb_link, &rb_parent))\n\t\treturn -ENOMEM;\n\tif ((vma->vm_flags & VM_ACCOUNT) &&\n\t     security_vm_enough_memory_mm(mm, vma_pages(vma)))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * The vm_pgoff of a purely anonymous vma should be irrelevant\n\t * until its first write fault, when page's anon_vma and index\n\t * are set.  But now set the vm_pgoff it will almost certainly\n\t * end up with (unless mremap moves it elsewhere before that\n\t * first wfault), so /proc/pid/maps tells a consistent story.\n\t *\n\t * By setting it to reflect the virtual start address of the\n\t * vma, merges and splits can happen in a seamless way, just\n\t * using the existing file pgoff checks and manipulations.\n\t * Similarly in do_mmap_pgoff and in do_brk.\n\t */\n\tif (vma_is_anonymous(vma)) {\n\t\tBUG_ON(vma->anon_vma);\n\t\tvma->vm_pgoff = vma->vm_start >> PAGE_SHIFT;\n\t}\n\n\tvma_link(mm, vma, prev, rb_link, rb_parent);\n\treturn 0;\n}\n\n/*\n * Copy the vma structure to a new location in the same mm,\n * prior to moving page table entries, to effect an mremap move.\n */\nstruct vm_area_struct *copy_vma(struct vm_area_struct **vmap,\n\tunsigned long addr, unsigned long len, pgoff_t pgoff,\n\tbool *need_rmap_locks)\n{\n\tstruct vm_area_struct *vma = *vmap;\n\tunsigned long vma_start = vma->vm_start;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *new_vma, *prev;\n\tstruct rb_node **rb_link, *rb_parent;\n\tbool faulted_in_anon_vma = true;\n\n\t/*\n\t * If anonymous vma has not yet been faulted, update new pgoff\n\t * to match new location, to increase its chance of merging.\n\t */\n\tif (unlikely(vma_is_anonymous(vma) && !vma->anon_vma)) {\n\t\tpgoff = addr >> PAGE_SHIFT;\n\t\tfaulted_in_anon_vma = false;\n\t}\n\n\tif (find_vma_links(mm, addr, addr + len, &prev, &rb_link, &rb_parent))\n\t\treturn NULL;\t/* should never get here */\n\tnew_vma = vma_merge(mm, prev, addr, addr + len, vma->vm_flags,\n\t\t\t    vma->anon_vma, vma->vm_file, pgoff, vma_policy(vma),\n\t\t\t    vma->vm_userfaultfd_ctx);\n\tif (new_vma) {\n\t\t/*\n\t\t * Source vma may have been merged into new_vma\n\t\t */\n\t\tif (unlikely(vma_start >= new_vma->vm_start &&\n\t\t\t     vma_start < new_vma->vm_end)) {\n\t\t\t/*\n\t\t\t * The only way we can get a vma_merge with\n\t\t\t * self during an mremap is if the vma hasn't\n\t\t\t * been faulted in yet and we were allowed to\n\t\t\t * reset the dst vma->vm_pgoff to the\n\t\t\t * destination address of the mremap to allow\n\t\t\t * the merge to happen. mremap must change the\n\t\t\t * vm_pgoff linearity between src and dst vmas\n\t\t\t * (in turn preventing a vma_merge) to be\n\t\t\t * safe. It is only safe to keep the vm_pgoff\n\t\t\t * linear if there are no pages mapped yet.\n\t\t\t */\n\t\t\tVM_BUG_ON_VMA(faulted_in_anon_vma, new_vma);\n\t\t\t*vmap = vma = new_vma;\n\t\t}\n\t\t*need_rmap_locks = (new_vma->vm_pgoff <= vma->vm_pgoff);\n\t} else {\n\t\tnew_vma = vm_area_dup(vma);\n\t\tif (!new_vma)\n\t\t\tgoto out;\n\t\tnew_vma->vm_start = addr;\n\t\tnew_vma->vm_end = addr + len;\n\t\tnew_vma->vm_pgoff = pgoff;\n\t\tif (vma_dup_policy(vma, new_vma))\n\t\t\tgoto out_free_vma;\n\t\tif (anon_vma_clone(new_vma, vma))\n\t\t\tgoto out_free_mempol;\n\t\tif (new_vma->vm_file)\n\t\t\tget_file(new_vma->vm_file);\n\t\tif (new_vma->vm_ops && new_vma->vm_ops->open)\n\t\t\tnew_vma->vm_ops->open(new_vma);\n\t\tvma_link(mm, new_vma, prev, rb_link, rb_parent);\n\t\t*need_rmap_locks = false;\n\t}\n\treturn new_vma;\n\nout_free_mempol:\n\tmpol_put(vma_policy(new_vma));\nout_free_vma:\n\tvm_area_free(new_vma);\nout:\n\treturn NULL;\n}\n\n/*\n * Return true if the calling process may expand its vm space by the passed\n * number of pages\n */\nbool may_expand_vm(struct mm_struct *mm, vm_flags_t flags, unsigned long npages)\n{\n\tif (mm->total_vm + npages > rlimit(RLIMIT_AS) >> PAGE_SHIFT)\n\t\treturn false;\n\n\tif (is_data_mapping(flags) &&\n\t    mm->data_vm + npages > rlimit(RLIMIT_DATA) >> PAGE_SHIFT) {\n\t\t/* Workaround for Valgrind */\n\t\tif (rlimit(RLIMIT_DATA) == 0 &&\n\t\t    mm->data_vm + npages <= rlimit_max(RLIMIT_DATA) >> PAGE_SHIFT)\n\t\t\treturn true;\n\n\t\tpr_warn_once(\"%s (%d): VmData %lu exceed data ulimit %lu. Update limits%s.\\n\",\n\t\t\t     current->comm, current->pid,\n\t\t\t     (mm->data_vm + npages) << PAGE_SHIFT,\n\t\t\t     rlimit(RLIMIT_DATA),\n\t\t\t     ignore_rlimit_data ? \"\" : \" or use boot option ignore_rlimit_data\");\n\n\t\tif (!ignore_rlimit_data)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid vm_stat_account(struct mm_struct *mm, vm_flags_t flags, long npages)\n{\n\tmm->total_vm += npages;\n\n\tif (is_exec_mapping(flags))\n\t\tmm->exec_vm += npages;\n\telse if (is_stack_mapping(flags))\n\t\tmm->stack_vm += npages;\n\telse if (is_data_mapping(flags))\n\t\tmm->data_vm += npages;\n}\n\nstatic vm_fault_t special_mapping_fault(struct vm_fault *vmf);\n\n/*\n * Having a close hook prevents vma merging regardless of flags.\n */\nstatic void special_mapping_close(struct vm_area_struct *vma)\n{\n}\n\nstatic const char *special_mapping_name(struct vm_area_struct *vma)\n{\n\treturn ((struct vm_special_mapping *)vma->vm_private_data)->name;\n}\n\nstatic int special_mapping_mremap(struct vm_area_struct *new_vma)\n{\n\tstruct vm_special_mapping *sm = new_vma->vm_private_data;\n\n\tif (WARN_ON_ONCE(current->mm != new_vma->vm_mm))\n\t\treturn -EFAULT;\n\n\tif (sm->mremap)\n\t\treturn sm->mremap(sm, new_vma);\n\n\treturn 0;\n}\n\nstatic const struct vm_operations_struct special_mapping_vmops = {\n\t.close = special_mapping_close,\n\t.fault = special_mapping_fault,\n\t.mremap = special_mapping_mremap,\n\t.name = special_mapping_name,\n};\n\nstatic const struct vm_operations_struct legacy_special_mapping_vmops = {\n\t.close = special_mapping_close,\n\t.fault = special_mapping_fault,\n};\n\nstatic vm_fault_t special_mapping_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tpgoff_t pgoff;\n\tstruct page **pages;\n\n\tif (vma->vm_ops == &legacy_special_mapping_vmops) {\n\t\tpages = vma->vm_private_data;\n\t} else {\n\t\tstruct vm_special_mapping *sm = vma->vm_private_data;\n\n\t\tif (sm->fault)\n\t\t\treturn sm->fault(sm, vmf->vma, vmf);\n\n\t\tpages = sm->pages;\n\t}\n\n\tfor (pgoff = vmf->pgoff; pgoff && *pages; ++pages)\n\t\tpgoff--;\n\n\tif (*pages) {\n\t\tstruct page *page = *pages;\n\t\tget_page(page);\n\t\tvmf->page = page;\n\t\treturn 0;\n\t}\n\n\treturn VM_FAULT_SIGBUS;\n}\n\nstatic struct vm_area_struct *__install_special_mapping(\n\tstruct mm_struct *mm,\n\tunsigned long addr, unsigned long len,\n\tunsigned long vm_flags, void *priv,\n\tconst struct vm_operations_struct *ops)\n{\n\tint ret;\n\tstruct vm_area_struct *vma;\n\n\tvma = vm_area_alloc(mm);\n\tif (unlikely(vma == NULL))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvma->vm_start = addr;\n\tvma->vm_end = addr + len;\n\n\tvma->vm_flags = vm_flags | mm->def_flags | VM_DONTEXPAND | VM_SOFTDIRTY;\n\tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\n\tvma->vm_ops = ops;\n\tvma->vm_private_data = priv;\n\n\tret = insert_vm_struct(mm, vma);\n\tif (ret)\n\t\tgoto out;\n\n\tvm_stat_account(mm, vma->vm_flags, len >> PAGE_SHIFT);\n\n\tperf_event_mmap(vma);\n\n\treturn vma;\n\nout:\n\tvm_area_free(vma);\n\treturn ERR_PTR(ret);\n}\n\nbool vma_is_special_mapping(const struct vm_area_struct *vma,\n\tconst struct vm_special_mapping *sm)\n{\n\treturn vma->vm_private_data == sm &&\n\t\t(vma->vm_ops == &special_mapping_vmops ||\n\t\t vma->vm_ops == &legacy_special_mapping_vmops);\n}\n\n/*\n * Called with mm->mmap_sem held for writing.\n * Insert a new vma covering the given region, with the given flags.\n * Its pages are supplied by the given array of struct page *.\n * The array can be shorter than len >> PAGE_SHIFT if it's null-terminated.\n * The region past the last page supplied will always produce SIGBUS.\n * The array pointer and the pages it points to are assumed to stay alive\n * for as long as this mapping might exist.\n */\nstruct vm_area_struct *_install_special_mapping(\n\tstruct mm_struct *mm,\n\tunsigned long addr, unsigned long len,\n\tunsigned long vm_flags, const struct vm_special_mapping *spec)\n{\n\treturn __install_special_mapping(mm, addr, len, vm_flags, (void *)spec,\n\t\t\t\t\t&special_mapping_vmops);\n}\n\nint install_special_mapping(struct mm_struct *mm,\n\t\t\t    unsigned long addr, unsigned long len,\n\t\t\t    unsigned long vm_flags, struct page **pages)\n{\n\tstruct vm_area_struct *vma = __install_special_mapping(\n\t\tmm, addr, len, vm_flags, (void *)pages,\n\t\t&legacy_special_mapping_vmops);\n\n\treturn PTR_ERR_OR_ZERO(vma);\n}\n\nstatic DEFINE_MUTEX(mm_all_locks_mutex);\n\nstatic void vm_lock_anon_vma(struct mm_struct *mm, struct anon_vma *anon_vma)\n{\n\tif (!test_bit(0, (unsigned long *) &anon_vma->root->rb_root.rb_root.rb_node)) {\n\t\t/*\n\t\t * The LSB of head.next can't change from under us\n\t\t * because we hold the mm_all_locks_mutex.\n\t\t */\n\t\tdown_write_nest_lock(&anon_vma->root->rwsem, &mm->mmap_sem);\n\t\t/*\n\t\t * We can safely modify head.next after taking the\n\t\t * anon_vma->root->rwsem. If some other vma in this mm shares\n\t\t * the same anon_vma we won't take it again.\n\t\t *\n\t\t * No need of atomic instructions here, head.next\n\t\t * can't change from under us thanks to the\n\t\t * anon_vma->root->rwsem.\n\t\t */\n\t\tif (__test_and_set_bit(0, (unsigned long *)\n\t\t\t\t       &anon_vma->root->rb_root.rb_root.rb_node))\n\t\t\tBUG();\n\t}\n}\n\nstatic void vm_lock_mapping(struct mm_struct *mm, struct address_space *mapping)\n{\n\tif (!test_bit(AS_MM_ALL_LOCKS, &mapping->flags)) {\n\t\t/*\n\t\t * AS_MM_ALL_LOCKS can't change from under us because\n\t\t * we hold the mm_all_locks_mutex.\n\t\t *\n\t\t * Operations on ->flags have to be atomic because\n\t\t * even if AS_MM_ALL_LOCKS is stable thanks to the\n\t\t * mm_all_locks_mutex, there may be other cpus\n\t\t * changing other bitflags in parallel to us.\n\t\t */\n\t\tif (test_and_set_bit(AS_MM_ALL_LOCKS, &mapping->flags))\n\t\t\tBUG();\n\t\tdown_write_nest_lock(&mapping->i_mmap_rwsem, &mm->mmap_sem);\n\t}\n}\n\n/*\n * This operation locks against the VM for all pte/vma/mm related\n * operations that could ever happen on a certain mm. This includes\n * vmtruncate, try_to_unmap, and all page faults.\n *\n * The caller must take the mmap_sem in write mode before calling\n * mm_take_all_locks(). The caller isn't allowed to release the\n * mmap_sem until mm_drop_all_locks() returns.\n *\n * mmap_sem in write mode is required in order to block all operations\n * that could modify pagetables and free pages without need of\n * altering the vma layout. It's also needed in write mode to avoid new\n * anon_vmas to be associated with existing vmas.\n *\n * A single task can't take more than one mm_take_all_locks() in a row\n * or it would deadlock.\n *\n * The LSB in anon_vma->rb_root.rb_node and the AS_MM_ALL_LOCKS bitflag in\n * mapping->flags avoid to take the same lock twice, if more than one\n * vma in this mm is backed by the same anon_vma or address_space.\n *\n * We take locks in following order, accordingly to comment at beginning\n * of mm/rmap.c:\n *   - all hugetlbfs_i_mmap_rwsem_key locks (aka mapping->i_mmap_rwsem for\n *     hugetlb mapping);\n *   - all i_mmap_rwsem locks;\n *   - all anon_vma->rwseml\n *\n * We can take all locks within these types randomly because the VM code\n * doesn't nest them and we protected from parallel mm_take_all_locks() by\n * mm_all_locks_mutex.\n *\n * mm_take_all_locks() and mm_drop_all_locks are expensive operations\n * that may have to take thousand of locks.\n *\n * mm_take_all_locks() can fail if it's interrupted by signals.\n */\nint mm_take_all_locks(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tstruct anon_vma_chain *avc;\n\n\tBUG_ON(down_read_trylock(&mm->mmap_sem));\n\n\tmutex_lock(&mm_all_locks_mutex);\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (signal_pending(current))\n\t\t\tgoto out_unlock;\n\t\tif (vma->vm_file && vma->vm_file->f_mapping &&\n\t\t\t\tis_vm_hugetlb_page(vma))\n\t\t\tvm_lock_mapping(mm, vma->vm_file->f_mapping);\n\t}\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (signal_pending(current))\n\t\t\tgoto out_unlock;\n\t\tif (vma->vm_file && vma->vm_file->f_mapping &&\n\t\t\t\t!is_vm_hugetlb_page(vma))\n\t\t\tvm_lock_mapping(mm, vma->vm_file->f_mapping);\n\t}\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (signal_pending(current))\n\t\t\tgoto out_unlock;\n\t\tif (vma->anon_vma)\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tvm_lock_anon_vma(mm, avc->anon_vma);\n\t}\n\n\treturn 0;\n\nout_unlock:\n\tmm_drop_all_locks(mm);\n\treturn -EINTR;\n}\n\nstatic void vm_unlock_anon_vma(struct anon_vma *anon_vma)\n{\n\tif (test_bit(0, (unsigned long *) &anon_vma->root->rb_root.rb_root.rb_node)) {\n\t\t/*\n\t\t * The LSB of head.next can't change to 0 from under\n\t\t * us because we hold the mm_all_locks_mutex.\n\t\t *\n\t\t * We must however clear the bitflag before unlocking\n\t\t * the vma so the users using the anon_vma->rb_root will\n\t\t * never see our bitflag.\n\t\t *\n\t\t * No need of atomic instructions here, head.next\n\t\t * can't change from under us until we release the\n\t\t * anon_vma->root->rwsem.\n\t\t */\n\t\tif (!__test_and_clear_bit(0, (unsigned long *)\n\t\t\t\t\t  &anon_vma->root->rb_root.rb_root.rb_node))\n\t\t\tBUG();\n\t\tanon_vma_unlock_write(anon_vma);\n\t}\n}\n\nstatic void vm_unlock_mapping(struct address_space *mapping)\n{\n\tif (test_bit(AS_MM_ALL_LOCKS, &mapping->flags)) {\n\t\t/*\n\t\t * AS_MM_ALL_LOCKS can't change to 0 from under us\n\t\t * because we hold the mm_all_locks_mutex.\n\t\t */\n\t\ti_mmap_unlock_write(mapping);\n\t\tif (!test_and_clear_bit(AS_MM_ALL_LOCKS,\n\t\t\t\t\t&mapping->flags))\n\t\t\tBUG();\n\t}\n}\n\n/*\n * The mmap_sem cannot be released by the caller until\n * mm_drop_all_locks() returns.\n */\nvoid mm_drop_all_locks(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tstruct anon_vma_chain *avc;\n\n\tBUG_ON(down_read_trylock(&mm->mmap_sem));\n\tBUG_ON(!mutex_is_locked(&mm_all_locks_mutex));\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->anon_vma)\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tvm_unlock_anon_vma(avc->anon_vma);\n\t\tif (vma->vm_file && vma->vm_file->f_mapping)\n\t\t\tvm_unlock_mapping(vma->vm_file->f_mapping);\n\t}\n\n\tmutex_unlock(&mm_all_locks_mutex);\n}\n\n/*\n * initialise the percpu counter for VM\n */\nvoid __init mmap_init(void)\n{\n\tint ret;\n\n\tret = percpu_counter_init(&vm_committed_as, 0, GFP_KERNEL);\n\tVM_BUG_ON(ret);\n}\n\n/*\n * Initialise sysctl_user_reserve_kbytes.\n *\n * This is intended to prevent a user from starting a single memory hogging\n * process, such that they cannot recover (kill the hog) in OVERCOMMIT_NEVER\n * mode.\n *\n * The default value is min(3% of free memory, 128MB)\n * 128MB is enough to recover with sshd/login, bash, and top/kill.\n */\nstatic int init_user_reserve(void)\n{\n\tunsigned long free_kbytes;\n\n\tfree_kbytes = global_zone_page_state(NR_FREE_PAGES) << (PAGE_SHIFT - 10);\n\n\tsysctl_user_reserve_kbytes = min(free_kbytes / 32, 1UL << 17);\n\treturn 0;\n}\nsubsys_initcall(init_user_reserve);\n\n/*\n * Initialise sysctl_admin_reserve_kbytes.\n *\n * The purpose of sysctl_admin_reserve_kbytes is to allow the sys admin\n * to log in and kill a memory hogging process.\n *\n * Systems with more than 256MB will reserve 8MB, enough to recover\n * with sshd, bash, and top in OVERCOMMIT_GUESS. Smaller systems will\n * only reserve 3% of free pages by default.\n */\nstatic int init_admin_reserve(void)\n{\n\tunsigned long free_kbytes;\n\n\tfree_kbytes = global_zone_page_state(NR_FREE_PAGES) << (PAGE_SHIFT - 10);\n\n\tsysctl_admin_reserve_kbytes = min(free_kbytes / 32, 1UL << 13);\n\treturn 0;\n}\nsubsys_initcall(init_admin_reserve);\n\n/*\n * Reinititalise user and admin reserves if memory is added or removed.\n *\n * The default user reserve max is 128MB, and the default max for the\n * admin reserve is 8MB. These are usually, but not always, enough to\n * enable recovery from a memory hogging process using login/sshd, a shell,\n * and tools like top. It may make sense to increase or even disable the\n * reserve depending on the existence of swap or variations in the recovery\n * tools. So, the admin may have changed them.\n *\n * If memory is added and the reserves have been eliminated or increased above\n * the default max, then we'll trust the admin.\n *\n * If memory is removed and there isn't enough free memory, then we\n * need to reset the reserves.\n *\n * Otherwise keep the reserve set by the admin.\n */\nstatic int reserve_mem_notifier(struct notifier_block *nb,\n\t\t\t     unsigned long action, void *data)\n{\n\tunsigned long tmp, free_kbytes;\n\n\tswitch (action) {\n\tcase MEM_ONLINE:\n\t\t/* Default max is 128MB. Leave alone if modified by operator. */\n\t\ttmp = sysctl_user_reserve_kbytes;\n\t\tif (0 < tmp && tmp < (1UL << 17))\n\t\t\tinit_user_reserve();\n\n\t\t/* Default max is 8MB.  Leave alone if modified by operator. */\n\t\ttmp = sysctl_admin_reserve_kbytes;\n\t\tif (0 < tmp && tmp < (1UL << 13))\n\t\t\tinit_admin_reserve();\n\n\t\tbreak;\n\tcase MEM_OFFLINE:\n\t\tfree_kbytes = global_zone_page_state(NR_FREE_PAGES) << (PAGE_SHIFT - 10);\n\n\t\tif (sysctl_user_reserve_kbytes > free_kbytes) {\n\t\t\tinit_user_reserve();\n\t\t\tpr_info(\"vm.user_reserve_kbytes reset to %lu\\n\",\n\t\t\t\tsysctl_user_reserve_kbytes);\n\t\t}\n\n\t\tif (sysctl_admin_reserve_kbytes > free_kbytes) {\n\t\t\tinit_admin_reserve();\n\t\t\tpr_info(\"vm.admin_reserve_kbytes reset to %lu\\n\",\n\t\t\t\tsysctl_admin_reserve_kbytes);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block reserve_mem_nb = {\n\t.notifier_call = reserve_mem_notifier,\n};\n\nstatic int __meminit init_reserve_notifier(void)\n{\n\tif (register_hotmemory_notifier(&reserve_mem_nb))\n\t\tpr_err(\"Failed registering memory add/remove notifier for admin reserve\\n\");\n\n\treturn 0;\n}\nsubsys_initcall(init_reserve_notifier);\n"], "filenames": ["mm/mmap.c"], "buggy_code_start_loc": [2429], "buggy_code_end_loc": [2435], "fixing_code_start_loc": [2429], "fixing_code_end_loc": [2434], "type": "CWE-476", "message": "In the Linux kernel before 4.20.14, expand_downwards in mm/mmap.c lacks a check for the mmap minimum address, which makes it easier for attackers to exploit kernel NULL pointer dereferences on non-SMAP platforms. This is related to a capability check for the wrong task.", "other": {"cve": {"id": "CVE-2019-9213", "sourceIdentifier": "cve@mitre.org", "published": "2019-03-05T22:29:00.240", "lastModified": "2022-10-12T15:56:12.443", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 4.20.14, expand_downwards in mm/mmap.c lacks a check for the mmap minimum address, which makes it easier for attackers to exploit kernel NULL pointer dereferences on non-SMAP platforms. This is related to a capability check for the wrong task."}, {"lang": "es", "value": "En el kernel de Linux, en versiones anteriores a la 4.20.14, expand_downwards en mm/mmap.c carece de una comprobaci\u00f3n para la direcci\u00f3n m\u00ednima de mmap, lo que facilita que los atacantes exploten desreferencias de puntero NULL en el kernel en plataformas que no son SMAP. Esto esto est\u00e1 relacionado con una comprobaci\u00f3n de capacidades para la tarea equivocada."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.9", "versionEndExcluding": "4.9.162", "matchCriteriaId": "56A636A0-542A-457B-8557-CD70D9AD69C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.14", "versionEndExcluding": "4.14.105", "matchCriteriaId": "6DC55135-E4DB-45B8-BF67-5139F750BF40"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.19", "versionEndExcluding": "4.19.27", "matchCriteriaId": "03F65CBE-42FC-4C64-8189-9D1AA25C01A5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.20", "versionEndExcluding": "4.20.14", "matchCriteriaId": "816E4DD2-A3B9-47AD-AFD4-79A03297934E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.3:*:*:*:*:*:*:*", "matchCriteriaId": "5F65DAB0-3DAD-49FF-BC73-3581CC3D5BF3"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:*:*:*:*", "matchCriteriaId": "1F3EFED2-F6BC-46D9-AB22-D5ED87EF4549"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=0a1d52994d440e21def1c2174932410b4f2a98a1", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-03/msg00045.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-04/msg00052.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://packetstormsecurity.com/files/156053/Reliable-Datagram-Sockets-RDS-rds_atomic_free_op-Privilege-Escalation.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:0831", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:1479", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:1480", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugs.chromium.org/p/project-zero/issues/detail?id=1792", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.14.105", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.19.27", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.20.14", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.9.162", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/0a1d52994d440e21def1c2174932410b4f2a98a1", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/03/msg00034.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/04/msg00004.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/05/msg00002.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3930-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3930-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3931-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3931-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3932-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3932-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3933-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3933-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/46502/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/0a1d52994d440e21def1c2174932410b4f2a98a1"}}