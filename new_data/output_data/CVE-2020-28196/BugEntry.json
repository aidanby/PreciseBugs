{"buggy_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* lib/krb5/asn.1/asn1_encode.c */\n/*\n * Copyright 1994, 2008 by the Massachusetts Institute of Technology.\n * All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n\n#include \"asn1_encode.h\"\n\nstruct asn1buf_st {\n    uint8_t *ptr;               /* Position, moving backwards; may be NULL */\n    size_t count;               /* Count of bytes written so far */\n};\n\n/**** Functions for encoding primitive types ****/\n\n/* Insert one byte into buf going backwards. */\nstatic inline void\ninsert_byte(asn1buf *buf, uint8_t o)\n{\n    if (buf->ptr != NULL) {\n        buf->ptr--;\n        *buf->ptr = o;\n    }\n    buf->count++;\n}\n\n/* Insert a block of bytes into buf going backwards (but without reversing\n * bytes). */\nstatic inline void\ninsert_bytes(asn1buf *buf, const void *bytes, size_t len)\n{\n    if (buf->ptr != NULL) {\n        memcpy(buf->ptr - len, bytes, len);\n        buf->ptr -= len;\n    }\n    buf->count += len;\n}\n\nvoid\nk5_asn1_encode_bool(asn1buf *buf, intmax_t val)\n{\n    insert_byte(buf, val ? 0xFF : 0x00);\n}\n\nvoid\nk5_asn1_encode_int(asn1buf *buf, intmax_t val)\n{\n    long valcopy;\n    int digit;\n\n    valcopy = val;\n    do {\n        digit = valcopy & 0xFF;\n        insert_byte(buf, digit);\n        valcopy = valcopy >> 8;\n    } while (valcopy != 0 && valcopy != ~0);\n\n    /* Make sure the high bit is of the proper signed-ness. */\n    if (val > 0 && (digit & 0x80) == 0x80)\n        insert_byte(buf, 0);\n    else if (val < 0 && (digit & 0x80) != 0x80)\n        insert_byte(buf, 0xFF);\n}\n\nvoid\nk5_asn1_encode_uint(asn1buf *buf, uintmax_t val)\n{\n    uintmax_t valcopy;\n    int digit;\n\n    valcopy = val;\n    do {\n        digit = valcopy & 0xFF;\n        insert_byte(buf, digit);\n        valcopy = valcopy >> 8;\n    } while (valcopy != 0);\n\n    /* Make sure the high bit is of the proper signed-ness. */\n    if (digit & 0x80)\n        insert_byte(buf, 0);\n}\n\nkrb5_error_code\nk5_asn1_encode_bytestring(asn1buf *buf, uint8_t *const *val, size_t len)\n{\n    if (len > 0 && val == NULL)\n        return ASN1_MISSING_FIELD;\n    insert_bytes(buf, *val, len);\n    return 0;\n}\n\nkrb5_error_code\nk5_asn1_encode_generaltime(asn1buf *buf, time_t val)\n{\n    struct tm *gtime, gtimebuf;\n    char s[16], *sp;\n    time_t gmt_time = val;\n    int len;\n\n    /*\n     * Time encoding: YYYYMMDDhhmmssZ\n     */\n    if (gmt_time == 0) {\n        sp = \"19700101000000Z\";\n    } else {\n        /*\n         * Sanity check this just to be paranoid, as gmtime can return NULL,\n         * and some bogus implementations might overrun on the sprintf.\n         */\n#ifdef HAVE_GMTIME_R\n#ifdef GMTIME_R_RETURNS_INT\n        if (gmtime_r(&gmt_time, &gtimebuf) != 0)\n            return ASN1_BAD_GMTIME;\n#else\n        if (gmtime_r(&gmt_time, &gtimebuf) == NULL)\n            return ASN1_BAD_GMTIME;\n#endif\n#else /* HAVE_GMTIME_R */\n        gtime = gmtime(&gmt_time);\n        if (gtime == NULL)\n            return ASN1_BAD_GMTIME;\n        memcpy(&gtimebuf, gtime, sizeof(gtimebuf));\n#endif /* HAVE_GMTIME_R */\n        gtime = &gtimebuf;\n\n        if (gtime->tm_year > 8099 || gtime->tm_mon > 11 ||\n            gtime->tm_mday > 31 || gtime->tm_hour > 23 ||\n            gtime->tm_min > 59 || gtime->tm_sec > 59)\n            return ASN1_BAD_GMTIME;\n        len = snprintf(s, sizeof(s), \"%04d%02d%02d%02d%02d%02dZ\",\n                       1900 + gtime->tm_year, gtime->tm_mon + 1,\n                       gtime->tm_mday, gtime->tm_hour,\n                       gtime->tm_min, gtime->tm_sec);\n        if (SNPRINTF_OVERFLOW(len, sizeof(s)))\n            /* Shouldn't be possible given above tests.  */\n            return ASN1_BAD_GMTIME;\n        sp = s;\n    }\n\n    insert_bytes(buf, sp, 15);\n    return 0;\n}\n\nkrb5_error_code\nk5_asn1_encode_bitstring(asn1buf *buf, uint8_t *const *val, size_t len)\n{\n    insert_bytes(buf, *val, len);\n    insert_byte(buf, 0);\n    return 0;\n}\n\n/**** Functions for decoding primitive types ****/\n\nkrb5_error_code\nk5_asn1_decode_bool(const uint8_t *asn1, size_t len, intmax_t *val)\n{\n    if (len != 1)\n        return ASN1_BAD_LENGTH;\n    *val = (*asn1 != 0);\n    return 0;\n}\n\n/* Decode asn1/len as the contents of a DER integer, placing the signed result\n * in val. */\nkrb5_error_code\nk5_asn1_decode_int(const uint8_t *asn1, size_t len, intmax_t *val)\n{\n    intmax_t n;\n    size_t i;\n\n    if (len == 0)\n        return ASN1_BAD_LENGTH;\n    n = (asn1[0] & 0x80) ? -1 : 0;\n    /* Check length; allow extra octet if first octet is 0. */\n    if (len > sizeof(intmax_t) + (asn1[0] == 0))\n        return ASN1_OVERFLOW;\n    for (i = 0; i < len; i++)\n        n = (n << 8) | asn1[i];\n    *val = n;\n    return 0;\n}\n\n/* Decode asn1/len as the contents of a DER integer, placing the unsigned\n * result in val. */\nkrb5_error_code\nk5_asn1_decode_uint(const uint8_t *asn1, size_t len, uintmax_t *val)\n{\n    uintmax_t n;\n    size_t i;\n\n    if (len == 0)\n        return ASN1_BAD_LENGTH;\n    /* Check for negative values and check length. */\n    if ((asn1[0] & 0x80) || len > sizeof(uintmax_t) + (asn1[0] == 0))\n        return ASN1_OVERFLOW;\n    for (i = 0, n = 0; i < len; i++)\n        n = (n << 8) | asn1[i];\n    *val = n;\n    return 0;\n}\n\nkrb5_error_code\nk5_asn1_decode_bytestring(const uint8_t *asn1, size_t len,\n                          uint8_t **str_out, size_t *len_out)\n{\n    uint8_t *str;\n\n    *str_out = NULL;\n    *len_out = 0;\n    if (len == 0)\n        return 0;\n    str = malloc(len);\n    if (str == NULL)\n        return ENOMEM;\n    memcpy(str, asn1, len);\n    *str_out = str;\n    *len_out = len;\n    return 0;\n}\n\nkrb5_error_code\nk5_asn1_decode_generaltime(const uint8_t *asn1, size_t len, time_t *time_out)\n{\n    const char *s = (char *)asn1;\n    struct tm ts;\n    time_t t;\n\n    *time_out = 0;\n    if (len != 15)\n        return ASN1_BAD_LENGTH;\n    /* Time encoding: YYYYMMDDhhmmssZ */\n    if (s[14] != 'Z')\n        return ASN1_BAD_FORMAT;\n    if (memcmp(s, \"19700101000000Z\", 15) == 0) {\n        *time_out = 0;\n        return 0;\n    }\n#define c2i(c) ((c) - '0')\n    ts.tm_year = 1000 * c2i(s[0]) + 100 * c2i(s[1]) + 10 * c2i(s[2]) +\n        c2i(s[3]) - 1900;\n    ts.tm_mon = 10 * c2i(s[4]) + c2i(s[5]) - 1;\n    ts.tm_mday = 10 * c2i(s[6]) + c2i(s[7]);\n    ts.tm_hour = 10 * c2i(s[8]) + c2i(s[9]);\n    ts.tm_min = 10 * c2i(s[10]) + c2i(s[11]);\n    ts.tm_sec = 10 * c2i(s[12]) + c2i(s[13]);\n    ts.tm_isdst = -1;\n    t = krb5int_gmt_mktime(&ts);\n    if (t == -1)\n        return ASN1_BAD_TIMEFORMAT;\n    *time_out = t;\n    return 0;\n}\n\n/*\n * Note: we return the number of bytes, not bits, in the bit string.  If the\n * number of bits is not a multiple of 8 we effectively round up to the next\n * multiple of 8.\n */\nkrb5_error_code\nk5_asn1_decode_bitstring(const uint8_t *asn1, size_t len,\n                         uint8_t **bits_out, size_t *len_out)\n{\n    uint8_t unused, *bits;\n\n    *bits_out = NULL;\n    *len_out = 0;\n    if (len == 0)\n        return ASN1_BAD_LENGTH;\n    unused = *asn1++;\n    len--;\n    if (unused > 7)\n        return ASN1_BAD_FORMAT;\n\n    bits = malloc(len);\n    if (bits == NULL)\n        return ENOMEM;\n    memcpy(bits, asn1, len);\n    if (len > 1)\n        bits[len - 1] &= (0xff << unused);\n\n    *bits_out = bits;\n    *len_out = len;\n    return 0;\n}\n\n/**** Functions for encoding and decoding tags ****/\n\n/* Encode a DER tag into buf with the tag parameters in t and the content\n * length len.  Place the length of the encoded tag in *retlen. */\nstatic krb5_error_code\nmake_tag(asn1buf *buf, const taginfo *t, size_t len)\n{\n    asn1_tagnum tag_copy;\n    size_t len_copy, oldcount;\n\n    if (t->tagnum > ASN1_TAGNUM_MAX)\n        return ASN1_OVERFLOW;\n\n    /* Encode the length of the content within the tag. */\n    if (len < 128) {\n        insert_byte(buf, len & 0x7F);\n    } else {\n        oldcount = buf->count;\n        for (len_copy = len; len_copy != 0; len_copy >>= 8)\n            insert_byte(buf, len_copy & 0xFF);\n        insert_byte(buf, 0x80 | ((buf->count - oldcount) & 0x7F));\n    }\n\n    /* Encode the tag and construction bit. */\n    if (t->tagnum < 31) {\n        insert_byte(buf, t->asn1class | t->construction | t->tagnum);\n    } else {\n        tag_copy = t->tagnum;\n        insert_byte(buf, tag_copy & 0x7F);\n        tag_copy >>= 7;\n\n        for (; tag_copy != 0; tag_copy >>= 7)\n            insert_byte(buf, 0x80 | (tag_copy & 0x7F));\n\n        insert_byte(buf, t->asn1class | t->construction | 0x1F);\n    }\n\n    return 0;\n}\n\n/*\n * Read a BER tag and length from asn1/len.  Place the tag parameters in\n * tag_out.  Set contents_out/clen_out to the octet range of the tag's\n * contents, and remainder_out/rlen_out to the octet range after the end of the\n * BER encoding.\n *\n * (krb5 ASN.1 encodings should be in DER, but for compatibility with some\n * really ancient implementations we handle the indefinite length form in tags.\n * However, we still insist on the primitive form of string types.)\n */\nstatic krb5_error_code\nget_tag(const uint8_t *asn1, size_t len, taginfo *tag_out,\n        const uint8_t **contents_out, size_t *clen_out,\n        const uint8_t **remainder_out, size_t *rlen_out)\n{\n    krb5_error_code ret;\n    uint8_t o;\n    const uint8_t *c, *p, *tag_start = asn1;\n    size_t clen, llen, i;\n    taginfo t;\n\n    *contents_out = *remainder_out = NULL;\n    *clen_out = *rlen_out = 0;\n    if (len == 0)\n        return ASN1_OVERRUN;\n    o = *asn1++;\n    len--;\n    tag_out->asn1class = o & 0xC0;\n    tag_out->construction = o & 0x20;\n    if ((o & 0x1F) != 0x1F) {\n        tag_out->tagnum = o & 0x1F;\n    } else {\n        tag_out->tagnum = 0;\n        do {\n            if (len == 0)\n                return ASN1_OVERRUN;\n            o = *asn1++;\n            len--;\n            tag_out->tagnum = (tag_out->tagnum << 7) | (o & 0x7F);\n        } while (o & 0x80);\n    }\n\n    if (len == 0)\n        return ASN1_OVERRUN;\n    o = *asn1++;\n    len--;\n\n    if (o == 0x80) {\n        /* Indefinite form (should not be present in DER, but we accept it). */\n        if (tag_out->construction != CONSTRUCTED)\n            return ASN1_MISMATCH_INDEF;\n        p = asn1;\n        while (!(len >= 2 && p[0] == 0 && p[1] == 0)) {\n            ret = get_tag(p, len, &t, &c, &clen, &p, &len);\n            if (ret)\n                return ret;\n        }\n        tag_out->tag_end_len = 2;\n        *contents_out = asn1;\n        *clen_out = p - asn1;\n        *remainder_out = p + 2;\n        *rlen_out = len - 2;\n    } else if ((o & 0x80) == 0) {\n        /* Short form (first octet gives content length). */\n        if (o > len)\n            return ASN1_OVERRUN;\n        tag_out->tag_end_len = 0;\n        *contents_out = asn1;\n        *clen_out = o;\n        *remainder_out = asn1 + *clen_out;\n        *rlen_out = len - (*remainder_out - asn1);\n    } else {\n        /* Long form (first octet gives number of base-256 length octets). */\n        llen = o & 0x7F;\n        if (llen > len)\n            return ASN1_OVERRUN;\n        if (llen > sizeof(*clen_out))\n            return ASN1_OVERFLOW;\n        for (i = 0, clen = 0; i < llen; i++)\n            clen = (clen << 8) | asn1[i];\n        if (clen > len - llen)\n            return ASN1_OVERRUN;\n        tag_out->tag_end_len = 0;\n        *contents_out = asn1 + llen;\n        *clen_out = clen;\n        *remainder_out = *contents_out + clen;\n        *rlen_out = len - (*remainder_out - asn1);\n    }\n    tag_out->tag_len = *contents_out - tag_start;\n    return 0;\n}\n\n#ifdef POINTERS_ARE_ALL_THE_SAME\n#define LOADPTR(PTR, TYPE) (*(const void *const *)(PTR))\n#define STOREPTR(PTR, TYPE, VAL) (*(void **)(VAL) = (PTR))\n#else\n#define LOADPTR(PTR, PTRINFO)                                           \\\n    (assert((PTRINFO)->loadptr != NULL), (PTRINFO)->loadptr(PTR))\n#define STOREPTR(PTR, PTRINFO, VAL)                                     \\\n    (assert((PTRINFO)->storeptr != NULL), (PTRINFO)->storeptr(PTR, VAL))\n#endif\n\nstatic size_t\nget_nullterm_sequence_len(const void *valp, const struct atype_info *seq)\n{\n    size_t i;\n    const struct atype_info *a;\n    const struct ptr_info *ptr;\n    const void *elt, *eltptr;\n\n    a = seq;\n    i = 0;\n    assert(a->type == atype_ptr);\n    assert(seq->size != 0);\n    ptr = a->tinfo;\n\n    while (1) {\n        eltptr = (const char *)valp + i * seq->size;\n        elt = LOADPTR(eltptr, ptr);\n        if (elt == NULL)\n            break;\n        i++;\n    }\n    return i;\n}\nstatic krb5_error_code\nencode_sequence_of(asn1buf *buf, size_t seqlen, const void *val,\n                   const struct atype_info *eltinfo);\n\nstatic krb5_error_code\nencode_nullterm_sequence_of(asn1buf *buf, const void *val,\n                            const struct atype_info *type, int can_be_empty)\n{\n    size_t len = get_nullterm_sequence_len(val, type);\n\n    if (!can_be_empty && len == 0)\n        return ASN1_MISSING_FIELD;\n    return encode_sequence_of(buf, len, val, type);\n}\n\nstatic intmax_t\nload_int(const void *val, size_t size)\n{\n    switch (size) {\n    case 1: return *(int8_t *)val;\n    case 2: return *(int16_t *)val;\n    case 4: return *(int32_t *)val;\n    case 8: return *(int64_t *)val;\n    default: abort();\n    }\n}\n\nstatic uintmax_t\nload_uint(const void *val, size_t size)\n{\n    switch (size) {\n    case 1: return *(uint8_t *)val;\n    case 2: return *(uint16_t *)val;\n    case 4: return *(uint32_t *)val;\n    case 8: return *(uint64_t *)val;\n    default: abort();\n    }\n}\n\nstatic krb5_error_code\nload_count(const void *val, const struct counted_info *counted,\n           size_t *count_out)\n{\n    const void *countptr = (const char *)val + counted->lenoff;\n\n    assert(sizeof(size_t) <= sizeof(uintmax_t));\n    if (counted->lensigned) {\n        intmax_t xlen = load_int(countptr, counted->lensize);\n        if (xlen < 0 || (uintmax_t)xlen > SIZE_MAX)\n            return EINVAL;\n        *count_out = xlen;\n    } else {\n        uintmax_t xlen = load_uint(countptr, counted->lensize);\n        if ((size_t)xlen != xlen || xlen > SIZE_MAX)\n            return EINVAL;\n        *count_out = xlen;\n    }\n    return 0;\n}\n\nstatic krb5_error_code\nstore_int(intmax_t intval, size_t size, void *val)\n{\n    switch (size) {\n    case 1:\n        if ((int8_t)intval != intval)\n            return ASN1_OVERFLOW;\n        *(int8_t *)val = intval;\n        return 0;\n    case 2:\n        if ((int16_t)intval != intval)\n            return ASN1_OVERFLOW;\n        *(int16_t *)val = intval;\n        return 0;\n    case 4:\n        if ((int32_t)intval != intval)\n            return ASN1_OVERFLOW;\n        *(int32_t *)val = intval;\n        return 0;\n    case 8:\n        if ((int64_t)intval != intval)\n            return ASN1_OVERFLOW;\n        *(int64_t *)val = intval;\n        return 0;\n    default:\n        abort();\n    }\n}\n\nstatic krb5_error_code\nstore_uint(uintmax_t intval, size_t size, void *val)\n{\n    switch (size) {\n    case 1:\n        if ((uint8_t)intval != intval)\n            return ASN1_OVERFLOW;\n        *(uint8_t *)val = intval;\n        return 0;\n    case 2:\n        if ((uint16_t)intval != intval)\n            return ASN1_OVERFLOW;\n        *(uint16_t *)val = intval;\n        return 0;\n    case 4:\n        if ((uint32_t)intval != intval)\n            return ASN1_OVERFLOW;\n        *(uint32_t *)val = intval;\n        return 0;\n    case 8:\n        if ((uint64_t)intval != intval)\n            return ASN1_OVERFLOW;\n        *(uint64_t *)val = intval;\n        return 0;\n    default:\n        abort();\n    }\n}\n\n/* Store a count value in an integer field of a structure.  If count is\n * SIZE_MAX and the target is a signed field, store -1. */\nstatic krb5_error_code\nstore_count(size_t count, const struct counted_info *counted, void *val)\n{\n    void *countptr = (char *)val + counted->lenoff;\n\n    if (counted->lensigned) {\n        if (count == SIZE_MAX)\n            return store_int(-1, counted->lensize, countptr);\n        else if ((intmax_t)count < 0)\n            return ASN1_OVERFLOW;\n        else\n            return store_int(count, counted->lensize, countptr);\n    } else\n        return store_uint(count, counted->lensize, countptr);\n}\n\n/* Split a DER encoding into tag and contents.  Insert the contents into buf,\n * then return the length of the contents and the tag. */\nstatic krb5_error_code\nsplit_der(asn1buf *buf, uint8_t *const *der, size_t len, taginfo *tag_out)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n\n    ret = get_tag(*der, len, tag_out, &contents, &clen, &remainder, &rlen);\n    if (ret)\n        return ret;\n    if (rlen != 0)\n        return ASN1_BAD_LENGTH;\n    insert_bytes(buf, contents, clen);\n    return 0;\n}\n\n/*\n * Store the DER encoding given by t and asn1/len into the char * or\n * uint8_t * pointed to by val.  Set *count_out to the length of the\n * DER encoding.\n */\nstatic krb5_error_code\nstore_der(const taginfo *t, const uint8_t *asn1, size_t len, void *val,\n          size_t *count_out)\n{\n    uint8_t *der;\n    size_t der_len;\n\n    *count_out = 0;\n    der_len = t->tag_len + len + t->tag_end_len;\n    der = malloc(der_len);\n    if (der == NULL)\n        return ENOMEM;\n    memcpy(der, asn1 - t->tag_len, der_len);\n    *(uint8_t **)val = der;\n    *count_out = der_len;\n    return 0;\n}\n\nstatic krb5_error_code\nencode_sequence(asn1buf *buf, const void *val, const struct seq_info *seq);\nstatic krb5_error_code\nencode_cntype(asn1buf *buf, const void *val, size_t len,\n              const struct cntype_info *c, taginfo *tag_out);\n\n/* Encode a value (contents only, no outer tag) according to a type, and return\n * its encoded tag information. */\nstatic krb5_error_code\nencode_atype(asn1buf *buf, const void *val, const struct atype_info *a,\n             taginfo *tag_out)\n{\n    krb5_error_code ret;\n\n    if (val == NULL)\n        return ASN1_MISSING_FIELD;\n\n    switch (a->type) {\n    case atype_fn: {\n        const struct fn_info *fn = a->tinfo;\n        assert(fn->enc != NULL);\n        return fn->enc(buf, val, tag_out);\n    }\n    case atype_sequence:\n        assert(a->tinfo != NULL);\n        ret = encode_sequence(buf, val, a->tinfo);\n        if (ret)\n            return ret;\n        tag_out->asn1class = UNIVERSAL;\n        tag_out->construction = CONSTRUCTED;\n        tag_out->tagnum = ASN1_SEQUENCE;\n        break;\n    case atype_ptr: {\n        const struct ptr_info *ptr = a->tinfo;\n        assert(ptr->basetype != NULL);\n        return encode_atype(buf, LOADPTR(val, ptr), ptr->basetype, tag_out);\n    }\n    case atype_offset: {\n        const struct offset_info *off = a->tinfo;\n        assert(off->basetype != NULL);\n        return encode_atype(buf, (const char *)val + off->dataoff,\n                            off->basetype, tag_out);\n    }\n    case atype_optional: {\n        const struct optional_info *opt = a->tinfo;\n        assert(opt->is_present != NULL);\n        if (opt->is_present(val))\n            return encode_atype(buf, val, opt->basetype, tag_out);\n        else\n            return ASN1_OMITTED;\n    }\n    case atype_counted: {\n        const struct counted_info *counted = a->tinfo;\n        const void *dataptr = (const char *)val + counted->dataoff;\n        size_t count;\n        assert(counted->basetype != NULL);\n        ret = load_count(val, counted, &count);\n        if (ret)\n            return ret;\n        return encode_cntype(buf, dataptr, count, counted->basetype, tag_out);\n    }\n    case atype_nullterm_sequence_of:\n    case atype_nonempty_nullterm_sequence_of:\n        assert(a->tinfo != NULL);\n        ret = encode_nullterm_sequence_of(buf, val, a->tinfo,\n                                          a->type ==\n                                          atype_nullterm_sequence_of);\n        if (ret)\n            return ret;\n        tag_out->asn1class = UNIVERSAL;\n        tag_out->construction = CONSTRUCTED;\n        tag_out->tagnum = ASN1_SEQUENCE;\n        break;\n    case atype_tagged_thing: {\n        const struct tagged_info *tag = a->tinfo;\n        size_t oldcount = buf->count;\n        ret = encode_atype(buf, val, tag->basetype, tag_out);\n        if (ret)\n            return ret;\n        if (!tag->implicit) {\n            ret = make_tag(buf, tag_out, buf->count - oldcount);\n            if (ret)\n                return ret;\n            tag_out->construction = tag->construction;\n        }\n        tag_out->asn1class = tag->tagtype;\n        tag_out->tagnum = tag->tagval;\n        break;\n    }\n    case atype_bool:\n        k5_asn1_encode_bool(buf, load_int(val, a->size));\n        tag_out->asn1class = UNIVERSAL;\n        tag_out->construction = PRIMITIVE;\n        tag_out->tagnum = ASN1_BOOLEAN;\n        break;\n    case atype_int:\n        k5_asn1_encode_int(buf, load_int(val, a->size));\n        tag_out->asn1class = UNIVERSAL;\n        tag_out->construction = PRIMITIVE;\n        tag_out->tagnum = ASN1_INTEGER;\n        break;\n    case atype_uint:\n        k5_asn1_encode_uint(buf, load_uint(val, a->size));\n        tag_out->asn1class = UNIVERSAL;\n        tag_out->construction = PRIMITIVE;\n        tag_out->tagnum = ASN1_INTEGER;\n        break;\n    case atype_int_immediate: {\n        const struct immediate_info *imm = a->tinfo;\n        k5_asn1_encode_int(buf, imm->val);\n        tag_out->asn1class = UNIVERSAL;\n        tag_out->construction = PRIMITIVE;\n        tag_out->tagnum = ASN1_INTEGER;\n        break;\n    }\n    default:\n        assert(a->type > atype_min);\n        assert(a->type < atype_max);\n        abort();\n    }\n\n    return 0;\n}\n\nstatic krb5_error_code\nencode_atype_and_tag(asn1buf *buf, const void *val, const struct atype_info *a)\n{\n    taginfo t;\n    krb5_error_code ret;\n    size_t oldcount = buf->count;\n\n    ret = encode_atype(buf, val, a, &t);\n    if (ret)\n        return ret;\n    ret = make_tag(buf, &t, buf->count - oldcount);\n    if (ret)\n        return ret;\n    return 0;\n}\n\n/*\n * Encode an object and count according to a cntype_info structure.  val is a\n * pointer to the object being encoded, which in most cases is itself a\n * pointer (but is a union in the cntype_choice case).\n */\nstatic krb5_error_code\nencode_cntype(asn1buf *buf, const void *val, size_t count,\n              const struct cntype_info *c, taginfo *tag_out)\n{\n    krb5_error_code ret;\n\n    switch (c->type) {\n    case cntype_string: {\n        const struct string_info *string = c->tinfo;\n        assert(string->enc != NULL);\n        ret = string->enc(buf, val, count);\n        if (ret)\n            return ret;\n        tag_out->asn1class = UNIVERSAL;\n        tag_out->construction = PRIMITIVE;\n        tag_out->tagnum = string->tagval;\n        break;\n    }\n    case cntype_der:\n        return split_der(buf, val, count, tag_out);\n    case cntype_seqof: {\n        const struct atype_info *a = c->tinfo;\n        const struct ptr_info *ptr = a->tinfo;\n        assert(a->type == atype_ptr);\n        val = LOADPTR(val, ptr);\n        ret = encode_sequence_of(buf, count, val, ptr->basetype);\n        if (ret)\n            return ret;\n        tag_out->asn1class = UNIVERSAL;\n        tag_out->construction = CONSTRUCTED;\n        tag_out->tagnum = ASN1_SEQUENCE;\n        break;\n    }\n    case cntype_choice: {\n        const struct choice_info *choice = c->tinfo;\n        if (count >= choice->n_options)\n            return ASN1_MISSING_FIELD;\n        return encode_atype(buf, val, choice->options[count], tag_out);\n    }\n\n    default:\n        assert(c->type > cntype_min);\n        assert(c->type < cntype_max);\n        abort();\n    }\n\n    return 0;\n}\n\nstatic krb5_error_code\nencode_sequence(asn1buf *buf, const void *val, const struct seq_info *seq)\n{\n    krb5_error_code ret;\n    size_t i;\n\n    for (i = seq->n_fields; i > 0; i--) {\n        ret = encode_atype_and_tag(buf, val, seq->fields[i - 1]);\n        if (ret == ASN1_OMITTED)\n            continue;\n        else if (ret != 0)\n            return ret;\n    }\n    return 0;\n}\n\nstatic krb5_error_code\nencode_sequence_of(asn1buf *buf, size_t seqlen, const void *val,\n                   const struct atype_info *eltinfo)\n{\n    krb5_error_code ret;\n    size_t i;\n    const void *eltptr;\n\n    assert(eltinfo->size != 0);\n    for (i = seqlen; i > 0; i--) {\n        eltptr = (const char *)val + (i - 1) * eltinfo->size;\n        ret = encode_atype_and_tag(buf, eltptr, eltinfo);\n        if (ret)\n            return ret;\n    }\n    return 0;\n}\n\n/**** Functions for freeing C objects based on type info ****/\n\nstatic void free_atype_ptr(const struct atype_info *a, void *val);\nstatic void free_sequence(const struct seq_info *seq, void *val);\nstatic void free_sequence_of(const struct atype_info *eltinfo, void *val,\n                             size_t count);\nstatic void free_cntype(const struct cntype_info *a, void *val, size_t count);\n\n/*\n * Free a C object according to a type description.  Do not free pointers at\n * the first level; they may be referenced by other fields of a sequence, and\n * will be freed by free_atype_ptr in a second pass.\n */\nstatic void\nfree_atype(const struct atype_info *a, void *val)\n{\n    switch (a->type) {\n    case atype_fn: {\n        const struct fn_info *fn = a->tinfo;\n        if (fn->free_func != NULL)\n            fn->free_func(val);\n        break;\n    }\n    case atype_sequence:\n        free_sequence(a->tinfo, val);\n        break;\n    case atype_ptr: {\n        const struct ptr_info *ptrinfo = a->tinfo;\n        void *ptr = LOADPTR(val, ptrinfo);\n        if (ptr != NULL) {\n            free_atype(ptrinfo->basetype, ptr);\n            free_atype_ptr(ptrinfo->basetype, ptr);\n        }\n        break;\n    }\n    case atype_offset: {\n        const struct offset_info *off = a->tinfo;\n        assert(off->basetype != NULL);\n        free_atype(off->basetype, (char *)val + off->dataoff);\n        break;\n    }\n    case atype_optional: {\n        const struct optional_info *opt = a->tinfo;\n        free_atype(opt->basetype, val);\n        break;\n    }\n    case atype_counted: {\n        const struct counted_info *counted = a->tinfo;\n        void *dataptr = (char *)val + counted->dataoff;\n        size_t count;\n        if (load_count(val, counted, &count) == 0)\n            free_cntype(counted->basetype, dataptr, count);\n        break;\n    }\n    case atype_nullterm_sequence_of:\n    case atype_nonempty_nullterm_sequence_of: {\n        size_t count = get_nullterm_sequence_len(val, a->tinfo);\n        free_sequence_of(a->tinfo, val, count);\n        break;\n    }\n    case atype_tagged_thing: {\n        const struct tagged_info *tag = a->tinfo;\n        free_atype(tag->basetype, val);\n        break;\n    }\n    case atype_bool:\n    case atype_int:\n    case atype_uint:\n    case atype_int_immediate:\n        break;\n    default:\n        abort();\n    }\n}\n\nstatic void\nfree_atype_ptr(const struct atype_info *a, void *val)\n{\n    switch (a->type) {\n    case atype_fn:\n    case atype_sequence:\n    case atype_counted:\n    case atype_nullterm_sequence_of:\n    case atype_nonempty_nullterm_sequence_of:\n    case atype_bool:\n    case atype_int:\n    case atype_uint:\n    case atype_int_immediate:\n         break;\n    case atype_ptr: {\n        const struct ptr_info *ptrinfo = a->tinfo;\n        void *ptr = LOADPTR(val, ptrinfo);\n        free(ptr);\n        STOREPTR(NULL, ptrinfo, val);\n        break;\n    }\n    case atype_offset: {\n        const struct offset_info *off = a->tinfo;\n        assert(off->basetype != NULL);\n        free_atype_ptr(off->basetype, (char *)val + off->dataoff);\n        break;\n    }\n    case atype_optional: {\n        const struct optional_info *opt = a->tinfo;\n        free_atype_ptr(opt->basetype, val);\n        break;\n    }\n    case atype_tagged_thing: {\n        const struct tagged_info *tag = a->tinfo;\n        free_atype_ptr(tag->basetype, val);\n        break;\n    }\n    default:\n        abort();\n    }\n}\n\nstatic void\nfree_cntype(const struct cntype_info *c, void *val, size_t count)\n{\n    switch (c->type) {\n    case cntype_string:\n    case cntype_der:\n        free(*(char **)val);\n        *(char **)val = NULL;\n        break;\n    case cntype_seqof: {\n        const struct atype_info *a = c->tinfo;\n        const struct ptr_info *ptrinfo = a->tinfo;\n        void *seqptr = LOADPTR(val, ptrinfo);\n        free_sequence_of(ptrinfo->basetype, seqptr, count);\n        free(seqptr);\n        STOREPTR(NULL, ptrinfo, val);\n        break;\n    }\n    case cntype_choice: {\n        const struct choice_info *choice = c->tinfo;\n        if (count < choice->n_options) {\n            free_atype(choice->options[count], val);\n            free_atype_ptr(choice->options[count], val);\n        }\n        break;\n    }\n    default:\n        abort();\n    }\n}\n\nstatic void\nfree_sequence(const struct seq_info *seq, void *val)\n{\n    size_t i;\n\n    for (i = 0; i < seq->n_fields; i++)\n        free_atype(seq->fields[i], val);\n    for (i = 0; i < seq->n_fields; i++)\n        free_atype_ptr(seq->fields[i], val);\n}\n\nstatic void\nfree_sequence_of(const struct atype_info *eltinfo, void *val, size_t count)\n{\n    void *eltptr;\n\n    assert(eltinfo->size != 0);\n    while (count-- > 0) {\n        eltptr = (char *)val + count * eltinfo->size;\n        free_atype(eltinfo, eltptr);\n        free_atype_ptr(eltinfo, eltptr);\n    }\n}\n\n/**** Functions for decoding objects based on type info ****/\n\n/* Return nonzero if t is an expected tag for an ASN.1 object of type a. */\nstatic int\ncheck_atype_tag(const struct atype_info *a, const taginfo *t)\n{\n    switch (a->type) {\n    case atype_fn: {\n        const struct fn_info *fn = a->tinfo;\n        assert(fn->check_tag != NULL);\n        return fn->check_tag(t);\n    }\n    case atype_sequence:\n    case atype_nullterm_sequence_of:\n    case atype_nonempty_nullterm_sequence_of:\n        return (t->asn1class == UNIVERSAL && t->construction == CONSTRUCTED &&\n                t->tagnum == ASN1_SEQUENCE);\n    case atype_ptr: {\n        const struct ptr_info *ptrinfo = a->tinfo;\n        return check_atype_tag(ptrinfo->basetype, t);\n    }\n    case atype_offset: {\n        const struct offset_info *off = a->tinfo;\n        return check_atype_tag(off->basetype, t);\n    }\n    case atype_optional: {\n        const struct optional_info *opt = a->tinfo;\n        return check_atype_tag(opt->basetype, t);\n    }\n    case atype_counted: {\n        const struct counted_info *counted = a->tinfo;\n        switch (counted->basetype->type) {\n        case cntype_string: {\n            const struct string_info *string = counted->basetype->tinfo;\n            return (t->asn1class == UNIVERSAL &&\n                    t->construction == PRIMITIVE &&\n                    t->tagnum == string->tagval);\n        }\n        case cntype_seqof:\n            return (t->asn1class == UNIVERSAL &&\n                    t->construction == CONSTRUCTED &&\n                    t->tagnum == ASN1_SEQUENCE);\n        case cntype_der:\n            /*\n             * We treat any tag as matching a stored DER encoding.  In some\n             * cases we know what the tag should be; in others, we truly want\n             * to accept any tag.  If it ever becomes an issue, we could add\n             * optional tag info to the type and check it here.\n             */\n            return 1;\n        case cntype_choice:\n            /*\n             * ASN.1 choices may or may not be extensible.  For now, we treat\n             * all choices as extensible and match any tag.  We should consider\n             * modeling whether choices are extensible before making the\n             * encoder visible to plugins.\n             */\n            return 1;\n        default:\n            abort();\n        }\n    }\n    case atype_tagged_thing: {\n        const struct tagged_info *tag = a->tinfo;\n        /* NOTE: Doesn't check construction bit for implicit tags. */\n        if (!tag->implicit && t->construction != tag->construction)\n            return 0;\n        return (t->asn1class == tag->tagtype && t->tagnum == tag->tagval);\n    }\n    case atype_bool:\n        return (t->asn1class == UNIVERSAL && t->construction == PRIMITIVE &&\n                t->tagnum == ASN1_BOOLEAN);\n    case atype_int:\n    case atype_uint:\n    case atype_int_immediate:\n        return (t->asn1class == UNIVERSAL && t->construction == PRIMITIVE &&\n                t->tagnum == ASN1_INTEGER);\n    default:\n        abort();\n    }\n}\n\nstatic krb5_error_code\ndecode_cntype(const taginfo *t, const uint8_t *asn1, size_t len,\n              const struct cntype_info *c, void *val, size_t *count_out);\nstatic krb5_error_code\ndecode_atype_to_ptr(const taginfo *t, const uint8_t *asn1, size_t len,\n                    const struct atype_info *basetype, void **ptr_out);\nstatic krb5_error_code\ndecode_sequence(const uint8_t *asn1, size_t len, const struct seq_info *seq,\n                void *val);\nstatic krb5_error_code\ndecode_sequence_of(const uint8_t *asn1, size_t len,\n                   const struct atype_info *elemtype, void **seq_out,\n                   size_t *count_out);\n\n/* Given the enclosing tag t, decode from asn1/len the contents of the ASN.1\n * type specified by a, placing the result into val (caller-allocated). */\nstatic krb5_error_code\ndecode_atype(const taginfo *t, const uint8_t *asn1, size_t len,\n             const struct atype_info *a, void *val)\n{\n    krb5_error_code ret;\n\n    switch (a->type) {\n    case atype_fn: {\n        const struct fn_info *fn = a->tinfo;\n        assert(fn->dec != NULL);\n        return fn->dec(t, asn1, len, val);\n    }\n    case atype_sequence:\n        return decode_sequence(asn1, len, a->tinfo, val);\n    case atype_ptr: {\n        const struct ptr_info *ptrinfo = a->tinfo;\n        void *ptr = LOADPTR(val, ptrinfo);\n        assert(ptrinfo->basetype != NULL);\n        if (ptr != NULL) {\n            /* Container was already allocated by a previous sequence field. */\n            return decode_atype(t, asn1, len, ptrinfo->basetype, ptr);\n        } else {\n            ret = decode_atype_to_ptr(t, asn1, len, ptrinfo->basetype, &ptr);\n            if (ret)\n                return ret;\n            STOREPTR(ptr, ptrinfo, val);\n            break;\n        }\n    }\n    case atype_offset: {\n        const struct offset_info *off = a->tinfo;\n        assert(off->basetype != NULL);\n        return decode_atype(t, asn1, len, off->basetype,\n                            (char *)val + off->dataoff);\n    }\n    case atype_optional: {\n        const struct optional_info *opt = a->tinfo;\n        return decode_atype(t, asn1, len, opt->basetype, val);\n    }\n    case atype_counted: {\n        const struct counted_info *counted = a->tinfo;\n        void *dataptr = (char *)val + counted->dataoff;\n        size_t count;\n        assert(counted->basetype != NULL);\n        ret = decode_cntype(t, asn1, len, counted->basetype, dataptr, &count);\n        if (ret)\n            return ret;\n        return store_count(count, counted, val);\n    }\n    case atype_tagged_thing: {\n        const struct tagged_info *tag = a->tinfo;\n        taginfo inner_tag;\n        const taginfo *tp = t;\n        const uint8_t *rem;\n        size_t rlen;\n        if (!tag->implicit) {\n            ret = get_tag(asn1, len, &inner_tag, &asn1, &len, &rem, &rlen);\n            if (ret)\n                return ret;\n            /* Note: we don't check rlen (it should be 0). */\n            tp = &inner_tag;\n            if (!check_atype_tag(tag->basetype, tp))\n                return ASN1_BAD_ID;\n        }\n        return decode_atype(tp, asn1, len, tag->basetype, val);\n    }\n    case atype_bool: {\n        intmax_t intval;\n        ret = k5_asn1_decode_bool(asn1, len, &intval);\n        if (ret)\n            return ret;\n        return store_int(intval, a->size, val);\n    }\n    case atype_int: {\n        intmax_t intval;\n        ret = k5_asn1_decode_int(asn1, len, &intval);\n        if (ret)\n            return ret;\n        return store_int(intval, a->size, val);\n    }\n    case atype_uint: {\n        uintmax_t intval;\n        ret = k5_asn1_decode_uint(asn1, len, &intval);\n        if (ret)\n            return ret;\n        return store_uint(intval, a->size, val);\n    }\n    case atype_int_immediate: {\n        const struct immediate_info *imm = a->tinfo;\n        intmax_t intval;\n        ret = k5_asn1_decode_int(asn1, len, &intval);\n        if (ret)\n            return ret;\n        if (intval != imm->val && imm->err != 0)\n            return imm->err;\n        break;\n    }\n    default:\n        /* Null-terminated sequence types are handled in decode_atype_to_ptr,\n         * since they create variable-sized objects. */\n        assert(a->type != atype_nullterm_sequence_of);\n        assert(a->type != atype_nonempty_nullterm_sequence_of);\n        assert(a->type > atype_min);\n        assert(a->type < atype_max);\n        abort();\n    }\n    return 0;\n}\n\n/*\n * Given the enclosing tag t, decode from asn1/len the contents of the\n * ASN.1 type described by c, placing the counted result into val/count_out.\n * If the resulting count should be -1 (for an unknown union distinguisher),\n * set *count_out to SIZE_MAX.\n */\nstatic krb5_error_code\ndecode_cntype(const taginfo *t, const uint8_t *asn1, size_t len,\n              const struct cntype_info *c, void *val, size_t *count_out)\n{\n    krb5_error_code ret;\n\n    switch (c->type) {\n    case cntype_string: {\n        const struct string_info *string = c->tinfo;\n        assert(string->dec != NULL);\n        return string->dec(asn1, len, val, count_out);\n    }\n    case cntype_der:\n        return store_der(t, asn1, len, val, count_out);\n    case cntype_seqof: {\n        const struct atype_info *a = c->tinfo;\n        const struct ptr_info *ptrinfo = a->tinfo;\n        void *seq;\n        assert(a->type == atype_ptr);\n        ret = decode_sequence_of(asn1, len, ptrinfo->basetype, &seq,\n                                 count_out);\n        if (ret)\n            return ret;\n        STOREPTR(seq, ptrinfo, val);\n        break;\n    }\n    case cntype_choice: {\n        const struct choice_info *choice = c->tinfo;\n        size_t i;\n        for (i = 0; i < choice->n_options; i++) {\n            if (check_atype_tag(choice->options[i], t)) {\n                ret = decode_atype(t, asn1, len, choice->options[i], val);\n                if (ret)\n                    return ret;\n                *count_out = i;\n                return 0;\n            }\n        }\n        /* SIZE_MAX will be stored as -1 in the distinguisher.  If we start\n         * modeling non-extensible choices we should check that here. */\n        *count_out = SIZE_MAX;\n        break;\n    }\n    default:\n        assert(c->type > cntype_min);\n        assert(c->type < cntype_max);\n        abort();\n    }\n    return 0;\n}\n\n/* Add a null pointer to the end of a sequence.  ptr is consumed on success\n * (to be replaced by *ptr_out), left alone on failure. */\nstatic krb5_error_code\nnull_terminate(const struct atype_info *eltinfo, void *ptr, size_t count,\n               void **ptr_out)\n{\n    const struct ptr_info *ptrinfo = eltinfo->tinfo;\n    void *endptr;\n\n    assert(eltinfo->type == atype_ptr);\n    ptr = realloc(ptr, (count + 1) * eltinfo->size);\n    if (ptr == NULL)\n        return ENOMEM;\n    endptr = (char *)ptr + count * eltinfo->size;\n    STOREPTR(NULL, ptrinfo, endptr);\n    *ptr_out = ptr;\n    return 0;\n}\n\nstatic krb5_error_code\ndecode_atype_to_ptr(const taginfo *t, const uint8_t *asn1, size_t len,\n                    const struct atype_info *a, void **ptr_out)\n{\n    krb5_error_code ret;\n    void *ptr;\n    size_t count;\n\n    *ptr_out = NULL;\n    switch (a->type) {\n    case atype_nullterm_sequence_of:\n    case atype_nonempty_nullterm_sequence_of:\n        ret = decode_sequence_of(asn1, len, a->tinfo, &ptr, &count);\n        if (ret)\n            return ret;\n        ret = null_terminate(a->tinfo, ptr, count, &ptr);\n        if (ret) {\n            free_sequence_of(a->tinfo, ptr, count);\n            return ret;\n        }\n        /* Historically we do not enforce non-emptiness of sequences when\n         * decoding, even when it is required by the ASN.1 type. */\n        break;\n    default:\n        ptr = calloc(a->size, 1);\n        if (ptr == NULL)\n            return ENOMEM;\n        ret = decode_atype(t, asn1, len, a, ptr);\n        if (ret) {\n            free(ptr);\n            return ret;\n        }\n        break;\n    }\n    *ptr_out = ptr;\n    return 0;\n}\n\n/* Initialize a C object when the corresponding ASN.1 type was omitted within a\n * sequence.  If the ASN.1 type is not optional, return ASN1_MISSING_FIELD. */\nstatic krb5_error_code\nomit_atype(const struct atype_info *a, void *val)\n{\n    switch (a->type)\n    {\n    case atype_fn:\n    case atype_sequence:\n    case atype_nullterm_sequence_of:\n    case atype_nonempty_nullterm_sequence_of:\n    case atype_counted:\n    case atype_bool:\n    case atype_int:\n    case atype_uint:\n    case atype_int_immediate:\n        return ASN1_MISSING_FIELD;\n    case atype_ptr: {\n        const struct ptr_info *ptrinfo = a->tinfo;\n        return omit_atype(ptrinfo->basetype, val);\n    }\n    case atype_offset: {\n        const struct offset_info *off = a->tinfo;\n        return omit_atype(off->basetype, (char *)val + off->dataoff);\n    }\n    case atype_tagged_thing: {\n        const struct tagged_info *tag = a->tinfo;\n        return omit_atype(tag->basetype, val);\n    }\n    case atype_optional: {\n        const struct optional_info *opt = a->tinfo;\n        if (opt->init != NULL)\n            opt->init(val);\n        return 0;\n    }\n    default:\n        abort();\n    }\n}\n\n/* Decode an ASN.1 sequence into a C object. */\nstatic krb5_error_code\ndecode_sequence(const uint8_t *asn1, size_t len, const struct seq_info *seq,\n                void *val)\n{\n    krb5_error_code ret;\n    const uint8_t *contents;\n    size_t i, j, clen;\n    taginfo t;\n\n    assert(seq->n_fields > 0);\n    for (i = 0; i < seq->n_fields; i++) {\n        if (len == 0)\n            break;\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);\n        if (ret)\n            goto error;\n        /*\n         * Find the applicable sequence field.  This logic is a little\n         * oversimplified; we could match an element to an optional extensible\n         * choice or optional stored-DER type when we ought to match a\n         * subsequent non-optional field.  But it's unwise and (hopefully) very\n         * rare for ASN.1 modules to require such precision.\n         */\n        for (; i < seq->n_fields; i++) {\n            if (check_atype_tag(seq->fields[i], &t))\n                break;\n            ret = omit_atype(seq->fields[i], val);\n            if (ret)\n                goto error;\n        }\n        /* We currently model all sequences as extensible.  We should consider\n         * changing this before making the encoder visible to plugins. */\n        if (i == seq->n_fields)\n            break;\n        ret = decode_atype(&t, contents, clen, seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    /* Initialize any fields in the C object which were not accounted for in\n     * the sequence.  Error out if any of them aren't optional. */\n    for (; i < seq->n_fields; i++) {\n        ret = omit_atype(seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    return 0;\n\nerror:\n    /* Free what we've decoded so far.  Free pointers in a second pass in\n     * case multiple fields refer to the same pointer. */\n    for (j = 0; j < i; j++)\n        free_atype(seq->fields[j], val);\n    for (j = 0; j < i; j++)\n        free_atype_ptr(seq->fields[j], val);\n    return ret;\n}\n\nstatic krb5_error_code\ndecode_sequence_of(const uint8_t *asn1, size_t len,\n                   const struct atype_info *elemtype, void **seq_out,\n                   size_t *count_out)\n{\n    krb5_error_code ret;\n    void *seq = NULL, *elem, *newseq;\n    const uint8_t *contents;\n    size_t clen, count = 0;\n    taginfo t;\n\n    *seq_out = NULL;\n    *count_out = 0;\n    while (len > 0) {\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);\n        if (ret)\n            goto error;\n        if (!check_atype_tag(elemtype, &t)) {\n            ret = ASN1_BAD_ID;\n            goto error;\n        }\n        newseq = realloc(seq, (count + 1) * elemtype->size);\n        if (newseq == NULL) {\n            ret = ENOMEM;\n            goto error;\n        }\n        seq = newseq;\n        elem = (char *)seq + count * elemtype->size;\n        memset(elem, 0, elemtype->size);\n        ret = decode_atype(&t, contents, clen, elemtype, elem);\n        if (ret)\n            goto error;\n        count++;\n    }\n    *seq_out = seq;\n    *count_out = count;\n    return 0;\n\nerror:\n    free_sequence_of(elemtype, seq, count);\n    free(seq);\n    return ret;\n}\n\n/* These three entry points are only needed for the kdc_req_body hack and may\n * go away at some point.  Define them here so we can use short names above. */\n\nkrb5_error_code\nk5_asn1_encode_atype(asn1buf *buf, const void *val, const struct atype_info *a,\n                     taginfo *tag_out)\n{\n    return encode_atype(buf, val, a, tag_out);\n}\n\nkrb5_error_code\nk5_asn1_decode_atype(const taginfo *t, const uint8_t *asn1, size_t len,\n                     const struct atype_info *a, void *val)\n{\n    return decode_atype(t, asn1, len, a, val);\n}\n\nkrb5_error_code\nk5_asn1_full_encode(const void *rep, const struct atype_info *a,\n                    krb5_data **code_out)\n{\n    krb5_error_code ret;\n    asn1buf buf;\n    krb5_data *d;\n    uint8_t *bytes;\n\n    *code_out = NULL;\n\n    if (rep == NULL)\n        return ASN1_MISSING_FIELD;\n\n    /* Make a first pass over rep to count the encoding size. */\n    buf.ptr = NULL;\n    buf.count = 0;\n    ret = encode_atype_and_tag(&buf, rep, a);\n    if (ret)\n        return ret;\n\n    /* Allocate space for the encoding. */\n    bytes = malloc(buf.count + 1);\n    if (bytes == NULL)\n        return ENOMEM;\n    bytes[buf.count] = 0;\n\n    /* Make a second pass over rep to encode it.  buf.ptr moves backwards as we\n     * encode, and will always exactly return to the base. */\n    buf.ptr = bytes + buf.count;\n    buf.count = 0;\n    ret = encode_atype_and_tag(&buf, rep, a);\n    if (ret) {\n        free(bytes);\n        return ret;\n    }\n    assert(buf.ptr == bytes);\n\n    /* Create the output data object. */\n    *code_out = malloc(sizeof(*d));\n    if (*code_out == NULL) {\n        free(bytes);\n        return ENOMEM;\n    }\n    **code_out = make_data(bytes, buf.count);\n    return 0;\n}\n\nkrb5_error_code\nk5_asn1_full_decode(const krb5_data *code, const struct atype_info *a,\n                    void **retrep)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n    taginfo t;\n\n    *retrep = NULL;\n    ret = get_tag((uint8_t *)code->data, code->length, &t, &contents,\n                  &clen, &remainder, &rlen);\n    if (ret)\n        return ret;\n    /* rlen should be 0, but we don't check it (and due to padding in\n     * non-length-preserving enctypes, it will sometimes be nonzero). */\n    if (!check_atype_tag(a, &t))\n        return ASN1_BAD_ID;\n    return decode_atype_to_ptr(&t, contents, clen, a, retrep);\n}\n"], "fixing_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* lib/krb5/asn.1/asn1_encode.c */\n/*\n * Copyright 1994, 2008 by the Massachusetts Institute of Technology.\n * All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n\n#include \"asn1_encode.h\"\n\nstruct asn1buf_st {\n    uint8_t *ptr;               /* Position, moving backwards; may be NULL */\n    size_t count;               /* Count of bytes written so far */\n};\n\n/**** Functions for encoding primitive types ****/\n\n/* Insert one byte into buf going backwards. */\nstatic inline void\ninsert_byte(asn1buf *buf, uint8_t o)\n{\n    if (buf->ptr != NULL) {\n        buf->ptr--;\n        *buf->ptr = o;\n    }\n    buf->count++;\n}\n\n/* Insert a block of bytes into buf going backwards (but without reversing\n * bytes). */\nstatic inline void\ninsert_bytes(asn1buf *buf, const void *bytes, size_t len)\n{\n    if (buf->ptr != NULL) {\n        memcpy(buf->ptr - len, bytes, len);\n        buf->ptr -= len;\n    }\n    buf->count += len;\n}\n\nvoid\nk5_asn1_encode_bool(asn1buf *buf, intmax_t val)\n{\n    insert_byte(buf, val ? 0xFF : 0x00);\n}\n\nvoid\nk5_asn1_encode_int(asn1buf *buf, intmax_t val)\n{\n    long valcopy;\n    int digit;\n\n    valcopy = val;\n    do {\n        digit = valcopy & 0xFF;\n        insert_byte(buf, digit);\n        valcopy = valcopy >> 8;\n    } while (valcopy != 0 && valcopy != ~0);\n\n    /* Make sure the high bit is of the proper signed-ness. */\n    if (val > 0 && (digit & 0x80) == 0x80)\n        insert_byte(buf, 0);\n    else if (val < 0 && (digit & 0x80) != 0x80)\n        insert_byte(buf, 0xFF);\n}\n\nvoid\nk5_asn1_encode_uint(asn1buf *buf, uintmax_t val)\n{\n    uintmax_t valcopy;\n    int digit;\n\n    valcopy = val;\n    do {\n        digit = valcopy & 0xFF;\n        insert_byte(buf, digit);\n        valcopy = valcopy >> 8;\n    } while (valcopy != 0);\n\n    /* Make sure the high bit is of the proper signed-ness. */\n    if (digit & 0x80)\n        insert_byte(buf, 0);\n}\n\nkrb5_error_code\nk5_asn1_encode_bytestring(asn1buf *buf, uint8_t *const *val, size_t len)\n{\n    if (len > 0 && val == NULL)\n        return ASN1_MISSING_FIELD;\n    insert_bytes(buf, *val, len);\n    return 0;\n}\n\nkrb5_error_code\nk5_asn1_encode_generaltime(asn1buf *buf, time_t val)\n{\n    struct tm *gtime, gtimebuf;\n    char s[16], *sp;\n    time_t gmt_time = val;\n    int len;\n\n    /*\n     * Time encoding: YYYYMMDDhhmmssZ\n     */\n    if (gmt_time == 0) {\n        sp = \"19700101000000Z\";\n    } else {\n        /*\n         * Sanity check this just to be paranoid, as gmtime can return NULL,\n         * and some bogus implementations might overrun on the sprintf.\n         */\n#ifdef HAVE_GMTIME_R\n#ifdef GMTIME_R_RETURNS_INT\n        if (gmtime_r(&gmt_time, &gtimebuf) != 0)\n            return ASN1_BAD_GMTIME;\n#else\n        if (gmtime_r(&gmt_time, &gtimebuf) == NULL)\n            return ASN1_BAD_GMTIME;\n#endif\n#else /* HAVE_GMTIME_R */\n        gtime = gmtime(&gmt_time);\n        if (gtime == NULL)\n            return ASN1_BAD_GMTIME;\n        memcpy(&gtimebuf, gtime, sizeof(gtimebuf));\n#endif /* HAVE_GMTIME_R */\n        gtime = &gtimebuf;\n\n        if (gtime->tm_year > 8099 || gtime->tm_mon > 11 ||\n            gtime->tm_mday > 31 || gtime->tm_hour > 23 ||\n            gtime->tm_min > 59 || gtime->tm_sec > 59)\n            return ASN1_BAD_GMTIME;\n        len = snprintf(s, sizeof(s), \"%04d%02d%02d%02d%02d%02dZ\",\n                       1900 + gtime->tm_year, gtime->tm_mon + 1,\n                       gtime->tm_mday, gtime->tm_hour,\n                       gtime->tm_min, gtime->tm_sec);\n        if (SNPRINTF_OVERFLOW(len, sizeof(s)))\n            /* Shouldn't be possible given above tests.  */\n            return ASN1_BAD_GMTIME;\n        sp = s;\n    }\n\n    insert_bytes(buf, sp, 15);\n    return 0;\n}\n\nkrb5_error_code\nk5_asn1_encode_bitstring(asn1buf *buf, uint8_t *const *val, size_t len)\n{\n    insert_bytes(buf, *val, len);\n    insert_byte(buf, 0);\n    return 0;\n}\n\n/**** Functions for decoding primitive types ****/\n\nkrb5_error_code\nk5_asn1_decode_bool(const uint8_t *asn1, size_t len, intmax_t *val)\n{\n    if (len != 1)\n        return ASN1_BAD_LENGTH;\n    *val = (*asn1 != 0);\n    return 0;\n}\n\n/* Decode asn1/len as the contents of a DER integer, placing the signed result\n * in val. */\nkrb5_error_code\nk5_asn1_decode_int(const uint8_t *asn1, size_t len, intmax_t *val)\n{\n    intmax_t n;\n    size_t i;\n\n    if (len == 0)\n        return ASN1_BAD_LENGTH;\n    n = (asn1[0] & 0x80) ? -1 : 0;\n    /* Check length; allow extra octet if first octet is 0. */\n    if (len > sizeof(intmax_t) + (asn1[0] == 0))\n        return ASN1_OVERFLOW;\n    for (i = 0; i < len; i++)\n        n = (n << 8) | asn1[i];\n    *val = n;\n    return 0;\n}\n\n/* Decode asn1/len as the contents of a DER integer, placing the unsigned\n * result in val. */\nkrb5_error_code\nk5_asn1_decode_uint(const uint8_t *asn1, size_t len, uintmax_t *val)\n{\n    uintmax_t n;\n    size_t i;\n\n    if (len == 0)\n        return ASN1_BAD_LENGTH;\n    /* Check for negative values and check length. */\n    if ((asn1[0] & 0x80) || len > sizeof(uintmax_t) + (asn1[0] == 0))\n        return ASN1_OVERFLOW;\n    for (i = 0, n = 0; i < len; i++)\n        n = (n << 8) | asn1[i];\n    *val = n;\n    return 0;\n}\n\nkrb5_error_code\nk5_asn1_decode_bytestring(const uint8_t *asn1, size_t len,\n                          uint8_t **str_out, size_t *len_out)\n{\n    uint8_t *str;\n\n    *str_out = NULL;\n    *len_out = 0;\n    if (len == 0)\n        return 0;\n    str = malloc(len);\n    if (str == NULL)\n        return ENOMEM;\n    memcpy(str, asn1, len);\n    *str_out = str;\n    *len_out = len;\n    return 0;\n}\n\nkrb5_error_code\nk5_asn1_decode_generaltime(const uint8_t *asn1, size_t len, time_t *time_out)\n{\n    const char *s = (char *)asn1;\n    struct tm ts;\n    time_t t;\n\n    *time_out = 0;\n    if (len != 15)\n        return ASN1_BAD_LENGTH;\n    /* Time encoding: YYYYMMDDhhmmssZ */\n    if (s[14] != 'Z')\n        return ASN1_BAD_FORMAT;\n    if (memcmp(s, \"19700101000000Z\", 15) == 0) {\n        *time_out = 0;\n        return 0;\n    }\n#define c2i(c) ((c) - '0')\n    ts.tm_year = 1000 * c2i(s[0]) + 100 * c2i(s[1]) + 10 * c2i(s[2]) +\n        c2i(s[3]) - 1900;\n    ts.tm_mon = 10 * c2i(s[4]) + c2i(s[5]) - 1;\n    ts.tm_mday = 10 * c2i(s[6]) + c2i(s[7]);\n    ts.tm_hour = 10 * c2i(s[8]) + c2i(s[9]);\n    ts.tm_min = 10 * c2i(s[10]) + c2i(s[11]);\n    ts.tm_sec = 10 * c2i(s[12]) + c2i(s[13]);\n    ts.tm_isdst = -1;\n    t = krb5int_gmt_mktime(&ts);\n    if (t == -1)\n        return ASN1_BAD_TIMEFORMAT;\n    *time_out = t;\n    return 0;\n}\n\n/*\n * Note: we return the number of bytes, not bits, in the bit string.  If the\n * number of bits is not a multiple of 8 we effectively round up to the next\n * multiple of 8.\n */\nkrb5_error_code\nk5_asn1_decode_bitstring(const uint8_t *asn1, size_t len,\n                         uint8_t **bits_out, size_t *len_out)\n{\n    uint8_t unused, *bits;\n\n    *bits_out = NULL;\n    *len_out = 0;\n    if (len == 0)\n        return ASN1_BAD_LENGTH;\n    unused = *asn1++;\n    len--;\n    if (unused > 7)\n        return ASN1_BAD_FORMAT;\n\n    bits = malloc(len);\n    if (bits == NULL)\n        return ENOMEM;\n    memcpy(bits, asn1, len);\n    if (len > 1)\n        bits[len - 1] &= (0xff << unused);\n\n    *bits_out = bits;\n    *len_out = len;\n    return 0;\n}\n\n/**** Functions for encoding and decoding tags ****/\n\n/* Encode a DER tag into buf with the tag parameters in t and the content\n * length len.  Place the length of the encoded tag in *retlen. */\nstatic krb5_error_code\nmake_tag(asn1buf *buf, const taginfo *t, size_t len)\n{\n    asn1_tagnum tag_copy;\n    size_t len_copy, oldcount;\n\n    if (t->tagnum > ASN1_TAGNUM_MAX)\n        return ASN1_OVERFLOW;\n\n    /* Encode the length of the content within the tag. */\n    if (len < 128) {\n        insert_byte(buf, len & 0x7F);\n    } else {\n        oldcount = buf->count;\n        for (len_copy = len; len_copy != 0; len_copy >>= 8)\n            insert_byte(buf, len_copy & 0xFF);\n        insert_byte(buf, 0x80 | ((buf->count - oldcount) & 0x7F));\n    }\n\n    /* Encode the tag and construction bit. */\n    if (t->tagnum < 31) {\n        insert_byte(buf, t->asn1class | t->construction | t->tagnum);\n    } else {\n        tag_copy = t->tagnum;\n        insert_byte(buf, tag_copy & 0x7F);\n        tag_copy >>= 7;\n\n        for (; tag_copy != 0; tag_copy >>= 7)\n            insert_byte(buf, 0x80 | (tag_copy & 0x7F));\n\n        insert_byte(buf, t->asn1class | t->construction | 0x1F);\n    }\n\n    return 0;\n}\n\n/*\n * Read a BER tag and length from asn1/len.  Place the tag parameters in\n * tag_out.  Set contents_out/clen_out to the octet range of the tag's\n * contents, and remainder_out/rlen_out to the octet range after the end of the\n * BER encoding.\n *\n * (krb5 ASN.1 encodings should be in DER, but for compatibility with some\n * really ancient implementations we handle the indefinite length form in tags.\n * However, we still insist on the primitive form of string types.)\n */\nstatic krb5_error_code\nget_tag(const uint8_t *asn1, size_t len, taginfo *tag_out,\n        const uint8_t **contents_out, size_t *clen_out,\n        const uint8_t **remainder_out, size_t *rlen_out, int recursion)\n{\n    krb5_error_code ret;\n    uint8_t o;\n    const uint8_t *c, *p, *tag_start = asn1;\n    size_t clen, llen, i;\n    taginfo t;\n\n    *contents_out = *remainder_out = NULL;\n    *clen_out = *rlen_out = 0;\n    if (len == 0)\n        return ASN1_OVERRUN;\n    o = *asn1++;\n    len--;\n    tag_out->asn1class = o & 0xC0;\n    tag_out->construction = o & 0x20;\n    if ((o & 0x1F) != 0x1F) {\n        tag_out->tagnum = o & 0x1F;\n    } else {\n        tag_out->tagnum = 0;\n        do {\n            if (len == 0)\n                return ASN1_OVERRUN;\n            o = *asn1++;\n            len--;\n            tag_out->tagnum = (tag_out->tagnum << 7) | (o & 0x7F);\n        } while (o & 0x80);\n    }\n\n    if (len == 0)\n        return ASN1_OVERRUN;\n    o = *asn1++;\n    len--;\n\n    if (o == 0x80) {\n        /* Indefinite form (should not be present in DER, but we accept it). */\n        if (tag_out->construction != CONSTRUCTED)\n            return ASN1_MISMATCH_INDEF;\n        if (recursion >= 32)\n            return ASN1_OVERFLOW;\n        p = asn1;\n        while (!(len >= 2 && p[0] == 0 && p[1] == 0)) {\n            ret = get_tag(p, len, &t, &c, &clen, &p, &len, recursion + 1);\n            if (ret)\n                return ret;\n        }\n        tag_out->tag_end_len = 2;\n        *contents_out = asn1;\n        *clen_out = p - asn1;\n        *remainder_out = p + 2;\n        *rlen_out = len - 2;\n    } else if ((o & 0x80) == 0) {\n        /* Short form (first octet gives content length). */\n        if (o > len)\n            return ASN1_OVERRUN;\n        tag_out->tag_end_len = 0;\n        *contents_out = asn1;\n        *clen_out = o;\n        *remainder_out = asn1 + *clen_out;\n        *rlen_out = len - (*remainder_out - asn1);\n    } else {\n        /* Long form (first octet gives number of base-256 length octets). */\n        llen = o & 0x7F;\n        if (llen > len)\n            return ASN1_OVERRUN;\n        if (llen > sizeof(*clen_out))\n            return ASN1_OVERFLOW;\n        for (i = 0, clen = 0; i < llen; i++)\n            clen = (clen << 8) | asn1[i];\n        if (clen > len - llen)\n            return ASN1_OVERRUN;\n        tag_out->tag_end_len = 0;\n        *contents_out = asn1 + llen;\n        *clen_out = clen;\n        *remainder_out = *contents_out + clen;\n        *rlen_out = len - (*remainder_out - asn1);\n    }\n    tag_out->tag_len = *contents_out - tag_start;\n    return 0;\n}\n\n#ifdef POINTERS_ARE_ALL_THE_SAME\n#define LOADPTR(PTR, TYPE) (*(const void *const *)(PTR))\n#define STOREPTR(PTR, TYPE, VAL) (*(void **)(VAL) = (PTR))\n#else\n#define LOADPTR(PTR, PTRINFO)                                           \\\n    (assert((PTRINFO)->loadptr != NULL), (PTRINFO)->loadptr(PTR))\n#define STOREPTR(PTR, PTRINFO, VAL)                                     \\\n    (assert((PTRINFO)->storeptr != NULL), (PTRINFO)->storeptr(PTR, VAL))\n#endif\n\nstatic size_t\nget_nullterm_sequence_len(const void *valp, const struct atype_info *seq)\n{\n    size_t i;\n    const struct atype_info *a;\n    const struct ptr_info *ptr;\n    const void *elt, *eltptr;\n\n    a = seq;\n    i = 0;\n    assert(a->type == atype_ptr);\n    assert(seq->size != 0);\n    ptr = a->tinfo;\n\n    while (1) {\n        eltptr = (const char *)valp + i * seq->size;\n        elt = LOADPTR(eltptr, ptr);\n        if (elt == NULL)\n            break;\n        i++;\n    }\n    return i;\n}\nstatic krb5_error_code\nencode_sequence_of(asn1buf *buf, size_t seqlen, const void *val,\n                   const struct atype_info *eltinfo);\n\nstatic krb5_error_code\nencode_nullterm_sequence_of(asn1buf *buf, const void *val,\n                            const struct atype_info *type, int can_be_empty)\n{\n    size_t len = get_nullterm_sequence_len(val, type);\n\n    if (!can_be_empty && len == 0)\n        return ASN1_MISSING_FIELD;\n    return encode_sequence_of(buf, len, val, type);\n}\n\nstatic intmax_t\nload_int(const void *val, size_t size)\n{\n    switch (size) {\n    case 1: return *(int8_t *)val;\n    case 2: return *(int16_t *)val;\n    case 4: return *(int32_t *)val;\n    case 8: return *(int64_t *)val;\n    default: abort();\n    }\n}\n\nstatic uintmax_t\nload_uint(const void *val, size_t size)\n{\n    switch (size) {\n    case 1: return *(uint8_t *)val;\n    case 2: return *(uint16_t *)val;\n    case 4: return *(uint32_t *)val;\n    case 8: return *(uint64_t *)val;\n    default: abort();\n    }\n}\n\nstatic krb5_error_code\nload_count(const void *val, const struct counted_info *counted,\n           size_t *count_out)\n{\n    const void *countptr = (const char *)val + counted->lenoff;\n\n    assert(sizeof(size_t) <= sizeof(uintmax_t));\n    if (counted->lensigned) {\n        intmax_t xlen = load_int(countptr, counted->lensize);\n        if (xlen < 0 || (uintmax_t)xlen > SIZE_MAX)\n            return EINVAL;\n        *count_out = xlen;\n    } else {\n        uintmax_t xlen = load_uint(countptr, counted->lensize);\n        if ((size_t)xlen != xlen || xlen > SIZE_MAX)\n            return EINVAL;\n        *count_out = xlen;\n    }\n    return 0;\n}\n\nstatic krb5_error_code\nstore_int(intmax_t intval, size_t size, void *val)\n{\n    switch (size) {\n    case 1:\n        if ((int8_t)intval != intval)\n            return ASN1_OVERFLOW;\n        *(int8_t *)val = intval;\n        return 0;\n    case 2:\n        if ((int16_t)intval != intval)\n            return ASN1_OVERFLOW;\n        *(int16_t *)val = intval;\n        return 0;\n    case 4:\n        if ((int32_t)intval != intval)\n            return ASN1_OVERFLOW;\n        *(int32_t *)val = intval;\n        return 0;\n    case 8:\n        if ((int64_t)intval != intval)\n            return ASN1_OVERFLOW;\n        *(int64_t *)val = intval;\n        return 0;\n    default:\n        abort();\n    }\n}\n\nstatic krb5_error_code\nstore_uint(uintmax_t intval, size_t size, void *val)\n{\n    switch (size) {\n    case 1:\n        if ((uint8_t)intval != intval)\n            return ASN1_OVERFLOW;\n        *(uint8_t *)val = intval;\n        return 0;\n    case 2:\n        if ((uint16_t)intval != intval)\n            return ASN1_OVERFLOW;\n        *(uint16_t *)val = intval;\n        return 0;\n    case 4:\n        if ((uint32_t)intval != intval)\n            return ASN1_OVERFLOW;\n        *(uint32_t *)val = intval;\n        return 0;\n    case 8:\n        if ((uint64_t)intval != intval)\n            return ASN1_OVERFLOW;\n        *(uint64_t *)val = intval;\n        return 0;\n    default:\n        abort();\n    }\n}\n\n/* Store a count value in an integer field of a structure.  If count is\n * SIZE_MAX and the target is a signed field, store -1. */\nstatic krb5_error_code\nstore_count(size_t count, const struct counted_info *counted, void *val)\n{\n    void *countptr = (char *)val + counted->lenoff;\n\n    if (counted->lensigned) {\n        if (count == SIZE_MAX)\n            return store_int(-1, counted->lensize, countptr);\n        else if ((intmax_t)count < 0)\n            return ASN1_OVERFLOW;\n        else\n            return store_int(count, counted->lensize, countptr);\n    } else\n        return store_uint(count, counted->lensize, countptr);\n}\n\n/* Split a DER encoding into tag and contents.  Insert the contents into buf,\n * then return the length of the contents and the tag. */\nstatic krb5_error_code\nsplit_der(asn1buf *buf, uint8_t *const *der, size_t len, taginfo *tag_out)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n\n    ret = get_tag(*der, len, tag_out, &contents, &clen, &remainder, &rlen, 0);\n    if (ret)\n        return ret;\n    if (rlen != 0)\n        return ASN1_BAD_LENGTH;\n    insert_bytes(buf, contents, clen);\n    return 0;\n}\n\n/*\n * Store the DER encoding given by t and asn1/len into the char * or\n * uint8_t * pointed to by val.  Set *count_out to the length of the\n * DER encoding.\n */\nstatic krb5_error_code\nstore_der(const taginfo *t, const uint8_t *asn1, size_t len, void *val,\n          size_t *count_out)\n{\n    uint8_t *der;\n    size_t der_len;\n\n    *count_out = 0;\n    der_len = t->tag_len + len + t->tag_end_len;\n    der = malloc(der_len);\n    if (der == NULL)\n        return ENOMEM;\n    memcpy(der, asn1 - t->tag_len, der_len);\n    *(uint8_t **)val = der;\n    *count_out = der_len;\n    return 0;\n}\n\nstatic krb5_error_code\nencode_sequence(asn1buf *buf, const void *val, const struct seq_info *seq);\nstatic krb5_error_code\nencode_cntype(asn1buf *buf, const void *val, size_t len,\n              const struct cntype_info *c, taginfo *tag_out);\n\n/* Encode a value (contents only, no outer tag) according to a type, and return\n * its encoded tag information. */\nstatic krb5_error_code\nencode_atype(asn1buf *buf, const void *val, const struct atype_info *a,\n             taginfo *tag_out)\n{\n    krb5_error_code ret;\n\n    if (val == NULL)\n        return ASN1_MISSING_FIELD;\n\n    switch (a->type) {\n    case atype_fn: {\n        const struct fn_info *fn = a->tinfo;\n        assert(fn->enc != NULL);\n        return fn->enc(buf, val, tag_out);\n    }\n    case atype_sequence:\n        assert(a->tinfo != NULL);\n        ret = encode_sequence(buf, val, a->tinfo);\n        if (ret)\n            return ret;\n        tag_out->asn1class = UNIVERSAL;\n        tag_out->construction = CONSTRUCTED;\n        tag_out->tagnum = ASN1_SEQUENCE;\n        break;\n    case atype_ptr: {\n        const struct ptr_info *ptr = a->tinfo;\n        assert(ptr->basetype != NULL);\n        return encode_atype(buf, LOADPTR(val, ptr), ptr->basetype, tag_out);\n    }\n    case atype_offset: {\n        const struct offset_info *off = a->tinfo;\n        assert(off->basetype != NULL);\n        return encode_atype(buf, (const char *)val + off->dataoff,\n                            off->basetype, tag_out);\n    }\n    case atype_optional: {\n        const struct optional_info *opt = a->tinfo;\n        assert(opt->is_present != NULL);\n        if (opt->is_present(val))\n            return encode_atype(buf, val, opt->basetype, tag_out);\n        else\n            return ASN1_OMITTED;\n    }\n    case atype_counted: {\n        const struct counted_info *counted = a->tinfo;\n        const void *dataptr = (const char *)val + counted->dataoff;\n        size_t count;\n        assert(counted->basetype != NULL);\n        ret = load_count(val, counted, &count);\n        if (ret)\n            return ret;\n        return encode_cntype(buf, dataptr, count, counted->basetype, tag_out);\n    }\n    case atype_nullterm_sequence_of:\n    case atype_nonempty_nullterm_sequence_of:\n        assert(a->tinfo != NULL);\n        ret = encode_nullterm_sequence_of(buf, val, a->tinfo,\n                                          a->type ==\n                                          atype_nullterm_sequence_of);\n        if (ret)\n            return ret;\n        tag_out->asn1class = UNIVERSAL;\n        tag_out->construction = CONSTRUCTED;\n        tag_out->tagnum = ASN1_SEQUENCE;\n        break;\n    case atype_tagged_thing: {\n        const struct tagged_info *tag = a->tinfo;\n        size_t oldcount = buf->count;\n        ret = encode_atype(buf, val, tag->basetype, tag_out);\n        if (ret)\n            return ret;\n        if (!tag->implicit) {\n            ret = make_tag(buf, tag_out, buf->count - oldcount);\n            if (ret)\n                return ret;\n            tag_out->construction = tag->construction;\n        }\n        tag_out->asn1class = tag->tagtype;\n        tag_out->tagnum = tag->tagval;\n        break;\n    }\n    case atype_bool:\n        k5_asn1_encode_bool(buf, load_int(val, a->size));\n        tag_out->asn1class = UNIVERSAL;\n        tag_out->construction = PRIMITIVE;\n        tag_out->tagnum = ASN1_BOOLEAN;\n        break;\n    case atype_int:\n        k5_asn1_encode_int(buf, load_int(val, a->size));\n        tag_out->asn1class = UNIVERSAL;\n        tag_out->construction = PRIMITIVE;\n        tag_out->tagnum = ASN1_INTEGER;\n        break;\n    case atype_uint:\n        k5_asn1_encode_uint(buf, load_uint(val, a->size));\n        tag_out->asn1class = UNIVERSAL;\n        tag_out->construction = PRIMITIVE;\n        tag_out->tagnum = ASN1_INTEGER;\n        break;\n    case atype_int_immediate: {\n        const struct immediate_info *imm = a->tinfo;\n        k5_asn1_encode_int(buf, imm->val);\n        tag_out->asn1class = UNIVERSAL;\n        tag_out->construction = PRIMITIVE;\n        tag_out->tagnum = ASN1_INTEGER;\n        break;\n    }\n    default:\n        assert(a->type > atype_min);\n        assert(a->type < atype_max);\n        abort();\n    }\n\n    return 0;\n}\n\nstatic krb5_error_code\nencode_atype_and_tag(asn1buf *buf, const void *val, const struct atype_info *a)\n{\n    taginfo t;\n    krb5_error_code ret;\n    size_t oldcount = buf->count;\n\n    ret = encode_atype(buf, val, a, &t);\n    if (ret)\n        return ret;\n    ret = make_tag(buf, &t, buf->count - oldcount);\n    if (ret)\n        return ret;\n    return 0;\n}\n\n/*\n * Encode an object and count according to a cntype_info structure.  val is a\n * pointer to the object being encoded, which in most cases is itself a\n * pointer (but is a union in the cntype_choice case).\n */\nstatic krb5_error_code\nencode_cntype(asn1buf *buf, const void *val, size_t count,\n              const struct cntype_info *c, taginfo *tag_out)\n{\n    krb5_error_code ret;\n\n    switch (c->type) {\n    case cntype_string: {\n        const struct string_info *string = c->tinfo;\n        assert(string->enc != NULL);\n        ret = string->enc(buf, val, count);\n        if (ret)\n            return ret;\n        tag_out->asn1class = UNIVERSAL;\n        tag_out->construction = PRIMITIVE;\n        tag_out->tagnum = string->tagval;\n        break;\n    }\n    case cntype_der:\n        return split_der(buf, val, count, tag_out);\n    case cntype_seqof: {\n        const struct atype_info *a = c->tinfo;\n        const struct ptr_info *ptr = a->tinfo;\n        assert(a->type == atype_ptr);\n        val = LOADPTR(val, ptr);\n        ret = encode_sequence_of(buf, count, val, ptr->basetype);\n        if (ret)\n            return ret;\n        tag_out->asn1class = UNIVERSAL;\n        tag_out->construction = CONSTRUCTED;\n        tag_out->tagnum = ASN1_SEQUENCE;\n        break;\n    }\n    case cntype_choice: {\n        const struct choice_info *choice = c->tinfo;\n        if (count >= choice->n_options)\n            return ASN1_MISSING_FIELD;\n        return encode_atype(buf, val, choice->options[count], tag_out);\n    }\n\n    default:\n        assert(c->type > cntype_min);\n        assert(c->type < cntype_max);\n        abort();\n    }\n\n    return 0;\n}\n\nstatic krb5_error_code\nencode_sequence(asn1buf *buf, const void *val, const struct seq_info *seq)\n{\n    krb5_error_code ret;\n    size_t i;\n\n    for (i = seq->n_fields; i > 0; i--) {\n        ret = encode_atype_and_tag(buf, val, seq->fields[i - 1]);\n        if (ret == ASN1_OMITTED)\n            continue;\n        else if (ret != 0)\n            return ret;\n    }\n    return 0;\n}\n\nstatic krb5_error_code\nencode_sequence_of(asn1buf *buf, size_t seqlen, const void *val,\n                   const struct atype_info *eltinfo)\n{\n    krb5_error_code ret;\n    size_t i;\n    const void *eltptr;\n\n    assert(eltinfo->size != 0);\n    for (i = seqlen; i > 0; i--) {\n        eltptr = (const char *)val + (i - 1) * eltinfo->size;\n        ret = encode_atype_and_tag(buf, eltptr, eltinfo);\n        if (ret)\n            return ret;\n    }\n    return 0;\n}\n\n/**** Functions for freeing C objects based on type info ****/\n\nstatic void free_atype_ptr(const struct atype_info *a, void *val);\nstatic void free_sequence(const struct seq_info *seq, void *val);\nstatic void free_sequence_of(const struct atype_info *eltinfo, void *val,\n                             size_t count);\nstatic void free_cntype(const struct cntype_info *a, void *val, size_t count);\n\n/*\n * Free a C object according to a type description.  Do not free pointers at\n * the first level; they may be referenced by other fields of a sequence, and\n * will be freed by free_atype_ptr in a second pass.\n */\nstatic void\nfree_atype(const struct atype_info *a, void *val)\n{\n    switch (a->type) {\n    case atype_fn: {\n        const struct fn_info *fn = a->tinfo;\n        if (fn->free_func != NULL)\n            fn->free_func(val);\n        break;\n    }\n    case atype_sequence:\n        free_sequence(a->tinfo, val);\n        break;\n    case atype_ptr: {\n        const struct ptr_info *ptrinfo = a->tinfo;\n        void *ptr = LOADPTR(val, ptrinfo);\n        if (ptr != NULL) {\n            free_atype(ptrinfo->basetype, ptr);\n            free_atype_ptr(ptrinfo->basetype, ptr);\n        }\n        break;\n    }\n    case atype_offset: {\n        const struct offset_info *off = a->tinfo;\n        assert(off->basetype != NULL);\n        free_atype(off->basetype, (char *)val + off->dataoff);\n        break;\n    }\n    case atype_optional: {\n        const struct optional_info *opt = a->tinfo;\n        free_atype(opt->basetype, val);\n        break;\n    }\n    case atype_counted: {\n        const struct counted_info *counted = a->tinfo;\n        void *dataptr = (char *)val + counted->dataoff;\n        size_t count;\n        if (load_count(val, counted, &count) == 0)\n            free_cntype(counted->basetype, dataptr, count);\n        break;\n    }\n    case atype_nullterm_sequence_of:\n    case atype_nonempty_nullterm_sequence_of: {\n        size_t count = get_nullterm_sequence_len(val, a->tinfo);\n        free_sequence_of(a->tinfo, val, count);\n        break;\n    }\n    case atype_tagged_thing: {\n        const struct tagged_info *tag = a->tinfo;\n        free_atype(tag->basetype, val);\n        break;\n    }\n    case atype_bool:\n    case atype_int:\n    case atype_uint:\n    case atype_int_immediate:\n        break;\n    default:\n        abort();\n    }\n}\n\nstatic void\nfree_atype_ptr(const struct atype_info *a, void *val)\n{\n    switch (a->type) {\n    case atype_fn:\n    case atype_sequence:\n    case atype_counted:\n    case atype_nullterm_sequence_of:\n    case atype_nonempty_nullterm_sequence_of:\n    case atype_bool:\n    case atype_int:\n    case atype_uint:\n    case atype_int_immediate:\n         break;\n    case atype_ptr: {\n        const struct ptr_info *ptrinfo = a->tinfo;\n        void *ptr = LOADPTR(val, ptrinfo);\n        free(ptr);\n        STOREPTR(NULL, ptrinfo, val);\n        break;\n    }\n    case atype_offset: {\n        const struct offset_info *off = a->tinfo;\n        assert(off->basetype != NULL);\n        free_atype_ptr(off->basetype, (char *)val + off->dataoff);\n        break;\n    }\n    case atype_optional: {\n        const struct optional_info *opt = a->tinfo;\n        free_atype_ptr(opt->basetype, val);\n        break;\n    }\n    case atype_tagged_thing: {\n        const struct tagged_info *tag = a->tinfo;\n        free_atype_ptr(tag->basetype, val);\n        break;\n    }\n    default:\n        abort();\n    }\n}\n\nstatic void\nfree_cntype(const struct cntype_info *c, void *val, size_t count)\n{\n    switch (c->type) {\n    case cntype_string:\n    case cntype_der:\n        free(*(char **)val);\n        *(char **)val = NULL;\n        break;\n    case cntype_seqof: {\n        const struct atype_info *a = c->tinfo;\n        const struct ptr_info *ptrinfo = a->tinfo;\n        void *seqptr = LOADPTR(val, ptrinfo);\n        free_sequence_of(ptrinfo->basetype, seqptr, count);\n        free(seqptr);\n        STOREPTR(NULL, ptrinfo, val);\n        break;\n    }\n    case cntype_choice: {\n        const struct choice_info *choice = c->tinfo;\n        if (count < choice->n_options) {\n            free_atype(choice->options[count], val);\n            free_atype_ptr(choice->options[count], val);\n        }\n        break;\n    }\n    default:\n        abort();\n    }\n}\n\nstatic void\nfree_sequence(const struct seq_info *seq, void *val)\n{\n    size_t i;\n\n    for (i = 0; i < seq->n_fields; i++)\n        free_atype(seq->fields[i], val);\n    for (i = 0; i < seq->n_fields; i++)\n        free_atype_ptr(seq->fields[i], val);\n}\n\nstatic void\nfree_sequence_of(const struct atype_info *eltinfo, void *val, size_t count)\n{\n    void *eltptr;\n\n    assert(eltinfo->size != 0);\n    while (count-- > 0) {\n        eltptr = (char *)val + count * eltinfo->size;\n        free_atype(eltinfo, eltptr);\n        free_atype_ptr(eltinfo, eltptr);\n    }\n}\n\n/**** Functions for decoding objects based on type info ****/\n\n/* Return nonzero if t is an expected tag for an ASN.1 object of type a. */\nstatic int\ncheck_atype_tag(const struct atype_info *a, const taginfo *t)\n{\n    switch (a->type) {\n    case atype_fn: {\n        const struct fn_info *fn = a->tinfo;\n        assert(fn->check_tag != NULL);\n        return fn->check_tag(t);\n    }\n    case atype_sequence:\n    case atype_nullterm_sequence_of:\n    case atype_nonempty_nullterm_sequence_of:\n        return (t->asn1class == UNIVERSAL && t->construction == CONSTRUCTED &&\n                t->tagnum == ASN1_SEQUENCE);\n    case atype_ptr: {\n        const struct ptr_info *ptrinfo = a->tinfo;\n        return check_atype_tag(ptrinfo->basetype, t);\n    }\n    case atype_offset: {\n        const struct offset_info *off = a->tinfo;\n        return check_atype_tag(off->basetype, t);\n    }\n    case atype_optional: {\n        const struct optional_info *opt = a->tinfo;\n        return check_atype_tag(opt->basetype, t);\n    }\n    case atype_counted: {\n        const struct counted_info *counted = a->tinfo;\n        switch (counted->basetype->type) {\n        case cntype_string: {\n            const struct string_info *string = counted->basetype->tinfo;\n            return (t->asn1class == UNIVERSAL &&\n                    t->construction == PRIMITIVE &&\n                    t->tagnum == string->tagval);\n        }\n        case cntype_seqof:\n            return (t->asn1class == UNIVERSAL &&\n                    t->construction == CONSTRUCTED &&\n                    t->tagnum == ASN1_SEQUENCE);\n        case cntype_der:\n            /*\n             * We treat any tag as matching a stored DER encoding.  In some\n             * cases we know what the tag should be; in others, we truly want\n             * to accept any tag.  If it ever becomes an issue, we could add\n             * optional tag info to the type and check it here.\n             */\n            return 1;\n        case cntype_choice:\n            /*\n             * ASN.1 choices may or may not be extensible.  For now, we treat\n             * all choices as extensible and match any tag.  We should consider\n             * modeling whether choices are extensible before making the\n             * encoder visible to plugins.\n             */\n            return 1;\n        default:\n            abort();\n        }\n    }\n    case atype_tagged_thing: {\n        const struct tagged_info *tag = a->tinfo;\n        /* NOTE: Doesn't check construction bit for implicit tags. */\n        if (!tag->implicit && t->construction != tag->construction)\n            return 0;\n        return (t->asn1class == tag->tagtype && t->tagnum == tag->tagval);\n    }\n    case atype_bool:\n        return (t->asn1class == UNIVERSAL && t->construction == PRIMITIVE &&\n                t->tagnum == ASN1_BOOLEAN);\n    case atype_int:\n    case atype_uint:\n    case atype_int_immediate:\n        return (t->asn1class == UNIVERSAL && t->construction == PRIMITIVE &&\n                t->tagnum == ASN1_INTEGER);\n    default:\n        abort();\n    }\n}\n\nstatic krb5_error_code\ndecode_cntype(const taginfo *t, const uint8_t *asn1, size_t len,\n              const struct cntype_info *c, void *val, size_t *count_out);\nstatic krb5_error_code\ndecode_atype_to_ptr(const taginfo *t, const uint8_t *asn1, size_t len,\n                    const struct atype_info *basetype, void **ptr_out);\nstatic krb5_error_code\ndecode_sequence(const uint8_t *asn1, size_t len, const struct seq_info *seq,\n                void *val);\nstatic krb5_error_code\ndecode_sequence_of(const uint8_t *asn1, size_t len,\n                   const struct atype_info *elemtype, void **seq_out,\n                   size_t *count_out);\n\n/* Given the enclosing tag t, decode from asn1/len the contents of the ASN.1\n * type specified by a, placing the result into val (caller-allocated). */\nstatic krb5_error_code\ndecode_atype(const taginfo *t, const uint8_t *asn1, size_t len,\n             const struct atype_info *a, void *val)\n{\n    krb5_error_code ret;\n\n    switch (a->type) {\n    case atype_fn: {\n        const struct fn_info *fn = a->tinfo;\n        assert(fn->dec != NULL);\n        return fn->dec(t, asn1, len, val);\n    }\n    case atype_sequence:\n        return decode_sequence(asn1, len, a->tinfo, val);\n    case atype_ptr: {\n        const struct ptr_info *ptrinfo = a->tinfo;\n        void *ptr = LOADPTR(val, ptrinfo);\n        assert(ptrinfo->basetype != NULL);\n        if (ptr != NULL) {\n            /* Container was already allocated by a previous sequence field. */\n            return decode_atype(t, asn1, len, ptrinfo->basetype, ptr);\n        } else {\n            ret = decode_atype_to_ptr(t, asn1, len, ptrinfo->basetype, &ptr);\n            if (ret)\n                return ret;\n            STOREPTR(ptr, ptrinfo, val);\n            break;\n        }\n    }\n    case atype_offset: {\n        const struct offset_info *off = a->tinfo;\n        assert(off->basetype != NULL);\n        return decode_atype(t, asn1, len, off->basetype,\n                            (char *)val + off->dataoff);\n    }\n    case atype_optional: {\n        const struct optional_info *opt = a->tinfo;\n        return decode_atype(t, asn1, len, opt->basetype, val);\n    }\n    case atype_counted: {\n        const struct counted_info *counted = a->tinfo;\n        void *dataptr = (char *)val + counted->dataoff;\n        size_t count;\n        assert(counted->basetype != NULL);\n        ret = decode_cntype(t, asn1, len, counted->basetype, dataptr, &count);\n        if (ret)\n            return ret;\n        return store_count(count, counted, val);\n    }\n    case atype_tagged_thing: {\n        const struct tagged_info *tag = a->tinfo;\n        taginfo inner_tag;\n        const taginfo *tp = t;\n        const uint8_t *rem;\n        size_t rlen;\n        if (!tag->implicit) {\n            ret = get_tag(asn1, len, &inner_tag, &asn1, &len, &rem, &rlen, 0);\n            if (ret)\n                return ret;\n            /* Note: we don't check rlen (it should be 0). */\n            tp = &inner_tag;\n            if (!check_atype_tag(tag->basetype, tp))\n                return ASN1_BAD_ID;\n        }\n        return decode_atype(tp, asn1, len, tag->basetype, val);\n    }\n    case atype_bool: {\n        intmax_t intval;\n        ret = k5_asn1_decode_bool(asn1, len, &intval);\n        if (ret)\n            return ret;\n        return store_int(intval, a->size, val);\n    }\n    case atype_int: {\n        intmax_t intval;\n        ret = k5_asn1_decode_int(asn1, len, &intval);\n        if (ret)\n            return ret;\n        return store_int(intval, a->size, val);\n    }\n    case atype_uint: {\n        uintmax_t intval;\n        ret = k5_asn1_decode_uint(asn1, len, &intval);\n        if (ret)\n            return ret;\n        return store_uint(intval, a->size, val);\n    }\n    case atype_int_immediate: {\n        const struct immediate_info *imm = a->tinfo;\n        intmax_t intval;\n        ret = k5_asn1_decode_int(asn1, len, &intval);\n        if (ret)\n            return ret;\n        if (intval != imm->val && imm->err != 0)\n            return imm->err;\n        break;\n    }\n    default:\n        /* Null-terminated sequence types are handled in decode_atype_to_ptr,\n         * since they create variable-sized objects. */\n        assert(a->type != atype_nullterm_sequence_of);\n        assert(a->type != atype_nonempty_nullterm_sequence_of);\n        assert(a->type > atype_min);\n        assert(a->type < atype_max);\n        abort();\n    }\n    return 0;\n}\n\n/*\n * Given the enclosing tag t, decode from asn1/len the contents of the\n * ASN.1 type described by c, placing the counted result into val/count_out.\n * If the resulting count should be -1 (for an unknown union distinguisher),\n * set *count_out to SIZE_MAX.\n */\nstatic krb5_error_code\ndecode_cntype(const taginfo *t, const uint8_t *asn1, size_t len,\n              const struct cntype_info *c, void *val, size_t *count_out)\n{\n    krb5_error_code ret;\n\n    switch (c->type) {\n    case cntype_string: {\n        const struct string_info *string = c->tinfo;\n        assert(string->dec != NULL);\n        return string->dec(asn1, len, val, count_out);\n    }\n    case cntype_der:\n        return store_der(t, asn1, len, val, count_out);\n    case cntype_seqof: {\n        const struct atype_info *a = c->tinfo;\n        const struct ptr_info *ptrinfo = a->tinfo;\n        void *seq;\n        assert(a->type == atype_ptr);\n        ret = decode_sequence_of(asn1, len, ptrinfo->basetype, &seq,\n                                 count_out);\n        if (ret)\n            return ret;\n        STOREPTR(seq, ptrinfo, val);\n        break;\n    }\n    case cntype_choice: {\n        const struct choice_info *choice = c->tinfo;\n        size_t i;\n        for (i = 0; i < choice->n_options; i++) {\n            if (check_atype_tag(choice->options[i], t)) {\n                ret = decode_atype(t, asn1, len, choice->options[i], val);\n                if (ret)\n                    return ret;\n                *count_out = i;\n                return 0;\n            }\n        }\n        /* SIZE_MAX will be stored as -1 in the distinguisher.  If we start\n         * modeling non-extensible choices we should check that here. */\n        *count_out = SIZE_MAX;\n        break;\n    }\n    default:\n        assert(c->type > cntype_min);\n        assert(c->type < cntype_max);\n        abort();\n    }\n    return 0;\n}\n\n/* Add a null pointer to the end of a sequence.  ptr is consumed on success\n * (to be replaced by *ptr_out), left alone on failure. */\nstatic krb5_error_code\nnull_terminate(const struct atype_info *eltinfo, void *ptr, size_t count,\n               void **ptr_out)\n{\n    const struct ptr_info *ptrinfo = eltinfo->tinfo;\n    void *endptr;\n\n    assert(eltinfo->type == atype_ptr);\n    ptr = realloc(ptr, (count + 1) * eltinfo->size);\n    if (ptr == NULL)\n        return ENOMEM;\n    endptr = (char *)ptr + count * eltinfo->size;\n    STOREPTR(NULL, ptrinfo, endptr);\n    *ptr_out = ptr;\n    return 0;\n}\n\nstatic krb5_error_code\ndecode_atype_to_ptr(const taginfo *t, const uint8_t *asn1, size_t len,\n                    const struct atype_info *a, void **ptr_out)\n{\n    krb5_error_code ret;\n    void *ptr;\n    size_t count;\n\n    *ptr_out = NULL;\n    switch (a->type) {\n    case atype_nullterm_sequence_of:\n    case atype_nonempty_nullterm_sequence_of:\n        ret = decode_sequence_of(asn1, len, a->tinfo, &ptr, &count);\n        if (ret)\n            return ret;\n        ret = null_terminate(a->tinfo, ptr, count, &ptr);\n        if (ret) {\n            free_sequence_of(a->tinfo, ptr, count);\n            return ret;\n        }\n        /* Historically we do not enforce non-emptiness of sequences when\n         * decoding, even when it is required by the ASN.1 type. */\n        break;\n    default:\n        ptr = calloc(a->size, 1);\n        if (ptr == NULL)\n            return ENOMEM;\n        ret = decode_atype(t, asn1, len, a, ptr);\n        if (ret) {\n            free(ptr);\n            return ret;\n        }\n        break;\n    }\n    *ptr_out = ptr;\n    return 0;\n}\n\n/* Initialize a C object when the corresponding ASN.1 type was omitted within a\n * sequence.  If the ASN.1 type is not optional, return ASN1_MISSING_FIELD. */\nstatic krb5_error_code\nomit_atype(const struct atype_info *a, void *val)\n{\n    switch (a->type)\n    {\n    case atype_fn:\n    case atype_sequence:\n    case atype_nullterm_sequence_of:\n    case atype_nonempty_nullterm_sequence_of:\n    case atype_counted:\n    case atype_bool:\n    case atype_int:\n    case atype_uint:\n    case atype_int_immediate:\n        return ASN1_MISSING_FIELD;\n    case atype_ptr: {\n        const struct ptr_info *ptrinfo = a->tinfo;\n        return omit_atype(ptrinfo->basetype, val);\n    }\n    case atype_offset: {\n        const struct offset_info *off = a->tinfo;\n        return omit_atype(off->basetype, (char *)val + off->dataoff);\n    }\n    case atype_tagged_thing: {\n        const struct tagged_info *tag = a->tinfo;\n        return omit_atype(tag->basetype, val);\n    }\n    case atype_optional: {\n        const struct optional_info *opt = a->tinfo;\n        if (opt->init != NULL)\n            opt->init(val);\n        return 0;\n    }\n    default:\n        abort();\n    }\n}\n\n/* Decode an ASN.1 sequence into a C object. */\nstatic krb5_error_code\ndecode_sequence(const uint8_t *asn1, size_t len, const struct seq_info *seq,\n                void *val)\n{\n    krb5_error_code ret;\n    const uint8_t *contents;\n    size_t i, j, clen;\n    taginfo t;\n\n    assert(seq->n_fields > 0);\n    for (i = 0; i < seq->n_fields; i++) {\n        if (len == 0)\n            break;\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len, 0);\n        if (ret)\n            goto error;\n        /*\n         * Find the applicable sequence field.  This logic is a little\n         * oversimplified; we could match an element to an optional extensible\n         * choice or optional stored-DER type when we ought to match a\n         * subsequent non-optional field.  But it's unwise and (hopefully) very\n         * rare for ASN.1 modules to require such precision.\n         */\n        for (; i < seq->n_fields; i++) {\n            if (check_atype_tag(seq->fields[i], &t))\n                break;\n            ret = omit_atype(seq->fields[i], val);\n            if (ret)\n                goto error;\n        }\n        /* We currently model all sequences as extensible.  We should consider\n         * changing this before making the encoder visible to plugins. */\n        if (i == seq->n_fields)\n            break;\n        ret = decode_atype(&t, contents, clen, seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    /* Initialize any fields in the C object which were not accounted for in\n     * the sequence.  Error out if any of them aren't optional. */\n    for (; i < seq->n_fields; i++) {\n        ret = omit_atype(seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    return 0;\n\nerror:\n    /* Free what we've decoded so far.  Free pointers in a second pass in\n     * case multiple fields refer to the same pointer. */\n    for (j = 0; j < i; j++)\n        free_atype(seq->fields[j], val);\n    for (j = 0; j < i; j++)\n        free_atype_ptr(seq->fields[j], val);\n    return ret;\n}\n\nstatic krb5_error_code\ndecode_sequence_of(const uint8_t *asn1, size_t len,\n                   const struct atype_info *elemtype, void **seq_out,\n                   size_t *count_out)\n{\n    krb5_error_code ret;\n    void *seq = NULL, *elem, *newseq;\n    const uint8_t *contents;\n    size_t clen, count = 0;\n    taginfo t;\n\n    *seq_out = NULL;\n    *count_out = 0;\n    while (len > 0) {\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len, 0);\n        if (ret)\n            goto error;\n        if (!check_atype_tag(elemtype, &t)) {\n            ret = ASN1_BAD_ID;\n            goto error;\n        }\n        newseq = realloc(seq, (count + 1) * elemtype->size);\n        if (newseq == NULL) {\n            ret = ENOMEM;\n            goto error;\n        }\n        seq = newseq;\n        elem = (char *)seq + count * elemtype->size;\n        memset(elem, 0, elemtype->size);\n        ret = decode_atype(&t, contents, clen, elemtype, elem);\n        if (ret)\n            goto error;\n        count++;\n    }\n    *seq_out = seq;\n    *count_out = count;\n    return 0;\n\nerror:\n    free_sequence_of(elemtype, seq, count);\n    free(seq);\n    return ret;\n}\n\n/* These three entry points are only needed for the kdc_req_body hack and may\n * go away at some point.  Define them here so we can use short names above. */\n\nkrb5_error_code\nk5_asn1_encode_atype(asn1buf *buf, const void *val, const struct atype_info *a,\n                     taginfo *tag_out)\n{\n    return encode_atype(buf, val, a, tag_out);\n}\n\nkrb5_error_code\nk5_asn1_decode_atype(const taginfo *t, const uint8_t *asn1, size_t len,\n                     const struct atype_info *a, void *val)\n{\n    return decode_atype(t, asn1, len, a, val);\n}\n\nkrb5_error_code\nk5_asn1_full_encode(const void *rep, const struct atype_info *a,\n                    krb5_data **code_out)\n{\n    krb5_error_code ret;\n    asn1buf buf;\n    krb5_data *d;\n    uint8_t *bytes;\n\n    *code_out = NULL;\n\n    if (rep == NULL)\n        return ASN1_MISSING_FIELD;\n\n    /* Make a first pass over rep to count the encoding size. */\n    buf.ptr = NULL;\n    buf.count = 0;\n    ret = encode_atype_and_tag(&buf, rep, a);\n    if (ret)\n        return ret;\n\n    /* Allocate space for the encoding. */\n    bytes = malloc(buf.count + 1);\n    if (bytes == NULL)\n        return ENOMEM;\n    bytes[buf.count] = 0;\n\n    /* Make a second pass over rep to encode it.  buf.ptr moves backwards as we\n     * encode, and will always exactly return to the base. */\n    buf.ptr = bytes + buf.count;\n    buf.count = 0;\n    ret = encode_atype_and_tag(&buf, rep, a);\n    if (ret) {\n        free(bytes);\n        return ret;\n    }\n    assert(buf.ptr == bytes);\n\n    /* Create the output data object. */\n    *code_out = malloc(sizeof(*d));\n    if (*code_out == NULL) {\n        free(bytes);\n        return ENOMEM;\n    }\n    **code_out = make_data(bytes, buf.count);\n    return 0;\n}\n\nkrb5_error_code\nk5_asn1_full_decode(const krb5_data *code, const struct atype_info *a,\n                    void **retrep)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n    taginfo t;\n\n    *retrep = NULL;\n    ret = get_tag((uint8_t *)code->data, code->length, &t, &contents,\n                  &clen, &remainder, &rlen, 0);\n    if (ret)\n        return ret;\n    /* rlen should be 0, but we don't check it (and due to padding in\n     * non-length-preserving enctypes, it will sometimes be nonzero). */\n    if (!check_atype_tag(a, &t))\n        return ASN1_BAD_ID;\n    return decode_atype_to_ptr(&t, contents, clen, a, retrep);\n}\n"], "filenames": ["src/lib/krb5/asn.1/asn1_encode.c"], "buggy_code_start_loc": [359], "buggy_code_end_loc": [1588], "fixing_code_start_loc": [359], "fixing_code_end_loc": [1590], "type": "CWE-674", "message": "MIT Kerberos 5 (aka krb5) before 1.17.2 and 1.18.x before 1.18.3 allows unbounded recursion via an ASN.1-encoded Kerberos message because the lib/krb5/asn.1/asn1_encode.c support for BER indefinite lengths lacks a recursion limit.", "other": {"cve": {"id": "CVE-2020-28196", "sourceIdentifier": "cve@mitre.org", "published": "2020-11-06T08:15:13.860", "lastModified": "2022-05-12T14:47:13.277", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "MIT Kerberos 5 (aka krb5) before 1.17.2 and 1.18.x before 1.18.3 allows unbounded recursion via an ASN.1-encoded Kerberos message because the lib/krb5/asn.1/asn1_encode.c support for BER indefinite lengths lacks a recursion limit."}, {"lang": "es", "value": "MIT Kerberos versi\u00f3n 5 (tambi\u00e9n se conoce como krb5) versiones anteriores a 1.17.2 y versiones 1.18.x anteriores a 1.18.3, permite una recursividad ilimitada por medio de un mensaje Kerberos codificado en ASN.1 porque el soporte de la biblioteca lib/krb5 /asn.1/asn1_encode.c para longitudes indefinidas BER carece un l\u00edmite de recursividad"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-674"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.17.2", "matchCriteriaId": "2165B9A8-9DE4-48CB-B64A-7D0B8622C385"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.18.0", "versionEndExcluding": "1.18.3", "matchCriteriaId": "F5E19D5A-961C-4F77-BA53-4DC84EAA5223"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:vmware_vsphere:*:*", "matchCriteriaId": "3A756737-1CC4-42C2-A4DF-E1C893B4E2D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:windows:*:*", "matchCriteriaId": "B55E8D50-99B4-47EC-86F9-699B67D473CE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:cloud_backup:-:*:*:*:*:*:*:*", "matchCriteriaId": "5C2089EE-5D7F-47EC-8EA5-0F69790564C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:oncommand_insight:-:*:*:*:*:*:*:*", "matchCriteriaId": "F1BE6C1F-2565-4E97-92AA-16563E5660A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:oncommand_workflow_automation:-:*:*:*:*:*:*:*", "matchCriteriaId": "5735E553-9731-4AAC-BCFF-989377F817B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:snapcenter:-:*:*:*:*:*:*:*", "matchCriteriaId": "BDFB1169-41A0-4A86-8E4F-FDA9730B1E94"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_policy:1.14.0:*:*:*:*:*:*:*", "matchCriteriaId": "4479F76A-4B67-41CC-98C7-C76B81050F8E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_offline_mediation_controller:12.0.0.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "49ACFC73-A509-4D1C-8FC3-F68F495AB055"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_pricing_design_center:12.0.0.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "D7B49D71-6A31-497A-B6A9-06E84F086E7A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:mysql_server:*:*:*:*:*:*:*:*", "versionEndIncluding": "8.0.23", "matchCriteriaId": "71560664-D26B-4A67-BE0F-5FCBE0E117BF"}]}]}], "references": [{"url": "https://github.com/krb5/krb5/commit/57415dda6cf04e73ffc3723be518eddfae599bfd", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r58af02e294bd07f487e2c64ffc0a29b837db5600e33b6e698b9d696b@%3Cissues.bookkeeper.apache.org%3E", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rf4c02775860db415b4955778a131c2795223f61cb8c6a450893651e4@%3Cissues.bookkeeper.apache.org%3E", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/11/msg00011.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/45KKOZQWIIIW5C45PJVGQ32AXBSYNBE7/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/73IGOG6CZAVMVNS4GGRMOLOZ7B6QVA7F/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/KPH2V3WSQTELROZK3GFCPQDOFLKIZ6H5/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202011-17", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20201202-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210513-0002/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4795", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com//security-alerts/cpujul2021.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuApr2021.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2022.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/krb5/krb5/commit/57415dda6cf04e73ffc3723be518eddfae599bfd"}}