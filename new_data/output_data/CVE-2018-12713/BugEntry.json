{"buggy_code": ["/* GIMP - The GNU Image Manipulation Program\n * Copyright (C) 2009 Martin Nordholts\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"config.h\"\n\n#include <string.h>\n\n#include <gegl.h>\n#include <gtk/gtk.h>\n\n#include \"libgimpbase/gimpbase.h\"\n\n#include \"widgets/widgets-types.h\"\n\n#include \"widgets/gimpuimanager.h\"\n\n#include \"core/gimp.h\"\n#include \"core/gimpchannel.h\"\n#include \"core/gimpchannel-select.h\"\n#include \"core/gimpdrawable.h\"\n#include \"core/gimpgrid.h\"\n#include \"core/gimpgrouplayer.h\"\n#include \"core/gimpguide.h\"\n#include \"core/gimpimage.h\"\n#include \"core/gimpimage-grid.h\"\n#include \"core/gimpimage-guides.h\"\n#include \"core/gimpimage-sample-points.h\"\n#include \"core/gimplayer.h\"\n#include \"core/gimplayer-new.h\"\n#include \"core/gimpsamplepoint.h\"\n#include \"core/gimpselection.h\"\n\n#include \"vectors/gimpanchor.h\"\n#include \"vectors/gimpbezierstroke.h\"\n#include \"vectors/gimpvectors.h\"\n\n#include \"plug-in/gimppluginmanager-file.h\"\n\n#include \"file/file-open.h\"\n#include \"file/file-save.h\"\n\n#include \"tests.h\"\n\n#include \"gimp-app-test-utils.h\"\n\n\n/* we continue to use LEGACY layers for testing, so we can use the\n * same test image for all tests, including loading\n * files/gimp-2-6-file.xcf which can't have any non-LEGACY modes\n */\n\n#define GIMP_MAINIMAGE_WIDTH            100\n#define GIMP_MAINIMAGE_HEIGHT           90\n#define GIMP_MAINIMAGE_TYPE             GIMP_RGB\n#define GIMP_MAINIMAGE_PRECISION        GIMP_PRECISION_U8_GAMMA\n\n#define GIMP_MAINIMAGE_LAYER1_NAME      \"layer1\"\n#define GIMP_MAINIMAGE_LAYER1_WIDTH     50\n#define GIMP_MAINIMAGE_LAYER1_HEIGHT    51\n#define GIMP_MAINIMAGE_LAYER1_FORMAT    babl_format (\"R'G'B'A u8\")\n#define GIMP_MAINIMAGE_LAYER1_OPACITY   GIMP_OPACITY_OPAQUE\n#define GIMP_MAINIMAGE_LAYER1_MODE      GIMP_LAYER_MODE_NORMAL_LEGACY\n\n#define GIMP_MAINIMAGE_LAYER2_NAME      \"layer2\"\n#define GIMP_MAINIMAGE_LAYER2_WIDTH     25\n#define GIMP_MAINIMAGE_LAYER2_HEIGHT    251\n#define GIMP_MAINIMAGE_LAYER2_FORMAT    babl_format (\"R'G'B' u8\")\n#define GIMP_MAINIMAGE_LAYER2_OPACITY   GIMP_OPACITY_TRANSPARENT\n#define GIMP_MAINIMAGE_LAYER2_MODE      GIMP_LAYER_MODE_MULTIPLY_LEGACY\n\n#define GIMP_MAINIMAGE_GROUP1_NAME      \"group1\"\n\n#define GIMP_MAINIMAGE_LAYER3_NAME      \"layer3\"\n\n#define GIMP_MAINIMAGE_LAYER4_NAME      \"layer4\"\n\n#define GIMP_MAINIMAGE_GROUP2_NAME      \"group2\"\n\n#define GIMP_MAINIMAGE_LAYER5_NAME      \"layer5\"\n\n#define GIMP_MAINIMAGE_VGUIDE1_POS      42\n#define GIMP_MAINIMAGE_VGUIDE2_POS      82\n#define GIMP_MAINIMAGE_HGUIDE1_POS      3\n#define GIMP_MAINIMAGE_HGUIDE2_POS      4\n\n#define GIMP_MAINIMAGE_SAMPLEPOINT1_X   10\n#define GIMP_MAINIMAGE_SAMPLEPOINT1_Y   12\n#define GIMP_MAINIMAGE_SAMPLEPOINT2_X   41\n#define GIMP_MAINIMAGE_SAMPLEPOINT2_Y   49\n\n#define GIMP_MAINIMAGE_RESOLUTIONX      400\n#define GIMP_MAINIMAGE_RESOLUTIONY      410\n\n#define GIMP_MAINIMAGE_PARASITE_NAME    \"test-parasite\"\n#define GIMP_MAINIMAGE_PARASITE_DATA    \"foo\"\n#define GIMP_MAINIMAGE_PARASITE_SIZE    4                /* 'f' 'o' 'o' '\\0' */\n\n#define GIMP_MAINIMAGE_COMMENT          \"Created with code from \"\\\n                                        \"app/tests/test-xcf.c in the GIMP \"\\\n                                        \"source tree, i.e. it was not created \"\\\n                                        \"manually and may thus look weird if \"\\\n                                        \"opened and inspected in GIMP.\"\n\n#define GIMP_MAINIMAGE_UNIT             GIMP_UNIT_PICA\n\n#define GIMP_MAINIMAGE_GRIDXSPACING     25.0\n#define GIMP_MAINIMAGE_GRIDYSPACING     27.0\n\n#define GIMP_MAINIMAGE_CHANNEL1_NAME    \"channel1\"\n#define GIMP_MAINIMAGE_CHANNEL1_WIDTH   GIMP_MAINIMAGE_WIDTH\n#define GIMP_MAINIMAGE_CHANNEL1_HEIGHT  GIMP_MAINIMAGE_HEIGHT\n#define GIMP_MAINIMAGE_CHANNEL1_COLOR   { 1.0, 0.0, 1.0, 1.0 }\n\n#define GIMP_MAINIMAGE_SELECTION_X      5\n#define GIMP_MAINIMAGE_SELECTION_Y      6\n#define GIMP_MAINIMAGE_SELECTION_W      7\n#define GIMP_MAINIMAGE_SELECTION_H      8\n\n#define GIMP_MAINIMAGE_VECTORS1_NAME    \"vectors1\"\n#define GIMP_MAINIMAGE_VECTORS1_COORDS  { { 11.0, 12.0, /* pad zeroes */ },\\\n                                          { 21.0, 22.0, /* pad zeroes */ },\\\n                                          { 31.0, 32.0, /* pad zeroes */ }, }\n\n#define GIMP_MAINIMAGE_VECTORS2_NAME    \"vectors2\"\n#define GIMP_MAINIMAGE_VECTORS2_COORDS  { { 911.0, 912.0, /* pad zeroes */ },\\\n                                          { 921.0, 922.0, /* pad zeroes */ },\\\n                                          { 931.0, 932.0, /* pad zeroes */ }, }\n\n#define ADD_TEST(function) \\\n  g_test_add_data_func (\"/gimp-xcf/\" #function, gimp, function);\n\n\nGimpImage        * gimp_test_load_image                        (Gimp            *gimp,\n                                                                GFile           *file);\nstatic void        gimp_write_and_read_file                    (Gimp            *gimp,\n                                                                gboolean         with_unusual_stuff,\n                                                                gboolean         compat_paths,\n                                                                gboolean         use_gimp_2_8_features);\nstatic GimpImage * gimp_create_mainimage                       (Gimp            *gimp,\n                                                                gboolean         with_unusual_stuff,\n                                                                gboolean         compat_paths,\n                                                                gboolean         use_gimp_2_8_features);\nstatic void        gimp_assert_mainimage                       (GimpImage       *image,\n                                                                gboolean         with_unusual_stuff,\n                                                                gboolean         compat_paths,\n                                                                gboolean         use_gimp_2_8_features);\n\n\n/**\n * write_and_read_gimp_2_6_format:\n * @data:\n *\n * Do a write and read test on a file that could as well be\n * constructed with GIMP 2.6.\n **/\nstatic void\nwrite_and_read_gimp_2_6_format (gconstpointer data)\n{\n  Gimp *gimp = GIMP (data);\n\n  gimp_write_and_read_file (gimp,\n                            FALSE /*with_unusual_stuff*/,\n                            FALSE /*compat_paths*/,\n                            FALSE /*use_gimp_2_8_features*/);\n}\n\n/**\n * write_and_read_gimp_2_6_format_unusual:\n * @data:\n *\n * Do a write and read test on a file that could as well be\n * constructed with GIMP 2.6, and make it unusual, like compatible\n * vectors and with a floating selection.\n **/\nstatic void\nwrite_and_read_gimp_2_6_format_unusual (gconstpointer data)\n{\n  Gimp *gimp = GIMP (data);\n\n  gimp_write_and_read_file (gimp,\n                            TRUE /*with_unusual_stuff*/,\n                            TRUE /*compat_paths*/,\n                            FALSE /*use_gimp_2_8_features*/);\n}\n\n/**\n * load_gimp_2_6_file:\n * @data:\n *\n * Loads a file created with GIMP 2.6 and makes sure it loaded as\n * expected.\n **/\nstatic void\nload_gimp_2_6_file (gconstpointer data)\n{\n  Gimp      *gimp = GIMP (data);\n  GimpImage *image;\n  gchar     *filename;\n  GFile     *file;\n\n  filename = g_build_filename (g_getenv (\"GIMP_TESTING_ABS_TOP_SRCDIR\"),\n                               \"app/tests/files/gimp-2-6-file.xcf\",\n                               NULL);\n  file = g_file_new_for_path (filename);\n  g_free (filename);\n\n  image = gimp_test_load_image (gimp, file);\n\n  /* The image file was constructed by running\n   * gimp_write_and_read_file (FALSE, FALSE) in GIMP 2.6 by\n   * copy-pasting the code to GIMP 2.6 and adapting it to changes in\n   * the core API, so we can use gimp_assert_mainimage() to make sure\n   * the file was loaded successfully.\n   */\n  gimp_assert_mainimage (image,\n                         FALSE /*with_unusual_stuff*/,\n                         FALSE /*compat_paths*/,\n                         FALSE /*use_gimp_2_8_features*/);\n}\n\n/**\n * write_and_read_gimp_2_8_format:\n * @data:\n *\n * Writes an XCF file that uses GIMP 2.8 features such as layer\n * groups, then reads the file and make sure no relevant information\n * was lost.\n **/\nstatic void\nwrite_and_read_gimp_2_8_format (gconstpointer data)\n{\n  Gimp *gimp = GIMP (data);\n\n  gimp_write_and_read_file (gimp,\n                            FALSE /*with_unusual_stuff*/,\n                            FALSE /*compat_paths*/,\n                            TRUE /*use_gimp_2_8_features*/);\n}\n\nGimpImage *\ngimp_test_load_image (Gimp  *gimp,\n                      GFile *file)\n{\n  GimpPlugInProcedure *proc;\n  GimpImage           *image;\n  GimpPDBStatusType    unused;\n\n  proc = gimp_plug_in_manager_file_procedure_find (gimp->plug_in_manager,\n                                                   GIMP_FILE_PROCEDURE_GROUP_OPEN,\n                                                   file,\n                                                   NULL /*error*/);\n  image = file_open_image (gimp,\n                           gimp_get_user_context (gimp),\n                           NULL /*progress*/,\n                           file,\n                           file,\n                           FALSE /*as_new*/,\n                           proc,\n                           GIMP_RUN_NONINTERACTIVE,\n                           &unused /*status*/,\n                           NULL /*mime_type*/,\n                           NULL /*error*/);\n\n  return image;\n}\n\n/**\n * gimp_write_and_read_file:\n *\n * Constructs the main test image and asserts its state, writes it to\n * a file, reads the image from the file, and asserts the state of the\n * loaded file. The function takes various parameters so the same\n * function can be used for different formats.\n **/\nstatic void\ngimp_write_and_read_file (Gimp     *gimp,\n                          gboolean  with_unusual_stuff,\n                          gboolean  compat_paths,\n                          gboolean  use_gimp_2_8_features)\n{\n  GimpImage           *image;\n  GimpImage           *loaded_image;\n  GimpPlugInProcedure *proc;\n  gchar               *filename;\n  GFile               *file;\n\n  /* Create the image */\n  image = gimp_create_mainimage (gimp,\n                                 with_unusual_stuff,\n                                 compat_paths,\n                                 use_gimp_2_8_features);\n\n  /* Assert valid state */\n  gimp_assert_mainimage (image,\n                         with_unusual_stuff,\n                         compat_paths,\n                         use_gimp_2_8_features);\n\n  /* Write to file */\n  filename = g_build_filename (g_get_tmp_dir (), \"gimp-test.xcf\", NULL);\n  file = g_file_new_for_path (filename);\n  g_free (filename);\n\n  proc = gimp_plug_in_manager_file_procedure_find (image->gimp->plug_in_manager,\n                                                   GIMP_FILE_PROCEDURE_GROUP_SAVE,\n                                                   file,\n                                                   NULL /*error*/);\n  file_save (gimp,\n             image,\n             NULL /*progress*/,\n             file,\n             proc,\n             GIMP_RUN_NONINTERACTIVE,\n             FALSE /*change_saved_state*/,\n             FALSE /*export_backward*/,\n             FALSE /*export_forward*/,\n             NULL /*error*/);\n\n  /* Load from file */\n  loaded_image = gimp_test_load_image (image->gimp, file);\n\n  /* Assert on the loaded file. If success, it means that there is no\n   * significant information loss when we wrote the image to a file\n   * and loaded it again\n   */\n  gimp_assert_mainimage (loaded_image,\n                         with_unusual_stuff,\n                         compat_paths,\n                         use_gimp_2_8_features);\n\n  g_file_delete (file, NULL, NULL);\n  g_object_unref (file);\n}\n\n/**\n * gimp_create_mainimage:\n *\n * Creates the main test image, i.e. the image that we use for most of\n * our XCF testing purposes.\n *\n * Returns: The #GimpImage\n **/\nstatic GimpImage *\ngimp_create_mainimage (Gimp     *gimp,\n                       gboolean  with_unusual_stuff,\n                       gboolean  compat_paths,\n                       gboolean  use_gimp_2_8_features)\n{\n  GimpImage     *image             = NULL;\n  GimpLayer     *layer             = NULL;\n  GimpParasite  *parasite          = NULL;\n  GimpGrid      *grid              = NULL;\n  GimpChannel   *channel           = NULL;\n  GimpRGB        channel_color     = GIMP_MAINIMAGE_CHANNEL1_COLOR;\n  GimpChannel   *selection         = NULL;\n  GimpVectors   *vectors           = NULL;\n  GimpCoords     vectors1_coords[] = GIMP_MAINIMAGE_VECTORS1_COORDS;\n  GimpCoords     vectors2_coords[] = GIMP_MAINIMAGE_VECTORS2_COORDS;\n  GimpStroke    *stroke            = NULL;\n  GimpLayerMask *layer_mask        = NULL;\n\n  /* Image size and type */\n  image = gimp_image_new (gimp,\n                          GIMP_MAINIMAGE_WIDTH,\n                          GIMP_MAINIMAGE_HEIGHT,\n                          GIMP_MAINIMAGE_TYPE,\n                          GIMP_MAINIMAGE_PRECISION);\n\n  /* Layers */\n  layer = gimp_layer_new (image,\n                          GIMP_MAINIMAGE_LAYER1_WIDTH,\n                          GIMP_MAINIMAGE_LAYER1_HEIGHT,\n                          GIMP_MAINIMAGE_LAYER1_FORMAT,\n                          GIMP_MAINIMAGE_LAYER1_NAME,\n                          GIMP_MAINIMAGE_LAYER1_OPACITY,\n                          GIMP_MAINIMAGE_LAYER1_MODE);\n  gimp_image_add_layer (image,\n                        layer,\n                        NULL,\n                        0,\n                        FALSE/*push_undo*/);\n  layer = gimp_layer_new (image,\n                          GIMP_MAINIMAGE_LAYER2_WIDTH,\n                          GIMP_MAINIMAGE_LAYER2_HEIGHT,\n                          GIMP_MAINIMAGE_LAYER2_FORMAT,\n                          GIMP_MAINIMAGE_LAYER2_NAME,\n                          GIMP_MAINIMAGE_LAYER2_OPACITY,\n                          GIMP_MAINIMAGE_LAYER2_MODE);\n  gimp_image_add_layer (image,\n                        layer,\n                        NULL,\n                        0,\n                        FALSE /*push_undo*/);\n\n  /* Layer mask */\n  layer_mask = gimp_layer_create_mask (layer,\n                                       GIMP_ADD_MASK_BLACK,\n                                       NULL /*channel*/);\n  gimp_layer_add_mask (layer,\n                       layer_mask,\n                       FALSE /*push_undo*/,\n                       NULL /*error*/);\n\n  /* Image compression type\n   *\n   * We don't do any explicit test, only implicit when we read tile\n   * data in other tests\n   */\n\n  /* Guides, note we add them in reversed order */\n  gimp_image_add_hguide (image,\n                         GIMP_MAINIMAGE_HGUIDE2_POS,\n                         FALSE /*push_undo*/);\n  gimp_image_add_hguide (image,\n                         GIMP_MAINIMAGE_HGUIDE1_POS,\n                         FALSE /*push_undo*/);\n  gimp_image_add_vguide (image,\n                         GIMP_MAINIMAGE_VGUIDE2_POS,\n                         FALSE /*push_undo*/);\n  gimp_image_add_vguide (image,\n                         GIMP_MAINIMAGE_VGUIDE1_POS,\n                         FALSE /*push_undo*/);\n\n\n  /* Sample points */\n  gimp_image_add_sample_point_at_pos (image,\n                                      GIMP_MAINIMAGE_SAMPLEPOINT1_X,\n                                      GIMP_MAINIMAGE_SAMPLEPOINT1_Y,\n                                      FALSE /*push_undo*/);\n  gimp_image_add_sample_point_at_pos (image,\n                                      GIMP_MAINIMAGE_SAMPLEPOINT2_X,\n                                      GIMP_MAINIMAGE_SAMPLEPOINT2_Y,\n                                      FALSE /*push_undo*/);\n\n  /* Tattoo\n   * We don't bother testing this, not yet at least\n   */\n\n  /* Resolution */\n  gimp_image_set_resolution (image,\n                             GIMP_MAINIMAGE_RESOLUTIONX,\n                             GIMP_MAINIMAGE_RESOLUTIONY);\n\n\n  /* Parasites */\n  parasite = gimp_parasite_new (GIMP_MAINIMAGE_PARASITE_NAME,\n                                GIMP_PARASITE_PERSISTENT,\n                                GIMP_MAINIMAGE_PARASITE_SIZE,\n                                GIMP_MAINIMAGE_PARASITE_DATA);\n  gimp_image_parasite_attach (image,\n                              parasite);\n  gimp_parasite_free (parasite);\n  parasite = gimp_parasite_new (\"gimp-comment\",\n                                GIMP_PARASITE_PERSISTENT,\n                                strlen (GIMP_MAINIMAGE_COMMENT) + 1,\n                                GIMP_MAINIMAGE_COMMENT);\n  gimp_image_parasite_attach (image, parasite);\n  gimp_parasite_free (parasite);\n\n\n  /* Unit */\n  gimp_image_set_unit (image,\n                       GIMP_MAINIMAGE_UNIT);\n\n  /* Grid */\n  grid = g_object_new (GIMP_TYPE_GRID,\n                       \"xspacing\", GIMP_MAINIMAGE_GRIDXSPACING,\n                       \"yspacing\", GIMP_MAINIMAGE_GRIDYSPACING,\n                       NULL);\n  gimp_image_set_grid (image,\n                       grid,\n                       FALSE /*push_undo*/);\n  g_object_unref (grid);\n\n  /* Channel */\n  channel = gimp_channel_new (image,\n                              GIMP_MAINIMAGE_CHANNEL1_WIDTH,\n                              GIMP_MAINIMAGE_CHANNEL1_HEIGHT,\n                              GIMP_MAINIMAGE_CHANNEL1_NAME,\n                              &channel_color);\n  gimp_image_add_channel (image,\n                          channel,\n                          NULL,\n                          -1,\n                          FALSE /*push_undo*/);\n\n  /* Selection */\n  selection = gimp_image_get_mask (image);\n  gimp_channel_select_rectangle (selection,\n                                 GIMP_MAINIMAGE_SELECTION_X,\n                                 GIMP_MAINIMAGE_SELECTION_Y,\n                                 GIMP_MAINIMAGE_SELECTION_W,\n                                 GIMP_MAINIMAGE_SELECTION_H,\n                                 GIMP_CHANNEL_OP_REPLACE,\n                                 FALSE /*feather*/,\n                                 0.0 /*feather_radius_x*/,\n                                 0.0 /*feather_radius_y*/,\n                                 FALSE /*push_undo*/);\n\n  /* Vectors 1 */\n  vectors = gimp_vectors_new (image,\n                              GIMP_MAINIMAGE_VECTORS1_NAME);\n  /* The XCF file can save vectors in two kind of ways, one old way\n   * and a new way. Parameterize the way so we can test both variants,\n   * i.e. gimp_vectors_compat_is_compatible() must return both TRUE\n   * and FALSE.\n   */\n  if (! compat_paths)\n    {\n      gimp_item_set_visible (GIMP_ITEM (vectors),\n                             TRUE,\n                             FALSE /*push_undo*/);\n    }\n  /* TODO: Add test for non-closed stroke. The order of the anchor\n   * points changes for open strokes, so it's boring to test\n   */\n  stroke = gimp_bezier_stroke_new_from_coords (vectors1_coords,\n                                               G_N_ELEMENTS (vectors1_coords),\n                                               TRUE /*closed*/);\n  gimp_vectors_stroke_add (vectors, stroke);\n  gimp_image_add_vectors (image,\n                          vectors,\n                          NULL /*parent*/,\n                          -1 /*position*/,\n                          FALSE /*push_undo*/);\n\n  /* Vectors 2 */\n  vectors = gimp_vectors_new (image,\n                              GIMP_MAINIMAGE_VECTORS2_NAME);\n\n  stroke = gimp_bezier_stroke_new_from_coords (vectors2_coords,\n                                               G_N_ELEMENTS (vectors2_coords),\n                                               TRUE /*closed*/);\n  gimp_vectors_stroke_add (vectors, stroke);\n  gimp_image_add_vectors (image,\n                          vectors,\n                          NULL /*parent*/,\n                          -1 /*position*/,\n                          FALSE /*push_undo*/);\n\n  /* Some of these things are pretty unusual, parameterize the\n   * inclusion of this in the written file so we can do our test both\n   * with and without\n   */\n  if (with_unusual_stuff)\n    {\n      /* Floating selection */\n      gimp_selection_float (GIMP_SELECTION (gimp_image_get_mask (image)),\n                            gimp_image_get_active_drawable (image),\n                            gimp_get_user_context (gimp),\n                            TRUE /*cut_image*/,\n                            0 /*off_x*/,\n                            0 /*off_y*/,\n                            NULL /*error*/);\n    }\n\n  /* Adds stuff like layer groups */\n  if (use_gimp_2_8_features)\n    {\n      GimpLayer *parent;\n\n      /* Add a layer group and some layers:\n       *\n       *  group1\n       *    layer3\n       *    layer4\n       *    group2\n       *      layer5\n       */\n\n      /* group1 */\n      layer = gimp_group_layer_new (image);\n      gimp_object_set_name (GIMP_OBJECT (layer), GIMP_MAINIMAGE_GROUP1_NAME);\n      gimp_image_add_layer (image,\n                            layer,\n                            NULL /*parent*/,\n                            -1 /*position*/,\n                            FALSE /*push_undo*/);\n      parent = layer;\n\n      /* layer3 */\n      layer = gimp_layer_new (image,\n                              GIMP_MAINIMAGE_LAYER1_WIDTH,\n                              GIMP_MAINIMAGE_LAYER1_HEIGHT,\n                              GIMP_MAINIMAGE_LAYER1_FORMAT,\n                              GIMP_MAINIMAGE_LAYER3_NAME,\n                              GIMP_MAINIMAGE_LAYER1_OPACITY,\n                              GIMP_MAINIMAGE_LAYER1_MODE);\n      gimp_image_add_layer (image,\n                            layer,\n                            parent,\n                            -1 /*position*/,\n                            FALSE /*push_undo*/);\n\n      /* layer4 */\n      layer = gimp_layer_new (image,\n                              GIMP_MAINIMAGE_LAYER1_WIDTH,\n                              GIMP_MAINIMAGE_LAYER1_HEIGHT,\n                              GIMP_MAINIMAGE_LAYER1_FORMAT,\n                              GIMP_MAINIMAGE_LAYER4_NAME,\n                              GIMP_MAINIMAGE_LAYER1_OPACITY,\n                              GIMP_MAINIMAGE_LAYER1_MODE);\n      gimp_image_add_layer (image,\n                            layer,\n                            parent,\n                            -1 /*position*/,\n                            FALSE /*push_undo*/);\n\n      /* group2 */\n      layer = gimp_group_layer_new (image);\n      gimp_object_set_name (GIMP_OBJECT (layer), GIMP_MAINIMAGE_GROUP2_NAME);\n      gimp_image_add_layer (image,\n                            layer,\n                            parent,\n                            -1 /*position*/,\n                            FALSE /*push_undo*/);\n      parent = layer;\n\n      /* layer5 */\n      layer = gimp_layer_new (image,\n                              GIMP_MAINIMAGE_LAYER1_WIDTH,\n                              GIMP_MAINIMAGE_LAYER1_HEIGHT,\n                              GIMP_MAINIMAGE_LAYER1_FORMAT,\n                              GIMP_MAINIMAGE_LAYER5_NAME,\n                              GIMP_MAINIMAGE_LAYER1_OPACITY,\n                              GIMP_MAINIMAGE_LAYER1_MODE);\n      gimp_image_add_layer (image,\n                            layer,\n                            parent,\n                            -1 /*position*/,\n                            FALSE /*push_undo*/);\n    }\n\n  /* Todo, should be tested somehow:\n   *\n   * - Color maps\n   * - Custom user units\n   * - Text layers\n   * - Layer parasites\n   * - Channel parasites\n   * - Different tile compression methods\n   */\n\n  return image;\n}\n\nstatic void\ngimp_assert_vectors (GimpImage   *image,\n                     const gchar *name,\n                     GimpCoords   coords[],\n                     gsize        coords_size,\n                     gboolean     visible)\n{\n  GimpVectors *vectors        = NULL;\n  GimpStroke  *stroke         = NULL;\n  GArray      *control_points = NULL;\n  gboolean     closed         = FALSE;\n  gint         i              = 0;\n\n  vectors = gimp_image_get_vectors_by_name (image, name);\n  stroke = gimp_vectors_stroke_get_next (vectors, NULL);\n  g_assert (stroke != NULL);\n  control_points = gimp_stroke_control_points_get (stroke,\n                                                   &closed);\n  g_assert (closed);\n  g_assert_cmpint (control_points->len,\n                   ==,\n                   coords_size);\n  for (i = 0; i < control_points->len; i++)\n    {\n      g_assert_cmpint (coords[i].x,\n                       ==,\n                       g_array_index (control_points,\n                                      GimpAnchor,\n                                      i).position.x);\n      g_assert_cmpint (coords[i].y,\n                       ==,\n                       g_array_index (control_points,\n                                      GimpAnchor,\n                                      i).position.y);\n    }\n\n  g_assert (gimp_item_get_visible (GIMP_ITEM (vectors)) ? TRUE : FALSE ==\n            visible ? TRUE : FALSE);\n}\n\n/**\n * gimp_assert_mainimage:\n * @image:\n *\n * Verifies that the passed #GimpImage contains all the information\n * that was put in it by gimp_create_mainimage().\n **/\nstatic void\ngimp_assert_mainimage (GimpImage *image,\n                       gboolean   with_unusual_stuff,\n                       gboolean   compat_paths,\n                       gboolean   use_gimp_2_8_features)\n{\n  const GimpParasite *parasite               = NULL;\n  GimpLayer          *layer                  = NULL;\n  GList              *iter                   = NULL;\n  GimpGuide          *guide                  = NULL;\n  GimpSamplePoint    *sample_point           = NULL;\n  gint                sample_point_x         = 0;\n  gint                sample_point_y         = 0;\n  gdouble             xres                   = 0.0;\n  gdouble             yres                   = 0.0;\n  GimpGrid           *grid                   = NULL;\n  gdouble             xspacing               = 0.0;\n  gdouble             yspacing               = 0.0;\n  GimpChannel        *channel                = NULL;\n  GimpRGB             expected_channel_color = GIMP_MAINIMAGE_CHANNEL1_COLOR;\n  GimpRGB             actual_channel_color   = { 0, };\n  GimpChannel        *selection              = NULL;\n  gint                x                      = -1;\n  gint                y                      = -1;\n  gint                w                      = -1;\n  gint                h                      = -1;\n  GimpCoords          vectors1_coords[]      = GIMP_MAINIMAGE_VECTORS1_COORDS;\n  GimpCoords          vectors2_coords[]      = GIMP_MAINIMAGE_VECTORS2_COORDS;\n\n  /* Image size and type */\n  g_assert_cmpint (gimp_image_get_width (image),\n                   ==,\n                   GIMP_MAINIMAGE_WIDTH);\n  g_assert_cmpint (gimp_image_get_height (image),\n                   ==,\n                   GIMP_MAINIMAGE_HEIGHT);\n  g_assert_cmpint (gimp_image_get_base_type (image),\n                   ==,\n                   GIMP_MAINIMAGE_TYPE);\n\n  /* Layers */\n  layer = gimp_image_get_layer_by_name (image,\n                                        GIMP_MAINIMAGE_LAYER1_NAME);\n  g_assert_cmpint (gimp_item_get_width (GIMP_ITEM (layer)),\n                   ==,\n                   GIMP_MAINIMAGE_LAYER1_WIDTH);\n  g_assert_cmpint (gimp_item_get_height (GIMP_ITEM (layer)),\n                   ==,\n                   GIMP_MAINIMAGE_LAYER1_HEIGHT);\n  g_assert_cmpstr (babl_get_name (gimp_drawable_get_format (GIMP_DRAWABLE (layer))),\n                   ==,\n                   babl_get_name (GIMP_MAINIMAGE_LAYER1_FORMAT));\n  g_assert_cmpstr (gimp_object_get_name (GIMP_DRAWABLE (layer)),\n                   ==,\n                   GIMP_MAINIMAGE_LAYER1_NAME);\n  g_assert_cmpfloat (gimp_layer_get_opacity (layer),\n                     ==,\n                     GIMP_MAINIMAGE_LAYER1_OPACITY);\n  g_assert_cmpint (gimp_layer_get_mode (layer),\n                   ==,\n                   GIMP_MAINIMAGE_LAYER1_MODE);\n  layer = gimp_image_get_layer_by_name (image,\n                                        GIMP_MAINIMAGE_LAYER2_NAME);\n  g_assert_cmpint (gimp_item_get_width (GIMP_ITEM (layer)),\n                   ==,\n                   GIMP_MAINIMAGE_LAYER2_WIDTH);\n  g_assert_cmpint (gimp_item_get_height (GIMP_ITEM (layer)),\n                   ==,\n                   GIMP_MAINIMAGE_LAYER2_HEIGHT);\n  g_assert_cmpstr (babl_get_name (gimp_drawable_get_format (GIMP_DRAWABLE (layer))),\n                   ==,\n                   babl_get_name (GIMP_MAINIMAGE_LAYER2_FORMAT));\n  g_assert_cmpstr (gimp_object_get_name (GIMP_DRAWABLE (layer)),\n                   ==,\n                   GIMP_MAINIMAGE_LAYER2_NAME);\n  g_assert_cmpfloat (gimp_layer_get_opacity (layer),\n                     ==,\n                     GIMP_MAINIMAGE_LAYER2_OPACITY);\n  g_assert_cmpint (gimp_layer_get_mode (layer),\n                   ==,\n                   GIMP_MAINIMAGE_LAYER2_MODE);\n\n  /* Guides, note that we rely on internal ordering */\n  iter = gimp_image_get_guides (image);\n  g_assert (iter != NULL);\n  guide = iter->data;\n  g_assert_cmpint (gimp_guide_get_position (guide),\n                   ==,\n                   GIMP_MAINIMAGE_VGUIDE1_POS);\n  iter = g_list_next (iter);\n  g_assert (iter != NULL);\n  guide = iter->data;\n  g_assert_cmpint (gimp_guide_get_position (guide),\n                   ==,\n                   GIMP_MAINIMAGE_VGUIDE2_POS);\n  iter = g_list_next (iter);\n  g_assert (iter != NULL);\n  guide = iter->data;\n  g_assert_cmpint (gimp_guide_get_position (guide),\n                   ==,\n                   GIMP_MAINIMAGE_HGUIDE1_POS);\n  iter = g_list_next (iter);\n  g_assert (iter != NULL);\n  guide = iter->data;\n  g_assert_cmpint (gimp_guide_get_position (guide),\n                   ==,\n                   GIMP_MAINIMAGE_HGUIDE2_POS);\n  iter = g_list_next (iter);\n  g_assert (iter == NULL);\n\n  /* Sample points, we rely on the same ordering as when we added\n   * them, although this ordering is not a necessity\n   */\n  iter = gimp_image_get_sample_points (image);\n  g_assert (iter != NULL);\n  sample_point = iter->data;\n  gimp_sample_point_get_position (sample_point,\n                                  &sample_point_x, &sample_point_y);\n  g_assert_cmpint (sample_point_x,\n                   ==,\n                   GIMP_MAINIMAGE_SAMPLEPOINT1_X);\n  g_assert_cmpint (sample_point_y,\n                   ==,\n                   GIMP_MAINIMAGE_SAMPLEPOINT1_Y);\n  iter = g_list_next (iter);\n  g_assert (iter != NULL);\n  sample_point = iter->data;\n  gimp_sample_point_get_position (sample_point,\n                                  &sample_point_x, &sample_point_y);\n  g_assert_cmpint (sample_point_x,\n                   ==,\n                   GIMP_MAINIMAGE_SAMPLEPOINT2_X);\n  g_assert_cmpint (sample_point_y,\n                   ==,\n                   GIMP_MAINIMAGE_SAMPLEPOINT2_Y);\n  iter = g_list_next (iter);\n  g_assert (iter == NULL);\n\n  /* Resolution */\n  gimp_image_get_resolution (image, &xres, &yres);\n  g_assert_cmpint (xres,\n                   ==,\n                   GIMP_MAINIMAGE_RESOLUTIONX);\n  g_assert_cmpint (yres,\n                   ==,\n                   GIMP_MAINIMAGE_RESOLUTIONY);\n\n  /* Parasites */\n  parasite = gimp_image_parasite_find (image,\n                                       GIMP_MAINIMAGE_PARASITE_NAME);\n  g_assert_cmpint (gimp_parasite_data_size (parasite),\n                   ==,\n                   GIMP_MAINIMAGE_PARASITE_SIZE);\n  g_assert_cmpstr (gimp_parasite_data (parasite),\n                   ==,\n                   GIMP_MAINIMAGE_PARASITE_DATA);\n  parasite = gimp_image_parasite_find (image,\n                                       \"gimp-comment\");\n  g_assert_cmpint (gimp_parasite_data_size (parasite),\n                   ==,\n                   strlen (GIMP_MAINIMAGE_COMMENT) + 1);\n  g_assert_cmpstr (gimp_parasite_data (parasite),\n                   ==,\n                   GIMP_MAINIMAGE_COMMENT);\n\n  /* Unit */\n  g_assert_cmpint (gimp_image_get_unit (image),\n                   ==,\n                   GIMP_MAINIMAGE_UNIT);\n\n  /* Grid */\n  grid = gimp_image_get_grid (image);\n  g_object_get (grid,\n                \"xspacing\", &xspacing,\n                \"yspacing\", &yspacing,\n                NULL);\n  g_assert_cmpint (xspacing,\n                   ==,\n                   GIMP_MAINIMAGE_GRIDXSPACING);\n  g_assert_cmpint (yspacing,\n                   ==,\n                   GIMP_MAINIMAGE_GRIDYSPACING);\n\n\n  /* Channel */\n  channel = gimp_image_get_channel_by_name (image,\n                                            GIMP_MAINIMAGE_CHANNEL1_NAME);\n  gimp_channel_get_color (channel, &actual_channel_color);\n  g_assert_cmpint (gimp_item_get_width (GIMP_ITEM (channel)),\n                   ==,\n                   GIMP_MAINIMAGE_CHANNEL1_WIDTH);\n  g_assert_cmpint (gimp_item_get_height (GIMP_ITEM (channel)),\n                   ==,\n                   GIMP_MAINIMAGE_CHANNEL1_HEIGHT);\n  g_assert (memcmp (&expected_channel_color,\n                    &actual_channel_color,\n                    sizeof (GimpRGB)) == 0);\n\n  /* Selection, if the image contains unusual stuff it contains a\n   * floating select, and when floating a selection, the selection\n   * mask is cleared, so don't test for the presence of the selection\n   * mask in that case\n   */\n  if (! with_unusual_stuff)\n    {\n      selection = gimp_image_get_mask (image);\n      gimp_item_bounds (GIMP_ITEM (selection), &x, &y, &w, &h);\n      g_assert_cmpint (x,\n                       ==,\n                       GIMP_MAINIMAGE_SELECTION_X);\n      g_assert_cmpint (y,\n                       ==,\n                       GIMP_MAINIMAGE_SELECTION_Y);\n      g_assert_cmpint (w,\n                       ==,\n                       GIMP_MAINIMAGE_SELECTION_W);\n      g_assert_cmpint (h,\n                       ==,\n                       GIMP_MAINIMAGE_SELECTION_H);\n    }\n\n  /* Vectors 1 */\n  gimp_assert_vectors (image,\n                       GIMP_MAINIMAGE_VECTORS1_NAME,\n                       vectors1_coords,\n                       G_N_ELEMENTS (vectors1_coords),\n                       ! compat_paths /*visible*/);\n\n  /* Vectors 2 (always visible FALSE) */\n  gimp_assert_vectors (image,\n                       GIMP_MAINIMAGE_VECTORS2_NAME,\n                       vectors2_coords,\n                       G_N_ELEMENTS (vectors2_coords),\n                       FALSE /*visible*/);\n\n  if (with_unusual_stuff)\n    g_assert (gimp_image_get_floating_selection (image) != NULL);\n  else /* if (! with_unusual_stuff) */\n    g_assert (gimp_image_get_floating_selection (image) == NULL);\n\n  if (use_gimp_2_8_features)\n    {\n      /* Only verify the parent relationships, the layer attributes\n       * are tested above\n       */\n      GimpItem *group1 = GIMP_ITEM (gimp_image_get_layer_by_name (image, GIMP_MAINIMAGE_GROUP1_NAME));\n      GimpItem *layer3 = GIMP_ITEM (gimp_image_get_layer_by_name (image, GIMP_MAINIMAGE_LAYER3_NAME));\n      GimpItem *layer4 = GIMP_ITEM (gimp_image_get_layer_by_name (image, GIMP_MAINIMAGE_LAYER4_NAME));\n      GimpItem *group2 = GIMP_ITEM (gimp_image_get_layer_by_name (image, GIMP_MAINIMAGE_GROUP2_NAME));\n      GimpItem *layer5 = GIMP_ITEM (gimp_image_get_layer_by_name (image, GIMP_MAINIMAGE_LAYER5_NAME));\n\n      g_assert (gimp_item_get_parent (group1) == NULL);\n      g_assert (gimp_item_get_parent (layer3) == group1);\n      g_assert (gimp_item_get_parent (layer4) == group1);\n      g_assert (gimp_item_get_parent (group2) == group1);\n      g_assert (gimp_item_get_parent (layer5) == group2);\n    }\n}\n\n\n/**\n * main:\n * @argc:\n * @argv:\n *\n * These tests intend to\n *\n *  - Make sure that we are backwards compatible with files created by\n *    older version of GIMP, i.e. that we can load files from earlier\n *    version of GIMP\n *\n *  - Make sure that the information put into a #GimpImage is not lost\n *    when the #GimpImage is written to a file and then read again\n **/\nint\nmain (int    argc,\n      char **argv)\n{\n  Gimp *gimp;\n  int   result;\n\n  g_test_init (&argc, &argv, NULL);\n\n  gimp_test_utils_set_gimp3_directory (\"GIMP_TESTING_ABS_TOP_SRCDIR\",\n                                       \"app/tests/gimpdir\");\n\n  /* We share the same application instance across all tests. We need\n   * the GUI variant for the file procs\n   */\n  gimp = gimp_init_for_testing ();\n\n  /* Add tests */\n  ADD_TEST (write_and_read_gimp_2_6_format);\n  ADD_TEST (write_and_read_gimp_2_6_format_unusual);\n  ADD_TEST (load_gimp_2_6_file);\n  ADD_TEST (write_and_read_gimp_2_8_format);\n\n  /* Don't write files to the source dir */\n  gimp_test_utils_set_gimp3_directory (\"GIMP_TESTING_ABS_TOP_BUILDDIR\",\n                                       \"app/tests/gimpdir-output\");\n\n  /* Run the tests */\n  result = g_test_run ();\n\n  /* Exit so we don't break script-fu plug-in wire */\n  gimp_exit (gimp, TRUE);\n\n  return result;\n}\n"], "fixing_code": ["/* GIMP - The GNU Image Manipulation Program\n * Copyright (C) 2009 Martin Nordholts\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"config.h\"\n\n#include <string.h>\n\n#include <gegl.h>\n#include <gtk/gtk.h>\n\n#include \"libgimpbase/gimpbase.h\"\n\n#include \"widgets/widgets-types.h\"\n\n#include \"widgets/gimpuimanager.h\"\n\n#include \"core/gimp.h\"\n#include \"core/gimpchannel.h\"\n#include \"core/gimpchannel-select.h\"\n#include \"core/gimpdrawable.h\"\n#include \"core/gimpgrid.h\"\n#include \"core/gimpgrouplayer.h\"\n#include \"core/gimpguide.h\"\n#include \"core/gimpimage.h\"\n#include \"core/gimpimage-grid.h\"\n#include \"core/gimpimage-guides.h\"\n#include \"core/gimpimage-sample-points.h\"\n#include \"core/gimplayer.h\"\n#include \"core/gimplayer-new.h\"\n#include \"core/gimpsamplepoint.h\"\n#include \"core/gimpselection.h\"\n\n#include \"vectors/gimpanchor.h\"\n#include \"vectors/gimpbezierstroke.h\"\n#include \"vectors/gimpvectors.h\"\n\n#include \"plug-in/gimppluginmanager-file.h\"\n\n#include \"file/file-open.h\"\n#include \"file/file-save.h\"\n\n#include \"tests.h\"\n\n#include \"gimp-app-test-utils.h\"\n\n\n/* we continue to use LEGACY layers for testing, so we can use the\n * same test image for all tests, including loading\n * files/gimp-2-6-file.xcf which can't have any non-LEGACY modes\n */\n\n#define GIMP_MAINIMAGE_WIDTH            100\n#define GIMP_MAINIMAGE_HEIGHT           90\n#define GIMP_MAINIMAGE_TYPE             GIMP_RGB\n#define GIMP_MAINIMAGE_PRECISION        GIMP_PRECISION_U8_GAMMA\n\n#define GIMP_MAINIMAGE_LAYER1_NAME      \"layer1\"\n#define GIMP_MAINIMAGE_LAYER1_WIDTH     50\n#define GIMP_MAINIMAGE_LAYER1_HEIGHT    51\n#define GIMP_MAINIMAGE_LAYER1_FORMAT    babl_format (\"R'G'B'A u8\")\n#define GIMP_MAINIMAGE_LAYER1_OPACITY   GIMP_OPACITY_OPAQUE\n#define GIMP_MAINIMAGE_LAYER1_MODE      GIMP_LAYER_MODE_NORMAL_LEGACY\n\n#define GIMP_MAINIMAGE_LAYER2_NAME      \"layer2\"\n#define GIMP_MAINIMAGE_LAYER2_WIDTH     25\n#define GIMP_MAINIMAGE_LAYER2_HEIGHT    251\n#define GIMP_MAINIMAGE_LAYER2_FORMAT    babl_format (\"R'G'B' u8\")\n#define GIMP_MAINIMAGE_LAYER2_OPACITY   GIMP_OPACITY_TRANSPARENT\n#define GIMP_MAINIMAGE_LAYER2_MODE      GIMP_LAYER_MODE_MULTIPLY_LEGACY\n\n#define GIMP_MAINIMAGE_GROUP1_NAME      \"group1\"\n\n#define GIMP_MAINIMAGE_LAYER3_NAME      \"layer3\"\n\n#define GIMP_MAINIMAGE_LAYER4_NAME      \"layer4\"\n\n#define GIMP_MAINIMAGE_GROUP2_NAME      \"group2\"\n\n#define GIMP_MAINIMAGE_LAYER5_NAME      \"layer5\"\n\n#define GIMP_MAINIMAGE_VGUIDE1_POS      42\n#define GIMP_MAINIMAGE_VGUIDE2_POS      82\n#define GIMP_MAINIMAGE_HGUIDE1_POS      3\n#define GIMP_MAINIMAGE_HGUIDE2_POS      4\n\n#define GIMP_MAINIMAGE_SAMPLEPOINT1_X   10\n#define GIMP_MAINIMAGE_SAMPLEPOINT1_Y   12\n#define GIMP_MAINIMAGE_SAMPLEPOINT2_X   41\n#define GIMP_MAINIMAGE_SAMPLEPOINT2_Y   49\n\n#define GIMP_MAINIMAGE_RESOLUTIONX      400\n#define GIMP_MAINIMAGE_RESOLUTIONY      410\n\n#define GIMP_MAINIMAGE_PARASITE_NAME    \"test-parasite\"\n#define GIMP_MAINIMAGE_PARASITE_DATA    \"foo\"\n#define GIMP_MAINIMAGE_PARASITE_SIZE    4                /* 'f' 'o' 'o' '\\0' */\n\n#define GIMP_MAINIMAGE_COMMENT          \"Created with code from \"\\\n                                        \"app/tests/test-xcf.c in the GIMP \"\\\n                                        \"source tree, i.e. it was not created \"\\\n                                        \"manually and may thus look weird if \"\\\n                                        \"opened and inspected in GIMP.\"\n\n#define GIMP_MAINIMAGE_UNIT             GIMP_UNIT_PICA\n\n#define GIMP_MAINIMAGE_GRIDXSPACING     25.0\n#define GIMP_MAINIMAGE_GRIDYSPACING     27.0\n\n#define GIMP_MAINIMAGE_CHANNEL1_NAME    \"channel1\"\n#define GIMP_MAINIMAGE_CHANNEL1_WIDTH   GIMP_MAINIMAGE_WIDTH\n#define GIMP_MAINIMAGE_CHANNEL1_HEIGHT  GIMP_MAINIMAGE_HEIGHT\n#define GIMP_MAINIMAGE_CHANNEL1_COLOR   { 1.0, 0.0, 1.0, 1.0 }\n\n#define GIMP_MAINIMAGE_SELECTION_X      5\n#define GIMP_MAINIMAGE_SELECTION_Y      6\n#define GIMP_MAINIMAGE_SELECTION_W      7\n#define GIMP_MAINIMAGE_SELECTION_H      8\n\n#define GIMP_MAINIMAGE_VECTORS1_NAME    \"vectors1\"\n#define GIMP_MAINIMAGE_VECTORS1_COORDS  { { 11.0, 12.0, /* pad zeroes */ },\\\n                                          { 21.0, 22.0, /* pad zeroes */ },\\\n                                          { 31.0, 32.0, /* pad zeroes */ }, }\n\n#define GIMP_MAINIMAGE_VECTORS2_NAME    \"vectors2\"\n#define GIMP_MAINIMAGE_VECTORS2_COORDS  { { 911.0, 912.0, /* pad zeroes */ },\\\n                                          { 921.0, 922.0, /* pad zeroes */ },\\\n                                          { 931.0, 932.0, /* pad zeroes */ }, }\n\n#define ADD_TEST(function) \\\n  g_test_add_data_func (\"/gimp-xcf/\" #function, gimp, function);\n\n\nGimpImage        * gimp_test_load_image                        (Gimp            *gimp,\n                                                                GFile           *file);\nstatic void        gimp_write_and_read_file                    (Gimp            *gimp,\n                                                                gboolean         with_unusual_stuff,\n                                                                gboolean         compat_paths,\n                                                                gboolean         use_gimp_2_8_features);\nstatic GimpImage * gimp_create_mainimage                       (Gimp            *gimp,\n                                                                gboolean         with_unusual_stuff,\n                                                                gboolean         compat_paths,\n                                                                gboolean         use_gimp_2_8_features);\nstatic void        gimp_assert_mainimage                       (GimpImage       *image,\n                                                                gboolean         with_unusual_stuff,\n                                                                gboolean         compat_paths,\n                                                                gboolean         use_gimp_2_8_features);\n\n\n/**\n * write_and_read_gimp_2_6_format:\n * @data:\n *\n * Do a write and read test on a file that could as well be\n * constructed with GIMP 2.6.\n **/\nstatic void\nwrite_and_read_gimp_2_6_format (gconstpointer data)\n{\n  Gimp *gimp = GIMP (data);\n\n  gimp_write_and_read_file (gimp,\n                            FALSE /*with_unusual_stuff*/,\n                            FALSE /*compat_paths*/,\n                            FALSE /*use_gimp_2_8_features*/);\n}\n\n/**\n * write_and_read_gimp_2_6_format_unusual:\n * @data:\n *\n * Do a write and read test on a file that could as well be\n * constructed with GIMP 2.6, and make it unusual, like compatible\n * vectors and with a floating selection.\n **/\nstatic void\nwrite_and_read_gimp_2_6_format_unusual (gconstpointer data)\n{\n  Gimp *gimp = GIMP (data);\n\n  gimp_write_and_read_file (gimp,\n                            TRUE /*with_unusual_stuff*/,\n                            TRUE /*compat_paths*/,\n                            FALSE /*use_gimp_2_8_features*/);\n}\n\n/**\n * load_gimp_2_6_file:\n * @data:\n *\n * Loads a file created with GIMP 2.6 and makes sure it loaded as\n * expected.\n **/\nstatic void\nload_gimp_2_6_file (gconstpointer data)\n{\n  Gimp      *gimp = GIMP (data);\n  GimpImage *image;\n  gchar     *filename;\n  GFile     *file;\n\n  filename = g_build_filename (g_getenv (\"GIMP_TESTING_ABS_TOP_SRCDIR\"),\n                               \"app/tests/files/gimp-2-6-file.xcf\",\n                               NULL);\n  file = g_file_new_for_path (filename);\n  g_free (filename);\n\n  image = gimp_test_load_image (gimp, file);\n\n  /* The image file was constructed by running\n   * gimp_write_and_read_file (FALSE, FALSE) in GIMP 2.6 by\n   * copy-pasting the code to GIMP 2.6 and adapting it to changes in\n   * the core API, so we can use gimp_assert_mainimage() to make sure\n   * the file was loaded successfully.\n   */\n  gimp_assert_mainimage (image,\n                         FALSE /*with_unusual_stuff*/,\n                         FALSE /*compat_paths*/,\n                         FALSE /*use_gimp_2_8_features*/);\n}\n\n/**\n * write_and_read_gimp_2_8_format:\n * @data:\n *\n * Writes an XCF file that uses GIMP 2.8 features such as layer\n * groups, then reads the file and make sure no relevant information\n * was lost.\n **/\nstatic void\nwrite_and_read_gimp_2_8_format (gconstpointer data)\n{\n  Gimp *gimp = GIMP (data);\n\n  gimp_write_and_read_file (gimp,\n                            FALSE /*with_unusual_stuff*/,\n                            FALSE /*compat_paths*/,\n                            TRUE /*use_gimp_2_8_features*/);\n}\n\nGimpImage *\ngimp_test_load_image (Gimp  *gimp,\n                      GFile *file)\n{\n  GimpPlugInProcedure *proc;\n  GimpImage           *image;\n  GimpPDBStatusType    unused;\n\n  proc = gimp_plug_in_manager_file_procedure_find (gimp->plug_in_manager,\n                                                   GIMP_FILE_PROCEDURE_GROUP_OPEN,\n                                                   file,\n                                                   NULL /*error*/);\n  image = file_open_image (gimp,\n                           gimp_get_user_context (gimp),\n                           NULL /*progress*/,\n                           file,\n                           file,\n                           FALSE /*as_new*/,\n                           proc,\n                           GIMP_RUN_NONINTERACTIVE,\n                           &unused /*status*/,\n                           NULL /*mime_type*/,\n                           NULL /*error*/);\n\n  return image;\n}\n\n/**\n * gimp_write_and_read_file:\n *\n * Constructs the main test image and asserts its state, writes it to\n * a file, reads the image from the file, and asserts the state of the\n * loaded file. The function takes various parameters so the same\n * function can be used for different formats.\n **/\nstatic void\ngimp_write_and_read_file (Gimp     *gimp,\n                          gboolean  with_unusual_stuff,\n                          gboolean  compat_paths,\n                          gboolean  use_gimp_2_8_features)\n{\n  GimpImage           *image;\n  GimpImage           *loaded_image;\n  GimpPlugInProcedure *proc;\n  gchar               *filename = NULL;\n  gint                 file_handle;\n  GFile               *file;\n\n  /* Create the image */\n  image = gimp_create_mainimage (gimp,\n                                 with_unusual_stuff,\n                                 compat_paths,\n                                 use_gimp_2_8_features);\n\n  /* Assert valid state */\n  gimp_assert_mainimage (image,\n                         with_unusual_stuff,\n                         compat_paths,\n                         use_gimp_2_8_features);\n\n  /* Write to file */\n  file_handle = g_file_open_tmp (\"gimp-test-XXXXXX.xcf\", &filename, NULL);\n  g_assert (file_handle != -1);\n  close (file_handle);\n  file = g_file_new_for_path (filename);\n  g_free (filename);\n\n  proc = gimp_plug_in_manager_file_procedure_find (image->gimp->plug_in_manager,\n                                                   GIMP_FILE_PROCEDURE_GROUP_SAVE,\n                                                   file,\n                                                   NULL /*error*/);\n  file_save (gimp,\n             image,\n             NULL /*progress*/,\n             file,\n             proc,\n             GIMP_RUN_NONINTERACTIVE,\n             FALSE /*change_saved_state*/,\n             FALSE /*export_backward*/,\n             FALSE /*export_forward*/,\n             NULL /*error*/);\n\n  /* Load from file */\n  loaded_image = gimp_test_load_image (image->gimp, file);\n\n  /* Assert on the loaded file. If success, it means that there is no\n   * significant information loss when we wrote the image to a file\n   * and loaded it again\n   */\n  gimp_assert_mainimage (loaded_image,\n                         with_unusual_stuff,\n                         compat_paths,\n                         use_gimp_2_8_features);\n\n  g_file_delete (file, NULL, NULL);\n  g_object_unref (file);\n}\n\n/**\n * gimp_create_mainimage:\n *\n * Creates the main test image, i.e. the image that we use for most of\n * our XCF testing purposes.\n *\n * Returns: The #GimpImage\n **/\nstatic GimpImage *\ngimp_create_mainimage (Gimp     *gimp,\n                       gboolean  with_unusual_stuff,\n                       gboolean  compat_paths,\n                       gboolean  use_gimp_2_8_features)\n{\n  GimpImage     *image             = NULL;\n  GimpLayer     *layer             = NULL;\n  GimpParasite  *parasite          = NULL;\n  GimpGrid      *grid              = NULL;\n  GimpChannel   *channel           = NULL;\n  GimpRGB        channel_color     = GIMP_MAINIMAGE_CHANNEL1_COLOR;\n  GimpChannel   *selection         = NULL;\n  GimpVectors   *vectors           = NULL;\n  GimpCoords     vectors1_coords[] = GIMP_MAINIMAGE_VECTORS1_COORDS;\n  GimpCoords     vectors2_coords[] = GIMP_MAINIMAGE_VECTORS2_COORDS;\n  GimpStroke    *stroke            = NULL;\n  GimpLayerMask *layer_mask        = NULL;\n\n  /* Image size and type */\n  image = gimp_image_new (gimp,\n                          GIMP_MAINIMAGE_WIDTH,\n                          GIMP_MAINIMAGE_HEIGHT,\n                          GIMP_MAINIMAGE_TYPE,\n                          GIMP_MAINIMAGE_PRECISION);\n\n  /* Layers */\n  layer = gimp_layer_new (image,\n                          GIMP_MAINIMAGE_LAYER1_WIDTH,\n                          GIMP_MAINIMAGE_LAYER1_HEIGHT,\n                          GIMP_MAINIMAGE_LAYER1_FORMAT,\n                          GIMP_MAINIMAGE_LAYER1_NAME,\n                          GIMP_MAINIMAGE_LAYER1_OPACITY,\n                          GIMP_MAINIMAGE_LAYER1_MODE);\n  gimp_image_add_layer (image,\n                        layer,\n                        NULL,\n                        0,\n                        FALSE/*push_undo*/);\n  layer = gimp_layer_new (image,\n                          GIMP_MAINIMAGE_LAYER2_WIDTH,\n                          GIMP_MAINIMAGE_LAYER2_HEIGHT,\n                          GIMP_MAINIMAGE_LAYER2_FORMAT,\n                          GIMP_MAINIMAGE_LAYER2_NAME,\n                          GIMP_MAINIMAGE_LAYER2_OPACITY,\n                          GIMP_MAINIMAGE_LAYER2_MODE);\n  gimp_image_add_layer (image,\n                        layer,\n                        NULL,\n                        0,\n                        FALSE /*push_undo*/);\n\n  /* Layer mask */\n  layer_mask = gimp_layer_create_mask (layer,\n                                       GIMP_ADD_MASK_BLACK,\n                                       NULL /*channel*/);\n  gimp_layer_add_mask (layer,\n                       layer_mask,\n                       FALSE /*push_undo*/,\n                       NULL /*error*/);\n\n  /* Image compression type\n   *\n   * We don't do any explicit test, only implicit when we read tile\n   * data in other tests\n   */\n\n  /* Guides, note we add them in reversed order */\n  gimp_image_add_hguide (image,\n                         GIMP_MAINIMAGE_HGUIDE2_POS,\n                         FALSE /*push_undo*/);\n  gimp_image_add_hguide (image,\n                         GIMP_MAINIMAGE_HGUIDE1_POS,\n                         FALSE /*push_undo*/);\n  gimp_image_add_vguide (image,\n                         GIMP_MAINIMAGE_VGUIDE2_POS,\n                         FALSE /*push_undo*/);\n  gimp_image_add_vguide (image,\n                         GIMP_MAINIMAGE_VGUIDE1_POS,\n                         FALSE /*push_undo*/);\n\n\n  /* Sample points */\n  gimp_image_add_sample_point_at_pos (image,\n                                      GIMP_MAINIMAGE_SAMPLEPOINT1_X,\n                                      GIMP_MAINIMAGE_SAMPLEPOINT1_Y,\n                                      FALSE /*push_undo*/);\n  gimp_image_add_sample_point_at_pos (image,\n                                      GIMP_MAINIMAGE_SAMPLEPOINT2_X,\n                                      GIMP_MAINIMAGE_SAMPLEPOINT2_Y,\n                                      FALSE /*push_undo*/);\n\n  /* Tattoo\n   * We don't bother testing this, not yet at least\n   */\n\n  /* Resolution */\n  gimp_image_set_resolution (image,\n                             GIMP_MAINIMAGE_RESOLUTIONX,\n                             GIMP_MAINIMAGE_RESOLUTIONY);\n\n\n  /* Parasites */\n  parasite = gimp_parasite_new (GIMP_MAINIMAGE_PARASITE_NAME,\n                                GIMP_PARASITE_PERSISTENT,\n                                GIMP_MAINIMAGE_PARASITE_SIZE,\n                                GIMP_MAINIMAGE_PARASITE_DATA);\n  gimp_image_parasite_attach (image,\n                              parasite);\n  gimp_parasite_free (parasite);\n  parasite = gimp_parasite_new (\"gimp-comment\",\n                                GIMP_PARASITE_PERSISTENT,\n                                strlen (GIMP_MAINIMAGE_COMMENT) + 1,\n                                GIMP_MAINIMAGE_COMMENT);\n  gimp_image_parasite_attach (image, parasite);\n  gimp_parasite_free (parasite);\n\n\n  /* Unit */\n  gimp_image_set_unit (image,\n                       GIMP_MAINIMAGE_UNIT);\n\n  /* Grid */\n  grid = g_object_new (GIMP_TYPE_GRID,\n                       \"xspacing\", GIMP_MAINIMAGE_GRIDXSPACING,\n                       \"yspacing\", GIMP_MAINIMAGE_GRIDYSPACING,\n                       NULL);\n  gimp_image_set_grid (image,\n                       grid,\n                       FALSE /*push_undo*/);\n  g_object_unref (grid);\n\n  /* Channel */\n  channel = gimp_channel_new (image,\n                              GIMP_MAINIMAGE_CHANNEL1_WIDTH,\n                              GIMP_MAINIMAGE_CHANNEL1_HEIGHT,\n                              GIMP_MAINIMAGE_CHANNEL1_NAME,\n                              &channel_color);\n  gimp_image_add_channel (image,\n                          channel,\n                          NULL,\n                          -1,\n                          FALSE /*push_undo*/);\n\n  /* Selection */\n  selection = gimp_image_get_mask (image);\n  gimp_channel_select_rectangle (selection,\n                                 GIMP_MAINIMAGE_SELECTION_X,\n                                 GIMP_MAINIMAGE_SELECTION_Y,\n                                 GIMP_MAINIMAGE_SELECTION_W,\n                                 GIMP_MAINIMAGE_SELECTION_H,\n                                 GIMP_CHANNEL_OP_REPLACE,\n                                 FALSE /*feather*/,\n                                 0.0 /*feather_radius_x*/,\n                                 0.0 /*feather_radius_y*/,\n                                 FALSE /*push_undo*/);\n\n  /* Vectors 1 */\n  vectors = gimp_vectors_new (image,\n                              GIMP_MAINIMAGE_VECTORS1_NAME);\n  /* The XCF file can save vectors in two kind of ways, one old way\n   * and a new way. Parameterize the way so we can test both variants,\n   * i.e. gimp_vectors_compat_is_compatible() must return both TRUE\n   * and FALSE.\n   */\n  if (! compat_paths)\n    {\n      gimp_item_set_visible (GIMP_ITEM (vectors),\n                             TRUE,\n                             FALSE /*push_undo*/);\n    }\n  /* TODO: Add test for non-closed stroke. The order of the anchor\n   * points changes for open strokes, so it's boring to test\n   */\n  stroke = gimp_bezier_stroke_new_from_coords (vectors1_coords,\n                                               G_N_ELEMENTS (vectors1_coords),\n                                               TRUE /*closed*/);\n  gimp_vectors_stroke_add (vectors, stroke);\n  gimp_image_add_vectors (image,\n                          vectors,\n                          NULL /*parent*/,\n                          -1 /*position*/,\n                          FALSE /*push_undo*/);\n\n  /* Vectors 2 */\n  vectors = gimp_vectors_new (image,\n                              GIMP_MAINIMAGE_VECTORS2_NAME);\n\n  stroke = gimp_bezier_stroke_new_from_coords (vectors2_coords,\n                                               G_N_ELEMENTS (vectors2_coords),\n                                               TRUE /*closed*/);\n  gimp_vectors_stroke_add (vectors, stroke);\n  gimp_image_add_vectors (image,\n                          vectors,\n                          NULL /*parent*/,\n                          -1 /*position*/,\n                          FALSE /*push_undo*/);\n\n  /* Some of these things are pretty unusual, parameterize the\n   * inclusion of this in the written file so we can do our test both\n   * with and without\n   */\n  if (with_unusual_stuff)\n    {\n      /* Floating selection */\n      gimp_selection_float (GIMP_SELECTION (gimp_image_get_mask (image)),\n                            gimp_image_get_active_drawable (image),\n                            gimp_get_user_context (gimp),\n                            TRUE /*cut_image*/,\n                            0 /*off_x*/,\n                            0 /*off_y*/,\n                            NULL /*error*/);\n    }\n\n  /* Adds stuff like layer groups */\n  if (use_gimp_2_8_features)\n    {\n      GimpLayer *parent;\n\n      /* Add a layer group and some layers:\n       *\n       *  group1\n       *    layer3\n       *    layer4\n       *    group2\n       *      layer5\n       */\n\n      /* group1 */\n      layer = gimp_group_layer_new (image);\n      gimp_object_set_name (GIMP_OBJECT (layer), GIMP_MAINIMAGE_GROUP1_NAME);\n      gimp_image_add_layer (image,\n                            layer,\n                            NULL /*parent*/,\n                            -1 /*position*/,\n                            FALSE /*push_undo*/);\n      parent = layer;\n\n      /* layer3 */\n      layer = gimp_layer_new (image,\n                              GIMP_MAINIMAGE_LAYER1_WIDTH,\n                              GIMP_MAINIMAGE_LAYER1_HEIGHT,\n                              GIMP_MAINIMAGE_LAYER1_FORMAT,\n                              GIMP_MAINIMAGE_LAYER3_NAME,\n                              GIMP_MAINIMAGE_LAYER1_OPACITY,\n                              GIMP_MAINIMAGE_LAYER1_MODE);\n      gimp_image_add_layer (image,\n                            layer,\n                            parent,\n                            -1 /*position*/,\n                            FALSE /*push_undo*/);\n\n      /* layer4 */\n      layer = gimp_layer_new (image,\n                              GIMP_MAINIMAGE_LAYER1_WIDTH,\n                              GIMP_MAINIMAGE_LAYER1_HEIGHT,\n                              GIMP_MAINIMAGE_LAYER1_FORMAT,\n                              GIMP_MAINIMAGE_LAYER4_NAME,\n                              GIMP_MAINIMAGE_LAYER1_OPACITY,\n                              GIMP_MAINIMAGE_LAYER1_MODE);\n      gimp_image_add_layer (image,\n                            layer,\n                            parent,\n                            -1 /*position*/,\n                            FALSE /*push_undo*/);\n\n      /* group2 */\n      layer = gimp_group_layer_new (image);\n      gimp_object_set_name (GIMP_OBJECT (layer), GIMP_MAINIMAGE_GROUP2_NAME);\n      gimp_image_add_layer (image,\n                            layer,\n                            parent,\n                            -1 /*position*/,\n                            FALSE /*push_undo*/);\n      parent = layer;\n\n      /* layer5 */\n      layer = gimp_layer_new (image,\n                              GIMP_MAINIMAGE_LAYER1_WIDTH,\n                              GIMP_MAINIMAGE_LAYER1_HEIGHT,\n                              GIMP_MAINIMAGE_LAYER1_FORMAT,\n                              GIMP_MAINIMAGE_LAYER5_NAME,\n                              GIMP_MAINIMAGE_LAYER1_OPACITY,\n                              GIMP_MAINIMAGE_LAYER1_MODE);\n      gimp_image_add_layer (image,\n                            layer,\n                            parent,\n                            -1 /*position*/,\n                            FALSE /*push_undo*/);\n    }\n\n  /* Todo, should be tested somehow:\n   *\n   * - Color maps\n   * - Custom user units\n   * - Text layers\n   * - Layer parasites\n   * - Channel parasites\n   * - Different tile compression methods\n   */\n\n  return image;\n}\n\nstatic void\ngimp_assert_vectors (GimpImage   *image,\n                     const gchar *name,\n                     GimpCoords   coords[],\n                     gsize        coords_size,\n                     gboolean     visible)\n{\n  GimpVectors *vectors        = NULL;\n  GimpStroke  *stroke         = NULL;\n  GArray      *control_points = NULL;\n  gboolean     closed         = FALSE;\n  gint         i              = 0;\n\n  vectors = gimp_image_get_vectors_by_name (image, name);\n  stroke = gimp_vectors_stroke_get_next (vectors, NULL);\n  g_assert (stroke != NULL);\n  control_points = gimp_stroke_control_points_get (stroke,\n                                                   &closed);\n  g_assert (closed);\n  g_assert_cmpint (control_points->len,\n                   ==,\n                   coords_size);\n  for (i = 0; i < control_points->len; i++)\n    {\n      g_assert_cmpint (coords[i].x,\n                       ==,\n                       g_array_index (control_points,\n                                      GimpAnchor,\n                                      i).position.x);\n      g_assert_cmpint (coords[i].y,\n                       ==,\n                       g_array_index (control_points,\n                                      GimpAnchor,\n                                      i).position.y);\n    }\n\n  g_assert (gimp_item_get_visible (GIMP_ITEM (vectors)) ? TRUE : FALSE ==\n            visible ? TRUE : FALSE);\n}\n\n/**\n * gimp_assert_mainimage:\n * @image:\n *\n * Verifies that the passed #GimpImage contains all the information\n * that was put in it by gimp_create_mainimage().\n **/\nstatic void\ngimp_assert_mainimage (GimpImage *image,\n                       gboolean   with_unusual_stuff,\n                       gboolean   compat_paths,\n                       gboolean   use_gimp_2_8_features)\n{\n  const GimpParasite *parasite               = NULL;\n  GimpLayer          *layer                  = NULL;\n  GList              *iter                   = NULL;\n  GimpGuide          *guide                  = NULL;\n  GimpSamplePoint    *sample_point           = NULL;\n  gint                sample_point_x         = 0;\n  gint                sample_point_y         = 0;\n  gdouble             xres                   = 0.0;\n  gdouble             yres                   = 0.0;\n  GimpGrid           *grid                   = NULL;\n  gdouble             xspacing               = 0.0;\n  gdouble             yspacing               = 0.0;\n  GimpChannel        *channel                = NULL;\n  GimpRGB             expected_channel_color = GIMP_MAINIMAGE_CHANNEL1_COLOR;\n  GimpRGB             actual_channel_color   = { 0, };\n  GimpChannel        *selection              = NULL;\n  gint                x                      = -1;\n  gint                y                      = -1;\n  gint                w                      = -1;\n  gint                h                      = -1;\n  GimpCoords          vectors1_coords[]      = GIMP_MAINIMAGE_VECTORS1_COORDS;\n  GimpCoords          vectors2_coords[]      = GIMP_MAINIMAGE_VECTORS2_COORDS;\n\n  /* Image size and type */\n  g_assert_cmpint (gimp_image_get_width (image),\n                   ==,\n                   GIMP_MAINIMAGE_WIDTH);\n  g_assert_cmpint (gimp_image_get_height (image),\n                   ==,\n                   GIMP_MAINIMAGE_HEIGHT);\n  g_assert_cmpint (gimp_image_get_base_type (image),\n                   ==,\n                   GIMP_MAINIMAGE_TYPE);\n\n  /* Layers */\n  layer = gimp_image_get_layer_by_name (image,\n                                        GIMP_MAINIMAGE_LAYER1_NAME);\n  g_assert_cmpint (gimp_item_get_width (GIMP_ITEM (layer)),\n                   ==,\n                   GIMP_MAINIMAGE_LAYER1_WIDTH);\n  g_assert_cmpint (gimp_item_get_height (GIMP_ITEM (layer)),\n                   ==,\n                   GIMP_MAINIMAGE_LAYER1_HEIGHT);\n  g_assert_cmpstr (babl_get_name (gimp_drawable_get_format (GIMP_DRAWABLE (layer))),\n                   ==,\n                   babl_get_name (GIMP_MAINIMAGE_LAYER1_FORMAT));\n  g_assert_cmpstr (gimp_object_get_name (GIMP_DRAWABLE (layer)),\n                   ==,\n                   GIMP_MAINIMAGE_LAYER1_NAME);\n  g_assert_cmpfloat (gimp_layer_get_opacity (layer),\n                     ==,\n                     GIMP_MAINIMAGE_LAYER1_OPACITY);\n  g_assert_cmpint (gimp_layer_get_mode (layer),\n                   ==,\n                   GIMP_MAINIMAGE_LAYER1_MODE);\n  layer = gimp_image_get_layer_by_name (image,\n                                        GIMP_MAINIMAGE_LAYER2_NAME);\n  g_assert_cmpint (gimp_item_get_width (GIMP_ITEM (layer)),\n                   ==,\n                   GIMP_MAINIMAGE_LAYER2_WIDTH);\n  g_assert_cmpint (gimp_item_get_height (GIMP_ITEM (layer)),\n                   ==,\n                   GIMP_MAINIMAGE_LAYER2_HEIGHT);\n  g_assert_cmpstr (babl_get_name (gimp_drawable_get_format (GIMP_DRAWABLE (layer))),\n                   ==,\n                   babl_get_name (GIMP_MAINIMAGE_LAYER2_FORMAT));\n  g_assert_cmpstr (gimp_object_get_name (GIMP_DRAWABLE (layer)),\n                   ==,\n                   GIMP_MAINIMAGE_LAYER2_NAME);\n  g_assert_cmpfloat (gimp_layer_get_opacity (layer),\n                     ==,\n                     GIMP_MAINIMAGE_LAYER2_OPACITY);\n  g_assert_cmpint (gimp_layer_get_mode (layer),\n                   ==,\n                   GIMP_MAINIMAGE_LAYER2_MODE);\n\n  /* Guides, note that we rely on internal ordering */\n  iter = gimp_image_get_guides (image);\n  g_assert (iter != NULL);\n  guide = iter->data;\n  g_assert_cmpint (gimp_guide_get_position (guide),\n                   ==,\n                   GIMP_MAINIMAGE_VGUIDE1_POS);\n  iter = g_list_next (iter);\n  g_assert (iter != NULL);\n  guide = iter->data;\n  g_assert_cmpint (gimp_guide_get_position (guide),\n                   ==,\n                   GIMP_MAINIMAGE_VGUIDE2_POS);\n  iter = g_list_next (iter);\n  g_assert (iter != NULL);\n  guide = iter->data;\n  g_assert_cmpint (gimp_guide_get_position (guide),\n                   ==,\n                   GIMP_MAINIMAGE_HGUIDE1_POS);\n  iter = g_list_next (iter);\n  g_assert (iter != NULL);\n  guide = iter->data;\n  g_assert_cmpint (gimp_guide_get_position (guide),\n                   ==,\n                   GIMP_MAINIMAGE_HGUIDE2_POS);\n  iter = g_list_next (iter);\n  g_assert (iter == NULL);\n\n  /* Sample points, we rely on the same ordering as when we added\n   * them, although this ordering is not a necessity\n   */\n  iter = gimp_image_get_sample_points (image);\n  g_assert (iter != NULL);\n  sample_point = iter->data;\n  gimp_sample_point_get_position (sample_point,\n                                  &sample_point_x, &sample_point_y);\n  g_assert_cmpint (sample_point_x,\n                   ==,\n                   GIMP_MAINIMAGE_SAMPLEPOINT1_X);\n  g_assert_cmpint (sample_point_y,\n                   ==,\n                   GIMP_MAINIMAGE_SAMPLEPOINT1_Y);\n  iter = g_list_next (iter);\n  g_assert (iter != NULL);\n  sample_point = iter->data;\n  gimp_sample_point_get_position (sample_point,\n                                  &sample_point_x, &sample_point_y);\n  g_assert_cmpint (sample_point_x,\n                   ==,\n                   GIMP_MAINIMAGE_SAMPLEPOINT2_X);\n  g_assert_cmpint (sample_point_y,\n                   ==,\n                   GIMP_MAINIMAGE_SAMPLEPOINT2_Y);\n  iter = g_list_next (iter);\n  g_assert (iter == NULL);\n\n  /* Resolution */\n  gimp_image_get_resolution (image, &xres, &yres);\n  g_assert_cmpint (xres,\n                   ==,\n                   GIMP_MAINIMAGE_RESOLUTIONX);\n  g_assert_cmpint (yres,\n                   ==,\n                   GIMP_MAINIMAGE_RESOLUTIONY);\n\n  /* Parasites */\n  parasite = gimp_image_parasite_find (image,\n                                       GIMP_MAINIMAGE_PARASITE_NAME);\n  g_assert_cmpint (gimp_parasite_data_size (parasite),\n                   ==,\n                   GIMP_MAINIMAGE_PARASITE_SIZE);\n  g_assert_cmpstr (gimp_parasite_data (parasite),\n                   ==,\n                   GIMP_MAINIMAGE_PARASITE_DATA);\n  parasite = gimp_image_parasite_find (image,\n                                       \"gimp-comment\");\n  g_assert_cmpint (gimp_parasite_data_size (parasite),\n                   ==,\n                   strlen (GIMP_MAINIMAGE_COMMENT) + 1);\n  g_assert_cmpstr (gimp_parasite_data (parasite),\n                   ==,\n                   GIMP_MAINIMAGE_COMMENT);\n\n  /* Unit */\n  g_assert_cmpint (gimp_image_get_unit (image),\n                   ==,\n                   GIMP_MAINIMAGE_UNIT);\n\n  /* Grid */\n  grid = gimp_image_get_grid (image);\n  g_object_get (grid,\n                \"xspacing\", &xspacing,\n                \"yspacing\", &yspacing,\n                NULL);\n  g_assert_cmpint (xspacing,\n                   ==,\n                   GIMP_MAINIMAGE_GRIDXSPACING);\n  g_assert_cmpint (yspacing,\n                   ==,\n                   GIMP_MAINIMAGE_GRIDYSPACING);\n\n\n  /* Channel */\n  channel = gimp_image_get_channel_by_name (image,\n                                            GIMP_MAINIMAGE_CHANNEL1_NAME);\n  gimp_channel_get_color (channel, &actual_channel_color);\n  g_assert_cmpint (gimp_item_get_width (GIMP_ITEM (channel)),\n                   ==,\n                   GIMP_MAINIMAGE_CHANNEL1_WIDTH);\n  g_assert_cmpint (gimp_item_get_height (GIMP_ITEM (channel)),\n                   ==,\n                   GIMP_MAINIMAGE_CHANNEL1_HEIGHT);\n  g_assert (memcmp (&expected_channel_color,\n                    &actual_channel_color,\n                    sizeof (GimpRGB)) == 0);\n\n  /* Selection, if the image contains unusual stuff it contains a\n   * floating select, and when floating a selection, the selection\n   * mask is cleared, so don't test for the presence of the selection\n   * mask in that case\n   */\n  if (! with_unusual_stuff)\n    {\n      selection = gimp_image_get_mask (image);\n      gimp_item_bounds (GIMP_ITEM (selection), &x, &y, &w, &h);\n      g_assert_cmpint (x,\n                       ==,\n                       GIMP_MAINIMAGE_SELECTION_X);\n      g_assert_cmpint (y,\n                       ==,\n                       GIMP_MAINIMAGE_SELECTION_Y);\n      g_assert_cmpint (w,\n                       ==,\n                       GIMP_MAINIMAGE_SELECTION_W);\n      g_assert_cmpint (h,\n                       ==,\n                       GIMP_MAINIMAGE_SELECTION_H);\n    }\n\n  /* Vectors 1 */\n  gimp_assert_vectors (image,\n                       GIMP_MAINIMAGE_VECTORS1_NAME,\n                       vectors1_coords,\n                       G_N_ELEMENTS (vectors1_coords),\n                       ! compat_paths /*visible*/);\n\n  /* Vectors 2 (always visible FALSE) */\n  gimp_assert_vectors (image,\n                       GIMP_MAINIMAGE_VECTORS2_NAME,\n                       vectors2_coords,\n                       G_N_ELEMENTS (vectors2_coords),\n                       FALSE /*visible*/);\n\n  if (with_unusual_stuff)\n    g_assert (gimp_image_get_floating_selection (image) != NULL);\n  else /* if (! with_unusual_stuff) */\n    g_assert (gimp_image_get_floating_selection (image) == NULL);\n\n  if (use_gimp_2_8_features)\n    {\n      /* Only verify the parent relationships, the layer attributes\n       * are tested above\n       */\n      GimpItem *group1 = GIMP_ITEM (gimp_image_get_layer_by_name (image, GIMP_MAINIMAGE_GROUP1_NAME));\n      GimpItem *layer3 = GIMP_ITEM (gimp_image_get_layer_by_name (image, GIMP_MAINIMAGE_LAYER3_NAME));\n      GimpItem *layer4 = GIMP_ITEM (gimp_image_get_layer_by_name (image, GIMP_MAINIMAGE_LAYER4_NAME));\n      GimpItem *group2 = GIMP_ITEM (gimp_image_get_layer_by_name (image, GIMP_MAINIMAGE_GROUP2_NAME));\n      GimpItem *layer5 = GIMP_ITEM (gimp_image_get_layer_by_name (image, GIMP_MAINIMAGE_LAYER5_NAME));\n\n      g_assert (gimp_item_get_parent (group1) == NULL);\n      g_assert (gimp_item_get_parent (layer3) == group1);\n      g_assert (gimp_item_get_parent (layer4) == group1);\n      g_assert (gimp_item_get_parent (group2) == group1);\n      g_assert (gimp_item_get_parent (layer5) == group2);\n    }\n}\n\n\n/**\n * main:\n * @argc:\n * @argv:\n *\n * These tests intend to\n *\n *  - Make sure that we are backwards compatible with files created by\n *    older version of GIMP, i.e. that we can load files from earlier\n *    version of GIMP\n *\n *  - Make sure that the information put into a #GimpImage is not lost\n *    when the #GimpImage is written to a file and then read again\n **/\nint\nmain (int    argc,\n      char **argv)\n{\n  Gimp *gimp;\n  int   result;\n\n  g_test_init (&argc, &argv, NULL);\n\n  gimp_test_utils_set_gimp3_directory (\"GIMP_TESTING_ABS_TOP_SRCDIR\",\n                                       \"app/tests/gimpdir\");\n\n  /* We share the same application instance across all tests. We need\n   * the GUI variant for the file procs\n   */\n  gimp = gimp_init_for_testing ();\n\n  /* Add tests */\n  ADD_TEST (write_and_read_gimp_2_6_format);\n  ADD_TEST (write_and_read_gimp_2_6_format_unusual);\n  ADD_TEST (load_gimp_2_6_file);\n  ADD_TEST (write_and_read_gimp_2_8_format);\n\n  /* Don't write files to the source dir */\n  gimp_test_utils_set_gimp3_directory (\"GIMP_TESTING_ABS_TOP_BUILDDIR\",\n                                       \"app/tests/gimpdir-output\");\n\n  /* Run the tests */\n  result = g_test_run ();\n\n  /* Exit so we don't break script-fu plug-in wire */\n  gimp_exit (gimp, TRUE);\n\n  return result;\n}\n"], "filenames": ["app/tests/test-xcf.c"], "buggy_code_start_loc": [298], "buggy_code_end_loc": [315], "fixing_code_start_loc": [298], "fixing_code_end_loc": [318], "type": "NVD-CWE-noinfo", "message": "GIMP through 2.10.2 makes g_get_tmp_dir calls to establish temporary filenames, which may result in a filename that already exists, as demonstrated by the gimp_write_and_read_file function in app/tests/test-xcf.c. This might be leveraged by attackers to overwrite files or read file content that was intended to be private.", "other": {"cve": {"id": "CVE-2018-12713", "sourceIdentifier": "cve@mitre.org", "published": "2018-06-24T22:29:00.267", "lastModified": "2022-02-07T18:42:13.547", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "GIMP through 2.10.2 makes g_get_tmp_dir calls to establish temporary filenames, which may result in a filename that already exists, as demonstrated by the gimp_write_and_read_file function in app/tests/test-xcf.c. This might be leveraged by attackers to overwrite files or read file content that was intended to be private."}, {"lang": "es", "value": "GIMP hasta la versi\u00f3n 2.10.2 realiza llamadas g_get_tmp_dir para establecer nombres de archivo temporales, lo que podr\u00eda resultar en un nombre de archivo que ya existe, tal y como queda demostrado con la funci\u00f3n gimp_write_and_read_file en app/tests/test-xcf.c. Esto podr\u00eda ser aprovechado por atacantes para sobrescribir archivos o leer el contenido que se supone que deber\u00eda ser privado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gimp:gimp:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.10.2", "matchCriteriaId": "EF127F3A-FC27-429A-93E1-3290C06A34CE"}]}]}], "references": [{"url": "https://github.com/GNOME/gimp/commit/c21eff4b031acb04fb4dfce8bd5fdfecc2b6524f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://gitlab.gnome.org/GNOME/gimp/issues/1689", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/GNOME/gimp/commit/c21eff4b031acb04fb4dfce8bd5fdfecc2b6524f"}}