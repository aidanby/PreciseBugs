{"buggy_code": ["/* Capstone Disassembly Engine */\n/* By Satoshi Tanda <tanda.sat@gmail.com>, 2016 */\n\n#include \"winkernel_mm.h\"\n#include <ntddk.h>\n\n// A pool tag for memory allocation\nstatic const ULONG CS_WINKERNEL_POOL_TAG = 'kwsC';\n\n\n// A structure to implement realloc()\ntypedef struct _CS_WINKERNEL_MEMBLOCK {\n\tsize_t size;   // A number of bytes allocated\n\tchar data[1];  // An address returned to a caller\n} CS_WINKERNEL_MEMBLOCK;\nC_ASSERT(sizeof(CS_WINKERNEL_MEMBLOCK) == sizeof(void *) * 2);\n\n\n// free()\nvoid CAPSTONE_API cs_winkernel_free(void *ptr)\n{\n\tif (ptr) {\n\t\tExFreePoolWithTag(CONTAINING_RECORD(ptr, CS_WINKERNEL_MEMBLOCK, data), CS_WINKERNEL_POOL_TAG);\n\t}\n}\n\n// malloc()\nvoid * CAPSTONE_API cs_winkernel_malloc(size_t size)\n{\n\t// Disallow zero length allocation because they waste pool header space and,\n\t// in many cases, indicate a potential validation issue in the calling code.\n\tNT_ASSERT(size);\n\n\t// FP; a use of NonPagedPool is required for Windows 7 support\n#pragma prefast(suppress : 30030)\t\t// Allocating executable POOL_TYPE memory\n\tCS_WINKERNEL_MEMBLOCK *block = (CS_WINKERNEL_MEMBLOCK *)ExAllocatePoolWithTag(\n\t\t\tNonPagedPool, size + sizeof(CS_WINKERNEL_MEMBLOCK), CS_WINKERNEL_POOL_TAG);\n\tif (!block) {\n\t\treturn NULL;\n\t}\n\tblock->size = size;\n\n\treturn block->data;\n}\n\n// calloc()\nvoid * CAPSTONE_API cs_winkernel_calloc(size_t n, size_t size)\n{\n\tsize_t total = n * size;\n\n\tvoid *new_ptr = cs_winkernel_malloc(total);\n\tif (!new_ptr) {\n\t\treturn NULL;\n\t}\n\n\treturn RtlFillMemory(new_ptr, total, 0);\n}\n\n// realloc()\nvoid * CAPSTONE_API cs_winkernel_realloc(void *ptr, size_t size)\n{\n\tvoid *new_ptr = NULL;\n\tsize_t current_size = 0;\n\tsize_t smaller_size = 0;\n\n\tif (!ptr) {\n\t\treturn cs_winkernel_malloc(size);\n\t}\n\n\tnew_ptr = cs_winkernel_malloc(size);\n\tif (!new_ptr) {\n\t\treturn NULL;\n\t}\n\n\tcurrent_size = CONTAINING_RECORD(ptr, CS_WINKERNEL_MEMBLOCK, data)->size;\n\tsmaller_size = (current_size < size) ? current_size : size;\n\tRtlCopyMemory(new_ptr, ptr, smaller_size);\n\tcs_winkernel_free(ptr);\n\n\treturn new_ptr;\n}\n\n// vsnprintf(). _vsnprintf() is available for drivers, but it differs from\n// vsnprintf() in a return value and when a null-terminator is set.\n// cs_winkernel_vsnprintf() takes care of those differences.\n#pragma warning(push)\n// Banned API Usage : _vsnprintf is a Banned API as listed in dontuse.h for\n// security purposes.\n#pragma warning(disable : 28719)\nint CAPSTONE_API cs_winkernel_vsnprintf(char *buffer, size_t count, const char *format, va_list argptr)\n{\n\tint result = _vsnprintf(buffer, count, format, argptr);\n\n\t// _vsnprintf() returns -1 when a string is truncated, and returns \"count\"\n\t// when an entire string is stored but without '\\0' at the end of \"buffer\".\n\t// In both cases, null-terminator needs to be added manually.\n\tif (result == -1 || (size_t)result == count) {\n\t\tbuffer[count - 1] = '\\0';\n\t}\n\n\tif (result == -1) {\n\t\t// In case when -1 is returned, the function has to get and return a number\n\t\t// of characters that would have been written. This attempts so by retrying\n\t\t// the same conversion with temp buffer that is most likely big enough to\n\t\t// complete formatting and get a number of characters that would have been\n\t\t// written.\n\t\tchar* tmp = cs_winkernel_malloc(0x1000);\n\t\tif (!tmp) {\n\t\t\treturn result;\n\t\t}\n\n\t\tresult = _vsnprintf(tmp, 0x1000, format, argptr);\n\t\tNT_ASSERT(result != -1);\n\t\tcs_winkernel_free(tmp);\n\t}\n\n\treturn result;\n}\n#pragma warning(pop)\n"], "fixing_code": ["/* Capstone Disassembly Engine */\n/* By Satoshi Tanda <tanda.sat@gmail.com>, 2016 */\n\n#include \"winkernel_mm.h\"\n#include <ntddk.h>\n#include <Ntintsafe.h>\n\n// A pool tag for memory allocation\nstatic const ULONG CS_WINKERNEL_POOL_TAG = 'kwsC';\n\n\n// A structure to implement realloc()\ntypedef struct _CS_WINKERNEL_MEMBLOCK {\n\tsize_t size;   // A number of bytes allocated\n\tchar data[1];  // An address returned to a caller\n} CS_WINKERNEL_MEMBLOCK;\nC_ASSERT(sizeof(CS_WINKERNEL_MEMBLOCK) == sizeof(void *) * 2);\n\n\n// free()\nvoid CAPSTONE_API cs_winkernel_free(void *ptr)\n{\n\tif (ptr) {\n\t\tExFreePoolWithTag(CONTAINING_RECORD(ptr, CS_WINKERNEL_MEMBLOCK, data), CS_WINKERNEL_POOL_TAG);\n\t}\n}\n\n// malloc()\nvoid * CAPSTONE_API cs_winkernel_malloc(size_t size)\n{\n\t// Disallow zero length allocation because they waste pool header space and,\n\t// in many cases, indicate a potential validation issue in the calling code.\n\tNT_ASSERT(size);\n\n\t// FP; a use of NonPagedPool is required for Windows 7 support\n#pragma prefast(suppress : 30030)\t\t// Allocating executable POOL_TYPE memory\n\tsize_t number_of_bytes = 0;\n\tCS_WINKERNEL_MEMBLOCK *block = NULL;\n\t// A specially crafted size value can trigger the overflow.\n\t// If the sum in a value that overflows or underflows the capacity of the type,\n\t// the function returns NULL.\n\tif (!NT_SUCCESS(RtlSizeTAdd(size, sizeof(CS_WINKERNEL_MEMBLOCK), &number_of_bytes))) {\n\t\treturn NULL;\n\t}\n\tblock = (CS_WINKERNEL_MEMBLOCK *)ExAllocatePoolWithTag(\n\t\t\tNonPagedPool, number_of_bytes, CS_WINKERNEL_POOL_TAG);\n\tif (!block) {\n\t\treturn NULL;\n\t}\n\tblock->size = size;\n\n\treturn block->data;\n}\n\n// calloc()\nvoid * CAPSTONE_API cs_winkernel_calloc(size_t n, size_t size)\n{\n\tsize_t total = n * size;\n\n\tvoid *new_ptr = cs_winkernel_malloc(total);\n\tif (!new_ptr) {\n\t\treturn NULL;\n\t}\n\n\treturn RtlFillMemory(new_ptr, total, 0);\n}\n\n// realloc()\nvoid * CAPSTONE_API cs_winkernel_realloc(void *ptr, size_t size)\n{\n\tvoid *new_ptr = NULL;\n\tsize_t current_size = 0;\n\tsize_t smaller_size = 0;\n\n\tif (!ptr) {\n\t\treturn cs_winkernel_malloc(size);\n\t}\n\n\tnew_ptr = cs_winkernel_malloc(size);\n\tif (!new_ptr) {\n\t\treturn NULL;\n\t}\n\n\tcurrent_size = CONTAINING_RECORD(ptr, CS_WINKERNEL_MEMBLOCK, data)->size;\n\tsmaller_size = (current_size < size) ? current_size : size;\n\tRtlCopyMemory(new_ptr, ptr, smaller_size);\n\tcs_winkernel_free(ptr);\n\n\treturn new_ptr;\n}\n\n// vsnprintf(). _vsnprintf() is available for drivers, but it differs from\n// vsnprintf() in a return value and when a null-terminator is set.\n// cs_winkernel_vsnprintf() takes care of those differences.\n#pragma warning(push)\n// Banned API Usage : _vsnprintf is a Banned API as listed in dontuse.h for\n// security purposes.\n#pragma warning(disable : 28719)\nint CAPSTONE_API cs_winkernel_vsnprintf(char *buffer, size_t count, const char *format, va_list argptr)\n{\n\tint result = _vsnprintf(buffer, count, format, argptr);\n\n\t// _vsnprintf() returns -1 when a string is truncated, and returns \"count\"\n\t// when an entire string is stored but without '\\0' at the end of \"buffer\".\n\t// In both cases, null-terminator needs to be added manually.\n\tif (result == -1 || (size_t)result == count) {\n\t\tbuffer[count - 1] = '\\0';\n\t}\n\n\tif (result == -1) {\n\t\t// In case when -1 is returned, the function has to get and return a number\n\t\t// of characters that would have been written. This attempts so by retrying\n\t\t// the same conversion with temp buffer that is most likely big enough to\n\t\t// complete formatting and get a number of characters that would have been\n\t\t// written.\n\t\tchar* tmp = cs_winkernel_malloc(0x1000);\n\t\tif (!tmp) {\n\t\t\treturn result;\n\t\t}\n\n\t\tresult = _vsnprintf(tmp, 0x1000, format, argptr);\n\t\tNT_ASSERT(result != -1);\n\t\tcs_winkernel_free(tmp);\n\t}\n\n\treturn result;\n}\n#pragma warning(pop)\n"], "filenames": ["windows/winkernel_mm.c"], "buggy_code_start_loc": [5], "buggy_code_end_loc": [38], "fixing_code_start_loc": [6], "fixing_code_end_loc": [47], "type": "CWE-190", "message": "Integer overflow in the cs_winkernel_malloc function in winkernel_mm.c in Capstone 3.0.4 and earlier allows attackers to cause a denial of service (heap-based buffer overflow in a kernel driver) or possibly have unspecified other impact via a large value.", "other": {"cve": {"id": "CVE-2017-6952", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-16T21:59:00.167", "lastModified": "2017-04-05T01:59:01.253", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Integer overflow in the cs_winkernel_malloc function in winkernel_mm.c in Capstone 3.0.4 and earlier allows attackers to cause a denial of service (heap-based buffer overflow in a kernel driver) or possibly have unspecified other impact via a large value."}, {"lang": "es", "value": "Desbordamiento de entero en la funci\u00f3n cs_winkernel_malloc en winkernel_mm.c en Capstone 3.0.4 y versiones anteriores permite a atacantes provocar una denegaci\u00f3n de servicio (desbordamiento de b\u00fafer basado en memoria din\u00e1mica en un controlador del kernel) o tener otro posible impacto no especificado a trav\u00e9s de un valor grande."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:capstone-engine:capstone:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.0.4", "matchCriteriaId": "65330FAB-135C-4C19-BB22-C0A44A80DFC6"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/97323", "source": "cve@mitre.org"}, {"url": "https://github.com/aquynh/capstone/commit/6fe86eef621b9849f51a5e1e5d73258a93440403", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/aquynh/capstone/commit/6fe86eef621b9849f51a5e1e5d73258a93440403"}}