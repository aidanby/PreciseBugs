{"buggy_code": ["import itertools\n\nfrom flask import request, abort, _app_ctx_stack, redirect\nfrom flask_security.core import AnonymousUser\nfrom security_monkey.datastore import User\n\ntry:\n    from flask.ext.login import current_user\nexcept ImportError:\n    current_user = None\n\nfrom .models import RBACRole, RBACUserMixin\n\nfrom . import anonymous\n\nfrom flask import Response\nimport json\n\n\nclass AccessControlList(object):\n    \"\"\"\n    This class record rules for access controling.\n    \"\"\"\n\n    def __init__(self):\n        self._allowed = []\n        self._exempt = []\n        self.seted = False\n\n    def allow(self, role, method, resource, with_children=True):\n        \"\"\"Add allowing rules.\n\n        :param role: Role of this rule.\n        :param method: Method to allow in rule, include GET, POST, PUT etc.\n        :param resource: Resource also view function.\n        :param with_children: Allow role's children in rule as well\n                              if with_children is `True`\n        \"\"\"\n\n        if with_children:\n            for r in role.get_children():\n                permission = (r.name, method, resource)\n                if permission not in self._allowed:\n                    self._allowed.append(permission)\n        permission = (role.name, method, resource)\n        if permission not in self._allowed:\n            self._allowed.append(permission)\n\n    def exempt(self, view_func):\n        \"\"\"Exempt a view function from being checked permission\n\n        :param view_func: The view function exempt from checking.\n        \"\"\"\n        if not view_func in self._exempt:\n            self._exempt.append(view_func)\n\n    def is_allowed(self, role, method, resource):\n        \"\"\"Check whether role is allowed to access resource\n\n        :param role: Role to be checked.\n        :param method: Method to be checked.\n        :param resource: View function to be checked.\n        \"\"\"\n        return (role, method, resource) in self._allowed\n\n    def is_exempt(self, view_func):\n        \"\"\"Return whether view_func is exempted.\n\n        :param view_func: View function to be checked.\n        \"\"\"\n        return view_func in self._exempt\n\n\nclass _RBACState(object):\n    \"\"\"Records configuration for Flask-RBAC\"\"\"\n    def __init__(self, rbac, app):\n        self.rbac = rbac\n        self.app = app\n\n\nclass RBAC(object):\n    \"\"\"\n    This class implements role-based access control module in Flask.\n    There are two way to initialize Flask-RBAC::\n\n        app = Flask(__name__)\n        rbac = RBAC(app)\n\n    :param app: the Flask object\n    \"\"\"\n\n    _role_model = RBACRole\n    _user_model = RBACUserMixin\n\n    def __init__(self, app):\n        self.acl = AccessControlList()\n        self.before_acl = []\n\n        self.app = app\n        self.init_app(app)\n\n    def init_app(self, app):\n        # Add (RBAC, app) to flask extensions.\n        # Add hook to authenticate permission before request.\n\n        if not hasattr(app, 'extensions'):\n            app.extensions = {}\n        app.extensions['rbac'] = _RBACState(self, app)\n\n        self.acl.allow(anonymous, 'GET', app.view_functions['static'].__name__)\n        app.before_first_request(self._setup_acl)\n        app.before_request(self._authenticate)\n\n    def has_permission(self, method, endpoint, user=None):\n        \"\"\"Return whether the current user can access the resource.\n        Example::\n\n            @app.route('/some_url', methods=['GET', 'POST'])\n            @rbac.allow(['anonymous'], ['GET'])\n            def a_view_func():\n                return Response('Blah Blah...')\n\n        If you are not logged.\n\n        `rbac.has_permission('GET', 'a_view_func')` return True.\n        `rbac.has_permission('POST', 'a_view_func')` return False.\n\n        :param method: The method wait to check.\n        :param endpoint: The application endpoint.\n        :param user: user who you need to check. Current user by default.\n        \"\"\"\n        app = self.get_app()\n        _user = user or current_user\n        roles = _user.get_roles()\n        view_func = app.view_functions[endpoint]\n        return self._check_permission(roles, method, view_func)\n\n    def check_perm(self, role, method, callback=None):\n        def decorator(view_func):\n            if not self._check_permission([role], method, view_func):\n                if callable(callback):\n                    callback()\n                else:\n                    self._deny_hook()\n            return view_func\n        return decorator\n\n    def allow(self, roles, methods, with_children=True):\n        \"\"\"Decorator: allow roles to access the view func with it.\n\n        :param roles: List, each name of roles. Please note that,\n                      `anonymous` is refered to anonymous.\n                      If you add `anonymous` to the rule,\n                      everyone can access the resource,\n                      unless you deny other roles.\n        :param methods: List, each name of methods.\n                        methods is valid in ['GET', 'POST', 'PUT', 'DELETE']\n        :param with_children: Whether allow children of roles as well.\n                              True by default.\n        \"\"\"\n        def decorator(view_func):\n            _methods = [m.upper() for m in methods]\n            for r, m, v in itertools.product(roles, _methods, [view_func.__name__]):\n                self.before_acl.append((r, m, v, with_children))\n            return view_func\n        return decorator\n\n    def exempt(self, view_func):\n        \"\"\"\n        Decorator function\n        Exempt a view function from being checked permission.\n        \"\"\"\n        self.acl.exempt(view_func.__name__)\n        return view_func\n\n    def get_app(self, reference_app=None):\n        \"\"\"\n        Helper to look up an app.\n        \"\"\"\n        if reference_app is not None:\n            return reference_app\n        if self.app is not None:\n            return self.app\n        ctx = _app_ctx_stack.top\n        if ctx is not None:\n            return ctx.app\n        raise RuntimeError('application not registered on rbac '\n                           'instance and no application bound '\n                           'to current context')\n\n    def _authenticate(self):\n        app = self.get_app()\n        assert app, \"Please initialize your application into Flask-RBAC.\"\n        assert self._role_model, \"Please set role model before authenticate.\"\n        assert self._user_model, \"Please set user model before authenticate.\"\n        user = current_user\n        if not isinstance(user._get_current_object(), self._user_model) and not isinstance(user._get_current_object(), AnonymousUser):\n            raise TypeError(\n                \"%s is not an instance of %s\" %\n                (user, self._user_model.__class__))\n\n        endpoint = request.endpoint\n        resource = app.view_functions.get(endpoint, None)\n\n        if not resource:\n            abort(404)\n\n        method = request.method\n        if not hasattr(user, 'get_roles'):\n            roles = [anonymous]\n        else:\n            roles = user.get_roles()\n\n        permit = self._check_permission(roles, method, resource)\n        if not permit:\n            return self._deny_hook(resource=resource)\n\n    def _check_permission(self, roles, method, resource):\n\n        resource = resource.__name__\n        if self.acl.is_exempt(resource):\n            return True\n\n        if not self.acl.seted:\n            self._setup_acl()\n\n        _roles = set()\n        _methods = {'*', method}\n        _resources = {None, resource}\n\n        _roles.add(anonymous)\n\n        _roles.update(roles)\n\n        for r, m, res in itertools.product(_roles, _methods, _resources):\n            if self.acl.is_allowed(r.name, m, res):\n                return True\n\n        return False\n\n    def _deny_hook(self, resource=None):\n        app = self.get_app()\n        if current_user.is_authenticated():\n            status = 403\n        else:\n            status = 401\n        #abort(status)\n\n        if app.config.get('FRONTED_BY_NGINX'):\n                url = \"https://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('NGINX_PORT'), '/login')\n        else:\n                url = \"http://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('API_PORT'), '/login')\n        if current_user.is_authenticated():\n            auth_dict = {\n                \"authenticated\": True,\n                \"user\": current_user.email,\n                \"roles\": current_user.role,\n            }\n        else:\n            auth_dict = {\n                \"authenticated\": False,\n                \"user\": None,\n                \"url\": url\n            }\n\n        return Response(response=json.dumps({\"auth\": auth_dict}), status=status, mimetype=\"application/json\")\n\n\n    def _setup_acl(self):\n        for rn, method, resource, with_children in self.before_acl:\n            role = self._role_model.get_by_name(rn)\n            self.acl.allow(role, method, resource, with_children)\n        self.acl.seted = True\n", "\"\"\"\n.. module: security_monkey.sso.views\n    :platform: Unix\n    :copyright: (c) 2015 by Netflix Inc., see AUTHORS for more\n    :license: Apache, see LICENSE for more details.\n.. moduleauthor:: Patrick Kelley <patrick@netflix.com>\n\"\"\"\nimport jwt\nimport base64\nimport requests\n\nfrom flask import Blueprint, current_app, redirect, request\n\nfrom flask.ext.restful import reqparse, Resource, Api\nfrom flask.ext.principal import Identity, identity_changed\nfrom flask_login import login_user\n\ntry:\n    from onelogin.saml2.auth import OneLogin_Saml2_Auth\n    from onelogin.saml2.utils import OneLogin_Saml2_Utils\n    onelogin_import_success = True\nexcept ImportError:\n    onelogin_import_success = False\n\nfrom .service import fetch_token_header_payload, get_rsa_public_key\n\nfrom security_monkey.datastore import User\nfrom security_monkey import db, rbac\n\nfrom urlparse import urlparse\n\nmod = Blueprint('sso', __name__)\napi = Api(mod)\n\n\nfrom flask_security.utils import validate_redirect_url\n\n\nclass Ping(Resource):\n    \"\"\"\n    This class serves as an example of how one might implement an SSO provider for use with Security Monkey. In\n    this example we use a OpenIDConnect authentication flow, that is essentially OAuth2 underneath.\n    \"\"\"\n    decorators = [rbac.allow([\"anonymous\"], [\"GET\", \"POST\"])]\n    def __init__(self):\n        self.reqparse = reqparse.RequestParser()\n        super(Ping, self).__init__()\n\n    def get(self):\n        return self.post()\n\n    def post(self):\n        if \"ping\" not in current_app.config.get(\"ACTIVE_PROVIDERS\"):\n            return \"Ping is not enabled in the config.  See the ACTIVE_PROVIDERS section.\", 404\n\n        default_state = 'clientId,{client_id},redirectUri,{redirectUri},return_to,{return_to}'.format(\n            client_id=current_app.config.get('PING_CLIENT_ID'),\n            redirectUri=current_app.config.get('PING_REDIRECT_URI'),\n            return_to=current_app.config.get('WEB_PATH')\n        )\n        self.reqparse.add_argument('code', type=str, required=True)\n        self.reqparse.add_argument('state', type=str, required=False, default=default_state)\n\n        args = self.reqparse.parse_args()\n        client_id = args['state'].split(',')[1]\n        redirect_uri = args['state'].split(',')[3]\n        return_to = args['state'].split(',')[5]\n\n        if not validate_redirect_url(return_to):\n            return_to = current_app.config.get('WEB_PATH')\n\n        # take the information we have received from the provider to create a new request\n        params = {\n            'client_id': client_id,\n            'grant_type': 'authorization_code',\n            'scope': 'openid email profile address',\n            'redirect_uri': redirect_uri,\n            'code': args['code']\n        }\n\n        # you can either discover these dynamically or simply configure them\n        access_token_url = current_app.config.get('PING_ACCESS_TOKEN_URL')\n        user_api_url = current_app.config.get('PING_USER_API_URL')\n\n        # the secret and cliendId will be given to you when you signup for the provider\n        basic = base64.b64encode(bytes('{0}:{1}'.format(client_id, current_app.config.get(\"PING_SECRET\"))))\n        headers = {'Authorization': 'Basic {0}'.format(basic.decode('utf-8'))}\n\n        # exchange authorization code for access token.\n        r = requests.post(access_token_url, headers=headers, params=params)\n        id_token = r.json()['id_token']\n        access_token = r.json()['access_token']\n\n        # fetch token public key\n        header_data = fetch_token_header_payload(id_token)[0]\n        jwks_url = current_app.config.get('PING_JWKS_URL')\n\n        # retrieve the key material as specified by the token header\n        r = requests.get(jwks_url)\n        for key in r.json()['keys']:\n            if key['kid'] == header_data['kid']:\n                secret = get_rsa_public_key(key['n'], key['e'])\n                algo = header_data['alg']\n                break\n        else:\n            return dict(message='Key not found'), 403\n\n        # validate your token based on the key it was signed with\n        try:\n            current_app.logger.debug(id_token)\n            current_app.logger.debug(secret)\n            current_app.logger.debug(algo)\n            jwt.decode(id_token, secret.decode('utf-8'), algorithms=[algo], audience=client_id)\n        except jwt.DecodeError:\n            return dict(message='Token is invalid'), 403\n        except jwt.ExpiredSignatureError:\n            return dict(message='Token has expired'), 403\n        except jwt.InvalidTokenError:\n            return dict(message='Token is invalid'), 403\n\n        user_params = dict(access_token=access_token, schema='profile')\n\n        # retrieve information about the current user.\n        r = requests.get(user_api_url, params=user_params)\n        profile = r.json()\n\n        user = User.query.filter(User.email==profile['email']).first()\n\n        # if we get an sso user create them an account\n        if not user:\n            user = User(\n                email=profile['email'],\n                active=True,\n                role='View'\n                # profile_picture=profile.get('thumbnailPhotoUrl')\n            )\n            db.session.add(user)\n            db.session.commit()\n            db.session.refresh(user)\n\n        # Tell Flask-Principal the identity changed\n        identity_changed.send(current_app._get_current_object(), identity=Identity(user.id))\n        login_user(user)\n\n        return redirect(return_to, code=302)\n\n\nclass Google(Resource):\n    decorators = [rbac.allow([\"anonymous\"], [\"GET\", \"POST\"])]\n    def __init__(self):\n        self.reqparse = reqparse.RequestParser()\n        super(Google, self).__init__()\n\n    def get(self):\n        return self.post()\n\n    def post(self):\n        if \"google\" not in current_app.config.get(\"ACTIVE_PROVIDERS\"):\n            return \"Google is not enabled in the config.  See the ACTIVE_PROVIDERS section.\", 404\n\n        default_state = 'clientId,{client_id},redirectUri,{redirectUri},return_to,{return_to}'.format(\n            client_id=current_app.config.get(\"GOOGLE_CLIENT_ID\"),\n            redirectUri=api.url_for(Google),\n            return_to=current_app.config.get('WEB_PATH')\n        )\n        self.reqparse.add_argument('code', type=str, required=True)\n        self.reqparse.add_argument('state', type=str, required=False, default=default_state)\n\n        args = self.reqparse.parse_args()\n        client_id = args['state'].split(',')[1]\n        redirect_uri = args['state'].split(',')[3]\n        return_to = args['state'].split(',')[5]\n\n        if not validate_redirect_url(return_to):\n            return_to = current_app.config.get('WEB_PATH')\n\n        access_token_url = 'https://accounts.google.com/o/oauth2/token'\n        people_api_url = 'https://www.googleapis.com/plus/v1/people/me/openIdConnect'\n\n        args = self.reqparse.parse_args()\n\n        # Step 1. Exchange authorization code for access token\n        payload = {\n            'client_id': client_id,\n            'grant_type': 'authorization_code',\n            'redirect_uri': redirect_uri,\n            'code': args['code'],\n            'client_secret': current_app.config.get('GOOGLE_SECRET')\n        }\n\n        r = requests.post(access_token_url, data=payload)\n        token = r.json()\n\n        # Step 1bis. Validate (some information of) the id token (if necessary)\n        google_hosted_domain = current_app.config.get(\"GOOGLE_HOSTED_DOMAIN\")\n        if google_hosted_domain is not None:\n            current_app.logger.debug('We need to verify that the token was issued for this hosted domain: %s ' % (google_hosted_domain))\n\n\t    # Get the JSON Web Token\n            id_token = r.json()['id_token']\n            current_app.logger.debug('The id_token is: %s' % (id_token))\n\n            # Extract the payload\n            (header_data, payload_data) = fetch_token_header_payload(id_token)\n            current_app.logger.debug('id_token.header_data: %s' % (header_data))\n            current_app.logger.debug('id_token.payload_data: %s' % (payload_data))\n\n            token_hd = payload_data.get('hd')\n            if token_hd != google_hosted_domain:\n                current_app.logger.debug('Verification failed: %s != %s' % (token_hd, google_hosted_domain))\n                return dict(message='Token is invalid %s' % token), 403\n            current_app.logger.debug('Verification passed')\n\n        # Step 2. Retrieve information about the current user\n        headers = {'Authorization': 'Bearer {0}'.format(token['access_token'])}\n\n        r = requests.get(people_api_url, headers=headers)\n        profile = r.json()\n\n        user = User.query.filter(User.email == profile['email']).first()\n\n        # if we get an sso user create them an account\n        if not user:\n            user = User(\n                email=profile['email'],\n                active=True,\n                role='View'\n                # profile_picture=profile.get('thumbnailPhotoUrl')\n            )\n            db.session.add(user)\n            db.session.commit()\n            db.session.refresh(user)\n\n        # Tell Flask-Principal the identity changed\n        identity_changed.send(current_app._get_current_object(), identity=Identity(user.id))\n        login_user(user)\n\n        return redirect(return_to, code=302)\n\n\nclass OneLogin(Resource):\n    decorators = [rbac.allow([\"anonymous\"], [\"GET\", \"POST\"])]\n    def __init__(self):\n        self.reqparse = reqparse.RequestParser()\n        self.req = OneLogin.prepare_from_flask_request(request)\n        super(OneLogin, self).__init__()\n\n    @staticmethod\n    def prepare_from_flask_request(req):\n        url_data = urlparse(req.url)\n        return {\n            'http_host': req.host,\n            'server_port': url_data.port,\n            'script_name': req.path,\n            'get_data': req.args.copy(),\n            'post_data': req.form.copy(),\n            'https': (\"on\" if current_app.config.get(\"ONELOGIN_HTTPS\") else \"off\")\n    }\n\n    def get(self):\n        return self.post()\n\n    def _consumer(self, auth):\n        auth.process_response()\n        errors = auth.get_errors()\n        if not errors:\n            if auth.is_authenticated():\n                return True\n            else:\n                return False\n        else:\n            current_app.logger.error('Error processing %s' % (', '.join(errors)))\n            return False\n\n    def post(self):\n        if \"onelogin\" not in current_app.config.get(\"ACTIVE_PROVIDERS\"):\n            return \"Onelogin is not enabled in the config.  See the ACTIVE_PROVIDERS section.\", 404\n        auth = OneLogin_Saml2_Auth(self.req, current_app.config.get(\"ONELOGIN_SETTINGS\"))\n\n        self.reqparse.add_argument('return_to', required=False, default=current_app.config.get('WEB_PATH'))\n        self.reqparse.add_argument('acs', required=False)\n        self.reqparse.add_argument('sls', required=False)\n\n        args = self.reqparse.parse_args()\n\n        return_to = args['return_to']\n\n        if args['acs'] != None:\n            # valids the SAML response and checks if successfully authenticated\n            if self._consumer(auth):\n                email = auth.get_attribute(current_app.config.get(\"ONELOGIN_EMAIL_FIELD\"))[0]\n                user = User.query.filter(User.email == email).first()\n\n                # if we get an sso user create them an account\n                if not user:\n                    user = User(\n                        email=email,\n                        active=True,\n                        role=current_app.config.get('ONELOGIN_DEFAULT_ROLE')\n                        # profile_picture=profile.get('thumbnailPhotoUrl')\n                    )\n                    db.session.add(user)\n                    db.session.commit()\n                    db.session.refresh(user)\n\n                # Tell Flask-Principal the identity changed\n                identity_changed.send(current_app._get_current_object(), identity=Identity(user.id))\n                login_user(user)\n\n                self_url = OneLogin_Saml2_Utils.get_self_url(self.req)\n                if 'RelayState' in request.form and self_url != request.form['RelayState']:\n                    return redirect(auth.redirect_to(request.form['RelayState']), code=302)\n                else:  \n                    return redirect(current_app.config.get('BASE_URL'), code=302)\n            else:\n                return dict(message='OneLogin authentication failed.'), 403\n        elif args['sls'] != None:\n            return dict(message='OneLogin SLS not implemented yet.'), 405\n        else:\n            return redirect(auth.login(return_to=return_to))\n\n\nclass Providers(Resource):\n    decorators = [rbac.allow([\"anonymous\"], [\"GET\"])]\n    def __init__(self):\n        super(Providers, self).__init__()\n\n    def get(self):\n        active_providers = []\n\n        for provider in current_app.config.get(\"ACTIVE_PROVIDERS\"):\n            provider = provider.lower()\n\n            if provider == \"ping\":\n                active_providers.append({\n                    'name': current_app.config.get(\"PING_NAME\"),\n                    'url': current_app.config.get('PING_REDIRECT_URI'),\n                    'redirectUri': current_app.config.get(\"PING_REDIRECT_URI\"),\n                    'clientId': current_app.config.get(\"PING_CLIENT_ID\"),\n                    'responseType': 'code',\n                    'scope': ['openid', 'profile', 'email'],\n                    'scopeDelimiter': ' ',\n                    'authorizationEndpoint': current_app.config.get(\"PING_AUTH_ENDPOINT\"),\n                    'requiredUrlParams': ['scope'],\n                    'type': '2.0'\n                })\n            elif provider == \"google\":\n                google_provider = {\n                    'name': 'google',\n                    'clientId': current_app.config.get(\"GOOGLE_CLIENT_ID\"),\n                    'url': api.url_for(Google, _external=True, _scheme='https'),\n                    'redirectUri': api.url_for(Google, _external=True, _scheme='https'),\n                    'authorizationEndpoint': current_app.config.get(\"GOOGLE_AUTH_ENDPOINT\"),\n                    'scope': ['openid email'],\n                    'responseType': 'code'\n                }\n                google_hosted_domain = current_app.config.get(\"GOOGLE_HOSTED_DOMAIN\")\n                if google_hosted_domain is not None:\n                    google_provider['hd'] = google_hosted_domain\n                active_providers.append(google_provider)\n            elif provider == \"onelogin\":\n                active_providers.append({\n                    'name': 'OneLogin',\n                    'authorizationEndpoint': api.url_for(OneLogin)\n                })\n            else:\n                raise Exception(\"Unknown authentication provider: {0}\".format(provider))\n\n        return active_providers\n\n\napi.add_resource(Ping, '/auth/ping', endpoint='ping')\napi.add_resource(Google, '/auth/google', endpoint='google')\napi.add_resource(Providers, '/auth/providers', endpoint='providers')\n\nif onelogin_import_success:\n    api.add_resource(OneLogin, '/auth/onelogin', endpoint='onelogin')\n", "#     Copyright 2014 Netflix, Inc.\n#\n#     Licensed under the Apache License, Version 2.0 (the \"License\");\n#     you may not use this file except in compliance with the License.\n#     You may obtain a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#     Unless required by applicable law or agreed to in writing, software\n#     distributed under the License is distributed on an \"AS IS\" BASIS,\n#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#     See the License for the specific language governing permissions and\n#     limitations under the License.\n\nfrom security_monkey import app, db\nfrom flask_wtf.csrf import generate_csrf\nfrom security_monkey.auth.models import RBACRole\nfrom security_monkey.decorators import crossdomain\n\nfrom flask_restful import fields, marshal, Resource, reqparse\nfrom flask_login import current_user\n\nORIGINS = [\n    'https://{}:{}'.format(app.config.get('FQDN'), app.config.get('WEB_PORT')),\n    # Adding this next one so you can also access the dart UI by prepending /static to the path.\n    'https://{}:{}'.format(app.config.get('FQDN'), app.config.get('API_PORT')),\n    'https://{}:{}'.format(app.config.get('FQDN'), app.config.get('NGINX_PORT')),\n    'https://{}:80'.format(app.config.get('FQDN'))\n]\n\n##### Marshal Datastructures #####\n\n# Used by RevisionGet, RevisionList, ItemList\nREVISION_FIELDS = {\n    'id': fields.Integer,\n    'date_created': fields.String,\n    'date_last_ephemeral_change': fields.String,\n    'active': fields.Boolean,\n    'item_id': fields.Integer\n}\n\n# Used by RevisionList, ItemGet, ItemList\nITEM_FIELDS = {\n    'id': fields.Integer,\n    'region': fields.String,\n    'name': fields.String\n}\n\n# Used by ItemList, Justify\nAUDIT_FIELDS = {\n    'id': fields.Integer,\n    'score': fields.Integer,\n    'issue': fields.String,\n    'notes': fields.String,\n    'justified': fields.Boolean,\n    'justification': fields.String,\n    'justified_date': fields.String,\n    'item_id': fields.Integer\n}\n\n## Single Use Marshal Objects ##\n\n# SINGLE USE - RevisionGet\nREVISION_COMMENT_FIELDS = {\n    'id': fields.Integer,\n    'revision_id': fields.Integer,\n    'date_created': fields.String,\n    'text': fields.String\n}\n\n# SINGLE USE - ItemGet\nITEM_COMMENT_FIELDS = {\n    'id': fields.Integer,\n    'date_created': fields.String,\n    'text': fields.String,\n    'item_id': fields.Integer\n}\n\n# SINGLE USE - UserSettings\nUSER_SETTINGS_FIELDS = {\n    # 'id': fields.Integer,\n    'daily_audit_email': fields.Boolean,\n    'change_reports': fields.String\n}\n\n# SINGLE USE - AccountGet\nACCOUNT_FIELDS = {\n    'id': fields.Integer,\n    'name': fields.String,\n    'identifier': fields.String,\n    'notes': fields.String,\n    'active': fields.Boolean,\n    'third_party': fields.Boolean,\n    'account_type': fields.String\n}\n\nUSER_FIELDS = {\n    'id': fields.Integer,\n    'active': fields.Boolean,\n    'email': fields.String,\n    'role': fields.String,\n    'confirmed_at': fields.String,\n    'daily_audit_email': fields.Boolean,\n    'change_reports': fields.String,\n    'last_login_at': fields.String,\n    'current_login_at': fields.String,\n    'login_count': fields.Integer,\n    'last_login_ip': fields.String,\n    'current_login_ip': fields.String\n}\n\nROLE_FIELDS = {\n    'id': fields.Integer,\n    'name': fields.String,\n    'description': fields.String,\n}\n\nWHITELIST_FIELDS = {\n    'id': fields.Integer,\n    'name': fields.String,\n    'notes': fields.String,\n    'cidr': fields.String\n}\n\nIGNORELIST_FIELDS = {\n    'id': fields.Integer,\n    'prefix': fields.String,\n    'notes': fields.String,\n}\n\nAUDITORSETTING_FIELDS = {\n    'id': fields.Integer,\n    'disabled': fields.Boolean,\n    'issue_text': fields.String\n}\n\nITEM_LINK_FIELDS = {\n    'id': fields.Integer,\n    'name': fields.String\n}\n\nclass AuthenticatedService(Resource):\n    def __init__(self):\n        self.reqparse = reqparse.RequestParser()\n        super(AuthenticatedService, self).__init__()\n        self.auth_dict = dict()\n        if current_user.is_authenticated():\n            roles_marshal = []\n            for role in current_user.roles:\n                roles_marshal.append(marshal(role.__dict__, ROLE_FIELDS))\n\n            roles_marshal.append({\"name\": current_user.role})\n\n            for role in RBACRole.roles[current_user.role].get_parents():\n                roles_marshal.append({\"name\": role.name})\n\n            self.auth_dict = {\n                \"authenticated\": True,\n                \"user\": current_user.email,\n                \"roles\": roles_marshal\n            }\n        else:\n            if app.config.get('FRONTED_BY_NGINX'):\n                url = \"https://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('NGINX_PORT'), '/login')\n            else:\n                url = \"http://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('API_PORT'), '/login')\n            self.auth_dict = {\n                \"authenticated\": False,\n                \"user\": None,\n                \"url\": url\n            }\n\n\n@app.after_request\n@crossdomain(allowed_origins=ORIGINS)\ndef after(response):\n    response.set_cookie('XSRF-COOKIE', generate_csrf())\n    return response\n", "#     Copyright 2014 Netflix, Inc.\n#\n#     Licensed under the Apache License, Version 2.0 (the \"License\");\n#     you may not use this file except in compliance with the License.\n#     You may obtain a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#     Unless required by applicable law or agreed to in writing, software\n#     distributed under the License is distributed on an \"AS IS\" BASIS,\n#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#     See the License for the specific language governing permissions and\n#     limitations under the License.\n\nfrom flask_login import current_user, logout_user\nfrom flask_restful import Resource\n\n\n# End the Flask-Logins session\nfrom security_monkey import rbac\n\n\nclass Logout(Resource):\n\n    decorators = [rbac.exempt]\n\n    def get(self):\n        if not current_user.is_authenticated():\n            return \"Must be logged in to log out\", 200\n\n        logout_user()\n        return \"Logged Out\", 200\n", "#     Copyright 2014 Netflix, Inc.\n#\n#     Licensed under the Apache License, Version 2.0 (the \"License\");\n#     you may not use this file except in compliance with the License.\n#     You may obtain a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#     Unless required by applicable law or agreed to in writing, software\n#     distributed under the License is distributed on an \"AS IS\" BASIS,\n#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#     See the License for the specific language governing permissions and\n#     limitations under the License.\nfrom setuptools import setup\n\nsetup(\n    name='security_monkey',\n    version='0.8.0',\n    long_description=__doc__,\n    packages=['security_monkey'],\n    include_package_data=True,\n    zip_safe=False,\n    install_requires=[\n        'APScheduler==2.1.2',\n        'Flask==0.10.1',\n        'Flask-Login==0.2.10',\n        'Flask-Mail==0.9.0',\n        'Flask-Migrate==1.3.1',\n        'Flask-Principal==0.4.0',\n        'Flask-RESTful==0.3.3',\n        'Flask-SQLAlchemy==1.0',\n        'Flask-Script==0.6.3',\n        'Flask-Security==1.7.4',\n        'Flask-WTF==0.9.5',\n        'Jinja2==2.8',\n        'SQLAlchemy==0.9.2',\n        'boto>=2.41.0',\n        'ipaddr==2.1.11',\n        'itsdangerous==0.23',\n        'psycopg2==2.5.2',\n        'bcrypt==2.0.0',\n        'Sphinx==1.2.2',\n        'gunicorn==18.0',\n        'cryptography==1.3.2',\n        'boto3>=1.4.2',\n        'botocore>=1.4.81',\n        'dpath==1.3.2',\n        'pyyaml==3.11',\n        'jira==0.32',\n        'cloudaux>=1.0.6',\n        'joblib>=0.9.4',\n        'pyjwt>=1.01',\n    ],\n    extras_require = {\n        'onelogin': ['python-saml>=2.2.0'],\n        'tests': [\n            'nose==1.3.0',\n            'mock==1.0.1',\n            'moto==0.4.30',\n            'freezegun>=0.3.7'\n        ]\n    }\n)\n"], "fixing_code": ["import itertools\n\nfrom flask import request, abort, _app_ctx_stack, redirect\nfrom flask_security.core import AnonymousUser\nfrom security_monkey.datastore import User\n\ntry:\n    from flask.ext.login import current_user\nexcept ImportError:\n    current_user = None\n\nfrom .models import RBACRole, RBACUserMixin\n\nfrom . import anonymous\n\nfrom flask import Response\nimport json\n\n\nclass AccessControlList(object):\n    \"\"\"\n    This class record rules for access controling.\n    \"\"\"\n\n    def __init__(self):\n        self._allowed = []\n        self._exempt = []\n        self.seted = False\n\n    def allow(self, role, method, resource, with_children=True):\n        \"\"\"Add allowing rules.\n\n        :param role: Role of this rule.\n        :param method: Method to allow in rule, include GET, POST, PUT etc.\n        :param resource: Resource also view function.\n        :param with_children: Allow role's children in rule as well\n                              if with_children is `True`\n        \"\"\"\n\n        if with_children:\n            for r in role.get_children():\n                permission = (r.name, method, resource)\n                if permission not in self._allowed:\n                    self._allowed.append(permission)\n        permission = (role.name, method, resource)\n        if permission not in self._allowed:\n            self._allowed.append(permission)\n\n    def exempt(self, view_func):\n        \"\"\"Exempt a view function from being checked permission\n\n        :param view_func: The view function exempt from checking.\n        \"\"\"\n        if not view_func in self._exempt:\n            self._exempt.append(view_func)\n\n    def is_allowed(self, role, method, resource):\n        \"\"\"Check whether role is allowed to access resource\n\n        :param role: Role to be checked.\n        :param method: Method to be checked.\n        :param resource: View function to be checked.\n        \"\"\"\n        return (role, method, resource) in self._allowed\n\n    def is_exempt(self, view_func):\n        \"\"\"Return whether view_func is exempted.\n\n        :param view_func: View function to be checked.\n        \"\"\"\n        return view_func in self._exempt\n\n\nclass _RBACState(object):\n    \"\"\"Records configuration for Flask-RBAC\"\"\"\n    def __init__(self, rbac, app):\n        self.rbac = rbac\n        self.app = app\n\n\nclass RBAC(object):\n    \"\"\"\n    This class implements role-based access control module in Flask.\n    There are two way to initialize Flask-RBAC::\n\n        app = Flask(__name__)\n        rbac = RBAC(app)\n\n    :param app: the Flask object\n    \"\"\"\n\n    _role_model = RBACRole\n    _user_model = RBACUserMixin\n\n    def __init__(self, app):\n        self.acl = AccessControlList()\n        self.before_acl = []\n\n        self.app = app\n        self.init_app(app)\n\n    def init_app(self, app):\n        # Add (RBAC, app) to flask extensions.\n        # Add hook to authenticate permission before request.\n\n        if not hasattr(app, 'extensions'):\n            app.extensions = {}\n        app.extensions['rbac'] = _RBACState(self, app)\n\n        self.acl.allow(anonymous, 'GET', app.view_functions['static'].__name__)\n        app.before_first_request(self._setup_acl)\n        app.before_request(self._authenticate)\n\n    def has_permission(self, method, endpoint, user=None):\n        \"\"\"Return whether the current user can access the resource.\n        Example::\n\n            @app.route('/some_url', methods=['GET', 'POST'])\n            @rbac.allow(['anonymous'], ['GET'])\n            def a_view_func():\n                return Response('Blah Blah...')\n\n        If you are not logged.\n\n        `rbac.has_permission('GET', 'a_view_func')` return True.\n        `rbac.has_permission('POST', 'a_view_func')` return False.\n\n        :param method: The method wait to check.\n        :param endpoint: The application endpoint.\n        :param user: user who you need to check. Current user by default.\n        \"\"\"\n        app = self.get_app()\n        _user = user or current_user\n        roles = _user.get_roles()\n        view_func = app.view_functions[endpoint]\n        return self._check_permission(roles, method, view_func)\n\n    def check_perm(self, role, method, callback=None):\n        def decorator(view_func):\n            if not self._check_permission([role], method, view_func):\n                if callable(callback):\n                    callback()\n                else:\n                    self._deny_hook()\n            return view_func\n        return decorator\n\n    def allow(self, roles, methods, with_children=True):\n        \"\"\"Decorator: allow roles to access the view func with it.\n\n        :param roles: List, each name of roles. Please note that,\n                      `anonymous` is refered to anonymous.\n                      If you add `anonymous` to the rule,\n                      everyone can access the resource,\n                      unless you deny other roles.\n        :param methods: List, each name of methods.\n                        methods is valid in ['GET', 'POST', 'PUT', 'DELETE']\n        :param with_children: Whether allow children of roles as well.\n                              True by default.\n        \"\"\"\n        def decorator(view_func):\n            _methods = [m.upper() for m in methods]\n            for r, m, v in itertools.product(roles, _methods, [view_func.__name__]):\n                self.before_acl.append((r, m, v, with_children))\n            return view_func\n        return decorator\n\n    def exempt(self, view_func):\n        \"\"\"\n        Decorator function\n        Exempt a view function from being checked permission.\n        \"\"\"\n        self.acl.exempt(view_func.__name__)\n        return view_func\n\n    def get_app(self, reference_app=None):\n        \"\"\"\n        Helper to look up an app.\n        \"\"\"\n        if reference_app is not None:\n            return reference_app\n        if self.app is not None:\n            return self.app\n        ctx = _app_ctx_stack.top\n        if ctx is not None:\n            return ctx.app\n        raise RuntimeError('application not registered on rbac '\n                           'instance and no application bound '\n                           'to current context')\n\n    def _authenticate(self):\n        app = self.get_app()\n        assert app, \"Please initialize your application into Flask-RBAC.\"\n        assert self._role_model, \"Please set role model before authenticate.\"\n        assert self._user_model, \"Please set user model before authenticate.\"\n        user = current_user\n        if not isinstance(user._get_current_object(), self._user_model) and not isinstance(user._get_current_object(), AnonymousUser):\n            raise TypeError(\n                \"%s is not an instance of %s\" %\n                (user, self._user_model.__class__))\n\n        endpoint = request.endpoint\n        resource = app.view_functions.get(endpoint, None)\n\n        if not resource:\n            abort(404)\n\n        method = request.method\n        if not hasattr(user, 'get_roles'):\n            roles = [anonymous]\n        else:\n            roles = user.get_roles()\n\n        permit = self._check_permission(roles, method, resource)\n        if not permit:\n            return self._deny_hook(resource=resource)\n\n    def _check_permission(self, roles, method, resource):\n\n        resource = resource.__name__\n        if self.acl.is_exempt(resource):\n            return True\n\n        if not self.acl.seted:\n            self._setup_acl()\n\n        _roles = set()\n        _methods = {'*', method}\n        _resources = {None, resource}\n\n        _roles.add(anonymous)\n\n        _roles.update(roles)\n\n        for r, m, res in itertools.product(_roles, _methods, _resources):\n            if self.acl.is_allowed(r.name, m, res):\n                return True\n\n        return False\n\n    def _deny_hook(self, resource=None):\n        app = self.get_app()\n        if current_user.is_authenticated:\n            status = 403\n        else:\n            status = 401\n        #abort(status)\n\n        if app.config.get('FRONTED_BY_NGINX'):\n                url = \"https://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('NGINX_PORT'), '/login')\n        else:\n                url = \"http://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('API_PORT'), '/login')\n        if current_user.is_authenticated:\n            auth_dict = {\n                \"authenticated\": True,\n                \"user\": current_user.email,\n                \"roles\": current_user.role,\n            }\n        else:\n            auth_dict = {\n                \"authenticated\": False,\n                \"user\": None,\n                \"url\": url\n            }\n\n        return Response(response=json.dumps({\"auth\": auth_dict}), status=status, mimetype=\"application/json\")\n\n\n    def _setup_acl(self):\n        for rn, method, resource, with_children in self.before_acl:\n            role = self._role_model.get_by_name(rn)\n            self.acl.allow(role, method, resource, with_children)\n        self.acl.seted = True\n", "\"\"\"\n.. module: security_monkey.sso.views\n    :platform: Unix\n    :copyright: (c) 2015 by Netflix Inc., see AUTHORS for more\n    :license: Apache, see LICENSE for more details.\n.. moduleauthor:: Patrick Kelley <patrick@netflix.com>\n\"\"\"\nimport jwt\nimport base64\nimport requests\n\nfrom flask import Blueprint, current_app, redirect, request\n\nfrom flask.ext.restful import reqparse, Resource, Api\nfrom flask.ext.principal import Identity, identity_changed\nfrom flask_security.utils import login_user\n\ntry:\n    from onelogin.saml2.auth import OneLogin_Saml2_Auth\n    from onelogin.saml2.utils import OneLogin_Saml2_Utils\n    onelogin_import_success = True\nexcept ImportError:\n    onelogin_import_success = False\n\nfrom .service import fetch_token_header_payload, get_rsa_public_key\n\nfrom security_monkey.datastore import User\nfrom security_monkey import db, rbac\n\nfrom urlparse import urlparse\n\nmod = Blueprint('sso', __name__)\napi = Api(mod)\n\n\nfrom flask_security.utils import validate_redirect_url\n\n\nclass Ping(Resource):\n    \"\"\"\n    This class serves as an example of how one might implement an SSO provider for use with Security Monkey. In\n    this example we use a OpenIDConnect authentication flow, that is essentially OAuth2 underneath.\n    \"\"\"\n    decorators = [rbac.allow([\"anonymous\"], [\"GET\", \"POST\"])]\n    def __init__(self):\n        self.reqparse = reqparse.RequestParser()\n        super(Ping, self).__init__()\n\n    def get(self):\n        return self.post()\n\n    def post(self):\n        if \"ping\" not in current_app.config.get(\"ACTIVE_PROVIDERS\"):\n            return \"Ping is not enabled in the config.  See the ACTIVE_PROVIDERS section.\", 404\n\n        default_state = 'clientId,{client_id},redirectUri,{redirectUri},return_to,{return_to}'.format(\n            client_id=current_app.config.get('PING_CLIENT_ID'),\n            redirectUri=current_app.config.get('PING_REDIRECT_URI'),\n            return_to=current_app.config.get('WEB_PATH')\n        )\n        self.reqparse.add_argument('code', type=str, required=True)\n        self.reqparse.add_argument('state', type=str, required=False, default=default_state)\n\n        args = self.reqparse.parse_args()\n        client_id = args['state'].split(',')[1]\n        redirect_uri = args['state'].split(',')[3]\n        return_to = args['state'].split(',')[5]\n\n        if not validate_redirect_url(return_to):\n            return_to = current_app.config.get('WEB_PATH')\n\n        # take the information we have received from the provider to create a new request\n        params = {\n            'client_id': client_id,\n            'grant_type': 'authorization_code',\n            'scope': 'openid email profile address',\n            'redirect_uri': redirect_uri,\n            'code': args['code']\n        }\n\n        # you can either discover these dynamically or simply configure them\n        access_token_url = current_app.config.get('PING_ACCESS_TOKEN_URL')\n        user_api_url = current_app.config.get('PING_USER_API_URL')\n\n        # the secret and cliendId will be given to you when you signup for the provider\n        basic = base64.b64encode(bytes('{0}:{1}'.format(client_id, current_app.config.get(\"PING_SECRET\"))))\n        headers = {'Authorization': 'Basic {0}'.format(basic.decode('utf-8'))}\n\n        # exchange authorization code for access token.\n        r = requests.post(access_token_url, headers=headers, params=params)\n        id_token = r.json()['id_token']\n        access_token = r.json()['access_token']\n\n        # fetch token public key\n        header_data = fetch_token_header_payload(id_token)[0]\n        jwks_url = current_app.config.get('PING_JWKS_URL')\n\n        # retrieve the key material as specified by the token header\n        r = requests.get(jwks_url)\n        for key in r.json()['keys']:\n            if key['kid'] == header_data['kid']:\n                secret = get_rsa_public_key(key['n'], key['e'])\n                algo = header_data['alg']\n                break\n        else:\n            return dict(message='Key not found'), 403\n\n        # validate your token based on the key it was signed with\n        try:\n            current_app.logger.debug(id_token)\n            current_app.logger.debug(secret)\n            current_app.logger.debug(algo)\n            jwt.decode(id_token, secret.decode('utf-8'), algorithms=[algo], audience=client_id)\n        except jwt.DecodeError:\n            return dict(message='Token is invalid'), 403\n        except jwt.ExpiredSignatureError:\n            return dict(message='Token has expired'), 403\n        except jwt.InvalidTokenError:\n            return dict(message='Token is invalid'), 403\n\n        user_params = dict(access_token=access_token, schema='profile')\n\n        # retrieve information about the current user.\n        r = requests.get(user_api_url, params=user_params)\n        profile = r.json()\n\n        user = User.query.filter(User.email==profile['email']).first()\n\n        # if we get an sso user create them an account\n        if not user:\n            user = User(\n                email=profile['email'],\n                active=True,\n                role='View'\n                # profile_picture=profile.get('thumbnailPhotoUrl')\n            )\n            db.session.add(user)\n            db.session.commit()\n            db.session.refresh(user)\n\n        # Tell Flask-Principal the identity changed\n        identity_changed.send(current_app._get_current_object(), identity=Identity(user.id))\n        login_user(user)\n\n        return redirect(return_to, code=302)\n\n\nclass Google(Resource):\n    decorators = [rbac.allow([\"anonymous\"], [\"GET\", \"POST\"])]\n    def __init__(self):\n        self.reqparse = reqparse.RequestParser()\n        super(Google, self).__init__()\n\n    def get(self):\n        return self.post()\n\n    def post(self):\n        if \"google\" not in current_app.config.get(\"ACTIVE_PROVIDERS\"):\n            return \"Google is not enabled in the config.  See the ACTIVE_PROVIDERS section.\", 404\n\n        default_state = 'clientId,{client_id},redirectUri,{redirectUri},return_to,{return_to}'.format(\n            client_id=current_app.config.get(\"GOOGLE_CLIENT_ID\"),\n            redirectUri=api.url_for(Google),\n            return_to=current_app.config.get('WEB_PATH')\n        )\n        self.reqparse.add_argument('code', type=str, required=True)\n        self.reqparse.add_argument('state', type=str, required=False, default=default_state)\n\n        args = self.reqparse.parse_args()\n        client_id = args['state'].split(',')[1]\n        redirect_uri = args['state'].split(',')[3]\n        return_to = args['state'].split(',')[5]\n\n        if not validate_redirect_url(return_to):\n            return_to = current_app.config.get('WEB_PATH')\n\n        access_token_url = 'https://accounts.google.com/o/oauth2/token'\n        people_api_url = 'https://www.googleapis.com/plus/v1/people/me/openIdConnect'\n\n        args = self.reqparse.parse_args()\n\n        # Step 1. Exchange authorization code for access token\n        payload = {\n            'client_id': client_id,\n            'grant_type': 'authorization_code',\n            'redirect_uri': redirect_uri,\n            'code': args['code'],\n            'client_secret': current_app.config.get('GOOGLE_SECRET')\n        }\n\n        r = requests.post(access_token_url, data=payload)\n        token = r.json()\n\n        # Step 1bis. Validate (some information of) the id token (if necessary)\n        google_hosted_domain = current_app.config.get(\"GOOGLE_HOSTED_DOMAIN\")\n        if google_hosted_domain is not None:\n            current_app.logger.debug('We need to verify that the token was issued for this hosted domain: %s ' % (google_hosted_domain))\n\n\t    # Get the JSON Web Token\n            id_token = r.json()['id_token']\n            current_app.logger.debug('The id_token is: %s' % (id_token))\n\n            # Extract the payload\n            (header_data, payload_data) = fetch_token_header_payload(id_token)\n            current_app.logger.debug('id_token.header_data: %s' % (header_data))\n            current_app.logger.debug('id_token.payload_data: %s' % (payload_data))\n\n            token_hd = payload_data.get('hd')\n            if token_hd != google_hosted_domain:\n                current_app.logger.debug('Verification failed: %s != %s' % (token_hd, google_hosted_domain))\n                return dict(message='Token is invalid %s' % token), 403\n            current_app.logger.debug('Verification passed')\n\n        # Step 2. Retrieve information about the current user\n        headers = {'Authorization': 'Bearer {0}'.format(token['access_token'])}\n\n        r = requests.get(people_api_url, headers=headers)\n        profile = r.json()\n\n        user = User.query.filter(User.email == profile['email']).first()\n\n        # if we get an sso user create them an account\n        if not user:\n            user = User(\n                email=profile['email'],\n                active=True,\n                role='View'\n                # profile_picture=profile.get('thumbnailPhotoUrl')\n            )\n            db.session.add(user)\n            db.session.commit()\n            db.session.refresh(user)\n\n        # Tell Flask-Principal the identity changed\n        identity_changed.send(current_app._get_current_object(), identity=Identity(user.id))\n        login_user(user)\n\n        return redirect(return_to, code=302)\n\n\nclass OneLogin(Resource):\n    decorators = [rbac.allow([\"anonymous\"], [\"GET\", \"POST\"])]\n    def __init__(self):\n        self.reqparse = reqparse.RequestParser()\n        self.req = OneLogin.prepare_from_flask_request(request)\n        super(OneLogin, self).__init__()\n\n    @staticmethod\n    def prepare_from_flask_request(req):\n        url_data = urlparse(req.url)\n        return {\n            'http_host': req.host,\n            'server_port': url_data.port,\n            'script_name': req.path,\n            'get_data': req.args.copy(),\n            'post_data': req.form.copy(),\n            'https': (\"on\" if current_app.config.get(\"ONELOGIN_HTTPS\") else \"off\")\n    }\n\n    def get(self):\n        return self.post()\n\n    def _consumer(self, auth):\n        auth.process_response()\n        errors = auth.get_errors()\n        if not errors:\n            if auth.is_authenticated:\n                return True\n            else:\n                return False\n        else:\n            current_app.logger.error('Error processing %s' % (', '.join(errors)))\n            return False\n\n    def post(self):\n        if \"onelogin\" not in current_app.config.get(\"ACTIVE_PROVIDERS\"):\n            return \"Onelogin is not enabled in the config.  See the ACTIVE_PROVIDERS section.\", 404\n        auth = OneLogin_Saml2_Auth(self.req, current_app.config.get(\"ONELOGIN_SETTINGS\"))\n\n        self.reqparse.add_argument('return_to', required=False, default=current_app.config.get('WEB_PATH'))\n        self.reqparse.add_argument('acs', required=False)\n        self.reqparse.add_argument('sls', required=False)\n\n        args = self.reqparse.parse_args()\n\n        return_to = args['return_to']\n\n        if args['acs'] != None:\n            # valids the SAML response and checks if successfully authenticated\n            if self._consumer(auth):\n                email = auth.get_attribute(current_app.config.get(\"ONELOGIN_EMAIL_FIELD\"))[0]\n                user = User.query.filter(User.email == email).first()\n\n                # if we get an sso user create them an account\n                if not user:\n                    user = User(\n                        email=email,\n                        active=True,\n                        role=current_app.config.get('ONELOGIN_DEFAULT_ROLE')\n                        # profile_picture=profile.get('thumbnailPhotoUrl')\n                    )\n                    db.session.add(user)\n                    db.session.commit()\n                    db.session.refresh(user)\n\n                # Tell Flask-Principal the identity changed\n                identity_changed.send(current_app._get_current_object(), identity=Identity(user.id))\n                login_user(user)\n\n                self_url = OneLogin_Saml2_Utils.get_self_url(self.req)\n                if 'RelayState' in request.form and self_url != request.form['RelayState']:\n                    return redirect(auth.redirect_to(request.form['RelayState']), code=302)\n                else:  \n                    return redirect(current_app.config.get('BASE_URL'), code=302)\n            else:\n                return dict(message='OneLogin authentication failed.'), 403\n        elif args['sls'] != None:\n            return dict(message='OneLogin SLS not implemented yet.'), 405\n        else:\n            return redirect(auth.login(return_to=return_to))\n\n\nclass Providers(Resource):\n    decorators = [rbac.allow([\"anonymous\"], [\"GET\"])]\n    def __init__(self):\n        super(Providers, self).__init__()\n\n    def get(self):\n        active_providers = []\n\n        for provider in current_app.config.get(\"ACTIVE_PROVIDERS\"):\n            provider = provider.lower()\n\n            if provider == \"ping\":\n                active_providers.append({\n                    'name': current_app.config.get(\"PING_NAME\"),\n                    'url': current_app.config.get('PING_REDIRECT_URI'),\n                    'redirectUri': current_app.config.get(\"PING_REDIRECT_URI\"),\n                    'clientId': current_app.config.get(\"PING_CLIENT_ID\"),\n                    'responseType': 'code',\n                    'scope': ['openid', 'profile', 'email'],\n                    'scopeDelimiter': ' ',\n                    'authorizationEndpoint': current_app.config.get(\"PING_AUTH_ENDPOINT\"),\n                    'requiredUrlParams': ['scope'],\n                    'type': '2.0'\n                })\n            elif provider == \"google\":\n                google_provider = {\n                    'name': 'google',\n                    'clientId': current_app.config.get(\"GOOGLE_CLIENT_ID\"),\n                    'url': api.url_for(Google, _external=True, _scheme='https'),\n                    'redirectUri': api.url_for(Google, _external=True, _scheme='https'),\n                    'authorizationEndpoint': current_app.config.get(\"GOOGLE_AUTH_ENDPOINT\"),\n                    'scope': ['openid email'],\n                    'responseType': 'code'\n                }\n                google_hosted_domain = current_app.config.get(\"GOOGLE_HOSTED_DOMAIN\")\n                if google_hosted_domain is not None:\n                    google_provider['hd'] = google_hosted_domain\n                active_providers.append(google_provider)\n            elif provider == \"onelogin\":\n                active_providers.append({\n                    'name': 'OneLogin',\n                    'authorizationEndpoint': api.url_for(OneLogin)\n                })\n            else:\n                raise Exception(\"Unknown authentication provider: {0}\".format(provider))\n\n        return active_providers\n\n\napi.add_resource(Ping, '/auth/ping', endpoint='ping')\napi.add_resource(Google, '/auth/google', endpoint='google')\napi.add_resource(Providers, '/auth/providers', endpoint='providers')\n\nif onelogin_import_success:\n    api.add_resource(OneLogin, '/auth/onelogin', endpoint='onelogin')\n", "#     Copyright 2014 Netflix, Inc.\n#\n#     Licensed under the Apache License, Version 2.0 (the \"License\");\n#     you may not use this file except in compliance with the License.\n#     You may obtain a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#     Unless required by applicable law or agreed to in writing, software\n#     distributed under the License is distributed on an \"AS IS\" BASIS,\n#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#     See the License for the specific language governing permissions and\n#     limitations under the License.\n\nfrom security_monkey import app, db\nfrom flask_wtf.csrf import generate_csrf\nfrom security_monkey.auth.models import RBACRole\nfrom security_monkey.decorators import crossdomain\n\nfrom flask_restful import fields, marshal, Resource, reqparse\nfrom flask_login import current_user\n\nORIGINS = [\n    'https://{}:{}'.format(app.config.get('FQDN'), app.config.get('WEB_PORT')),\n    # Adding this next one so you can also access the dart UI by prepending /static to the path.\n    'https://{}:{}'.format(app.config.get('FQDN'), app.config.get('API_PORT')),\n    'https://{}:{}'.format(app.config.get('FQDN'), app.config.get('NGINX_PORT')),\n    'https://{}:80'.format(app.config.get('FQDN'))\n]\n\n##### Marshal Datastructures #####\n\n# Used by RevisionGet, RevisionList, ItemList\nREVISION_FIELDS = {\n    'id': fields.Integer,\n    'date_created': fields.String,\n    'date_last_ephemeral_change': fields.String,\n    'active': fields.Boolean,\n    'item_id': fields.Integer\n}\n\n# Used by RevisionList, ItemGet, ItemList\nITEM_FIELDS = {\n    'id': fields.Integer,\n    'region': fields.String,\n    'name': fields.String\n}\n\n# Used by ItemList, Justify\nAUDIT_FIELDS = {\n    'id': fields.Integer,\n    'score': fields.Integer,\n    'issue': fields.String,\n    'notes': fields.String,\n    'justified': fields.Boolean,\n    'justification': fields.String,\n    'justified_date': fields.String,\n    'item_id': fields.Integer\n}\n\n## Single Use Marshal Objects ##\n\n# SINGLE USE - RevisionGet\nREVISION_COMMENT_FIELDS = {\n    'id': fields.Integer,\n    'revision_id': fields.Integer,\n    'date_created': fields.String,\n    'text': fields.String\n}\n\n# SINGLE USE - ItemGet\nITEM_COMMENT_FIELDS = {\n    'id': fields.Integer,\n    'date_created': fields.String,\n    'text': fields.String,\n    'item_id': fields.Integer\n}\n\n# SINGLE USE - UserSettings\nUSER_SETTINGS_FIELDS = {\n    # 'id': fields.Integer,\n    'daily_audit_email': fields.Boolean,\n    'change_reports': fields.String\n}\n\n# SINGLE USE - AccountGet\nACCOUNT_FIELDS = {\n    'id': fields.Integer,\n    'name': fields.String,\n    'identifier': fields.String,\n    'notes': fields.String,\n    'active': fields.Boolean,\n    'third_party': fields.Boolean,\n    'account_type': fields.String\n}\n\nUSER_FIELDS = {\n    'id': fields.Integer,\n    'active': fields.Boolean,\n    'email': fields.String,\n    'role': fields.String,\n    'confirmed_at': fields.String,\n    'daily_audit_email': fields.Boolean,\n    'change_reports': fields.String,\n    'last_login_at': fields.String,\n    'current_login_at': fields.String,\n    'login_count': fields.Integer,\n    'last_login_ip': fields.String,\n    'current_login_ip': fields.String\n}\n\nROLE_FIELDS = {\n    'id': fields.Integer,\n    'name': fields.String,\n    'description': fields.String,\n}\n\nWHITELIST_FIELDS = {\n    'id': fields.Integer,\n    'name': fields.String,\n    'notes': fields.String,\n    'cidr': fields.String\n}\n\nIGNORELIST_FIELDS = {\n    'id': fields.Integer,\n    'prefix': fields.String,\n    'notes': fields.String,\n}\n\nAUDITORSETTING_FIELDS = {\n    'id': fields.Integer,\n    'disabled': fields.Boolean,\n    'issue_text': fields.String\n}\n\nITEM_LINK_FIELDS = {\n    'id': fields.Integer,\n    'name': fields.String\n}\n\nclass AuthenticatedService(Resource):\n    def __init__(self):\n        self.reqparse = reqparse.RequestParser()\n        super(AuthenticatedService, self).__init__()\n        self.auth_dict = dict()\n        if current_user.is_authenticated:\n            roles_marshal = []\n            for role in current_user.roles:\n                roles_marshal.append(marshal(role.__dict__, ROLE_FIELDS))\n\n            roles_marshal.append({\"name\": current_user.role})\n\n            for role in RBACRole.roles[current_user.role].get_parents():\n                roles_marshal.append({\"name\": role.name})\n\n            self.auth_dict = {\n                \"authenticated\": True,\n                \"user\": current_user.email,\n                \"roles\": roles_marshal\n            }\n        else:\n            if app.config.get('FRONTED_BY_NGINX'):\n                url = \"https://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('NGINX_PORT'), '/login')\n            else:\n                url = \"http://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('API_PORT'), '/login')\n            self.auth_dict = {\n                \"authenticated\": False,\n                \"user\": None,\n                \"url\": url\n            }\n\n\n@app.after_request\n@crossdomain(allowed_origins=ORIGINS)\ndef after(response):\n    response.set_cookie('XSRF-COOKIE', generate_csrf())\n    return response\n", "#     Copyright 2014 Netflix, Inc.\n#\n#     Licensed under the Apache License, Version 2.0 (the \"License\");\n#     you may not use this file except in compliance with the License.\n#     You may obtain a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#     Unless required by applicable law or agreed to in writing, software\n#     distributed under the License is distributed on an \"AS IS\" BASIS,\n#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#     See the License for the specific language governing permissions and\n#     limitations under the License.\n\nfrom flask_login import current_user, logout_user\nfrom flask_restful import Resource\n\n\n# End the Flask-Logins session\nfrom security_monkey import rbac\n\n\nclass Logout(Resource):\n\n    decorators = [rbac.exempt]\n\n    def get(self):\n        if not current_user.is_authenticated:\n            return \"Must be logged in to log out\", 200\n\n        logout_user()\n        return \"Logged Out\", 200\n", "#     Copyright 2014 Netflix, Inc.\n#\n#     Licensed under the Apache License, Version 2.0 (the \"License\");\n#     you may not use this file except in compliance with the License.\n#     You may obtain a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#     Unless required by applicable law or agreed to in writing, software\n#     distributed under the License is distributed on an \"AS IS\" BASIS,\n#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#     See the License for the specific language governing permissions and\n#     limitations under the License.\nfrom setuptools import setup\n\nsetup(\n    name='security_monkey',\n    version='0.8.0',\n    long_description=__doc__,\n    packages=['security_monkey'],\n    include_package_data=True,\n    zip_safe=False,\n    install_requires=[\n        'APScheduler==2.1.2',\n        'Flask==0.10.1',\n        'Flask-Mail==0.9.0',\n        'Flask-Migrate==1.3.1',\n        'Flask-Principal==0.4.0',\n        'Flask-RESTful==0.3.3',\n        'Flask-SQLAlchemy==1.0',\n        'Flask-Script==0.6.3',\n        # 'Flask-Security==1.7.4',\n        'Flask-Security-Fork==1.8.2',\n        'Jinja2==2.8',\n        'SQLAlchemy==0.9.2',\n        'boto>=2.41.0',\n        'ipaddr==2.1.11',\n        'itsdangerous==0.23',\n        'psycopg2==2.6.2',\n        'bcrypt==3.1.2',\n        'Sphinx==1.2.2',\n        'gunicorn==18.0',\n        'cryptography==1.7.1',\n        'boto3>=1.4.2',\n        'botocore>=1.4.81',\n        'dpath==1.3.2',\n        'pyyaml==3.11',\n        'jira==0.32',\n        'cloudaux>=1.0.6',\n        'joblib>=0.9.4',\n        'pyjwt>=1.01',\n    ],\n    extras_require = {\n        'onelogin': ['python-saml>=2.2.0'],\n        'tests': [\n            'nose==1.3.0',\n            'mock==1.0.1',\n            'moto==0.4.30',\n            'freezegun>=0.3.7'\n        ]\n    }\n)\n"], "filenames": ["security_monkey/auth/modules.py", "security_monkey/sso/views.py", "security_monkey/views/__init__.py", "security_monkey/views/logout.py", "setup.py"], "buggy_code_start_loc": [243, 16, 147, 28, 26], "buggy_code_end_loc": [254, 268, 148, 29, 45], "fixing_code_start_loc": [243, 16, 147, 28, 25], "fixing_code_end_loc": [254, 268, 148, 29, 44], "type": "CWE-601", "message": "Netflix Security Monkey before 0.8.0 has an Open Redirect. The logout functionality accepted the \"next\" parameter which then redirects to any domain irrespective of the Host header.", "other": {"cve": {"id": "CVE-2017-7266", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-26T05:59:00.273", "lastModified": "2017-03-29T01:59:03.110", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Netflix Security Monkey before 0.8.0 has an Open Redirect. The logout functionality accepted the \"next\" parameter which then redirects to any domain irrespective of the Host header."}, {"lang": "es", "value": "Netflix Security Monkey en versiones anteriores a 0.8.0 tiene un Open Redirect. La funcionalidad de cierre de sesi\u00f3n acept\u00f3 el par\u00e1metro \"next\" que entonces redirige a cualquier dominio independientemente del encabezado del Host."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netflix:security_monkey:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.7.0", "matchCriteriaId": "52BCA67D-B627-4797-97BA-B371B3A859F8"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/97088", "source": "cve@mitre.org"}, {"url": "https://github.com/Netflix/security_monkey/commit/3b4da13efabb05970c80f464a50d3c1c12262466", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Netflix/security_monkey/pull/482", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/Netflix/security_monkey/releases/tag/v0.8.0", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Netflix/security_monkey/commit/3b4da13efabb05970c80f464a50d3c1c12262466"}}