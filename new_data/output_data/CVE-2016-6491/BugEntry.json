{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%            PPPP    RRRR    OOO   PPPP   EEEEE  RRRR   TTTTT  Y   Y          %\n%            P   P   R   R  O   O  P   P  E      R   R    T     Y Y           %\n%            PPPP    RRRR   O   O  PPPP   EEE    RRRR     T      Y            %\n%            P       R R    O   O  P      E      R R      T      Y            %\n%            P       R  R    OOO   P      EEEEE  R  R     T      Y            %\n%                                                                             %\n%                                                                             %\n%                         MagickCore Property Methods                         %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 March 2000                                  %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-private.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/compare.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/effect.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/fx.h\"\n#include \"MagickCore/fx-private.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/histogram.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/layer.h\"\n#include \"MagickCore/locale-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/montage.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/policy.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/signature.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/token-private.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n#include \"MagickCore/version.h\"\n#include \"MagickCore/xml-tree.h\"\n#include \"MagickCore/xml-tree-private.h\"\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n#if defined(MAGICKCORE_HAVE_LCMS2_LCMS2_H)\n#include <lcms2/lcms2.h>\n#elif defined(MAGICKCORE_HAVE_LCMS2_H)\n#include \"lcms2.h\"\n#elif defined(MAGICKCORE_HAVE_LCMS_LCMS_H)\n#include <lcms/lcms.h>\n#else\n#include \"lcms.h\"\n#endif\n#endif\n\f\n/*\n  Define declarations.\n*/\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n#if defined(LCMS_VERSION) && (LCMS_VERSION < 2000)\n#define cmsUInt32Number  DWORD\n#endif\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l o n e I m a g e P r o p e r t i e s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CloneImageProperties() clones all the image properties to another image.\n%\n%  The format of the CloneImageProperties method is:\n%\n%      MagickBooleanType CloneImageProperties(Image *image,\n%        const Image *clone_image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o clone_image: the clone image.\n%\n*/\nMagickExport MagickBooleanType CloneImageProperties(Image *image,\n  const Image *clone_image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(clone_image != (const Image *) NULL);\n  assert(clone_image->signature == MagickCoreSignature);\n  if (clone_image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      clone_image->filename);\n  (void) CopyMagickString(image->filename,clone_image->filename,\n    MagickPathExtent);\n  (void) CopyMagickString(image->magick_filename,clone_image->magick_filename,\n    MagickPathExtent);\n  image->compression=clone_image->compression;\n  image->quality=clone_image->quality;\n  image->depth=clone_image->depth;\n  image->alpha_color=clone_image->alpha_color;\n  image->background_color=clone_image->background_color;\n  image->border_color=clone_image->border_color;\n  image->transparent_color=clone_image->transparent_color;\n  image->gamma=clone_image->gamma;\n  image->chromaticity=clone_image->chromaticity;\n  image->rendering_intent=clone_image->rendering_intent;\n  image->black_point_compensation=clone_image->black_point_compensation;\n  image->units=clone_image->units;\n  image->montage=(char *) NULL;\n  image->directory=(char *) NULL;\n  (void) CloneString(&image->geometry,clone_image->geometry);\n  image->offset=clone_image->offset;\n  image->resolution.x=clone_image->resolution.x;\n  image->resolution.y=clone_image->resolution.y;\n  image->page=clone_image->page;\n  image->tile_offset=clone_image->tile_offset;\n  image->extract_info=clone_image->extract_info;\n  image->filter=clone_image->filter;\n  image->fuzz=clone_image->fuzz;\n  image->intensity=clone_image->intensity;\n  image->interlace=clone_image->interlace;\n  image->interpolate=clone_image->interpolate;\n  image->endian=clone_image->endian;\n  image->gravity=clone_image->gravity;\n  image->compose=clone_image->compose;\n  image->orientation=clone_image->orientation;\n  image->scene=clone_image->scene;\n  image->dispose=clone_image->dispose;\n  image->delay=clone_image->delay;\n  image->ticks_per_second=clone_image->ticks_per_second;\n  image->iterations=clone_image->iterations;\n  image->total_colors=clone_image->total_colors;\n  image->taint=clone_image->taint;\n  image->progress_monitor=clone_image->progress_monitor;\n  image->client_data=clone_image->client_data;\n  image->start_loop=clone_image->start_loop;\n  image->error=clone_image->error;\n  image->signature=clone_image->signature;\n  if (clone_image->properties != (void *) NULL)\n    {\n      if (image->properties != (void *) NULL)\n        DestroyImageProperties(image);\n      image->properties=CloneSplayTree((SplayTreeInfo *)\n        clone_image->properties,(void *(*)(void *)) ConstantString,\n        (void *(*)(void *)) ConstantString);\n    }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e f i n e I m a g e P r o p e r t y                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DefineImageProperty() associates an assignment string of the form\n%  \"key=value\" with an artifact or options. It is equivelent to\n%  SetImageProperty()\n%\n%  The format of the DefineImageProperty method is:\n%\n%      MagickBooleanType DefineImageProperty(Image *image,const char *property,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o property: the image property.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType DefineImageProperty(Image *image,\n  const char *property,ExceptionInfo *exception)\n{\n  char\n    key[MagickPathExtent],\n    value[MagickPathExtent];\n\n  register char\n    *p;\n\n  assert(image != (Image *) NULL);\n  assert(property != (const char *) NULL);\n  (void) CopyMagickString(key,property,MagickPathExtent-1);\n  for (p=key; *p != '\\0'; p++)\n    if (*p == '=')\n      break;\n  *value='\\0';\n  if (*p == '=')\n    (void) CopyMagickString(value,p+1,MagickPathExtent);\n  *p='\\0';\n  return(SetImageProperty(image,key,value,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e l e t e I m a g e P r o p e r t y                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DeleteImageProperty() deletes an image property.\n%\n%  The format of the DeleteImageProperty method is:\n%\n%      MagickBooleanType DeleteImageProperty(Image *image,const char *property)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o property: the image property.\n%\n*/\nMagickExport MagickBooleanType DeleteImageProperty(Image *image,\n  const char *property)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->properties == (void *) NULL)\n    return(MagickFalse);\n  return(DeleteNodeFromSplayTree((SplayTreeInfo *) image->properties,property));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y I m a g e P r o p e r t i e s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyImageProperties() destroys all properties and associated memory\n%  attached to the given image.\n%\n%  The format of the DestroyDefines method is:\n%\n%      void DestroyImageProperties(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void DestroyImageProperties(Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->properties != (void *) NULL)\n    image->properties=(void *) DestroySplayTree((SplayTreeInfo *)\n      image->properties);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  F o r m a t I m a g e P r o p e r t y                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FormatImageProperty() permits formatted property/value pairs to be saved as\n%  an image property.\n%\n%  The format of the FormatImageProperty method is:\n%\n%      MagickBooleanType FormatImageProperty(Image *image,const char *property,\n%        const char *format,...)\n%\n%  A description of each parameter follows.\n%\n%   o  image:  The image.\n%\n%   o  property:  The attribute property.\n%\n%   o  format:  A string describing the format to use to write the remaining\n%      arguments.\n%\n*/\nMagickExport MagickBooleanType FormatImageProperty(Image *image,\n  const char *property,const char *format,...)\n{\n  char\n    value[MagickPathExtent];\n\n  ExceptionInfo\n    *exception;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    n;\n\n  va_list\n    operands;\n\n  va_start(operands,format);\n  n=FormatLocaleStringList(value,MagickPathExtent,format,operands);\n  (void) n;\n  va_end(operands);\n  exception=AcquireExceptionInfo();\n  status=SetImageProperty(image,property,value,exception);\n  exception=DestroyExceptionInfo(exception);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e P r o p e r t y                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageProperty() gets a value associated with an image property.\n%\n%  This includes,  profile prefixes, such as \"exif:\", \"iptc:\" and \"8bim:\"\n%  It does not handle non-prifile prefixes, such as \"fx:\", \"option:\", or\n%  \"artifact:\".\n%\n%  The returned string is stored as a properity of the same name for faster\n%  lookup later. It should NOT be freed by the caller.\n%\n%  The format of the GetImageProperty method is:\n%\n%      const char *GetImageProperty(const Image *image,const char *key,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o key: the key.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic char\n  *TracePSClippath(const unsigned char *,size_t),\n  *TraceSVGClippath(const unsigned char *,size_t,const size_t,\n    const size_t);\n\nstatic MagickBooleanType GetIPTCProperty(const Image *image,const char *key,\n  ExceptionInfo *exception)\n{\n  char\n    *attribute,\n    *message;\n\n  const StringInfo\n    *profile;\n\n  long\n    count,\n    dataset,\n    record;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  profile=GetImageProfile(image,\"iptc\");\n  if (profile == (StringInfo *) NULL)\n    profile=GetImageProfile(image,\"8bim\");\n  if (profile == (StringInfo *) NULL)\n    return(MagickFalse);\n  count=sscanf(key,\"IPTC:%ld:%ld\",&dataset,&record);\n  if (count != 2)\n    return(MagickFalse);\n  attribute=(char *) NULL;\n  for (i=0; i < (ssize_t) GetStringInfoLength(profile); i+=(ssize_t) length)\n  {\n    length=1;\n    if ((ssize_t) GetStringInfoDatum(profile)[i] != 0x1c)\n      continue;\n    length=(size_t) (GetStringInfoDatum(profile)[i+3] << 8);\n    length|=GetStringInfoDatum(profile)[i+4];\n    if (((long) GetStringInfoDatum(profile)[i+1] == dataset) &&\n        ((long) GetStringInfoDatum(profile)[i+2] == record))\n      {\n        message=(char *) NULL;\n        if (~length >= 1)\n          message=(char *) AcquireQuantumMemory(length+1UL,sizeof(*message));\n        if (message != (char *) NULL)\n          {\n            (void) CopyMagickString(message,(char *) GetStringInfoDatum(\n              profile)+i+5,length+1);\n            (void) ConcatenateString(&attribute,message);\n            (void) ConcatenateString(&attribute,\";\");\n            message=DestroyString(message);\n          }\n      }\n    i+=5;\n  }\n  if ((attribute == (char *) NULL) || (*attribute == ';'))\n    {\n      if (attribute != (char *) NULL)\n        attribute=DestroyString(attribute);\n      return(MagickFalse);\n    }\n  attribute[strlen(attribute)-1]='\\0';\n  (void) SetImageProperty((Image *) image,key,(const char *) attribute,\n    exception);\n  attribute=DestroyString(attribute);\n  return(MagickTrue);\n}\n\nstatic inline int ReadPropertyByte(const unsigned char **p,size_t *length)\n{\n  int\n    c;\n\n  if (*length < 1)\n    return(EOF);\n  c=(int) (*(*p)++);\n  (*length)--;\n  return(c);\n}\n\nstatic inline signed int ReadPropertyMSBLong(const unsigned char **p,\n  size_t *length)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  int\n    c;\n\n  register ssize_t\n    i;\n\n  unsigned char\n    buffer[4];\n\n  unsigned int\n    value;\n\n  if (*length < 4)\n    return(-1);\n  for (i=0; i < 4; i++)\n  {\n    c=(int) (*(*p)++);\n    (*length)--;\n    buffer[i]=(unsigned char) c;\n  }\n  value=(unsigned int) buffer[0] << 24;\n  value|=(unsigned int) buffer[1] << 16;\n  value|=(unsigned int) buffer[2] << 8;\n  value|=(unsigned int) buffer[3];\n  quantum.unsigned_value=value & 0xffffffff;\n  return(quantum.signed_value);\n}\n\nstatic inline signed short ReadPropertyMSBShort(const unsigned char **p,\n  size_t *length)\n{\n  union\n  {\n    unsigned short\n      unsigned_value;\n\n    signed short\n      signed_value;\n  } quantum;\n\n  int\n    c;\n\n  register ssize_t\n    i;\n\n  unsigned char\n    buffer[2];\n\n  unsigned short\n    value;\n\n  if (*length < 2)\n    return((unsigned short) ~0);\n  for (i=0; i < 2; i++)\n  {\n    c=(int) (*(*p)++);\n    (*length)--;\n    buffer[i]=(unsigned char) c;\n  }\n  value=(unsigned short) buffer[0] << 8;\n  value|=(unsigned short) buffer[1];\n  quantum.unsigned_value=value & 0xffff;\n  return(quantum.signed_value);\n}\n\nstatic MagickBooleanType Get8BIMProperty(const Image *image,const char *key,\n  ExceptionInfo *exception)\n{\n  char\n    *attribute,\n    format[MagickPathExtent],\n    name[MagickPathExtent],\n    *resource;\n\n  const StringInfo\n    *profile;\n\n  const unsigned char\n    *info;\n\n  long\n    start,\n    stop;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    id,\n    sub_number;\n\n  /*\n    There are no newlines in path names, so it's safe as terminator.\n  */\n  profile=GetImageProfile(image,\"8bim\");\n  if (profile == (StringInfo *) NULL)\n    return(MagickFalse);\n  count=(ssize_t) sscanf(key,\"8BIM:%ld,%ld:%1024[^\\n]\\n%1024[^\\n]\",&start,&stop,\n    name,format);\n  if ((count != 2) && (count != 3) && (count != 4))\n    return(MagickFalse);\n  if (count < 4)\n    (void) CopyMagickString(format,\"SVG\",MagickPathExtent);\n  if (count < 3)\n    *name='\\0';\n  sub_number=1;\n  if (*name == '#')\n    sub_number=(ssize_t) StringToLong(&name[1]);\n  sub_number=MagickMax(sub_number,1L);\n  resource=(char *) NULL;\n  status=MagickFalse;\n  length=GetStringInfoLength(profile);\n  info=GetStringInfoDatum(profile);\n  while ((length > 0) && (status == MagickFalse))\n  {\n    if (ReadPropertyByte(&info,&length) != (unsigned char) '8')\n      continue;\n    if (ReadPropertyByte(&info,&length) != (unsigned char) 'B')\n      continue;\n    if (ReadPropertyByte(&info,&length) != (unsigned char) 'I')\n      continue;\n    if (ReadPropertyByte(&info,&length) != (unsigned char) 'M')\n      continue;\n    id=(ssize_t) ReadPropertyMSBShort(&info,&length);\n    if (id < (ssize_t) start)\n      continue;\n    if (id > (ssize_t) stop)\n      continue;\n    if (resource != (char *) NULL)\n      resource=DestroyString(resource);\n    count=(ssize_t) ReadPropertyByte(&info,&length);\n    if ((count != 0) && ((size_t) count <= length))\n      {\n        resource=(char *) NULL;\n        if (~((size_t) count) >= (MagickPathExtent-1))\n          resource=(char *) AcquireQuantumMemory((size_t) count+\n            MagickPathExtent,sizeof(*resource));\n        if (resource != (char *) NULL)\n          {\n            for (i=0; i < (ssize_t) count; i++)\n              resource[i]=(char) ReadPropertyByte(&info,&length);\n            resource[count]='\\0';\n          }\n      }\n    if ((count & 0x01) == 0)\n      (void) ReadPropertyByte(&info,&length);\n    count=(ssize_t) ReadPropertyMSBLong(&info,&length);\n    if ((*name != '\\0') && (*name != '#'))\n      if ((resource == (char *) NULL) || (LocaleCompare(name,resource) != 0))\n        {\n          /*\n            No name match, scroll forward and try next.\n          */\n          info+=count;\n          length-=MagickMin(count,(ssize_t) length);\n          continue;\n        }\n    if ((*name == '#') && (sub_number != 1))\n      {\n        /*\n          No numbered match, scroll forward and try next.\n        */\n        sub_number--;\n        info+=count;\n        length-=MagickMin(count,(ssize_t) length);\n        continue;\n      }\n    /*\n      We have the resource of interest.\n    */\n    attribute=(char *) NULL;\n    if (~((size_t) count) >= (MagickPathExtent-1))\n      attribute=(char *) AcquireQuantumMemory((size_t) count+MagickPathExtent,\n        sizeof(*attribute));\n    if (attribute != (char *) NULL)\n      {\n        (void) CopyMagickMemory(attribute,(char *) info,(size_t) count);\n        attribute[count]='\\0';\n        info+=count;\n        length-=MagickMin(count,(ssize_t) length);\n        if ((id <= 1999) || (id >= 2999))\n          (void) SetImageProperty((Image *) image,key,(const char *)\n            attribute,exception);\n        else\n          {\n            char\n              *path;\n\n            if (LocaleCompare(format,\"svg\") == 0)\n              path=TraceSVGClippath((unsigned char *) attribute,(size_t) count,\n                image->columns,image->rows);\n            else\n              path=TracePSClippath((unsigned char *) attribute,(size_t) count);\n            (void) SetImageProperty((Image *) image,key,(const char *) path,\n              exception);\n            path=DestroyString(path);\n          }\n        attribute=DestroyString(attribute);\n        status=MagickTrue;\n      }\n  }\n  if (resource != (char *) NULL)\n    resource=DestroyString(resource);\n  return(status);\n}\n\nstatic inline signed int ReadPropertySignedLong(const EndianType endian,\n  const unsigned char *buffer)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  unsigned int\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned int) buffer[3] << 24;\n      value|=(unsigned int) buffer[2] << 16;\n      value|=(unsigned int) buffer[1] << 8;\n      value|=(unsigned int) buffer[0];\n      quantum.unsigned_value=value & 0xffffffff;\n      return(quantum.signed_value);\n    }\n  value=(unsigned int) buffer[0] << 24;\n  value|=(unsigned int) buffer[1] << 16;\n  value|=(unsigned int) buffer[2] << 8;\n  value|=(unsigned int) buffer[3];\n  quantum.unsigned_value=value & 0xffffffff;\n  return(quantum.signed_value);\n}\n\nstatic inline unsigned int ReadPropertyUnsignedLong(const EndianType endian,\n  const unsigned char *buffer)\n{\n  unsigned int\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned int) buffer[3] << 24;\n      value|=(unsigned int) buffer[2] << 16;\n      value|=(unsigned int) buffer[1] << 8;\n      value|=(unsigned int) buffer[0];\n      return(value & 0xffffffff);\n    }\n  value=(unsigned int) buffer[0] << 24;\n  value|=(unsigned int) buffer[1] << 16;\n  value|=(unsigned int) buffer[2] << 8;\n  value|=(unsigned int) buffer[3];\n  return(value & 0xffffffff);\n}\n\nstatic inline signed short ReadPropertySignedShort(const EndianType endian,\n  const unsigned char *buffer)\n{\n  union\n  {\n    unsigned short\n      unsigned_value;\n\n    signed short\n      signed_value;\n  } quantum;\n\n  unsigned short\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned short) buffer[1] << 8;\n      value|=(unsigned short) buffer[0];\n      quantum.unsigned_value=value & 0xffff;\n      return(quantum.signed_value);\n    }\n  value=(unsigned short) buffer[0] << 8;\n  value|=(unsigned short) buffer[1];\n  quantum.unsigned_value=value & 0xffff;\n  return(quantum.signed_value);\n}\n\nstatic inline unsigned short ReadPropertyUnsignedShort(const EndianType endian,\n  const unsigned char *buffer)\n{\n  unsigned short\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned short) buffer[1] << 8;\n      value|=(unsigned short) buffer[0];\n      return(value & 0xffff);\n    }\n  value=(unsigned short) buffer[0] << 8;\n  value|=(unsigned short) buffer[1];\n  return(value & 0xffff);\n}\n\nstatic MagickBooleanType GetEXIFProperty(const Image *image,\n  const char *property,ExceptionInfo *exception)\n{\n#define MaxDirectoryStack  16\n#define EXIF_DELIMITER  \"\\n\"\n#define EXIF_NUM_FORMATS  12\n#define EXIF_FMT_BYTE  1\n#define EXIF_FMT_STRING  2\n#define EXIF_FMT_USHORT  3\n#define EXIF_FMT_ULONG  4\n#define EXIF_FMT_URATIONAL  5\n#define EXIF_FMT_SBYTE  6\n#define EXIF_FMT_UNDEFINED  7\n#define EXIF_FMT_SSHORT  8\n#define EXIF_FMT_SLONG  9\n#define EXIF_FMT_SRATIONAL  10\n#define EXIF_FMT_SINGLE  11\n#define EXIF_FMT_DOUBLE  12\n#define TAG_EXIF_OFFSET  0x8769\n#define TAG_GPS_OFFSET  0x8825\n#define TAG_INTEROP_OFFSET  0xa005\n\n#define EXIFMultipleValues(size,format,arg) \\\n{ \\\n   ssize_t \\\n     component; \\\n \\\n   size_t \\\n     length; \\\n \\\n   unsigned char \\\n     *p1; \\\n \\\n   length=0; \\\n   p1=p; \\\n   for (component=0; component < components; component++) \\\n   { \\\n     length+=FormatLocaleString(buffer+length,MagickPathExtent-length, \\\n       format\", \",arg); \\\n     if (length >= (MagickPathExtent-1)) \\\n       length=MagickPathExtent-1; \\\n     p1+=size; \\\n   } \\\n   if (length > 1) \\\n     buffer[length-2]='\\0'; \\\n   value=AcquireString(buffer); \\\n}\n\n#define EXIFMultipleFractions(size,format,arg1,arg2) \\\n{ \\\n   ssize_t \\\n     component; \\\n \\\n   size_t \\\n     length; \\\n \\\n   unsigned char \\\n     *p1; \\\n \\\n   length=0; \\\n   p1=p; \\\n   for (component=0; component < components; component++) \\\n   { \\\n     length+=FormatLocaleString(buffer+length,MagickPathExtent-length, \\\n       format\", \",(arg1),(arg2)); \\\n     if (length >= (MagickPathExtent-1)) \\\n       length=MagickPathExtent-1; \\\n     p1+=size; \\\n   } \\\n   if (length > 1) \\\n     buffer[length-2]='\\0'; \\\n   value=AcquireString(buffer); \\\n}\n\n  typedef struct _DirectoryInfo\n  {\n    const unsigned char\n      *directory;\n\n    size_t\n      entry;\n\n    ssize_t\n      offset;\n  } DirectoryInfo;\n\n  typedef struct _TagInfo\n  {\n    size_t\n      tag;\n\n    const char\n      *description;\n  } TagInfo;\n\n  static TagInfo\n    EXIFTag[] =\n    {\n      {  0x001, \"exif:InteroperabilityIndex\" },\n      {  0x002, \"exif:InteroperabilityVersion\" },\n      {  0x100, \"exif:ImageWidth\" },\n      {  0x101, \"exif:ImageLength\" },\n      {  0x102, \"exif:BitsPerSample\" },\n      {  0x103, \"exif:Compression\" },\n      {  0x106, \"exif:PhotometricInterpretation\" },\n      {  0x10a, \"exif:FillOrder\" },\n      {  0x10d, \"exif:DocumentName\" },\n      {  0x10e, \"exif:ImageDescription\" },\n      {  0x10f, \"exif:Make\" },\n      {  0x110, \"exif:Model\" },\n      {  0x111, \"exif:StripOffsets\" },\n      {  0x112, \"exif:Orientation\" },\n      {  0x115, \"exif:SamplesPerPixel\" },\n      {  0x116, \"exif:RowsPerStrip\" },\n      {  0x117, \"exif:StripByteCounts\" },\n      {  0x11a, \"exif:XResolution\" },\n      {  0x11b, \"exif:YResolution\" },\n      {  0x11c, \"exif:PlanarConfiguration\" },\n      {  0x11d, \"exif:PageName\" },\n      {  0x11e, \"exif:XPosition\" },\n      {  0x11f, \"exif:YPosition\" },\n      {  0x118, \"exif:MinSampleValue\" },\n      {  0x119, \"exif:MaxSampleValue\" },\n      {  0x120, \"exif:FreeOffsets\" },\n      {  0x121, \"exif:FreeByteCounts\" },\n      {  0x122, \"exif:GrayResponseUnit\" },\n      {  0x123, \"exif:GrayResponseCurve\" },\n      {  0x124, \"exif:T4Options\" },\n      {  0x125, \"exif:T6Options\" },\n      {  0x128, \"exif:ResolutionUnit\" },\n      {  0x12d, \"exif:TransferFunction\" },\n      {  0x131, \"exif:Software\" },\n      {  0x132, \"exif:DateTime\" },\n      {  0x13b, \"exif:Artist\" },\n      {  0x13e, \"exif:WhitePoint\" },\n      {  0x13f, \"exif:PrimaryChromaticities\" },\n      {  0x140, \"exif:ColorMap\" },\n      {  0x141, \"exif:HalfToneHints\" },\n      {  0x142, \"exif:TileWidth\" },\n      {  0x143, \"exif:TileLength\" },\n      {  0x144, \"exif:TileOffsets\" },\n      {  0x145, \"exif:TileByteCounts\" },\n      {  0x14a, \"exif:SubIFD\" },\n      {  0x14c, \"exif:InkSet\" },\n      {  0x14d, \"exif:InkNames\" },\n      {  0x14e, \"exif:NumberOfInks\" },\n      {  0x150, \"exif:DotRange\" },\n      {  0x151, \"exif:TargetPrinter\" },\n      {  0x152, \"exif:ExtraSample\" },\n      {  0x153, \"exif:SampleFormat\" },\n      {  0x154, \"exif:SMinSampleValue\" },\n      {  0x155, \"exif:SMaxSampleValue\" },\n      {  0x156, \"exif:TransferRange\" },\n      {  0x157, \"exif:ClipPath\" },\n      {  0x158, \"exif:XClipPathUnits\" },\n      {  0x159, \"exif:YClipPathUnits\" },\n      {  0x15a, \"exif:Indexed\" },\n      {  0x15b, \"exif:JPEGTables\" },\n      {  0x15f, \"exif:OPIProxy\" },\n      {  0x200, \"exif:JPEGProc\" },\n      {  0x201, \"exif:JPEGInterchangeFormat\" },\n      {  0x202, \"exif:JPEGInterchangeFormatLength\" },\n      {  0x203, \"exif:JPEGRestartInterval\" },\n      {  0x205, \"exif:JPEGLosslessPredictors\" },\n      {  0x206, \"exif:JPEGPointTransforms\" },\n      {  0x207, \"exif:JPEGQTables\" },\n      {  0x208, \"exif:JPEGDCTables\" },\n      {  0x209, \"exif:JPEGACTables\" },\n      {  0x211, \"exif:YCbCrCoefficients\" },\n      {  0x212, \"exif:YCbCrSubSampling\" },\n      {  0x213, \"exif:YCbCrPositioning\" },\n      {  0x214, \"exif:ReferenceBlackWhite\" },\n      {  0x2bc, \"exif:ExtensibleMetadataPlatform\" },\n      {  0x301, \"exif:Gamma\" },\n      {  0x302, \"exif:ICCProfileDescriptor\" },\n      {  0x303, \"exif:SRGBRenderingIntent\" },\n      {  0x320, \"exif:ImageTitle\" },\n      {  0x5001, \"exif:ResolutionXUnit\" },\n      {  0x5002, \"exif:ResolutionYUnit\" },\n      {  0x5003, \"exif:ResolutionXLengthUnit\" },\n      {  0x5004, \"exif:ResolutionYLengthUnit\" },\n      {  0x5005, \"exif:PrintFlags\" },\n      {  0x5006, \"exif:PrintFlagsVersion\" },\n      {  0x5007, \"exif:PrintFlagsCrop\" },\n      {  0x5008, \"exif:PrintFlagsBleedWidth\" },\n      {  0x5009, \"exif:PrintFlagsBleedWidthScale\" },\n      {  0x500A, \"exif:HalftoneLPI\" },\n      {  0x500B, \"exif:HalftoneLPIUnit\" },\n      {  0x500C, \"exif:HalftoneDegree\" },\n      {  0x500D, \"exif:HalftoneShape\" },\n      {  0x500E, \"exif:HalftoneMisc\" },\n      {  0x500F, \"exif:HalftoneScreen\" },\n      {  0x5010, \"exif:JPEGQuality\" },\n      {  0x5011, \"exif:GridSize\" },\n      {  0x5012, \"exif:ThumbnailFormat\" },\n      {  0x5013, \"exif:ThumbnailWidth\" },\n      {  0x5014, \"exif:ThumbnailHeight\" },\n      {  0x5015, \"exif:ThumbnailColorDepth\" },\n      {  0x5016, \"exif:ThumbnailPlanes\" },\n      {  0x5017, \"exif:ThumbnailRawBytes\" },\n      {  0x5018, \"exif:ThumbnailSize\" },\n      {  0x5019, \"exif:ThumbnailCompressedSize\" },\n      {  0x501a, \"exif:ColorTransferFunction\" },\n      {  0x501b, \"exif:ThumbnailData\" },\n      {  0x5020, \"exif:ThumbnailImageWidth\" },\n      {  0x5021, \"exif:ThumbnailImageHeight\" },\n      {  0x5022, \"exif:ThumbnailBitsPerSample\" },\n      {  0x5023, \"exif:ThumbnailCompression\" },\n      {  0x5024, \"exif:ThumbnailPhotometricInterp\" },\n      {  0x5025, \"exif:ThumbnailImageDescription\" },\n      {  0x5026, \"exif:ThumbnailEquipMake\" },\n      {  0x5027, \"exif:ThumbnailEquipModel\" },\n      {  0x5028, \"exif:ThumbnailStripOffsets\" },\n      {  0x5029, \"exif:ThumbnailOrientation\" },\n      {  0x502a, \"exif:ThumbnailSamplesPerPixel\" },\n      {  0x502b, \"exif:ThumbnailRowsPerStrip\" },\n      {  0x502c, \"exif:ThumbnailStripBytesCount\" },\n      {  0x502d, \"exif:ThumbnailResolutionX\" },\n      {  0x502e, \"exif:ThumbnailResolutionY\" },\n      {  0x502f, \"exif:ThumbnailPlanarConfig\" },\n      {  0x5030, \"exif:ThumbnailResolutionUnit\" },\n      {  0x5031, \"exif:ThumbnailTransferFunction\" },\n      {  0x5032, \"exif:ThumbnailSoftwareUsed\" },\n      {  0x5033, \"exif:ThumbnailDateTime\" },\n      {  0x5034, \"exif:ThumbnailArtist\" },\n      {  0x5035, \"exif:ThumbnailWhitePoint\" },\n      {  0x5036, \"exif:ThumbnailPrimaryChromaticities\" },\n      {  0x5037, \"exif:ThumbnailYCbCrCoefficients\" },\n      {  0x5038, \"exif:ThumbnailYCbCrSubsampling\" },\n      {  0x5039, \"exif:ThumbnailYCbCrPositioning\" },\n      {  0x503A, \"exif:ThumbnailRefBlackWhite\" },\n      {  0x503B, \"exif:ThumbnailCopyRight\" },\n      {  0x5090, \"exif:LuminanceTable\" },\n      {  0x5091, \"exif:ChrominanceTable\" },\n      {  0x5100, \"exif:FrameDelay\" },\n      {  0x5101, \"exif:LoopCount\" },\n      {  0x5110, \"exif:PixelUnit\" },\n      {  0x5111, \"exif:PixelPerUnitX\" },\n      {  0x5112, \"exif:PixelPerUnitY\" },\n      {  0x5113, \"exif:PaletteHistogram\" },\n      {  0x1000, \"exif:RelatedImageFileFormat\" },\n      {  0x1001, \"exif:RelatedImageLength\" },\n      {  0x1002, \"exif:RelatedImageWidth\" },\n      {  0x800d, \"exif:ImageID\" },\n      {  0x80e3, \"exif:Matteing\" },\n      {  0x80e4, \"exif:DataType\" },\n      {  0x80e5, \"exif:ImageDepth\" },\n      {  0x80e6, \"exif:TileDepth\" },\n      {  0x828d, \"exif:CFARepeatPatternDim\" },\n      {  0x828e, \"exif:CFAPattern2\" },\n      {  0x828f, \"exif:BatteryLevel\" },\n      {  0x8298, \"exif:Copyright\" },\n      {  0x829a, \"exif:ExposureTime\" },\n      {  0x829d, \"exif:FNumber\" },\n      {  0x83bb, \"exif:IPTC/NAA\" },\n      {  0x84e3, \"exif:IT8RasterPadding\" },\n      {  0x84e5, \"exif:IT8ColorTable\" },\n      {  0x8649, \"exif:ImageResourceInformation\" },\n      {  0x8769, \"exif:ExifOffset\" },\n      {  0x8773, \"exif:InterColorProfile\" },\n      {  0x8822, \"exif:ExposureProgram\" },\n      {  0x8824, \"exif:SpectralSensitivity\" },\n      {  0x8825, \"exif:GPSInfo\" },\n      {  0x8827, \"exif:ISOSpeedRatings\" },\n      {  0x8828, \"exif:OECF\" },\n      {  0x8829, \"exif:Interlace\" },\n      {  0x882a, \"exif:TimeZoneOffset\" },\n      {  0x882b, \"exif:SelfTimerMode\" },\n      {  0x9000, \"exif:ExifVersion\" },\n      {  0x9003, \"exif:DateTimeOriginal\" },\n      {  0x9004, \"exif:DateTimeDigitized\" },\n      {  0x9101, \"exif:ComponentsConfiguration\" },\n      {  0x9102, \"exif:CompressedBitsPerPixel\" },\n      {  0x9201, \"exif:ShutterSpeedValue\" },\n      {  0x9202, \"exif:ApertureValue\" },\n      {  0x9203, \"exif:BrightnessValue\" },\n      {  0x9204, \"exif:ExposureBiasValue\" },\n      {  0x9205, \"exif:MaxApertureValue\" },\n      {  0x9206, \"exif:SubjectDistance\" },\n      {  0x9207, \"exif:MeteringMode\" },\n      {  0x9208, \"exif:LightSource\" },\n      {  0x9209, \"exif:Flash\" },\n      {  0x920a, \"exif:FocalLength\" },\n      {  0x920b, \"exif:FlashEnergy\" },\n      {  0x920c, \"exif:SpatialFrequencyResponse\" },\n      {  0x920d, \"exif:Noise\" },\n      {  0x9211, \"exif:ImageNumber\" },\n      {  0x9212, \"exif:SecurityClassification\" },\n      {  0x9213, \"exif:ImageHistory\" },\n      {  0x9214, \"exif:SubjectArea\" },\n      {  0x9215, \"exif:ExposureIndex\" },\n      {  0x9216, \"exif:TIFF-EPStandardID\" },\n      {  0x927c, \"exif:MakerNote\" },\n      {  0x9C9b, \"exif:WinXP-Title\" },\n      {  0x9C9c, \"exif:WinXP-Comments\" },\n      {  0x9C9d, \"exif:WinXP-Author\" },\n      {  0x9C9e, \"exif:WinXP-Keywords\" },\n      {  0x9C9f, \"exif:WinXP-Subject\" },\n      {  0x9286, \"exif:UserComment\" },\n      {  0x9290, \"exif:SubSecTime\" },\n      {  0x9291, \"exif:SubSecTimeOriginal\" },\n      {  0x9292, \"exif:SubSecTimeDigitized\" },\n      {  0xa000, \"exif:FlashPixVersion\" },\n      {  0xa001, \"exif:ColorSpace\" },\n      {  0xa002, \"exif:ExifImageWidth\" },\n      {  0xa003, \"exif:ExifImageLength\" },\n      {  0xa004, \"exif:RelatedSoundFile\" },\n      {  0xa005, \"exif:InteroperabilityOffset\" },\n      {  0xa20b, \"exif:FlashEnergy\" },\n      {  0xa20c, \"exif:SpatialFrequencyResponse\" },\n      {  0xa20d, \"exif:Noise\" },\n      {  0xa20e, \"exif:FocalPlaneXResolution\" },\n      {  0xa20f, \"exif:FocalPlaneYResolution\" },\n      {  0xa210, \"exif:FocalPlaneResolutionUnit\" },\n      {  0xa214, \"exif:SubjectLocation\" },\n      {  0xa215, \"exif:ExposureIndex\" },\n      {  0xa216, \"exif:TIFF/EPStandardID\" },\n      {  0xa217, \"exif:SensingMethod\" },\n      {  0xa300, \"exif:FileSource\" },\n      {  0xa301, \"exif:SceneType\" },\n      {  0xa302, \"exif:CFAPattern\" },\n      {  0xa401, \"exif:CustomRendered\" },\n      {  0xa402, \"exif:ExposureMode\" },\n      {  0xa403, \"exif:WhiteBalance\" },\n      {  0xa404, \"exif:DigitalZoomRatio\" },\n      {  0xa405, \"exif:FocalLengthIn35mmFilm\" },\n      {  0xa406, \"exif:SceneCaptureType\" },\n      {  0xa407, \"exif:GainControl\" },\n      {  0xa408, \"exif:Contrast\" },\n      {  0xa409, \"exif:Saturation\" },\n      {  0xa40a, \"exif:Sharpness\" },\n      {  0xa40b, \"exif:DeviceSettingDescription\" },\n      {  0xa40c, \"exif:SubjectDistanceRange\" },\n      {  0xa420, \"exif:ImageUniqueID\" },\n      {  0xc4a5, \"exif:PrintImageMatching\" },\n      {  0xa500, \"exif:Gamma\" },\n      {  0xc640, \"exif:CR2Slice\" },\n      { 0x10000, \"exif:GPSVersionID\" },\n      { 0x10001, \"exif:GPSLatitudeRef\" },\n      { 0x10002, \"exif:GPSLatitude\" },\n      { 0x10003, \"exif:GPSLongitudeRef\" },\n      { 0x10004, \"exif:GPSLongitude\" },\n      { 0x10005, \"exif:GPSAltitudeRef\" },\n      { 0x10006, \"exif:GPSAltitude\" },\n      { 0x10007, \"exif:GPSTimeStamp\" },\n      { 0x10008, \"exif:GPSSatellites\" },\n      { 0x10009, \"exif:GPSStatus\" },\n      { 0x1000a, \"exif:GPSMeasureMode\" },\n      { 0x1000b, \"exif:GPSDop\" },\n      { 0x1000c, \"exif:GPSSpeedRef\" },\n      { 0x1000d, \"exif:GPSSpeed\" },\n      { 0x1000e, \"exif:GPSTrackRef\" },\n      { 0x1000f, \"exif:GPSTrack\" },\n      { 0x10010, \"exif:GPSImgDirectionRef\" },\n      { 0x10011, \"exif:GPSImgDirection\" },\n      { 0x10012, \"exif:GPSMapDatum\" },\n      { 0x10013, \"exif:GPSDestLatitudeRef\" },\n      { 0x10014, \"exif:GPSDestLatitude\" },\n      { 0x10015, \"exif:GPSDestLongitudeRef\" },\n      { 0x10016, \"exif:GPSDestLongitude\" },\n      { 0x10017, \"exif:GPSDestBearingRef\" },\n      { 0x10018, \"exif:GPSDestBearing\" },\n      { 0x10019, \"exif:GPSDestDistanceRef\" },\n      { 0x1001a, \"exif:GPSDestDistance\" },\n      { 0x1001b, \"exif:GPSProcessingMethod\" },\n      { 0x1001c, \"exif:GPSAreaInformation\" },\n      { 0x1001d, \"exif:GPSDateStamp\" },\n      { 0x1001e, \"exif:GPSDifferential\" },\n      { 0x00000, (const char *) NULL }\n    };\n\n  const StringInfo\n    *profile;\n\n  const unsigned char\n    *directory,\n    *exif;\n\n  DirectoryInfo\n    directory_stack[MaxDirectoryStack];\n\n  EndianType\n    endian;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    entry,\n    length,\n    number_entries,\n    tag,\n    tag_value;\n\n  SplayTreeInfo\n    *exif_resources;\n\n  ssize_t\n    all,\n    id,\n    level,\n    offset,\n    tag_offset;\n\n  static int\n    tag_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};\n\n  /*\n    If EXIF data exists, then try to parse the request for a tag.\n  */\n  profile=GetImageProfile(image,\"exif\");\n  if (profile == (const StringInfo *) NULL)\n    return(MagickFalse);\n  if ((property == (const char *) NULL) || (*property == '\\0'))\n    return(MagickFalse);\n  while (isspace((int) ((unsigned char) *property)) != 0)\n    property++;\n  if (strlen(property) <= 5)\n    return(MagickFalse);\n  all=0;\n  tag=(~0UL);\n  switch (*(property+5))\n  {\n    case '*':\n    {\n      /*\n        Caller has asked for all the tags in the EXIF data.\n      */\n      tag=0;\n      all=1; /* return the data in description=value format */\n      break;\n    }\n    case '!':\n    {\n      tag=0;\n      all=2; /* return the data in tagid=value format */\n      break;\n    }\n    case '#':\n    case '@':\n    {\n      int\n        c;\n\n      size_t\n        n;\n\n      /*\n        Check for a hex based tag specification first.\n      */\n      tag=(*(property+5) == '@') ? 1UL : 0UL;\n      property+=6;\n      n=strlen(property);\n      if (n != 4)\n        return(MagickFalse);\n      /*\n        Parse tag specification as a hex number.\n      */\n      n/=4;\n      do\n      {\n        for (i=(ssize_t) n-1L; i >= 0; i--)\n        {\n          c=(*property++);\n          tag<<=4;\n          if ((c >= '0') && (c <= '9'))\n            tag|=(c-'0');\n          else\n            if ((c >= 'A') && (c <= 'F'))\n              tag|=(c-('A'-10));\n            else\n              if ((c >= 'a') && (c <= 'f'))\n                tag|=(c-('a'-10));\n              else\n                return(MagickFalse);\n        }\n      } while (*property != '\\0');\n      break;\n    }\n    default:\n    {\n      /*\n        Try to match the text with a tag name instead.\n      */\n      for (i=0; ; i++)\n      {\n        if (EXIFTag[i].tag == 0)\n          break;\n        if (LocaleCompare(EXIFTag[i].description,property) == 0)\n          {\n            tag=(size_t) EXIFTag[i].tag;\n            break;\n          }\n      }\n      break;\n    }\n  }\n  if (tag == (~0UL))\n    return(MagickFalse);\n  length=GetStringInfoLength(profile);\n  exif=GetStringInfoDatum(profile);\n  while (length != 0)\n  {\n    if (ReadPropertyByte(&exif,&length) != 0x45)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x78)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x69)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x66)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x00)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x00)\n      continue;\n    break;\n  }\n  if (length < 16)\n    return(MagickFalse);\n  id=(ssize_t) ReadPropertySignedShort(LSBEndian,exif);\n  endian=LSBEndian;\n  if (id == 0x4949)\n    endian=LSBEndian;\n  else\n    if (id == 0x4D4D)\n      endian=MSBEndian;\n    else\n      return(MagickFalse);\n  if (ReadPropertyUnsignedShort(endian,exif+2) != 0x002a)\n    return(MagickFalse);\n  /*\n    This the offset to the first IFD.\n  */\n  offset=(ssize_t) ReadPropertySignedLong(endian,exif+4);\n  if ((offset < 0) || (size_t) offset >= length)\n    return(MagickFalse);\n  /*\n    Set the pointer to the first IFD and follow it were it leads.\n  */\n  status=MagickFalse;\n  directory=exif+offset;\n  level=0;\n  entry=0;\n  tag_offset=0;\n  exif_resources=NewSplayTree((int (*)(const void *,const void *)) NULL,\n    (void *(*)(void *)) NULL,(void *(*)(void *)) NULL);\n  do\n  {\n    /*\n      If there is anything on the stack then pop it off.\n    */\n    if (level > 0)\n      {\n        level--;\n        directory=directory_stack[level].directory;\n        entry=directory_stack[level].entry;\n        tag_offset=directory_stack[level].offset;\n      }\n    if ((directory < exif) || (directory > (exif+length-2)))\n      break;\n    /*\n      Determine how many entries there are in the current IFD.\n    */\n    number_entries=(size_t) ReadPropertyUnsignedShort(endian,directory);\n    for ( ; entry < number_entries; entry++)\n    {\n      register unsigned char\n        *p,\n        *q;\n\n      size_t\n        format;\n\n      ssize_t\n        number_bytes,\n        components;\n\n      q=(unsigned char *) (directory+(12*entry)+2);\n      if (q > (exif+length-12))\n        break;  /* corrupt EXIF */\n      if (GetValueFromSplayTree(exif_resources,q) == q)\n        break;\n      (void) AddValueToSplayTree(exif_resources,q,q);\n      tag_value=(size_t) ReadPropertyUnsignedShort(endian,q)+tag_offset;\n      format=(size_t) ReadPropertyUnsignedShort(endian,q+2);\n      if (format >= (sizeof(tag_bytes)/sizeof(*tag_bytes)))\n        break;\n      components=(ssize_t) ReadPropertySignedLong(endian,q+4);\n      if (components < 0)\n        break;  /* corrupt EXIF */\n      number_bytes=(size_t) components*tag_bytes[format];\n      if (number_bytes < components)\n        break;  /* prevent overflow */\n      if (number_bytes <= 4)\n        p=q+8;\n      else\n        {\n          ssize_t\n            offset;\n\n          /*\n            The directory entry contains an offset.\n          */\n          offset=(ssize_t) ReadPropertySignedLong(endian,q+8);\n          if ((offset < 0) || (size_t) offset >= length)\n            continue;\n          if ((ssize_t) (offset+number_bytes) < offset)\n            continue;  /* prevent overflow */\n          if ((size_t) (offset+number_bytes) > length)\n            continue;\n          p=(unsigned char *) (exif+offset);\n        }\n      if ((all != 0) || (tag == (size_t) tag_value))\n        {\n          char\n            buffer[MagickPathExtent],\n            *value;\n\n          value=(char *) NULL;\n          *buffer='\\0';\n          switch (format)\n          {\n            case EXIF_FMT_BYTE:\n            case EXIF_FMT_UNDEFINED:\n            {\n              EXIFMultipleValues(1,\"%.20g\",(double) (*(unsigned char *) p1));\n              break;\n            }\n            case EXIF_FMT_SBYTE:\n            {\n              EXIFMultipleValues(1,\"%.20g\",(double) (*(signed char *) p1));\n              break;\n            }\n            case EXIF_FMT_SSHORT:\n            {\n              EXIFMultipleValues(2,\"%hd\",ReadPropertySignedShort(endian,p1));\n              break;\n            }\n            case EXIF_FMT_USHORT:\n            {\n              EXIFMultipleValues(2,\"%hu\",ReadPropertyUnsignedShort(endian,p1));\n              break;\n            }\n            case EXIF_FMT_ULONG:\n            {\n              EXIFMultipleValues(4,\"%.20g\",(double)\n                ReadPropertyUnsignedLong(endian,p1));\n              break;\n            }\n            case EXIF_FMT_SLONG:\n            {\n              EXIFMultipleValues(4,\"%.20g\",(double)\n                ReadPropertySignedLong(endian,p1));\n              break;\n            }\n            case EXIF_FMT_URATIONAL:\n            {\n              EXIFMultipleFractions(8,\"%.20g/%.20g\",(double)\n                ReadPropertyUnsignedLong(endian,p1),(double)\n                ReadPropertyUnsignedLong(endian,p1+4));\n              break;\n            }\n            case EXIF_FMT_SRATIONAL:\n            {\n              EXIFMultipleFractions(8,\"%.20g/%.20g\",(double)\n                ReadPropertySignedLong(endian,p1),(double)\n                ReadPropertySignedLong(endian,p1+4));\n              break;\n            }\n            case EXIF_FMT_SINGLE:\n            {\n              EXIFMultipleValues(4,\"%f\",(double) *(float *) p1);\n              break;\n            }\n            case EXIF_FMT_DOUBLE:\n            {\n              EXIFMultipleValues(8,\"%f\",*(double *) p1);\n              break;\n            }\n            default:\n            case EXIF_FMT_STRING:\n            {\n              value=(char *) NULL;\n              if (~((size_t) number_bytes) >= 1)\n                value=(char *) AcquireQuantumMemory((size_t) number_bytes+1UL,\n                  sizeof(*value));\n              if (value != (char *) NULL)\n                {\n                  register ssize_t\n                    i;\n\n                  for (i=0; i < (ssize_t) number_bytes; i++)\n                  {\n                    value[i]='.';\n                    if ((isprint((int) p[i]) != 0) || (p[i] == '\\0'))\n                      value[i]=(char) p[i];\n                  }\n                  value[i]='\\0';\n                }\n              break;\n            }\n          }\n          if (value != (char *) NULL)\n            {\n              char\n                *key;\n\n              register const char\n                *p;\n\n              key=AcquireString(property);\n              switch (all)\n              {\n                case 1:\n                {\n                  const char\n                    *description;\n\n                  register ssize_t\n                    i;\n\n                  description=\"unknown\";\n                  for (i=0; ; i++)\n                  {\n                    if (EXIFTag[i].tag == 0)\n                      break;\n                    if (EXIFTag[i].tag == tag_value)\n                      {\n                        description=EXIFTag[i].description;\n                        break;\n                      }\n                  }\n                  (void) FormatLocaleString(key,MagickPathExtent,\"%s\",\n                    description);\n                  if (level == 2)\n                    (void) SubstituteString(&key,\"exif:\",\"exif:thumbnail:\");\n                  break;\n                }\n                case 2:\n                {\n                  if (tag_value < 0x10000)\n                    (void) FormatLocaleString(key,MagickPathExtent,\"#%04lx\",\n                      (unsigned long) tag_value);\n                  else\n                    if (tag_value < 0x20000)\n                      (void) FormatLocaleString(key,MagickPathExtent,\"@%04lx\",\n                        (unsigned long) (tag_value & 0xffff));\n                    else\n                      (void) FormatLocaleString(key,MagickPathExtent,\"unknown\");\n                  break;\n                }\n                default:\n                {\n                  if (level == 2)\n                    (void) SubstituteString(&key,\"exif:\",\"exif:thumbnail:\");\n                }\n              }\n              p=(const char *) NULL;\n              if (image->properties != (void *) NULL)\n                p=(const char *) GetValueFromSplayTree((SplayTreeInfo *)\n                  image->properties,key);\n              if (p == (const char *) NULL)\n                (void) SetImageProperty((Image *) image,key,value,exception);\n              value=DestroyString(value);\n              key=DestroyString(key);\n              status=MagickTrue;\n            }\n        }\n        if ((tag_value == TAG_EXIF_OFFSET) ||\n            (tag_value == TAG_INTEROP_OFFSET) || (tag_value == TAG_GPS_OFFSET))\n          {\n            ssize_t\n              offset;\n\n            offset=(ssize_t) ReadPropertySignedLong(endian,p);\n            if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))\n              {\n                ssize_t\n                  tag_offset1;\n\n                tag_offset1=(ssize_t) ((tag_value == TAG_GPS_OFFSET) ? 0x10000 :\n                  0);\n                directory_stack[level].directory=directory;\n                entry++;\n                directory_stack[level].entry=entry;\n                directory_stack[level].offset=tag_offset;\n                level++;\n                directory_stack[level].directory=exif+offset;\n                directory_stack[level].offset=tag_offset1;\n                directory_stack[level].entry=0;\n                level++;\n                if ((directory+2+(12*number_entries)) > (exif+length))\n                  break;\n                offset=(ssize_t) ReadPropertySignedLong(endian,directory+2+(12*\n                  number_entries));\n                if ((offset != 0) && ((size_t) offset < length) &&\n                    (level < (MaxDirectoryStack-2)))\n                  {\n                    directory_stack[level].directory=exif+offset;\n                    directory_stack[level].entry=0;\n                    directory_stack[level].offset=tag_offset1;\n                    level++;\n                  }\n              }\n            break;\n          }\n    }\n  } while (level > 0);\n  exif_resources=DestroySplayTree(exif_resources);\n  return(status);\n}\n\nstatic MagickBooleanType GetICCProperty(const Image *image,const char *property,\n  ExceptionInfo *exception)\n{\n  const StringInfo\n    *profile;\n\n  magick_unreferenced(property);\n\n  profile=GetImageProfile(image,\"icc\");\n  if (profile == (StringInfo *) NULL)\n    profile=GetImageProfile(image,\"icm\");\n  if (profile == (StringInfo *) NULL)\n    return(MagickFalse);\n  if (GetStringInfoLength(profile) < 128)\n    return(MagickFalse);  /* minimum ICC profile length */\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n  {\n    cmsHPROFILE\n      icc_profile;\n\n    icc_profile=cmsOpenProfileFromMem(GetStringInfoDatum(profile),\n      (cmsUInt32Number) GetStringInfoLength(profile));\n    if (icc_profile != (cmsHPROFILE *) NULL)\n      {\n#if defined(LCMS_VERSION) && (LCMS_VERSION < 2000)\n        const char\n          *name;\n\n        name=cmsTakeProductName(icc_profile);\n        if (name != (const char *) NULL)\n          (void) SetImageProperty((Image *) image,\"icc:name\",name,exception);\n#else\n        char\n          info[MagickPathExtent];\n\n        (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoDescription,\"en\",\"US\",\n          info,MagickPathExtent);\n        (void) SetImageProperty((Image *) image,\"icc:description\",info,\n          exception);\n        (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoManufacturer,\"en\",\"US\",\n          info,MagickPathExtent);\n        (void) SetImageProperty((Image *) image,\"icc:manufacturer\",info,\n          exception);\n        (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoModel,\"en\",\"US\",info,\n          MagickPathExtent);\n        (void) SetImageProperty((Image *) image,\"icc:model\",info,exception);\n        (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoCopyright,\"en\",\"US\",\n          info,MagickPathExtent);\n        (void) SetImageProperty((Image *) image,\"icc:copyright\",info,exception);\n#endif\n        (void) cmsCloseProfile(icc_profile);\n      }\n  }\n#endif\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType SkipXMPValue(const char *value)\n{\n  if (value == (const char*) NULL)\n    return(MagickTrue);\n  while (*value != '\\0')\n  {\n    if (isspace((int) ((unsigned char) *value)) == 0)\n      return(MagickFalse);\n    value++;\n  }\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType GetXMPProperty(const Image *image,const char *property)\n{\n  char\n    *xmp_profile;\n\n  const char\n    *content;\n\n  const StringInfo\n    *profile;\n\n  ExceptionInfo\n    *exception;\n\n  MagickBooleanType\n    status;\n\n  register const char\n    *p;\n\n  XMLTreeInfo\n    *child,\n    *description,\n    *node,\n    *rdf,\n    *xmp;\n\n  profile=GetImageProfile(image,\"xmp\");\n  if (profile == (StringInfo *) NULL)\n    return(MagickFalse);\n  if ((property == (const char *) NULL) || (*property == '\\0'))\n    return(MagickFalse);\n  xmp_profile=StringInfoToString(profile);\n  if (xmp_profile == (char *) NULL)\n    return(MagickFalse);\n  for (p=xmp_profile; *p != '\\0'; p++)\n    if ((*p == '<') && (*(p+1) == 'x'))\n      break;\n  exception=AcquireExceptionInfo();\n  xmp=NewXMLTree((char *) p,exception);\n  xmp_profile=DestroyString(xmp_profile);\n  exception=DestroyExceptionInfo(exception);\n  if (xmp == (XMLTreeInfo *) NULL)\n    return(MagickFalse);\n  status=MagickFalse;\n  rdf=GetXMLTreeChild(xmp,\"rdf:RDF\");\n  if (rdf != (XMLTreeInfo *) NULL)\n    {\n      if (image->properties == (void *) NULL)\n        ((Image *) image)->properties=NewSplayTree(CompareSplayTreeString,\n          RelinquishMagickMemory,RelinquishMagickMemory);\n      description=GetXMLTreeChild(rdf,\"rdf:Description\");\n      while (description != (XMLTreeInfo *) NULL)\n      {\n        node=GetXMLTreeChild(description,(const char *) NULL);\n        while (node != (XMLTreeInfo *) NULL)\n        {\n          child=GetXMLTreeChild(node,(const char *) NULL);\n          content=GetXMLTreeContent(node);\n          if ((child == (XMLTreeInfo *) NULL) &&\n              (SkipXMPValue(content) == MagickFalse))\n            (void) AddValueToSplayTree((SplayTreeInfo *) image->properties,\n              ConstantString(GetXMLTreeTag(node)),ConstantString(content));\n          while (child != (XMLTreeInfo *) NULL)\n          {\n            content=GetXMLTreeContent(child);\n            if (SkipXMPValue(content) == MagickFalse)\n              (void) AddValueToSplayTree((SplayTreeInfo *) image->properties,\n                ConstantString(GetXMLTreeTag(child)),ConstantString(content));\n            child=GetXMLTreeSibling(child);\n          }\n          node=GetXMLTreeSibling(node);\n        }\n        description=GetNextXMLTreeTag(description);\n      }\n    }\n  xmp=DestroyXMLTree(xmp);\n  return(status);\n}\n\nstatic char *TracePSClippath(const unsigned char *blob,size_t length)\n{\n  char\n    *path,\n    *message;\n\n  MagickBooleanType\n    in_subpath;\n\n  PointInfo\n    first[3],\n    last[3],\n    point[3];\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    knot_count,\n    selector,\n    y;\n\n  path=AcquireString((char *) NULL);\n  if (path == (char *) NULL)\n    return((char *) NULL);\n  message=AcquireString((char *) NULL);\n  (void) FormatLocaleString(message,MagickPathExtent,\"/ClipImage\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"{\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"  /c {curveto} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"  /l {lineto} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"  /m {moveto} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"  /v {currentpoint 6 2 roll curveto} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"  /y {2 copy curveto} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"  /z {closepath} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"  newpath\\n\");\n  (void) ConcatenateString(&path,message);\n  /*\n    The clipping path format is defined in \"Adobe Photoshop File Formats\n    Specification\" version 6.0 downloadable from adobe.com.\n  */\n  (void) ResetMagickMemory(point,0,sizeof(point));\n  (void) ResetMagickMemory(first,0,sizeof(first));\n  (void) ResetMagickMemory(last,0,sizeof(last));\n  knot_count=0;\n  in_subpath=MagickFalse;\n  while (length > 0)\n  {\n    selector=(ssize_t) ReadPropertyMSBShort(&blob,&length);\n    switch (selector)\n    {\n      case 0:\n      case 3:\n      {\n        if (knot_count != 0)\n          {\n            blob+=24;\n            length-=MagickMin(24,(ssize_t) length);\n            break;\n          }\n        /*\n          Expected subpath length record.\n        */\n        knot_count=(ssize_t) ReadPropertyMSBShort(&blob,&length);\n        blob+=22;\n        length-=MagickMin(22,(ssize_t) length);\n        break;\n      }\n      case 1:\n      case 2:\n      case 4:\n      case 5:\n      {\n        if (knot_count == 0)\n          {\n            /*\n              Unexpected subpath knot\n            */\n            blob+=24;\n            length-=MagickMin(24,(ssize_t) length);\n            break;\n          }\n        /*\n          Add sub-path knot\n        */\n        for (i=0; i < 3; i++)\n        {\n          size_t\n            xx,\n            yy;\n\n          yy=(size_t) ReadPropertyMSBLong(&blob,&length);\n          xx=(size_t) ReadPropertyMSBLong(&blob,&length);\n          x=(ssize_t) xx;\n          if (xx > 2147483647)\n            x=(ssize_t) xx-4294967295U-1;\n          y=(ssize_t) yy;\n          if (yy > 2147483647)\n            y=(ssize_t) yy-4294967295U-1;\n          point[i].x=(double) x/4096/4096;\n          point[i].y=1.0-(double) y/4096/4096;\n        }\n        if (in_subpath == MagickFalse)\n          {\n            (void) FormatLocaleString(message,MagickPathExtent,\"  %g %g m\\n\",\n              point[1].x,point[1].y);\n            for (i=0; i < 3; i++)\n            {\n              first[i]=point[i];\n              last[i]=point[i];\n            }\n          }\n        else\n          {\n            /*\n              Handle special cases when Bezier curves are used to describe\n              corners and straight lines.\n            */\n            if ((last[1].x == last[2].x) && (last[1].y == last[2].y) &&\n                (point[0].x == point[1].x) && (point[0].y == point[1].y))\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"  %g %g l\\n\",point[1].x,point[1].y);\n            else\n              if ((last[1].x == last[2].x) && (last[1].y == last[2].y))\n                (void) FormatLocaleString(message,MagickPathExtent,\n                  \"  %g %g %g %g v\\n\",point[0].x,point[0].y,\n                  point[1].x,point[1].y);\n              else\n                if ((point[0].x == point[1].x) && (point[0].y == point[1].y))\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"  %g %g %g %g y\\n\",last[2].x,last[2].y,\n                    point[1].x,point[1].y);\n                else\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"  %g %g %g %g %g %g c\\n\",last[2].x,\n                    last[2].y,point[0].x,point[0].y,point[1].x,point[1].y);\n            for (i=0; i < 3; i++)\n              last[i]=point[i];\n          }\n        (void) ConcatenateString(&path,message);\n        in_subpath=MagickTrue;\n        knot_count--;\n        /*\n          Close the subpath if there are no more knots.\n        */\n        if (knot_count == 0)\n          {\n            /*\n              Same special handling as above except we compare to the\n              first point in the path and close the path.\n            */\n            if ((last[1].x == last[2].x) && (last[1].y == last[2].y) &&\n                (first[0].x == first[1].x) && (first[0].y == first[1].y))\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"  %g %g l z\\n\",first[1].x,first[1].y);\n            else\n              if ((last[1].x == last[2].x) && (last[1].y == last[2].y))\n                (void) FormatLocaleString(message,MagickPathExtent,\n                  \"  %g %g %g %g v z\\n\",first[0].x,first[0].y,\n                  first[1].x,first[1].y);\n              else\n                if ((first[0].x == first[1].x) && (first[0].y == first[1].y))\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"  %g %g %g %g y z\\n\",last[2].x,last[2].y,\n                    first[1].x,first[1].y);\n                else\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"  %g %g %g %g %g %g c z\\n\",last[2].x,\n                    last[2].y,first[0].x,first[0].y,first[1].x,first[1].y);\n            (void) ConcatenateString(&path,message);\n            in_subpath=MagickFalse;\n          }\n        break;\n      }\n      case 6:\n      case 7:\n      case 8:\n      default:\n      {\n        blob+=24;\n        length-=MagickMin(24,(ssize_t) length);\n        break;\n      }\n    }\n  }\n  /*\n    Returns an empty PS path if the path has no knots.\n  */\n  (void) FormatLocaleString(message,MagickPathExtent,\"  eoclip\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"} bind def\");\n  (void) ConcatenateString(&path,message);\n  message=DestroyString(message);\n  return(path);\n}\n\nstatic char *TraceSVGClippath(const unsigned char *blob,size_t length,\n  const size_t columns,const size_t rows)\n{\n  char\n    *path,\n    *message;\n\n  MagickBooleanType\n    in_subpath;\n\n  PointInfo\n    first[3],\n    last[3],\n    point[3];\n\n  register ssize_t\n    i;\n\n  ssize_t\n    knot_count,\n    selector,\n    x,\n    y;\n\n  path=AcquireString((char *) NULL);\n  if (path == (char *) NULL)\n    return((char *) NULL);\n  message=AcquireString((char *) NULL);\n  (void) FormatLocaleString(message,MagickPathExtent,(\n    \"<?xml version=\\\"1.0\\\" encoding=\\\"iso-8859-1\\\"?>\\n\"\n    \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\"\"\n    \" width=\\\"%.20g\\\" height=\\\"%.20g\\\">\\n\"\n    \"<g>\\n\"\n    \"<path fill-rule=\\\"evenodd\\\" style=\\\"fill:#00000000;stroke:#00000000;\"\n    \"stroke-width:0;stroke-antialiasing:false\\\" d=\\\"\\n\"),(double) columns,\n    (double) rows);\n  (void) ConcatenateString(&path,message);\n  (void) ResetMagickMemory(point,0,sizeof(point));\n  (void) ResetMagickMemory(first,0,sizeof(first));\n  (void) ResetMagickMemory(last,0,sizeof(last));\n  knot_count=0;\n  in_subpath=MagickFalse;\n  while (length != 0)\n  {\n    selector=(ssize_t) ReadPropertyMSBShort(&blob,&length);\n    switch (selector)\n    {\n      case 0:\n      case 3:\n      {\n        if (knot_count != 0)\n          {\n            blob+=24;\n            length-=MagickMin(24,(ssize_t) length);\n            break;\n          }\n        /*\n          Expected subpath length record.\n        */\n        knot_count=(ssize_t) ReadPropertyMSBShort(&blob,&length);\n        blob+=22;\n        length-=MagickMin(22,(ssize_t) length);\n        break;\n      }\n      case 1:\n      case 2:\n      case 4:\n      case 5:\n      {\n        if (knot_count == 0)\n          {\n            /*\n              Unexpected subpath knot.\n            */\n            blob+=24;\n            length-=MagickMin(24,(ssize_t) length);\n            break;\n          }\n        /*\n          Add sub-path knot\n        */\n        for (i=0; i < 3; i++)\n        {\n          unsigned int\n            xx,\n            yy;\n\n          yy=(unsigned int) ReadPropertyMSBLong(&blob,&length);\n          xx=(unsigned int) ReadPropertyMSBLong(&blob,&length);\n          x=(ssize_t) xx;\n          if (xx > 2147483647)\n            x=(ssize_t) xx-4294967295U-1;\n          y=(ssize_t) yy;\n          if (yy > 2147483647)\n            y=(ssize_t) yy-4294967295U-1;\n          point[i].x=(double) x*columns/4096/4096;\n          point[i].y=(double) y*rows/4096/4096;\n        }\n        if (in_subpath == MagickFalse)\n          {\n            (void) FormatLocaleString(message,MagickPathExtent,\"M %g %g\\n\",\n              point[1].x,point[1].y);\n            for (i=0; i < 3; i++)\n            {\n              first[i]=point[i];\n              last[i]=point[i];\n            }\n          }\n        else\n          {\n            /*\n              Handle special cases when Bezier curves are used to describe\n              corners and straight lines.\n            */\n            if ((last[1].x == last[2].x) && (last[1].y == last[2].y) &&\n                (point[0].x == point[1].x) && (point[0].y == point[1].y))\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"L %g %g\\n\",point[1].x,point[1].y);\n            else\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"C %g %g %g %g %g %g\\n\",last[2].x,\n                last[2].y,point[0].x,point[0].y,point[1].x,point[1].y);\n            for (i=0; i < 3; i++)\n              last[i]=point[i];\n          }\n        (void) ConcatenateString(&path,message);\n        in_subpath=MagickTrue;\n        knot_count--;\n        /*\n          Close the subpath if there are no more knots.\n        */\n        if (knot_count == 0)\n          {\n           /*\n              Same special handling as above except we compare to the\n              first point in the path and close the path.\n            */\n            if ((last[1].x == last[2].x) && (last[1].y == last[2].y) &&\n                (first[0].x == first[1].x) && (first[0].y == first[1].y))\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"L %g %g Z\\n\",first[1].x,first[1].y);\n            else\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"C %g %g %g %g %g %g Z\\n\",last[2].x,\n                last[2].y,first[0].x,first[0].y,first[1].x,first[1].y);\n            (void) ConcatenateString(&path,message);\n            in_subpath=MagickFalse;\n          }\n        break;\n      }\n      case 6:\n      case 7:\n      case 8:\n      default:\n      {\n        blob+=24;\n        length-=MagickMin(24,(ssize_t) length);\n        break;\n      }\n    }\n  }\n  /*\n    Return an empty SVG image if the path does not have knots.\n  */\n  (void) ConcatenateString(&path,\"\\\"/>\\n</g>\\n</svg>\\n\");\n  message=DestroyString(message);\n  return(path);\n}\n\nMagickExport const char *GetImageProperty(const Image *image,\n  const char *property,ExceptionInfo *exception)\n{\n  register const char\n    *p;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  p=(const char *) NULL;\n  if (image->properties != (void *) NULL)\n    {\n      if (property == (const char *) NULL)\n        {\n          ResetSplayTreeIterator((SplayTreeInfo *) image->properties);\n          p=(const char *) GetNextValueInSplayTree((SplayTreeInfo *)\n            image->properties);\n          return(p);\n        }\n        p=(const char *) GetValueFromSplayTree((SplayTreeInfo *)\n          image->properties,property);\n        if (p != (const char *) NULL)\n          return(p);\n    }\n  if ((property == (const char *) NULL) ||\n      (strchr(property,':') == (char *) NULL))\n    return(p);\n  switch (*property)\n  {\n    case '8':\n    {\n      if (LocaleNCompare(\"8bim:\",property,5) == 0)\n        {\n          (void) Get8BIMProperty(image,property,exception);\n          break;\n        }\n      break;\n    }\n    case 'E':\n    case 'e':\n    {\n      if (LocaleNCompare(\"exif:\",property,5) == 0)\n        {\n          (void) GetEXIFProperty(image,property,exception);\n          break;\n        }\n      break;\n    }\n    case 'I':\n    case 'i':\n    {\n      if ((LocaleNCompare(\"icc:\",property,4) == 0) ||\n          (LocaleNCompare(\"icm:\",property,4) == 0))\n        {\n          (void) GetICCProperty(image,property,exception);\n          break;\n        }\n      if (LocaleNCompare(\"iptc:\",property,5) == 0)\n        {\n          (void) GetIPTCProperty(image,property,exception);\n          break;\n        }\n      break;\n    }\n    case 'X':\n    case 'x':\n    {\n      if (LocaleNCompare(\"xmp:\",property,4) == 0)\n        {\n          (void) GetXMPProperty(image,property);\n          break;\n        }\n      break;\n    }\n    default:\n      break;\n  }\n  if (image->properties != (void *) NULL)\n    {\n      p=(const char *) GetValueFromSplayTree((SplayTreeInfo *)\n        image->properties,property);\n      return(p);\n    }\n  return((const char *) NULL);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t M a g i c k P r o p e r t y                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetMagickProperty() gets attributes or calculated values that is associated\n%  with a fixed known property name, or single letter property. It may be\n%  called if no image is defined (IMv7), in which case only global image_info\n%  values are available:\n%\n%    \\n   newline\n%    \\r   carriage return\n%    <    less-than character.\n%    >    greater-than character.\n%    &    ampersand character.\n%    %%   a percent sign\n%    %b   file size of image read in\n%    %c   comment meta-data property\n%    %d   directory component of path\n%    %e   filename extension or suffix\n%    %f   filename (including suffix)\n%    %g   layer canvas page geometry   (equivalent to \"%Wx%H%X%Y\")\n%    %h   current image height in pixels\n%    %i   image filename (note: becomes output filename for \"info:\")\n%    %k   CALCULATED: number of unique colors\n%    %l   label meta-data property\n%    %m   image file format (file magic)\n%    %n   number of images in current image sequence\n%    %o   output filename  (used for delegates)\n%    %p   index of image in current image list\n%    %q   quantum depth (compile-time constant)\n%    %r   image class and colorspace\n%    %s   scene number (from input unless re-assigned)\n%    %t   filename without directory or extension (suffix)\n%    %u   unique temporary filename (used for delegates)\n%    %w   current width in pixels\n%    %x   x resolution (density)\n%    %y   y resolution (density)\n%    %z   image depth (as read in unless modified, image save depth)\n%    %A   image transparency channel enabled (true/false)\n%    %C   image compression type\n%    %D   image GIF dispose method\n%    %G   original image size (%wx%h; before any resizes)\n%    %H   page (canvas) height\n%    %M   Magick filename (original file exactly as given,  including read mods)\n%    %O   page (canvas) offset ( = %X%Y )\n%    %P   page (canvas) size ( = %Wx%H )\n%    %Q   image compression quality ( 0 = default )\n%    %S   ?? scenes ??\n%    %T   image time delay (in centi-seconds)\n%    %U   image resolution units\n%    %W   page (canvas) width\n%    %X   page (canvas) x offset (including sign)\n%    %Y   page (canvas) y offset (including sign)\n%    %Z   unique filename (used for delegates)\n%    %@   CALCULATED: trim bounding box (without actually trimming)\n%    %#   CALCULATED: 'signature' hash of image values\n%\n%  This routine only handles specifically known properties.  It does not\n%  handle special prefixed properties, profiles, or expressions. Nor does\n%  it return any free-form property strings.\n%\n%  The returned string is stored in a structure somewhere, and should not be\n%  directly freed.  If the string was generated (common) the string will be\n%  stored as as either as artifact or option 'get-property'.  These may be\n%  deleted (cleaned up) when no longer required, but neither artifact or\n%  option is guranteed to exist.\n%\n%  The format of the GetMagickProperty method is:\n%\n%      const char *GetMagickProperty(ImageInfo *image_info,Image *image,\n%        const char *property,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info (optional)\n%\n%    o image: the image (optional)\n%\n%    o key: the key.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic const char *GetMagickPropertyLetter(ImageInfo *image_info,\n  Image *image,const char letter,ExceptionInfo *exception)\n{\n#define WarnNoImageReturn(format,arg) \\\n  if (image == (Image *) NULL ) { \\\n    (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning, \\\n      \"NoImageForProperty\",format,arg); \\\n    return((const char *) NULL); \\\n  }\n#define WarnNoImageInfoReturn(format,arg) \\\n  if (image_info == (ImageInfo *) NULL ) { \\\n    (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning, \\\n      \"NoImageInfoForProperty\",format,arg); \\\n    return((const char *) NULL); \\\n  }\n\n  char\n    value[MagickPathExtent];  /* formatted string to store as an artifact */\n\n  const char\n    *string;     /* return a string already stored somewher */\n\n  if ((image != (Image *) NULL) && (image->debug != MagickFalse))\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  else\n    if ((image_info != (ImageInfo *) NULL) &&\n        (image_info->debug != MagickFalse))\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\"no-images\");\n  *value='\\0';           /* formatted string */\n  string=(char *) NULL;  /* constant string reference */\n  /*\n    Get properities that are directly defined by images.\n  */\n  switch (letter)\n  {\n    case 'b':  /* image size read in - in bytes */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatMagickSize(image->extent,MagickFalse,\"B\",MagickPathExtent,\n        value);\n      if (image->extent == 0)\n        (void) FormatMagickSize(GetBlobSize(image),MagickFalse,\"B\",\n          MagickPathExtent,value);\n      break;\n    }\n    case 'c':  /* image comment property - empty string by default */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=GetImageProperty(image,\"comment\",exception);\n      if ( string == (const char *) NULL )\n        string=\"\";\n      break;\n    }\n    case 'd':  /* Directory component of filename */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      GetPathComponent(image->magick_filename,HeadPath,value);\n      if (*value == '\\0')\n        string=\"\";\n      break;\n    }\n    case 'e': /* Filename extension (suffix) of image file */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      GetPathComponent(image->magick_filename,ExtensionPath,value);\n      if (*value == '\\0')\n        string=\"\";\n      break;\n    }\n    case 'f': /* Filename without directory component */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      GetPathComponent(image->magick_filename,TailPath,value);\n      if (*value == '\\0')\n        string=\"\";\n      break;\n    }\n    case 'g': /* Image geometry, canvas and offset  %Wx%H+%X+%Y */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\n        \"%.20gx%.20g%+.20g%+.20g\",(double) image->page.width,(double)\n        image->page.height,(double) image->page.x,(double) image->page.y);\n      break;\n    }\n    case 'h': /* Image height (current) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        (image->rows != 0 ? image->rows : image->magick_rows));\n      break;\n    }\n    case 'i': /* Filename last used for an image (read or write) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=image->filename;\n      break;\n    }\n    case 'k': /* Number of unique colors  */\n    {\n      /*\n        FUTURE: ensure this does not generate the formatted comment!\n      */\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        GetNumberColors(image,(FILE *) NULL,exception));\n      break;\n    }\n    case 'l': /* Image label property - empty string by default */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=GetImageProperty(image,\"label\",exception);\n      if (string == (const char *) NULL)\n        string=\"\";\n      break;\n    }\n    case 'm': /* Image format (file magick) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=image->magick;\n      break;\n    }\n    case 'n': /* Number of images in the list.  */\n    {\n      if ( image != (Image *) NULL )\n        (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n          GetImageListLength(image));\n      else\n        string=\"0\";    /* no images or scenes */\n      break;\n    }\n    case 'o': /* Output Filename - for delegate use only */\n      WarnNoImageInfoReturn(\"\\\"%%%c\\\"\",letter);\n      string=image_info->filename;\n      break;\n    case 'p': /* Image index in current image list */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        GetImageIndexInList(image));\n      break;\n    }\n    case 'q': /* Quantum depth of image in memory */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        MAGICKCORE_QUANTUM_DEPTH);\n      break;\n    }\n    case 'r': /* Image storage class, colorspace, and alpha enabled.  */\n    {\n      ColorspaceType\n        colorspace;\n\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      colorspace=image->colorspace;\n      if (SetImageGray(image,exception) != MagickFalse)\n        colorspace=GRAYColorspace;   /* FUTURE: this is IMv6 not IMv7 */\n      (void) FormatLocaleString(value,MagickPathExtent,\"%s %s %s\",\n        CommandOptionToMnemonic(MagickClassOptions,(ssize_t)\n        image->storage_class),CommandOptionToMnemonic(MagickColorspaceOptions,\n        (ssize_t) colorspace),image->alpha_trait != UndefinedPixelTrait ?\n        \"Alpha\" : \"\");\n      break;\n    }\n    case 's': /* Image scene number */\n    {\n#if 0  /* this seems non-sensical -- simplifing */\n      if (image_info->number_scenes != 0)\n        (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n          image_info->scene);\n      else if (image != (Image *) NULL)\n        (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n          image->scene);\n      else\n          string=\"0\";\n#else\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n         image->scene);\n#endif\n      break;\n    }\n    case 't': /* Base filename without directory or extention */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      GetPathComponent(image->magick_filename,BasePath,value);\n      if (*value == '\\0')\n        string=\"\";\n      break;\n    }\n    case 'u': /* Unique filename */\n    {\n      WarnNoImageInfoReturn(\"\\\"%%%c\\\"\",letter);\n      string=image_info->unique;\n      break;\n    }\n    case 'w': /* Image width (current) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        (image->columns != 0 ? image->columns : image->magick_columns));\n      break;\n    }\n    case 'x': /* Image horizontal resolution (with units) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",\n        fabs(image->resolution.x) > MagickEpsilon ? image->resolution.x : 72.0);\n      break;\n    }\n    case 'y': /* Image vertical resolution (with units) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",\n        fabs(image->resolution.y) > MagickEpsilon ? image->resolution.y : 72.0);\n      break;\n    }\n    case 'z': /* Image depth as read in */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        image->depth);\n      break;\n    }\n    case 'A': /* Image alpha channel  */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=CommandOptionToMnemonic(MagickPixelTraitOptions,(ssize_t)\n        image->alpha_trait);\n      break;\n    }\n    case 'C': /* Image compression method.  */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=CommandOptionToMnemonic(MagickCompressOptions,(ssize_t)\n        image->compression);\n      break;\n    }\n    case 'D': /* Image dispose method.  */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=CommandOptionToMnemonic(MagickDisposeOptions,(ssize_t)\n        image->dispose);\n      break;\n    }\n    case 'G': /* Image size as geometry = \"%wx%h\" */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20gx%.20g\",(double)\n        image->magick_columns,(double) image->magick_rows);\n      break;\n    }\n    case 'H': /* layer canvas height */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        image->page.height);\n      break;\n    }\n    case 'M': /* Magick filename - filename given incl. coder & read mods */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=image->magick_filename;\n      break;\n    }\n    case 'O': /* layer canvas offset with sign = \"+%X+%Y\" */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%+ld%+ld\",(long)\n        image->page.x,(long) image->page.y);\n      break;\n    }\n    case 'P': /* layer canvas page size = \"%Wx%H\" */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20gx%.20g\",(double)\n        image->page.width,(double) image->page.height);\n      break;\n    }\n    case 'Q': /* image compression quality */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        (image->quality == 0 ? 92 : image->quality));\n      break;\n    }\n    case 'S': /* Number of scenes in image list.  */\n    {\n      WarnNoImageInfoReturn(\"\\\"%%%c\\\"\",letter);\n#if 0 /* What is this number? -- it makes no sense - simplifing */\n      if (image_info->number_scenes == 0)\n         string=\"2147483647\";\n      else if ( image != (Image *) NULL )\n        (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n                image_info->scene+image_info->number_scenes);\n      else\n        string=\"0\";\n#else\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        (image_info->number_scenes == 0 ? 2147483647 :\n         image_info->number_scenes));\n#endif\n      break;\n    }\n    case 'T': /* image time delay for animations */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        image->delay);\n      break;\n    }\n    case 'U': /* Image resolution units. */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=CommandOptionToMnemonic(MagickResolutionOptions,(ssize_t)\n        image->units);\n      break;\n    }\n    case 'W': /* layer canvas width */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        image->page.width);\n      break;\n    }\n    case 'X': /* layer canvas X offset */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%+.20g\",(double)\n        image->page.x);\n      break;\n    }\n    case 'Y': /* layer canvas Y offset */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%+.20g\",(double)\n        image->page.y);\n      break;\n    }\n    case '%': /* percent escaped */\n    {\n      string=\"%\";\n      break;\n    }\n    case '@': /* Trim bounding box, without actually Trimming! */\n    {\n      RectangleInfo\n        page;\n\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      page=GetImageBoundingBox(image,exception);\n      (void) FormatLocaleString(value,MagickPathExtent,\n        \"%.20gx%.20g%+.20g%+.20g\",(double) page.width,(double) page.height,\n        (double) page.x,(double)page.y);\n      break;\n    }\n    case '#':\n    {\n      /*\n        Image signature.\n      */\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) SignatureImage(image,exception);\n      string=GetImageProperty(image,\"signature\",exception);\n      break;\n    }\n  }\n  if (string != (char *) NULL)\n    return(string);\n  if (*value != '\\0')\n    {\n      /*\n        Create a cloned copy of result.\n      */\n      if (image != (Image *) NULL)\n        {\n          (void) SetImageArtifact(image,\"get-property\",value);\n          return(GetImageArtifact(image,\"get-property\"));\n        }\n      else\n        {\n          (void) SetImageOption(image_info,\"get-property\",value);\n          return(GetImageOption(image_info,\"get-property\"));\n        }\n    }\n  return((char *) NULL);\n}\n\nMagickExport const char *GetMagickProperty(ImageInfo *image_info,\n  Image *image,const char *property,ExceptionInfo *exception)\n{\n  char\n    value[MagickPathExtent];\n\n  const char\n    *string;\n\n  assert(property[0] != '\\0');\n  assert(image != (Image *) NULL || image_info != (ImageInfo *) NULL );\n  if (property[1] == '\\0')  /* single letter property request */\n    return(GetMagickPropertyLetter(image_info,image,*property,exception));\n  if ((image != (Image *) NULL) && (image->debug != MagickFalse))\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  else\n    if ((image_info != (ImageInfo *) NULL) &&\n        (image_info->debug != MagickFalse))\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\"no-images\");\n  *value='\\0';           /* formated string */\n  string=(char *) NULL;  /* constant string reference */\n  switch (*property)\n  {\n    case 'b':\n    {\n      if (LocaleCompare(\"basename\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          GetPathComponent(image->magick_filename,BasePath,value);\n          if (*value == '\\0')\n            string=\"\";\n          break;\n        }\n      if (LocaleCompare(\"bit-depth\",property) == 0)\n        {\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            GetImageDepth(image,exception));\n          break;\n        }\n      break;\n    }\n    case 'c':\n    {\n      if (LocaleCompare(\"channels\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          /* FUTURE: return actual image channels */\n          (void) FormatLocaleString(value,MagickPathExtent,\"%s\",\n            CommandOptionToMnemonic(MagickColorspaceOptions,(ssize_t)\n            image->colorspace));\n          LocaleLower(value);\n          if( image->alpha_trait != UndefinedPixelTrait )\n            (void) ConcatenateMagickString(value,\"a\",MagickPathExtent);\n          break;\n        }\n      if (LocaleCompare(\"colorspace\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          /* FUTURE: return actual colorspace - no 'gray' stuff */\n          string=CommandOptionToMnemonic(MagickColorspaceOptions,(ssize_t)\n            image->colorspace);\n          break;\n        }\n      if (LocaleCompare(\"compose\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickComposeOptions,(ssize_t)\n            image->compose);\n          break;\n        }\n      if (LocaleCompare(\"copyright\",property) == 0)\n        {\n          (void) CopyMagickString(value,GetMagickCopyright(),MagickPathExtent);\n          break;\n        }\n      break;\n    }\n    case 'd':\n    {\n      if (LocaleCompare(\"depth\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            image->depth);\n          break;\n        }\n      if (LocaleCompare(\"directory\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          GetPathComponent(image->magick_filename,HeadPath,value);\n          if (*value == '\\0')\n            string=\"\";\n          break;\n        }\n      break;\n    }\n    case 'e':\n    {\n      if (LocaleCompare(\"entropy\",property) == 0)\n        {\n          double\n            entropy;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageEntropy(image,&entropy,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),entropy);\n          break;\n        }\n      if (LocaleCompare(\"extension\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          GetPathComponent(image->magick_filename,ExtensionPath,value);\n          if (*value == '\\0')\n            string=\"\";\n          break;\n        }\n      break;\n    }\n    case 'g':\n    {\n      if (LocaleCompare(\"gamma\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),image->gamma);\n          break;\n        }\n      break;\n    }\n    case 'h':\n    {\n      if (LocaleCompare(\"height\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",\n            image->magick_rows != 0 ? (double) image->magick_rows : 256.0);\n          break;\n        }\n      break;\n    }\n    case 'i':\n    {\n      if (LocaleCompare(\"input\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=image->filename;\n          break;\n        }\n      break;\n    }\n    case 'k':\n    {\n      if (LocaleCompare(\"kurtosis\",property) == 0)\n        {\n          double\n            kurtosis,\n            skewness;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageKurtosis(image,&kurtosis,&skewness,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),kurtosis);\n          break;\n        }\n      break;\n    }\n    case 'm':\n    {\n      if (LocaleCompare(\"magick\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=image->magick;\n          break;\n        }\n      if ((LocaleCompare(\"maxima\",property) == 0) ||\n          (LocaleCompare(\"max\",property) == 0))\n        {\n          double\n            maximum,\n            minimum;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageRange(image,&minimum,&maximum,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),maximum);\n          break;\n        }\n      if (LocaleCompare(\"mean\",property) == 0)\n        {\n          double\n            mean,\n            standard_deviation;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageMean(image,&mean,&standard_deviation,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),mean);\n          break;\n        }\n      if ((LocaleCompare(\"minima\",property) == 0) ||\n          (LocaleCompare(\"min\",property) == 0))\n        {\n          double\n            maximum,\n            minimum;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageRange(image,&minimum,&maximum,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),minimum);\n          break;\n        }\n      break;\n    }\n    case 'o':\n    {\n      if (LocaleCompare(\"opaque\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickBooleanOptions,(ssize_t)\n            IsImageOpaque(image,exception));\n          break;\n        }\n      if (LocaleCompare(\"orientation\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickOrientationOptions,(ssize_t)\n            image->orientation);\n          break;\n        }\n      if (LocaleCompare(\"output\",property) == 0)\n        {\n          WarnNoImageInfoReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) CopyMagickString(value,image_info->filename,MagickPathExtent);\n          break;\n        }\n     break;\n    }\n    case 'p':\n    {\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n      if (LocaleCompare(\"profile:icc\",property) == 0 ||\n          LocaleCompare(\"profile:icm\",property) == 0)\n        {\n#if !defined(LCMS_VERSION) || (LCMS_VERSION < 2000)\n#define cmsUInt32Number  DWORD\n#endif\n\n          const StringInfo\n            *profile;\n\n          cmsHPROFILE\n            icc_profile;\n\n          profile=GetImageProfile(image,property+8);\n          if (profile == (StringInfo *) NULL)\n            break;\n          icc_profile=cmsOpenProfileFromMem(GetStringInfoDatum(profile),\n            (cmsUInt32Number) GetStringInfoLength(profile));\n          if (icc_profile != (cmsHPROFILE *) NULL)\n            {\n#if defined(LCMS_VERSION) && (LCMS_VERSION < 2000)\n              string=cmsTakeProductName(icc_profile);\n#else\n              (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoDescription,\n                \"en\",\"US\",value,MagickPathExtent);\n#endif\n              (void) cmsCloseProfile(icc_profile);\n            }\n      }\n#endif\n      if (LocaleCompare(\"profiles\",property) == 0)\n        {\n          const char\n            *name;\n\n          ResetImageProfileIterator(image);\n          name=GetNextImageProfile(image);\n          if (name != (char *) NULL)\n            {\n              (void) CopyMagickString(value,name,MagickPathExtent);\n              name=GetNextImageProfile(image);\n              while (name != (char *) NULL)\n              {\n                ConcatenateMagickString(value,\",\",MagickPathExtent);\n                ConcatenateMagickString(value,name,MagickPathExtent);\n                name=GetNextImageProfile(image);\n              }\n            }\n          break;\n        }\n      break;\n    }\n    case 'r':\n    {\n      if (LocaleCompare(\"resolution.x\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%g\",\n            image->resolution.x);\n          break;\n        }\n      if (LocaleCompare(\"resolution.y\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%g\",\n            image->resolution.y);\n          break;\n        }\n      break;\n    }\n    case 's':\n    {\n      if (LocaleCompare(\"scene\",property) == 0)\n        {\n          WarnNoImageInfoReturn(\"\\\"%%[%s]\\\"\",property);\n          if (image_info->number_scenes != 0)\n            (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n              image_info->scene);\n          else {\n            WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n            (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n              image->scene);\n          }\n          break;\n        }\n      if (LocaleCompare(\"scenes\",property) == 0)\n        {\n          /* FUTURE: equivelent to %n? */\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            GetImageListLength(image));\n          break;\n        }\n      if (LocaleCompare(\"size\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatMagickSize(GetBlobSize(image),MagickFalse,\"B\",\n            MagickPathExtent,value);\n          break;\n        }\n      if (LocaleCompare(\"skewness\",property) == 0)\n        {\n          double\n            kurtosis,\n            skewness;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageKurtosis(image,&kurtosis,&skewness,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),skewness);\n          break;\n        }\n      if (LocaleCompare(\"standard-deviation\",property) == 0)\n        {\n          double\n            mean,\n            standard_deviation;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageMean(image,&mean,&standard_deviation,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),standard_deviation);\n          break;\n        }\n       break;\n    }\n    case 't':\n    {\n      if (LocaleCompare(\"type\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickTypeOptions,(ssize_t)\n            IdentifyImageType(image,exception));\n          break;\n        }\n       break;\n    }\n    case 'u':\n    {\n      if (LocaleCompare(\"unique\",property) == 0)\n        {\n          WarnNoImageInfoReturn(\"\\\"%%[%s]\\\"\",property);\n          string=image_info->unique;\n          break;\n        }\n      if (LocaleCompare(\"units\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickResolutionOptions,(ssize_t)\n            image->units);\n          break;\n        }\n      if (LocaleCompare(\"copyright\",property) == 0)\n      break;\n    }\n    case 'v':\n    {\n      if (LocaleCompare(\"version\",property) == 0)\n        {\n          string=GetMagickVersion((size_t *) NULL);\n          break;\n        }\n      break;\n    }\n    case 'w':\n    {\n      if (LocaleCompare(\"width\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            (image->magick_columns != 0 ? image->magick_columns : 256));\n          break;\n        }\n      break;\n    }\n  }\n  if (string != (char *) NULL)\n    return(string);\n  if (*value != '\\0')\n    {\n      /*\n        Create a cloned copy of result, that will get cleaned up, eventually.\n      */\n      if (image != (Image *) NULL)\n        {\n          (void) SetImageArtifact(image,\"get-property\",value);\n          return(GetImageArtifact(image,\"get-property\"));\n        }\n      else\n        {\n          (void) SetImageOption(image_info,\"get-property\",value);\n          return(GetImageOption(image_info,\"get-property\"));\n        }\n    }\n  return((char *) NULL);\n}\n#undef WarnNoImageReturn\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t N e x t I m a g e P r o p e r t y                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetNextImageProperty() gets the next free-form string property name.\n%\n%  The format of the GetNextImageProperty method is:\n%\n%      char *GetNextImageProperty(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport const char *GetNextImageProperty(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image->filename);\n  if (image->properties == (void *) NULL)\n    return((const char *) NULL);\n  return((const char *) GetNextKeyInSplayTree((SplayTreeInfo *) image->properties));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I n t e r p r e t I m a g e P r o p e r t i e s                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InterpretImageProperties() replaces any embedded formatting characters with\n%  the appropriate image property and returns the interpreted text.\n%\n%  This searches for and replaces\n%     \\n \\r \\%          replaced by newline, return, and percent resp.\n%     &lt; &gt; &amp;   replaced by '<', '>', '&' resp.\n%     %%                replaced by percent\n%\n%     %x %[x]       where 'x' is a single letter properity, case sensitive).\n%     %[type:name]  where 'type' a is special and known prefix.\n%     %[name]       where 'name' is a specifically known attribute, calculated\n%                   value, or a per-image property string name, or a per-image\n%                   'artifact' (as generated from a global option).\n%                   It may contain ':' as long as the prefix is not special.\n%\n%  Single letter % substitutions will only happen if the character before the\n%  percent is NOT a number. But braced substitutions will always be performed.\n%  This prevents the typical usage of percent in a interpreted geometry\n%  argument from being substituted when the percent is a geometry flag.\n%\n%  If 'glob-expresions' ('*' or '?' characters) is used for 'name' it may be\n%  used as a search pattern to print multiple lines of \"name=value\\n\" pairs of\n%  the associacted set of properties.\n%\n%  The returned string must be freed using DestoryString() by the caller.\n%\n%  The format of the InterpretImageProperties method is:\n%\n%      char *InterpretImageProperties(ImageInfo *image_info,\n%        Image *image,const char *embed_text,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info. (required)\n%\n%    o image: the image. (optional)\n%\n%    o embed_text: the address of a character string containing the embedded\n%      formatting characters.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport char *InterpretImageProperties(ImageInfo *image_info,Image *image,\n  const char *embed_text,ExceptionInfo *exception)\n{\n#define ExtendInterpretText(string_length) \\\nDisableMSCWarning(4127) \\\n{ \\\n  size_t length=(string_length); \\\n  if ((size_t) (q-interpret_text+length+1) >= extent) \\\n    { \\\n      extent+=length; \\\n      interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \\\n        MaxTextExtent,sizeof(*interpret_text)); \\\n      if (interpret_text == (char *) NULL) \\\n        return((char *) NULL); \\\n      q=interpret_text+strlen(interpret_text); \\\n   } \\\n} \\\nRestoreMSCWarning\n\n#define AppendKeyValue2Text(key,value)\\\nDisableMSCWarning(4127) \\\n{ \\\n  size_t length=strlen(key)+strlen(value)+2; \\\n  if ((size_t) (q-interpret_text+length+1) >= extent) \\\n    { \\\n      extent+=length; \\\n      interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \\\n        MaxTextExtent,sizeof(*interpret_text)); \\\n      if (interpret_text == (char *) NULL) \\\n        return((char *) NULL); \\\n      q=interpret_text+strlen(interpret_text); \\\n     } \\\n   q+=FormatLocaleString(q,extent,\"%s=%s\\n\",(key),(value)); \\\n} \\\nRestoreMSCWarning\n\n#define AppendString2Text(string) \\\nDisableMSCWarning(4127) \\\n{ \\\n  size_t length=strlen((string)); \\\n  if ((size_t) (q-interpret_text+length+1) >= extent) \\\n    { \\\n      extent+=length; \\\n      interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \\\n        MaxTextExtent,sizeof(*interpret_text)); \\\n      if (interpret_text == (char *) NULL) \\\n        return((char *) NULL); \\\n      q=interpret_text+strlen(interpret_text); \\\n    } \\\n  (void) CopyMagickString(q,(string),extent); \\\n  q+=length; \\\n} \\\nRestoreMSCWarning\n\n  char\n    *interpret_text;\n\n  MagickBooleanType\n    number;\n\n  register char\n    *q;  /* current position in interpret_text */\n\n  register const char\n    *p;  /* position in embed_text string being expanded */\n\n  size_t\n    extent;  /* allocated length of interpret_text */\n\n  assert(image == NULL || image->signature == MagickCoreSignature);\n  assert(image_info == NULL || image_info->signature == MagickCoreSignature);\n  if ((image != (Image *) NULL) && (image->debug != MagickFalse))\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  else\n   if ((image_info != (ImageInfo *) NULL) && (image_info->debug != MagickFalse))\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\"no-image\");\n  if (embed_text == (const char *) NULL)\n    return(ConstantString(\"\"));\n  p=embed_text;\n  while ((isspace((int) ((unsigned char) *p)) != 0) && (*p != '\\0'))\n    p++;\n  if (*p == '\\0')\n    return(ConstantString(\"\"));\n  if ((*p == '@') && (IsPathAccessible(p+1) != MagickFalse))\n    {\n      /*\n        Handle a '@' replace string from file.\n      */\n      if (IsRightsAuthorized(PathPolicyDomain,ReadPolicyRights,p) == MagickFalse)\n        {\n          errno=EPERM;\n          (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n            \"NotAuthorized\",\"`%s'\",p);\n          return(ConstantString(\"\"));\n        }\n      interpret_text=FileToString(p+1,~0UL,exception);\n      if (interpret_text != (char *) NULL)\n        return(interpret_text);\n    }\n  /*\n    Translate any embedded format characters.\n  */\n  interpret_text=AcquireString(embed_text); /* new string with extra space */\n  extent=MagickPathExtent;                     /* allocated space in string */\n  number=MagickFalse;                       /* is last char a number? */\n  for (q=interpret_text; *p!='\\0'; number=isdigit(*p) ? MagickTrue : MagickFalse,p++)\n  {\n    /*\n      Look for the various escapes, (and handle other specials)\n    */\n    *q='\\0';\n    ExtendInterpretText(MagickPathExtent);\n    switch (*p)\n    {\n      case '\\\\':\n      {\n        switch (*(p+1))\n        {\n          case '\\0':\n            continue;\n          case 'r':  /* convert to RETURN */\n          {\n            *q++='\\r';\n            p++;\n            continue;\n          }\n          case 'n':  /* convert to NEWLINE */\n          {\n            *q++='\\n';\n            p++;\n            continue;\n          }\n          case '\\n':  /* EOL removal UNIX,MacOSX */\n          {\n            p++;\n            continue;\n          }\n          case '\\r':  /* EOL removal DOS,Windows */\n          {\n            p++;\n            if (*p == '\\n') /* return-newline EOL */\n              p++;\n            continue;\n          }\n          default:\n          {\n            p++;\n            *q++=(*p);\n          }\n        }\n        continue;\n      }\n      case '&':\n      {\n        if (LocaleNCompare(\"&lt;\",p,4) == 0)\n          {\n            *q++='<';\n            p+=3;\n          }\n        else\n          if (LocaleNCompare(\"&gt;\",p,4) == 0)\n            {\n              *q++='>';\n              p+=3;\n            }\n          else\n            if (LocaleNCompare(\"&amp;\",p,5) == 0)\n              {\n                *q++='&';\n                p+=4;\n              }\n            else\n              *q++=(*p);\n        continue;\n      }\n      case '%':\n        break;  /* continue to next set of handlers */\n      default:\n      {\n        *q++=(*p);  /* any thing else is 'as normal' */\n        continue;\n      }\n    }\n    p++; /* advance beyond the percent */\n    /*\n      Doubled Percent - or percent at end of string.\n    */\n    if ((*p == '\\0') || (*p == '\\'') || (*p == '\"'))\n      p--;\n    if (*p == '%')\n      {\n        *q++='%';\n        continue;\n      }\n    /*\n      Single letter escapes %c.\n    */\n    if (*p != '[')\n      {\n        const char\n          *string;\n\n        if (number != MagickFalse)\n          {\n            /*\n              But only if not preceeded by a number!\n            */\n            *q++='%'; /* do NOT substitute the percent */\n            p--;      /* back up one */\n            continue;\n          }\n        string=GetMagickPropertyLetter(image_info,image,*p, exception);\n        if (string != (char *) NULL)\n          {\n            AppendString2Text(string);\n            if (image != (Image *) NULL)\n              (void) DeleteImageArtifact(image,\"get-property\");\n            if (image_info != (ImageInfo *) NULL)\n              (void) DeleteImageOption(image_info,\"get-property\");\n            continue;\n          }\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n          \"UnknownImageProperty\",\"\\\"%%%c\\\"\",*p);\n        continue;\n      }\n    {\n      char\n        pattern[2*MagickPathExtent];\n\n      const char\n        *key,\n        *string;\n\n      register ssize_t\n        len;\n\n      ssize_t\n        depth;\n\n      /*\n        Braced Percent Escape %[...].\n      */\n      p++;  /* advance p to just inside the opening brace */\n      depth=1;\n      if (*p == ']')\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n            \"UnknownImageProperty\",\"\\\"%%[]\\\"\");\n          break;\n        }\n      for (len=0; len<(MagickPathExtent-1L) && (*p != '\\0');)\n      {\n        if ((*p == '\\\\') && (*(p+1) != '\\0'))\n          {\n            /*\n              Skip escaped braces within braced pattern.\n            */\n            pattern[len++]=(*p++);\n            pattern[len++]=(*p++);\n            continue;\n          }\n        if (*p == '[')\n          depth++;\n        if (*p == ']')\n          depth--;\n        if (depth <= 0)\n          break;\n        pattern[len++]=(*p++);\n      }\n      pattern[len]='\\0';\n      if (depth != 0)\n        {\n          /*\n            Check for unmatched final ']' for \"%[...]\".\n          */\n          if (len >= 64)\n            {\n              pattern[61] = '.';  /* truncate string for error message */\n              pattern[62] = '.';\n              pattern[63] = '.';\n              pattern[64] = '\\0';\n            }\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"UnbalancedBraces\",\"\\\"%%[%s\\\"\",pattern);\n          interpret_text=DestroyString(interpret_text);\n          return((char *) NULL);\n        }\n      /*\n        Special Lookup Prefixes %[prefix:...].\n      */\n      if (LocaleNCompare(\"fx:\",pattern,3) == 0)\n        {\n          double\n            value;\n\n          FxInfo\n            *fx_info;\n\n          MagickBooleanType\n            status;\n\n          /*\n            FX - value calculator.\n          */\n          if (image == (Image *) NULL )\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"NoImageForProperty\",\"\\\"%%[%s]\\\"\",pattern);\n              continue; /* else no image to retrieve artifact */\n            }\n          fx_info=AcquireFxInfo(image,pattern+3,exception);\n          status=FxEvaluateChannelExpression(fx_info,IntensityPixelChannel,0,0,\n            &value,exception);\n          fx_info=DestroyFxInfo(fx_info);\n          if (status != MagickFalse)\n            {\n              char\n                result[MagickPathExtent];\n\n              (void) FormatLocaleString(result,MagickPathExtent,\"%.*g\",\n                GetMagickPrecision(),(double) value);\n              AppendString2Text(result);\n            }\n          continue;\n        }\n      if (LocaleNCompare(\"pixel:\",pattern,6) == 0)\n        {\n          FxInfo\n            *fx_info;\n\n          double\n            value;\n\n          MagickStatusType\n            status;\n\n          PixelInfo\n            pixel;\n\n          /*\n            Pixel - color value calculator.\n          */\n          if (image == (Image *) NULL)\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"NoImageForProperty\",\"\\\"%%[%s]\\\"\",pattern);\n              continue; /* else no image to retrieve artifact */\n            }\n          GetPixelInfo(image,&pixel);\n          fx_info=AcquireFxInfo(image,pattern+6,exception);\n          status=FxEvaluateChannelExpression(fx_info,RedPixelChannel,0,0,\n            &value,exception);\n          pixel.red=(double) QuantumRange*value;\n          status&=FxEvaluateChannelExpression(fx_info,GreenPixelChannel,0,0,\n            &value,exception);\n          pixel.green=(double) QuantumRange*value;\n          status&=FxEvaluateChannelExpression(fx_info,BluePixelChannel,0,0,\n            &value,exception);\n          pixel.blue=(double) QuantumRange*value;\n          if (image->colorspace == CMYKColorspace)\n            {\n              status&=FxEvaluateChannelExpression(fx_info,BlackPixelChannel,0,0,\n                &value,exception);\n              pixel.black=(double) QuantumRange*value;\n            }\n          status&=FxEvaluateChannelExpression(fx_info,AlphaPixelChannel,0,0,\n            &value,exception);\n          pixel.alpha=(double) QuantumRange*value;\n          fx_info=DestroyFxInfo(fx_info);\n          if (status != MagickFalse)\n            {\n              char\n                name[MagickPathExtent];\n\n              (void) QueryColorname(image,&pixel,SVGCompliance,name,\n                exception);\n              AppendString2Text(name);\n            }\n          continue;\n        }\n      if (LocaleNCompare(\"option:\",pattern,7) == 0)\n        {\n          /*\n            Option - direct global option lookup (with globbing).\n          */\n          if (image_info == (ImageInfo *) NULL )\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"NoImageForProperty\",\"\\\"%%[%s]\\\"\",pattern);\n              continue; /* else no image to retrieve artifact */\n            }\n          if (IsGlob(pattern+7) != MagickFalse)\n            {\n              ResetImageOptionIterator(image_info);\n              while ((key=GetNextImageOption(image_info)) != (const char *) NULL)\n                if (GlobExpression(key,pattern+7,MagickTrue) != MagickFalse)\n                  {\n                    string=GetImageOption(image_info,key);\n                    if (string != (const char *) NULL)\n                      AppendKeyValue2Text(key,string);\n                    /* else - assertion failure? key found but no string value! */\n                  }\n              continue;\n            }\n          string=GetImageOption(image_info,pattern+7);\n          if (string == (char *) NULL)\n            goto PropertyLookupFailure; /* no artifact of this specifc name */\n          AppendString2Text(string);\n          continue;\n        }\n      if (LocaleNCompare(\"artifact:\",pattern,9) == 0)\n        {\n          /*\n            Artifact - direct image artifact lookup (with glob).\n          */\n          if (image == (Image *) NULL)\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"NoImageForProperty\",\"\\\"%%[%s]\\\"\",pattern);\n              continue; /* else no image to retrieve artifact */\n            }\n          if (IsGlob(pattern+9) != MagickFalse)\n            {\n              ResetImageArtifactIterator(image);\n              while ((key=GetNextImageArtifact(image)) != (const char *) NULL)\n              if (GlobExpression(key,pattern+9,MagickTrue) != MagickFalse)\n                {\n                  string=GetImageArtifact(image,key);\n                  if (string != (const char *) NULL)\n                    AppendKeyValue2Text(key,string);\n                  /* else - assertion failure? key found but no string value! */\n                }\n              continue;\n            }\n          string=GetImageArtifact(image,pattern+9);\n          if (string == (char *) NULL)\n            goto PropertyLookupFailure; /* no artifact of this specifc name */\n          AppendString2Text(string);\n          continue;\n        }\n      if (LocaleNCompare(\"property:\",pattern,9) == 0)\n        {\n          /*\n            Property - direct image property lookup (with glob).\n          */\n          if (image == (Image *) NULL)\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"NoImageForProperty\",\"\\\"%%[%s]\\\"\",pattern);\n              continue; /* else no image to retrieve artifact */\n            }\n          if (IsGlob(pattern+9) != MagickFalse)\n            {\n              ResetImagePropertyIterator(image);\n              while ((key=GetNextImageProperty(image)) != (const char *) NULL)\n                if (GlobExpression(key,pattern,MagickTrue) != MagickFalse)\n                  {\n                    string=GetImageProperty(image,key,exception);\n                    if (string != (const char *) NULL)\n                      AppendKeyValue2Text(key,string);\n                    /* else - assertion failure? */\n                  }\n              continue;\n            }\n          string=GetImageProperty(image,pattern+9,exception);\n          if (string == (char *) NULL)\n            goto PropertyLookupFailure; /* no artifact of this specifc name */\n          AppendString2Text(string);\n          continue;\n        }\n      if (image != (Image *) NULL)\n        {\n          /*\n            Properties without special prefix.  This handles attributes,\n            properties, and profiles such as %[exif:...].  Note the profile\n            properties may also include a glob expansion pattern.\n          */\n          string=GetImageProperty(image,pattern,exception);\n          if (string != (const char *) NULL)\n            {\n              AppendString2Text(string);\n              if (image != (Image *) NULL)\n                (void)DeleteImageArtifact(image,\"get-property\");\n              if (image_info != (ImageInfo *) NULL)\n                (void)DeleteImageOption(image_info,\"get-property\");\n              continue;\n            }\n        }\n      if (IsGlob(pattern) != MagickFalse)\n        {\n          /*\n            Handle property 'glob' patterns such as:\n            %[*] %[user:array_??] %[filename:e*]>\n          */\n          if (image == (Image *) NULL)\n            continue; /* else no image to retrieve proprty - no list */\n          ResetImagePropertyIterator(image);\n          while ((key=GetNextImageProperty(image)) != (const char *) NULL)\n            if (GlobExpression(key,pattern,MagickTrue) != MagickFalse)\n              {\n                string=GetImageProperty(image,key,exception);\n                if (string != (const char *) NULL)\n                  AppendKeyValue2Text(key,string);\n                /* else - assertion failure? */\n              }\n          continue;\n        }\n      /*\n        Look for a known property or image attribute such as\n        %[basename] %[denisty] %[delay].  Also handles a braced single\n        letter: %[b] %[G] %[g].\n      */\n      string=GetMagickProperty(image_info,image,pattern,exception);\n      if (string != (const char *) NULL)\n        {\n          AppendString2Text(string);\n          continue;\n        }\n      /*\n        Look for a per-image artifact. This includes option lookup\n        (FUTURE: interpreted according to image).\n      */\n      if (image != (Image *) NULL)\n        {\n          string=GetImageArtifact(image,pattern);\n          if (string != (char *) NULL)\n            {\n              AppendString2Text(string);\n              continue;\n            }\n        }\n      else\n        if (image_info != (ImageInfo *) NULL)\n          {\n            /*\n              No image, so direct 'option' lookup (no delayed percent escapes).\n            */\n            string=GetImageOption(image_info,pattern);\n            if (string != (char *) NULL)\n              {\n                AppendString2Text(string);\n                continue;\n              }\n          }\nPropertyLookupFailure:\n      /*\n        Failed to find any match anywhere!\n      */\n      if (len >= 64)\n        {\n          pattern[61] = '.';  /* truncate string for error message */\n          pattern[62] = '.';\n          pattern[63] = '.';\n          pattern[64] = '\\0';\n        }\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"UnknownImageProperty\",\"\\\"%%[%s]\\\"\",pattern);\n    }\n  }\n  *q='\\0';\n  return(interpret_text);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e m o v e I m a g e P r o p e r t y                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RemoveImageProperty() removes a property from the image and returns its\n%  value.\n%\n%  In this case the ConstantString() value returned should be freed by the\n%  caller when finished.\n%\n%  The format of the RemoveImageProperty method is:\n%\n%      char *RemoveImageProperty(Image *image,const char *property)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o property: the image property.\n%\n*/\nMagickExport char *RemoveImageProperty(Image *image,const char *property)\n{\n  char\n    *value;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->properties == (void *) NULL)\n    return((char *) NULL);\n  value=(char *) RemoveNodeFromSplayTree((SplayTreeInfo *) image->properties,\n    property);\n  return(value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e s e t I m a g e P r o p e r t y I t e r a t o r                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResetImagePropertyIterator() resets the image properties iterator.  Use it\n%  in conjunction with GetNextImageProperty() to iterate over all the values\n%  associated with an image property.\n%\n%  The format of the ResetImagePropertyIterator method is:\n%\n%      ResetImagePropertyIterator(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void ResetImagePropertyIterator(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->properties == (void *) NULL)\n    return;\n  ResetSplayTreeIterator((SplayTreeInfo *) image->properties);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e P r o p e r t y                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageProperty() saves the given string value either to specific known\n%  attribute or to a freeform property string.\n%\n%  Attempting to set a property that is normally calculated will produce\n%  an exception.\n%\n%  The format of the SetImageProperty method is:\n%\n%      MagickBooleanType SetImageProperty(Image *image,const char *property,\n%        const char *value,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o property: the image property.\n%\n%    o values: the image property values.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SetImageProperty(Image *image,\n  const char *property,const char *value,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  MagickStatusType\n    flags;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->properties == (void *) NULL)\n    image->properties=NewSplayTree(CompareSplayTreeString,\n      RelinquishMagickMemory,RelinquishMagickMemory);  /* create splay-tree */\n  if (value == (const char *) NULL)\n    return(DeleteImageProperty(image,property));  /* delete if NULL */\n  status=MagickTrue;\n  if (strlen(property) <= 1)\n    {\n      /*\n        Do not 'set' single letter properties - read only shorthand.\n       */\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"SetReadOnlyProperty\",\"`%s'\",property);\n      return(MagickFalse);\n    }\n\n  /* FUTURE: binary chars or quotes in key should produce a error */\n  /* Set attributes with known names or special prefixes\n     return result is found, or break to set a free form properity\n  */\n  switch (*property)\n  {\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n    case '8':\n    {\n      if (LocaleNCompare(\"8bim:\",property,5) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break;\n    }\n#endif\n    case 'B':\n    case 'b':\n    {\n      if (LocaleCompare(\"background\",property) == 0)\n        {\n          (void) QueryColorCompliance(value,AllCompliance,\n               &image->background_color,exception);\n          /* check for FUTURE: value exception?? */\n          /* also add user input to splay tree */\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'C':\n    case 'c':\n    {\n      if (LocaleCompare(\"channels\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      if (LocaleCompare(\"colorspace\",property) == 0)\n        {\n          ssize_t\n            colorspace;\n\n          colorspace=ParseCommandOption(MagickColorspaceOptions,MagickFalse,\n            value);\n          if (colorspace < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          return(SetImageColorspace(image,(ColorspaceType) colorspace,exception));\n        }\n      if (LocaleCompare(\"compose\",property) == 0)\n        {\n          ssize_t\n            compose;\n\n          compose=ParseCommandOption(MagickComposeOptions,MagickFalse,value);\n          if (compose < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->compose=(CompositeOperator) compose;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"compress\",property) == 0)\n        {\n          ssize_t\n            compression;\n\n          compression=ParseCommandOption(MagickCompressOptions,MagickFalse,\n            value);\n          if (compression < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->compression=(CompressionType) compression;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'D':\n    case 'd':\n    {\n      if (LocaleCompare(\"delay\",property) == 0)\n        {\n          GeometryInfo\n            geometry_info;\n\n          flags=ParseGeometry(value,&geometry_info);\n          if ((flags & GreaterValue) != 0)\n            {\n              if (image->delay > (size_t) floor(geometry_info.rho+0.5))\n                image->delay=(size_t) floor(geometry_info.rho+0.5);\n            }\n          else\n            if ((flags & LessValue) != 0)\n              {\n                if (image->delay < (size_t) floor(geometry_info.rho+0.5))\n                  image->delay=(ssize_t)\n                    floor(geometry_info.sigma+0.5);\n              }\n            else\n              image->delay=(size_t) floor(geometry_info.rho+0.5);\n          if ((flags & SigmaValue) != 0)\n            image->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"delay_units\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      if (LocaleCompare(\"density\",property) == 0)\n        {\n          GeometryInfo\n            geometry_info;\n\n          flags=ParseGeometry(value,&geometry_info);\n          image->resolution.x=geometry_info.rho;\n          image->resolution.y=geometry_info.sigma;\n          if ((flags & SigmaValue) == 0)\n            image->resolution.y=image->resolution.x;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"depth\",property) == 0)\n        {\n          image->depth=StringToUnsignedLong(value);\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"dispose\",property) == 0)\n        {\n          ssize_t\n            dispose;\n\n          dispose=ParseCommandOption(MagickDisposeOptions,MagickFalse,value);\n          if (dispose < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->dispose=(DisposeType) dispose;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n    case 'E':\n    case 'e':\n    {\n      if (LocaleNCompare(\"exif:\",property,5) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'F':\n    case 'f':\n    {\n      if (LocaleNCompare(\"fx:\",property,3) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#endif\n    case 'G':\n    case 'g':\n    {\n      if (LocaleCompare(\"gamma\",property) == 0)\n        {\n          image->gamma=StringToDouble(value,(char **) NULL);\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"gravity\",property) == 0)\n        {\n          ssize_t\n            gravity;\n\n          gravity=ParseCommandOption(MagickGravityOptions,MagickFalse,value);\n          if (gravity < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->gravity=(GravityType) gravity;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'H':\n    case 'h':\n    {\n      if (LocaleCompare(\"height\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'I':\n    case 'i':\n    {\n      if (LocaleCompare(\"intensity\",property) == 0)\n        {\n          ssize_t\n            intensity;\n\n          intensity=ParseCommandOption(MagickIntentOptions,MagickFalse,value);\n          if (intensity < 0)\n            return(MagickFalse);\n          image->intensity=(PixelIntensityMethod) intensity;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"intent\",property) == 0)\n        {\n          ssize_t\n            rendering_intent;\n\n          rendering_intent=ParseCommandOption(MagickIntentOptions,MagickFalse,\n            value);\n          if (rendering_intent < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->rendering_intent=(RenderingIntent) rendering_intent;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"interpolate\",property) == 0)\n        {\n          ssize_t\n            interpolate;\n\n          interpolate=ParseCommandOption(MagickInterpolateOptions,MagickFalse,\n            value);\n          if (interpolate < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->interpolate=(PixelInterpolateMethod) interpolate;\n          return(MagickTrue);\n        }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n      if (LocaleNCompare(\"iptc:\",property,5) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n#endif\n      break; /* not an attribute, add as a property */\n    }\n    case 'K':\n    case 'k':\n      if (LocaleCompare(\"kurtosis\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'L':\n    case 'l':\n    {\n      if (LocaleCompare(\"loop\",property) == 0)\n        {\n          image->iterations=StringToUnsignedLong(value);\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'M':\n    case 'm':\n      if ((LocaleCompare(\"magick\",property) == 0) ||\n          (LocaleCompare(\"max\",property) == 0) ||\n          (LocaleCompare(\"mean\",property) == 0) ||\n          (LocaleCompare(\"min\",property) == 0) ||\n          (LocaleCompare(\"min\",property) == 0))\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n             \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'O':\n    case 'o':\n      if (LocaleCompare(\"opaque\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'P':\n    case 'p':\n    {\n      if (LocaleCompare(\"page\",property) == 0)\n        {\n          char\n            *geometry;\n\n          geometry=GetPageGeometry(value);\n          flags=ParseAbsoluteGeometry(geometry,&image->page);\n          geometry=DestroyString(geometry);\n          return(MagickTrue);\n        }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n      if (LocaleNCompare(\"pixel:\",property,6) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n#endif\n      if (LocaleCompare(\"profile\",property) == 0)\n        {\n          ImageInfo\n            *image_info;\n\n          StringInfo\n            *profile;\n\n          image_info=AcquireImageInfo();\n          (void) CopyMagickString(image_info->filename,value,MagickPathExtent);\n          (void) SetImageInfo(image_info,1,exception);\n          profile=FileToStringInfo(image_info->filename,~0UL,exception);\n          if (profile != (StringInfo *) NULL)\n            status=SetImageProfile(image,image_info->magick,profile,exception);\n          image_info=DestroyImageInfo(image_info);\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'R':\n    case 'r':\n    {\n      if (LocaleCompare(\"rendering-intent\",property) == 0)\n        {\n          ssize_t\n            rendering_intent;\n\n          rendering_intent=ParseCommandOption(MagickIntentOptions,MagickFalse,\n            value);\n          if (rendering_intent < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->rendering_intent=(RenderingIntent) rendering_intent;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'S':\n    case 's':\n      if ((LocaleCompare(\"size\",property) == 0) ||\n          (LocaleCompare(\"skewness\",property) == 0) ||\n          (LocaleCompare(\"scenes\",property) == 0) ||\n          (LocaleCompare(\"standard-deviation\",property) == 0))\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'T':\n    case 't':\n    {\n      if (LocaleCompare(\"tile-offset\",property) == 0)\n        {\n          char\n            *geometry;\n\n          geometry=GetPageGeometry(value);\n          flags=ParseAbsoluteGeometry(geometry,&image->tile_offset);\n          geometry=DestroyString(geometry);\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'U':\n    case 'u':\n    {\n      if (LocaleCompare(\"units\",property) == 0)\n        {\n          ssize_t\n            units;\n\n          units=ParseCommandOption(MagickResolutionOptions,MagickFalse,value);\n          if (units < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->units=(ResolutionType) units;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'V':\n    case 'v':\n    {\n      if (LocaleCompare(\"version\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'W':\n    case 'w':\n    {\n      if (LocaleCompare(\"width\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n    case 'X':\n    case 'x':\n    {\n      if (LocaleNCompare(\"xmp:\",property,4) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#endif\n  }\n  /* Default: not an attribute, add as a property */\n  status=AddValueToSplayTree((SplayTreeInfo *) image->properties,\n    ConstantString(property),ConstantString(value));\n  /* FUTURE: error if status is bad? */\n  return(status);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%            PPPP    RRRR    OOO   PPPP   EEEEE  RRRR   TTTTT  Y   Y          %\n%            P   P   R   R  O   O  P   P  E      R   R    T     Y Y           %\n%            PPPP    RRRR   O   O  PPPP   EEE    RRRR     T      Y            %\n%            P       R R    O   O  P      E      R R      T      Y            %\n%            P       R  R    OOO   P      EEEEE  R  R     T      Y            %\n%                                                                             %\n%                                                                             %\n%                         MagickCore Property Methods                         %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 March 2000                                  %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-private.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/compare.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/effect.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/fx.h\"\n#include \"MagickCore/fx-private.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/histogram.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/layer.h\"\n#include \"MagickCore/locale-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/montage.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/policy.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/signature.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/token-private.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n#include \"MagickCore/version.h\"\n#include \"MagickCore/xml-tree.h\"\n#include \"MagickCore/xml-tree-private.h\"\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n#if defined(MAGICKCORE_HAVE_LCMS2_LCMS2_H)\n#include <lcms2/lcms2.h>\n#elif defined(MAGICKCORE_HAVE_LCMS2_H)\n#include \"lcms2.h\"\n#elif defined(MAGICKCORE_HAVE_LCMS_LCMS_H)\n#include <lcms/lcms.h>\n#else\n#include \"lcms.h\"\n#endif\n#endif\n\f\n/*\n  Define declarations.\n*/\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n#if defined(LCMS_VERSION) && (LCMS_VERSION < 2000)\n#define cmsUInt32Number  DWORD\n#endif\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l o n e I m a g e P r o p e r t i e s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CloneImageProperties() clones all the image properties to another image.\n%\n%  The format of the CloneImageProperties method is:\n%\n%      MagickBooleanType CloneImageProperties(Image *image,\n%        const Image *clone_image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o clone_image: the clone image.\n%\n*/\nMagickExport MagickBooleanType CloneImageProperties(Image *image,\n  const Image *clone_image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(clone_image != (const Image *) NULL);\n  assert(clone_image->signature == MagickCoreSignature);\n  if (clone_image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      clone_image->filename);\n  (void) CopyMagickString(image->filename,clone_image->filename,\n    MagickPathExtent);\n  (void) CopyMagickString(image->magick_filename,clone_image->magick_filename,\n    MagickPathExtent);\n  image->compression=clone_image->compression;\n  image->quality=clone_image->quality;\n  image->depth=clone_image->depth;\n  image->alpha_color=clone_image->alpha_color;\n  image->background_color=clone_image->background_color;\n  image->border_color=clone_image->border_color;\n  image->transparent_color=clone_image->transparent_color;\n  image->gamma=clone_image->gamma;\n  image->chromaticity=clone_image->chromaticity;\n  image->rendering_intent=clone_image->rendering_intent;\n  image->black_point_compensation=clone_image->black_point_compensation;\n  image->units=clone_image->units;\n  image->montage=(char *) NULL;\n  image->directory=(char *) NULL;\n  (void) CloneString(&image->geometry,clone_image->geometry);\n  image->offset=clone_image->offset;\n  image->resolution.x=clone_image->resolution.x;\n  image->resolution.y=clone_image->resolution.y;\n  image->page=clone_image->page;\n  image->tile_offset=clone_image->tile_offset;\n  image->extract_info=clone_image->extract_info;\n  image->filter=clone_image->filter;\n  image->fuzz=clone_image->fuzz;\n  image->intensity=clone_image->intensity;\n  image->interlace=clone_image->interlace;\n  image->interpolate=clone_image->interpolate;\n  image->endian=clone_image->endian;\n  image->gravity=clone_image->gravity;\n  image->compose=clone_image->compose;\n  image->orientation=clone_image->orientation;\n  image->scene=clone_image->scene;\n  image->dispose=clone_image->dispose;\n  image->delay=clone_image->delay;\n  image->ticks_per_second=clone_image->ticks_per_second;\n  image->iterations=clone_image->iterations;\n  image->total_colors=clone_image->total_colors;\n  image->taint=clone_image->taint;\n  image->progress_monitor=clone_image->progress_monitor;\n  image->client_data=clone_image->client_data;\n  image->start_loop=clone_image->start_loop;\n  image->error=clone_image->error;\n  image->signature=clone_image->signature;\n  if (clone_image->properties != (void *) NULL)\n    {\n      if (image->properties != (void *) NULL)\n        DestroyImageProperties(image);\n      image->properties=CloneSplayTree((SplayTreeInfo *)\n        clone_image->properties,(void *(*)(void *)) ConstantString,\n        (void *(*)(void *)) ConstantString);\n    }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e f i n e I m a g e P r o p e r t y                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DefineImageProperty() associates an assignment string of the form\n%  \"key=value\" with an artifact or options. It is equivelent to\n%  SetImageProperty()\n%\n%  The format of the DefineImageProperty method is:\n%\n%      MagickBooleanType DefineImageProperty(Image *image,const char *property,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o property: the image property.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType DefineImageProperty(Image *image,\n  const char *property,ExceptionInfo *exception)\n{\n  char\n    key[MagickPathExtent],\n    value[MagickPathExtent];\n\n  register char\n    *p;\n\n  assert(image != (Image *) NULL);\n  assert(property != (const char *) NULL);\n  (void) CopyMagickString(key,property,MagickPathExtent-1);\n  for (p=key; *p != '\\0'; p++)\n    if (*p == '=')\n      break;\n  *value='\\0';\n  if (*p == '=')\n    (void) CopyMagickString(value,p+1,MagickPathExtent);\n  *p='\\0';\n  return(SetImageProperty(image,key,value,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e l e t e I m a g e P r o p e r t y                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DeleteImageProperty() deletes an image property.\n%\n%  The format of the DeleteImageProperty method is:\n%\n%      MagickBooleanType DeleteImageProperty(Image *image,const char *property)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o property: the image property.\n%\n*/\nMagickExport MagickBooleanType DeleteImageProperty(Image *image,\n  const char *property)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->properties == (void *) NULL)\n    return(MagickFalse);\n  return(DeleteNodeFromSplayTree((SplayTreeInfo *) image->properties,property));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y I m a g e P r o p e r t i e s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyImageProperties() destroys all properties and associated memory\n%  attached to the given image.\n%\n%  The format of the DestroyDefines method is:\n%\n%      void DestroyImageProperties(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void DestroyImageProperties(Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->properties != (void *) NULL)\n    image->properties=(void *) DestroySplayTree((SplayTreeInfo *)\n      image->properties);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  F o r m a t I m a g e P r o p e r t y                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FormatImageProperty() permits formatted property/value pairs to be saved as\n%  an image property.\n%\n%  The format of the FormatImageProperty method is:\n%\n%      MagickBooleanType FormatImageProperty(Image *image,const char *property,\n%        const char *format,...)\n%\n%  A description of each parameter follows.\n%\n%   o  image:  The image.\n%\n%   o  property:  The attribute property.\n%\n%   o  format:  A string describing the format to use to write the remaining\n%      arguments.\n%\n*/\nMagickExport MagickBooleanType FormatImageProperty(Image *image,\n  const char *property,const char *format,...)\n{\n  char\n    value[MagickPathExtent];\n\n  ExceptionInfo\n    *exception;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    n;\n\n  va_list\n    operands;\n\n  va_start(operands,format);\n  n=FormatLocaleStringList(value,MagickPathExtent,format,operands);\n  (void) n;\n  va_end(operands);\n  exception=AcquireExceptionInfo();\n  status=SetImageProperty(image,property,value,exception);\n  exception=DestroyExceptionInfo(exception);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e P r o p e r t y                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageProperty() gets a value associated with an image property.\n%\n%  This includes,  profile prefixes, such as \"exif:\", \"iptc:\" and \"8bim:\"\n%  It does not handle non-prifile prefixes, such as \"fx:\", \"option:\", or\n%  \"artifact:\".\n%\n%  The returned string is stored as a properity of the same name for faster\n%  lookup later. It should NOT be freed by the caller.\n%\n%  The format of the GetImageProperty method is:\n%\n%      const char *GetImageProperty(const Image *image,const char *key,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o key: the key.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic char\n  *TracePSClippath(const unsigned char *,size_t),\n  *TraceSVGClippath(const unsigned char *,size_t,const size_t,\n    const size_t);\n\nstatic MagickBooleanType GetIPTCProperty(const Image *image,const char *key,\n  ExceptionInfo *exception)\n{\n  char\n    *attribute,\n    *message;\n\n  const StringInfo\n    *profile;\n\n  long\n    count,\n    dataset,\n    record;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  profile=GetImageProfile(image,\"iptc\");\n  if (profile == (StringInfo *) NULL)\n    profile=GetImageProfile(image,\"8bim\");\n  if (profile == (StringInfo *) NULL)\n    return(MagickFalse);\n  count=sscanf(key,\"IPTC:%ld:%ld\",&dataset,&record);\n  if (count != 2)\n    return(MagickFalse);\n  attribute=(char *) NULL;\n  for (i=0; i < (ssize_t) GetStringInfoLength(profile); i+=(ssize_t) length)\n  {\n    length=1;\n    if ((ssize_t) GetStringInfoDatum(profile)[i] != 0x1c)\n      continue;\n    length=(size_t) (GetStringInfoDatum(profile)[i+3] << 8);\n    length|=GetStringInfoDatum(profile)[i+4];\n    if (((long) GetStringInfoDatum(profile)[i+1] == dataset) &&\n        ((long) GetStringInfoDatum(profile)[i+2] == record))\n      {\n        message=(char *) NULL;\n        if (~length >= 1)\n          message=(char *) AcquireQuantumMemory(length+1UL,sizeof(*message));\n        if (message != (char *) NULL)\n          {\n            (void) CopyMagickString(message,(char *) GetStringInfoDatum(\n              profile)+i+5,length+1);\n            (void) ConcatenateString(&attribute,message);\n            (void) ConcatenateString(&attribute,\";\");\n            message=DestroyString(message);\n          }\n      }\n    i+=5;\n  }\n  if ((attribute == (char *) NULL) || (*attribute == ';'))\n    {\n      if (attribute != (char *) NULL)\n        attribute=DestroyString(attribute);\n      return(MagickFalse);\n    }\n  attribute[strlen(attribute)-1]='\\0';\n  (void) SetImageProperty((Image *) image,key,(const char *) attribute,\n    exception);\n  attribute=DestroyString(attribute);\n  return(MagickTrue);\n}\n\nstatic inline int ReadPropertyByte(const unsigned char **p,size_t *length)\n{\n  int\n    c;\n\n  if (*length < 1)\n    return(EOF);\n  c=(int) (*(*p)++);\n  (*length)--;\n  return(c);\n}\n\nstatic inline signed int ReadPropertyMSBLong(const unsigned char **p,\n  size_t *length)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  int\n    c;\n\n  register ssize_t\n    i;\n\n  unsigned char\n    buffer[4];\n\n  unsigned int\n    value;\n\n  if (*length < 4)\n    return(-1);\n  for (i=0; i < 4; i++)\n  {\n    c=(int) (*(*p)++);\n    (*length)--;\n    buffer[i]=(unsigned char) c;\n  }\n  value=(unsigned int) buffer[0] << 24;\n  value|=(unsigned int) buffer[1] << 16;\n  value|=(unsigned int) buffer[2] << 8;\n  value|=(unsigned int) buffer[3];\n  quantum.unsigned_value=value & 0xffffffff;\n  return(quantum.signed_value);\n}\n\nstatic inline signed short ReadPropertyMSBShort(const unsigned char **p,\n  size_t *length)\n{\n  union\n  {\n    unsigned short\n      unsigned_value;\n\n    signed short\n      signed_value;\n  } quantum;\n\n  int\n    c;\n\n  register ssize_t\n    i;\n\n  unsigned char\n    buffer[2];\n\n  unsigned short\n    value;\n\n  if (*length < 2)\n    return((unsigned short) ~0);\n  for (i=0; i < 2; i++)\n  {\n    c=(int) (*(*p)++);\n    (*length)--;\n    buffer[i]=(unsigned char) c;\n  }\n  value=(unsigned short) buffer[0] << 8;\n  value|=(unsigned short) buffer[1];\n  quantum.unsigned_value=value & 0xffff;\n  return(quantum.signed_value);\n}\n\nstatic MagickBooleanType Get8BIMProperty(const Image *image,const char *key,\n  ExceptionInfo *exception)\n{\n  char\n    *attribute,\n    format[MagickPathExtent],\n    name[MagickPathExtent],\n    *resource;\n\n  const StringInfo\n    *profile;\n\n  const unsigned char\n    *info;\n\n  long\n    start,\n    stop;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    id,\n    sub_number;\n\n  /*\n    There are no newlines in path names, so it's safe as terminator.\n  */\n  profile=GetImageProfile(image,\"8bim\");\n  if (profile == (StringInfo *) NULL)\n    return(MagickFalse);\n  count=(ssize_t) sscanf(key,\"8BIM:%ld,%ld:%1024[^\\n]\\n%1024[^\\n]\",&start,&stop,\n    name,format);\n  if ((count != 2) && (count != 3) && (count != 4))\n    return(MagickFalse);\n  if (count < 4)\n    (void) CopyMagickString(format,\"SVG\",MagickPathExtent);\n  if (count < 3)\n    *name='\\0';\n  sub_number=1;\n  if (*name == '#')\n    sub_number=(ssize_t) StringToLong(&name[1]);\n  sub_number=MagickMax(sub_number,1L);\n  resource=(char *) NULL;\n  status=MagickFalse;\n  length=GetStringInfoLength(profile);\n  info=GetStringInfoDatum(profile);\n  while ((length > 0) && (status == MagickFalse))\n  {\n    if (ReadPropertyByte(&info,&length) != (unsigned char) '8')\n      continue;\n    if (ReadPropertyByte(&info,&length) != (unsigned char) 'B')\n      continue;\n    if (ReadPropertyByte(&info,&length) != (unsigned char) 'I')\n      continue;\n    if (ReadPropertyByte(&info,&length) != (unsigned char) 'M')\n      continue;\n    id=(ssize_t) ReadPropertyMSBShort(&info,&length);\n    if (id < (ssize_t) start)\n      continue;\n    if (id > (ssize_t) stop)\n      continue;\n    if (resource != (char *) NULL)\n      resource=DestroyString(resource);\n    count=(ssize_t) ReadPropertyByte(&info,&length);\n    if ((count != 0) && ((size_t) count <= length))\n      {\n        resource=(char *) NULL;\n        if (~((size_t) count) >= (MagickPathExtent-1))\n          resource=(char *) AcquireQuantumMemory((size_t) count+\n            MagickPathExtent,sizeof(*resource));\n        if (resource != (char *) NULL)\n          {\n            for (i=0; i < (ssize_t) count; i++)\n              resource[i]=(char) ReadPropertyByte(&info,&length);\n            resource[count]='\\0';\n          }\n      }\n    if ((count & 0x01) == 0)\n      (void) ReadPropertyByte(&info,&length);\n    count=(ssize_t) ReadPropertyMSBLong(&info,&length);\n    if ((count < 0) || ((size_t) count > length))\n      {\n        length=0; \n        continue;\n      }\n    if ((*name != '\\0') && (*name != '#'))\n      if ((resource == (char *) NULL) || (LocaleCompare(name,resource) != 0))\n        {\n          /*\n            No name match, scroll forward and try next.\n          */\n          info+=count;\n          length-=MagickMin(count,(ssize_t) length);\n          continue;\n        }\n    if ((*name == '#') && (sub_number != 1))\n      {\n        /*\n          No numbered match, scroll forward and try next.\n        */\n        sub_number--;\n        info+=count;\n        length-=MagickMin(count,(ssize_t) length);\n        continue;\n      }\n    /*\n      We have the resource of interest.\n    */\n    attribute=(char *) NULL;\n    if (~((size_t) count) >= (MagickPathExtent-1))\n      attribute=(char *) AcquireQuantumMemory((size_t) count+MagickPathExtent,\n        sizeof(*attribute));\n    if (attribute != (char *) NULL)\n      {\n        (void) CopyMagickMemory(attribute,(char *) info,(size_t) count);\n        attribute[count]='\\0';\n        info+=count;\n        length-=MagickMin(count,(ssize_t) length);\n        if ((id <= 1999) || (id >= 2999))\n          (void) SetImageProperty((Image *) image,key,(const char *)\n            attribute,exception);\n        else\n          {\n            char\n              *path;\n\n            if (LocaleCompare(format,\"svg\") == 0)\n              path=TraceSVGClippath((unsigned char *) attribute,(size_t) count,\n                image->columns,image->rows);\n            else\n              path=TracePSClippath((unsigned char *) attribute,(size_t) count);\n            (void) SetImageProperty((Image *) image,key,(const char *) path,\n              exception);\n            path=DestroyString(path);\n          }\n        attribute=DestroyString(attribute);\n        status=MagickTrue;\n      }\n  }\n  if (resource != (char *) NULL)\n    resource=DestroyString(resource);\n  return(status);\n}\n\nstatic inline signed int ReadPropertySignedLong(const EndianType endian,\n  const unsigned char *buffer)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  unsigned int\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned int) buffer[3] << 24;\n      value|=(unsigned int) buffer[2] << 16;\n      value|=(unsigned int) buffer[1] << 8;\n      value|=(unsigned int) buffer[0];\n      quantum.unsigned_value=value & 0xffffffff;\n      return(quantum.signed_value);\n    }\n  value=(unsigned int) buffer[0] << 24;\n  value|=(unsigned int) buffer[1] << 16;\n  value|=(unsigned int) buffer[2] << 8;\n  value|=(unsigned int) buffer[3];\n  quantum.unsigned_value=value & 0xffffffff;\n  return(quantum.signed_value);\n}\n\nstatic inline unsigned int ReadPropertyUnsignedLong(const EndianType endian,\n  const unsigned char *buffer)\n{\n  unsigned int\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned int) buffer[3] << 24;\n      value|=(unsigned int) buffer[2] << 16;\n      value|=(unsigned int) buffer[1] << 8;\n      value|=(unsigned int) buffer[0];\n      return(value & 0xffffffff);\n    }\n  value=(unsigned int) buffer[0] << 24;\n  value|=(unsigned int) buffer[1] << 16;\n  value|=(unsigned int) buffer[2] << 8;\n  value|=(unsigned int) buffer[3];\n  return(value & 0xffffffff);\n}\n\nstatic inline signed short ReadPropertySignedShort(const EndianType endian,\n  const unsigned char *buffer)\n{\n  union\n  {\n    unsigned short\n      unsigned_value;\n\n    signed short\n      signed_value;\n  } quantum;\n\n  unsigned short\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned short) buffer[1] << 8;\n      value|=(unsigned short) buffer[0];\n      quantum.unsigned_value=value & 0xffff;\n      return(quantum.signed_value);\n    }\n  value=(unsigned short) buffer[0] << 8;\n  value|=(unsigned short) buffer[1];\n  quantum.unsigned_value=value & 0xffff;\n  return(quantum.signed_value);\n}\n\nstatic inline unsigned short ReadPropertyUnsignedShort(const EndianType endian,\n  const unsigned char *buffer)\n{\n  unsigned short\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned short) buffer[1] << 8;\n      value|=(unsigned short) buffer[0];\n      return(value & 0xffff);\n    }\n  value=(unsigned short) buffer[0] << 8;\n  value|=(unsigned short) buffer[1];\n  return(value & 0xffff);\n}\n\nstatic MagickBooleanType GetEXIFProperty(const Image *image,\n  const char *property,ExceptionInfo *exception)\n{\n#define MaxDirectoryStack  16\n#define EXIF_DELIMITER  \"\\n\"\n#define EXIF_NUM_FORMATS  12\n#define EXIF_FMT_BYTE  1\n#define EXIF_FMT_STRING  2\n#define EXIF_FMT_USHORT  3\n#define EXIF_FMT_ULONG  4\n#define EXIF_FMT_URATIONAL  5\n#define EXIF_FMT_SBYTE  6\n#define EXIF_FMT_UNDEFINED  7\n#define EXIF_FMT_SSHORT  8\n#define EXIF_FMT_SLONG  9\n#define EXIF_FMT_SRATIONAL  10\n#define EXIF_FMT_SINGLE  11\n#define EXIF_FMT_DOUBLE  12\n#define TAG_EXIF_OFFSET  0x8769\n#define TAG_GPS_OFFSET  0x8825\n#define TAG_INTEROP_OFFSET  0xa005\n\n#define EXIFMultipleValues(size,format,arg) \\\n{ \\\n   ssize_t \\\n     component; \\\n \\\n   size_t \\\n     length; \\\n \\\n   unsigned char \\\n     *p1; \\\n \\\n   length=0; \\\n   p1=p; \\\n   for (component=0; component < components; component++) \\\n   { \\\n     length+=FormatLocaleString(buffer+length,MagickPathExtent-length, \\\n       format\", \",arg); \\\n     if (length >= (MagickPathExtent-1)) \\\n       length=MagickPathExtent-1; \\\n     p1+=size; \\\n   } \\\n   if (length > 1) \\\n     buffer[length-2]='\\0'; \\\n   value=AcquireString(buffer); \\\n}\n\n#define EXIFMultipleFractions(size,format,arg1,arg2) \\\n{ \\\n   ssize_t \\\n     component; \\\n \\\n   size_t \\\n     length; \\\n \\\n   unsigned char \\\n     *p1; \\\n \\\n   length=0; \\\n   p1=p; \\\n   for (component=0; component < components; component++) \\\n   { \\\n     length+=FormatLocaleString(buffer+length,MagickPathExtent-length, \\\n       format\", \",(arg1),(arg2)); \\\n     if (length >= (MagickPathExtent-1)) \\\n       length=MagickPathExtent-1; \\\n     p1+=size; \\\n   } \\\n   if (length > 1) \\\n     buffer[length-2]='\\0'; \\\n   value=AcquireString(buffer); \\\n}\n\n  typedef struct _DirectoryInfo\n  {\n    const unsigned char\n      *directory;\n\n    size_t\n      entry;\n\n    ssize_t\n      offset;\n  } DirectoryInfo;\n\n  typedef struct _TagInfo\n  {\n    size_t\n      tag;\n\n    const char\n      *description;\n  } TagInfo;\n\n  static TagInfo\n    EXIFTag[] =\n    {\n      {  0x001, \"exif:InteroperabilityIndex\" },\n      {  0x002, \"exif:InteroperabilityVersion\" },\n      {  0x100, \"exif:ImageWidth\" },\n      {  0x101, \"exif:ImageLength\" },\n      {  0x102, \"exif:BitsPerSample\" },\n      {  0x103, \"exif:Compression\" },\n      {  0x106, \"exif:PhotometricInterpretation\" },\n      {  0x10a, \"exif:FillOrder\" },\n      {  0x10d, \"exif:DocumentName\" },\n      {  0x10e, \"exif:ImageDescription\" },\n      {  0x10f, \"exif:Make\" },\n      {  0x110, \"exif:Model\" },\n      {  0x111, \"exif:StripOffsets\" },\n      {  0x112, \"exif:Orientation\" },\n      {  0x115, \"exif:SamplesPerPixel\" },\n      {  0x116, \"exif:RowsPerStrip\" },\n      {  0x117, \"exif:StripByteCounts\" },\n      {  0x11a, \"exif:XResolution\" },\n      {  0x11b, \"exif:YResolution\" },\n      {  0x11c, \"exif:PlanarConfiguration\" },\n      {  0x11d, \"exif:PageName\" },\n      {  0x11e, \"exif:XPosition\" },\n      {  0x11f, \"exif:YPosition\" },\n      {  0x118, \"exif:MinSampleValue\" },\n      {  0x119, \"exif:MaxSampleValue\" },\n      {  0x120, \"exif:FreeOffsets\" },\n      {  0x121, \"exif:FreeByteCounts\" },\n      {  0x122, \"exif:GrayResponseUnit\" },\n      {  0x123, \"exif:GrayResponseCurve\" },\n      {  0x124, \"exif:T4Options\" },\n      {  0x125, \"exif:T6Options\" },\n      {  0x128, \"exif:ResolutionUnit\" },\n      {  0x12d, \"exif:TransferFunction\" },\n      {  0x131, \"exif:Software\" },\n      {  0x132, \"exif:DateTime\" },\n      {  0x13b, \"exif:Artist\" },\n      {  0x13e, \"exif:WhitePoint\" },\n      {  0x13f, \"exif:PrimaryChromaticities\" },\n      {  0x140, \"exif:ColorMap\" },\n      {  0x141, \"exif:HalfToneHints\" },\n      {  0x142, \"exif:TileWidth\" },\n      {  0x143, \"exif:TileLength\" },\n      {  0x144, \"exif:TileOffsets\" },\n      {  0x145, \"exif:TileByteCounts\" },\n      {  0x14a, \"exif:SubIFD\" },\n      {  0x14c, \"exif:InkSet\" },\n      {  0x14d, \"exif:InkNames\" },\n      {  0x14e, \"exif:NumberOfInks\" },\n      {  0x150, \"exif:DotRange\" },\n      {  0x151, \"exif:TargetPrinter\" },\n      {  0x152, \"exif:ExtraSample\" },\n      {  0x153, \"exif:SampleFormat\" },\n      {  0x154, \"exif:SMinSampleValue\" },\n      {  0x155, \"exif:SMaxSampleValue\" },\n      {  0x156, \"exif:TransferRange\" },\n      {  0x157, \"exif:ClipPath\" },\n      {  0x158, \"exif:XClipPathUnits\" },\n      {  0x159, \"exif:YClipPathUnits\" },\n      {  0x15a, \"exif:Indexed\" },\n      {  0x15b, \"exif:JPEGTables\" },\n      {  0x15f, \"exif:OPIProxy\" },\n      {  0x200, \"exif:JPEGProc\" },\n      {  0x201, \"exif:JPEGInterchangeFormat\" },\n      {  0x202, \"exif:JPEGInterchangeFormatLength\" },\n      {  0x203, \"exif:JPEGRestartInterval\" },\n      {  0x205, \"exif:JPEGLosslessPredictors\" },\n      {  0x206, \"exif:JPEGPointTransforms\" },\n      {  0x207, \"exif:JPEGQTables\" },\n      {  0x208, \"exif:JPEGDCTables\" },\n      {  0x209, \"exif:JPEGACTables\" },\n      {  0x211, \"exif:YCbCrCoefficients\" },\n      {  0x212, \"exif:YCbCrSubSampling\" },\n      {  0x213, \"exif:YCbCrPositioning\" },\n      {  0x214, \"exif:ReferenceBlackWhite\" },\n      {  0x2bc, \"exif:ExtensibleMetadataPlatform\" },\n      {  0x301, \"exif:Gamma\" },\n      {  0x302, \"exif:ICCProfileDescriptor\" },\n      {  0x303, \"exif:SRGBRenderingIntent\" },\n      {  0x320, \"exif:ImageTitle\" },\n      {  0x5001, \"exif:ResolutionXUnit\" },\n      {  0x5002, \"exif:ResolutionYUnit\" },\n      {  0x5003, \"exif:ResolutionXLengthUnit\" },\n      {  0x5004, \"exif:ResolutionYLengthUnit\" },\n      {  0x5005, \"exif:PrintFlags\" },\n      {  0x5006, \"exif:PrintFlagsVersion\" },\n      {  0x5007, \"exif:PrintFlagsCrop\" },\n      {  0x5008, \"exif:PrintFlagsBleedWidth\" },\n      {  0x5009, \"exif:PrintFlagsBleedWidthScale\" },\n      {  0x500A, \"exif:HalftoneLPI\" },\n      {  0x500B, \"exif:HalftoneLPIUnit\" },\n      {  0x500C, \"exif:HalftoneDegree\" },\n      {  0x500D, \"exif:HalftoneShape\" },\n      {  0x500E, \"exif:HalftoneMisc\" },\n      {  0x500F, \"exif:HalftoneScreen\" },\n      {  0x5010, \"exif:JPEGQuality\" },\n      {  0x5011, \"exif:GridSize\" },\n      {  0x5012, \"exif:ThumbnailFormat\" },\n      {  0x5013, \"exif:ThumbnailWidth\" },\n      {  0x5014, \"exif:ThumbnailHeight\" },\n      {  0x5015, \"exif:ThumbnailColorDepth\" },\n      {  0x5016, \"exif:ThumbnailPlanes\" },\n      {  0x5017, \"exif:ThumbnailRawBytes\" },\n      {  0x5018, \"exif:ThumbnailSize\" },\n      {  0x5019, \"exif:ThumbnailCompressedSize\" },\n      {  0x501a, \"exif:ColorTransferFunction\" },\n      {  0x501b, \"exif:ThumbnailData\" },\n      {  0x5020, \"exif:ThumbnailImageWidth\" },\n      {  0x5021, \"exif:ThumbnailImageHeight\" },\n      {  0x5022, \"exif:ThumbnailBitsPerSample\" },\n      {  0x5023, \"exif:ThumbnailCompression\" },\n      {  0x5024, \"exif:ThumbnailPhotometricInterp\" },\n      {  0x5025, \"exif:ThumbnailImageDescription\" },\n      {  0x5026, \"exif:ThumbnailEquipMake\" },\n      {  0x5027, \"exif:ThumbnailEquipModel\" },\n      {  0x5028, \"exif:ThumbnailStripOffsets\" },\n      {  0x5029, \"exif:ThumbnailOrientation\" },\n      {  0x502a, \"exif:ThumbnailSamplesPerPixel\" },\n      {  0x502b, \"exif:ThumbnailRowsPerStrip\" },\n      {  0x502c, \"exif:ThumbnailStripBytesCount\" },\n      {  0x502d, \"exif:ThumbnailResolutionX\" },\n      {  0x502e, \"exif:ThumbnailResolutionY\" },\n      {  0x502f, \"exif:ThumbnailPlanarConfig\" },\n      {  0x5030, \"exif:ThumbnailResolutionUnit\" },\n      {  0x5031, \"exif:ThumbnailTransferFunction\" },\n      {  0x5032, \"exif:ThumbnailSoftwareUsed\" },\n      {  0x5033, \"exif:ThumbnailDateTime\" },\n      {  0x5034, \"exif:ThumbnailArtist\" },\n      {  0x5035, \"exif:ThumbnailWhitePoint\" },\n      {  0x5036, \"exif:ThumbnailPrimaryChromaticities\" },\n      {  0x5037, \"exif:ThumbnailYCbCrCoefficients\" },\n      {  0x5038, \"exif:ThumbnailYCbCrSubsampling\" },\n      {  0x5039, \"exif:ThumbnailYCbCrPositioning\" },\n      {  0x503A, \"exif:ThumbnailRefBlackWhite\" },\n      {  0x503B, \"exif:ThumbnailCopyRight\" },\n      {  0x5090, \"exif:LuminanceTable\" },\n      {  0x5091, \"exif:ChrominanceTable\" },\n      {  0x5100, \"exif:FrameDelay\" },\n      {  0x5101, \"exif:LoopCount\" },\n      {  0x5110, \"exif:PixelUnit\" },\n      {  0x5111, \"exif:PixelPerUnitX\" },\n      {  0x5112, \"exif:PixelPerUnitY\" },\n      {  0x5113, \"exif:PaletteHistogram\" },\n      {  0x1000, \"exif:RelatedImageFileFormat\" },\n      {  0x1001, \"exif:RelatedImageLength\" },\n      {  0x1002, \"exif:RelatedImageWidth\" },\n      {  0x800d, \"exif:ImageID\" },\n      {  0x80e3, \"exif:Matteing\" },\n      {  0x80e4, \"exif:DataType\" },\n      {  0x80e5, \"exif:ImageDepth\" },\n      {  0x80e6, \"exif:TileDepth\" },\n      {  0x828d, \"exif:CFARepeatPatternDim\" },\n      {  0x828e, \"exif:CFAPattern2\" },\n      {  0x828f, \"exif:BatteryLevel\" },\n      {  0x8298, \"exif:Copyright\" },\n      {  0x829a, \"exif:ExposureTime\" },\n      {  0x829d, \"exif:FNumber\" },\n      {  0x83bb, \"exif:IPTC/NAA\" },\n      {  0x84e3, \"exif:IT8RasterPadding\" },\n      {  0x84e5, \"exif:IT8ColorTable\" },\n      {  0x8649, \"exif:ImageResourceInformation\" },\n      {  0x8769, \"exif:ExifOffset\" },\n      {  0x8773, \"exif:InterColorProfile\" },\n      {  0x8822, \"exif:ExposureProgram\" },\n      {  0x8824, \"exif:SpectralSensitivity\" },\n      {  0x8825, \"exif:GPSInfo\" },\n      {  0x8827, \"exif:ISOSpeedRatings\" },\n      {  0x8828, \"exif:OECF\" },\n      {  0x8829, \"exif:Interlace\" },\n      {  0x882a, \"exif:TimeZoneOffset\" },\n      {  0x882b, \"exif:SelfTimerMode\" },\n      {  0x9000, \"exif:ExifVersion\" },\n      {  0x9003, \"exif:DateTimeOriginal\" },\n      {  0x9004, \"exif:DateTimeDigitized\" },\n      {  0x9101, \"exif:ComponentsConfiguration\" },\n      {  0x9102, \"exif:CompressedBitsPerPixel\" },\n      {  0x9201, \"exif:ShutterSpeedValue\" },\n      {  0x9202, \"exif:ApertureValue\" },\n      {  0x9203, \"exif:BrightnessValue\" },\n      {  0x9204, \"exif:ExposureBiasValue\" },\n      {  0x9205, \"exif:MaxApertureValue\" },\n      {  0x9206, \"exif:SubjectDistance\" },\n      {  0x9207, \"exif:MeteringMode\" },\n      {  0x9208, \"exif:LightSource\" },\n      {  0x9209, \"exif:Flash\" },\n      {  0x920a, \"exif:FocalLength\" },\n      {  0x920b, \"exif:FlashEnergy\" },\n      {  0x920c, \"exif:SpatialFrequencyResponse\" },\n      {  0x920d, \"exif:Noise\" },\n      {  0x9211, \"exif:ImageNumber\" },\n      {  0x9212, \"exif:SecurityClassification\" },\n      {  0x9213, \"exif:ImageHistory\" },\n      {  0x9214, \"exif:SubjectArea\" },\n      {  0x9215, \"exif:ExposureIndex\" },\n      {  0x9216, \"exif:TIFF-EPStandardID\" },\n      {  0x927c, \"exif:MakerNote\" },\n      {  0x9C9b, \"exif:WinXP-Title\" },\n      {  0x9C9c, \"exif:WinXP-Comments\" },\n      {  0x9C9d, \"exif:WinXP-Author\" },\n      {  0x9C9e, \"exif:WinXP-Keywords\" },\n      {  0x9C9f, \"exif:WinXP-Subject\" },\n      {  0x9286, \"exif:UserComment\" },\n      {  0x9290, \"exif:SubSecTime\" },\n      {  0x9291, \"exif:SubSecTimeOriginal\" },\n      {  0x9292, \"exif:SubSecTimeDigitized\" },\n      {  0xa000, \"exif:FlashPixVersion\" },\n      {  0xa001, \"exif:ColorSpace\" },\n      {  0xa002, \"exif:ExifImageWidth\" },\n      {  0xa003, \"exif:ExifImageLength\" },\n      {  0xa004, \"exif:RelatedSoundFile\" },\n      {  0xa005, \"exif:InteroperabilityOffset\" },\n      {  0xa20b, \"exif:FlashEnergy\" },\n      {  0xa20c, \"exif:SpatialFrequencyResponse\" },\n      {  0xa20d, \"exif:Noise\" },\n      {  0xa20e, \"exif:FocalPlaneXResolution\" },\n      {  0xa20f, \"exif:FocalPlaneYResolution\" },\n      {  0xa210, \"exif:FocalPlaneResolutionUnit\" },\n      {  0xa214, \"exif:SubjectLocation\" },\n      {  0xa215, \"exif:ExposureIndex\" },\n      {  0xa216, \"exif:TIFF/EPStandardID\" },\n      {  0xa217, \"exif:SensingMethod\" },\n      {  0xa300, \"exif:FileSource\" },\n      {  0xa301, \"exif:SceneType\" },\n      {  0xa302, \"exif:CFAPattern\" },\n      {  0xa401, \"exif:CustomRendered\" },\n      {  0xa402, \"exif:ExposureMode\" },\n      {  0xa403, \"exif:WhiteBalance\" },\n      {  0xa404, \"exif:DigitalZoomRatio\" },\n      {  0xa405, \"exif:FocalLengthIn35mmFilm\" },\n      {  0xa406, \"exif:SceneCaptureType\" },\n      {  0xa407, \"exif:GainControl\" },\n      {  0xa408, \"exif:Contrast\" },\n      {  0xa409, \"exif:Saturation\" },\n      {  0xa40a, \"exif:Sharpness\" },\n      {  0xa40b, \"exif:DeviceSettingDescription\" },\n      {  0xa40c, \"exif:SubjectDistanceRange\" },\n      {  0xa420, \"exif:ImageUniqueID\" },\n      {  0xc4a5, \"exif:PrintImageMatching\" },\n      {  0xa500, \"exif:Gamma\" },\n      {  0xc640, \"exif:CR2Slice\" },\n      { 0x10000, \"exif:GPSVersionID\" },\n      { 0x10001, \"exif:GPSLatitudeRef\" },\n      { 0x10002, \"exif:GPSLatitude\" },\n      { 0x10003, \"exif:GPSLongitudeRef\" },\n      { 0x10004, \"exif:GPSLongitude\" },\n      { 0x10005, \"exif:GPSAltitudeRef\" },\n      { 0x10006, \"exif:GPSAltitude\" },\n      { 0x10007, \"exif:GPSTimeStamp\" },\n      { 0x10008, \"exif:GPSSatellites\" },\n      { 0x10009, \"exif:GPSStatus\" },\n      { 0x1000a, \"exif:GPSMeasureMode\" },\n      { 0x1000b, \"exif:GPSDop\" },\n      { 0x1000c, \"exif:GPSSpeedRef\" },\n      { 0x1000d, \"exif:GPSSpeed\" },\n      { 0x1000e, \"exif:GPSTrackRef\" },\n      { 0x1000f, \"exif:GPSTrack\" },\n      { 0x10010, \"exif:GPSImgDirectionRef\" },\n      { 0x10011, \"exif:GPSImgDirection\" },\n      { 0x10012, \"exif:GPSMapDatum\" },\n      { 0x10013, \"exif:GPSDestLatitudeRef\" },\n      { 0x10014, \"exif:GPSDestLatitude\" },\n      { 0x10015, \"exif:GPSDestLongitudeRef\" },\n      { 0x10016, \"exif:GPSDestLongitude\" },\n      { 0x10017, \"exif:GPSDestBearingRef\" },\n      { 0x10018, \"exif:GPSDestBearing\" },\n      { 0x10019, \"exif:GPSDestDistanceRef\" },\n      { 0x1001a, \"exif:GPSDestDistance\" },\n      { 0x1001b, \"exif:GPSProcessingMethod\" },\n      { 0x1001c, \"exif:GPSAreaInformation\" },\n      { 0x1001d, \"exif:GPSDateStamp\" },\n      { 0x1001e, \"exif:GPSDifferential\" },\n      { 0x00000, (const char *) NULL }\n    };\n\n  const StringInfo\n    *profile;\n\n  const unsigned char\n    *directory,\n    *exif;\n\n  DirectoryInfo\n    directory_stack[MaxDirectoryStack];\n\n  EndianType\n    endian;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    entry,\n    length,\n    number_entries,\n    tag,\n    tag_value;\n\n  SplayTreeInfo\n    *exif_resources;\n\n  ssize_t\n    all,\n    id,\n    level,\n    offset,\n    tag_offset;\n\n  static int\n    tag_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};\n\n  /*\n    If EXIF data exists, then try to parse the request for a tag.\n  */\n  profile=GetImageProfile(image,\"exif\");\n  if (profile == (const StringInfo *) NULL)\n    return(MagickFalse);\n  if ((property == (const char *) NULL) || (*property == '\\0'))\n    return(MagickFalse);\n  while (isspace((int) ((unsigned char) *property)) != 0)\n    property++;\n  if (strlen(property) <= 5)\n    return(MagickFalse);\n  all=0;\n  tag=(~0UL);\n  switch (*(property+5))\n  {\n    case '*':\n    {\n      /*\n        Caller has asked for all the tags in the EXIF data.\n      */\n      tag=0;\n      all=1; /* return the data in description=value format */\n      break;\n    }\n    case '!':\n    {\n      tag=0;\n      all=2; /* return the data in tagid=value format */\n      break;\n    }\n    case '#':\n    case '@':\n    {\n      int\n        c;\n\n      size_t\n        n;\n\n      /*\n        Check for a hex based tag specification first.\n      */\n      tag=(*(property+5) == '@') ? 1UL : 0UL;\n      property+=6;\n      n=strlen(property);\n      if (n != 4)\n        return(MagickFalse);\n      /*\n        Parse tag specification as a hex number.\n      */\n      n/=4;\n      do\n      {\n        for (i=(ssize_t) n-1L; i >= 0; i--)\n        {\n          c=(*property++);\n          tag<<=4;\n          if ((c >= '0') && (c <= '9'))\n            tag|=(c-'0');\n          else\n            if ((c >= 'A') && (c <= 'F'))\n              tag|=(c-('A'-10));\n            else\n              if ((c >= 'a') && (c <= 'f'))\n                tag|=(c-('a'-10));\n              else\n                return(MagickFalse);\n        }\n      } while (*property != '\\0');\n      break;\n    }\n    default:\n    {\n      /*\n        Try to match the text with a tag name instead.\n      */\n      for (i=0; ; i++)\n      {\n        if (EXIFTag[i].tag == 0)\n          break;\n        if (LocaleCompare(EXIFTag[i].description,property) == 0)\n          {\n            tag=(size_t) EXIFTag[i].tag;\n            break;\n          }\n      }\n      break;\n    }\n  }\n  if (tag == (~0UL))\n    return(MagickFalse);\n  length=GetStringInfoLength(profile);\n  exif=GetStringInfoDatum(profile);\n  while (length != 0)\n  {\n    if (ReadPropertyByte(&exif,&length) != 0x45)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x78)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x69)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x66)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x00)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x00)\n      continue;\n    break;\n  }\n  if (length < 16)\n    return(MagickFalse);\n  id=(ssize_t) ReadPropertySignedShort(LSBEndian,exif);\n  endian=LSBEndian;\n  if (id == 0x4949)\n    endian=LSBEndian;\n  else\n    if (id == 0x4D4D)\n      endian=MSBEndian;\n    else\n      return(MagickFalse);\n  if (ReadPropertyUnsignedShort(endian,exif+2) != 0x002a)\n    return(MagickFalse);\n  /*\n    This the offset to the first IFD.\n  */\n  offset=(ssize_t) ReadPropertySignedLong(endian,exif+4);\n  if ((offset < 0) || (size_t) offset >= length)\n    return(MagickFalse);\n  /*\n    Set the pointer to the first IFD and follow it were it leads.\n  */\n  status=MagickFalse;\n  directory=exif+offset;\n  level=0;\n  entry=0;\n  tag_offset=0;\n  exif_resources=NewSplayTree((int (*)(const void *,const void *)) NULL,\n    (void *(*)(void *)) NULL,(void *(*)(void *)) NULL);\n  do\n  {\n    /*\n      If there is anything on the stack then pop it off.\n    */\n    if (level > 0)\n      {\n        level--;\n        directory=directory_stack[level].directory;\n        entry=directory_stack[level].entry;\n        tag_offset=directory_stack[level].offset;\n      }\n    if ((directory < exif) || (directory > (exif+length-2)))\n      break;\n    /*\n      Determine how many entries there are in the current IFD.\n    */\n    number_entries=(size_t) ReadPropertyUnsignedShort(endian,directory);\n    for ( ; entry < number_entries; entry++)\n    {\n      register unsigned char\n        *p,\n        *q;\n\n      size_t\n        format;\n\n      ssize_t\n        number_bytes,\n        components;\n\n      q=(unsigned char *) (directory+(12*entry)+2);\n      if (q > (exif+length-12))\n        break;  /* corrupt EXIF */\n      if (GetValueFromSplayTree(exif_resources,q) == q)\n        break;\n      (void) AddValueToSplayTree(exif_resources,q,q);\n      tag_value=(size_t) ReadPropertyUnsignedShort(endian,q)+tag_offset;\n      format=(size_t) ReadPropertyUnsignedShort(endian,q+2);\n      if (format >= (sizeof(tag_bytes)/sizeof(*tag_bytes)))\n        break;\n      components=(ssize_t) ReadPropertySignedLong(endian,q+4);\n      if (components < 0)\n        break;  /* corrupt EXIF */\n      number_bytes=(size_t) components*tag_bytes[format];\n      if (number_bytes < components)\n        break;  /* prevent overflow */\n      if (number_bytes <= 4)\n        p=q+8;\n      else\n        {\n          ssize_t\n            offset;\n\n          /*\n            The directory entry contains an offset.\n          */\n          offset=(ssize_t) ReadPropertySignedLong(endian,q+8);\n          if ((offset < 0) || (size_t) offset >= length)\n            continue;\n          if ((ssize_t) (offset+number_bytes) < offset)\n            continue;  /* prevent overflow */\n          if ((size_t) (offset+number_bytes) > length)\n            continue;\n          p=(unsigned char *) (exif+offset);\n        }\n      if ((all != 0) || (tag == (size_t) tag_value))\n        {\n          char\n            buffer[MagickPathExtent],\n            *value;\n\n          value=(char *) NULL;\n          *buffer='\\0';\n          switch (format)\n          {\n            case EXIF_FMT_BYTE:\n            case EXIF_FMT_UNDEFINED:\n            {\n              EXIFMultipleValues(1,\"%.20g\",(double) (*(unsigned char *) p1));\n              break;\n            }\n            case EXIF_FMT_SBYTE:\n            {\n              EXIFMultipleValues(1,\"%.20g\",(double) (*(signed char *) p1));\n              break;\n            }\n            case EXIF_FMT_SSHORT:\n            {\n              EXIFMultipleValues(2,\"%hd\",ReadPropertySignedShort(endian,p1));\n              break;\n            }\n            case EXIF_FMT_USHORT:\n            {\n              EXIFMultipleValues(2,\"%hu\",ReadPropertyUnsignedShort(endian,p1));\n              break;\n            }\n            case EXIF_FMT_ULONG:\n            {\n              EXIFMultipleValues(4,\"%.20g\",(double)\n                ReadPropertyUnsignedLong(endian,p1));\n              break;\n            }\n            case EXIF_FMT_SLONG:\n            {\n              EXIFMultipleValues(4,\"%.20g\",(double)\n                ReadPropertySignedLong(endian,p1));\n              break;\n            }\n            case EXIF_FMT_URATIONAL:\n            {\n              EXIFMultipleFractions(8,\"%.20g/%.20g\",(double)\n                ReadPropertyUnsignedLong(endian,p1),(double)\n                ReadPropertyUnsignedLong(endian,p1+4));\n              break;\n            }\n            case EXIF_FMT_SRATIONAL:\n            {\n              EXIFMultipleFractions(8,\"%.20g/%.20g\",(double)\n                ReadPropertySignedLong(endian,p1),(double)\n                ReadPropertySignedLong(endian,p1+4));\n              break;\n            }\n            case EXIF_FMT_SINGLE:\n            {\n              EXIFMultipleValues(4,\"%f\",(double) *(float *) p1);\n              break;\n            }\n            case EXIF_FMT_DOUBLE:\n            {\n              EXIFMultipleValues(8,\"%f\",*(double *) p1);\n              break;\n            }\n            default:\n            case EXIF_FMT_STRING:\n            {\n              value=(char *) NULL;\n              if (~((size_t) number_bytes) >= 1)\n                value=(char *) AcquireQuantumMemory((size_t) number_bytes+1UL,\n                  sizeof(*value));\n              if (value != (char *) NULL)\n                {\n                  register ssize_t\n                    i;\n\n                  for (i=0; i < (ssize_t) number_bytes; i++)\n                  {\n                    value[i]='.';\n                    if ((isprint((int) p[i]) != 0) || (p[i] == '\\0'))\n                      value[i]=(char) p[i];\n                  }\n                  value[i]='\\0';\n                }\n              break;\n            }\n          }\n          if (value != (char *) NULL)\n            {\n              char\n                *key;\n\n              register const char\n                *p;\n\n              key=AcquireString(property);\n              switch (all)\n              {\n                case 1:\n                {\n                  const char\n                    *description;\n\n                  register ssize_t\n                    i;\n\n                  description=\"unknown\";\n                  for (i=0; ; i++)\n                  {\n                    if (EXIFTag[i].tag == 0)\n                      break;\n                    if (EXIFTag[i].tag == tag_value)\n                      {\n                        description=EXIFTag[i].description;\n                        break;\n                      }\n                  }\n                  (void) FormatLocaleString(key,MagickPathExtent,\"%s\",\n                    description);\n                  if (level == 2)\n                    (void) SubstituteString(&key,\"exif:\",\"exif:thumbnail:\");\n                  break;\n                }\n                case 2:\n                {\n                  if (tag_value < 0x10000)\n                    (void) FormatLocaleString(key,MagickPathExtent,\"#%04lx\",\n                      (unsigned long) tag_value);\n                  else\n                    if (tag_value < 0x20000)\n                      (void) FormatLocaleString(key,MagickPathExtent,\"@%04lx\",\n                        (unsigned long) (tag_value & 0xffff));\n                    else\n                      (void) FormatLocaleString(key,MagickPathExtent,\"unknown\");\n                  break;\n                }\n                default:\n                {\n                  if (level == 2)\n                    (void) SubstituteString(&key,\"exif:\",\"exif:thumbnail:\");\n                }\n              }\n              p=(const char *) NULL;\n              if (image->properties != (void *) NULL)\n                p=(const char *) GetValueFromSplayTree((SplayTreeInfo *)\n                  image->properties,key);\n              if (p == (const char *) NULL)\n                (void) SetImageProperty((Image *) image,key,value,exception);\n              value=DestroyString(value);\n              key=DestroyString(key);\n              status=MagickTrue;\n            }\n        }\n        if ((tag_value == TAG_EXIF_OFFSET) ||\n            (tag_value == TAG_INTEROP_OFFSET) || (tag_value == TAG_GPS_OFFSET))\n          {\n            ssize_t\n              offset;\n\n            offset=(ssize_t) ReadPropertySignedLong(endian,p);\n            if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))\n              {\n                ssize_t\n                  tag_offset1;\n\n                tag_offset1=(ssize_t) ((tag_value == TAG_GPS_OFFSET) ? 0x10000 :\n                  0);\n                directory_stack[level].directory=directory;\n                entry++;\n                directory_stack[level].entry=entry;\n                directory_stack[level].offset=tag_offset;\n                level++;\n                directory_stack[level].directory=exif+offset;\n                directory_stack[level].offset=tag_offset1;\n                directory_stack[level].entry=0;\n                level++;\n                if ((directory+2+(12*number_entries)) > (exif+length))\n                  break;\n                offset=(ssize_t) ReadPropertySignedLong(endian,directory+2+(12*\n                  number_entries));\n                if ((offset != 0) && ((size_t) offset < length) &&\n                    (level < (MaxDirectoryStack-2)))\n                  {\n                    directory_stack[level].directory=exif+offset;\n                    directory_stack[level].entry=0;\n                    directory_stack[level].offset=tag_offset1;\n                    level++;\n                  }\n              }\n            break;\n          }\n    }\n  } while (level > 0);\n  exif_resources=DestroySplayTree(exif_resources);\n  return(status);\n}\n\nstatic MagickBooleanType GetICCProperty(const Image *image,const char *property,\n  ExceptionInfo *exception)\n{\n  const StringInfo\n    *profile;\n\n  magick_unreferenced(property);\n\n  profile=GetImageProfile(image,\"icc\");\n  if (profile == (StringInfo *) NULL)\n    profile=GetImageProfile(image,\"icm\");\n  if (profile == (StringInfo *) NULL)\n    return(MagickFalse);\n  if (GetStringInfoLength(profile) < 128)\n    return(MagickFalse);  /* minimum ICC profile length */\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n  {\n    cmsHPROFILE\n      icc_profile;\n\n    icc_profile=cmsOpenProfileFromMem(GetStringInfoDatum(profile),\n      (cmsUInt32Number) GetStringInfoLength(profile));\n    if (icc_profile != (cmsHPROFILE *) NULL)\n      {\n#if defined(LCMS_VERSION) && (LCMS_VERSION < 2000)\n        const char\n          *name;\n\n        name=cmsTakeProductName(icc_profile);\n        if (name != (const char *) NULL)\n          (void) SetImageProperty((Image *) image,\"icc:name\",name,exception);\n#else\n        char\n          info[MagickPathExtent];\n\n        (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoDescription,\"en\",\"US\",\n          info,MagickPathExtent);\n        (void) SetImageProperty((Image *) image,\"icc:description\",info,\n          exception);\n        (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoManufacturer,\"en\",\"US\",\n          info,MagickPathExtent);\n        (void) SetImageProperty((Image *) image,\"icc:manufacturer\",info,\n          exception);\n        (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoModel,\"en\",\"US\",info,\n          MagickPathExtent);\n        (void) SetImageProperty((Image *) image,\"icc:model\",info,exception);\n        (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoCopyright,\"en\",\"US\",\n          info,MagickPathExtent);\n        (void) SetImageProperty((Image *) image,\"icc:copyright\",info,exception);\n#endif\n        (void) cmsCloseProfile(icc_profile);\n      }\n  }\n#endif\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType SkipXMPValue(const char *value)\n{\n  if (value == (const char*) NULL)\n    return(MagickTrue);\n  while (*value != '\\0')\n  {\n    if (isspace((int) ((unsigned char) *value)) == 0)\n      return(MagickFalse);\n    value++;\n  }\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType GetXMPProperty(const Image *image,const char *property)\n{\n  char\n    *xmp_profile;\n\n  const char\n    *content;\n\n  const StringInfo\n    *profile;\n\n  ExceptionInfo\n    *exception;\n\n  MagickBooleanType\n    status;\n\n  register const char\n    *p;\n\n  XMLTreeInfo\n    *child,\n    *description,\n    *node,\n    *rdf,\n    *xmp;\n\n  profile=GetImageProfile(image,\"xmp\");\n  if (profile == (StringInfo *) NULL)\n    return(MagickFalse);\n  if ((property == (const char *) NULL) || (*property == '\\0'))\n    return(MagickFalse);\n  xmp_profile=StringInfoToString(profile);\n  if (xmp_profile == (char *) NULL)\n    return(MagickFalse);\n  for (p=xmp_profile; *p != '\\0'; p++)\n    if ((*p == '<') && (*(p+1) == 'x'))\n      break;\n  exception=AcquireExceptionInfo();\n  xmp=NewXMLTree((char *) p,exception);\n  xmp_profile=DestroyString(xmp_profile);\n  exception=DestroyExceptionInfo(exception);\n  if (xmp == (XMLTreeInfo *) NULL)\n    return(MagickFalse);\n  status=MagickFalse;\n  rdf=GetXMLTreeChild(xmp,\"rdf:RDF\");\n  if (rdf != (XMLTreeInfo *) NULL)\n    {\n      if (image->properties == (void *) NULL)\n        ((Image *) image)->properties=NewSplayTree(CompareSplayTreeString,\n          RelinquishMagickMemory,RelinquishMagickMemory);\n      description=GetXMLTreeChild(rdf,\"rdf:Description\");\n      while (description != (XMLTreeInfo *) NULL)\n      {\n        node=GetXMLTreeChild(description,(const char *) NULL);\n        while (node != (XMLTreeInfo *) NULL)\n        {\n          child=GetXMLTreeChild(node,(const char *) NULL);\n          content=GetXMLTreeContent(node);\n          if ((child == (XMLTreeInfo *) NULL) &&\n              (SkipXMPValue(content) == MagickFalse))\n            (void) AddValueToSplayTree((SplayTreeInfo *) image->properties,\n              ConstantString(GetXMLTreeTag(node)),ConstantString(content));\n          while (child != (XMLTreeInfo *) NULL)\n          {\n            content=GetXMLTreeContent(child);\n            if (SkipXMPValue(content) == MagickFalse)\n              (void) AddValueToSplayTree((SplayTreeInfo *) image->properties,\n                ConstantString(GetXMLTreeTag(child)),ConstantString(content));\n            child=GetXMLTreeSibling(child);\n          }\n          node=GetXMLTreeSibling(node);\n        }\n        description=GetNextXMLTreeTag(description);\n      }\n    }\n  xmp=DestroyXMLTree(xmp);\n  return(status);\n}\n\nstatic char *TracePSClippath(const unsigned char *blob,size_t length)\n{\n  char\n    *path,\n    *message;\n\n  MagickBooleanType\n    in_subpath;\n\n  PointInfo\n    first[3],\n    last[3],\n    point[3];\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    knot_count,\n    selector,\n    y;\n\n  path=AcquireString((char *) NULL);\n  if (path == (char *) NULL)\n    return((char *) NULL);\n  message=AcquireString((char *) NULL);\n  (void) FormatLocaleString(message,MagickPathExtent,\"/ClipImage\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"{\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"  /c {curveto} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"  /l {lineto} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"  /m {moveto} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"  /v {currentpoint 6 2 roll curveto} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"  /y {2 copy curveto} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"  /z {closepath} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"  newpath\\n\");\n  (void) ConcatenateString(&path,message);\n  /*\n    The clipping path format is defined in \"Adobe Photoshop File Formats\n    Specification\" version 6.0 downloadable from adobe.com.\n  */\n  (void) ResetMagickMemory(point,0,sizeof(point));\n  (void) ResetMagickMemory(first,0,sizeof(first));\n  (void) ResetMagickMemory(last,0,sizeof(last));\n  knot_count=0;\n  in_subpath=MagickFalse;\n  while (length > 0)\n  {\n    selector=(ssize_t) ReadPropertyMSBShort(&blob,&length);\n    switch (selector)\n    {\n      case 0:\n      case 3:\n      {\n        if (knot_count != 0)\n          {\n            blob+=24;\n            length-=MagickMin(24,(ssize_t) length);\n            break;\n          }\n        /*\n          Expected subpath length record.\n        */\n        knot_count=(ssize_t) ReadPropertyMSBShort(&blob,&length);\n        blob+=22;\n        length-=MagickMin(22,(ssize_t) length);\n        break;\n      }\n      case 1:\n      case 2:\n      case 4:\n      case 5:\n      {\n        if (knot_count == 0)\n          {\n            /*\n              Unexpected subpath knot\n            */\n            blob+=24;\n            length-=MagickMin(24,(ssize_t) length);\n            break;\n          }\n        /*\n          Add sub-path knot\n        */\n        for (i=0; i < 3; i++)\n        {\n          size_t\n            xx,\n            yy;\n\n          yy=(size_t) ReadPropertyMSBLong(&blob,&length);\n          xx=(size_t) ReadPropertyMSBLong(&blob,&length);\n          x=(ssize_t) xx;\n          if (xx > 2147483647)\n            x=(ssize_t) xx-4294967295U-1;\n          y=(ssize_t) yy;\n          if (yy > 2147483647)\n            y=(ssize_t) yy-4294967295U-1;\n          point[i].x=(double) x/4096/4096;\n          point[i].y=1.0-(double) y/4096/4096;\n        }\n        if (in_subpath == MagickFalse)\n          {\n            (void) FormatLocaleString(message,MagickPathExtent,\"  %g %g m\\n\",\n              point[1].x,point[1].y);\n            for (i=0; i < 3; i++)\n            {\n              first[i]=point[i];\n              last[i]=point[i];\n            }\n          }\n        else\n          {\n            /*\n              Handle special cases when Bezier curves are used to describe\n              corners and straight lines.\n            */\n            if ((last[1].x == last[2].x) && (last[1].y == last[2].y) &&\n                (point[0].x == point[1].x) && (point[0].y == point[1].y))\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"  %g %g l\\n\",point[1].x,point[1].y);\n            else\n              if ((last[1].x == last[2].x) && (last[1].y == last[2].y))\n                (void) FormatLocaleString(message,MagickPathExtent,\n                  \"  %g %g %g %g v\\n\",point[0].x,point[0].y,\n                  point[1].x,point[1].y);\n              else\n                if ((point[0].x == point[1].x) && (point[0].y == point[1].y))\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"  %g %g %g %g y\\n\",last[2].x,last[2].y,\n                    point[1].x,point[1].y);\n                else\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"  %g %g %g %g %g %g c\\n\",last[2].x,\n                    last[2].y,point[0].x,point[0].y,point[1].x,point[1].y);\n            for (i=0; i < 3; i++)\n              last[i]=point[i];\n          }\n        (void) ConcatenateString(&path,message);\n        in_subpath=MagickTrue;\n        knot_count--;\n        /*\n          Close the subpath if there are no more knots.\n        */\n        if (knot_count == 0)\n          {\n            /*\n              Same special handling as above except we compare to the\n              first point in the path and close the path.\n            */\n            if ((last[1].x == last[2].x) && (last[1].y == last[2].y) &&\n                (first[0].x == first[1].x) && (first[0].y == first[1].y))\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"  %g %g l z\\n\",first[1].x,first[1].y);\n            else\n              if ((last[1].x == last[2].x) && (last[1].y == last[2].y))\n                (void) FormatLocaleString(message,MagickPathExtent,\n                  \"  %g %g %g %g v z\\n\",first[0].x,first[0].y,\n                  first[1].x,first[1].y);\n              else\n                if ((first[0].x == first[1].x) && (first[0].y == first[1].y))\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"  %g %g %g %g y z\\n\",last[2].x,last[2].y,\n                    first[1].x,first[1].y);\n                else\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"  %g %g %g %g %g %g c z\\n\",last[2].x,\n                    last[2].y,first[0].x,first[0].y,first[1].x,first[1].y);\n            (void) ConcatenateString(&path,message);\n            in_subpath=MagickFalse;\n          }\n        break;\n      }\n      case 6:\n      case 7:\n      case 8:\n      default:\n      {\n        blob+=24;\n        length-=MagickMin(24,(ssize_t) length);\n        break;\n      }\n    }\n  }\n  /*\n    Returns an empty PS path if the path has no knots.\n  */\n  (void) FormatLocaleString(message,MagickPathExtent,\"  eoclip\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"} bind def\");\n  (void) ConcatenateString(&path,message);\n  message=DestroyString(message);\n  return(path);\n}\n\nstatic char *TraceSVGClippath(const unsigned char *blob,size_t length,\n  const size_t columns,const size_t rows)\n{\n  char\n    *path,\n    *message;\n\n  MagickBooleanType\n    in_subpath;\n\n  PointInfo\n    first[3],\n    last[3],\n    point[3];\n\n  register ssize_t\n    i;\n\n  ssize_t\n    knot_count,\n    selector,\n    x,\n    y;\n\n  path=AcquireString((char *) NULL);\n  if (path == (char *) NULL)\n    return((char *) NULL);\n  message=AcquireString((char *) NULL);\n  (void) FormatLocaleString(message,MagickPathExtent,(\n    \"<?xml version=\\\"1.0\\\" encoding=\\\"iso-8859-1\\\"?>\\n\"\n    \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\"\"\n    \" width=\\\"%.20g\\\" height=\\\"%.20g\\\">\\n\"\n    \"<g>\\n\"\n    \"<path fill-rule=\\\"evenodd\\\" style=\\\"fill:#00000000;stroke:#00000000;\"\n    \"stroke-width:0;stroke-antialiasing:false\\\" d=\\\"\\n\"),(double) columns,\n    (double) rows);\n  (void) ConcatenateString(&path,message);\n  (void) ResetMagickMemory(point,0,sizeof(point));\n  (void) ResetMagickMemory(first,0,sizeof(first));\n  (void) ResetMagickMemory(last,0,sizeof(last));\n  knot_count=0;\n  in_subpath=MagickFalse;\n  while (length != 0)\n  {\n    selector=(ssize_t) ReadPropertyMSBShort(&blob,&length);\n    switch (selector)\n    {\n      case 0:\n      case 3:\n      {\n        if (knot_count != 0)\n          {\n            blob+=24;\n            length-=MagickMin(24,(ssize_t) length);\n            break;\n          }\n        /*\n          Expected subpath length record.\n        */\n        knot_count=(ssize_t) ReadPropertyMSBShort(&blob,&length);\n        blob+=22;\n        length-=MagickMin(22,(ssize_t) length);\n        break;\n      }\n      case 1:\n      case 2:\n      case 4:\n      case 5:\n      {\n        if (knot_count == 0)\n          {\n            /*\n              Unexpected subpath knot.\n            */\n            blob+=24;\n            length-=MagickMin(24,(ssize_t) length);\n            break;\n          }\n        /*\n          Add sub-path knot\n        */\n        for (i=0; i < 3; i++)\n        {\n          unsigned int\n            xx,\n            yy;\n\n          yy=(unsigned int) ReadPropertyMSBLong(&blob,&length);\n          xx=(unsigned int) ReadPropertyMSBLong(&blob,&length);\n          x=(ssize_t) xx;\n          if (xx > 2147483647)\n            x=(ssize_t) xx-4294967295U-1;\n          y=(ssize_t) yy;\n          if (yy > 2147483647)\n            y=(ssize_t) yy-4294967295U-1;\n          point[i].x=(double) x*columns/4096/4096;\n          point[i].y=(double) y*rows/4096/4096;\n        }\n        if (in_subpath == MagickFalse)\n          {\n            (void) FormatLocaleString(message,MagickPathExtent,\"M %g %g\\n\",\n              point[1].x,point[1].y);\n            for (i=0; i < 3; i++)\n            {\n              first[i]=point[i];\n              last[i]=point[i];\n            }\n          }\n        else\n          {\n            /*\n              Handle special cases when Bezier curves are used to describe\n              corners and straight lines.\n            */\n            if ((last[1].x == last[2].x) && (last[1].y == last[2].y) &&\n                (point[0].x == point[1].x) && (point[0].y == point[1].y))\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"L %g %g\\n\",point[1].x,point[1].y);\n            else\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"C %g %g %g %g %g %g\\n\",last[2].x,\n                last[2].y,point[0].x,point[0].y,point[1].x,point[1].y);\n            for (i=0; i < 3; i++)\n              last[i]=point[i];\n          }\n        (void) ConcatenateString(&path,message);\n        in_subpath=MagickTrue;\n        knot_count--;\n        /*\n          Close the subpath if there are no more knots.\n        */\n        if (knot_count == 0)\n          {\n           /*\n              Same special handling as above except we compare to the\n              first point in the path and close the path.\n            */\n            if ((last[1].x == last[2].x) && (last[1].y == last[2].y) &&\n                (first[0].x == first[1].x) && (first[0].y == first[1].y))\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"L %g %g Z\\n\",first[1].x,first[1].y);\n            else\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"C %g %g %g %g %g %g Z\\n\",last[2].x,\n                last[2].y,first[0].x,first[0].y,first[1].x,first[1].y);\n            (void) ConcatenateString(&path,message);\n            in_subpath=MagickFalse;\n          }\n        break;\n      }\n      case 6:\n      case 7:\n      case 8:\n      default:\n      {\n        blob+=24;\n        length-=MagickMin(24,(ssize_t) length);\n        break;\n      }\n    }\n  }\n  /*\n    Return an empty SVG image if the path does not have knots.\n  */\n  (void) ConcatenateString(&path,\"\\\"/>\\n</g>\\n</svg>\\n\");\n  message=DestroyString(message);\n  return(path);\n}\n\nMagickExport const char *GetImageProperty(const Image *image,\n  const char *property,ExceptionInfo *exception)\n{\n  register const char\n    *p;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  p=(const char *) NULL;\n  if (image->properties != (void *) NULL)\n    {\n      if (property == (const char *) NULL)\n        {\n          ResetSplayTreeIterator((SplayTreeInfo *) image->properties);\n          p=(const char *) GetNextValueInSplayTree((SplayTreeInfo *)\n            image->properties);\n          return(p);\n        }\n        p=(const char *) GetValueFromSplayTree((SplayTreeInfo *)\n          image->properties,property);\n        if (p != (const char *) NULL)\n          return(p);\n    }\n  if ((property == (const char *) NULL) ||\n      (strchr(property,':') == (char *) NULL))\n    return(p);\n  switch (*property)\n  {\n    case '8':\n    {\n      if (LocaleNCompare(\"8bim:\",property,5) == 0)\n        {\n          (void) Get8BIMProperty(image,property,exception);\n          break;\n        }\n      break;\n    }\n    case 'E':\n    case 'e':\n    {\n      if (LocaleNCompare(\"exif:\",property,5) == 0)\n        {\n          (void) GetEXIFProperty(image,property,exception);\n          break;\n        }\n      break;\n    }\n    case 'I':\n    case 'i':\n    {\n      if ((LocaleNCompare(\"icc:\",property,4) == 0) ||\n          (LocaleNCompare(\"icm:\",property,4) == 0))\n        {\n          (void) GetICCProperty(image,property,exception);\n          break;\n        }\n      if (LocaleNCompare(\"iptc:\",property,5) == 0)\n        {\n          (void) GetIPTCProperty(image,property,exception);\n          break;\n        }\n      break;\n    }\n    case 'X':\n    case 'x':\n    {\n      if (LocaleNCompare(\"xmp:\",property,4) == 0)\n        {\n          (void) GetXMPProperty(image,property);\n          break;\n        }\n      break;\n    }\n    default:\n      break;\n  }\n  if (image->properties != (void *) NULL)\n    {\n      p=(const char *) GetValueFromSplayTree((SplayTreeInfo *)\n        image->properties,property);\n      return(p);\n    }\n  return((const char *) NULL);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t M a g i c k P r o p e r t y                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetMagickProperty() gets attributes or calculated values that is associated\n%  with a fixed known property name, or single letter property. It may be\n%  called if no image is defined (IMv7), in which case only global image_info\n%  values are available:\n%\n%    \\n   newline\n%    \\r   carriage return\n%    <    less-than character.\n%    >    greater-than character.\n%    &    ampersand character.\n%    %%   a percent sign\n%    %b   file size of image read in\n%    %c   comment meta-data property\n%    %d   directory component of path\n%    %e   filename extension or suffix\n%    %f   filename (including suffix)\n%    %g   layer canvas page geometry   (equivalent to \"%Wx%H%X%Y\")\n%    %h   current image height in pixels\n%    %i   image filename (note: becomes output filename for \"info:\")\n%    %k   CALCULATED: number of unique colors\n%    %l   label meta-data property\n%    %m   image file format (file magic)\n%    %n   number of images in current image sequence\n%    %o   output filename  (used for delegates)\n%    %p   index of image in current image list\n%    %q   quantum depth (compile-time constant)\n%    %r   image class and colorspace\n%    %s   scene number (from input unless re-assigned)\n%    %t   filename without directory or extension (suffix)\n%    %u   unique temporary filename (used for delegates)\n%    %w   current width in pixels\n%    %x   x resolution (density)\n%    %y   y resolution (density)\n%    %z   image depth (as read in unless modified, image save depth)\n%    %A   image transparency channel enabled (true/false)\n%    %C   image compression type\n%    %D   image GIF dispose method\n%    %G   original image size (%wx%h; before any resizes)\n%    %H   page (canvas) height\n%    %M   Magick filename (original file exactly as given,  including read mods)\n%    %O   page (canvas) offset ( = %X%Y )\n%    %P   page (canvas) size ( = %Wx%H )\n%    %Q   image compression quality ( 0 = default )\n%    %S   ?? scenes ??\n%    %T   image time delay (in centi-seconds)\n%    %U   image resolution units\n%    %W   page (canvas) width\n%    %X   page (canvas) x offset (including sign)\n%    %Y   page (canvas) y offset (including sign)\n%    %Z   unique filename (used for delegates)\n%    %@   CALCULATED: trim bounding box (without actually trimming)\n%    %#   CALCULATED: 'signature' hash of image values\n%\n%  This routine only handles specifically known properties.  It does not\n%  handle special prefixed properties, profiles, or expressions. Nor does\n%  it return any free-form property strings.\n%\n%  The returned string is stored in a structure somewhere, and should not be\n%  directly freed.  If the string was generated (common) the string will be\n%  stored as as either as artifact or option 'get-property'.  These may be\n%  deleted (cleaned up) when no longer required, but neither artifact or\n%  option is guranteed to exist.\n%\n%  The format of the GetMagickProperty method is:\n%\n%      const char *GetMagickProperty(ImageInfo *image_info,Image *image,\n%        const char *property,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info (optional)\n%\n%    o image: the image (optional)\n%\n%    o key: the key.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic const char *GetMagickPropertyLetter(ImageInfo *image_info,\n  Image *image,const char letter,ExceptionInfo *exception)\n{\n#define WarnNoImageReturn(format,arg) \\\n  if (image == (Image *) NULL ) { \\\n    (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning, \\\n      \"NoImageForProperty\",format,arg); \\\n    return((const char *) NULL); \\\n  }\n#define WarnNoImageInfoReturn(format,arg) \\\n  if (image_info == (ImageInfo *) NULL ) { \\\n    (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning, \\\n      \"NoImageInfoForProperty\",format,arg); \\\n    return((const char *) NULL); \\\n  }\n\n  char\n    value[MagickPathExtent];  /* formatted string to store as an artifact */\n\n  const char\n    *string;     /* return a string already stored somewher */\n\n  if ((image != (Image *) NULL) && (image->debug != MagickFalse))\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  else\n    if ((image_info != (ImageInfo *) NULL) &&\n        (image_info->debug != MagickFalse))\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\"no-images\");\n  *value='\\0';           /* formatted string */\n  string=(char *) NULL;  /* constant string reference */\n  /*\n    Get properities that are directly defined by images.\n  */\n  switch (letter)\n  {\n    case 'b':  /* image size read in - in bytes */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatMagickSize(image->extent,MagickFalse,\"B\",MagickPathExtent,\n        value);\n      if (image->extent == 0)\n        (void) FormatMagickSize(GetBlobSize(image),MagickFalse,\"B\",\n          MagickPathExtent,value);\n      break;\n    }\n    case 'c':  /* image comment property - empty string by default */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=GetImageProperty(image,\"comment\",exception);\n      if ( string == (const char *) NULL )\n        string=\"\";\n      break;\n    }\n    case 'd':  /* Directory component of filename */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      GetPathComponent(image->magick_filename,HeadPath,value);\n      if (*value == '\\0')\n        string=\"\";\n      break;\n    }\n    case 'e': /* Filename extension (suffix) of image file */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      GetPathComponent(image->magick_filename,ExtensionPath,value);\n      if (*value == '\\0')\n        string=\"\";\n      break;\n    }\n    case 'f': /* Filename without directory component */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      GetPathComponent(image->magick_filename,TailPath,value);\n      if (*value == '\\0')\n        string=\"\";\n      break;\n    }\n    case 'g': /* Image geometry, canvas and offset  %Wx%H+%X+%Y */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\n        \"%.20gx%.20g%+.20g%+.20g\",(double) image->page.width,(double)\n        image->page.height,(double) image->page.x,(double) image->page.y);\n      break;\n    }\n    case 'h': /* Image height (current) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        (image->rows != 0 ? image->rows : image->magick_rows));\n      break;\n    }\n    case 'i': /* Filename last used for an image (read or write) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=image->filename;\n      break;\n    }\n    case 'k': /* Number of unique colors  */\n    {\n      /*\n        FUTURE: ensure this does not generate the formatted comment!\n      */\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        GetNumberColors(image,(FILE *) NULL,exception));\n      break;\n    }\n    case 'l': /* Image label property - empty string by default */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=GetImageProperty(image,\"label\",exception);\n      if (string == (const char *) NULL)\n        string=\"\";\n      break;\n    }\n    case 'm': /* Image format (file magick) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=image->magick;\n      break;\n    }\n    case 'n': /* Number of images in the list.  */\n    {\n      if ( image != (Image *) NULL )\n        (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n          GetImageListLength(image));\n      else\n        string=\"0\";    /* no images or scenes */\n      break;\n    }\n    case 'o': /* Output Filename - for delegate use only */\n      WarnNoImageInfoReturn(\"\\\"%%%c\\\"\",letter);\n      string=image_info->filename;\n      break;\n    case 'p': /* Image index in current image list */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        GetImageIndexInList(image));\n      break;\n    }\n    case 'q': /* Quantum depth of image in memory */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        MAGICKCORE_QUANTUM_DEPTH);\n      break;\n    }\n    case 'r': /* Image storage class, colorspace, and alpha enabled.  */\n    {\n      ColorspaceType\n        colorspace;\n\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      colorspace=image->colorspace;\n      if (SetImageGray(image,exception) != MagickFalse)\n        colorspace=GRAYColorspace;   /* FUTURE: this is IMv6 not IMv7 */\n      (void) FormatLocaleString(value,MagickPathExtent,\"%s %s %s\",\n        CommandOptionToMnemonic(MagickClassOptions,(ssize_t)\n        image->storage_class),CommandOptionToMnemonic(MagickColorspaceOptions,\n        (ssize_t) colorspace),image->alpha_trait != UndefinedPixelTrait ?\n        \"Alpha\" : \"\");\n      break;\n    }\n    case 's': /* Image scene number */\n    {\n#if 0  /* this seems non-sensical -- simplifing */\n      if (image_info->number_scenes != 0)\n        (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n          image_info->scene);\n      else if (image != (Image *) NULL)\n        (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n          image->scene);\n      else\n          string=\"0\";\n#else\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n         image->scene);\n#endif\n      break;\n    }\n    case 't': /* Base filename without directory or extention */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      GetPathComponent(image->magick_filename,BasePath,value);\n      if (*value == '\\0')\n        string=\"\";\n      break;\n    }\n    case 'u': /* Unique filename */\n    {\n      WarnNoImageInfoReturn(\"\\\"%%%c\\\"\",letter);\n      string=image_info->unique;\n      break;\n    }\n    case 'w': /* Image width (current) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        (image->columns != 0 ? image->columns : image->magick_columns));\n      break;\n    }\n    case 'x': /* Image horizontal resolution (with units) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",\n        fabs(image->resolution.x) > MagickEpsilon ? image->resolution.x : 72.0);\n      break;\n    }\n    case 'y': /* Image vertical resolution (with units) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",\n        fabs(image->resolution.y) > MagickEpsilon ? image->resolution.y : 72.0);\n      break;\n    }\n    case 'z': /* Image depth as read in */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        image->depth);\n      break;\n    }\n    case 'A': /* Image alpha channel  */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=CommandOptionToMnemonic(MagickPixelTraitOptions,(ssize_t)\n        image->alpha_trait);\n      break;\n    }\n    case 'C': /* Image compression method.  */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=CommandOptionToMnemonic(MagickCompressOptions,(ssize_t)\n        image->compression);\n      break;\n    }\n    case 'D': /* Image dispose method.  */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=CommandOptionToMnemonic(MagickDisposeOptions,(ssize_t)\n        image->dispose);\n      break;\n    }\n    case 'G': /* Image size as geometry = \"%wx%h\" */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20gx%.20g\",(double)\n        image->magick_columns,(double) image->magick_rows);\n      break;\n    }\n    case 'H': /* layer canvas height */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        image->page.height);\n      break;\n    }\n    case 'M': /* Magick filename - filename given incl. coder & read mods */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=image->magick_filename;\n      break;\n    }\n    case 'O': /* layer canvas offset with sign = \"+%X+%Y\" */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%+ld%+ld\",(long)\n        image->page.x,(long) image->page.y);\n      break;\n    }\n    case 'P': /* layer canvas page size = \"%Wx%H\" */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20gx%.20g\",(double)\n        image->page.width,(double) image->page.height);\n      break;\n    }\n    case 'Q': /* image compression quality */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        (image->quality == 0 ? 92 : image->quality));\n      break;\n    }\n    case 'S': /* Number of scenes in image list.  */\n    {\n      WarnNoImageInfoReturn(\"\\\"%%%c\\\"\",letter);\n#if 0 /* What is this number? -- it makes no sense - simplifing */\n      if (image_info->number_scenes == 0)\n         string=\"2147483647\";\n      else if ( image != (Image *) NULL )\n        (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n                image_info->scene+image_info->number_scenes);\n      else\n        string=\"0\";\n#else\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        (image_info->number_scenes == 0 ? 2147483647 :\n         image_info->number_scenes));\n#endif\n      break;\n    }\n    case 'T': /* image time delay for animations */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        image->delay);\n      break;\n    }\n    case 'U': /* Image resolution units. */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=CommandOptionToMnemonic(MagickResolutionOptions,(ssize_t)\n        image->units);\n      break;\n    }\n    case 'W': /* layer canvas width */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        image->page.width);\n      break;\n    }\n    case 'X': /* layer canvas X offset */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%+.20g\",(double)\n        image->page.x);\n      break;\n    }\n    case 'Y': /* layer canvas Y offset */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%+.20g\",(double)\n        image->page.y);\n      break;\n    }\n    case '%': /* percent escaped */\n    {\n      string=\"%\";\n      break;\n    }\n    case '@': /* Trim bounding box, without actually Trimming! */\n    {\n      RectangleInfo\n        page;\n\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      page=GetImageBoundingBox(image,exception);\n      (void) FormatLocaleString(value,MagickPathExtent,\n        \"%.20gx%.20g%+.20g%+.20g\",(double) page.width,(double) page.height,\n        (double) page.x,(double)page.y);\n      break;\n    }\n    case '#':\n    {\n      /*\n        Image signature.\n      */\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) SignatureImage(image,exception);\n      string=GetImageProperty(image,\"signature\",exception);\n      break;\n    }\n  }\n  if (string != (char *) NULL)\n    return(string);\n  if (*value != '\\0')\n    {\n      /*\n        Create a cloned copy of result.\n      */\n      if (image != (Image *) NULL)\n        {\n          (void) SetImageArtifact(image,\"get-property\",value);\n          return(GetImageArtifact(image,\"get-property\"));\n        }\n      else\n        {\n          (void) SetImageOption(image_info,\"get-property\",value);\n          return(GetImageOption(image_info,\"get-property\"));\n        }\n    }\n  return((char *) NULL);\n}\n\nMagickExport const char *GetMagickProperty(ImageInfo *image_info,\n  Image *image,const char *property,ExceptionInfo *exception)\n{\n  char\n    value[MagickPathExtent];\n\n  const char\n    *string;\n\n  assert(property[0] != '\\0');\n  assert(image != (Image *) NULL || image_info != (ImageInfo *) NULL );\n  if (property[1] == '\\0')  /* single letter property request */\n    return(GetMagickPropertyLetter(image_info,image,*property,exception));\n  if ((image != (Image *) NULL) && (image->debug != MagickFalse))\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  else\n    if ((image_info != (ImageInfo *) NULL) &&\n        (image_info->debug != MagickFalse))\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\"no-images\");\n  *value='\\0';           /* formated string */\n  string=(char *) NULL;  /* constant string reference */\n  switch (*property)\n  {\n    case 'b':\n    {\n      if (LocaleCompare(\"basename\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          GetPathComponent(image->magick_filename,BasePath,value);\n          if (*value == '\\0')\n            string=\"\";\n          break;\n        }\n      if (LocaleCompare(\"bit-depth\",property) == 0)\n        {\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            GetImageDepth(image,exception));\n          break;\n        }\n      break;\n    }\n    case 'c':\n    {\n      if (LocaleCompare(\"channels\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          /* FUTURE: return actual image channels */\n          (void) FormatLocaleString(value,MagickPathExtent,\"%s\",\n            CommandOptionToMnemonic(MagickColorspaceOptions,(ssize_t)\n            image->colorspace));\n          LocaleLower(value);\n          if( image->alpha_trait != UndefinedPixelTrait )\n            (void) ConcatenateMagickString(value,\"a\",MagickPathExtent);\n          break;\n        }\n      if (LocaleCompare(\"colorspace\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          /* FUTURE: return actual colorspace - no 'gray' stuff */\n          string=CommandOptionToMnemonic(MagickColorspaceOptions,(ssize_t)\n            image->colorspace);\n          break;\n        }\n      if (LocaleCompare(\"compose\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickComposeOptions,(ssize_t)\n            image->compose);\n          break;\n        }\n      if (LocaleCompare(\"copyright\",property) == 0)\n        {\n          (void) CopyMagickString(value,GetMagickCopyright(),MagickPathExtent);\n          break;\n        }\n      break;\n    }\n    case 'd':\n    {\n      if (LocaleCompare(\"depth\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            image->depth);\n          break;\n        }\n      if (LocaleCompare(\"directory\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          GetPathComponent(image->magick_filename,HeadPath,value);\n          if (*value == '\\0')\n            string=\"\";\n          break;\n        }\n      break;\n    }\n    case 'e':\n    {\n      if (LocaleCompare(\"entropy\",property) == 0)\n        {\n          double\n            entropy;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageEntropy(image,&entropy,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),entropy);\n          break;\n        }\n      if (LocaleCompare(\"extension\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          GetPathComponent(image->magick_filename,ExtensionPath,value);\n          if (*value == '\\0')\n            string=\"\";\n          break;\n        }\n      break;\n    }\n    case 'g':\n    {\n      if (LocaleCompare(\"gamma\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),image->gamma);\n          break;\n        }\n      break;\n    }\n    case 'h':\n    {\n      if (LocaleCompare(\"height\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",\n            image->magick_rows != 0 ? (double) image->magick_rows : 256.0);\n          break;\n        }\n      break;\n    }\n    case 'i':\n    {\n      if (LocaleCompare(\"input\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=image->filename;\n          break;\n        }\n      break;\n    }\n    case 'k':\n    {\n      if (LocaleCompare(\"kurtosis\",property) == 0)\n        {\n          double\n            kurtosis,\n            skewness;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageKurtosis(image,&kurtosis,&skewness,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),kurtosis);\n          break;\n        }\n      break;\n    }\n    case 'm':\n    {\n      if (LocaleCompare(\"magick\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=image->magick;\n          break;\n        }\n      if ((LocaleCompare(\"maxima\",property) == 0) ||\n          (LocaleCompare(\"max\",property) == 0))\n        {\n          double\n            maximum,\n            minimum;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageRange(image,&minimum,&maximum,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),maximum);\n          break;\n        }\n      if (LocaleCompare(\"mean\",property) == 0)\n        {\n          double\n            mean,\n            standard_deviation;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageMean(image,&mean,&standard_deviation,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),mean);\n          break;\n        }\n      if ((LocaleCompare(\"minima\",property) == 0) ||\n          (LocaleCompare(\"min\",property) == 0))\n        {\n          double\n            maximum,\n            minimum;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageRange(image,&minimum,&maximum,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),minimum);\n          break;\n        }\n      break;\n    }\n    case 'o':\n    {\n      if (LocaleCompare(\"opaque\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickBooleanOptions,(ssize_t)\n            IsImageOpaque(image,exception));\n          break;\n        }\n      if (LocaleCompare(\"orientation\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickOrientationOptions,(ssize_t)\n            image->orientation);\n          break;\n        }\n      if (LocaleCompare(\"output\",property) == 0)\n        {\n          WarnNoImageInfoReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) CopyMagickString(value,image_info->filename,MagickPathExtent);\n          break;\n        }\n     break;\n    }\n    case 'p':\n    {\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n      if (LocaleCompare(\"profile:icc\",property) == 0 ||\n          LocaleCompare(\"profile:icm\",property) == 0)\n        {\n#if !defined(LCMS_VERSION) || (LCMS_VERSION < 2000)\n#define cmsUInt32Number  DWORD\n#endif\n\n          const StringInfo\n            *profile;\n\n          cmsHPROFILE\n            icc_profile;\n\n          profile=GetImageProfile(image,property+8);\n          if (profile == (StringInfo *) NULL)\n            break;\n          icc_profile=cmsOpenProfileFromMem(GetStringInfoDatum(profile),\n            (cmsUInt32Number) GetStringInfoLength(profile));\n          if (icc_profile != (cmsHPROFILE *) NULL)\n            {\n#if defined(LCMS_VERSION) && (LCMS_VERSION < 2000)\n              string=cmsTakeProductName(icc_profile);\n#else\n              (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoDescription,\n                \"en\",\"US\",value,MagickPathExtent);\n#endif\n              (void) cmsCloseProfile(icc_profile);\n            }\n      }\n#endif\n      if (LocaleCompare(\"profiles\",property) == 0)\n        {\n          const char\n            *name;\n\n          ResetImageProfileIterator(image);\n          name=GetNextImageProfile(image);\n          if (name != (char *) NULL)\n            {\n              (void) CopyMagickString(value,name,MagickPathExtent);\n              name=GetNextImageProfile(image);\n              while (name != (char *) NULL)\n              {\n                ConcatenateMagickString(value,\",\",MagickPathExtent);\n                ConcatenateMagickString(value,name,MagickPathExtent);\n                name=GetNextImageProfile(image);\n              }\n            }\n          break;\n        }\n      break;\n    }\n    case 'r':\n    {\n      if (LocaleCompare(\"resolution.x\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%g\",\n            image->resolution.x);\n          break;\n        }\n      if (LocaleCompare(\"resolution.y\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%g\",\n            image->resolution.y);\n          break;\n        }\n      break;\n    }\n    case 's':\n    {\n      if (LocaleCompare(\"scene\",property) == 0)\n        {\n          WarnNoImageInfoReturn(\"\\\"%%[%s]\\\"\",property);\n          if (image_info->number_scenes != 0)\n            (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n              image_info->scene);\n          else {\n            WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n            (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n              image->scene);\n          }\n          break;\n        }\n      if (LocaleCompare(\"scenes\",property) == 0)\n        {\n          /* FUTURE: equivelent to %n? */\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            GetImageListLength(image));\n          break;\n        }\n      if (LocaleCompare(\"size\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatMagickSize(GetBlobSize(image),MagickFalse,\"B\",\n            MagickPathExtent,value);\n          break;\n        }\n      if (LocaleCompare(\"skewness\",property) == 0)\n        {\n          double\n            kurtosis,\n            skewness;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageKurtosis(image,&kurtosis,&skewness,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),skewness);\n          break;\n        }\n      if (LocaleCompare(\"standard-deviation\",property) == 0)\n        {\n          double\n            mean,\n            standard_deviation;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageMean(image,&mean,&standard_deviation,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),standard_deviation);\n          break;\n        }\n       break;\n    }\n    case 't':\n    {\n      if (LocaleCompare(\"type\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickTypeOptions,(ssize_t)\n            IdentifyImageType(image,exception));\n          break;\n        }\n       break;\n    }\n    case 'u':\n    {\n      if (LocaleCompare(\"unique\",property) == 0)\n        {\n          WarnNoImageInfoReturn(\"\\\"%%[%s]\\\"\",property);\n          string=image_info->unique;\n          break;\n        }\n      if (LocaleCompare(\"units\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickResolutionOptions,(ssize_t)\n            image->units);\n          break;\n        }\n      if (LocaleCompare(\"copyright\",property) == 0)\n      break;\n    }\n    case 'v':\n    {\n      if (LocaleCompare(\"version\",property) == 0)\n        {\n          string=GetMagickVersion((size_t *) NULL);\n          break;\n        }\n      break;\n    }\n    case 'w':\n    {\n      if (LocaleCompare(\"width\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            (image->magick_columns != 0 ? image->magick_columns : 256));\n          break;\n        }\n      break;\n    }\n  }\n  if (string != (char *) NULL)\n    return(string);\n  if (*value != '\\0')\n    {\n      /*\n        Create a cloned copy of result, that will get cleaned up, eventually.\n      */\n      if (image != (Image *) NULL)\n        {\n          (void) SetImageArtifact(image,\"get-property\",value);\n          return(GetImageArtifact(image,\"get-property\"));\n        }\n      else\n        {\n          (void) SetImageOption(image_info,\"get-property\",value);\n          return(GetImageOption(image_info,\"get-property\"));\n        }\n    }\n  return((char *) NULL);\n}\n#undef WarnNoImageReturn\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t N e x t I m a g e P r o p e r t y                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetNextImageProperty() gets the next free-form string property name.\n%\n%  The format of the GetNextImageProperty method is:\n%\n%      char *GetNextImageProperty(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport const char *GetNextImageProperty(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image->filename);\n  if (image->properties == (void *) NULL)\n    return((const char *) NULL);\n  return((const char *) GetNextKeyInSplayTree((SplayTreeInfo *) image->properties));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I n t e r p r e t I m a g e P r o p e r t i e s                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InterpretImageProperties() replaces any embedded formatting characters with\n%  the appropriate image property and returns the interpreted text.\n%\n%  This searches for and replaces\n%     \\n \\r \\%          replaced by newline, return, and percent resp.\n%     &lt; &gt; &amp;   replaced by '<', '>', '&' resp.\n%     %%                replaced by percent\n%\n%     %x %[x]       where 'x' is a single letter properity, case sensitive).\n%     %[type:name]  where 'type' a is special and known prefix.\n%     %[name]       where 'name' is a specifically known attribute, calculated\n%                   value, or a per-image property string name, or a per-image\n%                   'artifact' (as generated from a global option).\n%                   It may contain ':' as long as the prefix is not special.\n%\n%  Single letter % substitutions will only happen if the character before the\n%  percent is NOT a number. But braced substitutions will always be performed.\n%  This prevents the typical usage of percent in a interpreted geometry\n%  argument from being substituted when the percent is a geometry flag.\n%\n%  If 'glob-expresions' ('*' or '?' characters) is used for 'name' it may be\n%  used as a search pattern to print multiple lines of \"name=value\\n\" pairs of\n%  the associacted set of properties.\n%\n%  The returned string must be freed using DestoryString() by the caller.\n%\n%  The format of the InterpretImageProperties method is:\n%\n%      char *InterpretImageProperties(ImageInfo *image_info,\n%        Image *image,const char *embed_text,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info. (required)\n%\n%    o image: the image. (optional)\n%\n%    o embed_text: the address of a character string containing the embedded\n%      formatting characters.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport char *InterpretImageProperties(ImageInfo *image_info,Image *image,\n  const char *embed_text,ExceptionInfo *exception)\n{\n#define ExtendInterpretText(string_length) \\\nDisableMSCWarning(4127) \\\n{ \\\n  size_t length=(string_length); \\\n  if ((size_t) (q-interpret_text+length+1) >= extent) \\\n    { \\\n      extent+=length; \\\n      interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \\\n        MaxTextExtent,sizeof(*interpret_text)); \\\n      if (interpret_text == (char *) NULL) \\\n        return((char *) NULL); \\\n      q=interpret_text+strlen(interpret_text); \\\n   } \\\n} \\\nRestoreMSCWarning\n\n#define AppendKeyValue2Text(key,value)\\\nDisableMSCWarning(4127) \\\n{ \\\n  size_t length=strlen(key)+strlen(value)+2; \\\n  if ((size_t) (q-interpret_text+length+1) >= extent) \\\n    { \\\n      extent+=length; \\\n      interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \\\n        MaxTextExtent,sizeof(*interpret_text)); \\\n      if (interpret_text == (char *) NULL) \\\n        return((char *) NULL); \\\n      q=interpret_text+strlen(interpret_text); \\\n     } \\\n   q+=FormatLocaleString(q,extent,\"%s=%s\\n\",(key),(value)); \\\n} \\\nRestoreMSCWarning\n\n#define AppendString2Text(string) \\\nDisableMSCWarning(4127) \\\n{ \\\n  size_t length=strlen((string)); \\\n  if ((size_t) (q-interpret_text+length+1) >= extent) \\\n    { \\\n      extent+=length; \\\n      interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \\\n        MaxTextExtent,sizeof(*interpret_text)); \\\n      if (interpret_text == (char *) NULL) \\\n        return((char *) NULL); \\\n      q=interpret_text+strlen(interpret_text); \\\n    } \\\n  (void) CopyMagickString(q,(string),extent); \\\n  q+=length; \\\n} \\\nRestoreMSCWarning\n\n  char\n    *interpret_text;\n\n  MagickBooleanType\n    number;\n\n  register char\n    *q;  /* current position in interpret_text */\n\n  register const char\n    *p;  /* position in embed_text string being expanded */\n\n  size_t\n    extent;  /* allocated length of interpret_text */\n\n  assert(image == NULL || image->signature == MagickCoreSignature);\n  assert(image_info == NULL || image_info->signature == MagickCoreSignature);\n  if ((image != (Image *) NULL) && (image->debug != MagickFalse))\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  else\n   if ((image_info != (ImageInfo *) NULL) && (image_info->debug != MagickFalse))\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\"no-image\");\n  if (embed_text == (const char *) NULL)\n    return(ConstantString(\"\"));\n  p=embed_text;\n  while ((isspace((int) ((unsigned char) *p)) != 0) && (*p != '\\0'))\n    p++;\n  if (*p == '\\0')\n    return(ConstantString(\"\"));\n  if ((*p == '@') && (IsPathAccessible(p+1) != MagickFalse))\n    {\n      /*\n        Handle a '@' replace string from file.\n      */\n      if (IsRightsAuthorized(PathPolicyDomain,ReadPolicyRights,p) == MagickFalse)\n        {\n          errno=EPERM;\n          (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n            \"NotAuthorized\",\"`%s'\",p);\n          return(ConstantString(\"\"));\n        }\n      interpret_text=FileToString(p+1,~0UL,exception);\n      if (interpret_text != (char *) NULL)\n        return(interpret_text);\n    }\n  /*\n    Translate any embedded format characters.\n  */\n  interpret_text=AcquireString(embed_text); /* new string with extra space */\n  extent=MagickPathExtent;                     /* allocated space in string */\n  number=MagickFalse;                       /* is last char a number? */\n  for (q=interpret_text; *p!='\\0'; number=isdigit(*p) ? MagickTrue : MagickFalse,p++)\n  {\n    /*\n      Look for the various escapes, (and handle other specials)\n    */\n    *q='\\0';\n    ExtendInterpretText(MagickPathExtent);\n    switch (*p)\n    {\n      case '\\\\':\n      {\n        switch (*(p+1))\n        {\n          case '\\0':\n            continue;\n          case 'r':  /* convert to RETURN */\n          {\n            *q++='\\r';\n            p++;\n            continue;\n          }\n          case 'n':  /* convert to NEWLINE */\n          {\n            *q++='\\n';\n            p++;\n            continue;\n          }\n          case '\\n':  /* EOL removal UNIX,MacOSX */\n          {\n            p++;\n            continue;\n          }\n          case '\\r':  /* EOL removal DOS,Windows */\n          {\n            p++;\n            if (*p == '\\n') /* return-newline EOL */\n              p++;\n            continue;\n          }\n          default:\n          {\n            p++;\n            *q++=(*p);\n          }\n        }\n        continue;\n      }\n      case '&':\n      {\n        if (LocaleNCompare(\"&lt;\",p,4) == 0)\n          {\n            *q++='<';\n            p+=3;\n          }\n        else\n          if (LocaleNCompare(\"&gt;\",p,4) == 0)\n            {\n              *q++='>';\n              p+=3;\n            }\n          else\n            if (LocaleNCompare(\"&amp;\",p,5) == 0)\n              {\n                *q++='&';\n                p+=4;\n              }\n            else\n              *q++=(*p);\n        continue;\n      }\n      case '%':\n        break;  /* continue to next set of handlers */\n      default:\n      {\n        *q++=(*p);  /* any thing else is 'as normal' */\n        continue;\n      }\n    }\n    p++; /* advance beyond the percent */\n    /*\n      Doubled Percent - or percent at end of string.\n    */\n    if ((*p == '\\0') || (*p == '\\'') || (*p == '\"'))\n      p--;\n    if (*p == '%')\n      {\n        *q++='%';\n        continue;\n      }\n    /*\n      Single letter escapes %c.\n    */\n    if (*p != '[')\n      {\n        const char\n          *string;\n\n        if (number != MagickFalse)\n          {\n            /*\n              But only if not preceeded by a number!\n            */\n            *q++='%'; /* do NOT substitute the percent */\n            p--;      /* back up one */\n            continue;\n          }\n        string=GetMagickPropertyLetter(image_info,image,*p, exception);\n        if (string != (char *) NULL)\n          {\n            AppendString2Text(string);\n            if (image != (Image *) NULL)\n              (void) DeleteImageArtifact(image,\"get-property\");\n            if (image_info != (ImageInfo *) NULL)\n              (void) DeleteImageOption(image_info,\"get-property\");\n            continue;\n          }\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n          \"UnknownImageProperty\",\"\\\"%%%c\\\"\",*p);\n        continue;\n      }\n    {\n      char\n        pattern[2*MagickPathExtent];\n\n      const char\n        *key,\n        *string;\n\n      register ssize_t\n        len;\n\n      ssize_t\n        depth;\n\n      /*\n        Braced Percent Escape %[...].\n      */\n      p++;  /* advance p to just inside the opening brace */\n      depth=1;\n      if (*p == ']')\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n            \"UnknownImageProperty\",\"\\\"%%[]\\\"\");\n          break;\n        }\n      for (len=0; len<(MagickPathExtent-1L) && (*p != '\\0');)\n      {\n        if ((*p == '\\\\') && (*(p+1) != '\\0'))\n          {\n            /*\n              Skip escaped braces within braced pattern.\n            */\n            pattern[len++]=(*p++);\n            pattern[len++]=(*p++);\n            continue;\n          }\n        if (*p == '[')\n          depth++;\n        if (*p == ']')\n          depth--;\n        if (depth <= 0)\n          break;\n        pattern[len++]=(*p++);\n      }\n      pattern[len]='\\0';\n      if (depth != 0)\n        {\n          /*\n            Check for unmatched final ']' for \"%[...]\".\n          */\n          if (len >= 64)\n            {\n              pattern[61] = '.';  /* truncate string for error message */\n              pattern[62] = '.';\n              pattern[63] = '.';\n              pattern[64] = '\\0';\n            }\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"UnbalancedBraces\",\"\\\"%%[%s\\\"\",pattern);\n          interpret_text=DestroyString(interpret_text);\n          return((char *) NULL);\n        }\n      /*\n        Special Lookup Prefixes %[prefix:...].\n      */\n      if (LocaleNCompare(\"fx:\",pattern,3) == 0)\n        {\n          double\n            value;\n\n          FxInfo\n            *fx_info;\n\n          MagickBooleanType\n            status;\n\n          /*\n            FX - value calculator.\n          */\n          if (image == (Image *) NULL )\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"NoImageForProperty\",\"\\\"%%[%s]\\\"\",pattern);\n              continue; /* else no image to retrieve artifact */\n            }\n          fx_info=AcquireFxInfo(image,pattern+3,exception);\n          status=FxEvaluateChannelExpression(fx_info,IntensityPixelChannel,0,0,\n            &value,exception);\n          fx_info=DestroyFxInfo(fx_info);\n          if (status != MagickFalse)\n            {\n              char\n                result[MagickPathExtent];\n\n              (void) FormatLocaleString(result,MagickPathExtent,\"%.*g\",\n                GetMagickPrecision(),(double) value);\n              AppendString2Text(result);\n            }\n          continue;\n        }\n      if (LocaleNCompare(\"pixel:\",pattern,6) == 0)\n        {\n          FxInfo\n            *fx_info;\n\n          double\n            value;\n\n          MagickStatusType\n            status;\n\n          PixelInfo\n            pixel;\n\n          /*\n            Pixel - color value calculator.\n          */\n          if (image == (Image *) NULL)\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"NoImageForProperty\",\"\\\"%%[%s]\\\"\",pattern);\n              continue; /* else no image to retrieve artifact */\n            }\n          GetPixelInfo(image,&pixel);\n          fx_info=AcquireFxInfo(image,pattern+6,exception);\n          status=FxEvaluateChannelExpression(fx_info,RedPixelChannel,0,0,\n            &value,exception);\n          pixel.red=(double) QuantumRange*value;\n          status&=FxEvaluateChannelExpression(fx_info,GreenPixelChannel,0,0,\n            &value,exception);\n          pixel.green=(double) QuantumRange*value;\n          status&=FxEvaluateChannelExpression(fx_info,BluePixelChannel,0,0,\n            &value,exception);\n          pixel.blue=(double) QuantumRange*value;\n          if (image->colorspace == CMYKColorspace)\n            {\n              status&=FxEvaluateChannelExpression(fx_info,BlackPixelChannel,0,0,\n                &value,exception);\n              pixel.black=(double) QuantumRange*value;\n            }\n          status&=FxEvaluateChannelExpression(fx_info,AlphaPixelChannel,0,0,\n            &value,exception);\n          pixel.alpha=(double) QuantumRange*value;\n          fx_info=DestroyFxInfo(fx_info);\n          if (status != MagickFalse)\n            {\n              char\n                name[MagickPathExtent];\n\n              (void) QueryColorname(image,&pixel,SVGCompliance,name,\n                exception);\n              AppendString2Text(name);\n            }\n          continue;\n        }\n      if (LocaleNCompare(\"option:\",pattern,7) == 0)\n        {\n          /*\n            Option - direct global option lookup (with globbing).\n          */\n          if (image_info == (ImageInfo *) NULL )\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"NoImageForProperty\",\"\\\"%%[%s]\\\"\",pattern);\n              continue; /* else no image to retrieve artifact */\n            }\n          if (IsGlob(pattern+7) != MagickFalse)\n            {\n              ResetImageOptionIterator(image_info);\n              while ((key=GetNextImageOption(image_info)) != (const char *) NULL)\n                if (GlobExpression(key,pattern+7,MagickTrue) != MagickFalse)\n                  {\n                    string=GetImageOption(image_info,key);\n                    if (string != (const char *) NULL)\n                      AppendKeyValue2Text(key,string);\n                    /* else - assertion failure? key found but no string value! */\n                  }\n              continue;\n            }\n          string=GetImageOption(image_info,pattern+7);\n          if (string == (char *) NULL)\n            goto PropertyLookupFailure; /* no artifact of this specifc name */\n          AppendString2Text(string);\n          continue;\n        }\n      if (LocaleNCompare(\"artifact:\",pattern,9) == 0)\n        {\n          /*\n            Artifact - direct image artifact lookup (with glob).\n          */\n          if (image == (Image *) NULL)\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"NoImageForProperty\",\"\\\"%%[%s]\\\"\",pattern);\n              continue; /* else no image to retrieve artifact */\n            }\n          if (IsGlob(pattern+9) != MagickFalse)\n            {\n              ResetImageArtifactIterator(image);\n              while ((key=GetNextImageArtifact(image)) != (const char *) NULL)\n              if (GlobExpression(key,pattern+9,MagickTrue) != MagickFalse)\n                {\n                  string=GetImageArtifact(image,key);\n                  if (string != (const char *) NULL)\n                    AppendKeyValue2Text(key,string);\n                  /* else - assertion failure? key found but no string value! */\n                }\n              continue;\n            }\n          string=GetImageArtifact(image,pattern+9);\n          if (string == (char *) NULL)\n            goto PropertyLookupFailure; /* no artifact of this specifc name */\n          AppendString2Text(string);\n          continue;\n        }\n      if (LocaleNCompare(\"property:\",pattern,9) == 0)\n        {\n          /*\n            Property - direct image property lookup (with glob).\n          */\n          if (image == (Image *) NULL)\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"NoImageForProperty\",\"\\\"%%[%s]\\\"\",pattern);\n              continue; /* else no image to retrieve artifact */\n            }\n          if (IsGlob(pattern+9) != MagickFalse)\n            {\n              ResetImagePropertyIterator(image);\n              while ((key=GetNextImageProperty(image)) != (const char *) NULL)\n                if (GlobExpression(key,pattern,MagickTrue) != MagickFalse)\n                  {\n                    string=GetImageProperty(image,key,exception);\n                    if (string != (const char *) NULL)\n                      AppendKeyValue2Text(key,string);\n                    /* else - assertion failure? */\n                  }\n              continue;\n            }\n          string=GetImageProperty(image,pattern+9,exception);\n          if (string == (char *) NULL)\n            goto PropertyLookupFailure; /* no artifact of this specifc name */\n          AppendString2Text(string);\n          continue;\n        }\n      if (image != (Image *) NULL)\n        {\n          /*\n            Properties without special prefix.  This handles attributes,\n            properties, and profiles such as %[exif:...].  Note the profile\n            properties may also include a glob expansion pattern.\n          */\n          string=GetImageProperty(image,pattern,exception);\n          if (string != (const char *) NULL)\n            {\n              AppendString2Text(string);\n              if (image != (Image *) NULL)\n                (void)DeleteImageArtifact(image,\"get-property\");\n              if (image_info != (ImageInfo *) NULL)\n                (void)DeleteImageOption(image_info,\"get-property\");\n              continue;\n            }\n        }\n      if (IsGlob(pattern) != MagickFalse)\n        {\n          /*\n            Handle property 'glob' patterns such as:\n            %[*] %[user:array_??] %[filename:e*]>\n          */\n          if (image == (Image *) NULL)\n            continue; /* else no image to retrieve proprty - no list */\n          ResetImagePropertyIterator(image);\n          while ((key=GetNextImageProperty(image)) != (const char *) NULL)\n            if (GlobExpression(key,pattern,MagickTrue) != MagickFalse)\n              {\n                string=GetImageProperty(image,key,exception);\n                if (string != (const char *) NULL)\n                  AppendKeyValue2Text(key,string);\n                /* else - assertion failure? */\n              }\n          continue;\n        }\n      /*\n        Look for a known property or image attribute such as\n        %[basename] %[denisty] %[delay].  Also handles a braced single\n        letter: %[b] %[G] %[g].\n      */\n      string=GetMagickProperty(image_info,image,pattern,exception);\n      if (string != (const char *) NULL)\n        {\n          AppendString2Text(string);\n          continue;\n        }\n      /*\n        Look for a per-image artifact. This includes option lookup\n        (FUTURE: interpreted according to image).\n      */\n      if (image != (Image *) NULL)\n        {\n          string=GetImageArtifact(image,pattern);\n          if (string != (char *) NULL)\n            {\n              AppendString2Text(string);\n              continue;\n            }\n        }\n      else\n        if (image_info != (ImageInfo *) NULL)\n          {\n            /*\n              No image, so direct 'option' lookup (no delayed percent escapes).\n            */\n            string=GetImageOption(image_info,pattern);\n            if (string != (char *) NULL)\n              {\n                AppendString2Text(string);\n                continue;\n              }\n          }\nPropertyLookupFailure:\n      /*\n        Failed to find any match anywhere!\n      */\n      if (len >= 64)\n        {\n          pattern[61] = '.';  /* truncate string for error message */\n          pattern[62] = '.';\n          pattern[63] = '.';\n          pattern[64] = '\\0';\n        }\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"UnknownImageProperty\",\"\\\"%%[%s]\\\"\",pattern);\n    }\n  }\n  *q='\\0';\n  return(interpret_text);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e m o v e I m a g e P r o p e r t y                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RemoveImageProperty() removes a property from the image and returns its\n%  value.\n%\n%  In this case the ConstantString() value returned should be freed by the\n%  caller when finished.\n%\n%  The format of the RemoveImageProperty method is:\n%\n%      char *RemoveImageProperty(Image *image,const char *property)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o property: the image property.\n%\n*/\nMagickExport char *RemoveImageProperty(Image *image,const char *property)\n{\n  char\n    *value;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->properties == (void *) NULL)\n    return((char *) NULL);\n  value=(char *) RemoveNodeFromSplayTree((SplayTreeInfo *) image->properties,\n    property);\n  return(value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e s e t I m a g e P r o p e r t y I t e r a t o r                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResetImagePropertyIterator() resets the image properties iterator.  Use it\n%  in conjunction with GetNextImageProperty() to iterate over all the values\n%  associated with an image property.\n%\n%  The format of the ResetImagePropertyIterator method is:\n%\n%      ResetImagePropertyIterator(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void ResetImagePropertyIterator(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->properties == (void *) NULL)\n    return;\n  ResetSplayTreeIterator((SplayTreeInfo *) image->properties);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e P r o p e r t y                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageProperty() saves the given string value either to specific known\n%  attribute or to a freeform property string.\n%\n%  Attempting to set a property that is normally calculated will produce\n%  an exception.\n%\n%  The format of the SetImageProperty method is:\n%\n%      MagickBooleanType SetImageProperty(Image *image,const char *property,\n%        const char *value,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o property: the image property.\n%\n%    o values: the image property values.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SetImageProperty(Image *image,\n  const char *property,const char *value,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  MagickStatusType\n    flags;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->properties == (void *) NULL)\n    image->properties=NewSplayTree(CompareSplayTreeString,\n      RelinquishMagickMemory,RelinquishMagickMemory);  /* create splay-tree */\n  if (value == (const char *) NULL)\n    return(DeleteImageProperty(image,property));  /* delete if NULL */\n  status=MagickTrue;\n  if (strlen(property) <= 1)\n    {\n      /*\n        Do not 'set' single letter properties - read only shorthand.\n       */\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"SetReadOnlyProperty\",\"`%s'\",property);\n      return(MagickFalse);\n    }\n\n  /* FUTURE: binary chars or quotes in key should produce a error */\n  /* Set attributes with known names or special prefixes\n     return result is found, or break to set a free form properity\n  */\n  switch (*property)\n  {\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n    case '8':\n    {\n      if (LocaleNCompare(\"8bim:\",property,5) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break;\n    }\n#endif\n    case 'B':\n    case 'b':\n    {\n      if (LocaleCompare(\"background\",property) == 0)\n        {\n          (void) QueryColorCompliance(value,AllCompliance,\n               &image->background_color,exception);\n          /* check for FUTURE: value exception?? */\n          /* also add user input to splay tree */\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'C':\n    case 'c':\n    {\n      if (LocaleCompare(\"channels\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      if (LocaleCompare(\"colorspace\",property) == 0)\n        {\n          ssize_t\n            colorspace;\n\n          colorspace=ParseCommandOption(MagickColorspaceOptions,MagickFalse,\n            value);\n          if (colorspace < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          return(SetImageColorspace(image,(ColorspaceType) colorspace,exception));\n        }\n      if (LocaleCompare(\"compose\",property) == 0)\n        {\n          ssize_t\n            compose;\n\n          compose=ParseCommandOption(MagickComposeOptions,MagickFalse,value);\n          if (compose < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->compose=(CompositeOperator) compose;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"compress\",property) == 0)\n        {\n          ssize_t\n            compression;\n\n          compression=ParseCommandOption(MagickCompressOptions,MagickFalse,\n            value);\n          if (compression < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->compression=(CompressionType) compression;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'D':\n    case 'd':\n    {\n      if (LocaleCompare(\"delay\",property) == 0)\n        {\n          GeometryInfo\n            geometry_info;\n\n          flags=ParseGeometry(value,&geometry_info);\n          if ((flags & GreaterValue) != 0)\n            {\n              if (image->delay > (size_t) floor(geometry_info.rho+0.5))\n                image->delay=(size_t) floor(geometry_info.rho+0.5);\n            }\n          else\n            if ((flags & LessValue) != 0)\n              {\n                if (image->delay < (size_t) floor(geometry_info.rho+0.5))\n                  image->delay=(ssize_t)\n                    floor(geometry_info.sigma+0.5);\n              }\n            else\n              image->delay=(size_t) floor(geometry_info.rho+0.5);\n          if ((flags & SigmaValue) != 0)\n            image->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"delay_units\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      if (LocaleCompare(\"density\",property) == 0)\n        {\n          GeometryInfo\n            geometry_info;\n\n          flags=ParseGeometry(value,&geometry_info);\n          image->resolution.x=geometry_info.rho;\n          image->resolution.y=geometry_info.sigma;\n          if ((flags & SigmaValue) == 0)\n            image->resolution.y=image->resolution.x;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"depth\",property) == 0)\n        {\n          image->depth=StringToUnsignedLong(value);\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"dispose\",property) == 0)\n        {\n          ssize_t\n            dispose;\n\n          dispose=ParseCommandOption(MagickDisposeOptions,MagickFalse,value);\n          if (dispose < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->dispose=(DisposeType) dispose;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n    case 'E':\n    case 'e':\n    {\n      if (LocaleNCompare(\"exif:\",property,5) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'F':\n    case 'f':\n    {\n      if (LocaleNCompare(\"fx:\",property,3) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#endif\n    case 'G':\n    case 'g':\n    {\n      if (LocaleCompare(\"gamma\",property) == 0)\n        {\n          image->gamma=StringToDouble(value,(char **) NULL);\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"gravity\",property) == 0)\n        {\n          ssize_t\n            gravity;\n\n          gravity=ParseCommandOption(MagickGravityOptions,MagickFalse,value);\n          if (gravity < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->gravity=(GravityType) gravity;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'H':\n    case 'h':\n    {\n      if (LocaleCompare(\"height\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'I':\n    case 'i':\n    {\n      if (LocaleCompare(\"intensity\",property) == 0)\n        {\n          ssize_t\n            intensity;\n\n          intensity=ParseCommandOption(MagickIntentOptions,MagickFalse,value);\n          if (intensity < 0)\n            return(MagickFalse);\n          image->intensity=(PixelIntensityMethod) intensity;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"intent\",property) == 0)\n        {\n          ssize_t\n            rendering_intent;\n\n          rendering_intent=ParseCommandOption(MagickIntentOptions,MagickFalse,\n            value);\n          if (rendering_intent < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->rendering_intent=(RenderingIntent) rendering_intent;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"interpolate\",property) == 0)\n        {\n          ssize_t\n            interpolate;\n\n          interpolate=ParseCommandOption(MagickInterpolateOptions,MagickFalse,\n            value);\n          if (interpolate < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->interpolate=(PixelInterpolateMethod) interpolate;\n          return(MagickTrue);\n        }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n      if (LocaleNCompare(\"iptc:\",property,5) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n#endif\n      break; /* not an attribute, add as a property */\n    }\n    case 'K':\n    case 'k':\n      if (LocaleCompare(\"kurtosis\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'L':\n    case 'l':\n    {\n      if (LocaleCompare(\"loop\",property) == 0)\n        {\n          image->iterations=StringToUnsignedLong(value);\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'M':\n    case 'm':\n      if ((LocaleCompare(\"magick\",property) == 0) ||\n          (LocaleCompare(\"max\",property) == 0) ||\n          (LocaleCompare(\"mean\",property) == 0) ||\n          (LocaleCompare(\"min\",property) == 0) ||\n          (LocaleCompare(\"min\",property) == 0))\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n             \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'O':\n    case 'o':\n      if (LocaleCompare(\"opaque\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'P':\n    case 'p':\n    {\n      if (LocaleCompare(\"page\",property) == 0)\n        {\n          char\n            *geometry;\n\n          geometry=GetPageGeometry(value);\n          flags=ParseAbsoluteGeometry(geometry,&image->page);\n          geometry=DestroyString(geometry);\n          return(MagickTrue);\n        }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n      if (LocaleNCompare(\"pixel:\",property,6) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n#endif\n      if (LocaleCompare(\"profile\",property) == 0)\n        {\n          ImageInfo\n            *image_info;\n\n          StringInfo\n            *profile;\n\n          image_info=AcquireImageInfo();\n          (void) CopyMagickString(image_info->filename,value,MagickPathExtent);\n          (void) SetImageInfo(image_info,1,exception);\n          profile=FileToStringInfo(image_info->filename,~0UL,exception);\n          if (profile != (StringInfo *) NULL)\n            status=SetImageProfile(image,image_info->magick,profile,exception);\n          image_info=DestroyImageInfo(image_info);\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'R':\n    case 'r':\n    {\n      if (LocaleCompare(\"rendering-intent\",property) == 0)\n        {\n          ssize_t\n            rendering_intent;\n\n          rendering_intent=ParseCommandOption(MagickIntentOptions,MagickFalse,\n            value);\n          if (rendering_intent < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->rendering_intent=(RenderingIntent) rendering_intent;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'S':\n    case 's':\n      if ((LocaleCompare(\"size\",property) == 0) ||\n          (LocaleCompare(\"skewness\",property) == 0) ||\n          (LocaleCompare(\"scenes\",property) == 0) ||\n          (LocaleCompare(\"standard-deviation\",property) == 0))\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'T':\n    case 't':\n    {\n      if (LocaleCompare(\"tile-offset\",property) == 0)\n        {\n          char\n            *geometry;\n\n          geometry=GetPageGeometry(value);\n          flags=ParseAbsoluteGeometry(geometry,&image->tile_offset);\n          geometry=DestroyString(geometry);\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'U':\n    case 'u':\n    {\n      if (LocaleCompare(\"units\",property) == 0)\n        {\n          ssize_t\n            units;\n\n          units=ParseCommandOption(MagickResolutionOptions,MagickFalse,value);\n          if (units < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->units=(ResolutionType) units;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'V':\n    case 'v':\n    {\n      if (LocaleCompare(\"version\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'W':\n    case 'w':\n    {\n      if (LocaleCompare(\"width\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n    case 'X':\n    case 'x':\n    {\n      if (LocaleNCompare(\"xmp:\",property,4) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#endif\n  }\n  /* Default: not an attribute, add as a property */\n  status=AddValueToSplayTree((SplayTreeInfo *) image->properties,\n    ConstantString(property),ConstantString(value));\n  /* FUTURE: error if status is bad? */\n  return(status);\n}\n"], "filenames": ["MagickCore/property.c"], "buggy_code_start_loc": [674], "buggy_code_end_loc": [674], "fixing_code_start_loc": [675], "fixing_code_end_loc": [680], "type": "CWE-125", "message": "Buffer overflow in the Get8BIMProperty function in MagickCore/property.c in ImageMagick before 6.9.5-4 and 7.x before 7.0.2-6 allows remote attackers to cause a denial of service (out-of-bounds read, memory leak, and crash) via a crafted image.", "other": {"cve": {"id": "CVE-2016-6491", "sourceIdentifier": "cve@mitre.org", "published": "2016-12-13T15:59:09.217", "lastModified": "2017-07-01T01:30:01.127", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Buffer overflow in the Get8BIMProperty function in MagickCore/property.c in ImageMagick before 6.9.5-4 and 7.x before 7.0.2-6 allows remote attackers to cause a denial of service (out-of-bounds read, memory leak, and crash) via a crafted image."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer en la funci\u00f3n Get8BIMProperty en MagickCore/property.c en ImageMagick en versiones anteriores a 6.9.5-4 y 7.x en versiones anteriores a 7.0.2-6 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (lectura fuera de l\u00edmites, fuga de memoria y ca\u00edda) a trav\u00e9s de una imagen manipulada."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.9.5-3", "matchCriteriaId": "A2BC230D-5C9A-4C13-9FEB-AF963CEAF83A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-0:*:*:*:*:*:*:*", "matchCriteriaId": "693C9F8F-A8C1-4D06-8F31-E085E16E701C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-1:*:*:*:*:*:*:*", "matchCriteriaId": "6D3D3DFC-8459-41BA-BF3E-AE84E48FCEE7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-2:*:*:*:*:*:*:*", "matchCriteriaId": "A3E12EB4-B8F6-43A3-847D-DBC96AE10905"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-3:*:*:*:*:*:*:*", "matchCriteriaId": "30539421-5872-4C2E-94AE-8A2B05C952C0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-4:*:*:*:*:*:*:*", "matchCriteriaId": "1A5B7537-8563-409D-82DE-EB07107D3C04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-5:*:*:*:*:*:*:*", "matchCriteriaId": "FA648D3C-A464-4F54-8B5E-E8431531FBB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-6:*:*:*:*:*:*:*", "matchCriteriaId": "D6666BB0-B211-490F-884C-BE410CD19DAF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-7:*:*:*:*:*:*:*", "matchCriteriaId": "5FF2582D-1513-448B-8B61-9C4844B08324"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-8:*:*:*:*:*:*:*", "matchCriteriaId": "E57E6BA4-A727-4CF5-B15F-76632D02617A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-9:*:*:*:*:*:*:*", "matchCriteriaId": "C721BC6F-61DD-4ED1-8024-2946C494AEC4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-10:*:*:*:*:*:*:*", "matchCriteriaId": "CD319D32-FE7A-456D-AFEE-DC9F0D98652C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-0:*:*:*:*:*:*:*", "matchCriteriaId": "09CDF263-38F5-469F-984B-9D9A223159B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-1:*:*:*:*:*:*:*", "matchCriteriaId": "243FF3C1-D676-4D5F-A90C-3017DCBBE73A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-2:*:*:*:*:*:*:*", "matchCriteriaId": "1B8BDDE6-6B38-442B-83A4-FAADBAE1C792"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-3:*:*:*:*:*:*:*", "matchCriteriaId": "4DCD89B9-6A69-41DE-BE38-5E9193828279"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-4:*:*:*:*:*:*:*", "matchCriteriaId": "139BC277-8E00-4700-8B47-6D3A3CB38B04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-5:*:*:*:*:*:*:*", "matchCriteriaId": "D0FA2E18-6F7B-49D6-B60C-38851398F9B7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:oracle:solaris:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "FC633250-EB1E-4484-9BCB-977C8F9EB0B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:oracle:solaris:11.3:*:*:*:*:*:*:*", "matchCriteriaId": "79A602C5-61FE-47BA-9786-F045B6C6DBA8"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/07/28/13", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/07/28/15", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/topics/security/bulletinjul2016-3090568.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/92186", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1036501", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/ImageMagick/ImageMagick/blob/6.9.5-4/ChangeLog", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/dd84447b63a71fa8c3f47071b09454efc667767b", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://security.gentoo.org/glsa/201611-21", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/dd84447b63a71fa8c3f47071b09454efc667767b"}}