{"buggy_code": ["local setmetatable = setmetatable\nlocal tostring     = tostring\nlocal insert       = table.insert\nlocal remove       = table.remove\nlocal concat       = table.concat\nlocal ipairs       = ipairs\nlocal pairs        = pairs\nlocal match        = string.match\nlocal find         = string.find\nlocal sub          = string.sub\n\n\nlocal RANDOM_BOUNDARY = sub(tostring({}), 10)\n\n\nlocal MultipartData = { RANDOM_BOUNDARY = RANDOM_BOUNDARY}\n\n\nMultipartData.__index = MultipartData\n\n\nsetmetatable(MultipartData, {\n  __call = function (cls, ...)\n    return cls.new(...)\n  end,\n})\n\n\nlocal function is_header(value)\n  return match(value, \"(%S+):%s*(%S+)\")\nend\n\n\n-- Create a table representation of multipart/data body\n--\n-- @param {string} body The multipart/data string body\n-- @param {string} boundary The multipart/data boundary\n-- @return {table} Lua representation of the body\nlocal function decode(body, boundary)\n  local result = {\n    data    = {},\n    indexes = {},\n  }\n\n  if not boundary then\n    return result\n  end\n\n  local part_name\n  local part_index    = 1\n  local part_headers  = {}\n  local part_value    = {}\n  local part_value_ct = 0\n\n  local end_boundary_length   = boundary and #boundary + 2\n  local processing_part_value = false\n\n  local position = 1\n  local done     = false\n\n  repeat\n    local s = find(body, \"[\\r\\n]\", position)\n\n    local line\n\n    if s then\n      line = sub(body, position, s - 1)\n      position = s + 1\n\n    else\n      if position == 1 then\n        line = body\n\n      else\n        line = sub(body, position)\n      end\n\n      done = true\n    end\n\n    if line == \"\" then\n      if s and processing_part_value then\n        part_value_ct             = part_value_ct + 1\n        part_value[part_value_ct] = sub(body, s, s)\n      end\n\n    else\n      if sub(line, 1, 2) == \"--\" and sub(line, 3, end_boundary_length) == boundary then\n        processing_part_value = false\n\n        if part_name ~= nil then\n          if part_value[part_value_ct] == \"\\n\" then\n             part_value[part_value_ct] = nil\n          end\n\n          if part_value[part_value_ct - 1] == \"\\r\" then\n             part_value[part_value_ct - 1] = nil\n          end\n\n          result.data[part_index] = {\n            name    = part_name,\n            headers = part_headers,\n            value   = concat(part_value)\n          }\n\n          if result.indexes[part_name] == nil then\n            result.indexes[part_name] = {}\n          end\n\n          insert(result.indexes[part_name], part_index)\n\n          -- Reset fields for the next part\n          part_headers  = {}\n          part_value    = {}\n          part_value_ct = 0\n          part_name     = nil\n          part_index    = part_index + 1\n        end\n\n      else\n        --Beginning of part\n        if not processing_part_value and line:sub(1, 19):lower() == \"content-disposition\" then\n          -- Extract part_name\n          for v in line:gmatch(\"[^;]+\") do\n            if not is_header(v) then -- If it's not content disposition part\n              local pos = v:match(\"^%s*[Nn][Aa][Mm][Ee]=()\")\n              if pos then\n                local current_value = v:match(\"^%s*([^=]*)\", pos):gsub(\"%s*$\", \"\")\n                part_name = sub(current_value, 2, #current_value - 1)\n              end\n            end\n          end\n\n          insert(part_headers, line)\n\n          if s and sub(body, s, s + 3) == \"\\r\\n\\r\\n\" then\n            processing_part_value = true\n            position = s + 4\n          end\n\n        elseif not processing_part_value and is_header(line) then\n          insert(part_headers, line)\n\n          if s and sub(body, s, s + 3) == \"\\r\\n\\r\\n\" then\n            processing_part_value = true\n            position = s + 4\n          end\n\n        else\n          processing_part_value = true\n\n          -- The value part begins\n          part_value_ct               = part_value_ct + 1\n          part_value[part_value_ct]   = line\n\n          if s then\n            part_value_ct             = part_value_ct + 1\n            part_value[part_value_ct] = sub(body, s, s)\n          end\n        end\n      end\n    end\n\n  until done\n\n  if part_name ~= nil then\n    result.data[part_index] = {\n      name    = part_name,\n      headers = part_headers,\n      value   = concat(part_value)\n    }\n    result.indexes[part_name] = { part_index }\n  end\n\n  return result\nend\n\n-- Creates a multipart/data body from a table\n--\n-- @param {table} t The table that contains the multipart/data body properties\n-- @param {boundary} boundary The multipart/data boundary to use\n-- @return {string} The multipart/data string body\nlocal function encode(t, boundary)\n  if not boundary then\n    boundary = RANDOM_BOUNDARY\n  end\n\n  local result = {}\n  local i = 0\n\n  for _, v in ipairs(t.data) do\n    if v.value then\n      result[i + 1] = \"--\"\n      result[i + 2] = boundary\n      result[i + 3] = \"\\r\\n\"\n\n      i = i + 3\n\n      for _, header in ipairs(v.headers) do\n        result[i + 1] = header\n        result[i + 2] = \"\\r\\n\"\n\n        i = i + 2\n      end\n\n      result[i + 1] = \"\\r\\n\"\n      result[i + 2] = v.value\n      result[i + 3] = \"\\r\\n\"\n\n      i = i + 3\n    end\n  end\n\n  if i == 0 then\n    return \"\"\n  end\n\n  result[i + 1] = \"--\"\n  result[i + 2] = boundary\n  result[i + 3] = \"--\\r\\n\"\n\n  return concat(result)\nend\n\n\nfunction MultipartData.new(data, content_type)\n  local instance = setmetatable({}, MultipartData)\n\n  if content_type then\n    local boundary = match(content_type, \";%s*boundary=(%S+)\")\n    if boundary then\n      if (sub(boundary, 1, 1) == '\"' and sub(boundary, -1)  == '\"') or\n         (sub(boundary, 1, 1) == \"'\" and sub(boundary, -1)  == \"'\") then\n        boundary = sub(boundary, 2, -2)\n      end\n\n      if boundary ~= \"\" then\n        instance._boundary = boundary\n      end\n    end\n  end\n\n  instance._data = decode(data or \"\", instance._boundary)\n\n  return instance\nend\n\n\nfunction MultipartData:get(name)\n  -- Get first index for part\n  local index = self._data.indexes[name]\n  if not index then\n    return nil\n  end\n\n  return self._data.data[index[1]]\nend\n\n\nfunction MultipartData:get_all()\n  local result = {}\n\n  for k, v in pairs(self._data.indexes) do\n    -- Get first index for part\n    result[k] = self._data.data[v[1]].value\n  end\n\n  return result\nend\n\n\nfunction MultipartData:get_as_array(name)\n  local vals = {}\n\n  local idx = self._data.indexes[name]\n  if not idx then\n    return vals\n  end\n\n  for _, index in ipairs(self._data.indexes[name]) do\n    insert(vals, self._data.data[index].value)\n  end\n\n  return vals\nend\n\n\nfunction MultipartData:get_all_as_arrays()\n  -- Get all fields as arrays\n  local result = {}\n\n  for k in pairs(self._data.indexes) do\n    result[k] = self:get_as_array(k)\n  end\n\n  return result\nend\n\nfunction MultipartData:get_all_with_arrays()\n  -- Get repeating fields as arrays, rest as strings\n  local result = {}\n\n  for k, v in pairs(self._data.indexes) do\n    if #v == 1 then\n      result[k] = self._data.data[v[1]].value\n    else\n      result[k] = self:get_as_array(k)\n    end\n  end\n\n  return result\nend\n\n\nfunction MultipartData:set_simple(name, value, filename, content_type)\n    local headers = {'Content-Disposition: form-data; name=\"' , name , '\"'}\n    if filename then\n      headers[4] = '; filename=\"'\n      headers[5] = filename\n      headers[6] = '\"'\n    end\n    if content_type then\n      headers[7] = \"\\r\\ncontent-type: \"\n      headers[8] = content_type\n    end\n    headers = concat(headers)\n    if self._data.indexes[name] then\n      self._data.data[self._data.indexes[name][1]] = {\n        name = name,\n        value = value,\n        headers = { headers }\n      }\n\n    else\n      -- Find maximum index\n      local max_index = 0\n      for _, indexes in pairs(self._data.indexes) do\n        for _, index in ipairs(indexes) do\n          if index > max_index then\n            max_index = index\n          end\n        end\n      end\n      -- Assign data to new index\n      local part_index = max_index + 1\n      self._data.indexes[name] = { part_index }\n      self._data.data[part_index] = {\n        name    = name,\n        value   = value,\n        headers = { headers }\n      }\n    end\nend\n\n\nfunction MultipartData:delete(name)\n  -- If part name repeats, then delete all occurrences\n  local indexes = self._data.indexes[name]\n\n  if indexes ~= nil then\n    for _, index in ipairs(indexes) do\n      remove(self._data.data, index)\n    end\n    self._data.indexes[name] = nil\n\n    -- need to recount index\n    -- Deleted indexes can be anywhere,\n    -- including between values of indexes for single part name.\n    -- For every index, need to count how many deleted indexes are bellow it\n    for key, index_vals in pairs(self._data.indexes) do\n      for i, val in ipairs(index_vals) do\n        local num_deleted = 0\n        for _, del_index in ipairs(indexes) do\n          if val > del_index then\n            num_deleted = num_deleted + 1\n          end\n        end\n        self._data.indexes[key][i] = val - num_deleted\n      end\n    end\n  end\nend\n\n\nfunction MultipartData:tostring()\n  return encode(self._data, self._boundary)\nend\n\n\nreturn MultipartData\n"], "fixing_code": ["local setmetatable = setmetatable\nlocal tostring     = tostring\nlocal insert       = table.insert\nlocal remove       = table.remove\nlocal concat       = table.concat\nlocal ipairs       = ipairs\nlocal pairs        = pairs\nlocal match        = string.match\nlocal find         = string.find\nlocal sub          = string.sub\n\n\nlocal RANDOM_BOUNDARY = sub(tostring({}), 10)\n\n\nlocal MultipartData = { RANDOM_BOUNDARY = RANDOM_BOUNDARY}\n\n\nMultipartData.__index = MultipartData\n\n\nsetmetatable(MultipartData, {\n  __call = function (cls, ...)\n    return cls.new(...)\n  end,\n})\n\n\nlocal function is_header(value)\n  return match(value, \"%S:%s*%S\")\nend\n\n\n-- Create a table representation of multipart/data body\n--\n-- @param {string} body The multipart/data string body\n-- @param {string} boundary The multipart/data boundary\n-- @return {table} Lua representation of the body\nlocal function decode(body, boundary)\n  local result = {\n    data    = {},\n    indexes = {},\n  }\n\n  if not boundary then\n    return result\n  end\n\n  local part_name\n  local part_index    = 1\n  local part_headers  = {}\n  local part_value    = {}\n  local part_value_ct = 0\n\n  local end_boundary_length   = boundary and #boundary + 2\n  local processing_part_value = false\n\n  local position = 1\n  local done     = false\n\n  repeat\n    local s = find(body, \"[\\r\\n]\", position)\n\n    local line\n\n    if s then\n      line = sub(body, position, s - 1)\n      position = s + 1\n\n    else\n      if position == 1 then\n        line = body\n\n      else\n        line = sub(body, position)\n      end\n\n      done = true\n    end\n\n    if line == \"\" then\n      if s and processing_part_value then\n        part_value_ct             = part_value_ct + 1\n        part_value[part_value_ct] = sub(body, s, s)\n      end\n\n    else\n      if sub(line, 1, 2) == \"--\" and sub(line, 3, end_boundary_length) == boundary then\n        processing_part_value = false\n\n        if part_name ~= nil then\n          if part_value[part_value_ct] == \"\\n\" then\n             part_value[part_value_ct] = nil\n          end\n\n          if part_value[part_value_ct - 1] == \"\\r\" then\n             part_value[part_value_ct - 1] = nil\n          end\n\n          result.data[part_index] = {\n            name    = part_name,\n            headers = part_headers,\n            value   = concat(part_value)\n          }\n\n          if result.indexes[part_name] == nil then\n            result.indexes[part_name] = {}\n          end\n\n          insert(result.indexes[part_name], part_index)\n\n          -- Reset fields for the next part\n          part_headers  = {}\n          part_value    = {}\n          part_value_ct = 0\n          part_name     = nil\n          part_index    = part_index + 1\n        end\n\n      else\n        --Beginning of part\n        if not processing_part_value and line:sub(1, 19):lower() == \"content-disposition\" then\n          -- Extract part_name\n          for v in line:gmatch(\"[^;]+\") do\n            if not is_header(v) then -- If it's not content disposition part\n              local pos = v:match(\"^%s*[Nn][Aa][Mm][Ee]=()\")\n              if pos then\n                local current_value = v:match(\"^%s*([^=]*)\", pos):gsub(\"%s*$\", \"\")\n                part_name = sub(current_value, 2, #current_value - 1)\n              end\n            end\n          end\n\n          insert(part_headers, line)\n\n          if s and sub(body, s, s + 3) == \"\\r\\n\\r\\n\" then\n            processing_part_value = true\n            position = s + 4\n          end\n\n        elseif not processing_part_value and is_header(line) then\n          insert(part_headers, line)\n\n          if s and sub(body, s, s + 3) == \"\\r\\n\\r\\n\" then\n            processing_part_value = true\n            position = s + 4\n          end\n\n        else\n          processing_part_value = true\n\n          -- The value part begins\n          part_value_ct               = part_value_ct + 1\n          part_value[part_value_ct]   = line\n\n          if s then\n            part_value_ct             = part_value_ct + 1\n            part_value[part_value_ct] = sub(body, s, s)\n          end\n        end\n      end\n    end\n\n  until done\n\n  if part_name ~= nil then\n    result.data[part_index] = {\n      name    = part_name,\n      headers = part_headers,\n      value   = concat(part_value)\n    }\n    result.indexes[part_name] = { part_index }\n  end\n\n  return result\nend\n\n-- Creates a multipart/data body from a table\n--\n-- @param {table} t The table that contains the multipart/data body properties\n-- @param {boundary} boundary The multipart/data boundary to use\n-- @return {string} The multipart/data string body\nlocal function encode(t, boundary)\n  if not boundary then\n    boundary = RANDOM_BOUNDARY\n  end\n\n  local result = {}\n  local i = 0\n\n  for _, v in ipairs(t.data) do\n    if v.value then\n      result[i + 1] = \"--\"\n      result[i + 2] = boundary\n      result[i + 3] = \"\\r\\n\"\n\n      i = i + 3\n\n      for _, header in ipairs(v.headers) do\n        result[i + 1] = header\n        result[i + 2] = \"\\r\\n\"\n\n        i = i + 2\n      end\n\n      result[i + 1] = \"\\r\\n\"\n      result[i + 2] = v.value\n      result[i + 3] = \"\\r\\n\"\n\n      i = i + 3\n    end\n  end\n\n  if i == 0 then\n    return \"\"\n  end\n\n  result[i + 1] = \"--\"\n  result[i + 2] = boundary\n  result[i + 3] = \"--\\r\\n\"\n\n  return concat(result)\nend\n\n\nfunction MultipartData.new(data, content_type)\n  local instance = setmetatable({}, MultipartData)\n\n  if content_type then\n    local boundary = match(content_type, \";%s*boundary=(%S+)\")\n    if boundary then\n      if (sub(boundary, 1, 1) == '\"' and sub(boundary, -1)  == '\"') or\n         (sub(boundary, 1, 1) == \"'\" and sub(boundary, -1)  == \"'\") then\n        boundary = sub(boundary, 2, -2)\n      end\n\n      if boundary ~= \"\" then\n        instance._boundary = boundary\n      end\n    end\n  end\n\n  instance._data = decode(data or \"\", instance._boundary)\n\n  return instance\nend\n\n\nfunction MultipartData:get(name)\n  -- Get first index for part\n  local index = self._data.indexes[name]\n  if not index then\n    return nil\n  end\n\n  return self._data.data[index[1]]\nend\n\n\nfunction MultipartData:get_all()\n  local result = {}\n\n  for k, v in pairs(self._data.indexes) do\n    -- Get first index for part\n    result[k] = self._data.data[v[1]].value\n  end\n\n  return result\nend\n\n\nfunction MultipartData:get_as_array(name)\n  local vals = {}\n\n  local idx = self._data.indexes[name]\n  if not idx then\n    return vals\n  end\n\n  for _, index in ipairs(self._data.indexes[name]) do\n    insert(vals, self._data.data[index].value)\n  end\n\n  return vals\nend\n\n\nfunction MultipartData:get_all_as_arrays()\n  -- Get all fields as arrays\n  local result = {}\n\n  for k in pairs(self._data.indexes) do\n    result[k] = self:get_as_array(k)\n  end\n\n  return result\nend\n\nfunction MultipartData:get_all_with_arrays()\n  -- Get repeating fields as arrays, rest as strings\n  local result = {}\n\n  for k, v in pairs(self._data.indexes) do\n    if #v == 1 then\n      result[k] = self._data.data[v[1]].value\n    else\n      result[k] = self:get_as_array(k)\n    end\n  end\n\n  return result\nend\n\n\nfunction MultipartData:set_simple(name, value, filename, content_type)\n    local headers = {'Content-Disposition: form-data; name=\"' , name , '\"'}\n    if filename then\n      headers[4] = '; filename=\"'\n      headers[5] = filename\n      headers[6] = '\"'\n    end\n    if content_type then\n      headers[7] = \"\\r\\ncontent-type: \"\n      headers[8] = content_type\n    end\n    headers = concat(headers)\n    if self._data.indexes[name] then\n      self._data.data[self._data.indexes[name][1]] = {\n        name = name,\n        value = value,\n        headers = { headers }\n      }\n\n    else\n      -- Find maximum index\n      local max_index = 0\n      for _, indexes in pairs(self._data.indexes) do\n        for _, index in ipairs(indexes) do\n          if index > max_index then\n            max_index = index\n          end\n        end\n      end\n      -- Assign data to new index\n      local part_index = max_index + 1\n      self._data.indexes[name] = { part_index }\n      self._data.data[part_index] = {\n        name    = name,\n        value   = value,\n        headers = { headers }\n      }\n    end\nend\n\n\nfunction MultipartData:delete(name)\n  -- If part name repeats, then delete all occurrences\n  local indexes = self._data.indexes[name]\n\n  if indexes ~= nil then\n    for _, index in ipairs(indexes) do\n      remove(self._data.data, index)\n    end\n    self._data.indexes[name] = nil\n\n    -- need to recount index\n    -- Deleted indexes can be anywhere,\n    -- including between values of indexes for single part name.\n    -- For every index, need to count how many deleted indexes are bellow it\n    for key, index_vals in pairs(self._data.indexes) do\n      for i, val in ipairs(index_vals) do\n        local num_deleted = 0\n        for _, del_index in ipairs(indexes) do\n          if val > del_index then\n            num_deleted = num_deleted + 1\n          end\n        end\n        self._data.indexes[key][i] = val - num_deleted\n      end\n    end\n  end\nend\n\n\nfunction MultipartData:tostring()\n  return encode(self._data, self._boundary)\nend\n\n\nreturn MultipartData\n"], "filenames": ["src/multipart.lua"], "buggy_code_start_loc": [30], "buggy_code_end_loc": [31], "fixing_code_start_loc": [30], "fixing_code_end_loc": [31], "type": "CWE-1333", "message": "A vulnerability was found in Kong lua-multipart 0.5.8-1. It has been declared as problematic. This vulnerability affects the function is_header of the file src/multipart.lua. The manipulation leads to inefficient regular expression complexity. Upgrading to version 0.5.9-1 is able to address this issue. The name of the patch is d632e5df43a2928fd537784a99a79dec288bf01b. It is recommended to upgrade the affected component. VDB-220642 is the identifier assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2020-36661", "sourceIdentifier": "cna@vuldb.com", "published": "2023-02-12T21:15:10.650", "lastModified": "2023-02-24T06:24:34.020", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in Kong lua-multipart 0.5.8-1. It has been declared as problematic. This vulnerability affects the function is_header of the file src/multipart.lua. The manipulation leads to inefficient regular expression complexity. Upgrading to version 0.5.9-1 is able to address this issue. The name of the patch is d632e5df43a2928fd537784a99a79dec288bf01b. It is recommended to upgrade the affected component. VDB-220642 is the identifier assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.7}, "baseSeverity": "LOW", "exploitabilityScore": 5.1, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1333"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:konghq:multipart:0.5.8-1:*:*:*:*:lua:*:*", "matchCriteriaId": "706451AA-EA0B-482A-9F9C-B1BA98D80EFD"}]}]}], "references": [{"url": "https://github.com/Kong/lua-multipart/commit/d632e5df43a2928fd537784a99a79dec288bf01b", "source": "cna@vuldb.com", "tags": ["Patch"]}, {"url": "https://github.com/Kong/lua-multipart/pull/34", "source": "cna@vuldb.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/Kong/lua-multipart/releases/tag/0.5.9-1", "source": "cna@vuldb.com", "tags": ["Patch", "Release Notes"]}, {"url": "https://vuldb.com/?ctiid.220642", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.220642", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Kong/lua-multipart/commit/d632e5df43a2928fd537784a99a79dec288bf01b"}}