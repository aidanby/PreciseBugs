{"buggy_code": ["/**********************************************************************\n * Copyright (c) 2008  Red Hat, Inc.\n *\n * File: ParaNdis-Common.c\n *\n * This file contains NDIS driver procedures, common for NDIS5 and NDIS6\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n**********************************************************************/\n#include \"ndis56common.h\"\n\nstatic VOID ParaNdis_UpdateMAC(PARANDIS_ADAPTER *pContext);\n\nstatic __inline pRxNetDescriptor ReceiveQueueGetBuffer(PPARANDIS_RECEIVE_QUEUE pQueue);\n\n// TODO: remove when the problem solved\nvoid WriteVirtIODeviceByte(ULONG_PTR ulRegister, u8 bValue);\n\n//#define ROUNDSIZE(sz) ((sz + 15) & ~15)\n#define MAX_VLAN_ID     4095\n\n#define ABSTRACT_PATHES_TAG 'APVR'\n\n/**********************************************************\nValidates MAC address\nValid MAC address is not broadcast, not multicast, not empty\nif bLocal is set, it must be LOCAL\nif not, is must be non-local or local\nParameters:\n    PUCHAR pcMacAddress - MAC address to validate\n    BOOLEAN bLocal      - TRUE, if we validate locally administered address\nReturn value:\n    TRUE if valid\n***********************************************************/\nBOOLEAN ParaNdis_ValidateMacAddress(PUCHAR pcMacAddress, BOOLEAN bLocal)\n{\n    BOOLEAN bLA = FALSE, bEmpty, bBroadcast, bMulticast = FALSE;\n    bBroadcast = ETH_IS_BROADCAST(pcMacAddress);\n    bLA = !bBroadcast && ETH_IS_LOCALLY_ADMINISTERED(pcMacAddress);\n    bMulticast = !bBroadcast && ETH_IS_MULTICAST(pcMacAddress);\n    bEmpty = ETH_IS_EMPTY(pcMacAddress);\n    return !bBroadcast && !bEmpty && !bMulticast && (!bLocal || bLA);\n}\n\ntypedef struct _tagConfigurationEntry\n{\n    const char      *Name;\n    ULONG           ulValue;\n    ULONG           ulMinimal;\n    ULONG           ulMaximal;\n}tConfigurationEntry;\n\ntypedef struct _tagConfigurationEntries\n{\n    tConfigurationEntry PrioritySupport;\n    tConfigurationEntry ConnectRate;\n    tConfigurationEntry isLogEnabled;\n    tConfigurationEntry debugLevel;\n    tConfigurationEntry TxCapacity;\n    tConfigurationEntry RxCapacity;\n    tConfigurationEntry LogStatistics;\n    tConfigurationEntry OffloadTxChecksum;\n    tConfigurationEntry OffloadTxLSO;\n    tConfigurationEntry OffloadRxCS;\n    tConfigurationEntry stdIpcsV4;\n    tConfigurationEntry stdTcpcsV4;\n    tConfigurationEntry stdTcpcsV6;\n    tConfigurationEntry stdUdpcsV4;\n    tConfigurationEntry stdUdpcsV6;\n    tConfigurationEntry stdLsoV1;\n    tConfigurationEntry stdLsoV2ip4;\n    tConfigurationEntry stdLsoV2ip6;\n    tConfigurationEntry PriorityVlanTagging;\n    tConfigurationEntry VlanId;\n    tConfigurationEntry PublishIndices;\n    tConfigurationEntry MTU;\n    tConfigurationEntry NumberOfHandledRXPackersInDPC;\n#if PARANDIS_SUPPORT_RSS\n    tConfigurationEntry RSSOffloadSupported;\n    tConfigurationEntry NumRSSQueues;\n#endif\n#if PARANDIS_SUPPORT_RSC\n    tConfigurationEntry RSCIPv4Supported;\n    tConfigurationEntry RSCIPv6Supported;\n#endif\n}tConfigurationEntries;\n\nstatic const tConfigurationEntries defaultConfiguration =\n{\n    { \"Priority\",       0,  0,  1 },\n    { \"ConnectRate\",    100,10,10000 },\n    { \"DoLog\",          1,  0,  1 },\n    { \"DebugLevel\",     2,  0,  8 },\n    { \"TxCapacity\",     1024,   16, 1024 },\n    { \"RxCapacity\",     256, 32, 1024 },\n    { \"LogStatistics\",  0, 0, 10000},\n    { \"Offload.TxChecksum\", 0, 0, 31},\n    { \"Offload.TxLSO\",  0, 0, 2},\n    { \"Offload.RxCS\",   0, 0, 31},\n    { \"*IPChecksumOffloadIPv4\", 3, 0, 3 },\n    { \"*TCPChecksumOffloadIPv4\",3, 0, 3 },\n    { \"*TCPChecksumOffloadIPv6\",3, 0, 3 },\n    { \"*UDPChecksumOffloadIPv4\",3, 0, 3 },\n    { \"*UDPChecksumOffloadIPv6\",3, 0, 3 },\n    { \"*LsoV1IPv4\", 1, 0, 1 },\n    { \"*LsoV2IPv4\", 1, 0, 1 },\n    { \"*LsoV2IPv6\", 1, 0, 1 },\n    { \"*PriorityVLANTag\", 3, 0, 3},\n    { \"VlanId\", 0, 0, MAX_VLAN_ID},\n    { \"PublishIndices\", 1, 0, 1},\n    { \"MTU\", 1500, 576, 65500},\n    { \"NumberOfHandledRXPackersInDPC\", MAX_RX_LOOPS, 1, 10000},\n#if PARANDIS_SUPPORT_RSS\n    { \"*RSS\", 1, 0, 1},\n    { \"*NumRssQueues\", 8, 1, PARANDIS_RSS_MAX_RECEIVE_QUEUES},\n#endif\n#if PARANDIS_SUPPORT_RSC\n    { \"*RscIPv4\", 1, 0, 1},\n    { \"*RscIPv6\", 1, 0, 1},\n#endif\n};\n\nstatic void ParaNdis_ResetVirtIONetDevice(PARANDIS_ADAPTER *pContext)\n{\n    VirtIODeviceReset(pContext->IODevice);\n    DPrintf(0, (\"[%s] Done\\n\", __FUNCTION__));\n    /* reset all the features in the device */\n    pContext->ulCurrentVlansFilterSet = 0;\n}\n\n/**********************************************************\nGets integer value for specifies in pEntry->Name name\nParameters:\n    NDIS_HANDLE cfg  previously open configuration\n    tConfigurationEntry *pEntry - Entry to fill value in\n***********************************************************/\nstatic void GetConfigurationEntry(NDIS_HANDLE cfg, tConfigurationEntry *pEntry)\n{\n    NDIS_STATUS status;\n    const char *statusName;\n    NDIS_STRING name = {0};\n    PNDIS_CONFIGURATION_PARAMETER pParam = NULL;\n    NDIS_PARAMETER_TYPE ParameterType = NdisParameterInteger;\n    NdisInitializeString(&name, (PUCHAR)pEntry->Name);\n#pragma warning(push)\n#pragma warning(disable:6102)\n    NdisReadConfiguration(\n        &status,\n        &pParam,\n        cfg,\n        &name,\n        ParameterType);\n    if (status == NDIS_STATUS_SUCCESS)\n    {\n        ULONG ulValue = pParam->ParameterData.IntegerData;\n        if (ulValue >= pEntry->ulMinimal && ulValue <= pEntry->ulMaximal)\n        {\n            pEntry->ulValue = ulValue;\n            statusName = \"value\";\n        }\n        else\n        {\n            statusName = \"out of range\";\n        }\n    }\n    else\n    {\n        statusName = \"nothing\";\n    }\n#pragma warning(pop)\n    DPrintf(2, (\"[%s] %s read for %s - 0x%x\\n\",\n        __FUNCTION__,\n        statusName,\n        pEntry->Name,\n        pEntry->ulValue));\n    if (name.Buffer) NdisFreeString(name);\n}\n\nstatic void DisableLSOv4Permanently(PARANDIS_ADAPTER *pContext, LPCSTR procname, LPCSTR reason)\n{\n    if (pContext->Offload.flagsValue & osbT4Lso)\n    {\n        DPrintf(0, (\"[%s] Warning: %s\", procname, reason));\n        pContext->Offload.flagsValue &= ~osbT4Lso;\n        ParaNdis_ResetOffloadSettings(pContext, NULL, NULL);\n    }\n}\n\nstatic void DisableLSOv6Permanently(PARANDIS_ADAPTER *pContext, LPCSTR procname, LPCSTR reason)\n{\n    if (pContext->Offload.flagsValue & osbT6Lso)\n    {\n        DPrintf(0, (\"[%s] Warning: %s\\n\", procname, reason));\n        pContext->Offload.flagsValue &= ~osbT6Lso;\n        ParaNdis_ResetOffloadSettings(pContext, NULL, NULL);\n    }\n}\n\n/**********************************************************\nLoads NIC parameters from adapter registry key\nParameters:\n    context\n    PUCHAR *ppNewMACAddress - pointer to hold MAC address if configured from host\n***********************************************************/\nstatic void ReadNicConfiguration(PARANDIS_ADAPTER *pContext, PUCHAR pNewMACAddress)\n{\n    NDIS_HANDLE cfg;\n    tConfigurationEntries *pConfiguration = (tConfigurationEntries *) ParaNdis_AllocateMemory(pContext, sizeof(tConfigurationEntries));\n    if (pConfiguration)\n    {\n        *pConfiguration = defaultConfiguration;\n        cfg = ParaNdis_OpenNICConfiguration(pContext);\n        if (cfg)\n        {\n            GetConfigurationEntry(cfg, &pConfiguration->isLogEnabled);\n            GetConfigurationEntry(cfg, &pConfiguration->debugLevel);\n            GetConfigurationEntry(cfg, &pConfiguration->ConnectRate);\n            GetConfigurationEntry(cfg, &pConfiguration->PrioritySupport);\n            GetConfigurationEntry(cfg, &pConfiguration->TxCapacity);\n            GetConfigurationEntry(cfg, &pConfiguration->RxCapacity);\n            GetConfigurationEntry(cfg, &pConfiguration->LogStatistics);\n            GetConfigurationEntry(cfg, &pConfiguration->OffloadTxChecksum);\n            GetConfigurationEntry(cfg, &pConfiguration->OffloadTxLSO);\n            GetConfigurationEntry(cfg, &pConfiguration->OffloadRxCS);\n            GetConfigurationEntry(cfg, &pConfiguration->stdIpcsV4);\n            GetConfigurationEntry(cfg, &pConfiguration->stdTcpcsV4);\n            GetConfigurationEntry(cfg, &pConfiguration->stdTcpcsV6);\n            GetConfigurationEntry(cfg, &pConfiguration->stdUdpcsV4);\n            GetConfigurationEntry(cfg, &pConfiguration->stdUdpcsV6);\n            GetConfigurationEntry(cfg, &pConfiguration->stdLsoV1);\n            GetConfigurationEntry(cfg, &pConfiguration->stdLsoV2ip4);\n            GetConfigurationEntry(cfg, &pConfiguration->stdLsoV2ip6);\n            GetConfigurationEntry(cfg, &pConfiguration->PriorityVlanTagging);\n            GetConfigurationEntry(cfg, &pConfiguration->VlanId);\n            GetConfigurationEntry(cfg, &pConfiguration->PublishIndices);\n            GetConfigurationEntry(cfg, &pConfiguration->MTU);\n            GetConfigurationEntry(cfg, &pConfiguration->NumberOfHandledRXPackersInDPC);\n#if PARANDIS_SUPPORT_RSS\n            GetConfigurationEntry(cfg, &pConfiguration->RSSOffloadSupported);\n            GetConfigurationEntry(cfg, &pConfiguration->NumRSSQueues);\n#endif\n#if PARANDIS_SUPPORT_RSC\n            GetConfigurationEntry(cfg, &pConfiguration->RSCIPv4Supported);\n            GetConfigurationEntry(cfg, &pConfiguration->RSCIPv6Supported);\n#endif\n\n            bDebugPrint = pConfiguration->isLogEnabled.ulValue;\n            virtioDebugLevel = pConfiguration->debugLevel.ulValue;\n            pContext->maxFreeTxDescriptors = pConfiguration->TxCapacity.ulValue;\n            pContext->NetMaxReceiveBuffers = pConfiguration->RxCapacity.ulValue;\n            pContext->Limits.nPrintDiagnostic = pConfiguration->LogStatistics.ulValue;\n            pContext->uNumberOfHandledRXPacketsInDPC = pConfiguration->NumberOfHandledRXPackersInDPC.ulValue;\n            pContext->bDoSupportPriority = pConfiguration->PrioritySupport.ulValue != 0;\n            pContext->ulFormalLinkSpeed  = pConfiguration->ConnectRate.ulValue;\n            pContext->ulFormalLinkSpeed *= 1000000;\n            pContext->Offload.flagsValue = 0;\n            // TX caps: 1 - TCP, 2 - UDP, 4 - IP, 8 - TCPv6, 16 - UDPv6\n            if (pConfiguration->OffloadTxChecksum.ulValue & 1) pContext->Offload.flagsValue |= osbT4TcpChecksum | osbT4TcpOptionsChecksum;\n            if (pConfiguration->OffloadTxChecksum.ulValue & 2) pContext->Offload.flagsValue |= osbT4UdpChecksum;\n            if (pConfiguration->OffloadTxChecksum.ulValue & 4) pContext->Offload.flagsValue |= osbT4IpChecksum | osbT4IpOptionsChecksum;\n            if (pConfiguration->OffloadTxChecksum.ulValue & 8) pContext->Offload.flagsValue |= osbT6TcpChecksum | osbT6TcpOptionsChecksum;\n            if (pConfiguration->OffloadTxChecksum.ulValue & 16) pContext->Offload.flagsValue |= osbT6UdpChecksum;\n            if (pConfiguration->OffloadTxLSO.ulValue) pContext->Offload.flagsValue |= osbT4Lso | osbT4LsoIp | osbT4LsoTcp;\n            if (pConfiguration->OffloadTxLSO.ulValue > 1) pContext->Offload.flagsValue |= osbT6Lso | osbT6LsoTcpOptions;\n            // RX caps: 1 - TCP, 2 - UDP, 4 - IP, 8 - TCPv6, 16 - UDPv6\n            if (pConfiguration->OffloadRxCS.ulValue & 1) pContext->Offload.flagsValue |= osbT4RxTCPChecksum | osbT4RxTCPOptionsChecksum;\n            if (pConfiguration->OffloadRxCS.ulValue & 2) pContext->Offload.flagsValue |= osbT4RxUDPChecksum;\n            if (pConfiguration->OffloadRxCS.ulValue & 4) pContext->Offload.flagsValue |= osbT4RxIPChecksum | osbT4RxIPOptionsChecksum;\n            if (pConfiguration->OffloadRxCS.ulValue & 8) pContext->Offload.flagsValue |= osbT6RxTCPChecksum | osbT6RxTCPOptionsChecksum;\n            if (pConfiguration->OffloadRxCS.ulValue & 16) pContext->Offload.flagsValue |= osbT6RxUDPChecksum;\n            /* full packet size that can be configured as GSO for VIRTIO is short */\n            /* NDIS test fails sometimes fails on segments 50-60K */\n            pContext->Offload.maxPacketSize = PARANDIS_MAX_LSO_SIZE;\n            pContext->InitialOffloadParameters.IPv4Checksum = (UCHAR)pConfiguration->stdIpcsV4.ulValue;\n            pContext->InitialOffloadParameters.TCPIPv4Checksum = (UCHAR)pConfiguration->stdTcpcsV4.ulValue;\n            pContext->InitialOffloadParameters.TCPIPv6Checksum = (UCHAR)pConfiguration->stdTcpcsV6.ulValue;\n            pContext->InitialOffloadParameters.UDPIPv4Checksum = (UCHAR)pConfiguration->stdUdpcsV4.ulValue;\n            pContext->InitialOffloadParameters.UDPIPv6Checksum = (UCHAR)pConfiguration->stdUdpcsV6.ulValue;\n            pContext->InitialOffloadParameters.LsoV1 = (UCHAR)pConfiguration->stdLsoV1.ulValue;\n            pContext->InitialOffloadParameters.LsoV2IPv4 = (UCHAR)pConfiguration->stdLsoV2ip4.ulValue;\n            pContext->InitialOffloadParameters.LsoV2IPv6 = (UCHAR)pConfiguration->stdLsoV2ip6.ulValue;\n            pContext->ulPriorityVlanSetting = pConfiguration->PriorityVlanTagging.ulValue;\n            pContext->VlanId = pConfiguration->VlanId.ulValue & 0xfff;\n            pContext->MaxPacketSize.nMaxDataSize = pConfiguration->MTU.ulValue;\n#if PARANDIS_SUPPORT_RSS\n            pContext->bRSSOffloadSupported = pConfiguration->RSSOffloadSupported.ulValue ? TRUE : FALSE;\n            pContext->RSSMaxQueuesNumber = (CCHAR) pConfiguration->NumRSSQueues.ulValue;\n#endif\n#if PARANDIS_SUPPORT_RSC\n            pContext->RSC.bIPv4SupportedSW = (UCHAR)pConfiguration->RSCIPv4Supported.ulValue;\n            pContext->RSC.bIPv6SupportedSW = (UCHAR)pConfiguration->RSCIPv6Supported.ulValue;\n#endif\n            if (!pContext->bDoSupportPriority)\n                pContext->ulPriorityVlanSetting = 0;\n            // if Vlan not supported\n            if (!IsVlanSupported(pContext)) {\n                pContext->VlanId = 0;\n            }\n\n            {\n                NDIS_STATUS status;\n                PVOID p;\n                UINT  len = 0;\n#pragma warning(push)\n#pragma warning(disable:6102)\n                NdisReadNetworkAddress(&status, &p, &len, cfg);\n                if (status == NDIS_STATUS_SUCCESS && len == ETH_LENGTH_OF_ADDRESS)\n                {\n                    NdisMoveMemory(pNewMACAddress, p, len);\n                }\n                else if (len && len != ETH_LENGTH_OF_ADDRESS)\n                {\n                    DPrintf(0, (\"[%s] MAC address has wrong length of %d\\n\", __FUNCTION__, len));\n                }\n                else\n                {\n                    DPrintf(4, (\"[%s] Nothing read for MAC, error %X\\n\", __FUNCTION__, status));\n                }\n#pragma warning(pop)\n            }\n            NdisCloseConfiguration(cfg);\n        }\n        NdisFreeMemory(pConfiguration, 0, 0);\n    }\n}\n\nvoid ParaNdis_ResetOffloadSettings(PARANDIS_ADAPTER *pContext, tOffloadSettingsFlags *pDest, PULONG from)\n{\n    if (!pDest) pDest = &pContext->Offload.flags;\n    if (!from)  from = &pContext->Offload.flagsValue;\n\n    pDest->fTxIPChecksum = !!(*from & osbT4IpChecksum);\n    pDest->fTxTCPChecksum = !!(*from & osbT4TcpChecksum);\n    pDest->fTxUDPChecksum = !!(*from & osbT4UdpChecksum);\n    pDest->fTxTCPOptions = !!(*from & osbT4TcpOptionsChecksum);\n    pDest->fTxIPOptions = !!(*from & osbT4IpOptionsChecksum);\n\n    pDest->fTxLso = !!(*from & osbT4Lso);\n    pDest->fTxLsoIP = !!(*from & osbT4LsoIp);\n    pDest->fTxLsoTCP = !!(*from & osbT4LsoTcp);\n\n    pDest->fRxIPChecksum = !!(*from & osbT4RxIPChecksum);\n    pDest->fRxIPOptions = !!(*from & osbT4RxIPOptionsChecksum);\n    pDest->fRxTCPChecksum = !!(*from & osbT4RxTCPChecksum);\n    pDest->fRxTCPOptions = !!(*from & osbT4RxTCPOptionsChecksum);\n    pDest->fRxUDPChecksum = !!(*from & osbT4RxUDPChecksum);\n\n    pDest->fTxTCPv6Checksum = !!(*from & osbT6TcpChecksum);\n    pDest->fTxTCPv6Options = !!(*from & osbT6TcpOptionsChecksum);\n    pDest->fTxUDPv6Checksum = !!(*from & osbT6UdpChecksum);\n    pDest->fTxIPv6Ext = !!(*from & osbT6IpExtChecksum);\n\n    pDest->fTxLsov6 = !!(*from & osbT6Lso);\n    pDest->fTxLsov6IP = !!(*from & osbT6LsoIpExt);\n    pDest->fTxLsov6TCP = !!(*from & osbT6LsoTcpOptions);\n\n    pDest->fRxTCPv6Checksum = !!(*from & osbT6RxTCPChecksum);\n    pDest->fRxTCPv6Options = !!(*from & osbT6RxTCPOptionsChecksum);\n    pDest->fRxUDPv6Checksum = !!(*from & osbT6RxUDPChecksum);\n    pDest->fRxIPv6Ext = !!(*from & osbT6RxIpExtChecksum);\n}\n\n/**********************************************************\nEnumerates adapter resources and fills the structure holding them\nVerifies that IO assigned and has correct size\nVerifies that interrupt assigned\nParameters:\n    PNDIS_RESOURCE_LIST RList - list of resources, received from NDIS\n    tAdapterResources *pResources - structure to fill\nReturn value:\n    TRUE if everything is OK\n***********************************************************/\nstatic BOOLEAN GetAdapterResources(PNDIS_RESOURCE_LIST RList, tAdapterResources *pResources)\n{\n    UINT i;\n    NdisZeroMemory(pResources, sizeof(*pResources));\n    for (i = 0; i < RList->Count; ++i)\n    {\n        ULONG type = RList->PartialDescriptors[i].Type;\n        if (type == CmResourceTypePort)\n        {\n            PHYSICAL_ADDRESS Start = RList->PartialDescriptors[i].u.Port.Start;\n            ULONG len = RList->PartialDescriptors[i].u.Port.Length;\n            DPrintf(0, (\"Found IO ports at %08lX(%d)\\n\", Start.LowPart, len));\n            pResources->ulIOAddress = Start.LowPart;\n            pResources->IOLength = len;\n        }\n        else if (type == CmResourceTypeInterrupt)\n        {\n            pResources->Vector = RList->PartialDescriptors[i].u.Interrupt.Vector;\n            pResources->Level = RList->PartialDescriptors[i].u.Interrupt.Level;\n            pResources->Affinity = RList->PartialDescriptors[i].u.Interrupt.Affinity;\n            pResources->InterruptFlags = RList->PartialDescriptors[i].Flags;\n            DPrintf(0, (\"Found Interrupt vector %d, level %d, affinity %X, flags %X\\n\",\n                pResources->Vector, pResources->Level, (ULONG)pResources->Affinity, pResources->InterruptFlags));\n        }\n    }\n    return pResources->ulIOAddress && pResources->Vector;\n}\n\nstatic void DumpVirtIOFeatures(PPARANDIS_ADAPTER pContext)\n{\n    static const struct {  ULONG bitmask;  PCHAR Name; } Features[] =\n    {\n\n        {VIRTIO_NET_F_CSUM, \"VIRTIO_NET_F_CSUM\" },\n        {VIRTIO_NET_F_GUEST_CSUM, \"VIRTIO_NET_F_GUEST_CSUM\" },\n        {VIRTIO_NET_F_MAC, \"VIRTIO_NET_F_MAC\" },\n        {VIRTIO_NET_F_GSO, \"VIRTIO_NET_F_GSO\" },\n        {VIRTIO_NET_F_GUEST_TSO4, \"VIRTIO_NET_F_GUEST_TSO4\"},\n        {VIRTIO_NET_F_GUEST_TSO6, \"VIRTIO_NET_F_GUEST_TSO6\"},\n        {VIRTIO_NET_F_GUEST_ECN, \"VIRTIO_NET_F_GUEST_ECN\"},\n        {VIRTIO_NET_F_GUEST_UFO, \"VIRTIO_NET_F_GUEST_UFO\"},\n        {VIRTIO_NET_F_HOST_TSO4, \"VIRTIO_NET_F_HOST_TSO4\"},\n        {VIRTIO_NET_F_HOST_TSO6, \"VIRTIO_NET_F_HOST_TSO6\"},\n        {VIRTIO_NET_F_HOST_ECN, \"VIRTIO_NET_F_HOST_ECN\"},\n        {VIRTIO_NET_F_HOST_UFO, \"VIRTIO_NET_F_HOST_UFO\"},\n        {VIRTIO_NET_F_MRG_RXBUF, \"VIRTIO_NET_F_MRG_RXBUF\"},\n        {VIRTIO_NET_F_STATUS, \"VIRTIO_NET_F_STATUS\"},\n        {VIRTIO_NET_F_CTRL_VQ, \"VIRTIO_NET_F_CTRL_VQ\"},\n        {VIRTIO_NET_F_CTRL_RX, \"VIRTIO_NET_F_CTRL_RX\"},\n        {VIRTIO_NET_F_CTRL_VLAN, \"VIRTIO_NET_F_CTRL_VLAN\"},\n        {VIRTIO_NET_F_CTRL_RX_EXTRA, \"VIRTIO_NET_F_CTRL_RX_EXTRA\"},\n        {VIRTIO_NET_F_CTRL_MAC_ADDR, \"VIRTIO_NET_F_CTRL_MAC_ADDR\"},\n        {VIRTIO_F_INDIRECT, \"VIRTIO_F_INDIRECT\"},\n        {VIRTIO_F_ANY_LAYOUT, \"VIRTIO_F_ANY_LAYOUT\"},\n        { VIRTIO_RING_F_EVENT_IDX, \"VIRTIO_RING_F_EVENT_IDX\" },\n    };\n    UINT i;\n    for (i = 0; i < sizeof(Features)/sizeof(Features[0]); ++i)\n    {\n        if (VirtIOIsFeatureEnabled(pContext->u32HostFeatures, Features[i].bitmask))\n        {\n            DPrintf(0, (\"VirtIO Host Feature %s\\n\", Features[i].Name));\n        }\n    }\n}\n\nstatic BOOLEAN\nAckFeature(PPARANDIS_ADAPTER pContext, UINT32 Feature)\n{\n    if (VirtIOIsFeatureEnabled(pContext->u32HostFeatures, Feature))\n    {\n        VirtIOFeatureEnable(pContext->u32GuestFeatures, Feature);\n        return TRUE;\n    }\n    return FALSE;\n}\n\n/**********************************************************\nPrints out statistics\n***********************************************************/\nstatic void PrintStatistics(PARANDIS_ADAPTER *pContext)\n{\n    ULONG64 totalTxFrames =\n        pContext->Statistics.ifHCOutBroadcastPkts +\n        pContext->Statistics.ifHCOutMulticastPkts +\n        pContext->Statistics.ifHCOutUcastPkts;\n    ULONG64 totalRxFrames =\n        pContext->Statistics.ifHCInBroadcastPkts +\n        pContext->Statistics.ifHCInMulticastPkts +\n        pContext->Statistics.ifHCInUcastPkts;\n\n#if 0 /* TODO - setup accessor functions*/\n    DPrintf(0, (\"[Diag!%X] RX buffers at VIRTIO %d of %d\\n\",\n        pContext->CurrentMacAddress[5],\n        pContext->RXPath.m_NetNofReceiveBuffers,\n        pContext->NetMaxReceiveBuffers));\n\n    DPrintf(0, (\"[Diag!] TX desc available %d/%d, buf %d\\n\",\n        pContext->TXPath.GetFreeTXDescriptors(),\n        pContext->maxFreeTxDescriptors,\n        pContext->TXPath.GetFreeHWBuffers()));\n#endif\n    DPrintf(0, (\"[Diag!] Bytes transmitted %I64u, received %I64u\\n\",\n        pContext->Statistics.ifHCOutOctets,\n        pContext->Statistics.ifHCInOctets));\n    DPrintf(0, (\"[Diag!] Tx frames %I64u, CSO %d, LSO %d, indirect %d\\n\",\n        totalTxFrames,\n        pContext->extraStatistics.framesCSOffload,\n        pContext->extraStatistics.framesLSO,\n        pContext->extraStatistics.framesIndirect));\n    DPrintf(0, (\"[Diag!] Rx frames %I64u, Rx.Pri %d, RxHwCS.OK %d, FiltOut %d\\n\",\n        totalRxFrames, pContext->extraStatistics.framesRxPriority,\n        pContext->extraStatistics.framesRxCSHwOK, pContext->extraStatistics.framesFilteredOut));\n    if (pContext->extraStatistics.framesRxCSHwMissedBad || pContext->extraStatistics.framesRxCSHwMissedGood)\n    {\n        DPrintf(0, (\"[Diag!] RxHwCS mistakes: missed bad %d, missed good %d\\n\",\n            pContext->extraStatistics.framesRxCSHwMissedBad, pContext->extraStatistics.framesRxCSHwMissedGood));\n    }\n}\n\nstatic\nVOID InitializeRSCState(PPARANDIS_ADAPTER pContext)\n{\n#if PARANDIS_SUPPORT_RSC\n\n    pContext->RSC.bIPv4Enabled = FALSE;\n    pContext->RSC.bIPv6Enabled = FALSE;\n\n    if(!pContext->bGuestChecksumSupported)\n    {\n        DPrintf(0, (\"[%s] Guest TSO cannot be enabled without guest checksum\\n\", __FUNCTION__) );\n        return;\n    }\n\n    if(pContext->RSC.bIPv4SupportedSW)\n    {\n        pContext->RSC.bIPv4Enabled =\n            pContext->RSC.bIPv4SupportedHW =\n                AckFeature(pContext, VIRTIO_NET_F_GUEST_TSO4);\n    }\n    else\n    {\n        pContext->RSC.bIPv4SupportedHW =\n            VirtIOIsFeatureEnabled(pContext->u32HostFeatures, VIRTIO_NET_F_GUEST_TSO4);\n    }\n\n    if(pContext->RSC.bIPv6SupportedSW)\n    {\n        pContext->RSC.bIPv6Enabled =\n            pContext->RSC.bIPv6SupportedHW =\n                AckFeature(pContext, VIRTIO_NET_F_GUEST_TSO6);\n    }\n    else\n    {\n        pContext->RSC.bIPv6SupportedHW =\n            VirtIOIsFeatureEnabled(pContext->u32HostFeatures, VIRTIO_NET_F_GUEST_TSO6);\n    }\n\n    pContext->RSC.bHasDynamicConfig = (pContext->RSC.bIPv4Enabled || pContext->RSC.bIPv6Enabled) &&\n                                      AckFeature(pContext, VIRTIO_NET_F_CTRL_GUEST_OFFLOADS);\n\n    DPrintf(0, (\"[%s] Guest TSO state: IP4=%d, IP6=%d, Dynamic=%d\\n\", __FUNCTION__,\n        pContext->RSC.bIPv4Enabled, pContext->RSC.bIPv6Enabled, pContext->RSC.bHasDynamicConfig) );\n#else\n    UNREFERENCED_PARAMETER(pContext);\n#endif\n}\n\nstatic __inline void\nDumpMac(int dbg_level, const char* header_str, UCHAR* mac)\n{\n    DPrintf(dbg_level,(\"%s: %02x-%02x-%02x-%02x-%02x-%02x\\n\",\n        header_str, mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]));\n\n}\n\nstatic __inline void\nSetDeviceMAC(PPARANDIS_ADAPTER pContext, PUCHAR pDeviceMAC)\n{\n    if(pContext->bCfgMACAddrSupported && !pContext->bCtrlMACAddrSupported)\n    {\n        VirtIODeviceSet(pContext->IODevice, 0, pDeviceMAC, ETH_LENGTH_OF_ADDRESS);\n    }\n}\n\nstatic void\nInitializeMAC(PPARANDIS_ADAPTER pContext, PUCHAR pCurrentMAC)\n{\n    //Acknowledge related features\n    pContext->bCfgMACAddrSupported = AckFeature(pContext, VIRTIO_NET_F_MAC);\n    pContext->bCtrlMACAddrSupported = AckFeature(pContext, VIRTIO_NET_F_CTRL_MAC_ADDR);\n\n    //Read and validate permanent MAC address\n    if (pContext->bCfgMACAddrSupported)\n    {\n        VirtIODeviceGet(pContext->IODevice, 0, &pContext->PermanentMacAddress, ETH_LENGTH_OF_ADDRESS);\n        if (!ParaNdis_ValidateMacAddress(pContext->PermanentMacAddress, FALSE))\n        {\n            DumpMac(0, \"Invalid device MAC ignored\", pContext->PermanentMacAddress);\n            NdisZeroMemory(pContext->PermanentMacAddress, sizeof(pContext->PermanentMacAddress));\n        }\n    }\n\n    if (ETH_IS_EMPTY(pContext->PermanentMacAddress))\n    {\n        pContext->PermanentMacAddress[0] = 0x02;\n        pContext->PermanentMacAddress[1] = 0x50;\n        pContext->PermanentMacAddress[2] = 0xF2;\n        pContext->PermanentMacAddress[3] = 0x00;\n        pContext->PermanentMacAddress[4] = 0x01;\n        pContext->PermanentMacAddress[5] = 0x80 | (UCHAR)(pContext->ulUniqueID & 0xFF);\n        DumpMac(0, \"No device MAC present, use default\", pContext->PermanentMacAddress);\n    }\n    DumpMac(0, \"Permanent device MAC\", pContext->PermanentMacAddress);\n\n    //Read and validate configured MAC address\n    if (ParaNdis_ValidateMacAddress(pCurrentMAC, TRUE))\n    {\n        DPrintf(0, (\"[%s] MAC address from configuration used\\n\", __FUNCTION__));\n        ETH_COPY_NETWORK_ADDRESS(pContext->CurrentMacAddress, pCurrentMAC);\n    }\n    else\n    {\n        DPrintf(0, (\"No valid MAC configured\\n\", __FUNCTION__));\n        ETH_COPY_NETWORK_ADDRESS(pContext->CurrentMacAddress, pContext->PermanentMacAddress);\n    }\n\n    //If control channel message for MAC address configuration is not supported\n    //  Configure device with actual MAC address via configurations space\n    //Else actual MAC address will be configured later via control queue\n    SetDeviceMAC(pContext, pContext->CurrentMacAddress);\n\n    DumpMac(0, \"Actual MAC\", pContext->CurrentMacAddress);\n}\n\nstatic __inline void\nRestoreMAC(PPARANDIS_ADAPTER pContext)\n{\n    SetDeviceMAC(pContext, pContext->PermanentMacAddress);\n}\n\n/**********************************************************\nInitializes the context structure\nMajor variables, received from NDIS on initialization, must be be set before this call\n(for ex. pContext->MiniportHandle)\n\nIf this procedure fails, no need to call\n    ParaNdis_CleanupContext\n\n\nParameters:\nReturn value:\n    SUCCESS, if resources are OK\n    NDIS_STATUS_RESOURCE_CONFLICT if not\n***********************************************************/\nNDIS_STATUS ParaNdis_InitializeContext(\n    PARANDIS_ADAPTER *pContext,\n    PNDIS_RESOURCE_LIST pResourceList)\n{\n    NDIS_STATUS status = NDIS_STATUS_SUCCESS;\n    USHORT linkStatus = 0;\n    UCHAR CurrentMAC[ETH_LENGTH_OF_ADDRESS] = {0};\n    ULONG dependentOptions;\n\n    DEBUG_ENTRY(0);\n\n    ReadNicConfiguration(pContext, CurrentMAC);\n\n    pContext->fCurrentLinkState = MediaConnectStateUnknown;\n    pContext->powerState = NdisDeviceStateUnspecified;\n\n    pContext->MaxPacketSize.nMaxFullSizeOS = pContext->MaxPacketSize.nMaxDataSize + ETH_HEADER_SIZE;\n    pContext->MaxPacketSize.nMaxFullSizeHwTx = pContext->MaxPacketSize.nMaxFullSizeOS;\n#if PARANDIS_SUPPORT_RSC\n    pContext->MaxPacketSize.nMaxDataSizeHwRx = MAX_HW_RX_PACKET_SIZE;\n    pContext->MaxPacketSize.nMaxFullSizeOsRx = MAX_OS_RX_PACKET_SIZE;\n#else\n    pContext->MaxPacketSize.nMaxDataSizeHwRx = pContext->MaxPacketSize.nMaxFullSizeOS + ETH_PRIORITY_HEADER_SIZE;\n    pContext->MaxPacketSize.nMaxFullSizeOsRx = pContext->MaxPacketSize.nMaxFullSizeOS;\n#endif\n    if (pContext->ulPriorityVlanSetting)\n        pContext->MaxPacketSize.nMaxFullSizeHwTx = pContext->MaxPacketSize.nMaxFullSizeOS + ETH_PRIORITY_HEADER_SIZE;\n\n    if (GetAdapterResources(pResourceList, &pContext->AdapterResources) &&\n        NDIS_STATUS_SUCCESS == NdisMRegisterIoPortRange(\n            &pContext->pIoPortOffset,\n            pContext->MiniportHandle,\n            pContext->AdapterResources.ulIOAddress,\n            pContext->AdapterResources.IOLength)\n        )\n    {\n        if (pContext->AdapterResources.InterruptFlags & CM_RESOURCE_INTERRUPT_MESSAGE)\n        {\n            DPrintf(0, (\"[%s] Message interrupt assigned\\n\", __FUNCTION__));\n            pContext->bUsingMSIX = TRUE;\n        }\n\n        VirtIODeviceInitialize(pContext->IODevice, pContext->AdapterResources.ulIOAddress, sizeof(*pContext->IODevice));\n        VirtIODeviceSetMSIXUsed(pContext->IODevice, pContext->bUsingMSIX ? true : false);\n        ParaNdis_ResetVirtIONetDevice(pContext);\n        VirtIODeviceAddStatus(pContext->IODevice, VIRTIO_CONFIG_S_ACKNOWLEDGE);\n        VirtIODeviceAddStatus(pContext->IODevice, VIRTIO_CONFIG_S_DRIVER);\n        pContext->u32HostFeatures = VirtIODeviceReadHostFeatures(pContext->IODevice);\n        DumpVirtIOFeatures(pContext);\n\n        pContext->bLinkDetectSupported = AckFeature(pContext, VIRTIO_NET_F_STATUS);\n        if(pContext->bLinkDetectSupported) {\n            VirtIODeviceGet(pContext->IODevice, ETH_LENGTH_OF_ADDRESS, &linkStatus, sizeof(linkStatus));\n            pContext->bConnected = (linkStatus & VIRTIO_NET_S_LINK_UP) != 0;\n            DPrintf(0, (\"[%s] Link status on driver startup: %d\\n\", __FUNCTION__, pContext->bConnected));\n        }\n\n        InitializeMAC(pContext, CurrentMAC);\n\n        pContext->bUseMergedBuffers = AckFeature(pContext, VIRTIO_NET_F_MRG_RXBUF);\n        pContext->nVirtioHeaderSize = (pContext->bUseMergedBuffers) ? sizeof(virtio_net_hdr_ext) : sizeof(virtio_net_hdr_basic);\n        pContext->bDoPublishIndices = AckFeature(pContext, VIRTIO_RING_F_EVENT_IDX);\n    }\n    else\n    {\n        DPrintf(0, (\"[%s] Error: Incomplete resources\\n\", __FUNCTION__));\n        /* avoid deregistering if failed */\n        pContext->AdapterResources.ulIOAddress = 0;\n        status = NDIS_STATUS_RESOURCE_CONFLICT;\n    }\n\n    pContext->bMultiQueue = AckFeature(pContext, VIRTIO_NET_F_CTRL_MQ);\n    if (pContext->bMultiQueue)\n    {\n        VirtIODeviceGet(pContext->IODevice, ETH_LENGTH_OF_ADDRESS + sizeof(USHORT), &pContext->nHardwareQueues,\n            sizeof(pContext->nHardwareQueues));\n    }\n    else\n    {\n        pContext->nHardwareQueues = 1;\n    }\n\n    dependentOptions = osbT4TcpChecksum | osbT4UdpChecksum | osbT4TcpOptionsChecksum;\n\n    if((pContext->Offload.flagsValue & dependentOptions) && !AckFeature(pContext, VIRTIO_NET_F_CSUM))\n    {\n        DPrintf(0, (\"[%s] Host does not support CSUM, disabling CS offload\\n\", __FUNCTION__) );\n        pContext->Offload.flagsValue &= ~dependentOptions;\n    }\n\n    pContext->bGuestChecksumSupported = AckFeature(pContext, VIRTIO_NET_F_GUEST_CSUM);\n    AckFeature(pContext, VIRTIO_NET_F_CTRL_VQ);\n\n    InitializeRSCState(pContext);\n\n    // now, after we checked the capabilities, we can initialize current\n    // configuration of offload tasks\n    ParaNdis_ResetOffloadSettings(pContext, NULL, NULL);\n\n    if (pContext->Offload.flags.fTxLso && !AckFeature(pContext, VIRTIO_NET_F_HOST_TSO4))\n    {\n        DisableLSOv4Permanently(pContext, __FUNCTION__, \"Host does not support TSOv4\\n\");\n    }\n\n    if (pContext->Offload.flags.fTxLsov6 && !AckFeature(pContext, VIRTIO_NET_F_HOST_TSO6))\n    {\n        DisableLSOv6Permanently(pContext, __FUNCTION__, \"Host does not support TSOv6\");\n    }\n\n    pContext->bUseIndirect = AckFeature(pContext, VIRTIO_F_INDIRECT);\n    pContext->bAnyLaypout = AckFeature(pContext, VIRTIO_F_ANY_LAYOUT);\n\n    pContext->bHasHardwareFilters = AckFeature(pContext, VIRTIO_NET_F_CTRL_RX_EXTRA);\n\n    InterlockedExchange(&pContext->ReuseBufferRegular, TRUE);\n\n    VirtIODeviceWriteGuestFeatures(pContext->IODevice, pContext->u32GuestFeatures);\n    NdisInitializeEvent(&pContext->ResetEvent);\n    DEBUG_EXIT_STATUS(0, status);\n    return status;\n}\n\nvoid ParaNdis_FreeRxBufferDescriptor(PARANDIS_ADAPTER *pContext, pRxNetDescriptor p)\n{\n    ULONG i;\n    for(i = 0; i < p->PagesAllocated; i++)\n    {\n        ParaNdis_FreePhysicalMemory(pContext, &p->PhysicalPages[i]);\n    }\n\n    if(p->BufferSGArray) NdisFreeMemory(p->BufferSGArray, 0, 0);\n    if(p->PhysicalPages) NdisFreeMemory(p->PhysicalPages, 0, 0);\n    NdisFreeMemory(p, 0, 0);\n}\n\n/**********************************************************\nAllocates maximum RX buffers for incoming packets\nBuffers are chained in NetReceiveBuffers\nParameters:\n    context\n***********************************************************/\n\nvoid ParaNdis_DeleteQueue(PARANDIS_ADAPTER *pContext, struct virtqueue **ppq, tCompletePhysicalAddress *ppa)\n{\n    if (*ppq) VirtIODeviceDeleteQueue(*ppq, NULL);\n    *ppq = NULL;\n    if (ppa->Virtual) ParaNdis_FreePhysicalMemory(pContext, ppa);\n    RtlZeroMemory(ppa, sizeof(*ppa));\n}\n\n#if PARANDIS_SUPPORT_RSS\nstatic USHORT DetermineQueueNumber(PARANDIS_ADAPTER *pContext)\n{\n    if (!pContext->bUsingMSIX)\n    {\n        DPrintf(0, (\"[%s] No MSIX, using 1 queue\\n\", __FUNCTION__));\n        return 1;\n    }\n\n    if (pContext->bMultiQueue)\n    {\n        DPrintf(0, (\"[%s] Number of hardware queues = %d\\n\", __FUNCTION__, pContext->nHardwareQueues));\n    }\n    else\n    {\n        DPrintf(0, (\"[%s] - CTRL_MQ not acked, # bindles set to 1\\n\", __FUNCTION__));\n        return 1;\n    }\n\n    ULONG lnProcessors;\n#if NDIS_SUPPORT_NDIS620\n    lnProcessors = NdisGroupActiveProcessorCount(ALL_PROCESSOR_GROUPS);\n#elif NDIS_SUPPORT_NDIS6\n    lnProcessors = NdisSystemProcessorCount();\n#else\n    lnProcessors = 1;\n#endif\n\n    ULONG lnMSIs = (pContext->pMSIXInfoTable->MessageCount - 1) / 2; /* RX/TX pairs + control queue*/\n\n    DPrintf(0, (\"[%s] %lu CPUs reported\\n\", __FUNCTION__, lnProcessors));\n    DPrintf(0, (\"[%s] %lu MSIs, %lu queues\\n\", __FUNCTION__, pContext->pMSIXInfoTable->MessageCount, lnMSIs));\n\n    USHORT nMSIs = USHORT(lnMSIs & 0xFFFF);\n    USHORT nProcessors = USHORT(lnProcessors & 0xFFFF);\n\n    DPrintf(0, (\"[%s] %u CPUs reported\\n\", __FUNCTION__, nProcessors));\n    DPrintf(0, (\"[%s] %lu MSIs, %u queues\\n\", __FUNCTION__, pContext->pMSIXInfoTable->MessageCount, nMSIs));\n\n    USHORT nBundles = (pContext->nHardwareQueues < nProcessors) ? pContext->nHardwareQueues : nProcessors;\n    nBundles = (nMSIs < nBundles) ? nMSIs : nBundles;\n\n    DPrintf(0, (\"[%s] # of path bundles = %u\\n\", __FUNCTION__, nBundles));\n\n    return nBundles;\n}\n#else\nstatic USHORT DetermineQueueNumber(PARANDIS_ADAPTER *)\n{\n    return 1;\n}\n#endif\n\nstatic NDIS_STATUS SetupDPCTarget(PARANDIS_ADAPTER *pContext)\n{\n    ULONG i;\n#if NDIS_SUPPORT_NDIS620\n    NDIS_STATUS status;\n    PROCESSOR_NUMBER procNumber;\n#endif\n\n    for (i = 0; i < pContext->nPathBundles; i++)\n    {\n#if NDIS_SUPPORT_NDIS620\n        status = KeGetProcessorNumberFromIndex(i, &procNumber);\n        if (status != NDIS_STATUS_SUCCESS)\n        {\n            DPrintf(0, (\"[%s] - KeGetProcessorNumberFromIndex failed for index %lu - %d\\n\", __FUNCTION__, i, status));\n            return status;\n        }\n        ParaNdis_ProcessorNumberToGroupAffinity(&pContext->pPathBundles[i].rxPath.DPCAffinity, &procNumber);\n        pContext->pPathBundles[i].txPath.DPCAffinity = pContext->pPathBundles[i].rxPath.DPCAffinity;\n#elif NDIS_SUPPORT_NDIS6\n        pContext->pPathBundles[i].rxPath.DPCTargetProcessor = 1i64 << i;\n        pContext->pPathBundles[i].txPath.DPCTargetProcessor = pContext->pPathBundles[i].rxPath.DPCTargetProcessor;\n#else\n#error not supported\n#endif\n    }\n\n#if NDIS_SUPPORT_NDIS620\n    pContext->CXPath.DPCAffinity = pContext->pPathBundles[0].rxPath.DPCAffinity;\n#elif NDIS_SUPPORT_NDIS6\n    pContext->CXPath.DPCTargetProcessor = pContext->pPathBundles[0].rxPath.DPCTargetProcessor;\n#else\n#error not yet defined\n#endif\n    return NDIS_STATUS_SUCCESS;\n}\n\n#if PARANDIS_SUPPORT_RSS\nNDIS_STATUS ParaNdis_SetupRSSQueueMap(PARANDIS_ADAPTER *pContext)\n{\n    USHORT rssIndex, bundleIndex;\n    ULONG cpuIndex;\n    ULONG rssTableSize = pContext->RSSParameters.RSSScalingSettings.IndirectionTableSize / sizeof(PROCESSOR_NUMBER);\n\n    rssIndex = 0;\n    bundleIndex = 0;\n    USHORT *cpuIndexTable;\n    ULONG cpuNumbers;\n\n    cpuNumbers = KeQueryActiveProcessorCountEx(ALL_PROCESSOR_GROUPS);\n\n    cpuIndexTable = (USHORT *)NdisAllocateMemoryWithTagPriority(pContext->MiniportHandle, cpuNumbers * sizeof(*cpuIndexTable),\n        PARANDIS_MEMORY_TAG, NormalPoolPriority);\n    if (cpuIndexTable == nullptr)\n    {\n        DPrintf(0, (\"[%s] cpu index table allocation failed\\n\", __FUNCTION__));\n        return NDIS_STATUS_RESOURCES;\n    }\n\n    NdisZeroMemory(cpuIndexTable, sizeof(*cpuIndexTable) * cpuNumbers);\n\n    for (bundleIndex = 0; bundleIndex < pContext->nPathBundles; ++bundleIndex)\n    {\n        cpuIndex = pContext->pPathBundles[bundleIndex].rxPath.getCPUIndex();\n        if (cpuIndex == INVALID_PROCESSOR_INDEX)\n        {\n            DPrintf(0, (\"[%s]  Invalid CPU index for path %u\\n\", __FUNCTION__, bundleIndex));\n            NdisFreeMemoryWithTagPriority(pContext->MiniportHandle, cpuIndexTable, PARANDIS_MEMORY_TAG);\n            return NDIS_STATUS_SOFT_ERRORS;\n        }\n        else if (cpuIndex >= cpuNumbers)\n        {\n            DPrintf(0, (\"[%s]  CPU index %lu exceeds CPU range %lu\\n\", __FUNCTION__, cpuIndex, cpuNumbers));\n            NdisFreeMemoryWithTagPriority(pContext->MiniportHandle, cpuIndexTable, PARANDIS_MEMORY_TAG);\n            return NDIS_STATUS_SOFT_ERRORS;\n        }\n        else\n        {\n            cpuIndexTable[cpuIndex] = bundleIndex;\n        }\n    }\n\n    DPrintf(0, (\"[%s] Entering, RSS table size = %lu, # of path bundles = %u. RSS2QueueLength = %u, RSS2QueueMap =0x%p\\n\",\n        __FUNCTION__, rssTableSize, pContext->nPathBundles,\n        pContext->RSS2QueueLength, pContext->RSS2QueueMap));\n\n    if (pContext->RSS2QueueLength && pContext->RSS2QueueLength < rssTableSize)\n    {\n        DPrintf(0, (\"[%s] Freeing RSS2Queue Map\\n\", __FUNCTION__));\n        NdisFreeMemoryWithTagPriority(pContext->MiniportHandle, pContext->RSS2QueueMap, PARANDIS_MEMORY_TAG);\n        pContext->RSS2QueueLength = 0;\n    }\n\n    if (!pContext->RSS2QueueLength)\n    {\n        pContext->RSS2QueueLength = USHORT(rssTableSize);\n        pContext->RSS2QueueMap = (CPUPathesBundle **)NdisAllocateMemoryWithTagPriority(pContext->MiniportHandle, rssTableSize * sizeof(*pContext->RSS2QueueMap),\n            PARANDIS_MEMORY_TAG, NormalPoolPriority);\n        if (pContext->RSS2QueueMap == nullptr)\n        {\n            DPrintf(0, (\"[%s] - Allocating RSS to queue mapping failed\\n\", __FUNCTION__));\n            NdisFreeMemoryWithTagPriority(pContext->MiniportHandle, cpuIndexTable, PARANDIS_MEMORY_TAG);\n            return NDIS_STATUS_RESOURCES;\n        }\n\n        NdisZeroMemory(pContext->RSS2QueueMap, sizeof(*pContext->RSS2QueueMap) * pContext->RSS2QueueLength);\n    }\n\n    for (rssIndex = 0; rssIndex < rssTableSize; rssIndex++)\n    {\n       pContext->RSS2QueueMap[rssIndex] = pContext->pPathBundles;\n    }\n\n    for (rssIndex = 0; rssIndex < rssTableSize; rssIndex++)\n    {\n        cpuIndex = NdisProcessorNumberToIndex(pContext->RSSParameters.RSSScalingSettings.IndirectionTable[rssIndex]);\n        bundleIndex = cpuIndexTable[cpuIndex];\n\n        DPrintf(3, (\"[%s] filling the relationship, rssIndex = %u, bundleIndex = %u\\n\", __FUNCTION__, rssIndex, bundleIndex));\n        DPrintf(3, (\"[%s] RSS proc number %u/%u, bundle affinity %u/%u\\n\", __FUNCTION__,\n            pContext->RSSParameters.RSSScalingSettings.IndirectionTable[rssIndex].Group,\n            pContext->RSSParameters.RSSScalingSettings.IndirectionTable[rssIndex].Number,\n            pContext->pPathBundles[bundleIndex].txPath.DPCAffinity.Group,\n            pContext->pPathBundles[bundleIndex].txPath.DPCAffinity.Mask));\n\n        pContext->RSS2QueueMap[rssIndex] = pContext->pPathBundles + bundleIndex;\n    }\n\n    NdisFreeMemoryWithTagPriority(pContext->MiniportHandle, cpuIndexTable, PARANDIS_MEMORY_TAG);\n    return NDIS_STATUS_SUCCESS;\n}\n#endif\n\n/**********************************************************\nInitializes VirtIO buffering and related stuff:\nAllocates RX and TX queues and buffers\nParameters:\n    context\nReturn value:\n    TRUE if both queues are allocated\n***********************************************************/\nstatic NDIS_STATUS ParaNdis_VirtIONetInit(PARANDIS_ADAPTER *pContext)\n{\n    NDIS_STATUS status = NDIS_STATUS_RESOURCES;\n    DEBUG_ENTRY(0);\n    UINT i;\n    USHORT nVirtIOQueues = pContext->nHardwareQueues * 2 + 2;\n\n    pContext->nPathBundles = DetermineQueueNumber(pContext);\n    if (pContext->nPathBundles == 0)\n    {\n        DPrintf(0, (\"[%s] - no I/O pathes\\n\", __FUNCTION__));\n        return NDIS_STATUS_RESOURCES;\n    }\n\n    if (nVirtIOQueues > pContext->IODevice->maxQueues)\n    {\n        ULONG IODeviceSize = VirtIODeviceSizeRequired(nVirtIOQueues);\n\n        NdisFreeMemoryWithTagPriority(pContext->MiniportHandle, pContext->IODevice, PARANDIS_MEMORY_TAG);\n        pContext->IODevice = (VirtIODevice *)NdisAllocateMemoryWithTagPriority(\n            pContext->MiniportHandle,\n            IODeviceSize,\n            PARANDIS_MEMORY_TAG,\n            NormalPoolPriority);\n        if (pContext->IODevice == nullptr)\n        {\n            DPrintf(0, (\"[%s] - IODevice allocation failed\\n\", __FUNCTION__));\n            return NDIS_STATUS_RESOURCES;\n        }\n\n        VirtIODeviceInitialize(pContext->IODevice, pContext->AdapterResources.ulIOAddress, IODeviceSize);\n        VirtIODeviceSetMSIXUsed(pContext->IODevice, pContext->bUsingMSIX ? true : false);\n        DPrintf(0, (\"[%s] %u queues' slots reallocated for size %lu\\n\", __FUNCTION__, pContext->IODevice->maxQueues, IODeviceSize));\n    }\n\n    new (&pContext->CXPath, PLACEMENT_NEW) CParaNdisCX();\n    pContext->bCXPathAllocated = TRUE;\n    if (!pContext->CXPath.Create(pContext, 2 * pContext->nHardwareQueues))\n    {\n        DPrintf(0, (\"[%s] The Control vQueue does not work!\\n\", __FUNCTION__));\n        pContext->bHasHardwareFilters = FALSE;\n        pContext->bCtrlMACAddrSupported = FALSE;\n    }\n    else\n    {\n        pContext->bCXPathCreated = TRUE;\n    }\n\n    pContext->pPathBundles = (CPUPathesBundle *)NdisAllocateMemoryWithTagPriority(pContext->MiniportHandle, pContext->nPathBundles * sizeof(*pContext->pPathBundles),\n        PARANDIS_MEMORY_TAG, NormalPoolPriority);\n    if (pContext->pPathBundles == nullptr)\n    {\n        DPrintf(0, (\"[%s] Path bundles allocation failed\\n\", __FUNCTION__));\n        return status;\n    }\n\n    for (i = 0; i < pContext->nPathBundles; i++)\n    {\n        new (pContext->pPathBundles + i, PLACEMENT_NEW) CPUPathesBundle();\n\n        if (!pContext->pPathBundles[i].rxPath.Create(pContext, i * 2))\n        {\n            DPrintf(0, (\"%s: CParaNdisRX creation failed\\n\", __FUNCTION__));\n            return status;\n        }\n        pContext->pPathBundles[i].rxCreated = true;\n\n        if (!pContext->pPathBundles[i].txPath.Create(pContext, i * 2 + 1))\n        {\n            DPrintf(0, (\"%s: CParaNdisTX creation failed\\n\", __FUNCTION__));\n            return status;\n        }\n        pContext->pPathBundles[i].txCreated = true;\n    }\n\n    if (pContext->bCXPathCreated)\n    {\n        pContext->pPathBundles[0].cxPath = &pContext->CXPath;\n    }\n\n    status = NDIS_STATUS_SUCCESS;\n\n    return status;\n}\n\nstatic void ReadLinkState(PARANDIS_ADAPTER *pContext)\n{\n    if (pContext->bLinkDetectSupported)\n    {\n        USHORT linkStatus = 0;\n        VirtIODeviceGet(pContext->IODevice, ETH_LENGTH_OF_ADDRESS, &linkStatus, sizeof(linkStatus));\n        pContext->bConnected = !!(linkStatus & VIRTIO_NET_S_LINK_UP);\n    }\n    else\n    {\n        pContext->bConnected = TRUE;\n    }\n}\n\nstatic void ParaNdis_RemoveDriverOKStatus(PPARANDIS_ADAPTER pContext )\n{\n    VirtIODeviceRemoveStatus(pContext->IODevice, VIRTIO_CONFIG_S_DRIVER_OK);\n\n    KeMemoryBarrier();\n\n    pContext->bDeviceInitialized = FALSE;\n}\n\nstatic VOID ParaNdis_AddDriverOKStatus(PPARANDIS_ADAPTER pContext)\n{\n    pContext->bDeviceInitialized = TRUE;\n\n    KeMemoryBarrier();\n\n    VirtIODeviceAddStatus(pContext->IODevice, VIRTIO_CONFIG_S_DRIVER_OK);\n}\n\n/**********************************************************\nFinishes initialization of context structure, calling also version dependent part\nIf this procedure failed, ParaNdis_CleanupContext must be called\nParameters:\n    context\nReturn value:\n    SUCCESS or some kind of failure\n***********************************************************/\nNDIS_STATUS ParaNdis_FinishInitialization(PARANDIS_ADAPTER *pContext)\n{\n    NDIS_STATUS status = NDIS_STATUS_SUCCESS;\n    DEBUG_ENTRY(0);\n\n    status = ParaNdis_FinishSpecificInitialization(pContext);\n    DPrintf(0, (\"[%s] ParaNdis_FinishSpecificInitialization passed, status = %d\\n\", __FUNCTION__, status));\n\n\n    if (status == NDIS_STATUS_SUCCESS)\n    {\n        status = ParaNdis_VirtIONetInit(pContext);\n        DPrintf(0, (\"[%s] ParaNdis_VirtIONetInit passed, status = %d\\n\", __FUNCTION__, status));\n    }\n\n    if (status == NDIS_STATUS_SUCCESS)\n    {\n        status = ParaNdis_ConfigureMSIXVectors(pContext);\n        DPrintf(0, (\"[%s] ParaNdis_VirtIONetInit passed, status = %d\\n\", __FUNCTION__, status));\n    }\n\n    if (status == NDIS_STATUS_SUCCESS)\n    {\n        status = SetupDPCTarget(pContext);\n        DPrintf(0, (\"[%s] SetupDPCTarget passed, status = %d\\n\", __FUNCTION__, status));\n    }\n\n    if (status == NDIS_STATUS_SUCCESS && pContext->nPathBundles > 1)\n    {\n        u16 nPathes = u16(pContext->nPathBundles);\n        BOOLEAN sendSuccess = pContext->CXPath.SendControlMessage(VIRTIO_NET_CTRL_MQ, VIRTIO_NET_CTRL_MQ_VQ_PAIR_SET, &nPathes, sizeof(nPathes), NULL, 0, 2);\n        if (!sendSuccess)\n        {\n            DPrintf(0, (\"[%s] - Send MQ control message failed\\n\", __FUNCTION__));\n            status = NDIS_STATUS_DEVICE_FAILED;\n        }\n    }\n\n    pContext->Limits.nReusedRxBuffers = pContext->NetMaxReceiveBuffers / 4 + 1;\n\n    if (status == NDIS_STATUS_SUCCESS)\n    {\n        ReadLinkState(pContext);\n        pContext->bEnableInterruptHandlingDPC = TRUE;\n        ParaNdis_SetPowerState(pContext, NdisDeviceStateD0);\n        ParaNdis_SynchronizeLinkState(pContext);\n        ParaNdis_AddDriverOKStatus(pContext);\n        ParaNdis_UpdateMAC(pContext);\n    }\n    DEBUG_EXIT_STATUS(0, status);\n    return status;\n}\n\n/**********************************************************\nReleases VirtIO related resources - queues and buffers\nParameters:\n    context\nReturn value:\n***********************************************************/\nstatic void VirtIONetRelease(PARANDIS_ADAPTER *pContext)\n{\n    BOOLEAN b;\n    ULONG i;\n    DEBUG_ENTRY(0);\n\n    /* list NetReceiveBuffersWaiting must be free */\n\n    for (i = 0; i < ARRAYSIZE(pContext->ReceiveQueues); i++)\n    {\n        pRxNetDescriptor pBufferDescriptor;\n\n        while (NULL != (pBufferDescriptor = ReceiveQueueGetBuffer(pContext->ReceiveQueues + i)))\n        {\n            pBufferDescriptor->Queue->ReuseReceiveBuffer(FALSE, pBufferDescriptor);\n        }\n    }\n\n    do\n    {\n        b = pContext->m_upstreamPacketPending != 0;\n\n        if (b)\n        {\n            DPrintf(0, (\"[%s] There are waiting buffers\\n\", __FUNCTION__));\n            PrintStatistics(pContext);\n            NdisMSleep(5000000);\n        }\n    } while (b);\n\n    RestoreMAC(pContext);\n\n    for (i = 0; i < pContext->nPathBundles; i++)\n    {\n        if (pContext->pPathBundles[i].txCreated)\n        {\n            pContext->pPathBundles[i].txPath.Shutdown();\n        }\n\n        if (pContext->pPathBundles[i].rxCreated)\n        {\n            pContext->pPathBundles[i].rxPath.Shutdown();\n\n            /* this can be freed, queue shut down */\n            pContext->pPathBundles[i].rxPath.FreeRxDescriptorsFromList();\n        }\n    }\n\n    if (pContext->bCXPathCreated)\n    {\n        pContext->CXPath.Shutdown();\n    }\n\n    PrintStatistics(pContext);\n}\n\nstatic void PreventDPCServicing(PARANDIS_ADAPTER *pContext)\n{\n    LONG inside;\n    pContext->bEnableInterruptHandlingDPC = FALSE;\n    KeMemoryBarrier();\n    do\n    {\n        inside = InterlockedIncrement(&pContext->counterDPCInside);\n        InterlockedDecrement(&pContext->counterDPCInside);\n        if (inside > 1)\n        {\n            DPrintf(0, (\"[%s] waiting!\\n\", __FUNCTION__));\n            NdisMSleep(20000);\n        }\n    } while (inside > 1);\n}\n\n/**********************************************************\nFrees all the resources allocated when the context initialized,\n    calling also version-dependent part\nParameters:\n    context\n***********************************************************/\nVOID ParaNdis_CleanupContext(PARANDIS_ADAPTER *pContext)\n{\n    /* disable any interrupt generation */\n    if (pContext->IODevice->addr)\n    {\n        if (pContext->bDeviceInitialized)\n        {\n            ParaNdis_RemoveDriverOKStatus(pContext);\n        }\n    }\n\n    PreventDPCServicing(pContext);\n\n    /****************************************\n    ensure all the incoming packets returned,\n    free all the buffers and their descriptors\n    *****************************************/\n\n    if (pContext->IODevice->addr)\n    {\n        ParaNdis_ResetVirtIONetDevice(pContext);\n    }\n\n    ParaNdis_SetPowerState(pContext, NdisDeviceStateD3);\n    ParaNdis_SetLinkState(pContext, MediaConnectStateUnknown);\n    VirtIONetRelease(pContext);\n\n    ParaNdis_FinalizeCleanup(pContext);\n\n    if (pContext->ReceiveQueuesInitialized)\n    {\n        ULONG i;\n\n        for(i = 0; i < ARRAYSIZE(pContext->ReceiveQueues); i++)\n        {\n            NdisFreeSpinLock(&pContext->ReceiveQueues[i].Lock);\n        }\n    }\n\n    pContext->m_PauseLock.~CNdisRWLock();\n\n#if PARANDIS_SUPPORT_RSS\n    if (pContext->bRSSInitialized)\n    {\n        ParaNdis6_RSSCleanupConfiguration(&pContext->RSSParameters);\n    }\n\n    pContext->RSSParameters.rwLock.~CNdisRWLock();\n#endif\n\n    if (pContext->bCXPathAllocated)\n    {\n        pContext->CXPath.~CParaNdisCX();\n        pContext->bCXPathAllocated = false;\n    }\n\n    if (pContext->pPathBundles != NULL)\n    {\n        USHORT i;\n\n        for (i = 0; i < pContext->nPathBundles; i++)\n        {\n            pContext->pPathBundles[i].~CPUPathesBundle();\n        }\n        NdisFreeMemoryWithTagPriority(pContext->MiniportHandle, pContext->pPathBundles, PARANDIS_MEMORY_TAG);\n        pContext->pPathBundles = nullptr;\n    }\n\n    if (pContext->RSS2QueueMap)\n    {\n        NdisFreeMemoryWithTagPriority(pContext->MiniportHandle, pContext->RSS2QueueMap, PARANDIS_MEMORY_TAG);\n        pContext->RSS2QueueMap = nullptr;\n        pContext->RSS2QueueLength = 0;\n    }\n\n    if (pContext->IODevice)\n    {\n        NdisFreeMemoryWithTagPriority(pContext->MiniportHandle, pContext->IODevice, PARANDIS_MEMORY_TAG);\n        pContext->IODevice = nullptr;\n    }\n\n    if (pContext->AdapterResources.ulIOAddress)\n    {\n        NdisMDeregisterIoPortRange(\n            pContext->MiniportHandle,\n            pContext->AdapterResources.ulIOAddress,\n            pContext->AdapterResources.IOLength,\n            pContext->pIoPortOffset);\n        pContext->AdapterResources.ulIOAddress = 0;\n    }\n}\n\n\n/**********************************************************\nSystem shutdown handler (shutdown, restart, bugcheck)\nParameters:\n    context\n***********************************************************/\nVOID ParaNdis_OnShutdown(PARANDIS_ADAPTER *pContext)\n{\n    DEBUG_ENTRY(0); // this is only for kdbg :)\n    ParaNdis_ResetVirtIONetDevice(pContext);\n}\n\nstatic ULONG ShallPassPacket(PARANDIS_ADAPTER *pContext, PNET_PACKET_INFO pPacketInfo)\n{\n    ULONG i;\n\n    if (pPacketInfo->dataLength > pContext->MaxPacketSize.nMaxFullSizeOsRx + ETH_PRIORITY_HEADER_SIZE)\n        return FALSE;\n\n    if ((pPacketInfo->dataLength > pContext->MaxPacketSize.nMaxFullSizeOsRx) && !pPacketInfo->hasVlanHeader)\n        return FALSE;\n\n    if (IsVlanSupported(pContext) && pPacketInfo->hasVlanHeader)\n    {\n        if (pContext->VlanId && pContext->VlanId != pPacketInfo->Vlan.VlanId)\n        {\n            return FALSE;\n        }\n    }\n\n    if (pContext->PacketFilter & NDIS_PACKET_TYPE_PROMISCUOUS)\n        return TRUE;\n\n    if(pPacketInfo->isUnicast)\n    {\n        ULONG Res;\n\n        if(!(pContext->PacketFilter & NDIS_PACKET_TYPE_DIRECTED))\n            return FALSE;\n\n        ETH_COMPARE_NETWORK_ADDRESSES_EQ(pPacketInfo->ethDestAddr, pContext->CurrentMacAddress, &Res);\n        return !Res;\n    }\n\n    if(pPacketInfo->isBroadcast)\n        return (pContext->PacketFilter & NDIS_PACKET_TYPE_BROADCAST);\n\n    // Multi-cast\n\n    if(pContext->PacketFilter & NDIS_PACKET_TYPE_ALL_MULTICAST)\n        return TRUE;\n\n    if(!(pContext->PacketFilter & NDIS_PACKET_TYPE_MULTICAST))\n        return FALSE;\n\n    for (i = 0; i < pContext->MulticastData.nofMulticastEntries; i++)\n    {\n        ULONG Res;\n        PUCHAR CurrMcastAddr = &pContext->MulticastData.MulticastList[i*ETH_LENGTH_OF_ADDRESS];\n\n        ETH_COMPARE_NETWORK_ADDRESSES_EQ(pPacketInfo->ethDestAddr, CurrMcastAddr, &Res);\n\n        if(!Res)\n            return TRUE;\n    }\n\n    return FALSE;\n}\n\nBOOLEAN ParaNdis_PerformPacketAnalyzis(\n#if PARANDIS_SUPPORT_RSS\n                            PPARANDIS_RSS_PARAMS RSSParameters,\n#endif\n                            PNET_PACKET_INFO PacketInfo,\n                            PVOID HeadersBuffer,\n                            ULONG DataLength)\n{\n    if(!ParaNdis_AnalyzeReceivedPacket(HeadersBuffer, DataLength, PacketInfo))\n        return FALSE;\n\n#if PARANDIS_SUPPORT_RSS\n    if(RSSParameters->RSSMode != PARANDIS_RSS_DISABLED)\n    {\n        ParaNdis6_RSSAnalyzeReceivedPacket(RSSParameters, HeadersBuffer, PacketInfo);\n    }\n#endif\n    return TRUE;\n}\n\nVOID ParaNdis_ProcessorNumberToGroupAffinity(PGROUP_AFFINITY Affinity, const PPROCESSOR_NUMBER Processor)\n{\n    Affinity->Group = Processor->Group;\n    Affinity->Mask = 1;\n    Affinity->Mask <<= Processor->Number;\n}\n\n\nCCHAR ParaNdis_GetScalingDataForPacket(PARANDIS_ADAPTER *pContext, PNET_PACKET_INFO pPacketInfo, PPROCESSOR_NUMBER pTargetProcessor)\n{\n#if PARANDIS_SUPPORT_RSS\n    return ParaNdis6_RSSGetScalingDataForPacket(&pContext->RSSParameters, pPacketInfo, pTargetProcessor);\n#else\n    UNREFERENCED_PARAMETER(pContext);\n    UNREFERENCED_PARAMETER(pPacketInfo);\n    UNREFERENCED_PARAMETER(pTargetProcessor);\n\n    return PARANDIS_RECEIVE_QUEUE_UNCLASSIFIED;\n#endif\n}\n\nstatic __inline\nCCHAR GetReceiveQueueForCurrentCPU(PARANDIS_ADAPTER *pContext)\n{\n#if PARANDIS_SUPPORT_RSS\n    return ParaNdis6_RSSGetCurrentCpuReceiveQueue(&pContext->RSSParameters);\n#else\n    UNREFERENCED_PARAMETER(pContext);\n\n    return PARANDIS_RECEIVE_QUEUE_UNCLASSIFIED;\n#endif\n}\n\nVOID ParaNdis_QueueRSSDpc(PARANDIS_ADAPTER *pContext, ULONG MessageIndex, PGROUP_AFFINITY pTargetAffinity)\n{\n#if PARANDIS_SUPPORT_RSS\n    NdisMQueueDpcEx(pContext->InterruptHandle, MessageIndex, pTargetAffinity, NULL);\n#else\n    UNREFERENCED_PARAMETER(pContext);\n    UNREFERENCED_PARAMETER(MessageIndex);\n    UNREFERENCED_PARAMETER(pTargetAffinity);\n\n    ASSERT(FALSE);\n#endif\n}\n\n\nVOID ParaNdis_ReceiveQueueAddBuffer(PPARANDIS_RECEIVE_QUEUE pQueue, pRxNetDescriptor pBuffer)\n{\n    NdisInterlockedInsertTailList(  &pQueue->BuffersList,\n                                    &pBuffer->ReceiveQueueListEntry,\n                                    &pQueue->Lock);\n}\n\nVOID ParaMdis_TestPausing(PARANDIS_ADAPTER *pContext)\n{\n    ONPAUSECOMPLETEPROC callback = nullptr;\n\n    if (pContext->m_upstreamPacketPending == 0)\n    {\n        CNdisPassiveWriteAutoLock tLock(pContext->m_PauseLock);\n\n        if (pContext->m_upstreamPacketPending == 0 && (pContext->ReceiveState == srsPausing || pContext->ReceivePauseCompletionProc))\n        {\n            callback = pContext->ReceivePauseCompletionProc;\n            pContext->ReceiveState = srsDisabled;\n            pContext->ReceivePauseCompletionProc = NULL;\n            ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 0, 0, 0);\n        }\n    }\n\n    if (callback) callback(pContext);\n}\n\nstatic __inline\npRxNetDescriptor ReceiveQueueGetBuffer(PPARANDIS_RECEIVE_QUEUE pQueue)\n{\n    PLIST_ENTRY pListEntry = NdisInterlockedRemoveHeadList(&pQueue->BuffersList, &pQueue->Lock);\n    return pListEntry ? CONTAINING_RECORD(pListEntry, RxNetDescriptor, ReceiveQueueListEntry) : NULL;\n}\n\nstatic __inline\nBOOLEAN ReceiveQueueHasBuffers(PPARANDIS_RECEIVE_QUEUE pQueue)\n{\n    BOOLEAN res;\n\n    NdisAcquireSpinLock(&pQueue->Lock);\n    res = !IsListEmpty(&pQueue->BuffersList);\n    NdisReleaseSpinLock(&pQueue->Lock);\n\n    return res;\n}\n\nstatic VOID\nUpdateReceiveSuccessStatistics(PPARANDIS_ADAPTER pContext,\n                               PNET_PACKET_INFO pPacketInfo,\n                               UINT nCoalescedSegmentsCount)\n{\n    pContext->Statistics.ifHCInOctets += pPacketInfo->dataLength;\n\n    if(pPacketInfo->isUnicast)\n    {\n        pContext->Statistics.ifHCInUcastPkts += nCoalescedSegmentsCount;\n        pContext->Statistics.ifHCInUcastOctets += pPacketInfo->dataLength;\n    }\n    else if (pPacketInfo->isBroadcast)\n    {\n        pContext->Statistics.ifHCInBroadcastPkts += nCoalescedSegmentsCount;\n        pContext->Statistics.ifHCInBroadcastOctets += pPacketInfo->dataLength;\n    }\n    else if (pPacketInfo->isMulticast)\n    {\n        pContext->Statistics.ifHCInMulticastPkts += nCoalescedSegmentsCount;\n        pContext->Statistics.ifHCInMulticastOctets += pPacketInfo->dataLength;\n    }\n    else\n    {\n        ASSERT(FALSE);\n    }\n}\n\nstatic __inline VOID\nUpdateReceiveFailStatistics(PPARANDIS_ADAPTER pContext, UINT nCoalescedSegmentsCount)\n{\n    pContext->Statistics.ifInErrors++;\n    pContext->Statistics.ifInDiscards += nCoalescedSegmentsCount;\n}\n\nstatic BOOLEAN ProcessReceiveQueue(PARANDIS_ADAPTER *pContext,\n                                    PULONG pnPacketsToIndicateLeft,\n                                    CCHAR nQueueIndex,\n                                    PNET_BUFFER_LIST *indicate,\n                                    PNET_BUFFER_LIST *indicateTail,\n                                    ULONG *nIndicate)\n{\n    \n    pRxNetDescriptor pBufferDescriptor;\n    PPARANDIS_RECEIVE_QUEUE pTargetReceiveQueue = &pContext->ReceiveQueues[nQueueIndex];\n\n    if(NdisInterlockedIncrement(&pTargetReceiveQueue->ActiveProcessorsCount) == 1)\n    {\n        while( (*pnPacketsToIndicateLeft > 0) &&\n               (NULL != (pBufferDescriptor = ReceiveQueueGetBuffer(pTargetReceiveQueue))) )\n        {\n            PNET_PACKET_INFO pPacketInfo = &pBufferDescriptor->PacketInfo;\n\n            if( !pContext->bSurprizeRemoved &&\n                pContext->ReceiveState == srsEnabled &&\n                pContext->bConnected &&\n                ShallPassPacket(pContext, pPacketInfo))\n            {\n                UINT nCoalescedSegmentsCount;\n                PNET_BUFFER_LIST packet = ParaNdis_PrepareReceivedPacket(pContext, pBufferDescriptor, &nCoalescedSegmentsCount);\n                if(packet != NULL)\n                {\n                    UpdateReceiveSuccessStatistics(pContext, pPacketInfo, nCoalescedSegmentsCount);\n                    if (*indicate == nullptr)\n                    {\n                        *indicate = *indicateTail = packet;\n                    }\n                    else\n                    {\n                        NET_BUFFER_LIST_NEXT_NBL(*indicateTail) = packet;\n                        *indicateTail = packet;\n                    }\n\n                    NET_BUFFER_LIST_NEXT_NBL(*indicateTail) = NULL;\n                    (*pnPacketsToIndicateLeft)--;\n                    (*nIndicate)++;\n                }\n                else\n                {\n                    UpdateReceiveFailStatistics(pContext, nCoalescedSegmentsCount);\n                    pBufferDescriptor->Queue->ReuseReceiveBuffer(pContext->ReuseBufferRegular, pBufferDescriptor);\n                }\n            }\n            else\n            {\n                pContext->extraStatistics.framesFilteredOut++;\n                pBufferDescriptor->Queue->ReuseReceiveBuffer(pContext->ReuseBufferRegular, pBufferDescriptor);\n            }\n        }\n     }\n\n    NdisInterlockedDecrement(&pTargetReceiveQueue->ActiveProcessorsCount);\n    return ReceiveQueueHasBuffers(pTargetReceiveQueue);\n}\n\nstatic\nBOOLEAN RxDPCWorkBody(PARANDIS_ADAPTER *pContext, CPUPathesBundle *pathBundle, ULONG nPacketsToIndicate)\n{\n    BOOLEAN res = FALSE;\n    BOOLEAN bMoreDataInRing;\n\n    PNET_BUFFER_LIST indicate, indicateTail;\n    ULONG nIndicate;\n\n    CCHAR CurrCpuReceiveQueue = GetReceiveQueueForCurrentCPU(pContext);\n\n    do\n    {\n        indicate = nullptr;\n        indicateTail = nullptr;\n        nIndicate = 0;\n\n        {\n            CNdisDispatchReadAutoLock tLock(pContext->m_PauseLock);\n\n            pathBundle->rxPath.ProcessRxRing(CurrCpuReceiveQueue);\n\n            res |= ProcessReceiveQueue(pContext, &nPacketsToIndicate, PARANDIS_RECEIVE_QUEUE_UNCLASSIFIED,\n                &indicate, &indicateTail, &nIndicate);\n\n            if(CurrCpuReceiveQueue != PARANDIS_RECEIVE_QUEUE_UNCLASSIFIED)\n            {\n                res |= ProcessReceiveQueue(pContext, &nPacketsToIndicate, CurrCpuReceiveQueue,\n                    &indicate, &indicateTail, &nIndicate);\n            }\n\n            bMoreDataInRing = pathBundle->rxPath.RestartQueue();\n        }\n\n        if (nIndicate)\n        {\n            NdisMIndicateReceiveNetBufferLists(pContext->MiniportHandle,\n                indicate,\n                0,\n                nIndicate,\n                0);\n        }\n\n        ParaMdis_TestPausing(pContext);\n\n    } while (bMoreDataInRing);\n\n    return res;\n}\n\nbool ParaNdis_DPCWorkBody(PARANDIS_ADAPTER *pContext, ULONG ulMaxPacketsToIndicate)\n{\n    bool stillRequiresProcessing = false;\n    UINT numOfPacketsToIndicate = min(ulMaxPacketsToIndicate, pContext->uNumberOfHandledRXPacketsInDPC);\n\n    DEBUG_ENTRY(5);\n\n    InterlockedIncrement(&pContext->counterDPCInside);\n\n    CPUPathesBundle *pathBundle = nullptr;\n\n    if (pContext->nPathBundles == 1)\n    {\n        pathBundle = pContext->pPathBundles;\n    }\n    else\n    {\n        ULONG procNumber = KeGetCurrentProcessorNumber();\n        if (procNumber < pContext->nPathBundles)\n        {\n            pathBundle = pContext->pPathBundles + procNumber;\n        }\n    }\n\n    if (pathBundle == nullptr)\n    {\n        return false;\n    }\n\n    if (pContext->bEnableInterruptHandlingDPC)\n    {\n        bool bDoKick = false;\n\n        InterlockedExchange(&pContext->bDPCInactive, 0);\n\n        if (RxDPCWorkBody(pContext, pathBundle, numOfPacketsToIndicate))\n        {\n            stillRequiresProcessing = true;\n        }\n\n        if (pContext->CXPath.WasInterruptReported() && pContext->bLinkDetectSupported)\n        {\n            ReadLinkState(pContext);\n            ParaNdis_SynchronizeLinkState(pContext);\n            pContext->CXPath.ClearInterruptReport();\n        }\n\n        if (!stillRequiresProcessing)\n        {\n            bDoKick = pathBundle->txPath.DoPendingTasks(true);\n            if (pathBundle->txPath.RestartQueue(bDoKick))\n            {\n                stillRequiresProcessing = true;\n            }\n        }\n    }\n    InterlockedDecrement(&pContext->counterDPCInside);\n\n    return stillRequiresProcessing;\n}\n\nVOID ParaNdis_ResetRxClassification(PARANDIS_ADAPTER *pContext)\n{\n    ULONG i;\n    PPARANDIS_RECEIVE_QUEUE pUnclassified = &pContext->ReceiveQueues[PARANDIS_RECEIVE_QUEUE_UNCLASSIFIED];\n\n    NdisAcquireSpinLock(&pUnclassified->Lock);\n\n    for(i = PARANDIS_RECEIVE_QUEUE_UNCLASSIFIED + 1; i < ARRAYSIZE(pContext->ReceiveQueues); i++)\n    {\n        PPARANDIS_RECEIVE_QUEUE pCurrQueue = &pContext->ReceiveQueues[i];\n        NdisAcquireSpinLock(&pCurrQueue->Lock);\n\n        while(!IsListEmpty(&pCurrQueue->BuffersList))\n        {\n            PLIST_ENTRY pListEntry = RemoveHeadList(&pCurrQueue->BuffersList);\n            InsertTailList(&pUnclassified->BuffersList, pListEntry);\n        }\n\n        NdisReleaseSpinLock(&pCurrQueue->Lock);\n    }\n\n    NdisReleaseSpinLock(&pUnclassified->Lock);\n}\n\n/**********************************************************\nPeriodically called procedure, checking dpc activity\nIf DPC are not running, it does exactly the same that the DPC\nParameters:\n    context\n***********************************************************/\nstatic BOOLEAN CheckRunningDpc(PARANDIS_ADAPTER *pContext)\n{\n    BOOLEAN bStopped;\n    BOOLEAN bReportHang = FALSE;\n    bStopped = 0 != InterlockedExchange(&pContext->bDPCInactive, TRUE);\n\n    if (bStopped)\n    {\n        pContext->nDetectedInactivity++;\n    }\n    else\n    {\n        pContext->nDetectedInactivity = 0;\n    }\n\n    for (UINT i = 0; i < pContext->nPathBundles; i++)\n    {\n        if (pContext->pPathBundles[i].txPath.HasHWBuffersIsUse())\n        {\n            if (pContext->nDetectedStoppedTx++ > 1)\n            {\n                DPrintf(0, (\"[%s] - Suspicious Tx inactivity (%d)!\\n\", __FUNCTION__, pContext->pPathBundles[i].txPath.GetFreeHWBuffers()));\n                //bReportHang = TRUE;\n#ifdef DBG_USE_VIRTIO_PCI_ISR_FOR_HOST_REPORT\n                WriteVirtIODeviceByte(pContext->IODevice->addr + VIRTIO_PCI_ISR, 0);\n#endif\n                break;\n            }\n        }\n    }\n\n    if (pContext->Limits.nPrintDiagnostic &&\n        ++pContext->Counters.nPrintDiagnostic >= pContext->Limits.nPrintDiagnostic)\n    {\n        pContext->Counters.nPrintDiagnostic = 0;\n        // todo - collect more and put out optionally\n        PrintStatistics(pContext);\n    }\n\n    if (pContext->Statistics.ifHCInOctets == pContext->Counters.prevIn)\n    {\n        pContext->Counters.nRxInactivity++;\n        if (pContext->Counters.nRxInactivity >= 10)\n        {\n#if defined(CRASH_ON_NO_RX)\n            ONPAUSECOMPLETEPROC proc = (ONPAUSECOMPLETEPROC)(PVOID)1;\n            proc(pContext);\n#endif\n        }\n    }\n    else\n    {\n        pContext->Counters.nRxInactivity = 0;\n        pContext->Counters.prevIn = pContext->Statistics.ifHCInOctets;\n    }\n    return bReportHang;\n}\n\n/**********************************************************\nCommon implementation of periodic poll\nParameters:\n    context\nReturn:\n    TRUE, if reset required\n***********************************************************/\nBOOLEAN ParaNdis_CheckForHang(PARANDIS_ADAPTER *pContext)\n{\n    static int nHangOn = 0;\n    BOOLEAN b = nHangOn >= 3 && nHangOn < 6;\n    DEBUG_ENTRY(3);\n    b |= CheckRunningDpc(pContext);\n    //uncomment to cause 3 consecutive resets\n    //nHangOn++;\n    DEBUG_EXIT_STATUS(b ? 0 : 6, b);\n    return b;\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////\n//\n// ReadVirtIODeviceRegister\\WriteVirtIODeviceRegister\n// NDIS specific implementation of the IO space read\\write\n//\n/////////////////////////////////////////////////////////////////////////////////////\nu32 ReadVirtIODeviceRegister(ULONG_PTR ulRegister)\n{\n    ULONG ulValue;\n\n    NdisRawReadPortUlong(ulRegister, &ulValue);\n\n    DPrintf(6, (\"[%s]R[%x]=%x\\n\", __FUNCTION__, (ULONG)ulRegister, ulValue) );\n    return ulValue;\n}\n\nvoid WriteVirtIODeviceRegister(ULONG_PTR ulRegister, u32 ulValue)\n{\n    DPrintf(6, (\"[%s]R[%x]=%x\\n\", __FUNCTION__, (ULONG)ulRegister, ulValue) );\n\n    NdisRawWritePortUlong(ulRegister, ulValue);\n}\n\nu8 ReadVirtIODeviceByte(ULONG_PTR ulRegister)\n{\n    u8 bValue;\n\n    NdisRawReadPortUchar(ulRegister, &bValue);\n\n    DPrintf(6, (\"[%s]R[%x]=%x\\n\", __FUNCTION__, (ULONG)ulRegister, bValue) );\n\n    return bValue;\n}\n\nvoid WriteVirtIODeviceByte(ULONG_PTR ulRegister, u8 bValue)\n{\n    DPrintf(6, (\"[%s]R[%x]=%x\\n\", __FUNCTION__, (ULONG)ulRegister, bValue) );\n\n    NdisRawWritePortUchar(ulRegister, bValue);\n}\n\nu16 ReadVirtIODeviceWord(ULONG_PTR ulRegister)\n{\n    u16 wValue;\n\n    NdisRawReadPortUshort(ulRegister, &wValue);\n\n    DPrintf(6, (\"[%s]R[%x]=%x\\n\", __FUNCTION__, (ULONG)ulRegister, wValue) );\n\n    return wValue;\n}\n\nvoid WriteVirtIODeviceWord(ULONG_PTR ulRegister, u16 wValue)\n{\n#if 1\n    NdisRawWritePortUshort(ulRegister, wValue);\n#else\n    // test only to cause long TX waiting queue of NDIS packets\n    // to recognize it and request for reset via Hang handler\n    static int nCounterToFail = 0;\n    static const int StartFail = 200, StopFail = 600;\n    BOOLEAN bFail = FALSE;\n    DPrintf(6, (\"%s> R[%x] = %x\\n\", __FUNCTION__, (ULONG)ulRegister, wValue) );\n    if ((ulRegister & 0x1F) == 0x10)\n    {\n        nCounterToFail++;\n        bFail = nCounterToFail >= StartFail && nCounterToFail < StopFail;\n    }\n    if (!bFail) NdisRawWritePortUshort(ulRegister, wValue);\n    else\n    {\n        DPrintf(0, (\"%s> FAILING R[%x] = %x\\n\", __FUNCTION__, (ULONG)ulRegister, wValue) );\n    }\n#endif\n}\n\n/**********************************************************\nCommon handler of multicast address configuration\nParameters:\n    PVOID Buffer            array of addresses from NDIS\n    ULONG BufferSize        size of incoming buffer\n    PUINT pBytesRead        update on success\n    PUINT pBytesNeeded      update on wrong buffer size\nReturn value:\n    SUCCESS or kind of failure\n***********************************************************/\nNDIS_STATUS ParaNdis_SetMulticastList(\n    PARANDIS_ADAPTER *pContext,\n    PVOID Buffer,\n    ULONG BufferSize,\n    PUINT pBytesRead,\n    PUINT pBytesNeeded)\n{\n    NDIS_STATUS status;\n    ULONG length = BufferSize;\n    if (length > sizeof(pContext->MulticastData.MulticastList))\n    {\n        status = NDIS_STATUS_MULTICAST_FULL;\n        *pBytesNeeded = sizeof(pContext->MulticastData.MulticastList);\n    }\n    else if (length % ETH_LENGTH_OF_ADDRESS)\n    {\n        status = NDIS_STATUS_INVALID_LENGTH;\n        *pBytesNeeded = (length / ETH_LENGTH_OF_ADDRESS) * ETH_LENGTH_OF_ADDRESS;\n    }\n    else\n    {\n        NdisZeroMemory(pContext->MulticastData.MulticastList, sizeof(pContext->MulticastData.MulticastList));\n        if (length)\n            NdisMoveMemory(pContext->MulticastData.MulticastList, Buffer, length);\n        pContext->MulticastData.nofMulticastEntries = length / ETH_LENGTH_OF_ADDRESS;\n        DPrintf(1, (\"[%s] New multicast list of %d bytes\\n\", __FUNCTION__, length));\n        *pBytesRead = length;\n        status = NDIS_STATUS_SUCCESS;\n    }\n    return status;\n}\n\n/**********************************************************\nCommon handler of PnP events\nParameters:\nReturn value:\n***********************************************************/\nVOID ParaNdis_OnPnPEvent(\n    PARANDIS_ADAPTER *pContext,\n    NDIS_DEVICE_PNP_EVENT pEvent,\n    PVOID   pInfo,\n    ULONG   ulSize)\n{\n    const char *pName = \"\";\n\n    UNREFERENCED_PARAMETER(pInfo);\n    UNREFERENCED_PARAMETER(ulSize);\n\n    DEBUG_ENTRY(0);\n#undef MAKECASE\n#define MAKECASE(x) case (x): pName = #x; break;\n    switch (pEvent)\n    {\n        MAKECASE(NdisDevicePnPEventQueryRemoved)\n        MAKECASE(NdisDevicePnPEventRemoved)\n        MAKECASE(NdisDevicePnPEventSurpriseRemoved)\n        MAKECASE(NdisDevicePnPEventQueryStopped)\n        MAKECASE(NdisDevicePnPEventStopped)\n        MAKECASE(NdisDevicePnPEventPowerProfileChanged)\n        MAKECASE(NdisDevicePnPEventFilterListChanged)\n        default:\n            break;\n    }\n    ParaNdis_DebugHistory(pContext, hopPnpEvent, NULL, pEvent, 0, 0);\n    DPrintf(0, (\"[%s] (%s)\\n\", __FUNCTION__, pName));\n    if (pEvent == NdisDevicePnPEventSurpriseRemoved)\n    {\n        // on simulated surprise removal (under PnpTest) we need to reset the device\n        // to prevent any access of device queues to memory buffers\n        pContext->bSurprizeRemoved = TRUE;\n        ParaNdis_ResetVirtIONetDevice(pContext);\n        {\n            UINT i;\n\n            for (i = 0; i < pContext->nPathBundles; i++)\n            {\n                pContext->pPathBundles[i].txPath.Pause();\n            }\n        }\n    }\n    pContext->PnpEvents[pContext->nPnpEventIndex++] = pEvent;\n    if (pContext->nPnpEventIndex > sizeof(pContext->PnpEvents)/sizeof(pContext->PnpEvents[0]))\n        pContext->nPnpEventIndex = 0;\n}\n\nstatic VOID ParaNdis_DeviceFiltersUpdateRxMode(PARANDIS_ADAPTER *pContext)\n{\n    u8 val;\n    ULONG f = pContext->PacketFilter;\n    val = (f & NDIS_PACKET_TYPE_ALL_MULTICAST) ? 1 : 0;\n    pContext->CXPath.SendControlMessage(VIRTIO_NET_CTRL_RX_MODE, VIRTIO_NET_CTRL_RX_MODE_ALLMULTI, &val, sizeof(val), NULL, 0, 2);\n    //SendControlMessage(pContext, VIRTIO_NET_CTRL_RX_MODE, VIRTIO_NET_CTRL_RX_MODE_ALLUNI, &val, sizeof(val), NULL, 0, 2);\n    val = (f & (NDIS_PACKET_TYPE_MULTICAST | NDIS_PACKET_TYPE_ALL_MULTICAST)) ? 0 : 1;\n    pContext->CXPath.SendControlMessage(VIRTIO_NET_CTRL_RX_MODE, VIRTIO_NET_CTRL_RX_MODE_NOMULTI, &val, sizeof(val), NULL, 0, 2);\n    val = (f & NDIS_PACKET_TYPE_DIRECTED) ? 0 : 1;\n    pContext->CXPath.SendControlMessage(VIRTIO_NET_CTRL_RX_MODE, VIRTIO_NET_CTRL_RX_MODE_NOUNI, &val, sizeof(val), NULL, 0, 2);\n    val = (f & NDIS_PACKET_TYPE_BROADCAST) ? 0 : 1;\n    pContext->CXPath.SendControlMessage(VIRTIO_NET_CTRL_RX_MODE, VIRTIO_NET_CTRL_RX_MODE_NOBCAST, &val, sizeof(val), NULL, 0, 2);\n    val = (f & NDIS_PACKET_TYPE_PROMISCUOUS) ? 1 : 0;\n    pContext->CXPath.SendControlMessage(VIRTIO_NET_CTRL_RX_MODE, VIRTIO_NET_CTRL_RX_MODE_PROMISC, &val, sizeof(val), NULL, 0, 2);\n}\n\nstatic VOID ParaNdis_DeviceFiltersUpdateAddresses(PARANDIS_ADAPTER *pContext)\n{\n    u32 u32UniCastEntries = 0;\n    pContext->CXPath.SendControlMessage(VIRTIO_NET_CTRL_MAC, VIRTIO_NET_CTRL_MAC_TABLE_SET,\n                        &u32UniCastEntries,\n                        sizeof(u32UniCastEntries),\n                        &pContext->MulticastData,\n                        sizeof(pContext->MulticastData.nofMulticastEntries) + pContext->MulticastData.nofMulticastEntries * ETH_LENGTH_OF_ADDRESS,\n                        2);\n}\n\nstatic VOID SetSingleVlanFilter(PARANDIS_ADAPTER *pContext, ULONG vlanId, BOOLEAN bOn, int levelIfOK)\n{\n    u16 val = vlanId & 0xfff;\n    UCHAR cmd = bOn ? VIRTIO_NET_CTRL_VLAN_ADD : VIRTIO_NET_CTRL_VLAN_DEL;\n    pContext->CXPath.SendControlMessage(VIRTIO_NET_CTRL_VLAN, cmd, &val, sizeof(val), NULL, 0, levelIfOK);\n}\n\nstatic VOID SetAllVlanFilters(PARANDIS_ADAPTER *pContext, BOOLEAN bOn)\n{\n    ULONG i;\n    for (i = 0; i <= MAX_VLAN_ID; ++i)\n        SetSingleVlanFilter(pContext, i, bOn, 7);\n}\n\n/*\n    possible values of filter set (pContext->ulCurrentVlansFilterSet):\n    0 - all disabled\n    1..4095 - one selected enabled\n    4096 - all enabled\n    Note that only 0th vlan can't be enabled\n*/\nVOID ParaNdis_DeviceFiltersUpdateVlanId(PARANDIS_ADAPTER *pContext)\n{\n    if (pContext->bHasHardwareFilters)\n    {\n        ULONG newFilterSet;\n        if (IsVlanSupported(pContext))\n            newFilterSet = pContext->VlanId ? pContext->VlanId : (MAX_VLAN_ID + 1);\n        else\n            newFilterSet = IsPrioritySupported(pContext) ? (MAX_VLAN_ID + 1) : 0;\n        if (newFilterSet != pContext->ulCurrentVlansFilterSet)\n        {\n            if (pContext->ulCurrentVlansFilterSet > MAX_VLAN_ID)\n                SetAllVlanFilters(pContext, FALSE);\n            else if (pContext->ulCurrentVlansFilterSet)\n                SetSingleVlanFilter(pContext, pContext->ulCurrentVlansFilterSet, FALSE, 2);\n\n            pContext->ulCurrentVlansFilterSet = newFilterSet;\n\n            if (pContext->ulCurrentVlansFilterSet > MAX_VLAN_ID)\n                SetAllVlanFilters(pContext, TRUE);\n            else if (pContext->ulCurrentVlansFilterSet)\n                SetSingleVlanFilter(pContext, pContext->ulCurrentVlansFilterSet, TRUE, 2);\n        }\n    }\n}\n\nVOID ParaNdis_UpdateDeviceFilters(PARANDIS_ADAPTER *pContext)\n{\n    if (pContext->bHasHardwareFilters)\n    {\n        ParaNdis_DeviceFiltersUpdateRxMode(pContext);\n        ParaNdis_DeviceFiltersUpdateAddresses(pContext);\n        ParaNdis_DeviceFiltersUpdateVlanId(pContext);\n    }\n}\n\nstatic VOID\nParaNdis_UpdateMAC(PARANDIS_ADAPTER *pContext)\n{\n    if (pContext->bCtrlMACAddrSupported)\n    {\n        pContext->CXPath.SendControlMessage(VIRTIO_NET_CTRL_MAC, VIRTIO_NET_CTRL_MAC_ADDR_SET,\n                           pContext->CurrentMacAddress,\n                           ETH_LENGTH_OF_ADDRESS,\n                           NULL, 0, 4);\n    }\n}\n\n#if PARANDIS_SUPPORT_RSC\nVOID\nParaNdis_UpdateGuestOffloads(PARANDIS_ADAPTER *pContext, UINT64 Offloads)\n{\n    if (pContext->RSC.bHasDynamicConfig)\n    {\n        pContext->CXPath.SendControlMessage(VIRTIO_NET_CTRL_GUEST_OFFLOADS, VIRTIO_NET_CTRL_GUEST_OFFLOADS_SET,\n                           &Offloads,\n                           sizeof(Offloads),\n                           NULL, 0, 2);\n    }\n}\n#endif\n\nVOID ParaNdis_PowerOn(PARANDIS_ADAPTER *pContext)\n{\n    UINT i;\n\n    DEBUG_ENTRY(0);\n    ParaNdis_DebugHistory(pContext, hopPowerOn, NULL, 1, 0, 0);\n    ParaNdis_ResetVirtIONetDevice(pContext);\n    VirtIODeviceAddStatus(pContext->IODevice, VIRTIO_CONFIG_S_ACKNOWLEDGE | VIRTIO_CONFIG_S_DRIVER);\n    /* GetHostFeature must be called with any mask once upon device initialization:\n     otherwise the device will not work properly */\n    VirtIODeviceReadHostFeatures(pContext->IODevice);\n    VirtIODeviceWriteGuestFeatures(pContext->IODevice, pContext->u32GuestFeatures);\n\n    for (i = 0; i < pContext->nPathBundles; i++)\n    {\n        pContext->pPathBundles[i].txPath.Renew();\n        pContext->pPathBundles[i].rxPath.Renew();\n    }\n    if (pContext->bCXPathCreated)\n    {\n        pContext->CXPath.Renew();\n    }\n\n    ParaNdis_RestoreDeviceConfigurationAfterReset(pContext);\n\n    ParaNdis_UpdateDeviceFilters(pContext);\n    ParaNdis_UpdateMAC(pContext);\n\n    InterlockedExchange(&pContext->ReuseBufferRegular, TRUE);\n    \n    for (i = 0; i < pContext->nPathBundles; i++)\n    {\n        pContext->pPathBundles[i].rxPath.PopulateQueue();\n    }\n\n    ReadLinkState(pContext);\n    ParaNdis_SetPowerState(pContext, NdisDeviceStateD0);\n    ParaNdis_SynchronizeLinkState(pContext);\n    pContext->bEnableInterruptHandlingDPC = TRUE;\n    ParaNdis_AddDriverOKStatus(pContext);\n\n    // if bFastSuspendInProcess is set by Win8 power-off procedure,\n    // the ParaNdis_Resume enables Tx and RX\n    // otherwise it does not do anything in Vista+ (Tx and RX are enabled after power-on by Restart)\n    ParaNdis_Resume(pContext);\n    pContext->bFastSuspendInProcess = FALSE;\n\n    ParaNdis_DebugHistory(pContext, hopPowerOn, NULL, 0, 0, 0);\n}\n\nVOID ParaNdis_PowerOff(PARANDIS_ADAPTER *pContext)\n{\n    DEBUG_ENTRY(0);\n    ParaNdis_DebugHistory(pContext, hopPowerOff, NULL, 1, 0, 0);\n\n    pContext->bConnected = FALSE;\n\n    // if bFastSuspendInProcess is set by Win8 power-off procedure\n    // the ParaNdis_Suspend does fast Rx stop without waiting (=>srsPausing, if there are some RX packets in Ndis)\n    pContext->bFastSuspendInProcess = pContext->bNoPauseOnSuspend && pContext->ReceiveState == srsEnabled;\n    ParaNdis_Suspend(pContext);\n\n    ParaNdis_RemoveDriverOKStatus(pContext);\n    \n    if (pContext->bFastSuspendInProcess)\n    {\n        InterlockedExchange(&pContext->ReuseBufferRegular, FALSE);\n    }\n    \n#if !NDIS_SUPPORT_NDIS620\n    // WLK tests for Windows 2008 require media disconnect indication\n    // on power off. HCK tests for newer versions require media state unknown\n    // indication only and fail on disconnect indication\n    ParaNdis_SetLinkState(pContext, MediaConnectStateDisconnected);\n#endif\n    ParaNdis_SetPowerState(pContext, NdisDeviceStateD3);\n    ParaNdis_SetLinkState(pContext, MediaConnectStateUnknown);\n\n    PreventDPCServicing(pContext);\n\n    /*******************************************************************\n        shutdown queues to have all the receive buffers under our control\n        all the transmit buffers move to list of free buffers\n    ********************************************************************/\n\n    for (UINT i = 0; i < pContext->nPathBundles; i++)\n    {\n        pContext->pPathBundles[i].txPath.Shutdown();\n        pContext->pPathBundles[i].rxPath.Shutdown();\n    }\n\n    if (pContext->bCXPathCreated)\n    {\n        pContext->CXPath.Shutdown();\n    }\n\n    ParaNdis_ResetVirtIONetDevice(pContext);\n    ParaNdis_DebugHistory(pContext, hopPowerOff, NULL, 0, 0, 0);\n}\n\nvoid ParaNdis_CallOnBugCheck(PARANDIS_ADAPTER *pContext)\n{\n    if (pContext->AdapterResources.ulIOAddress)\n    {\n#ifdef DBG_USE_VIRTIO_PCI_ISR_FOR_HOST_REPORT\n        WriteVirtIODeviceByte(pContext->IODevice->addr + VIRTIO_PCI_ISR, 1);\n#endif\n    }\n}\n\ntChecksumCheckResult ParaNdis_CheckRxChecksum(\n                                            PARANDIS_ADAPTER *pContext,\n                                            ULONG virtioFlags,\n                                            tCompletePhysicalAddress *pPacketPages,\n                                            ULONG ulPacketLength,\n                                            ULONG ulDataOffset)\n{\n    tOffloadSettingsFlags f = pContext->Offload.flags;\n    tChecksumCheckResult res;\n    tTcpIpPacketParsingResult ppr;\n    ULONG flagsToCalculate = 0;\n    res.value = 0;\n\n    //VIRTIO_NET_HDR_F_NEEDS_CSUM - we need to calculate TCP/UDP CS\n    //VIRTIO_NET_HDR_F_DATA_VALID - host tells us TCP/UDP CS is OK\n\n    if (f.fRxIPChecksum) flagsToCalculate |= pcrIpChecksum; // check only\n\n    if (!(virtioFlags & VIRTIO_NET_HDR_F_DATA_VALID))\n    {\n        if (virtioFlags & VIRTIO_NET_HDR_F_NEEDS_CSUM)\n        {\n            flagsToCalculate |= pcrFixXxpChecksum | pcrTcpChecksum | pcrUdpChecksum;\n        }\n        else\n        {\n            if (f.fRxTCPChecksum) flagsToCalculate |= pcrTcpV4Checksum;\n            if (f.fRxUDPChecksum) flagsToCalculate |= pcrUdpV4Checksum;\n            if (f.fRxTCPv6Checksum) flagsToCalculate |= pcrTcpV6Checksum;\n            if (f.fRxUDPv6Checksum) flagsToCalculate |= pcrUdpV6Checksum;\n        }\n    }\n\n    ppr = ParaNdis_CheckSumVerify(pPacketPages, ulPacketLength - ETH_HEADER_SIZE, ulDataOffset + ETH_HEADER_SIZE, flagsToCalculate, __FUNCTION__);\n\n    if (ppr.ipCheckSum == ppresIPTooShort || ppr.xxpStatus == ppresXxpIncomplete)\n    {\n        res.flags.IpOK = FALSE;\n        res.flags.IpFailed = TRUE;\n        return res;\n    }\n\n    if (virtioFlags & VIRTIO_NET_HDR_F_DATA_VALID)\n    {\n        pContext->extraStatistics.framesRxCSHwOK++;\n        ppr.xxpCheckSum = ppresCSOK;\n    }\n\n    if (ppr.ipStatus == ppresIPV4 && !ppr.IsFragment)\n    {\n        if (f.fRxIPChecksum)\n        {\n            res.flags.IpOK =  ppr.ipCheckSum == ppresCSOK;\n            res.flags.IpFailed = ppr.ipCheckSum == ppresCSBad;\n        }\n        if(ppr.xxpStatus == ppresXxpKnown)\n        {\n            if(ppr.TcpUdp == ppresIsTCP) /* TCP */\n            {\n                if (f.fRxTCPChecksum)\n                {\n                    res.flags.TcpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;\n                    res.flags.TcpFailed = !res.flags.TcpOK;\n                }\n            }\n            else /* UDP */\n            {\n                if (f.fRxUDPChecksum)\n                {\n                    res.flags.UdpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;\n                    res.flags.UdpFailed = !res.flags.UdpOK;\n                }\n            }\n        }\n    }\n    else if (ppr.ipStatus == ppresIPV6)\n    {\n        if(ppr.xxpStatus == ppresXxpKnown)\n        {\n            if(ppr.TcpUdp == ppresIsTCP) /* TCP */\n            {\n                if (f.fRxTCPv6Checksum)\n                {\n                    res.flags.TcpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;\n                    res.flags.TcpFailed = !res.flags.TcpOK;\n                }\n            }\n            else /* UDP */\n            {\n                if (f.fRxUDPv6Checksum)\n                {\n                    res.flags.UdpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;\n                    res.flags.UdpFailed = !res.flags.UdpOK;\n                }\n            }\n        }\n    }\n\n    return res;\n}\n", "#include \"ndis56common.h\"\n\nCNBL::CNBL(PNET_BUFFER_LIST NBL, PPARANDIS_ADAPTER Context, CParaNdisTX &ParentTXPath)\n    : m_NBL(NBL)\n    , m_Context(Context)\n    , m_ParentTXPath(&ParentTXPath)\n{\n    m_NBL->Scratch = this;\n    m_LsoInfo.Value = NET_BUFFER_LIST_INFO(m_NBL, TcpLargeSendNetBufferListInfo);\n    m_CsoInfo.Value = NET_BUFFER_LIST_INFO(m_NBL, TcpIpChecksumNetBufferListInfo);\n}\n\nCNBL::~CNBL()\n{\n    CDpcIrqlRaiser OnDpc;\n\n    m_MappedBuffers.ForEachDetached([this](CNB *NB)\n                                    { CNB::Destroy(NB, m_Context->MiniportHandle); });\n\n    m_Buffers.ForEachDetached([this](CNB *NB)\n                              { CNB::Destroy(NB, m_Context->MiniportHandle); });\n\n    if(m_NBL)\n    {\n        auto NBL = DetachInternalObject();\n        NET_BUFFER_LIST_NEXT_NBL(NBL) = nullptr;\n        NdisMSendNetBufferListsComplete(m_Context->MiniportHandle, NBL, 0);\n    }\n}\n\nbool CNBL::ParsePriority()\n{\n    NDIS_NET_BUFFER_LIST_8021Q_INFO priorityInfo;\n    priorityInfo.Value = m_Context->ulPriorityVlanSetting ?\n        NET_BUFFER_LIST_INFO(m_NBL, Ieee8021QNetBufferListInfo) : nullptr;\n\n    if (!priorityInfo.TagHeader.VlanId)\n    {\n        priorityInfo.TagHeader.VlanId = m_Context->VlanId;\n    }\n\n    if (priorityInfo.TagHeader.CanonicalFormatId || !IsValidVlanId(m_Context, priorityInfo.TagHeader.VlanId))\n    {\n        DPrintf(0, (\"[%s] Discarded invalid priority tag %p\\n\", __FUNCTION__, priorityInfo.Value));\n        return false;\n    }\n    else if (priorityInfo.Value)\n    {\n        // ignore priority, if configured\n        if (!IsPrioritySupported(m_Context))\n            priorityInfo.TagHeader.UserPriority = 0;\n        // ignore VlanId, if specified\n        if (!IsVlanSupported(m_Context))\n            priorityInfo.TagHeader.VlanId = 0;\n        if (priorityInfo.Value)\n        {\n            m_TCI = static_cast<UINT16>(priorityInfo.TagHeader.UserPriority << 13 | priorityInfo.TagHeader.VlanId);\n            DPrintf(1, (\"[%s] Populated priority tag %p\\n\", __FUNCTION__, priorityInfo.Value));\n        }\n    }\n\n    return true;\n}\n\nvoid CNBL::RegisterNB(CNB *NB)\n{\n    m_Buffers.PushBack(NB);\n    m_BuffersNumber++;\n}\n\nvoid CNBL::RegisterMappedNB(CNB *NB)\n{\n    if (m_MappedBuffers.PushBack(NB) == m_BuffersNumber)\n    {\n        m_ParentTXPath->NBLMappingDone(this);\n    }\n}\n\nbool CNBL::ParseBuffers()\n{\n    m_MaxDataLength = 0;\n\n    for (auto NB = NET_BUFFER_LIST_FIRST_NB(m_NBL); NB != nullptr; NB = NET_BUFFER_NEXT_NB(NB))\n    {\n        CNB *NBHolder = new (m_Context->MiniportHandle) CNB(NB, this, m_Context);\n        if(!NBHolder || !NBHolder->IsValid())\n        {\n            return false;\n        }\n        RegisterNB(NBHolder);\n        m_MaxDataLength = max(m_MaxDataLength, NBHolder->GetDataLength());\n    }\n\n    if(m_MaxDataLength == 0)\n    {\n        DPrintf(0, (\"Empty NBL (%p) dropped\\n\", __FUNCTION__, m_NBL));\n        return false;\n    }\n\n    return true;\n}\n\nbool CNBL::NeedsLSO()\n{\n    return m_MaxDataLength > m_Context->MaxPacketSize.nMaxFullSizeOS;\n}\n\nbool CNBL::FitsLSO()\n{\n    return (m_MaxDataLength <= PARANDIS_MAX_LSO_SIZE + LsoTcpHeaderOffset() + MAX_TCP_HEADER_SIZE);\n}\n\nbool CNBL::ParseLSO()\n{\n    ASSERT(IsLSO());\n\n    if (m_LsoInfo.LsoV1Transmit.Type != NDIS_TCP_LARGE_SEND_OFFLOAD_V1_TYPE &&\n        m_LsoInfo.LsoV2Transmit.Type != NDIS_TCP_LARGE_SEND_OFFLOAD_V2_TYPE)\n    {\n        return false;\n    }\n\n    if (NeedsLSO() &&\n        (!m_LsoInfo.LsoV2Transmit.MSS ||\n         !m_LsoInfo.LsoV2Transmit.TcpHeaderOffset))\n    {\n        return false;\n    }\n\n    if (!FitsLSO())\n    {\n        return false;\n    }\n\n    if (!LsoTcpHeaderOffset() != !MSS())\n    {\n        return false;\n    }\n\n    if ((!m_Context->Offload.flags.fTxLso || !m_Context->bOffloadv4Enabled) &&\n        m_LsoInfo.LsoV2Transmit.IPVersion == NDIS_TCP_LARGE_SEND_OFFLOAD_IPv4)\n    {\n        return false;\n    }\n\n    if (m_LsoInfo.LsoV2Transmit.Type == NDIS_TCP_LARGE_SEND_OFFLOAD_V2_TYPE &&\n        m_LsoInfo.LsoV2Transmit.IPVersion == NDIS_TCP_LARGE_SEND_OFFLOAD_IPv6 &&\n        (!m_Context->Offload.flags.fTxLsov6 || !m_Context->bOffloadv6Enabled))\n    {\n        return false;\n    }\n\n    return true;\n}\n\ntemplate <typename TClassPred, typename TOffloadPred, typename TSupportedPred>\nbool CNBL::ParseCSO(TClassPred IsClass, TOffloadPred IsOffload,\n                    TSupportedPred IsSupported, LPSTR OffloadName)\n{\n    ASSERT(IsClass());\n    UNREFERENCED_PARAMETER(IsClass);\n\n    if (IsOffload())\n    {\n        if(!IsSupported())\n        {\n            DPrintf(0, (\"[%s] %s request when it is not supported\\n\", __FUNCTION__, OffloadName));\n#if FAIL_UNEXPECTED\n            // ignore unexpected CS requests while this passes WHQL\n            return false;\n#endif\n        }\n    }\n    return true;\n}\n\nbool CNBL::ParseOffloads()\n{\n    if (IsLSO())\n    {\n        if(!ParseLSO())\n        {\n            return false;\n        }\n    }\n    else if (IsIP4CSO())\n    {\n        if(!ParseCSO([this] () -> bool { return IsIP4CSO(); },\n                     [this] () -> bool { return m_CsoInfo.Transmit.TcpChecksum; },\n                     [this] () -> bool { return m_Context->Offload.flags.fTxTCPChecksum && m_Context->bOffloadv4Enabled; },\n                     \"TCP4 CSO\"))\n        {\n            return false;\n        }\n        else if(!ParseCSO([this] () -> bool { return IsIP4CSO(); },\n                          [this] () -> bool { return m_CsoInfo.Transmit.UdpChecksum; },\n                          [this] () -> bool { return m_Context->Offload.flags.fTxUDPChecksum && m_Context->bOffloadv4Enabled; },\n                          \"UDP4 CSO\"))\n        {\n            return false;\n        }\n\n        if(!ParseCSO([this] () -> bool { return IsIP4CSO(); },\n                     [this] () -> bool { return m_CsoInfo.Transmit.IpHeaderChecksum; },\n                     [this] () -> bool { return m_Context->Offload.flags.fTxIPChecksum && m_Context->bOffloadv4Enabled; },\n                     \"IP4 CSO\"))\n        {\n            return false;\n        }\n    }\n    else if (IsIP6CSO())\n    {\n        if(!ParseCSO([this] () -> bool { return IsIP6CSO(); },\n                     [this] () -> bool { return m_CsoInfo.Transmit.TcpChecksum; },\n                     [this] () -> bool { return m_Context->Offload.flags.fTxTCPv6Checksum && m_Context->bOffloadv6Enabled; },\n                     \"TCP6 CSO\"))\n        {\n            return false;\n        }\n        else if(!ParseCSO([this] () -> bool { return IsIP6CSO(); },\n                          [this] () -> bool { return m_CsoInfo.Transmit.UdpChecksum; },\n                          [this] () -> bool { return m_Context->Offload.flags.fTxUDPv6Checksum && m_Context->bOffloadv6Enabled; },\n                          \"UDP6 CSO\"))\n        {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid CNBL::StartMapping()\n{\n    CDpcIrqlRaiser OnDpc;\n\n    AddRef();\n\n    m_Buffers.ForEachDetached([this](CNB *NB)\n                              {\n                                  if (!NB->ScheduleBuildSGListForTx())\n                                  {\n                                      m_HaveFailedMappings = true;\n                                      NB->MappingDone(nullptr);\n                                  }\n                              });\n\n    Release();\n}\n\nvoid CNBL::OnLastReferenceGone()\n{\n    Destroy(this, m_Context->MiniportHandle);\n}\n\nCParaNdisTX::CParaNdisTX()\n{ }\n\nbool CParaNdisTX::Create(PPARANDIS_ADAPTER Context, UINT DeviceQueueIndex)\n{\n    m_Context = Context;\n    m_queueIndex = (u16)DeviceQueueIndex;\n\n    return m_VirtQueue.Create(DeviceQueueIndex,\n        m_Context->IODevice,\n        m_Context->MiniportHandle,\n        m_Context->bDoPublishIndices ? true : false,\n        m_Context->maxFreeTxDescriptors,\n        m_Context->nVirtioHeaderSize,\n        m_Context);\n}\n\nvoid CParaNdisTX::Send(PNET_BUFFER_LIST NBL)\n{\n    PNET_BUFFER_LIST nextNBL = nullptr;\n\n    for(auto currNBL = NBL; currNBL != nullptr; currNBL = nextNBL)\n    {\n        nextNBL = NET_BUFFER_LIST_NEXT_NBL(currNBL);\n        NET_BUFFER_LIST_NEXT_NBL(currNBL) = nullptr;\n\n        auto NBLHolder = new (m_Context->MiniportHandle) CNBL(currNBL, m_Context, *this);\n\n        if (NBLHolder == nullptr)\n        {\n            CNBL OnStack(currNBL, m_Context, *this);\n            OnStack.SetStatus(NDIS_STATUS_RESOURCES);\n            DPrintf(0, (\"ERROR: Failed to allocate CNBL instance\\n\"));\n            continue;\n        }\n\n        if(NBLHolder->Prepare() &&\n           ParaNdis_IsSendPossible(m_Context))\n        {\n            NBLHolder->StartMapping();\n        }\n        else\n        {\n            NBLHolder->SetStatus(ParaNdis_ExactSendFailureStatus(m_Context));\n            NBLHolder->Release();\n        }\n    }\n}\n\nvoid CParaNdisTX::NBLMappingDone(CNBL *NBLHolder)\n{\n    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);\n\n    if (NBLHolder->MappingSuceeded())\n    {\n        DoWithTXLock([NBLHolder, this](){ m_SendList.PushBack(NBLHolder); });\n        DoPendingTasks(false);\n    }\n    else\n    {\n        NBLHolder->SetStatus(NDIS_STATUS_FAILURE);\n        NBLHolder->Release();\n    }\n}\n\nCNB *CNBL::PopMappedNB()\n{\n    m_MappedBuffersDetached++;\n    return m_MappedBuffers.Pop();\n}\nvoid CNBL::PushMappedNB(CNB *NB)\n{\n    m_MappedBuffersDetached--;\n    m_MappedBuffers.Push(NB);\n}\n\n//TODO: Needs review\nvoid CNBL::NBComplete()\n{\n    m_BuffersDone++;\n    m_MappedBuffersDetached--;\n}\n\nbool CNBL::IsSendDone()\n{\n    return m_BuffersDone == m_BuffersNumber;\n}\n\n//TODO: Needs review\nvoid CNBL::CompleteMappedBuffers()\n{\n    m_MappedBuffers.ForEachDetached([this](CNB *NB)\n                                        {\n                                            NBComplete();\n                                            CNB::Destroy(NB, m_Context->MiniportHandle);\n                                        });\n}\n\nPNET_BUFFER_LIST CNBL::DetachInternalObject()\n{\n\n    // do it for both LsoV1 and LsoV2\n    if (IsLSO())\n    {\n        m_LsoInfo.LsoV1TransmitComplete.TcpPayload = m_TransferSize;\n    }\n\n    //Flush changes made in LSO structures\n    NET_BUFFER_LIST_INFO(m_NBL, TcpLargeSendNetBufferListInfo) = m_LsoInfo.Value;\n\n    auto Res = m_NBL;\n    m_NBL = nullptr;\n    return Res;\n}\n\nPNET_BUFFER_LIST CParaNdisTX::ProcessWaitingList()\n{\n    PNET_BUFFER_LIST CompletedNBLs = nullptr;\n\n\n    m_WaitingList.ForEachDetachedIf([](CNBL* NBL) { return NBL->IsSendDone(); },\n                                        [&](CNBL* NBL)\n                                        {\n                                            NBL->SetStatus(NDIS_STATUS_SUCCESS);\n                                            auto RawNBL = NBL->DetachInternalObject();\n                                            NBL->Release();\n                                            NET_BUFFER_LIST_NEXT_NBL(RawNBL) = CompletedNBLs;\n                                            CompletedNBLs = RawNBL;\n                                        });\n\n    return CompletedNBLs;\n}\n\n//TODO: Needs review\nPNET_BUFFER_LIST CParaNdisTX::RemoveAllNonWaitingNBLs()\n{\n    PNET_BUFFER_LIST RemovedNBLs = nullptr;\n    auto status = ParaNdis_ExactSendFailureStatus(m_Context);\n\n    m_SendList.ForEachDetachedIf([](CNBL *NBL) { return !NBL->HaveDetachedBuffers(); },\n                                     [&](CNBL *NBL)\n                                     {\n                                         NBL->SetStatus(status);\n                                         auto RawNBL = NBL->DetachInternalObject();\n                                         NBL->Release();\n                                         NET_BUFFER_LIST_NEXT_NBL(RawNBL) = RemovedNBLs;\n                                         RemovedNBLs = RawNBL;\n                                     });\n\n    m_SendList.ForEach([](CNBL *NBL) { NBL->CompleteMappedBuffers(); });\n\n    return RemovedNBLs;\n}\n\nbool CParaNdisTX::Pause()\n{\n    PNET_BUFFER_LIST NBL = nullptr;\n    bool res;\n\n    DoWithTXLock([this, &NBL, &res]()\n                 {\n                     NBL = RemoveAllNonWaitingNBLs();\n                     res = (!m_VirtQueue.HasPacketsInHW() && m_WaitingList.IsEmpty());\n                 });\n\n    if(NBL != nullptr)\n    {\n        NdisMSendNetBufferListsComplete(m_Context->MiniportHandle, NBL, 0);\n    }\n\n    return res;\n}\n\nPNET_BUFFER_LIST CParaNdisTX::BuildCancelList(PVOID CancelId)\n{\n    PNET_BUFFER_LIST CanceledNBLs = nullptr;\n    TSpinLocker LockedContext(m_Lock);\n\n    m_SendList.ForEachDetachedIf([CancelId](CNBL* NBL){ return NBL->MatchCancelID(CancelId) && !NBL->HaveDetachedBuffers(); },\n                                     [this, &CanceledNBLs](CNBL* NBL)\n                                     {\n                                         NBL->SetStatus(NDIS_STATUS_SEND_ABORTED);\n                                         auto RawNBL = NBL->DetachInternalObject();\n                                         NBL->Release();\n                                         NET_BUFFER_LIST_NEXT_NBL(RawNBL) = CanceledNBLs;\n                                         CanceledNBLs = RawNBL;\n                                     });\n\n    return CanceledNBLs;\n}\n\nvoid CParaNdisTX::CancelNBLs(PVOID CancelId)\n{\n    auto CanceledNBLs = BuildCancelList(CancelId);\n    if (CanceledNBLs != nullptr)\n    {\n        NdisMSendNetBufferListsComplete(m_Context->MiniportHandle, CanceledNBLs, 0);\n    }\n}\n\n//TODO: Requires review\nBOOLEAN _Function_class_(MINIPORT_SYNCHRONIZE_INTERRUPT) CParaNdisTX::RestartQueueSynchronously(tSynchronizedContext *ctx)\n{\n    auto TXPath = static_cast<CParaNdisTX *>(ctx->Parameter);\n    return !TXPath->m_VirtQueue.Restart();\n}\n\n//TODO: Requires review\nbool CParaNdisTX::RestartQueue(bool DoKick)\n{\n    TSpinLocker LockedContext(m_Lock);\n    auto res = ParaNdis_SynchronizeWithInterrupt(m_Context,\n                                                 m_messageIndex,\n                                                 CParaNdisTX::RestartQueueSynchronously,\n                                                 this) ? true : false;\n\n    if(DoKick)\n    {\n        Kick();\n    }\n\n    return res;\n}\n\nbool CParaNdisTX::SendMapped(bool IsInterrupt, PNET_BUFFER_LIST &NBLFailNow)\n{\n    if(!ParaNdis_IsSendPossible(m_Context))\n    {\n        NBLFailNow = RemoveAllNonWaitingNBLs();\n        if (NBLFailNow)\n        {\n            DPrintf(0, (__FUNCTION__ \" Failing send\"));\n        }\n    }\n    else\n    {\n        bool SentOutSomeBuffers = false;\n        auto HaveBuffers = true;\n\n        while (HaveBuffers && HaveMappedNBLs())\n        {\n            auto NBLHolder = PopMappedNBL();\n\n            if (NBLHolder->HaveMappedBuffers())\n            {\n                auto NBHolder = NBLHolder->PopMappedNB();\n                auto result = m_VirtQueue.SubmitPacket(*NBHolder);\n\n                switch (result)\n                {\n                case SUBMIT_NO_PLACE_IN_QUEUE:\n                    NBLHolder->PushMappedNB(NBHolder);\n                    PushMappedNBL(NBLHolder);\n                    HaveBuffers = false;\n                    // break the loop, allow to kick and free some buffers\n                    break;\n\n                case SUBMIT_FAILURE:\n                case SUBMIT_SUCCESS:\n                case SUBMIT_PACKET_TOO_LARGE:\n                    // if this NBL finished?\n                    if (!NBLHolder->HaveMappedBuffers())\n                    {\n                        m_WaitingList.Push(NBLHolder);\n                    }\n                    else\n                    {\n                        // no, insert it back to the queue\n                        PushMappedNBL(NBLHolder);\n                    }\n\n                    if (result == SUBMIT_SUCCESS)\n                    {\n                        SentOutSomeBuffers = true;\n                    }\n                    else\n                    {\n                        NBHolder->SendComplete();\n                        CNB::Destroy(NBHolder, m_Context->MiniportHandle);\n                    }\n                    break;\n                default:\n                    ASSERT(false);\n                    break;\n                }\n            }\n            else\n            {\n\n                //TODO: Refactoring needed\n                //This is a case when pause called, mapped list cleared but NBL is still in the send list\n                m_WaitingList.Push(NBLHolder);\n            }\n        }\n\n        if (SentOutSomeBuffers)\n        {\n            DPrintf(2, (\"[%s] sent down\\n\", __FUNCTION__, SentOutSomeBuffers));\n            if (IsInterrupt)\n            {\n                return true;\n            }\n            else\n            {\n                m_VirtQueue.Kick();\n            }\n        }\n    }\n\n    return false;\n}\n\nbool CParaNdisTX::DoPendingTasks(bool IsInterrupt)\n{\n    ONPAUSECOMPLETEPROC CallbackToCall = nullptr;\n    PNET_BUFFER_LIST pNBLFailNow = nullptr;\n    PNET_BUFFER_LIST pNBLReturnNow = nullptr;\n    bool bDoKick = false;\n\n    DoWithTXLock([&] ()\n                 {\n                    m_VirtQueue.ProcessTXCompletions();\n                    bDoKick = SendMapped(IsInterrupt, pNBLFailNow);\n                    pNBLReturnNow = ProcessWaitingList();\n                    {\n                        CNdisPassiveWriteAutoLock tLock(m_Context->m_PauseLock);\n\n                        if (!m_VirtQueue.HasPacketsInHW() && m_Context->SendState == srsPausing)\n                        {\n                            CallbackToCall = m_Context->SendPauseCompletionProc;\n                            m_Context->SendPauseCompletionProc = nullptr;\n                            m_Context->SendState = srsDisabled;\n                        }\n                    }\n                 });\n\n    if (pNBLFailNow)\n    {\n        NdisMSendNetBufferListsComplete(m_Context->MiniportHandle, pNBLFailNow,\n                                        NDIS_SEND_COMPLETE_FLAGS_DISPATCH_LEVEL);\n    }\n\n    if (pNBLReturnNow)\n    {\n        NdisMSendNetBufferListsComplete(m_Context->MiniportHandle, pNBLReturnNow,\n                                        NDIS_SEND_COMPLETE_FLAGS_DISPATCH_LEVEL);\n    }\n\n    if (CallbackToCall != nullptr)\n    {\n        CallbackToCall(m_Context);\n    }\n\n    return bDoKick;\n}\n\nvoid CNB::MappingDone(PSCATTER_GATHER_LIST SGL)\n{\n    m_SGL = SGL;\n    m_ParentNBL->RegisterMappedNB(this);\n}\n\nCNB::~CNB()\n{\n    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);\n\n    if(m_SGL != nullptr)\n    {\n        NdisMFreeNetBufferSGList(m_Context->DmaHandle, m_SGL, m_NB);\n    }\n}\n\nbool CNB::ScheduleBuildSGListForTx()\n{\n    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);\n\n    return NdisMAllocateNetBufferSGList(m_Context->DmaHandle, m_NB, this,\n                                        NDIS_SG_LIST_WRITE_TO_DEVICE, nullptr, 0) == NDIS_STATUS_SUCCESS;\n}\n\nvoid CNB::PopulateIPLength(IPv4Header *IpHeader, USHORT IpLength) const\n{\n    if ((IpHeader->ip_verlen & 0xF0) == 0x40)\n    {\n        if (!IpHeader->ip_length) {\n            IpHeader->ip_length = swap_short(IpLength);\n        }\n    }\n}\n\nvoid CNB::SetupLSO(virtio_net_hdr_basic *VirtioHeader, PVOID IpHeader, ULONG EthPayloadLength) const\n{\n    PopulateIPLength(reinterpret_cast<IPv4Header*>(IpHeader), static_cast<USHORT>(EthPayloadLength));\n\n    tTcpIpPacketParsingResult packetReview;\n    packetReview = ParaNdis_CheckSumVerifyFlat(reinterpret_cast<IPv4Header*>(IpHeader), EthPayloadLength,\n                                               pcrIpChecksum | pcrFixIPChecksum | pcrTcpChecksum | pcrFixPHChecksum,\n                                               __FUNCTION__);\n\n    if (packetReview.xxpCheckSum == ppresPCSOK || packetReview.fixedXxpCS)\n    {\n        auto IpHeaderOffset = m_Context->Offload.ipHeaderOffset;\n        auto VHeader = static_cast<virtio_net_hdr_basic*>(VirtioHeader);\n        auto PriorityHdrLen = (m_ParentNBL->TCI() != 0) ? ETH_PRIORITY_HEADER_SIZE : 0;\n\n        VHeader->flags = VIRTIO_NET_HDR_F_NEEDS_CSUM;\n        VHeader->gso_type = packetReview.ipStatus == ppresIPV4 ? VIRTIO_NET_HDR_GSO_TCPV4 : VIRTIO_NET_HDR_GSO_TCPV6;\n        VHeader->hdr_len = (USHORT)(packetReview.XxpIpHeaderSize + IpHeaderOffset + PriorityHdrLen);\n        VHeader->gso_size = (USHORT)m_ParentNBL->MSS();\n        VHeader->csum_start = (USHORT)(m_ParentNBL->TCPHeaderOffset() + PriorityHdrLen);\n        VHeader->csum_offset = TCP_CHECKSUM_OFFSET;\n    }\n}\n\nUSHORT CNB::QueryL4HeaderOffset(PVOID PacketData, ULONG IpHeaderOffset) const\n{\n    USHORT Res;\n    auto ppr = ParaNdis_ReviewIPPacket(RtlOffsetToPointer(PacketData, IpHeaderOffset),\n                                       GetDataLength(), __FUNCTION__);\n    if (ppr.ipStatus != ppresNotIP)\n    {\n        Res = static_cast<USHORT>(IpHeaderOffset + ppr.ipHeaderSize);\n    }\n    else\n    {\n        DPrintf(0, (\"[%s] ERROR: NOT an IP packet - expected troubles!\\n\", __FUNCTION__));\n        Res = 0;\n    }\n    return Res;\n}\n\nvoid CNB::SetupCSO(virtio_net_hdr_basic *VirtioHeader, ULONG L4HeaderOffset) const\n{\n    u16 PriorityHdrLen = m_ParentNBL->TCI() ? ETH_PRIORITY_HEADER_SIZE : 0;\n\n    VirtioHeader->flags = VIRTIO_NET_HDR_F_NEEDS_CSUM;\n    VirtioHeader->csum_start = static_cast<u16>(L4HeaderOffset) + PriorityHdrLen;\n    VirtioHeader->csum_offset = m_ParentNBL->IsTcpCSO() ? TCP_CHECKSUM_OFFSET : UDP_CHECKSUM_OFFSET;\n}\n\nvoid CNB::DoIPHdrCSO(PVOID IpHeader, ULONG EthPayloadLength) const\n{\n    ParaNdis_CheckSumVerifyFlat(IpHeader,\n                                EthPayloadLength,\n                                pcrIpChecksum | pcrFixIPChecksum,\n                                __FUNCTION__);\n}\n\nbool CNB::FillDescriptorSGList(CTXDescriptor &Descriptor, ULONG ParsedHeadersLength) const\n{\n    return Descriptor.SetupHeaders(ParsedHeadersLength) &&\n           MapDataToVirtioSGL(Descriptor, ParsedHeadersLength + NET_BUFFER_DATA_OFFSET(m_NB));\n}\n\nbool CNB::MapDataToVirtioSGL(CTXDescriptor &Descriptor, ULONG Offset) const\n{\n    for (ULONG i = 0; i < m_SGL->NumberOfElements; i++)\n    {\n        if (Offset < m_SGL->Elements[i].Length)\n        {\n            PHYSICAL_ADDRESS PA;\n            PA.QuadPart = m_SGL->Elements[i].Address.QuadPart + Offset;\n\n            if (!Descriptor.AddDataChunk(PA, m_SGL->Elements[i].Length - Offset))\n            {\n                return false;\n            }\n\n            Offset = 0;\n        }\n        else\n        {\n            Offset -= m_SGL->Elements[i].Length;\n        }\n    }\n\n    return true;\n}\n\nbool CNB::CopyHeaders(PVOID Destination, ULONG MaxSize, ULONG &HeadersLength, ULONG &L4HeaderOffset) const\n{\n    HeadersLength = 0;\n    L4HeaderOffset = 0;\n\n    if (m_ParentNBL->IsLSO() || m_ParentNBL->IsTcpCSO())\n    {\n        L4HeaderOffset = m_ParentNBL->TCPHeaderOffset();\n        HeadersLength = L4HeaderOffset + sizeof(TCPHeader);\n        Copy(Destination, HeadersLength);\n    }\n    else if (m_ParentNBL->IsUdpCSO())\n    {\n        Copy(Destination, MaxSize);\n        L4HeaderOffset = QueryL4HeaderOffset(Destination, m_Context->Offload.ipHeaderOffset);\n        HeadersLength = L4HeaderOffset + sizeof(UDPHeader);\n    }\n    else if (m_ParentNBL->IsIPHdrCSO())\n    {\n        Copy(Destination, MaxSize);\n        HeadersLength = QueryL4HeaderOffset(Destination, m_Context->Offload.ipHeaderOffset);\n        L4HeaderOffset = HeadersLength;\n    }\n    else\n    {\n        HeadersLength = ETH_HEADER_SIZE;\n        Copy(Destination, HeadersLength);\n    }\n\n    return (HeadersLength <= MaxSize);\n}\n\nvoid CNB::BuildPriorityHeader(PETH_HEADER EthHeader, PVLAN_HEADER VlanHeader) const\n{\n    VlanHeader->TCI = RtlUshortByteSwap(m_ParentNBL->TCI());\n\n    if (VlanHeader->TCI != 0)\n    {\n        VlanHeader->EthType = EthHeader->EthType;\n        EthHeader->EthType = RtlUshortByteSwap(PRIO_HEADER_ETH_TYPE);\n    }\n}\n\nvoid CNB::PrepareOffloads(virtio_net_hdr_basic *VirtioHeader, PVOID IpHeader, ULONG EthPayloadLength, ULONG L4HeaderOffset) const\n{\n    *VirtioHeader = {};\n\n    if (m_ParentNBL->IsLSO())\n    {\n        SetupLSO(VirtioHeader, IpHeader, EthPayloadLength);\n    }\n    else if (m_ParentNBL->IsTcpCSO() || m_ParentNBL->IsUdpCSO())\n    {\n        SetupCSO(VirtioHeader, L4HeaderOffset);\n    }\n\n    if (m_ParentNBL->IsIPHdrCSO())\n    {\n        DoIPHdrCSO(IpHeader, EthPayloadLength);\n    }\n}\n\nbool CNB::BindToDescriptor(CTXDescriptor &Descriptor)\n{\n    if (m_SGL == nullptr)\n    {\n        return false;\n    }\n\n    Descriptor.SetNB(this);\n\n    auto &HeadersArea = Descriptor.HeadersAreaAccessor();\n    auto EthHeaders = HeadersArea.EthHeadersAreaVA();\n    ULONG HeadersLength;\n    ULONG L4HeaderOffset;\n\n    if (!CopyHeaders(EthHeaders, HeadersArea.MaxEthHeadersSize(), HeadersLength, L4HeaderOffset))\n    {\n        return false;\n    }\n\n    BuildPriorityHeader(HeadersArea.EthHeader(), HeadersArea.VlanHeader());\n    PrepareOffloads(HeadersArea.VirtioHeader(),\n                    HeadersArea.IPHeaders(),\n                    GetDataLength() - m_Context->Offload.ipHeaderOffset,\n                    L4HeaderOffset);\n\n    return FillDescriptorSGList(Descriptor, HeadersLength);\n}\n\nbool CNB::Copy(PVOID Dst, ULONG Length) const\n{\n    ULONG CurrOffset = NET_BUFFER_CURRENT_MDL_OFFSET(m_NB);\n    ULONG Copied = 0;\n\n    for (PMDL CurrMDL = NET_BUFFER_CURRENT_MDL(m_NB);\n         CurrMDL != nullptr && Copied < Length;\n         CurrMDL = CurrMDL->Next)\n    {\n        ULONG CurrLen;\n        PVOID CurrAddr;\n\n#if NDIS_SUPPORT_NDIS620\n        NdisQueryMdl(CurrMDL, &CurrAddr, &CurrLen, LowPagePriority | MdlMappingNoExecute);\n#else\n        NdisQueryMdl(CurrMDL, &CurrAddr, &CurrLen, LowPagePriority);\n#endif\n\n        if (CurrAddr == nullptr)\n        {\n            break;\n        }\n\n        CurrLen = min(CurrLen - CurrOffset, Length - Copied);\n\n        NdisMoveMemory(RtlOffsetToPointer(Dst, Copied),\n                       RtlOffsetToPointer(CurrAddr, CurrOffset),\n                       CurrLen);\n\n        Copied += CurrLen;\n        CurrOffset = 0;\n    }\n\n    return (Copied == Length);\n}\n", "/**********************************************************************\n * Copyright (c) 2008  Red Hat, Inc.\n *\n * File: ndis56common.h\n *\n * This file contains general definitions for VirtIO network adapter driver,\n * common for both NDIS5 and NDIS6\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n**********************************************************************/\n#ifndef PARANDIS_56_COMMON_H\n#define PARANDIS_56_COMMON_H\n\n//#define PARANDIS_TEST_TX_KICK_ALWAYS\n#if defined(OFFLOAD_UNIT_TEST)\n#include <windows.h>\n#include <stdio.h>\n\n#define ETH_LENGTH_OF_ADDRESS       6\n#define DoPrint(fmt, ...) printf(fmt##\"\\n\", __VA_ARGS__)\n#define DPrintf(a,b) DoPrint b\n#define RtlOffsetToPointer(B,O)  ((PCHAR)( ((PCHAR)(B)) + ((ULONG_PTR)(O))  ))\n\n#include \"ethernetutils.h\"\n#endif //+OFFLOAD_UNIT_TEST\n\n#if !defined(OFFLOAD_UNIT_TEST)\n\n#if !defined(RtlOffsetToPointer)\n#define RtlOffsetToPointer(Base,Offset)  ((PCHAR)(((PCHAR)(Base))+((ULONG_PTR)(Offset))))\n#endif\n\n#if !defined(RtlPointerToOffset)\n#define RtlPointerToOffset(Base,Pointer)  ((ULONG)(((PCHAR)(Pointer))-((PCHAR)(Base))))\n#endif\n\nextern \"C\"\n{\n#include \"osdep.h\"\n\n#if NDIS_SUPPORT_NDIS630\n#define PARANDIS_SUPPORT_RSC 0 // Disable RSC support until support on the host side is ready\n#endif\n\n#if NDIS_SUPPORT_NDIS620\n#define PARANDIS_SUPPORT_RSS 1\n#endif\n\n#if !NDIS_SUPPORT_NDIS620\n    static VOID FORCEINLINE NdisFreeMemoryWithTagPriority(\n        IN  NDIS_HANDLE             NdisHandle,\n        IN  PVOID                   VirtualAddress,\n        IN  ULONG                   Tag)\n    {\n        UNREFERENCED_PARAMETER(NdisHandle);\n        UNREFERENCED_PARAMETER(Tag);\n        NdisFreeMemory(VirtualAddress, 0, 0);\n    }\n#endif\n\n#include \"kdebugprint.h\"\n#include \"ethernetutils.h\"\n#include \"virtio_pci.h\"\n#include \"VirtIO.h\"\n#include \"IONetDescriptor.h\"\n#include \"DebugData.h\"\n}\n\n#if !defined(_Function_class_)\n#define _Function_class_(x)\n#endif\n\n#include \"ParaNdis-RSS.h\"\n\ntypedef union _tagTcpIpPacketParsingResult tTcpIpPacketParsingResult;\n\ntypedef struct _tagCompletePhysicalAddress\n{\n    PHYSICAL_ADDRESS    Physical;\n    PVOID               Virtual;\n    ULONG               size;\n} tCompletePhysicalAddress;\n\nstruct _tagRxNetDescriptor;\ntypedef struct _tagRxNetDescriptor  RxNetDescriptor, *pRxNetDescriptor;\n\nstatic __inline BOOLEAN ParaNDIS_IsQueueInterruptEnabled(struct virtqueue * _vq);\n\n#include \"ParaNdis-TX.h\"\n#include \"ParaNdis-RX.h\"\n#include \"ParaNdis-CX.h\"\n\nstruct CPUPathesBundle : public CNdisAllocatable<CPUPathesBundle, 'CPPB'> {\n    CParaNdisRX rxPath;\n    bool        rxCreated = false;\n\n    CParaNdisTX txPath;\n    bool        txCreated = false;\n\n    CParaNdisCX *cxPath = NULL;\n} ;\n\n// those stuff defined in NDIS\n//NDIS_MINIPORT_MAJOR_VERSION\n//NDIS_MINIPORT_MINOR_VERSION\n// those stuff defined in build environment\n// PARANDIS_MAJOR_DRIVER_VERSION\n// PARANDIS_MINOR_DRIVER_VERSION\n\n#if !defined(NDIS_MINIPORT_MAJOR_VERSION) || !defined(NDIS_MINIPORT_MINOR_VERSION)\n#error \"Something is wrong with NDIS environment\"\n#endif\n\n#if !defined(PARANDIS_MAJOR_DRIVER_VERSION) || !defined(PARANDIS_MINOR_DRIVER_VERSION)\n#error \"Something is wrong with our versioning\"\n#endif\n\n// define if qemu supports logging to static IO port for synchronization\n// of driver output with qemu printouts; in this case define the port number\n// #define VIRTIO_DBG_USE_IOPORT    0x99\n\n// to be set to real limit later\n#define MAX_RX_LOOPS    1000\n\n/* The feature bitmap for virtio net */\n#define VIRTIO_NET_F_CSUM   0   /* Host handles pkts w/ partial csum */\n#define VIRTIO_NET_F_GUEST_CSUM 1   /* Guest handles pkts w/ partial csum */\n#define VIRTIO_NET_F_CTRL_GUEST_OFFLOADS 2 /* Control channel offload\n                                         * configuration support */\n#define VIRTIO_NET_F_MAC    5   /* Host has given MAC address. */\n#define VIRTIO_NET_F_GSO    6   /* Host handles pkts w/ any GSO type */\n#define VIRTIO_NET_F_GUEST_TSO4 7   /* Guest can handle TSOv4 in. */\n#define VIRTIO_NET_F_GUEST_TSO6 8   /* Guest can handle TSOv6 in. */\n#define VIRTIO_NET_F_GUEST_ECN  9   /* Guest can handle TSO[6] w/ ECN in. */\n#define VIRTIO_NET_F_GUEST_UFO  10  /* Guest can handle UFO in. */\n#define VIRTIO_NET_F_HOST_TSO4  11  /* Host can handle TSOv4 in. */\n#define VIRTIO_NET_F_HOST_TSO6  12  /* Host can handle TSOv6 in. */\n#define VIRTIO_NET_F_HOST_ECN   13  /* Host can handle TSO[6] w/ ECN in. */\n#define VIRTIO_NET_F_HOST_UFO   14  /* Host can handle UFO in. */\n#define VIRTIO_NET_F_MRG_RXBUF  15  /* Host can handle merged Rx buffers and requires bigger header for that. */\n#define VIRTIO_NET_F_STATUS     16\n#define VIRTIO_NET_F_CTRL_VQ    17      /* Control channel available */\n#define VIRTIO_NET_F_CTRL_RX    18      /* Control channel RX mode support */\n#define VIRTIO_NET_F_CTRL_VLAN  19      /* Control channel VLAN filtering */\n#define VIRTIO_NET_F_CTRL_RX_EXTRA 20   /* Extra RX mode control support */\n#define VIRTIO_NET_F_CTRL_MQ    22\n\n#define VIRTIO_NET_F_CTRL_MAC_ADDR   23 /* Set MAC address */\n\n#define VIRTIO_NET_S_LINK_UP    1       /* Link is up */\n\n#define VIRTIO_NET_INVALID_INTERRUPT_STATUS     0xFF\n\n#define PARANDIS_MULTICAST_LIST_SIZE        32\n#define PARANDIS_MEMORY_TAG                 '5muQ'\n#define PARANDIS_FORMAL_LINK_SPEED          (pContext->ulFormalLinkSpeed)\n#define PARANDIS_MAXIMUM_TRANSMIT_SPEED     PARANDIS_FORMAL_LINK_SPEED\n#define PARANDIS_MAXIMUM_RECEIVE_SPEED      PARANDIS_FORMAL_LINK_SPEED\n#define PARANDIS_MIN_LSO_SEGMENTS           2\n// reported\n#define PARANDIS_MAX_LSO_SIZE               0xF800\n\n#define PARANDIS_UNLIMITED_PACKETS_TO_INDICATE  (~0ul)\n\nstatic const ULONG PARANDIS_PACKET_FILTERS =\n    NDIS_PACKET_TYPE_DIRECTED |\n    NDIS_PACKET_TYPE_MULTICAST |\n    NDIS_PACKET_TYPE_BROADCAST |\n    NDIS_PACKET_TYPE_PROMISCUOUS |\n    NDIS_PACKET_TYPE_ALL_MULTICAST;\n\ntypedef VOID (*ONPAUSECOMPLETEPROC)(VOID *);\n\n\ntypedef enum _tagSendReceiveState\n{\n    srsDisabled = 0,        // initial state\n    srsPausing,\n    srsEnabled\n} tSendReceiveState;\n\ntypedef struct _tagAdapterResources\n{\n    ULONG ulIOAddress;\n    ULONG IOLength;\n    ULONG Vector;\n    ULONG Level;\n    KAFFINITY Affinity;\n    ULONG InterruptFlags;\n} tAdapterResources;\n\ntypedef enum _tagOffloadSettingsBit\n{\n    osbT4IpChecksum = (1 << 0),\n    osbT4TcpChecksum = (1 << 1),\n    osbT4UdpChecksum = (1 << 2),\n    osbT4TcpOptionsChecksum = (1 << 3),\n    osbT4IpOptionsChecksum = (1 << 4),\n    osbT4Lso = (1 << 5),\n    osbT4LsoIp = (1 << 6),\n    osbT4LsoTcp = (1 << 7),\n    osbT4RxTCPChecksum = (1 << 8),\n    osbT4RxTCPOptionsChecksum = (1 << 9),\n    osbT4RxIPChecksum = (1 << 10),\n    osbT4RxIPOptionsChecksum = (1 << 11),\n    osbT4RxUDPChecksum = (1 << 12),\n    osbT6TcpChecksum = (1 << 13),\n    osbT6UdpChecksum = (1 << 14),\n    osbT6TcpOptionsChecksum = (1 << 15),\n    osbT6IpExtChecksum = (1 << 16),\n    osbT6Lso = (1 << 17),\n    osbT6LsoIpExt = (1 << 18),\n    osbT6LsoTcpOptions = (1 << 19),\n    osbT6RxTCPChecksum = (1 << 20),\n    osbT6RxTCPOptionsChecksum = (1 << 21),\n    osbT6RxUDPChecksum = (1 << 22),\n    osbT6RxIpExtChecksum = (1 << 23),\n}tOffloadSettingsBit;\n\ntypedef struct _tagOffloadSettingsFlags\n{\n    int fTxIPChecksum       : 1;\n    int fTxTCPChecksum      : 1;\n    int fTxUDPChecksum      : 1;\n    int fTxTCPOptions       : 1;\n    int fTxIPOptions        : 1;\n    int fTxLso              : 1;\n    int fTxLsoIP            : 1;\n    int fTxLsoTCP           : 1;\n    int fRxIPChecksum       : 1;\n    int fRxTCPChecksum      : 1;\n    int fRxUDPChecksum      : 1;\n    int fRxTCPOptions       : 1;\n    int fRxIPOptions        : 1;\n    int fTxTCPv6Checksum    : 1;\n    int fTxUDPv6Checksum    : 1;\n    int fTxTCPv6Options     : 1;\n    int fTxIPv6Ext          : 1;\n    int fTxLsov6            : 1;\n    int fTxLsov6IP          : 1;\n    int fTxLsov6TCP         : 1;\n    int fRxTCPv6Checksum    : 1;\n    int fRxUDPv6Checksum    : 1;\n    int fRxTCPv6Options     : 1;\n    int fRxIPv6Ext          : 1;\n}tOffloadSettingsFlags;\n\n\ntypedef struct _tagOffloadSettings\n{\n    /* current value of enabled offload features */\n    tOffloadSettingsFlags flags;\n    /* load once, do not modify - bitmask of offload features, enabled in configuration */\n    ULONG flagsValue;\n    ULONG ipHeaderOffset;\n    ULONG maxPacketSize;\n}tOffloadSettings;\n\n#pragma warning (push)\n#pragma warning (disable:4201)\ntypedef struct _tagChecksumCheckResult\n{\n    union\n    {\n        struct\n        {\n            int   TcpFailed     :1;\n            int   UdpFailed     :1;\n            int   IpFailed      :1;\n            int   TcpOK         :1;\n            int   UdpOK         :1;\n            int   IpOK          :1;\n        } flags;\n        int value;\n    };\n}tChecksumCheckResult;\n#pragma warning (pop)\n\ntypedef PMDL                tPacketHolderType;\ntypedef PNET_BUFFER_LIST    tPacketIndicationType;\n\ntypedef struct _tagOurCounters\n{\n    UINT nReusedRxBuffers;\n    UINT nPrintDiagnostic;\n    ULONG64 prevIn;\n    UINT nRxInactivity;\n}tOurCounters;\n\ntypedef struct _tagMaxPacketSize\n{\n    UINT nMaxDataSize;\n    UINT nMaxFullSizeOS;\n    UINT nMaxFullSizeHwTx;\n    UINT nMaxDataSizeHwRx;\n    UINT nMaxFullSizeOsRx;\n}tMaxPacketSize;\n\n#define MAX_HW_RX_PACKET_SIZE (MAX_IP4_DATAGRAM_SIZE + ETH_HEADER_SIZE + ETH_PRIORITY_HEADER_SIZE)\n#define MAX_OS_RX_PACKET_SIZE (MAX_IP4_DATAGRAM_SIZE + ETH_HEADER_SIZE)\n\n\ntypedef struct _tagMulticastData\n{\n    ULONG                   nofMulticastEntries;\n    UCHAR                   MulticastList[ETH_LENGTH_OF_ADDRESS * PARANDIS_MULTICAST_LIST_SIZE];\n}tMulticastData;\n\n#pragma warning (push)\n#pragma warning (disable:4201)\ntypedef struct _tagNET_PACKET_INFO\n{\n    struct\n    {\n        int isBroadcast   : 1;\n        int isMulticast   : 1;\n        int isUnicast     : 1;\n        int hasVlanHeader : 1;\n        int isIP4         : 1;\n        int isIP6         : 1;\n        int isTCP         : 1;\n        int isUDP         : 1;\n        int isFragment    : 1;\n    };\n\n    struct\n    {\n        UINT32 UserPriority : 3;\n        UINT32 VlanId       : 12;\n    } Vlan;\n\n#if PARANDIS_SUPPORT_RSS\n    struct\n    {\n        ULONG Value;\n        ULONG Type;\n        ULONG Function;\n    } RSSHash;\n#endif\n\n    ULONG L2HdrLen;\n    ULONG L3HdrLen;\n    ULONG L2PayloadLen;\n    ULONG ip6HomeAddrOffset;\n    ULONG ip6DestAddrOffset;\n\n    PUCHAR ethDestAddr;\n\n    PVOID headersBuffer;\n    ULONG dataLength;\n} NET_PACKET_INFO, *PNET_PACKET_INFO;\n#pragma warning (pop)\n\nstruct _tagRxNetDescriptor {\n    LIST_ENTRY listEntry;\n    LIST_ENTRY ReceiveQueueListEntry;\n\n#define PARANDIS_FIRST_RX_DATA_PAGE   (1)\n    struct VirtIOBufferDescriptor *BufferSGArray;\n    tCompletePhysicalAddress      *PhysicalPages;\n    ULONG                          PagesAllocated;\n    tCompletePhysicalAddress       IndirectArea;\n    tPacketHolderType              Holder;\n\n    NET_PACKET_INFO PacketInfo;\n\n    CParaNdisRX*                   Queue;\n};\n\ntypedef struct _tagPARANDIS_RECEIVE_QUEUE\n{\n    NDIS_SPIN_LOCK          Lock;\n    LIST_ENTRY              BuffersList;\n\n    LONG                    ActiveProcessorsCount;\n} PARANDIS_RECEIVE_QUEUE, *PPARANDIS_RECEIVE_QUEUE;\n\ntypedef struct _tagPARANDIS_ADAPTER\n{\n    NDIS_HANDLE             DriverHandle;\n    NDIS_HANDLE             MiniportHandle;\n    NDIS_HANDLE             InterruptHandle;\n    NDIS_HANDLE             BufferListsPool;\n    NDIS_EVENT              ResetEvent;\n    tAdapterResources       AdapterResources;\n    PVOID                   pIoPortOffset;\n    VirtIODevice            *IODevice;\n    LARGE_INTEGER           LastTxCompletionTimeStamp;\n#ifdef PARANDIS_DEBUG_INTERRUPTS\n    LARGE_INTEGER           LastInterruptTimeStamp;\n#endif\n    u32                     u32HostFeatures;\n    u32                     u32GuestFeatures;\n    BOOLEAN                 bConnected;\n    NDIS_MEDIA_CONNECT_STATE fCurrentLinkState;\n    BOOLEAN                 bEnableInterruptHandlingDPC;\n    BOOLEAN                 bEnableInterruptChecking;\n    BOOLEAN                 bDoSupportPriority;\n    BOOLEAN                 bLinkDetectSupported;\n    BOOLEAN                 bGuestChecksumSupported;\n    BOOLEAN                 bUseMergedBuffers;\n    BOOLEAN                 bDoPublishIndices;\n    BOOLEAN                 bSurprizeRemoved;\n    BOOLEAN                 bUsingMSIX;\n    BOOLEAN                 bUseIndirect;\n    BOOLEAN                 bAnyLaypout;\n    BOOLEAN                 bHasHardwareFilters;\n    BOOLEAN                 bNoPauseOnSuspend;\n    BOOLEAN                 bFastSuspendInProcess;\n    BOOLEAN                 bResetInProgress;\n    BOOLEAN                 bCtrlMACAddrSupported;\n    BOOLEAN                 bCfgMACAddrSupported;\n    BOOLEAN                 bMultiQueue;\n    USHORT                  nHardwareQueues;\n    ULONG                   ulCurrentVlansFilterSet;\n    tMulticastData          MulticastData;\n    UINT                    uNumberOfHandledRXPacketsInDPC;\n    NDIS_DEVICE_POWER_STATE powerState;\n    LONG                    nPendingDPCs;\n    LONG                    counterDPCInside;\n    LONG                    bDPCInactive;\n    ULONG                   ulPriorityVlanSetting;\n    ULONG                   VlanId;\n    ULONGLONG               ulFormalLinkSpeed;\n    ULONG                   ulEnableWakeup;\n    tMaxPacketSize          MaxPacketSize;\n    ULONG                   ulUniqueID;\n    UCHAR                   PermanentMacAddress[ETH_LENGTH_OF_ADDRESS];\n    UCHAR                   CurrentMacAddress[ETH_LENGTH_OF_ADDRESS];\n    ULONG                   PacketFilter;\n    ULONG                   DummyLookAhead;\n    ULONG                   nDetectedStoppedTx;\n    ULONG                   nDetectedInactivity;\n    ULONG                   nVirtioHeaderSize;\n    /* send part */\n    NDIS_STATISTICS_INFO    Statistics;\n    struct\n    {\n        ULONG framesCSOffload;\n        ULONG framesLSO;\n        ULONG framesIndirect;\n        ULONG framesRxPriority;\n        ULONG framesRxCSHwOK;\n        ULONG framesRxCSHwMissedBad;\n        ULONG framesRxCSHwMissedGood;\n        ULONG framesFilteredOut;\n    } extraStatistics;\n    tOurCounters            Counters;\n    tOurCounters            Limits;\n    tSendReceiveState       SendState;\n    tSendReceiveState       ReceiveState;\n    ONPAUSECOMPLETEPROC     SendPauseCompletionProc;\n    ONPAUSECOMPLETEPROC     ReceivePauseCompletionProc;\n\n    CNdisRWLock             m_PauseLock;\n    CNdisRefCounter         m_upstreamPacketPending;\n\n    LONG                    ReuseBufferRegular;\n    /* initial number of free Tx descriptor(from cfg) - max number of available Tx descriptors */\n    UINT                    maxFreeTxDescriptors;\n    /* total of Rx buffer in turnaround */\n    UINT                    NetMaxReceiveBuffers;\n    UINT                    nPnpEventIndex;\n    NDIS_DEVICE_PNP_EVENT   PnpEvents[16];\n    tOffloadSettings        Offload;\n    NDIS_OFFLOAD_PARAMETERS InitialOffloadParameters;\n\n    PARANDIS_RECEIVE_QUEUE      ReceiveQueues[PARANDIS_RSS_MAX_RECEIVE_QUEUES + 1];\n    BOOLEAN                     ReceiveQueuesInitialized;\n#define PARANDIS_RECEIVE_QUEUE_UNCLASSIFIED (0)\n#define PARANDIS_FIRST_RSS_RECEIVE_QUEUE    (1)\n\n    CParaNdisCX CXPath;\n    BOOLEAN bCXPathAllocated;\n    BOOLEAN bCXPathCreated;\n\n    CPUPathesBundle             *pPathBundles;\n    UINT                        nPathBundles;\n\n    CPUPathesBundle            **RSS2QueueMap;\n    USHORT                      RSS2QueueLength;\n\n    PIO_INTERRUPT_MESSAGE_INFO  pMSIXInfoTable;\n    NDIS_HANDLE                 DmaHandle;\n    ULONG                       ulIrqReceived;\n    NDIS_OFFLOAD                ReportedOffloadCapabilities;\n    NDIS_OFFLOAD                ReportedOffloadConfiguration;\n    BOOLEAN                     bOffloadv4Enabled;\n    BOOLEAN                     bOffloadv6Enabled;\n    BOOLEAN                     bDeviceInitialized;\n\n#if PARANDIS_SUPPORT_RSS\n    BOOLEAN                     bRSSOffloadSupported;\n    BOOLEAN                     bRSSInitialized;\n    NDIS_RECEIVE_SCALE_CAPABILITIES RSSCapabilities;\n    PARANDIS_RSS_PARAMS         RSSParameters;\n    CCHAR                       RSSMaxQueuesNumber;\n#endif\n\n#if PARANDIS_SUPPORT_RSC\n    struct {\n        BOOLEAN                     bIPv4SupportedSW;\n        BOOLEAN                     bIPv6SupportedSW;\n        BOOLEAN                     bIPv4SupportedHW;\n        BOOLEAN                     bIPv6SupportedHW;\n        BOOLEAN                     bIPv4Enabled;\n        BOOLEAN                     bIPv6Enabled;\n        BOOLEAN                     bHasDynamicConfig;\n        struct {\n            LARGE_INTEGER           CoalescedPkts;\n            LARGE_INTEGER           CoalescedOctets;\n            LARGE_INTEGER           CoalesceEvents;\n        }                           Statistics;\n    } RSC;\n#endif\n\n    _tagPARANDIS_ADAPTER(const _tagPARANDIS_ADAPTER&) = delete;\n    _tagPARANDIS_ADAPTER& operator= (const _tagPARANDIS_ADAPTER&) = delete;\n}PARANDIS_ADAPTER, *PPARANDIS_ADAPTER;\n\ntypedef struct _tagSynchronizedContext\n{\n    PARANDIS_ADAPTER    *pContext;\n    PVOID               Parameter;\n}tSynchronizedContext;\n\ntypedef BOOLEAN _Function_class_(MINIPORT_SYNCHRONIZE_INTERRUPT) (*tSynchronizedProcedure)(tSynchronizedContext *context);\n\nBOOLEAN FORCEINLINE IsValidVlanId(PARANDIS_ADAPTER *pContext, ULONG VlanID)\n{\n    return pContext->VlanId == 0 || pContext->VlanId == VlanID;\n}\n\nBOOLEAN FORCEINLINE IsVlanSupported(PARANDIS_ADAPTER *pContext)\n{\n    return pContext->ulPriorityVlanSetting & 2;\n}\n\nBOOLEAN FORCEINLINE IsPrioritySupported(PARANDIS_ADAPTER *pContext)\n{\n    return pContext->ulPriorityVlanSetting & 1;\n}\n\nBOOLEAN ParaNdis_ValidateMacAddress(\n    PUCHAR pcMacAddress,\n    BOOLEAN bLocal);\n\nNDIS_STATUS ParaNdis_InitializeContext(\n    PARANDIS_ADAPTER *pContext,\n    PNDIS_RESOURCE_LIST ResourceList);\n\nNDIS_STATUS ParaNdis_FinishInitialization(\n    PARANDIS_ADAPTER *pContext);\n\nNDIS_STATUS ParaNdis_ConfigureMSIXVectors(\n    PARANDIS_ADAPTER *pContext);\n\nVOID ParaNdis_CleanupContext(\n    PARANDIS_ADAPTER *pContext);\n\nbool ParaNdis_DPCWorkBody(\n    PARANDIS_ADAPTER *pContext,\n    ULONG ulMaxPacketsToIndicate);\n\nVOID ParaNdis_ResetRxClassification(\n    PARANDIS_ADAPTER *pContext);\n\nNDIS_STATUS ParaNdis_SetMulticastList(\n    PARANDIS_ADAPTER *pContext,\n    PVOID Buffer,\n    ULONG BufferSize,\n    PUINT pBytesRead,\n    PUINT pBytesNeeded);\n\nVOID ParaNdis_VirtIOEnableIrqSynchronized(\n    PARANDIS_ADAPTER *pContext,\n    ULONG interruptSource);\n\nVOID ParaNdis_VirtIODisableIrqSynchronized(\n    PARANDIS_ADAPTER *pContext,\n    ULONG interruptSource);\n\nvoid ParaNdis_DeleteQueue(\n    PARANDIS_ADAPTER *pContext, \n    struct virtqueue **ppq,\n    tCompletePhysicalAddress *ppa);\n\nvoid ParaNdis_FreeRxBufferDescriptor(\n    PARANDIS_ADAPTER *pContext,\n    pRxNetDescriptor p);\n\nBOOLEAN ParaNdis_PerformPacketAnalyzis(\n#if PARANDIS_SUPPORT_RSS\n    PPARANDIS_RSS_PARAMS RSSParameters,\n#endif\n    PNET_PACKET_INFO PacketInfo,\n    PVOID HeadersBuffer,\n    ULONG DataLength);\n\nCCHAR ParaNdis_GetScalingDataForPacket(\n    PARANDIS_ADAPTER *pContext,\n    PNET_PACKET_INFO pPacketInfo,\n    PPROCESSOR_NUMBER pTargetProcessor);\n\n#if PARANDIS_SUPPORT_RSS\nNDIS_STATUS ParaNdis_SetupRSSQueueMap(PARANDIS_ADAPTER *pContext);\n#endif\n\nVOID ParaNdis_ReceiveQueueAddBuffer(\n    PPARANDIS_RECEIVE_QUEUE pQueue,\n    pRxNetDescriptor pBuffer);\n\nVOID ParaMdis_TestPausing(\n    PARANDIS_ADAPTER *pContext);\n\nVOID ParaNdis_ProcessorNumberToGroupAffinity(\n    PGROUP_AFFINITY Affinity,\n    const PPROCESSOR_NUMBER Processor);\n\nVOID ParaNdis_QueueRSSDpc(\n    PARANDIS_ADAPTER *pContext,\n    PGROUP_AFFINITY pTargetAffinity);\n\n\n\n\n\n\nstatic __inline BOOLEAN\nParaNDIS_IsQueueInterruptEnabled(struct virtqueue * _vq)\n{\n    return virtqueue_is_interrupt_enabled(_vq);\n}\n\n\nvoid ParaNdis_FreeRxBufferDescriptor(\n    PARANDIS_ADAPTER *pContext,\n    pRxNetDescriptor p);\n\nBOOLEAN ParaNdis_PerformPacketAnalyzis(\n#if PARANDIS_SUPPORT_RSS\n    PPARANDIS_RSS_PARAMS RSSParameters,\n#endif\n    PNET_PACKET_INFO PacketInfo,\n    PVOID HeadersBuffer,\n    ULONG DataLength);\n\nCCHAR ParaNdis_GetScalingDataForPacket(\n    PARANDIS_ADAPTER *pContext,\n    PNET_PACKET_INFO pPacketInfo,\n    PPROCESSOR_NUMBER pTargetProcessor);\n\nVOID ParaNdis_ReceiveQueueAddBuffer(\n    PPARANDIS_RECEIVE_QUEUE pQueue,\n    pRxNetDescriptor pBuffer);\n\nVOID ParaNdis_ProcessorNumberToGroupAffinity(\n    PGROUP_AFFINITY Affinity,\n    const PPROCESSOR_NUMBER Processor);\n\nVOID ParaNdis_QueueRSSDpc(\n    PARANDIS_ADAPTER *pContext,\n    ULONG MessageIndex,\n    PGROUP_AFFINITY pTargetAffinity);\n\nVOID ParaNdis_OnPnPEvent(\n    PARANDIS_ADAPTER *pContext,\n    NDIS_DEVICE_PNP_EVENT pEvent,\n    PVOID   pInfo,\n    ULONG   ulSize);\n\nBOOLEAN ParaNdis_OnLegacyInterrupt(\n    PARANDIS_ADAPTER *pContext,\n    BOOLEAN *pRunDpc);\n\nBOOLEAN ParaNdis_OnQueuedInterrupt(\n    PARANDIS_ADAPTER *pContext,\n    BOOLEAN *pRunDpc,\n    ULONG knownInterruptSources);\n\nVOID ParaNdis_OnShutdown(\n    PARANDIS_ADAPTER *pContext);\n\nBOOLEAN ParaNdis_CheckForHang(\n    PARANDIS_ADAPTER *pContext);\n\nVOID ParaNdis_PowerOn(\n    PARANDIS_ADAPTER *pContext\n);\n\nVOID ParaNdis_PowerOff(\n    PARANDIS_ADAPTER *pContext\n);\n\n#if PARANDIS_SUPPORT_RSC\nVOID ParaNdis_UpdateGuestOffloads(\n    PARANDIS_ADAPTER *pContext,\n    UINT64 Offloads\n);\n#endif\n\nvoid ParaNdis_DebugInitialize();\nvoid ParaNdis_DebugCleanup(PDRIVER_OBJECT  pDriverObject);\nvoid ParaNdis_DebugRegisterMiniport(PARANDIS_ADAPTER *pContext, BOOLEAN bRegister);\n\n\n//#define ENABLE_HISTORY_LOG\n#if !defined(ENABLE_HISTORY_LOG)\n\nvoid FORCEINLINE ParaNdis_DebugHistory(\n    PARANDIS_ADAPTER *pContext,\n    eHistoryLogOperation op,\n    PVOID pParam1,\n    ULONG lParam2,\n    ULONG lParam3,\n    ULONG lParam4)\n{\n    UNREFERENCED_PARAMETER(pContext);\n    UNREFERENCED_PARAMETER(op);\n    UNREFERENCED_PARAMETER(pParam1);\n    UNREFERENCED_PARAMETER(lParam2);\n    UNREFERENCED_PARAMETER(lParam3);\n    UNREFERENCED_PARAMETER(lParam4);\n}\n\n#else\n\nvoid ParaNdis_DebugHistory(\n    PARANDIS_ADAPTER *pContext,\n    eHistoryLogOperation op,\n    PVOID pParam1,\n    ULONG lParam2,\n    ULONG lParam3,\n    ULONG lParam4);\n\n#endif\n\nvoid ParaNdis_ResetOffloadSettings(PARANDIS_ADAPTER *pContext, tOffloadSettingsFlags *pDest, PULONG from);\n\ntChecksumCheckResult ParaNdis_CheckRxChecksum(\n                                            PARANDIS_ADAPTER *pContext,\n                                            ULONG virtioFlags,\n                                            tCompletePhysicalAddress *pPacketPages,\n                                            ULONG ulPacketLength,\n                                            ULONG ulDataOffset);\n\nvoid ParaNdis_CallOnBugCheck(PARANDIS_ADAPTER *pContext);\n\n/*****************************************************\nProcedures to implement for NDIS specific implementation\n******************************************************/\n\nPVOID ParaNdis_AllocateMemory(\n    PARANDIS_ADAPTER *pContext,\n    ULONG ulRequiredSize);\n\nPVOID ParaNdis_AllocateMemoryRaw(\n    NDIS_HANDLE MiniportHandle,\n    ULONG ulRequiredSize);\n\nNDIS_STATUS ParaNdis_FinishSpecificInitialization(\n    PARANDIS_ADAPTER *pContext);\n\nVOID ParaNdis_FinalizeCleanup(\n    PARANDIS_ADAPTER *pContext);\n\nNDIS_HANDLE ParaNdis_OpenNICConfiguration(\n    PARANDIS_ADAPTER *pContext);\n\ntPacketIndicationType ParaNdis_PrepareReceivedPacket(\n    PARANDIS_ADAPTER *pContext,\n    pRxNetDescriptor pBufferDesc,\n    PUINT            pnCoalescedSegmentsCount);\n\nBOOLEAN ParaNdis_SynchronizeWithInterrupt(\n    PARANDIS_ADAPTER *pContext,\n    ULONG messageId,\n    tSynchronizedProcedure procedure,\n    PVOID parameter);\n\nVOID ParaNdis_Suspend(\n    PARANDIS_ADAPTER *pContext);\n\nVOID ParaNdis_Resume(\n    PARANDIS_ADAPTER *pContext);\n\ntypedef VOID (*tOnAdditionalPhysicalMemoryAllocated)(\n    PARANDIS_ADAPTER *pContext,\n    tCompletePhysicalAddress *pAddresses);\n\n\ntypedef struct _tagPhysicalAddressAllocationContext\n{\n    tCompletePhysicalAddress address;\n    PARANDIS_ADAPTER *pContext;\n    tOnAdditionalPhysicalMemoryAllocated Callback;\n} tPhysicalAddressAllocationContext;\n\n\nBOOLEAN ParaNdis_InitialAllocatePhysicalMemory(\n    PARANDIS_ADAPTER *pContext,\n    tCompletePhysicalAddress *pAddresses);\n\nBOOLEAN ParaNdis_RuntimeRequestToAllocatePhysicalMemory(\n    PARANDIS_ADAPTER *pContext,\n    tCompletePhysicalAddress *pAddresses,\n    tOnAdditionalPhysicalMemoryAllocated Callback\n    );\n\nVOID ParaNdis_FreePhysicalMemory(\n    PARANDIS_ADAPTER *pContext,\n    tCompletePhysicalAddress *pAddresses);\n\nBOOLEAN ParaNdis_BindRxBufferToPacket(\n    PARANDIS_ADAPTER *pContext,\n    pRxNetDescriptor p);\n\nvoid ParaNdis_UnbindRxBufferFromPacket(\n    pRxNetDescriptor p);\n\nvoid ParaNdis_RestoreDeviceConfigurationAfterReset(\n    PARANDIS_ADAPTER *pContext);\n\nVOID ParaNdis_UpdateDeviceFilters(\n    PARANDIS_ADAPTER *pContext);\n\nVOID ParaNdis_DeviceFiltersUpdateVlanId(\n    PARANDIS_ADAPTER *pContext);\n\nVOID ParaNdis_SetPowerState(\n    PARANDIS_ADAPTER *pContext,\n    NDIS_DEVICE_POWER_STATE newState);\n\nVOID ParaNdis_SynchronizeLinkState(\n    PARANDIS_ADAPTER *pContext);\n\nVOID ParaNdis_SetLinkState(\n    PARANDIS_ADAPTER *pContext,\n    NDIS_MEDIA_CONNECT_STATE LinkState);\n\n#endif //-OFFLOAD_UNIT_TEST\n\ntypedef enum _tagppResult\n{\n    ppresNotTested = 0,\n    ppresNotIP     = 1,\n    ppresIPV4      = 2,\n    ppresIPV6      = 3,\n    ppresIPTooShort  = 1,\n    ppresPCSOK       = 1,\n    ppresCSOK        = 2,\n    ppresCSBad       = 3,\n    ppresXxpOther    = 1,\n    ppresXxpKnown    = 2,\n    ppresXxpIncomplete = 3,\n    ppresIsTCP         = 0,\n    ppresIsUDP         = 1,\n}ppResult;\n\n#pragma warning (push)\n#pragma warning (disable:4201) //nonstandard extension used : nameless struct/union\n#pragma warning (disable:4214) //nonstandard extension used : bit field types other than int\ntypedef union _tagTcpIpPacketParsingResult\n{\n    struct {\n        /* 0 - not tested, 1 - not IP, 2 - IPV4, 3 - IPV6 */\n        ULONG ipStatus        : 2;\n        /* 0 - not tested, 1 - n/a, 2 - CS, 3 - bad */\n        ULONG ipCheckSum      : 2;\n        /* 0 - not tested, 1 - PCS, 2 - CS, 3 - bad */\n        ULONG xxpCheckSum     : 2;\n        /* 0 - not tested, 1 - other, 2 - known(contains basic TCP or UDP header), 3 - known incomplete */\n        ULONG xxpStatus       : 2;\n        /* 1 - contains complete payload */\n        ULONG xxpFull         : 1;\n        ULONG TcpUdp          : 1;\n        ULONG fixedIpCS       : 1;\n        ULONG fixedXxpCS      : 1;\n        ULONG IsFragment      : 1;\n        ULONG reserved        : 3;\n        ULONG ipHeaderSize    : 8;\n        ULONG XxpIpHeaderSize : 8;\n    };\n    ULONG value;\n}tTcpIpPacketParsingResult;\n#pragma warning(pop)\n\ntypedef enum _tagPacketOffloadRequest\n{\n    pcrIpChecksum  = (1 << 0),\n    pcrTcpV4Checksum = (1 << 1),\n    pcrUdpV4Checksum = (1 << 2),\n    pcrTcpV6Checksum = (1 << 3),\n    pcrUdpV6Checksum = (1 << 4),\n    pcrTcpChecksum = (pcrTcpV4Checksum | pcrTcpV6Checksum),\n    pcrUdpChecksum = (pcrUdpV4Checksum | pcrUdpV6Checksum),\n    pcrAnyChecksum = (pcrIpChecksum | pcrTcpV4Checksum | pcrUdpV4Checksum | pcrTcpV6Checksum | pcrUdpV6Checksum),\n    pcrLSO   = (1 << 5),\n    pcrIsIP  = (1 << 6),\n    pcrFixIPChecksum = (1 << 7),\n    pcrFixPHChecksum = (1 << 8),\n    pcrFixTcpV4Checksum = (1 << 9),\n    pcrFixUdpV4Checksum = (1 << 10),\n    pcrFixTcpV6Checksum = (1 << 11),\n    pcrFixUdpV6Checksum = (1 << 12),\n    pcrFixXxpChecksum = (pcrFixTcpV4Checksum | pcrFixUdpV4Checksum | pcrFixTcpV6Checksum | pcrFixUdpV6Checksum),\n    pcrPriorityTag = (1 << 13),\n    pcrNoIndirect  = (1 << 14)\n}tPacketOffloadRequest;\n\n// sw offload\n\ntTcpIpPacketParsingResult ParaNdis_CheckSumVerify(\n                                                tCompletePhysicalAddress *pDataPages,\n                                                ULONG ulDataLength,\n                                                ULONG ulStartOffset,\n                                                ULONG flags,\n                                                LPCSTR caller);\n\nstatic __inline\ntTcpIpPacketParsingResult ParaNdis_CheckSumVerifyFlat(\n                                                PVOID pBuffer,\n                                                ULONG ulDataLength,\n                                                ULONG flags,\n                                                LPCSTR caller)\n{\n    tCompletePhysicalAddress SGBuffer;\n    SGBuffer.Virtual = pBuffer;\n    SGBuffer.size = ulDataLength;\n    return ParaNdis_CheckSumVerify(&SGBuffer, ulDataLength, 0, flags, caller);\n}\n\ntTcpIpPacketParsingResult ParaNdis_ReviewIPPacket(PVOID buffer, ULONG size, LPCSTR caller);\n\nBOOLEAN ParaNdis_AnalyzeReceivedPacket(PVOID headersBuffer, ULONG dataLength, PNET_PACKET_INFO packetInfo);\nULONG ParaNdis_StripVlanHeaderMoveHead(PNET_PACKET_INFO packetInfo);\nVOID ParaNdis_PadPacketToMinimalLength(PNET_PACKET_INFO packetInfo);\nBOOLEAN ParaNdis_IsSendPossible(PARANDIS_ADAPTER *pContext);\nNDIS_STATUS ParaNdis_ExactSendFailureStatus(PARANDIS_ADAPTER *pContext);\n\n#endif\n", "/**********************************************************************\n * Copyright (c) 2008  Red Hat, Inc.\n *\n * File: sw-offload.c\n *\n * This file contains SW Implementation of checksum computation for IP,TCP,UDP\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n**********************************************************************/\n#include \"ndis56common.h\"\n\n// till IP header size is 8 bit\n#define MAX_SUPPORTED_IPV6_HEADERS  (256 - 4)\n\n// IPv6 Header RFC 2460 (n*8 bytes)\ntypedef struct _tagIPv6ExtHeader {\n    UCHAR       ip6ext_next_header;     // next header type\n    UCHAR       ip6ext_hdr_len;         // length of this header in 8 bytes unit, not including first 8 bytes\n    USHORT      options;                // \n} IPv6ExtHeader;\n\n// IP Pseudo Header RFC 768\ntypedef struct _tagIPv4PseudoHeader {\n    ULONG       ipph_src;               // Source address\n    ULONG       ipph_dest;              // Destination address\n    UCHAR       ipph_zero;              // 0\n    UCHAR       ipph_protocol;          // TCP/UDP\n    USHORT      ipph_length;            // TCP/UDP length\n}tIPv4PseudoHeader;\n\n// IPv6 Pseudo Header RFC 2460\ntypedef struct _tagIPv6PseudoHeader {\n    IPV6_ADDRESS ipph_src;              // Source address\n    IPV6_ADDRESS ipph_dest;             // Destination address\n    ULONG        ipph_length;               // TCP/UDP length\n    UCHAR        z1;                // 0\n    UCHAR        z2;                // 0\n    UCHAR        z3;                // 0\n    UCHAR        ipph_protocol;             // TCP/UDP\n}tIPv6PseudoHeader;\n\n// IP v6 extension header option\ntypedef struct _tagIP6_EXT_HDR_OPTION\n{\n    UCHAR Type;\n    UCHAR Length;\n} IP6_EXT_HDR_OPTION, *PIP6_EXT_HDR_OPTION;\n\n#define IP6_EXT_HDR_OPTION_PAD1         (0)\n#define IP6_EXT_HDR_OPTION_HOME_ADDR    (201)\n\n// IP v6 routing header\ntypedef struct _tagIP6_TYPE2_ROUTING_HEADER\n{\n    UCHAR           NextHdr;\n    UCHAR           HdrLen;\n    UCHAR           RoutingType;\n    UCHAR           SegmentsLeft;\n    ULONG           Reserved;\n    IPV6_ADDRESS    Address;\n} IP6_TYPE2_ROUTING_HEADER, *PIP6_TYPE2_ROUTING_HEADER;\n\n#define PROTOCOL_TCP                    6\n#define PROTOCOL_UDP                    17\n\n#define IP_HEADER_LENGTH(pHeader)       (((pHeader)->ip_verlen & 0x0F) << 2)\n#define IP_HEADER_VERSION(pHeader)      (((pHeader)->ip_verlen & 0xF0) >> 4)\n#define IP_HEADER_IS_FRAGMENT(pHeader)  (((pHeader)->ip_offset & ~0xC0) != 0)\n\n#define IP6_HEADER_VERSION(pHeader)     (((pHeader)->ip6_ver_tc & 0xF0) >> 4)\n\n#define ETH_GET_VLAN_HDR(ethHdr)        ((PVLAN_HEADER) RtlOffsetToPointer(ethHdr, ETH_PRIORITY_HEADER_OFFSET))\n#define VLAN_GET_USER_PRIORITY(vlanHdr) ( (((PUCHAR)(vlanHdr))[2] & 0xE0) >> 5 )\n#define VLAN_GET_VLAN_ID(vlanHdr)       ( ((USHORT) (((PUCHAR)(vlanHdr))[2] & 0x0F) << 8) | ( ((PUCHAR)(vlanHdr))[3] ) )\n\n#define ETH_PROTO_IP4 (0x0800)\n#define ETH_PROTO_IP6 (0x86DD)\n\n#define IP6_HDR_HOP_BY_HOP        (0)\n#define IP6_HDR_ROUTING           (43)\n#define IP6_HDR_FRAGMENT          (44)\n#define IP6_HDR_ESP               (50)\n#define IP6_HDR_AUTHENTICATION    (51)\n#define IP6_HDR_NONE              (59)\n#define IP6_HDR_DESTINATON        (60)\n#define IP6_HDR_MOBILITY          (135)\n\n#define IP6_EXT_HDR_GRANULARITY   (8)\n\nstatic UINT32 RawCheckSumCalculator(PVOID buffer, ULONG len)\n{\n    UINT32 val = 0;\n    PUSHORT pus = (PUSHORT)buffer;\n    ULONG count = len >> 1;\n    while (count--) val += *pus++;\n    if (len & 1) val += (USHORT)*(PUCHAR)pus;\n    return val;\n}\n\nstatic __inline USHORT RawCheckSumFinalize(UINT32 val)\n{\n    val = (((val >> 16) | (val << 16)) + val) >> 16;\n    return (USHORT)~val;\n}\n\nstatic __inline USHORT CheckSumCalculatorFlat(PVOID buffer, ULONG len)\n{\n    return RawCheckSumFinalize(RawCheckSumCalculator(buffer, len));\n}\n\nstatic __inline USHORT CheckSumCalculator(tCompletePhysicalAddress *pDataPages, ULONG ulStartOffset, ULONG len)\n{\n    tCompletePhysicalAddress *pCurrentPage = &pDataPages[0];\n    ULONG ulCurrPageOffset = 0;\n    UINT32 u32RawCSum = 0;\n\n    while(ulStartOffset > 0)\n    {\n        ulCurrPageOffset = min(pCurrentPage->size, ulStartOffset);\n\n        if(ulCurrPageOffset < ulStartOffset)\n            pCurrentPage++;\n\n        ulStartOffset -= ulCurrPageOffset;\n    }\n\n    while(len > 0)\n    {\n        PVOID pCurrentPageDataStart = RtlOffsetToPointer(pCurrentPage->Virtual, ulCurrPageOffset);\n        ULONG ulCurrentPageDataLength = min(len, pCurrentPage->size - ulCurrPageOffset);\n\n        u32RawCSum += RawCheckSumCalculator(pCurrentPageDataStart, ulCurrentPageDataLength);\n        pCurrentPage++;\n        ulCurrPageOffset = 0;\n        len -= ulCurrentPageDataLength;\n    }\n\n    return RawCheckSumFinalize(u32RawCSum);\n}\n\n\n/******************************************\n    IP header checksum calculator\n*******************************************/\nstatic __inline VOID CalculateIpChecksum(IPv4Header *pIpHeader)\n{\n    pIpHeader->ip_xsum = 0;\n    pIpHeader->ip_xsum = CheckSumCalculatorFlat(pIpHeader, IP_HEADER_LENGTH(pIpHeader));\n}\n\nstatic __inline tTcpIpPacketParsingResult\nProcessTCPHeader(tTcpIpPacketParsingResult _res, PVOID pIpHeader, ULONG len, USHORT ipHeaderSize)\n{\n    ULONG tcpipDataAt;\n    tTcpIpPacketParsingResult res = _res;\n    tcpipDataAt = ipHeaderSize + sizeof(TCPHeader);\n    res.TcpUdp = ppresIsTCP;\n\n    if (len >= tcpipDataAt)\n    {\n        TCPHeader *pTcpHeader = (TCPHeader *)RtlOffsetToPointer(pIpHeader, ipHeaderSize);\n        res.xxpStatus = ppresXxpKnown;\n        res.xxpFull = TRUE;\n        tcpipDataAt = ipHeaderSize + TCP_HEADER_LENGTH(pTcpHeader);\n        res.XxpIpHeaderSize = tcpipDataAt;\n    }\n    else\n    {\n        DPrintf(2, (\"tcp: %d < min headers %d\\n\", len, tcpipDataAt));\n        res.xxpFull = FALSE;\n        res.xxpStatus = ppresXxpIncomplete;\n    }\n    return res;\n}\n\nstatic __inline tTcpIpPacketParsingResult\nProcessUDPHeader(tTcpIpPacketParsingResult _res, PVOID pIpHeader, ULONG len, USHORT ipHeaderSize)\n{\n    tTcpIpPacketParsingResult res = _res;\n    ULONG udpDataStart = ipHeaderSize + sizeof(UDPHeader);\n    res.TcpUdp = ppresIsUDP;\n    res.XxpIpHeaderSize = udpDataStart;\n    if (len >= udpDataStart)\n    {\n        UDPHeader *pUdpHeader = (UDPHeader *)RtlOffsetToPointer(pIpHeader, ipHeaderSize);\n        USHORT datagramLength = swap_short(pUdpHeader->udp_length);\n        res.xxpStatus = ppresXxpKnown;\n        res.xxpFull = TRUE;\n        // may be full or not, but the datagram length is known\n        DPrintf(2, (\"udp: len %d, datagramLength %d\\n\", len, datagramLength));\n    }\n    else\n    {\n        res.xxpFull = FALSE;\n        res.xxpStatus = ppresXxpIncomplete;\n    }\n    return res;\n}\n\nstatic __inline tTcpIpPacketParsingResult\nQualifyIpPacket(IPHeader *pIpHeader, ULONG len)\n{\n    tTcpIpPacketParsingResult res;\n    res.value = 0;\n\n    if (len < 4)\n    {\n        res.ipStatus = ppresNotIP;\n        return res;\n    }\n\n    UCHAR  ver_len = pIpHeader->v4.ip_verlen;\n    UCHAR  ip_version = (ver_len & 0xF0) >> 4;\n    USHORT ipHeaderSize = 0;\n    USHORT fullLength = 0;\n    res.value = 0;\n\n    if (ip_version == 4)\n    {\n        if (len < sizeof(IPv4Header))\n        {\n            res.ipStatus = ppresNotIP;\n            return res;\n        }\n        ipHeaderSize = (ver_len & 0xF) << 2;\n        fullLength = swap_short(pIpHeader->v4.ip_length);\n        DPrintf(3, (\"ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d\\n\",\n            ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len));\n\n        res.ipStatus = (ipHeaderSize >= sizeof(IPv4Header)) ? ppresIPV4 : ppresNotIP;\n        if (res.ipStatus == ppresNotIP)\n        {\n            return res;\n        }\n\n        if (ipHeaderSize >= fullLength || len < fullLength)\n        {\n            DPrintf(2, (\"[%s] - truncated packet - ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d\\n\", __FUNCTION__,\n                ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len));\n            res.ipCheckSum = ppresIPTooShort;\n            return res;\n        }\n    }\n    else if (ip_version == 6)\n    {\n        if (len < sizeof(IPv6Header))\n        {\n            res.ipStatus = ppresNotIP;\n            return res;\n        }\n\n        UCHAR nextHeader = pIpHeader->v6.ip6_next_header;\n        BOOLEAN bParsingDone = FALSE;\n        ipHeaderSize = sizeof(pIpHeader->v6);\n        res.ipStatus = ppresIPV6;\n        res.ipCheckSum = ppresCSOK;\n        fullLength = swap_short(pIpHeader->v6.ip6_payload_len);\n        fullLength += ipHeaderSize;\n        if (len < fullLength)\n        {\n            res.ipStatus = ppresNotIP;\n            return res;\n        }\n        while (nextHeader != 59)\n        {\n            IPv6ExtHeader *pExt;\n            switch (nextHeader)\n            {\n                case PROTOCOL_TCP:\n                    bParsingDone = TRUE;\n                    res.xxpStatus = ppresXxpKnown;\n                    res.TcpUdp = ppresIsTCP;\n                    res.xxpFull = len >= fullLength ? 1 : 0;\n                    res = ProcessTCPHeader(res, pIpHeader, len, ipHeaderSize);\n                    break;\n                case PROTOCOL_UDP:\n                    bParsingDone = TRUE;\n                    res.xxpStatus = ppresXxpKnown;\n                    res.TcpUdp = ppresIsUDP;\n                    res.xxpFull = len >= fullLength ? 1 : 0;\n                    res = ProcessUDPHeader(res, pIpHeader, len, ipHeaderSize);\n                    break;\n                    //existing extended headers\n                case 0:\n                case 60:\n                case 43:\n                case 44:\n                case 51:\n                case 50:\n                case 135:\n                    if (len >= ((ULONG)ipHeaderSize + 8))\n                    {\n                        pExt = (IPv6ExtHeader *)((PUCHAR)pIpHeader + ipHeaderSize);\n                        nextHeader = pExt->ip6ext_next_header;\n                        ipHeaderSize += 8;\n                        ipHeaderSize += pExt->ip6ext_hdr_len * 8;\n                    }\n                    else\n                    {\n                        DPrintf(0, (\"[%s] ERROR: Break in the middle of ext. headers(len %d, hdr > %d)\\n\", __FUNCTION__, len, ipHeaderSize));\n                        res.ipStatus = ppresNotIP;\n                        bParsingDone = TRUE;\n                    }\n                    break;\n                    //any other protocol\n                default:\n                    res.xxpStatus = ppresXxpOther;\n                    bParsingDone = TRUE;\n                    break;\n            }\n            if (bParsingDone)\n                break;\n        }\n        if (ipHeaderSize <= MAX_SUPPORTED_IPV6_HEADERS)\n        {\n            DPrintf(3, (\"ip_version %d, ipHeaderSize %d, protocol %d, iplen %d\\n\",\n                ip_version, ipHeaderSize, nextHeader, fullLength));\n            res.ipHeaderSize = ipHeaderSize;\n        }\n        else\n        {\n            DPrintf(0, (\"[%s] ERROR: IP chain is too large (%d)\\n\", __FUNCTION__, ipHeaderSize));\n            res.ipStatus = ppresNotIP;\n        }\n    }\n    \n    if (res.ipStatus == ppresIPV4)\n    {\n        res.ipHeaderSize = ipHeaderSize;\n\n        // bit \"more fragments\" or fragment offset mean the packet is fragmented\n        res.IsFragment = (pIpHeader->v4.ip_offset & ~0xC0) != 0;\n        switch (pIpHeader->v4.ip_protocol)\n        {\n            case PROTOCOL_TCP:\n            {\n                res = ProcessTCPHeader(res, pIpHeader, len, ipHeaderSize);\n            }\n            break;\n        case PROTOCOL_UDP:\n            {\n                res = ProcessUDPHeader(res, pIpHeader, len, ipHeaderSize);\n            }\n            break;\n        default:\n            res.xxpStatus = ppresXxpOther;\n            break;\n        }\n    }\n    return res;\n}\n\nstatic __inline USHORT GetXxpHeaderAndPayloadLen(IPHeader *pIpHeader, tTcpIpPacketParsingResult res)\n{\n    if (res.ipStatus == ppresIPV4)\n    {\n        USHORT headerLength = IP_HEADER_LENGTH(&pIpHeader->v4);\n        USHORT len = swap_short(pIpHeader->v4.ip_length);\n        return len - headerLength;          \n    }\n    if (res.ipStatus == ppresIPV6)\n    {\n        USHORT fullLength = swap_short(pIpHeader->v6.ip6_payload_len);\n        return fullLength + sizeof(pIpHeader->v6) - (USHORT)res.ipHeaderSize;\n    }\n    return 0;\n}\n\nstatic __inline USHORT CalculateIpv4PseudoHeaderChecksum(IPv4Header *pIpHeader, USHORT headerAndPayloadLen)\n{\n    tIPv4PseudoHeader ipph;\n    USHORT checksum;\n    ipph.ipph_src  = pIpHeader->ip_src;\n    ipph.ipph_dest = pIpHeader->ip_dest;\n    ipph.ipph_zero = 0;\n    ipph.ipph_protocol = pIpHeader->ip_protocol;\n    ipph.ipph_length = swap_short(headerAndPayloadLen);\n    checksum = CheckSumCalculatorFlat(&ipph, sizeof(ipph));\n    return ~checksum;\n}\n\n\nstatic __inline USHORT CalculateIpv6PseudoHeaderChecksum(IPv6Header *pIpHeader, USHORT headerAndPayloadLen)\n{\n    tIPv6PseudoHeader ipph;\n    USHORT checksum;\n    ipph.ipph_src[0]  = pIpHeader->ip6_src_address[0];\n    ipph.ipph_src[1]  = pIpHeader->ip6_src_address[1];\n    ipph.ipph_src[2]  = pIpHeader->ip6_src_address[2];\n    ipph.ipph_src[3]  = pIpHeader->ip6_src_address[3];\n    ipph.ipph_dest[0] = pIpHeader->ip6_dst_address[0];\n    ipph.ipph_dest[1] = pIpHeader->ip6_dst_address[1];\n    ipph.ipph_dest[2] = pIpHeader->ip6_dst_address[2];\n    ipph.ipph_dest[3] = pIpHeader->ip6_dst_address[3];\n    ipph.z1 = ipph.z2 = ipph.z3 = 0;\n    ipph.ipph_protocol = pIpHeader->ip6_next_header;\n    ipph.ipph_length = swap_short(headerAndPayloadLen);\n    checksum = CheckSumCalculatorFlat(&ipph, sizeof(ipph));\n    return ~checksum;\n}\n\nstatic __inline USHORT CalculateIpPseudoHeaderChecksum(IPHeader *pIpHeader,\n                                                       tTcpIpPacketParsingResult res,\n                                                       USHORT headerAndPayloadLen)\n{\n    if (res.ipStatus == ppresIPV4)\n        return CalculateIpv4PseudoHeaderChecksum(&pIpHeader->v4, headerAndPayloadLen);\n    if (res.ipStatus == ppresIPV6)\n        return CalculateIpv6PseudoHeaderChecksum(&pIpHeader->v6, headerAndPayloadLen);\n    return 0;\n}\n\nstatic __inline BOOLEAN\nCompareNetCheckSumOnEndSystem(USHORT computedChecksum, USHORT arrivedChecksum)\n{\n    //According to RFC 1624 sec. 3\n    //Checksum verification mechanism should treat 0xFFFF\n    //checksum value from received packet as 0x0000\n    if(arrivedChecksum == 0xFFFF)\n        arrivedChecksum = 0;\n\n    return computedChecksum == arrivedChecksum;\n}\n\n/******************************************\n  Calculates IP header checksum calculator\n  it can be already calculated\n  the header must be complete!\n*******************************************/\nstatic __inline tTcpIpPacketParsingResult\nVerifyIpChecksum(\n    IPv4Header *pIpHeader,\n    tTcpIpPacketParsingResult known,\n    BOOLEAN bFix)\n{\n    tTcpIpPacketParsingResult res = known;\n    if (res.ipCheckSum != ppresIPTooShort)\n    {\n        USHORT saved = pIpHeader->ip_xsum;\n        CalculateIpChecksum(pIpHeader);\n        res.ipCheckSum = CompareNetCheckSumOnEndSystem(pIpHeader->ip_xsum, saved) ? ppresCSOK : ppresCSBad;\n        if (!bFix)\n            pIpHeader->ip_xsum = saved;\n        else\n            res.fixedIpCS = res.ipCheckSum == ppresCSBad;\n    }\n    return res;\n}\n\n/*********************************************\nCalculates UDP checksum, assuming the checksum field\nis initialized with pseudoheader checksum\n**********************************************/\nstatic __inline VOID CalculateUdpChecksumGivenPseudoCS(UDPHeader *pUdpHeader, tCompletePhysicalAddress *pDataPages, ULONG ulStartOffset, ULONG udpLength)\n{\n    pUdpHeader->udp_xsum = CheckSumCalculator(pDataPages, ulStartOffset, udpLength);\n}\n\n/*********************************************\nCalculates TCP checksum, assuming the checksum field\nis initialized with pseudoheader checksum\n**********************************************/\nstatic __inline VOID CalculateTcpChecksumGivenPseudoCS(TCPHeader *pTcpHeader, tCompletePhysicalAddress *pDataPages, ULONG ulStartOffset, ULONG tcpLength)\n{\n    pTcpHeader->tcp_xsum = CheckSumCalculator(pDataPages, ulStartOffset, tcpLength);\n}\n\n/************************************************\nChecks (and fix if required) the TCP checksum\nsets flags in result structure according to verification\nTcpPseudoOK if valid pseudo CS was found\nTcpOK if valid TCP checksum was found\n************************************************/\nstatic __inline tTcpIpPacketParsingResult\nVerifyTcpChecksum(\n                tCompletePhysicalAddress *pDataPages,\n                ULONG ulDataLength,\n                ULONG ulStartOffset,\n                tTcpIpPacketParsingResult known,\n                ULONG whatToFix)\n{\n    USHORT  phcs;\n    tTcpIpPacketParsingResult res = known;\n    IPHeader *pIpHeader = (IPHeader *)RtlOffsetToPointer(pDataPages[0].Virtual, ulStartOffset);\n    TCPHeader *pTcpHeader = (TCPHeader *)RtlOffsetToPointer(pIpHeader, res.ipHeaderSize);\n    USHORT saved = pTcpHeader->tcp_xsum;\n    USHORT xxpHeaderAndPayloadLen = GetXxpHeaderAndPayloadLen(pIpHeader, res);\n    if (ulDataLength >= res.ipHeaderSize)\n    {\n        phcs = CalculateIpPseudoHeaderChecksum(pIpHeader, res, xxpHeaderAndPayloadLen);\n        res.xxpCheckSum = CompareNetCheckSumOnEndSystem(phcs, saved) ?  ppresPCSOK : ppresCSBad;\n        if (res.xxpCheckSum != ppresPCSOK || whatToFix)\n        {\n            if (whatToFix & pcrFixPHChecksum)\n            {\n                if (ulDataLength >= (ULONG)(res.ipHeaderSize + sizeof(*pTcpHeader)))\n                {\n                    pTcpHeader->tcp_xsum = phcs;\n                    res.fixedXxpCS = res.xxpCheckSum != ppresPCSOK;\n                }\n                else\n                    res.xxpStatus = ppresXxpIncomplete;\n            }\n            else if (res.xxpFull)\n            {\n                //USHORT ipFullLength = swap_short(pIpHeader->v4.ip_length);\n                pTcpHeader->tcp_xsum = phcs;\n                CalculateTcpChecksumGivenPseudoCS(pTcpHeader, pDataPages, ulStartOffset + res.ipHeaderSize, xxpHeaderAndPayloadLen);\n                if (CompareNetCheckSumOnEndSystem(pTcpHeader->tcp_xsum, saved))\n                    res.xxpCheckSum = ppresCSOK;\n\n                if (!(whatToFix & pcrFixXxpChecksum))\n                    pTcpHeader->tcp_xsum = saved;\n                else\n                    res.fixedXxpCS =\n                        res.xxpCheckSum == ppresCSBad || res.xxpCheckSum == ppresPCSOK;\n            }\n            else if (whatToFix)\n            {\n                res.xxpStatus = ppresXxpIncomplete;\n            }\n        }\n        else if (res.xxpFull)\n        {\n            // we have correct PHCS and we do not need to fix anything\n            // there is a very small chance that it is also good TCP CS\n            // in such rare case we give a priority to TCP CS\n            CalculateTcpChecksumGivenPseudoCS(pTcpHeader, pDataPages, ulStartOffset + res.ipHeaderSize, xxpHeaderAndPayloadLen);\n            if (CompareNetCheckSumOnEndSystem(pTcpHeader->tcp_xsum, saved))\n                res.xxpCheckSum = ppresCSOK;\n            pTcpHeader->tcp_xsum = saved;\n        }\n    }\n    else\n        res.ipCheckSum = ppresIPTooShort;\n    return res;\n}\n\n/************************************************\nChecks (and fix if required) the UDP checksum\nsets flags in result structure according to verification\nUdpPseudoOK if valid pseudo CS was found\nUdpOK if valid UDP checksum was found\n************************************************/\nstatic __inline tTcpIpPacketParsingResult\nVerifyUdpChecksum(\n                tCompletePhysicalAddress *pDataPages,\n                ULONG ulDataLength,\n                ULONG ulStartOffset,\n                tTcpIpPacketParsingResult known,\n                ULONG whatToFix)\n{\n    USHORT  phcs;\n    tTcpIpPacketParsingResult res = known;\n    IPHeader *pIpHeader = (IPHeader *)RtlOffsetToPointer(pDataPages[0].Virtual, ulStartOffset);\n    UDPHeader *pUdpHeader = (UDPHeader *)RtlOffsetToPointer(pIpHeader, res.ipHeaderSize);\n    USHORT saved = pUdpHeader->udp_xsum;\n    USHORT xxpHeaderAndPayloadLen = GetXxpHeaderAndPayloadLen(pIpHeader, res);\n    if (ulDataLength >= res.ipHeaderSize)\n    {\n        phcs = CalculateIpPseudoHeaderChecksum(pIpHeader, res, xxpHeaderAndPayloadLen);\n        res.xxpCheckSum = CompareNetCheckSumOnEndSystem(phcs, saved) ?  ppresPCSOK : ppresCSBad;\n        if (whatToFix & pcrFixPHChecksum)\n        {\n            if (ulDataLength >= (ULONG)(res.ipHeaderSize + sizeof(UDPHeader)))\n            {\n                pUdpHeader->udp_xsum = phcs;\n                res.fixedXxpCS = res.xxpCheckSum != ppresPCSOK;\n            }\n            else\n                res.xxpStatus = ppresXxpIncomplete;\n        }\n        else if (res.xxpCheckSum != ppresPCSOK || (whatToFix & pcrFixXxpChecksum))\n        {\n            if (res.xxpFull)\n            {\n                pUdpHeader->udp_xsum = phcs;\n                CalculateUdpChecksumGivenPseudoCS(pUdpHeader, pDataPages, ulStartOffset + res.ipHeaderSize, xxpHeaderAndPayloadLen);\n                if (CompareNetCheckSumOnEndSystem(pUdpHeader->udp_xsum, saved))\n                    res.xxpCheckSum = ppresCSOK;\n\n                if (!(whatToFix & pcrFixXxpChecksum))\n                    pUdpHeader->udp_xsum = saved;\n                else\n                    res.fixedXxpCS =\n                        res.xxpCheckSum == ppresCSBad || res.xxpCheckSum == ppresPCSOK;\n            }\n            else\n                res.xxpCheckSum = ppresXxpIncomplete;\n        }\n        else if (res.xxpFull)\n        {\n            // we have correct PHCS and we do not need to fix anything\n            // there is a very small chance that it is also good UDP CS\n            // in such rare case we give a priority to UDP CS\n            CalculateUdpChecksumGivenPseudoCS(pUdpHeader, pDataPages, ulStartOffset + res.ipHeaderSize, xxpHeaderAndPayloadLen);\n            if (CompareNetCheckSumOnEndSystem(pUdpHeader->udp_xsum, saved))\n                res.xxpCheckSum = ppresCSOK;\n            pUdpHeader->udp_xsum = saved;\n        }\n    }\n    else\n        res.ipCheckSum = ppresIPTooShort;\n\n    return res;\n}\n\nstatic LPCSTR __inline GetPacketCase(tTcpIpPacketParsingResult res)\n{\n    static const char *const IPCaseName[4] = { \"not tested\", \"Non-IP\", \"IPv4\", \"IPv6\" };\n    if (res.xxpStatus == ppresXxpKnown) return res.TcpUdp == ppresIsTCP ? \n        (res.ipStatus == ppresIPV4 ? \"TCPv4\" : \"TCPv6\") : \n        (res.ipStatus == ppresIPV4 ? \"UDPv4\" : \"UDPv6\");\n    if (res.xxpStatus == ppresXxpIncomplete) return res.TcpUdp == ppresIsTCP ? \"Incomplete TCP\" : \"Incomplete UDP\";\n    if (res.xxpStatus == ppresXxpOther) return \"IP\";\n    return  IPCaseName[res.ipStatus];\n}\n\nstatic LPCSTR __inline GetIPCSCase(tTcpIpPacketParsingResult res)\n{\n    static const char *const CSCaseName[4] = { \"not tested\", \"(too short)\", \"OK\", \"Bad\" };\n    return CSCaseName[res.ipCheckSum];\n}\n\nstatic LPCSTR __inline GetXxpCSCase(tTcpIpPacketParsingResult res)\n{\n    static const char *const CSCaseName[4] = { \"-\", \"PCS\", \"CS\", \"Bad\" };\n    return CSCaseName[res.xxpCheckSum];\n}\n\nstatic __inline VOID PrintOutParsingResult(\n    tTcpIpPacketParsingResult res,\n    int level,\n    LPCSTR procname)\n{\n    DPrintf(level, (\"[%s] %s packet IPCS %s%s, checksum %s%s\\n\", procname,\n        GetPacketCase(res),\n        GetIPCSCase(res),\n        res.fixedIpCS ? \"(fixed)\" : \"\",\n        GetXxpCSCase(res),\n        res.fixedXxpCS ? \"(fixed)\" : \"\"));\n}\n\ntTcpIpPacketParsingResult ParaNdis_CheckSumVerify(\n                                                tCompletePhysicalAddress *pDataPages,\n                                                ULONG ulDataLength,\n                                                ULONG ulStartOffset,\n                                                ULONG flags,\n                                                LPCSTR caller)\n{\n    IPHeader *pIpHeader = (IPHeader *) RtlOffsetToPointer(pDataPages[0].Virtual, ulStartOffset);\n\n    tTcpIpPacketParsingResult res = QualifyIpPacket(pIpHeader, ulDataLength);\n    if (res.ipStatus == ppresNotIP || res.ipCheckSum == ppresIPTooShort)\n        return res;\n\n    if (res.ipStatus == ppresIPV4)\n    {\n        if (flags & pcrIpChecksum)\n            res = VerifyIpChecksum(&pIpHeader->v4, res, (flags & pcrFixIPChecksum) != 0);\n        if(res.xxpStatus == ppresXxpKnown)\n        {\n            if (res.TcpUdp == ppresIsTCP) /* TCP */\n            {\n                if(flags & pcrTcpV4Checksum)\n                {\n                    res = VerifyTcpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixTcpV4Checksum));\n                }\n            }\n            else /* UDP */\n            {\n                if (flags & pcrUdpV4Checksum)\n                {\n                    res = VerifyUdpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixUdpV4Checksum));\n                }\n            }\n        }\n    }\n    else if (res.ipStatus == ppresIPV6)\n    {\n        if(res.xxpStatus == ppresXxpKnown)\n        {\n            if (res.TcpUdp == ppresIsTCP) /* TCP */\n            {\n                if(flags & pcrTcpV6Checksum)\n                {\n                    res = VerifyTcpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixTcpV6Checksum));\n                }\n            }\n            else /* UDP */\n            {\n                if (flags & pcrUdpV6Checksum)\n                {\n                    res = VerifyUdpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixUdpV6Checksum));\n                }\n            }\n        }\n    }\n    PrintOutParsingResult(res, 1, caller);\n    return res;\n}\n\ntTcpIpPacketParsingResult ParaNdis_ReviewIPPacket(PVOID buffer, ULONG size, LPCSTR caller)\n{\n    tTcpIpPacketParsingResult res = QualifyIpPacket((IPHeader *) buffer, size);\n    PrintOutParsingResult(res, 1, caller);\n    return res;\n}\n\nstatic __inline\nVOID AnalyzeL3Proto(\n    USHORT L3Proto,\n    PNET_PACKET_INFO packetInfo)\n{\n    packetInfo->isIP4 = (L3Proto == RtlUshortByteSwap(ETH_PROTO_IP4));\n    packetInfo->isIP6 = (L3Proto == RtlUshortByteSwap(ETH_PROTO_IP6));\n}\n\nstatic\nBOOLEAN AnalyzeL2Hdr(\n    PNET_PACKET_INFO packetInfo)\n{\n    PETH_HEADER dataBuffer = (PETH_HEADER) packetInfo->headersBuffer;\n\n    if (packetInfo->dataLength < ETH_HEADER_SIZE)\n        return FALSE;\n\n    packetInfo->ethDestAddr = dataBuffer->DstAddr;\n\n    if (ETH_IS_BROADCAST(dataBuffer))\n    {\n        packetInfo->isBroadcast = TRUE;\n    }\n    else if (ETH_IS_MULTICAST(dataBuffer))\n    {\n        packetInfo->isMulticast = TRUE;\n    }\n    else\n    {\n        packetInfo->isUnicast = TRUE;\n    }\n\n    if(ETH_HAS_PRIO_HEADER(dataBuffer))\n    {\n        PVLAN_HEADER vlanHdr = ETH_GET_VLAN_HDR(dataBuffer);\n\n        if(packetInfo->dataLength < ETH_HEADER_SIZE + ETH_PRIORITY_HEADER_SIZE)\n            return FALSE;\n\n        packetInfo->hasVlanHeader     = TRUE;\n        packetInfo->Vlan.UserPriority = VLAN_GET_USER_PRIORITY(vlanHdr);\n        packetInfo->Vlan.VlanId       = VLAN_GET_VLAN_ID(vlanHdr);\n        packetInfo->L2HdrLen          = ETH_HEADER_SIZE + ETH_PRIORITY_HEADER_SIZE;\n        AnalyzeL3Proto(vlanHdr->EthType, packetInfo);\n    }\n    else\n    {\n        packetInfo->L2HdrLen = ETH_HEADER_SIZE;\n        AnalyzeL3Proto(dataBuffer->EthType, packetInfo);\n    }\n\n    packetInfo->L2PayloadLen = packetInfo->dataLength - packetInfo->L2HdrLen;\n\n    return TRUE;\n}\n\nstatic __inline\nBOOLEAN SkipIP6ExtensionHeader(\n    IPv6Header *ip6Hdr,\n    ULONG dataLength,\n    PULONG ip6HdrLength,\n    PUCHAR nextHdr)\n{\n    IPv6ExtHeader* ip6ExtHdr;\n\n    if (*ip6HdrLength + sizeof(*ip6ExtHdr) > dataLength)\n        return FALSE;\n\n    ip6ExtHdr = (IPv6ExtHeader *)RtlOffsetToPointer(ip6Hdr, *ip6HdrLength);\n    *nextHdr = ip6ExtHdr->ip6ext_next_header;\n    *ip6HdrLength += (ip6ExtHdr->ip6ext_hdr_len + 1) * IP6_EXT_HDR_GRANULARITY;\n    return TRUE;\n}\n\nstatic\nBOOLEAN AnalyzeIP6RoutingExtension(\n    PIP6_TYPE2_ROUTING_HEADER routingHdr,\n    ULONG dataLength,\n    IPV6_ADDRESS **destAddr)\n{\n    if(dataLength < sizeof(*routingHdr))\n        return FALSE;\n    if(routingHdr->RoutingType == 2)\n    {\n        if((dataLength != sizeof(*routingHdr)) || (routingHdr->SegmentsLeft != 1))\n            return FALSE;\n\n        *destAddr = &routingHdr->Address;\n    }\n    else *destAddr = NULL;\n\n    return TRUE;\n}\n\nstatic\nBOOLEAN AnalyzeIP6DestinationExtension(\n    PVOID destHdr,\n    ULONG dataLength,\n    IPV6_ADDRESS **homeAddr)\n{\n    while(dataLength != 0)\n    {\n        PIP6_EXT_HDR_OPTION optHdr = (PIP6_EXT_HDR_OPTION) destHdr;\n        ULONG optionLen;\n\n        switch(optHdr->Type)\n        {\n        case IP6_EXT_HDR_OPTION_HOME_ADDR:\n            if(dataLength < sizeof(IP6_EXT_HDR_OPTION))\n                return FALSE;\n\n            optionLen = optHdr->Length + sizeof(IP6_EXT_HDR_OPTION);\n            if(optHdr->Length != sizeof(IPV6_ADDRESS))\n                return FALSE;\n\n            *homeAddr = (IPV6_ADDRESS*) RtlOffsetToPointer(optHdr, sizeof(IP6_EXT_HDR_OPTION));\n            break;\n\n        case IP6_EXT_HDR_OPTION_PAD1:\n            optionLen = RTL_SIZEOF_THROUGH_FIELD(IP6_EXT_HDR_OPTION, Type);\n            break;\n\n        default:\n            if(dataLength < sizeof(IP6_EXT_HDR_OPTION))\n                return FALSE;\n\n            optionLen = optHdr->Length + sizeof(IP6_EXT_HDR_OPTION);\n            break;\n        }\n\n        destHdr = RtlOffsetToPointer(destHdr, optionLen);\n        if(dataLength < optionLen)\n            return FALSE;\n\n        dataLength -= optionLen;\n    }\n\n    return TRUE;\n}\n\nstatic\nBOOLEAN AnalyzeIP6Hdr(\n    IPv6Header *ip6Hdr,\n    ULONG dataLength,\n    PULONG ip6HdrLength,\n    PUCHAR nextHdr,\n    PULONG homeAddrOffset,\n    PULONG destAddrOffset)\n{\n    *homeAddrOffset = 0;\n    *destAddrOffset = 0;\n\n    *ip6HdrLength = sizeof(*ip6Hdr);\n    if(dataLength < *ip6HdrLength)\n        return FALSE;\n\n    *nextHdr = ip6Hdr->ip6_next_header;\n    for(;;)\n    {\n        switch (*nextHdr)\n        {\n        default:\n        case IP6_HDR_NONE:\n        case PROTOCOL_TCP:\n        case PROTOCOL_UDP:\n        case IP6_HDR_FRAGMENT:\n            return TRUE;\n        case IP6_HDR_DESTINATON:\n            {\n                IPV6_ADDRESS *homeAddr = NULL;\n                ULONG destHdrOffset = *ip6HdrLength;\n                if(!SkipIP6ExtensionHeader(ip6Hdr, dataLength, ip6HdrLength, nextHdr))\n                    return FALSE;\n\n                if(!AnalyzeIP6DestinationExtension(RtlOffsetToPointer(ip6Hdr, destHdrOffset),\n                    *ip6HdrLength - destHdrOffset, &homeAddr))\n                    return FALSE;\n\n                *homeAddrOffset = homeAddr ? RtlPointerToOffset(ip6Hdr, homeAddr) : 0;\n            }\n            break;\n        case IP6_HDR_ROUTING:\n            {\n                IPV6_ADDRESS *destAddr = NULL;\n                ULONG routingHdrOffset = *ip6HdrLength;\n\n                if(!SkipIP6ExtensionHeader(ip6Hdr, dataLength, ip6HdrLength, nextHdr))\n                    return FALSE;\n\n                if(!AnalyzeIP6RoutingExtension((PIP6_TYPE2_ROUTING_HEADER) RtlOffsetToPointer(ip6Hdr, routingHdrOffset),\n                    *ip6HdrLength - routingHdrOffset, &destAddr))\n                    return FALSE;\n\n                *destAddrOffset = destAddr ? RtlPointerToOffset(ip6Hdr, destAddr) : 0;\n            }\n            break;\n        case IP6_HDR_HOP_BY_HOP:\n        case IP6_HDR_ESP:\n        case IP6_HDR_AUTHENTICATION:\n        case IP6_HDR_MOBILITY:\n            if(!SkipIP6ExtensionHeader(ip6Hdr, dataLength, ip6HdrLength, nextHdr))\n                return FALSE;\n\n            break;\n        }\n    }\n}\n\nstatic __inline\nVOID AnalyzeL4Proto(\n    UCHAR l4Protocol,\n    PNET_PACKET_INFO packetInfo)\n{\n    packetInfo->isTCP = (l4Protocol == PROTOCOL_TCP);\n    packetInfo->isUDP = (l4Protocol == PROTOCOL_UDP);\n}\n\nstatic\nBOOLEAN AnalyzeL3Hdr(\n    PNET_PACKET_INFO packetInfo)\n{\n    if(packetInfo->isIP4)\n    {\n        IPv4Header *ip4Hdr = (IPv4Header *) RtlOffsetToPointer(packetInfo->headersBuffer, packetInfo->L2HdrLen);\n\n        if(packetInfo->dataLength < packetInfo->L2HdrLen + sizeof(*ip4Hdr))\n            return FALSE;\n\n        packetInfo->L3HdrLen = IP_HEADER_LENGTH(ip4Hdr);\n        if ((packetInfo->L3HdrLen < sizeof(*ip4Hdr)) ||\n            (packetInfo->dataLength < packetInfo->L2HdrLen + packetInfo->L3HdrLen))\n            return FALSE;\n\n        if(IP_HEADER_VERSION(ip4Hdr) != 4)\n            return FALSE;\n\n        packetInfo->isFragment = IP_HEADER_IS_FRAGMENT(ip4Hdr);\n\n        if(!packetInfo->isFragment)\n        {\n            AnalyzeL4Proto(ip4Hdr->ip_protocol, packetInfo);\n        }\n    }\n    else if(packetInfo->isIP6)\n    {\n        ULONG homeAddrOffset, destAddrOffset;\n        UCHAR l4Proto;\n\n        IPv6Header *ip6Hdr = (IPv6Header *) RtlOffsetToPointer(packetInfo->headersBuffer, packetInfo->L2HdrLen);\n\n        if(IP6_HEADER_VERSION(ip6Hdr) != 6)\n            return FALSE;\n\n        if(!AnalyzeIP6Hdr(ip6Hdr, packetInfo->L2PayloadLen,\n            &packetInfo->L3HdrLen, &l4Proto, &homeAddrOffset, &destAddrOffset))\n            return FALSE;\n\n        if (packetInfo->L3HdrLen > MAX_SUPPORTED_IPV6_HEADERS)\n            return FALSE;\n\n        packetInfo->ip6HomeAddrOffset = (homeAddrOffset) ? packetInfo->L2HdrLen + homeAddrOffset : 0;\n        packetInfo->ip6DestAddrOffset = (destAddrOffset) ? packetInfo->L2HdrLen + destAddrOffset : 0;\n\n        packetInfo->isFragment = (l4Proto == IP6_HDR_FRAGMENT);\n\n        if(!packetInfo->isFragment)\n        {\n            AnalyzeL4Proto(l4Proto, packetInfo);\n        }\n    }\n\n    return TRUE;\n}\n\nBOOLEAN ParaNdis_AnalyzeReceivedPacket(\n    PVOID headersBuffer,\n    ULONG dataLength,\n    PNET_PACKET_INFO packetInfo)\n{\n    NdisZeroMemory(packetInfo, sizeof(*packetInfo));\n\n    packetInfo->headersBuffer = headersBuffer;\n    packetInfo->dataLength = dataLength;\n\n    if(!AnalyzeL2Hdr(packetInfo))\n        return FALSE;\n\n    if (!AnalyzeL3Hdr(packetInfo))\n        return FALSE;\n\n    return TRUE;\n}\n\nULONG ParaNdis_StripVlanHeaderMoveHead(PNET_PACKET_INFO packetInfo)\n{\n    PUINT32 pData = (PUINT32) packetInfo->headersBuffer;\n\n    ASSERT(packetInfo->hasVlanHeader);\n    ASSERT(packetInfo->L2HdrLen == ETH_HEADER_SIZE + ETH_PRIORITY_HEADER_SIZE);\n\n    pData[3] = pData[2];\n    pData[2] = pData[1];\n    pData[1] = pData[0];\n\n    packetInfo->headersBuffer = RtlOffsetToPointer(packetInfo->headersBuffer, ETH_PRIORITY_HEADER_SIZE);\n    packetInfo->dataLength -= ETH_PRIORITY_HEADER_SIZE;\n    packetInfo->L2HdrLen = ETH_HEADER_SIZE;\n\n    packetInfo->ethDestAddr = (PUCHAR) RtlOffsetToPointer(packetInfo->ethDestAddr, ETH_PRIORITY_HEADER_SIZE);\n    packetInfo->ip6DestAddrOffset -= ETH_PRIORITY_HEADER_SIZE;\n    packetInfo->ip6HomeAddrOffset -= ETH_PRIORITY_HEADER_SIZE;\n\n    return ETH_PRIORITY_HEADER_SIZE;\n};\n\nVOID ParaNdis_PadPacketToMinimalLength(PNET_PACKET_INFO packetInfo)\n{\n    // Ethernet standard declares minimal possible packet size\n    // Packets smaller than that must be padded before transfer\n    // Ethernet HW pads packets on transmit, however in our case\n    // some packets do not travel over Ethernet but being routed\n    // guest-to-guest by virtual switch.\n    // In this case padding is not performed and we may\n    // receive packet smaller than minimal allowed size. This is not\n    // a problem for real life scenarios however WHQL/HCK contains\n    // tests that check padding of received packets.\n    // To make these tests happy we have to pad small packets on receive\n\n    //NOTE: This function assumes that VLAN header has been already stripped out\n\n    if(packetInfo->dataLength < ETH_MIN_PACKET_SIZE)\n    {\n        RtlZeroMemory(\n                        RtlOffsetToPointer(packetInfo->headersBuffer, packetInfo->dataLength),\n                        ETH_MIN_PACKET_SIZE - packetInfo->dataLength);\n        packetInfo->dataLength = ETH_MIN_PACKET_SIZE;\n    }\n}\n", "/**********************************************************************\n * Copyright (c) 2008  Red Hat, Inc.\n *\n * File: ParaNdis6-Impl.c\n *\n * This file contains NDIS6-specific implementation of driver's procedures.\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n**********************************************************************/\n#include \"ParaNdis6.h\"\n\nstatic MINIPORT_DISABLE_INTERRUPT MiniportDisableInterruptEx;\nstatic MINIPORT_ENABLE_INTERRUPT MiniportEnableInterruptEx;\nstatic MINIPORT_INTERRUPT_DPC MiniportInterruptDPC;\nstatic MINIPORT_ISR MiniportInterrupt;\nstatic MINIPORT_ENABLE_MESSAGE_INTERRUPT MiniportEnableMSIInterrupt;\nstatic MINIPORT_DISABLE_MESSAGE_INTERRUPT MiniportDisableMSIInterrupt;\nstatic MINIPORT_MESSAGE_INTERRUPT MiniportMSIInterrupt;\nstatic MINIPORT_MESSAGE_INTERRUPT_DPC MiniportMSIInterruptDpc;\nstatic MINIPORT_PROCESS_SG_LIST ProcessSGListHandler;\nstatic MINIPORT_ALLOCATE_SHARED_MEM_COMPLETE SharedMemAllocateCompleteHandler;\n\nstatic MINIPORT_PROCESS_SG_LIST ProcessSGListHandler;\n\n/**********************************************************\nImplements general-purpose memory allocation routine\nParameters:\n    ULONG ulRequiredSize: block size\nReturn value:\n    PVOID allocated memory block\n    NULL on error\n***********************************************************/\nPVOID ParaNdis_AllocateMemoryRaw(NDIS_HANDLE MiniportHandle, ULONG ulRequiredSize)\n{\n    return NdisAllocateMemoryWithTagPriority(\n            MiniportHandle,\n            ulRequiredSize,\n            PARANDIS_MEMORY_TAG,\n            NormalPoolPriority);\n}\n\nPVOID ParaNdis_AllocateMemory(PARANDIS_ADAPTER *pContext, ULONG ulRequiredSize)\n{\n    return ParaNdis_AllocateMemoryRaw(pContext->MiniportHandle, ulRequiredSize);\n}\n\n/**********************************************************\nImplements opening of adapter-specific configuration\nParameters:\n\nReturn value:\n    NDIS_HANDLE Handle of open configuration\n    NULL on error\n***********************************************************/\nNDIS_HANDLE ParaNdis_OpenNICConfiguration(PARANDIS_ADAPTER *pContext)\n{\n    NDIS_CONFIGURATION_OBJECT co;\n    NDIS_HANDLE cfg;\n    NDIS_STATUS status;\n    DEBUG_ENTRY(2);\n    co.Header.Type = NDIS_OBJECT_TYPE_CONFIGURATION_OBJECT;\n    co.Header.Revision = NDIS_CONFIGURATION_OBJECT_REVISION_1;\n    co.Header.Size = sizeof(co);\n    co.Flags = 0;\n    co.NdisHandle = pContext->MiniportHandle;\n    status = NdisOpenConfigurationEx(&co, &cfg);\n    if (status != NDIS_STATUS_SUCCESS)\n        cfg = NULL;\n    DEBUG_EXIT_STATUS(status == NDIS_STATUS_SUCCESS ? 2 : 0, status);\n    return cfg;\n}\n\n/**********************************************************\nNDIS6 implementation of shared memory allocation\nParameters:\n    context\n    tCompletePhysicalAddress *pAddresses\n            the structure accumulates all our knowledge\n            about the allocation (size, addresses, cacheability etc)\nReturn value:\n    TRUE if the allocation was successful\n***********************************************************/\nBOOLEAN ParaNdis_InitialAllocatePhysicalMemory(\n    PARANDIS_ADAPTER *pContext,\n    tCompletePhysicalAddress *pAddresses)\n{\n    NdisMAllocateSharedMemory(\n        pContext->MiniportHandle,\n        pAddresses->size,\n        TRUE,\n        &pAddresses->Virtual,\n        &pAddresses->Physical);\n    return pAddresses->Virtual != NULL;\n}\n\n\n/**********************************************************\nNDIS6 implementation of shared memory freeing\nParameters:\n    context\n    tCompletePhysicalAddress *pAddresses\n            the structure accumulates all our knowledge\n            about the allocation (size, addresses, cacheability etc)\n            filled by ParaNdis_InitialAllocatePhysicalMemory or\n            by ParaNdis_RuntimeRequestToAllocatePhysicalMemory\n***********************************************************/\n\nVOID ParaNdis_FreePhysicalMemory(\n    PARANDIS_ADAPTER *pContext,\n    tCompletePhysicalAddress *pAddresses)\n{\n\n    NdisMFreeSharedMemory(\n        pContext->MiniportHandle,\n        pAddresses->size,\n        TRUE,\n        pAddresses->Virtual,\n        pAddresses->Physical);\n}\n\n#if (NDIS_SUPPORT_NDIS620)\ntypedef MINIPORT_SYNCHRONIZE_INTERRUPT_HANDLER NDIS_SYNC_PROC_TYPE;\n#else\ntypedef PVOID NDIS_SYNC_PROC_TYPE;\n#endif\n\n\nBOOLEAN ParaNdis_SynchronizeWithInterrupt(\n    PARANDIS_ADAPTER *pContext,\n    ULONG messageId,\n    tSynchronizedProcedure procedure,\n    PVOID parameter)\n{\n    tSynchronizedContext SyncContext;\n    NDIS_SYNC_PROC_TYPE syncProc;\n#pragma warning (push)\n#pragma warning (disable:4152)\n    syncProc = (NDIS_SYNC_PROC_TYPE) procedure;\n#pragma warning (pop)\n    SyncContext.pContext  = pContext;\n    SyncContext.Parameter = parameter;\n    return NdisMSynchronizeWithInterruptEx(pContext->InterruptHandle, messageId, syncProc, &SyncContext);\n}\n\n/**********************************************************\nNDIS-required procedure for hardware interrupt registration\nParameters:\n    IN PVOID MiniportInterruptContext (actually Adapter context)\n***********************************************************/\nstatic VOID MiniportDisableInterruptEx(IN PVOID MiniportInterruptContext)\n{\n    DEBUG_ENTRY(0);\n    PARANDIS_ADAPTER *pContext = (PARANDIS_ADAPTER *)MiniportInterruptContext;\n\n    /* TODO - make sure that interrups are not reenabled by the DPC callback*/\n    for (UINT i = 0; i < pContext->nPathBundles; i++)\n    {\n        pContext->pPathBundles[i].txPath.DisableInterrupts();\n        pContext->pPathBundles[i].rxPath.DisableInterrupts();\n    }\n    if (pContext->bCXPathCreated)\n    {\n        pContext->CXPath.DisableInterrupts();\n    }\n}\n\n/**********************************************************\nNDIS-required procedure for hardware interrupt registration\nParameters:\n    IN PVOID MiniportInterruptContext (actually Adapter context)\n***********************************************************/\nstatic VOID MiniportEnableInterruptEx(IN PVOID MiniportInterruptContext)\n{\n    DEBUG_ENTRY(0);\n    PARANDIS_ADAPTER *pContext = (PARANDIS_ADAPTER *)MiniportInterruptContext;\n\n    for (UINT i = 0; i < pContext->nPathBundles; i++)\n    {\n        pContext->pPathBundles[i].txPath.EnableInterrupts();\n        pContext->pPathBundles[i].rxPath.EnableInterrupts();\n    }\n    if (pContext->bCXPathCreated)\n    {\n        pContext->CXPath.EnableInterrupts();\n    }\n}\n\n/**********************************************************\nNDIS-required procedure for hardware interrupt handling\nParameters:\n    IN PVOID  MiniportInterruptContext (actually Adapter context)\n    OUT PBOOLEAN  QueueDefaultInterruptDpc - set to TRUE for default DPC spawning\n    OUT PULONG  TargetProcessors\nReturn value:\n    TRUE if recognized\n***********************************************************/\nstatic BOOLEAN MiniportInterrupt(\n    IN PVOID  MiniportInterruptContext,\n    OUT PBOOLEAN  QueueDefaultInterruptDpc,\n    OUT PULONG  TargetProcessors\n    )\n{\n    PARANDIS_ADAPTER *pContext = (PARANDIS_ADAPTER *)MiniportInterruptContext;\n    ULONG status = VirtIODeviceISR(pContext->IODevice);\n\n    *TargetProcessors = 0;\n\n    if((status == 0) ||\n       (status == VIRTIO_NET_INVALID_INTERRUPT_STATUS))\n    {\n        *QueueDefaultInterruptDpc = FALSE;\n        return FALSE;\n    }\n\n    PARADNIS_STORE_LAST_INTERRUPT_TIMESTAMP(pContext);\n\n    if(!pContext->bDeviceInitialized) {\n        *QueueDefaultInterruptDpc = FALSE;\n        return TRUE;\n    }\n\n    for (UINT i = 0; i < pContext->nPathBundles; i++)\n    {\n        pContext->pPathBundles[i].txPath.DisableInterrupts();\n        pContext->pPathBundles[i].rxPath.DisableInterrupts();\n    }\n    if (pContext->bCXPathCreated)\n    {\n        pContext->CXPath.DisableInterrupts();\n    }\n    \n    *QueueDefaultInterruptDpc = TRUE;\n    pContext->ulIrqReceived += 1;\n\n    return true;\n}\n\nstatic CParaNdisAbstractPath *GetPathByMessageId(PARANDIS_ADAPTER *pContext, ULONG MessageId)\n{\n    CParaNdisAbstractPath *path = NULL;\n\n    UINT bundleId = MessageId / 2;\n    if (bundleId >= pContext->nPathBundles)\n    {\n        path = &pContext->CXPath;\n    }\n    else if (MessageId % 2)\n    {\n        path = &(pContext->pPathBundles[bundleId].rxPath);\n    }\n    else\n    {\n        path = &(pContext->pPathBundles[bundleId].txPath);\n    }\n\n    return path;\n}\n\n/**********************************************************\nNDIS-required procedure for MSI hardware interrupt handling\nParameters:\n    IN PVOID  MiniportInterruptContext (actually Adapter context)\n    IN ULONG  MessageId - specific interrupt index\n    OUT PBOOLEAN  QueueDefaultInterruptDpc - - set to TRUE for default DPC spawning\n    OUT PULONG  TargetProcessors\nReturn value:\n    TRUE if recognized\n***********************************************************/\nstatic BOOLEAN MiniportMSIInterrupt(\n    IN PVOID  MiniportInterruptContext,\n    IN ULONG  MessageId,\n    OUT PBOOLEAN  QueueDefaultInterruptDpc,\n    OUT PULONG  TargetProcessors\n    )\n{\n    PARANDIS_ADAPTER *pContext = (PARANDIS_ADAPTER *)MiniportInterruptContext;\n\n    PARADNIS_STORE_LAST_INTERRUPT_TIMESTAMP(pContext);\n\n    *TargetProcessors = 0;\n\n    if (!pContext->bDeviceInitialized) {\n        *QueueDefaultInterruptDpc = FALSE;\n        return TRUE;\n    }\n\n    CParaNdisAbstractPath *path = GetPathByMessageId(pContext, MessageId);\n\n    path->DisableInterrupts();\n    path->ReportInterrupt();\n\n\n#if NDIS_SUPPORT_NDIS620\n    if (path->DPCAffinity.Mask)\n    {\n        NdisMQueueDpcEx(pContext->InterruptHandle, MessageId, &path->DPCAffinity, NULL);\n        *QueueDefaultInterruptDpc = FALSE;\n    }\n    else\n    {\n        *QueueDefaultInterruptDpc = TRUE;\n    }\n#else\n    *TargetProcessors = (ULONG)path->DPCTargetProcessor;\n    *QueueDefaultInterruptDpc = TRUE;\n#endif\n\n    pContext->ulIrqReceived += 1;\n    return true;\n}\n\n#if NDIS_SUPPORT_NDIS620\n\nstatic __inline\nVOID GetAffinityForCurrentCpu(PGROUP_AFFINITY pAffinity)\n{\n    PROCESSOR_NUMBER ProcNum;\n    KeGetCurrentProcessorNumberEx(&ProcNum);\n\n    pAffinity->Group = ProcNum.Group;\n    pAffinity->Mask = 1;\n    pAffinity->Mask <<= ProcNum.Number;\n}\n\n#endif\n\n/**********************************************************\nNDIS-required procedure for DPC handling\nParameters:\n    PVOID  MiniportInterruptContext (Adapter context)\n***********************************************************/\nstatic VOID MiniportInterruptDPC(\n    IN NDIS_HANDLE  MiniportInterruptContext,\n    IN PVOID  MiniportDpcContext,\n    IN PVOID                   ReceiveThrottleParameters,\n    IN PVOID                   NdisReserved2\n    )\n{\n    PARANDIS_ADAPTER *pContext = (PARANDIS_ADAPTER *)MiniportInterruptContext;\n    bool requiresDPCRescheduling;\n\n#if NDIS_SUPPORT_NDIS620\n    PNDIS_RECEIVE_THROTTLE_PARAMETERS RxThrottleParameters = (PNDIS_RECEIVE_THROTTLE_PARAMETERS)ReceiveThrottleParameters;\n    DEBUG_ENTRY(5);\n    RxThrottleParameters->MoreNblsPending = 0;\n    requiresDPCRescheduling = ParaNdis_DPCWorkBody(pContext, RxThrottleParameters->MaxNblsToIndicate);\n    if (requiresDPCRescheduling)\n        {\n            GROUP_AFFINITY Affinity;\n            GetAffinityForCurrentCpu(&Affinity);\n\n            NdisMQueueDpcEx(pContext->InterruptHandle, 0, &Affinity, MiniportDpcContext);\n        }\n#else /* NDIS 6.0*/\n    DEBUG_ENTRY(5);\n    UNREFERENCED_PARAMETER(ReceiveThrottleParameters);\n\n    requiresDPCRescheduling = ParaNdis_DPCWorkBody(pContext, PARANDIS_UNLIMITED_PACKETS_TO_INDICATE);\n    if (requiresDPCRescheduling)\n    {\n        DPrintf(4, (\"[%s] Queued additional DPC for %d\\n\", __FUNCTION__,  requiresDPCRescheduling));\n        NdisMQueueDpc(pContext->InterruptHandle, 0, 1 << KeGetCurrentProcessorNumber(), MiniportDpcContext);\n    }\n#endif /* NDIS_SUPPORT_NDIS620 */\n\n    UNREFERENCED_PARAMETER(NdisReserved2);\n}\n\n/**********************************************************\nNDIS-required procedure for MSI DPC handling\nParameters:\n    PVOID  MiniportInterruptContext (Adapter context)\n    IN ULONG  MessageId - specific interrupt index\n***********************************************************/\nstatic VOID MiniportMSIInterruptDpc(\n    IN PVOID  MiniportInterruptContext,\n    IN ULONG  MessageId,\n    IN PVOID  MiniportDpcContext,\n#if NDIS_SUPPORT_NDIS620\n    IN PVOID                   ReceiveThrottleParameters,\n    IN PVOID                   NdisReserved2\n#else\n    IN PULONG                  NdisReserved1,\n    IN PULONG                  NdisReserved2\n#endif\n    )\n{\n    PARANDIS_ADAPTER *pContext = (PARANDIS_ADAPTER *)MiniportInterruptContext;\n    bool requireDPCRescheduling;\n\n#if NDIS_SUPPORT_NDIS620\n    PNDIS_RECEIVE_THROTTLE_PARAMETERS RxThrottleParameters = (PNDIS_RECEIVE_THROTTLE_PARAMETERS)ReceiveThrottleParameters;\n\n    RxThrottleParameters->MoreNblsPending = 0;\n    requireDPCRescheduling = ParaNdis_DPCWorkBody(pContext, RxThrottleParameters->MaxNblsToIndicate);\n\n    if (requireDPCRescheduling)\n        {\n            GROUP_AFFINITY Affinity;\n            GetAffinityForCurrentCpu(&Affinity);\n\n            NdisMQueueDpcEx(pContext->InterruptHandle, MessageId, &Affinity, MiniportDpcContext);\n        }\n#else\n    UNREFERENCED_PARAMETER(NdisReserved1);\n\n    requireDPCRescheduling = ParaNdis_DPCWorkBody(pContext, PARANDIS_UNLIMITED_PACKETS_TO_INDICATE);\n    if (requireDPCRescheduling)\n    {\n        NdisMQueueDpc(pContext->InterruptHandle, MessageId, 1 << KeGetCurrentProcessorNumber(), MiniportDpcContext);\n    }\n#endif\n\n    UNREFERENCED_PARAMETER(NdisReserved2);\n}\n\nstatic VOID MiniportDisableMSIInterrupt(\n    IN PVOID  MiniportInterruptContext,\n    IN ULONG  MessageId\n    )\n{\n    PARANDIS_ADAPTER *pContext = (PARANDIS_ADAPTER *)MiniportInterruptContext;\n    /* TODO - How we prevent DPC procedure from re-enabling interrupt? */\n\n    CParaNdisAbstractPath *path = GetPathByMessageId(pContext, MessageId);\n    path->DisableInterrupts();\n}\n\nstatic VOID MiniportEnableMSIInterrupt(\n    IN PVOID  MiniportInterruptContext,\n    IN ULONG  MessageId\n    )\n{\n    PARANDIS_ADAPTER *pContext = (PARANDIS_ADAPTER *)MiniportInterruptContext;\n    CParaNdisAbstractPath *path = GetPathByMessageId(pContext, MessageId);\n    path->EnableInterrupts();\n}\n\n\n/**********************************************************\nNDIS required handler for run-time allocation of physical memory\nParameters:\n\nReturn value:\n***********************************************************/\nstatic VOID SharedMemAllocateCompleteHandler(\n    IN NDIS_HANDLE  MiniportAdapterContext,\n    IN PVOID  VirtualAddress,\n    IN PNDIS_PHYSICAL_ADDRESS  PhysicalAddress,\n    IN ULONG  Length,\n    IN PVOID  Context\n    )\n{\n    UNREFERENCED_PARAMETER(MiniportAdapterContext);\n    UNREFERENCED_PARAMETER(VirtualAddress);\n    UNREFERENCED_PARAMETER(PhysicalAddress);\n    UNREFERENCED_PARAMETER(Length);\n    UNREFERENCED_PARAMETER(Context);\n}\n\nNDIS_STATUS ParaNdis_ConfigureMSIXVectors(PARANDIS_ADAPTER *pContext)\n{\n    NDIS_STATUS status = NDIS_STATUS_RESOURCES;\n    UINT i;\n    PIO_INTERRUPT_MESSAGE_INFO pTable = pContext->pMSIXInfoTable;\n    if (pTable && pTable->MessageCount)\n    {\n        status = NDIS_STATUS_SUCCESS;\n        DPrintf(0, (\"[%s] Using MSIX interrupts (%d messages, irql %d)\\n\",\n            __FUNCTION__, pTable->MessageCount, pTable->UnifiedIrql));\n        for (i = 0; i < pContext->pMSIXInfoTable->MessageCount; ++i)\n        {\n            DPrintf(0, (\"[%s] MSIX message%d=%08X=>%I64X\\n\",\n                __FUNCTION__, i,\n                pTable->MessageInfo[i].MessageData,\n                pTable->MessageInfo[i].MessageAddress));\n        }\n        for (UINT j = 0; j < pContext->nPathBundles && status == NDIS_STATUS_SUCCESS; ++j)\n        {\n            status = pContext->pPathBundles[j].rxPath.SetupMessageIndex(2 * u16(j) + 1);\n            status = pContext->pPathBundles[j].txPath.SetupMessageIndex(2 * u16(j));\n        }\n\n        if (pContext->bCXPathCreated)\n        {\n            pContext->CXPath.SetupMessageIndex(2 * u16(pContext->nPathBundles));\n        }\n    }\n\n    if (status == NDIS_STATUS_SUCCESS)\n    {\n        for (UINT j = 0; j < pContext->nPathBundles && status == NDIS_STATUS_SUCCESS; ++j)\n        {\n            DPrintf(0, (\"[%s] Using messages %u/%u for RX/TX queue %u\\n\", __FUNCTION__, pContext->pPathBundles[j].rxPath.getMessageIndex(),\n                pContext->pPathBundles[j].txPath.getMessageIndex(), j));\n        }\n        if (pContext->bCXPathCreated)\n        {\n            DPrintf(0, (\"[%s] Using message %u for controls\\n\", __FUNCTION__, pContext->CXPath.getMessageIndex()));\n        }\n        else\n        {\n            DPrintf(0, (\"[%s] - No control path\\n\", __FUNCTION__));\n        }\n    }\n    DEBUG_EXIT_STATUS(2, status);\n    return status;\n}\n\nvoid ParaNdis_RestoreDeviceConfigurationAfterReset(\n    PARANDIS_ADAPTER *pContext)\n{\n    ParaNdis_ConfigureMSIXVectors(pContext);\n}\n\nstatic void DebugParseOffloadBits()\n{\n    NDIS_TCP_IP_CHECKSUM_NET_BUFFER_LIST_INFO info;\n    tChecksumCheckResult res;\n    ULONG val = 1;\n    int level = 1;\n    while (val)\n    {\n        info.Value = (PVOID)(ULONG_PTR)val;\n        if (info.Receive.IpChecksumFailed) DPrintf(level, (\"W.%X=IPCS failed\\n\", val));\n        if (info.Receive.IpChecksumSucceeded) DPrintf(level, (\"W.%X=IPCS OK\\n\", val));\n        if (info.Receive.TcpChecksumFailed) DPrintf(level, (\"W.%X=TCPCS failed\\n\", val));\n        if (info.Receive.TcpChecksumSucceeded) DPrintf(level, (\"W.%X=TCPCS OK\\n\", val));\n        if (info.Receive.UdpChecksumFailed) DPrintf(level, (\"W.%X=UDPCS failed\\n\", val));\n        if (info.Receive.UdpChecksumSucceeded) DPrintf(level, (\"W.%X=UDPCS OK\\n\", val));\n        val = val << 1;\n    }\n    val = 1;\n    while (val)\n    {\n        res.value = val;\n        if (res.flags.IpFailed) DPrintf(level, (\"C.%X=IPCS failed\\n\", val));\n        if (res.flags.IpOK) DPrintf(level, (\"C.%X=IPCS OK\\n\", val));\n        if (res.flags.TcpFailed) DPrintf(level, (\"C.%X=TCPCS failed\\n\", val));\n        if (res.flags.TcpOK) DPrintf(level, (\"C.%X=TCPCS OK\\n\", val));\n        if (res.flags.UdpFailed) DPrintf(level, (\"C.%X=UDPCS failed\\n\", val));\n        if (res.flags.UdpOK) DPrintf(level, (\"C.%X=UDPCS OK\\n\", val));\n        val = val << 1;\n    }\n}\n\n/**********************************************************\nNDIS6-related final initialization:\n    Installing interrupt handler\n    Allocate buffer list pool\n\nParameters:\n\nReturn value:\n\n***********************************************************/\nNDIS_STATUS ParaNdis_FinishSpecificInitialization(PARANDIS_ADAPTER *pContext)\n{\n    NDIS_STATUS status = NDIS_STATUS_SUCCESS;\n    NET_BUFFER_LIST_POOL_PARAMETERS PoolParams;\n    NDIS_MINIPORT_INTERRUPT_CHARACTERISTICS mic;\n    DEBUG_ENTRY(0);\n\n    NdisZeroMemory(&mic, sizeof(mic));\n    mic.Header.Type = NDIS_OBJECT_TYPE_MINIPORT_INTERRUPT;\n    mic.Header.Revision = NDIS_MINIPORT_INTERRUPT_REVISION_1;\n    mic.Header.Size = NDIS_SIZEOF_MINIPORT_INTERRUPT_CHARACTERISTICS_REVISION_1;\n    mic.DisableInterruptHandler = MiniportDisableInterruptEx;\n    mic.EnableInterruptHandler  = MiniportEnableInterruptEx;\n    mic.InterruptDpcHandler = MiniportInterruptDPC;\n    mic.InterruptHandler = MiniportInterrupt;\n    if (pContext->bUsingMSIX)\n    {\n        mic.MsiSupported = TRUE;\n        mic.MsiSyncWithAllMessages = TRUE;\n        mic.EnableMessageInterruptHandler = MiniportEnableMSIInterrupt;\n        mic.DisableMessageInterruptHandler = MiniportDisableMSIInterrupt;\n        mic.MessageInterruptHandler = MiniportMSIInterrupt;\n        mic.MessageInterruptDpcHandler = MiniportMSIInterruptDpc;\n    }\n    PoolParams.Header.Type = NDIS_OBJECT_TYPE_DEFAULT;\n    PoolParams.Header.Size = sizeof(PoolParams);\n    PoolParams.Header.Revision = NET_BUFFER_LIST_POOL_PARAMETERS_REVISION_1;\n    PoolParams.ProtocolId = NDIS_PROTOCOL_ID_DEFAULT;\n    PoolParams.fAllocateNetBuffer = TRUE;\n    PoolParams.ContextSize = 0;\n    PoolParams.PoolTag = PARANDIS_MEMORY_TAG;\n    PoolParams.DataSize = 0;\n\n    pContext->BufferListsPool = NdisAllocateNetBufferListPool(pContext->MiniportHandle, &PoolParams);\n    if (!pContext->BufferListsPool)\n    {\n        status = NDIS_STATUS_RESOURCES;\n    }\n\n    if (status == NDIS_STATUS_SUCCESS)\n    {\n        status = NdisMRegisterInterruptEx(pContext->MiniportHandle, pContext, &mic, &pContext->InterruptHandle);\n    }\n\n#ifdef DBG\n    if (pContext->bUsingMSIX)\n    {\n        DPrintf(0, (\"[%s] MSIX message table %savailable, count = %u\\n\", __FUNCTION__, (mic.MessageInfoTable == nullptr ? \"not \" : \"\"),\n            (mic.MessageInfoTable == nullptr ? 0 : mic.MessageInfoTable->MessageCount)));\n    }\n    else\n    {\n        DPrintf(0, (\"[%s] Not using MSIX\\n\", __FUNCTION__));\n    }\n#endif\n\n    if (status == NDIS_STATUS_SUCCESS)\n    {\n        NDIS_SG_DMA_DESCRIPTION sgDesc;\n        sgDesc.Header.Type = NDIS_OBJECT_TYPE_SG_DMA_DESCRIPTION;\n        sgDesc.Header.Revision = NDIS_SG_DMA_DESCRIPTION_REVISION_1;\n        sgDesc.Header.Size = sizeof(sgDesc);\n        sgDesc.Flags = NDIS_SG_DMA_64_BIT_ADDRESS;\n        sgDesc.MaximumPhysicalMapping = 0x10000; // 64K\n        sgDesc.ProcessSGListHandler = ProcessSGListHandler;\n        sgDesc.SharedMemAllocateCompleteHandler = SharedMemAllocateCompleteHandler;\n        sgDesc.ScatterGatherListSize = 0; // OUT value\n        status = NdisMRegisterScatterGatherDma(pContext->MiniportHandle, &sgDesc, &pContext->DmaHandle);\n        if (status != NDIS_STATUS_SUCCESS)\n        {\n            DPrintf(0, (\"[%s] ERROR: NdisMRegisterScatterGatherDma failed (%X)!\\n\", __FUNCTION__, status));\n        }\n        else\n        {\n            DPrintf(0, (\"[%s] SG recommended size %d\\n\", __FUNCTION__, sgDesc.ScatterGatherListSize));\n        }\n    }\n\n    if (status == NDIS_STATUS_SUCCESS)\n    {\n        if (NDIS_CONNECT_MESSAGE_BASED == mic.InterruptType)\n        {\n            pContext->pMSIXInfoTable = mic.MessageInfoTable;\n        }\n        else if (pContext->bUsingMSIX)\n        {\n            DPrintf(0, (\"[%s] ERROR: Interrupt type %d, message table %p\\n\",\n                __FUNCTION__, mic.InterruptType, mic.MessageInfoTable));\n            status = NDIS_STATUS_RESOURCE_CONFLICT;\n        }\n        ParaNdis6_ApplyOffloadPersistentConfiguration(pContext);\n        DebugParseOffloadBits();\n    }\n    DEBUG_EXIT_STATUS(0, status);\n    return status;\n}\n\n/**********************************************************\nNDIS6-related final initialization:\n    Uninstalling interrupt handler\n    Dellocate buffer list pool\nParameters:\n    context\n***********************************************************/\nVOID ParaNdis_FinalizeCleanup(PARANDIS_ADAPTER *pContext)\n{\n    // we zero context members to be able examine them in the debugger/dump\n    if (pContext->InterruptHandle)\n    {\n        NdisMDeregisterInterruptEx(pContext->InterruptHandle);\n        pContext->InterruptHandle = NULL;\n    }\n    if (pContext->BufferListsPool)\n    {\n        NdisFreeNetBufferListPool(pContext->BufferListsPool);\n        pContext->BufferListsPool = NULL;\n    }\n    if (pContext->DmaHandle)\n    {\n        NdisMDeregisterScatterGatherDma(pContext->DmaHandle);\n        pContext->DmaHandle = NULL;\n    }\n}\n\nBOOLEAN ParaNdis_BindRxBufferToPacket(\n    PARANDIS_ADAPTER *pContext,\n    pRxNetDescriptor p)\n{\n    ULONG i;\n    PMDL *NextMdlLinkage = &p->Holder;\n\n    for(i = PARANDIS_FIRST_RX_DATA_PAGE; i < p->PagesAllocated; i++)\n    {\n        *NextMdlLinkage = NdisAllocateMdl(pContext->MiniportHandle, p->PhysicalPages[i].Virtual, PAGE_SIZE);\n        if(*NextMdlLinkage == NULL) goto error_exit;\n\n        NextMdlLinkage = &(NDIS_MDL_LINKAGE(*NextMdlLinkage));\n    }\n    *NextMdlLinkage = NULL;\n\n    return TRUE;\n\nerror_exit:\n\n    ParaNdis_UnbindRxBufferFromPacket(p);\n    return FALSE;\n}\n\nvoid ParaNdis_UnbindRxBufferFromPacket(\n    pRxNetDescriptor p)\n{\n    PMDL NextMdlLinkage = p->Holder;\n\n    while(NextMdlLinkage != NULL)\n    {\n        PMDL pThisMDL = NextMdlLinkage;\n        NextMdlLinkage = NDIS_MDL_LINKAGE(pThisMDL);\n\n        NdisAdjustMdlLength(pThisMDL, PAGE_SIZE);\n        NdisFreeMdl(pThisMDL);\n    }\n}\n\nstatic\nvoid ParaNdis_AdjustRxBufferHolderLength(\n    pRxNetDescriptor p,\n    ULONG ulDataOffset)\n{\n    PMDL NextMdlLinkage = p->Holder;\n    ULONG ulBytesLeft = p->PacketInfo.dataLength + ulDataOffset;\n\n    while(NextMdlLinkage != NULL)\n    {\n        ULONG ulThisMdlBytes = min(PAGE_SIZE, ulBytesLeft);\n        NdisAdjustMdlLength(NextMdlLinkage, ulThisMdlBytes);\n        ulBytesLeft -= ulThisMdlBytes;\n        NextMdlLinkage = NDIS_MDL_LINKAGE(NextMdlLinkage);\n    }\n    ASSERT(ulBytesLeft == 0);\n}\n\nstatic __inline\nVOID NBLSetRSSInfo(PPARANDIS_ADAPTER pContext, PNET_BUFFER_LIST pNBL, PNET_PACKET_INFO PacketInfo)\n{\n#if PARANDIS_SUPPORT_RSS\n    CNdisRWLockState lockState;\n\n    pContext->RSSParameters.rwLock.acquireReadDpr(lockState);\n    if(pContext->RSSParameters.RSSMode != PARANDIS_RSS_DISABLED)\n    {\n        NET_BUFFER_LIST_SET_HASH_TYPE    (pNBL, PacketInfo->RSSHash.Type);\n        NET_BUFFER_LIST_SET_HASH_FUNCTION(pNBL, PacketInfo->RSSHash.Function);\n        NET_BUFFER_LIST_SET_HASH_VALUE   (pNBL, PacketInfo->RSSHash.Value);\n    }\n    pContext->RSSParameters.rwLock.releaseDpr(lockState);\n#else\n    UNREFERENCED_PARAMETER(pContext);\n    UNREFERENCED_PARAMETER(pNBL);\n    UNREFERENCED_PARAMETER(PacketInfo);\n#endif\n}\n\nstatic __inline\nVOID NBLSet8021QInfo(PPARANDIS_ADAPTER pContext, PNET_BUFFER_LIST pNBL, PNET_PACKET_INFO pPacketInfo)\n{\n    NDIS_NET_BUFFER_LIST_8021Q_INFO qInfo;\n    qInfo.Value = NULL;\n\n    if (IsPrioritySupported(pContext))\n        qInfo.TagHeader.UserPriority = pPacketInfo->Vlan.UserPriority;\n\n    if (IsVlanSupported(pContext))\n        qInfo.TagHeader.VlanId = pPacketInfo->Vlan.VlanId;\n\n    if(qInfo.Value != NULL)\n        pContext->extraStatistics.framesRxPriority++;\n\n    NET_BUFFER_LIST_INFO(pNBL, Ieee8021QNetBufferListInfo) = qInfo.Value;\n}\n\n#if PARANDIS_SUPPORT_RSC\nstatic __inline\nUINT PktGetTCPCoalescedSegmentsCount(PNET_PACKET_INFO PacketInfo, UINT nMaxTCPPayloadSize)\n{\n    // We have no corresponding data, following is a simulation\n    return PacketInfo->L2PayloadLen / nMaxTCPPayloadSize +\n        !!(PacketInfo->L2PayloadLen % nMaxTCPPayloadSize);\n}\n\nstatic __inline\nVOID NBLSetRSCInfo(PPARANDIS_ADAPTER pContext, PNET_BUFFER_LIST pNBL,\n                   PNET_PACKET_INFO PacketInfo, UINT nCoalescedSegments)\n{\n    NDIS_TCP_IP_CHECKSUM_NET_BUFFER_LIST_INFO qCSInfo;\n\n    qCSInfo.Value = NULL;\n    qCSInfo.Receive.IpChecksumSucceeded = TRUE;\n    qCSInfo.Receive.IpChecksumValueInvalid = TRUE;\n    qCSInfo.Receive.TcpChecksumSucceeded = TRUE;\n    qCSInfo.Receive.TcpChecksumValueInvalid = TRUE;\n    NET_BUFFER_LIST_INFO(pNBL, TcpIpChecksumNetBufferListInfo) = qCSInfo.Value;\n\n    NET_BUFFER_LIST_COALESCED_SEG_COUNT(pNBL) = (USHORT) nCoalescedSegments;\n    NET_BUFFER_LIST_DUP_ACK_COUNT(pNBL) = 0;\n\n    NdisInterlockedAddLargeStatistic(&pContext->RSC.Statistics.CoalescedOctets, PacketInfo->L2PayloadLen);\n    NdisInterlockedAddLargeStatistic(&pContext->RSC.Statistics.CoalesceEvents, 1);\n    NdisInterlockedAddLargeStatistic(&pContext->RSC.Statistics.CoalescedPkts, nCoalescedSegments);\n}\n#endif\n\n/**********************************************************\nNDIS6 implementation of packet indication\n\nParameters:\n    context\n    PVOID pBuffersDescriptor - VirtIO buffer descriptor of data buffer\n    BOOLEAN bPrepareOnly - only return NBL for further indication in batch\nReturn value:\n    TRUE  is packet indicated\n    FALSE if not (in this case, the descriptor should be freed now)\nIf priority header is in the packet. it will be removed and *pLength decreased\n***********************************************************/\ntPacketIndicationType ParaNdis_PrepareReceivedPacket(\n    PARANDIS_ADAPTER *pContext,\n    pRxNetDescriptor pBuffersDesc,\n    PUINT            pnCoalescedSegmentsCount)\n{\n    PMDL pMDL = pBuffersDesc->Holder;\n    PNET_BUFFER_LIST pNBL = NULL;\n    *pnCoalescedSegmentsCount = 1;\n\n    if (pMDL)\n    {\n        ULONG nBytesStripped = 0;\n        PNET_PACKET_INFO pPacketInfo = &pBuffersDesc->PacketInfo;\n\n        if (pContext->ulPriorityVlanSetting && pPacketInfo->hasVlanHeader)\n        {\n            nBytesStripped = ParaNdis_StripVlanHeaderMoveHead(pPacketInfo);\n        }\n\n        ParaNdis_PadPacketToMinimalLength(pPacketInfo);\n        ParaNdis_AdjustRxBufferHolderLength(pBuffersDesc, nBytesStripped);\n        pNBL = NdisAllocateNetBufferAndNetBufferList(pContext->BufferListsPool, 0, 0, pMDL, nBytesStripped, pPacketInfo->dataLength);\n\n        if (pNBL)\n        {\n            virtio_net_hdr_basic *pHeader = (virtio_net_hdr_basic *) pBuffersDesc->PhysicalPages[0].Virtual;\n            tChecksumCheckResult csRes;\n            pNBL->SourceHandle = pContext->MiniportHandle;\n            NBLSetRSSInfo(pContext, pNBL, pPacketInfo);\n            NBLSet8021QInfo(pContext, pNBL, pPacketInfo);\n\n            pNBL->MiniportReserved[0] = pBuffersDesc;\n\n#if PARANDIS_SUPPORT_RSC\n            if(pHeader->gso_type != VIRTIO_NET_HDR_GSO_NONE)\n            {\n                *pnCoalescedSegmentsCount = PktGetTCPCoalescedSegmentsCount(pPacketInfo, pContext->MaxPacketSize.nMaxDataSize);\n                NBLSetRSCInfo(pContext, pNBL, pPacketInfo, *pnCoalescedSegmentsCount);\n            }\n            else\n#endif\n            {\n                csRes = ParaNdis_CheckRxChecksum(\n                    pContext,\n                    pHeader->flags,\n                    &pBuffersDesc->PhysicalPages[PARANDIS_FIRST_RX_DATA_PAGE],\n                    pPacketInfo->dataLength,\n                    nBytesStripped);\n                if (csRes.value)\n                {\n                    NDIS_TCP_IP_CHECKSUM_NET_BUFFER_LIST_INFO qCSInfo;\n                    qCSInfo.Value = NULL;\n                    qCSInfo.Receive.IpChecksumFailed = csRes.flags.IpFailed;\n                    qCSInfo.Receive.IpChecksumSucceeded = csRes.flags.IpOK;\n                    qCSInfo.Receive.TcpChecksumFailed = csRes.flags.TcpFailed;\n                    qCSInfo.Receive.TcpChecksumSucceeded = csRes.flags.TcpOK;\n                    qCSInfo.Receive.UdpChecksumFailed = csRes.flags.UdpFailed;\n                    qCSInfo.Receive.UdpChecksumSucceeded = csRes.flags.UdpOK;\n                    NET_BUFFER_LIST_INFO(pNBL, TcpIpChecksumNetBufferListInfo) = qCSInfo.Value;\n                    DPrintf(1, (\"Reporting CS %X->%X\\n\", csRes.value, (ULONG)(ULONG_PTR)qCSInfo.Value));\n                }\n            }\n            pNBL->Status = NDIS_STATUS_SUCCESS;\n#if defined(ENABLE_HISTORY_LOG)\n            {\n                tTcpIpPacketParsingResult packetReview = ParaNdis_CheckSumVerify(\n                    RtlOffsetToPointer(pPacketInfo->headersBuffer, ETH_HEADER_SIZE),\n                    pPacketInfo->dataLength,\n                    pcrIpChecksum | pcrTcpChecksum | pcrUdpChecksum,\n                    __FUNCTION__\n                    );\n                ParaNdis_DebugHistory(pContext, hopPacketReceived, pNBL, pPacketInfo->dataLength, (ULONG)(ULONG_PTR)qInfo.Value, packetReview.value);\n            }\n#endif\n        }\n    }\n    return pNBL;\n}\n\n\n/**********************************************************\nNDIS procedure of returning us buffer of previously indicated packets\nParameters:\n    context\n    PNET_BUFFER_LIST pNBL - list of buffers to free\n    returnFlags - is dpc\n\nThe procedure frees:\nreceived buffer descriptors back to list of RX buffers\nall the allocated MDL structures\nall the received NBLs back to our pool\n***********************************************************/\nVOID ParaNdis6_ReturnNetBufferLists(\n    NDIS_HANDLE miniportAdapterContext,\n    PNET_BUFFER_LIST pNBL,\n    ULONG returnFlags)\n{\n    PARANDIS_ADAPTER *pContext = (PARANDIS_ADAPTER *)miniportAdapterContext;\n\n    UNREFERENCED_PARAMETER(returnFlags);\n\n    DEBUG_ENTRY(5);\n    while (pNBL)\n    {\n        PNET_BUFFER_LIST pTemp = pNBL;\n        pRxNetDescriptor pBuffersDescriptor = (pRxNetDescriptor)pNBL->MiniportReserved[0];\n        DPrintf(3, (\"  Returned NBL of pBuffersDescriptor %p!\\n\", pBuffersDescriptor));\n        pNBL = NET_BUFFER_LIST_NEXT_NBL(pNBL);\n        NET_BUFFER_LIST_NEXT_NBL(pTemp) = NULL;\n        NdisFreeNetBufferList(pTemp);\n        pBuffersDescriptor->Queue->ReuseReceiveBuffer(pContext->ReuseBufferRegular, pBuffersDescriptor);\n    }\n    ParaMdis_TestPausing(pContext);\n}\n\n/**********************************************************\nPauses of restarts RX activity.\nRestart is immediate, pause may be delayed until\nNDIS returns all the indicated NBL\n\nParameters:\n    context\n    bPause 1/0 - pause or restart\n    ONPAUSECOMPLETEPROC Callback to be called when PAUSE finished\nReturn value:\n    SUCCESS if finished synchronously\n    PENDING if not, then callback will be called\n***********************************************************/\nNDIS_STATUS ParaNdis6_ReceivePauseRestart(\n    PARANDIS_ADAPTER *pContext,\n    BOOLEAN bPause,\n    ONPAUSECOMPLETEPROC Callback\n    )\n{\n    NDIS_STATUS status = NDIS_STATUS_SUCCESS;\n\n    if (bPause)\n    {\n        CNdisPassiveWriteAutoLock tLock(pContext->m_PauseLock);\n\n        ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 1, 0, 0);\n        if (pContext->m_upstreamPacketPending != 0)\n        {\n            pContext->ReceiveState = srsPausing;\n            pContext->ReceivePauseCompletionProc = Callback;\n            status = NDIS_STATUS_PENDING;\n        }\n        else\n        {\n            ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 0, 0, 0);\n            pContext->ReceiveState = srsDisabled;\n        }\n    }\n    else\n    {\n        ParaNdis_DebugHistory(pContext, hopInternalReceiveResume, NULL, 0, 0, 0);\n        pContext->ReceiveState = srsEnabled;\n    }\n    return status;\n}\n\nNDIS_STATUS ParaNdis_ExactSendFailureStatus(PARANDIS_ADAPTER *pContext)\n{\n    NDIS_STATUS status = NDIS_STATUS_FAILURE;\n    if (pContext->SendState != srsEnabled ) status = NDIS_STATUS_PAUSED;\n    if (!pContext->bConnected) status = NDIS_STATUS_MEDIA_DISCONNECTED;\n    if (pContext->bSurprizeRemoved) status = NDIS_STATUS_NOT_ACCEPTED;\n    // override NDIS_STATUS_PAUSED is there is a specific reason of implicit paused state\n    if (pContext->powerState != NdisDeviceStateD0) status = NDIS_STATUS_LOW_POWER_STATE;\n    if (pContext->bResetInProgress) status = NDIS_STATUS_RESET_IN_PROGRESS;\n    return status;\n}\n\nBOOLEAN ParaNdis_IsSendPossible(PARANDIS_ADAPTER *pContext)\n{\n    BOOLEAN b;\n    b =  !pContext->bSurprizeRemoved && pContext->bConnected && pContext->SendState == srsEnabled;\n    return b;\n}\n\n/**********************************************************\nNDIS required handler for run-time allocation of scatter-gather list\nParameters:\npSGL - scatter-hather list of elements (possible NULL when called directly)\nContext - (tNetBufferEntry *) for specific NET_BUFFER in NBL\nCalled on DPC (DDK claims it)\n***********************************************************/\nVOID ProcessSGListHandler(\n    IN PDEVICE_OBJECT  pDO,\n    IN PVOID  Reserved,\n    IN PSCATTER_GATHER_LIST  pSGL,\n    IN PVOID  Context\n    )\n{\n    UNREFERENCED_PARAMETER(Reserved);\n    UNREFERENCED_PARAMETER(pDO);\n\n    auto NBHolder = static_cast<CNB*>(Context);\n    NBHolder->MappingDone(pSGL);\n}\n\n/**********************************************************\nPauses of restarts TX activity.\nRestart is immediate, pause may be delayed until\nwe return all the NBLs to NDIS\n\nParameters:\n    context\n    bPause 1/0 - pause or restart\n    ONPAUSECOMPLETEPROC Callback to be called when PAUSE finished\nReturn value:\n    SUCCESS if finished synchronously\n    PENDING if not, then callback will be called later\n***********************************************************/\nNDIS_STATUS ParaNdis6_SendPauseRestart(\n    PARANDIS_ADAPTER *pContext,\n    BOOLEAN bPause,\n    ONPAUSECOMPLETEPROC Callback\n)\n{\n    NDIS_STATUS status = NDIS_STATUS_SUCCESS;\n    DEBUG_ENTRY(4);\n    if (bPause)\n    {\n        ParaNdis_DebugHistory(pContext, hopInternalSendPause, NULL, 1, 0, 0);\n        if (pContext->SendState == srsEnabled)\n        {\n            {\n                CNdisPassiveWriteAutoLock tLock(pContext->m_PauseLock);\n\n                pContext->SendState = srsPausing;\n                pContext->SendPauseCompletionProc = Callback;\n            }\n\n            for (UINT i = 0; i < pContext->nPathBundles; i++)\n            {\n                if (!pContext->pPathBundles[i].txPath.Pause())\n                {\n                    status = NDIS_STATUS_PENDING;\n                }\n            }\n\n            if (status == NDIS_STATUS_SUCCESS)\n            {\n                pContext->SendState = srsDisabled;\n            }\n        }\n        if (status == NDIS_STATUS_SUCCESS)\n        {\n            ParaNdis_DebugHistory(pContext, hopInternalSendPause, NULL, 0, 0, 0);\n        }\n    }\n    else\n    {\n        pContext->SendState = srsEnabled;\n        ParaNdis_DebugHistory(pContext, hopInternalSendResume, NULL, 0, 0, 0);\n    }\n    return status;\n}\n\n/**********************************************************\nRequired procedure of NDIS\nNDIS wants to cancel sending of each list which has specified CancelID\nCan be tested only under NDIS Test\n***********************************************************/\nVOID ParaNdis6_CancelSendNetBufferLists(\n    NDIS_HANDLE  miniportAdapterContext,\n    PVOID pCancelId)\n{\n    PARANDIS_ADAPTER *pContext = (PARANDIS_ADAPTER *)miniportAdapterContext;\n\n    DEBUG_ENTRY(0);\n    for (UINT i = 0; i < pContext->nPathBundles; i++)\n    {\n        pContext->pPathBundles[i].txPath.CancelNBLs(pCancelId);\n    }\n}\n"], "fixing_code": ["/**********************************************************************\n * Copyright (c) 2008  Red Hat, Inc.\n *\n * File: ParaNdis-Common.c\n *\n * This file contains NDIS driver procedures, common for NDIS5 and NDIS6\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n**********************************************************************/\n#include \"ndis56common.h\"\n\nstatic VOID ParaNdis_UpdateMAC(PARANDIS_ADAPTER *pContext);\n\nstatic __inline pRxNetDescriptor ReceiveQueueGetBuffer(PPARANDIS_RECEIVE_QUEUE pQueue);\n\n// TODO: remove when the problem solved\nvoid WriteVirtIODeviceByte(ULONG_PTR ulRegister, u8 bValue);\n\n//#define ROUNDSIZE(sz) ((sz + 15) & ~15)\n#define MAX_VLAN_ID     4095\n\n#define ABSTRACT_PATHES_TAG 'APVR'\n\n/**********************************************************\nValidates MAC address\nValid MAC address is not broadcast, not multicast, not empty\nif bLocal is set, it must be LOCAL\nif not, is must be non-local or local\nParameters:\n    PUCHAR pcMacAddress - MAC address to validate\n    BOOLEAN bLocal      - TRUE, if we validate locally administered address\nReturn value:\n    TRUE if valid\n***********************************************************/\nBOOLEAN ParaNdis_ValidateMacAddress(PUCHAR pcMacAddress, BOOLEAN bLocal)\n{\n    BOOLEAN bLA = FALSE, bEmpty, bBroadcast, bMulticast = FALSE;\n    bBroadcast = ETH_IS_BROADCAST(pcMacAddress);\n    bLA = !bBroadcast && ETH_IS_LOCALLY_ADMINISTERED(pcMacAddress);\n    bMulticast = !bBroadcast && ETH_IS_MULTICAST(pcMacAddress);\n    bEmpty = ETH_IS_EMPTY(pcMacAddress);\n    return !bBroadcast && !bEmpty && !bMulticast && (!bLocal || bLA);\n}\n\ntypedef struct _tagConfigurationEntry\n{\n    const char      *Name;\n    ULONG           ulValue;\n    ULONG           ulMinimal;\n    ULONG           ulMaximal;\n}tConfigurationEntry;\n\ntypedef struct _tagConfigurationEntries\n{\n    tConfigurationEntry PrioritySupport;\n    tConfigurationEntry ConnectRate;\n    tConfigurationEntry isLogEnabled;\n    tConfigurationEntry debugLevel;\n    tConfigurationEntry TxCapacity;\n    tConfigurationEntry RxCapacity;\n    tConfigurationEntry LogStatistics;\n    tConfigurationEntry OffloadTxChecksum;\n    tConfigurationEntry OffloadTxLSO;\n    tConfigurationEntry OffloadRxCS;\n    tConfigurationEntry stdIpcsV4;\n    tConfigurationEntry stdTcpcsV4;\n    tConfigurationEntry stdTcpcsV6;\n    tConfigurationEntry stdUdpcsV4;\n    tConfigurationEntry stdUdpcsV6;\n    tConfigurationEntry stdLsoV1;\n    tConfigurationEntry stdLsoV2ip4;\n    tConfigurationEntry stdLsoV2ip6;\n    tConfigurationEntry PriorityVlanTagging;\n    tConfigurationEntry VlanId;\n    tConfigurationEntry PublishIndices;\n    tConfigurationEntry MTU;\n    tConfigurationEntry NumberOfHandledRXPackersInDPC;\n#if PARANDIS_SUPPORT_RSS\n    tConfigurationEntry RSSOffloadSupported;\n    tConfigurationEntry NumRSSQueues;\n#endif\n#if PARANDIS_SUPPORT_RSC\n    tConfigurationEntry RSCIPv4Supported;\n    tConfigurationEntry RSCIPv6Supported;\n#endif\n}tConfigurationEntries;\n\nstatic const tConfigurationEntries defaultConfiguration =\n{\n    { \"Priority\",       0,  0,  1 },\n    { \"ConnectRate\",    100,10,10000 },\n    { \"DoLog\",          1,  0,  1 },\n    { \"DebugLevel\",     2,  0,  8 },\n    { \"TxCapacity\",     1024,   16, 1024 },\n    { \"RxCapacity\",     256, 32, 1024 },\n    { \"LogStatistics\",  0, 0, 10000},\n    { \"Offload.TxChecksum\", 0, 0, 31},\n    { \"Offload.TxLSO\",  0, 0, 2},\n    { \"Offload.RxCS\",   0, 0, 31},\n    { \"*IPChecksumOffloadIPv4\", 3, 0, 3 },\n    { \"*TCPChecksumOffloadIPv4\",3, 0, 3 },\n    { \"*TCPChecksumOffloadIPv6\",3, 0, 3 },\n    { \"*UDPChecksumOffloadIPv4\",3, 0, 3 },\n    { \"*UDPChecksumOffloadIPv6\",3, 0, 3 },\n    { \"*LsoV1IPv4\", 1, 0, 1 },\n    { \"*LsoV2IPv4\", 1, 0, 1 },\n    { \"*LsoV2IPv6\", 1, 0, 1 },\n    { \"*PriorityVLANTag\", 3, 0, 3},\n    { \"VlanId\", 0, 0, MAX_VLAN_ID},\n    { \"PublishIndices\", 1, 0, 1},\n    { \"MTU\", 1500, 576, 65500},\n    { \"NumberOfHandledRXPackersInDPC\", MAX_RX_LOOPS, 1, 10000},\n#if PARANDIS_SUPPORT_RSS\n    { \"*RSS\", 1, 0, 1},\n    { \"*NumRssQueues\", 8, 1, PARANDIS_RSS_MAX_RECEIVE_QUEUES},\n#endif\n#if PARANDIS_SUPPORT_RSC\n    { \"*RscIPv4\", 1, 0, 1},\n    { \"*RscIPv6\", 1, 0, 1},\n#endif\n};\n\nstatic void ParaNdis_ResetVirtIONetDevice(PARANDIS_ADAPTER *pContext)\n{\n    VirtIODeviceReset(pContext->IODevice);\n    DPrintf(0, (\"[%s] Done\\n\", __FUNCTION__));\n    /* reset all the features in the device */\n    pContext->ulCurrentVlansFilterSet = 0;\n}\n\n/**********************************************************\nGets integer value for specifies in pEntry->Name name\nParameters:\n    NDIS_HANDLE cfg  previously open configuration\n    tConfigurationEntry *pEntry - Entry to fill value in\n***********************************************************/\nstatic void GetConfigurationEntry(NDIS_HANDLE cfg, tConfigurationEntry *pEntry)\n{\n    NDIS_STATUS status;\n    const char *statusName;\n    NDIS_STRING name = {0};\n    PNDIS_CONFIGURATION_PARAMETER pParam = NULL;\n    NDIS_PARAMETER_TYPE ParameterType = NdisParameterInteger;\n    NdisInitializeString(&name, (PUCHAR)pEntry->Name);\n#pragma warning(push)\n#pragma warning(disable:6102)\n    NdisReadConfiguration(\n        &status,\n        &pParam,\n        cfg,\n        &name,\n        ParameterType);\n    if (status == NDIS_STATUS_SUCCESS)\n    {\n        ULONG ulValue = pParam->ParameterData.IntegerData;\n        if (ulValue >= pEntry->ulMinimal && ulValue <= pEntry->ulMaximal)\n        {\n            pEntry->ulValue = ulValue;\n            statusName = \"value\";\n        }\n        else\n        {\n            statusName = \"out of range\";\n        }\n    }\n    else\n    {\n        statusName = \"nothing\";\n    }\n#pragma warning(pop)\n    DPrintf(2, (\"[%s] %s read for %s - 0x%x\\n\",\n        __FUNCTION__,\n        statusName,\n        pEntry->Name,\n        pEntry->ulValue));\n    if (name.Buffer) NdisFreeString(name);\n}\n\nstatic void DisableLSOv4Permanently(PARANDIS_ADAPTER *pContext, LPCSTR procname, LPCSTR reason)\n{\n    if (pContext->Offload.flagsValue & osbT4Lso)\n    {\n        DPrintf(0, (\"[%s] Warning: %s\", procname, reason));\n        pContext->Offload.flagsValue &= ~osbT4Lso;\n        ParaNdis_ResetOffloadSettings(pContext, NULL, NULL);\n    }\n}\n\nstatic void DisableLSOv6Permanently(PARANDIS_ADAPTER *pContext, LPCSTR procname, LPCSTR reason)\n{\n    if (pContext->Offload.flagsValue & osbT6Lso)\n    {\n        DPrintf(0, (\"[%s] Warning: %s\\n\", procname, reason));\n        pContext->Offload.flagsValue &= ~osbT6Lso;\n        ParaNdis_ResetOffloadSettings(pContext, NULL, NULL);\n    }\n}\n\n/**********************************************************\nLoads NIC parameters from adapter registry key\nParameters:\n    context\n    PUCHAR *ppNewMACAddress - pointer to hold MAC address if configured from host\n***********************************************************/\nstatic void ReadNicConfiguration(PARANDIS_ADAPTER *pContext, PUCHAR pNewMACAddress)\n{\n    NDIS_HANDLE cfg;\n    tConfigurationEntries *pConfiguration = (tConfigurationEntries *) ParaNdis_AllocateMemory(pContext, sizeof(tConfigurationEntries));\n    if (pConfiguration)\n    {\n        *pConfiguration = defaultConfiguration;\n        cfg = ParaNdis_OpenNICConfiguration(pContext);\n        if (cfg)\n        {\n            GetConfigurationEntry(cfg, &pConfiguration->isLogEnabled);\n            GetConfigurationEntry(cfg, &pConfiguration->debugLevel);\n            GetConfigurationEntry(cfg, &pConfiguration->ConnectRate);\n            GetConfigurationEntry(cfg, &pConfiguration->PrioritySupport);\n            GetConfigurationEntry(cfg, &pConfiguration->TxCapacity);\n            GetConfigurationEntry(cfg, &pConfiguration->RxCapacity);\n            GetConfigurationEntry(cfg, &pConfiguration->LogStatistics);\n            GetConfigurationEntry(cfg, &pConfiguration->OffloadTxChecksum);\n            GetConfigurationEntry(cfg, &pConfiguration->OffloadTxLSO);\n            GetConfigurationEntry(cfg, &pConfiguration->OffloadRxCS);\n            GetConfigurationEntry(cfg, &pConfiguration->stdIpcsV4);\n            GetConfigurationEntry(cfg, &pConfiguration->stdTcpcsV4);\n            GetConfigurationEntry(cfg, &pConfiguration->stdTcpcsV6);\n            GetConfigurationEntry(cfg, &pConfiguration->stdUdpcsV4);\n            GetConfigurationEntry(cfg, &pConfiguration->stdUdpcsV6);\n            GetConfigurationEntry(cfg, &pConfiguration->stdLsoV1);\n            GetConfigurationEntry(cfg, &pConfiguration->stdLsoV2ip4);\n            GetConfigurationEntry(cfg, &pConfiguration->stdLsoV2ip6);\n            GetConfigurationEntry(cfg, &pConfiguration->PriorityVlanTagging);\n            GetConfigurationEntry(cfg, &pConfiguration->VlanId);\n            GetConfigurationEntry(cfg, &pConfiguration->PublishIndices);\n            GetConfigurationEntry(cfg, &pConfiguration->MTU);\n            GetConfigurationEntry(cfg, &pConfiguration->NumberOfHandledRXPackersInDPC);\n#if PARANDIS_SUPPORT_RSS\n            GetConfigurationEntry(cfg, &pConfiguration->RSSOffloadSupported);\n            GetConfigurationEntry(cfg, &pConfiguration->NumRSSQueues);\n#endif\n#if PARANDIS_SUPPORT_RSC\n            GetConfigurationEntry(cfg, &pConfiguration->RSCIPv4Supported);\n            GetConfigurationEntry(cfg, &pConfiguration->RSCIPv6Supported);\n#endif\n\n            bDebugPrint = pConfiguration->isLogEnabled.ulValue;\n            virtioDebugLevel = pConfiguration->debugLevel.ulValue;\n            pContext->maxFreeTxDescriptors = pConfiguration->TxCapacity.ulValue;\n            pContext->NetMaxReceiveBuffers = pConfiguration->RxCapacity.ulValue;\n            pContext->Limits.nPrintDiagnostic = pConfiguration->LogStatistics.ulValue;\n            pContext->uNumberOfHandledRXPacketsInDPC = pConfiguration->NumberOfHandledRXPackersInDPC.ulValue;\n            pContext->bDoSupportPriority = pConfiguration->PrioritySupport.ulValue != 0;\n            pContext->ulFormalLinkSpeed  = pConfiguration->ConnectRate.ulValue;\n            pContext->ulFormalLinkSpeed *= 1000000;\n            pContext->Offload.flagsValue = 0;\n            // TX caps: 1 - TCP, 2 - UDP, 4 - IP, 8 - TCPv6, 16 - UDPv6\n            if (pConfiguration->OffloadTxChecksum.ulValue & 1) pContext->Offload.flagsValue |= osbT4TcpChecksum | osbT4TcpOptionsChecksum;\n            if (pConfiguration->OffloadTxChecksum.ulValue & 2) pContext->Offload.flagsValue |= osbT4UdpChecksum;\n            if (pConfiguration->OffloadTxChecksum.ulValue & 4) pContext->Offload.flagsValue |= osbT4IpChecksum | osbT4IpOptionsChecksum;\n            if (pConfiguration->OffloadTxChecksum.ulValue & 8) pContext->Offload.flagsValue |= osbT6TcpChecksum | osbT6TcpOptionsChecksum;\n            if (pConfiguration->OffloadTxChecksum.ulValue & 16) pContext->Offload.flagsValue |= osbT6UdpChecksum;\n            if (pConfiguration->OffloadTxLSO.ulValue) pContext->Offload.flagsValue |= osbT4Lso | osbT4LsoIp | osbT4LsoTcp;\n            if (pConfiguration->OffloadTxLSO.ulValue > 1) pContext->Offload.flagsValue |= osbT6Lso | osbT6LsoTcpOptions;\n            // RX caps: 1 - TCP, 2 - UDP, 4 - IP, 8 - TCPv6, 16 - UDPv6\n            if (pConfiguration->OffloadRxCS.ulValue & 1) pContext->Offload.flagsValue |= osbT4RxTCPChecksum | osbT4RxTCPOptionsChecksum;\n            if (pConfiguration->OffloadRxCS.ulValue & 2) pContext->Offload.flagsValue |= osbT4RxUDPChecksum;\n            if (pConfiguration->OffloadRxCS.ulValue & 4) pContext->Offload.flagsValue |= osbT4RxIPChecksum | osbT4RxIPOptionsChecksum;\n            if (pConfiguration->OffloadRxCS.ulValue & 8) pContext->Offload.flagsValue |= osbT6RxTCPChecksum | osbT6RxTCPOptionsChecksum;\n            if (pConfiguration->OffloadRxCS.ulValue & 16) pContext->Offload.flagsValue |= osbT6RxUDPChecksum;\n            /* full packet size that can be configured as GSO for VIRTIO is short */\n            /* NDIS test fails sometimes fails on segments 50-60K */\n            pContext->Offload.maxPacketSize = PARANDIS_MAX_LSO_SIZE;\n            pContext->InitialOffloadParameters.IPv4Checksum = (UCHAR)pConfiguration->stdIpcsV4.ulValue;\n            pContext->InitialOffloadParameters.TCPIPv4Checksum = (UCHAR)pConfiguration->stdTcpcsV4.ulValue;\n            pContext->InitialOffloadParameters.TCPIPv6Checksum = (UCHAR)pConfiguration->stdTcpcsV6.ulValue;\n            pContext->InitialOffloadParameters.UDPIPv4Checksum = (UCHAR)pConfiguration->stdUdpcsV4.ulValue;\n            pContext->InitialOffloadParameters.UDPIPv6Checksum = (UCHAR)pConfiguration->stdUdpcsV6.ulValue;\n            pContext->InitialOffloadParameters.LsoV1 = (UCHAR)pConfiguration->stdLsoV1.ulValue;\n            pContext->InitialOffloadParameters.LsoV2IPv4 = (UCHAR)pConfiguration->stdLsoV2ip4.ulValue;\n            pContext->InitialOffloadParameters.LsoV2IPv6 = (UCHAR)pConfiguration->stdLsoV2ip6.ulValue;\n            pContext->ulPriorityVlanSetting = pConfiguration->PriorityVlanTagging.ulValue;\n            pContext->VlanId = pConfiguration->VlanId.ulValue & 0xfff;\n            pContext->MaxPacketSize.nMaxDataSize = pConfiguration->MTU.ulValue;\n#if PARANDIS_SUPPORT_RSS\n            pContext->bRSSOffloadSupported = pConfiguration->RSSOffloadSupported.ulValue ? TRUE : FALSE;\n            pContext->RSSMaxQueuesNumber = (CCHAR) pConfiguration->NumRSSQueues.ulValue;\n#endif\n#if PARANDIS_SUPPORT_RSC\n            pContext->RSC.bIPv4SupportedSW = (UCHAR)pConfiguration->RSCIPv4Supported.ulValue;\n            pContext->RSC.bIPv6SupportedSW = (UCHAR)pConfiguration->RSCIPv6Supported.ulValue;\n#endif\n            if (!pContext->bDoSupportPriority)\n                pContext->ulPriorityVlanSetting = 0;\n            // if Vlan not supported\n            if (!IsVlanSupported(pContext)) {\n                pContext->VlanId = 0;\n            }\n\n            {\n                NDIS_STATUS status;\n                PVOID p;\n                UINT  len = 0;\n#pragma warning(push)\n#pragma warning(disable:6102)\n                NdisReadNetworkAddress(&status, &p, &len, cfg);\n                if (status == NDIS_STATUS_SUCCESS && len == ETH_LENGTH_OF_ADDRESS)\n                {\n                    NdisMoveMemory(pNewMACAddress, p, len);\n                }\n                else if (len && len != ETH_LENGTH_OF_ADDRESS)\n                {\n                    DPrintf(0, (\"[%s] MAC address has wrong length of %d\\n\", __FUNCTION__, len));\n                }\n                else\n                {\n                    DPrintf(4, (\"[%s] Nothing read for MAC, error %X\\n\", __FUNCTION__, status));\n                }\n#pragma warning(pop)\n            }\n            NdisCloseConfiguration(cfg);\n        }\n        NdisFreeMemory(pConfiguration, 0, 0);\n    }\n}\n\nvoid ParaNdis_ResetOffloadSettings(PARANDIS_ADAPTER *pContext, tOffloadSettingsFlags *pDest, PULONG from)\n{\n    if (!pDest) pDest = &pContext->Offload.flags;\n    if (!from)  from = &pContext->Offload.flagsValue;\n\n    pDest->fTxIPChecksum = !!(*from & osbT4IpChecksum);\n    pDest->fTxTCPChecksum = !!(*from & osbT4TcpChecksum);\n    pDest->fTxUDPChecksum = !!(*from & osbT4UdpChecksum);\n    pDest->fTxTCPOptions = !!(*from & osbT4TcpOptionsChecksum);\n    pDest->fTxIPOptions = !!(*from & osbT4IpOptionsChecksum);\n\n    pDest->fTxLso = !!(*from & osbT4Lso);\n    pDest->fTxLsoIP = !!(*from & osbT4LsoIp);\n    pDest->fTxLsoTCP = !!(*from & osbT4LsoTcp);\n\n    pDest->fRxIPChecksum = !!(*from & osbT4RxIPChecksum);\n    pDest->fRxIPOptions = !!(*from & osbT4RxIPOptionsChecksum);\n    pDest->fRxTCPChecksum = !!(*from & osbT4RxTCPChecksum);\n    pDest->fRxTCPOptions = !!(*from & osbT4RxTCPOptionsChecksum);\n    pDest->fRxUDPChecksum = !!(*from & osbT4RxUDPChecksum);\n\n    pDest->fTxTCPv6Checksum = !!(*from & osbT6TcpChecksum);\n    pDest->fTxTCPv6Options = !!(*from & osbT6TcpOptionsChecksum);\n    pDest->fTxUDPv6Checksum = !!(*from & osbT6UdpChecksum);\n    pDest->fTxIPv6Ext = !!(*from & osbT6IpExtChecksum);\n\n    pDest->fTxLsov6 = !!(*from & osbT6Lso);\n    pDest->fTxLsov6IP = !!(*from & osbT6LsoIpExt);\n    pDest->fTxLsov6TCP = !!(*from & osbT6LsoTcpOptions);\n\n    pDest->fRxTCPv6Checksum = !!(*from & osbT6RxTCPChecksum);\n    pDest->fRxTCPv6Options = !!(*from & osbT6RxTCPOptionsChecksum);\n    pDest->fRxUDPv6Checksum = !!(*from & osbT6RxUDPChecksum);\n    pDest->fRxIPv6Ext = !!(*from & osbT6RxIpExtChecksum);\n}\n\n/**********************************************************\nEnumerates adapter resources and fills the structure holding them\nVerifies that IO assigned and has correct size\nVerifies that interrupt assigned\nParameters:\n    PNDIS_RESOURCE_LIST RList - list of resources, received from NDIS\n    tAdapterResources *pResources - structure to fill\nReturn value:\n    TRUE if everything is OK\n***********************************************************/\nstatic BOOLEAN GetAdapterResources(PNDIS_RESOURCE_LIST RList, tAdapterResources *pResources)\n{\n    UINT i;\n    NdisZeroMemory(pResources, sizeof(*pResources));\n    for (i = 0; i < RList->Count; ++i)\n    {\n        ULONG type = RList->PartialDescriptors[i].Type;\n        if (type == CmResourceTypePort)\n        {\n            PHYSICAL_ADDRESS Start = RList->PartialDescriptors[i].u.Port.Start;\n            ULONG len = RList->PartialDescriptors[i].u.Port.Length;\n            DPrintf(0, (\"Found IO ports at %08lX(%d)\\n\", Start.LowPart, len));\n            pResources->ulIOAddress = Start.LowPart;\n            pResources->IOLength = len;\n        }\n        else if (type == CmResourceTypeInterrupt)\n        {\n            pResources->Vector = RList->PartialDescriptors[i].u.Interrupt.Vector;\n            pResources->Level = RList->PartialDescriptors[i].u.Interrupt.Level;\n            pResources->Affinity = RList->PartialDescriptors[i].u.Interrupt.Affinity;\n            pResources->InterruptFlags = RList->PartialDescriptors[i].Flags;\n            DPrintf(0, (\"Found Interrupt vector %d, level %d, affinity %X, flags %X\\n\",\n                pResources->Vector, pResources->Level, (ULONG)pResources->Affinity, pResources->InterruptFlags));\n        }\n    }\n    return pResources->ulIOAddress && pResources->Vector;\n}\n\nstatic void DumpVirtIOFeatures(PPARANDIS_ADAPTER pContext)\n{\n    static const struct {  ULONG bitmask;  PCHAR Name; } Features[] =\n    {\n\n        {VIRTIO_NET_F_CSUM, \"VIRTIO_NET_F_CSUM\" },\n        {VIRTIO_NET_F_GUEST_CSUM, \"VIRTIO_NET_F_GUEST_CSUM\" },\n        {VIRTIO_NET_F_MAC, \"VIRTIO_NET_F_MAC\" },\n        {VIRTIO_NET_F_GSO, \"VIRTIO_NET_F_GSO\" },\n        {VIRTIO_NET_F_GUEST_TSO4, \"VIRTIO_NET_F_GUEST_TSO4\"},\n        {VIRTIO_NET_F_GUEST_TSO6, \"VIRTIO_NET_F_GUEST_TSO6\"},\n        {VIRTIO_NET_F_GUEST_ECN, \"VIRTIO_NET_F_GUEST_ECN\"},\n        {VIRTIO_NET_F_GUEST_UFO, \"VIRTIO_NET_F_GUEST_UFO\"},\n        {VIRTIO_NET_F_HOST_TSO4, \"VIRTIO_NET_F_HOST_TSO4\"},\n        {VIRTIO_NET_F_HOST_TSO6, \"VIRTIO_NET_F_HOST_TSO6\"},\n        {VIRTIO_NET_F_HOST_ECN, \"VIRTIO_NET_F_HOST_ECN\"},\n        {VIRTIO_NET_F_HOST_UFO, \"VIRTIO_NET_F_HOST_UFO\"},\n        {VIRTIO_NET_F_MRG_RXBUF, \"VIRTIO_NET_F_MRG_RXBUF\"},\n        {VIRTIO_NET_F_STATUS, \"VIRTIO_NET_F_STATUS\"},\n        {VIRTIO_NET_F_CTRL_VQ, \"VIRTIO_NET_F_CTRL_VQ\"},\n        {VIRTIO_NET_F_CTRL_RX, \"VIRTIO_NET_F_CTRL_RX\"},\n        {VIRTIO_NET_F_CTRL_VLAN, \"VIRTIO_NET_F_CTRL_VLAN\"},\n        {VIRTIO_NET_F_CTRL_RX_EXTRA, \"VIRTIO_NET_F_CTRL_RX_EXTRA\"},\n        {VIRTIO_NET_F_CTRL_MAC_ADDR, \"VIRTIO_NET_F_CTRL_MAC_ADDR\"},\n        {VIRTIO_F_INDIRECT, \"VIRTIO_F_INDIRECT\"},\n        {VIRTIO_F_ANY_LAYOUT, \"VIRTIO_F_ANY_LAYOUT\"},\n        { VIRTIO_RING_F_EVENT_IDX, \"VIRTIO_RING_F_EVENT_IDX\" },\n    };\n    UINT i;\n    for (i = 0; i < sizeof(Features)/sizeof(Features[0]); ++i)\n    {\n        if (VirtIOIsFeatureEnabled(pContext->u32HostFeatures, Features[i].bitmask))\n        {\n            DPrintf(0, (\"VirtIO Host Feature %s\\n\", Features[i].Name));\n        }\n    }\n}\n\nstatic BOOLEAN\nAckFeature(PPARANDIS_ADAPTER pContext, UINT32 Feature)\n{\n    if (VirtIOIsFeatureEnabled(pContext->u32HostFeatures, Feature))\n    {\n        VirtIOFeatureEnable(pContext->u32GuestFeatures, Feature);\n        return TRUE;\n    }\n    return FALSE;\n}\n\n/**********************************************************\nPrints out statistics\n***********************************************************/\nstatic void PrintStatistics(PARANDIS_ADAPTER *pContext)\n{\n    ULONG64 totalTxFrames =\n        pContext->Statistics.ifHCOutBroadcastPkts +\n        pContext->Statistics.ifHCOutMulticastPkts +\n        pContext->Statistics.ifHCOutUcastPkts;\n    ULONG64 totalRxFrames =\n        pContext->Statistics.ifHCInBroadcastPkts +\n        pContext->Statistics.ifHCInMulticastPkts +\n        pContext->Statistics.ifHCInUcastPkts;\n\n#if 0 /* TODO - setup accessor functions*/\n    DPrintf(0, (\"[Diag!%X] RX buffers at VIRTIO %d of %d\\n\",\n        pContext->CurrentMacAddress[5],\n        pContext->RXPath.m_NetNofReceiveBuffers,\n        pContext->NetMaxReceiveBuffers));\n\n    DPrintf(0, (\"[Diag!] TX desc available %d/%d, buf %d\\n\",\n        pContext->TXPath.GetFreeTXDescriptors(),\n        pContext->maxFreeTxDescriptors,\n        pContext->TXPath.GetFreeHWBuffers()));\n#endif\n    DPrintf(0, (\"[Diag!] Bytes transmitted %I64u, received %I64u\\n\",\n        pContext->Statistics.ifHCOutOctets,\n        pContext->Statistics.ifHCInOctets));\n    DPrintf(0, (\"[Diag!] Tx frames %I64u, CSO %d, LSO %d, indirect %d\\n\",\n        totalTxFrames,\n        pContext->extraStatistics.framesCSOffload,\n        pContext->extraStatistics.framesLSO,\n        pContext->extraStatistics.framesIndirect));\n    DPrintf(0, (\"[Diag!] Rx frames %I64u, Rx.Pri %d, RxHwCS.OK %d, FiltOut %d\\n\",\n        totalRxFrames, pContext->extraStatistics.framesRxPriority,\n        pContext->extraStatistics.framesRxCSHwOK, pContext->extraStatistics.framesFilteredOut));\n    if (pContext->extraStatistics.framesRxCSHwMissedBad || pContext->extraStatistics.framesRxCSHwMissedGood)\n    {\n        DPrintf(0, (\"[Diag!] RxHwCS mistakes: missed bad %d, missed good %d\\n\",\n            pContext->extraStatistics.framesRxCSHwMissedBad, pContext->extraStatistics.framesRxCSHwMissedGood));\n    }\n}\n\nstatic\nVOID InitializeRSCState(PPARANDIS_ADAPTER pContext)\n{\n#if PARANDIS_SUPPORT_RSC\n\n    pContext->RSC.bIPv4Enabled = FALSE;\n    pContext->RSC.bIPv6Enabled = FALSE;\n\n    if(!pContext->bGuestChecksumSupported)\n    {\n        DPrintf(0, (\"[%s] Guest TSO cannot be enabled without guest checksum\\n\", __FUNCTION__) );\n        return;\n    }\n\n    if(pContext->RSC.bIPv4SupportedSW)\n    {\n        pContext->RSC.bIPv4Enabled =\n            pContext->RSC.bIPv4SupportedHW =\n                AckFeature(pContext, VIRTIO_NET_F_GUEST_TSO4);\n    }\n    else\n    {\n        pContext->RSC.bIPv4SupportedHW =\n            VirtIOIsFeatureEnabled(pContext->u32HostFeatures, VIRTIO_NET_F_GUEST_TSO4);\n    }\n\n    if(pContext->RSC.bIPv6SupportedSW)\n    {\n        pContext->RSC.bIPv6Enabled =\n            pContext->RSC.bIPv6SupportedHW =\n                AckFeature(pContext, VIRTIO_NET_F_GUEST_TSO6);\n    }\n    else\n    {\n        pContext->RSC.bIPv6SupportedHW =\n            VirtIOIsFeatureEnabled(pContext->u32HostFeatures, VIRTIO_NET_F_GUEST_TSO6);\n    }\n\n    pContext->RSC.bHasDynamicConfig = (pContext->RSC.bIPv4Enabled || pContext->RSC.bIPv6Enabled) &&\n                                      AckFeature(pContext, VIRTIO_NET_F_CTRL_GUEST_OFFLOADS);\n\n    DPrintf(0, (\"[%s] Guest TSO state: IP4=%d, IP6=%d, Dynamic=%d\\n\", __FUNCTION__,\n        pContext->RSC.bIPv4Enabled, pContext->RSC.bIPv6Enabled, pContext->RSC.bHasDynamicConfig) );\n#else\n    UNREFERENCED_PARAMETER(pContext);\n#endif\n}\n\nstatic __inline void\nDumpMac(int dbg_level, const char* header_str, UCHAR* mac)\n{\n    DPrintf(dbg_level,(\"%s: %02x-%02x-%02x-%02x-%02x-%02x\\n\",\n        header_str, mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]));\n\n}\n\nstatic __inline void\nSetDeviceMAC(PPARANDIS_ADAPTER pContext, PUCHAR pDeviceMAC)\n{\n    if(pContext->bCfgMACAddrSupported && !pContext->bCtrlMACAddrSupported)\n    {\n        VirtIODeviceSet(pContext->IODevice, 0, pDeviceMAC, ETH_LENGTH_OF_ADDRESS);\n    }\n}\n\nstatic void\nInitializeMAC(PPARANDIS_ADAPTER pContext, PUCHAR pCurrentMAC)\n{\n    //Acknowledge related features\n    pContext->bCfgMACAddrSupported = AckFeature(pContext, VIRTIO_NET_F_MAC);\n    pContext->bCtrlMACAddrSupported = AckFeature(pContext, VIRTIO_NET_F_CTRL_MAC_ADDR);\n\n    //Read and validate permanent MAC address\n    if (pContext->bCfgMACAddrSupported)\n    {\n        VirtIODeviceGet(pContext->IODevice, 0, &pContext->PermanentMacAddress, ETH_LENGTH_OF_ADDRESS);\n        if (!ParaNdis_ValidateMacAddress(pContext->PermanentMacAddress, FALSE))\n        {\n            DumpMac(0, \"Invalid device MAC ignored\", pContext->PermanentMacAddress);\n            NdisZeroMemory(pContext->PermanentMacAddress, sizeof(pContext->PermanentMacAddress));\n        }\n    }\n\n    if (ETH_IS_EMPTY(pContext->PermanentMacAddress))\n    {\n        pContext->PermanentMacAddress[0] = 0x02;\n        pContext->PermanentMacAddress[1] = 0x50;\n        pContext->PermanentMacAddress[2] = 0xF2;\n        pContext->PermanentMacAddress[3] = 0x00;\n        pContext->PermanentMacAddress[4] = 0x01;\n        pContext->PermanentMacAddress[5] = 0x80 | (UCHAR)(pContext->ulUniqueID & 0xFF);\n        DumpMac(0, \"No device MAC present, use default\", pContext->PermanentMacAddress);\n    }\n    DumpMac(0, \"Permanent device MAC\", pContext->PermanentMacAddress);\n\n    //Read and validate configured MAC address\n    if (ParaNdis_ValidateMacAddress(pCurrentMAC, TRUE))\n    {\n        DPrintf(0, (\"[%s] MAC address from configuration used\\n\", __FUNCTION__));\n        ETH_COPY_NETWORK_ADDRESS(pContext->CurrentMacAddress, pCurrentMAC);\n    }\n    else\n    {\n        DPrintf(0, (\"No valid MAC configured\\n\", __FUNCTION__));\n        ETH_COPY_NETWORK_ADDRESS(pContext->CurrentMacAddress, pContext->PermanentMacAddress);\n    }\n\n    //If control channel message for MAC address configuration is not supported\n    //  Configure device with actual MAC address via configurations space\n    //Else actual MAC address will be configured later via control queue\n    SetDeviceMAC(pContext, pContext->CurrentMacAddress);\n\n    DumpMac(0, \"Actual MAC\", pContext->CurrentMacAddress);\n}\n\nstatic __inline void\nRestoreMAC(PPARANDIS_ADAPTER pContext)\n{\n    SetDeviceMAC(pContext, pContext->PermanentMacAddress);\n}\n\n/**********************************************************\nInitializes the context structure\nMajor variables, received from NDIS on initialization, must be be set before this call\n(for ex. pContext->MiniportHandle)\n\nIf this procedure fails, no need to call\n    ParaNdis_CleanupContext\n\n\nParameters:\nReturn value:\n    SUCCESS, if resources are OK\n    NDIS_STATUS_RESOURCE_CONFLICT if not\n***********************************************************/\nNDIS_STATUS ParaNdis_InitializeContext(\n    PARANDIS_ADAPTER *pContext,\n    PNDIS_RESOURCE_LIST pResourceList)\n{\n    NDIS_STATUS status = NDIS_STATUS_SUCCESS;\n    USHORT linkStatus = 0;\n    UCHAR CurrentMAC[ETH_LENGTH_OF_ADDRESS] = {0};\n    ULONG dependentOptions;\n\n    DEBUG_ENTRY(0);\n\n    ReadNicConfiguration(pContext, CurrentMAC);\n\n    pContext->fCurrentLinkState = MediaConnectStateUnknown;\n    pContext->powerState = NdisDeviceStateUnspecified;\n\n    pContext->MaxPacketSize.nMaxFullSizeOS = pContext->MaxPacketSize.nMaxDataSize + ETH_HEADER_SIZE;\n    pContext->MaxPacketSize.nMaxFullSizeHwTx = pContext->MaxPacketSize.nMaxFullSizeOS;\n#if PARANDIS_SUPPORT_RSC\n    pContext->MaxPacketSize.nMaxDataSizeHwRx = MAX_HW_RX_PACKET_SIZE;\n    pContext->MaxPacketSize.nMaxFullSizeOsRx = MAX_OS_RX_PACKET_SIZE;\n#else\n    pContext->MaxPacketSize.nMaxDataSizeHwRx = pContext->MaxPacketSize.nMaxFullSizeOS + ETH_PRIORITY_HEADER_SIZE;\n    pContext->MaxPacketSize.nMaxFullSizeOsRx = pContext->MaxPacketSize.nMaxFullSizeOS;\n#endif\n    if (pContext->ulPriorityVlanSetting)\n        pContext->MaxPacketSize.nMaxFullSizeHwTx = pContext->MaxPacketSize.nMaxFullSizeOS + ETH_PRIORITY_HEADER_SIZE;\n\n    if (GetAdapterResources(pResourceList, &pContext->AdapterResources) &&\n        NDIS_STATUS_SUCCESS == NdisMRegisterIoPortRange(\n            &pContext->pIoPortOffset,\n            pContext->MiniportHandle,\n            pContext->AdapterResources.ulIOAddress,\n            pContext->AdapterResources.IOLength)\n        )\n    {\n        if (pContext->AdapterResources.InterruptFlags & CM_RESOURCE_INTERRUPT_MESSAGE)\n        {\n            DPrintf(0, (\"[%s] Message interrupt assigned\\n\", __FUNCTION__));\n            pContext->bUsingMSIX = TRUE;\n        }\n\n        VirtIODeviceInitialize(pContext->IODevice, pContext->AdapterResources.ulIOAddress, sizeof(*pContext->IODevice));\n        VirtIODeviceSetMSIXUsed(pContext->IODevice, pContext->bUsingMSIX ? true : false);\n        ParaNdis_ResetVirtIONetDevice(pContext);\n        VirtIODeviceAddStatus(pContext->IODevice, VIRTIO_CONFIG_S_ACKNOWLEDGE);\n        VirtIODeviceAddStatus(pContext->IODevice, VIRTIO_CONFIG_S_DRIVER);\n        pContext->u32HostFeatures = VirtIODeviceReadHostFeatures(pContext->IODevice);\n        DumpVirtIOFeatures(pContext);\n\n        pContext->bLinkDetectSupported = AckFeature(pContext, VIRTIO_NET_F_STATUS);\n        if(pContext->bLinkDetectSupported) {\n            VirtIODeviceGet(pContext->IODevice, ETH_LENGTH_OF_ADDRESS, &linkStatus, sizeof(linkStatus));\n            pContext->bConnected = (linkStatus & VIRTIO_NET_S_LINK_UP) != 0;\n            DPrintf(0, (\"[%s] Link status on driver startup: %d\\n\", __FUNCTION__, pContext->bConnected));\n        }\n\n        InitializeMAC(pContext, CurrentMAC);\n\n        pContext->bUseMergedBuffers = AckFeature(pContext, VIRTIO_NET_F_MRG_RXBUF);\n        pContext->nVirtioHeaderSize = (pContext->bUseMergedBuffers) ? sizeof(virtio_net_hdr_ext) : sizeof(virtio_net_hdr_basic);\n        pContext->bDoPublishIndices = AckFeature(pContext, VIRTIO_RING_F_EVENT_IDX);\n    }\n    else\n    {\n        DPrintf(0, (\"[%s] Error: Incomplete resources\\n\", __FUNCTION__));\n        /* avoid deregistering if failed */\n        pContext->AdapterResources.ulIOAddress = 0;\n        status = NDIS_STATUS_RESOURCE_CONFLICT;\n    }\n\n    pContext->bMultiQueue = AckFeature(pContext, VIRTIO_NET_F_CTRL_MQ);\n    if (pContext->bMultiQueue)\n    {\n        VirtIODeviceGet(pContext->IODevice, ETH_LENGTH_OF_ADDRESS + sizeof(USHORT), &pContext->nHardwareQueues,\n            sizeof(pContext->nHardwareQueues));\n    }\n    else\n    {\n        pContext->nHardwareQueues = 1;\n    }\n\n    dependentOptions = osbT4TcpChecksum | osbT4UdpChecksum | osbT4TcpOptionsChecksum;\n\n    if((pContext->Offload.flagsValue & dependentOptions) && !AckFeature(pContext, VIRTIO_NET_F_CSUM))\n    {\n        DPrintf(0, (\"[%s] Host does not support CSUM, disabling CS offload\\n\", __FUNCTION__) );\n        pContext->Offload.flagsValue &= ~dependentOptions;\n    }\n\n    pContext->bGuestChecksumSupported = AckFeature(pContext, VIRTIO_NET_F_GUEST_CSUM);\n    AckFeature(pContext, VIRTIO_NET_F_CTRL_VQ);\n\n    InitializeRSCState(pContext);\n\n    // now, after we checked the capabilities, we can initialize current\n    // configuration of offload tasks\n    ParaNdis_ResetOffloadSettings(pContext, NULL, NULL);\n\n    if (pContext->Offload.flags.fTxLso && !AckFeature(pContext, VIRTIO_NET_F_HOST_TSO4))\n    {\n        DisableLSOv4Permanently(pContext, __FUNCTION__, \"Host does not support TSOv4\\n\");\n    }\n\n    if (pContext->Offload.flags.fTxLsov6 && !AckFeature(pContext, VIRTIO_NET_F_HOST_TSO6))\n    {\n        DisableLSOv6Permanently(pContext, __FUNCTION__, \"Host does not support TSOv6\");\n    }\n\n    pContext->bUseIndirect = AckFeature(pContext, VIRTIO_F_INDIRECT);\n    pContext->bAnyLaypout = AckFeature(pContext, VIRTIO_F_ANY_LAYOUT);\n\n    pContext->bHasHardwareFilters = AckFeature(pContext, VIRTIO_NET_F_CTRL_RX_EXTRA);\n\n    InterlockedExchange(&pContext->ReuseBufferRegular, TRUE);\n\n    VirtIODeviceWriteGuestFeatures(pContext->IODevice, pContext->u32GuestFeatures);\n    NdisInitializeEvent(&pContext->ResetEvent);\n    DEBUG_EXIT_STATUS(0, status);\n    return status;\n}\n\nvoid ParaNdis_FreeRxBufferDescriptor(PARANDIS_ADAPTER *pContext, pRxNetDescriptor p)\n{\n    ULONG i;\n    for(i = 0; i < p->PagesAllocated; i++)\n    {\n        ParaNdis_FreePhysicalMemory(pContext, &p->PhysicalPages[i]);\n    }\n\n    if(p->BufferSGArray) NdisFreeMemory(p->BufferSGArray, 0, 0);\n    if(p->PhysicalPages) NdisFreeMemory(p->PhysicalPages, 0, 0);\n    NdisFreeMemory(p, 0, 0);\n}\n\n/**********************************************************\nAllocates maximum RX buffers for incoming packets\nBuffers are chained in NetReceiveBuffers\nParameters:\n    context\n***********************************************************/\n\nvoid ParaNdis_DeleteQueue(PARANDIS_ADAPTER *pContext, struct virtqueue **ppq, tCompletePhysicalAddress *ppa)\n{\n    if (*ppq) VirtIODeviceDeleteQueue(*ppq, NULL);\n    *ppq = NULL;\n    if (ppa->Virtual) ParaNdis_FreePhysicalMemory(pContext, ppa);\n    RtlZeroMemory(ppa, sizeof(*ppa));\n}\n\n#if PARANDIS_SUPPORT_RSS\nstatic USHORT DetermineQueueNumber(PARANDIS_ADAPTER *pContext)\n{\n    if (!pContext->bUsingMSIX)\n    {\n        DPrintf(0, (\"[%s] No MSIX, using 1 queue\\n\", __FUNCTION__));\n        return 1;\n    }\n\n    if (pContext->bMultiQueue)\n    {\n        DPrintf(0, (\"[%s] Number of hardware queues = %d\\n\", __FUNCTION__, pContext->nHardwareQueues));\n    }\n    else\n    {\n        DPrintf(0, (\"[%s] - CTRL_MQ not acked, # bindles set to 1\\n\", __FUNCTION__));\n        return 1;\n    }\n\n    ULONG lnProcessors;\n#if NDIS_SUPPORT_NDIS620\n    lnProcessors = NdisGroupActiveProcessorCount(ALL_PROCESSOR_GROUPS);\n#elif NDIS_SUPPORT_NDIS6\n    lnProcessors = NdisSystemProcessorCount();\n#else\n    lnProcessors = 1;\n#endif\n\n    ULONG lnMSIs = (pContext->pMSIXInfoTable->MessageCount - 1) / 2; /* RX/TX pairs + control queue*/\n\n    DPrintf(0, (\"[%s] %lu CPUs reported\\n\", __FUNCTION__, lnProcessors));\n    DPrintf(0, (\"[%s] %lu MSIs, %lu queues\\n\", __FUNCTION__, pContext->pMSIXInfoTable->MessageCount, lnMSIs));\n\n    USHORT nMSIs = USHORT(lnMSIs & 0xFFFF);\n    USHORT nProcessors = USHORT(lnProcessors & 0xFFFF);\n\n    DPrintf(0, (\"[%s] %u CPUs reported\\n\", __FUNCTION__, nProcessors));\n    DPrintf(0, (\"[%s] %lu MSIs, %u queues\\n\", __FUNCTION__, pContext->pMSIXInfoTable->MessageCount, nMSIs));\n\n    USHORT nBundles = (pContext->nHardwareQueues < nProcessors) ? pContext->nHardwareQueues : nProcessors;\n    nBundles = (nMSIs < nBundles) ? nMSIs : nBundles;\n\n    DPrintf(0, (\"[%s] # of path bundles = %u\\n\", __FUNCTION__, nBundles));\n\n    return nBundles;\n}\n#else\nstatic USHORT DetermineQueueNumber(PARANDIS_ADAPTER *)\n{\n    return 1;\n}\n#endif\n\nstatic NDIS_STATUS SetupDPCTarget(PARANDIS_ADAPTER *pContext)\n{\n    ULONG i;\n#if NDIS_SUPPORT_NDIS620\n    NDIS_STATUS status;\n    PROCESSOR_NUMBER procNumber;\n#endif\n\n    for (i = 0; i < pContext->nPathBundles; i++)\n    {\n#if NDIS_SUPPORT_NDIS620\n        status = KeGetProcessorNumberFromIndex(i, &procNumber);\n        if (status != NDIS_STATUS_SUCCESS)\n        {\n            DPrintf(0, (\"[%s] - KeGetProcessorNumberFromIndex failed for index %lu - %d\\n\", __FUNCTION__, i, status));\n            return status;\n        }\n        ParaNdis_ProcessorNumberToGroupAffinity(&pContext->pPathBundles[i].rxPath.DPCAffinity, &procNumber);\n        pContext->pPathBundles[i].txPath.DPCAffinity = pContext->pPathBundles[i].rxPath.DPCAffinity;\n#elif NDIS_SUPPORT_NDIS6\n        pContext->pPathBundles[i].rxPath.DPCTargetProcessor = 1i64 << i;\n        pContext->pPathBundles[i].txPath.DPCTargetProcessor = pContext->pPathBundles[i].rxPath.DPCTargetProcessor;\n#else\n#error not supported\n#endif\n    }\n\n#if NDIS_SUPPORT_NDIS620\n    pContext->CXPath.DPCAffinity = pContext->pPathBundles[0].rxPath.DPCAffinity;\n#elif NDIS_SUPPORT_NDIS6\n    pContext->CXPath.DPCTargetProcessor = pContext->pPathBundles[0].rxPath.DPCTargetProcessor;\n#else\n#error not yet defined\n#endif\n    return NDIS_STATUS_SUCCESS;\n}\n\n#if PARANDIS_SUPPORT_RSS\nNDIS_STATUS ParaNdis_SetupRSSQueueMap(PARANDIS_ADAPTER *pContext)\n{\n    USHORT rssIndex, bundleIndex;\n    ULONG cpuIndex;\n    ULONG rssTableSize = pContext->RSSParameters.RSSScalingSettings.IndirectionTableSize / sizeof(PROCESSOR_NUMBER);\n\n    rssIndex = 0;\n    bundleIndex = 0;\n    USHORT *cpuIndexTable;\n    ULONG cpuNumbers;\n\n    cpuNumbers = KeQueryActiveProcessorCountEx(ALL_PROCESSOR_GROUPS);\n\n    cpuIndexTable = (USHORT *)NdisAllocateMemoryWithTagPriority(pContext->MiniportHandle, cpuNumbers * sizeof(*cpuIndexTable),\n        PARANDIS_MEMORY_TAG, NormalPoolPriority);\n    if (cpuIndexTable == nullptr)\n    {\n        DPrintf(0, (\"[%s] cpu index table allocation failed\\n\", __FUNCTION__));\n        return NDIS_STATUS_RESOURCES;\n    }\n\n    NdisZeroMemory(cpuIndexTable, sizeof(*cpuIndexTable) * cpuNumbers);\n\n    for (bundleIndex = 0; bundleIndex < pContext->nPathBundles; ++bundleIndex)\n    {\n        cpuIndex = pContext->pPathBundles[bundleIndex].rxPath.getCPUIndex();\n        if (cpuIndex == INVALID_PROCESSOR_INDEX)\n        {\n            DPrintf(0, (\"[%s]  Invalid CPU index for path %u\\n\", __FUNCTION__, bundleIndex));\n            NdisFreeMemoryWithTagPriority(pContext->MiniportHandle, cpuIndexTable, PARANDIS_MEMORY_TAG);\n            return NDIS_STATUS_SOFT_ERRORS;\n        }\n        else if (cpuIndex >= cpuNumbers)\n        {\n            DPrintf(0, (\"[%s]  CPU index %lu exceeds CPU range %lu\\n\", __FUNCTION__, cpuIndex, cpuNumbers));\n            NdisFreeMemoryWithTagPriority(pContext->MiniportHandle, cpuIndexTable, PARANDIS_MEMORY_TAG);\n            return NDIS_STATUS_SOFT_ERRORS;\n        }\n        else\n        {\n            cpuIndexTable[cpuIndex] = bundleIndex;\n        }\n    }\n\n    DPrintf(0, (\"[%s] Entering, RSS table size = %lu, # of path bundles = %u. RSS2QueueLength = %u, RSS2QueueMap =0x%p\\n\",\n        __FUNCTION__, rssTableSize, pContext->nPathBundles,\n        pContext->RSS2QueueLength, pContext->RSS2QueueMap));\n\n    if (pContext->RSS2QueueLength && pContext->RSS2QueueLength < rssTableSize)\n    {\n        DPrintf(0, (\"[%s] Freeing RSS2Queue Map\\n\", __FUNCTION__));\n        NdisFreeMemoryWithTagPriority(pContext->MiniportHandle, pContext->RSS2QueueMap, PARANDIS_MEMORY_TAG);\n        pContext->RSS2QueueLength = 0;\n    }\n\n    if (!pContext->RSS2QueueLength)\n    {\n        pContext->RSS2QueueLength = USHORT(rssTableSize);\n        pContext->RSS2QueueMap = (CPUPathesBundle **)NdisAllocateMemoryWithTagPriority(pContext->MiniportHandle, rssTableSize * sizeof(*pContext->RSS2QueueMap),\n            PARANDIS_MEMORY_TAG, NormalPoolPriority);\n        if (pContext->RSS2QueueMap == nullptr)\n        {\n            DPrintf(0, (\"[%s] - Allocating RSS to queue mapping failed\\n\", __FUNCTION__));\n            NdisFreeMemoryWithTagPriority(pContext->MiniportHandle, cpuIndexTable, PARANDIS_MEMORY_TAG);\n            return NDIS_STATUS_RESOURCES;\n        }\n\n        NdisZeroMemory(pContext->RSS2QueueMap, sizeof(*pContext->RSS2QueueMap) * pContext->RSS2QueueLength);\n    }\n\n    for (rssIndex = 0; rssIndex < rssTableSize; rssIndex++)\n    {\n       pContext->RSS2QueueMap[rssIndex] = pContext->pPathBundles;\n    }\n\n    for (rssIndex = 0; rssIndex < rssTableSize; rssIndex++)\n    {\n        cpuIndex = NdisProcessorNumberToIndex(pContext->RSSParameters.RSSScalingSettings.IndirectionTable[rssIndex]);\n        bundleIndex = cpuIndexTable[cpuIndex];\n\n        DPrintf(3, (\"[%s] filling the relationship, rssIndex = %u, bundleIndex = %u\\n\", __FUNCTION__, rssIndex, bundleIndex));\n        DPrintf(3, (\"[%s] RSS proc number %u/%u, bundle affinity %u/%u\\n\", __FUNCTION__,\n            pContext->RSSParameters.RSSScalingSettings.IndirectionTable[rssIndex].Group,\n            pContext->RSSParameters.RSSScalingSettings.IndirectionTable[rssIndex].Number,\n            pContext->pPathBundles[bundleIndex].txPath.DPCAffinity.Group,\n            pContext->pPathBundles[bundleIndex].txPath.DPCAffinity.Mask));\n\n        pContext->RSS2QueueMap[rssIndex] = pContext->pPathBundles + bundleIndex;\n    }\n\n    NdisFreeMemoryWithTagPriority(pContext->MiniportHandle, cpuIndexTable, PARANDIS_MEMORY_TAG);\n    return NDIS_STATUS_SUCCESS;\n}\n#endif\n\n/**********************************************************\nInitializes VirtIO buffering and related stuff:\nAllocates RX and TX queues and buffers\nParameters:\n    context\nReturn value:\n    TRUE if both queues are allocated\n***********************************************************/\nstatic NDIS_STATUS ParaNdis_VirtIONetInit(PARANDIS_ADAPTER *pContext)\n{\n    NDIS_STATUS status = NDIS_STATUS_RESOURCES;\n    DEBUG_ENTRY(0);\n    UINT i;\n    USHORT nVirtIOQueues = pContext->nHardwareQueues * 2 + 2;\n\n    pContext->nPathBundles = DetermineQueueNumber(pContext);\n    if (pContext->nPathBundles == 0)\n    {\n        DPrintf(0, (\"[%s] - no I/O pathes\\n\", __FUNCTION__));\n        return NDIS_STATUS_RESOURCES;\n    }\n\n    if (nVirtIOQueues > pContext->IODevice->maxQueues)\n    {\n        ULONG IODeviceSize = VirtIODeviceSizeRequired(nVirtIOQueues);\n\n        NdisFreeMemoryWithTagPriority(pContext->MiniportHandle, pContext->IODevice, PARANDIS_MEMORY_TAG);\n        pContext->IODevice = (VirtIODevice *)NdisAllocateMemoryWithTagPriority(\n            pContext->MiniportHandle,\n            IODeviceSize,\n            PARANDIS_MEMORY_TAG,\n            NormalPoolPriority);\n        if (pContext->IODevice == nullptr)\n        {\n            DPrintf(0, (\"[%s] - IODevice allocation failed\\n\", __FUNCTION__));\n            return NDIS_STATUS_RESOURCES;\n        }\n\n        VirtIODeviceInitialize(pContext->IODevice, pContext->AdapterResources.ulIOAddress, IODeviceSize);\n        VirtIODeviceSetMSIXUsed(pContext->IODevice, pContext->bUsingMSIX ? true : false);\n        DPrintf(0, (\"[%s] %u queues' slots reallocated for size %lu\\n\", __FUNCTION__, pContext->IODevice->maxQueues, IODeviceSize));\n    }\n\n    new (&pContext->CXPath, PLACEMENT_NEW) CParaNdisCX();\n    pContext->bCXPathAllocated = TRUE;\n    if (!pContext->CXPath.Create(pContext, 2 * pContext->nHardwareQueues))\n    {\n        DPrintf(0, (\"[%s] The Control vQueue does not work!\\n\", __FUNCTION__));\n        pContext->bHasHardwareFilters = FALSE;\n        pContext->bCtrlMACAddrSupported = FALSE;\n    }\n    else\n    {\n        pContext->bCXPathCreated = TRUE;\n    }\n\n    pContext->pPathBundles = (CPUPathesBundle *)NdisAllocateMemoryWithTagPriority(pContext->MiniportHandle, pContext->nPathBundles * sizeof(*pContext->pPathBundles),\n        PARANDIS_MEMORY_TAG, NormalPoolPriority);\n    if (pContext->pPathBundles == nullptr)\n    {\n        DPrintf(0, (\"[%s] Path bundles allocation failed\\n\", __FUNCTION__));\n        return status;\n    }\n\n    for (i = 0; i < pContext->nPathBundles; i++)\n    {\n        new (pContext->pPathBundles + i, PLACEMENT_NEW) CPUPathesBundle();\n\n        if (!pContext->pPathBundles[i].rxPath.Create(pContext, i * 2))\n        {\n            DPrintf(0, (\"%s: CParaNdisRX creation failed\\n\", __FUNCTION__));\n            return status;\n        }\n        pContext->pPathBundles[i].rxCreated = true;\n\n        if (!pContext->pPathBundles[i].txPath.Create(pContext, i * 2 + 1))\n        {\n            DPrintf(0, (\"%s: CParaNdisTX creation failed\\n\", __FUNCTION__));\n            return status;\n        }\n        pContext->pPathBundles[i].txCreated = true;\n    }\n\n    if (pContext->bCXPathCreated)\n    {\n        pContext->pPathBundles[0].cxPath = &pContext->CXPath;\n    }\n\n    status = NDIS_STATUS_SUCCESS;\n\n    return status;\n}\n\nstatic void ReadLinkState(PARANDIS_ADAPTER *pContext)\n{\n    if (pContext->bLinkDetectSupported)\n    {\n        USHORT linkStatus = 0;\n        VirtIODeviceGet(pContext->IODevice, ETH_LENGTH_OF_ADDRESS, &linkStatus, sizeof(linkStatus));\n        pContext->bConnected = !!(linkStatus & VIRTIO_NET_S_LINK_UP);\n    }\n    else\n    {\n        pContext->bConnected = TRUE;\n    }\n}\n\nstatic void ParaNdis_RemoveDriverOKStatus(PPARANDIS_ADAPTER pContext )\n{\n    VirtIODeviceRemoveStatus(pContext->IODevice, VIRTIO_CONFIG_S_DRIVER_OK);\n\n    KeMemoryBarrier();\n\n    pContext->bDeviceInitialized = FALSE;\n}\n\nstatic VOID ParaNdis_AddDriverOKStatus(PPARANDIS_ADAPTER pContext)\n{\n    pContext->bDeviceInitialized = TRUE;\n\n    KeMemoryBarrier();\n\n    VirtIODeviceAddStatus(pContext->IODevice, VIRTIO_CONFIG_S_DRIVER_OK);\n}\n\n/**********************************************************\nFinishes initialization of context structure, calling also version dependent part\nIf this procedure failed, ParaNdis_CleanupContext must be called\nParameters:\n    context\nReturn value:\n    SUCCESS or some kind of failure\n***********************************************************/\nNDIS_STATUS ParaNdis_FinishInitialization(PARANDIS_ADAPTER *pContext)\n{\n    NDIS_STATUS status = NDIS_STATUS_SUCCESS;\n    DEBUG_ENTRY(0);\n\n    status = ParaNdis_FinishSpecificInitialization(pContext);\n    DPrintf(0, (\"[%s] ParaNdis_FinishSpecificInitialization passed, status = %d\\n\", __FUNCTION__, status));\n\n\n    if (status == NDIS_STATUS_SUCCESS)\n    {\n        status = ParaNdis_VirtIONetInit(pContext);\n        DPrintf(0, (\"[%s] ParaNdis_VirtIONetInit passed, status = %d\\n\", __FUNCTION__, status));\n    }\n\n    if (status == NDIS_STATUS_SUCCESS)\n    {\n        status = ParaNdis_ConfigureMSIXVectors(pContext);\n        DPrintf(0, (\"[%s] ParaNdis_VirtIONetInit passed, status = %d\\n\", __FUNCTION__, status));\n    }\n\n    if (status == NDIS_STATUS_SUCCESS)\n    {\n        status = SetupDPCTarget(pContext);\n        DPrintf(0, (\"[%s] SetupDPCTarget passed, status = %d\\n\", __FUNCTION__, status));\n    }\n\n    if (status == NDIS_STATUS_SUCCESS && pContext->nPathBundles > 1)\n    {\n        u16 nPathes = u16(pContext->nPathBundles);\n        BOOLEAN sendSuccess = pContext->CXPath.SendControlMessage(VIRTIO_NET_CTRL_MQ, VIRTIO_NET_CTRL_MQ_VQ_PAIR_SET, &nPathes, sizeof(nPathes), NULL, 0, 2);\n        if (!sendSuccess)\n        {\n            DPrintf(0, (\"[%s] - Send MQ control message failed\\n\", __FUNCTION__));\n            status = NDIS_STATUS_DEVICE_FAILED;\n        }\n    }\n\n    pContext->Limits.nReusedRxBuffers = pContext->NetMaxReceiveBuffers / 4 + 1;\n\n    if (status == NDIS_STATUS_SUCCESS)\n    {\n        ReadLinkState(pContext);\n        pContext->bEnableInterruptHandlingDPC = TRUE;\n        ParaNdis_SetPowerState(pContext, NdisDeviceStateD0);\n        ParaNdis_SynchronizeLinkState(pContext);\n        ParaNdis_AddDriverOKStatus(pContext);\n        ParaNdis_UpdateMAC(pContext);\n    }\n    DEBUG_EXIT_STATUS(0, status);\n    return status;\n}\n\n/**********************************************************\nReleases VirtIO related resources - queues and buffers\nParameters:\n    context\nReturn value:\n***********************************************************/\nstatic void VirtIONetRelease(PARANDIS_ADAPTER *pContext)\n{\n    BOOLEAN b;\n    ULONG i;\n    DEBUG_ENTRY(0);\n\n    /* list NetReceiveBuffersWaiting must be free */\n\n    for (i = 0; i < ARRAYSIZE(pContext->ReceiveQueues); i++)\n    {\n        pRxNetDescriptor pBufferDescriptor;\n\n        while (NULL != (pBufferDescriptor = ReceiveQueueGetBuffer(pContext->ReceiveQueues + i)))\n        {\n            pBufferDescriptor->Queue->ReuseReceiveBuffer(FALSE, pBufferDescriptor);\n        }\n    }\n\n    do\n    {\n        b = pContext->m_upstreamPacketPending != 0;\n\n        if (b)\n        {\n            DPrintf(0, (\"[%s] There are waiting buffers\\n\", __FUNCTION__));\n            PrintStatistics(pContext);\n            NdisMSleep(5000000);\n        }\n    } while (b);\n\n    RestoreMAC(pContext);\n\n    for (i = 0; i < pContext->nPathBundles; i++)\n    {\n        if (pContext->pPathBundles[i].txCreated)\n        {\n            pContext->pPathBundles[i].txPath.Shutdown();\n        }\n\n        if (pContext->pPathBundles[i].rxCreated)\n        {\n            pContext->pPathBundles[i].rxPath.Shutdown();\n\n            /* this can be freed, queue shut down */\n            pContext->pPathBundles[i].rxPath.FreeRxDescriptorsFromList();\n        }\n    }\n\n    if (pContext->bCXPathCreated)\n    {\n        pContext->CXPath.Shutdown();\n    }\n\n    PrintStatistics(pContext);\n}\n\nstatic void PreventDPCServicing(PARANDIS_ADAPTER *pContext)\n{\n    LONG inside;\n    pContext->bEnableInterruptHandlingDPC = FALSE;\n    KeMemoryBarrier();\n    do\n    {\n        inside = InterlockedIncrement(&pContext->counterDPCInside);\n        InterlockedDecrement(&pContext->counterDPCInside);\n        if (inside > 1)\n        {\n            DPrintf(0, (\"[%s] waiting!\\n\", __FUNCTION__));\n            NdisMSleep(20000);\n        }\n    } while (inside > 1);\n}\n\n/**********************************************************\nFrees all the resources allocated when the context initialized,\n    calling also version-dependent part\nParameters:\n    context\n***********************************************************/\nVOID ParaNdis_CleanupContext(PARANDIS_ADAPTER *pContext)\n{\n    /* disable any interrupt generation */\n    if (pContext->IODevice->addr)\n    {\n        if (pContext->bDeviceInitialized)\n        {\n            ParaNdis_RemoveDriverOKStatus(pContext);\n        }\n    }\n\n    PreventDPCServicing(pContext);\n\n    /****************************************\n    ensure all the incoming packets returned,\n    free all the buffers and their descriptors\n    *****************************************/\n\n    if (pContext->IODevice->addr)\n    {\n        ParaNdis_ResetVirtIONetDevice(pContext);\n    }\n\n    ParaNdis_SetPowerState(pContext, NdisDeviceStateD3);\n    ParaNdis_SetLinkState(pContext, MediaConnectStateUnknown);\n    VirtIONetRelease(pContext);\n\n    ParaNdis_FinalizeCleanup(pContext);\n\n    if (pContext->ReceiveQueuesInitialized)\n    {\n        ULONG i;\n\n        for(i = 0; i < ARRAYSIZE(pContext->ReceiveQueues); i++)\n        {\n            NdisFreeSpinLock(&pContext->ReceiveQueues[i].Lock);\n        }\n    }\n\n    pContext->m_PauseLock.~CNdisRWLock();\n\n#if PARANDIS_SUPPORT_RSS\n    if (pContext->bRSSInitialized)\n    {\n        ParaNdis6_RSSCleanupConfiguration(&pContext->RSSParameters);\n    }\n\n    pContext->RSSParameters.rwLock.~CNdisRWLock();\n#endif\n\n    if (pContext->bCXPathAllocated)\n    {\n        pContext->CXPath.~CParaNdisCX();\n        pContext->bCXPathAllocated = false;\n    }\n\n    if (pContext->pPathBundles != NULL)\n    {\n        USHORT i;\n\n        for (i = 0; i < pContext->nPathBundles; i++)\n        {\n            pContext->pPathBundles[i].~CPUPathesBundle();\n        }\n        NdisFreeMemoryWithTagPriority(pContext->MiniportHandle, pContext->pPathBundles, PARANDIS_MEMORY_TAG);\n        pContext->pPathBundles = nullptr;\n    }\n\n    if (pContext->RSS2QueueMap)\n    {\n        NdisFreeMemoryWithTagPriority(pContext->MiniportHandle, pContext->RSS2QueueMap, PARANDIS_MEMORY_TAG);\n        pContext->RSS2QueueMap = nullptr;\n        pContext->RSS2QueueLength = 0;\n    }\n\n    if (pContext->IODevice)\n    {\n        NdisFreeMemoryWithTagPriority(pContext->MiniportHandle, pContext->IODevice, PARANDIS_MEMORY_TAG);\n        pContext->IODevice = nullptr;\n    }\n\n    if (pContext->AdapterResources.ulIOAddress)\n    {\n        NdisMDeregisterIoPortRange(\n            pContext->MiniportHandle,\n            pContext->AdapterResources.ulIOAddress,\n            pContext->AdapterResources.IOLength,\n            pContext->pIoPortOffset);\n        pContext->AdapterResources.ulIOAddress = 0;\n    }\n}\n\n\n/**********************************************************\nSystem shutdown handler (shutdown, restart, bugcheck)\nParameters:\n    context\n***********************************************************/\nVOID ParaNdis_OnShutdown(PARANDIS_ADAPTER *pContext)\n{\n    DEBUG_ENTRY(0); // this is only for kdbg :)\n    ParaNdis_ResetVirtIONetDevice(pContext);\n}\n\nstatic ULONG ShallPassPacket(PARANDIS_ADAPTER *pContext, PNET_PACKET_INFO pPacketInfo)\n{\n    ULONG i;\n\n    if (pPacketInfo->dataLength > pContext->MaxPacketSize.nMaxFullSizeOsRx + ETH_PRIORITY_HEADER_SIZE)\n        return FALSE;\n\n    if ((pPacketInfo->dataLength > pContext->MaxPacketSize.nMaxFullSizeOsRx) && !pPacketInfo->hasVlanHeader)\n        return FALSE;\n\n    if (IsVlanSupported(pContext) && pPacketInfo->hasVlanHeader)\n    {\n        if (pContext->VlanId && pContext->VlanId != pPacketInfo->Vlan.VlanId)\n        {\n            return FALSE;\n        }\n    }\n\n    if (pContext->PacketFilter & NDIS_PACKET_TYPE_PROMISCUOUS)\n        return TRUE;\n\n    if(pPacketInfo->isUnicast)\n    {\n        ULONG Res;\n\n        if(!(pContext->PacketFilter & NDIS_PACKET_TYPE_DIRECTED))\n            return FALSE;\n\n        ETH_COMPARE_NETWORK_ADDRESSES_EQ(pPacketInfo->ethDestAddr, pContext->CurrentMacAddress, &Res);\n        return !Res;\n    }\n\n    if(pPacketInfo->isBroadcast)\n        return (pContext->PacketFilter & NDIS_PACKET_TYPE_BROADCAST);\n\n    // Multi-cast\n\n    if(pContext->PacketFilter & NDIS_PACKET_TYPE_ALL_MULTICAST)\n        return TRUE;\n\n    if(!(pContext->PacketFilter & NDIS_PACKET_TYPE_MULTICAST))\n        return FALSE;\n\n    for (i = 0; i < pContext->MulticastData.nofMulticastEntries; i++)\n    {\n        ULONG Res;\n        PUCHAR CurrMcastAddr = &pContext->MulticastData.MulticastList[i*ETH_LENGTH_OF_ADDRESS];\n\n        ETH_COMPARE_NETWORK_ADDRESSES_EQ(pPacketInfo->ethDestAddr, CurrMcastAddr, &Res);\n\n        if(!Res)\n            return TRUE;\n    }\n\n    return FALSE;\n}\n\nBOOLEAN ParaNdis_PerformPacketAnalyzis(\n#if PARANDIS_SUPPORT_RSS\n                            PPARANDIS_RSS_PARAMS RSSParameters,\n#endif\n                            PNET_PACKET_INFO PacketInfo,\n                            PVOID HeadersBuffer,\n                            ULONG DataLength)\n{\n    if(!ParaNdis_AnalyzeReceivedPacket(HeadersBuffer, DataLength, PacketInfo))\n        return FALSE;\n\n#if PARANDIS_SUPPORT_RSS\n    if(RSSParameters->RSSMode != PARANDIS_RSS_DISABLED)\n    {\n        ParaNdis6_RSSAnalyzeReceivedPacket(RSSParameters, HeadersBuffer, PacketInfo);\n    }\n#endif\n    return TRUE;\n}\n\nVOID ParaNdis_ProcessorNumberToGroupAffinity(PGROUP_AFFINITY Affinity, const PPROCESSOR_NUMBER Processor)\n{\n    Affinity->Group = Processor->Group;\n    Affinity->Mask = 1;\n    Affinity->Mask <<= Processor->Number;\n}\n\n\nCCHAR ParaNdis_GetScalingDataForPacket(PARANDIS_ADAPTER *pContext, PNET_PACKET_INFO pPacketInfo, PPROCESSOR_NUMBER pTargetProcessor)\n{\n#if PARANDIS_SUPPORT_RSS\n    return ParaNdis6_RSSGetScalingDataForPacket(&pContext->RSSParameters, pPacketInfo, pTargetProcessor);\n#else\n    UNREFERENCED_PARAMETER(pContext);\n    UNREFERENCED_PARAMETER(pPacketInfo);\n    UNREFERENCED_PARAMETER(pTargetProcessor);\n\n    return PARANDIS_RECEIVE_QUEUE_UNCLASSIFIED;\n#endif\n}\n\nstatic __inline\nCCHAR GetReceiveQueueForCurrentCPU(PARANDIS_ADAPTER *pContext)\n{\n#if PARANDIS_SUPPORT_RSS\n    return ParaNdis6_RSSGetCurrentCpuReceiveQueue(&pContext->RSSParameters);\n#else\n    UNREFERENCED_PARAMETER(pContext);\n\n    return PARANDIS_RECEIVE_QUEUE_UNCLASSIFIED;\n#endif\n}\n\nVOID ParaNdis_QueueRSSDpc(PARANDIS_ADAPTER *pContext, ULONG MessageIndex, PGROUP_AFFINITY pTargetAffinity)\n{\n#if PARANDIS_SUPPORT_RSS\n    NdisMQueueDpcEx(pContext->InterruptHandle, MessageIndex, pTargetAffinity, NULL);\n#else\n    UNREFERENCED_PARAMETER(pContext);\n    UNREFERENCED_PARAMETER(MessageIndex);\n    UNREFERENCED_PARAMETER(pTargetAffinity);\n\n    ASSERT(FALSE);\n#endif\n}\n\n\nVOID ParaNdis_ReceiveQueueAddBuffer(PPARANDIS_RECEIVE_QUEUE pQueue, pRxNetDescriptor pBuffer)\n{\n    NdisInterlockedInsertTailList(  &pQueue->BuffersList,\n                                    &pBuffer->ReceiveQueueListEntry,\n                                    &pQueue->Lock);\n}\n\nVOID ParaMdis_TestPausing(PARANDIS_ADAPTER *pContext)\n{\n    ONPAUSECOMPLETEPROC callback = nullptr;\n\n    if (pContext->m_upstreamPacketPending == 0)\n    {\n        CNdisPassiveWriteAutoLock tLock(pContext->m_PauseLock);\n\n        if (pContext->m_upstreamPacketPending == 0 && (pContext->ReceiveState == srsPausing || pContext->ReceivePauseCompletionProc))\n        {\n            callback = pContext->ReceivePauseCompletionProc;\n            pContext->ReceiveState = srsDisabled;\n            pContext->ReceivePauseCompletionProc = NULL;\n            ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 0, 0, 0);\n        }\n    }\n\n    if (callback) callback(pContext);\n}\n\nstatic __inline\npRxNetDescriptor ReceiveQueueGetBuffer(PPARANDIS_RECEIVE_QUEUE pQueue)\n{\n    PLIST_ENTRY pListEntry = NdisInterlockedRemoveHeadList(&pQueue->BuffersList, &pQueue->Lock);\n    return pListEntry ? CONTAINING_RECORD(pListEntry, RxNetDescriptor, ReceiveQueueListEntry) : NULL;\n}\n\nstatic __inline\nBOOLEAN ReceiveQueueHasBuffers(PPARANDIS_RECEIVE_QUEUE pQueue)\n{\n    BOOLEAN res;\n\n    NdisAcquireSpinLock(&pQueue->Lock);\n    res = !IsListEmpty(&pQueue->BuffersList);\n    NdisReleaseSpinLock(&pQueue->Lock);\n\n    return res;\n}\n\nstatic VOID\nUpdateReceiveSuccessStatistics(PPARANDIS_ADAPTER pContext,\n                               PNET_PACKET_INFO pPacketInfo,\n                               UINT nCoalescedSegmentsCount)\n{\n    pContext->Statistics.ifHCInOctets += pPacketInfo->dataLength;\n\n    if(pPacketInfo->isUnicast)\n    {\n        pContext->Statistics.ifHCInUcastPkts += nCoalescedSegmentsCount;\n        pContext->Statistics.ifHCInUcastOctets += pPacketInfo->dataLength;\n    }\n    else if (pPacketInfo->isBroadcast)\n    {\n        pContext->Statistics.ifHCInBroadcastPkts += nCoalescedSegmentsCount;\n        pContext->Statistics.ifHCInBroadcastOctets += pPacketInfo->dataLength;\n    }\n    else if (pPacketInfo->isMulticast)\n    {\n        pContext->Statistics.ifHCInMulticastPkts += nCoalescedSegmentsCount;\n        pContext->Statistics.ifHCInMulticastOctets += pPacketInfo->dataLength;\n    }\n    else\n    {\n        ASSERT(FALSE);\n    }\n}\n\nstatic __inline VOID\nUpdateReceiveFailStatistics(PPARANDIS_ADAPTER pContext, UINT nCoalescedSegmentsCount)\n{\n    pContext->Statistics.ifInErrors++;\n    pContext->Statistics.ifInDiscards += nCoalescedSegmentsCount;\n}\n\nstatic BOOLEAN ProcessReceiveQueue(PARANDIS_ADAPTER *pContext,\n                                    PULONG pnPacketsToIndicateLeft,\n                                    CCHAR nQueueIndex,\n                                    PNET_BUFFER_LIST *indicate,\n                                    PNET_BUFFER_LIST *indicateTail,\n                                    ULONG *nIndicate)\n{\n    \n    pRxNetDescriptor pBufferDescriptor;\n    PPARANDIS_RECEIVE_QUEUE pTargetReceiveQueue = &pContext->ReceiveQueues[nQueueIndex];\n\n    if(NdisInterlockedIncrement(&pTargetReceiveQueue->ActiveProcessorsCount) == 1)\n    {\n        while( (*pnPacketsToIndicateLeft > 0) &&\n               (NULL != (pBufferDescriptor = ReceiveQueueGetBuffer(pTargetReceiveQueue))) )\n        {\n            PNET_PACKET_INFO pPacketInfo = &pBufferDescriptor->PacketInfo;\n\n            if( !pContext->bSurprizeRemoved &&\n                pContext->ReceiveState == srsEnabled &&\n                pContext->bConnected &&\n                ShallPassPacket(pContext, pPacketInfo))\n            {\n                UINT nCoalescedSegmentsCount;\n                PNET_BUFFER_LIST packet = ParaNdis_PrepareReceivedPacket(pContext, pBufferDescriptor, &nCoalescedSegmentsCount);\n                if(packet != NULL)\n                {\n                    UpdateReceiveSuccessStatistics(pContext, pPacketInfo, nCoalescedSegmentsCount);\n                    if (*indicate == nullptr)\n                    {\n                        *indicate = *indicateTail = packet;\n                    }\n                    else\n                    {\n                        NET_BUFFER_LIST_NEXT_NBL(*indicateTail) = packet;\n                        *indicateTail = packet;\n                    }\n\n                    NET_BUFFER_LIST_NEXT_NBL(*indicateTail) = NULL;\n                    (*pnPacketsToIndicateLeft)--;\n                    (*nIndicate)++;\n                }\n                else\n                {\n                    UpdateReceiveFailStatistics(pContext, nCoalescedSegmentsCount);\n                    pBufferDescriptor->Queue->ReuseReceiveBuffer(pContext->ReuseBufferRegular, pBufferDescriptor);\n                }\n            }\n            else\n            {\n                pContext->extraStatistics.framesFilteredOut++;\n                pBufferDescriptor->Queue->ReuseReceiveBuffer(pContext->ReuseBufferRegular, pBufferDescriptor);\n            }\n        }\n     }\n\n    NdisInterlockedDecrement(&pTargetReceiveQueue->ActiveProcessorsCount);\n    return ReceiveQueueHasBuffers(pTargetReceiveQueue);\n}\n\nstatic\nBOOLEAN RxDPCWorkBody(PARANDIS_ADAPTER *pContext, CPUPathesBundle *pathBundle, ULONG nPacketsToIndicate)\n{\n    BOOLEAN res = FALSE;\n    BOOLEAN bMoreDataInRing;\n\n    PNET_BUFFER_LIST indicate, indicateTail;\n    ULONG nIndicate;\n\n    CCHAR CurrCpuReceiveQueue = GetReceiveQueueForCurrentCPU(pContext);\n\n    do\n    {\n        indicate = nullptr;\n        indicateTail = nullptr;\n        nIndicate = 0;\n\n        {\n            CNdisDispatchReadAutoLock tLock(pContext->m_PauseLock);\n\n            pathBundle->rxPath.ProcessRxRing(CurrCpuReceiveQueue);\n\n            res |= ProcessReceiveQueue(pContext, &nPacketsToIndicate, PARANDIS_RECEIVE_QUEUE_UNCLASSIFIED,\n                &indicate, &indicateTail, &nIndicate);\n\n            if(CurrCpuReceiveQueue != PARANDIS_RECEIVE_QUEUE_UNCLASSIFIED)\n            {\n                res |= ProcessReceiveQueue(pContext, &nPacketsToIndicate, CurrCpuReceiveQueue,\n                    &indicate, &indicateTail, &nIndicate);\n            }\n\n            bMoreDataInRing = pathBundle->rxPath.RestartQueue();\n        }\n\n        if (nIndicate)\n        {\n            NdisMIndicateReceiveNetBufferLists(pContext->MiniportHandle,\n                indicate,\n                0,\n                nIndicate,\n                0);\n        }\n\n        ParaMdis_TestPausing(pContext);\n\n    } while (bMoreDataInRing);\n\n    return res;\n}\n\nbool ParaNdis_DPCWorkBody(PARANDIS_ADAPTER *pContext, ULONG ulMaxPacketsToIndicate)\n{\n    bool stillRequiresProcessing = false;\n    UINT numOfPacketsToIndicate = min(ulMaxPacketsToIndicate, pContext->uNumberOfHandledRXPacketsInDPC);\n\n    DEBUG_ENTRY(5);\n\n    InterlockedIncrement(&pContext->counterDPCInside);\n\n    CPUPathesBundle *pathBundle = nullptr;\n\n    if (pContext->nPathBundles == 1)\n    {\n        pathBundle = pContext->pPathBundles;\n    }\n    else\n    {\n        ULONG procNumber = KeGetCurrentProcessorNumber();\n        if (procNumber < pContext->nPathBundles)\n        {\n            pathBundle = pContext->pPathBundles + procNumber;\n        }\n    }\n\n    if (pathBundle == nullptr)\n    {\n        return false;\n    }\n\n    if (pContext->bEnableInterruptHandlingDPC)\n    {\n        bool bDoKick = false;\n\n        InterlockedExchange(&pContext->bDPCInactive, 0);\n\n        if (RxDPCWorkBody(pContext, pathBundle, numOfPacketsToIndicate))\n        {\n            stillRequiresProcessing = true;\n        }\n\n        if (pContext->CXPath.WasInterruptReported() && pContext->bLinkDetectSupported)\n        {\n            ReadLinkState(pContext);\n            ParaNdis_SynchronizeLinkState(pContext);\n            pContext->CXPath.ClearInterruptReport();\n        }\n\n        if (!stillRequiresProcessing)\n        {\n            bDoKick = pathBundle->txPath.DoPendingTasks(true);\n            if (pathBundle->txPath.RestartQueue(bDoKick))\n            {\n                stillRequiresProcessing = true;\n            }\n        }\n    }\n    InterlockedDecrement(&pContext->counterDPCInside);\n\n    return stillRequiresProcessing;\n}\n\nVOID ParaNdis_ResetRxClassification(PARANDIS_ADAPTER *pContext)\n{\n    ULONG i;\n    PPARANDIS_RECEIVE_QUEUE pUnclassified = &pContext->ReceiveQueues[PARANDIS_RECEIVE_QUEUE_UNCLASSIFIED];\n\n    NdisAcquireSpinLock(&pUnclassified->Lock);\n\n    for(i = PARANDIS_RECEIVE_QUEUE_UNCLASSIFIED + 1; i < ARRAYSIZE(pContext->ReceiveQueues); i++)\n    {\n        PPARANDIS_RECEIVE_QUEUE pCurrQueue = &pContext->ReceiveQueues[i];\n        NdisAcquireSpinLock(&pCurrQueue->Lock);\n\n        while(!IsListEmpty(&pCurrQueue->BuffersList))\n        {\n            PLIST_ENTRY pListEntry = RemoveHeadList(&pCurrQueue->BuffersList);\n            InsertTailList(&pUnclassified->BuffersList, pListEntry);\n        }\n\n        NdisReleaseSpinLock(&pCurrQueue->Lock);\n    }\n\n    NdisReleaseSpinLock(&pUnclassified->Lock);\n}\n\n/**********************************************************\nPeriodically called procedure, checking dpc activity\nIf DPC are not running, it does exactly the same that the DPC\nParameters:\n    context\n***********************************************************/\nstatic BOOLEAN CheckRunningDpc(PARANDIS_ADAPTER *pContext)\n{\n    BOOLEAN bStopped;\n    BOOLEAN bReportHang = FALSE;\n    bStopped = 0 != InterlockedExchange(&pContext->bDPCInactive, TRUE);\n\n    if (bStopped)\n    {\n        pContext->nDetectedInactivity++;\n    }\n    else\n    {\n        pContext->nDetectedInactivity = 0;\n    }\n\n    for (UINT i = 0; i < pContext->nPathBundles; i++)\n    {\n        if (pContext->pPathBundles[i].txPath.HasHWBuffersIsUse())\n        {\n            if (pContext->nDetectedStoppedTx++ > 1)\n            {\n                DPrintf(0, (\"[%s] - Suspicious Tx inactivity (%d)!\\n\", __FUNCTION__, pContext->pPathBundles[i].txPath.GetFreeHWBuffers()));\n                //bReportHang = TRUE;\n#ifdef DBG_USE_VIRTIO_PCI_ISR_FOR_HOST_REPORT\n                WriteVirtIODeviceByte(pContext->IODevice->addr + VIRTIO_PCI_ISR, 0);\n#endif\n                break;\n            }\n        }\n    }\n\n    if (pContext->Limits.nPrintDiagnostic &&\n        ++pContext->Counters.nPrintDiagnostic >= pContext->Limits.nPrintDiagnostic)\n    {\n        pContext->Counters.nPrintDiagnostic = 0;\n        // todo - collect more and put out optionally\n        PrintStatistics(pContext);\n    }\n\n    if (pContext->Statistics.ifHCInOctets == pContext->Counters.prevIn)\n    {\n        pContext->Counters.nRxInactivity++;\n        if (pContext->Counters.nRxInactivity >= 10)\n        {\n#if defined(CRASH_ON_NO_RX)\n            ONPAUSECOMPLETEPROC proc = (ONPAUSECOMPLETEPROC)(PVOID)1;\n            proc(pContext);\n#endif\n        }\n    }\n    else\n    {\n        pContext->Counters.nRxInactivity = 0;\n        pContext->Counters.prevIn = pContext->Statistics.ifHCInOctets;\n    }\n    return bReportHang;\n}\n\n/**********************************************************\nCommon implementation of periodic poll\nParameters:\n    context\nReturn:\n    TRUE, if reset required\n***********************************************************/\nBOOLEAN ParaNdis_CheckForHang(PARANDIS_ADAPTER *pContext)\n{\n    static int nHangOn = 0;\n    BOOLEAN b = nHangOn >= 3 && nHangOn < 6;\n    DEBUG_ENTRY(3);\n    b |= CheckRunningDpc(pContext);\n    //uncomment to cause 3 consecutive resets\n    //nHangOn++;\n    DEBUG_EXIT_STATUS(b ? 0 : 6, b);\n    return b;\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////\n//\n// ReadVirtIODeviceRegister\\WriteVirtIODeviceRegister\n// NDIS specific implementation of the IO space read\\write\n//\n/////////////////////////////////////////////////////////////////////////////////////\nu32 ReadVirtIODeviceRegister(ULONG_PTR ulRegister)\n{\n    ULONG ulValue;\n\n    NdisRawReadPortUlong(ulRegister, &ulValue);\n\n    DPrintf(6, (\"[%s]R[%x]=%x\\n\", __FUNCTION__, (ULONG)ulRegister, ulValue) );\n    return ulValue;\n}\n\nvoid WriteVirtIODeviceRegister(ULONG_PTR ulRegister, u32 ulValue)\n{\n    DPrintf(6, (\"[%s]R[%x]=%x\\n\", __FUNCTION__, (ULONG)ulRegister, ulValue) );\n\n    NdisRawWritePortUlong(ulRegister, ulValue);\n}\n\nu8 ReadVirtIODeviceByte(ULONG_PTR ulRegister)\n{\n    u8 bValue;\n\n    NdisRawReadPortUchar(ulRegister, &bValue);\n\n    DPrintf(6, (\"[%s]R[%x]=%x\\n\", __FUNCTION__, (ULONG)ulRegister, bValue) );\n\n    return bValue;\n}\n\nvoid WriteVirtIODeviceByte(ULONG_PTR ulRegister, u8 bValue)\n{\n    DPrintf(6, (\"[%s]R[%x]=%x\\n\", __FUNCTION__, (ULONG)ulRegister, bValue) );\n\n    NdisRawWritePortUchar(ulRegister, bValue);\n}\n\nu16 ReadVirtIODeviceWord(ULONG_PTR ulRegister)\n{\n    u16 wValue;\n\n    NdisRawReadPortUshort(ulRegister, &wValue);\n\n    DPrintf(6, (\"[%s]R[%x]=%x\\n\", __FUNCTION__, (ULONG)ulRegister, wValue) );\n\n    return wValue;\n}\n\nvoid WriteVirtIODeviceWord(ULONG_PTR ulRegister, u16 wValue)\n{\n#if 1\n    NdisRawWritePortUshort(ulRegister, wValue);\n#else\n    // test only to cause long TX waiting queue of NDIS packets\n    // to recognize it and request for reset via Hang handler\n    static int nCounterToFail = 0;\n    static const int StartFail = 200, StopFail = 600;\n    BOOLEAN bFail = FALSE;\n    DPrintf(6, (\"%s> R[%x] = %x\\n\", __FUNCTION__, (ULONG)ulRegister, wValue) );\n    if ((ulRegister & 0x1F) == 0x10)\n    {\n        nCounterToFail++;\n        bFail = nCounterToFail >= StartFail && nCounterToFail < StopFail;\n    }\n    if (!bFail) NdisRawWritePortUshort(ulRegister, wValue);\n    else\n    {\n        DPrintf(0, (\"%s> FAILING R[%x] = %x\\n\", __FUNCTION__, (ULONG)ulRegister, wValue) );\n    }\n#endif\n}\n\n/**********************************************************\nCommon handler of multicast address configuration\nParameters:\n    PVOID Buffer            array of addresses from NDIS\n    ULONG BufferSize        size of incoming buffer\n    PUINT pBytesRead        update on success\n    PUINT pBytesNeeded      update on wrong buffer size\nReturn value:\n    SUCCESS or kind of failure\n***********************************************************/\nNDIS_STATUS ParaNdis_SetMulticastList(\n    PARANDIS_ADAPTER *pContext,\n    PVOID Buffer,\n    ULONG BufferSize,\n    PUINT pBytesRead,\n    PUINT pBytesNeeded)\n{\n    NDIS_STATUS status;\n    ULONG length = BufferSize;\n    if (length > sizeof(pContext->MulticastData.MulticastList))\n    {\n        status = NDIS_STATUS_MULTICAST_FULL;\n        *pBytesNeeded = sizeof(pContext->MulticastData.MulticastList);\n    }\n    else if (length % ETH_LENGTH_OF_ADDRESS)\n    {\n        status = NDIS_STATUS_INVALID_LENGTH;\n        *pBytesNeeded = (length / ETH_LENGTH_OF_ADDRESS) * ETH_LENGTH_OF_ADDRESS;\n    }\n    else\n    {\n        NdisZeroMemory(pContext->MulticastData.MulticastList, sizeof(pContext->MulticastData.MulticastList));\n        if (length)\n            NdisMoveMemory(pContext->MulticastData.MulticastList, Buffer, length);\n        pContext->MulticastData.nofMulticastEntries = length / ETH_LENGTH_OF_ADDRESS;\n        DPrintf(1, (\"[%s] New multicast list of %d bytes\\n\", __FUNCTION__, length));\n        *pBytesRead = length;\n        status = NDIS_STATUS_SUCCESS;\n    }\n    return status;\n}\n\n/**********************************************************\nCommon handler of PnP events\nParameters:\nReturn value:\n***********************************************************/\nVOID ParaNdis_OnPnPEvent(\n    PARANDIS_ADAPTER *pContext,\n    NDIS_DEVICE_PNP_EVENT pEvent,\n    PVOID   pInfo,\n    ULONG   ulSize)\n{\n    const char *pName = \"\";\n\n    UNREFERENCED_PARAMETER(pInfo);\n    UNREFERENCED_PARAMETER(ulSize);\n\n    DEBUG_ENTRY(0);\n#undef MAKECASE\n#define MAKECASE(x) case (x): pName = #x; break;\n    switch (pEvent)\n    {\n        MAKECASE(NdisDevicePnPEventQueryRemoved)\n        MAKECASE(NdisDevicePnPEventRemoved)\n        MAKECASE(NdisDevicePnPEventSurpriseRemoved)\n        MAKECASE(NdisDevicePnPEventQueryStopped)\n        MAKECASE(NdisDevicePnPEventStopped)\n        MAKECASE(NdisDevicePnPEventPowerProfileChanged)\n        MAKECASE(NdisDevicePnPEventFilterListChanged)\n        default:\n            break;\n    }\n    ParaNdis_DebugHistory(pContext, hopPnpEvent, NULL, pEvent, 0, 0);\n    DPrintf(0, (\"[%s] (%s)\\n\", __FUNCTION__, pName));\n    if (pEvent == NdisDevicePnPEventSurpriseRemoved)\n    {\n        // on simulated surprise removal (under PnpTest) we need to reset the device\n        // to prevent any access of device queues to memory buffers\n        pContext->bSurprizeRemoved = TRUE;\n        ParaNdis_ResetVirtIONetDevice(pContext);\n        {\n            UINT i;\n\n            for (i = 0; i < pContext->nPathBundles; i++)\n            {\n                pContext->pPathBundles[i].txPath.Pause();\n            }\n        }\n    }\n    pContext->PnpEvents[pContext->nPnpEventIndex++] = pEvent;\n    if (pContext->nPnpEventIndex > sizeof(pContext->PnpEvents)/sizeof(pContext->PnpEvents[0]))\n        pContext->nPnpEventIndex = 0;\n}\n\nstatic VOID ParaNdis_DeviceFiltersUpdateRxMode(PARANDIS_ADAPTER *pContext)\n{\n    u8 val;\n    ULONG f = pContext->PacketFilter;\n    val = (f & NDIS_PACKET_TYPE_ALL_MULTICAST) ? 1 : 0;\n    pContext->CXPath.SendControlMessage(VIRTIO_NET_CTRL_RX_MODE, VIRTIO_NET_CTRL_RX_MODE_ALLMULTI, &val, sizeof(val), NULL, 0, 2);\n    //SendControlMessage(pContext, VIRTIO_NET_CTRL_RX_MODE, VIRTIO_NET_CTRL_RX_MODE_ALLUNI, &val, sizeof(val), NULL, 0, 2);\n    val = (f & (NDIS_PACKET_TYPE_MULTICAST | NDIS_PACKET_TYPE_ALL_MULTICAST)) ? 0 : 1;\n    pContext->CXPath.SendControlMessage(VIRTIO_NET_CTRL_RX_MODE, VIRTIO_NET_CTRL_RX_MODE_NOMULTI, &val, sizeof(val), NULL, 0, 2);\n    val = (f & NDIS_PACKET_TYPE_DIRECTED) ? 0 : 1;\n    pContext->CXPath.SendControlMessage(VIRTIO_NET_CTRL_RX_MODE, VIRTIO_NET_CTRL_RX_MODE_NOUNI, &val, sizeof(val), NULL, 0, 2);\n    val = (f & NDIS_PACKET_TYPE_BROADCAST) ? 0 : 1;\n    pContext->CXPath.SendControlMessage(VIRTIO_NET_CTRL_RX_MODE, VIRTIO_NET_CTRL_RX_MODE_NOBCAST, &val, sizeof(val), NULL, 0, 2);\n    val = (f & NDIS_PACKET_TYPE_PROMISCUOUS) ? 1 : 0;\n    pContext->CXPath.SendControlMessage(VIRTIO_NET_CTRL_RX_MODE, VIRTIO_NET_CTRL_RX_MODE_PROMISC, &val, sizeof(val), NULL, 0, 2);\n}\n\nstatic VOID ParaNdis_DeviceFiltersUpdateAddresses(PARANDIS_ADAPTER *pContext)\n{\n    u32 u32UniCastEntries = 0;\n    pContext->CXPath.SendControlMessage(VIRTIO_NET_CTRL_MAC, VIRTIO_NET_CTRL_MAC_TABLE_SET,\n                        &u32UniCastEntries,\n                        sizeof(u32UniCastEntries),\n                        &pContext->MulticastData,\n                        sizeof(pContext->MulticastData.nofMulticastEntries) + pContext->MulticastData.nofMulticastEntries * ETH_LENGTH_OF_ADDRESS,\n                        2);\n}\n\nstatic VOID SetSingleVlanFilter(PARANDIS_ADAPTER *pContext, ULONG vlanId, BOOLEAN bOn, int levelIfOK)\n{\n    u16 val = vlanId & 0xfff;\n    UCHAR cmd = bOn ? VIRTIO_NET_CTRL_VLAN_ADD : VIRTIO_NET_CTRL_VLAN_DEL;\n    pContext->CXPath.SendControlMessage(VIRTIO_NET_CTRL_VLAN, cmd, &val, sizeof(val), NULL, 0, levelIfOK);\n}\n\nstatic VOID SetAllVlanFilters(PARANDIS_ADAPTER *pContext, BOOLEAN bOn)\n{\n    ULONG i;\n    for (i = 0; i <= MAX_VLAN_ID; ++i)\n        SetSingleVlanFilter(pContext, i, bOn, 7);\n}\n\n/*\n    possible values of filter set (pContext->ulCurrentVlansFilterSet):\n    0 - all disabled\n    1..4095 - one selected enabled\n    4096 - all enabled\n    Note that only 0th vlan can't be enabled\n*/\nVOID ParaNdis_DeviceFiltersUpdateVlanId(PARANDIS_ADAPTER *pContext)\n{\n    if (pContext->bHasHardwareFilters)\n    {\n        ULONG newFilterSet;\n        if (IsVlanSupported(pContext))\n            newFilterSet = pContext->VlanId ? pContext->VlanId : (MAX_VLAN_ID + 1);\n        else\n            newFilterSet = IsPrioritySupported(pContext) ? (MAX_VLAN_ID + 1) : 0;\n        if (newFilterSet != pContext->ulCurrentVlansFilterSet)\n        {\n            if (pContext->ulCurrentVlansFilterSet > MAX_VLAN_ID)\n                SetAllVlanFilters(pContext, FALSE);\n            else if (pContext->ulCurrentVlansFilterSet)\n                SetSingleVlanFilter(pContext, pContext->ulCurrentVlansFilterSet, FALSE, 2);\n\n            pContext->ulCurrentVlansFilterSet = newFilterSet;\n\n            if (pContext->ulCurrentVlansFilterSet > MAX_VLAN_ID)\n                SetAllVlanFilters(pContext, TRUE);\n            else if (pContext->ulCurrentVlansFilterSet)\n                SetSingleVlanFilter(pContext, pContext->ulCurrentVlansFilterSet, TRUE, 2);\n        }\n    }\n}\n\nVOID ParaNdis_UpdateDeviceFilters(PARANDIS_ADAPTER *pContext)\n{\n    if (pContext->bHasHardwareFilters)\n    {\n        ParaNdis_DeviceFiltersUpdateRxMode(pContext);\n        ParaNdis_DeviceFiltersUpdateAddresses(pContext);\n        ParaNdis_DeviceFiltersUpdateVlanId(pContext);\n    }\n}\n\nstatic VOID\nParaNdis_UpdateMAC(PARANDIS_ADAPTER *pContext)\n{\n    if (pContext->bCtrlMACAddrSupported)\n    {\n        pContext->CXPath.SendControlMessage(VIRTIO_NET_CTRL_MAC, VIRTIO_NET_CTRL_MAC_ADDR_SET,\n                           pContext->CurrentMacAddress,\n                           ETH_LENGTH_OF_ADDRESS,\n                           NULL, 0, 4);\n    }\n}\n\n#if PARANDIS_SUPPORT_RSC\nVOID\nParaNdis_UpdateGuestOffloads(PARANDIS_ADAPTER *pContext, UINT64 Offloads)\n{\n    if (pContext->RSC.bHasDynamicConfig)\n    {\n        pContext->CXPath.SendControlMessage(VIRTIO_NET_CTRL_GUEST_OFFLOADS, VIRTIO_NET_CTRL_GUEST_OFFLOADS_SET,\n                           &Offloads,\n                           sizeof(Offloads),\n                           NULL, 0, 2);\n    }\n}\n#endif\n\nVOID ParaNdis_PowerOn(PARANDIS_ADAPTER *pContext)\n{\n    UINT i;\n\n    DEBUG_ENTRY(0);\n    ParaNdis_DebugHistory(pContext, hopPowerOn, NULL, 1, 0, 0);\n    ParaNdis_ResetVirtIONetDevice(pContext);\n    VirtIODeviceAddStatus(pContext->IODevice, VIRTIO_CONFIG_S_ACKNOWLEDGE | VIRTIO_CONFIG_S_DRIVER);\n    /* GetHostFeature must be called with any mask once upon device initialization:\n     otherwise the device will not work properly */\n    VirtIODeviceReadHostFeatures(pContext->IODevice);\n    VirtIODeviceWriteGuestFeatures(pContext->IODevice, pContext->u32GuestFeatures);\n\n    for (i = 0; i < pContext->nPathBundles; i++)\n    {\n        pContext->pPathBundles[i].txPath.Renew();\n        pContext->pPathBundles[i].rxPath.Renew();\n    }\n    if (pContext->bCXPathCreated)\n    {\n        pContext->CXPath.Renew();\n    }\n\n    ParaNdis_RestoreDeviceConfigurationAfterReset(pContext);\n\n    ParaNdis_UpdateDeviceFilters(pContext);\n    ParaNdis_UpdateMAC(pContext);\n\n    InterlockedExchange(&pContext->ReuseBufferRegular, TRUE);\n    \n    for (i = 0; i < pContext->nPathBundles; i++)\n    {\n        pContext->pPathBundles[i].rxPath.PopulateQueue();\n    }\n\n    ReadLinkState(pContext);\n    ParaNdis_SetPowerState(pContext, NdisDeviceStateD0);\n    ParaNdis_SynchronizeLinkState(pContext);\n    pContext->bEnableInterruptHandlingDPC = TRUE;\n    ParaNdis_AddDriverOKStatus(pContext);\n\n    // if bFastSuspendInProcess is set by Win8 power-off procedure,\n    // the ParaNdis_Resume enables Tx and RX\n    // otherwise it does not do anything in Vista+ (Tx and RX are enabled after power-on by Restart)\n    ParaNdis_Resume(pContext);\n    pContext->bFastSuspendInProcess = FALSE;\n\n    ParaNdis_DebugHistory(pContext, hopPowerOn, NULL, 0, 0, 0);\n}\n\nVOID ParaNdis_PowerOff(PARANDIS_ADAPTER *pContext)\n{\n    DEBUG_ENTRY(0);\n    ParaNdis_DebugHistory(pContext, hopPowerOff, NULL, 1, 0, 0);\n\n    pContext->bConnected = FALSE;\n\n    // if bFastSuspendInProcess is set by Win8 power-off procedure\n    // the ParaNdis_Suspend does fast Rx stop without waiting (=>srsPausing, if there are some RX packets in Ndis)\n    pContext->bFastSuspendInProcess = pContext->bNoPauseOnSuspend && pContext->ReceiveState == srsEnabled;\n    ParaNdis_Suspend(pContext);\n\n    ParaNdis_RemoveDriverOKStatus(pContext);\n    \n    if (pContext->bFastSuspendInProcess)\n    {\n        InterlockedExchange(&pContext->ReuseBufferRegular, FALSE);\n    }\n    \n#if !NDIS_SUPPORT_NDIS620\n    // WLK tests for Windows 2008 require media disconnect indication\n    // on power off. HCK tests for newer versions require media state unknown\n    // indication only and fail on disconnect indication\n    ParaNdis_SetLinkState(pContext, MediaConnectStateDisconnected);\n#endif\n    ParaNdis_SetPowerState(pContext, NdisDeviceStateD3);\n    ParaNdis_SetLinkState(pContext, MediaConnectStateUnknown);\n\n    PreventDPCServicing(pContext);\n\n    /*******************************************************************\n        shutdown queues to have all the receive buffers under our control\n        all the transmit buffers move to list of free buffers\n    ********************************************************************/\n\n    for (UINT i = 0; i < pContext->nPathBundles; i++)\n    {\n        pContext->pPathBundles[i].txPath.Shutdown();\n        pContext->pPathBundles[i].rxPath.Shutdown();\n    }\n\n    if (pContext->bCXPathCreated)\n    {\n        pContext->CXPath.Shutdown();\n    }\n\n    ParaNdis_ResetVirtIONetDevice(pContext);\n    ParaNdis_DebugHistory(pContext, hopPowerOff, NULL, 0, 0, 0);\n}\n\nvoid ParaNdis_CallOnBugCheck(PARANDIS_ADAPTER *pContext)\n{\n    if (pContext->AdapterResources.ulIOAddress)\n    {\n#ifdef DBG_USE_VIRTIO_PCI_ISR_FOR_HOST_REPORT\n        WriteVirtIODeviceByte(pContext->IODevice->addr + VIRTIO_PCI_ISR, 1);\n#endif\n    }\n}\n\ntChecksumCheckResult ParaNdis_CheckRxChecksum(\n                                            PARANDIS_ADAPTER *pContext,\n                                            ULONG virtioFlags,\n                                            tCompletePhysicalAddress *pPacketPages,\n                                            ULONG ulPacketLength,\n                                            ULONG ulDataOffset,\n                                            BOOLEAN verifyLength)\n{\n    tOffloadSettingsFlags f = pContext->Offload.flags;\n    tChecksumCheckResult res;\n    tTcpIpPacketParsingResult ppr;\n    ULONG flagsToCalculate = 0;\n    res.value = 0;\n\n    //VIRTIO_NET_HDR_F_NEEDS_CSUM - we need to calculate TCP/UDP CS\n    //VIRTIO_NET_HDR_F_DATA_VALID - host tells us TCP/UDP CS is OK\n\n    if (f.fRxIPChecksum) flagsToCalculate |= pcrIpChecksum; // check only\n\n    if (!(virtioFlags & VIRTIO_NET_HDR_F_DATA_VALID))\n    {\n        if (virtioFlags & VIRTIO_NET_HDR_F_NEEDS_CSUM)\n        {\n            flagsToCalculate |= pcrFixXxpChecksum | pcrTcpChecksum | pcrUdpChecksum;\n        }\n        else\n        {\n            if (f.fRxTCPChecksum) flagsToCalculate |= pcrTcpV4Checksum;\n            if (f.fRxUDPChecksum) flagsToCalculate |= pcrUdpV4Checksum;\n            if (f.fRxTCPv6Checksum) flagsToCalculate |= pcrTcpV6Checksum;\n            if (f.fRxUDPv6Checksum) flagsToCalculate |= pcrUdpV6Checksum;\n        }\n    }\n\n    ppr = ParaNdis_CheckSumVerify(pPacketPages, ulPacketLength - ETH_HEADER_SIZE, ulDataOffset + ETH_HEADER_SIZE, flagsToCalculate,\n        verifyLength, __FUNCTION__);\n\n    if (ppr.ipCheckSum == ppresIPTooShort || ppr.xxpStatus == ppresXxpIncomplete)\n    {\n        res.flags.IpOK = FALSE;\n        res.flags.IpFailed = TRUE;\n        return res;\n    }\n\n    if (virtioFlags & VIRTIO_NET_HDR_F_DATA_VALID)\n    {\n        pContext->extraStatistics.framesRxCSHwOK++;\n        ppr.xxpCheckSum = ppresCSOK;\n    }\n\n    if (ppr.ipStatus == ppresIPV4 && !ppr.IsFragment)\n    {\n        if (f.fRxIPChecksum)\n        {\n            res.flags.IpOK =  ppr.ipCheckSum == ppresCSOK;\n            res.flags.IpFailed = ppr.ipCheckSum == ppresCSBad;\n        }\n        if(ppr.xxpStatus == ppresXxpKnown)\n        {\n            if(ppr.TcpUdp == ppresIsTCP) /* TCP */\n            {\n                if (f.fRxTCPChecksum)\n                {\n                    res.flags.TcpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;\n                    res.flags.TcpFailed = !res.flags.TcpOK;\n                }\n            }\n            else /* UDP */\n            {\n                if (f.fRxUDPChecksum)\n                {\n                    res.flags.UdpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;\n                    res.flags.UdpFailed = !res.flags.UdpOK;\n                }\n            }\n        }\n    }\n    else if (ppr.ipStatus == ppresIPV6)\n    {\n        if(ppr.xxpStatus == ppresXxpKnown)\n        {\n            if(ppr.TcpUdp == ppresIsTCP) /* TCP */\n            {\n                if (f.fRxTCPv6Checksum)\n                {\n                    res.flags.TcpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;\n                    res.flags.TcpFailed = !res.flags.TcpOK;\n                }\n            }\n            else /* UDP */\n            {\n                if (f.fRxUDPv6Checksum)\n                {\n                    res.flags.UdpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;\n                    res.flags.UdpFailed = !res.flags.UdpOK;\n                }\n            }\n        }\n    }\n\n    return res;\n}\n", "#include \"ndis56common.h\"\n\nCNBL::CNBL(PNET_BUFFER_LIST NBL, PPARANDIS_ADAPTER Context, CParaNdisTX &ParentTXPath)\n    : m_NBL(NBL)\n    , m_Context(Context)\n    , m_ParentTXPath(&ParentTXPath)\n{\n    m_NBL->Scratch = this;\n    m_LsoInfo.Value = NET_BUFFER_LIST_INFO(m_NBL, TcpLargeSendNetBufferListInfo);\n    m_CsoInfo.Value = NET_BUFFER_LIST_INFO(m_NBL, TcpIpChecksumNetBufferListInfo);\n}\n\nCNBL::~CNBL()\n{\n    CDpcIrqlRaiser OnDpc;\n\n    m_MappedBuffers.ForEachDetached([this](CNB *NB)\n                                    { CNB::Destroy(NB, m_Context->MiniportHandle); });\n\n    m_Buffers.ForEachDetached([this](CNB *NB)\n                              { CNB::Destroy(NB, m_Context->MiniportHandle); });\n\n    if(m_NBL)\n    {\n        auto NBL = DetachInternalObject();\n        NET_BUFFER_LIST_NEXT_NBL(NBL) = nullptr;\n        NdisMSendNetBufferListsComplete(m_Context->MiniportHandle, NBL, 0);\n    }\n}\n\nbool CNBL::ParsePriority()\n{\n    NDIS_NET_BUFFER_LIST_8021Q_INFO priorityInfo;\n    priorityInfo.Value = m_Context->ulPriorityVlanSetting ?\n        NET_BUFFER_LIST_INFO(m_NBL, Ieee8021QNetBufferListInfo) : nullptr;\n\n    if (!priorityInfo.TagHeader.VlanId)\n    {\n        priorityInfo.TagHeader.VlanId = m_Context->VlanId;\n    }\n\n    if (priorityInfo.TagHeader.CanonicalFormatId || !IsValidVlanId(m_Context, priorityInfo.TagHeader.VlanId))\n    {\n        DPrintf(0, (\"[%s] Discarded invalid priority tag %p\\n\", __FUNCTION__, priorityInfo.Value));\n        return false;\n    }\n    else if (priorityInfo.Value)\n    {\n        // ignore priority, if configured\n        if (!IsPrioritySupported(m_Context))\n            priorityInfo.TagHeader.UserPriority = 0;\n        // ignore VlanId, if specified\n        if (!IsVlanSupported(m_Context))\n            priorityInfo.TagHeader.VlanId = 0;\n        if (priorityInfo.Value)\n        {\n            m_TCI = static_cast<UINT16>(priorityInfo.TagHeader.UserPriority << 13 | priorityInfo.TagHeader.VlanId);\n            DPrintf(1, (\"[%s] Populated priority tag %p\\n\", __FUNCTION__, priorityInfo.Value));\n        }\n    }\n\n    return true;\n}\n\nvoid CNBL::RegisterNB(CNB *NB)\n{\n    m_Buffers.PushBack(NB);\n    m_BuffersNumber++;\n}\n\nvoid CNBL::RegisterMappedNB(CNB *NB)\n{\n    if (m_MappedBuffers.PushBack(NB) == m_BuffersNumber)\n    {\n        m_ParentTXPath->NBLMappingDone(this);\n    }\n}\n\nbool CNBL::ParseBuffers()\n{\n    m_MaxDataLength = 0;\n\n    for (auto NB = NET_BUFFER_LIST_FIRST_NB(m_NBL); NB != nullptr; NB = NET_BUFFER_NEXT_NB(NB))\n    {\n        CNB *NBHolder = new (m_Context->MiniportHandle) CNB(NB, this, m_Context);\n        if(!NBHolder || !NBHolder->IsValid())\n        {\n            return false;\n        }\n        RegisterNB(NBHolder);\n        m_MaxDataLength = max(m_MaxDataLength, NBHolder->GetDataLength());\n    }\n\n    if(m_MaxDataLength == 0)\n    {\n        DPrintf(0, (\"Empty NBL (%p) dropped\\n\", __FUNCTION__, m_NBL));\n        return false;\n    }\n\n    return true;\n}\n\nbool CNBL::NeedsLSO()\n{\n    return m_MaxDataLength > m_Context->MaxPacketSize.nMaxFullSizeOS;\n}\n\nbool CNBL::FitsLSO()\n{\n    return (m_MaxDataLength <= PARANDIS_MAX_LSO_SIZE + LsoTcpHeaderOffset() + MAX_TCP_HEADER_SIZE);\n}\n\nbool CNBL::ParseLSO()\n{\n    ASSERT(IsLSO());\n\n    if (m_LsoInfo.LsoV1Transmit.Type != NDIS_TCP_LARGE_SEND_OFFLOAD_V1_TYPE &&\n        m_LsoInfo.LsoV2Transmit.Type != NDIS_TCP_LARGE_SEND_OFFLOAD_V2_TYPE)\n    {\n        return false;\n    }\n\n    if (NeedsLSO() &&\n        (!m_LsoInfo.LsoV2Transmit.MSS ||\n         !m_LsoInfo.LsoV2Transmit.TcpHeaderOffset))\n    {\n        return false;\n    }\n\n    if (!FitsLSO())\n    {\n        return false;\n    }\n\n    if (!LsoTcpHeaderOffset() != !MSS())\n    {\n        return false;\n    }\n\n    if ((!m_Context->Offload.flags.fTxLso || !m_Context->bOffloadv4Enabled) &&\n        m_LsoInfo.LsoV2Transmit.IPVersion == NDIS_TCP_LARGE_SEND_OFFLOAD_IPv4)\n    {\n        return false;\n    }\n\n    if (m_LsoInfo.LsoV2Transmit.Type == NDIS_TCP_LARGE_SEND_OFFLOAD_V2_TYPE &&\n        m_LsoInfo.LsoV2Transmit.IPVersion == NDIS_TCP_LARGE_SEND_OFFLOAD_IPv6 &&\n        (!m_Context->Offload.flags.fTxLsov6 || !m_Context->bOffloadv6Enabled))\n    {\n        return false;\n    }\n\n    return true;\n}\n\ntemplate <typename TClassPred, typename TOffloadPred, typename TSupportedPred>\nbool CNBL::ParseCSO(TClassPred IsClass, TOffloadPred IsOffload,\n                    TSupportedPred IsSupported, LPSTR OffloadName)\n{\n    ASSERT(IsClass());\n    UNREFERENCED_PARAMETER(IsClass);\n\n    if (IsOffload())\n    {\n        if(!IsSupported())\n        {\n            DPrintf(0, (\"[%s] %s request when it is not supported\\n\", __FUNCTION__, OffloadName));\n#if FAIL_UNEXPECTED\n            // ignore unexpected CS requests while this passes WHQL\n            return false;\n#endif\n        }\n    }\n    return true;\n}\n\nbool CNBL::ParseOffloads()\n{\n    if (IsLSO())\n    {\n        if(!ParseLSO())\n        {\n            return false;\n        }\n    }\n    else if (IsIP4CSO())\n    {\n        if(!ParseCSO([this] () -> bool { return IsIP4CSO(); },\n                     [this] () -> bool { return m_CsoInfo.Transmit.TcpChecksum; },\n                     [this] () -> bool { return m_Context->Offload.flags.fTxTCPChecksum && m_Context->bOffloadv4Enabled; },\n                     \"TCP4 CSO\"))\n        {\n            return false;\n        }\n        else if(!ParseCSO([this] () -> bool { return IsIP4CSO(); },\n                          [this] () -> bool { return m_CsoInfo.Transmit.UdpChecksum; },\n                          [this] () -> bool { return m_Context->Offload.flags.fTxUDPChecksum && m_Context->bOffloadv4Enabled; },\n                          \"UDP4 CSO\"))\n        {\n            return false;\n        }\n\n        if(!ParseCSO([this] () -> bool { return IsIP4CSO(); },\n                     [this] () -> bool { return m_CsoInfo.Transmit.IpHeaderChecksum; },\n                     [this] () -> bool { return m_Context->Offload.flags.fTxIPChecksum && m_Context->bOffloadv4Enabled; },\n                     \"IP4 CSO\"))\n        {\n            return false;\n        }\n    }\n    else if (IsIP6CSO())\n    {\n        if(!ParseCSO([this] () -> bool { return IsIP6CSO(); },\n                     [this] () -> bool { return m_CsoInfo.Transmit.TcpChecksum; },\n                     [this] () -> bool { return m_Context->Offload.flags.fTxTCPv6Checksum && m_Context->bOffloadv6Enabled; },\n                     \"TCP6 CSO\"))\n        {\n            return false;\n        }\n        else if(!ParseCSO([this] () -> bool { return IsIP6CSO(); },\n                          [this] () -> bool { return m_CsoInfo.Transmit.UdpChecksum; },\n                          [this] () -> bool { return m_Context->Offload.flags.fTxUDPv6Checksum && m_Context->bOffloadv6Enabled; },\n                          \"UDP6 CSO\"))\n        {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid CNBL::StartMapping()\n{\n    CDpcIrqlRaiser OnDpc;\n\n    AddRef();\n\n    m_Buffers.ForEachDetached([this](CNB *NB)\n                              {\n                                  if (!NB->ScheduleBuildSGListForTx())\n                                  {\n                                      m_HaveFailedMappings = true;\n                                      NB->MappingDone(nullptr);\n                                  }\n                              });\n\n    Release();\n}\n\nvoid CNBL::OnLastReferenceGone()\n{\n    Destroy(this, m_Context->MiniportHandle);\n}\n\nCParaNdisTX::CParaNdisTX()\n{ }\n\nbool CParaNdisTX::Create(PPARANDIS_ADAPTER Context, UINT DeviceQueueIndex)\n{\n    m_Context = Context;\n    m_queueIndex = (u16)DeviceQueueIndex;\n\n    return m_VirtQueue.Create(DeviceQueueIndex,\n        m_Context->IODevice,\n        m_Context->MiniportHandle,\n        m_Context->bDoPublishIndices ? true : false,\n        m_Context->maxFreeTxDescriptors,\n        m_Context->nVirtioHeaderSize,\n        m_Context);\n}\n\nvoid CParaNdisTX::Send(PNET_BUFFER_LIST NBL)\n{\n    PNET_BUFFER_LIST nextNBL = nullptr;\n\n    for(auto currNBL = NBL; currNBL != nullptr; currNBL = nextNBL)\n    {\n        nextNBL = NET_BUFFER_LIST_NEXT_NBL(currNBL);\n        NET_BUFFER_LIST_NEXT_NBL(currNBL) = nullptr;\n\n        auto NBLHolder = new (m_Context->MiniportHandle) CNBL(currNBL, m_Context, *this);\n\n        if (NBLHolder == nullptr)\n        {\n            CNBL OnStack(currNBL, m_Context, *this);\n            OnStack.SetStatus(NDIS_STATUS_RESOURCES);\n            DPrintf(0, (\"ERROR: Failed to allocate CNBL instance\\n\"));\n            continue;\n        }\n\n        if(NBLHolder->Prepare() &&\n           ParaNdis_IsSendPossible(m_Context))\n        {\n            NBLHolder->StartMapping();\n        }\n        else\n        {\n            NBLHolder->SetStatus(ParaNdis_ExactSendFailureStatus(m_Context));\n            NBLHolder->Release();\n        }\n    }\n}\n\nvoid CParaNdisTX::NBLMappingDone(CNBL *NBLHolder)\n{\n    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);\n\n    if (NBLHolder->MappingSuceeded())\n    {\n        DoWithTXLock([NBLHolder, this](){ m_SendList.PushBack(NBLHolder); });\n        DoPendingTasks(false);\n    }\n    else\n    {\n        NBLHolder->SetStatus(NDIS_STATUS_FAILURE);\n        NBLHolder->Release();\n    }\n}\n\nCNB *CNBL::PopMappedNB()\n{\n    m_MappedBuffersDetached++;\n    return m_MappedBuffers.Pop();\n}\nvoid CNBL::PushMappedNB(CNB *NB)\n{\n    m_MappedBuffersDetached--;\n    m_MappedBuffers.Push(NB);\n}\n\n//TODO: Needs review\nvoid CNBL::NBComplete()\n{\n    m_BuffersDone++;\n    m_MappedBuffersDetached--;\n}\n\nbool CNBL::IsSendDone()\n{\n    return m_BuffersDone == m_BuffersNumber;\n}\n\n//TODO: Needs review\nvoid CNBL::CompleteMappedBuffers()\n{\n    m_MappedBuffers.ForEachDetached([this](CNB *NB)\n                                        {\n                                            NBComplete();\n                                            CNB::Destroy(NB, m_Context->MiniportHandle);\n                                        });\n}\n\nPNET_BUFFER_LIST CNBL::DetachInternalObject()\n{\n\n    // do it for both LsoV1 and LsoV2\n    if (IsLSO())\n    {\n        m_LsoInfo.LsoV1TransmitComplete.TcpPayload = m_TransferSize;\n    }\n\n    //Flush changes made in LSO structures\n    NET_BUFFER_LIST_INFO(m_NBL, TcpLargeSendNetBufferListInfo) = m_LsoInfo.Value;\n\n    auto Res = m_NBL;\n    m_NBL = nullptr;\n    return Res;\n}\n\nPNET_BUFFER_LIST CParaNdisTX::ProcessWaitingList()\n{\n    PNET_BUFFER_LIST CompletedNBLs = nullptr;\n\n\n    m_WaitingList.ForEachDetachedIf([](CNBL* NBL) { return NBL->IsSendDone(); },\n                                        [&](CNBL* NBL)\n                                        {\n                                            NBL->SetStatus(NDIS_STATUS_SUCCESS);\n                                            auto RawNBL = NBL->DetachInternalObject();\n                                            NBL->Release();\n                                            NET_BUFFER_LIST_NEXT_NBL(RawNBL) = CompletedNBLs;\n                                            CompletedNBLs = RawNBL;\n                                        });\n\n    return CompletedNBLs;\n}\n\n//TODO: Needs review\nPNET_BUFFER_LIST CParaNdisTX::RemoveAllNonWaitingNBLs()\n{\n    PNET_BUFFER_LIST RemovedNBLs = nullptr;\n    auto status = ParaNdis_ExactSendFailureStatus(m_Context);\n\n    m_SendList.ForEachDetachedIf([](CNBL *NBL) { return !NBL->HaveDetachedBuffers(); },\n                                     [&](CNBL *NBL)\n                                     {\n                                         NBL->SetStatus(status);\n                                         auto RawNBL = NBL->DetachInternalObject();\n                                         NBL->Release();\n                                         NET_BUFFER_LIST_NEXT_NBL(RawNBL) = RemovedNBLs;\n                                         RemovedNBLs = RawNBL;\n                                     });\n\n    m_SendList.ForEach([](CNBL *NBL) { NBL->CompleteMappedBuffers(); });\n\n    return RemovedNBLs;\n}\n\nbool CParaNdisTX::Pause()\n{\n    PNET_BUFFER_LIST NBL = nullptr;\n    bool res;\n\n    DoWithTXLock([this, &NBL, &res]()\n                 {\n                     NBL = RemoveAllNonWaitingNBLs();\n                     res = (!m_VirtQueue.HasPacketsInHW() && m_WaitingList.IsEmpty());\n                 });\n\n    if(NBL != nullptr)\n    {\n        NdisMSendNetBufferListsComplete(m_Context->MiniportHandle, NBL, 0);\n    }\n\n    return res;\n}\n\nPNET_BUFFER_LIST CParaNdisTX::BuildCancelList(PVOID CancelId)\n{\n    PNET_BUFFER_LIST CanceledNBLs = nullptr;\n    TSpinLocker LockedContext(m_Lock);\n\n    m_SendList.ForEachDetachedIf([CancelId](CNBL* NBL){ return NBL->MatchCancelID(CancelId) && !NBL->HaveDetachedBuffers(); },\n                                     [this, &CanceledNBLs](CNBL* NBL)\n                                     {\n                                         NBL->SetStatus(NDIS_STATUS_SEND_ABORTED);\n                                         auto RawNBL = NBL->DetachInternalObject();\n                                         NBL->Release();\n                                         NET_BUFFER_LIST_NEXT_NBL(RawNBL) = CanceledNBLs;\n                                         CanceledNBLs = RawNBL;\n                                     });\n\n    return CanceledNBLs;\n}\n\nvoid CParaNdisTX::CancelNBLs(PVOID CancelId)\n{\n    auto CanceledNBLs = BuildCancelList(CancelId);\n    if (CanceledNBLs != nullptr)\n    {\n        NdisMSendNetBufferListsComplete(m_Context->MiniportHandle, CanceledNBLs, 0);\n    }\n}\n\n//TODO: Requires review\nBOOLEAN _Function_class_(MINIPORT_SYNCHRONIZE_INTERRUPT) CParaNdisTX::RestartQueueSynchronously(tSynchronizedContext *ctx)\n{\n    auto TXPath = static_cast<CParaNdisTX *>(ctx->Parameter);\n    return !TXPath->m_VirtQueue.Restart();\n}\n\n//TODO: Requires review\nbool CParaNdisTX::RestartQueue(bool DoKick)\n{\n    TSpinLocker LockedContext(m_Lock);\n    auto res = ParaNdis_SynchronizeWithInterrupt(m_Context,\n                                                 m_messageIndex,\n                                                 CParaNdisTX::RestartQueueSynchronously,\n                                                 this) ? true : false;\n\n    if(DoKick)\n    {\n        Kick();\n    }\n\n    return res;\n}\n\nbool CParaNdisTX::SendMapped(bool IsInterrupt, PNET_BUFFER_LIST &NBLFailNow)\n{\n    if(!ParaNdis_IsSendPossible(m_Context))\n    {\n        NBLFailNow = RemoveAllNonWaitingNBLs();\n        if (NBLFailNow)\n        {\n            DPrintf(0, (__FUNCTION__ \" Failing send\"));\n        }\n    }\n    else\n    {\n        bool SentOutSomeBuffers = false;\n        auto HaveBuffers = true;\n\n        while (HaveBuffers && HaveMappedNBLs())\n        {\n            auto NBLHolder = PopMappedNBL();\n\n            if (NBLHolder->HaveMappedBuffers())\n            {\n                auto NBHolder = NBLHolder->PopMappedNB();\n                auto result = m_VirtQueue.SubmitPacket(*NBHolder);\n\n                switch (result)\n                {\n                case SUBMIT_NO_PLACE_IN_QUEUE:\n                    NBLHolder->PushMappedNB(NBHolder);\n                    PushMappedNBL(NBLHolder);\n                    HaveBuffers = false;\n                    // break the loop, allow to kick and free some buffers\n                    break;\n\n                case SUBMIT_FAILURE:\n                case SUBMIT_SUCCESS:\n                case SUBMIT_PACKET_TOO_LARGE:\n                    // if this NBL finished?\n                    if (!NBLHolder->HaveMappedBuffers())\n                    {\n                        m_WaitingList.Push(NBLHolder);\n                    }\n                    else\n                    {\n                        // no, insert it back to the queue\n                        PushMappedNBL(NBLHolder);\n                    }\n\n                    if (result == SUBMIT_SUCCESS)\n                    {\n                        SentOutSomeBuffers = true;\n                    }\n                    else\n                    {\n                        NBHolder->SendComplete();\n                        CNB::Destroy(NBHolder, m_Context->MiniportHandle);\n                    }\n                    break;\n                default:\n                    ASSERT(false);\n                    break;\n                }\n            }\n            else\n            {\n\n                //TODO: Refactoring needed\n                //This is a case when pause called, mapped list cleared but NBL is still in the send list\n                m_WaitingList.Push(NBLHolder);\n            }\n        }\n\n        if (SentOutSomeBuffers)\n        {\n            DPrintf(2, (\"[%s] sent down\\n\", __FUNCTION__, SentOutSomeBuffers));\n            if (IsInterrupt)\n            {\n                return true;\n            }\n            else\n            {\n                m_VirtQueue.Kick();\n            }\n        }\n    }\n\n    return false;\n}\n\nbool CParaNdisTX::DoPendingTasks(bool IsInterrupt)\n{\n    ONPAUSECOMPLETEPROC CallbackToCall = nullptr;\n    PNET_BUFFER_LIST pNBLFailNow = nullptr;\n    PNET_BUFFER_LIST pNBLReturnNow = nullptr;\n    bool bDoKick = false;\n\n    DoWithTXLock([&] ()\n                 {\n                    m_VirtQueue.ProcessTXCompletions();\n                    bDoKick = SendMapped(IsInterrupt, pNBLFailNow);\n                    pNBLReturnNow = ProcessWaitingList();\n                    {\n                        CNdisPassiveWriteAutoLock tLock(m_Context->m_PauseLock);\n\n                        if (!m_VirtQueue.HasPacketsInHW() && m_Context->SendState == srsPausing)\n                        {\n                            CallbackToCall = m_Context->SendPauseCompletionProc;\n                            m_Context->SendPauseCompletionProc = nullptr;\n                            m_Context->SendState = srsDisabled;\n                        }\n                    }\n                 });\n\n    if (pNBLFailNow)\n    {\n        NdisMSendNetBufferListsComplete(m_Context->MiniportHandle, pNBLFailNow,\n                                        NDIS_SEND_COMPLETE_FLAGS_DISPATCH_LEVEL);\n    }\n\n    if (pNBLReturnNow)\n    {\n        NdisMSendNetBufferListsComplete(m_Context->MiniportHandle, pNBLReturnNow,\n                                        NDIS_SEND_COMPLETE_FLAGS_DISPATCH_LEVEL);\n    }\n\n    if (CallbackToCall != nullptr)\n    {\n        CallbackToCall(m_Context);\n    }\n\n    return bDoKick;\n}\n\nvoid CNB::MappingDone(PSCATTER_GATHER_LIST SGL)\n{\n    m_SGL = SGL;\n    m_ParentNBL->RegisterMappedNB(this);\n}\n\nCNB::~CNB()\n{\n    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);\n\n    if(m_SGL != nullptr)\n    {\n        NdisMFreeNetBufferSGList(m_Context->DmaHandle, m_SGL, m_NB);\n    }\n}\n\nbool CNB::ScheduleBuildSGListForTx()\n{\n    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);\n\n    return NdisMAllocateNetBufferSGList(m_Context->DmaHandle, m_NB, this,\n                                        NDIS_SG_LIST_WRITE_TO_DEVICE, nullptr, 0) == NDIS_STATUS_SUCCESS;\n}\n\nvoid CNB::PopulateIPLength(IPv4Header *IpHeader, USHORT IpLength) const\n{\n    if ((IpHeader->ip_verlen & 0xF0) == 0x40)\n    {\n        if (!IpHeader->ip_length) {\n            IpHeader->ip_length = swap_short(IpLength);\n        }\n    }\n}\n\nvoid CNB::SetupLSO(virtio_net_hdr_basic *VirtioHeader, PVOID IpHeader, ULONG EthPayloadLength) const\n{\n    PopulateIPLength(reinterpret_cast<IPv4Header*>(IpHeader), static_cast<USHORT>(EthPayloadLength));\n\n    tTcpIpPacketParsingResult packetReview;\n    packetReview = ParaNdis_CheckSumVerifyFlat(reinterpret_cast<IPv4Header*>(IpHeader), EthPayloadLength,\n                                               pcrIpChecksum | pcrFixIPChecksum | pcrTcpChecksum | pcrFixPHChecksum,\n                                               FALSE,\n                                               __FUNCTION__);\n\n    if (packetReview.xxpCheckSum == ppresPCSOK || packetReview.fixedXxpCS)\n    {\n        auto IpHeaderOffset = m_Context->Offload.ipHeaderOffset;\n        auto VHeader = static_cast<virtio_net_hdr_basic*>(VirtioHeader);\n        auto PriorityHdrLen = (m_ParentNBL->TCI() != 0) ? ETH_PRIORITY_HEADER_SIZE : 0;\n\n        VHeader->flags = VIRTIO_NET_HDR_F_NEEDS_CSUM;\n        VHeader->gso_type = packetReview.ipStatus == ppresIPV4 ? VIRTIO_NET_HDR_GSO_TCPV4 : VIRTIO_NET_HDR_GSO_TCPV6;\n        VHeader->hdr_len = (USHORT)(packetReview.XxpIpHeaderSize + IpHeaderOffset + PriorityHdrLen);\n        VHeader->gso_size = (USHORT)m_ParentNBL->MSS();\n        VHeader->csum_start = (USHORT)(m_ParentNBL->TCPHeaderOffset() + PriorityHdrLen);\n        VHeader->csum_offset = TCP_CHECKSUM_OFFSET;\n    }\n}\n\nUSHORT CNB::QueryL4HeaderOffset(PVOID PacketData, ULONG IpHeaderOffset) const\n{\n    USHORT Res;\n    auto ppr = ParaNdis_ReviewIPPacket(RtlOffsetToPointer(PacketData, IpHeaderOffset),\n                                       GetDataLength(), FALSE, __FUNCTION__);\n    if (ppr.ipStatus != ppresNotIP)\n    {\n        Res = static_cast<USHORT>(IpHeaderOffset + ppr.ipHeaderSize);\n    }\n    else\n    {\n        DPrintf(0, (\"[%s] ERROR: NOT an IP packet - expected troubles!\\n\", __FUNCTION__));\n        Res = 0;\n    }\n    return Res;\n}\n\nvoid CNB::SetupCSO(virtio_net_hdr_basic *VirtioHeader, ULONG L4HeaderOffset) const\n{\n    u16 PriorityHdrLen = m_ParentNBL->TCI() ? ETH_PRIORITY_HEADER_SIZE : 0;\n\n    VirtioHeader->flags = VIRTIO_NET_HDR_F_NEEDS_CSUM;\n    VirtioHeader->csum_start = static_cast<u16>(L4HeaderOffset) + PriorityHdrLen;\n    VirtioHeader->csum_offset = m_ParentNBL->IsTcpCSO() ? TCP_CHECKSUM_OFFSET : UDP_CHECKSUM_OFFSET;\n}\n\nvoid CNB::DoIPHdrCSO(PVOID IpHeader, ULONG EthPayloadLength) const\n{\n    ParaNdis_CheckSumVerifyFlat(IpHeader,\n                                EthPayloadLength,\n                                pcrIpChecksum | pcrFixIPChecksum, FALSE,\n                                __FUNCTION__);\n}\n\nbool CNB::FillDescriptorSGList(CTXDescriptor &Descriptor, ULONG ParsedHeadersLength) const\n{\n    return Descriptor.SetupHeaders(ParsedHeadersLength) &&\n           MapDataToVirtioSGL(Descriptor, ParsedHeadersLength + NET_BUFFER_DATA_OFFSET(m_NB));\n}\n\nbool CNB::MapDataToVirtioSGL(CTXDescriptor &Descriptor, ULONG Offset) const\n{\n    for (ULONG i = 0; i < m_SGL->NumberOfElements; i++)\n    {\n        if (Offset < m_SGL->Elements[i].Length)\n        {\n            PHYSICAL_ADDRESS PA;\n            PA.QuadPart = m_SGL->Elements[i].Address.QuadPart + Offset;\n\n            if (!Descriptor.AddDataChunk(PA, m_SGL->Elements[i].Length - Offset))\n            {\n                return false;\n            }\n\n            Offset = 0;\n        }\n        else\n        {\n            Offset -= m_SGL->Elements[i].Length;\n        }\n    }\n\n    return true;\n}\n\nbool CNB::CopyHeaders(PVOID Destination, ULONG MaxSize, ULONG &HeadersLength, ULONG &L4HeaderOffset) const\n{\n    HeadersLength = 0;\n    L4HeaderOffset = 0;\n\n    if (m_ParentNBL->IsLSO() || m_ParentNBL->IsTcpCSO())\n    {\n        L4HeaderOffset = m_ParentNBL->TCPHeaderOffset();\n        HeadersLength = L4HeaderOffset + sizeof(TCPHeader);\n        Copy(Destination, HeadersLength);\n    }\n    else if (m_ParentNBL->IsUdpCSO())\n    {\n        Copy(Destination, MaxSize);\n        L4HeaderOffset = QueryL4HeaderOffset(Destination, m_Context->Offload.ipHeaderOffset);\n        HeadersLength = L4HeaderOffset + sizeof(UDPHeader);\n    }\n    else if (m_ParentNBL->IsIPHdrCSO())\n    {\n        Copy(Destination, MaxSize);\n        HeadersLength = QueryL4HeaderOffset(Destination, m_Context->Offload.ipHeaderOffset);\n        L4HeaderOffset = HeadersLength;\n    }\n    else\n    {\n        HeadersLength = ETH_HEADER_SIZE;\n        Copy(Destination, HeadersLength);\n    }\n\n    return (HeadersLength <= MaxSize);\n}\n\nvoid CNB::BuildPriorityHeader(PETH_HEADER EthHeader, PVLAN_HEADER VlanHeader) const\n{\n    VlanHeader->TCI = RtlUshortByteSwap(m_ParentNBL->TCI());\n\n    if (VlanHeader->TCI != 0)\n    {\n        VlanHeader->EthType = EthHeader->EthType;\n        EthHeader->EthType = RtlUshortByteSwap(PRIO_HEADER_ETH_TYPE);\n    }\n}\n\nvoid CNB::PrepareOffloads(virtio_net_hdr_basic *VirtioHeader, PVOID IpHeader, ULONG EthPayloadLength, ULONG L4HeaderOffset) const\n{\n    *VirtioHeader = {};\n\n    if (m_ParentNBL->IsLSO())\n    {\n        SetupLSO(VirtioHeader, IpHeader, EthPayloadLength);\n    }\n    else if (m_ParentNBL->IsTcpCSO() || m_ParentNBL->IsUdpCSO())\n    {\n        SetupCSO(VirtioHeader, L4HeaderOffset);\n    }\n\n    if (m_ParentNBL->IsIPHdrCSO())\n    {\n        DoIPHdrCSO(IpHeader, EthPayloadLength);\n    }\n}\n\nbool CNB::BindToDescriptor(CTXDescriptor &Descriptor)\n{\n    if (m_SGL == nullptr)\n    {\n        return false;\n    }\n\n    Descriptor.SetNB(this);\n\n    auto &HeadersArea = Descriptor.HeadersAreaAccessor();\n    auto EthHeaders = HeadersArea.EthHeadersAreaVA();\n    ULONG HeadersLength;\n    ULONG L4HeaderOffset;\n\n    if (!CopyHeaders(EthHeaders, HeadersArea.MaxEthHeadersSize(), HeadersLength, L4HeaderOffset))\n    {\n        return false;\n    }\n\n    BuildPriorityHeader(HeadersArea.EthHeader(), HeadersArea.VlanHeader());\n    PrepareOffloads(HeadersArea.VirtioHeader(),\n                    HeadersArea.IPHeaders(),\n                    GetDataLength() - m_Context->Offload.ipHeaderOffset,\n                    L4HeaderOffset);\n\n    return FillDescriptorSGList(Descriptor, HeadersLength);\n}\n\nbool CNB::Copy(PVOID Dst, ULONG Length) const\n{\n    ULONG CurrOffset = NET_BUFFER_CURRENT_MDL_OFFSET(m_NB);\n    ULONG Copied = 0;\n\n    for (PMDL CurrMDL = NET_BUFFER_CURRENT_MDL(m_NB);\n         CurrMDL != nullptr && Copied < Length;\n         CurrMDL = CurrMDL->Next)\n    {\n        ULONG CurrLen;\n        PVOID CurrAddr;\n\n#if NDIS_SUPPORT_NDIS620\n        NdisQueryMdl(CurrMDL, &CurrAddr, &CurrLen, LowPagePriority | MdlMappingNoExecute);\n#else\n        NdisQueryMdl(CurrMDL, &CurrAddr, &CurrLen, LowPagePriority);\n#endif\n\n        if (CurrAddr == nullptr)\n        {\n            break;\n        }\n\n        CurrLen = min(CurrLen - CurrOffset, Length - Copied);\n\n        NdisMoveMemory(RtlOffsetToPointer(Dst, Copied),\n                       RtlOffsetToPointer(CurrAddr, CurrOffset),\n                       CurrLen);\n\n        Copied += CurrLen;\n        CurrOffset = 0;\n    }\n\n    return (Copied == Length);\n}\n", "/**********************************************************************\n * Copyright (c) 2008  Red Hat, Inc.\n *\n * File: ndis56common.h\n *\n * This file contains general definitions for VirtIO network adapter driver,\n * common for both NDIS5 and NDIS6\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n**********************************************************************/\n#ifndef PARANDIS_56_COMMON_H\n#define PARANDIS_56_COMMON_H\n\n//#define PARANDIS_TEST_TX_KICK_ALWAYS\n#if defined(OFFLOAD_UNIT_TEST)\n#include <windows.h>\n#include <stdio.h>\n\n#define ETH_LENGTH_OF_ADDRESS       6\n#define DoPrint(fmt, ...) printf(fmt##\"\\n\", __VA_ARGS__)\n#define DPrintf(a,b) DoPrint b\n#define RtlOffsetToPointer(B,O)  ((PCHAR)( ((PCHAR)(B)) + ((ULONG_PTR)(O))  ))\n\n#include \"ethernetutils.h\"\n#endif //+OFFLOAD_UNIT_TEST\n\n#if !defined(OFFLOAD_UNIT_TEST)\n\n#if !defined(RtlOffsetToPointer)\n#define RtlOffsetToPointer(Base,Offset)  ((PCHAR)(((PCHAR)(Base))+((ULONG_PTR)(Offset))))\n#endif\n\n#if !defined(RtlPointerToOffset)\n#define RtlPointerToOffset(Base,Pointer)  ((ULONG)(((PCHAR)(Pointer))-((PCHAR)(Base))))\n#endif\n\nextern \"C\"\n{\n#include \"osdep.h\"\n\n#if NDIS_SUPPORT_NDIS630\n#define PARANDIS_SUPPORT_RSC 0 // Disable RSC support until support on the host side is ready\n#endif\n\n#if NDIS_SUPPORT_NDIS620\n#define PARANDIS_SUPPORT_RSS 1\n#endif\n\n#if !NDIS_SUPPORT_NDIS620\n    static VOID FORCEINLINE NdisFreeMemoryWithTagPriority(\n        IN  NDIS_HANDLE             NdisHandle,\n        IN  PVOID                   VirtualAddress,\n        IN  ULONG                   Tag)\n    {\n        UNREFERENCED_PARAMETER(NdisHandle);\n        UNREFERENCED_PARAMETER(Tag);\n        NdisFreeMemory(VirtualAddress, 0, 0);\n    }\n#endif\n\n#include \"kdebugprint.h\"\n#include \"ethernetutils.h\"\n#include \"virtio_pci.h\"\n#include \"VirtIO.h\"\n#include \"IONetDescriptor.h\"\n#include \"DebugData.h\"\n}\n\n#if !defined(_Function_class_)\n#define _Function_class_(x)\n#endif\n\n#include \"ParaNdis-RSS.h\"\n\ntypedef union _tagTcpIpPacketParsingResult tTcpIpPacketParsingResult;\n\ntypedef struct _tagCompletePhysicalAddress\n{\n    PHYSICAL_ADDRESS    Physical;\n    PVOID               Virtual;\n    ULONG               size;\n} tCompletePhysicalAddress;\n\nstruct _tagRxNetDescriptor;\ntypedef struct _tagRxNetDescriptor  RxNetDescriptor, *pRxNetDescriptor;\n\nstatic __inline BOOLEAN ParaNDIS_IsQueueInterruptEnabled(struct virtqueue * _vq);\n\n#include \"ParaNdis-TX.h\"\n#include \"ParaNdis-RX.h\"\n#include \"ParaNdis-CX.h\"\n\nstruct CPUPathesBundle : public CNdisAllocatable<CPUPathesBundle, 'CPPB'> {\n    CParaNdisRX rxPath;\n    bool        rxCreated = false;\n\n    CParaNdisTX txPath;\n    bool        txCreated = false;\n\n    CParaNdisCX *cxPath = NULL;\n} ;\n\n// those stuff defined in NDIS\n//NDIS_MINIPORT_MAJOR_VERSION\n//NDIS_MINIPORT_MINOR_VERSION\n// those stuff defined in build environment\n// PARANDIS_MAJOR_DRIVER_VERSION\n// PARANDIS_MINOR_DRIVER_VERSION\n\n#if !defined(NDIS_MINIPORT_MAJOR_VERSION) || !defined(NDIS_MINIPORT_MINOR_VERSION)\n#error \"Something is wrong with NDIS environment\"\n#endif\n\n#if !defined(PARANDIS_MAJOR_DRIVER_VERSION) || !defined(PARANDIS_MINOR_DRIVER_VERSION)\n#error \"Something is wrong with our versioning\"\n#endif\n\n// define if qemu supports logging to static IO port for synchronization\n// of driver output with qemu printouts; in this case define the port number\n// #define VIRTIO_DBG_USE_IOPORT    0x99\n\n// to be set to real limit later\n#define MAX_RX_LOOPS    1000\n\n/* The feature bitmap for virtio net */\n#define VIRTIO_NET_F_CSUM   0   /* Host handles pkts w/ partial csum */\n#define VIRTIO_NET_F_GUEST_CSUM 1   /* Guest handles pkts w/ partial csum */\n#define VIRTIO_NET_F_CTRL_GUEST_OFFLOADS 2 /* Control channel offload\n                                         * configuration support */\n#define VIRTIO_NET_F_MAC    5   /* Host has given MAC address. */\n#define VIRTIO_NET_F_GSO    6   /* Host handles pkts w/ any GSO type */\n#define VIRTIO_NET_F_GUEST_TSO4 7   /* Guest can handle TSOv4 in. */\n#define VIRTIO_NET_F_GUEST_TSO6 8   /* Guest can handle TSOv6 in. */\n#define VIRTIO_NET_F_GUEST_ECN  9   /* Guest can handle TSO[6] w/ ECN in. */\n#define VIRTIO_NET_F_GUEST_UFO  10  /* Guest can handle UFO in. */\n#define VIRTIO_NET_F_HOST_TSO4  11  /* Host can handle TSOv4 in. */\n#define VIRTIO_NET_F_HOST_TSO6  12  /* Host can handle TSOv6 in. */\n#define VIRTIO_NET_F_HOST_ECN   13  /* Host can handle TSO[6] w/ ECN in. */\n#define VIRTIO_NET_F_HOST_UFO   14  /* Host can handle UFO in. */\n#define VIRTIO_NET_F_MRG_RXBUF  15  /* Host can handle merged Rx buffers and requires bigger header for that. */\n#define VIRTIO_NET_F_STATUS     16\n#define VIRTIO_NET_F_CTRL_VQ    17      /* Control channel available */\n#define VIRTIO_NET_F_CTRL_RX    18      /* Control channel RX mode support */\n#define VIRTIO_NET_F_CTRL_VLAN  19      /* Control channel VLAN filtering */\n#define VIRTIO_NET_F_CTRL_RX_EXTRA 20   /* Extra RX mode control support */\n#define VIRTIO_NET_F_CTRL_MQ    22\n\n#define VIRTIO_NET_F_CTRL_MAC_ADDR   23 /* Set MAC address */\n\n#define VIRTIO_NET_S_LINK_UP    1       /* Link is up */\n\n#define VIRTIO_NET_INVALID_INTERRUPT_STATUS     0xFF\n\n#define PARANDIS_MULTICAST_LIST_SIZE        32\n#define PARANDIS_MEMORY_TAG                 '5muQ'\n#define PARANDIS_FORMAL_LINK_SPEED          (pContext->ulFormalLinkSpeed)\n#define PARANDIS_MAXIMUM_TRANSMIT_SPEED     PARANDIS_FORMAL_LINK_SPEED\n#define PARANDIS_MAXIMUM_RECEIVE_SPEED      PARANDIS_FORMAL_LINK_SPEED\n#define PARANDIS_MIN_LSO_SEGMENTS           2\n// reported\n#define PARANDIS_MAX_LSO_SIZE               0xF800\n\n#define PARANDIS_UNLIMITED_PACKETS_TO_INDICATE  (~0ul)\n\nstatic const ULONG PARANDIS_PACKET_FILTERS =\n    NDIS_PACKET_TYPE_DIRECTED |\n    NDIS_PACKET_TYPE_MULTICAST |\n    NDIS_PACKET_TYPE_BROADCAST |\n    NDIS_PACKET_TYPE_PROMISCUOUS |\n    NDIS_PACKET_TYPE_ALL_MULTICAST;\n\ntypedef VOID (*ONPAUSECOMPLETEPROC)(VOID *);\n\n\ntypedef enum _tagSendReceiveState\n{\n    srsDisabled = 0,        // initial state\n    srsPausing,\n    srsEnabled\n} tSendReceiveState;\n\ntypedef struct _tagAdapterResources\n{\n    ULONG ulIOAddress;\n    ULONG IOLength;\n    ULONG Vector;\n    ULONG Level;\n    KAFFINITY Affinity;\n    ULONG InterruptFlags;\n} tAdapterResources;\n\ntypedef enum _tagOffloadSettingsBit\n{\n    osbT4IpChecksum = (1 << 0),\n    osbT4TcpChecksum = (1 << 1),\n    osbT4UdpChecksum = (1 << 2),\n    osbT4TcpOptionsChecksum = (1 << 3),\n    osbT4IpOptionsChecksum = (1 << 4),\n    osbT4Lso = (1 << 5),\n    osbT4LsoIp = (1 << 6),\n    osbT4LsoTcp = (1 << 7),\n    osbT4RxTCPChecksum = (1 << 8),\n    osbT4RxTCPOptionsChecksum = (1 << 9),\n    osbT4RxIPChecksum = (1 << 10),\n    osbT4RxIPOptionsChecksum = (1 << 11),\n    osbT4RxUDPChecksum = (1 << 12),\n    osbT6TcpChecksum = (1 << 13),\n    osbT6UdpChecksum = (1 << 14),\n    osbT6TcpOptionsChecksum = (1 << 15),\n    osbT6IpExtChecksum = (1 << 16),\n    osbT6Lso = (1 << 17),\n    osbT6LsoIpExt = (1 << 18),\n    osbT6LsoTcpOptions = (1 << 19),\n    osbT6RxTCPChecksum = (1 << 20),\n    osbT6RxTCPOptionsChecksum = (1 << 21),\n    osbT6RxUDPChecksum = (1 << 22),\n    osbT6RxIpExtChecksum = (1 << 23),\n}tOffloadSettingsBit;\n\ntypedef struct _tagOffloadSettingsFlags\n{\n    int fTxIPChecksum       : 1;\n    int fTxTCPChecksum      : 1;\n    int fTxUDPChecksum      : 1;\n    int fTxTCPOptions       : 1;\n    int fTxIPOptions        : 1;\n    int fTxLso              : 1;\n    int fTxLsoIP            : 1;\n    int fTxLsoTCP           : 1;\n    int fRxIPChecksum       : 1;\n    int fRxTCPChecksum      : 1;\n    int fRxUDPChecksum      : 1;\n    int fRxTCPOptions       : 1;\n    int fRxIPOptions        : 1;\n    int fTxTCPv6Checksum    : 1;\n    int fTxUDPv6Checksum    : 1;\n    int fTxTCPv6Options     : 1;\n    int fTxIPv6Ext          : 1;\n    int fTxLsov6            : 1;\n    int fTxLsov6IP          : 1;\n    int fTxLsov6TCP         : 1;\n    int fRxTCPv6Checksum    : 1;\n    int fRxUDPv6Checksum    : 1;\n    int fRxTCPv6Options     : 1;\n    int fRxIPv6Ext          : 1;\n}tOffloadSettingsFlags;\n\n\ntypedef struct _tagOffloadSettings\n{\n    /* current value of enabled offload features */\n    tOffloadSettingsFlags flags;\n    /* load once, do not modify - bitmask of offload features, enabled in configuration */\n    ULONG flagsValue;\n    ULONG ipHeaderOffset;\n    ULONG maxPacketSize;\n}tOffloadSettings;\n\n#pragma warning (push)\n#pragma warning (disable:4201)\ntypedef struct _tagChecksumCheckResult\n{\n    union\n    {\n        struct\n        {\n            int   TcpFailed     :1;\n            int   UdpFailed     :1;\n            int   IpFailed      :1;\n            int   TcpOK         :1;\n            int   UdpOK         :1;\n            int   IpOK          :1;\n        } flags;\n        int value;\n    };\n}tChecksumCheckResult;\n#pragma warning (pop)\n\ntypedef PMDL                tPacketHolderType;\ntypedef PNET_BUFFER_LIST    tPacketIndicationType;\n\ntypedef struct _tagOurCounters\n{\n    UINT nReusedRxBuffers;\n    UINT nPrintDiagnostic;\n    ULONG64 prevIn;\n    UINT nRxInactivity;\n}tOurCounters;\n\ntypedef struct _tagMaxPacketSize\n{\n    UINT nMaxDataSize;\n    UINT nMaxFullSizeOS;\n    UINT nMaxFullSizeHwTx;\n    UINT nMaxDataSizeHwRx;\n    UINT nMaxFullSizeOsRx;\n}tMaxPacketSize;\n\n#define MAX_HW_RX_PACKET_SIZE (MAX_IP4_DATAGRAM_SIZE + ETH_HEADER_SIZE + ETH_PRIORITY_HEADER_SIZE)\n#define MAX_OS_RX_PACKET_SIZE (MAX_IP4_DATAGRAM_SIZE + ETH_HEADER_SIZE)\n\n\ntypedef struct _tagMulticastData\n{\n    ULONG                   nofMulticastEntries;\n    UCHAR                   MulticastList[ETH_LENGTH_OF_ADDRESS * PARANDIS_MULTICAST_LIST_SIZE];\n}tMulticastData;\n\n#pragma warning (push)\n#pragma warning (disable:4201)\ntypedef struct _tagNET_PACKET_INFO\n{\n    struct\n    {\n        int isBroadcast   : 1;\n        int isMulticast   : 1;\n        int isUnicast     : 1;\n        int hasVlanHeader : 1;\n        int isIP4         : 1;\n        int isIP6         : 1;\n        int isTCP         : 1;\n        int isUDP         : 1;\n        int isFragment    : 1;\n    };\n\n    struct\n    {\n        UINT32 UserPriority : 3;\n        UINT32 VlanId       : 12;\n    } Vlan;\n\n#if PARANDIS_SUPPORT_RSS\n    struct\n    {\n        ULONG Value;\n        ULONG Type;\n        ULONG Function;\n    } RSSHash;\n#endif\n\n    ULONG L2HdrLen;\n    ULONG L3HdrLen;\n    ULONG L2PayloadLen;\n    ULONG ip6HomeAddrOffset;\n    ULONG ip6DestAddrOffset;\n\n    PUCHAR ethDestAddr;\n\n    PVOID headersBuffer;\n    ULONG dataLength;\n} NET_PACKET_INFO, *PNET_PACKET_INFO;\n#pragma warning (pop)\n\nstruct _tagRxNetDescriptor {\n    LIST_ENTRY listEntry;\n    LIST_ENTRY ReceiveQueueListEntry;\n\n#define PARANDIS_FIRST_RX_DATA_PAGE   (1)\n    struct VirtIOBufferDescriptor *BufferSGArray;\n    tCompletePhysicalAddress      *PhysicalPages;\n    ULONG                          PagesAllocated;\n    tCompletePhysicalAddress       IndirectArea;\n    tPacketHolderType              Holder;\n\n    NET_PACKET_INFO PacketInfo;\n\n    CParaNdisRX*                   Queue;\n};\n\ntypedef struct _tagPARANDIS_RECEIVE_QUEUE\n{\n    NDIS_SPIN_LOCK          Lock;\n    LIST_ENTRY              BuffersList;\n\n    LONG                    ActiveProcessorsCount;\n} PARANDIS_RECEIVE_QUEUE, *PPARANDIS_RECEIVE_QUEUE;\n\ntypedef struct _tagPARANDIS_ADAPTER\n{\n    NDIS_HANDLE             DriverHandle;\n    NDIS_HANDLE             MiniportHandle;\n    NDIS_HANDLE             InterruptHandle;\n    NDIS_HANDLE             BufferListsPool;\n    NDIS_EVENT              ResetEvent;\n    tAdapterResources       AdapterResources;\n    PVOID                   pIoPortOffset;\n    VirtIODevice            *IODevice;\n    LARGE_INTEGER           LastTxCompletionTimeStamp;\n#ifdef PARANDIS_DEBUG_INTERRUPTS\n    LARGE_INTEGER           LastInterruptTimeStamp;\n#endif\n    u32                     u32HostFeatures;\n    u32                     u32GuestFeatures;\n    BOOLEAN                 bConnected;\n    NDIS_MEDIA_CONNECT_STATE fCurrentLinkState;\n    BOOLEAN                 bEnableInterruptHandlingDPC;\n    BOOLEAN                 bEnableInterruptChecking;\n    BOOLEAN                 bDoSupportPriority;\n    BOOLEAN                 bLinkDetectSupported;\n    BOOLEAN                 bGuestChecksumSupported;\n    BOOLEAN                 bUseMergedBuffers;\n    BOOLEAN                 bDoPublishIndices;\n    BOOLEAN                 bSurprizeRemoved;\n    BOOLEAN                 bUsingMSIX;\n    BOOLEAN                 bUseIndirect;\n    BOOLEAN                 bAnyLaypout;\n    BOOLEAN                 bHasHardwareFilters;\n    BOOLEAN                 bNoPauseOnSuspend;\n    BOOLEAN                 bFastSuspendInProcess;\n    BOOLEAN                 bResetInProgress;\n    BOOLEAN                 bCtrlMACAddrSupported;\n    BOOLEAN                 bCfgMACAddrSupported;\n    BOOLEAN                 bMultiQueue;\n    USHORT                  nHardwareQueues;\n    ULONG                   ulCurrentVlansFilterSet;\n    tMulticastData          MulticastData;\n    UINT                    uNumberOfHandledRXPacketsInDPC;\n    NDIS_DEVICE_POWER_STATE powerState;\n    LONG                    nPendingDPCs;\n    LONG                    counterDPCInside;\n    LONG                    bDPCInactive;\n    ULONG                   ulPriorityVlanSetting;\n    ULONG                   VlanId;\n    ULONGLONG               ulFormalLinkSpeed;\n    ULONG                   ulEnableWakeup;\n    tMaxPacketSize          MaxPacketSize;\n    ULONG                   ulUniqueID;\n    UCHAR                   PermanentMacAddress[ETH_LENGTH_OF_ADDRESS];\n    UCHAR                   CurrentMacAddress[ETH_LENGTH_OF_ADDRESS];\n    ULONG                   PacketFilter;\n    ULONG                   DummyLookAhead;\n    ULONG                   nDetectedStoppedTx;\n    ULONG                   nDetectedInactivity;\n    ULONG                   nVirtioHeaderSize;\n    /* send part */\n    NDIS_STATISTICS_INFO    Statistics;\n    struct\n    {\n        ULONG framesCSOffload;\n        ULONG framesLSO;\n        ULONG framesIndirect;\n        ULONG framesRxPriority;\n        ULONG framesRxCSHwOK;\n        ULONG framesRxCSHwMissedBad;\n        ULONG framesRxCSHwMissedGood;\n        ULONG framesFilteredOut;\n    } extraStatistics;\n    tOurCounters            Counters;\n    tOurCounters            Limits;\n    tSendReceiveState       SendState;\n    tSendReceiveState       ReceiveState;\n    ONPAUSECOMPLETEPROC     SendPauseCompletionProc;\n    ONPAUSECOMPLETEPROC     ReceivePauseCompletionProc;\n\n    CNdisRWLock             m_PauseLock;\n    CNdisRefCounter         m_upstreamPacketPending;\n\n    LONG                    ReuseBufferRegular;\n    /* initial number of free Tx descriptor(from cfg) - max number of available Tx descriptors */\n    UINT                    maxFreeTxDescriptors;\n    /* total of Rx buffer in turnaround */\n    UINT                    NetMaxReceiveBuffers;\n    UINT                    nPnpEventIndex;\n    NDIS_DEVICE_PNP_EVENT   PnpEvents[16];\n    tOffloadSettings        Offload;\n    NDIS_OFFLOAD_PARAMETERS InitialOffloadParameters;\n\n    PARANDIS_RECEIVE_QUEUE      ReceiveQueues[PARANDIS_RSS_MAX_RECEIVE_QUEUES + 1];\n    BOOLEAN                     ReceiveQueuesInitialized;\n#define PARANDIS_RECEIVE_QUEUE_UNCLASSIFIED (0)\n#define PARANDIS_FIRST_RSS_RECEIVE_QUEUE    (1)\n\n    CParaNdisCX CXPath;\n    BOOLEAN bCXPathAllocated;\n    BOOLEAN bCXPathCreated;\n\n    CPUPathesBundle             *pPathBundles;\n    UINT                        nPathBundles;\n\n    CPUPathesBundle            **RSS2QueueMap;\n    USHORT                      RSS2QueueLength;\n\n    PIO_INTERRUPT_MESSAGE_INFO  pMSIXInfoTable;\n    NDIS_HANDLE                 DmaHandle;\n    ULONG                       ulIrqReceived;\n    NDIS_OFFLOAD                ReportedOffloadCapabilities;\n    NDIS_OFFLOAD                ReportedOffloadConfiguration;\n    BOOLEAN                     bOffloadv4Enabled;\n    BOOLEAN                     bOffloadv6Enabled;\n    BOOLEAN                     bDeviceInitialized;\n\n#if PARANDIS_SUPPORT_RSS\n    BOOLEAN                     bRSSOffloadSupported;\n    BOOLEAN                     bRSSInitialized;\n    NDIS_RECEIVE_SCALE_CAPABILITIES RSSCapabilities;\n    PARANDIS_RSS_PARAMS         RSSParameters;\n    CCHAR                       RSSMaxQueuesNumber;\n#endif\n\n#if PARANDIS_SUPPORT_RSC\n    struct {\n        BOOLEAN                     bIPv4SupportedSW;\n        BOOLEAN                     bIPv6SupportedSW;\n        BOOLEAN                     bIPv4SupportedHW;\n        BOOLEAN                     bIPv6SupportedHW;\n        BOOLEAN                     bIPv4Enabled;\n        BOOLEAN                     bIPv6Enabled;\n        BOOLEAN                     bHasDynamicConfig;\n        struct {\n            LARGE_INTEGER           CoalescedPkts;\n            LARGE_INTEGER           CoalescedOctets;\n            LARGE_INTEGER           CoalesceEvents;\n        }                           Statistics;\n    } RSC;\n#endif\n\n    _tagPARANDIS_ADAPTER(const _tagPARANDIS_ADAPTER&) = delete;\n    _tagPARANDIS_ADAPTER& operator= (const _tagPARANDIS_ADAPTER&) = delete;\n}PARANDIS_ADAPTER, *PPARANDIS_ADAPTER;\n\ntypedef struct _tagSynchronizedContext\n{\n    PARANDIS_ADAPTER    *pContext;\n    PVOID               Parameter;\n}tSynchronizedContext;\n\ntypedef BOOLEAN _Function_class_(MINIPORT_SYNCHRONIZE_INTERRUPT) (*tSynchronizedProcedure)(tSynchronizedContext *context);\n\nBOOLEAN FORCEINLINE IsValidVlanId(PARANDIS_ADAPTER *pContext, ULONG VlanID)\n{\n    return pContext->VlanId == 0 || pContext->VlanId == VlanID;\n}\n\nBOOLEAN FORCEINLINE IsVlanSupported(PARANDIS_ADAPTER *pContext)\n{\n    return pContext->ulPriorityVlanSetting & 2;\n}\n\nBOOLEAN FORCEINLINE IsPrioritySupported(PARANDIS_ADAPTER *pContext)\n{\n    return pContext->ulPriorityVlanSetting & 1;\n}\n\nBOOLEAN ParaNdis_ValidateMacAddress(\n    PUCHAR pcMacAddress,\n    BOOLEAN bLocal);\n\nNDIS_STATUS ParaNdis_InitializeContext(\n    PARANDIS_ADAPTER *pContext,\n    PNDIS_RESOURCE_LIST ResourceList);\n\nNDIS_STATUS ParaNdis_FinishInitialization(\n    PARANDIS_ADAPTER *pContext);\n\nNDIS_STATUS ParaNdis_ConfigureMSIXVectors(\n    PARANDIS_ADAPTER *pContext);\n\nVOID ParaNdis_CleanupContext(\n    PARANDIS_ADAPTER *pContext);\n\nbool ParaNdis_DPCWorkBody(\n    PARANDIS_ADAPTER *pContext,\n    ULONG ulMaxPacketsToIndicate);\n\nVOID ParaNdis_ResetRxClassification(\n    PARANDIS_ADAPTER *pContext);\n\nNDIS_STATUS ParaNdis_SetMulticastList(\n    PARANDIS_ADAPTER *pContext,\n    PVOID Buffer,\n    ULONG BufferSize,\n    PUINT pBytesRead,\n    PUINT pBytesNeeded);\n\nVOID ParaNdis_VirtIOEnableIrqSynchronized(\n    PARANDIS_ADAPTER *pContext,\n    ULONG interruptSource);\n\nVOID ParaNdis_VirtIODisableIrqSynchronized(\n    PARANDIS_ADAPTER *pContext,\n    ULONG interruptSource);\n\nvoid ParaNdis_DeleteQueue(\n    PARANDIS_ADAPTER *pContext, \n    struct virtqueue **ppq,\n    tCompletePhysicalAddress *ppa);\n\nvoid ParaNdis_FreeRxBufferDescriptor(\n    PARANDIS_ADAPTER *pContext,\n    pRxNetDescriptor p);\n\nBOOLEAN ParaNdis_PerformPacketAnalyzis(\n#if PARANDIS_SUPPORT_RSS\n    PPARANDIS_RSS_PARAMS RSSParameters,\n#endif\n    PNET_PACKET_INFO PacketInfo,\n    PVOID HeadersBuffer,\n    ULONG DataLength);\n\nCCHAR ParaNdis_GetScalingDataForPacket(\n    PARANDIS_ADAPTER *pContext,\n    PNET_PACKET_INFO pPacketInfo,\n    PPROCESSOR_NUMBER pTargetProcessor);\n\n#if PARANDIS_SUPPORT_RSS\nNDIS_STATUS ParaNdis_SetupRSSQueueMap(PARANDIS_ADAPTER *pContext);\n#endif\n\nVOID ParaNdis_ReceiveQueueAddBuffer(\n    PPARANDIS_RECEIVE_QUEUE pQueue,\n    pRxNetDescriptor pBuffer);\n\nVOID ParaMdis_TestPausing(\n    PARANDIS_ADAPTER *pContext);\n\nVOID ParaNdis_ProcessorNumberToGroupAffinity(\n    PGROUP_AFFINITY Affinity,\n    const PPROCESSOR_NUMBER Processor);\n\nVOID ParaNdis_QueueRSSDpc(\n    PARANDIS_ADAPTER *pContext,\n    PGROUP_AFFINITY pTargetAffinity);\n\n\n\n\n\n\nstatic __inline BOOLEAN\nParaNDIS_IsQueueInterruptEnabled(struct virtqueue * _vq)\n{\n    return virtqueue_is_interrupt_enabled(_vq);\n}\n\n\nvoid ParaNdis_FreeRxBufferDescriptor(\n    PARANDIS_ADAPTER *pContext,\n    pRxNetDescriptor p);\n\nBOOLEAN ParaNdis_PerformPacketAnalyzis(\n#if PARANDIS_SUPPORT_RSS\n    PPARANDIS_RSS_PARAMS RSSParameters,\n#endif\n    PNET_PACKET_INFO PacketInfo,\n    PVOID HeadersBuffer,\n    ULONG DataLength);\n\nCCHAR ParaNdis_GetScalingDataForPacket(\n    PARANDIS_ADAPTER *pContext,\n    PNET_PACKET_INFO pPacketInfo,\n    PPROCESSOR_NUMBER pTargetProcessor);\n\nVOID ParaNdis_ReceiveQueueAddBuffer(\n    PPARANDIS_RECEIVE_QUEUE pQueue,\n    pRxNetDescriptor pBuffer);\n\nVOID ParaNdis_ProcessorNumberToGroupAffinity(\n    PGROUP_AFFINITY Affinity,\n    const PPROCESSOR_NUMBER Processor);\n\nVOID ParaNdis_QueueRSSDpc(\n    PARANDIS_ADAPTER *pContext,\n    ULONG MessageIndex,\n    PGROUP_AFFINITY pTargetAffinity);\n\nVOID ParaNdis_OnPnPEvent(\n    PARANDIS_ADAPTER *pContext,\n    NDIS_DEVICE_PNP_EVENT pEvent,\n    PVOID   pInfo,\n    ULONG   ulSize);\n\nBOOLEAN ParaNdis_OnLegacyInterrupt(\n    PARANDIS_ADAPTER *pContext,\n    BOOLEAN *pRunDpc);\n\nBOOLEAN ParaNdis_OnQueuedInterrupt(\n    PARANDIS_ADAPTER *pContext,\n    BOOLEAN *pRunDpc,\n    ULONG knownInterruptSources);\n\nVOID ParaNdis_OnShutdown(\n    PARANDIS_ADAPTER *pContext);\n\nBOOLEAN ParaNdis_CheckForHang(\n    PARANDIS_ADAPTER *pContext);\n\nVOID ParaNdis_PowerOn(\n    PARANDIS_ADAPTER *pContext\n);\n\nVOID ParaNdis_PowerOff(\n    PARANDIS_ADAPTER *pContext\n);\n\n#if PARANDIS_SUPPORT_RSC\nVOID ParaNdis_UpdateGuestOffloads(\n    PARANDIS_ADAPTER *pContext,\n    UINT64 Offloads\n);\n#endif\n\nvoid ParaNdis_DebugInitialize();\nvoid ParaNdis_DebugCleanup(PDRIVER_OBJECT  pDriverObject);\nvoid ParaNdis_DebugRegisterMiniport(PARANDIS_ADAPTER *pContext, BOOLEAN bRegister);\n\n\n//#define ENABLE_HISTORY_LOG\n#if !defined(ENABLE_HISTORY_LOG)\n\nvoid FORCEINLINE ParaNdis_DebugHistory(\n    PARANDIS_ADAPTER *pContext,\n    eHistoryLogOperation op,\n    PVOID pParam1,\n    ULONG lParam2,\n    ULONG lParam3,\n    ULONG lParam4)\n{\n    UNREFERENCED_PARAMETER(pContext);\n    UNREFERENCED_PARAMETER(op);\n    UNREFERENCED_PARAMETER(pParam1);\n    UNREFERENCED_PARAMETER(lParam2);\n    UNREFERENCED_PARAMETER(lParam3);\n    UNREFERENCED_PARAMETER(lParam4);\n}\n\n#else\n\nvoid ParaNdis_DebugHistory(\n    PARANDIS_ADAPTER *pContext,\n    eHistoryLogOperation op,\n    PVOID pParam1,\n    ULONG lParam2,\n    ULONG lParam3,\n    ULONG lParam4);\n\n#endif\n\nvoid ParaNdis_ResetOffloadSettings(PARANDIS_ADAPTER *pContext, tOffloadSettingsFlags *pDest, PULONG from);\n\ntChecksumCheckResult ParaNdis_CheckRxChecksum(\n                                            PARANDIS_ADAPTER *pContext,\n                                            ULONG virtioFlags,\n                                            tCompletePhysicalAddress *pPacketPages,\n                                            ULONG ulPacketLength,\n                                            ULONG ulDataOffset,\n                                            BOOLEAN verifyLength);\n\nvoid ParaNdis_CallOnBugCheck(PARANDIS_ADAPTER *pContext);\n\n/*****************************************************\nProcedures to implement for NDIS specific implementation\n******************************************************/\n\nPVOID ParaNdis_AllocateMemory(\n    PARANDIS_ADAPTER *pContext,\n    ULONG ulRequiredSize);\n\nPVOID ParaNdis_AllocateMemoryRaw(\n    NDIS_HANDLE MiniportHandle,\n    ULONG ulRequiredSize);\n\nNDIS_STATUS ParaNdis_FinishSpecificInitialization(\n    PARANDIS_ADAPTER *pContext);\n\nVOID ParaNdis_FinalizeCleanup(\n    PARANDIS_ADAPTER *pContext);\n\nNDIS_HANDLE ParaNdis_OpenNICConfiguration(\n    PARANDIS_ADAPTER *pContext);\n\ntPacketIndicationType ParaNdis_PrepareReceivedPacket(\n    PARANDIS_ADAPTER *pContext,\n    pRxNetDescriptor pBufferDesc,\n    PUINT            pnCoalescedSegmentsCount);\n\nBOOLEAN ParaNdis_SynchronizeWithInterrupt(\n    PARANDIS_ADAPTER *pContext,\n    ULONG messageId,\n    tSynchronizedProcedure procedure,\n    PVOID parameter);\n\nVOID ParaNdis_Suspend(\n    PARANDIS_ADAPTER *pContext);\n\nVOID ParaNdis_Resume(\n    PARANDIS_ADAPTER *pContext);\n\ntypedef VOID (*tOnAdditionalPhysicalMemoryAllocated)(\n    PARANDIS_ADAPTER *pContext,\n    tCompletePhysicalAddress *pAddresses);\n\n\ntypedef struct _tagPhysicalAddressAllocationContext\n{\n    tCompletePhysicalAddress address;\n    PARANDIS_ADAPTER *pContext;\n    tOnAdditionalPhysicalMemoryAllocated Callback;\n} tPhysicalAddressAllocationContext;\n\n\nBOOLEAN ParaNdis_InitialAllocatePhysicalMemory(\n    PARANDIS_ADAPTER *pContext,\n    tCompletePhysicalAddress *pAddresses);\n\nBOOLEAN ParaNdis_RuntimeRequestToAllocatePhysicalMemory(\n    PARANDIS_ADAPTER *pContext,\n    tCompletePhysicalAddress *pAddresses,\n    tOnAdditionalPhysicalMemoryAllocated Callback\n    );\n\nVOID ParaNdis_FreePhysicalMemory(\n    PARANDIS_ADAPTER *pContext,\n    tCompletePhysicalAddress *pAddresses);\n\nBOOLEAN ParaNdis_BindRxBufferToPacket(\n    PARANDIS_ADAPTER *pContext,\n    pRxNetDescriptor p);\n\nvoid ParaNdis_UnbindRxBufferFromPacket(\n    pRxNetDescriptor p);\n\nvoid ParaNdis_RestoreDeviceConfigurationAfterReset(\n    PARANDIS_ADAPTER *pContext);\n\nVOID ParaNdis_UpdateDeviceFilters(\n    PARANDIS_ADAPTER *pContext);\n\nVOID ParaNdis_DeviceFiltersUpdateVlanId(\n    PARANDIS_ADAPTER *pContext);\n\nVOID ParaNdis_SetPowerState(\n    PARANDIS_ADAPTER *pContext,\n    NDIS_DEVICE_POWER_STATE newState);\n\nVOID ParaNdis_SynchronizeLinkState(\n    PARANDIS_ADAPTER *pContext);\n\nVOID ParaNdis_SetLinkState(\n    PARANDIS_ADAPTER *pContext,\n    NDIS_MEDIA_CONNECT_STATE LinkState);\n\n#endif //-OFFLOAD_UNIT_TEST\n\ntypedef enum _tagppResult\n{\n    ppresNotTested = 0,\n    ppresNotIP     = 1,\n    ppresIPV4      = 2,\n    ppresIPV6      = 3,\n    ppresIPTooShort  = 1,\n    ppresPCSOK       = 1,\n    ppresCSOK        = 2,\n    ppresCSBad       = 3,\n    ppresXxpOther    = 1,\n    ppresXxpKnown    = 2,\n    ppresXxpIncomplete = 3,\n    ppresIsTCP         = 0,\n    ppresIsUDP         = 1,\n}ppResult;\n\n#pragma warning (push)\n#pragma warning (disable:4201) //nonstandard extension used : nameless struct/union\n#pragma warning (disable:4214) //nonstandard extension used : bit field types other than int\ntypedef union _tagTcpIpPacketParsingResult\n{\n    struct {\n        /* 0 - not tested, 1 - not IP, 2 - IPV4, 3 - IPV6 */\n        ULONG ipStatus        : 2;\n        /* 0 - not tested, 1 - n/a, 2 - CS, 3 - bad */\n        ULONG ipCheckSum      : 2;\n        /* 0 - not tested, 1 - PCS, 2 - CS, 3 - bad */\n        ULONG xxpCheckSum     : 2;\n        /* 0 - not tested, 1 - other, 2 - known(contains basic TCP or UDP header), 3 - known incomplete */\n        ULONG xxpStatus       : 2;\n        /* 1 - contains complete payload */\n        ULONG xxpFull         : 1;\n        ULONG TcpUdp          : 1;\n        ULONG fixedIpCS       : 1;\n        ULONG fixedXxpCS      : 1;\n        ULONG IsFragment      : 1;\n        ULONG reserved        : 3;\n        ULONG ipHeaderSize    : 8;\n        ULONG XxpIpHeaderSize : 8;\n    };\n    ULONG value;\n}tTcpIpPacketParsingResult;\n#pragma warning(pop)\n\ntypedef enum _tagPacketOffloadRequest\n{\n    pcrIpChecksum  = (1 << 0),\n    pcrTcpV4Checksum = (1 << 1),\n    pcrUdpV4Checksum = (1 << 2),\n    pcrTcpV6Checksum = (1 << 3),\n    pcrUdpV6Checksum = (1 << 4),\n    pcrTcpChecksum = (pcrTcpV4Checksum | pcrTcpV6Checksum),\n    pcrUdpChecksum = (pcrUdpV4Checksum | pcrUdpV6Checksum),\n    pcrAnyChecksum = (pcrIpChecksum | pcrTcpV4Checksum | pcrUdpV4Checksum | pcrTcpV6Checksum | pcrUdpV6Checksum),\n    pcrLSO   = (1 << 5),\n    pcrIsIP  = (1 << 6),\n    pcrFixIPChecksum = (1 << 7),\n    pcrFixPHChecksum = (1 << 8),\n    pcrFixTcpV4Checksum = (1 << 9),\n    pcrFixUdpV4Checksum = (1 << 10),\n    pcrFixTcpV6Checksum = (1 << 11),\n    pcrFixUdpV6Checksum = (1 << 12),\n    pcrFixXxpChecksum = (pcrFixTcpV4Checksum | pcrFixUdpV4Checksum | pcrFixTcpV6Checksum | pcrFixUdpV6Checksum),\n    pcrPriorityTag = (1 << 13),\n    pcrNoIndirect  = (1 << 14)\n}tPacketOffloadRequest;\n\n// sw offload\n\ntTcpIpPacketParsingResult ParaNdis_CheckSumVerify(\n                                                tCompletePhysicalAddress *pDataPages,\n                                                ULONG ulDataLength,\n                                                ULONG ulStartOffset,\n                                                ULONG flags,\n                                                BOOLEAN verifyLength,\n                                                LPCSTR caller);\n\nstatic __inline\ntTcpIpPacketParsingResult ParaNdis_CheckSumVerifyFlat(\n                                                PVOID pBuffer,\n                                                ULONG ulDataLength,\n                                                ULONG flags,\n                                                BOOLEAN verifyLength,\n                                                LPCSTR caller)\n{\n    tCompletePhysicalAddress SGBuffer;\n    SGBuffer.Virtual = pBuffer;\n    SGBuffer.size = ulDataLength;\n    return ParaNdis_CheckSumVerify(&SGBuffer, ulDataLength, 0, flags, verifyLength, caller);\n}\n\ntTcpIpPacketParsingResult ParaNdis_ReviewIPPacket(PVOID buffer, ULONG size, BOOLEAN verityLength, LPCSTR caller);\n\nBOOLEAN ParaNdis_AnalyzeReceivedPacket(PVOID headersBuffer, ULONG dataLength, PNET_PACKET_INFO packetInfo);\nULONG ParaNdis_StripVlanHeaderMoveHead(PNET_PACKET_INFO packetInfo);\nVOID ParaNdis_PadPacketToMinimalLength(PNET_PACKET_INFO packetInfo);\nBOOLEAN ParaNdis_IsSendPossible(PARANDIS_ADAPTER *pContext);\nNDIS_STATUS ParaNdis_ExactSendFailureStatus(PARANDIS_ADAPTER *pContext);\n\n#endif\n", "/**********************************************************************\n * Copyright (c) 2008  Red Hat, Inc.\n *\n * File: sw-offload.c\n *\n * This file contains SW Implementation of checksum computation for IP,TCP,UDP\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n**********************************************************************/\n#include \"ndis56common.h\"\n\n// till IP header size is 8 bit\n#define MAX_SUPPORTED_IPV6_HEADERS  (256 - 4)\n\n// IPv6 Header RFC 2460 (n*8 bytes)\ntypedef struct _tagIPv6ExtHeader {\n    UCHAR       ip6ext_next_header;     // next header type\n    UCHAR       ip6ext_hdr_len;         // length of this header in 8 bytes unit, not including first 8 bytes\n    USHORT      options;                // \n} IPv6ExtHeader;\n\n// IP Pseudo Header RFC 768\ntypedef struct _tagIPv4PseudoHeader {\n    ULONG       ipph_src;               // Source address\n    ULONG       ipph_dest;              // Destination address\n    UCHAR       ipph_zero;              // 0\n    UCHAR       ipph_protocol;          // TCP/UDP\n    USHORT      ipph_length;            // TCP/UDP length\n}tIPv4PseudoHeader;\n\n// IPv6 Pseudo Header RFC 2460\ntypedef struct _tagIPv6PseudoHeader {\n    IPV6_ADDRESS ipph_src;              // Source address\n    IPV6_ADDRESS ipph_dest;             // Destination address\n    ULONG        ipph_length;               // TCP/UDP length\n    UCHAR        z1;                // 0\n    UCHAR        z2;                // 0\n    UCHAR        z3;                // 0\n    UCHAR        ipph_protocol;             // TCP/UDP\n}tIPv6PseudoHeader;\n\n// IP v6 extension header option\ntypedef struct _tagIP6_EXT_HDR_OPTION\n{\n    UCHAR Type;\n    UCHAR Length;\n} IP6_EXT_HDR_OPTION, *PIP6_EXT_HDR_OPTION;\n\n#define IP6_EXT_HDR_OPTION_PAD1         (0)\n#define IP6_EXT_HDR_OPTION_HOME_ADDR    (201)\n\n// IP v6 routing header\ntypedef struct _tagIP6_TYPE2_ROUTING_HEADER\n{\n    UCHAR           NextHdr;\n    UCHAR           HdrLen;\n    UCHAR           RoutingType;\n    UCHAR           SegmentsLeft;\n    ULONG           Reserved;\n    IPV6_ADDRESS    Address;\n} IP6_TYPE2_ROUTING_HEADER, *PIP6_TYPE2_ROUTING_HEADER;\n\n#define PROTOCOL_TCP                    6\n#define PROTOCOL_UDP                    17\n\n#define IP_HEADER_LENGTH(pHeader)       (((pHeader)->ip_verlen & 0x0F) << 2)\n#define IP_HEADER_VERSION(pHeader)      (((pHeader)->ip_verlen & 0xF0) >> 4)\n#define IP_HEADER_IS_FRAGMENT(pHeader)  (((pHeader)->ip_offset & ~0xC0) != 0)\n\n#define IP6_HEADER_VERSION(pHeader)     (((pHeader)->ip6_ver_tc & 0xF0) >> 4)\n\n#define ETH_GET_VLAN_HDR(ethHdr)        ((PVLAN_HEADER) RtlOffsetToPointer(ethHdr, ETH_PRIORITY_HEADER_OFFSET))\n#define VLAN_GET_USER_PRIORITY(vlanHdr) ( (((PUCHAR)(vlanHdr))[2] & 0xE0) >> 5 )\n#define VLAN_GET_VLAN_ID(vlanHdr)       ( ((USHORT) (((PUCHAR)(vlanHdr))[2] & 0x0F) << 8) | ( ((PUCHAR)(vlanHdr))[3] ) )\n\n#define ETH_PROTO_IP4 (0x0800)\n#define ETH_PROTO_IP6 (0x86DD)\n\n#define IP6_HDR_HOP_BY_HOP        (0)\n#define IP6_HDR_ROUTING           (43)\n#define IP6_HDR_FRAGMENT          (44)\n#define IP6_HDR_ESP               (50)\n#define IP6_HDR_AUTHENTICATION    (51)\n#define IP6_HDR_NONE              (59)\n#define IP6_HDR_DESTINATON        (60)\n#define IP6_HDR_MOBILITY          (135)\n\n#define IP6_EXT_HDR_GRANULARITY   (8)\n\nstatic UINT32 RawCheckSumCalculator(PVOID buffer, ULONG len)\n{\n    UINT32 val = 0;\n    PUSHORT pus = (PUSHORT)buffer;\n    ULONG count = len >> 1;\n    while (count--) val += *pus++;\n    if (len & 1) val += (USHORT)*(PUCHAR)pus;\n    return val;\n}\n\nstatic __inline USHORT RawCheckSumFinalize(UINT32 val)\n{\n    val = (((val >> 16) | (val << 16)) + val) >> 16;\n    return (USHORT)~val;\n}\n\nstatic __inline USHORT CheckSumCalculatorFlat(PVOID buffer, ULONG len)\n{\n    return RawCheckSumFinalize(RawCheckSumCalculator(buffer, len));\n}\n\nstatic __inline USHORT CheckSumCalculator(tCompletePhysicalAddress *pDataPages, ULONG ulStartOffset, ULONG len)\n{\n    tCompletePhysicalAddress *pCurrentPage = &pDataPages[0];\n    ULONG ulCurrPageOffset = 0;\n    UINT32 u32RawCSum = 0;\n\n    while(ulStartOffset > 0)\n    {\n        ulCurrPageOffset = min(pCurrentPage->size, ulStartOffset);\n\n        if(ulCurrPageOffset < ulStartOffset)\n            pCurrentPage++;\n\n        ulStartOffset -= ulCurrPageOffset;\n    }\n\n    while(len > 0)\n    {\n        PVOID pCurrentPageDataStart = RtlOffsetToPointer(pCurrentPage->Virtual, ulCurrPageOffset);\n        ULONG ulCurrentPageDataLength = min(len, pCurrentPage->size - ulCurrPageOffset);\n\n        u32RawCSum += RawCheckSumCalculator(pCurrentPageDataStart, ulCurrentPageDataLength);\n        pCurrentPage++;\n        ulCurrPageOffset = 0;\n        len -= ulCurrentPageDataLength;\n    }\n\n    return RawCheckSumFinalize(u32RawCSum);\n}\n\n\n/******************************************\n    IP header checksum calculator\n*******************************************/\nstatic __inline VOID CalculateIpChecksum(IPv4Header *pIpHeader)\n{\n    pIpHeader->ip_xsum = 0;\n    pIpHeader->ip_xsum = CheckSumCalculatorFlat(pIpHeader, IP_HEADER_LENGTH(pIpHeader));\n}\n\nstatic __inline tTcpIpPacketParsingResult\nProcessTCPHeader(tTcpIpPacketParsingResult _res, PVOID pIpHeader, ULONG len, USHORT ipHeaderSize)\n{\n    ULONG tcpipDataAt;\n    tTcpIpPacketParsingResult res = _res;\n    tcpipDataAt = ipHeaderSize + sizeof(TCPHeader);\n    res.TcpUdp = ppresIsTCP;\n\n    if (len >= tcpipDataAt)\n    {\n        TCPHeader *pTcpHeader = (TCPHeader *)RtlOffsetToPointer(pIpHeader, ipHeaderSize);\n        res.xxpStatus = ppresXxpKnown;\n        res.xxpFull = TRUE;\n        tcpipDataAt = ipHeaderSize + TCP_HEADER_LENGTH(pTcpHeader);\n        res.XxpIpHeaderSize = tcpipDataAt;\n    }\n    else\n    {\n        DPrintf(2, (\"tcp: %d < min headers %d\\n\", len, tcpipDataAt));\n        res.xxpFull = FALSE;\n        res.xxpStatus = ppresXxpIncomplete;\n    }\n    return res;\n}\n\nstatic __inline tTcpIpPacketParsingResult\nProcessUDPHeader(tTcpIpPacketParsingResult _res, PVOID pIpHeader, ULONG len, USHORT ipHeaderSize)\n{\n    tTcpIpPacketParsingResult res = _res;\n    ULONG udpDataStart = ipHeaderSize + sizeof(UDPHeader);\n    res.TcpUdp = ppresIsUDP;\n    res.XxpIpHeaderSize = udpDataStart;\n    if (len >= udpDataStart)\n    {\n        UDPHeader *pUdpHeader = (UDPHeader *)RtlOffsetToPointer(pIpHeader, ipHeaderSize);\n        USHORT datagramLength = swap_short(pUdpHeader->udp_length);\n        res.xxpStatus = ppresXxpKnown;\n        res.xxpFull = TRUE;\n        // may be full or not, but the datagram length is known\n        DPrintf(2, (\"udp: len %d, datagramLength %d\\n\", len, datagramLength));\n    }\n    else\n    {\n        res.xxpFull = FALSE;\n        res.xxpStatus = ppresXxpIncomplete;\n    }\n    return res;\n}\n\nstatic __inline tTcpIpPacketParsingResult\nQualifyIpPacket(IPHeader *pIpHeader, ULONG len, BOOLEAN verifyLength)\n{\n    tTcpIpPacketParsingResult res;\n    res.value = 0;\n\n    if (len < 4)\n    {\n        res.ipStatus = ppresNotIP;\n        return res;\n    }\n\n    UCHAR  ver_len = pIpHeader->v4.ip_verlen;\n    UCHAR  ip_version = (ver_len & 0xF0) >> 4;\n    USHORT ipHeaderSize = 0;\n    USHORT fullLength = 0;\n    res.value = 0;\n\n    if (ip_version == 4)\n    {\n        if (len < sizeof(IPv4Header))\n        {\n            res.ipStatus = ppresNotIP;\n            return res;\n        }\n        ipHeaderSize = (ver_len & 0xF) << 2;\n        fullLength = swap_short(pIpHeader->v4.ip_length);\n        DPrintf(3, (\"ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d\\n\",\n            ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len));\n\n        res.ipStatus = (ipHeaderSize >= sizeof(IPv4Header)) ? ppresIPV4 : ppresNotIP;\n        if (res.ipStatus == ppresNotIP)\n        {\n            return res;\n        }\n\n        if (ipHeaderSize >= fullLength || ( verifyLength && len < fullLength))\n        {\n            DPrintf(2, (\"[%s] - truncated packet - ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d, verify = %s\\n\", __FUNCTION__,\n                ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len, (verifyLength ? \"true\" : \"false\")));\n            res.ipCheckSum = ppresIPTooShort;\n            return res;\n        }\n    }\n    else if (ip_version == 6)\n    {\n        if (len < sizeof(IPv6Header))\n        {\n            res.ipStatus = ppresNotIP;\n            return res;\n        }\n\n        UCHAR nextHeader = pIpHeader->v6.ip6_next_header;\n        BOOLEAN bParsingDone = FALSE;\n        ipHeaderSize = sizeof(pIpHeader->v6);\n        res.ipStatus = ppresIPV6;\n        res.ipCheckSum = ppresCSOK;\n        fullLength = swap_short(pIpHeader->v6.ip6_payload_len);\n        fullLength += ipHeaderSize;\n\n        if (verifyLength && (len < fullLength))\n        {\n            res.ipStatus = ppresNotIP;\n            return res;\n        }\n        while (nextHeader != 59)\n        {\n            IPv6ExtHeader *pExt;\n            switch (nextHeader)\n            {\n                case PROTOCOL_TCP:\n                    bParsingDone = TRUE;\n                    res.xxpStatus = ppresXxpKnown;\n                    res.TcpUdp = ppresIsTCP;\n                    res.xxpFull = len >= fullLength ? 1 : 0;\n                    res = ProcessTCPHeader(res, pIpHeader, len, ipHeaderSize);\n                    break;\n                case PROTOCOL_UDP:\n                    bParsingDone = TRUE;\n                    res.xxpStatus = ppresXxpKnown;\n                    res.TcpUdp = ppresIsUDP;\n                    res.xxpFull = len >= fullLength ? 1 : 0;\n                    res = ProcessUDPHeader(res, pIpHeader, len, ipHeaderSize);\n                    break;\n                    //existing extended headers\n                case 0:\n                case 60:\n                case 43:\n                case 44:\n                case 51:\n                case 50:\n                case 135:\n                    if (len >= ((ULONG)ipHeaderSize + 8))\n                    {\n                        pExt = (IPv6ExtHeader *)((PUCHAR)pIpHeader + ipHeaderSize);\n                        nextHeader = pExt->ip6ext_next_header;\n                        ipHeaderSize += 8;\n                        ipHeaderSize += pExt->ip6ext_hdr_len * 8;\n                    }\n                    else\n                    {\n                        DPrintf(0, (\"[%s] ERROR: Break in the middle of ext. headers(len %d, hdr > %d)\\n\", __FUNCTION__, len, ipHeaderSize));\n                        res.ipStatus = ppresNotIP;\n                        bParsingDone = TRUE;\n                    }\n                    break;\n                    //any other protocol\n                default:\n                    res.xxpStatus = ppresXxpOther;\n                    bParsingDone = TRUE;\n                    break;\n            }\n            if (bParsingDone)\n                break;\n        }\n        if (ipHeaderSize <= MAX_SUPPORTED_IPV6_HEADERS)\n        {\n            DPrintf(3, (\"ip_version %d, ipHeaderSize %d, protocol %d, iplen %d\\n\",\n                ip_version, ipHeaderSize, nextHeader, fullLength));\n            res.ipHeaderSize = ipHeaderSize;\n        }\n        else\n        {\n            DPrintf(0, (\"[%s] ERROR: IP chain is too large (%d)\\n\", __FUNCTION__, ipHeaderSize));\n            res.ipStatus = ppresNotIP;\n        }\n    }\n    \n    if (res.ipStatus == ppresIPV4)\n    {\n        res.ipHeaderSize = ipHeaderSize;\n\n        // bit \"more fragments\" or fragment offset mean the packet is fragmented\n        res.IsFragment = (pIpHeader->v4.ip_offset & ~0xC0) != 0;\n        switch (pIpHeader->v4.ip_protocol)\n        {\n            case PROTOCOL_TCP:\n            {\n                res = ProcessTCPHeader(res, pIpHeader, len, ipHeaderSize);\n            }\n            break;\n        case PROTOCOL_UDP:\n            {\n                res = ProcessUDPHeader(res, pIpHeader, len, ipHeaderSize);\n            }\n            break;\n        default:\n            res.xxpStatus = ppresXxpOther;\n            break;\n        }\n    }\n    return res;\n}\n\nstatic __inline USHORT GetXxpHeaderAndPayloadLen(IPHeader *pIpHeader, tTcpIpPacketParsingResult res)\n{\n    if (res.ipStatus == ppresIPV4)\n    {\n        USHORT headerLength = IP_HEADER_LENGTH(&pIpHeader->v4);\n        USHORT len = swap_short(pIpHeader->v4.ip_length);\n        return len - headerLength;          \n    }\n    if (res.ipStatus == ppresIPV6)\n    {\n        USHORT fullLength = swap_short(pIpHeader->v6.ip6_payload_len);\n        return fullLength + sizeof(pIpHeader->v6) - (USHORT)res.ipHeaderSize;\n    }\n    return 0;\n}\n\nstatic __inline USHORT CalculateIpv4PseudoHeaderChecksum(IPv4Header *pIpHeader, USHORT headerAndPayloadLen)\n{\n    tIPv4PseudoHeader ipph;\n    USHORT checksum;\n    ipph.ipph_src  = pIpHeader->ip_src;\n    ipph.ipph_dest = pIpHeader->ip_dest;\n    ipph.ipph_zero = 0;\n    ipph.ipph_protocol = pIpHeader->ip_protocol;\n    ipph.ipph_length = swap_short(headerAndPayloadLen);\n    checksum = CheckSumCalculatorFlat(&ipph, sizeof(ipph));\n    return ~checksum;\n}\n\n\nstatic __inline USHORT CalculateIpv6PseudoHeaderChecksum(IPv6Header *pIpHeader, USHORT headerAndPayloadLen)\n{\n    tIPv6PseudoHeader ipph;\n    USHORT checksum;\n    ipph.ipph_src[0]  = pIpHeader->ip6_src_address[0];\n    ipph.ipph_src[1]  = pIpHeader->ip6_src_address[1];\n    ipph.ipph_src[2]  = pIpHeader->ip6_src_address[2];\n    ipph.ipph_src[3]  = pIpHeader->ip6_src_address[3];\n    ipph.ipph_dest[0] = pIpHeader->ip6_dst_address[0];\n    ipph.ipph_dest[1] = pIpHeader->ip6_dst_address[1];\n    ipph.ipph_dest[2] = pIpHeader->ip6_dst_address[2];\n    ipph.ipph_dest[3] = pIpHeader->ip6_dst_address[3];\n    ipph.z1 = ipph.z2 = ipph.z3 = 0;\n    ipph.ipph_protocol = pIpHeader->ip6_next_header;\n    ipph.ipph_length = swap_short(headerAndPayloadLen);\n    checksum = CheckSumCalculatorFlat(&ipph, sizeof(ipph));\n    return ~checksum;\n}\n\nstatic __inline USHORT CalculateIpPseudoHeaderChecksum(IPHeader *pIpHeader,\n                                                       tTcpIpPacketParsingResult res,\n                                                       USHORT headerAndPayloadLen)\n{\n    if (res.ipStatus == ppresIPV4)\n        return CalculateIpv4PseudoHeaderChecksum(&pIpHeader->v4, headerAndPayloadLen);\n    if (res.ipStatus == ppresIPV6)\n        return CalculateIpv6PseudoHeaderChecksum(&pIpHeader->v6, headerAndPayloadLen);\n    return 0;\n}\n\nstatic __inline BOOLEAN\nCompareNetCheckSumOnEndSystem(USHORT computedChecksum, USHORT arrivedChecksum)\n{\n    //According to RFC 1624 sec. 3\n    //Checksum verification mechanism should treat 0xFFFF\n    //checksum value from received packet as 0x0000\n    if(arrivedChecksum == 0xFFFF)\n        arrivedChecksum = 0;\n\n    return computedChecksum == arrivedChecksum;\n}\n\n/******************************************\n  Calculates IP header checksum calculator\n  it can be already calculated\n  the header must be complete!\n*******************************************/\nstatic __inline tTcpIpPacketParsingResult\nVerifyIpChecksum(\n    IPv4Header *pIpHeader,\n    tTcpIpPacketParsingResult known,\n    BOOLEAN bFix)\n{\n    tTcpIpPacketParsingResult res = known;\n    if (res.ipCheckSum != ppresIPTooShort)\n    {\n        USHORT saved = pIpHeader->ip_xsum;\n        CalculateIpChecksum(pIpHeader);\n        res.ipCheckSum = CompareNetCheckSumOnEndSystem(pIpHeader->ip_xsum, saved) ? ppresCSOK : ppresCSBad;\n        if (!bFix)\n            pIpHeader->ip_xsum = saved;\n        else\n            res.fixedIpCS = res.ipCheckSum == ppresCSBad;\n    }\n    return res;\n}\n\n/*********************************************\nCalculates UDP checksum, assuming the checksum field\nis initialized with pseudoheader checksum\n**********************************************/\nstatic __inline VOID CalculateUdpChecksumGivenPseudoCS(UDPHeader *pUdpHeader, tCompletePhysicalAddress *pDataPages, ULONG ulStartOffset, ULONG udpLength)\n{\n    pUdpHeader->udp_xsum = CheckSumCalculator(pDataPages, ulStartOffset, udpLength);\n}\n\n/*********************************************\nCalculates TCP checksum, assuming the checksum field\nis initialized with pseudoheader checksum\n**********************************************/\nstatic __inline VOID CalculateTcpChecksumGivenPseudoCS(TCPHeader *pTcpHeader, tCompletePhysicalAddress *pDataPages, ULONG ulStartOffset, ULONG tcpLength)\n{\n    pTcpHeader->tcp_xsum = CheckSumCalculator(pDataPages, ulStartOffset, tcpLength);\n}\n\n/************************************************\nChecks (and fix if required) the TCP checksum\nsets flags in result structure according to verification\nTcpPseudoOK if valid pseudo CS was found\nTcpOK if valid TCP checksum was found\n************************************************/\nstatic __inline tTcpIpPacketParsingResult\nVerifyTcpChecksum(\n                tCompletePhysicalAddress *pDataPages,\n                ULONG ulDataLength,\n                ULONG ulStartOffset,\n                tTcpIpPacketParsingResult known,\n                ULONG whatToFix)\n{\n    USHORT  phcs;\n    tTcpIpPacketParsingResult res = known;\n    IPHeader *pIpHeader = (IPHeader *)RtlOffsetToPointer(pDataPages[0].Virtual, ulStartOffset);\n    TCPHeader *pTcpHeader = (TCPHeader *)RtlOffsetToPointer(pIpHeader, res.ipHeaderSize);\n    USHORT saved = pTcpHeader->tcp_xsum;\n    USHORT xxpHeaderAndPayloadLen = GetXxpHeaderAndPayloadLen(pIpHeader, res);\n    if (ulDataLength >= res.ipHeaderSize)\n    {\n        phcs = CalculateIpPseudoHeaderChecksum(pIpHeader, res, xxpHeaderAndPayloadLen);\n        res.xxpCheckSum = CompareNetCheckSumOnEndSystem(phcs, saved) ?  ppresPCSOK : ppresCSBad;\n        if (res.xxpCheckSum != ppresPCSOK || whatToFix)\n        {\n            if (whatToFix & pcrFixPHChecksum)\n            {\n                if (ulDataLength >= (ULONG)(res.ipHeaderSize + sizeof(*pTcpHeader)))\n                {\n                    pTcpHeader->tcp_xsum = phcs;\n                    res.fixedXxpCS = res.xxpCheckSum != ppresPCSOK;\n                }\n                else\n                    res.xxpStatus = ppresXxpIncomplete;\n            }\n            else if (res.xxpFull)\n            {\n                //USHORT ipFullLength = swap_short(pIpHeader->v4.ip_length);\n                pTcpHeader->tcp_xsum = phcs;\n                CalculateTcpChecksumGivenPseudoCS(pTcpHeader, pDataPages, ulStartOffset + res.ipHeaderSize, xxpHeaderAndPayloadLen);\n                if (CompareNetCheckSumOnEndSystem(pTcpHeader->tcp_xsum, saved))\n                    res.xxpCheckSum = ppresCSOK;\n\n                if (!(whatToFix & pcrFixXxpChecksum))\n                    pTcpHeader->tcp_xsum = saved;\n                else\n                    res.fixedXxpCS =\n                        res.xxpCheckSum == ppresCSBad || res.xxpCheckSum == ppresPCSOK;\n            }\n            else if (whatToFix)\n            {\n                res.xxpStatus = ppresXxpIncomplete;\n            }\n        }\n        else if (res.xxpFull)\n        {\n            // we have correct PHCS and we do not need to fix anything\n            // there is a very small chance that it is also good TCP CS\n            // in such rare case we give a priority to TCP CS\n            CalculateTcpChecksumGivenPseudoCS(pTcpHeader, pDataPages, ulStartOffset + res.ipHeaderSize, xxpHeaderAndPayloadLen);\n            if (CompareNetCheckSumOnEndSystem(pTcpHeader->tcp_xsum, saved))\n                res.xxpCheckSum = ppresCSOK;\n            pTcpHeader->tcp_xsum = saved;\n        }\n    }\n    else\n        res.ipCheckSum = ppresIPTooShort;\n    return res;\n}\n\n/************************************************\nChecks (and fix if required) the UDP checksum\nsets flags in result structure according to verification\nUdpPseudoOK if valid pseudo CS was found\nUdpOK if valid UDP checksum was found\n************************************************/\nstatic __inline tTcpIpPacketParsingResult\nVerifyUdpChecksum(\n                tCompletePhysicalAddress *pDataPages,\n                ULONG ulDataLength,\n                ULONG ulStartOffset,\n                tTcpIpPacketParsingResult known,\n                ULONG whatToFix)\n{\n    USHORT  phcs;\n    tTcpIpPacketParsingResult res = known;\n    IPHeader *pIpHeader = (IPHeader *)RtlOffsetToPointer(pDataPages[0].Virtual, ulStartOffset);\n    UDPHeader *pUdpHeader = (UDPHeader *)RtlOffsetToPointer(pIpHeader, res.ipHeaderSize);\n    USHORT saved = pUdpHeader->udp_xsum;\n    USHORT xxpHeaderAndPayloadLen = GetXxpHeaderAndPayloadLen(pIpHeader, res);\n    if (ulDataLength >= res.ipHeaderSize)\n    {\n        phcs = CalculateIpPseudoHeaderChecksum(pIpHeader, res, xxpHeaderAndPayloadLen);\n        res.xxpCheckSum = CompareNetCheckSumOnEndSystem(phcs, saved) ?  ppresPCSOK : ppresCSBad;\n        if (whatToFix & pcrFixPHChecksum)\n        {\n            if (ulDataLength >= (ULONG)(res.ipHeaderSize + sizeof(UDPHeader)))\n            {\n                pUdpHeader->udp_xsum = phcs;\n                res.fixedXxpCS = res.xxpCheckSum != ppresPCSOK;\n            }\n            else\n                res.xxpStatus = ppresXxpIncomplete;\n        }\n        else if (res.xxpCheckSum != ppresPCSOK || (whatToFix & pcrFixXxpChecksum))\n        {\n            if (res.xxpFull)\n            {\n                pUdpHeader->udp_xsum = phcs;\n                CalculateUdpChecksumGivenPseudoCS(pUdpHeader, pDataPages, ulStartOffset + res.ipHeaderSize, xxpHeaderAndPayloadLen);\n                if (CompareNetCheckSumOnEndSystem(pUdpHeader->udp_xsum, saved))\n                    res.xxpCheckSum = ppresCSOK;\n\n                if (!(whatToFix & pcrFixXxpChecksum))\n                    pUdpHeader->udp_xsum = saved;\n                else\n                    res.fixedXxpCS =\n                        res.xxpCheckSum == ppresCSBad || res.xxpCheckSum == ppresPCSOK;\n            }\n            else\n                res.xxpCheckSum = ppresXxpIncomplete;\n        }\n        else if (res.xxpFull)\n        {\n            // we have correct PHCS and we do not need to fix anything\n            // there is a very small chance that it is also good UDP CS\n            // in such rare case we give a priority to UDP CS\n            CalculateUdpChecksumGivenPseudoCS(pUdpHeader, pDataPages, ulStartOffset + res.ipHeaderSize, xxpHeaderAndPayloadLen);\n            if (CompareNetCheckSumOnEndSystem(pUdpHeader->udp_xsum, saved))\n                res.xxpCheckSum = ppresCSOK;\n            pUdpHeader->udp_xsum = saved;\n        }\n    }\n    else\n        res.ipCheckSum = ppresIPTooShort;\n\n    return res;\n}\n\nstatic LPCSTR __inline GetPacketCase(tTcpIpPacketParsingResult res)\n{\n    static const char *const IPCaseName[4] = { \"not tested\", \"Non-IP\", \"IPv4\", \"IPv6\" };\n    if (res.xxpStatus == ppresXxpKnown) return res.TcpUdp == ppresIsTCP ? \n        (res.ipStatus == ppresIPV4 ? \"TCPv4\" : \"TCPv6\") : \n        (res.ipStatus == ppresIPV4 ? \"UDPv4\" : \"UDPv6\");\n    if (res.xxpStatus == ppresXxpIncomplete) return res.TcpUdp == ppresIsTCP ? \"Incomplete TCP\" : \"Incomplete UDP\";\n    if (res.xxpStatus == ppresXxpOther) return \"IP\";\n    return  IPCaseName[res.ipStatus];\n}\n\nstatic LPCSTR __inline GetIPCSCase(tTcpIpPacketParsingResult res)\n{\n    static const char *const CSCaseName[4] = { \"not tested\", \"(too short)\", \"OK\", \"Bad\" };\n    return CSCaseName[res.ipCheckSum];\n}\n\nstatic LPCSTR __inline GetXxpCSCase(tTcpIpPacketParsingResult res)\n{\n    static const char *const CSCaseName[4] = { \"-\", \"PCS\", \"CS\", \"Bad\" };\n    return CSCaseName[res.xxpCheckSum];\n}\n\nstatic __inline VOID PrintOutParsingResult(\n    tTcpIpPacketParsingResult res,\n    int level,\n    LPCSTR procname)\n{\n    DPrintf(level, (\"[%s] %s packet IPCS %s%s, checksum %s%s\\n\", procname,\n        GetPacketCase(res),\n        GetIPCSCase(res),\n        res.fixedIpCS ? \"(fixed)\" : \"\",\n        GetXxpCSCase(res),\n        res.fixedXxpCS ? \"(fixed)\" : \"\"));\n}\n\ntTcpIpPacketParsingResult ParaNdis_CheckSumVerify(\n                                                tCompletePhysicalAddress *pDataPages,\n                                                ULONG ulDataLength,\n                                                ULONG ulStartOffset,\n                                                ULONG flags,\n                                                BOOLEAN verifyLength,\n                                                LPCSTR caller)\n{\n    IPHeader *pIpHeader = (IPHeader *) RtlOffsetToPointer(pDataPages[0].Virtual, ulStartOffset);\n\n    tTcpIpPacketParsingResult res = QualifyIpPacket(pIpHeader, ulDataLength, verifyLength);\n    if (res.ipStatus == ppresNotIP || res.ipCheckSum == ppresIPTooShort)\n        return res;\n\n    if (res.ipStatus == ppresIPV4)\n    {\n        if (flags & pcrIpChecksum)\n            res = VerifyIpChecksum(&pIpHeader->v4, res, (flags & pcrFixIPChecksum) != 0);\n        if(res.xxpStatus == ppresXxpKnown)\n        {\n            if (res.TcpUdp == ppresIsTCP) /* TCP */\n            {\n                if(flags & pcrTcpV4Checksum)\n                {\n                    res = VerifyTcpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixTcpV4Checksum));\n                }\n            }\n            else /* UDP */\n            {\n                if (flags & pcrUdpV4Checksum)\n                {\n                    res = VerifyUdpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixUdpV4Checksum));\n                }\n            }\n        }\n    }\n    else if (res.ipStatus == ppresIPV6)\n    {\n        if(res.xxpStatus == ppresXxpKnown)\n        {\n            if (res.TcpUdp == ppresIsTCP) /* TCP */\n            {\n                if(flags & pcrTcpV6Checksum)\n                {\n                    res = VerifyTcpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixTcpV6Checksum));\n                }\n            }\n            else /* UDP */\n            {\n                if (flags & pcrUdpV6Checksum)\n                {\n                    res = VerifyUdpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixUdpV6Checksum));\n                }\n            }\n        }\n    }\n    PrintOutParsingResult(res, 1, caller);\n    return res;\n}\n\ntTcpIpPacketParsingResult ParaNdis_ReviewIPPacket(PVOID buffer, ULONG size, BOOLEAN verifyLength, LPCSTR caller)\n{\n    tTcpIpPacketParsingResult res = QualifyIpPacket((IPHeader *) buffer, size, verifyLength);\n    PrintOutParsingResult(res, 1, caller);\n    return res;\n}\n\nstatic __inline\nVOID AnalyzeL3Proto(\n    USHORT L3Proto,\n    PNET_PACKET_INFO packetInfo)\n{\n    packetInfo->isIP4 = (L3Proto == RtlUshortByteSwap(ETH_PROTO_IP4));\n    packetInfo->isIP6 = (L3Proto == RtlUshortByteSwap(ETH_PROTO_IP6));\n}\n\nstatic\nBOOLEAN AnalyzeL2Hdr(\n    PNET_PACKET_INFO packetInfo)\n{\n    PETH_HEADER dataBuffer = (PETH_HEADER) packetInfo->headersBuffer;\n\n    if (packetInfo->dataLength < ETH_HEADER_SIZE)\n        return FALSE;\n\n    packetInfo->ethDestAddr = dataBuffer->DstAddr;\n\n    if (ETH_IS_BROADCAST(dataBuffer))\n    {\n        packetInfo->isBroadcast = TRUE;\n    }\n    else if (ETH_IS_MULTICAST(dataBuffer))\n    {\n        packetInfo->isMulticast = TRUE;\n    }\n    else\n    {\n        packetInfo->isUnicast = TRUE;\n    }\n\n    if(ETH_HAS_PRIO_HEADER(dataBuffer))\n    {\n        PVLAN_HEADER vlanHdr = ETH_GET_VLAN_HDR(dataBuffer);\n\n        if(packetInfo->dataLength < ETH_HEADER_SIZE + ETH_PRIORITY_HEADER_SIZE)\n            return FALSE;\n\n        packetInfo->hasVlanHeader     = TRUE;\n        packetInfo->Vlan.UserPriority = VLAN_GET_USER_PRIORITY(vlanHdr);\n        packetInfo->Vlan.VlanId       = VLAN_GET_VLAN_ID(vlanHdr);\n        packetInfo->L2HdrLen          = ETH_HEADER_SIZE + ETH_PRIORITY_HEADER_SIZE;\n        AnalyzeL3Proto(vlanHdr->EthType, packetInfo);\n    }\n    else\n    {\n        packetInfo->L2HdrLen = ETH_HEADER_SIZE;\n        AnalyzeL3Proto(dataBuffer->EthType, packetInfo);\n    }\n\n    packetInfo->L2PayloadLen = packetInfo->dataLength - packetInfo->L2HdrLen;\n\n    return TRUE;\n}\n\nstatic __inline\nBOOLEAN SkipIP6ExtensionHeader(\n    IPv6Header *ip6Hdr,\n    ULONG dataLength,\n    PULONG ip6HdrLength,\n    PUCHAR nextHdr)\n{\n    IPv6ExtHeader* ip6ExtHdr;\n\n    if (*ip6HdrLength + sizeof(*ip6ExtHdr) > dataLength)\n        return FALSE;\n\n    ip6ExtHdr = (IPv6ExtHeader *)RtlOffsetToPointer(ip6Hdr, *ip6HdrLength);\n    *nextHdr = ip6ExtHdr->ip6ext_next_header;\n    *ip6HdrLength += (ip6ExtHdr->ip6ext_hdr_len + 1) * IP6_EXT_HDR_GRANULARITY;\n    return TRUE;\n}\n\nstatic\nBOOLEAN AnalyzeIP6RoutingExtension(\n    PIP6_TYPE2_ROUTING_HEADER routingHdr,\n    ULONG dataLength,\n    IPV6_ADDRESS **destAddr)\n{\n    if(dataLength < sizeof(*routingHdr))\n        return FALSE;\n    if(routingHdr->RoutingType == 2)\n    {\n        if((dataLength != sizeof(*routingHdr)) || (routingHdr->SegmentsLeft != 1))\n            return FALSE;\n\n        *destAddr = &routingHdr->Address;\n    }\n    else *destAddr = NULL;\n\n    return TRUE;\n}\n\nstatic\nBOOLEAN AnalyzeIP6DestinationExtension(\n    PVOID destHdr,\n    ULONG dataLength,\n    IPV6_ADDRESS **homeAddr)\n{\n    while(dataLength != 0)\n    {\n        PIP6_EXT_HDR_OPTION optHdr = (PIP6_EXT_HDR_OPTION) destHdr;\n        ULONG optionLen;\n\n        switch(optHdr->Type)\n        {\n        case IP6_EXT_HDR_OPTION_HOME_ADDR:\n            if(dataLength < sizeof(IP6_EXT_HDR_OPTION))\n                return FALSE;\n\n            optionLen = optHdr->Length + sizeof(IP6_EXT_HDR_OPTION);\n            if(optHdr->Length != sizeof(IPV6_ADDRESS))\n                return FALSE;\n\n            *homeAddr = (IPV6_ADDRESS*) RtlOffsetToPointer(optHdr, sizeof(IP6_EXT_HDR_OPTION));\n            break;\n\n        case IP6_EXT_HDR_OPTION_PAD1:\n            optionLen = RTL_SIZEOF_THROUGH_FIELD(IP6_EXT_HDR_OPTION, Type);\n            break;\n\n        default:\n            if(dataLength < sizeof(IP6_EXT_HDR_OPTION))\n                return FALSE;\n\n            optionLen = optHdr->Length + sizeof(IP6_EXT_HDR_OPTION);\n            break;\n        }\n\n        destHdr = RtlOffsetToPointer(destHdr, optionLen);\n        if(dataLength < optionLen)\n            return FALSE;\n\n        dataLength -= optionLen;\n    }\n\n    return TRUE;\n}\n\nstatic\nBOOLEAN AnalyzeIP6Hdr(\n    IPv6Header *ip6Hdr,\n    ULONG dataLength,\n    PULONG ip6HdrLength,\n    PUCHAR nextHdr,\n    PULONG homeAddrOffset,\n    PULONG destAddrOffset)\n{\n    *homeAddrOffset = 0;\n    *destAddrOffset = 0;\n\n    *ip6HdrLength = sizeof(*ip6Hdr);\n    if(dataLength < *ip6HdrLength)\n        return FALSE;\n\n    *nextHdr = ip6Hdr->ip6_next_header;\n    for(;;)\n    {\n        switch (*nextHdr)\n        {\n        default:\n        case IP6_HDR_NONE:\n        case PROTOCOL_TCP:\n        case PROTOCOL_UDP:\n        case IP6_HDR_FRAGMENT:\n            return TRUE;\n        case IP6_HDR_DESTINATON:\n            {\n                IPV6_ADDRESS *homeAddr = NULL;\n                ULONG destHdrOffset = *ip6HdrLength;\n                if(!SkipIP6ExtensionHeader(ip6Hdr, dataLength, ip6HdrLength, nextHdr))\n                    return FALSE;\n\n                if(!AnalyzeIP6DestinationExtension(RtlOffsetToPointer(ip6Hdr, destHdrOffset),\n                    *ip6HdrLength - destHdrOffset, &homeAddr))\n                    return FALSE;\n\n                *homeAddrOffset = homeAddr ? RtlPointerToOffset(ip6Hdr, homeAddr) : 0;\n            }\n            break;\n        case IP6_HDR_ROUTING:\n            {\n                IPV6_ADDRESS *destAddr = NULL;\n                ULONG routingHdrOffset = *ip6HdrLength;\n\n                if(!SkipIP6ExtensionHeader(ip6Hdr, dataLength, ip6HdrLength, nextHdr))\n                    return FALSE;\n\n                if(!AnalyzeIP6RoutingExtension((PIP6_TYPE2_ROUTING_HEADER) RtlOffsetToPointer(ip6Hdr, routingHdrOffset),\n                    *ip6HdrLength - routingHdrOffset, &destAddr))\n                    return FALSE;\n\n                *destAddrOffset = destAddr ? RtlPointerToOffset(ip6Hdr, destAddr) : 0;\n            }\n            break;\n        case IP6_HDR_HOP_BY_HOP:\n        case IP6_HDR_ESP:\n        case IP6_HDR_AUTHENTICATION:\n        case IP6_HDR_MOBILITY:\n            if(!SkipIP6ExtensionHeader(ip6Hdr, dataLength, ip6HdrLength, nextHdr))\n                return FALSE;\n\n            break;\n        }\n    }\n}\n\nstatic __inline\nVOID AnalyzeL4Proto(\n    UCHAR l4Protocol,\n    PNET_PACKET_INFO packetInfo)\n{\n    packetInfo->isTCP = (l4Protocol == PROTOCOL_TCP);\n    packetInfo->isUDP = (l4Protocol == PROTOCOL_UDP);\n}\n\nstatic\nBOOLEAN AnalyzeL3Hdr(\n    PNET_PACKET_INFO packetInfo)\n{\n    if(packetInfo->isIP4)\n    {\n        IPv4Header *ip4Hdr = (IPv4Header *) RtlOffsetToPointer(packetInfo->headersBuffer, packetInfo->L2HdrLen);\n\n        if(packetInfo->dataLength < packetInfo->L2HdrLen + sizeof(*ip4Hdr))\n            return FALSE;\n\n        packetInfo->L3HdrLen = IP_HEADER_LENGTH(ip4Hdr);\n        if ((packetInfo->L3HdrLen < sizeof(*ip4Hdr)) ||\n            (packetInfo->dataLength < packetInfo->L2HdrLen + packetInfo->L3HdrLen))\n            return FALSE;\n\n        if(IP_HEADER_VERSION(ip4Hdr) != 4)\n            return FALSE;\n\n        packetInfo->isFragment = IP_HEADER_IS_FRAGMENT(ip4Hdr);\n\n        if(!packetInfo->isFragment)\n        {\n            AnalyzeL4Proto(ip4Hdr->ip_protocol, packetInfo);\n        }\n    }\n    else if(packetInfo->isIP6)\n    {\n        ULONG homeAddrOffset, destAddrOffset;\n        UCHAR l4Proto;\n\n        IPv6Header *ip6Hdr = (IPv6Header *) RtlOffsetToPointer(packetInfo->headersBuffer, packetInfo->L2HdrLen);\n\n        if(IP6_HEADER_VERSION(ip6Hdr) != 6)\n            return FALSE;\n\n        if(!AnalyzeIP6Hdr(ip6Hdr, packetInfo->L2PayloadLen,\n            &packetInfo->L3HdrLen, &l4Proto, &homeAddrOffset, &destAddrOffset))\n            return FALSE;\n\n        if (packetInfo->L3HdrLen > MAX_SUPPORTED_IPV6_HEADERS)\n            return FALSE;\n\n        packetInfo->ip6HomeAddrOffset = (homeAddrOffset) ? packetInfo->L2HdrLen + homeAddrOffset : 0;\n        packetInfo->ip6DestAddrOffset = (destAddrOffset) ? packetInfo->L2HdrLen + destAddrOffset : 0;\n\n        packetInfo->isFragment = (l4Proto == IP6_HDR_FRAGMENT);\n\n        if(!packetInfo->isFragment)\n        {\n            AnalyzeL4Proto(l4Proto, packetInfo);\n        }\n    }\n\n    return TRUE;\n}\n\nBOOLEAN ParaNdis_AnalyzeReceivedPacket(\n    PVOID headersBuffer,\n    ULONG dataLength,\n    PNET_PACKET_INFO packetInfo)\n{\n    NdisZeroMemory(packetInfo, sizeof(*packetInfo));\n\n    packetInfo->headersBuffer = headersBuffer;\n    packetInfo->dataLength = dataLength;\n\n    if(!AnalyzeL2Hdr(packetInfo))\n        return FALSE;\n\n    if (!AnalyzeL3Hdr(packetInfo))\n        return FALSE;\n\n    return TRUE;\n}\n\nULONG ParaNdis_StripVlanHeaderMoveHead(PNET_PACKET_INFO packetInfo)\n{\n    PUINT32 pData = (PUINT32) packetInfo->headersBuffer;\n\n    ASSERT(packetInfo->hasVlanHeader);\n    ASSERT(packetInfo->L2HdrLen == ETH_HEADER_SIZE + ETH_PRIORITY_HEADER_SIZE);\n\n    pData[3] = pData[2];\n    pData[2] = pData[1];\n    pData[1] = pData[0];\n\n    packetInfo->headersBuffer = RtlOffsetToPointer(packetInfo->headersBuffer, ETH_PRIORITY_HEADER_SIZE);\n    packetInfo->dataLength -= ETH_PRIORITY_HEADER_SIZE;\n    packetInfo->L2HdrLen = ETH_HEADER_SIZE;\n\n    packetInfo->ethDestAddr = (PUCHAR) RtlOffsetToPointer(packetInfo->ethDestAddr, ETH_PRIORITY_HEADER_SIZE);\n    packetInfo->ip6DestAddrOffset -= ETH_PRIORITY_HEADER_SIZE;\n    packetInfo->ip6HomeAddrOffset -= ETH_PRIORITY_HEADER_SIZE;\n\n    return ETH_PRIORITY_HEADER_SIZE;\n};\n\nVOID ParaNdis_PadPacketToMinimalLength(PNET_PACKET_INFO packetInfo)\n{\n    // Ethernet standard declares minimal possible packet size\n    // Packets smaller than that must be padded before transfer\n    // Ethernet HW pads packets on transmit, however in our case\n    // some packets do not travel over Ethernet but being routed\n    // guest-to-guest by virtual switch.\n    // In this case padding is not performed and we may\n    // receive packet smaller than minimal allowed size. This is not\n    // a problem for real life scenarios however WHQL/HCK contains\n    // tests that check padding of received packets.\n    // To make these tests happy we have to pad small packets on receive\n\n    //NOTE: This function assumes that VLAN header has been already stripped out\n\n    if(packetInfo->dataLength < ETH_MIN_PACKET_SIZE)\n    {\n        RtlZeroMemory(\n                        RtlOffsetToPointer(packetInfo->headersBuffer, packetInfo->dataLength),\n                        ETH_MIN_PACKET_SIZE - packetInfo->dataLength);\n        packetInfo->dataLength = ETH_MIN_PACKET_SIZE;\n    }\n}\n", "/**********************************************************************\n * Copyright (c) 2008  Red Hat, Inc.\n *\n * File: ParaNdis6-Impl.c\n *\n * This file contains NDIS6-specific implementation of driver's procedures.\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n *\n**********************************************************************/\n#include \"ParaNdis6.h\"\n\nstatic MINIPORT_DISABLE_INTERRUPT MiniportDisableInterruptEx;\nstatic MINIPORT_ENABLE_INTERRUPT MiniportEnableInterruptEx;\nstatic MINIPORT_INTERRUPT_DPC MiniportInterruptDPC;\nstatic MINIPORT_ISR MiniportInterrupt;\nstatic MINIPORT_ENABLE_MESSAGE_INTERRUPT MiniportEnableMSIInterrupt;\nstatic MINIPORT_DISABLE_MESSAGE_INTERRUPT MiniportDisableMSIInterrupt;\nstatic MINIPORT_MESSAGE_INTERRUPT MiniportMSIInterrupt;\nstatic MINIPORT_MESSAGE_INTERRUPT_DPC MiniportMSIInterruptDpc;\nstatic MINIPORT_PROCESS_SG_LIST ProcessSGListHandler;\nstatic MINIPORT_ALLOCATE_SHARED_MEM_COMPLETE SharedMemAllocateCompleteHandler;\n\nstatic MINIPORT_PROCESS_SG_LIST ProcessSGListHandler;\n\n/**********************************************************\nImplements general-purpose memory allocation routine\nParameters:\n    ULONG ulRequiredSize: block size\nReturn value:\n    PVOID allocated memory block\n    NULL on error\n***********************************************************/\nPVOID ParaNdis_AllocateMemoryRaw(NDIS_HANDLE MiniportHandle, ULONG ulRequiredSize)\n{\n    return NdisAllocateMemoryWithTagPriority(\n            MiniportHandle,\n            ulRequiredSize,\n            PARANDIS_MEMORY_TAG,\n            NormalPoolPriority);\n}\n\nPVOID ParaNdis_AllocateMemory(PARANDIS_ADAPTER *pContext, ULONG ulRequiredSize)\n{\n    return ParaNdis_AllocateMemoryRaw(pContext->MiniportHandle, ulRequiredSize);\n}\n\n/**********************************************************\nImplements opening of adapter-specific configuration\nParameters:\n\nReturn value:\n    NDIS_HANDLE Handle of open configuration\n    NULL on error\n***********************************************************/\nNDIS_HANDLE ParaNdis_OpenNICConfiguration(PARANDIS_ADAPTER *pContext)\n{\n    NDIS_CONFIGURATION_OBJECT co;\n    NDIS_HANDLE cfg;\n    NDIS_STATUS status;\n    DEBUG_ENTRY(2);\n    co.Header.Type = NDIS_OBJECT_TYPE_CONFIGURATION_OBJECT;\n    co.Header.Revision = NDIS_CONFIGURATION_OBJECT_REVISION_1;\n    co.Header.Size = sizeof(co);\n    co.Flags = 0;\n    co.NdisHandle = pContext->MiniportHandle;\n    status = NdisOpenConfigurationEx(&co, &cfg);\n    if (status != NDIS_STATUS_SUCCESS)\n        cfg = NULL;\n    DEBUG_EXIT_STATUS(status == NDIS_STATUS_SUCCESS ? 2 : 0, status);\n    return cfg;\n}\n\n/**********************************************************\nNDIS6 implementation of shared memory allocation\nParameters:\n    context\n    tCompletePhysicalAddress *pAddresses\n            the structure accumulates all our knowledge\n            about the allocation (size, addresses, cacheability etc)\nReturn value:\n    TRUE if the allocation was successful\n***********************************************************/\nBOOLEAN ParaNdis_InitialAllocatePhysicalMemory(\n    PARANDIS_ADAPTER *pContext,\n    tCompletePhysicalAddress *pAddresses)\n{\n    NdisMAllocateSharedMemory(\n        pContext->MiniportHandle,\n        pAddresses->size,\n        TRUE,\n        &pAddresses->Virtual,\n        &pAddresses->Physical);\n    return pAddresses->Virtual != NULL;\n}\n\n\n/**********************************************************\nNDIS6 implementation of shared memory freeing\nParameters:\n    context\n    tCompletePhysicalAddress *pAddresses\n            the structure accumulates all our knowledge\n            about the allocation (size, addresses, cacheability etc)\n            filled by ParaNdis_InitialAllocatePhysicalMemory or\n            by ParaNdis_RuntimeRequestToAllocatePhysicalMemory\n***********************************************************/\n\nVOID ParaNdis_FreePhysicalMemory(\n    PARANDIS_ADAPTER *pContext,\n    tCompletePhysicalAddress *pAddresses)\n{\n\n    NdisMFreeSharedMemory(\n        pContext->MiniportHandle,\n        pAddresses->size,\n        TRUE,\n        pAddresses->Virtual,\n        pAddresses->Physical);\n}\n\n#if (NDIS_SUPPORT_NDIS620)\ntypedef MINIPORT_SYNCHRONIZE_INTERRUPT_HANDLER NDIS_SYNC_PROC_TYPE;\n#else\ntypedef PVOID NDIS_SYNC_PROC_TYPE;\n#endif\n\n\nBOOLEAN ParaNdis_SynchronizeWithInterrupt(\n    PARANDIS_ADAPTER *pContext,\n    ULONG messageId,\n    tSynchronizedProcedure procedure,\n    PVOID parameter)\n{\n    tSynchronizedContext SyncContext;\n    NDIS_SYNC_PROC_TYPE syncProc;\n#pragma warning (push)\n#pragma warning (disable:4152)\n    syncProc = (NDIS_SYNC_PROC_TYPE) procedure;\n#pragma warning (pop)\n    SyncContext.pContext  = pContext;\n    SyncContext.Parameter = parameter;\n    return NdisMSynchronizeWithInterruptEx(pContext->InterruptHandle, messageId, syncProc, &SyncContext);\n}\n\n/**********************************************************\nNDIS-required procedure for hardware interrupt registration\nParameters:\n    IN PVOID MiniportInterruptContext (actually Adapter context)\n***********************************************************/\nstatic VOID MiniportDisableInterruptEx(IN PVOID MiniportInterruptContext)\n{\n    DEBUG_ENTRY(0);\n    PARANDIS_ADAPTER *pContext = (PARANDIS_ADAPTER *)MiniportInterruptContext;\n\n    /* TODO - make sure that interrups are not reenabled by the DPC callback*/\n    for (UINT i = 0; i < pContext->nPathBundles; i++)\n    {\n        pContext->pPathBundles[i].txPath.DisableInterrupts();\n        pContext->pPathBundles[i].rxPath.DisableInterrupts();\n    }\n    if (pContext->bCXPathCreated)\n    {\n        pContext->CXPath.DisableInterrupts();\n    }\n}\n\n/**********************************************************\nNDIS-required procedure for hardware interrupt registration\nParameters:\n    IN PVOID MiniportInterruptContext (actually Adapter context)\n***********************************************************/\nstatic VOID MiniportEnableInterruptEx(IN PVOID MiniportInterruptContext)\n{\n    DEBUG_ENTRY(0);\n    PARANDIS_ADAPTER *pContext = (PARANDIS_ADAPTER *)MiniportInterruptContext;\n\n    for (UINT i = 0; i < pContext->nPathBundles; i++)\n    {\n        pContext->pPathBundles[i].txPath.EnableInterrupts();\n        pContext->pPathBundles[i].rxPath.EnableInterrupts();\n    }\n    if (pContext->bCXPathCreated)\n    {\n        pContext->CXPath.EnableInterrupts();\n    }\n}\n\n/**********************************************************\nNDIS-required procedure for hardware interrupt handling\nParameters:\n    IN PVOID  MiniportInterruptContext (actually Adapter context)\n    OUT PBOOLEAN  QueueDefaultInterruptDpc - set to TRUE for default DPC spawning\n    OUT PULONG  TargetProcessors\nReturn value:\n    TRUE if recognized\n***********************************************************/\nstatic BOOLEAN MiniportInterrupt(\n    IN PVOID  MiniportInterruptContext,\n    OUT PBOOLEAN  QueueDefaultInterruptDpc,\n    OUT PULONG  TargetProcessors\n    )\n{\n    PARANDIS_ADAPTER *pContext = (PARANDIS_ADAPTER *)MiniportInterruptContext;\n    ULONG status = VirtIODeviceISR(pContext->IODevice);\n\n    *TargetProcessors = 0;\n\n    if((status == 0) ||\n       (status == VIRTIO_NET_INVALID_INTERRUPT_STATUS))\n    {\n        *QueueDefaultInterruptDpc = FALSE;\n        return FALSE;\n    }\n\n    PARADNIS_STORE_LAST_INTERRUPT_TIMESTAMP(pContext);\n\n    if(!pContext->bDeviceInitialized) {\n        *QueueDefaultInterruptDpc = FALSE;\n        return TRUE;\n    }\n\n    for (UINT i = 0; i < pContext->nPathBundles; i++)\n    {\n        pContext->pPathBundles[i].txPath.DisableInterrupts();\n        pContext->pPathBundles[i].rxPath.DisableInterrupts();\n    }\n    if (pContext->bCXPathCreated)\n    {\n        pContext->CXPath.DisableInterrupts();\n    }\n    \n    *QueueDefaultInterruptDpc = TRUE;\n    pContext->ulIrqReceived += 1;\n\n    return true;\n}\n\nstatic CParaNdisAbstractPath *GetPathByMessageId(PARANDIS_ADAPTER *pContext, ULONG MessageId)\n{\n    CParaNdisAbstractPath *path = NULL;\n\n    UINT bundleId = MessageId / 2;\n    if (bundleId >= pContext->nPathBundles)\n    {\n        path = &pContext->CXPath;\n    }\n    else if (MessageId % 2)\n    {\n        path = &(pContext->pPathBundles[bundleId].rxPath);\n    }\n    else\n    {\n        path = &(pContext->pPathBundles[bundleId].txPath);\n    }\n\n    return path;\n}\n\n/**********************************************************\nNDIS-required procedure for MSI hardware interrupt handling\nParameters:\n    IN PVOID  MiniportInterruptContext (actually Adapter context)\n    IN ULONG  MessageId - specific interrupt index\n    OUT PBOOLEAN  QueueDefaultInterruptDpc - - set to TRUE for default DPC spawning\n    OUT PULONG  TargetProcessors\nReturn value:\n    TRUE if recognized\n***********************************************************/\nstatic BOOLEAN MiniportMSIInterrupt(\n    IN PVOID  MiniportInterruptContext,\n    IN ULONG  MessageId,\n    OUT PBOOLEAN  QueueDefaultInterruptDpc,\n    OUT PULONG  TargetProcessors\n    )\n{\n    PARANDIS_ADAPTER *pContext = (PARANDIS_ADAPTER *)MiniportInterruptContext;\n\n    PARADNIS_STORE_LAST_INTERRUPT_TIMESTAMP(pContext);\n\n    *TargetProcessors = 0;\n\n    if (!pContext->bDeviceInitialized) {\n        *QueueDefaultInterruptDpc = FALSE;\n        return TRUE;\n    }\n\n    CParaNdisAbstractPath *path = GetPathByMessageId(pContext, MessageId);\n\n    path->DisableInterrupts();\n    path->ReportInterrupt();\n\n\n#if NDIS_SUPPORT_NDIS620\n    if (path->DPCAffinity.Mask)\n    {\n        NdisMQueueDpcEx(pContext->InterruptHandle, MessageId, &path->DPCAffinity, NULL);\n        *QueueDefaultInterruptDpc = FALSE;\n    }\n    else\n    {\n        *QueueDefaultInterruptDpc = TRUE;\n    }\n#else\n    *TargetProcessors = (ULONG)path->DPCTargetProcessor;\n    *QueueDefaultInterruptDpc = TRUE;\n#endif\n\n    pContext->ulIrqReceived += 1;\n    return true;\n}\n\n#if NDIS_SUPPORT_NDIS620\n\nstatic __inline\nVOID GetAffinityForCurrentCpu(PGROUP_AFFINITY pAffinity)\n{\n    PROCESSOR_NUMBER ProcNum;\n    KeGetCurrentProcessorNumberEx(&ProcNum);\n\n    pAffinity->Group = ProcNum.Group;\n    pAffinity->Mask = 1;\n    pAffinity->Mask <<= ProcNum.Number;\n}\n\n#endif\n\n/**********************************************************\nNDIS-required procedure for DPC handling\nParameters:\n    PVOID  MiniportInterruptContext (Adapter context)\n***********************************************************/\nstatic VOID MiniportInterruptDPC(\n    IN NDIS_HANDLE  MiniportInterruptContext,\n    IN PVOID  MiniportDpcContext,\n    IN PVOID                   ReceiveThrottleParameters,\n    IN PVOID                   NdisReserved2\n    )\n{\n    PARANDIS_ADAPTER *pContext = (PARANDIS_ADAPTER *)MiniportInterruptContext;\n    bool requiresDPCRescheduling;\n\n#if NDIS_SUPPORT_NDIS620\n    PNDIS_RECEIVE_THROTTLE_PARAMETERS RxThrottleParameters = (PNDIS_RECEIVE_THROTTLE_PARAMETERS)ReceiveThrottleParameters;\n    DEBUG_ENTRY(5);\n    RxThrottleParameters->MoreNblsPending = 0;\n    requiresDPCRescheduling = ParaNdis_DPCWorkBody(pContext, RxThrottleParameters->MaxNblsToIndicate);\n    if (requiresDPCRescheduling)\n        {\n            GROUP_AFFINITY Affinity;\n            GetAffinityForCurrentCpu(&Affinity);\n\n            NdisMQueueDpcEx(pContext->InterruptHandle, 0, &Affinity, MiniportDpcContext);\n        }\n#else /* NDIS 6.0*/\n    DEBUG_ENTRY(5);\n    UNREFERENCED_PARAMETER(ReceiveThrottleParameters);\n\n    requiresDPCRescheduling = ParaNdis_DPCWorkBody(pContext, PARANDIS_UNLIMITED_PACKETS_TO_INDICATE);\n    if (requiresDPCRescheduling)\n    {\n        DPrintf(4, (\"[%s] Queued additional DPC for %d\\n\", __FUNCTION__,  requiresDPCRescheduling));\n        NdisMQueueDpc(pContext->InterruptHandle, 0, 1 << KeGetCurrentProcessorNumber(), MiniportDpcContext);\n    }\n#endif /* NDIS_SUPPORT_NDIS620 */\n\n    UNREFERENCED_PARAMETER(NdisReserved2);\n}\n\n/**********************************************************\nNDIS-required procedure for MSI DPC handling\nParameters:\n    PVOID  MiniportInterruptContext (Adapter context)\n    IN ULONG  MessageId - specific interrupt index\n***********************************************************/\nstatic VOID MiniportMSIInterruptDpc(\n    IN PVOID  MiniportInterruptContext,\n    IN ULONG  MessageId,\n    IN PVOID  MiniportDpcContext,\n#if NDIS_SUPPORT_NDIS620\n    IN PVOID                   ReceiveThrottleParameters,\n    IN PVOID                   NdisReserved2\n#else\n    IN PULONG                  NdisReserved1,\n    IN PULONG                  NdisReserved2\n#endif\n    )\n{\n    PARANDIS_ADAPTER *pContext = (PARANDIS_ADAPTER *)MiniportInterruptContext;\n    bool requireDPCRescheduling;\n\n#if NDIS_SUPPORT_NDIS620\n    PNDIS_RECEIVE_THROTTLE_PARAMETERS RxThrottleParameters = (PNDIS_RECEIVE_THROTTLE_PARAMETERS)ReceiveThrottleParameters;\n\n    RxThrottleParameters->MoreNblsPending = 0;\n    requireDPCRescheduling = ParaNdis_DPCWorkBody(pContext, RxThrottleParameters->MaxNblsToIndicate);\n\n    if (requireDPCRescheduling)\n        {\n            GROUP_AFFINITY Affinity;\n            GetAffinityForCurrentCpu(&Affinity);\n\n            NdisMQueueDpcEx(pContext->InterruptHandle, MessageId, &Affinity, MiniportDpcContext);\n        }\n#else\n    UNREFERENCED_PARAMETER(NdisReserved1);\n\n    requireDPCRescheduling = ParaNdis_DPCWorkBody(pContext, PARANDIS_UNLIMITED_PACKETS_TO_INDICATE);\n    if (requireDPCRescheduling)\n    {\n        NdisMQueueDpc(pContext->InterruptHandle, MessageId, 1 << KeGetCurrentProcessorNumber(), MiniportDpcContext);\n    }\n#endif\n\n    UNREFERENCED_PARAMETER(NdisReserved2);\n}\n\nstatic VOID MiniportDisableMSIInterrupt(\n    IN PVOID  MiniportInterruptContext,\n    IN ULONG  MessageId\n    )\n{\n    PARANDIS_ADAPTER *pContext = (PARANDIS_ADAPTER *)MiniportInterruptContext;\n    /* TODO - How we prevent DPC procedure from re-enabling interrupt? */\n\n    CParaNdisAbstractPath *path = GetPathByMessageId(pContext, MessageId);\n    path->DisableInterrupts();\n}\n\nstatic VOID MiniportEnableMSIInterrupt(\n    IN PVOID  MiniportInterruptContext,\n    IN ULONG  MessageId\n    )\n{\n    PARANDIS_ADAPTER *pContext = (PARANDIS_ADAPTER *)MiniportInterruptContext;\n    CParaNdisAbstractPath *path = GetPathByMessageId(pContext, MessageId);\n    path->EnableInterrupts();\n}\n\n\n/**********************************************************\nNDIS required handler for run-time allocation of physical memory\nParameters:\n\nReturn value:\n***********************************************************/\nstatic VOID SharedMemAllocateCompleteHandler(\n    IN NDIS_HANDLE  MiniportAdapterContext,\n    IN PVOID  VirtualAddress,\n    IN PNDIS_PHYSICAL_ADDRESS  PhysicalAddress,\n    IN ULONG  Length,\n    IN PVOID  Context\n    )\n{\n    UNREFERENCED_PARAMETER(MiniportAdapterContext);\n    UNREFERENCED_PARAMETER(VirtualAddress);\n    UNREFERENCED_PARAMETER(PhysicalAddress);\n    UNREFERENCED_PARAMETER(Length);\n    UNREFERENCED_PARAMETER(Context);\n}\n\nNDIS_STATUS ParaNdis_ConfigureMSIXVectors(PARANDIS_ADAPTER *pContext)\n{\n    NDIS_STATUS status = NDIS_STATUS_RESOURCES;\n    UINT i;\n    PIO_INTERRUPT_MESSAGE_INFO pTable = pContext->pMSIXInfoTable;\n    if (pTable && pTable->MessageCount)\n    {\n        status = NDIS_STATUS_SUCCESS;\n        DPrintf(0, (\"[%s] Using MSIX interrupts (%d messages, irql %d)\\n\",\n            __FUNCTION__, pTable->MessageCount, pTable->UnifiedIrql));\n        for (i = 0; i < pContext->pMSIXInfoTable->MessageCount; ++i)\n        {\n            DPrintf(0, (\"[%s] MSIX message%d=%08X=>%I64X\\n\",\n                __FUNCTION__, i,\n                pTable->MessageInfo[i].MessageData,\n                pTable->MessageInfo[i].MessageAddress));\n        }\n        for (UINT j = 0; j < pContext->nPathBundles && status == NDIS_STATUS_SUCCESS; ++j)\n        {\n            status = pContext->pPathBundles[j].rxPath.SetupMessageIndex(2 * u16(j) + 1);\n            status = pContext->pPathBundles[j].txPath.SetupMessageIndex(2 * u16(j));\n        }\n\n        if (pContext->bCXPathCreated)\n        {\n            pContext->CXPath.SetupMessageIndex(2 * u16(pContext->nPathBundles));\n        }\n    }\n\n    if (status == NDIS_STATUS_SUCCESS)\n    {\n        for (UINT j = 0; j < pContext->nPathBundles && status == NDIS_STATUS_SUCCESS; ++j)\n        {\n            DPrintf(0, (\"[%s] Using messages %u/%u for RX/TX queue %u\\n\", __FUNCTION__, pContext->pPathBundles[j].rxPath.getMessageIndex(),\n                pContext->pPathBundles[j].txPath.getMessageIndex(), j));\n        }\n        if (pContext->bCXPathCreated)\n        {\n            DPrintf(0, (\"[%s] Using message %u for controls\\n\", __FUNCTION__, pContext->CXPath.getMessageIndex()));\n        }\n        else\n        {\n            DPrintf(0, (\"[%s] - No control path\\n\", __FUNCTION__));\n        }\n    }\n    DEBUG_EXIT_STATUS(2, status);\n    return status;\n}\n\nvoid ParaNdis_RestoreDeviceConfigurationAfterReset(\n    PARANDIS_ADAPTER *pContext)\n{\n    ParaNdis_ConfigureMSIXVectors(pContext);\n}\n\nstatic void DebugParseOffloadBits()\n{\n    NDIS_TCP_IP_CHECKSUM_NET_BUFFER_LIST_INFO info;\n    tChecksumCheckResult res;\n    ULONG val = 1;\n    int level = 1;\n    while (val)\n    {\n        info.Value = (PVOID)(ULONG_PTR)val;\n        if (info.Receive.IpChecksumFailed) DPrintf(level, (\"W.%X=IPCS failed\\n\", val));\n        if (info.Receive.IpChecksumSucceeded) DPrintf(level, (\"W.%X=IPCS OK\\n\", val));\n        if (info.Receive.TcpChecksumFailed) DPrintf(level, (\"W.%X=TCPCS failed\\n\", val));\n        if (info.Receive.TcpChecksumSucceeded) DPrintf(level, (\"W.%X=TCPCS OK\\n\", val));\n        if (info.Receive.UdpChecksumFailed) DPrintf(level, (\"W.%X=UDPCS failed\\n\", val));\n        if (info.Receive.UdpChecksumSucceeded) DPrintf(level, (\"W.%X=UDPCS OK\\n\", val));\n        val = val << 1;\n    }\n    val = 1;\n    while (val)\n    {\n        res.value = val;\n        if (res.flags.IpFailed) DPrintf(level, (\"C.%X=IPCS failed\\n\", val));\n        if (res.flags.IpOK) DPrintf(level, (\"C.%X=IPCS OK\\n\", val));\n        if (res.flags.TcpFailed) DPrintf(level, (\"C.%X=TCPCS failed\\n\", val));\n        if (res.flags.TcpOK) DPrintf(level, (\"C.%X=TCPCS OK\\n\", val));\n        if (res.flags.UdpFailed) DPrintf(level, (\"C.%X=UDPCS failed\\n\", val));\n        if (res.flags.UdpOK) DPrintf(level, (\"C.%X=UDPCS OK\\n\", val));\n        val = val << 1;\n    }\n}\n\n/**********************************************************\nNDIS6-related final initialization:\n    Installing interrupt handler\n    Allocate buffer list pool\n\nParameters:\n\nReturn value:\n\n***********************************************************/\nNDIS_STATUS ParaNdis_FinishSpecificInitialization(PARANDIS_ADAPTER *pContext)\n{\n    NDIS_STATUS status = NDIS_STATUS_SUCCESS;\n    NET_BUFFER_LIST_POOL_PARAMETERS PoolParams;\n    NDIS_MINIPORT_INTERRUPT_CHARACTERISTICS mic;\n    DEBUG_ENTRY(0);\n\n    NdisZeroMemory(&mic, sizeof(mic));\n    mic.Header.Type = NDIS_OBJECT_TYPE_MINIPORT_INTERRUPT;\n    mic.Header.Revision = NDIS_MINIPORT_INTERRUPT_REVISION_1;\n    mic.Header.Size = NDIS_SIZEOF_MINIPORT_INTERRUPT_CHARACTERISTICS_REVISION_1;\n    mic.DisableInterruptHandler = MiniportDisableInterruptEx;\n    mic.EnableInterruptHandler  = MiniportEnableInterruptEx;\n    mic.InterruptDpcHandler = MiniportInterruptDPC;\n    mic.InterruptHandler = MiniportInterrupt;\n    if (pContext->bUsingMSIX)\n    {\n        mic.MsiSupported = TRUE;\n        mic.MsiSyncWithAllMessages = TRUE;\n        mic.EnableMessageInterruptHandler = MiniportEnableMSIInterrupt;\n        mic.DisableMessageInterruptHandler = MiniportDisableMSIInterrupt;\n        mic.MessageInterruptHandler = MiniportMSIInterrupt;\n        mic.MessageInterruptDpcHandler = MiniportMSIInterruptDpc;\n    }\n    PoolParams.Header.Type = NDIS_OBJECT_TYPE_DEFAULT;\n    PoolParams.Header.Size = sizeof(PoolParams);\n    PoolParams.Header.Revision = NET_BUFFER_LIST_POOL_PARAMETERS_REVISION_1;\n    PoolParams.ProtocolId = NDIS_PROTOCOL_ID_DEFAULT;\n    PoolParams.fAllocateNetBuffer = TRUE;\n    PoolParams.ContextSize = 0;\n    PoolParams.PoolTag = PARANDIS_MEMORY_TAG;\n    PoolParams.DataSize = 0;\n\n    pContext->BufferListsPool = NdisAllocateNetBufferListPool(pContext->MiniportHandle, &PoolParams);\n    if (!pContext->BufferListsPool)\n    {\n        status = NDIS_STATUS_RESOURCES;\n    }\n\n    if (status == NDIS_STATUS_SUCCESS)\n    {\n        status = NdisMRegisterInterruptEx(pContext->MiniportHandle, pContext, &mic, &pContext->InterruptHandle);\n    }\n\n#ifdef DBG\n    if (pContext->bUsingMSIX)\n    {\n        DPrintf(0, (\"[%s] MSIX message table %savailable, count = %u\\n\", __FUNCTION__, (mic.MessageInfoTable == nullptr ? \"not \" : \"\"),\n            (mic.MessageInfoTable == nullptr ? 0 : mic.MessageInfoTable->MessageCount)));\n    }\n    else\n    {\n        DPrintf(0, (\"[%s] Not using MSIX\\n\", __FUNCTION__));\n    }\n#endif\n\n    if (status == NDIS_STATUS_SUCCESS)\n    {\n        NDIS_SG_DMA_DESCRIPTION sgDesc;\n        sgDesc.Header.Type = NDIS_OBJECT_TYPE_SG_DMA_DESCRIPTION;\n        sgDesc.Header.Revision = NDIS_SG_DMA_DESCRIPTION_REVISION_1;\n        sgDesc.Header.Size = sizeof(sgDesc);\n        sgDesc.Flags = NDIS_SG_DMA_64_BIT_ADDRESS;\n        sgDesc.MaximumPhysicalMapping = 0x10000; // 64K\n        sgDesc.ProcessSGListHandler = ProcessSGListHandler;\n        sgDesc.SharedMemAllocateCompleteHandler = SharedMemAllocateCompleteHandler;\n        sgDesc.ScatterGatherListSize = 0; // OUT value\n        status = NdisMRegisterScatterGatherDma(pContext->MiniportHandle, &sgDesc, &pContext->DmaHandle);\n        if (status != NDIS_STATUS_SUCCESS)\n        {\n            DPrintf(0, (\"[%s] ERROR: NdisMRegisterScatterGatherDma failed (%X)!\\n\", __FUNCTION__, status));\n        }\n        else\n        {\n            DPrintf(0, (\"[%s] SG recommended size %d\\n\", __FUNCTION__, sgDesc.ScatterGatherListSize));\n        }\n    }\n\n    if (status == NDIS_STATUS_SUCCESS)\n    {\n        if (NDIS_CONNECT_MESSAGE_BASED == mic.InterruptType)\n        {\n            pContext->pMSIXInfoTable = mic.MessageInfoTable;\n        }\n        else if (pContext->bUsingMSIX)\n        {\n            DPrintf(0, (\"[%s] ERROR: Interrupt type %d, message table %p\\n\",\n                __FUNCTION__, mic.InterruptType, mic.MessageInfoTable));\n            status = NDIS_STATUS_RESOURCE_CONFLICT;\n        }\n        ParaNdis6_ApplyOffloadPersistentConfiguration(pContext);\n        DebugParseOffloadBits();\n    }\n    DEBUG_EXIT_STATUS(0, status);\n    return status;\n}\n\n/**********************************************************\nNDIS6-related final initialization:\n    Uninstalling interrupt handler\n    Dellocate buffer list pool\nParameters:\n    context\n***********************************************************/\nVOID ParaNdis_FinalizeCleanup(PARANDIS_ADAPTER *pContext)\n{\n    // we zero context members to be able examine them in the debugger/dump\n    if (pContext->InterruptHandle)\n    {\n        NdisMDeregisterInterruptEx(pContext->InterruptHandle);\n        pContext->InterruptHandle = NULL;\n    }\n    if (pContext->BufferListsPool)\n    {\n        NdisFreeNetBufferListPool(pContext->BufferListsPool);\n        pContext->BufferListsPool = NULL;\n    }\n    if (pContext->DmaHandle)\n    {\n        NdisMDeregisterScatterGatherDma(pContext->DmaHandle);\n        pContext->DmaHandle = NULL;\n    }\n}\n\nBOOLEAN ParaNdis_BindRxBufferToPacket(\n    PARANDIS_ADAPTER *pContext,\n    pRxNetDescriptor p)\n{\n    ULONG i;\n    PMDL *NextMdlLinkage = &p->Holder;\n\n    for(i = PARANDIS_FIRST_RX_DATA_PAGE; i < p->PagesAllocated; i++)\n    {\n        *NextMdlLinkage = NdisAllocateMdl(pContext->MiniportHandle, p->PhysicalPages[i].Virtual, PAGE_SIZE);\n        if(*NextMdlLinkage == NULL) goto error_exit;\n\n        NextMdlLinkage = &(NDIS_MDL_LINKAGE(*NextMdlLinkage));\n    }\n    *NextMdlLinkage = NULL;\n\n    return TRUE;\n\nerror_exit:\n\n    ParaNdis_UnbindRxBufferFromPacket(p);\n    return FALSE;\n}\n\nvoid ParaNdis_UnbindRxBufferFromPacket(\n    pRxNetDescriptor p)\n{\n    PMDL NextMdlLinkage = p->Holder;\n\n    while(NextMdlLinkage != NULL)\n    {\n        PMDL pThisMDL = NextMdlLinkage;\n        NextMdlLinkage = NDIS_MDL_LINKAGE(pThisMDL);\n\n        NdisAdjustMdlLength(pThisMDL, PAGE_SIZE);\n        NdisFreeMdl(pThisMDL);\n    }\n}\n\nstatic\nvoid ParaNdis_AdjustRxBufferHolderLength(\n    pRxNetDescriptor p,\n    ULONG ulDataOffset)\n{\n    PMDL NextMdlLinkage = p->Holder;\n    ULONG ulBytesLeft = p->PacketInfo.dataLength + ulDataOffset;\n\n    while(NextMdlLinkage != NULL)\n    {\n        ULONG ulThisMdlBytes = min(PAGE_SIZE, ulBytesLeft);\n        NdisAdjustMdlLength(NextMdlLinkage, ulThisMdlBytes);\n        ulBytesLeft -= ulThisMdlBytes;\n        NextMdlLinkage = NDIS_MDL_LINKAGE(NextMdlLinkage);\n    }\n    ASSERT(ulBytesLeft == 0);\n}\n\nstatic __inline\nVOID NBLSetRSSInfo(PPARANDIS_ADAPTER pContext, PNET_BUFFER_LIST pNBL, PNET_PACKET_INFO PacketInfo)\n{\n#if PARANDIS_SUPPORT_RSS\n    CNdisRWLockState lockState;\n\n    pContext->RSSParameters.rwLock.acquireReadDpr(lockState);\n    if(pContext->RSSParameters.RSSMode != PARANDIS_RSS_DISABLED)\n    {\n        NET_BUFFER_LIST_SET_HASH_TYPE    (pNBL, PacketInfo->RSSHash.Type);\n        NET_BUFFER_LIST_SET_HASH_FUNCTION(pNBL, PacketInfo->RSSHash.Function);\n        NET_BUFFER_LIST_SET_HASH_VALUE   (pNBL, PacketInfo->RSSHash.Value);\n    }\n    pContext->RSSParameters.rwLock.releaseDpr(lockState);\n#else\n    UNREFERENCED_PARAMETER(pContext);\n    UNREFERENCED_PARAMETER(pNBL);\n    UNREFERENCED_PARAMETER(PacketInfo);\n#endif\n}\n\nstatic __inline\nVOID NBLSet8021QInfo(PPARANDIS_ADAPTER pContext, PNET_BUFFER_LIST pNBL, PNET_PACKET_INFO pPacketInfo)\n{\n    NDIS_NET_BUFFER_LIST_8021Q_INFO qInfo;\n    qInfo.Value = NULL;\n\n    if (IsPrioritySupported(pContext))\n        qInfo.TagHeader.UserPriority = pPacketInfo->Vlan.UserPriority;\n\n    if (IsVlanSupported(pContext))\n        qInfo.TagHeader.VlanId = pPacketInfo->Vlan.VlanId;\n\n    if(qInfo.Value != NULL)\n        pContext->extraStatistics.framesRxPriority++;\n\n    NET_BUFFER_LIST_INFO(pNBL, Ieee8021QNetBufferListInfo) = qInfo.Value;\n}\n\n#if PARANDIS_SUPPORT_RSC\nstatic __inline\nUINT PktGetTCPCoalescedSegmentsCount(PNET_PACKET_INFO PacketInfo, UINT nMaxTCPPayloadSize)\n{\n    // We have no corresponding data, following is a simulation\n    return PacketInfo->L2PayloadLen / nMaxTCPPayloadSize +\n        !!(PacketInfo->L2PayloadLen % nMaxTCPPayloadSize);\n}\n\nstatic __inline\nVOID NBLSetRSCInfo(PPARANDIS_ADAPTER pContext, PNET_BUFFER_LIST pNBL,\n                   PNET_PACKET_INFO PacketInfo, UINT nCoalescedSegments)\n{\n    NDIS_TCP_IP_CHECKSUM_NET_BUFFER_LIST_INFO qCSInfo;\n\n    qCSInfo.Value = NULL;\n    qCSInfo.Receive.IpChecksumSucceeded = TRUE;\n    qCSInfo.Receive.IpChecksumValueInvalid = TRUE;\n    qCSInfo.Receive.TcpChecksumSucceeded = TRUE;\n    qCSInfo.Receive.TcpChecksumValueInvalid = TRUE;\n    NET_BUFFER_LIST_INFO(pNBL, TcpIpChecksumNetBufferListInfo) = qCSInfo.Value;\n\n    NET_BUFFER_LIST_COALESCED_SEG_COUNT(pNBL) = (USHORT) nCoalescedSegments;\n    NET_BUFFER_LIST_DUP_ACK_COUNT(pNBL) = 0;\n\n    NdisInterlockedAddLargeStatistic(&pContext->RSC.Statistics.CoalescedOctets, PacketInfo->L2PayloadLen);\n    NdisInterlockedAddLargeStatistic(&pContext->RSC.Statistics.CoalesceEvents, 1);\n    NdisInterlockedAddLargeStatistic(&pContext->RSC.Statistics.CoalescedPkts, nCoalescedSegments);\n}\n#endif\n\n/**********************************************************\nNDIS6 implementation of packet indication\n\nParameters:\n    context\n    PVOID pBuffersDescriptor - VirtIO buffer descriptor of data buffer\n    BOOLEAN bPrepareOnly - only return NBL for further indication in batch\nReturn value:\n    TRUE  is packet indicated\n    FALSE if not (in this case, the descriptor should be freed now)\nIf priority header is in the packet. it will be removed and *pLength decreased\n***********************************************************/\ntPacketIndicationType ParaNdis_PrepareReceivedPacket(\n    PARANDIS_ADAPTER *pContext,\n    pRxNetDescriptor pBuffersDesc,\n    PUINT            pnCoalescedSegmentsCount)\n{\n    PMDL pMDL = pBuffersDesc->Holder;\n    PNET_BUFFER_LIST pNBL = NULL;\n    *pnCoalescedSegmentsCount = 1;\n\n    if (pMDL)\n    {\n        ULONG nBytesStripped = 0;\n        PNET_PACKET_INFO pPacketInfo = &pBuffersDesc->PacketInfo;\n\n        if (pContext->ulPriorityVlanSetting && pPacketInfo->hasVlanHeader)\n        {\n            nBytesStripped = ParaNdis_StripVlanHeaderMoveHead(pPacketInfo);\n        }\n\n        ParaNdis_PadPacketToMinimalLength(pPacketInfo);\n        ParaNdis_AdjustRxBufferHolderLength(pBuffersDesc, nBytesStripped);\n        pNBL = NdisAllocateNetBufferAndNetBufferList(pContext->BufferListsPool, 0, 0, pMDL, nBytesStripped, pPacketInfo->dataLength);\n\n        if (pNBL)\n        {\n            virtio_net_hdr_basic *pHeader = (virtio_net_hdr_basic *) pBuffersDesc->PhysicalPages[0].Virtual;\n            tChecksumCheckResult csRes;\n            pNBL->SourceHandle = pContext->MiniportHandle;\n            NBLSetRSSInfo(pContext, pNBL, pPacketInfo);\n            NBLSet8021QInfo(pContext, pNBL, pPacketInfo);\n\n            pNBL->MiniportReserved[0] = pBuffersDesc;\n\n#if PARANDIS_SUPPORT_RSC\n            if(pHeader->gso_type != VIRTIO_NET_HDR_GSO_NONE)\n            {\n                *pnCoalescedSegmentsCount = PktGetTCPCoalescedSegmentsCount(pPacketInfo, pContext->MaxPacketSize.nMaxDataSize);\n                NBLSetRSCInfo(pContext, pNBL, pPacketInfo, *pnCoalescedSegmentsCount);\n            }\n            else\n#endif\n            {\n                csRes = ParaNdis_CheckRxChecksum(\n                    pContext,\n                    pHeader->flags,\n                    &pBuffersDesc->PhysicalPages[PARANDIS_FIRST_RX_DATA_PAGE],\n                    pPacketInfo->dataLength,\n                    nBytesStripped, TRUE);\n                if (csRes.value)\n                {\n                    NDIS_TCP_IP_CHECKSUM_NET_BUFFER_LIST_INFO qCSInfo;\n                    qCSInfo.Value = NULL;\n                    qCSInfo.Receive.IpChecksumFailed = csRes.flags.IpFailed;\n                    qCSInfo.Receive.IpChecksumSucceeded = csRes.flags.IpOK;\n                    qCSInfo.Receive.TcpChecksumFailed = csRes.flags.TcpFailed;\n                    qCSInfo.Receive.TcpChecksumSucceeded = csRes.flags.TcpOK;\n                    qCSInfo.Receive.UdpChecksumFailed = csRes.flags.UdpFailed;\n                    qCSInfo.Receive.UdpChecksumSucceeded = csRes.flags.UdpOK;\n                    NET_BUFFER_LIST_INFO(pNBL, TcpIpChecksumNetBufferListInfo) = qCSInfo.Value;\n                    DPrintf(1, (\"Reporting CS %X->%X\\n\", csRes.value, (ULONG)(ULONG_PTR)qCSInfo.Value));\n                }\n            }\n            pNBL->Status = NDIS_STATUS_SUCCESS;\n#if defined(ENABLE_HISTORY_LOG)\n            {\n                tTcpIpPacketParsingResult packetReview = ParaNdis_CheckSumVerify(\n                    RtlOffsetToPointer(pPacketInfo->headersBuffer, ETH_HEADER_SIZE),\n                    pPacketInfo->dataLength,\n                    pcrIpChecksum | pcrTcpChecksum | pcrUdpChecksum,\n                    __FUNCTION__\n                    );\n                ParaNdis_DebugHistory(pContext, hopPacketReceived, pNBL, pPacketInfo->dataLength, (ULONG)(ULONG_PTR)qInfo.Value, packetReview.value);\n            }\n#endif\n        }\n    }\n    return pNBL;\n}\n\n\n/**********************************************************\nNDIS procedure of returning us buffer of previously indicated packets\nParameters:\n    context\n    PNET_BUFFER_LIST pNBL - list of buffers to free\n    returnFlags - is dpc\n\nThe procedure frees:\nreceived buffer descriptors back to list of RX buffers\nall the allocated MDL structures\nall the received NBLs back to our pool\n***********************************************************/\nVOID ParaNdis6_ReturnNetBufferLists(\n    NDIS_HANDLE miniportAdapterContext,\n    PNET_BUFFER_LIST pNBL,\n    ULONG returnFlags)\n{\n    PARANDIS_ADAPTER *pContext = (PARANDIS_ADAPTER *)miniportAdapterContext;\n\n    UNREFERENCED_PARAMETER(returnFlags);\n\n    DEBUG_ENTRY(5);\n    while (pNBL)\n    {\n        PNET_BUFFER_LIST pTemp = pNBL;\n        pRxNetDescriptor pBuffersDescriptor = (pRxNetDescriptor)pNBL->MiniportReserved[0];\n        DPrintf(3, (\"  Returned NBL of pBuffersDescriptor %p!\\n\", pBuffersDescriptor));\n        pNBL = NET_BUFFER_LIST_NEXT_NBL(pNBL);\n        NET_BUFFER_LIST_NEXT_NBL(pTemp) = NULL;\n        NdisFreeNetBufferList(pTemp);\n        pBuffersDescriptor->Queue->ReuseReceiveBuffer(pContext->ReuseBufferRegular, pBuffersDescriptor);\n    }\n    ParaMdis_TestPausing(pContext);\n}\n\n/**********************************************************\nPauses of restarts RX activity.\nRestart is immediate, pause may be delayed until\nNDIS returns all the indicated NBL\n\nParameters:\n    context\n    bPause 1/0 - pause or restart\n    ONPAUSECOMPLETEPROC Callback to be called when PAUSE finished\nReturn value:\n    SUCCESS if finished synchronously\n    PENDING if not, then callback will be called\n***********************************************************/\nNDIS_STATUS ParaNdis6_ReceivePauseRestart(\n    PARANDIS_ADAPTER *pContext,\n    BOOLEAN bPause,\n    ONPAUSECOMPLETEPROC Callback\n    )\n{\n    NDIS_STATUS status = NDIS_STATUS_SUCCESS;\n\n    if (bPause)\n    {\n        CNdisPassiveWriteAutoLock tLock(pContext->m_PauseLock);\n\n        ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 1, 0, 0);\n        if (pContext->m_upstreamPacketPending != 0)\n        {\n            pContext->ReceiveState = srsPausing;\n            pContext->ReceivePauseCompletionProc = Callback;\n            status = NDIS_STATUS_PENDING;\n        }\n        else\n        {\n            ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 0, 0, 0);\n            pContext->ReceiveState = srsDisabled;\n        }\n    }\n    else\n    {\n        ParaNdis_DebugHistory(pContext, hopInternalReceiveResume, NULL, 0, 0, 0);\n        pContext->ReceiveState = srsEnabled;\n    }\n    return status;\n}\n\nNDIS_STATUS ParaNdis_ExactSendFailureStatus(PARANDIS_ADAPTER *pContext)\n{\n    NDIS_STATUS status = NDIS_STATUS_FAILURE;\n    if (pContext->SendState != srsEnabled ) status = NDIS_STATUS_PAUSED;\n    if (!pContext->bConnected) status = NDIS_STATUS_MEDIA_DISCONNECTED;\n    if (pContext->bSurprizeRemoved) status = NDIS_STATUS_NOT_ACCEPTED;\n    // override NDIS_STATUS_PAUSED is there is a specific reason of implicit paused state\n    if (pContext->powerState != NdisDeviceStateD0) status = NDIS_STATUS_LOW_POWER_STATE;\n    if (pContext->bResetInProgress) status = NDIS_STATUS_RESET_IN_PROGRESS;\n    return status;\n}\n\nBOOLEAN ParaNdis_IsSendPossible(PARANDIS_ADAPTER *pContext)\n{\n    BOOLEAN b;\n    b =  !pContext->bSurprizeRemoved && pContext->bConnected && pContext->SendState == srsEnabled;\n    return b;\n}\n\n/**********************************************************\nNDIS required handler for run-time allocation of scatter-gather list\nParameters:\npSGL - scatter-hather list of elements (possible NULL when called directly)\nContext - (tNetBufferEntry *) for specific NET_BUFFER in NBL\nCalled on DPC (DDK claims it)\n***********************************************************/\nVOID ProcessSGListHandler(\n    IN PDEVICE_OBJECT  pDO,\n    IN PVOID  Reserved,\n    IN PSCATTER_GATHER_LIST  pSGL,\n    IN PVOID  Context\n    )\n{\n    UNREFERENCED_PARAMETER(Reserved);\n    UNREFERENCED_PARAMETER(pDO);\n\n    auto NBHolder = static_cast<CNB*>(Context);\n    NBHolder->MappingDone(pSGL);\n}\n\n/**********************************************************\nPauses of restarts TX activity.\nRestart is immediate, pause may be delayed until\nwe return all the NBLs to NDIS\n\nParameters:\n    context\n    bPause 1/0 - pause or restart\n    ONPAUSECOMPLETEPROC Callback to be called when PAUSE finished\nReturn value:\n    SUCCESS if finished synchronously\n    PENDING if not, then callback will be called later\n***********************************************************/\nNDIS_STATUS ParaNdis6_SendPauseRestart(\n    PARANDIS_ADAPTER *pContext,\n    BOOLEAN bPause,\n    ONPAUSECOMPLETEPROC Callback\n)\n{\n    NDIS_STATUS status = NDIS_STATUS_SUCCESS;\n    DEBUG_ENTRY(4);\n    if (bPause)\n    {\n        ParaNdis_DebugHistory(pContext, hopInternalSendPause, NULL, 1, 0, 0);\n        if (pContext->SendState == srsEnabled)\n        {\n            {\n                CNdisPassiveWriteAutoLock tLock(pContext->m_PauseLock);\n\n                pContext->SendState = srsPausing;\n                pContext->SendPauseCompletionProc = Callback;\n            }\n\n            for (UINT i = 0; i < pContext->nPathBundles; i++)\n            {\n                if (!pContext->pPathBundles[i].txPath.Pause())\n                {\n                    status = NDIS_STATUS_PENDING;\n                }\n            }\n\n            if (status == NDIS_STATUS_SUCCESS)\n            {\n                pContext->SendState = srsDisabled;\n            }\n        }\n        if (status == NDIS_STATUS_SUCCESS)\n        {\n            ParaNdis_DebugHistory(pContext, hopInternalSendPause, NULL, 0, 0, 0);\n        }\n    }\n    else\n    {\n        pContext->SendState = srsEnabled;\n        ParaNdis_DebugHistory(pContext, hopInternalSendResume, NULL, 0, 0, 0);\n    }\n    return status;\n}\n\n/**********************************************************\nRequired procedure of NDIS\nNDIS wants to cancel sending of each list which has specified CancelID\nCan be tested only under NDIS Test\n***********************************************************/\nVOID ParaNdis6_CancelSendNetBufferLists(\n    NDIS_HANDLE  miniportAdapterContext,\n    PVOID pCancelId)\n{\n    PARANDIS_ADAPTER *pContext = (PARANDIS_ADAPTER *)miniportAdapterContext;\n\n    DEBUG_ENTRY(0);\n    for (UINT i = 0; i < pContext->nPathBundles; i++)\n    {\n        pContext->pPathBundles[i].txPath.CancelNBLs(pCancelId);\n    }\n}\n"], "filenames": ["NetKVM/Common/ParaNdis-Common.cpp", "NetKVM/Common/ParaNdis-TX.cpp", "NetKVM/Common/ndis56common.h", "NetKVM/Common/sw-offload.cpp", "NetKVM/wlh/ParaNdis6-Impl.cpp"], "buggy_code_start_loc": [2222, 651, 747, 203, 869], "buggy_code_end_loc": [2251, 700, 936, 708, 870], "fixing_code_start_loc": [2222, 652, 747, 203, 869], "fixing_code_end_loc": [2253, 701, 939, 710, 870], "type": "CWE-20", "message": "The NetKVM Windows Virtio driver allows remote attackers to cause a denial of service (guest crash) via a crafted length value in an IP packet, as demonstrated by a value that does not account for the size of the IP options.", "other": {"cve": {"id": "CVE-2015-3215", "sourceIdentifier": "secalert@redhat.com", "published": "2017-06-26T15:29:00.393", "lastModified": "2023-02-13T00:48:25.147", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The NetKVM Windows Virtio driver allows remote attackers to cause a denial of service (guest crash) via a crafted length value in an IP packet, as demonstrated by a value that does not account for the size of the IP options."}, {"lang": "es", "value": "El driver de NetKVM Windows Virtio permite a un atacante remoto provocar una denegaci\u00f3n de servicio (guest crash) mediante un valor de longitud dise\u00f1ado en un paquete IP, como demuestra el valor que no tiene en cuenta el tama\u00f1o de las opciones IP`s."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:virtio-win:-:*:*:*:*:*:*:*", "matchCriteriaId": "3C9702E9-461D-4BEC-9AD4-EE6C8D5E3327"}]}]}], "references": [{"url": "http://rhn.redhat.com/errata/RHSA-2015-1043.html", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-1044.html", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/YanVugenfirer/kvm-guest-drivers-windows/commit/723416fa4210b7464b28eab89cc76252e6193ac1", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/YanVugenfirer/kvm-guest-drivers-windows/commit/fbfa4d1083ea84c5429992ca3e996d7d4fbc8238", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.redhat.com/security/data/cve/CVE-2015-3215.html", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/YanVugenfirer/kvm-guest-drivers-windows/commit/723416fa4210b7464b28eab89cc76252e6193ac1"}}