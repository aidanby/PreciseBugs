{"buggy_code": ["/*\n * Ayttm\n *\n * Copyright (C) 2003, 2009 the Ayttm team\n * \n * Ayttm is a derivative of Everybuddy\n * Copyright (C) 1998-1999, Torrey Searle\n * proxy featured by Seb C.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n */\n\n/* this is a little piece of code to handle proxy connection */\n/* it is intended to : 1st handle http proxy, using the CONNECT command\n , 2nd provide an easy way to add socks support */\n\n#include \"intl.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#ifdef __MINGW32__\n#include <winsock2.h>\n#else\n#include <sys/socket.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#endif\n\n#include \"proxy.h\"\n#include \"proxy_private.h\"\n#include \"common.h\"\n#include \"net_constants.h\"\n\n#include <glib.h>\n\n#ifdef __MINGW32__\n#define sleep(a)\t\tSleep(1000*a)\n\n#define bcopy(a,b,c)\tmemcpy(b,a,c)\n#define bzero(a,b)\t\tmemset(a,0,b)\n\n#define ECONNREFUSED\tWSAECONNREFUSED\n#endif\n\n/* Prototypes */\nstatic char *encode_proxy_auth_str(AyProxyData *proxy);\n\n#define debug_print printf\n\n/* \n * External function to use to set the proxy settings\n */\nint ay_proxy_set_default(AyProxyType type, const char *host, int port,\n\tchar *username, char *password)\n{\n\tif (!default_proxy)\n\t\tdefault_proxy = g_new0(AyProxyData, 1);\n\n\tdefault_proxy->type = type;\n\n\tif (type == PROXY_NONE) {\n\t\tif (default_proxy->host)\n\t\t\tfree(default_proxy->host);\n\n\t\tif (default_proxy->username)\n\t\t\tfree(default_proxy->username);\n\n\t\tif (default_proxy->password)\n\t\t\tfree(default_proxy->password);\n\n\t\tg_free(default_proxy);\n\t\tdefault_proxy = NULL;\n\t} else {\n\t\tdefault_proxy->port = 0;\n\n\t\tif (host != NULL && host[0]) {\n\t\t\tdefault_proxy->host = strdup(host);\n\t\t\tdefault_proxy->port = port;\n\t\t}\n\t\tif (default_proxy->port == 0)\n\t\t\tdefault_proxy->port = 3128;\n\n\t\tif (username && username[0])\n\t\t\tdefault_proxy->username = strdup(username);\n\n\t\tif (password && password[0])\n\t\t\tdefault_proxy->password = strdup(password);\n\n\t}\n#ifdef __MINGW32__\n\t{\n\t\tWSADATA wsaData;\n\t\tWSAStartup(MAKEWORD(2, 0), &wsaData);\n\t}\n#endif\n\treturn (0);\n}\n\n/* http://archive.socks.permeo.com/protocol/socks4.protocol */\nint socks4_connect(int sock, const char *host, int port, AyProxyData *proxy)\n{\n\tint i, packetlen;\n\n\tunsigned char *packet = NULL;\n\tstruct addrinfo *result = NULL;\n\n\tint retval = 0;\n\n\tif (proxy->username && proxy->username[0])\n\t\tpacketlen = 9 + strlen(proxy->username);\n\telse\n\t\tpacketlen = 9;\n\n\tresult = lookup_address(host, port, AF_INET);\n\n\tif (!result)\n\t\treturn AY_HOSTNAME_LOOKUP_FAIL;\n\n\tpacket = (unsigned char *)calloc(packetlen, sizeof(unsigned char));\n\n\tpacket[0] = 4;\t\t/* Version */\n\tpacket[1] = 1;\t\t/* CONNECT  */\n\tpacket[2] = (((unsigned short)port) >> 8);\t/* DESTPORT */\n\tpacket[3] = (((unsigned short)port) & 0xff);\t/* DESTPORT */\n\n\t/* DESTIP */\n\tbcopy(packet + 4, &(((struct sockaddr_in *)result->ai_addr)->sin_addr),\n\t\t4);\n\n\tfreeaddrinfo(result);\n\n\tif (proxy->username && proxy->username[0]) {\n\t\tfor (i = 0; proxy->username[i]; i++) {\n\t\t\tpacket[i + 8] = (unsigned char)proxy->username[i];\t/* AUTH      */\n\t\t}\n\t}\n\tpacket[packetlen - 1] = 0;\t/* END          */\n\tdebug_print(\"Sending \\\"%s\\\"\\n\", packet);\n\tif (write(sock, packet, packetlen) == packetlen) {\n\t\tbzero(packet, sizeof(packet));\n\t\t/* Check response - return as SOCKS4 if its valid */\n\t\tif (read(sock, packet, 9) >= 4) {\n\t\t\tif (packet[1] == 90) {\n\t\t\t\treturn 0;\n\t\t\t} else if (packet[1] == 91)\n\t\t\t\tretval = AY_SOCKS4_UNKNOWN;\n\t\t\telse if (packet[1] == 92)\n\t\t\t\tretval = AY_SOCKS4_IDENTD_FAIL;\n\t\t\telse if (packet[1] == 93)\n\t\t\t\tretval = AY_SOCKS4_IDENT_USER_DIFF;\n\t\t\telse {\n\t\t\t\tretval = AY_SOCKS4_INCOMPATIBLE_ERROR;\n\t\t\t\tprintf(\"=>>%d\\n\", packet[1]);\n\t\t\t}\n\t\t} else {\n\t\t\tprintf(\"short read %s\\n\", packet);\n\t\t}\n\t}\n\tclose(sock);\n\n\treturn retval;\n}\n\n/* http://archive.socks.permeo.com/rfc/rfc1928.txt */\n/* http://archive.socks.permeo.com/rfc/rfc1929.txt */\n\n/* \n * Removed support for datagram connections because we're not even using it now. \n * I'll add it back if/when it is needed or if I feel like being very correct \n * some time later...\n */\nint socks5_connect(int sockfd, const char *host, int port, AyProxyData *proxy)\n{\n\tint i;\n\tchar buff[530];\n\tint need_auth = 0;\n\tstruct addrinfo *result = NULL;\n\tint j;\n\n\tbuff[0] = 0x05;\t\t/* use socks v5 */\n\tif (proxy->username && proxy->username[0]) {\n\t\tbuff[1] = 0x02;\t/* we support (no authentication & username/pass) */\n\t\tbuff[2] = 0x00;\t/* we support the method type \"no authentication\" */\n\t\tbuff[3] = 0x02;\t/* we support the method type \"username/passw\" */\n\t\tneed_auth = 1;\n\t} else {\n\t\tbuff[1] = 0x01;\t/* we support (no authentication) */\n\t\tbuff[2] = 0x00;\t/* we support the method type \"no authentication\" */\n\t}\n\n\twrite(sockfd, buff, 3 + ((proxy->username\n\t\t\t\t&& proxy->username[0]) ? 1 : 0));\n\n\tif (read(sockfd, buff, 2) < 0) {\n\t\tclose(sockfd);\n\t\treturn AY_SOCKS5_CONNECT_FAIL;\n\t}\n\tif (buff[1] == 0x00)\n\t\tneed_auth = 0;\n\telse if (buff[1] == 0x02 && proxy->username && proxy->username[0])\n\t\tneed_auth = 1;\n\telse {\n\t\tfprintf(stderr, \"No Acceptable Methods\");\n\t\treturn AY_SOCKS5_CONNECT_FAIL;\n\t}\n\tif (((proxy->username && proxy->username[0]) ? 1 : 0)) {\n\t\t/* subneg start */\n\t\tbuff[0] = 0x01;\t/* subneg version  */\n\t\tprintf(\"[%d]\", buff[0]);\n\t\tbuff[1] = strlen(proxy->username);\t/* username length */\n\t\tprintf(\"[%d]\", buff[1]);\n\t\tfor (i = 0; proxy->username[i] && i < 255; i++) {\n\t\t\tbuff[i + 2] = proxy->username[i];\t/* AUTH         */\n\t\t\tprintf(\"%c\", buff[i + 2]);\n\t\t}\n\t\ti += 2;\n\t\tbuff[i] = strlen(proxy->password);\n\t\tprintf(\"[%d]\", buff[i]);\n\t\ti++;\n\t\tfor (j = 0; j < proxy->password[j] && j < 255; j++) {\n\t\t\tbuff[i + j] = proxy->password[j];\t/* AUTH         */\n\t\t\tprintf(\"%c\", buff[i + j]);\n\t\t}\n\t\ti += (j);\n\t\tbuff[i] = 0;\n\n\t\twrite(sockfd, buff, i);\n\n\t\tif (read(sockfd, buff, 2) < 0) {\n\t\t\tclose(sockfd);\n\t\t\treturn AY_SOCKS5_CONNECT_FAIL;\n\t\t}\n\n\t\tif (buff[1] != 0)\n\t\t\treturn AY_PROXY_PERMISSION_DENIED;\n\t}\n\n\tbuff[0] = 0x05;\t\t/* use socks5 */\n\tbuff[1] = 0x01;\t\t/* connect only SOCK_STREAM for now */\n\tbuff[2] = 0x00;\t\t/* reserved */\n\tbuff[3] = 0x01;\t\t/* ipv4 address */\n\n\tif ((result = lookup_address(host, port, AF_UNSPEC)) == NULL)\n\t\treturn AY_HOSTNAME_LOOKUP_FAIL;\n\n\tmemcpy(buff + 4, &(((struct sockaddr_in *)result->ai_addr)->sin_addr),\n\t\t4);\n\tmemcpy((buff + 8), &(((struct sockaddr_in *)result->ai_addr)->sin_port),\n\t\t2);\n\n\tfreeaddrinfo(result);\n\n\twrite(sockfd, buff, 10);\n\n\tif (read(sockfd, buff, 10) < 0) {\n\t\tclose(sockfd);\n\t\treturn AY_SOCKS5_CONNECT_FAIL;\n\t}\n\n\tif (buff[1] != 0x00) {\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tprintf(\"%03d \", buff[i]);\n\n\t\tprintf(\"%d\", ntohs(*(unsigned short *)&buff[8]));\n\t\tprintf(\"\\n\");\n\t\tfprintf(stderr, \"SOCKS error number %d\\n\", buff[1]);\n\t\tclose(sockfd);\n\t\treturn AY_CONNECTION_REFUSED;\n\t}\n\n\treturn AY_NONE;\n}\n\nint http_connect(int sockfd, const char *host, int port, AyProxyData *proxy)\n{\n\t/* step two : do  proxy tunneling init */\n\tchar cmd[512];\n\tchar *inputline = NULL;\n\tchar *proxy_auth = NULL;\n\tchar debug_buff[512];\n\tint remaining = sizeof(cmd) - 1;\n\n\tremaining -= snprintf(cmd, sizeof(cmd), \"CONNECT %s:%d HTTP/1.1\\r\\n\", host, port);\n\tif (proxy->username && proxy->username[0]) {\n\t\tproxy_auth = encode_proxy_auth_str(proxy);\n\n\t\tstrncat(cmd, \"Proxy-Authorization: Basic \", remaining);\n\t\tremaining -= 27;\n\t\tstrncat(cmd, proxy_auth, remaining);\n\t\tremaining -= strlen(proxy_auth);\n\t\tstrncat(cmd, \"\\r\\n\", remaining);\n\t\tremaining -= 2;\n\t}\n\tstrncat(cmd, \"\\r\\n\", remaining);\n#ifndef DEBUG\n\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", cmd);\n\tdebug_print(debug_buff);\n#endif\n\tif (send(sockfd, cmd, strlen(cmd), 0) < 0)\n\t\treturn AY_CONNECTION_REFUSED;\n\tif (ay_recv_line(sockfd, &inputline) < 0)\n\t\treturn AY_CONNECTION_REFUSED;\n#ifndef DEBUG\n\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", inputline);\n\tdebug_print(debug_buff);\n#endif\n\tif (!strstr(inputline, \"200\")) {\n\t\t/* Check if proxy authorization needed */\n\t\tif (strstr(inputline, \"407\")) {\n\t\t\twhile (ay_recv_line(sockfd, &inputline) > 0) {\n\t\t\t\tfree(inputline);\n\t\t\t}\n\t\t\treturn AY_PROXY_AUTH_REQUIRED;\n\t\t}\n\t\tif (strstr(inputline, \"403\")) {\n\t\t\twhile (ay_recv_line(sockfd, &inputline) > 0) {\n\t\t\t\tfree(inputline);\n\t\t\t}\n\t\t\treturn AY_PROXY_PERMISSION_DENIED;\n\t\t}\n\t\tfree(inputline);\n\t\treturn AY_CONNECTION_REFUSED;\n\t}\n\n\twhile (strlen(inputline) > 1) {\n\t\tfree(inputline);\n\t\tif (ay_recv_line(sockfd, &inputline) < 0) {\n\t\t\treturn AY_CONNECTION_REFUSED;\n\t\t}\n#ifndef DEBUG\n\t\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", inputline);\n\t\tdebug_print(debug_buff);\n#endif\n\t}\n\tfree(inputline);\n\n\tg_free(proxy_auth);\n\n\treturn 0;\n}\n\nstatic char *encode_proxy_auth_str(AyProxyData *proxy)\n{\n\tchar *buff = NULL;\n\tchar *ret = NULL;\n\n\tif (proxy->username == NULL)\n\t\treturn NULL;\n\n\tbuff = g_strdup_printf(\"%s:%s\", proxy->username, proxy->password);\n\n\tret = g_base64_encode((unsigned char *)buff, strlen(buff));\n\tg_free (buff);\n\n\treturn ret;\n}\n"], "fixing_code": ["/*\n * Ayttm\n *\n * Copyright (C) 2003, 2009 the Ayttm team\n * \n * Ayttm is a derivative of Everybuddy\n * Copyright (C) 1998-1999, Torrey Searle\n * proxy featured by Seb C.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n */\n\n/* this is a little piece of code to handle proxy connection */\n/* it is intended to : 1st handle http proxy, using the CONNECT command\n , 2nd provide an easy way to add socks support */\n\n#include \"intl.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#ifdef __MINGW32__\n#include <winsock2.h>\n#else\n#include <sys/socket.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#endif\n\n#include \"proxy.h\"\n#include \"proxy_private.h\"\n#include \"common.h\"\n#include \"net_constants.h\"\n\n#include <glib.h>\n\n#ifdef __MINGW32__\n#define sleep(a)\t\tSleep(1000*a)\n\n#define bcopy(a,b,c)\tmemcpy(b,a,c)\n#define bzero(a,b)\t\tmemset(a,0,b)\n\n#define ECONNREFUSED\tWSAECONNREFUSED\n#endif\n\n/* Prototypes */\nstatic char *encode_proxy_auth_str(AyProxyData *proxy);\n\n#define debug_print printf\n\n/* \n * External function to use to set the proxy settings\n */\nint ay_proxy_set_default(AyProxyType type, const char *host, int port,\n\tchar *username, char *password)\n{\n\tif (!default_proxy)\n\t\tdefault_proxy = g_new0(AyProxyData, 1);\n\n\tdefault_proxy->type = type;\n\n\tif (type == PROXY_NONE) {\n\t\tif (default_proxy->host)\n\t\t\tfree(default_proxy->host);\n\n\t\tif (default_proxy->username)\n\t\t\tfree(default_proxy->username);\n\n\t\tif (default_proxy->password)\n\t\t\tfree(default_proxy->password);\n\n\t\tg_free(default_proxy);\n\t\tdefault_proxy = NULL;\n\t} else {\n\t\tdefault_proxy->port = 0;\n\n\t\tif (host != NULL && host[0]) {\n\t\t\tdefault_proxy->host = strdup(host);\n\t\t\tdefault_proxy->port = port;\n\t\t}\n\t\tif (default_proxy->port == 0)\n\t\t\tdefault_proxy->port = 3128;\n\n\t\tif (username && username[0])\n\t\t\tdefault_proxy->username = strdup(username);\n\n\t\tif (password && password[0])\n\t\t\tdefault_proxy->password = strdup(password);\n\n\t}\n#ifdef __MINGW32__\n\t{\n\t\tWSADATA wsaData;\n\t\tWSAStartup(MAKEWORD(2, 0), &wsaData);\n\t}\n#endif\n\treturn (0);\n}\n\n/* http://archive.socks.permeo.com/protocol/socks4.protocol */\nint socks4_connect(int sock, const char *host, int port, AyProxyData *proxy)\n{\n\tint i, packetlen;\n\n\tunsigned char *packet = NULL;\n\tstruct addrinfo *result = NULL;\n\n\tint retval = 0;\n\n\tif (proxy->username && proxy->username[0])\n\t\tpacketlen = 9 + strlen(proxy->username);\n\telse\n\t\tpacketlen = 9;\n\n\tresult = lookup_address(host, port, AF_INET);\n\n\tif (!result)\n\t\treturn AY_HOSTNAME_LOOKUP_FAIL;\n\n\tpacket = (unsigned char *)calloc(packetlen, sizeof(unsigned char));\n\n\tpacket[0] = 4;\t\t/* Version */\n\tpacket[1] = 1;\t\t/* CONNECT  */\n\tpacket[2] = (((unsigned short)port) >> 8);\t/* DESTPORT */\n\tpacket[3] = (((unsigned short)port) & 0xff);\t/* DESTPORT */\n\n\t/* DESTIP */\n\tbcopy(packet + 4, &(((struct sockaddr_in *)result->ai_addr)->sin_addr),\n\t\t4);\n\n\tfreeaddrinfo(result);\n\n\tif (proxy->username && proxy->username[0]) {\n\t\tfor (i = 0; proxy->username[i]; i++) {\n\t\t\tpacket[i + 8] = (unsigned char)proxy->username[i];\t/* AUTH      */\n\t\t}\n\t}\n\tpacket[packetlen - 1] = 0;\t/* END          */\n\tdebug_print(\"Sending \\\"%s\\\"\\n\", packet);\n\tif (write(sock, packet, packetlen) == packetlen) {\n\t\tbzero(packet, sizeof(packet));\n\t\t/* Check response - return as SOCKS4 if its valid */\n\t\tif (read(sock, packet, 9) >= 4) {\n\t\t\tif (packet[1] == 90) {\n\t\t\t\treturn 0;\n\t\t\t} else if (packet[1] == 91)\n\t\t\t\tretval = AY_SOCKS4_UNKNOWN;\n\t\t\telse if (packet[1] == 92)\n\t\t\t\tretval = AY_SOCKS4_IDENTD_FAIL;\n\t\t\telse if (packet[1] == 93)\n\t\t\t\tretval = AY_SOCKS4_IDENT_USER_DIFF;\n\t\t\telse {\n\t\t\t\tretval = AY_SOCKS4_INCOMPATIBLE_ERROR;\n\t\t\t\tprintf(\"=>>%d\\n\", packet[1]);\n\t\t\t}\n\t\t} else {\n\t\t\tprintf(\"short read %s\\n\", packet);\n\t\t}\n\t}\n\tclose(sock);\n\n\treturn retval;\n}\n\n/* http://archive.socks.permeo.com/rfc/rfc1928.txt */\n/* http://archive.socks.permeo.com/rfc/rfc1929.txt */\n\n/* \n * Removed support for datagram connections because we're not even using it now. \n * I'll add it back if/when it is needed or if I feel like being very correct \n * some time later...\n */\nint socks5_connect(int sockfd, const char *host, int port, AyProxyData *proxy)\n{\n\tint i;\n\tchar buff[530];\n\tint need_auth = 0;\n\tstruct addrinfo *result = NULL;\n\tint j;\n\n\tbuff[0] = 0x05;\t\t/* use socks v5 */\n\tif (proxy->username && proxy->username[0]) {\n\t\tbuff[1] = 0x02;\t/* we support (no authentication & username/pass) */\n\t\tbuff[2] = 0x00;\t/* we support the method type \"no authentication\" */\n\t\tbuff[3] = 0x02;\t/* we support the method type \"username/passw\" */\n\t\tneed_auth = 1;\n\t} else {\n\t\tbuff[1] = 0x01;\t/* we support (no authentication) */\n\t\tbuff[2] = 0x00;\t/* we support the method type \"no authentication\" */\n\t}\n\n\twrite(sockfd, buff, 3 + ((proxy->username\n\t\t\t\t&& proxy->username[0]) ? 1 : 0));\n\n\tif (read(sockfd, buff, 2) < 0) {\n\t\tclose(sockfd);\n\t\treturn AY_SOCKS5_CONNECT_FAIL;\n\t}\n\tif (buff[1] == 0x00)\n\t\tneed_auth = 0;\n\telse if (buff[1] == 0x02 && proxy->username && proxy->username[0])\n\t\tneed_auth = 1;\n\telse {\n\t\tfprintf(stderr, \"No Acceptable Methods\");\n\t\treturn AY_SOCKS5_CONNECT_FAIL;\n\t}\n\tif (((proxy->username && proxy->username[0]) ? 1 : 0)) {\n\t\t/* subneg start */\n\t\tbuff[0] = 0x01;\t/* subneg version  */\n\t\tprintf(\"[%d]\", buff[0]);\n\t\tbuff[1] = strlen(proxy->username);\t/* username length */\n\t\tprintf(\"[%d]\", buff[1]);\n\t\tfor (i = 0; proxy->username[i] && i < 255; i++) {\n\t\t\tbuff[i + 2] = proxy->username[i];\t/* AUTH         */\n\t\t\tprintf(\"%c\", buff[i + 2]);\n\t\t}\n\t\ti += 2;\n\t\tbuff[i] = strlen(proxy->password);\n\t\tprintf(\"[%d]\", buff[i]);\n\t\ti++;\n\t\tfor (j = 0; j < proxy->password[j] && j < 255; j++) {\n\t\t\tbuff[i + j] = proxy->password[j];\t/* AUTH         */\n\t\t\tprintf(\"%c\", buff[i + j]);\n\t\t}\n\t\ti += (j);\n\t\tbuff[i] = 0;\n\n\t\twrite(sockfd, buff, i);\n\n\t\tif (read(sockfd, buff, 2) < 0) {\n\t\t\tclose(sockfd);\n\t\t\treturn AY_SOCKS5_CONNECT_FAIL;\n\t\t}\n\n\t\tif (buff[1] != 0)\n\t\t\treturn AY_PROXY_PERMISSION_DENIED;\n\t}\n\n\tbuff[0] = 0x05;\t\t/* use socks5 */\n\tbuff[1] = 0x01;\t\t/* connect only SOCK_STREAM for now */\n\tbuff[2] = 0x00;\t\t/* reserved */\n\tbuff[3] = 0x01;\t\t/* ipv4 address */\n\n\tif ((result = lookup_address(host, port, AF_UNSPEC)) == NULL)\n\t\treturn AY_HOSTNAME_LOOKUP_FAIL;\n\n\tmemcpy(buff + 4, &(((struct sockaddr_in *)result->ai_addr)->sin_addr),\n\t\t4);\n\tmemcpy((buff + 8), &(((struct sockaddr_in *)result->ai_addr)->sin_port),\n\t\t2);\n\n\tfreeaddrinfo(result);\n\n\twrite(sockfd, buff, 10);\n\n\tif (read(sockfd, buff, 10) < 0) {\n\t\tclose(sockfd);\n\t\treturn AY_SOCKS5_CONNECT_FAIL;\n\t}\n\n\tif (buff[1] != 0x00) {\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tprintf(\"%03d \", buff[i]);\n\n\t\tprintf(\"%d\", ntohs(*(unsigned short *)&buff[8]));\n\t\tprintf(\"\\n\");\n\t\tfprintf(stderr, \"SOCKS error number %d\\n\", buff[1]);\n\t\tclose(sockfd);\n\t\treturn AY_CONNECTION_REFUSED;\n\t}\n\n\treturn AY_NONE;\n}\n\nint http_connect(int sockfd, const char *host, int port, AyProxyData *proxy)\n{\n\t/* step two : do  proxy tunneling init */\n\tchar cmd[512];\n\tchar *inputline = NULL;\n\tchar *proxy_auth = NULL;\n\tint remaining = sizeof(cmd) - 1;\n\n\tremaining -= snprintf(cmd, sizeof(cmd), \"CONNECT %s:%d HTTP/1.1\\r\\n\", host, port);\n\tif (proxy->username && proxy->username[0]) {\n\t\tproxy_auth = encode_proxy_auth_str(proxy);\n\n\t\tstrncat(cmd, \"Proxy-Authorization: Basic \", remaining);\n\t\tremaining -= 27;\n\t\tstrncat(cmd, proxy_auth, remaining);\n\t\tremaining -= strlen(proxy_auth);\n\t\tstrncat(cmd, \"\\r\\n\", remaining);\n\t\tremaining -= 2;\n\t}\n\tstrncat(cmd, \"\\r\\n\", remaining);\n#ifdef DEBUG\n\tdebug_print(\"<%s>\\n\", cmd);\n#endif\n\tif (send(sockfd, cmd, strlen(cmd), 0) < 0)\n\t\treturn AY_CONNECTION_REFUSED;\n\tif (ay_recv_line(sockfd, &inputline) < 0)\n\t\treturn AY_CONNECTION_REFUSED;\n#ifdef DEBUG\n\tdebug_print(\"<%s>\\n\", inputline);\n#endif\n\tif (!strstr(inputline, \"200\")) {\n\t\t/* Check if proxy authorization needed */\n\t\tif (strstr(inputline, \"407\")) {\n\t\t\twhile (ay_recv_line(sockfd, &inputline) > 0) {\n\t\t\t\tfree(inputline);\n\t\t\t}\n\t\t\treturn AY_PROXY_AUTH_REQUIRED;\n\t\t}\n\t\tif (strstr(inputline, \"403\")) {\n\t\t\twhile (ay_recv_line(sockfd, &inputline) > 0) {\n\t\t\t\tfree(inputline);\n\t\t\t}\n\t\t\treturn AY_PROXY_PERMISSION_DENIED;\n\t\t}\n\t\tfree(inputline);\n\t\treturn AY_CONNECTION_REFUSED;\n\t}\n\n\twhile (strlen(inputline) > 1) {\n\t\tfree(inputline);\n\t\tif (ay_recv_line(sockfd, &inputline) < 0) {\n\t\t\treturn AY_CONNECTION_REFUSED;\n\t\t}\n#ifdef DEBUG\n\t\tdebug_print(\"<%s>\\n\", inputline);\n#endif\n\t}\n\tfree(inputline);\n\n\tg_free(proxy_auth);\n\n\treturn 0;\n}\n\nstatic char *encode_proxy_auth_str(AyProxyData *proxy)\n{\n\tchar *buff = NULL;\n\tchar *ret = NULL;\n\n\tif (proxy->username == NULL)\n\t\treturn NULL;\n\n\tbuff = g_strdup_printf(\"%s:%s\", proxy->username, proxy->password);\n\n\tret = g_base64_encode((unsigned char *)buff, strlen(buff));\n\tg_free (buff);\n\n\treturn ret;\n}\n"], "filenames": ["libproxy/proxy.c"], "buggy_code_start_loc": [297], "buggy_code_end_loc": [350], "fixing_code_start_loc": [296], "fixing_code_end_loc": [346], "type": "CWE-134", "message": "A vulnerability, which was classified as critical, was found in ayttm up to 0.5.0.89. This affects the function http_connect in the library libproxy/proxy.c. The manipulation leads to format string. It is possible to initiate the attack remotely. The name of the patch is 40e04680018614a7d2b68566b261b061a0597046. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-222267.", "other": {"cve": {"id": "CVE-2015-10088", "sourceIdentifier": "cna@vuldb.com", "published": "2023-03-05T05:15:09.210", "lastModified": "2023-03-13T16:55:56.763", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability, which was classified as critical, was found in ayttm up to 0.5.0.89. This affects the function http_connect in the library libproxy/proxy.c. The manipulation leads to format string. It is possible to initiate the attack remotely. The name of the patch is 40e04680018614a7d2b68566b261b061a0597046. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-222267."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-134"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ayttm_project:ayttm:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.5.0-89", "matchCriteriaId": "50590714-3CEF-4C65-906E-B7CCC8E8F618"}]}]}], "references": [{"url": "https://github.com/ayttm/ayttm/commit/40e04680018614a7d2b68566b261b061a0597046", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://sourceforge.net/p/ayttm/mailman/message/34397158/", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.222267", "source": "cna@vuldb.com", "tags": ["Permissions Required"]}, {"url": "https://vuldb.com/?id.222267", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ayttm/ayttm/commit/40e04680018614a7d2b68566b261b061a0597046"}}