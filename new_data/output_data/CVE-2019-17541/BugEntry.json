{"buggy_code": ["2019-07-16  7.0.8-54 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-54, GIT revision 15916:e868e22:20190716.\n\n2019-07-08  7.0.8-54 Cristy  <quetzlzacatenango@image...>\n   * resolve division by zero  (reference\n     https://github.com/ImageMagick/ImageMagick/issues/1629).\n   * introducing MagickLevelImageColors() MagickWand method.\n  * Transient problem with text placement with gravity (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1633).\n  * Support TIM2 image format (reference\n    https://github.com/ImageMagick/ImageMagick/pull/1571).\n  * For -magnify option, specify an alternative scaling method with -define\n\t  magnify:method=method, choose from these methods: eagle2X, eagle3X,\n    eagle3XB, epb2X, fish2X, hq2X,  scale2X (default), scale3X, xbr2X.\n\n2019-07-05  7.0.8-53 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-53, GIT revision 15828:f5d59c0:20190705.\n\n2019-07-05  7.0.8-53 Cristy  <quetzlzacatenango@image...>\n   * Fix -fx parsing issue (reference\n     https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=36314).\n\n2019-07-05  7.0.8-52 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-52, GIT revision 15825:ea47310:20190705.\n\n2019-07-01  7.0.8-52 Cristy  <quetzlzacatenango@image...>\n  * Eliminate buffer overflow in TranslateEvent() (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1621).\n\n2019-06-30  7.0.8-51 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-51, GIT revision 15812:51f11c4:20190630.\n\n2019-06-24  7.0.8-51 Cristy  <quetzlzacatenango@image...>\n  * Clone rather than copy X window name/icon.\n  * Optimize PDF reader.\n\n2019-06-23  7.0.8-50 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-50, GIT revision 15778:4a60519:20190623\n\n2019-06-14  7.0.8-50 Dirk Lemstra <dirk@lem.....org>\n  * Added support for reading all images from a HEIC image (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1391).\n  * Heap-buffer-overflow in MagickCore/fourier.c (reference\n   https://github.com/ImageMagick/ImageMagick/issues/1588).\n  * Fixed a number of issues (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-06-08  7.0.8-49 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-49, GIT revision 15708:6d7e1db:20190608\n\n2019-06-03  7.0.8-49 Cristy  <quetzlzacatenango@image...>\n  * Add support for RGB565 image format (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=2&t=36078).\n  * Use user defined allocator instead of `malloc` (reference\n    https://github.com/ImageMagick/ImageMagick6/pull/49/).\n  * Add static decorator to accelerator kernels (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1366).\n\n2019-06-01  7.0.8-48 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-48, GIT revision 15689:061a3bb82:20190601\n\n2019-06-01  7.0.8-48 Cristy  <quetzlzacatenango@image...>\n  * Fix transient convolution bug (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=36119).\n\n2019-05-26  7.0.8-47 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-47, GIT revision 15681:5cffc6cbb:20190526\n\n2019-05-19  7.0.8-47 Cristy  <quetzlzacatenango@image...>\n  * Support 16 and 32 bit tiled float TIFF images.\n  * Convolve morphology alpha channel fix (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=36086).\n  * Text improvements to the internal SVG renderer.\n\n2019-05-14  7.0.8-46 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-46, GIT revision 15655:84dd3301c:20190518\n\n2019-05-14  7.0.8-46 Cristy  <quetzlzacatenango@image...>\n  * PerlMagick unit tests pass again.\n  * Builds under MacOS X and FreeBSD works again.\n  * Return HEIC images in the sRGB colorspace.\n\n2019-05-12  7.0.8-45 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-45, GIT revision 15634:784105bcb:20190512\n\n2019-05-06  7.0.8-45 Cristy  <quetzlzacatenango@image...>\n  * Fix image signatures to ensure they are Q-depth invariant (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=35970).\n  * Fixed a number of issues (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-05-03  7.0.8-44 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-44, GIT revision 15600:41f47759a:20190503\n\n2019-05-03  7.0.8-44 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-05-01  7.0.8-43 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-43, GIT revision 15595:0062cef74:20190502\n\n2019-05-01  7.0.8-43 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-04-29  7.0.8-42 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-42, GIT revision 15570:71190ccd0:20190424\n\n2019-04-20  7.0.8-42 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-04-19  7.0.8-41 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-41, GIT revision 15540:c78993d13:20190420\n\n2019-04-13  7.0.8-41 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * Honor SOURCE_DATE_EPOCH environment variable (reference\n    https://github.com/ImageMagick/ImageMagick/pull/1496/).\n  * Standardize on UTC time for any image format timestamp.\n  * Add MagickAutoThresholdImage(), MagickCannyEdgeImage(),\n    MagickComplexImages(), MagickConnectedComponentsImage(),\n    MagickHoughLineImage(), MagickKuwaharaImage(), MagickLevelizeImageColors(),\n    MagickLevelImageColors(), MagickMeanShiftImage(), MagickPolynomialImage(),\n    MagickRangeThresholdImage(), MagickSetSeed(), MagickWaveletDenoiseImage()\n    methods to MagickWand API.\n\n2019-04-12  7.0.8-40 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-40, GIT revision 15510:7e503e231:20190412\n\n2019-04-10  7.0.8-40 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n\n2019-04-07  7.0.8-39 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-39, GIT revision 15489:6120f8bc1:20190406\n\n2019-04-06  7.0.8-39 Cristy  <quetzlzacatenango@image...>\n  * The -layers option compared pixels inocorrectly as opacity rather than\n    alpha.\n  * The -preview raise option now returns expected results.\n  * Initialise ghostscript instances with NULL (reference\n    https://github.com/ImageMagick/ImageMagick/pull/1538).\n\n2019-04-06  7.0.8-38 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-38, GIT revision 15483:23edcef04:20190406\n\n2019-04-06  7.0.8-38 Cristy  <quetzlzacatenango@image...>\n  * Modulo off by one patch for -virtual-pixel option (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=35789).\n\n2019-04-03  7.0.8-37 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-37, GIT revision 15470:477216fd7:20190403\n\n2019-04-03  7.0.8-37 Cristy  <quetzlzacatenango@image...>\n  * Fixed -virtual-pixel option (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=35789).\n\n2019-03-31  7.0.8-36 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-36, GIT revision 15464:3a928224d:20190331\n\n2019-03-27  7.0.8-36 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-03-24  7.0.8-35 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-35, GIT revision 15440:4a0a88e41:20190324\n\n2019-03-23  7.0.8-35 Cristy  <quetzlzacatenango@image...>\n  * -draw image DstOver is now responsive to the composite operator (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=35650).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-03-15  7.0.8-34 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-34, GIT revision 15413:860af935d:20190315\n\n2019-03-11  7.0.8-34 Cristy  <quetzlzacatenango@image...>\n  * Associate one lock with each resource.\n  * Report exception if opening TIFF did not work out.\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2019-03-10  7.0.8-33 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-33, GIT revision 15401:c805e3205:20190310\n\n2019-03-06  7.0.8-33 Cristy  <quetzlzacatenango@image...>\n  * Fix SVG conversion infinite loop (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=35591).\n  * Initialize primitive drawing structure after resizing.\n\n2019-03-05  7.0.8-32 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-32, GIT revision 15386:58d9c4692:20190305\n\n2019-03-05  7.0.8-32 Cristy  <quetzlzacatenango@image...>\n  * Fix out-of-boundary LocaleLowerCase() @\n    https://github.com/ImageMagick/ImageMagick/issues/1495\n\n2019-03-04  7.0.8-31 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-31, GIT revision 15381:3122a669d:20190304\n\n2019-03-04  7.0.8-31 Cristy  <quetzlzacatenango@image...>\n  * -trim is no longer sensitive to the image virtual canvas.\n\n2019-03-03  7.0.8-30 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-30, GIT revision 15376:16d2b4e6a:20190303\n\n2019-03-03  7.0.8-30 Cristy  <quetzlzacatenango@image...>\n  * Support define to remove additional background from an image during a\n    trim, e.g. -fuzz 5% -define trim:percent-background=0% -trim.\n\n2019-02-28  7.0.8-29 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-29, GIT revision 15368:5d8ed9f56:20190228\n\n2019-02-28  7.0.8-29 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2019-02-18  7.0.8-28 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-28, GIT revision 15345:09a7c67dd:20190218\n\n2019-02-12  7.0.8-28 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-02-09  7.0.8-27 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-27, GIT revision 15315:5d48cd312:20190209\n\n2019-02-09  7.0.8-27 Cristy  <quetzlzacatenango@image...>\n  * Mod patch to properly handle subimage ranges (e.g. image.gif[2-3]).\n\n2019-02-03  7.0.8-26 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-26, GIT revision 15294:726bd82a3:20190203\n\n2019-02-02  7.0.8-26 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-01-27  7.0.8-25 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-25, GIT revision 15279:7da783a5b:20190127\n\n2019-01-19  7.0.8-25 Cristy  <quetzlzacatenango@image...>\n  * Eliminate spurious font warning (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1458).\n  * Support HEIC EXIF & XMP profiles.\n\n2019-01-12  7.0.8-24 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-24, GIT revision 15233:db129ba64:20190112\n\n2019-01-08  7.0.8-24 Cristy  <quetzlzacatenango@image...>\n  * Support -clahe option real clip limit (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=2&t=35292).\n  * ShadeImage() kernels can return negative pixels, clamp to range (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1319).\n  * Annotate with negative offsets no longer renders slanted text.\n\n2019-01-01  7.0.8-23 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-23, GIT revision 15199:ba07f7d07:20190101\n\n2019-01-01  7.0.8-23 Cristy  <quetzlzacatenango@image...>\n  * CacheInfo destructor must be aligned in DestroyPixelStream().\n\n2018-12-30  7.0.8-22 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-22, GIT revision 15189:842164090:20181230\n\n2018-12-29  7.0.8-22 Cristy  <quetzlzacatenango@image...>\n  * Support negative rotations in a geometry (e.g. -10x-10+10+10).\n  * Return expected canvas offset after a crop with gravity.\n\n2018-12-27  7.0.8-21 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-21, GIT revision 15179:114be1716:20181227\n\n2018-12-27  7.0.8-21 Cristy  <quetzlzacatenango@image...>\n  * Check to ensure SeekBlob() offset can be represented in an off_t.\n\n2018-12-23  7.0.8-20 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-20, GIT revision 15170:8e8222e87:20181223\n\n2018-12-23  7.0.8-20 Cristy  <quetzlzacatenango@image...>\n  * Cube image format returns a HALD image.\n  * CLAHE tiles overlapped are now centered relative to the image.\n\n2018-12-19  7.0.8-19 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-19, GIT revision 15153:e74ed77f5:20181219\n\n2018-12-18  7.0.8-18 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-18, GIT revision 15146:b5eccd295:20181218\n\n2018-12-18  7.0.8-18 Cristy  <quetzlzacatenango@image...>\n  * Fixed Magick++ compile error on Mac OS X.\n\n2018-12-17  7.0.8-17 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-17, GIT revision 15142:32f2d195e:20181217\n\n2018-12-02  7.0.8-16 Cristy  <quetzlzacatenango@image...>\n  * Support -clahe clip limit with percentages (e.g. -clahe 50x50%+128+3).\n\n2018-12-10  7.0.8-16 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-16, GIT revision 15109:9a9af88de:20181210.\n\n2018-12-02  7.0.8-16 Cristy  <quetzlzacatenango@image...>\n  * Check for modulo underflow.\n  * Change SVG default DPI to 96 from 90 to meet recommendation of SVG2 & CSS.\n\n2018-12-01  7.0.8-15 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-15, GIT revision 15059:2fb22e07b:20181201\n\n2018-11-21  7.0.8-15 Cristy  <quetzlzacatenango@image...>\n  * Added support for the -clahe option: contrast limited adaptive histogram\n    equalization.\n\n2018-11-13  7.0.8-15 Dirk Lemstra <dirk@lem.....org>\n  * Added support for GIMP 2.10 files (reference\n    https://github.com/ImageMagick/ImageMagick/pull/1381).\n\n2018-10-23  7.0.8-14 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-14, GIT revision 14943:1a0da3dd0:20181023\n\n2018-10-21  7.0.8-13 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-13, GIT revision 14936:d3ec5abe2:20181021.\n\n2018-10-04  7.0.8-13 Dirk Lemstra <dirk@lem.....org>\n  * Adding coder headers with magic.xml will no longer be supported.\n  * Adding coder aliases with coder.xml will no longer be supported.\n\n2018-09-16  7.0.8-12 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-12, GIT revision 14843:cb5cf1959:20180923\n\n2018-09-15  7.0.8-12 Dirk Lemstra <dirk@lem.....org>\n  * Added support for arithmetic coding to the jpeg encoder:\n    -define jpeg:arithmetic-coding=true.\n\n2018-09-08  7.0.8-12 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-08-28  7.0.8-11 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-11, GIT revision 14729:798fbdb5b:20180828\n\n2018-08-15  7.0.8-11 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n  * Add support for \"module\" security policy.\n\n2018-08-13  7.0.8-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-10, GIT revision 14646:48fba3256:20180813\n\n2018-08-12  7.0.8-10 Dirk Lemstra <dirk@lem.....org>\n  * Added dcraw coder (dcraw:img.cr2) that can be used to force the use of the\n    dcraw delegate when libraw is the default raw delegate.\n  * Restored thread support for the HEIC coder.\n\n2018-08-08  7.0.8-10 Cristy  <quetzlzacatenango@image...>\n  * ThumbnailImage function no longer reveals sensitive information (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1243).\n\n2018-08-06  7.0.8-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-9, GIT revision 14618:a3663c3dc:20180805.\n\n2018-07-24  7.0.8-9 Cristy  <quetzlzacatenango@image...>\n  * XBM coder leaves the hex image data uninitialized if hex value of the\n    pixel is negative.\n  * More improvements to SVG text handling.\n  * New -range-threshold option that combines hard and soft thresholding.\n\n2018-07-23  7.0.8-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-8, GIT revision 14583:300fdbcfd:20180723.\n\n2018-07-20  7.0.8-8 Cristy  <quetzlzacatenango@image...>\n  * Non-HDRI ScaleLongToQuantum() private method no longer adds a half interval.\n  * Fixed memset() negative-size-param (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1217).\n\n2018-07-16  7.0.8-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-7, GIT revision 14561:f85c23180:20180716.\n\n2018-07-15  7.0.8-7 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-07-08  7.0.8-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-6, GIT revision 14541:db940ccd2:20180708.\n\n2018-07-06  7.0.8-6 Cristy  <quetzlzacatenango@image...>\n  * Improve SVG support for tspan element.\n  * Add support for -fx image.extent.\n\n2018-07-04  7.0.8-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-5, GIT revision 14514:bba545bbb:20180704.\n\n2018-07-04  7.0.8-5 Cristy  <quetzlzacatenango@image...>\n  * Fixed a few potential memory leaks\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2018-07-02  7.0.8-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-4, GIT revision 14505:4613eed4a:20180702.\n\n2018-06-28  7.0.8-4 Cristy  <quetzlzacatenango@image...>\n  * Small tweaks to compile under Cygwin.\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n  * Support %B property, the image file size without any decorations.\n\n2018-06-24  7.0.8-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-3, GIT revision 14489:c63c504e8:20180624.\n\n2018-06-24  7.0.8-3 Cristy  <quetzlzacatenango@image...>\n  * Apply translate component of SVG transform rotate.\n\n2018-06-18  7.0.8-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-2, GIT revision 14476:cda11d81d:20180618.\n\n2018-06-18  7.0.8-2 Cristy  <quetzlzacatenango@image...>\n  * More robust SVG text handling.\n\n2018-06-16  7.0.8-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-1, GIT revision 14468:94cb08785:20180616.\n\n2018-06-16  7.0.8-1 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n  * Fixed an issue with stroke and label: (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=34142).\n  * PNG: set storage class to DirectClass if alpha enabled (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=34121).\n\n2018-06-12  7.0.8-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-0, GIT revision 14459:d7c892d5a:20180612.\n\n2018-06-11  7.0.8-0  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-06-11  7.0.7-39 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-39, GIT revision 14445:cc962acde:20180611.\n\n2018-06-06  7.0.7-39  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-06-02  7.0.7-38 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-38, GIT revision 14409:01e395a73:20180602.\n\n2018-05-30  7.0.7-38  <quetzlzacatenango@image...>\n  * Heap buffer overflow fix (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1156).\n  * Boundary issues with -gamma option when HDRI is enabled (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1151).\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-05-29  7.0.7-37 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-37, GIT revision 14393:61d7e8b17:20180529.\n\n2018-05-29  7.0.7-37  <quetzlzacatenango@image...>\n  * Properly initialize SVG color style.\n\n2018-05-28  7.0.7-36 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-36, GIT revision 14390:3a6bd703f:20180528.\n\n2018-05-28  7.0.7-36  <quetzlzacatenango@image...>\n  * A SVG rectangle with a width and height of 1 is a point.\n\n2018-05-21  7.0.7-35 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-35, GIT revision 14356:13507412c:20180521.\n\n2018-05-21  7.0.7-35  <quetzlzacatenango@image...>\n  * Fixed memory corruption for MVG paths.\n\n2018-05-20  7.0.7-34 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-34, GIT revision 14348:ac9ff6ba1:20180520.\n\n2018-05-20  7.0.7-34 Dirk Lemstra <dirk@lem.....org>\n  * Added support for reading eXIf chunks to the PNG coder.\n\n2018-05-19  7.0.7-34  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n  * Improved clip / composite mask handling.\n\n2018-05-16  7.0.7-33 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-33, GIT revision 14326:58c2e4972:20180516.\n\n2018-05-03  7.0.7-33  <quetzlzacatenango@image...>\n  * Restore SetImageAlpha() behavior.\n  * Fix -clip and -mask options.\n\n2018-05-13  7.0.7-32 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-32, GIT revision 14307:f61f674e3:20180513.\n\n2018-05-03  7.0.7-31  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-05-01  7.0.7-30 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-30, GIT revision 14242:730f1d1d3:20180501.\n\n2018-05-01  7.0.7-30  <quetzlzacatenango@image...>\n  * Missing break when checking \"compliance\" element.\n\n2018-04-30  7.0.7-29 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-29, GIT revision 14225:41edbdcea:20180430.\n\n2018-03-26  7.0.7-29  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-03-24  7.0.7-28 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-28, GIT revision 23615:edd71782e:20180325.\n\n2018-03-21  7.0.7-28  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-03-18  7.0.7-27 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-27, GIT revision 23466:734b146df:20180318.\n\n2018-03-17  7.0.7-27  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-03-11  7.0.7-26 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-26, GIT revision 23344:7a03766ef:20180311.\n\n2018-03-10  7.0.7-26  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-03-04  7.0.7-25 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-25, GIT revision 23177:17a986472:20180304.\n\n2018-03-04  7.0.7-25 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-02-25  7.0.7-24 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-24, GIT revision 23079:7ccb76178:20180225.\n\n2018-02-19  7.0.7-24 Cristy  <quetzlzacatenango@image...>\n  * Do not refer to page in OptimizeLayerFrames (reference\n    https://github.com/ImageMagick/ImageMagick/pull/987).\n  * PerlMagick unit tests pass again.\n  * Fixed numerous use of uninitialized values, integer overflow,\n    memory exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-02-18  7.0.7-23 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.0-23, GIT revision 22969:c6b3a22b0:20180218.\n\n2018-02-09  7.0.7-23 Dirk Lemstra <dirk@lem.....org>\n  * Add support for reading the HEIC image format to the Windows build.\n\n2018-01-23  7.0.7-23 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow,\n    memory exceeded, and timeouts (credit to OSS Fuzz).\n  * Add list-length policy to limit the maximum image sequence length.\n\n2018-01-22  7.0.7-22 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.0-22, GIT revision 22391:e8be814f1:20180122.\n\n2018-01-06  7.0.7-22 Cristy  <quetzlzacatenango@image...>\n  * Support aspect ratio geometry, e.g. -crop 3:2.\n  * Add support for reading the HEIC image format (reference\n    https://github.com/ImageMagick/ImageMagick/issues/507).\n  * Fixed numerous memory leaks, credit to OSS Fuzz.\n\n2018-01-06  7.0.7-21 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.0-21, GIT revision 22168:a91afc45b:20180106.\n\n2018-01-06  7.0.7-21 Dirk Lemstra <dirk@lem.....org>\n  * Fix some enum values in the OpenCL code.\n\n2018-01-06  7.0.7-20 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-20, GIT revision 22161:33a04d3e5:20180105.\n\n2018-01-05  7.0.7-20 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2018-01-01  7.0.7-19 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-19, GIT revision 22133:977fe08bf:20180101.\n\n2017-12-29  7.0.7-19 Cristy  <quetzlzacatenango@image...>\n  * Check for webpmux library version 0.4.4 (reference\n    https://github.com/ImageMagick/ImageMagick/issues/896).\n\n2017-12-26  7.0.7-18 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-18, GIT revision 22096:ad4bdeb40:20171228.\n\n2017-12-28  7.0.7-18 Cristy  <quetzlzacatenango@image...>\n  * Fix error reading from pipe under Windows (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=33288).\n\n2017-12-26  7.0.7-17 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-17, GIT revision 22093:9caea323b:20171227.\n\n2017-12-26  7.0.7-17 Cristy  <quetzlzacatenango@image...>\n  * Fix heap use after free error (reference\n    https://github.com/ImageMagick/ImageMagick/issues/918).\n\n2017-12-24  7.0.7-16 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-16, GIT revision 22038:e55dc7626:20171225.\n\n2017-12-18  7.0.7-16 Cristy  <quetzlzacatenango@image...>\n  * Fix error reading multi-layer XCF image file.\n  * Fix possible stack overflow in WEBP reader (reference\n    https://github.com/ImageMagick/ImageMagick/issues/907)\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2017-12-16  7.0.7-15 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-15, GIT revision 21924:30cb31746:20171216.\n\n2017-12-08  7.0.7-15 Cristy  <quetzlzacatenango@image...>\n  * Overall standard deviation is the average of each pixel channel (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Update to the latest ImageMagick documentation.\n\n2017-12-05  7.0.7-14 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-14, GIT revision 21855:dc73b2aba:20171205.\n\n2017-11-30  7.0.7-14 Cristy  <quetzlzacatenango@image...>\n  * Support Stereo composite operator.\n  * Fix build failure with --without-modules (reference\n    https://github.com/ImageMagick/ImageMagick/issues/890).\n\n2017-11-30  7.0.7-13 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-13, GIT revision 21823:72cb0fd0c:20171130.\n\n2017-11-30  7.0.7-13 Cristy  <quetzlzacatenango@image...>\n  * Fix build failure with libraw 0.14.8 (reference\n    https://github.com/ImageMagick/ImageMagick/issues/888).\n\n2017-11-29  7.0.7-12 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-12, GIT revision 21814:5ef2c5a67:20171129.\n\n2017-11-12  7.0.7-12 Cristy  <quetzlzacatenango@image...>\n  * The -tint option no longer munges the alpha channel (reference\n    http://imagemagick.org/discourse-server/viewtopic.php?f=1&t=33070).\n  * Don't delete in-memory blob when reading an image (reference\n    https://github.com/ImageMagick/ImageMagick/issues/886).\n  * Support HDRI color profile management.\n\n2017-11-11  7.0.7-11 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-11, GIT revision 21635:0447c6b46:20171111.\n\n2017-11-05  7.0.7-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-10, GIT revision 21612:36e2aabfd:20171105.\n\n2017-11-03  7.0.7-10 Dirk Lemstra <dirk@lem.....org>\n  * Fixed a problem with resource bookkeeping in AcquireMatrixInfo().\n\n2017-10-30  7.0.7-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-9, GIT revision 21580:2682a311e:20171031.\n\n2017-10-20  7.0.7-9 Cristy  <quetzlzacatenango@image...>\n  * Encode JSON control characters (reference\n    https://github.com/ImageMagick/ImageMagick/issues/848).\n\n2017-10-27  7.0.7-9 Dirk Lemstra <dirk@lem.....org>\n  * Added support for reading mipmaps in dds images (reference\n    https://github.com/ImageMagick/ImageMagick/issues/845).\n\n2017-10-15  7.0.7-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-8, GIT revision 21507:63ffc9878:20171015.\n\n2017-10-08  7.0.7-8 Cristy  <quetzlzacatenango@image...>\n  * Return expected results for a percent 0 -chop option argument (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32806).\n  * Tweaks to OpenMP support within ImageMagick.\n\n2017-10-07  7.0.7-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-7, GIT revision 21432:29003eeed:20171007.\n\n2017-10-06  7.0.7-7 Cristy  <quetzlzacatenango@image...>\n  * Correct handling of GIF transparency (reference\n    https://github.com/ImageMagick/ImageMagick/issues/831).\n\n2017-10-04  7.0.7-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-6, GIT revision 21426:0a1cb507b:20171004.\n\n2017-10-03  7.0.7-6 Cristy  <quetzlzacatenango@image...>\n  * Reset the magick_list_initialized boolean when needed (reference\n    https://github.com/ImageMagick/ImageMagick/pull/826).\n\n2017-10-01  7.0.7-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-5, GIT revision 21382:3846f9d97:20171001.\n\n2017-09-28  7.0.7-5 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * Support URW-base35 fonts.\n\n2017-09-26  7.0.7-5 Glenn Randers-Pehrson <glennrp@image...>\n  * Removed \"ping_preserve_iCCP=MagickTrue;\" statement that was inadvertently\n    added to coders/png.c (reference\n    http://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32771).\n\n2017-09-23  7.0.7-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-4, GIT revision 21265:bdbc14590:20170923.\n\n2017-09-23  7.0.7-4 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/pull/763).\n\n2017-09-17  7.0.7-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-3, GIT revision 21202:6e6907ac7:20170917.\n\n2017-09-17  7.0.7-3 ADLab of Venustech\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/pull/763).\n\n2017-09-15  7.0.7-3 Glenn Randers-Pehrson <glennrp@image...>\n  * Stop potential leaks in the JNG decoder (reference:\n    https://github.com/ImageMagick/ImageMagick/issues/760).\n  * Maximum valid hour is 23, not 24, in the PNG tIME chunk, and maximum\n    valid minute is 59, not 60.\n\n2017-09-12  7.0.7-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-2, GIT revision 21089:4e46ad9dd:20170912.\n\n2017-09-11  7.0.7-2 Glenn Randers-Pehrson <glennrp@image...>\n  * Use signed integer arithmetic to calculate timezone corrections (reference\n    https://github.com/ImageMagick/ImageMagick/issues/685).\n\n2017-09-09  7.0.7-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-1, GIT revision 21065:ab2194121:20170909.\n\n2017-09-09  7.0.7-1 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2017-09-05 7.0.7-1 Dirk Lemstra <dirk@lem.....org>\n  * Added -define tiff:write-layers=true to add support for writing layered\n    tiff files.\n\n2017-09-03  7.0.7-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-0, GIT revision 20996:2f8ac2203:20170903.\n\n2017-08-28  7.0.7-0 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * Don't overwrite symbolic links when the shred policy is enabled.\n\n2017-08-27  7.0.6-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-10, GIT revision 20920:9940c367a:20170827.\n\n2017-08-27  7.0.6-10 Cristy  <quetzlzacatenango@image...>\n  * Support -metric ssim, structual similarity index.\n\n2017-08-26  7.0.6-10 Dirk Lemstra <dirk@lem.....org>\n  * Fixed thread safety issue inside the pango and librsvg decoder\n    (reference: https://github.com/dlemstra/Magick.NET/issues/91).\n\n2017-08-20  7.0.6-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-9, GIT revision 20860:3f307d8ad:20170820.\n\n2017-08-18  7.0.6-9 Glenn Randers-Pehrson <glennrp@image...>\n  * Fixed bug with writing tIME chunk when timezone has a negative offset\n    (reference: https://github.com/ImageMagick/ImageMagick/issues/685)\n\n2017-08-18  7.0.6-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-8, GIT revision 20838:e2eb79427:20170818.\n\n2017-08-14  7.0.6-7 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * Support CubicSpline resize filter.  Define the lobes with the\n    -define filter:lobes={2,3,4} (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=2&t=32506).\n  * Prevent assertion failure when creating PDF thumbnail (reference\n    https://github.com/ImageMagick/ImageMagick/issues/674).\n\n2017-08-12  7.0.6-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-7, GIT revision 20799:0db4d8a16:20170812.\n\n2017-08-12  7.0.6-7 Cristy  <quetzlzacatenango@image...>\n  * Improve EPS aliasing (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32497).\n\n2017-08-11  7.0.6-7 Dirk Lemstra <dirk@lem.....org>\n  * Added a new option called 'dds:fast-mipmaps' (reference\n    https://github.com/ImageMagick/ImageMagick/issues/558)\n  * The mipmaps of a dds image can now be created from a list of images with\n    -define dds:mipmaps=fromlist (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=2&t=30236).\n\n2017-08-10  7.0.6-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-6, GIT revision 20775:061d0fa25:20170810.\n\n2017-08-10  7.0.6-6 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2017-08-10  7.0.6-6 Glenn Randers-Pehrson <glennrp@image...>\n  * tests/validate.c: Show the reason for failures in the test logs,\n    if available.\n\n2017-08-03  7.0.6-6 Glenn Randers-Pehrson <glennrp@image...>\n  * Put UTC time in the PNG tIME chunk instead of local time (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32447).\n\n2017-08-02  7.0.6-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-5, GIT revision 20715:26b28d50a:20170802.\n\n2017-08-01  7.0.6-5 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2017-07-29  7.0.6-5 Glenn Randers-Pehrson <glennrp@image...>\n  * Properly set image->colorspace in the PNG decoder (previously\n    it was setting image->gamma, but only setting image->colorspace\n    for grayscale and gray-alpha images.  Reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32418).\n  * Fix improper use of NULL in the JNG decoder (CVE-2017-11750, Reference\n    https://github.com/ImageMagick/ImageMagick/issues/632).\n  * Added \"-define png:ignore-crc\" option to PNG decoder. When you know\n    your image has no CRC or ADLER32 errors, this can speed up decoding.\n    It is also helpful in debugging bug reports from \"fuzzers\".\n\n2017-07-29  7.0.6-5 Cristy  <quetzlzacatenango@image...>\n  * Off by one error for gradient coder (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32416),\n    https://github.com/ImageMagick/ImageMagick/issues/612).\n\n2017-07-28  7.0.6-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-4, GIT revision 20657:4e81160d6:20170728.\n\n2017-07-24  7.0.6-4 Cristy  <quetzlzacatenango@image...>\n  * YUV coder no longer renders streaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues/612).\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues) including\n    https://github.com/ImageMagick/ImageMagick/issues/618 (CVE-2017-12676).\n  * coders/png.c: Initialized quantum_scanline and quantum_info\n    to prevent a bad free (reference\n    https://github.com/ImageMagick/ImageMagick/issues/621).\n\n2017-07-25  7.0.6-4 Glenn Randers-Pehrson <glennrp@image...>\n  * Removed write_chunk_from_profile() from coders/png.c because it has\n    not worked at least since version 6.7.6.\n  * Removed many redundant checks before RelinquishMagickMemory(), which\n    is safe to call with a NULL argument.\n  * Added experimental PNG orNT chunk, to store image->orientation.\n  * Removed vpAg chunk write support (we are now writing caNv instead).\n\n2017-07-24  7.0.6-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-3, GIT revision 20598:cc9c43b44:20170724.\n\n2017-07-23  7.0.6-3 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2017-07-23  7.0.6-3 Glenn Randers-Pehrson <glennrp@image...>\n  * Fix memory leaks when reading a malformed JNG image:\n    https://github.com/ImageMagick/ImageMagick/issues/600 (CVE-2017-13141),\n    https://github.com/ImageMagick/ImageMagick/issues/602 (CVE-2017-12565).\n\n2017-07-21  7.0.6-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-2, GIT revision 20549:62fcf3d96:20170721.\n\n2017-07-19  7.0.6-2 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * The -monochrome option no longer returns a blank canvas (reference\n    https://github.com/ImageMagick/ImageMagick/issues/594).\n  * coders/png.c: fixed memory leak of quantum_info (CVE-2017-11539, reference\n    https://github.com/ImageMagick/ImageMagick/issues/582\n  * coders/png.c: fixed NULL dereference when trying to write an empty MNG\n    (CVE-2017-11522, reference\n    https://github.com/ImageMagick/ImageMagick/issues/586).\n\n2017-07-15  7.0.6-2 Glenn Randers-Pehrson <glennrp@image...>\n  * Added caNv, eXIf, and pHYs to the list of PNG chunks to be removed\n    by the \"-strip\" option.\n\n2017-07-15  7.0.6-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-1, GIT revision 20447:c2a315e10:20170715.\n\n2017-07-13  7.0.6-1 Glenn Randers-Pehrson <glennrp@image...>\n  * Implemented PNG eXIf chunk support.\n\n2017-07-08  7.0.6-1 Cristy  <quetzlzacatenango@image...>\n  * Support new -auto-threshold option.  OTSU and Triangle methods are\n    currently supported.  Look for the Kapur method in the next release.\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * Don't use variable float_t / double_t, bump SO (reference\n    https://github.com/ImageMagick/ImageMagick/issues/510).\n  * Support DNG images with libraw delegate library.\n\n2017-07-02  7.0.6-1 Glenn Randers-Pehrson <glennrp@image...>\n  * Reject PNG file that is too small (under 60 bytes) to contain\n    a valid image.\n  * Reject JPEG file that is too small (under 107 bytes) to contain\n    a valid image.\n  * Reject JNG file that is too small (under 147 bytes) to contain\n    a valid image.\n\n2017-06-22  7.0.6-1 Glenn Randers-Pehrson <glennrp@image...>\n  * Stop a memory leak in read_user_chunk_callback() (reference\n    https://github.com/ImageMagick/ImageMagick/issues/517,\n    CVE 2017-11310).\n\n2017-06-10  7.0.6-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-0, GIT revision 20194:b0c0d00:20170611.\n\n2017-06-10  7.0.6-0 Glenn Randers-Pehrson <glennrp@image...>\n  * coders/png.c: Accept exIf chunks whose data segment\n    erroneously begins with \"Exif\\0\\0\".\n\n2017-06-10  7.0.6-0 Cristy  <quetzlzacatenango@image...>\n  * Introduce SetMagickSecurityPolicy() (MagickCore) and\n    MagickSetSecurityPolicy() (MagickWand) to set the ImageMagick security\n    policy (reference https://github.com/ImageMagick/ImageMagick/issues/407).\n\n2017-06-02  7.0.5-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-10, GIT revision 20155:38ebc02:20170602.\n\n2017-06-01  7.0.5-10 Glenn Randers-Pehrson <glennrp@image...>\n  * Removed experimental PNG zxIF chunk support; the proposal is dead.\n\n2017-06-01  7.0.5-10 Cristy  <quetzlzacatenango@image...>\n  * Fix choppy bitmap font rendering (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32071).\n  * The +opaque option is not longer a noop (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32081).\n  * Add support  for 'hex:' property.\n\n2017-05-28  7.0.5-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-9, GIT revision 20113:8b67333:20170528.\n\n2017-05-28  7.0.5-9 Cristy  <quetzlzacatenango@image...>\n  * Transient error validating the JPEG-2000 image format (reference\n    https://github.com/ImageMagick/ImageMagick/issues/501).\n  * Properly allocate DCM image colormap (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32063).\n\n2017-05-26  7.0.5-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-8, GIT revision 20099:870a016:20170526.\n\n2017-05-23  7.0.5-8 Cristy  <quetzlzacatenango@image...>\n  * Improper allocation of memory for IM instances without threads (reference\n    https://github.com/ImageMagick/ImageMagick/issues/497).\n  * Delete corrupt image from list (reference\n    https://github.com/ImageMagick/ImageMagick/issues/500).\n\n2017-05-19  7.0.5-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-6, GIT revision 20078:7ce2d38:20170519.\n\n2017-05-15  7.0.5-7 Cristy  <quetzlzacatenango@image...>\n  * Support various image operators for the compare utility (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=2&t=31938).\n\n 2017-05-12  7.0.5-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-6, GIT revision 20039:9371904:20170512.\n\n2017-05-10  7.0.5-6 John Cupitt <jcupitt@gmail.com>\n  * Revise DICOM window and rescale handling (reference\n    https://github.com/ImageMagick/ImageMagick/pull/484)\n\n2017-05-06  7.0.5-6 Cristy  <quetzlzacatenango@image...>\n  * Restore the -alpha Shape option (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31879).\n  * Fix transient PDF bug (reference\n    https://github.com/ImageMagick/ImageMagick/issues/463).\n  * The +opaque option now works on all channels (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31862).\n  * Ensure backwards compatibility for the -combine option (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31855).\n  * Check for EOF conditions for RLE image format.\n  * Reset histogram page geometry (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31920).\n\n2017-04-24  7.0.5-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-5, GIT revision 19915:12eec43:20170424.\n\n2017-03-26  7.0.5-5 Cristy  <quetzlzacatenango@image...>\n  * Minimize buffer copies to improve OpenCL performance.\n  * Morphology thinning is no longer a no-op (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31650).\n  * Patch two PCD writer problems, corrupt output and dark pixels (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=3164).\n  * Support ICC based PDF's (reference\n    https://github.com/ImageMagick/ImageMagick/issues/417).\n  * Fix improper EPS clip path rendering (reference\n    http://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31722).\n\n2017-03-24  7.0.5-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-4, GIT revision 19754:350fff3:20170324.\n\n2017-03-21  7.0.5-4 Cristy  <quetzlzacatenango@image...>\n  * Respect -loop option for animate -window (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31619).\n\n2017-03-17  7.0.5-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-3, GIT revision 19741:070c3fb:20170317.\n\n2017-03-14  7.0.5-3 Cristy  <quetzlzacatenango@image...>\n  * Support namespaces for the security policy.\n  * Support the -authenticate option for PDF (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31530).\n\n2017-03-11  7.0.5-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-2, GIT revision 19696:da91a7c:20170311.\n\n2017-03-06  7.0.5-2 Cristy  <quetzlzacatenango@image...>\n  * Respect throttle policy (reference\n    https://github.com/ImageMagick/ImageMagick/issues/393).\n  * Return proper minima / maxima (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31377).\n\n2017-03-03  7.0.5-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-1, GIT revision 19662:b7f455a:20170303.\n\n2017-02-21  7.0.5-1 Cristy  <quetzlzacatenango@image...>\n  * Fix Spurious memory allocation message (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31438).\n  * Identical images should return inf for PSNR (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31487).\n\n2017-02-20  7.0.5-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-0, GIT revision 19616:505fea9:20170220.\n\n2017-02-20  7.0.5-0 Cristy  <quetzlzacatenango@image...>\n  * Fix transient bug with -separate option (reference\n    https://github.com/ImageMagick/ImageMagick/issues/385).\n\n2017-02-18  7.0.4-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-10, GIT revision 19608:fe757a2:20170218.\n\n2017-02-18  7.0.4-10 Dirk Lemstra <dirk@lem.....org>\n  * Fixed fd leak for webp coder (reference\n    https://github.com/ImageMagick/ImageMagick/pull/382)\n\n2017-02-15  7.0.4-10 Cristy  <quetzlzacatenango@image...>\n  * Prevent random pixel data for corrupt JPEG image (bug report from\n    Hirokazu Moriguchi, Sony).\n  * Restore -mattecolor option.\n  * Support pixel-cache and shred security policies.\n  * Bump Magick++ SO.  Previously a global replace changed matteColor to\n    alphaColor.\n\n2017-02-14  7.0.4-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-9, GIT revision 19580:d474b37:20170214.\n\n2017-02-14  7.0.4-9 Cristy  <quetzlzacatenango@image...>\n  * Revert patch that did not set update trait on alpha channel.\n\n2017-02-13  7.0.4-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-8, GIT revision 19574:7642384:20170213.\n\n2017-02-09  7.0.4-8 Dirk Lemstra <dirk@lem.....org>\n  * Fixed memory leak when creating nested exceptions in Magick++ (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=23&p=142634)\n\n2017-02-09  7.0.4-8 Cristy  <quetzlzacatenango@image...>\n  * Unbreak build without JPEG support (reference\n    https://github.com/ImageMagick/ImageMagick/pull/373).\n  * Document behavior change in the security policy (thanks to yoya @\n    https://blog.awm.jp/2017/02/09/imagemagick-en/).\n  * Return unbiased standard deviation for image statistics (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31377).\n  * Don't set update trait on alpha channel (private e-mail concerning\n    -levels-colors option).\n\n2017-02-04  7.0.4-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-7, GIT revision 19513:5783e57:20170204.\n\n2017-01-28  7.0.4-7 Cristy  <quetzlzacatenango@image...>\n  * Sanitize comments that include braces for the MIFF image format (reference\n    https://github.com/ImageMagick/ImageMagick/issues/368).\n\n2017-01-27  7.0.4-7 Glenn Randers-Pehrson <glennrp@image...>\n  * coders/png.c: Added support for a proposed new PNG chunk\n    (zxIf, read-only) that is currently being discussed on the\n    png-mng-misc at lists.sourceforge.net mailing list.  Enable\n    exIf and zxIf with CPPFLAGS=\"-DexIf_SUPPORTED -DxzIf_SUPPORTED\".\n    If exIf is enabled, only the uncompressed exIF chunk will be\n    written and the hex-encoded zTXt chunk containing the raw Exif\n    profile won't be written.\n\n2017-01-27  7.0.4-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-6, GIT revision 19442:4747de9:20170127.\n\n2017-01-27  7.0.4-6 Cristy  <quetzlzacatenango@image...>\n  * Uninitialized data in MAT image format (reference\n    https://github.com/ImageMagick/ImageMagick/issues/362).\n  * Properly auto-fit caption (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30887).\n  * Correction to composite Over operator (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31282).\n  * Respect gravity option (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31284).\n\n2017-01-22  7.0.4-6 Glenn Randers-Pehrson <glennrp@image...>\n  * Renamed read_vpag_chunk_callback() function to png_user_chunk_callback()\n    in coders/png.c\n  * Implemented a private PNG caNv (canvas) chunk for remembering the\n    original dimensions and offsets when an image is cropped.  Previously\n    we used the oFFs and vpAg chunks for this purpose, but this had potential\n    conflicts with other applications that also use the oFFs chunk.\n  * coders/png.c: Added support for a proposed new PNG chunk (exIf\n    read-write, eXIf read-only) that is currently being discussed on the\n    png-mng-misc at lists.sourceforge.net mailing list.\n\n2017-01-22  7.0.4-6 Dirk Lemstra <dirk@lem.....org>\n  * Replaced CoderSeekableStreamFlag with CoderDecoderSeekableStreamFlag and\n    CoderEncoderSeekableStreamFlag.\n\n2017-01-21  7.0.4-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-5, GIT revision 19381:7ae396f:20170121.\n\n2017-01-18  7.0.4-5 Cristy  <quetzlzacatenango@image...>\n  * Don't set background for transparent tiled images (reference\n    http://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31210).\n\n2017-01-14  7.0.4-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-4, GIT revision 19361:a12953c:20170114.\n\n2017-01-14  7.0.4-4 Dirk Lemstra <dirk@lem.....org>\n  * Added support for RGB555, RGB565, ARGB4444 and ARGB1555 to the\n    BMP encoder (reference\n    https://github.com/ImageMagick/ImageMagick/issues/344).\n\n2017-01-10  7.0.4-4 Cristy  <quetzlzacatenango@image...>\n  * Recognize XML policy closing tags (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31182).\n  * Fix memory leak in the MPC format.\n\n2017-01-07  7.0.4-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-3, GIT revision 19329:930ca78:20170107.\n\n2017-01-04  7.0.4-3 Cristy  <quetzlzacatenango@image...>\n  * Increase memory allocation for TIFF pixels (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31161).\n\n2017-01-03  7.0.4-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-2, GIT revision 19318:8766311:20170103.\n\n2017-01-02  7.0.4-2 Cristy  <quetzlzacatenango@image...>\n  * Validation unit test for MNG works again.\n\n2016-12-31  7.0.4-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-1, GIT revision 19292:c5ccfa8:20161231.\n\n2016-12-26  7.0.4-1 Cristy  <quetzlzacatenango@image...>\n  * Initialize draw_info alpha member to OpaqueAlpha.\n  * Monochrome images no longer have inverted colors (reference\n    https://github.com/ImageMagick/ImageMagick/issues/332).\n\n2016-12-18  7.0.4-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-0, GIT revision 19221:d5e8abc:20161218.\n\n2016-12-14  7.0.4-0 Cristy  <quetzlzacatenango@image...>\n * Do not close path for linejoins of round (reference\n   https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31039).\n\n2016-12-10  7.0.3-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-10, GIT revision 19191:338f088:20161210.\n\n2016-12-07  7.0.3-10 Cristy  <quetzlzacatenango@image...>\n  * Set colorspace to sRGB if -append has non-homogenous colorspaces (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=29105).\n  * Respect connected-components:area-threshold define (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31006).\n  * Enable alpha channel if background color is non-opaque (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31016).\n  * Return correct offset for negative index for -fx option (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31019).\n  * Fixed improper scaling of certain FITS images (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31028).\n  * Properly center text label (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31027).\n\n2016-12-05  7.0.3-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-9, GIT revision 19139:6fed3f1:20161205.\n\n2016-11-26  7.0.3-9 Cristy  <quetzlzacatenango@image...>\n  * Support the compare -read-mask option.\n  * Support read-masks for the -modulate option.\n  * Prevent buffer overflow when streaming an image (reference\n    https://github.com/ImageMagick/ImageMagick/issues/312).\n  * Fix possible buffer overflow when writing compressed TIFFS (vulnerability\n    report from Cisco Talos, CVE-2016-8707).\n\n2016-11-15  7.0.3-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-8, GIT revision 19067:5aceded:20161125.\n\n2016-11-18  7.0.3-8 Cristy  <quetzlzacatenango@image...>\n  * Support the phash:colorspaces and phash:normalize options.\n  * If a convenient line break is not found, force it for caption: (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30887).\n  * Set alpha member of draw structure to OpaqueAlpha (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30894).\n  * Off by 1 error when computing the standard deviation (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=2&t=30866).\n  * Apply Debian patches, (reference\n    https://github.com/ImageMagick/ImageMagick/issues/304).\n  * Permit EPT images with just a TIFF or EPS image, not both (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30921).\n  * The -clone option no longer leaks memory.\n  * Render to clip mask rather than image for clip-path MVG graphics primitive.\n\n2016-11-15  7.0.3-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-7, GIT revision 19024:87aca83:20161115.\n\n2016-11-10  7.0.3-7 Cristy  <quetzlzacatenango@image...>\n  * Web pages were broken when we moved to HTTPS protocol.\n\n2016-11-08  7.0.3-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-6, GIT revision 19001:4cff747:20161108.\n\n2016-11-01  7.0.3-6 Cristy  <quetzlzacatenango@image...>\n  * Off by one memory allocation (reference\n    https://github.com/ImageMagick/ImageMagick/issues/296).\n  * The -extent option now matches the results of IMv6 (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=30779).\n  * Prevent fault in MSL interpreter (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30797).\n  * Mask composite produces proper results for the convert utility (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=29675).\n\n2016-10-10  7.0.3-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-5, GIT revision 18975:a8174a2:20161030.\n\n2016-10-16  7.0.3-5 Dirk Lemstra <dirk@lem.....org>\n  * Added layer RLE compression to the PSD encoder.\n\n2016-10-10  7.0.3-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-4, GIT revision 18937:83da034:20161010.\n\n2016-10-10  7.0.3-4 Dirk Lemstra <dirk@lem.....org>\n  * Fixed incorrect parsing with ordered dither. (reference\n    https://github.com/ImageMagick/ImageMagick/issues/254)\n\n2016-10-10  7.0.3-4 Cristy  <quetzlzacatenango@image...>\n  * Unit test pass again after small SUN image patch.\n\n2016-10-08  7.0.3-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-3, GIT revision 18924:d6614e7:20161008.\n\n2016-10-07  7.0.3-3 Dirk Lemstra <dirk@lem.....org>\n  * Fixed incorrect RLE decoding when reading a DCM image that contains\n    multiple segments.\n\n2016-10-02  7.0.3-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-2, GIT revision 18887:6b27c5b:20161002.\n\n2016-09-27  7.0.3-2 Dirk Lemstra <dirk@lem.....org>\n  * Fixed incorrect RLE decoding when reading an SGI image (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30514)\n\n2016-09-20  7.0.3-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-1, GIT revision 18851:ad91ea8:20160920.\n\n2016-09-16  7.0.3-1 Dirk Lemstra <dirk@lem.....org>\n  * Added layer RLE compression to the PSD encoder.\n  * Added define 'psd:preserve-opacity-mask' to preserve the opacity mask\n    in a PSD file.\n  * Fixed issue where the display window was used instead of the data window\n    when reading EXR files (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&p=137849).\n\n2016-09-05  7.0.3-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-0, GIT revision 18786:10aa64c:20160905.\n\n2016-08-29  7.0.3-0 Dirk Lemstra <dirk@lem.....org>\n  * Fixed reading DXT1 images with an alpha channel.\n  * Fixed incorrect padding calculation in PSD encoder.\n\n2016-08-27  7.0.2-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-10, GIT revision 18750:e3335b3:20160827.\n\n2016-08-27  7.0.2-10 Dirk Lemstra <dirk@lem.....org>\n  * Added define 'psd:additional-info' to preserve the additional information\n    in a PSD file.\n\n2016-08-15  7.0.2-10 Cristy  <quetzlzacatenango@image...>\n  * Prevent buffer overflow in BMP & SGI coders (bug report from\n    pwchen&rayzhong of tencent).\n  * Prevent buffer overflow and other problems in SIXEL, PDB, MAP, TIFF and\n    CALS coders (bug report from Donghai Zhu).\n  * The -stream option now increments the pixel pointer properly (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30327).\n\n2016-08-14  7.0.2-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-9, GIT revision 18707:2c02f09:20160814.\n\n2016-08-14  7.0.2-9 Cristy  <quetzlzacatenango@image...>\n  * Fix compile error in opencl.c (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30289).\n  * Eliminate compiler warning.\n\n2016-08-14  7.0.2-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-8, GIT revision 18698:74b1d5d:20160814.\n\n2016-08-07  7.0.2-8 Cristy  <quetzlzacatenango@image...>\n  * Prevent spurious removal of MPC cache files (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30256).\n  * Note alpha channel when combining 4 or more images (reference\n    https://github.com/ImageMagick/ImageMagick/issues/250).\n\n2016-08-06  7.0.2-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-7, GIT revision 10980:ecc03a2:20160806.\n\n2016-08-01  7.0.2-7 Cristy  <quetzlzacatenango@image...>\n  * Evaluate lazy pixel cache morphology to prevent buffer overflow (bug report\n    from Ibrahim M. El-Sayed).\n  * Prevent buffer overflow (bug report from Max Thrane).\n  * Prevent memory use after free (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30245).\n\n2016-07-30  7.0.2-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-6, GIT revision 18651:df24175:20160729.\n\n2016-07-29  7.0.2-6 Cristy  <quetzlzacatenango@image...>\n  * Support -region option (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=29692).\n\n2016-07-21  7.0.2-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-5, GIT revision 18627:2b5ddbd:20160721.\n\n2016-07-13  7.0.2-5 Cristy  <quetzlzacatenango@image...>\n  * Fix MVG stroke-opacity (reference\n    https://github.com/ImageMagick/ImageMagick/issues/229).\n  * Prevent possible buffer overflow when reading TIFF images (bug report from\n    Shi Pu of MS509 Team).\n  * Initialize index channel to get expected results from the stegano coder.\n\n2016-07-11  7.0.2-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-4, GIT revision 18591:50debe5:20160710.\n\n2016-07-10  7.0.2-4 Cristy  <quetzlzacatenango@image...>\n  * To comply with the SVG standard, use stroke-opacity for transparent strokes.\n  * Define CompositeChannels mask to Red, Green, Blue, Alpha, and Black.\n\n2016-07-09  7.0.2-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-3, GIT revision 18572:28560fc:20160709.\n\n2016-07-01  7.0.2-3 Cristy  <quetzlzacatenango@image...>\n  * Patch so -kuwahara option can preserve colormapped edges.\n  * The histogram coder now returns the correct extent.\n  * Use CopyMagickString() rather than CopyMagickMemory() for strings.\n\n2016-06-26  7.0.2-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-2, GIT revision 18514:a7b5b46:20160626.\n\n2016-06-23  7.0.2-2 Cristy  <quetzlzacatenango@image...>\n  * Correct for numerical instability (reference\n    https://github.com/ImageMagick/ImageMagick/issues/218).\n\n2016-06-21  7.0.2-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-1, GIT revision 18479:931319b:20160622.\n\n2016-06-17  7.0.2-1 Dirk Lemstra <dirk@lem.....org>\n  * Added support for GROUP4 compression to the FAX coder.\n\n2016-06-12  7.0.2-1 Cristy  <quetzlzacatenango@image...>\n  * Distort no longer converts grayscale image to sRGB (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=29895).\n  * Don't return a zero bounding box for QueryMultilineFontMetrics() (reference\n    https://github.com/ImageMagick/ImageMagick/issues/222).\n\n2016-06-12  7.0.2-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-0, GIT revision 10884:f0e15e8:20160612.\n\n2016-06-09  7.0.2-0 Cristy  <quetzlzacatenango@image...>\n  * Backoff finite precision epsilon (reference\n    https://github.com/ImageMagick/ImageMagick/issues/215).\n  * Fix drawing glitch for stroke widths greater than 2 (reference\n    https://github.com/ImageMagick/ImageMagick/issues/218).\n\n2016-06-05  7.0.1-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-10, GIT revision 18406:ba4ad2d:20160607.\n\n2016-06-04  7.0.1-10 Cristy  <quetzlzacatenango@image...>\n  * Deny indirect reads by policy, remove policy to permit, e.g.,\n    convert caption:@mytext.txt ...\n  * RLE check for pixel offset less than 0 (heap overflow report from Craig\n    Young).\n  * Properly initialze PES blocks (reference\n    https://github.com/ImageMagick/ImageMagick/issues/213).\n\n2016-06-03  7.0.1-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-9, GIT revision 10847:339f803:20160602.\n\n2016-06-02  7.0.1-9 Cristy  <quetzlzacatenango@image...>\n  * Fix small memory leak (patch provided by \u0410\u043d\u0434\u0440\u0435\u0439 \u0427\u0435\u0440\u043d\u044b\u0439).\n  * Coder path traversal is not authorized (bug report provided by\n    Masaaki Chida).\n  * Turn off alpha channel for the compare difference image (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=29828).\n\n2016-05-31  7.0.1-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-8, GIT revision 18334:97775b5:20160531.\n\n2016-05-31  7.0.1-8 Cristy  <quetzlzacatenango@image...>\n  * Support configure script --enable-pipes option to enable pipes (|) in\n    filenames.\n  * Support configure script --enable-indirect-reads option to enable\n    indirect reads (@) in filenames.\n\n2016-05-30  7.0.1-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-7, GIT revision 18321:5511ef5:20160530.\n\n2016-05-25  7.0.1-7 Cristy  <quetzlzacatenango@image...>\n  * Security improvements to TEXT coder broke it (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=29754).\n  * Fix stroke offset problem for -annotate (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=29626).\n  * Don't interpret -fx option arguments (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=29774);\n  * Add additional checks to DCM reader to prevent data-driven faults (bug\n    report from Hanno B\u00f6ck).\n\n2016-05-21  7.0.1-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-6, GIT revision 18241:d4f277c:20160521.\n\n2016-05-20  7.0.1-6 Cristy  <quetzlzacatenango@image...>\n  * Fixed proper placement of text annotation for east / west gravity.\n\n2016-05-18  7.0.1-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-5, GIT revision 10789:f7c2e89:20160518,\n\n2016-05-18  7.0.1-5 Cristy  <quetzlzacatenango@image...>\n  * Process channels independently for -channel -equalize (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=29708).\n  * Fix pixel cache on disk regression (reference\n    https://github.com/ImageMagick/ImageMagick/issues/202).\n\n2016-05-15  7.0.1-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-4, GIT revision 10778:52dae14:20160516.\n\n2016-05-10  7.0.1-4 Cristy  <quetzlzacatenango@image...>\n  * Prevent possible shell command injection vulnerability through the\n    authenticate parameter of the PDF, PCL and XPS coders (report from\n    Erez Turjeman).\n  * Quote passwords when passed to a delegate program.\n  * Iterate channels over source image rather than destination (bug report\n    from Hanno B\u00f6ck).\n  * Can read geo-related EXIF metdata once-again (reference\n    https://github.com/ImageMagick/ImageMagick/issues/198).\n  * Sanitize all delegate emedded formatting characters.\n  * Don't sync pixel cache in AcquireAuthenticCacheView() (bug report from\n    Hanno B\u00f6ck).\n\n2016-05-09  7.0.1-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-3, GIT revision 10755:d540dda:20160509.\n\n2016-05-07  7.0.1-3 Cristy  <quetzlzacatenango@image...>\n  * Remove https delegate.\n\n2016-05-06  7.0.1-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-2, GIT revision 10741:5746147:20160507.\n\n2016-05-04  7.0.1-2 Cristy  <quetzlzacatenango@image...>\n  * Check for buffer overflow in magick/draw.c/DrawStrokePolygon().\n  * Replace show delegate title with image filename rather than label.\n  * Fix GetNextToken() off by one error.\n  * Remove support for internal ephemeral coder.\n\n2016-05-03  7.0.1-1 Cristy  <quetzlzacatenango@image...>\n  * New version 7.0.1-1, GIT revision 10723:9fc8a0c:20160503.\n\n2016-05-03  7.0.1-1 Cristy  <quetzlzacatenango@image...>\n  * Sanitize input filename for http / https delegates (improved patch).\n  * Fix for possible security vulnerabilities (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=4&t=29588).\n\n2016-04-30  7.0.1-0 Cristy  <quetzlzacatenango@image...>\n  * New version 7.0.1-0, GIT revision 10716:b527bce:20160430.\n\n2016-01-30  7.0.0-0 \tFahad-Alsaidi & ShamsaHamed\n  * Add support for languages that require complex text layout (reference\n    https://github.com/ImageMagick/ImageMagick/pull/88).\n\n2012-04-27  7.0.0-0 Anthony thyssen <A.Thyssen@griffith...>\n  * Allow the use of set and escapes when no images in memory\n    (unless you attempt to access per-image meta-data)\n    Currently does not include %[fx:...] and %[pixel:...]\n\n2012-10-05  7.0.0-0 Anthony thyssen <A.Thyssen@griffith...>\n  * Rather than replicate 'options' into 'artifacts' make a link\n    from image to image_info and lookup a global option if no artifact\n    is defined.\n\n2012-09-11  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * sigmoidal-contrast:\n  * Remove unnecessary initial ClampToQuantum.\n\n2012-09-10  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * sigmoidal-contrast:\n  * Direct computation, without LUT;\n  * Fix re-declaration of i (at the top, and inside a conditional).\n\n2012-09-04  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * Add tanh/atanh clone of legacy sigmoidal map (faster & more accurate).\n\n2012-08-08  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * Add final ClampToQuantum in sigmoidal colormap loop.\n  * Remove OpenMP calls from colormap update loops.\n\n2011-08-01  7.0.0-0 Cristy  <quetzlzacatenango@image...>\n  * New version 7.0.0-0.\n\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        JJJJJ  PPPP   EEEEE   GGGG                           %\n%                          J    P   P  E      G                               %\n%                          J    PPPP   EEE    G  GG                           %\n%                        J J    P      E      G   G                           %\n%                        JJJ    P      EEEEE   GGG                            %\n%                                                                             %\n%                                                                             %\n%                       Read/Write JPEG Image Format                          %\n%                                                                             %\n%                              Software Design                                %\n%                                John Cristy                                  %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2013 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n% This software is based in part on the work of the Independent JPEG Group.\n% See ftp://ftp.uu.net/graphics/jpeg/jpegsrc.v6b.tar.gz for copyright and\n% licensing restrictions.  Blob support contributed by Glenn Randers-Pehrson.\n%\n%\n*/\n\n\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/memory-private.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/option-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/xml-tree.h\"\n#include \"MagickCore/xml-tree-private.h\"\n#include <setjmp.h>\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n#define JPEG_INTERNAL_OPTIONS\n#if defined(__MINGW32__)\n# define XMD_H 1  /* Avoid conflicting typedef for INT32 */\n#endif\n#undef HAVE_STDLIB_H\n#include \"jpeglib.h\"\n#include \"jerror.h\"\n#endif\n\f\n/*\n  Define declarations.\n*/\n#define ICC_MARKER  (JPEG_APP0+2)\n#define ICC_PROFILE  \"ICC_PROFILE\"\n#define IPTC_MARKER  (JPEG_APP0+13)\n#define XML_MARKER  (JPEG_APP0+1)\n#define MaxJPEGScans  1024\n\f\n/*\n  Typedef declarations.\n*/\n#if defined(MAGICKCORE_JPEG_DELEGATE)\ntypedef struct _DestinationManager\n{\n  struct jpeg_destination_mgr\n    manager;\n\n  Image\n    *image;\n\n  JOCTET\n    *buffer;\n} DestinationManager;\n\ntypedef struct _ErrorManager\n{\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    finished;\n\n  StringInfo\n    *profile;\n\n  jmp_buf\n    error_recovery;\n} ErrorManager;\n\ntypedef struct _SourceManager\n{\n  struct jpeg_source_mgr\n    manager;\n\n  Image\n    *image;\n\n  JOCTET\n    *buffer;\n\n  boolean\n    start_of_blob;\n} SourceManager;\n#endif\n\ntypedef struct _QuantizationTable\n{\n  char\n    *slot,\n    *description;\n\n  size_t\n    width,\n    height;\n\n  double\n    divisor;\n\n  unsigned int\n    *levels;\n} QuantizationTable;\n\f\n/*\n  Const declarations.\n*/\nstatic const char\n  xmp_namespace[] = \"http://ns.adobe.com/xap/1.0/ \";\n#define XmpNamespaceExtent 28\n\f\n/*\n  Forward declarations.\n*/\n#if defined(MAGICKCORE_JPEG_DELEGATE)\nstatic MagickBooleanType\n  WriteJPEGImage(const ImageInfo *,Image *,ExceptionInfo *);\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s J P E G                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsJPEG() returns MagickTrue if the image format type, identified by the\n%  magick string, is JPEG.\n%\n%  The format of the IsJPEG  method is:\n%\n%      MagickBooleanType IsJPEG(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsJPEG(const unsigned char *magick,const size_t length)\n{\n  if (length < 3)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\377\\330\\377\",3) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d J P E G I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadJPEGImage() reads a JPEG image file and returns it.  It allocates\n%  the memory necessary for the new Image structure and returns a pointer to\n%  the new image.\n%\n%  The format of the ReadJPEGImage method is:\n%\n%      Image *ReadJPEGImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic boolean FillInputBuffer(j_decompress_ptr cinfo)\n{\n  SourceManager\n    *source;\n\n  source=(SourceManager *) cinfo->src;\n  source->manager.bytes_in_buffer=(size_t) ReadBlob(source->image,\n    MagickMinBufferExtent,source->buffer);\n  if (source->manager.bytes_in_buffer == 0)\n    {\n      if (source->start_of_blob != FALSE)\n        ERREXIT(cinfo,JERR_INPUT_EMPTY);\n      WARNMS(cinfo,JWRN_JPEG_EOF);\n      source->buffer[0]=(JOCTET) 0xff;\n      source->buffer[1]=(JOCTET) JPEG_EOI;\n      source->manager.bytes_in_buffer=2;\n    }\n  source->manager.next_input_byte=source->buffer;\n  source->start_of_blob=FALSE;\n  return(TRUE);\n}\n\nstatic int GetCharacter(j_decompress_ptr jpeg_info)\n{\n  if (jpeg_info->src->bytes_in_buffer == 0)\n    {\n      (void) (*jpeg_info->src->fill_input_buffer)(jpeg_info);\n      if (jpeg_info->err->msg_code == JWRN_JPEG_EOF)\n        return EOF;\n    }\n  jpeg_info->src->bytes_in_buffer--;\n  return((int) GETJOCTET(*jpeg_info->src->next_input_byte++));\n}\n\nstatic void InitializeSource(j_decompress_ptr cinfo)\n{\n  SourceManager\n    *source;\n\n  source=(SourceManager *) cinfo->src;\n  source->start_of_blob=TRUE;\n}\n\nstatic MagickBooleanType IsITUFaxImage(const Image *image)\n{\n  const StringInfo\n    *profile;\n\n  const unsigned char\n    *datum;\n\n  profile=GetImageProfile(image,\"8bim\");\n  if (profile == (const StringInfo *) NULL)\n    return(MagickFalse);\n  if (GetStringInfoLength(profile) < 5)\n    return(MagickFalse);\n  datum=GetStringInfoDatum(profile);\n  if ((datum[0] == 0x47) && (datum[1] == 0x33) && (datum[2] == 0x46) &&\n      (datum[3] == 0x41) && (datum[4] == 0x58))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic void JPEGErrorHandler(j_common_ptr jpeg_info)\n{\n  char\n    message[JMSG_LENGTH_MAX];\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  *message='\\0';\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  image=error_manager->image;\n  exception=error_manager->exception;\n  (jpeg_info->err->format_message)(jpeg_info,message);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"[%s] JPEG Trace: \\\"%s\\\"\",image->filename,message);\n  if (error_manager->finished != MagickFalse)\n    (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageWarning,\n      (char *) message,\"`%s'\",image->filename);\n  else\n    (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n      (char *) message,\"`%s'\",image->filename);\n  longjmp(error_manager->error_recovery,1);\n}\n\nstatic void JPEGProgressHandler(j_common_ptr jpeg_info)\n{\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  image=error_manager->image;\n  exception=error_manager->exception;\n  if (jpeg_info->is_decompressor == 0)\n    return;\n  if (((j_decompress_ptr) jpeg_info)->input_scan_number < MaxJPEGScans)\n    return;\n  (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n    \"too many scans\",\"`%s'\",image->filename);\n  longjmp(error_manager->error_recovery,1);\n}\n\nstatic MagickBooleanType JPEGWarningHandler(j_common_ptr jpeg_info,int level)\n{\n#define JPEGExcessiveWarnings  1000\n\n  char\n    message[JMSG_LENGTH_MAX];\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  *message='\\0';\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  if (level < 0)\n    {\n      /*\n        Process warning message.\n      */\n      (jpeg_info->err->format_message)(jpeg_info,message);\n      if (jpeg_info->err->num_warnings++ < JPEGExcessiveWarnings)\n        ThrowBinaryException(CorruptImageWarning,(char *) message,\n          image->filename);\n    }\n  else\n    if ((image->debug != MagickFalse) &&\n        (level >= jpeg_info->err->trace_level))\n      {\n        /*\n          Process trace message.\n        */\n        (jpeg_info->err->format_message)(jpeg_info,message);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"[%s] JPEG Trace: \\\"%s\\\"\",image->filename,message);\n      }\n  return(MagickTrue);\n}\n\nstatic boolean ReadComment(j_decompress_ptr jpeg_info)\n{\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  StringInfo\n    *comment;\n\n  /*\n    Determine length of comment.\n  */\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=GetCharacter(jpeg_info);\n  if (length <= 2)\n    return(TRUE);\n  length-=2;\n  comment=BlobToStringInfo((const void *) NULL,length);\n  if (comment == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  /*\n    Read comment.\n  */\n  error_manager->profile=comment;\n  p=GetStringInfoDatum(comment);\n  for (i=0; i < (ssize_t) length; i++)\n  {\n    int\n      c;\n\n    c=GetCharacter(jpeg_info);\n    if (c == EOF)\n      break;\n    *p++=(unsigned char) c;\n  }\n  *p='\\0';\n  error_manager->profile=NULL;\n  if (i != (ssize_t) length)\n    {\n      comment=DestroyStringInfo(comment);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        CorruptImageError,\"InsufficientImageDataInFile\",\"`%s'\",\n        image->filename);\n      return(FALSE);\n    }\n  p=GetStringInfoDatum(comment);\n  (void) SetImageProperty(image,\"comment\",(const char *) p,exception);\n  comment=DestroyStringInfo(comment);\n  return(TRUE);\n}\n\nstatic boolean ReadICCProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    magick[12];\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *icc_profile,\n    *profile;\n\n  /*\n    Read color profile.\n  */\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=(size_t) GetCharacter(jpeg_info);\n  length-=2;\n  if (length <= 14)\n    {\n      while (length-- > 0)\n        if (GetCharacter(jpeg_info) == EOF)\n          break;\n      return(TRUE);\n    }\n  for (i=0; i < 12; i++)\n    magick[i]=(char) GetCharacter(jpeg_info);\n  if (LocaleCompare(magick,ICC_PROFILE) != 0)\n    {\n      /*\n        Not a ICC profile, return.\n      */\n      for (i=0; i < (ssize_t) (length-12); i++)\n        if (GetCharacter(jpeg_info) == EOF)\n          break;\n      return(TRUE);\n    }\n  (void) GetCharacter(jpeg_info);  /* id */\n  (void) GetCharacter(jpeg_info);  /* markers */\n  length-=14;\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  profile=BlobToStringInfo((const void *) NULL,length);\n  if (profile == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  error_manager->profile=profile;\n  p=GetStringInfoDatum(profile);\n  for (i=0; i < (ssize_t) length; i++)\n  {\n    int\n      c;\n\n    c=GetCharacter(jpeg_info);\n    if (c == EOF)\n      break;\n    *p++=(unsigned char) c;\n  }\n  if (i != (ssize_t) length)\n    {\n      profile=DestroyStringInfo(profile);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        CorruptImageError,\"InsufficientImageDataInFile\",\"`%s'\",\n        image->filename);\n      return(FALSE);\n    }\n  error_manager->profile=NULL;\n  icc_profile=(StringInfo *) GetImageProfile(image,\"icc\");\n  if (icc_profile != (StringInfo *) NULL)\n    {\n      ConcatenateStringInfo(icc_profile,profile);\n      profile=DestroyStringInfo(profile);\n    }\n  else\n    {\n      status=SetImageProfile(image,\"icc\",profile,exception);\n      profile=DestroyStringInfo(profile);\n      if (status == MagickFalse)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n          return(FALSE);\n        }\n    }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Profile: ICC, %.20g bytes\",(double) length);\n  return(TRUE);\n}\n\nstatic boolean ReadIPTCProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    magick[MagickPathExtent];\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *iptc_profile,\n    *profile;\n\n  /*\n    Determine length of binary data stored here.\n  */\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=(size_t) GetCharacter(jpeg_info);\n  length-=2;\n  if (length <= 14)\n    {\n      while (length-- > 0)\n        if (GetCharacter(jpeg_info) == EOF)\n          break;\n      return(TRUE);\n    }\n  /*\n    Validate that this was written as a Photoshop resource format slug.\n  */\n  for (i=0; i < 10; i++)\n    magick[i]=(char) GetCharacter(jpeg_info);\n  magick[10]='\\0';\n  length-=10;\n  if (length <= 10)\n    return(TRUE);\n  if (LocaleCompare(magick,\"Photoshop \") != 0)\n    {\n      /*\n        Not a IPTC profile, return.\n      */\n      for (i=0; i < (ssize_t) length; i++)\n        if (GetCharacter(jpeg_info) == EOF)\n          break;\n      return(TRUE);\n    }\n  /*\n    Remove the version number.\n  */\n  for (i=0; i < 4; i++)\n    if (GetCharacter(jpeg_info) == EOF)\n      break;\n  if (length <= 11)\n    return(TRUE);\n  length-=4;\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  profile=BlobToStringInfo((const void *) NULL,length);\n  if (profile == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  error_manager->profile=profile;\n  p=GetStringInfoDatum(profile);\n  for (i=0; i < (ssize_t) length; i++)\n  {\n    int\n      c;\n\n    c=GetCharacter(jpeg_info);\n    if (c == EOF)\n      break;\n    *p++=(unsigned char) c;\n  }\n  error_manager->profile=NULL;\n  if (i != (ssize_t) length)\n    {\n      profile=DestroyStringInfo(profile);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        CorruptImageError,\"InsufficientImageDataInFile\",\"`%s'\",\n        image->filename);\n      return(FALSE);\n    }\n  /* The IPTC profile is actually an 8bim */\n  iptc_profile=(StringInfo *) GetImageProfile(image,\"8bim\");\n  if (iptc_profile != (StringInfo *) NULL)\n    {\n      ConcatenateStringInfo(iptc_profile,profile);\n      profile=DestroyStringInfo(profile);\n    }\n  else\n    {\n      status=SetImageProfile(image,\"8bim\",profile,exception);\n      profile=DestroyStringInfo(profile);\n      if (status == MagickFalse)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n          return(FALSE);\n        }\n    }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Profile: iptc, %.20g bytes\",(double) length);\n  return(TRUE);\n}\n\nstatic boolean ReadProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    name[MagickPathExtent];\n\n  const StringInfo\n    *previous_profile;\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  int\n    marker;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *profile;\n\n  /*\n    Read generic profile.\n  */\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=(size_t) GetCharacter(jpeg_info);\n  if (length <= 2)\n    return(TRUE);\n  length-=2;\n  marker=jpeg_info->unread_marker-JPEG_APP0;\n  (void) FormatLocaleString(name,MagickPathExtent,\"APP%d\",marker);\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  profile=BlobToStringInfo((const void *) NULL,length);\n  if (profile == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  error_manager->profile=profile;\n  p=GetStringInfoDatum(profile);\n  for (i=0; i < (ssize_t) length; i++)\n  {\n    int\n      c;\n\n    c=GetCharacter(jpeg_info);\n    if (c == EOF)\n      break;\n    *p++=(unsigned char) c;\n  }\n  error_manager->profile=NULL;\n  if (i != (ssize_t) length)\n    {\n      profile=DestroyStringInfo(profile);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        CorruptImageError,\"InsufficientImageDataInFile\",\"`%s'\",\n        image->filename);\n      return(FALSE);\n    }\n  if (marker == 1)\n    {\n      p=GetStringInfoDatum(profile);\n      if ((length > 4) && (LocaleNCompare((char *) p,\"exif\",4) == 0))\n        (void) CopyMagickString(name,\"exif\",MagickPathExtent);\n      else if ((length > XmpNamespaceExtent) &&\n          (LocaleNCompare((char *) p,xmp_namespace,XmpNamespaceExtent-1) == 0))\n        {\n          ssize_t\n            j;\n\n          /*\n            Extract namespace from XMP profile.\n          */\n          p=GetStringInfoDatum(profile)+XmpNamespaceExtent;\n          for (j=XmpNamespaceExtent; j < (ssize_t) GetStringInfoLength(profile); j++)\n          {\n            if (*p == '\\0')\n              break;\n            p++;\n          }\n          if (j < (ssize_t) GetStringInfoLength(profile))\n            (void) DestroyStringInfo(SplitStringInfo(profile,(size_t) (j+1)));\n          (void) CopyMagickString(name,\"xmp\",MagickPathExtent);\n        }\n    }\n  previous_profile=GetImageProfile(image,name);\n  if ((previous_profile != (const StringInfo *) NULL) &&\n      (CompareStringInfo(previous_profile,profile) != 0))\n    {\n      size_t\n        profile_length;\n\n      profile_length=GetStringInfoLength(profile);\n      SetStringInfoLength(profile,GetStringInfoLength(profile)+\n        GetStringInfoLength(previous_profile));\n      (void) memmove(GetStringInfoDatum(profile)+\n        GetStringInfoLength(previous_profile),GetStringInfoDatum(profile),\n        profile_length);\n      (void) memcpy(GetStringInfoDatum(profile),\n        GetStringInfoDatum(previous_profile),\n        GetStringInfoLength(previous_profile));\n    }\n  status=SetImageProfile(image,name,profile,exception);\n  profile=DestroyStringInfo(profile);\n  if (status == MagickFalse)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Profile: %s, %.20g bytes\",name,(double) length);\n  return(TRUE);\n}\n\nstatic void SkipInputData(j_decompress_ptr cinfo,long number_bytes)\n{\n  SourceManager\n    *source;\n\n  if (number_bytes <= 0)\n    return;\n  source=(SourceManager *) cinfo->src;\n  while (number_bytes > (long) source->manager.bytes_in_buffer)\n  {\n    number_bytes-=(long) source->manager.bytes_in_buffer;\n    (void) FillInputBuffer(cinfo);\n  }\n  source->manager.next_input_byte+=number_bytes;\n  source->manager.bytes_in_buffer-=number_bytes;\n}\n\nstatic void TerminateSource(j_decompress_ptr cinfo)\n{\n  (void) cinfo;\n}\n\nstatic void JPEGSourceManager(j_decompress_ptr cinfo,Image *image)\n{\n  SourceManager\n    *source;\n\n  cinfo->src=(struct jpeg_source_mgr *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,sizeof(SourceManager));\n  source=(SourceManager *) cinfo->src;\n  source->buffer=(JOCTET *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,MagickMinBufferExtent*sizeof(JOCTET));\n  source=(SourceManager *) cinfo->src;\n  source->manager.init_source=InitializeSource;\n  source->manager.fill_input_buffer=FillInputBuffer;\n  source->manager.skip_input_data=SkipInputData;\n  source->manager.resync_to_restart=jpeg_resync_to_restart;\n  source->manager.term_source=TerminateSource;\n  source->manager.bytes_in_buffer=0;\n  source->manager.next_input_byte=NULL;\n  source->image=image;\n}\n\nstatic void JPEGSetImageQuality(struct jpeg_decompress_struct *jpeg_info,\n  Image *image)\n{\n  image->quality=UndefinedCompressionQuality;\n#if defined(D_PROGRESSIVE_SUPPORTED)\n  if (image->compression == LosslessJPEGCompression)\n    {\n      image->quality=100;\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"Quality: 100 (lossless)\");\n    }\n  else\n#endif\n  {\n    ssize_t\n      j,\n      qvalue,\n      sum;\n\n    register ssize_t\n      i;\n\n    /*\n      Determine the JPEG compression quality from the quantization tables.\n    */\n    sum=0;\n    for (i=0; i < NUM_QUANT_TBLS; i++)\n    {\n      if (jpeg_info->quant_tbl_ptrs[i] != NULL)\n        for (j=0; j < DCTSIZE2; j++)\n          sum+=jpeg_info->quant_tbl_ptrs[i]->quantval[j];\n    }\n    if ((jpeg_info->quant_tbl_ptrs[0] != NULL) &&\n        (jpeg_info->quant_tbl_ptrs[1] != NULL))\n      {\n        ssize_t\n          hash[101] =\n          {\n            1020, 1015,  932,  848,  780,  735,  702,  679,  660,  645,\n             632,  623,  613,  607,  600,  594,  589,  585,  581,  571,\n             555,  542,  529,  514,  494,  474,  457,  439,  424,  410,\n             397,  386,  373,  364,  351,  341,  334,  324,  317,  309,\n             299,  294,  287,  279,  274,  267,  262,  257,  251,  247,\n             243,  237,  232,  227,  222,  217,  213,  207,  202,  198,\n             192,  188,  183,  177,  173,  168,  163,  157,  153,  148,\n             143,  139,  132,  128,  125,  119,  115,  108,  104,   99,\n              94,   90,   84,   79,   74,   70,   64,   59,   55,   49,\n              45,   40,   34,   30,   25,   20,   15,   11,    6,    4,\n               0\n          },\n          sums[101] =\n          {\n            32640, 32635, 32266, 31495, 30665, 29804, 29146, 28599, 28104,\n            27670, 27225, 26725, 26210, 25716, 25240, 24789, 24373, 23946,\n            23572, 22846, 21801, 20842, 19949, 19121, 18386, 17651, 16998,\n            16349, 15800, 15247, 14783, 14321, 13859, 13535, 13081, 12702,\n            12423, 12056, 11779, 11513, 11135, 10955, 10676, 10392, 10208,\n             9928,  9747,  9564,  9369,  9193,  9017,  8822,  8639,  8458,\n             8270,  8084,  7896,  7710,  7527,  7347,  7156,  6977,  6788,\n             6607,  6422,  6236,  6054,  5867,  5684,  5495,  5305,  5128,\n             4945,  4751,  4638,  4442,  4248,  4065,  3888,  3698,  3509,\n             3326,  3139,  2957,  2775,  2586,  2405,  2216,  2037,  1846,\n             1666,  1483,  1297,  1109,   927,   735,   554,   375,   201,\n              128,     0\n          };\n\n        qvalue=(ssize_t) (jpeg_info->quant_tbl_ptrs[0]->quantval[2]+\n          jpeg_info->quant_tbl_ptrs[0]->quantval[53]+\n          jpeg_info->quant_tbl_ptrs[1]->quantval[0]+\n          jpeg_info->quant_tbl_ptrs[1]->quantval[DCTSIZE2-1]);\n        for (i=0; i < 100; i++)\n        {\n          if ((qvalue < hash[i]) && (sum < sums[i]))\n            continue;\n          if (((qvalue <= hash[i]) && (sum <= sums[i])) || (i >= 50))\n            image->quality=(size_t) i+1;\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"Quality: %.20g (%s)\",(double) i+1,(qvalue <= hash[i]) &&\n              (sum <= sums[i]) ? \"exact\" : \"approximate\");\n          break;\n        }\n      }\n    else\n      if (jpeg_info->quant_tbl_ptrs[0] != NULL)\n        {\n          ssize_t\n            hash[101] =\n            {\n              510,  505,  422,  380,  355,  338,  326,  318,  311,  305,\n              300,  297,  293,  291,  288,  286,  284,  283,  281,  280,\n              279,  278,  277,  273,  262,  251,  243,  233,  225,  218,\n              211,  205,  198,  193,  186,  181,  177,  172,  168,  164,\n              158,  156,  152,  148,  145,  142,  139,  136,  133,  131,\n              129,  126,  123,  120,  118,  115,  113,  110,  107,  105,\n              102,  100,   97,   94,   92,   89,   87,   83,   81,   79,\n               76,   74,   70,   68,   66,   63,   61,   57,   55,   52,\n               50,   48,   44,   42,   39,   37,   34,   31,   29,   26,\n               24,   21,   18,   16,   13,   11,    8,    6,    3,    2,\n                0\n            },\n            sums[101] =\n            {\n              16320, 16315, 15946, 15277, 14655, 14073, 13623, 13230, 12859,\n              12560, 12240, 11861, 11456, 11081, 10714, 10360, 10027,  9679,\n               9368,  9056,  8680,  8331,  7995,  7668,  7376,  7084,  6823,\n               6562,  6345,  6125,  5939,  5756,  5571,  5421,  5240,  5086,\n               4976,  4829,  4719,  4616,  4463,  4393,  4280,  4166,  4092,\n               3980,  3909,  3835,  3755,  3688,  3621,  3541,  3467,  3396,\n               3323,  3247,  3170,  3096,  3021,  2952,  2874,  2804,  2727,\n               2657,  2583,  2509,  2437,  2362,  2290,  2211,  2136,  2068,\n               1996,  1915,  1858,  1773,  1692,  1620,  1552,  1477,  1398,\n               1326,  1251,  1179,  1109,  1031,   961,   884,   814,   736,\n                667,   592,   518,   441,   369,   292,   221,   151,    86,\n                 64,     0\n            };\n\n          qvalue=(ssize_t) (jpeg_info->quant_tbl_ptrs[0]->quantval[2]+\n            jpeg_info->quant_tbl_ptrs[0]->quantval[53]);\n          for (i=0; i < 100; i++)\n          {\n            if ((qvalue < hash[i]) && (sum < sums[i]))\n              continue;\n            if (((qvalue <= hash[i]) && (sum <= sums[i])) || (i >= 50))\n              image->quality=(size_t)i+1;\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Quality: %.20g (%s)\",(double) i+1,(qvalue <= hash[i]) &&\n                (sum <= sums[i]) ? \"exact\" : \"approximate\");\n            break;\n          }\n        }\n  }\n}\n\nstatic void JPEGSetImageSamplingFactor(struct jpeg_decompress_struct *jpeg_info,  Image *image,ExceptionInfo *exception)\n{\n  char\n    sampling_factor[MagickPathExtent];\n\n  switch (jpeg_info->out_color_space)\n  {\n    case JCS_CMYK:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: CMYK\");\n      (void) FormatLocaleString(sampling_factor,MagickPathExtent,\n        \"%dx%d,%dx%d,%dx%d,%dx%d\",jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor,\n        jpeg_info->comp_info[1].h_samp_factor,\n        jpeg_info->comp_info[1].v_samp_factor,\n        jpeg_info->comp_info[2].h_samp_factor,\n        jpeg_info->comp_info[2].v_samp_factor,\n        jpeg_info->comp_info[3].h_samp_factor,\n        jpeg_info->comp_info[3].v_samp_factor);\n      break;\n    }\n    case JCS_GRAYSCALE:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"Colorspace: GRAYSCALE\");\n      (void) FormatLocaleString(sampling_factor,MagickPathExtent,\"%dx%d\",\n        jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor);\n      break;\n    }\n    case JCS_RGB:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: RGB\");\n      (void) FormatLocaleString(sampling_factor,MagickPathExtent,\n        \"%dx%d,%dx%d,%dx%d\",jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor,\n        jpeg_info->comp_info[1].h_samp_factor,\n        jpeg_info->comp_info[1].v_samp_factor,\n        jpeg_info->comp_info[2].h_samp_factor,\n        jpeg_info->comp_info[2].v_samp_factor);\n      break;\n    }\n    default:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: %d\",\n        jpeg_info->out_color_space);\n      (void) FormatLocaleString(sampling_factor,MagickPathExtent,\n        \"%dx%d,%dx%d,%dx%d,%dx%d\",jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor,\n        jpeg_info->comp_info[1].h_samp_factor,\n        jpeg_info->comp_info[1].v_samp_factor,\n        jpeg_info->comp_info[2].h_samp_factor,\n        jpeg_info->comp_info[2].v_samp_factor,\n        jpeg_info->comp_info[3].h_samp_factor,\n        jpeg_info->comp_info[3].v_samp_factor);\n      break;\n    }\n  }\n  (void) SetImageProperty(image,\"jpeg:sampling-factor\",sampling_factor,\n    exception);\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Sampling Factors: %s\",\n    sampling_factor);\n}\n\nstatic Image *ReadJPEGImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    value[MagickPathExtent];\n\n  const char\n    *dct_method,\n    *option;\n\n  ErrorManager\n    error_manager;\n\n  Image\n    *image;\n\n  JSAMPLE\n    *volatile jpeg_pixels;\n\n  JSAMPROW\n    scanline[1];\n\n  MagickBooleanType\n    debug,\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *memory_info;\n\n  Quantum\n    index;\n\n  register ssize_t\n    i;\n\n  struct jpeg_decompress_struct\n    jpeg_info;\n\n  struct jpeg_error_mgr\n    jpeg_error;\n\n  struct jpeg_progress_mgr\n    jpeg_progress;\n\n  register JSAMPLE\n    *p;\n\n  size_t\n    units;\n\n  ssize_t\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  debug=IsEventLogging();\n  (void) debug;\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Verify that file size large enough to contain a JPEG datastream.\n  */\n  if (GetBlobSize(image) < 107)\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n  /*\n    Initialize JPEG parameters.\n  */\n  (void) memset(&error_manager,0,sizeof(error_manager));\n  (void) memset(&jpeg_info,0,sizeof(jpeg_info));\n  (void) memset(&jpeg_error,0,sizeof(jpeg_error));\n  (void) memset(&jpeg_progress,0,sizeof(jpeg_progress));\n  jpeg_info.err=jpeg_std_error(&jpeg_error);\n  jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;\n  jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;\n  memory_info=(MemoryInfo *) NULL;\n  error_manager.exception=exception;\n  error_manager.image=image;\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      if (error_manager.profile != (StringInfo *) NULL)\n        error_manager.profile=DestroyStringInfo(error_manager.profile);\n      (void) CloseBlob(image);\n      number_pixels=(MagickSizeType) image->columns*image->rows;\n      if (number_pixels != 0)\n        return(GetFirstImageInList(image));\n      return(DestroyImage(image));\n    }\n  jpeg_info.client_data=(void *) &error_manager;\n  jpeg_create_decompress(&jpeg_info);\n  if (GetMaxMemoryRequest() != ~0UL)\n    jpeg_info.mem->max_memory_to_use=(long) GetMaxMemoryRequest();\n  jpeg_progress.progress_monitor=(void (*)(j_common_ptr)) JPEGProgressHandler;\n  jpeg_info.progress=(&jpeg_progress);\n  JPEGSourceManager(&jpeg_info,image);\n  jpeg_set_marker_processor(&jpeg_info,JPEG_COM,ReadComment);\n  option=GetImageOption(image_info,\"profile:skip\");\n  if (IsOptionMember(\"ICC\",option) == MagickFalse)\n    jpeg_set_marker_processor(&jpeg_info,ICC_MARKER,ReadICCProfile);\n  if (IsOptionMember(\"IPTC\",option) == MagickFalse)\n    jpeg_set_marker_processor(&jpeg_info,IPTC_MARKER,ReadIPTCProfile);\n  for (i=1; i < 16; i++)\n    if ((i != 2) && (i != 13) && (i != 14))\n      if (IsOptionMember(\"APP\",option) == MagickFalse)\n        jpeg_set_marker_processor(&jpeg_info,(int) (JPEG_APP0+i),ReadProfile);\n  i=(ssize_t) jpeg_read_header(&jpeg_info,TRUE);\n  if ((image_info->colorspace == YCbCrColorspace) ||\n      (image_info->colorspace == Rec601YCbCrColorspace) ||\n      (image_info->colorspace == Rec709YCbCrColorspace))\n    jpeg_info.out_color_space=JCS_YCbCr;\n  /*\n    Set image resolution.\n  */\n  units=0;\n  if ((jpeg_info.saw_JFIF_marker != 0) && (jpeg_info.X_density != 1) &&\n      (jpeg_info.Y_density != 1))\n    {\n      image->resolution.x=(double) jpeg_info.X_density;\n      image->resolution.y=(double) jpeg_info.Y_density;\n      units=(size_t) jpeg_info.density_unit;\n    }\n  if (units == 1)\n    image->units=PixelsPerInchResolution;\n  if (units == 2)\n    image->units=PixelsPerCentimeterResolution;\n  number_pixels=(MagickSizeType) image->columns*image->rows;\n  option=GetImageOption(image_info,\"jpeg:size\");\n  if ((option != (const char *) NULL) &&\n      (jpeg_info.out_color_space != JCS_YCbCr))\n    {\n      double\n        scale_factor;\n\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      /*\n        Scale the image.\n      */\n      flags=ParseGeometry(option,&geometry_info);\n      if ((flags & SigmaValue) == 0)\n        geometry_info.sigma=geometry_info.rho;\n      jpeg_calc_output_dimensions(&jpeg_info);\n      image->magick_columns=jpeg_info.output_width;\n      image->magick_rows=jpeg_info.output_height;\n      scale_factor=1.0;\n      if (geometry_info.rho != 0.0)\n        scale_factor=jpeg_info.output_width/geometry_info.rho;\n      if ((geometry_info.sigma != 0.0) &&\n          (scale_factor > (jpeg_info.output_height/geometry_info.sigma)))\n        scale_factor=jpeg_info.output_height/geometry_info.sigma;\n      jpeg_info.scale_num=1U;\n      jpeg_info.scale_denom=(unsigned int) scale_factor;\n      jpeg_calc_output_dimensions(&jpeg_info);\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Scale factor: %.20g\",(double) scale_factor);\n    }\n#if (JPEG_LIB_VERSION >= 61) && defined(D_PROGRESSIVE_SUPPORTED)\n#if defined(D_LOSSLESS_SUPPORTED)\n  image->interlace=jpeg_info.process == JPROC_PROGRESSIVE ?\n    JPEGInterlace : NoInterlace;\n  image->compression=jpeg_info.process == JPROC_LOSSLESS ?\n    LosslessJPEGCompression : JPEGCompression;\n  if (jpeg_info.data_precision > 8)\n    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n      \"12-bit JPEG not supported. Reducing pixel data to 8 bits\",\"`%s'\",\n      image->filename);\n  if (jpeg_info.data_precision == 16)\n    jpeg_info.data_precision=12;\n#else\n  image->interlace=jpeg_info.progressive_mode != 0 ? JPEGInterlace :\n    NoInterlace;\n  image->compression=JPEGCompression;\n#endif\n#else\n  image->compression=JPEGCompression;\n  image->interlace=JPEGInterlace;\n#endif\n  option=GetImageOption(image_info,\"jpeg:colors\");\n  if (option != (const char *) NULL)\n    {\n      /*\n        Let the JPEG library quantize the image.\n      */\n      jpeg_info.quantize_colors=TRUE;\n      jpeg_info.desired_number_of_colors=(int) StringToUnsignedLong(option);\n    }\n  option=GetImageOption(image_info,\"jpeg:block-smoothing\");\n  if (option != (const char *) NULL)\n    jpeg_info.do_block_smoothing=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  dct_method=GetImageOption(image_info,\"jpeg:dct-method\");\n  if (dct_method != (const char *) NULL)\n    switch (*dct_method)\n    {\n      case 'D':\n      case 'd':\n      {\n        if (LocaleCompare(dct_method,\"default\") == 0)\n          jpeg_info.dct_method=JDCT_DEFAULT;\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        if (LocaleCompare(dct_method,\"fastest\") == 0)\n          jpeg_info.dct_method=JDCT_FASTEST;\n        if (LocaleCompare(dct_method,\"float\") == 0)\n          jpeg_info.dct_method=JDCT_FLOAT;\n        break;\n      }\n      case 'I':\n      case 'i':\n      {\n        if (LocaleCompare(dct_method,\"ifast\") == 0)\n          jpeg_info.dct_method=JDCT_IFAST;\n        if (LocaleCompare(dct_method,\"islow\") == 0)\n          jpeg_info.dct_method=JDCT_ISLOW;\n        break;\n      }\n    }\n  option=GetImageOption(image_info,\"jpeg:fancy-upsampling\");\n  if (option != (const char *) NULL)\n    jpeg_info.do_fancy_upsampling=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  jpeg_calc_output_dimensions(&jpeg_info);\n  image->columns=jpeg_info.output_width;\n  image->rows=jpeg_info.output_height;\n  image->depth=(size_t) jpeg_info.data_precision;\n  switch (jpeg_info.out_color_space)\n  {\n    case JCS_RGB:\n    default:\n    {\n      (void) SetImageColorspace(image,sRGBColorspace,exception);\n      break;\n    }\n    case JCS_GRAYSCALE:\n    {\n      (void) SetImageColorspace(image,GRAYColorspace,exception);\n      break;\n    }\n    case JCS_YCbCr:\n    {\n      (void) SetImageColorspace(image,YCbCrColorspace,exception);\n      break;\n    }\n    case JCS_CMYK:\n    {\n      (void) SetImageColorspace(image,CMYKColorspace,exception);\n      break;\n    }\n  }\n  if (IsITUFaxImage(image) != MagickFalse)\n    {\n      (void) SetImageColorspace(image,LabColorspace,exception);\n      jpeg_info.out_color_space=JCS_YCbCr;\n    }\n  option=GetImageOption(image_info,\"jpeg:colors\");\n  if (option != (const char *) NULL)\n    if (AcquireImageColormap(image,StringToUnsignedLong(option),exception) == MagickFalse)\n      {\n        jpeg_destroy_decompress(&jpeg_info);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n  if ((jpeg_info.output_components == 1) && (jpeg_info.quantize_colors == 0))\n    {\n      size_t\n        colors;\n\n      colors=(size_t) GetQuantumRange(image->depth)+1;\n      if (AcquireImageColormap(image,colors,exception) == MagickFalse)\n        {\n          jpeg_destroy_decompress(&jpeg_info);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n    }\n  if (image->debug != MagickFalse)\n    {\n      if (image->interlace != NoInterlace)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: progressive\");\n      else\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: nonprogressive\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Data precision: %d\",\n        (int) jpeg_info.data_precision);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %dx%d\",\n        (int) jpeg_info.output_width,(int) jpeg_info.output_height);\n    }\n  JPEGSetImageQuality(&jpeg_info,image);\n  JPEGSetImageSamplingFactor(&jpeg_info,image,exception);\n  (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n    jpeg_info.out_color_space);\n  (void) SetImageProperty(image,\"jpeg:colorspace\",value,exception);\n#if defined(D_ARITH_CODING_SUPPORTED)\n  if (jpeg_info.arith_code == TRUE)\n    (void) SetImageProperty(image,\"jpeg:coding\",\"arithmetic\",exception);\n#endif\n  if (image_info->ping != MagickFalse)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      return(DestroyImageList(image));\n    }\n  (void) jpeg_start_decompress(&jpeg_info);\n  if ((jpeg_info.output_components != 1) &&\n      (jpeg_info.output_components != 3) && (jpeg_info.output_components != 4))\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      ThrowReaderException(CorruptImageError,\"ImageTypeNotSupported\");\n    }\n  memory_info=AcquireVirtualMemory((size_t) image->columns,\n    jpeg_info.output_components*sizeof(*jpeg_pixels));\n  if (memory_info == (MemoryInfo *) NULL)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);\n  (void) memset(jpeg_pixels,0,image->columns*\n    jpeg_info.output_components*sizeof(*jpeg_pixels));\n  /*\n    Convert JPEG pixels to pixel packets.\n  */\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      if (memory_info != (MemoryInfo *) NULL)\n        memory_info=RelinquishVirtualMemory(memory_info);\n      jpeg_destroy_decompress(&jpeg_info);\n      (void) CloseBlob(image);\n      number_pixels=(MagickSizeType) image->columns*image->rows;\n      if (number_pixels != 0)\n        return(GetFirstImageInList(image));\n      return(DestroyImage(image));\n    }\n  if (jpeg_info.quantize_colors != 0)\n    {\n      image->colors=(size_t) jpeg_info.actual_number_of_colors;\n      if (jpeg_info.out_color_space == JCS_GRAYSCALE)\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=(double) ScaleCharToQuantum(\n            jpeg_info.colormap[0][i]);\n          image->colormap[i].green=image->colormap[i].red;\n          image->colormap[i].blue=image->colormap[i].red;\n          image->colormap[i].alpha=(MagickRealType) OpaqueAlpha;\n        }\n      else\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=(double) ScaleCharToQuantum(\n            jpeg_info.colormap[0][i]);\n          image->colormap[i].green=(double) ScaleCharToQuantum(\n            jpeg_info.colormap[1][i]);\n          image->colormap[i].blue=(double) ScaleCharToQuantum(\n            jpeg_info.colormap[2][i]);\n          image->colormap[i].alpha=(MagickRealType) OpaqueAlpha;\n        }\n    }\n  scanline[0]=(JSAMPROW) jpeg_pixels;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (jpeg_read_scanlines(&jpeg_info,scanline,1) != 1)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"SkipToSyncByte\",\"`%s'\",image->filename);\n        continue;\n      }\n    p=jpeg_pixels;\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    if (jpeg_info.data_precision > 8)\n      {\n        unsigned short\n          scale;\n\n        scale=65535/(unsigned short) GetQuantumRange((size_t)\n          jpeg_info.data_precision);\n        if (jpeg_info.output_components == 1)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            ssize_t\n              pixel;\n\n            pixel=(ssize_t) (scale*GETJSAMPLE(*p));\n            index=(Quantum) ConstrainColormapIndex(image,pixel,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            p++;\n            q+=GetPixelChannels(image);\n          }\n        else\n          if (image->colorspace != CMYKColorspace)\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(image,ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelGreen(image,ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelBlue(image,ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelAlpha(image,OpaqueAlpha,q);\n              q+=GetPixelChannels(image);\n            }\n          else\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelCyan(image,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelMagenta(image,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelYellow(image,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelBlack(image,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelAlpha(image,OpaqueAlpha,q);\n              q+=GetPixelChannels(image);\n            }\n      }\n    else\n      if (jpeg_info.output_components == 1)\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          ssize_t\n            pixel;\n\n          pixel=(ssize_t) GETJSAMPLE(*p);\n          index=(Quantum) ConstrainColormapIndex(image,pixel,exception);\n          SetPixelIndex(image,index,q);\n          SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n          p++;\n          q+=GetPixelChannels(image);\n        }\n      else\n        if (image->colorspace != CMYKColorspace)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)),q);\n            SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)),q);\n            SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            q+=GetPixelChannels(image);\n          }\n        else\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(image,QuantumRange-ScaleCharToQuantum(\n              (unsigned char) GETJSAMPLE(*p++)),q);\n            SetPixelMagenta(image,QuantumRange-ScaleCharToQuantum(\n              (unsigned char) GETJSAMPLE(*p++)),q);\n            SetPixelYellow(image,QuantumRange-ScaleCharToQuantum(\n              (unsigned char) GETJSAMPLE(*p++)),q);\n            SetPixelBlack(image,QuantumRange-ScaleCharToQuantum(\n              (unsigned char) GETJSAMPLE(*p++)),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            q+=GetPixelChannels(image);\n          }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      {\n        jpeg_abort_decompress(&jpeg_info);\n        break;\n      }\n  }\n  if (status != MagickFalse)\n    {\n      error_manager.finished=MagickTrue;\n      if (setjmp(error_manager.error_recovery) == 0)\n        (void) jpeg_finish_decompress(&jpeg_info);\n    }\n  /*\n    Free jpeg resources.\n  */\n  jpeg_destroy_decompress(&jpeg_info);\n  memory_info=RelinquishVirtualMemory(memory_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r J P E G I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterJPEGImage() adds properties for the JPEG image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterJPEGImage method is:\n%\n%      size_t RegisterJPEGImage(void)\n%\n*/\nModuleExport size_t RegisterJPEGImage(void)\n{\n#define JPEGDescription \"Joint Photographic Experts Group JFIF format\"\n#define JPEGStringify(macro_or_string)  JPEGStringifyArg(macro_or_string)\n#define JPEGStringifyArg(contents)  #contents\n\n  char\n    version[MagickPathExtent];\n\n  MagickInfo\n    *entry;\n\n  *version='\\0';\n#if defined(LIBJPEG_TURBO_VERSION)\n  (void) CopyMagickString(version,\"libjpeg-turbo \" JPEGStringify(\n    LIBJPEG_TURBO_VERSION),MagickPathExtent);\n#elif defined(JPEG_LIB_VERSION)\n  (void) FormatLocaleString(version,MagickPathExtent,\"libjpeg %d\",\n    JPEG_LIB_VERSION);\n#endif\n  entry=AcquireMagickInfo(\"JPEG\",\"JPE\",JPEGDescription);\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsJPEG;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"JPEG\",\"JPEG\",JPEGDescription);\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsJPEG;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"JPEG\",\"JPG\",JPEGDescription);\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"JPEG\",\"JPS\",JPEGDescription);\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"JPEG\",\"PJPEG\",JPEGDescription);\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r J P E G I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterJPEGImage() removes format registrations made by the\n%  JPEG module from the list of supported formats.\n%\n%  The format of the UnregisterJPEGImage method is:\n%\n%      UnregisterJPEGImage(void)\n%\n*/\nModuleExport void UnregisterJPEGImage(void)\n{\n  (void) UnregisterMagickInfo(\"PJPG\");\n  (void) UnregisterMagickInfo(\"JPS\");\n  (void) UnregisterMagickInfo(\"JPG\");\n  (void) UnregisterMagickInfo(\"JPEG\");\n  (void) UnregisterMagickInfo(\"JPE\");\n}\n\f\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  W r i t e J P E G I m a g e                                                %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteJPEGImage() writes a JPEG image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the WriteJPEGImage method is:\n%\n%      MagickBooleanType WriteJPEGImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o jpeg_image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic QuantizationTable *DestroyQuantizationTable(QuantizationTable *table)\n{\n  assert(table != (QuantizationTable *) NULL);\n  if (table->slot != (char *) NULL)\n    table->slot=DestroyString(table->slot);\n  if (table->description != (char *) NULL)\n    table->description=DestroyString(table->description);\n  if (table->levels != (unsigned int *) NULL)\n    table->levels=(unsigned int *) RelinquishMagickMemory(table->levels);\n  table=(QuantizationTable *) RelinquishMagickMemory(table);\n  return(table);\n}\n\nstatic boolean EmptyOutputBuffer(j_compress_ptr cinfo)\n{\n  DestinationManager\n    *destination;\n\n  destination=(DestinationManager *) cinfo->dest;\n  destination->manager.free_in_buffer=(size_t) WriteBlob(destination->image,\n    MagickMinBufferExtent,destination->buffer);\n  if (destination->manager.free_in_buffer != MagickMinBufferExtent)\n    ERREXIT(cinfo,JERR_FILE_WRITE);\n  destination->manager.next_output_byte=destination->buffer;\n  return(TRUE);\n}\n\nstatic QuantizationTable *GetQuantizationTable(const char *filename,\n  const char *slot,ExceptionInfo *exception)\n{\n  char\n    *p,\n    *xml;\n\n  const char\n    *attribute,\n    *content;\n\n  double\n    value;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    j;\n\n  QuantizationTable\n    *table;\n\n  size_t\n    length;\n\n  XMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\n\n  (void) LogMagickEvent(ConfigureEvent,GetMagickModule(),\n    \"Loading quantization tables \\\"%s\\\" ...\",filename);\n  table=(QuantizationTable *) NULL;\n  xml=FileToString(filename,~0UL,exception);\n  if (xml == (char *) NULL)\n    return(table);\n  quantization_tables=NewXMLTree(xml,exception);\n  if (quantization_tables == (XMLTreeInfo *) NULL)\n    {\n      xml=DestroyString(xml);\n      return(table);\n    }\n  for (table_iterator=GetXMLTreeChild(quantization_tables,\"table\");\n       table_iterator != (XMLTreeInfo *) NULL;\n       table_iterator=GetNextXMLTreeTag(table_iterator))\n  {\n    attribute=GetXMLTreeAttribute(table_iterator,\"slot\");\n    if ((attribute != (char *) NULL) && (LocaleCompare(slot,attribute) == 0))\n      break;\n    attribute=GetXMLTreeAttribute(table_iterator,\"alias\");\n    if ((attribute != (char *) NULL) && (LocaleCompare(slot,attribute) == 0))\n      break;\n  }\n  if (table_iterator == (XMLTreeInfo *) NULL)\n    {\n      xml=DestroyString(xml);\n      return(table);\n    }\n  description=GetXMLTreeChild(table_iterator,\"description\");\n  if (description == (XMLTreeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingElement\",\"<description>, slot \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  levels=GetXMLTreeChild(table_iterator,\"levels\");\n  if (levels == (XMLTreeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingElement\",\"<levels>, slot \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table=(QuantizationTable *) AcquireCriticalMemory(sizeof(*table));\n  table->slot=(char *) NULL;\n  table->description=(char *) NULL;\n  table->levels=(unsigned int *) NULL;\n  attribute=GetXMLTreeAttribute(table_iterator,\"slot\");\n  if (attribute != (char *) NULL)\n    table->slot=ConstantString(attribute);\n  content=GetXMLTreeContent(description);\n  if (content != (char *) NULL)\n    table->description=ConstantString(content);\n  attribute=GetXMLTreeAttribute(levels,\"width\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\",\"<levels width>, slot \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table->width=StringToUnsignedLong(attribute);\n  if (table->width == 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n       \"XmlInvalidAttribute\",\"<levels width>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  attribute=GetXMLTreeAttribute(levels,\"height\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\",\"<levels height>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table->height=StringToUnsignedLong(attribute);\n  if (table->height == 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidAttribute\",\"<levels height>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  attribute=GetXMLTreeAttribute(levels,\"divisor\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\",\"<levels divisor>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table->divisor=InterpretLocaleValue(attribute,(char **) NULL);\n  if (table->divisor == 0.0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidAttribute\",\"<levels divisor>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  content=GetXMLTreeContent(levels);\n  if (content == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingContent\",\"<levels>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  length=(size_t) table->width*table->height;\n  if (length < 64)\n    length=64;\n  table->levels=(unsigned int *) AcquireQuantumMemory(length,\n    sizeof(*table->levels));\n  if (table->levels == (unsigned int *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\n      \"UnableToAcquireQuantizationTable\");\n  for (i=0; i < (ssize_t) (table->width*table->height); i++)\n  {\n    table->levels[i]=(unsigned int) (InterpretLocaleValue(content,&p)/\n      table->divisor+0.5);\n    while (isspace((int) ((unsigned char) *p)) != 0)\n      p++;\n    if (*p == ',')\n      p++;\n    content=p;\n  }\n  value=InterpretLocaleValue(content,&p);\n  (void) value;\n  if (p != content)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidContent\",\"<level> too many values, table \\\"%s\\\"\",slot);\n     quantization_tables=DestroyXMLTree(quantization_tables);\n     table=DestroyQuantizationTable(table);\n     xml=DestroyString(xml);\n     return(table);\n   }\n  for (j=i; j < 64; j++)\n    table->levels[j]=table->levels[j-1];\n  quantization_tables=DestroyXMLTree(quantization_tables);\n  xml=DestroyString(xml);\n  return(table);\n}\n\nstatic void InitializeDestination(j_compress_ptr cinfo)\n{\n  DestinationManager\n    *destination;\n\n  destination=(DestinationManager *) cinfo->dest;\n  destination->buffer=(JOCTET *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,MagickMinBufferExtent*sizeof(JOCTET));\n  destination->manager.next_output_byte=destination->buffer;\n  destination->manager.free_in_buffer=MagickMinBufferExtent;\n}\n\nstatic void TerminateDestination(j_compress_ptr cinfo)\n{\n  DestinationManager\n    *destination;\n\n  destination=(DestinationManager *) cinfo->dest;\n  if ((MagickMinBufferExtent-(int) destination->manager.free_in_buffer) > 0)\n    {\n      ssize_t\n        count;\n\n      count=WriteBlob(destination->image,MagickMinBufferExtent-\n        destination->manager.free_in_buffer,destination->buffer);\n      if (count != (ssize_t)\n          (MagickMinBufferExtent-destination->manager.free_in_buffer))\n        ERREXIT(cinfo,JERR_FILE_WRITE);\n    }\n}\n\nstatic void WriteProfile(j_compress_ptr jpeg_info,Image *image,\n  ExceptionInfo *exception)\n{\n  const char\n    *name;\n\n  const StringInfo\n    *profile;\n\n  MagickBooleanType\n    iptc;\n\n  register ssize_t\n    i;\n\n  size_t\n    length,\n    tag_length;\n\n  StringInfo\n    *custom_profile;\n\n  /*\n    Save image profile as a APP marker.\n  */\n  iptc=MagickFalse;\n  custom_profile=AcquireStringInfo(65535L);\n  ResetImageProfileIterator(image);\n  for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n  {\n    profile=GetImageProfile(image,name);\n    length=GetStringInfoLength(profile);\n    if (LocaleNCompare(name,\"APP\",3) == 0)\n      {\n        int\n          id;\n\n        id=JPEG_APP0+StringToInteger(name+3);\n        for (i=0; i < (ssize_t) length; i+=65533L)\n           jpeg_write_marker(jpeg_info,id,GetStringInfoDatum(profile)+i,\n             (unsigned int) MagickMin(length-i,65533));\n      }\n    if (LocaleCompare(name,\"EXIF\") == 0)\n      {\n        length=GetStringInfoLength(profile);\n        if (length > 65533L)\n          {\n            (void) ThrowMagickException(exception,GetMagickModule(),\n              CoderWarning,\"ExifProfileSizeExceedsLimit\",\"`%s'\",\n              image->filename);\n            length=65533L;\n          }\n        jpeg_write_marker(jpeg_info,XML_MARKER,GetStringInfoDatum(profile),\n          (unsigned int) length);\n      }\n    if (LocaleCompare(name,\"ICC\") == 0)\n      {\n        register unsigned char\n          *p;\n\n        tag_length=strlen(ICC_PROFILE);\n        p=GetStringInfoDatum(custom_profile);\n        (void) memcpy(p,ICC_PROFILE,tag_length);\n        p[tag_length]='\\0';\n        for (i=0; i < (ssize_t) GetStringInfoLength(profile); i+=65519L)\n        {\n          length=MagickMin(GetStringInfoLength(profile)-i,65519L);\n          p[12]=(unsigned char) ((i/65519L)+1);\n          p[13]=(unsigned char) (GetStringInfoLength(profile)/65519L+1);\n          (void) memcpy(p+tag_length+3,GetStringInfoDatum(profile)+i,\n            length);\n          jpeg_write_marker(jpeg_info,ICC_MARKER,GetStringInfoDatum(\n            custom_profile),(unsigned int) (length+tag_length+3));\n        }\n      }\n    if (((LocaleCompare(name,\"IPTC\") == 0) ||\n        (LocaleCompare(name,\"8BIM\") == 0)) && (iptc == MagickFalse))\n      {\n        register unsigned char\n          *p;\n\n        size_t\n          roundup;\n\n        iptc=MagickTrue;\n        p=GetStringInfoDatum(custom_profile);\n        for (i=0; i < (ssize_t) GetStringInfoLength(profile); i+=65500L)\n        {\n          length=MagickMin(GetStringInfoLength(profile)-i,65500L);\n          roundup=(size_t) (length & 0x01);\n          if (LocaleNCompare((char *) GetStringInfoDatum(profile),\"8BIM\",4) == 0)\n            {\n              (void) memcpy(p,\"Photoshop 3.0 \",14);\n              tag_length=14;\n            }\n          else\n            {\n              (void) memcpy(p,\"Photoshop 3.0 8BIM\\04\\04\\0\\0\\0\\0\",24);\n              tag_length=26;\n              p[24]=(unsigned char) (length >> 8);\n              p[25]=(unsigned char) (length & 0xff);\n            }\n          p[13]=0x00;\n          (void) memcpy(p+tag_length,GetStringInfoDatum(profile)+i,length);\n          if (roundup != 0)\n            p[length+tag_length]='\\0';\n          jpeg_write_marker(jpeg_info,IPTC_MARKER,GetStringInfoDatum(\n            custom_profile),(unsigned int) (length+tag_length+roundup));\n        }\n      }\n   if ((LocaleCompare(name,\"XMP\") == 0) &&\n       (GetStringInfoLength(profile) <= 65502))\n      {\n        StringInfo\n          *xmp_profile;\n\n        /*\n          Add namespace to XMP profile.\n        */\n        xmp_profile=StringToStringInfo(xmp_namespace);\n        if (xmp_profile != (StringInfo *) NULL)\n          {\n            if (profile != (StringInfo *) NULL)\n              ConcatenateStringInfo(xmp_profile,profile);\n            GetStringInfoDatum(xmp_profile)[XmpNamespaceExtent]='\\0';\n            for (i=0; i < (ssize_t) GetStringInfoLength(xmp_profile); i+=65533L)\n            {\n              length=MagickMin(GetStringInfoLength(xmp_profile)-i,65533L);\n              jpeg_write_marker(jpeg_info,XML_MARKER,\n                GetStringInfoDatum(xmp_profile)+i,(unsigned int) length);\n            }\n            xmp_profile=DestroyStringInfo(xmp_profile);\n          }\n      }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"%s profile: %.20g bytes\",name,(double) GetStringInfoLength(profile));\n    name=GetNextImageProfile(image);\n  }\n  custom_profile=DestroyStringInfo(custom_profile);\n}\n\nstatic void JPEGDestinationManager(j_compress_ptr cinfo,Image * image)\n{\n  DestinationManager\n    *destination;\n\n  cinfo->dest=(struct jpeg_destination_mgr *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,sizeof(DestinationManager));\n  destination=(DestinationManager *) cinfo->dest;\n  destination->manager.init_destination=InitializeDestination;\n  destination->manager.empty_output_buffer=EmptyOutputBuffer;\n  destination->manager.term_destination=TerminateDestination;\n  destination->image=image;\n}\n\nstatic char **SamplingFactorToList(const char *text)\n{\n  char\n    **textlist;\n\n  register char\n    *q;\n\n  register const char\n    *p;\n\n  register ssize_t\n    i;\n\n  if (text == (char *) NULL)\n    return((char **) NULL);\n  /*\n    Convert string to an ASCII list.\n  */\n  textlist=(char **) AcquireQuantumMemory((size_t) MAX_COMPONENTS,\n    sizeof(*textlist));\n  if (textlist == (char **) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"UnableToConvertText\");\n  p=text;\n  for (i=0; i < (ssize_t) MAX_COMPONENTS; i++)\n  {\n    for (q=(char *) p; *q != '\\0'; q++)\n      if (*q == ',')\n        break;\n    textlist[i]=(char *) AcquireQuantumMemory((size_t) (q-p)+MagickPathExtent,\n      sizeof(*textlist[i]));\n    if (textlist[i] == (char *) NULL)\n      ThrowFatalException(ResourceLimitFatalError,\"UnableToConvertText\");\n    (void) CopyMagickString(textlist[i],p,(size_t) (q-p+1));\n    if (*q == '\\r')\n      q++;\n    if (*q == '\\0')\n      break;\n    p=q+1;\n  }\n  for (i++; i < (ssize_t) MAX_COMPONENTS; i++)\n    textlist[i]=ConstantString(\"1x1\");\n  return(textlist);\n}\n\nstatic MagickBooleanType WriteJPEGImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  const char\n    *dct_method,\n    *option,\n    *sampling_factor,\n    *value;\n\n  ErrorManager\n    error_manager;\n\n  Image\n    *volatile volatile_image;\n\n  int\n    colorspace,\n    quality;\n\n  JSAMPLE\n    *volatile jpeg_pixels;\n\n  JSAMPROW\n    scanline[1];\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *memory_info;\n\n  register JSAMPLE\n    *q;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  struct jpeg_compress_struct\n    jpeg_info;\n\n  struct jpeg_error_mgr\n    jpeg_error;\n\n  unsigned short\n    scale;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if ((LocaleCompare(image_info->magick,\"JPS\") == 0) &&\n      (image->next != (Image *) NULL))\n    image=AppendImages(image,MagickFalse,exception);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Initialize JPEG parameters.\n  */\n  (void) memset(&error_manager,0,sizeof(error_manager));\n  (void) memset(&jpeg_info,0,sizeof(jpeg_info));\n  (void) memset(&jpeg_error,0,sizeof(jpeg_error));\n  volatile_image=image;\n  jpeg_info.client_data=(void *) volatile_image;\n  jpeg_info.err=jpeg_std_error(&jpeg_error);\n  jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;\n  jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;\n  error_manager.exception=exception;\n  error_manager.image=volatile_image;\n  memory_info=(MemoryInfo *) NULL;\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      jpeg_destroy_compress(&jpeg_info);\n      (void) CloseBlob(volatile_image);\n      return(MagickFalse);\n    }\n  jpeg_info.client_data=(void *) &error_manager;\n  jpeg_create_compress(&jpeg_info);\n  JPEGDestinationManager(&jpeg_info,image);\n  if ((image->columns != (unsigned int) image->columns) ||\n      (image->rows != (unsigned int) image->rows))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  jpeg_info.image_width=(unsigned int) image->columns;\n  jpeg_info.image_height=(unsigned int) image->rows;\n  jpeg_info.input_components=3;\n  jpeg_info.data_precision=8;\n  jpeg_info.in_color_space=JCS_RGB;\n  switch (image->colorspace)\n  {\n    case CMYKColorspace:\n    {\n      jpeg_info.input_components=4;\n      jpeg_info.in_color_space=JCS_CMYK;\n      break;\n    }\n    case YCbCrColorspace:\n    case Rec601YCbCrColorspace:\n    case Rec709YCbCrColorspace:\n    {\n      jpeg_info.in_color_space=JCS_YCbCr;\n      break;\n    }\n    case LinearGRAYColorspace:\n    case GRAYColorspace:\n    {\n      if (image_info->type == TrueColorType)\n        break;\n      jpeg_info.input_components=1;\n      jpeg_info.in_color_space=JCS_GRAYSCALE;\n      break;\n    }\n    default:\n    {\n      (void) TransformImageColorspace(image,sRGBColorspace,exception);\n      if (image_info->type == TrueColorType)\n        break;\n      if (SetImageGray(image,exception) != MagickFalse)\n        {\n          jpeg_info.input_components=1;\n          jpeg_info.in_color_space=JCS_GRAYSCALE;\n        }\n      break;\n    }\n  }\n  jpeg_set_defaults(&jpeg_info);\n  if (jpeg_info.in_color_space == JCS_CMYK)\n    jpeg_set_colorspace(&jpeg_info,JCS_YCCK);\n  if ((jpeg_info.data_precision != 12) && (image->depth <= 8))\n    jpeg_info.data_precision=8;\n  else\n    jpeg_info.data_precision=BITS_IN_JSAMPLE;\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Image resolution: %.20g,%.20g\",image->resolution.x,image->resolution.y);\n  if ((image->resolution.x != 0.0) && (image->resolution.y != 0.0))\n    {\n      /*\n        Set image resolution.\n      */\n      jpeg_info.write_JFIF_header=TRUE;\n      jpeg_info.X_density=(UINT16) image->resolution.x;\n      jpeg_info.Y_density=(UINT16) image->resolution.y;\n      /*\n        Set image resolution units.\n      */\n      if (image->units == PixelsPerInchResolution)\n        jpeg_info.density_unit=(UINT8) 1;\n      if (image->units == PixelsPerCentimeterResolution)\n        jpeg_info.density_unit=(UINT8) 2;\n    }\n  dct_method=GetImageOption(image_info,\"jpeg:dct-method\");\n  if (dct_method != (const char *) NULL)\n    switch (*dct_method)\n    {\n      case 'D':\n      case 'd':\n      {\n        if (LocaleCompare(dct_method,\"default\") == 0)\n          jpeg_info.dct_method=JDCT_DEFAULT;\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        if (LocaleCompare(dct_method,\"fastest\") == 0)\n          jpeg_info.dct_method=JDCT_FASTEST;\n        if (LocaleCompare(dct_method,\"float\") == 0)\n          jpeg_info.dct_method=JDCT_FLOAT;\n        break;\n      }\n      case 'I':\n      case 'i':\n      {\n        if (LocaleCompare(dct_method,\"ifast\") == 0)\n          jpeg_info.dct_method=JDCT_IFAST;\n        if (LocaleCompare(dct_method,\"islow\") == 0)\n          jpeg_info.dct_method=JDCT_ISLOW;\n        break;\n      }\n    }\n  option=GetImageOption(image_info,\"jpeg:optimize-coding\");\n  if (option != (const char *) NULL)\n    jpeg_info.optimize_coding=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  else\n    {\n      MagickSizeType\n        length;\n\n      length=(MagickSizeType) jpeg_info.input_components*image->columns*\n        image->rows*sizeof(JSAMPLE);\n      if (length == (MagickSizeType) ((size_t) length))\n        {\n          /*\n            Perform optimization only if available memory resources permit it.\n          */\n          status=AcquireMagickResource(MemoryResource,length);\n          if (status != MagickFalse)\n            RelinquishMagickResource(MemoryResource,length);\n          jpeg_info.optimize_coding=status == MagickFalse ? FALSE : TRUE;\n        }\n    }\n#if defined(C_ARITH_CODING_SUPPORTED)\n  option=GetImageOption(image_info,\"jpeg:arithmetic-coding\");\n  if (IsStringTrue(option) != MagickFalse)\n    {\n      jpeg_info.arith_code=TRUE;\n      jpeg_info.optimize_coding=FALSE; // Not supported.\n    }\n#endif\n#if (JPEG_LIB_VERSION >= 61) && defined(C_PROGRESSIVE_SUPPORTED)\n  if ((LocaleCompare(image_info->magick,\"PJPEG\") == 0) ||\n      (image_info->interlace != NoInterlace))\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: progressive\");\n      jpeg_simple_progression(&jpeg_info);\n    }\n  else\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"Interlace: non-progressive\");\n#else\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Interlace: nonprogressive\");\n#endif\n  quality=92;\n  if ((image_info->compression != LosslessJPEGCompression) &&\n      (image->quality <= 100))\n    {\n      if (image->quality != UndefinedCompressionQuality)\n        quality=(int) image->quality;\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Quality: %.20g\",\n          (double) image->quality);\n    }\n  else\n    {\n#if !defined(C_LOSSLESS_SUPPORTED)\n      quality=100;\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Quality: 100\");\n#else\n      if (image->quality < 100)\n        (void) ThrowMagickException(exception,GetMagickModule(),CoderWarning,\n          \"LosslessToLossyJPEGConversion\",\"`%s'\",image->filename);\n      else\n        {\n          int\n            point_transform,\n            predictor;\n\n          predictor=image->quality/100;  /* range 1-7 */\n          point_transform=image->quality % 20;  /* range 0-15 */\n          jpeg_simple_lossless(&jpeg_info,predictor,point_transform);\n          if (image->debug != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Compression: lossless\");\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Predictor: %d\",predictor);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Point Transform: %d\",point_transform);\n            }\n        }\n#endif\n    }\n  option=GetImageOption(image_info,\"jpeg:extent\");\n  if (option != (const char *) NULL)\n    {\n      Image\n        *jpeg_image;\n\n      ImageInfo\n        *extent_info;\n\n      extent_info=CloneImageInfo(image_info);\n      extent_info->blob=NULL;\n      jpeg_image=CloneImage(image,0,0,MagickTrue,exception);\n      if (jpeg_image != (Image *) NULL)\n        {\n          MagickSizeType\n            extent;\n\n          size_t\n            maximum,\n            minimum;\n\n          /*\n            Search for compression quality that does not exceed image extent.\n          */\n          extent_info->quality=0;\n          extent=(MagickSizeType) SiPrefixToDoubleInterval(option,100.0);\n          (void) DeleteImageOption(extent_info,\"jpeg:extent\");\n          (void) DeleteImageArtifact(jpeg_image,\"jpeg:extent\");\n          maximum=image_info->quality;\n          if (maximum < 2)\n            maximum=101;\n          for (minimum=2; minimum < maximum; )\n          {\n            (void) AcquireUniqueFilename(jpeg_image->filename);\n            jpeg_image->quality=minimum+(maximum-minimum+1)/2;\n            status=WriteJPEGImage(extent_info,jpeg_image,exception);\n            if (GetBlobSize(jpeg_image) <= extent)\n              minimum=jpeg_image->quality+1;\n            else\n              maximum=jpeg_image->quality-1;\n            (void) RelinquishUniqueFileResource(jpeg_image->filename);\n          }\n          quality=(int) minimum-1;\n          jpeg_image=DestroyImage(jpeg_image);\n        }\n      extent_info=DestroyImageInfo(extent_info);\n    }\n  jpeg_set_quality(&jpeg_info,quality,TRUE);\n  if ((dct_method == (const char *) NULL) && (quality <= 90))\n    jpeg_info.dct_method=JDCT_IFAST;\n#if (JPEG_LIB_VERSION >= 70)\n  option=GetImageOption(image_info,\"quality\");\n  if (option != (const char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      int\n        flags;\n\n      /*\n        Set quality scaling for luminance and chrominance separately.\n      */\n      flags=ParseGeometry(option,&geometry_info);\n      if (((flags & RhoValue) != 0) && ((flags & SigmaValue) != 0))\n        {\n          jpeg_info.q_scale_factor[0]=jpeg_quality_scaling((int)\n            (geometry_info.rho+0.5));\n          jpeg_info.q_scale_factor[1]=jpeg_quality_scaling((int)\n            (geometry_info.sigma+0.5));\n          jpeg_default_qtables(&jpeg_info,TRUE);\n        }\n    }\n#endif\n  colorspace=jpeg_info.in_color_space;\n  value=GetImageOption(image_info,\"jpeg:colorspace\");\n  if (value == (char *) NULL)\n    value=GetImageProperty(image,\"jpeg:colorspace\",exception);\n  if (value != (char *) NULL)\n    colorspace=StringToInteger(value);\n  sampling_factor=(const char *) NULL;\n  if ((J_COLOR_SPACE) colorspace == jpeg_info.in_color_space)\n    {\n      value=GetImageOption(image_info,\"jpeg:sampling-factor\");\n      if (value == (char *) NULL)\n        value=GetImageProperty(image,\"jpeg:sampling-factor\",exception);\n      if (value != (char *) NULL)\n        {\n          sampling_factor=value;\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Input sampling-factors=%s\",sampling_factor);\n        }\n    }\n  value=GetImageOption(image_info,\"jpeg:sampling-factor\");\n  if (image_info->sampling_factor != (char *) NULL)\n    sampling_factor=image_info->sampling_factor;\n  if (sampling_factor == (const char *) NULL)\n    {\n      if (quality >= 90)\n        for (i=0; i < MAX_COMPONENTS; i++)\n        {\n          jpeg_info.comp_info[i].h_samp_factor=1;\n          jpeg_info.comp_info[i].v_samp_factor=1;\n        }\n    }\n  else\n    {\n      char\n        **factors;\n\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      /*\n        Set sampling factor.\n      */\n      i=0;\n      factors=SamplingFactorToList(sampling_factor);\n      if (factors != (char **) NULL)\n        {\n          for (i=0; i < MAX_COMPONENTS; i++)\n          {\n            if (factors[i] == (char *) NULL)\n              break;\n            flags=ParseGeometry(factors[i],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=geometry_info.rho;\n            jpeg_info.comp_info[i].h_samp_factor=(int) geometry_info.rho;\n            jpeg_info.comp_info[i].v_samp_factor=(int) geometry_info.sigma;\n            factors[i]=(char *) RelinquishMagickMemory(factors[i]);\n          }\n          factors=(char **) RelinquishMagickMemory(factors);\n        }\n      for ( ; i < MAX_COMPONENTS; i++)\n      {\n        jpeg_info.comp_info[i].h_samp_factor=1;\n        jpeg_info.comp_info[i].v_samp_factor=1;\n      }\n    }\n  option=GetImageOption(image_info,\"jpeg:q-table\");\n  if (option != (const char *) NULL)\n    {\n      QuantizationTable\n        *table;\n\n      /*\n        Custom quantization tables.\n      */\n      table=GetQuantizationTable(option,\"0\",exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=0; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=0;\n          jpeg_add_quant_table(&jpeg_info,0,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n      table=GetQuantizationTable(option,\"1\",exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=1; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=1;\n          jpeg_add_quant_table(&jpeg_info,1,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n      table=GetQuantizationTable(option,\"2\",exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=2; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=2;\n          jpeg_add_quant_table(&jpeg_info,2,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n      table=GetQuantizationTable(option,\"3\",exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=3; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=3;\n          jpeg_add_quant_table(&jpeg_info,3,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n    }\n  jpeg_start_compress(&jpeg_info,TRUE);\n  if (image->debug != MagickFalse)\n    {\n      if (image->storage_class == PseudoClass)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Storage class: PseudoClass\");\n      else\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Storage class: DirectClass\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Depth: %.20g\",\n        (double) image->depth);\n      if (image->colors != 0)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Number of colors: %.20g\",(double) image->colors);\n      else\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Number of colors: unspecified\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"JPEG data precision: %d\",(int) jpeg_info.data_precision);\n      switch (image->colorspace)\n      {\n        case CMYKColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Storage class: DirectClass\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: CMYK\");\n          break;\n        }\n        case YCbCrColorspace:\n        case Rec601YCbCrColorspace:\n        case Rec709YCbCrColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: YCbCr\");\n          break;\n        }\n        default:\n          break;\n      }\n      switch (image->colorspace)\n      {\n        case CMYKColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: CMYK\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor,\n            jpeg_info.comp_info[3].h_samp_factor,\n            jpeg_info.comp_info[3].v_samp_factor);\n          break;\n        }\n        case GRAYColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: GRAY\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d\",jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor);\n          break;\n        }\n        case sRGBColorspace:\n        case RGBColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Image colorspace is RGB\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor);\n          break;\n        }\n        case YCbCrColorspace:\n        case Rec601YCbCrColorspace:\n        case Rec709YCbCrColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: YCbCr\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor);\n          break;\n        }\n        default:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: %d\",\n            image->colorspace);\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor,\n            jpeg_info.comp_info[3].h_samp_factor,\n            jpeg_info.comp_info[3].v_samp_factor);\n          break;\n        }\n      }\n    }\n  /*\n    Write JPEG profiles.\n  */\n  value=GetImageProperty(image,\"comment\",exception);\n  if (value != (char *) NULL)\n    for (i=0; i < (ssize_t) strlen(value); i+=65533L)\n      jpeg_write_marker(&jpeg_info,JPEG_COM,(unsigned char *) value+i,\n        (unsigned int) MagickMin((size_t) strlen(value+i),65533L));\n  if (image->profiles != (void *) NULL)\n    WriteProfile(&jpeg_info,image,exception);\n  /*\n    Convert MIFF to JPEG raster pixels.\n  */\n  memory_info=AcquireVirtualMemory((size_t) image->columns,\n    jpeg_info.input_components*sizeof(*jpeg_pixels));\n  if (memory_info == (MemoryInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      jpeg_destroy_compress(&jpeg_info);\n      if (memory_info != (MemoryInfo *) NULL)\n        memory_info=RelinquishVirtualMemory(memory_info);\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  scanline[0]=(JSAMPROW) jpeg_pixels;\n  scale=65535/(unsigned short) GetQuantumRange((size_t)\n    jpeg_info.data_precision);\n  if (scale == 0)\n    scale=1;\n  if (jpeg_info.data_precision <= 8)\n    {\n      if ((jpeg_info.in_color_space == JCS_RGB) ||\n          (jpeg_info.in_color_space == JCS_YCbCr))\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=jpeg_pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(JSAMPLE) ScaleQuantumToChar(GetPixelRed(image,p));\n            *q++=(JSAMPLE) ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=(JSAMPLE) ScaleQuantumToChar(GetPixelBlue(image,p));\n            p+=GetPixelChannels(image);\n          }\n          (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n      else\n        if (jpeg_info.in_color_space == JCS_GRAYSCALE)\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            register const Quantum\n              *p;\n\n            register ssize_t\n              x;\n\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            q=jpeg_pixels;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              *q++=(JSAMPLE) ScaleQuantumToChar(ClampToQuantum(GetPixelLuma(\n                image,p)));\n              p+=GetPixelChannels(image);\n            }\n            (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n            status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n            }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            register const Quantum\n              *p;\n\n            register ssize_t\n              x;\n\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            q=jpeg_pixels;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              /*\n                Convert DirectClass packets to contiguous CMYK scanlines.\n              */\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelCyan(image,p))));\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelMagenta(image,p))));\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelYellow(image,p))));\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelBlack(image,p))));\n              p+=GetPixelChannels(image);\n            }\n            (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n            status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n    }\n  else\n    if (jpeg_info.in_color_space == JCS_GRAYSCALE)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        register const Quantum\n          *p;\n\n        register ssize_t\n          x;\n\n        p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n        if (p == (const Quantum *) NULL)\n          break;\n        q=jpeg_pixels;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          *q++=(JSAMPLE) (ScaleQuantumToShort(ClampToQuantum(GetPixelLuma(image,\n            p)))/scale);\n          p+=GetPixelChannels(image);\n        }\n        (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n        status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n    else\n      if ((jpeg_info.in_color_space == JCS_RGB) ||\n          (jpeg_info.in_color_space == JCS_YCbCr))\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=jpeg_pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(JSAMPLE) (ScaleQuantumToShort(GetPixelRed(image,p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(GetPixelGreen(image,p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(GetPixelBlue(image,p))/scale);\n            p+=GetPixelChannels(image);\n          }\n          (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n      else\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=jpeg_pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            /*\n              Convert DirectClass packets to contiguous CMYK scanlines.\n            */\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-GetPixelRed(\n              image,p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-GetPixelGreen(\n              image,p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-GetPixelBlue(\n              image,p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-GetPixelBlack(\n              image,p))/scale);\n            p+=GetPixelChannels(image);\n          }\n          (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n  if (y == (ssize_t) image->rows)\n    jpeg_finish_compress(&jpeg_info);\n  /*\n    Relinquish resources.\n  */\n  jpeg_destroy_compress(&jpeg_info);\n  memory_info=RelinquishVirtualMemory(memory_info);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n#endif\n"], "fixing_code": ["2019-07-18  7.0.8-55 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-55, GIT revision 15...\n\n2019-07-18  7.0.8-55 Cristy  <quetzlzacatenango@image...>\n  * Heap-buffer overflow (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1641\n\n2019-07-16  7.0.8-54 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-54, GIT revision 15916:e868e22:20190716.\n\n2019-07-08  7.0.8-54 Cristy  <quetzlzacatenango@image...>\n  * resolve division by zero  (reference\n     https://github.com/ImageMagick/ImageMagick/issues/1629).\n  * introducing MagickLevelImageColors() MagickWand method.\n  * Transient problem with text placement with gravity (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1633).\n  * Support TIM2 image format (reference\n    https://github.com/ImageMagick/ImageMagick/pull/1571).\n  * For -magnify option, specify an alternative scaling method with -define\n    magnify:method=method, choose from these methods: eagle2X, eagle3X,\n    eagle3XB, epb2X, fish2X, hq2X,  scale2X (default), scale3X, xbr2X.\n\n2019-07-05  7.0.8-53 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-53, GIT revision 15828:f5d59c0:20190705.\n\n2019-07-05  7.0.8-53 Cristy  <quetzlzacatenango@image...>\n   * Fix -fx parsing issue (reference\n     https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=36314).\n\n2019-07-05  7.0.8-52 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-52, GIT revision 15825:ea47310:20190705.\n\n2019-07-01  7.0.8-52 Cristy  <quetzlzacatenango@image...>\n  * Eliminate buffer overflow in TranslateEvent() (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1621).\n\n2019-06-30  7.0.8-51 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-51, GIT revision 15812:51f11c4:20190630.\n\n2019-06-24  7.0.8-51 Cristy  <quetzlzacatenango@image...>\n  * Clone rather than copy X window name/icon.\n  * Optimize PDF reader.\n\n2019-06-23  7.0.8-50 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-50, GIT revision 15778:4a60519:20190623\n\n2019-06-14  7.0.8-50 Dirk Lemstra <dirk@lem.....org>\n  * Added support for reading all images from a HEIC image (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1391).\n  * Heap-buffer-overflow in MagickCore/fourier.c (reference\n   https://github.com/ImageMagick/ImageMagick/issues/1588).\n  * Fixed a number of issues (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-06-08  7.0.8-49 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-49, GIT revision 15708:6d7e1db:20190608\n\n2019-06-03  7.0.8-49 Cristy  <quetzlzacatenango@image...>\n  * Add support for RGB565 image format (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=2&t=36078).\n  * Use user defined allocator instead of `malloc` (reference\n    https://github.com/ImageMagick/ImageMagick6/pull/49/).\n  * Add static decorator to accelerator kernels (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1366).\n\n2019-06-01  7.0.8-48 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-48, GIT revision 15689:061a3bb82:20190601\n\n2019-06-01  7.0.8-48 Cristy  <quetzlzacatenango@image...>\n  * Fix transient convolution bug (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=36119).\n\n2019-05-26  7.0.8-47 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-47, GIT revision 15681:5cffc6cbb:20190526\n\n2019-05-19  7.0.8-47 Cristy  <quetzlzacatenango@image...>\n  * Support 16 and 32 bit tiled float TIFF images.\n  * Convolve morphology alpha channel fix (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=36086).\n  * Text improvements to the internal SVG renderer.\n\n2019-05-14  7.0.8-46 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-46, GIT revision 15655:84dd3301c:20190518\n\n2019-05-14  7.0.8-46 Cristy  <quetzlzacatenango@image...>\n  * PerlMagick unit tests pass again.\n  * Builds under MacOS X and FreeBSD works again.\n  * Return HEIC images in the sRGB colorspace.\n\n2019-05-12  7.0.8-45 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-45, GIT revision 15634:784105bcb:20190512\n\n2019-05-06  7.0.8-45 Cristy  <quetzlzacatenango@image...>\n  * Fix image signatures to ensure they are Q-depth invariant (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=35970).\n  * Fixed a number of issues (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-05-03  7.0.8-44 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-44, GIT revision 15600:41f47759a:20190503\n\n2019-05-03  7.0.8-44 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-05-01  7.0.8-43 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-43, GIT revision 15595:0062cef74:20190502\n\n2019-05-01  7.0.8-43 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-04-29  7.0.8-42 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-42, GIT revision 15570:71190ccd0:20190424\n\n2019-04-20  7.0.8-42 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-04-19  7.0.8-41 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-41, GIT revision 15540:c78993d13:20190420\n\n2019-04-13  7.0.8-41 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * Honor SOURCE_DATE_EPOCH environment variable (reference\n    https://github.com/ImageMagick/ImageMagick/pull/1496/).\n  * Standardize on UTC time for any image format timestamp.\n  * Add MagickAutoThresholdImage(), MagickCannyEdgeImage(),\n    MagickComplexImages(), MagickConnectedComponentsImage(),\n    MagickHoughLineImage(), MagickKuwaharaImage(), MagickLevelizeImageColors(),\n    MagickLevelImageColors(), MagickMeanShiftImage(), MagickPolynomialImage(),\n    MagickRangeThresholdImage(), MagickSetSeed(), MagickWaveletDenoiseImage()\n    methods to MagickWand API.\n\n2019-04-12  7.0.8-40 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-40, GIT revision 15510:7e503e231:20190412\n\n2019-04-10  7.0.8-40 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n\n2019-04-07  7.0.8-39 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-39, GIT revision 15489:6120f8bc1:20190406\n\n2019-04-06  7.0.8-39 Cristy  <quetzlzacatenango@image...>\n  * The -layers option compared pixels inocorrectly as opacity rather than\n    alpha.\n  * The -preview raise option now returns expected results.\n  * Initialise ghostscript instances with NULL (reference\n    https://github.com/ImageMagick/ImageMagick/pull/1538).\n\n2019-04-06  7.0.8-38 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-38, GIT revision 15483:23edcef04:20190406\n\n2019-04-06  7.0.8-38 Cristy  <quetzlzacatenango@image...>\n  * Modulo off by one patch for -virtual-pixel option (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=35789).\n\n2019-04-03  7.0.8-37 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-37, GIT revision 15470:477216fd7:20190403\n\n2019-04-03  7.0.8-37 Cristy  <quetzlzacatenango@image...>\n  * Fixed -virtual-pixel option (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=35789).\n\n2019-03-31  7.0.8-36 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-36, GIT revision 15464:3a928224d:20190331\n\n2019-03-27  7.0.8-36 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-03-24  7.0.8-35 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-35, GIT revision 15440:4a0a88e41:20190324\n\n2019-03-23  7.0.8-35 Cristy  <quetzlzacatenango@image...>\n  * -draw image DstOver is now responsive to the composite operator (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=35650).\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-03-15  7.0.8-34 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-34, GIT revision 15413:860af935d:20190315\n\n2019-03-11  7.0.8-34 Cristy  <quetzlzacatenango@image...>\n  * Associate one lock with each resource.\n  * Report exception if opening TIFF did not work out.\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2019-03-10  7.0.8-33 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-33, GIT revision 15401:c805e3205:20190310\n\n2019-03-06  7.0.8-33 Cristy  <quetzlzacatenango@image...>\n  * Fix SVG conversion infinite loop (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=35591).\n  * Initialize primitive drawing structure after resizing.\n\n2019-03-05  7.0.8-32 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-32, GIT revision 15386:58d9c4692:20190305\n\n2019-03-05  7.0.8-32 Cristy  <quetzlzacatenango@image...>\n  * Fix out-of-boundary LocaleLowerCase() @\n    https://github.com/ImageMagick/ImageMagick/issues/1495\n\n2019-03-04  7.0.8-31 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-31, GIT revision 15381:3122a669d:20190304\n\n2019-03-04  7.0.8-31 Cristy  <quetzlzacatenango@image...>\n  * -trim is no longer sensitive to the image virtual canvas.\n\n2019-03-03  7.0.8-30 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-30, GIT revision 15376:16d2b4e6a:20190303\n\n2019-03-03  7.0.8-30 Cristy  <quetzlzacatenango@image...>\n  * Support define to remove additional background from an image during a\n    trim, e.g. -fuzz 5% -define trim:percent-background=0% -trim.\n\n2019-02-28  7.0.8-29 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-29, GIT revision 15368:5d8ed9f56:20190228\n\n2019-02-28  7.0.8-29 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2019-02-18  7.0.8-28 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-28, GIT revision 15345:09a7c67dd:20190218\n\n2019-02-12  7.0.8-28 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-02-09  7.0.8-27 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-27, GIT revision 15315:5d48cd312:20190209\n\n2019-02-09  7.0.8-27 Cristy  <quetzlzacatenango@image...>\n  * Mod patch to properly handle subimage ranges (e.g. image.gif[2-3]).\n\n2019-02-03  7.0.8-26 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-26, GIT revision 15294:726bd82a3:20190203\n\n2019-02-02  7.0.8-26 Cristy  <quetzlzacatenango@image...>\n  * Fixed a number of issues (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2019-01-27  7.0.8-25 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-25, GIT revision 15279:7da783a5b:20190127\n\n2019-01-19  7.0.8-25 Cristy  <quetzlzacatenango@image...>\n  * Eliminate spurious font warning (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1458).\n  * Support HEIC EXIF & XMP profiles.\n\n2019-01-12  7.0.8-24 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-24, GIT revision 15233:db129ba64:20190112\n\n2019-01-08  7.0.8-24 Cristy  <quetzlzacatenango@image...>\n  * Support -clahe option real clip limit (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=2&t=35292).\n  * ShadeImage() kernels can return negative pixels, clamp to range (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1319).\n  * Annotate with negative offsets no longer renders slanted text.\n\n2019-01-01  7.0.8-23 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-23, GIT revision 15199:ba07f7d07:20190101\n\n2019-01-01  7.0.8-23 Cristy  <quetzlzacatenango@image...>\n  * CacheInfo destructor must be aligned in DestroyPixelStream().\n\n2018-12-30  7.0.8-22 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-22, GIT revision 15189:842164090:20181230\n\n2018-12-29  7.0.8-22 Cristy  <quetzlzacatenango@image...>\n  * Support negative rotations in a geometry (e.g. -10x-10+10+10).\n  * Return expected canvas offset after a crop with gravity.\n\n2018-12-27  7.0.8-21 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-21, GIT revision 15179:114be1716:20181227\n\n2018-12-27  7.0.8-21 Cristy  <quetzlzacatenango@image...>\n  * Check to ensure SeekBlob() offset can be represented in an off_t.\n\n2018-12-23  7.0.8-20 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-20, GIT revision 15170:8e8222e87:20181223\n\n2018-12-23  7.0.8-20 Cristy  <quetzlzacatenango@image...>\n  * Cube image format returns a HALD image.\n  * CLAHE tiles overlapped are now centered relative to the image.\n\n2018-12-19  7.0.8-19 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-19, GIT revision 15153:e74ed77f5:20181219\n\n2018-12-18  7.0.8-18 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-18, GIT revision 15146:b5eccd295:20181218\n\n2018-12-18  7.0.8-18 Cristy  <quetzlzacatenango@image...>\n  * Fixed Magick++ compile error on Mac OS X.\n\n2018-12-17  7.0.8-17 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-17, GIT revision 15142:32f2d195e:20181217\n\n2018-12-02  7.0.8-16 Cristy  <quetzlzacatenango@image...>\n  * Support -clahe clip limit with percentages (e.g. -clahe 50x50%+128+3).\n\n2018-12-10  7.0.8-16 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-16, GIT revision 15109:9a9af88de:20181210.\n\n2018-12-02  7.0.8-16 Cristy  <quetzlzacatenango@image...>\n  * Check for modulo underflow.\n  * Change SVG default DPI to 96 from 90 to meet recommendation of SVG2 & CSS.\n\n2018-12-01  7.0.8-15 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-15, GIT revision 15059:2fb22e07b:20181201\n\n2018-11-21  7.0.8-15 Cristy  <quetzlzacatenango@image...>\n  * Added support for the -clahe option: contrast limited adaptive histogram\n    equalization.\n\n2018-11-13  7.0.8-15 Dirk Lemstra <dirk@lem.....org>\n  * Added support for GIMP 2.10 files (reference\n    https://github.com/ImageMagick/ImageMagick/pull/1381).\n\n2018-10-23  7.0.8-14 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-14, GIT revision 14943:1a0da3dd0:20181023\n\n2018-10-21  7.0.8-13 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-13, GIT revision 14936:d3ec5abe2:20181021.\n\n2018-10-04  7.0.8-13 Dirk Lemstra <dirk@lem.....org>\n  * Adding coder headers with magic.xml will no longer be supported.\n  * Adding coder aliases with coder.xml will no longer be supported.\n\n2018-09-16  7.0.8-12 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-12, GIT revision 14843:cb5cf1959:20180923\n\n2018-09-15  7.0.8-12 Dirk Lemstra <dirk@lem.....org>\n  * Added support for arithmetic coding to the jpeg encoder:\n    -define jpeg:arithmetic-coding=true.\n\n2018-09-08  7.0.8-12 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-08-28  7.0.8-11 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-11, GIT revision 14729:798fbdb5b:20180828\n\n2018-08-15  7.0.8-11 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n  * Add support for \"module\" security policy.\n\n2018-08-13  7.0.8-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-10, GIT revision 14646:48fba3256:20180813\n\n2018-08-12  7.0.8-10 Dirk Lemstra <dirk@lem.....org>\n  * Added dcraw coder (dcraw:img.cr2) that can be used to force the use of the\n    dcraw delegate when libraw is the default raw delegate.\n  * Restored thread support for the HEIC coder.\n\n2018-08-08  7.0.8-10 Cristy  <quetzlzacatenango@image...>\n  * ThumbnailImage function no longer reveals sensitive information (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1243).\n\n2018-08-06  7.0.8-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-9, GIT revision 14618:a3663c3dc:20180805.\n\n2018-07-24  7.0.8-9 Cristy  <quetzlzacatenango@image...>\n  * XBM coder leaves the hex image data uninitialized if hex value of the\n    pixel is negative.\n  * More improvements to SVG text handling.\n  * New -range-threshold option that combines hard and soft thresholding.\n\n2018-07-23  7.0.8-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-8, GIT revision 14583:300fdbcfd:20180723.\n\n2018-07-20  7.0.8-8 Cristy  <quetzlzacatenango@image...>\n  * Non-HDRI ScaleLongToQuantum() private method no longer adds a half interval.\n  * Fixed memset() negative-size-param (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1217).\n\n2018-07-16  7.0.8-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-7, GIT revision 14561:f85c23180:20180716.\n\n2018-07-15  7.0.8-7 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-07-08  7.0.8-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-6, GIT revision 14541:db940ccd2:20180708.\n\n2018-07-06  7.0.8-6 Cristy  <quetzlzacatenango@image...>\n  * Improve SVG support for tspan element.\n  * Add support for -fx image.extent.\n\n2018-07-04  7.0.8-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-5, GIT revision 14514:bba545bbb:20180704.\n\n2018-07-04  7.0.8-5 Cristy  <quetzlzacatenango@image...>\n  * Fixed a few potential memory leaks\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2018-07-02  7.0.8-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-4, GIT revision 14505:4613eed4a:20180702.\n\n2018-06-28  7.0.8-4 Cristy  <quetzlzacatenango@image...>\n  * Small tweaks to compile under Cygwin.\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n  * Support %B property, the image file size without any decorations.\n\n2018-06-24  7.0.8-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-3, GIT revision 14489:c63c504e8:20180624.\n\n2018-06-24  7.0.8-3 Cristy  <quetzlzacatenango@image...>\n  * Apply translate component of SVG transform rotate.\n\n2018-06-18  7.0.8-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-2, GIT revision 14476:cda11d81d:20180618.\n\n2018-06-18  7.0.8-2 Cristy  <quetzlzacatenango@image...>\n  * More robust SVG text handling.\n\n2018-06-16  7.0.8-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-1, GIT revision 14468:94cb08785:20180616.\n\n2018-06-16  7.0.8-1 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n  * Fixed an issue with stroke and label: (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=34142).\n  * PNG: set storage class to DirectClass if alpha enabled (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=34121).\n\n2018-06-12  7.0.8-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.8-0, GIT revision 14459:d7c892d5a:20180612.\n\n2018-06-11  7.0.8-0  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-06-11  7.0.7-39 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-39, GIT revision 14445:cc962acde:20180611.\n\n2018-06-06  7.0.7-39  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-06-02  7.0.7-38 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-38, GIT revision 14409:01e395a73:20180602.\n\n2018-05-30  7.0.7-38  <quetzlzacatenango@image...>\n  * Heap buffer overflow fix (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1156).\n  * Boundary issues with -gamma option when HDRI is enabled (reference\n    https://github.com/ImageMagick/ImageMagick/issues/1151).\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-05-29  7.0.7-37 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-37, GIT revision 14393:61d7e8b17:20180529.\n\n2018-05-29  7.0.7-37  <quetzlzacatenango@image...>\n  * Properly initialize SVG color style.\n\n2018-05-28  7.0.7-36 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-36, GIT revision 14390:3a6bd703f:20180528.\n\n2018-05-28  7.0.7-36  <quetzlzacatenango@image...>\n  * A SVG rectangle with a width and height of 1 is a point.\n\n2018-05-21  7.0.7-35 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-35, GIT revision 14356:13507412c:20180521.\n\n2018-05-21  7.0.7-35  <quetzlzacatenango@image...>\n  * Fixed memory corruption for MVG paths.\n\n2018-05-20  7.0.7-34 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-34, GIT revision 14348:ac9ff6ba1:20180520.\n\n2018-05-20  7.0.7-34 Dirk Lemstra <dirk@lem.....org>\n  * Added support for reading eXIf chunks to the PNG coder.\n\n2018-05-19  7.0.7-34  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n  * Improved clip / composite mask handling.\n\n2018-05-16  7.0.7-33 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-33, GIT revision 14326:58c2e4972:20180516.\n\n2018-05-03  7.0.7-33  <quetzlzacatenango@image...>\n  * Restore SetImageAlpha() behavior.\n  * Fix -clip and -mask options.\n\n2018-05-13  7.0.7-32 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-32, GIT revision 14307:f61f674e3:20180513.\n\n2018-05-03  7.0.7-31  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-05-01  7.0.7-30 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-30, GIT revision 14242:730f1d1d3:20180501.\n\n2018-05-01  7.0.7-30  <quetzlzacatenango@image...>\n  * Missing break when checking \"compliance\" element.\n\n2018-04-30  7.0.7-29 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-29, GIT revision 14225:41edbdcea:20180430.\n\n2018-03-26  7.0.7-29  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-03-24  7.0.7-28 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-28, GIT revision 23615:edd71782e:20180325.\n\n2018-03-21  7.0.7-28  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-03-18  7.0.7-27 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-27, GIT revision 23466:734b146df:20180318.\n\n2018-03-17  7.0.7-27  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-03-11  7.0.7-26 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-26, GIT revision 23344:7a03766ef:20180311.\n\n2018-03-10  7.0.7-26  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-03-04  7.0.7-25 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-25, GIT revision 23177:17a986472:20180304.\n\n2018-03-04  7.0.7-25 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow, memory\n    exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-02-25  7.0.7-24 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-24, GIT revision 23079:7ccb76178:20180225.\n\n2018-02-19  7.0.7-24 Cristy  <quetzlzacatenango@image...>\n  * Do not refer to page in OptimizeLayerFrames (reference\n    https://github.com/ImageMagick/ImageMagick/pull/987).\n  * PerlMagick unit tests pass again.\n  * Fixed numerous use of uninitialized values, integer overflow,\n    memory exceeded, and timeouts (credit to OSS Fuzz).\n\n2018-02-18  7.0.7-23 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.0-23, GIT revision 22969:c6b3a22b0:20180218.\n\n2018-02-09  7.0.7-23 Dirk Lemstra <dirk@lem.....org>\n  * Add support for reading the HEIC image format to the Windows build.\n\n2018-01-23  7.0.7-23 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous use of uninitialized values, integer overflow,\n    memory exceeded, and timeouts (credit to OSS Fuzz).\n  * Add list-length policy to limit the maximum image sequence length.\n\n2018-01-22  7.0.7-22 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.0-22, GIT revision 22391:e8be814f1:20180122.\n\n2018-01-06  7.0.7-22 Cristy  <quetzlzacatenango@image...>\n  * Support aspect ratio geometry, e.g. -crop 3:2.\n  * Add support for reading the HEIC image format (reference\n    https://github.com/ImageMagick/ImageMagick/issues/507).\n  * Fixed numerous memory leaks, credit to OSS Fuzz.\n\n2018-01-06  7.0.7-21 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.0-21, GIT revision 22168:a91afc45b:20180106.\n\n2018-01-06  7.0.7-21 Dirk Lemstra <dirk@lem.....org>\n  * Fix some enum values in the OpenCL code.\n\n2018-01-06  7.0.7-20 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-20, GIT revision 22161:33a04d3e5:20180105.\n\n2018-01-05  7.0.7-20 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2018-01-01  7.0.7-19 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-19, GIT revision 22133:977fe08bf:20180101.\n\n2017-12-29  7.0.7-19 Cristy  <quetzlzacatenango@image...>\n  * Check for webpmux library version 0.4.4 (reference\n    https://github.com/ImageMagick/ImageMagick/issues/896).\n\n2017-12-26  7.0.7-18 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-18, GIT revision 22096:ad4bdeb40:20171228.\n\n2017-12-28  7.0.7-18 Cristy  <quetzlzacatenango@image...>\n  * Fix error reading from pipe under Windows (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=33288).\n\n2017-12-26  7.0.7-17 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-17, GIT revision 22093:9caea323b:20171227.\n\n2017-12-26  7.0.7-17 Cristy  <quetzlzacatenango@image...>\n  * Fix heap use after free error (reference\n    https://github.com/ImageMagick/ImageMagick/issues/918).\n\n2017-12-24  7.0.7-16 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-16, GIT revision 22038:e55dc7626:20171225.\n\n2017-12-18  7.0.7-16 Cristy  <quetzlzacatenango@image...>\n  * Fix error reading multi-layer XCF image file.\n  * Fix possible stack overflow in WEBP reader (reference\n    https://github.com/ImageMagick/ImageMagick/issues/907)\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2017-12-16  7.0.7-15 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-15, GIT revision 21924:30cb31746:20171216.\n\n2017-12-08  7.0.7-15 Cristy  <quetzlzacatenango@image...>\n  * Overall standard deviation is the average of each pixel channel (reference\n    https://imagemagick.org/discourse-server/viewforum.php?f=3).\n  * Update to the latest ImageMagick documentation.\n\n2017-12-05  7.0.7-14 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-14, GIT revision 21855:dc73b2aba:20171205.\n\n2017-11-30  7.0.7-14 Cristy  <quetzlzacatenango@image...>\n  * Support Stereo composite operator.\n  * Fix build failure with --without-modules (reference\n    https://github.com/ImageMagick/ImageMagick/issues/890).\n\n2017-11-30  7.0.7-13 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-13, GIT revision 21823:72cb0fd0c:20171130.\n\n2017-11-30  7.0.7-13 Cristy  <quetzlzacatenango@image...>\n  * Fix build failure with libraw 0.14.8 (reference\n    https://github.com/ImageMagick/ImageMagick/issues/888).\n\n2017-11-29  7.0.7-12 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-12, GIT revision 21814:5ef2c5a67:20171129.\n\n2017-11-12  7.0.7-12 Cristy  <quetzlzacatenango@image...>\n  * The -tint option no longer munges the alpha channel (reference\n    http://imagemagick.org/discourse-server/viewtopic.php?f=1&t=33070).\n  * Don't delete in-memory blob when reading an image (reference\n    https://github.com/ImageMagick/ImageMagick/issues/886).\n  * Support HDRI color profile management.\n\n2017-11-11  7.0.7-11 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-11, GIT revision 21635:0447c6b46:20171111.\n\n2017-11-05  7.0.7-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-10, GIT revision 21612:36e2aabfd:20171105.\n\n2017-11-03  7.0.7-10 Dirk Lemstra <dirk@lem.....org>\n  * Fixed a problem with resource bookkeeping in AcquireMatrixInfo().\n\n2017-10-30  7.0.7-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-9, GIT revision 21580:2682a311e:20171031.\n\n2017-10-20  7.0.7-9 Cristy  <quetzlzacatenango@image...>\n  * Encode JSON control characters (reference\n    https://github.com/ImageMagick/ImageMagick/issues/848).\n\n2017-10-27  7.0.7-9 Dirk Lemstra <dirk@lem.....org>\n  * Added support for reading mipmaps in dds images (reference\n    https://github.com/ImageMagick/ImageMagick/issues/845).\n\n2017-10-15  7.0.7-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-8, GIT revision 21507:63ffc9878:20171015.\n\n2017-10-08  7.0.7-8 Cristy  <quetzlzacatenango@image...>\n  * Return expected results for a percent 0 -chop option argument (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32806).\n  * Tweaks to OpenMP support within ImageMagick.\n\n2017-10-07  7.0.7-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-7, GIT revision 21432:29003eeed:20171007.\n\n2017-10-06  7.0.7-7 Cristy  <quetzlzacatenango@image...>\n  * Correct handling of GIF transparency (reference\n    https://github.com/ImageMagick/ImageMagick/issues/831).\n\n2017-10-04  7.0.7-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-6, GIT revision 21426:0a1cb507b:20171004.\n\n2017-10-03  7.0.7-6 Cristy  <quetzlzacatenango@image...>\n  * Reset the magick_list_initialized boolean when needed (reference\n    https://github.com/ImageMagick/ImageMagick/pull/826).\n\n2017-10-01  7.0.7-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-5, GIT revision 21382:3846f9d97:20171001.\n\n2017-09-28  7.0.7-5 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * Support URW-base35 fonts.\n\n2017-09-26  7.0.7-5 Glenn Randers-Pehrson <glennrp@image...>\n  * Removed \"ping_preserve_iCCP=MagickTrue;\" statement that was inadvertently\n    added to coders/png.c (reference\n    http://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32771).\n\n2017-09-23  7.0.7-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-4, GIT revision 21265:bdbc14590:20170923.\n\n2017-09-23  7.0.7-4 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/pull/763).\n\n2017-09-17  7.0.7-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-3, GIT revision 21202:6e6907ac7:20170917.\n\n2017-09-17  7.0.7-3 ADLab of Venustech\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/pull/763).\n\n2017-09-15  7.0.7-3 Glenn Randers-Pehrson <glennrp@image...>\n  * Stop potential leaks in the JNG decoder (reference:\n    https://github.com/ImageMagick/ImageMagick/issues/760).\n  * Maximum valid hour is 23, not 24, in the PNG tIME chunk, and maximum\n    valid minute is 59, not 60.\n\n2017-09-12  7.0.7-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-2, GIT revision 21089:4e46ad9dd:20170912.\n\n2017-09-11  7.0.7-2 Glenn Randers-Pehrson <glennrp@image...>\n  * Use signed integer arithmetic to calculate timezone corrections (reference\n    https://github.com/ImageMagick/ImageMagick/issues/685).\n\n2017-09-09  7.0.7-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-1, GIT revision 21065:ab2194121:20170909.\n\n2017-09-09  7.0.7-1 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2017-09-05 7.0.7-1 Dirk Lemstra <dirk@lem.....org>\n  * Added -define tiff:write-layers=true to add support for writing layered\n    tiff files.\n\n2017-09-03  7.0.7-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.7-0, GIT revision 20996:2f8ac2203:20170903.\n\n2017-08-28  7.0.7-0 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * Don't overwrite symbolic links when the shred policy is enabled.\n\n2017-08-27  7.0.6-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-10, GIT revision 20920:9940c367a:20170827.\n\n2017-08-27  7.0.6-10 Cristy  <quetzlzacatenango@image...>\n  * Support -metric ssim, structual similarity index.\n\n2017-08-26  7.0.6-10 Dirk Lemstra <dirk@lem.....org>\n  * Fixed thread safety issue inside the pango and librsvg decoder\n    (reference: https://github.com/dlemstra/Magick.NET/issues/91).\n\n2017-08-20  7.0.6-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-9, GIT revision 20860:3f307d8ad:20170820.\n\n2017-08-18  7.0.6-9 Glenn Randers-Pehrson <glennrp@image...>\n  * Fixed bug with writing tIME chunk when timezone has a negative offset\n    (reference: https://github.com/ImageMagick/ImageMagick/issues/685)\n\n2017-08-18  7.0.6-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-8, GIT revision 20838:e2eb79427:20170818.\n\n2017-08-14  7.0.6-7 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * Support CubicSpline resize filter.  Define the lobes with the\n    -define filter:lobes={2,3,4} (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=2&t=32506).\n  * Prevent assertion failure when creating PDF thumbnail (reference\n    https://github.com/ImageMagick/ImageMagick/issues/674).\n\n2017-08-12  7.0.6-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-7, GIT revision 20799:0db4d8a16:20170812.\n\n2017-08-12  7.0.6-7 Cristy  <quetzlzacatenango@image...>\n  * Improve EPS aliasing (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32497).\n\n2017-08-11  7.0.6-7 Dirk Lemstra <dirk@lem.....org>\n  * Added a new option called 'dds:fast-mipmaps' (reference\n    https://github.com/ImageMagick/ImageMagick/issues/558)\n  * The mipmaps of a dds image can now be created from a list of images with\n    -define dds:mipmaps=fromlist (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=2&t=30236).\n\n2017-08-10  7.0.6-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-6, GIT revision 20775:061d0fa25:20170810.\n\n2017-08-10  7.0.6-6 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2017-08-10  7.0.6-6 Glenn Randers-Pehrson <glennrp@image...>\n  * tests/validate.c: Show the reason for failures in the test logs,\n    if available.\n\n2017-08-03  7.0.6-6 Glenn Randers-Pehrson <glennrp@image...>\n  * Put UTC time in the PNG tIME chunk instead of local time (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32447).\n\n2017-08-02  7.0.6-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-5, GIT revision 20715:26b28d50a:20170802.\n\n2017-08-01  7.0.6-5 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2017-07-29  7.0.6-5 Glenn Randers-Pehrson <glennrp@image...>\n  * Properly set image->colorspace in the PNG decoder (previously\n    it was setting image->gamma, but only setting image->colorspace\n    for grayscale and gray-alpha images.  Reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32418).\n  * Fix improper use of NULL in the JNG decoder (CVE-2017-11750, Reference\n    https://github.com/ImageMagick/ImageMagick/issues/632).\n  * Added \"-define png:ignore-crc\" option to PNG decoder. When you know\n    your image has no CRC or ADLER32 errors, this can speed up decoding.\n    It is also helpful in debugging bug reports from \"fuzzers\".\n\n2017-07-29  7.0.6-5 Cristy  <quetzlzacatenango@image...>\n  * Off by one error for gradient coder (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32416),\n    https://github.com/ImageMagick/ImageMagick/issues/612).\n\n2017-07-28  7.0.6-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-4, GIT revision 20657:4e81160d6:20170728.\n\n2017-07-24  7.0.6-4 Cristy  <quetzlzacatenango@image...>\n  * YUV coder no longer renders streaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues/612).\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues) including\n    https://github.com/ImageMagick/ImageMagick/issues/618 (CVE-2017-12676).\n  * coders/png.c: Initialized quantum_scanline and quantum_info\n    to prevent a bad free (reference\n    https://github.com/ImageMagick/ImageMagick/issues/621).\n\n2017-07-25  7.0.6-4 Glenn Randers-Pehrson <glennrp@image...>\n  * Removed write_chunk_from_profile() from coders/png.c because it has\n    not worked at least since version 6.7.6.\n  * Removed many redundant checks before RelinquishMagickMemory(), which\n    is safe to call with a NULL argument.\n  * Added experimental PNG orNT chunk, to store image->orientation.\n  * Removed vpAg chunk write support (we are now writing caNv instead).\n\n2017-07-24  7.0.6-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-3, GIT revision 20598:cc9c43b44:20170724.\n\n2017-07-23  7.0.6-3 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n\n2017-07-23  7.0.6-3 Glenn Randers-Pehrson <glennrp@image...>\n  * Fix memory leaks when reading a malformed JNG image:\n    https://github.com/ImageMagick/ImageMagick/issues/600 (CVE-2017-13141),\n    https://github.com/ImageMagick/ImageMagick/issues/602 (CVE-2017-12565).\n\n2017-07-21  7.0.6-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-2, GIT revision 20549:62fcf3d96:20170721.\n\n2017-07-19  7.0.6-2 Cristy  <quetzlzacatenango@image...>\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * The -monochrome option no longer returns a blank canvas (reference\n    https://github.com/ImageMagick/ImageMagick/issues/594).\n  * coders/png.c: fixed memory leak of quantum_info (CVE-2017-11539, reference\n    https://github.com/ImageMagick/ImageMagick/issues/582\n  * coders/png.c: fixed NULL dereference when trying to write an empty MNG\n    (CVE-2017-11522, reference\n    https://github.com/ImageMagick/ImageMagick/issues/586).\n\n2017-07-15  7.0.6-2 Glenn Randers-Pehrson <glennrp@image...>\n  * Added caNv, eXIf, and pHYs to the list of PNG chunks to be removed\n    by the \"-strip\" option.\n\n2017-07-15  7.0.6-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-1, GIT revision 20447:c2a315e10:20170715.\n\n2017-07-13  7.0.6-1 Glenn Randers-Pehrson <glennrp@image...>\n  * Implemented PNG eXIf chunk support.\n\n2017-07-08  7.0.6-1 Cristy  <quetzlzacatenango@image...>\n  * Support new -auto-threshold option.  OTSU and Triangle methods are\n    currently supported.  Look for the Kapur method in the next release.\n  * Fixed numerous memory leaks (reference\n    https://github.com/ImageMagick/ImageMagick/issues).\n  * Don't use variable float_t / double_t, bump SO (reference\n    https://github.com/ImageMagick/ImageMagick/issues/510).\n  * Support DNG images with libraw delegate library.\n\n2017-07-02  7.0.6-1 Glenn Randers-Pehrson <glennrp@image...>\n  * Reject PNG file that is too small (under 60 bytes) to contain\n    a valid image.\n  * Reject JPEG file that is too small (under 107 bytes) to contain\n    a valid image.\n  * Reject JNG file that is too small (under 147 bytes) to contain\n    a valid image.\n\n2017-06-22  7.0.6-1 Glenn Randers-Pehrson <glennrp@image...>\n  * Stop a memory leak in read_user_chunk_callback() (reference\n    https://github.com/ImageMagick/ImageMagick/issues/517,\n    CVE 2017-11310).\n\n2017-06-10  7.0.6-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.6-0, GIT revision 20194:b0c0d00:20170611.\n\n2017-06-10  7.0.6-0 Glenn Randers-Pehrson <glennrp@image...>\n  * coders/png.c: Accept exIf chunks whose data segment\n    erroneously begins with \"Exif\\0\\0\".\n\n2017-06-10  7.0.6-0 Cristy  <quetzlzacatenango@image...>\n  * Introduce SetMagickSecurityPolicy() (MagickCore) and\n    MagickSetSecurityPolicy() (MagickWand) to set the ImageMagick security\n    policy (reference https://github.com/ImageMagick/ImageMagick/issues/407).\n\n2017-06-02  7.0.5-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-10, GIT revision 20155:38ebc02:20170602.\n\n2017-06-01  7.0.5-10 Glenn Randers-Pehrson <glennrp@image...>\n  * Removed experimental PNG zxIF chunk support; the proposal is dead.\n\n2017-06-01  7.0.5-10 Cristy  <quetzlzacatenango@image...>\n  * Fix choppy bitmap font rendering (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32071).\n  * The +opaque option is not longer a noop (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32081).\n  * Add support  for 'hex:' property.\n\n2017-05-28  7.0.5-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-9, GIT revision 20113:8b67333:20170528.\n\n2017-05-28  7.0.5-9 Cristy  <quetzlzacatenango@image...>\n  * Transient error validating the JPEG-2000 image format (reference\n    https://github.com/ImageMagick/ImageMagick/issues/501).\n  * Properly allocate DCM image colormap (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=32063).\n\n2017-05-26  7.0.5-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-8, GIT revision 20099:870a016:20170526.\n\n2017-05-23  7.0.5-8 Cristy  <quetzlzacatenango@image...>\n  * Improper allocation of memory for IM instances without threads (reference\n    https://github.com/ImageMagick/ImageMagick/issues/497).\n  * Delete corrupt image from list (reference\n    https://github.com/ImageMagick/ImageMagick/issues/500).\n\n2017-05-19  7.0.5-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-6, GIT revision 20078:7ce2d38:20170519.\n\n2017-05-15  7.0.5-7 Cristy  <quetzlzacatenango@image...>\n  * Support various image operators for the compare utility (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=2&t=31938).\n\n 2017-05-12  7.0.5-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-6, GIT revision 20039:9371904:20170512.\n\n2017-05-10  7.0.5-6 John Cupitt <jcupitt@gmail.com>\n  * Revise DICOM window and rescale handling (reference\n    https://github.com/ImageMagick/ImageMagick/pull/484)\n\n2017-05-06  7.0.5-6 Cristy  <quetzlzacatenango@image...>\n  * Restore the -alpha Shape option (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31879).\n  * Fix transient PDF bug (reference\n    https://github.com/ImageMagick/ImageMagick/issues/463).\n  * The +opaque option now works on all channels (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31862).\n  * Ensure backwards compatibility for the -combine option (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31855).\n  * Check for EOF conditions for RLE image format.\n  * Reset histogram page geometry (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31920).\n\n2017-04-24  7.0.5-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-5, GIT revision 19915:12eec43:20170424.\n\n2017-03-26  7.0.5-5 Cristy  <quetzlzacatenango@image...>\n  * Minimize buffer copies to improve OpenCL performance.\n  * Morphology thinning is no longer a no-op (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31650).\n  * Patch two PCD writer problems, corrupt output and dark pixels (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=3164).\n  * Support ICC based PDF's (reference\n    https://github.com/ImageMagick/ImageMagick/issues/417).\n  * Fix improper EPS clip path rendering (reference\n    http://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31722).\n\n2017-03-24  7.0.5-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-4, GIT revision 19754:350fff3:20170324.\n\n2017-03-21  7.0.5-4 Cristy  <quetzlzacatenango@image...>\n  * Respect -loop option for animate -window (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31619).\n\n2017-03-17  7.0.5-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-3, GIT revision 19741:070c3fb:20170317.\n\n2017-03-14  7.0.5-3 Cristy  <quetzlzacatenango@image...>\n  * Support namespaces for the security policy.\n  * Support the -authenticate option for PDF (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31530).\n\n2017-03-11  7.0.5-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-2, GIT revision 19696:da91a7c:20170311.\n\n2017-03-06  7.0.5-2 Cristy  <quetzlzacatenango@image...>\n  * Respect throttle policy (reference\n    https://github.com/ImageMagick/ImageMagick/issues/393).\n  * Return proper minima / maxima (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31377).\n\n2017-03-03  7.0.5-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-1, GIT revision 19662:b7f455a:20170303.\n\n2017-02-21  7.0.5-1 Cristy  <quetzlzacatenango@image...>\n  * Fix Spurious memory allocation message (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31438).\n  * Identical images should return inf for PSNR (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31487).\n\n2017-02-20  7.0.5-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.5-0, GIT revision 19616:505fea9:20170220.\n\n2017-02-20  7.0.5-0 Cristy  <quetzlzacatenango@image...>\n  * Fix transient bug with -separate option (reference\n    https://github.com/ImageMagick/ImageMagick/issues/385).\n\n2017-02-18  7.0.4-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-10, GIT revision 19608:fe757a2:20170218.\n\n2017-02-18  7.0.4-10 Dirk Lemstra <dirk@lem.....org>\n  * Fixed fd leak for webp coder (reference\n    https://github.com/ImageMagick/ImageMagick/pull/382)\n\n2017-02-15  7.0.4-10 Cristy  <quetzlzacatenango@image...>\n  * Prevent random pixel data for corrupt JPEG image (bug report from\n    Hirokazu Moriguchi, Sony).\n  * Restore -mattecolor option.\n  * Support pixel-cache and shred security policies.\n  * Bump Magick++ SO.  Previously a global replace changed matteColor to\n    alphaColor.\n\n2017-02-14  7.0.4-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-9, GIT revision 19580:d474b37:20170214.\n\n2017-02-14  7.0.4-9 Cristy  <quetzlzacatenango@image...>\n  * Revert patch that did not set update trait on alpha channel.\n\n2017-02-13  7.0.4-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-8, GIT revision 19574:7642384:20170213.\n\n2017-02-09  7.0.4-8 Dirk Lemstra <dirk@lem.....org>\n  * Fixed memory leak when creating nested exceptions in Magick++ (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=23&p=142634)\n\n2017-02-09  7.0.4-8 Cristy  <quetzlzacatenango@image...>\n  * Unbreak build without JPEG support (reference\n    https://github.com/ImageMagick/ImageMagick/pull/373).\n  * Document behavior change in the security policy (thanks to yoya @\n    https://blog.awm.jp/2017/02/09/imagemagick-en/).\n  * Return unbiased standard deviation for image statistics (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31377).\n  * Don't set update trait on alpha channel (private e-mail concerning\n    -levels-colors option).\n\n2017-02-04  7.0.4-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-7, GIT revision 19513:5783e57:20170204.\n\n2017-01-28  7.0.4-7 Cristy  <quetzlzacatenango@image...>\n  * Sanitize comments that include braces for the MIFF image format (reference\n    https://github.com/ImageMagick/ImageMagick/issues/368).\n\n2017-01-27  7.0.4-7 Glenn Randers-Pehrson <glennrp@image...>\n  * coders/png.c: Added support for a proposed new PNG chunk\n    (zxIf, read-only) that is currently being discussed on the\n    png-mng-misc at lists.sourceforge.net mailing list.  Enable\n    exIf and zxIf with CPPFLAGS=\"-DexIf_SUPPORTED -DxzIf_SUPPORTED\".\n    If exIf is enabled, only the uncompressed exIF chunk will be\n    written and the hex-encoded zTXt chunk containing the raw Exif\n    profile won't be written.\n\n2017-01-27  7.0.4-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-6, GIT revision 19442:4747de9:20170127.\n\n2017-01-27  7.0.4-6 Cristy  <quetzlzacatenango@image...>\n  * Uninitialized data in MAT image format (reference\n    https://github.com/ImageMagick/ImageMagick/issues/362).\n  * Properly auto-fit caption (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30887).\n  * Correction to composite Over operator (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31282).\n  * Respect gravity option (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31284).\n\n2017-01-22  7.0.4-6 Glenn Randers-Pehrson <glennrp@image...>\n  * Renamed read_vpag_chunk_callback() function to png_user_chunk_callback()\n    in coders/png.c\n  * Implemented a private PNG caNv (canvas) chunk for remembering the\n    original dimensions and offsets when an image is cropped.  Previously\n    we used the oFFs and vpAg chunks for this purpose, but this had potential\n    conflicts with other applications that also use the oFFs chunk.\n  * coders/png.c: Added support for a proposed new PNG chunk (exIf\n    read-write, eXIf read-only) that is currently being discussed on the\n    png-mng-misc at lists.sourceforge.net mailing list.\n\n2017-01-22  7.0.4-6 Dirk Lemstra <dirk@lem.....org>\n  * Replaced CoderSeekableStreamFlag with CoderDecoderSeekableStreamFlag and\n    CoderEncoderSeekableStreamFlag.\n\n2017-01-21  7.0.4-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-5, GIT revision 19381:7ae396f:20170121.\n\n2017-01-18  7.0.4-5 Cristy  <quetzlzacatenango@image...>\n  * Don't set background for transparent tiled images (reference\n    http://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31210).\n\n2017-01-14  7.0.4-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-4, GIT revision 19361:a12953c:20170114.\n\n2017-01-14  7.0.4-4 Dirk Lemstra <dirk@lem.....org>\n  * Added support for RGB555, RGB565, ARGB4444 and ARGB1555 to the\n    BMP encoder (reference\n    https://github.com/ImageMagick/ImageMagick/issues/344).\n\n2017-01-10  7.0.4-4 Cristy  <quetzlzacatenango@image...>\n  * Recognize XML policy closing tags (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31182).\n  * Fix memory leak in the MPC format.\n\n2017-01-07  7.0.4-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-3, GIT revision 19329:930ca78:20170107.\n\n2017-01-04  7.0.4-3 Cristy  <quetzlzacatenango@image...>\n  * Increase memory allocation for TIFF pixels (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31161).\n\n2017-01-03  7.0.4-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-2, GIT revision 19318:8766311:20170103.\n\n2017-01-02  7.0.4-2 Cristy  <quetzlzacatenango@image...>\n  * Validation unit test for MNG works again.\n\n2016-12-31  7.0.4-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-1, GIT revision 19292:c5ccfa8:20161231.\n\n2016-12-26  7.0.4-1 Cristy  <quetzlzacatenango@image...>\n  * Initialize draw_info alpha member to OpaqueAlpha.\n  * Monochrome images no longer have inverted colors (reference\n    https://github.com/ImageMagick/ImageMagick/issues/332).\n\n2016-12-18  7.0.4-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.4-0, GIT revision 19221:d5e8abc:20161218.\n\n2016-12-14  7.0.4-0 Cristy  <quetzlzacatenango@image...>\n * Do not close path for linejoins of round (reference\n   https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31039).\n\n2016-12-10  7.0.3-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-10, GIT revision 19191:338f088:20161210.\n\n2016-12-07  7.0.3-10 Cristy  <quetzlzacatenango@image...>\n  * Set colorspace to sRGB if -append has non-homogenous colorspaces (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=29105).\n  * Respect connected-components:area-threshold define (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31006).\n  * Enable alpha channel if background color is non-opaque (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31016).\n  * Return correct offset for negative index for -fx option (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31019).\n  * Fixed improper scaling of certain FITS images (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31028).\n  * Properly center text label (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=31027).\n\n2016-12-05  7.0.3-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-9, GIT revision 19139:6fed3f1:20161205.\n\n2016-11-26  7.0.3-9 Cristy  <quetzlzacatenango@image...>\n  * Support the compare -read-mask option.\n  * Support read-masks for the -modulate option.\n  * Prevent buffer overflow when streaming an image (reference\n    https://github.com/ImageMagick/ImageMagick/issues/312).\n  * Fix possible buffer overflow when writing compressed TIFFS (vulnerability\n    report from Cisco Talos, CVE-2016-8707).\n\n2016-11-15  7.0.3-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-8, GIT revision 19067:5aceded:20161125.\n\n2016-11-18  7.0.3-8 Cristy  <quetzlzacatenango@image...>\n  * Support the phash:colorspaces and phash:normalize options.\n  * If a convenient line break is not found, force it for caption: (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30887).\n  * Set alpha member of draw structure to OpaqueAlpha (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30894).\n  * Off by 1 error when computing the standard deviation (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=2&t=30866).\n  * Apply Debian patches, (reference\n    https://github.com/ImageMagick/ImageMagick/issues/304).\n  * Permit EPT images with just a TIFF or EPS image, not both (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30921).\n  * The -clone option no longer leaks memory.\n  * Render to clip mask rather than image for clip-path MVG graphics primitive.\n\n2016-11-15  7.0.3-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-7, GIT revision 19024:87aca83:20161115.\n\n2016-11-10  7.0.3-7 Cristy  <quetzlzacatenango@image...>\n  * Web pages were broken when we moved to HTTPS protocol.\n\n2016-11-08  7.0.3-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-6, GIT revision 19001:4cff747:20161108.\n\n2016-11-01  7.0.3-6 Cristy  <quetzlzacatenango@image...>\n  * Off by one memory allocation (reference\n    https://github.com/ImageMagick/ImageMagick/issues/296).\n  * The -extent option now matches the results of IMv6 (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=30779).\n  * Prevent fault in MSL interpreter (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30797).\n  * Mask composite produces proper results for the convert utility (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=29675).\n\n2016-10-10  7.0.3-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-5, GIT revision 18975:a8174a2:20161030.\n\n2016-10-16  7.0.3-5 Dirk Lemstra <dirk@lem.....org>\n  * Added layer RLE compression to the PSD encoder.\n\n2016-10-10  7.0.3-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-4, GIT revision 18937:83da034:20161010.\n\n2016-10-10  7.0.3-4 Dirk Lemstra <dirk@lem.....org>\n  * Fixed incorrect parsing with ordered dither. (reference\n    https://github.com/ImageMagick/ImageMagick/issues/254)\n\n2016-10-10  7.0.3-4 Cristy  <quetzlzacatenango@image...>\n  * Unit test pass again after small SUN image patch.\n\n2016-10-08  7.0.3-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-3, GIT revision 18924:d6614e7:20161008.\n\n2016-10-07  7.0.3-3 Dirk Lemstra <dirk@lem.....org>\n  * Fixed incorrect RLE decoding when reading a DCM image that contains\n    multiple segments.\n\n2016-10-02  7.0.3-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-2, GIT revision 18887:6b27c5b:20161002.\n\n2016-09-27  7.0.3-2 Dirk Lemstra <dirk@lem.....org>\n  * Fixed incorrect RLE decoding when reading an SGI image (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30514)\n\n2016-09-20  7.0.3-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-1, GIT revision 18851:ad91ea8:20160920.\n\n2016-09-16  7.0.3-1 Dirk Lemstra <dirk@lem.....org>\n  * Added layer RLE compression to the PSD encoder.\n  * Added define 'psd:preserve-opacity-mask' to preserve the opacity mask\n    in a PSD file.\n  * Fixed issue where the display window was used instead of the data window\n    when reading EXR files (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&p=137849).\n\n2016-09-05  7.0.3-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.3-0, GIT revision 18786:10aa64c:20160905.\n\n2016-08-29  7.0.3-0 Dirk Lemstra <dirk@lem.....org>\n  * Fixed reading DXT1 images with an alpha channel.\n  * Fixed incorrect padding calculation in PSD encoder.\n\n2016-08-27  7.0.2-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-10, GIT revision 18750:e3335b3:20160827.\n\n2016-08-27  7.0.2-10 Dirk Lemstra <dirk@lem.....org>\n  * Added define 'psd:additional-info' to preserve the additional information\n    in a PSD file.\n\n2016-08-15  7.0.2-10 Cristy  <quetzlzacatenango@image...>\n  * Prevent buffer overflow in BMP & SGI coders (bug report from\n    pwchen&rayzhong of tencent).\n  * Prevent buffer overflow and other problems in SIXEL, PDB, MAP, TIFF and\n    CALS coders (bug report from Donghai Zhu).\n  * The -stream option now increments the pixel pointer properly (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30327).\n\n2016-08-14  7.0.2-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-9, GIT revision 18707:2c02f09:20160814.\n\n2016-08-14  7.0.2-9 Cristy  <quetzlzacatenango@image...>\n  * Fix compile error in opencl.c (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30289).\n  * Eliminate compiler warning.\n\n2016-08-14  7.0.2-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-8, GIT revision 18698:74b1d5d:20160814.\n\n2016-08-07  7.0.2-8 Cristy  <quetzlzacatenango@image...>\n  * Prevent spurious removal of MPC cache files (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30256).\n  * Note alpha channel when combining 4 or more images (reference\n    https://github.com/ImageMagick/ImageMagick/issues/250).\n\n2016-08-06  7.0.2-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-7, GIT revision 10980:ecc03a2:20160806.\n\n2016-08-01  7.0.2-7 Cristy  <quetzlzacatenango@image...>\n  * Evaluate lazy pixel cache morphology to prevent buffer overflow (bug report\n    from Ibrahim M. El-Sayed).\n  * Prevent buffer overflow (bug report from Max Thrane).\n  * Prevent memory use after free (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=30245).\n\n2016-07-30  7.0.2-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-6, GIT revision 18651:df24175:20160729.\n\n2016-07-29  7.0.2-6 Cristy  <quetzlzacatenango@image...>\n  * Support -region option (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=29692).\n\n2016-07-21  7.0.2-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-5, GIT revision 18627:2b5ddbd:20160721.\n\n2016-07-13  7.0.2-5 Cristy  <quetzlzacatenango@image...>\n  * Fix MVG stroke-opacity (reference\n    https://github.com/ImageMagick/ImageMagick/issues/229).\n  * Prevent possible buffer overflow when reading TIFF images (bug report from\n    Shi Pu of MS509 Team).\n  * Initialize index channel to get expected results from the stegano coder.\n\n2016-07-11  7.0.2-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-4, GIT revision 18591:50debe5:20160710.\n\n2016-07-10  7.0.2-4 Cristy  <quetzlzacatenango@image...>\n  * To comply with the SVG standard, use stroke-opacity for transparent strokes.\n  * Define CompositeChannels mask to Red, Green, Blue, Alpha, and Black.\n\n2016-07-09  7.0.2-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-3, GIT revision 18572:28560fc:20160709.\n\n2016-07-01  7.0.2-3 Cristy  <quetzlzacatenango@image...>\n  * Patch so -kuwahara option can preserve colormapped edges.\n  * The histogram coder now returns the correct extent.\n  * Use CopyMagickString() rather than CopyMagickMemory() for strings.\n\n2016-06-26  7.0.2-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-2, GIT revision 18514:a7b5b46:20160626.\n\n2016-06-23  7.0.2-2 Cristy  <quetzlzacatenango@image...>\n  * Correct for numerical instability (reference\n    https://github.com/ImageMagick/ImageMagick/issues/218).\n\n2016-06-21  7.0.2-1 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-1, GIT revision 18479:931319b:20160622.\n\n2016-06-17  7.0.2-1 Dirk Lemstra <dirk@lem.....org>\n  * Added support for GROUP4 compression to the FAX coder.\n\n2016-06-12  7.0.2-1 Cristy  <quetzlzacatenango@image...>\n  * Distort no longer converts grayscale image to sRGB (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=1&t=29895).\n  * Don't return a zero bounding box for QueryMultilineFontMetrics() (reference\n    https://github.com/ImageMagick/ImageMagick/issues/222).\n\n2016-06-12  7.0.2-0 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.2-0, GIT revision 10884:f0e15e8:20160612.\n\n2016-06-09  7.0.2-0 Cristy  <quetzlzacatenango@image...>\n  * Backoff finite precision epsilon (reference\n    https://github.com/ImageMagick/ImageMagick/issues/215).\n  * Fix drawing glitch for stroke widths greater than 2 (reference\n    https://github.com/ImageMagick/ImageMagick/issues/218).\n\n2016-06-05  7.0.1-10 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-10, GIT revision 18406:ba4ad2d:20160607.\n\n2016-06-04  7.0.1-10 Cristy  <quetzlzacatenango@image...>\n  * Deny indirect reads by policy, remove policy to permit, e.g.,\n    convert caption:@mytext.txt ...\n  * RLE check for pixel offset less than 0 (heap overflow report from Craig\n    Young).\n  * Properly initialze PES blocks (reference\n    https://github.com/ImageMagick/ImageMagick/issues/213).\n\n2016-06-03  7.0.1-9 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-9, GIT revision 10847:339f803:20160602.\n\n2016-06-02  7.0.1-9 Cristy  <quetzlzacatenango@image...>\n  * Fix small memory leak (patch provided by \u0410\u043d\u0434\u0440\u0435\u0439 \u0427\u0435\u0440\u043d\u044b\u0439).\n  * Coder path traversal is not authorized (bug report provided by\n    Masaaki Chida).\n  * Turn off alpha channel for the compare difference image (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=29828).\n\n2016-05-31  7.0.1-8 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-8, GIT revision 18334:97775b5:20160531.\n\n2016-05-31  7.0.1-8 Cristy  <quetzlzacatenango@image...>\n  * Support configure script --enable-pipes option to enable pipes (|) in\n    filenames.\n  * Support configure script --enable-indirect-reads option to enable\n    indirect reads (@) in filenames.\n\n2016-05-30  7.0.1-7 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-7, GIT revision 18321:5511ef5:20160530.\n\n2016-05-25  7.0.1-7 Cristy  <quetzlzacatenango@image...>\n  * Security improvements to TEXT coder broke it (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=29754).\n  * Fix stroke offset problem for -annotate (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=29626).\n  * Don't interpret -fx option arguments (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=29774);\n  * Add additional checks to DCM reader to prevent data-driven faults (bug\n    report from Hanno B\u00f6ck).\n\n2016-05-21  7.0.1-6 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-6, GIT revision 18241:d4f277c:20160521.\n\n2016-05-20  7.0.1-6 Cristy  <quetzlzacatenango@image...>\n  * Fixed proper placement of text annotation for east / west gravity.\n\n2016-05-18  7.0.1-5 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-5, GIT revision 10789:f7c2e89:20160518,\n\n2016-05-18  7.0.1-5 Cristy  <quetzlzacatenango@image...>\n  * Process channels independently for -channel -equalize (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=3&t=29708).\n  * Fix pixel cache on disk regression (reference\n    https://github.com/ImageMagick/ImageMagick/issues/202).\n\n2016-05-15  7.0.1-4 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-4, GIT revision 10778:52dae14:20160516.\n\n2016-05-10  7.0.1-4 Cristy  <quetzlzacatenango@image...>\n  * Prevent possible shell command injection vulnerability through the\n    authenticate parameter of the PDF, PCL and XPS coders (report from\n    Erez Turjeman).\n  * Quote passwords when passed to a delegate program.\n  * Iterate channels over source image rather than destination (bug report\n    from Hanno B\u00f6ck).\n  * Can read geo-related EXIF metdata once-again (reference\n    https://github.com/ImageMagick/ImageMagick/issues/198).\n  * Sanitize all delegate emedded formatting characters.\n  * Don't sync pixel cache in AcquireAuthenticCacheView() (bug report from\n    Hanno B\u00f6ck).\n\n2016-05-09  7.0.1-3 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-3, GIT revision 10755:d540dda:20160509.\n\n2016-05-07  7.0.1-3 Cristy  <quetzlzacatenango@image...>\n  * Remove https delegate.\n\n2016-05-06  7.0.1-2 Cristy  <quetzlzacatenango@image...>\n  * Release ImageMagick version 7.0.1-2, GIT revision 10741:5746147:20160507.\n\n2016-05-04  7.0.1-2 Cristy  <quetzlzacatenango@image...>\n  * Check for buffer overflow in magick/draw.c/DrawStrokePolygon().\n  * Replace show delegate title with image filename rather than label.\n  * Fix GetNextToken() off by one error.\n  * Remove support for internal ephemeral coder.\n\n2016-05-03  7.0.1-1 Cristy  <quetzlzacatenango@image...>\n  * New version 7.0.1-1, GIT revision 10723:9fc8a0c:20160503.\n\n2016-05-03  7.0.1-1 Cristy  <quetzlzacatenango@image...>\n  * Sanitize input filename for http / https delegates (improved patch).\n  * Fix for possible security vulnerabilities (reference\n    https://imagemagick.org/discourse-server/viewtopic.php?f=4&t=29588).\n\n2016-04-30  7.0.1-0 Cristy  <quetzlzacatenango@image...>\n  * New version 7.0.1-0, GIT revision 10716:b527bce:20160430.\n\n2016-01-30  7.0.0-0 Fahad-Alsaidi & ShamsaHamed\n  * Add support for languages that require complex text layout (reference\n    https://github.com/ImageMagick/ImageMagick/pull/88).\n\n2012-04-27  7.0.0-0 Anthony thyssen <A.Thyssen@griffith...>\n  * Allow the use of set and escapes when no images in memory\n    (unless you attempt to access per-image meta-data)\n    Currently does not include %[fx:...] and %[pixel:...]\n\n2012-10-05  7.0.0-0 Anthony thyssen <A.Thyssen@griffith...>\n  * Rather than replicate 'options' into 'artifacts' make a link\n    from image to image_info and lookup a global option if no artifact\n    is defined.\n\n2012-09-11  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * sigmoidal-contrast:\n  * Remove unnecessary initial ClampToQuantum.\n\n2012-09-10  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * sigmoidal-contrast:\n  * Direct computation, without LUT;\n  * Fix re-declaration of i (at the top, and inside a conditional).\n\n2012-09-04  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * Add tanh/atanh clone of legacy sigmoidal map (faster & more accurate).\n\n2012-08-08  7.0.0-0 Nicolas Robidoux <nicolas.robidoux@gmail...>\n  * Add final ClampToQuantum in sigmoidal colormap loop.\n  * Remove OpenMP calls from colormap update loops.\n\n2011-08-01  7.0.0-0 Cristy  <quetzlzacatenango@image...>\n  * New version 7.0.0-0.\n\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        JJJJJ  PPPP   EEEEE   GGGG                           %\n%                          J    P   P  E      G                               %\n%                          J    PPPP   EEE    G  GG                           %\n%                        J J    P      E      G   G                           %\n%                        JJJ    P      EEEEE   GGG                            %\n%                                                                             %\n%                                                                             %\n%                       Read/Write JPEG Image Format                          %\n%                                                                             %\n%                              Software Design                                %\n%                                John Cristy                                  %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2013 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n% This software is based in part on the work of the Independent JPEG Group.\n% See ftp://ftp.uu.net/graphics/jpeg/jpegsrc.v6b.tar.gz for copyright and\n% licensing restrictions.  Blob support contributed by Glenn Randers-Pehrson.\n%\n%\n*/\n\n\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/memory-private.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/option-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/xml-tree.h\"\n#include \"MagickCore/xml-tree-private.h\"\n#include <setjmp.h>\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n#define JPEG_INTERNAL_OPTIONS\n#if defined(__MINGW32__)\n# define XMD_H 1  /* Avoid conflicting typedef for INT32 */\n#endif\n#undef HAVE_STDLIB_H\n#include \"jpeglib.h\"\n#include \"jerror.h\"\n#endif\n\f\n/*\n  Define declarations.\n*/\n#define ICC_MARKER  (JPEG_APP0+2)\n#define ICC_PROFILE  \"ICC_PROFILE\"\n#define IPTC_MARKER  (JPEG_APP0+13)\n#define XML_MARKER  (JPEG_APP0+1)\n#define MaxJPEGScans  1024\n\f\n/*\n  Typedef declarations.\n*/\n#if defined(MAGICKCORE_JPEG_DELEGATE)\ntypedef struct _DestinationManager\n{\n  struct jpeg_destination_mgr\n    manager;\n\n  Image\n    *image;\n\n  JOCTET\n    *buffer;\n} DestinationManager;\n\ntypedef struct _ErrorManager\n{\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    finished;\n\n  StringInfo\n    *profile;\n\n  jmp_buf\n    error_recovery;\n} ErrorManager;\n\ntypedef struct _SourceManager\n{\n  struct jpeg_source_mgr\n    manager;\n\n  Image\n    *image;\n\n  JOCTET\n    *buffer;\n\n  boolean\n    start_of_blob;\n} SourceManager;\n#endif\n\ntypedef struct _QuantizationTable\n{\n  char\n    *slot,\n    *description;\n\n  size_t\n    width,\n    height;\n\n  double\n    divisor;\n\n  unsigned int\n    *levels;\n} QuantizationTable;\n\f\n/*\n  Const declarations.\n*/\nstatic const char\n  xmp_namespace[] = \"http://ns.adobe.com/xap/1.0/ \";\n#define XmpNamespaceExtent 28\n\f\n/*\n  Forward declarations.\n*/\n#if defined(MAGICKCORE_JPEG_DELEGATE)\nstatic MagickBooleanType\n  WriteJPEGImage(const ImageInfo *,Image *,ExceptionInfo *);\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s J P E G                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsJPEG() returns MagickTrue if the image format type, identified by the\n%  magick string, is JPEG.\n%\n%  The format of the IsJPEG  method is:\n%\n%      MagickBooleanType IsJPEG(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsJPEG(const unsigned char *magick,const size_t length)\n{\n  if (length < 3)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\377\\330\\377\",3) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d J P E G I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadJPEGImage() reads a JPEG image file and returns it.  It allocates\n%  the memory necessary for the new Image structure and returns a pointer to\n%  the new image.\n%\n%  The format of the ReadJPEGImage method is:\n%\n%      Image *ReadJPEGImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic boolean FillInputBuffer(j_decompress_ptr cinfo)\n{\n  SourceManager\n    *source;\n\n  source=(SourceManager *) cinfo->src;\n  source->manager.bytes_in_buffer=(size_t) ReadBlob(source->image,\n    MagickMinBufferExtent,source->buffer);\n  if (source->manager.bytes_in_buffer == 0)\n    {\n      if (source->start_of_blob != FALSE)\n        ERREXIT(cinfo,JERR_INPUT_EMPTY);\n      WARNMS(cinfo,JWRN_JPEG_EOF);\n      source->buffer[0]=(JOCTET) 0xff;\n      source->buffer[1]=(JOCTET) JPEG_EOI;\n      source->manager.bytes_in_buffer=2;\n    }\n  source->manager.next_input_byte=source->buffer;\n  source->start_of_blob=FALSE;\n  return(TRUE);\n}\n\nstatic int GetCharacter(j_decompress_ptr jpeg_info)\n{\n  if (jpeg_info->src->bytes_in_buffer == 0)\n    {\n      (void) (*jpeg_info->src->fill_input_buffer)(jpeg_info);\n      if (jpeg_info->err->msg_code == JWRN_JPEG_EOF)\n        return EOF;\n    }\n  jpeg_info->src->bytes_in_buffer--;\n  return((int) GETJOCTET(*jpeg_info->src->next_input_byte++));\n}\n\nstatic void InitializeSource(j_decompress_ptr cinfo)\n{\n  SourceManager\n    *source;\n\n  source=(SourceManager *) cinfo->src;\n  source->start_of_blob=TRUE;\n}\n\nstatic MagickBooleanType IsITUFaxImage(const Image *image)\n{\n  const StringInfo\n    *profile;\n\n  const unsigned char\n    *datum;\n\n  profile=GetImageProfile(image,\"8bim\");\n  if (profile == (const StringInfo *) NULL)\n    return(MagickFalse);\n  if (GetStringInfoLength(profile) < 5)\n    return(MagickFalse);\n  datum=GetStringInfoDatum(profile);\n  if ((datum[0] == 0x47) && (datum[1] == 0x33) && (datum[2] == 0x46) &&\n      (datum[3] == 0x41) && (datum[4] == 0x58))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic void JPEGErrorHandler(j_common_ptr jpeg_info)\n{\n  char\n    message[JMSG_LENGTH_MAX];\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  *message='\\0';\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  image=error_manager->image;\n  exception=error_manager->exception;\n  (jpeg_info->err->format_message)(jpeg_info,message);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"[%s] JPEG Trace: \\\"%s\\\"\",image->filename,message);\n  if (error_manager->finished != MagickFalse)\n    (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageWarning,\n      (char *) message,\"`%s'\",image->filename);\n  else\n    (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n      (char *) message,\"`%s'\",image->filename);\n  longjmp(error_manager->error_recovery,1);\n}\n\nstatic void JPEGProgressHandler(j_common_ptr jpeg_info)\n{\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  image=error_manager->image;\n  exception=error_manager->exception;\n  if (jpeg_info->is_decompressor == 0)\n    return;\n  if (((j_decompress_ptr) jpeg_info)->input_scan_number < MaxJPEGScans)\n    return;\n  (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n    \"too many scans\",\"`%s'\",image->filename);\n  longjmp(error_manager->error_recovery,1);\n}\n\nstatic MagickBooleanType JPEGWarningHandler(j_common_ptr jpeg_info,int level)\n{\n#define JPEGExcessiveWarnings  1000\n\n  char\n    message[JMSG_LENGTH_MAX];\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  *message='\\0';\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  if (level < 0)\n    {\n      /*\n        Process warning message.\n      */\n      (jpeg_info->err->format_message)(jpeg_info,message);\n      if (jpeg_info->err->num_warnings++ < JPEGExcessiveWarnings)\n        ThrowBinaryException(CorruptImageWarning,(char *) message,\n          image->filename);\n    }\n  else\n    if ((image->debug != MagickFalse) &&\n        (level >= jpeg_info->err->trace_level))\n      {\n        /*\n          Process trace message.\n        */\n        (jpeg_info->err->format_message)(jpeg_info,message);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"[%s] JPEG Trace: \\\"%s\\\"\",image->filename,message);\n      }\n  return(MagickTrue);\n}\n\nstatic boolean ReadComment(j_decompress_ptr jpeg_info)\n{\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  StringInfo\n    *comment;\n\n  /*\n    Determine length of comment.\n  */\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=GetCharacter(jpeg_info);\n  if (length <= 2)\n    return(TRUE);\n  length-=2;\n  comment=BlobToStringInfo((const void *) NULL,length);\n  if (comment == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  /*\n    Read comment.\n  */\n  error_manager->profile=comment;\n  p=GetStringInfoDatum(comment);\n  for (i=0; i < (ssize_t) length; i++)\n  {\n    int\n      c;\n\n    c=GetCharacter(jpeg_info);\n    if (c == EOF)\n      break;\n    *p++=(unsigned char) c;\n  }\n  *p='\\0';\n  error_manager->profile=NULL;\n  if (i != (ssize_t) length)\n    {\n      comment=DestroyStringInfo(comment);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        CorruptImageError,\"InsufficientImageDataInFile\",\"`%s'\",\n        image->filename);\n      return(FALSE);\n    }\n  p=GetStringInfoDatum(comment);\n  (void) SetImageProperty(image,\"comment\",(const char *) p,exception);\n  comment=DestroyStringInfo(comment);\n  return(TRUE);\n}\n\nstatic boolean ReadICCProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    magick[12];\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *icc_profile,\n    *profile;\n\n  /*\n    Read color profile.\n  */\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=(size_t) GetCharacter(jpeg_info);\n  length-=2;\n  if (length <= 14)\n    {\n      while (length-- > 0)\n        if (GetCharacter(jpeg_info) == EOF)\n          break;\n      return(TRUE);\n    }\n  for (i=0; i < 12; i++)\n    magick[i]=(char) GetCharacter(jpeg_info);\n  if (LocaleCompare(magick,ICC_PROFILE) != 0)\n    {\n      /*\n        Not a ICC profile, return.\n      */\n      for (i=0; i < (ssize_t) (length-12); i++)\n        if (GetCharacter(jpeg_info) == EOF)\n          break;\n      return(TRUE);\n    }\n  (void) GetCharacter(jpeg_info);  /* id */\n  (void) GetCharacter(jpeg_info);  /* markers */\n  length-=14;\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  profile=BlobToStringInfo((const void *) NULL,length);\n  if (profile == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  error_manager->profile=profile;\n  p=GetStringInfoDatum(profile);\n  for (i=0; i < (ssize_t) length; i++)\n  {\n    int\n      c;\n\n    c=GetCharacter(jpeg_info);\n    if (c == EOF)\n      break;\n    *p++=(unsigned char) c;\n  }\n  error_manager->profile=NULL;\n  if (i != (ssize_t) length)\n    {\n      profile=DestroyStringInfo(profile);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        CorruptImageError,\"InsufficientImageDataInFile\",\"`%s'\",\n        image->filename);\n      return(FALSE);\n    }\n  icc_profile=(StringInfo *) GetImageProfile(image,\"icc\");\n  if (icc_profile != (StringInfo *) NULL)\n    {\n      ConcatenateStringInfo(icc_profile,profile);\n      profile=DestroyStringInfo(profile);\n    }\n  else\n    {\n      status=SetImageProfile(image,\"icc\",profile,exception);\n      profile=DestroyStringInfo(profile);\n      if (status == MagickFalse)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n          return(FALSE);\n        }\n    }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Profile: ICC, %.20g bytes\",(double) length);\n  return(TRUE);\n}\n\nstatic boolean ReadIPTCProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    magick[MagickPathExtent];\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *iptc_profile,\n    *profile;\n\n  /*\n    Determine length of binary data stored here.\n  */\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=(size_t) GetCharacter(jpeg_info);\n  length-=2;\n  if (length <= 14)\n    {\n      while (length-- > 0)\n        if (GetCharacter(jpeg_info) == EOF)\n          break;\n      return(TRUE);\n    }\n  /*\n    Validate that this was written as a Photoshop resource format slug.\n  */\n  for (i=0; i < 10; i++)\n    magick[i]=(char) GetCharacter(jpeg_info);\n  magick[10]='\\0';\n  length-=10;\n  if (length <= 10)\n    return(TRUE);\n  if (LocaleCompare(magick,\"Photoshop \") != 0)\n    {\n      /*\n        Not a IPTC profile, return.\n      */\n      for (i=0; i < (ssize_t) length; i++)\n        if (GetCharacter(jpeg_info) == EOF)\n          break;\n      return(TRUE);\n    }\n  /*\n    Remove the version number.\n  */\n  for (i=0; i < 4; i++)\n    if (GetCharacter(jpeg_info) == EOF)\n      break;\n  if (length <= 11)\n    return(TRUE);\n  length-=4;\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  profile=BlobToStringInfo((const void *) NULL,length);\n  if (profile == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  error_manager->profile=profile;\n  p=GetStringInfoDatum(profile);\n  for (i=0; i < (ssize_t) length; i++)\n  {\n    int\n      c;\n\n    c=GetCharacter(jpeg_info);\n    if (c == EOF)\n      break;\n    *p++=(unsigned char) c;\n  }\n  error_manager->profile=NULL;\n  if (i != (ssize_t) length)\n    {\n      profile=DestroyStringInfo(profile);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        CorruptImageError,\"InsufficientImageDataInFile\",\"`%s'\",\n        image->filename);\n      return(FALSE);\n    }\n  /*\n    The IPTC profile is actually an 8bim.\n  */\n  iptc_profile=(StringInfo *) GetImageProfile(image,\"8bim\");\n  if (iptc_profile != (StringInfo *) NULL)\n    {\n      ConcatenateStringInfo(iptc_profile,profile);\n      profile=DestroyStringInfo(profile);\n    }\n  else\n    {\n      status=SetImageProfile(image,\"8bim\",profile,exception);\n      profile=DestroyStringInfo(profile);\n      if (status == MagickFalse)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n          return(FALSE);\n        }\n    }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Profile: iptc, %.20g bytes\",(double) length);\n  return(TRUE);\n}\n\nstatic boolean ReadProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    name[MagickPathExtent];\n\n  const StringInfo\n    *previous_profile;\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  int\n    marker;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *profile;\n\n  /*\n    Read generic profile.\n  */\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=(size_t) GetCharacter(jpeg_info);\n  if (length <= 2)\n    return(TRUE);\n  length-=2;\n  marker=jpeg_info->unread_marker-JPEG_APP0;\n  (void) FormatLocaleString(name,MagickPathExtent,\"APP%d\",marker);\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  profile=BlobToStringInfo((const void *) NULL,length);\n  if (profile == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  error_manager->profile=profile;\n  p=GetStringInfoDatum(profile);\n  for (i=0; i < (ssize_t) length; i++)\n  {\n    int\n      c;\n\n    c=GetCharacter(jpeg_info);\n    if (c == EOF)\n      break;\n    *p++=(unsigned char) c;\n  }\n  error_manager->profile=NULL;\n  if (i != (ssize_t) length)\n    {\n      profile=DestroyStringInfo(profile);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        CorruptImageError,\"InsufficientImageDataInFile\",\"`%s'\",\n        image->filename);\n      return(FALSE);\n    }\n  if (marker == 1)\n    {\n      p=GetStringInfoDatum(profile);\n      if ((length > 4) && (LocaleNCompare((char *) p,\"exif\",4) == 0))\n        (void) CopyMagickString(name,\"exif\",MagickPathExtent);\n      else if ((length > XmpNamespaceExtent) &&\n          (LocaleNCompare((char *) p,xmp_namespace,XmpNamespaceExtent-1) == 0))\n        {\n          ssize_t\n            j;\n\n          /*\n            Extract namespace from XMP profile.\n          */\n          p=GetStringInfoDatum(profile)+XmpNamespaceExtent;\n          for (j=XmpNamespaceExtent; j < (ssize_t) GetStringInfoLength(profile); j++)\n          {\n            if (*p == '\\0')\n              break;\n            p++;\n          }\n          if (j < (ssize_t) GetStringInfoLength(profile))\n            (void) DestroyStringInfo(SplitStringInfo(profile,(size_t) (j+1)));\n          (void) CopyMagickString(name,\"xmp\",MagickPathExtent);\n        }\n    }\n  previous_profile=GetImageProfile(image,name);\n  if ((previous_profile != (const StringInfo *) NULL) &&\n      (CompareStringInfo(previous_profile,profile) != 0))\n    {\n      size_t\n        profile_length;\n\n      profile_length=GetStringInfoLength(profile);\n      SetStringInfoLength(profile,GetStringInfoLength(profile)+\n        GetStringInfoLength(previous_profile));\n      (void) memmove(GetStringInfoDatum(profile)+\n        GetStringInfoLength(previous_profile),GetStringInfoDatum(profile),\n        profile_length);\n      (void) memcpy(GetStringInfoDatum(profile),\n        GetStringInfoDatum(previous_profile),\n        GetStringInfoLength(previous_profile));\n    }\n  status=SetImageProfile(image,name,profile,exception);\n  profile=DestroyStringInfo(profile);\n  if (status == MagickFalse)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Profile: %s, %.20g bytes\",name,(double) length);\n  return(TRUE);\n}\n\nstatic void SkipInputData(j_decompress_ptr cinfo,long number_bytes)\n{\n  SourceManager\n    *source;\n\n  if (number_bytes <= 0)\n    return;\n  source=(SourceManager *) cinfo->src;\n  while (number_bytes > (long) source->manager.bytes_in_buffer)\n  {\n    number_bytes-=(long) source->manager.bytes_in_buffer;\n    (void) FillInputBuffer(cinfo);\n  }\n  source->manager.next_input_byte+=number_bytes;\n  source->manager.bytes_in_buffer-=number_bytes;\n}\n\nstatic void TerminateSource(j_decompress_ptr cinfo)\n{\n  (void) cinfo;\n}\n\nstatic void JPEGSourceManager(j_decompress_ptr cinfo,Image *image)\n{\n  SourceManager\n    *source;\n\n  cinfo->src=(struct jpeg_source_mgr *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,sizeof(SourceManager));\n  source=(SourceManager *) cinfo->src;\n  source->buffer=(JOCTET *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,MagickMinBufferExtent*sizeof(JOCTET));\n  source=(SourceManager *) cinfo->src;\n  source->manager.init_source=InitializeSource;\n  source->manager.fill_input_buffer=FillInputBuffer;\n  source->manager.skip_input_data=SkipInputData;\n  source->manager.resync_to_restart=jpeg_resync_to_restart;\n  source->manager.term_source=TerminateSource;\n  source->manager.bytes_in_buffer=0;\n  source->manager.next_input_byte=NULL;\n  source->image=image;\n}\n\nstatic void JPEGSetImageQuality(struct jpeg_decompress_struct *jpeg_info,\n  Image *image)\n{\n  image->quality=UndefinedCompressionQuality;\n#if defined(D_PROGRESSIVE_SUPPORTED)\n  if (image->compression == LosslessJPEGCompression)\n    {\n      image->quality=100;\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"Quality: 100 (lossless)\");\n    }\n  else\n#endif\n  {\n    ssize_t\n      j,\n      qvalue,\n      sum;\n\n    register ssize_t\n      i;\n\n    /*\n      Determine the JPEG compression quality from the quantization tables.\n    */\n    sum=0;\n    for (i=0; i < NUM_QUANT_TBLS; i++)\n    {\n      if (jpeg_info->quant_tbl_ptrs[i] != NULL)\n        for (j=0; j < DCTSIZE2; j++)\n          sum+=jpeg_info->quant_tbl_ptrs[i]->quantval[j];\n    }\n    if ((jpeg_info->quant_tbl_ptrs[0] != NULL) &&\n        (jpeg_info->quant_tbl_ptrs[1] != NULL))\n      {\n        ssize_t\n          hash[101] =\n          {\n            1020, 1015,  932,  848,  780,  735,  702,  679,  660,  645,\n             632,  623,  613,  607,  600,  594,  589,  585,  581,  571,\n             555,  542,  529,  514,  494,  474,  457,  439,  424,  410,\n             397,  386,  373,  364,  351,  341,  334,  324,  317,  309,\n             299,  294,  287,  279,  274,  267,  262,  257,  251,  247,\n             243,  237,  232,  227,  222,  217,  213,  207,  202,  198,\n             192,  188,  183,  177,  173,  168,  163,  157,  153,  148,\n             143,  139,  132,  128,  125,  119,  115,  108,  104,   99,\n              94,   90,   84,   79,   74,   70,   64,   59,   55,   49,\n              45,   40,   34,   30,   25,   20,   15,   11,    6,    4,\n               0\n          },\n          sums[101] =\n          {\n            32640, 32635, 32266, 31495, 30665, 29804, 29146, 28599, 28104,\n            27670, 27225, 26725, 26210, 25716, 25240, 24789, 24373, 23946,\n            23572, 22846, 21801, 20842, 19949, 19121, 18386, 17651, 16998,\n            16349, 15800, 15247, 14783, 14321, 13859, 13535, 13081, 12702,\n            12423, 12056, 11779, 11513, 11135, 10955, 10676, 10392, 10208,\n             9928,  9747,  9564,  9369,  9193,  9017,  8822,  8639,  8458,\n             8270,  8084,  7896,  7710,  7527,  7347,  7156,  6977,  6788,\n             6607,  6422,  6236,  6054,  5867,  5684,  5495,  5305,  5128,\n             4945,  4751,  4638,  4442,  4248,  4065,  3888,  3698,  3509,\n             3326,  3139,  2957,  2775,  2586,  2405,  2216,  2037,  1846,\n             1666,  1483,  1297,  1109,   927,   735,   554,   375,   201,\n              128,     0\n          };\n\n        qvalue=(ssize_t) (jpeg_info->quant_tbl_ptrs[0]->quantval[2]+\n          jpeg_info->quant_tbl_ptrs[0]->quantval[53]+\n          jpeg_info->quant_tbl_ptrs[1]->quantval[0]+\n          jpeg_info->quant_tbl_ptrs[1]->quantval[DCTSIZE2-1]);\n        for (i=0; i < 100; i++)\n        {\n          if ((qvalue < hash[i]) && (sum < sums[i]))\n            continue;\n          if (((qvalue <= hash[i]) && (sum <= sums[i])) || (i >= 50))\n            image->quality=(size_t) i+1;\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"Quality: %.20g (%s)\",(double) i+1,(qvalue <= hash[i]) &&\n              (sum <= sums[i]) ? \"exact\" : \"approximate\");\n          break;\n        }\n      }\n    else\n      if (jpeg_info->quant_tbl_ptrs[0] != NULL)\n        {\n          ssize_t\n            hash[101] =\n            {\n              510,  505,  422,  380,  355,  338,  326,  318,  311,  305,\n              300,  297,  293,  291,  288,  286,  284,  283,  281,  280,\n              279,  278,  277,  273,  262,  251,  243,  233,  225,  218,\n              211,  205,  198,  193,  186,  181,  177,  172,  168,  164,\n              158,  156,  152,  148,  145,  142,  139,  136,  133,  131,\n              129,  126,  123,  120,  118,  115,  113,  110,  107,  105,\n              102,  100,   97,   94,   92,   89,   87,   83,   81,   79,\n               76,   74,   70,   68,   66,   63,   61,   57,   55,   52,\n               50,   48,   44,   42,   39,   37,   34,   31,   29,   26,\n               24,   21,   18,   16,   13,   11,    8,    6,    3,    2,\n                0\n            },\n            sums[101] =\n            {\n              16320, 16315, 15946, 15277, 14655, 14073, 13623, 13230, 12859,\n              12560, 12240, 11861, 11456, 11081, 10714, 10360, 10027,  9679,\n               9368,  9056,  8680,  8331,  7995,  7668,  7376,  7084,  6823,\n               6562,  6345,  6125,  5939,  5756,  5571,  5421,  5240,  5086,\n               4976,  4829,  4719,  4616,  4463,  4393,  4280,  4166,  4092,\n               3980,  3909,  3835,  3755,  3688,  3621,  3541,  3467,  3396,\n               3323,  3247,  3170,  3096,  3021,  2952,  2874,  2804,  2727,\n               2657,  2583,  2509,  2437,  2362,  2290,  2211,  2136,  2068,\n               1996,  1915,  1858,  1773,  1692,  1620,  1552,  1477,  1398,\n               1326,  1251,  1179,  1109,  1031,   961,   884,   814,   736,\n                667,   592,   518,   441,   369,   292,   221,   151,    86,\n                 64,     0\n            };\n\n          qvalue=(ssize_t) (jpeg_info->quant_tbl_ptrs[0]->quantval[2]+\n            jpeg_info->quant_tbl_ptrs[0]->quantval[53]);\n          for (i=0; i < 100; i++)\n          {\n            if ((qvalue < hash[i]) && (sum < sums[i]))\n              continue;\n            if (((qvalue <= hash[i]) && (sum <= sums[i])) || (i >= 50))\n              image->quality=(size_t)i+1;\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Quality: %.20g (%s)\",(double) i+1,(qvalue <= hash[i]) &&\n                (sum <= sums[i]) ? \"exact\" : \"approximate\");\n            break;\n          }\n        }\n  }\n}\n\nstatic void JPEGSetImageSamplingFactor(struct jpeg_decompress_struct *jpeg_info,  Image *image,ExceptionInfo *exception)\n{\n  char\n    sampling_factor[MagickPathExtent];\n\n  switch (jpeg_info->out_color_space)\n  {\n    case JCS_CMYK:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: CMYK\");\n      (void) FormatLocaleString(sampling_factor,MagickPathExtent,\n        \"%dx%d,%dx%d,%dx%d,%dx%d\",jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor,\n        jpeg_info->comp_info[1].h_samp_factor,\n        jpeg_info->comp_info[1].v_samp_factor,\n        jpeg_info->comp_info[2].h_samp_factor,\n        jpeg_info->comp_info[2].v_samp_factor,\n        jpeg_info->comp_info[3].h_samp_factor,\n        jpeg_info->comp_info[3].v_samp_factor);\n      break;\n    }\n    case JCS_GRAYSCALE:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"Colorspace: GRAYSCALE\");\n      (void) FormatLocaleString(sampling_factor,MagickPathExtent,\"%dx%d\",\n        jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor);\n      break;\n    }\n    case JCS_RGB:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: RGB\");\n      (void) FormatLocaleString(sampling_factor,MagickPathExtent,\n        \"%dx%d,%dx%d,%dx%d\",jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor,\n        jpeg_info->comp_info[1].h_samp_factor,\n        jpeg_info->comp_info[1].v_samp_factor,\n        jpeg_info->comp_info[2].h_samp_factor,\n        jpeg_info->comp_info[2].v_samp_factor);\n      break;\n    }\n    default:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: %d\",\n        jpeg_info->out_color_space);\n      (void) FormatLocaleString(sampling_factor,MagickPathExtent,\n        \"%dx%d,%dx%d,%dx%d,%dx%d\",jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor,\n        jpeg_info->comp_info[1].h_samp_factor,\n        jpeg_info->comp_info[1].v_samp_factor,\n        jpeg_info->comp_info[2].h_samp_factor,\n        jpeg_info->comp_info[2].v_samp_factor,\n        jpeg_info->comp_info[3].h_samp_factor,\n        jpeg_info->comp_info[3].v_samp_factor);\n      break;\n    }\n  }\n  (void) SetImageProperty(image,\"jpeg:sampling-factor\",sampling_factor,\n    exception);\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Sampling Factors: %s\",\n    sampling_factor);\n}\n\nstatic Image *ReadJPEGImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    value[MagickPathExtent];\n\n  const char\n    *dct_method,\n    *option;\n\n  ErrorManager\n    error_manager;\n\n  Image\n    *image;\n\n  JSAMPLE\n    *volatile jpeg_pixels;\n\n  JSAMPROW\n    scanline[1];\n\n  MagickBooleanType\n    debug,\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *memory_info;\n\n  Quantum\n    index;\n\n  register ssize_t\n    i;\n\n  struct jpeg_decompress_struct\n    jpeg_info;\n\n  struct jpeg_error_mgr\n    jpeg_error;\n\n  struct jpeg_progress_mgr\n    jpeg_progress;\n\n  register JSAMPLE\n    *p;\n\n  size_t\n    units;\n\n  ssize_t\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  debug=IsEventLogging();\n  (void) debug;\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Verify that file size large enough to contain a JPEG datastream.\n  */\n  if (GetBlobSize(image) < 107)\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n  /*\n    Initialize JPEG parameters.\n  */\n  (void) memset(&error_manager,0,sizeof(error_manager));\n  (void) memset(&jpeg_info,0,sizeof(jpeg_info));\n  (void) memset(&jpeg_error,0,sizeof(jpeg_error));\n  (void) memset(&jpeg_progress,0,sizeof(jpeg_progress));\n  jpeg_info.err=jpeg_std_error(&jpeg_error);\n  jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;\n  jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;\n  memory_info=(MemoryInfo *) NULL;\n  error_manager.exception=exception;\n  error_manager.image=image;\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      if (error_manager.profile != (StringInfo *) NULL)\n        error_manager.profile=DestroyStringInfo(error_manager.profile);\n      (void) CloseBlob(image);\n      number_pixels=(MagickSizeType) image->columns*image->rows;\n      if (number_pixels != 0)\n        return(GetFirstImageInList(image));\n      return(DestroyImage(image));\n    }\n  jpeg_info.client_data=(void *) &error_manager;\n  jpeg_create_decompress(&jpeg_info);\n  if (GetMaxMemoryRequest() != ~0UL)\n    jpeg_info.mem->max_memory_to_use=(long) GetMaxMemoryRequest();\n  jpeg_progress.progress_monitor=(void (*)(j_common_ptr)) JPEGProgressHandler;\n  jpeg_info.progress=(&jpeg_progress);\n  JPEGSourceManager(&jpeg_info,image);\n  jpeg_set_marker_processor(&jpeg_info,JPEG_COM,ReadComment);\n  option=GetImageOption(image_info,\"profile:skip\");\n  if (IsOptionMember(\"ICC\",option) == MagickFalse)\n    jpeg_set_marker_processor(&jpeg_info,ICC_MARKER,ReadICCProfile);\n  if (IsOptionMember(\"IPTC\",option) == MagickFalse)\n    jpeg_set_marker_processor(&jpeg_info,IPTC_MARKER,ReadIPTCProfile);\n  for (i=1; i < 16; i++)\n    if ((i != 2) && (i != 13) && (i != 14))\n      if (IsOptionMember(\"APP\",option) == MagickFalse)\n        jpeg_set_marker_processor(&jpeg_info,(int) (JPEG_APP0+i),ReadProfile);\n  i=(ssize_t) jpeg_read_header(&jpeg_info,TRUE);\n  if ((image_info->colorspace == YCbCrColorspace) ||\n      (image_info->colorspace == Rec601YCbCrColorspace) ||\n      (image_info->colorspace == Rec709YCbCrColorspace))\n    jpeg_info.out_color_space=JCS_YCbCr;\n  /*\n    Set image resolution.\n  */\n  units=0;\n  if ((jpeg_info.saw_JFIF_marker != 0) && (jpeg_info.X_density != 1) &&\n      (jpeg_info.Y_density != 1))\n    {\n      image->resolution.x=(double) jpeg_info.X_density;\n      image->resolution.y=(double) jpeg_info.Y_density;\n      units=(size_t) jpeg_info.density_unit;\n    }\n  if (units == 1)\n    image->units=PixelsPerInchResolution;\n  if (units == 2)\n    image->units=PixelsPerCentimeterResolution;\n  number_pixels=(MagickSizeType) image->columns*image->rows;\n  option=GetImageOption(image_info,\"jpeg:size\");\n  if ((option != (const char *) NULL) &&\n      (jpeg_info.out_color_space != JCS_YCbCr))\n    {\n      double\n        scale_factor;\n\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      /*\n        Scale the image.\n      */\n      flags=ParseGeometry(option,&geometry_info);\n      if ((flags & SigmaValue) == 0)\n        geometry_info.sigma=geometry_info.rho;\n      jpeg_calc_output_dimensions(&jpeg_info);\n      image->magick_columns=jpeg_info.output_width;\n      image->magick_rows=jpeg_info.output_height;\n      scale_factor=1.0;\n      if (geometry_info.rho != 0.0)\n        scale_factor=jpeg_info.output_width/geometry_info.rho;\n      if ((geometry_info.sigma != 0.0) &&\n          (scale_factor > (jpeg_info.output_height/geometry_info.sigma)))\n        scale_factor=jpeg_info.output_height/geometry_info.sigma;\n      jpeg_info.scale_num=1U;\n      jpeg_info.scale_denom=(unsigned int) scale_factor;\n      jpeg_calc_output_dimensions(&jpeg_info);\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Scale factor: %.20g\",(double) scale_factor);\n    }\n#if (JPEG_LIB_VERSION >= 61) && defined(D_PROGRESSIVE_SUPPORTED)\n#if defined(D_LOSSLESS_SUPPORTED)\n  image->interlace=jpeg_info.process == JPROC_PROGRESSIVE ?\n    JPEGInterlace : NoInterlace;\n  image->compression=jpeg_info.process == JPROC_LOSSLESS ?\n    LosslessJPEGCompression : JPEGCompression;\n  if (jpeg_info.data_precision > 8)\n    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n      \"12-bit JPEG not supported. Reducing pixel data to 8 bits\",\"`%s'\",\n      image->filename);\n  if (jpeg_info.data_precision == 16)\n    jpeg_info.data_precision=12;\n#else\n  image->interlace=jpeg_info.progressive_mode != 0 ? JPEGInterlace :\n    NoInterlace;\n  image->compression=JPEGCompression;\n#endif\n#else\n  image->compression=JPEGCompression;\n  image->interlace=JPEGInterlace;\n#endif\n  option=GetImageOption(image_info,\"jpeg:colors\");\n  if (option != (const char *) NULL)\n    {\n      /*\n        Let the JPEG library quantize the image.\n      */\n      jpeg_info.quantize_colors=TRUE;\n      jpeg_info.desired_number_of_colors=(int) StringToUnsignedLong(option);\n    }\n  option=GetImageOption(image_info,\"jpeg:block-smoothing\");\n  if (option != (const char *) NULL)\n    jpeg_info.do_block_smoothing=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  dct_method=GetImageOption(image_info,\"jpeg:dct-method\");\n  if (dct_method != (const char *) NULL)\n    switch (*dct_method)\n    {\n      case 'D':\n      case 'd':\n      {\n        if (LocaleCompare(dct_method,\"default\") == 0)\n          jpeg_info.dct_method=JDCT_DEFAULT;\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        if (LocaleCompare(dct_method,\"fastest\") == 0)\n          jpeg_info.dct_method=JDCT_FASTEST;\n        if (LocaleCompare(dct_method,\"float\") == 0)\n          jpeg_info.dct_method=JDCT_FLOAT;\n        break;\n      }\n      case 'I':\n      case 'i':\n      {\n        if (LocaleCompare(dct_method,\"ifast\") == 0)\n          jpeg_info.dct_method=JDCT_IFAST;\n        if (LocaleCompare(dct_method,\"islow\") == 0)\n          jpeg_info.dct_method=JDCT_ISLOW;\n        break;\n      }\n    }\n  option=GetImageOption(image_info,\"jpeg:fancy-upsampling\");\n  if (option != (const char *) NULL)\n    jpeg_info.do_fancy_upsampling=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  jpeg_calc_output_dimensions(&jpeg_info);\n  image->columns=jpeg_info.output_width;\n  image->rows=jpeg_info.output_height;\n  image->depth=(size_t) jpeg_info.data_precision;\n  switch (jpeg_info.out_color_space)\n  {\n    case JCS_RGB:\n    default:\n    {\n      (void) SetImageColorspace(image,sRGBColorspace,exception);\n      break;\n    }\n    case JCS_GRAYSCALE:\n    {\n      (void) SetImageColorspace(image,GRAYColorspace,exception);\n      break;\n    }\n    case JCS_YCbCr:\n    {\n      (void) SetImageColorspace(image,YCbCrColorspace,exception);\n      break;\n    }\n    case JCS_CMYK:\n    {\n      (void) SetImageColorspace(image,CMYKColorspace,exception);\n      break;\n    }\n  }\n  if (IsITUFaxImage(image) != MagickFalse)\n    {\n      (void) SetImageColorspace(image,LabColorspace,exception);\n      jpeg_info.out_color_space=JCS_YCbCr;\n    }\n  option=GetImageOption(image_info,\"jpeg:colors\");\n  if (option != (const char *) NULL)\n    if (AcquireImageColormap(image,StringToUnsignedLong(option),exception) == MagickFalse)\n      {\n        jpeg_destroy_decompress(&jpeg_info);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n  if ((jpeg_info.output_components == 1) && (jpeg_info.quantize_colors == 0))\n    {\n      size_t\n        colors;\n\n      colors=(size_t) GetQuantumRange(image->depth)+1;\n      if (AcquireImageColormap(image,colors,exception) == MagickFalse)\n        {\n          jpeg_destroy_decompress(&jpeg_info);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n    }\n  if (image->debug != MagickFalse)\n    {\n      if (image->interlace != NoInterlace)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: progressive\");\n      else\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: nonprogressive\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Data precision: %d\",\n        (int) jpeg_info.data_precision);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %dx%d\",\n        (int) jpeg_info.output_width,(int) jpeg_info.output_height);\n    }\n  JPEGSetImageQuality(&jpeg_info,image);\n  JPEGSetImageSamplingFactor(&jpeg_info,image,exception);\n  (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n    jpeg_info.out_color_space);\n  (void) SetImageProperty(image,\"jpeg:colorspace\",value,exception);\n#if defined(D_ARITH_CODING_SUPPORTED)\n  if (jpeg_info.arith_code == TRUE)\n    (void) SetImageProperty(image,\"jpeg:coding\",\"arithmetic\",exception);\n#endif\n  if (image_info->ping != MagickFalse)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      return(DestroyImageList(image));\n    }\n  (void) jpeg_start_decompress(&jpeg_info);\n  if ((jpeg_info.output_components != 1) &&\n      (jpeg_info.output_components != 3) && (jpeg_info.output_components != 4))\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      ThrowReaderException(CorruptImageError,\"ImageTypeNotSupported\");\n    }\n  memory_info=AcquireVirtualMemory((size_t) image->columns,\n    jpeg_info.output_components*sizeof(*jpeg_pixels));\n  if (memory_info == (MemoryInfo *) NULL)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);\n  (void) memset(jpeg_pixels,0,image->columns*\n    jpeg_info.output_components*sizeof(*jpeg_pixels));\n  /*\n    Convert JPEG pixels to pixel packets.\n  */\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      if (memory_info != (MemoryInfo *) NULL)\n        memory_info=RelinquishVirtualMemory(memory_info);\n      jpeg_destroy_decompress(&jpeg_info);\n      (void) CloseBlob(image);\n      number_pixels=(MagickSizeType) image->columns*image->rows;\n      if (number_pixels != 0)\n        return(GetFirstImageInList(image));\n      return(DestroyImage(image));\n    }\n  if (jpeg_info.quantize_colors != 0)\n    {\n      image->colors=(size_t) jpeg_info.actual_number_of_colors;\n      if (jpeg_info.out_color_space == JCS_GRAYSCALE)\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=(double) ScaleCharToQuantum(\n            jpeg_info.colormap[0][i]);\n          image->colormap[i].green=image->colormap[i].red;\n          image->colormap[i].blue=image->colormap[i].red;\n          image->colormap[i].alpha=(MagickRealType) OpaqueAlpha;\n        }\n      else\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=(double) ScaleCharToQuantum(\n            jpeg_info.colormap[0][i]);\n          image->colormap[i].green=(double) ScaleCharToQuantum(\n            jpeg_info.colormap[1][i]);\n          image->colormap[i].blue=(double) ScaleCharToQuantum(\n            jpeg_info.colormap[2][i]);\n          image->colormap[i].alpha=(MagickRealType) OpaqueAlpha;\n        }\n    }\n  scanline[0]=(JSAMPROW) jpeg_pixels;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (jpeg_read_scanlines(&jpeg_info,scanline,1) != 1)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"SkipToSyncByte\",\"`%s'\",image->filename);\n        continue;\n      }\n    p=jpeg_pixels;\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    if (jpeg_info.data_precision > 8)\n      {\n        unsigned short\n          scale;\n\n        scale=65535/(unsigned short) GetQuantumRange((size_t)\n          jpeg_info.data_precision);\n        if (jpeg_info.output_components == 1)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            ssize_t\n              pixel;\n\n            pixel=(ssize_t) (scale*GETJSAMPLE(*p));\n            index=(Quantum) ConstrainColormapIndex(image,pixel,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            p++;\n            q+=GetPixelChannels(image);\n          }\n        else\n          if (image->colorspace != CMYKColorspace)\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(image,ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelGreen(image,ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelBlue(image,ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelAlpha(image,OpaqueAlpha,q);\n              q+=GetPixelChannels(image);\n            }\n          else\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelCyan(image,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelMagenta(image,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelYellow(image,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelBlack(image,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelAlpha(image,OpaqueAlpha,q);\n              q+=GetPixelChannels(image);\n            }\n      }\n    else\n      if (jpeg_info.output_components == 1)\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          ssize_t\n            pixel;\n\n          pixel=(ssize_t) GETJSAMPLE(*p);\n          index=(Quantum) ConstrainColormapIndex(image,pixel,exception);\n          SetPixelIndex(image,index,q);\n          SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n          p++;\n          q+=GetPixelChannels(image);\n        }\n      else\n        if (image->colorspace != CMYKColorspace)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)),q);\n            SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)),q);\n            SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            q+=GetPixelChannels(image);\n          }\n        else\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(image,QuantumRange-ScaleCharToQuantum(\n              (unsigned char) GETJSAMPLE(*p++)),q);\n            SetPixelMagenta(image,QuantumRange-ScaleCharToQuantum(\n              (unsigned char) GETJSAMPLE(*p++)),q);\n            SetPixelYellow(image,QuantumRange-ScaleCharToQuantum(\n              (unsigned char) GETJSAMPLE(*p++)),q);\n            SetPixelBlack(image,QuantumRange-ScaleCharToQuantum(\n              (unsigned char) GETJSAMPLE(*p++)),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            q+=GetPixelChannels(image);\n          }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      {\n        jpeg_abort_decompress(&jpeg_info);\n        break;\n      }\n  }\n  if (status != MagickFalse)\n    {\n      error_manager.finished=MagickTrue;\n      if (setjmp(error_manager.error_recovery) == 0)\n        (void) jpeg_finish_decompress(&jpeg_info);\n    }\n  /*\n    Free jpeg resources.\n  */\n  jpeg_destroy_decompress(&jpeg_info);\n  memory_info=RelinquishVirtualMemory(memory_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r J P E G I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterJPEGImage() adds properties for the JPEG image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterJPEGImage method is:\n%\n%      size_t RegisterJPEGImage(void)\n%\n*/\nModuleExport size_t RegisterJPEGImage(void)\n{\n#define JPEGDescription \"Joint Photographic Experts Group JFIF format\"\n#define JPEGStringify(macro_or_string)  JPEGStringifyArg(macro_or_string)\n#define JPEGStringifyArg(contents)  #contents\n\n  char\n    version[MagickPathExtent];\n\n  MagickInfo\n    *entry;\n\n  *version='\\0';\n#if defined(LIBJPEG_TURBO_VERSION)\n  (void) CopyMagickString(version,\"libjpeg-turbo \" JPEGStringify(\n    LIBJPEG_TURBO_VERSION),MagickPathExtent);\n#elif defined(JPEG_LIB_VERSION)\n  (void) FormatLocaleString(version,MagickPathExtent,\"libjpeg %d\",\n    JPEG_LIB_VERSION);\n#endif\n  entry=AcquireMagickInfo(\"JPEG\",\"JPE\",JPEGDescription);\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsJPEG;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"JPEG\",\"JPEG\",JPEGDescription);\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsJPEG;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"JPEG\",\"JPG\",JPEGDescription);\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"JPEG\",\"JPS\",JPEGDescription);\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"JPEG\",\"PJPEG\",JPEGDescription);\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r J P E G I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterJPEGImage() removes format registrations made by the\n%  JPEG module from the list of supported formats.\n%\n%  The format of the UnregisterJPEGImage method is:\n%\n%      UnregisterJPEGImage(void)\n%\n*/\nModuleExport void UnregisterJPEGImage(void)\n{\n  (void) UnregisterMagickInfo(\"PJPG\");\n  (void) UnregisterMagickInfo(\"JPS\");\n  (void) UnregisterMagickInfo(\"JPG\");\n  (void) UnregisterMagickInfo(\"JPEG\");\n  (void) UnregisterMagickInfo(\"JPE\");\n}\n\f\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  W r i t e J P E G I m a g e                                                %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteJPEGImage() writes a JPEG image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the WriteJPEGImage method is:\n%\n%      MagickBooleanType WriteJPEGImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o jpeg_image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic QuantizationTable *DestroyQuantizationTable(QuantizationTable *table)\n{\n  assert(table != (QuantizationTable *) NULL);\n  if (table->slot != (char *) NULL)\n    table->slot=DestroyString(table->slot);\n  if (table->description != (char *) NULL)\n    table->description=DestroyString(table->description);\n  if (table->levels != (unsigned int *) NULL)\n    table->levels=(unsigned int *) RelinquishMagickMemory(table->levels);\n  table=(QuantizationTable *) RelinquishMagickMemory(table);\n  return(table);\n}\n\nstatic boolean EmptyOutputBuffer(j_compress_ptr cinfo)\n{\n  DestinationManager\n    *destination;\n\n  destination=(DestinationManager *) cinfo->dest;\n  destination->manager.free_in_buffer=(size_t) WriteBlob(destination->image,\n    MagickMinBufferExtent,destination->buffer);\n  if (destination->manager.free_in_buffer != MagickMinBufferExtent)\n    ERREXIT(cinfo,JERR_FILE_WRITE);\n  destination->manager.next_output_byte=destination->buffer;\n  return(TRUE);\n}\n\nstatic QuantizationTable *GetQuantizationTable(const char *filename,\n  const char *slot,ExceptionInfo *exception)\n{\n  char\n    *p,\n    *xml;\n\n  const char\n    *attribute,\n    *content;\n\n  double\n    value;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    j;\n\n  QuantizationTable\n    *table;\n\n  size_t\n    length;\n\n  XMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\n\n  (void) LogMagickEvent(ConfigureEvent,GetMagickModule(),\n    \"Loading quantization tables \\\"%s\\\" ...\",filename);\n  table=(QuantizationTable *) NULL;\n  xml=FileToString(filename,~0UL,exception);\n  if (xml == (char *) NULL)\n    return(table);\n  quantization_tables=NewXMLTree(xml,exception);\n  if (quantization_tables == (XMLTreeInfo *) NULL)\n    {\n      xml=DestroyString(xml);\n      return(table);\n    }\n  for (table_iterator=GetXMLTreeChild(quantization_tables,\"table\");\n       table_iterator != (XMLTreeInfo *) NULL;\n       table_iterator=GetNextXMLTreeTag(table_iterator))\n  {\n    attribute=GetXMLTreeAttribute(table_iterator,\"slot\");\n    if ((attribute != (char *) NULL) && (LocaleCompare(slot,attribute) == 0))\n      break;\n    attribute=GetXMLTreeAttribute(table_iterator,\"alias\");\n    if ((attribute != (char *) NULL) && (LocaleCompare(slot,attribute) == 0))\n      break;\n  }\n  if (table_iterator == (XMLTreeInfo *) NULL)\n    {\n      xml=DestroyString(xml);\n      return(table);\n    }\n  description=GetXMLTreeChild(table_iterator,\"description\");\n  if (description == (XMLTreeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingElement\",\"<description>, slot \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  levels=GetXMLTreeChild(table_iterator,\"levels\");\n  if (levels == (XMLTreeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingElement\",\"<levels>, slot \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table=(QuantizationTable *) AcquireCriticalMemory(sizeof(*table));\n  table->slot=(char *) NULL;\n  table->description=(char *) NULL;\n  table->levels=(unsigned int *) NULL;\n  attribute=GetXMLTreeAttribute(table_iterator,\"slot\");\n  if (attribute != (char *) NULL)\n    table->slot=ConstantString(attribute);\n  content=GetXMLTreeContent(description);\n  if (content != (char *) NULL)\n    table->description=ConstantString(content);\n  attribute=GetXMLTreeAttribute(levels,\"width\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\",\"<levels width>, slot \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table->width=StringToUnsignedLong(attribute);\n  if (table->width == 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n       \"XmlInvalidAttribute\",\"<levels width>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  attribute=GetXMLTreeAttribute(levels,\"height\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\",\"<levels height>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table->height=StringToUnsignedLong(attribute);\n  if (table->height == 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidAttribute\",\"<levels height>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  attribute=GetXMLTreeAttribute(levels,\"divisor\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\",\"<levels divisor>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table->divisor=InterpretLocaleValue(attribute,(char **) NULL);\n  if (table->divisor == 0.0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidAttribute\",\"<levels divisor>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  content=GetXMLTreeContent(levels);\n  if (content == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingContent\",\"<levels>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  length=(size_t) table->width*table->height;\n  if (length < 64)\n    length=64;\n  table->levels=(unsigned int *) AcquireQuantumMemory(length,\n    sizeof(*table->levels));\n  if (table->levels == (unsigned int *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\n      \"UnableToAcquireQuantizationTable\");\n  for (i=0; i < (ssize_t) (table->width*table->height); i++)\n  {\n    table->levels[i]=(unsigned int) (InterpretLocaleValue(content,&p)/\n      table->divisor+0.5);\n    while (isspace((int) ((unsigned char) *p)) != 0)\n      p++;\n    if (*p == ',')\n      p++;\n    content=p;\n  }\n  value=InterpretLocaleValue(content,&p);\n  (void) value;\n  if (p != content)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidContent\",\"<level> too many values, table \\\"%s\\\"\",slot);\n     quantization_tables=DestroyXMLTree(quantization_tables);\n     table=DestroyQuantizationTable(table);\n     xml=DestroyString(xml);\n     return(table);\n   }\n  for (j=i; j < 64; j++)\n    table->levels[j]=table->levels[j-1];\n  quantization_tables=DestroyXMLTree(quantization_tables);\n  xml=DestroyString(xml);\n  return(table);\n}\n\nstatic void InitializeDestination(j_compress_ptr cinfo)\n{\n  DestinationManager\n    *destination;\n\n  destination=(DestinationManager *) cinfo->dest;\n  destination->buffer=(JOCTET *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,MagickMinBufferExtent*sizeof(JOCTET));\n  destination->manager.next_output_byte=destination->buffer;\n  destination->manager.free_in_buffer=MagickMinBufferExtent;\n}\n\nstatic void TerminateDestination(j_compress_ptr cinfo)\n{\n  DestinationManager\n    *destination;\n\n  destination=(DestinationManager *) cinfo->dest;\n  if ((MagickMinBufferExtent-(int) destination->manager.free_in_buffer) > 0)\n    {\n      ssize_t\n        count;\n\n      count=WriteBlob(destination->image,MagickMinBufferExtent-\n        destination->manager.free_in_buffer,destination->buffer);\n      if (count != (ssize_t)\n          (MagickMinBufferExtent-destination->manager.free_in_buffer))\n        ERREXIT(cinfo,JERR_FILE_WRITE);\n    }\n}\n\nstatic void WriteProfile(j_compress_ptr jpeg_info,Image *image,\n  ExceptionInfo *exception)\n{\n  const char\n    *name;\n\n  const StringInfo\n    *profile;\n\n  MagickBooleanType\n    iptc;\n\n  register ssize_t\n    i;\n\n  size_t\n    length,\n    tag_length;\n\n  StringInfo\n    *custom_profile;\n\n  /*\n    Save image profile as a APP marker.\n  */\n  iptc=MagickFalse;\n  custom_profile=AcquireStringInfo(65535L);\n  ResetImageProfileIterator(image);\n  for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n  {\n    profile=GetImageProfile(image,name);\n    length=GetStringInfoLength(profile);\n    if (LocaleNCompare(name,\"APP\",3) == 0)\n      {\n        int\n          id;\n\n        id=JPEG_APP0+StringToInteger(name+3);\n        for (i=0; i < (ssize_t) length; i+=65533L)\n           jpeg_write_marker(jpeg_info,id,GetStringInfoDatum(profile)+i,\n             (unsigned int) MagickMin(length-i,65533));\n      }\n    if (LocaleCompare(name,\"EXIF\") == 0)\n      {\n        length=GetStringInfoLength(profile);\n        if (length > 65533L)\n          {\n            (void) ThrowMagickException(exception,GetMagickModule(),\n              CoderWarning,\"ExifProfileSizeExceedsLimit\",\"`%s'\",\n              image->filename);\n            length=65533L;\n          }\n        jpeg_write_marker(jpeg_info,XML_MARKER,GetStringInfoDatum(profile),\n          (unsigned int) length);\n      }\n    if (LocaleCompare(name,\"ICC\") == 0)\n      {\n        register unsigned char\n          *p;\n\n        tag_length=strlen(ICC_PROFILE);\n        p=GetStringInfoDatum(custom_profile);\n        (void) memcpy(p,ICC_PROFILE,tag_length);\n        p[tag_length]='\\0';\n        for (i=0; i < (ssize_t) GetStringInfoLength(profile); i+=65519L)\n        {\n          length=MagickMin(GetStringInfoLength(profile)-i,65519L);\n          p[12]=(unsigned char) ((i/65519L)+1);\n          p[13]=(unsigned char) (GetStringInfoLength(profile)/65519L+1);\n          (void) memcpy(p+tag_length+3,GetStringInfoDatum(profile)+i,\n            length);\n          jpeg_write_marker(jpeg_info,ICC_MARKER,GetStringInfoDatum(\n            custom_profile),(unsigned int) (length+tag_length+3));\n        }\n      }\n    if (((LocaleCompare(name,\"IPTC\") == 0) ||\n        (LocaleCompare(name,\"8BIM\") == 0)) && (iptc == MagickFalse))\n      {\n        register unsigned char\n          *p;\n\n        size_t\n          roundup;\n\n        iptc=MagickTrue;\n        p=GetStringInfoDatum(custom_profile);\n        for (i=0; i < (ssize_t) GetStringInfoLength(profile); i+=65500L)\n        {\n          length=MagickMin(GetStringInfoLength(profile)-i,65500L);\n          roundup=(size_t) (length & 0x01);\n          if (LocaleNCompare((char *) GetStringInfoDatum(profile),\"8BIM\",4) == 0)\n            {\n              (void) memcpy(p,\"Photoshop 3.0 \",14);\n              tag_length=14;\n            }\n          else\n            {\n              (void) memcpy(p,\"Photoshop 3.0 8BIM\\04\\04\\0\\0\\0\\0\",24);\n              tag_length=26;\n              p[24]=(unsigned char) (length >> 8);\n              p[25]=(unsigned char) (length & 0xff);\n            }\n          p[13]=0x00;\n          (void) memcpy(p+tag_length,GetStringInfoDatum(profile)+i,length);\n          if (roundup != 0)\n            p[length+tag_length]='\\0';\n          jpeg_write_marker(jpeg_info,IPTC_MARKER,GetStringInfoDatum(\n            custom_profile),(unsigned int) (length+tag_length+roundup));\n        }\n      }\n   if ((LocaleCompare(name,\"XMP\") == 0) &&\n       (GetStringInfoLength(profile) <= 65502))\n      {\n        StringInfo\n          *xmp_profile;\n\n        /*\n          Add namespace to XMP profile.\n        */\n        xmp_profile=StringToStringInfo(xmp_namespace);\n        if (xmp_profile != (StringInfo *) NULL)\n          {\n            if (profile != (StringInfo *) NULL)\n              ConcatenateStringInfo(xmp_profile,profile);\n            GetStringInfoDatum(xmp_profile)[XmpNamespaceExtent]='\\0';\n            for (i=0; i < (ssize_t) GetStringInfoLength(xmp_profile); i+=65533L)\n            {\n              length=MagickMin(GetStringInfoLength(xmp_profile)-i,65533L);\n              jpeg_write_marker(jpeg_info,XML_MARKER,\n                GetStringInfoDatum(xmp_profile)+i,(unsigned int) length);\n            }\n            xmp_profile=DestroyStringInfo(xmp_profile);\n          }\n      }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"%s profile: %.20g bytes\",name,(double) GetStringInfoLength(profile));\n    name=GetNextImageProfile(image);\n  }\n  custom_profile=DestroyStringInfo(custom_profile);\n}\n\nstatic void JPEGDestinationManager(j_compress_ptr cinfo,Image * image)\n{\n  DestinationManager\n    *destination;\n\n  cinfo->dest=(struct jpeg_destination_mgr *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,sizeof(DestinationManager));\n  destination=(DestinationManager *) cinfo->dest;\n  destination->manager.init_destination=InitializeDestination;\n  destination->manager.empty_output_buffer=EmptyOutputBuffer;\n  destination->manager.term_destination=TerminateDestination;\n  destination->image=image;\n}\n\nstatic char **SamplingFactorToList(const char *text)\n{\n  char\n    **textlist;\n\n  register char\n    *q;\n\n  register const char\n    *p;\n\n  register ssize_t\n    i;\n\n  if (text == (char *) NULL)\n    return((char **) NULL);\n  /*\n    Convert string to an ASCII list.\n  */\n  textlist=(char **) AcquireQuantumMemory((size_t) MAX_COMPONENTS,\n    sizeof(*textlist));\n  if (textlist == (char **) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"UnableToConvertText\");\n  p=text;\n  for (i=0; i < (ssize_t) MAX_COMPONENTS; i++)\n  {\n    for (q=(char *) p; *q != '\\0'; q++)\n      if (*q == ',')\n        break;\n    textlist[i]=(char *) AcquireQuantumMemory((size_t) (q-p)+MagickPathExtent,\n      sizeof(*textlist[i]));\n    if (textlist[i] == (char *) NULL)\n      ThrowFatalException(ResourceLimitFatalError,\"UnableToConvertText\");\n    (void) CopyMagickString(textlist[i],p,(size_t) (q-p+1));\n    if (*q == '\\r')\n      q++;\n    if (*q == '\\0')\n      break;\n    p=q+1;\n  }\n  for (i++; i < (ssize_t) MAX_COMPONENTS; i++)\n    textlist[i]=ConstantString(\"1x1\");\n  return(textlist);\n}\n\nstatic MagickBooleanType WriteJPEGImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  const char\n    *dct_method,\n    *option,\n    *sampling_factor,\n    *value;\n\n  ErrorManager\n    error_manager;\n\n  Image\n    *volatile volatile_image;\n\n  int\n    colorspace,\n    quality;\n\n  JSAMPLE\n    *volatile jpeg_pixels;\n\n  JSAMPROW\n    scanline[1];\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *memory_info;\n\n  register JSAMPLE\n    *q;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  struct jpeg_compress_struct\n    jpeg_info;\n\n  struct jpeg_error_mgr\n    jpeg_error;\n\n  unsigned short\n    scale;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if ((LocaleCompare(image_info->magick,\"JPS\") == 0) &&\n      (image->next != (Image *) NULL))\n    image=AppendImages(image,MagickFalse,exception);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Initialize JPEG parameters.\n  */\n  (void) memset(&error_manager,0,sizeof(error_manager));\n  (void) memset(&jpeg_info,0,sizeof(jpeg_info));\n  (void) memset(&jpeg_error,0,sizeof(jpeg_error));\n  volatile_image=image;\n  jpeg_info.client_data=(void *) volatile_image;\n  jpeg_info.err=jpeg_std_error(&jpeg_error);\n  jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;\n  jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;\n  error_manager.exception=exception;\n  error_manager.image=volatile_image;\n  memory_info=(MemoryInfo *) NULL;\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      jpeg_destroy_compress(&jpeg_info);\n      (void) CloseBlob(volatile_image);\n      return(MagickFalse);\n    }\n  jpeg_info.client_data=(void *) &error_manager;\n  jpeg_create_compress(&jpeg_info);\n  JPEGDestinationManager(&jpeg_info,image);\n  if ((image->columns != (unsigned int) image->columns) ||\n      (image->rows != (unsigned int) image->rows))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  jpeg_info.image_width=(unsigned int) image->columns;\n  jpeg_info.image_height=(unsigned int) image->rows;\n  jpeg_info.input_components=3;\n  jpeg_info.data_precision=8;\n  jpeg_info.in_color_space=JCS_RGB;\n  switch (image->colorspace)\n  {\n    case CMYKColorspace:\n    {\n      jpeg_info.input_components=4;\n      jpeg_info.in_color_space=JCS_CMYK;\n      break;\n    }\n    case YCbCrColorspace:\n    case Rec601YCbCrColorspace:\n    case Rec709YCbCrColorspace:\n    {\n      jpeg_info.in_color_space=JCS_YCbCr;\n      break;\n    }\n    case LinearGRAYColorspace:\n    case GRAYColorspace:\n    {\n      if (image_info->type == TrueColorType)\n        break;\n      jpeg_info.input_components=1;\n      jpeg_info.in_color_space=JCS_GRAYSCALE;\n      break;\n    }\n    default:\n    {\n      (void) TransformImageColorspace(image,sRGBColorspace,exception);\n      if (image_info->type == TrueColorType)\n        break;\n      if (SetImageGray(image,exception) != MagickFalse)\n        {\n          jpeg_info.input_components=1;\n          jpeg_info.in_color_space=JCS_GRAYSCALE;\n        }\n      break;\n    }\n  }\n  jpeg_set_defaults(&jpeg_info);\n  if (jpeg_info.in_color_space == JCS_CMYK)\n    jpeg_set_colorspace(&jpeg_info,JCS_YCCK);\n  if ((jpeg_info.data_precision != 12) && (image->depth <= 8))\n    jpeg_info.data_precision=8;\n  else\n    jpeg_info.data_precision=BITS_IN_JSAMPLE;\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Image resolution: %.20g,%.20g\",image->resolution.x,image->resolution.y);\n  if ((image->resolution.x != 0.0) && (image->resolution.y != 0.0))\n    {\n      /*\n        Set image resolution.\n      */\n      jpeg_info.write_JFIF_header=TRUE;\n      jpeg_info.X_density=(UINT16) image->resolution.x;\n      jpeg_info.Y_density=(UINT16) image->resolution.y;\n      /*\n        Set image resolution units.\n      */\n      if (image->units == PixelsPerInchResolution)\n        jpeg_info.density_unit=(UINT8) 1;\n      if (image->units == PixelsPerCentimeterResolution)\n        jpeg_info.density_unit=(UINT8) 2;\n    }\n  dct_method=GetImageOption(image_info,\"jpeg:dct-method\");\n  if (dct_method != (const char *) NULL)\n    switch (*dct_method)\n    {\n      case 'D':\n      case 'd':\n      {\n        if (LocaleCompare(dct_method,\"default\") == 0)\n          jpeg_info.dct_method=JDCT_DEFAULT;\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        if (LocaleCompare(dct_method,\"fastest\") == 0)\n          jpeg_info.dct_method=JDCT_FASTEST;\n        if (LocaleCompare(dct_method,\"float\") == 0)\n          jpeg_info.dct_method=JDCT_FLOAT;\n        break;\n      }\n      case 'I':\n      case 'i':\n      {\n        if (LocaleCompare(dct_method,\"ifast\") == 0)\n          jpeg_info.dct_method=JDCT_IFAST;\n        if (LocaleCompare(dct_method,\"islow\") == 0)\n          jpeg_info.dct_method=JDCT_ISLOW;\n        break;\n      }\n    }\n  option=GetImageOption(image_info,\"jpeg:optimize-coding\");\n  if (option != (const char *) NULL)\n    jpeg_info.optimize_coding=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  else\n    {\n      MagickSizeType\n        length;\n\n      length=(MagickSizeType) jpeg_info.input_components*image->columns*\n        image->rows*sizeof(JSAMPLE);\n      if (length == (MagickSizeType) ((size_t) length))\n        {\n          /*\n            Perform optimization only if available memory resources permit it.\n          */\n          status=AcquireMagickResource(MemoryResource,length);\n          if (status != MagickFalse)\n            RelinquishMagickResource(MemoryResource,length);\n          jpeg_info.optimize_coding=status == MagickFalse ? FALSE : TRUE;\n        }\n    }\n#if defined(C_ARITH_CODING_SUPPORTED)\n  option=GetImageOption(image_info,\"jpeg:arithmetic-coding\");\n  if (IsStringTrue(option) != MagickFalse)\n    {\n      jpeg_info.arith_code=TRUE;\n      jpeg_info.optimize_coding=FALSE; // Not supported.\n    }\n#endif\n#if (JPEG_LIB_VERSION >= 61) && defined(C_PROGRESSIVE_SUPPORTED)\n  if ((LocaleCompare(image_info->magick,\"PJPEG\") == 0) ||\n      (image_info->interlace != NoInterlace))\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: progressive\");\n      jpeg_simple_progression(&jpeg_info);\n    }\n  else\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"Interlace: non-progressive\");\n#else\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Interlace: nonprogressive\");\n#endif\n  quality=92;\n  if ((image_info->compression != LosslessJPEGCompression) &&\n      (image->quality <= 100))\n    {\n      if (image->quality != UndefinedCompressionQuality)\n        quality=(int) image->quality;\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Quality: %.20g\",\n          (double) image->quality);\n    }\n  else\n    {\n#if !defined(C_LOSSLESS_SUPPORTED)\n      quality=100;\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Quality: 100\");\n#else\n      if (image->quality < 100)\n        (void) ThrowMagickException(exception,GetMagickModule(),CoderWarning,\n          \"LosslessToLossyJPEGConversion\",\"`%s'\",image->filename);\n      else\n        {\n          int\n            point_transform,\n            predictor;\n\n          predictor=image->quality/100;  /* range 1-7 */\n          point_transform=image->quality % 20;  /* range 0-15 */\n          jpeg_simple_lossless(&jpeg_info,predictor,point_transform);\n          if (image->debug != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Compression: lossless\");\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Predictor: %d\",predictor);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Point Transform: %d\",point_transform);\n            }\n        }\n#endif\n    }\n  option=GetImageOption(image_info,\"jpeg:extent\");\n  if (option != (const char *) NULL)\n    {\n      Image\n        *jpeg_image;\n\n      ImageInfo\n        *extent_info;\n\n      extent_info=CloneImageInfo(image_info);\n      extent_info->blob=NULL;\n      jpeg_image=CloneImage(image,0,0,MagickTrue,exception);\n      if (jpeg_image != (Image *) NULL)\n        {\n          MagickSizeType\n            extent;\n\n          size_t\n            maximum,\n            minimum;\n\n          /*\n            Search for compression quality that does not exceed image extent.\n          */\n          extent_info->quality=0;\n          extent=(MagickSizeType) SiPrefixToDoubleInterval(option,100.0);\n          (void) DeleteImageOption(extent_info,\"jpeg:extent\");\n          (void) DeleteImageArtifact(jpeg_image,\"jpeg:extent\");\n          maximum=image_info->quality;\n          if (maximum < 2)\n            maximum=101;\n          for (minimum=2; minimum < maximum; )\n          {\n            (void) AcquireUniqueFilename(jpeg_image->filename);\n            jpeg_image->quality=minimum+(maximum-minimum+1)/2;\n            status=WriteJPEGImage(extent_info,jpeg_image,exception);\n            if (GetBlobSize(jpeg_image) <= extent)\n              minimum=jpeg_image->quality+1;\n            else\n              maximum=jpeg_image->quality-1;\n            (void) RelinquishUniqueFileResource(jpeg_image->filename);\n          }\n          quality=(int) minimum-1;\n          jpeg_image=DestroyImage(jpeg_image);\n        }\n      extent_info=DestroyImageInfo(extent_info);\n    }\n  jpeg_set_quality(&jpeg_info,quality,TRUE);\n  if ((dct_method == (const char *) NULL) && (quality <= 90))\n    jpeg_info.dct_method=JDCT_IFAST;\n#if (JPEG_LIB_VERSION >= 70)\n  option=GetImageOption(image_info,\"quality\");\n  if (option != (const char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      int\n        flags;\n\n      /*\n        Set quality scaling for luminance and chrominance separately.\n      */\n      flags=ParseGeometry(option,&geometry_info);\n      if (((flags & RhoValue) != 0) && ((flags & SigmaValue) != 0))\n        {\n          jpeg_info.q_scale_factor[0]=jpeg_quality_scaling((int)\n            (geometry_info.rho+0.5));\n          jpeg_info.q_scale_factor[1]=jpeg_quality_scaling((int)\n            (geometry_info.sigma+0.5));\n          jpeg_default_qtables(&jpeg_info,TRUE);\n        }\n    }\n#endif\n  colorspace=jpeg_info.in_color_space;\n  value=GetImageOption(image_info,\"jpeg:colorspace\");\n  if (value == (char *) NULL)\n    value=GetImageProperty(image,\"jpeg:colorspace\",exception);\n  if (value != (char *) NULL)\n    colorspace=StringToInteger(value);\n  sampling_factor=(const char *) NULL;\n  if ((J_COLOR_SPACE) colorspace == jpeg_info.in_color_space)\n    {\n      value=GetImageOption(image_info,\"jpeg:sampling-factor\");\n      if (value == (char *) NULL)\n        value=GetImageProperty(image,\"jpeg:sampling-factor\",exception);\n      if (value != (char *) NULL)\n        {\n          sampling_factor=value;\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Input sampling-factors=%s\",sampling_factor);\n        }\n    }\n  value=GetImageOption(image_info,\"jpeg:sampling-factor\");\n  if (image_info->sampling_factor != (char *) NULL)\n    sampling_factor=image_info->sampling_factor;\n  if (sampling_factor == (const char *) NULL)\n    {\n      if (quality >= 90)\n        for (i=0; i < MAX_COMPONENTS; i++)\n        {\n          jpeg_info.comp_info[i].h_samp_factor=1;\n          jpeg_info.comp_info[i].v_samp_factor=1;\n        }\n    }\n  else\n    {\n      char\n        **factors;\n\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      /*\n        Set sampling factor.\n      */\n      i=0;\n      factors=SamplingFactorToList(sampling_factor);\n      if (factors != (char **) NULL)\n        {\n          for (i=0; i < MAX_COMPONENTS; i++)\n          {\n            if (factors[i] == (char *) NULL)\n              break;\n            flags=ParseGeometry(factors[i],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=geometry_info.rho;\n            jpeg_info.comp_info[i].h_samp_factor=(int) geometry_info.rho;\n            jpeg_info.comp_info[i].v_samp_factor=(int) geometry_info.sigma;\n            factors[i]=(char *) RelinquishMagickMemory(factors[i]);\n          }\n          factors=(char **) RelinquishMagickMemory(factors);\n        }\n      for ( ; i < MAX_COMPONENTS; i++)\n      {\n        jpeg_info.comp_info[i].h_samp_factor=1;\n        jpeg_info.comp_info[i].v_samp_factor=1;\n      }\n    }\n  option=GetImageOption(image_info,\"jpeg:q-table\");\n  if (option != (const char *) NULL)\n    {\n      QuantizationTable\n        *table;\n\n      /*\n        Custom quantization tables.\n      */\n      table=GetQuantizationTable(option,\"0\",exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=0; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=0;\n          jpeg_add_quant_table(&jpeg_info,0,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n      table=GetQuantizationTable(option,\"1\",exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=1; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=1;\n          jpeg_add_quant_table(&jpeg_info,1,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n      table=GetQuantizationTable(option,\"2\",exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=2; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=2;\n          jpeg_add_quant_table(&jpeg_info,2,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n      table=GetQuantizationTable(option,\"3\",exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=3; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=3;\n          jpeg_add_quant_table(&jpeg_info,3,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n    }\n  jpeg_start_compress(&jpeg_info,TRUE);\n  if (image->debug != MagickFalse)\n    {\n      if (image->storage_class == PseudoClass)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Storage class: PseudoClass\");\n      else\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Storage class: DirectClass\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Depth: %.20g\",\n        (double) image->depth);\n      if (image->colors != 0)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Number of colors: %.20g\",(double) image->colors);\n      else\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Number of colors: unspecified\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"JPEG data precision: %d\",(int) jpeg_info.data_precision);\n      switch (image->colorspace)\n      {\n        case CMYKColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Storage class: DirectClass\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: CMYK\");\n          break;\n        }\n        case YCbCrColorspace:\n        case Rec601YCbCrColorspace:\n        case Rec709YCbCrColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: YCbCr\");\n          break;\n        }\n        default:\n          break;\n      }\n      switch (image->colorspace)\n      {\n        case CMYKColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: CMYK\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor,\n            jpeg_info.comp_info[3].h_samp_factor,\n            jpeg_info.comp_info[3].v_samp_factor);\n          break;\n        }\n        case GRAYColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: GRAY\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d\",jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor);\n          break;\n        }\n        case sRGBColorspace:\n        case RGBColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Image colorspace is RGB\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor);\n          break;\n        }\n        case YCbCrColorspace:\n        case Rec601YCbCrColorspace:\n        case Rec709YCbCrColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: YCbCr\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor);\n          break;\n        }\n        default:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: %d\",\n            image->colorspace);\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor,\n            jpeg_info.comp_info[3].h_samp_factor,\n            jpeg_info.comp_info[3].v_samp_factor);\n          break;\n        }\n      }\n    }\n  /*\n    Write JPEG profiles.\n  */\n  value=GetImageProperty(image,\"comment\",exception);\n  if (value != (char *) NULL)\n    for (i=0; i < (ssize_t) strlen(value); i+=65533L)\n      jpeg_write_marker(&jpeg_info,JPEG_COM,(unsigned char *) value+i,\n        (unsigned int) MagickMin((size_t) strlen(value+i),65533L));\n  if (image->profiles != (void *) NULL)\n    WriteProfile(&jpeg_info,image,exception);\n  /*\n    Convert MIFF to JPEG raster pixels.\n  */\n  memory_info=AcquireVirtualMemory((size_t) image->columns,\n    jpeg_info.input_components*sizeof(*jpeg_pixels));\n  if (memory_info == (MemoryInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      jpeg_destroy_compress(&jpeg_info);\n      if (memory_info != (MemoryInfo *) NULL)\n        memory_info=RelinquishVirtualMemory(memory_info);\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  scanline[0]=(JSAMPROW) jpeg_pixels;\n  scale=65535/(unsigned short) GetQuantumRange((size_t)\n    jpeg_info.data_precision);\n  if (scale == 0)\n    scale=1;\n  if (jpeg_info.data_precision <= 8)\n    {\n      if ((jpeg_info.in_color_space == JCS_RGB) ||\n          (jpeg_info.in_color_space == JCS_YCbCr))\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=jpeg_pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(JSAMPLE) ScaleQuantumToChar(GetPixelRed(image,p));\n            *q++=(JSAMPLE) ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=(JSAMPLE) ScaleQuantumToChar(GetPixelBlue(image,p));\n            p+=GetPixelChannels(image);\n          }\n          (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n      else\n        if (jpeg_info.in_color_space == JCS_GRAYSCALE)\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            register const Quantum\n              *p;\n\n            register ssize_t\n              x;\n\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            q=jpeg_pixels;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              *q++=(JSAMPLE) ScaleQuantumToChar(ClampToQuantum(GetPixelLuma(\n                image,p)));\n              p+=GetPixelChannels(image);\n            }\n            (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n            status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n            }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            register const Quantum\n              *p;\n\n            register ssize_t\n              x;\n\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            q=jpeg_pixels;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              /*\n                Convert DirectClass packets to contiguous CMYK scanlines.\n              */\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelCyan(image,p))));\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelMagenta(image,p))));\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelYellow(image,p))));\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelBlack(image,p))));\n              p+=GetPixelChannels(image);\n            }\n            (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n            status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n    }\n  else\n    if (jpeg_info.in_color_space == JCS_GRAYSCALE)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        register const Quantum\n          *p;\n\n        register ssize_t\n          x;\n\n        p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n        if (p == (const Quantum *) NULL)\n          break;\n        q=jpeg_pixels;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          *q++=(JSAMPLE) (ScaleQuantumToShort(ClampToQuantum(GetPixelLuma(image,\n            p)))/scale);\n          p+=GetPixelChannels(image);\n        }\n        (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n        status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n    else\n      if ((jpeg_info.in_color_space == JCS_RGB) ||\n          (jpeg_info.in_color_space == JCS_YCbCr))\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=jpeg_pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(JSAMPLE) (ScaleQuantumToShort(GetPixelRed(image,p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(GetPixelGreen(image,p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(GetPixelBlue(image,p))/scale);\n            p+=GetPixelChannels(image);\n          }\n          (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n      else\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=jpeg_pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            /*\n              Convert DirectClass packets to contiguous CMYK scanlines.\n            */\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-GetPixelRed(\n              image,p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-GetPixelGreen(\n              image,p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-GetPixelBlue(\n              image,p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-GetPixelBlack(\n              image,p))/scale);\n            p+=GetPixelChannels(image);\n          }\n          (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n  if (y == (ssize_t) image->rows)\n    jpeg_finish_compress(&jpeg_info);\n  /*\n    Relinquish resources.\n  */\n  jpeg_destroy_compress(&jpeg_info);\n  memory_info=RelinquishVirtualMemory(memory_info);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n#endif\n"], "filenames": ["ChangeLog", "coders/jpeg.c"], "buggy_code_start_loc": [0, 572], "buggy_code_end_loc": [1492, 708], "fixing_code_start_loc": [1, 573], "fixing_code_end_loc": [1499, 710], "type": "CWE-416", "message": "ImageMagick before 7.0.8-55 has a use-after-free in DestroyStringInfo in MagickCore/string.c because the error manager is mishandled in coders/jpeg.c.", "other": {"cve": {"id": "CVE-2019-17541", "sourceIdentifier": "cve@mitre.org", "published": "2019-10-14T02:15:10.703", "lastModified": "2021-04-20T15:30:24.060", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ImageMagick before 7.0.8-55 has a use-after-free in DestroyStringInfo in MagickCore/string.c because the error manager is mishandled in coders/jpeg.c."}, {"lang": "es", "value": "ImageMagick versiones anteriores a 7.0.8-55, presenta una vulnerabilidad de uso de la memoria previamente liberada de la funci\u00f3n DestroyStringInfo en el archivo MagickCore/string.c porque el administrador de errores es manejado inapropiadamente en el archivo coders/jpeg.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.9.10-55", "matchCriteriaId": "FB264CB7-AFF2-45C4-A12E-9C65BD7DDD76"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0-0", "versionEndExcluding": "7.0.8-55", "matchCriteriaId": "6B173DFB-D070-44D6-BE3F-772BF990E3A9"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=15827", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/39f226a9c137f547e12afde972eeba7551124493", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/compare/7.0.8-54...7.0.8-55", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/1641", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/39f226a9c137f547e12afde972eeba7551124493"}}