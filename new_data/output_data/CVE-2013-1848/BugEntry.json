{"buggy_code": ["/*\n *  linux/fs/ext3/super.c\n *\n * Copyright (C) 1992, 1993, 1994, 1995\n * Remy Card (card@masi.ibp.fr)\n * Laboratoire MASI - Institut Blaise Pascal\n * Universite Pierre et Marie Curie (Paris VI)\n *\n *  from\n *\n *  linux/fs/minix/inode.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n *\n *  Big-endian to little-endian byte-swapping/bitmaps by\n *        David S. Miller (davem@caip.rutgers.edu), 1995\n */\n\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/parser.h>\n#include <linux/exportfs.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/log2.h>\n#include <linux/cleancache.h>\n\n#include <asm/uaccess.h>\n\n#define CREATE_TRACE_POINTS\n\n#include \"ext3.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"namei.h\"\n\n#ifdef CONFIG_EXT3_DEFAULTS_TO_ORDERED\n  #define EXT3_MOUNT_DEFAULT_DATA_MODE EXT3_MOUNT_ORDERED_DATA\n#else\n  #define EXT3_MOUNT_DEFAULT_DATA_MODE EXT3_MOUNT_WRITEBACK_DATA\n#endif\n\nstatic int ext3_load_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t     unsigned long journal_devnum);\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_sync_fs(struct super_block *sb, int wait);\nstatic const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);\nstatic int ext3_remount (struct super_block * sb, int * flags, char * data);\nstatic int ext3_statfs (struct dentry * dentry, struct kstatfs * buf);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\n/*\n * Wrappers for journal_start/end.\n */\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks)\n{\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\n\t/* Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly. */\n\tjournal = EXT3_SB(sb)->s_journal;\n\tif (is_journal_aborted(journal)) {\n\t\text3_abort(sb, __func__,\n\t\t\t   \"Detected aborted journal\");\n\t\treturn ERR_PTR(-EROFS);\n\t}\n\n\treturn journal_start(journal, nblocks);\n}\n\nint __ext3_journal_stop(const char *where, handle_t *handle)\n{\n\tstruct super_block *sb;\n\tint err;\n\tint rc;\n\n\tsb = handle->h_transaction->t_journal->j_private;\n\terr = handle->h_err;\n\trc = journal_stop(handle);\n\n\tif (!err)\n\t\terr = rc;\n\tif (err)\n\t\t__ext3_std_error(sb, where, err);\n\treturn err;\n}\n\nvoid ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext3_decode_error(NULL, err, nbuf);\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT3-fs: %s: aborting transaction: %s in %s\\n\",\n\t\tcaller, errstr, err_fn);\n\n\tjournal_abort_handle(handle);\n}\n\nvoid ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}\n\n/* Deal with the reporting of failure conditions on a filesystem such as\n * inconsistencies detected or read IO failures.\n *\n * On ext2, we can store the error state of the filesystem in the\n * superblock.  That is not possible on ext3, because we may have other\n * write ordering constraints on the superblock which prevent us from\n * writing it out straight away; and given that the journal is about to\n * be aborted, we can't rely on the current, or future, transactions to\n * write out the superblock safely.\n *\n * We'll just use the journal_abort() error code to record an error in\n * the journal instead.  On recovery, the journal will complain about\n * that error until we've noted it down and cleared it.\n */\n\nstatic void ext3_handle_error(struct super_block *sb)\n{\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\n\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\tes->s_state |= cpu_to_le16(EXT3_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tif (!test_opt (sb, ERRORS_CONT)) {\n\t\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\n\t\tset_opt(EXT3_SB(sb)->s_mount_opt, ABORT);\n\t\tif (journal)\n\t\t\tjournal_abort(journal, -EIO);\n\t}\n\tif (test_opt (sb, ERRORS_RO)) {\n\t\text3_msg(sb, KERN_CRIT,\n\t\t\t\"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\text3_commit_super(sb, es, 1);\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT3-fs (%s): panic forced after error\\n\",\n\t\t\tsb->s_id);\n}\n\nvoid ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}\n\nstatic const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16])\n{\n\tchar *errstr = NULL;\n\n\tswitch (errno) {\n\tcase -EIO:\n\t\terrstr = \"IO failure\";\n\t\tbreak;\n\tcase -ENOMEM:\n\t\terrstr = \"Out of memory\";\n\t\tbreak;\n\tcase -EROFS:\n\t\tif (!sb || EXT3_SB(sb)->s_journal->j_flags & JFS_ABORT)\n\t\t\terrstr = \"Journal has aborted\";\n\t\telse\n\t\t\terrstr = \"Readonly filesystem\";\n\t\tbreak;\n\tdefault:\n\t\t/* If the caller passed in an extra buffer for unknown\n\t\t * errors, textualise them now.  Else we just return\n\t\t * NULL. */\n\t\tif (nbuf) {\n\t\t\t/* Check for truncated error codes... */\n\t\t\tif (snprintf(nbuf, 16, \"error %d\", -errno) >= 0)\n\t\t\t\terrstr = nbuf;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn errstr;\n}\n\n/* __ext3_std_error decodes expected errors from journaling functions\n * automatically and invokes the appropriate error response.  */\n\nvoid __ext3_std_error (struct super_block * sb, const char * function,\n\t\t       int errno)\n{\n\tchar nbuf[16];\n\tconst char *errstr;\n\n\t/* Special case: if the error is EROFS, and we're not already\n\t * inside a transaction, then there's really no point in logging\n\t * an error. */\n\tif (errno == -EROFS && journal_current_handle() == NULL &&\n\t    (sb->s_flags & MS_RDONLY))\n\t\treturn;\n\n\terrstr = ext3_decode_error(sb, errno, nbuf);\n\text3_msg(sb, KERN_CRIT, \"error in %s: %s\", function, errstr);\n\n\text3_handle_error(sb);\n}\n\n/*\n * ext3_abort is a much stronger failure handler than ext3_error.  The\n * abort function may be used to deal with unrecoverable failures such\n * as journal IO errors or ENOMEM at a critical moment in log management.\n *\n * We unconditionally force the filesystem into an ABORT|READONLY state,\n * unless the error response on the fs has been set to panic in which\n * case we take the easy way out and panic immediately.\n */\n\nvoid ext3_abort(struct super_block *sb, const char *function,\n\t\t const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT3-fs: panic from previous error\\n\");\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\text3_msg(sb, KERN_CRIT,\n\t\t\"error: remounting filesystem read-only\");\n\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\tsb->s_flags |= MS_RDONLY;\n\tset_opt(EXT3_SB(sb)->s_mount_opt, ABORT);\n\tif (EXT3_SB(sb)->s_journal)\n\t\tjournal_abort(EXT3_SB(sb)->s_journal, -EIO);\n}\n\nvoid ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}\n\nvoid ext3_update_dynamic_rev(struct super_block *sb)\n{\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT3_GOOD_OLD_REV)\n\t\treturn;\n\n\text3_msg(sb, KERN_WARNING,\n\t\t\"warning: updating to rev %d because of \"\n\t\t\"new feature flag, running e2fsck is recommended\",\n\t\tEXT3_DYNAMIC_REV);\n\n\tes->s_first_ino = cpu_to_le32(EXT3_GOOD_OLD_FIRST_INO);\n\tes->s_inode_size = cpu_to_le16(EXT3_GOOD_OLD_INODE_SIZE);\n\tes->s_rev_level = cpu_to_le32(EXT3_DYNAMIC_REV);\n\t/* leave es->s_feature_*compat flags alone */\n\t/* es->s_uuid will be set by e2fsck if empty */\n\n\t/*\n\t * The rest of the superblock fields should be zero, and if not it\n\t * means they are likely already in use, so leave them alone.  We\n\t * can leave it up to e2fsck to clean up any inconsistencies there.\n\t */\n}\n\n/*\n * Open the external journal device\n */\nstatic struct block_device *ext3_blkdev_get(dev_t dev, struct super_block *sb)\n{\n\tstruct block_device *bdev;\n\tchar b[BDEVNAME_SIZE];\n\n\tbdev = blkdev_get_by_dev(dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL, sb);\n\tif (IS_ERR(bdev))\n\t\tgoto fail;\n\treturn bdev;\n\nfail:\n\text3_msg(sb, \"error: failed to open journal device %s: %ld\",\n\t\t__bdevname(dev, b), PTR_ERR(bdev));\n\n\treturn NULL;\n}\n\n/*\n * Release the journal device\n */\nstatic int ext3_blkdev_put(struct block_device *bdev)\n{\n\treturn blkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n}\n\nstatic int ext3_blkdev_remove(struct ext3_sb_info *sbi)\n{\n\tstruct block_device *bdev;\n\tint ret = -ENODEV;\n\n\tbdev = sbi->journal_bdev;\n\tif (bdev) {\n\t\tret = ext3_blkdev_put(bdev);\n\t\tsbi->journal_bdev = NULL;\n\t}\n\treturn ret;\n}\n\nstatic inline struct inode *orphan_list_entry(struct list_head *l)\n{\n\treturn &list_entry(l, struct ext3_inode_info, i_orphan)->vfs_inode;\n}\n\nstatic void dump_orphan_list(struct super_block *sb, struct ext3_sb_info *sbi)\n{\n\tstruct list_head *l;\n\n\text3_msg(sb, KERN_ERR, \"error: sb orphan head is %d\",\n\t       le32_to_cpu(sbi->s_es->s_last_orphan));\n\n\text3_msg(sb, KERN_ERR, \"sb_info orphan list:\");\n\tlist_for_each(l, &sbi->s_orphan) {\n\t\tstruct inode *inode = orphan_list_entry(l);\n\t\text3_msg(sb, KERN_ERR, \"  \"\n\t\t       \"inode %s:%lu at %p: mode %o, nlink %d, next %d\\n\",\n\t\t       inode->i_sb->s_id, inode->i_ino, inode,\n\t\t       inode->i_mode, inode->i_nlink,\n\t\t       NEXT_ORPHAN(inode));\n\t}\n}\n\nstatic void ext3_put_super (struct super_block * sb)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tstruct ext3_super_block *es = sbi->s_es;\n\tint i, err;\n\n\tdquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\text3_xattr_put_super(sb);\n\terr = journal_destroy(sbi->s_journal);\n\tsbi->s_journal = NULL;\n\tif (err < 0)\n\t\text3_abort(sb, __func__, \"Couldn't clean up the journal\");\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tEXT3_CLEAR_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"marking dirty\");\n\t\tmark_buffer_dirty(sbi->s_sbh);\n\t\text3_commit_super(sb, es, 1);\n\t}\n\n\tfor (i = 0; i < sbi->s_gdb_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tbrelse(sbi->s_sbh);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\n\t/* Debugging code just in case the in-memory inode orphan list\n\t * isn't empty.  The on-disk one can be non-empty if we've\n\t * detected an error and taken the fs readonly, but the\n\t * in-memory list had better be clean by this point. */\n\tif (!list_empty(&sbi->s_orphan))\n\t\tdump_orphan_list(sb, sbi);\n\tJ_ASSERT(list_empty(&sbi->s_orphan));\n\n\tinvalidate_bdev(sb->s_bdev);\n\tif (sbi->journal_bdev && sbi->journal_bdev != sb->s_bdev) {\n\t\t/*\n\t\t * Invalidate the journal device's buffers.  We don't want them\n\t\t * floating about in memory - the physical journal device may\n\t\t * hotswapped, and it breaks the `ro-after' testing code.\n\t\t */\n\t\tsync_blockdev(sbi->journal_bdev);\n\t\tinvalidate_bdev(sbi->journal_bdev);\n\t\text3_blkdev_remove(sbi);\n\t}\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\n}\n\nstatic struct kmem_cache *ext3_inode_cachep;\n\n/*\n * Called inside transaction, so use GFP_NOFS\n */\nstatic struct inode *ext3_alloc_inode(struct super_block *sb)\n{\n\tstruct ext3_inode_info *ei;\n\n\tei = kmem_cache_alloc(ext3_inode_cachep, GFP_NOFS);\n\tif (!ei)\n\t\treturn NULL;\n\tei->i_block_alloc_info = NULL;\n\tei->vfs_inode.i_version = 1;\n\tatomic_set(&ei->i_datasync_tid, 0);\n\tatomic_set(&ei->i_sync_tid, 0);\n\treturn &ei->vfs_inode;\n}\n\nstatic int ext3_drop_inode(struct inode *inode)\n{\n\tint drop = generic_drop_inode(inode);\n\n\ttrace_ext3_drop_inode(inode, drop);\n\treturn drop;\n}\n\nstatic void ext3_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(ext3_inode_cachep, EXT3_I(inode));\n}\n\nstatic void ext3_destroy_inode(struct inode *inode)\n{\n\tif (!list_empty(&(EXT3_I(inode)->i_orphan))) {\n\t\tprintk(\"EXT3 Inode %p: orphan list check failed!\\n\",\n\t\t\tEXT3_I(inode));\n\t\tprint_hex_dump(KERN_INFO, \"\", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\tEXT3_I(inode), sizeof(struct ext3_inode_info),\n\t\t\t\tfalse);\n\t\tdump_stack();\n\t}\n\tcall_rcu(&inode->i_rcu, ext3_i_callback);\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct ext3_inode_info *ei = (struct ext3_inode_info *) foo;\n\n\tINIT_LIST_HEAD(&ei->i_orphan);\n#ifdef CONFIG_EXT3_FS_XATTR\n\tinit_rwsem(&ei->xattr_sem);\n#endif\n\tmutex_init(&ei->truncate_mutex);\n\tinode_init_once(&ei->vfs_inode);\n}\n\nstatic int init_inodecache(void)\n{\n\text3_inode_cachep = kmem_cache_create(\"ext3_inode_cache\",\n\t\t\t\t\t     sizeof(struct ext3_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (ext3_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ext3_inode_cachep);\n}\n\nstatic inline void ext3_show_quota_options(struct seq_file *seq, struct super_block *sb)\n{\n#if defined(CONFIG_QUOTA)\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (sbi->s_jquota_fmt) {\n\t\tchar *fmtname = \"\";\n\n\t\tswitch (sbi->s_jquota_fmt) {\n\t\tcase QFMT_VFS_OLD:\n\t\t\tfmtname = \"vfsold\";\n\t\t\tbreak;\n\t\tcase QFMT_VFS_V0:\n\t\t\tfmtname = \"vfsv0\";\n\t\t\tbreak;\n\t\tcase QFMT_VFS_V1:\n\t\t\tfmtname = \"vfsv1\";\n\t\t\tbreak;\n\t\t}\n\t\tseq_printf(seq, \",jqfmt=%s\", fmtname);\n\t}\n\n\tif (sbi->s_qf_names[USRQUOTA])\n\t\tseq_printf(seq, \",usrjquota=%s\", sbi->s_qf_names[USRQUOTA]);\n\n\tif (sbi->s_qf_names[GRPQUOTA])\n\t\tseq_printf(seq, \",grpjquota=%s\", sbi->s_qf_names[GRPQUOTA]);\n\n\tif (test_opt(sb, USRQUOTA))\n\t\tseq_puts(seq, \",usrquota\");\n\n\tif (test_opt(sb, GRPQUOTA))\n\t\tseq_puts(seq, \",grpquota\");\n#endif\n}\n\nstatic char *data_mode_string(unsigned long mode)\n{\n\tswitch (mode) {\n\tcase EXT3_MOUNT_JOURNAL_DATA:\n\t\treturn \"journal\";\n\tcase EXT3_MOUNT_ORDERED_DATA:\n\t\treturn \"ordered\";\n\tcase EXT3_MOUNT_WRITEBACK_DATA:\n\t\treturn \"writeback\";\n\t}\n\treturn \"unknown\";\n}\n\n/*\n * Show an option if\n *  - it's set to a non-default value OR\n *  - if the per-sb default is different from the global default\n */\nstatic int ext3_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct super_block *sb = root->d_sb;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tstruct ext3_super_block *es = sbi->s_es;\n\tunsigned long def_mount_opts;\n\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\n\tif (sbi->s_sb_block != 1)\n\t\tseq_printf(seq, \",sb=%lu\", sbi->s_sb_block);\n\tif (test_opt(sb, MINIX_DF))\n\t\tseq_puts(seq, \",minixdf\");\n\tif (test_opt(sb, GRPID))\n\t\tseq_puts(seq, \",grpid\");\n\tif (!test_opt(sb, GRPID) && (def_mount_opts & EXT3_DEFM_BSDGROUPS))\n\t\tseq_puts(seq, \",nogrpid\");\n\tif (!uid_eq(sbi->s_resuid, make_kuid(&init_user_ns, EXT3_DEF_RESUID)) ||\n\t    le16_to_cpu(es->s_def_resuid) != EXT3_DEF_RESUID) {\n\t\tseq_printf(seq, \",resuid=%u\",\n\t\t\t\tfrom_kuid_munged(&init_user_ns, sbi->s_resuid));\n\t}\n\tif (!gid_eq(sbi->s_resgid, make_kgid(&init_user_ns, EXT3_DEF_RESGID)) ||\n\t    le16_to_cpu(es->s_def_resgid) != EXT3_DEF_RESGID) {\n\t\tseq_printf(seq, \",resgid=%u\",\n\t\t\t\tfrom_kgid_munged(&init_user_ns, sbi->s_resgid));\n\t}\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\tint def_errors = le16_to_cpu(es->s_errors);\n\n\t\tif (def_errors == EXT3_ERRORS_PANIC ||\n\t\t    def_errors == EXT3_ERRORS_CONTINUE) {\n\t\t\tseq_puts(seq, \",errors=remount-ro\");\n\t\t}\n\t}\n\tif (test_opt(sb, ERRORS_CONT))\n\t\tseq_puts(seq, \",errors=continue\");\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tseq_puts(seq, \",errors=panic\");\n\tif (test_opt(sb, NO_UID32))\n\t\tseq_puts(seq, \",nouid32\");\n\tif (test_opt(sb, DEBUG))\n\t\tseq_puts(seq, \",debug\");\n#ifdef CONFIG_EXT3_FS_XATTR\n\tif (test_opt(sb, XATTR_USER))\n\t\tseq_puts(seq, \",user_xattr\");\n\tif (!test_opt(sb, XATTR_USER) &&\n\t    (def_mount_opts & EXT3_DEFM_XATTR_USER)) {\n\t\tseq_puts(seq, \",nouser_xattr\");\n\t}\n#endif\n#ifdef CONFIG_EXT3_FS_POSIX_ACL\n\tif (test_opt(sb, POSIX_ACL))\n\t\tseq_puts(seq, \",acl\");\n\tif (!test_opt(sb, POSIX_ACL) && (def_mount_opts & EXT3_DEFM_ACL))\n\t\tseq_puts(seq, \",noacl\");\n#endif\n\tif (!test_opt(sb, RESERVATION))\n\t\tseq_puts(seq, \",noreservation\");\n\tif (sbi->s_commit_interval) {\n\t\tseq_printf(seq, \",commit=%u\",\n\t\t\t   (unsigned) (sbi->s_commit_interval / HZ));\n\t}\n\n\t/*\n\t * Always display barrier state so it's clear what the status is.\n\t */\n\tseq_puts(seq, \",barrier=\");\n\tseq_puts(seq, test_opt(sb, BARRIER) ? \"1\" : \"0\");\n\tseq_printf(seq, \",data=%s\", data_mode_string(test_opt(sb, DATA_FLAGS)));\n\tif (test_opt(sb, DATA_ERR_ABORT))\n\t\tseq_puts(seq, \",data_err=abort\");\n\n\tif (test_opt(sb, NOLOAD))\n\t\tseq_puts(seq, \",norecovery\");\n\n\text3_show_quota_options(seq, sb);\n\n\treturn 0;\n}\n\n\nstatic struct inode *ext3_nfs_get_inode(struct super_block *sb,\n\t\tu64 ino, u32 generation)\n{\n\tstruct inode *inode;\n\n\tif (ino < EXT3_FIRST_INO(sb) && ino != EXT3_ROOT_INO)\n\t\treturn ERR_PTR(-ESTALE);\n\tif (ino > le32_to_cpu(EXT3_SB(sb)->s_es->s_inodes_count))\n\t\treturn ERR_PTR(-ESTALE);\n\n\t/* iget isn't really right if the inode is currently unallocated!!\n\t *\n\t * ext3_read_inode will return a bad_inode if the inode had been\n\t * deleted, so we should be safe.\n\t *\n\t * Currently we don't know the generation for parent directory, so\n\t * a generation of 0 means \"accept any\"\n\t */\n\tinode = ext3_iget(sb, ino);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tif (generation && inode->i_generation != generation) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\treturn inode;\n}\n\nstatic struct dentry *ext3_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    ext3_nfs_get_inode);\n}\n\nstatic struct dentry *ext3_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    ext3_nfs_get_inode);\n}\n\n/*\n * Try to release metadata pages (indirect blocks, directories) which are\n * mapped via the block device.  Since these pages could have journal heads\n * which would prevent try_to_free_buffers() from freeing them, we must use\n * jbd layer's try_to_free_buffers() function to release them.\n */\nstatic int bdev_try_to_free_page(struct super_block *sb, struct page *page,\n\t\t\t\t gfp_t wait)\n{\n\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\n\tWARN_ON(PageChecked(page));\n\tif (!page_has_buffers(page))\n\t\treturn 0;\n\tif (journal)\n\t\treturn journal_try_to_free_buffers(journal, page, \n\t\t\t\t\t\t   wait & ~__GFP_WAIT);\n\treturn try_to_free_buffers(page);\n}\n\n#ifdef CONFIG_QUOTA\n#define QTYPE2NAME(t) ((t)==USRQUOTA?\"user\":\"group\")\n#define QTYPE2MOPT(on, t) ((t)==USRQUOTA?((on)##USRJQUOTA):((on)##GRPJQUOTA))\n\nstatic int ext3_write_dquot(struct dquot *dquot);\nstatic int ext3_acquire_dquot(struct dquot *dquot);\nstatic int ext3_release_dquot(struct dquot *dquot);\nstatic int ext3_mark_dquot_dirty(struct dquot *dquot);\nstatic int ext3_write_info(struct super_block *sb, int type);\nstatic int ext3_quota_on(struct super_block *sb, int type, int format_id,\n\t\t\t struct path *path);\nstatic int ext3_quota_on_mount(struct super_block *sb, int type);\nstatic ssize_t ext3_quota_read(struct super_block *sb, int type, char *data,\n\t\t\t       size_t len, loff_t off);\nstatic ssize_t ext3_quota_write(struct super_block *sb, int type,\n\t\t\t\tconst char *data, size_t len, loff_t off);\n\nstatic const struct dquot_operations ext3_quota_operations = {\n\t.write_dquot\t= ext3_write_dquot,\n\t.acquire_dquot\t= ext3_acquire_dquot,\n\t.release_dquot\t= ext3_release_dquot,\n\t.mark_dirty\t= ext3_mark_dquot_dirty,\n\t.write_info\t= ext3_write_info,\n\t.alloc_dquot\t= dquot_alloc,\n\t.destroy_dquot\t= dquot_destroy,\n};\n\nstatic const struct quotactl_ops ext3_qctl_operations = {\n\t.quota_on\t= ext3_quota_on,\n\t.quota_off\t= dquot_quota_off,\n\t.quota_sync\t= dquot_quota_sync,\n\t.get_info\t= dquot_get_dqinfo,\n\t.set_info\t= dquot_set_dqinfo,\n\t.get_dqblk\t= dquot_get_dqblk,\n\t.set_dqblk\t= dquot_set_dqblk\n};\n#endif\n\nstatic const struct super_operations ext3_sops = {\n\t.alloc_inode\t= ext3_alloc_inode,\n\t.destroy_inode\t= ext3_destroy_inode,\n\t.write_inode\t= ext3_write_inode,\n\t.dirty_inode\t= ext3_dirty_inode,\n\t.drop_inode\t= ext3_drop_inode,\n\t.evict_inode\t= ext3_evict_inode,\n\t.put_super\t= ext3_put_super,\n\t.sync_fs\t= ext3_sync_fs,\n\t.freeze_fs\t= ext3_freeze,\n\t.unfreeze_fs\t= ext3_unfreeze,\n\t.statfs\t\t= ext3_statfs,\n\t.remount_fs\t= ext3_remount,\n\t.show_options\t= ext3_show_options,\n#ifdef CONFIG_QUOTA\n\t.quota_read\t= ext3_quota_read,\n\t.quota_write\t= ext3_quota_write,\n#endif\n\t.bdev_try_to_free_page = bdev_try_to_free_page,\n};\n\nstatic const struct export_operations ext3_export_ops = {\n\t.fh_to_dentry = ext3_fh_to_dentry,\n\t.fh_to_parent = ext3_fh_to_parent,\n\t.get_parent = ext3_get_parent,\n};\n\nenum {\n\tOpt_bsd_df, Opt_minix_df, Opt_grpid, Opt_nogrpid,\n\tOpt_resgid, Opt_resuid, Opt_sb, Opt_err_cont, Opt_err_panic, Opt_err_ro,\n\tOpt_nouid32, Opt_nocheck, Opt_debug, Opt_oldalloc, Opt_orlov,\n\tOpt_user_xattr, Opt_nouser_xattr, Opt_acl, Opt_noacl,\n\tOpt_reservation, Opt_noreservation, Opt_noload, Opt_nobh, Opt_bh,\n\tOpt_commit, Opt_journal_update, Opt_journal_inum, Opt_journal_dev,\n\tOpt_abort, Opt_data_journal, Opt_data_ordered, Opt_data_writeback,\n\tOpt_data_err_abort, Opt_data_err_ignore,\n\tOpt_usrjquota, Opt_grpjquota, Opt_offusrjquota, Opt_offgrpjquota,\n\tOpt_jqfmt_vfsold, Opt_jqfmt_vfsv0, Opt_jqfmt_vfsv1, Opt_quota,\n\tOpt_noquota, Opt_ignore, Opt_barrier, Opt_nobarrier, Opt_err,\n\tOpt_resize, Opt_usrquota, Opt_grpquota\n};\n\nstatic const match_table_t tokens = {\n\t{Opt_bsd_df, \"bsddf\"},\n\t{Opt_minix_df, \"minixdf\"},\n\t{Opt_grpid, \"grpid\"},\n\t{Opt_grpid, \"bsdgroups\"},\n\t{Opt_nogrpid, \"nogrpid\"},\n\t{Opt_nogrpid, \"sysvgroups\"},\n\t{Opt_resgid, \"resgid=%u\"},\n\t{Opt_resuid, \"resuid=%u\"},\n\t{Opt_sb, \"sb=%u\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_nouid32, \"nouid32\"},\n\t{Opt_nocheck, \"nocheck\"},\n\t{Opt_nocheck, \"check=none\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_oldalloc, \"oldalloc\"},\n\t{Opt_orlov, \"orlov\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_reservation, \"reservation\"},\n\t{Opt_noreservation, \"noreservation\"},\n\t{Opt_noload, \"noload\"},\n\t{Opt_noload, \"norecovery\"},\n\t{Opt_nobh, \"nobh\"},\n\t{Opt_bh, \"bh\"},\n\t{Opt_commit, \"commit=%u\"},\n\t{Opt_journal_update, \"journal=update\"},\n\t{Opt_journal_inum, \"journal=%u\"},\n\t{Opt_journal_dev, \"journal_dev=%u\"},\n\t{Opt_abort, \"abort\"},\n\t{Opt_data_journal, \"data=journal\"},\n\t{Opt_data_ordered, \"data=ordered\"},\n\t{Opt_data_writeback, \"data=writeback\"},\n\t{Opt_data_err_abort, \"data_err=abort\"},\n\t{Opt_data_err_ignore, \"data_err=ignore\"},\n\t{Opt_offusrjquota, \"usrjquota=\"},\n\t{Opt_usrjquota, \"usrjquota=%s\"},\n\t{Opt_offgrpjquota, \"grpjquota=\"},\n\t{Opt_grpjquota, \"grpjquota=%s\"},\n\t{Opt_jqfmt_vfsold, \"jqfmt=vfsold\"},\n\t{Opt_jqfmt_vfsv0, \"jqfmt=vfsv0\"},\n\t{Opt_jqfmt_vfsv1, \"jqfmt=vfsv1\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_noquota, \"noquota\"},\n\t{Opt_quota, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_barrier, \"barrier=%u\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_resize, \"resize\"},\n\t{Opt_err, NULL},\n};\n\nstatic ext3_fsblk_t get_sb_block(void **data, struct super_block *sb)\n{\n\text3_fsblk_t\tsb_block;\n\tchar\t\t*options = (char *) *data;\n\n\tif (!options || strncmp(options, \"sb=\", 3) != 0)\n\t\treturn 1;\t/* Default location */\n\toptions += 3;\n\t/*todo: use simple_strtoll with >32bit ext3 */\n\tsb_block = simple_strtoul(options, &options, 0);\n\tif (*options && *options != ',') {\n\t\text3_msg(sb, \"error: invalid sb specification: %s\",\n\t\t       (char *) *data);\n\t\treturn 1;\n\t}\n\tif (*options == ',')\n\t\toptions++;\n\t*data = (void *) options;\n\treturn sb_block;\n}\n\n#ifdef CONFIG_QUOTA\nstatic int set_qf_name(struct super_block *sb, int qtype, substring_t *args)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tchar *qname;\n\n\tif (sb_any_quota_loaded(sb) &&\n\t\t!sbi->s_qf_names[qtype]) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"Cannot change journaled \"\n\t\t\t\"quota options when quota turned on\");\n\t\treturn 0;\n\t}\n\tqname = match_strdup(args);\n\tif (!qname) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"Not enough memory for storing quotafile name\");\n\t\treturn 0;\n\t}\n\tif (sbi->s_qf_names[qtype]) {\n\t\tint same = !strcmp(sbi->s_qf_names[qtype], qname);\n\n\t\tkfree(qname);\n\t\tif (!same) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t \"%s quota file already specified\",\n\t\t\t\t QTYPE2NAME(qtype));\n\t\t}\n\t\treturn same;\n\t}\n\tif (strchr(qname, '/')) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"quotafile must be on filesystem root\");\n\t\tkfree(qname);\n\t\treturn 0;\n\t}\n\tsbi->s_qf_names[qtype] = qname;\n\tset_opt(sbi->s_mount_opt, QUOTA);\n\treturn 1;\n}\n\nstatic int clear_qf_name(struct super_block *sb, int qtype) {\n\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (sb_any_quota_loaded(sb) &&\n\t\tsbi->s_qf_names[qtype]) {\n\t\text3_msg(sb, KERN_ERR, \"Cannot change journaled quota options\"\n\t\t\t\" when quota turned on\");\n\t\treturn 0;\n\t}\n\tif (sbi->s_qf_names[qtype]) {\n\t\tkfree(sbi->s_qf_names[qtype]);\n\t\tsbi->s_qf_names[qtype] = NULL;\n\t}\n\treturn 1;\n}\n#endif\n\nstatic int parse_options (char *options, struct super_block *sb,\n\t\t\t  unsigned int *inum, unsigned long *journal_devnum,\n\t\t\t  ext3_fsblk_t *n_blocks_count, int is_remount)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tchar * p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint data_opt = 0;\n\tint option;\n\tkuid_t uid;\n\tkgid_t gid;\n#ifdef CONFIG_QUOTA\n\tint qfmt;\n#endif\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep (&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Initialize args struct so we know whether arg was\n\t\t * found; some options take optional arguments.\n\t\t */\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_bsd_df:\n\t\t\tclear_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_minix_df:\n\t\t\tset_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_grpid:\n\t\t\tset_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_nogrpid:\n\t\t\tclear_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_resuid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid)) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"Invalid uid value %d\", option);\n\t\t\t\treturn 0;\n\n\t\t\t}\n\t\t\tsbi->s_resuid = uid;\n\t\t\tbreak;\n\t\tcase Opt_resgid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid)) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"Invalid gid value %d\", option);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->s_resgid = gid;\n\t\t\tbreak;\n\t\tcase Opt_sb:\n\t\t\t/* handled by get_sb_block() instead of here */\n\t\t\t/* *sb_block = match_int(&args[0]); */\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tbreak;\n\t\tcase Opt_nouid32:\n\t\t\tset_opt (sbi->s_mount_opt, NO_UID32);\n\t\t\tbreak;\n\t\tcase Opt_nocheck:\n\t\t\tclear_opt (sbi->s_mount_opt, CHECK);\n\t\t\tbreak;\n\t\tcase Opt_debug:\n\t\t\tset_opt (sbi->s_mount_opt, DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_oldalloc:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"Ignoring deprecated oldalloc option\");\n\t\t\tbreak;\n\t\tcase Opt_orlov:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"Ignoring deprecated orlov option\");\n\t\t\tbreak;\n#ifdef CONFIG_EXT3_FS_XATTR\n\t\tcase Opt_user_xattr:\n\t\t\tset_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tclear_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n#else\n\t\tcase Opt_user_xattr:\n\t\tcase Opt_nouser_xattr:\n\t\t\text3_msg(sb, KERN_INFO,\n\t\t\t\t\"(no)user_xattr options not supported\");\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_EXT3_FS_POSIX_ACL\n\t\tcase Opt_acl:\n\t\t\tset_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tclear_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n#else\n\t\tcase Opt_acl:\n\t\tcase Opt_noacl:\n\t\t\text3_msg(sb, KERN_INFO,\n\t\t\t\t\"(no)acl options not supported\");\n\t\t\tbreak;\n#endif\n\t\tcase Opt_reservation:\n\t\t\tset_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\tbreak;\n\t\tcase Opt_noreservation:\n\t\t\tclear_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\tbreak;\n\t\tcase Opt_journal_update:\n\t\t\t/* @@@ FIXME */\n\t\t\t/* Eventually we will want to be able to create\n\t\t\t   a journal file here.  For now, only allow the\n\t\t\t   user to specify an existing inode to be the\n\t\t\t   journal file. */\n\t\t\tif (is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot specify \"\n\t\t\t\t\t\"journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tset_opt (sbi->s_mount_opt, UPDATE_JOURNAL);\n\t\t\tbreak;\n\t\tcase Opt_journal_inum:\n\t\t\tif (is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot specify \"\n\t\t\t\t       \"journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*inum = option;\n\t\t\tbreak;\n\t\tcase Opt_journal_dev:\n\t\t\tif (is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot specify \"\n\t\t\t\t       \"journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*journal_devnum = option;\n\t\t\tbreak;\n\t\tcase Opt_noload:\n\t\t\tset_opt (sbi->s_mount_opt, NOLOAD);\n\t\t\tbreak;\n\t\tcase Opt_commit:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tif (option < 0)\n\t\t\t\treturn 0;\n\t\t\tif (option == 0)\n\t\t\t\toption = JBD_DEFAULT_MAX_COMMIT_AGE;\n\t\t\tsbi->s_commit_interval = HZ * option;\n\t\t\tbreak;\n\t\tcase Opt_data_journal:\n\t\t\tdata_opt = EXT3_MOUNT_JOURNAL_DATA;\n\t\t\tgoto datacheck;\n\t\tcase Opt_data_ordered:\n\t\t\tdata_opt = EXT3_MOUNT_ORDERED_DATA;\n\t\t\tgoto datacheck;\n\t\tcase Opt_data_writeback:\n\t\t\tdata_opt = EXT3_MOUNT_WRITEBACK_DATA;\n\t\tdatacheck:\n\t\t\tif (is_remount) {\n\t\t\t\tif (test_opt(sb, DATA_FLAGS) == data_opt)\n\t\t\t\t\tbreak;\n\t\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: cannot change \"\n\t\t\t\t\t\"data mode on remount. The filesystem \"\n\t\t\t\t\t\"is mounted in data=%s mode and you \"\n\t\t\t\t\t\"try to remount it in data=%s mode.\",\n\t\t\t\t\tdata_mode_string(test_opt(sb,\n\t\t\t\t\t\t\tDATA_FLAGS)),\n\t\t\t\t\tdata_mode_string(data_opt));\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tclear_opt(sbi->s_mount_opt, DATA_FLAGS);\n\t\t\t\tsbi->s_mount_opt |= data_opt;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_data_err_abort:\n\t\t\tset_opt(sbi->s_mount_opt, DATA_ERR_ABORT);\n\t\t\tbreak;\n\t\tcase Opt_data_err_ignore:\n\t\t\tclear_opt(sbi->s_mount_opt, DATA_ERR_ABORT);\n\t\t\tbreak;\n#ifdef CONFIG_QUOTA\n\t\tcase Opt_usrjquota:\n\t\t\tif (!set_qf_name(sb, USRQUOTA, &args[0]))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_grpjquota:\n\t\t\tif (!set_qf_name(sb, GRPQUOTA, &args[0]))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_offusrjquota:\n\t\t\tif (!clear_qf_name(sb, USRQUOTA))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_offgrpjquota:\n\t\t\tif (!clear_qf_name(sb, GRPQUOTA))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_jqfmt_vfsold:\n\t\t\tqfmt = QFMT_VFS_OLD;\n\t\t\tgoto set_qf_format;\n\t\tcase Opt_jqfmt_vfsv0:\n\t\t\tqfmt = QFMT_VFS_V0;\n\t\t\tgoto set_qf_format;\n\t\tcase Opt_jqfmt_vfsv1:\n\t\t\tqfmt = QFMT_VFS_V1;\nset_qf_format:\n\t\t\tif (sb_any_quota_loaded(sb) &&\n\t\t\t    sbi->s_jquota_fmt != qfmt) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot change \"\n\t\t\t\t\t\"journaled quota options when \"\n\t\t\t\t\t\"quota turned on.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->s_jquota_fmt = qfmt;\n\t\t\tbreak;\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\t\tset_opt(sbi->s_mount_opt, QUOTA);\n\t\t\tset_opt(sbi->s_mount_opt, USRQUOTA);\n\t\t\tbreak;\n\t\tcase Opt_grpquota:\n\t\t\tset_opt(sbi->s_mount_opt, QUOTA);\n\t\t\tset_opt(sbi->s_mount_opt, GRPQUOTA);\n\t\t\tbreak;\n\t\tcase Opt_noquota:\n\t\t\tif (sb_any_quota_loaded(sb)) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot change \"\n\t\t\t\t\t\"quota options when quota turned on.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tclear_opt(sbi->s_mount_opt, QUOTA);\n\t\t\tclear_opt(sbi->s_mount_opt, USRQUOTA);\n\t\t\tclear_opt(sbi->s_mount_opt, GRPQUOTA);\n\t\t\tbreak;\n#else\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\tcase Opt_grpquota:\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: quota options not supported.\");\n\t\t\tbreak;\n\t\tcase Opt_usrjquota:\n\t\tcase Opt_grpjquota:\n\t\tcase Opt_offusrjquota:\n\t\tcase Opt_offgrpjquota:\n\t\tcase Opt_jqfmt_vfsold:\n\t\tcase Opt_jqfmt_vfsv0:\n\t\tcase Opt_jqfmt_vfsv1:\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: journaled quota options not \"\n\t\t\t\t\"supported.\");\n\t\t\tbreak;\n\t\tcase Opt_noquota:\n\t\t\tbreak;\n#endif\n\t\tcase Opt_abort:\n\t\t\tset_opt(sbi->s_mount_opt, ABORT);\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tclear_opt(sbi->s_mount_opt, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_barrier:\n\t\t\tif (args[0].from) {\n\t\t\t\tif (match_int(&args[0], &option))\n\t\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\toption = 1;\t/* No argument, default to 1 */\n\t\t\tif (option)\n\t\t\t\tset_opt(sbi->s_mount_opt, BARRIER);\n\t\t\telse\n\t\t\t\tclear_opt(sbi->s_mount_opt, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\t\tcase Opt_resize:\n\t\t\tif (!is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: resize option only available \"\n\t\t\t\t\t\"for remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (match_int(&args[0], &option) != 0)\n\t\t\t\treturn 0;\n\t\t\t*n_blocks_count = option;\n\t\t\tbreak;\n\t\tcase Opt_nobh:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"warning: ignoring deprecated nobh option\");\n\t\t\tbreak;\n\t\tcase Opt_bh:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"warning: ignoring deprecated bh option\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: unrecognized mount option \\\"%s\\\" \"\n\t\t\t\t\"or missing value\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n#ifdef CONFIG_QUOTA\n\tif (sbi->s_qf_names[USRQUOTA] || sbi->s_qf_names[GRPQUOTA]) {\n\t\tif (test_opt(sb, USRQUOTA) && sbi->s_qf_names[USRQUOTA])\n\t\t\tclear_opt(sbi->s_mount_opt, USRQUOTA);\n\t\tif (test_opt(sb, GRPQUOTA) && sbi->s_qf_names[GRPQUOTA])\n\t\t\tclear_opt(sbi->s_mount_opt, GRPQUOTA);\n\n\t\tif (test_opt(sb, GRPQUOTA) || test_opt(sb, USRQUOTA)) {\n\t\t\text3_msg(sb, KERN_ERR, \"error: old and new quota \"\n\t\t\t\t\t\"format mixing.\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!sbi->s_jquota_fmt) {\n\t\t\text3_msg(sb, KERN_ERR, \"error: journaled quota format \"\n\t\t\t\t\t\"not specified.\");\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (sbi->s_jquota_fmt) {\n\t\t\text3_msg(sb, KERN_ERR, \"error: journaled quota format \"\n\t\t\t\t\t\"specified with no journaling \"\n\t\t\t\t\t\"enabled.\");\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif\n\treturn 1;\n}\n\nstatic int ext3_setup_super(struct super_block *sb, struct ext3_super_block *es,\n\t\t\t    int read_only)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tint res = 0;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT3_MAX_SUPP_REV) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: revision level too high, \"\n\t\t\t\"forcing read-only mode\");\n\t\tres = MS_RDONLY;\n\t}\n\tif (read_only)\n\t\treturn res;\n\tif (!(sbi->s_mount_state & EXT3_VALID_FS))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting unchecked fs, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((sbi->s_mount_state & EXT3_ERROR_FS))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting fs with errors, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((__s16) le16_to_cpu(es->s_max_mnt_count) > 0 &&\n\t\t le16_to_cpu(es->s_mnt_count) >=\n\t\t\tle16_to_cpu(es->s_max_mnt_count))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: maximal mount count reached, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if (le32_to_cpu(es->s_checkinterval) &&\n\t\t(le32_to_cpu(es->s_lastcheck) +\n\t\t\tle32_to_cpu(es->s_checkinterval) <= get_seconds()))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: checktime reached, \"\n\t\t\t\"running e2fsck is recommended\");\n#if 0\n\t\t/* @@@ We _will_ want to clear the valid bit if we find\n                   inconsistencies, to force a fsck at reboot.  But for\n                   a plain journaled filesystem we can keep it set as\n                   valid forever! :) */\n\tes->s_state &= cpu_to_le16(~EXT3_VALID_FS);\n#endif\n\tif (!le16_to_cpu(es->s_max_mnt_count))\n\t\tes->s_max_mnt_count = cpu_to_le16(EXT3_DFL_MAX_MNT_COUNT);\n\tle16_add_cpu(&es->s_mnt_count, 1);\n\tes->s_mtime = cpu_to_le32(get_seconds());\n\text3_update_dynamic_rev(sb);\n\tEXT3_SET_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\n\text3_commit_super(sb, es, 1);\n\tif (test_opt(sb, DEBUG))\n\t\text3_msg(sb, KERN_INFO, \"[bs=%lu, gc=%lu, \"\n\t\t\t\t\"bpg=%lu, ipg=%lu, mo=%04lx]\",\n\t\t\tsb->s_blocksize,\n\t\t\tsbi->s_groups_count,\n\t\t\tEXT3_BLOCKS_PER_GROUP(sb),\n\t\t\tEXT3_INODES_PER_GROUP(sb),\n\t\t\tsbi->s_mount_opt);\n\n\tif (EXT3_SB(sb)->s_journal->j_inode == NULL) {\n\t\tchar b[BDEVNAME_SIZE];\n\t\text3_msg(sb, KERN_INFO, \"using external journal on %s\",\n\t\t\tbdevname(EXT3_SB(sb)->s_journal->j_dev, b));\n\t} else {\n\t\text3_msg(sb, KERN_INFO, \"using internal journal\");\n\t}\n\tcleancache_init_fs(sb);\n\treturn res;\n}\n\n/* Called at mount-time, super-block is locked */\nstatic int ext3_check_descriptors(struct super_block *sb)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tint i;\n\n\text3_debug (\"Checking group descriptors\");\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tstruct ext3_group_desc *gdp = ext3_get_group_desc(sb, i, NULL);\n\t\text3_fsblk_t first_block = ext3_group_first_block_no(sb, i);\n\t\text3_fsblk_t last_block;\n\n\t\tif (i == sbi->s_groups_count - 1)\n\t\t\tlast_block = le32_to_cpu(sbi->s_es->s_blocks_count) - 1;\n\t\telse\n\t\t\tlast_block = first_block +\n\t\t\t\t(EXT3_BLOCKS_PER_GROUP(sb) - 1);\n\n\t\tif (le32_to_cpu(gdp->bg_block_bitmap) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_block_bitmap) > last_block)\n\t\t{\n\t\t\text3_error (sb, \"ext3_check_descriptors\",\n\t\t\t\t    \"Block bitmap for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long)\n\t\t\t\t\tle32_to_cpu(gdp->bg_block_bitmap));\n\t\t\treturn 0;\n\t\t}\n\t\tif (le32_to_cpu(gdp->bg_inode_bitmap) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_inode_bitmap) > last_block)\n\t\t{\n\t\t\text3_error (sb, \"ext3_check_descriptors\",\n\t\t\t\t    \"Inode bitmap for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long)\n\t\t\t\t\tle32_to_cpu(gdp->bg_inode_bitmap));\n\t\t\treturn 0;\n\t\t}\n\t\tif (le32_to_cpu(gdp->bg_inode_table) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_inode_table) + sbi->s_itb_per_group - 1 >\n\t\t    last_block)\n\t\t{\n\t\t\text3_error (sb, \"ext3_check_descriptors\",\n\t\t\t\t    \"Inode table for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long)\n\t\t\t\t\tle32_to_cpu(gdp->bg_inode_table));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tsbi->s_es->s_free_blocks_count=cpu_to_le32(ext3_count_free_blocks(sb));\n\tsbi->s_es->s_free_inodes_count=cpu_to_le32(ext3_count_free_inodes(sb));\n\treturn 1;\n}\n\n\n/* ext3_orphan_cleanup() walks a singly-linked list of inodes (starting at\n * the superblock) which were deleted from all directories, but held open by\n * a process at the time of a crash.  We walk the list and try to delete these\n * inodes at recovery time (only with a read-write filesystem).\n *\n * In order to keep the orphan inode chain consistent during traversal (in\n * case of crash during recovery), we link each inode into the superblock\n * orphan list_head and handle it the same way as an inode deletion during\n * normal operation (which journals the operations for us).\n *\n * We only do an iget() and an iput() on each inode, which is very safe if we\n * accidentally point at an in-use or already deleted inode.  The worst that\n * can happen in this case is that we get a \"bit already cleared\" message from\n * ext3_free_inode().  The only reason we would point at a wrong inode is if\n * e2fsck was run on this filesystem, and it must have already done the orphan\n * inode cleanup for us, so we can safely abort without any further action.\n */\nstatic void ext3_orphan_cleanup (struct super_block * sb,\n\t\t\t\t struct ext3_super_block * es)\n{\n\tunsigned int s_flags = sb->s_flags;\n\tint nr_orphans = 0, nr_truncates = 0;\n#ifdef CONFIG_QUOTA\n\tint i;\n#endif\n\tif (!es->s_last_orphan) {\n\t\tjbd_debug(4, \"no orphan inodes to clean up\\n\");\n\t\treturn;\n\t}\n\n\tif (bdev_read_only(sb->s_bdev)) {\n\t\text3_msg(sb, KERN_ERR, \"error: write access \"\n\t\t\t\"unavailable, skipping orphan cleanup.\");\n\t\treturn;\n\t}\n\n\t/* Check if feature set allows readwrite operations */\n\tif (EXT3_HAS_RO_COMPAT_FEATURE(sb, ~EXT3_FEATURE_RO_COMPAT_SUPP)) {\n\t\text3_msg(sb, KERN_INFO, \"Skipping orphan cleanup due to \"\n\t\t\t \"unknown ROCOMPAT features\");\n\t\treturn;\n\t}\n\n\tif (EXT3_SB(sb)->s_mount_state & EXT3_ERROR_FS) {\n\t\t/* don't clear list on RO mount w/ errors */\n\t\tif (es->s_last_orphan && !(s_flags & MS_RDONLY)) {\n\t\t\tjbd_debug(1, \"Errors on filesystem, \"\n\t\t\t\t  \"clearing orphan list.\\n\");\n\t\t\tes->s_last_orphan = 0;\n\t\t}\n\t\tjbd_debug(1, \"Skipping orphan recovery on fs with errors.\\n\");\n\t\treturn;\n\t}\n\n\tif (s_flags & MS_RDONLY) {\n\t\text3_msg(sb, KERN_INFO, \"orphan cleanup on readonly fs\");\n\t\tsb->s_flags &= ~MS_RDONLY;\n\t}\n#ifdef CONFIG_QUOTA\n\t/* Needed for iput() to work correctly and not trash data */\n\tsb->s_flags |= MS_ACTIVE;\n\t/* Turn on quotas so that they are updated correctly */\n\tfor (i = 0; i < MAXQUOTAS; i++) {\n\t\tif (EXT3_SB(sb)->s_qf_names[i]) {\n\t\t\tint ret = ext3_quota_on_mount(sb, i);\n\t\t\tif (ret < 0)\n\t\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: cannot turn on journaled \"\n\t\t\t\t\t\"quota: %d\", ret);\n\t\t}\n\t}\n#endif\n\n\twhile (es->s_last_orphan) {\n\t\tstruct inode *inode;\n\n\t\tinode = ext3_orphan_get(sb, le32_to_cpu(es->s_last_orphan));\n\t\tif (IS_ERR(inode)) {\n\t\t\tes->s_last_orphan = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\t\tdquot_initialize(inode);\n\t\tif (inode->i_nlink) {\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"%s: truncating inode %lu to %Ld bytes\\n\",\n\t\t\t\t__func__, inode->i_ino, inode->i_size);\n\t\t\tjbd_debug(2, \"truncating inode %lu to %Ld bytes\\n\",\n\t\t\t\t  inode->i_ino, inode->i_size);\n\t\t\text3_truncate(inode);\n\t\t\tnr_truncates++;\n\t\t} else {\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"%s: deleting unreferenced inode %lu\\n\",\n\t\t\t\t__func__, inode->i_ino);\n\t\t\tjbd_debug(2, \"deleting unreferenced inode %lu\\n\",\n\t\t\t\t  inode->i_ino);\n\t\t\tnr_orphans++;\n\t\t}\n\t\tiput(inode);  /* The delete magic happens here! */\n\t}\n\n#define PLURAL(x) (x), ((x)==1) ? \"\" : \"s\"\n\n\tif (nr_orphans)\n\t\text3_msg(sb, KERN_INFO, \"%d orphan inode%s deleted\",\n\t\t       PLURAL(nr_orphans));\n\tif (nr_truncates)\n\t\text3_msg(sb, KERN_INFO, \"%d truncate%s cleaned up\",\n\t\t       PLURAL(nr_truncates));\n#ifdef CONFIG_QUOTA\n\t/* Turn quotas off */\n\tfor (i = 0; i < MAXQUOTAS; i++) {\n\t\tif (sb_dqopt(sb)->files[i])\n\t\t\tdquot_quota_off(sb, i);\n\t}\n#endif\n\tsb->s_flags = s_flags; /* Restore MS_RDONLY status */\n}\n\n/*\n * Maximal file size.  There is a direct, and {,double-,triple-}indirect\n * block limit, and also a limit of (2^32 - 1) 512-byte sectors in i_blocks.\n * We need to be 1 filesystem block less than the 2^32 sector limit.\n */\nstatic loff_t ext3_max_size(int bits)\n{\n\tloff_t res = EXT3_NDIR_BLOCKS;\n\tint meta_blocks;\n\tloff_t upper_limit;\n\n\t/* This is calculated to be the largest file size for a\n\t * dense, file such that the total number of\n\t * sectors in the file, including data and all indirect blocks,\n\t * does not exceed 2^32 -1\n\t * __u32 i_blocks representing the total number of\n\t * 512 bytes blocks of the file\n\t */\n\tupper_limit = (1LL << 32) - 1;\n\n\t/* total blocks in file system block size */\n\tupper_limit >>= (bits - 9);\n\n\n\t/* indirect blocks */\n\tmeta_blocks = 1;\n\t/* double indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2));\n\t/* tripple indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2)) + (1LL << (2*(bits-2)));\n\n\tupper_limit -= meta_blocks;\n\tupper_limit <<= bits;\n\n\tres += 1LL << (bits-2);\n\tres += 1LL << (2*(bits-2));\n\tres += 1LL << (3*(bits-2));\n\tres <<= bits;\n\tif (res > upper_limit)\n\t\tres = upper_limit;\n\n\tif (res > MAX_LFS_FILESIZE)\n\t\tres = MAX_LFS_FILESIZE;\n\n\treturn res;\n}\n\nstatic ext3_fsblk_t descriptor_loc(struct super_block *sb,\n\t\t\t\t    ext3_fsblk_t logic_sb_block,\n\t\t\t\t    int nr)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tunsigned long bg, first_meta_bg;\n\tint has_super = 0;\n\n\tfirst_meta_bg = le32_to_cpu(sbi->s_es->s_first_meta_bg);\n\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_META_BG) ||\n\t    nr < first_meta_bg)\n\t\treturn (logic_sb_block + nr + 1);\n\tbg = sbi->s_desc_per_block * nr;\n\tif (ext3_bg_has_super(sb, bg))\n\t\thas_super = 1;\n\treturn (has_super + ext3_group_first_block_no(sb, bg));\n}\n\n\nstatic int ext3_fill_super (struct super_block *sb, void *data, int silent)\n{\n\tstruct buffer_head * bh;\n\tstruct ext3_super_block *es = NULL;\n\tstruct ext3_sb_info *sbi;\n\text3_fsblk_t block;\n\text3_fsblk_t sb_block = get_sb_block(&data, sb);\n\text3_fsblk_t logic_sb_block;\n\tunsigned long offset = 0;\n\tunsigned int journal_inum = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tint blocksize;\n\tint hblock;\n\tint db_count;\n\tint i;\n\tint needs_recovery;\n\tint ret = -EINVAL;\n\t__le32 features;\n\tint err;\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock) {\n\t\tkfree(sbi);\n\t\treturn -ENOMEM;\n\t}\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb_block = sb_block;\n\n\tblocksize = sb_min_blocksize(sb, EXT3_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text3_msg(sb, KERN_ERR, \"error: unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext3 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT3_MIN_BLOCK_SIZE) {\n\t\tlogic_sb_block = (sb_block * EXT3_MIN_BLOCK_SIZE) / blocksize;\n\t\toffset = (sb_block * EXT3_MIN_BLOCK_SIZE) % blocksize;\n\t} else {\n\t\tlogic_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread(sb, logic_sb_block))) {\n\t\text3_msg(sb, KERN_ERR, \"error: unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext3 macro-instructions depend on its value\n\t */\n\tes = (struct ext3_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT3_SUPER_MAGIC)\n\t\tgoto cantfind_ext3;\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tif (def_mount_opts & EXT3_DEFM_DEBUG)\n\t\tset_opt(sbi->s_mount_opt, DEBUG);\n\tif (def_mount_opts & EXT3_DEFM_BSDGROUPS)\n\t\tset_opt(sbi->s_mount_opt, GRPID);\n\tif (def_mount_opts & EXT3_DEFM_UID16)\n\t\tset_opt(sbi->s_mount_opt, NO_UID32);\n#ifdef CONFIG_EXT3_FS_XATTR\n\tif (def_mount_opts & EXT3_DEFM_XATTR_USER)\n\t\tset_opt(sbi->s_mount_opt, XATTR_USER);\n#endif\n#ifdef CONFIG_EXT3_FS_POSIX_ACL\n\tif (def_mount_opts & EXT3_DEFM_ACL)\n\t\tset_opt(sbi->s_mount_opt, POSIX_ACL);\n#endif\n\tif ((def_mount_opts & EXT3_DEFM_JMODE) == EXT3_DEFM_JMODE_DATA)\n\t\tset_opt(sbi->s_mount_opt, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT3_DEFM_JMODE) == EXT3_DEFM_JMODE_ORDERED)\n\t\tset_opt(sbi->s_mount_opt, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT3_DEFM_JMODE) == EXT3_DEFM_JMODE_WBACK)\n\t\tset_opt(sbi->s_mount_opt, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT3_ERRORS_PANIC)\n\t\tset_opt(sbi->s_mount_opt, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT3_ERRORS_CONTINUE)\n\t\tset_opt(sbi->s_mount_opt, ERRORS_CONT);\n\telse\n\t\tset_opt(sbi->s_mount_opt, ERRORS_RO);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\n\t/* enable barriers by default */\n\tset_opt(sbi->s_mount_opt, BARRIER);\n\tset_opt(sbi->s_mount_opt, RESERVATION);\n\n\tif (!parse_options ((char *) data, sb, &journal_inum, &journal_devnum,\n\t\t\t    NULL, 0))\n\t\tgoto failed_mount;\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT3_GOOD_OLD_REV &&\n\t    (EXT3_HAS_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT3_HAS_RO_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT3_HAS_INCOMPAT_FEATURE(sb, ~0U)))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: feature flags set on rev 0 fs, \"\n\t\t\t\"running e2fsck is recommended\");\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tfeatures = EXT3_HAS_INCOMPAT_FEATURE(sb, ~EXT3_FEATURE_INCOMPAT_SUPP);\n\tif (features) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: couldn't mount because of unsupported \"\n\t\t\t\"optional features (%x)\", le32_to_cpu(features));\n\t\tgoto failed_mount;\n\t}\n\tfeatures = EXT3_HAS_RO_COMPAT_FEATURE(sb, ~EXT3_FEATURE_RO_COMPAT_SUPP);\n\tif (!(sb->s_flags & MS_RDONLY) && features) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: couldn't mount RDWR because of unsupported \"\n\t\t\t\"optional features (%x)\", le32_to_cpu(features));\n\t\tgoto failed_mount;\n\t}\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\n\tif (blocksize < EXT3_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT3_MAX_BLOCK_SIZE) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: couldn't mount because of unsupported \"\n\t\t\t\"filesystem blocksize %d\", blocksize);\n\t\tgoto failed_mount;\n\t}\n\n\thblock = bdev_logical_block_size(sb->s_bdev);\n\tif (sb->s_blocksize != blocksize) {\n\t\t/*\n\t\t * Make sure the blocksize for the filesystem is larger\n\t\t * than the hardware sectorsize for the machine.\n\t\t */\n\t\tif (blocksize < hblock) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: fsblocksize %d too small for \"\n\t\t\t\t\"hardware sectorsize %d\", blocksize, hblock);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse (bh);\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: bad blocksize %d\", blocksize);\n\t\t\tgoto out_fail;\n\t\t}\n\t\tlogic_sb_block = (sb_block * EXT3_MIN_BLOCK_SIZE) / blocksize;\n\t\toffset = (sb_block * EXT3_MIN_BLOCK_SIZE) % blocksize;\n\t\tbh = sb_bread(sb, logic_sb_block);\n\t\tif (!bh) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t       \"error: can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext3_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT3_SUPER_MAGIC)) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: magic mismatch\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tsb->s_maxbytes = ext3_max_size(sb->s_blocksize_bits);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT3_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT3_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT3_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT3_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: unsupported inode size: %d\",\n\t\t\t\tsbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\tsbi->s_frag_size = EXT3_MIN_FRAG_SIZE <<\n\t\t\t\t   le32_to_cpu(es->s_log_frag_size);\n\tif (blocksize != sbi->s_frag_size) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t       \"error: fragsize %lu != blocksize %u (unsupported)\",\n\t\t       sbi->s_frag_size, blocksize);\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_frags_per_block = 1;\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_frags_per_group = le32_to_cpu(es->s_frags_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\tif (EXT3_INODE_SIZE(sb) == 0 || EXT3_INODES_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext3;\n\tsbi->s_inodes_per_block = blocksize / EXT3_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext3;\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / sizeof(struct ext3_group_desc);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT3_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT3_DESC_PER_BLOCK(sb));\n\tfor (i=0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\ti = le32_to_cpu(es->s_flags);\n\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\tsbi->s_hash_unsigned = 3;\n\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\tes->s_flags |= cpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\tes->s_flags |= cpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t}\n\n\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"#blocks per group too big: %lu\",\n\t\t\tsbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tif (sbi->s_frags_per_group > blocksize * 8) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: #fragments per group too big: %lu\",\n\t\t\tsbi->s_frags_per_group);\n\t\tgoto failed_mount;\n\t}\n\tif (sbi->s_inodes_per_group > blocksize * 8) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: #inodes per group too big: %lu\",\n\t\t\tsbi->s_inodes_per_group);\n\t\tgoto failed_mount;\n\t}\n\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\tle32_to_cpu(es->s_blocks_count));\n\tif (err) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: filesystem is too large to mount safely\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: CONFIG_LBDAF not enabled\");\n\t\tret = err;\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT3_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext3;\n\tsbi->s_groups_count = ((le32_to_cpu(es->s_blocks_count) -\n\t\t\t       le32_to_cpu(es->s_first_data_block) - 1)\n\t\t\t\t       / EXT3_BLOCKS_PER_GROUP(sb)) + 1;\n\tdb_count = DIV_ROUND_UP(sbi->s_groups_count, EXT3_DESC_PER_BLOCK(sb));\n\tsbi->s_group_desc = kmalloc(db_count * sizeof (struct buffer_head *),\n\t\t\t\t    GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logic_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext3_check_descriptors (sb)) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: group descriptors corrupted\");\n\t\tgoto failed_mount2;\n\t}\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\t/* per fileystem reservation list head & lock */\n\tspin_lock_init(&sbi->s_rsv_window_lock);\n\tsbi->s_rsv_window_root = RB_ROOT;\n\t/* Add a single, static dummy reservation to the start of the\n\t * reservation window list --- it gives us a placeholder for\n\t * append-at-start-of-list which makes the allocation logic\n\t * _much_ simpler. */\n\tsbi->s_rsv_window_head.rsv_start = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\tsbi->s_rsv_window_head.rsv_end = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\tsbi->s_rsv_window_head.rsv_alloc_hit = 0;\n\tsbi->s_rsv_window_head.rsv_goal_size = 0;\n\text3_rsv_window_add(sb, &sbi->s_rsv_window_head);\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext3_sops;\n\tsb->s_export_op = &ext3_export_ops;\n\tsb->s_xattr = ext3_xattr_handlers;\n#ifdef CONFIG_QUOTA\n\tsb->s_qcop = &ext3_qctl_operations;\n\tsb->dq_op = &ext3_quota_operations;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\tmutex_init(&sbi->s_resize_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  EXT3_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t    EXT3_FEATURE_INCOMPAT_RECOVER));\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) &&\n\t    EXT3_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_HAS_JOURNAL)) {\n\t\tif (ext3_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount2;\n\t} else if (journal_inum) {\n\t\tif (ext3_create_journal(sb, es, journal_inum))\n\t\t\tgoto failed_mount2;\n\t} else {\n\t\tif (!silent)\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: no journal found. \"\n\t\t\t\t\"mounting ext3 over ext2?\");\n\t\tgoto failed_mount2;\n\t}\n\terr = percpu_counter_init(&sbi->s_freeblocks_counter,\n\t\t\text3_count_free_blocks(sb));\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter,\n\t\t\t\text3_count_free_inodes(sb));\n\t}\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\text3_count_dirs(sb));\n\t}\n\tif (err) {\n\t\text3_msg(sb, KERN_ERR, \"error: insufficient memory\");\n\t\tret = err;\n\t\tgoto failed_mount3;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n                   capabilities: ORDERED_DATA if the journal can\n                   cope, else JOURNAL_DATA */\n\t\tif (journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JFS_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sbi->s_mount_opt, DEFAULT_DATA_MODE);\n\t\telse\n\t\t\tset_opt(sbi->s_mount_opt, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT3_MOUNT_ORDERED_DATA:\n\tcase EXT3_MOUNT_WRITEBACK_DATA:\n\t\tif (!journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JFS_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: journal does not support \"\n\t\t\t\t\"requested data journaling mode\");\n\t\t\tgoto failed_mount3;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/*\n\t * The journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext3_iget(sb, EXT3_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text3_msg(sb, KERN_ERR, \"error: get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\tgoto failed_mount3;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\tiput(root);\n\t\text3_msg(sb, KERN_ERR, \"error: corrupt root inode, run e2fsck\");\n\t\tgoto failed_mount3;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text3_msg(sb, KERN_ERR, \"error: get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount3;\n\t}\n\n\tif (ext3_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\tEXT3_SB(sb)->s_mount_state |= EXT3_ORPHAN_FS;\n\text3_orphan_cleanup(sb, es);\n\tEXT3_SB(sb)->s_mount_state &= ~EXT3_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text3_mark_recovery_complete(sb, es);\n\t\text3_msg(sb, KERN_INFO, \"recovery complete\");\n\t}\n\text3_msg(sb, KERN_INFO, \"mounted filesystem with %s data mode\",\n\t\ttest_opt(sb,DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA ? \"journal\":\n\t\ttest_opt(sb,DATA_FLAGS) == EXT3_MOUNT_ORDERED_DATA ? \"ordered\":\n\t\t\"writeback\");\n\tsb->s_flags |= MS_SNAP_STABLE;\n\n\treturn 0;\n\ncantfind_ext3:\n\tif (!silent)\n\t\text3_msg(sb, KERN_INFO,\n\t\t\t\"error: can't find ext3 filesystem on dev %s.\",\n\t\t       sb->s_id);\n\tgoto failed_mount;\n\nfailed_mount3:\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tjournal_destroy(sbi->s_journal);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\nfailed_mount:\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text3_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\n\treturn ret;\n}\n\n/*\n * Setup any per-fs journal parameters now.  We'll do this both on\n * initial mount, once the journal has been initialised but before we've\n * done any recovery; and again on any subsequent remount.\n */\nstatic void ext3_init_journal_params(struct super_block *sb, journal_t *journal)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (sbi->s_commit_interval)\n\t\tjournal->j_commit_interval = sbi->s_commit_interval;\n\t/* We could also set up an ext3-specific default for the commit\n\t * interval here, but for now we'll just fall back to the jbd\n\t * default. */\n\n\tspin_lock(&journal->j_state_lock);\n\tif (test_opt(sb, BARRIER))\n\t\tjournal->j_flags |= JFS_BARRIER;\n\telse\n\t\tjournal->j_flags &= ~JFS_BARRIER;\n\tif (test_opt(sb, DATA_ERR_ABORT))\n\t\tjournal->j_flags |= JFS_ABORT_ON_SYNCDATA_ERR;\n\telse\n\t\tjournal->j_flags &= ~JFS_ABORT_ON_SYNCDATA_ERR;\n\tspin_unlock(&journal->j_state_lock);\n}\n\nstatic journal_t *ext3_get_journal(struct super_block *sb,\n\t\t\t\t   unsigned int journal_inum)\n{\n\tstruct inode *journal_inode;\n\tjournal_t *journal;\n\n\t/* First, test for the existence of a valid inode on disk.  Bad\n\t * things happen if we iget() an unused inode, as the subsequent\n\t * iput() will try to delete it. */\n\n\tjournal_inode = ext3_iget(sb, journal_inum);\n\tif (IS_ERR(journal_inode)) {\n\t\text3_msg(sb, KERN_ERR, \"error: no journal found\");\n\t\treturn NULL;\n\t}\n\tif (!journal_inode->i_nlink) {\n\t\tmake_bad_inode(journal_inode);\n\t\tiput(journal_inode);\n\t\text3_msg(sb, KERN_ERR, \"error: journal inode is deleted\");\n\t\treturn NULL;\n\t}\n\n\tjbd_debug(2, \"Journal inode found at %p: %Ld bytes\\n\",\n\t\t  journal_inode, journal_inode->i_size);\n\tif (!S_ISREG(journal_inode->i_mode)) {\n\t\text3_msg(sb, KERN_ERR, \"error: invalid journal inode\");\n\t\tiput(journal_inode);\n\t\treturn NULL;\n\t}\n\n\tjournal = journal_init_inode(journal_inode);\n\tif (!journal) {\n\t\text3_msg(sb, KERN_ERR, \"error: could not load journal inode\");\n\t\tiput(journal_inode);\n\t\treturn NULL;\n\t}\n\tjournal->j_private = sb;\n\text3_init_journal_params(sb, journal);\n\treturn journal;\n}\n\nstatic journal_t *ext3_get_dev_journal(struct super_block *sb,\n\t\t\t\t       dev_t j_dev)\n{\n\tstruct buffer_head * bh;\n\tjournal_t *journal;\n\text3_fsblk_t start;\n\text3_fsblk_t len;\n\tint hblock, blocksize;\n\text3_fsblk_t sb_block;\n\tunsigned long offset;\n\tstruct ext3_super_block * es;\n\tstruct block_device *bdev;\n\n\tbdev = ext3_blkdev_get(j_dev, sb);\n\tif (bdev == NULL)\n\t\treturn NULL;\n\n\tblocksize = sb->s_blocksize;\n\thblock = bdev_logical_block_size(bdev);\n\tif (blocksize < hblock) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: blocksize too small for journal device\");\n\t\tgoto out_bdev;\n\t}\n\n\tsb_block = EXT3_MIN_BLOCK_SIZE / blocksize;\n\toffset = EXT3_MIN_BLOCK_SIZE % blocksize;\n\tset_blocksize(bdev, blocksize);\n\tif (!(bh = __bread(bdev, sb_block, blocksize))) {\n\t\text3_msg(sb, KERN_ERR, \"error: couldn't read superblock of \"\n\t\t\t\"external journal\");\n\t\tgoto out_bdev;\n\t}\n\n\tes = (struct ext3_super_block *) (bh->b_data + offset);\n\tif ((le16_to_cpu(es->s_magic) != EXT3_SUPER_MAGIC) ||\n\t    !(le32_to_cpu(es->s_feature_incompat) &\n\t      EXT3_FEATURE_INCOMPAT_JOURNAL_DEV)) {\n\t\text3_msg(sb, KERN_ERR, \"error: external journal has \"\n\t\t\t\"bad superblock\");\n\t\tbrelse(bh);\n\t\tgoto out_bdev;\n\t}\n\n\tif (memcmp(EXT3_SB(sb)->s_es->s_journal_uuid, es->s_uuid, 16)) {\n\t\text3_msg(sb, KERN_ERR, \"error: journal UUID does not match\");\n\t\tbrelse(bh);\n\t\tgoto out_bdev;\n\t}\n\n\tlen = le32_to_cpu(es->s_blocks_count);\n\tstart = sb_block + 1;\n\tbrelse(bh);\t/* we're done with the superblock */\n\n\tjournal = journal_init_dev(bdev, sb->s_bdev,\n\t\t\t\t\tstart, len, blocksize);\n\tif (!journal) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: failed to create device journal\");\n\t\tgoto out_bdev;\n\t}\n\tjournal->j_private = sb;\n\tif (!bh_uptodate_or_lock(journal->j_sb_buffer)) {\n\t\tif (bh_submit_read(journal->j_sb_buffer)) {\n\t\t\text3_msg(sb, KERN_ERR, \"I/O error on journal device\");\n\t\t\tgoto out_journal;\n\t\t}\n\t}\n\tif (be32_to_cpu(journal->j_superblock->s_nr_users) != 1) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: external journal has more than one \"\n\t\t\t\"user (unsupported) - %d\",\n\t\t\tbe32_to_cpu(journal->j_superblock->s_nr_users));\n\t\tgoto out_journal;\n\t}\n\tEXT3_SB(sb)->journal_bdev = bdev;\n\text3_init_journal_params(sb, journal);\n\treturn journal;\nout_journal:\n\tjournal_destroy(journal);\nout_bdev:\n\text3_blkdev_put(bdev);\n\treturn NULL;\n}\n\nstatic int ext3_load_journal(struct super_block *sb,\n\t\t\t     struct ext3_super_block *es,\n\t\t\t     unsigned long journal_devnum)\n{\n\tjournal_t *journal;\n\tunsigned int journal_inum = le32_to_cpu(es->s_journal_inum);\n\tdev_t journal_dev;\n\tint err = 0;\n\tint really_read_only;\n\n\tif (journal_devnum &&\n\t    journal_devnum != le32_to_cpu(es->s_journal_dev)) {\n\t\text3_msg(sb, KERN_INFO, \"external journal device major/minor \"\n\t\t\t\"numbers have changed\");\n\t\tjournal_dev = new_decode_dev(journal_devnum);\n\t} else\n\t\tjournal_dev = new_decode_dev(le32_to_cpu(es->s_journal_dev));\n\n\treally_read_only = bdev_read_only(sb->s_bdev);\n\n\t/*\n\t * Are we loading a blank journal or performing recovery after a\n\t * crash?  For recovery, we need to check in advance whether we\n\t * can get read-write access to the device.\n\t */\n\n\tif (EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER)) {\n\t\tif (sb->s_flags & MS_RDONLY) {\n\t\t\text3_msg(sb, KERN_INFO,\n\t\t\t\t\"recovery required on readonly filesystem\");\n\t\t\tif (really_read_only) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: write access \"\n\t\t\t\t\t\"unavailable, cannot proceed\");\n\t\t\t\treturn -EROFS;\n\t\t\t}\n\t\t\text3_msg(sb, KERN_INFO,\n\t\t\t\t\"write access will be enabled during recovery\");\n\t\t}\n\t}\n\n\tif (journal_inum && journal_dev) {\n\t\text3_msg(sb, KERN_ERR, \"error: filesystem has both journal \"\n\t\t       \"and inode journals\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (journal_inum) {\n\t\tif (!(journal = ext3_get_journal(sb, journal_inum)))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (!(journal = ext3_get_dev_journal(sb, journal_dev)))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!(journal->j_flags & JFS_BARRIER))\n\t\tprintk(KERN_INFO \"EXT3-fs: barriers not enabled\\n\");\n\n\tif (!really_read_only && test_opt(sb, UPDATE_JOURNAL)) {\n\t\terr = journal_update_format(journal);\n\t\tif (err)  {\n\t\t\text3_msg(sb, KERN_ERR, \"error updating journal\");\n\t\t\tjournal_destroy(journal);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER))\n\t\terr = journal_wipe(journal, !really_read_only);\n\tif (!err)\n\t\terr = journal_load(journal);\n\n\tif (err) {\n\t\text3_msg(sb, KERN_ERR, \"error loading journal\");\n\t\tjournal_destroy(journal);\n\t\treturn err;\n\t}\n\n\tEXT3_SB(sb)->s_journal = journal;\n\text3_clear_journal_err(sb, es);\n\n\tif (!really_read_only && journal_devnum &&\n\t    journal_devnum != le32_to_cpu(es->s_journal_dev)) {\n\t\tes->s_journal_dev = cpu_to_le32(journal_devnum);\n\n\t\t/* Make sure we flush the recovery flag to disk. */\n\t\text3_commit_super(sb, es, 1);\n\t}\n\n\treturn 0;\n}\n\nstatic int ext3_create_journal(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       unsigned int journal_inum)\n{\n\tjournal_t *journal;\n\tint err;\n\n\tif (sb->s_flags & MS_RDONLY) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: readonly filesystem when trying to \"\n\t\t\t\"create journal\");\n\t\treturn -EROFS;\n\t}\n\n\tjournal = ext3_get_journal(sb, journal_inum);\n\tif (!journal)\n\t\treturn -EINVAL;\n\n\text3_msg(sb, KERN_INFO, \"creating new journal on inode %u\",\n\t       journal_inum);\n\n\terr = journal_create(journal);\n\tif (err) {\n\t\text3_msg(sb, KERN_ERR, \"error creating journal\");\n\t\tjournal_destroy(journal);\n\t\treturn -EIO;\n\t}\n\n\tEXT3_SB(sb)->s_journal = journal;\n\n\text3_update_dynamic_rev(sb);\n\tEXT3_SET_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\tEXT3_SET_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_HAS_JOURNAL);\n\n\tes->s_journal_inum = cpu_to_le32(journal_inum);\n\n\t/* Make sure we flush the recovery flag to disk. */\n\text3_commit_super(sb, es, 1);\n\n\treturn 0;\n}\n\nstatic int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync)\n{\n\tstruct buffer_head *sbh = EXT3_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh)\n\t\treturn error;\n\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text3_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tes->s_free_blocks_count = cpu_to_le32(ext3_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext3_count_free_inodes(sb));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (buffer_write_io_error(sbh)) {\n\t\t\text3_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}\n\n\n/*\n * Have we just finished recovery?  If so, and if we are mounting (or\n * remounting) the filesystem readonly, then we will end up with a\n * consistent fs on disk.  Record that fact.\n */\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es)\n{\n\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\n\tjournal_lock_updates(journal);\n\tif (journal_flush(journal) < 0)\n\t\tgoto out;\n\n\tif (EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER) &&\n\t    sb->s_flags & MS_RDONLY) {\n\t\tEXT3_CLEAR_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\t\text3_commit_super(sb, es, 1);\n\t}\n\nout:\n\tjournal_unlock_updates(journal);\n}\n\n/*\n * If we are mounting (or read-write remounting) a filesystem whose journal\n * has recorded an error from a previous lifetime, move that error to the\n * main filesystem now.\n */\nstatic void ext3_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext3_super_block *es)\n{\n\tjournal_t *journal;\n\tint j_errno;\n\tconst char *errstr;\n\n\tjournal = EXT3_SB(sb)->s_journal;\n\n\t/*\n\t * Now check for any error status which may have been recorded in the\n\t * journal by a prior ext3_error() or ext3_abort()\n\t */\n\n\tj_errno = journal_errno(journal);\n\tif (j_errno) {\n\t\tchar nbuf[16];\n\n\t\terrstr = ext3_decode_error(sb, j_errno, nbuf);\n\t\text3_warning(sb, __func__, \"Filesystem error recorded \"\n\t\t\t     \"from previous mount: %s\", errstr);\n\t\text3_warning(sb, __func__, \"Marking fs in need of \"\n\t\t\t     \"filesystem check.\");\n\n\t\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT3_ERROR_FS);\n\t\text3_commit_super (sb, es, 1);\n\n\t\tjournal_clear_err(journal);\n\t}\n}\n\n/*\n * Force the running and committing transactions to commit,\n * and wait on the commit.\n */\nint ext3_force_commit(struct super_block *sb)\n{\n\tjournal_t *journal;\n\tint ret;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tjournal = EXT3_SB(sb)->s_journal;\n\tret = ext3_journal_force_commit(journal);\n\treturn ret;\n}\n\nstatic int ext3_sync_fs(struct super_block *sb, int wait)\n{\n\ttid_t target;\n\n\ttrace_ext3_sync_fs(sb, wait);\n\t/*\n\t * Writeback quota in non-journalled quota case - journalled quota has\n\t * no dirty dquots\n\t */\n\tdquot_writeback_dquots(sb, -1);\n\tif (journal_start_commit(EXT3_SB(sb)->s_journal, &target)) {\n\t\tif (wait)\n\t\t\tlog_wait_commit(EXT3_SB(sb)->s_journal, target);\n\t}\n\treturn 0;\n}\n\n/*\n * LVM calls this function before a (read-only) snapshot is created.  This\n * gives us a chance to flush the journal completely and mark the fs clean.\n */\nstatic int ext3_freeze(struct super_block *sb)\n{\n\tint error = 0;\n\tjournal_t *journal;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tjournal = EXT3_SB(sb)->s_journal;\n\n\t\t/* Now we set up the journal barrier. */\n\t\tjournal_lock_updates(journal);\n\n\t\t/*\n\t\t * We don't want to clear needs_recovery flag when we failed\n\t\t * to flush the journal.\n\t\t */\n\t\terror = journal_flush(journal);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\n\t\t/* Journal blocked and flushed, clear needs_recovery flag. */\n\t\tEXT3_CLEAR_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\t\terror = ext3_commit_super(sb, EXT3_SB(sb)->s_es, 1);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\treturn 0;\n\nout:\n\tjournal_unlock_updates(journal);\n\treturn error;\n}\n\n/*\n * Called by LVM after the snapshot is done.  We need to reset the RECOVER\n * flag here, even though the filesystem is not technically dirty yet.\n */\nstatic int ext3_unfreeze(struct super_block *sb)\n{\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t/* Reser the needs_recovery flag before the fs is unlocked. */\n\t\tEXT3_SET_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\t\text3_commit_super(sb, EXT3_SB(sb)->s_es, 1);\n\t\tjournal_unlock_updates(EXT3_SB(sb)->s_journal);\n\t}\n\treturn 0;\n}\n\nstatic int ext3_remount (struct super_block * sb, int * flags, char * data)\n{\n\tstruct ext3_super_block * es;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\text3_fsblk_t n_blocks_count = 0;\n\tunsigned long old_sb_flags;\n\tstruct ext3_mount_options old_opts;\n\tint enable_quota = 0;\n\tint err;\n#ifdef CONFIG_QUOTA\n\tint i;\n#endif\n\n\t/* Store the original options */\n\told_sb_flags = sb->s_flags;\n\told_opts.s_mount_opt = sbi->s_mount_opt;\n\told_opts.s_resuid = sbi->s_resuid;\n\told_opts.s_resgid = sbi->s_resgid;\n\told_opts.s_commit_interval = sbi->s_commit_interval;\n#ifdef CONFIG_QUOTA\n\told_opts.s_jquota_fmt = sbi->s_jquota_fmt;\n\tfor (i = 0; i < MAXQUOTAS; i++)\n\t\tif (sbi->s_qf_names[i]) {\n\t\t\told_opts.s_qf_names[i] = kstrdup(sbi->s_qf_names[i],\n\t\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!old_opts.s_qf_names[i]) {\n\t\t\t\tint j;\n\n\t\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\t\tkfree(old_opts.s_qf_names[j]);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t} else\n\t\t\told_opts.s_qf_names[i] = NULL;\n#endif\n\n\t/*\n\t * Allow the \"check\" option to be passed as a remount option.\n\t */\n\tif (!parse_options(data, sb, NULL, NULL, &n_blocks_count, 1)) {\n\t\terr = -EINVAL;\n\t\tgoto restore_opts;\n\t}\n\n\tif (test_opt(sb, ABORT))\n\t\text3_abort(sb, __func__, \"Abort forced by user\");\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tes = sbi->s_es;\n\n\text3_init_journal_params(sb, sbi->s_journal);\n\n\tif ((*flags & MS_RDONLY) != (sb->s_flags & MS_RDONLY) ||\n\t\tn_blocks_count > le32_to_cpu(es->s_blocks_count)) {\n\t\tif (test_opt(sb, ABORT)) {\n\t\t\terr = -EROFS;\n\t\t\tgoto restore_opts;\n\t\t}\n\n\t\tif (*flags & MS_RDONLY) {\n\t\t\terr = dquot_suspend(sb, -1);\n\t\t\tif (err < 0)\n\t\t\t\tgoto restore_opts;\n\n\t\t\t/*\n\t\t\t * First of all, the unconditional stuff we have to do\n\t\t\t * to disable replay of the journal when we next remount\n\t\t\t */\n\t\t\tsb->s_flags |= MS_RDONLY;\n\n\t\t\t/*\n\t\t\t * OK, test if we are remounting a valid rw partition\n\t\t\t * readonly, and if so set the rdonly flag and then\n\t\t\t * mark the partition as valid again.\n\t\t\t */\n\t\t\tif (!(es->s_state & cpu_to_le16(EXT3_VALID_FS)) &&\n\t\t\t    (sbi->s_mount_state & EXT3_VALID_FS))\n\t\t\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\n\t\t\text3_mark_recovery_complete(sb, es);\n\t\t} else {\n\t\t\t__le32 ret;\n\t\t\tif ((ret = EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t~EXT3_FEATURE_RO_COMPAT_SUPP))) {\n\t\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\t\"warning: couldn't remount RDWR \"\n\t\t\t\t\t\"because of unsupported optional \"\n\t\t\t\t\t\"features (%x)\", le32_to_cpu(ret));\n\t\t\t\terr = -EROFS;\n\t\t\t\tgoto restore_opts;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If we have an unprocessed orphan list hanging\n\t\t\t * around from a previously readonly bdev mount,\n\t\t\t * require a full umount & mount for now.\n\t\t\t */\n\t\t\tif (es->s_last_orphan) {\n\t\t\t\text3_msg(sb, KERN_WARNING, \"warning: couldn't \"\n\t\t\t\t       \"remount RDWR because of unprocessed \"\n\t\t\t\t       \"orphan inode list.  Please \"\n\t\t\t\t       \"umount & mount instead.\");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto restore_opts;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Mounting a RDONLY partition read-write, so reread\n\t\t\t * and store the current valid flag.  (It may have\n\t\t\t * been changed by e2fsck since we originally mounted\n\t\t\t * the partition.)\n\t\t\t */\n\t\t\text3_clear_journal_err(sb, es);\n\t\t\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\t\t\tif ((err = ext3_group_extend(sb, es, n_blocks_count)))\n\t\t\t\tgoto restore_opts;\n\t\t\tif (!ext3_setup_super (sb, es, 0))\n\t\t\t\tsb->s_flags &= ~MS_RDONLY;\n\t\t\tenable_quota = 1;\n\t\t}\n\t}\n#ifdef CONFIG_QUOTA\n\t/* Release old quota file names */\n\tfor (i = 0; i < MAXQUOTAS; i++)\n\t\tkfree(old_opts.s_qf_names[i]);\n#endif\n\tif (enable_quota)\n\t\tdquot_resume(sb, -1);\n\treturn 0;\nrestore_opts:\n\tsb->s_flags = old_sb_flags;\n\tsbi->s_mount_opt = old_opts.s_mount_opt;\n\tsbi->s_resuid = old_opts.s_resuid;\n\tsbi->s_resgid = old_opts.s_resgid;\n\tsbi->s_commit_interval = old_opts.s_commit_interval;\n#ifdef CONFIG_QUOTA\n\tsbi->s_jquota_fmt = old_opts.s_jquota_fmt;\n\tfor (i = 0; i < MAXQUOTAS; i++) {\n\t\tkfree(sbi->s_qf_names[i]);\n\t\tsbi->s_qf_names[i] = old_opts.s_qf_names[i];\n\t}\n#endif\n\treturn err;\n}\n\nstatic int ext3_statfs (struct dentry * dentry, struct kstatfs * buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tstruct ext3_super_block *es = sbi->s_es;\n\tu64 fsid;\n\n\tif (test_opt(sb, MINIX_DF)) {\n\t\tsbi->s_overhead_last = 0;\n\t} else if (sbi->s_blocks_last != le32_to_cpu(es->s_blocks_count)) {\n\t\tunsigned long ngroups = sbi->s_groups_count, i;\n\t\text3_fsblk_t overhead = 0;\n\t\tsmp_rmb();\n\n\t\t/*\n\t\t * Compute the overhead (FS structures).  This is constant\n\t\t * for a given filesystem unless the number of block groups\n\t\t * changes so we cache the previous value until it does.\n\t\t */\n\n\t\t/*\n\t\t * All of the blocks before first_data_block are\n\t\t * overhead\n\t\t */\n\t\toverhead = le32_to_cpu(es->s_first_data_block);\n\n\t\t/*\n\t\t * Add the overhead attributed to the superblock and\n\t\t * block group descriptors.  If the sparse superblocks\n\t\t * feature is turned on, then not all groups have this.\n\t\t */\n\t\tfor (i = 0; i < ngroups; i++) {\n\t\t\toverhead += ext3_bg_has_super(sb, i) +\n\t\t\t\text3_bg_num_gdb(sb, i);\n\t\t\tcond_resched();\n\t\t}\n\n\t\t/*\n\t\t * Every block group has an inode bitmap, a block\n\t\t * bitmap, and an inode table.\n\t\t */\n\t\toverhead += ngroups * (2 + sbi->s_itb_per_group);\n\t\tsbi->s_overhead_last = overhead;\n\t\tsmp_wmb();\n\t\tsbi->s_blocks_last = le32_to_cpu(es->s_blocks_count);\n\t}\n\n\tbuf->f_type = EXT3_SUPER_MAGIC;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = le32_to_cpu(es->s_blocks_count) - sbi->s_overhead_last;\n\tbuf->f_bfree = percpu_counter_sum_positive(&sbi->s_freeblocks_counter);\n\tbuf->f_bavail = buf->f_bfree - le32_to_cpu(es->s_r_blocks_count);\n\tif (buf->f_bfree < le32_to_cpu(es->s_r_blocks_count))\n\t\tbuf->f_bavail = 0;\n\tbuf->f_files = le32_to_cpu(es->s_inodes_count);\n\tbuf->f_ffree = percpu_counter_sum_positive(&sbi->s_freeinodes_counter);\n\tbuf->f_namelen = EXT3_NAME_LEN;\n\tfsid = le64_to_cpup((void *)es->s_uuid) ^\n\t       le64_to_cpup((void *)es->s_uuid + sizeof(u64));\n\tbuf->f_fsid.val[0] = fsid & 0xFFFFFFFFUL;\n\tbuf->f_fsid.val[1] = (fsid >> 32) & 0xFFFFFFFFUL;\n\treturn 0;\n}\n\n/* Helper function for writing quotas on sync - we need to start transaction before quota file\n * is locked for write. Otherwise the are possible deadlocks:\n * Process 1                         Process 2\n * ext3_create()                     quota_sync()\n *   journal_start()                   write_dquot()\n *   dquot_initialize()                       down(dqio_mutex)\n *     down(dqio_mutex)                    journal_start()\n *\n */\n\n#ifdef CONFIG_QUOTA\n\nstatic inline struct inode *dquot_to_inode(struct dquot *dquot)\n{\n\treturn sb_dqopt(dquot->dq_sb)->files[dquot->dq_id.type];\n}\n\nstatic int ext3_write_dquot(struct dquot *dquot)\n{\n\tint ret, err;\n\thandle_t *handle;\n\tstruct inode *inode;\n\n\tinode = dquot_to_inode(dquot);\n\thandle = ext3_journal_start(inode,\n\t\t\t\t\tEXT3_QUOTA_TRANS_BLOCKS(dquot->dq_sb));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tret = dquot_commit(dquot);\n\terr = ext3_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}\n\nstatic int ext3_acquire_dquot(struct dquot *dquot)\n{\n\tint ret, err;\n\thandle_t *handle;\n\n\thandle = ext3_journal_start(dquot_to_inode(dquot),\n\t\t\t\t\tEXT3_QUOTA_INIT_BLOCKS(dquot->dq_sb));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tret = dquot_acquire(dquot);\n\terr = ext3_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}\n\nstatic int ext3_release_dquot(struct dquot *dquot)\n{\n\tint ret, err;\n\thandle_t *handle;\n\n\thandle = ext3_journal_start(dquot_to_inode(dquot),\n\t\t\t\t\tEXT3_QUOTA_DEL_BLOCKS(dquot->dq_sb));\n\tif (IS_ERR(handle)) {\n\t\t/* Release dquot anyway to avoid endless cycle in dqput() */\n\t\tdquot_release(dquot);\n\t\treturn PTR_ERR(handle);\n\t}\n\tret = dquot_release(dquot);\n\terr = ext3_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}\n\nstatic int ext3_mark_dquot_dirty(struct dquot *dquot)\n{\n\t/* Are we journaling quotas? */\n\tif (EXT3_SB(dquot->dq_sb)->s_qf_names[USRQUOTA] ||\n\t    EXT3_SB(dquot->dq_sb)->s_qf_names[GRPQUOTA]) {\n\t\tdquot_mark_dquot_dirty(dquot);\n\t\treturn ext3_write_dquot(dquot);\n\t} else {\n\t\treturn dquot_mark_dquot_dirty(dquot);\n\t}\n}\n\nstatic int ext3_write_info(struct super_block *sb, int type)\n{\n\tint ret, err;\n\thandle_t *handle;\n\n\t/* Data block + inode block */\n\thandle = ext3_journal_start(sb->s_root->d_inode, 2);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tret = dquot_commit_info(sb, type);\n\terr = ext3_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}\n\n/*\n * Turn on quotas during mount time - we need to find\n * the quota file and such...\n */\nstatic int ext3_quota_on_mount(struct super_block *sb, int type)\n{\n\treturn dquot_quota_on_mount(sb, EXT3_SB(sb)->s_qf_names[type],\n\t\t\t\t\tEXT3_SB(sb)->s_jquota_fmt, type);\n}\n\n/*\n * Standard function to be called on quota_on\n */\nstatic int ext3_quota_on(struct super_block *sb, int type, int format_id,\n\t\t\t struct path *path)\n{\n\tint err;\n\n\tif (!test_opt(sb, QUOTA))\n\t\treturn -EINVAL;\n\n\t/* Quotafile not on the same filesystem? */\n\tif (path->dentry->d_sb != sb)\n\t\treturn -EXDEV;\n\t/* Journaling quota? */\n\tif (EXT3_SB(sb)->s_qf_names[type]) {\n\t\t/* Quotafile not of fs root? */\n\t\tif (path->dentry->d_parent != sb->s_root)\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"warning: Quota file not on filesystem root. \"\n\t\t\t\t\"Journaled quota will not work.\");\n\t}\n\n\t/*\n\t * When we journal data on quota file, we have to flush journal to see\n\t * all updates to the file when we bypass pagecache...\n\t */\n\tif (ext3_should_journal_data(path->dentry->d_inode)) {\n\t\t/*\n\t\t * We don't need to lock updates but journal_flush() could\n\t\t * otherwise be livelocked...\n\t\t */\n\t\tjournal_lock_updates(EXT3_SB(sb)->s_journal);\n\t\terr = journal_flush(EXT3_SB(sb)->s_journal);\n\t\tjournal_unlock_updates(EXT3_SB(sb)->s_journal);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn dquot_quota_on(sb, type, format_id, path);\n}\n\n/* Read data from quotafile - avoid pagecache and such because we cannot afford\n * acquiring the locks... As quota files are never truncated and quota code\n * itself serializes the operations (and no one else should touch the files)\n * we don't have to be afraid of races */\nstatic ssize_t ext3_quota_read(struct super_block *sb, int type, char *data,\n\t\t\t       size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tsector_t blk = off >> EXT3_BLOCK_SIZE_BITS(sb);\n\tint err = 0;\n\tint offset = off & (sb->s_blocksize - 1);\n\tint tocopy;\n\tsize_t toread;\n\tstruct buffer_head *bh;\n\tloff_t i_size = i_size_read(inode);\n\n\tif (off > i_size)\n\t\treturn 0;\n\tif (off+len > i_size)\n\t\tlen = i_size-off;\n\ttoread = len;\n\twhile (toread > 0) {\n\t\ttocopy = sb->s_blocksize - offset < toread ?\n\t\t\t\tsb->s_blocksize - offset : toread;\n\t\tbh = ext3_bread(NULL, inode, blk, 0, &err);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (!bh)\t/* A hole? */\n\t\t\tmemset(data, 0, tocopy);\n\t\telse\n\t\t\tmemcpy(data, bh->b_data+offset, tocopy);\n\t\tbrelse(bh);\n\t\toffset = 0;\n\t\ttoread -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\n\treturn len;\n}\n\n/* Write to quotafile (we know the transaction is already started and has\n * enough credits) */\nstatic ssize_t ext3_quota_write(struct super_block *sb, int type,\n\t\t\t\tconst char *data, size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tsector_t blk = off >> EXT3_BLOCK_SIZE_BITS(sb);\n\tint err = 0;\n\tint offset = off & (sb->s_blocksize - 1);\n\tint journal_quota = EXT3_SB(sb)->s_qf_names[type] != NULL;\n\tstruct buffer_head *bh;\n\thandle_t *handle = journal_current_handle();\n\n\tif (!handle) {\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: quota write (off=%llu, len=%llu)\"\n\t\t\t\" cancelled because transaction is not started.\",\n\t\t\t(unsigned long long)off, (unsigned long long)len);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * Since we account only one data block in transaction credits,\n\t * then it is impossible to cross a block boundary.\n\t */\n\tif (sb->s_blocksize - offset < len) {\n\t\text3_msg(sb, KERN_WARNING, \"Quota write (off=%llu, len=%llu)\"\n\t\t\t\" cancelled because not block aligned\",\n\t\t\t(unsigned long long)off, (unsigned long long)len);\n\t\treturn -EIO;\n\t}\n\tbh = ext3_bread(handle, inode, blk, 1, &err);\n\tif (!bh)\n\t\tgoto out;\n\tif (journal_quota) {\n\t\terr = ext3_journal_get_write_access(handle, bh);\n\t\tif (err) {\n\t\t\tbrelse(bh);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tlock_buffer(bh);\n\tmemcpy(bh->b_data+offset, data, len);\n\tflush_dcache_page(bh->b_page);\n\tunlock_buffer(bh);\n\tif (journal_quota)\n\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\telse {\n\t\t/* Always do at least ordered writes for quotas */\n\t\terr = ext3_journal_dirty_data(handle, bh);\n\t\tmark_buffer_dirty(bh);\n\t}\n\tbrelse(bh);\nout:\n\tif (err)\n\t\treturn err;\n\tif (inode->i_size < off + len) {\n\t\ti_size_write(inode, off + len);\n\t\tEXT3_I(inode)->i_disksize = inode->i_size;\n\t}\n\tinode->i_version++;\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\text3_mark_inode_dirty(handle, inode);\n\treturn len;\n}\n\n#endif\n\nstatic struct dentry *ext3_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, ext3_fill_super);\n}\n\nstatic struct file_system_type ext3_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ext3\",\n\t.mount\t\t= ext3_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"ext3\");\n\nstatic int __init init_ext3_fs(void)\n{\n\tint err = init_ext3_xattr();\n\tif (err)\n\t\treturn err;\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n        err = register_filesystem(&ext3_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\texit_ext3_xattr();\n\treturn err;\n}\n\nstatic void __exit exit_ext3_fs(void)\n{\n\tunregister_filesystem(&ext3_fs_type);\n\tdestroy_inodecache();\n\texit_ext3_xattr();\n}\n\nMODULE_AUTHOR(\"Remy Card, Stephen Tweedie, Andrew Morton, Andreas Dilger, Theodore Ts'o and others\");\nMODULE_DESCRIPTION(\"Second Extended Filesystem with journaling extensions\");\nMODULE_LICENSE(\"GPL\");\nmodule_init(init_ext3_fs)\nmodule_exit(exit_ext3_fs)\n"], "fixing_code": ["/*\n *  linux/fs/ext3/super.c\n *\n * Copyright (C) 1992, 1993, 1994, 1995\n * Remy Card (card@masi.ibp.fr)\n * Laboratoire MASI - Institut Blaise Pascal\n * Universite Pierre et Marie Curie (Paris VI)\n *\n *  from\n *\n *  linux/fs/minix/inode.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n *\n *  Big-endian to little-endian byte-swapping/bitmaps by\n *        David S. Miller (davem@caip.rutgers.edu), 1995\n */\n\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/parser.h>\n#include <linux/exportfs.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/log2.h>\n#include <linux/cleancache.h>\n\n#include <asm/uaccess.h>\n\n#define CREATE_TRACE_POINTS\n\n#include \"ext3.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"namei.h\"\n\n#ifdef CONFIG_EXT3_DEFAULTS_TO_ORDERED\n  #define EXT3_MOUNT_DEFAULT_DATA_MODE EXT3_MOUNT_ORDERED_DATA\n#else\n  #define EXT3_MOUNT_DEFAULT_DATA_MODE EXT3_MOUNT_WRITEBACK_DATA\n#endif\n\nstatic int ext3_load_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t     unsigned long journal_devnum);\nstatic int ext3_create_journal(struct super_block *, struct ext3_super_block *,\n\t\t\t       unsigned int);\nstatic int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync);\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es);\nstatic void ext3_clear_journal_err(struct super_block * sb,\n\t\t\t\t   struct ext3_super_block * es);\nstatic int ext3_sync_fs(struct super_block *sb, int wait);\nstatic const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);\nstatic int ext3_remount (struct super_block * sb, int * flags, char * data);\nstatic int ext3_statfs (struct dentry * dentry, struct kstatfs * buf);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\n/*\n * Wrappers for journal_start/end.\n */\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks)\n{\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\n\t/* Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly. */\n\tjournal = EXT3_SB(sb)->s_journal;\n\tif (is_journal_aborted(journal)) {\n\t\text3_abort(sb, __func__,\n\t\t\t   \"Detected aborted journal\");\n\t\treturn ERR_PTR(-EROFS);\n\t}\n\n\treturn journal_start(journal, nblocks);\n}\n\nint __ext3_journal_stop(const char *where, handle_t *handle)\n{\n\tstruct super_block *sb;\n\tint err;\n\tint rc;\n\n\tsb = handle->h_transaction->t_journal->j_private;\n\terr = handle->h_err;\n\trc = journal_stop(handle);\n\n\tif (!err)\n\t\terr = rc;\n\tif (err)\n\t\t__ext3_std_error(sb, where, err);\n\treturn err;\n}\n\nvoid ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext3_decode_error(NULL, err, nbuf);\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT3-fs: %s: aborting transaction: %s in %s\\n\",\n\t\tcaller, errstr, err_fn);\n\n\tjournal_abort_handle(handle);\n}\n\nvoid ext3_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT3-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}\n\n/* Deal with the reporting of failure conditions on a filesystem such as\n * inconsistencies detected or read IO failures.\n *\n * On ext2, we can store the error state of the filesystem in the\n * superblock.  That is not possible on ext3, because we may have other\n * write ordering constraints on the superblock which prevent us from\n * writing it out straight away; and given that the journal is about to\n * be aborted, we can't rely on the current, or future, transactions to\n * write out the superblock safely.\n *\n * We'll just use the journal_abort() error code to record an error in\n * the journal instead.  On recovery, the journal will complain about\n * that error until we've noted it down and cleared it.\n */\n\nstatic void ext3_handle_error(struct super_block *sb)\n{\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\n\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\tes->s_state |= cpu_to_le16(EXT3_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tif (!test_opt (sb, ERRORS_CONT)) {\n\t\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\n\t\tset_opt(EXT3_SB(sb)->s_mount_opt, ABORT);\n\t\tif (journal)\n\t\t\tjournal_abort(journal, -EIO);\n\t}\n\tif (test_opt (sb, ERRORS_RO)) {\n\t\text3_msg(sb, KERN_CRIT,\n\t\t\t\"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\text3_commit_super(sb, es, 1);\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT3-fs (%s): panic forced after error\\n\",\n\t\t\tsb->s_id);\n}\n\nvoid ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}\n\nstatic const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16])\n{\n\tchar *errstr = NULL;\n\n\tswitch (errno) {\n\tcase -EIO:\n\t\terrstr = \"IO failure\";\n\t\tbreak;\n\tcase -ENOMEM:\n\t\terrstr = \"Out of memory\";\n\t\tbreak;\n\tcase -EROFS:\n\t\tif (!sb || EXT3_SB(sb)->s_journal->j_flags & JFS_ABORT)\n\t\t\terrstr = \"Journal has aborted\";\n\t\telse\n\t\t\terrstr = \"Readonly filesystem\";\n\t\tbreak;\n\tdefault:\n\t\t/* If the caller passed in an extra buffer for unknown\n\t\t * errors, textualise them now.  Else we just return\n\t\t * NULL. */\n\t\tif (nbuf) {\n\t\t\t/* Check for truncated error codes... */\n\t\t\tif (snprintf(nbuf, 16, \"error %d\", -errno) >= 0)\n\t\t\t\terrstr = nbuf;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn errstr;\n}\n\n/* __ext3_std_error decodes expected errors from journaling functions\n * automatically and invokes the appropriate error response.  */\n\nvoid __ext3_std_error (struct super_block * sb, const char * function,\n\t\t       int errno)\n{\n\tchar nbuf[16];\n\tconst char *errstr;\n\n\t/* Special case: if the error is EROFS, and we're not already\n\t * inside a transaction, then there's really no point in logging\n\t * an error. */\n\tif (errno == -EROFS && journal_current_handle() == NULL &&\n\t    (sb->s_flags & MS_RDONLY))\n\t\treturn;\n\n\terrstr = ext3_decode_error(sb, errno, nbuf);\n\text3_msg(sb, KERN_CRIT, \"error in %s: %s\", function, errstr);\n\n\text3_handle_error(sb);\n}\n\n/*\n * ext3_abort is a much stronger failure handler than ext3_error.  The\n * abort function may be used to deal with unrecoverable failures such\n * as journal IO errors or ENOMEM at a critical moment in log management.\n *\n * We unconditionally force the filesystem into an ABORT|READONLY state,\n * unless the error response on the fs has been set to panic in which\n * case we take the easy way out and panic immediately.\n */\n\nvoid ext3_abort(struct super_block *sb, const char *function,\n\t\t const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT3-fs: panic from previous error\\n\");\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\text3_msg(sb, KERN_CRIT,\n\t\t\"error: remounting filesystem read-only\");\n\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\tsb->s_flags |= MS_RDONLY;\n\tset_opt(EXT3_SB(sb)->s_mount_opt, ABORT);\n\tif (EXT3_SB(sb)->s_journal)\n\t\tjournal_abort(EXT3_SB(sb)->s_journal, -EIO);\n}\n\nvoid ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}\n\nvoid ext3_update_dynamic_rev(struct super_block *sb)\n{\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT3_GOOD_OLD_REV)\n\t\treturn;\n\n\text3_msg(sb, KERN_WARNING,\n\t\t\"warning: updating to rev %d because of \"\n\t\t\"new feature flag, running e2fsck is recommended\",\n\t\tEXT3_DYNAMIC_REV);\n\n\tes->s_first_ino = cpu_to_le32(EXT3_GOOD_OLD_FIRST_INO);\n\tes->s_inode_size = cpu_to_le16(EXT3_GOOD_OLD_INODE_SIZE);\n\tes->s_rev_level = cpu_to_le32(EXT3_DYNAMIC_REV);\n\t/* leave es->s_feature_*compat flags alone */\n\t/* es->s_uuid will be set by e2fsck if empty */\n\n\t/*\n\t * The rest of the superblock fields should be zero, and if not it\n\t * means they are likely already in use, so leave them alone.  We\n\t * can leave it up to e2fsck to clean up any inconsistencies there.\n\t */\n}\n\n/*\n * Open the external journal device\n */\nstatic struct block_device *ext3_blkdev_get(dev_t dev, struct super_block *sb)\n{\n\tstruct block_device *bdev;\n\tchar b[BDEVNAME_SIZE];\n\n\tbdev = blkdev_get_by_dev(dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL, sb);\n\tif (IS_ERR(bdev))\n\t\tgoto fail;\n\treturn bdev;\n\nfail:\n\text3_msg(sb, KERN_ERR, \"error: failed to open journal device %s: %ld\",\n\t\t__bdevname(dev, b), PTR_ERR(bdev));\n\n\treturn NULL;\n}\n\n/*\n * Release the journal device\n */\nstatic int ext3_blkdev_put(struct block_device *bdev)\n{\n\treturn blkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n}\n\nstatic int ext3_blkdev_remove(struct ext3_sb_info *sbi)\n{\n\tstruct block_device *bdev;\n\tint ret = -ENODEV;\n\n\tbdev = sbi->journal_bdev;\n\tif (bdev) {\n\t\tret = ext3_blkdev_put(bdev);\n\t\tsbi->journal_bdev = NULL;\n\t}\n\treturn ret;\n}\n\nstatic inline struct inode *orphan_list_entry(struct list_head *l)\n{\n\treturn &list_entry(l, struct ext3_inode_info, i_orphan)->vfs_inode;\n}\n\nstatic void dump_orphan_list(struct super_block *sb, struct ext3_sb_info *sbi)\n{\n\tstruct list_head *l;\n\n\text3_msg(sb, KERN_ERR, \"error: sb orphan head is %d\",\n\t       le32_to_cpu(sbi->s_es->s_last_orphan));\n\n\text3_msg(sb, KERN_ERR, \"sb_info orphan list:\");\n\tlist_for_each(l, &sbi->s_orphan) {\n\t\tstruct inode *inode = orphan_list_entry(l);\n\t\text3_msg(sb, KERN_ERR, \"  \"\n\t\t       \"inode %s:%lu at %p: mode %o, nlink %d, next %d\\n\",\n\t\t       inode->i_sb->s_id, inode->i_ino, inode,\n\t\t       inode->i_mode, inode->i_nlink,\n\t\t       NEXT_ORPHAN(inode));\n\t}\n}\n\nstatic void ext3_put_super (struct super_block * sb)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tstruct ext3_super_block *es = sbi->s_es;\n\tint i, err;\n\n\tdquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\text3_xattr_put_super(sb);\n\terr = journal_destroy(sbi->s_journal);\n\tsbi->s_journal = NULL;\n\tif (err < 0)\n\t\text3_abort(sb, __func__, \"Couldn't clean up the journal\");\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tEXT3_CLEAR_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"marking dirty\");\n\t\tmark_buffer_dirty(sbi->s_sbh);\n\t\text3_commit_super(sb, es, 1);\n\t}\n\n\tfor (i = 0; i < sbi->s_gdb_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tbrelse(sbi->s_sbh);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\n\t/* Debugging code just in case the in-memory inode orphan list\n\t * isn't empty.  The on-disk one can be non-empty if we've\n\t * detected an error and taken the fs readonly, but the\n\t * in-memory list had better be clean by this point. */\n\tif (!list_empty(&sbi->s_orphan))\n\t\tdump_orphan_list(sb, sbi);\n\tJ_ASSERT(list_empty(&sbi->s_orphan));\n\n\tinvalidate_bdev(sb->s_bdev);\n\tif (sbi->journal_bdev && sbi->journal_bdev != sb->s_bdev) {\n\t\t/*\n\t\t * Invalidate the journal device's buffers.  We don't want them\n\t\t * floating about in memory - the physical journal device may\n\t\t * hotswapped, and it breaks the `ro-after' testing code.\n\t\t */\n\t\tsync_blockdev(sbi->journal_bdev);\n\t\tinvalidate_bdev(sbi->journal_bdev);\n\t\text3_blkdev_remove(sbi);\n\t}\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\n}\n\nstatic struct kmem_cache *ext3_inode_cachep;\n\n/*\n * Called inside transaction, so use GFP_NOFS\n */\nstatic struct inode *ext3_alloc_inode(struct super_block *sb)\n{\n\tstruct ext3_inode_info *ei;\n\n\tei = kmem_cache_alloc(ext3_inode_cachep, GFP_NOFS);\n\tif (!ei)\n\t\treturn NULL;\n\tei->i_block_alloc_info = NULL;\n\tei->vfs_inode.i_version = 1;\n\tatomic_set(&ei->i_datasync_tid, 0);\n\tatomic_set(&ei->i_sync_tid, 0);\n\treturn &ei->vfs_inode;\n}\n\nstatic int ext3_drop_inode(struct inode *inode)\n{\n\tint drop = generic_drop_inode(inode);\n\n\ttrace_ext3_drop_inode(inode, drop);\n\treturn drop;\n}\n\nstatic void ext3_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(ext3_inode_cachep, EXT3_I(inode));\n}\n\nstatic void ext3_destroy_inode(struct inode *inode)\n{\n\tif (!list_empty(&(EXT3_I(inode)->i_orphan))) {\n\t\tprintk(\"EXT3 Inode %p: orphan list check failed!\\n\",\n\t\t\tEXT3_I(inode));\n\t\tprint_hex_dump(KERN_INFO, \"\", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\tEXT3_I(inode), sizeof(struct ext3_inode_info),\n\t\t\t\tfalse);\n\t\tdump_stack();\n\t}\n\tcall_rcu(&inode->i_rcu, ext3_i_callback);\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct ext3_inode_info *ei = (struct ext3_inode_info *) foo;\n\n\tINIT_LIST_HEAD(&ei->i_orphan);\n#ifdef CONFIG_EXT3_FS_XATTR\n\tinit_rwsem(&ei->xattr_sem);\n#endif\n\tmutex_init(&ei->truncate_mutex);\n\tinode_init_once(&ei->vfs_inode);\n}\n\nstatic int init_inodecache(void)\n{\n\text3_inode_cachep = kmem_cache_create(\"ext3_inode_cache\",\n\t\t\t\t\t     sizeof(struct ext3_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (ext3_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ext3_inode_cachep);\n}\n\nstatic inline void ext3_show_quota_options(struct seq_file *seq, struct super_block *sb)\n{\n#if defined(CONFIG_QUOTA)\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (sbi->s_jquota_fmt) {\n\t\tchar *fmtname = \"\";\n\n\t\tswitch (sbi->s_jquota_fmt) {\n\t\tcase QFMT_VFS_OLD:\n\t\t\tfmtname = \"vfsold\";\n\t\t\tbreak;\n\t\tcase QFMT_VFS_V0:\n\t\t\tfmtname = \"vfsv0\";\n\t\t\tbreak;\n\t\tcase QFMT_VFS_V1:\n\t\t\tfmtname = \"vfsv1\";\n\t\t\tbreak;\n\t\t}\n\t\tseq_printf(seq, \",jqfmt=%s\", fmtname);\n\t}\n\n\tif (sbi->s_qf_names[USRQUOTA])\n\t\tseq_printf(seq, \",usrjquota=%s\", sbi->s_qf_names[USRQUOTA]);\n\n\tif (sbi->s_qf_names[GRPQUOTA])\n\t\tseq_printf(seq, \",grpjquota=%s\", sbi->s_qf_names[GRPQUOTA]);\n\n\tif (test_opt(sb, USRQUOTA))\n\t\tseq_puts(seq, \",usrquota\");\n\n\tif (test_opt(sb, GRPQUOTA))\n\t\tseq_puts(seq, \",grpquota\");\n#endif\n}\n\nstatic char *data_mode_string(unsigned long mode)\n{\n\tswitch (mode) {\n\tcase EXT3_MOUNT_JOURNAL_DATA:\n\t\treturn \"journal\";\n\tcase EXT3_MOUNT_ORDERED_DATA:\n\t\treturn \"ordered\";\n\tcase EXT3_MOUNT_WRITEBACK_DATA:\n\t\treturn \"writeback\";\n\t}\n\treturn \"unknown\";\n}\n\n/*\n * Show an option if\n *  - it's set to a non-default value OR\n *  - if the per-sb default is different from the global default\n */\nstatic int ext3_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct super_block *sb = root->d_sb;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tstruct ext3_super_block *es = sbi->s_es;\n\tunsigned long def_mount_opts;\n\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\n\tif (sbi->s_sb_block != 1)\n\t\tseq_printf(seq, \",sb=%lu\", sbi->s_sb_block);\n\tif (test_opt(sb, MINIX_DF))\n\t\tseq_puts(seq, \",minixdf\");\n\tif (test_opt(sb, GRPID))\n\t\tseq_puts(seq, \",grpid\");\n\tif (!test_opt(sb, GRPID) && (def_mount_opts & EXT3_DEFM_BSDGROUPS))\n\t\tseq_puts(seq, \",nogrpid\");\n\tif (!uid_eq(sbi->s_resuid, make_kuid(&init_user_ns, EXT3_DEF_RESUID)) ||\n\t    le16_to_cpu(es->s_def_resuid) != EXT3_DEF_RESUID) {\n\t\tseq_printf(seq, \",resuid=%u\",\n\t\t\t\tfrom_kuid_munged(&init_user_ns, sbi->s_resuid));\n\t}\n\tif (!gid_eq(sbi->s_resgid, make_kgid(&init_user_ns, EXT3_DEF_RESGID)) ||\n\t    le16_to_cpu(es->s_def_resgid) != EXT3_DEF_RESGID) {\n\t\tseq_printf(seq, \",resgid=%u\",\n\t\t\t\tfrom_kgid_munged(&init_user_ns, sbi->s_resgid));\n\t}\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\tint def_errors = le16_to_cpu(es->s_errors);\n\n\t\tif (def_errors == EXT3_ERRORS_PANIC ||\n\t\t    def_errors == EXT3_ERRORS_CONTINUE) {\n\t\t\tseq_puts(seq, \",errors=remount-ro\");\n\t\t}\n\t}\n\tif (test_opt(sb, ERRORS_CONT))\n\t\tseq_puts(seq, \",errors=continue\");\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tseq_puts(seq, \",errors=panic\");\n\tif (test_opt(sb, NO_UID32))\n\t\tseq_puts(seq, \",nouid32\");\n\tif (test_opt(sb, DEBUG))\n\t\tseq_puts(seq, \",debug\");\n#ifdef CONFIG_EXT3_FS_XATTR\n\tif (test_opt(sb, XATTR_USER))\n\t\tseq_puts(seq, \",user_xattr\");\n\tif (!test_opt(sb, XATTR_USER) &&\n\t    (def_mount_opts & EXT3_DEFM_XATTR_USER)) {\n\t\tseq_puts(seq, \",nouser_xattr\");\n\t}\n#endif\n#ifdef CONFIG_EXT3_FS_POSIX_ACL\n\tif (test_opt(sb, POSIX_ACL))\n\t\tseq_puts(seq, \",acl\");\n\tif (!test_opt(sb, POSIX_ACL) && (def_mount_opts & EXT3_DEFM_ACL))\n\t\tseq_puts(seq, \",noacl\");\n#endif\n\tif (!test_opt(sb, RESERVATION))\n\t\tseq_puts(seq, \",noreservation\");\n\tif (sbi->s_commit_interval) {\n\t\tseq_printf(seq, \",commit=%u\",\n\t\t\t   (unsigned) (sbi->s_commit_interval / HZ));\n\t}\n\n\t/*\n\t * Always display barrier state so it's clear what the status is.\n\t */\n\tseq_puts(seq, \",barrier=\");\n\tseq_puts(seq, test_opt(sb, BARRIER) ? \"1\" : \"0\");\n\tseq_printf(seq, \",data=%s\", data_mode_string(test_opt(sb, DATA_FLAGS)));\n\tif (test_opt(sb, DATA_ERR_ABORT))\n\t\tseq_puts(seq, \",data_err=abort\");\n\n\tif (test_opt(sb, NOLOAD))\n\t\tseq_puts(seq, \",norecovery\");\n\n\text3_show_quota_options(seq, sb);\n\n\treturn 0;\n}\n\n\nstatic struct inode *ext3_nfs_get_inode(struct super_block *sb,\n\t\tu64 ino, u32 generation)\n{\n\tstruct inode *inode;\n\n\tif (ino < EXT3_FIRST_INO(sb) && ino != EXT3_ROOT_INO)\n\t\treturn ERR_PTR(-ESTALE);\n\tif (ino > le32_to_cpu(EXT3_SB(sb)->s_es->s_inodes_count))\n\t\treturn ERR_PTR(-ESTALE);\n\n\t/* iget isn't really right if the inode is currently unallocated!!\n\t *\n\t * ext3_read_inode will return a bad_inode if the inode had been\n\t * deleted, so we should be safe.\n\t *\n\t * Currently we don't know the generation for parent directory, so\n\t * a generation of 0 means \"accept any\"\n\t */\n\tinode = ext3_iget(sb, ino);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tif (generation && inode->i_generation != generation) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\treturn inode;\n}\n\nstatic struct dentry *ext3_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    ext3_nfs_get_inode);\n}\n\nstatic struct dentry *ext3_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    ext3_nfs_get_inode);\n}\n\n/*\n * Try to release metadata pages (indirect blocks, directories) which are\n * mapped via the block device.  Since these pages could have journal heads\n * which would prevent try_to_free_buffers() from freeing them, we must use\n * jbd layer's try_to_free_buffers() function to release them.\n */\nstatic int bdev_try_to_free_page(struct super_block *sb, struct page *page,\n\t\t\t\t gfp_t wait)\n{\n\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\n\tWARN_ON(PageChecked(page));\n\tif (!page_has_buffers(page))\n\t\treturn 0;\n\tif (journal)\n\t\treturn journal_try_to_free_buffers(journal, page, \n\t\t\t\t\t\t   wait & ~__GFP_WAIT);\n\treturn try_to_free_buffers(page);\n}\n\n#ifdef CONFIG_QUOTA\n#define QTYPE2NAME(t) ((t)==USRQUOTA?\"user\":\"group\")\n#define QTYPE2MOPT(on, t) ((t)==USRQUOTA?((on)##USRJQUOTA):((on)##GRPJQUOTA))\n\nstatic int ext3_write_dquot(struct dquot *dquot);\nstatic int ext3_acquire_dquot(struct dquot *dquot);\nstatic int ext3_release_dquot(struct dquot *dquot);\nstatic int ext3_mark_dquot_dirty(struct dquot *dquot);\nstatic int ext3_write_info(struct super_block *sb, int type);\nstatic int ext3_quota_on(struct super_block *sb, int type, int format_id,\n\t\t\t struct path *path);\nstatic int ext3_quota_on_mount(struct super_block *sb, int type);\nstatic ssize_t ext3_quota_read(struct super_block *sb, int type, char *data,\n\t\t\t       size_t len, loff_t off);\nstatic ssize_t ext3_quota_write(struct super_block *sb, int type,\n\t\t\t\tconst char *data, size_t len, loff_t off);\n\nstatic const struct dquot_operations ext3_quota_operations = {\n\t.write_dquot\t= ext3_write_dquot,\n\t.acquire_dquot\t= ext3_acquire_dquot,\n\t.release_dquot\t= ext3_release_dquot,\n\t.mark_dirty\t= ext3_mark_dquot_dirty,\n\t.write_info\t= ext3_write_info,\n\t.alloc_dquot\t= dquot_alloc,\n\t.destroy_dquot\t= dquot_destroy,\n};\n\nstatic const struct quotactl_ops ext3_qctl_operations = {\n\t.quota_on\t= ext3_quota_on,\n\t.quota_off\t= dquot_quota_off,\n\t.quota_sync\t= dquot_quota_sync,\n\t.get_info\t= dquot_get_dqinfo,\n\t.set_info\t= dquot_set_dqinfo,\n\t.get_dqblk\t= dquot_get_dqblk,\n\t.set_dqblk\t= dquot_set_dqblk\n};\n#endif\n\nstatic const struct super_operations ext3_sops = {\n\t.alloc_inode\t= ext3_alloc_inode,\n\t.destroy_inode\t= ext3_destroy_inode,\n\t.write_inode\t= ext3_write_inode,\n\t.dirty_inode\t= ext3_dirty_inode,\n\t.drop_inode\t= ext3_drop_inode,\n\t.evict_inode\t= ext3_evict_inode,\n\t.put_super\t= ext3_put_super,\n\t.sync_fs\t= ext3_sync_fs,\n\t.freeze_fs\t= ext3_freeze,\n\t.unfreeze_fs\t= ext3_unfreeze,\n\t.statfs\t\t= ext3_statfs,\n\t.remount_fs\t= ext3_remount,\n\t.show_options\t= ext3_show_options,\n#ifdef CONFIG_QUOTA\n\t.quota_read\t= ext3_quota_read,\n\t.quota_write\t= ext3_quota_write,\n#endif\n\t.bdev_try_to_free_page = bdev_try_to_free_page,\n};\n\nstatic const struct export_operations ext3_export_ops = {\n\t.fh_to_dentry = ext3_fh_to_dentry,\n\t.fh_to_parent = ext3_fh_to_parent,\n\t.get_parent = ext3_get_parent,\n};\n\nenum {\n\tOpt_bsd_df, Opt_minix_df, Opt_grpid, Opt_nogrpid,\n\tOpt_resgid, Opt_resuid, Opt_sb, Opt_err_cont, Opt_err_panic, Opt_err_ro,\n\tOpt_nouid32, Opt_nocheck, Opt_debug, Opt_oldalloc, Opt_orlov,\n\tOpt_user_xattr, Opt_nouser_xattr, Opt_acl, Opt_noacl,\n\tOpt_reservation, Opt_noreservation, Opt_noload, Opt_nobh, Opt_bh,\n\tOpt_commit, Opt_journal_update, Opt_journal_inum, Opt_journal_dev,\n\tOpt_abort, Opt_data_journal, Opt_data_ordered, Opt_data_writeback,\n\tOpt_data_err_abort, Opt_data_err_ignore,\n\tOpt_usrjquota, Opt_grpjquota, Opt_offusrjquota, Opt_offgrpjquota,\n\tOpt_jqfmt_vfsold, Opt_jqfmt_vfsv0, Opt_jqfmt_vfsv1, Opt_quota,\n\tOpt_noquota, Opt_ignore, Opt_barrier, Opt_nobarrier, Opt_err,\n\tOpt_resize, Opt_usrquota, Opt_grpquota\n};\n\nstatic const match_table_t tokens = {\n\t{Opt_bsd_df, \"bsddf\"},\n\t{Opt_minix_df, \"minixdf\"},\n\t{Opt_grpid, \"grpid\"},\n\t{Opt_grpid, \"bsdgroups\"},\n\t{Opt_nogrpid, \"nogrpid\"},\n\t{Opt_nogrpid, \"sysvgroups\"},\n\t{Opt_resgid, \"resgid=%u\"},\n\t{Opt_resuid, \"resuid=%u\"},\n\t{Opt_sb, \"sb=%u\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_nouid32, \"nouid32\"},\n\t{Opt_nocheck, \"nocheck\"},\n\t{Opt_nocheck, \"check=none\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_oldalloc, \"oldalloc\"},\n\t{Opt_orlov, \"orlov\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_reservation, \"reservation\"},\n\t{Opt_noreservation, \"noreservation\"},\n\t{Opt_noload, \"noload\"},\n\t{Opt_noload, \"norecovery\"},\n\t{Opt_nobh, \"nobh\"},\n\t{Opt_bh, \"bh\"},\n\t{Opt_commit, \"commit=%u\"},\n\t{Opt_journal_update, \"journal=update\"},\n\t{Opt_journal_inum, \"journal=%u\"},\n\t{Opt_journal_dev, \"journal_dev=%u\"},\n\t{Opt_abort, \"abort\"},\n\t{Opt_data_journal, \"data=journal\"},\n\t{Opt_data_ordered, \"data=ordered\"},\n\t{Opt_data_writeback, \"data=writeback\"},\n\t{Opt_data_err_abort, \"data_err=abort\"},\n\t{Opt_data_err_ignore, \"data_err=ignore\"},\n\t{Opt_offusrjquota, \"usrjquota=\"},\n\t{Opt_usrjquota, \"usrjquota=%s\"},\n\t{Opt_offgrpjquota, \"grpjquota=\"},\n\t{Opt_grpjquota, \"grpjquota=%s\"},\n\t{Opt_jqfmt_vfsold, \"jqfmt=vfsold\"},\n\t{Opt_jqfmt_vfsv0, \"jqfmt=vfsv0\"},\n\t{Opt_jqfmt_vfsv1, \"jqfmt=vfsv1\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_noquota, \"noquota\"},\n\t{Opt_quota, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_barrier, \"barrier=%u\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_resize, \"resize\"},\n\t{Opt_err, NULL},\n};\n\nstatic ext3_fsblk_t get_sb_block(void **data, struct super_block *sb)\n{\n\text3_fsblk_t\tsb_block;\n\tchar\t\t*options = (char *) *data;\n\n\tif (!options || strncmp(options, \"sb=\", 3) != 0)\n\t\treturn 1;\t/* Default location */\n\toptions += 3;\n\t/*todo: use simple_strtoll with >32bit ext3 */\n\tsb_block = simple_strtoul(options, &options, 0);\n\tif (*options && *options != ',') {\n\t\text3_msg(sb, KERN_ERR, \"error: invalid sb specification: %s\",\n\t\t       (char *) *data);\n\t\treturn 1;\n\t}\n\tif (*options == ',')\n\t\toptions++;\n\t*data = (void *) options;\n\treturn sb_block;\n}\n\n#ifdef CONFIG_QUOTA\nstatic int set_qf_name(struct super_block *sb, int qtype, substring_t *args)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tchar *qname;\n\n\tif (sb_any_quota_loaded(sb) &&\n\t\t!sbi->s_qf_names[qtype]) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"Cannot change journaled \"\n\t\t\t\"quota options when quota turned on\");\n\t\treturn 0;\n\t}\n\tqname = match_strdup(args);\n\tif (!qname) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"Not enough memory for storing quotafile name\");\n\t\treturn 0;\n\t}\n\tif (sbi->s_qf_names[qtype]) {\n\t\tint same = !strcmp(sbi->s_qf_names[qtype], qname);\n\n\t\tkfree(qname);\n\t\tif (!same) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t \"%s quota file already specified\",\n\t\t\t\t QTYPE2NAME(qtype));\n\t\t}\n\t\treturn same;\n\t}\n\tif (strchr(qname, '/')) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"quotafile must be on filesystem root\");\n\t\tkfree(qname);\n\t\treturn 0;\n\t}\n\tsbi->s_qf_names[qtype] = qname;\n\tset_opt(sbi->s_mount_opt, QUOTA);\n\treturn 1;\n}\n\nstatic int clear_qf_name(struct super_block *sb, int qtype) {\n\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (sb_any_quota_loaded(sb) &&\n\t\tsbi->s_qf_names[qtype]) {\n\t\text3_msg(sb, KERN_ERR, \"Cannot change journaled quota options\"\n\t\t\t\" when quota turned on\");\n\t\treturn 0;\n\t}\n\tif (sbi->s_qf_names[qtype]) {\n\t\tkfree(sbi->s_qf_names[qtype]);\n\t\tsbi->s_qf_names[qtype] = NULL;\n\t}\n\treturn 1;\n}\n#endif\n\nstatic int parse_options (char *options, struct super_block *sb,\n\t\t\t  unsigned int *inum, unsigned long *journal_devnum,\n\t\t\t  ext3_fsblk_t *n_blocks_count, int is_remount)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tchar * p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint data_opt = 0;\n\tint option;\n\tkuid_t uid;\n\tkgid_t gid;\n#ifdef CONFIG_QUOTA\n\tint qfmt;\n#endif\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep (&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Initialize args struct so we know whether arg was\n\t\t * found; some options take optional arguments.\n\t\t */\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_bsd_df:\n\t\t\tclear_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_minix_df:\n\t\t\tset_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_grpid:\n\t\t\tset_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_nogrpid:\n\t\t\tclear_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_resuid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid)) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"Invalid uid value %d\", option);\n\t\t\t\treturn 0;\n\n\t\t\t}\n\t\t\tsbi->s_resuid = uid;\n\t\t\tbreak;\n\t\tcase Opt_resgid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid)) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"Invalid gid value %d\", option);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->s_resgid = gid;\n\t\t\tbreak;\n\t\tcase Opt_sb:\n\t\t\t/* handled by get_sb_block() instead of here */\n\t\t\t/* *sb_block = match_int(&args[0]); */\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tbreak;\n\t\tcase Opt_nouid32:\n\t\t\tset_opt (sbi->s_mount_opt, NO_UID32);\n\t\t\tbreak;\n\t\tcase Opt_nocheck:\n\t\t\tclear_opt (sbi->s_mount_opt, CHECK);\n\t\t\tbreak;\n\t\tcase Opt_debug:\n\t\t\tset_opt (sbi->s_mount_opt, DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_oldalloc:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"Ignoring deprecated oldalloc option\");\n\t\t\tbreak;\n\t\tcase Opt_orlov:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"Ignoring deprecated orlov option\");\n\t\t\tbreak;\n#ifdef CONFIG_EXT3_FS_XATTR\n\t\tcase Opt_user_xattr:\n\t\t\tset_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tclear_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n#else\n\t\tcase Opt_user_xattr:\n\t\tcase Opt_nouser_xattr:\n\t\t\text3_msg(sb, KERN_INFO,\n\t\t\t\t\"(no)user_xattr options not supported\");\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_EXT3_FS_POSIX_ACL\n\t\tcase Opt_acl:\n\t\t\tset_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tclear_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n#else\n\t\tcase Opt_acl:\n\t\tcase Opt_noacl:\n\t\t\text3_msg(sb, KERN_INFO,\n\t\t\t\t\"(no)acl options not supported\");\n\t\t\tbreak;\n#endif\n\t\tcase Opt_reservation:\n\t\t\tset_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\tbreak;\n\t\tcase Opt_noreservation:\n\t\t\tclear_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\tbreak;\n\t\tcase Opt_journal_update:\n\t\t\t/* @@@ FIXME */\n\t\t\t/* Eventually we will want to be able to create\n\t\t\t   a journal file here.  For now, only allow the\n\t\t\t   user to specify an existing inode to be the\n\t\t\t   journal file. */\n\t\t\tif (is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot specify \"\n\t\t\t\t\t\"journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tset_opt (sbi->s_mount_opt, UPDATE_JOURNAL);\n\t\t\tbreak;\n\t\tcase Opt_journal_inum:\n\t\t\tif (is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot specify \"\n\t\t\t\t       \"journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*inum = option;\n\t\t\tbreak;\n\t\tcase Opt_journal_dev:\n\t\t\tif (is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot specify \"\n\t\t\t\t       \"journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*journal_devnum = option;\n\t\t\tbreak;\n\t\tcase Opt_noload:\n\t\t\tset_opt (sbi->s_mount_opt, NOLOAD);\n\t\t\tbreak;\n\t\tcase Opt_commit:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tif (option < 0)\n\t\t\t\treturn 0;\n\t\t\tif (option == 0)\n\t\t\t\toption = JBD_DEFAULT_MAX_COMMIT_AGE;\n\t\t\tsbi->s_commit_interval = HZ * option;\n\t\t\tbreak;\n\t\tcase Opt_data_journal:\n\t\t\tdata_opt = EXT3_MOUNT_JOURNAL_DATA;\n\t\t\tgoto datacheck;\n\t\tcase Opt_data_ordered:\n\t\t\tdata_opt = EXT3_MOUNT_ORDERED_DATA;\n\t\t\tgoto datacheck;\n\t\tcase Opt_data_writeback:\n\t\t\tdata_opt = EXT3_MOUNT_WRITEBACK_DATA;\n\t\tdatacheck:\n\t\t\tif (is_remount) {\n\t\t\t\tif (test_opt(sb, DATA_FLAGS) == data_opt)\n\t\t\t\t\tbreak;\n\t\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: cannot change \"\n\t\t\t\t\t\"data mode on remount. The filesystem \"\n\t\t\t\t\t\"is mounted in data=%s mode and you \"\n\t\t\t\t\t\"try to remount it in data=%s mode.\",\n\t\t\t\t\tdata_mode_string(test_opt(sb,\n\t\t\t\t\t\t\tDATA_FLAGS)),\n\t\t\t\t\tdata_mode_string(data_opt));\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tclear_opt(sbi->s_mount_opt, DATA_FLAGS);\n\t\t\t\tsbi->s_mount_opt |= data_opt;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_data_err_abort:\n\t\t\tset_opt(sbi->s_mount_opt, DATA_ERR_ABORT);\n\t\t\tbreak;\n\t\tcase Opt_data_err_ignore:\n\t\t\tclear_opt(sbi->s_mount_opt, DATA_ERR_ABORT);\n\t\t\tbreak;\n#ifdef CONFIG_QUOTA\n\t\tcase Opt_usrjquota:\n\t\t\tif (!set_qf_name(sb, USRQUOTA, &args[0]))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_grpjquota:\n\t\t\tif (!set_qf_name(sb, GRPQUOTA, &args[0]))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_offusrjquota:\n\t\t\tif (!clear_qf_name(sb, USRQUOTA))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_offgrpjquota:\n\t\t\tif (!clear_qf_name(sb, GRPQUOTA))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_jqfmt_vfsold:\n\t\t\tqfmt = QFMT_VFS_OLD;\n\t\t\tgoto set_qf_format;\n\t\tcase Opt_jqfmt_vfsv0:\n\t\t\tqfmt = QFMT_VFS_V0;\n\t\t\tgoto set_qf_format;\n\t\tcase Opt_jqfmt_vfsv1:\n\t\t\tqfmt = QFMT_VFS_V1;\nset_qf_format:\n\t\t\tif (sb_any_quota_loaded(sb) &&\n\t\t\t    sbi->s_jquota_fmt != qfmt) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot change \"\n\t\t\t\t\t\"journaled quota options when \"\n\t\t\t\t\t\"quota turned on.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->s_jquota_fmt = qfmt;\n\t\t\tbreak;\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\t\tset_opt(sbi->s_mount_opt, QUOTA);\n\t\t\tset_opt(sbi->s_mount_opt, USRQUOTA);\n\t\t\tbreak;\n\t\tcase Opt_grpquota:\n\t\t\tset_opt(sbi->s_mount_opt, QUOTA);\n\t\t\tset_opt(sbi->s_mount_opt, GRPQUOTA);\n\t\t\tbreak;\n\t\tcase Opt_noquota:\n\t\t\tif (sb_any_quota_loaded(sb)) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: cannot change \"\n\t\t\t\t\t\"quota options when quota turned on.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tclear_opt(sbi->s_mount_opt, QUOTA);\n\t\t\tclear_opt(sbi->s_mount_opt, USRQUOTA);\n\t\t\tclear_opt(sbi->s_mount_opt, GRPQUOTA);\n\t\t\tbreak;\n#else\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\tcase Opt_grpquota:\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: quota options not supported.\");\n\t\t\tbreak;\n\t\tcase Opt_usrjquota:\n\t\tcase Opt_grpjquota:\n\t\tcase Opt_offusrjquota:\n\t\tcase Opt_offgrpjquota:\n\t\tcase Opt_jqfmt_vfsold:\n\t\tcase Opt_jqfmt_vfsv0:\n\t\tcase Opt_jqfmt_vfsv1:\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: journaled quota options not \"\n\t\t\t\t\"supported.\");\n\t\t\tbreak;\n\t\tcase Opt_noquota:\n\t\t\tbreak;\n#endif\n\t\tcase Opt_abort:\n\t\t\tset_opt(sbi->s_mount_opt, ABORT);\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tclear_opt(sbi->s_mount_opt, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_barrier:\n\t\t\tif (args[0].from) {\n\t\t\t\tif (match_int(&args[0], &option))\n\t\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\toption = 1;\t/* No argument, default to 1 */\n\t\t\tif (option)\n\t\t\t\tset_opt(sbi->s_mount_opt, BARRIER);\n\t\t\telse\n\t\t\t\tclear_opt(sbi->s_mount_opt, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\t\tcase Opt_resize:\n\t\t\tif (!is_remount) {\n\t\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: resize option only available \"\n\t\t\t\t\t\"for remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (match_int(&args[0], &option) != 0)\n\t\t\t\treturn 0;\n\t\t\t*n_blocks_count = option;\n\t\t\tbreak;\n\t\tcase Opt_nobh:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"warning: ignoring deprecated nobh option\");\n\t\t\tbreak;\n\t\tcase Opt_bh:\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"warning: ignoring deprecated bh option\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: unrecognized mount option \\\"%s\\\" \"\n\t\t\t\t\"or missing value\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n#ifdef CONFIG_QUOTA\n\tif (sbi->s_qf_names[USRQUOTA] || sbi->s_qf_names[GRPQUOTA]) {\n\t\tif (test_opt(sb, USRQUOTA) && sbi->s_qf_names[USRQUOTA])\n\t\t\tclear_opt(sbi->s_mount_opt, USRQUOTA);\n\t\tif (test_opt(sb, GRPQUOTA) && sbi->s_qf_names[GRPQUOTA])\n\t\t\tclear_opt(sbi->s_mount_opt, GRPQUOTA);\n\n\t\tif (test_opt(sb, GRPQUOTA) || test_opt(sb, USRQUOTA)) {\n\t\t\text3_msg(sb, KERN_ERR, \"error: old and new quota \"\n\t\t\t\t\t\"format mixing.\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!sbi->s_jquota_fmt) {\n\t\t\text3_msg(sb, KERN_ERR, \"error: journaled quota format \"\n\t\t\t\t\t\"not specified.\");\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (sbi->s_jquota_fmt) {\n\t\t\text3_msg(sb, KERN_ERR, \"error: journaled quota format \"\n\t\t\t\t\t\"specified with no journaling \"\n\t\t\t\t\t\"enabled.\");\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif\n\treturn 1;\n}\n\nstatic int ext3_setup_super(struct super_block *sb, struct ext3_super_block *es,\n\t\t\t    int read_only)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tint res = 0;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT3_MAX_SUPP_REV) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: revision level too high, \"\n\t\t\t\"forcing read-only mode\");\n\t\tres = MS_RDONLY;\n\t}\n\tif (read_only)\n\t\treturn res;\n\tif (!(sbi->s_mount_state & EXT3_VALID_FS))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting unchecked fs, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((sbi->s_mount_state & EXT3_ERROR_FS))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting fs with errors, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((__s16) le16_to_cpu(es->s_max_mnt_count) > 0 &&\n\t\t le16_to_cpu(es->s_mnt_count) >=\n\t\t\tle16_to_cpu(es->s_max_mnt_count))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: maximal mount count reached, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if (le32_to_cpu(es->s_checkinterval) &&\n\t\t(le32_to_cpu(es->s_lastcheck) +\n\t\t\tle32_to_cpu(es->s_checkinterval) <= get_seconds()))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: checktime reached, \"\n\t\t\t\"running e2fsck is recommended\");\n#if 0\n\t\t/* @@@ We _will_ want to clear the valid bit if we find\n                   inconsistencies, to force a fsck at reboot.  But for\n                   a plain journaled filesystem we can keep it set as\n                   valid forever! :) */\n\tes->s_state &= cpu_to_le16(~EXT3_VALID_FS);\n#endif\n\tif (!le16_to_cpu(es->s_max_mnt_count))\n\t\tes->s_max_mnt_count = cpu_to_le16(EXT3_DFL_MAX_MNT_COUNT);\n\tle16_add_cpu(&es->s_mnt_count, 1);\n\tes->s_mtime = cpu_to_le32(get_seconds());\n\text3_update_dynamic_rev(sb);\n\tEXT3_SET_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\n\text3_commit_super(sb, es, 1);\n\tif (test_opt(sb, DEBUG))\n\t\text3_msg(sb, KERN_INFO, \"[bs=%lu, gc=%lu, \"\n\t\t\t\t\"bpg=%lu, ipg=%lu, mo=%04lx]\",\n\t\t\tsb->s_blocksize,\n\t\t\tsbi->s_groups_count,\n\t\t\tEXT3_BLOCKS_PER_GROUP(sb),\n\t\t\tEXT3_INODES_PER_GROUP(sb),\n\t\t\tsbi->s_mount_opt);\n\n\tif (EXT3_SB(sb)->s_journal->j_inode == NULL) {\n\t\tchar b[BDEVNAME_SIZE];\n\t\text3_msg(sb, KERN_INFO, \"using external journal on %s\",\n\t\t\tbdevname(EXT3_SB(sb)->s_journal->j_dev, b));\n\t} else {\n\t\text3_msg(sb, KERN_INFO, \"using internal journal\");\n\t}\n\tcleancache_init_fs(sb);\n\treturn res;\n}\n\n/* Called at mount-time, super-block is locked */\nstatic int ext3_check_descriptors(struct super_block *sb)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tint i;\n\n\text3_debug (\"Checking group descriptors\");\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tstruct ext3_group_desc *gdp = ext3_get_group_desc(sb, i, NULL);\n\t\text3_fsblk_t first_block = ext3_group_first_block_no(sb, i);\n\t\text3_fsblk_t last_block;\n\n\t\tif (i == sbi->s_groups_count - 1)\n\t\t\tlast_block = le32_to_cpu(sbi->s_es->s_blocks_count) - 1;\n\t\telse\n\t\t\tlast_block = first_block +\n\t\t\t\t(EXT3_BLOCKS_PER_GROUP(sb) - 1);\n\n\t\tif (le32_to_cpu(gdp->bg_block_bitmap) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_block_bitmap) > last_block)\n\t\t{\n\t\t\text3_error (sb, \"ext3_check_descriptors\",\n\t\t\t\t    \"Block bitmap for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long)\n\t\t\t\t\tle32_to_cpu(gdp->bg_block_bitmap));\n\t\t\treturn 0;\n\t\t}\n\t\tif (le32_to_cpu(gdp->bg_inode_bitmap) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_inode_bitmap) > last_block)\n\t\t{\n\t\t\text3_error (sb, \"ext3_check_descriptors\",\n\t\t\t\t    \"Inode bitmap for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long)\n\t\t\t\t\tle32_to_cpu(gdp->bg_inode_bitmap));\n\t\t\treturn 0;\n\t\t}\n\t\tif (le32_to_cpu(gdp->bg_inode_table) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_inode_table) + sbi->s_itb_per_group - 1 >\n\t\t    last_block)\n\t\t{\n\t\t\text3_error (sb, \"ext3_check_descriptors\",\n\t\t\t\t    \"Inode table for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long)\n\t\t\t\t\tle32_to_cpu(gdp->bg_inode_table));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tsbi->s_es->s_free_blocks_count=cpu_to_le32(ext3_count_free_blocks(sb));\n\tsbi->s_es->s_free_inodes_count=cpu_to_le32(ext3_count_free_inodes(sb));\n\treturn 1;\n}\n\n\n/* ext3_orphan_cleanup() walks a singly-linked list of inodes (starting at\n * the superblock) which were deleted from all directories, but held open by\n * a process at the time of a crash.  We walk the list and try to delete these\n * inodes at recovery time (only with a read-write filesystem).\n *\n * In order to keep the orphan inode chain consistent during traversal (in\n * case of crash during recovery), we link each inode into the superblock\n * orphan list_head and handle it the same way as an inode deletion during\n * normal operation (which journals the operations for us).\n *\n * We only do an iget() and an iput() on each inode, which is very safe if we\n * accidentally point at an in-use or already deleted inode.  The worst that\n * can happen in this case is that we get a \"bit already cleared\" message from\n * ext3_free_inode().  The only reason we would point at a wrong inode is if\n * e2fsck was run on this filesystem, and it must have already done the orphan\n * inode cleanup for us, so we can safely abort without any further action.\n */\nstatic void ext3_orphan_cleanup (struct super_block * sb,\n\t\t\t\t struct ext3_super_block * es)\n{\n\tunsigned int s_flags = sb->s_flags;\n\tint nr_orphans = 0, nr_truncates = 0;\n#ifdef CONFIG_QUOTA\n\tint i;\n#endif\n\tif (!es->s_last_orphan) {\n\t\tjbd_debug(4, \"no orphan inodes to clean up\\n\");\n\t\treturn;\n\t}\n\n\tif (bdev_read_only(sb->s_bdev)) {\n\t\text3_msg(sb, KERN_ERR, \"error: write access \"\n\t\t\t\"unavailable, skipping orphan cleanup.\");\n\t\treturn;\n\t}\n\n\t/* Check if feature set allows readwrite operations */\n\tif (EXT3_HAS_RO_COMPAT_FEATURE(sb, ~EXT3_FEATURE_RO_COMPAT_SUPP)) {\n\t\text3_msg(sb, KERN_INFO, \"Skipping orphan cleanup due to \"\n\t\t\t \"unknown ROCOMPAT features\");\n\t\treturn;\n\t}\n\n\tif (EXT3_SB(sb)->s_mount_state & EXT3_ERROR_FS) {\n\t\t/* don't clear list on RO mount w/ errors */\n\t\tif (es->s_last_orphan && !(s_flags & MS_RDONLY)) {\n\t\t\tjbd_debug(1, \"Errors on filesystem, \"\n\t\t\t\t  \"clearing orphan list.\\n\");\n\t\t\tes->s_last_orphan = 0;\n\t\t}\n\t\tjbd_debug(1, \"Skipping orphan recovery on fs with errors.\\n\");\n\t\treturn;\n\t}\n\n\tif (s_flags & MS_RDONLY) {\n\t\text3_msg(sb, KERN_INFO, \"orphan cleanup on readonly fs\");\n\t\tsb->s_flags &= ~MS_RDONLY;\n\t}\n#ifdef CONFIG_QUOTA\n\t/* Needed for iput() to work correctly and not trash data */\n\tsb->s_flags |= MS_ACTIVE;\n\t/* Turn on quotas so that they are updated correctly */\n\tfor (i = 0; i < MAXQUOTAS; i++) {\n\t\tif (EXT3_SB(sb)->s_qf_names[i]) {\n\t\t\tint ret = ext3_quota_on_mount(sb, i);\n\t\t\tif (ret < 0)\n\t\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: cannot turn on journaled \"\n\t\t\t\t\t\"quota: %d\", ret);\n\t\t}\n\t}\n#endif\n\n\twhile (es->s_last_orphan) {\n\t\tstruct inode *inode;\n\n\t\tinode = ext3_orphan_get(sb, le32_to_cpu(es->s_last_orphan));\n\t\tif (IS_ERR(inode)) {\n\t\t\tes->s_last_orphan = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add(&EXT3_I(inode)->i_orphan, &EXT3_SB(sb)->s_orphan);\n\t\tdquot_initialize(inode);\n\t\tif (inode->i_nlink) {\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"%s: truncating inode %lu to %Ld bytes\\n\",\n\t\t\t\t__func__, inode->i_ino, inode->i_size);\n\t\t\tjbd_debug(2, \"truncating inode %lu to %Ld bytes\\n\",\n\t\t\t\t  inode->i_ino, inode->i_size);\n\t\t\text3_truncate(inode);\n\t\t\tnr_truncates++;\n\t\t} else {\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"%s: deleting unreferenced inode %lu\\n\",\n\t\t\t\t__func__, inode->i_ino);\n\t\t\tjbd_debug(2, \"deleting unreferenced inode %lu\\n\",\n\t\t\t\t  inode->i_ino);\n\t\t\tnr_orphans++;\n\t\t}\n\t\tiput(inode);  /* The delete magic happens here! */\n\t}\n\n#define PLURAL(x) (x), ((x)==1) ? \"\" : \"s\"\n\n\tif (nr_orphans)\n\t\text3_msg(sb, KERN_INFO, \"%d orphan inode%s deleted\",\n\t\t       PLURAL(nr_orphans));\n\tif (nr_truncates)\n\t\text3_msg(sb, KERN_INFO, \"%d truncate%s cleaned up\",\n\t\t       PLURAL(nr_truncates));\n#ifdef CONFIG_QUOTA\n\t/* Turn quotas off */\n\tfor (i = 0; i < MAXQUOTAS; i++) {\n\t\tif (sb_dqopt(sb)->files[i])\n\t\t\tdquot_quota_off(sb, i);\n\t}\n#endif\n\tsb->s_flags = s_flags; /* Restore MS_RDONLY status */\n}\n\n/*\n * Maximal file size.  There is a direct, and {,double-,triple-}indirect\n * block limit, and also a limit of (2^32 - 1) 512-byte sectors in i_blocks.\n * We need to be 1 filesystem block less than the 2^32 sector limit.\n */\nstatic loff_t ext3_max_size(int bits)\n{\n\tloff_t res = EXT3_NDIR_BLOCKS;\n\tint meta_blocks;\n\tloff_t upper_limit;\n\n\t/* This is calculated to be the largest file size for a\n\t * dense, file such that the total number of\n\t * sectors in the file, including data and all indirect blocks,\n\t * does not exceed 2^32 -1\n\t * __u32 i_blocks representing the total number of\n\t * 512 bytes blocks of the file\n\t */\n\tupper_limit = (1LL << 32) - 1;\n\n\t/* total blocks in file system block size */\n\tupper_limit >>= (bits - 9);\n\n\n\t/* indirect blocks */\n\tmeta_blocks = 1;\n\t/* double indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2));\n\t/* tripple indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2)) + (1LL << (2*(bits-2)));\n\n\tupper_limit -= meta_blocks;\n\tupper_limit <<= bits;\n\n\tres += 1LL << (bits-2);\n\tres += 1LL << (2*(bits-2));\n\tres += 1LL << (3*(bits-2));\n\tres <<= bits;\n\tif (res > upper_limit)\n\t\tres = upper_limit;\n\n\tif (res > MAX_LFS_FILESIZE)\n\t\tres = MAX_LFS_FILESIZE;\n\n\treturn res;\n}\n\nstatic ext3_fsblk_t descriptor_loc(struct super_block *sb,\n\t\t\t\t    ext3_fsblk_t logic_sb_block,\n\t\t\t\t    int nr)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tunsigned long bg, first_meta_bg;\n\tint has_super = 0;\n\n\tfirst_meta_bg = le32_to_cpu(sbi->s_es->s_first_meta_bg);\n\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_META_BG) ||\n\t    nr < first_meta_bg)\n\t\treturn (logic_sb_block + nr + 1);\n\tbg = sbi->s_desc_per_block * nr;\n\tif (ext3_bg_has_super(sb, bg))\n\t\thas_super = 1;\n\treturn (has_super + ext3_group_first_block_no(sb, bg));\n}\n\n\nstatic int ext3_fill_super (struct super_block *sb, void *data, int silent)\n{\n\tstruct buffer_head * bh;\n\tstruct ext3_super_block *es = NULL;\n\tstruct ext3_sb_info *sbi;\n\text3_fsblk_t block;\n\text3_fsblk_t sb_block = get_sb_block(&data, sb);\n\text3_fsblk_t logic_sb_block;\n\tunsigned long offset = 0;\n\tunsigned int journal_inum = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tint blocksize;\n\tint hblock;\n\tint db_count;\n\tint i;\n\tint needs_recovery;\n\tint ret = -EINVAL;\n\t__le32 features;\n\tint err;\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock) {\n\t\tkfree(sbi);\n\t\treturn -ENOMEM;\n\t}\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb_block = sb_block;\n\n\tblocksize = sb_min_blocksize(sb, EXT3_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text3_msg(sb, KERN_ERR, \"error: unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext3 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT3_MIN_BLOCK_SIZE) {\n\t\tlogic_sb_block = (sb_block * EXT3_MIN_BLOCK_SIZE) / blocksize;\n\t\toffset = (sb_block * EXT3_MIN_BLOCK_SIZE) % blocksize;\n\t} else {\n\t\tlogic_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread(sb, logic_sb_block))) {\n\t\text3_msg(sb, KERN_ERR, \"error: unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext3 macro-instructions depend on its value\n\t */\n\tes = (struct ext3_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT3_SUPER_MAGIC)\n\t\tgoto cantfind_ext3;\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tif (def_mount_opts & EXT3_DEFM_DEBUG)\n\t\tset_opt(sbi->s_mount_opt, DEBUG);\n\tif (def_mount_opts & EXT3_DEFM_BSDGROUPS)\n\t\tset_opt(sbi->s_mount_opt, GRPID);\n\tif (def_mount_opts & EXT3_DEFM_UID16)\n\t\tset_opt(sbi->s_mount_opt, NO_UID32);\n#ifdef CONFIG_EXT3_FS_XATTR\n\tif (def_mount_opts & EXT3_DEFM_XATTR_USER)\n\t\tset_opt(sbi->s_mount_opt, XATTR_USER);\n#endif\n#ifdef CONFIG_EXT3_FS_POSIX_ACL\n\tif (def_mount_opts & EXT3_DEFM_ACL)\n\t\tset_opt(sbi->s_mount_opt, POSIX_ACL);\n#endif\n\tif ((def_mount_opts & EXT3_DEFM_JMODE) == EXT3_DEFM_JMODE_DATA)\n\t\tset_opt(sbi->s_mount_opt, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT3_DEFM_JMODE) == EXT3_DEFM_JMODE_ORDERED)\n\t\tset_opt(sbi->s_mount_opt, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT3_DEFM_JMODE) == EXT3_DEFM_JMODE_WBACK)\n\t\tset_opt(sbi->s_mount_opt, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT3_ERRORS_PANIC)\n\t\tset_opt(sbi->s_mount_opt, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT3_ERRORS_CONTINUE)\n\t\tset_opt(sbi->s_mount_opt, ERRORS_CONT);\n\telse\n\t\tset_opt(sbi->s_mount_opt, ERRORS_RO);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\n\t/* enable barriers by default */\n\tset_opt(sbi->s_mount_opt, BARRIER);\n\tset_opt(sbi->s_mount_opt, RESERVATION);\n\n\tif (!parse_options ((char *) data, sb, &journal_inum, &journal_devnum,\n\t\t\t    NULL, 0))\n\t\tgoto failed_mount;\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT3_GOOD_OLD_REV &&\n\t    (EXT3_HAS_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT3_HAS_RO_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT3_HAS_INCOMPAT_FEATURE(sb, ~0U)))\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: feature flags set on rev 0 fs, \"\n\t\t\t\"running e2fsck is recommended\");\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tfeatures = EXT3_HAS_INCOMPAT_FEATURE(sb, ~EXT3_FEATURE_INCOMPAT_SUPP);\n\tif (features) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: couldn't mount because of unsupported \"\n\t\t\t\"optional features (%x)\", le32_to_cpu(features));\n\t\tgoto failed_mount;\n\t}\n\tfeatures = EXT3_HAS_RO_COMPAT_FEATURE(sb, ~EXT3_FEATURE_RO_COMPAT_SUPP);\n\tif (!(sb->s_flags & MS_RDONLY) && features) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: couldn't mount RDWR because of unsupported \"\n\t\t\t\"optional features (%x)\", le32_to_cpu(features));\n\t\tgoto failed_mount;\n\t}\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\n\tif (blocksize < EXT3_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT3_MAX_BLOCK_SIZE) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: couldn't mount because of unsupported \"\n\t\t\t\"filesystem blocksize %d\", blocksize);\n\t\tgoto failed_mount;\n\t}\n\n\thblock = bdev_logical_block_size(sb->s_bdev);\n\tif (sb->s_blocksize != blocksize) {\n\t\t/*\n\t\t * Make sure the blocksize for the filesystem is larger\n\t\t * than the hardware sectorsize for the machine.\n\t\t */\n\t\tif (blocksize < hblock) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: fsblocksize %d too small for \"\n\t\t\t\t\"hardware sectorsize %d\", blocksize, hblock);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse (bh);\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: bad blocksize %d\", blocksize);\n\t\t\tgoto out_fail;\n\t\t}\n\t\tlogic_sb_block = (sb_block * EXT3_MIN_BLOCK_SIZE) / blocksize;\n\t\toffset = (sb_block * EXT3_MIN_BLOCK_SIZE) % blocksize;\n\t\tbh = sb_bread(sb, logic_sb_block);\n\t\tif (!bh) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t       \"error: can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext3_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT3_SUPER_MAGIC)) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: magic mismatch\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tsb->s_maxbytes = ext3_max_size(sb->s_blocksize_bits);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT3_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT3_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT3_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT3_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: unsupported inode size: %d\",\n\t\t\t\tsbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\tsbi->s_frag_size = EXT3_MIN_FRAG_SIZE <<\n\t\t\t\t   le32_to_cpu(es->s_log_frag_size);\n\tif (blocksize != sbi->s_frag_size) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t       \"error: fragsize %lu != blocksize %u (unsupported)\",\n\t\t       sbi->s_frag_size, blocksize);\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_frags_per_block = 1;\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_frags_per_group = le32_to_cpu(es->s_frags_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\tif (EXT3_INODE_SIZE(sb) == 0 || EXT3_INODES_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext3;\n\tsbi->s_inodes_per_block = blocksize / EXT3_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext3;\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / sizeof(struct ext3_group_desc);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT3_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT3_DESC_PER_BLOCK(sb));\n\tfor (i=0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\ti = le32_to_cpu(es->s_flags);\n\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\tsbi->s_hash_unsigned = 3;\n\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\tes->s_flags |= cpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\tes->s_flags |= cpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t}\n\n\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"#blocks per group too big: %lu\",\n\t\t\tsbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tif (sbi->s_frags_per_group > blocksize * 8) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: #fragments per group too big: %lu\",\n\t\t\tsbi->s_frags_per_group);\n\t\tgoto failed_mount;\n\t}\n\tif (sbi->s_inodes_per_group > blocksize * 8) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: #inodes per group too big: %lu\",\n\t\t\tsbi->s_inodes_per_group);\n\t\tgoto failed_mount;\n\t}\n\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\tle32_to_cpu(es->s_blocks_count));\n\tif (err) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: filesystem is too large to mount safely\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: CONFIG_LBDAF not enabled\");\n\t\tret = err;\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT3_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext3;\n\tsbi->s_groups_count = ((le32_to_cpu(es->s_blocks_count) -\n\t\t\t       le32_to_cpu(es->s_first_data_block) - 1)\n\t\t\t\t       / EXT3_BLOCKS_PER_GROUP(sb)) + 1;\n\tdb_count = DIV_ROUND_UP(sbi->s_groups_count, EXT3_DESC_PER_BLOCK(sb));\n\tsbi->s_group_desc = kmalloc(db_count * sizeof (struct buffer_head *),\n\t\t\t\t    GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logic_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext3_check_descriptors (sb)) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: group descriptors corrupted\");\n\t\tgoto failed_mount2;\n\t}\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\t/* per fileystem reservation list head & lock */\n\tspin_lock_init(&sbi->s_rsv_window_lock);\n\tsbi->s_rsv_window_root = RB_ROOT;\n\t/* Add a single, static dummy reservation to the start of the\n\t * reservation window list --- it gives us a placeholder for\n\t * append-at-start-of-list which makes the allocation logic\n\t * _much_ simpler. */\n\tsbi->s_rsv_window_head.rsv_start = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\tsbi->s_rsv_window_head.rsv_end = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\tsbi->s_rsv_window_head.rsv_alloc_hit = 0;\n\tsbi->s_rsv_window_head.rsv_goal_size = 0;\n\text3_rsv_window_add(sb, &sbi->s_rsv_window_head);\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext3_sops;\n\tsb->s_export_op = &ext3_export_ops;\n\tsb->s_xattr = ext3_xattr_handlers;\n#ifdef CONFIG_QUOTA\n\tsb->s_qcop = &ext3_qctl_operations;\n\tsb->dq_op = &ext3_quota_operations;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\tmutex_init(&sbi->s_resize_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  EXT3_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t    EXT3_FEATURE_INCOMPAT_RECOVER));\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) &&\n\t    EXT3_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_HAS_JOURNAL)) {\n\t\tif (ext3_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount2;\n\t} else if (journal_inum) {\n\t\tif (ext3_create_journal(sb, es, journal_inum))\n\t\t\tgoto failed_mount2;\n\t} else {\n\t\tif (!silent)\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: no journal found. \"\n\t\t\t\t\"mounting ext3 over ext2?\");\n\t\tgoto failed_mount2;\n\t}\n\terr = percpu_counter_init(&sbi->s_freeblocks_counter,\n\t\t\text3_count_free_blocks(sb));\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter,\n\t\t\t\text3_count_free_inodes(sb));\n\t}\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\text3_count_dirs(sb));\n\t}\n\tif (err) {\n\t\text3_msg(sb, KERN_ERR, \"error: insufficient memory\");\n\t\tret = err;\n\t\tgoto failed_mount3;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n                   capabilities: ORDERED_DATA if the journal can\n                   cope, else JOURNAL_DATA */\n\t\tif (journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JFS_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sbi->s_mount_opt, DEFAULT_DATA_MODE);\n\t\telse\n\t\t\tset_opt(sbi->s_mount_opt, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT3_MOUNT_ORDERED_DATA:\n\tcase EXT3_MOUNT_WRITEBACK_DATA:\n\t\tif (!journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JFS_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text3_msg(sb, KERN_ERR,\n\t\t\t\t\"error: journal does not support \"\n\t\t\t\t\"requested data journaling mode\");\n\t\t\tgoto failed_mount3;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/*\n\t * The journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext3_iget(sb, EXT3_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text3_msg(sb, KERN_ERR, \"error: get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\tgoto failed_mount3;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\tiput(root);\n\t\text3_msg(sb, KERN_ERR, \"error: corrupt root inode, run e2fsck\");\n\t\tgoto failed_mount3;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text3_msg(sb, KERN_ERR, \"error: get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount3;\n\t}\n\n\tif (ext3_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\tEXT3_SB(sb)->s_mount_state |= EXT3_ORPHAN_FS;\n\text3_orphan_cleanup(sb, es);\n\tEXT3_SB(sb)->s_mount_state &= ~EXT3_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text3_mark_recovery_complete(sb, es);\n\t\text3_msg(sb, KERN_INFO, \"recovery complete\");\n\t}\n\text3_msg(sb, KERN_INFO, \"mounted filesystem with %s data mode\",\n\t\ttest_opt(sb,DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA ? \"journal\":\n\t\ttest_opt(sb,DATA_FLAGS) == EXT3_MOUNT_ORDERED_DATA ? \"ordered\":\n\t\t\"writeback\");\n\tsb->s_flags |= MS_SNAP_STABLE;\n\n\treturn 0;\n\ncantfind_ext3:\n\tif (!silent)\n\t\text3_msg(sb, KERN_INFO,\n\t\t\t\"error: can't find ext3 filesystem on dev %s.\",\n\t\t       sb->s_id);\n\tgoto failed_mount;\n\nfailed_mount3:\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tjournal_destroy(sbi->s_journal);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\nfailed_mount:\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text3_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\n\treturn ret;\n}\n\n/*\n * Setup any per-fs journal parameters now.  We'll do this both on\n * initial mount, once the journal has been initialised but before we've\n * done any recovery; and again on any subsequent remount.\n */\nstatic void ext3_init_journal_params(struct super_block *sb, journal_t *journal)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (sbi->s_commit_interval)\n\t\tjournal->j_commit_interval = sbi->s_commit_interval;\n\t/* We could also set up an ext3-specific default for the commit\n\t * interval here, but for now we'll just fall back to the jbd\n\t * default. */\n\n\tspin_lock(&journal->j_state_lock);\n\tif (test_opt(sb, BARRIER))\n\t\tjournal->j_flags |= JFS_BARRIER;\n\telse\n\t\tjournal->j_flags &= ~JFS_BARRIER;\n\tif (test_opt(sb, DATA_ERR_ABORT))\n\t\tjournal->j_flags |= JFS_ABORT_ON_SYNCDATA_ERR;\n\telse\n\t\tjournal->j_flags &= ~JFS_ABORT_ON_SYNCDATA_ERR;\n\tspin_unlock(&journal->j_state_lock);\n}\n\nstatic journal_t *ext3_get_journal(struct super_block *sb,\n\t\t\t\t   unsigned int journal_inum)\n{\n\tstruct inode *journal_inode;\n\tjournal_t *journal;\n\n\t/* First, test for the existence of a valid inode on disk.  Bad\n\t * things happen if we iget() an unused inode, as the subsequent\n\t * iput() will try to delete it. */\n\n\tjournal_inode = ext3_iget(sb, journal_inum);\n\tif (IS_ERR(journal_inode)) {\n\t\text3_msg(sb, KERN_ERR, \"error: no journal found\");\n\t\treturn NULL;\n\t}\n\tif (!journal_inode->i_nlink) {\n\t\tmake_bad_inode(journal_inode);\n\t\tiput(journal_inode);\n\t\text3_msg(sb, KERN_ERR, \"error: journal inode is deleted\");\n\t\treturn NULL;\n\t}\n\n\tjbd_debug(2, \"Journal inode found at %p: %Ld bytes\\n\",\n\t\t  journal_inode, journal_inode->i_size);\n\tif (!S_ISREG(journal_inode->i_mode)) {\n\t\text3_msg(sb, KERN_ERR, \"error: invalid journal inode\");\n\t\tiput(journal_inode);\n\t\treturn NULL;\n\t}\n\n\tjournal = journal_init_inode(journal_inode);\n\tif (!journal) {\n\t\text3_msg(sb, KERN_ERR, \"error: could not load journal inode\");\n\t\tiput(journal_inode);\n\t\treturn NULL;\n\t}\n\tjournal->j_private = sb;\n\text3_init_journal_params(sb, journal);\n\treturn journal;\n}\n\nstatic journal_t *ext3_get_dev_journal(struct super_block *sb,\n\t\t\t\t       dev_t j_dev)\n{\n\tstruct buffer_head * bh;\n\tjournal_t *journal;\n\text3_fsblk_t start;\n\text3_fsblk_t len;\n\tint hblock, blocksize;\n\text3_fsblk_t sb_block;\n\tunsigned long offset;\n\tstruct ext3_super_block * es;\n\tstruct block_device *bdev;\n\n\tbdev = ext3_blkdev_get(j_dev, sb);\n\tif (bdev == NULL)\n\t\treturn NULL;\n\n\tblocksize = sb->s_blocksize;\n\thblock = bdev_logical_block_size(bdev);\n\tif (blocksize < hblock) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: blocksize too small for journal device\");\n\t\tgoto out_bdev;\n\t}\n\n\tsb_block = EXT3_MIN_BLOCK_SIZE / blocksize;\n\toffset = EXT3_MIN_BLOCK_SIZE % blocksize;\n\tset_blocksize(bdev, blocksize);\n\tif (!(bh = __bread(bdev, sb_block, blocksize))) {\n\t\text3_msg(sb, KERN_ERR, \"error: couldn't read superblock of \"\n\t\t\t\"external journal\");\n\t\tgoto out_bdev;\n\t}\n\n\tes = (struct ext3_super_block *) (bh->b_data + offset);\n\tif ((le16_to_cpu(es->s_magic) != EXT3_SUPER_MAGIC) ||\n\t    !(le32_to_cpu(es->s_feature_incompat) &\n\t      EXT3_FEATURE_INCOMPAT_JOURNAL_DEV)) {\n\t\text3_msg(sb, KERN_ERR, \"error: external journal has \"\n\t\t\t\"bad superblock\");\n\t\tbrelse(bh);\n\t\tgoto out_bdev;\n\t}\n\n\tif (memcmp(EXT3_SB(sb)->s_es->s_journal_uuid, es->s_uuid, 16)) {\n\t\text3_msg(sb, KERN_ERR, \"error: journal UUID does not match\");\n\t\tbrelse(bh);\n\t\tgoto out_bdev;\n\t}\n\n\tlen = le32_to_cpu(es->s_blocks_count);\n\tstart = sb_block + 1;\n\tbrelse(bh);\t/* we're done with the superblock */\n\n\tjournal = journal_init_dev(bdev, sb->s_bdev,\n\t\t\t\t\tstart, len, blocksize);\n\tif (!journal) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: failed to create device journal\");\n\t\tgoto out_bdev;\n\t}\n\tjournal->j_private = sb;\n\tif (!bh_uptodate_or_lock(journal->j_sb_buffer)) {\n\t\tif (bh_submit_read(journal->j_sb_buffer)) {\n\t\t\text3_msg(sb, KERN_ERR, \"I/O error on journal device\");\n\t\t\tgoto out_journal;\n\t\t}\n\t}\n\tif (be32_to_cpu(journal->j_superblock->s_nr_users) != 1) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: external journal has more than one \"\n\t\t\t\"user (unsupported) - %d\",\n\t\t\tbe32_to_cpu(journal->j_superblock->s_nr_users));\n\t\tgoto out_journal;\n\t}\n\tEXT3_SB(sb)->journal_bdev = bdev;\n\text3_init_journal_params(sb, journal);\n\treturn journal;\nout_journal:\n\tjournal_destroy(journal);\nout_bdev:\n\text3_blkdev_put(bdev);\n\treturn NULL;\n}\n\nstatic int ext3_load_journal(struct super_block *sb,\n\t\t\t     struct ext3_super_block *es,\n\t\t\t     unsigned long journal_devnum)\n{\n\tjournal_t *journal;\n\tunsigned int journal_inum = le32_to_cpu(es->s_journal_inum);\n\tdev_t journal_dev;\n\tint err = 0;\n\tint really_read_only;\n\n\tif (journal_devnum &&\n\t    journal_devnum != le32_to_cpu(es->s_journal_dev)) {\n\t\text3_msg(sb, KERN_INFO, \"external journal device major/minor \"\n\t\t\t\"numbers have changed\");\n\t\tjournal_dev = new_decode_dev(journal_devnum);\n\t} else\n\t\tjournal_dev = new_decode_dev(le32_to_cpu(es->s_journal_dev));\n\n\treally_read_only = bdev_read_only(sb->s_bdev);\n\n\t/*\n\t * Are we loading a blank journal or performing recovery after a\n\t * crash?  For recovery, we need to check in advance whether we\n\t * can get read-write access to the device.\n\t */\n\n\tif (EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER)) {\n\t\tif (sb->s_flags & MS_RDONLY) {\n\t\t\text3_msg(sb, KERN_INFO,\n\t\t\t\t\"recovery required on readonly filesystem\");\n\t\t\tif (really_read_only) {\n\t\t\t\text3_msg(sb, KERN_ERR, \"error: write access \"\n\t\t\t\t\t\"unavailable, cannot proceed\");\n\t\t\t\treturn -EROFS;\n\t\t\t}\n\t\t\text3_msg(sb, KERN_INFO,\n\t\t\t\t\"write access will be enabled during recovery\");\n\t\t}\n\t}\n\n\tif (journal_inum && journal_dev) {\n\t\text3_msg(sb, KERN_ERR, \"error: filesystem has both journal \"\n\t\t       \"and inode journals\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (journal_inum) {\n\t\tif (!(journal = ext3_get_journal(sb, journal_inum)))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (!(journal = ext3_get_dev_journal(sb, journal_dev)))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!(journal->j_flags & JFS_BARRIER))\n\t\tprintk(KERN_INFO \"EXT3-fs: barriers not enabled\\n\");\n\n\tif (!really_read_only && test_opt(sb, UPDATE_JOURNAL)) {\n\t\terr = journal_update_format(journal);\n\t\tif (err)  {\n\t\t\text3_msg(sb, KERN_ERR, \"error updating journal\");\n\t\t\tjournal_destroy(journal);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER))\n\t\terr = journal_wipe(journal, !really_read_only);\n\tif (!err)\n\t\terr = journal_load(journal);\n\n\tif (err) {\n\t\text3_msg(sb, KERN_ERR, \"error loading journal\");\n\t\tjournal_destroy(journal);\n\t\treturn err;\n\t}\n\n\tEXT3_SB(sb)->s_journal = journal;\n\text3_clear_journal_err(sb, es);\n\n\tif (!really_read_only && journal_devnum &&\n\t    journal_devnum != le32_to_cpu(es->s_journal_dev)) {\n\t\tes->s_journal_dev = cpu_to_le32(journal_devnum);\n\n\t\t/* Make sure we flush the recovery flag to disk. */\n\t\text3_commit_super(sb, es, 1);\n\t}\n\n\treturn 0;\n}\n\nstatic int ext3_create_journal(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       unsigned int journal_inum)\n{\n\tjournal_t *journal;\n\tint err;\n\n\tif (sb->s_flags & MS_RDONLY) {\n\t\text3_msg(sb, KERN_ERR,\n\t\t\t\"error: readonly filesystem when trying to \"\n\t\t\t\"create journal\");\n\t\treturn -EROFS;\n\t}\n\n\tjournal = ext3_get_journal(sb, journal_inum);\n\tif (!journal)\n\t\treturn -EINVAL;\n\n\text3_msg(sb, KERN_INFO, \"creating new journal on inode %u\",\n\t       journal_inum);\n\n\terr = journal_create(journal);\n\tif (err) {\n\t\text3_msg(sb, KERN_ERR, \"error creating journal\");\n\t\tjournal_destroy(journal);\n\t\treturn -EIO;\n\t}\n\n\tEXT3_SB(sb)->s_journal = journal;\n\n\text3_update_dynamic_rev(sb);\n\tEXT3_SET_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\tEXT3_SET_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_HAS_JOURNAL);\n\n\tes->s_journal_inum = cpu_to_le32(journal_inum);\n\n\t/* Make sure we flush the recovery flag to disk. */\n\text3_commit_super(sb, es, 1);\n\n\treturn 0;\n}\n\nstatic int ext3_commit_super(struct super_block *sb,\n\t\t\t       struct ext3_super_block *es,\n\t\t\t       int sync)\n{\n\tstruct buffer_head *sbh = EXT3_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh)\n\t\treturn error;\n\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text3_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tes->s_free_blocks_count = cpu_to_le32(ext3_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext3_count_free_inodes(sb));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (buffer_write_io_error(sbh)) {\n\t\t\text3_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}\n\n\n/*\n * Have we just finished recovery?  If so, and if we are mounting (or\n * remounting) the filesystem readonly, then we will end up with a\n * consistent fs on disk.  Record that fact.\n */\nstatic void ext3_mark_recovery_complete(struct super_block * sb,\n\t\t\t\t\tstruct ext3_super_block * es)\n{\n\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\n\tjournal_lock_updates(journal);\n\tif (journal_flush(journal) < 0)\n\t\tgoto out;\n\n\tif (EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER) &&\n\t    sb->s_flags & MS_RDONLY) {\n\t\tEXT3_CLEAR_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\t\text3_commit_super(sb, es, 1);\n\t}\n\nout:\n\tjournal_unlock_updates(journal);\n}\n\n/*\n * If we are mounting (or read-write remounting) a filesystem whose journal\n * has recorded an error from a previous lifetime, move that error to the\n * main filesystem now.\n */\nstatic void ext3_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext3_super_block *es)\n{\n\tjournal_t *journal;\n\tint j_errno;\n\tconst char *errstr;\n\n\tjournal = EXT3_SB(sb)->s_journal;\n\n\t/*\n\t * Now check for any error status which may have been recorded in the\n\t * journal by a prior ext3_error() or ext3_abort()\n\t */\n\n\tj_errno = journal_errno(journal);\n\tif (j_errno) {\n\t\tchar nbuf[16];\n\n\t\terrstr = ext3_decode_error(sb, j_errno, nbuf);\n\t\text3_warning(sb, __func__, \"Filesystem error recorded \"\n\t\t\t     \"from previous mount: %s\", errstr);\n\t\text3_warning(sb, __func__, \"Marking fs in need of \"\n\t\t\t     \"filesystem check.\");\n\n\t\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT3_ERROR_FS);\n\t\text3_commit_super (sb, es, 1);\n\n\t\tjournal_clear_err(journal);\n\t}\n}\n\n/*\n * Force the running and committing transactions to commit,\n * and wait on the commit.\n */\nint ext3_force_commit(struct super_block *sb)\n{\n\tjournal_t *journal;\n\tint ret;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tjournal = EXT3_SB(sb)->s_journal;\n\tret = ext3_journal_force_commit(journal);\n\treturn ret;\n}\n\nstatic int ext3_sync_fs(struct super_block *sb, int wait)\n{\n\ttid_t target;\n\n\ttrace_ext3_sync_fs(sb, wait);\n\t/*\n\t * Writeback quota in non-journalled quota case - journalled quota has\n\t * no dirty dquots\n\t */\n\tdquot_writeback_dquots(sb, -1);\n\tif (journal_start_commit(EXT3_SB(sb)->s_journal, &target)) {\n\t\tif (wait)\n\t\t\tlog_wait_commit(EXT3_SB(sb)->s_journal, target);\n\t}\n\treturn 0;\n}\n\n/*\n * LVM calls this function before a (read-only) snapshot is created.  This\n * gives us a chance to flush the journal completely and mark the fs clean.\n */\nstatic int ext3_freeze(struct super_block *sb)\n{\n\tint error = 0;\n\tjournal_t *journal;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tjournal = EXT3_SB(sb)->s_journal;\n\n\t\t/* Now we set up the journal barrier. */\n\t\tjournal_lock_updates(journal);\n\n\t\t/*\n\t\t * We don't want to clear needs_recovery flag when we failed\n\t\t * to flush the journal.\n\t\t */\n\t\terror = journal_flush(journal);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\n\t\t/* Journal blocked and flushed, clear needs_recovery flag. */\n\t\tEXT3_CLEAR_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\t\terror = ext3_commit_super(sb, EXT3_SB(sb)->s_es, 1);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\treturn 0;\n\nout:\n\tjournal_unlock_updates(journal);\n\treturn error;\n}\n\n/*\n * Called by LVM after the snapshot is done.  We need to reset the RECOVER\n * flag here, even though the filesystem is not technically dirty yet.\n */\nstatic int ext3_unfreeze(struct super_block *sb)\n{\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t/* Reser the needs_recovery flag before the fs is unlocked. */\n\t\tEXT3_SET_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n\t\text3_commit_super(sb, EXT3_SB(sb)->s_es, 1);\n\t\tjournal_unlock_updates(EXT3_SB(sb)->s_journal);\n\t}\n\treturn 0;\n}\n\nstatic int ext3_remount (struct super_block * sb, int * flags, char * data)\n{\n\tstruct ext3_super_block * es;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\text3_fsblk_t n_blocks_count = 0;\n\tunsigned long old_sb_flags;\n\tstruct ext3_mount_options old_opts;\n\tint enable_quota = 0;\n\tint err;\n#ifdef CONFIG_QUOTA\n\tint i;\n#endif\n\n\t/* Store the original options */\n\told_sb_flags = sb->s_flags;\n\told_opts.s_mount_opt = sbi->s_mount_opt;\n\told_opts.s_resuid = sbi->s_resuid;\n\told_opts.s_resgid = sbi->s_resgid;\n\told_opts.s_commit_interval = sbi->s_commit_interval;\n#ifdef CONFIG_QUOTA\n\told_opts.s_jquota_fmt = sbi->s_jquota_fmt;\n\tfor (i = 0; i < MAXQUOTAS; i++)\n\t\tif (sbi->s_qf_names[i]) {\n\t\t\told_opts.s_qf_names[i] = kstrdup(sbi->s_qf_names[i],\n\t\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!old_opts.s_qf_names[i]) {\n\t\t\t\tint j;\n\n\t\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\t\tkfree(old_opts.s_qf_names[j]);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t} else\n\t\t\told_opts.s_qf_names[i] = NULL;\n#endif\n\n\t/*\n\t * Allow the \"check\" option to be passed as a remount option.\n\t */\n\tif (!parse_options(data, sb, NULL, NULL, &n_blocks_count, 1)) {\n\t\terr = -EINVAL;\n\t\tgoto restore_opts;\n\t}\n\n\tif (test_opt(sb, ABORT))\n\t\text3_abort(sb, __func__, \"Abort forced by user\");\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tes = sbi->s_es;\n\n\text3_init_journal_params(sb, sbi->s_journal);\n\n\tif ((*flags & MS_RDONLY) != (sb->s_flags & MS_RDONLY) ||\n\t\tn_blocks_count > le32_to_cpu(es->s_blocks_count)) {\n\t\tif (test_opt(sb, ABORT)) {\n\t\t\terr = -EROFS;\n\t\t\tgoto restore_opts;\n\t\t}\n\n\t\tif (*flags & MS_RDONLY) {\n\t\t\terr = dquot_suspend(sb, -1);\n\t\t\tif (err < 0)\n\t\t\t\tgoto restore_opts;\n\n\t\t\t/*\n\t\t\t * First of all, the unconditional stuff we have to do\n\t\t\t * to disable replay of the journal when we next remount\n\t\t\t */\n\t\t\tsb->s_flags |= MS_RDONLY;\n\n\t\t\t/*\n\t\t\t * OK, test if we are remounting a valid rw partition\n\t\t\t * readonly, and if so set the rdonly flag and then\n\t\t\t * mark the partition as valid again.\n\t\t\t */\n\t\t\tif (!(es->s_state & cpu_to_le16(EXT3_VALID_FS)) &&\n\t\t\t    (sbi->s_mount_state & EXT3_VALID_FS))\n\t\t\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\n\t\t\text3_mark_recovery_complete(sb, es);\n\t\t} else {\n\t\t\t__le32 ret;\n\t\t\tif ((ret = EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t~EXT3_FEATURE_RO_COMPAT_SUPP))) {\n\t\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\t\"warning: couldn't remount RDWR \"\n\t\t\t\t\t\"because of unsupported optional \"\n\t\t\t\t\t\"features (%x)\", le32_to_cpu(ret));\n\t\t\t\terr = -EROFS;\n\t\t\t\tgoto restore_opts;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If we have an unprocessed orphan list hanging\n\t\t\t * around from a previously readonly bdev mount,\n\t\t\t * require a full umount & mount for now.\n\t\t\t */\n\t\t\tif (es->s_last_orphan) {\n\t\t\t\text3_msg(sb, KERN_WARNING, \"warning: couldn't \"\n\t\t\t\t       \"remount RDWR because of unprocessed \"\n\t\t\t\t       \"orphan inode list.  Please \"\n\t\t\t\t       \"umount & mount instead.\");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto restore_opts;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Mounting a RDONLY partition read-write, so reread\n\t\t\t * and store the current valid flag.  (It may have\n\t\t\t * been changed by e2fsck since we originally mounted\n\t\t\t * the partition.)\n\t\t\t */\n\t\t\text3_clear_journal_err(sb, es);\n\t\t\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\t\t\tif ((err = ext3_group_extend(sb, es, n_blocks_count)))\n\t\t\t\tgoto restore_opts;\n\t\t\tif (!ext3_setup_super (sb, es, 0))\n\t\t\t\tsb->s_flags &= ~MS_RDONLY;\n\t\t\tenable_quota = 1;\n\t\t}\n\t}\n#ifdef CONFIG_QUOTA\n\t/* Release old quota file names */\n\tfor (i = 0; i < MAXQUOTAS; i++)\n\t\tkfree(old_opts.s_qf_names[i]);\n#endif\n\tif (enable_quota)\n\t\tdquot_resume(sb, -1);\n\treturn 0;\nrestore_opts:\n\tsb->s_flags = old_sb_flags;\n\tsbi->s_mount_opt = old_opts.s_mount_opt;\n\tsbi->s_resuid = old_opts.s_resuid;\n\tsbi->s_resgid = old_opts.s_resgid;\n\tsbi->s_commit_interval = old_opts.s_commit_interval;\n#ifdef CONFIG_QUOTA\n\tsbi->s_jquota_fmt = old_opts.s_jquota_fmt;\n\tfor (i = 0; i < MAXQUOTAS; i++) {\n\t\tkfree(sbi->s_qf_names[i]);\n\t\tsbi->s_qf_names[i] = old_opts.s_qf_names[i];\n\t}\n#endif\n\treturn err;\n}\n\nstatic int ext3_statfs (struct dentry * dentry, struct kstatfs * buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tstruct ext3_super_block *es = sbi->s_es;\n\tu64 fsid;\n\n\tif (test_opt(sb, MINIX_DF)) {\n\t\tsbi->s_overhead_last = 0;\n\t} else if (sbi->s_blocks_last != le32_to_cpu(es->s_blocks_count)) {\n\t\tunsigned long ngroups = sbi->s_groups_count, i;\n\t\text3_fsblk_t overhead = 0;\n\t\tsmp_rmb();\n\n\t\t/*\n\t\t * Compute the overhead (FS structures).  This is constant\n\t\t * for a given filesystem unless the number of block groups\n\t\t * changes so we cache the previous value until it does.\n\t\t */\n\n\t\t/*\n\t\t * All of the blocks before first_data_block are\n\t\t * overhead\n\t\t */\n\t\toverhead = le32_to_cpu(es->s_first_data_block);\n\n\t\t/*\n\t\t * Add the overhead attributed to the superblock and\n\t\t * block group descriptors.  If the sparse superblocks\n\t\t * feature is turned on, then not all groups have this.\n\t\t */\n\t\tfor (i = 0; i < ngroups; i++) {\n\t\t\toverhead += ext3_bg_has_super(sb, i) +\n\t\t\t\text3_bg_num_gdb(sb, i);\n\t\t\tcond_resched();\n\t\t}\n\n\t\t/*\n\t\t * Every block group has an inode bitmap, a block\n\t\t * bitmap, and an inode table.\n\t\t */\n\t\toverhead += ngroups * (2 + sbi->s_itb_per_group);\n\t\tsbi->s_overhead_last = overhead;\n\t\tsmp_wmb();\n\t\tsbi->s_blocks_last = le32_to_cpu(es->s_blocks_count);\n\t}\n\n\tbuf->f_type = EXT3_SUPER_MAGIC;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = le32_to_cpu(es->s_blocks_count) - sbi->s_overhead_last;\n\tbuf->f_bfree = percpu_counter_sum_positive(&sbi->s_freeblocks_counter);\n\tbuf->f_bavail = buf->f_bfree - le32_to_cpu(es->s_r_blocks_count);\n\tif (buf->f_bfree < le32_to_cpu(es->s_r_blocks_count))\n\t\tbuf->f_bavail = 0;\n\tbuf->f_files = le32_to_cpu(es->s_inodes_count);\n\tbuf->f_ffree = percpu_counter_sum_positive(&sbi->s_freeinodes_counter);\n\tbuf->f_namelen = EXT3_NAME_LEN;\n\tfsid = le64_to_cpup((void *)es->s_uuid) ^\n\t       le64_to_cpup((void *)es->s_uuid + sizeof(u64));\n\tbuf->f_fsid.val[0] = fsid & 0xFFFFFFFFUL;\n\tbuf->f_fsid.val[1] = (fsid >> 32) & 0xFFFFFFFFUL;\n\treturn 0;\n}\n\n/* Helper function for writing quotas on sync - we need to start transaction before quota file\n * is locked for write. Otherwise the are possible deadlocks:\n * Process 1                         Process 2\n * ext3_create()                     quota_sync()\n *   journal_start()                   write_dquot()\n *   dquot_initialize()                       down(dqio_mutex)\n *     down(dqio_mutex)                    journal_start()\n *\n */\n\n#ifdef CONFIG_QUOTA\n\nstatic inline struct inode *dquot_to_inode(struct dquot *dquot)\n{\n\treturn sb_dqopt(dquot->dq_sb)->files[dquot->dq_id.type];\n}\n\nstatic int ext3_write_dquot(struct dquot *dquot)\n{\n\tint ret, err;\n\thandle_t *handle;\n\tstruct inode *inode;\n\n\tinode = dquot_to_inode(dquot);\n\thandle = ext3_journal_start(inode,\n\t\t\t\t\tEXT3_QUOTA_TRANS_BLOCKS(dquot->dq_sb));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tret = dquot_commit(dquot);\n\terr = ext3_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}\n\nstatic int ext3_acquire_dquot(struct dquot *dquot)\n{\n\tint ret, err;\n\thandle_t *handle;\n\n\thandle = ext3_journal_start(dquot_to_inode(dquot),\n\t\t\t\t\tEXT3_QUOTA_INIT_BLOCKS(dquot->dq_sb));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tret = dquot_acquire(dquot);\n\terr = ext3_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}\n\nstatic int ext3_release_dquot(struct dquot *dquot)\n{\n\tint ret, err;\n\thandle_t *handle;\n\n\thandle = ext3_journal_start(dquot_to_inode(dquot),\n\t\t\t\t\tEXT3_QUOTA_DEL_BLOCKS(dquot->dq_sb));\n\tif (IS_ERR(handle)) {\n\t\t/* Release dquot anyway to avoid endless cycle in dqput() */\n\t\tdquot_release(dquot);\n\t\treturn PTR_ERR(handle);\n\t}\n\tret = dquot_release(dquot);\n\terr = ext3_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}\n\nstatic int ext3_mark_dquot_dirty(struct dquot *dquot)\n{\n\t/* Are we journaling quotas? */\n\tif (EXT3_SB(dquot->dq_sb)->s_qf_names[USRQUOTA] ||\n\t    EXT3_SB(dquot->dq_sb)->s_qf_names[GRPQUOTA]) {\n\t\tdquot_mark_dquot_dirty(dquot);\n\t\treturn ext3_write_dquot(dquot);\n\t} else {\n\t\treturn dquot_mark_dquot_dirty(dquot);\n\t}\n}\n\nstatic int ext3_write_info(struct super_block *sb, int type)\n{\n\tint ret, err;\n\thandle_t *handle;\n\n\t/* Data block + inode block */\n\thandle = ext3_journal_start(sb->s_root->d_inode, 2);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tret = dquot_commit_info(sb, type);\n\terr = ext3_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}\n\n/*\n * Turn on quotas during mount time - we need to find\n * the quota file and such...\n */\nstatic int ext3_quota_on_mount(struct super_block *sb, int type)\n{\n\treturn dquot_quota_on_mount(sb, EXT3_SB(sb)->s_qf_names[type],\n\t\t\t\t\tEXT3_SB(sb)->s_jquota_fmt, type);\n}\n\n/*\n * Standard function to be called on quota_on\n */\nstatic int ext3_quota_on(struct super_block *sb, int type, int format_id,\n\t\t\t struct path *path)\n{\n\tint err;\n\n\tif (!test_opt(sb, QUOTA))\n\t\treturn -EINVAL;\n\n\t/* Quotafile not on the same filesystem? */\n\tif (path->dentry->d_sb != sb)\n\t\treturn -EXDEV;\n\t/* Journaling quota? */\n\tif (EXT3_SB(sb)->s_qf_names[type]) {\n\t\t/* Quotafile not of fs root? */\n\t\tif (path->dentry->d_parent != sb->s_root)\n\t\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\t\"warning: Quota file not on filesystem root. \"\n\t\t\t\t\"Journaled quota will not work.\");\n\t}\n\n\t/*\n\t * When we journal data on quota file, we have to flush journal to see\n\t * all updates to the file when we bypass pagecache...\n\t */\n\tif (ext3_should_journal_data(path->dentry->d_inode)) {\n\t\t/*\n\t\t * We don't need to lock updates but journal_flush() could\n\t\t * otherwise be livelocked...\n\t\t */\n\t\tjournal_lock_updates(EXT3_SB(sb)->s_journal);\n\t\terr = journal_flush(EXT3_SB(sb)->s_journal);\n\t\tjournal_unlock_updates(EXT3_SB(sb)->s_journal);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn dquot_quota_on(sb, type, format_id, path);\n}\n\n/* Read data from quotafile - avoid pagecache and such because we cannot afford\n * acquiring the locks... As quota files are never truncated and quota code\n * itself serializes the operations (and no one else should touch the files)\n * we don't have to be afraid of races */\nstatic ssize_t ext3_quota_read(struct super_block *sb, int type, char *data,\n\t\t\t       size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tsector_t blk = off >> EXT3_BLOCK_SIZE_BITS(sb);\n\tint err = 0;\n\tint offset = off & (sb->s_blocksize - 1);\n\tint tocopy;\n\tsize_t toread;\n\tstruct buffer_head *bh;\n\tloff_t i_size = i_size_read(inode);\n\n\tif (off > i_size)\n\t\treturn 0;\n\tif (off+len > i_size)\n\t\tlen = i_size-off;\n\ttoread = len;\n\twhile (toread > 0) {\n\t\ttocopy = sb->s_blocksize - offset < toread ?\n\t\t\t\tsb->s_blocksize - offset : toread;\n\t\tbh = ext3_bread(NULL, inode, blk, 0, &err);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (!bh)\t/* A hole? */\n\t\t\tmemset(data, 0, tocopy);\n\t\telse\n\t\t\tmemcpy(data, bh->b_data+offset, tocopy);\n\t\tbrelse(bh);\n\t\toffset = 0;\n\t\ttoread -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\n\treturn len;\n}\n\n/* Write to quotafile (we know the transaction is already started and has\n * enough credits) */\nstatic ssize_t ext3_quota_write(struct super_block *sb, int type,\n\t\t\t\tconst char *data, size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tsector_t blk = off >> EXT3_BLOCK_SIZE_BITS(sb);\n\tint err = 0;\n\tint offset = off & (sb->s_blocksize - 1);\n\tint journal_quota = EXT3_SB(sb)->s_qf_names[type] != NULL;\n\tstruct buffer_head *bh;\n\thandle_t *handle = journal_current_handle();\n\n\tif (!handle) {\n\t\text3_msg(sb, KERN_WARNING,\n\t\t\t\"warning: quota write (off=%llu, len=%llu)\"\n\t\t\t\" cancelled because transaction is not started.\",\n\t\t\t(unsigned long long)off, (unsigned long long)len);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * Since we account only one data block in transaction credits,\n\t * then it is impossible to cross a block boundary.\n\t */\n\tif (sb->s_blocksize - offset < len) {\n\t\text3_msg(sb, KERN_WARNING, \"Quota write (off=%llu, len=%llu)\"\n\t\t\t\" cancelled because not block aligned\",\n\t\t\t(unsigned long long)off, (unsigned long long)len);\n\t\treturn -EIO;\n\t}\n\tbh = ext3_bread(handle, inode, blk, 1, &err);\n\tif (!bh)\n\t\tgoto out;\n\tif (journal_quota) {\n\t\terr = ext3_journal_get_write_access(handle, bh);\n\t\tif (err) {\n\t\t\tbrelse(bh);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tlock_buffer(bh);\n\tmemcpy(bh->b_data+offset, data, len);\n\tflush_dcache_page(bh->b_page);\n\tunlock_buffer(bh);\n\tif (journal_quota)\n\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\telse {\n\t\t/* Always do at least ordered writes for quotas */\n\t\terr = ext3_journal_dirty_data(handle, bh);\n\t\tmark_buffer_dirty(bh);\n\t}\n\tbrelse(bh);\nout:\n\tif (err)\n\t\treturn err;\n\tif (inode->i_size < off + len) {\n\t\ti_size_write(inode, off + len);\n\t\tEXT3_I(inode)->i_disksize = inode->i_size;\n\t}\n\tinode->i_version++;\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\text3_mark_inode_dirty(handle, inode);\n\treturn len;\n}\n\n#endif\n\nstatic struct dentry *ext3_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, ext3_fill_super);\n}\n\nstatic struct file_system_type ext3_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ext3\",\n\t.mount\t\t= ext3_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"ext3\");\n\nstatic int __init init_ext3_fs(void)\n{\n\tint err = init_ext3_xattr();\n\tif (err)\n\t\treturn err;\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n        err = register_filesystem(&ext3_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\texit_ext3_xattr();\n\treturn err;\n}\n\nstatic void __exit exit_ext3_fs(void)\n{\n\tunregister_filesystem(&ext3_fs_type);\n\tdestroy_inodecache();\n\texit_ext3_xattr();\n}\n\nMODULE_AUTHOR(\"Remy Card, Stephen Tweedie, Andrew Morton, Andreas Dilger, Theodore Ts'o and others\");\nMODULE_DESCRIPTION(\"Second Extended Filesystem with journaling extensions\");\nMODULE_LICENSE(\"GPL\");\nmodule_init(init_ext3_fs)\nmodule_exit(exit_ext3_fs)\n"], "filenames": ["fs/ext3/super.c"], "buggy_code_start_loc": [356], "buggy_code_end_loc": [891], "fixing_code_start_loc": [356], "fixing_code_end_loc": [891], "type": "CWE-20", "message": "fs/ext3/super.c in the Linux kernel before 3.8.4 uses incorrect arguments to functions in certain circumstances related to printk input, which allows local users to conduct format-string attacks and possibly gain privileges via a crafted application.", "other": {"cve": {"id": "CVE-2013-1848", "sourceIdentifier": "secalert@redhat.com", "published": "2013-03-22T11:59:11.673", "lastModified": "2023-02-13T04:41:41.240", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "fs/ext3/super.c in the Linux kernel before 3.8.4 uses incorrect arguments to functions in certain circumstances related to printk input, which allows local users to conduct format-string attacks and possibly gain privileges via a crafted application."}, {"lang": "es", "value": "fs/ext3/super.c en el kernel de Linux antes de v3.8.4 utiliza argumentos incorrectos para funciones en determinadas circunstancias relacionadas con la entrada printk, lo que permite a usuarios locales llevar a cabo ataques de formato de cadena (format-string) y, posiblemente, obtener privilegios a trav\u00e9s de una aplicaci\u00f3n especialmente dise\u00f1ada."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:H/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 1.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.8.3", "matchCriteriaId": "7A40E2A8-BBC3-4763-B150-9193F30E9DF0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "1A6E41FB-38CE-49F2-B796-9A5AA648E73F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "93523FE1-5993-46CB-9299-7C8C1A04E873"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "27ADC356-6BE9-43A3-9E0B-393DC4B1559A"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=8d0c2d10dd72c5292eda7a06231056a4c972e4cc", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2013-06/msg00005.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-0928.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-1026.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-1051.html", "source": "secalert@redhat.com"}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.8.4", "source": "secalert@redhat.com"}, {"url": "http://www.mandriva.com/security/advisories?name=MDVSA-2013:176", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2013/03/20/8", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1809-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1811-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1812-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1813-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1814-1", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=920783", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/8d0c2d10dd72c5292eda7a06231056a4c972e4cc", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/8d0c2d10dd72c5292eda7a06231056a4c972e4cc"}}