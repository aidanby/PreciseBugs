{"buggy_code": ["#include \"sb_pci_mp.h\"\n#include <linux/module.h>\n#include <linux/parport.h>\n\nextern struct parport *parport_pc_probe_port(unsigned long base_lo,\n\t\tunsigned long base_hi,\n\t\tint irq, int dma,\n\t\tstruct device *dev,\n\t\tint irqflags);\n\nstatic struct mp_device_t mp_devs[MAX_MP_DEV];\nstatic int mp_nrpcibrds = sizeof(mp_pciboards)/sizeof(mppcibrd_t);\nstatic int NR_BOARD=0;\nstatic int NR_PORTS=0;\nstatic struct mp_port multi_ports[MAX_MP_PORT];\nstatic struct irq_info irq_lists[NR_IRQS];\n\nstatic _INLINE_ unsigned int serial_in(struct mp_port *mtpt, int offset);\nstatic _INLINE_ void serial_out(struct mp_port *mtpt, int offset, int value);\nstatic _INLINE_ unsigned int read_option_register(struct mp_port *mtpt, int offset);\nstatic int sb1054_get_register(struct sb_uart_port *port, int page, int reg);\nstatic int sb1054_set_register(struct sb_uart_port *port, int page, int reg, int value);\nstatic void SendATCommand(struct mp_port *mtpt);\nstatic int set_deep_fifo(struct sb_uart_port *port, int status);\nstatic int get_deep_fifo(struct sb_uart_port *port);\nstatic int get_device_type(int arg);\nstatic int set_auto_rts(struct sb_uart_port *port, int status);\nstatic void mp_stop(struct tty_struct *tty);\nstatic void __mp_start(struct tty_struct *tty);\nstatic void mp_start(struct tty_struct *tty);\nstatic void mp_tasklet_action(unsigned long data);\nstatic inline void mp_update_mctrl(struct sb_uart_port *port, unsigned int set, unsigned int clear);\nstatic int mp_startup(struct sb_uart_state *state, int init_hw);\nstatic void mp_shutdown(struct sb_uart_state *state);\nstatic void mp_change_speed(struct sb_uart_state *state, struct MP_TERMIOS *old_termios);\n\nstatic inline int __mp_put_char(struct sb_uart_port *port, struct circ_buf *circ, unsigned char c);\nstatic int mp_put_char(struct tty_struct *tty, unsigned char ch);\n\nstatic void mp_put_chars(struct tty_struct *tty);\nstatic int mp_write(struct tty_struct *tty, const unsigned char *buf, int count);\nstatic int mp_write_room(struct tty_struct *tty);\nstatic int mp_chars_in_buffer(struct tty_struct *tty);\nstatic void mp_flush_buffer(struct tty_struct *tty);\nstatic void mp_send_xchar(struct tty_struct *tty, char ch);\nstatic void mp_throttle(struct tty_struct *tty);\nstatic void mp_unthrottle(struct tty_struct *tty);\nstatic int mp_get_info(struct sb_uart_state *state, struct serial_struct *retinfo);\nstatic int mp_set_info(struct sb_uart_state *state, struct serial_struct *newinfo);\nstatic int mp_get_lsr_info(struct sb_uart_state *state, unsigned int *value);\n\nstatic int mp_tiocmget(struct tty_struct *tty);\nstatic int mp_tiocmset(struct tty_struct *tty, unsigned int set, unsigned int clear);\nstatic int mp_break_ctl(struct tty_struct *tty, int break_state);\nstatic int mp_do_autoconfig(struct sb_uart_state *state);\nstatic int mp_wait_modem_status(struct sb_uart_state *state, unsigned long arg);\nstatic int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt);\nstatic int mp_ioctl(struct tty_struct *tty, unsigned int cmd, unsigned long arg);\nstatic void mp_set_termios(struct tty_struct *tty, struct MP_TERMIOS *old_termios);\nstatic void mp_close(struct tty_struct *tty, struct file *filp);\nstatic void mp_wait_until_sent(struct tty_struct *tty, int timeout);\nstatic void mp_hangup(struct tty_struct *tty);\nstatic void mp_update_termios(struct sb_uart_state *state);\nstatic int mp_block_til_ready(struct file *filp, struct sb_uart_state *state);\nstatic struct sb_uart_state *uart_get(struct uart_driver *drv, int line);\nstatic int mp_open(struct tty_struct *tty, struct file *filp);\nstatic const char *mp_type(struct sb_uart_port *port);\nstatic void mp_change_pm(struct sb_uart_state *state, int pm_state);\nstatic inline void mp_report_port(struct uart_driver *drv, struct sb_uart_port *port);\nstatic void mp_configure_port(struct uart_driver *drv, struct sb_uart_state *state, struct sb_uart_port *port);\nstatic void mp_unconfigure_port(struct uart_driver *drv, struct sb_uart_state *state);\nstatic int mp_register_driver(struct uart_driver *drv);\nstatic void mp_unregister_driver(struct uart_driver *drv);\nstatic int mp_add_one_port(struct uart_driver *drv, struct sb_uart_port *port);\nstatic int mp_remove_one_port(struct uart_driver *drv, struct sb_uart_port *port);\nstatic void autoconfig(struct mp_port *mtpt, unsigned int probeflags);\nstatic void autoconfig_irq(struct mp_port *mtpt);\nstatic void multi_stop_tx(struct sb_uart_port *port);\nstatic void multi_start_tx(struct sb_uart_port *port);\nstatic void multi_stop_rx(struct sb_uart_port *port);\nstatic void multi_enable_ms(struct sb_uart_port *port);\nstatic _INLINE_ void receive_chars(struct mp_port *mtpt, int *status );\nstatic _INLINE_ void transmit_chars(struct mp_port *mtpt);\nstatic _INLINE_ void check_modem_status(struct mp_port *mtpt);\nstatic inline void multi_handle_port(struct mp_port *mtpt);\nstatic irqreturn_t multi_interrupt(int irq, void *dev_id);\nstatic void serial_do_unlink(struct irq_info *i, struct mp_port *mtpt);\nstatic int serial_link_irq_chain(struct mp_port *mtpt);\nstatic void serial_unlink_irq_chain(struct mp_port *mtpt);\nstatic void multi_timeout(unsigned long data);\nstatic unsigned int multi_tx_empty(struct sb_uart_port *port);\nstatic unsigned int multi_get_mctrl(struct sb_uart_port *port);\nstatic void multi_set_mctrl(struct sb_uart_port *port, unsigned int mctrl);\nstatic void multi_break_ctl(struct sb_uart_port *port, int break_state);\nstatic int multi_startup(struct sb_uart_port *port);\nstatic void multi_shutdown(struct sb_uart_port *port);\nstatic unsigned int multi_get_divisor(struct sb_uart_port *port, unsigned int baud);\nstatic void multi_set_termios(struct sb_uart_port *port, struct MP_TERMIOS *termios, struct MP_TERMIOS *old);\nstatic void multi_pm(struct sb_uart_port *port, unsigned int state, unsigned int oldstate);\nstatic void multi_release_std_resource(struct mp_port *mtpt);\nstatic void multi_release_port(struct sb_uart_port *port);\nstatic int multi_request_port(struct sb_uart_port *port);\nstatic void multi_config_port(struct sb_uart_port *port, int flags);\nstatic int multi_verify_port(struct sb_uart_port *port, struct serial_struct *ser);\nstatic const char *multi_type(struct sb_uart_port *port);\nstatic void __init multi_init_ports(void);\nstatic void __init multi_register_ports(struct uart_driver *drv);\nstatic int init_mp_dev(struct pci_dev *pcidev, mppcibrd_t brd);\n\nstatic int deep[256];\nstatic int deep_count;\nstatic int fcr_arr[256];\nstatic int fcr_count;\nstatic int ttr[256];\nstatic int ttr_count;\nstatic int rtr[256];\nstatic int rtr_count;\n\nmodule_param_array(deep,int,&deep_count,0);\nmodule_param_array(fcr_arr,int,&fcr_count,0);\nmodule_param_array(ttr,int,&ttr_count,0);\nmodule_param_array(rtr,int,&rtr_count,0);\n\nstatic _INLINE_ unsigned int serial_in(struct mp_port *mtpt, int offset)\n{\n\treturn inb(mtpt->port.iobase + offset);\n}\n\nstatic _INLINE_ void serial_out(struct mp_port *mtpt, int offset, int value)\n{\n\toutb(value, mtpt->port.iobase + offset);\n}\n\nstatic _INLINE_ unsigned int read_option_register(struct mp_port *mtpt, int offset)\n{\n\treturn inb(mtpt->option_base_addr + offset);\n}\n\nstatic int sb1053a_get_interface(struct mp_port *mtpt, int port_num)\n{\n\tunsigned long option_base_addr = mtpt->option_base_addr;\n\tunsigned int  interface = 0;\n\n\tswitch (port_num)\n\t{\n\t\tcase 0:\n\t\tcase 1:\n\t\t\t/* set GPO[1:0] = 00 */\n\t\t\toutb(0x00, option_base_addr + MP_OPTR_GPODR);\n\t\t\tbreak;\n\t\tcase 2:\n\t\tcase 3:\n\t\t\t/* set GPO[1:0] = 01 */\n\t\t\toutb(0x01, option_base_addr + MP_OPTR_GPODR);\n\t\t\tbreak;\n\t\tcase 4:\n\t\tcase 5:\n\t\t\t/* set GPO[1:0] = 10 */\n\t\t\toutb(0x02, option_base_addr + MP_OPTR_GPODR);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tport_num &= 0x1;\n\n\t/* get interface */\n\tinterface = inb(option_base_addr + MP_OPTR_IIR0 + port_num);\n\n\t/* set GPO[1:0] = 11 */\n\toutb(0x03, option_base_addr + MP_OPTR_GPODR);\n\n\treturn (interface);\n}\n\t\t\nstatic int sb1054_get_register(struct sb_uart_port *port, int page, int reg)\n{\n\tint ret = 0;\n\tunsigned int lcr = 0;\n\tunsigned int mcr = 0;\n\tunsigned int tmp = 0;\n\n\tif( page <= 0)\n\t{\n\t\tprintk(\" page 0 can not use this fuction\\n\");\n\t\treturn -1;\n\t}\n\n\tswitch(page)\n\t{\n\t\tcase 1:\n\t\t\tlcr = SB105X_GET_LCR(port);\n\t\t\ttmp = lcr | SB105X_LCR_DLAB;\n\t\t\tSB105X_PUT_LCR(port, tmp);\n\n\t\t\ttmp = SB105X_GET_LCR(port);\n\n\t\t\tret = SB105X_GET_REG(port,reg);\n\t\t\tSB105X_PUT_LCR(port,lcr);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmcr = SB105X_GET_MCR(port);\n\t\t\ttmp = mcr | SB105X_MCR_P2S;\n\t\t\tSB105X_PUT_MCR(port,tmp);\n\n\t\t\tret = SB105X_GET_REG(port,reg);\n\n\t\t\tSB105X_PUT_MCR(port,mcr);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tlcr = SB105X_GET_LCR(port);\n\t\t\ttmp = lcr | SB105X_LCR_BF;\n\t\t\tSB105X_PUT_LCR(port,tmp);\n\t\t\tSB105X_PUT_REG(port,SB105X_PSR,SB105X_PSR_P3KEY);\n\n\t\t\tret = SB105X_GET_REG(port,reg);\n\n\t\t\tSB105X_PUT_LCR(port,lcr);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tlcr = SB105X_GET_LCR(port);\n\t\t\ttmp = lcr | SB105X_LCR_BF;\n\t\t\tSB105X_PUT_LCR(port,tmp);\n\t\t\tSB105X_PUT_REG(port,SB105X_PSR,SB105X_PSR_P4KEY);\n\n\t\t\tret = SB105X_GET_REG(port,reg);\n\n\t\t\tSB105X_PUT_LCR(port,lcr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(\" error invalid page number \\n\");\n\t\t\treturn -1;\n\t}\n\n\treturn ret;\n}\n\nstatic int sb1054_set_register(struct sb_uart_port *port, int page, int reg, int value)\n{  \n\tint lcr = 0;\n\tint mcr = 0;\n\tint ret = 0;\n\n\tif( page <= 0)\n\t{\n\t\tprintk(\" page 0 can not use this fuction\\n\");\n\t\treturn -1;\n\t}\n\tswitch(page)\n\t{\n\t\tcase 1:\n\t\t\tlcr = SB105X_GET_LCR(port);\n\t\t\tSB105X_PUT_LCR(port, lcr | SB105X_LCR_DLAB);\n\n\t\t\tSB105X_PUT_REG(port,reg,value);\n\n\t\t\tSB105X_PUT_LCR(port, lcr);\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmcr = SB105X_GET_MCR(port);\n\t\t\tSB105X_PUT_MCR(port, mcr | SB105X_MCR_P2S);\n\n\t\t\tSB105X_PUT_REG(port,reg,value);\n\n\t\t\tSB105X_PUT_MCR(port, mcr);\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tlcr = SB105X_GET_LCR(port);\n\t\t\tSB105X_PUT_LCR(port, lcr | SB105X_LCR_BF);\n\t\t\tSB105X_PUT_PSR(port, SB105X_PSR_P3KEY);\n\n\t\t\tSB105X_PUT_REG(port,reg,value);\n\n\t\t\tSB105X_PUT_LCR(port, lcr);\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tlcr = SB105X_GET_LCR(port);\n\t\t\tSB105X_PUT_LCR(port, lcr | SB105X_LCR_BF);\n\t\t\tSB105X_PUT_PSR(port, SB105X_PSR_P4KEY);\n\n\t\t\tSB105X_PUT_REG(port,reg,value);\n\n\t\t\tSB105X_PUT_LCR(port, lcr);\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(\" error invalid page number \\n\");\n\t\t\treturn -1;\n\t}\n\n\treturn ret;\n}\n\nstatic int set_multidrop_mode(struct sb_uart_port *port, unsigned int mode)\n{\n\tint mdr = SB105XA_MDR_NPS;\n\n\tif (mode & MDMODE_ENABLE)\n\t{\n\t\tmdr |= SB105XA_MDR_MDE;\n\t}\n\n\tif (1) //(mode & MDMODE_AUTO)\n\t{\n\t\tint efr = 0;\n\t\tmdr |= SB105XA_MDR_AME;\n\t\tefr = sb1054_get_register(port, PAGE_3, SB105X_EFR);\n\t\tefr |= SB105X_EFR_SCD;\n\t\tsb1054_set_register(port, PAGE_3, SB105X_EFR, efr);\n\t}\n\n\tsb1054_set_register(port, PAGE_1, SB105XA_MDR, mdr);\n\tport->mdmode &= ~0x6;\n\tport->mdmode |= mode;\n\tprintk(\"[%d] multidrop init: %x\\n\", port->line, port->mdmode);\n\n\treturn 0;\n}\n\nstatic int get_multidrop_addr(struct sb_uart_port *port)\n{\n\treturn sb1054_get_register(port, PAGE_3, SB105X_XOFF2);\n}\n\nstatic int set_multidrop_addr(struct sb_uart_port *port, unsigned int addr)\n{\n\tsb1054_set_register(port, PAGE_3, SB105X_XOFF2, addr);\n\n\treturn 0;\n}\n\nstatic void SendATCommand(struct mp_port *mtpt)\n{\n\t//\t\t      a    t\tcr   lf\n\tunsigned char ch[] = {0x61,0x74,0x0d,0x0a,0x0};\n\tunsigned char lineControl;\n\tunsigned char i=0;\n\tunsigned char Divisor = 0xc;\n\n\tlineControl = serial_inp(mtpt,UART_LCR);\n\tserial_outp(mtpt,UART_LCR,(lineControl | UART_LCR_DLAB));\n\tserial_outp(mtpt,UART_DLL,(Divisor & 0xff));\n\tserial_outp(mtpt,UART_DLM,(Divisor & 0xff00)>>8); //baudrate is 4800\n\n\n\tserial_outp(mtpt,UART_LCR,lineControl);\t\n\tserial_outp(mtpt,UART_LCR,0x03); // N-8-1\n\tserial_outp(mtpt,UART_FCR,7); \n\tserial_outp(mtpt,UART_MCR,0x3);\n\twhile(ch[i]){\n\t\twhile((serial_inp(mtpt,UART_LSR) & 0x60) !=0x60){\n\t\t\t;\n\t\t}\n\t\tserial_outp(mtpt,0,ch[i++]);\n\t}\n\n\n}// end of SendATCommand()\n\nstatic int set_deep_fifo(struct sb_uart_port *port, int status)\n{\n\tint afr_status = 0;\n\tafr_status = sb1054_get_register(port, PAGE_4, SB105X_AFR);\n\n\tif(status == ENABLE)\n\t{\n\t\tafr_status |= SB105X_AFR_AFEN;\n\t}\n\telse\n\t{\n\t\tafr_status &= ~SB105X_AFR_AFEN;\n\t}\n\t\t\n\tsb1054_set_register(port,PAGE_4,SB105X_AFR,afr_status);\n\tsb1054_set_register(port,PAGE_4,SB105X_TTR,ttr[port->line]); \n\tsb1054_set_register(port,PAGE_4,SB105X_RTR,rtr[port->line]); \n\tafr_status = sb1054_get_register(port, PAGE_4, SB105X_AFR);\n\t\t\n\treturn afr_status;\n}\n\nstatic int get_device_type(int arg)\n{\n\tint ret;\n        ret = inb(mp_devs[arg].option_reg_addr+MP_OPTR_DIR0);\n        ret = (ret & 0xf0) >> 4;\n        switch (ret)\n        {\n               case DIR_UART_16C550:\n                    return PORT_16C55X;\n               case DIR_UART_16C1050:\n                    return PORT_16C105X;\n               case DIR_UART_16C1050A:\n               /*\n               if (mtpt->port.line < 2)\n               {\n                    return PORT_16C105XA;\n               }\n               else\n               {\n                   if (mtpt->device->device_id & 0x50)\n                   {\n                       return PORT_16C55X;\n                   }\n                   else\n                   {\n                       return PORT_16C105X;\n                   }\n               }*/\n               return PORT_16C105XA;\n               default:\n                    return PORT_UNKNOWN;\n        }\n\n}\nstatic int get_deep_fifo(struct sb_uart_port *port)\n{\n\tint afr_status = 0;\n\tafr_status = sb1054_get_register(port, PAGE_4, SB105X_AFR);\n\treturn afr_status;\n}\n\nstatic int set_auto_rts(struct sb_uart_port *port, int status)\n{\n\tint atr_status = 0;\n\n#if 0\n\tint efr_status = 0;\n\n\tefr_status = sb1054_get_register(port, PAGE_3, SB105X_EFR);\n\tif(status == ENABLE)\n\t\tefr_status |= SB105X_EFR_ARTS;\n\telse\n\t\tefr_status &= ~SB105X_EFR_ARTS;\n\tsb1054_set_register(port,PAGE_3,SB105X_EFR,efr_status);\n\tefr_status = sb1054_get_register(port, PAGE_3, SB105X_EFR);\n#endif\n\t\t\n//ATR\n\tatr_status = sb1054_get_register(port, PAGE_3, SB105X_ATR);\n\tswitch(status)\n\t{\n\t\tcase RS422PTP:\n\t\t\tatr_status = (SB105X_ATR_TPS) | (SB105X_ATR_A80);\n\t\t\tbreak;\n\t\tcase RS422MD:\n\t\t\tatr_status = (SB105X_ATR_TPS) | (SB105X_ATR_TCMS) | (SB105X_ATR_A80);\n\t\t\tbreak;\n\t\tcase RS485NE:\n\t\t\tatr_status = (SB105X_ATR_RCMS) | (SB105X_ATR_TPS) | (SB105X_ATR_TCMS) | (SB105X_ATR_A80);\n\t\t\tbreak;\n\t\tcase RS485ECHO:\n\t\t\tatr_status = (SB105X_ATR_TPS) | (SB105X_ATR_TCMS) | (SB105X_ATR_A80);\n\t\t\tbreak;\n\t}\n\n\tsb1054_set_register(port,PAGE_3,SB105X_ATR,atr_status);\n\tatr_status = sb1054_get_register(port, PAGE_3, SB105X_ATR);\n\n\treturn atr_status;\n}\n\nstatic void mp_stop(struct tty_struct *tty)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\tstruct sb_uart_port *port = state->port;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tport->ops->stop_tx(port);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic void __mp_start(struct tty_struct *tty)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\tstruct sb_uart_port *port = state->port;\n\n\tif (!uart_circ_empty(&state->info->xmit) && state->info->xmit.buf &&\n\t\t\t!tty->stopped && !tty->hw_stopped)\n\t\tport->ops->start_tx(port);\n}\n\nstatic void mp_start(struct tty_struct *tty)\n{\n\t__mp_start(tty);\n}\n\nstatic void mp_tasklet_action(unsigned long data)\n{\n\tstruct sb_uart_state *state = (struct sb_uart_state *)data;\n\tstruct tty_struct *tty;\n\n\tprintk(\"tasklet is called!\\n\");\n\ttty = state->info->tty;\n\ttty_wakeup(tty);\n}\n\nstatic inline void mp_update_mctrl(struct sb_uart_port *port, unsigned int set, unsigned int clear)\n{\n\tunsigned int old;\n\n\told = port->mctrl;\n\tport->mctrl = (old & ~clear) | set;\n\tif (old != port->mctrl)\n\t\tport->ops->set_mctrl(port, port->mctrl);\n}\n\n#define uart_set_mctrl(port,set)\tmp_update_mctrl(port,set,0)\n#define uart_clear_mctrl(port,clear)\tmp_update_mctrl(port,0,clear)\n\nstatic int mp_startup(struct sb_uart_state *state, int init_hw)\n{\n\tstruct sb_uart_info *info = state->info;\n\tstruct sb_uart_port *port = state->port;\n\tunsigned long page;\n\tint retval = 0;\n\n\tif (info->flags & UIF_INITIALIZED)\n\t\treturn 0;\n\n\tif (info->tty)\n\t\tset_bit(TTY_IO_ERROR, &info->tty->flags);\n\n\tif (port->type == PORT_UNKNOWN)\n\t\treturn 0;\n\n\tif (!info->xmit.buf) {\n\t\tpage = get_zeroed_page(GFP_KERNEL);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\tinfo->xmit.buf = (unsigned char *) page;\n\t\t\t\n\t\tuart_circ_clear(&info->xmit);\n\t}\n\n\tretval = port->ops->startup(port);\n\tif (retval == 0) {\n\t\tif (init_hw) {\n\t\t\tmp_change_speed(state, NULL);\n\n\t\t\tif (info->tty->termios.c_cflag & CBAUD)\n\t\t\t\tuart_set_mctrl(port, TIOCM_RTS | TIOCM_DTR);\n\t\t}\n\n\t\tinfo->flags |= UIF_INITIALIZED;\n\n\n\t\tclear_bit(TTY_IO_ERROR, &info->tty->flags);\n\t}\n\n\tif (retval && capable(CAP_SYS_ADMIN))\n\t\tretval = 0;\n\n\treturn retval;\n}\n\nstatic void mp_shutdown(struct sb_uart_state *state)\n{\n\tstruct sb_uart_info *info = state->info;\n\tstruct sb_uart_port *port = state->port;\n\n\tif (info->tty)\n\t\tset_bit(TTY_IO_ERROR, &info->tty->flags);\n\n\tif (info->flags & UIF_INITIALIZED) {\n\t\tinfo->flags &= ~UIF_INITIALIZED;\n\n\t\tif (!info->tty || (info->tty->termios.c_cflag & HUPCL))\n\t\t\tuart_clear_mctrl(port, TIOCM_DTR | TIOCM_RTS);\n\n\t\twake_up_interruptible(&info->delta_msr_wait);\n\n\t\tport->ops->shutdown(port);\n\n\t\tsynchronize_irq(port->irq);\n\t}\n\ttasklet_kill(&info->tlet);\n\n\tif (info->xmit.buf) {\n\t\tfree_page((unsigned long)info->xmit.buf);\n\t\tinfo->xmit.buf = NULL;\n\t}\n}\n\nstatic void mp_change_speed(struct sb_uart_state *state, struct MP_TERMIOS *old_termios)\n{\n\tstruct tty_struct *tty = state->info->tty;\n\tstruct sb_uart_port *port = state->port;\n\n\tif (!tty || port->type == PORT_UNKNOWN)\n\t\treturn;\n\n\tif (tty->termios.c_cflag & CRTSCTS)\n\t\tstate->info->flags |= UIF_CTS_FLOW;\n\telse\n\t\tstate->info->flags &= ~UIF_CTS_FLOW;\n\n\tif (tty->termios.c_cflag & CLOCAL)\n\t\tstate->info->flags &= ~UIF_CHECK_CD;\n\telse\n\t\tstate->info->flags |= UIF_CHECK_CD;\n\n\tport->ops->set_termios(port, &tty->termios, old_termios);\n}\n\nstatic inline int __mp_put_char(struct sb_uart_port *port, struct circ_buf *circ, unsigned char c)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (!circ->buf)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tif (uart_circ_chars_free(circ) != 0) {\n\t\tcirc->buf[circ->head] = c;\n\t\tcirc->head = (circ->head + 1) & (UART_XMIT_SIZE - 1);\n\t\tret = 1;\n\t}\n\tspin_unlock_irqrestore(&port->lock, flags);\n\treturn ret;\n}\n\nstatic int mp_put_char(struct tty_struct *tty, unsigned char ch)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\n\treturn __mp_put_char(state->port, &state->info->xmit, ch);\n}\n\nstatic void mp_put_chars(struct tty_struct *tty)\n{\n\tmp_start(tty);\n}\n\nstatic int mp_write(struct tty_struct *tty, const unsigned char *buf, int count)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\tstruct sb_uart_port *port;\n\tstruct circ_buf *circ;\n\tint c, ret = 0;\n\n\tif (!state || !state->info) {\n\t\treturn -EL3HLT;\n\t}\n\n\tport = state->port;\n\tcirc = &state->info->xmit;\n\n\tif (!circ->buf)\n\t\treturn 0;\n\t\t\n\twhile (1) {\n\t\tc = CIRC_SPACE_TO_END(circ->head, circ->tail, UART_XMIT_SIZE);\n\t\tif (count < c)\n\t\t\tc = count;\n\t\tif (c <= 0)\n\t\t\tbreak;\n\tmemcpy(circ->buf + circ->head, buf, c);\n\n\t\tcirc->head = (circ->head + c) & (UART_XMIT_SIZE - 1);\n\t\tbuf += c;\n\t\tcount -= c;\n\t\tret += c;\n\t}\n\tmp_start(tty);\n\treturn ret;\n}\n\nstatic int mp_write_room(struct tty_struct *tty)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\n\treturn uart_circ_chars_free(&state->info->xmit);\n}\n\nstatic int mp_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\n\treturn uart_circ_chars_pending(&state->info->xmit);\n}\n\nstatic void mp_flush_buffer(struct tty_struct *tty)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\tstruct sb_uart_port *port;\n\tunsigned long flags;\n\n\tif (!state || !state->info) {\n\t\treturn;\n\t}\n\n\tport = state->port;\n\tspin_lock_irqsave(&port->lock, flags);\n\tuart_circ_clear(&state->info->xmit);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\twake_up_interruptible(&tty->write_wait);\n\ttty_wakeup(tty);\n}\n\nstatic void mp_send_xchar(struct tty_struct *tty, char ch)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\tstruct sb_uart_port *port = state->port;\n\tunsigned long flags;\n\n\tif (port->ops->send_xchar)\n\t\tport->ops->send_xchar(port, ch);\n\telse {\n\t\tport->x_char = ch;\n\t\tif (ch) {\n\t\t\tspin_lock_irqsave(&port->lock, flags);\n\t\t\tport->ops->start_tx(port);\n\t\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t\t}\n\t}\n}\n\nstatic void mp_throttle(struct tty_struct *tty)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\n\tif (I_IXOFF(tty))\n\t\tmp_send_xchar(tty, STOP_CHAR(tty));\n\n\tif (tty->termios.c_cflag & CRTSCTS)\n\t\tuart_clear_mctrl(state->port, TIOCM_RTS);\n}\n\nstatic void mp_unthrottle(struct tty_struct *tty)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\tstruct sb_uart_port *port = state->port;\n\n\tif (I_IXOFF(tty)) {\n\t\tif (port->x_char)\n\t\t\tport->x_char = 0;\n\t\telse\n\t\t\tmp_send_xchar(tty, START_CHAR(tty));\n\t}\n\n\tif (tty->termios.c_cflag & CRTSCTS)\n\t\tuart_set_mctrl(port, TIOCM_RTS);\n}\n\nstatic int mp_get_info(struct sb_uart_state *state, struct serial_struct *retinfo)\n{\n\tstruct sb_uart_port *port = state->port;\n\tstruct serial_struct tmp;\n\n\tmemset(&tmp, 0, sizeof(tmp));\n\ttmp.type\t    = port->type;\n\ttmp.line\t    = port->line;\n\ttmp.port\t    = port->iobase;\n\tif (HIGH_BITS_OFFSET)\n\t\ttmp.port_high = (long) port->iobase >> HIGH_BITS_OFFSET;\n\ttmp.irq\t\t    = port->irq;\n\ttmp.flags\t    = port->flags;\n\ttmp.xmit_fifo_size  = port->fifosize;\n\ttmp.baud_base\t    = port->uartclk / 16;\n\ttmp.close_delay\t    = state->close_delay;\n\ttmp.closing_wait    = state->closing_wait == USF_CLOSING_WAIT_NONE ?\n\t\tASYNC_CLOSING_WAIT_NONE :\n\t\tstate->closing_wait;\n\ttmp.custom_divisor  = port->custom_divisor;\n\ttmp.hub6\t    = port->hub6;\n\ttmp.io_type         = port->iotype;\n\ttmp.iomem_reg_shift = port->regshift;\n\ttmp.iomem_base      = (void *)port->mapbase;\n\n\tif (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int mp_set_info(struct sb_uart_state *state, struct serial_struct *newinfo)\n{\n\tstruct serial_struct new_serial;\n\tstruct sb_uart_port *port = state->port;\n\tunsigned long new_port;\n\tunsigned int change_irq, change_port, closing_wait;\n\tunsigned int old_custom_divisor;\n\tunsigned int old_flags, new_flags;\n\tint retval = 0;\n\n\tif (copy_from_user(&new_serial, newinfo, sizeof(new_serial)))\n\t\treturn -EFAULT;\n\n\tnew_port = new_serial.port;\n\tif (HIGH_BITS_OFFSET)\n\t\tnew_port += (unsigned long) new_serial.port_high << HIGH_BITS_OFFSET;\n\n\tnew_serial.irq = irq_canonicalize(new_serial.irq);\n\n\tclosing_wait = new_serial.closing_wait == ASYNC_CLOSING_WAIT_NONE ?\n\t\tUSF_CLOSING_WAIT_NONE : new_serial.closing_wait;\n\tMP_STATE_LOCK(state);\n\n\tchange_irq  = new_serial.irq != port->irq;\n\tchange_port = new_port != port->iobase ||\n\t\t(unsigned long)new_serial.iomem_base != port->mapbase ||\n\t\tnew_serial.hub6 != port->hub6 ||\n\t\tnew_serial.io_type != port->iotype ||\n\t\tnew_serial.iomem_reg_shift != port->regshift ||\n\t\tnew_serial.type != port->type;\n\told_flags = port->flags;\n\tnew_flags = new_serial.flags;\n\told_custom_divisor = port->custom_divisor;\n\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\tretval = -EPERM;\n\t\tif (change_irq || change_port ||\n\t\t\t\t(new_serial.baud_base != port->uartclk / 16) ||\n\t\t\t\t(new_serial.close_delay != state->close_delay) ||\n\t\t\t\t(closing_wait != state->closing_wait) ||\n\t\t\t\t(new_serial.xmit_fifo_size != port->fifosize) ||\n\t\t\t\t(((new_flags ^ old_flags) & ~UPF_USR_MASK) != 0))\n\t\t\tgoto exit;\n\t\tport->flags = ((port->flags & ~UPF_USR_MASK) |\n\t\t\t\t(new_flags & UPF_USR_MASK));\n\t\tport->custom_divisor = new_serial.custom_divisor;\n\t\tgoto check_and_exit;\n\t}\n\n\tif (port->ops->verify_port)\n\t\tretval = port->ops->verify_port(port, &new_serial);\n\n\tif ((new_serial.irq >= NR_IRQS) || (new_serial.irq < 0) ||\n\t\t\t(new_serial.baud_base < 9600))\n\t\tretval = -EINVAL;\n\n\tif (retval)\n\t\tgoto exit;\n\n\tif (change_port || change_irq) {\n\t\tretval = -EBUSY;\n\n\t\tif (uart_users(state) > 1)\n\t\t\tgoto exit;\n\n\t\tmp_shutdown(state);\n\t}\n\n\tif (change_port) {\n\t\tunsigned long old_iobase, old_mapbase;\n\t\tunsigned int old_type, old_iotype, old_hub6, old_shift;\n\n\t\told_iobase = port->iobase;\n\t\told_mapbase = port->mapbase;\n\t\told_type = port->type;\n\t\told_hub6 = port->hub6;\n\t\told_iotype = port->iotype;\n\t\told_shift = port->regshift;\n\n\t\tif (old_type != PORT_UNKNOWN)\n\t\t\tport->ops->release_port(port);\n\n\t\tport->iobase = new_port;\n\t\tport->type = new_serial.type;\n\t\tport->hub6 = new_serial.hub6;\n\t\tport->iotype = new_serial.io_type;\n\t\tport->regshift = new_serial.iomem_reg_shift;\n\t\tport->mapbase = (unsigned long)new_serial.iomem_base;\n\n\t\tif (port->type != PORT_UNKNOWN) {\n\t\t\tretval = port->ops->request_port(port);\n\t\t} else {\n\t\t\tretval = 0;\n\t\t}\n\n\t\tif (retval && old_type != PORT_UNKNOWN) {\n\t\t\tport->iobase = old_iobase;\n\t\t\tport->type = old_type;\n\t\t\tport->hub6 = old_hub6;\n\t\t\tport->iotype = old_iotype;\n\t\t\tport->regshift = old_shift;\n\t\t\tport->mapbase = old_mapbase;\n\t\t\tretval = port->ops->request_port(port);\n\t\t\tif (retval)\n\t\t\t\tport->type = PORT_UNKNOWN;\n\n\t\t\tretval = -EBUSY;\n\t\t}\n\t}\n\n\tport->irq              = new_serial.irq;\n\tport->uartclk          = new_serial.baud_base * 16;\n\tport->flags            = (port->flags & ~UPF_CHANGE_MASK) |\n\t\t(new_flags & UPF_CHANGE_MASK);\n\tport->custom_divisor   = new_serial.custom_divisor;\n\tstate->close_delay     = new_serial.close_delay;\n\tstate->closing_wait    = closing_wait;\n\tport->fifosize         = new_serial.xmit_fifo_size;\n\tif (state->info->tty)\n\t\tstate->info->tty->low_latency =\n\t\t\t(port->flags & UPF_LOW_LATENCY) ? 1 : 0;\n\ncheck_and_exit:\n\tretval = 0;\n\tif (port->type == PORT_UNKNOWN)\n\t\tgoto exit;\n\tif (state->info->flags & UIF_INITIALIZED) {\n\t\tif (((old_flags ^ port->flags) & UPF_SPD_MASK) ||\n\t\t\t\told_custom_divisor != port->custom_divisor) {\n\t\t\tif (port->flags & UPF_SPD_MASK) {\n\t\t\t\tprintk(KERN_NOTICE\n\t\t\t\t\t\t\"%s sets custom speed on ttyMP%d. This \"\n\t\t\t\t\t\t\"is deprecated.\\n\", current->comm,\n\t\t\t\t\t\tport->line);\n\t\t\t}\n\t\t\tmp_change_speed(state, NULL);\n\t\t}\n\t} else\n\t\tretval = mp_startup(state, 1);\nexit:\n\tMP_STATE_UNLOCK(state);\n\treturn retval;\n}\n\n\nstatic int mp_get_lsr_info(struct sb_uart_state *state, unsigned int *value)\n{\n\tstruct sb_uart_port *port = state->port;\n\tunsigned int result;\n\n\tresult = port->ops->tx_empty(port);\n\n\tif (port->x_char ||\n\t\t\t((uart_circ_chars_pending(&state->info->xmit) > 0) &&\n\t\t\t\t!state->info->tty->stopped && !state->info->tty->hw_stopped))\n\t\tresult &= ~TIOCSER_TEMT;\n\n\treturn put_user(result, value);\n}\n\nstatic int mp_tiocmget(struct tty_struct *tty)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\tstruct sb_uart_port *port = state->port;\n\tint result = -EIO;\n\n\tMP_STATE_LOCK(state);\n\tif (!(tty->flags & (1 << TTY_IO_ERROR))) {\n\t\tresult = port->mctrl;\n\t\tspin_lock_irq(&port->lock);\n\t\tresult |= port->ops->get_mctrl(port);\n\t\tspin_unlock_irq(&port->lock);\n\t}\n\tMP_STATE_UNLOCK(state);\n\treturn result;\n}\n\nstatic int mp_tiocmset(struct tty_struct *tty, unsigned int set, unsigned int clear)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\tstruct sb_uart_port *port = state->port;\n\tint ret = -EIO;\n\n\n\tMP_STATE_LOCK(state);\n\tif (!(tty->flags & (1 << TTY_IO_ERROR))) {\n\t\tmp_update_mctrl(port, set, clear);\n\t\tret = 0;\n\t}\n\tMP_STATE_UNLOCK(state);\n\n\treturn ret;\n}\n\nstatic int mp_break_ctl(struct tty_struct *tty, int break_state)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\tstruct sb_uart_port *port = state->port;\n\n\tMP_STATE_LOCK(state);\n\n\tif (port->type != PORT_UNKNOWN)\n\t\tport->ops->break_ctl(port, break_state);\n\n\tMP_STATE_UNLOCK(state);\n\treturn 0;\n}\n\nstatic int mp_do_autoconfig(struct sb_uart_state *state)\n{\n\tstruct sb_uart_port *port = state->port;\n\tint flags, ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (mutex_lock_interruptible(&state->mutex))\n\t\treturn -ERESTARTSYS;\n\tret = -EBUSY;\n\tif (uart_users(state) == 1) {\n\t\tmp_shutdown(state);\n\n\t\tif (port->type != PORT_UNKNOWN)\n\t\t\tport->ops->release_port(port);\n\n\t\tflags = UART_CONFIG_TYPE;\n\t\tif (port->flags & UPF_AUTO_IRQ)\n\t\t\tflags |= UART_CONFIG_IRQ;\n\n\t\tport->ops->config_port(port, flags);\n\n\t\tret = mp_startup(state, 1);\n\t}\n\tMP_STATE_UNLOCK(state);\n\treturn ret;\n}\n\nstatic int mp_wait_modem_status(struct sb_uart_state *state, unsigned long arg)\n{\n\tstruct sb_uart_port *port = state->port;\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct sb_uart_icount cprev, cnow;\n\tint ret;\n\n\tspin_lock_irq(&port->lock);\n\tmemcpy(&cprev, &port->icount, sizeof(struct sb_uart_icount));\n\n\tport->ops->enable_ms(port);\n\tspin_unlock_irq(&port->lock);\n\n\tadd_wait_queue(&state->info->delta_msr_wait, &wait);\n\tfor (;;) {\n\t\tspin_lock_irq(&port->lock);\n\t\tmemcpy(&cnow, &port->icount, sizeof(struct sb_uart_icount));\n\t\tspin_unlock_irq(&port->lock);\n\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tif (((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) ||\n\t\t\t\t((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) ||\n\t\t\t\t((arg & TIOCM_CD)  && (cnow.dcd != cprev.dcd)) ||\n\t\t\t\t((arg & TIOCM_CTS) && (cnow.cts != cprev.cts))) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tschedule();\n\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tcprev = cnow;\n\t}\n\n\tcurrent->state = TASK_RUNNING;\n\tremove_wait_queue(&state->info->delta_msr_wait, &wait);\n\n\treturn ret;\n}\n\nstatic int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt)\n{\n\tstruct serial_icounter_struct icount;\n\tstruct sb_uart_icount cnow;\n\tstruct sb_uart_port *port = state->port;\n\n\tspin_lock_irq(&port->lock);\n\tmemcpy(&cnow, &port->icount, sizeof(struct sb_uart_icount));\n\tspin_unlock_irq(&port->lock);\n\n\ticount.cts         = cnow.cts;\n\ticount.dsr         = cnow.dsr;\n\ticount.rng         = cnow.rng;\n\ticount.dcd         = cnow.dcd;\n\ticount.rx          = cnow.rx;\n\ticount.tx          = cnow.tx;\n\ticount.frame       = cnow.frame;\n\ticount.overrun     = cnow.overrun;\n\ticount.parity      = cnow.parity;\n\ticount.brk         = cnow.brk;\n\ticount.buf_overrun = cnow.buf_overrun;\n\n\treturn copy_to_user(icnt, &icount, sizeof(icount)) ? -EFAULT : 0;\n}\n\nstatic int mp_ioctl(struct tty_struct *tty, unsigned int cmd, unsigned long arg)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\tstruct mp_port *info = (struct mp_port *)state->port;\n\tint ret = -ENOIOCTLCMD;\n\n\n\tswitch (cmd) {\n\t\tcase TIOCSMULTIDROP:\n\t\t\t/* set multi-drop mode enable or disable, and default operation mode is H/W mode */\n\t\t\tif (info->port.type == PORT_16C105XA)\n\t\t\t{\n\t\t\t\t//arg &= ~0x6;\n\t\t\t\t//state->port->mdmode = 0;\n\t\t\t\treturn set_multidrop_mode((struct sb_uart_port *)info, (unsigned int)arg);\n\t\t\t}\n\t\t\tret = -ENOTSUPP;\n\t\t\tbreak;\n\t\tcase GETDEEPFIFO:\n\t\t\tret = get_deep_fifo(state->port);\n\t\t\treturn ret;\n\t\tcase SETDEEPFIFO:\n\t\t\tret = set_deep_fifo(state->port,arg);\n\t\t\tdeep[state->port->line] = arg;\n\t\t\treturn ret;\n\t\tcase SETTTR:\n\t\t\tif (info->port.type == PORT_16C105X || info->port.type == PORT_16C105XA){\n\t\t\t\tret = sb1054_set_register(state->port,PAGE_4,SB105X_TTR,arg);\n\t\t\t\tttr[state->port->line] = arg;\n\t\t\t}\n\t\t\treturn ret;\n\t\tcase SETRTR:\n\t\t\tif (info->port.type == PORT_16C105X || info->port.type == PORT_16C105XA){\n\t\t\t\tret = sb1054_set_register(state->port,PAGE_4,SB105X_RTR,arg);\n\t\t\t\trtr[state->port->line] = arg;\n\t\t\t}\n\t\t\treturn ret;\n\t\tcase GETTTR:\n\t\t\tif (info->port.type == PORT_16C105X || info->port.type == PORT_16C105XA){\n\t\t\t\tret = sb1054_get_register(state->port,PAGE_4,SB105X_TTR);\n\t\t\t}\n\t\t\treturn ret;\n\t\tcase GETRTR:\n\t\t\tif (info->port.type == PORT_16C105X || info->port.type == PORT_16C105XA){\n\t\t\t\tret = sb1054_get_register(state->port,PAGE_4,SB105X_RTR);\n\t\t\t}\n\t\t\treturn ret;\n\n\t\tcase SETFCR:\n\t\t\tif (info->port.type == PORT_16C105X || info->port.type == PORT_16C105XA){\n\t\t\t\tret = sb1054_set_register(state->port,PAGE_1,SB105X_FCR,arg);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tserial_out(info,2,arg);\n\t\t\t}\n\n\t\t\treturn ret;\n\t\tcase TIOCSMDADDR:\n\t\t\t/* set multi-drop address */\n\t\t\tif (info->port.type == PORT_16C105XA)\n\t\t\t{\n\t\t\t\tstate->port->mdmode |= MDMODE_ADDR;\n\t\t\t\treturn set_multidrop_addr((struct sb_uart_port *)info, (unsigned int)arg);\n\t\t\t}\n\t\t\tret = -ENOTSUPP;\n\t\t\tbreak;\n\n\t\tcase TIOCGMDADDR:\n\t\t\t/* set multi-drop address */\n\t\t\tif ((info->port.type == PORT_16C105XA) && (state->port->mdmode & MDMODE_ADDR))\n\t\t\t{\n\t\t\t\treturn get_multidrop_addr((struct sb_uart_port *)info);\n\t\t\t}\n\t\t\tret = -ENOTSUPP;\n\t\t\tbreak;\n\n\t\tcase TIOCSENDADDR:\n\t\t\t/* send address in multi-drop mode */\n\t\t\tif ((info->port.type == PORT_16C105XA) \n\t\t\t\t\t&& (state->port->mdmode & (MDMODE_ENABLE)))\n\t\t\t{\n\t\t\t\tif (mp_chars_in_buffer(tty) > 0)\n\t\t\t\t{\n\t\t\t\t\ttty_wait_until_sent(tty, 0);\n\t\t\t\t}\n\t\t\t\t//while ((serial_in(info, UART_LSR) & 0x60) != 0x60);\n\t\t\t\t//while (sb1054_get_register(state->port, PAGE_2, SB105X_TFCR) != 0);\n\t\t\t\twhile ((serial_in(info, UART_LSR) & 0x60) != 0x60);\n\t\t\t\tserial_out(info, UART_SCR, (int)arg);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TIOCGSERIAL:\n\t\t\tret = mp_get_info(state, (struct serial_struct *)arg);\n\t\t\tbreak;\n\n\t\tcase TIOCSSERIAL:\n\t\t\tret = mp_set_info(state, (struct serial_struct *)arg);\n\t\t\tbreak;\n\n\t\tcase TIOCSERCONFIG:\n\t\t\tret = mp_do_autoconfig(state);\n\t\t\tbreak;\n\n\t\tcase TIOCSERGWILD: /* obsolete */\n\t\tcase TIOCSERSWILD: /* obsolete */\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t\t/* for Multiport */\n\t\tcase TIOCGNUMOFPORT: /* Get number of ports */\n\t\t\treturn NR_PORTS;\n\t\tcase TIOCGGETDEVID:\n\t\t\treturn mp_devs[arg].device_id;\n\t\tcase TIOCGGETREV:\n\t\t\treturn mp_devs[arg].revision;\n\t\tcase TIOCGGETNRPORTS:\n\t\t\treturn mp_devs[arg].nr_ports;\n\t\tcase TIOCGGETBDNO:\n\t\t\treturn NR_BOARD;\n\t\tcase TIOCGGETINTERFACE:\n\t\t\tif (mp_devs[arg].revision == 0xc0)\n\t\t\t{\n\t\t\t\t/* for SB16C1053APCI */\n\t\t\t\treturn (sb1053a_get_interface(info, info->port.line));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn (inb(mp_devs[arg].option_reg_addr+MP_OPTR_IIR0+(state->port->line/8)));\n\t\t\t}\n\t\tcase TIOCGGETPORTTYPE:\n\t\t\tret = get_device_type(arg);;\n\t\t\treturn ret;\n\t\tcase TIOCSMULTIECHO: /* set to multi-drop mode(RS422) or echo mode(RS485)*/\n\t\t\toutb( ( inb(info->interface_config_addr) & ~0x03 ) | 0x01 ,  \n\t\t\t\t\tinfo->interface_config_addr);\n\t\t\treturn 0;\n\t\tcase TIOCSPTPNOECHO: /* set to multi-drop mode(RS422) or echo mode(RS485) */\n\t\t\toutb( ( inb(info->interface_config_addr) & ~0x03 )  ,             \n\t\t\t\t\tinfo->interface_config_addr);\n\t\t\treturn 0;\n\t}\n\n\tif (ret != -ENOIOCTLCMD)\n\t\tgoto out;\n\n\tif (tty->flags & (1 << TTY_IO_ERROR)) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tswitch (cmd) {\n\t\tcase TIOCMIWAIT:\n\t\t\tret = mp_wait_modem_status(state, arg);\n\t\t\tbreak;\n\n\t\tcase TIOCGICOUNT:\n\t\t\tret = mp_get_count(state, (struct serial_icounter_struct *)arg);\n\t\t\tbreak;\n\t}\n\n\tif (ret != -ENOIOCTLCMD)\n\t\tgoto out;\n\n\tMP_STATE_LOCK(state);\n\tswitch (cmd) {\n\t\tcase TIOCSERGETLSR: /* Get line status register */\n\t\t\tret = mp_get_lsr_info(state, (unsigned int *)arg);\n\t\t\tbreak;\n\n\t\tdefault: {\n\t\t\t\t\tstruct sb_uart_port *port = state->port;\n\t\t\t\t\tif (port->ops->ioctl)\n\t\t\t\t\t\tret = port->ops->ioctl(port, cmd, arg);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t}\n\n\tMP_STATE_UNLOCK(state);\nout:\n\treturn ret;\n}\n\nstatic void mp_set_termios(struct tty_struct *tty, struct MP_TERMIOS *old_termios)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\tunsigned long flags;\n\tunsigned int cflag = tty->termios.c_cflag;\n\n#define RELEVANT_IFLAG(iflag)\t((iflag) & (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))\n\n\tif ((cflag ^ old_termios->c_cflag) == 0 &&\n\t\t\tRELEVANT_IFLAG(tty->termios.c_iflag ^ old_termios->c_iflag) == 0)\n\t\treturn;\n\n\tmp_change_speed(state, old_termios);\n\n\tif ((old_termios->c_cflag & CBAUD) && !(cflag & CBAUD))\n\t\tuart_clear_mctrl(state->port, TIOCM_RTS | TIOCM_DTR);\n\n\tif (!(old_termios->c_cflag & CBAUD) && (cflag & CBAUD)) {\n\t\tunsigned int mask = TIOCM_DTR;\n\t\tif (!(cflag & CRTSCTS) ||\n\t\t\t\t!test_bit(TTY_THROTTLED, &tty->flags))\n\t\t\tmask |= TIOCM_RTS;\n\t\tuart_set_mctrl(state->port, mask);\n\t}\n\n\tif ((old_termios->c_cflag & CRTSCTS) && !(cflag & CRTSCTS)) {\n\t\tspin_lock_irqsave(&state->port->lock, flags);\n\t\ttty->hw_stopped = 0;\n\t\t__mp_start(tty);\n\t\tspin_unlock_irqrestore(&state->port->lock, flags);\n\t}\n\n\tif (!(old_termios->c_cflag & CRTSCTS) && (cflag & CRTSCTS)) {\n\t\tspin_lock_irqsave(&state->port->lock, flags);\n\t\tif (!(state->port->ops->get_mctrl(state->port) & TIOCM_CTS)) {\n\t\t\ttty->hw_stopped = 1;\n\t\t\tstate->port->ops->stop_tx(state->port);\n\t\t}\n\t\tspin_unlock_irqrestore(&state->port->lock, flags);\n\t}\n}\n\nstatic void mp_close(struct tty_struct *tty, struct file *filp)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\tstruct sb_uart_port *port;\n\n\tprintk(\"mp_close!\\n\");\n\tif (!state || !state->port)\n\t\treturn;\n\n\tport = state->port;\n\n\tprintk(\"close1 %d\\n\", __LINE__);\n\tMP_STATE_LOCK(state);\n\n\tprintk(\"close2 %d\\n\", __LINE__);\n\tif (tty_hung_up_p(filp))\n\t\tgoto done;\n\n\tprintk(\"close3 %d\\n\", __LINE__);\n\tif ((tty->count == 1) && (state->count != 1)) {\n\t\tprintk(\"mp_close: bad serial port count; tty->count is 1, \"\n\t\t\t\t\"state->count is %d\\n\", state->count);\n\t\tstate->count = 1;\n\t}\n\tprintk(\"close4 %d\\n\", __LINE__);\n\tif (--state->count < 0) {\n\t\tprintk(\"rs_close: bad serial port count for ttyMP%d: %d\\n\",\n\t\t\t\tport->line, state->count);\n\t\tstate->count = 0;\n\t}\n\tif (state->count)\n\t\tgoto done;\n\n\ttty->closing = 1;\n\n\tprintk(\"close5 %d\\n\", __LINE__);\n\tif (state->closing_wait != USF_CLOSING_WAIT_NONE)\n\t\ttty_wait_until_sent(tty, state->closing_wait);\n\n\tprintk(\"close6 %d\\n\", __LINE__);\n\tif (state->info->flags & UIF_INITIALIZED) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&port->lock, flags);\n\t\tport->ops->stop_rx(port);\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t\tmp_wait_until_sent(tty, port->timeout);\n\t}\n\tprintk(\"close7 %d\\n\", __LINE__);\n\n\tmp_shutdown(state);\n\tprintk(\"close8 %d\\n\", __LINE__);\n\tmp_flush_buffer(tty);\n\ttty_ldisc_flush(tty);\n\ttty->closing = 0;\n\tstate->info->tty = NULL;\n\tif (state->info->blocked_open) \n\t{\n\t\tif (state->close_delay)\n\t\t{\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tschedule_timeout(state->close_delay);\n\t\t}\n\t}\n\telse\n\t{\n\t\tmp_change_pm(state, 3);\n\t}\n\tprintk(\"close8 %d\\n\", __LINE__);\n\n\tstate->info->flags &= ~UIF_NORMAL_ACTIVE;\n\twake_up_interruptible(&state->info->open_wait);\n\ndone:\n\tprintk(\"close done\\n\");\n\tMP_STATE_UNLOCK(state);\n\tmodule_put(THIS_MODULE);\n}\n\nstatic void mp_wait_until_sent(struct tty_struct *tty, int timeout)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\tstruct sb_uart_port *port = state->port;\n\tunsigned long char_time, expire;\n\n\tif (port->type == PORT_UNKNOWN || port->fifosize == 0)\n\t\treturn;\n\n\tchar_time = (port->timeout - HZ/50) / port->fifosize;\n\tchar_time = char_time / 5;\n\tif (char_time == 0)\n\t\tchar_time = 1;\n\tif (timeout && timeout < char_time)\n\t\tchar_time = timeout;\n\n\tif (timeout == 0 || timeout > 2 * port->timeout)\n\t\ttimeout = 2 * port->timeout;\n\n\texpire = jiffies + timeout;\n\n\twhile (!port->ops->tx_empty(port)) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule_timeout(char_time);\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tif (time_after(jiffies, expire))\n\t\t\tbreak;\n\t}\n\tset_current_state(TASK_RUNNING); /* might not be needed */\n}\n\nstatic void mp_hangup(struct tty_struct *tty)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\n\tMP_STATE_LOCK(state);\n\tif (state->info && state->info->flags & UIF_NORMAL_ACTIVE) {\n\t\tmp_flush_buffer(tty);\n\t\tmp_shutdown(state);\n\t\tstate->count = 0;\n\t\tstate->info->flags &= ~UIF_NORMAL_ACTIVE;\n\t\tstate->info->tty = NULL;\n\t\twake_up_interruptible(&state->info->open_wait);\n\t\twake_up_interruptible(&state->info->delta_msr_wait);\n\t}\n\tMP_STATE_UNLOCK(state);\n}\n\nstatic void mp_update_termios(struct sb_uart_state *state)\n{\n\tstruct tty_struct *tty = state->info->tty;\n\tstruct sb_uart_port *port = state->port;\n\n\tif (!(tty->flags & (1 << TTY_IO_ERROR))) {\n\t\tmp_change_speed(state, NULL);\n\n\t\tif (tty->termios.c_cflag & CBAUD)\n\t\t\tuart_set_mctrl(port, TIOCM_DTR | TIOCM_RTS);\n\t}\n}\n\nstatic int mp_block_til_ready(struct file *filp, struct sb_uart_state *state)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct sb_uart_info *info = state->info;\n\tstruct sb_uart_port *port = state->port;\n\tunsigned int mctrl;\n\n\tinfo->blocked_open++;\n\tstate->count--;\n\n\tadd_wait_queue(&info->open_wait, &wait);\n\twhile (1) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tif (tty_hung_up_p(filp) || info->tty == NULL)\n\t\t\tbreak;\n\n\t\tif (!(info->flags & UIF_INITIALIZED))\n\t\t\tbreak;\n\n\t\tif ((filp->f_flags & O_NONBLOCK) ||\n\t\t\t\t(info->tty->termios.c_cflag & CLOCAL) ||\n\t\t\t\t(info->tty->flags & (1 << TTY_IO_ERROR))) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (info->tty->termios.c_cflag & CBAUD)\n\t\t\tuart_set_mctrl(port, TIOCM_DTR);\n\n\t\tspin_lock_irq(&port->lock);\n\t\tport->ops->enable_ms(port);\n\t\tmctrl = port->ops->get_mctrl(port);\n\t\tspin_unlock_irq(&port->lock);\n\t\tif (mctrl & TIOCM_CAR)\n\t\t\tbreak;\n\n\t\tMP_STATE_UNLOCK(state);\n\t\tschedule();\n\t\tMP_STATE_LOCK(state);\n\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&info->open_wait, &wait);\n\n\tstate->count++;\n\tinfo->blocked_open--;\n\n\tif (signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\n\tif (!info->tty || tty_hung_up_p(filp))\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nstatic struct sb_uart_state *uart_get(struct uart_driver *drv, int line)\n{\n\tstruct sb_uart_state *state;\n\n\tMP_MUTEX_LOCK(mp_mutex);\n\tstate = drv->state + line;\n\tif (mutex_lock_interruptible(&state->mutex)) {\n\t\tstate = ERR_PTR(-ERESTARTSYS);\n\t\tgoto out;\n\t}\n\tstate->count++;\n\tif (!state->port) {\n\t\tstate->count--;\n\t\tMP_STATE_UNLOCK(state);\n\t\tstate = ERR_PTR(-ENXIO);\n\t\tgoto out;\n\t}\n\n\tif (!state->info) {\n\t\tstate->info = kmalloc(sizeof(struct sb_uart_info), GFP_KERNEL);\n\t\tif (state->info) {\n\t\t\tmemset(state->info, 0, sizeof(struct sb_uart_info));\n\t\t\tinit_waitqueue_head(&state->info->open_wait);\n\t\t\tinit_waitqueue_head(&state->info->delta_msr_wait);\n\n\t\t\tstate->port->info = state->info;\n\n\t\t\ttasklet_init(&state->info->tlet, mp_tasklet_action,\n\t\t\t\t\t(unsigned long)state);\n\t\t} else {\n\t\t\tstate->count--;\n\t\t\tMP_STATE_UNLOCK(state);\n\t\t\tstate = ERR_PTR(-ENOMEM);\n\t\t}\n\t}\n\nout:\n\tMP_MUTEX_UNLOCK(mp_mutex);\n\treturn state;\n}\n\nstatic int mp_open(struct tty_struct *tty, struct file *filp)\n{\n\tstruct uart_driver *drv = (struct uart_driver *)tty->driver->driver_state;\n\tstruct sb_uart_state *state;\n\tint retval;\n\tint  line = tty->index;\n\tstruct mp_port *mtpt;\n\n\tretval = -ENODEV;\n\tif (line >= tty->driver->num)\n\t\tgoto fail;\n\n\tstate = uart_get(drv, line);\n\n\tif (IS_ERR(state)) {\n\t\tretval = PTR_ERR(state);\n\t\tgoto fail;\n\t}\n\n\tmtpt  = (struct mp_port *)state->port;\n\n\ttty->driver_data = state;\n\ttty->low_latency = (state->port->flags & UPF_LOW_LATENCY) ? 1 : 0;\n\ttty->alt_speed = 0;\n\tstate->info->tty = tty;\n\n\tif (tty_hung_up_p(filp)) {\n\t\tretval = -EAGAIN;\n\t\tstate->count--;\n\t\tMP_STATE_UNLOCK(state);\n\t\tgoto fail;\n\t}\n\n\tif (state->count == 1)\n\t\tmp_change_pm(state, 0);\n\n\tretval = mp_startup(state, 0);\n\n\tif (retval == 0)\n\t\tretval = mp_block_til_ready(filp, state);\n\tMP_STATE_UNLOCK(state);\n\n\tif (retval == 0 && !(state->info->flags & UIF_NORMAL_ACTIVE)) {\n\t\tstate->info->flags |= UIF_NORMAL_ACTIVE;\n\n\t\tmp_update_termios(state);\n\t}\n\n\tuart_clear_mctrl(state->port, TIOCM_RTS);\n\ttry_module_get(THIS_MODULE);\nfail:\n\treturn retval;\n}\n\n\nstatic const char *mp_type(struct sb_uart_port *port)\n{\n\tconst char *str = NULL;\n\n\tif (port->ops->type)\n\t\tstr = port->ops->type(port);\n\n\tif (!str)\n\t\tstr = \"unknown\";\n\n\treturn str;\n}\n\nstatic void mp_change_pm(struct sb_uart_state *state, int pm_state)\n{\n\tstruct sb_uart_port *port = state->port;\n\tif (port->ops->pm)\n\t\tport->ops->pm(port, pm_state, state->pm_state);\n\tstate->pm_state = pm_state;\n}\n\nstatic inline void mp_report_port(struct uart_driver *drv, struct sb_uart_port *port)\n{\n\tchar address[64];\n\n\tswitch (port->iotype) {\n\t\tcase UPIO_PORT:\n\t\t\tsnprintf(address, sizeof(address),\"I/O 0x%x\", port->iobase);\n\t\t\tbreak;\n\t\tcase UPIO_HUB6:\n\t\t\tsnprintf(address, sizeof(address),\"I/O 0x%x offset 0x%x\", port->iobase, port->hub6);\n\t\t\tbreak;\n\t\tcase UPIO_MEM:\n\t\t\tsnprintf(address, sizeof(address),\"MMIO 0x%lx\", port->mapbase);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnprintf(address, sizeof(address),\"*unknown*\" );\n\t\t\tstrlcpy(address, \"*unknown*\", sizeof(address));\n\t\t\tbreak;\n\t}\n\n\tprintk( \"%s%d at %s (irq = %d) is a %s\\n\",\n\t\t\tdrv->dev_name, port->line, address, port->irq, mp_type(port));\n\n}\n\nstatic void mp_configure_port(struct uart_driver *drv, struct sb_uart_state *state, struct sb_uart_port *port)\n{\n\tunsigned int flags;\n\n\n\tif (!port->iobase && !port->mapbase && !port->membase)\n\t{\n\t\tDPRINTK(\"%s error \\n\",__FUNCTION__);\n\t\treturn;\n\t}\n\tflags = UART_CONFIG_TYPE;\n\tif (port->flags & UPF_AUTO_IRQ)\n\t\tflags |= UART_CONFIG_IRQ;\n\tif (port->flags & UPF_BOOT_AUTOCONF) {\n\t\tport->type = PORT_UNKNOWN;\n\t\tport->ops->config_port(port, flags);\n\t}\n\n\tif (port->type != PORT_UNKNOWN) {\n\t\tunsigned long flags;\n\n\t\tmp_report_port(drv, port);\n\n\t\tspin_lock_irqsave(&port->lock, flags);\n\t\tport->ops->set_mctrl(port, 0);\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\n\t\tmp_change_pm(state, 3);\n\t}\n}\n\nstatic void mp_unconfigure_port(struct uart_driver *drv, struct sb_uart_state *state)\n{\n\tstruct sb_uart_port *port = state->port;\n\tstruct sb_uart_info *info = state->info;\n\n\tif (info && info->tty)\n\t\ttty_hangup(info->tty);\n\n\tMP_STATE_LOCK(state);\n\n\tstate->info = NULL;\n\n\tif (port->type != PORT_UNKNOWN)\n\t\tport->ops->release_port(port);\n\n\tport->type = PORT_UNKNOWN;\n\n\tif (info) {\n\t\ttasklet_kill(&info->tlet);\n\t\tkfree(info);\n\t}\n\n\tMP_STATE_UNLOCK(state);\n}\nstatic struct tty_operations mp_ops = {\n\t.open\t\t= mp_open,\n\t.close\t\t= mp_close,\n\t.write\t\t= mp_write,\n\t.put_char\t= mp_put_char,\n\t.flush_chars\t= mp_put_chars,\n\t.write_room\t= mp_write_room,\n\t.chars_in_buffer= mp_chars_in_buffer,\n\t.flush_buffer\t= mp_flush_buffer,\n\t.ioctl\t\t= mp_ioctl,\n\t.throttle\t= mp_throttle,\n\t.unthrottle\t= mp_unthrottle,\n\t.send_xchar\t= mp_send_xchar,\n\t.set_termios\t= mp_set_termios,\n\t.stop\t\t= mp_stop,\n\t.start\t\t= mp_start,\n\t.hangup\t\t= mp_hangup,\n\t.break_ctl\t= mp_break_ctl,\n\t.wait_until_sent= mp_wait_until_sent,\n#ifdef CONFIG_PROC_FS\n\t.proc_fops\t= NULL,\n#endif\n\t.tiocmget\t= mp_tiocmget,\n\t.tiocmset\t= mp_tiocmset,\n};\n\nstatic int mp_register_driver(struct uart_driver *drv)\n{\n\tstruct tty_driver *normal = NULL;\n\tint i, retval;\n\n\tdrv->state = kmalloc(sizeof(struct sb_uart_state) * drv->nr, GFP_KERNEL);\n\tretval = -ENOMEM;\n\tif (!drv->state)\n\t{\n\t\tprintk(\"SB PCI Error: Kernel memory allocation error!\\n\");\n\t\tgoto out;\n\t}\n\tmemset(drv->state, 0, sizeof(struct sb_uart_state) * drv->nr);\n\n\tnormal = alloc_tty_driver(drv->nr);\n\tif (!normal)\n\t{\n\t\tprintk(\"SB PCI Error: tty allocation error!\\n\");\n\t\tgoto out;\n\t}\n\n\tdrv->tty_driver = normal;\n\n\tnormal->owner           = drv->owner;\n\tnormal->magic\t\t= TTY_DRIVER_MAGIC;\n\tnormal->driver_name     = drv->driver_name;\n\tnormal->name\t\t= drv->dev_name;\n\tnormal->major\t\t= drv->major;\n\tnormal->minor_start\t= drv->minor;\n\n\tnormal->num\t\t= MAX_MP_PORT ; \n\n\tnormal->type\t\t= TTY_DRIVER_TYPE_SERIAL;\n\tnormal->subtype\t\t= SERIAL_TYPE_NORMAL;\n\tnormal->init_termios\t= tty_std_termios;\n\tnormal->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;\n\tnormal->flags\t\t= TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;\n\tnormal->driver_state    = drv;\n\n\ttty_set_operations(normal, &mp_ops);\n\nfor (i = 0; i < drv->nr; i++) {\n\tstruct sb_uart_state *state = drv->state + i;\n\n\tstate->close_delay     = 500;   \n\tstate->closing_wait    = 30000; \n\n\tmutex_init(&state->mutex);\n\t}\n\n\tretval = tty_register_driver(normal);\nout:\n\tif (retval < 0) {\n\t\tprintk(\"Register tty driver Fail!\\n\");\n\t\tput_tty_driver(normal);\n\t\tkfree(drv->state);\n\t}\n\n\treturn retval;\n}\n\nvoid mp_unregister_driver(struct uart_driver *drv)\n{\n    struct tty_driver *normal = NULL;\n\n    normal = drv->tty_driver;\n\n    if (!normal)\n    {\n        return;\n    }\n\n    tty_unregister_driver(normal);\n    put_tty_driver(normal);\n    drv->tty_driver = NULL;\n\n\n    if (drv->state)\n    {\n        kfree(drv->state);\n    }\n\n}\n\nstatic int mp_add_one_port(struct uart_driver *drv, struct sb_uart_port *port)\n{\n\tstruct sb_uart_state *state;\n\tint ret = 0;\n\n\n\tif (port->line >= drv->nr)\n\t\treturn -EINVAL;\n\n\tstate = drv->state + port->line;\n\n\tMP_MUTEX_LOCK(mp_mutex);\n\tif (state->port) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tstate->port = port;\n\n\tspin_lock_init(&port->lock);\n\tport->cons = drv->cons;\n\tport->info = state->info;\n\n\tmp_configure_port(drv, state, port);\n\n\ttty_register_device(drv->tty_driver, port->line, port->dev);\n\nout:\n\tMP_MUTEX_UNLOCK(mp_mutex);\n\n\n\treturn ret;\n}\n\nstatic int mp_remove_one_port(struct uart_driver *drv, struct sb_uart_port *port)\n{\n\tstruct sb_uart_state *state = drv->state + port->line;\n\n\tif (state->port != port)\n\t\tprintk(KERN_ALERT \"Removing wrong port: %p != %p\\n\",\n\t\t\t\tstate->port, port);\n\n\tMP_MUTEX_LOCK(mp_mutex);\n\n\ttty_unregister_device(drv->tty_driver, port->line);\n\n\tmp_unconfigure_port(drv, state);\n\tstate->port = NULL;\n\tMP_MUTEX_UNLOCK(mp_mutex);\n\n\treturn 0;\n}\n\nstatic void autoconfig(struct mp_port *mtpt, unsigned int probeflags)\n{\n\tunsigned char status1, scratch, scratch2, scratch3;\n\tunsigned char save_lcr, save_mcr;\n\tunsigned long flags;\n\n\tunsigned char u_type;\n\tunsigned char b_ret = 0;\n\n\tif (!mtpt->port.iobase && !mtpt->port.mapbase && !mtpt->port.membase)\n\t\treturn;\n\n\tDEBUG_AUTOCONF(\"ttyMP%d: autoconf (0x%04x, 0x%p): \",\n\t\t\tmtpt->port.line, mtpt->port.iobase, mtpt->port.membase);\n\n\tspin_lock_irqsave(&mtpt->port.lock, flags);\n\n\tif (!(mtpt->port.flags & UPF_BUGGY_UART)) {\n\t\tscratch = serial_inp(mtpt, UART_IER);\n\t\tserial_outp(mtpt, UART_IER, 0);\n#ifdef __i386__\n\t\toutb(0xff, 0x080);\n#endif\n\t\tscratch2 = serial_inp(mtpt, UART_IER) & 0x0f;\n\t\tserial_outp(mtpt, UART_IER, 0x0F);\n#ifdef __i386__\n\t\toutb(0, 0x080);\n#endif\n\t\tscratch3 = serial_inp(mtpt, UART_IER) & 0x0F;\n\t\tserial_outp(mtpt, UART_IER, scratch);\n\t\tif (scratch2 != 0 || scratch3 != 0x0F) {\n\t\t\tDEBUG_AUTOCONF(\"IER test failed (%02x, %02x) \",\n\t\t\t\t\tscratch2, scratch3);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tsave_mcr = serial_in(mtpt, UART_MCR);\n\tsave_lcr = serial_in(mtpt, UART_LCR);\n\n\tif (!(mtpt->port.flags & UPF_SKIP_TEST)) {\n\t\tserial_outp(mtpt, UART_MCR, UART_MCR_LOOP | 0x0A);\n\t\tstatus1 = serial_inp(mtpt, UART_MSR) & 0xF0;\n\t\tserial_outp(mtpt, UART_MCR, save_mcr);\n\t\tif (status1 != 0x90) {\n\t\t\tDEBUG_AUTOCONF(\"LOOP test failed (%02x) \",\n\t\t\t\t\tstatus1);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tserial_outp(mtpt, UART_LCR, 0xBF);\n\tserial_outp(mtpt, UART_EFR, 0);\n\tserial_outp(mtpt, UART_LCR, 0);\n\n\tserial_outp(mtpt, UART_FCR, UART_FCR_ENABLE_FIFO);\n\tscratch = serial_in(mtpt, UART_IIR) >> 6;\n\n\tDEBUG_AUTOCONF(\"iir=%d \", scratch);\n\tif(mtpt->device->nr_ports >= 8)\n\t\tb_ret = read_option_register(mtpt,(MP_OPTR_DIR0 + ((mtpt->port.line)/8)));\n\telse\t\n\t\tb_ret = read_option_register(mtpt,MP_OPTR_DIR0);\n\tu_type = (b_ret & 0xf0) >> 4;\n\tif(mtpt->port.type == PORT_UNKNOWN )\n\t{\n\t\tswitch (u_type)\n\t\t{\n\t\t\tcase DIR_UART_16C550:\n\t\t\t\tmtpt->port.type = PORT_16C55X;\n\t\t\t\tbreak;\n\t\t\tcase DIR_UART_16C1050:\n\t\t\t\tmtpt->port.type = PORT_16C105X;\n\t\t\t\tbreak;\n\t\t\tcase DIR_UART_16C1050A:\n\t\t\t\tif (mtpt->port.line < 2)\n\t\t\t\t{\n\t\t\t\t\tmtpt->port.type = PORT_16C105XA;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (mtpt->device->device_id & 0x50)\n\t\t\t\t\t{\n\t\t\t\t\t\tmtpt->port.type = PORT_16C55X;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tmtpt->port.type = PORT_16C105X;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\t\n\t\t\t\tmtpt->port.type = PORT_UNKNOWN;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(mtpt->port.type == PORT_UNKNOWN )\n\t{\nprintk(\"unknow2\\n\");\n\t\tswitch (scratch) {\n\t\t\tcase 0:\n\t\t\tcase 1:\n\t\t\t\tmtpt->port.type = PORT_UNKNOWN;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\tcase 3:\n\t\t\t\tmtpt->port.type = PORT_16C55X;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tserial_outp(mtpt, UART_LCR, save_lcr);\n\n\tmtpt->port.fifosize = uart_config[mtpt->port.type].dfl_xmit_fifo_size;\n\tmtpt->capabilities = uart_config[mtpt->port.type].flags;\n\n\tif (mtpt->port.type == PORT_UNKNOWN)\n\t\tgoto out;\n\tserial_outp(mtpt, UART_MCR, save_mcr);\n\tserial_outp(mtpt, UART_FCR, (UART_FCR_ENABLE_FIFO |\n\t\t\t\tUART_FCR_CLEAR_RCVR |\n\t\t\t\tUART_FCR_CLEAR_XMIT));\n\tserial_outp(mtpt, UART_FCR, 0);\n\t(void)serial_in(mtpt, UART_RX);\n\tserial_outp(mtpt, UART_IER, 0);\n\nout:\n\tspin_unlock_irqrestore(&mtpt->port.lock, flags);\n\tDEBUG_AUTOCONF(\"type=%s\\n\", uart_config[mtpt->port.type].name);\n}\n\nstatic void autoconfig_irq(struct mp_port *mtpt)\n{\n\tunsigned char save_mcr, save_ier;\n\tunsigned long irqs;\n\tint irq;\n\n\t/* forget possible initially masked and pending IRQ */\n\tprobe_irq_off(probe_irq_on());\n\tsave_mcr = serial_inp(mtpt, UART_MCR);\n\tsave_ier = serial_inp(mtpt, UART_IER);\n\tserial_outp(mtpt, UART_MCR, UART_MCR_OUT1 | UART_MCR_OUT2);\n\n\tirqs = probe_irq_on();\n\tserial_outp(mtpt, UART_MCR, 0);\n\tserial_outp(mtpt, UART_MCR,\n\t\tUART_MCR_DTR | UART_MCR_RTS | UART_MCR_OUT2);\n\n\tserial_outp(mtpt, UART_IER, 0x0f);    /* enable all intrs */\n\t(void)serial_inp(mtpt, UART_LSR);\n\t(void)serial_inp(mtpt, UART_RX);\n\t(void)serial_inp(mtpt, UART_IIR);\n\t(void)serial_inp(mtpt, UART_MSR);\n\tserial_outp(mtpt, UART_TX, 0xFF);\n\tirq = probe_irq_off(irqs);\n\n\tserial_outp(mtpt, UART_MCR, save_mcr);\n\tserial_outp(mtpt, UART_IER, save_ier);\n\n\tmtpt->port.irq = (irq > 0) ? irq : 0;\n}\n\nstatic void multi_stop_tx(struct sb_uart_port *port)\n{\n\tstruct mp_port *mtpt = (struct mp_port *)port;\n\n\tif (mtpt->ier & UART_IER_THRI) {\n\t\tmtpt->ier &= ~UART_IER_THRI;\n\t\tserial_out(mtpt, UART_IER, mtpt->ier);\n\t}\n\n\ttasklet_schedule(&port->info->tlet);\n}\n\nstatic void multi_start_tx(struct sb_uart_port *port)\n{\n\tstruct mp_port *mtpt = (struct mp_port *)port;\n\n\tif (!(mtpt->ier & UART_IER_THRI)) {\n\t\tmtpt->ier |= UART_IER_THRI;\n\t\tserial_out(mtpt, UART_IER, mtpt->ier);\n\t}\n}\n\nstatic void multi_stop_rx(struct sb_uart_port *port)\n{\n\tstruct mp_port *mtpt = (struct mp_port *)port;\n\n\tmtpt->ier &= ~UART_IER_RLSI;\n\tmtpt->port.read_status_mask &= ~UART_LSR_DR;\n\tserial_out(mtpt, UART_IER, mtpt->ier);\n}\n\nstatic void multi_enable_ms(struct sb_uart_port *port)\n{\n\tstruct mp_port *mtpt = (struct mp_port *)port;\n\n\tmtpt->ier |= UART_IER_MSI;\n\tserial_out(mtpt, UART_IER, mtpt->ier);\n}\n\n\nstatic _INLINE_ void receive_chars(struct mp_port *mtpt, int *status )\n{\n\tstruct tty_struct *tty = mtpt->port.info->tty;\n\tunsigned char lsr = *status;\n\tint max_count = 256;\n\tunsigned char ch;\n\tchar flag;\n\n\t//lsr &= mtpt->port.read_status_mask;\n\n\tdo {\n\t\tif ((lsr & UART_LSR_PE) && (mtpt->port.mdmode & MDMODE_ENABLE))\n\t\t{\n\t\t\tch = serial_inp(mtpt, UART_RX);\n\t\t}\n\t\telse if (lsr & UART_LSR_SPECIAL) \n\t\t{\n\t\t\tflag = 0;\n\t\t\tch = serial_inp(mtpt, UART_RX);\n\n\t\t\tif (lsr & UART_LSR_BI) \n\t\t\t{\n\n\t\t\t\tmtpt->port.icount.brk++;\n\t\t\t\tflag = TTY_BREAK;\n\n\t\t\t\tif (sb_uart_handle_break(&mtpt->port))\n\t\t\t\t\tgoto ignore_char;\n\t\t\t} \n\t\t\tif (lsr & UART_LSR_PE)\n\t\t\t{\n\t\t\t\tmtpt->port.icount.parity++;\n\t\t\t\tflag = TTY_PARITY;\n\t\t\t}\n\t\t\tif (lsr & UART_LSR_FE)\n\t\t\t{\n\t\t\t\tmtpt->port.icount.frame++;\n\t\t\t\tflag = TTY_FRAME;\n\t\t\t}\n\t\t\tif (lsr & UART_LSR_OE)\n\t\t\t{\n\t\t\t\tmtpt->port.icount.overrun++;\n\t\t\t\tflag = TTY_OVERRUN;\n\t\t\t}\n\t\t\ttty_insert_flip_char(tty, ch, flag);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tch = serial_inp(mtpt, UART_RX);\n\t\t\ttty_insert_flip_char(tty, ch, 0);\n\t\t}\nignore_char:\n\t\tlsr = serial_inp(mtpt, UART_LSR);\n\t} while ((lsr & UART_LSR_DR) && (max_count-- > 0));\n\n\ttty_flip_buffer_push(tty);\n}\n\n\n\n\nstatic _INLINE_ void transmit_chars(struct mp_port *mtpt)\n{\n\tstruct circ_buf *xmit = &mtpt->port.info->xmit;\n\tint count;\n\n\tif (mtpt->port.x_char) {\n\t\tserial_outp(mtpt, UART_TX, mtpt->port.x_char);\n\t\tmtpt->port.icount.tx++;\n\t\tmtpt->port.x_char = 0;\n\t\treturn;\n\t}\n\tif (uart_circ_empty(xmit) || uart_tx_stopped(&mtpt->port)) {\n\t\tmulti_stop_tx(&mtpt->port);\n\t\treturn;\n\t}\n\n\tcount = uart_circ_chars_pending(xmit);\n\n\tif(count > mtpt->port.fifosize)\n\t{\n\t\tcount = mtpt->port.fifosize;\n\t}\n\n\tprintk(\"[%d] mdmode: %x\\n\", mtpt->port.line, mtpt->port.mdmode);\n\tdo {\n#if 0\n\t\t/* check multi-drop mode */\n\t\tif ((mtpt->port.mdmode & (MDMODE_ENABLE | MDMODE_ADDR)) == (MDMODE_ENABLE | MDMODE_ADDR))\n\t\t{\n\t\t\tprintk(\"send address\\n\");\n\t\t\t/* send multi-drop address */\n\t\t\tserial_out(mtpt, UART_SCR, xmit->buf[xmit->tail]);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t\tserial_out(mtpt, UART_TX, xmit->buf[xmit->tail]);\n\t\t}\n\t\txmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\n\t\tmtpt->port.icount.tx++;\n\t} while (--count > 0);\n}\n\n\n\nstatic _INLINE_ void check_modem_status(struct mp_port *mtpt)\n{\n\tint status;\n\n\tstatus = serial_in(mtpt, UART_MSR);\n\n\tif ((status & UART_MSR_ANY_DELTA) == 0)\n\t\treturn;\n\n\tif (status & UART_MSR_TERI)\n\t\tmtpt->port.icount.rng++;\n\tif (status & UART_MSR_DDSR)\n\t\tmtpt->port.icount.dsr++;\n\tif (status & UART_MSR_DDCD)\n\t\tsb_uart_handle_dcd_change(&mtpt->port, status & UART_MSR_DCD);\n\tif (status & UART_MSR_DCTS)\n\t\tsb_uart_handle_cts_change(&mtpt->port, status & UART_MSR_CTS);\n\n\twake_up_interruptible(&mtpt->port.info->delta_msr_wait);\n}\n\nstatic inline void multi_handle_port(struct mp_port *mtpt)\n{\n\tunsigned int status = serial_inp(mtpt, UART_LSR);\n\n\t//printk(\"lsr: %x\\n\", status);\n\n\tif ((status & UART_LSR_DR) || (status & UART_LSR_SPECIAL))\n\t\treceive_chars(mtpt, &status);\n\tcheck_modem_status(mtpt);\n\tif (status & UART_LSR_THRE)\n\t{\n\t\tif ((mtpt->port.type == PORT_16C105X)\n\t\t\t|| (mtpt->port.type == PORT_16C105XA))\n\t\t\ttransmit_chars(mtpt);\n\t\telse\n\t\t{\n\t\t\tif (mtpt->interface >= RS485NE)\n\t\t\t\tuart_set_mctrl(&mtpt->port, TIOCM_RTS);\n\t\t\t\n\t\t\ttransmit_chars(mtpt);\n\n\n\t\t\tif (mtpt->interface >= RS485NE)\n\t\t\t{\n\t\t\t\twhile((status=serial_in(mtpt,UART_LSR) &0x60)!=0x60);\n\t\t\t\tuart_clear_mctrl(&mtpt->port, TIOCM_RTS);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\nstatic irqreturn_t multi_interrupt(int irq, void *dev_id)\n{\n\tstruct irq_info *iinfo = dev_id;\n\tstruct list_head *lhead, *end = NULL;\n\tint pass_counter = 0;\n\n\n\tspin_lock(&iinfo->lock);\n\n\tlhead = iinfo->head;\n\tdo {\n\t\tstruct mp_port *mtpt;\n\t\tunsigned int iir;\n\n\t\tmtpt = list_entry(lhead, struct mp_port, list);\n\t\t\n\t\tiir = serial_in(mtpt, UART_IIR);\n\t\tprintk(\"interrupt! port %d, iir 0x%x\\n\", mtpt->port.line, iir); //wlee\n\t\tif (!(iir & UART_IIR_NO_INT)) \n\t\t{\n\t\t\tprintk(\"interrupt handle\\n\");\n\t\t\tspin_lock(&mtpt->port.lock);\n\t\t\tmulti_handle_port(mtpt);\n\t\t\tspin_unlock(&mtpt->port.lock);\n\n\t\t\tend = NULL;\n\t\t} else if (end == NULL)\n\t\t\tend = lhead;\n\n\t\tlhead = lhead->next;\n\t\tif (lhead == iinfo->head && pass_counter++ > PASS_LIMIT) \n\t\t{\n\t\t\tprintk(KERN_ERR \"multi: too much work for \"\n\t\t\t\t\t\"irq%d\\n\", irq);\n\t\t\tprintk( \"multi: too much work for \"\n\t\t\t\t\t\"irq%d\\n\", irq);\n\t\t\tbreak;\n\t\t}\n\t} while (lhead != end);\n\n\tspin_unlock(&iinfo->lock);\n\n\n        return IRQ_HANDLED;\n}\n\nstatic void serial_do_unlink(struct irq_info *i, struct mp_port *mtpt)\n{\n\tspin_lock_irq(&i->lock);\n\n\tif (!list_empty(i->head)) {\n\t\tif (i->head == &mtpt->list)\n\t\t\ti->head = i->head->next;\n\t\tlist_del(&mtpt->list);\n\t} else {\n\t\ti->head = NULL;\n\t}\n\n\tspin_unlock_irq(&i->lock);\n}\n\nstatic int serial_link_irq_chain(struct mp_port *mtpt)\n{\n\tstruct irq_info *i = irq_lists + mtpt->port.irq;\n\tint ret, irq_flags = mtpt->port.flags & UPF_SHARE_IRQ ? IRQF_SHARED : 0;\n\tspin_lock_irq(&i->lock);\n\n\tif (i->head) {\n\t\tlist_add(&mtpt->list, i->head);\n\t\tspin_unlock_irq(&i->lock);\n\n\t\tret = 0;\n\t} else {\n\t\tINIT_LIST_HEAD(&mtpt->list);\n\t\ti->head = &mtpt->list;\n\t\tspin_unlock_irq(&i->lock);\n\n\t\tret = request_irq(mtpt->port.irq, multi_interrupt,\n\t\t\t\tirq_flags, \"serial\", i);\n\t\tif (ret < 0)\n\t\t\tserial_do_unlink(i, mtpt);\n\t}\n\n\treturn ret;\n}\n\n\n\n\nstatic void serial_unlink_irq_chain(struct mp_port *mtpt)\n{\n\tstruct irq_info *i = irq_lists + mtpt->port.irq;\n\n\tif (list_empty(i->head))\n\t{\n\t\tfree_irq(mtpt->port.irq, i);\n\t}\n\tserial_do_unlink(i, mtpt);\n}\n\nstatic void multi_timeout(unsigned long data)\n{\n\tstruct mp_port *mtpt = (struct mp_port *)data;\n\n\n\tspin_lock(&mtpt->port.lock);\n\tmulti_handle_port(mtpt);\n\tspin_unlock(&mtpt->port.lock);\n\n\tmod_timer(&mtpt->timer, jiffies+1 );\n}\n\nstatic unsigned int multi_tx_empty(struct sb_uart_port *port)\n{\n\tstruct mp_port *mtpt = (struct mp_port *)port;\n\tunsigned long flags;\n\tunsigned int ret;\n\n\tspin_lock_irqsave(&mtpt->port.lock, flags);\n\tret = serial_in(mtpt, UART_LSR) & UART_LSR_TEMT ? TIOCSER_TEMT : 0;\n\tspin_unlock_irqrestore(&mtpt->port.lock, flags);\n\n\treturn ret;\n}\n\n\nstatic unsigned int multi_get_mctrl(struct sb_uart_port *port)\n{\n\tstruct mp_port *mtpt = (struct mp_port *)port;\n\tunsigned char status;\n\tunsigned int ret;\n\n\tstatus = serial_in(mtpt, UART_MSR);\n\n\tret = 0;\n\tif (status & UART_MSR_DCD)\n\t\tret |= TIOCM_CAR;\n\tif (status & UART_MSR_RI)\n\t\tret |= TIOCM_RNG;\n\tif (status & UART_MSR_DSR)\n\t\tret |= TIOCM_DSR;\n\tif (status & UART_MSR_CTS)\n\t\tret |= TIOCM_CTS;\n\treturn ret;\n}\n\nstatic void multi_set_mctrl(struct sb_uart_port *port, unsigned int mctrl)\n{\n\tstruct mp_port *mtpt = (struct mp_port *)port;\n\tunsigned char mcr = 0;\n\n\tmctrl &= 0xff;\n\n\tif (mctrl & TIOCM_RTS)\n\t\tmcr |= UART_MCR_RTS;\n\tif (mctrl & TIOCM_DTR)\n\t\tmcr |= UART_MCR_DTR;\n\tif (mctrl & TIOCM_OUT1)\n\t\tmcr |= UART_MCR_OUT1;\n\tif (mctrl & TIOCM_OUT2)\n\t\tmcr |= UART_MCR_OUT2;\n\tif (mctrl & TIOCM_LOOP)\n\t\tmcr |= UART_MCR_LOOP;\n\n\n\tserial_out(mtpt, UART_MCR, mcr);\n}\n\n\nstatic void multi_break_ctl(struct sb_uart_port *port, int break_state)\n{\n\tstruct mp_port *mtpt = (struct mp_port *)port;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mtpt->port.lock, flags);\n\tif (break_state == -1)\n\t\tmtpt->lcr |= UART_LCR_SBC;\n\telse\n\t\tmtpt->lcr &= ~UART_LCR_SBC;\n\tserial_out(mtpt, UART_LCR, mtpt->lcr);\n\tspin_unlock_irqrestore(&mtpt->port.lock, flags);\n}\n\n\n\nstatic int multi_startup(struct sb_uart_port *port)\n{\n\tstruct mp_port *mtpt = (struct mp_port *)port;\n\tunsigned long flags;\n\tint retval;\n\n\tmtpt->capabilities = uart_config[mtpt->port.type].flags;\n\tmtpt->mcr = 0;\n\n\tif (mtpt->capabilities & UART_CLEAR_FIFO) {\n\t\tserial_outp(mtpt, UART_FCR, UART_FCR_ENABLE_FIFO);\n\t\tserial_outp(mtpt, UART_FCR, UART_FCR_ENABLE_FIFO |\n\t\t\t\tUART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);\n\t\tserial_outp(mtpt, UART_FCR, 0);\n\t}\n\n\t(void) serial_inp(mtpt, UART_LSR);\n\t(void) serial_inp(mtpt, UART_RX);\n\t(void) serial_inp(mtpt, UART_IIR);\n\t(void) serial_inp(mtpt, UART_MSR);\n\t//test-wlee 9-bit disable\n\tserial_outp(mtpt, UART_MSR, 0);\n\n\n\tif (!(mtpt->port.flags & UPF_BUGGY_UART) &&\n\t\t\t(serial_inp(mtpt, UART_LSR) == 0xff)) {\n\t\tprintk(\"ttyS%d: LSR safety check engaged!\\n\", mtpt->port.line);\n\t\t//return -ENODEV;\n\t}\n\n\tif ((!is_real_interrupt(mtpt->port.irq)) || (mtpt->poll_type==TYPE_POLL)) {\n\t\tunsigned int timeout = mtpt->port.timeout;\n\n\t\ttimeout = timeout > 6 ? (timeout / 2 - 2) : 1;\n\n\t\tmtpt->timer.data = (unsigned long)mtpt;\n\t\tmod_timer(&mtpt->timer, jiffies + timeout);\n\t} \n\telse \n\t{\n\t\tretval = serial_link_irq_chain(mtpt);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\tserial_outp(mtpt, UART_LCR, UART_LCR_WLEN8);\n\n\tspin_lock_irqsave(&mtpt->port.lock, flags);\n\tif ((is_real_interrupt(mtpt->port.irq))||(mtpt->poll_type==TYPE_INTERRUPT))\n\t\tmtpt->port.mctrl |= TIOCM_OUT2;\n\n\tmulti_set_mctrl(&mtpt->port, mtpt->port.mctrl);\n\tspin_unlock_irqrestore(&mtpt->port.lock, flags);\n\n\t\n\tmtpt->ier = UART_IER_RLSI | UART_IER_RDI;\n\tserial_outp(mtpt, UART_IER, mtpt->ier);\n\n\t(void) serial_inp(mtpt, UART_LSR);\n\t(void) serial_inp(mtpt, UART_RX);\n\t(void) serial_inp(mtpt, UART_IIR);\n\t(void) serial_inp(mtpt, UART_MSR);\n\n\treturn 0;\n}\n\n\n\nstatic void multi_shutdown(struct sb_uart_port *port)\n{\n\tstruct mp_port *mtpt = (struct mp_port *)port;\n\tunsigned long flags;\n\n\n\tmtpt->ier = 0;\n\tserial_outp(mtpt, UART_IER, 0);\n\n\tspin_lock_irqsave(&mtpt->port.lock, flags);\n\tmtpt->port.mctrl &= ~TIOCM_OUT2;\n\n\tmulti_set_mctrl(&mtpt->port, mtpt->port.mctrl);\n\tspin_unlock_irqrestore(&mtpt->port.lock, flags);\n\n\tserial_out(mtpt, UART_LCR, serial_inp(mtpt, UART_LCR) & ~UART_LCR_SBC);\n\tserial_outp(mtpt, UART_FCR, UART_FCR_ENABLE_FIFO |\n\t\t\tUART_FCR_CLEAR_RCVR |\n\t\t\tUART_FCR_CLEAR_XMIT);\n\tserial_outp(mtpt, UART_FCR, 0);\n\n\n\t(void) serial_in(mtpt, UART_RX);\n\n\tif ((!is_real_interrupt(mtpt->port.irq))||(mtpt->poll_type==TYPE_POLL))\n\t{\n\t\tdel_timer_sync(&mtpt->timer);\n\t}\n\telse\n\t{\n\t\tserial_unlink_irq_chain(mtpt);\n\t}\n}\n\n\n\nstatic unsigned int multi_get_divisor(struct sb_uart_port *port, unsigned int baud)\n{\n\tunsigned int quot;\n\n\tif ((port->flags & UPF_MAGIC_MULTIPLIER) &&\n\t\t\tbaud == (port->uartclk/4))\n\t\tquot = 0x8001;\n\telse if ((port->flags & UPF_MAGIC_MULTIPLIER) &&\n\t\t\tbaud == (port->uartclk/8))\n\t\tquot = 0x8002;\n\telse\n\t\tquot = sb_uart_get_divisor(port, baud);\n\n\treturn quot;\n}\n\n\n\n\nstatic void multi_set_termios(struct sb_uart_port *port, struct MP_TERMIOS *termios, struct MP_TERMIOS *old)\n{\n\tstruct mp_port *mtpt = (struct mp_port *)port;\n\tunsigned char cval, fcr = 0;\n\tunsigned long flags;\n\tunsigned int baud, quot;\n\n\tswitch (termios->c_cflag & CSIZE) {\n\t\tcase CS5:\n\t\t\tcval = 0x00;\n\t\t\tbreak;\n\t\tcase CS6:\n\t\t\tcval = 0x01;\n\t\t\tbreak;\n\t\tcase CS7:\n\t\t\tcval = 0x02;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase CS8:\n\t\t\tcval = 0x03;\n\t\t\tbreak;\n\t}\n\n\tif (termios->c_cflag & CSTOPB)\n\t\tcval |= 0x04;\n\tif (termios->c_cflag & PARENB)\n\t\tcval |= UART_LCR_PARITY;\n\tif (!(termios->c_cflag & PARODD))\n\t\tcval |= UART_LCR_EPAR;\n\n#ifdef CMSPAR\n\tif (termios->c_cflag & CMSPAR)\n\t\tcval |= UART_LCR_SPAR;\n#endif\n\n\tbaud = sb_uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);\n\tquot = multi_get_divisor(port, baud);\n\n\tif (mtpt->capabilities & UART_USE_FIFO) {\n\t\t//if (baud < 2400)\n\t\t//\tfcr = UART_FCR_ENABLE_FIFO | UART_FCR_TRIGGER_1;\n\t\t//else\n\t\t//\tfcr = UART_FCR_ENABLE_FIFO | UART_FCR_TRIGGER_8;\n\n\t\t//\tfcr = UART_FCR_ENABLE_FIFO | 0x90;\n\t\t\tfcr = fcr_arr[mtpt->port.line];\n\t}\n\n\tspin_lock_irqsave(&mtpt->port.lock, flags);\n\n\tsb_uart_update_timeout(port, termios->c_cflag, baud);\n\n\tmtpt->port.read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;\n\tif (termios->c_iflag & INPCK)\n\t\tmtpt->port.read_status_mask |= UART_LSR_FE | UART_LSR_PE;\n\tif (termios->c_iflag & (BRKINT | PARMRK))\n\t\tmtpt->port.read_status_mask |= UART_LSR_BI;\n\n\tmtpt->port.ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tmtpt->port.ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;\n\tif (termios->c_iflag & IGNBRK) {\n\t\tmtpt->port.ignore_status_mask |= UART_LSR_BI;\n\t\tif (termios->c_iflag & IGNPAR)\n\t\t\tmtpt->port.ignore_status_mask |= UART_LSR_OE;\n\t}\n\n\tif ((termios->c_cflag & CREAD) == 0)\n\t\tmtpt->port.ignore_status_mask |= UART_LSR_DR;\n\n\tmtpt->ier &= ~UART_IER_MSI;\n\tif (UART_ENABLE_MS(&mtpt->port, termios->c_cflag))\n\t\tmtpt->ier |= UART_IER_MSI;\n\n\tserial_out(mtpt, UART_IER, mtpt->ier);\n\n\tif (mtpt->capabilities & UART_STARTECH) {\n\t\tserial_outp(mtpt, UART_LCR, 0xBF);\n\t\tserial_outp(mtpt, UART_EFR,\n\t\t\t\ttermios->c_cflag & CRTSCTS ? UART_EFR_CTS :0);\n\t}\n\n\tserial_outp(mtpt, UART_LCR, cval | UART_LCR_DLAB);/* set DLAB */\n\n\tserial_outp(mtpt, UART_DLL, quot & 0xff);     /* LS of divisor */\n\tserial_outp(mtpt, UART_DLM, quot >> 8);       /* MS of divisor */\n\n\tserial_outp(mtpt, UART_LCR, cval);        /* reset DLAB */\n\tmtpt->lcr = cval;                 /* Save LCR */\n\n\tif (fcr & UART_FCR_ENABLE_FIFO) {\n\t\t/* emulated UARTs (Lucent Venus 167x) need two steps */\n\t\tserial_outp(mtpt, UART_FCR, UART_FCR_ENABLE_FIFO);\n\t}\n\n\tserial_outp(mtpt, UART_FCR, fcr);     /* set fcr */\n\n\n\tif ((mtpt->port.type == PORT_16C105X)\n\t\t|| (mtpt->port.type == PORT_16C105XA))\n\t{\n\t\tif(deep[mtpt->port.line]!=0)\n\t\t\tset_deep_fifo(port, ENABLE);\n\n\t\tif (mtpt->interface != RS232)\n\t\t\tset_auto_rts(port,mtpt->interface);\n\n\t}\n\telse\n\t{\n\t\tif (mtpt->interface >= RS485NE)\n\t\t{\n\t\t\tuart_clear_mctrl(&mtpt->port, TIOCM_RTS);\n\t\t}\n\t}\n\n\tif(mtpt->device->device_id == PCI_DEVICE_ID_MP4M)\n\t{\n\t\tSendATCommand(mtpt);\n\t\tprintk(\"SendATCommand\\n\");\n\t}\t\n\tmulti_set_mctrl(&mtpt->port, mtpt->port.mctrl);\n\tspin_unlock_irqrestore(&mtpt->port.lock, flags);\n}\n\nstatic void multi_pm(struct sb_uart_port *port, unsigned int state, unsigned int oldstate)\n{\n\tstruct mp_port *mtpt = (struct mp_port *)port;\n\tif (state) {\n\t\tif (mtpt->capabilities & UART_STARTECH) {\n\t\t\tserial_outp(mtpt, UART_LCR, 0xBF);\n\t\t\tserial_outp(mtpt, UART_EFR, UART_EFR_ECB);\n\t\t\tserial_outp(mtpt, UART_LCR, 0);\n\t\t\tserial_outp(mtpt, UART_IER, UART_IERX_SLEEP);\n\t\t\tserial_outp(mtpt, UART_LCR, 0xBF);\n\t\t\tserial_outp(mtpt, UART_EFR, 0);\n\t\t\tserial_outp(mtpt, UART_LCR, 0);\n\t\t}\n\n\t\tif (mtpt->pm)\n\t\t\tmtpt->pm(port, state, oldstate);\n\t} \n\telse \n\t{\n\t\tif (mtpt->capabilities & UART_STARTECH) {\n\t\t\tserial_outp(mtpt, UART_LCR, 0xBF);\n\t\t\tserial_outp(mtpt, UART_EFR, UART_EFR_ECB);\n\t\t\tserial_outp(mtpt, UART_LCR, 0);\n\t\t\tserial_outp(mtpt, UART_IER, 0);\n\t\t\tserial_outp(mtpt, UART_LCR, 0xBF);\n\t\t\tserial_outp(mtpt, UART_EFR, 0);\n\t\t\tserial_outp(mtpt, UART_LCR, 0);\n\t\t}\n\n\t\tif (mtpt->pm)\n\t\t\tmtpt->pm(port, state, oldstate);\n\t}\n}\n\nstatic void multi_release_std_resource(struct mp_port *mtpt)\n{\n\tunsigned int size = 8 << mtpt->port.regshift;\n\n\tswitch (mtpt->port.iotype) {\n\t\tcase UPIO_MEM:\n\t\t\tif (!mtpt->port.mapbase)\n\t\t\t\tbreak;\n\n\t\t\tif (mtpt->port.flags & UPF_IOREMAP) {\n\t\t\t\tiounmap(mtpt->port.membase);\n\t\t\t\tmtpt->port.membase = NULL;\n\t\t\t}\n\n\t\t\trelease_mem_region(mtpt->port.mapbase, size);\n\t\t\tbreak;\n\n\t\tcase UPIO_HUB6:\n\t\tcase UPIO_PORT:\n\t\t\trelease_region(mtpt->port.iobase,size);\n\t\t\tbreak;\n\t}\n}\n\nstatic void multi_release_port(struct sb_uart_port *port)\n{\n}\n\nstatic int multi_request_port(struct sb_uart_port *port)\n{\n\treturn 0;\n}\n\nstatic void multi_config_port(struct sb_uart_port *port, int flags)\n{\n\tstruct mp_port *mtpt = (struct mp_port *)port;\n\tint probeflags = PROBE_ANY;\n\n\tif (flags & UART_CONFIG_TYPE)\n\t\tautoconfig(mtpt, probeflags);\n\tif (mtpt->port.type != PORT_UNKNOWN && flags & UART_CONFIG_IRQ)\n\t\tautoconfig_irq(mtpt);\n\n\tif (mtpt->port.type == PORT_UNKNOWN)\n\t\tmulti_release_std_resource(mtpt);\n}\n\nstatic int multi_verify_port(struct sb_uart_port *port, struct serial_struct *ser)\n{\n\tif (ser->irq >= NR_IRQS || ser->irq < 0 ||\n\t\t\tser->baud_base < 9600 || ser->type < PORT_UNKNOWN ||\n\t\t\tser->type == PORT_STARTECH)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic const char *multi_type(struct sb_uart_port *port)\n{\n\tint type = port->type;\n\n\tif (type >= ARRAY_SIZE(uart_config))\n\t\ttype = 0;\n\treturn uart_config[type].name;\n}\n\nstatic struct sb_uart_ops multi_pops = {\n\t.tx_empty   = multi_tx_empty,\n\t.set_mctrl  = multi_set_mctrl,\n\t.get_mctrl  = multi_get_mctrl,\n\t.stop_tx    = multi_stop_tx,\n\t.start_tx   = multi_start_tx,\n\t.stop_rx    = multi_stop_rx,\n\t.enable_ms  = multi_enable_ms,\n\t.break_ctl  = multi_break_ctl,\n\t.startup    = multi_startup,\n\t.shutdown   = multi_shutdown,\n\t.set_termios    = multi_set_termios,\n\t.pm     \t= multi_pm,\n\t.type       \t= multi_type,\n\t.release_port   = multi_release_port,\n\t.request_port   = multi_request_port,\n\t.config_port    = multi_config_port,\n\t.verify_port    = multi_verify_port,\n};\n\nstatic struct uart_driver multi_reg = {\n\t.owner          = THIS_MODULE,\n\t.driver_name    = \"goldel_tulip\",\n\t.dev_name       = \"ttyMP\",\n\t.major          = SB_TTY_MP_MAJOR,\n\t.minor          = 0,\n\t.nr             = MAX_MP_PORT, \n\t.cons           = NULL,\n};\n\nstatic void __init multi_init_ports(void)\n{\n\tstruct mp_port *mtpt;\n\tstatic int first = 1;\n\tint i,j,k;\n\tunsigned char osc;\n\tunsigned char b_ret = 0;\n\tstatic struct mp_device_t *sbdev; \n\n\tif (!first)\n\t\treturn;\n\tfirst = 0;\n\n\tmtpt = multi_ports; \n\n\tfor (k=0;k<NR_BOARD;k++)\n\t{\n\t\tsbdev = &mp_devs[k];\n\n\t\tfor (i = 0; i < sbdev->nr_ports; i++, mtpt++) \n\t\t{\n\t\t\tmtpt->device \t\t= sbdev;\n\t\t\tmtpt->port.iobase   = sbdev->uart_access_addr + 8*i;\n\t\t\tmtpt->port.irq      = sbdev->irq;\n\t\t\tif ( ((sbdev->device_id == PCI_DEVICE_ID_MP4)&&(sbdev->revision==0x91)))\n\t\t\t\tmtpt->interface_config_addr = sbdev->option_reg_addr + 0x08 + i;\n\t\t\telse if (sbdev->revision == 0xc0)\n\t\t\t\tmtpt->interface_config_addr = sbdev->option_reg_addr + 0x08 + (i & 0x1);\n\t\t\telse\n\t\t\t\tmtpt->interface_config_addr = sbdev->option_reg_addr + 0x08 + i/8;\n\n\t\t\tmtpt->option_base_addr = sbdev->option_reg_addr;\n\n\t\t\tmtpt->poll_type = sbdev->poll_type;\n\n\t\t\tmtpt->port.uartclk  = BASE_BAUD * 16;\n\n\t\t\t/* get input clock information */\n\t\t\tosc = inb(sbdev->option_reg_addr + MP_OPTR_DIR0 + i/8) & 0x0F;\n\t\t\tif (osc==0x0f)\n\t\t\t\tosc = 0;\n\t\t\tfor(j=0;j<osc;j++)\n\t\t\t\tmtpt->port.uartclk *= 2;\n\t\t\tmtpt->port.flags    |= STD_COM_FLAGS | UPF_SHARE_IRQ ;\n\t\t\tmtpt->port.iotype   = UPIO_PORT;\n\t\t\tmtpt->port.ops      = &multi_pops;\n\n\t\t\tif (sbdev->revision == 0xc0)\n\t\t\t{\n\t\t\t\t/* for SB16C1053APCI */\n\t\t\t\tb_ret = sb1053a_get_interface(mtpt, i);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb_ret = read_option_register(mtpt,(MP_OPTR_IIR0 + i/8));\n\t\t\t\tprintk(\"IIR_RET = %x\\n\",b_ret);\n\t\t\t}\n\n\t\t\t/* default to RS232 */\n\t\t\tmtpt->interface = RS232;\n\t\t\tif (IIR_RS422 == (b_ret & IIR_TYPE_MASK))\n\t\t\t\tmtpt->interface = RS422PTP;\n\t\t\tif (IIR_RS485 == (b_ret & IIR_TYPE_MASK))\n\t\t\t\tmtpt->interface = RS485NE;\n\t\t}\n\t}\n}\n\nstatic void __init multi_register_ports(struct uart_driver *drv)\n{\n\tint i;\n\n\tmulti_init_ports();\n\n\tfor (i = 0; i < NR_PORTS; i++) {\n\t\tstruct mp_port *mtpt = &multi_ports[i];\n\n\t\tmtpt->port.line = i;\n\t\tmtpt->port.ops = &multi_pops;\n\t\tinit_timer(&mtpt->timer);\n\t\tmtpt->timer.function = multi_timeout;\n\t\tmp_add_one_port(drv, &mtpt->port);\n\t}\n}\n\n/**\n * pci_remap_base - remap BAR value of pci device\n *\n * PARAMETERS\n *  pcidev  - pci_dev structure address\n *  offset  - BAR offset PCI_BASE_ADDRESS_0 ~ PCI_BASE_ADDRESS_4\n *  address - address to be changed BAR value\n *  size\t- size of address space \n *\n * RETURNS\n *  If this function performs successful, it returns 0. Otherwise, It returns -1.\n */\nstatic int pci_remap_base(struct pci_dev *pcidev, unsigned int offset, \n\t\tunsigned int address, unsigned int size) \n{\n#if 0\n\tstruct resource *root;\n\tunsigned index = (offset - 0x10) >> 2;\n#endif\n\n\tpci_write_config_dword(pcidev, offset, address);\n#if 0\n\troot = pcidev->resource[index].parent;\n\trelease_resource(&pcidev->resource[index]);\n\taddress &= ~0x1;\n\tpcidev->resource[index].start = address;\n\tpcidev->resource[index].end\t  = address + size - 1;\n\n\tif (request_resource(root, &pcidev->resource[index]) != NULL)\n\t{\n\t\tprintk(KERN_ERR \"pci remap conflict!! 0x%x\\n\", address);\n\t\treturn (-1);\n\t}\n#endif\n\n\treturn (0);\n}\n\nstatic int init_mp_dev(struct pci_dev *pcidev, mppcibrd_t brd)\n{\n\tstatic struct mp_device_t *sbdev = mp_devs;\n\tunsigned long addr = 0;\n\tint j;\n\tstruct resource *ret = NULL;\n\n\tsbdev->device_id = brd.device_id;\n\tpci_read_config_byte(pcidev, PCI_CLASS_REVISION, &(sbdev->revision));\n\tsbdev->name = brd.name;\n\tsbdev->uart_access_addr = pcidev->resource[0].start & PCI_BASE_ADDRESS_IO_MASK;\n\n\t/* check revision. The SB16C1053APCI's option i/o address is BAR4 */\n\tif (sbdev->revision == 0xc0)\n\t{\n\t\t/* SB16C1053APCI */\n\t\tsbdev->option_reg_addr = pcidev->resource[4].start & PCI_BASE_ADDRESS_IO_MASK;\n\t}\n\telse\n\t{\n\t\tsbdev->option_reg_addr = pcidev->resource[1].start & PCI_BASE_ADDRESS_IO_MASK;\n\t}\n#if 1\t\n\tif (sbdev->revision == 0xc0)\n\t{\n\t\toutb(0x00, sbdev->option_reg_addr + MP_OPTR_GPOCR);\n\t\tinb(sbdev->option_reg_addr + MP_OPTR_GPOCR);\n\t\toutb(0x83, sbdev->option_reg_addr + MP_OPTR_GPOCR);\n\t}\n#endif\n\n\tsbdev->irq = pcidev->irq;\n\n\tif ((brd.device_id & 0x0800) || !(brd.device_id &0xff00))\n\t{\n\t\tsbdev->poll_type = TYPE_INTERRUPT;\n\t}\n\telse\n\t{\n\t\tsbdev->poll_type = TYPE_POLL;\n\t}\n\n\t/* codes which is specific to each board*/\n\tswitch(brd.device_id){\n\t\tcase PCI_DEVICE_ID_MP1 :\n\t\tcase PCIE_DEVICE_ID_MP1 :\n\t\tcase PCIE_DEVICE_ID_MP1E :\n\t\tcase PCIE_DEVICE_ID_GT_MP1 :\n\t\t\tsbdev->nr_ports = 1;\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_MP2 :\n\t\tcase PCIE_DEVICE_ID_MP2 :\n\t\tcase PCIE_DEVICE_ID_GT_MP2 :\n\t\tcase PCIE_DEVICE_ID_MP2B :\n\t\tcase PCIE_DEVICE_ID_MP2E :\n\t\t\tsbdev->nr_ports = 2;\n\n\t\t\t/* serial base address remap */\n\t\t\tif (sbdev->revision == 0xc0)\n\t\t\t{\n\t\t\t\tint prev_port_addr = 0;\n\n\t\t\t\tpci_read_config_dword(pcidev, PCI_BASE_ADDRESS_0, &prev_port_addr);\n\t\t\t\tpci_remap_base(pcidev, PCI_BASE_ADDRESS_1, prev_port_addr + 8, 8);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_MP4 :\n\t\tcase PCI_DEVICE_ID_MP4A :\n\t\tcase PCIE_DEVICE_ID_MP4 :\n\t\tcase PCI_DEVICE_ID_GT_MP4 :\n\t\tcase PCI_DEVICE_ID_GT_MP4A :\n\t\tcase PCIE_DEVICE_ID_GT_MP4 :\n\t\tcase PCI_DEVICE_ID_MP4M :\n\t\tcase PCIE_DEVICE_ID_MP4B :\n\t\t\tsbdev->nr_ports = 4;\n\n\t\t\tif(sbdev->revision == 0x91){\n\t\t\t\tsbdev->reserved_addr[0] = pcidev->resource[0].start & PCI_BASE_ADDRESS_IO_MASK;\n\t\t\t\toutb(0x03 , sbdev->reserved_addr[0] + 0x01);\n\t\t\t\toutb(0x03 , sbdev->reserved_addr[0] + 0x02);\n\t\t\t\toutb(0x01 , sbdev->reserved_addr[0] + 0x20);\n\t\t\t\toutb(0x00 , sbdev->reserved_addr[0] + 0x21);\n\t\t\t\trequest_region(sbdev->reserved_addr[0], 32, sbdev->name);\n\t\t\t\tsbdev->uart_access_addr = pcidev->resource[1].start & PCI_BASE_ADDRESS_IO_MASK;\n\t\t\t\tsbdev->option_reg_addr = pcidev->resource[2].start & PCI_BASE_ADDRESS_IO_MASK;\n\t\t\t}\n\n\t\t\t/* SB16C1053APCI */\n\t\t\tif (sbdev->revision == 0xc0)\n\t\t\t{\n\t\t\t\tint prev_port_addr = 0;\n\n\t\t\t\tpci_read_config_dword(pcidev, PCI_BASE_ADDRESS_0, &prev_port_addr);\n\t\t\t\tpci_remap_base(pcidev, PCI_BASE_ADDRESS_1, prev_port_addr + 8, 8);\n\t\t\t\tpci_remap_base(pcidev, PCI_BASE_ADDRESS_2, prev_port_addr + 16, 8);\n\t\t\t\tpci_remap_base(pcidev, PCI_BASE_ADDRESS_3, prev_port_addr + 24, 8);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_MP6 :\n\t\tcase PCI_DEVICE_ID_MP6A :\n\t\tcase PCI_DEVICE_ID_GT_MP6 :\n\t\tcase PCI_DEVICE_ID_GT_MP6A :\n\t\t\tsbdev->nr_ports = 6;\n\n\t\t\t/* SB16C1053APCI */\n\t\t\tif (sbdev->revision == 0xc0)\n\t\t\t{\n\t\t\t\tint prev_port_addr = 0;\n\n\t\t\t\tpci_read_config_dword(pcidev, PCI_BASE_ADDRESS_0, &prev_port_addr);\n\t\t\t\tpci_remap_base(pcidev, PCI_BASE_ADDRESS_1, prev_port_addr + 8, 8);\n\t\t\t\tpci_remap_base(pcidev, PCI_BASE_ADDRESS_2, prev_port_addr + 16, 16);\n\t\t\t\tpci_remap_base(pcidev, PCI_BASE_ADDRESS_3, prev_port_addr + 32, 16);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_MP8 :\n\t\tcase PCIE_DEVICE_ID_MP8 :\n\t\tcase PCI_DEVICE_ID_GT_MP8 :\n\t\tcase PCIE_DEVICE_ID_GT_MP8 :\n\t\tcase PCIE_DEVICE_ID_MP8B :\n\t\t\tsbdev->nr_ports = 8;\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_MP32 :\n\t\tcase PCIE_DEVICE_ID_MP32 :\n\t\tcase PCI_DEVICE_ID_GT_MP32 :\n\t\tcase PCIE_DEVICE_ID_GT_MP32 :\n\t\t\t{\n\t\t\t\tint portnum_hex=0;\n\t\t\t\tportnum_hex = inb(sbdev->option_reg_addr);\n\t\t\t\tsbdev->nr_ports = ((portnum_hex/16)*10) + (portnum_hex % 16);\n\t\t\t}\n\t\t\tbreak;\n#ifdef CONFIG_PARPORT_PC\n\t\tcase PCI_DEVICE_ID_MP2S1P :\n\t\t\tsbdev->nr_ports = 2;\n\n\t\t\t/* SB16C1053APCI */\n\t\t\tif (sbdev->revision == 0xc0)\n\t\t\t{\n\t\t\t\tint prev_port_addr = 0;\n\n\t\t\t\tpci_read_config_dword(pcidev, PCI_BASE_ADDRESS_0, &prev_port_addr);\n\t\t\t\tpci_remap_base(pcidev, PCI_BASE_ADDRESS_1, prev_port_addr + 8, 8);\n\t\t\t}\n\n\t\t\t/* add PC compatible parallel port */\n\t\t\tparport_pc_probe_port(pcidev->resource[2].start, pcidev->resource[3].start, PARPORT_IRQ_NONE, PARPORT_DMA_NONE, &pcidev->dev, 0);\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_MP1P :\n\t\t\t/* add PC compatible parallel port */\n\t\t\tparport_pc_probe_port(pcidev->resource[2].start, pcidev->resource[3].start, PARPORT_IRQ_NONE, PARPORT_DMA_NONE, &pcidev->dev, 0);\n\t\t\tbreak;\n#endif\n\t}\n\n\tret = request_region(sbdev->uart_access_addr, (8*sbdev->nr_ports), sbdev->name);\n\n\tif (sbdev->revision == 0xc0)\n\t{\n\t\tret = request_region(sbdev->option_reg_addr, 0x40, sbdev->name);\n\t}\n\telse\n\t{\n\t\tret = request_region(sbdev->option_reg_addr, 0x20, sbdev->name);\n\t}\n\n\n\tNR_BOARD++;\n\tNR_PORTS += sbdev->nr_ports;\n\n\t/* Enable PCI interrupt */\n\taddr = sbdev->option_reg_addr + MP_OPTR_IMR0;\n\tfor(j=0; j < (sbdev->nr_ports/8)+1; j++)\n\t{\n\t\tif (sbdev->poll_type == TYPE_INTERRUPT)\n\t\t{\n\t\t\toutb(0xff,addr +j);\n\t\t}\n\t}\n\tsbdev++;\n\n\treturn 0;\n}\n\nstatic int __init multi_init(void)\n{\n\tint ret, i;\n\tstruct pci_dev  *dev = NULL;\n\n\tif(fcr_count==0)\n\t{\n\t\tfor(i=0;i<256;i++)\n\t\t{\n\t\t\tfcr_arr[i] = 0x01;\n\t\t\t\n\t\t}\n\t}\n\tif(deep_count==0)\n\t{\n\t\tfor(i=0;i<256;i++)\n\t\t{\n\t\t\tdeep[i] = 1;\n\t\t\t\n\t\t}\n\t}\n\tif(rtr_count==0)\n        {\n                for(i=0;i<256;i++)\n                {\n                        rtr[i] = 0x10;\n                }\n        }\n\tif(ttr_count==0)\n        {\n                for(i=0;i<256;i++)\n                {\n                        ttr[i] = 0x38;\n                }\n        }\n\n\nprintk(\"MULTI INIT\\n\");\n\tfor( i=0; i< mp_nrpcibrds; i++)\n\t{\n\n\t\twhile( (dev = pci_get_device(mp_pciboards[i].vendor_id, mp_pciboards[i].device_id, dev) ) )\n\n\t\t{\nprintk(\"FOUND~~~\\n\");\n//\tCent OS bug fix\n//\t\t\tif (mp_pciboards[i].device_id & 0x0800)\n\t\t\t{\n\t\t\t\tint status;\n\t        \t\tpci_disable_device(dev);\n\t        \t\tstatus = pci_enable_device(dev);\n            \n\t   \t\t     \tif (status != 0)\n        \t\t\t{ \n               \t\t\t\tprintk(\"Multiport Board Enable Fail !\\n\\n\");\n               \t\t\t\tstatus = -ENXIO;\n                \t\t\treturn status;\n           \t\t\t}\n\t\t\t}\n\n\t\t\tinit_mp_dev(dev, mp_pciboards[i]);\t\n\t\t}\n\t}\n\n\tfor (i = 0; i < NR_IRQS; i++)\n\t\tspin_lock_init(&irq_lists[i].lock);\n\n\tret = mp_register_driver(&multi_reg);\n\n\tif (ret >= 0)\n\t\tmulti_register_ports(&multi_reg);\n\n\treturn ret;\n}\n\nstatic void __exit multi_exit(void)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_PORTS; i++)\n\t\tmp_remove_one_port(&multi_reg, &multi_ports[i].port);\n\n\tmp_unregister_driver(&multi_reg);\n}\n\nmodule_init(multi_init);\nmodule_exit(multi_exit);\n\nMODULE_DESCRIPTION(\"SystemBase Multiport PCI/PCIe CORE\");\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["#include \"sb_pci_mp.h\"\n#include <linux/module.h>\n#include <linux/parport.h>\n\nextern struct parport *parport_pc_probe_port(unsigned long base_lo,\n\t\tunsigned long base_hi,\n\t\tint irq, int dma,\n\t\tstruct device *dev,\n\t\tint irqflags);\n\nstatic struct mp_device_t mp_devs[MAX_MP_DEV];\nstatic int mp_nrpcibrds = sizeof(mp_pciboards)/sizeof(mppcibrd_t);\nstatic int NR_BOARD=0;\nstatic int NR_PORTS=0;\nstatic struct mp_port multi_ports[MAX_MP_PORT];\nstatic struct irq_info irq_lists[NR_IRQS];\n\nstatic _INLINE_ unsigned int serial_in(struct mp_port *mtpt, int offset);\nstatic _INLINE_ void serial_out(struct mp_port *mtpt, int offset, int value);\nstatic _INLINE_ unsigned int read_option_register(struct mp_port *mtpt, int offset);\nstatic int sb1054_get_register(struct sb_uart_port *port, int page, int reg);\nstatic int sb1054_set_register(struct sb_uart_port *port, int page, int reg, int value);\nstatic void SendATCommand(struct mp_port *mtpt);\nstatic int set_deep_fifo(struct sb_uart_port *port, int status);\nstatic int get_deep_fifo(struct sb_uart_port *port);\nstatic int get_device_type(int arg);\nstatic int set_auto_rts(struct sb_uart_port *port, int status);\nstatic void mp_stop(struct tty_struct *tty);\nstatic void __mp_start(struct tty_struct *tty);\nstatic void mp_start(struct tty_struct *tty);\nstatic void mp_tasklet_action(unsigned long data);\nstatic inline void mp_update_mctrl(struct sb_uart_port *port, unsigned int set, unsigned int clear);\nstatic int mp_startup(struct sb_uart_state *state, int init_hw);\nstatic void mp_shutdown(struct sb_uart_state *state);\nstatic void mp_change_speed(struct sb_uart_state *state, struct MP_TERMIOS *old_termios);\n\nstatic inline int __mp_put_char(struct sb_uart_port *port, struct circ_buf *circ, unsigned char c);\nstatic int mp_put_char(struct tty_struct *tty, unsigned char ch);\n\nstatic void mp_put_chars(struct tty_struct *tty);\nstatic int mp_write(struct tty_struct *tty, const unsigned char *buf, int count);\nstatic int mp_write_room(struct tty_struct *tty);\nstatic int mp_chars_in_buffer(struct tty_struct *tty);\nstatic void mp_flush_buffer(struct tty_struct *tty);\nstatic void mp_send_xchar(struct tty_struct *tty, char ch);\nstatic void mp_throttle(struct tty_struct *tty);\nstatic void mp_unthrottle(struct tty_struct *tty);\nstatic int mp_get_info(struct sb_uart_state *state, struct serial_struct *retinfo);\nstatic int mp_set_info(struct sb_uart_state *state, struct serial_struct *newinfo);\nstatic int mp_get_lsr_info(struct sb_uart_state *state, unsigned int *value);\n\nstatic int mp_tiocmget(struct tty_struct *tty);\nstatic int mp_tiocmset(struct tty_struct *tty, unsigned int set, unsigned int clear);\nstatic int mp_break_ctl(struct tty_struct *tty, int break_state);\nstatic int mp_do_autoconfig(struct sb_uart_state *state);\nstatic int mp_wait_modem_status(struct sb_uart_state *state, unsigned long arg);\nstatic int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt);\nstatic int mp_ioctl(struct tty_struct *tty, unsigned int cmd, unsigned long arg);\nstatic void mp_set_termios(struct tty_struct *tty, struct MP_TERMIOS *old_termios);\nstatic void mp_close(struct tty_struct *tty, struct file *filp);\nstatic void mp_wait_until_sent(struct tty_struct *tty, int timeout);\nstatic void mp_hangup(struct tty_struct *tty);\nstatic void mp_update_termios(struct sb_uart_state *state);\nstatic int mp_block_til_ready(struct file *filp, struct sb_uart_state *state);\nstatic struct sb_uart_state *uart_get(struct uart_driver *drv, int line);\nstatic int mp_open(struct tty_struct *tty, struct file *filp);\nstatic const char *mp_type(struct sb_uart_port *port);\nstatic void mp_change_pm(struct sb_uart_state *state, int pm_state);\nstatic inline void mp_report_port(struct uart_driver *drv, struct sb_uart_port *port);\nstatic void mp_configure_port(struct uart_driver *drv, struct sb_uart_state *state, struct sb_uart_port *port);\nstatic void mp_unconfigure_port(struct uart_driver *drv, struct sb_uart_state *state);\nstatic int mp_register_driver(struct uart_driver *drv);\nstatic void mp_unregister_driver(struct uart_driver *drv);\nstatic int mp_add_one_port(struct uart_driver *drv, struct sb_uart_port *port);\nstatic int mp_remove_one_port(struct uart_driver *drv, struct sb_uart_port *port);\nstatic void autoconfig(struct mp_port *mtpt, unsigned int probeflags);\nstatic void autoconfig_irq(struct mp_port *mtpt);\nstatic void multi_stop_tx(struct sb_uart_port *port);\nstatic void multi_start_tx(struct sb_uart_port *port);\nstatic void multi_stop_rx(struct sb_uart_port *port);\nstatic void multi_enable_ms(struct sb_uart_port *port);\nstatic _INLINE_ void receive_chars(struct mp_port *mtpt, int *status );\nstatic _INLINE_ void transmit_chars(struct mp_port *mtpt);\nstatic _INLINE_ void check_modem_status(struct mp_port *mtpt);\nstatic inline void multi_handle_port(struct mp_port *mtpt);\nstatic irqreturn_t multi_interrupt(int irq, void *dev_id);\nstatic void serial_do_unlink(struct irq_info *i, struct mp_port *mtpt);\nstatic int serial_link_irq_chain(struct mp_port *mtpt);\nstatic void serial_unlink_irq_chain(struct mp_port *mtpt);\nstatic void multi_timeout(unsigned long data);\nstatic unsigned int multi_tx_empty(struct sb_uart_port *port);\nstatic unsigned int multi_get_mctrl(struct sb_uart_port *port);\nstatic void multi_set_mctrl(struct sb_uart_port *port, unsigned int mctrl);\nstatic void multi_break_ctl(struct sb_uart_port *port, int break_state);\nstatic int multi_startup(struct sb_uart_port *port);\nstatic void multi_shutdown(struct sb_uart_port *port);\nstatic unsigned int multi_get_divisor(struct sb_uart_port *port, unsigned int baud);\nstatic void multi_set_termios(struct sb_uart_port *port, struct MP_TERMIOS *termios, struct MP_TERMIOS *old);\nstatic void multi_pm(struct sb_uart_port *port, unsigned int state, unsigned int oldstate);\nstatic void multi_release_std_resource(struct mp_port *mtpt);\nstatic void multi_release_port(struct sb_uart_port *port);\nstatic int multi_request_port(struct sb_uart_port *port);\nstatic void multi_config_port(struct sb_uart_port *port, int flags);\nstatic int multi_verify_port(struct sb_uart_port *port, struct serial_struct *ser);\nstatic const char *multi_type(struct sb_uart_port *port);\nstatic void __init multi_init_ports(void);\nstatic void __init multi_register_ports(struct uart_driver *drv);\nstatic int init_mp_dev(struct pci_dev *pcidev, mppcibrd_t brd);\n\nstatic int deep[256];\nstatic int deep_count;\nstatic int fcr_arr[256];\nstatic int fcr_count;\nstatic int ttr[256];\nstatic int ttr_count;\nstatic int rtr[256];\nstatic int rtr_count;\n\nmodule_param_array(deep,int,&deep_count,0);\nmodule_param_array(fcr_arr,int,&fcr_count,0);\nmodule_param_array(ttr,int,&ttr_count,0);\nmodule_param_array(rtr,int,&rtr_count,0);\n\nstatic _INLINE_ unsigned int serial_in(struct mp_port *mtpt, int offset)\n{\n\treturn inb(mtpt->port.iobase + offset);\n}\n\nstatic _INLINE_ void serial_out(struct mp_port *mtpt, int offset, int value)\n{\n\toutb(value, mtpt->port.iobase + offset);\n}\n\nstatic _INLINE_ unsigned int read_option_register(struct mp_port *mtpt, int offset)\n{\n\treturn inb(mtpt->option_base_addr + offset);\n}\n\nstatic int sb1053a_get_interface(struct mp_port *mtpt, int port_num)\n{\n\tunsigned long option_base_addr = mtpt->option_base_addr;\n\tunsigned int  interface = 0;\n\n\tswitch (port_num)\n\t{\n\t\tcase 0:\n\t\tcase 1:\n\t\t\t/* set GPO[1:0] = 00 */\n\t\t\toutb(0x00, option_base_addr + MP_OPTR_GPODR);\n\t\t\tbreak;\n\t\tcase 2:\n\t\tcase 3:\n\t\t\t/* set GPO[1:0] = 01 */\n\t\t\toutb(0x01, option_base_addr + MP_OPTR_GPODR);\n\t\t\tbreak;\n\t\tcase 4:\n\t\tcase 5:\n\t\t\t/* set GPO[1:0] = 10 */\n\t\t\toutb(0x02, option_base_addr + MP_OPTR_GPODR);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tport_num &= 0x1;\n\n\t/* get interface */\n\tinterface = inb(option_base_addr + MP_OPTR_IIR0 + port_num);\n\n\t/* set GPO[1:0] = 11 */\n\toutb(0x03, option_base_addr + MP_OPTR_GPODR);\n\n\treturn (interface);\n}\n\t\t\nstatic int sb1054_get_register(struct sb_uart_port *port, int page, int reg)\n{\n\tint ret = 0;\n\tunsigned int lcr = 0;\n\tunsigned int mcr = 0;\n\tunsigned int tmp = 0;\n\n\tif( page <= 0)\n\t{\n\t\tprintk(\" page 0 can not use this fuction\\n\");\n\t\treturn -1;\n\t}\n\n\tswitch(page)\n\t{\n\t\tcase 1:\n\t\t\tlcr = SB105X_GET_LCR(port);\n\t\t\ttmp = lcr | SB105X_LCR_DLAB;\n\t\t\tSB105X_PUT_LCR(port, tmp);\n\n\t\t\ttmp = SB105X_GET_LCR(port);\n\n\t\t\tret = SB105X_GET_REG(port,reg);\n\t\t\tSB105X_PUT_LCR(port,lcr);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmcr = SB105X_GET_MCR(port);\n\t\t\ttmp = mcr | SB105X_MCR_P2S;\n\t\t\tSB105X_PUT_MCR(port,tmp);\n\n\t\t\tret = SB105X_GET_REG(port,reg);\n\n\t\t\tSB105X_PUT_MCR(port,mcr);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tlcr = SB105X_GET_LCR(port);\n\t\t\ttmp = lcr | SB105X_LCR_BF;\n\t\t\tSB105X_PUT_LCR(port,tmp);\n\t\t\tSB105X_PUT_REG(port,SB105X_PSR,SB105X_PSR_P3KEY);\n\n\t\t\tret = SB105X_GET_REG(port,reg);\n\n\t\t\tSB105X_PUT_LCR(port,lcr);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tlcr = SB105X_GET_LCR(port);\n\t\t\ttmp = lcr | SB105X_LCR_BF;\n\t\t\tSB105X_PUT_LCR(port,tmp);\n\t\t\tSB105X_PUT_REG(port,SB105X_PSR,SB105X_PSR_P4KEY);\n\n\t\t\tret = SB105X_GET_REG(port,reg);\n\n\t\t\tSB105X_PUT_LCR(port,lcr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(\" error invalid page number \\n\");\n\t\t\treturn -1;\n\t}\n\n\treturn ret;\n}\n\nstatic int sb1054_set_register(struct sb_uart_port *port, int page, int reg, int value)\n{  \n\tint lcr = 0;\n\tint mcr = 0;\n\tint ret = 0;\n\n\tif( page <= 0)\n\t{\n\t\tprintk(\" page 0 can not use this fuction\\n\");\n\t\treturn -1;\n\t}\n\tswitch(page)\n\t{\n\t\tcase 1:\n\t\t\tlcr = SB105X_GET_LCR(port);\n\t\t\tSB105X_PUT_LCR(port, lcr | SB105X_LCR_DLAB);\n\n\t\t\tSB105X_PUT_REG(port,reg,value);\n\n\t\t\tSB105X_PUT_LCR(port, lcr);\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmcr = SB105X_GET_MCR(port);\n\t\t\tSB105X_PUT_MCR(port, mcr | SB105X_MCR_P2S);\n\n\t\t\tSB105X_PUT_REG(port,reg,value);\n\n\t\t\tSB105X_PUT_MCR(port, mcr);\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tlcr = SB105X_GET_LCR(port);\n\t\t\tSB105X_PUT_LCR(port, lcr | SB105X_LCR_BF);\n\t\t\tSB105X_PUT_PSR(port, SB105X_PSR_P3KEY);\n\n\t\t\tSB105X_PUT_REG(port,reg,value);\n\n\t\t\tSB105X_PUT_LCR(port, lcr);\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tlcr = SB105X_GET_LCR(port);\n\t\t\tSB105X_PUT_LCR(port, lcr | SB105X_LCR_BF);\n\t\t\tSB105X_PUT_PSR(port, SB105X_PSR_P4KEY);\n\n\t\t\tSB105X_PUT_REG(port,reg,value);\n\n\t\t\tSB105X_PUT_LCR(port, lcr);\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(\" error invalid page number \\n\");\n\t\t\treturn -1;\n\t}\n\n\treturn ret;\n}\n\nstatic int set_multidrop_mode(struct sb_uart_port *port, unsigned int mode)\n{\n\tint mdr = SB105XA_MDR_NPS;\n\n\tif (mode & MDMODE_ENABLE)\n\t{\n\t\tmdr |= SB105XA_MDR_MDE;\n\t}\n\n\tif (1) //(mode & MDMODE_AUTO)\n\t{\n\t\tint efr = 0;\n\t\tmdr |= SB105XA_MDR_AME;\n\t\tefr = sb1054_get_register(port, PAGE_3, SB105X_EFR);\n\t\tefr |= SB105X_EFR_SCD;\n\t\tsb1054_set_register(port, PAGE_3, SB105X_EFR, efr);\n\t}\n\n\tsb1054_set_register(port, PAGE_1, SB105XA_MDR, mdr);\n\tport->mdmode &= ~0x6;\n\tport->mdmode |= mode;\n\tprintk(\"[%d] multidrop init: %x\\n\", port->line, port->mdmode);\n\n\treturn 0;\n}\n\nstatic int get_multidrop_addr(struct sb_uart_port *port)\n{\n\treturn sb1054_get_register(port, PAGE_3, SB105X_XOFF2);\n}\n\nstatic int set_multidrop_addr(struct sb_uart_port *port, unsigned int addr)\n{\n\tsb1054_set_register(port, PAGE_3, SB105X_XOFF2, addr);\n\n\treturn 0;\n}\n\nstatic void SendATCommand(struct mp_port *mtpt)\n{\n\t//\t\t      a    t\tcr   lf\n\tunsigned char ch[] = {0x61,0x74,0x0d,0x0a,0x0};\n\tunsigned char lineControl;\n\tunsigned char i=0;\n\tunsigned char Divisor = 0xc;\n\n\tlineControl = serial_inp(mtpt,UART_LCR);\n\tserial_outp(mtpt,UART_LCR,(lineControl | UART_LCR_DLAB));\n\tserial_outp(mtpt,UART_DLL,(Divisor & 0xff));\n\tserial_outp(mtpt,UART_DLM,(Divisor & 0xff00)>>8); //baudrate is 4800\n\n\n\tserial_outp(mtpt,UART_LCR,lineControl);\t\n\tserial_outp(mtpt,UART_LCR,0x03); // N-8-1\n\tserial_outp(mtpt,UART_FCR,7); \n\tserial_outp(mtpt,UART_MCR,0x3);\n\twhile(ch[i]){\n\t\twhile((serial_inp(mtpt,UART_LSR) & 0x60) !=0x60){\n\t\t\t;\n\t\t}\n\t\tserial_outp(mtpt,0,ch[i++]);\n\t}\n\n\n}// end of SendATCommand()\n\nstatic int set_deep_fifo(struct sb_uart_port *port, int status)\n{\n\tint afr_status = 0;\n\tafr_status = sb1054_get_register(port, PAGE_4, SB105X_AFR);\n\n\tif(status == ENABLE)\n\t{\n\t\tafr_status |= SB105X_AFR_AFEN;\n\t}\n\telse\n\t{\n\t\tafr_status &= ~SB105X_AFR_AFEN;\n\t}\n\t\t\n\tsb1054_set_register(port,PAGE_4,SB105X_AFR,afr_status);\n\tsb1054_set_register(port,PAGE_4,SB105X_TTR,ttr[port->line]); \n\tsb1054_set_register(port,PAGE_4,SB105X_RTR,rtr[port->line]); \n\tafr_status = sb1054_get_register(port, PAGE_4, SB105X_AFR);\n\t\t\n\treturn afr_status;\n}\n\nstatic int get_device_type(int arg)\n{\n\tint ret;\n        ret = inb(mp_devs[arg].option_reg_addr+MP_OPTR_DIR0);\n        ret = (ret & 0xf0) >> 4;\n        switch (ret)\n        {\n               case DIR_UART_16C550:\n                    return PORT_16C55X;\n               case DIR_UART_16C1050:\n                    return PORT_16C105X;\n               case DIR_UART_16C1050A:\n               /*\n               if (mtpt->port.line < 2)\n               {\n                    return PORT_16C105XA;\n               }\n               else\n               {\n                   if (mtpt->device->device_id & 0x50)\n                   {\n                       return PORT_16C55X;\n                   }\n                   else\n                   {\n                       return PORT_16C105X;\n                   }\n               }*/\n               return PORT_16C105XA;\n               default:\n                    return PORT_UNKNOWN;\n        }\n\n}\nstatic int get_deep_fifo(struct sb_uart_port *port)\n{\n\tint afr_status = 0;\n\tafr_status = sb1054_get_register(port, PAGE_4, SB105X_AFR);\n\treturn afr_status;\n}\n\nstatic int set_auto_rts(struct sb_uart_port *port, int status)\n{\n\tint atr_status = 0;\n\n#if 0\n\tint efr_status = 0;\n\n\tefr_status = sb1054_get_register(port, PAGE_3, SB105X_EFR);\n\tif(status == ENABLE)\n\t\tefr_status |= SB105X_EFR_ARTS;\n\telse\n\t\tefr_status &= ~SB105X_EFR_ARTS;\n\tsb1054_set_register(port,PAGE_3,SB105X_EFR,efr_status);\n\tefr_status = sb1054_get_register(port, PAGE_3, SB105X_EFR);\n#endif\n\t\t\n//ATR\n\tatr_status = sb1054_get_register(port, PAGE_3, SB105X_ATR);\n\tswitch(status)\n\t{\n\t\tcase RS422PTP:\n\t\t\tatr_status = (SB105X_ATR_TPS) | (SB105X_ATR_A80);\n\t\t\tbreak;\n\t\tcase RS422MD:\n\t\t\tatr_status = (SB105X_ATR_TPS) | (SB105X_ATR_TCMS) | (SB105X_ATR_A80);\n\t\t\tbreak;\n\t\tcase RS485NE:\n\t\t\tatr_status = (SB105X_ATR_RCMS) | (SB105X_ATR_TPS) | (SB105X_ATR_TCMS) | (SB105X_ATR_A80);\n\t\t\tbreak;\n\t\tcase RS485ECHO:\n\t\t\tatr_status = (SB105X_ATR_TPS) | (SB105X_ATR_TCMS) | (SB105X_ATR_A80);\n\t\t\tbreak;\n\t}\n\n\tsb1054_set_register(port,PAGE_3,SB105X_ATR,atr_status);\n\tatr_status = sb1054_get_register(port, PAGE_3, SB105X_ATR);\n\n\treturn atr_status;\n}\n\nstatic void mp_stop(struct tty_struct *tty)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\tstruct sb_uart_port *port = state->port;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tport->ops->stop_tx(port);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic void __mp_start(struct tty_struct *tty)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\tstruct sb_uart_port *port = state->port;\n\n\tif (!uart_circ_empty(&state->info->xmit) && state->info->xmit.buf &&\n\t\t\t!tty->stopped && !tty->hw_stopped)\n\t\tport->ops->start_tx(port);\n}\n\nstatic void mp_start(struct tty_struct *tty)\n{\n\t__mp_start(tty);\n}\n\nstatic void mp_tasklet_action(unsigned long data)\n{\n\tstruct sb_uart_state *state = (struct sb_uart_state *)data;\n\tstruct tty_struct *tty;\n\n\tprintk(\"tasklet is called!\\n\");\n\ttty = state->info->tty;\n\ttty_wakeup(tty);\n}\n\nstatic inline void mp_update_mctrl(struct sb_uart_port *port, unsigned int set, unsigned int clear)\n{\n\tunsigned int old;\n\n\told = port->mctrl;\n\tport->mctrl = (old & ~clear) | set;\n\tif (old != port->mctrl)\n\t\tport->ops->set_mctrl(port, port->mctrl);\n}\n\n#define uart_set_mctrl(port,set)\tmp_update_mctrl(port,set,0)\n#define uart_clear_mctrl(port,clear)\tmp_update_mctrl(port,0,clear)\n\nstatic int mp_startup(struct sb_uart_state *state, int init_hw)\n{\n\tstruct sb_uart_info *info = state->info;\n\tstruct sb_uart_port *port = state->port;\n\tunsigned long page;\n\tint retval = 0;\n\n\tif (info->flags & UIF_INITIALIZED)\n\t\treturn 0;\n\n\tif (info->tty)\n\t\tset_bit(TTY_IO_ERROR, &info->tty->flags);\n\n\tif (port->type == PORT_UNKNOWN)\n\t\treturn 0;\n\n\tif (!info->xmit.buf) {\n\t\tpage = get_zeroed_page(GFP_KERNEL);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\tinfo->xmit.buf = (unsigned char *) page;\n\t\t\t\n\t\tuart_circ_clear(&info->xmit);\n\t}\n\n\tretval = port->ops->startup(port);\n\tif (retval == 0) {\n\t\tif (init_hw) {\n\t\t\tmp_change_speed(state, NULL);\n\n\t\t\tif (info->tty->termios.c_cflag & CBAUD)\n\t\t\t\tuart_set_mctrl(port, TIOCM_RTS | TIOCM_DTR);\n\t\t}\n\n\t\tinfo->flags |= UIF_INITIALIZED;\n\n\n\t\tclear_bit(TTY_IO_ERROR, &info->tty->flags);\n\t}\n\n\tif (retval && capable(CAP_SYS_ADMIN))\n\t\tretval = 0;\n\n\treturn retval;\n}\n\nstatic void mp_shutdown(struct sb_uart_state *state)\n{\n\tstruct sb_uart_info *info = state->info;\n\tstruct sb_uart_port *port = state->port;\n\n\tif (info->tty)\n\t\tset_bit(TTY_IO_ERROR, &info->tty->flags);\n\n\tif (info->flags & UIF_INITIALIZED) {\n\t\tinfo->flags &= ~UIF_INITIALIZED;\n\n\t\tif (!info->tty || (info->tty->termios.c_cflag & HUPCL))\n\t\t\tuart_clear_mctrl(port, TIOCM_DTR | TIOCM_RTS);\n\n\t\twake_up_interruptible(&info->delta_msr_wait);\n\n\t\tport->ops->shutdown(port);\n\n\t\tsynchronize_irq(port->irq);\n\t}\n\ttasklet_kill(&info->tlet);\n\n\tif (info->xmit.buf) {\n\t\tfree_page((unsigned long)info->xmit.buf);\n\t\tinfo->xmit.buf = NULL;\n\t}\n}\n\nstatic void mp_change_speed(struct sb_uart_state *state, struct MP_TERMIOS *old_termios)\n{\n\tstruct tty_struct *tty = state->info->tty;\n\tstruct sb_uart_port *port = state->port;\n\n\tif (!tty || port->type == PORT_UNKNOWN)\n\t\treturn;\n\n\tif (tty->termios.c_cflag & CRTSCTS)\n\t\tstate->info->flags |= UIF_CTS_FLOW;\n\telse\n\t\tstate->info->flags &= ~UIF_CTS_FLOW;\n\n\tif (tty->termios.c_cflag & CLOCAL)\n\t\tstate->info->flags &= ~UIF_CHECK_CD;\n\telse\n\t\tstate->info->flags |= UIF_CHECK_CD;\n\n\tport->ops->set_termios(port, &tty->termios, old_termios);\n}\n\nstatic inline int __mp_put_char(struct sb_uart_port *port, struct circ_buf *circ, unsigned char c)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (!circ->buf)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tif (uart_circ_chars_free(circ) != 0) {\n\t\tcirc->buf[circ->head] = c;\n\t\tcirc->head = (circ->head + 1) & (UART_XMIT_SIZE - 1);\n\t\tret = 1;\n\t}\n\tspin_unlock_irqrestore(&port->lock, flags);\n\treturn ret;\n}\n\nstatic int mp_put_char(struct tty_struct *tty, unsigned char ch)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\n\treturn __mp_put_char(state->port, &state->info->xmit, ch);\n}\n\nstatic void mp_put_chars(struct tty_struct *tty)\n{\n\tmp_start(tty);\n}\n\nstatic int mp_write(struct tty_struct *tty, const unsigned char *buf, int count)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\tstruct sb_uart_port *port;\n\tstruct circ_buf *circ;\n\tint c, ret = 0;\n\n\tif (!state || !state->info) {\n\t\treturn -EL3HLT;\n\t}\n\n\tport = state->port;\n\tcirc = &state->info->xmit;\n\n\tif (!circ->buf)\n\t\treturn 0;\n\t\t\n\twhile (1) {\n\t\tc = CIRC_SPACE_TO_END(circ->head, circ->tail, UART_XMIT_SIZE);\n\t\tif (count < c)\n\t\t\tc = count;\n\t\tif (c <= 0)\n\t\t\tbreak;\n\tmemcpy(circ->buf + circ->head, buf, c);\n\n\t\tcirc->head = (circ->head + c) & (UART_XMIT_SIZE - 1);\n\t\tbuf += c;\n\t\tcount -= c;\n\t\tret += c;\n\t}\n\tmp_start(tty);\n\treturn ret;\n}\n\nstatic int mp_write_room(struct tty_struct *tty)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\n\treturn uart_circ_chars_free(&state->info->xmit);\n}\n\nstatic int mp_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\n\treturn uart_circ_chars_pending(&state->info->xmit);\n}\n\nstatic void mp_flush_buffer(struct tty_struct *tty)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\tstruct sb_uart_port *port;\n\tunsigned long flags;\n\n\tif (!state || !state->info) {\n\t\treturn;\n\t}\n\n\tport = state->port;\n\tspin_lock_irqsave(&port->lock, flags);\n\tuart_circ_clear(&state->info->xmit);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\twake_up_interruptible(&tty->write_wait);\n\ttty_wakeup(tty);\n}\n\nstatic void mp_send_xchar(struct tty_struct *tty, char ch)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\tstruct sb_uart_port *port = state->port;\n\tunsigned long flags;\n\n\tif (port->ops->send_xchar)\n\t\tport->ops->send_xchar(port, ch);\n\telse {\n\t\tport->x_char = ch;\n\t\tif (ch) {\n\t\t\tspin_lock_irqsave(&port->lock, flags);\n\t\t\tport->ops->start_tx(port);\n\t\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t\t}\n\t}\n}\n\nstatic void mp_throttle(struct tty_struct *tty)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\n\tif (I_IXOFF(tty))\n\t\tmp_send_xchar(tty, STOP_CHAR(tty));\n\n\tif (tty->termios.c_cflag & CRTSCTS)\n\t\tuart_clear_mctrl(state->port, TIOCM_RTS);\n}\n\nstatic void mp_unthrottle(struct tty_struct *tty)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\tstruct sb_uart_port *port = state->port;\n\n\tif (I_IXOFF(tty)) {\n\t\tif (port->x_char)\n\t\t\tport->x_char = 0;\n\t\telse\n\t\t\tmp_send_xchar(tty, START_CHAR(tty));\n\t}\n\n\tif (tty->termios.c_cflag & CRTSCTS)\n\t\tuart_set_mctrl(port, TIOCM_RTS);\n}\n\nstatic int mp_get_info(struct sb_uart_state *state, struct serial_struct *retinfo)\n{\n\tstruct sb_uart_port *port = state->port;\n\tstruct serial_struct tmp;\n\n\tmemset(&tmp, 0, sizeof(tmp));\n\ttmp.type\t    = port->type;\n\ttmp.line\t    = port->line;\n\ttmp.port\t    = port->iobase;\n\tif (HIGH_BITS_OFFSET)\n\t\ttmp.port_high = (long) port->iobase >> HIGH_BITS_OFFSET;\n\ttmp.irq\t\t    = port->irq;\n\ttmp.flags\t    = port->flags;\n\ttmp.xmit_fifo_size  = port->fifosize;\n\ttmp.baud_base\t    = port->uartclk / 16;\n\ttmp.close_delay\t    = state->close_delay;\n\ttmp.closing_wait    = state->closing_wait == USF_CLOSING_WAIT_NONE ?\n\t\tASYNC_CLOSING_WAIT_NONE :\n\t\tstate->closing_wait;\n\ttmp.custom_divisor  = port->custom_divisor;\n\ttmp.hub6\t    = port->hub6;\n\ttmp.io_type         = port->iotype;\n\ttmp.iomem_reg_shift = port->regshift;\n\ttmp.iomem_base      = (void *)port->mapbase;\n\n\tif (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int mp_set_info(struct sb_uart_state *state, struct serial_struct *newinfo)\n{\n\tstruct serial_struct new_serial;\n\tstruct sb_uart_port *port = state->port;\n\tunsigned long new_port;\n\tunsigned int change_irq, change_port, closing_wait;\n\tunsigned int old_custom_divisor;\n\tunsigned int old_flags, new_flags;\n\tint retval = 0;\n\n\tif (copy_from_user(&new_serial, newinfo, sizeof(new_serial)))\n\t\treturn -EFAULT;\n\n\tnew_port = new_serial.port;\n\tif (HIGH_BITS_OFFSET)\n\t\tnew_port += (unsigned long) new_serial.port_high << HIGH_BITS_OFFSET;\n\n\tnew_serial.irq = irq_canonicalize(new_serial.irq);\n\n\tclosing_wait = new_serial.closing_wait == ASYNC_CLOSING_WAIT_NONE ?\n\t\tUSF_CLOSING_WAIT_NONE : new_serial.closing_wait;\n\tMP_STATE_LOCK(state);\n\n\tchange_irq  = new_serial.irq != port->irq;\n\tchange_port = new_port != port->iobase ||\n\t\t(unsigned long)new_serial.iomem_base != port->mapbase ||\n\t\tnew_serial.hub6 != port->hub6 ||\n\t\tnew_serial.io_type != port->iotype ||\n\t\tnew_serial.iomem_reg_shift != port->regshift ||\n\t\tnew_serial.type != port->type;\n\told_flags = port->flags;\n\tnew_flags = new_serial.flags;\n\told_custom_divisor = port->custom_divisor;\n\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\tretval = -EPERM;\n\t\tif (change_irq || change_port ||\n\t\t\t\t(new_serial.baud_base != port->uartclk / 16) ||\n\t\t\t\t(new_serial.close_delay != state->close_delay) ||\n\t\t\t\t(closing_wait != state->closing_wait) ||\n\t\t\t\t(new_serial.xmit_fifo_size != port->fifosize) ||\n\t\t\t\t(((new_flags ^ old_flags) & ~UPF_USR_MASK) != 0))\n\t\t\tgoto exit;\n\t\tport->flags = ((port->flags & ~UPF_USR_MASK) |\n\t\t\t\t(new_flags & UPF_USR_MASK));\n\t\tport->custom_divisor = new_serial.custom_divisor;\n\t\tgoto check_and_exit;\n\t}\n\n\tif (port->ops->verify_port)\n\t\tretval = port->ops->verify_port(port, &new_serial);\n\n\tif ((new_serial.irq >= NR_IRQS) || (new_serial.irq < 0) ||\n\t\t\t(new_serial.baud_base < 9600))\n\t\tretval = -EINVAL;\n\n\tif (retval)\n\t\tgoto exit;\n\n\tif (change_port || change_irq) {\n\t\tretval = -EBUSY;\n\n\t\tif (uart_users(state) > 1)\n\t\t\tgoto exit;\n\n\t\tmp_shutdown(state);\n\t}\n\n\tif (change_port) {\n\t\tunsigned long old_iobase, old_mapbase;\n\t\tunsigned int old_type, old_iotype, old_hub6, old_shift;\n\n\t\told_iobase = port->iobase;\n\t\told_mapbase = port->mapbase;\n\t\told_type = port->type;\n\t\told_hub6 = port->hub6;\n\t\told_iotype = port->iotype;\n\t\told_shift = port->regshift;\n\n\t\tif (old_type != PORT_UNKNOWN)\n\t\t\tport->ops->release_port(port);\n\n\t\tport->iobase = new_port;\n\t\tport->type = new_serial.type;\n\t\tport->hub6 = new_serial.hub6;\n\t\tport->iotype = new_serial.io_type;\n\t\tport->regshift = new_serial.iomem_reg_shift;\n\t\tport->mapbase = (unsigned long)new_serial.iomem_base;\n\n\t\tif (port->type != PORT_UNKNOWN) {\n\t\t\tretval = port->ops->request_port(port);\n\t\t} else {\n\t\t\tretval = 0;\n\t\t}\n\n\t\tif (retval && old_type != PORT_UNKNOWN) {\n\t\t\tport->iobase = old_iobase;\n\t\t\tport->type = old_type;\n\t\t\tport->hub6 = old_hub6;\n\t\t\tport->iotype = old_iotype;\n\t\t\tport->regshift = old_shift;\n\t\t\tport->mapbase = old_mapbase;\n\t\t\tretval = port->ops->request_port(port);\n\t\t\tif (retval)\n\t\t\t\tport->type = PORT_UNKNOWN;\n\n\t\t\tretval = -EBUSY;\n\t\t}\n\t}\n\n\tport->irq              = new_serial.irq;\n\tport->uartclk          = new_serial.baud_base * 16;\n\tport->flags            = (port->flags & ~UPF_CHANGE_MASK) |\n\t\t(new_flags & UPF_CHANGE_MASK);\n\tport->custom_divisor   = new_serial.custom_divisor;\n\tstate->close_delay     = new_serial.close_delay;\n\tstate->closing_wait    = closing_wait;\n\tport->fifosize         = new_serial.xmit_fifo_size;\n\tif (state->info->tty)\n\t\tstate->info->tty->low_latency =\n\t\t\t(port->flags & UPF_LOW_LATENCY) ? 1 : 0;\n\ncheck_and_exit:\n\tretval = 0;\n\tif (port->type == PORT_UNKNOWN)\n\t\tgoto exit;\n\tif (state->info->flags & UIF_INITIALIZED) {\n\t\tif (((old_flags ^ port->flags) & UPF_SPD_MASK) ||\n\t\t\t\told_custom_divisor != port->custom_divisor) {\n\t\t\tif (port->flags & UPF_SPD_MASK) {\n\t\t\t\tprintk(KERN_NOTICE\n\t\t\t\t\t\t\"%s sets custom speed on ttyMP%d. This \"\n\t\t\t\t\t\t\"is deprecated.\\n\", current->comm,\n\t\t\t\t\t\tport->line);\n\t\t\t}\n\t\t\tmp_change_speed(state, NULL);\n\t\t}\n\t} else\n\t\tretval = mp_startup(state, 1);\nexit:\n\tMP_STATE_UNLOCK(state);\n\treturn retval;\n}\n\n\nstatic int mp_get_lsr_info(struct sb_uart_state *state, unsigned int *value)\n{\n\tstruct sb_uart_port *port = state->port;\n\tunsigned int result;\n\n\tresult = port->ops->tx_empty(port);\n\n\tif (port->x_char ||\n\t\t\t((uart_circ_chars_pending(&state->info->xmit) > 0) &&\n\t\t\t\t!state->info->tty->stopped && !state->info->tty->hw_stopped))\n\t\tresult &= ~TIOCSER_TEMT;\n\n\treturn put_user(result, value);\n}\n\nstatic int mp_tiocmget(struct tty_struct *tty)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\tstruct sb_uart_port *port = state->port;\n\tint result = -EIO;\n\n\tMP_STATE_LOCK(state);\n\tif (!(tty->flags & (1 << TTY_IO_ERROR))) {\n\t\tresult = port->mctrl;\n\t\tspin_lock_irq(&port->lock);\n\t\tresult |= port->ops->get_mctrl(port);\n\t\tspin_unlock_irq(&port->lock);\n\t}\n\tMP_STATE_UNLOCK(state);\n\treturn result;\n}\n\nstatic int mp_tiocmset(struct tty_struct *tty, unsigned int set, unsigned int clear)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\tstruct sb_uart_port *port = state->port;\n\tint ret = -EIO;\n\n\n\tMP_STATE_LOCK(state);\n\tif (!(tty->flags & (1 << TTY_IO_ERROR))) {\n\t\tmp_update_mctrl(port, set, clear);\n\t\tret = 0;\n\t}\n\tMP_STATE_UNLOCK(state);\n\n\treturn ret;\n}\n\nstatic int mp_break_ctl(struct tty_struct *tty, int break_state)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\tstruct sb_uart_port *port = state->port;\n\n\tMP_STATE_LOCK(state);\n\n\tif (port->type != PORT_UNKNOWN)\n\t\tport->ops->break_ctl(port, break_state);\n\n\tMP_STATE_UNLOCK(state);\n\treturn 0;\n}\n\nstatic int mp_do_autoconfig(struct sb_uart_state *state)\n{\n\tstruct sb_uart_port *port = state->port;\n\tint flags, ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (mutex_lock_interruptible(&state->mutex))\n\t\treturn -ERESTARTSYS;\n\tret = -EBUSY;\n\tif (uart_users(state) == 1) {\n\t\tmp_shutdown(state);\n\n\t\tif (port->type != PORT_UNKNOWN)\n\t\t\tport->ops->release_port(port);\n\n\t\tflags = UART_CONFIG_TYPE;\n\t\tif (port->flags & UPF_AUTO_IRQ)\n\t\t\tflags |= UART_CONFIG_IRQ;\n\n\t\tport->ops->config_port(port, flags);\n\n\t\tret = mp_startup(state, 1);\n\t}\n\tMP_STATE_UNLOCK(state);\n\treturn ret;\n}\n\nstatic int mp_wait_modem_status(struct sb_uart_state *state, unsigned long arg)\n{\n\tstruct sb_uart_port *port = state->port;\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct sb_uart_icount cprev, cnow;\n\tint ret;\n\n\tspin_lock_irq(&port->lock);\n\tmemcpy(&cprev, &port->icount, sizeof(struct sb_uart_icount));\n\n\tport->ops->enable_ms(port);\n\tspin_unlock_irq(&port->lock);\n\n\tadd_wait_queue(&state->info->delta_msr_wait, &wait);\n\tfor (;;) {\n\t\tspin_lock_irq(&port->lock);\n\t\tmemcpy(&cnow, &port->icount, sizeof(struct sb_uart_icount));\n\t\tspin_unlock_irq(&port->lock);\n\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tif (((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) ||\n\t\t\t\t((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) ||\n\t\t\t\t((arg & TIOCM_CD)  && (cnow.dcd != cprev.dcd)) ||\n\t\t\t\t((arg & TIOCM_CTS) && (cnow.cts != cprev.cts))) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tschedule();\n\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tcprev = cnow;\n\t}\n\n\tcurrent->state = TASK_RUNNING;\n\tremove_wait_queue(&state->info->delta_msr_wait, &wait);\n\n\treturn ret;\n}\n\nstatic int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt)\n{\n\tstruct serial_icounter_struct icount = {};\n\tstruct sb_uart_icount cnow;\n\tstruct sb_uart_port *port = state->port;\n\n\tspin_lock_irq(&port->lock);\n\tmemcpy(&cnow, &port->icount, sizeof(struct sb_uart_icount));\n\tspin_unlock_irq(&port->lock);\n\n\ticount.cts         = cnow.cts;\n\ticount.dsr         = cnow.dsr;\n\ticount.rng         = cnow.rng;\n\ticount.dcd         = cnow.dcd;\n\ticount.rx          = cnow.rx;\n\ticount.tx          = cnow.tx;\n\ticount.frame       = cnow.frame;\n\ticount.overrun     = cnow.overrun;\n\ticount.parity      = cnow.parity;\n\ticount.brk         = cnow.brk;\n\ticount.buf_overrun = cnow.buf_overrun;\n\n\treturn copy_to_user(icnt, &icount, sizeof(icount)) ? -EFAULT : 0;\n}\n\nstatic int mp_ioctl(struct tty_struct *tty, unsigned int cmd, unsigned long arg)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\tstruct mp_port *info = (struct mp_port *)state->port;\n\tint ret = -ENOIOCTLCMD;\n\n\n\tswitch (cmd) {\n\t\tcase TIOCSMULTIDROP:\n\t\t\t/* set multi-drop mode enable or disable, and default operation mode is H/W mode */\n\t\t\tif (info->port.type == PORT_16C105XA)\n\t\t\t{\n\t\t\t\t//arg &= ~0x6;\n\t\t\t\t//state->port->mdmode = 0;\n\t\t\t\treturn set_multidrop_mode((struct sb_uart_port *)info, (unsigned int)arg);\n\t\t\t}\n\t\t\tret = -ENOTSUPP;\n\t\t\tbreak;\n\t\tcase GETDEEPFIFO:\n\t\t\tret = get_deep_fifo(state->port);\n\t\t\treturn ret;\n\t\tcase SETDEEPFIFO:\n\t\t\tret = set_deep_fifo(state->port,arg);\n\t\t\tdeep[state->port->line] = arg;\n\t\t\treturn ret;\n\t\tcase SETTTR:\n\t\t\tif (info->port.type == PORT_16C105X || info->port.type == PORT_16C105XA){\n\t\t\t\tret = sb1054_set_register(state->port,PAGE_4,SB105X_TTR,arg);\n\t\t\t\tttr[state->port->line] = arg;\n\t\t\t}\n\t\t\treturn ret;\n\t\tcase SETRTR:\n\t\t\tif (info->port.type == PORT_16C105X || info->port.type == PORT_16C105XA){\n\t\t\t\tret = sb1054_set_register(state->port,PAGE_4,SB105X_RTR,arg);\n\t\t\t\trtr[state->port->line] = arg;\n\t\t\t}\n\t\t\treturn ret;\n\t\tcase GETTTR:\n\t\t\tif (info->port.type == PORT_16C105X || info->port.type == PORT_16C105XA){\n\t\t\t\tret = sb1054_get_register(state->port,PAGE_4,SB105X_TTR);\n\t\t\t}\n\t\t\treturn ret;\n\t\tcase GETRTR:\n\t\t\tif (info->port.type == PORT_16C105X || info->port.type == PORT_16C105XA){\n\t\t\t\tret = sb1054_get_register(state->port,PAGE_4,SB105X_RTR);\n\t\t\t}\n\t\t\treturn ret;\n\n\t\tcase SETFCR:\n\t\t\tif (info->port.type == PORT_16C105X || info->port.type == PORT_16C105XA){\n\t\t\t\tret = sb1054_set_register(state->port,PAGE_1,SB105X_FCR,arg);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tserial_out(info,2,arg);\n\t\t\t}\n\n\t\t\treturn ret;\n\t\tcase TIOCSMDADDR:\n\t\t\t/* set multi-drop address */\n\t\t\tif (info->port.type == PORT_16C105XA)\n\t\t\t{\n\t\t\t\tstate->port->mdmode |= MDMODE_ADDR;\n\t\t\t\treturn set_multidrop_addr((struct sb_uart_port *)info, (unsigned int)arg);\n\t\t\t}\n\t\t\tret = -ENOTSUPP;\n\t\t\tbreak;\n\n\t\tcase TIOCGMDADDR:\n\t\t\t/* set multi-drop address */\n\t\t\tif ((info->port.type == PORT_16C105XA) && (state->port->mdmode & MDMODE_ADDR))\n\t\t\t{\n\t\t\t\treturn get_multidrop_addr((struct sb_uart_port *)info);\n\t\t\t}\n\t\t\tret = -ENOTSUPP;\n\t\t\tbreak;\n\n\t\tcase TIOCSENDADDR:\n\t\t\t/* send address in multi-drop mode */\n\t\t\tif ((info->port.type == PORT_16C105XA) \n\t\t\t\t\t&& (state->port->mdmode & (MDMODE_ENABLE)))\n\t\t\t{\n\t\t\t\tif (mp_chars_in_buffer(tty) > 0)\n\t\t\t\t{\n\t\t\t\t\ttty_wait_until_sent(tty, 0);\n\t\t\t\t}\n\t\t\t\t//while ((serial_in(info, UART_LSR) & 0x60) != 0x60);\n\t\t\t\t//while (sb1054_get_register(state->port, PAGE_2, SB105X_TFCR) != 0);\n\t\t\t\twhile ((serial_in(info, UART_LSR) & 0x60) != 0x60);\n\t\t\t\tserial_out(info, UART_SCR, (int)arg);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TIOCGSERIAL:\n\t\t\tret = mp_get_info(state, (struct serial_struct *)arg);\n\t\t\tbreak;\n\n\t\tcase TIOCSSERIAL:\n\t\t\tret = mp_set_info(state, (struct serial_struct *)arg);\n\t\t\tbreak;\n\n\t\tcase TIOCSERCONFIG:\n\t\t\tret = mp_do_autoconfig(state);\n\t\t\tbreak;\n\n\t\tcase TIOCSERGWILD: /* obsolete */\n\t\tcase TIOCSERSWILD: /* obsolete */\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t\t/* for Multiport */\n\t\tcase TIOCGNUMOFPORT: /* Get number of ports */\n\t\t\treturn NR_PORTS;\n\t\tcase TIOCGGETDEVID:\n\t\t\treturn mp_devs[arg].device_id;\n\t\tcase TIOCGGETREV:\n\t\t\treturn mp_devs[arg].revision;\n\t\tcase TIOCGGETNRPORTS:\n\t\t\treturn mp_devs[arg].nr_ports;\n\t\tcase TIOCGGETBDNO:\n\t\t\treturn NR_BOARD;\n\t\tcase TIOCGGETINTERFACE:\n\t\t\tif (mp_devs[arg].revision == 0xc0)\n\t\t\t{\n\t\t\t\t/* for SB16C1053APCI */\n\t\t\t\treturn (sb1053a_get_interface(info, info->port.line));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn (inb(mp_devs[arg].option_reg_addr+MP_OPTR_IIR0+(state->port->line/8)));\n\t\t\t}\n\t\tcase TIOCGGETPORTTYPE:\n\t\t\tret = get_device_type(arg);;\n\t\t\treturn ret;\n\t\tcase TIOCSMULTIECHO: /* set to multi-drop mode(RS422) or echo mode(RS485)*/\n\t\t\toutb( ( inb(info->interface_config_addr) & ~0x03 ) | 0x01 ,  \n\t\t\t\t\tinfo->interface_config_addr);\n\t\t\treturn 0;\n\t\tcase TIOCSPTPNOECHO: /* set to multi-drop mode(RS422) or echo mode(RS485) */\n\t\t\toutb( ( inb(info->interface_config_addr) & ~0x03 )  ,             \n\t\t\t\t\tinfo->interface_config_addr);\n\t\t\treturn 0;\n\t}\n\n\tif (ret != -ENOIOCTLCMD)\n\t\tgoto out;\n\n\tif (tty->flags & (1 << TTY_IO_ERROR)) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tswitch (cmd) {\n\t\tcase TIOCMIWAIT:\n\t\t\tret = mp_wait_modem_status(state, arg);\n\t\t\tbreak;\n\n\t\tcase TIOCGICOUNT:\n\t\t\tret = mp_get_count(state, (struct serial_icounter_struct *)arg);\n\t\t\tbreak;\n\t}\n\n\tif (ret != -ENOIOCTLCMD)\n\t\tgoto out;\n\n\tMP_STATE_LOCK(state);\n\tswitch (cmd) {\n\t\tcase TIOCSERGETLSR: /* Get line status register */\n\t\t\tret = mp_get_lsr_info(state, (unsigned int *)arg);\n\t\t\tbreak;\n\n\t\tdefault: {\n\t\t\t\t\tstruct sb_uart_port *port = state->port;\n\t\t\t\t\tif (port->ops->ioctl)\n\t\t\t\t\t\tret = port->ops->ioctl(port, cmd, arg);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t}\n\n\tMP_STATE_UNLOCK(state);\nout:\n\treturn ret;\n}\n\nstatic void mp_set_termios(struct tty_struct *tty, struct MP_TERMIOS *old_termios)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\tunsigned long flags;\n\tunsigned int cflag = tty->termios.c_cflag;\n\n#define RELEVANT_IFLAG(iflag)\t((iflag) & (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))\n\n\tif ((cflag ^ old_termios->c_cflag) == 0 &&\n\t\t\tRELEVANT_IFLAG(tty->termios.c_iflag ^ old_termios->c_iflag) == 0)\n\t\treturn;\n\n\tmp_change_speed(state, old_termios);\n\n\tif ((old_termios->c_cflag & CBAUD) && !(cflag & CBAUD))\n\t\tuart_clear_mctrl(state->port, TIOCM_RTS | TIOCM_DTR);\n\n\tif (!(old_termios->c_cflag & CBAUD) && (cflag & CBAUD)) {\n\t\tunsigned int mask = TIOCM_DTR;\n\t\tif (!(cflag & CRTSCTS) ||\n\t\t\t\t!test_bit(TTY_THROTTLED, &tty->flags))\n\t\t\tmask |= TIOCM_RTS;\n\t\tuart_set_mctrl(state->port, mask);\n\t}\n\n\tif ((old_termios->c_cflag & CRTSCTS) && !(cflag & CRTSCTS)) {\n\t\tspin_lock_irqsave(&state->port->lock, flags);\n\t\ttty->hw_stopped = 0;\n\t\t__mp_start(tty);\n\t\tspin_unlock_irqrestore(&state->port->lock, flags);\n\t}\n\n\tif (!(old_termios->c_cflag & CRTSCTS) && (cflag & CRTSCTS)) {\n\t\tspin_lock_irqsave(&state->port->lock, flags);\n\t\tif (!(state->port->ops->get_mctrl(state->port) & TIOCM_CTS)) {\n\t\t\ttty->hw_stopped = 1;\n\t\t\tstate->port->ops->stop_tx(state->port);\n\t\t}\n\t\tspin_unlock_irqrestore(&state->port->lock, flags);\n\t}\n}\n\nstatic void mp_close(struct tty_struct *tty, struct file *filp)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\tstruct sb_uart_port *port;\n\n\tprintk(\"mp_close!\\n\");\n\tif (!state || !state->port)\n\t\treturn;\n\n\tport = state->port;\n\n\tprintk(\"close1 %d\\n\", __LINE__);\n\tMP_STATE_LOCK(state);\n\n\tprintk(\"close2 %d\\n\", __LINE__);\n\tif (tty_hung_up_p(filp))\n\t\tgoto done;\n\n\tprintk(\"close3 %d\\n\", __LINE__);\n\tif ((tty->count == 1) && (state->count != 1)) {\n\t\tprintk(\"mp_close: bad serial port count; tty->count is 1, \"\n\t\t\t\t\"state->count is %d\\n\", state->count);\n\t\tstate->count = 1;\n\t}\n\tprintk(\"close4 %d\\n\", __LINE__);\n\tif (--state->count < 0) {\n\t\tprintk(\"rs_close: bad serial port count for ttyMP%d: %d\\n\",\n\t\t\t\tport->line, state->count);\n\t\tstate->count = 0;\n\t}\n\tif (state->count)\n\t\tgoto done;\n\n\ttty->closing = 1;\n\n\tprintk(\"close5 %d\\n\", __LINE__);\n\tif (state->closing_wait != USF_CLOSING_WAIT_NONE)\n\t\ttty_wait_until_sent(tty, state->closing_wait);\n\n\tprintk(\"close6 %d\\n\", __LINE__);\n\tif (state->info->flags & UIF_INITIALIZED) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&port->lock, flags);\n\t\tport->ops->stop_rx(port);\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t\tmp_wait_until_sent(tty, port->timeout);\n\t}\n\tprintk(\"close7 %d\\n\", __LINE__);\n\n\tmp_shutdown(state);\n\tprintk(\"close8 %d\\n\", __LINE__);\n\tmp_flush_buffer(tty);\n\ttty_ldisc_flush(tty);\n\ttty->closing = 0;\n\tstate->info->tty = NULL;\n\tif (state->info->blocked_open) \n\t{\n\t\tif (state->close_delay)\n\t\t{\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tschedule_timeout(state->close_delay);\n\t\t}\n\t}\n\telse\n\t{\n\t\tmp_change_pm(state, 3);\n\t}\n\tprintk(\"close8 %d\\n\", __LINE__);\n\n\tstate->info->flags &= ~UIF_NORMAL_ACTIVE;\n\twake_up_interruptible(&state->info->open_wait);\n\ndone:\n\tprintk(\"close done\\n\");\n\tMP_STATE_UNLOCK(state);\n\tmodule_put(THIS_MODULE);\n}\n\nstatic void mp_wait_until_sent(struct tty_struct *tty, int timeout)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\tstruct sb_uart_port *port = state->port;\n\tunsigned long char_time, expire;\n\n\tif (port->type == PORT_UNKNOWN || port->fifosize == 0)\n\t\treturn;\n\n\tchar_time = (port->timeout - HZ/50) / port->fifosize;\n\tchar_time = char_time / 5;\n\tif (char_time == 0)\n\t\tchar_time = 1;\n\tif (timeout && timeout < char_time)\n\t\tchar_time = timeout;\n\n\tif (timeout == 0 || timeout > 2 * port->timeout)\n\t\ttimeout = 2 * port->timeout;\n\n\texpire = jiffies + timeout;\n\n\twhile (!port->ops->tx_empty(port)) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule_timeout(char_time);\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tif (time_after(jiffies, expire))\n\t\t\tbreak;\n\t}\n\tset_current_state(TASK_RUNNING); /* might not be needed */\n}\n\nstatic void mp_hangup(struct tty_struct *tty)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\n\tMP_STATE_LOCK(state);\n\tif (state->info && state->info->flags & UIF_NORMAL_ACTIVE) {\n\t\tmp_flush_buffer(tty);\n\t\tmp_shutdown(state);\n\t\tstate->count = 0;\n\t\tstate->info->flags &= ~UIF_NORMAL_ACTIVE;\n\t\tstate->info->tty = NULL;\n\t\twake_up_interruptible(&state->info->open_wait);\n\t\twake_up_interruptible(&state->info->delta_msr_wait);\n\t}\n\tMP_STATE_UNLOCK(state);\n}\n\nstatic void mp_update_termios(struct sb_uart_state *state)\n{\n\tstruct tty_struct *tty = state->info->tty;\n\tstruct sb_uart_port *port = state->port;\n\n\tif (!(tty->flags & (1 << TTY_IO_ERROR))) {\n\t\tmp_change_speed(state, NULL);\n\n\t\tif (tty->termios.c_cflag & CBAUD)\n\t\t\tuart_set_mctrl(port, TIOCM_DTR | TIOCM_RTS);\n\t}\n}\n\nstatic int mp_block_til_ready(struct file *filp, struct sb_uart_state *state)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct sb_uart_info *info = state->info;\n\tstruct sb_uart_port *port = state->port;\n\tunsigned int mctrl;\n\n\tinfo->blocked_open++;\n\tstate->count--;\n\n\tadd_wait_queue(&info->open_wait, &wait);\n\twhile (1) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tif (tty_hung_up_p(filp) || info->tty == NULL)\n\t\t\tbreak;\n\n\t\tif (!(info->flags & UIF_INITIALIZED))\n\t\t\tbreak;\n\n\t\tif ((filp->f_flags & O_NONBLOCK) ||\n\t\t\t\t(info->tty->termios.c_cflag & CLOCAL) ||\n\t\t\t\t(info->tty->flags & (1 << TTY_IO_ERROR))) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (info->tty->termios.c_cflag & CBAUD)\n\t\t\tuart_set_mctrl(port, TIOCM_DTR);\n\n\t\tspin_lock_irq(&port->lock);\n\t\tport->ops->enable_ms(port);\n\t\tmctrl = port->ops->get_mctrl(port);\n\t\tspin_unlock_irq(&port->lock);\n\t\tif (mctrl & TIOCM_CAR)\n\t\t\tbreak;\n\n\t\tMP_STATE_UNLOCK(state);\n\t\tschedule();\n\t\tMP_STATE_LOCK(state);\n\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&info->open_wait, &wait);\n\n\tstate->count++;\n\tinfo->blocked_open--;\n\n\tif (signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\n\tif (!info->tty || tty_hung_up_p(filp))\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nstatic struct sb_uart_state *uart_get(struct uart_driver *drv, int line)\n{\n\tstruct sb_uart_state *state;\n\n\tMP_MUTEX_LOCK(mp_mutex);\n\tstate = drv->state + line;\n\tif (mutex_lock_interruptible(&state->mutex)) {\n\t\tstate = ERR_PTR(-ERESTARTSYS);\n\t\tgoto out;\n\t}\n\tstate->count++;\n\tif (!state->port) {\n\t\tstate->count--;\n\t\tMP_STATE_UNLOCK(state);\n\t\tstate = ERR_PTR(-ENXIO);\n\t\tgoto out;\n\t}\n\n\tif (!state->info) {\n\t\tstate->info = kmalloc(sizeof(struct sb_uart_info), GFP_KERNEL);\n\t\tif (state->info) {\n\t\t\tmemset(state->info, 0, sizeof(struct sb_uart_info));\n\t\t\tinit_waitqueue_head(&state->info->open_wait);\n\t\t\tinit_waitqueue_head(&state->info->delta_msr_wait);\n\n\t\t\tstate->port->info = state->info;\n\n\t\t\ttasklet_init(&state->info->tlet, mp_tasklet_action,\n\t\t\t\t\t(unsigned long)state);\n\t\t} else {\n\t\t\tstate->count--;\n\t\t\tMP_STATE_UNLOCK(state);\n\t\t\tstate = ERR_PTR(-ENOMEM);\n\t\t}\n\t}\n\nout:\n\tMP_MUTEX_UNLOCK(mp_mutex);\n\treturn state;\n}\n\nstatic int mp_open(struct tty_struct *tty, struct file *filp)\n{\n\tstruct uart_driver *drv = (struct uart_driver *)tty->driver->driver_state;\n\tstruct sb_uart_state *state;\n\tint retval;\n\tint  line = tty->index;\n\tstruct mp_port *mtpt;\n\n\tretval = -ENODEV;\n\tif (line >= tty->driver->num)\n\t\tgoto fail;\n\n\tstate = uart_get(drv, line);\n\n\tif (IS_ERR(state)) {\n\t\tretval = PTR_ERR(state);\n\t\tgoto fail;\n\t}\n\n\tmtpt  = (struct mp_port *)state->port;\n\n\ttty->driver_data = state;\n\ttty->low_latency = (state->port->flags & UPF_LOW_LATENCY) ? 1 : 0;\n\ttty->alt_speed = 0;\n\tstate->info->tty = tty;\n\n\tif (tty_hung_up_p(filp)) {\n\t\tretval = -EAGAIN;\n\t\tstate->count--;\n\t\tMP_STATE_UNLOCK(state);\n\t\tgoto fail;\n\t}\n\n\tif (state->count == 1)\n\t\tmp_change_pm(state, 0);\n\n\tretval = mp_startup(state, 0);\n\n\tif (retval == 0)\n\t\tretval = mp_block_til_ready(filp, state);\n\tMP_STATE_UNLOCK(state);\n\n\tif (retval == 0 && !(state->info->flags & UIF_NORMAL_ACTIVE)) {\n\t\tstate->info->flags |= UIF_NORMAL_ACTIVE;\n\n\t\tmp_update_termios(state);\n\t}\n\n\tuart_clear_mctrl(state->port, TIOCM_RTS);\n\ttry_module_get(THIS_MODULE);\nfail:\n\treturn retval;\n}\n\n\nstatic const char *mp_type(struct sb_uart_port *port)\n{\n\tconst char *str = NULL;\n\n\tif (port->ops->type)\n\t\tstr = port->ops->type(port);\n\n\tif (!str)\n\t\tstr = \"unknown\";\n\n\treturn str;\n}\n\nstatic void mp_change_pm(struct sb_uart_state *state, int pm_state)\n{\n\tstruct sb_uart_port *port = state->port;\n\tif (port->ops->pm)\n\t\tport->ops->pm(port, pm_state, state->pm_state);\n\tstate->pm_state = pm_state;\n}\n\nstatic inline void mp_report_port(struct uart_driver *drv, struct sb_uart_port *port)\n{\n\tchar address[64];\n\n\tswitch (port->iotype) {\n\t\tcase UPIO_PORT:\n\t\t\tsnprintf(address, sizeof(address),\"I/O 0x%x\", port->iobase);\n\t\t\tbreak;\n\t\tcase UPIO_HUB6:\n\t\t\tsnprintf(address, sizeof(address),\"I/O 0x%x offset 0x%x\", port->iobase, port->hub6);\n\t\t\tbreak;\n\t\tcase UPIO_MEM:\n\t\t\tsnprintf(address, sizeof(address),\"MMIO 0x%lx\", port->mapbase);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnprintf(address, sizeof(address),\"*unknown*\" );\n\t\t\tstrlcpy(address, \"*unknown*\", sizeof(address));\n\t\t\tbreak;\n\t}\n\n\tprintk( \"%s%d at %s (irq = %d) is a %s\\n\",\n\t\t\tdrv->dev_name, port->line, address, port->irq, mp_type(port));\n\n}\n\nstatic void mp_configure_port(struct uart_driver *drv, struct sb_uart_state *state, struct sb_uart_port *port)\n{\n\tunsigned int flags;\n\n\n\tif (!port->iobase && !port->mapbase && !port->membase)\n\t{\n\t\tDPRINTK(\"%s error \\n\",__FUNCTION__);\n\t\treturn;\n\t}\n\tflags = UART_CONFIG_TYPE;\n\tif (port->flags & UPF_AUTO_IRQ)\n\t\tflags |= UART_CONFIG_IRQ;\n\tif (port->flags & UPF_BOOT_AUTOCONF) {\n\t\tport->type = PORT_UNKNOWN;\n\t\tport->ops->config_port(port, flags);\n\t}\n\n\tif (port->type != PORT_UNKNOWN) {\n\t\tunsigned long flags;\n\n\t\tmp_report_port(drv, port);\n\n\t\tspin_lock_irqsave(&port->lock, flags);\n\t\tport->ops->set_mctrl(port, 0);\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\n\t\tmp_change_pm(state, 3);\n\t}\n}\n\nstatic void mp_unconfigure_port(struct uart_driver *drv, struct sb_uart_state *state)\n{\n\tstruct sb_uart_port *port = state->port;\n\tstruct sb_uart_info *info = state->info;\n\n\tif (info && info->tty)\n\t\ttty_hangup(info->tty);\n\n\tMP_STATE_LOCK(state);\n\n\tstate->info = NULL;\n\n\tif (port->type != PORT_UNKNOWN)\n\t\tport->ops->release_port(port);\n\n\tport->type = PORT_UNKNOWN;\n\n\tif (info) {\n\t\ttasklet_kill(&info->tlet);\n\t\tkfree(info);\n\t}\n\n\tMP_STATE_UNLOCK(state);\n}\nstatic struct tty_operations mp_ops = {\n\t.open\t\t= mp_open,\n\t.close\t\t= mp_close,\n\t.write\t\t= mp_write,\n\t.put_char\t= mp_put_char,\n\t.flush_chars\t= mp_put_chars,\n\t.write_room\t= mp_write_room,\n\t.chars_in_buffer= mp_chars_in_buffer,\n\t.flush_buffer\t= mp_flush_buffer,\n\t.ioctl\t\t= mp_ioctl,\n\t.throttle\t= mp_throttle,\n\t.unthrottle\t= mp_unthrottle,\n\t.send_xchar\t= mp_send_xchar,\n\t.set_termios\t= mp_set_termios,\n\t.stop\t\t= mp_stop,\n\t.start\t\t= mp_start,\n\t.hangup\t\t= mp_hangup,\n\t.break_ctl\t= mp_break_ctl,\n\t.wait_until_sent= mp_wait_until_sent,\n#ifdef CONFIG_PROC_FS\n\t.proc_fops\t= NULL,\n#endif\n\t.tiocmget\t= mp_tiocmget,\n\t.tiocmset\t= mp_tiocmset,\n};\n\nstatic int mp_register_driver(struct uart_driver *drv)\n{\n\tstruct tty_driver *normal = NULL;\n\tint i, retval;\n\n\tdrv->state = kmalloc(sizeof(struct sb_uart_state) * drv->nr, GFP_KERNEL);\n\tretval = -ENOMEM;\n\tif (!drv->state)\n\t{\n\t\tprintk(\"SB PCI Error: Kernel memory allocation error!\\n\");\n\t\tgoto out;\n\t}\n\tmemset(drv->state, 0, sizeof(struct sb_uart_state) * drv->nr);\n\n\tnormal = alloc_tty_driver(drv->nr);\n\tif (!normal)\n\t{\n\t\tprintk(\"SB PCI Error: tty allocation error!\\n\");\n\t\tgoto out;\n\t}\n\n\tdrv->tty_driver = normal;\n\n\tnormal->owner           = drv->owner;\n\tnormal->magic\t\t= TTY_DRIVER_MAGIC;\n\tnormal->driver_name     = drv->driver_name;\n\tnormal->name\t\t= drv->dev_name;\n\tnormal->major\t\t= drv->major;\n\tnormal->minor_start\t= drv->minor;\n\n\tnormal->num\t\t= MAX_MP_PORT ; \n\n\tnormal->type\t\t= TTY_DRIVER_TYPE_SERIAL;\n\tnormal->subtype\t\t= SERIAL_TYPE_NORMAL;\n\tnormal->init_termios\t= tty_std_termios;\n\tnormal->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;\n\tnormal->flags\t\t= TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;\n\tnormal->driver_state    = drv;\n\n\ttty_set_operations(normal, &mp_ops);\n\nfor (i = 0; i < drv->nr; i++) {\n\tstruct sb_uart_state *state = drv->state + i;\n\n\tstate->close_delay     = 500;   \n\tstate->closing_wait    = 30000; \n\n\tmutex_init(&state->mutex);\n\t}\n\n\tretval = tty_register_driver(normal);\nout:\n\tif (retval < 0) {\n\t\tprintk(\"Register tty driver Fail!\\n\");\n\t\tput_tty_driver(normal);\n\t\tkfree(drv->state);\n\t}\n\n\treturn retval;\n}\n\nvoid mp_unregister_driver(struct uart_driver *drv)\n{\n    struct tty_driver *normal = NULL;\n\n    normal = drv->tty_driver;\n\n    if (!normal)\n    {\n        return;\n    }\n\n    tty_unregister_driver(normal);\n    put_tty_driver(normal);\n    drv->tty_driver = NULL;\n\n\n    if (drv->state)\n    {\n        kfree(drv->state);\n    }\n\n}\n\nstatic int mp_add_one_port(struct uart_driver *drv, struct sb_uart_port *port)\n{\n\tstruct sb_uart_state *state;\n\tint ret = 0;\n\n\n\tif (port->line >= drv->nr)\n\t\treturn -EINVAL;\n\n\tstate = drv->state + port->line;\n\n\tMP_MUTEX_LOCK(mp_mutex);\n\tif (state->port) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tstate->port = port;\n\n\tspin_lock_init(&port->lock);\n\tport->cons = drv->cons;\n\tport->info = state->info;\n\n\tmp_configure_port(drv, state, port);\n\n\ttty_register_device(drv->tty_driver, port->line, port->dev);\n\nout:\n\tMP_MUTEX_UNLOCK(mp_mutex);\n\n\n\treturn ret;\n}\n\nstatic int mp_remove_one_port(struct uart_driver *drv, struct sb_uart_port *port)\n{\n\tstruct sb_uart_state *state = drv->state + port->line;\n\n\tif (state->port != port)\n\t\tprintk(KERN_ALERT \"Removing wrong port: %p != %p\\n\",\n\t\t\t\tstate->port, port);\n\n\tMP_MUTEX_LOCK(mp_mutex);\n\n\ttty_unregister_device(drv->tty_driver, port->line);\n\n\tmp_unconfigure_port(drv, state);\n\tstate->port = NULL;\n\tMP_MUTEX_UNLOCK(mp_mutex);\n\n\treturn 0;\n}\n\nstatic void autoconfig(struct mp_port *mtpt, unsigned int probeflags)\n{\n\tunsigned char status1, scratch, scratch2, scratch3;\n\tunsigned char save_lcr, save_mcr;\n\tunsigned long flags;\n\n\tunsigned char u_type;\n\tunsigned char b_ret = 0;\n\n\tif (!mtpt->port.iobase && !mtpt->port.mapbase && !mtpt->port.membase)\n\t\treturn;\n\n\tDEBUG_AUTOCONF(\"ttyMP%d: autoconf (0x%04x, 0x%p): \",\n\t\t\tmtpt->port.line, mtpt->port.iobase, mtpt->port.membase);\n\n\tspin_lock_irqsave(&mtpt->port.lock, flags);\n\n\tif (!(mtpt->port.flags & UPF_BUGGY_UART)) {\n\t\tscratch = serial_inp(mtpt, UART_IER);\n\t\tserial_outp(mtpt, UART_IER, 0);\n#ifdef __i386__\n\t\toutb(0xff, 0x080);\n#endif\n\t\tscratch2 = serial_inp(mtpt, UART_IER) & 0x0f;\n\t\tserial_outp(mtpt, UART_IER, 0x0F);\n#ifdef __i386__\n\t\toutb(0, 0x080);\n#endif\n\t\tscratch3 = serial_inp(mtpt, UART_IER) & 0x0F;\n\t\tserial_outp(mtpt, UART_IER, scratch);\n\t\tif (scratch2 != 0 || scratch3 != 0x0F) {\n\t\t\tDEBUG_AUTOCONF(\"IER test failed (%02x, %02x) \",\n\t\t\t\t\tscratch2, scratch3);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tsave_mcr = serial_in(mtpt, UART_MCR);\n\tsave_lcr = serial_in(mtpt, UART_LCR);\n\n\tif (!(mtpt->port.flags & UPF_SKIP_TEST)) {\n\t\tserial_outp(mtpt, UART_MCR, UART_MCR_LOOP | 0x0A);\n\t\tstatus1 = serial_inp(mtpt, UART_MSR) & 0xF0;\n\t\tserial_outp(mtpt, UART_MCR, save_mcr);\n\t\tif (status1 != 0x90) {\n\t\t\tDEBUG_AUTOCONF(\"LOOP test failed (%02x) \",\n\t\t\t\t\tstatus1);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tserial_outp(mtpt, UART_LCR, 0xBF);\n\tserial_outp(mtpt, UART_EFR, 0);\n\tserial_outp(mtpt, UART_LCR, 0);\n\n\tserial_outp(mtpt, UART_FCR, UART_FCR_ENABLE_FIFO);\n\tscratch = serial_in(mtpt, UART_IIR) >> 6;\n\n\tDEBUG_AUTOCONF(\"iir=%d \", scratch);\n\tif(mtpt->device->nr_ports >= 8)\n\t\tb_ret = read_option_register(mtpt,(MP_OPTR_DIR0 + ((mtpt->port.line)/8)));\n\telse\t\n\t\tb_ret = read_option_register(mtpt,MP_OPTR_DIR0);\n\tu_type = (b_ret & 0xf0) >> 4;\n\tif(mtpt->port.type == PORT_UNKNOWN )\n\t{\n\t\tswitch (u_type)\n\t\t{\n\t\t\tcase DIR_UART_16C550:\n\t\t\t\tmtpt->port.type = PORT_16C55X;\n\t\t\t\tbreak;\n\t\t\tcase DIR_UART_16C1050:\n\t\t\t\tmtpt->port.type = PORT_16C105X;\n\t\t\t\tbreak;\n\t\t\tcase DIR_UART_16C1050A:\n\t\t\t\tif (mtpt->port.line < 2)\n\t\t\t\t{\n\t\t\t\t\tmtpt->port.type = PORT_16C105XA;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (mtpt->device->device_id & 0x50)\n\t\t\t\t\t{\n\t\t\t\t\t\tmtpt->port.type = PORT_16C55X;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tmtpt->port.type = PORT_16C105X;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\t\n\t\t\t\tmtpt->port.type = PORT_UNKNOWN;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(mtpt->port.type == PORT_UNKNOWN )\n\t{\nprintk(\"unknow2\\n\");\n\t\tswitch (scratch) {\n\t\t\tcase 0:\n\t\t\tcase 1:\n\t\t\t\tmtpt->port.type = PORT_UNKNOWN;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\tcase 3:\n\t\t\t\tmtpt->port.type = PORT_16C55X;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tserial_outp(mtpt, UART_LCR, save_lcr);\n\n\tmtpt->port.fifosize = uart_config[mtpt->port.type].dfl_xmit_fifo_size;\n\tmtpt->capabilities = uart_config[mtpt->port.type].flags;\n\n\tif (mtpt->port.type == PORT_UNKNOWN)\n\t\tgoto out;\n\tserial_outp(mtpt, UART_MCR, save_mcr);\n\tserial_outp(mtpt, UART_FCR, (UART_FCR_ENABLE_FIFO |\n\t\t\t\tUART_FCR_CLEAR_RCVR |\n\t\t\t\tUART_FCR_CLEAR_XMIT));\n\tserial_outp(mtpt, UART_FCR, 0);\n\t(void)serial_in(mtpt, UART_RX);\n\tserial_outp(mtpt, UART_IER, 0);\n\nout:\n\tspin_unlock_irqrestore(&mtpt->port.lock, flags);\n\tDEBUG_AUTOCONF(\"type=%s\\n\", uart_config[mtpt->port.type].name);\n}\n\nstatic void autoconfig_irq(struct mp_port *mtpt)\n{\n\tunsigned char save_mcr, save_ier;\n\tunsigned long irqs;\n\tint irq;\n\n\t/* forget possible initially masked and pending IRQ */\n\tprobe_irq_off(probe_irq_on());\n\tsave_mcr = serial_inp(mtpt, UART_MCR);\n\tsave_ier = serial_inp(mtpt, UART_IER);\n\tserial_outp(mtpt, UART_MCR, UART_MCR_OUT1 | UART_MCR_OUT2);\n\n\tirqs = probe_irq_on();\n\tserial_outp(mtpt, UART_MCR, 0);\n\tserial_outp(mtpt, UART_MCR,\n\t\tUART_MCR_DTR | UART_MCR_RTS | UART_MCR_OUT2);\n\n\tserial_outp(mtpt, UART_IER, 0x0f);    /* enable all intrs */\n\t(void)serial_inp(mtpt, UART_LSR);\n\t(void)serial_inp(mtpt, UART_RX);\n\t(void)serial_inp(mtpt, UART_IIR);\n\t(void)serial_inp(mtpt, UART_MSR);\n\tserial_outp(mtpt, UART_TX, 0xFF);\n\tirq = probe_irq_off(irqs);\n\n\tserial_outp(mtpt, UART_MCR, save_mcr);\n\tserial_outp(mtpt, UART_IER, save_ier);\n\n\tmtpt->port.irq = (irq > 0) ? irq : 0;\n}\n\nstatic void multi_stop_tx(struct sb_uart_port *port)\n{\n\tstruct mp_port *mtpt = (struct mp_port *)port;\n\n\tif (mtpt->ier & UART_IER_THRI) {\n\t\tmtpt->ier &= ~UART_IER_THRI;\n\t\tserial_out(mtpt, UART_IER, mtpt->ier);\n\t}\n\n\ttasklet_schedule(&port->info->tlet);\n}\n\nstatic void multi_start_tx(struct sb_uart_port *port)\n{\n\tstruct mp_port *mtpt = (struct mp_port *)port;\n\n\tif (!(mtpt->ier & UART_IER_THRI)) {\n\t\tmtpt->ier |= UART_IER_THRI;\n\t\tserial_out(mtpt, UART_IER, mtpt->ier);\n\t}\n}\n\nstatic void multi_stop_rx(struct sb_uart_port *port)\n{\n\tstruct mp_port *mtpt = (struct mp_port *)port;\n\n\tmtpt->ier &= ~UART_IER_RLSI;\n\tmtpt->port.read_status_mask &= ~UART_LSR_DR;\n\tserial_out(mtpt, UART_IER, mtpt->ier);\n}\n\nstatic void multi_enable_ms(struct sb_uart_port *port)\n{\n\tstruct mp_port *mtpt = (struct mp_port *)port;\n\n\tmtpt->ier |= UART_IER_MSI;\n\tserial_out(mtpt, UART_IER, mtpt->ier);\n}\n\n\nstatic _INLINE_ void receive_chars(struct mp_port *mtpt, int *status )\n{\n\tstruct tty_struct *tty = mtpt->port.info->tty;\n\tunsigned char lsr = *status;\n\tint max_count = 256;\n\tunsigned char ch;\n\tchar flag;\n\n\t//lsr &= mtpt->port.read_status_mask;\n\n\tdo {\n\t\tif ((lsr & UART_LSR_PE) && (mtpt->port.mdmode & MDMODE_ENABLE))\n\t\t{\n\t\t\tch = serial_inp(mtpt, UART_RX);\n\t\t}\n\t\telse if (lsr & UART_LSR_SPECIAL) \n\t\t{\n\t\t\tflag = 0;\n\t\t\tch = serial_inp(mtpt, UART_RX);\n\n\t\t\tif (lsr & UART_LSR_BI) \n\t\t\t{\n\n\t\t\t\tmtpt->port.icount.brk++;\n\t\t\t\tflag = TTY_BREAK;\n\n\t\t\t\tif (sb_uart_handle_break(&mtpt->port))\n\t\t\t\t\tgoto ignore_char;\n\t\t\t} \n\t\t\tif (lsr & UART_LSR_PE)\n\t\t\t{\n\t\t\t\tmtpt->port.icount.parity++;\n\t\t\t\tflag = TTY_PARITY;\n\t\t\t}\n\t\t\tif (lsr & UART_LSR_FE)\n\t\t\t{\n\t\t\t\tmtpt->port.icount.frame++;\n\t\t\t\tflag = TTY_FRAME;\n\t\t\t}\n\t\t\tif (lsr & UART_LSR_OE)\n\t\t\t{\n\t\t\t\tmtpt->port.icount.overrun++;\n\t\t\t\tflag = TTY_OVERRUN;\n\t\t\t}\n\t\t\ttty_insert_flip_char(tty, ch, flag);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tch = serial_inp(mtpt, UART_RX);\n\t\t\ttty_insert_flip_char(tty, ch, 0);\n\t\t}\nignore_char:\n\t\tlsr = serial_inp(mtpt, UART_LSR);\n\t} while ((lsr & UART_LSR_DR) && (max_count-- > 0));\n\n\ttty_flip_buffer_push(tty);\n}\n\n\n\n\nstatic _INLINE_ void transmit_chars(struct mp_port *mtpt)\n{\n\tstruct circ_buf *xmit = &mtpt->port.info->xmit;\n\tint count;\n\n\tif (mtpt->port.x_char) {\n\t\tserial_outp(mtpt, UART_TX, mtpt->port.x_char);\n\t\tmtpt->port.icount.tx++;\n\t\tmtpt->port.x_char = 0;\n\t\treturn;\n\t}\n\tif (uart_circ_empty(xmit) || uart_tx_stopped(&mtpt->port)) {\n\t\tmulti_stop_tx(&mtpt->port);\n\t\treturn;\n\t}\n\n\tcount = uart_circ_chars_pending(xmit);\n\n\tif(count > mtpt->port.fifosize)\n\t{\n\t\tcount = mtpt->port.fifosize;\n\t}\n\n\tprintk(\"[%d] mdmode: %x\\n\", mtpt->port.line, mtpt->port.mdmode);\n\tdo {\n#if 0\n\t\t/* check multi-drop mode */\n\t\tif ((mtpt->port.mdmode & (MDMODE_ENABLE | MDMODE_ADDR)) == (MDMODE_ENABLE | MDMODE_ADDR))\n\t\t{\n\t\t\tprintk(\"send address\\n\");\n\t\t\t/* send multi-drop address */\n\t\t\tserial_out(mtpt, UART_SCR, xmit->buf[xmit->tail]);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t\tserial_out(mtpt, UART_TX, xmit->buf[xmit->tail]);\n\t\t}\n\t\txmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\n\t\tmtpt->port.icount.tx++;\n\t} while (--count > 0);\n}\n\n\n\nstatic _INLINE_ void check_modem_status(struct mp_port *mtpt)\n{\n\tint status;\n\n\tstatus = serial_in(mtpt, UART_MSR);\n\n\tif ((status & UART_MSR_ANY_DELTA) == 0)\n\t\treturn;\n\n\tif (status & UART_MSR_TERI)\n\t\tmtpt->port.icount.rng++;\n\tif (status & UART_MSR_DDSR)\n\t\tmtpt->port.icount.dsr++;\n\tif (status & UART_MSR_DDCD)\n\t\tsb_uart_handle_dcd_change(&mtpt->port, status & UART_MSR_DCD);\n\tif (status & UART_MSR_DCTS)\n\t\tsb_uart_handle_cts_change(&mtpt->port, status & UART_MSR_CTS);\n\n\twake_up_interruptible(&mtpt->port.info->delta_msr_wait);\n}\n\nstatic inline void multi_handle_port(struct mp_port *mtpt)\n{\n\tunsigned int status = serial_inp(mtpt, UART_LSR);\n\n\t//printk(\"lsr: %x\\n\", status);\n\n\tif ((status & UART_LSR_DR) || (status & UART_LSR_SPECIAL))\n\t\treceive_chars(mtpt, &status);\n\tcheck_modem_status(mtpt);\n\tif (status & UART_LSR_THRE)\n\t{\n\t\tif ((mtpt->port.type == PORT_16C105X)\n\t\t\t|| (mtpt->port.type == PORT_16C105XA))\n\t\t\ttransmit_chars(mtpt);\n\t\telse\n\t\t{\n\t\t\tif (mtpt->interface >= RS485NE)\n\t\t\t\tuart_set_mctrl(&mtpt->port, TIOCM_RTS);\n\t\t\t\n\t\t\ttransmit_chars(mtpt);\n\n\n\t\t\tif (mtpt->interface >= RS485NE)\n\t\t\t{\n\t\t\t\twhile((status=serial_in(mtpt,UART_LSR) &0x60)!=0x60);\n\t\t\t\tuart_clear_mctrl(&mtpt->port, TIOCM_RTS);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\nstatic irqreturn_t multi_interrupt(int irq, void *dev_id)\n{\n\tstruct irq_info *iinfo = dev_id;\n\tstruct list_head *lhead, *end = NULL;\n\tint pass_counter = 0;\n\n\n\tspin_lock(&iinfo->lock);\n\n\tlhead = iinfo->head;\n\tdo {\n\t\tstruct mp_port *mtpt;\n\t\tunsigned int iir;\n\n\t\tmtpt = list_entry(lhead, struct mp_port, list);\n\t\t\n\t\tiir = serial_in(mtpt, UART_IIR);\n\t\tprintk(\"interrupt! port %d, iir 0x%x\\n\", mtpt->port.line, iir); //wlee\n\t\tif (!(iir & UART_IIR_NO_INT)) \n\t\t{\n\t\t\tprintk(\"interrupt handle\\n\");\n\t\t\tspin_lock(&mtpt->port.lock);\n\t\t\tmulti_handle_port(mtpt);\n\t\t\tspin_unlock(&mtpt->port.lock);\n\n\t\t\tend = NULL;\n\t\t} else if (end == NULL)\n\t\t\tend = lhead;\n\n\t\tlhead = lhead->next;\n\t\tif (lhead == iinfo->head && pass_counter++ > PASS_LIMIT) \n\t\t{\n\t\t\tprintk(KERN_ERR \"multi: too much work for \"\n\t\t\t\t\t\"irq%d\\n\", irq);\n\t\t\tprintk( \"multi: too much work for \"\n\t\t\t\t\t\"irq%d\\n\", irq);\n\t\t\tbreak;\n\t\t}\n\t} while (lhead != end);\n\n\tspin_unlock(&iinfo->lock);\n\n\n        return IRQ_HANDLED;\n}\n\nstatic void serial_do_unlink(struct irq_info *i, struct mp_port *mtpt)\n{\n\tspin_lock_irq(&i->lock);\n\n\tif (!list_empty(i->head)) {\n\t\tif (i->head == &mtpt->list)\n\t\t\ti->head = i->head->next;\n\t\tlist_del(&mtpt->list);\n\t} else {\n\t\ti->head = NULL;\n\t}\n\n\tspin_unlock_irq(&i->lock);\n}\n\nstatic int serial_link_irq_chain(struct mp_port *mtpt)\n{\n\tstruct irq_info *i = irq_lists + mtpt->port.irq;\n\tint ret, irq_flags = mtpt->port.flags & UPF_SHARE_IRQ ? IRQF_SHARED : 0;\n\tspin_lock_irq(&i->lock);\n\n\tif (i->head) {\n\t\tlist_add(&mtpt->list, i->head);\n\t\tspin_unlock_irq(&i->lock);\n\n\t\tret = 0;\n\t} else {\n\t\tINIT_LIST_HEAD(&mtpt->list);\n\t\ti->head = &mtpt->list;\n\t\tspin_unlock_irq(&i->lock);\n\n\t\tret = request_irq(mtpt->port.irq, multi_interrupt,\n\t\t\t\tirq_flags, \"serial\", i);\n\t\tif (ret < 0)\n\t\t\tserial_do_unlink(i, mtpt);\n\t}\n\n\treturn ret;\n}\n\n\n\n\nstatic void serial_unlink_irq_chain(struct mp_port *mtpt)\n{\n\tstruct irq_info *i = irq_lists + mtpt->port.irq;\n\n\tif (list_empty(i->head))\n\t{\n\t\tfree_irq(mtpt->port.irq, i);\n\t}\n\tserial_do_unlink(i, mtpt);\n}\n\nstatic void multi_timeout(unsigned long data)\n{\n\tstruct mp_port *mtpt = (struct mp_port *)data;\n\n\n\tspin_lock(&mtpt->port.lock);\n\tmulti_handle_port(mtpt);\n\tspin_unlock(&mtpt->port.lock);\n\n\tmod_timer(&mtpt->timer, jiffies+1 );\n}\n\nstatic unsigned int multi_tx_empty(struct sb_uart_port *port)\n{\n\tstruct mp_port *mtpt = (struct mp_port *)port;\n\tunsigned long flags;\n\tunsigned int ret;\n\n\tspin_lock_irqsave(&mtpt->port.lock, flags);\n\tret = serial_in(mtpt, UART_LSR) & UART_LSR_TEMT ? TIOCSER_TEMT : 0;\n\tspin_unlock_irqrestore(&mtpt->port.lock, flags);\n\n\treturn ret;\n}\n\n\nstatic unsigned int multi_get_mctrl(struct sb_uart_port *port)\n{\n\tstruct mp_port *mtpt = (struct mp_port *)port;\n\tunsigned char status;\n\tunsigned int ret;\n\n\tstatus = serial_in(mtpt, UART_MSR);\n\n\tret = 0;\n\tif (status & UART_MSR_DCD)\n\t\tret |= TIOCM_CAR;\n\tif (status & UART_MSR_RI)\n\t\tret |= TIOCM_RNG;\n\tif (status & UART_MSR_DSR)\n\t\tret |= TIOCM_DSR;\n\tif (status & UART_MSR_CTS)\n\t\tret |= TIOCM_CTS;\n\treturn ret;\n}\n\nstatic void multi_set_mctrl(struct sb_uart_port *port, unsigned int mctrl)\n{\n\tstruct mp_port *mtpt = (struct mp_port *)port;\n\tunsigned char mcr = 0;\n\n\tmctrl &= 0xff;\n\n\tif (mctrl & TIOCM_RTS)\n\t\tmcr |= UART_MCR_RTS;\n\tif (mctrl & TIOCM_DTR)\n\t\tmcr |= UART_MCR_DTR;\n\tif (mctrl & TIOCM_OUT1)\n\t\tmcr |= UART_MCR_OUT1;\n\tif (mctrl & TIOCM_OUT2)\n\t\tmcr |= UART_MCR_OUT2;\n\tif (mctrl & TIOCM_LOOP)\n\t\tmcr |= UART_MCR_LOOP;\n\n\n\tserial_out(mtpt, UART_MCR, mcr);\n}\n\n\nstatic void multi_break_ctl(struct sb_uart_port *port, int break_state)\n{\n\tstruct mp_port *mtpt = (struct mp_port *)port;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mtpt->port.lock, flags);\n\tif (break_state == -1)\n\t\tmtpt->lcr |= UART_LCR_SBC;\n\telse\n\t\tmtpt->lcr &= ~UART_LCR_SBC;\n\tserial_out(mtpt, UART_LCR, mtpt->lcr);\n\tspin_unlock_irqrestore(&mtpt->port.lock, flags);\n}\n\n\n\nstatic int multi_startup(struct sb_uart_port *port)\n{\n\tstruct mp_port *mtpt = (struct mp_port *)port;\n\tunsigned long flags;\n\tint retval;\n\n\tmtpt->capabilities = uart_config[mtpt->port.type].flags;\n\tmtpt->mcr = 0;\n\n\tif (mtpt->capabilities & UART_CLEAR_FIFO) {\n\t\tserial_outp(mtpt, UART_FCR, UART_FCR_ENABLE_FIFO);\n\t\tserial_outp(mtpt, UART_FCR, UART_FCR_ENABLE_FIFO |\n\t\t\t\tUART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);\n\t\tserial_outp(mtpt, UART_FCR, 0);\n\t}\n\n\t(void) serial_inp(mtpt, UART_LSR);\n\t(void) serial_inp(mtpt, UART_RX);\n\t(void) serial_inp(mtpt, UART_IIR);\n\t(void) serial_inp(mtpt, UART_MSR);\n\t//test-wlee 9-bit disable\n\tserial_outp(mtpt, UART_MSR, 0);\n\n\n\tif (!(mtpt->port.flags & UPF_BUGGY_UART) &&\n\t\t\t(serial_inp(mtpt, UART_LSR) == 0xff)) {\n\t\tprintk(\"ttyS%d: LSR safety check engaged!\\n\", mtpt->port.line);\n\t\t//return -ENODEV;\n\t}\n\n\tif ((!is_real_interrupt(mtpt->port.irq)) || (mtpt->poll_type==TYPE_POLL)) {\n\t\tunsigned int timeout = mtpt->port.timeout;\n\n\t\ttimeout = timeout > 6 ? (timeout / 2 - 2) : 1;\n\n\t\tmtpt->timer.data = (unsigned long)mtpt;\n\t\tmod_timer(&mtpt->timer, jiffies + timeout);\n\t} \n\telse \n\t{\n\t\tretval = serial_link_irq_chain(mtpt);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\tserial_outp(mtpt, UART_LCR, UART_LCR_WLEN8);\n\n\tspin_lock_irqsave(&mtpt->port.lock, flags);\n\tif ((is_real_interrupt(mtpt->port.irq))||(mtpt->poll_type==TYPE_INTERRUPT))\n\t\tmtpt->port.mctrl |= TIOCM_OUT2;\n\n\tmulti_set_mctrl(&mtpt->port, mtpt->port.mctrl);\n\tspin_unlock_irqrestore(&mtpt->port.lock, flags);\n\n\t\n\tmtpt->ier = UART_IER_RLSI | UART_IER_RDI;\n\tserial_outp(mtpt, UART_IER, mtpt->ier);\n\n\t(void) serial_inp(mtpt, UART_LSR);\n\t(void) serial_inp(mtpt, UART_RX);\n\t(void) serial_inp(mtpt, UART_IIR);\n\t(void) serial_inp(mtpt, UART_MSR);\n\n\treturn 0;\n}\n\n\n\nstatic void multi_shutdown(struct sb_uart_port *port)\n{\n\tstruct mp_port *mtpt = (struct mp_port *)port;\n\tunsigned long flags;\n\n\n\tmtpt->ier = 0;\n\tserial_outp(mtpt, UART_IER, 0);\n\n\tspin_lock_irqsave(&mtpt->port.lock, flags);\n\tmtpt->port.mctrl &= ~TIOCM_OUT2;\n\n\tmulti_set_mctrl(&mtpt->port, mtpt->port.mctrl);\n\tspin_unlock_irqrestore(&mtpt->port.lock, flags);\n\n\tserial_out(mtpt, UART_LCR, serial_inp(mtpt, UART_LCR) & ~UART_LCR_SBC);\n\tserial_outp(mtpt, UART_FCR, UART_FCR_ENABLE_FIFO |\n\t\t\tUART_FCR_CLEAR_RCVR |\n\t\t\tUART_FCR_CLEAR_XMIT);\n\tserial_outp(mtpt, UART_FCR, 0);\n\n\n\t(void) serial_in(mtpt, UART_RX);\n\n\tif ((!is_real_interrupt(mtpt->port.irq))||(mtpt->poll_type==TYPE_POLL))\n\t{\n\t\tdel_timer_sync(&mtpt->timer);\n\t}\n\telse\n\t{\n\t\tserial_unlink_irq_chain(mtpt);\n\t}\n}\n\n\n\nstatic unsigned int multi_get_divisor(struct sb_uart_port *port, unsigned int baud)\n{\n\tunsigned int quot;\n\n\tif ((port->flags & UPF_MAGIC_MULTIPLIER) &&\n\t\t\tbaud == (port->uartclk/4))\n\t\tquot = 0x8001;\n\telse if ((port->flags & UPF_MAGIC_MULTIPLIER) &&\n\t\t\tbaud == (port->uartclk/8))\n\t\tquot = 0x8002;\n\telse\n\t\tquot = sb_uart_get_divisor(port, baud);\n\n\treturn quot;\n}\n\n\n\n\nstatic void multi_set_termios(struct sb_uart_port *port, struct MP_TERMIOS *termios, struct MP_TERMIOS *old)\n{\n\tstruct mp_port *mtpt = (struct mp_port *)port;\n\tunsigned char cval, fcr = 0;\n\tunsigned long flags;\n\tunsigned int baud, quot;\n\n\tswitch (termios->c_cflag & CSIZE) {\n\t\tcase CS5:\n\t\t\tcval = 0x00;\n\t\t\tbreak;\n\t\tcase CS6:\n\t\t\tcval = 0x01;\n\t\t\tbreak;\n\t\tcase CS7:\n\t\t\tcval = 0x02;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase CS8:\n\t\t\tcval = 0x03;\n\t\t\tbreak;\n\t}\n\n\tif (termios->c_cflag & CSTOPB)\n\t\tcval |= 0x04;\n\tif (termios->c_cflag & PARENB)\n\t\tcval |= UART_LCR_PARITY;\n\tif (!(termios->c_cflag & PARODD))\n\t\tcval |= UART_LCR_EPAR;\n\n#ifdef CMSPAR\n\tif (termios->c_cflag & CMSPAR)\n\t\tcval |= UART_LCR_SPAR;\n#endif\n\n\tbaud = sb_uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);\n\tquot = multi_get_divisor(port, baud);\n\n\tif (mtpt->capabilities & UART_USE_FIFO) {\n\t\t//if (baud < 2400)\n\t\t//\tfcr = UART_FCR_ENABLE_FIFO | UART_FCR_TRIGGER_1;\n\t\t//else\n\t\t//\tfcr = UART_FCR_ENABLE_FIFO | UART_FCR_TRIGGER_8;\n\n\t\t//\tfcr = UART_FCR_ENABLE_FIFO | 0x90;\n\t\t\tfcr = fcr_arr[mtpt->port.line];\n\t}\n\n\tspin_lock_irqsave(&mtpt->port.lock, flags);\n\n\tsb_uart_update_timeout(port, termios->c_cflag, baud);\n\n\tmtpt->port.read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;\n\tif (termios->c_iflag & INPCK)\n\t\tmtpt->port.read_status_mask |= UART_LSR_FE | UART_LSR_PE;\n\tif (termios->c_iflag & (BRKINT | PARMRK))\n\t\tmtpt->port.read_status_mask |= UART_LSR_BI;\n\n\tmtpt->port.ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tmtpt->port.ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;\n\tif (termios->c_iflag & IGNBRK) {\n\t\tmtpt->port.ignore_status_mask |= UART_LSR_BI;\n\t\tif (termios->c_iflag & IGNPAR)\n\t\t\tmtpt->port.ignore_status_mask |= UART_LSR_OE;\n\t}\n\n\tif ((termios->c_cflag & CREAD) == 0)\n\t\tmtpt->port.ignore_status_mask |= UART_LSR_DR;\n\n\tmtpt->ier &= ~UART_IER_MSI;\n\tif (UART_ENABLE_MS(&mtpt->port, termios->c_cflag))\n\t\tmtpt->ier |= UART_IER_MSI;\n\n\tserial_out(mtpt, UART_IER, mtpt->ier);\n\n\tif (mtpt->capabilities & UART_STARTECH) {\n\t\tserial_outp(mtpt, UART_LCR, 0xBF);\n\t\tserial_outp(mtpt, UART_EFR,\n\t\t\t\ttermios->c_cflag & CRTSCTS ? UART_EFR_CTS :0);\n\t}\n\n\tserial_outp(mtpt, UART_LCR, cval | UART_LCR_DLAB);/* set DLAB */\n\n\tserial_outp(mtpt, UART_DLL, quot & 0xff);     /* LS of divisor */\n\tserial_outp(mtpt, UART_DLM, quot >> 8);       /* MS of divisor */\n\n\tserial_outp(mtpt, UART_LCR, cval);        /* reset DLAB */\n\tmtpt->lcr = cval;                 /* Save LCR */\n\n\tif (fcr & UART_FCR_ENABLE_FIFO) {\n\t\t/* emulated UARTs (Lucent Venus 167x) need two steps */\n\t\tserial_outp(mtpt, UART_FCR, UART_FCR_ENABLE_FIFO);\n\t}\n\n\tserial_outp(mtpt, UART_FCR, fcr);     /* set fcr */\n\n\n\tif ((mtpt->port.type == PORT_16C105X)\n\t\t|| (mtpt->port.type == PORT_16C105XA))\n\t{\n\t\tif(deep[mtpt->port.line]!=0)\n\t\t\tset_deep_fifo(port, ENABLE);\n\n\t\tif (mtpt->interface != RS232)\n\t\t\tset_auto_rts(port,mtpt->interface);\n\n\t}\n\telse\n\t{\n\t\tif (mtpt->interface >= RS485NE)\n\t\t{\n\t\t\tuart_clear_mctrl(&mtpt->port, TIOCM_RTS);\n\t\t}\n\t}\n\n\tif(mtpt->device->device_id == PCI_DEVICE_ID_MP4M)\n\t{\n\t\tSendATCommand(mtpt);\n\t\tprintk(\"SendATCommand\\n\");\n\t}\t\n\tmulti_set_mctrl(&mtpt->port, mtpt->port.mctrl);\n\tspin_unlock_irqrestore(&mtpt->port.lock, flags);\n}\n\nstatic void multi_pm(struct sb_uart_port *port, unsigned int state, unsigned int oldstate)\n{\n\tstruct mp_port *mtpt = (struct mp_port *)port;\n\tif (state) {\n\t\tif (mtpt->capabilities & UART_STARTECH) {\n\t\t\tserial_outp(mtpt, UART_LCR, 0xBF);\n\t\t\tserial_outp(mtpt, UART_EFR, UART_EFR_ECB);\n\t\t\tserial_outp(mtpt, UART_LCR, 0);\n\t\t\tserial_outp(mtpt, UART_IER, UART_IERX_SLEEP);\n\t\t\tserial_outp(mtpt, UART_LCR, 0xBF);\n\t\t\tserial_outp(mtpt, UART_EFR, 0);\n\t\t\tserial_outp(mtpt, UART_LCR, 0);\n\t\t}\n\n\t\tif (mtpt->pm)\n\t\t\tmtpt->pm(port, state, oldstate);\n\t} \n\telse \n\t{\n\t\tif (mtpt->capabilities & UART_STARTECH) {\n\t\t\tserial_outp(mtpt, UART_LCR, 0xBF);\n\t\t\tserial_outp(mtpt, UART_EFR, UART_EFR_ECB);\n\t\t\tserial_outp(mtpt, UART_LCR, 0);\n\t\t\tserial_outp(mtpt, UART_IER, 0);\n\t\t\tserial_outp(mtpt, UART_LCR, 0xBF);\n\t\t\tserial_outp(mtpt, UART_EFR, 0);\n\t\t\tserial_outp(mtpt, UART_LCR, 0);\n\t\t}\n\n\t\tif (mtpt->pm)\n\t\t\tmtpt->pm(port, state, oldstate);\n\t}\n}\n\nstatic void multi_release_std_resource(struct mp_port *mtpt)\n{\n\tunsigned int size = 8 << mtpt->port.regshift;\n\n\tswitch (mtpt->port.iotype) {\n\t\tcase UPIO_MEM:\n\t\t\tif (!mtpt->port.mapbase)\n\t\t\t\tbreak;\n\n\t\t\tif (mtpt->port.flags & UPF_IOREMAP) {\n\t\t\t\tiounmap(mtpt->port.membase);\n\t\t\t\tmtpt->port.membase = NULL;\n\t\t\t}\n\n\t\t\trelease_mem_region(mtpt->port.mapbase, size);\n\t\t\tbreak;\n\n\t\tcase UPIO_HUB6:\n\t\tcase UPIO_PORT:\n\t\t\trelease_region(mtpt->port.iobase,size);\n\t\t\tbreak;\n\t}\n}\n\nstatic void multi_release_port(struct sb_uart_port *port)\n{\n}\n\nstatic int multi_request_port(struct sb_uart_port *port)\n{\n\treturn 0;\n}\n\nstatic void multi_config_port(struct sb_uart_port *port, int flags)\n{\n\tstruct mp_port *mtpt = (struct mp_port *)port;\n\tint probeflags = PROBE_ANY;\n\n\tif (flags & UART_CONFIG_TYPE)\n\t\tautoconfig(mtpt, probeflags);\n\tif (mtpt->port.type != PORT_UNKNOWN && flags & UART_CONFIG_IRQ)\n\t\tautoconfig_irq(mtpt);\n\n\tif (mtpt->port.type == PORT_UNKNOWN)\n\t\tmulti_release_std_resource(mtpt);\n}\n\nstatic int multi_verify_port(struct sb_uart_port *port, struct serial_struct *ser)\n{\n\tif (ser->irq >= NR_IRQS || ser->irq < 0 ||\n\t\t\tser->baud_base < 9600 || ser->type < PORT_UNKNOWN ||\n\t\t\tser->type == PORT_STARTECH)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic const char *multi_type(struct sb_uart_port *port)\n{\n\tint type = port->type;\n\n\tif (type >= ARRAY_SIZE(uart_config))\n\t\ttype = 0;\n\treturn uart_config[type].name;\n}\n\nstatic struct sb_uart_ops multi_pops = {\n\t.tx_empty   = multi_tx_empty,\n\t.set_mctrl  = multi_set_mctrl,\n\t.get_mctrl  = multi_get_mctrl,\n\t.stop_tx    = multi_stop_tx,\n\t.start_tx   = multi_start_tx,\n\t.stop_rx    = multi_stop_rx,\n\t.enable_ms  = multi_enable_ms,\n\t.break_ctl  = multi_break_ctl,\n\t.startup    = multi_startup,\n\t.shutdown   = multi_shutdown,\n\t.set_termios    = multi_set_termios,\n\t.pm     \t= multi_pm,\n\t.type       \t= multi_type,\n\t.release_port   = multi_release_port,\n\t.request_port   = multi_request_port,\n\t.config_port    = multi_config_port,\n\t.verify_port    = multi_verify_port,\n};\n\nstatic struct uart_driver multi_reg = {\n\t.owner          = THIS_MODULE,\n\t.driver_name    = \"goldel_tulip\",\n\t.dev_name       = \"ttyMP\",\n\t.major          = SB_TTY_MP_MAJOR,\n\t.minor          = 0,\n\t.nr             = MAX_MP_PORT, \n\t.cons           = NULL,\n};\n\nstatic void __init multi_init_ports(void)\n{\n\tstruct mp_port *mtpt;\n\tstatic int first = 1;\n\tint i,j,k;\n\tunsigned char osc;\n\tunsigned char b_ret = 0;\n\tstatic struct mp_device_t *sbdev; \n\n\tif (!first)\n\t\treturn;\n\tfirst = 0;\n\n\tmtpt = multi_ports; \n\n\tfor (k=0;k<NR_BOARD;k++)\n\t{\n\t\tsbdev = &mp_devs[k];\n\n\t\tfor (i = 0; i < sbdev->nr_ports; i++, mtpt++) \n\t\t{\n\t\t\tmtpt->device \t\t= sbdev;\n\t\t\tmtpt->port.iobase   = sbdev->uart_access_addr + 8*i;\n\t\t\tmtpt->port.irq      = sbdev->irq;\n\t\t\tif ( ((sbdev->device_id == PCI_DEVICE_ID_MP4)&&(sbdev->revision==0x91)))\n\t\t\t\tmtpt->interface_config_addr = sbdev->option_reg_addr + 0x08 + i;\n\t\t\telse if (sbdev->revision == 0xc0)\n\t\t\t\tmtpt->interface_config_addr = sbdev->option_reg_addr + 0x08 + (i & 0x1);\n\t\t\telse\n\t\t\t\tmtpt->interface_config_addr = sbdev->option_reg_addr + 0x08 + i/8;\n\n\t\t\tmtpt->option_base_addr = sbdev->option_reg_addr;\n\n\t\t\tmtpt->poll_type = sbdev->poll_type;\n\n\t\t\tmtpt->port.uartclk  = BASE_BAUD * 16;\n\n\t\t\t/* get input clock information */\n\t\t\tosc = inb(sbdev->option_reg_addr + MP_OPTR_DIR0 + i/8) & 0x0F;\n\t\t\tif (osc==0x0f)\n\t\t\t\tosc = 0;\n\t\t\tfor(j=0;j<osc;j++)\n\t\t\t\tmtpt->port.uartclk *= 2;\n\t\t\tmtpt->port.flags    |= STD_COM_FLAGS | UPF_SHARE_IRQ ;\n\t\t\tmtpt->port.iotype   = UPIO_PORT;\n\t\t\tmtpt->port.ops      = &multi_pops;\n\n\t\t\tif (sbdev->revision == 0xc0)\n\t\t\t{\n\t\t\t\t/* for SB16C1053APCI */\n\t\t\t\tb_ret = sb1053a_get_interface(mtpt, i);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb_ret = read_option_register(mtpt,(MP_OPTR_IIR0 + i/8));\n\t\t\t\tprintk(\"IIR_RET = %x\\n\",b_ret);\n\t\t\t}\n\n\t\t\t/* default to RS232 */\n\t\t\tmtpt->interface = RS232;\n\t\t\tif (IIR_RS422 == (b_ret & IIR_TYPE_MASK))\n\t\t\t\tmtpt->interface = RS422PTP;\n\t\t\tif (IIR_RS485 == (b_ret & IIR_TYPE_MASK))\n\t\t\t\tmtpt->interface = RS485NE;\n\t\t}\n\t}\n}\n\nstatic void __init multi_register_ports(struct uart_driver *drv)\n{\n\tint i;\n\n\tmulti_init_ports();\n\n\tfor (i = 0; i < NR_PORTS; i++) {\n\t\tstruct mp_port *mtpt = &multi_ports[i];\n\n\t\tmtpt->port.line = i;\n\t\tmtpt->port.ops = &multi_pops;\n\t\tinit_timer(&mtpt->timer);\n\t\tmtpt->timer.function = multi_timeout;\n\t\tmp_add_one_port(drv, &mtpt->port);\n\t}\n}\n\n/**\n * pci_remap_base - remap BAR value of pci device\n *\n * PARAMETERS\n *  pcidev  - pci_dev structure address\n *  offset  - BAR offset PCI_BASE_ADDRESS_0 ~ PCI_BASE_ADDRESS_4\n *  address - address to be changed BAR value\n *  size\t- size of address space \n *\n * RETURNS\n *  If this function performs successful, it returns 0. Otherwise, It returns -1.\n */\nstatic int pci_remap_base(struct pci_dev *pcidev, unsigned int offset, \n\t\tunsigned int address, unsigned int size) \n{\n#if 0\n\tstruct resource *root;\n\tunsigned index = (offset - 0x10) >> 2;\n#endif\n\n\tpci_write_config_dword(pcidev, offset, address);\n#if 0\n\troot = pcidev->resource[index].parent;\n\trelease_resource(&pcidev->resource[index]);\n\taddress &= ~0x1;\n\tpcidev->resource[index].start = address;\n\tpcidev->resource[index].end\t  = address + size - 1;\n\n\tif (request_resource(root, &pcidev->resource[index]) != NULL)\n\t{\n\t\tprintk(KERN_ERR \"pci remap conflict!! 0x%x\\n\", address);\n\t\treturn (-1);\n\t}\n#endif\n\n\treturn (0);\n}\n\nstatic int init_mp_dev(struct pci_dev *pcidev, mppcibrd_t brd)\n{\n\tstatic struct mp_device_t *sbdev = mp_devs;\n\tunsigned long addr = 0;\n\tint j;\n\tstruct resource *ret = NULL;\n\n\tsbdev->device_id = brd.device_id;\n\tpci_read_config_byte(pcidev, PCI_CLASS_REVISION, &(sbdev->revision));\n\tsbdev->name = brd.name;\n\tsbdev->uart_access_addr = pcidev->resource[0].start & PCI_BASE_ADDRESS_IO_MASK;\n\n\t/* check revision. The SB16C1053APCI's option i/o address is BAR4 */\n\tif (sbdev->revision == 0xc0)\n\t{\n\t\t/* SB16C1053APCI */\n\t\tsbdev->option_reg_addr = pcidev->resource[4].start & PCI_BASE_ADDRESS_IO_MASK;\n\t}\n\telse\n\t{\n\t\tsbdev->option_reg_addr = pcidev->resource[1].start & PCI_BASE_ADDRESS_IO_MASK;\n\t}\n#if 1\t\n\tif (sbdev->revision == 0xc0)\n\t{\n\t\toutb(0x00, sbdev->option_reg_addr + MP_OPTR_GPOCR);\n\t\tinb(sbdev->option_reg_addr + MP_OPTR_GPOCR);\n\t\toutb(0x83, sbdev->option_reg_addr + MP_OPTR_GPOCR);\n\t}\n#endif\n\n\tsbdev->irq = pcidev->irq;\n\n\tif ((brd.device_id & 0x0800) || !(brd.device_id &0xff00))\n\t{\n\t\tsbdev->poll_type = TYPE_INTERRUPT;\n\t}\n\telse\n\t{\n\t\tsbdev->poll_type = TYPE_POLL;\n\t}\n\n\t/* codes which is specific to each board*/\n\tswitch(brd.device_id){\n\t\tcase PCI_DEVICE_ID_MP1 :\n\t\tcase PCIE_DEVICE_ID_MP1 :\n\t\tcase PCIE_DEVICE_ID_MP1E :\n\t\tcase PCIE_DEVICE_ID_GT_MP1 :\n\t\t\tsbdev->nr_ports = 1;\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_MP2 :\n\t\tcase PCIE_DEVICE_ID_MP2 :\n\t\tcase PCIE_DEVICE_ID_GT_MP2 :\n\t\tcase PCIE_DEVICE_ID_MP2B :\n\t\tcase PCIE_DEVICE_ID_MP2E :\n\t\t\tsbdev->nr_ports = 2;\n\n\t\t\t/* serial base address remap */\n\t\t\tif (sbdev->revision == 0xc0)\n\t\t\t{\n\t\t\t\tint prev_port_addr = 0;\n\n\t\t\t\tpci_read_config_dword(pcidev, PCI_BASE_ADDRESS_0, &prev_port_addr);\n\t\t\t\tpci_remap_base(pcidev, PCI_BASE_ADDRESS_1, prev_port_addr + 8, 8);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_MP4 :\n\t\tcase PCI_DEVICE_ID_MP4A :\n\t\tcase PCIE_DEVICE_ID_MP4 :\n\t\tcase PCI_DEVICE_ID_GT_MP4 :\n\t\tcase PCI_DEVICE_ID_GT_MP4A :\n\t\tcase PCIE_DEVICE_ID_GT_MP4 :\n\t\tcase PCI_DEVICE_ID_MP4M :\n\t\tcase PCIE_DEVICE_ID_MP4B :\n\t\t\tsbdev->nr_ports = 4;\n\n\t\t\tif(sbdev->revision == 0x91){\n\t\t\t\tsbdev->reserved_addr[0] = pcidev->resource[0].start & PCI_BASE_ADDRESS_IO_MASK;\n\t\t\t\toutb(0x03 , sbdev->reserved_addr[0] + 0x01);\n\t\t\t\toutb(0x03 , sbdev->reserved_addr[0] + 0x02);\n\t\t\t\toutb(0x01 , sbdev->reserved_addr[0] + 0x20);\n\t\t\t\toutb(0x00 , sbdev->reserved_addr[0] + 0x21);\n\t\t\t\trequest_region(sbdev->reserved_addr[0], 32, sbdev->name);\n\t\t\t\tsbdev->uart_access_addr = pcidev->resource[1].start & PCI_BASE_ADDRESS_IO_MASK;\n\t\t\t\tsbdev->option_reg_addr = pcidev->resource[2].start & PCI_BASE_ADDRESS_IO_MASK;\n\t\t\t}\n\n\t\t\t/* SB16C1053APCI */\n\t\t\tif (sbdev->revision == 0xc0)\n\t\t\t{\n\t\t\t\tint prev_port_addr = 0;\n\n\t\t\t\tpci_read_config_dword(pcidev, PCI_BASE_ADDRESS_0, &prev_port_addr);\n\t\t\t\tpci_remap_base(pcidev, PCI_BASE_ADDRESS_1, prev_port_addr + 8, 8);\n\t\t\t\tpci_remap_base(pcidev, PCI_BASE_ADDRESS_2, prev_port_addr + 16, 8);\n\t\t\t\tpci_remap_base(pcidev, PCI_BASE_ADDRESS_3, prev_port_addr + 24, 8);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_MP6 :\n\t\tcase PCI_DEVICE_ID_MP6A :\n\t\tcase PCI_DEVICE_ID_GT_MP6 :\n\t\tcase PCI_DEVICE_ID_GT_MP6A :\n\t\t\tsbdev->nr_ports = 6;\n\n\t\t\t/* SB16C1053APCI */\n\t\t\tif (sbdev->revision == 0xc0)\n\t\t\t{\n\t\t\t\tint prev_port_addr = 0;\n\n\t\t\t\tpci_read_config_dword(pcidev, PCI_BASE_ADDRESS_0, &prev_port_addr);\n\t\t\t\tpci_remap_base(pcidev, PCI_BASE_ADDRESS_1, prev_port_addr + 8, 8);\n\t\t\t\tpci_remap_base(pcidev, PCI_BASE_ADDRESS_2, prev_port_addr + 16, 16);\n\t\t\t\tpci_remap_base(pcidev, PCI_BASE_ADDRESS_3, prev_port_addr + 32, 16);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_MP8 :\n\t\tcase PCIE_DEVICE_ID_MP8 :\n\t\tcase PCI_DEVICE_ID_GT_MP8 :\n\t\tcase PCIE_DEVICE_ID_GT_MP8 :\n\t\tcase PCIE_DEVICE_ID_MP8B :\n\t\t\tsbdev->nr_ports = 8;\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_MP32 :\n\t\tcase PCIE_DEVICE_ID_MP32 :\n\t\tcase PCI_DEVICE_ID_GT_MP32 :\n\t\tcase PCIE_DEVICE_ID_GT_MP32 :\n\t\t\t{\n\t\t\t\tint portnum_hex=0;\n\t\t\t\tportnum_hex = inb(sbdev->option_reg_addr);\n\t\t\t\tsbdev->nr_ports = ((portnum_hex/16)*10) + (portnum_hex % 16);\n\t\t\t}\n\t\t\tbreak;\n#ifdef CONFIG_PARPORT_PC\n\t\tcase PCI_DEVICE_ID_MP2S1P :\n\t\t\tsbdev->nr_ports = 2;\n\n\t\t\t/* SB16C1053APCI */\n\t\t\tif (sbdev->revision == 0xc0)\n\t\t\t{\n\t\t\t\tint prev_port_addr = 0;\n\n\t\t\t\tpci_read_config_dword(pcidev, PCI_BASE_ADDRESS_0, &prev_port_addr);\n\t\t\t\tpci_remap_base(pcidev, PCI_BASE_ADDRESS_1, prev_port_addr + 8, 8);\n\t\t\t}\n\n\t\t\t/* add PC compatible parallel port */\n\t\t\tparport_pc_probe_port(pcidev->resource[2].start, pcidev->resource[3].start, PARPORT_IRQ_NONE, PARPORT_DMA_NONE, &pcidev->dev, 0);\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_MP1P :\n\t\t\t/* add PC compatible parallel port */\n\t\t\tparport_pc_probe_port(pcidev->resource[2].start, pcidev->resource[3].start, PARPORT_IRQ_NONE, PARPORT_DMA_NONE, &pcidev->dev, 0);\n\t\t\tbreak;\n#endif\n\t}\n\n\tret = request_region(sbdev->uart_access_addr, (8*sbdev->nr_ports), sbdev->name);\n\n\tif (sbdev->revision == 0xc0)\n\t{\n\t\tret = request_region(sbdev->option_reg_addr, 0x40, sbdev->name);\n\t}\n\telse\n\t{\n\t\tret = request_region(sbdev->option_reg_addr, 0x20, sbdev->name);\n\t}\n\n\n\tNR_BOARD++;\n\tNR_PORTS += sbdev->nr_ports;\n\n\t/* Enable PCI interrupt */\n\taddr = sbdev->option_reg_addr + MP_OPTR_IMR0;\n\tfor(j=0; j < (sbdev->nr_ports/8)+1; j++)\n\t{\n\t\tif (sbdev->poll_type == TYPE_INTERRUPT)\n\t\t{\n\t\t\toutb(0xff,addr +j);\n\t\t}\n\t}\n\tsbdev++;\n\n\treturn 0;\n}\n\nstatic int __init multi_init(void)\n{\n\tint ret, i;\n\tstruct pci_dev  *dev = NULL;\n\n\tif(fcr_count==0)\n\t{\n\t\tfor(i=0;i<256;i++)\n\t\t{\n\t\t\tfcr_arr[i] = 0x01;\n\t\t\t\n\t\t}\n\t}\n\tif(deep_count==0)\n\t{\n\t\tfor(i=0;i<256;i++)\n\t\t{\n\t\t\tdeep[i] = 1;\n\t\t\t\n\t\t}\n\t}\n\tif(rtr_count==0)\n        {\n                for(i=0;i<256;i++)\n                {\n                        rtr[i] = 0x10;\n                }\n        }\n\tif(ttr_count==0)\n        {\n                for(i=0;i<256;i++)\n                {\n                        ttr[i] = 0x38;\n                }\n        }\n\n\nprintk(\"MULTI INIT\\n\");\n\tfor( i=0; i< mp_nrpcibrds; i++)\n\t{\n\n\t\twhile( (dev = pci_get_device(mp_pciboards[i].vendor_id, mp_pciboards[i].device_id, dev) ) )\n\n\t\t{\nprintk(\"FOUND~~~\\n\");\n//\tCent OS bug fix\n//\t\t\tif (mp_pciboards[i].device_id & 0x0800)\n\t\t\t{\n\t\t\t\tint status;\n\t        \t\tpci_disable_device(dev);\n\t        \t\tstatus = pci_enable_device(dev);\n            \n\t   \t\t     \tif (status != 0)\n        \t\t\t{ \n               \t\t\t\tprintk(\"Multiport Board Enable Fail !\\n\\n\");\n               \t\t\t\tstatus = -ENXIO;\n                \t\t\treturn status;\n           \t\t\t}\n\t\t\t}\n\n\t\t\tinit_mp_dev(dev, mp_pciboards[i]);\t\n\t\t}\n\t}\n\n\tfor (i = 0; i < NR_IRQS; i++)\n\t\tspin_lock_init(&irq_lists[i].lock);\n\n\tret = mp_register_driver(&multi_reg);\n\n\tif (ret >= 0)\n\t\tmulti_register_ports(&multi_reg);\n\n\treturn ret;\n}\n\nstatic void __exit multi_exit(void)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_PORTS; i++)\n\t\tmp_remove_one_port(&multi_reg, &multi_ports[i].port);\n\n\tmp_unregister_driver(&multi_reg);\n}\n\nmodule_init(multi_init);\nmodule_exit(multi_exit);\n\nMODULE_DESCRIPTION(\"SystemBase Multiport PCI/PCIe CORE\");\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["drivers/staging/sb105x/sb_pci_mp.c"], "buggy_code_start_loc": [1066], "buggy_code_end_loc": [1067], "fixing_code_start_loc": [1066], "fixing_code_end_loc": [1067], "type": "CWE-200", "message": "The mp_get_count function in drivers/staging/sb105x/sb_pci_mp.c in the Linux kernel before 3.12 does not initialize a certain data structure, which allows local users to obtain sensitive information from kernel stack memory via a TIOCGICOUNT ioctl call.", "other": {"cve": {"id": "CVE-2013-4516", "sourceIdentifier": "secalert@redhat.com", "published": "2013-11-12T14:35:12.540", "lastModified": "2023-02-13T00:28:58.263", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The mp_get_count function in drivers/staging/sb105x/sb_pci_mp.c in the Linux kernel before 3.12 does not initialize a certain data structure, which allows local users to obtain sensitive information from kernel stack memory via a TIOCGICOUNT ioctl call."}, {"lang": "es", "value": "La funci\u00f3n mp_get_count de drivers/staging/sb105x/sb_pci_mp.c en el kernel de Linux anterior a la versi\u00f3n 3.12 no inicializa una estructura de datos determinada, lo que permite a usuarios locales obtener informaci\u00f3n sensible desde la memoria de pila del kernel a trav\u00e9s de una llamada TIOCGICOUNT ioctl."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.11.7", "matchCriteriaId": "74676759-D357-4224-9C07-7FCAB195A0CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "D30AEC07-3CBD-4F4F-9646-BEAA1D98750B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "C2AA8E68-691B-499C-AEDD-3C0BFFE70044"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "9440475B-5960-4066-A204-F30AAFC87846"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "53BCFBFB-6AF0-4525-8623-7633CC5E17DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc5:*:*:*:*:*:*", "matchCriteriaId": "6ED4E86A-74F0-436A-BEB4-3F4EE93A5421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc6:*:*:*:*:*:*", "matchCriteriaId": "BF0365B0-8E16-4F30-BD92-5DD538CC8135"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc7:*:*:*:*:*:*", "matchCriteriaId": "079505E8-2942-4C33-93D1-35ADA4C39E72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "38989541-2360-4E0A-AE5A-3D6144AA6114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "4E51646B-7A0E-40F3-B8C9-239C1DA81DD1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "42A8A507-F8E2-491C-A144-B2448A1DB26E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "901FC6F3-2C2A-4112-AE27-AB102BBE8DEE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "203AD334-DB9F-41B0-A4D1-A6C158EF8C40"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "B3611753-E440-410F-8250-600C996A4B8E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "9739BB47-EEAF-42F1-A557-2AE2EA9526A3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "5A95E3BB-0AFC-4C2E-B9BE-C975E902A266"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "482A6C9A-9B8E-4D1C-917A-F16370745E7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "C6D87357-63E0-41D0-9F02-1BCBF9A77E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "3765A2D6-2D78-4FB1-989E-D5106BFA3F5E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "F54257DB-7023-43C4-AC4D-9590B815CD92"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.13:*:*:*:*:*:*:*", "matchCriteriaId": "61FF5FCD-A4A1-4803-AC53-320A4C838AF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.14:*:*:*:*:*:*:*", "matchCriteriaId": "9F096553-064F-46A2-877B-F32F163A0F49"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.15:*:*:*:*:*:*:*", "matchCriteriaId": "C0D762D1-E3AD-40EA-8D39-83EEB51B5E85"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.16:*:*:*:*:*:*:*", "matchCriteriaId": "A6187D19-7148-4B87-AD7E-244FF9EE0FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.17:*:*:*:*:*:*:*", "matchCriteriaId": "99AC64C2-E391-485C-9CD7-BA09C8FA5E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.18:*:*:*:*:*:*:*", "matchCriteriaId": "8CDA5E95-7805-441B-BEF7-4448EA45E964"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.19:*:*:*:*:*:*:*", "matchCriteriaId": "51561053-6C28-4F38-BC9B-3F7A7508EB72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.20:*:*:*:*:*:*:*", "matchCriteriaId": "118F4A5B-C498-4FC3-BE28-50D18EBE4F22"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.21:*:*:*:*:*:*:*", "matchCriteriaId": "BD38EBE6-FE1A-4B55-9FB5-07952253B7A5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.22:*:*:*:*:*:*:*", "matchCriteriaId": "3A491E47-82AD-4055-9444-2EC0D6715326"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.23:*:*:*:*:*:*:*", "matchCriteriaId": "13C5FD16-23B6-467F-9438-5B554922F974"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.24:*:*:*:*:*:*:*", "matchCriteriaId": "9C67235F-5B51-4BF7-89EC-4810F720246F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.25:*:*:*:*:*:*:*", "matchCriteriaId": "08405DEF-05F4-45F0-AC95-DBF914A36D93"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.26:*:*:*:*:*:*:*", "matchCriteriaId": "1A7B9C4B-4A41-4175-9F07-191C1EE98C1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.27:*:*:*:*:*:*:*", "matchCriteriaId": "B306E0A8-4D4A-4895-8128-A500D30A7E0C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.28:*:*:*:*:*:*:*", "matchCriteriaId": "295C839A-F34E-4853-A926-55EABC639412"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.29:*:*:*:*:*:*:*", "matchCriteriaId": "2AFD5F49-7EF9-4CFE-95BD-8FD19B500B0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.30:*:*:*:*:*:*:*", "matchCriteriaId": "00B3DDDD-B2F6-4753-BA38-65A24017857D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.31:*:*:*:*:*:*:*", "matchCriteriaId": "33FCD39E-F4BF-432D-9CF9-F195CF5844F3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.32:*:*:*:*:*:*:*", "matchCriteriaId": "C7308690-CB0D-4758-B80F-D2ADCD2A9D66"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.33:*:*:*:*:*:*:*", "matchCriteriaId": "313A470B-8A2B-478A-82B5-B27D2718331C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.34:*:*:*:*:*:*:*", "matchCriteriaId": "83FF021E-07E3-41CC-AAE8-D99D7FF24B9D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.35:*:*:*:*:*:*:*", "matchCriteriaId": "F72412E3-8DA9-4CC9-A426-B534202ADBA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.36:*:*:*:*:*:*:*", "matchCriteriaId": "FCAA9D7A-3C3E-4C0B-9D38-EA80E68C2E46"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.37:*:*:*:*:*:*:*", "matchCriteriaId": "4A9E3AE5-3FCF-4CBB-A30B-082BCFBFB0CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.38:*:*:*:*:*:*:*", "matchCriteriaId": "CF715657-4C3A-4392-B85D-1BBF4DE45D89"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.39:*:*:*:*:*:*:*", "matchCriteriaId": "4B63C618-AC3D-4EF7-AFDF-27B9BF482B78"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.40:*:*:*:*:*:*:*", "matchCriteriaId": "C33DA5A9-5E40-4365-9602-82FB4DCD15B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.41:*:*:*:*:*:*:*", "matchCriteriaId": "EFAFDB74-40BD-46FA-89AC-617EB2C7160B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.42:*:*:*:*:*:*:*", "matchCriteriaId": "CF5F17DA-30A7-40CF-BD7C-CEDF06D64617"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.43:*:*:*:*:*:*:*", "matchCriteriaId": "71A276F5-BD9D-4C1B-90DF-9B0C15B6F7DF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.44:*:*:*:*:*:*:*", "matchCriteriaId": "F8F6EBEC-3C29-444B-BB85-6EF239B59EC1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.45:*:*:*:*:*:*:*", "matchCriteriaId": "FDB91302-FD18-44CF-A8A8-B31483328539"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.46:*:*:*:*:*:*:*", "matchCriteriaId": "9B81DC2B-46FA-4640-AD6C-2A404D94BA0B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.47:*:*:*:*:*:*:*", "matchCriteriaId": "BA6A1663-BC4C-4FC9-B5EB-A52EDED17B26"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.48:*:*:*:*:*:*:*", "matchCriteriaId": "69C33D6C-6B9F-49F4-B505-E7B589CDEC50"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.49:*:*:*:*:*:*:*", "matchCriteriaId": "C464796B-2F31-4159-A132-82A0C74137B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.50:*:*:*:*:*:*:*", "matchCriteriaId": "1D6C6E46-FE29-4D2D-A0EC-43DA5112BCC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.51:*:*:*:*:*:*:*", "matchCriteriaId": "1A370E91-73A1-4D62-8E7B-696B920203F8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.52:*:*:*:*:*:*:*", "matchCriteriaId": "340197CD-9645-4B7E-B976-F3F5A7D4C5BE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.53:*:*:*:*:*:*:*", "matchCriteriaId": "96030636-0C4A-4A10-B768-525D6A0E18CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.54:*:*:*:*:*:*:*", "matchCriteriaId": "A42D8419-914F-4AD6-B0E9-C1290D514FF1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.55:*:*:*:*:*:*:*", "matchCriteriaId": "F4E2C88B-42EA-4F4F-B1F6-A9332EC6888B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.56:*:*:*:*:*:*:*", "matchCriteriaId": "2449D13B-3314-4182-832F-03F6B11AA31F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.57:*:*:*:*:*:*:*", "matchCriteriaId": "9A35B66C-F050-4462-A58E-FEE061B5582E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.58:*:*:*:*:*:*:*", "matchCriteriaId": "1B551164-0167-49BB-A3AE-4034BDA3DCB4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.59:*:*:*:*:*:*:*", "matchCriteriaId": "7244278E-49B6-4405-A14C-F3540C8F5AF8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.60:*:*:*:*:*:*:*", "matchCriteriaId": "B4C3E4B8-7274-4ABB-B7CE-6A39C183CE18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.61:*:*:*:*:*:*:*", "matchCriteriaId": "6501EDB9-4847-47F8-90EE-B295626E4CDC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.62:*:*:*:*:*:*:*", "matchCriteriaId": "2D676D48-7521-45E2-8563-6B966FF86A35"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.63:*:*:*:*:*:*:*", "matchCriteriaId": "3B69FA17-0AB9-4986-A5A7-2A4C1DD24222"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.64:*:*:*:*:*:*:*", "matchCriteriaId": "7BC35593-96C7-41F0-B738-1568F8129121"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.65:*:*:*:*:*:*:*", "matchCriteriaId": "38D23794-0E7C-4FA5-A7A8-CF940E3FA962"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.66:*:*:*:*:*:*:*", "matchCriteriaId": "008E1E7D-4C20-4560-9288-EF532ADB0029"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.67:*:*:*:*:*:*:*", "matchCriteriaId": "3B3A7044-A92E-47A9-A7BD-35E5B575F5FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.68:*:*:*:*:*:*:*", "matchCriteriaId": "783E2980-B6AB-489E-B157-B6A2E10A32CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:*:*:*:*:*:*:*", "matchCriteriaId": "3DFFE5A6-6A67-4992-84A3-C0F05FACDEAD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc1:*:*:*:*:*:*", "matchCriteriaId": "13BBD2A3-AE10-48B9-8776-4FB1CAC37D44"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc2:*:*:*:*:*:*", "matchCriteriaId": "B25680CC-8918-4F27-8D7E-A6579215450B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc3:*:*:*:*:*:*", "matchCriteriaId": "92C48B4C-410C-4BA8-A28A-B2E928320FCC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc4:*:*:*:*:*:*", "matchCriteriaId": "CB447523-855B-461E-8197-95169BE86EB0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "B155BBDF-6DF6-4FF5-9C41-D8A5266DCC67"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "28476DEC-9630-4B40-9D4D-9BC151DC4CA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "5646880A-2355-4BDD-89E7-825863A0311F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "7FF99148-267A-46F8-9927-A9082269BAF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "A783C083-5D9C-48F9-B5A6-A97A9604FB19"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "2B817A24-03AC-46CD-BEFA-505457FD2A5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.7:*:*:*:*:*:*:*", "matchCriteriaId": "51CF1BCE-090E-4B70-BA16-ACB74411293B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "187AAD67-10D7-4B57-B4C6-00443E246AF3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.9:*:*:*:*:*:*:*", "matchCriteriaId": "F341CE88-C5BC-4CDD-9CB5-B6BAD7152E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.10:*:*:*:*:*:*:*", "matchCriteriaId": "37ACE2A6-C229-4236-8E9F-235F008F3AA0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:*:*:*:*:*:*:*", "matchCriteriaId": "D3220B70-917F-4F9F-8A3B-2BF581281E8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:*:*:*:*:*:x86:*", "matchCriteriaId": "7D47A395-821D-4BFF-996E-E849D9A40217"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc2:*:*:*:*:*:*", "matchCriteriaId": "99372D07-C06A-41FA-9843-6D57F99AB5AF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc3:*:*:*:*:*:*", "matchCriteriaId": "2B9DC110-D260-4DB4-B8B0-EF1D160ADA07"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc4:*:*:*:*:*:*", "matchCriteriaId": "6192FE84-4D53-40D4-AF61-78CE7136141A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc5:*:*:*:*:*:*", "matchCriteriaId": "42FEF3CF-1302-45EB-89CC-3786FE4BAC1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc6:*:*:*:*:*:*", "matchCriteriaId": "AE6A6B58-2C89-4DE4-BA57-78100818095C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc7:*:*:*:*:*:*", "matchCriteriaId": "1D467F87-2F13-4D26-9A93-E0BA526FEA24"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "FE348F7B-02DE-47D5-8011-F83DA9426021"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.1:*:*:*:*:*:x86:*", "matchCriteriaId": "8A603291-33B4-4195-B52D-D2A9938089C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "E91594EA-F0A3-41B3-A9C6-F7864FC2F229"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "9E1ECCDB-0208-48F6-B44F-16CC0ECE3503"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "FBA8B5DE-372E-47E0-A0F6-BE286D509CC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "9A1CA083-2CF8-45AE-9E15-1AA3A8352E3B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "19D69A49-5290-4C5F-8157-719AD58D253D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "290BD969-42E7-47B0-B21B-06DE4865432C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.8:*:*:*:*:*:*:*", "matchCriteriaId": "23A9E29E-DE78-4C73-9FBD-C2410F5FC8B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.9:*:*:*:*:*:*:*", "matchCriteriaId": "018434C9-E75F-45CB-A169-DAB4B1D864D7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.10:*:*:*:*:*:*:*", "matchCriteriaId": "DC0AC68F-EC58-4C4F-8CBC-A59ECC00CCDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.11:*:*:*:*:*:*:*", "matchCriteriaId": "C123C844-F6D7-471E-A62E-F756042FB1CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.12:*:*:*:*:*:*:*", "matchCriteriaId": "A11C38BB-7FA2-49B0-AAC9-83DB387A06DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.13:*:*:*:*:*:*:*", "matchCriteriaId": "61F3733C-E5F6-4855-B471-DF3FB823613B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.14:*:*:*:*:*:*:*", "matchCriteriaId": "1DDCA75F-9A06-4457-9A45-38A38E7F7086"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.15:*:*:*:*:*:*:*", "matchCriteriaId": "7AEA837E-7864-4003-8DB7-111ED710A7E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.16:*:*:*:*:*:*:*", "matchCriteriaId": "B6FE471F-2D1F-4A1D-A197-7E46B75787E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.17:*:*:*:*:*:*:*", "matchCriteriaId": "FDA9E6AB-58DC-4EC5-A25C-11F9D0B38BF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.18:*:*:*:*:*:*:*", "matchCriteriaId": "DC6B8DB3-B05B-41A2-B091-342D66AAE8F5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.19:*:*:*:*:*:*:*", "matchCriteriaId": "958F0FF8-33EF-4A71-A0BD-572C85211DBA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.20:*:*:*:*:*:*:*", "matchCriteriaId": "FBA39F48-B02F-4C48-B304-DA9CCA055244"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.21:*:*:*:*:*:*:*", "matchCriteriaId": "1FF841F3-48A7-41D7-9C45-A8170435A5EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.22:*:*:*:*:*:*:*", "matchCriteriaId": "EF506916-A6DC-4B1E-90E5-959492AF55F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.23:*:*:*:*:*:*:*", "matchCriteriaId": "B3CDAD1F-2C6A-48C0-8FAB-C2659373FA25"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.24:*:*:*:*:*:*:*", "matchCriteriaId": "4FFE4B22-C96A-43D0-B993-F51EDD9C5E0E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.25:*:*:*:*:*:*:*", "matchCriteriaId": "F571CC8B-B212-4553-B463-1DB01D616E8A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.26:*:*:*:*:*:*:*", "matchCriteriaId": "84E3E151-D437-48ED-A529-731EEFF88567"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.27:*:*:*:*:*:*:*", "matchCriteriaId": "E9E3EA3C-CCA5-4433-86E0-3D02C4757A0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.28:*:*:*:*:*:*:*", "matchCriteriaId": "F7AC4F7D-9FA6-4CF1-B2E9-70BF7D4D177C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.29:*:*:*:*:*:*:*", "matchCriteriaId": "3CE3A80D-9648-43CC-8F99-D741ED6552BF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.30:*:*:*:*:*:*:*", "matchCriteriaId": "C8A98C03-A465-41B4-A551-A26FEC7FFD94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:*:*:*:*:*:*:*", "matchCriteriaId": "AFB76697-1C2F-48C0-9B14-517EC053D4B3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc1:*:*:*:*:*:*", "matchCriteriaId": "BED88DFD-1DC5-4505-A441-44ECDEF0252D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc2:*:*:*:*:*:*", "matchCriteriaId": "DBFD2ACD-728A-4082-BB6A-A1EF6E58E47D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc3:*:*:*:*:*:*", "matchCriteriaId": "C31B0E51-F62D-4053-B04F-FC4D5BC373D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc4:*:*:*:*:*:*", "matchCriteriaId": "A914303E-1CB6-4AAD-9F5F-DE5433C4E814"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc5:*:*:*:*:*:*", "matchCriteriaId": "203BBA69-90B2-4C5E-8023-C14180742421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc6:*:*:*:*:*:*", "matchCriteriaId": "0DBFAB53-B889-4028-AC0E-7E165B152A18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc7:*:*:*:*:*:*", "matchCriteriaId": "FE409AEC-F677-4DEF-8EB7-2C35809043CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "578EC12B-402F-4AD4-B8F8-C9B2CAB06891"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "877002ED-8097-4BB4-BB88-6FC6306C38B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "76294CE3-D72C-41D5-9E0F-B693D0042699"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "916E97D4-1FAB-42F5-826B-653B1C0909A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.5:*:*:*:*:*:*:*", "matchCriteriaId": "33FD2217-C5D0-48C1-AD74-3527127FEF9C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.6:*:*:*:*:*:*:*", "matchCriteriaId": "2E92971F-B629-4E0A-9A50-8B235F9704B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.7:*:*:*:*:*:*:*", "matchCriteriaId": "EDD3A069-3829-4EE2-9D5A-29459F29D4C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.8:*:*:*:*:*:*:*", "matchCriteriaId": "A4A0964C-CEB2-41D7-A69C-1599B05B6171"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:*:*:*:*:*:*:*", "matchCriteriaId": "0F960FA6-F904-4A4E-B483-44C70090E9A1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:*:*:*:*:*:x86:*", "matchCriteriaId": "8C3D9C66-933A-469E-9073-75015A8AD17D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc1:*:*:*:*:*:*", "matchCriteriaId": "261C1B41-C9E0-414F-8368-51C0C0B8AD38"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc1:*:*:*:*:x86:*", "matchCriteriaId": "C92F29A0-DEFF-49E4-AE86-5DBDAD51C677"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc2:*:*:*:*:*:*", "matchCriteriaId": "5CCA261D-2B97-492F-89A0-5F209A804350"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc2:*:*:*:*:x86:*", "matchCriteriaId": "5690A703-390D-4D8A-9258-2F47116DAB4F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc3:*:*:*:*:*:*", "matchCriteriaId": "1B1C0C68-9194-473F-BE5E-EC7F184899FA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc3:*:*:*:*:x86:*", "matchCriteriaId": "AB1EDDA7-15AF-4B45-A931-DFCBB1EEB701"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc4:*:*:*:*:*:*", "matchCriteriaId": "D7A6AC9E-BEA6-44B0-B3B3-F0F94E32424A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc4:*:*:*:*:x86:*", "matchCriteriaId": "952FE0DC-B2ED-4080-BF29-A2C265E83FEF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc5:*:*:*:*:*:*", "matchCriteriaId": "16038328-9399-4B85-B777-BA4757D02C9B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc5:*:*:*:*:x86:*", "matchCriteriaId": "1CE7ABDB-6572-40E8-B952-CBE52C999858"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc6:*:*:*:*:*:*", "matchCriteriaId": "16CA2757-FA8D-43D9-96E8-D3C0EB6E1DEF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc6:*:*:*:*:x86:*", "matchCriteriaId": "0F417186-D1ED-4A31-92B2-83DEDA1AF272"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc7:*:*:*:*:*:*", "matchCriteriaId": "E8CB5481-5EAE-401E-BD7E-D3095CCA9E94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc7:*:*:*:*:x86:*", "matchCriteriaId": "3D4FCFAE-918C-4886-9A17-08A5B94D35F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "A0F36FAC-141D-476D-84C5-A558C199F904"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.1:*:*:*:*:*:x86:*", "matchCriteriaId": "830D2914-C9FE-406F-AFCE-7A04BB9E2896"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "51D64824-25F6-4761-BD6A-29038A143744"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.2:*:*:*:*:*:x86:*", "matchCriteriaId": "F4B791B5-2EB5-403A-90CC-B219F6277D1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "E284C8A1-740F-454D-A774-99CD3A21B594"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.3:*:*:*:*:*:x86:*", "matchCriteriaId": "2BA5F34D-7490-4B2B-A7E6-8450F9C1FC31"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "C70D72AE-0CBF-4324-9935-57E28EC6279C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.4:*:*:*:*:*:x86:*", "matchCriteriaId": "B803FE64-FC8D-4650-9FB9-FEEED4340416"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "F674B06B-7E86-4E41-9126-8152D0DDABAE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.5:*:*:*:*:*:x86:*", "matchCriteriaId": "4C560A9A-2388-4980-9E88-118C5EB806B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "7039B3EC-8B22-413E-B582-B4BEC6181241"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "35CF1DD2-80B9-4476-8963-5C3EF52B33F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "BFB0B05B-A5CE-4B9C-AE7F-83062868D35B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.9:*:*:*:*:*:*:*", "matchCriteriaId": "D166A66E-7454-47EC-BB56-861A9AFEAFE1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.10:*:*:*:*:*:*:*", "matchCriteriaId": "7DA94F50-2A62-4300-BF4D-A342AAE35629"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.11:*:*:*:*:*:*:*", "matchCriteriaId": "252D937B-50DC-444F-AE73-5FCF6203DF27"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.12:*:*:*:*:*:*:*", "matchCriteriaId": "F6D8EE51-02C1-47BC-A92C-0A8ABEFD28FF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.13:*:*:*:*:*:*:*", "matchCriteriaId": "7F20A5D7-3B38-4911-861A-04C8310D5916"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.14:*:*:*:*:*:*:*", "matchCriteriaId": "D472DE3A-71D8-4F40-9DDE-85929A2B047D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.15:*:*:*:*:*:*:*", "matchCriteriaId": "B2AED943-65A8-4FDB-BBD0-CCEF8682A48C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.16:*:*:*:*:*:*:*", "matchCriteriaId": "D4640185-F3D8-4575-A71D-4C889A93DE2C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.17:*:*:*:*:*:*:*", "matchCriteriaId": "144CCF7C-025E-4879-B2E7-ABB8E4390BE5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.18:*:*:*:*:*:*:*", "matchCriteriaId": "B6FAA052-0B2B-40CE-8C98-919B8D08A5ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.19:*:*:*:*:*:*:*", "matchCriteriaId": "4B5A53DE-9C83-4A6B-96F3-23C03BF445D9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.20:*:*:*:*:*:*:*", "matchCriteriaId": "063EB879-CB05-4E33-AA90-9E43516839B5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.21:*:*:*:*:*:*:*", "matchCriteriaId": "2D25764F-4B02-4C65-954E-8C7D6632DE00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.22:*:*:*:*:*:*:*", "matchCriteriaId": "F31F5BF3-CD0A-465C-857F-273841BCD28A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.23:*:*:*:*:*:*:*", "matchCriteriaId": "FF302C8A-079B-42B9-B455-CD9083BFA067"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.24:*:*:*:*:*:*:*", "matchCriteriaId": "744999C0-33D3-4363-B3DB-E0D02CDD3918"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.25:*:*:*:*:*:*:*", "matchCriteriaId": "C2E77A76-2A60-45D8-9337-867BC22C5110"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.26:*:*:*:*:*:*:*", "matchCriteriaId": "C9F4AAE7-C870-46B7-B559-2949737BE777"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.27:*:*:*:*:*:*:*", "matchCriteriaId": "20FA2824-20B0-48B8-BB0A-4904C1D3E8AA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.28:*:*:*:*:*:*:*", "matchCriteriaId": "9F9B347E-61AC-419F-9701-B862BBFA46F2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.29:*:*:*:*:*:*:*", "matchCriteriaId": "989F351C-8B7C-4C1B-AFA2-AE9431576368"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.30:*:*:*:*:*:*:*", "matchCriteriaId": "8D22172A-9FA7-42E0-8451-165D8E47A573"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.31:*:*:*:*:*:*:*", "matchCriteriaId": "CE31624C-94F9-45D8-9B4A-D0028F10602F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.32:*:*:*:*:*:*:*", "matchCriteriaId": "70967A83-28F6-4568-9ADA-6EF232E5BBC2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "962B0C45-AB29-4383-AC16-C6E8245D0FF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "A0EE126B-74B2-4F79-BFE1-3DC169F3F9B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "392075E0-A9C7-4B4A-90F9-7F1ADFF5EFA7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "ECC66968-06F0-4874-A95A-A292C36E45C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "5FE986E6-1068-4E1B-8EAB-DF1EAF32B4E3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.6:*:*:*:*:*:*:*", "matchCriteriaId": "543E8536-1A8E-4E76-B89F-1B1F9F26FAB8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.7:*:*:*:*:*:*:*", "matchCriteriaId": "EC2B45E3-31E1-4B46-85FA-3A84E75B8F84"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6:*:*:*:*:*:*:*", "matchCriteriaId": "DDB8CC75-D3EE-417C-A83D-CB6D666FE595"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "09A072F1-7BEE-4236-ACBB-55DB8FEF4A03"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "E19D5A58-17D6-4502-A57A-70B2F84817A4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "D58BA035-1204-4DFA-98A1-12111FB6222E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.4:*:*:*:*:*:*:*", "matchCriteriaId": "A17F2E87-8EB8-476A-B5B5-9AE5CF53D9FE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.5:*:*:*:*:*:*:*", "matchCriteriaId": "A8CCC101-5852-4299-9B67-EA1B149D58C0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.6:*:*:*:*:*:*:*", "matchCriteriaId": "B8074D32-C252-4AD3-A579-1C5EDDD7014B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.7:*:*:*:*:*:*:*", "matchCriteriaId": "962AA802-8179-4606-AAC0-9363BAEABC9F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.8:*:*:*:*:*:*:*", "matchCriteriaId": "1286C858-D5A2-45F3-86D1-E50FE53FB23C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.9:*:*:*:*:*:*:*", "matchCriteriaId": "5AC4A13E-F560-4D01-98A3-E2A2B82EB25B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.10:*:*:*:*:*:*:*", "matchCriteriaId": "942C462A-5398-4BB9-A792-598682E1FEF2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.11:*:*:*:*:*:*:*", "matchCriteriaId": "B852F7E0-0282-483D-BB4D-18CB7A4F1392"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7:*:*:*:*:*:*:*", "matchCriteriaId": "53ED9A31-99CC-41C8-8B72-5B2A9B49AA6C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "EFD646BC-62F7-47CF-B0BE-768F701F7D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "F43D418E-87C1-4C83-9FF1-4F45B4F452DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.3:*:*:*:*:*:*:*", "matchCriteriaId": "680D0E00-F29A-487C-8770-8E7EAC672B7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.4:*:*:*:*:*:*:*", "matchCriteriaId": "2DCA96A4-A836-4E94-A39C-3AD3EA1D9611"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.5:*:*:*:*:*:*:*", "matchCriteriaId": "753C05E3-B603-4E36-B9BA-FAEDCBF62A7D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.6:*:*:*:*:*:*:*", "matchCriteriaId": "E385C2E0-B9F1-4564-8E6D-56FD9E762405"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.7:*:*:*:*:*:*:*", "matchCriteriaId": "041335D4-05E1-4004-9381-28AAD5994B47"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.8:*:*:*:*:*:*:*", "matchCriteriaId": "370F2AE5-3DBC-46B9-AC70-F052C9229C00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.9:*:*:*:*:*:*:*", "matchCriteriaId": "7A971BE3-259D-4494-BBC5-12793D92DB57"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.10:*:*:*:*:*:*:*", "matchCriteriaId": "8E4719A6-FDEA-4714-A830-E23A52AE90BC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "1A6E41FB-38CE-49F2-B796-9A5AA648E73F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "93523FE1-5993-46CB-9299-7C8C1A04E873"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "27ADC356-6BE9-43A3-9E0B-393DC4B1559A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.3:*:*:*:*:*:*:*", "matchCriteriaId": "4F543D23-1774-4D14-A7D1-AD49EDEA94DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.4:*:*:*:*:*:*:*", "matchCriteriaId": "FC323F58-CA00-4C3C-BA4D-CC2C0A6E5F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "FEA0B2E3-668D-40ED-9D3D-709EB6449F8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "3431B258-4EC8-4E7F-87BB-4D934880601E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.7:*:*:*:*:*:*:*", "matchCriteriaId": "1B09FA1E-8B28-4F2A-BA7E-8E1C40365970"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.8:*:*:*:*:*:*:*", "matchCriteriaId": "91917120-9D68-41C0-8B5D-85C256BC6200"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.9:*:*:*:*:*:*:*", "matchCriteriaId": "AAD268A0-096C-4C31-BEC5-D47F5149D462"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.10:*:*:*:*:*:*:*", "matchCriteriaId": "32BD2427-C47F-4660-A1D9-448E500EF5B9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.11:*:*:*:*:*:*:*", "matchCriteriaId": "02048CE5-81C7-4DFB-BC40-CE4C86B7E022"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.12:*:*:*:*:*:*:*", "matchCriteriaId": "934D2B37-0575-4A75-B00B-0028316D6DF0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.13:*:*:*:*:*:*:*", "matchCriteriaId": "06754C21-995C-4850-A4DC-F21826C0F8C5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc1:*:*:*:*:*:*", "matchCriteriaId": "42633FF9-FB0C-4095-B4A1-8D623A98683B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc2:*:*:*:*:*:*", "matchCriteriaId": "08C04619-89A2-4B15-82A2-48BCC662C1F1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc3:*:*:*:*:*:*", "matchCriteriaId": "5B039196-7159-476C-876A-C61242CC41DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc4:*:*:*:*:*:*", "matchCriteriaId": "3A9E0457-53C9-44DD-ACFB-31EE1D1E060E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc5:*:*:*:*:*:*", "matchCriteriaId": "BEE406E7-87BA-44BA-BF61-673E6CC44A2F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc6:*:*:*:*:*:*", "matchCriteriaId": "29FBA173-658F-45DC-8205-934CACD67166"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc7:*:*:*:*:*:*", "matchCriteriaId": "139700F0-BA32-40CF-B9DF-C9C450384FDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "E578085C-3968-4543-BEBA-EE3C3CB4FA02"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "4DCFA441-68FB-4559-A245-FF0B79DE43CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "8C2508D8-6571-4B81-A0D7-E494CCD039CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "8B516926-5E86-4C0A-85F3-F64E1FCDA249"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "069D774D-79BE-479F-BF4E-F021AD808114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.5:*:*:*:*:*:*:*", "matchCriteriaId": "D15B27A9-46E0-4DDF-A00C-29F8F1F18D73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.6:*:*:*:*:*:*:*", "matchCriteriaId": "A381BB4A-28B4-4672-87EE-91B3DDD6C71A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.7:*:*:*:*:*:*:*", "matchCriteriaId": "922F80CF-937D-4FA2-AFF2-6E47FFE9E1E9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.8:*:*:*:*:*:*:*", "matchCriteriaId": "A548ADF4-9E3B-407C-A5ED-05150EB3A185"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.9:*:*:*:*:*:*:*", "matchCriteriaId": "9C623230-4497-41B9-9BD2-7A6CFDD77983"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.10:*:*:*:*:*:*:*", "matchCriteriaId": "C72FA8A6-60A6-4486-A245-7BEF8B2A2711"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.11:*:*:*:*:*:*:*", "matchCriteriaId": "0A498D90-BB99-405E-9FA6-1FBFE179787E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.0:*:*:*:*:*:arm64:*", "matchCriteriaId": "C8409226-20A1-4549-9E11-6D0C3C38DCCE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "D0D32776-8ADB-4E79-846A-C0C99FED19E0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.2:*:*:*:*:*:*:*", "matchCriteriaId": "B7D01673-D13F-487F-81B6-1279C187277E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.3:*:*:*:*:*:*:*", "matchCriteriaId": "ADB27A3E-78E4-40F7-9716-A1099B0D85FB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.4:*:*:*:*:*:*:*", "matchCriteriaId": "16E7136A-A8A6-4BF5-AF5D-AFB5C7A10712"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.5:*:*:*:*:*:*:*", "matchCriteriaId": "6FE127AC-E61D-427A-B998-D60DF5AABA21"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.6:*:*:*:*:*:*:*", "matchCriteriaId": "3819FF99-AEC5-4466-8542-D395419E4308"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.7:*:*:*:*:*:*:*", "matchCriteriaId": "E621FA1A-464B-4D2A-A0D6-EDA475A3709B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.8:*:*:*:*:*:*:*", "matchCriteriaId": "B760B422-EA11-43AB-B6D2-CA54E7229663"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.9:*:*:*:*:*:*:*", "matchCriteriaId": "D2CA7BBC-917C-4F31-A442-465C30444836"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.10:*:*:*:*:*:*:*", "matchCriteriaId": "AE778000-4FD5-4032-86CE-5930EF4CB7C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.11:*:*:*:*:*:*:*", "matchCriteriaId": "B3344EEB-F037-48FE-81DC-67F6384F7D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.12:*:*:*:*:*:*:*", "matchCriteriaId": "0244B0CA-9C67-4F06-BFBA-1F257112AC08"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.13:*:*:*:*:*:*:*", "matchCriteriaId": "2148C13F-4BB0-4D46-A688-F7C726D12497"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.14:*:*:*:*:*:*:*", "matchCriteriaId": "9871AF57-9158-4A41-8340-596B4463289A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.15:*:*:*:*:*:*:*", "matchCriteriaId": "2A875207-DF01-4240-8895-49B62693D27B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.16:*:*:*:*:*:*:*", "matchCriteriaId": "FE04A172-6F3B-4E3B-8D4D-564740FABAAF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.17:*:*:*:*:*:*:*", "matchCriteriaId": "CFEEF8C4-7DC2-4230-B58C-337F39A4DFAF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.18:*:*:*:*:*:*:*", "matchCriteriaId": "9F74DB5C-5096-438C-8C8A-6D337A2FD06A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11:*:*:*:*:*:*:*", "matchCriteriaId": "639E3A57-A9E7-40E6-8929-81CCC0060EFB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.1:*:*:*:*:*:*:*", "matchCriteriaId": "07012ADD-F521-40A8-B067-E87C2238A3D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.2:*:*:*:*:*:*:*", "matchCriteriaId": "3F5FF393-3F89-4274-B82B-F671358072ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.3:*:*:*:*:*:*:*", "matchCriteriaId": "E348698F-54D1-4F5E-B701-CFAF50881E0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.4:*:*:*:*:*:*:*", "matchCriteriaId": "932205D9-3514-4289-9B55-C7A169276930"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.5:*:*:*:*:*:*:*", "matchCriteriaId": "2ECB2D33-F517-480F-8A6F-99D9D6C49596"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.6:*:*:*:*:*:*:*", "matchCriteriaId": "D16F68DD-E2D4-4AA4-AB81-3796C2947E37"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=a8b33654b1e3b0c74d4a1fed041c9aae50b3c427", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2013/11/04/22", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2069-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2070-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2073-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2075-1", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/a8b33654b1e3b0c74d4a1fed041c9aae50b3c427", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}, {"url": "https://www.kernel.org/pub/linux/kernel/v3.x/patch-3.12.bz2", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/a8b33654b1e3b0c74d4a1fed041c9aae50b3c427"}}