{"buggy_code": ["apiVersion: v1\nkind: AppConfig\nspec:\n  server:\n    bind:\n      host: 0.0.0.0\n      port: 80\n    ssl:\n      enable: false\n      certificate:\n      certificateKey:\n  db:\n    path: /var/lib/kubepi/db/kubepi.db\n  session:\n    expires: 24", "package session\n\nimport (\n\tgoContext \"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\tv1Role \"github.com/KubeOperator/kubepi/internal/model/v1/role\"\n\tv1System \"github.com/KubeOperator/kubepi/internal/model/v1/system\"\n\tv1User \"github.com/KubeOperator/kubepi/internal/model/v1/user\"\n\t\"github.com/KubeOperator/kubepi/internal/server\"\n\t\"github.com/KubeOperator/kubepi/internal/service/v1/cluster\"\n\t\"github.com/KubeOperator/kubepi/internal/service/v1/common\"\n\t\"github.com/KubeOperator/kubepi/internal/service/v1/ldap\"\n\t\"github.com/KubeOperator/kubepi/internal/service/v1/role\"\n\t\"github.com/KubeOperator/kubepi/internal/service/v1/rolebinding\"\n\tv1SystemService \"github.com/KubeOperator/kubepi/internal/service/v1/system\"\n\t\"github.com/KubeOperator/kubepi/internal/service/v1/user\"\n\t\"github.com/KubeOperator/kubepi/pkg/collectons\"\n\t\"github.com/KubeOperator/kubepi/pkg/kubernetes\"\n\t\"github.com/KubeOperator/kubepi/pkg/logging\"\n\t\"github.com/KubeOperator/kubepi/pkg/network/ip\"\n\t\"github.com/KubeOperator/kubepi/pkg/terminal\"\n\t\"github.com/asdine/storm/v3\"\n\t\"github.com/kataras/iris/v12\"\n\t\"github.com/kataras/iris/v12/context\"\n\t\"github.com/kataras/iris/v12/middleware/jwt\"\n\t\"golang.org/x/crypto/bcrypt\"\n\tv1 \"k8s.io/api/rbac/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n)\n\nvar JwtSigKey = []byte(\"signature_hmac_secret_shared_key\")\nvar jwtMaxAge = 10 * time.Minute\n\ntype Handler struct {\n\tuserService        user.Service\n\troleService        role.Service\n\tclusterService     cluster.Service\n\trolebindingService rolebinding.Service\n\tldapService        ldap.Service\n\tjwtSigner          *jwt.Signer\n}\n\nfunc NewHandler() *Handler {\n\treturn &Handler{\n\t\tclusterService:     cluster.NewService(),\n\t\tuserService:        user.NewService(),\n\t\troleService:        role.NewService(),\n\t\trolebindingService: rolebinding.NewService(),\n\t\tldapService:        ldap.NewService(),\n\t\tjwtSigner:          jwt.NewSigner(jwt.HS256, JwtSigKey, jwtMaxAge),\n\t}\n}\n\nfunc (h *Handler) IsLogin() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tsession := server.SessionMgr.Start(ctx)\n\t\tloginUser := session.Get(\"profile\")\n\t\tif loginUser == nil {\n\t\t\tctx.StatusCode(iris.StatusOK)\n\t\t\tctx.Values().Set(\"data\", false)\n\t\t\treturn\n\t\t}\n\t\tp, ok := loginUser.(UserProfile)\n\t\tif !ok {\n\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\tctx.Values().Set(\"message\", \"can not parse to session user\")\n\t\t\treturn\n\t\t}\n\t\tif p.Mfa.Enable {\n\t\t\tif !p.Mfa.Approved {\n\t\t\t\tctx.StatusCode(iris.StatusUnauthorized)\n\t\t\t\tctx.Values().Set(\"message\", \"no login user\")\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := session.Man.ShiftExpiration(ctx); err != nil {\n\t\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\t\tctx.Values().Set(\"message\", fmt.Errorf(\"shift expiration falied, err: %v\", err))\n\t\t\t\treturn\n\t\t\t}\n\t\t\tctx.StatusCode(iris.StatusOK)\n\t\t\tctx.Values().Set(\"data\", loginUser != nil)\n\t\t}\n\t}\n}\n\n// Auth\n// @Tags sessions\n// @Summary User Login\n// @Description User Login\n// @Accept  json\n// @Produce  json\n// @Param request body LoginCredential true \"request\"\n// @Router /sessions [post]\nfunc (h *Handler) Login() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tvar loginCredential LoginCredential\n\t\tif err := ctx.ReadJSON(&loginCredential); err != nil {\n\t\t\tctx.StatusCode(iris.StatusBadRequest)\n\t\t\tctx.Values().Set(\"message\", err.Error())\n\t\t\treturn\n\t\t}\n\t\tu, err := h.userService.GetByNameOrEmail(loginCredential.Username, common.DBOptions{})\n\t\tif err != nil {\n\t\t\tif errors.Is(err, storm.ErrNotFound) {\n\t\t\t\tctx.StatusCode(iris.StatusBadRequest)\n\t\t\t\tctx.Values().Set(\"message\", \"username or password error\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\tctx.Values().Set(\"message\", fmt.Sprintf(\"query user %s failed ,: %s\", loginCredential.Username, err.Error()))\n\t\t\treturn\n\t\t}\n\n\t\tif u.Type == v1User.LDAP {\n\t\t\tif !h.ldapService.CheckStatus() {\n\t\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\t\tctx.Values().Set(\"message\", \"ldap is not enable!\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err := h.ldapService.Login(*u, loginCredential.Password, common.DBOptions{}); err != nil {\n\t\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\t\tctx.Values().Set(\"message\", \"username or password error\")\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := bcrypt.CompareHashAndPassword([]byte(u.Authenticate.Password), []byte(loginCredential.Password)); err != nil {\n\t\t\t\tctx.StatusCode(iris.StatusBadRequest)\n\t\t\t\tctx.Values().Set(\"message\", \"username or password error\")\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tpermissions, err := h.aggregateResourcePermissions(loginCredential.Username)\n\t\tif err != nil {\n\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\tctx.Values().Set(\"message\", err.Error())\n\t\t\treturn\n\t\t}\n\t\tprofile := UserProfile{\n\t\t\tName:                u.Name,\n\t\t\tNickName:            u.NickName,\n\t\t\tEmail:               u.Email,\n\t\t\tLanguage:            u.Language,\n\t\t\tResourcePermissions: permissions,\n\t\t\tIsAdministrator:     u.IsAdmin,\n\t\t\tMfa: Mfa{\n\t\t\t\tSecret:   u.Mfa.Secret,\n\t\t\t\tEnable:   u.Mfa.Enable,\n\t\t\t\tApproved: false,\n\t\t\t},\n\t\t}\n\n\t\tauthMethod := loginCredential.AuthMethod\n\n\t\tswitch authMethod {\n\t\tcase \"jwt\":\n\t\t\ttoken, err := h.jwtSigner.Sign(profile)\n\t\t\tif err != nil {\n\t\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\t\tctx.Values().Set(\"message\", err.Error())\n\t\t\t}\n\t\t\tctx.StatusCode(iris.StatusOK)\n\t\t\tctx.Values().Set(\"token\", token)\n\t\t\treturn\n\t\tdefault:\n\t\t\tsession := server.SessionMgr.Start(ctx)\n\t\t\tsession.Set(\"profile\", profile)\n\t\t}\n\n\t\tctx.StatusCode(iris.StatusOK)\n\t\tgo saveLoginLog(ctx, profile.Name)\n\t\tctx.Values().Set(\"data\", profile)\n\t}\n}\n\nfunc saveLoginLog(ctx *context.Context, userName string) {\n\tvar logItem v1System.LoginLog\n\tlogItem.UserName = userName\n\tlogItem.Ip = ctx.RemoteAddr()\n\tqqWry, err := ip.NewQQwry()\n\tif err != nil {\n\t\tserver.Logger().Errorf(\"load qqwry datas failed: %s\", err)\n\t}\n\tres := qqWry.Find(logItem.Ip)\n\tlogItem.City = res.Area\n\tsystemService := v1SystemService.NewService()\n\tsystemService.CreateLoginLog(&logItem, common.DBOptions{})\n}\n\nfunc (h *Handler) aggregateResourcePermissions(name string) (map[string][]string, error) {\n\tuserRoleBindings, err := h.rolebindingService.GetRoleBindingBySubject(v1Role.Subject{\n\t\tKind: \"User\",\n\t\tName: name,\n\t}, common.DBOptions{})\n\tif err != nil && !errors.As(err, &storm.ErrNotFound) {\n\t\treturn nil, err\n\t}\n\n\tvar roleNames []string\n\tfor i := range userRoleBindings {\n\t\troleNames = append(roleNames, userRoleBindings[i].RoleRef)\n\t}\n\n\trs, err := h.roleService.GetByNames(roleNames, common.DBOptions{})\n\tif err != nil && !errors.As(err, &storm.ErrNotFound) {\n\t\treturn nil, err\n\t}\n\tmapping := map[string]*collectons.StringSet{}\n\tvar policyRoles []v1Role.PolicyRule\n\t//merge permissions\n\tfor i := range rs {\n\t\tfor j := range rs[i].Rules {\n\t\t\tpolicyRoles = append(policyRoles, rs[i].Rules[j])\n\t\t}\n\t}\n\tfor i := range policyRoles {\n\t\tfor j := range policyRoles[i].Resource {\n\t\t\t_, ok := mapping[policyRoles[i].Resource[j]]\n\t\t\tif !ok {\n\t\t\t\tmapping[policyRoles[i].Resource[j]] = collectons.NewStringSet()\n\t\t\t}\n\t\t\tfor k := range policyRoles[i].Verbs {\n\t\t\t\tmapping[policyRoles[i].Resource[j]].Add(policyRoles[i].Verbs[k])\n\t\t\t\tif policyRoles[i].Verbs[k] == \"*\" {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif policyRoles[i].Resource[j] == \"*\" {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tresourceMapping := map[string][]string{}\n\tfor key := range mapping {\n\t\tresourceMapping[key] = mapping[key].ToSlice()\n\t}\n\treturn resourceMapping, nil\n}\n\nfunc (h *Handler) Logout() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tsession := server.SessionMgr.Start(ctx)\n\t\tloginUser := session.Get(\"profile\")\n\t\tif loginUser == nil {\n\t\t\tctx.StatusCode(iris.StatusUnauthorized)\n\t\t\tctx.Values().Set(\"message\", \"no login user\")\n\t\t\treturn\n\t\t}\n\t\tsession.Delete(\"profile\")\n\t\tlogging.LogSessions.Clean()\n\t\tterminal.TerminalSessions.Clean()\n\t\tctx.StatusCode(iris.StatusOK)\n\t\tctx.Values().Set(\"data\", \"logout success\")\n\t}\n}\n\nfunc (h *Handler) GetProfile() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tsession := server.SessionMgr.Start(ctx)\n\t\tloginUser := session.Get(\"profile\")\n\t\tif loginUser == nil {\n\t\t\tctx.StatusCode(iris.StatusUnauthorized)\n\t\t\tctx.Values().Set(\"message\", \"no login user\")\n\t\t\treturn\n\t\t}\n\t\tp, ok := loginUser.(UserProfile)\n\t\tif !ok {\n\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\tctx.Values().Set(\"message\", \"can not parse to session user\")\n\t\t\treturn\n\t\t}\n\n\t\tuser, err := h.userService.GetByNameOrEmail(p.Name, common.DBOptions{})\n\t\tif err != nil {\n\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\tctx.Values().Set(\"message\", err.Error())\n\t\t\treturn\n\t\t}\n\t\tp = UserProfile{\n\t\t\tName:            user.Name,\n\t\t\tNickName:        user.NickName,\n\t\t\tEmail:           user.Email,\n\t\t\tLanguage:        user.Language,\n\t\t\tIsAdministrator: user.IsAdmin,\n\t\t}\n\t\tif !user.IsAdmin {\n\t\t\tpermissions, err := h.aggregateResourcePermissions(p.Name)\n\t\t\tif err != nil {\n\t\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\t\tctx.Values().Set(\"message\", err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t\tp.ResourcePermissions = permissions\n\t\t}\n\t\tsession.Set(\"profile\", p)\n\t\tctx.StatusCode(iris.StatusOK)\n\t\tctx.Values().Set(\"data\", p)\n\t}\n}\n\nfunc (h *Handler) ListUserNamespace() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tname := ctx.Params().GetString(\"cluster_name\")\n\t\tc, err := h.clusterService.Get(name, common.DBOptions{})\n\t\tif err != nil {\n\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\tctx.Values().Set(\"message\", fmt.Sprintf(\"get cluster failed: %s\", err.Error()))\n\t\t\treturn\n\t\t}\n\t\tsession := server.SessionMgr.Start(ctx)\n\t\tu := session.Get(\"profile\")\n\t\tprofile := u.(UserProfile)\n\n\t\tk := kubernetes.NewKubernetes(c)\n\t\tns, err := k.GetUserNamespaceNames(profile.Name, profile.IsAdministrator)\n\t\tif err != nil {\n\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\tctx.Values().Set(\"message\", err)\n\t\t\treturn\n\t\t}\n\t\tctx.Values().Set(\"data\", ns)\n\t}\n}\n\nfunc (h *Handler) GetClusterProfile() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tsession := server.SessionMgr.Start(ctx)\n\t\tclusterName := ctx.Params().GetString(\"cluster_name\")\n\t\tnamesapce := ctx.URLParam(\"namespace\")\n\t\tc, err := h.clusterService.Get(clusterName, common.DBOptions{})\n\t\tif err != nil {\n\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\tctx.Values().Set(\"message\", err.Error())\n\t\t\treturn\n\t\t}\n\t\tk := kubernetes.NewKubernetes(c)\n\t\tclient, err := k.Client()\n\t\tif err != nil {\n\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\tctx.Values().Set(\"message\", fmt.Sprintf(\"get k8s client failed: %s\", err.Error()))\n\t\t\treturn\n\t\t}\n\t\tu := session.Get(\"profile\")\n\t\tprofile := u.(UserProfile)\n\n\t\tif profile.IsAdministrator {\n\t\t\tcrp := ClusterUserProfile{\n\t\t\t\tUserProfile:  profile,\n\t\t\t\tClusterRoles: []v1.ClusterRole{},\n\t\t\t}\n\t\t\tctx.Values().Set(\"data\", &crp)\n\t\t\treturn\n\t\t}\n\n\t\tlabels := []string{\n\t\t\tfmt.Sprintf(\"%s=%s\", kubernetes.LabelManageKey, \"kubepi\"),\n\t\t\tfmt.Sprintf(\"%s=%s\", kubernetes.LabelClusterId, c.UUID),\n\t\t\tfmt.Sprintf(\"%s=%s\", kubernetes.LabelUsername, profile.Name),\n\t\t}\n\t\tclusterRoleBindings, err := client.RbacV1().ClusterRoleBindings().List(goContext.TODO(), metav1.ListOptions{\n\t\t\tLabelSelector: strings.Join(labels, \",\"),\n\t\t})\n\t\tif err != nil {\n\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\tctx.Values().Set(\"message\", fmt.Sprintf(\"get cluster-role-binding failed: %s\", err.Error()))\n\t\t\treturn\n\t\t}\n\t\trolebindings, err := client.RbacV1().RoleBindings(namesapce).List(goContext.TODO(), metav1.ListOptions{\n\t\t\tLabelSelector: strings.Join(labels, \",\"),\n\t\t})\n\t\tif err != nil {\n\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\tctx.Values().Set(\"message\", fmt.Sprintf(\"get role-binding failed: %s\", err.Error()))\n\t\t\treturn\n\t\t}\n\t\troleSet := map[string]struct{}{}\n\t\tfor i := range clusterRoleBindings.Items {\n\t\t\tfor j := range clusterRoleBindings.Items[i].Subjects {\n\t\t\t\tif clusterRoleBindings.Items[i].Subjects[j].Kind == \"User\" {\n\t\t\t\t\troleSet[clusterRoleBindings.Items[i].RoleRef.Name] = struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor i := range rolebindings.Items {\n\t\t\tfor j := range rolebindings.Items[i].Subjects {\n\t\t\t\tif rolebindings.Items[i].Subjects[j].Kind == \"User\" {\n\t\t\t\t\troleSet[rolebindings.Items[i].RoleRef.Name] = struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar roles []v1.ClusterRole\n\t\tfor key := range roleSet {\n\t\t\tr, err := client.RbacV1().ClusterRoles().Get(goContext.TODO(), key, metav1.GetOptions{})\n\t\t\tif err != nil {\n\t\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\t\tctx.Values().Set(\"message\", fmt.Sprintf(\"get cluster-role failed: %s\", err.Error()))\n\t\t\t\treturn\n\t\t\t}\n\t\t\troles = append(roles, *r)\n\t\t}\n\n\t\tcrp := ClusterUserProfile{\n\t\t\tUserProfile:  profile,\n\t\t\tClusterRoles: roles,\n\t\t}\n\t\tif len(roles) <= 0 {\n\t\t\tctx.StatusCode(iris.StatusForbidden)\n\t\t\treturn\n\t\t}\n\t\tctx.Values().Set(\"data\", &crp)\n\t}\n}\n\nfunc Install(parent iris.Party) {\n\thandler := NewHandler()\n\tsp := parent.Party(\"/sessions\")\n\tsp.Post(\"\", handler.Login())\n\tsp.Delete(\"\", handler.Logout())\n\tsp.Get(\"\", handler.GetProfile())\n\tsp.Get(\"/:cluster_name\", handler.GetClusterProfile())\n\tsp.Get(\"/status\", handler.IsLogin())\n\tsp.Get(\"/:cluster_name/namespaces\", handler.ListUserNamespace())\n\tsp.Put(\"\", handler.UpdateProfile())\n\tsp.Put(\"/password\", handler.UpdatePassword())\n}\n", "package v1\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"strings\"\n\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/mfa\"\n\t\"github.com/KubeOperator/kubepi/internal/server\"\n\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/file\"\n\t\"github.com/kataras/iris/v12/middleware/jwt\"\n\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/chart\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/cluster\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/imagerepo\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/ldap\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/proxy\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/role\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/session\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/system\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/user\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/webkubectl\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/ws\"\n\tv1 \"github.com/KubeOperator/kubepi/internal/model/v1\"\n\tv1Role \"github.com/KubeOperator/kubepi/internal/model/v1/role\"\n\tv1System \"github.com/KubeOperator/kubepi/internal/model/v1/system\"\n\t\"github.com/KubeOperator/kubepi/internal/service/v1/common\"\n\tv1RoleService \"github.com/KubeOperator/kubepi/internal/service/v1/role\"\n\tv1RoleBindingService \"github.com/KubeOperator/kubepi/internal/service/v1/rolebinding\"\n\tv1SystemService \"github.com/KubeOperator/kubepi/internal/service/v1/system\"\n\tpkgV1 \"github.com/KubeOperator/kubepi/pkg/api/v1\"\n\t\"github.com/KubeOperator/kubepi/pkg/collectons\"\n\t\"github.com/KubeOperator/kubepi/pkg/i18n\"\n\t\"github.com/asdine/storm/v3\"\n\t\"github.com/kataras/iris/v12\"\n\t\"github.com/kataras/iris/v12/context\"\n\t\"github.com/kataras/iris/v12/core/router\"\n)\n\nvar resourceWhiteList = WhiteList{\"sessions\", \"proxy\", \"ws\", \"charts\", \"webkubectl\", \"apps\", \"mfa\", \"pod\"}\n\ntype WhiteList []string\n\nfunc (w WhiteList) In(name string) bool {\n\tfor i := range w {\n\t\tif w[i] == name {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc authHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tvar p session.UserProfile\n\t\tif ctx.GetHeader(\"Authorization\") != \"\" {\n\t\t\tpr := jwt.Get(ctx).(*session.UserProfile)\n\t\t\tp = *pr\n\n\t\t} else {\n\t\t\tp = server.SessionMgr.Start(ctx).Get(\"profile\").(session.UserProfile)\n\t\t}\n\t\tif p.Name == \"\" {\n\t\t\tctx.Values().Set(\"message\", \"please login\")\n\t\t\tctx.StopWithStatus(iris.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tctx.Values().Set(\"profile\", p)\n\t\tctx.Next()\n\t}\n}\n\nfunc langHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tp := ctx.Values().Get(\"profile\")\n\t\tu, ok := p.(session.UserProfile)\n\t\tlang := i18n.LanguageZhCN\n\t\tif ok {\n\t\t\tlang = u.Language\n\t\t}\n\t\tctx.Values().Set(\"language\", lang)\n\t\tctx.Next()\n\t}\n}\n\nfunc pageHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tif ctx.URLParamExists(pkgV1.PageSize) && ctx.URLParamExists(pkgV1.PageNum) {\n\t\t\tpageNum, err := ctx.URLParamInt(pkgV1.PageNum)\n\t\t\tif err != nil {\n\t\t\t\tctx.Values().Set(\"message\", fmt.Sprintf(\"page num format err %s\", err.Error()))\n\t\t\t\tctx.StopWithStatus(iris.StatusBadRequest)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tpageSize, err := ctx.URLParamInt(pkgV1.PageSize)\n\t\t\tif err != nil {\n\t\t\t\tctx.Values().Set(\"message\", fmt.Sprintf(\"page size format err %s\", err.Error()))\n\t\t\t\tctx.StopWithStatus(iris.StatusBadRequest)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tctx.Values().Set(pkgV1.PageNum, pageNum)\n\t\t\tctx.Values().Set(pkgV1.PageSize, pageSize)\n\t\t}\n\t\tctx.Next()\n\t}\n}\n\ntype logHelper struct {\n\tName     string `json:\"name\"`\n\tMetadata v1.Metadata\n}\n\nfunc logHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tmethod := strings.ToLower(ctx.Method())\n\t\tif method != \"post\" && method != \"delete\" && method != \"put\" {\n\t\t\tctx.Next()\n\t\t\treturn\n\t\t}\n\n\t\tresourceName := ctx.Values().GetString(\"resource\")\n\t\tif resourceName == \"\" || resourceWhiteList.In(resourceName) {\n\t\t\tctx.Next()\n\t\t\treturn\n\t\t}\n\n\t\tcurrentPath := ctx.GetCurrentRoute().Path()\n\t\tpath := strings.Replace(ctx.Request().URL.Path, \"/kubepi/api/v1/\", \"\", 1)\n\t\tcurrentPath = strings.Replace(currentPath, \"/kubepi/api/v1/\", \"\", 1)\n\t\tif strings.HasSuffix(path, \"search\") {\n\t\t\tctx.Next()\n\t\t\treturn\n\t\t}\n\n\t\tu := ctx.Values().Get(\"profile\")\n\t\tprofile := u.(session.UserProfile)\n\t\tvar log v1System.OperationLog\n\t\tlog.Operator = profile.Name\n\t\tlog.Operation = method\n\n\t\t//handle ldap operate\n\t\tif strings.Contains(path, \"ldap\") {\n\t\t\tif strings.Contains(path, \"import\") {\n\t\t\t\tlog.Operation = \"import\"\n\t\t\t}\n\t\t\tif strings.Contains(path, \"sync\") {\n\t\t\t\tlog.Operation = \"sync\"\n\t\t\t}\n\t\t\tif strings.Contains(path, \"connect\") {\n\t\t\t\tlog.Operation = \"testConnect\"\n\t\t\t}\n\t\t\tif strings.Contains(path, \"login\") {\n\t\t\t\tlog.Operation = \"testLogin\"\n\t\t\t}\n\t\t}\n\n\t\tpathResource := strings.Split(path, \"/\")\n\t\tif strings.HasPrefix(currentPath, \"clusters/:name\") {\n\t\t\tif len(pathResource) < 3 {\n\t\t\t\tlog.OperationDomain = pathResource[0]\n\t\t\t\tif method != \"post\" {\n\t\t\t\t\tlog.SpecificInformation = pathResource[1]\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlog.OperationDomain = fmt.Sprintf(\"%s_%s\", pathResource[0], pathResource[2])\n\t\t\t\tif method != \"post\" {\n\t\t\t\t\tif len(pathResource) > 3 {\n\t\t\t\t\t\tlog.SpecificInformation = fmt.Sprintf(\"[%s] %s\", pathResource[1], pathResource[3])\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlog.SpecificInformation = fmt.Sprintf(\"[%s] %s\", pathResource[1], \"-\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlog.OperationDomain = strings.Split(currentPath, \"/\")[0]\n\t\t\tif method != \"post\" {\n\t\t\t\tif len(pathResource) > 1 {\n\t\t\t\t\tlog.SpecificInformation = pathResource[1]\n\t\t\t\t} else {\n\t\t\t\t\tlog.SpecificInformation = \"-\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif !strings.Contains(currentPath, \"upload\") {\n\t\t\tif method == \"post\" {\n\t\t\t\tvar req logHelper\n\t\t\t\tdata, _ := ctx.GetBody()\n\t\t\t\tif err := json.Unmarshal(data, &req); err != nil {\n\t\t\t\t\tctx.Next()\n\t\t\t\t}\n\t\t\t\tif len(req.Name) == 0 {\n\t\t\t\t\treq.Name = req.Metadata.Name\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(currentPath, \"clusters/:name\") {\n\t\t\t\t\tlog.SpecificInformation = fmt.Sprintf(\"[%s] %s\", pathResource[1], req.Name)\n\t\t\t\t} else {\n\t\t\t\t\tlog.SpecificInformation = req.Name\n\t\t\t\t}\n\t\t\t\tctx.Request().Body = ioutil.NopCloser(bytes.NewBuffer(data))\n\t\t\t}\n\t\t}\n\t\tsystemService := v1SystemService.NewService()\n\t\tgo systemService.CreateOperationLog(&log, common.DBOptions{})\n\t\tctx.Next()\n\t}\n}\n\nfunc resourceExtractHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tpath := ctx.Request().URL.Path\n\t\tss := strings.Split(path, \"/\")\n\t\t// \"\" \"api\" \"v1\" \"resource\"\n\t\tif len(ss) >= 5 {\n\t\t\tctx.Values().Set(\"resource\", ss[4])\n\t\t}\n\t\tctx.Next()\n\t}\n}\n\nfunc roleHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\t// \u67e5\u8be2\u5f53\u524d\u7528\u6237\u7684\u89d2\u8272\n\t\t// \u67e5\u8be2\u89d2\u8272\u7684 rolebinding \u83b7\u53d6 roles\n\t\tp := ctx.Values().Get(\"profile\")\n\t\tu := p.(session.UserProfile)\n\n\t\tif u.IsAdministrator {\n\t\t\tctx.Next()\n\t\t\treturn\n\t\t}\n\t\troleBindingService := v1RoleBindingService.NewService()\n\t\trbs, err := roleBindingService.GetRoleBindingBySubject(v1Role.Subject{\n\t\t\tKind: \"User\",\n\t\t\tName: u.Name,\n\t\t}, common.DBOptions{})\n\t\tif err != nil {\n\t\t\tif !errors.As(err, &storm.ErrNotFound) {\n\t\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\t\tctx.Values().Set(\"message\", err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\troleNameHash := map[string]struct{}{}\n\t\tfor i := range rbs {\n\t\t\troleName := rbs[i].RoleRef\n\t\t\troleNameHash[roleName] = struct{}{}\n\t\t}\n\t\tvar roleNames []string\n\t\tfor key := range roleNameHash {\n\t\t\troleNames = append(roleNames, key)\n\t\t}\n\n\t\troleService := v1RoleService.NewService()\n\t\trs, err := roleService.GetByNames(roleNames, common.DBOptions{})\n\t\tif err != nil {\n\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\tctx.Values().Set(\"message\", err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tctx.Values().Set(\"roles\", rs)\n\t\tctx.Next()\n\t}\n}\n\nfunc getVerbByRoute(path, method string) string {\n\tswitch strings.ToLower(method) {\n\tcase \"put\":\n\t\treturn \"update\"\n\tcase \"delete\":\n\t\treturn \"delete\"\n\tcase \"get\":\n\t\tif strings.Contains(path, \"/:name\") {\n\t\t\treturn \"get\"\n\t\t} else {\n\t\t\treturn \"list\"\n\t\t}\n\tcase \"post\":\n\t\tif strings.HasSuffix(path, \"search\") {\n\t\t\treturn \"list\"\n\t\t}\n\t\treturn \"create\"\n\n\t}\n\treturn \"\"\n}\n\nfunc apiResourceHandler(party iris.Party) iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\t//1. \u786e\u5b9a\u6240\u6709\u7684api\u8d44\u6e90\u6709\u54ea\u4e9b\n\t\tapiBuilder := party.(*router.APIBuilder)\n\t\troutes := apiBuilder.GetRoutes()\n\t\tresourceMap := map[string]*collectons.StringSet{}\n\t\tfor i := range routes {\n\t\t\tif strings.HasPrefix(routes[i].Path, \"/kubepi/api/v1/\") {\n\t\t\t\tss := strings.Split(routes[i].Path, \"/\")\n\t\t\t\tif len(ss) >= 5 {\n\t\t\t\t\tresourceName := ss[4]\n\t\t\t\t\t//\u8fc7\u6ee4session\u8d44\u6e90\n\t\t\t\t\tif resourceWhiteList.In(resourceName) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif _, ok := resourceMap[resourceName]; !ok {\n\t\t\t\t\t\tresourceMap[resourceName] = collectons.NewStringSet()\n\t\t\t\t\t}\n\t\t\t\t\tresourceMap[resourceName].Add(getVerbByRoute(routes[i].Path, routes[i].Method))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdisplayMap := map[string][]string{}\n\t\tfor k := range resourceMap {\n\t\t\tverbs := resourceMap[k]\n\t\t\tif len(verbs.ToSlice()) > 0 {\n\t\t\t\tdisplayMap[k] = verbs.ToSlice()\n\t\t\t}\n\t\t}\n\t\tif ops, ok := displayMap[\"clusters\"]; ok {\n\t\t\tops = append(ops, \"authorization\")\n\t\t\tdisplayMap[\"clusters\"] = ops\n\t\t}\n\t\tctx.Values().Set(\"data\", displayMap)\n\t}\n}\n\nfunc roleAccessHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\t//// \u67e5\u8be2\u89d2\u8272\u7684 resources\n\t\t//// \u901a\u8fc7api resource \u8fc7\u6ee4\u51fa\u6765\u8d44\u6e90\u4e3b\u4f53,method \u8fc7\u6ee4\u64cd\u4f5c\n\t\tp := ctx.Values().Get(\"profile\")\n\t\tu := p.(session.UserProfile)\n\t\tisInWhiteList := false\n\t\tfor _, path := range resourceWhiteList {\n\t\t\tif strings.Contains(ctx.Request().URL.Path, fmt.Sprintf(\"/%s\", path)) && path != \"sessions\" {\n\t\t\t\tisInWhiteList = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isInWhiteList {\n\t\t\t// \u653e\u901aadmin\u6743\u9650\n\t\t\tif u.IsAdministrator {\n\t\t\t\tctx.Next()\n\t\t\t\treturn\n\t\t\t}\n\t\t\trs := ctx.Values().Get(\"roles\")\n\t\t\troles := rs.([]v1Role.Role)\n\t\t\trequestResource := ctx.Values().GetString(\"resource\")\n\t\t\tif requestResource != \"\" {\n\t\t\t\tcurrentRoute := ctx.GetCurrentRoute()\n\t\t\t\trequestVerb := getVerbByRoute(currentRoute.Path(), currentRoute.Method())\n\t\t\t\tresourceMatched, methodMatch := matchRoles(requestResource, requestVerb, roles)\n\t\t\t\tif !(resourceMatched && methodMatch) {\n\t\t\t\t\tctx.StopWithStatus(iris.StatusForbidden)\n\t\t\t\t\tctx.Values().Set(\"message\", []string{\"user %s can not access resource %s %s\", u.Name, requestResource, requestVerb})\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tctx.Next()\n\t}\n}\n\nfunc matchRoles(requestResource, requestMethod string, rs []v1Role.Role) (bool, bool) {\n\tresourceMatch := false\n\tmethodMatch := false\n\tfor i := range rs {\n\t\tfor j := range rs[i].Rules {\n\t\t\tfor k := range rs[i].Rules[j].Resource {\n\t\t\t\tif rs[i].Rules[j].Resource[k] == requestResource || rs[i].Rules[j].Resource[k] == \"*\" {\n\t\t\t\t\tresourceMatch = true\n\t\t\t\t\tfor x := range rs[i].Rules[j].Verbs {\n\t\t\t\t\t\tif rs[i].Rules[j].Verbs[x] == requestMethod || rs[i].Rules[j].Verbs[x] == \"*\" {\n\t\t\t\t\t\t\tmethodMatch = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn resourceMatch, methodMatch\n}\n\nfunc resourceNameInvalidHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tr := ctx.GetCurrentRoute()\n\t\tif strings.Contains(r.Path(), \"/:name\") {\n\t\t\tresourceName := ctx.Params().GetString(\"name\")\n\t\t\tif resourceName == \"\" {\n\t\t\t\tctx.StatusCode(iris.StatusBadRequest)\n\t\t\t\tctx.Values().Set(\"message\", fmt.Sprintf(\"invalid resource name %s\", resourceName))\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tctx.Next()\n\t}\n}\n\nfunc WarpedJwtHandler() iris.Handler {\n\n\tverifier := jwt.NewVerifier(jwt.HS256, session.JwtSigKey)\n\tverifier.WithDefaultBlocklist()\n\tverifyMiddleware := verifier.Verify(func() interface{} {\n\t\treturn new(session.UserProfile)\n\t})\n\treturn func(ctx *context.Context) {\n\t\tsess := server.SessionMgr.Start(ctx)\n\t\tif sess.Get(\"profile\") != nil {\n\t\t\tctx.Next()\n\t\t\treturn\n\t\t}\n\t\tverifyMiddleware(ctx)\n\t}\n}\n\nfunc AddV1Route(app iris.Party) {\n\n\tv1Party := app.Party(\"/v1\")\n\tv1Party.Use(langHandler())\n\tv1Party.Use(pageHandler())\n\tsession.Install(v1Party)\n\tmfa.Install(v1Party)\n\tauthParty := v1Party.Party(\"\")\n\n\tauthParty.Use(WarpedJwtHandler())\n\tauthParty.Use(authHandler())\n\tauthParty.Use(resourceExtractHandler())\n\tauthParty.Use(roleHandler())\n\tauthParty.Use(roleAccessHandler())\n\tauthParty.Use(resourceNameInvalidHandler())\n\tauthParty.Use(logHandler())\n\tauthParty.Get(\"/\", apiResourceHandler(authParty))\n\tuser.Install(authParty)\n\tcluster.Install(authParty)\n\trole.Install(authParty)\n\tsystem.Install(v1Party)\n\tproxy.Install(authParty)\n\tws.Install(authParty)\n\tchart.Install(authParty)\n\twebkubectl.Install(authParty, v1Party)\n\tldap.Install(authParty)\n\timagerepo.Install(authParty)\n\tfile.Install(authParty)\n}\n", "package config\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"github.com/KubeOperator/kubepi/internal/model/v1/config\"\n\t\"github.com/KubeOperator/kubepi/pkg/file\"\n\t\"github.com/coreos/etcd/pkg/fileutil\"\n\t\"github.com/spf13/viper\"\n)\n\nconst configNotFoundSkipErr = \"config file not found in %s, skip\"\nconst configReadErr = \"can not read config file %s ,%s\"\nconst configMergeErr = \"can not merge config file, %s\"\n\nvar configFilePaths = []string{\n\t\"/etc/kubepi\",\n}\n\nfunc ReadConfig(c *config.Config, path ...string)  error {\n\tv := viper.New()\n\tv.SetConfigName(\"app\")\n\tv.SetConfigType(\"yaml\")\n\n\tfor i := range path {\n\t\tconfigFilePaths = append(configFilePaths, path[i])\n\t}\n\tfor i := range configFilePaths {\n\t\trealDir := file.ReplaceHomeDir(configFilePaths[i])\n\n\t\tif exists := fileutil.Exist(realDir); !exists {\n\t\t\tfmt.Println(fmt.Sprintf(configNotFoundSkipErr, realDir))\n\t\t\tcontinue\n\t\t}\n\n\t\tv.AddConfigPath(realDir)\n\t\tif err := v.ReadInConfig(); err != nil {\n\t\t\tfmt.Println(fmt.Sprintf(configReadErr, realDir, err.Error()))\n\t\t\tcontinue\n\t\t}\n\t\tif err := v.MergeInConfig(); err != nil {\n\t\t\tfmt.Println(fmt.Sprintf(configMergeErr, configFilePaths))\n\t\t}\n\t}\n\n\tvar configMap map[string]interface{}\n\tif err := v.Unmarshal(&configMap); err != nil {\n\t\treturn  err\n\t}\n\tstr, err := json.Marshal(&configMap)\n\tif err != nil {\n\t\treturn  err\n\t}\n\tif err := json.Unmarshal(str, &c); err != nil {\n\t\treturn  nil\n\t}\n\treturn  nil\n}\n\n", "package config\n\nimport v1 \"github.com/KubeOperator/kubepi/internal/model/v1\"\n\ntype Config struct {\n\tv1.BaseModel\n\tv1.Metadata\n\tSpec Spec `json:\"spec\"`\n}\ntype Spec struct {\n\tServer  ServerConfig  `json:\"server\"`\n\tDB      DBConfig      `json:\"db\"`\n\tSession SessionConfig `json:\"session\"`\n\tLogger  LoggerConfig  `json:\"logger\"`\n\tAppId   string        `json:\"appId\"`\n}\n\ntype ServerConfig struct {\n\tBind BindConfig `json:\"bind\"`\n\tSSL  SSLConfig  `json:\"ssl\"`\n}\n\ntype BindConfig struct {\n\tHost string `json:\"host\"`\n\tPort int    `json:\"port\"`\n}\n\ntype SSLConfig struct {\n\tEnable         bool   `json:\"enable\"`\n\tCertificate    string `json:\"certificate\"`\n\tCertificateKey string `json:\"certificateKey\"`\n}\n\ntype LoggerConfig struct {\n\tLevel string\n}\n\ntype DBConfig struct {\n\tPath string `json:\"path\"`\n}\n\ntype SessionConfig struct {\n\tExpires int `json:\"expires\"`\n}\n", "package server\n\nimport (\n\t\"embed\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/iris-contrib/swagger/v12\"\n\t\"github.com/iris-contrib/swagger/v12/swaggerFiles\"\n\n\tv1 \"github.com/KubeOperator/kubepi/internal/model/v1\"\n\t\"k8s.io/klog/v2\"\n\n\t\"github.com/KubeOperator/kubepi/internal/config\"\n\tv1Config \"github.com/KubeOperator/kubepi/internal/model/v1/config\"\n\t\"github.com/KubeOperator/kubepi/migrate\"\n\t\"github.com/KubeOperator/kubepi/pkg/file\"\n\t\"github.com/KubeOperator/kubepi/pkg/i18n\"\n\t\"github.com/asdine/storm/v3\"\n\t\"github.com/coreos/etcd/pkg/fileutil\"\n\t\"github.com/kataras/iris/v12\"\n\t\"github.com/kataras/iris/v12/context\"\n\t\"github.com/kataras/iris/v12/sessions\"\n\t\"github.com/kataras/iris/v12/view\"\n\t\"github.com/sirupsen/logrus\"\n)\n\nconst sessionCookieName = \"SESS_COOKIE_KUBEPI\"\n\nvar SessionMgr *sessions.Sessions\n\nvar EmbedWebKubePi embed.FS\nvar EmbedWebDashboard embed.FS\nvar EmbedWebTerminal embed.FS\nvar WebkubectlEntrypoint string\n\ntype Option func(server *KubePiServer)\n\nfunc WithServerBindHost(host string) Option {\n\treturn func(server *KubePiServer) {\n\t\tif host != \"\" {\n\t\t\tserver.config.Spec.Server.Bind.Host = host\n\t\t}\n\t}\n}\n\nfunc WithServerBindPort(port int) Option {\n\treturn func(server *KubePiServer) {\n\t\tif port != 0 {\n\t\t\tserver.config.Spec.Server.Bind.Port = port\n\t\t}\n\t}\n}\n\nfunc WithCustomConfigFilePath(path string) Option {\n\treturn func(server *KubePiServer) {\n\t\tif path != \"\" {\n\t\t\tserver.configCustomFilePath = path\n\t\t}\n\t}\n}\n\ntype KubePiServer struct {\n\tapp                  *iris.Application\n\tdb                   *storm.DB\n\tlogger               *logrus.Logger\n\tconfigCustomFilePath string\n\tconfig               *v1Config.Config\n\trootRoute            iris.Party\n}\n\nfunc NewKubePiSerer(opts ...Option) *KubePiServer {\n\tc := &KubePiServer{}\n\tc.app = iris.New()\n\tc.config = getDefaultConfig()\n\tfor _, op := range opts {\n\t\top(c)\n\t}\n\tc.setUpConfig()\n\tfor _, op := range opts {\n\t\top(c)\n\t}\n\treturn c.bootstrap()\n}\n\nfunc (e *KubePiServer) setUpConfig() {\n\terr := config.ReadConfig(e.config, e.configCustomFilePath)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc (e *KubePiServer) setUpLogger() {\n\tklog.SetLogger(TodoLogger{})\n\te.logger = logrus.New()\n\tl, err := logrus.ParseLevel(e.config.Spec.Logger.Level)\n\tif err != nil {\n\t\te.logger.Errorf(\"cant not parse logger level %s, %s,use default level: INFO\", e.config.Spec.Logger.Level, err)\n\t}\n\te.logger.SetLevel(l)\n}\n\nfunc (e *KubePiServer) setUpDB() {\n\trealDir := file.ReplaceHomeDir(e.config.Spec.DB.Path)\n\tif !fileutil.Exist(realDir) {\n\t\tif err := os.MkdirAll(realDir, 0755); err != nil {\n\t\t\tpanic(fmt.Errorf(\"can not create database dir: %s message: %s\", e.config.Spec.DB.Path, err))\n\t\t}\n\t}\n\td, err := storm.Open(path.Join(realDir, \"kubepi.db\"))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\te.db = d\n}\n\nfunc (e *KubePiServer) setUpRootRoute() {\n\te.app.Any(\"/\", func(ctx *context.Context) {\n\t\tctx.Redirect(\"/kubepi\")\n\t})\n\tc := swagger.Config{\n\t\tURL: \"/kubepi/swagger/doc.json\",\n\t}\n\te.app.Get(\"/kubepi/swagger/{any:path}\", swagger.CustomWrapHandler(&c, swaggerFiles.Handler))\n\te.rootRoute = e.app.Party(\"/kubepi\")\n}\n\nfunc (e *KubePiServer) setUpStaticFile() {\n\tspaOption := iris.DirOptions{SPA: true, IndexName: \"index.html\"}\n\tparty := e.rootRoute.Party(\"/\")\n\tparty.Use(iris.Compression)\n\tdashboardFS := iris.PrefixDir(\"web/dashboard\", http.FS(EmbedWebDashboard))\n\tparty.RegisterView(view.HTML(dashboardFS, \".html\"))\n\tparty.HandleDir(\"/dashboard/\", dashboardFS, spaOption)\n\n\tterminalFS := iris.PrefixDir(\"web/terminal\", http.FS(EmbedWebTerminal))\n\tparty.RegisterView(view.HTML(terminalFS, \".html\"))\n\tparty.HandleDir(\"/terminal/\", terminalFS, spaOption)\n\n\tkubePiFS := iris.PrefixDir(\"web/kubepi\", http.FS(EmbedWebKubePi))\n\tparty.RegisterView(view.HTML(kubePiFS, \".html\"))\n\tparty.HandleDir(\"/\", kubePiFS, spaOption)\n}\n\nfunc (e *KubePiServer) setUpSession() {\n\tSessionMgr = sessions.New(sessions.Config{Cookie: sessionCookieName, AllowReclaim: true, Expires: time.Duration(e.config.Spec.Session.Expires) * time.Hour})\n\te.rootRoute.Use(SessionMgr.Handler())\n}\n\nconst ContentTypeDownload = \"application/download\"\n\nfunc (e *KubePiServer) setResultHandler() {\n\te.rootRoute.Use(func(ctx *context.Context) {\n\t\tctx.Next()\n\t\tcontentType := ctx.ResponseWriter().Header().Get(\"Content-Type\")\n\t\tif contentType == ContentTypeDownload {\n\t\t\treturn\n\t\t}\n\t\tisProxyPath := func() bool {\n\t\t\tp := ctx.GetCurrentRoute().Path()\n\t\t\tss := strings.Split(p, \"/\")\n\t\t\tif len(ss) > 0 {\n\t\t\t\tif ss[0] == \"webkubectl\" {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t\tif len(ss) >= 3 {\n\t\t\t\tfor i := range ss {\n\t\t\t\t\tif ss[i] == \"proxy\" || ss[i] == \"ws\" {\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false\n\t\t}()\n\t\tif !isProxyPath {\n\t\t\tif ctx.GetStatusCode() >= iris.StatusOK && ctx.GetStatusCode() < iris.StatusBadRequest {\n\t\t\t\tif ctx.Values().Get(\"token\") != nil {\n\t\t\t\t\t_, _ = ctx.Write(ctx.Values().Get(\"token\").([]uint8))\n\t\t\t\t} else {\n\t\t\t\t\tresp := iris.Map{\n\t\t\t\t\t\t\"success\": true,\n\t\t\t\t\t\t\"data\":    ctx.Values().Get(\"data\"),\n\t\t\t\t\t}\n\t\t\t\t\t_, _ = ctx.JSON(resp)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc (e *KubePiServer) setUpErrHandler() {\n\te.rootRoute.OnAnyErrorCode(func(ctx iris.Context) {\n\t\tif ctx.Values().GetString(\"message\") == \"\" {\n\t\t\tswitch ctx.GetStatusCode() {\n\t\t\tcase iris.StatusNotFound:\n\t\t\t\tctx.Values().Set(\"message\", \"the server could not find the requested resource\")\n\t\t\t}\n\t\t}\n\t\tmessage := ctx.Values().Get(\"message\")\n\t\tif message == nil || message == \"\" {\n\t\t\tmessage = ctx.Values().Get(\"iris.context.error\")\n\t\t}\n\n\t\tlang := ctx.Values().GetString(\"language\")\n\t\tvar (\n\t\t\ttranslateMessage string\n\t\t\terr              error\n\t\t\toriginMessage    string\n\t\t)\n\n\t\tswitch value := message.(type) {\n\t\tcase string:\n\t\t\toriginMessage = message.(string)\n\t\t\ttranslateMessage, err = i18n.Translate(lang, value)\n\t\tcase []string:\n\t\t\toriginMessage = strings.Join(value, \",\")\n\t\t\tif len(value) > 0 {\n\t\t\t\ttranslateMessage, err = i18n.Translate(lang, value[0], value[1:])\n\t\t\t}\n\t\tcase context.ErrPrivate:\n\t\t\terr := message.(context.ErrPrivate)\n\t\t\ttranslateMessage = err.Error()\n\t\t}\n\t\tmsg := translateMessage\n\t\tif err != nil {\n\t\t\te.app.Logger().Debug(err)\n\t\t\tmsg = originMessage\n\t\t}\n\t\ter := iris.Map{\n\t\t\t\"success\": false,\n\t\t\t\"code\":    ctx.GetStatusCode(),\n\t\t\t\"message\": msg,\n\t\t}\n\t\t_, _ = ctx.JSON(er)\n\t})\n}\n\nfunc (e *KubePiServer) runMigrations() {\n\tmigrate.RunMigrate(e.db, e.logger)\n}\nfunc (e *KubePiServer) setWebkubectlProxy() {\n\thandler := func(ctx *context.Context) {\n\t\tp := ctx.Params().Get(\"p\")\n\t\tif strings.Contains(p, \"root\") {\n\t\t\tctx.Request().URL.Path = strings.ReplaceAll(ctx.Request().URL.Path, \"root\", \"\")\n\t\t\tctx.Request().RequestURI = strings.ReplaceAll(ctx.Request().RequestURI, \"root\", \"\")\n\t\t}\n\t\tu, _ := url.Parse(\"http://localhost:8080\")\n\t\tproxy := httputil.NewSingleHostReverseProxy(u)\n\t\tproxy.ModifyResponse = func(resp *http.Response) error {\n\t\t\tif resp.StatusCode == iris.StatusMovedPermanently {\n\t\t\t\t// \u91cd\u5b9a\u5411\u91cd\u5199\n\t\t\t\tif resp.Header.Get(\"Location\") == \"/kubepi/webkubectl/\" {\n\t\t\t\t\tresp.Header.Set(\"Location\", \"/kubepi/webkubectl/root\")\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\tproxy.ServeHTTP(ctx.ResponseWriter(), ctx.Request())\n\t}\n\te.rootRoute.Any(\"/webkubectl/{p:path}\", handler)\n\te.rootRoute.Any(\"webkubectl\", handler)\n}\n\nfunc (e *KubePiServer) setUpTtyEntrypoint() {\n\tf, err := os.OpenFile(\"init-kube.sh\", os.O_CREATE|os.O_RDWR, 0755)\n\tif err != nil {\n\t\te.logger.Error(err)\n\t\treturn\n\t}\n\tif _, err := f.WriteString(WebkubectlEntrypoint); err != nil {\n\t\te.logger.Error(err)\n\t\treturn\n\t}\n}\n\nfunc (e *KubePiServer) bootstrap() *KubePiServer {\n\te.setUpRootRoute()\n\te.setUpStaticFile()\n\te.setUpLogger()\n\te.setUpDB()\n\te.setUpSession()\n\te.setResultHandler()\n\te.setUpErrHandler()\n\te.setWebkubectlProxy()\n\te.runMigrations()\n\te.setUpTtyEntrypoint()\n\te.startTty()\n\treturn e\n}\n\nvar es *KubePiServer\n\nfunc DB() *storm.DB {\n\treturn es.db\n}\n\nfunc Config() *v1Config.Config {\n\treturn es.config\n}\n\nfunc Logger() *logrus.Logger {\n\treturn es.logger\n}\n\nfunc Listen(route func(party iris.Party), options ...Option) error {\n\tes = NewKubePiSerer(options...)\n\troute(es.rootRoute)\n\treturn es.app.Run(iris.Addr(fmt.Sprintf(\"%s:%d\", es.config.Spec.Server.Bind.Host, es.config.Spec.Server.Bind.Port)))\n}\n\nfunc getDefaultConfig() *v1Config.Config {\n\treturn &v1Config.Config{\n\t\tBaseModel: v1.BaseModel{\n\t\t\tApiVersion: \"v1\",\n\t\t\tKind:       \"AppConfig\",\n\t\t},\n\t\tMetadata: v1.Metadata{},\n\t\tSpec: v1Config.Spec{\n\t\t\tServer: v1Config.ServerConfig{\n\t\t\t\tBind: v1Config.BindConfig{\n\t\t\t\t\tHost: \"0.0.0.0\",\n\t\t\t\t\tPort: 80,\n\t\t\t\t},\n\t\t\t\tSSL: v1Config.SSLConfig{\n\t\t\t\t\tEnable: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\tDB: v1Config.DBConfig{\n\t\t\t\tPath: \"/var/lib/kubepi/db\",\n\t\t\t},\n\t\t\tSession: v1Config.SessionConfig{\n\t\t\t\tExpires: 72,\n\t\t\t},\n\t\t\tLogger: v1Config.LoggerConfig{Level: \"debug\"},\n\t\t},\n\t}\n}\n"], "fixing_code": ["apiVersion: v1\nkind: AppConfig\nspec:\n  server:\n    bind:\n      host: 0.0.0.0\n      port: 80\n    ssl:\n      enable: false\n      certificate:\n      certificateKey:\n  db:\n    path: /var/lib/kubepi/db/kubepi.db\n  session:\n    expires: 24\n  jwt:\n    key:", "package session\n\nimport (\n\tgoContext \"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\tv1Role \"github.com/KubeOperator/kubepi/internal/model/v1/role\"\n\tv1System \"github.com/KubeOperator/kubepi/internal/model/v1/system\"\n\tv1User \"github.com/KubeOperator/kubepi/internal/model/v1/user\"\n\t\"github.com/KubeOperator/kubepi/internal/server\"\n\t\"github.com/KubeOperator/kubepi/internal/service/v1/cluster\"\n\t\"github.com/KubeOperator/kubepi/internal/service/v1/common\"\n\t\"github.com/KubeOperator/kubepi/internal/service/v1/ldap\"\n\t\"github.com/KubeOperator/kubepi/internal/service/v1/role\"\n\t\"github.com/KubeOperator/kubepi/internal/service/v1/rolebinding\"\n\tv1SystemService \"github.com/KubeOperator/kubepi/internal/service/v1/system\"\n\t\"github.com/KubeOperator/kubepi/internal/service/v1/user\"\n\t\"github.com/KubeOperator/kubepi/pkg/collectons\"\n\t\"github.com/KubeOperator/kubepi/pkg/kubernetes\"\n\t\"github.com/KubeOperator/kubepi/pkg/logging\"\n\t\"github.com/KubeOperator/kubepi/pkg/network/ip\"\n\t\"github.com/KubeOperator/kubepi/pkg/terminal\"\n\t\"github.com/asdine/storm/v3\"\n\t\"github.com/kataras/iris/v12\"\n\t\"github.com/kataras/iris/v12/context\"\n\t\"github.com/kataras/iris/v12/middleware/jwt\"\n\t\"golang.org/x/crypto/bcrypt\"\n\tv1 \"k8s.io/api/rbac/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n)\n\nvar jwtMaxAge = 10 * time.Minute\n\ntype Handler struct {\n\tuserService        user.Service\n\troleService        role.Service\n\tclusterService     cluster.Service\n\trolebindingService rolebinding.Service\n\tldapService        ldap.Service\n\tjwtSigner          *jwt.Signer\n}\n\nfunc NewHandler() *Handler {\n\treturn &Handler{\n\t\tclusterService:     cluster.NewService(),\n\t\tuserService:        user.NewService(),\n\t\troleService:        role.NewService(),\n\t\trolebindingService: rolebinding.NewService(),\n\t\tldapService:        ldap.NewService(),\n\t\tjwtSigner:          jwt.NewSigner(jwt.HS256, server.Config().Spec.Jwt.Key, jwtMaxAge),\n\t}\n}\n\nfunc (h *Handler) IsLogin() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tsession := server.SessionMgr.Start(ctx)\n\t\tloginUser := session.Get(\"profile\")\n\t\tif loginUser == nil {\n\t\t\tctx.StatusCode(iris.StatusOK)\n\t\t\tctx.Values().Set(\"data\", false)\n\t\t\treturn\n\t\t}\n\t\tp, ok := loginUser.(UserProfile)\n\t\tif !ok {\n\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\tctx.Values().Set(\"message\", \"can not parse to session user\")\n\t\t\treturn\n\t\t}\n\t\tif p.Mfa.Enable {\n\t\t\tif !p.Mfa.Approved {\n\t\t\t\tctx.StatusCode(iris.StatusUnauthorized)\n\t\t\t\tctx.Values().Set(\"message\", \"no login user\")\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := session.Man.ShiftExpiration(ctx); err != nil {\n\t\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\t\tctx.Values().Set(\"message\", fmt.Errorf(\"shift expiration falied, err: %v\", err))\n\t\t\t\treturn\n\t\t\t}\n\t\t\tctx.StatusCode(iris.StatusOK)\n\t\t\tctx.Values().Set(\"data\", loginUser != nil)\n\t\t}\n\t}\n}\n\n// Auth\n// @Tags sessions\n// @Summary User Login\n// @Description User Login\n// @Accept  json\n// @Produce  json\n// @Param request body LoginCredential true \"request\"\n// @Router /sessions [post]\nfunc (h *Handler) Login() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tvar loginCredential LoginCredential\n\t\tif err := ctx.ReadJSON(&loginCredential); err != nil {\n\t\t\tctx.StatusCode(iris.StatusBadRequest)\n\t\t\tctx.Values().Set(\"message\", err.Error())\n\t\t\treturn\n\t\t}\n\t\tu, err := h.userService.GetByNameOrEmail(loginCredential.Username, common.DBOptions{})\n\t\tif err != nil {\n\t\t\tif errors.Is(err, storm.ErrNotFound) {\n\t\t\t\tctx.StatusCode(iris.StatusBadRequest)\n\t\t\t\tctx.Values().Set(\"message\", \"username or password error\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\tctx.Values().Set(\"message\", fmt.Sprintf(\"query user %s failed ,: %s\", loginCredential.Username, err.Error()))\n\t\t\treturn\n\t\t}\n\n\t\tif u.Type == v1User.LDAP {\n\t\t\tif !h.ldapService.CheckStatus() {\n\t\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\t\tctx.Values().Set(\"message\", \"ldap is not enable!\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err := h.ldapService.Login(*u, loginCredential.Password, common.DBOptions{}); err != nil {\n\t\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\t\tctx.Values().Set(\"message\", \"username or password error\")\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := bcrypt.CompareHashAndPassword([]byte(u.Authenticate.Password), []byte(loginCredential.Password)); err != nil {\n\t\t\t\tctx.StatusCode(iris.StatusBadRequest)\n\t\t\t\tctx.Values().Set(\"message\", \"username or password error\")\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tpermissions, err := h.aggregateResourcePermissions(loginCredential.Username)\n\t\tif err != nil {\n\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\tctx.Values().Set(\"message\", err.Error())\n\t\t\treturn\n\t\t}\n\t\tprofile := UserProfile{\n\t\t\tName:                u.Name,\n\t\t\tNickName:            u.NickName,\n\t\t\tEmail:               u.Email,\n\t\t\tLanguage:            u.Language,\n\t\t\tResourcePermissions: permissions,\n\t\t\tIsAdministrator:     u.IsAdmin,\n\t\t\tMfa: Mfa{\n\t\t\t\tSecret:   u.Mfa.Secret,\n\t\t\t\tEnable:   u.Mfa.Enable,\n\t\t\t\tApproved: false,\n\t\t\t},\n\t\t}\n\n\t\tauthMethod := loginCredential.AuthMethod\n\n\t\tswitch authMethod {\n\t\tcase \"jwt\":\n\t\t\ttoken, err := h.jwtSigner.Sign(profile)\n\t\t\tif err != nil {\n\t\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\t\tctx.Values().Set(\"message\", err.Error())\n\t\t\t}\n\t\t\tctx.StatusCode(iris.StatusOK)\n\t\t\tctx.Values().Set(\"token\", token)\n\t\t\treturn\n\t\tdefault:\n\t\t\tsession := server.SessionMgr.Start(ctx)\n\t\t\tsession.Set(\"profile\", profile)\n\t\t}\n\n\t\tctx.StatusCode(iris.StatusOK)\n\t\tgo saveLoginLog(ctx, profile.Name)\n\t\tctx.Values().Set(\"data\", profile)\n\t}\n}\n\nfunc saveLoginLog(ctx *context.Context, userName string) {\n\tvar logItem v1System.LoginLog\n\tlogItem.UserName = userName\n\tlogItem.Ip = ctx.RemoteAddr()\n\tqqWry, err := ip.NewQQwry()\n\tif err != nil {\n\t\tserver.Logger().Errorf(\"load qqwry datas failed: %s\", err)\n\t}\n\tres := qqWry.Find(logItem.Ip)\n\tlogItem.City = res.Area\n\tsystemService := v1SystemService.NewService()\n\tsystemService.CreateLoginLog(&logItem, common.DBOptions{})\n}\n\nfunc (h *Handler) aggregateResourcePermissions(name string) (map[string][]string, error) {\n\tuserRoleBindings, err := h.rolebindingService.GetRoleBindingBySubject(v1Role.Subject{\n\t\tKind: \"User\",\n\t\tName: name,\n\t}, common.DBOptions{})\n\tif err != nil && !errors.As(err, &storm.ErrNotFound) {\n\t\treturn nil, err\n\t}\n\n\tvar roleNames []string\n\tfor i := range userRoleBindings {\n\t\troleNames = append(roleNames, userRoleBindings[i].RoleRef)\n\t}\n\n\trs, err := h.roleService.GetByNames(roleNames, common.DBOptions{})\n\tif err != nil && !errors.As(err, &storm.ErrNotFound) {\n\t\treturn nil, err\n\t}\n\tmapping := map[string]*collectons.StringSet{}\n\tvar policyRoles []v1Role.PolicyRule\n\t//merge permissions\n\tfor i := range rs {\n\t\tfor j := range rs[i].Rules {\n\t\t\tpolicyRoles = append(policyRoles, rs[i].Rules[j])\n\t\t}\n\t}\n\tfor i := range policyRoles {\n\t\tfor j := range policyRoles[i].Resource {\n\t\t\t_, ok := mapping[policyRoles[i].Resource[j]]\n\t\t\tif !ok {\n\t\t\t\tmapping[policyRoles[i].Resource[j]] = collectons.NewStringSet()\n\t\t\t}\n\t\t\tfor k := range policyRoles[i].Verbs {\n\t\t\t\tmapping[policyRoles[i].Resource[j]].Add(policyRoles[i].Verbs[k])\n\t\t\t\tif policyRoles[i].Verbs[k] == \"*\" {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif policyRoles[i].Resource[j] == \"*\" {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tresourceMapping := map[string][]string{}\n\tfor key := range mapping {\n\t\tresourceMapping[key] = mapping[key].ToSlice()\n\t}\n\treturn resourceMapping, nil\n}\n\nfunc (h *Handler) Logout() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tsession := server.SessionMgr.Start(ctx)\n\t\tloginUser := session.Get(\"profile\")\n\t\tif loginUser == nil {\n\t\t\tctx.StatusCode(iris.StatusUnauthorized)\n\t\t\tctx.Values().Set(\"message\", \"no login user\")\n\t\t\treturn\n\t\t}\n\t\tsession.Delete(\"profile\")\n\t\tlogging.LogSessions.Clean()\n\t\tterminal.TerminalSessions.Clean()\n\t\tctx.StatusCode(iris.StatusOK)\n\t\tctx.Values().Set(\"data\", \"logout success\")\n\t}\n}\n\nfunc (h *Handler) GetProfile() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tsession := server.SessionMgr.Start(ctx)\n\t\tloginUser := session.Get(\"profile\")\n\t\tif loginUser == nil {\n\t\t\tctx.StatusCode(iris.StatusUnauthorized)\n\t\t\tctx.Values().Set(\"message\", \"no login user\")\n\t\t\treturn\n\t\t}\n\t\tp, ok := loginUser.(UserProfile)\n\t\tif !ok {\n\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\tctx.Values().Set(\"message\", \"can not parse to session user\")\n\t\t\treturn\n\t\t}\n\n\t\tuser, err := h.userService.GetByNameOrEmail(p.Name, common.DBOptions{})\n\t\tif err != nil {\n\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\tctx.Values().Set(\"message\", err.Error())\n\t\t\treturn\n\t\t}\n\t\tp = UserProfile{\n\t\t\tName:            user.Name,\n\t\t\tNickName:        user.NickName,\n\t\t\tEmail:           user.Email,\n\t\t\tLanguage:        user.Language,\n\t\t\tIsAdministrator: user.IsAdmin,\n\t\t}\n\t\tif !user.IsAdmin {\n\t\t\tpermissions, err := h.aggregateResourcePermissions(p.Name)\n\t\t\tif err != nil {\n\t\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\t\tctx.Values().Set(\"message\", err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t\tp.ResourcePermissions = permissions\n\t\t}\n\t\tsession.Set(\"profile\", p)\n\t\tctx.StatusCode(iris.StatusOK)\n\t\tctx.Values().Set(\"data\", p)\n\t}\n}\n\nfunc (h *Handler) ListUserNamespace() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tname := ctx.Params().GetString(\"cluster_name\")\n\t\tc, err := h.clusterService.Get(name, common.DBOptions{})\n\t\tif err != nil {\n\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\tctx.Values().Set(\"message\", fmt.Sprintf(\"get cluster failed: %s\", err.Error()))\n\t\t\treturn\n\t\t}\n\t\tsession := server.SessionMgr.Start(ctx)\n\t\tu := session.Get(\"profile\")\n\t\tprofile := u.(UserProfile)\n\n\t\tk := kubernetes.NewKubernetes(c)\n\t\tns, err := k.GetUserNamespaceNames(profile.Name, profile.IsAdministrator)\n\t\tif err != nil {\n\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\tctx.Values().Set(\"message\", err)\n\t\t\treturn\n\t\t}\n\t\tctx.Values().Set(\"data\", ns)\n\t}\n}\n\nfunc (h *Handler) GetClusterProfile() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tsession := server.SessionMgr.Start(ctx)\n\t\tclusterName := ctx.Params().GetString(\"cluster_name\")\n\t\tnamesapce := ctx.URLParam(\"namespace\")\n\t\tc, err := h.clusterService.Get(clusterName, common.DBOptions{})\n\t\tif err != nil {\n\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\tctx.Values().Set(\"message\", err.Error())\n\t\t\treturn\n\t\t}\n\t\tk := kubernetes.NewKubernetes(c)\n\t\tclient, err := k.Client()\n\t\tif err != nil {\n\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\tctx.Values().Set(\"message\", fmt.Sprintf(\"get k8s client failed: %s\", err.Error()))\n\t\t\treturn\n\t\t}\n\t\tu := session.Get(\"profile\")\n\t\tprofile := u.(UserProfile)\n\n\t\tif profile.IsAdministrator {\n\t\t\tcrp := ClusterUserProfile{\n\t\t\t\tUserProfile:  profile,\n\t\t\t\tClusterRoles: []v1.ClusterRole{},\n\t\t\t}\n\t\t\tctx.Values().Set(\"data\", &crp)\n\t\t\treturn\n\t\t}\n\n\t\tlabels := []string{\n\t\t\tfmt.Sprintf(\"%s=%s\", kubernetes.LabelManageKey, \"kubepi\"),\n\t\t\tfmt.Sprintf(\"%s=%s\", kubernetes.LabelClusterId, c.UUID),\n\t\t\tfmt.Sprintf(\"%s=%s\", kubernetes.LabelUsername, profile.Name),\n\t\t}\n\t\tclusterRoleBindings, err := client.RbacV1().ClusterRoleBindings().List(goContext.TODO(), metav1.ListOptions{\n\t\t\tLabelSelector: strings.Join(labels, \",\"),\n\t\t})\n\t\tif err != nil {\n\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\tctx.Values().Set(\"message\", fmt.Sprintf(\"get cluster-role-binding failed: %s\", err.Error()))\n\t\t\treturn\n\t\t}\n\t\trolebindings, err := client.RbacV1().RoleBindings(namesapce).List(goContext.TODO(), metav1.ListOptions{\n\t\t\tLabelSelector: strings.Join(labels, \",\"),\n\t\t})\n\t\tif err != nil {\n\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\tctx.Values().Set(\"message\", fmt.Sprintf(\"get role-binding failed: %s\", err.Error()))\n\t\t\treturn\n\t\t}\n\t\troleSet := map[string]struct{}{}\n\t\tfor i := range clusterRoleBindings.Items {\n\t\t\tfor j := range clusterRoleBindings.Items[i].Subjects {\n\t\t\t\tif clusterRoleBindings.Items[i].Subjects[j].Kind == \"User\" {\n\t\t\t\t\troleSet[clusterRoleBindings.Items[i].RoleRef.Name] = struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor i := range rolebindings.Items {\n\t\t\tfor j := range rolebindings.Items[i].Subjects {\n\t\t\t\tif rolebindings.Items[i].Subjects[j].Kind == \"User\" {\n\t\t\t\t\troleSet[rolebindings.Items[i].RoleRef.Name] = struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar roles []v1.ClusterRole\n\t\tfor key := range roleSet {\n\t\t\tr, err := client.RbacV1().ClusterRoles().Get(goContext.TODO(), key, metav1.GetOptions{})\n\t\t\tif err != nil {\n\t\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\t\tctx.Values().Set(\"message\", fmt.Sprintf(\"get cluster-role failed: %s\", err.Error()))\n\t\t\t\treturn\n\t\t\t}\n\t\t\troles = append(roles, *r)\n\t\t}\n\n\t\tcrp := ClusterUserProfile{\n\t\t\tUserProfile:  profile,\n\t\t\tClusterRoles: roles,\n\t\t}\n\t\tif len(roles) <= 0 {\n\t\t\tctx.StatusCode(iris.StatusForbidden)\n\t\t\treturn\n\t\t}\n\t\tctx.Values().Set(\"data\", &crp)\n\t}\n}\n\nfunc Install(parent iris.Party) {\n\thandler := NewHandler()\n\tsp := parent.Party(\"/sessions\")\n\tsp.Post(\"\", handler.Login())\n\tsp.Delete(\"\", handler.Logout())\n\tsp.Get(\"\", handler.GetProfile())\n\tsp.Get(\"/:cluster_name\", handler.GetClusterProfile())\n\tsp.Get(\"/status\", handler.IsLogin())\n\tsp.Get(\"/:cluster_name/namespaces\", handler.ListUserNamespace())\n\tsp.Put(\"\", handler.UpdateProfile())\n\tsp.Put(\"/password\", handler.UpdatePassword())\n}\n", "package v1\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"strings\"\n\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/mfa\"\n\t\"github.com/KubeOperator/kubepi/internal/server\"\n\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/file\"\n\t\"github.com/kataras/iris/v12/middleware/jwt\"\n\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/chart\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/cluster\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/imagerepo\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/ldap\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/proxy\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/role\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/session\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/system\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/user\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/webkubectl\"\n\t\"github.com/KubeOperator/kubepi/internal/api/v1/ws\"\n\tv1 \"github.com/KubeOperator/kubepi/internal/model/v1\"\n\tv1Role \"github.com/KubeOperator/kubepi/internal/model/v1/role\"\n\tv1System \"github.com/KubeOperator/kubepi/internal/model/v1/system\"\n\t\"github.com/KubeOperator/kubepi/internal/service/v1/common\"\n\tv1RoleService \"github.com/KubeOperator/kubepi/internal/service/v1/role\"\n\tv1RoleBindingService \"github.com/KubeOperator/kubepi/internal/service/v1/rolebinding\"\n\tv1SystemService \"github.com/KubeOperator/kubepi/internal/service/v1/system\"\n\tpkgV1 \"github.com/KubeOperator/kubepi/pkg/api/v1\"\n\t\"github.com/KubeOperator/kubepi/pkg/collectons\"\n\t\"github.com/KubeOperator/kubepi/pkg/i18n\"\n\t\"github.com/asdine/storm/v3\"\n\t\"github.com/kataras/iris/v12\"\n\t\"github.com/kataras/iris/v12/context\"\n\t\"github.com/kataras/iris/v12/core/router\"\n)\n\nvar resourceWhiteList = WhiteList{\"sessions\", \"proxy\", \"ws\", \"charts\", \"webkubectl\", \"apps\", \"mfa\", \"pod\"}\n\ntype WhiteList []string\n\nfunc (w WhiteList) In(name string) bool {\n\tfor i := range w {\n\t\tif w[i] == name {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc authHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tvar p session.UserProfile\n\t\tif ctx.GetHeader(\"Authorization\") != \"\" {\n\t\t\tpr := jwt.Get(ctx).(*session.UserProfile)\n\t\t\tp = *pr\n\n\t\t} else {\n\t\t\tp = server.SessionMgr.Start(ctx).Get(\"profile\").(session.UserProfile)\n\t\t}\n\t\tif p.Name == \"\" {\n\t\t\tctx.Values().Set(\"message\", \"please login\")\n\t\t\tctx.StopWithStatus(iris.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tctx.Values().Set(\"profile\", p)\n\t\tctx.Next()\n\t}\n}\n\nfunc langHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tp := ctx.Values().Get(\"profile\")\n\t\tu, ok := p.(session.UserProfile)\n\t\tlang := i18n.LanguageZhCN\n\t\tif ok {\n\t\t\tlang = u.Language\n\t\t}\n\t\tctx.Values().Set(\"language\", lang)\n\t\tctx.Next()\n\t}\n}\n\nfunc pageHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tif ctx.URLParamExists(pkgV1.PageSize) && ctx.URLParamExists(pkgV1.PageNum) {\n\t\t\tpageNum, err := ctx.URLParamInt(pkgV1.PageNum)\n\t\t\tif err != nil {\n\t\t\t\tctx.Values().Set(\"message\", fmt.Sprintf(\"page num format err %s\", err.Error()))\n\t\t\t\tctx.StopWithStatus(iris.StatusBadRequest)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tpageSize, err := ctx.URLParamInt(pkgV1.PageSize)\n\t\t\tif err != nil {\n\t\t\t\tctx.Values().Set(\"message\", fmt.Sprintf(\"page size format err %s\", err.Error()))\n\t\t\t\tctx.StopWithStatus(iris.StatusBadRequest)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tctx.Values().Set(pkgV1.PageNum, pageNum)\n\t\t\tctx.Values().Set(pkgV1.PageSize, pageSize)\n\t\t}\n\t\tctx.Next()\n\t}\n}\n\ntype logHelper struct {\n\tName     string `json:\"name\"`\n\tMetadata v1.Metadata\n}\n\nfunc logHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tmethod := strings.ToLower(ctx.Method())\n\t\tif method != \"post\" && method != \"delete\" && method != \"put\" {\n\t\t\tctx.Next()\n\t\t\treturn\n\t\t}\n\n\t\tresourceName := ctx.Values().GetString(\"resource\")\n\t\tif resourceName == \"\" || resourceWhiteList.In(resourceName) {\n\t\t\tctx.Next()\n\t\t\treturn\n\t\t}\n\n\t\tcurrentPath := ctx.GetCurrentRoute().Path()\n\t\tpath := strings.Replace(ctx.Request().URL.Path, \"/kubepi/api/v1/\", \"\", 1)\n\t\tcurrentPath = strings.Replace(currentPath, \"/kubepi/api/v1/\", \"\", 1)\n\t\tif strings.HasSuffix(path, \"search\") {\n\t\t\tctx.Next()\n\t\t\treturn\n\t\t}\n\n\t\tu := ctx.Values().Get(\"profile\")\n\t\tprofile := u.(session.UserProfile)\n\t\tvar log v1System.OperationLog\n\t\tlog.Operator = profile.Name\n\t\tlog.Operation = method\n\n\t\t//handle ldap operate\n\t\tif strings.Contains(path, \"ldap\") {\n\t\t\tif strings.Contains(path, \"import\") {\n\t\t\t\tlog.Operation = \"import\"\n\t\t\t}\n\t\t\tif strings.Contains(path, \"sync\") {\n\t\t\t\tlog.Operation = \"sync\"\n\t\t\t}\n\t\t\tif strings.Contains(path, \"connect\") {\n\t\t\t\tlog.Operation = \"testConnect\"\n\t\t\t}\n\t\t\tif strings.Contains(path, \"login\") {\n\t\t\t\tlog.Operation = \"testLogin\"\n\t\t\t}\n\t\t}\n\n\t\tpathResource := strings.Split(path, \"/\")\n\t\tif strings.HasPrefix(currentPath, \"clusters/:name\") {\n\t\t\tif len(pathResource) < 3 {\n\t\t\t\tlog.OperationDomain = pathResource[0]\n\t\t\t\tif method != \"post\" {\n\t\t\t\t\tlog.SpecificInformation = pathResource[1]\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlog.OperationDomain = fmt.Sprintf(\"%s_%s\", pathResource[0], pathResource[2])\n\t\t\t\tif method != \"post\" {\n\t\t\t\t\tif len(pathResource) > 3 {\n\t\t\t\t\t\tlog.SpecificInformation = fmt.Sprintf(\"[%s] %s\", pathResource[1], pathResource[3])\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlog.SpecificInformation = fmt.Sprintf(\"[%s] %s\", pathResource[1], \"-\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlog.OperationDomain = strings.Split(currentPath, \"/\")[0]\n\t\t\tif method != \"post\" {\n\t\t\t\tif len(pathResource) > 1 {\n\t\t\t\t\tlog.SpecificInformation = pathResource[1]\n\t\t\t\t} else {\n\t\t\t\t\tlog.SpecificInformation = \"-\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif !strings.Contains(currentPath, \"upload\") {\n\t\t\tif method == \"post\" {\n\t\t\t\tvar req logHelper\n\t\t\t\tdata, _ := ctx.GetBody()\n\t\t\t\tif err := json.Unmarshal(data, &req); err != nil {\n\t\t\t\t\tctx.Next()\n\t\t\t\t}\n\t\t\t\tif len(req.Name) == 0 {\n\t\t\t\t\treq.Name = req.Metadata.Name\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(currentPath, \"clusters/:name\") {\n\t\t\t\t\tlog.SpecificInformation = fmt.Sprintf(\"[%s] %s\", pathResource[1], req.Name)\n\t\t\t\t} else {\n\t\t\t\t\tlog.SpecificInformation = req.Name\n\t\t\t\t}\n\t\t\t\tctx.Request().Body = ioutil.NopCloser(bytes.NewBuffer(data))\n\t\t\t}\n\t\t}\n\t\tsystemService := v1SystemService.NewService()\n\t\tgo systemService.CreateOperationLog(&log, common.DBOptions{})\n\t\tctx.Next()\n\t}\n}\n\nfunc resourceExtractHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tpath := ctx.Request().URL.Path\n\t\tss := strings.Split(path, \"/\")\n\t\t// \"\" \"api\" \"v1\" \"resource\"\n\t\tif len(ss) >= 5 {\n\t\t\tctx.Values().Set(\"resource\", ss[4])\n\t\t}\n\t\tctx.Next()\n\t}\n}\n\nfunc roleHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\t// \u67e5\u8be2\u5f53\u524d\u7528\u6237\u7684\u89d2\u8272\n\t\t// \u67e5\u8be2\u89d2\u8272\u7684 rolebinding \u83b7\u53d6 roles\n\t\tp := ctx.Values().Get(\"profile\")\n\t\tu := p.(session.UserProfile)\n\n\t\tif u.IsAdministrator {\n\t\t\tctx.Next()\n\t\t\treturn\n\t\t}\n\t\troleBindingService := v1RoleBindingService.NewService()\n\t\trbs, err := roleBindingService.GetRoleBindingBySubject(v1Role.Subject{\n\t\t\tKind: \"User\",\n\t\t\tName: u.Name,\n\t\t}, common.DBOptions{})\n\t\tif err != nil {\n\t\t\tif !errors.As(err, &storm.ErrNotFound) {\n\t\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\t\tctx.Values().Set(\"message\", err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\troleNameHash := map[string]struct{}{}\n\t\tfor i := range rbs {\n\t\t\troleName := rbs[i].RoleRef\n\t\t\troleNameHash[roleName] = struct{}{}\n\t\t}\n\t\tvar roleNames []string\n\t\tfor key := range roleNameHash {\n\t\t\troleNames = append(roleNames, key)\n\t\t}\n\n\t\troleService := v1RoleService.NewService()\n\t\trs, err := roleService.GetByNames(roleNames, common.DBOptions{})\n\t\tif err != nil {\n\t\t\tctx.StatusCode(iris.StatusInternalServerError)\n\t\t\tctx.Values().Set(\"message\", err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tctx.Values().Set(\"roles\", rs)\n\t\tctx.Next()\n\t}\n}\n\nfunc getVerbByRoute(path, method string) string {\n\tswitch strings.ToLower(method) {\n\tcase \"put\":\n\t\treturn \"update\"\n\tcase \"delete\":\n\t\treturn \"delete\"\n\tcase \"get\":\n\t\tif strings.Contains(path, \"/:name\") {\n\t\t\treturn \"get\"\n\t\t} else {\n\t\t\treturn \"list\"\n\t\t}\n\tcase \"post\":\n\t\tif strings.HasSuffix(path, \"search\") {\n\t\t\treturn \"list\"\n\t\t}\n\t\treturn \"create\"\n\n\t}\n\treturn \"\"\n}\n\nfunc apiResourceHandler(party iris.Party) iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\t//1. \u786e\u5b9a\u6240\u6709\u7684api\u8d44\u6e90\u6709\u54ea\u4e9b\n\t\tapiBuilder := party.(*router.APIBuilder)\n\t\troutes := apiBuilder.GetRoutes()\n\t\tresourceMap := map[string]*collectons.StringSet{}\n\t\tfor i := range routes {\n\t\t\tif strings.HasPrefix(routes[i].Path, \"/kubepi/api/v1/\") {\n\t\t\t\tss := strings.Split(routes[i].Path, \"/\")\n\t\t\t\tif len(ss) >= 5 {\n\t\t\t\t\tresourceName := ss[4]\n\t\t\t\t\t//\u8fc7\u6ee4session\u8d44\u6e90\n\t\t\t\t\tif resourceWhiteList.In(resourceName) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif _, ok := resourceMap[resourceName]; !ok {\n\t\t\t\t\t\tresourceMap[resourceName] = collectons.NewStringSet()\n\t\t\t\t\t}\n\t\t\t\t\tresourceMap[resourceName].Add(getVerbByRoute(routes[i].Path, routes[i].Method))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdisplayMap := map[string][]string{}\n\t\tfor k := range resourceMap {\n\t\t\tverbs := resourceMap[k]\n\t\t\tif len(verbs.ToSlice()) > 0 {\n\t\t\t\tdisplayMap[k] = verbs.ToSlice()\n\t\t\t}\n\t\t}\n\t\tif ops, ok := displayMap[\"clusters\"]; ok {\n\t\t\tops = append(ops, \"authorization\")\n\t\t\tdisplayMap[\"clusters\"] = ops\n\t\t}\n\t\tctx.Values().Set(\"data\", displayMap)\n\t}\n}\n\nfunc roleAccessHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\t//// \u67e5\u8be2\u89d2\u8272\u7684 resources\n\t\t//// \u901a\u8fc7api resource \u8fc7\u6ee4\u51fa\u6765\u8d44\u6e90\u4e3b\u4f53,method \u8fc7\u6ee4\u64cd\u4f5c\n\t\tp := ctx.Values().Get(\"profile\")\n\t\tu := p.(session.UserProfile)\n\t\tisInWhiteList := false\n\t\tfor _, path := range resourceWhiteList {\n\t\t\tif strings.Contains(ctx.Request().URL.Path, fmt.Sprintf(\"/%s\", path)) && path != \"sessions\" {\n\t\t\t\tisInWhiteList = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isInWhiteList {\n\t\t\t// \u653e\u901aadmin\u6743\u9650\n\t\t\tif u.IsAdministrator {\n\t\t\t\tctx.Next()\n\t\t\t\treturn\n\t\t\t}\n\t\t\trs := ctx.Values().Get(\"roles\")\n\t\t\troles := rs.([]v1Role.Role)\n\t\t\trequestResource := ctx.Values().GetString(\"resource\")\n\t\t\tif requestResource != \"\" {\n\t\t\t\tcurrentRoute := ctx.GetCurrentRoute()\n\t\t\t\trequestVerb := getVerbByRoute(currentRoute.Path(), currentRoute.Method())\n\t\t\t\tresourceMatched, methodMatch := matchRoles(requestResource, requestVerb, roles)\n\t\t\t\tif !(resourceMatched && methodMatch) {\n\t\t\t\t\tctx.StopWithStatus(iris.StatusForbidden)\n\t\t\t\t\tctx.Values().Set(\"message\", []string{\"user %s can not access resource %s %s\", u.Name, requestResource, requestVerb})\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tctx.Next()\n\t}\n}\n\nfunc matchRoles(requestResource, requestMethod string, rs []v1Role.Role) (bool, bool) {\n\tresourceMatch := false\n\tmethodMatch := false\n\tfor i := range rs {\n\t\tfor j := range rs[i].Rules {\n\t\t\tfor k := range rs[i].Rules[j].Resource {\n\t\t\t\tif rs[i].Rules[j].Resource[k] == requestResource || rs[i].Rules[j].Resource[k] == \"*\" {\n\t\t\t\t\tresourceMatch = true\n\t\t\t\t\tfor x := range rs[i].Rules[j].Verbs {\n\t\t\t\t\t\tif rs[i].Rules[j].Verbs[x] == requestMethod || rs[i].Rules[j].Verbs[x] == \"*\" {\n\t\t\t\t\t\t\tmethodMatch = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn resourceMatch, methodMatch\n}\n\nfunc resourceNameInvalidHandler() iris.Handler {\n\treturn func(ctx *context.Context) {\n\t\tr := ctx.GetCurrentRoute()\n\t\tif strings.Contains(r.Path(), \"/:name\") {\n\t\t\tresourceName := ctx.Params().GetString(\"name\")\n\t\t\tif resourceName == \"\" {\n\t\t\t\tctx.StatusCode(iris.StatusBadRequest)\n\t\t\t\tctx.Values().Set(\"message\", fmt.Sprintf(\"invalid resource name %s\", resourceName))\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tctx.Next()\n\t}\n}\n\nfunc WarpedJwtHandler() iris.Handler {\n\tverifier := jwt.NewVerifier(jwt.HS256, server.Config().Spec.Jwt.Key)\n\tverifier.WithDefaultBlocklist()\n\tverifyMiddleware := verifier.Verify(func() interface{} {\n\t\treturn new(session.UserProfile)\n\t})\n\treturn func(ctx *context.Context) {\n\t\tsess := server.SessionMgr.Start(ctx)\n\t\tif sess.Get(\"profile\") != nil {\n\t\t\tctx.Next()\n\t\t\treturn\n\t\t}\n\t\tverifyMiddleware(ctx)\n\t}\n}\n\nfunc AddV1Route(app iris.Party) {\n\n\tv1Party := app.Party(\"/v1\")\n\tv1Party.Use(langHandler())\n\tv1Party.Use(pageHandler())\n\tsession.Install(v1Party)\n\tmfa.Install(v1Party)\n\tauthParty := v1Party.Party(\"\")\n\n\tauthParty.Use(WarpedJwtHandler())\n\tauthParty.Use(authHandler())\n\tauthParty.Use(resourceExtractHandler())\n\tauthParty.Use(roleHandler())\n\tauthParty.Use(roleAccessHandler())\n\tauthParty.Use(resourceNameInvalidHandler())\n\tauthParty.Use(logHandler())\n\tauthParty.Get(\"/\", apiResourceHandler(authParty))\n\tuser.Install(authParty)\n\tcluster.Install(authParty)\n\trole.Install(authParty)\n\tsystem.Install(v1Party)\n\tproxy.Install(authParty)\n\tws.Install(authParty)\n\tchart.Install(authParty)\n\twebkubectl.Install(authParty, v1Party)\n\tldap.Install(authParty)\n\timagerepo.Install(authParty)\n\tfile.Install(authParty)\n}\n", "package config\n\nimport (\n\t\"crypto/rand\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"github.com/KubeOperator/kubepi/internal/model/v1/config\"\n\t\"github.com/KubeOperator/kubepi/pkg/file\"\n\t\"github.com/coreos/etcd/pkg/fileutil\"\n\t\"github.com/spf13/viper\"\n\t\"math/big\"\n\t\"strconv\"\n)\n\nconst configNotFoundSkipErr = \"config file not found in %s, skip\"\nconst configReadErr = \"can not read config file %s ,%s\"\nconst configMergeErr = \"can not merge config file, %s\"\n\nvar configFilePaths = []string{\n\t\"/etc/kubepi\",\n}\n\nfunc ReadConfig(c *config.Config, path ...string) error {\n\tv := viper.New()\n\tv.SetConfigName(\"app\")\n\tv.SetConfigType(\"yaml\")\n\n\tfor i := range path {\n\t\tconfigFilePaths = append(configFilePaths, path[i])\n\t}\n\tfor i := range configFilePaths {\n\t\trealDir := file.ReplaceHomeDir(configFilePaths[i])\n\n\t\tif exists := fileutil.Exist(realDir); !exists {\n\t\t\tfmt.Println(fmt.Sprintf(configNotFoundSkipErr, realDir))\n\t\t\tcontinue\n\t\t}\n\n\t\tv.AddConfigPath(realDir)\n\t\tif err := v.ReadInConfig(); err != nil {\n\t\t\tfmt.Println(fmt.Sprintf(configReadErr, realDir, err.Error()))\n\t\t\tcontinue\n\t\t}\n\t\tif err := v.MergeInConfig(); err != nil {\n\t\t\tfmt.Println(fmt.Sprintf(configMergeErr, configFilePaths))\n\t\t}\n\n\t}\n\n\tvar configMap map[string]interface{}\n\tif err := v.Unmarshal(&configMap); err != nil {\n\t\treturn err\n\t}\n\tstr, err := json.Marshal(&configMap)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := json.Unmarshal(str, &c); err != nil {\n\t\treturn nil\n\t}\n\tif c.Spec.Jwt.Key == \"\" {\n\t\tv.Set(\"spec.jwt.key\", generate(32))\n\t\tif err := v.WriteConfig(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc generate(length int) string {\n\tconst base = 36\n\tsize := big.NewInt(base)\n\tn := make([]byte, length)\n\tfor i := range n {\n\t\tc, _ := rand.Int(rand.Reader, size)\n\t\tn[i] = strconv.FormatInt(c.Int64(), base)[0]\n\t}\n\treturn string(n)\n}\n", "package config\n\nimport v1 \"github.com/KubeOperator/kubepi/internal/model/v1\"\n\ntype Config struct {\n\tv1.BaseModel\n\tv1.Metadata\n\tSpec Spec `json:\"spec\"`\n}\ntype Spec struct {\n\tServer  ServerConfig  `json:\"server\"`\n\tDB      DBConfig      `json:\"db\"`\n\tSession SessionConfig `json:\"session\"`\n\tLogger  LoggerConfig  `json:\"logger\"`\n\tJwt     JwtConfig     `json:\"jwt\"`\n\tAppId   string        `json:\"appId\"`\n}\n\ntype ServerConfig struct {\n\tBind BindConfig `json:\"bind\"`\n\tSSL  SSLConfig  `json:\"ssl\"`\n}\n\ntype BindConfig struct {\n\tHost string `json:\"host\"`\n\tPort int    `json:\"port\"`\n}\n\ntype SSLConfig struct {\n\tEnable         bool   `json:\"enable\"`\n\tCertificate    string `json:\"certificate\"`\n\tCertificateKey string `json:\"certificateKey\"`\n}\n\ntype LoggerConfig struct {\n\tLevel string\n}\n\ntype DBConfig struct {\n\tPath string `json:\"path\"`\n}\n\ntype SessionConfig struct {\n\tExpires int `json:\"expires\"`\n}\n\ntype JwtConfig struct {\n\tKey string `json:\"key\"`\n}\n", "package server\n\nimport (\n\t\"embed\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/iris-contrib/swagger/v12\"\n\t\"github.com/iris-contrib/swagger/v12/swaggerFiles\"\n\n\tv1 \"github.com/KubeOperator/kubepi/internal/model/v1\"\n\t\"k8s.io/klog/v2\"\n\n\t\"github.com/KubeOperator/kubepi/internal/config\"\n\tv1Config \"github.com/KubeOperator/kubepi/internal/model/v1/config\"\n\t\"github.com/KubeOperator/kubepi/migrate\"\n\t\"github.com/KubeOperator/kubepi/pkg/file\"\n\t\"github.com/KubeOperator/kubepi/pkg/i18n\"\n\t\"github.com/asdine/storm/v3\"\n\t\"github.com/coreos/etcd/pkg/fileutil\"\n\t\"github.com/kataras/iris/v12\"\n\t\"github.com/kataras/iris/v12/context\"\n\t\"github.com/kataras/iris/v12/sessions\"\n\t\"github.com/kataras/iris/v12/view\"\n\t\"github.com/sirupsen/logrus\"\n)\n\nconst sessionCookieName = \"SESS_COOKIE_KUBEPI\"\n\nvar SessionMgr *sessions.Sessions\n\nvar EmbedWebKubePi embed.FS\nvar EmbedWebDashboard embed.FS\nvar EmbedWebTerminal embed.FS\nvar WebkubectlEntrypoint string\n\ntype Option func(server *KubePiServer)\n\nfunc WithServerBindHost(host string) Option {\n\treturn func(server *KubePiServer) {\n\t\tif host != \"\" {\n\t\t\tserver.config.Spec.Server.Bind.Host = host\n\t\t}\n\t}\n}\n\nfunc WithServerBindPort(port int) Option {\n\treturn func(server *KubePiServer) {\n\t\tif port != 0 {\n\t\t\tserver.config.Spec.Server.Bind.Port = port\n\t\t}\n\t}\n}\n\nfunc WithCustomConfigFilePath(path string) Option {\n\treturn func(server *KubePiServer) {\n\t\tif path != \"\" {\n\t\t\tserver.configCustomFilePath = path\n\t\t}\n\t}\n}\n\ntype KubePiServer struct {\n\tapp                  *iris.Application\n\tdb                   *storm.DB\n\tlogger               *logrus.Logger\n\tconfigCustomFilePath string\n\tconfig               *v1Config.Config\n\trootRoute            iris.Party\n}\n\nfunc NewKubePiSerer(opts ...Option) *KubePiServer {\n\tc := &KubePiServer{}\n\tc.app = iris.New()\n\tc.config = getDefaultConfig()\n\tfor _, op := range opts {\n\t\top(c)\n\t}\n\tc.setUpConfig()\n\tfor _, op := range opts {\n\t\top(c)\n\t}\n\treturn c.bootstrap()\n}\n\nfunc (e *KubePiServer) setUpConfig() {\n\terr := config.ReadConfig(e.config, e.configCustomFilePath)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc (e *KubePiServer) setUpLogger() {\n\tklog.SetLogger(TodoLogger{})\n\te.logger = logrus.New()\n\tl, err := logrus.ParseLevel(e.config.Spec.Logger.Level)\n\tif err != nil {\n\t\te.logger.Errorf(\"cant not parse logger level %s, %s,use default level: INFO\", e.config.Spec.Logger.Level, err)\n\t}\n\te.logger.SetLevel(l)\n}\n\nfunc (e *KubePiServer) setUpDB() {\n\trealDir := file.ReplaceHomeDir(e.config.Spec.DB.Path)\n\tif !fileutil.Exist(realDir) {\n\t\tif err := os.MkdirAll(realDir, 0755); err != nil {\n\t\t\tpanic(fmt.Errorf(\"can not create database dir: %s message: %s\", e.config.Spec.DB.Path, err))\n\t\t}\n\t}\n\td, err := storm.Open(path.Join(realDir, \"kubepi.db\"))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\te.db = d\n}\n\nfunc (e *KubePiServer) setUpRootRoute() {\n\te.app.Any(\"/\", func(ctx *context.Context) {\n\t\tctx.Redirect(\"/kubepi\")\n\t})\n\tc := swagger.Config{\n\t\tURL: \"/kubepi/swagger/doc.json\",\n\t}\n\te.app.Get(\"/kubepi/swagger/{any:path}\", swagger.CustomWrapHandler(&c, swaggerFiles.Handler))\n\te.rootRoute = e.app.Party(\"/kubepi\")\n}\n\nfunc (e *KubePiServer) setUpStaticFile() {\n\tspaOption := iris.DirOptions{SPA: true, IndexName: \"index.html\"}\n\tparty := e.rootRoute.Party(\"/\")\n\tparty.Use(iris.Compression)\n\tdashboardFS := iris.PrefixDir(\"web/dashboard\", http.FS(EmbedWebDashboard))\n\tparty.RegisterView(view.HTML(dashboardFS, \".html\"))\n\tparty.HandleDir(\"/dashboard/\", dashboardFS, spaOption)\n\n\tterminalFS := iris.PrefixDir(\"web/terminal\", http.FS(EmbedWebTerminal))\n\tparty.RegisterView(view.HTML(terminalFS, \".html\"))\n\tparty.HandleDir(\"/terminal/\", terminalFS, spaOption)\n\n\tkubePiFS := iris.PrefixDir(\"web/kubepi\", http.FS(EmbedWebKubePi))\n\tparty.RegisterView(view.HTML(kubePiFS, \".html\"))\n\tparty.HandleDir(\"/\", kubePiFS, spaOption)\n}\n\nfunc (e *KubePiServer) setUpSession() {\n\tSessionMgr = sessions.New(sessions.Config{Cookie: sessionCookieName, AllowReclaim: true, Expires: time.Duration(e.config.Spec.Session.Expires) * time.Hour})\n\te.rootRoute.Use(SessionMgr.Handler())\n}\n\nconst ContentTypeDownload = \"application/download\"\n\nfunc (e *KubePiServer) setResultHandler() {\n\te.rootRoute.Use(func(ctx *context.Context) {\n\t\tctx.Next()\n\t\tcontentType := ctx.ResponseWriter().Header().Get(\"Content-Type\")\n\t\tif contentType == ContentTypeDownload {\n\t\t\treturn\n\t\t}\n\t\tisProxyPath := func() bool {\n\t\t\tp := ctx.GetCurrentRoute().Path()\n\t\t\tss := strings.Split(p, \"/\")\n\t\t\tif len(ss) > 0 {\n\t\t\t\tif ss[0] == \"webkubectl\" {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t\tif len(ss) >= 3 {\n\t\t\t\tfor i := range ss {\n\t\t\t\t\tif ss[i] == \"proxy\" || ss[i] == \"ws\" {\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false\n\t\t}()\n\t\tif !isProxyPath {\n\t\t\tif ctx.GetStatusCode() >= iris.StatusOK && ctx.GetStatusCode() < iris.StatusBadRequest {\n\t\t\t\tif ctx.Values().Get(\"token\") != nil {\n\t\t\t\t\t_, _ = ctx.Write(ctx.Values().Get(\"token\").([]uint8))\n\t\t\t\t} else {\n\t\t\t\t\tresp := iris.Map{\n\t\t\t\t\t\t\"success\": true,\n\t\t\t\t\t\t\"data\":    ctx.Values().Get(\"data\"),\n\t\t\t\t\t}\n\t\t\t\t\t_, _ = ctx.JSON(resp)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc (e *KubePiServer) setUpErrHandler() {\n\te.rootRoute.OnAnyErrorCode(func(ctx iris.Context) {\n\t\tif ctx.Values().GetString(\"message\") == \"\" {\n\t\t\tswitch ctx.GetStatusCode() {\n\t\t\tcase iris.StatusNotFound:\n\t\t\t\tctx.Values().Set(\"message\", \"the server could not find the requested resource\")\n\t\t\t}\n\t\t}\n\t\tmessage := ctx.Values().Get(\"message\")\n\t\tif message == nil || message == \"\" {\n\t\t\tmessage = ctx.Values().Get(\"iris.context.error\")\n\t\t}\n\n\t\tlang := ctx.Values().GetString(\"language\")\n\t\tvar (\n\t\t\ttranslateMessage string\n\t\t\terr              error\n\t\t\toriginMessage    string\n\t\t)\n\n\t\tswitch value := message.(type) {\n\t\tcase string:\n\t\t\toriginMessage = message.(string)\n\t\t\ttranslateMessage, err = i18n.Translate(lang, value)\n\t\tcase []string:\n\t\t\toriginMessage = strings.Join(value, \",\")\n\t\t\tif len(value) > 0 {\n\t\t\t\ttranslateMessage, err = i18n.Translate(lang, value[0], value[1:])\n\t\t\t}\n\t\tcase context.ErrPrivate:\n\t\t\terr := message.(context.ErrPrivate)\n\t\t\ttranslateMessage = err.Error()\n\t\t}\n\t\tmsg := translateMessage\n\t\tif err != nil {\n\t\t\te.app.Logger().Debug(err)\n\t\t\tmsg = originMessage\n\t\t}\n\t\ter := iris.Map{\n\t\t\t\"success\": false,\n\t\t\t\"code\":    ctx.GetStatusCode(),\n\t\t\t\"message\": msg,\n\t\t}\n\t\t_, _ = ctx.JSON(er)\n\t})\n}\n\nfunc (e *KubePiServer) runMigrations() {\n\tmigrate.RunMigrate(e.db, e.logger)\n}\nfunc (e *KubePiServer) setWebkubectlProxy() {\n\thandler := func(ctx *context.Context) {\n\t\tp := ctx.Params().Get(\"p\")\n\t\tif strings.Contains(p, \"root\") {\n\t\t\tctx.Request().URL.Path = strings.ReplaceAll(ctx.Request().URL.Path, \"root\", \"\")\n\t\t\tctx.Request().RequestURI = strings.ReplaceAll(ctx.Request().RequestURI, \"root\", \"\")\n\t\t}\n\t\tu, _ := url.Parse(\"http://localhost:8080\")\n\t\tproxy := httputil.NewSingleHostReverseProxy(u)\n\t\tproxy.ModifyResponse = func(resp *http.Response) error {\n\t\t\tif resp.StatusCode == iris.StatusMovedPermanently {\n\t\t\t\t// \u91cd\u5b9a\u5411\u91cd\u5199\n\t\t\t\tif resp.Header.Get(\"Location\") == \"/kubepi/webkubectl/\" {\n\t\t\t\t\tresp.Header.Set(\"Location\", \"/kubepi/webkubectl/root\")\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\tproxy.ServeHTTP(ctx.ResponseWriter(), ctx.Request())\n\t}\n\te.rootRoute.Any(\"/webkubectl/{p:path}\", handler)\n\te.rootRoute.Any(\"webkubectl\", handler)\n}\n\nfunc (e *KubePiServer) setUpTtyEntrypoint() {\n\tf, err := os.OpenFile(\"init-kube.sh\", os.O_CREATE|os.O_RDWR, 0755)\n\tif err != nil {\n\t\te.logger.Error(err)\n\t\treturn\n\t}\n\tif _, err := f.WriteString(WebkubectlEntrypoint); err != nil {\n\t\te.logger.Error(err)\n\t\treturn\n\t}\n}\n\nfunc (e *KubePiServer) bootstrap() *KubePiServer {\n\te.setUpRootRoute()\n\te.setUpStaticFile()\n\te.setUpLogger()\n\te.setUpDB()\n\te.setUpSession()\n\te.setResultHandler()\n\te.setUpErrHandler()\n\te.setWebkubectlProxy()\n\te.runMigrations()\n\te.setUpTtyEntrypoint()\n\te.startTty()\n\treturn e\n}\n\nvar es *KubePiServer\n\nfunc DB() *storm.DB {\n\treturn es.db\n}\n\nfunc Config() *v1Config.Config {\n\treturn es.config\n}\n\nfunc Logger() *logrus.Logger {\n\treturn es.logger\n}\n\nfunc Listen(route func(party iris.Party), options ...Option) error {\n\tes = NewKubePiSerer(options...)\n\troute(es.rootRoute)\n\treturn es.app.Run(iris.Addr(fmt.Sprintf(\"%s:%d\", es.config.Spec.Server.Bind.Host, es.config.Spec.Server.Bind.Port)))\n}\n\nfunc getDefaultConfig() *v1Config.Config {\n\treturn &v1Config.Config{\n\t\tBaseModel: v1.BaseModel{\n\t\t\tApiVersion: \"v1\",\n\t\t\tKind:       \"AppConfig\",\n\t\t},\n\t\tMetadata: v1.Metadata{},\n\t\tSpec: v1Config.Spec{\n\t\t\tServer: v1Config.ServerConfig{\n\t\t\t\tBind: v1Config.BindConfig{\n\t\t\t\t\tHost: \"0.0.0.0\",\n\t\t\t\t\tPort: 80,\n\t\t\t\t},\n\t\t\t\tSSL: v1Config.SSLConfig{\n\t\t\t\t\tEnable: false,\n\t\t\t\t},\n\t\t\t},\n\t\t\tDB: v1Config.DBConfig{\n\t\t\t\tPath: \"/var/lib/kubepi/db\",\n\t\t\t},\n\t\t\tSession: v1Config.SessionConfig{\n\t\t\t\tExpires: 72,\n\t\t\t},\n\t\t\tLogger: v1Config.LoggerConfig{Level: \"debug\"},\n\t\t\tJwt:    v1Config.JwtConfig{},\n\t\t},\n\t}\n}\n"], "filenames": ["conf/app.yml", "internal/api/v1/session/session.go", "internal/api/v1/v1.go", "internal/config/config.go", "internal/model/v1/config/config.go", "internal/server/server.go"], "buggy_code_start_loc": [15, 35, 404, 3, 14, 342], "buggy_code_end_loc": [16, 55, 406, 59, 44, 342], "fixing_code_start_loc": [15, 34, 404, 4, 15, 343], "fixing_code_end_loc": [18, 54, 405, 80, 50, 344], "type": "CWE-798", "message": "KubePi is a k8s panel. The jwt authentication function of KubePi through version 1.6.2 uses hard-coded Jwtsigkeys, resulting in the same Jwtsigkeys for all online projects. This means that an attacker can forge any jwt token to take over the administrator account of any online project. Furthermore, they may use the administrator to take over the k8s cluster of the target enterprise. `session.go`, the use of hard-coded JwtSigKey, allows an attacker to use this value to forge jwt tokens arbitrarily. The JwtSigKey is confidential and should not be hard-coded in the code. The vulnerability has been fixed in 1.6.3. In the patch, JWT key is specified in app.yml. If the user leaves it blank, a random key will be used. There are no workarounds aside from upgrading.", "other": {"cve": {"id": "CVE-2023-22463", "sourceIdentifier": "security-advisories@github.com", "published": "2023-01-04T16:15:09.143", "lastModified": "2023-01-10T19:08:51.177", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "KubePi is a k8s panel. The jwt authentication function of KubePi through version 1.6.2 uses hard-coded Jwtsigkeys, resulting in the same Jwtsigkeys for all online projects. This means that an attacker can forge any jwt token to take over the administrator account of any online project. Furthermore, they may use the administrator to take over the k8s cluster of the target enterprise. `session.go`, the use of hard-coded JwtSigKey, allows an attacker to use this value to forge jwt tokens arbitrarily. The JwtSigKey is confidential and should not be hard-coded in the code. The vulnerability has been fixed in 1.6.3. In the patch, JWT key is specified in app.yml. If the user leaves it blank, a random key will be used. There are no workarounds aside from upgrading."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-798"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fit2cloud:kubepi:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.6.3", "matchCriteriaId": "433EBCCD-AD47-4115-8C3A-026360EBBBAB"}]}]}], "references": [{"url": "https://github.com/KubeOperator/KubePi/blob/da784f5532ea2495b92708cacb32703bff3a45a3/internal/api/v1/session/session.go#L35", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/KubeOperator/KubePi/commit/3be58b8df5bc05d2343c30371dd5fcf6a9fbbf8b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/KubeOperator/KubePi/releases/tag/v1.6.3", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/KubeOperator/KubePi/security/advisories/GHSA-vjhf-8vqx-vqpq", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/KubeOperator/KubePi/commit/3be58b8df5bc05d2343c30371dd5fcf6a9fbbf8b"}}