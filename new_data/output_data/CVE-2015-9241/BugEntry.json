{"buggy_code": ["'use strict';\n\n// Load modules\n\nconst Http = require('http');\nconst Stream = require('stream');\nconst Zlib = require('zlib');\nconst Ammo = require('ammo');\nconst Boom = require('boom');\nconst Hoek = require('hoek');\nconst Items = require('items');\nconst Shot = require('shot');\nconst Auth = require('./auth');\nconst Cors = require('./cors');\nconst Response = require('./response');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports.send = function (request, callback) {\n\n    const response = request.response;\n    if (response.isBoom) {\n        return internals.fail(request, response, callback);\n    }\n\n    internals.marshal(request, (err) => {\n\n        if (err) {\n            request._setResponse(err);\n            return internals.fail(request, err, callback);\n        }\n\n        return internals.transmit(response, callback);\n    });\n};\n\n\ninternals.marshal = function (request, next) {\n\n    const response = request.response;\n\n    Cors.headers(response);\n    internals.content(response);\n    internals.security(response);\n\n    if (response.statusCode !== 304 &&\n        (request.method === 'get' || request.method === 'head')) {\n\n        if (response.headers.etag &&\n            request.headers['if-none-match']) {\n\n            // Strong verifier\n\n            const ifNoneMatch = request.headers['if-none-match'].split(/\\s*,\\s*/);\n            for (let i = 0; i < ifNoneMatch.length; ++i) {\n                const etag = ifNoneMatch[i];\n                if (etag === response.headers.etag) {\n                    response.code(304);\n                    break;\n                }\n                else if (response.settings.varyEtag) {\n                    const etagBase = response.headers.etag.slice(0, -1);\n                    if (etag === etagBase + '-gzip\"' ||\n                        etag === etagBase + '-deflate\"') {\n\n                        response.code(304);\n                        break;\n                    }\n                }\n            }\n        }\n        else {\n            const ifModifiedSinceHeader = request.headers['if-modified-since'];\n            const lastModifiedHeader = response.headers['last-modified'];\n\n            if (ifModifiedSinceHeader &&\n                lastModifiedHeader) {\n\n                // Weak verifier\n\n                const ifModifiedSince = Date.parse(ifModifiedSinceHeader);\n                const lastModified = Date.parse(lastModifiedHeader);\n\n                if (ifModifiedSince &&\n                    lastModified &&\n                    ifModifiedSince >= lastModified) {\n\n                    response.code(304);\n                }\n            }\n        }\n    }\n\n    internals.state(response, (err) => {\n\n        if (err) {\n            request._log(['state', 'response', 'error'], err);\n            request._states = {};                                           // Clear broken state\n            return next(err);\n        }\n\n        internals.cache(response);\n\n        if (!response._isPayloadSupported()) {\n\n            // Close unused file streams\n\n            response._close();\n\n            // Set empty stream\n\n            response._payload = new internals.Empty();\n            if (request.method !== 'head') {\n                delete response.headers['content-length'];\n            }\n\n            return Auth.response(request, next);               // Must be last in case requires access to headers\n        }\n\n        response._marshal((err) => {\n\n            if (err) {\n                return next(Boom.wrap(err));\n            }\n\n            if (request.jsonp &&\n                response._payload.jsonp) {\n\n                response._header('content-type', 'text/javascript' + (response.settings.charset ? '; charset=' + response.settings.charset : ''));\n                response._header('x-content-type-options', 'nosniff');\n                response._payload.jsonp(request.jsonp);\n            }\n\n            if (response._payload.size &&\n                typeof response._payload.size === 'function') {\n\n                response._header('content-length', response._payload.size(), { override: false });\n            }\n\n            return Auth.response(request, next);               // Must be last in case requires access to headers\n        });\n    });\n};\n\n\ninternals.fail = function (request, boom, callback) {\n\n    const error = boom.output;\n    const response = new Response(error.payload, request);\n    response._error = boom;\n    response.code(error.statusCode);\n    response.headers = error.headers;\n    request.response = response;                            // Not using request._setResponse() to avoid double log\n\n    internals.marshal(request, (err) => {\n\n        if (err) {\n\n            // Failed to marshal an error - replace with minimal representation of original error\n\n            const minimal = {\n                statusCode: error.statusCode,\n                error: Http.STATUS_CODES[error.statusCode],\n                message: boom.message\n            };\n\n            response._payload = new Response.Payload(JSON.stringify(minimal), {});\n        }\n\n        return internals.transmit(response, callback);\n    });\n};\n\n\ninternals.transmit = function (response, callback) {\n\n    // Setup source\n\n    const request = response.request;\n    const source = response._payload;\n    const length = parseInt(response.headers['content-length'], 10);      // In case value is a string\n\n    // Empty response\n\n    if (length === 0 &&\n        response.statusCode === 200 &&\n        request.route.settings.response.emptyStatusCode === 204) {\n\n        response.code(204);\n        delete response.headers['content-length'];\n    }\n\n    // Compression\n\n    const mime = request.server.mime.type(response.headers['content-type'] || 'application/octet-stream');\n    let encoding = (request.connection.settings.compression && mime.compressible && !response.headers['content-encoding'] ? request.info.acceptEncoding : null);\n    encoding = (encoding === 'identity' ? null : encoding);\n\n    // Range\n\n    let ranger = null;\n    if (request.method === 'get' &&\n        response.statusCode === 200 &&\n        length > 0 &&\n        !encoding) {\n\n        if (request.headers.range) {\n\n            // Check If-Range\n\n            if (!request.headers['if-range'] ||\n                request.headers['if-range'] === response.headers.etag) {            // Ignoring last-modified date (weak)\n\n                // Parse header\n\n                const ranges = Ammo.header(request.headers.range, length);\n                if (!ranges) {\n                    const error = Boom.rangeNotSatisfiable();\n                    error.output.headers['content-range'] = 'bytes */' + length;\n                    return internals.fail(request, error, callback);\n                }\n\n                // Prepare transform\n\n                if (ranges.length === 1) {                                          // Ignore requests for multiple ranges\n                    const range = ranges[0];\n                    ranger = new Ammo.Stream(range);\n                    response.code(206);\n                    response.bytes(range.to - range.from + 1);\n                    response._header('content-range', 'bytes ' + range.from + '-' + range.to + '/' + length);\n                }\n            }\n        }\n\n        response._header('accept-ranges', 'bytes');\n    }\n\n    // Content-Encoding\n\n    if (request.headers['accept-encoding']) {\n        response.vary('accept-encoding');\n    }\n\n    let compressor = null;\n    if (encoding &&\n        length !== 0 &&\n        response._isPayloadSupported()) {\n\n        delete response.headers['content-length'];\n        response._header('content-encoding', encoding);\n\n        compressor = (encoding === 'gzip' ? Zlib.createGzip() : Zlib.createDeflate());\n    }\n\n    if ((response.headers['content-encoding'] || encoding) &&\n        response.headers.etag &&\n        response.settings.varyEtag) {\n\n        response.headers.etag = response.headers.etag.slice(0, -1) + '-' + (response.headers['content-encoding'] || encoding) + '\"';\n    }\n\n    // Write headers\n\n    const headers = Object.keys(response.headers);\n    for (let i = 0; i < headers.length; ++i) {\n        const header = headers[i];\n        const value = response.headers[header];\n        if (value !== undefined) {\n            request.raw.res.setHeader(header, value);\n        }\n    }\n\n    request.raw.res.writeHead(response.statusCode);\n\n    // Generate tap stream\n\n    const tap = response._tap();\n\n    // Write payload\n\n    let hasEnded = false;\n    const end = (err, event) => {\n\n        if (hasEnded) {\n            return;\n        }\n\n        hasEnded = true;\n\n        if (event !== 'aborted') {\n            request.raw.res.end();\n        }\n\n        source.removeListener('error', end);\n\n        request.raw.req.removeListener('aborted', onAborted);\n        request.raw.req.removeListener('close', onClose);\n\n        request.raw.res.removeListener('close', onClose);\n        request.raw.res.removeListener('error', end);\n        request.raw.res.removeListener('finish', end);\n\n        const tags = (err ? ['response', 'error']\n                        : (event ? ['response', 'error', event]\n                                 : ['response']));\n\n        if (event || err) {\n            request.emit('disconnect');\n        }\n\n        request._log(tags, err);\n        callback();\n    };\n\n    source.once('error', end);\n\n    const onAborted = () => {\n\n        end(null, 'aborted');\n    };\n\n    const onClose = () => {\n\n        end(null, 'close');\n    };\n\n    request.raw.req.once('aborted', onAborted);\n    request.raw.req.once('close', onClose);\n\n    request.raw.res.once('close', onClose);\n    request.raw.res.once('error', end);\n    request.raw.res.once('finish', end);\n\n    const preview = (tap ? source.pipe(tap) : source);\n    const compressed = (compressor ? preview.pipe(compressor) : preview);\n    const ranged = (ranger ? compressed.pipe(ranger) : compressed);\n    ranged.pipe(request.raw.res);\n\n    // Injection\n\n    if (Shot.isInjection(request.raw.req)) {\n        request.raw.res._hapi = {\n            request: request\n        };\n\n        if (response.variety === 'plain') {\n            request.raw.res._hapi.result = response._isPayloadSupported() ? response.source : null;\n        }\n    }\n};\n\n\ninternals.Empty = function () {\n\n    Stream.Readable.call(this);\n};\n\nHoek.inherits(internals.Empty, Stream.Readable);\n\n\ninternals.Empty.prototype._read = function (/* size */) {\n\n    this.push(null);\n};\n\n\ninternals.cache = function (response) {\n\n    if (response.headers['cache-control']) {\n        return;\n    }\n\n    const request = response.request;\n    const policy = request._route._cache && (request.route.settings.cache._statuses[response.statusCode] || (response.statusCode === 304 && request.route.settings.cache._statuses['200']));\n    if (policy ||\n        response.settings.ttl) {\n\n        const ttl = (response.settings.ttl !== null ? response.settings.ttl : request._route._cache.ttl());\n        const privacy = (request.auth.isAuthenticated || response.headers['set-cookie'] ? 'private' : request.route.settings.cache.privacy || 'default');\n        response._header('cache-control', 'max-age=' + Math.floor(ttl / 1000) + ', must-revalidate' + (privacy !== 'default' ? ', ' + privacy : ''));\n    }\n    else {\n        response._header('cache-control', 'no-cache');\n    }\n};\n\n\ninternals.security = function (response) {\n\n    const request = response.request;\n\n    const security = request.route.settings.security;\n    if (security) {\n        if (security._hsts) {\n            response._header('strict-transport-security', security._hsts, { override: false });\n        }\n\n        if (security._xframe) {\n            response._header('x-frame-options', security._xframe, { override: false });\n        }\n\n        if (security.xss) {\n            response._header('x-xss-protection', '1; mode=block', { override: false });\n        }\n\n        if (security.noOpen) {\n            response._header('x-download-options', 'noopen', { override: false });\n        }\n\n        if (security.noSniff) {\n            response._header('x-content-type-options', 'nosniff', { override: false });\n        }\n    }\n};\n\n\ninternals.content = function (response) {\n\n    const type = response.headers['content-type'];\n    if (!type) {\n        const charset = (response.settings.charset ? '; charset=' + response.settings.charset : '');\n\n        if (typeof response.source === 'string') {\n            response.type('text/html' + charset);\n        }\n        else if (Buffer.isBuffer(response.source)) {\n            response.type('application/octet-stream');\n        }\n        else if (response.variety === 'plain' &&\n            response.source !== null) {\n\n            response.type('application/json' + charset);\n        }\n    }\n    else if (response.settings.charset &&\n        type.match(/^(?:text\\/)|(?:application\\/(?:json)|(?:javascript))/)) {\n\n        const hasParams = (type.indexOf(';') !== -1);\n        if (!hasParams ||\n            !type.match(/[; ]charset=/)) {\n\n            response.type(type + (hasParams ? ', ' : '; ') + 'charset=' + (response.settings.charset));\n        }\n    }\n};\n\n\ninternals.state = function (response, next) {\n\n    const request = response.request;\n\n    const names = {};\n    const states = [];\n\n    const requestStates = Object.keys(request._states);\n    for (let i = 0; i < requestStates.length; ++i) {\n        const stateName = requestStates[i];\n        names[stateName] = true;\n        states.push(request._states[stateName]);\n    }\n\n    const each = (name, nextKey) => {\n\n        const autoValue = request.connection.states.cookies[name].autoValue;\n        if (!autoValue || names[name]) {\n            return nextKey();\n        }\n\n        names[name] = true;\n\n        if (typeof autoValue !== 'function') {\n            states.push({ name: name, value: autoValue });\n            return nextKey();\n        }\n\n        autoValue(request, (err, value) => {\n\n            if (err) {\n                return nextKey(err);\n            }\n\n            states.push({ name: name, value: value });\n            return nextKey();\n        });\n    };\n\n    const keys = Object.keys(request.connection.states.cookies);\n    Items.parallel(keys, each, (err) => {\n\n        if (err) {\n            return next(Boom.wrap(err));\n        }\n\n        if (!states.length) {\n            return next();\n        }\n\n        request.connection.states.format(states, (err, header) => {\n\n            if (err) {\n                return next(Boom.wrap(err));\n            }\n\n            const existing = response.headers['set-cookie'];\n            if (existing) {\n                header = (Array.isArray(existing) ? existing : [existing]).concat(header);\n            }\n\n            response._header('set-cookie', header);\n            return next();\n        });\n    });\n};\n"], "fixing_code": ["'use strict';\n\n// Load modules\n\nconst Http = require('http');\nconst Stream = require('stream');\nconst Zlib = require('zlib');\nconst Ammo = require('ammo');\nconst Boom = require('boom');\nconst Hoek = require('hoek');\nconst Items = require('items');\nconst Shot = require('shot');\nconst Auth = require('./auth');\nconst Cors = require('./cors');\nconst Response = require('./response');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports.send = function (request, callback) {\n\n    const response = request.response;\n    if (response.isBoom) {\n        return internals.fail(request, response, callback);\n    }\n\n    internals.marshal(request, (err) => {\n\n        if (err) {\n            request._setResponse(err);\n            return internals.fail(request, err, callback);\n        }\n\n        return internals.transmit(response, callback);\n    });\n};\n\n\ninternals.marshal = function (request, next) {\n\n    const response = request.response;\n\n    Cors.headers(response);\n    internals.content(response);\n    internals.security(response);\n\n    if (response.statusCode !== 304 &&\n        (request.method === 'get' || request.method === 'head')) {\n\n        if (response.headers.etag &&\n            request.headers['if-none-match']) {\n\n            // Strong verifier\n\n            const ifNoneMatch = request.headers['if-none-match'].split(/\\s*,\\s*/);\n            for (let i = 0; i < ifNoneMatch.length; ++i) {\n                const etag = ifNoneMatch[i];\n                if (etag === response.headers.etag) {\n                    response.code(304);\n                    break;\n                }\n                else if (response.settings.varyEtag) {\n                    const etagBase = response.headers.etag.slice(0, -1);\n                    if (etag === etagBase + '-gzip\"' ||\n                        etag === etagBase + '-deflate\"') {\n\n                        response.code(304);\n                        break;\n                    }\n                }\n            }\n        }\n        else {\n            const ifModifiedSinceHeader = request.headers['if-modified-since'];\n            const lastModifiedHeader = response.headers['last-modified'];\n\n            if (ifModifiedSinceHeader &&\n                lastModifiedHeader) {\n\n                // Weak verifier\n\n                const ifModifiedSince = internals.parseDate(ifModifiedSinceHeader);\n                const lastModified = internals.parseDate(lastModifiedHeader);\n\n                if (ifModifiedSince &&\n                    lastModified &&\n                    ifModifiedSince >= lastModified) {\n\n                    response.code(304);\n                }\n            }\n        }\n    }\n\n    internals.state(response, (err) => {\n\n        if (err) {\n            request._log(['state', 'response', 'error'], err);\n            request._states = {};                                           // Clear broken state\n            return next(err);\n        }\n\n        internals.cache(response);\n\n        if (!response._isPayloadSupported()) {\n\n            // Close unused file streams\n\n            response._close();\n\n            // Set empty stream\n\n            response._payload = new internals.Empty();\n            if (request.method !== 'head') {\n                delete response.headers['content-length'];\n            }\n\n            return Auth.response(request, next);               // Must be last in case requires access to headers\n        }\n\n        response._marshal((err) => {\n\n            if (err) {\n                return next(Boom.wrap(err));\n            }\n\n            if (request.jsonp &&\n                response._payload.jsonp) {\n\n                response._header('content-type', 'text/javascript' + (response.settings.charset ? '; charset=' + response.settings.charset : ''));\n                response._header('x-content-type-options', 'nosniff');\n                response._payload.jsonp(request.jsonp);\n            }\n\n            if (response._payload.size &&\n                typeof response._payload.size === 'function') {\n\n                response._header('content-length', response._payload.size(), { override: false });\n            }\n\n            return Auth.response(request, next);               // Must be last in case requires access to headers\n        });\n    });\n};\n\n\ninternals.parseDate = function (string) {\n\n    try {\n        return Date.parse(string);\n    }\n    catch (errIgnore) { }\n};\n\n\ninternals.fail = function (request, boom, callback) {\n\n    const error = boom.output;\n    const response = new Response(error.payload, request);\n    response._error = boom;\n    response.code(error.statusCode);\n    response.headers = error.headers;\n    request.response = response;                            // Not using request._setResponse() to avoid double log\n\n    internals.marshal(request, (err) => {\n\n        if (err) {\n\n            // Failed to marshal an error - replace with minimal representation of original error\n\n            const minimal = {\n                statusCode: error.statusCode,\n                error: Http.STATUS_CODES[error.statusCode],\n                message: boom.message\n            };\n\n            response._payload = new Response.Payload(JSON.stringify(minimal), {});\n        }\n\n        return internals.transmit(response, callback);\n    });\n};\n\n\ninternals.transmit = function (response, callback) {\n\n    // Setup source\n\n    const request = response.request;\n    const source = response._payload;\n    const length = parseInt(response.headers['content-length'], 10);      // In case value is a string\n\n    // Empty response\n\n    if (length === 0 &&\n        response.statusCode === 200 &&\n        request.route.settings.response.emptyStatusCode === 204) {\n\n        response.code(204);\n        delete response.headers['content-length'];\n    }\n\n    // Compression\n\n    const mime = request.server.mime.type(response.headers['content-type'] || 'application/octet-stream');\n    let encoding = (request.connection.settings.compression && mime.compressible && !response.headers['content-encoding'] ? request.info.acceptEncoding : null);\n    encoding = (encoding === 'identity' ? null : encoding);\n\n    // Range\n\n    let ranger = null;\n    if (request.method === 'get' &&\n        response.statusCode === 200 &&\n        length > 0 &&\n        !encoding) {\n\n        if (request.headers.range) {\n\n            // Check If-Range\n\n            if (!request.headers['if-range'] ||\n                request.headers['if-range'] === response.headers.etag) {            // Ignoring last-modified date (weak)\n\n                // Parse header\n\n                const ranges = Ammo.header(request.headers.range, length);\n                if (!ranges) {\n                    const error = Boom.rangeNotSatisfiable();\n                    error.output.headers['content-range'] = 'bytes */' + length;\n                    return internals.fail(request, error, callback);\n                }\n\n                // Prepare transform\n\n                if (ranges.length === 1) {                                          // Ignore requests for multiple ranges\n                    const range = ranges[0];\n                    ranger = new Ammo.Stream(range);\n                    response.code(206);\n                    response.bytes(range.to - range.from + 1);\n                    response._header('content-range', 'bytes ' + range.from + '-' + range.to + '/' + length);\n                }\n            }\n        }\n\n        response._header('accept-ranges', 'bytes');\n    }\n\n    // Content-Encoding\n\n    if (request.headers['accept-encoding']) {\n        response.vary('accept-encoding');\n    }\n\n    let compressor = null;\n    if (encoding &&\n        length !== 0 &&\n        response._isPayloadSupported()) {\n\n        delete response.headers['content-length'];\n        response._header('content-encoding', encoding);\n\n        compressor = (encoding === 'gzip' ? Zlib.createGzip() : Zlib.createDeflate());\n    }\n\n    if ((response.headers['content-encoding'] || encoding) &&\n        response.headers.etag &&\n        response.settings.varyEtag) {\n\n        response.headers.etag = response.headers.etag.slice(0, -1) + '-' + (response.headers['content-encoding'] || encoding) + '\"';\n    }\n\n    // Write headers\n\n    const headers = Object.keys(response.headers);\n    for (let i = 0; i < headers.length; ++i) {\n        const header = headers[i];\n        const value = response.headers[header];\n        if (value !== undefined) {\n            request.raw.res.setHeader(header, value);\n        }\n    }\n\n    request.raw.res.writeHead(response.statusCode);\n\n    // Generate tap stream\n\n    const tap = response._tap();\n\n    // Write payload\n\n    let hasEnded = false;\n    const end = (err, event) => {\n\n        if (hasEnded) {\n            return;\n        }\n\n        hasEnded = true;\n\n        if (event !== 'aborted') {\n            request.raw.res.end();\n        }\n\n        source.removeListener('error', end);\n\n        request.raw.req.removeListener('aborted', onAborted);\n        request.raw.req.removeListener('close', onClose);\n\n        request.raw.res.removeListener('close', onClose);\n        request.raw.res.removeListener('error', end);\n        request.raw.res.removeListener('finish', end);\n\n        const tags = (err ? ['response', 'error']\n                        : (event ? ['response', 'error', event]\n                                 : ['response']));\n\n        if (event || err) {\n            request.emit('disconnect');\n        }\n\n        request._log(tags, err);\n        callback();\n    };\n\n    source.once('error', end);\n\n    const onAborted = () => {\n\n        end(null, 'aborted');\n    };\n\n    const onClose = () => {\n\n        end(null, 'close');\n    };\n\n    request.raw.req.once('aborted', onAborted);\n    request.raw.req.once('close', onClose);\n\n    request.raw.res.once('close', onClose);\n    request.raw.res.once('error', end);\n    request.raw.res.once('finish', end);\n\n    const preview = (tap ? source.pipe(tap) : source);\n    const compressed = (compressor ? preview.pipe(compressor) : preview);\n    const ranged = (ranger ? compressed.pipe(ranger) : compressed);\n    ranged.pipe(request.raw.res);\n\n    // Injection\n\n    if (Shot.isInjection(request.raw.req)) {\n        request.raw.res._hapi = {\n            request: request\n        };\n\n        if (response.variety === 'plain') {\n            request.raw.res._hapi.result = response._isPayloadSupported() ? response.source : null;\n        }\n    }\n};\n\n\ninternals.Empty = function () {\n\n    Stream.Readable.call(this);\n};\n\nHoek.inherits(internals.Empty, Stream.Readable);\n\n\ninternals.Empty.prototype._read = function (/* size */) {\n\n    this.push(null);\n};\n\n\ninternals.cache = function (response) {\n\n    if (response.headers['cache-control']) {\n        return;\n    }\n\n    const request = response.request;\n    const policy = request._route._cache && (request.route.settings.cache._statuses[response.statusCode] || (response.statusCode === 304 && request.route.settings.cache._statuses['200']));\n    if (policy ||\n        response.settings.ttl) {\n\n        const ttl = (response.settings.ttl !== null ? response.settings.ttl : request._route._cache.ttl());\n        const privacy = (request.auth.isAuthenticated || response.headers['set-cookie'] ? 'private' : request.route.settings.cache.privacy || 'default');\n        response._header('cache-control', 'max-age=' + Math.floor(ttl / 1000) + ', must-revalidate' + (privacy !== 'default' ? ', ' + privacy : ''));\n    }\n    else {\n        response._header('cache-control', 'no-cache');\n    }\n};\n\n\ninternals.security = function (response) {\n\n    const request = response.request;\n\n    const security = request.route.settings.security;\n    if (security) {\n        if (security._hsts) {\n            response._header('strict-transport-security', security._hsts, { override: false });\n        }\n\n        if (security._xframe) {\n            response._header('x-frame-options', security._xframe, { override: false });\n        }\n\n        if (security.xss) {\n            response._header('x-xss-protection', '1; mode=block', { override: false });\n        }\n\n        if (security.noOpen) {\n            response._header('x-download-options', 'noopen', { override: false });\n        }\n\n        if (security.noSniff) {\n            response._header('x-content-type-options', 'nosniff', { override: false });\n        }\n    }\n};\n\n\ninternals.content = function (response) {\n\n    const type = response.headers['content-type'];\n    if (!type) {\n        const charset = (response.settings.charset ? '; charset=' + response.settings.charset : '');\n\n        if (typeof response.source === 'string') {\n            response.type('text/html' + charset);\n        }\n        else if (Buffer.isBuffer(response.source)) {\n            response.type('application/octet-stream');\n        }\n        else if (response.variety === 'plain' &&\n            response.source !== null) {\n\n            response.type('application/json' + charset);\n        }\n    }\n    else if (response.settings.charset &&\n        type.match(/^(?:text\\/)|(?:application\\/(?:json)|(?:javascript))/)) {\n\n        const hasParams = (type.indexOf(';') !== -1);\n        if (!hasParams ||\n            !type.match(/[; ]charset=/)) {\n\n            response.type(type + (hasParams ? ', ' : '; ') + 'charset=' + (response.settings.charset));\n        }\n    }\n};\n\n\ninternals.state = function (response, next) {\n\n    const request = response.request;\n\n    const names = {};\n    const states = [];\n\n    const requestStates = Object.keys(request._states);\n    for (let i = 0; i < requestStates.length; ++i) {\n        const stateName = requestStates[i];\n        names[stateName] = true;\n        states.push(request._states[stateName]);\n    }\n\n    const each = (name, nextKey) => {\n\n        const autoValue = request.connection.states.cookies[name].autoValue;\n        if (!autoValue || names[name]) {\n            return nextKey();\n        }\n\n        names[name] = true;\n\n        if (typeof autoValue !== 'function') {\n            states.push({ name: name, value: autoValue });\n            return nextKey();\n        }\n\n        autoValue(request, (err, value) => {\n\n            if (err) {\n                return nextKey(err);\n            }\n\n            states.push({ name: name, value: value });\n            return nextKey();\n        });\n    };\n\n    const keys = Object.keys(request.connection.states.cookies);\n    Items.parallel(keys, each, (err) => {\n\n        if (err) {\n            return next(Boom.wrap(err));\n        }\n\n        if (!states.length) {\n            return next();\n        }\n\n        request.connection.states.format(states, (err, header) => {\n\n            if (err) {\n                return next(Boom.wrap(err));\n            }\n\n            const existing = response.headers['set-cookie'];\n            if (existing) {\n                header = (Array.isArray(existing) ? existing : [existing]).concat(header);\n            }\n\n            response._header('set-cookie', header);\n            return next();\n        });\n    });\n};\n"], "filenames": ["lib/transmit.js"], "buggy_code_start_loc": [85], "buggy_code_end_loc": [146], "fixing_code_start_loc": [85], "fixing_code_end_loc": [156], "type": "CWE-20", "message": "Certain input passed into the If-Modified-Since or Last-Modified headers will cause an 'illegal access' exception to be raised. Instead of sending a HTTP 500 error back to the sender, hapi node module before 11.1.3 will continue to hold the socket open until timed out (default node timeout is 2 minutes).", "other": {"cve": {"id": "CVE-2015-9241", "sourceIdentifier": "support@hackerone.com", "published": "2018-05-29T20:29:00.440", "lastModified": "2019-10-09T23:15:58.277", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Certain input passed into the If-Modified-Since or Last-Modified headers will cause an 'illegal access' exception to be raised. Instead of sending a HTTP 500 error back to the sender, hapi node module before 11.1.3 will continue to hold the socket open until timed out (default node timeout is 2 minutes)."}, {"lang": "es", "value": "Ciertas entradas pasadas a las cabeceras If-Modified-Since o Last-Modified provocar\u00e1n una excepci\u00f3n \"illegal access\". En lugar de enviar un error HTTP 500 de nuevo al remitente, el m\u00f3dulo hapi node en versiones anteriores a la 11.1.3 seguir\u00e1 manteniendo abierto el socket hasta que se agote el tiempo (el tiempo de agotamiento por defecto es de 2 minutos)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}, {"source": "support@hackerone.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:hapijs:hapi:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "11.1.3", "matchCriteriaId": "C824DAF6-2DA3-41AB-B2E4-D3D40AB72C83"}]}]}], "references": [{"url": "https://github.com/hapijs/hapi/commit/aab2496e930dce5ee1ab28eecec94e0e45f03580", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/jfhbrook/node-ecstatic/pull/179", "source": "support@hackerone.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://nodesecurity.io/advisories/63", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/hapijs/hapi/commit/aab2496e930dce5ee1ab28eecec94e0e45f03580"}}