{"buggy_code": ["/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.internal.config;\n\nimport com.hazelcast.config.ConfigRecognizer;\nimport com.hazelcast.config.ConfigStream;\nimport com.hazelcast.logging.ILogger;\nimport com.hazelcast.logging.Logger;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.helpers.DefaultHandler;\n\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\n\nimport static com.hazelcast.internal.util.StringUtil.equalsIgnoreCase;\nimport static java.util.Objects.requireNonNull;\n\n/**\n * Abstract {@link ConfigRecognizer} implementation that recognizes\n * Hazelcast XML configurations. The recognition is done by looking into\n * the provided configuration to check if the root node is the expected\n * one.\n * <p/>\n * This implementation uses a SAX parser. The parsing is aborted once the\n * root tag is processed.\n * <p/>\n * If the provided configuration is not a valid XML document, no exception\n * is thrown. Instead, the configuration is simply not recognized by this\n * implementation.\n * </p>\n * Note that this {@link ConfigRecognizer} doesn't validate the\n * configuration and doesn't look further into the provided configuration.\n */\npublic class AbstractXmlConfigRootTagRecognizer implements ConfigRecognizer {\n    private final SAXParser saxParser;\n    private final String expectedRootNode;\n    private final ILogger logger = Logger.getLogger(AbstractXmlConfigRootTagRecognizer.class);\n\n    public AbstractXmlConfigRootTagRecognizer(String expectedRootNode) throws Exception {\n        this.expectedRootNode = expectedRootNode;\n        SAXParserFactory factory = SAXParserFactory.newInstance();\n        saxParser = factory.newSAXParser();\n    }\n\n    @Override\n    public boolean isRecognized(ConfigStream configStream) throws Exception {\n        MemberHandler memberHandler = new MemberHandler(expectedRootNode);\n        try {\n            saxParser.parse(configStream, memberHandler);\n        } catch (TerminateParseException ex) {\n            // expected, always\n        } catch (SAXParseException ex) {\n            // thrown if the provided XML is not a valid XML\n            handleParseException(ex);\n            return false;\n        } catch (Exception ex) {\n            // thrown if any unexpected exception is encountered\n            handleUnexpectedException(ex);\n            throw ex;\n        }\n        return memberHandler.isMemberXml;\n    }\n\n    private void handleParseException(SAXParseException ex) {\n        if (logger.isFineEnabled()) {\n            logger.fine(\"An exception is encountered while processing the provided XML configuration\", ex);\n        }\n    }\n\n    private void handleUnexpectedException(Exception ex) {\n        if (logger.isFineEnabled()) {\n            logger.fine(\"An unexpected exception is encountered while processing the provided XML configuration\", ex);\n        }\n    }\n\n    private static final class MemberHandler extends DefaultHandler {\n        private final String expectedRootNode;\n        private boolean isMemberXml;\n\n        private MemberHandler(String expectedRootNode) {\n            this.expectedRootNode = requireNonNull(expectedRootNode);\n        }\n\n        @Override\n        public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n            if (equalsIgnoreCase(expectedRootNode, qName)) {\n                isMemberXml = true;\n            }\n            throw new TerminateParseException();\n        }\n    }\n\n    private static final class TerminateParseException extends SAXException {\n    }\n}\n", "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.internal.util;\n\nimport static com.hazelcast.internal.nio.IOUtil.closeResource;\n\nimport java.io.StringReader;\nimport java.io.StringWriter;\n\nimport javax.annotation.Nullable;\nimport javax.xml.XMLConstants;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.ErrorListener;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.validation.SchemaFactory;\n\nimport org.xml.sax.SAXException;\n\nimport com.hazelcast.logging.ILogger;\nimport com.hazelcast.logging.Logger;\n\n/**\n * Utility class for XML processing.\n */\npublic final class XmlUtil {\n\n    /**\n     * System property name which allows ignoring failures during enabling the XML External Entity protection.\n     * This property should only be used as a last\n     * resort. Hazelcast uses the XXE protection by setting properties {@link XMLConstants#ACCESS_EXTERNAL_DTD} and\n     * {@link XMLConstants#ACCESS_EXTERNAL_SCHEMA}. These properties are supported in modern XML processors (JAXP 1.5+, Java\n     * 8+). Old JAXP implementations on the classpath (e.g. Xerces, Xalan) may miss the support and they throw exception\n     * during enabling the XXE protection. Setting this system property to true suppresses/ignores such Exceptions.\n     */\n    public static final String SYSTEM_PROPERTY_IGNORE_XXE_PROTECTION_FAILURES = \"hazelcast.ignoreXxeProtectionFailures\";\n\n    private static final ILogger LOGGER = Logger.getLogger(XmlUtil.class);\n\n    private XmlUtil() {\n    }\n\n    /**\n     * Returns namespace aware instance of {@link DocumentBuilderFactory} with XXE protection enabled.\n     *\n     * @throws ParserConfigurationException enabling XXE protection fail\n     */\n    public static DocumentBuilderFactory getNsAwareDocumentBuilderFactory() throws ParserConfigurationException {\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n        dbf.setNamespaceAware(true);\n        setFeature(dbf, \"http://apache.org/xml/features/disallow-doctype-decl\");\n        return dbf;\n    }\n\n    /**\n     * Returns {@link TransformerFactory} with XXE protection enabled.\n     */\n    public static TransformerFactory getTransformerFactory() {\n        TransformerFactory transformerFactory = TransformerFactory.newInstance();\n        setAttribute(transformerFactory, XMLConstants.ACCESS_EXTERNAL_DTD);\n        setAttribute(transformerFactory, XMLConstants.ACCESS_EXTERNAL_STYLESHEET);\n        return transformerFactory;\n    }\n\n    /**\n     * Returns {@link SchemaFactory} with XXE protection enabled.\n     */\n    public static SchemaFactory getSchemaFactory() throws SAXException {\n        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n        setProperty(schemaFactory, XMLConstants.ACCESS_EXTERNAL_SCHEMA);\n        setProperty(schemaFactory, XMLConstants.ACCESS_EXTERNAL_DTD);\n        return schemaFactory;\n    }\n\n    /**\n     * Formats given XML String with the given indentation used. If the {@code input} XML string is {@code null}, or\n     * {@code indent} parameter is negative, or XML transformation fails, then the original value is returned unchanged. The\n     * {@link IllegalArgumentException} is thrown when {@code indent==0}.\n     *\n     * @param input the XML String\n     * @param indent indentation (number of spaces used for one indentation level)\n     * @return formatted XML String or the original String if the formatting fails.\n     * @throws IllegalArgumentException when indentation is equal to zero\n     */\n    @SuppressWarnings(\"checkstyle:NPathComplexity\")\n    public static String format(@Nullable String input, int indent) throws IllegalArgumentException {\n        if (input == null || indent < 0) {\n            return input;\n        }\n        if (indent == 0) {\n            throw new IllegalArgumentException(\"Indentation must not be 0.\");\n        }\n        StreamResult xmlOutput = null;\n        try {\n            Source xmlInput = new StreamSource(new StringReader(input));\n            xmlOutput = new StreamResult(new StringWriter());\n            TransformerFactory transformerFactory = getTransformerFactory();\n            /*\n             * Older versions of Xalan still use this method of setting indent values.\n             * Attempt to make this work but don't completely fail if it's a problem.\n             */\n            try {\n                transformerFactory.setAttribute(\"indent-number\", indent);\n            } catch (IllegalArgumentException e) {\n                if (LOGGER.isFinestEnabled()) {\n                    LOGGER.finest(\"Failed to set indent-number attribute; cause: \" + e.getMessage());\n                }\n            }\n            Transformer transformer = transformerFactory.newTransformer();\n            // workaround IBM Java behavior - the silent ignorance of issues during the transformation.\n            transformer.setErrorListener(ThrowingErrorListener.INSTANCE);\n            transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"yes\");\n            transformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\");\n            transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n            /*\n             * Newer versions of Xalan will look for a fully-qualified output property in order to specify amount of\n             * indentation to use. Attempt to make this work as well but again don't completely fail if it's a problem.\n             */\n            try {\n                transformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", Integer.toString(indent));\n            } catch (IllegalArgumentException e) {\n                if (LOGGER.isFinestEnabled()) {\n                    LOGGER.finest(\"Failed to set indent-amount property; cause: \" + e.getMessage());\n                }\n            }\n            transformer.transform(xmlInput, xmlOutput);\n            return xmlOutput.getWriter().toString();\n        } catch (Exception e) {\n            LOGGER.warning(e);\n            return input;\n        } finally {\n            if (xmlOutput != null) {\n                closeResource(xmlOutput.getWriter());\n            }\n        }\n    }\n\n    /**\n     * Returns ErrorListener implementation which just throws the original error.\n     */\n    public ErrorListener getErrorListener() {\n        return ThrowingErrorListener.INSTANCE;\n    }\n\n    static void setAttribute(TransformerFactory transformerFactory, String attributeName) {\n        try {\n            transformerFactory.setAttribute(attributeName, \"\");\n        } catch (IllegalArgumentException iae) {\n            if (Boolean.getBoolean(SYSTEM_PROPERTY_IGNORE_XXE_PROTECTION_FAILURES)) {\n                LOGGER.warning(\"Enabling XXE protection failed. The attribute \" + attributeName\n                        + \" is not supported by the TransformerFactory. The \" + SYSTEM_PROPERTY_IGNORE_XXE_PROTECTION_FAILURES\n                        + \" system property is used so the XML processing continues in the UNSECURE mode\"\n                        + \" with XXE protection disabled!!!\");\n            } else {\n                LOGGER.severe(\"Enabling XXE protection failed. The attribute \" + attributeName\n                        + \" is not supported by the TransformerFactory. This usually mean an outdated XML processor\"\n                        + \" is present on the classpath (e.g. Xerces, Xalan). If you are not able to resolve the issue by\"\n                        + \" fixing the classpath, the \" + SYSTEM_PROPERTY_IGNORE_XXE_PROTECTION_FAILURES\n                        + \" system property can be used to disable XML External Entity protections.\"\n                        + \" We don't recommend disabling the XXE as such the XML processor configuration is unsecure!!!\", iae);\n                throw iae;\n            }\n        }\n    }\n\n    static void setFeature(DocumentBuilderFactory dbf, String featureName) throws ParserConfigurationException {\n        try {\n            dbf.setFeature(featureName, true);\n        } catch (ParserConfigurationException e) {\n            if (Boolean.getBoolean(SYSTEM_PROPERTY_IGNORE_XXE_PROTECTION_FAILURES)) {\n                LOGGER.warning(\"Enabling XXE protection failed. The feature \" + featureName\n                        + \" is not supported by the DocumentBuilderFactory. The \" + SYSTEM_PROPERTY_IGNORE_XXE_PROTECTION_FAILURES\n                        + \" system property is used so the XML processing continues in the UNSECURE mode\"\n                        + \" with XXE protection disabled!!!\");\n            } else {\n                LOGGER.severe(\"Enabling XXE protection failed. The feature \" + featureName\n                        + \" is not supported by the DocumentBuilderFactory. This usually mean an outdated XML processor\"\n                        + \" is present on the classpath (e.g. Xerces, Xalan). If you are not able to resolve the issue by\"\n                        + \" fixing the classpath, the \" + SYSTEM_PROPERTY_IGNORE_XXE_PROTECTION_FAILURES\n                        + \" system property can be used to disable XML External Entity protections.\"\n                        + \" We don't recommend disabling the XXE as such the XML processor configuration is unsecure!!!\", e);\n                throw e;\n            }\n        }\n    }\n\n    static void setProperty(SchemaFactory schemaFactory, String propertyName) throws SAXException {\n        try {\n            schemaFactory.setProperty(propertyName, \"\");\n        } catch (SAXException e) {\n            if (Boolean.getBoolean(SYSTEM_PROPERTY_IGNORE_XXE_PROTECTION_FAILURES)) {\n                LOGGER.warning(\"Enabling XXE protection failed. The property \" + propertyName\n                        + \" is not supported by the SchemaFactory. The \" + SYSTEM_PROPERTY_IGNORE_XXE_PROTECTION_FAILURES\n                        + \" system property is used so the XML processing continues in the UNSECURE mode\"\n                        + \" with XXE protection disabled!!!\");\n            } else {\n                LOGGER.severe(\"Enabling XXE protection failed. The property \" + propertyName\n                        + \" is not supported by the SchemaFactory. This usually mean an outdated XML processor\"\n                        + \" is present on the classpath (e.g. Xerces, Xalan). If you are not able to resolve the issue by\"\n                        + \" fixing the classpath, the \" + SYSTEM_PROPERTY_IGNORE_XXE_PROTECTION_FAILURES\n                        + \" system property can be used to disable XML External Entity protections.\"\n                        + \" We don't recommend disabling the XXE as such the XML processor configuration is unsecure!!!\", e);\n                throw e;\n            }\n        }\n    }\n\n    /**\n     * ErrorListener implementation which just throws the error. It workarounds IBM Java default behaviour when\n     * {@link Transformer#transform(Source, javax.xml.transform.Result)} finishes without problems even if an exception is\n     * thrown within the call. If an error happens, we want to know about it and handle it properly.\n     */\n    static final class ThrowingErrorListener implements ErrorListener {\n        public static final ThrowingErrorListener INSTANCE = new ThrowingErrorListener();\n\n        private ThrowingErrorListener() {\n        }\n\n        @Override\n        public void warning(TransformerException exception) throws TransformerException {\n            throw exception;\n        }\n\n        @Override\n        public void fatalError(TransformerException exception) throws TransformerException {\n            throw exception;\n        }\n\n        @Override\n        public void error(TransformerException exception) throws TransformerException {\n            throw exception;\n        }\n    }\n\n}\n", "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.internal.util;\n\nimport static com.hazelcast.internal.util.XmlUtil.SYSTEM_PROPERTY_IGNORE_XXE_PROTECTION_FAILURES;\nimport static com.hazelcast.internal.util.XmlUtil.format;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertThrows;\n\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.validation.SchemaFactory;\n\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.experimental.categories.Category;\nimport org.junit.runner.RunWith;\nimport org.xml.sax.SAXException;\n\nimport com.hazelcast.test.HazelcastSerialClassRunner;\nimport com.hazelcast.test.OverridePropertyRule;\nimport com.hazelcast.test.annotation.QuickTest;\n\n@RunWith(HazelcastSerialClassRunner.class)\n@Category({ QuickTest.class })\npublic class XmlUtilTest {\n\n    @Rule\n    public OverridePropertyRule ignoreXxeFailureProp = OverridePropertyRule\n            .clear(SYSTEM_PROPERTY_IGNORE_XXE_PROTECTION_FAILURES);\n\n    @Test\n    public void testFormat() throws Exception {\n        assertEquals(\"<a> <b>c</b></a>\", format(\"<a><b>c</b></a>\", 1).replaceAll(\"[\\r\\n]\", \"\"));\n        assertEquals(\"<a>   <b>c</b></a>\", format(\"<a><b>c</b></a>\", 3).replaceAll(\"[\\r\\n]\", \"\"));\n        assertEquals(\"<a><b>c</b></a>\", format(\"<a><b>c</b></a>\", -21));\n\n        assertThrows(IllegalArgumentException.class, () -> format(\"<a><b>c</b></a>\", 0));\n\n        // check if the XXE protection is enabled\n        String xxeAttack = \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n\" + \"  <!DOCTYPE test [\\n\"\n                + \"    <!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\">\\n\" + \"  ]>\" + \"<a><b>&xxe;</b></a>\";\n        assertEquals(xxeAttack, format(xxeAttack, 1));\n\n        // wrongly formatted XML\n        assertEquals(\"<a><b>c</b><a>\", format(\"<a><b>c</b><a>\", 1));\n    }\n\n    @Test\n    public void testGetSchemaFactory() throws Exception {\n        SchemaFactory schemaFactory = XmlUtil.getSchemaFactory();\n        assertNotNull(schemaFactory);\n        assertThrows(SAXException.class, () -> XmlUtil.setProperty(schemaFactory, \"test://no-such-property\"));\n        ignoreXxeFailureProp.setOrClearProperty(\"false\");\n        assertThrows(SAXException.class, () -> XmlUtil.setProperty(schemaFactory, \"test://no-such-property\"));\n        ignoreXxeFailureProp.setOrClearProperty(\"true\");\n        XmlUtil.setProperty(schemaFactory, \"test://no-such-property\");\n    }\n\n    @Test\n    public void testGetTransformerFactory() throws Exception {\n        TransformerFactory transformerFactory = XmlUtil.getTransformerFactory();\n        assertNotNull(transformerFactory);\n        assertThrows(IllegalArgumentException.class, () -> XmlUtil.setAttribute(transformerFactory, \"test://no-such-property\"));\n        ignoreXxeFailureProp.setOrClearProperty(\"false\");\n        assertThrows(IllegalArgumentException.class, () -> XmlUtil.setAttribute(transformerFactory, \"test://no-such-property\"));\n        ignoreXxeFailureProp.setOrClearProperty(\"true\");\n        XmlUtil.setAttribute(transformerFactory, \"test://no-such-property\");\n    }\n\n    @Test\n    public void testGetDocumentBuilderFactory() throws Exception {\n        DocumentBuilderFactory dbf = XmlUtil.getNsAwareDocumentBuilderFactory();\n        assertNotNull(dbf);\n        assertThrows(ParserConfigurationException.class, () -> XmlUtil.setFeature(dbf, \"test://no-such-feature\"));\n        ignoreXxeFailureProp.setOrClearProperty(\"false\");\n        assertThrows(ParserConfigurationException.class, () -> XmlUtil.setFeature(dbf, \"test://no-such-feature\"));\n        ignoreXxeFailureProp.setOrClearProperty(\"true\");\n        XmlUtil.setFeature(dbf, \"test://no-such-feature\");\n    }\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.internal.config;\n\nimport com.hazelcast.config.ConfigRecognizer;\nimport com.hazelcast.config.ConfigStream;\nimport com.hazelcast.internal.util.XmlUtil;\nimport com.hazelcast.logging.ILogger;\nimport com.hazelcast.logging.Logger;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.helpers.DefaultHandler;\n\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\n\nimport static com.hazelcast.internal.util.StringUtil.equalsIgnoreCase;\nimport static java.util.Objects.requireNonNull;\n\n/**\n * Abstract {@link ConfigRecognizer} implementation that recognizes\n * Hazelcast XML configurations. The recognition is done by looking into\n * the provided configuration to check if the root node is the expected\n * one.\n * <p/>\n * This implementation uses a SAX parser. The parsing is aborted once the\n * root tag is processed.\n * <p/>\n * If the provided configuration is not a valid XML document, no exception\n * is thrown. Instead, the configuration is simply not recognized by this\n * implementation.\n * </p>\n * Note that this {@link ConfigRecognizer} doesn't validate the\n * configuration and doesn't look further into the provided configuration.\n */\npublic class AbstractXmlConfigRootTagRecognizer implements ConfigRecognizer {\n    private final SAXParser saxParser;\n    private final String expectedRootNode;\n    private final ILogger logger = Logger.getLogger(AbstractXmlConfigRootTagRecognizer.class);\n\n    public AbstractXmlConfigRootTagRecognizer(String expectedRootNode) throws Exception {\n        this.expectedRootNode = expectedRootNode;\n        SAXParserFactory factory = XmlUtil.getSAXParserFactory();\n        saxParser = factory.newSAXParser();\n    }\n\n    @Override\n    public boolean isRecognized(ConfigStream configStream) throws Exception {\n        MemberHandler memberHandler = new MemberHandler(expectedRootNode);\n        try {\n            saxParser.parse(configStream, memberHandler);\n        } catch (TerminateParseException ex) {\n            // expected, always\n        } catch (SAXParseException ex) {\n            // thrown if the provided XML is not a valid XML\n            handleParseException(ex);\n            return false;\n        } catch (Exception ex) {\n            // thrown if any unexpected exception is encountered\n            handleUnexpectedException(ex);\n            throw ex;\n        }\n        return memberHandler.isMemberXml;\n    }\n\n    private void handleParseException(SAXParseException ex) {\n        if (logger.isFineEnabled()) {\n            logger.fine(\"An exception is encountered while processing the provided XML configuration\", ex);\n        }\n    }\n\n    private void handleUnexpectedException(Exception ex) {\n        if (logger.isFineEnabled()) {\n            logger.fine(\"An unexpected exception is encountered while processing the provided XML configuration\", ex);\n        }\n    }\n\n    private static final class MemberHandler extends DefaultHandler {\n        private final String expectedRootNode;\n        private boolean isMemberXml;\n\n        private MemberHandler(String expectedRootNode) {\n            this.expectedRootNode = requireNonNull(expectedRootNode);\n        }\n\n        @Override\n        public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n            if (equalsIgnoreCase(expectedRootNode, qName)) {\n                isMemberXml = true;\n            }\n            throw new TerminateParseException();\n        }\n    }\n\n    private static final class TerminateParseException extends SAXException {\n    }\n}\n", "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.internal.util;\n\nimport static com.hazelcast.internal.nio.IOUtil.closeResource;\n\nimport java.io.StringReader;\nimport java.io.StringWriter;\n\nimport javax.annotation.Nullable;\nimport javax.xml.XMLConstants;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.transform.ErrorListener;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.validation.SchemaFactory;\n\nimport org.xml.sax.SAXException;\n\nimport com.hazelcast.logging.ILogger;\nimport com.hazelcast.logging.Logger;\n\n/**\n * Utility class for XML processing. It contains several methods to retrieve XML processing factories with XXE protection\n * enabled (based on recommendation in the\n * <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\">OWASP XXE prevention\n * cheat-sheet</a>).\n */\npublic final class XmlUtil {\n\n    /**\n     * System property name which allows ignoring failures during enabling the XML External Entity protection.\n     * This property should only be used as a last\n     * resort. Hazelcast uses the XXE protection by setting properties {@link XMLConstants#ACCESS_EXTERNAL_DTD} and\n     * {@link XMLConstants#ACCESS_EXTERNAL_SCHEMA}. These properties are supported in modern XML processors (JAXP 1.5+, Java\n     * 8+). Old JAXP implementations on the classpath (e.g. Xerces, Xalan) may miss the support and they throw exception\n     * during enabling the XXE protection. Setting this system property to true suppresses/ignores such Exceptions.\n     */\n    public static final String SYSTEM_PROPERTY_IGNORE_XXE_PROTECTION_FAILURES = \"hazelcast.ignoreXxeProtectionFailures\";\n\n    private static final String FEATURES_DISALLOW_DOCTYPE = \"http://apache.org/xml/features/disallow-doctype-decl\";\n    private static final ILogger LOGGER = Logger.getLogger(XmlUtil.class);\n\n    private XmlUtil() {\n    }\n\n    /**\n     * Returns namespace aware instance of {@link DocumentBuilderFactory} with XXE protection enabled.\n     *\n     * @throws ParserConfigurationException enabling XXE protection fail\n     */\n    public static DocumentBuilderFactory getNsAwareDocumentBuilderFactory() throws ParserConfigurationException {\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n        dbf.setNamespaceAware(true);\n        setFeature(dbf, FEATURES_DISALLOW_DOCTYPE);\n        return dbf;\n    }\n\n    /**\n     * Returns {@link TransformerFactory} with XXE protection enabled.\n     */\n    public static TransformerFactory getTransformerFactory() {\n        TransformerFactory transformerFactory = TransformerFactory.newInstance();\n        setAttribute(transformerFactory, XMLConstants.ACCESS_EXTERNAL_DTD);\n        setAttribute(transformerFactory, XMLConstants.ACCESS_EXTERNAL_STYLESHEET);\n        return transformerFactory;\n    }\n\n    /**\n     * Returns {@link SchemaFactory} with XXE protection enabled.\n     */\n    public static SchemaFactory getSchemaFactory() throws SAXException {\n        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n        setProperty(schemaFactory, XMLConstants.ACCESS_EXTERNAL_SCHEMA);\n        setProperty(schemaFactory, XMLConstants.ACCESS_EXTERNAL_DTD);\n        return schemaFactory;\n    }\n\n    /**\n     * Returns {@link SAXParserFactory} with XXE protection enabled.\n     */\n    public static SAXParserFactory getSAXParserFactory() throws ParserConfigurationException, SAXException {\n        SAXParserFactory factory = SAXParserFactory.newInstance();\n        setFeature(factory, FEATURES_DISALLOW_DOCTYPE);\n        return factory;\n    }\n\n    /**\n     * Returns {@link XMLInputFactory} with XXE protection enabled.\n     */\n    public static XMLInputFactory getXMLInputFactory() {\n        XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();\n        setProperty(xmlInputFactory, XMLInputFactory.SUPPORT_DTD, false);\n        return xmlInputFactory;\n    }\n\n    /**\n     * Formats given XML String with the given indentation used. If the {@code input} XML string is {@code null}, or\n     * {@code indent} parameter is negative, or XML transformation fails, then the original value is returned unchanged. The\n     * {@link IllegalArgumentException} is thrown when {@code indent==0}.\n     *\n     * @param input the XML String\n     * @param indent indentation (number of spaces used for one indentation level)\n     * @return formatted XML String or the original String if the formatting fails.\n     * @throws IllegalArgumentException when indentation is equal to zero\n     */\n    @SuppressWarnings(\"checkstyle:NPathComplexity\")\n    public static String format(@Nullable String input, int indent) throws IllegalArgumentException {\n        if (input == null || indent < 0) {\n            return input;\n        }\n        if (indent == 0) {\n            throw new IllegalArgumentException(\"Indentation must not be 0.\");\n        }\n        StreamResult xmlOutput = null;\n        try {\n            Source xmlInput = new StreamSource(new StringReader(input));\n            xmlOutput = new StreamResult(new StringWriter());\n            TransformerFactory transformerFactory = getTransformerFactory();\n            /*\n             * Older versions of Xalan still use this method of setting indent values.\n             * Attempt to make this work but don't completely fail if it's a problem.\n             */\n            try {\n                transformerFactory.setAttribute(\"indent-number\", indent);\n            } catch (IllegalArgumentException e) {\n                if (LOGGER.isFinestEnabled()) {\n                    LOGGER.finest(\"Failed to set indent-number attribute; cause: \" + e.getMessage());\n                }\n            }\n            Transformer transformer = transformerFactory.newTransformer();\n            // workaround IBM Java behavior - the silent ignorance of issues during the transformation.\n            transformer.setErrorListener(ThrowingErrorListener.INSTANCE);\n            transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"yes\");\n            transformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\");\n            transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n            /*\n             * Newer versions of Xalan will look for a fully-qualified output property in order to specify amount of\n             * indentation to use. Attempt to make this work as well but again don't completely fail if it's a problem.\n             */\n            try {\n                transformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", Integer.toString(indent));\n            } catch (IllegalArgumentException e) {\n                if (LOGGER.isFinestEnabled()) {\n                    LOGGER.finest(\"Failed to set indent-amount property; cause: \" + e.getMessage());\n                }\n            }\n            transformer.transform(xmlInput, xmlOutput);\n            return xmlOutput.getWriter().toString();\n        } catch (Exception e) {\n            LOGGER.warning(e);\n            return input;\n        } finally {\n            if (xmlOutput != null) {\n                closeResource(xmlOutput.getWriter());\n            }\n        }\n    }\n\n    /**\n     * Returns ErrorListener implementation which just throws the original error.\n     */\n    public ErrorListener getErrorListener() {\n        return ThrowingErrorListener.INSTANCE;\n    }\n\n    static void setAttribute(TransformerFactory transformerFactory, String attributeName) {\n        try {\n            transformerFactory.setAttribute(attributeName, \"\");\n        } catch (IllegalArgumentException iae) {\n            printWarningAndRethrowEventually(iae, TransformerFactory.class, \"attribute \" + attributeName);\n        }\n    }\n\n    static void setFeature(DocumentBuilderFactory dbf, String featureName) throws ParserConfigurationException {\n        try {\n            dbf.setFeature(featureName, true);\n        } catch (ParserConfigurationException e) {\n            printWarningAndRethrowEventually(e, DocumentBuilderFactory.class, \"feature \" + featureName);\n        }\n    }\n\n    static void setFeature(SAXParserFactory saxParserFactory, String featureName)\n            throws ParserConfigurationException, SAXException {\n        try {\n            saxParserFactory.setFeature(featureName, true);\n        } catch (SAXException e) {\n            printWarningAndRethrowEventually(e, SAXParserFactory.class, \"feature \" + featureName);\n        } catch (ParserConfigurationException e) {\n            printWarningAndRethrowEventually(e, SAXParserFactory.class, \"feature \" + featureName);\n        }\n    }\n\n    static void setProperty(SchemaFactory schemaFactory, String propertyName) throws SAXException {\n        try {\n            schemaFactory.setProperty(propertyName, \"\");\n        } catch (SAXException e) {\n            printWarningAndRethrowEventually(e, SchemaFactory.class, \"property \" + propertyName);\n        }\n    }\n\n    static void setProperty(XMLInputFactory xmlInputFactory, String propertyName, Object value) {\n        try {\n            xmlInputFactory.setProperty(propertyName, value);\n        } catch (IllegalArgumentException e) {\n            printWarningAndRethrowEventually(e, XMLInputFactory.class, \"property \" + propertyName);\n        }\n    }\n\n    private static <T extends Exception> void printWarningAndRethrowEventually(T cause, Class<?> clazz, String objective)\n            throws T {\n        String className = clazz.getSimpleName();\n        if (Boolean.getBoolean(SYSTEM_PROPERTY_IGNORE_XXE_PROTECTION_FAILURES)) {\n            LOGGER.warning(\"Enabling XXE protection failed. The \" + objective + \" is not supported by the \" + className\n                    + \". The \" + SYSTEM_PROPERTY_IGNORE_XXE_PROTECTION_FAILURES\n                    + \" system property is used so the XML processing continues in the UNSECURE mode\"\n                    + \" with XXE protection disabled!!!\");\n        } else {\n            LOGGER.severe(\n                    \"Enabling XXE protection failed. The \" + objective + \" is not supported by the \" + className\n                            + \". This usually mean an outdated XML processor\"\n                            + \" is present on the classpath (e.g. Xerces, Xalan). If you are not able to resolve the issue by\"\n                            + \" fixing the classpath, the \" + SYSTEM_PROPERTY_IGNORE_XXE_PROTECTION_FAILURES\n                            + \" system property can be used to disable XML External Entity protections.\"\n                            + \" We don't recommend disabling the XXE as such the XML processor configuration is unsecure!\",\n                    cause);\n            throw cause;\n        }\n    }\n\n    /**\n     * ErrorListener implementation which just throws the error. It workarounds IBM Java default behaviour when\n     * {@link Transformer#transform(Source, javax.xml.transform.Result)} finishes without problems even if an exception is\n     * thrown within the call. If an error happens, we want to know about it and handle it properly.\n     */\n    static final class ThrowingErrorListener implements ErrorListener {\n        public static final ThrowingErrorListener INSTANCE = new ThrowingErrorListener();\n\n        private ThrowingErrorListener() {\n        }\n\n        @Override\n        public void warning(TransformerException exception) throws TransformerException {\n            throw exception;\n        }\n\n        @Override\n        public void fatalError(TransformerException exception) throws TransformerException {\n            throw exception;\n        }\n\n        @Override\n        public void error(TransformerException exception) throws TransformerException {\n            throw exception;\n        }\n    }\n\n}\n", "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.internal.util;\n\nimport static com.hazelcast.internal.util.XmlUtil.SYSTEM_PROPERTY_IGNORE_XXE_PROTECTION_FAILURES;\nimport static com.hazelcast.internal.util.XmlUtil.format;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertThrows;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.stream.XMLEventReader;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.validation.SchemaFactory;\n\nimport org.fusesource.hawtbuf.ByteArrayInputStream;\nimport org.hamcrest.Matchers;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.experimental.categories.Category;\nimport org.junit.runner.RunWith;\nimport org.xml.sax.HandlerBase;\nimport org.xml.sax.SAXException;\n\nimport com.hazelcast.test.HazelcastSerialClassRunner;\nimport com.hazelcast.test.OverridePropertyRule;\nimport com.hazelcast.test.annotation.QuickTest;\n\n@RunWith(HazelcastSerialClassRunner.class)\n@Category({ QuickTest.class })\npublic class XmlUtilTest {\n\n    @Rule\n    public OverridePropertyRule ignoreXxeFailureProp = OverridePropertyRule\n            .clear(SYSTEM_PROPERTY_IGNORE_XXE_PROTECTION_FAILURES);\n\n    private DummyServer server;\n\n    @Before\n    public void before() throws IOException {\n        server = new DummyServer();\n        server.start();\n    }\n\n    @After\n    public void after() {\n        server.stop();\n    }\n\n    @Test\n    public void testUnprotectedXxe() throws Exception {\n        DocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n        try {\n            db.parse(new ByteArrayInputStream(server.getTestXml().getBytes(UTF_8)));\n        } catch (Exception e) {\n            // not important if it fails\n        }\n        assertThat(server.getHits(), Matchers.greaterThan(0));\n    }\n\n    @Test\n    public void testFormat() throws Exception {\n        assertEquals(\"<a> <b>c</b></a>\", format(\"<a><b>c</b></a>\", 1).replaceAll(\"[\\r\\n]\", \"\"));\n        assertEquals(\"<a>   <b>c</b></a>\", format(\"<a><b>c</b></a>\", 3).replaceAll(\"[\\r\\n]\", \"\"));\n        assertEquals(\"<a><b>c</b></a>\", format(\"<a><b>c</b></a>\", -21));\n\n        assertThrows(IllegalArgumentException.class, () -> format(\"<a><b>c</b></a>\", 0));\n\n        // check if the XXE protection is enabled\n        String xml = server.getTestXml();\n        assertEquals(xml, format(xml, 1));\n        assertEquals(0, server.getHits());\n\n        // wrongly formatted XML\n        assertEquals(\"<a><b>c</b><a>\", format(\"<a><b>c</b><a>\", 1));\n    }\n\n    @Test\n    public void testGetSchemaFactory() throws Exception {\n        SchemaFactory schemaFactory = XmlUtil.getSchemaFactory();\n        assertNotNull(schemaFactory);\n        assertThrows(SAXException.class, () -> XmlUtil.setProperty(schemaFactory, \"test://no-such-property\"));\n        ignoreXxeFailureProp.setOrClearProperty(\"false\");\n        assertThrows(SAXException.class, () -> XmlUtil.setProperty(schemaFactory, \"test://no-such-property\"));\n        ignoreXxeFailureProp.setOrClearProperty(\"true\");\n        XmlUtil.setProperty(schemaFactory, \"test://no-such-property\");\n    }\n\n    @Test\n    public void testGetTransformerFactory() throws Exception {\n        TransformerFactory transformerFactory = XmlUtil.getTransformerFactory();\n        assertNotNull(transformerFactory);\n        assertThrows(IllegalArgumentException.class, () -> XmlUtil.setAttribute(transformerFactory, \"test://no-such-property\"));\n        ignoreXxeFailureProp.setOrClearProperty(\"false\");\n        assertThrows(IllegalArgumentException.class, () -> XmlUtil.setAttribute(transformerFactory, \"test://no-such-property\"));\n        ignoreXxeFailureProp.setOrClearProperty(\"true\");\n        XmlUtil.setAttribute(transformerFactory, \"test://no-such-property\");\n    }\n\n    @Test\n    public void testGetDocumentBuilderFactory() throws Exception {\n        DocumentBuilderFactory dbf = XmlUtil.getNsAwareDocumentBuilderFactory();\n        assertNotNull(dbf);\n        assertThrows(ParserConfigurationException.class, () -> XmlUtil.setFeature(dbf, \"test://no-such-feature\"));\n        ignoreXxeFailureProp.setOrClearProperty(\"false\");\n        assertThrows(ParserConfigurationException.class, () -> XmlUtil.setFeature(dbf, \"test://no-such-feature\"));\n        ignoreXxeFailureProp.setOrClearProperty(\"true\");\n        XmlUtil.setFeature(dbf, \"test://no-such-feature\");\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    @Test\n    public void testGetSAXParserFactory() throws Exception {\n        SAXParserFactory saxParserFactory = XmlUtil.getSAXParserFactory();\n        assertNotNull(saxParserFactory);\n        // check if the XXE protection is enabled\n        SAXParser saxParser = saxParserFactory.newSAXParser();\n        assertThrows(SAXException.class,\n                () -> saxParser.parse(new ByteArrayInputStream(server.getTestXml().getBytes(UTF_8)), new HandlerBase()));\n        assertEquals(0, server.getHits());\n\n        assertThrows(SAXException.class, () -> XmlUtil.setFeature(saxParserFactory, \"test://no-such-feature\"));\n        ignoreXxeFailureProp.setOrClearProperty(\"false\");\n        assertThrows(SAXException.class, () -> XmlUtil.setFeature(saxParserFactory, \"test://no-such-feature\"));\n        ignoreXxeFailureProp.setOrClearProperty(\"true\");\n        XmlUtil.setFeature(saxParserFactory, \"test://no-such-feature\");\n    }\n\n    @Test\n    public void testGetXmlInputFactory() throws Exception {\n        XMLInputFactory xmlInputFactory = XmlUtil.getXMLInputFactory();\n        assertNotNull(xmlInputFactory);\n        // check if the XXE protection is enabled\n        assertThrows(XMLStreamException.class,\n                () -> staxReadEvents(xmlInputFactory.createXMLEventReader(new StringReader(server.getTestXml()))));\n        assertEquals(0, server.getHits());\n\n        assertThrows(IllegalArgumentException.class,\n                () -> XmlUtil.setProperty(xmlInputFactory, \"test://no-such-property\", false));\n        ignoreXxeFailureProp.setOrClearProperty(\"false\");\n        assertThrows(IllegalArgumentException.class,\n                () -> XmlUtil.setProperty(xmlInputFactory, \"test://no-such-property\", false));\n        ignoreXxeFailureProp.setOrClearProperty(\"true\");\n        XmlUtil.setProperty(xmlInputFactory, \"test://no-such-feature\", false);\n    }\n\n    private void staxReadEvents(XMLEventReader reader) throws XMLStreamException {\n        try {\n            while (reader.hasNext()) {\n                reader.nextEvent();\n            }\n        } finally {\n            reader.close();\n        }\n    }\n\n    static class DummyServer implements Runnable {\n        private static final String XXE_TEST_STR_TEMPLATE = \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n\"\n                + \"  <!DOCTYPE test [\\n\" + \"    <!ENTITY xxe SYSTEM \\\"%s\\\">\\n\" + \"  ]>\" + \"<a><b>&xxe;</b></a>\";\n\n        private final ServerSocket serverSocket;\n        private final AtomicInteger counter = new AtomicInteger();\n\n        DummyServer() throws IOException {\n            serverSocket = new ServerSocket(0, 5, InetAddress.getLoopbackAddress());\n        }\n\n        public void start() {\n            new Thread(this, \"DummyServer-acceptor\").start();\n        }\n\n        public String getUrlString() {\n            return \"http://127.0.0.1:\" + serverSocket.getLocalPort();\n        }\n\n        public String getTestXml() {\n            return String.format(XXE_TEST_STR_TEMPLATE, getUrlString());\n        }\n\n        public int getHits() {\n            return counter.get();\n        }\n\n        public void stop() {\n            try {\n                serverSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                try (Socket socket = serverSocket.accept()) {\n                    System.out.println(\">> connection accepted: \" + socket);\n                    counter.incrementAndGet();\n                } catch (Exception e) {\n                    System.out.println(\">> stopping the server. Cause: \" + e.getClass().getName());\n                    return;\n                }\n            }\n        }\n    }\n}\n"], "filenames": ["hazelcast/src/main/java/com/hazelcast/internal/config/AbstractXmlConfigRootTagRecognizer.java", "hazelcast/src/main/java/com/hazelcast/internal/util/XmlUtil.java", "hazelcast/src/test/java/com/hazelcast/internal/util/XmlUtilTest.java"], "buggy_code_start_loc": [20, 27, 20], "buggy_code_end_loc": [58, 225, 96], "fixing_code_start_loc": [21, 28, 21], "fixing_code_end_loc": [59, 250, 236], "type": "CWE-611", "message": "Improper Restriction of XML External Entity Reference in GitHub repository hazelcast/hazelcast in 5.1-BETA-1.", "other": {"cve": {"id": "CVE-2022-0265", "sourceIdentifier": "security@huntr.dev", "published": "2022-03-03T22:15:08.577", "lastModified": "2022-04-29T16:50:28.860", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper Restriction of XML External Entity Reference in GitHub repository hazelcast/hazelcast in 5.1-BETA-1."}, {"lang": "es", "value": "Restricci\u00f3n inadecuada de la referencia de entidad externa XML en el repositorio GitHub hazelcast/hazelcast en 5.1-BETA-1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-611"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-611"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:hazelcast:hazelcast:5.1:beta1:*:*:*:*:*:*", "matchCriteriaId": "8AD19A9D-733A-4066-8C82-97DE2B8EB64E"}]}]}], "references": [{"url": "https://github.com/hazelcast/hazelcast/commit/4d6b666cd0291abd618c3b95cdbb51aa4208e748", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/d63972a2-b910-480a-a86b-d1f75d24d563", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/hazelcast/hazelcast/commit/4d6b666cd0291abd618c3b95cdbb51aa4208e748"}}