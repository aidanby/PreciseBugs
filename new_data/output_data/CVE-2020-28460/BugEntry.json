{"buggy_code": ["# multi-ini [![Build Status](https://travis-ci.org/evangelion1204/multi-ini.png?branch=master)](https://travis-ci.org/evangelion1204/multi-ini) [![Coverage Status](https://coveralls.io/repos/evangelion1204/multi-ini/badge.svg?branch=master)](https://coveralls.io/r/evangelion1204/multi-ini?branch=master)\n\n[![Join the chat at https://gitter.im/evangelion1204/multi-ini](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/evangelion1204/multi-ini?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nAn ini-file parser which supports multi line, multiple levels and arrays to get a maximum of compatibility with Zend config files.\n\n## Install\n\n```shell\nnpm install multi-ini\n```\n\n## Usage\n\n```js\nini = require('multi-ini');\ncontent = ini.read(file);\ncontent.section.key = value;\nini.write(file, content);\n\n```\n\n## Options\n\nFollowing options are available:\n* encoding \\[*'utf8'*\\] - directly passed to readFileSync\n* keep_quotes \\[*false*\\] - does not strip quotes around values\n* filters - predefined *lowercase*, *uppercase*, *trim*, *constants*, *boolean*\n\n### Examples\n\n#### encoding\n\n```js\nini = require('multi-ini');\ncontent = ini.read(file, {encoding: 'utf8'});\ncontent.section.key = value;\nini.write(file, content, {encoding: 'utf8'});\n```\n\n#### keep_quotes\nThis option is by default off to be backward compatible, if you ever need the value containing the quotes then use this.\n```ini\nkey=\"value\"\n```\nEnabling this option will result in **\"value\"** instead of **value**.\n\n```js\nini = require('multi-ini');\ncontent = ini.read(file, {keep_quotes: true});\n```\n\nThis will also affect the Serializer and serialized values. Using it will not quote anything automatically.\n```js\n{\n    production: {\n        quoted: '\"quoted\"',\n        not_quoted: 'not_quoted'\n    }\n}\n```\n\nWill result in a ini like\n```ini\n[production]\nquoted=\"quoted\"\nnot_quotes=not_quoted\n```\n\n#### filters\n\n```js\nMultiIni = require('multi-ini');\nini = new MultiIni.Class({\n    filters: [MultiIni.filters.lowercase]\n});\ncontent = ini.read(file);\n```\n\n*Replacing constants*\n```js\nMultiIni = require('multi-ini');\nini = new MultiIni.Class({\n  constants: {'CONSTANT': 'replacement'},\n  filters: [MultiIni.filters.constants]\n});\ncontent = ini.read(file);\n```\n\n\n*Define a custom filter*\n```js\nMultiIni = require('multi-ini');\nini = new MultiIni.Class({\n    filters: [\n        function (value) {\n            return \"Prepend \" + value;\n        }\n    ]\n});\ncontent = ini.read(file);\n```\n\n#### line_breaks\n\nEither `unix` or `windows` for line breaks.\n\n```js\nini = require('multi-ini');\ncontent = ini.read(file, {line_breaks: 'windows'});\ncontent.section.key = value;\n```\n\n#### Parser\n\nIt's also possible to parse a ini file from an array of strings.\n\n```js\nini = require('multi-ini');\nparser = new ini.Parser();\ncontent = parser.parse(lines);\n```\n\n#### Serializer\n\nLike parsing it's also possible to serialize an ini object to a string.\n\n```js\nini = require('multi-ini');\nserializer = new ini.Serializer();\ncontent = serializer.serialize({\n    production: {\n        base_url: 'https://google.com'\n    }\n});\n```\n\n## Changelog\n\n### 1.0.1\n* Fixed bug with `keep_quotes` ignored when writing files\n\n### 1.0.0\n* First full release keeping backwards compatibility\n\n### 0.5.2\n* Introduced option for line breaks\n\n### 0.5.1\n* Fixed a bug where single lines of multilines got trimmed\n\n### 0.5.0\n* Added support for filters per value\n\n### 0.4.0\n* Refactoring of the basic implementation to be no longer a singleton\n* Fixed a bug with wrong detected escaped double quotes\n\n### 0.2.5\nNow correctly reads\n```ini\nkey= example\n```\nto the value \"**example**\" instead of \"** example**\"\n\n### 0.2.4\nImplemented support for constants and removed a lot of bugs and the options **ignore_invalid** and **oninvalid**, this may be introduced again but are currently not necessary.\n\n### 0.2.3\nFixed a bug that the module was not recognized as a module by Node.\n", "{\n  \"name\": \"multi-ini\",\n  \"version\": \"2.1.1\",\n  \"license\": \"MIT\",\n  \"description\": \"An ini-file parser which supports multi line, multiple levels and arrays to get a maximum of compatibility with Zend config files.\",\n  \"main\": \"lib/index.js\",\n  \"scripts\": {\n    \"predistribute\": \"babel src --out-dir lib\",\n    \"test\": \"babel-node ./node_modules/.bin/_mocha\",\n    \"coverage\": \"babel-node ./node_modules/.bin/istanbul cover _mocha\",\n    \"distribute\": \"npm publish\"\n  },\n  \"homepage\": \"https://github.com/evangelion1204/multi-ini\",\n  \"author\": {\n    \"name\": \"Michael Iwersen\",\n    \"email\": \"mi.iwersen@gmail.com\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/evangelion1204/multi-ini.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/evangelion1204/multi-ini/issues\"\n  },\n  \"licenses\": [\n    {\n      \"type\": \"MIT\",\n      \"url\": \"https://github.com/evangelion1204/multi-ini/blob/master/LICENSE\"\n    }\n  ],\n  \"keywords\": [\n    \"ini\",\n    \"zend\",\n    \"config\",\n    \"multi-line\",\n    \"multi-level\"\n  ],\n  \"devDependencies\": {\n    \"babel-cli\": \"^6.3.17\",\n    \"babel-plugin-check-es2015-constants\": \"^6.3.13\",\n    \"babel-plugin-transform-es2015-arrow-functions\": \"^6.4.0\",\n    \"babel-plugin-transform-es2015-block-scoping\": \"^6.3.13\",\n    \"babel-plugin-transform-es2015-classes\": \"^6.3.15\",\n    \"babel-plugin-transform-es2015-destructuring\": \"^6.18.0\",\n    \"babel-plugin-transform-es2015-for-of\": \"^6.18.0\",\n    \"babel-plugin-transform-es2015-modules-commonjs\": \"^6.3.16\",\n    \"babel-plugin-transform-es2015-parameters\": \"^6.3.26\",\n    \"babel-plugin-transform-es2015-shorthand-properties\": \"^6.18.0\",\n    \"babel-plugin-transform-es2015-template-literals\": \"^6.3.13\",\n    \"babel-plugin-transform-object-assign\": \"^6.8.0\",\n    \"babel-plugin-transform-object-rest-spread\": \"^6.19.0\",\n    \"babel-register\": \"^6.18.0\",\n    \"benchmark\": \"^2.0.0\",\n    \"chai\": \"^3.4.1\",\n    \"istanbul\": \"^1.1.0-alpha.1\",\n    \"mocha\": \"^5.2.0\",\n    \"sinon\": \"^1.17.2\",\n    \"sinon-chai\": \"^2.8.0\"\n  },\n  \"dependencies\": {\n    \"lodash\": \"^4.0.0\"\n  }\n}\n", "'use strict';\n\n// match1 - section, match2 - optional full inheritance  part, match3 - inherited section\nconst REGEXP_SECTION = /^\\s*\\[\\s*([^:]*?)\\s*(:\\s*(.+?)\\s*)?\\]\\s*$/;\nconst REGEXP_COMMENT = /^;.*/;\nconst REGEXP_SINGLE_LINE = /^\\s*(.*?)\\s*?=\\s*?(\\S.*?)$/;\nconst REGEXP_MULTI_LINE = /^\\s*(.*?)\\s*?=\\s*?\"(.*?)$/;\nconst REGEXP_NOT_ESCAPED_MULTI_LINE_END = /^(.*?)\\\\\"$/;\nconst REGEXP_MULTI_LINE_END = /^(.*?)\"$/;\nconst REGEXP_ARRAY = /^(.*?)\\[\\]$/;\n\nconst STATUS_OK = 0;\nconst STATUS_INVALID = 1;\n\nconst defaults = {\n    ignore_invalid: true,\n    keep_quotes: false,\n    oninvalid: () => true,\n    filters: [],\n    constants: {},\n};\n\nconst REGEXP_IGNORE_KEYS = /__proto__/;\n\nclass Parser {\n    constructor(options = {}) {\n        this.options = Object.assign({}, defaults, options);\n\n        this.handlers = [\n            this.handleMultiLineStart,\n            this.handleMultiLineEnd,\n            this.handleMultiLineAppend,\n            this.handleComment,\n            this.handleSection,\n            this.handleSingleLine,\n        ];\n    }\n\n    parse(lines) {\n        const ctx = {\n            ini: {},\n            current: {},\n            multiLineKeys: false,\n            multiLineValue: '',\n        };\n\n        for (let line of lines) {\n            for (let handler of this.handlers) {\n                const stop = handler.call(this, ctx, line);\n\n                if (stop) {\n                    break;\n                }\n            }\n        }\n\n        return ctx.ini;\n    }\n\n    isSection(line) {\n        return line.match(REGEXP_SECTION);\n    }\n\n    getSection(line) {\n        return line.match(REGEXP_SECTION)[1];\n    }\n\n    getParentSection(line) {\n        return line.match(REGEXP_SECTION)[3];\n    }\n\n    isInheritedSection(line) {\n        return !!line.match(REGEXP_SECTION)[3];\n    }\n\n    isComment(line) {\n        return line.match(REGEXP_COMMENT);\n    }\n\n    isSingleLine(line) {\n        const result = line.match(REGEXP_SINGLE_LINE);\n\n        if (!result) {\n            return false;\n        }\n\n        const check = result[2].match(/\"/g);\n\n        return !check || check.length % 2 === 0;\n    }\n\n    isMultiLine(line) {\n        const result = line.match(REGEXP_MULTI_LINE);\n\n        if (!result) {\n            return false;\n        }\n\n        const check = result[2].match(/\"/g);\n\n        return !check || check.length % 2 === 0;\n    }\n\n    isMultiLineEnd(line) {\n        return line.match(REGEXP_MULTI_LINE_END) && !line.match(REGEXP_NOT_ESCAPED_MULTI_LINE_END);\n    }\n\n    isArray(line) {\n        return line.match(REGEXP_ARRAY);\n    }\n\n    assignValue(element, keys, value) {\n        value = this.applyFilter(value);\n\n        let current = element;\n        let previous = element;\n        let array = false;\n        let key;\n\n        if (keys.some((key) => REGEXP_IGNORE_KEYS.test(key))) {\n            return;\n        }\n\n        for (key of keys) {\n            if (this.isArray(key)) {\n                key = this.getArrayKey(key);\n                array = true;\n            }\n\n            if (current[key] == null) {\n                current[key] = array ? [] : {};\n            }\n\n            previous = current;\n            current = current[key];\n        }\n\n        if (array) {\n            current.push(value);\n        } else {\n            previous[key] = value;\n        }\n\n        return element;\n    }\n\n    applyFilter(value) {\n        for (let filter of this.options.filters) {\n            value = filter(value, this.options);\n        }\n\n        return value;\n    }\n\n    getKeyValue(line) {\n        const result = line.match(REGEXP_SINGLE_LINE);\n\n        if (!result) {\n            throw new Error();\n        }\n\n        let [, key, value] = result;\n\n        if (!this.options.keep_quotes) {\n            value = value.replace(/^\\s*?\"(.*?)\"\\s*?$/, '$1');\n        }\n\n        return { key, value, status: STATUS_OK };\n    }\n\n    getMultiKeyValue(line) {\n        const result = line.match(REGEXP_MULTI_LINE);\n\n        if (!result) {\n            throw new Error();\n        }\n\n        let [, key, value] = result;\n\n        if (this.options.keep_quotes) {\n            value = '\"' + value;\n        }\n\n        return { key, value };\n    }\n\n    getMultiLineEndValue(line) {\n        const result = line.match(REGEXP_MULTI_LINE_END);\n\n        if (!result) {\n            throw new Error();\n        }\n\n        let [, value] = result;\n\n        if (this.options.keep_quotes) {\n            value = value + '\"';\n        }\n\n        return { value, status: STATUS_OK };\n    }\n\n    getArrayKey(line) {\n        const result = line.match(REGEXP_ARRAY);\n\n        return result[1];\n    }\n\n    handleMultiLineStart(ctx, line) {\n        if (!this.isMultiLine(line.trim())) {\n            return false;\n        }\n\n        const { key, value } = this.getMultiKeyValue(line);\n        const keys = key.split('.');\n\n        ctx.multiLineKeys = keys;\n        ctx.multiLineValue = value;\n\n        return true;\n    }\n\n    handleMultiLineEnd(ctx, line) {\n        if (!ctx.multiLineKeys || !this.isMultiLineEnd(line.trim())) {\n            return false;\n        }\n\n        const { value, status } = this.getMultiLineEndValue(line);\n\n        // abort on false of onerror callback if we meet an invalid line\n        if (status === STATUS_INVALID && !this.options.oninvalid(line)) {\n            return;\n        }\n\n        // ignore whole multiline on invalid\n        if (status === STATUS_INVALID && this.options.ignore_invalid) {\n            ctx.multiLineKeys = false;\n            ctx.multiLineValue = '';\n\n            return true;\n        }\n\n        ctx.multiLineValue += '\\n' + value;\n\n        this.assignValue(ctx.current, ctx.multiLineKeys, ctx.multiLineValue);\n\n        ctx.multiLineKeys = false;\n        ctx.multiLineValue = '';\n\n        return true;\n    }\n\n    handleMultiLineAppend(ctx, line) {\n        if (!ctx.multiLineKeys || this.isMultiLineEnd(line.trim())) {\n            return false;\n        }\n\n        ctx.multiLineValue += '\\n' + line;\n\n        return true;\n    }\n\n    handleComment(ctx, line) {\n        return this.isComment(line.trim());\n    }\n\n    handleSection(ctx, line) {\n        line = line.trim();\n\n        if (!this.isSection(line)) {\n            return false;\n        }\n\n        const section = this.getSection(line);\n\n        if (REGEXP_IGNORE_KEYS.test(section)) {\n            return false;\n        }\n\n        if (this.isInheritedSection(line)) {\n            const parentSection = this.getParentSection(line);\n            ctx.ini[section] = JSON.parse(JSON.stringify(ctx.ini[parentSection]));\n        }\n\n        if (typeof ctx.ini[section] === 'undefined') {\n            ctx.ini[section] = {};\n        }\n\n        ctx.current = ctx.ini[section];\n\n        return true;\n    }\n\n    handleSingleLine(ctx, line) {\n        line = line.trim();\n\n        if (!this.isSingleLine(line)) {\n            return false;\n        }\n\n        const { key, value, status } = this.getKeyValue(line);\n\n        // abort on false of onerror callback if we meet an invalid line\n        if (status === STATUS_INVALID && !this.options.oninvalid(line)) {\n            throw new Error('Abort');\n        }\n\n        // skip entry\n        if (status === STATUS_INVALID && !this.options.ignore_invalid) {\n            return true;\n        }\n\n        const keys = key.split('.');\n\n        this.assignValue(ctx.current, keys, value);\n\n        return true;\n    }\n}\n\nmodule.exports = Parser;\n", "[test]\nvalue=key\n[__proto__]\npolluted=\"polluted\"\n[other]\n__proto__.path_polluted=\"polluted\""], "fixing_code": ["# multi-ini [![Build Status](https://travis-ci.org/evangelion1204/multi-ini.png?branch=master)](https://travis-ci.org/evangelion1204/multi-ini) [![Coverage Status](https://coveralls.io/repos/evangelion1204/multi-ini/badge.svg?branch=master)](https://coveralls.io/r/evangelion1204/multi-ini?branch=master)\n\n[![Join the chat at https://gitter.im/evangelion1204/multi-ini](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/evangelion1204/multi-ini?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nAn ini-file parser which supports multi line, multiple levels and arrays to get a maximum of compatibility with Zend config files.\n\n## Install\n\n```shell\nnpm install multi-ini\n```\n\n## Usage\n\n```js\nini = require('multi-ini');\ncontent = ini.read(file);\ncontent.section.key = value;\nini.write(file, content);\n\n```\n\n## Options\n\nFollowing options are available:\n* encoding \\[*'utf8'*\\] - directly passed to readFileSync\n* keep_quotes \\[*false*\\] - does not strip quotes around values\n* filters - predefined *lowercase*, *uppercase*, *trim*, *constants*, *boolean*\n\n### Examples\n\n#### encoding\n\n```js\nini = require('multi-ini');\ncontent = ini.read(file, {encoding: 'utf8'});\ncontent.section.key = value;\nini.write(file, content, {encoding: 'utf8'});\n```\n\n#### keep_quotes\nThis option is by default off to be backward compatible, if you ever need the value containing the quotes then use this.\n```ini\nkey=\"value\"\n```\nEnabling this option will result in **\"value\"** instead of **value**.\n\n```js\nini = require('multi-ini');\ncontent = ini.read(file, {keep_quotes: true});\n```\n\nThis will also affect the Serializer and serialized values. Using it will not quote anything automatically.\n```js\n{\n    production: {\n        quoted: '\"quoted\"',\n        not_quoted: 'not_quoted'\n    }\n}\n```\n\nWill result in a ini like\n```ini\n[production]\nquoted=\"quoted\"\nnot_quotes=not_quoted\n```\n\n#### filters\n\n```js\nMultiIni = require('multi-ini');\nini = new MultiIni.Class({\n    filters: [MultiIni.filters.lowercase]\n});\ncontent = ini.read(file);\n```\n\n*Replacing constants*\n```js\nMultiIni = require('multi-ini');\nini = new MultiIni.Class({\n  constants: {'CONSTANT': 'replacement'},\n  filters: [MultiIni.filters.constants]\n});\ncontent = ini.read(file);\n```\n\n\n*Define a custom filter*\n```js\nMultiIni = require('multi-ini');\nini = new MultiIni.Class({\n    filters: [\n        function (value) {\n            return \"Prepend \" + value;\n        }\n    ]\n});\ncontent = ini.read(file);\n```\n\n#### line_breaks\n\nEither `unix` or `windows` for line breaks.\n\n```js\nini = require('multi-ini');\ncontent = ini.read(file, {line_breaks: 'windows'});\ncontent.section.key = value;\n```\n\n#### Parser\n\nIt's also possible to parse a ini file from an array of strings.\n\n```js\nini = require('multi-ini');\nparser = new ini.Parser();\ncontent = parser.parse(lines);\n```\n\n#### Serializer\n\nLike parsing it's also possible to serialize an ini object to a string.\n\n```js\nini = require('multi-ini');\nserializer = new ini.Serializer();\ncontent = serializer.serialize({\n    production: {\n        base_url: 'https://google.com'\n    }\n});\n```\n\n## Changelog\n\n### 2.1.2\n* Fixed prototype pollution by ignoring `constructor`\n\n### 2.1.1\n* Fixed prototype pollution by ignoring `__proto__`\n\n### 1.0.1\n* Fixed bug with `keep_quotes` ignored when writing files\n\n### 1.0.0\n* First full release keeping backwards compatibility\n\n### 0.5.2\n* Introduced option for line breaks\n\n### 0.5.1\n* Fixed a bug where single lines of multilines got trimmed\n\n### 0.5.0\n* Added support for filters per value\n\n### 0.4.0\n* Refactoring of the basic implementation to be no longer a singleton\n* Fixed a bug with wrong detected escaped double quotes\n\n### 0.2.5\nNow correctly reads\n```ini\nkey= example\n```\nto the value \"**example**\" instead of \"** example**\"\n\n### 0.2.4\nImplemented support for constants and removed a lot of bugs and the options **ignore_invalid** and **oninvalid**, this may be introduced again but are currently not necessary.\n\n### 0.2.3\nFixed a bug that the module was not recognized as a module by Node.\n", "{\n  \"name\": \"multi-ini\",\n  \"version\": \"2.1.2\",\n  \"license\": \"MIT\",\n  \"description\": \"An ini-file parser which supports multi line, multiple levels and arrays to get a maximum of compatibility with Zend config files.\",\n  \"main\": \"lib/index.js\",\n  \"scripts\": {\n    \"predistribute\": \"babel src --out-dir lib\",\n    \"test\": \"babel-node ./node_modules/.bin/_mocha\",\n    \"coverage\": \"babel-node ./node_modules/.bin/istanbul cover _mocha\",\n    \"distribute\": \"npm publish\"\n  },\n  \"homepage\": \"https://github.com/evangelion1204/multi-ini\",\n  \"author\": {\n    \"name\": \"Michael Iwersen\",\n    \"email\": \"mi.iwersen@gmail.com\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/evangelion1204/multi-ini.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/evangelion1204/multi-ini/issues\"\n  },\n  \"licenses\": [\n    {\n      \"type\": \"MIT\",\n      \"url\": \"https://github.com/evangelion1204/multi-ini/blob/master/LICENSE\"\n    }\n  ],\n  \"keywords\": [\n    \"ini\",\n    \"zend\",\n    \"config\",\n    \"multi-line\",\n    \"multi-level\"\n  ],\n  \"devDependencies\": {\n    \"babel-cli\": \"^6.3.17\",\n    \"babel-plugin-check-es2015-constants\": \"^6.3.13\",\n    \"babel-plugin-transform-es2015-arrow-functions\": \"^6.4.0\",\n    \"babel-plugin-transform-es2015-block-scoping\": \"^6.3.13\",\n    \"babel-plugin-transform-es2015-classes\": \"^6.3.15\",\n    \"babel-plugin-transform-es2015-destructuring\": \"^6.18.0\",\n    \"babel-plugin-transform-es2015-for-of\": \"^6.18.0\",\n    \"babel-plugin-transform-es2015-modules-commonjs\": \"^6.3.16\",\n    \"babel-plugin-transform-es2015-parameters\": \"^6.3.26\",\n    \"babel-plugin-transform-es2015-shorthand-properties\": \"^6.18.0\",\n    \"babel-plugin-transform-es2015-template-literals\": \"^6.3.13\",\n    \"babel-plugin-transform-object-assign\": \"^6.8.0\",\n    \"babel-plugin-transform-object-rest-spread\": \"^6.19.0\",\n    \"babel-register\": \"^6.18.0\",\n    \"benchmark\": \"^2.0.0\",\n    \"chai\": \"^3.4.1\",\n    \"istanbul\": \"^1.1.0-alpha.1\",\n    \"mocha\": \"^5.2.0\",\n    \"sinon\": \"^1.17.2\",\n    \"sinon-chai\": \"^2.8.0\"\n  },\n  \"dependencies\": {\n    \"lodash\": \"^4.0.0\"\n  }\n}\n", "'use strict';\n\n// match1 - section, match2 - optional full inheritance  part, match3 - inherited section\nconst REGEXP_SECTION = /^\\s*\\[\\s*([^:]*?)\\s*(:\\s*(.+?)\\s*)?\\]\\s*$/;\nconst REGEXP_COMMENT = /^;.*/;\nconst REGEXP_SINGLE_LINE = /^\\s*(.*?)\\s*?=\\s*?(\\S.*?)$/;\nconst REGEXP_MULTI_LINE = /^\\s*(.*?)\\s*?=\\s*?\"(.*?)$/;\nconst REGEXP_NOT_ESCAPED_MULTI_LINE_END = /^(.*?)\\\\\"$/;\nconst REGEXP_MULTI_LINE_END = /^(.*?)\"$/;\nconst REGEXP_ARRAY = /^(.*?)\\[\\]$/;\n\nconst STATUS_OK = 0;\nconst STATUS_INVALID = 1;\n\nconst defaults = {\n    ignore_invalid: true,\n    keep_quotes: false,\n    oninvalid: () => true,\n    filters: [],\n    constants: {},\n};\n\nconst REGEXP_IGNORE_KEYS = /__proto__|constructor|prototype/;\n\nclass Parser {\n    constructor(options = {}) {\n        this.options = Object.assign({}, defaults, options);\n\n        this.handlers = [\n            this.handleMultiLineStart,\n            this.handleMultiLineEnd,\n            this.handleMultiLineAppend,\n            this.handleComment,\n            this.handleSection,\n            this.handleSingleLine,\n        ];\n    }\n\n    parse(lines) {\n        const ctx = {\n            ini: {},\n            current: {},\n            multiLineKeys: false,\n            multiLineValue: '',\n        };\n\n        for (let line of lines) {\n            for (let handler of this.handlers) {\n                const stop = handler.call(this, ctx, line);\n\n                if (stop) {\n                    break;\n                }\n            }\n        }\n\n        return ctx.ini;\n    }\n\n    isSection(line) {\n        return line.match(REGEXP_SECTION);\n    }\n\n    getSection(line) {\n        return line.match(REGEXP_SECTION)[1];\n    }\n\n    getParentSection(line) {\n        return line.match(REGEXP_SECTION)[3];\n    }\n\n    isInheritedSection(line) {\n        return !!line.match(REGEXP_SECTION)[3];\n    }\n\n    isComment(line) {\n        return line.match(REGEXP_COMMENT);\n    }\n\n    isSingleLine(line) {\n        const result = line.match(REGEXP_SINGLE_LINE);\n\n        if (!result) {\n            return false;\n        }\n\n        const check = result[2].match(/\"/g);\n\n        return !check || check.length % 2 === 0;\n    }\n\n    isMultiLine(line) {\n        const result = line.match(REGEXP_MULTI_LINE);\n\n        if (!result) {\n            return false;\n        }\n\n        const check = result[2].match(/\"/g);\n\n        return !check || check.length % 2 === 0;\n    }\n\n    isMultiLineEnd(line) {\n        return line.match(REGEXP_MULTI_LINE_END) && !line.match(REGEXP_NOT_ESCAPED_MULTI_LINE_END);\n    }\n\n    isArray(line) {\n        return line.match(REGEXP_ARRAY);\n    }\n\n    assignValue(element, keys, value) {\n        value = this.applyFilter(value);\n\n        let current = element;\n        let previous = element;\n        let array = false;\n        let key;\n\n        if (keys.some((key) => REGEXP_IGNORE_KEYS.test(key))) {\n            return;\n        }\n\n        for (key of keys) {\n            if (this.isArray(key)) {\n                key = this.getArrayKey(key);\n                array = true;\n            }\n\n            if (current[key] == null) {\n                current[key] = array ? [] : {};\n            }\n\n            previous = current;\n            current = current[key];\n        }\n\n        if (array) {\n            current.push(value);\n        } else {\n            previous[key] = value;\n        }\n\n        return element;\n    }\n\n    applyFilter(value) {\n        for (let filter of this.options.filters) {\n            value = filter(value, this.options);\n        }\n\n        return value;\n    }\n\n    getKeyValue(line) {\n        const result = line.match(REGEXP_SINGLE_LINE);\n\n        if (!result) {\n            throw new Error();\n        }\n\n        let [, key, value] = result;\n\n        if (!this.options.keep_quotes) {\n            value = value.replace(/^\\s*?\"(.*?)\"\\s*?$/, '$1');\n        }\n\n        return { key, value, status: STATUS_OK };\n    }\n\n    getMultiKeyValue(line) {\n        const result = line.match(REGEXP_MULTI_LINE);\n\n        if (!result) {\n            throw new Error();\n        }\n\n        let [, key, value] = result;\n\n        if (this.options.keep_quotes) {\n            value = '\"' + value;\n        }\n\n        return { key, value };\n    }\n\n    getMultiLineEndValue(line) {\n        const result = line.match(REGEXP_MULTI_LINE_END);\n\n        if (!result) {\n            throw new Error();\n        }\n\n        let [, value] = result;\n\n        if (this.options.keep_quotes) {\n            value = value + '\"';\n        }\n\n        return { value, status: STATUS_OK };\n    }\n\n    getArrayKey(line) {\n        const result = line.match(REGEXP_ARRAY);\n\n        return result[1];\n    }\n\n    handleMultiLineStart(ctx, line) {\n        if (!this.isMultiLine(line.trim())) {\n            return false;\n        }\n\n        const { key, value } = this.getMultiKeyValue(line);\n        const keys = key.split('.');\n\n        ctx.multiLineKeys = keys;\n        ctx.multiLineValue = value;\n\n        return true;\n    }\n\n    handleMultiLineEnd(ctx, line) {\n        if (!ctx.multiLineKeys || !this.isMultiLineEnd(line.trim())) {\n            return false;\n        }\n\n        const { value, status } = this.getMultiLineEndValue(line);\n\n        // abort on false of onerror callback if we meet an invalid line\n        if (status === STATUS_INVALID && !this.options.oninvalid(line)) {\n            return;\n        }\n\n        // ignore whole multiline on invalid\n        if (status === STATUS_INVALID && this.options.ignore_invalid) {\n            ctx.multiLineKeys = false;\n            ctx.multiLineValue = '';\n\n            return true;\n        }\n\n        ctx.multiLineValue += '\\n' + value;\n\n        this.assignValue(ctx.current, ctx.multiLineKeys, ctx.multiLineValue);\n\n        ctx.multiLineKeys = false;\n        ctx.multiLineValue = '';\n\n        return true;\n    }\n\n    handleMultiLineAppend(ctx, line) {\n        if (!ctx.multiLineKeys || this.isMultiLineEnd(line.trim())) {\n            return false;\n        }\n\n        ctx.multiLineValue += '\\n' + line;\n\n        return true;\n    }\n\n    handleComment(ctx, line) {\n        return this.isComment(line.trim());\n    }\n\n    handleSection(ctx, line) {\n        line = line.trim();\n\n        if (!this.isSection(line)) {\n            return false;\n        }\n\n        const section = this.getSection(line);\n\n        if (REGEXP_IGNORE_KEYS.test(section)) {\n            return false;\n        }\n\n        if (this.isInheritedSection(line)) {\n            const parentSection = this.getParentSection(line);\n            ctx.ini[section] = JSON.parse(JSON.stringify(ctx.ini[parentSection]));\n        }\n\n        if (typeof ctx.ini[section] === 'undefined') {\n            ctx.ini[section] = {};\n        }\n\n        ctx.current = ctx.ini[section];\n\n        return true;\n    }\n\n    handleSingleLine(ctx, line) {\n        line = line.trim();\n\n        if (!this.isSingleLine(line)) {\n            return false;\n        }\n\n        const { key, value, status } = this.getKeyValue(line);\n\n        // abort on false of onerror callback if we meet an invalid line\n        if (status === STATUS_INVALID && !this.options.oninvalid(line)) {\n            throw new Error('Abort');\n        }\n\n        // skip entry\n        if (status === STATUS_INVALID && !this.options.ignore_invalid) {\n            return true;\n        }\n\n        const keys = key.split('.');\n\n        this.assignValue(ctx.current, keys, value);\n\n        return true;\n    }\n}\n\nmodule.exports = Parser;\n", "[test]\nvalue=key\n[__proto__]\npolluted=\"polluted\"\n[other]\n__proto__.path_polluted=\"polluted\"\n[constructor]\nprototype.polluted = polluted\n[prototype]\npolluted = polluted"], "filenames": ["README.md", "package.json", "src/parser.js", "test/data/prototype_pollution.ini"], "buggy_code_start_loc": [139, 3, 23, 6], "buggy_code_end_loc": [139, 4, 24, 7], "fixing_code_start_loc": [140, 3, 23, 6], "fixing_code_end_loc": [146, 4, 24, 11], "type": "CWE-1321", "message": "This affects the package multi-ini before 2.1.2. It is possible to pollute an object's prototype by specifying the constructor.proto object as part of an array. This is a bypass of CVE-2020-28448.", "other": {"cve": {"id": "CVE-2020-28460", "sourceIdentifier": "report@snyk.io", "published": "2020-12-22T13:15:12.507", "lastModified": "2022-12-02T19:39:41.243", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects the package multi-ini before 2.1.2. It is possible to pollute an object's prototype by specifying the constructor.proto object as part of an array. This is a bypass of CVE-2020-28448."}, {"lang": "es", "value": "Esto afecta al paquete multi-ini versiones anteriores a 2.1.2.&#xa0;Es posible contaminar el prototipo de un objeto al especificar el objeto constructor.proto como parte de una matriz.&#xa0;Esto es una omisi\u00f3n de CVE-2020-28448"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:multi-ini_project:multi-ini:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "2.1.2", "matchCriteriaId": "F883EB8D-B5B6-428F-A607-D935A7D2EDE0"}]}]}], "references": [{"url": "https://github.com/evangelion1204/multi-ini/commit/6b2212b2ce152c19538a2431415f72942c5a1bde", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-MULTIINI-1053229", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/evangelion1204/multi-ini/commit/6b2212b2ce152c19538a2431415f72942c5a1bde"}}