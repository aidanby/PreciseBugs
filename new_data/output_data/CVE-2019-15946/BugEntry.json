{"buggy_code": ["/*\n * asn1.c: ASN.1 decoding functions (DER)\n *\n * Copyright (C) 2001, 2002  Juha Yrj\u00f6l\u00e4 <juha.yrjola@iki.fi>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <assert.h>\n#include <ctype.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"internal.h\"\n#include \"asn1.h\"\n\nstatic int asn1_decode(sc_context_t *ctx, struct sc_asn1_entry *asn1,\n\t\t       const u8 *in, size_t len, const u8 **newp, size_t *len_left,\n\t\t       int choice, int depth);\nstatic int asn1_encode(sc_context_t *ctx, const struct sc_asn1_entry *asn1,\n\t\t       u8 **ptr, size_t *size, int depth);\nstatic int asn1_write_element(sc_context_t *ctx, unsigned int tag,\n\t\tconst u8 * data, size_t datalen, u8 ** out, size_t * outlen);\n\nstatic const char *tag2str(unsigned int tag)\n{\n\tstatic const char *tags[] = {\n\t\t\"EOC\", \"BOOLEAN\", \"INTEGER\", \"BIT STRING\", \"OCTET STRING\",\t/* 0-4 */\n\t\t\"NULL\", \"OBJECT IDENTIFIER\", \"OBJECT DESCRIPTOR\", \"EXTERNAL\", \"REAL\",\t/* 5-9 */\n\t\t\"ENUMERATED\", \"Universal 11\", \"UTF8String\", \"Universal 13\",\t/* 10-13 */\n\t\t\"Universal 14\", \"Universal 15\", \"SEQUENCE\", \"SET\",\t/* 15-17 */\n\t\t\"NumericString\", \"PrintableString\", \"T61String\",\t/* 18-20 */\n\t\t\"VideotexString\", \"IA5String\", \"UTCTIME\", \"GENERALIZEDTIME\",\t/* 21-24 */\n\t\t\"GraphicString\", \"VisibleString\", \"GeneralString\",\t/* 25-27 */\n\t\t\"UniversalString\", \"Universal 29\", \"BMPString\"\t/* 28-30 */\n\t};\n\n\tif (tag > 30)\n\t\treturn \"(unknown)\";\n\treturn tags[tag];\n}\n\nint sc_asn1_read_tag(const u8 ** buf, size_t buflen, unsigned int *cla_out,\n\t\t     unsigned int *tag_out, size_t *taglen)\n{\n\tconst u8 *p = *buf;\n\tsize_t left = buflen, len;\n\tunsigned int cla, tag, i;\n\n\t*buf = NULL;\n\n\tif (left == 0)\n\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\tif (*p == 0xff || *p == 0) {\n\t\t/* end of data reached */\n\t\t*taglen = 0;\n\t\t*tag_out = SC_ASN1_TAG_EOC;\n\t\treturn SC_SUCCESS;\n\t}\n\n\t/* parse tag byte(s)\n\t * Resulted tag is presented by integer that has not to be\n\t * confused with the 'tag number' part of ASN.1 tag.\n\t */\n\tcla = (*p & SC_ASN1_TAG_CLASS) | (*p & SC_ASN1_TAG_CONSTRUCTED);\n\ttag = *p & SC_ASN1_TAG_PRIMITIVE;\n\tp++;\n\tleft--;\n\tif (tag == SC_ASN1_TAG_PRIMITIVE) {\n\t\t/* high tag number */\n\t\tsize_t n = SC_ASN1_TAGNUM_SIZE - 1;\n\t\t/* search the last tag octet */\n\t\tdo {\n\t\t\tif (left == 0 || n == 0)\n\t\t\t\t/* either an invalid tag or it doesn't fit in\n\t\t\t\t * unsigned int */\n\t\t\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\t\t\ttag <<= 8;\n\t\t\ttag |= *p;\n\t\t\tp++;\n\t\t\tleft--;\n\t\t\tn--;\n\t\t} while (tag & 0x80);\n\t}\n\n\t/* parse length byte(s) */\n\tif (left == 0)\n\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\tlen = *p;\n\tp++;\n\tleft--;\n\tif (len & 0x80) {\n\t\tlen &= 0x7f;\n\t\tunsigned int a = 0;\n\t\tif (len > sizeof a || len > left)\n\t\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\ta <<= 8;\n\t\t\ta |= *p;\n\t\t\tp++;\n\t\t\tleft--;\n\t\t}\n\t\tlen = a;\n\t}\n\n\t*cla_out = cla;\n\t*tag_out = tag;\n\t*taglen = len;\n\t*buf = p;\n\n\tif (len > left)\n\t\treturn SC_ERROR_ASN1_END_OF_CONTENTS;\n\n\treturn SC_SUCCESS;\n}\n\nvoid sc_format_asn1_entry(struct sc_asn1_entry *entry, void *parm, void *arg,\n\t\t\t  int set_present)\n{\n\tentry->parm = parm;\n\tentry->arg  = arg;\n\tif (set_present)\n\t\tentry->flags |= SC_ASN1_PRESENT;\n}\n\nvoid sc_copy_asn1_entry(const struct sc_asn1_entry *src,\n\t\t\tstruct sc_asn1_entry *dest)\n{\n\twhile (src->name != NULL) {\n\t\t*dest = *src;\n\t\tdest++;\n\t\tsrc++;\n\t}\n\tdest->name = NULL;\n}\n\nstatic void print_indent(size_t depth)\n{\n\tfor (; depth > 0; depth--) {\n\t\tputchar(' ');\n\t}\n}\n\nstatic void print_hex(const u8 * buf, size_t buflen, size_t depth)\n{\n\tsize_t lines_len = buflen * 5 + 128;\n\tchar *lines = malloc(lines_len);\n\tchar *line = lines;\n\n\tif (buf == NULL || buflen == 0 || lines == NULL) {\n\t\tfree(lines);\n\t\treturn;\n\t}\n\n\tsc_hex_dump(buf, buflen, lines, lines_len);\n\n\twhile (*line != '\\0') {\n\t\tchar *line_end = strchr(line, '\\n');\n\t\tptrdiff_t width = line_end - line;\n\t\tif (!line_end || width <= 1) {\n\t\t\t/* don't print empty lines */\n\t\t\tbreak;\n\t\t}\n\t\tif (buflen > 8) {\n\t\t\tputchar('\\n');\n\t\t\tprint_indent(depth);\n\t\t} else {\n\t\t\tprintf(\": \");\n\t\t}\n\t\tprintf(\"%.*s\", (int) width, line);\n\t\tline = line_end + 1;\n\t}\n\n\tfree(lines);\n}\n\nstatic void print_ascii(const u8 * buf, size_t buflen)\n{\n\tfor (; 0 < buflen; buflen--, buf++) {\n\t\tif (isprint(*buf))\n\t\t\tprintf(\"%c\", *buf);\n\t\telse\n\t\t\tputchar('.');\n\t}\n}\n\nstatic void sc_asn1_print_octet_string(const u8 * buf, size_t buflen, size_t depth)\n{\n\tprint_hex(buf, buflen, depth);\n}\n\nstatic void sc_asn1_print_utf8string(const u8 * buf, size_t buflen)\n{\n\t/* FIXME UTF-8 is not ASCII */\n\tprint_ascii(buf, buflen);\n}\n\nstatic void sc_asn1_print_integer(const u8 * buf, size_t buflen)\n{\n\tsize_t a = 0;\n\n\tif (buflen > sizeof(a)) {\n\t\tprintf(\"0x%s\", sc_dump_hex(buf, buflen));\n\t} else {\n\t\tsize_t i;\n\t\tfor (i = 0; i < buflen; i++) {\n\t\t\ta <<= 8;\n\t\t\ta |= buf[i];\n\t\t}\n\t\tprintf(\"%\"SC_FORMAT_LEN_SIZE_T\"u\", a);\n\t}\n}\n\nstatic void sc_asn1_print_boolean(const u8 * buf, size_t buflen)\n{\n\tif (!buflen)\n\t\treturn;\n\n\tif (buf[0])\n\t\tprintf(\"true\");\n\telse\n\t\tprintf(\"false\");\n}\n\nstatic void sc_asn1_print_bit_string(const u8 * buf, size_t buflen, size_t depth)\n{\n#ifndef _WIN32\n\tlong long a = 0;\n#else\n\t__int64 a = 0;\n#endif\n\tint r, i;\n\n\tif (buflen > sizeof(a) + 1) {\n\t\tprint_hex(buf, buflen, depth);\n\t} else {\n\t\tr = sc_asn1_decode_bit_string(buf, buflen, &a, sizeof(a));\n\t\tif (r < 0) {\n\t\t\tprintf(\"decode error\");\n\t\t\treturn;\n\t\t}\n\t\tfor (i = r - 1; i >= 0; i--) {\n\t\t\tprintf(\"%c\", ((a >> i) & 1) ? '1' : '0');\n\t\t}\n\t}\n}\n\n#ifdef ENABLE_OPENSSL\n#include <openssl/objects.h>\n\nstatic void openssl_print_object_sn(const char *s)\n{\n\tASN1_OBJECT *obj = OBJ_txt2obj(s, 0);\n\tif (obj) {\n\t\tint nid = OBJ_obj2nid(obj);\n\t\tif (nid != NID_undef) {\n\t\t\tprintf(\", %s\", OBJ_nid2sn(nid));\n\t\t}\n\t\tASN1_OBJECT_free(obj);\n\t}\n}\n#else\nstatic void openssl_print_object_sn(const char *s)\n{\n}\n#endif\n\nstatic void sc_asn1_print_object_id(const u8 * buf, size_t buflen)\n{\n\tstruct sc_object_id oid;\n\tconst char *sbuf;\n\n\tif (sc_asn1_decode_object_id(buf, buflen, &oid)) {\n\t\tprintf(\"decode error\");\n\t\treturn;\n\t}\n\n\tsbuf = sc_dump_oid(&oid);\n\tprintf(\" %s\", sbuf);\n\topenssl_print_object_sn(sbuf);\n}\n\nstatic void sc_asn1_print_utctime(const u8 * buf, size_t buflen)\n{\n\tif (buflen < 8) {\n\t\tprintf(\"Error in decoding.\\n\");\n\t\treturn;\n\t}\n\n\tprint_ascii(buf, 2);\t\t/* YY */\n\tputchar('-');\n\tprint_ascii(buf+2, 2);\t\t/* MM */\n\tputchar('-');\n\tprint_ascii(buf+4, 2);\t\t/* DD */\n\tputchar(' ');\n\tprint_ascii(buf+6, 2);\t\t/* hh */\n\tbuf += 8;\n\tbuflen -= 8;\n\tif (buflen >= 2 && isdigit(buf[0]) && isdigit(buf[1])) {\n\t\tputchar(':');\n\t\tprint_ascii(buf, 2);\t/* mm */\n\t\tbuf += 2;\n\t\tbuflen -= 2;\n\t}\n\tif (buflen >= 2 && isdigit(buf[0]) && isdigit(buf[1])) {\n\t\tputchar(':');\n\t\tprint_ascii(buf, 2);\t/* ss */\n\t\tbuf += 2;\n\t\tbuflen -= 2;\n\t}\n\tif (buflen >= 4 && '.' == buf[0]) {\n\t\tprint_ascii(buf, 4);\t/* fff */\n\t\tbuf += 4;\n\t\tbuflen -= 4;\n\t}\n\n\tif (buflen >= 1 && 'Z' == buf[0]) {\n\t\tprintf(\" UTC\");\n\t} else if (buflen >= 5 && ('-' == buf[0] || '+' == buf[0])) {\n\t\tputchar(' ');\n\t\tprint_ascii(buf, 3);\t/* +/-hh */\n\t\tputchar(':');\n\t\tprint_ascii(buf+3, 2);\t/* mm */\n\t}\n}\n\nstatic void sc_asn1_print_generalizedtime(const u8 * buf, size_t buflen)\n{\n\tif (buflen < 8) {\n\t\tprintf(\"Error in decoding.\\n\");\n\t\treturn;\n\t}\n\n\tprint_ascii(buf, 2);\n\tsc_asn1_print_utctime(buf + 2, buflen - 2);\n}\n\nstatic void print_tags_recursive(const u8 * buf0, const u8 * buf,\n\t\t\t\t size_t buflen, size_t depth)\n{\n\tint r;\n\tsize_t i;\n\tsize_t bytesleft = buflen;\n\tconst char *classes[4] = {\n\t\t\"Universal\",\n\t\t\"Application\",\n\t\t\"Context\",\n\t\t\"Private\"\n\t};\n\tconst u8 *p = buf;\n\n\twhile (bytesleft >= 2) {\n\t\tunsigned int cla = 0, tag = 0, hlen;\n\t\tconst u8 *tagp = p;\n\t\tsize_t len;\n\n\t\tr = sc_asn1_read_tag(&tagp, bytesleft, &cla, &tag, &len);\n\t\tif (r != SC_SUCCESS || tagp == NULL) {\n\t\t\tprintf(\"Error in decoding.\\n\");\n\t\t\treturn;\n\t\t}\n\t\thlen = tagp - p;\n\t\tif (cla == 0 && tag == 0) {\n\t\t\tprintf(\"Zero tag, finishing\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tprint_indent(depth);\n\t\t/* let i be the length of the tag in bytes */\n\t\tfor (i = 1; i < sizeof tag - 1; i++) {\n\t\t\tif (!(tag >> 8*i))\n\t\t\t\tbreak;\n\t\t}\n\t\tprintf(\"%02X\", cla<<(i-1)*8 | tag);\n\n\t\tif ((cla & SC_ASN1_TAG_CLASS) == SC_ASN1_TAG_UNIVERSAL) {\n\t\t\tprintf(\" %s\", tag2str(tag));\n\t\t} else {\n\t\t\tprintf(\" %s %-2u\",\n\t\t\t\t\tclasses[cla >> 6],\n\t\t\t\t\ti == 1 ? tag & SC_ASN1_TAG_PRIMITIVE : tag & (((unsigned int) ~0) >> (i-1)*8));\n\t\t}\n\t\tif (!((cla & SC_ASN1_TAG_CLASS) == SC_ASN1_TAG_UNIVERSAL\n\t\t\t\t\t&& tag == SC_ASN1_TAG_NULL && len == 0)) {\n\t\t\tprintf(\" (%\"SC_FORMAT_LEN_SIZE_T\"u byte%s)\",\n\t\t\t\t\tlen,\n\t\t\t\t\tlen != 1 ? \"s\" : \"\");\n\t\t}\n\n\t\tif (len + hlen > bytesleft) {\n\t\t\tprintf(\" Illegal length!\\n\");\n\t\t\treturn;\n\t\t}\n\t\tp += hlen + len;\n\t\tbytesleft -= hlen + len;\n\n\t\tif (cla & SC_ASN1_TAG_CONSTRUCTED) {\n\t\t\tputchar('\\n');\n\t\t\tprint_tags_recursive(buf0, tagp, len, depth + 2*i + 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (tag) {\n\t\t\tcase SC_ASN1_TAG_BIT_STRING:\n\t\t\t\tprintf(\": \");\n\t\t\t\tsc_asn1_print_bit_string(tagp, len, depth + 2*i + 1);\n\t\t\t\tbreak;\n\t\t\tcase SC_ASN1_TAG_OCTET_STRING:\n\t\t\t\tsc_asn1_print_octet_string(tagp, len, depth + 2*i + 1);\n\t\t\t\tbreak;\n\t\t\tcase SC_ASN1_TAG_OBJECT:\n\t\t\t\tprintf(\": \");\n\t\t\t\tsc_asn1_print_object_id(tagp, len);\n\t\t\t\tbreak;\n\t\t\tcase SC_ASN1_TAG_INTEGER:\n\t\t\tcase SC_ASN1_TAG_ENUMERATED:\n\t\t\t\tprintf(\": \");\n\t\t\t\tsc_asn1_print_integer(tagp, len);\n\t\t\t\tbreak;\n\t\t\tcase SC_ASN1_TAG_IA5STRING:\n\t\t\tcase SC_ASN1_TAG_PRINTABLESTRING:\n\t\t\tcase SC_ASN1_TAG_T61STRING:\n\t\t\tcase SC_ASN1_TAG_UTF8STRING:\n\t\t\t\tprintf(\": \");\n\t\t\t\tsc_asn1_print_utf8string(tagp, len);\n\t\t\t\tbreak;\n\t\t\tcase SC_ASN1_TAG_BOOLEAN:\n\t\t\t\tprintf(\": \");\n\t\t\t\tsc_asn1_print_boolean(tagp, len);\n\t\t\t\tbreak;\n\t\t\tcase SC_ASN1_GENERALIZEDTIME:\n\t\t\t\tprintf(\": \");\n\t\t\t\tsc_asn1_print_generalizedtime(tagp, len);\n\t\t\t\tbreak;\n\t\t\tcase SC_ASN1_UTCTIME:\n\t\t\t\tprintf(\": \");\n\t\t\t\tsc_asn1_print_utctime(tagp, len);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif ((cla & SC_ASN1_TAG_CLASS) == SC_ASN1_TAG_APPLICATION) {\n\t\t\tprint_hex(tagp, len, depth + 2*i + 1);\n\t\t}\n\n\t\tif ((cla & SC_ASN1_TAG_CLASS) == SC_ASN1_TAG_CONTEXT) {\n\t\t\tprint_hex(tagp, len, depth + 2*i + 1);\n\t\t}\n\n\t\tputchar('\\n');\n\t}\n}\n\nvoid sc_asn1_print_tags(const u8 * buf, size_t buflen)\n{\n\tprint_tags_recursive(buf, buf, buflen, 0);\n}\n\nconst u8 *sc_asn1_find_tag(sc_context_t *ctx, const u8 * buf,\n\tsize_t buflen, unsigned int tag_in, size_t *taglen_in)\n{\n\tsize_t left = buflen, taglen;\n\tconst u8 *p = buf;\n\n\t*taglen_in = 0;\n\twhile (left >= 2) {\n\t\tunsigned int cla = 0, tag, mask = 0xff00;\n\n\t\tbuf = p;\n\t\t/* read a tag */\n\t\tif (sc_asn1_read_tag(&p, left, &cla, &tag, &taglen) != SC_SUCCESS\n\t\t\t\t|| p == NULL)\n\t\t\treturn NULL;\n\n\t\tleft -= (p - buf);\n\t\t/* we need to shift the class byte to the leftmost\n\t\t * byte of the tag */\n\t\twhile ((tag & mask) != 0) {\n\t\t\tcla  <<= 8;\n\t\t\tmask <<= 8;\n\t\t}\n\t\t/* compare the read tag with the given tag */\n\t\tif ((tag | cla) == tag_in) {\n\t\t\t/* we have a match => return length and value part */\n\t\t\tif (taglen > left)\n\t\t\t\treturn NULL;\n\t\t\t*taglen_in = taglen;\n\t\t\treturn p;\n\t\t}\n\t\t/* otherwise continue reading tags */\n\t\tleft -= taglen;\n\t\tp += taglen;\n\t}\n\treturn NULL;\n}\n\nconst u8 *sc_asn1_skip_tag(sc_context_t *ctx, const u8 ** buf, size_t *buflen,\n\t\t\t   unsigned int tag_in, size_t *taglen_out)\n{\n\tconst u8 *p = *buf;\n\tsize_t len = *buflen, taglen;\n\tunsigned int cla = 0, tag;\n\n\tif (sc_asn1_read_tag((const u8 **) &p, len, &cla, &tag, &taglen) != SC_SUCCESS\n\t\t\t|| p == NULL)\n\t\treturn NULL;\n\tswitch (cla & 0xC0) {\n\tcase SC_ASN1_TAG_UNIVERSAL:\n\t\tif ((tag_in & SC_ASN1_CLASS_MASK) != SC_ASN1_UNI)\n\t\t\treturn NULL;\n\t\tbreak;\n\tcase SC_ASN1_TAG_APPLICATION:\n\t\tif ((tag_in & SC_ASN1_CLASS_MASK) != SC_ASN1_APP)\n\t\t\treturn NULL;\n\t\tbreak;\n\tcase SC_ASN1_TAG_CONTEXT:\n\t\tif ((tag_in & SC_ASN1_CLASS_MASK) != SC_ASN1_CTX)\n\t\t\treturn NULL;\n\t\tbreak;\n\tcase SC_ASN1_TAG_PRIVATE:\n\t\tif ((tag_in & SC_ASN1_CLASS_MASK) != SC_ASN1_PRV)\n\t\t\treturn NULL;\n\t\tbreak;\n\t}\n\tif (cla & SC_ASN1_TAG_CONSTRUCTED) {\n\t\tif ((tag_in & SC_ASN1_CONS) == 0)\n\t\t\treturn NULL;\n\t} else\n\t\tif (tag_in & SC_ASN1_CONS)\n\t\t\treturn NULL;\n\tif ((tag_in & SC_ASN1_TAG_MASK) != tag)\n\t\treturn NULL;\n\tlen -= (p - *buf);\t/* header size */\n\tif (taglen > len) {\n\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1,\n\t\t\t \"too long ASN.1 object (size %\"SC_FORMAT_LEN_SIZE_T\"u while only %\"SC_FORMAT_LEN_SIZE_T\"u available)\\n\",\n\t\t\t taglen, len);\n\t\treturn NULL;\n\t}\n\t*buflen -= (p - *buf) + taglen;\n\t*buf = p + taglen;\t/* point to next tag */\n\t*taglen_out = taglen;\n\treturn p;\n}\n\nconst u8 *sc_asn1_verify_tag(sc_context_t *ctx, const u8 * buf, size_t buflen,\n\t\t\t     unsigned int tag_in, size_t *taglen_out)\n{\n\treturn sc_asn1_skip_tag(ctx, &buf, &buflen, tag_in, taglen_out);\n}\n\nstatic int decode_bit_string(const u8 * inbuf, size_t inlen, void *outbuf,\n\t\t\t     size_t outlen, int invert)\n{\n\tconst u8 *in = inbuf;\n\tu8 *out = (u8 *) outbuf;\n\tint i, count = 0;\n\tint zero_bits;\n\tsize_t octets_left;\n\n\tif (outlen < octets_left)\n\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\tif (inlen < 1)\n\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\n\tzero_bits = *in & 0x07;\n\toctets_left = inlen - 1;\n\tin++;\n\tmemset(outbuf, 0, outlen);\n\n\twhile (octets_left) {\n\t\t/* 1st octet of input:  ABCDEFGH, where A is the MSB */\n\t\t/* 1st octet of output: HGFEDCBA, where A is the LSB */\n\t\t/* first bit in bit string is the LSB in first resulting octet */\n\t\tint bits_to_go;\n\n\t\t*out = 0;\n\t\tif (octets_left == 1)\n\t\t\tbits_to_go = 8 - zero_bits;\n\t\telse\n\t\t\tbits_to_go = 8;\n\t\tif (invert)\n\t\t\tfor (i = 0; i < bits_to_go; i++) {\n\t\t\t\t*out |= ((*in >> (7 - i)) & 1) << i;\n\t\t\t}\n\t\telse {\n\t\t\t*out = *in;\n\t\t}\n\t\tout++;\n\t\tin++;\n\t\toctets_left--;\n\t\tcount++;\n\t}\n\treturn (count * 8) - zero_bits;\n}\n\nint sc_asn1_decode_bit_string(const u8 * inbuf, size_t inlen,\n\t\t\t      void *outbuf, size_t outlen)\n{\n\treturn decode_bit_string(inbuf, inlen, outbuf, outlen, 1);\n}\n\nint sc_asn1_decode_bit_string_ni(const u8 * inbuf, size_t inlen,\n\t\t\t\t void *outbuf, size_t outlen)\n{\n\treturn decode_bit_string(inbuf, inlen, outbuf, outlen, 0);\n}\n\nstatic int encode_bit_string(const u8 * inbuf, size_t bits_left, u8 **outbuf,\n\t\t\t     size_t *outlen, int invert)\n{\n\tconst u8 *in = inbuf;\n\tu8 *out;\n\tsize_t bytes;\n\tint skipped = 0;\n\n\tbytes = (bits_left + 7)/8 + 1;\n\t*outbuf = out = malloc(bytes);\n\tif (out == NULL)\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t*outlen = bytes;\n\tout += 1;\n\twhile (bits_left) {\n\t\tint i, bits_to_go = 8;\n\n\t\t*out = 0;\n\t\tif (bits_left < 8) {\n\t\t\tbits_to_go = bits_left;\n\t\t\tskipped = 8 - bits_left;\n\t\t}\n\t\tif (invert) {\n\t\t\tfor (i = 0; i < bits_to_go; i++)\n\t\t\t\t*out |= ((*in >> i) & 1) << (7 - i);\n\t\t} else {\n\t\t\t*out = *in;\n\t\t\tif (bits_left < 8)\n\t\t\t\treturn SC_ERROR_NOT_SUPPORTED; /* FIXME */\n\t\t}\n\t\tbits_left -= bits_to_go;\n\t\tout++, in++;\n\t}\n\tout = *outbuf;\n\tout[0] = skipped;\n\treturn 0;\n}\n\n/*\n * Bitfields are just bit strings, stored in an unsigned int\n * (taking endianness into account)\n */\nstatic int decode_bit_field(const u8 * inbuf, size_t inlen, void *outbuf, size_t outlen)\n{\n\tu8\t\tdata[sizeof(unsigned int)];\n\tunsigned int\tfield = 0;\n\tint\t\ti, n;\n\n\tif (outlen != sizeof(data))\n\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\n\tn = decode_bit_string(inbuf, inlen, data, sizeof(data), 1);\n\tif (n < 0)\n\t\treturn n;\n\n\tfor (i = 0; i < n; i += 8) {\n\t\tfield |= (data[i/8] << i);\n\t}\n\tmemcpy(outbuf, &field, outlen);\n\treturn 0;\n}\n\nstatic int encode_bit_field(const u8 *inbuf, size_t inlen,\n\t\t\t    u8 **outbuf, size_t *outlen)\n{\n\tu8\t\tdata[sizeof(unsigned int)];\n\tunsigned int\tfield = 0;\n\tsize_t\t\ti, bits;\n\n\tif (inlen != sizeof(data))\n\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\n\t/* count the bits */\n\tmemcpy(&field, inbuf, inlen);\n\tfor (bits = 0; field; bits++)\n\t\tfield >>= 1;\n\n\tmemcpy(&field, inbuf, inlen);\n\tfor (i = 0; i < bits; i += 8)\n\t\tdata[i/8] = field >> i;\n\n\treturn encode_bit_string(data, bits, outbuf, outlen, 1);\n}\n\nint sc_asn1_decode_integer(const u8 * inbuf, size_t inlen, int *out)\n{\n\tint    a = 0;\n\tsize_t i;\n\n\tif (inlen > sizeof(int) || inlen == 0)\n\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\tif (inbuf[0] & 0x80)\n\t\ta = -1;\n\tfor (i = 0; i < inlen; i++) {\n\t\ta <<= 8;\n\t\ta |= *inbuf++;\n\t}\n\t*out = a;\n\treturn 0;\n}\n\nstatic int asn1_encode_integer(int in, u8 ** obj, size_t * objsize)\n{\n\tint i = sizeof(in) * 8, skip_zero, skip_sign;\n\tu8 *p, b;\n\n\tif (in < 0)\n\t{\n\t\tskip_sign = 1;\n\t\tskip_zero= 0;\n\t}\n\telse\n\t{\n\t\tskip_sign = 0;\n\t\tskip_zero= 1;\n\t}\n\t*obj = p = malloc(sizeof(in)+1);\n\tif (*obj == NULL)\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\tdo {\n\t\ti -= 8;\n\t\tb = in >> i;\n\t\tif (skip_sign)\n\t\t{\n\t\t\tif (b != 0xff)\n\t\t\t\tskip_sign = 0;\n\t\t\tif (b & 0x80)\n\t\t\t{\n\t\t\t\t*p = b;\n\t\t\t\tif (0xff == b)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tp++;\n\t\t\t\tskip_sign = 0;\n\t\t\t}\n\t\t}\n\t\tif (b == 0 && skip_zero)\n\t\t\tcontinue;\n\t\tif (skip_zero) {\n\t\t\tskip_zero = 0;\n\t\t\t/* prepend 0x00 if MSb is 1 and integer positive */\n\t\t\tif ((b & 0x80) != 0 && in > 0)\n\t\t\t\t*p++ = 0;\n\t\t}\n\t\t*p++ = b;\n\t} while (i > 0);\n\tif (skip_sign)\n\t\tp++;\n\t*objsize = p - *obj;\n\tif (*objsize == 0) {\n\t\t*objsize = 1;\n\t\t(*obj)[0] = 0;\n\t}\n\treturn 0;\n}\n\nint\nsc_asn1_decode_object_id(const u8 *inbuf, size_t inlen, struct sc_object_id *id)\n{\n\tint a;\n\tconst u8 *p = inbuf;\n\tint *octet;\n\n\tif (inlen == 0 || inbuf == NULL || id == NULL)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tsc_init_oid(id);\n\toctet = id->value;\n\n\ta = *p;\n\t*octet++ = a / 40;\n\t*octet++ = a % 40;\n\tinlen--;\n\n\twhile (inlen) {\n\t\tp++;\n\t\ta = *p & 0x7F;\n\t\tinlen--;\n\t\twhile (inlen && *p & 0x80) {\n\t\t\tp++;\n\t\t\ta <<= 7;\n\t\t\ta |= *p & 0x7F;\n\t\t\tinlen--;\n\t\t}\n\t\t*octet++ = a;\n\t\tif (octet - id->value >= SC_MAX_OBJECT_ID_OCTETS)   {\n\t\t\tsc_init_oid(id);\n\t\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\t\t}\n\t};\n\n\treturn 0;\n}\n\nint\nsc_asn1_encode_object_id(u8 **buf, size_t *buflen, const struct sc_object_id *id)\n{\n\tu8 temp[SC_MAX_OBJECT_ID_OCTETS*5], *p = temp;\n\tint\ti;\n\n\tif (!buflen || !id)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\t/* an OID must have at least two components */\n\tif (id->value[0] == -1 || id->value[1] == -1)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tfor (i = 0; i < SC_MAX_OBJECT_ID_OCTETS; i++) {\n\t\tunsigned int k, shift;\n\n\t\tif (id->value[i] == -1)\n\t\t\tbreak;\n\n\t\tk = id->value[i];\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tif (k > 2)\n\t\t\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t\t\t*p = k * 40;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (k > 39)\n\t\t\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t\t\t*p++ += k;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tshift = 28;\n\t\t\twhile (shift && (k >> shift) == 0)\n\t\t\t\tshift -= 7;\n\t\t\twhile (shift) {\n\t\t\t\t*p++ = 0x80 | ((k >> shift) & 0x7f);\n\t\t\t\tshift -= 7;\n\t\t\t}\n\t\t\t*p++ = k & 0x7F;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t*buflen = p - temp;\n\n\tif (buf)   {\n\t\t*buf = malloc(*buflen);\n\t\tif (!*buf)\n\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\tmemcpy(*buf, temp, *buflen);\n\t}\n\treturn 0;\n}\n\nstatic int sc_asn1_decode_utf8string(const u8 *inbuf, size_t inlen,\n\t\t\t      u8 *out, size_t *outlen)\n{\n\tif (inlen+1 > *outlen)\n\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\t*outlen = inlen+1;\n\tmemcpy(out, inbuf, inlen);\n\tout[inlen] = 0;\n\treturn 0;\n}\n\nint sc_asn1_put_tag(unsigned int tag, const u8 * data, size_t datalen, u8 * out, size_t outlen, u8 **ptr)\n{\n\tsize_t c = 0;\n\tsize_t tag_len;\n\tsize_t ii;\n\tu8 *p = out;\n\tu8 tag_char[4] = {0, 0, 0, 0};\n\n\t/* Check tag */\n\tif (tag == 0 || tag > 0xFFFFFFFF) {\n\t\t/* A tag of 0x00 is not valid and at most 4-byte tag names are supported. */\n\t\treturn SC_ERROR_INVALID_DATA;\n\t}\n\tfor (tag_len = 0; tag; tag >>= 8) {\n\t\t/* Note: tag char will be reversed order. */\n\t\ttag_char[tag_len++] = tag & 0xFF;\n\t}\n\n\tif (tag_len > 1)   {\n\t\tif ((tag_char[tag_len - 1] & SC_ASN1_TAG_PRIMITIVE) != SC_ASN1_TAG_ESCAPE_MARKER) {\n\t\t\t/* First byte is not escape marker. */\n\t\t\treturn SC_ERROR_INVALID_DATA;\n\t\t}\n\t\tfor (ii = 1; ii < tag_len - 1; ii++) {\n\t\t\tif ((tag_char[ii] & 0x80) != 0x80) {\n\t\t\t\t/* MS bit is not 'one'. */\n\t\t\t\treturn SC_ERROR_INVALID_DATA;\n\t\t\t}\n\t\t}\n\t\tif ((tag_char[0] & 0x80) != 0x00) {\n\t\t\t/* MS bit of the last byte is not 'zero'. */\n\t\t\treturn SC_ERROR_INVALID_DATA;\n\t\t}\n\t}\n\n\t/* Calculate the number of additional bytes necessary to encode the length. */\n\t/* c+1 is the size of the length field. */\n\tif (datalen > 127) {\n\t\tc = 1;\n\t\twhile (datalen >> (c << 3))\n\t\t\tc++;\n\t}\n\tif (outlen == 0 || out == NULL) {\n\t\t/* Caller only asks for the length that would be written. */\n\t\treturn tag_len + (c+1) + datalen;\n\t}\n\t/* We will write the tag, so check the length. */\n\tif (outlen < tag_len + (c+1) + datalen)\n\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\tfor (ii=0;ii<tag_len;ii++)\n\t\t*p++ = tag_char[tag_len - ii - 1];\n\n\tif (c > 0) {\n\t\t*p++ = 0x80 | c;\n\t\twhile (c--)\n\t\t\t*p++ = (datalen >> (c << 3)) & 0xFF;\n\t}\n\telse {\n\t\t*p++ = datalen & 0x7F;\n\t}\n\tif(data && datalen > 0) {\n\t\tmemcpy(p, data, datalen);\n\t\tp += datalen;\n\t}\n\tif (ptr != NULL)\n\t\t*ptr = p;\n\treturn 0;\n}\n\nint sc_asn1_write_element(sc_context_t *ctx, unsigned int tag,\n\tconst u8 * data, size_t datalen, u8 ** out, size_t * outlen)\n{\n\treturn asn1_write_element(ctx, tag, data, datalen, out, outlen);\n}\n\nstatic int asn1_write_element(sc_context_t *ctx, unsigned int tag,\n\tconst u8 * data, size_t datalen, u8 ** out, size_t * outlen)\n{\n\tunsigned char t;\n\tunsigned char *buf, *p;\n\tint c = 0;\n\tunsigned short_tag;\n\tunsigned char tag_char[3] = {0, 0, 0};\n\tsize_t tag_len, ii;\n\n\tshort_tag = tag & SC_ASN1_TAG_MASK;\n\tfor (tag_len = 0; short_tag >> (8 * tag_len); tag_len++)\n\t\ttag_char[tag_len] = (short_tag >> (8 * tag_len)) & 0xFF;\n\tif (!tag_len)\n\t\ttag_len = 1;\n\n\tif (tag_len > 1)   {\n\t\tif ((tag_char[tag_len - 1] & SC_ASN1_TAG_PRIMITIVE) != SC_ASN1_TAG_ESCAPE_MARKER)\n\t\t\tSC_TEST_RET(ctx, SC_LOG_DEBUG_ASN1, SC_ERROR_INVALID_DATA, \"First byte of the long tag is not 'escape marker'\");\n\n\t\tfor (ii = 1; ii < tag_len - 1; ii++)\n\t\t\tif (!(tag_char[ii] & 0x80))\n\t\t\t\tSC_TEST_RET(ctx, SC_LOG_DEBUG_ASN1, SC_ERROR_INVALID_DATA, \"MS bit expected to be 'one'\");\n\n\t\tif (tag_char[0] & 0x80)\n\t\t\tSC_TEST_RET(ctx, SC_LOG_DEBUG_ASN1, SC_ERROR_INVALID_DATA, \"MS bit of the last byte expected to be 'zero'\");\n\t}\n\n\tt = tag_char[tag_len - 1] & 0x1F;\n\n\tswitch (tag & SC_ASN1_CLASS_MASK) {\n\tcase SC_ASN1_UNI:\n\t\tbreak;\n\tcase SC_ASN1_APP:\n\t\tt |= SC_ASN1_TAG_APPLICATION;\n\t\tbreak;\n\tcase SC_ASN1_CTX:\n\t\tt |= SC_ASN1_TAG_CONTEXT;\n\t\tbreak;\n\tcase SC_ASN1_PRV:\n\t\tt |= SC_ASN1_TAG_PRIVATE;\n\t\tbreak;\n\t}\n\tif (tag & SC_ASN1_CONS)\n\t\tt |= SC_ASN1_TAG_CONSTRUCTED;\n\tif (datalen > 127) {\n\t\tc = 1;\n\t\twhile (datalen >> (c << 3))\n\t\t\tc++;\n\t}\n\n\t*outlen = tag_len + 1 + c + datalen;\n\tbuf = malloc(*outlen);\n\tif (buf == NULL)\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_ASN1, SC_ERROR_OUT_OF_MEMORY);\n\n\t*out = p = buf;\n\t*p++ = t;\n\tfor (ii=1;ii<tag_len;ii++)\n\t\t*p++ = tag_char[tag_len - ii - 1];\n\n\tif (c) {\n\t\t*p++ = 0x80 | c;\n\t\twhile (c--)\n\t\t\t*p++ = (datalen >> (c << 3)) & 0xFF;\n\t}\n\telse   {\n\t\t*p++ = datalen & 0x7F;\n\t}\n\tmemcpy(p, data, datalen);\n\n\treturn SC_SUCCESS;\n}\n\nstatic const struct sc_asn1_entry c_asn1_path_ext[3] = {\n\t{ \"aid\",  SC_ASN1_OCTET_STRING, SC_ASN1_APP | 0x0F, 0, NULL, NULL },\n\t{ \"path\", SC_ASN1_OCTET_STRING, SC_ASN1_TAG_OCTET_STRING, 0, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\nstatic const struct sc_asn1_entry c_asn1_path[5] = {\n\t{ \"path\",   SC_ASN1_OCTET_STRING, SC_ASN1_TAG_OCTET_STRING, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"index\",  SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"length\", SC_ASN1_INTEGER, SC_ASN1_CTX | 0, SC_ASN1_OPTIONAL, NULL, NULL },\n/* For some multi-applications PKCS#15 card the ODF records can hold the references to\n * the xDF files and objects placed elsewhere then under the application DF of the ODF itself.\n * In such a case the 'path' ASN1 data includes also the ID of the target application (AID).\n * This path extension do not make a part of PKCS#15 standard.\n */\n\t{ \"pathExtended\", SC_ASN1_STRUCT, SC_ASN1_CTX | 1 | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\nstatic int asn1_decode_path(sc_context_t *ctx, const u8 *in, size_t len,\n\t\t\t    sc_path_t *path, int depth)\n{\n\tint idx, count, r;\n\tstruct sc_asn1_entry asn1_path_ext[3], asn1_path[5];\n\tunsigned char path_value[SC_MAX_PATH_SIZE], aid_value[SC_MAX_AID_SIZE];\n\tsize_t path_len = sizeof(path_value), aid_len = sizeof(aid_value);\n\n\tmemset(path, 0, sizeof(struct sc_path));\n\n\tsc_copy_asn1_entry(c_asn1_path_ext, asn1_path_ext);\n\tsc_copy_asn1_entry(c_asn1_path, asn1_path);\n\n\tsc_format_asn1_entry(asn1_path_ext + 0, aid_value, &aid_len, 0);\n\tsc_format_asn1_entry(asn1_path_ext + 1, path_value, &path_len, 0);\n\n\tsc_format_asn1_entry(asn1_path + 0, path_value, &path_len, 0);\n\tsc_format_asn1_entry(asn1_path + 1, &idx, NULL, 0);\n\tsc_format_asn1_entry(asn1_path + 2, &count, NULL, 0);\n\tsc_format_asn1_entry(asn1_path + 3, asn1_path_ext, NULL, 0);\n\n\tr = asn1_decode(ctx, asn1_path, in, len, NULL, NULL, 0, depth + 1);\n\tif (r)\n\t\treturn r;\n\n\tif (asn1_path[3].flags & SC_ASN1_PRESENT)   {\n\t\t/* extended path present: set 'path' and 'aid' */\n\t\tmemcpy(path->aid.value, aid_value, aid_len);\n\t\tpath->aid.len = aid_len;\n\n\t\tmemcpy(path->value, path_value, path_len);\n\t\tpath->len = path_len;\n\t}\n\telse if (asn1_path[0].flags & SC_ASN1_PRESENT)   {\n\t\t/* path present: set 'path' */\n\t\tmemcpy(path->value, path_value, path_len);\n\t\tpath->len = path_len;\n\t}\n\telse   {\n\t\t/* failed if both 'path' and 'pathExtended' are absent */\n\t\treturn SC_ERROR_ASN1_OBJECT_NOT_FOUND;\n\t}\n\n\tif (path->len == 2)\n\t\tpath->type = SC_PATH_TYPE_FILE_ID;\n\telse   if (path->aid.len && path->len > 2)\n\t\tpath->type = SC_PATH_TYPE_FROM_CURRENT;\n\telse\n\t\tpath->type = SC_PATH_TYPE_PATH;\n\n\tif ((asn1_path[1].flags & SC_ASN1_PRESENT) && (asn1_path[2].flags & SC_ASN1_PRESENT)) {\n\t\tpath->index = idx;\n\t\tpath->count = count;\n\t}\n\telse {\n\t\tpath->index = 0;\n\t\tpath->count = -1;\n\t}\n\n\treturn SC_SUCCESS;\n}\n\nstatic int asn1_encode_path(sc_context_t *ctx, const sc_path_t *path,\n\t\t\t    u8 **buf, size_t *bufsize, int depth, unsigned int parent_flags)\n{\n\tint r;\n \tstruct sc_asn1_entry asn1_path[5];\n\tsc_path_t tpath = *path;\n\n\tsc_copy_asn1_entry(c_asn1_path, asn1_path);\n\tsc_format_asn1_entry(asn1_path + 0, (void *) &tpath.value, (void *) &tpath.len, 1);\n\n\tasn1_path[0].flags |= parent_flags;\n\tif (path->count > 0) {\n\t\tsc_format_asn1_entry(asn1_path + 1, (void *) &tpath.index, NULL, 1);\n\t\tsc_format_asn1_entry(asn1_path + 2, (void *) &tpath.count, NULL, 1);\n\t}\n\tr = asn1_encode(ctx, asn1_path, buf, bufsize, depth + 1);\n\treturn r;\n}\n\n\nstatic const struct sc_asn1_entry c_asn1_se[2] = {\n\t{ \"seInfo\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, 0, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\nstatic const struct sc_asn1_entry c_asn1_se_info[4] = {\n\t{ \"se\",   SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, 0, NULL, NULL },\n\t{ \"owner\",SC_ASN1_OBJECT, SC_ASN1_TAG_OBJECT, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"aid\",  SC_ASN1_OCTET_STRING, SC_ASN1_TAG_OCTET_STRING, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\nstatic int asn1_decode_se_info(sc_context_t *ctx, const u8 *obj, size_t objlen,\n\t\t\t       sc_pkcs15_sec_env_info_t ***se, size_t *num, int depth)\n{\n\tstruct sc_pkcs15_sec_env_info **ses;\n\tconst unsigned char *ptr = obj;\n\tsize_t idx, ptrlen = objlen;\n\tint ret;\n\n\tses = calloc(SC_MAX_SE_NUM, sizeof(sc_pkcs15_sec_env_info_t *));\n\tif (ses == NULL)\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\n\tfor (idx=0; idx < SC_MAX_SE_NUM && ptrlen; )   {\n\t\tstruct sc_asn1_entry asn1_se[2];\n\t\tstruct sc_asn1_entry asn1_se_info[4];\n\t\tstruct sc_pkcs15_sec_env_info si;\n\n\t\tsc_copy_asn1_entry(c_asn1_se, asn1_se);\n\t\tsc_copy_asn1_entry(c_asn1_se_info, asn1_se_info);\n\n\t\tsi.aid.len = sizeof(si.aid.value);\n\t\tsc_format_asn1_entry(asn1_se_info + 0, &si.se, NULL, 0);\n\t\tsc_format_asn1_entry(asn1_se_info + 1, &si.owner, NULL, 0);\n\t\tsc_format_asn1_entry(asn1_se_info + 2, &si.aid.value, &si.aid.len, 0);\n\t\tsc_format_asn1_entry(asn1_se + 0, asn1_se_info, NULL, 0);\n\n\t\tret = asn1_decode(ctx, asn1_se, ptr, ptrlen, &ptr, &ptrlen, 0, depth+1);\n\t\tif (ret != SC_SUCCESS)\n\t\t\tgoto err;\n\t\tif (!(asn1_se_info[1].flags & SC_ASN1_PRESENT))\n\t\t\tsc_init_oid(&si.owner);\n\n\t\tses[idx] = calloc(1, sizeof(sc_pkcs15_sec_env_info_t));\n\t\tif (ses[idx] == NULL) {\n\t\t\tret = SC_ERROR_OUT_OF_MEMORY;\n\t\t\tgoto err;\n\t\t}\n\n\t\tmemcpy(ses[idx], &si, sizeof(struct sc_pkcs15_sec_env_info));\n\t\tidx++;\n\t}\n\n\t*se  = ses;\n\t*num = idx;\n\tret = SC_SUCCESS;\nerr:\n\tif (ret != SC_SUCCESS) {\n\t\tsize_t i;\n\t\tfor (i = 0; i < idx; i++)\n\t\t\tif (ses[i])\n\t\t\t\tfree(ses[i]);\n\t\tfree(ses);\n\t}\n\n\treturn ret;\n}\n\n\nstatic int asn1_encode_se_info(sc_context_t *ctx,\n\t\tstruct sc_pkcs15_sec_env_info **se, size_t se_num,\n\t\tunsigned char **buf, size_t *bufsize, int depth)\n{\n\tunsigned char *ptr = NULL, *out = NULL, *p;\n\tsize_t ptrlen = 0, outlen = 0, idx;\n\tint ret;\n\n\tfor (idx=0; idx < se_num; idx++)   {\n\t\tstruct sc_asn1_entry asn1_se[2];\n\t\tstruct sc_asn1_entry asn1_se_info[4];\n\n\t\tsc_copy_asn1_entry(c_asn1_se, asn1_se);\n\t\tsc_copy_asn1_entry(c_asn1_se_info, asn1_se_info);\n\n\t\tsc_format_asn1_entry(asn1_se_info + 0, &se[idx]->se, NULL, 1);\n\t\tif (sc_valid_oid(&se[idx]->owner))\n\t\t\tsc_format_asn1_entry(asn1_se_info + 1, &se[idx]->owner, NULL, 1);\n\t\tif (se[idx]->aid.len)\n\t\t\tsc_format_asn1_entry(asn1_se_info + 2, &se[idx]->aid.value, &se[idx]->aid.len, 1);\n\t\tsc_format_asn1_entry(asn1_se + 0, asn1_se_info, NULL, 1);\n\n\t\tret = sc_asn1_encode(ctx, asn1_se, &ptr, &ptrlen);\n\t\tif (ret != SC_SUCCESS)\n\t\t\tgoto err;\n\n\t\tif (!ptrlen)\n\t\t\tcontinue;\n\t\tp = (unsigned char *) realloc(out, outlen + ptrlen);\n\t\tif (!p)   {\n\t\t\tret = SC_ERROR_OUT_OF_MEMORY;\n\t\t\tgoto err;\n\t\t}\n\t\tout = p;\n\t\tmemcpy(out + outlen, ptr, ptrlen);\n\t\toutlen += ptrlen;\n\t\tfree(ptr);\n\t\tptr = NULL;\n\t\tptrlen = 0;\n\t}\n\n\t*buf = out;\n\t*bufsize = outlen;\n\tret = SC_SUCCESS;\nerr:\n\tif (ret != SC_SUCCESS && out != NULL)\n\t\tfree(out);\n\treturn ret;\n}\n\n/* TODO: According to specification type of 'SecurityCondition' is 'CHOICE'.\n *       Do it at least for SC_ASN1_PKCS15_ID(authId), SC_ASN1_STRUCT(authReference) and NULL(always). */\nstatic const struct sc_asn1_entry c_asn1_access_control_rule[3] = {\n\t{ \"accessMode\", SC_ASN1_BIT_FIELD, SC_ASN1_TAG_BIT_STRING, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"securityCondition\", SC_ASN1_PKCS15_ID, SC_ASN1_TAG_OCTET_STRING, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n/*\n * in src/libopensc/pkcs15.h SC_PKCS15_MAX_ACCESS_RULES  defined as 8\n */\nstatic const struct sc_asn1_entry c_asn1_access_control_rules[SC_PKCS15_MAX_ACCESS_RULES + 1] = {\n\t{ \"accessControlRule\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"accessControlRule\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"accessControlRule\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"accessControlRule\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"accessControlRule\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"accessControlRule\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"accessControlRule\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"accessControlRule\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\nstatic const struct sc_asn1_entry c_asn1_com_obj_attr[6] = {\n\t{ \"label\", SC_ASN1_UTF8STRING, SC_ASN1_TAG_UTF8STRING, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"flags\", SC_ASN1_BIT_FIELD, SC_ASN1_TAG_BIT_STRING, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"authId\", SC_ASN1_PKCS15_ID, SC_ASN1_TAG_OCTET_STRING, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"userConsent\", SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"accessControlRules\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\nstatic const struct sc_asn1_entry c_asn1_p15_obj[5] = {\n\t{ \"commonObjectAttributes\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, 0, NULL, NULL },\n\t{ \"classAttributes\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, 0, NULL, NULL },\n\t{ \"subClassAttributes\", SC_ASN1_STRUCT, SC_ASN1_CTX | 0 | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"typeAttributes\", SC_ASN1_STRUCT, SC_ASN1_CTX | 1 | SC_ASN1_CONS, 0, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\nstatic int asn1_decode_p15_object(sc_context_t *ctx, const u8 *in,\n\t\t\t\t  size_t len, struct sc_asn1_pkcs15_object *obj,\n\t\t\t\t  int depth)\n{\n\tstruct sc_pkcs15_object *p15_obj = obj->p15_obj;\n\tstruct sc_asn1_entry asn1_c_attr[6], asn1_p15_obj[5];\n\tstruct sc_asn1_entry asn1_ac_rules[SC_PKCS15_MAX_ACCESS_RULES + 1], asn1_ac_rule[SC_PKCS15_MAX_ACCESS_RULES][3];\n\tsize_t flags_len = sizeof(p15_obj->flags);\n\tsize_t label_len = sizeof(p15_obj->label);\n\tsize_t access_mode_len = sizeof(p15_obj->access_rules[0].access_mode);\n\tint r, ii;\n\n\tfor (ii=0; ii<SC_PKCS15_MAX_ACCESS_RULES; ii++)\n\t\tsc_copy_asn1_entry(c_asn1_access_control_rule, asn1_ac_rule[ii]);\n\tsc_copy_asn1_entry(c_asn1_access_control_rules, asn1_ac_rules);\n\n\n\tsc_copy_asn1_entry(c_asn1_com_obj_attr, asn1_c_attr);\n\tsc_copy_asn1_entry(c_asn1_p15_obj, asn1_p15_obj);\n\tsc_format_asn1_entry(asn1_c_attr + 0, p15_obj->label, &label_len, 0);\n\tsc_format_asn1_entry(asn1_c_attr + 1, &p15_obj->flags, &flags_len, 0);\n\tsc_format_asn1_entry(asn1_c_attr + 2, &p15_obj->auth_id, NULL, 0);\n\tsc_format_asn1_entry(asn1_c_attr + 3, &p15_obj->user_consent, NULL, 0);\n\n\tfor (ii=0; ii<SC_PKCS15_MAX_ACCESS_RULES; ii++)   {\n\t\tsc_format_asn1_entry(asn1_ac_rule[ii] + 0, &p15_obj->access_rules[ii].access_mode, &access_mode_len, 0);\n\t\tsc_format_asn1_entry(asn1_ac_rule[ii] + 1, &p15_obj->access_rules[ii].auth_id, NULL, 0);\n\t\tsc_format_asn1_entry(asn1_ac_rules + ii, asn1_ac_rule[ii], NULL, 0);\n\t}\n\tsc_format_asn1_entry(asn1_c_attr + 4, asn1_ac_rules, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_p15_obj + 0, asn1_c_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_p15_obj + 1, obj->asn1_class_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_p15_obj + 2, obj->asn1_subclass_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_p15_obj + 3, obj->asn1_type_attr, NULL, 0);\n\n\tr = asn1_decode(ctx, asn1_p15_obj, in, len, NULL, NULL, 0, depth + 1);\n\treturn r;\n}\n\nstatic int asn1_encode_p15_object(sc_context_t *ctx, const struct sc_asn1_pkcs15_object *obj,\n\t\t\t\t  u8 **buf, size_t *bufsize, int depth)\n{\n\tstruct sc_pkcs15_object p15_obj = *obj->p15_obj;\n\tstruct sc_asn1_entry    asn1_c_attr[6], asn1_p15_obj[5];\n\tstruct sc_asn1_entry asn1_ac_rules[SC_PKCS15_MAX_ACCESS_RULES + 1], asn1_ac_rule[SC_PKCS15_MAX_ACCESS_RULES][3];\n\tsize_t label_len = strlen(p15_obj.label);\n\tsize_t flags_len;\n\tsize_t access_mode_len;\n\tint r, ii;\n\n\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"encode p15 obj(type:0x%X,access_mode:0x%X)\", p15_obj.type, p15_obj.access_rules[0].access_mode);\n\tif (p15_obj.access_rules[0].access_mode)   {\n\t\tfor (ii=0; ii<SC_PKCS15_MAX_ACCESS_RULES; ii++)   {\n\t\t\tsc_copy_asn1_entry(c_asn1_access_control_rule, asn1_ac_rule[ii]);\n\t\t\tif (p15_obj.access_rules[ii].auth_id.len == 0)   {\n\t\t\t\tasn1_ac_rule[ii][1].type = SC_ASN1_NULL;\n\t\t\t\tasn1_ac_rule[ii][1].tag = SC_ASN1_TAG_NULL;\n\t\t\t}\n\t\t}\n\t\tsc_copy_asn1_entry(c_asn1_access_control_rules, asn1_ac_rules);\n\t}\n\n\tsc_copy_asn1_entry(c_asn1_com_obj_attr, asn1_c_attr);\n\tsc_copy_asn1_entry(c_asn1_p15_obj, asn1_p15_obj);\n\tif (label_len != 0)\n\t\tsc_format_asn1_entry(asn1_c_attr + 0, (void *) p15_obj.label, &label_len, 1);\n\tif (p15_obj.flags) {\n\t\tflags_len = sizeof(p15_obj.flags);\n\t\tsc_format_asn1_entry(asn1_c_attr + 1, (void *) &p15_obj.flags, &flags_len, 1);\n\t}\n\tif (p15_obj.auth_id.len)\n\t\tsc_format_asn1_entry(asn1_c_attr + 2, (void *) &p15_obj.auth_id, NULL, 1);\n\tif (p15_obj.user_consent)\n\t\tsc_format_asn1_entry(asn1_c_attr + 3, (void *) &p15_obj.user_consent, NULL, 1);\n\n\tif (p15_obj.access_rules[0].access_mode)   {\n\t\tfor (ii=0; p15_obj.access_rules[ii].access_mode; ii++)   {\n\t\t\taccess_mode_len = sizeof(p15_obj.access_rules[ii].access_mode);\n\t\t\tsc_format_asn1_entry(asn1_ac_rule[ii] + 0, (void *) &p15_obj.access_rules[ii].access_mode, &access_mode_len, 1);\n\t\t\tsc_format_asn1_entry(asn1_ac_rule[ii] + 1, (void *) &p15_obj.access_rules[ii].auth_id, NULL, 1);\n\t\t\tsc_format_asn1_entry(asn1_ac_rules + ii, asn1_ac_rule[ii], NULL, 1);\n\t\t}\n\t\tsc_format_asn1_entry(asn1_c_attr + 4, asn1_ac_rules, NULL, 1);\n\t}\n\n\tsc_format_asn1_entry(asn1_p15_obj + 0, asn1_c_attr, NULL, 1);\n\tsc_format_asn1_entry(asn1_p15_obj + 1, obj->asn1_class_attr, NULL, 1);\n\tif (obj->asn1_subclass_attr != NULL && obj->asn1_subclass_attr->name)\n\t\tsc_format_asn1_entry(asn1_p15_obj + 2, obj->asn1_subclass_attr, NULL, 1);\n\tsc_format_asn1_entry(asn1_p15_obj + 3, obj->asn1_type_attr, NULL, 1);\n\n\tr = asn1_encode(ctx, asn1_p15_obj, buf, bufsize, depth + 1);\n\treturn r;\n}\n\nstatic int asn1_decode_entry(sc_context_t *ctx,struct sc_asn1_entry *entry,\n\t\t\t     const u8 *obj, size_t objlen, int depth)\n{\n\tvoid *parm = entry->parm;\n\tint (*callback_func)(sc_context_t *nctx, void *arg, const u8 *nobj,\n\t\t\t     size_t nobjlen, int ndepth);\n\tsize_t *len = (size_t *) entry->arg;\n\tint r = 0;\n\n\tcallback_func = parm;\n\n\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"%*.*sdecoding '%s', raw data:%s%s\\n\",\n\t\tdepth, depth, \"\", entry->name,\n\t\tsc_dump_hex(obj, objlen > 16  ? 16 : objlen),\n\t\tobjlen > 16 ? \"...\" : \"\");\n\n\tswitch (entry->type) {\n\tcase SC_ASN1_STRUCT:\n\t\tif (parm != NULL)\n\t\t\tr = asn1_decode(ctx, (struct sc_asn1_entry *) parm, obj,\n\t\t\t\t       objlen, NULL, NULL, 0, depth + 1);\n\t\tbreak;\n\tcase SC_ASN1_NULL:\n\t\tbreak;\n\tcase SC_ASN1_BOOLEAN:\n\t\tif (parm != NULL) {\n\t\t\tif (objlen != 1) {\n\t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1,\n\t\t\t\t\t \"invalid ASN.1 object length: %\"SC_FORMAT_LEN_SIZE_T\"u\\n\",\n\t\t\t\t\t objlen);\n\t\t\t\tr = SC_ERROR_INVALID_ASN1_OBJECT;\n\t\t\t} else\n\t\t\t\t*((int *) parm) = obj[0] ? 1 : 0;\n\t\t}\n\t\tbreak;\n\tcase SC_ASN1_INTEGER:\n\tcase SC_ASN1_ENUMERATED:\n\t\tif (parm != NULL) {\n\t\t\tr = sc_asn1_decode_integer(obj, objlen, (int *) entry->parm);\n\t\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"%*.*sdecoding '%s' returned %d\\n\", depth, depth, \"\",\n\t\t\t\t\tentry->name, *((int *) entry->parm));\n\t\t}\n\t\tbreak;\n\tcase SC_ASN1_BIT_STRING_NI:\n\tcase SC_ASN1_BIT_STRING:\n\t\tif (parm != NULL) {\n\t\t\tint invert = entry->type == SC_ASN1_BIT_STRING ? 1 : 0;\n\t\t\tassert(len != NULL);\n\t\t\tif (objlen < 1) {\n\t\t\t\tr = SC_ERROR_INVALID_ASN1_OBJECT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (entry->flags & SC_ASN1_ALLOC) {\n\t\t\t\tu8 **buf = (u8 **) parm;\n\t\t\t\t*buf = malloc(objlen-1);\n\t\t\t\tif (*buf == NULL) {\n\t\t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*len = objlen-1;\n\t\t\t\tparm = *buf;\n\t\t\t}\n\t\t\tr = decode_bit_string(obj, objlen, (u8 *) parm, *len, invert);\n\t\t\tif (r >= 0) {\n\t\t\t\t*len = r;\n\t\t\t\tr = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SC_ASN1_BIT_FIELD:\n\t\tif (parm != NULL)\n\t\t\tr = decode_bit_field(obj, objlen, (u8 *) parm, *len);\n\t\tbreak;\n\tcase SC_ASN1_OCTET_STRING:\n\t\tif (parm != NULL) {\n\t\t\tsize_t c;\n\t\t\tassert(len != NULL);\n\n\t\t\t/* Strip off padding zero */\n\t\t\tif ((entry->flags & SC_ASN1_UNSIGNED)\n\t\t\t && obj[0] == 0x00 && objlen > 1) {\n\t\t\t\tobjlen--;\n\t\t\t\tobj++;\n\t\t\t}\n\n\t\t\t/* Allocate buffer if needed */\n\t\t\tif (entry->flags & SC_ASN1_ALLOC) {\n\t\t\t\tu8 **buf = (u8 **) parm;\n\t\t\t\t*buf = malloc(objlen);\n\t\t\t\tif (*buf == NULL) {\n\t\t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tc = *len = objlen;\n\t\t\t\tparm = *buf;\n\t\t\t} else\n\t\t\t\tc = objlen > *len ? *len : objlen;\n\n\t\t\tmemcpy(parm, obj, c);\n\t\t\t*len = c;\n\t\t}\n\t\tbreak;\n\tcase SC_ASN1_GENERALIZEDTIME:\n\t\tif (parm != NULL) {\n\t\t\tsize_t c;\n\t\t\tassert(len != NULL);\n\t\t\tif (entry->flags & SC_ASN1_ALLOC) {\n\t\t\t\tu8 **buf = (u8 **) parm;\n\t\t\t\t*buf = malloc(objlen);\n\t\t\t\tif (*buf == NULL) {\n\t\t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tc = *len = objlen;\n\t\t\t\tparm = *buf;\n\t\t\t} else\n\t\t\t\tc = objlen > *len ? *len : objlen;\n\n\t\t\tmemcpy(parm, obj, c);\n\t\t\t*len = c;\n\t\t}\n\t\tbreak;\n\tcase SC_ASN1_OBJECT:\n\t\tif (parm != NULL)\n\t\t\tr = sc_asn1_decode_object_id(obj, objlen, (struct sc_object_id *) parm);\n\t\tbreak;\n\tcase SC_ASN1_PRINTABLESTRING:\n\tcase SC_ASN1_UTF8STRING:\n\t\tif (parm != NULL) {\n\t\t\tassert(len != NULL);\n\t\t\tif (entry->flags & SC_ASN1_ALLOC) {\n\t\t\t\tu8 **buf = (u8 **) parm;\n\t\t\t\t*buf = malloc(objlen+1);\n\t\t\t\tif (*buf == NULL) {\n\t\t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*len = objlen+1;\n\t\t\t\tparm = *buf;\n\t\t\t}\n\t\t\tr = sc_asn1_decode_utf8string(obj, objlen, (u8 *) parm, len);\n\t\t\tif (entry->flags & SC_ASN1_ALLOC) {\n\t\t\t\t*len -= 1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SC_ASN1_PATH:\n\t\tif (entry->parm != NULL)\n\t\t\tr = asn1_decode_path(ctx, obj, objlen, (sc_path_t *) parm, depth);\n\t\tbreak;\n\tcase SC_ASN1_PKCS15_ID:\n\t\tif (entry->parm != NULL) {\n\t\t\tstruct sc_pkcs15_id *id = (struct sc_pkcs15_id *) parm;\n\t\t\tsize_t c = objlen > sizeof(id->value) ? sizeof(id->value) : objlen;\n\n\t\t\tmemcpy(id->value, obj, c);\n\t\t\tid->len = c;\n\t\t}\n\t\tbreak;\n\tcase SC_ASN1_PKCS15_OBJECT:\n\t\tif (entry->parm != NULL)\n\t\t\tr = asn1_decode_p15_object(ctx, obj, objlen, (struct sc_asn1_pkcs15_object *) parm, depth);\n\t\tbreak;\n\tcase SC_ASN1_ALGORITHM_ID:\n\t\tif (entry->parm != NULL)\n\t\t\tr = sc_asn1_decode_algorithm_id(ctx, obj, objlen, (struct sc_algorithm_id *) parm, depth);\n\t\tbreak;\n\tcase SC_ASN1_SE_INFO:\n\t\tif (entry->parm != NULL)\n\t\t\tr = asn1_decode_se_info(ctx, obj, objlen, (sc_pkcs15_sec_env_info_t ***)entry->parm, len, depth);\n\t\tbreak;\n\tcase SC_ASN1_CALLBACK:\n\t\tif (entry->parm != NULL)\n\t\t\tr = callback_func(ctx, entry->arg, obj, objlen, depth);\n\t\tbreak;\n\tdefault:\n\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"invalid ASN.1 type: %d\\n\", entry->type);\n\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\t}\n\tif (r) {\n\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"decoding of ASN.1 object '%s' failed: %s\\n\", entry->name,\n\t\t      sc_strerror(r));\n\t\treturn r;\n\t}\n\tentry->flags |= SC_ASN1_PRESENT;\n\treturn 0;\n}\n\nstatic int asn1_decode(sc_context_t *ctx, struct sc_asn1_entry *asn1,\n\t\t       const u8 *in, size_t len, const u8 **newp, size_t *len_left,\n\t\t       int choice, int depth)\n{\n\tint r, idx = 0;\n\tconst u8 *p = in, *obj;\n\tstruct sc_asn1_entry *entry = asn1;\n\tsize_t left = len, objlen;\n\n\tsc_debug(ctx, SC_LOG_DEBUG_ASN1,\n\t\t \"%*.*scalled, left=%\"SC_FORMAT_LEN_SIZE_T\"u, depth %d%s\\n\",\n\t\t depth, depth, \"\", left, depth, choice ? \", choice\" : \"\");\n\n\tif (!p)\n\t\treturn SC_ERROR_ASN1_OBJECT_NOT_FOUND;\n\tif (left < 2) {\n\t\twhile (asn1->name && (asn1->flags & SC_ASN1_OPTIONAL))\n\t\t\tasn1++;\n\t\t/* If all elements were optional, there's nothing\n\t\t * to complain about */\n\t\tif (asn1->name == NULL)\n\t\t\treturn 0;\n\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"End of ASN.1 stream, \"\n\t\t\t      \"non-optional field \\\"%s\\\" not found\\n\",\n\t\t\t      asn1->name);\n\t\treturn SC_ERROR_ASN1_OBJECT_NOT_FOUND;\n\t}\n\tif (p[0] == 0 || p[0] == 0xFF || len == 0)\n\t\treturn SC_ERROR_ASN1_END_OF_CONTENTS;\n\n\tfor (idx = 0; asn1[idx].name != NULL; idx++) {\n\t\tentry = &asn1[idx];\n\n\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"Looking for '%s', tag 0x%x%s%s\\n\",\n\t\t\tentry->name, entry->tag, choice? \", CHOICE\" : \"\",\n\t\t\t(entry->flags & SC_ASN1_OPTIONAL)? \", OPTIONAL\": \"\");\n\n\t\t/* Special case CHOICE has no tag */\n\t\tif (entry->type == SC_ASN1_CHOICE) {\n\t\t\tr = asn1_decode(ctx,\n\t\t\t\t(struct sc_asn1_entry *) entry->parm,\n\t\t\t\tp, left, &p, &left, 1, depth + 1);\n\t\t\tif (r >= 0)\n\t\t\t\tr = 0;\n\t\t\tgoto decode_ok;\n\t\t}\n\n\t\tobj = sc_asn1_skip_tag(ctx, &p, &left, entry->tag, &objlen);\n\t\tif (obj == NULL) {\n\t\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"'%s' not present\\n\", entry->name);\n\t\t\tif (choice)\n\t\t\t\tcontinue;\n\t\t\tif (entry->flags & SC_ASN1_OPTIONAL)\n\t\t\t\tcontinue;\n\t\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"mandatory ASN.1 object '%s' not found\\n\", entry->name);\n\t\t\tif (left) {\n\t\t\t\tu8 line[128], *linep = line;\n\t\t\t\tsize_t i;\n\n\t\t\t\tline[0] = 0;\n\t\t\t\tfor (i = 0; i < 10 && i < left; i++) {\n\t\t\t\t\tsprintf((char *) linep, \"%02X \", p[i]);\n\t\t\t\t\tlinep += 3;\n\t\t\t\t}\n\t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"next tag: %s\\n\", line);\n\t\t\t}\n\t\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_ASN1, SC_ERROR_ASN1_OBJECT_NOT_FOUND);\n\t\t}\n\t\tr = asn1_decode_entry(ctx, entry, obj, objlen, depth);\n\ndecode_ok:\n\t\tif (r)\n\t\t\treturn r;\n\t\tif (choice)\n\t\t\tbreak;\n \t}\n \tif (choice && asn1[idx].name == NULL) /* No match */\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_ASN1, SC_ERROR_ASN1_OBJECT_NOT_FOUND);\n \tif (newp != NULL)\n\t\t*newp = p;\n \tif (len_left != NULL)\n\t\t*len_left = left;\n\tif (choice)\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_ASN1, idx);\n\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_ASN1, 0);\n}\n\nint sc_asn1_decode(sc_context_t *ctx, struct sc_asn1_entry *asn1,\n\t\t   const u8 *in, size_t len, const u8 **newp, size_t *len_left)\n{\n\treturn asn1_decode(ctx, asn1, in, len, newp, len_left, 0, 0);\n}\n\nint sc_asn1_decode_choice(sc_context_t *ctx, struct sc_asn1_entry *asn1,\n\t\t\t  const u8 *in, size_t len, const u8 **newp, size_t *len_left)\n{\n\treturn asn1_decode(ctx, asn1, in, len, newp, len_left, 1, 0);\n}\n\nstatic int asn1_encode_entry(sc_context_t *ctx, const struct sc_asn1_entry *entry,\n\t\t\t     u8 **obj, size_t *objlen, int depth)\n{\n\tvoid *parm = entry->parm;\n\tint (*callback_func)(sc_context_t *nctx, void *arg, u8 **nobj,\n\t\t\t     size_t *nobjlen, int ndepth);\n\tconst size_t *len = (const size_t *) entry->arg;\n\tint r = 0;\n\tu8 * buf = NULL;\n\tsize_t buflen = 0;\n\n\tcallback_func = parm;\n\n\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"%*.*sencoding '%s'%s\\n\",\n\t       \tdepth, depth, \"\", entry->name,\n\t\t(entry->flags & SC_ASN1_PRESENT)? \"\" : \" (not present)\");\n\tif (!(entry->flags & SC_ASN1_PRESENT))\n\t\tgoto no_object;\n\tsc_debug(ctx, SC_LOG_DEBUG_ASN1,\n\t\t \"%*.*stype=%d, tag=0x%02x, parm=%p, len=%\"SC_FORMAT_LEN_SIZE_T\"u\\n\",\n\t\t depth, depth, \"\", entry->type, entry->tag, parm,\n\t\t len ? *len : 0);\n\n\tif (entry->type == SC_ASN1_CHOICE) {\n\t\tconst struct sc_asn1_entry *list, *choice = NULL;\n\n\t\tlist = (const struct sc_asn1_entry *) parm;\n\t\twhile (list->name != NULL) {\n\t\t\tif (list->flags & SC_ASN1_PRESENT) {\n\t\t\t\tif (choice) {\n\t\t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1,\n\t\t\t\t\t\t\"ASN.1 problem: more than \"\n\t\t\t\t\t\t\"one CHOICE when encoding %s: \"\n\t\t\t\t\t\t\"%s and %s both present\\n\",\n\t\t\t\t\t\tentry->name,\n\t\t\t\t\t\tchoice->name,\n\t\t\t\t\t\tlist->name);\n\t\t\t\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\t\t\t\t}\n\t\t\t\tchoice = list;\n\t\t\t}\n\t\t\tlist++;\n\t\t}\n\t\tif (choice == NULL)\n\t\t\tgoto no_object;\n\t\treturn asn1_encode_entry(ctx, choice, obj, objlen, depth + 1);\n\t}\n\n\tif (entry->type != SC_ASN1_NULL && parm == NULL) {\n\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"unexpected parm == NULL\\n\");\n\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\t}\n\n\tswitch (entry->type) {\n\tcase SC_ASN1_STRUCT:\n\t\tr = asn1_encode(ctx, (const struct sc_asn1_entry *) parm, &buf,\n\t\t\t\t&buflen, depth + 1);\n\t\tbreak;\n\tcase SC_ASN1_NULL:\n\t\tbuf = NULL;\n\t\tbuflen = 0;\n\t\tbreak;\n\tcase SC_ASN1_BOOLEAN:\n\t\tbuf = malloc(1);\n\t\tif (buf == NULL) {\n\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\tbreak;\n\t\t}\n\t\tbuf[0] = *((int *) parm) ? 0xFF : 0;\n\t\tbuflen = 1;\n\t\tbreak;\n\tcase SC_ASN1_INTEGER:\n\tcase SC_ASN1_ENUMERATED:\n\t\tr = asn1_encode_integer(*((int *) entry->parm), &buf, &buflen);\n\t\tbreak;\n\tcase SC_ASN1_BIT_STRING_NI:\n\tcase SC_ASN1_BIT_STRING:\n\t\tif (len != NULL) {\n\t\t\tif (entry->type == SC_ASN1_BIT_STRING)\n\t\t\t\tr = encode_bit_string((const u8 *) parm, *len, &buf, &buflen, 1);\n\t\t\telse\n\t\t\t\tr = encode_bit_string((const u8 *) parm, *len, &buf, &buflen, 0);\n\t\t} else {\n\t\t\tr = SC_ERROR_INVALID_ARGUMENTS;\n\t\t}\n\t\tbreak;\n\tcase SC_ASN1_BIT_FIELD:\n\t\tif (len != NULL) {\n\t\t\tr = encode_bit_field((const u8 *) parm, *len, &buf, &buflen);\n\t\t} else {\n\t\t\tr = SC_ERROR_INVALID_ARGUMENTS;\n\t\t}\n\t\tbreak;\n\tcase SC_ASN1_PRINTABLESTRING:\n\tcase SC_ASN1_OCTET_STRING:\n\tcase SC_ASN1_UTF8STRING:\n\t\tif (len != NULL) {\n\t\t\tbuf = malloc(*len + 1);\n\t\t\tif (buf == NULL) {\n\t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuflen = 0;\n\t\t\t/* If the integer is supposed to be unsigned, insert\n\t\t\t * a padding byte if the MSB is one */\n\t\t\tif ((entry->flags & SC_ASN1_UNSIGNED)\n\t\t\t\t\t&& (((u8 *) parm)[0] & 0x80)) {\n\t\t\t\tbuf[buflen++] = 0x00;\n\t\t\t}\n\t\t\tmemcpy(buf + buflen, parm, *len);\n\t\t\tbuflen += *len;\n\t\t} else {\n\t\t\tr = SC_ERROR_INVALID_ARGUMENTS;\n\t\t}\n\t\tbreak;\n\tcase SC_ASN1_GENERALIZEDTIME:\n\t\tif (len != NULL) {\n\t\t\tbuf = malloc(*len);\n\t\t\tif (buf == NULL) {\n\t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(buf, parm, *len);\n\t\t\tbuflen = *len;\n\t\t} else {\n\t\t\tr = SC_ERROR_INVALID_ARGUMENTS;\n\t\t}\n\t\tbreak;\n\tcase SC_ASN1_OBJECT:\n\t\tr = sc_asn1_encode_object_id(&buf, &buflen, (struct sc_object_id *) parm);\n\t\tbreak;\n\tcase SC_ASN1_PATH:\n\t\tr = asn1_encode_path(ctx, (const sc_path_t *) parm, &buf, &buflen, depth, entry->flags);\n\t\tbreak;\n\tcase SC_ASN1_PKCS15_ID:\n\t\t{\n\t\t\tconst struct sc_pkcs15_id *id = (const struct sc_pkcs15_id *) parm;\n\n\t\t\tbuf = malloc(id->len);\n\t\t\tif (buf == NULL) {\n\t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(buf, id->value, id->len);\n\t\t\tbuflen = id->len;\n\t\t}\n\t\tbreak;\n\tcase SC_ASN1_PKCS15_OBJECT:\n\t\tr = asn1_encode_p15_object(ctx, (const struct sc_asn1_pkcs15_object *) parm, &buf, &buflen, depth);\n\t\tbreak;\n\tcase SC_ASN1_ALGORITHM_ID:\n\t\tr = sc_asn1_encode_algorithm_id(ctx, &buf, &buflen, (const struct sc_algorithm_id *) parm, depth);\n\t\tbreak;\n\tcase SC_ASN1_SE_INFO:\n\t\tif (!len)\n\t\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\t\tr = asn1_encode_se_info(ctx, (struct sc_pkcs15_sec_env_info **)parm, *len, &buf, &buflen, depth);\n\t\tbreak;\n\tcase SC_ASN1_CALLBACK:\n\t\tr = callback_func(ctx, entry->arg, &buf, &buflen, depth);\n\t\tbreak;\n\tdefault:\n\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"invalid ASN.1 type: %d\\n\", entry->type);\n\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\t}\n\tif (r) {\n\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"encoding of ASN.1 object '%s' failed: %s\\n\", entry->name,\n\t\t      sc_strerror(r));\n\t\tif (buf)\n\t\t\tfree(buf);\n\t\treturn r;\n\t}\n\n\t/* Treatment of OPTIONAL elements:\n\t *  -\tif the encoding has 0 length, and the element is OPTIONAL,\n\t *\twe don't write anything (unless it's an ASN1 NULL and the\n\t *      SC_ASN1_PRESENT flag is set).\n\t *  -\tif the encoding has 0 length, but the element is non-OPTIONAL,\n\t *\tconstructed, we write a empty element (e.g. a SEQUENCE of\n\t *      length 0). In case of an ASN1 NULL just write the tag and\n\t *      length (i.e. 0x05,0x00).\n\t *  -\tany other empty objects are considered bogus\n\t */\nno_object:\n\tif (!buflen && entry->flags & SC_ASN1_OPTIONAL && !(entry->flags & SC_ASN1_PRESENT)) {\n\t\t/* This happens when we try to encode e.g. the\n\t\t * subClassAttributes, which may be empty */\n\t\t*obj = NULL;\n\t\t*objlen = 0;\n\t\tr = 0;\n\t} else if (!buflen && (entry->flags & SC_ASN1_EMPTY_ALLOWED)) {\n\t\t*obj = NULL;\n\t\t*objlen = 0;\n\t\tr = asn1_write_element(ctx, entry->tag, buf, buflen, obj, objlen);\n\t\tif (r)\n\t\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"error writing ASN.1 tag and length: %s\\n\", sc_strerror(r));\n\t} else if (buflen || entry->type == SC_ASN1_NULL || entry->tag & SC_ASN1_CONS) {\n\t\tr = asn1_write_element(ctx, entry->tag, buf, buflen, obj, objlen);\n\t\tif (r)\n\t\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"error writing ASN.1 tag and length: %s\\n\",\n\t\t\t\t\tsc_strerror(r));\n\t} else if (!(entry->flags & SC_ASN1_PRESENT)) {\n\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"cannot encode non-optional ASN.1 object: not given by caller\\n\");\n\t\tr = SC_ERROR_INVALID_ASN1_OBJECT;\n\t} else {\n\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"cannot encode empty non-optional ASN.1 object\\n\");\n\t\tr = SC_ERROR_INVALID_ASN1_OBJECT;\n\t}\n\tif (buf)\n\t\tfree(buf);\n\tif (r >= 0)\n\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1,\n\t\t\t \"%*.*slength of encoded item=%\"SC_FORMAT_LEN_SIZE_T\"u\\n\",\n\t\t\t depth, depth, \"\", *objlen);\n\treturn r;\n}\n\nstatic int asn1_encode(sc_context_t *ctx, const struct sc_asn1_entry *asn1,\n\t\t      u8 **ptr, size_t *size, int depth)\n{\n\tint r, idx = 0;\n\tu8 *obj = NULL, *buf = NULL, *tmp;\n\tsize_t total = 0, objsize;\n\n\tfor (idx = 0; asn1[idx].name != NULL; idx++) {\n\t\tr = asn1_encode_entry(ctx, &asn1[idx], &obj, &objsize, depth);\n\t\tif (r) {\n\t\t\tif (obj)\n\t\t\t\tfree(obj);\n\t\t\tif (buf)\n\t\t\t\tfree(buf);\n\t\t\treturn r;\n\t\t}\n\t\t/* in case of an empty (optional) element continue with\n\t\t * the next asn1 element */\n\t\tif (!objsize)\n\t\t\tcontinue;\n\t\ttmp = (u8 *) realloc(buf, total + objsize);\n\t\tif (!tmp) {\n\t\t\tif (obj)\n\t\t\t\tfree(obj);\n\t\t\tif (buf)\n\t\t\t\tfree(buf);\n\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\t}\n\t\tbuf = tmp;\n\t\tmemcpy(buf + total, obj, objsize);\n\t\tfree(obj);\n\t\tobj = NULL;\n\t\ttotal += objsize;\n\t}\n\t*ptr = buf;\n\t*size = total;\n\treturn 0;\n}\n\nint sc_asn1_encode(sc_context_t *ctx, const struct sc_asn1_entry *asn1,\n\t\t   u8 **ptr, size_t *size)\n{\n\treturn asn1_encode(ctx, asn1, ptr, size, 0);\n}\n\nint _sc_asn1_encode(sc_context_t *ctx, const struct sc_asn1_entry *asn1,\n\t\t    u8 **ptr, size_t *size, int depth)\n{\n\treturn asn1_encode(ctx, asn1, ptr, size, depth);\n}\n\nint\n_sc_asn1_decode(sc_context_t *ctx, struct sc_asn1_entry *asn1,\n\t\t       const u8 *in, size_t len, const u8 **newp, size_t *left,\n\t\t       int choice, int depth)\n{\n\treturn asn1_decode(ctx, asn1, in, len, newp, left, choice, depth);\n}\n\nint\nsc_der_copy(sc_pkcs15_der_t *dst, const sc_pkcs15_der_t *src)\n{\n\tif (!dst)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tmemset(dst, 0, sizeof(*dst));\n\tif (src->len) {\n\t\tdst->value = malloc(src->len);\n\t\tif (!dst->value)\n\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\tdst->len = src->len;\n\t\tmemcpy(dst->value, src->value, src->len);\n\t}\n\treturn SC_SUCCESS;\n}\n\nint\nsc_encode_oid (struct sc_context *ctx, struct sc_object_id *id,\n\t\tunsigned char **out, size_t *size)\n{\n\tstatic const struct sc_asn1_entry c_asn1_object_id[2] = {\n\t\t{ \"oid\", SC_ASN1_OBJECT, SC_ASN1_TAG_OBJECT, SC_ASN1_ALLOC, NULL, NULL },\n\t\t{ NULL, 0, 0, 0, NULL, NULL }\n\t};\n\tstruct sc_asn1_entry asn1_object_id[2];\n\tint rv;\n\n\tsc_copy_asn1_entry(c_asn1_object_id, asn1_object_id);\n\tsc_format_asn1_entry(asn1_object_id + 0, id, NULL, 1);\n\n\trv = _sc_asn1_encode(ctx, asn1_object_id, out, size, 1);\n\tLOG_TEST_RET(ctx, rv, \"Cannot encode object ID\");\n\n\treturn SC_SUCCESS;\n}\n\n\n#define C_ASN1_SIG_VALUE_SIZE 2\nstatic struct sc_asn1_entry c_asn1_sig_value[C_ASN1_SIG_VALUE_SIZE] = {\n\t\t{ \"ECDSA-Sig-Value\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, 0, NULL, NULL },\n\t\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_SIG_VALUE_COEFFICIENTS_SIZE 3\nstatic struct sc_asn1_entry c_asn1_sig_value_coefficients[C_ASN1_SIG_VALUE_COEFFICIENTS_SIZE] = {\n\t\t{ \"r\", SC_ASN1_OCTET_STRING, SC_ASN1_TAG_INTEGER, SC_ASN1_ALLOC|SC_ASN1_UNSIGNED, NULL, NULL },\n\t\t{ \"s\", SC_ASN1_OCTET_STRING, SC_ASN1_TAG_INTEGER, SC_ASN1_ALLOC|SC_ASN1_UNSIGNED, NULL, NULL },\n\t\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n\nint\nsc_asn1_sig_value_rs_to_sequence(struct sc_context *ctx, unsigned char *in, size_t inlen,\n\t\tunsigned char **buf, size_t *buflen)\n{\n\tstruct sc_asn1_entry asn1_sig_value[C_ASN1_SIG_VALUE_SIZE];\n\tstruct sc_asn1_entry asn1_sig_value_coefficients[C_ASN1_SIG_VALUE_COEFFICIENTS_SIZE];\n\tunsigned char *r = in, *s = in + inlen/2;\n\tsize_t r_len = inlen/2, s_len = inlen/2;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\t/* R/S are filled up with zeroes, we do not want that in sequence format */\n\twhile(r_len > 1 && *r == 0x00) {\n\t\tr++;\n\t\tr_len--;\n\t}\n\twhile(s_len > 1 && *s == 0x00) {\n\t\ts++;\n\t\ts_len--;\n\t}\n\n\tsc_copy_asn1_entry(c_asn1_sig_value, asn1_sig_value);\n\tsc_format_asn1_entry(asn1_sig_value + 0, asn1_sig_value_coefficients, NULL, 1);\n\n\tsc_copy_asn1_entry(c_asn1_sig_value_coefficients, asn1_sig_value_coefficients);\n\tsc_format_asn1_entry(asn1_sig_value_coefficients + 0, r, &r_len, 1);\n\tsc_format_asn1_entry(asn1_sig_value_coefficients + 1, s, &s_len, 1);\n\n\trv = sc_asn1_encode(ctx, asn1_sig_value, buf, buflen);\n\tLOG_TEST_RET(ctx, rv, \"ASN.1 encoding ECDSA-SIg-Value failed\");\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nint\nsc_asn1_sig_value_sequence_to_rs(struct sc_context *ctx, const unsigned char *in, size_t inlen,\n\t\tunsigned char *buf, size_t buflen)\n{\n\tstruct sc_asn1_entry asn1_sig_value[C_ASN1_SIG_VALUE_SIZE];\n\tstruct sc_asn1_entry asn1_sig_value_coefficients[C_ASN1_SIG_VALUE_COEFFICIENTS_SIZE];\n\tunsigned char *r = NULL, *s = NULL;\n\tsize_t r_len, s_len, halflen = buflen/2;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!buf || !buflen)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\tsc_copy_asn1_entry(c_asn1_sig_value, asn1_sig_value);\n\tsc_format_asn1_entry(asn1_sig_value + 0, asn1_sig_value_coefficients, NULL, 0);\n\n\tsc_copy_asn1_entry(c_asn1_sig_value_coefficients, asn1_sig_value_coefficients);\n\tsc_format_asn1_entry(asn1_sig_value_coefficients + 0, &r, &r_len, 0);\n\tsc_format_asn1_entry(asn1_sig_value_coefficients + 1, &s, &s_len, 0);\n\n\trv = sc_asn1_decode(ctx, asn1_sig_value, in, inlen, NULL, NULL);\n\tLOG_TEST_GOTO_ERR(ctx, rv, \"ASN.1 decoding ECDSA-Sig-Value failed\");\n\n\tif (halflen < r_len || halflen < s_len)   {\n\t\trv = SC_ERROR_BUFFER_TOO_SMALL;\n\t\tgoto err;\n\t}\n\n\tmemset(buf, 0, buflen);\n\tmemcpy(buf + (halflen - r_len), r, r_len);\n\tmemcpy(buf + (buflen - s_len), s, s_len);\n\n\tsc_log(ctx, \"r(%\"SC_FORMAT_LEN_SIZE_T\"u): %s\", halflen,\n\t       sc_dump_hex(buf, halflen));\n\tsc_log(ctx, \"s(%\"SC_FORMAT_LEN_SIZE_T\"u): %s\", halflen,\n\t       sc_dump_hex(buf + halflen, halflen));\n\n\trv = SC_SUCCESS;\nerr:\n\tfree(r);\n\tfree(s);\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n"], "fixing_code": ["/*\n * asn1.c: ASN.1 decoding functions (DER)\n *\n * Copyright (C) 2001, 2002  Juha Yrj\u00f6l\u00e4 <juha.yrjola@iki.fi>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <assert.h>\n#include <ctype.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"internal.h\"\n#include \"asn1.h\"\n\nstatic int asn1_decode(sc_context_t *ctx, struct sc_asn1_entry *asn1,\n\t\t       const u8 *in, size_t len, const u8 **newp, size_t *len_left,\n\t\t       int choice, int depth);\nstatic int asn1_encode(sc_context_t *ctx, const struct sc_asn1_entry *asn1,\n\t\t       u8 **ptr, size_t *size, int depth);\nstatic int asn1_write_element(sc_context_t *ctx, unsigned int tag,\n\t\tconst u8 * data, size_t datalen, u8 ** out, size_t * outlen);\n\nstatic const char *tag2str(unsigned int tag)\n{\n\tstatic const char *tags[] = {\n\t\t\"EOC\", \"BOOLEAN\", \"INTEGER\", \"BIT STRING\", \"OCTET STRING\",\t/* 0-4 */\n\t\t\"NULL\", \"OBJECT IDENTIFIER\", \"OBJECT DESCRIPTOR\", \"EXTERNAL\", \"REAL\",\t/* 5-9 */\n\t\t\"ENUMERATED\", \"Universal 11\", \"UTF8String\", \"Universal 13\",\t/* 10-13 */\n\t\t\"Universal 14\", \"Universal 15\", \"SEQUENCE\", \"SET\",\t/* 15-17 */\n\t\t\"NumericString\", \"PrintableString\", \"T61String\",\t/* 18-20 */\n\t\t\"VideotexString\", \"IA5String\", \"UTCTIME\", \"GENERALIZEDTIME\",\t/* 21-24 */\n\t\t\"GraphicString\", \"VisibleString\", \"GeneralString\",\t/* 25-27 */\n\t\t\"UniversalString\", \"Universal 29\", \"BMPString\"\t/* 28-30 */\n\t};\n\n\tif (tag > 30)\n\t\treturn \"(unknown)\";\n\treturn tags[tag];\n}\n\nint sc_asn1_read_tag(const u8 ** buf, size_t buflen, unsigned int *cla_out,\n\t\t     unsigned int *tag_out, size_t *taglen)\n{\n\tconst u8 *p = *buf;\n\tsize_t left = buflen, len;\n\tunsigned int cla, tag, i;\n\n\t*buf = NULL;\n\n\tif (left == 0)\n\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\tif (*p == 0xff || *p == 0) {\n\t\t/* end of data reached */\n\t\t*taglen = 0;\n\t\t*tag_out = SC_ASN1_TAG_EOC;\n\t\treturn SC_SUCCESS;\n\t}\n\n\t/* parse tag byte(s)\n\t * Resulted tag is presented by integer that has not to be\n\t * confused with the 'tag number' part of ASN.1 tag.\n\t */\n\tcla = (*p & SC_ASN1_TAG_CLASS) | (*p & SC_ASN1_TAG_CONSTRUCTED);\n\ttag = *p & SC_ASN1_TAG_PRIMITIVE;\n\tp++;\n\tleft--;\n\tif (tag == SC_ASN1_TAG_PRIMITIVE) {\n\t\t/* high tag number */\n\t\tsize_t n = SC_ASN1_TAGNUM_SIZE - 1;\n\t\t/* search the last tag octet */\n\t\tdo {\n\t\t\tif (left == 0 || n == 0)\n\t\t\t\t/* either an invalid tag or it doesn't fit in\n\t\t\t\t * unsigned int */\n\t\t\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\t\t\ttag <<= 8;\n\t\t\ttag |= *p;\n\t\t\tp++;\n\t\t\tleft--;\n\t\t\tn--;\n\t\t} while (tag & 0x80);\n\t}\n\n\t/* parse length byte(s) */\n\tif (left == 0)\n\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\tlen = *p;\n\tp++;\n\tleft--;\n\tif (len & 0x80) {\n\t\tlen &= 0x7f;\n\t\tunsigned int a = 0;\n\t\tif (len > sizeof a || len > left)\n\t\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\ta <<= 8;\n\t\t\ta |= *p;\n\t\t\tp++;\n\t\t\tleft--;\n\t\t}\n\t\tlen = a;\n\t}\n\n\t*cla_out = cla;\n\t*tag_out = tag;\n\t*taglen = len;\n\t*buf = p;\n\n\tif (len > left)\n\t\treturn SC_ERROR_ASN1_END_OF_CONTENTS;\n\n\treturn SC_SUCCESS;\n}\n\nvoid sc_format_asn1_entry(struct sc_asn1_entry *entry, void *parm, void *arg,\n\t\t\t  int set_present)\n{\n\tentry->parm = parm;\n\tentry->arg  = arg;\n\tif (set_present)\n\t\tentry->flags |= SC_ASN1_PRESENT;\n}\n\nvoid sc_copy_asn1_entry(const struct sc_asn1_entry *src,\n\t\t\tstruct sc_asn1_entry *dest)\n{\n\twhile (src->name != NULL) {\n\t\t*dest = *src;\n\t\tdest++;\n\t\tsrc++;\n\t}\n\tdest->name = NULL;\n}\n\nstatic void print_indent(size_t depth)\n{\n\tfor (; depth > 0; depth--) {\n\t\tputchar(' ');\n\t}\n}\n\nstatic void print_hex(const u8 * buf, size_t buflen, size_t depth)\n{\n\tsize_t lines_len = buflen * 5 + 128;\n\tchar *lines = malloc(lines_len);\n\tchar *line = lines;\n\n\tif (buf == NULL || buflen == 0 || lines == NULL) {\n\t\tfree(lines);\n\t\treturn;\n\t}\n\n\tsc_hex_dump(buf, buflen, lines, lines_len);\n\n\twhile (*line != '\\0') {\n\t\tchar *line_end = strchr(line, '\\n');\n\t\tptrdiff_t width = line_end - line;\n\t\tif (!line_end || width <= 1) {\n\t\t\t/* don't print empty lines */\n\t\t\tbreak;\n\t\t}\n\t\tif (buflen > 8) {\n\t\t\tputchar('\\n');\n\t\t\tprint_indent(depth);\n\t\t} else {\n\t\t\tprintf(\": \");\n\t\t}\n\t\tprintf(\"%.*s\", (int) width, line);\n\t\tline = line_end + 1;\n\t}\n\n\tfree(lines);\n}\n\nstatic void print_ascii(const u8 * buf, size_t buflen)\n{\n\tfor (; 0 < buflen; buflen--, buf++) {\n\t\tif (isprint(*buf))\n\t\t\tprintf(\"%c\", *buf);\n\t\telse\n\t\t\tputchar('.');\n\t}\n}\n\nstatic void sc_asn1_print_octet_string(const u8 * buf, size_t buflen, size_t depth)\n{\n\tprint_hex(buf, buflen, depth);\n}\n\nstatic void sc_asn1_print_utf8string(const u8 * buf, size_t buflen)\n{\n\t/* FIXME UTF-8 is not ASCII */\n\tprint_ascii(buf, buflen);\n}\n\nstatic void sc_asn1_print_integer(const u8 * buf, size_t buflen)\n{\n\tsize_t a = 0;\n\n\tif (buflen > sizeof(a)) {\n\t\tprintf(\"0x%s\", sc_dump_hex(buf, buflen));\n\t} else {\n\t\tsize_t i;\n\t\tfor (i = 0; i < buflen; i++) {\n\t\t\ta <<= 8;\n\t\t\ta |= buf[i];\n\t\t}\n\t\tprintf(\"%\"SC_FORMAT_LEN_SIZE_T\"u\", a);\n\t}\n}\n\nstatic void sc_asn1_print_boolean(const u8 * buf, size_t buflen)\n{\n\tif (!buflen)\n\t\treturn;\n\n\tif (buf[0])\n\t\tprintf(\"true\");\n\telse\n\t\tprintf(\"false\");\n}\n\nstatic void sc_asn1_print_bit_string(const u8 * buf, size_t buflen, size_t depth)\n{\n#ifndef _WIN32\n\tlong long a = 0;\n#else\n\t__int64 a = 0;\n#endif\n\tint r, i;\n\n\tif (buflen > sizeof(a) + 1) {\n\t\tprint_hex(buf, buflen, depth);\n\t} else {\n\t\tr = sc_asn1_decode_bit_string(buf, buflen, &a, sizeof(a));\n\t\tif (r < 0) {\n\t\t\tprintf(\"decode error\");\n\t\t\treturn;\n\t\t}\n\t\tfor (i = r - 1; i >= 0; i--) {\n\t\t\tprintf(\"%c\", ((a >> i) & 1) ? '1' : '0');\n\t\t}\n\t}\n}\n\n#ifdef ENABLE_OPENSSL\n#include <openssl/objects.h>\n\nstatic void openssl_print_object_sn(const char *s)\n{\n\tASN1_OBJECT *obj = OBJ_txt2obj(s, 0);\n\tif (obj) {\n\t\tint nid = OBJ_obj2nid(obj);\n\t\tif (nid != NID_undef) {\n\t\t\tprintf(\", %s\", OBJ_nid2sn(nid));\n\t\t}\n\t\tASN1_OBJECT_free(obj);\n\t}\n}\n#else\nstatic void openssl_print_object_sn(const char *s)\n{\n}\n#endif\n\nstatic void sc_asn1_print_object_id(const u8 * buf, size_t buflen)\n{\n\tstruct sc_object_id oid;\n\tconst char *sbuf;\n\n\tif (sc_asn1_decode_object_id(buf, buflen, &oid)) {\n\t\tprintf(\"decode error\");\n\t\treturn;\n\t}\n\n\tsbuf = sc_dump_oid(&oid);\n\tprintf(\" %s\", sbuf);\n\topenssl_print_object_sn(sbuf);\n}\n\nstatic void sc_asn1_print_utctime(const u8 * buf, size_t buflen)\n{\n\tif (buflen < 8) {\n\t\tprintf(\"Error in decoding.\\n\");\n\t\treturn;\n\t}\n\n\tprint_ascii(buf, 2);\t\t/* YY */\n\tputchar('-');\n\tprint_ascii(buf+2, 2);\t\t/* MM */\n\tputchar('-');\n\tprint_ascii(buf+4, 2);\t\t/* DD */\n\tputchar(' ');\n\tprint_ascii(buf+6, 2);\t\t/* hh */\n\tbuf += 8;\n\tbuflen -= 8;\n\tif (buflen >= 2 && isdigit(buf[0]) && isdigit(buf[1])) {\n\t\tputchar(':');\n\t\tprint_ascii(buf, 2);\t/* mm */\n\t\tbuf += 2;\n\t\tbuflen -= 2;\n\t}\n\tif (buflen >= 2 && isdigit(buf[0]) && isdigit(buf[1])) {\n\t\tputchar(':');\n\t\tprint_ascii(buf, 2);\t/* ss */\n\t\tbuf += 2;\n\t\tbuflen -= 2;\n\t}\n\tif (buflen >= 4 && '.' == buf[0]) {\n\t\tprint_ascii(buf, 4);\t/* fff */\n\t\tbuf += 4;\n\t\tbuflen -= 4;\n\t}\n\n\tif (buflen >= 1 && 'Z' == buf[0]) {\n\t\tprintf(\" UTC\");\n\t} else if (buflen >= 5 && ('-' == buf[0] || '+' == buf[0])) {\n\t\tputchar(' ');\n\t\tprint_ascii(buf, 3);\t/* +/-hh */\n\t\tputchar(':');\n\t\tprint_ascii(buf+3, 2);\t/* mm */\n\t}\n}\n\nstatic void sc_asn1_print_generalizedtime(const u8 * buf, size_t buflen)\n{\n\tif (buflen < 8) {\n\t\tprintf(\"Error in decoding.\\n\");\n\t\treturn;\n\t}\n\n\tprint_ascii(buf, 2);\n\tsc_asn1_print_utctime(buf + 2, buflen - 2);\n}\n\nstatic void print_tags_recursive(const u8 * buf0, const u8 * buf,\n\t\t\t\t size_t buflen, size_t depth)\n{\n\tint r;\n\tsize_t i;\n\tsize_t bytesleft = buflen;\n\tconst char *classes[4] = {\n\t\t\"Universal\",\n\t\t\"Application\",\n\t\t\"Context\",\n\t\t\"Private\"\n\t};\n\tconst u8 *p = buf;\n\n\twhile (bytesleft >= 2) {\n\t\tunsigned int cla = 0, tag = 0, hlen;\n\t\tconst u8 *tagp = p;\n\t\tsize_t len;\n\n\t\tr = sc_asn1_read_tag(&tagp, bytesleft, &cla, &tag, &len);\n\t\tif (r != SC_SUCCESS || tagp == NULL) {\n\t\t\tprintf(\"Error in decoding.\\n\");\n\t\t\treturn;\n\t\t}\n\t\thlen = tagp - p;\n\t\tif (cla == 0 && tag == 0) {\n\t\t\tprintf(\"Zero tag, finishing\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tprint_indent(depth);\n\t\t/* let i be the length of the tag in bytes */\n\t\tfor (i = 1; i < sizeof tag - 1; i++) {\n\t\t\tif (!(tag >> 8*i))\n\t\t\t\tbreak;\n\t\t}\n\t\tprintf(\"%02X\", cla<<(i-1)*8 | tag);\n\n\t\tif ((cla & SC_ASN1_TAG_CLASS) == SC_ASN1_TAG_UNIVERSAL) {\n\t\t\tprintf(\" %s\", tag2str(tag));\n\t\t} else {\n\t\t\tprintf(\" %s %-2u\",\n\t\t\t\t\tclasses[cla >> 6],\n\t\t\t\t\ti == 1 ? tag & SC_ASN1_TAG_PRIMITIVE : tag & (((unsigned int) ~0) >> (i-1)*8));\n\t\t}\n\t\tif (!((cla & SC_ASN1_TAG_CLASS) == SC_ASN1_TAG_UNIVERSAL\n\t\t\t\t\t&& tag == SC_ASN1_TAG_NULL && len == 0)) {\n\t\t\tprintf(\" (%\"SC_FORMAT_LEN_SIZE_T\"u byte%s)\",\n\t\t\t\t\tlen,\n\t\t\t\t\tlen != 1 ? \"s\" : \"\");\n\t\t}\n\n\t\tif (len + hlen > bytesleft) {\n\t\t\tprintf(\" Illegal length!\\n\");\n\t\t\treturn;\n\t\t}\n\t\tp += hlen + len;\n\t\tbytesleft -= hlen + len;\n\n\t\tif (cla & SC_ASN1_TAG_CONSTRUCTED) {\n\t\t\tputchar('\\n');\n\t\t\tprint_tags_recursive(buf0, tagp, len, depth + 2*i + 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (tag) {\n\t\t\tcase SC_ASN1_TAG_BIT_STRING:\n\t\t\t\tprintf(\": \");\n\t\t\t\tsc_asn1_print_bit_string(tagp, len, depth + 2*i + 1);\n\t\t\t\tbreak;\n\t\t\tcase SC_ASN1_TAG_OCTET_STRING:\n\t\t\t\tsc_asn1_print_octet_string(tagp, len, depth + 2*i + 1);\n\t\t\t\tbreak;\n\t\t\tcase SC_ASN1_TAG_OBJECT:\n\t\t\t\tprintf(\": \");\n\t\t\t\tsc_asn1_print_object_id(tagp, len);\n\t\t\t\tbreak;\n\t\t\tcase SC_ASN1_TAG_INTEGER:\n\t\t\tcase SC_ASN1_TAG_ENUMERATED:\n\t\t\t\tprintf(\": \");\n\t\t\t\tsc_asn1_print_integer(tagp, len);\n\t\t\t\tbreak;\n\t\t\tcase SC_ASN1_TAG_IA5STRING:\n\t\t\tcase SC_ASN1_TAG_PRINTABLESTRING:\n\t\t\tcase SC_ASN1_TAG_T61STRING:\n\t\t\tcase SC_ASN1_TAG_UTF8STRING:\n\t\t\t\tprintf(\": \");\n\t\t\t\tsc_asn1_print_utf8string(tagp, len);\n\t\t\t\tbreak;\n\t\t\tcase SC_ASN1_TAG_BOOLEAN:\n\t\t\t\tprintf(\": \");\n\t\t\t\tsc_asn1_print_boolean(tagp, len);\n\t\t\t\tbreak;\n\t\t\tcase SC_ASN1_GENERALIZEDTIME:\n\t\t\t\tprintf(\": \");\n\t\t\t\tsc_asn1_print_generalizedtime(tagp, len);\n\t\t\t\tbreak;\n\t\t\tcase SC_ASN1_UTCTIME:\n\t\t\t\tprintf(\": \");\n\t\t\t\tsc_asn1_print_utctime(tagp, len);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif ((cla & SC_ASN1_TAG_CLASS) == SC_ASN1_TAG_APPLICATION) {\n\t\t\tprint_hex(tagp, len, depth + 2*i + 1);\n\t\t}\n\n\t\tif ((cla & SC_ASN1_TAG_CLASS) == SC_ASN1_TAG_CONTEXT) {\n\t\t\tprint_hex(tagp, len, depth + 2*i + 1);\n\t\t}\n\n\t\tputchar('\\n');\n\t}\n}\n\nvoid sc_asn1_print_tags(const u8 * buf, size_t buflen)\n{\n\tprint_tags_recursive(buf, buf, buflen, 0);\n}\n\nconst u8 *sc_asn1_find_tag(sc_context_t *ctx, const u8 * buf,\n\tsize_t buflen, unsigned int tag_in, size_t *taglen_in)\n{\n\tsize_t left = buflen, taglen;\n\tconst u8 *p = buf;\n\n\t*taglen_in = 0;\n\twhile (left >= 2) {\n\t\tunsigned int cla = 0, tag, mask = 0xff00;\n\n\t\tbuf = p;\n\t\t/* read a tag */\n\t\tif (sc_asn1_read_tag(&p, left, &cla, &tag, &taglen) != SC_SUCCESS\n\t\t\t\t|| p == NULL)\n\t\t\treturn NULL;\n\n\t\tleft -= (p - buf);\n\t\t/* we need to shift the class byte to the leftmost\n\t\t * byte of the tag */\n\t\twhile ((tag & mask) != 0) {\n\t\t\tcla  <<= 8;\n\t\t\tmask <<= 8;\n\t\t}\n\t\t/* compare the read tag with the given tag */\n\t\tif ((tag | cla) == tag_in) {\n\t\t\t/* we have a match => return length and value part */\n\t\t\tif (taglen > left)\n\t\t\t\treturn NULL;\n\t\t\t*taglen_in = taglen;\n\t\t\treturn p;\n\t\t}\n\t\t/* otherwise continue reading tags */\n\t\tleft -= taglen;\n\t\tp += taglen;\n\t}\n\treturn NULL;\n}\n\nconst u8 *sc_asn1_skip_tag(sc_context_t *ctx, const u8 ** buf, size_t *buflen,\n\t\t\t   unsigned int tag_in, size_t *taglen_out)\n{\n\tconst u8 *p = *buf;\n\tsize_t len = *buflen, taglen;\n\tunsigned int cla = 0, tag;\n\n\tif (sc_asn1_read_tag((const u8 **) &p, len, &cla, &tag, &taglen) != SC_SUCCESS\n\t\t\t|| p == NULL)\n\t\treturn NULL;\n\tswitch (cla & 0xC0) {\n\tcase SC_ASN1_TAG_UNIVERSAL:\n\t\tif ((tag_in & SC_ASN1_CLASS_MASK) != SC_ASN1_UNI)\n\t\t\treturn NULL;\n\t\tbreak;\n\tcase SC_ASN1_TAG_APPLICATION:\n\t\tif ((tag_in & SC_ASN1_CLASS_MASK) != SC_ASN1_APP)\n\t\t\treturn NULL;\n\t\tbreak;\n\tcase SC_ASN1_TAG_CONTEXT:\n\t\tif ((tag_in & SC_ASN1_CLASS_MASK) != SC_ASN1_CTX)\n\t\t\treturn NULL;\n\t\tbreak;\n\tcase SC_ASN1_TAG_PRIVATE:\n\t\tif ((tag_in & SC_ASN1_CLASS_MASK) != SC_ASN1_PRV)\n\t\t\treturn NULL;\n\t\tbreak;\n\t}\n\tif (cla & SC_ASN1_TAG_CONSTRUCTED) {\n\t\tif ((tag_in & SC_ASN1_CONS) == 0)\n\t\t\treturn NULL;\n\t} else\n\t\tif (tag_in & SC_ASN1_CONS)\n\t\t\treturn NULL;\n\tif ((tag_in & SC_ASN1_TAG_MASK) != tag)\n\t\treturn NULL;\n\tlen -= (p - *buf);\t/* header size */\n\tif (taglen > len) {\n\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1,\n\t\t\t \"too long ASN.1 object (size %\"SC_FORMAT_LEN_SIZE_T\"u while only %\"SC_FORMAT_LEN_SIZE_T\"u available)\\n\",\n\t\t\t taglen, len);\n\t\treturn NULL;\n\t}\n\t*buflen -= (p - *buf) + taglen;\n\t*buf = p + taglen;\t/* point to next tag */\n\t*taglen_out = taglen;\n\treturn p;\n}\n\nconst u8 *sc_asn1_verify_tag(sc_context_t *ctx, const u8 * buf, size_t buflen,\n\t\t\t     unsigned int tag_in, size_t *taglen_out)\n{\n\treturn sc_asn1_skip_tag(ctx, &buf, &buflen, tag_in, taglen_out);\n}\n\nstatic int decode_bit_string(const u8 * inbuf, size_t inlen, void *outbuf,\n\t\t\t     size_t outlen, int invert)\n{\n\tconst u8 *in = inbuf;\n\tu8 *out = (u8 *) outbuf;\n\tint i, count = 0;\n\tint zero_bits;\n\tsize_t octets_left;\n\n\tif (outlen < octets_left)\n\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\tif (inlen < 1)\n\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\n\tzero_bits = *in & 0x07;\n\toctets_left = inlen - 1;\n\tin++;\n\tmemset(outbuf, 0, outlen);\n\n\twhile (octets_left) {\n\t\t/* 1st octet of input:  ABCDEFGH, where A is the MSB */\n\t\t/* 1st octet of output: HGFEDCBA, where A is the LSB */\n\t\t/* first bit in bit string is the LSB in first resulting octet */\n\t\tint bits_to_go;\n\n\t\t*out = 0;\n\t\tif (octets_left == 1)\n\t\t\tbits_to_go = 8 - zero_bits;\n\t\telse\n\t\t\tbits_to_go = 8;\n\t\tif (invert)\n\t\t\tfor (i = 0; i < bits_to_go; i++) {\n\t\t\t\t*out |= ((*in >> (7 - i)) & 1) << i;\n\t\t\t}\n\t\telse {\n\t\t\t*out = *in;\n\t\t}\n\t\tout++;\n\t\tin++;\n\t\toctets_left--;\n\t\tcount++;\n\t}\n\treturn (count * 8) - zero_bits;\n}\n\nint sc_asn1_decode_bit_string(const u8 * inbuf, size_t inlen,\n\t\t\t      void *outbuf, size_t outlen)\n{\n\treturn decode_bit_string(inbuf, inlen, outbuf, outlen, 1);\n}\n\nint sc_asn1_decode_bit_string_ni(const u8 * inbuf, size_t inlen,\n\t\t\t\t void *outbuf, size_t outlen)\n{\n\treturn decode_bit_string(inbuf, inlen, outbuf, outlen, 0);\n}\n\nstatic int encode_bit_string(const u8 * inbuf, size_t bits_left, u8 **outbuf,\n\t\t\t     size_t *outlen, int invert)\n{\n\tconst u8 *in = inbuf;\n\tu8 *out;\n\tsize_t bytes;\n\tint skipped = 0;\n\n\tbytes = (bits_left + 7)/8 + 1;\n\t*outbuf = out = malloc(bytes);\n\tif (out == NULL)\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t*outlen = bytes;\n\tout += 1;\n\twhile (bits_left) {\n\t\tint i, bits_to_go = 8;\n\n\t\t*out = 0;\n\t\tif (bits_left < 8) {\n\t\t\tbits_to_go = bits_left;\n\t\t\tskipped = 8 - bits_left;\n\t\t}\n\t\tif (invert) {\n\t\t\tfor (i = 0; i < bits_to_go; i++)\n\t\t\t\t*out |= ((*in >> i) & 1) << (7 - i);\n\t\t} else {\n\t\t\t*out = *in;\n\t\t\tif (bits_left < 8)\n\t\t\t\treturn SC_ERROR_NOT_SUPPORTED; /* FIXME */\n\t\t}\n\t\tbits_left -= bits_to_go;\n\t\tout++, in++;\n\t}\n\tout = *outbuf;\n\tout[0] = skipped;\n\treturn 0;\n}\n\n/*\n * Bitfields are just bit strings, stored in an unsigned int\n * (taking endianness into account)\n */\nstatic int decode_bit_field(const u8 * inbuf, size_t inlen, void *outbuf, size_t outlen)\n{\n\tu8\t\tdata[sizeof(unsigned int)];\n\tunsigned int\tfield = 0;\n\tint\t\ti, n;\n\n\tif (outlen != sizeof(data))\n\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\n\tn = decode_bit_string(inbuf, inlen, data, sizeof(data), 1);\n\tif (n < 0)\n\t\treturn n;\n\n\tfor (i = 0; i < n; i += 8) {\n\t\tfield |= (data[i/8] << i);\n\t}\n\tmemcpy(outbuf, &field, outlen);\n\treturn 0;\n}\n\nstatic int encode_bit_field(const u8 *inbuf, size_t inlen,\n\t\t\t    u8 **outbuf, size_t *outlen)\n{\n\tu8\t\tdata[sizeof(unsigned int)];\n\tunsigned int\tfield = 0;\n\tsize_t\t\ti, bits;\n\n\tif (inlen != sizeof(data))\n\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\n\t/* count the bits */\n\tmemcpy(&field, inbuf, inlen);\n\tfor (bits = 0; field; bits++)\n\t\tfield >>= 1;\n\n\tmemcpy(&field, inbuf, inlen);\n\tfor (i = 0; i < bits; i += 8)\n\t\tdata[i/8] = field >> i;\n\n\treturn encode_bit_string(data, bits, outbuf, outlen, 1);\n}\n\nint sc_asn1_decode_integer(const u8 * inbuf, size_t inlen, int *out)\n{\n\tint    a = 0;\n\tsize_t i;\n\n\tif (inlen > sizeof(int) || inlen == 0)\n\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\tif (inbuf[0] & 0x80)\n\t\ta = -1;\n\tfor (i = 0; i < inlen; i++) {\n\t\ta <<= 8;\n\t\ta |= *inbuf++;\n\t}\n\t*out = a;\n\treturn 0;\n}\n\nstatic int asn1_encode_integer(int in, u8 ** obj, size_t * objsize)\n{\n\tint i = sizeof(in) * 8, skip_zero, skip_sign;\n\tu8 *p, b;\n\n\tif (in < 0)\n\t{\n\t\tskip_sign = 1;\n\t\tskip_zero= 0;\n\t}\n\telse\n\t{\n\t\tskip_sign = 0;\n\t\tskip_zero= 1;\n\t}\n\t*obj = p = malloc(sizeof(in)+1);\n\tif (*obj == NULL)\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\tdo {\n\t\ti -= 8;\n\t\tb = in >> i;\n\t\tif (skip_sign)\n\t\t{\n\t\t\tif (b != 0xff)\n\t\t\t\tskip_sign = 0;\n\t\t\tif (b & 0x80)\n\t\t\t{\n\t\t\t\t*p = b;\n\t\t\t\tif (0xff == b)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tp++;\n\t\t\t\tskip_sign = 0;\n\t\t\t}\n\t\t}\n\t\tif (b == 0 && skip_zero)\n\t\t\tcontinue;\n\t\tif (skip_zero) {\n\t\t\tskip_zero = 0;\n\t\t\t/* prepend 0x00 if MSb is 1 and integer positive */\n\t\t\tif ((b & 0x80) != 0 && in > 0)\n\t\t\t\t*p++ = 0;\n\t\t}\n\t\t*p++ = b;\n\t} while (i > 0);\n\tif (skip_sign)\n\t\tp++;\n\t*objsize = p - *obj;\n\tif (*objsize == 0) {\n\t\t*objsize = 1;\n\t\t(*obj)[0] = 0;\n\t}\n\treturn 0;\n}\n\nint\nsc_asn1_decode_object_id(const u8 *inbuf, size_t inlen, struct sc_object_id *id)\n{\n\tint a;\n\tconst u8 *p = inbuf;\n\tint *octet;\n\n\tif (inlen == 0 || inbuf == NULL || id == NULL)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tsc_init_oid(id);\n\toctet = id->value;\n\n\ta = *p;\n\t*octet++ = a / 40;\n\t*octet++ = a % 40;\n\tinlen--;\n\n\twhile (inlen) {\n\t\tp++;\n\t\ta = *p & 0x7F;\n\t\tinlen--;\n\t\twhile (inlen && *p & 0x80) {\n\t\t\tp++;\n\t\t\ta <<= 7;\n\t\t\ta |= *p & 0x7F;\n\t\t\tinlen--;\n\t\t}\n\t\t*octet++ = a;\n\t\tif (octet - id->value >= SC_MAX_OBJECT_ID_OCTETS)   {\n\t\t\tsc_init_oid(id);\n\t\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\t\t}\n\t};\n\n\treturn 0;\n}\n\nint\nsc_asn1_encode_object_id(u8 **buf, size_t *buflen, const struct sc_object_id *id)\n{\n\tu8 temp[SC_MAX_OBJECT_ID_OCTETS*5], *p = temp;\n\tint\ti;\n\n\tif (!buflen || !id)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\t/* an OID must have at least two components */\n\tif (id->value[0] == -1 || id->value[1] == -1)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tfor (i = 0; i < SC_MAX_OBJECT_ID_OCTETS; i++) {\n\t\tunsigned int k, shift;\n\n\t\tif (id->value[i] == -1)\n\t\t\tbreak;\n\n\t\tk = id->value[i];\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tif (k > 2)\n\t\t\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t\t\t*p = k * 40;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (k > 39)\n\t\t\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t\t\t*p++ += k;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tshift = 28;\n\t\t\twhile (shift && (k >> shift) == 0)\n\t\t\t\tshift -= 7;\n\t\t\twhile (shift) {\n\t\t\t\t*p++ = 0x80 | ((k >> shift) & 0x7f);\n\t\t\t\tshift -= 7;\n\t\t\t}\n\t\t\t*p++ = k & 0x7F;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t*buflen = p - temp;\n\n\tif (buf)   {\n\t\t*buf = malloc(*buflen);\n\t\tif (!*buf)\n\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\tmemcpy(*buf, temp, *buflen);\n\t}\n\treturn 0;\n}\n\nstatic int sc_asn1_decode_utf8string(const u8 *inbuf, size_t inlen,\n\t\t\t      u8 *out, size_t *outlen)\n{\n\tif (inlen+1 > *outlen)\n\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\t*outlen = inlen+1;\n\tmemcpy(out, inbuf, inlen);\n\tout[inlen] = 0;\n\treturn 0;\n}\n\nint sc_asn1_put_tag(unsigned int tag, const u8 * data, size_t datalen, u8 * out, size_t outlen, u8 **ptr)\n{\n\tsize_t c = 0;\n\tsize_t tag_len;\n\tsize_t ii;\n\tu8 *p = out;\n\tu8 tag_char[4] = {0, 0, 0, 0};\n\n\t/* Check tag */\n\tif (tag == 0 || tag > 0xFFFFFFFF) {\n\t\t/* A tag of 0x00 is not valid and at most 4-byte tag names are supported. */\n\t\treturn SC_ERROR_INVALID_DATA;\n\t}\n\tfor (tag_len = 0; tag; tag >>= 8) {\n\t\t/* Note: tag char will be reversed order. */\n\t\ttag_char[tag_len++] = tag & 0xFF;\n\t}\n\n\tif (tag_len > 1)   {\n\t\tif ((tag_char[tag_len - 1] & SC_ASN1_TAG_PRIMITIVE) != SC_ASN1_TAG_ESCAPE_MARKER) {\n\t\t\t/* First byte is not escape marker. */\n\t\t\treturn SC_ERROR_INVALID_DATA;\n\t\t}\n\t\tfor (ii = 1; ii < tag_len - 1; ii++) {\n\t\t\tif ((tag_char[ii] & 0x80) != 0x80) {\n\t\t\t\t/* MS bit is not 'one'. */\n\t\t\t\treturn SC_ERROR_INVALID_DATA;\n\t\t\t}\n\t\t}\n\t\tif ((tag_char[0] & 0x80) != 0x00) {\n\t\t\t/* MS bit of the last byte is not 'zero'. */\n\t\t\treturn SC_ERROR_INVALID_DATA;\n\t\t}\n\t}\n\n\t/* Calculate the number of additional bytes necessary to encode the length. */\n\t/* c+1 is the size of the length field. */\n\tif (datalen > 127) {\n\t\tc = 1;\n\t\twhile (datalen >> (c << 3))\n\t\t\tc++;\n\t}\n\tif (outlen == 0 || out == NULL) {\n\t\t/* Caller only asks for the length that would be written. */\n\t\treturn tag_len + (c+1) + datalen;\n\t}\n\t/* We will write the tag, so check the length. */\n\tif (outlen < tag_len + (c+1) + datalen)\n\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\tfor (ii=0;ii<tag_len;ii++)\n\t\t*p++ = tag_char[tag_len - ii - 1];\n\n\tif (c > 0) {\n\t\t*p++ = 0x80 | c;\n\t\twhile (c--)\n\t\t\t*p++ = (datalen >> (c << 3)) & 0xFF;\n\t}\n\telse {\n\t\t*p++ = datalen & 0x7F;\n\t}\n\tif(data && datalen > 0) {\n\t\tmemcpy(p, data, datalen);\n\t\tp += datalen;\n\t}\n\tif (ptr != NULL)\n\t\t*ptr = p;\n\treturn 0;\n}\n\nint sc_asn1_write_element(sc_context_t *ctx, unsigned int tag,\n\tconst u8 * data, size_t datalen, u8 ** out, size_t * outlen)\n{\n\treturn asn1_write_element(ctx, tag, data, datalen, out, outlen);\n}\n\nstatic int asn1_write_element(sc_context_t *ctx, unsigned int tag,\n\tconst u8 * data, size_t datalen, u8 ** out, size_t * outlen)\n{\n\tunsigned char t;\n\tunsigned char *buf, *p;\n\tint c = 0;\n\tunsigned short_tag;\n\tunsigned char tag_char[3] = {0, 0, 0};\n\tsize_t tag_len, ii;\n\n\tshort_tag = tag & SC_ASN1_TAG_MASK;\n\tfor (tag_len = 0; short_tag >> (8 * tag_len); tag_len++)\n\t\ttag_char[tag_len] = (short_tag >> (8 * tag_len)) & 0xFF;\n\tif (!tag_len)\n\t\ttag_len = 1;\n\n\tif (tag_len > 1)   {\n\t\tif ((tag_char[tag_len - 1] & SC_ASN1_TAG_PRIMITIVE) != SC_ASN1_TAG_ESCAPE_MARKER)\n\t\t\tSC_TEST_RET(ctx, SC_LOG_DEBUG_ASN1, SC_ERROR_INVALID_DATA, \"First byte of the long tag is not 'escape marker'\");\n\n\t\tfor (ii = 1; ii < tag_len - 1; ii++)\n\t\t\tif (!(tag_char[ii] & 0x80))\n\t\t\t\tSC_TEST_RET(ctx, SC_LOG_DEBUG_ASN1, SC_ERROR_INVALID_DATA, \"MS bit expected to be 'one'\");\n\n\t\tif (tag_char[0] & 0x80)\n\t\t\tSC_TEST_RET(ctx, SC_LOG_DEBUG_ASN1, SC_ERROR_INVALID_DATA, \"MS bit of the last byte expected to be 'zero'\");\n\t}\n\n\tt = tag_char[tag_len - 1] & 0x1F;\n\n\tswitch (tag & SC_ASN1_CLASS_MASK) {\n\tcase SC_ASN1_UNI:\n\t\tbreak;\n\tcase SC_ASN1_APP:\n\t\tt |= SC_ASN1_TAG_APPLICATION;\n\t\tbreak;\n\tcase SC_ASN1_CTX:\n\t\tt |= SC_ASN1_TAG_CONTEXT;\n\t\tbreak;\n\tcase SC_ASN1_PRV:\n\t\tt |= SC_ASN1_TAG_PRIVATE;\n\t\tbreak;\n\t}\n\tif (tag & SC_ASN1_CONS)\n\t\tt |= SC_ASN1_TAG_CONSTRUCTED;\n\tif (datalen > 127) {\n\t\tc = 1;\n\t\twhile (datalen >> (c << 3))\n\t\t\tc++;\n\t}\n\n\t*outlen = tag_len + 1 + c + datalen;\n\tbuf = malloc(*outlen);\n\tif (buf == NULL)\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_ASN1, SC_ERROR_OUT_OF_MEMORY);\n\n\t*out = p = buf;\n\t*p++ = t;\n\tfor (ii=1;ii<tag_len;ii++)\n\t\t*p++ = tag_char[tag_len - ii - 1];\n\n\tif (c) {\n\t\t*p++ = 0x80 | c;\n\t\twhile (c--)\n\t\t\t*p++ = (datalen >> (c << 3)) & 0xFF;\n\t}\n\telse   {\n\t\t*p++ = datalen & 0x7F;\n\t}\n\tmemcpy(p, data, datalen);\n\n\treturn SC_SUCCESS;\n}\n\nstatic const struct sc_asn1_entry c_asn1_path_ext[3] = {\n\t{ \"aid\",  SC_ASN1_OCTET_STRING, SC_ASN1_APP | 0x0F, 0, NULL, NULL },\n\t{ \"path\", SC_ASN1_OCTET_STRING, SC_ASN1_TAG_OCTET_STRING, 0, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\nstatic const struct sc_asn1_entry c_asn1_path[5] = {\n\t{ \"path\",   SC_ASN1_OCTET_STRING, SC_ASN1_TAG_OCTET_STRING, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"index\",  SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"length\", SC_ASN1_INTEGER, SC_ASN1_CTX | 0, SC_ASN1_OPTIONAL, NULL, NULL },\n/* For some multi-applications PKCS#15 card the ODF records can hold the references to\n * the xDF files and objects placed elsewhere then under the application DF of the ODF itself.\n * In such a case the 'path' ASN1 data includes also the ID of the target application (AID).\n * This path extension do not make a part of PKCS#15 standard.\n */\n\t{ \"pathExtended\", SC_ASN1_STRUCT, SC_ASN1_CTX | 1 | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\nstatic int asn1_decode_path(sc_context_t *ctx, const u8 *in, size_t len,\n\t\t\t    sc_path_t *path, int depth)\n{\n\tint idx, count, r;\n\tstruct sc_asn1_entry asn1_path_ext[3], asn1_path[5];\n\tunsigned char path_value[SC_MAX_PATH_SIZE], aid_value[SC_MAX_AID_SIZE];\n\tsize_t path_len = sizeof(path_value), aid_len = sizeof(aid_value);\n\n\tmemset(path, 0, sizeof(struct sc_path));\n\n\tsc_copy_asn1_entry(c_asn1_path_ext, asn1_path_ext);\n\tsc_copy_asn1_entry(c_asn1_path, asn1_path);\n\n\tsc_format_asn1_entry(asn1_path_ext + 0, aid_value, &aid_len, 0);\n\tsc_format_asn1_entry(asn1_path_ext + 1, path_value, &path_len, 0);\n\n\tsc_format_asn1_entry(asn1_path + 0, path_value, &path_len, 0);\n\tsc_format_asn1_entry(asn1_path + 1, &idx, NULL, 0);\n\tsc_format_asn1_entry(asn1_path + 2, &count, NULL, 0);\n\tsc_format_asn1_entry(asn1_path + 3, asn1_path_ext, NULL, 0);\n\n\tr = asn1_decode(ctx, asn1_path, in, len, NULL, NULL, 0, depth + 1);\n\tif (r)\n\t\treturn r;\n\n\tif (asn1_path[3].flags & SC_ASN1_PRESENT)   {\n\t\t/* extended path present: set 'path' and 'aid' */\n\t\tmemcpy(path->aid.value, aid_value, aid_len);\n\t\tpath->aid.len = aid_len;\n\n\t\tmemcpy(path->value, path_value, path_len);\n\t\tpath->len = path_len;\n\t}\n\telse if (asn1_path[0].flags & SC_ASN1_PRESENT)   {\n\t\t/* path present: set 'path' */\n\t\tmemcpy(path->value, path_value, path_len);\n\t\tpath->len = path_len;\n\t}\n\telse   {\n\t\t/* failed if both 'path' and 'pathExtended' are absent */\n\t\treturn SC_ERROR_ASN1_OBJECT_NOT_FOUND;\n\t}\n\n\tif (path->len == 2)\n\t\tpath->type = SC_PATH_TYPE_FILE_ID;\n\telse   if (path->aid.len && path->len > 2)\n\t\tpath->type = SC_PATH_TYPE_FROM_CURRENT;\n\telse\n\t\tpath->type = SC_PATH_TYPE_PATH;\n\n\tif ((asn1_path[1].flags & SC_ASN1_PRESENT) && (asn1_path[2].flags & SC_ASN1_PRESENT)) {\n\t\tpath->index = idx;\n\t\tpath->count = count;\n\t}\n\telse {\n\t\tpath->index = 0;\n\t\tpath->count = -1;\n\t}\n\n\treturn SC_SUCCESS;\n}\n\nstatic int asn1_encode_path(sc_context_t *ctx, const sc_path_t *path,\n\t\t\t    u8 **buf, size_t *bufsize, int depth, unsigned int parent_flags)\n{\n\tint r;\n \tstruct sc_asn1_entry asn1_path[5];\n\tsc_path_t tpath = *path;\n\n\tsc_copy_asn1_entry(c_asn1_path, asn1_path);\n\tsc_format_asn1_entry(asn1_path + 0, (void *) &tpath.value, (void *) &tpath.len, 1);\n\n\tasn1_path[0].flags |= parent_flags;\n\tif (path->count > 0) {\n\t\tsc_format_asn1_entry(asn1_path + 1, (void *) &tpath.index, NULL, 1);\n\t\tsc_format_asn1_entry(asn1_path + 2, (void *) &tpath.count, NULL, 1);\n\t}\n\tr = asn1_encode(ctx, asn1_path, buf, bufsize, depth + 1);\n\treturn r;\n}\n\n\nstatic const struct sc_asn1_entry c_asn1_se[2] = {\n\t{ \"seInfo\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, 0, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\nstatic const struct sc_asn1_entry c_asn1_se_info[4] = {\n\t{ \"se\",   SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, 0, NULL, NULL },\n\t{ \"owner\",SC_ASN1_OBJECT, SC_ASN1_TAG_OBJECT, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"aid\",  SC_ASN1_OCTET_STRING, SC_ASN1_TAG_OCTET_STRING, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\nstatic int asn1_decode_se_info(sc_context_t *ctx, const u8 *obj, size_t objlen,\n\t\t\t       sc_pkcs15_sec_env_info_t ***se, size_t *num, int depth)\n{\n\tstruct sc_pkcs15_sec_env_info **ses;\n\tconst unsigned char *ptr = obj;\n\tsize_t idx, ptrlen = objlen;\n\tint ret;\n\n\tses = calloc(SC_MAX_SE_NUM, sizeof(sc_pkcs15_sec_env_info_t *));\n\tif (ses == NULL)\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\n\tfor (idx=0; idx < SC_MAX_SE_NUM && ptrlen; )   {\n\t\tstruct sc_asn1_entry asn1_se[2];\n\t\tstruct sc_asn1_entry asn1_se_info[4];\n\t\tstruct sc_pkcs15_sec_env_info si;\n\n\t\tsc_copy_asn1_entry(c_asn1_se, asn1_se);\n\t\tsc_copy_asn1_entry(c_asn1_se_info, asn1_se_info);\n\n\t\tsi.aid.len = sizeof(si.aid.value);\n\t\tsc_format_asn1_entry(asn1_se_info + 0, &si.se, NULL, 0);\n\t\tsc_format_asn1_entry(asn1_se_info + 1, &si.owner, NULL, 0);\n\t\tsc_format_asn1_entry(asn1_se_info + 2, &si.aid.value, &si.aid.len, 0);\n\t\tsc_format_asn1_entry(asn1_se + 0, asn1_se_info, NULL, 0);\n\n\t\tret = asn1_decode(ctx, asn1_se, ptr, ptrlen, &ptr, &ptrlen, 0, depth+1);\n\t\tif (ret != SC_SUCCESS)\n\t\t\tgoto err;\n\t\tif (!(asn1_se_info[1].flags & SC_ASN1_PRESENT))\n\t\t\tsc_init_oid(&si.owner);\n\n\t\tses[idx] = calloc(1, sizeof(sc_pkcs15_sec_env_info_t));\n\t\tif (ses[idx] == NULL) {\n\t\t\tret = SC_ERROR_OUT_OF_MEMORY;\n\t\t\tgoto err;\n\t\t}\n\n\t\tmemcpy(ses[idx], &si, sizeof(struct sc_pkcs15_sec_env_info));\n\t\tidx++;\n\t}\n\n\t*se  = ses;\n\t*num = idx;\n\tret = SC_SUCCESS;\nerr:\n\tif (ret != SC_SUCCESS) {\n\t\tsize_t i;\n\t\tfor (i = 0; i < idx; i++)\n\t\t\tif (ses[i])\n\t\t\t\tfree(ses[i]);\n\t\tfree(ses);\n\t}\n\n\treturn ret;\n}\n\n\nstatic int asn1_encode_se_info(sc_context_t *ctx,\n\t\tstruct sc_pkcs15_sec_env_info **se, size_t se_num,\n\t\tunsigned char **buf, size_t *bufsize, int depth)\n{\n\tunsigned char *ptr = NULL, *out = NULL, *p;\n\tsize_t ptrlen = 0, outlen = 0, idx;\n\tint ret;\n\n\tfor (idx=0; idx < se_num; idx++)   {\n\t\tstruct sc_asn1_entry asn1_se[2];\n\t\tstruct sc_asn1_entry asn1_se_info[4];\n\n\t\tsc_copy_asn1_entry(c_asn1_se, asn1_se);\n\t\tsc_copy_asn1_entry(c_asn1_se_info, asn1_se_info);\n\n\t\tsc_format_asn1_entry(asn1_se_info + 0, &se[idx]->se, NULL, 1);\n\t\tif (sc_valid_oid(&se[idx]->owner))\n\t\t\tsc_format_asn1_entry(asn1_se_info + 1, &se[idx]->owner, NULL, 1);\n\t\tif (se[idx]->aid.len)\n\t\t\tsc_format_asn1_entry(asn1_se_info + 2, &se[idx]->aid.value, &se[idx]->aid.len, 1);\n\t\tsc_format_asn1_entry(asn1_se + 0, asn1_se_info, NULL, 1);\n\n\t\tret = sc_asn1_encode(ctx, asn1_se, &ptr, &ptrlen);\n\t\tif (ret != SC_SUCCESS)\n\t\t\tgoto err;\n\n\t\tif (!ptrlen)\n\t\t\tcontinue;\n\t\tp = (unsigned char *) realloc(out, outlen + ptrlen);\n\t\tif (!p)   {\n\t\t\tret = SC_ERROR_OUT_OF_MEMORY;\n\t\t\tgoto err;\n\t\t}\n\t\tout = p;\n\t\tmemcpy(out + outlen, ptr, ptrlen);\n\t\toutlen += ptrlen;\n\t\tfree(ptr);\n\t\tptr = NULL;\n\t\tptrlen = 0;\n\t}\n\n\t*buf = out;\n\t*bufsize = outlen;\n\tret = SC_SUCCESS;\nerr:\n\tif (ret != SC_SUCCESS && out != NULL)\n\t\tfree(out);\n\treturn ret;\n}\n\n/* TODO: According to specification type of 'SecurityCondition' is 'CHOICE'.\n *       Do it at least for SC_ASN1_PKCS15_ID(authId), SC_ASN1_STRUCT(authReference) and NULL(always). */\nstatic const struct sc_asn1_entry c_asn1_access_control_rule[3] = {\n\t{ \"accessMode\", SC_ASN1_BIT_FIELD, SC_ASN1_TAG_BIT_STRING, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"securityCondition\", SC_ASN1_PKCS15_ID, SC_ASN1_TAG_OCTET_STRING, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n/*\n * in src/libopensc/pkcs15.h SC_PKCS15_MAX_ACCESS_RULES  defined as 8\n */\nstatic const struct sc_asn1_entry c_asn1_access_control_rules[SC_PKCS15_MAX_ACCESS_RULES + 1] = {\n\t{ \"accessControlRule\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"accessControlRule\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"accessControlRule\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"accessControlRule\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"accessControlRule\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"accessControlRule\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"accessControlRule\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"accessControlRule\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\nstatic const struct sc_asn1_entry c_asn1_com_obj_attr[6] = {\n\t{ \"label\", SC_ASN1_UTF8STRING, SC_ASN1_TAG_UTF8STRING, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"flags\", SC_ASN1_BIT_FIELD, SC_ASN1_TAG_BIT_STRING, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"authId\", SC_ASN1_PKCS15_ID, SC_ASN1_TAG_OCTET_STRING, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"userConsent\", SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"accessControlRules\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\nstatic const struct sc_asn1_entry c_asn1_p15_obj[5] = {\n\t{ \"commonObjectAttributes\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, 0, NULL, NULL },\n\t{ \"classAttributes\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, 0, NULL, NULL },\n\t{ \"subClassAttributes\", SC_ASN1_STRUCT, SC_ASN1_CTX | 0 | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"typeAttributes\", SC_ASN1_STRUCT, SC_ASN1_CTX | 1 | SC_ASN1_CONS, 0, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\nstatic int asn1_decode_p15_object(sc_context_t *ctx, const u8 *in,\n\t\t\t\t  size_t len, struct sc_asn1_pkcs15_object *obj,\n\t\t\t\t  int depth)\n{\n\tstruct sc_pkcs15_object *p15_obj = obj->p15_obj;\n\tstruct sc_asn1_entry asn1_c_attr[6], asn1_p15_obj[5];\n\tstruct sc_asn1_entry asn1_ac_rules[SC_PKCS15_MAX_ACCESS_RULES + 1], asn1_ac_rule[SC_PKCS15_MAX_ACCESS_RULES][3];\n\tsize_t flags_len = sizeof(p15_obj->flags);\n\tsize_t label_len = sizeof(p15_obj->label);\n\tsize_t access_mode_len = sizeof(p15_obj->access_rules[0].access_mode);\n\tint r, ii;\n\n\tfor (ii=0; ii<SC_PKCS15_MAX_ACCESS_RULES; ii++)\n\t\tsc_copy_asn1_entry(c_asn1_access_control_rule, asn1_ac_rule[ii]);\n\tsc_copy_asn1_entry(c_asn1_access_control_rules, asn1_ac_rules);\n\n\n\tsc_copy_asn1_entry(c_asn1_com_obj_attr, asn1_c_attr);\n\tsc_copy_asn1_entry(c_asn1_p15_obj, asn1_p15_obj);\n\tsc_format_asn1_entry(asn1_c_attr + 0, p15_obj->label, &label_len, 0);\n\tsc_format_asn1_entry(asn1_c_attr + 1, &p15_obj->flags, &flags_len, 0);\n\tsc_format_asn1_entry(asn1_c_attr + 2, &p15_obj->auth_id, NULL, 0);\n\tsc_format_asn1_entry(asn1_c_attr + 3, &p15_obj->user_consent, NULL, 0);\n\n\tfor (ii=0; ii<SC_PKCS15_MAX_ACCESS_RULES; ii++)   {\n\t\tsc_format_asn1_entry(asn1_ac_rule[ii] + 0, &p15_obj->access_rules[ii].access_mode, &access_mode_len, 0);\n\t\tsc_format_asn1_entry(asn1_ac_rule[ii] + 1, &p15_obj->access_rules[ii].auth_id, NULL, 0);\n\t\tsc_format_asn1_entry(asn1_ac_rules + ii, asn1_ac_rule[ii], NULL, 0);\n\t}\n\tsc_format_asn1_entry(asn1_c_attr + 4, asn1_ac_rules, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_p15_obj + 0, asn1_c_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_p15_obj + 1, obj->asn1_class_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_p15_obj + 2, obj->asn1_subclass_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_p15_obj + 3, obj->asn1_type_attr, NULL, 0);\n\n\tr = asn1_decode(ctx, asn1_p15_obj, in, len, NULL, NULL, 0, depth + 1);\n\treturn r;\n}\n\nstatic int asn1_encode_p15_object(sc_context_t *ctx, const struct sc_asn1_pkcs15_object *obj,\n\t\t\t\t  u8 **buf, size_t *bufsize, int depth)\n{\n\tstruct sc_pkcs15_object p15_obj = *obj->p15_obj;\n\tstruct sc_asn1_entry    asn1_c_attr[6], asn1_p15_obj[5];\n\tstruct sc_asn1_entry asn1_ac_rules[SC_PKCS15_MAX_ACCESS_RULES + 1], asn1_ac_rule[SC_PKCS15_MAX_ACCESS_RULES][3];\n\tsize_t label_len = strlen(p15_obj.label);\n\tsize_t flags_len;\n\tsize_t access_mode_len;\n\tint r, ii;\n\n\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"encode p15 obj(type:0x%X,access_mode:0x%X)\", p15_obj.type, p15_obj.access_rules[0].access_mode);\n\tif (p15_obj.access_rules[0].access_mode)   {\n\t\tfor (ii=0; ii<SC_PKCS15_MAX_ACCESS_RULES; ii++)   {\n\t\t\tsc_copy_asn1_entry(c_asn1_access_control_rule, asn1_ac_rule[ii]);\n\t\t\tif (p15_obj.access_rules[ii].auth_id.len == 0)   {\n\t\t\t\tasn1_ac_rule[ii][1].type = SC_ASN1_NULL;\n\t\t\t\tasn1_ac_rule[ii][1].tag = SC_ASN1_TAG_NULL;\n\t\t\t}\n\t\t}\n\t\tsc_copy_asn1_entry(c_asn1_access_control_rules, asn1_ac_rules);\n\t}\n\n\tsc_copy_asn1_entry(c_asn1_com_obj_attr, asn1_c_attr);\n\tsc_copy_asn1_entry(c_asn1_p15_obj, asn1_p15_obj);\n\tif (label_len != 0)\n\t\tsc_format_asn1_entry(asn1_c_attr + 0, (void *) p15_obj.label, &label_len, 1);\n\tif (p15_obj.flags) {\n\t\tflags_len = sizeof(p15_obj.flags);\n\t\tsc_format_asn1_entry(asn1_c_attr + 1, (void *) &p15_obj.flags, &flags_len, 1);\n\t}\n\tif (p15_obj.auth_id.len)\n\t\tsc_format_asn1_entry(asn1_c_attr + 2, (void *) &p15_obj.auth_id, NULL, 1);\n\tif (p15_obj.user_consent)\n\t\tsc_format_asn1_entry(asn1_c_attr + 3, (void *) &p15_obj.user_consent, NULL, 1);\n\n\tif (p15_obj.access_rules[0].access_mode)   {\n\t\tfor (ii=0; p15_obj.access_rules[ii].access_mode; ii++)   {\n\t\t\taccess_mode_len = sizeof(p15_obj.access_rules[ii].access_mode);\n\t\t\tsc_format_asn1_entry(asn1_ac_rule[ii] + 0, (void *) &p15_obj.access_rules[ii].access_mode, &access_mode_len, 1);\n\t\t\tsc_format_asn1_entry(asn1_ac_rule[ii] + 1, (void *) &p15_obj.access_rules[ii].auth_id, NULL, 1);\n\t\t\tsc_format_asn1_entry(asn1_ac_rules + ii, asn1_ac_rule[ii], NULL, 1);\n\t\t}\n\t\tsc_format_asn1_entry(asn1_c_attr + 4, asn1_ac_rules, NULL, 1);\n\t}\n\n\tsc_format_asn1_entry(asn1_p15_obj + 0, asn1_c_attr, NULL, 1);\n\tsc_format_asn1_entry(asn1_p15_obj + 1, obj->asn1_class_attr, NULL, 1);\n\tif (obj->asn1_subclass_attr != NULL && obj->asn1_subclass_attr->name)\n\t\tsc_format_asn1_entry(asn1_p15_obj + 2, obj->asn1_subclass_attr, NULL, 1);\n\tsc_format_asn1_entry(asn1_p15_obj + 3, obj->asn1_type_attr, NULL, 1);\n\n\tr = asn1_encode(ctx, asn1_p15_obj, buf, bufsize, depth + 1);\n\treturn r;\n}\n\nstatic int asn1_decode_entry(sc_context_t *ctx,struct sc_asn1_entry *entry,\n\t\t\t     const u8 *obj, size_t objlen, int depth)\n{\n\tvoid *parm = entry->parm;\n\tint (*callback_func)(sc_context_t *nctx, void *arg, const u8 *nobj,\n\t\t\t     size_t nobjlen, int ndepth);\n\tsize_t *len = (size_t *) entry->arg;\n\tint r = 0;\n\n\tcallback_func = parm;\n\n\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"%*.*sdecoding '%s', raw data:%s%s\\n\",\n\t\tdepth, depth, \"\", entry->name,\n\t\tsc_dump_hex(obj, objlen > 16  ? 16 : objlen),\n\t\tobjlen > 16 ? \"...\" : \"\");\n\n\tswitch (entry->type) {\n\tcase SC_ASN1_STRUCT:\n\t\tif (parm != NULL)\n\t\t\tr = asn1_decode(ctx, (struct sc_asn1_entry *) parm, obj,\n\t\t\t\t       objlen, NULL, NULL, 0, depth + 1);\n\t\tbreak;\n\tcase SC_ASN1_NULL:\n\t\tbreak;\n\tcase SC_ASN1_BOOLEAN:\n\t\tif (parm != NULL) {\n\t\t\tif (objlen != 1) {\n\t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1,\n\t\t\t\t\t \"invalid ASN.1 object length: %\"SC_FORMAT_LEN_SIZE_T\"u\\n\",\n\t\t\t\t\t objlen);\n\t\t\t\tr = SC_ERROR_INVALID_ASN1_OBJECT;\n\t\t\t} else\n\t\t\t\t*((int *) parm) = obj[0] ? 1 : 0;\n\t\t}\n\t\tbreak;\n\tcase SC_ASN1_INTEGER:\n\tcase SC_ASN1_ENUMERATED:\n\t\tif (parm != NULL) {\n\t\t\tr = sc_asn1_decode_integer(obj, objlen, (int *) entry->parm);\n\t\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"%*.*sdecoding '%s' returned %d\\n\", depth, depth, \"\",\n\t\t\t\t\tentry->name, *((int *) entry->parm));\n\t\t}\n\t\tbreak;\n\tcase SC_ASN1_BIT_STRING_NI:\n\tcase SC_ASN1_BIT_STRING:\n\t\tif (parm != NULL) {\n\t\t\tint invert = entry->type == SC_ASN1_BIT_STRING ? 1 : 0;\n\t\t\tassert(len != NULL);\n\t\t\tif (objlen < 1) {\n\t\t\t\tr = SC_ERROR_INVALID_ASN1_OBJECT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (entry->flags & SC_ASN1_ALLOC) {\n\t\t\t\tu8 **buf = (u8 **) parm;\n\t\t\t\t*buf = malloc(objlen-1);\n\t\t\t\tif (*buf == NULL) {\n\t\t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*len = objlen-1;\n\t\t\t\tparm = *buf;\n\t\t\t}\n\t\t\tr = decode_bit_string(obj, objlen, (u8 *) parm, *len, invert);\n\t\t\tif (r >= 0) {\n\t\t\t\t*len = r;\n\t\t\t\tr = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SC_ASN1_BIT_FIELD:\n\t\tif (parm != NULL)\n\t\t\tr = decode_bit_field(obj, objlen, (u8 *) parm, *len);\n\t\tbreak;\n\tcase SC_ASN1_OCTET_STRING:\n\t\tif (parm != NULL) {\n\t\t\tsize_t c;\n\t\t\tassert(len != NULL);\n\n\t\t\t/* Strip off padding zero */\n\t\t\tif ((entry->flags & SC_ASN1_UNSIGNED)\n\t\t\t\t\t&& objlen > 1 && obj[0] == 0x00) {\n\t\t\t\tobjlen--;\n\t\t\t\tobj++;\n\t\t\t}\n\n\t\t\t/* Allocate buffer if needed */\n\t\t\tif (entry->flags & SC_ASN1_ALLOC) {\n\t\t\t\tu8 **buf = (u8 **) parm;\n\t\t\t\t*buf = malloc(objlen);\n\t\t\t\tif (*buf == NULL) {\n\t\t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tc = *len = objlen;\n\t\t\t\tparm = *buf;\n\t\t\t} else\n\t\t\t\tc = objlen > *len ? *len : objlen;\n\n\t\t\tmemcpy(parm, obj, c);\n\t\t\t*len = c;\n\t\t}\n\t\tbreak;\n\tcase SC_ASN1_GENERALIZEDTIME:\n\t\tif (parm != NULL) {\n\t\t\tsize_t c;\n\t\t\tassert(len != NULL);\n\t\t\tif (entry->flags & SC_ASN1_ALLOC) {\n\t\t\t\tu8 **buf = (u8 **) parm;\n\t\t\t\t*buf = malloc(objlen);\n\t\t\t\tif (*buf == NULL) {\n\t\t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tc = *len = objlen;\n\t\t\t\tparm = *buf;\n\t\t\t} else\n\t\t\t\tc = objlen > *len ? *len : objlen;\n\n\t\t\tmemcpy(parm, obj, c);\n\t\t\t*len = c;\n\t\t}\n\t\tbreak;\n\tcase SC_ASN1_OBJECT:\n\t\tif (parm != NULL)\n\t\t\tr = sc_asn1_decode_object_id(obj, objlen, (struct sc_object_id *) parm);\n\t\tbreak;\n\tcase SC_ASN1_PRINTABLESTRING:\n\tcase SC_ASN1_UTF8STRING:\n\t\tif (parm != NULL) {\n\t\t\tassert(len != NULL);\n\t\t\tif (entry->flags & SC_ASN1_ALLOC) {\n\t\t\t\tu8 **buf = (u8 **) parm;\n\t\t\t\t*buf = malloc(objlen+1);\n\t\t\t\tif (*buf == NULL) {\n\t\t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*len = objlen+1;\n\t\t\t\tparm = *buf;\n\t\t\t}\n\t\t\tr = sc_asn1_decode_utf8string(obj, objlen, (u8 *) parm, len);\n\t\t\tif (entry->flags & SC_ASN1_ALLOC) {\n\t\t\t\t*len -= 1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SC_ASN1_PATH:\n\t\tif (entry->parm != NULL)\n\t\t\tr = asn1_decode_path(ctx, obj, objlen, (sc_path_t *) parm, depth);\n\t\tbreak;\n\tcase SC_ASN1_PKCS15_ID:\n\t\tif (entry->parm != NULL) {\n\t\t\tstruct sc_pkcs15_id *id = (struct sc_pkcs15_id *) parm;\n\t\t\tsize_t c = objlen > sizeof(id->value) ? sizeof(id->value) : objlen;\n\n\t\t\tmemcpy(id->value, obj, c);\n\t\t\tid->len = c;\n\t\t}\n\t\tbreak;\n\tcase SC_ASN1_PKCS15_OBJECT:\n\t\tif (entry->parm != NULL)\n\t\t\tr = asn1_decode_p15_object(ctx, obj, objlen, (struct sc_asn1_pkcs15_object *) parm, depth);\n\t\tbreak;\n\tcase SC_ASN1_ALGORITHM_ID:\n\t\tif (entry->parm != NULL)\n\t\t\tr = sc_asn1_decode_algorithm_id(ctx, obj, objlen, (struct sc_algorithm_id *) parm, depth);\n\t\tbreak;\n\tcase SC_ASN1_SE_INFO:\n\t\tif (entry->parm != NULL)\n\t\t\tr = asn1_decode_se_info(ctx, obj, objlen, (sc_pkcs15_sec_env_info_t ***)entry->parm, len, depth);\n\t\tbreak;\n\tcase SC_ASN1_CALLBACK:\n\t\tif (entry->parm != NULL)\n\t\t\tr = callback_func(ctx, entry->arg, obj, objlen, depth);\n\t\tbreak;\n\tdefault:\n\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"invalid ASN.1 type: %d\\n\", entry->type);\n\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\t}\n\tif (r) {\n\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"decoding of ASN.1 object '%s' failed: %s\\n\", entry->name,\n\t\t      sc_strerror(r));\n\t\treturn r;\n\t}\n\tentry->flags |= SC_ASN1_PRESENT;\n\treturn 0;\n}\n\nstatic int asn1_decode(sc_context_t *ctx, struct sc_asn1_entry *asn1,\n\t\t       const u8 *in, size_t len, const u8 **newp, size_t *len_left,\n\t\t       int choice, int depth)\n{\n\tint r, idx = 0;\n\tconst u8 *p = in, *obj;\n\tstruct sc_asn1_entry *entry = asn1;\n\tsize_t left = len, objlen;\n\n\tsc_debug(ctx, SC_LOG_DEBUG_ASN1,\n\t\t \"%*.*scalled, left=%\"SC_FORMAT_LEN_SIZE_T\"u, depth %d%s\\n\",\n\t\t depth, depth, \"\", left, depth, choice ? \", choice\" : \"\");\n\n\tif (!p)\n\t\treturn SC_ERROR_ASN1_OBJECT_NOT_FOUND;\n\tif (left < 2) {\n\t\twhile (asn1->name && (asn1->flags & SC_ASN1_OPTIONAL))\n\t\t\tasn1++;\n\t\t/* If all elements were optional, there's nothing\n\t\t * to complain about */\n\t\tif (asn1->name == NULL)\n\t\t\treturn 0;\n\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"End of ASN.1 stream, \"\n\t\t\t      \"non-optional field \\\"%s\\\" not found\\n\",\n\t\t\t      asn1->name);\n\t\treturn SC_ERROR_ASN1_OBJECT_NOT_FOUND;\n\t}\n\tif (p[0] == 0 || p[0] == 0xFF || len == 0)\n\t\treturn SC_ERROR_ASN1_END_OF_CONTENTS;\n\n\tfor (idx = 0; asn1[idx].name != NULL; idx++) {\n\t\tentry = &asn1[idx];\n\n\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"Looking for '%s', tag 0x%x%s%s\\n\",\n\t\t\tentry->name, entry->tag, choice? \", CHOICE\" : \"\",\n\t\t\t(entry->flags & SC_ASN1_OPTIONAL)? \", OPTIONAL\": \"\");\n\n\t\t/* Special case CHOICE has no tag */\n\t\tif (entry->type == SC_ASN1_CHOICE) {\n\t\t\tr = asn1_decode(ctx,\n\t\t\t\t(struct sc_asn1_entry *) entry->parm,\n\t\t\t\tp, left, &p, &left, 1, depth + 1);\n\t\t\tif (r >= 0)\n\t\t\t\tr = 0;\n\t\t\tgoto decode_ok;\n\t\t}\n\n\t\tobj = sc_asn1_skip_tag(ctx, &p, &left, entry->tag, &objlen);\n\t\tif (obj == NULL) {\n\t\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"'%s' not present\\n\", entry->name);\n\t\t\tif (choice)\n\t\t\t\tcontinue;\n\t\t\tif (entry->flags & SC_ASN1_OPTIONAL)\n\t\t\t\tcontinue;\n\t\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"mandatory ASN.1 object '%s' not found\\n\", entry->name);\n\t\t\tif (left) {\n\t\t\t\tu8 line[128], *linep = line;\n\t\t\t\tsize_t i;\n\n\t\t\t\tline[0] = 0;\n\t\t\t\tfor (i = 0; i < 10 && i < left; i++) {\n\t\t\t\t\tsprintf((char *) linep, \"%02X \", p[i]);\n\t\t\t\t\tlinep += 3;\n\t\t\t\t}\n\t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"next tag: %s\\n\", line);\n\t\t\t}\n\t\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_ASN1, SC_ERROR_ASN1_OBJECT_NOT_FOUND);\n\t\t}\n\t\tr = asn1_decode_entry(ctx, entry, obj, objlen, depth);\n\ndecode_ok:\n\t\tif (r)\n\t\t\treturn r;\n\t\tif (choice)\n\t\t\tbreak;\n \t}\n \tif (choice && asn1[idx].name == NULL) /* No match */\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_ASN1, SC_ERROR_ASN1_OBJECT_NOT_FOUND);\n \tif (newp != NULL)\n\t\t*newp = p;\n \tif (len_left != NULL)\n\t\t*len_left = left;\n\tif (choice)\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_ASN1, idx);\n\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_ASN1, 0);\n}\n\nint sc_asn1_decode(sc_context_t *ctx, struct sc_asn1_entry *asn1,\n\t\t   const u8 *in, size_t len, const u8 **newp, size_t *len_left)\n{\n\treturn asn1_decode(ctx, asn1, in, len, newp, len_left, 0, 0);\n}\n\nint sc_asn1_decode_choice(sc_context_t *ctx, struct sc_asn1_entry *asn1,\n\t\t\t  const u8 *in, size_t len, const u8 **newp, size_t *len_left)\n{\n\treturn asn1_decode(ctx, asn1, in, len, newp, len_left, 1, 0);\n}\n\nstatic int asn1_encode_entry(sc_context_t *ctx, const struct sc_asn1_entry *entry,\n\t\t\t     u8 **obj, size_t *objlen, int depth)\n{\n\tvoid *parm = entry->parm;\n\tint (*callback_func)(sc_context_t *nctx, void *arg, u8 **nobj,\n\t\t\t     size_t *nobjlen, int ndepth);\n\tconst size_t *len = (const size_t *) entry->arg;\n\tint r = 0;\n\tu8 * buf = NULL;\n\tsize_t buflen = 0;\n\n\tcallback_func = parm;\n\n\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"%*.*sencoding '%s'%s\\n\",\n\t       \tdepth, depth, \"\", entry->name,\n\t\t(entry->flags & SC_ASN1_PRESENT)? \"\" : \" (not present)\");\n\tif (!(entry->flags & SC_ASN1_PRESENT))\n\t\tgoto no_object;\n\tsc_debug(ctx, SC_LOG_DEBUG_ASN1,\n\t\t \"%*.*stype=%d, tag=0x%02x, parm=%p, len=%\"SC_FORMAT_LEN_SIZE_T\"u\\n\",\n\t\t depth, depth, \"\", entry->type, entry->tag, parm,\n\t\t len ? *len : 0);\n\n\tif (entry->type == SC_ASN1_CHOICE) {\n\t\tconst struct sc_asn1_entry *list, *choice = NULL;\n\n\t\tlist = (const struct sc_asn1_entry *) parm;\n\t\twhile (list->name != NULL) {\n\t\t\tif (list->flags & SC_ASN1_PRESENT) {\n\t\t\t\tif (choice) {\n\t\t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1,\n\t\t\t\t\t\t\"ASN.1 problem: more than \"\n\t\t\t\t\t\t\"one CHOICE when encoding %s: \"\n\t\t\t\t\t\t\"%s and %s both present\\n\",\n\t\t\t\t\t\tentry->name,\n\t\t\t\t\t\tchoice->name,\n\t\t\t\t\t\tlist->name);\n\t\t\t\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\t\t\t\t}\n\t\t\t\tchoice = list;\n\t\t\t}\n\t\t\tlist++;\n\t\t}\n\t\tif (choice == NULL)\n\t\t\tgoto no_object;\n\t\treturn asn1_encode_entry(ctx, choice, obj, objlen, depth + 1);\n\t}\n\n\tif (entry->type != SC_ASN1_NULL && parm == NULL) {\n\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"unexpected parm == NULL\\n\");\n\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\t}\n\n\tswitch (entry->type) {\n\tcase SC_ASN1_STRUCT:\n\t\tr = asn1_encode(ctx, (const struct sc_asn1_entry *) parm, &buf,\n\t\t\t\t&buflen, depth + 1);\n\t\tbreak;\n\tcase SC_ASN1_NULL:\n\t\tbuf = NULL;\n\t\tbuflen = 0;\n\t\tbreak;\n\tcase SC_ASN1_BOOLEAN:\n\t\tbuf = malloc(1);\n\t\tif (buf == NULL) {\n\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\tbreak;\n\t\t}\n\t\tbuf[0] = *((int *) parm) ? 0xFF : 0;\n\t\tbuflen = 1;\n\t\tbreak;\n\tcase SC_ASN1_INTEGER:\n\tcase SC_ASN1_ENUMERATED:\n\t\tr = asn1_encode_integer(*((int *) entry->parm), &buf, &buflen);\n\t\tbreak;\n\tcase SC_ASN1_BIT_STRING_NI:\n\tcase SC_ASN1_BIT_STRING:\n\t\tif (len != NULL) {\n\t\t\tif (entry->type == SC_ASN1_BIT_STRING)\n\t\t\t\tr = encode_bit_string((const u8 *) parm, *len, &buf, &buflen, 1);\n\t\t\telse\n\t\t\t\tr = encode_bit_string((const u8 *) parm, *len, &buf, &buflen, 0);\n\t\t} else {\n\t\t\tr = SC_ERROR_INVALID_ARGUMENTS;\n\t\t}\n\t\tbreak;\n\tcase SC_ASN1_BIT_FIELD:\n\t\tif (len != NULL) {\n\t\t\tr = encode_bit_field((const u8 *) parm, *len, &buf, &buflen);\n\t\t} else {\n\t\t\tr = SC_ERROR_INVALID_ARGUMENTS;\n\t\t}\n\t\tbreak;\n\tcase SC_ASN1_PRINTABLESTRING:\n\tcase SC_ASN1_OCTET_STRING:\n\tcase SC_ASN1_UTF8STRING:\n\t\tif (len != NULL) {\n\t\t\tbuf = malloc(*len + 1);\n\t\t\tif (buf == NULL) {\n\t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuflen = 0;\n\t\t\t/* If the integer is supposed to be unsigned, insert\n\t\t\t * a padding byte if the MSB is one */\n\t\t\tif ((entry->flags & SC_ASN1_UNSIGNED)\n\t\t\t\t\t&& (((u8 *) parm)[0] & 0x80)) {\n\t\t\t\tbuf[buflen++] = 0x00;\n\t\t\t}\n\t\t\tmemcpy(buf + buflen, parm, *len);\n\t\t\tbuflen += *len;\n\t\t} else {\n\t\t\tr = SC_ERROR_INVALID_ARGUMENTS;\n\t\t}\n\t\tbreak;\n\tcase SC_ASN1_GENERALIZEDTIME:\n\t\tif (len != NULL) {\n\t\t\tbuf = malloc(*len);\n\t\t\tif (buf == NULL) {\n\t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(buf, parm, *len);\n\t\t\tbuflen = *len;\n\t\t} else {\n\t\t\tr = SC_ERROR_INVALID_ARGUMENTS;\n\t\t}\n\t\tbreak;\n\tcase SC_ASN1_OBJECT:\n\t\tr = sc_asn1_encode_object_id(&buf, &buflen, (struct sc_object_id *) parm);\n\t\tbreak;\n\tcase SC_ASN1_PATH:\n\t\tr = asn1_encode_path(ctx, (const sc_path_t *) parm, &buf, &buflen, depth, entry->flags);\n\t\tbreak;\n\tcase SC_ASN1_PKCS15_ID:\n\t\t{\n\t\t\tconst struct sc_pkcs15_id *id = (const struct sc_pkcs15_id *) parm;\n\n\t\t\tbuf = malloc(id->len);\n\t\t\tif (buf == NULL) {\n\t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(buf, id->value, id->len);\n\t\t\tbuflen = id->len;\n\t\t}\n\t\tbreak;\n\tcase SC_ASN1_PKCS15_OBJECT:\n\t\tr = asn1_encode_p15_object(ctx, (const struct sc_asn1_pkcs15_object *) parm, &buf, &buflen, depth);\n\t\tbreak;\n\tcase SC_ASN1_ALGORITHM_ID:\n\t\tr = sc_asn1_encode_algorithm_id(ctx, &buf, &buflen, (const struct sc_algorithm_id *) parm, depth);\n\t\tbreak;\n\tcase SC_ASN1_SE_INFO:\n\t\tif (!len)\n\t\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\t\tr = asn1_encode_se_info(ctx, (struct sc_pkcs15_sec_env_info **)parm, *len, &buf, &buflen, depth);\n\t\tbreak;\n\tcase SC_ASN1_CALLBACK:\n\t\tr = callback_func(ctx, entry->arg, &buf, &buflen, depth);\n\t\tbreak;\n\tdefault:\n\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"invalid ASN.1 type: %d\\n\", entry->type);\n\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\t}\n\tif (r) {\n\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"encoding of ASN.1 object '%s' failed: %s\\n\", entry->name,\n\t\t      sc_strerror(r));\n\t\tif (buf)\n\t\t\tfree(buf);\n\t\treturn r;\n\t}\n\n\t/* Treatment of OPTIONAL elements:\n\t *  -\tif the encoding has 0 length, and the element is OPTIONAL,\n\t *\twe don't write anything (unless it's an ASN1 NULL and the\n\t *      SC_ASN1_PRESENT flag is set).\n\t *  -\tif the encoding has 0 length, but the element is non-OPTIONAL,\n\t *\tconstructed, we write a empty element (e.g. a SEQUENCE of\n\t *      length 0). In case of an ASN1 NULL just write the tag and\n\t *      length (i.e. 0x05,0x00).\n\t *  -\tany other empty objects are considered bogus\n\t */\nno_object:\n\tif (!buflen && entry->flags & SC_ASN1_OPTIONAL && !(entry->flags & SC_ASN1_PRESENT)) {\n\t\t/* This happens when we try to encode e.g. the\n\t\t * subClassAttributes, which may be empty */\n\t\t*obj = NULL;\n\t\t*objlen = 0;\n\t\tr = 0;\n\t} else if (!buflen && (entry->flags & SC_ASN1_EMPTY_ALLOWED)) {\n\t\t*obj = NULL;\n\t\t*objlen = 0;\n\t\tr = asn1_write_element(ctx, entry->tag, buf, buflen, obj, objlen);\n\t\tif (r)\n\t\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"error writing ASN.1 tag and length: %s\\n\", sc_strerror(r));\n\t} else if (buflen || entry->type == SC_ASN1_NULL || entry->tag & SC_ASN1_CONS) {\n\t\tr = asn1_write_element(ctx, entry->tag, buf, buflen, obj, objlen);\n\t\tif (r)\n\t\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"error writing ASN.1 tag and length: %s\\n\",\n\t\t\t\t\tsc_strerror(r));\n\t} else if (!(entry->flags & SC_ASN1_PRESENT)) {\n\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"cannot encode non-optional ASN.1 object: not given by caller\\n\");\n\t\tr = SC_ERROR_INVALID_ASN1_OBJECT;\n\t} else {\n\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1, \"cannot encode empty non-optional ASN.1 object\\n\");\n\t\tr = SC_ERROR_INVALID_ASN1_OBJECT;\n\t}\n\tif (buf)\n\t\tfree(buf);\n\tif (r >= 0)\n\t\tsc_debug(ctx, SC_LOG_DEBUG_ASN1,\n\t\t\t \"%*.*slength of encoded item=%\"SC_FORMAT_LEN_SIZE_T\"u\\n\",\n\t\t\t depth, depth, \"\", *objlen);\n\treturn r;\n}\n\nstatic int asn1_encode(sc_context_t *ctx, const struct sc_asn1_entry *asn1,\n\t\t      u8 **ptr, size_t *size, int depth)\n{\n\tint r, idx = 0;\n\tu8 *obj = NULL, *buf = NULL, *tmp;\n\tsize_t total = 0, objsize;\n\n\tfor (idx = 0; asn1[idx].name != NULL; idx++) {\n\t\tr = asn1_encode_entry(ctx, &asn1[idx], &obj, &objsize, depth);\n\t\tif (r) {\n\t\t\tif (obj)\n\t\t\t\tfree(obj);\n\t\t\tif (buf)\n\t\t\t\tfree(buf);\n\t\t\treturn r;\n\t\t}\n\t\t/* in case of an empty (optional) element continue with\n\t\t * the next asn1 element */\n\t\tif (!objsize)\n\t\t\tcontinue;\n\t\ttmp = (u8 *) realloc(buf, total + objsize);\n\t\tif (!tmp) {\n\t\t\tif (obj)\n\t\t\t\tfree(obj);\n\t\t\tif (buf)\n\t\t\t\tfree(buf);\n\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\t}\n\t\tbuf = tmp;\n\t\tmemcpy(buf + total, obj, objsize);\n\t\tfree(obj);\n\t\tobj = NULL;\n\t\ttotal += objsize;\n\t}\n\t*ptr = buf;\n\t*size = total;\n\treturn 0;\n}\n\nint sc_asn1_encode(sc_context_t *ctx, const struct sc_asn1_entry *asn1,\n\t\t   u8 **ptr, size_t *size)\n{\n\treturn asn1_encode(ctx, asn1, ptr, size, 0);\n}\n\nint _sc_asn1_encode(sc_context_t *ctx, const struct sc_asn1_entry *asn1,\n\t\t    u8 **ptr, size_t *size, int depth)\n{\n\treturn asn1_encode(ctx, asn1, ptr, size, depth);\n}\n\nint\n_sc_asn1_decode(sc_context_t *ctx, struct sc_asn1_entry *asn1,\n\t\t       const u8 *in, size_t len, const u8 **newp, size_t *left,\n\t\t       int choice, int depth)\n{\n\treturn asn1_decode(ctx, asn1, in, len, newp, left, choice, depth);\n}\n\nint\nsc_der_copy(sc_pkcs15_der_t *dst, const sc_pkcs15_der_t *src)\n{\n\tif (!dst)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tmemset(dst, 0, sizeof(*dst));\n\tif (src->len) {\n\t\tdst->value = malloc(src->len);\n\t\tif (!dst->value)\n\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\tdst->len = src->len;\n\t\tmemcpy(dst->value, src->value, src->len);\n\t}\n\treturn SC_SUCCESS;\n}\n\nint\nsc_encode_oid (struct sc_context *ctx, struct sc_object_id *id,\n\t\tunsigned char **out, size_t *size)\n{\n\tstatic const struct sc_asn1_entry c_asn1_object_id[2] = {\n\t\t{ \"oid\", SC_ASN1_OBJECT, SC_ASN1_TAG_OBJECT, SC_ASN1_ALLOC, NULL, NULL },\n\t\t{ NULL, 0, 0, 0, NULL, NULL }\n\t};\n\tstruct sc_asn1_entry asn1_object_id[2];\n\tint rv;\n\n\tsc_copy_asn1_entry(c_asn1_object_id, asn1_object_id);\n\tsc_format_asn1_entry(asn1_object_id + 0, id, NULL, 1);\n\n\trv = _sc_asn1_encode(ctx, asn1_object_id, out, size, 1);\n\tLOG_TEST_RET(ctx, rv, \"Cannot encode object ID\");\n\n\treturn SC_SUCCESS;\n}\n\n\n#define C_ASN1_SIG_VALUE_SIZE 2\nstatic struct sc_asn1_entry c_asn1_sig_value[C_ASN1_SIG_VALUE_SIZE] = {\n\t\t{ \"ECDSA-Sig-Value\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, 0, NULL, NULL },\n\t\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_SIG_VALUE_COEFFICIENTS_SIZE 3\nstatic struct sc_asn1_entry c_asn1_sig_value_coefficients[C_ASN1_SIG_VALUE_COEFFICIENTS_SIZE] = {\n\t\t{ \"r\", SC_ASN1_OCTET_STRING, SC_ASN1_TAG_INTEGER, SC_ASN1_ALLOC|SC_ASN1_UNSIGNED, NULL, NULL },\n\t\t{ \"s\", SC_ASN1_OCTET_STRING, SC_ASN1_TAG_INTEGER, SC_ASN1_ALLOC|SC_ASN1_UNSIGNED, NULL, NULL },\n\t\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n\nint\nsc_asn1_sig_value_rs_to_sequence(struct sc_context *ctx, unsigned char *in, size_t inlen,\n\t\tunsigned char **buf, size_t *buflen)\n{\n\tstruct sc_asn1_entry asn1_sig_value[C_ASN1_SIG_VALUE_SIZE];\n\tstruct sc_asn1_entry asn1_sig_value_coefficients[C_ASN1_SIG_VALUE_COEFFICIENTS_SIZE];\n\tunsigned char *r = in, *s = in + inlen/2;\n\tsize_t r_len = inlen/2, s_len = inlen/2;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\t/* R/S are filled up with zeroes, we do not want that in sequence format */\n\twhile(r_len > 1 && *r == 0x00) {\n\t\tr++;\n\t\tr_len--;\n\t}\n\twhile(s_len > 1 && *s == 0x00) {\n\t\ts++;\n\t\ts_len--;\n\t}\n\n\tsc_copy_asn1_entry(c_asn1_sig_value, asn1_sig_value);\n\tsc_format_asn1_entry(asn1_sig_value + 0, asn1_sig_value_coefficients, NULL, 1);\n\n\tsc_copy_asn1_entry(c_asn1_sig_value_coefficients, asn1_sig_value_coefficients);\n\tsc_format_asn1_entry(asn1_sig_value_coefficients + 0, r, &r_len, 1);\n\tsc_format_asn1_entry(asn1_sig_value_coefficients + 1, s, &s_len, 1);\n\n\trv = sc_asn1_encode(ctx, asn1_sig_value, buf, buflen);\n\tLOG_TEST_RET(ctx, rv, \"ASN.1 encoding ECDSA-SIg-Value failed\");\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\n\nint\nsc_asn1_sig_value_sequence_to_rs(struct sc_context *ctx, const unsigned char *in, size_t inlen,\n\t\tunsigned char *buf, size_t buflen)\n{\n\tstruct sc_asn1_entry asn1_sig_value[C_ASN1_SIG_VALUE_SIZE];\n\tstruct sc_asn1_entry asn1_sig_value_coefficients[C_ASN1_SIG_VALUE_COEFFICIENTS_SIZE];\n\tunsigned char *r = NULL, *s = NULL;\n\tsize_t r_len, s_len, halflen = buflen/2;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!buf || !buflen)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\tsc_copy_asn1_entry(c_asn1_sig_value, asn1_sig_value);\n\tsc_format_asn1_entry(asn1_sig_value + 0, asn1_sig_value_coefficients, NULL, 0);\n\n\tsc_copy_asn1_entry(c_asn1_sig_value_coefficients, asn1_sig_value_coefficients);\n\tsc_format_asn1_entry(asn1_sig_value_coefficients + 0, &r, &r_len, 0);\n\tsc_format_asn1_entry(asn1_sig_value_coefficients + 1, &s, &s_len, 0);\n\n\trv = sc_asn1_decode(ctx, asn1_sig_value, in, inlen, NULL, NULL);\n\tLOG_TEST_GOTO_ERR(ctx, rv, \"ASN.1 decoding ECDSA-Sig-Value failed\");\n\n\tif (halflen < r_len || halflen < s_len)   {\n\t\trv = SC_ERROR_BUFFER_TOO_SMALL;\n\t\tgoto err;\n\t}\n\n\tmemset(buf, 0, buflen);\n\tmemcpy(buf + (halflen - r_len), r, r_len);\n\tmemcpy(buf + (buflen - s_len), s, s_len);\n\n\tsc_log(ctx, \"r(%\"SC_FORMAT_LEN_SIZE_T\"u): %s\", halflen,\n\t       sc_dump_hex(buf, halflen));\n\tsc_log(ctx, \"s(%\"SC_FORMAT_LEN_SIZE_T\"u): %s\", halflen,\n\t       sc_dump_hex(buf + halflen, halflen));\n\n\trv = SC_SUCCESS;\nerr:\n\tfree(r);\n\tfree(s);\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n"], "filenames": ["src/libopensc/asn1.c"], "buggy_code_start_loc": [1472], "buggy_code_end_loc": [1473], "fixing_code_start_loc": [1472], "fixing_code_end_loc": [1473], "type": "CWE-119", "message": "OpenSC before 0.20.0-rc1 has an out-of-bounds access of an ASN.1 Octet string in asn1_decode_entry in libopensc/asn1.c.", "other": {"cve": {"id": "CVE-2019-15946", "sourceIdentifier": "cve@mitre.org", "published": "2019-09-05T17:15:12.047", "lastModified": "2021-11-30T22:14:16.190", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OpenSC before 0.20.0-rc1 has an out-of-bounds access of an ASN.1 Octet string in asn1_decode_entry in libopensc/asn1.c."}, {"lang": "es", "value": "OpenSC en versiones anteriores a la 0.20.0-rc1 tiene un acceso fuera de los l\u00edmites de Octet string ASN.1 en asn1_decode_entry en libopensc/asn1.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:P/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "PHYSICAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.5, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensc_project:opensc:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.19.0", "matchCriteriaId": "1BBAA136-529C-41AB-8A74-D4BABD9B00ED"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2019/12/29/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/OpenSC/OpenSC/commit/a3fc7693f3a035a8a7921cffb98432944bb42740", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/OpenSC/OpenSC/compare/f1691fc...12218d4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/09/msg00009.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/11/msg00027.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/NDSQLMZZYBHO5X3BK7D6E7E6NZIMZDI5/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/OpenSC/OpenSC/commit/a3fc7693f3a035a8a7921cffb98432944bb42740"}}