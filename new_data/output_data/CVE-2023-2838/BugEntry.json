{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2017-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / filters sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terfsess of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include \"filter_session.h\"\n#include <gpac/network.h>\n\n#ifndef GPAC_DISABLE_3D\n#include <gpac/modules/video_out.h>\n#endif\n\n//#define CHECK_TASK_LIST_INTEGRITY\n\n#ifndef GPAC_DISABLE_FONTS\nstruct _gf_ft_mgr *gf_font_manager_new();\nvoid gf_font_manager_del(struct _gf_ft_mgr *fm);\n#endif\n\nstatic GFINLINE void gf_fs_sema_io(GF_FilterSession *fsess, Bool notify, Bool main)\n{\n\t//we don't use sema on emscripten, we always give control back to main caller or pthread\n#ifndef GPAC_CONFIG_EMSCRIPTEN\n\tGF_Semaphore *sem = main ? fsess->semaphore_main : fsess->semaphore_other;\n\tif (sem) {\n\t\tif (notify) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u notify scheduler %s semaphore\\n\", gf_th_id(), main ? \"main\" : \"secondary\"));\n\t\t\tif ( ! gf_sema_notify(sem, 1)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCHEDULER, (\"Cannot notify scheduler of new task, semaphore failure\\n\"));\n\t\t\t}\n\t\t} else {\n\t\t\tu32 nb_tasks;\n\t\t\t//if not main and no tasks in main list, this could be the last task to process.\n\t\t\t//if main thread is sleeping force a wake to take further actions (only the main thread decides the exit)\n\t\t\t//this also ensures that the main thread will process tasks from secondary task lists if no\n\t\t\t//dedicated main thread tasks are present (eg no GL filters)\n\t\t\tif (!main && fsess->in_main_sem_wait && !gf_fq_count(fsess->main_thread_tasks)) {\n\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_TRUE);\n\t\t\t}\n\t\t\tnb_tasks = 1;\n\t\t\t//no active threads, count number of tasks. If no posted tasks we are likely at the end of the session, don't block, rather use a sem_wait \n\t\t\tif (!fsess->active_threads)\n\t\t\t \tnb_tasks = gf_fq_count(fsess->main_thread_tasks) + gf_fq_count(fsess->tasks);\n\n\t\t\t//if main semaphore, keep track that we are going to sleep\n\t\t\tif (main) {\n\t\t\t\tfsess->in_main_sem_wait = GF_TRUE;\n\t\t\t\tif (!nb_tasks) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"No tasks scheduled, waiting on main semaphore for at most 100 ms\\n\"));\n\t\t\t\t\tif (gf_sema_wait_for(sem, 100)) {\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (gf_sema_wait(sem)) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfsess->in_main_sem_wait = GF_FALSE;\n\t\t\t} else {\n\t\t\t\tif (!nb_tasks) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"No tasks scheduled, waiting on secondary semaphore for at most 100 ms\\n\"));\n\t\t\t\t\tif (gf_sema_wait_for(sem, 100)) {\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (gf_sema_wait(sem)) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif // GPAC_CONFIG_EMSCRIPTEN\n}\n\n\nGF_EXPORT\nvoid gf_fs_add_filter_register(GF_FilterSession *fsess, const GF_FilterRegister *freg)\n{\n\tif (!freg) return;\n\tif (!fsess) {\n\t\tif (freg->register_free) freg->register_free(fsess, (GF_FilterRegister *)freg);\n\t\treturn;\n\t}\n\n\tif (!freg->name) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Filter missing name - ignoring\\n\"));\n\t\tif (freg->register_free) freg->register_free(fsess, (GF_FilterRegister *)freg);\n\t\treturn;\n\t}\n#if 0\n\tif (strchr(freg->name, fsess->sep_args)\t) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Filter name cannot contain argument separator %c - ignoring\\n\", fsess->sep_args));\n\t\tif (freg->register_free) freg->register_free(fsess, (GF_FilterRegister *)freg);\n\t\treturn;\n\t}\n\tif (strchr(freg->name, fsess->sep_name)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Filter name cannot contain argument value separator %c - ignoring\\n\", fsess->sep_name));\n\t\tif (freg->register_free) freg->register_free(fsess, (GF_FilterRegister *)freg);\n\t\treturn;\n\t}\n#endif\n\tif (!freg->process) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Filter %s missing process function - ignoring\\n\", freg->name));\n\t\tif (freg->register_free) freg->register_free(fsess, (GF_FilterRegister *)freg);\n\t\treturn;\n\t}\n\n\t//except for meta filters, don't accept a filter with input caps but no output caps\n\t//meta filters do follow the same rule, however when expanding them for help we may have weird cases\n\t//where no config is set but inputs are listed to expose mime types or extensions (cf ffdmx)\n\tif (!(freg->flags & GF_FS_REG_META)\n\t\t&& !freg->configure_pid\n\t\t&& gf_filter_has_in_caps(freg->caps, freg->nb_caps)\n\t) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Filter %s missing configure_pid function but has input capabilities - ignoring\\n\", freg->name));\n\t\tif (freg->register_free) freg->register_free(fsess, (GF_FilterRegister *)freg);\n\t\treturn;\n\t}\n\n\tgf_mx_p(fsess->filters_mx);\n\tgf_list_add(fsess->registry, (void *) freg);\n\tgf_mx_v(fsess->filters_mx);\n\n\tif (fsess->init_done && fsess->links && gf_list_count( fsess->links)) {\n\t\tgf_filter_sess_build_graph(fsess, freg);\n\t}\n}\n\nstatic Bool fs_default_event_proc(void *ptr, GF_Event *evt)\n{\n\tGF_FilterSession *fs = (GF_FilterSession *)ptr;\n\tif (evt->type==GF_EVENT_QUIT) {\n\t\tgf_fs_abort(fs, (evt->message.error) ? GF_FS_FLUSH_NONE : GF_FS_FLUSH_FAST);\n\t}\n\tif (evt->type==GF_EVENT_MESSAGE) {\n\t\tif (evt->message.error) {\n\t\t\tif (evt->message.service) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"Service %s %s: %s\\n\", evt->message.service, evt->message.message, gf_error_to_string(evt->message.error) ))\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"%s: %s\\n\", evt->message.message, gf_error_to_string(evt->message.error) ))\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef GPAC_HAS_QJS\n\tif (fs->on_evt_task && jsfs_on_event(fs, evt))\n\t\treturn GF_TRUE;\n#endif\n\n\tif (evt->type==GF_EVENT_AUTHORIZATION) {\n#ifdef GPAC_HAS_QJS\n\t\tif (fs->on_auth_task && jsfs_on_auth(fs, evt))\n\t\t\treturn GF_TRUE;\n#endif\n\n\t\tif (gf_sys_is_test_mode()) {\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tassert( evt->type == GF_EVENT_AUTHORIZATION);\n\t\tassert( evt->auth.user);\n\t\tassert( evt->auth.password);\n\t\tassert( evt->auth.site_url);\n\n\t\tfprintf(stderr, \"**** Authorization required for site %s %s ****\\n\", evt->auth.site_url, evt->auth.secure ? \"(secure)\" : \"- NOT SECURE\");\n\t\tfprintf(stderr, \"login   : \");\n\t\tif (!gf_read_line_input(evt->auth.user, 50, 1))\n\t\t\treturn GF_FALSE;\n\t\tfprintf(stderr, \"\\npassword: \");\n\t\tif (!gf_read_line_input(evt->auth.password, 50, 0))\n\t\t\treturn GF_FALSE;\n\t\tfprintf(stderr, \"*********\\n\");\n\n\t\tif (evt->auth.on_usr_pass) {\n\t\t\tevt->auth.on_usr_pass(evt->auth.async_usr_data, evt->auth.user, evt->auth.password, GF_FALSE);\n\t\t\tevt->auth.password[0] = 0;\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\n\treturn GF_FALSE;\n}\n\n\n#ifdef GF_FS_ENABLE_LOCALES\nstatic Bool fs_check_locales(void *__self, const char *locales_parent_path, const char *rel_path, char *relocated_path, char *localized_rel_path);\n#endif\n\n#ifdef __EMSCRIPTEN_PTHREADS__\n#include <emscripten/threading.h>\n#endif\n\nGF_EXPORT\nGF_FilterSession *gf_fs_new(s32 nb_threads, GF_FilterSchedulerType sched_type, u32 flags, const char *blacklist)\n{\n\tconst char *opt;\n\tBool gf_sys_has_filter_global_args();\n\tBool gf_sys_has_filter_global_meta_args();\n\tu32 i;\n\tGF_FilterSession *fsess, *a_sess;\n\n\t//safety check: all built-in properties shall have unique 4CCs\n\tif (gf_sys_is_test_mode() && ! gf_props_4cc_check_props())\n\t\treturn NULL;\n\n\tGF_SAFEALLOC(fsess, GF_FilterSession);\n\tif (!fsess) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Failed to alloc media session\\n\"));\n\t\treturn NULL;\n\t}\n\t//reverse implicit mode flag, we run by default in this mode\n\tif (flags & GF_FS_FLAG_NO_IMPLICIT)\n\t\tflags &= ~GF_FS_FLAG_IMPLICIT_MODE;\n\telse\n\t\tflags |= GF_FS_FLAG_IMPLICIT_MODE;\n\n\tfsess->flags = flags;\n\n\tif (gf_opts_get_bool(\"core\", \"no-mx\"))\n\t\tnb_threads=0;\n\n#ifdef __EMSCRIPTEN_PTHREADS__\n\t//detect if we run as a worker\n\tif (!emscripten_is_main_runtime_thread()) {\n\t\tfsess->is_worker = GF_TRUE;\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Session running in worker mode\\n\"));\n\t}\n#endif\n\n\tfsess->filters = gf_list_new();\n\tfsess->main_th.fsess = fsess;\n\n\tif ((s32) nb_threads == -1) {\n\t\tGF_SystemRTInfo rti;\n\t\tmemset(&rti, 0, sizeof(GF_SystemRTInfo));\n\t\tif (gf_sys_get_rti(0, &rti, 0)) {\n\t\t\tnb_threads = rti.nb_cores-1;\n\t\t}\n\t\tif ((s32)nb_threads<0) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"Failed to query number of cores, disabling extra threads for session\\n\"));\n\t\t\tnb_threads=0;\n\t\t}\n\t}\n\n\tif (sched_type==GF_FS_SCHEDULER_DIRECT) {\n\t\tfsess->direct_mode = GF_TRUE;\n\t\tnb_threads=0;\n\t}\n\tif (nb_threads && (sched_type != GF_FS_SCHEDULER_LOCK_FREE_X)) {\n\t\tfsess->tasks_mx = gf_mx_new(\"TasksList\");\n\t}\n\n\t//regardless of scheduler type, we don't use lock on the main task list\n\tfsess->tasks = gf_fq_new(fsess->tasks_mx);\n\n\tif (nb_threads>0) {\n\t\tfsess->main_thread_tasks = gf_fq_new(fsess->tasks_mx);\n\t\tfsess->filters_mx = gf_mx_new(\"Filters\");\n\t} else {\n\t\t//otherwise use the same as the global task list\n\t\tfsess->main_thread_tasks = fsess->tasks;\n\t}\n\n\tif (!(flags & GF_FS_FLAG_NO_RESERVOIR)) {\n\t\tfsess->tasks_reservoir = gf_fq_new(fsess->tasks_mx);\n\t}\n\n\tif (nb_threads || (sched_type==GF_FS_SCHEDULER_LOCK_FORCE) ) {\n\t\tfsess->semaphore_main = fsess->semaphore_other = gf_sema_new(GF_INT_MAX, 0);\n\t\tif (nb_threads>0)\n\t\t\tfsess->semaphore_other = gf_sema_new(GF_INT_MAX, 0);\n\n\t\t//force testing of mutex queues\n\t\t//fsess->use_locks = GF_TRUE;\n\t}\n\tfsess->ui_event_proc = fs_default_event_proc;\n\tfsess->ui_opaque = fsess;\n\n\tif (flags & GF_FS_FLAG_NON_BLOCKING)\n\t\tfsess->non_blocking = 1;\n\n\tif (!fsess->semaphore_main)\n\t\tnb_threads=0;\n\n#ifndef GPAC_DISABLE_THREADS\n\tif (nb_threads) {\n\t\tfsess->threads = gf_list_new();\n\t\tif (!fsess->threads) {\n\t\t\tgf_sema_del(fsess->semaphore_main);\n\t\t\tfsess->semaphore_main=NULL;\n\t\t\tgf_sema_del(fsess->semaphore_other);\n\t\t\tfsess->semaphore_other=NULL;\n\t\t\tnb_threads=0;\n\t\t}\n\t\tfsess->use_locks = (sched_type==GF_FS_SCHEDULER_LOCK) ? GF_TRUE : GF_FALSE;\n\t} else\n#endif\n\t{\n#ifdef GPAC_MEMORY_TRACKING\n\t\textern int gf_mem_track_enabled;\n\t\tfsess->check_allocs = gf_mem_track_enabled;\n#endif\n\n\t}\n\n\tif (fsess->use_locks)\n\t\tfsess->props_mx = gf_mx_new(\"FilterSessionProps\");\n\n\tif (!(flags & GF_FS_FLAG_NO_RESERVOIR)) {\n#if GF_PROPS_HASHTABLE_SIZE\n\t\tfsess->prop_maps_list_reservoir = gf_fq_new(fsess->props_mx);\n#endif\n\t\tfsess->prop_maps_reservoir = gf_fq_new(fsess->props_mx);\n\t\tfsess->prop_maps_entry_reservoir = gf_fq_new(fsess->props_mx);\n\t\tfsess->prop_maps_entry_data_alloc_reservoir = gf_fq_new(fsess->props_mx);\n\t\t//we also use the props mutex for the this one\n\t\tfsess->pcks_refprops_reservoir = gf_fq_new(fsess->props_mx);\n\t}\n\n\n#ifndef GPAC_DISABLE_REMOTERY\n\tsprintf(fsess->main_th.rmt_name, \"FSThread0\");\n#endif\n\n\tif (!fsess->filters || !fsess->tasks) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Failed to alloc media session\\n\"));\n\t\tfsess->run_status = GF_OUT_OF_MEM;\n\t\tgf_fs_del(fsess);\n\t\treturn NULL;\n\t}\n\n\tif (nb_threads) {\n\t\tfsess->info_mx = gf_mx_new(\"FilterSessionInfo\");\n\t\tfsess->ui_mx = gf_mx_new(\"FilterSessionUIProc\");\n\t}\n\n#ifndef GPAC_DISABLE_THREADS\n\tfor (i=0; i<(u32) nb_threads; i++) {\n\t\tchar szName[30];\n\t\tGF_SessionThread *sess_thread;\n\t\tGF_SAFEALLOC(sess_thread, GF_SessionThread);\n\t\tif (!sess_thread) continue;\n#ifndef GPAC_DISABLE_REMOTERY\n\t\tsprintf(sess_thread->rmt_name, \"FSThread%d\", i+1);\n#endif\n\t\tsprintf(szName, \"gf_fs_th_%d\", i+1);\n\t\tsess_thread->th = gf_th_new(szName);\n\t\tif (!sess_thread->th) {\n\t\t\tgf_free(sess_thread);\n\t\t\tcontinue;\n\t\t}\n\t\tsess_thread->fsess = fsess;\n\t\tgf_list_add(fsess->threads, sess_thread);\n\t}\n#endif\n\n\tgf_fs_set_separators(fsess, NULL);\n\n\tfsess->registry = gf_list_new();\n#ifdef GPAC_HAS_QJS\n\t//keep copy of blacklist for JS\n\tfsess->blacklist = blacklist ? gf_strdup(blacklist) : NULL;\n#else\n\tfsess->blacklist = (char*)blacklist;\n#endif\n\ta_sess = (flags & GF_FS_FLAG_LOAD_META) ? fsess : NULL;\n\tgf_fs_reg_all(fsess, a_sess);\n\n#ifndef GPAC_HAS_QJS\n\tfsess->blacklist = NULL;\n#endif\n\n\t//todo - find a way to handle events without mutex ...\n\tfsess->evt_mx = gf_mx_new(\"Event mutex\");\n\n\tfsess->blocking_mode = GF_FS_BLOCK_ALL;\n\topt = gf_opts_get_key(\"core\", \"no-block\");\n\tif (opt) {\n\t\tif (!strcmp(opt, \"fanout\")) {\n\t\t\tfsess->blocking_mode = GF_FS_NOBLOCK_FANOUT;\n\t\t}\n\t\telse if (!strcmp(opt, \"all\")) {\n\t\t\tfsess->blocking_mode = GF_FS_NOBLOCK;\n\t\t}\n\t}\n\n\tfsess->run_status = GF_EOS;\n\tfsess->nb_threads_stopped = 1+nb_threads;\n\tfsess->default_pid_buffer_max_us = gf_opts_get_int(\"core\", \"buffer-gen\");\n\tfsess->decoder_pid_buffer_max_us = gf_opts_get_int(\"core\", \"buffer-dec\");\n\tfsess->default_pid_buffer_max_units = gf_opts_get_int(\"core\", \"buffer-units\");\n\tfsess->max_resolve_chain_len = 6;\n\tfsess->auto_inc_nums = gf_list_new();\n\n\tif (nb_threads)\n\t\tfsess->links_mx = gf_mx_new(\"FilterRegistryGraph\");\n\tfsess->links = gf_list_new();\n\n#ifndef GPAC_DISABLE_3D\n\tfsess->gl_providers = gf_list_new();\n#endif\n\n\tif (! (fsess->flags & GF_FS_FLAG_NO_GRAPH_CACHE))\n\t\tgf_filter_sess_build_graph(fsess, NULL);\n\n\tfsess->init_done = GF_TRUE;\n\n\t//parse all global filter options for argument tracking\n\tif (gf_sys_has_filter_global_args() || gf_sys_has_filter_global_meta_args()) {\n\t\tu32 nb_args = gf_sys_get_argc();\n\t\tfor (i=0; i<nb_args; i++) {\n\t\t\tchar *arg = (char *)gf_sys_get_arg(i);\n\t\t\tif (arg[0]!='-') continue;\n\t\t\tif ((arg[1]!='-') && (arg[1]!='+')) continue;\n\t\t\tchar *sep = strchr(arg, '=');\n\t\t\tif (sep) sep[0] = 0;\n\t\t\tgf_fs_push_arg(fsess, arg+2, GF_FALSE, (arg[1]=='-') ? GF_ARGTYPE_GLOBAL : GF_ARGTYPE_META, NULL, NULL);\n\n\t\t\t//force indexing in reframers when dash template with bandwidth is used\n\t\t\tif (sep && !strcmp(arg+2, \"template\") && strstr(sep+1, \"$Bandwidth$\")) {\n\t\t\t\tgf_opts_set_key(\"temp\", \"force_indexing\", \"true\");\n\t\t\t}\n\n\t\t\tif (sep) sep[0] = '=';\n\t\t}\n\t}\n\n#ifdef GF_FS_ENABLE_LOCALES\n\tfsess->uri_relocators = gf_list_new();\n\tfsess->locales.relocate_uri = fs_check_locales;\n\tfsess->locales.sess = fsess;\n\tgf_list_add(fsess->uri_relocators, &fsess->locales);\n#endif\n\treturn fsess;\n}\n\nvoid gf_fs_push_arg(GF_FilterSession *session, const char *szArg, Bool was_found, GF_FSArgItemType type, GF_Filter *meta_filter, const char *sub_opt_name)\n{\n\tu32 meta_len = meta_filter ? (u32) strlen(meta_filter->freg->name) : 0;\n\tBool create_if_not_found = GF_TRUE;\n\tif (session->flags & GF_FS_FLAG_NO_ARG_CHECK)\n\t\treturn;\n\n\t//ignore any meta argument reported (found or not) that is not already present\n\t//if sub_opt_name, we must create an entry\n\tif (!sub_opt_name && (type==GF_ARGTYPE_META_REPORTING)) {\n\t\tcreate_if_not_found = GF_FALSE;\n\t}\n\tif (!session->parsed_args) session->parsed_args = gf_list_new();\n\n\tu32 k, acount = gf_list_count(session->parsed_args);\n\tGF_FSArgItem *ai=NULL;\n\tfor (k=0; k<acount; k++) {\n\t\tai = gf_list_get(session->parsed_args, k);\n\t\tif (!strcmp(ai->argname, szArg))\n\t\t\tbreak;\n\n\t\tif (meta_len\n\t\t\t&& !strncmp(ai->argname, meta_filter->freg->name, meta_len)\n\t\t\t&& ((ai->argname[meta_len]==':') || (ai->argname[meta_len]=='@'))\n\t\t\t&& !strcmp(ai->argname+meta_len+1, szArg)\n\t\t) {\n\t\t\tbreak;\n\t\t}\n\t\tai = NULL;\n\t}\n\tif (!ai && create_if_not_found) {\n\t\tGF_SAFEALLOC(ai, GF_FSArgItem);\n\t\tif (ai) {\n\t\t\tai->argname = gf_strdup(szArg);\n\t\t\tai->type = type;\n\t\t\tif ((type==GF_ARGTYPE_META_REPORTING) && meta_filter) {\n\t\t\t\tai->meta_filter = meta_filter->freg->name;\n\t\t\t\tai->meta_opt = sub_opt_name;\n\t\t\t}\n\t\t\tgf_list_add(session->parsed_args, ai );\n\t\t}\n\t}\n\tif (!ai) return;\n\n\tif (type==GF_ARGTYPE_META_REPORTING) {\n\t\t//meta option declared as true by default at init but notified as not found\n\t\tif (ai->meta_state==3) {\n\t\t\tai->meta_state = 0;\n\t\t\tif (!was_found) ai->opt_found = 0;\n\t\t}\n\t\tif (!ai->meta_state) {\n\t\t\tai->opt_found = 0;\n\t\t\tai->meta_state = 1;\n\t\t\tif (!ai->meta_filter) {\n\t\t\t\tai->meta_filter = meta_filter->freg->name;\n\t\t\t\tai->meta_opt = sub_opt_name;\n\t\t\t}\n\t\t}\n\t\tif (was_found)\n\t\t\tai->meta_state = 2;\n\t} else if (was_found && (!ai->meta_state || !meta_filter) ) {\n\t\tai->opt_found = 1;\n\t\t//initial declaration from filter setup: meta args are declared as true by default\n\t\tif (type==GF_ARGTYPE_LOCAL) {\n\t\t\t//forbid further meta state change\n\t\t\tai->meta_state = 1;\n\t\t\t//meta option, mark as not found\n\t\t\tif (meta_filter) ai->meta_state = 3;\n\t\t\telse ai->meta_filter = NULL;\n\t\t}\n\t}\n}\n\n\nGF_EXPORT\nGF_FilterSession *gf_fs_new_defaults(u32 inflags)\n{\n\tGF_FilterSession *fsess;\n\tGF_FilterSchedulerType sched_type = GF_FS_SCHEDULER_LOCK_FREE;\n\tu32 flags = 0;\n\ts32 nb_threads = gf_opts_get_int(\"core\", \"threads\");\n\tconst char *blacklist = gf_opts_get_key(\"core\", \"blacklist\");\n\tconst char *opt = gf_opts_get_key(\"core\", \"sched\");\n\n\tif (!opt) sched_type = GF_FS_SCHEDULER_LOCK_FREE;\n\telse if (!strcmp(opt, \"lock\")) sched_type = GF_FS_SCHEDULER_LOCK;\n\telse if (!strcmp(opt, \"flock\")) sched_type = GF_FS_SCHEDULER_LOCK_FORCE;\n\telse if (!strcmp(opt, \"direct\")) sched_type = GF_FS_SCHEDULER_DIRECT;\n\telse if (!strcmp(opt, \"free\")) sched_type = GF_FS_SCHEDULER_LOCK_FREE;\n\telse if (!strcmp(opt, \"freex\")) sched_type = GF_FS_SCHEDULER_LOCK_FREE_X;\n\telse {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Unrecognized scheduler type %s\\n\", opt));\n\t\treturn NULL;\n\t}\n\tif (inflags & GF_FS_FLAG_LOAD_META)\n\t\tflags |= GF_FS_FLAG_LOAD_META;\n\n\tif (inflags & GF_FS_FLAG_NON_BLOCKING)\n\t\tflags |= GF_FS_FLAG_NON_BLOCKING;\n\n\tif (inflags & GF_FS_FLAG_NO_GRAPH_CACHE)\n\t\tflags |= GF_FS_FLAG_NO_GRAPH_CACHE;\n\n\tif (inflags & GF_FS_FLAG_PRINT_CONNECTIONS)\n\t\tflags |= GF_FS_FLAG_PRINT_CONNECTIONS;\n\n\tif (inflags & GF_FS_FLAG_NO_IMPLICIT)\n\t\tflags |= GF_FS_FLAG_NO_IMPLICIT;\n\n\tif (gf_opts_get_bool(\"core\", \"dbg-edges\"))\n\t\tflags |= GF_FS_FLAG_PRINT_CONNECTIONS;\n\n\tif (gf_opts_get_bool(\"core\", \"full-link\"))\n\t\tflags |= GF_FS_FLAG_FULL_LINK;\n\n\tif (gf_opts_get_bool(\"core\", \"no-reg\"))\n\t\tflags |= GF_FS_FLAG_NO_REGULATION;\n\n\tif (gf_opts_get_bool(\"core\", \"no-reassign\"))\n\t\tflags |= GF_FS_FLAG_NO_REASSIGN;\n\n\tif (gf_opts_get_bool(\"core\", \"no-graph-cache\"))\n\t\tflags |= GF_FS_FLAG_NO_GRAPH_CACHE;\n\n\tif (gf_opts_get_bool(\"core\", \"no-probe\"))\n\t\tflags |= GF_FS_FLAG_NO_PROBE;\n\telse if (inflags & GF_FS_FLAG_NO_PROBE)\n\t\tflags |= GF_FS_FLAG_NO_PROBE;\n\n\tif (gf_opts_get_bool(\"core\", \"no-argchk\"))\n\t\tflags |= GF_FS_FLAG_NO_ARG_CHECK;\n\n\tif (gf_opts_get_bool(\"core\", \"no-reservoir\"))\n\t\tflags |= GF_FS_FLAG_NO_RESERVOIR;\n\n\n\tfsess = gf_fs_new(nb_threads, sched_type, flags, blacklist);\n\tif (!fsess) return NULL;\n\n\tgf_fs_set_max_resolution_chain_length(fsess, gf_opts_get_int(\"core\", \"max-chain\") );\n\n\tgf_fs_set_max_sleep_time(fsess, gf_opts_get_int(\"core\", \"max-sleep\") );\n\n\topt = gf_opts_get_key(\"core\", \"seps\");\n\tif (opt)\n\t\tgf_fs_set_separators(fsess, opt);\n\n\treturn fsess;\n}\n\n\nGF_EXPORT\nGF_Err gf_fs_set_separators(GF_FilterSession *session, const char *separator_set)\n{\n\tif (!session) return GF_BAD_PARAM;\n\tif (separator_set && (strlen(separator_set)<5)) return GF_BAD_PARAM;\n\n\tif (separator_set) {\n\t\tsession->sep_args = separator_set[0];\n\t\tsession->sep_name = separator_set[1];\n\t\tsession->sep_frag = separator_set[2];\n\t\tsession->sep_list = separator_set[3];\n\t\tsession->sep_neg = separator_set[4];\n\t} else {\n\t\tsession->sep_args = ':';\n\t\tsession->sep_name = '=';\n\t\tsession->sep_frag = '#';\n\t\tsession->sep_list = ',';\n\t\tsession->sep_neg = '!';\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_fs_set_max_resolution_chain_length(GF_FilterSession *session, u32 max_chain_length)\n{\n\tif (!session) return GF_BAD_PARAM;\n\tsession->max_resolve_chain_len = max_chain_length;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_fs_set_max_sleep_time(GF_FilterSession *session, u32 max_sleep)\n{\n\tif (!session) return GF_BAD_PARAM;\n\tsession->max_sleep = max_sleep;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu32 gf_fs_get_max_resolution_chain_length(GF_FilterSession *session)\n{\n\tif (!session) return 0;\n\treturn session->max_resolve_chain_len;\n}\n\nGF_EXPORT\nvoid gf_fs_remove_filter_register(GF_FilterSession *session, GF_FilterRegister *freg)\n{\n\tif (!session || !freg) return;\n\n\tgf_mx_p(session->filters_mx);\n\tgf_list_del_item(session->registry, freg);\n\tgf_mx_v(session->filters_mx);\n\tgf_filter_sess_reset_graph(session, freg);\n}\n\nGF_EXPORT\nvoid gf_fs_set_ui_callback(GF_FilterSession *fs, Bool (*ui_event_proc)(void *opaque, GF_Event *event), void *cbk_udta)\n{\n\tif (fs) {\n\t\tfs->ui_event_proc = ui_event_proc;\n\t\tfs->ui_opaque = cbk_udta;\n\t\tif (!fs->ui_event_proc) {\n\t\t\tfs->ui_event_proc = fs_default_event_proc;\n\t\t\tfs->ui_opaque = fs;\n\t\t}\n\t}\n}\n\nvoid gf_propalloc_del(void *it)\n{\n\tGF_PropertyEntry *pe = (GF_PropertyEntry *)it;\n\tif (pe->prop.value.data.ptr) gf_free(pe->prop.value.data.ptr);\n\tgf_free(pe);\n}\n\n\nGF_EXPORT\nBool gf_fs_enum_unmapped_options(GF_FilterSession *fsess, u32 *idx, const char **argname, u32 *argtype, const char **meta_filter, const char **meta_sub_opt)\n{\n\tif (!fsess || !fsess->parsed_args) return GF_FALSE;\n\tu32 i, count = gf_list_count(fsess->parsed_args);\n\n\tfor (i=*idx; i<count; i++) {\n\t\tGF_FSArgItem *ai = gf_list_get(fsess->parsed_args, i);\n\t\t(*idx)++;\n\t\tif (ai->opt_found || (ai->meta_state==2)) continue;\n\t\tif (argname) *argname = ai->argname;\n\t\tif (argtype) *argtype = ai->type;\n\t\tif (meta_filter) *meta_filter = ai->meta_filter;\n\t\tif (meta_sub_opt) *meta_sub_opt = ai->meta_opt;\n\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\n\nvoid task_canceled(GF_FSTask *task);\nstatic void gf_task_del(void *p)\n{\n\tGF_FSTask *t = (GF_FSTask *) p;\n\ttask_canceled(t);\n\tgf_free(p);\n}\n\nGF_EXPORT\nvoid gf_fs_del(GF_FilterSession *fsess)\n{\n\tassert(fsess);\n\n\tgf_fs_stop(fsess);\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Session destroy begin\\n\"));\n\n\tif (fsess->parsed_args) {\n\t\twhile (gf_list_count(fsess->parsed_args)) {\n\t\t\tGF_FSArgItem *ai = gf_list_pop_back(fsess->parsed_args);\n\t\t\tgf_free(ai->argname);\n\t\t\tgf_free(ai);\n\t\t}\n\t\tgf_list_del(fsess->parsed_args);\n\t}\n\n\t//temporary until we don't introduce fsess_stop\n\tassert(fsess->run_status != GF_OK);\n\tif (fsess->filters) {\n\t\tu32 i, pass, count=gf_list_count(fsess->filters);\n\t\t//first pass: disconnect all filters, since some may have references to property maps or packets \n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 j;\n\t\t\tGF_Filter *filter = gf_list_get(fsess->filters, i);\n\t\t\tfilter->process_th_id = 0;\n\t\t\tfilter->scheduled_for_next_task = GF_TRUE;\n\n\t\t\tif (filter->detached_pid_inst) {\n\t\t\t\twhile (gf_list_count(filter->detached_pid_inst)) {\n\t\t\t\t\tGF_FilterPidInst *pidi = gf_list_pop_front(filter->detached_pid_inst);\n\t\t\t\t\tgf_filter_pid_inst_del(pidi);\n\t\t\t\t}\n\t\t\t\tgf_list_del(filter->detached_pid_inst);\n\t\t\t\tfilter->detached_pid_inst = NULL;\n\t\t\t}\n\n\t\t\tif (filter->postponed_packets) {\n\t\t\t\twhile (gf_list_count(filter->postponed_packets)) {\n\t\t\t\t\tGF_FilterPacket *pck = gf_list_pop_front(filter->postponed_packets);\n\t\t\t\t\tgf_filter_packet_destroy(pck);\n\t\t\t\t}\n\t\t\t\tgf_list_del(filter->postponed_packets);\n\t\t\t\tfilter->postponed_packets = NULL;\n\t\t\t}\n\t\t\tgf_mx_p(filter->tasks_mx);\n\t\t\tfor (j=0; j<filter->num_input_pids; j++) {\n\t\t\t\tGF_FilterPidInst *pidi = gf_list_get(filter->input_pids, j);\n\t\t\t\tgf_filter_pid_inst_reset(pidi);\n\t\t\t}\n\t\t\tgf_mx_v(filter->tasks_mx);\n\t\t\tfilter->scheduled_for_next_task = GF_FALSE;\n\t\t}\n\t\t//second pass, finalize all\n\t\tfor (pass=0; pass<2; pass++) {\n\t\t\tBool has_scripts = GF_FALSE;\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_Filter *filter = gf_list_get(fsess->filters, i);\n\t\t\t\tif (!pass && (filter->freg->flags & GF_FS_REG_SCRIPT)) {\n\t\t\t\t\thas_scripts = GF_TRUE;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (filter->freg->finalize && !filter->finalized) {\n\t\t\t\t\tfilter->finalized = GF_TRUE;\n\t\t\t\t\tFSESS_CHECK_THREAD(filter)\n\t\t\t\t\tfilter->freg->finalize(filter);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!has_scripts) break;\n\t\t}\n\n\t\twhile (gf_list_count(fsess->filters)) {\n\t\t\tGF_Filter *filter = gf_list_pop_back(fsess->filters);\n\n\t\t\tgf_filter_del(filter);\n\t\t}\n\t\tgf_list_del(fsess->filters);\n\t\tfsess->filters = NULL;\n\t}\n\n\tgf_fs_unload_script(fsess, NULL);\n\n#ifdef GPAC_USE_DOWNLOADER\n\tif (fsess->download_manager) gf_dm_del(fsess->download_manager);\n#endif\n\n#ifndef GPAC_DISABLE_FONTS\n\tif (fsess->font_manager) gf_font_manager_del(fsess->font_manager);\n#endif\n\n\tif (fsess->registry) {\n\t\twhile (gf_list_count(fsess->registry)) {\n\t\t\tGF_FilterRegister *freg = gf_list_pop_back(fsess->registry);\n\t\t\tif (freg->register_free) freg->register_free(fsess, freg);\n\t\t}\n\t\tgf_list_del(fsess->registry);\n\t}\n\n\tif (fsess->tasks)\n\t\tgf_fq_del(fsess->tasks, gf_task_del);\n\n\tif (fsess->tasks_reservoir)\n\t\tgf_fq_del(fsess->tasks_reservoir, gf_void_del);\n\n#ifndef GPAC_DISABLE_THREADS\n\tif (fsess->threads) {\n\t\tif (fsess->main_thread_tasks)\n\t\t\tgf_fq_del(fsess->main_thread_tasks, gf_task_del);\n\n\t\twhile (gf_list_count(fsess->threads)) {\n\t\t\tGF_SessionThread *sess_th = gf_list_pop_back(fsess->threads);\n\t\t\tgf_th_del(sess_th->th);\n\t\t\tgf_free(sess_th);\n\t\t}\n\t\tgf_list_del(fsess->threads);\n\t}\n#endif\n\n\tif (fsess->prop_maps_reservoir)\n\t\tgf_fq_del(fsess->prop_maps_reservoir, gf_propmap_del);\n#if GF_PROPS_HASHTABLE_SIZE\n\tif (fsess->prop_maps_list_reservoir)\n\t\tgf_fq_del(fsess->prop_maps_list_reservoir, (gf_destruct_fun) gf_list_del);\n#endif\n\tif (fsess->prop_maps_entry_reservoir)\n\t\tgf_fq_del(fsess->prop_maps_entry_reservoir, gf_void_del);\n\tif (fsess->prop_maps_entry_data_alloc_reservoir)\n\t\tgf_fq_del(fsess->prop_maps_entry_data_alloc_reservoir, gf_propalloc_del);\n\tif (fsess->pcks_refprops_reservoir)\n\t\tgf_fq_del(fsess->pcks_refprops_reservoir, gf_void_del);\n\n\n\tif (fsess->props_mx)\n\t\tgf_mx_del(fsess->props_mx);\n\n\tif (fsess->info_mx)\n\t\tgf_mx_del(fsess->info_mx);\n\n\tif (fsess->ui_mx)\n\t\tgf_mx_del(fsess->ui_mx);\n\n\tif (fsess->semaphore_other && (fsess->semaphore_other != fsess->semaphore_main) )\n\t\tgf_sema_del(fsess->semaphore_other);\n\n\tif (fsess->semaphore_main)\n\t\tgf_sema_del(fsess->semaphore_main);\n\n\tif (fsess->tasks_mx)\n\t\tgf_mx_del(fsess->tasks_mx);\n\n\tif (fsess->filters_mx)\n\t\tgf_mx_del(fsess->filters_mx);\n\n\tif (fsess->evt_mx) gf_mx_del(fsess->evt_mx);\n\tif (fsess->event_listeners) gf_list_del(fsess->event_listeners);\n\n\tif (fsess->links) {\n\t\tgf_filter_sess_reset_graph(fsess, NULL);\n\t\tgf_list_del(fsess->links);\n\t}\n\tif (fsess->links_mx) gf_mx_del(fsess->links_mx);\n\n#ifndef GPAC_DISABLE_3D\n\tgf_list_del(fsess->gl_providers);\n\tif (fsess->gl_driver) {\n\t\tfsess->gl_driver->Shutdown(fsess->gl_driver);\n\t\tgf_modules_close_interface((GF_BaseInterface *)fsess->gl_driver);\n\t}\n#endif\n\n\tif (fsess->auto_inc_nums) {\n\t\twhile(gf_list_count(fsess->auto_inc_nums)) {\n\t\t\tGF_FSAutoIncNum *aint = gf_list_pop_back(fsess->auto_inc_nums);\n\t\t\tgf_free(aint);\n\t\t}\n\t\tgf_list_del(fsess->auto_inc_nums);\n\t}\n\n#ifdef GF_FS_ENABLE_LOCALES\n\tif (fsess->uri_relocators) gf_list_del(fsess->uri_relocators);\n\tif (fsess->locales.szAbsRelocatedPath) gf_free(fsess->locales.szAbsRelocatedPath);\n#endif\n\tif (fsess->blacklist) gf_free(fsess->blacklist);\n\n\tgf_free(fsess);\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Session destroyed\\n\"));\n}\n\nGF_EXPORT\nu32 gf_fs_filters_registers_count(GF_FilterSession *fsess)\n{\n\treturn fsess ? gf_list_count(fsess->registry) : 0;\n}\n\nGF_EXPORT\nconst GF_FilterRegister * gf_fs_get_filter_register(GF_FilterSession *fsess, u32 idx)\n{\n\treturn gf_list_get(fsess->registry, idx);\n}\n\n#ifdef CHECK_TASK_LIST_INTEGRITY\nstatic void check_task_list_enum(void *udta, void *item)\n{\n\tassert(udta != item);\n}\nstatic void check_task_list(GF_FilterQueue *fq, GF_FSTask *task)\n{\n\tif (fq) {\n\t\tgf_fq_enum(fq, check_task_list_enum, task);\n\t}\n}\n#endif\n\nvoid gf_fs_post_task_ex(GF_FilterSession *fsess, gf_fs_task_callback task_fun, GF_Filter *filter, GF_FilterPid *pid, const char *log_name, void *udta, Bool is_configure, Bool force_main_thread, Bool force_direct_call, u32 class_type)\n{\n\tGF_FSTask *task;\n\tBool notified = GF_FALSE;\n\n\tassert(fsess);\n\tassert(task_fun);\n\n\t//only flatten calls if in main thread (we still have some broken filters using threading that could trigger tasks)\n\tif ((force_direct_call || fsess->direct_mode)\n\t\t&& (!filter || !filter->in_process)\n\t\t&& fsess->tasks_in_process\n\t\t&& (gf_th_id()==fsess->main_th.th_id)\n\t) {\n\t\tGF_FSTask atask;\n\t\tu64 task_time = gf_sys_clock_high_res();\n\t\tmemset(&atask, 0, sizeof(GF_FSTask));\n\t\tatask.filter = filter;\n\t\tatask.pid = pid;\n\t\tatask.run_task = task_fun;\n\t\tatask.log_name = log_name;\n\t\tatask.udta = udta;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread 0 task#%d %p executing Filter %s::%s (%d tasks pending)\\n\", fsess->main_th.nb_tasks, &atask, filter ? filter->name : \"none\", log_name, fsess->tasks_pending));\n\t\tif (filter)\n\t\t\tfilter->scheduled_for_next_task = GF_TRUE;\n\t\ttask_fun(&atask);\n\t\tfilter = atask.filter;\n\t\tif (filter) {\n\t\t\tfilter->time_process += gf_sys_clock_high_res() - task_time;\n\t\t\tfilter->scheduled_for_next_task = GF_FALSE;\n\t\t\tfilter->nb_tasks_done++;\n\t\t}\n\t\tif (!atask.requeue_request)\n\t\t\treturn;\n\t\t//asked to requeue the task, post it\n\t}\n\n\t/*this was a gf_filter_process_task request but direct call could not be done or requeue is requested.\n\tprocess_task_queued was incremented by caller without checking for existing process task\n\t\t- If the task was not treated, dec / inc will give the same state, undo process_task_queued increment\n\t\t- If the task was requeued, dec will undo the increment done when requeing the task in gf_filter_check_pending_tasks\n\n\tIn both cases, inc will redo the same logic as in gf_filter_post_process_task_internal, not creating task if gf_filter_process_task is\n\talready scheduled for the filter\n\n\tWe must use safe_int_dec/safe_int_inc here for multi thread cases - cf issue #1778\n\t*/\n\tif (force_direct_call) {\n\t\tassert(filter);\n\t\tsafe_int_dec(&filter->process_task_queued);\n\t\tif (safe_int_inc(&filter->process_task_queued) > 1) {\n\t\t\treturn;\n\t\t}\n\t}\n\ttask = gf_fq_pop(fsess->tasks_reservoir);\n\n\tif (!task) {\n\t\tGF_SAFEALLOC(task, GF_FSTask);\n\t\tif (!task) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCHEDULER, (\"No more memory to post new task\\n\"));\n\t\t\treturn;\n\t\t}\n\t}\n\ttask->filter = filter;\n\ttask->pid = pid;\n\ttask->run_task = task_fun;\n\ttask->log_name = log_name;\n\ttask->udta = udta;\n\ttask->class_type = class_type;\n\n\tif (filter && is_configure) {\n\t\tif (filter->freg->flags & GF_FS_REG_CONFIGURE_MAIN_THREAD)\n\t\t\tforce_main_thread = GF_TRUE;\n\t}\n\n\tif (filter) {\n\t\tgf_mx_p(filter->tasks_mx);\n\n\t\t//no tasks and not scheduled\n\t\tif (! filter->scheduled_for_next_task && !gf_fq_count(filter->tasks)) {\n\t\t\tnotified = task->notified = GF_TRUE;\n\n\t\t\tif (!force_main_thread)\n\t\t\t\tforce_main_thread = (filter->nb_main_thread_forced || (filter->freg->flags & GF_FS_REG_MAIN_THREAD)) ? GF_TRUE : GF_FALSE;\n\t\t} else if (force_main_thread) {\n#if 0\n\t\t\tforce_main_thread = GF_FALSE;\n\t\t\tif (filter->process_th_id && (fsess->main_th.th_id != filter->process_th_id)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCHEDULER, (\"Cannot post task to main thread, filter is already scheduled\\n\"));\n\t\t\t}\n#endif\n\t\t}\n\n#ifdef GPAC_CONFIG_EMSCRIPTEN\n\t\tif (filter->freg->flags & GF_FS_REG_BLOCK_MAIN)\n\t\t\ttask->blocking = GF_TRUE;\n\t\telse\n#endif\n\t\tif (!force_main_thread)\n\t\t\ttask->blocking = (filter->is_blocking_source) ? GF_TRUE : GF_FALSE;\n\t\telse\n\t\t\ttask->force_main = GF_TRUE;\n\n\t\tgf_fq_add(filter->tasks, task);\n\t\tgf_mx_v(filter->tasks_mx);\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u Posted task %p Filter %s::%s (%d (%d) pending, %d process tasks) on %s task list\\n\", gf_th_id(), task, filter->name, task->log_name, fsess->tasks_pending, gf_fq_count(filter->tasks), filter->process_task_queued, task->notified ? (force_main_thread ? \"main\" : \"secondary\") : \"filter\"));\n\t} else {\n\t\ttask->notified = notified = GF_TRUE;\n\t\ttask->force_main = force_main_thread;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u Posted filter-less task %s (%d pending) on secondary task list\\n\", gf_th_id(), task->log_name, fsess->tasks_pending));\n\t}\n\n\t//WARNING, do not use task->notified since the task may have been posted to the filter task list and may already have been swapped\n\t//with a different value !\n\tif (notified) {\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\tcheck_task_list(fsess->main_thread_tasks, task);\n\t\tcheck_task_list(fsess->tasks, task);\n\t\tcheck_task_list(fsess->tasks_reservoir, task);\n#endif\n\t\tassert(task->run_task);\n\t\tif (filter) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u posting filter task, scheduled_for_next_task %d\\n\", gf_th_id(), filter->scheduled_for_next_task));\n\t\t\tassert(!filter->scheduled_for_next_task);\n\t\t}\n\n\t\t//notify/count tasks posted on the main task or regular task lists\n\t\tsafe_int_inc(&fsess->tasks_pending);\n\t\tif (task->force_main) {\n\t\t\tgf_fq_add(fsess->main_thread_tasks, task);\n\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_TRUE);\n\t\t} else {\n\t\t\tassert(task->run_task);\n\t\t\tgf_fq_add(fsess->tasks, task);\n\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_FALSE);\n\t\t}\n\t}\n}\n\nvoid gf_fs_post_task(GF_FilterSession *fsess, gf_fs_task_callback task_fun, GF_Filter *filter, GF_FilterPid *pid, const char *log_name, void *udta)\n{\n\tgf_fs_post_task_ex(fsess, task_fun, filter, pid, log_name, udta, GF_FALSE, GF_FALSE, GF_FALSE, TASK_TYPE_NONE);\n}\n\nvoid gf_fs_post_task_class(GF_FilterSession *fsess, gf_fs_task_callback task_fun, GF_Filter *filter, GF_FilterPid *pid, const char *log_name, void *udta, u32 class_id)\n{\n\tgf_fs_post_task_ex(fsess, task_fun, filter, pid, log_name, udta, GF_FALSE, GF_FALSE, GF_FALSE, class_id);\n}\n\nBool gf_fs_check_filter_register_cap_ex(const GF_FilterRegister *f_reg, u32 incode, GF_PropertyValue *cap_input, u32 outcode, GF_PropertyValue *cap_output, Bool exact_match_only, Bool out_cap_excluded)\n{\n\tu32 j;\n\tu32 has_raw_in = 0;\n\tu32 has_cid_match = 0;\n\tu32 exclude_cid_out = 0;\n\tu32 has_exclude_cid_out = 0;\n\tfor (j=0; j<f_reg->nb_caps; j++) {\n\t\tconst GF_FilterCapability *cap = &f_reg->caps[j];\n\t\tif (!(cap->flags & GF_CAPFLAG_IN_BUNDLE)) {\n\t\t\t//CID not excluded, raw in present and CID explicit match or not included in excluded set\n\t\t\tif (!exclude_cid_out && has_raw_in && (has_cid_match || (!exact_match_only && has_exclude_cid_out) ) ) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\n\t\t\tif (has_raw_in != 2) has_raw_in = 0;\n\t\t\tif (has_cid_match != 2) has_cid_match = 0;\n\t\t\tif (exclude_cid_out != 2) exclude_cid_out = 0;\n\t\t\tif (has_exclude_cid_out != 2) has_exclude_cid_out = 0;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( (cap->flags & GF_CAPFLAG_INPUT) && (cap->code == incode) ) {\n\t\t\tif (! (cap->flags & GF_CAPFLAG_EXCLUDED) && gf_props_equal(&cap->val, cap_input) ) {\n\t\t\t\thas_raw_in = (cap->flags & GF_CAPS_INPUT_STATIC) ? 2 : 1;\n\t\t\t}\n\t\t}\n\t\tif ( (cap->flags & GF_CAPFLAG_OUTPUT) && (cap->code == outcode) ) {\n\t\t\tif (! (cap->flags & GF_CAPFLAG_EXCLUDED)) {\n\t\t\t\tif (gf_props_equal(&cap->val, cap_output) ) {\n\t\t\t\t\tif (out_cap_excluded) {\n\t\t\t\t\t\texclude_cid_out = (cap->flags & GF_CAPS_OUTPUT_STATIC) ? 2 : 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\thas_cid_match = (cap->flags & GF_CAPS_OUTPUT_STATIC) ? 2 : 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tBool prop_equal = gf_props_equal(&cap->val, cap_output);\n\t\t\t\tif (out_cap_excluded)\n\t\t\t\t\tprop_equal = !prop_equal;\n\n\t\t\t\tif (prop_equal) {\n\t\t\t\t\texclude_cid_out = (cap->flags & GF_CAPS_OUTPUT_STATIC) ? 2 : 1;\n\t\t\t\t} else {\n\t\t\t\t\thas_exclude_cid_out = (cap->flags & GF_CAPS_OUTPUT_STATIC) ? 2 : 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//CID not excluded, raw in present and CID explicit match or not included in excluded set\n\tif (!exclude_cid_out && has_raw_in && (has_cid_match || (!exact_match_only && has_exclude_cid_out) ) ) {\n\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\nGF_EXPORT\nBool gf_fs_check_filter_register_cap(const GF_FilterRegister *f_reg, u32 incode, GF_PropertyValue *cap_input, u32 outcode, GF_PropertyValue *cap_output, Bool exact_match_only)\n{\n\treturn gf_fs_check_filter_register_cap_ex(f_reg, incode, cap_input, outcode, cap_output, exact_match_only, GF_FALSE);\n}\n\nGF_Filter *gf_fs_load_encoder(GF_FilterSession *fsess, const char *args, GF_List *filter_blacklist)\n{\n\tGF_Err e;\n\tchar szCodec[3];\n\tchar *cid, *sep;\n\tconst GF_FilterRegister *candidate;\n\tu32 codecid=0;\n\tGF_Filter *filter;\n\tu32 i, count;\n\tGF_PropertyValue cap_in, cap_out;\n\tGF_List *blacklist = NULL;\n\tBool ocap_excluded = GF_FALSE;\n\tszCodec[0] = 'c';\n\tszCodec[1] = fsess->sep_name;\n\tszCodec[2] = 0;\n\n\tcid = args ? strstr(args, szCodec) : NULL;\n\tif (!cid) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Missing codec identifier in \\\"enc\\\" definition: %s\\n\", args ? args : \"no arguments\"));\n\t\treturn NULL;\n\t}\n\tsep = strchr(cid, fsess->sep_args);\n\tif (sep) sep[0] = 0;\n\n\tcodecid = gf_codecid_parse(cid+2);\n#if 0\n\tif (codecid==GF_CODECID_NONE) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Unrecognized codec identifier in \\\"enc\\\" definition: %s\\n\", cid));\n\t\tif (sep) sep[0] = fsess->sep_args;\n\t\treturn NULL;\n\t}\n#endif\n\tif (sep) sep[0] = fsess->sep_args;\n\n\tcap_in.type = GF_PROP_UINT;\n\tcap_in.value.uint = GF_CODECID_RAW;\n\tcap_out.type = GF_PROP_UINT;\n\tif (codecid==GF_CODECID_NONE) {\n\t\tcap_out.value.uint = GF_CODECID_RAW;\n\t\tocap_excluded = GF_TRUE;\n\t} else {\n\t\tcap_out.value.uint = codecid;\n\t}\n\nretry:\n\tcandidate = NULL;\n\tcount = gf_list_count(fsess->registry);\n\tfor (i=0; i<count; i++) {\n\t\tconst GF_FilterRegister *f_reg = gf_list_get(fsess->registry, i);\n\t\tif (blacklist && (gf_list_find(blacklist, (void *) f_reg)>=0) )\n\t\t\tcontinue;\n\t\tif (filter_blacklist && (gf_list_find(filter_blacklist, (void *) f_reg)>=0) )\n\t\t\tcontinue;\n\n\t\tif ( gf_fs_check_filter_register_cap_ex(f_reg, GF_PROP_PID_CODECID, &cap_in, GF_PROP_PID_CODECID, &cap_out, GF_FALSE, ocap_excluded)) {\n\t\t\tif (!candidate || (candidate->priority>f_reg->priority))\n\t\t\t\tcandidate = f_reg;\n\t\t}\n\t}\n\tif (!candidate) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Cannot find any filter providing encoding for %s\\n\", cid));\n\t\tif (blacklist) gf_list_del(blacklist);\n\t\treturn NULL;\n\t}\n\tfilter = gf_filter_new(fsess, candidate, args, NULL, GF_FILTER_ARG_EXPLICIT, &e, NULL, GF_FALSE);\n\tif (!filter) {\n\t\tif (e==GF_NOT_SUPPORTED) {\n\t\t\tif (!blacklist) blacklist = gf_list_new();\n\t\t\tgf_list_add(blacklist, (void *) candidate);\n\t\t\tgoto retry;\n\t\t}\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Failed to load filter %s: %s\\n\", candidate->name, gf_error_to_string(e) ));\n\t} else {\n\t\tfilter->encoder_stream_type = gf_codecid_type(codecid);\n\t}\n\tif (blacklist) gf_list_del(blacklist);\n\treturn filter;\n}\n\nGF_EXPORT\nBool gf_fs_filter_exists(GF_FilterSession *fsess, const char *name)\n{\n\tu32 i, count;\n\n\tif (!strcmp(name, \"enc\")) return GF_TRUE;\n\tif ((strlen(name)>2) && (name[0]=='c') && (name[1]==fsess->sep_name))\n\t\treturn GF_TRUE;\n\n\tcount = gf_list_count(fsess->registry);\n\tfor (i=0;i<count;i++) {\n\t\tconst GF_FilterRegister *f_reg = gf_list_get(fsess->registry, i);\n\t\tif (!strcmp(f_reg->name, name)) {\n\t\t\treturn GF_TRUE;\n\t\t}\n\t}\n\treturn GF_FALSE;\n}\n\nstatic Bool locate_js_script(char *path, const char *file_name, const char *file_ext)\n{\n\tu32 len = (u32) strlen(path);\n\tu32 flen = 20 + (u32) strlen(file_name);\n\n\tchar *apath = gf_malloc(sizeof(char) * (len+flen) );\n\tif (!apath) return GF_FALSE;\n\tstrcpy(apath, path);\n\n\tstrcat(apath, file_name);\n\tif (gf_file_exists(apath)) {\n\t\tstrncpy(path, apath, GF_MAX_PATH-1);\n\t\tpath[GF_MAX_PATH-1] = 0;\n\t\tgf_free(apath);\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Found %s for file %s\\n\", path, file_name));\n\t\treturn GF_TRUE;\n\t}\n\n\tif (!file_ext) {\n\t\tstrcat(apath, \".js\");\n\t\tif (gf_file_exists(apath)) {\n\t\t\tstrncpy(path, apath, GF_MAX_PATH-1);\n\t\t\tpath[GF_MAX_PATH-1] = 0;\n\t\t\tgf_free(apath);\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Found %s for file %s\\n\", path, file_name));\n\t\t\treturn GF_TRUE;\n\t\t}\n\t}\n\tapath[len] = 0;\n\tstrcat(apath, file_name);\n\tstrcat(apath, \"/init.js\");\n\tif (gf_file_exists(apath)) {\n\t\tstrncpy(path, apath, GF_MAX_PATH-1);\n\t\tpath[GF_MAX_PATH-1] = 0;\n\t\tgf_free(apath);\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Found %s for file %s\\n\", path, file_name));\n\t\treturn GF_TRUE;\n\t}\n\tgf_free(apath);\n\treturn GF_FALSE;\n}\n\nBool gf_fs_solve_js_script(char *szPath, const char *file_name, const char *file_ext)\n{\n\tconst char *js_dirs;\n\tif (gf_opts_default_shared_directory(szPath)) {\n\t\tstrcat(szPath, \"/scripts/jsf/\");\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Trying JS filter %s\\n\", szPath));\n\t\tif (locate_js_script(szPath, file_name, file_ext)) {\n\t\t\treturn GF_TRUE;\n\t\t}\n\t} else {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Failed to get default shared dir\\n\"));\n\t}\n\tjs_dirs = gf_opts_get_key(\"core\", \"js-dirs\");\n\twhile (js_dirs && js_dirs[0]) {\n\t\tchar *sep = strchr(js_dirs, ',');\n\t\tif (sep) {\n\t\t\tu32 cplen = (u32) (sep-js_dirs);\n\t\t\tif (cplen>=GF_MAX_PATH) cplen = GF_MAX_PATH-1;\n\t\t\tstrncpy(szPath, js_dirs, cplen);\n\t\t\tszPath[cplen]=0;\n\t\t\tjs_dirs = sep+1;\n\t\t} else {\n\t\t\tstrcpy(szPath, js_dirs);\n\t\t}\n\t\tif (strcmp(szPath, \"$GJS\")) {\n\t\t\tu32 len = (u32) strlen(szPath);\n\t\t\tif (len && (szPath[len-1]!='/') && (szPath[len-1]!='\\\\'))\n\t\t\t\tstrcat(szPath, \"/\");\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Trying JS filter in %s\\n\", szPath));\n\t\t\tif (locate_js_script(szPath, file_name, file_ext))\n\t\t\t\treturn GF_TRUE;\n\t\t}\n\t\tif (!sep) break;\n\t}\n\treturn GF_FALSE;\n}\n\nstatic GF_Filter *gf_fs_load_filter_internal(GF_FilterSession *fsess, const char *name, GF_Err *err_code, Bool *probe_only)\n{\n\tconst char *args=NULL;\n\tconst char *sep, *file_ext;\n\tu32 i, len, count = gf_list_count(fsess->registry);\n\tBool quiet = (err_code && (*err_code == GF_EOS)) ? GF_TRUE : GF_FALSE;\n\n\tassert(fsess);\n\tassert(name);\n\tif (err_code) *err_code = GF_OK;\n\n\t//the first string before any option sep MUST be the filter registry name, so we don't use gf_fs_path_escape_colon here\n\tsep = strchr(name, fsess->sep_args);\n\tif (sep) {\n\t\targs = sep+1;\n\t\tlen = (u32) (sep - name);\n\t} else len = (u32) strlen(name);\n\n\tif (!len) {\n\t\tif (!quiet) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Missing filter name in %s\\n\", name));\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (!strncmp(name, \"enc\", len)) {\n\t\treturn gf_fs_load_encoder(fsess, args, NULL);\n\t}\n\tif ((strlen(name)>2) && (name[0]=='c') && (name[1]==fsess->sep_name)) {\n\t\treturn gf_fs_load_encoder(fsess, name, NULL);\n\t}\n\n\t/*regular filter loading*/\n\tfor (i=0;i<count;i++) {\n\t\tconst GF_FilterRegister *f_reg = gf_list_get(fsess->registry, i);\n\t\tif ((strlen(f_reg->name)==len) && !strncmp(f_reg->name, name, len)) {\n\t\t\tGF_Filter *filter;\n\t\t\tGF_FilterArgType argtype = GF_FILTER_ARG_EXPLICIT;\n\n\t\t\tif ((f_reg->flags & GF_FS_REG_REQUIRES_RESOLVER) && !fsess->max_resolve_chain_len) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Filter %s requires graph resolver but it is disabled\\n\", name));\n\t\t\t\tif (err_code) *err_code = GF_BAD_PARAM;\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tif (f_reg->flags & GF_FS_REG_ACT_AS_SOURCE) argtype = GF_FILTER_ARG_EXPLICIT_SOURCE;\n\t\t\tfilter = gf_filter_new(fsess, f_reg, args, NULL, argtype, err_code, NULL, GF_FALSE);\n\t\t\tif (!filter) return NULL;\n\t\t\tif (!filter->num_output_pids) {\n\t\t\t\t//check we have a src specified for the filter\n\t\t\t\tconst char *src_url = strstr(name, \"src\");\n\t\t\t\tif (src_url && (src_url[3]==fsess->sep_name)) {\n\t\t\t\t\tconst GF_FilterArgs *f_args = filter->instance_args ? filter->instance_args : f_reg->args;\n\t\t\t\t\t//check the filter has an src argument\n\t\t\t\t\t//we don't want to call process on a filter not acting as source until at least one input is connected\n\t\t\t\t\ti=0;\n\t\t\t\t\twhile (f_args && f_args[i].arg_name) {\n\t\t\t\t\t\tif (!strcmp(f_args[i].arg_name, \"src\")) {\n\t\t\t\t\t\t\tgf_filter_post_process_task(filter);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn filter;\n\t\t}\n\t}\n\t/*check JS file*/\n\tfile_ext = gf_file_ext_start(name);\n\tif (file_ext && (file_ext > sep) )\n\t\tfile_ext = NULL;\n\n\tif (!file_ext || strstr(name, \".js\") || strstr(name, \".jsf\") || strstr(name, \".mjs\") ) {\n\t\tBool file_exists = GF_FALSE;\n\t\tchar szName[10+GF_MAX_PATH];\n\t\tchar szPath[10+GF_MAX_PATH];\n\t\tif (len>GF_MAX_PATH)\n\t\t\treturn NULL;\n\n\t\tstrncpy(szPath, name, len);\n\t\tszPath[len]=0;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Trying JS filter %s\\n\", szPath));\n\t\tif (gf_file_exists(szPath)) {\n\t\t\tfile_exists = GF_TRUE;\n\t\t} else {\n\t\t\tstrcpy(szName, szPath);\n\t\t\tfile_exists = gf_fs_solve_js_script(szPath, szName, file_ext);\n\t\t\tif (!file_exists && !file_ext) {\n\t\t\t\tstrcat(szName, \".js\");\n\t\t\t\tif (gf_file_exists(szName)) {\n\t\t\t\t\tstrncpy(szPath, name, len);\n\t\t\t\t\tszPath[len]=0;\n\t\t\t\t\tstrcat(szPath, \".js\");\n\t\t\t\t\tfile_exists = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (file_exists) {\n\t\t\tif (probe_only) {\n\t\t\t\t*probe_only = GF_TRUE;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tsprintf(szName, \"jsf%cjs%c\", fsess->sep_args, fsess->sep_name);\n\t\t\tstrcat(szName, szPath);\n\t\t\tif (name[len])\n\t\t\t\tstrcat(szName, name+len);\n\t\t\treturn gf_fs_load_filter(fsess, szName, err_code);\n\t\t}\n\t}\n\tif (err_code) *err_code = GF_FILTER_NOT_FOUND;\n\treturn NULL;\n}\n\nGF_EXPORT\nGF_Filter *gf_fs_load_filter(GF_FilterSession *fsess, const char *name, GF_Err *err_code)\n{\n\treturn gf_fs_load_filter_internal(fsess, name, err_code, NULL);\n}\n\n//in mono thread mode, we cannot always sleep for the requested timeout in case there are more tasks to be processed\n//this defines the number of pending tasks above which we limit sleep\n#define MONOTH_MIN_TASKS\t2\n//this defines the sleep time for this case\n#define MONOTH_MIN_SLEEP\t5\n\n#if defined(GPAC_CONFIG_EMSCRIPTEN) && !defined(GPAC_DISABLE_THREADS)\n#include <emscripten/threading.h>\nGF_Err gf_th_async_call(GF_Thread *t, u32 (*Run)(void *param), void *param);\n#endif\n\nstatic u32 gf_fs_thread_proc(GF_SessionThread *sess_thread)\n{\n\tGF_FilterSession *fsess = sess_thread->fsess;\n#ifndef GPAC_DISABLE_THREADS\n\tu32 i;\n\tu32 th_count = fsess->threads ? gf_list_count(fsess->threads) : 0;\n\tu32 thid =  1 + gf_list_find(fsess->threads, sess_thread);\n#else\n\tu32 th_count = 0;\n\tu32 thid = 0;\n#endif\n\tu64 enter_time = gf_sys_clock_high_res();\n\tBool use_main_sema = thid ? GF_FALSE : GF_TRUE;\n#ifndef GPAC_DISABLE_LOG\n\tu32 sys_thid = gf_th_id();\n#endif\n\tu64 next_task_schedule_time = 0;\n\tBool do_regulate = (fsess->flags & GF_FS_FLAG_NO_REGULATION) ? GF_FALSE : GF_TRUE;\n\tu32 consecutive_filter_tasks=0;\n\tBool force_secondary_tasks = GF_FALSE;\n\tBool skip_next_sema_wait = GF_FALSE;\n\tGF_Filter *current_filter = NULL;\n\n#if defined(GPAC_CONFIG_EMSCRIPTEN) && !defined(GPAC_DISABLE_THREADS)\n\tBool flush_main_blocking = (!thid && !fsess->is_worker) ? GF_TRUE : GF_FALSE;\n\tif (flush_main_blocking) do_regulate = GF_FALSE;\n#endif\n\n\t//main thread\n\tif (!thid) {\n\t\tif (!sess_thread->run_time) {\n\t\t\tsess_thread->run_time = enter_time;\n\t\t}\n\t\tif (fsess->non_blocking) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Main thread proc enter\\n\"));\n\t\t}\n\t}\n\t//first time we enter the thread proc\n\tif (!sess_thread->th_id) {\n\t\tsess_thread->th_id = gf_th_id();\n#ifdef GPAC_CONFIG_EMSCRIPTEN\n\t\tif (fsess->non_blocking && thid) {\n\t\t\tsess_thread->run_time = 0;\n\t\t\tsafe_int_dec(&fsess->pending_threads);\n\t\t}\n#endif\n\n#ifndef GPAC_DISABLE_REMOTERY\n\t\tgf_rmt_set_thread_name(sess_thread->rmt_name);\n#endif\n\t}\n\n#ifndef GPAC_DISABLE_REMOTERY\n\tsess_thread->rmt_tasks=40;\n#endif\n\n\tgf_rmt_begin(fs_thread, 0);\n\n\tsafe_int_inc(&fsess->active_threads);\n\n\twhile (1) {\n\t\tBool notified;\n\t\tBool requeue = GF_FALSE;\n\t\tu64 active_start, task_time;\n\t\tGF_FSTask *task=NULL;\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\tGF_Filter *prev_current_filter = NULL;\n\t\tBool skip_filter_task_check = GF_FALSE;\n#endif\n\n#ifndef GPAC_DISABLE_REMOTERY\n\t\tsess_thread->rmt_tasks--;\n\t\tif (!sess_thread->rmt_tasks) {\n\t\t\tgf_rmt_end();\n\t\t\tgf_rmt_begin(fs_thread, 0);\n\t\t\tsess_thread->rmt_tasks=40;\n\t\t}\n#endif\n\n#if defined(GPAC_CONFIG_EMSCRIPTEN) && !defined(GPAC_DISABLE_THREADS)\n\t\tif (flush_main_blocking)\n\t\t\temscripten_main_thread_process_queued_calls();\n#endif\n\n\t\tsafe_int_dec(&fsess->active_threads);\n\n\t\tif (!skip_next_sema_wait && (current_filter==NULL)) {\n\t\t\tgf_rmt_begin(sema_wait, GF_RMT_AGGREGATE);\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u Waiting scheduler %s semaphore\\n\", sys_thid, use_main_sema ? \"main\" : \"secondary\"));\n\t\t\t//wait for something to be done\n\t\t\tgf_fs_sema_io(fsess, GF_FALSE, use_main_sema);\n\t\t\tconsecutive_filter_tasks = 0;\n\t\t\tgf_rmt_end();\n#ifdef GPAC_CONFIG_EMSCRIPTEN\n\t\t\t//no tasks on main thread, exit setting in_main_sem_wait to trigger a NOT_READY on fs_run\n\t\t\t//this will give control back to JS\n\t\t\tif (use_main_sema && fsess->non_blocking && !gf_fq_count(fsess->main_thread_tasks)) {\n\t\t\t\tsafe_int_inc(&fsess->active_threads);\n\t\t\t\tfsess->in_main_sem_wait=1;\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t}\n\t\tsafe_int_inc(&fsess->active_threads);\n\t\tskip_next_sema_wait = GF_FALSE;\n\n\t\tactive_start = gf_sys_clock_high_res();\n\n\t\tif (current_filter==NULL) {\n\t\t\t//main thread\n\t\t\tif (thid==0) {\n\t\t\t\tif (!force_secondary_tasks) {\n\t\t\t\t\ttask = gf_fq_pop(fsess->main_thread_tasks);\n\t\t\t\t}\n\t\t\t\tif (!task) {\n\t\t\t\t\ttask = gf_fq_pop(fsess->tasks);\n\t\t\t\t\t//if task is blocking, don't use it, let a secondary thread deal with it\n\t\t\t\t\tif (task && task->blocking) {\n\t\t\t\t\t\tgf_fq_add(fsess->tasks, task);\n\t\t\t\t\t\ttask = NULL;\n\t\t\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_FALSE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tforce_secondary_tasks = GF_FALSE;\n\t\t\t} else {\n\t\t\t\ttask = gf_fq_pop(fsess->tasks);\n\t\t\t\tif (task && (task->force_main || (task->filter && task->filter->nb_main_thread_forced) ) ) {\n\t\t\t\t\t//post to main\n\t\t\t\t\tgf_fq_add(fsess->main_thread_tasks, task);\n\t\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_TRUE);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(!task || task->run_task );\n\t\t\tassert(!task || task->notified );\n\t\t} else {\n\t\t\t//keep task in filter tasks list until done\n\t\t\ttask = gf_fq_head(current_filter->tasks);\n\t\t\tif (task) {\n\t\t\t\tassert( task->run_task );\n\t\t\t\tassert( ! task->notified );\n\n\t\t\t\t//task was requested for main thread\n\t\t\t\tif ((task->force_main || current_filter->nb_main_thread_forced) && thid) {\n\t\t\t\t\t//make task notified and increase pending tasks\n\t\t\t\t\ttask->notified = GF_TRUE;\n\t\t\t\t\tsafe_int_inc(&fsess->tasks_pending);\n\n\t\t\t\t\t//post to main\n\t\t\t\t\tgf_fq_add(fsess->main_thread_tasks, task);\n\t\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_TRUE);\n\t\t\t\t\t//disable current filter\n\t\t\t\t\tcurrent_filter = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!task) {\n\t\t\tu32 force_nb_notif = 0;\n\t\t\tnext_task_schedule_time = 0;\n\t\t\t//no more task and EOS signal\n\t\t\tif (fsess->run_status != GF_OK)\n\t\t\t\tbreak;\n\n\t\t\tif (!fsess->tasks_pending && fsess->main_th.has_seen_eot) {\n\t\t\t\t//check all threads\n\t\t\t\tBool all_done = GF_TRUE;\n\n#ifndef GPAC_DISABLE_THREADS\n\t\t\t\tfor (i=0; i<th_count; i++) {\n\t\t\t\t\tGF_SessionThread *st = gf_list_get(fsess->threads, i);\n\t\t\t\t\tif (!st->has_seen_eot) {\n\t\t\t\t\t\tall_done = GF_FALSE;\n\t\t\t\t\t\tforce_nb_notif++;\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tif (all_done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (current_filter) {\n\t\t\t\tcurrent_filter->scheduled_for_next_task = GF_FALSE;\n\t\t\t\tcurrent_filter->process_th_id = 0;\n\t\t\t\tassert(current_filter->in_process);\n\t\t\t\tcurrent_filter->in_process = GF_FALSE;\n\t\t\t}\n\t\t\tcurrent_filter = NULL;\n\t\t\tsess_thread->active_time += gf_sys_clock_high_res() - active_start;\n\n\n\t\t\t//no pending tasks and first time main task queue is empty, flush to detect if we\n\t\t\t//are indeed done\n\t\t\tif (!fsess->tasks_pending && !fsess->tasks_in_process && !sess_thread->has_seen_eot && !gf_fq_count(fsess->tasks)) {\n\t\t\t\t//maybe last task, force a notify to check if we are truly done\n\t\t\t\tsess_thread->has_seen_eot = GF_TRUE;\n\t\t\t\t//not main thread and some tasks pending on main, notify only ourselves\n\t\t\t\tif (thid && gf_fq_count(fsess->main_thread_tasks)) {\n\t\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, use_main_sema);\n\t\t\t\t}\n\t\t\t\t//main thread exit probing, send a notify to main sema (for this thread), and N for the secondary one\n\t\t\t\telse {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u notify scheduler main semaphore\\n\", gf_th_id()));\n\t\t\t\t\tgf_sema_notify(fsess->semaphore_main, 1);\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u notify scheduler secondary semaphore %d\\n\", gf_th_id(), th_count));\n\t\t\t\t\tgf_sema_notify(fsess->semaphore_other, th_count);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//this thread and the main thread are done but we still have unfinished threads, re-notify everyone\n\t\t\telse if (!fsess->tasks_pending && fsess->main_th.has_seen_eot && force_nb_notif) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u notify scheduler main semaphore\\n\", gf_th_id()));\n\t\t\t\tgf_sema_notify(fsess->semaphore_main, 1);\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u notify scheduler secondary semaphore %d\\n\", gf_th_id(), th_count));\n\t\t\t\tgf_sema_notify(fsess->semaphore_other, th_count);\n\t\t\t}\n\n\t\t\t//no main thread, return\n\t\t\tif (!thid && fsess->non_blocking) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Main thread proc exit\\n\"));\n\t\t\t\tsafe_int_dec(&fsess->active_threads);\n\t\t\t\treturn 0;\n\t\t\t}\n\n#if defined(GPAC_CONFIG_EMSCRIPTEN) && !defined(GPAC_DISABLE_THREADS)\n\t\t\tif (thid && (fsess->run_status == GF_OK)) {\n\t\t\t\tsess_thread->run_time += gf_sys_clock_high_res() - enter_time;\n\t\t\t\tsafe_int_dec(&fsess->active_threads);\n\t\t\t\tgf_th_async_call(sess_thread->th, (gf_thread_run) gf_fs_thread_proc, sess_thread);\n\t\t\t\treturn 0;\n\t\t\t}\n#endif\n\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: no task available\\n\", sys_thid));\n\n\t\t\tif (do_regulate) {\n\t\t\t\tgf_sleep(0);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\tcheck_task_list(fsess->main_thread_tasks, task);\n\t\tcheck_task_list(fsess->tasks, task);\n#endif\n\t\tif (current_filter) {\n\t\t\tassert(current_filter==task->filter);\n\t\t}\n\t\tcurrent_filter = task->filter;\n\n\t\t//unless task was explicitly forced to main (pid init mostly), reschedule if filter is not on desired thread\n\t\tif (current_filter && !task->force_main\n\t\t\t&& current_filter->restrict_th_idx\n\t\t\t&& (thid != current_filter->restrict_th_idx)\n\t\t) {\n\t\t\t//reschedule task to secondary list\n\t\t\tif (!task->notified) {\n\t\t\t\ttask->notified = GF_TRUE;\n\t\t\t\tsafe_int_inc(&fsess->tasks_pending);\n\t\t\t}\n\t\t\tgf_fq_add(fsess->tasks, task);\n\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_FALSE);\n\t\t\tcurrent_filter = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//this is a crude way of scheduling the next task, we should\n\t\t//1- have a way to make sure we will not repost after a time-consuming task\n\t\t//2- have a way to wait for the given amount of time rather than just do a sema_wait/notify in loop\n\t\tif (task->schedule_next_time) {\n\t\t\ts64 now = gf_sys_clock_high_res();\n\t\t\ts64 diff = task->schedule_next_time;\n\t\t\tdiff -= now;\n\t\t\tdiff /= 1000;\n\n\n\t\t\tif (diff > 0) {\n\t\t\t\tGF_FSTask *next;\n\t\t\t\ts64 tdiff = diff;\n\t\t\t\ts64 ndiff = 0;\n\n\t\t\t\t//no filter, just reschedule the task\n\t\t\t\tif (!current_filter) {\n#ifndef GPAC_DISABLE_LOG\n\t\t\t\t\tconst char *task_log_name = task->log_name;\n#endif\n\t\t\t\t\tnext = gf_fq_head(fsess->tasks);\n\t\t\t\t\tnext_task_schedule_time = task->schedule_next_time;\n\t\t\t\t\tassert(task->run_task);\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\t\t\t\tcheck_task_list(fsess->main_thread_tasks, task);\n\t\t\t\t\tcheck_task_list(fsess->tasks, task);\n\t\t\t\t\tcheck_task_list(fsess->tasks_reservoir, task);\n#endif\n\t\t\t\t\t//tasks without filter are currently only posted to the secondary task list\n\t\t\t\t\tgf_fq_add(fsess->tasks, task);\n\t\t\t\t\tif (next) {\n\t\t\t\t\t\tif (next->schedule_next_time <= (u64) now) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: task %s reposted, next task time ready for execution\\n\", sys_thid, task_log_name));\n\n\t\t\t\t\t\t\tskip_next_sema_wait = GF_TRUE;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tndiff = next->schedule_next_time;\n\t\t\t\t\t\tndiff -= now;\n\t\t\t\t\t\tndiff /= 1000;\n\t\t\t\t\t\tif (ndiff<diff) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: task %s scheduled after next task %s:%s (in %d ms vs %d ms)\\n\", sys_thid, task_log_name, next->log_name, next->filter ? next->filter->name : \"\", (s32) diff, (s32) ndiff));\n\t\t\t\t\t\t\tdiff = ndiff;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!do_regulate) {\n\t\t\t\t\t\tdiff = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (diff && do_regulate) {\n\t\t\t\t\t\tif (diff > fsess->max_sleep)\n\t\t\t\t\t\t\tdiff = fsess->max_sleep;\n\t\t\t\t\t\tif (th_count==0) {\n\t\t\t\t\t\t\tif ( gf_fq_count(fsess->tasks) > MONOTH_MIN_TASKS)\n\t\t\t\t\t\t\t\tdiff = MONOTH_MIN_SLEEP;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: task %s reposted, %s task scheduled after this task, sleeping for %d ms (task diff %d - next diff %d)\\n\", sys_thid, task_log_name, next ? \"next\" : \"no\", diff, tdiff, ndiff));\n\t\t\t\t\t\tgf_sleep((u32) diff);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: task %s reposted, next task scheduled after this task, rerun\\n\", sys_thid, task_log_name));\n\t\t\t\t\t}\n\t\t\t\t\tskip_next_sema_wait = GF_TRUE;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!task->filter->finalized) {\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\t\t\t\tnext = gf_fq_head(current_filter->tasks);\n\t\t\t\t\tassert(next == task);\n\t\t\t\t\tcheck_task_list(fsess->main_thread_tasks, task);\n\t\t\t\t\tcheck_task_list(fsess->tasks_reservoir, task);\n#endif\n\n\t\t\t\t\t//next in filter should be handled before this task, move task at the end of the filter task\n\t\t\t\t\tnext = gf_fq_get(current_filter->tasks, 1);\n\t\t\t\t\tif (next && next->schedule_next_time < task->schedule_next_time) {\n\t\t\t\t\t\tif (task->notified) {\n\t\t\t\t\t\t\tassert(fsess->tasks_pending);\n\t\t\t\t\t\t\tsafe_int_dec(&fsess->tasks_pending);\n\t\t\t\t\t\t\ttask->notified = GF_FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: task %s:%s reposted to filter task until task exec time is reached (%d us)\\n\", sys_thid, current_filter->name, task->log_name, (s32) (task->schedule_next_time - next->schedule_next_time) ));\n\t\t\t\t\t\t//remove task\n\t\t\t\t\t\tgf_fq_pop(current_filter->tasks);\n\t\t\t\t\t\t//and queue it after the next one\n\t\t\t\t\t\tgf_fq_add(current_filter->tasks, task);\n\t\t\t\t\t\t//and continue with the same filter\n#if defined(GPAC_CONFIG_EMSCRIPTEN) && !defined(GPAC_DISABLE_THREADS)\n\t\t\t\t\t\tif (thid && (fsess->run_status == GF_OK)) {\n\t\t\t\t\t\t\tsess_thread->run_time += gf_sys_clock_high_res() - enter_time;\n\t\t\t\t\t\t\tsafe_int_dec(&fsess->active_threads);\n\t\t\t\t\t\t\tgf_th_async_call(sess_thread->th, (gf_thread_run) gf_fs_thread_proc, sess_thread);\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//little optim here: if this is the main thread and we have other tasks pending\n\t\t\t\t\t//check the timing of tasks in the secondary list. If a task is present with smaller time than\n\t\t\t\t\t//the head of the main task, force a temporary swap to the secondary task list\n\t\t\t\t\tif (!thid && task->notified && (diff > MONOTH_MIN_SLEEP) ) {\n\t\t\t\t\t\tu32 idx=0;\n\t\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t\tnext = gf_fq_get(fsess->tasks, idx);\n\t\t\t\t\t\t\tif (!next || next->blocking) break;\n\t\t\t\t\t\t\tidx++;\n\n\t\t\t\t\t\t\tu64 next_time_main = task->schedule_next_time;\n\t\t\t\t\t\t\tu64 next_time_secondary = next->schedule_next_time;\n\t\t\t\t\t\t\t//if we have several threads, also check the next task on the main task list\n\t\t\t\t\t\t\t// (different from secondary tasks in multithread case)\n\t\t\t\t\t\t\tif (th_count) {\n\t\t\t\t\t\t\t\tGF_FSTask *next_main = gf_fq_head(fsess->main_thread_tasks);\n\t\t\t\t\t\t\t\tif (next_main && (next_time_main > next_main->schedule_next_time))\n\t\t\t\t\t\t\t\t\tnext_time_main = next_main->schedule_next_time;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (next_time_secondary<next_time_main) {\n\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: forcing secondary task list on main - current task schedule time \"LLU\" (diff to now %d) vs next time secondary \"LLU\" (%s::%s)\\n\", sys_thid, task->schedule_next_time, (s32) diff, next_time_secondary, next->filter ? next->filter->freg->name : \"\", next->log_name));\n\t\t\t\t\t\t\t\tdiff = 0;\n\t\t\t\t\t\t\t\tforce_secondary_tasks = GF_TRUE;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t//move task to main list\n\t\t\t\t\tif (!task->notified) {\n\t\t\t\t\t\ttask->notified = GF_TRUE;\n\t\t\t\t\t\tsafe_int_inc(&fsess->tasks_pending);\n\t\t\t\t\t}\n\n\t\t\t\t\tsess_thread->active_time += gf_sys_clock_high_res() - active_start;\n\n\t\t\t\t\tif (next_task_schedule_time && (next_task_schedule_time <= task->schedule_next_time)) {\n\t\t\t\t\t\ttdiff = next_task_schedule_time;\n\t\t\t\t\t\ttdiff -= now;\n\t\t\t\t\t\tif (tdiff < 0) tdiff=0;\n\t\t\t\t\t\tif (tdiff<diff) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: next task has earlier exec time than current task %s:%s, adjusting sleep (old %d - new %d)\\n\", sys_thid, current_filter->name, task->log_name, (s32) diff, (s32) tdiff));\n\t\t\t\t\t\t\tdiff = tdiff;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: next task has earlier exec time#2 than current task %s:%s, adjusting sleep (old %d - new %d)\\n\", sys_thid, current_filter->name, task->log_name, (s32) diff, (s32) tdiff));\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (do_regulate && diff) {\n\t\t\t\t\t\tif (diff > fsess->max_sleep)\n\t\t\t\t\t\t\tdiff = fsess->max_sleep;\n\t\t\t\t\t\tif (th_count==0) {\n\t\t\t\t\t\t\tif ( gf_fq_count(fsess->tasks) > MONOTH_MIN_TASKS)\n\t\t\t\t\t\t\t\tdiff = MONOTH_MIN_SLEEP;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: task %s:%s postponed for %d ms (scheduled time \"LLU\" us, next task schedule \"LLU\" us)\\n\", sys_thid, current_filter->name, task->log_name, (s32) diff, task->schedule_next_time, next_task_schedule_time));\n\n\t\t\t\t\t\tgf_sleep((u32) diff);\n\t\t\t\t\t\tactive_start = gf_sys_clock_high_res();\n\t\t\t\t\t}\n\t\t\t\t\tdiff = (s64)task->schedule_next_time;\n\t\t\t\t\tdiff -= (s64) gf_sys_clock_high_res();\n\t\t\t\t\tif (diff > 100 ) {\n\t\t\t\t\t\tu32 pending_tasks;\n\t\t\t\t\t\tBool use_main = (current_filter->freg->flags & GF_FS_REG_MAIN_THREAD) ? GF_TRUE : GF_FALSE;\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: releasing current filter %s, exec time for %s due in \"LLD\" us\\n\", sys_thid, current_filter->name, task->log_name, diff));\n\t\t\t\t\t\tcurrent_filter->process_th_id = 0;\n\t\t\t\t\t\tcurrent_filter->in_process = GF_FALSE;\n\t\t\t\t\t\t//don't touch the current filter tasks, just repost the task to the main/secondary list\n\t\t\t\t\t\tassert(gf_fq_count(current_filter->tasks));\n\t\t\t\t\t\tcurrent_filter = NULL;\n\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\t\t\t\t\tcheck_task_list(fsess->main_thread_tasks, task);\n\t\t\t\t\t\tcheck_task_list(fsess->tasks, task);\n\t\t\t\t\t\tcheck_task_list(fsess->tasks_reservoir, task);\n\t\t\t\t\t\tassert(task->run_task);\n#endif\n\n\t\t\t\t\t\tif (use_main) {\n\t\t\t\t\t\t\tpending_tasks = gf_fq_count(fsess->main_thread_tasks);\n\t\t\t\t\t\t\tgf_fq_add(fsess->main_thread_tasks, task);\n\t\t\t\t\t\t\t//we are the main thread and reposting to the main task list, don't notify/wait for the sema, just retry\n\t\t\t\t\t\t\t//we are sure to get a task from main list at next iteration\n\t\t\t\t\t\t\tif (use_main_sema) {\n\t\t\t\t\t\t\t\tskip_next_sema_wait = GF_TRUE;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_TRUE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpending_tasks = gf_fq_count(fsess->main_thread_tasks);\n\t\t\t\t\t\t\tgf_fq_add(fsess->tasks, task);\n\t\t\t\t\t\t\t//we are not the main thread and we are reposting to the secondary task list, don't notify/wait for the sema, just retry\n\t\t\t\t\t\t\t//we are not sure to get a task from secondary list at next iteration, but the end of thread check will make\n\t\t\t\t\t\t\t//sure we renotify secondary sema if some tasks are still pending\n\t\t\t\t\t\t\tif (!use_main_sema) {\n\t\t\t\t\t\t\t\tskip_next_sema_wait = GF_TRUE;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_FALSE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//we temporary force the main thread to fetch a task from the secondary list\n\t\t\t\t\t\t//because the first main task was not yet due for execution\n\t\t\t\t\t\t//it is likely that the execution of the next task will not wake up the main thread\n\t\t\t\t\t\t//but we must reevaluate the previous main task timing, so we force a notification of the main sema\n\t\t\t\t\t\tif (force_secondary_tasks) {\n\t\t\t\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_TRUE);\n\t\t\t\t\t\t} else if (!thid && fsess->non_blocking && !pending_tasks) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Main thread proc exit\\n\"));\n\t\t\t\t\t\t\tsafe_int_dec(&fsess->active_threads);\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\n#if defined(GPAC_CONFIG_EMSCRIPTEN) && !defined(GPAC_DISABLE_THREADS)\n\t\t\t\t\t\tif (thid && (fsess->run_status == GF_OK)) {\n\t\t\t\t\t\t\tsess_thread->run_time += gf_sys_clock_high_res() - enter_time;\n\t\t\t\t\t\t\tsafe_int_dec(&fsess->active_threads);\n\t\t\t\t\t\t\tgf_th_async_call(sess_thread->th, (gf_thread_run) gf_fs_thread_proc, sess_thread);\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tforce_secondary_tasks=GF_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: task %s:%s schedule time \"LLU\" us reached (diff %d ms)\\n\", sys_thid, current_filter ? current_filter->name : \"\", task->log_name, task->schedule_next_time, (s32) diff));\n\n\t\t}\n\t\tnext_task_schedule_time = 0;\n\n\t\tif (current_filter) {\n\t\t\tcurrent_filter->scheduled_for_next_task = GF_TRUE;\n\t\t\tassert(!current_filter->in_process);\n\t\t\tcurrent_filter->in_process = GF_TRUE;\n\t\t\tcurrent_filter->process_th_id = gf_th_id();\n\t\t}\n\n\t\tsess_thread->nb_tasks++;\n\t\tsess_thread->has_seen_eot = GF_FALSE;\n\t\tif (task->filter) {\n\t\t\tassert(gf_fq_count(task->filter->tasks));\n\t\t}\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u task#%d %p executing Filter %s::%s (%d tasks pending, %d(%d) process task queued)\\n\", sys_thid, sess_thread->nb_tasks, task, task->filter ? task->filter->name : \"none\", task->log_name, fsess->tasks_pending, task->filter ? task->filter->process_task_queued : 0, task->filter ? gf_fq_count(task->filter->tasks) : 0));\n\n\t\tsafe_int_inc(& fsess->tasks_in_process );\n\t\tassert( task->run_task );\n\t\ttask_time = gf_sys_clock_high_res();\n\t\t//remember the last time we scheduled this filter\n\t\tif (task->filter)\n\t\t\ttask->filter->last_schedule_task_time = task_time;\n\n\t\ttask->can_swap = 0;\n\t\ttask->requeue_request = GF_FALSE;\n\t\ttask->run_task(task);\n\t\trequeue = task->requeue_request;\n\n\t\ttask_time = gf_sys_clock_high_res() - task_time;\n\t\tsafe_int_dec(& fsess->tasks_in_process );\n\n\t\t//may now be NULL if task was a filter destruction task\n\t\tcurrent_filter = task->filter;\n\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\tprev_current_filter = task->filter;\n#endif\n\n\t\t//source task was current filter, pop the filter task list\n\t\tif (current_filter) {\n\t\t\tBool last_task = GF_FALSE;\n\t\t\tcurrent_filter->nb_tasks_done++;\n\t\t\tcurrent_filter->time_process += task_time;\n\t\t\tconsecutive_filter_tasks++;\n\n#if defined(GPAC_CONFIG_EMSCRIPTEN)\n\t\t\t//for mono-thread case non blocking: if filter is marked as async blocking, abort and release\n\t\t\t//control to caller\n\t\t\tif  (!thid && fsess->non_blocking && (current_filter->freg->flags & GF_FS_REG_ASYNC_BLOCK)) {\n\t\t\t\tconsecutive_filter_tasks=11;\n\t\t\t\tfsess->in_main_sem_wait = GF_TRUE;\n\t\t\t}\n#endif\n\n\t\t\tgf_mx_p(current_filter->tasks_mx);\n\t\t\tif (gf_fq_count(current_filter->tasks)==1) {\n\t\t\t\t//if task is set to immediate reschedule, don't consider this is the last task\n\t\t\t\t//and check consecutive_filter_tasks - this will keep the active filter running\n\t\t\t\t//when the last task is a process task and the filter is not blocking\n\t\t\t\t//FIXME: commented out as this breaks ssome tests, needs further checking\n\t\t\t\t//if (task->can_swap!=2)\n\t\t\t\t{\n\t\t\t\t\tlast_task = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//if last task\n\t\t\tif ( last_task\n\t\t\t\t//if requeue request and stream reset pending (we must exit the filter task loop for the reset task to pe processed)\n\t\t\t\t|| (requeue && current_filter->stream_reset_pending)\n\t\t\t\t//or requeue request and pid swap pending (we must exit the filter task loop for the swap task to pe processed)\n\t\t\t\t|| (requeue && (current_filter->swap_pidinst_src ||  current_filter->swap_pidinst_dst) )\n\t\t\t\t//or requeue request and pid detach / cap negotiate pending\n\t\t\t\t|| (requeue && (current_filter->out_pid_connection_pending || current_filter->detached_pid_inst || current_filter->caps_negociate) )\n\n\t\t\t\t//or requeue request and we have been running on that filter for more than 10 times, abort\n\t\t\t\t|| (requeue && (consecutive_filter_tasks>10))\n\t\t\t) {\n\n\t\t\t\tif (requeue) {\n\t\t\t\t\t//filter task can be pushed back the queue of tasks\n\t\t\t\t\tif (task->can_swap) {\n\t\t\t\t\t\tGF_FSTask *next_task;\n\n\t\t\t\t\t\t//drop task from filter task list\n\t\t\t\t\t\tgf_fq_pop(current_filter->tasks);\n\n\t\t\t\t\t\tnext_task = gf_fq_head(current_filter->tasks);\n\t\t\t\t\t\t//if first task was notified, swap the flag\n\t\t\t\t\t\tif (next_task) {\n\t\t\t\t\t\t\t//see note in post_task_ex for caution about this !!\n\t\t\t\t\t\t\tnext_task->notified = task->notified;\n\t\t\t\t\t\t\ttask->notified = GF_FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//requeue task\n\t\t\t\t\t\tgf_fq_add(current_filter->tasks, task);\n\n\t\t\t\t\t\t//ans swap task for later requeing\n\t\t\t\t\t\tif (next_task) task = next_task;\n\t\t\t\t\t}\n\t\t\t\t\t//otherwise (can't swap) keep task first in the list\n\n\t\t\t\t\t//don't reset scheduled_for_next_task flag if requeued to make sure no other task posted from\n\t\t\t\t\t//another thread will post to main sched\n\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\t\t\t\tskip_filter_task_check = GF_TRUE;\n#endif\n\t\t\t\t} else {\n\t\t\t\t\t//no requeue, filter no longer scheduled and drop task\n\t\t\t\t\tcurrent_filter->scheduled_for_next_task = GF_FALSE;\n\n\t\t\t\t\t//drop task from filter task list\n\t\t\t\t\tgf_fq_pop(current_filter->tasks);\n\t\t\t\t}\n\n\t\t\t\tcurrent_filter->process_th_id = 0;\n\t\t\t\tcurrent_filter->in_process = GF_FALSE;\n\n\t\t\t\t//unlock once we modified in_process, otherwise this will make our assert fail\n\t\t\t\tgf_mx_v(current_filter->tasks_mx);\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\t\t\tif (requeue && !skip_filter_task_check) check_task_list(current_filter->tasks, task);\n#endif\n\t\t\t\tcurrent_filter = NULL;\n\t\t\t} else {\n\t\t\t\t//drop task from filter task list\n\t\t\t\tgf_fq_pop(current_filter->tasks);\n\n\t\t\t\t//not requeued, no more tasks, deactivate filter\n\t\t\t\tif (!requeue && !gf_fq_count(current_filter->tasks)) {\n\t\t\t\t\tcurrent_filter->process_th_id = 0;\n\t\t\t\t\tcurrent_filter->in_process = GF_FALSE;\n\t\t\t\t\tcurrent_filter->scheduled_for_next_task = GF_FALSE;\n\t\t\t\t\tgf_mx_v(current_filter->tasks_mx);\n\t\t\t\t\tcurrent_filter = NULL;\n\t\t\t\t} else {\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\t\t\t\tcheck_task_list(fsess->main_thread_tasks, task);\n\t\t\t\t\tcheck_task_list(fsess->tasks, task);\n\t\t\t\t\tcheck_task_list(fsess->tasks_reservoir, task);\n#endif\n\n\t\t\t\t\t//requeue task in current filter\n\t\t\t\t\tif (requeue)\n\t\t\t\t\t\tgf_fq_add(current_filter->tasks, task);\n\n\t\t\t\t\tgf_mx_v(current_filter->tasks_mx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//do not touch the filter task list after this, it has to be mutex protected to ensure proper posting of tasks\n\n\t\tnotified = task->notified;\n\t\tif (requeue) {\n\t\t\t//if requeue on a filter active, use filter queue to avoid another thread grabing the task (we would have concurrent access to the filter)\n\t\t\tif (current_filter) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u re-posted task Filter %s::%s in filter tasks (%d pending)\\n\", sys_thid, task->filter->name, task->log_name, fsess->tasks_pending));\n\t\t\t\ttask->notified = GF_FALSE;\n\t\t\t\t//keep this thread running on the current filter no signaling of semaphore\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u re-posted task Filter %s::%s in %s tasks (%d pending)\\n\", sys_thid, task->filter ? task->filter->name : \"none\", task->log_name, (task->filter && (task->filter->freg->flags & GF_FS_REG_MAIN_THREAD)) ? \"main\" : \"secondary\", fsess->tasks_pending));\n\n\t\t\t\ttask->notified = GF_TRUE;\n\t\t\t\tsafe_int_inc(&fsess->tasks_pending);\n\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\t\t\tcheck_task_list(fsess->main_thread_tasks, task);\n\t\t\t\tcheck_task_list(fsess->tasks, task);\n\t\t\t\tcheck_task_list(fsess->tasks_reservoir, task);\n\t\t\t\tif (prev_current_filter && !skip_filter_task_check) check_task_list(prev_current_filter->tasks, task);\n#endif\n\n\t\t\t\t//main thread\n\t\t\t\tif (task->filter && (task->filter->freg->flags & GF_FS_REG_MAIN_THREAD)) {\n\t\t\t\t\tgf_fq_add(fsess->main_thread_tasks, task);\n\n#ifndef GPAC_DISABLE_THREADS\n\t\t\t\t\t//FIXME, we sometimes miss a sema notfiy resulting in secondary tasks being locked\n\t\t\t\t\t//until we find the cause, notify secondary sema if non-main-thread tasks are scheduled and we are the only task in main\n\t\t\t\t\tif (use_main_sema && (thid==0) && fsess->threads && (gf_fq_count(fsess->main_thread_tasks)==1) && gf_fq_count(fsess->tasks)) {\n\t\t\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_FALSE);\n\t\t\t\t\t}\n#endif\n\t\t\t\t} else {\n\t\t\t\t\tgf_fq_add(fsess->tasks, task);\n\t\t\t\t}\n\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, use_main_sema);\n\t\t\t}\n\t\t} else {\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\t\tcheck_task_list(fsess->main_thread_tasks, task);\n\t\t\tcheck_task_list(fsess->tasks, task);\n\t\t\tcheck_task_list(fsess->tasks_reservoir, task);\n\t\t\tif (prev_current_filter)\n\t\t\t\tcheck_task_list(prev_current_filter->tasks, task);\n\n\t\t\t{\n\t\t\t\tgf_mx_p(fsess->filters_mx);\n\t\t\t\tu32 k, c2 = gf_list_count(fsess->filters);\n\t\t\t\tfor (k=0; k<c2; k++) {\n\t\t\t\t\tGF_Filter *af = gf_list_get(fsess->filters, k);\n\t\t\t\t\tcheck_task_list(af->tasks, task);\n\t\t\t\t}\n\t\t\t\tgf_mx_v(fsess->filters_mx);\n\t\t\t}\n#endif\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u task#%d %p pushed to reservoir\\n\", sys_thid, sess_thread->nb_tasks, task));\n\n\t\t\tif (fsess->tasks_reservoir) {\n\t\t\t\tmemset(task, 0, sizeof(GF_FSTask));\n\t\t\t\tgf_fq_add(fsess->tasks_reservoir, task);\n\t\t\t} else {\n\t\t\t\tgf_free(task);\n\t\t\t}\n\t\t}\n\n\t\t//decrement task counter\n\t\tif (notified) {\n\t\t\tassert(fsess->tasks_pending);\n\t\t\tsafe_int_dec(&fsess->tasks_pending);\n\t\t}\n\t\tif (current_filter) {\n\t\t\tcurrent_filter->process_th_id = 0;\n\t\t\tcurrent_filter->in_process = GF_FALSE;\n\t\t}\n\t\t//not requeuing and first time we have an empty task queue, flush to detect if we are indeed done\n\t\tif (!current_filter && !fsess->tasks_pending && !sess_thread->has_seen_eot && !gf_fq_count(fsess->tasks)) {\n\t\t\t//if not the main thread, or if main thread and task list is empty, enter end of session probing mode\n\t\t\tif (thid || !gf_fq_count(fsess->main_thread_tasks) ) {\n\t\t\t\t//maybe last task, force a notify to check if we are truly done. We only tag \"session done\" for the non-main\n\t\t\t\t//threads, in order to enter the end-of session signaling above\n\t\t\t\tif (thid) sess_thread->has_seen_eot = GF_TRUE;\n\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, use_main_sema);\n\t\t\t}\n\t\t}\n\n\t\tsess_thread->active_time += gf_sys_clock_high_res() - active_start;\n\n\n\t\t//no main thread, return\n\t\tif (!thid && fsess->non_blocking && !current_filter && !fsess->pid_connect_tasks_pending) {\n\t\t\tgf_rmt_end();\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Main thread proc exit\\n\"));\n\t\t\tsafe_int_dec(&fsess->active_threads);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tgf_rmt_end();\n\n\tsafe_int_dec(&fsess->active_threads);\n\t//no main thread, return\n\tif (!thid && fsess->non_blocking) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Main thread proc exit\\n\"));\n\t\treturn 0;\n\t}\n\n#if defined(GPAC_CONFIG_EMSCRIPTEN) && !defined(GPAC_DISABLE_THREADS)\n\tif (thid) {\n\t\tsess_thread->run_time += gf_sys_clock_high_res() - enter_time;\n\t} else\n#endif\n\t\tsess_thread->run_time = gf_sys_clock_high_res() - enter_time;\n\n\tsafe_int_inc(&fsess->nb_threads_stopped);\n\n\tif (!fsess->run_status)\n\t\tfsess->run_status = GF_EOS;\n\n\t// thread exit, notify the semaphores\n\tif (fsess->semaphore_main && ! gf_sema_notify(fsess->semaphore_main, 1)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCHEDULER, (\"Failed to notify main semaphore, might hang up !!\\n\"));\n\t}\n\tif (fsess->semaphore_other && ! gf_sema_notify(fsess->semaphore_other, th_count)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCHEDULER, (\"Failed to notify secondary semaphore, might hang up !!\\n\"));\n\t}\n\n\treturn 0;\n}\n\n\nGF_EXPORT\nGF_Err gf_fs_run(GF_FilterSession *fsess)\n{\n\tassert(fsess);\n\n\t//non blocking mode and threads created, only run main thread proc\n\tif (fsess->non_blocking && (fsess->non_blocking==2) ) {\n#ifdef GPAC_CONFIG_EMSCRIPTEN\n\t\tif (fsess->pending_threads) return GF_NOT_READY;\n#endif\n\t\tgf_fs_thread_proc(&fsess->main_th);\n#ifdef GPAC_CONFIG_EMSCRIPTEN\n\t\tif (fsess->in_main_sem_wait) {\n\t\t\tfsess->in_main_sem_wait = GF_FALSE;\n\t\t\treturn GF_NOT_READY;\n\t\t}\n#endif\n\t\treturn fsess->run_status;\n\t}\n\n\t//run threads\n\tfsess->run_status = GF_OK;\n\tfsess->main_th.has_seen_eot = GF_FALSE;\n\tfsess->nb_threads_stopped = 0;\n\n#ifndef GPAC_DISABLE_THREADS\n\tu32 i, nb_threads;\n\tnb_threads = gf_list_count(fsess->threads);\n\tfor (i=0;i<nb_threads; i++) {\n\t\tGF_SessionThread *sess_th = gf_list_get(fsess->threads, i);\n\t\tif ( gf_th_run(sess_th->th, (gf_thread_run) gf_fs_thread_proc, sess_th) ==GF_OK) {\n#ifdef GPAC_CONFIG_EMSCRIPTEN\n\t\t\tif (fsess->non_blocking) {\n\t\t\t\tsafe_int_inc(&fsess->pending_threads);\n\t\t\t}\n#endif\n\t\t}\n\t}\n#endif\n\n\n\t//run main thread - for emscripten, we only call if no pending threads\n#ifdef GPAC_CONFIG_EMSCRIPTEN\n\tif (!fsess->pending_threads)\n#endif\n\t{\n\t\tgf_fs_thread_proc(&fsess->main_th);\n\t}\n\n\t//non blocking mode init, don't wait for other threads\n\tif (fsess->non_blocking) {\n\t\tfsess->non_blocking = 2;\n\t\treturn fsess->run_status;\n\t}\n\n#ifndef GPAC_DISABLE_THREADS\n\t//blocking mode, wait for all threads to be done\n\twhile (nb_threads+1 != fsess->nb_threads_stopped) {\n\t\tgf_sleep(1);\n\t}\n#endif\n\n\treturn fsess->run_status;\n}\n\nstatic void filter_abort_task(GF_FSTask *task)\n{\n\tGF_FilterEvent evt;\n\tGF_FEVT_INIT(evt, GF_FEVT_STOP, task->pid);\n\n\ttask->pid->filter->freg->process_event(task->pid->filter, &evt);\n\tgf_filter_pid_set_eos(task->pid);\n\ttask->pid->filter->disabled = GF_FILTER_DISABLED;\n\tsafe_int_dec(&task->pid->filter->abort_pending);\n\n}\n\nGF_EXPORT\nGF_Err gf_fs_abort(GF_FilterSession *fsess, GF_FSFlushType flush_type)\n{\n\tu32 i, count;\n\tBool threaded;\n\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Session abort from user, stopping sources\\n\"));\n\tif (!fsess) return GF_BAD_PARAM;\n\tthreaded = (!fsess->filters_mx && (fsess->main_th.th_id==gf_th_id())) ? GF_FALSE : GF_TRUE;\n\n\tif (flush_type==GF_FS_FLUSH_NONE) {\n\t\tfsess->in_final_flush = GF_TRUE;\n\t\tfsess->run_status = GF_EOS;\n\t\treturn GF_OK;\n\t}\n\n\tfsess->in_final_flush = GF_TRUE;\n\n\tgf_mx_p(fsess->filters_mx);\n\tcount = gf_list_count(fsess->filters);\n\t//disable all sources\n\tfor (i=0; i<count; i++) {\n\t\tGF_Filter *filter = gf_list_get(fsess->filters, i);\n\t\tif (!filter) continue;\n\t\t//force end of session on all sources, and on all filters connected to these sources, and dispatch end of stream on all outputs pids of these filters\n\t\t//if we don't propagate on connected filters, we take the risk of not deactivating demuxers working from file\n\t\t//(eg ignoring input packets)\n\t\t//\n\t\t//we shortcut the thread execution state here by directly calling set_eos, we need to lock/unlock our filters carefully\n\t\t//to avoid deadlocks or crashes\n\t\tgf_mx_v(fsess->filters_mx);\n\t\tgf_mx_p(filter->tasks_mx);\n\n\t\tif (!filter->num_input_pids) {\n\t\t\tu32 j, k, l;\n\t\t\tif (!filter->disabled)\n\t\t\t\tfilter->disabled = GF_FILTER_DISABLED;\n\t\t\tfor (j=0; j<filter->num_output_pids; j++) {\n\t\t\t\tconst GF_PropertyValue *p;\n\t\t\t\tGF_FilterPid *pid = gf_list_get(filter->output_pids, j);\n\t\t\t\t//unlock before forcing eos as this could trigger a post task on a filter waiting for this mutex to be unlocked\n\t\t\t\tgf_mx_v(filter->tasks_mx);\n\t\t\t\tgf_filter_pid_set_eos(pid);\n\t\t\t\tgf_mx_p(filter->tasks_mx);\n\t\t\t\t//if the PID has a codecid set (demuxed pid, e.g. ffavin or other grabbers), do not force STOP on its destinations\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CODECID);\n\t\t\t\tif (p) continue;\n\t\t\t\t\n\t\t\t\tfor (k=0; k<pid->num_destinations; k++) {\n\t\t\t\t\tBool force_disable = GF_TRUE;\n\t\t\t\t\tGF_FilterPidInst *pidi = gf_list_get(pid->destinations, k);\n\t\t\t\t\tgf_mx_v(filter->tasks_mx);\n\t\t\t\t\tgf_mx_p(pidi->filter->tasks_mx);\n\t\t\t\t\tfor (l=0; l<pidi->filter->num_output_pids; l++) {\n\t\t\t\t\t\tGF_FilterPid *opid = gf_list_get(pidi->filter->output_pids, l);\n\t\t\t\t\t\t//We cannot directly call process_event as this would make concurrent access to the filter\n\t\t\t\t\t\t//which we guarantee we will never do\n\t\t\t\t\t\t//but we don't want to send a regular stop event which will reset PID buffers, so:\n\t\t\t\t\t\t//- if called in main thread of session in single-thread mode we can safely force a STOP event\n\t\t\t\t\t\t//otherwise:\n\t\t\t\t\t\t//- post a task to the filter\n\t\t\t\t\t\t//- only disable the filter once the filter_abort has been called\n\t\t\t\t\t\t//- only move to EOS if no filter_abort is pending\n\t\t\t\t\t\t//\n\t\t\t\t\t\tif (opid->filter->freg->process_event) {\n\t\t\t\t\t\t\tif (threaded) {\n\t\t\t\t\t\t\t\tsafe_int_inc(&opid->filter->abort_pending);\n\t\t\t\t\t\t\t\tgf_fs_post_task(opid->filter->session, filter_abort_task, opid->filter, opid, \"filter_abort\", NULL);\n\t\t\t\t\t\t\t\tforce_disable = GF_FALSE;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tGF_FilterEvent evt;\n\t\t\t\t\t\t\t\tGF_FEVT_INIT(evt, GF_FEVT_STOP, opid);\n\n\t\t\t\t\t\t\t\topid->filter->freg->process_event(opid->filter, &evt);\n\t\t\t\t\t\t\t\tgf_filter_pid_set_eos(opid);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_filter_pid_set_eos(opid);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tgf_mx_v(pidi->filter->tasks_mx);\n\t\t\t\t\tgf_mx_p(filter->tasks_mx);\n\t\t\t\t\t//no filter_abort pending, disable the filter\n\t\t\t\t\tif (force_disable)\n\t\t\t\t\t\tpidi->filter->disabled = GF_FILTER_DISABLED;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//fast flush and this is a sink: send a stop from all filters connected to the sink\n\t\tif ((flush_type==GF_FS_FLUSH_FAST) && !filter->num_output_pids) {\n\t\t\tu32 j;\n\t\t\tfor (j=0; j<filter->num_input_pids; j++) {\n\t\t\t\tGF_FilterEvent evt;\n\t\t\t\tGF_FilterPidInst *pidi = gf_list_get(filter->input_pids, j);\n\t\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property((GF_FilterPid *) pidi, GF_PROP_PID_STREAM_TYPE);\n\t\t\t\t//if pid is of type FILE, we keep the last connections to the sink active so that muxers can still dispatch pending packets\n\t\t\t\tif (p && (p->value.uint==GF_STREAM_FILE)) {\n\t\t\t\t\tu32 k;\n\t\t\t\t\tgf_mx_p(pidi->pid->filter->tasks_mx);\n\t\t\t\t\tfor (k=0; k<pidi->pid->filter->num_input_pids; k++) {\n\t\t\t\t\t\tGF_FilterPid *pid = gf_list_get(pidi->pid->filter->input_pids, k);\n\t\t\t\t\t\tGF_FEVT_INIT(evt, GF_FEVT_STOP, pid);\n\t\t\t\t\t\tgf_filter_pid_send_event(pid, &evt);\n\t\t\t\t\t\t//and force pid to be in eos, since we do a fast flush EOS may not be dispatched by input filter(s)\n\t\t\t\t\t\tgf_filter_pid_set_eos(pid->pid);\n\t\t\t\t\t}\n\t\t\t\t\tgf_mx_v(pidi->pid->filter->tasks_mx);\n\t\t\t\t}\n\t\t\t\t//otherwise send STOP right away\n\t\t\t\telse {\n\t\t\t\t\tGF_FEVT_INIT(evt, GF_FEVT_STOP, (GF_FilterPid *) pidi);\n\t\t\t\t\tgf_filter_pid_send_event((GF_FilterPid *) pidi, &evt);\n\t\t\t\t\t//and force pid to be in eos, since we do a fast flush EOS may not be dispatched by input filter(s)\n\t\t\t\t\tgf_filter_pid_set_eos(pidi->pid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgf_mx_v(filter->tasks_mx);\n\t\tgf_mx_p(fsess->filters_mx);\n\t}\n\tgf_mx_v(fsess->filters_mx);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_fs_stop(GF_FilterSession *fsess)\n{\n\tu32 i;\n#ifndef GPAC_DISABLE_THREADS\n\tu32 count = fsess->threads ? gf_list_count(fsess->threads) : 0;\n#else\n\tu32 count=0;\n#endif\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Session stop\\n\"));\n\tif (count+1 == fsess->nb_threads_stopped) {\n\t\treturn GF_OK;\n\t}\n\n\tif (!fsess->run_status) {\n\t\tfsess->in_final_flush = GF_TRUE;\n\t\tfsess->run_status = GF_EOS;\n\t}\n\n\t//update runtime for main thread in non-blocking mode\n\tif (fsess->non_blocking) {\n\t\tfsess->main_th.run_time = gf_sys_clock_high_res() - fsess->main_th.run_time;\n\t}\n\n\n\tfor (i=0; i < count; i++) {\n\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_FALSE);\n\t}\n\n\t//wait for all threads to be done, we might still need flushing the main thread queue\n\twhile (fsess->non_blocking) {\n\t\tgf_fs_thread_proc(&fsess->main_th);\n\t\tif (gf_fq_count(fsess->main_thread_tasks))\n\t\t\tcontinue;\n\n\t\tif (count && (count == fsess->nb_threads_stopped) && gf_fq_count(fsess->tasks) ) {\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tif (fsess->non_blocking) {\n\t\tsafe_int_inc(&fsess->nb_threads_stopped);\n\t\tfsess->main_th.has_seen_eot = GF_TRUE;\n\t}\n\n\twhile (count+1 != fsess->nb_threads_stopped) {\n\t\tfor (i=0; i < count; i++) {\n\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_FALSE);\n\t\t}\n\t\tgf_sleep(0);\n\t\t//we may have tasks in main task list posted by other threads\n\t\tif (fsess->non_blocking) {\n\t\t\tgf_fs_thread_proc(&fsess->main_th);\n\t\t\tfsess->main_th.has_seen_eot = GF_TRUE;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nstatic GFINLINE void print_filter_name(GF_Filter *f, Bool skip_id, Bool skip_args)\n{\n\tif (f->freg->flags & GF_FS_REG_SCRIPT) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" \\\"%s\\\"\", f->name));\n\t} else {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"%s\", f->freg->name));\n\t\tif (strcmp(f->name, f->freg->name)) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" \\\"%s\\\"\", f->name));\n\t\t}\n\t}\n\tif (!skip_id && f->id) GF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" ID %s\", f->id));\n\tif (f->dynamic_filter || skip_args) return;\n\n\tif (!f->src_args && !f->orig_args && !f->dst_args && !f->dynamic_source_ids) return;\n\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" (\"));\n\tif (f->src_args) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"%s\", f->src_args));\n\t}\n\telse if (f->orig_args) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"%s\", f->orig_args));\n\t}\n\telse if (f->dst_args) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"%s\", f->dst_args));\n\t}\n\n\tif (f->dynamic_source_ids) GF_LOG(GF_LOG_INFO, GF_LOG_APP, (\",resolved SID:%s\", f->source_ids));\n\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\")\"));\n}\n\nGF_EXPORT\nvoid gf_fs_print_stats(GF_FilterSession *fsess)\n{\n#ifndef GPAC_DISABLE_THREADS\n\tu64 run_time=0, active_time=0, nb_tasks=0;\n#endif\n\tu32 i, count;\n#ifndef GPAC_DISABLE_LOG\n\tu32 nb_filters=0;\n#endif\n\n\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\n\"));\n\tgf_mx_p(fsess->filters_mx);\n\n\tcount=gf_list_count(fsess->filters);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Filter *f = gf_list_get(fsess->filters, i);\n\t\tif (f->multi_sink_target) continue;\n#ifndef GPAC_DISABLE_LOG\n\t\tnb_filters++;\n#endif\n\t}\n\n\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"Filter stats - %d filters\\n\", nb_filters));\n\tfor (i=0; i<count; i++) {\n\t\tu32 k, ipids, opids;\n\t\tGF_Filter *f = gf_list_get(fsess->filters, i);\n\t\tif (!f || f->multi_sink_target) continue;\n\n\t\tgf_mx_v(fsess->filters_mx);\n\t\tgf_mx_p(f->tasks_mx);\n\n\t\tipids = f->num_input_pids;\n\t\topids = f->num_output_pids;\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\tFilter \"));\n\t\tprint_filter_name(f, GF_FALSE, GF_FALSE);\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" : %d input pids %d output pids \"LLU\" tasks \"LLU\" us process time\\n\", ipids, opids, f->nb_tasks_done, f->time_process));\n\n\t\tif (ipids) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\t\\t\"LLU\" packets processed \"LLU\" bytes processed\", f->nb_pck_processed, f->nb_bytes_processed));\n\t\t\tif (f->time_process) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" (%g pck/sec %g mbps)\", (Double) f->nb_pck_processed*1000000/f->time_process, (Double) f->nb_bytes_processed*8/f->time_process));\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\n\"));\n\t\t}\n\t\tif (opids) {\n\t\t\tif (f->nb_hw_pck_sent) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\t\\t\"LLU\" hardware frames sent\", f->nb_hw_pck_sent));\n\t\t\t\tif (f->time_process) {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" (%g pck/sec)\", (Double) f->nb_hw_pck_sent*1000000/f->time_process));\n\t\t\t\t}\n\n\t\t\t} else if (f->nb_pck_sent) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\t\\t\"LLU\" packets sent \"LLU\" bytes sent\", f->nb_pck_sent, f->nb_bytes_sent));\n\t\t\t\tif (f->time_process) {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" (%g pck/sec %g mbps)\", (Double) f->nb_pck_sent*1000000/f->time_process, (Double) f->nb_bytes_sent*8/f->time_process));\n\t\t\t\t}\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\n\"));\n\t\t}\n\n\t\tfor (k=0; k<ipids; k++) {\n\t\t\tGF_FilterPidInst *pid = gf_list_get(f->input_pids, k);\n\t\t\tif (!pid->pid) continue;\n\t\t\tif (pid->requires_full_data_block && (pid->nb_reagg_pck != pid->pid->nb_pck_sent) ) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\t\\t* input PID %s: %d frames (%d packets) received\\n\", pid->pid->name, pid->nb_reagg_pck, pid->pid->nb_pck_sent));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\t\\t* input PID %s: %d packets received\\n\", pid->pid->name, pid->pid->nb_pck_sent));\n\t\t\t}\n\t\t}\n#ifndef GPAC_DISABLE_LOG\n\t\tfor (k=0; k<opids; k++) {\n\t\t\tGF_FilterPid *pid = gf_list_get(f->output_pids, k);\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\t\\t* output PID %s: %d packets sent\\n\", pid->name, pid->nb_pck_sent));\n\t\t}\n\t\tif (f->nb_errors) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\t\\t%d errors while processing\\n\", f->nb_errors));\n\t\t}\n#endif\n\n\t\tgf_mx_v(f->tasks_mx);\n\t\tgf_mx_p(fsess->filters_mx);\n\t}\n\tgf_mx_v(fsess->filters_mx);\n\n#ifndef GPAC_DISABLE_THREADS\n\tcount=gf_list_count(fsess->threads);\n\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"Session stats - threads %d\\n\\tThread 1: \", 1+count));\n#else\n\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"Session stats: \"));\n#endif\n\n\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"run_time \"LLU\" us active_time \"LLU\" us nb_tasks \"LLU\"\\n\", fsess->main_th.run_time, fsess->main_th.active_time, fsess->main_th.nb_tasks));\n\n#ifndef GPAC_DISABLE_THREADS\n\trun_time+=fsess->main_th.run_time;\n\tactive_time+=fsess->main_th.active_time;\n\tnb_tasks+=fsess->main_th.nb_tasks;\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_SessionThread *s = gf_list_get(fsess->threads, i);\n\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\tThread %u: run_time \"LLU\" us active_time \"LLU\" us nb_tasks \"LLU\"\\n\", i+2, s->run_time, s->active_time, s->nb_tasks));\n\n\t\trun_time+=s->run_time;\n\t\tactive_time+=s->active_time;\n\t\tnb_tasks+=s->nb_tasks;\n\t}\n\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\nTotal: run_time \"LLU\" us active_time \"LLU\" us nb_tasks \"LLU\"\\n\", run_time, active_time, nb_tasks));\n#endif\n}\n\nstatic void gf_fs_print_filter_outputs(GF_Filter *f, GF_List *filters_done, u32 indent, GF_FilterPid *pid, GF_Filter *alias_for, u32 src_num_tiled_pids, Bool skip_print, s32 nb_recursion, u32 max_length)\n{\n\tu32 i=0;\n\n\tif (!skip_print) {\n\t\twhile (i<indent) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"-\"));\n\t\t\ti++;\n\t\t}\n\n\t\tif (src_num_tiled_pids>1) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"(tilePID[%d]) \", src_num_tiled_pids));\n\t\t}\n\t\telse if (pid) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"(PID %s)\", pid->name));\n\t\t}\n\t\tif (max_length) {\n\t\t\tu32 l;\n\t\t\tif (src_num_tiled_pids) {\n\t\t\t\tchar szName[50];\n\t\t\t\tsprintf(szName, \"PID[%d]\", src_num_tiled_pids);\n\t\t\t\tl = (u32) strlen(szName);\n\t\t\t} else {\n\t\t\t\tl = (u32) strlen(pid->name);\n\t\t\t}\n\t\t\twhile (l<max_length) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" \"));\n\t\t\t\t\tl++;\n\t\t\t}\n\t\t}\n\t\tif (nb_recursion>0) {\n\t\t\tu32 k=0;\n\t\t\twhile (k<(u32) nb_recursion-1) {\n\t\t\t\tk++;\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" \"));\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\\\\\n\"));\n\t\t\treturn;\n\t\t}\n\t\tif (pid) {\n\t\t\tif (nb_recursion<0) {\n\t\t\t\tu32 k=(u32) -nb_recursion;\n\t\t\t\twhile (k>1) {\n\t\t\t\t\tk--;\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"-\"));\n\t\t\t\t}\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\">\"));\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" \"));\n\t\t}\n\n\t\tprint_filter_name(f, GF_TRUE, GF_FALSE);\n\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" (%s=%u)\\n\", f->dynamic_filter ? \"dyn_idx\" : \"idx\", 1+gf_list_find(f->session->filters, f) ));\n\t}\n\n\tif (filters_done && (gf_list_find(filters_done, f)>=0))\n\t\treturn;\n\n\tif (filters_done)\n\t\tgf_list_add(filters_done, f);\n\tif (alias_for && !skip_print) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" (<=> \"));\n\t\tprint_filter_name(alias_for, GF_TRUE, GF_TRUE);\n\t\tif (alias_for->id) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" ID=%s\", alias_for->id));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" ptr=%p\", alias_for));\n\t\t}\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\")\\n\"));\n\t}\n\n\tGF_List *dests = gf_list_new();\n\tfor (i=0; i<f->num_output_pids; i++) {\n\t\tu32 j;\n\t\tGF_FilterPid *pidout = gf_list_get(f->output_pids, i);\n\t\tfor (j=0; j<pidout->num_destinations; j++) {\n\t\t\tGF_FilterPidInst *pidi = gf_list_get(pidout->destinations, j);\n\t\t\tif (gf_list_find(dests, pidi->filter)<0)\n\t\t\t\tgf_list_add(dests, pidi->filter);\n\t\t}\n\t}\n\n\twhile (gf_list_count(dests)) {\n\tGF_Filter *dest = gf_list_pop_front(dests);\n\tGF_List *pids = gf_list_new();\n\tu32 max_name_len=0;\n\tu32 num_tile_pids=0;\n\tfor (i=0; i<f->num_output_pids; i++) {\n\t\tu32 j;\n\t\tGF_FilterPid *pidout = gf_list_get(f->output_pids, i);\n\t\tfor (j=0; j<pidout->num_destinations; j++) {\n\t\t\tGF_FilterPidInst *pidi = gf_list_get(pidout->destinations, j);\n\t\t\tif (pidi->filter != dest) continue;\n\t\t\tgf_list_add(pids, pidi);\n\t\t}\n\t\tu32 plen = (u32) strlen(pidout->name);\n\n\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(pidout, GF_PROP_PID_CODECID);\n\t\tif (p &&\n\t\t\t((p->value.uint==GF_CODECID_HEVC_TILES) || (p->value.uint==GF_CODECID_VVC_SUBPIC))\n\t\t) {\n\t\t\tplen = 0;\n\t\t\tif (!num_tile_pids) {\n\t\t\t\tfor (j=0; j<f->num_output_pids; j++) {\n\t\t\t\t\tGF_FilterPid *apid = gf_list_get(f->output_pids, j);\n\t\t\t\t\tp = gf_filter_pid_get_property(apid, GF_PROP_PID_CODECID);\n\t\t\t\t\tif (p &&\n\t\t\t\t\t\t((p->value.uint==GF_CODECID_HEVC_TILES) || (p->value.uint==GF_CODECID_VVC_SUBPIC))\n\t\t\t\t\t) {\n\t\t\t\t\t\tnum_tile_pids++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tplen = 5;\n\t\t\t\tj=0;\n\t\t\t\twhile (j<num_tile_pids) {\n\t\t\t\t\tplen+=1;\n\t\t\t\t\tj+=10;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (plen>max_name_len) max_name_len = plen;\n\t}\n\ts32 nb_pids_print = gf_list_count(pids);\n\tif (nb_pids_print==1) nb_pids_print = 0;\n\tif (num_tile_pids) nb_pids_print -= num_tile_pids-1;\n\ts32 nb_final_pids = nb_pids_print;\n\tif (nb_pids_print) nb_pids_print++;\n\tBool first_tile = GF_TRUE;\n\n\tfor (i=0; i<f->num_output_pids; i++) {\n\t\tu32 j, k;\n\t\tBool is_tiled = GF_FALSE;\n\t\tBool skip_tiled = skip_print;\n\n\t\tGF_FilterPid *pidout = gf_list_get(f->output_pids, i);\n\t\tif (num_tile_pids) {\n\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(pidout, GF_PROP_PID_CODECID);\n\t\t\tif (p &&\n\t\t\t\t((p->value.uint==GF_CODECID_HEVC_TILES) || (p->value.uint==GF_CODECID_VVC_SUBPIC))\n\t\t\t) {\n\t\t\t\tis_tiled = GF_TRUE;\n\t\t\t}\n\t\t}\n\n\t\tfor (j=0; j<pidout->num_destinations; j++) {\n\t\t\tGF_Filter *alias = NULL;\n\t\t\tGF_FilterPidInst *pidi = gf_list_get(pidout->destinations, j);\n\t\t\tif (pidi->filter != dest) continue;\n\n\t\t\tgf_list_del_item(pids, pidi);\n\t\t\tif (nb_pids_print && !gf_list_count(pids))\n\t\t\t\tnb_pids_print = 0;\n\t\t\telse if (is_tiled) {\n\t\t\t\tif (!first_tile) continue;\n\t\t\t\tnb_pids_print = 0;\n\t\t\t\tfirst_tile = GF_FALSE;\n\t\t\t}\n\n\t\t\tfor (k=0; k<gf_list_count(f->destination_filters); k++) {\n\t\t\t\talias = gf_list_get(f->destination_filters, k);\n\t\t\t\tif (alias->multi_sink_target == pidi->filter)\n\t\t\t\t\tbreak;\n\t\t\t\talias = NULL;\n\t\t\t}\n\t\t\tif (alias) {\n\t\t\t\tgf_fs_print_filter_outputs(alias, filters_done, indent+1, pidout, pidi->filter, is_tiled ? num_tile_pids : src_num_tiled_pids, skip_tiled, nb_pids_print-nb_final_pids, max_name_len);\n\t\t\t} else {\n\t\t\t\tgf_fs_print_filter_outputs(pidi->filter, filters_done, indent+1, pidout, NULL, is_tiled ? num_tile_pids : src_num_tiled_pids, skip_tiled, nb_pids_print-nb_final_pids, max_name_len);\n\t\t\t}\n\t\t}\n\t\tif (nb_pids_print) nb_pids_print++;\n\t}\n\tgf_list_del(pids);\n\t}\n\tgf_list_del(dests);\n}\n\nstatic void gf_fs_print_not_connected_filters(GF_FilterSession *fsess, GF_List *filters_done, Bool ignore_sinks)\n{\n\tu32 i, count;\n\tBool has_unconnected=GF_FALSE;\n\tcount=gf_list_count(fsess->filters);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Filter *f = gf_list_get(fsess->filters, i);\n\t\t//only dump not connected ones\n\t\tif (f->num_input_pids || f->num_output_pids || f->multi_sink_target || f->nb_tasks_done) continue;\n\t\tif (f->disabled==GF_FILTER_DISABLED_HIDE) continue;\n\n\t\tif (ignore_sinks) {\n\t\t\tBool has_outputs;\n\t\t\tif (f->forced_caps)\n\t\t\t\thas_outputs = gf_filter_has_out_caps(f->forced_caps, f->nb_forced_caps);\n\t\t\telse\n\t\t\t\thas_outputs = gf_filter_has_out_caps(f->freg->caps, f->freg->nb_caps);\n\t\t\tif (!has_outputs) continue;\n\t\t}\n\n\t\tif (!has_unconnected) {\n\t\t\thas_unconnected = GF_TRUE;\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_APP, (\"Filters not connected:\\n\"));\n\t\t}\n\t\tgf_fs_print_filter_outputs(f, filters_done, 0, NULL, NULL, 0, GF_FALSE, 0, 0);\n\t}\n}\n\nGF_EXPORT\nvoid gf_fs_print_non_connected(GF_FilterSession *fsess)\n{\n\tgf_fs_print_not_connected_filters(fsess, NULL, GF_FALSE);\n}\n\nGF_EXPORT\nvoid gf_fs_print_non_connected_ex(GF_FilterSession *fsess, Bool ignore_sinks)\n{\n\tgf_fs_print_not_connected_filters(fsess, NULL, ignore_sinks);\n}\n\nGF_EXPORT\nvoid gf_fs_print_connections(GF_FilterSession *fsess)\n{\n\tu32 i, count;\n\tBool has_undefined=GF_FALSE;\n\tBool has_connected=GF_FALSE;\n\tGF_List *filters_done;\n\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\n\"));\n\tgf_mx_p(fsess->filters_mx);\n\n\tfilters_done = gf_list_new();\n\n\tcount=gf_list_count(fsess->filters);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Filter *f = gf_list_get(fsess->filters, i);\n\t\t//only dump sources\n\t\tif (f->num_input_pids) continue;\n\t\tif (!f->num_output_pids) continue;\n\t\tif (!has_connected) {\n\t\t\thas_connected = GF_TRUE;\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"Filters connected:\\n\"));\n\t\t}\n\t\tgf_fs_print_filter_outputs(f, filters_done, 0, NULL, NULL, 0, GF_FALSE, 0, 0);\n\t}\n\n\tgf_fs_print_not_connected_filters(fsess, filters_done, GF_FALSE);\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_Filter *f = gf_list_get(fsess->filters, i);\n\t\tif (f->multi_sink_target) continue;\n\t\tif (gf_list_find(filters_done, f)>=0) continue;\n\t\tif (f->disabled==GF_FILTER_DISABLED_HIDE) continue;\n\t\tif (!has_undefined) {\n\t\t\thas_undefined = GF_TRUE;\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"Filters in unknown connection state:\\n\"));\n\t\t}\n\t\tgf_fs_print_filter_outputs(f, filters_done, 0, NULL, NULL, 0, GF_FALSE, 0, 0);\n\t}\n\n\tgf_mx_v(fsess->filters_mx);\n\tgf_list_del(filters_done);\n}\n\nGF_EXPORT\nvoid gf_fs_print_unused_args(GF_FilterSession *fsess, const char *ignore_args)\n{\n\tu32 idx = 0;\n\tconst char *argname;\n\tu32 argtype;\n\n\twhile (1) {\n\t\tBool found = GF_FALSE;\n\t\tconst char *loc_arg;\n\t\tif (gf_fs_enum_unmapped_options(fsess, &idx, &argname, &argtype, NULL, NULL)==GF_FALSE)\n\t\t\tbreak;\n\n\t\tloc_arg = ignore_args;\n\t\twhile (loc_arg) {\n\t\t\tu32 len;\n\t\t\tchar *sep;\n\t\t\tchar *match = strstr(loc_arg, argname);\n\t\t\tif (!match) break;\n\t\t\tlen = (u32) strlen(argname);\n\t\t\tif (!match[len] || (match[len]==',')) {\n\t\t\t\tfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsep = strchr(loc_arg, ',');\n\t\t\tif (!sep) break;\n\t\t\tloc_arg = sep+1;\n\t\t}\n\t\tif (found) continue;\n\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_APP, (\"Arg %s set but not used\\n\", argname));\n\t}\n}\n\nGF_EXPORT\nvoid gf_fs_send_update(GF_FilterSession *fsess, const char *fid, GF_Filter *filter, const char *name, const char *val, GF_EventPropagateType propagate_mask)\n{\n\tGF_FilterUpdate *upd;\n\tu32 i, count;\n\tchar *sep = NULL;\n\tBool removed = GF_FALSE;\n\tif ((!fid && !filter) || !name) return;\n\tif (!fsess) {\n\t\tif (!filter) return;\n\t\tfsess = filter->session;\n\t}\n\n\tgf_mx_p(fsess->filters_mx);\n\n\tif (!filter) {\n\t\tGF_Filter *reg_filter = NULL;\n\t\tcount = gf_list_count(fsess->filters);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tfilter = gf_list_get(fsess->filters, i);\n\t\t\tif (filter->id && !strcmp(filter->id, fid)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (filter->name && !strcmp(filter->name, fid)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!reg_filter && !strcmp(filter->freg->name, fid))\n\t\t\t\treg_filter = filter;\n\t\t\tfilter = NULL;\n\t\t}\n\t\tif (!filter)\n\t\t\tfilter = reg_filter;\n\t}\n\n\tif (filter && filter->multi_sink_target)\n\t\tfilter = filter->multi_sink_target;\n\n\tremoved = (!filter || filter->removed || filter->finalized) ? GF_TRUE : GF_FALSE;\n\tgf_mx_v(fsess->filters_mx);\n\n\tif (removed) return;\n\n\tif (!val) {\n\t\tsep = strchr(name, fsess->sep_name);\n\t\tif (sep) sep[0] = 0;\n\t}\n\n\t//find arg and check if it is only a sync update - if so do it now\n\ti=0;\n\twhile (filter->freg->args) {\n\t\tconst GF_FilterArgs *a = &filter->freg->args[i];\n\t\ti++;\n\t\tif (!a || !a->arg_name) break;\n\n\t\tif ((a->flags & GF_FS_ARG_META) && !strcmp(a->arg_name, \"*\")) {\n\t\t\tcontinue;\n\t\t} else if (strcmp(a->arg_name, name)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (a->flags & GF_FS_ARG_UPDATE_SYNC) {\n\t\t\tgf_mx_p(filter->tasks_mx);\n\t\t\tgf_filter_update_arg_apply(filter, name, sep ? sep+1 : val, GF_TRUE);\n\t\t\tgf_mx_v(filter->tasks_mx);\n\t\t\tif (sep) sep[0] = fsess->sep_name;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\n\tGF_SAFEALLOC(upd, GF_FilterUpdate);\n\tif (!val) {\n\t\tupd->name = gf_strdup(name);\n\t\tupd->val = sep ? gf_strdup(sep+1) : NULL;\n\t\tif (sep) sep[0] = fsess->sep_name;\n\t} else {\n\t\tupd->name = gf_strdup(name);\n\t\tupd->val = gf_strdup(val);\n\t}\n\tupd->recursive = propagate_mask;\n\tgf_fs_post_task(fsess, gf_filter_update_arg_task, filter, NULL, \"update_arg\", upd);\n}\n\nstatic GF_FilterProbeScore probe_meta_check_builtin_format(GF_FilterSession *fsess, GF_FilterRegister *freg, const char *url, const char *mime, char *fargs)\n{\n\tchar szExt[100];\n\tconst char *ext = gf_file_ext_start(url);\n\tu32 len=0, i, j, count = gf_list_count(fsess->registry);\n\tif (ext) {\n\t\text++;\n\t\tlen = (u32) strlen(ext);\n\t}\n\t//check in filter args if we have a format set, in which case replace URL ext by the given format\n\tif (fargs) {\n\t\tchar szExtN[10];\n\t\tchar *ext_arg;\n\t\tsprintf(szExtN, \"ext%c\", fsess->sep_name);\n\t\text_arg = strstr(fargs, szExtN);\n\t\tif (ext_arg && (ext_arg>fargs) && (ext_arg[-1] != fsess->sep_name))\n\t\t\text_arg = NULL;\n\n\t\tif (ext_arg) {\n\t\t\tchar *next_arg;\n\t\t\text_arg+=4;\n\t\t\tnext_arg = strchr(ext_arg, fsess->sep_args);\n\t\t\tif (next_arg) {\n\t\t\t\tlen = (u32) (next_arg - ext_arg);\n\t\t\t} else {\n\t\t\t\tlen = (u32) strlen(ext_arg);\n\t\t\t}\n\t\t\tif (len>99) len=99;\n\t\t\tstrncpy(szExt, ext_arg, len);\n\t\t\tszExt[len] = 0;\n\t\t\text = szExt;\n\t\t}\n\t}\n\n\tif (mime) {\n\t\tif (strstr(mime, \"/mp4\")) return GF_FPROBE_MAYBE_SUPPORTED;\n\t}\n\n\tfor (i=0; i<count; i++) {\n\t\tconst GF_FilterArgs *dst_arg=NULL;\n\t\tGF_FilterRegister *reg = gf_list_get(fsess->registry, i);\n\t\tif (reg==freg) continue;\n\t\tif (reg->flags & GF_FS_REG_META) continue;\n\n\t\tj=0;\n\t\twhile (reg->args) {\n\t\t\tdst_arg = &reg->args[j];\n\t\t\tif (!dst_arg || !dst_arg->arg_name) {\n\t\t\t\tdst_arg=NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!strcmp(dst_arg->arg_name, \"dst\") && !(dst_arg->flags&GF_FS_ARG_SINK_ALIAS)) break;\n\t\t\tdst_arg = NULL;\n\t\t\tj++;\n\t\t}\n\t\t/*check prober*/\n\t\tif (dst_arg) {\n\t\t\tif (reg->probe_url) {\n\t\t\t\tGF_FilterProbeScore s = reg->probe_url(url, mime);\n\t\t\t\tif (s==GF_FPROBE_SUPPORTED)\n\t\t\t\t\treturn GF_FPROBE_MAYBE_SUPPORTED;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* check muxers*/\n\t\tfor (j=0; j<reg->nb_caps; j++) {\n\t\t\tchar *value=NULL;\n\t\t\tconst char *pattern = NULL;\n\t\t\tconst GF_FilterCapability *cap = &reg->caps[j];\n\t\t\tif (! (cap->flags & GF_CAPFLAG_OUTPUT) )\n\t\t\t\tcontinue;\n\t\t\tif (cap->flags & GF_CAPFLAG_EXCLUDED)\n\t\t\t\tcontinue;\n\n\t\t\tif (cap->code==GF_PROP_PID_FILE_EXT) {\n\t\t\t\tif (ext) {\n\t\t\t\t\tvalue = cap->val.value.string;\n\t\t\t\t\tpattern = ext;\n\t\t\t\t}\n\t\t\t} else if (cap->code==GF_PROP_PID_MIME) {\n\t\t\t\tif (mime) {\n\t\t\t\t\tvalue = cap->val.value.string;\n\t\t\t\t\tpattern = mime;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (value) {\n\t\t\t\tchar *match = strstr(value, pattern);\n\t\t\t\tif (!match) break;\n\t\t\t\tif (!match[len] || match[len]=='|')\n\t\t\t\t\treturn GF_FPROBE_MAYBE_SUPPORTED;\n\t\t\t\tvalue = match+1;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_FPROBE_SUPPORTED;\n}\n\nstatic GF_Filter *locate_alias_sink(GF_Filter *filter, const char *url, const char *mime_type)\n{\n\tu32 i;\n\tfor (i=0; i<filter->num_output_pids; i++) {\n\t\tu32 j;\n\t\tGF_FilterPid *pid = gf_list_get(filter->output_pids, i);\n\t\tfor (j=0; j<pid->num_destinations; j++) {\n\t\t\tGF_Filter *f;\n\t\t\tGF_FilterPidInst *pidi = gf_list_get(pid->destinations, j);\n\t\t\tif (!pidi->filter) continue;\n\t\t\tif (pidi->filter->act_as_sink && pidi->filter->freg->use_alias\n\t\t\t\t&& pidi->filter->freg->use_alias(pidi->filter, url, mime_type)\n\t\t\t) {\n\t\t\t\treturn pidi->filter;\n\t\t\t}\n\t\t\t//recursovely walk towards the sink\n\t\t\tf = locate_alias_sink(pidi->filter, url, mime_type);\n\t\t\tif (f) return f;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nBool filter_solve_gdocs(const char *url, char szPath[GF_MAX_PATH]);\n\nGF_Filter *gf_fs_load_source_dest_internal(GF_FilterSession *fsess, const char *url, const char *user_args, const char *parent_url, GF_Err *err, GF_Filter *filter, GF_Filter *dst_filter, Bool for_source, Bool no_args_inherit, Bool *probe_only, const GF_FilterRegister **probe_reg)\n{\n\tGF_FilterProbeScore score = GF_FPROBE_NOT_SUPPORTED;\n\tGF_FilterRegister *candidate_freg=NULL;\n\tGF_Filter *alias_for_filter = NULL;\n\tconst GF_FilterArgs *src_dst_arg=NULL;\n\tu32 i, count, user_args_len, arg_type;\n\tchar szForceReg[20];\n\tchar szMime[50];\n\tchar szForceExt[20];\n\tGF_Err e;\n\tconst char *force_freg = NULL;\n\tchar *sURL, *mime_type, *args, *sep;\n\tchar szExt[50];\n\tBool free_url=GF_FALSE;\n\tmemset(szExt, 0, sizeof(szExt));\n\n\tif (!url) {\n\t\tif (err) *err = GF_BAD_PARAM;\n\t\treturn NULL;\n\t}\n\tif (err) *err = GF_OK;\n\n\tszForceExt[0] = 0;\n\tmime_type = NULL;\n\t//destination, extract mime from arguments\n\tif (!for_source) {\n\t\tsprintf(szMime, \"%cmime=\", fsess->sep_args);\n\t\tmime_type = strstr(url, szMime);\n\t\tif (!mime_type && user_args)\n\t\t\tmime_type = strstr(user_args, szMime);\n\n\t\tif (mime_type) {\n\t\t\tstrncpy(szMime, mime_type+6, 49);\n\t\t\tszMime[49]=0;\n\t\t\tsep = strchr(szMime, fsess->sep_args);\n\t\t\tif (sep) sep[0] = 0;\n\t\t\tmime_type = szMime;\n\t\t}\n\t\tsprintf(szForceExt, \"%cext=\", fsess->sep_args);\n\t\tchar *ext = strstr(url, szForceExt);\n\t\tif (ext) {\n\t\t\text+=5;\n\t\t\tsnprintf(szForceExt, 19, \"test.%s\", ext);\n\t\t\tszForceExt[19]=0;\n\t\t\text = strchr(szForceExt, fsess->sep_args);\n\t\t\tif (ext) ext[0] = 0;\n\t\t} else {\n\t\t\tszForceExt[0] = 0;\n\t\t}\n\t}\n\tsURL = NULL;\n\tif (filter) {\n\t\tsURL = (char *) url;\n\t} else {\n\t\tchar szSolvedPath[GF_MAX_PATH];\n\t\tBool is_local;\n\n\t\tif (!strncmp(url, \"$GDOCS\", 6)) {\n\t\t\tif (filter_solve_gdocs(url, szSolvedPath))\n\t\t\t\turl = szSolvedPath;\n\t\t}\n\t\t/*used by GUIs scripts to skip URL concatenation*/\n\t\tif (!strncmp(url, \"gpac://\", 7)) sURL = gf_strdup(url+7);\n\t\t/*opera-style localhost URLs*/\n\t\telse if (!strncmp(url, \"file://localhost\", 16)) sURL = gf_strdup(url+16);\n\t\telse if (parent_url) sURL = gf_url_concatenate(parent_url, url);\n\n\t\t/*path absolute*/\n\t\tif (!sURL) sURL = gf_strdup(url);\n\t\tfree_url=GF_TRUE;\n\n\t\tif (!strncmp(sURL, \"gpac://\", 7)) {\n\t\t\tu32 ulen = (u32) strlen(sURL+7);\n\t\t\tmemmove(sURL, sURL+7, ulen);\n\t\t\tsURL[ulen]=0;\n\t\t}\n\t\t//remove any filter arguments in URL before checking if it is local\n\t\t//not doing so will lead wrong result if one argument is a URL (eg \":#BUrl=http://\")\n\t\tsep = (char *) gf_fs_path_escape_colon(fsess, sURL);\n\t\tif (sep) sep[0] = 0;\n\t\tis_local = gf_url_is_local(sURL);\n\t\tif (sep) sep[0] = fsess->sep_args;\n\n\t\tif (for_source && is_local && !strstr(sURL, \"isobmff://\")) {\n\t\t\tchar *frag_par, *cgi, *ext_start;\n\t\t\tchar f_c=0;\n\t\t\tgf_url_to_fs_path(sURL);\n\t\t\tsep = (char *)gf_fs_path_escape_colon(fsess, sURL);\n\t\t\tif (sep) sep[0] = 0;\n\n\t\t\text_start = gf_file_ext_start(sURL);\n\t\t\tif (!ext_start) ext_start = sURL;\n\t\t\tfrag_par = strchr(ext_start, '#');\n\t\t\tcgi = strchr(ext_start, '?');\n\t\t\tif (frag_par && cgi && (cgi<frag_par))\n\t\t\t\tfrag_par = cgi;\n\n\t\t\tif (frag_par) {\n\t\t\t\tf_c = frag_par[0];\n\t\t\t\tfrag_par[0] = 0;\n\t\t\t}\n\n\t\t\tif (strcmp(sURL, \"null\") && strncmp(sURL, \"rand\", 4) && strcmp(sURL, \"-\") && strcmp(sURL, \"stdin\") && ! gf_file_exists(sURL)) {\n\t\t\t\tchar szPath[GF_MAX_PATH];\n\t\t\t\tBool try_js = gf_fs_solve_js_script(szPath, sURL, NULL);\n\t\t\t\tif (sep) sep[0] = fsess->sep_args;\n\t\t\t\tif (frag_par) frag_par[0] = f_c;\n\t\t\t\tgf_free(sURL);\n\n\t\t\t\tif (try_js) {\n\t\t\t\t\tif (!strncmp(url, \"gpac://\", 7)) url += 7;\n\t\t\t\t\tfilter = gf_fs_load_filter_internal(fsess, url, err, probe_only);\n\t\t\t\t\tif (probe_only) return NULL;\n\n\t\t\t\t\tif (filter) {\n\t\t\t\t\t\t//for link resolution\n\t\t\t\t\t\tif (dst_filter)\t{\n\t\t\t\t\t\t\tif (gf_list_find(filter->destination_links, dst_filter)<0)\n\t\t\t\t\t\t\t\tgf_list_add(filter->destination_links, dst_filter);\n\t\t\t\t\t\t\t//to remember our connection target\n\t\t\t\t\t\t\tfilter->target_filter = dst_filter;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn filter;\n\t\t\t\t}\n\n\t\t\t\tif (err) *err = GF_URL_ERROR;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (frag_par) frag_par[0] = f_c;\n\t\t\tif (sep) sep[0] = fsess->sep_args;\n\t\t}\n\t}\n\tBool needs_escape;\n\tsep = (char *)gf_fs_path_escape_colon_ex(fsess, sURL, &needs_escape, for_source);\n\n\tsprintf(szForceReg, \"gfreg%c\", fsess->sep_name);\n\tforce_freg = NULL;\n\tif (sep) {\n\t\tsep[0] = 0;\n\t\tforce_freg = strstr(sep+1, szForceReg);\n\t}\n\tif (!force_freg && user_args) {\n\t\tforce_freg = strstr(user_args, szForceReg);\n\t}\n\tif (force_freg)\n\t\tforce_freg += 6;\n\n\n\tif (!for_source && dst_filter) {\n\t\talias_for_filter = locate_alias_sink(dst_filter, sURL, mime_type);\n\t\tif (alias_for_filter) {\n\t\t\tcandidate_freg = (GF_FilterRegister *) alias_for_filter->freg;\n\t\t}\n\t}\n\nrestart:\n\t//check all our registered filters\n\tcount = gf_list_count(fsess->registry);\n\tif (candidate_freg) count = 0;\n\tfor (i=0; i<count; i++) {\n\t\tu32 j;\n\t\tGF_FilterProbeScore s;\n\t\tGF_FilterRegister *freg = gf_list_get(fsess->registry, i);\n\t\tif (! freg->probe_url) continue;\n\t\tif (force_freg && strncmp(force_freg, freg->name, strlen(freg->name))) continue;\n\t\tif (! freg->args) continue;\n\t\tif (filter && (gf_list_find(filter->blacklisted, freg) >=0)) continue;\n\n\t\tj=0;\n\t\twhile (freg->args) {\n\t\t\tsrc_dst_arg = &freg->args[j];\n\t\t\tif (!src_dst_arg || !src_dst_arg->arg_name) {\n\t\t\t\tsrc_dst_arg=NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (for_source && !strcmp(src_dst_arg->arg_name, \"src\")) break;\n\t\t\telse if (!for_source && !strcmp(src_dst_arg->arg_name, \"dst\") && !(src_dst_arg->flags&GF_FS_ARG_SINK_ALIAS)) break;\n\t\t\tsrc_dst_arg = NULL;\n\t\t\tj++;\n\t\t}\n\t\tif (!src_dst_arg)\n\t\t\tcontinue;\n\n\t\ts = freg->probe_url(sURL, mime_type);\n\t\tif (!for_source && (s==GF_FPROBE_MAYBE_NOT_SUPPORTED)) {\n\t\t\ts = szForceExt[0] ? freg->probe_url(szForceExt, mime_type) : GF_FPROBE_NOT_SUPPORTED;\n\t\t}\n\t\t/* destination meta filter: change GF_FPROBE_SUPPORTED to GF_FPROBE_MAYBE_SUPPORTED for internal mux formats\n\t\tin order to avoid always giving the hand to the meta filter*/\n\t\tif (!for_source && (s == GF_FPROBE_SUPPORTED) && (freg->flags & GF_FS_REG_META)) {\n\t\t\ts = probe_meta_check_builtin_format(fsess, freg, sURL, mime_type, sep ? sep+1 : NULL);\n\t\t}\n\t\t//higher score, use this new registry\n\t\tif (s > score) {\n\t\t\tcandidate_freg = freg;\n\t\t\tscore = s;\n\t\t}\n\t\t//same score and higher priority (0 being highest), use this new registry\n\t\telse if ((s == score) && candidate_freg && (freg->priority<candidate_freg->priority) ) {\n\t\t\tcandidate_freg = freg;\n\t\t\tscore = s;\n\t\t}\n\t}\n\tif (probe_only) {\n\t\t*probe_only = candidate_freg ? GF_TRUE : GF_FALSE;\n\t\tif (probe_reg) *probe_reg = candidate_freg;\n\n\t\tif (free_url)\n\t\t\tgf_free(sURL);\n\t\tif (err) *err = GF_OK;\n\t\treturn NULL;\n\t}\n\n\tif (!candidate_freg) {\n\t\tif (force_freg) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"No source filter named %s found, retrying without forcing registry\\n\", force_freg));\n\t\t\tforce_freg = NULL;\n\t\t\tgoto restart;\n\t\t}\n\t\tif (free_url)\n\t\t\tgf_free(sURL);\n\t\tif (err) *err = GF_NOT_SUPPORTED;\n\t\tif (filter) filter->finalized = GF_TRUE;\n\t\treturn NULL;\n\t}\n\tif (sep) sep[0] = fsess->sep_args;\n\n\tuser_args_len = user_args ? (u32) strlen(user_args) : 0;\n\targs = gf_malloc(sizeof(char)*5);\n\t\n\tsprintf(args, \"%s%c\", for_source ? \"src\" : \"dst\", fsess->sep_name);\n\t//path is using ':' and has options specified, inject :gpac before first option\n\tif (sep && needs_escape) {\n\t\tsep[0]=0;\n\t\tgf_dynstrcat(&args, sURL, NULL);\n\t\tgf_dynstrcat(&args, \":gpac\", NULL);\n\t\tsep[0] = fsess->sep_args;\n\t\tgf_dynstrcat(&args, sep, NULL);\n\t} else {\n\t\tgf_dynstrcat(&args, sURL, NULL);\n\t}\n\t//path is using ':' and has no specified, inject :gpac: at end\n\tif (needs_escape && !sep && !user_args_len)\n\t\tgf_dynstrcat(&args, \":gpac:\", NULL);\n\n\tif (user_args_len) {\n\t\tif (fsess->sep_args==':')\n\t\t\tgf_dynstrcat(&args, \":gpac:\", NULL);\n\t\telse {\n\t\t\tchar szSep[2];\n\t\t\tszSep[0] = fsess->sep_args;\n\t\t\tszSep[1] = 0;\n\t\t\tgf_dynstrcat(&args, szSep, NULL);\n\t\t}\n\t\tgf_dynstrcat(&args, user_args, NULL);\n\t}\n\n\te = GF_OK;\n\targ_type = GF_FILTER_ARG_EXPLICIT_SINK;\n\tif (for_source) {\n\t\tif (no_args_inherit) arg_type = GF_FILTER_ARG_EXPLICIT_SOURCE_NO_DST_INHERIT;\n\t\telse arg_type = GF_FILTER_ARG_EXPLICIT_SOURCE;\n\t}\n\n\tif (!for_source && !alias_for_filter && candidate_freg->use_alias) {\n\t\tu32 fcount = gf_list_count(fsess->filters);\n\t\tfor (i=0; i<fcount; i++) {\n\t\t\tGF_Filter *f = gf_list_get(fsess->filters, i);\n\t\t\tif (f->freg != candidate_freg) continue;\n\t\t\tif (f->freg->use_alias(f, sURL, mime_type)) {\n\t\t\t\talias_for_filter = f;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!filter) {\n\t\tfilter = gf_filter_new(fsess, candidate_freg, args, NULL, arg_type, err, alias_for_filter, GF_FALSE);\n\t} else {\n        //destroy underlying JS object - gf_filter_new_finalize always reassign it to JS_UNDEFINED\n#ifdef GPAC_HAS_QJS\n        jsfs_on_filter_destroyed(filter);\n#endif\n\t\tif (filter->session->on_filter_create_destroy)\n\t\t\tfilter->session->on_filter_create_destroy(filter->session->rt_udta, filter, GF_TRUE);\n\t\t\t\n        filter->freg = candidate_freg;\n\t\te = gf_filter_new_finalize(filter, args, arg_type);\n\t\tif (err) *err = e;\n\t}\n\n\tif (free_url)\n\t\tgf_free(sURL);\n\n\tif (filter) {\n\t\tif (filter->src_args) gf_free(filter->src_args);\n\t\tfilter->src_args = args;\n\t\t//for link resolution\n\t\tif (dst_filter && for_source)\t{\n\t\t\tif (gf_list_find(filter->destination_links, dst_filter)<0)\n\t\t\t\tgf_list_add(filter->destination_links, dst_filter);\n\t\t\t//to remember our connection target\n\t\t\tfilter->target_filter = dst_filter;\n\t\t}\n\t\tif (dst_filter)\n\t\t\tfilter->subsession_id = dst_filter->subsession_id;\n\t} else {\n\t\tgf_free(args);\n\t}\n\n\tif (!e && filter && !filter->num_output_pids && for_source)\n\t\tgf_filter_post_process_task(filter);\n\n\treturn filter;\n}\n\nGF_EXPORT\nGF_Filter *gf_fs_load_source(GF_FilterSession *fsess, const char *url, const char *args, const char *parent_url, GF_Err *err)\n{\n\treturn gf_fs_load_source_dest_internal(fsess, url, args, parent_url, err, NULL, NULL, GF_TRUE, GF_FALSE, NULL, NULL);\n}\n\nGF_EXPORT\nGF_Filter *gf_fs_load_destination(GF_FilterSession *fsess, const char *url, const char *args, const char *parent_url, GF_Err *err)\n{\n\treturn gf_fs_load_source_dest_internal(fsess, url, args, parent_url, err, NULL, NULL, GF_FALSE, GF_FALSE, NULL, NULL);\n}\n\n\nGF_EXPORT\nGF_Err gf_filter_add_event_listener(GF_Filter *filter, GF_FSEventListener *el)\n{\n\tGF_Err e;\n\tif (!filter || !filter->session || !el || !el->on_event) return GF_BAD_PARAM;\n\twhile (filter->session->in_event_listener) gf_sleep(1);\n\tgf_mx_p(filter->session->evt_mx);\n\tif (!filter->session->event_listeners) {\n\t\tfilter->session->event_listeners = gf_list_new();\n\t}\n\te = gf_list_add(filter->session->event_listeners, el);\n\tgf_mx_v(filter->session->evt_mx);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_filter_remove_event_listener(GF_Filter *filter, GF_FSEventListener *el)\n{\n\tif (!filter || !filter->session || !el || !filter->session->event_listeners) return GF_BAD_PARAM;\n\n\twhile (filter->session->in_event_listener) gf_sleep(1);\n\tgf_mx_p(filter->session->evt_mx);\n\tgf_list_del_item(filter->session->event_listeners, el);\n\tif (!gf_list_count(filter->session->event_listeners)) {\n\t\tgf_list_del(filter->session->event_listeners);\n\t\tfilter->session->event_listeners=NULL;\n\t}\n\tgf_mx_v(filter->session->evt_mx);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nBool gf_fs_forward_gf_event(GF_FilterSession *fsess, GF_Event *evt, Bool consumed, Bool skip_user)\n{\n\tif (!fsess || fsess->in_final_flush) return GF_FALSE;\n\n\tif (fsess->event_listeners) {\n\t\tGF_FSEventListener *el;\n\t\tu32 i=0;\n\n\t\tgf_mx_p(fsess->evt_mx);\n\t\tfsess->in_event_listener ++;\n\t\tgf_mx_v(fsess->evt_mx);\n\t\twhile ((el = gf_list_enum(fsess->event_listeners, &i))) {\n\t\t\tif (el->on_event(el->udta, evt, consumed)) {\n\t\t\t\tfsess->in_event_listener --;\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t}\n\t\tfsess->in_event_listener --;\n\t}\n\n\tif (!skip_user && !consumed && fsess->ui_event_proc) {\n\t\tBool res;\n\t\tres = gf_fs_ui_event(fsess, evt);\n\t\treturn res;\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nBool gf_filter_forward_gf_event(GF_Filter *filter, GF_Event *evt, Bool consumed, Bool skip_user)\n{\n\tif (!filter) return GF_FALSE;\n\treturn gf_fs_forward_gf_event(filter->session, evt, consumed, skip_user);\n\n}\n\nGF_EXPORT\nBool gf_filter_send_gf_event(GF_Filter *filter, GF_Event *evt)\n{\n\treturn gf_filter_forward_gf_event(filter, evt, GF_FALSE, GF_FALSE);\n}\n\n\nstatic void gf_fs_print_jsf_connection(GF_FilterSession *session, char *filter_name, GF_Filter *js_filter, void (*print_fn)(FILE *output, GF_SysPrintArgFlags flags, const char *fmt, ...) )\n{\n\tGF_CapsBundleStore capstore;\n\tconst char *js_name = NULL;\n\tGF_Err e=GF_OK;\n\tu32 i, j, count, nb_js_caps;\n\tGF_List *sources, *sinks;\n\tGF_FilterRegister loaded_freg;\n\tBool has_output, has_input;\n\n\tif (!js_filter) {\n\t\tif (!filter_name) return;\n\t\tjs_filter = gf_fs_load_filter(session, filter_name, &e);\n\t\tif (!js_filter) return;\n\t} else {\n\t\tif (!filter_name) filter_name = (char *) js_filter->freg->name;\n\t}\n\n\tjs_name = strrchr(filter_name, '/');\n\tif (!js_name) js_name = strrchr(filter_name, '\\\\');\n\tif (js_name) js_name++;\n\telse js_name = filter_name;\n\n\tnb_js_caps = gf_filter_caps_bundle_count(js_filter->forced_caps, js_filter->nb_forced_caps);\n\n\t//fake a new register with only the caps set\n\tmemset(&loaded_freg, 0, sizeof(GF_FilterRegister));\n\tloaded_freg.caps = js_filter->forced_caps;\n\tloaded_freg.nb_caps = js_filter->nb_forced_caps;\n\n\thas_output = gf_filter_has_out_caps(js_filter->forced_caps, js_filter->nb_forced_caps);\n\thas_input = gf_filter_has_in_caps(js_filter->forced_caps, js_filter->nb_forced_caps);\n\n\tmemset(&capstore, 0, sizeof(GF_CapsBundleStore));\n\tsources = gf_list_new();\n\tsinks = gf_list_new();\n\t//edges for JS are for the unloaded JSF (eg accept anything, output anything).\n\t//we need to do a manual check\n\tcount = gf_list_count(session->links);\n\tfor (i=0; i<count; i++) {\n\t\tu32 nb_src_caps, k, l;\n\t\tBool src_match = GF_FALSE;\n\t\tBool sink_match = GF_FALSE;\n\t\tGF_FilterRegDesc *a_reg = gf_list_get(session->links, i);\n\t\tif (a_reg->freg == js_filter->freg) continue;\n\n\t\t//check which cap of this filter matches our destination\n\t\tnb_src_caps = gf_filter_caps_bundle_count(a_reg->freg->caps, a_reg->freg->nb_caps);\n\t\tfor (k=0; k<nb_src_caps; k++) {\n\t\t\tfor (l=0; l<nb_js_caps; l++) {\n\t\t\t\ts32 bundle_idx;\n\t\t\t\tu32 loaded_filter_only_flags = 0;\n\t\t\t\tu32 path_weight;\n\t\t\t\tif (has_input && !src_match) {\n\t\t\t\t\tpath_weight = gf_filter_caps_to_caps_match(a_reg->freg, k, (const GF_FilterRegister *) &loaded_freg, 0, NULL, &bundle_idx, l, &loaded_filter_only_flags, &capstore);\n\t\t\t\t\tif (path_weight && (bundle_idx == l))\n\t\t\t\t\t\tsrc_match = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tif (has_output && !sink_match) {\n\t\t\t\t\tloaded_filter_only_flags = 0;\n\t\t\t\t\tpath_weight = gf_filter_caps_to_caps_match(&loaded_freg, l, a_reg->freg, 0, NULL, &bundle_idx, k, &loaded_filter_only_flags, &capstore);\n\n\t\t\t\t\tif (path_weight && (bundle_idx == k))\n\t\t\t\t\t\tsink_match = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (src_match && sink_match)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (src_match) gf_list_add(sources, (void *) a_reg->freg);\n\t\tif (sink_match) gf_list_add(sinks, (void *) a_reg->freg);\n\t}\n\n\tfor (i=0; i<2; i++) {\n\t\tGF_List *from = i ? sinks : sources;\n\t\tchar *type = i ? \"sinks\" : \"sources\";\n\n\t\tcount = gf_list_count(from);\n\t\tif (!count) {\n\t\t\tif (print_fn)\n\t\t\t\tprint_fn(stderr, 1, \"%s: no %s\\n\", js_name, type);\n\t\t\telse {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"%s: no %s\\n\", type));\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (print_fn)\n\t\t\tprint_fn(stderr, 1, \"%s %s:\", js_name, type);\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"%s %s:\", js_name, type));\n\t\t}\n\t\tfor (j=0; j<count; j++) {\n\t\t\tGF_FilterRegister *a_reg = gf_list_get(from, j);\n\t\t\tif (print_fn)\n\t\t\t\tprint_fn(stderr, 0, \" %s\", a_reg->name);\n\t\t\telse {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" %s\", a_reg->name));\n\t\t\t}\n\t\t}\n\t\tif (print_fn)\n\t\t\tprint_fn(stderr, 0, \"\\n\");\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\n\"));\n\t\t}\n\t}\n\n\tif (capstore.bundles_cap_found) gf_free(capstore.bundles_cap_found);\n\tif (capstore.bundles_in_ok) gf_free(capstore.bundles_in_ok);\n\tif (capstore.bundles_in_scores) gf_free(capstore.bundles_in_scores);\n\tgf_list_del(sources);\n\tgf_list_del(sinks);\n}\n\nGF_EXPORT\nvoid gf_fs_print_all_connections(GF_FilterSession *session, char *filter_name, void (*print_fn)(FILE *output, GF_SysPrintArgFlags flags, const char *fmt, ...) )\n{\n\tBool found = GF_FALSE;\n\tGF_List *done;\n\tu32 i, j, k, count;\n\tu32 llev = gf_log_get_tool_level(GF_LOG_FILTER);\n\n\tgf_log_set_tool_level(GF_LOG_FILTER, GF_LOG_INFO);\n\t//load JS to inspect its connections\n\tif (filter_name && strstr(filter_name, \".js\")) {\n\t\tgf_fs_print_jsf_connection(session, filter_name, NULL, print_fn);\n\t\tgf_log_set_tool_level(GF_LOG_FILTER, llev);\n\t\treturn;\n\t}\n\tdone = gf_list_new();\n\tcount = gf_list_count(session->links);\n\n\tfor (i=0; i<count; i++) {\n\t\tconst GF_FilterRegDesc *src = gf_list_get(session->links, i);\n\t\tif (filter_name && strcmp(src->freg->name, filter_name))\n\t\t\tcontinue;\n\n\t\tfound = GF_TRUE;\n\t\tif (print_fn)\n\t\t\tprint_fn(stderr, 1, \"%s sources:%s\", src->freg->name, src->nb_edges ? \"\" : \" none\\n\");\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"%s sources:%s\", src->freg->name, src->nb_edges ? \"\" : \" none\\n\"));\n\t\t}\n\t\tif (!src->nb_edges)\n\t\t\tcontinue;\n\n\t\tfor (j=0; j<src->nb_edges; j++) {\n\t\t\tif (gf_list_find(done, (void *) src->edges[j].src_reg->freg->name)<0) {\n\t\t\t\tif (print_fn)\n\t\t\t\t\tprint_fn(stderr, 0, \" %s\", src->edges[j].src_reg->freg->name);\n\t\t\t\telse {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" %s\", src->edges[j].src_reg->freg->name));\n\t\t\t\t}\n\t\t\t\tgf_list_add(done, (void *) src->edges[j].src_reg->freg->name);\n\t\t\t\tif (session->flags & GF_FS_FLAG_PRINT_CONNECTIONS) {\n\t\t\t\t\tif (print_fn)\n\t\t\t\t\t\tprint_fn(stderr, 0, \" ( \", src->edges[j].src_reg->freg->name);\n\t\t\t\t\telse {\n\t\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" ( \", src->edges[j].src_reg->freg->name));\n\t\t\t\t\t}\n\t\t\t\t\tfor (k=0; k<src->nb_edges; k++) {\n\t\t\t\t\t\tif (src->edges[j].src_reg != src->edges[k].src_reg) continue;;\n\n\t\t\t\t\t\tif (print_fn)\n\t\t\t\t\t\t\tprint_fn(stderr, 0, \"%d->%d \", src->edges[k].src_cap_idx, src->edges[k].dst_cap_idx);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"%d->%d \", src->edges[k].src_cap_idx, src->edges[k].dst_cap_idx));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif (print_fn)\n\t\t\t\t\t\tprint_fn(stderr, 0, \")\", src->edges[j].src_reg->freg->name);\n\t\t\t\t\telse {\n\t\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\")\", src->edges[j].src_reg->freg->name));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (print_fn)\n\t\t\tprint_fn(stderr, 0, \"\\n\");\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\n\"));\n\t\t}\n\t\tgf_list_reset(done);\n\t}\n\n\tif (found && filter_name) {\n\t\tu32 nb_sinks=0;\n\t\tif (print_fn)\n\t\t\tprint_fn(stderr, 1, \"%s sinks:\", filter_name);\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"%s sinks:\", filter_name));\n\t\t}\n\t\tcount = gf_list_count(session->links);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tconst GF_FilterRegDesc *src = gf_list_get(session->links, i);\n\t\t\tif (!strcmp(src->freg->name, filter_name)) {\n\t\t\t\tif (!(src->freg->flags & GF_FS_REG_EXPLICIT_ONLY) || !(src->freg->flags & GF_FS_REG_ALLOW_CYCLIC))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (j=0; j<src->nb_edges; j++) {\n\t\t\t\tif (strcmp(src->edges[j].src_reg->freg->name, filter_name)) continue;\n\n\t\t\t\tif (gf_list_find(done, (void *) src->freg->name)<0) {\n\t\t\t\t\tnb_sinks++;\n\t\t\t\t\tif (print_fn)\n\t\t\t\t\t\tprint_fn(stderr, 0, \" %s\", src->freg->name);\n\t\t\t\t\telse {\n\t\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" %s\", src->freg->name));\n\t\t\t\t\t}\n\t\t\t\t\tgf_list_add(done, (void *) src->freg->name);\n\t\t\t\t\tif (session->flags & GF_FS_FLAG_PRINT_CONNECTIONS) {\n\t\t\t\t\t\tif (print_fn)\n\t\t\t\t\t\t\tprint_fn(stderr, 0, \" ( \", src->edges[j].src_reg->freg->name);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" ( \", src->edges[j].src_reg->freg->name));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (k=0; k<src->nb_edges; k++) {\n\t\t\t\t\t\t\tif (src->edges[j].src_reg != src->edges[k].src_reg) continue;\n\n\t\t\t\t\t\t\tif (print_fn)\n\t\t\t\t\t\t\t\tprint_fn(stderr, 0, \"%d->%d \", src->edges[k].src_cap_idx, src->edges[k].dst_cap_idx);\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"%d->%d \", src->edges[k].src_cap_idx, src->edges[k].dst_cap_idx));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (print_fn)\n\t\t\t\t\t\t\tprint_fn(stderr, 0, \")\", src->edges[j].src_reg->freg->name);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\")\", src->edges[j].src_reg->freg->name));\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_list_reset(done);\n\t\t}\n\t\tif (print_fn)\n\t\t\tprint_fn(stderr, 1, \"%s\\n\", nb_sinks ? \" \" : \" none\");\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"%s\\n\", nb_sinks ? \" \" : \" none\"));\n\t\t}\n\t}\n\n\tif (!found && filter_name) {\n\t\tGF_Err e = GF_OK;\n\t\tGF_Filter *f = gf_fs_load_filter(session, filter_name, &e);\n\t\tif (f) {\n\t\t\tgf_fs_print_jsf_connection(session, filter_name, f, print_fn);\n\t\t}\n\t\telse if (print_fn)\n\t\t\tprint_fn(stderr, 1, \"%s filter not found\\n\", filter_name);\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_APP, (\"%s filter not found\\n\", filter_name));\n\t\t}\n\t}\n\tgf_list_del(done);\n\tgf_log_set_tool_level(GF_LOG_FILTER, llev);\n}\n\nGF_EXPORT\nvoid gf_filter_print_all_connections(GF_Filter *filter, void (*print_fn)(FILE *output, GF_SysPrintArgFlags flags, const char *fmt, ...) )\n{\n\tif (!filter) return;\n\tif (filter->freg->flags & GF_FS_REG_CUSTOM) {\n\t\tgf_fs_print_jsf_connection(filter->session, NULL, filter, print_fn);\n\t} else {\n\t\tgf_fs_print_all_connections(filter->session, (char *) filter->freg->name, print_fn);\n\t}\n}\n\nGF_EXPORT\nvoid gf_filter_get_session_caps(GF_Filter *filter, GF_FilterSessionCaps *caps)\n{\n\tif (caps) {\n\t\tif (filter) {\n\t\t\t(*caps) = filter->session->caps;\n\t\t} else {\n\t\t\tmemset(caps, 0, sizeof(GF_FilterSessionCaps));\n\t\t}\n\t}\n}\n\nGF_EXPORT\nvoid gf_filter_set_session_caps(GF_Filter *filter, GF_FilterSessionCaps *caps)\n{\n\tif (caps && filter) {\n\t\tfilter->session->caps = (*caps);\n\t\t//TODO fire event\n\t}\n}\n\nGF_EXPORT\nu8 gf_filter_get_sep(GF_Filter *filter, GF_FilterSessionSepType sep_type)\n{\n\tswitch (sep_type) {\n\tcase GF_FS_SEP_ARGS: return filter->session->sep_args;\n\tcase GF_FS_SEP_NAME: return filter->session->sep_name;\n\tcase GF_FS_SEP_FRAG: return filter->session->sep_frag;\n\tcase GF_FS_SEP_LIST: return filter->session->sep_list;\n\tcase GF_FS_SEP_NEG: return filter->session->sep_neg;\n\tdefault: return 0;\n\t}\n}\n\n#ifndef GPAC_DISABLE_NETWORK\nstatic Bool gf_fsess_get_user_pass(void *usr_cbk, Bool secure, const char *site_url, char *usr_name, char *password, gf_dm_on_usr_pass async_pass, void *async_udta)\n{\n\tGF_Event evt;\n\tGF_FilterSession *fsess = (GF_FilterSession *)usr_cbk;\n\tevt.type = GF_EVENT_AUTHORIZATION;\n\tevt.auth.secure = secure;\n\tevt.auth.site_url = site_url;\n\tevt.auth.user = usr_name;\n\tevt.auth.password = password;\n\tevt.auth.on_usr_pass = async_pass;\n\tevt.auth.async_usr_data = async_udta;\n\treturn gf_fs_forward_gf_event(fsess, &evt, GF_FALSE, GF_FALSE);\n}\n#endif\n\nstatic GF_DownloadManager *gf_fs_get_download_manager(GF_FilterSession *fs)\n{\n#ifdef GPAC_USE_DOWNLOADER\n\tif (!fs->download_manager) {\n\t\tfs->download_manager = gf_dm_new(fs);\n\n#ifndef GPAC_DISABLE_NETWORK\n\t\tgf_dm_set_auth_callback(fs->download_manager, gf_fsess_get_user_pass, fs);\n#endif\n\t}\n\treturn fs->download_manager;\n#else\n\treturn NULL;\n#endif\n}\n\nGF_EXPORT\nGF_DownloadManager *gf_filter_get_download_manager(GF_Filter *filter)\n{\n\tif (!filter) return NULL;\n\treturn gf_fs_get_download_manager(filter->session);\n}\n\nGF_EXPORT\nstruct _gf_ft_mgr *gf_fs_get_font_manager(GF_FilterSession *fsess)\n{\n#ifdef GPAC_DISABLE_FONTS\n\treturn NULL;\n#else\n\tif (!fsess->font_manager) {\n\t\tfsess->font_manager = gf_font_manager_new();\n\t}\n\treturn fsess->font_manager;\n#endif\n}\n\nGF_EXPORT\nstruct _gf_ft_mgr *gf_filter_get_font_manager(GF_Filter *filter)\n{\n\tif (!filter) return NULL;\n\treturn gf_fs_get_font_manager(filter->session);\n}\n\nvoid gf_fs_cleanup_filters(GF_FilterSession *fsess)\n{\n\tassert(fsess->pid_connect_tasks_pending);\n\tsafe_int_dec(&fsess->pid_connect_tasks_pending);\n}\n\nGF_EXPORT\nGF_Err gf_fs_get_last_connect_error(GF_FilterSession *fs)\n{\n\tGF_Err e;\n\tif (!fs) return GF_BAD_PARAM;\n\te = fs->last_connect_error;\n\tfs->last_connect_error = GF_OK;\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_fs_get_last_process_error(GF_FilterSession *fs)\n{\n\tGF_Err e;\n\tif (!fs) return GF_BAD_PARAM;\n\te = fs->last_process_error;\n\tfs->last_process_error = GF_OK;\n\treturn e;\n}\n\ntypedef struct\n{\n\tGF_FilterSession *fsess;\n\tvoid *callback;\n\tBool (*task_execute) (GF_FilterSession *fsess, void *callback, u32 *reschedule_ms);\n\tBool (*task_execute_filter) (GF_Filter *filter, void *callback, u32 *reschedule_ms);\n#ifndef GPAC_DISABLE_REMOTERY\n\trmtU32 rmt_hash;\n#endif\n} GF_UserTask;\n\nstatic void gf_fs_user_task(GF_FSTask *task)\n{\n\tu32 reschedule_ms=0;\n\tGF_UserTask *utask = (GF_UserTask *)task->udta;\n\ttask->schedule_next_time = 0;\n\n#ifndef GPAC_DISABLE_REMOTERY\n\tgf_rmt_begin_hash(task->log_name, GF_RMT_AGGREGATE, &utask->rmt_hash);\n#endif\n\tif (utask->task_execute) {\n\t\ttask->requeue_request = utask->task_execute(utask->fsess, utask->callback, &reschedule_ms);\n\t} else if (task->filter) {\n\t\ttask->requeue_request = utask->task_execute_filter(task->filter, utask->callback, &reschedule_ms);\n\t} else {\n\t\ttask->requeue_request = 0;\n\t}\n\tgf_rmt_end();\n\t//if no requeue request or if we are in final flush, don't re-execute\n\tif (!task->requeue_request || utask->fsess->in_final_flush) {\n\t\tgf_free(utask);\n\t\ttask->udta = NULL;\n\t\t//we duplicated the name for user tasks\n\t\tgf_free((char *) task->log_name);\n\t\ttask->requeue_request = GF_FALSE;\n\t} else {\n\t\tassert(task->requeue_request);\n\t\ttask->schedule_next_time = gf_sys_clock_high_res() + 1000*reschedule_ms;\n\t}\n}\n\n\nstatic GF_Err gf_fs_post_user_task_internal(GF_FilterSession *fsess, Bool (*task_execute) (GF_FilterSession *fsess, void *callback, u32 *reschedule_ms), void *udta_callback, const char *log_name, Bool force_main)\n{\n\tGF_UserTask *utask;\n\tchar *_log_name;\n\tif (!fsess || !task_execute) return GF_BAD_PARAM;\n\tGF_SAFEALLOC(utask, GF_UserTask);\n\tif (!utask) return GF_OUT_OF_MEM;\n\tutask->fsess = fsess;\n\tutask->callback = udta_callback;\n\tutask->task_execute = task_execute;\n\t//dup mem for user task\n\t_log_name = gf_strdup(log_name ? log_name : \"user_task\");\n\tgf_fs_post_task_ex(fsess, gf_fs_user_task, NULL, NULL, _log_name, utask, GF_FALSE, force_main, GF_FALSE, TASK_TYPE_USER);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_fs_post_user_task(GF_FilterSession *fsess, Bool (*task_execute) (GF_FilterSession *fsess, void *callback, u32 *reschedule_ms), void *udta_callback, const char *log_name)\n{\n\treturn gf_fs_post_user_task_internal(fsess, task_execute, udta_callback, log_name, fsess->force_main_thread_tasks);\n}\n\nGF_EXPORT\nGF_Err gf_fs_post_user_task_main(GF_FilterSession *fsess, Bool (*task_execute) (GF_FilterSession *fsess, void *callback, u32 *reschedule_ms), void *udta_callback, const char *log_name)\n{\n\treturn gf_fs_post_user_task_internal(fsess, task_execute, udta_callback, log_name, GF_TRUE);\n}\n\nGF_EXPORT\nGF_Err gf_filter_post_task(GF_Filter *filter, Bool (*task_execute) (GF_Filter *filter, void *callback, u32 *reschedule_ms), void *udta, const char *task_name)\n{\n\tGF_UserTask *utask;\n\tif (!filter || !task_execute) return GF_BAD_PARAM;\n\tGF_SAFEALLOC(utask, GF_UserTask);\n\tif (!utask) return GF_OUT_OF_MEM;\n\tutask->callback = udta;\n\tutask->task_execute_filter = task_execute;\n\tutask->fsess = filter->session;\n\tchar *_log_name=NULL;\n\tif (task_name) {\n\t\t_log_name = gf_strdup(task_name);\n\t} else {\n\t\tgf_dynstrcat(&_log_name, filter->name, NULL);\n\t\tgf_dynstrcat(&_log_name, \"_task\", NULL);\n\t}\n\n\tgf_fs_post_task_class(filter->session, gf_fs_user_task, filter, NULL, _log_name, utask, TASK_TYPE_USER);\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nBool gf_fs_is_last_task(GF_FilterSession *fsess)\n{\n\tif (!fsess) return GF_TRUE;\n\tif (fsess->tasks_pending>1) return GF_FALSE;\n\tif (gf_fq_count(fsess->main_thread_tasks)) return GF_FALSE;\n\tif (gf_fq_count(fsess->tasks)) return GF_FALSE;\n\tif (fsess->non_blocking && fsess->tasks_in_process) return GF_FALSE;\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nBool gf_fs_in_final_flush(GF_FilterSession *fsess)\n{\n\tif (!fsess) return GF_TRUE;\n\treturn fsess->in_final_flush;\n}\nGF_EXPORT\nBool gf_fs_is_supported_mime(GF_FilterSession *fsess, const char *mime)\n{\n\tu32 i, count;\n\t//first pass on explicit mimes\n\tcount = gf_list_count(fsess->registry);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j;\n\t\tconst GF_FilterRegister *freg = gf_list_get(fsess->registry, i);\n\t\tfor (j=0; j<freg->nb_caps; j++) {\n\t\t\tconst GF_FilterCapability *acap = &freg->caps[j];\n\t\t\tif (!(acap->flags & GF_CAPFLAG_INPUT)) continue;\n\t\t\tif (acap->code == GF_PROP_PID_MIME) {\n\t\t\t\tif (acap->val.value.string && strstr(acap->val.value.string, mime)) return GF_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_FALSE;\n}\n\n\nGF_EXPORT\nvoid gf_fs_enable_reporting(GF_FilterSession *session, Bool reporting_on)\n{\n\tif (session) session->reporting_on = reporting_on;\n}\n\nGF_EXPORT\nvoid gf_fs_lock_filters(GF_FilterSession *session, Bool do_lock)\n{\n\tif (!session || !session->filters_mx) return;\n\tif (do_lock) gf_mx_p(session->filters_mx);\n\telse gf_mx_v(session->filters_mx);\n}\n\nGF_EXPORT\nu32 gf_fs_get_filters_count(GF_FilterSession *session)\n{\n\treturn session ? gf_list_count(session->filters) : 0;\n}\nGF_EXPORT\nGF_Filter *gf_fs_get_filter(GF_FilterSession *session, u32 idx)\n{\n\treturn session ? gf_list_get(session->filters, idx) : NULL;\n}\n\nGF_EXPORT\nGF_Err gf_filter_get_stats(GF_Filter *f, GF_FilterStats *stats)\n{\n\tu32 i;\n\tBool set_name=GF_FALSE;\n\tif (!stats || !f) return GF_BAD_PARAM;\n\tmemset(stats, 0, sizeof(GF_FilterStats));\n\tstats->filter = f;\n\tstats->filter_alias = f->multi_sink_target;\n\tif (f->multi_sink_target) return GF_OK;\n\t\n\tstats->percent = f->status_percent>10000 ? -1 : (s32) f->status_percent;\n\tstats->status = f->status_str;\n\tstats->nb_pck_processed = f->nb_pck_processed;\n\tstats->nb_bytes_processed = f->nb_bytes_processed;\n\tstats->time_process = f->time_process;\n\tstats->nb_hw_pck_sent = f->nb_hw_pck_sent;\n\tstats->nb_pck_sent = f->nb_pck_sent;\n\tstats->nb_bytes_sent = f->nb_bytes_sent;\n\tstats->nb_tasks_done = f->nb_tasks_done;\n\tstats->nb_errors = f->nb_errors;\n\tstats->name = f->name;\n\tstats->reg_name = f->freg->name;\n\tstats->filter_id = f->id;\n\tstats->done = f->removed || f->finalized;\n\tif (stats->name && !strcmp(stats->name, stats->reg_name)) {\n\t\tset_name=GF_TRUE;\n\t}\n\tstats->report_updated = f->report_updated;\n\tf->report_updated = GF_FALSE;\n\n\n\tif (!stats->nb_pid_out && stats->nb_pid_in) stats->type = GF_FS_STATS_FILTER_RAWOUT;\n\telse if (!stats->nb_pid_in && stats->nb_pid_out) stats->type = GF_FS_STATS_FILTER_RAWIN;\n\n\tstats->nb_pid_out = f->num_output_pids;\n\tfor (i=0; i<f->num_output_pids; i++) {\n\t\tGF_FilterPid *pid = gf_list_get(f->output_pids, i);\n\t\tstats->nb_out_pck += pid->nb_pck_sent;\n\t\tif (pid->has_seen_eos) stats->in_eos = GF_TRUE;\n\n\t\tif (pid->last_ts_sent.num * stats->last_ts_sent.den >= stats->last_ts_sent.num * pid->last_ts_sent.den)\n\t\t\tstats->last_ts_sent = pid->last_ts_sent;\n\n\t\tif (f->num_output_pids!=1) continue;\n\n\t\tif (!stats->codecid)\n\t\t\tstats->codecid = pid->codecid;\n\t\tif (!stats->stream_type)\n\t\t\tstats->stream_type = pid->stream_type;\n\n\t\t//set name if PID name is not a default generated one\n\t\tif (set_name && strncmp(pid->name, \"PID\", 3)) {\n\t\t\tstats->name = pid->name;\n\t\t\tset_name = GF_FALSE;\n\t\t}\n\t}\n\tgf_mx_p(f->tasks_mx);\n\tstats->nb_pid_in = f->num_input_pids;\n\tfor (i=0; i<f->num_input_pids; i++) {\n\t\tGF_FilterPidInst *pidi = gf_list_get(f->input_pids, i);\n\t\tstats->nb_in_pck += pidi->nb_processed;\n\t\tif (pidi->is_end_of_stream) stats->in_eos = GF_TRUE;\n\n\t\tif (pidi->is_decoder_input) stats->type = GF_FS_STATS_FILTER_DECODE;\n\t\telse if (pidi->is_encoder_input) stats->type = GF_FS_STATS_FILTER_ENCODE;\n\n\t\tif (pidi->pid && (pidi->pid->stream_type==GF_STREAM_FILE))\n\t\t\tstats->type = GF_FS_STATS_FILTER_DEMUX;\n\n\t\tif (pidi->last_ts_drop.num * stats->last_ts_drop.den >= stats->last_ts_drop.num * pidi->last_ts_drop.den)\n\t\t\tstats->last_ts_drop = pidi->last_ts_drop;\n\n\t\tif ((f->num_input_pids!=1) && f->num_output_pids)\n\t\t\tcontinue;\n\n\t\tif (!stats->codecid)\n\t\t\tstats->codecid = pidi->pid->codecid;\n\t\tif (!stats->stream_type)\n\t\t\tstats->stream_type = pidi->pid->stream_type;\n\n\t\tif (set_name) {\n\t\t\tstats->name = pidi->pid->name;\n\t\t\tset_name = GF_FALSE;\n\t\t}\n\t}\n\tgf_mx_v(f->tasks_mx);\n\tif (!stats->type && stats->codecid) {\n\t\tif (!stats->nb_pid_out) {\n\t\t\tstats->type = GF_FS_STATS_FILTER_MEDIA_SINK;\n\t\t} else if (!stats->nb_pid_in) {\n\t\t\tstats->type = GF_FS_STATS_FILTER_MEDIA_SOURCE;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_fs_get_filter_stats(GF_FilterSession *session, u32 idx, GF_FilterStats *stats)\n{\n\tif (!stats || !session) return GF_BAD_PARAM;\n\treturn gf_filter_get_stats(gf_list_get(session->filters, idx), stats);\n}\n\nBool gf_fs_ui_event(GF_FilterSession *session, GF_Event *uievt)\n{\n\tBool ret;\n\tgf_mx_p(session->ui_mx);\n\tret = session->ui_event_proc(session->ui_opaque, uievt);\n\tgf_mx_v(session->ui_mx);\n\treturn ret;\n}\n\nvoid gf_fs_check_graph_load(GF_FilterSession *fsess, Bool for_load)\n{\n\tif (for_load) {\n\t\tif (!fsess->links || ! gf_list_count( fsess->links))\n\t\t\tgf_filter_sess_build_graph(fsess, NULL);\n\t} else {\n\t\tif (fsess->flags & GF_FS_FLAG_NO_GRAPH_CACHE)\n\t\t\tgf_filter_sess_reset_graph(fsess, NULL);\n\t}\n}\n\nGF_EXPORT\nGF_Filter *gf_fs_new_filter(GF_FilterSession *fsess, const char *name, u32 flags, GF_Err *e)\n{\n\tGF_Filter *f;\n\tchar *sep, szRegName[25];\n\tGF_FilterRegister *reg;\n\n\tGF_SAFEALLOC(reg, GF_FilterRegister);\n\tif (!reg) {\n\t\t*e = GF_OUT_OF_MEM;\n\t\treturn NULL;\n\t}\n\n\treg->flags = 0;\n#ifndef GPAC_DISABLE_DOC\n\treg->author = \"custom\";\n\treg->description = \"custom\";\n\treg->help = \"custom\";\n#endif\n\treg->version = \"custom\";\n\tsprintf(szRegName, \"custom%p\", reg);\n\tsep = strchr(name, fsess->sep_args);\n\tif (sep) sep[0] = 0;\n\treg->name = gf_strdup(name ? name : szRegName);\n\treg->flags = GF_FS_REG_CUSTOM | GF_FS_REG_EXPLICIT_ONLY;\n\n\tif (flags & GF_FS_REG_MAIN_THREAD)\n\t\treg->flags |= GF_FS_REG_MAIN_THREAD;\n\n\tf = gf_filter_new(fsess, reg, sep ? sep+1 : NULL, NULL, 0, e, NULL, GF_FALSE);\n\tif (f && name)\n\t\tgf_filter_set_name(f, name);\n\tif (sep) sep[0] = fsess->sep_args;\n\treturn f;\n}\n\n#ifndef GPAC_DISABLE_3D\n\n\n#define GF_VIDEO_HW_INTERNAL\t(1<<29)\n#define GF_VIDEO_HW_ATTACHED\t(1<<30)\n\nstatic Bool fsess_on_event(void *cbk, GF_Event *evt)\n{\n\treturn GF_TRUE;\n}\n\nGF_Err gf_fs_check_gl_provider(GF_FilterSession *session)\n{\n\tGF_Event evt;\n\tGF_Err e;\n\tconst char *sOpt;\n\tvoid *os_disp_handler;\n\n\tif (session->ext_gl_callback) {\n\t\te = session->ext_gl_callback(session->ext_gl_udta, GF_TRUE);\n\t\tif (e==GF_OK) gf_opengl_init();\n\t\treturn e;\n\t}\n\n\tif (!session->nb_gl_filters) return GF_OK;\n\tif (gf_list_count(session->gl_providers)) return GF_OK;\n\n\tif (session->gl_driver) return GF_OK;\n\n\n\tsession->gl_driver = (GF_VideoOutput *) gf_module_load(GF_VIDEO_OUTPUT_INTERFACE, gf_opts_get_key(\"core\", \"video-output\") );\n\n\tif (!session->gl_driver) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Failed to load a video output for OpenGL context support !\\n\"));\n\t\treturn GF_IO_ERR;\n\t}\n\tif (!gf_opts_get_key(\"core\", \"video-output\")) {\n\t\tgf_opts_set_key(\"core\", \"video-output\", session->gl_driver->module_name);\n\t}\n\tsession->gl_driver->hw_caps |= GF_VIDEO_HW_INTERNAL;\n\tsession->gl_driver->on_event = fsess_on_event;\n\tsession->gl_driver->evt_cbk_hdl = session;\n\n\tos_disp_handler = NULL;\n\tsOpt = gf_opts_get_key(\"temp\", \"window-display\");\n\tif (sOpt) sscanf(sOpt, \"%p\", &os_disp_handler);\n\n\te = session->gl_driver->Setup(session->gl_driver, NULL, os_disp_handler, GF_VOUT_INIT_HIDE);\n\tif (e!=GF_OK) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"Failed to setup Video Driver %s!\\n\", session->gl_driver->module_name));\n\t\tgf_modules_close_interface((GF_BaseInterface *)session->gl_driver);\n\t\tsession->gl_driver = NULL;\n\t\treturn e;\n\t}\n\n\t//and initialize GL context\n\tmemset(&evt, 0, sizeof(GF_Event));\n\tevt.type = GF_EVENT_VIDEO_SETUP;\n\tevt.setup.width = 128;\n\tevt.setup.height = 128;\n\tevt.setup.use_opengl = GF_TRUE;\n\tevt.setup.back_buffer = 1;\n\t//we anyway should'nt call swapBuffer/flush on this object\n\tevt.setup.disable_vsync = GF_TRUE;\n\tsession->gl_driver->ProcessEvent(session->gl_driver, &evt);\n\n\tif (evt.setup.use_opengl) {\n\t\tgf_opengl_init();\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_fs_set_gl(GF_FilterSession *session, Bool do_activate)\n{\n\tGF_Event evt;\n\tif (session->ext_gl_callback) {\n\t\treturn session->ext_gl_callback(session->ext_gl_udta, do_activate);\n\t}\n\n\tif (!session->gl_driver) return GF_BAD_PARAM;\n\tmemset(&evt, 0, sizeof(GF_Event));\n\tevt.type = GF_EVENT_SET_GL;\n\treturn session->gl_driver->ProcessEvent(session->gl_driver, &evt);\n}\n\nGF_VideoOutput *gf_filter_claim_opengl_provider(GF_Filter *filter)\n{\n\tif (!filter || !filter->session || !filter->session->gl_driver) return NULL;\n\tif (filter->session->ext_gl_callback) return NULL;\n\n\tif (! (filter->session->gl_driver->hw_caps & GF_VIDEO_HW_INTERNAL))\n\t\treturn NULL;\n\tif (filter->session->gl_driver->hw_caps & GF_VIDEO_HW_ATTACHED)\n\t\treturn NULL;\n\n\tfilter->session->gl_driver->hw_caps |= GF_VIDEO_HW_ATTACHED;\n\treturn filter->session->gl_driver;\n}\n\nBool gf_filter_unclaim_opengl_provider(GF_Filter *filter, GF_VideoOutput * video_out)\n{\n\tif (!filter || !video_out) return GF_FALSE;\n\tif (filter->session->ext_gl_callback) return GF_FALSE;\n\n\tif (! (video_out->hw_caps & GF_VIDEO_HW_INTERNAL))\n\t\treturn GF_FALSE;\n\tif (video_out != filter->session->gl_driver)\n\t\treturn GF_FALSE;\n\n\tif (filter->session->gl_driver->hw_caps & GF_VIDEO_HW_ATTACHED) {\n\t\tfilter->session->gl_driver->hw_caps &= ~GF_VIDEO_HW_ATTACHED;\n\t\tfilter->session->gl_driver->on_event = fsess_on_event;\n\t\tfilter->session->gl_driver->evt_cbk_hdl = filter->session;\n\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\n\n#else\nvoid *gf_filter_claim_opengl_provider(GF_Filter *filter)\n{\n\treturn NULL;\n}\nBool gf_filter_unclaim_opengl_provider(GF_Filter *filter, void *vout)\n{\n\treturn GF_FALSE;\n}\n\n#endif\n\n\nGF_EXPORT\nu32 gf_fs_get_http_max_rate(GF_FilterSession *fs)\n{\n#ifdef GPAC_USE_DOWNLOADER\n\tif (!fs->download_manager) {\n\t\tgf_fs_get_download_manager(fs);\n\t\tif (!fs->download_manager) return 0;\n\t}\n\treturn gf_dm_get_data_rate(fs->download_manager);\n#else\n\treturn 0;\n#endif\n}\n\nGF_EXPORT\nGF_Err gf_fs_set_http_max_rate(GF_FilterSession *fs, u32 rate)\n{\n#ifdef GPAC_USE_DOWNLOADER\n\tif (!fs) return GF_OK;\n\tif (!fs->download_manager) {\n\t\tgf_fs_get_download_manager(fs);\n\t\tif (!fs->download_manager) return GF_OUT_OF_MEM;\n\t}\n\tgf_dm_set_data_rate(fs->download_manager, rate);\n#endif\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu32 gf_fs_get_http_rate(GF_FilterSession *fs)\n{\n#ifdef GPAC_USE_DOWNLOADER\n\tif (!fs->download_manager) {\n\t\tgf_fs_get_download_manager(fs);\n\t\tif (!fs->download_manager) return 0;\n\t}\n\treturn gf_dm_get_global_rate(fs->download_manager);\n#else\n\treturn 0;\n#endif\n}\n\nGF_EXPORT\nBool gf_fs_is_supported_source(GF_FilterSession *session, const char *url, const char *parent_url)\n{\n\tGF_Err e;\n\tBool is_supported = GF_FALSE;\n\tgf_fs_load_source_dest_internal(session, url, NULL, parent_url, &e, NULL, NULL, GF_TRUE, GF_TRUE, &is_supported, NULL);\n\treturn is_supported;\n}\n\n\nGF_EXPORT\nBool gf_fs_fire_event(GF_FilterSession *fs, GF_Filter *f, GF_FilterEvent *evt, Bool upstream)\n{\n\tBool ret = GF_FALSE;\n\tif (!fs || !evt) return GF_FALSE;\n\n\tGF_FilterPid *on_pid = evt->base.on_pid;\n\tevt->base.on_pid = NULL;\n\tif (f) {\n\t\tif (evt->base.type==GF_FEVT_USER) {\n\t\t\tif (f->freg->process_event && f->event_target) {\n\t\t\t\tgf_mx_p(f->tasks_mx);\n\t\t\t\tf->freg->process_event(f, evt);\n\t\t\t\tgf_mx_v(f->tasks_mx);\n\t\t\t\tret = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\tif (!ret) {\n\t\t\tgf_mx_p(f->tasks_mx);\n\t\t\tif (f->num_output_pids && upstream) ret = GF_TRUE;\n\t\t\telse if (f->num_input_pids && !upstream) ret = GF_TRUE;\n\t\t\tif (ret)\n\t\t\t\tgf_filter_send_event(f, evt, upstream);\n\t\t\tgf_mx_v(f->tasks_mx);\n\t\t}\n\t} else {\n\t\tu32 i, count;\n\t\tgf_fs_lock_filters(fs, GF_TRUE);\n\t\tcount = gf_list_count(fs->filters);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tBool canceled;\n\t\t\tf = gf_list_get(fs->filters, i);\n\t\t\tif (f->disabled || f->removed) continue;\n\t\t\tif (f->multi_sink_target) continue;\n\t\t\tif (!f->freg->process_event) continue;\n\t\t\tif (!f->event_target) continue;\n\n\t\t\tgf_mx_p(f->tasks_mx);\n\t\t\tcanceled = f->freg->process_event(f, evt);\n\t\t\tgf_mx_v(f->tasks_mx);\n\t\t\tret = GF_TRUE;\n\t\t\tif (canceled) break;\n\t\t}\n\t\tgf_fs_lock_filters(fs, GF_FALSE);\n\t}\n\tevt->base.on_pid = on_pid;\n\treturn ret;\n}\n\nGF_EXPORT\nGF_Err gf_fs_set_filter_creation_callback(GF_FilterSession *session, gf_fs_on_filter_creation on_create_destroy, void *udta, Bool force_sync)\n{\n\tif (!session) return GF_BAD_PARAM;\n\tsession->rt_udta = udta;\n\tsession->on_filter_create_destroy = on_create_destroy;\n\tsession->force_main_thread_tasks = force_sync;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nvoid *gf_fs_get_rt_udta(GF_FilterSession *session)\n{\n\tif (!session) return NULL;\n\treturn session->rt_udta;\n}\n\nGF_EXPORT\nGF_Err gf_fs_set_external_gl_provider(GF_FilterSession *session, gf_fs_gl_activate on_gl_activate, void *udta)\n{\n\tif (!session || !on_gl_activate || session->ext_gl_callback) return GF_BAD_PARAM;\n\tif (gf_list_count(session->filters)) return GF_BAD_PARAM;\n\tsession->ext_gl_udta = udta;\n\tsession->ext_gl_callback = on_gl_activate;\n\treturn GF_OK;\n}\n#ifdef GF_FS_ENABLE_LOCALES\n\nstatic Bool fsess_find_res(GF_FSLocales *loc, char *parent, char *path, char *relocated_path, char *localized_rel_path)\n{\n\tFILE *f;\n\n\tif (loc->szAbsRelocatedPath) gf_free(loc->szAbsRelocatedPath);\n\tloc->szAbsRelocatedPath = gf_url_concatenate(parent, path);\n\tif (!loc->szAbsRelocatedPath) loc->szAbsRelocatedPath = gf_strdup(path);\n\n\tf = gf_fopen(loc->szAbsRelocatedPath, \"rb\");\n\tif (f) {\n\t\tgf_fclose(f);\n\t\tstrcpy(localized_rel_path, path);\n\t\tstrcpy(relocated_path, loc->szAbsRelocatedPath);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/* Checks if, for a given relative path, there exists a localized version in an given folder\n   if this is the case, it returns the absolute localized path, otherwise it returns null.\n   if the resource was localized, the last parameter is set to the localized relative path.\n*/\nstatic Bool fs_check_locales(void *__self, const char *locales_parent_path, const char *rel_path, char *relocated_path, char *localized_rel_path)\n{\n\tchar path[GF_MAX_PATH];\n\tconst char *opt;\n\n\tGF_FSLocales *loc = (GF_FSLocales*)__self;\n\n\t/* Checks if the rel_path argument really contains a relative path (no ':', no '/' at the beginning) */\n\tif (strstr(rel_path, \"://\") || (rel_path[0]=='/') || strstr(rel_path, \":\\\\\") || !strncmp(rel_path, \"\\\\\\\\\", 2)) {\n\t\treturn 0;\n\t}\n\n\t/*Checks if the absolute path is really absolute and points to a local file (no http or else) */\n\tif (!locales_parent_path ||\n\t        (locales_parent_path && (locales_parent_path[0] != '/') && strstr(locales_parent_path, \"://\") && strnicmp(locales_parent_path, \"file://\", 7))) {\n\t\treturn 0;\n\t}\n\topt = gf_opts_get_key(\"core\", \"lang\");\n\tif (opt && (!strcmp(opt, \"*\") || !strcmp(opt, \"un\") ) ) {\n\t\topt = NULL;\n\t}\n\n\twhile (opt) {\n\t\tchar lan[100];\n\t\tchar *sep;\n\t\tchar *sep_lang = strchr(opt, ';');\n\t\tif (sep_lang) sep_lang[0] = 0;\n\n\t\twhile (strchr(\" \\t\", opt[0]))\n\t\t\topt++;\n\n\t\tstrcpy(lan, opt);\n\n\t\tif (sep_lang) {\n\t\t\tsep_lang[0] = ';';\n\t\t\topt = sep_lang+1;\n\t\t} else {\n\t\t\topt = NULL;\n\t\t}\n\n\t\twhile (1) {\n\t\t\tsep = strstr(lan, \"-*\");\n\t\t\tif (!sep) break;\n\t\t\tstrncpy(sep, sep+2, strlen(sep)-2);\n\t\t}\n\n\t\tsprintf(path, \"locales/%s/%s\", lan, rel_path);\n\t\tif (fsess_find_res(loc, (char *) locales_parent_path, (char *) path, relocated_path, localized_rel_path))\n\t\t\treturn 1;\n\n\t\t/*recursively remove region (sub)tags*/\n\t\twhile (1) {\n\t\t\tsep = strrchr(lan, '-');\n\t\t\tif (!sep) break;\n\t\t\tsep[0] = 0;\n\t\t\tsprintf(path, \"locales/%s/%s\", lan, rel_path);\n\t\t\tif (fsess_find_res(loc, (char *) locales_parent_path, (char *) path, relocated_path, localized_rel_path))\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (fsess_find_res(loc, (char *) locales_parent_path, (char *) rel_path, relocated_path, localized_rel_path))\n\t\treturn 1;\n\t/* if we did not find the localized file, both the relocated and localized strings are NULL */\n\tstrcpy(localized_rel_path, \"\");\n\tstrcpy(relocated_path, \"\");\n\treturn 0;\n}\n#endif\n\nstatic Bool gf_fs_relocate_url(GF_FilterSession *session, const char *service_url, const char *parent_url, char *out_relocated_url, char *out_localized_url)\n{\n#ifdef GF_FS_ENABLE_LOCALES\n\tu32 i, count;\n\n\tcount = gf_list_count(session->uri_relocators);\n\tfor (i=0; i<count; i++) {\n\t\tBool result;\n\t\tGF_URIRelocator *uri_relocator = gf_list_get(session->uri_relocators, i);\n\t\tresult = uri_relocator->relocate_uri(uri_relocator, parent_url, service_url, out_relocated_url, out_localized_url);\n\t\tif (result) return 1;\n\t}\n#endif\n\treturn 0;\n}\n\nGF_EXPORT\nBool gf_filter_relocate_url(GF_Filter *filter, const char *service_url, const char *parent_url, char *out_relocated_url, char *out_localized_url)\n{\n\tif (!filter) return 0;\n\treturn gf_fs_relocate_url(filter->session, service_url, parent_url, out_relocated_url, out_localized_url);\n}\n\n\n#ifdef GPAC_CONFIG_EMSCRIPTEN\nvoid gf_fs_force_non_blocking(GF_FilterSession *fs)\n{\n\tif (fs) fs->non_blocking = GF_TRUE;\n}\nBool gf_filter_on_main_thread(GF_Filter *filter)\n{\n\tif (!filter) return GF_TRUE;\n\tif (gf_th_id() != filter->session->main_th.th_id) return GF_FALSE;\n\tif (filter->session->is_worker) return GF_FALSE;\n\treturn GF_TRUE;\n}\n#endif\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2017-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / filters sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terfsess of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include \"filter_session.h\"\n#include <gpac/network.h>\n\n#ifndef GPAC_DISABLE_3D\n#include <gpac/modules/video_out.h>\n#endif\n\n//#define CHECK_TASK_LIST_INTEGRITY\n\n#ifndef GPAC_DISABLE_FONTS\nstruct _gf_ft_mgr *gf_font_manager_new();\nvoid gf_font_manager_del(struct _gf_ft_mgr *fm);\n#endif\n\nstatic GFINLINE void gf_fs_sema_io(GF_FilterSession *fsess, Bool notify, Bool main)\n{\n\t//we don't use sema on emscripten, we always give control back to main caller or pthread\n#ifndef GPAC_CONFIG_EMSCRIPTEN\n\tGF_Semaphore *sem = main ? fsess->semaphore_main : fsess->semaphore_other;\n\tif (sem) {\n\t\tif (notify) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u notify scheduler %s semaphore\\n\", gf_th_id(), main ? \"main\" : \"secondary\"));\n\t\t\tif ( ! gf_sema_notify(sem, 1)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCHEDULER, (\"Cannot notify scheduler of new task, semaphore failure\\n\"));\n\t\t\t}\n\t\t} else {\n\t\t\tu32 nb_tasks;\n\t\t\t//if not main and no tasks in main list, this could be the last task to process.\n\t\t\t//if main thread is sleeping force a wake to take further actions (only the main thread decides the exit)\n\t\t\t//this also ensures that the main thread will process tasks from secondary task lists if no\n\t\t\t//dedicated main thread tasks are present (eg no GL filters)\n\t\t\tif (!main && fsess->in_main_sem_wait && !gf_fq_count(fsess->main_thread_tasks)) {\n\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_TRUE);\n\t\t\t}\n\t\t\tnb_tasks = 1;\n\t\t\t//no active threads, count number of tasks. If no posted tasks we are likely at the end of the session, don't block, rather use a sem_wait \n\t\t\tif (!fsess->active_threads)\n\t\t\t \tnb_tasks = gf_fq_count(fsess->main_thread_tasks) + gf_fq_count(fsess->tasks);\n\n\t\t\t//if main semaphore, keep track that we are going to sleep\n\t\t\tif (main) {\n\t\t\t\tfsess->in_main_sem_wait = GF_TRUE;\n\t\t\t\tif (!nb_tasks) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"No tasks scheduled, waiting on main semaphore for at most 100 ms\\n\"));\n\t\t\t\t\tif (gf_sema_wait_for(sem, 100)) {\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (gf_sema_wait(sem)) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfsess->in_main_sem_wait = GF_FALSE;\n\t\t\t} else {\n\t\t\t\tif (!nb_tasks) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"No tasks scheduled, waiting on secondary semaphore for at most 100 ms\\n\"));\n\t\t\t\t\tif (gf_sema_wait_for(sem, 100)) {\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (gf_sema_wait(sem)) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif // GPAC_CONFIG_EMSCRIPTEN\n}\n\n\nGF_EXPORT\nvoid gf_fs_add_filter_register(GF_FilterSession *fsess, const GF_FilterRegister *freg)\n{\n\tif (!freg) return;\n\tif (!fsess) {\n\t\tif (freg->register_free) freg->register_free(fsess, (GF_FilterRegister *)freg);\n\t\treturn;\n\t}\n\n\tif (!freg->name) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Filter missing name - ignoring\\n\"));\n\t\tif (freg->register_free) freg->register_free(fsess, (GF_FilterRegister *)freg);\n\t\treturn;\n\t}\n#if 0\n\tif (strchr(freg->name, fsess->sep_args)\t) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Filter name cannot contain argument separator %c - ignoring\\n\", fsess->sep_args));\n\t\tif (freg->register_free) freg->register_free(fsess, (GF_FilterRegister *)freg);\n\t\treturn;\n\t}\n\tif (strchr(freg->name, fsess->sep_name)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Filter name cannot contain argument value separator %c - ignoring\\n\", fsess->sep_name));\n\t\tif (freg->register_free) freg->register_free(fsess, (GF_FilterRegister *)freg);\n\t\treturn;\n\t}\n#endif\n\tif (!freg->process) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Filter %s missing process function - ignoring\\n\", freg->name));\n\t\tif (freg->register_free) freg->register_free(fsess, (GF_FilterRegister *)freg);\n\t\treturn;\n\t}\n\n\t//except for meta filters, don't accept a filter with input caps but no output caps\n\t//meta filters do follow the same rule, however when expanding them for help we may have weird cases\n\t//where no config is set but inputs are listed to expose mime types or extensions (cf ffdmx)\n\tif (!(freg->flags & GF_FS_REG_META)\n\t\t&& !freg->configure_pid\n\t\t&& gf_filter_has_in_caps(freg->caps, freg->nb_caps)\n\t) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Filter %s missing configure_pid function but has input capabilities - ignoring\\n\", freg->name));\n\t\tif (freg->register_free) freg->register_free(fsess, (GF_FilterRegister *)freg);\n\t\treturn;\n\t}\n\n\tgf_mx_p(fsess->filters_mx);\n\tgf_list_add(fsess->registry, (void *) freg);\n\tgf_mx_v(fsess->filters_mx);\n\n\tif (fsess->init_done && fsess->links && gf_list_count( fsess->links)) {\n\t\tgf_filter_sess_build_graph(fsess, freg);\n\t}\n}\n\nstatic Bool fs_default_event_proc(void *ptr, GF_Event *evt)\n{\n\tGF_FilterSession *fs = (GF_FilterSession *)ptr;\n\tif (evt->type==GF_EVENT_QUIT) {\n\t\tgf_fs_abort(fs, (evt->message.error) ? GF_FS_FLUSH_NONE : GF_FS_FLUSH_FAST);\n\t}\n\tif (evt->type==GF_EVENT_MESSAGE) {\n\t\tif (evt->message.error) {\n\t\t\tif (evt->message.service) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"Service %s %s: %s\\n\", evt->message.service, evt->message.message, gf_error_to_string(evt->message.error) ))\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"%s: %s\\n\", evt->message.message, gf_error_to_string(evt->message.error) ))\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef GPAC_HAS_QJS\n\tif (fs->on_evt_task && jsfs_on_event(fs, evt))\n\t\treturn GF_TRUE;\n#endif\n\n\tif (evt->type==GF_EVENT_AUTHORIZATION) {\n#ifdef GPAC_HAS_QJS\n\t\tif (fs->on_auth_task && jsfs_on_auth(fs, evt))\n\t\t\treturn GF_TRUE;\n#endif\n\n\t\tif (gf_sys_is_test_mode()) {\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tassert( evt->type == GF_EVENT_AUTHORIZATION);\n\t\tassert( evt->auth.user);\n\t\tassert( evt->auth.password);\n\t\tassert( evt->auth.site_url);\n\n\t\tfprintf(stderr, \"**** Authorization required for site %s %s ****\\n\", evt->auth.site_url, evt->auth.secure ? \"(secure)\" : \"- NOT SECURE\");\n\t\tfprintf(stderr, \"login   : \");\n\t\tif (!gf_read_line_input(evt->auth.user, 50, 1))\n\t\t\treturn GF_FALSE;\n\t\tfprintf(stderr, \"\\npassword: \");\n\t\tif (!gf_read_line_input(evt->auth.password, 50, 0))\n\t\t\treturn GF_FALSE;\n\t\tfprintf(stderr, \"*********\\n\");\n\n\t\tif (evt->auth.on_usr_pass) {\n\t\t\tevt->auth.on_usr_pass(evt->auth.async_usr_data, evt->auth.user, evt->auth.password, GF_FALSE);\n\t\t\tevt->auth.password[0] = 0;\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\n\treturn GF_FALSE;\n}\n\n\n#ifdef GF_FS_ENABLE_LOCALES\nstatic Bool fs_check_locales(void *__self, const char *locales_parent_path, const char *rel_path, char *relocated_path, char *localized_rel_path);\n#endif\n\n#ifdef __EMSCRIPTEN_PTHREADS__\n#include <emscripten/threading.h>\n#endif\n\nGF_EXPORT\nGF_FilterSession *gf_fs_new(s32 nb_threads, GF_FilterSchedulerType sched_type, u32 flags, const char *blacklist)\n{\n\tconst char *opt;\n\tBool gf_sys_has_filter_global_args();\n\tBool gf_sys_has_filter_global_meta_args();\n\tu32 i;\n\tGF_FilterSession *fsess, *a_sess;\n\n\t//safety check: all built-in properties shall have unique 4CCs\n\tif (gf_sys_is_test_mode() && ! gf_props_4cc_check_props())\n\t\treturn NULL;\n\n\tGF_SAFEALLOC(fsess, GF_FilterSession);\n\tif (!fsess) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Failed to alloc media session\\n\"));\n\t\treturn NULL;\n\t}\n\t//reverse implicit mode flag, we run by default in this mode\n\tif (flags & GF_FS_FLAG_NO_IMPLICIT)\n\t\tflags &= ~GF_FS_FLAG_IMPLICIT_MODE;\n\telse\n\t\tflags |= GF_FS_FLAG_IMPLICIT_MODE;\n\n\tfsess->flags = flags;\n\n\tif (gf_opts_get_bool(\"core\", \"no-mx\"))\n\t\tnb_threads=0;\n\n#ifdef __EMSCRIPTEN_PTHREADS__\n\t//detect if we run as a worker\n\tif (!emscripten_is_main_runtime_thread()) {\n\t\tfsess->is_worker = GF_TRUE;\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Session running in worker mode\\n\"));\n\t}\n#endif\n\n\tfsess->filters = gf_list_new();\n\tfsess->main_th.fsess = fsess;\n\n\tif ((s32) nb_threads == -1) {\n\t\tGF_SystemRTInfo rti;\n\t\tmemset(&rti, 0, sizeof(GF_SystemRTInfo));\n\t\tif (gf_sys_get_rti(0, &rti, 0)) {\n\t\t\tnb_threads = rti.nb_cores-1;\n\t\t}\n\t\tif ((s32)nb_threads<0) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"Failed to query number of cores, disabling extra threads for session\\n\"));\n\t\t\tnb_threads=0;\n\t\t}\n\t}\n\n\tif (sched_type==GF_FS_SCHEDULER_DIRECT) {\n\t\tfsess->direct_mode = GF_TRUE;\n\t\tnb_threads=0;\n\t}\n\tif (nb_threads && (sched_type != GF_FS_SCHEDULER_LOCK_FREE_X)) {\n\t\tfsess->tasks_mx = gf_mx_new(\"TasksList\");\n\t}\n\n\t//regardless of scheduler type, we don't use lock on the main task list\n\tfsess->tasks = gf_fq_new(fsess->tasks_mx);\n\n\tif (nb_threads>0) {\n\t\tfsess->main_thread_tasks = gf_fq_new(fsess->tasks_mx);\n\t\tfsess->filters_mx = gf_mx_new(\"Filters\");\n\t} else {\n\t\t//otherwise use the same as the global task list\n\t\tfsess->main_thread_tasks = fsess->tasks;\n\t}\n\n\tif (!(flags & GF_FS_FLAG_NO_RESERVOIR)) {\n\t\tfsess->tasks_reservoir = gf_fq_new(fsess->tasks_mx);\n\t}\n\n\tif (nb_threads || (sched_type==GF_FS_SCHEDULER_LOCK_FORCE) ) {\n\t\tfsess->semaphore_main = fsess->semaphore_other = gf_sema_new(GF_INT_MAX, 0);\n\t\tif (nb_threads>0)\n\t\t\tfsess->semaphore_other = gf_sema_new(GF_INT_MAX, 0);\n\n\t\t//force testing of mutex queues\n\t\t//fsess->use_locks = GF_TRUE;\n\t}\n\tfsess->ui_event_proc = fs_default_event_proc;\n\tfsess->ui_opaque = fsess;\n\n\tif (flags & GF_FS_FLAG_NON_BLOCKING)\n\t\tfsess->non_blocking = 1;\n\n\tif (!fsess->semaphore_main)\n\t\tnb_threads=0;\n\n#ifndef GPAC_DISABLE_THREADS\n\tif (nb_threads) {\n\t\tfsess->threads = gf_list_new();\n\t\tif (!fsess->threads) {\n\t\t\tgf_sema_del(fsess->semaphore_main);\n\t\t\tfsess->semaphore_main=NULL;\n\t\t\tgf_sema_del(fsess->semaphore_other);\n\t\t\tfsess->semaphore_other=NULL;\n\t\t\tnb_threads=0;\n\t\t}\n\t\tfsess->use_locks = (sched_type==GF_FS_SCHEDULER_LOCK) ? GF_TRUE : GF_FALSE;\n\t} else\n#endif\n\t{\n#ifdef GPAC_MEMORY_TRACKING\n\t\textern int gf_mem_track_enabled;\n\t\tfsess->check_allocs = gf_mem_track_enabled;\n#endif\n\n\t}\n\n\tif (fsess->use_locks)\n\t\tfsess->props_mx = gf_mx_new(\"FilterSessionProps\");\n\n\tif (!(flags & GF_FS_FLAG_NO_RESERVOIR)) {\n#if GF_PROPS_HASHTABLE_SIZE\n\t\tfsess->prop_maps_list_reservoir = gf_fq_new(fsess->props_mx);\n#endif\n\t\tfsess->prop_maps_reservoir = gf_fq_new(fsess->props_mx);\n\t\tfsess->prop_maps_entry_reservoir = gf_fq_new(fsess->props_mx);\n\t\tfsess->prop_maps_entry_data_alloc_reservoir = gf_fq_new(fsess->props_mx);\n\t\t//we also use the props mutex for the this one\n\t\tfsess->pcks_refprops_reservoir = gf_fq_new(fsess->props_mx);\n\t}\n\n\n#ifndef GPAC_DISABLE_REMOTERY\n\tsprintf(fsess->main_th.rmt_name, \"FSThread0\");\n#endif\n\n\tif (!fsess->filters || !fsess->tasks) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Failed to alloc media session\\n\"));\n\t\tfsess->run_status = GF_OUT_OF_MEM;\n\t\tgf_fs_del(fsess);\n\t\treturn NULL;\n\t}\n\n\tif (nb_threads) {\n\t\tfsess->info_mx = gf_mx_new(\"FilterSessionInfo\");\n\t\tfsess->ui_mx = gf_mx_new(\"FilterSessionUIProc\");\n\t}\n\n#ifndef GPAC_DISABLE_THREADS\n\tfor (i=0; i<(u32) nb_threads; i++) {\n\t\tchar szName[30];\n\t\tGF_SessionThread *sess_thread;\n\t\tGF_SAFEALLOC(sess_thread, GF_SessionThread);\n\t\tif (!sess_thread) continue;\n#ifndef GPAC_DISABLE_REMOTERY\n\t\tsprintf(sess_thread->rmt_name, \"FSThread%d\", i+1);\n#endif\n\t\tsprintf(szName, \"gf_fs_th_%d\", i+1);\n\t\tsess_thread->th = gf_th_new(szName);\n\t\tif (!sess_thread->th) {\n\t\t\tgf_free(sess_thread);\n\t\t\tcontinue;\n\t\t}\n\t\tsess_thread->fsess = fsess;\n\t\tgf_list_add(fsess->threads, sess_thread);\n\t}\n#endif\n\n\tgf_fs_set_separators(fsess, NULL);\n\n\tfsess->registry = gf_list_new();\n#ifdef GPAC_HAS_QJS\n\t//keep copy of blacklist for JS\n\tfsess->blacklist = blacklist ? gf_strdup(blacklist) : NULL;\n#else\n\tfsess->blacklist = (char*)blacklist;\n#endif\n\ta_sess = (flags & GF_FS_FLAG_LOAD_META) ? fsess : NULL;\n\tgf_fs_reg_all(fsess, a_sess);\n\n#ifndef GPAC_HAS_QJS\n\tfsess->blacklist = NULL;\n#endif\n\n\t//todo - find a way to handle events without mutex ...\n\tfsess->evt_mx = gf_mx_new(\"Event mutex\");\n\n\tfsess->blocking_mode = GF_FS_BLOCK_ALL;\n\topt = gf_opts_get_key(\"core\", \"no-block\");\n\tif (opt) {\n\t\tif (!strcmp(opt, \"fanout\")) {\n\t\t\tfsess->blocking_mode = GF_FS_NOBLOCK_FANOUT;\n\t\t}\n\t\telse if (!strcmp(opt, \"all\")) {\n\t\t\tfsess->blocking_mode = GF_FS_NOBLOCK;\n\t\t}\n\t}\n\n\tfsess->run_status = GF_EOS;\n\tfsess->nb_threads_stopped = 1+nb_threads;\n\tfsess->default_pid_buffer_max_us = gf_opts_get_int(\"core\", \"buffer-gen\");\n\tfsess->decoder_pid_buffer_max_us = gf_opts_get_int(\"core\", \"buffer-dec\");\n\tfsess->default_pid_buffer_max_units = gf_opts_get_int(\"core\", \"buffer-units\");\n\tfsess->max_resolve_chain_len = 6;\n\tfsess->auto_inc_nums = gf_list_new();\n\n\tif (nb_threads)\n\t\tfsess->links_mx = gf_mx_new(\"FilterRegistryGraph\");\n\tfsess->links = gf_list_new();\n\n#ifndef GPAC_DISABLE_3D\n\tfsess->gl_providers = gf_list_new();\n#endif\n\n\tif (! (fsess->flags & GF_FS_FLAG_NO_GRAPH_CACHE))\n\t\tgf_filter_sess_build_graph(fsess, NULL);\n\n\tfsess->init_done = GF_TRUE;\n\n\t//parse all global filter options for argument tracking\n\tif (gf_sys_has_filter_global_args() || gf_sys_has_filter_global_meta_args()) {\n\t\tu32 nb_args = gf_sys_get_argc();\n\t\tfor (i=0; i<nb_args; i++) {\n\t\t\tchar *arg = (char *)gf_sys_get_arg(i);\n\t\t\tif (arg[0]!='-') continue;\n\t\t\tif ((arg[1]!='-') && (arg[1]!='+')) continue;\n\t\t\tchar *sep = strchr(arg, '=');\n\t\t\tif (sep) sep[0] = 0;\n\t\t\tgf_fs_push_arg(fsess, arg+2, GF_FALSE, (arg[1]=='-') ? GF_ARGTYPE_GLOBAL : GF_ARGTYPE_META, NULL, NULL);\n\n\t\t\t//force indexing in reframers when dash template with bandwidth is used\n\t\t\tif (sep && !strcmp(arg+2, \"template\") && strstr(sep+1, \"$Bandwidth$\")) {\n\t\t\t\tgf_opts_set_key(\"temp\", \"force_indexing\", \"true\");\n\t\t\t}\n\n\t\t\tif (sep) sep[0] = '=';\n\t\t}\n\t}\n\n#ifdef GF_FS_ENABLE_LOCALES\n\tfsess->uri_relocators = gf_list_new();\n\tfsess->locales.relocate_uri = fs_check_locales;\n\tfsess->locales.sess = fsess;\n\tgf_list_add(fsess->uri_relocators, &fsess->locales);\n#endif\n\treturn fsess;\n}\n\nvoid gf_fs_push_arg(GF_FilterSession *session, const char *szArg, Bool was_found, GF_FSArgItemType type, GF_Filter *meta_filter, const char *sub_opt_name)\n{\n\tu32 meta_len = meta_filter ? (u32) strlen(meta_filter->freg->name) : 0;\n\tBool create_if_not_found = GF_TRUE;\n\tif (session->flags & GF_FS_FLAG_NO_ARG_CHECK)\n\t\treturn;\n\n\t//ignore any meta argument reported (found or not) that is not already present\n\t//if sub_opt_name, we must create an entry\n\tif (!sub_opt_name && (type==GF_ARGTYPE_META_REPORTING)) {\n\t\tcreate_if_not_found = GF_FALSE;\n\t}\n\tif (!session->parsed_args) session->parsed_args = gf_list_new();\n\n\tu32 k, acount = gf_list_count(session->parsed_args);\n\tGF_FSArgItem *ai=NULL;\n\tfor (k=0; k<acount; k++) {\n\t\tai = gf_list_get(session->parsed_args, k);\n\t\tif (!strcmp(ai->argname, szArg))\n\t\t\tbreak;\n\n\t\tif (meta_len\n\t\t\t&& !strncmp(ai->argname, meta_filter->freg->name, meta_len)\n\t\t\t&& ((ai->argname[meta_len]==':') || (ai->argname[meta_len]=='@'))\n\t\t\t&& !strcmp(ai->argname+meta_len+1, szArg)\n\t\t) {\n\t\t\tbreak;\n\t\t}\n\t\tai = NULL;\n\t}\n\tif (!ai && create_if_not_found) {\n\t\tGF_SAFEALLOC(ai, GF_FSArgItem);\n\t\tif (ai) {\n\t\t\tai->argname = gf_strdup(szArg);\n\t\t\tai->type = type;\n\t\t\tif ((type==GF_ARGTYPE_META_REPORTING) && meta_filter) {\n\t\t\t\tai->meta_filter = meta_filter->freg->name;\n\t\t\t\tai->meta_opt = sub_opt_name;\n\t\t\t}\n\t\t\tgf_list_add(session->parsed_args, ai );\n\t\t}\n\t}\n\tif (!ai) return;\n\n\tif (type==GF_ARGTYPE_META_REPORTING) {\n\t\t//meta option declared as true by default at init but notified as not found\n\t\tif (ai->meta_state==3) {\n\t\t\tai->meta_state = 0;\n\t\t\tif (!was_found) ai->opt_found = 0;\n\t\t}\n\t\tif (!ai->meta_state) {\n\t\t\tai->opt_found = 0;\n\t\t\tai->meta_state = 1;\n\t\t\tif (!ai->meta_filter) {\n\t\t\t\tai->meta_filter = meta_filter->freg->name;\n\t\t\t\tai->meta_opt = sub_opt_name;\n\t\t\t}\n\t\t}\n\t\tif (was_found)\n\t\t\tai->meta_state = 2;\n\t} else if (was_found && (!ai->meta_state || !meta_filter) ) {\n\t\tai->opt_found = 1;\n\t\t//initial declaration from filter setup: meta args are declared as true by default\n\t\tif (type==GF_ARGTYPE_LOCAL) {\n\t\t\t//forbid further meta state change\n\t\t\tai->meta_state = 1;\n\t\t\t//meta option, mark as not found\n\t\t\tif (meta_filter) ai->meta_state = 3;\n\t\t\telse ai->meta_filter = NULL;\n\t\t}\n\t}\n}\n\n\nGF_EXPORT\nGF_FilterSession *gf_fs_new_defaults(u32 inflags)\n{\n\tGF_FilterSession *fsess;\n\tGF_FilterSchedulerType sched_type = GF_FS_SCHEDULER_LOCK_FREE;\n\tu32 flags = 0;\n\ts32 nb_threads = gf_opts_get_int(\"core\", \"threads\");\n\tconst char *blacklist = gf_opts_get_key(\"core\", \"blacklist\");\n\tconst char *opt = gf_opts_get_key(\"core\", \"sched\");\n\n\tif (!opt) sched_type = GF_FS_SCHEDULER_LOCK_FREE;\n\telse if (!strcmp(opt, \"lock\")) sched_type = GF_FS_SCHEDULER_LOCK;\n\telse if (!strcmp(opt, \"flock\")) sched_type = GF_FS_SCHEDULER_LOCK_FORCE;\n\telse if (!strcmp(opt, \"direct\")) sched_type = GF_FS_SCHEDULER_DIRECT;\n\telse if (!strcmp(opt, \"free\")) sched_type = GF_FS_SCHEDULER_LOCK_FREE;\n\telse if (!strcmp(opt, \"freex\")) sched_type = GF_FS_SCHEDULER_LOCK_FREE_X;\n\telse {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Unrecognized scheduler type %s\\n\", opt));\n\t\treturn NULL;\n\t}\n\tif (inflags & GF_FS_FLAG_LOAD_META)\n\t\tflags |= GF_FS_FLAG_LOAD_META;\n\n\tif (inflags & GF_FS_FLAG_NON_BLOCKING)\n\t\tflags |= GF_FS_FLAG_NON_BLOCKING;\n\n\tif (inflags & GF_FS_FLAG_NO_GRAPH_CACHE)\n\t\tflags |= GF_FS_FLAG_NO_GRAPH_CACHE;\n\n\tif (inflags & GF_FS_FLAG_PRINT_CONNECTIONS)\n\t\tflags |= GF_FS_FLAG_PRINT_CONNECTIONS;\n\n\tif (inflags & GF_FS_FLAG_NO_IMPLICIT)\n\t\tflags |= GF_FS_FLAG_NO_IMPLICIT;\n\n\tif (gf_opts_get_bool(\"core\", \"dbg-edges\"))\n\t\tflags |= GF_FS_FLAG_PRINT_CONNECTIONS;\n\n\tif (gf_opts_get_bool(\"core\", \"full-link\"))\n\t\tflags |= GF_FS_FLAG_FULL_LINK;\n\n\tif (gf_opts_get_bool(\"core\", \"no-reg\"))\n\t\tflags |= GF_FS_FLAG_NO_REGULATION;\n\n\tif (gf_opts_get_bool(\"core\", \"no-reassign\"))\n\t\tflags |= GF_FS_FLAG_NO_REASSIGN;\n\n\tif (gf_opts_get_bool(\"core\", \"no-graph-cache\"))\n\t\tflags |= GF_FS_FLAG_NO_GRAPH_CACHE;\n\n\tif (gf_opts_get_bool(\"core\", \"no-probe\"))\n\t\tflags |= GF_FS_FLAG_NO_PROBE;\n\telse if (inflags & GF_FS_FLAG_NO_PROBE)\n\t\tflags |= GF_FS_FLAG_NO_PROBE;\n\n\tif (gf_opts_get_bool(\"core\", \"no-argchk\"))\n\t\tflags |= GF_FS_FLAG_NO_ARG_CHECK;\n\n\tif (gf_opts_get_bool(\"core\", \"no-reservoir\"))\n\t\tflags |= GF_FS_FLAG_NO_RESERVOIR;\n\n\n\tfsess = gf_fs_new(nb_threads, sched_type, flags, blacklist);\n\tif (!fsess) return NULL;\n\n\tgf_fs_set_max_resolution_chain_length(fsess, gf_opts_get_int(\"core\", \"max-chain\") );\n\n\tgf_fs_set_max_sleep_time(fsess, gf_opts_get_int(\"core\", \"max-sleep\") );\n\n\topt = gf_opts_get_key(\"core\", \"seps\");\n\tif (opt)\n\t\tgf_fs_set_separators(fsess, opt);\n\n\treturn fsess;\n}\n\n\nGF_EXPORT\nGF_Err gf_fs_set_separators(GF_FilterSession *session, const char *separator_set)\n{\n\tif (!session) return GF_BAD_PARAM;\n\tif (separator_set && (strlen(separator_set)<5)) return GF_BAD_PARAM;\n\n\tif (separator_set) {\n\t\tsession->sep_args = separator_set[0];\n\t\tsession->sep_name = separator_set[1];\n\t\tsession->sep_frag = separator_set[2];\n\t\tsession->sep_list = separator_set[3];\n\t\tsession->sep_neg = separator_set[4];\n\t} else {\n\t\tsession->sep_args = ':';\n\t\tsession->sep_name = '=';\n\t\tsession->sep_frag = '#';\n\t\tsession->sep_list = ',';\n\t\tsession->sep_neg = '!';\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_fs_set_max_resolution_chain_length(GF_FilterSession *session, u32 max_chain_length)\n{\n\tif (!session) return GF_BAD_PARAM;\n\tsession->max_resolve_chain_len = max_chain_length;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_fs_set_max_sleep_time(GF_FilterSession *session, u32 max_sleep)\n{\n\tif (!session) return GF_BAD_PARAM;\n\tsession->max_sleep = max_sleep;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu32 gf_fs_get_max_resolution_chain_length(GF_FilterSession *session)\n{\n\tif (!session) return 0;\n\treturn session->max_resolve_chain_len;\n}\n\nGF_EXPORT\nvoid gf_fs_remove_filter_register(GF_FilterSession *session, GF_FilterRegister *freg)\n{\n\tif (!session || !freg) return;\n\n\tgf_mx_p(session->filters_mx);\n\tgf_list_del_item(session->registry, freg);\n\tgf_mx_v(session->filters_mx);\n\tgf_filter_sess_reset_graph(session, freg);\n}\n\nGF_EXPORT\nvoid gf_fs_set_ui_callback(GF_FilterSession *fs, Bool (*ui_event_proc)(void *opaque, GF_Event *event), void *cbk_udta)\n{\n\tif (fs) {\n\t\tfs->ui_event_proc = ui_event_proc;\n\t\tfs->ui_opaque = cbk_udta;\n\t\tif (!fs->ui_event_proc) {\n\t\t\tfs->ui_event_proc = fs_default_event_proc;\n\t\t\tfs->ui_opaque = fs;\n\t\t}\n\t}\n}\n\nvoid gf_propalloc_del(void *it)\n{\n\tGF_PropertyEntry *pe = (GF_PropertyEntry *)it;\n\tif (pe->prop.value.data.ptr) gf_free(pe->prop.value.data.ptr);\n\tgf_free(pe);\n}\n\n\nGF_EXPORT\nBool gf_fs_enum_unmapped_options(GF_FilterSession *fsess, u32 *idx, const char **argname, u32 *argtype, const char **meta_filter, const char **meta_sub_opt)\n{\n\tif (!fsess || !fsess->parsed_args) return GF_FALSE;\n\tu32 i, count = gf_list_count(fsess->parsed_args);\n\n\tfor (i=*idx; i<count; i++) {\n\t\tGF_FSArgItem *ai = gf_list_get(fsess->parsed_args, i);\n\t\t(*idx)++;\n\t\tif (ai->opt_found || (ai->meta_state==2)) continue;\n\t\tif (argname) *argname = ai->argname;\n\t\tif (argtype) *argtype = ai->type;\n\t\tif (meta_filter) *meta_filter = ai->meta_filter;\n\t\tif (meta_sub_opt) *meta_sub_opt = ai->meta_opt;\n\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\n\nvoid task_canceled(GF_FSTask *task);\nstatic void gf_task_del(void *p)\n{\n\tGF_FSTask *t = (GF_FSTask *) p;\n\ttask_canceled(t);\n\tgf_free(p);\n}\n\nGF_EXPORT\nvoid gf_fs_del(GF_FilterSession *fsess)\n{\n\tassert(fsess);\n\n\tgf_fs_stop(fsess);\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Session destroy begin\\n\"));\n\n\tif (fsess->parsed_args) {\n\t\twhile (gf_list_count(fsess->parsed_args)) {\n\t\t\tGF_FSArgItem *ai = gf_list_pop_back(fsess->parsed_args);\n\t\t\tgf_free(ai->argname);\n\t\t\tgf_free(ai);\n\t\t}\n\t\tgf_list_del(fsess->parsed_args);\n\t}\n\n\t//temporary until we don't introduce fsess_stop\n\tassert(fsess->run_status != GF_OK);\n\tif (fsess->filters) {\n\t\tu32 i, pass, count=gf_list_count(fsess->filters);\n\t\t//first pass: disconnect all filters, since some may have references to property maps or packets \n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 j;\n\t\t\tGF_Filter *filter = gf_list_get(fsess->filters, i);\n\t\t\tfilter->process_th_id = 0;\n\t\t\tfilter->scheduled_for_next_task = GF_TRUE;\n\n\t\t\tif (filter->detached_pid_inst) {\n\t\t\t\twhile (gf_list_count(filter->detached_pid_inst)) {\n\t\t\t\t\tGF_FilterPidInst *pidi = gf_list_pop_front(filter->detached_pid_inst);\n\t\t\t\t\tgf_filter_pid_inst_del(pidi);\n\t\t\t\t}\n\t\t\t\tgf_list_del(filter->detached_pid_inst);\n\t\t\t\tfilter->detached_pid_inst = NULL;\n\t\t\t}\n\n\t\t\tif (filter->postponed_packets) {\n\t\t\t\twhile (gf_list_count(filter->postponed_packets)) {\n\t\t\t\t\tGF_FilterPacket *pck = gf_list_pop_front(filter->postponed_packets);\n\t\t\t\t\tgf_filter_packet_destroy(pck);\n\t\t\t\t}\n\t\t\t\tgf_list_del(filter->postponed_packets);\n\t\t\t\tfilter->postponed_packets = NULL;\n\t\t\t}\n\t\t\tgf_mx_p(filter->tasks_mx);\n\t\t\tfor (j=0; j<filter->num_input_pids; j++) {\n\t\t\t\tGF_FilterPidInst *pidi = gf_list_get(filter->input_pids, j);\n\t\t\t\tgf_filter_pid_inst_reset(pidi);\n\t\t\t}\n\t\t\tgf_mx_v(filter->tasks_mx);\n\t\t\tfilter->scheduled_for_next_task = GF_FALSE;\n\t\t}\n\t\t//second pass, finalize all\n\t\tfor (pass=0; pass<2; pass++) {\n\t\t\tBool has_scripts = GF_FALSE;\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_Filter *filter = gf_list_get(fsess->filters, i);\n\t\t\t\tif (!pass && (filter->freg->flags & GF_FS_REG_SCRIPT)) {\n\t\t\t\t\thas_scripts = GF_TRUE;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (filter->freg->finalize && !filter->finalized) {\n\t\t\t\t\tfilter->finalized = GF_TRUE;\n\t\t\t\t\tFSESS_CHECK_THREAD(filter)\n\t\t\t\t\tfilter->freg->finalize(filter);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!has_scripts) break;\n\t\t}\n\n\t\twhile (gf_list_count(fsess->filters)) {\n\t\t\tGF_Filter *filter = gf_list_pop_back(fsess->filters);\n\n\t\t\tgf_filter_del(filter);\n\t\t}\n\t\tgf_list_del(fsess->filters);\n\t\tfsess->filters = NULL;\n\t}\n\n\tgf_fs_unload_script(fsess, NULL);\n\n#ifdef GPAC_USE_DOWNLOADER\n\tif (fsess->download_manager) gf_dm_del(fsess->download_manager);\n#endif\n\n#ifndef GPAC_DISABLE_FONTS\n\tif (fsess->font_manager) gf_font_manager_del(fsess->font_manager);\n#endif\n\n\tif (fsess->registry) {\n\t\twhile (gf_list_count(fsess->registry)) {\n\t\t\tGF_FilterRegister *freg = gf_list_pop_back(fsess->registry);\n\t\t\tif (freg->register_free) freg->register_free(fsess, freg);\n\t\t}\n\t\tgf_list_del(fsess->registry);\n\t}\n\n\tif (fsess->tasks)\n\t\tgf_fq_del(fsess->tasks, gf_task_del);\n\n\tif (fsess->tasks_reservoir)\n\t\tgf_fq_del(fsess->tasks_reservoir, gf_void_del);\n\n#ifndef GPAC_DISABLE_THREADS\n\tif (fsess->threads) {\n\t\tif (fsess->main_thread_tasks)\n\t\t\tgf_fq_del(fsess->main_thread_tasks, gf_task_del);\n\n\t\twhile (gf_list_count(fsess->threads)) {\n\t\t\tGF_SessionThread *sess_th = gf_list_pop_back(fsess->threads);\n\t\t\tgf_th_del(sess_th->th);\n\t\t\tgf_free(sess_th);\n\t\t}\n\t\tgf_list_del(fsess->threads);\n\t}\n#endif\n\n\tif (fsess->prop_maps_reservoir)\n\t\tgf_fq_del(fsess->prop_maps_reservoir, gf_propmap_del);\n#if GF_PROPS_HASHTABLE_SIZE\n\tif (fsess->prop_maps_list_reservoir)\n\t\tgf_fq_del(fsess->prop_maps_list_reservoir, (gf_destruct_fun) gf_list_del);\n#endif\n\tif (fsess->prop_maps_entry_reservoir)\n\t\tgf_fq_del(fsess->prop_maps_entry_reservoir, gf_void_del);\n\tif (fsess->prop_maps_entry_data_alloc_reservoir)\n\t\tgf_fq_del(fsess->prop_maps_entry_data_alloc_reservoir, gf_propalloc_del);\n\tif (fsess->pcks_refprops_reservoir)\n\t\tgf_fq_del(fsess->pcks_refprops_reservoir, gf_void_del);\n\n\n\tif (fsess->props_mx)\n\t\tgf_mx_del(fsess->props_mx);\n\n\tif (fsess->info_mx)\n\t\tgf_mx_del(fsess->info_mx);\n\n\tif (fsess->ui_mx)\n\t\tgf_mx_del(fsess->ui_mx);\n\n\tif (fsess->semaphore_other && (fsess->semaphore_other != fsess->semaphore_main) )\n\t\tgf_sema_del(fsess->semaphore_other);\n\n\tif (fsess->semaphore_main)\n\t\tgf_sema_del(fsess->semaphore_main);\n\n\tif (fsess->tasks_mx)\n\t\tgf_mx_del(fsess->tasks_mx);\n\n\tif (fsess->filters_mx)\n\t\tgf_mx_del(fsess->filters_mx);\n\n\tif (fsess->evt_mx) gf_mx_del(fsess->evt_mx);\n\tif (fsess->event_listeners) gf_list_del(fsess->event_listeners);\n\n\tif (fsess->links) {\n\t\tgf_filter_sess_reset_graph(fsess, NULL);\n\t\tgf_list_del(fsess->links);\n\t}\n\tif (fsess->links_mx) gf_mx_del(fsess->links_mx);\n\n#ifndef GPAC_DISABLE_3D\n\tgf_list_del(fsess->gl_providers);\n\tif (fsess->gl_driver) {\n\t\tfsess->gl_driver->Shutdown(fsess->gl_driver);\n\t\tgf_modules_close_interface((GF_BaseInterface *)fsess->gl_driver);\n\t}\n#endif\n\n\tif (fsess->auto_inc_nums) {\n\t\twhile(gf_list_count(fsess->auto_inc_nums)) {\n\t\t\tGF_FSAutoIncNum *aint = gf_list_pop_back(fsess->auto_inc_nums);\n\t\t\tgf_free(aint);\n\t\t}\n\t\tgf_list_del(fsess->auto_inc_nums);\n\t}\n\n#ifdef GF_FS_ENABLE_LOCALES\n\tif (fsess->uri_relocators) gf_list_del(fsess->uri_relocators);\n\tif (fsess->locales.szAbsRelocatedPath) gf_free(fsess->locales.szAbsRelocatedPath);\n#endif\n\tif (fsess->blacklist) gf_free(fsess->blacklist);\n\n\tgf_free(fsess);\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Session destroyed\\n\"));\n}\n\nGF_EXPORT\nu32 gf_fs_filters_registers_count(GF_FilterSession *fsess)\n{\n\treturn fsess ? gf_list_count(fsess->registry) : 0;\n}\n\nGF_EXPORT\nconst GF_FilterRegister * gf_fs_get_filter_register(GF_FilterSession *fsess, u32 idx)\n{\n\treturn gf_list_get(fsess->registry, idx);\n}\n\n#ifdef CHECK_TASK_LIST_INTEGRITY\nstatic void check_task_list_enum(void *udta, void *item)\n{\n\tassert(udta != item);\n}\nstatic void check_task_list(GF_FilterQueue *fq, GF_FSTask *task)\n{\n\tif (fq) {\n\t\tgf_fq_enum(fq, check_task_list_enum, task);\n\t}\n}\n#endif\n\nvoid gf_fs_post_task_ex(GF_FilterSession *fsess, gf_fs_task_callback task_fun, GF_Filter *filter, GF_FilterPid *pid, const char *log_name, void *udta, Bool is_configure, Bool force_main_thread, Bool force_direct_call, u32 class_type)\n{\n\tGF_FSTask *task;\n\tBool notified = GF_FALSE;\n\n\tassert(fsess);\n\tassert(task_fun);\n\n\t//only flatten calls if in main thread (we still have some broken filters using threading that could trigger tasks)\n\tif ((force_direct_call || fsess->direct_mode)\n\t\t&& (!filter || !filter->in_process)\n\t\t&& fsess->tasks_in_process\n\t\t&& (gf_th_id()==fsess->main_th.th_id)\n\t) {\n\t\tGF_FSTask atask;\n\t\tu64 task_time = gf_sys_clock_high_res();\n\t\tmemset(&atask, 0, sizeof(GF_FSTask));\n\t\tatask.filter = filter;\n\t\tatask.pid = pid;\n\t\tatask.run_task = task_fun;\n\t\tatask.log_name = log_name;\n\t\tatask.udta = udta;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread 0 task#%d %p executing Filter %s::%s (%d tasks pending)\\n\", fsess->main_th.nb_tasks, &atask, filter ? filter->name : \"none\", log_name, fsess->tasks_pending));\n\t\tif (filter)\n\t\t\tfilter->scheduled_for_next_task = GF_TRUE;\n\t\ttask_fun(&atask);\n\t\tfilter = atask.filter;\n\t\tif (filter) {\n\t\t\tfilter->time_process += gf_sys_clock_high_res() - task_time;\n\t\t\tfilter->scheduled_for_next_task = GF_FALSE;\n\t\t\tfilter->nb_tasks_done++;\n\t\t}\n\t\tif (!atask.requeue_request)\n\t\t\treturn;\n\t\t//asked to requeue the task, post it\n\t}\n\n\t/*this was a gf_filter_process_task request but direct call could not be done or requeue is requested.\n\tprocess_task_queued was incremented by caller without checking for existing process task\n\t\t- If the task was not treated, dec / inc will give the same state, undo process_task_queued increment\n\t\t- If the task was requeued, dec will undo the increment done when requeing the task in gf_filter_check_pending_tasks\n\n\tIn both cases, inc will redo the same logic as in gf_filter_post_process_task_internal, not creating task if gf_filter_process_task is\n\talready scheduled for the filter\n\n\tWe must use safe_int_dec/safe_int_inc here for multi thread cases - cf issue #1778\n\t*/\n\tif (force_direct_call) {\n\t\tassert(filter);\n\t\tsafe_int_dec(&filter->process_task_queued);\n\t\tif (safe_int_inc(&filter->process_task_queued) > 1) {\n\t\t\treturn;\n\t\t}\n\t}\n\ttask = gf_fq_pop(fsess->tasks_reservoir);\n\n\tif (!task) {\n\t\tGF_SAFEALLOC(task, GF_FSTask);\n\t\tif (!task) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCHEDULER, (\"No more memory to post new task\\n\"));\n\t\t\treturn;\n\t\t}\n\t}\n\ttask->filter = filter;\n\ttask->pid = pid;\n\ttask->run_task = task_fun;\n\ttask->log_name = log_name;\n\ttask->udta = udta;\n\ttask->class_type = class_type;\n\n\tif (filter && is_configure) {\n\t\tif (filter->freg->flags & GF_FS_REG_CONFIGURE_MAIN_THREAD)\n\t\t\tforce_main_thread = GF_TRUE;\n\t}\n\n\tif (filter) {\n\t\tgf_mx_p(filter->tasks_mx);\n\n\t\t//no tasks and not scheduled\n\t\tif (! filter->scheduled_for_next_task && !gf_fq_count(filter->tasks)) {\n\t\t\tnotified = task->notified = GF_TRUE;\n\n\t\t\tif (!force_main_thread)\n\t\t\t\tforce_main_thread = (filter->nb_main_thread_forced || (filter->freg->flags & GF_FS_REG_MAIN_THREAD)) ? GF_TRUE : GF_FALSE;\n\t\t} else if (force_main_thread) {\n#if 0\n\t\t\tforce_main_thread = GF_FALSE;\n\t\t\tif (filter->process_th_id && (fsess->main_th.th_id != filter->process_th_id)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCHEDULER, (\"Cannot post task to main thread, filter is already scheduled\\n\"));\n\t\t\t}\n#endif\n\t\t}\n\n#ifdef GPAC_CONFIG_EMSCRIPTEN\n\t\tif (filter->freg->flags & GF_FS_REG_BLOCK_MAIN)\n\t\t\ttask->blocking = GF_TRUE;\n\t\telse\n#endif\n\t\tif (!force_main_thread)\n\t\t\ttask->blocking = (filter->is_blocking_source) ? GF_TRUE : GF_FALSE;\n\t\telse\n\t\t\ttask->force_main = GF_TRUE;\n\n\t\tgf_fq_add(filter->tasks, task);\n\t\tgf_mx_v(filter->tasks_mx);\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u Posted task %p Filter %s::%s (%d (%d) pending, %d process tasks) on %s task list\\n\", gf_th_id(), task, filter->name, task->log_name, fsess->tasks_pending, gf_fq_count(filter->tasks), filter->process_task_queued, task->notified ? (force_main_thread ? \"main\" : \"secondary\") : \"filter\"));\n\t} else {\n\t\ttask->notified = notified = GF_TRUE;\n\t\ttask->force_main = force_main_thread;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u Posted filter-less task %s (%d pending) on secondary task list\\n\", gf_th_id(), task->log_name, fsess->tasks_pending));\n\t}\n\n\t//WARNING, do not use task->notified since the task may have been posted to the filter task list and may already have been swapped\n\t//with a different value !\n\tif (notified) {\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\tcheck_task_list(fsess->main_thread_tasks, task);\n\t\tcheck_task_list(fsess->tasks, task);\n\t\tcheck_task_list(fsess->tasks_reservoir, task);\n#endif\n\t\tassert(task->run_task);\n\t\tif (filter) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u posting filter task, scheduled_for_next_task %d\\n\", gf_th_id(), filter->scheduled_for_next_task));\n\t\t\tassert(!filter->scheduled_for_next_task);\n\t\t}\n\n\t\t//notify/count tasks posted on the main task or regular task lists\n\t\tsafe_int_inc(&fsess->tasks_pending);\n\t\tif (task->force_main) {\n\t\t\tgf_fq_add(fsess->main_thread_tasks, task);\n\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_TRUE);\n\t\t} else {\n\t\t\tassert(task->run_task);\n\t\t\tgf_fq_add(fsess->tasks, task);\n\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_FALSE);\n\t\t}\n\t}\n}\n\nvoid gf_fs_post_task(GF_FilterSession *fsess, gf_fs_task_callback task_fun, GF_Filter *filter, GF_FilterPid *pid, const char *log_name, void *udta)\n{\n\tgf_fs_post_task_ex(fsess, task_fun, filter, pid, log_name, udta, GF_FALSE, GF_FALSE, GF_FALSE, TASK_TYPE_NONE);\n}\n\nvoid gf_fs_post_task_class(GF_FilterSession *fsess, gf_fs_task_callback task_fun, GF_Filter *filter, GF_FilterPid *pid, const char *log_name, void *udta, u32 class_id)\n{\n\tgf_fs_post_task_ex(fsess, task_fun, filter, pid, log_name, udta, GF_FALSE, GF_FALSE, GF_FALSE, class_id);\n}\n\nBool gf_fs_check_filter_register_cap_ex(const GF_FilterRegister *f_reg, u32 incode, GF_PropertyValue *cap_input, u32 outcode, GF_PropertyValue *cap_output, Bool exact_match_only, Bool out_cap_excluded)\n{\n\tu32 j;\n\tu32 has_raw_in = 0;\n\tu32 has_cid_match = 0;\n\tu32 exclude_cid_out = 0;\n\tu32 has_exclude_cid_out = 0;\n\tfor (j=0; j<f_reg->nb_caps; j++) {\n\t\tconst GF_FilterCapability *cap = &f_reg->caps[j];\n\t\tif (!(cap->flags & GF_CAPFLAG_IN_BUNDLE)) {\n\t\t\t//CID not excluded, raw in present and CID explicit match or not included in excluded set\n\t\t\tif (!exclude_cid_out && has_raw_in && (has_cid_match || (!exact_match_only && has_exclude_cid_out) ) ) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\n\t\t\tif (has_raw_in != 2) has_raw_in = 0;\n\t\t\tif (has_cid_match != 2) has_cid_match = 0;\n\t\t\tif (exclude_cid_out != 2) exclude_cid_out = 0;\n\t\t\tif (has_exclude_cid_out != 2) has_exclude_cid_out = 0;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( (cap->flags & GF_CAPFLAG_INPUT) && (cap->code == incode) ) {\n\t\t\tif (! (cap->flags & GF_CAPFLAG_EXCLUDED) && gf_props_equal(&cap->val, cap_input) ) {\n\t\t\t\thas_raw_in = (cap->flags & GF_CAPS_INPUT_STATIC) ? 2 : 1;\n\t\t\t}\n\t\t}\n\t\tif ( (cap->flags & GF_CAPFLAG_OUTPUT) && (cap->code == outcode) ) {\n\t\t\tif (! (cap->flags & GF_CAPFLAG_EXCLUDED)) {\n\t\t\t\tif (gf_props_equal(&cap->val, cap_output) ) {\n\t\t\t\t\tif (out_cap_excluded) {\n\t\t\t\t\t\texclude_cid_out = (cap->flags & GF_CAPS_OUTPUT_STATIC) ? 2 : 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\thas_cid_match = (cap->flags & GF_CAPS_OUTPUT_STATIC) ? 2 : 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tBool prop_equal = gf_props_equal(&cap->val, cap_output);\n\t\t\t\tif (out_cap_excluded)\n\t\t\t\t\tprop_equal = !prop_equal;\n\n\t\t\t\tif (prop_equal) {\n\t\t\t\t\texclude_cid_out = (cap->flags & GF_CAPS_OUTPUT_STATIC) ? 2 : 1;\n\t\t\t\t} else {\n\t\t\t\t\thas_exclude_cid_out = (cap->flags & GF_CAPS_OUTPUT_STATIC) ? 2 : 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//CID not excluded, raw in present and CID explicit match or not included in excluded set\n\tif (!exclude_cid_out && has_raw_in && (has_cid_match || (!exact_match_only && has_exclude_cid_out) ) ) {\n\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\nGF_EXPORT\nBool gf_fs_check_filter_register_cap(const GF_FilterRegister *f_reg, u32 incode, GF_PropertyValue *cap_input, u32 outcode, GF_PropertyValue *cap_output, Bool exact_match_only)\n{\n\treturn gf_fs_check_filter_register_cap_ex(f_reg, incode, cap_input, outcode, cap_output, exact_match_only, GF_FALSE);\n}\n\nGF_Filter *gf_fs_load_encoder(GF_FilterSession *fsess, const char *args, GF_List *filter_blacklist)\n{\n\tGF_Err e;\n\tchar szCodec[3];\n\tchar *cid, *sep;\n\tconst GF_FilterRegister *candidate;\n\tu32 codecid=0;\n\tGF_Filter *filter;\n\tu32 i, count;\n\tGF_PropertyValue cap_in, cap_out;\n\tGF_List *blacklist = NULL;\n\tBool ocap_excluded = GF_FALSE;\n\tszCodec[0] = 'c';\n\tszCodec[1] = fsess->sep_name;\n\tszCodec[2] = 0;\n\n\tcid = args ? strstr(args, szCodec) : NULL;\n\tif (!cid) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Missing codec identifier in \\\"enc\\\" definition: %s\\n\", args ? args : \"no arguments\"));\n\t\treturn NULL;\n\t}\n\tsep = strchr(cid, fsess->sep_args);\n\tif (sep) sep[0] = 0;\n\n\tcodecid = gf_codecid_parse(cid+2);\n#if 0\n\tif (codecid==GF_CODECID_NONE) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Unrecognized codec identifier in \\\"enc\\\" definition: %s\\n\", cid));\n\t\tif (sep) sep[0] = fsess->sep_args;\n\t\treturn NULL;\n\t}\n#endif\n\tif (sep) sep[0] = fsess->sep_args;\n\n\tcap_in.type = GF_PROP_UINT;\n\tcap_in.value.uint = GF_CODECID_RAW;\n\tcap_out.type = GF_PROP_UINT;\n\tif (codecid==GF_CODECID_NONE) {\n\t\tcap_out.value.uint = GF_CODECID_RAW;\n\t\tocap_excluded = GF_TRUE;\n\t} else {\n\t\tcap_out.value.uint = codecid;\n\t}\n\nretry:\n\tcandidate = NULL;\n\tcount = gf_list_count(fsess->registry);\n\tfor (i=0; i<count; i++) {\n\t\tconst GF_FilterRegister *f_reg = gf_list_get(fsess->registry, i);\n\t\tif (blacklist && (gf_list_find(blacklist, (void *) f_reg)>=0) )\n\t\t\tcontinue;\n\t\tif (filter_blacklist && (gf_list_find(filter_blacklist, (void *) f_reg)>=0) )\n\t\t\tcontinue;\n\n\t\tif ( gf_fs_check_filter_register_cap_ex(f_reg, GF_PROP_PID_CODECID, &cap_in, GF_PROP_PID_CODECID, &cap_out, GF_FALSE, ocap_excluded)) {\n\t\t\tif (!candidate || (candidate->priority>f_reg->priority))\n\t\t\t\tcandidate = f_reg;\n\t\t}\n\t}\n\tif (!candidate) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Cannot find any filter providing encoding for %s\\n\", cid));\n\t\tif (blacklist) gf_list_del(blacklist);\n\t\treturn NULL;\n\t}\n\tfilter = gf_filter_new(fsess, candidate, args, NULL, GF_FILTER_ARG_EXPLICIT, &e, NULL, GF_FALSE);\n\tif (!filter) {\n\t\tif (e==GF_NOT_SUPPORTED) {\n\t\t\tif (!blacklist) blacklist = gf_list_new();\n\t\t\tgf_list_add(blacklist, (void *) candidate);\n\t\t\tgoto retry;\n\t\t}\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Failed to load filter %s: %s\\n\", candidate->name, gf_error_to_string(e) ));\n\t} else {\n\t\tfilter->encoder_stream_type = gf_codecid_type(codecid);\n\t}\n\tif (blacklist) gf_list_del(blacklist);\n\treturn filter;\n}\n\nGF_EXPORT\nBool gf_fs_filter_exists(GF_FilterSession *fsess, const char *name)\n{\n\tu32 i, count;\n\n\tif (!strcmp(name, \"enc\")) return GF_TRUE;\n\tif ((strlen(name)>2) && (name[0]=='c') && (name[1]==fsess->sep_name))\n\t\treturn GF_TRUE;\n\n\tcount = gf_list_count(fsess->registry);\n\tfor (i=0;i<count;i++) {\n\t\tconst GF_FilterRegister *f_reg = gf_list_get(fsess->registry, i);\n\t\tif (!strcmp(f_reg->name, name)) {\n\t\t\treturn GF_TRUE;\n\t\t}\n\t}\n\treturn GF_FALSE;\n}\n\nstatic Bool locate_js_script(char *path, const char *file_name, const char *file_ext)\n{\n\tu32 len = (u32) strlen(path);\n\tu32 flen = 20 + (u32) strlen(file_name);\n\n\tchar *apath = gf_malloc(sizeof(char) * (len+flen) );\n\tif (!apath) return GF_FALSE;\n\tstrcpy(apath, path);\n\n\tstrcat(apath, file_name);\n\tif (gf_file_exists(apath)) {\n\t\tstrncpy(path, apath, GF_MAX_PATH-1);\n\t\tpath[GF_MAX_PATH-1] = 0;\n\t\tgf_free(apath);\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Found %s for file %s\\n\", path, file_name));\n\t\treturn GF_TRUE;\n\t}\n\n\tif (!file_ext) {\n\t\tstrcat(apath, \".js\");\n\t\tif (gf_file_exists(apath)) {\n\t\t\tstrncpy(path, apath, GF_MAX_PATH-1);\n\t\t\tpath[GF_MAX_PATH-1] = 0;\n\t\t\tgf_free(apath);\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Found %s for file %s\\n\", path, file_name));\n\t\t\treturn GF_TRUE;\n\t\t}\n\t}\n\tapath[len] = 0;\n\tstrcat(apath, file_name);\n\tstrcat(apath, \"/init.js\");\n\tif (gf_file_exists(apath)) {\n\t\tstrncpy(path, apath, GF_MAX_PATH-1);\n\t\tpath[GF_MAX_PATH-1] = 0;\n\t\tgf_free(apath);\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Found %s for file %s\\n\", path, file_name));\n\t\treturn GF_TRUE;\n\t}\n\tgf_free(apath);\n\treturn GF_FALSE;\n}\n\nBool gf_fs_solve_js_script(char *szPath, const char *file_name, const char *file_ext)\n{\n\tconst char *js_dirs;\n\tif (gf_opts_default_shared_directory(szPath)) {\n\t\tstrcat(szPath, \"/scripts/jsf/\");\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Trying JS filter %s\\n\", szPath));\n\t\tif (locate_js_script(szPath, file_name, file_ext)) {\n\t\t\treturn GF_TRUE;\n\t\t}\n\t} else {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Failed to get default shared dir\\n\"));\n\t}\n\tjs_dirs = gf_opts_get_key(\"core\", \"js-dirs\");\n\twhile (js_dirs && js_dirs[0]) {\n\t\tchar *sep = strchr(js_dirs, ',');\n\t\tif (sep) {\n\t\t\tu32 cplen = (u32) (sep-js_dirs);\n\t\t\tif (cplen>=GF_MAX_PATH) cplen = GF_MAX_PATH-1;\n\t\t\tstrncpy(szPath, js_dirs, cplen);\n\t\t\tszPath[cplen]=0;\n\t\t\tjs_dirs = sep+1;\n\t\t} else {\n\t\t\tstrcpy(szPath, js_dirs);\n\t\t}\n\t\tif (strcmp(szPath, \"$GJS\")) {\n\t\t\tu32 len = (u32) strlen(szPath);\n\t\t\tif (len && (szPath[len-1]!='/') && (szPath[len-1]!='\\\\'))\n\t\t\t\tstrcat(szPath, \"/\");\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Trying JS filter in %s\\n\", szPath));\n\t\t\tif (locate_js_script(szPath, file_name, file_ext))\n\t\t\t\treturn GF_TRUE;\n\t\t}\n\t\tif (!sep) break;\n\t}\n\treturn GF_FALSE;\n}\n\nstatic GF_Filter *gf_fs_load_filter_internal(GF_FilterSession *fsess, const char *name, GF_Err *err_code, Bool *probe_only)\n{\n\tconst char *args=NULL;\n\tconst char *sep, *file_ext;\n\tu32 i, len, count = gf_list_count(fsess->registry);\n\tBool quiet = (err_code && (*err_code == GF_EOS)) ? GF_TRUE : GF_FALSE;\n\n\tassert(fsess);\n\tassert(name);\n\tif (err_code) *err_code = GF_OK;\n\n\t//the first string before any option sep MUST be the filter registry name, so we don't use gf_fs_path_escape_colon here\n\tsep = strchr(name, fsess->sep_args);\n\tif (sep) {\n\t\targs = sep+1;\n\t\tlen = (u32) (sep - name);\n\t} else len = (u32) strlen(name);\n\n\tif (!len) {\n\t\tif (!quiet) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Missing filter name in %s\\n\", name));\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (!strncmp(name, \"enc\", len)) {\n\t\treturn gf_fs_load_encoder(fsess, args, NULL);\n\t}\n\tif ((strlen(name)>2) && (name[0]=='c') && (name[1]==fsess->sep_name)) {\n\t\treturn gf_fs_load_encoder(fsess, name, NULL);\n\t}\n\n\t/*regular filter loading*/\n\tfor (i=0;i<count;i++) {\n\t\tconst GF_FilterRegister *f_reg = gf_list_get(fsess->registry, i);\n\t\tif ((strlen(f_reg->name)==len) && !strncmp(f_reg->name, name, len)) {\n\t\t\tGF_Filter *filter;\n\t\t\tGF_FilterArgType argtype = GF_FILTER_ARG_EXPLICIT;\n\n\t\t\tif ((f_reg->flags & GF_FS_REG_REQUIRES_RESOLVER) && !fsess->max_resolve_chain_len) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Filter %s requires graph resolver but it is disabled\\n\", name));\n\t\t\t\tif (err_code) *err_code = GF_BAD_PARAM;\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tif (f_reg->flags & GF_FS_REG_ACT_AS_SOURCE) argtype = GF_FILTER_ARG_EXPLICIT_SOURCE;\n\t\t\tfilter = gf_filter_new(fsess, f_reg, args, NULL, argtype, err_code, NULL, GF_FALSE);\n\t\t\tif (!filter) return NULL;\n\t\t\tif (!filter->num_output_pids) {\n\t\t\t\t//check we have a src specified for the filter\n\t\t\t\tconst char *src_url = strstr(name, \"src\");\n\t\t\t\tif (src_url && (src_url[3]==fsess->sep_name)) {\n\t\t\t\t\tconst GF_FilterArgs *f_args = filter->instance_args ? filter->instance_args : f_reg->args;\n\t\t\t\t\t//check the filter has an src argument\n\t\t\t\t\t//we don't want to call process on a filter not acting as source until at least one input is connected\n\t\t\t\t\ti=0;\n\t\t\t\t\twhile (f_args && f_args[i].arg_name) {\n\t\t\t\t\t\tif (!strcmp(f_args[i].arg_name, \"src\")) {\n\t\t\t\t\t\t\tgf_filter_post_process_task(filter);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn filter;\n\t\t}\n\t}\n\t/*check JS file*/\n\tfile_ext = gf_file_ext_start(name);\n\tif (file_ext && (file_ext > sep) )\n\t\tfile_ext = NULL;\n\n\tif (!file_ext || strstr(name, \".js\") || strstr(name, \".jsf\") || strstr(name, \".mjs\") ) {\n\t\tBool file_exists = GF_FALSE;\n\t\tchar szName[10+GF_MAX_PATH];\n\t\tchar szPath[10+GF_MAX_PATH];\n\t\tif (len>GF_MAX_PATH)\n\t\t\treturn NULL;\n\n\t\tstrncpy(szPath, name, len);\n\t\tszPath[len]=0;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Trying JS filter %s\\n\", szPath));\n\t\tif (gf_file_exists(szPath)) {\n\t\t\tfile_exists = GF_TRUE;\n\t\t} else {\n\t\t\tstrcpy(szName, szPath);\n\t\t\tfile_exists = gf_fs_solve_js_script(szPath, szName, file_ext);\n\t\t\tif (!file_exists && !file_ext) {\n\t\t\t\tstrcat(szName, \".js\");\n\t\t\t\tif (gf_file_exists(szName)) {\n\t\t\t\t\tstrncpy(szPath, name, len);\n\t\t\t\t\tszPath[len]=0;\n\t\t\t\t\tstrcat(szPath, \".js\");\n\t\t\t\t\tfile_exists = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (file_exists) {\n\t\t\tif (probe_only) {\n\t\t\t\t*probe_only = GF_TRUE;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tsprintf(szName, \"jsf%cjs%c\", fsess->sep_args, fsess->sep_name);\n\t\t\tstrcat(szName, szPath);\n\t\t\tif (name[len])\n\t\t\t\tstrcat(szName, name+len);\n\t\t\treturn gf_fs_load_filter(fsess, szName, err_code);\n\t\t}\n\t}\n\tif (err_code) *err_code = GF_FILTER_NOT_FOUND;\n\treturn NULL;\n}\n\nGF_EXPORT\nGF_Filter *gf_fs_load_filter(GF_FilterSession *fsess, const char *name, GF_Err *err_code)\n{\n\treturn gf_fs_load_filter_internal(fsess, name, err_code, NULL);\n}\n\n//in mono thread mode, we cannot always sleep for the requested timeout in case there are more tasks to be processed\n//this defines the number of pending tasks above which we limit sleep\n#define MONOTH_MIN_TASKS\t2\n//this defines the sleep time for this case\n#define MONOTH_MIN_SLEEP\t5\n\n#if defined(GPAC_CONFIG_EMSCRIPTEN) && !defined(GPAC_DISABLE_THREADS)\n#include <emscripten/threading.h>\nGF_Err gf_th_async_call(GF_Thread *t, u32 (*Run)(void *param), void *param);\n#endif\n\nstatic u32 gf_fs_thread_proc(GF_SessionThread *sess_thread)\n{\n\tGF_FilterSession *fsess = sess_thread->fsess;\n#ifndef GPAC_DISABLE_THREADS\n\tu32 i;\n\tu32 th_count = fsess->threads ? gf_list_count(fsess->threads) : 0;\n\tu32 thid =  1 + gf_list_find(fsess->threads, sess_thread);\n#else\n\tu32 th_count = 0;\n\tu32 thid = 0;\n#endif\n\tu64 enter_time = gf_sys_clock_high_res();\n\tBool use_main_sema = thid ? GF_FALSE : GF_TRUE;\n#ifndef GPAC_DISABLE_LOG\n\tu32 sys_thid = gf_th_id();\n#endif\n\tu64 next_task_schedule_time = 0;\n\tBool do_regulate = (fsess->flags & GF_FS_FLAG_NO_REGULATION) ? GF_FALSE : GF_TRUE;\n\tu32 consecutive_filter_tasks=0;\n\tBool force_secondary_tasks = GF_FALSE;\n\tBool skip_next_sema_wait = GF_FALSE;\n\tGF_Filter *current_filter = NULL;\n\n#if defined(GPAC_CONFIG_EMSCRIPTEN) && !defined(GPAC_DISABLE_THREADS)\n\tBool flush_main_blocking = (!thid && !fsess->is_worker) ? GF_TRUE : GF_FALSE;\n\tif (flush_main_blocking) do_regulate = GF_FALSE;\n#endif\n\n\t//main thread\n\tif (!thid) {\n\t\tif (!sess_thread->run_time) {\n\t\t\tsess_thread->run_time = enter_time;\n\t\t}\n\t\tif (fsess->non_blocking) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Main thread proc enter\\n\"));\n\t\t}\n\t}\n\t//first time we enter the thread proc\n\tif (!sess_thread->th_id) {\n\t\tsess_thread->th_id = gf_th_id();\n#ifdef GPAC_CONFIG_EMSCRIPTEN\n\t\tif (fsess->non_blocking && thid) {\n\t\t\tsess_thread->run_time = 0;\n\t\t\tsafe_int_dec(&fsess->pending_threads);\n\t\t}\n#endif\n\n#ifndef GPAC_DISABLE_REMOTERY\n\t\tgf_rmt_set_thread_name(sess_thread->rmt_name);\n#endif\n\t}\n\n#ifndef GPAC_DISABLE_REMOTERY\n\tsess_thread->rmt_tasks=40;\n#endif\n\n\tgf_rmt_begin(fs_thread, 0);\n\n\tsafe_int_inc(&fsess->active_threads);\n\n\twhile (1) {\n\t\tBool notified;\n\t\tBool requeue = GF_FALSE;\n\t\tu64 active_start, task_time;\n\t\tGF_FSTask *task=NULL;\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\tGF_Filter *prev_current_filter = NULL;\n\t\tBool skip_filter_task_check = GF_FALSE;\n#endif\n\n#ifndef GPAC_DISABLE_REMOTERY\n\t\tsess_thread->rmt_tasks--;\n\t\tif (!sess_thread->rmt_tasks) {\n\t\t\tgf_rmt_end();\n\t\t\tgf_rmt_begin(fs_thread, 0);\n\t\t\tsess_thread->rmt_tasks=40;\n\t\t}\n#endif\n\n#if defined(GPAC_CONFIG_EMSCRIPTEN) && !defined(GPAC_DISABLE_THREADS)\n\t\tif (flush_main_blocking)\n\t\t\temscripten_main_thread_process_queued_calls();\n#endif\n\n\t\tsafe_int_dec(&fsess->active_threads);\n\n\t\tif (!skip_next_sema_wait && (current_filter==NULL)) {\n\t\t\tgf_rmt_begin(sema_wait, GF_RMT_AGGREGATE);\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u Waiting scheduler %s semaphore\\n\", sys_thid, use_main_sema ? \"main\" : \"secondary\"));\n\t\t\t//wait for something to be done\n\t\t\tgf_fs_sema_io(fsess, GF_FALSE, use_main_sema);\n\t\t\tconsecutive_filter_tasks = 0;\n\t\t\tgf_rmt_end();\n#ifdef GPAC_CONFIG_EMSCRIPTEN\n\t\t\t//no tasks on main thread, exit setting in_main_sem_wait to trigger a NOT_READY on fs_run\n\t\t\t//this will give control back to JS\n\t\t\tif (use_main_sema && fsess->non_blocking && !gf_fq_count(fsess->main_thread_tasks)) {\n\t\t\t\tsafe_int_inc(&fsess->active_threads);\n\t\t\t\tfsess->in_main_sem_wait=1;\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t}\n\t\tsafe_int_inc(&fsess->active_threads);\n\t\tskip_next_sema_wait = GF_FALSE;\n\n\t\tactive_start = gf_sys_clock_high_res();\n\n\t\tif (current_filter==NULL) {\n\t\t\t//main thread\n\t\t\tif (thid==0) {\n\t\t\t\tif (!force_secondary_tasks) {\n\t\t\t\t\ttask = gf_fq_pop(fsess->main_thread_tasks);\n\t\t\t\t}\n\t\t\t\tif (!task) {\n\t\t\t\t\ttask = gf_fq_pop(fsess->tasks);\n\t\t\t\t\t//if task is blocking, don't use it, let a secondary thread deal with it\n\t\t\t\t\tif (task && task->blocking) {\n\t\t\t\t\t\tgf_fq_add(fsess->tasks, task);\n\t\t\t\t\t\ttask = NULL;\n\t\t\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_FALSE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tforce_secondary_tasks = GF_FALSE;\n\t\t\t} else {\n\t\t\t\ttask = gf_fq_pop(fsess->tasks);\n\t\t\t\tif (task && (task->force_main || (task->filter && task->filter->nb_main_thread_forced) ) ) {\n\t\t\t\t\t//post to main\n\t\t\t\t\tgf_fq_add(fsess->main_thread_tasks, task);\n\t\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_TRUE);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(!task || task->run_task );\n\t\t\tassert(!task || task->notified );\n\t\t} else {\n\t\t\t//keep task in filter tasks list until done\n\t\t\ttask = gf_fq_head(current_filter->tasks);\n\t\t\tif (task) {\n\t\t\t\tassert( task->run_task );\n\t\t\t\tassert( ! task->notified );\n\n\t\t\t\t//task was requested for main thread\n\t\t\t\tif ((task->force_main || current_filter->nb_main_thread_forced) && thid) {\n\t\t\t\t\t//make task notified and increase pending tasks\n\t\t\t\t\ttask->notified = GF_TRUE;\n\t\t\t\t\tsafe_int_inc(&fsess->tasks_pending);\n\n\t\t\t\t\t//post to main\n\t\t\t\t\tgf_fq_add(fsess->main_thread_tasks, task);\n\t\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_TRUE);\n\t\t\t\t\t//disable current filter\n\t\t\t\t\tcurrent_filter = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!task) {\n\t\t\tu32 force_nb_notif = 0;\n\t\t\tnext_task_schedule_time = 0;\n\t\t\t//no more task and EOS signal\n\t\t\tif (fsess->run_status != GF_OK)\n\t\t\t\tbreak;\n\n\t\t\tif (!fsess->tasks_pending && fsess->main_th.has_seen_eot) {\n\t\t\t\t//check all threads\n\t\t\t\tBool all_done = GF_TRUE;\n\n#ifndef GPAC_DISABLE_THREADS\n\t\t\t\tfor (i=0; i<th_count; i++) {\n\t\t\t\t\tGF_SessionThread *st = gf_list_get(fsess->threads, i);\n\t\t\t\t\tif (!st->has_seen_eot) {\n\t\t\t\t\t\tall_done = GF_FALSE;\n\t\t\t\t\t\tforce_nb_notif++;\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tif (all_done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (current_filter) {\n\t\t\t\tcurrent_filter->scheduled_for_next_task = GF_FALSE;\n\t\t\t\tcurrent_filter->process_th_id = 0;\n\t\t\t\tassert(current_filter->in_process);\n\t\t\t\tcurrent_filter->in_process = GF_FALSE;\n\t\t\t}\n\t\t\tcurrent_filter = NULL;\n\t\t\tsess_thread->active_time += gf_sys_clock_high_res() - active_start;\n\n\n\t\t\t//no pending tasks and first time main task queue is empty, flush to detect if we\n\t\t\t//are indeed done\n\t\t\tif (!fsess->tasks_pending && !fsess->tasks_in_process && !sess_thread->has_seen_eot && !gf_fq_count(fsess->tasks)) {\n\t\t\t\t//maybe last task, force a notify to check if we are truly done\n\t\t\t\tsess_thread->has_seen_eot = GF_TRUE;\n\t\t\t\t//not main thread and some tasks pending on main, notify only ourselves\n\t\t\t\tif (thid && gf_fq_count(fsess->main_thread_tasks)) {\n\t\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, use_main_sema);\n\t\t\t\t}\n\t\t\t\t//main thread exit probing, send a notify to main sema (for this thread), and N for the secondary one\n\t\t\t\telse {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u notify scheduler main semaphore\\n\", gf_th_id()));\n\t\t\t\t\tgf_sema_notify(fsess->semaphore_main, 1);\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u notify scheduler secondary semaphore %d\\n\", gf_th_id(), th_count));\n\t\t\t\t\tgf_sema_notify(fsess->semaphore_other, th_count);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//this thread and the main thread are done but we still have unfinished threads, re-notify everyone\n\t\t\telse if (!fsess->tasks_pending && fsess->main_th.has_seen_eot && force_nb_notif) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u notify scheduler main semaphore\\n\", gf_th_id()));\n\t\t\t\tgf_sema_notify(fsess->semaphore_main, 1);\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u notify scheduler secondary semaphore %d\\n\", gf_th_id(), th_count));\n\t\t\t\tgf_sema_notify(fsess->semaphore_other, th_count);\n\t\t\t}\n\n\t\t\t//no main thread, return\n\t\t\tif (!thid && fsess->non_blocking) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Main thread proc exit\\n\"));\n\t\t\t\tsafe_int_dec(&fsess->active_threads);\n\t\t\t\treturn 0;\n\t\t\t}\n\n#if defined(GPAC_CONFIG_EMSCRIPTEN) && !defined(GPAC_DISABLE_THREADS)\n\t\t\tif (thid && (fsess->run_status == GF_OK)) {\n\t\t\t\tsess_thread->run_time += gf_sys_clock_high_res() - enter_time;\n\t\t\t\tsafe_int_dec(&fsess->active_threads);\n\t\t\t\tgf_th_async_call(sess_thread->th, (gf_thread_run) gf_fs_thread_proc, sess_thread);\n\t\t\t\treturn 0;\n\t\t\t}\n#endif\n\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: no task available\\n\", sys_thid));\n\n\t\t\tif (do_regulate) {\n\t\t\t\tgf_sleep(0);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\tcheck_task_list(fsess->main_thread_tasks, task);\n\t\tcheck_task_list(fsess->tasks, task);\n#endif\n\t\tif (current_filter) {\n\t\t\tassert(current_filter==task->filter);\n\t\t}\n\t\tcurrent_filter = task->filter;\n\n\t\t//unless task was explicitly forced to main (pid init mostly), reschedule if filter is not on desired thread\n\t\tif (current_filter && !task->force_main\n\t\t\t&& current_filter->restrict_th_idx\n\t\t\t&& (thid != current_filter->restrict_th_idx)\n\t\t) {\n\t\t\t//reschedule task to secondary list\n\t\t\tif (!task->notified) {\n\t\t\t\ttask->notified = GF_TRUE;\n\t\t\t\tsafe_int_inc(&fsess->tasks_pending);\n\t\t\t}\n\t\t\tgf_fq_add(fsess->tasks, task);\n\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_FALSE);\n\t\t\tcurrent_filter = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//this is a crude way of scheduling the next task, we should\n\t\t//1- have a way to make sure we will not repost after a time-consuming task\n\t\t//2- have a way to wait for the given amount of time rather than just do a sema_wait/notify in loop\n\t\tif (task->schedule_next_time) {\n\t\t\ts64 now = gf_sys_clock_high_res();\n\t\t\ts64 diff = task->schedule_next_time;\n\t\t\tdiff -= now;\n\t\t\tdiff /= 1000;\n\n\n\t\t\tif (diff > 0) {\n\t\t\t\tGF_FSTask *next;\n\t\t\t\ts64 tdiff = diff;\n\t\t\t\ts64 ndiff = 0;\n\n\t\t\t\t//no filter, just reschedule the task\n\t\t\t\tif (!current_filter) {\n#ifndef GPAC_DISABLE_LOG\n\t\t\t\t\tconst char *task_log_name = task->log_name;\n#endif\n\t\t\t\t\tnext = gf_fq_head(fsess->tasks);\n\t\t\t\t\tnext_task_schedule_time = task->schedule_next_time;\n\t\t\t\t\tassert(task->run_task);\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\t\t\t\tcheck_task_list(fsess->main_thread_tasks, task);\n\t\t\t\t\tcheck_task_list(fsess->tasks, task);\n\t\t\t\t\tcheck_task_list(fsess->tasks_reservoir, task);\n#endif\n\t\t\t\t\t//tasks without filter are currently only posted to the secondary task list\n\t\t\t\t\tgf_fq_add(fsess->tasks, task);\n\t\t\t\t\tif (next) {\n\t\t\t\t\t\tif (next->schedule_next_time <= (u64) now) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: task %s reposted, next task time ready for execution\\n\", sys_thid, task_log_name));\n\n\t\t\t\t\t\t\tskip_next_sema_wait = GF_TRUE;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tndiff = next->schedule_next_time;\n\t\t\t\t\t\tndiff -= now;\n\t\t\t\t\t\tndiff /= 1000;\n\t\t\t\t\t\tif (ndiff<diff) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: task %s scheduled after next task %s:%s (in %d ms vs %d ms)\\n\", sys_thid, task_log_name, next->log_name, next->filter ? next->filter->name : \"\", (s32) diff, (s32) ndiff));\n\t\t\t\t\t\t\tdiff = ndiff;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!do_regulate) {\n\t\t\t\t\t\tdiff = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (diff && do_regulate) {\n\t\t\t\t\t\tif (diff > fsess->max_sleep)\n\t\t\t\t\t\t\tdiff = fsess->max_sleep;\n\t\t\t\t\t\tif (th_count==0) {\n\t\t\t\t\t\t\tif ( gf_fq_count(fsess->tasks) > MONOTH_MIN_TASKS)\n\t\t\t\t\t\t\t\tdiff = MONOTH_MIN_SLEEP;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: task %s reposted, %s task scheduled after this task, sleeping for %d ms (task diff %d - next diff %d)\\n\", sys_thid, task_log_name, next ? \"next\" : \"no\", diff, tdiff, ndiff));\n\t\t\t\t\t\tgf_sleep((u32) diff);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: task %s reposted, next task scheduled after this task, rerun\\n\", sys_thid, task_log_name));\n\t\t\t\t\t}\n\t\t\t\t\tskip_next_sema_wait = GF_TRUE;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!task->filter->finalized) {\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\t\t\t\tnext = gf_fq_head(current_filter->tasks);\n\t\t\t\t\tassert(next == task);\n\t\t\t\t\tcheck_task_list(fsess->main_thread_tasks, task);\n\t\t\t\t\tcheck_task_list(fsess->tasks_reservoir, task);\n#endif\n\n\t\t\t\t\t//next in filter should be handled before this task, move task at the end of the filter task\n\t\t\t\t\tnext = gf_fq_get(current_filter->tasks, 1);\n\t\t\t\t\tif (next && next->schedule_next_time < task->schedule_next_time) {\n\t\t\t\t\t\tif (task->notified) {\n\t\t\t\t\t\t\tassert(fsess->tasks_pending);\n\t\t\t\t\t\t\tsafe_int_dec(&fsess->tasks_pending);\n\t\t\t\t\t\t\ttask->notified = GF_FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: task %s:%s reposted to filter task until task exec time is reached (%d us)\\n\", sys_thid, current_filter->name, task->log_name, (s32) (task->schedule_next_time - next->schedule_next_time) ));\n\t\t\t\t\t\t//remove task\n\t\t\t\t\t\tgf_fq_pop(current_filter->tasks);\n\t\t\t\t\t\t//and queue it after the next one\n\t\t\t\t\t\tgf_fq_add(current_filter->tasks, task);\n\t\t\t\t\t\t//and continue with the same filter\n#if defined(GPAC_CONFIG_EMSCRIPTEN) && !defined(GPAC_DISABLE_THREADS)\n\t\t\t\t\t\tif (thid && (fsess->run_status == GF_OK)) {\n\t\t\t\t\t\t\tsess_thread->run_time += gf_sys_clock_high_res() - enter_time;\n\t\t\t\t\t\t\tsafe_int_dec(&fsess->active_threads);\n\t\t\t\t\t\t\tgf_th_async_call(sess_thread->th, (gf_thread_run) gf_fs_thread_proc, sess_thread);\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//little optim here: if this is the main thread and we have other tasks pending\n\t\t\t\t\t//check the timing of tasks in the secondary list. If a task is present with smaller time than\n\t\t\t\t\t//the head of the main task, force a temporary swap to the secondary task list\n\t\t\t\t\tif (!thid && task->notified && (diff > MONOTH_MIN_SLEEP) ) {\n\t\t\t\t\t\tu32 idx=0;\n\t\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t\tnext = gf_fq_get(fsess->tasks, idx);\n\t\t\t\t\t\t\tif (!next || next->blocking) break;\n\t\t\t\t\t\t\tidx++;\n\n\t\t\t\t\t\t\tu64 next_time_main = task->schedule_next_time;\n\t\t\t\t\t\t\tu64 next_time_secondary = next->schedule_next_time;\n\t\t\t\t\t\t\t//if we have several threads, also check the next task on the main task list\n\t\t\t\t\t\t\t// (different from secondary tasks in multithread case)\n\t\t\t\t\t\t\tif (th_count) {\n\t\t\t\t\t\t\t\tGF_FSTask *next_main = gf_fq_head(fsess->main_thread_tasks);\n\t\t\t\t\t\t\t\tif (next_main && (next_time_main > next_main->schedule_next_time))\n\t\t\t\t\t\t\t\t\tnext_time_main = next_main->schedule_next_time;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (next_time_secondary<next_time_main) {\n\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: forcing secondary task list on main - current task schedule time \"LLU\" (diff to now %d) vs next time secondary \"LLU\" (%s::%s)\\n\", sys_thid, task->schedule_next_time, (s32) diff, next_time_secondary, next->filter ? next->filter->freg->name : \"\", next->log_name));\n\t\t\t\t\t\t\t\tdiff = 0;\n\t\t\t\t\t\t\t\tforce_secondary_tasks = GF_TRUE;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t//move task to main list\n\t\t\t\t\tif (!task->notified) {\n\t\t\t\t\t\ttask->notified = GF_TRUE;\n\t\t\t\t\t\tsafe_int_inc(&fsess->tasks_pending);\n\t\t\t\t\t}\n\n\t\t\t\t\tsess_thread->active_time += gf_sys_clock_high_res() - active_start;\n\n\t\t\t\t\tif (next_task_schedule_time && (next_task_schedule_time <= task->schedule_next_time)) {\n\t\t\t\t\t\ttdiff = next_task_schedule_time;\n\t\t\t\t\t\ttdiff -= now;\n\t\t\t\t\t\tif (tdiff < 0) tdiff=0;\n\t\t\t\t\t\tif (tdiff<diff) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: next task has earlier exec time than current task %s:%s, adjusting sleep (old %d - new %d)\\n\", sys_thid, current_filter->name, task->log_name, (s32) diff, (s32) tdiff));\n\t\t\t\t\t\t\tdiff = tdiff;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: next task has earlier exec time#2 than current task %s:%s, adjusting sleep (old %d - new %d)\\n\", sys_thid, current_filter->name, task->log_name, (s32) diff, (s32) tdiff));\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (do_regulate && diff) {\n\t\t\t\t\t\tif (diff > fsess->max_sleep)\n\t\t\t\t\t\t\tdiff = fsess->max_sleep;\n\t\t\t\t\t\tif (th_count==0) {\n\t\t\t\t\t\t\tif ( gf_fq_count(fsess->tasks) > MONOTH_MIN_TASKS)\n\t\t\t\t\t\t\t\tdiff = MONOTH_MIN_SLEEP;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: task %s:%s postponed for %d ms (scheduled time \"LLU\" us, next task schedule \"LLU\" us)\\n\", sys_thid, current_filter->name, task->log_name, (s32) diff, task->schedule_next_time, next_task_schedule_time));\n\n\t\t\t\t\t\tgf_sleep((u32) diff);\n\t\t\t\t\t\tactive_start = gf_sys_clock_high_res();\n\t\t\t\t\t}\n\t\t\t\t\tdiff = (s64)task->schedule_next_time;\n\t\t\t\t\tdiff -= (s64) gf_sys_clock_high_res();\n\t\t\t\t\tif (diff > 100 ) {\n\t\t\t\t\t\tu32 pending_tasks;\n\t\t\t\t\t\tBool use_main = (current_filter->freg->flags & GF_FS_REG_MAIN_THREAD) ? GF_TRUE : GF_FALSE;\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: releasing current filter %s, exec time for %s due in \"LLD\" us\\n\", sys_thid, current_filter->name, task->log_name, diff));\n\t\t\t\t\t\tcurrent_filter->process_th_id = 0;\n\t\t\t\t\t\tcurrent_filter->in_process = GF_FALSE;\n\t\t\t\t\t\t//don't touch the current filter tasks, just repost the task to the main/secondary list\n\t\t\t\t\t\tassert(gf_fq_count(current_filter->tasks));\n\t\t\t\t\t\tcurrent_filter = NULL;\n\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\t\t\t\t\tcheck_task_list(fsess->main_thread_tasks, task);\n\t\t\t\t\t\tcheck_task_list(fsess->tasks, task);\n\t\t\t\t\t\tcheck_task_list(fsess->tasks_reservoir, task);\n\t\t\t\t\t\tassert(task->run_task);\n#endif\n\n\t\t\t\t\t\tif (use_main) {\n\t\t\t\t\t\t\tpending_tasks = gf_fq_count(fsess->main_thread_tasks);\n\t\t\t\t\t\t\tgf_fq_add(fsess->main_thread_tasks, task);\n\t\t\t\t\t\t\t//we are the main thread and reposting to the main task list, don't notify/wait for the sema, just retry\n\t\t\t\t\t\t\t//we are sure to get a task from main list at next iteration\n\t\t\t\t\t\t\tif (use_main_sema) {\n\t\t\t\t\t\t\t\tskip_next_sema_wait = GF_TRUE;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_TRUE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpending_tasks = gf_fq_count(fsess->main_thread_tasks);\n\t\t\t\t\t\t\tgf_fq_add(fsess->tasks, task);\n\t\t\t\t\t\t\t//we are not the main thread and we are reposting to the secondary task list, don't notify/wait for the sema, just retry\n\t\t\t\t\t\t\t//we are not sure to get a task from secondary list at next iteration, but the end of thread check will make\n\t\t\t\t\t\t\t//sure we renotify secondary sema if some tasks are still pending\n\t\t\t\t\t\t\tif (!use_main_sema) {\n\t\t\t\t\t\t\t\tskip_next_sema_wait = GF_TRUE;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_FALSE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//we temporary force the main thread to fetch a task from the secondary list\n\t\t\t\t\t\t//because the first main task was not yet due for execution\n\t\t\t\t\t\t//it is likely that the execution of the next task will not wake up the main thread\n\t\t\t\t\t\t//but we must reevaluate the previous main task timing, so we force a notification of the main sema\n\t\t\t\t\t\tif (force_secondary_tasks) {\n\t\t\t\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_TRUE);\n\t\t\t\t\t\t} else if (!thid && fsess->non_blocking && !pending_tasks) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Main thread proc exit\\n\"));\n\t\t\t\t\t\t\tsafe_int_dec(&fsess->active_threads);\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\n#if defined(GPAC_CONFIG_EMSCRIPTEN) && !defined(GPAC_DISABLE_THREADS)\n\t\t\t\t\t\tif (thid && (fsess->run_status == GF_OK)) {\n\t\t\t\t\t\t\tsess_thread->run_time += gf_sys_clock_high_res() - enter_time;\n\t\t\t\t\t\t\tsafe_int_dec(&fsess->active_threads);\n\t\t\t\t\t\t\tgf_th_async_call(sess_thread->th, (gf_thread_run) gf_fs_thread_proc, sess_thread);\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tforce_secondary_tasks=GF_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: task %s:%s schedule time \"LLU\" us reached (diff %d ms)\\n\", sys_thid, current_filter ? current_filter->name : \"\", task->log_name, task->schedule_next_time, (s32) diff));\n\n\t\t}\n\t\tnext_task_schedule_time = 0;\n\n\t\tif (current_filter) {\n\t\t\tcurrent_filter->scheduled_for_next_task = GF_TRUE;\n\t\t\tassert(!current_filter->in_process);\n\t\t\tcurrent_filter->in_process = GF_TRUE;\n\t\t\tcurrent_filter->process_th_id = gf_th_id();\n\t\t}\n\n\t\tsess_thread->nb_tasks++;\n\t\tsess_thread->has_seen_eot = GF_FALSE;\n\t\tif (task->filter) {\n\t\t\tassert(gf_fq_count(task->filter->tasks));\n\t\t}\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u task#%d %p executing Filter %s::%s (%d tasks pending, %d(%d) process task queued)\\n\", sys_thid, sess_thread->nb_tasks, task, task->filter ? task->filter->name : \"none\", task->log_name, fsess->tasks_pending, task->filter ? task->filter->process_task_queued : 0, task->filter ? gf_fq_count(task->filter->tasks) : 0));\n\n\t\tsafe_int_inc(& fsess->tasks_in_process );\n\t\tassert( task->run_task );\n\t\ttask_time = gf_sys_clock_high_res();\n\t\t//remember the last time we scheduled this filter\n\t\tif (task->filter)\n\t\t\ttask->filter->last_schedule_task_time = task_time;\n\n\t\ttask->can_swap = 0;\n\t\ttask->requeue_request = GF_FALSE;\n\t\ttask->run_task(task);\n\t\trequeue = task->requeue_request;\n\n\t\ttask_time = gf_sys_clock_high_res() - task_time;\n\t\tsafe_int_dec(& fsess->tasks_in_process );\n\n\t\t//may now be NULL if task was a filter destruction task\n\t\tcurrent_filter = task->filter;\n\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\tprev_current_filter = task->filter;\n#endif\n\n\t\t//source task was current filter, pop the filter task list\n\t\tif (current_filter) {\n\t\t\tBool last_task = GF_FALSE;\n\t\t\tcurrent_filter->nb_tasks_done++;\n\t\t\tcurrent_filter->time_process += task_time;\n\t\t\tconsecutive_filter_tasks++;\n\n#if defined(GPAC_CONFIG_EMSCRIPTEN)\n\t\t\t//for mono-thread case non blocking: if filter is marked as async blocking, abort and release\n\t\t\t//control to caller\n\t\t\tif  (!thid && fsess->non_blocking && (current_filter->freg->flags & GF_FS_REG_ASYNC_BLOCK)) {\n\t\t\t\tconsecutive_filter_tasks=11;\n\t\t\t\tfsess->in_main_sem_wait = GF_TRUE;\n\t\t\t}\n#endif\n\n\t\t\tgf_mx_p(current_filter->tasks_mx);\n\t\t\tif (gf_fq_count(current_filter->tasks)==1) {\n\t\t\t\t//if task is set to immediate reschedule, don't consider this is the last task\n\t\t\t\t//and check consecutive_filter_tasks - this will keep the active filter running\n\t\t\t\t//when the last task is a process task and the filter is not blocking\n\t\t\t\t//FIXME: commented out as this breaks ssome tests, needs further checking\n\t\t\t\t//if (task->can_swap!=2)\n\t\t\t\t{\n\t\t\t\t\tlast_task = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//if last task\n\t\t\tif ( last_task\n\t\t\t\t//if requeue request and stream reset pending (we must exit the filter task loop for the reset task to pe processed)\n\t\t\t\t|| (requeue && current_filter->stream_reset_pending)\n\t\t\t\t//or requeue request and pid swap pending (we must exit the filter task loop for the swap task to pe processed)\n\t\t\t\t|| (requeue && (current_filter->swap_pidinst_src ||  current_filter->swap_pidinst_dst) )\n\t\t\t\t//or requeue request and pid detach / cap negotiate pending\n\t\t\t\t|| (requeue && (current_filter->out_pid_connection_pending || current_filter->detached_pid_inst || current_filter->caps_negociate) )\n\n\t\t\t\t//or requeue request and we have been running on that filter for more than 10 times, abort\n\t\t\t\t|| (requeue && (consecutive_filter_tasks>10))\n\t\t\t) {\n\n\t\t\t\tif (requeue) {\n\t\t\t\t\t//filter task can be pushed back the queue of tasks\n\t\t\t\t\tif (task->can_swap) {\n\t\t\t\t\t\tGF_FSTask *next_task;\n\n\t\t\t\t\t\t//drop task from filter task list\n\t\t\t\t\t\tgf_fq_pop(current_filter->tasks);\n\n\t\t\t\t\t\tnext_task = gf_fq_head(current_filter->tasks);\n\t\t\t\t\t\t//if first task was notified, swap the flag\n\t\t\t\t\t\tif (next_task) {\n\t\t\t\t\t\t\t//see note in post_task_ex for caution about this !!\n\t\t\t\t\t\t\tnext_task->notified = task->notified;\n\t\t\t\t\t\t\ttask->notified = GF_FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//requeue task\n\t\t\t\t\t\tgf_fq_add(current_filter->tasks, task);\n\n\t\t\t\t\t\t//ans swap task for later requeing\n\t\t\t\t\t\tif (next_task) task = next_task;\n\t\t\t\t\t}\n\t\t\t\t\t//otherwise (can't swap) keep task first in the list\n\n\t\t\t\t\t//don't reset scheduled_for_next_task flag if requeued to make sure no other task posted from\n\t\t\t\t\t//another thread will post to main sched\n\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\t\t\t\tskip_filter_task_check = GF_TRUE;\n#endif\n\t\t\t\t} else {\n\t\t\t\t\t//no requeue, filter no longer scheduled and drop task\n\t\t\t\t\tcurrent_filter->scheduled_for_next_task = GF_FALSE;\n\n\t\t\t\t\t//drop task from filter task list\n\t\t\t\t\tgf_fq_pop(current_filter->tasks);\n\t\t\t\t}\n\n\t\t\t\tcurrent_filter->process_th_id = 0;\n\t\t\t\tcurrent_filter->in_process = GF_FALSE;\n\n\t\t\t\t//unlock once we modified in_process, otherwise this will make our assert fail\n\t\t\t\tgf_mx_v(current_filter->tasks_mx);\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\t\t\tif (requeue && !skip_filter_task_check) check_task_list(current_filter->tasks, task);\n#endif\n\t\t\t\tcurrent_filter = NULL;\n\t\t\t} else {\n\t\t\t\t//drop task from filter task list\n\t\t\t\tgf_fq_pop(current_filter->tasks);\n\n\t\t\t\t//not requeued, no more tasks, deactivate filter\n\t\t\t\tif (!requeue && !gf_fq_count(current_filter->tasks)) {\n\t\t\t\t\tcurrent_filter->process_th_id = 0;\n\t\t\t\t\tcurrent_filter->in_process = GF_FALSE;\n\t\t\t\t\tcurrent_filter->scheduled_for_next_task = GF_FALSE;\n\t\t\t\t\tgf_mx_v(current_filter->tasks_mx);\n\t\t\t\t\tcurrent_filter = NULL;\n\t\t\t\t} else {\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\t\t\t\tcheck_task_list(fsess->main_thread_tasks, task);\n\t\t\t\t\tcheck_task_list(fsess->tasks, task);\n\t\t\t\t\tcheck_task_list(fsess->tasks_reservoir, task);\n#endif\n\n\t\t\t\t\t//requeue task in current filter\n\t\t\t\t\tif (requeue)\n\t\t\t\t\t\tgf_fq_add(current_filter->tasks, task);\n\n\t\t\t\t\tgf_mx_v(current_filter->tasks_mx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//do not touch the filter task list after this, it has to be mutex protected to ensure proper posting of tasks\n\n\t\tnotified = task->notified;\n\t\tif (requeue) {\n\t\t\t//if requeue on a filter active, use filter queue to avoid another thread grabing the task (we would have concurrent access to the filter)\n\t\t\tif (current_filter) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u re-posted task Filter %s::%s in filter tasks (%d pending)\\n\", sys_thid, task->filter->name, task->log_name, fsess->tasks_pending));\n\t\t\t\ttask->notified = GF_FALSE;\n\t\t\t\t//keep this thread running on the current filter no signaling of semaphore\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u re-posted task Filter %s::%s in %s tasks (%d pending)\\n\", sys_thid, task->filter ? task->filter->name : \"none\", task->log_name, (task->filter && (task->filter->freg->flags & GF_FS_REG_MAIN_THREAD)) ? \"main\" : \"secondary\", fsess->tasks_pending));\n\n\t\t\t\ttask->notified = GF_TRUE;\n\t\t\t\tsafe_int_inc(&fsess->tasks_pending);\n\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\t\t\tcheck_task_list(fsess->main_thread_tasks, task);\n\t\t\t\tcheck_task_list(fsess->tasks, task);\n\t\t\t\tcheck_task_list(fsess->tasks_reservoir, task);\n\t\t\t\tif (prev_current_filter && !skip_filter_task_check) check_task_list(prev_current_filter->tasks, task);\n#endif\n\n\t\t\t\t//main thread\n\t\t\t\tif (task->filter && (task->filter->freg->flags & GF_FS_REG_MAIN_THREAD)) {\n\t\t\t\t\tgf_fq_add(fsess->main_thread_tasks, task);\n\n#ifndef GPAC_DISABLE_THREADS\n\t\t\t\t\t//FIXME, we sometimes miss a sema notfiy resulting in secondary tasks being locked\n\t\t\t\t\t//until we find the cause, notify secondary sema if non-main-thread tasks are scheduled and we are the only task in main\n\t\t\t\t\tif (use_main_sema && (thid==0) && fsess->threads && (gf_fq_count(fsess->main_thread_tasks)==1) && gf_fq_count(fsess->tasks)) {\n\t\t\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_FALSE);\n\t\t\t\t\t}\n#endif\n\t\t\t\t} else {\n\t\t\t\t\tgf_fq_add(fsess->tasks, task);\n\t\t\t\t}\n\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, use_main_sema);\n\t\t\t}\n\t\t} else {\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\t\tcheck_task_list(fsess->main_thread_tasks, task);\n\t\t\tcheck_task_list(fsess->tasks, task);\n\t\t\tcheck_task_list(fsess->tasks_reservoir, task);\n\t\t\tif (prev_current_filter)\n\t\t\t\tcheck_task_list(prev_current_filter->tasks, task);\n\n\t\t\t{\n\t\t\t\tgf_mx_p(fsess->filters_mx);\n\t\t\t\tu32 k, c2 = gf_list_count(fsess->filters);\n\t\t\t\tfor (k=0; k<c2; k++) {\n\t\t\t\t\tGF_Filter *af = gf_list_get(fsess->filters, k);\n\t\t\t\t\tcheck_task_list(af->tasks, task);\n\t\t\t\t}\n\t\t\t\tgf_mx_v(fsess->filters_mx);\n\t\t\t}\n#endif\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u task#%d %p pushed to reservoir\\n\", sys_thid, sess_thread->nb_tasks, task));\n\n\t\t\tif (fsess->tasks_reservoir) {\n\t\t\t\tmemset(task, 0, sizeof(GF_FSTask));\n\t\t\t\tgf_fq_add(fsess->tasks_reservoir, task);\n\t\t\t} else {\n\t\t\t\tgf_free(task);\n\t\t\t}\n\t\t}\n\n\t\t//decrement task counter\n\t\tif (notified) {\n\t\t\tassert(fsess->tasks_pending);\n\t\t\tsafe_int_dec(&fsess->tasks_pending);\n\t\t}\n\t\tif (current_filter) {\n\t\t\tcurrent_filter->process_th_id = 0;\n\t\t\tcurrent_filter->in_process = GF_FALSE;\n\t\t}\n\t\t//not requeuing and first time we have an empty task queue, flush to detect if we are indeed done\n\t\tif (!current_filter && !fsess->tasks_pending && !sess_thread->has_seen_eot && !gf_fq_count(fsess->tasks)) {\n\t\t\t//if not the main thread, or if main thread and task list is empty, enter end of session probing mode\n\t\t\tif (thid || !gf_fq_count(fsess->main_thread_tasks) ) {\n\t\t\t\t//maybe last task, force a notify to check if we are truly done. We only tag \"session done\" for the non-main\n\t\t\t\t//threads, in order to enter the end-of session signaling above\n\t\t\t\tif (thid) sess_thread->has_seen_eot = GF_TRUE;\n\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, use_main_sema);\n\t\t\t}\n\t\t}\n\n\t\tsess_thread->active_time += gf_sys_clock_high_res() - active_start;\n\n\n\t\t//no main thread, return\n\t\tif (!thid && fsess->non_blocking && !current_filter && !fsess->pid_connect_tasks_pending) {\n\t\t\tgf_rmt_end();\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Main thread proc exit\\n\"));\n\t\t\tsafe_int_dec(&fsess->active_threads);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tgf_rmt_end();\n\n\tsafe_int_dec(&fsess->active_threads);\n\t//no main thread, return\n\tif (!thid && fsess->non_blocking) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Main thread proc exit\\n\"));\n\t\treturn 0;\n\t}\n\n#if defined(GPAC_CONFIG_EMSCRIPTEN) && !defined(GPAC_DISABLE_THREADS)\n\tif (thid) {\n\t\tsess_thread->run_time += gf_sys_clock_high_res() - enter_time;\n\t} else\n#endif\n\t\tsess_thread->run_time = gf_sys_clock_high_res() - enter_time;\n\n\tsafe_int_inc(&fsess->nb_threads_stopped);\n\n\tif (!fsess->run_status)\n\t\tfsess->run_status = GF_EOS;\n\n\t// thread exit, notify the semaphores\n\tif (fsess->semaphore_main && ! gf_sema_notify(fsess->semaphore_main, 1)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCHEDULER, (\"Failed to notify main semaphore, might hang up !!\\n\"));\n\t}\n\tif (fsess->semaphore_other && ! gf_sema_notify(fsess->semaphore_other, th_count)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCHEDULER, (\"Failed to notify secondary semaphore, might hang up !!\\n\"));\n\t}\n\n\treturn 0;\n}\n\n\nGF_EXPORT\nGF_Err gf_fs_run(GF_FilterSession *fsess)\n{\n\tassert(fsess);\n\n\t//non blocking mode and threads created, only run main thread proc\n\tif (fsess->non_blocking && (fsess->non_blocking==2) ) {\n#ifdef GPAC_CONFIG_EMSCRIPTEN\n\t\tif (fsess->pending_threads) return GF_NOT_READY;\n#endif\n\t\tgf_fs_thread_proc(&fsess->main_th);\n#ifdef GPAC_CONFIG_EMSCRIPTEN\n\t\tif (fsess->in_main_sem_wait) {\n\t\t\tfsess->in_main_sem_wait = GF_FALSE;\n\t\t\treturn GF_NOT_READY;\n\t\t}\n#endif\n\t\treturn fsess->run_status;\n\t}\n\n\t//run threads\n\tfsess->run_status = GF_OK;\n\tfsess->main_th.has_seen_eot = GF_FALSE;\n\tfsess->nb_threads_stopped = 0;\n\n#ifndef GPAC_DISABLE_THREADS\n\tu32 i, nb_threads;\n\tnb_threads = gf_list_count(fsess->threads);\n\tfor (i=0;i<nb_threads; i++) {\n\t\tGF_SessionThread *sess_th = gf_list_get(fsess->threads, i);\n\t\tif ( gf_th_run(sess_th->th, (gf_thread_run) gf_fs_thread_proc, sess_th) ==GF_OK) {\n#ifdef GPAC_CONFIG_EMSCRIPTEN\n\t\t\tif (fsess->non_blocking) {\n\t\t\t\tsafe_int_inc(&fsess->pending_threads);\n\t\t\t}\n#endif\n\t\t}\n\t}\n#endif\n\n\n\t//run main thread - for emscripten, we only call if no pending threads\n#ifdef GPAC_CONFIG_EMSCRIPTEN\n\tif (!fsess->pending_threads)\n#endif\n\t{\n\t\tgf_fs_thread_proc(&fsess->main_th);\n\t}\n\n\t//non blocking mode init, don't wait for other threads\n\tif (fsess->non_blocking) {\n\t\tfsess->non_blocking = 2;\n\t\treturn fsess->run_status;\n\t}\n\n#ifndef GPAC_DISABLE_THREADS\n\t//blocking mode, wait for all threads to be done\n\twhile (nb_threads+1 != fsess->nb_threads_stopped) {\n\t\tgf_sleep(1);\n\t}\n#endif\n\n\treturn fsess->run_status;\n}\n\nstatic void filter_abort_task(GF_FSTask *task)\n{\n\tGF_FilterEvent evt;\n\tGF_FEVT_INIT(evt, GF_FEVT_STOP, task->pid);\n\n\ttask->pid->filter->freg->process_event(task->pid->filter, &evt);\n\tgf_filter_pid_set_eos(task->pid);\n\ttask->pid->filter->disabled = GF_FILTER_DISABLED;\n\tsafe_int_dec(&task->pid->filter->abort_pending);\n\n}\n\nGF_EXPORT\nGF_Err gf_fs_abort(GF_FilterSession *fsess, GF_FSFlushType flush_type)\n{\n\tu32 i, count;\n\tBool threaded;\n\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Session abort from user, stopping sources\\n\"));\n\tif (!fsess) return GF_BAD_PARAM;\n\tthreaded = (!fsess->filters_mx && (fsess->main_th.th_id==gf_th_id())) ? GF_FALSE : GF_TRUE;\n\n\tif (flush_type==GF_FS_FLUSH_NONE) {\n\t\tfsess->in_final_flush = GF_TRUE;\n\t\tfsess->run_status = GF_EOS;\n\t\treturn GF_OK;\n\t}\n\n\tfsess->in_final_flush = GF_TRUE;\n\n\tgf_mx_p(fsess->filters_mx);\n\tcount = gf_list_count(fsess->filters);\n\t//disable all sources\n\tfor (i=0; i<count; i++) {\n\t\tGF_Filter *filter = gf_list_get(fsess->filters, i);\n\t\tif (!filter) continue;\n\t\t//force end of session on all sources, and on all filters connected to these sources, and dispatch end of stream on all outputs pids of these filters\n\t\t//if we don't propagate on connected filters, we take the risk of not deactivating demuxers working from file\n\t\t//(eg ignoring input packets)\n\t\t//\n\t\t//we shortcut the thread execution state here by directly calling set_eos, we need to lock/unlock our filters carefully\n\t\t//to avoid deadlocks or crashes\n\t\tgf_mx_v(fsess->filters_mx);\n\t\tgf_mx_p(filter->tasks_mx);\n\n\t\tif (!filter->num_input_pids) {\n\t\t\tu32 j, k, l;\n\t\t\tif (!filter->disabled)\n\t\t\t\tfilter->disabled = GF_FILTER_DISABLED;\n\t\t\tfor (j=0; j<filter->num_output_pids; j++) {\n\t\t\t\tconst GF_PropertyValue *p;\n\t\t\t\tGF_FilterPid *pid = gf_list_get(filter->output_pids, j);\n\t\t\t\t//unlock before forcing eos as this could trigger a post task on a filter waiting for this mutex to be unlocked\n\t\t\t\tgf_mx_v(filter->tasks_mx);\n\t\t\t\tgf_filter_pid_set_eos(pid);\n\t\t\t\tgf_mx_p(filter->tasks_mx);\n\t\t\t\t//if the PID has a codecid set (demuxed pid, e.g. ffavin or other grabbers), do not force STOP on its destinations\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CODECID);\n\t\t\t\tif (p) continue;\n\t\t\t\t\n\t\t\t\tfor (k=0; k<pid->num_destinations; k++) {\n\t\t\t\t\tBool force_disable = GF_TRUE;\n\t\t\t\t\tGF_FilterPidInst *pidi = gf_list_get(pid->destinations, k);\n\t\t\t\t\tgf_mx_v(filter->tasks_mx);\n\t\t\t\t\tgf_mx_p(pidi->filter->tasks_mx);\n\t\t\t\t\tfor (l=0; l<pidi->filter->num_output_pids; l++) {\n\t\t\t\t\t\tGF_FilterPid *opid = gf_list_get(pidi->filter->output_pids, l);\n\t\t\t\t\t\t//We cannot directly call process_event as this would make concurrent access to the filter\n\t\t\t\t\t\t//which we guarantee we will never do\n\t\t\t\t\t\t//but we don't want to send a regular stop event which will reset PID buffers, so:\n\t\t\t\t\t\t//- if called in main thread of session in single-thread mode we can safely force a STOP event\n\t\t\t\t\t\t//otherwise:\n\t\t\t\t\t\t//- post a task to the filter\n\t\t\t\t\t\t//- only disable the filter once the filter_abort has been called\n\t\t\t\t\t\t//- only move to EOS if no filter_abort is pending\n\t\t\t\t\t\t//\n\t\t\t\t\t\tif (opid->filter->freg->process_event) {\n\t\t\t\t\t\t\tif (threaded) {\n\t\t\t\t\t\t\t\tsafe_int_inc(&opid->filter->abort_pending);\n\t\t\t\t\t\t\t\tgf_fs_post_task(opid->filter->session, filter_abort_task, opid->filter, opid, \"filter_abort\", NULL);\n\t\t\t\t\t\t\t\tforce_disable = GF_FALSE;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tGF_FilterEvent evt;\n\t\t\t\t\t\t\t\tGF_FEVT_INIT(evt, GF_FEVT_STOP, opid);\n\n\t\t\t\t\t\t\t\topid->filter->freg->process_event(opid->filter, &evt);\n\t\t\t\t\t\t\t\tgf_filter_pid_set_eos(opid);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_filter_pid_set_eos(opid);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tgf_mx_v(pidi->filter->tasks_mx);\n\t\t\t\t\tgf_mx_p(filter->tasks_mx);\n\t\t\t\t\t//no filter_abort pending, disable the filter\n\t\t\t\t\tif (force_disable)\n\t\t\t\t\t\tpidi->filter->disabled = GF_FILTER_DISABLED;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//fast flush and this is a sink: send a stop from all filters connected to the sink\n\t\tif ((flush_type==GF_FS_FLUSH_FAST) && !filter->num_output_pids) {\n\t\t\tu32 j;\n\t\t\tfor (j=0; j<filter->num_input_pids; j++) {\n\t\t\t\tGF_FilterEvent evt;\n\t\t\t\tGF_FilterPidInst *pidi = gf_list_get(filter->input_pids, j);\n\t\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property((GF_FilterPid *) pidi, GF_PROP_PID_STREAM_TYPE);\n\t\t\t\t//if pid is of type FILE, we keep the last connections to the sink active so that muxers can still dispatch pending packets\n\t\t\t\tif (p && (p->value.uint==GF_STREAM_FILE)) {\n\t\t\t\t\tu32 k;\n\t\t\t\t\tgf_mx_p(pidi->pid->filter->tasks_mx);\n\t\t\t\t\tfor (k=0; k<pidi->pid->filter->num_input_pids; k++) {\n\t\t\t\t\t\tGF_FilterPid *pid = gf_list_get(pidi->pid->filter->input_pids, k);\n\t\t\t\t\t\tGF_FEVT_INIT(evt, GF_FEVT_STOP, pid);\n\t\t\t\t\t\tgf_filter_pid_send_event(pid, &evt);\n\t\t\t\t\t\t//and force pid to be in eos, since we do a fast flush EOS may not be dispatched by input filter(s)\n\t\t\t\t\t\tgf_filter_pid_set_eos(pid->pid);\n\t\t\t\t\t}\n\t\t\t\t\tgf_mx_v(pidi->pid->filter->tasks_mx);\n\t\t\t\t}\n\t\t\t\t//otherwise send STOP right away\n\t\t\t\telse {\n\t\t\t\t\tGF_FEVT_INIT(evt, GF_FEVT_STOP, (GF_FilterPid *) pidi);\n\t\t\t\t\tgf_filter_pid_send_event((GF_FilterPid *) pidi, &evt);\n\t\t\t\t\t//and force pid to be in eos, since we do a fast flush EOS may not be dispatched by input filter(s)\n\t\t\t\t\tgf_filter_pid_set_eos(pidi->pid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgf_mx_v(filter->tasks_mx);\n\t\tgf_mx_p(fsess->filters_mx);\n\t}\n\tgf_mx_v(fsess->filters_mx);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_fs_stop(GF_FilterSession *fsess)\n{\n\tu32 i;\n#ifndef GPAC_DISABLE_THREADS\n\tu32 count = fsess->threads ? gf_list_count(fsess->threads) : 0;\n#else\n\tu32 count=0;\n#endif\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Session stop\\n\"));\n\tif (count+1 == fsess->nb_threads_stopped) {\n\t\treturn GF_OK;\n\t}\n\n\tif (!fsess->run_status) {\n\t\tfsess->in_final_flush = GF_TRUE;\n\t\tfsess->run_status = GF_EOS;\n\t}\n\n\t//update runtime for main thread in non-blocking mode\n\tif (fsess->non_blocking) {\n\t\tfsess->main_th.run_time = gf_sys_clock_high_res() - fsess->main_th.run_time;\n\t}\n\n\n\tfor (i=0; i < count; i++) {\n\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_FALSE);\n\t}\n\n\t//wait for all threads to be done, we might still need flushing the main thread queue\n\twhile (fsess->non_blocking) {\n\t\tgf_fs_thread_proc(&fsess->main_th);\n\t\tif (gf_fq_count(fsess->main_thread_tasks))\n\t\t\tcontinue;\n\n\t\tif (count && (count == fsess->nb_threads_stopped) && gf_fq_count(fsess->tasks) ) {\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tif (fsess->non_blocking) {\n\t\tsafe_int_inc(&fsess->nb_threads_stopped);\n\t\tfsess->main_th.has_seen_eot = GF_TRUE;\n\t}\n\n\twhile (count+1 != fsess->nb_threads_stopped) {\n\t\tfor (i=0; i < count; i++) {\n\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_FALSE);\n\t\t}\n\t\tgf_sleep(0);\n\t\t//we may have tasks in main task list posted by other threads\n\t\tif (fsess->non_blocking) {\n\t\t\tgf_fs_thread_proc(&fsess->main_th);\n\t\t\tfsess->main_th.has_seen_eot = GF_TRUE;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nstatic GFINLINE void print_filter_name(GF_Filter *f, Bool skip_id, Bool skip_args)\n{\n\tif (f->freg->flags & GF_FS_REG_SCRIPT) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" \\\"%s\\\"\", f->name));\n\t} else {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"%s\", f->freg->name));\n\t\tif (strcmp(f->name, f->freg->name)) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" \\\"%s\\\"\", f->name));\n\t\t}\n\t}\n\tif (!skip_id && f->id) GF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" ID %s\", f->id));\n\tif (f->dynamic_filter || skip_args) return;\n\n\tif (!f->src_args && !f->orig_args && !f->dst_args && !f->dynamic_source_ids) return;\n\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" (\"));\n\tif (f->src_args) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"%s\", f->src_args));\n\t}\n\telse if (f->orig_args) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"%s\", f->orig_args));\n\t}\n\telse if (f->dst_args) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"%s\", f->dst_args));\n\t}\n\n\tif (f->dynamic_source_ids) GF_LOG(GF_LOG_INFO, GF_LOG_APP, (\",resolved SID:%s\", f->source_ids));\n\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\")\"));\n}\n\nGF_EXPORT\nvoid gf_fs_print_stats(GF_FilterSession *fsess)\n{\n#ifndef GPAC_DISABLE_THREADS\n\tu64 run_time=0, active_time=0, nb_tasks=0;\n#endif\n\tu32 i, count;\n#ifndef GPAC_DISABLE_LOG\n\tu32 nb_filters=0;\n#endif\n\n\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\n\"));\n\tgf_mx_p(fsess->filters_mx);\n\n\tcount=gf_list_count(fsess->filters);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Filter *f = gf_list_get(fsess->filters, i);\n\t\tif (f->multi_sink_target) continue;\n#ifndef GPAC_DISABLE_LOG\n\t\tnb_filters++;\n#endif\n\t}\n\n\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"Filter stats - %d filters\\n\", nb_filters));\n\tfor (i=0; i<count; i++) {\n\t\tu32 k, ipids, opids;\n\t\tGF_Filter *f = gf_list_get(fsess->filters, i);\n\t\tif (!f || f->multi_sink_target) continue;\n\n\t\tgf_mx_v(fsess->filters_mx);\n\t\tgf_mx_p(f->tasks_mx);\n\n\t\tipids = f->num_input_pids;\n\t\topids = f->num_output_pids;\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\tFilter \"));\n\t\tprint_filter_name(f, GF_FALSE, GF_FALSE);\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" : %d input pids %d output pids \"LLU\" tasks \"LLU\" us process time\\n\", ipids, opids, f->nb_tasks_done, f->time_process));\n\n\t\tif (ipids) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\t\\t\"LLU\" packets processed \"LLU\" bytes processed\", f->nb_pck_processed, f->nb_bytes_processed));\n\t\t\tif (f->time_process) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" (%g pck/sec %g mbps)\", (Double) f->nb_pck_processed*1000000/f->time_process, (Double) f->nb_bytes_processed*8/f->time_process));\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\n\"));\n\t\t}\n\t\tif (opids) {\n\t\t\tif (f->nb_hw_pck_sent) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\t\\t\"LLU\" hardware frames sent\", f->nb_hw_pck_sent));\n\t\t\t\tif (f->time_process) {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" (%g pck/sec)\", (Double) f->nb_hw_pck_sent*1000000/f->time_process));\n\t\t\t\t}\n\n\t\t\t} else if (f->nb_pck_sent) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\t\\t\"LLU\" packets sent \"LLU\" bytes sent\", f->nb_pck_sent, f->nb_bytes_sent));\n\t\t\t\tif (f->time_process) {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" (%g pck/sec %g mbps)\", (Double) f->nb_pck_sent*1000000/f->time_process, (Double) f->nb_bytes_sent*8/f->time_process));\n\t\t\t\t}\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\n\"));\n\t\t}\n\n\t\tfor (k=0; k<ipids; k++) {\n\t\t\tGF_FilterPidInst *pid = gf_list_get(f->input_pids, k);\n\t\t\tif (!pid->pid) continue;\n\t\t\tif (pid->requires_full_data_block && (pid->nb_reagg_pck != pid->pid->nb_pck_sent) ) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\t\\t* input PID %s: %d frames (%d packets) received\\n\", pid->pid->name, pid->nb_reagg_pck, pid->pid->nb_pck_sent));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\t\\t* input PID %s: %d packets received\\n\", pid->pid->name, pid->pid->nb_pck_sent));\n\t\t\t}\n\t\t}\n#ifndef GPAC_DISABLE_LOG\n\t\tfor (k=0; k<opids; k++) {\n\t\t\tGF_FilterPid *pid = gf_list_get(f->output_pids, k);\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\t\\t* output PID %s: %d packets sent\\n\", pid->name, pid->nb_pck_sent));\n\t\t}\n\t\tif (f->nb_errors) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\t\\t%d errors while processing\\n\", f->nb_errors));\n\t\t}\n#endif\n\n\t\tgf_mx_v(f->tasks_mx);\n\t\tgf_mx_p(fsess->filters_mx);\n\t}\n\tgf_mx_v(fsess->filters_mx);\n\n#ifndef GPAC_DISABLE_THREADS\n\tcount=gf_list_count(fsess->threads);\n\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"Session stats - threads %d\\n\\tThread 1: \", 1+count));\n#else\n\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"Session stats: \"));\n#endif\n\n\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"run_time \"LLU\" us active_time \"LLU\" us nb_tasks \"LLU\"\\n\", fsess->main_th.run_time, fsess->main_th.active_time, fsess->main_th.nb_tasks));\n\n#ifndef GPAC_DISABLE_THREADS\n\trun_time+=fsess->main_th.run_time;\n\tactive_time+=fsess->main_th.active_time;\n\tnb_tasks+=fsess->main_th.nb_tasks;\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_SessionThread *s = gf_list_get(fsess->threads, i);\n\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\tThread %u: run_time \"LLU\" us active_time \"LLU\" us nb_tasks \"LLU\"\\n\", i+2, s->run_time, s->active_time, s->nb_tasks));\n\n\t\trun_time+=s->run_time;\n\t\tactive_time+=s->active_time;\n\t\tnb_tasks+=s->nb_tasks;\n\t}\n\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\nTotal: run_time \"LLU\" us active_time \"LLU\" us nb_tasks \"LLU\"\\n\", run_time, active_time, nb_tasks));\n#endif\n}\n\nstatic void gf_fs_print_filter_outputs(GF_Filter *f, GF_List *filters_done, u32 indent, GF_FilterPid *pid, GF_Filter *alias_for, u32 src_num_tiled_pids, Bool skip_print, s32 nb_recursion, u32 max_length)\n{\n\tu32 i=0;\n\n\tif (!skip_print) {\n\t\twhile (i<indent) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"-\"));\n\t\t\ti++;\n\t\t}\n\n\t\tif (src_num_tiled_pids>1) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"(tilePID[%d]) \", src_num_tiled_pids));\n\t\t}\n\t\telse if (pid) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"(PID %s)\", pid->name));\n\t\t}\n\t\tif (max_length) {\n\t\t\tu32 l;\n\t\t\tif (src_num_tiled_pids) {\n\t\t\t\tchar szName[50];\n\t\t\t\tsprintf(szName, \"PID[%d]\", src_num_tiled_pids);\n\t\t\t\tl = (u32) strlen(szName);\n\t\t\t} else {\n\t\t\t\tl = (u32) strlen(pid->name);\n\t\t\t}\n\t\t\twhile (l<max_length) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" \"));\n\t\t\t\t\tl++;\n\t\t\t}\n\t\t}\n\t\tif (nb_recursion>0) {\n\t\t\tu32 k=0;\n\t\t\twhile (k<(u32) nb_recursion-1) {\n\t\t\t\tk++;\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" \"));\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\\\\\n\"));\n\t\t\treturn;\n\t\t}\n\t\tif (pid) {\n\t\t\tif (nb_recursion<0) {\n\t\t\t\tu32 k=(u32) -nb_recursion;\n\t\t\t\twhile (k>1) {\n\t\t\t\t\tk--;\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"-\"));\n\t\t\t\t}\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\">\"));\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" \"));\n\t\t}\n\n\t\tprint_filter_name(f, GF_TRUE, GF_FALSE);\n\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" (%s=%u)\\n\", f->dynamic_filter ? \"dyn_idx\" : \"idx\", 1+gf_list_find(f->session->filters, f) ));\n\t}\n\n\tif (filters_done && (gf_list_find(filters_done, f)>=0))\n\t\treturn;\n\n\tif (filters_done)\n\t\tgf_list_add(filters_done, f);\n\tif (alias_for && !skip_print) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" (<=> \"));\n\t\tprint_filter_name(alias_for, GF_TRUE, GF_TRUE);\n\t\tif (alias_for->id) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" ID=%s\", alias_for->id));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" ptr=%p\", alias_for));\n\t\t}\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\")\\n\"));\n\t}\n\n\tGF_List *dests = gf_list_new();\n\tfor (i=0; i<f->num_output_pids; i++) {\n\t\tu32 j;\n\t\tGF_FilterPid *pidout = gf_list_get(f->output_pids, i);\n\t\tfor (j=0; j<pidout->num_destinations; j++) {\n\t\t\tGF_FilterPidInst *pidi = gf_list_get(pidout->destinations, j);\n\t\t\tif (gf_list_find(dests, pidi->filter)<0)\n\t\t\t\tgf_list_add(dests, pidi->filter);\n\t\t}\n\t}\n\n\twhile (gf_list_count(dests)) {\n\tGF_Filter *dest = gf_list_pop_front(dests);\n\tGF_List *pids = gf_list_new();\n\tu32 max_name_len=0;\n\tu32 num_tile_pids=0;\n\tfor (i=0; i<f->num_output_pids; i++) {\n\t\tu32 j;\n\t\tGF_FilterPid *pidout = gf_list_get(f->output_pids, i);\n\t\tfor (j=0; j<pidout->num_destinations; j++) {\n\t\t\tGF_FilterPidInst *pidi = gf_list_get(pidout->destinations, j);\n\t\t\tif (pidi->filter != dest) continue;\n\t\t\tgf_list_add(pids, pidi);\n\t\t}\n\t\tu32 plen = (u32) strlen(pidout->name);\n\n\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(pidout, GF_PROP_PID_CODECID);\n\t\tif (p &&\n\t\t\t((p->value.uint==GF_CODECID_HEVC_TILES) || (p->value.uint==GF_CODECID_VVC_SUBPIC))\n\t\t) {\n\t\t\tplen = 0;\n\t\t\tif (!num_tile_pids) {\n\t\t\t\tfor (j=0; j<f->num_output_pids; j++) {\n\t\t\t\t\tGF_FilterPid *apid = gf_list_get(f->output_pids, j);\n\t\t\t\t\tp = gf_filter_pid_get_property(apid, GF_PROP_PID_CODECID);\n\t\t\t\t\tif (p &&\n\t\t\t\t\t\t((p->value.uint==GF_CODECID_HEVC_TILES) || (p->value.uint==GF_CODECID_VVC_SUBPIC))\n\t\t\t\t\t) {\n\t\t\t\t\t\tnum_tile_pids++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tplen = 5;\n\t\t\t\tj=0;\n\t\t\t\twhile (j<num_tile_pids) {\n\t\t\t\t\tplen+=1;\n\t\t\t\t\tj+=10;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (plen>max_name_len) max_name_len = plen;\n\t}\n\ts32 nb_pids_print = gf_list_count(pids);\n\tif (nb_pids_print==1) nb_pids_print = 0;\n\tif (num_tile_pids) nb_pids_print -= num_tile_pids-1;\n\ts32 nb_final_pids = nb_pids_print;\n\tif (nb_pids_print) nb_pids_print++;\n\tBool first_tile = GF_TRUE;\n\n\tfor (i=0; i<f->num_output_pids; i++) {\n\t\tu32 j, k;\n\t\tBool is_tiled = GF_FALSE;\n\t\tBool skip_tiled = skip_print;\n\n\t\tGF_FilterPid *pidout = gf_list_get(f->output_pids, i);\n\t\tif (num_tile_pids) {\n\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(pidout, GF_PROP_PID_CODECID);\n\t\t\tif (p &&\n\t\t\t\t((p->value.uint==GF_CODECID_HEVC_TILES) || (p->value.uint==GF_CODECID_VVC_SUBPIC))\n\t\t\t) {\n\t\t\t\tis_tiled = GF_TRUE;\n\t\t\t}\n\t\t}\n\n\t\tfor (j=0; j<pidout->num_destinations; j++) {\n\t\t\tGF_Filter *alias = NULL;\n\t\t\tGF_FilterPidInst *pidi = gf_list_get(pidout->destinations, j);\n\t\t\tif (pidi->filter != dest) continue;\n\n\t\t\tgf_list_del_item(pids, pidi);\n\t\t\tif (nb_pids_print && !gf_list_count(pids))\n\t\t\t\tnb_pids_print = 0;\n\t\t\telse if (is_tiled) {\n\t\t\t\tif (!first_tile) continue;\n\t\t\t\tnb_pids_print = 0;\n\t\t\t\tfirst_tile = GF_FALSE;\n\t\t\t}\n\n\t\t\tfor (k=0; k<gf_list_count(f->destination_filters); k++) {\n\t\t\t\talias = gf_list_get(f->destination_filters, k);\n\t\t\t\tif (alias->multi_sink_target == pidi->filter)\n\t\t\t\t\tbreak;\n\t\t\t\talias = NULL;\n\t\t\t}\n\t\t\tif (alias) {\n\t\t\t\tgf_fs_print_filter_outputs(alias, filters_done, indent+1, pidout, pidi->filter, is_tiled ? num_tile_pids : src_num_tiled_pids, skip_tiled, nb_pids_print-nb_final_pids, max_name_len);\n\t\t\t} else {\n\t\t\t\tgf_fs_print_filter_outputs(pidi->filter, filters_done, indent+1, pidout, NULL, is_tiled ? num_tile_pids : src_num_tiled_pids, skip_tiled, nb_pids_print-nb_final_pids, max_name_len);\n\t\t\t}\n\t\t}\n\t\tif (nb_pids_print) nb_pids_print++;\n\t}\n\tgf_list_del(pids);\n\t}\n\tgf_list_del(dests);\n}\n\nstatic void gf_fs_print_not_connected_filters(GF_FilterSession *fsess, GF_List *filters_done, Bool ignore_sinks)\n{\n\tu32 i, count;\n\tBool has_unconnected=GF_FALSE;\n\tcount=gf_list_count(fsess->filters);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Filter *f = gf_list_get(fsess->filters, i);\n\t\t//only dump not connected ones\n\t\tif (f->num_input_pids || f->num_output_pids || f->multi_sink_target || f->nb_tasks_done) continue;\n\t\tif (f->disabled==GF_FILTER_DISABLED_HIDE) continue;\n\n\t\tif (ignore_sinks) {\n\t\t\tBool has_outputs;\n\t\t\tif (f->forced_caps)\n\t\t\t\thas_outputs = gf_filter_has_out_caps(f->forced_caps, f->nb_forced_caps);\n\t\t\telse\n\t\t\t\thas_outputs = gf_filter_has_out_caps(f->freg->caps, f->freg->nb_caps);\n\t\t\tif (!has_outputs) continue;\n\t\t}\n\n\t\tif (!has_unconnected) {\n\t\t\thas_unconnected = GF_TRUE;\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_APP, (\"Filters not connected:\\n\"));\n\t\t}\n\t\tgf_fs_print_filter_outputs(f, filters_done, 0, NULL, NULL, 0, GF_FALSE, 0, 0);\n\t}\n}\n\nGF_EXPORT\nvoid gf_fs_print_non_connected(GF_FilterSession *fsess)\n{\n\tgf_fs_print_not_connected_filters(fsess, NULL, GF_FALSE);\n}\n\nGF_EXPORT\nvoid gf_fs_print_non_connected_ex(GF_FilterSession *fsess, Bool ignore_sinks)\n{\n\tgf_fs_print_not_connected_filters(fsess, NULL, ignore_sinks);\n}\n\nGF_EXPORT\nvoid gf_fs_print_connections(GF_FilterSession *fsess)\n{\n\tu32 i, count;\n\tBool has_undefined=GF_FALSE;\n\tBool has_connected=GF_FALSE;\n\tGF_List *filters_done;\n\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\n\"));\n\tgf_mx_p(fsess->filters_mx);\n\n\tfilters_done = gf_list_new();\n\n\tcount=gf_list_count(fsess->filters);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Filter *f = gf_list_get(fsess->filters, i);\n\t\t//only dump sources\n\t\tif (f->num_input_pids) continue;\n\t\tif (!f->num_output_pids) continue;\n\t\tif (!has_connected) {\n\t\t\thas_connected = GF_TRUE;\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"Filters connected:\\n\"));\n\t\t}\n\t\tgf_fs_print_filter_outputs(f, filters_done, 0, NULL, NULL, 0, GF_FALSE, 0, 0);\n\t}\n\n\tgf_fs_print_not_connected_filters(fsess, filters_done, GF_FALSE);\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_Filter *f = gf_list_get(fsess->filters, i);\n\t\tif (f->multi_sink_target) continue;\n\t\tif (gf_list_find(filters_done, f)>=0) continue;\n\t\tif (f->disabled==GF_FILTER_DISABLED_HIDE) continue;\n\t\tif (!has_undefined) {\n\t\t\thas_undefined = GF_TRUE;\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"Filters in unknown connection state:\\n\"));\n\t\t}\n\t\tgf_fs_print_filter_outputs(f, filters_done, 0, NULL, NULL, 0, GF_FALSE, 0, 0);\n\t}\n\n\tgf_mx_v(fsess->filters_mx);\n\tgf_list_del(filters_done);\n}\n\nGF_EXPORT\nvoid gf_fs_print_unused_args(GF_FilterSession *fsess, const char *ignore_args)\n{\n\tu32 idx = 0;\n\tconst char *argname;\n\tu32 argtype;\n\n\twhile (1) {\n\t\tBool found = GF_FALSE;\n\t\tconst char *loc_arg;\n\t\tif (gf_fs_enum_unmapped_options(fsess, &idx, &argname, &argtype, NULL, NULL)==GF_FALSE)\n\t\t\tbreak;\n\n\t\tloc_arg = ignore_args;\n\t\twhile (loc_arg) {\n\t\t\tu32 len;\n\t\t\tchar *sep;\n\t\t\tchar *match = strstr(loc_arg, argname);\n\t\t\tif (!match) break;\n\t\t\tlen = (u32) strlen(argname);\n\t\t\tif (!match[len] || (match[len]==',')) {\n\t\t\t\tfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsep = strchr(loc_arg, ',');\n\t\t\tif (!sep) break;\n\t\t\tloc_arg = sep+1;\n\t\t}\n\t\tif (found) continue;\n\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_APP, (\"Arg %s set but not used\\n\", argname));\n\t}\n}\n\nGF_EXPORT\nvoid gf_fs_send_update(GF_FilterSession *fsess, const char *fid, GF_Filter *filter, const char *name, const char *val, GF_EventPropagateType propagate_mask)\n{\n\tGF_FilterUpdate *upd;\n\tu32 i, count;\n\tchar *sep = NULL;\n\tBool removed = GF_FALSE;\n\tif ((!fid && !filter) || !name) return;\n\tif (!fsess) {\n\t\tif (!filter) return;\n\t\tfsess = filter->session;\n\t}\n\n\tgf_mx_p(fsess->filters_mx);\n\n\tif (!filter) {\n\t\tGF_Filter *reg_filter = NULL;\n\t\tcount = gf_list_count(fsess->filters);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tfilter = gf_list_get(fsess->filters, i);\n\t\t\tif (filter->id && !strcmp(filter->id, fid)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (filter->name && !strcmp(filter->name, fid)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!reg_filter && !strcmp(filter->freg->name, fid))\n\t\t\t\treg_filter = filter;\n\t\t\tfilter = NULL;\n\t\t}\n\t\tif (!filter)\n\t\t\tfilter = reg_filter;\n\t}\n\n\tif (filter && filter->multi_sink_target)\n\t\tfilter = filter->multi_sink_target;\n\n\tremoved = (!filter || filter->removed || filter->finalized) ? GF_TRUE : GF_FALSE;\n\tgf_mx_v(fsess->filters_mx);\n\n\tif (removed) return;\n\n\tif (!val) {\n\t\tsep = strchr(name, fsess->sep_name);\n\t\tif (sep) sep[0] = 0;\n\t}\n\n\t//find arg and check if it is only a sync update - if so do it now\n\ti=0;\n\twhile (filter->freg->args) {\n\t\tconst GF_FilterArgs *a = &filter->freg->args[i];\n\t\ti++;\n\t\tif (!a || !a->arg_name) break;\n\n\t\tif ((a->flags & GF_FS_ARG_META) && !strcmp(a->arg_name, \"*\")) {\n\t\t\tcontinue;\n\t\t} else if (strcmp(a->arg_name, name)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (a->flags & GF_FS_ARG_UPDATE_SYNC) {\n\t\t\tgf_mx_p(filter->tasks_mx);\n\t\t\tgf_filter_update_arg_apply(filter, name, sep ? sep+1 : val, GF_TRUE);\n\t\t\tgf_mx_v(filter->tasks_mx);\n\t\t\tif (sep) sep[0] = fsess->sep_name;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\n\tGF_SAFEALLOC(upd, GF_FilterUpdate);\n\tif (!val) {\n\t\tupd->name = gf_strdup(name);\n\t\tupd->val = sep ? gf_strdup(sep+1) : NULL;\n\t\tif (sep) sep[0] = fsess->sep_name;\n\t} else {\n\t\tupd->name = gf_strdup(name);\n\t\tupd->val = gf_strdup(val);\n\t}\n\tupd->recursive = propagate_mask;\n\tgf_fs_post_task(fsess, gf_filter_update_arg_task, filter, NULL, \"update_arg\", upd);\n}\n\nstatic GF_FilterProbeScore probe_meta_check_builtin_format(GF_FilterSession *fsess, GF_FilterRegister *freg, const char *url, const char *mime, char *fargs)\n{\n\tchar szExt[100];\n\tconst char *ext = gf_file_ext_start(url);\n\tu32 len=0, i, j, count = gf_list_count(fsess->registry);\n\tif (ext) {\n\t\text++;\n\t\tlen = (u32) strlen(ext);\n\t}\n\t//check in filter args if we have a format set, in which case replace URL ext by the given format\n\tif (fargs) {\n\t\tchar szExtN[10];\n\t\tchar *ext_arg;\n\t\tsprintf(szExtN, \"ext%c\", fsess->sep_name);\n\t\text_arg = strstr(fargs, szExtN);\n\t\tif (ext_arg && (ext_arg>fargs) && (ext_arg[-1] != fsess->sep_name))\n\t\t\text_arg = NULL;\n\n\t\tif (ext_arg) {\n\t\t\tchar *next_arg;\n\t\t\text_arg+=4;\n\t\t\tnext_arg = strchr(ext_arg, fsess->sep_args);\n\t\t\tif (next_arg) {\n\t\t\t\tlen = (u32) (next_arg - ext_arg);\n\t\t\t} else {\n\t\t\t\tlen = (u32) strlen(ext_arg);\n\t\t\t}\n\t\t\tif (len>99) len=99;\n\t\t\tstrncpy(szExt, ext_arg, len);\n\t\t\tszExt[len] = 0;\n\t\t\text = szExt;\n\t\t}\n\t}\n\n\tif (mime) {\n\t\tif (strstr(mime, \"/mp4\")) return GF_FPROBE_MAYBE_SUPPORTED;\n\t}\n\n\tfor (i=0; i<count; i++) {\n\t\tconst GF_FilterArgs *dst_arg=NULL;\n\t\tGF_FilterRegister *reg = gf_list_get(fsess->registry, i);\n\t\tif (reg==freg) continue;\n\t\tif (reg->flags & GF_FS_REG_META) continue;\n\n\t\tj=0;\n\t\twhile (reg->args) {\n\t\t\tdst_arg = &reg->args[j];\n\t\t\tif (!dst_arg || !dst_arg->arg_name) {\n\t\t\t\tdst_arg=NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!strcmp(dst_arg->arg_name, \"dst\") && !(dst_arg->flags&GF_FS_ARG_SINK_ALIAS)) break;\n\t\t\tdst_arg = NULL;\n\t\t\tj++;\n\t\t}\n\t\t/*check prober*/\n\t\tif (dst_arg) {\n\t\t\tif (reg->probe_url) {\n\t\t\t\tGF_FilterProbeScore s = reg->probe_url(url, mime);\n\t\t\t\tif (s==GF_FPROBE_SUPPORTED)\n\t\t\t\t\treturn GF_FPROBE_MAYBE_SUPPORTED;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* check muxers*/\n\t\tfor (j=0; j<reg->nb_caps; j++) {\n\t\t\tchar *value=NULL;\n\t\t\tconst char *pattern = NULL;\n\t\t\tconst GF_FilterCapability *cap = &reg->caps[j];\n\t\t\tif (! (cap->flags & GF_CAPFLAG_OUTPUT) )\n\t\t\t\tcontinue;\n\t\t\tif (cap->flags & GF_CAPFLAG_EXCLUDED)\n\t\t\t\tcontinue;\n\n\t\t\tif (cap->code==GF_PROP_PID_FILE_EXT) {\n\t\t\t\tif (ext) {\n\t\t\t\t\tvalue = cap->val.value.string;\n\t\t\t\t\tpattern = ext;\n\t\t\t\t}\n\t\t\t} else if (cap->code==GF_PROP_PID_MIME) {\n\t\t\t\tif (mime) {\n\t\t\t\t\tvalue = cap->val.value.string;\n\t\t\t\t\tpattern = mime;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (value) {\n\t\t\t\tchar *match = strstr(value, pattern);\n\t\t\t\tif (!match) break;\n\t\t\t\tif (!match[len] || match[len]=='|')\n\t\t\t\t\treturn GF_FPROBE_MAYBE_SUPPORTED;\n\t\t\t\tvalue = match+1;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_FPROBE_SUPPORTED;\n}\n\nstatic GF_Filter *locate_alias_sink(GF_Filter *filter, const char *url, const char *mime_type)\n{\n\tu32 i;\n\tfor (i=0; i<filter->num_output_pids; i++) {\n\t\tu32 j;\n\t\tGF_FilterPid *pid = gf_list_get(filter->output_pids, i);\n\t\tfor (j=0; j<pid->num_destinations; j++) {\n\t\t\tGF_Filter *f;\n\t\t\tGF_FilterPidInst *pidi = gf_list_get(pid->destinations, j);\n\t\t\tif (!pidi->filter) continue;\n\t\t\tif (pidi->filter->act_as_sink && pidi->filter->freg->use_alias\n\t\t\t\t&& pidi->filter->freg->use_alias(pidi->filter, url, mime_type)\n\t\t\t) {\n\t\t\t\treturn pidi->filter;\n\t\t\t}\n\t\t\t//recursovely walk towards the sink\n\t\t\tf = locate_alias_sink(pidi->filter, url, mime_type);\n\t\t\tif (f) return f;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nBool filter_solve_gdocs(const char *url, char szPath[GF_MAX_PATH]);\n\nGF_Filter *gf_fs_load_source_dest_internal(GF_FilterSession *fsess, const char *url, const char *user_args, const char *parent_url, GF_Err *err, GF_Filter *filter, GF_Filter *dst_filter, Bool for_source, Bool no_args_inherit, Bool *probe_only, const GF_FilterRegister **probe_reg)\n{\n\tGF_FilterProbeScore score = GF_FPROBE_NOT_SUPPORTED;\n\tGF_FilterRegister *candidate_freg=NULL;\n\tGF_Filter *alias_for_filter = NULL;\n\tconst GF_FilterArgs *src_dst_arg=NULL;\n\tu32 i, count, user_args_len, arg_type;\n\tchar szForceReg[20];\n\tchar szMime[50];\n\tchar szForceExt[20];\n\tGF_Err e;\n\tconst char *force_freg = NULL;\n\tchar *sURL, *mime_type, *args, *sep;\n\tchar szExt[50];\n\tBool free_url=GF_FALSE;\n\tmemset(szExt, 0, sizeof(szExt));\n\n\tif (!url) {\n\t\tif (err) *err = GF_BAD_PARAM;\n\t\treturn NULL;\n\t}\n\tif (err) *err = GF_OK;\n\n\tszForceExt[0] = 0;\n\tmime_type = NULL;\n\t//destination, extract mime from arguments\n\tif (!for_source) {\n\t\tsprintf(szMime, \"%cmime=\", fsess->sep_args);\n\t\tmime_type = strstr(url, szMime);\n\t\tif (!mime_type && user_args)\n\t\t\tmime_type = strstr(user_args, szMime);\n\n\t\tif (mime_type) {\n\t\t\tstrncpy(szMime, mime_type+6, 49);\n\t\t\tszMime[49]=0;\n\t\t\tsep = strchr(szMime, fsess->sep_args);\n\t\t\tif (sep) sep[0] = 0;\n\t\t\tmime_type = szMime;\n\t\t}\n\t\tsprintf(szForceExt, \"%cext=\", fsess->sep_args);\n\t\tchar *ext = strstr(url, szForceExt);\n\t\tif (ext) {\n\t\t\text+=5;\n\t\t\tsnprintf(szForceExt, 19, \"test.%s\", ext);\n\t\t\tszForceExt[19]=0;\n\t\t\text = strchr(szForceExt, fsess->sep_args);\n\t\t\tif (ext) ext[0] = 0;\n\t\t} else {\n\t\t\tszForceExt[0] = 0;\n\t\t}\n\t}\n\tsURL = NULL;\n\tif (filter) {\n\t\tsURL = (char *) url;\n\t} else {\n\t\tchar szSolvedPath[GF_MAX_PATH];\n\t\tBool is_local;\n\n\t\tif (!strncmp(url, \"$GDOCS\", 6)) {\n\t\t\tif (filter_solve_gdocs(url, szSolvedPath))\n\t\t\t\turl = szSolvedPath;\n\t\t}\n\t\t/*used by GUIs scripts to skip URL concatenation*/\n\t\tif (!strncmp(url, \"gpac://\", 7)) sURL = gf_strdup(url+7);\n\t\t/*opera-style localhost URLs*/\n\t\telse if (!strncmp(url, \"file://localhost\", 16)) sURL = gf_strdup(url+16);\n\t\telse if (parent_url) sURL = gf_url_concatenate(parent_url, url);\n\n\t\t/*path absolute*/\n\t\tif (!sURL) sURL = gf_strdup(url);\n\t\tfree_url=GF_TRUE;\n\n\t\tif (!strncmp(sURL, \"gpac://\", 7)) {\n\t\t\tu32 ulen = (u32) strlen(sURL+7);\n\t\t\tmemmove(sURL, sURL+7, ulen);\n\t\t\tsURL[ulen]=0;\n\t\t}\n\t\t//remove any filter arguments in URL before checking if it is local\n\t\t//not doing so will lead wrong result if one argument is a URL (eg \":#BUrl=http://\")\n\t\tsep = (char *) gf_fs_path_escape_colon(fsess, sURL);\n\t\tif (sep) sep[0] = 0;\n\t\tis_local = gf_url_is_local(sURL);\n\t\tif (sep) sep[0] = fsess->sep_args;\n\n\t\tif (for_source && is_local && !strstr(sURL, \"isobmff://\")) {\n\t\t\tchar *frag_par, *cgi, *ext_start;\n\t\t\tchar f_c=0;\n\t\t\tgf_url_to_fs_path(sURL);\n\t\t\tsep = (char *)gf_fs_path_escape_colon(fsess, sURL);\n\t\t\tif (sep) sep[0] = 0;\n\n\t\t\text_start = gf_file_ext_start(sURL);\n\t\t\tif (!ext_start) ext_start = sURL;\n\t\t\tfrag_par = strchr(ext_start, '#');\n\t\t\tcgi = strchr(ext_start, '?');\n\t\t\tif (frag_par && cgi && (cgi<frag_par))\n\t\t\t\tfrag_par = cgi;\n\n\t\t\tif (frag_par) {\n\t\t\t\tf_c = frag_par[0];\n\t\t\t\tfrag_par[0] = 0;\n\t\t\t}\n\n\t\t\tif (strcmp(sURL, \"null\") && strncmp(sURL, \"rand\", 4) && strcmp(sURL, \"-\") && strcmp(sURL, \"stdin\") && ! gf_file_exists(sURL)) {\n\t\t\t\tchar szPath[GF_MAX_PATH];\n\t\t\t\tBool try_js = gf_fs_solve_js_script(szPath, sURL, NULL);\n\t\t\t\tif (sep) sep[0] = fsess->sep_args;\n\t\t\t\tif (frag_par) frag_par[0] = f_c;\n\t\t\t\tgf_free(sURL);\n\n\t\t\t\tif (try_js) {\n\t\t\t\t\tif (!strncmp(url, \"gpac://\", 7)) url += 7;\n\t\t\t\t\tfilter = gf_fs_load_filter_internal(fsess, url, err, probe_only);\n\t\t\t\t\tif (probe_only) return NULL;\n\n\t\t\t\t\tif (filter) {\n\t\t\t\t\t\t//for link resolution\n\t\t\t\t\t\tif (dst_filter)\t{\n\t\t\t\t\t\t\tif (gf_list_find(filter->destination_links, dst_filter)<0)\n\t\t\t\t\t\t\t\tgf_list_add(filter->destination_links, dst_filter);\n\t\t\t\t\t\t\t//to remember our connection target\n\t\t\t\t\t\t\tfilter->target_filter = dst_filter;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn filter;\n\t\t\t\t}\n\n\t\t\t\tif (err) *err = GF_URL_ERROR;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (frag_par) frag_par[0] = f_c;\n\t\t\tif (sep) sep[0] = fsess->sep_args;\n\t\t}\n\t}\n\tBool needs_escape;\n\tsep = (char *)gf_fs_path_escape_colon_ex(fsess, sURL, &needs_escape, for_source);\n\n\tsprintf(szForceReg, \"gfreg%c\", fsess->sep_name);\n\tforce_freg = NULL;\n\tif (sep) {\n\t\tsep[0] = 0;\n\t\tforce_freg = strstr(sep+1, szForceReg);\n\t}\n\tif (!force_freg && user_args) {\n\t\tforce_freg = strstr(user_args, szForceReg);\n\t}\n\tif (force_freg)\n\t\tforce_freg += 6;\n\n\n\tif (!for_source && dst_filter) {\n\t\talias_for_filter = locate_alias_sink(dst_filter, sURL, mime_type);\n\t\tif (alias_for_filter) {\n\t\t\tcandidate_freg = (GF_FilterRegister *) alias_for_filter->freg;\n\t\t}\n\t}\n\nrestart:\n\t//check all our registered filters\n\tcount = gf_list_count(fsess->registry);\n\tif (candidate_freg) count = 0;\n\tfor (i=0; i<count; i++) {\n\t\tu32 j;\n\t\tGF_FilterProbeScore s;\n\t\tGF_FilterRegister *freg = gf_list_get(fsess->registry, i);\n\t\tif (! freg->probe_url) continue;\n\t\tif (force_freg && strncmp(force_freg, freg->name, strlen(freg->name))) continue;\n\t\tif (! freg->args) continue;\n\t\tif (filter && (gf_list_find(filter->blacklisted, freg) >=0)) continue;\n\n\t\tj=0;\n\t\twhile (freg->args) {\n\t\t\tsrc_dst_arg = &freg->args[j];\n\t\t\tif (!src_dst_arg || !src_dst_arg->arg_name) {\n\t\t\t\tsrc_dst_arg=NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (for_source && !strcmp(src_dst_arg->arg_name, \"src\")) break;\n\t\t\telse if (!for_source && !strcmp(src_dst_arg->arg_name, \"dst\") && !(src_dst_arg->flags&GF_FS_ARG_SINK_ALIAS)) break;\n\t\t\tsrc_dst_arg = NULL;\n\t\t\tj++;\n\t\t}\n\t\tif (!src_dst_arg)\n\t\t\tcontinue;\n\n\t\ts = freg->probe_url(sURL, mime_type);\n\t\tif (!for_source && (s==GF_FPROBE_MAYBE_NOT_SUPPORTED)) {\n\t\t\ts = szForceExt[0] ? freg->probe_url(szForceExt, mime_type) : GF_FPROBE_NOT_SUPPORTED;\n\t\t}\n\t\t/* destination meta filter: change GF_FPROBE_SUPPORTED to GF_FPROBE_MAYBE_SUPPORTED for internal mux formats\n\t\tin order to avoid always giving the hand to the meta filter*/\n\t\tif (!for_source && (s == GF_FPROBE_SUPPORTED) && (freg->flags & GF_FS_REG_META)) {\n\t\t\ts = probe_meta_check_builtin_format(fsess, freg, sURL, mime_type, sep ? sep+1 : NULL);\n\t\t}\n\t\t//higher score, use this new registry\n\t\tif (s > score) {\n\t\t\tcandidate_freg = freg;\n\t\t\tscore = s;\n\t\t}\n\t\t//same score and higher priority (0 being highest), use this new registry\n\t\telse if ((s == score) && candidate_freg && (freg->priority<candidate_freg->priority) ) {\n\t\t\tcandidate_freg = freg;\n\t\t\tscore = s;\n\t\t}\n\t}\n\tif (probe_only) {\n\t\t*probe_only = candidate_freg ? GF_TRUE : GF_FALSE;\n\t\tif (probe_reg) *probe_reg = candidate_freg;\n\n\t\tif (free_url)\n\t\t\tgf_free(sURL);\n\t\tif (err) *err = GF_OK;\n\t\treturn NULL;\n\t}\n\n\tif (!candidate_freg) {\n\t\tif (force_freg) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"No source filter named %s found, retrying without forcing registry\\n\", force_freg));\n\t\t\tforce_freg = NULL;\n\t\t\tgoto restart;\n\t\t}\n\t\tif (free_url)\n\t\t\tgf_free(sURL);\n\t\tif (err) *err = GF_NOT_SUPPORTED;\n\t\tif (filter) filter->finalized = GF_TRUE;\n\t\treturn NULL;\n\t}\n\tif (sep) sep[0] = fsess->sep_args;\n\n\tuser_args_len = user_args ? (u32) strlen(user_args) : 0;\n\targs = gf_malloc(sizeof(char)*5);\n\t\n\tsprintf(args, \"%s%c\", for_source ? \"src\" : \"dst\", fsess->sep_name);\n\t//path is using ':' and has options specified, inject :gpac before first option\n\tif (sep && needs_escape) {\n\t\tsep[0]=0;\n\t\tgf_dynstrcat(&args, sURL, NULL);\n\t\tgf_dynstrcat(&args, \":gpac\", NULL);\n\t\tsep[0] = fsess->sep_args;\n\t\tgf_dynstrcat(&args, sep, NULL);\n\t} else {\n\t\tgf_dynstrcat(&args, sURL, NULL);\n\t}\n\t//path is using ':' and has no specified, inject :gpac: at end\n\tif (needs_escape && !sep && !user_args_len)\n\t\tgf_dynstrcat(&args, \":gpac:\", NULL);\n\n\tif (user_args_len) {\n\t\tif (fsess->sep_args==':')\n\t\t\tgf_dynstrcat(&args, \":gpac:\", NULL);\n\t\telse {\n\t\t\tchar szSep[2];\n\t\t\tszSep[0] = fsess->sep_args;\n\t\t\tszSep[1] = 0;\n\t\t\tgf_dynstrcat(&args, szSep, NULL);\n\t\t}\n\t\tgf_dynstrcat(&args, user_args, NULL);\n\t}\n\n\te = GF_OK;\n\targ_type = GF_FILTER_ARG_EXPLICIT_SINK;\n\tif (for_source) {\n\t\tif (no_args_inherit) arg_type = GF_FILTER_ARG_EXPLICIT_SOURCE_NO_DST_INHERIT;\n\t\telse arg_type = GF_FILTER_ARG_EXPLICIT_SOURCE;\n\t}\n\n\tif (!for_source && !alias_for_filter && candidate_freg->use_alias) {\n\t\tu32 fcount = gf_list_count(fsess->filters);\n\t\tfor (i=0; i<fcount; i++) {\n\t\t\tGF_Filter *f = gf_list_get(fsess->filters, i);\n\t\t\tif (f->freg != candidate_freg) continue;\n\t\t\tif (f->freg->use_alias(f, sURL, mime_type)) {\n\t\t\t\talias_for_filter = f;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!filter) {\n\t\tfilter = gf_filter_new(fsess, candidate_freg, args, NULL, arg_type, err, alias_for_filter, GF_FALSE);\n\t} else {\n        //destroy underlying JS object - gf_filter_new_finalize always reassign it to JS_UNDEFINED\n#ifdef GPAC_HAS_QJS\n        jsfs_on_filter_destroyed(filter);\n#endif\n\t\tif (filter->session->on_filter_create_destroy)\n\t\t\tfilter->session->on_filter_create_destroy(filter->session->rt_udta, filter, GF_TRUE);\n\t\t\t\n        filter->freg = candidate_freg;\n\t\te = gf_filter_new_finalize(filter, args, arg_type);\n\t\tif (err) *err = e;\n\t}\n\n\tif (free_url)\n\t\tgf_free(sURL);\n\n\tif (filter) {\n\t\tif (filter->src_args) gf_free(filter->src_args);\n\t\tfilter->src_args = args;\n\t\t//for link resolution\n\t\tif (dst_filter && for_source)\t{\n\t\t\tif (gf_list_find(filter->destination_links, dst_filter)<0)\n\t\t\t\tgf_list_add(filter->destination_links, dst_filter);\n\t\t\t//to remember our connection target\n\t\t\tfilter->target_filter = dst_filter;\n\t\t}\n\t\tif (dst_filter)\n\t\t\tfilter->subsession_id = dst_filter->subsession_id;\n\t} else {\n\t\tgf_free(args);\n\t}\n\n\tif (!e && filter && !filter->num_output_pids && for_source)\n\t\tgf_filter_post_process_task(filter);\n\n\treturn filter;\n}\n\nGF_EXPORT\nGF_Filter *gf_fs_load_source(GF_FilterSession *fsess, const char *url, const char *args, const char *parent_url, GF_Err *err)\n{\n\treturn gf_fs_load_source_dest_internal(fsess, url, args, parent_url, err, NULL, NULL, GF_TRUE, GF_FALSE, NULL, NULL);\n}\n\nGF_EXPORT\nGF_Filter *gf_fs_load_destination(GF_FilterSession *fsess, const char *url, const char *args, const char *parent_url, GF_Err *err)\n{\n\treturn gf_fs_load_source_dest_internal(fsess, url, args, parent_url, err, NULL, NULL, GF_FALSE, GF_FALSE, NULL, NULL);\n}\n\n\nGF_EXPORT\nGF_Err gf_filter_add_event_listener(GF_Filter *filter, GF_FSEventListener *el)\n{\n\tGF_Err e;\n\tif (!filter || !filter->session || !el || !el->on_event) return GF_BAD_PARAM;\n\twhile (filter->session->in_event_listener) gf_sleep(1);\n\tgf_mx_p(filter->session->evt_mx);\n\tif (!filter->session->event_listeners) {\n\t\tfilter->session->event_listeners = gf_list_new();\n\t}\n\te = gf_list_add(filter->session->event_listeners, el);\n\tgf_mx_v(filter->session->evt_mx);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_filter_remove_event_listener(GF_Filter *filter, GF_FSEventListener *el)\n{\n\tif (!filter || !filter->session || !el || !filter->session->event_listeners) return GF_BAD_PARAM;\n\n\twhile (filter->session->in_event_listener) gf_sleep(1);\n\tgf_mx_p(filter->session->evt_mx);\n\tgf_list_del_item(filter->session->event_listeners, el);\n\tif (!gf_list_count(filter->session->event_listeners)) {\n\t\tgf_list_del(filter->session->event_listeners);\n\t\tfilter->session->event_listeners=NULL;\n\t}\n\tgf_mx_v(filter->session->evt_mx);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nBool gf_fs_forward_gf_event(GF_FilterSession *fsess, GF_Event *evt, Bool consumed, Bool skip_user)\n{\n\tif (!fsess || fsess->in_final_flush) return GF_FALSE;\n\n\tif (fsess->event_listeners) {\n\t\tGF_FSEventListener *el;\n\t\tu32 i=0;\n\n\t\tgf_mx_p(fsess->evt_mx);\n\t\tfsess->in_event_listener ++;\n\t\tgf_mx_v(fsess->evt_mx);\n\t\twhile ((el = gf_list_enum(fsess->event_listeners, &i))) {\n\t\t\tif (el->on_event(el->udta, evt, consumed)) {\n\t\t\t\tfsess->in_event_listener --;\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t}\n\t\tfsess->in_event_listener --;\n\t}\n\n\tif (!skip_user && !consumed && fsess->ui_event_proc) {\n\t\tBool res;\n\t\tres = gf_fs_ui_event(fsess, evt);\n\t\treturn res;\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nBool gf_filter_forward_gf_event(GF_Filter *filter, GF_Event *evt, Bool consumed, Bool skip_user)\n{\n\tif (!filter) return GF_FALSE;\n\treturn gf_fs_forward_gf_event(filter->session, evt, consumed, skip_user);\n\n}\n\nGF_EXPORT\nBool gf_filter_send_gf_event(GF_Filter *filter, GF_Event *evt)\n{\n\treturn gf_filter_forward_gf_event(filter, evt, GF_FALSE, GF_FALSE);\n}\n\n\nstatic void gf_fs_print_jsf_connection(GF_FilterSession *session, char *filter_name, GF_Filter *js_filter, void (*print_fn)(FILE *output, GF_SysPrintArgFlags flags, const char *fmt, ...) )\n{\n\tGF_CapsBundleStore capstore;\n\tconst char *js_name = NULL;\n\tGF_Err e=GF_OK;\n\tu32 i, j, count, nb_js_caps;\n\tGF_List *sources, *sinks;\n\tGF_FilterRegister loaded_freg;\n\tBool has_output, has_input;\n\n\tif (!js_filter) {\n\t\tif (!filter_name) return;\n\t\tjs_filter = gf_fs_load_filter(session, filter_name, &e);\n\t\tif (!js_filter) return;\n\t} else {\n\t\tif (!filter_name) filter_name = (char *) js_filter->freg->name;\n\t}\n\n\tjs_name = strrchr(filter_name, '/');\n\tif (!js_name) js_name = strrchr(filter_name, '\\\\');\n\tif (js_name) js_name++;\n\telse js_name = filter_name;\n\n\tnb_js_caps = gf_filter_caps_bundle_count(js_filter->forced_caps, js_filter->nb_forced_caps);\n\n\t//fake a new register with only the caps set\n\tmemset(&loaded_freg, 0, sizeof(GF_FilterRegister));\n\tloaded_freg.caps = js_filter->forced_caps;\n\tloaded_freg.nb_caps = js_filter->nb_forced_caps;\n\n\thas_output = gf_filter_has_out_caps(js_filter->forced_caps, js_filter->nb_forced_caps);\n\thas_input = gf_filter_has_in_caps(js_filter->forced_caps, js_filter->nb_forced_caps);\n\n\tmemset(&capstore, 0, sizeof(GF_CapsBundleStore));\n\tsources = gf_list_new();\n\tsinks = gf_list_new();\n\t//edges for JS are for the unloaded JSF (eg accept anything, output anything).\n\t//we need to do a manual check\n\tcount = gf_list_count(session->links);\n\tfor (i=0; i<count; i++) {\n\t\tu32 nb_src_caps, k, l;\n\t\tBool src_match = GF_FALSE;\n\t\tBool sink_match = GF_FALSE;\n\t\tGF_FilterRegDesc *a_reg = gf_list_get(session->links, i);\n\t\tif (a_reg->freg == js_filter->freg) continue;\n\n\t\t//check which cap of this filter matches our destination\n\t\tnb_src_caps = gf_filter_caps_bundle_count(a_reg->freg->caps, a_reg->freg->nb_caps);\n\t\tfor (k=0; k<nb_src_caps; k++) {\n\t\t\tfor (l=0; l<nb_js_caps; l++) {\n\t\t\t\ts32 bundle_idx;\n\t\t\t\tu32 loaded_filter_only_flags = 0;\n\t\t\t\tu32 path_weight;\n\t\t\t\tif (has_input && !src_match) {\n\t\t\t\t\tpath_weight = gf_filter_caps_to_caps_match(a_reg->freg, k, (const GF_FilterRegister *) &loaded_freg, 0, NULL, &bundle_idx, l, &loaded_filter_only_flags, &capstore);\n\t\t\t\t\tif (path_weight && (bundle_idx == l))\n\t\t\t\t\t\tsrc_match = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tif (has_output && !sink_match) {\n\t\t\t\t\tloaded_filter_only_flags = 0;\n\t\t\t\t\tpath_weight = gf_filter_caps_to_caps_match(&loaded_freg, l, a_reg->freg, 0, NULL, &bundle_idx, k, &loaded_filter_only_flags, &capstore);\n\n\t\t\t\t\tif (path_weight && (bundle_idx == k))\n\t\t\t\t\t\tsink_match = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (src_match && sink_match)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (src_match) gf_list_add(sources, (void *) a_reg->freg);\n\t\tif (sink_match) gf_list_add(sinks, (void *) a_reg->freg);\n\t}\n\n\tfor (i=0; i<2; i++) {\n\t\tGF_List *from = i ? sinks : sources;\n\t\tchar *type = i ? \"sinks\" : \"sources\";\n\n\t\tcount = gf_list_count(from);\n\t\tif (!count) {\n\t\t\tif (print_fn)\n\t\t\t\tprint_fn(stderr, 1, \"%s: no %s\\n\", js_name, type);\n\t\t\telse {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"%s: no %s\\n\", type));\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (print_fn)\n\t\t\tprint_fn(stderr, 1, \"%s %s:\", js_name, type);\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"%s %s:\", js_name, type));\n\t\t}\n\t\tfor (j=0; j<count; j++) {\n\t\t\tGF_FilterRegister *a_reg = gf_list_get(from, j);\n\t\t\tif (print_fn)\n\t\t\t\tprint_fn(stderr, 0, \" %s\", a_reg->name);\n\t\t\telse {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" %s\", a_reg->name));\n\t\t\t}\n\t\t}\n\t\tif (print_fn)\n\t\t\tprint_fn(stderr, 0, \"\\n\");\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\n\"));\n\t\t}\n\t}\n\n\tif (capstore.bundles_cap_found) gf_free(capstore.bundles_cap_found);\n\tif (capstore.bundles_in_ok) gf_free(capstore.bundles_in_ok);\n\tif (capstore.bundles_in_scores) gf_free(capstore.bundles_in_scores);\n\tgf_list_del(sources);\n\tgf_list_del(sinks);\n}\n\nGF_EXPORT\nvoid gf_fs_print_all_connections(GF_FilterSession *session, char *filter_name, void (*print_fn)(FILE *output, GF_SysPrintArgFlags flags, const char *fmt, ...) )\n{\n\tBool found = GF_FALSE;\n\tGF_List *done;\n\tu32 i, j, k, count;\n\tu32 llev = gf_log_get_tool_level(GF_LOG_FILTER);\n\n\tgf_log_set_tool_level(GF_LOG_FILTER, GF_LOG_INFO);\n\t//load JS to inspect its connections\n\tif (filter_name && strstr(filter_name, \".js\")) {\n\t\tgf_fs_print_jsf_connection(session, filter_name, NULL, print_fn);\n\t\tgf_log_set_tool_level(GF_LOG_FILTER, llev);\n\t\treturn;\n\t}\n\tdone = gf_list_new();\n\tcount = gf_list_count(session->links);\n\n\tfor (i=0; i<count; i++) {\n\t\tconst GF_FilterRegDesc *src = gf_list_get(session->links, i);\n\t\tif (filter_name && strcmp(src->freg->name, filter_name))\n\t\t\tcontinue;\n\n\t\tfound = GF_TRUE;\n\t\tif (print_fn)\n\t\t\tprint_fn(stderr, 1, \"%s sources:%s\", src->freg->name, src->nb_edges ? \"\" : \" none\\n\");\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"%s sources:%s\", src->freg->name, src->nb_edges ? \"\" : \" none\\n\"));\n\t\t}\n\t\tif (!src->nb_edges)\n\t\t\tcontinue;\n\n\t\tfor (j=0; j<src->nb_edges; j++) {\n\t\t\tif (gf_list_find(done, (void *) src->edges[j].src_reg->freg->name)<0) {\n\t\t\t\tif (print_fn)\n\t\t\t\t\tprint_fn(stderr, 0, \" %s\", src->edges[j].src_reg->freg->name);\n\t\t\t\telse {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" %s\", src->edges[j].src_reg->freg->name));\n\t\t\t\t}\n\t\t\t\tgf_list_add(done, (void *) src->edges[j].src_reg->freg->name);\n\t\t\t\tif (session->flags & GF_FS_FLAG_PRINT_CONNECTIONS) {\n\t\t\t\t\tif (print_fn)\n\t\t\t\t\t\tprint_fn(stderr, 0, \" ( \", src->edges[j].src_reg->freg->name);\n\t\t\t\t\telse {\n\t\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" ( \", src->edges[j].src_reg->freg->name));\n\t\t\t\t\t}\n\t\t\t\t\tfor (k=0; k<src->nb_edges; k++) {\n\t\t\t\t\t\tif (src->edges[j].src_reg != src->edges[k].src_reg) continue;;\n\n\t\t\t\t\t\tif (print_fn)\n\t\t\t\t\t\t\tprint_fn(stderr, 0, \"%d->%d \", src->edges[k].src_cap_idx, src->edges[k].dst_cap_idx);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"%d->%d \", src->edges[k].src_cap_idx, src->edges[k].dst_cap_idx));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif (print_fn)\n\t\t\t\t\t\tprint_fn(stderr, 0, \")\", src->edges[j].src_reg->freg->name);\n\t\t\t\t\telse {\n\t\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\")\", src->edges[j].src_reg->freg->name));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (print_fn)\n\t\t\tprint_fn(stderr, 0, \"\\n\");\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"\\n\"));\n\t\t}\n\t\tgf_list_reset(done);\n\t}\n\n\tif (found && filter_name) {\n\t\tu32 nb_sinks=0;\n\t\tif (print_fn)\n\t\t\tprint_fn(stderr, 1, \"%s sinks:\", filter_name);\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"%s sinks:\", filter_name));\n\t\t}\n\t\tcount = gf_list_count(session->links);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tconst GF_FilterRegDesc *src = gf_list_get(session->links, i);\n\t\t\tif (!strcmp(src->freg->name, filter_name)) {\n\t\t\t\tif (!(src->freg->flags & GF_FS_REG_EXPLICIT_ONLY) || !(src->freg->flags & GF_FS_REG_ALLOW_CYCLIC))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (j=0; j<src->nb_edges; j++) {\n\t\t\t\tif (strcmp(src->edges[j].src_reg->freg->name, filter_name)) continue;\n\n\t\t\t\tif (gf_list_find(done, (void *) src->freg->name)<0) {\n\t\t\t\t\tnb_sinks++;\n\t\t\t\t\tif (print_fn)\n\t\t\t\t\t\tprint_fn(stderr, 0, \" %s\", src->freg->name);\n\t\t\t\t\telse {\n\t\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" %s\", src->freg->name));\n\t\t\t\t\t}\n\t\t\t\t\tgf_list_add(done, (void *) src->freg->name);\n\t\t\t\t\tif (session->flags & GF_FS_FLAG_PRINT_CONNECTIONS) {\n\t\t\t\t\t\tif (print_fn)\n\t\t\t\t\t\t\tprint_fn(stderr, 0, \" ( \", src->edges[j].src_reg->freg->name);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\" ( \", src->edges[j].src_reg->freg->name));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (k=0; k<src->nb_edges; k++) {\n\t\t\t\t\t\t\tif (src->edges[j].src_reg != src->edges[k].src_reg) continue;\n\n\t\t\t\t\t\t\tif (print_fn)\n\t\t\t\t\t\t\t\tprint_fn(stderr, 0, \"%d->%d \", src->edges[k].src_cap_idx, src->edges[k].dst_cap_idx);\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"%d->%d \", src->edges[k].src_cap_idx, src->edges[k].dst_cap_idx));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (print_fn)\n\t\t\t\t\t\t\tprint_fn(stderr, 0, \")\", src->edges[j].src_reg->freg->name);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\")\", src->edges[j].src_reg->freg->name));\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_list_reset(done);\n\t\t}\n\t\tif (print_fn)\n\t\t\tprint_fn(stderr, 1, \"%s\\n\", nb_sinks ? \" \" : \" none\");\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"%s\\n\", nb_sinks ? \" \" : \" none\"));\n\t\t}\n\t}\n\n\tif (!found && filter_name) {\n\t\tGF_Err e = GF_OK;\n\t\tGF_Filter *f = gf_fs_load_filter(session, filter_name, &e);\n\t\tif (f) {\n\t\t\tgf_fs_print_jsf_connection(session, filter_name, f, print_fn);\n\t\t}\n\t\telse if (print_fn)\n\t\t\tprint_fn(stderr, 1, \"%s filter not found\\n\", filter_name);\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_APP, (\"%s filter not found\\n\", filter_name));\n\t\t}\n\t}\n\tgf_list_del(done);\n\tgf_log_set_tool_level(GF_LOG_FILTER, llev);\n}\n\nGF_EXPORT\nvoid gf_filter_print_all_connections(GF_Filter *filter, void (*print_fn)(FILE *output, GF_SysPrintArgFlags flags, const char *fmt, ...) )\n{\n\tif (!filter) return;\n\tif (filter->freg->flags & GF_FS_REG_CUSTOM) {\n\t\tgf_fs_print_jsf_connection(filter->session, NULL, filter, print_fn);\n\t} else {\n\t\tgf_fs_print_all_connections(filter->session, (char *) filter->freg->name, print_fn);\n\t}\n}\n\nGF_EXPORT\nvoid gf_filter_get_session_caps(GF_Filter *filter, GF_FilterSessionCaps *caps)\n{\n\tif (caps) {\n\t\tif (filter) {\n\t\t\t(*caps) = filter->session->caps;\n\t\t} else {\n\t\t\tmemset(caps, 0, sizeof(GF_FilterSessionCaps));\n\t\t}\n\t}\n}\n\nGF_EXPORT\nvoid gf_filter_set_session_caps(GF_Filter *filter, GF_FilterSessionCaps *caps)\n{\n\tif (caps && filter) {\n\t\tfilter->session->caps = (*caps);\n\t\t//TODO fire event\n\t}\n}\n\nGF_EXPORT\nu8 gf_filter_get_sep(GF_Filter *filter, GF_FilterSessionSepType sep_type)\n{\n\tswitch (sep_type) {\n\tcase GF_FS_SEP_ARGS: return filter->session->sep_args;\n\tcase GF_FS_SEP_NAME: return filter->session->sep_name;\n\tcase GF_FS_SEP_FRAG: return filter->session->sep_frag;\n\tcase GF_FS_SEP_LIST: return filter->session->sep_list;\n\tcase GF_FS_SEP_NEG: return filter->session->sep_neg;\n\tdefault: return 0;\n\t}\n}\n\n#ifndef GPAC_DISABLE_NETWORK\nstatic Bool gf_fsess_get_user_pass(void *usr_cbk, Bool secure, const char *site_url, char *usr_name, char *password, gf_dm_on_usr_pass async_pass, void *async_udta)\n{\n\tGF_Event evt;\n\tGF_FilterSession *fsess = (GF_FilterSession *)usr_cbk;\n\tevt.type = GF_EVENT_AUTHORIZATION;\n\tevt.auth.secure = secure;\n\tevt.auth.site_url = site_url;\n\tevt.auth.user = usr_name;\n\tevt.auth.password = password;\n\tevt.auth.on_usr_pass = async_pass;\n\tevt.auth.async_usr_data = async_udta;\n\treturn gf_fs_forward_gf_event(fsess, &evt, GF_FALSE, GF_FALSE);\n}\n#endif\n\nstatic GF_DownloadManager *gf_fs_get_download_manager(GF_FilterSession *fs)\n{\n#ifdef GPAC_USE_DOWNLOADER\n\tif (!fs->download_manager) {\n\t\tfs->download_manager = gf_dm_new(fs);\n\n#ifndef GPAC_DISABLE_NETWORK\n\t\tgf_dm_set_auth_callback(fs->download_manager, gf_fsess_get_user_pass, fs);\n#endif\n\t}\n\treturn fs->download_manager;\n#else\n\treturn NULL;\n#endif\n}\n\nGF_EXPORT\nGF_DownloadManager *gf_filter_get_download_manager(GF_Filter *filter)\n{\n\tif (!filter) return NULL;\n\treturn gf_fs_get_download_manager(filter->session);\n}\n\nGF_EXPORT\nstruct _gf_ft_mgr *gf_fs_get_font_manager(GF_FilterSession *fsess)\n{\n#ifdef GPAC_DISABLE_FONTS\n\treturn NULL;\n#else\n\tif (!fsess->font_manager) {\n\t\tfsess->font_manager = gf_font_manager_new();\n\t}\n\treturn fsess->font_manager;\n#endif\n}\n\nGF_EXPORT\nstruct _gf_ft_mgr *gf_filter_get_font_manager(GF_Filter *filter)\n{\n\tif (!filter) return NULL;\n\treturn gf_fs_get_font_manager(filter->session);\n}\n\nvoid gf_fs_cleanup_filters(GF_FilterSession *fsess)\n{\n\tassert(fsess->pid_connect_tasks_pending);\n\tsafe_int_dec(&fsess->pid_connect_tasks_pending);\n}\n\nGF_EXPORT\nGF_Err gf_fs_get_last_connect_error(GF_FilterSession *fs)\n{\n\tGF_Err e;\n\tif (!fs) return GF_BAD_PARAM;\n\te = fs->last_connect_error;\n\tfs->last_connect_error = GF_OK;\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_fs_get_last_process_error(GF_FilterSession *fs)\n{\n\tGF_Err e;\n\tif (!fs) return GF_BAD_PARAM;\n\te = fs->last_process_error;\n\tfs->last_process_error = GF_OK;\n\treturn e;\n}\n\ntypedef struct\n{\n\tGF_FilterSession *fsess;\n\tvoid *callback;\n\tBool (*task_execute) (GF_FilterSession *fsess, void *callback, u32 *reschedule_ms);\n\tBool (*task_execute_filter) (GF_Filter *filter, void *callback, u32 *reschedule_ms);\n#ifndef GPAC_DISABLE_REMOTERY\n\trmtU32 rmt_hash;\n#endif\n} GF_UserTask;\n\nstatic void gf_fs_user_task(GF_FSTask *task)\n{\n\tu32 reschedule_ms=0;\n\tGF_UserTask *utask = (GF_UserTask *)task->udta;\n\ttask->schedule_next_time = 0;\n\n#ifndef GPAC_DISABLE_REMOTERY\n\tgf_rmt_begin_hash(task->log_name, GF_RMT_AGGREGATE, &utask->rmt_hash);\n#endif\n\tif (utask->task_execute) {\n\t\ttask->requeue_request = utask->task_execute(utask->fsess, utask->callback, &reschedule_ms);\n\t} else if (task->filter) {\n\t\ttask->requeue_request = utask->task_execute_filter(task->filter, utask->callback, &reschedule_ms);\n\t} else {\n\t\ttask->requeue_request = 0;\n\t}\n\tgf_rmt_end();\n\t//if no requeue request or if we are in final flush, don't re-execute\n\tif (!task->requeue_request || utask->fsess->in_final_flush) {\n\t\tgf_free(utask);\n\t\ttask->udta = NULL;\n\t\t//we duplicated the name for user tasks\n\t\tgf_free((char *) task->log_name);\n\t\ttask->requeue_request = GF_FALSE;\n\t} else {\n\t\tassert(task->requeue_request);\n\t\ttask->schedule_next_time = gf_sys_clock_high_res() + 1000*reschedule_ms;\n\t}\n}\n\n\nstatic GF_Err gf_fs_post_user_task_internal(GF_FilterSession *fsess, Bool (*task_execute) (GF_FilterSession *fsess, void *callback, u32 *reschedule_ms), void *udta_callback, const char *log_name, Bool force_main)\n{\n\tGF_UserTask *utask;\n\tchar *_log_name;\n\tif (!fsess || !task_execute) return GF_BAD_PARAM;\n\tGF_SAFEALLOC(utask, GF_UserTask);\n\tif (!utask) return GF_OUT_OF_MEM;\n\tutask->fsess = fsess;\n\tutask->callback = udta_callback;\n\tutask->task_execute = task_execute;\n\t//dup mem for user task\n\t_log_name = gf_strdup(log_name ? log_name : \"user_task\");\n\tgf_fs_post_task_ex(fsess, gf_fs_user_task, NULL, NULL, _log_name, utask, GF_FALSE, force_main, GF_FALSE, TASK_TYPE_USER);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_fs_post_user_task(GF_FilterSession *fsess, Bool (*task_execute) (GF_FilterSession *fsess, void *callback, u32 *reschedule_ms), void *udta_callback, const char *log_name)\n{\n\treturn gf_fs_post_user_task_internal(fsess, task_execute, udta_callback, log_name, fsess->force_main_thread_tasks);\n}\n\nGF_EXPORT\nGF_Err gf_fs_post_user_task_main(GF_FilterSession *fsess, Bool (*task_execute) (GF_FilterSession *fsess, void *callback, u32 *reschedule_ms), void *udta_callback, const char *log_name)\n{\n\treturn gf_fs_post_user_task_internal(fsess, task_execute, udta_callback, log_name, GF_TRUE);\n}\n\nGF_EXPORT\nGF_Err gf_filter_post_task(GF_Filter *filter, Bool (*task_execute) (GF_Filter *filter, void *callback, u32 *reschedule_ms), void *udta, const char *task_name)\n{\n\tGF_UserTask *utask;\n\tif (!filter || !task_execute) return GF_BAD_PARAM;\n\tGF_SAFEALLOC(utask, GF_UserTask);\n\tif (!utask) return GF_OUT_OF_MEM;\n\tutask->callback = udta;\n\tutask->task_execute_filter = task_execute;\n\tutask->fsess = filter->session;\n\tchar *_log_name=NULL;\n\tif (task_name) {\n\t\t_log_name = gf_strdup(task_name);\n\t} else {\n\t\tgf_dynstrcat(&_log_name, filter->name, NULL);\n\t\tgf_dynstrcat(&_log_name, \"_task\", NULL);\n\t}\n\n\tgf_fs_post_task_class(filter->session, gf_fs_user_task, filter, NULL, _log_name, utask, TASK_TYPE_USER);\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nBool gf_fs_is_last_task(GF_FilterSession *fsess)\n{\n\tif (!fsess) return GF_TRUE;\n\tif (fsess->tasks_pending>1) return GF_FALSE;\n\tif (gf_fq_count(fsess->main_thread_tasks)) return GF_FALSE;\n\tif (gf_fq_count(fsess->tasks)) return GF_FALSE;\n\tif (fsess->non_blocking && fsess->tasks_in_process) return GF_FALSE;\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nBool gf_fs_in_final_flush(GF_FilterSession *fsess)\n{\n\tif (!fsess) return GF_TRUE;\n\treturn fsess->in_final_flush;\n}\nGF_EXPORT\nBool gf_fs_is_supported_mime(GF_FilterSession *fsess, const char *mime)\n{\n\tu32 i, count;\n\t//first pass on explicit mimes\n\tcount = gf_list_count(fsess->registry);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j;\n\t\tconst GF_FilterRegister *freg = gf_list_get(fsess->registry, i);\n\t\tfor (j=0; j<freg->nb_caps; j++) {\n\t\t\tconst GF_FilterCapability *acap = &freg->caps[j];\n\t\t\tif (!(acap->flags & GF_CAPFLAG_INPUT)) continue;\n\t\t\tif (acap->code == GF_PROP_PID_MIME) {\n\t\t\t\tif (acap->val.value.string && strstr(acap->val.value.string, mime)) return GF_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_FALSE;\n}\n\n\nGF_EXPORT\nvoid gf_fs_enable_reporting(GF_FilterSession *session, Bool reporting_on)\n{\n\tif (session) session->reporting_on = reporting_on;\n}\n\nGF_EXPORT\nvoid gf_fs_lock_filters(GF_FilterSession *session, Bool do_lock)\n{\n\tif (!session || !session->filters_mx) return;\n\tif (do_lock) gf_mx_p(session->filters_mx);\n\telse gf_mx_v(session->filters_mx);\n}\n\nGF_EXPORT\nu32 gf_fs_get_filters_count(GF_FilterSession *session)\n{\n\treturn session ? gf_list_count(session->filters) : 0;\n}\nGF_EXPORT\nGF_Filter *gf_fs_get_filter(GF_FilterSession *session, u32 idx)\n{\n\treturn session ? gf_list_get(session->filters, idx) : NULL;\n}\n\nGF_EXPORT\nGF_Err gf_filter_get_stats(GF_Filter *f, GF_FilterStats *stats)\n{\n\tu32 i;\n\tBool set_name=GF_FALSE;\n\tif (!stats || !f) return GF_BAD_PARAM;\n\tmemset(stats, 0, sizeof(GF_FilterStats));\n\tstats->filter = f;\n\tstats->filter_alias = f->multi_sink_target;\n\tif (f->multi_sink_target) return GF_OK;\n\t\n\tstats->percent = f->status_percent>10000 ? -1 : (s32) f->status_percent;\n\tstats->status = f->status_str;\n\tstats->nb_pck_processed = f->nb_pck_processed;\n\tstats->nb_bytes_processed = f->nb_bytes_processed;\n\tstats->time_process = f->time_process;\n\tstats->nb_hw_pck_sent = f->nb_hw_pck_sent;\n\tstats->nb_pck_sent = f->nb_pck_sent;\n\tstats->nb_bytes_sent = f->nb_bytes_sent;\n\tstats->nb_tasks_done = f->nb_tasks_done;\n\tstats->nb_errors = f->nb_errors;\n\tstats->name = f->name;\n\tstats->reg_name = f->freg->name;\n\tstats->filter_id = f->id;\n\tstats->done = f->removed || f->finalized;\n\tif (stats->name && !strcmp(stats->name, stats->reg_name)) {\n\t\tset_name=GF_TRUE;\n\t}\n\tstats->report_updated = f->report_updated;\n\tf->report_updated = GF_FALSE;\n\n\n\tif (!stats->nb_pid_out && stats->nb_pid_in) stats->type = GF_FS_STATS_FILTER_RAWOUT;\n\telse if (!stats->nb_pid_in && stats->nb_pid_out) stats->type = GF_FS_STATS_FILTER_RAWIN;\n\n\tstats->nb_pid_out = f->num_output_pids;\n\tfor (i=0; i<f->num_output_pids; i++) {\n\t\tGF_FilterPid *pid = gf_list_get(f->output_pids, i);\n\t\tstats->nb_out_pck += pid->nb_pck_sent;\n\t\tif (pid->has_seen_eos) stats->in_eos = GF_TRUE;\n\n\t\tif (pid->last_ts_sent.num * stats->last_ts_sent.den >= stats->last_ts_sent.num * pid->last_ts_sent.den)\n\t\t\tstats->last_ts_sent = pid->last_ts_sent;\n\n\t\tif (f->num_output_pids!=1) continue;\n\n\t\tif (!stats->codecid)\n\t\t\tstats->codecid = pid->codecid;\n\t\tif (!stats->stream_type)\n\t\t\tstats->stream_type = pid->stream_type;\n\n\t\t//set name if PID name is not a default generated one\n\t\tif (set_name && strncmp(pid->name, \"PID\", 3)) {\n\t\t\tstats->name = pid->name;\n\t\t\tset_name = GF_FALSE;\n\t\t}\n\t}\n\tgf_mx_p(f->tasks_mx);\n\tstats->nb_pid_in = f->num_input_pids;\n\tfor (i=0; i<f->num_input_pids; i++) {\n\t\tGF_FilterPidInst *pidi = gf_list_get(f->input_pids, i);\n\t\tstats->nb_in_pck += pidi->nb_processed;\n\t\tif (pidi->is_end_of_stream) stats->in_eos = GF_TRUE;\n\n\t\tif (pidi->is_decoder_input) stats->type = GF_FS_STATS_FILTER_DECODE;\n\t\telse if (pidi->is_encoder_input) stats->type = GF_FS_STATS_FILTER_ENCODE;\n\n\t\tif (pidi->pid && (pidi->pid->stream_type==GF_STREAM_FILE))\n\t\t\tstats->type = GF_FS_STATS_FILTER_DEMUX;\n\n\t\tif (pidi->last_ts_drop.num * stats->last_ts_drop.den >= stats->last_ts_drop.num * pidi->last_ts_drop.den)\n\t\t\tstats->last_ts_drop = pidi->last_ts_drop;\n\n\t\tif ((f->num_input_pids!=1) && f->num_output_pids)\n\t\t\tcontinue;\n\n\t\tif (!pidi->pid)\n\t\t\tcontinue;\n\n\t\tif (!stats->codecid)\n\t\t\tstats->codecid = pidi->pid->codecid;\n\t\tif (!stats->stream_type)\n\t\t\tstats->stream_type = pidi->pid->stream_type;\n\n\t\tif (set_name) {\n\t\t\tstats->name = pidi->pid->name;\n\t\t\tset_name = GF_FALSE;\n\t\t}\n\t}\n\tgf_mx_v(f->tasks_mx);\n\tif (!stats->type && stats->codecid) {\n\t\tif (!stats->nb_pid_out) {\n\t\t\tstats->type = GF_FS_STATS_FILTER_MEDIA_SINK;\n\t\t} else if (!stats->nb_pid_in) {\n\t\t\tstats->type = GF_FS_STATS_FILTER_MEDIA_SOURCE;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_fs_get_filter_stats(GF_FilterSession *session, u32 idx, GF_FilterStats *stats)\n{\n\tif (!stats || !session) return GF_BAD_PARAM;\n\treturn gf_filter_get_stats(gf_list_get(session->filters, idx), stats);\n}\n\nBool gf_fs_ui_event(GF_FilterSession *session, GF_Event *uievt)\n{\n\tBool ret;\n\tgf_mx_p(session->ui_mx);\n\tret = session->ui_event_proc(session->ui_opaque, uievt);\n\tgf_mx_v(session->ui_mx);\n\treturn ret;\n}\n\nvoid gf_fs_check_graph_load(GF_FilterSession *fsess, Bool for_load)\n{\n\tif (for_load) {\n\t\tif (!fsess->links || ! gf_list_count( fsess->links))\n\t\t\tgf_filter_sess_build_graph(fsess, NULL);\n\t} else {\n\t\tif (fsess->flags & GF_FS_FLAG_NO_GRAPH_CACHE)\n\t\t\tgf_filter_sess_reset_graph(fsess, NULL);\n\t}\n}\n\nGF_EXPORT\nGF_Filter *gf_fs_new_filter(GF_FilterSession *fsess, const char *name, u32 flags, GF_Err *e)\n{\n\tGF_Filter *f;\n\tchar *sep, szRegName[25];\n\tGF_FilterRegister *reg;\n\n\tGF_SAFEALLOC(reg, GF_FilterRegister);\n\tif (!reg) {\n\t\t*e = GF_OUT_OF_MEM;\n\t\treturn NULL;\n\t}\n\n\treg->flags = 0;\n#ifndef GPAC_DISABLE_DOC\n\treg->author = \"custom\";\n\treg->description = \"custom\";\n\treg->help = \"custom\";\n#endif\n\treg->version = \"custom\";\n\tsprintf(szRegName, \"custom%p\", reg);\n\tsep = strchr(name, fsess->sep_args);\n\tif (sep) sep[0] = 0;\n\treg->name = gf_strdup(name ? name : szRegName);\n\treg->flags = GF_FS_REG_CUSTOM | GF_FS_REG_EXPLICIT_ONLY;\n\n\tif (flags & GF_FS_REG_MAIN_THREAD)\n\t\treg->flags |= GF_FS_REG_MAIN_THREAD;\n\n\tf = gf_filter_new(fsess, reg, sep ? sep+1 : NULL, NULL, 0, e, NULL, GF_FALSE);\n\tif (f && name)\n\t\tgf_filter_set_name(f, name);\n\tif (sep) sep[0] = fsess->sep_args;\n\treturn f;\n}\n\n#ifndef GPAC_DISABLE_3D\n\n\n#define GF_VIDEO_HW_INTERNAL\t(1<<29)\n#define GF_VIDEO_HW_ATTACHED\t(1<<30)\n\nstatic Bool fsess_on_event(void *cbk, GF_Event *evt)\n{\n\treturn GF_TRUE;\n}\n\nGF_Err gf_fs_check_gl_provider(GF_FilterSession *session)\n{\n\tGF_Event evt;\n\tGF_Err e;\n\tconst char *sOpt;\n\tvoid *os_disp_handler;\n\n\tif (session->ext_gl_callback) {\n\t\te = session->ext_gl_callback(session->ext_gl_udta, GF_TRUE);\n\t\tif (e==GF_OK) gf_opengl_init();\n\t\treturn e;\n\t}\n\n\tif (!session->nb_gl_filters) return GF_OK;\n\tif (gf_list_count(session->gl_providers)) return GF_OK;\n\n\tif (session->gl_driver) return GF_OK;\n\n\n\tsession->gl_driver = (GF_VideoOutput *) gf_module_load(GF_VIDEO_OUTPUT_INTERFACE, gf_opts_get_key(\"core\", \"video-output\") );\n\n\tif (!session->gl_driver) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Failed to load a video output for OpenGL context support !\\n\"));\n\t\treturn GF_IO_ERR;\n\t}\n\tif (!gf_opts_get_key(\"core\", \"video-output\")) {\n\t\tgf_opts_set_key(\"core\", \"video-output\", session->gl_driver->module_name);\n\t}\n\tsession->gl_driver->hw_caps |= GF_VIDEO_HW_INTERNAL;\n\tsession->gl_driver->on_event = fsess_on_event;\n\tsession->gl_driver->evt_cbk_hdl = session;\n\n\tos_disp_handler = NULL;\n\tsOpt = gf_opts_get_key(\"temp\", \"window-display\");\n\tif (sOpt) sscanf(sOpt, \"%p\", &os_disp_handler);\n\n\te = session->gl_driver->Setup(session->gl_driver, NULL, os_disp_handler, GF_VOUT_INIT_HIDE);\n\tif (e!=GF_OK) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"Failed to setup Video Driver %s!\\n\", session->gl_driver->module_name));\n\t\tgf_modules_close_interface((GF_BaseInterface *)session->gl_driver);\n\t\tsession->gl_driver = NULL;\n\t\treturn e;\n\t}\n\n\t//and initialize GL context\n\tmemset(&evt, 0, sizeof(GF_Event));\n\tevt.type = GF_EVENT_VIDEO_SETUP;\n\tevt.setup.width = 128;\n\tevt.setup.height = 128;\n\tevt.setup.use_opengl = GF_TRUE;\n\tevt.setup.back_buffer = 1;\n\t//we anyway should'nt call swapBuffer/flush on this object\n\tevt.setup.disable_vsync = GF_TRUE;\n\tsession->gl_driver->ProcessEvent(session->gl_driver, &evt);\n\n\tif (evt.setup.use_opengl) {\n\t\tgf_opengl_init();\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_fs_set_gl(GF_FilterSession *session, Bool do_activate)\n{\n\tGF_Event evt;\n\tif (session->ext_gl_callback) {\n\t\treturn session->ext_gl_callback(session->ext_gl_udta, do_activate);\n\t}\n\n\tif (!session->gl_driver) return GF_BAD_PARAM;\n\tmemset(&evt, 0, sizeof(GF_Event));\n\tevt.type = GF_EVENT_SET_GL;\n\treturn session->gl_driver->ProcessEvent(session->gl_driver, &evt);\n}\n\nGF_VideoOutput *gf_filter_claim_opengl_provider(GF_Filter *filter)\n{\n\tif (!filter || !filter->session || !filter->session->gl_driver) return NULL;\n\tif (filter->session->ext_gl_callback) return NULL;\n\n\tif (! (filter->session->gl_driver->hw_caps & GF_VIDEO_HW_INTERNAL))\n\t\treturn NULL;\n\tif (filter->session->gl_driver->hw_caps & GF_VIDEO_HW_ATTACHED)\n\t\treturn NULL;\n\n\tfilter->session->gl_driver->hw_caps |= GF_VIDEO_HW_ATTACHED;\n\treturn filter->session->gl_driver;\n}\n\nBool gf_filter_unclaim_opengl_provider(GF_Filter *filter, GF_VideoOutput * video_out)\n{\n\tif (!filter || !video_out) return GF_FALSE;\n\tif (filter->session->ext_gl_callback) return GF_FALSE;\n\n\tif (! (video_out->hw_caps & GF_VIDEO_HW_INTERNAL))\n\t\treturn GF_FALSE;\n\tif (video_out != filter->session->gl_driver)\n\t\treturn GF_FALSE;\n\n\tif (filter->session->gl_driver->hw_caps & GF_VIDEO_HW_ATTACHED) {\n\t\tfilter->session->gl_driver->hw_caps &= ~GF_VIDEO_HW_ATTACHED;\n\t\tfilter->session->gl_driver->on_event = fsess_on_event;\n\t\tfilter->session->gl_driver->evt_cbk_hdl = filter->session;\n\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\n\n#else\nvoid *gf_filter_claim_opengl_provider(GF_Filter *filter)\n{\n\treturn NULL;\n}\nBool gf_filter_unclaim_opengl_provider(GF_Filter *filter, void *vout)\n{\n\treturn GF_FALSE;\n}\n\n#endif\n\n\nGF_EXPORT\nu32 gf_fs_get_http_max_rate(GF_FilterSession *fs)\n{\n#ifdef GPAC_USE_DOWNLOADER\n\tif (!fs->download_manager) {\n\t\tgf_fs_get_download_manager(fs);\n\t\tif (!fs->download_manager) return 0;\n\t}\n\treturn gf_dm_get_data_rate(fs->download_manager);\n#else\n\treturn 0;\n#endif\n}\n\nGF_EXPORT\nGF_Err gf_fs_set_http_max_rate(GF_FilterSession *fs, u32 rate)\n{\n#ifdef GPAC_USE_DOWNLOADER\n\tif (!fs) return GF_OK;\n\tif (!fs->download_manager) {\n\t\tgf_fs_get_download_manager(fs);\n\t\tif (!fs->download_manager) return GF_OUT_OF_MEM;\n\t}\n\tgf_dm_set_data_rate(fs->download_manager, rate);\n#endif\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu32 gf_fs_get_http_rate(GF_FilterSession *fs)\n{\n#ifdef GPAC_USE_DOWNLOADER\n\tif (!fs->download_manager) {\n\t\tgf_fs_get_download_manager(fs);\n\t\tif (!fs->download_manager) return 0;\n\t}\n\treturn gf_dm_get_global_rate(fs->download_manager);\n#else\n\treturn 0;\n#endif\n}\n\nGF_EXPORT\nBool gf_fs_is_supported_source(GF_FilterSession *session, const char *url, const char *parent_url)\n{\n\tGF_Err e;\n\tBool is_supported = GF_FALSE;\n\tgf_fs_load_source_dest_internal(session, url, NULL, parent_url, &e, NULL, NULL, GF_TRUE, GF_TRUE, &is_supported, NULL);\n\treturn is_supported;\n}\n\n\nGF_EXPORT\nBool gf_fs_fire_event(GF_FilterSession *fs, GF_Filter *f, GF_FilterEvent *evt, Bool upstream)\n{\n\tBool ret = GF_FALSE;\n\tif (!fs || !evt) return GF_FALSE;\n\n\tGF_FilterPid *on_pid = evt->base.on_pid;\n\tevt->base.on_pid = NULL;\n\tif (f) {\n\t\tif (evt->base.type==GF_FEVT_USER) {\n\t\t\tif (f->freg->process_event && f->event_target) {\n\t\t\t\tgf_mx_p(f->tasks_mx);\n\t\t\t\tf->freg->process_event(f, evt);\n\t\t\t\tgf_mx_v(f->tasks_mx);\n\t\t\t\tret = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\tif (!ret) {\n\t\t\tgf_mx_p(f->tasks_mx);\n\t\t\tif (f->num_output_pids && upstream) ret = GF_TRUE;\n\t\t\telse if (f->num_input_pids && !upstream) ret = GF_TRUE;\n\t\t\tif (ret)\n\t\t\t\tgf_filter_send_event(f, evt, upstream);\n\t\t\tgf_mx_v(f->tasks_mx);\n\t\t}\n\t} else {\n\t\tu32 i, count;\n\t\tgf_fs_lock_filters(fs, GF_TRUE);\n\t\tcount = gf_list_count(fs->filters);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tBool canceled;\n\t\t\tf = gf_list_get(fs->filters, i);\n\t\t\tif (f->disabled || f->removed) continue;\n\t\t\tif (f->multi_sink_target) continue;\n\t\t\tif (!f->freg->process_event) continue;\n\t\t\tif (!f->event_target) continue;\n\n\t\t\tgf_mx_p(f->tasks_mx);\n\t\t\tcanceled = f->freg->process_event(f, evt);\n\t\t\tgf_mx_v(f->tasks_mx);\n\t\t\tret = GF_TRUE;\n\t\t\tif (canceled) break;\n\t\t}\n\t\tgf_fs_lock_filters(fs, GF_FALSE);\n\t}\n\tevt->base.on_pid = on_pid;\n\treturn ret;\n}\n\nGF_EXPORT\nGF_Err gf_fs_set_filter_creation_callback(GF_FilterSession *session, gf_fs_on_filter_creation on_create_destroy, void *udta, Bool force_sync)\n{\n\tif (!session) return GF_BAD_PARAM;\n\tsession->rt_udta = udta;\n\tsession->on_filter_create_destroy = on_create_destroy;\n\tsession->force_main_thread_tasks = force_sync;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nvoid *gf_fs_get_rt_udta(GF_FilterSession *session)\n{\n\tif (!session) return NULL;\n\treturn session->rt_udta;\n}\n\nGF_EXPORT\nGF_Err gf_fs_set_external_gl_provider(GF_FilterSession *session, gf_fs_gl_activate on_gl_activate, void *udta)\n{\n\tif (!session || !on_gl_activate || session->ext_gl_callback) return GF_BAD_PARAM;\n\tif (gf_list_count(session->filters)) return GF_BAD_PARAM;\n\tsession->ext_gl_udta = udta;\n\tsession->ext_gl_callback = on_gl_activate;\n\treturn GF_OK;\n}\n#ifdef GF_FS_ENABLE_LOCALES\n\nstatic Bool fsess_find_res(GF_FSLocales *loc, char *parent, char *path, char *relocated_path, char *localized_rel_path)\n{\n\tFILE *f;\n\n\tif (loc->szAbsRelocatedPath) gf_free(loc->szAbsRelocatedPath);\n\tloc->szAbsRelocatedPath = gf_url_concatenate(parent, path);\n\tif (!loc->szAbsRelocatedPath) loc->szAbsRelocatedPath = gf_strdup(path);\n\n\tf = gf_fopen(loc->szAbsRelocatedPath, \"rb\");\n\tif (f) {\n\t\tgf_fclose(f);\n\t\tstrcpy(localized_rel_path, path);\n\t\tstrcpy(relocated_path, loc->szAbsRelocatedPath);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/* Checks if, for a given relative path, there exists a localized version in an given folder\n   if this is the case, it returns the absolute localized path, otherwise it returns null.\n   if the resource was localized, the last parameter is set to the localized relative path.\n*/\nstatic Bool fs_check_locales(void *__self, const char *locales_parent_path, const char *rel_path, char *relocated_path, char *localized_rel_path)\n{\n\tchar path[GF_MAX_PATH];\n\tconst char *opt;\n\n\tGF_FSLocales *loc = (GF_FSLocales*)__self;\n\n\t/* Checks if the rel_path argument really contains a relative path (no ':', no '/' at the beginning) */\n\tif (strstr(rel_path, \"://\") || (rel_path[0]=='/') || strstr(rel_path, \":\\\\\") || !strncmp(rel_path, \"\\\\\\\\\", 2)) {\n\t\treturn 0;\n\t}\n\n\t/*Checks if the absolute path is really absolute and points to a local file (no http or else) */\n\tif (!locales_parent_path ||\n\t        (locales_parent_path && (locales_parent_path[0] != '/') && strstr(locales_parent_path, \"://\") && strnicmp(locales_parent_path, \"file://\", 7))) {\n\t\treturn 0;\n\t}\n\topt = gf_opts_get_key(\"core\", \"lang\");\n\tif (opt && (!strcmp(opt, \"*\") || !strcmp(opt, \"un\") ) ) {\n\t\topt = NULL;\n\t}\n\n\twhile (opt) {\n\t\tchar lan[100];\n\t\tchar *sep;\n\t\tchar *sep_lang = strchr(opt, ';');\n\t\tif (sep_lang) sep_lang[0] = 0;\n\n\t\twhile (strchr(\" \\t\", opt[0]))\n\t\t\topt++;\n\n\t\tstrcpy(lan, opt);\n\n\t\tif (sep_lang) {\n\t\t\tsep_lang[0] = ';';\n\t\t\topt = sep_lang+1;\n\t\t} else {\n\t\t\topt = NULL;\n\t\t}\n\n\t\twhile (1) {\n\t\t\tsep = strstr(lan, \"-*\");\n\t\t\tif (!sep) break;\n\t\t\tstrncpy(sep, sep+2, strlen(sep)-2);\n\t\t}\n\n\t\tsprintf(path, \"locales/%s/%s\", lan, rel_path);\n\t\tif (fsess_find_res(loc, (char *) locales_parent_path, (char *) path, relocated_path, localized_rel_path))\n\t\t\treturn 1;\n\n\t\t/*recursively remove region (sub)tags*/\n\t\twhile (1) {\n\t\t\tsep = strrchr(lan, '-');\n\t\t\tif (!sep) break;\n\t\t\tsep[0] = 0;\n\t\t\tsprintf(path, \"locales/%s/%s\", lan, rel_path);\n\t\t\tif (fsess_find_res(loc, (char *) locales_parent_path, (char *) path, relocated_path, localized_rel_path))\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (fsess_find_res(loc, (char *) locales_parent_path, (char *) rel_path, relocated_path, localized_rel_path))\n\t\treturn 1;\n\t/* if we did not find the localized file, both the relocated and localized strings are NULL */\n\tstrcpy(localized_rel_path, \"\");\n\tstrcpy(relocated_path, \"\");\n\treturn 0;\n}\n#endif\n\nstatic Bool gf_fs_relocate_url(GF_FilterSession *session, const char *service_url, const char *parent_url, char *out_relocated_url, char *out_localized_url)\n{\n#ifdef GF_FS_ENABLE_LOCALES\n\tu32 i, count;\n\n\tcount = gf_list_count(session->uri_relocators);\n\tfor (i=0; i<count; i++) {\n\t\tBool result;\n\t\tGF_URIRelocator *uri_relocator = gf_list_get(session->uri_relocators, i);\n\t\tresult = uri_relocator->relocate_uri(uri_relocator, parent_url, service_url, out_relocated_url, out_localized_url);\n\t\tif (result) return 1;\n\t}\n#endif\n\treturn 0;\n}\n\nGF_EXPORT\nBool gf_filter_relocate_url(GF_Filter *filter, const char *service_url, const char *parent_url, char *out_relocated_url, char *out_localized_url)\n{\n\tif (!filter) return 0;\n\treturn gf_fs_relocate_url(filter->session, service_url, parent_url, out_relocated_url, out_localized_url);\n}\n\n\n#ifdef GPAC_CONFIG_EMSCRIPTEN\nvoid gf_fs_force_non_blocking(GF_FilterSession *fs)\n{\n\tif (fs) fs->non_blocking = GF_TRUE;\n}\nBool gf_filter_on_main_thread(GF_Filter *filter)\n{\n\tif (!filter) return GF_TRUE;\n\tif (gf_th_id() != filter->session->main_th.th_id) return GF_FALSE;\n\tif (filter->session->is_worker) return GF_FALSE;\n\treturn GF_TRUE;\n}\n#endif\n"], "filenames": ["src/filter_core/filter_session.c"], "buggy_code_start_loc": [4147], "buggy_code_end_loc": [4147], "fixing_code_start_loc": [4148], "fixing_code_end_loc": [4151], "type": "CWE-125", "message": "Out-of-bounds Read in GitHub repository gpac/gpac prior to 2.2.2.", "other": {"cve": {"id": "CVE-2023-2838", "sourceIdentifier": "security@huntr.dev", "published": "2023-05-22T18:15:09.293", "lastModified": "2023-05-27T04:15:25.057", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Out-of-bounds Read in GitHub repository gpac/gpac prior to 2.2.2."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 4.2}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.2.2", "matchCriteriaId": "DBF31B7B-F4C7-40C0-9245-09FECA1A8164"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/c88df2e202efad214c25b4e586f243b2038779ba", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/711e0988-5345-4c01-a2fe-1179604dd07f", "source": "security@huntr.dev", "tags": ["Exploit", "Patch"]}, {"url": "https://www.debian.org/security/2023/dsa-5411", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/c88df2e202efad214c25b4e586f243b2038779ba"}}