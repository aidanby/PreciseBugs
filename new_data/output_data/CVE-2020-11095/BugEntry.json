{"buggy_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Drawing Orders\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2016 Armin Novak <armin.novak@thincast.com>\n * Copyright 2016 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"window.h\"\n\n#include <winpr/wtypes.h>\n#include <winpr/crt.h>\n\n#include <freerdp/api.h>\n#include <freerdp/log.h>\n#include <freerdp/graphics.h>\n#include <freerdp/codec/bitmap.h>\n#include <freerdp/gdi/gdi.h>\n\n#include \"orders.h\"\n\n#include \"../cache/glyph.h\"\n#include \"../cache/bitmap.h\"\n#include \"../cache/brush.h\"\n#include \"../cache/cache.h\"\n\n#define TAG FREERDP_TAG(\"core.orders\")\n\nconst BYTE PRIMARY_DRAWING_ORDER_FIELD_BYTES[] = { DSTBLT_ORDER_FIELD_BYTES,\n\t                                               PATBLT_ORDER_FIELD_BYTES,\n\t                                               SCRBLT_ORDER_FIELD_BYTES,\n\t                                               0,\n\t                                               0,\n\t                                               0,\n\t                                               0,\n\t                                               DRAW_NINE_GRID_ORDER_FIELD_BYTES,\n\t                                               MULTI_DRAW_NINE_GRID_ORDER_FIELD_BYTES,\n\t                                               LINE_TO_ORDER_FIELD_BYTES,\n\t                                               OPAQUE_RECT_ORDER_FIELD_BYTES,\n\t                                               SAVE_BITMAP_ORDER_FIELD_BYTES,\n\t                                               0,\n\t                                               MEMBLT_ORDER_FIELD_BYTES,\n\t                                               MEM3BLT_ORDER_FIELD_BYTES,\n\t                                               MULTI_DSTBLT_ORDER_FIELD_BYTES,\n\t                                               MULTI_PATBLT_ORDER_FIELD_BYTES,\n\t                                               MULTI_SCRBLT_ORDER_FIELD_BYTES,\n\t                                               MULTI_OPAQUE_RECT_ORDER_FIELD_BYTES,\n\t                                               FAST_INDEX_ORDER_FIELD_BYTES,\n\t                                               POLYGON_SC_ORDER_FIELD_BYTES,\n\t                                               POLYGON_CB_ORDER_FIELD_BYTES,\n\t                                               POLYLINE_ORDER_FIELD_BYTES,\n\t                                               0,\n\t                                               FAST_GLYPH_ORDER_FIELD_BYTES,\n\t                                               ELLIPSE_SC_ORDER_FIELD_BYTES,\n\t                                               ELLIPSE_CB_ORDER_FIELD_BYTES,\n\t                                               GLYPH_INDEX_ORDER_FIELD_BYTES };\n\n#define PRIMARY_DRAWING_ORDER_COUNT (ARRAYSIZE(PRIMARY_DRAWING_ORDER_FIELD_BYTES))\n\nstatic const BYTE CBR2_BPP[] = { 0, 0, 0, 8, 16, 24, 32 };\n\nstatic const BYTE BPP_CBR2[] = { 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,\n\t                             0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 };\n\nstatic const BYTE CBR23_BPP[] = { 0, 0, 0, 8, 16, 24, 32 };\n\nstatic const BYTE BPP_CBR23[] = { 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,\n\t                              0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 };\n\nstatic const BYTE BMF_BPP[] = { 0, 1, 0, 8, 16, 24, 32, 0 };\n\nstatic const BYTE BPP_BMF[] = { 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,\n\t                            0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 };\n\nstatic BOOL check_order_activated(wLog* log, rdpSettings* settings, const char* orderName,\n                                  BOOL condition)\n{\n\tif (!condition)\n\t{\n\t\tif (settings->AllowUnanouncedOrdersFromServer)\n\t\t{\n\t\t\tWLog_Print(log, WLOG_WARN,\n\t\t\t           \"%s - SERVER BUG: The support for this feature was not announced!\",\n\t\t\t           orderName);\n\t\t\treturn TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWLog_Print(log, WLOG_ERROR,\n\t\t\t           \"%s - SERVER BUG: The support for this feature was not announced! Use \"\n\t\t\t           \"/relax-order-checks to ignore\",\n\t\t\t           orderName);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL check_alt_order_supported(wLog* log, rdpSettings* settings, BYTE orderType,\n                                      const char* orderName)\n{\n\tBOOL condition = FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_CREATE_OFFSCREEN_BITMAP:\n\t\tcase ORDER_TYPE_SWITCH_SURFACE:\n\t\t\tcondition = settings->OffscreenSupportLevel != 0;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CREATE_NINE_GRID_BITMAP:\n\t\t\tcondition = settings->DrawNineGridEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FRAME_MARKER:\n\t\t\tcondition = settings->FrameMarkerCommandEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_FIRST:\n\t\tcase ORDER_TYPE_GDIPLUS_NEXT:\n\t\tcase ORDER_TYPE_GDIPLUS_END:\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_FIRST:\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_NEXT:\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_END:\n\t\t\tcondition = settings->DrawGdiPlusCacheEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_WINDOW:\n\t\t\tcondition = settings->RemoteWndSupportLevel != WINDOW_LEVEL_NOT_SUPPORTED;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_STREAM_BITMAP_FIRST:\n\t\tcase ORDER_TYPE_STREAM_BITMAP_NEXT:\n\t\tcase ORDER_TYPE_COMPDESK_FIRST:\n\t\t\tcondition = TRUE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(log, WLOG_WARN, \"%s - Alternate Secondary Drawing Order UNKNOWN\", orderName);\n\t\t\tcondition = FALSE;\n\t\t\tbreak;\n\t}\n\n\treturn check_order_activated(log, settings, orderName, condition);\n}\n\nstatic BOOL check_secondary_order_supported(wLog* log, rdpSettings* settings, BYTE orderType,\n                                            const char* orderName)\n{\n\tBOOL condition = FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED:\n\t\tcase ORDER_TYPE_CACHE_BITMAP_COMPRESSED:\n\t\t\tcondition = settings->BitmapCacheEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED_V2:\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V2:\n\t\t\tcondition = settings->BitmapCacheEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V3:\n\t\t\tcondition = settings->BitmapCacheV3Enabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_COLOR_TABLE:\n\t\t\tcondition = (settings->OrderSupport[NEG_MEMBLT_INDEX] ||\n\t\t\t             settings->OrderSupport[NEG_MEM3BLT_INDEX]);\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_GLYPH:\n\t\t{\n\t\t\tswitch (settings->GlyphSupportLevel)\n\t\t\t{\n\t\t\t\tcase GLYPH_SUPPORT_PARTIAL:\n\t\t\t\tcase GLYPH_SUPPORT_FULL:\n\t\t\t\tcase GLYPH_SUPPORT_ENCODE:\n\t\t\t\t\tcondition = TRUE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_NONE:\n\t\t\t\tdefault:\n\t\t\t\t\tcondition = FALSE;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_BRUSH:\n\t\t\tcondition = TRUE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(log, WLOG_WARN, \"SECONDARY ORDER %s not supported\", orderName);\n\t\t\tbreak;\n\t}\n\n\treturn check_order_activated(log, settings, orderName, condition);\n}\n\nstatic BOOL check_primary_order_supported(wLog* log, rdpSettings* settings, UINT32 orderType,\n                                          const char* orderName)\n{\n\tBOOL condition = FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_DSTBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_DSTBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SCRBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_SCRBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_DRAW_NINE_GRID:\n\t\t\tcondition = settings->OrderSupport[NEG_DRAWNINEGRID_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DRAW_NINE_GRID:\n\t\t\tcondition = settings->OrderSupport[NEG_MULTI_DRAWNINEGRID_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_LINE_TO:\n\t\t\tcondition = settings->OrderSupport[NEG_LINETO_INDEX];\n\t\t\tbreak;\n\n\t\t/* [MS-RDPEGDI] 2.2.2.2.1.1.2.5 OpaqueRect (OPAQUERECT_ORDER)\n\t\t * suggests that PatBlt and OpaqueRect imply each other. */\n\t\tcase ORDER_TYPE_PATBLT:\n\t\tcase ORDER_TYPE_OPAQUE_RECT:\n\t\t\tcondition = settings->OrderSupport[NEG_OPAQUE_RECT_INDEX] ||\n\t\t\t            settings->OrderSupport[NEG_PATBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SAVE_BITMAP:\n\t\t\tcondition = settings->OrderSupport[NEG_SAVEBITMAP_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEMBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_MEMBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEM3BLT:\n\t\t\tcondition = settings->OrderSupport[NEG_MEM3BLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DSTBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_MULTIDSTBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_PATBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_MULTIPATBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_SCRBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_MULTIDSTBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_OPAQUE_RECT:\n\t\t\tcondition = settings->OrderSupport[NEG_MULTIOPAQUERECT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_INDEX:\n\t\t\tcondition = settings->OrderSupport[NEG_FAST_INDEX_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_SC:\n\t\t\tcondition = settings->OrderSupport[NEG_POLYGON_SC_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_CB:\n\t\t\tcondition = settings->OrderSupport[NEG_POLYGON_CB_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYLINE:\n\t\t\tcondition = settings->OrderSupport[NEG_POLYLINE_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_GLYPH:\n\t\t\tcondition = settings->OrderSupport[NEG_FAST_GLYPH_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_SC:\n\t\t\tcondition = settings->OrderSupport[NEG_ELLIPSE_SC_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_CB:\n\t\t\tcondition = settings->OrderSupport[NEG_ELLIPSE_CB_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GLYPH_INDEX:\n\t\t\tcondition = settings->OrderSupport[NEG_GLYPH_INDEX_INDEX];\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(log, WLOG_WARN, \"%s Primary Drawing Order not supported\", orderName);\n\t\t\tbreak;\n\t}\n\n\treturn check_order_activated(log, settings, orderName, condition);\n}\n\nstatic const char* primary_order_string(UINT32 orderType)\n{\n\tconst char* orders[] = { \"[0x%02\" PRIx8 \"] DstBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] PatBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] ScrBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] DrawNineGrid\",\n\t\t                     \"[0x%02\" PRIx8 \"] MultiDrawNineGrid\",\n\t\t                     \"[0x%02\" PRIx8 \"] LineTo\",\n\t\t                     \"[0x%02\" PRIx8 \"] OpaqueRect\",\n\t\t                     \"[0x%02\" PRIx8 \"] SaveBitmap\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] MemBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] Mem3Blt\",\n\t\t                     \"[0x%02\" PRIx8 \"] MultiDstBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] MultiPatBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] MultiScrBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] MultiOpaqueRect\",\n\t\t                     \"[0x%02\" PRIx8 \"] FastIndex\",\n\t\t                     \"[0x%02\" PRIx8 \"] PolygonSC\",\n\t\t                     \"[0x%02\" PRIx8 \"] PolygonCB\",\n\t\t                     \"[0x%02\" PRIx8 \"] Polyline\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] FastGlyph\",\n\t\t                     \"[0x%02\" PRIx8 \"] EllipseSC\",\n\t\t                     \"[0x%02\" PRIx8 \"] EllipseCB\",\n\t\t                     \"[0x%02\" PRIx8 \"] GlyphIndex\" };\n\tconst char* fmt = \"[0x%02\" PRIx8 \"] UNKNOWN\";\n\tstatic char buffer[64] = { 0 };\n\n\tif (orderType < ARRAYSIZE(orders))\n\t\tfmt = orders[orderType];\n\n\tsprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);\n\treturn buffer;\n}\nstatic const char* secondary_order_string(UINT32 orderType)\n{\n\tconst char* orders[] = { \"[0x%02\" PRIx8 \"] Cache Bitmap\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Color Table\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap (Compressed)\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Glyph\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap V2\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap V2 (Compressed)\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Brush\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap V3\" };\n\tconst char* fmt = \"[0x%02\" PRIx8 \"] UNKNOWN\";\n\tstatic char buffer[64] = { 0 };\n\n\tif (orderType < ARRAYSIZE(orders))\n\t\tfmt = orders[orderType];\n\n\tsprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);\n\treturn buffer;\n}\nstatic const char* altsec_order_string(BYTE orderType)\n{\n\tconst char* orders[] = {\n\t\t\"[0x%02\" PRIx8 \"] Switch Surface\",         \"[0x%02\" PRIx8 \"] Create Offscreen Bitmap\",\n\t\t\"[0x%02\" PRIx8 \"] Stream Bitmap First\",    \"[0x%02\" PRIx8 \"] Stream Bitmap Next\",\n\t\t\"[0x%02\" PRIx8 \"] Create NineGrid Bitmap\", \"[0x%02\" PRIx8 \"] Draw GDI+ First\",\n\t\t\"[0x%02\" PRIx8 \"] Draw GDI+ Next\",         \"[0x%02\" PRIx8 \"] Draw GDI+ End\",\n\t\t\"[0x%02\" PRIx8 \"] Draw GDI+ Cache First\",  \"[0x%02\" PRIx8 \"] Draw GDI+ Cache Next\",\n\t\t\"[0x%02\" PRIx8 \"] Draw GDI+ Cache End\",    \"[0x%02\" PRIx8 \"] Windowing\",\n\t\t\"[0x%02\" PRIx8 \"] Desktop Composition\",    \"[0x%02\" PRIx8 \"] Frame Marker\"\n\t};\n\tconst char* fmt = \"[0x%02\" PRIx8 \"] UNKNOWN\";\n\tstatic char buffer[64] = { 0 };\n\n\tif (orderType < ARRAYSIZE(orders))\n\t\tfmt = orders[orderType];\n\n\tsprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);\n\treturn buffer;\n}\n\nstatic INLINE BOOL update_read_coord(wStream* s, INT32* coord, BOOL delta)\n{\n\tINT8 lsi8;\n\tINT16 lsi16;\n\n\tif (delta)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_INT8(s, lsi8);\n\t\t*coord += lsi8;\n\t}\n\telse\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_INT16(s, lsi16);\n\t\t*coord = lsi16;\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_coord(wStream* s, INT32 coord)\n{\n\tStream_Write_UINT16(s, coord);\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_color(wStream* s, UINT32* color)\n{\n\tBYTE byte;\n\n\tif (Stream_GetRemainingLength(s) < 3)\n\t\treturn FALSE;\n\n\t*color = 0;\n\tStream_Read_UINT8(s, byte);\n\t*color = (UINT32)byte;\n\tStream_Read_UINT8(s, byte);\n\t*color |= ((UINT32)byte << 8) & 0xFF00;\n\tStream_Read_UINT8(s, byte);\n\t*color |= ((UINT32)byte << 16) & 0xFF0000;\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_color(wStream* s, UINT32 color)\n{\n\tBYTE byte;\n\tbyte = (color & 0xFF);\n\tStream_Write_UINT8(s, byte);\n\tbyte = ((color >> 8) & 0xFF);\n\tStream_Write_UINT8(s, byte);\n\tbyte = ((color >> 16) & 0xFF);\n\tStream_Write_UINT8(s, byte);\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_colorref(wStream* s, UINT32* color)\n{\n\tBYTE byte;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\t*color = 0;\n\tStream_Read_UINT8(s, byte);\n\t*color = byte;\n\tStream_Read_UINT8(s, byte);\n\t*color |= ((UINT32)byte << 8);\n\tStream_Read_UINT8(s, byte);\n\t*color |= ((UINT32)byte << 16);\n\tStream_Seek_UINT8(s);\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_color_quad(wStream* s, UINT32* color)\n{\n\treturn update_read_colorref(s, color);\n}\nstatic INLINE void update_write_color_quad(wStream* s, UINT32 color)\n{\n\tBYTE byte;\n\tbyte = (color >> 16) & 0xFF;\n\tStream_Write_UINT8(s, byte);\n\tbyte = (color >> 8) & 0xFF;\n\tStream_Write_UINT8(s, byte);\n\tbyte = color & 0xFF;\n\tStream_Write_UINT8(s, byte);\n}\nstatic INLINE BOOL update_read_2byte_unsigned(wStream* s, UINT32* value)\n{\n\tBYTE byte;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, byte);\n\n\tif (byte & 0x80)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\t*value = (byte & 0x7F) << 8;\n\t\tStream_Read_UINT8(s, byte);\n\t\t*value |= byte;\n\t}\n\telse\n\t{\n\t\t*value = (byte & 0x7F);\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_2byte_unsigned(wStream* s, UINT32 value)\n{\n\tBYTE byte;\n\n\tif (value > 0x7FFF)\n\t\treturn FALSE;\n\n\tif (value >= 0x7F)\n\t{\n\t\tbyte = ((value & 0x7F00) >> 8);\n\t\tStream_Write_UINT8(s, byte | 0x80);\n\t\tbyte = (value & 0xFF);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse\n\t{\n\t\tbyte = (value & 0x7F);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_2byte_signed(wStream* s, INT32* value)\n{\n\tBYTE byte;\n\tBOOL negative;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, byte);\n\tnegative = (byte & 0x40) ? TRUE : FALSE;\n\t*value = (byte & 0x3F);\n\n\tif (byte & 0x80)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\t*value = (*value << 8) | byte;\n\t}\n\n\tif (negative)\n\t\t*value *= -1;\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_2byte_signed(wStream* s, INT32 value)\n{\n\tBYTE byte;\n\tBOOL negative = FALSE;\n\n\tif (value < 0)\n\t{\n\t\tnegative = TRUE;\n\t\tvalue *= -1;\n\t}\n\n\tif (value > 0x3FFF)\n\t\treturn FALSE;\n\n\tif (value >= 0x3F)\n\t{\n\t\tbyte = ((value & 0x3F00) >> 8);\n\n\t\tif (negative)\n\t\t\tbyte |= 0x40;\n\n\t\tStream_Write_UINT8(s, byte | 0x80);\n\t\tbyte = (value & 0xFF);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse\n\t{\n\t\tbyte = (value & 0x3F);\n\n\t\tif (negative)\n\t\t\tbyte |= 0x40;\n\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_4byte_unsigned(wStream* s, UINT32* value)\n{\n\tBYTE byte;\n\tBYTE count;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, byte);\n\tcount = (byte & 0xC0) >> 6;\n\n\tif (Stream_GetRemainingLength(s) < count)\n\t\treturn FALSE;\n\n\tswitch (count)\n\t{\n\t\tcase 0:\n\t\t\t*value = (byte & 0x3F);\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\t*value = (byte & 0x3F) << 8;\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= byte;\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\t*value = (byte & 0x3F) << 16;\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= (byte << 8);\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= byte;\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\t*value = (byte & 0x3F) << 24;\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= (byte << 16);\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= (byte << 8);\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= byte;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_4byte_unsigned(wStream* s, UINT32 value)\n{\n\tBYTE byte;\n\n\tif (value <= 0x3F)\n\t{\n\t\tStream_Write_UINT8(s, value);\n\t}\n\telse if (value <= 0x3FFF)\n\t{\n\t\tbyte = (value >> 8) & 0x3F;\n\t\tStream_Write_UINT8(s, byte | 0x40);\n\t\tbyte = (value & 0xFF);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse if (value <= 0x3FFFFF)\n\t{\n\t\tbyte = (value >> 16) & 0x3F;\n\t\tStream_Write_UINT8(s, byte | 0x80);\n\t\tbyte = (value >> 8) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (value & 0xFF);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse if (value <= 0x3FFFFFFF)\n\t{\n\t\tbyte = (value >> 24) & 0x3F;\n\t\tStream_Write_UINT8(s, byte | 0xC0);\n\t\tbyte = (value >> 16) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (value >> 8) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (value & 0xFF);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_delta(wStream* s, INT32* value)\n{\n\tBYTE byte;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 1\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT8(s, byte);\n\n\tif (byte & 0x40)\n\t\t*value = (byte | ~0x3F);\n\telse\n\t\t*value = (byte & 0x3F);\n\n\tif (byte & 0x80)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 1\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tStream_Read_UINT8(s, byte);\n\t\t*value = (*value << 8) | byte;\n\t}\n\n\treturn TRUE;\n}\n#if 0\nstatic INLINE void update_read_glyph_delta(wStream* s, UINT16* value)\n{\n\tBYTE byte;\n\tStream_Read_UINT8(s, byte);\n\n\tif (byte == 0x80)\n\t\tStream_Read_UINT16(s, *value);\n\telse\n\t\t*value = (byte & 0x3F);\n}\nstatic INLINE void update_seek_glyph_delta(wStream* s)\n{\n\tBYTE byte;\n\tStream_Read_UINT8(s, byte);\n\n\tif (byte & 0x80)\n\t\tStream_Seek_UINT8(s);\n}\n#endif\nstatic INLINE BOOL update_read_brush(wStream* s, rdpBrush* brush, BYTE fieldFlags)\n{\n\tif (fieldFlags & ORDER_FIELD_01)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, brush->x);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_02)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, brush->y);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_03)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, brush->style);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_04)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, brush->hatch);\n\t}\n\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->index = brush->hatch;\n\t\tbrush->bpp = BMF_BPP[brush->style & 0x07];\n\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 7)\n\t\t\treturn FALSE;\n\n\t\tbrush->data = (BYTE*)brush->p8x8;\n\t\tStream_Read_UINT8(s, brush->data[7]);\n\t\tStream_Read_UINT8(s, brush->data[6]);\n\t\tStream_Read_UINT8(s, brush->data[5]);\n\t\tStream_Read_UINT8(s, brush->data[4]);\n\t\tStream_Read_UINT8(s, brush->data[3]);\n\t\tStream_Read_UINT8(s, brush->data[2]);\n\t\tStream_Read_UINT8(s, brush->data[1]);\n\t\tbrush->data[0] = brush->hatch;\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_brush(wStream* s, rdpBrush* brush, BYTE fieldFlags)\n{\n\tif (fieldFlags & ORDER_FIELD_01)\n\t{\n\t\tStream_Write_UINT8(s, brush->x);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_02)\n\t{\n\t\tStream_Write_UINT8(s, brush->y);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_03)\n\t{\n\t\tStream_Write_UINT8(s, brush->style);\n\t}\n\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->hatch = brush->index;\n\t\tbrush->bpp = BMF_BPP[brush->style & 0x07];\n\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_04)\n\t{\n\t\tStream_Write_UINT8(s, brush->hatch);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tbrush->data = (BYTE*)brush->p8x8;\n\t\tStream_Write_UINT8(s, brush->data[7]);\n\t\tStream_Write_UINT8(s, brush->data[6]);\n\t\tStream_Write_UINT8(s, brush->data[5]);\n\t\tStream_Write_UINT8(s, brush->data[4]);\n\t\tStream_Write_UINT8(s, brush->data[3]);\n\t\tStream_Write_UINT8(s, brush->data[2]);\n\t\tStream_Write_UINT8(s, brush->data[1]);\n\t\tbrush->data[0] = brush->hatch;\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_delta_rects(wStream* s, DELTA_RECT* rectangles, UINT32* nr)\n{\n\tUINT32 number = *nr;\n\tUINT32 i;\n\tBYTE flags = 0;\n\tBYTE* zeroBits;\n\tUINT32 zeroBitsSize;\n\n\tif (number > 45)\n\t{\n\t\tWLog_WARN(TAG, \"Invalid number of delta rectangles %\" PRIu32, number);\n\t\treturn FALSE;\n\t}\n\n\tzeroBitsSize = ((number + 1) / 2);\n\n\tif (Stream_GetRemainingLength(s) < zeroBitsSize)\n\t\treturn FALSE;\n\n\tStream_GetPointer(s, zeroBits);\n\tStream_Seek(s, zeroBitsSize);\n\tZeroMemory(rectangles, sizeof(DELTA_RECT) * number);\n\n\tfor (i = 0; i < number; i++)\n\t{\n\t\tif (i % 2 == 0)\n\t\t\tflags = zeroBits[i / 2];\n\n\t\tif ((~flags & 0x80) && !update_read_delta(s, &rectangles[i].left))\n\t\t\treturn FALSE;\n\n\t\tif ((~flags & 0x40) && !update_read_delta(s, &rectangles[i].top))\n\t\t\treturn FALSE;\n\n\t\tif (~flags & 0x20)\n\t\t{\n\t\t\tif (!update_read_delta(s, &rectangles[i].width))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse if (i > 0)\n\t\t\trectangles[i].width = rectangles[i - 1].width;\n\t\telse\n\t\t\trectangles[i].width = 0;\n\n\t\tif (~flags & 0x10)\n\t\t{\n\t\t\tif (!update_read_delta(s, &rectangles[i].height))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse if (i > 0)\n\t\t\trectangles[i].height = rectangles[i - 1].height;\n\t\telse\n\t\t\trectangles[i].height = 0;\n\n\t\tif (i > 0)\n\t\t{\n\t\t\trectangles[i].left += rectangles[i - 1].left;\n\t\t\trectangles[i].top += rectangles[i - 1].top;\n\t\t}\n\n\t\tflags <<= 4;\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_delta_points(wStream* s, DELTA_POINT* points, int number, INT16 x,\n                                            INT16 y)\n{\n\tint i;\n\tBYTE flags = 0;\n\tBYTE* zeroBits;\n\tUINT32 zeroBitsSize;\n\tzeroBitsSize = ((number + 3) / 4);\n\n\tif (Stream_GetRemainingLength(s) < zeroBitsSize)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < %\" PRIu32 \"\", zeroBitsSize);\n\t\treturn FALSE;\n\t}\n\n\tStream_GetPointer(s, zeroBits);\n\tStream_Seek(s, zeroBitsSize);\n\tZeroMemory(points, sizeof(DELTA_POINT) * number);\n\n\tfor (i = 0; i < number; i++)\n\t{\n\t\tif (i % 4 == 0)\n\t\t\tflags = zeroBits[i / 4];\n\n\t\tif ((~flags & 0x80) && !update_read_delta(s, &points[i].x))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"update_read_delta(x) failed\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif ((~flags & 0x40) && !update_read_delta(s, &points[i].y))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"update_read_delta(y) failed\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tflags <<= 2;\n\t}\n\n\treturn TRUE;\n}\n#define ORDER_FIELD_BYTE(NO, TARGET)                        \\\n\tdo                                                      \\\n\t{                                                       \\\n\t\tif (orderInfo->fieldFlags & (1 << (NO - 1)))        \\\n\t\t{                                                   \\\n\t\t\tif (Stream_GetRemainingLength(s) < 1)           \\\n\t\t\t{                                               \\\n\t\t\t\tWLog_ERR(TAG, \"error reading %s\", #TARGET); \\\n\t\t\t\treturn FALSE;                               \\\n\t\t\t}                                               \\\n\t\t\tStream_Read_UINT8(s, TARGET);                   \\\n\t\t}                                                   \\\n\t} while (0)\n#define ORDER_FIELD_2BYTE(NO, TARGET1, TARGET2)                              \\\n\tdo                                                                       \\\n\t{                                                                        \\\n\t\tif (orderInfo->fieldFlags & (1 << (NO - 1)))                         \\\n\t\t{                                                                    \\\n\t\t\tif (Stream_GetRemainingLength(s) < 2)                            \\\n\t\t\t{                                                                \\\n\t\t\t\tWLog_ERR(TAG, \"error reading %s or %s\", #TARGET1, #TARGET2); \\\n\t\t\t\treturn FALSE;                                                \\\n\t\t\t}                                                                \\\n\t\t\tStream_Read_UINT8(s, TARGET1);                                   \\\n\t\t\tStream_Read_UINT8(s, TARGET2);                                   \\\n\t\t}                                                                    \\\n\t} while (0)\n#define ORDER_FIELD_UINT16(NO, TARGET)                      \\\n\tdo                                                      \\\n\t{                                                       \\\n\t\tif (orderInfo->fieldFlags & (1 << (NO - 1)))        \\\n\t\t{                                                   \\\n\t\t\tif (Stream_GetRemainingLength(s) < 2)           \\\n\t\t\t{                                               \\\n\t\t\t\tWLog_ERR(TAG, \"error reading %s\", #TARGET); \\\n\t\t\t\treturn FALSE;                               \\\n\t\t\t}                                               \\\n\t\t\tStream_Read_UINT16(s, TARGET);                  \\\n\t\t}                                                   \\\n\t} while (0)\n#define ORDER_FIELD_UINT32(NO, TARGET)                      \\\n\tdo                                                      \\\n\t{                                                       \\\n\t\tif (orderInfo->fieldFlags & (1 << (NO - 1)))        \\\n\t\t{                                                   \\\n\t\t\tif (Stream_GetRemainingLength(s) < 4)           \\\n\t\t\t{                                               \\\n\t\t\t\tWLog_ERR(TAG, \"error reading %s\", #TARGET); \\\n\t\t\t\treturn FALSE;                               \\\n\t\t\t}                                               \\\n\t\t\tStream_Read_UINT32(s, TARGET);                  \\\n\t\t}                                                   \\\n\t} while (0)\n#define ORDER_FIELD_COORD(NO, TARGET)                                    \\\n\tdo                                                                   \\\n\t{                                                                    \\\n\t\tif ((orderInfo->fieldFlags & (1 << (NO - 1))) &&                 \\\n\t\t    !update_read_coord(s, &TARGET, orderInfo->deltaCoordinates)) \\\n\t\t{                                                                \\\n\t\t\tWLog_ERR(TAG, \"error reading %s\", #TARGET);                  \\\n\t\t\treturn FALSE;                                                \\\n\t\t}                                                                \\\n\t} while (0)\nstatic INLINE BOOL ORDER_FIELD_COLOR(const ORDER_INFO* orderInfo, wStream* s, UINT32 NO,\n                                     UINT32* TARGET)\n{\n\tif (!TARGET || !orderInfo)\n\t\treturn FALSE;\n\n\tif ((orderInfo->fieldFlags & (1 << (NO - 1))) && !update_read_color(s, TARGET))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\nstatic INLINE BOOL FIELD_SKIP_BUFFER16(wStream* s, UINT32 TARGET_LEN)\n{\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, TARGET_LEN);\n\n\tif (!Stream_SafeSeek(s, TARGET_LEN))\n\t{\n\t\tWLog_ERR(TAG, \"error skipping %\" PRIu32 \" bytes\", TARGET_LEN);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n/* Primary Drawing Orders */\nstatic BOOL update_read_dstblt_order(wStream* s, const ORDER_INFO* orderInfo, DSTBLT_ORDER* dstblt)\n{\n\tORDER_FIELD_COORD(1, dstblt->nLeftRect);\n\tORDER_FIELD_COORD(2, dstblt->nTopRect);\n\tORDER_FIELD_COORD(3, dstblt->nWidth);\n\tORDER_FIELD_COORD(4, dstblt->nHeight);\n\tORDER_FIELD_BYTE(5, dstblt->bRop);\n\treturn TRUE;\n}\nint update_approximate_dstblt_order(ORDER_INFO* orderInfo, const DSTBLT_ORDER* dstblt)\n{\n\treturn 32;\n}\nBOOL update_write_dstblt_order(wStream* s, ORDER_INFO* orderInfo, const DSTBLT_ORDER* dstblt)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, update_approximate_dstblt_order(orderInfo, dstblt)))\n\t\treturn FALSE;\n\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tupdate_write_coord(s, dstblt->nLeftRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, dstblt->nTopRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, dstblt->nWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, dstblt->nHeight);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tStream_Write_UINT8(s, dstblt->bRop);\n\treturn TRUE;\n}\nstatic BOOL update_read_patblt_order(wStream* s, const ORDER_INFO* orderInfo, PATBLT_ORDER* patblt)\n{\n\tORDER_FIELD_COORD(1, patblt->nLeftRect);\n\tORDER_FIELD_COORD(2, patblt->nTopRect);\n\tORDER_FIELD_COORD(3, patblt->nWidth);\n\tORDER_FIELD_COORD(4, patblt->nHeight);\n\tORDER_FIELD_BYTE(5, patblt->bRop);\n\tORDER_FIELD_COLOR(orderInfo, s, 6, &patblt->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 7, &patblt->foreColor);\n\treturn update_read_brush(s, &patblt->brush, orderInfo->fieldFlags >> 7);\n}\nint update_approximate_patblt_order(ORDER_INFO* orderInfo, PATBLT_ORDER* patblt)\n{\n\treturn 32;\n}\nBOOL update_write_patblt_order(wStream* s, ORDER_INFO* orderInfo, PATBLT_ORDER* patblt)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, update_approximate_patblt_order(orderInfo, patblt)))\n\t\treturn FALSE;\n\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tupdate_write_coord(s, patblt->nLeftRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, patblt->nTopRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, patblt->nWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, patblt->nHeight);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tStream_Write_UINT8(s, patblt->bRop);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tupdate_write_color(s, patblt->backColor);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tupdate_write_color(s, patblt->foreColor);\n\torderInfo->fieldFlags |= ORDER_FIELD_08;\n\torderInfo->fieldFlags |= ORDER_FIELD_09;\n\torderInfo->fieldFlags |= ORDER_FIELD_10;\n\torderInfo->fieldFlags |= ORDER_FIELD_11;\n\torderInfo->fieldFlags |= ORDER_FIELD_12;\n\tupdate_write_brush(s, &patblt->brush, orderInfo->fieldFlags >> 7);\n\treturn TRUE;\n}\nstatic BOOL update_read_scrblt_order(wStream* s, const ORDER_INFO* orderInfo, SCRBLT_ORDER* scrblt)\n{\n\tORDER_FIELD_COORD(1, scrblt->nLeftRect);\n\tORDER_FIELD_COORD(2, scrblt->nTopRect);\n\tORDER_FIELD_COORD(3, scrblt->nWidth);\n\tORDER_FIELD_COORD(4, scrblt->nHeight);\n\tORDER_FIELD_BYTE(5, scrblt->bRop);\n\tORDER_FIELD_COORD(6, scrblt->nXSrc);\n\tORDER_FIELD_COORD(7, scrblt->nYSrc);\n\treturn TRUE;\n}\nint update_approximate_scrblt_order(ORDER_INFO* orderInfo, const SCRBLT_ORDER* scrblt)\n{\n\treturn 32;\n}\nBOOL update_write_scrblt_order(wStream* s, ORDER_INFO* orderInfo, const SCRBLT_ORDER* scrblt)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, update_approximate_scrblt_order(orderInfo, scrblt)))\n\t\treturn FALSE;\n\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tupdate_write_coord(s, scrblt->nLeftRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, scrblt->nTopRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, scrblt->nWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, scrblt->nHeight);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tStream_Write_UINT8(s, scrblt->bRop);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tupdate_write_coord(s, scrblt->nXSrc);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tupdate_write_coord(s, scrblt->nYSrc);\n\treturn TRUE;\n}\nstatic BOOL update_read_opaque_rect_order(wStream* s, const ORDER_INFO* orderInfo,\n                                          OPAQUE_RECT_ORDER* opaque_rect)\n{\n\tBYTE byte;\n\tORDER_FIELD_COORD(1, opaque_rect->nLeftRect);\n\tORDER_FIELD_COORD(2, opaque_rect->nTopRect);\n\tORDER_FIELD_COORD(3, opaque_rect->nWidth);\n\tORDER_FIELD_COORD(4, opaque_rect->nHeight);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\topaque_rect->color = (opaque_rect->color & 0x00FFFF00) | ((UINT32)byte);\n\t}\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_06)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\topaque_rect->color = (opaque_rect->color & 0x00FF00FF) | ((UINT32)byte << 8);\n\t}\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\topaque_rect->color = (opaque_rect->color & 0x0000FFFF) | ((UINT32)byte << 16);\n\t}\n\n\treturn TRUE;\n}\nint update_approximate_opaque_rect_order(ORDER_INFO* orderInfo,\n                                         const OPAQUE_RECT_ORDER* opaque_rect)\n{\n\treturn 32;\n}\nBOOL update_write_opaque_rect_order(wStream* s, ORDER_INFO* orderInfo,\n                                    const OPAQUE_RECT_ORDER* opaque_rect)\n{\n\tBYTE byte;\n\tint inf = update_approximate_opaque_rect_order(orderInfo, opaque_rect);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\t// TODO: Color format conversion\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tupdate_write_coord(s, opaque_rect->nLeftRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, opaque_rect->nTopRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, opaque_rect->nWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, opaque_rect->nHeight);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tbyte = opaque_rect->color & 0x000000FF;\n\tStream_Write_UINT8(s, byte);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tbyte = (opaque_rect->color & 0x0000FF00) >> 8;\n\tStream_Write_UINT8(s, byte);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tbyte = (opaque_rect->color & 0x00FF0000) >> 16;\n\tStream_Write_UINT8(s, byte);\n\treturn TRUE;\n}\nstatic BOOL update_read_draw_nine_grid_order(wStream* s, const ORDER_INFO* orderInfo,\n                                             DRAW_NINE_GRID_ORDER* draw_nine_grid)\n{\n\tORDER_FIELD_COORD(1, draw_nine_grid->srcLeft);\n\tORDER_FIELD_COORD(2, draw_nine_grid->srcTop);\n\tORDER_FIELD_COORD(3, draw_nine_grid->srcRight);\n\tORDER_FIELD_COORD(4, draw_nine_grid->srcBottom);\n\tORDER_FIELD_UINT16(5, draw_nine_grid->bitmapId);\n\treturn TRUE;\n}\nstatic BOOL update_read_multi_dstblt_order(wStream* s, const ORDER_INFO* orderInfo,\n                                           MULTI_DSTBLT_ORDER* multi_dstblt)\n{\n\tORDER_FIELD_COORD(1, multi_dstblt->nLeftRect);\n\tORDER_FIELD_COORD(2, multi_dstblt->nTopRect);\n\tORDER_FIELD_COORD(3, multi_dstblt->nWidth);\n\tORDER_FIELD_COORD(4, multi_dstblt->nHeight);\n\tORDER_FIELD_BYTE(5, multi_dstblt->bRop);\n\tORDER_FIELD_BYTE(6, multi_dstblt->numRectangles);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, multi_dstblt->cbData);\n\t\treturn update_read_delta_rects(s, multi_dstblt->rectangles, &multi_dstblt->numRectangles);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_multi_patblt_order(wStream* s, const ORDER_INFO* orderInfo,\n                                           MULTI_PATBLT_ORDER* multi_patblt)\n{\n\tORDER_FIELD_COORD(1, multi_patblt->nLeftRect);\n\tORDER_FIELD_COORD(2, multi_patblt->nTopRect);\n\tORDER_FIELD_COORD(3, multi_patblt->nWidth);\n\tORDER_FIELD_COORD(4, multi_patblt->nHeight);\n\tORDER_FIELD_BYTE(5, multi_patblt->bRop);\n\tORDER_FIELD_COLOR(orderInfo, s, 6, &multi_patblt->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 7, &multi_patblt->foreColor);\n\n\tif (!update_read_brush(s, &multi_patblt->brush, orderInfo->fieldFlags >> 7))\n\t\treturn FALSE;\n\n\tORDER_FIELD_BYTE(13, multi_patblt->numRectangles);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_14)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, multi_patblt->cbData);\n\n\t\tif (!update_read_delta_rects(s, multi_patblt->rectangles, &multi_patblt->numRectangles))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_multi_scrblt_order(wStream* s, const ORDER_INFO* orderInfo,\n                                           MULTI_SCRBLT_ORDER* multi_scrblt)\n{\n\tORDER_FIELD_COORD(1, multi_scrblt->nLeftRect);\n\tORDER_FIELD_COORD(2, multi_scrblt->nTopRect);\n\tORDER_FIELD_COORD(3, multi_scrblt->nWidth);\n\tORDER_FIELD_COORD(4, multi_scrblt->nHeight);\n\tORDER_FIELD_BYTE(5, multi_scrblt->bRop);\n\tORDER_FIELD_COORD(6, multi_scrblt->nXSrc);\n\tORDER_FIELD_COORD(7, multi_scrblt->nYSrc);\n\tORDER_FIELD_BYTE(8, multi_scrblt->numRectangles);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_09)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, multi_scrblt->cbData);\n\t\treturn update_read_delta_rects(s, multi_scrblt->rectangles, &multi_scrblt->numRectangles);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_multi_opaque_rect_order(wStream* s, const ORDER_INFO* orderInfo,\n                                                MULTI_OPAQUE_RECT_ORDER* multi_opaque_rect)\n{\n\tBYTE byte;\n\tORDER_FIELD_COORD(1, multi_opaque_rect->nLeftRect);\n\tORDER_FIELD_COORD(2, multi_opaque_rect->nTopRect);\n\tORDER_FIELD_COORD(3, multi_opaque_rect->nWidth);\n\tORDER_FIELD_COORD(4, multi_opaque_rect->nHeight);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\tmulti_opaque_rect->color = (multi_opaque_rect->color & 0x00FFFF00) | ((UINT32)byte);\n\t}\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_06)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\tmulti_opaque_rect->color = (multi_opaque_rect->color & 0x00FF00FF) | ((UINT32)byte << 8);\n\t}\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\tmulti_opaque_rect->color = (multi_opaque_rect->color & 0x0000FFFF) | ((UINT32)byte << 16);\n\t}\n\n\tORDER_FIELD_BYTE(8, multi_opaque_rect->numRectangles);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_09)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, multi_opaque_rect->cbData);\n\t\treturn update_read_delta_rects(s, multi_opaque_rect->rectangles,\n\t\t                               &multi_opaque_rect->numRectangles);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_multi_draw_nine_grid_order(wStream* s, const ORDER_INFO* orderInfo,\n                                                   MULTI_DRAW_NINE_GRID_ORDER* multi_draw_nine_grid)\n{\n\tORDER_FIELD_COORD(1, multi_draw_nine_grid->srcLeft);\n\tORDER_FIELD_COORD(2, multi_draw_nine_grid->srcTop);\n\tORDER_FIELD_COORD(3, multi_draw_nine_grid->srcRight);\n\tORDER_FIELD_COORD(4, multi_draw_nine_grid->srcBottom);\n\tORDER_FIELD_UINT16(5, multi_draw_nine_grid->bitmapId);\n\tORDER_FIELD_BYTE(6, multi_draw_nine_grid->nDeltaEntries);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, multi_draw_nine_grid->cbData);\n\t\treturn update_read_delta_rects(s, multi_draw_nine_grid->rectangles,\n\t\t                               &multi_draw_nine_grid->nDeltaEntries);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_line_to_order(wStream* s, const ORDER_INFO* orderInfo,\n                                      LINE_TO_ORDER* line_to)\n{\n\tORDER_FIELD_UINT16(1, line_to->backMode);\n\tORDER_FIELD_COORD(2, line_to->nXStart);\n\tORDER_FIELD_COORD(3, line_to->nYStart);\n\tORDER_FIELD_COORD(4, line_to->nXEnd);\n\tORDER_FIELD_COORD(5, line_to->nYEnd);\n\tORDER_FIELD_COLOR(orderInfo, s, 6, &line_to->backColor);\n\tORDER_FIELD_BYTE(7, line_to->bRop2);\n\tORDER_FIELD_BYTE(8, line_to->penStyle);\n\tORDER_FIELD_BYTE(9, line_to->penWidth);\n\tORDER_FIELD_COLOR(orderInfo, s, 10, &line_to->penColor);\n\treturn TRUE;\n}\nint update_approximate_line_to_order(ORDER_INFO* orderInfo, const LINE_TO_ORDER* line_to)\n{\n\treturn 32;\n}\nBOOL update_write_line_to_order(wStream* s, ORDER_INFO* orderInfo, const LINE_TO_ORDER* line_to)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, update_approximate_line_to_order(orderInfo, line_to)))\n\t\treturn FALSE;\n\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tStream_Write_UINT16(s, line_to->backMode);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, line_to->nXStart);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, line_to->nYStart);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, line_to->nXEnd);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tupdate_write_coord(s, line_to->nYEnd);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tupdate_write_color(s, line_to->backColor);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tStream_Write_UINT8(s, line_to->bRop2);\n\torderInfo->fieldFlags |= ORDER_FIELD_08;\n\tStream_Write_UINT8(s, line_to->penStyle);\n\torderInfo->fieldFlags |= ORDER_FIELD_09;\n\tStream_Write_UINT8(s, line_to->penWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_10;\n\tupdate_write_color(s, line_to->penColor);\n\treturn TRUE;\n}\nstatic BOOL update_read_polyline_order(wStream* s, const ORDER_INFO* orderInfo,\n                                       POLYLINE_ORDER* polyline)\n{\n\tUINT16 word;\n\tUINT32 new_num = polyline->numDeltaEntries;\n\tORDER_FIELD_COORD(1, polyline->xStart);\n\tORDER_FIELD_COORD(2, polyline->yStart);\n\tORDER_FIELD_BYTE(3, polyline->bRop2);\n\tORDER_FIELD_UINT16(4, word);\n\tORDER_FIELD_COLOR(orderInfo, s, 5, &polyline->penColor);\n\tORDER_FIELD_BYTE(6, new_num);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tDELTA_POINT* new_points;\n\n\t\tif (new_num == 0)\n\t\t\treturn FALSE;\n\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 1\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tStream_Read_UINT8(s, polyline->cbData);\n\t\tnew_points = (DELTA_POINT*)realloc(polyline->points, sizeof(DELTA_POINT) * new_num);\n\n\t\tif (!new_points)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"realloc(%\" PRIu32 \") failed\", new_num);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tpolyline->points = new_points;\n\t\tpolyline->numDeltaEntries = new_num;\n\t\treturn update_read_delta_points(s, polyline->points, polyline->numDeltaEntries,\n\t\t                                polyline->xStart, polyline->yStart);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_memblt_order(wStream* s, const ORDER_INFO* orderInfo, MEMBLT_ORDER* memblt)\n{\n\tif (!s || !orderInfo || !memblt)\n\t\treturn FALSE;\n\n\tORDER_FIELD_UINT16(1, memblt->cacheId);\n\tORDER_FIELD_COORD(2, memblt->nLeftRect);\n\tORDER_FIELD_COORD(3, memblt->nTopRect);\n\tORDER_FIELD_COORD(4, memblt->nWidth);\n\tORDER_FIELD_COORD(5, memblt->nHeight);\n\tORDER_FIELD_BYTE(6, memblt->bRop);\n\tORDER_FIELD_COORD(7, memblt->nXSrc);\n\tORDER_FIELD_COORD(8, memblt->nYSrc);\n\tORDER_FIELD_UINT16(9, memblt->cacheIndex);\n\tmemblt->colorIndex = (memblt->cacheId >> 8);\n\tmemblt->cacheId = (memblt->cacheId & 0xFF);\n\tmemblt->bitmap = NULL;\n\treturn TRUE;\n}\nint update_approximate_memblt_order(ORDER_INFO* orderInfo, const MEMBLT_ORDER* memblt)\n{\n\treturn 64;\n}\nBOOL update_write_memblt_order(wStream* s, ORDER_INFO* orderInfo, const MEMBLT_ORDER* memblt)\n{\n\tUINT16 cacheId;\n\n\tif (!Stream_EnsureRemainingCapacity(s, update_approximate_memblt_order(orderInfo, memblt)))\n\t\treturn FALSE;\n\n\tcacheId = (memblt->cacheId & 0xFF) | ((memblt->colorIndex & 0xFF) << 8);\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tStream_Write_UINT16(s, cacheId);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, memblt->nLeftRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, memblt->nTopRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, memblt->nWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tupdate_write_coord(s, memblt->nHeight);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tStream_Write_UINT8(s, memblt->bRop);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tupdate_write_coord(s, memblt->nXSrc);\n\torderInfo->fieldFlags |= ORDER_FIELD_08;\n\tupdate_write_coord(s, memblt->nYSrc);\n\torderInfo->fieldFlags |= ORDER_FIELD_09;\n\tStream_Write_UINT16(s, memblt->cacheIndex);\n\treturn TRUE;\n}\nstatic BOOL update_read_mem3blt_order(wStream* s, const ORDER_INFO* orderInfo,\n                                      MEM3BLT_ORDER* mem3blt)\n{\n\tORDER_FIELD_UINT16(1, mem3blt->cacheId);\n\tORDER_FIELD_COORD(2, mem3blt->nLeftRect);\n\tORDER_FIELD_COORD(3, mem3blt->nTopRect);\n\tORDER_FIELD_COORD(4, mem3blt->nWidth);\n\tORDER_FIELD_COORD(5, mem3blt->nHeight);\n\tORDER_FIELD_BYTE(6, mem3blt->bRop);\n\tORDER_FIELD_COORD(7, mem3blt->nXSrc);\n\tORDER_FIELD_COORD(8, mem3blt->nYSrc);\n\tORDER_FIELD_COLOR(orderInfo, s, 9, &mem3blt->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 10, &mem3blt->foreColor);\n\n\tif (!update_read_brush(s, &mem3blt->brush, orderInfo->fieldFlags >> 10))\n\t\treturn FALSE;\n\n\tORDER_FIELD_UINT16(16, mem3blt->cacheIndex);\n\tmem3blt->colorIndex = (mem3blt->cacheId >> 8);\n\tmem3blt->cacheId = (mem3blt->cacheId & 0xFF);\n\tmem3blt->bitmap = NULL;\n\treturn TRUE;\n}\nstatic BOOL update_read_save_bitmap_order(wStream* s, const ORDER_INFO* orderInfo,\n                                          SAVE_BITMAP_ORDER* save_bitmap)\n{\n\tORDER_FIELD_UINT32(1, save_bitmap->savedBitmapPosition);\n\tORDER_FIELD_COORD(2, save_bitmap->nLeftRect);\n\tORDER_FIELD_COORD(3, save_bitmap->nTopRect);\n\tORDER_FIELD_COORD(4, save_bitmap->nRightRect);\n\tORDER_FIELD_COORD(5, save_bitmap->nBottomRect);\n\tORDER_FIELD_BYTE(6, save_bitmap->operation);\n\treturn TRUE;\n}\nstatic BOOL update_read_glyph_index_order(wStream* s, const ORDER_INFO* orderInfo,\n                                          GLYPH_INDEX_ORDER* glyph_index)\n{\n\tORDER_FIELD_BYTE(1, glyph_index->cacheId);\n\tORDER_FIELD_BYTE(2, glyph_index->flAccel);\n\tORDER_FIELD_BYTE(3, glyph_index->ulCharInc);\n\tORDER_FIELD_BYTE(4, glyph_index->fOpRedundant);\n\tORDER_FIELD_COLOR(orderInfo, s, 5, &glyph_index->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 6, &glyph_index->foreColor);\n\tORDER_FIELD_UINT16(7, glyph_index->bkLeft);\n\tORDER_FIELD_UINT16(8, glyph_index->bkTop);\n\tORDER_FIELD_UINT16(9, glyph_index->bkRight);\n\tORDER_FIELD_UINT16(10, glyph_index->bkBottom);\n\tORDER_FIELD_UINT16(11, glyph_index->opLeft);\n\tORDER_FIELD_UINT16(12, glyph_index->opTop);\n\tORDER_FIELD_UINT16(13, glyph_index->opRight);\n\tORDER_FIELD_UINT16(14, glyph_index->opBottom);\n\n\tif (!update_read_brush(s, &glyph_index->brush, orderInfo->fieldFlags >> 14))\n\t\treturn FALSE;\n\n\tORDER_FIELD_UINT16(20, glyph_index->x);\n\tORDER_FIELD_UINT16(21, glyph_index->y);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_22)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, glyph_index->cbData);\n\n\t\tif (Stream_GetRemainingLength(s) < glyph_index->cbData)\n\t\t\treturn FALSE;\n\n\t\tCopyMemory(glyph_index->data, Stream_Pointer(s), glyph_index->cbData);\n\t\tStream_Seek(s, glyph_index->cbData);\n\t}\n\n\treturn TRUE;\n}\nint update_approximate_glyph_index_order(ORDER_INFO* orderInfo,\n                                         const GLYPH_INDEX_ORDER* glyph_index)\n{\n\treturn 64;\n}\nBOOL update_write_glyph_index_order(wStream* s, ORDER_INFO* orderInfo,\n                                    GLYPH_INDEX_ORDER* glyph_index)\n{\n\tint inf = update_approximate_glyph_index_order(orderInfo, glyph_index);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tStream_Write_UINT8(s, glyph_index->cacheId);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tStream_Write_UINT8(s, glyph_index->flAccel);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tStream_Write_UINT8(s, glyph_index->ulCharInc);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tStream_Write_UINT8(s, glyph_index->fOpRedundant);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tupdate_write_color(s, glyph_index->backColor);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tupdate_write_color(s, glyph_index->foreColor);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tStream_Write_UINT16(s, glyph_index->bkLeft);\n\torderInfo->fieldFlags |= ORDER_FIELD_08;\n\tStream_Write_UINT16(s, glyph_index->bkTop);\n\torderInfo->fieldFlags |= ORDER_FIELD_09;\n\tStream_Write_UINT16(s, glyph_index->bkRight);\n\torderInfo->fieldFlags |= ORDER_FIELD_10;\n\tStream_Write_UINT16(s, glyph_index->bkBottom);\n\torderInfo->fieldFlags |= ORDER_FIELD_11;\n\tStream_Write_UINT16(s, glyph_index->opLeft);\n\torderInfo->fieldFlags |= ORDER_FIELD_12;\n\tStream_Write_UINT16(s, glyph_index->opTop);\n\torderInfo->fieldFlags |= ORDER_FIELD_13;\n\tStream_Write_UINT16(s, glyph_index->opRight);\n\torderInfo->fieldFlags |= ORDER_FIELD_14;\n\tStream_Write_UINT16(s, glyph_index->opBottom);\n\torderInfo->fieldFlags |= ORDER_FIELD_15;\n\torderInfo->fieldFlags |= ORDER_FIELD_16;\n\torderInfo->fieldFlags |= ORDER_FIELD_17;\n\torderInfo->fieldFlags |= ORDER_FIELD_18;\n\torderInfo->fieldFlags |= ORDER_FIELD_19;\n\tupdate_write_brush(s, &glyph_index->brush, orderInfo->fieldFlags >> 14);\n\torderInfo->fieldFlags |= ORDER_FIELD_20;\n\tStream_Write_UINT16(s, glyph_index->x);\n\torderInfo->fieldFlags |= ORDER_FIELD_21;\n\tStream_Write_UINT16(s, glyph_index->y);\n\torderInfo->fieldFlags |= ORDER_FIELD_22;\n\tStream_Write_UINT8(s, glyph_index->cbData);\n\tStream_Write(s, glyph_index->data, glyph_index->cbData);\n\treturn TRUE;\n}\nstatic BOOL update_read_fast_index_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         FAST_INDEX_ORDER* fast_index)\n{\n\tORDER_FIELD_BYTE(1, fast_index->cacheId);\n\tORDER_FIELD_2BYTE(2, fast_index->ulCharInc, fast_index->flAccel);\n\tORDER_FIELD_COLOR(orderInfo, s, 3, &fast_index->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 4, &fast_index->foreColor);\n\tORDER_FIELD_COORD(5, fast_index->bkLeft);\n\tORDER_FIELD_COORD(6, fast_index->bkTop);\n\tORDER_FIELD_COORD(7, fast_index->bkRight);\n\tORDER_FIELD_COORD(8, fast_index->bkBottom);\n\tORDER_FIELD_COORD(9, fast_index->opLeft);\n\tORDER_FIELD_COORD(10, fast_index->opTop);\n\tORDER_FIELD_COORD(11, fast_index->opRight);\n\tORDER_FIELD_COORD(12, fast_index->opBottom);\n\tORDER_FIELD_COORD(13, fast_index->x);\n\tORDER_FIELD_COORD(14, fast_index->y);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_15)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, fast_index->cbData);\n\n\t\tif (Stream_GetRemainingLength(s) < fast_index->cbData)\n\t\t\treturn FALSE;\n\n\t\tCopyMemory(fast_index->data, Stream_Pointer(s), fast_index->cbData);\n\t\tStream_Seek(s, fast_index->cbData);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_fast_glyph_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         FAST_GLYPH_ORDER* fastGlyph)\n{\n\tGLYPH_DATA_V2* glyph = &fastGlyph->glyphData;\n\tORDER_FIELD_BYTE(1, fastGlyph->cacheId);\n\tORDER_FIELD_2BYTE(2, fastGlyph->ulCharInc, fastGlyph->flAccel);\n\tORDER_FIELD_COLOR(orderInfo, s, 3, &fastGlyph->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 4, &fastGlyph->foreColor);\n\tORDER_FIELD_COORD(5, fastGlyph->bkLeft);\n\tORDER_FIELD_COORD(6, fastGlyph->bkTop);\n\tORDER_FIELD_COORD(7, fastGlyph->bkRight);\n\tORDER_FIELD_COORD(8, fastGlyph->bkBottom);\n\tORDER_FIELD_COORD(9, fastGlyph->opLeft);\n\tORDER_FIELD_COORD(10, fastGlyph->opTop);\n\tORDER_FIELD_COORD(11, fastGlyph->opRight);\n\tORDER_FIELD_COORD(12, fastGlyph->opBottom);\n\tORDER_FIELD_COORD(13, fastGlyph->x);\n\tORDER_FIELD_COORD(14, fastGlyph->y);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_15)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, fastGlyph->cbData);\n\n\t\tif (Stream_GetRemainingLength(s) < fastGlyph->cbData)\n\t\t\treturn FALSE;\n\n\t\tCopyMemory(fastGlyph->data, Stream_Pointer(s), fastGlyph->cbData);\n\t\tif (Stream_GetRemainingLength(s) < fastGlyph->cbData)\n\t\t\treturn FALSE;\n\n\t\tif (!Stream_SafeSeek(s, 1))\n\t\t\treturn FALSE;\n\n\t\tif (fastGlyph->cbData > 1)\n\t\t{\n\t\t\tUINT32 new_cb;\n\t\t\t/* parse optional glyph data */\n\t\t\tglyph->cacheIndex = fastGlyph->data[0];\n\n\t\t\tif (!update_read_2byte_signed(s, &glyph->x) ||\n\t\t\t    !update_read_2byte_signed(s, &glyph->y) ||\n\t\t\t    !update_read_2byte_unsigned(s, &glyph->cx) ||\n\t\t\t    !update_read_2byte_unsigned(s, &glyph->cy))\n\t\t\t\treturn FALSE;\n\n\t\t\tglyph->cb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\t\tglyph->cb += ((glyph->cb % 4) > 0) ? 4 - (glyph->cb % 4) : 0;\n\t\t\tnew_cb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\t\tnew_cb += ((new_cb % 4) > 0) ? 4 - (new_cb % 4) : 0;\n\n\t\t\tif (fastGlyph->cbData < new_cb)\n\t\t\t\treturn FALSE;\n\n\t\t\tif (new_cb > 0)\n\t\t\t{\n\t\t\t\tBYTE* new_aj;\n\t\t\t\tnew_aj = (BYTE*)realloc(glyph->aj, new_cb);\n\n\t\t\t\tif (!new_aj)\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tglyph->aj = new_aj;\n\t\t\t\tglyph->cb = new_cb;\n\t\t\t\tStream_Read(s, glyph->aj, glyph->cb);\n\t\t\t}\n\t\t\tStream_Seek(s, fastGlyph->cbData - new_cb);\n\t\t}\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_polygon_sc_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         POLYGON_SC_ORDER* polygon_sc)\n{\n\tUINT32 num = polygon_sc->numPoints;\n\tORDER_FIELD_COORD(1, polygon_sc->xStart);\n\tORDER_FIELD_COORD(2, polygon_sc->yStart);\n\tORDER_FIELD_BYTE(3, polygon_sc->bRop2);\n\tORDER_FIELD_BYTE(4, polygon_sc->fillMode);\n\tORDER_FIELD_COLOR(orderInfo, s, 5, &polygon_sc->brushColor);\n\tORDER_FIELD_BYTE(6, num);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tDELTA_POINT* newpoints;\n\n\t\tif (num == 0)\n\t\t\treturn FALSE;\n\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, polygon_sc->cbData);\n\t\tnewpoints = (DELTA_POINT*)realloc(polygon_sc->points, sizeof(DELTA_POINT) * num);\n\n\t\tif (!newpoints)\n\t\t\treturn FALSE;\n\n\t\tpolygon_sc->points = newpoints;\n\t\tpolygon_sc->numPoints = num;\n\t\treturn update_read_delta_points(s, polygon_sc->points, polygon_sc->numPoints,\n\t\t                                polygon_sc->xStart, polygon_sc->yStart);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_polygon_cb_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         POLYGON_CB_ORDER* polygon_cb)\n{\n\tUINT32 num = polygon_cb->numPoints;\n\tORDER_FIELD_COORD(1, polygon_cb->xStart);\n\tORDER_FIELD_COORD(2, polygon_cb->yStart);\n\tORDER_FIELD_BYTE(3, polygon_cb->bRop2);\n\tORDER_FIELD_BYTE(4, polygon_cb->fillMode);\n\tORDER_FIELD_COLOR(orderInfo, s, 5, &polygon_cb->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 6, &polygon_cb->foreColor);\n\n\tif (!update_read_brush(s, &polygon_cb->brush, orderInfo->fieldFlags >> 6))\n\t\treturn FALSE;\n\n\tORDER_FIELD_BYTE(12, num);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_13)\n\t{\n\t\tDELTA_POINT* newpoints;\n\n\t\tif (num == 0)\n\t\t\treturn FALSE;\n\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, polygon_cb->cbData);\n\t\tnewpoints = (DELTA_POINT*)realloc(polygon_cb->points, sizeof(DELTA_POINT) * num);\n\n\t\tif (!newpoints)\n\t\t\treturn FALSE;\n\n\t\tpolygon_cb->points = newpoints;\n\t\tpolygon_cb->numPoints = num;\n\n\t\tif (!update_read_delta_points(s, polygon_cb->points, polygon_cb->numPoints,\n\t\t                              polygon_cb->xStart, polygon_cb->yStart))\n\t\t\treturn FALSE;\n\t}\n\n\tpolygon_cb->backMode = (polygon_cb->bRop2 & 0x80) ? BACKMODE_TRANSPARENT : BACKMODE_OPAQUE;\n\tpolygon_cb->bRop2 = (polygon_cb->bRop2 & 0x1F);\n\treturn TRUE;\n}\nstatic BOOL update_read_ellipse_sc_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         ELLIPSE_SC_ORDER* ellipse_sc)\n{\n\tORDER_FIELD_COORD(1, ellipse_sc->leftRect);\n\tORDER_FIELD_COORD(2, ellipse_sc->topRect);\n\tORDER_FIELD_COORD(3, ellipse_sc->rightRect);\n\tORDER_FIELD_COORD(4, ellipse_sc->bottomRect);\n\tORDER_FIELD_BYTE(5, ellipse_sc->bRop2);\n\tORDER_FIELD_BYTE(6, ellipse_sc->fillMode);\n\tORDER_FIELD_COLOR(orderInfo, s, 7, &ellipse_sc->color);\n\treturn TRUE;\n}\nstatic BOOL update_read_ellipse_cb_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         ELLIPSE_CB_ORDER* ellipse_cb)\n{\n\tORDER_FIELD_COORD(1, ellipse_cb->leftRect);\n\tORDER_FIELD_COORD(2, ellipse_cb->topRect);\n\tORDER_FIELD_COORD(3, ellipse_cb->rightRect);\n\tORDER_FIELD_COORD(4, ellipse_cb->bottomRect);\n\tORDER_FIELD_BYTE(5, ellipse_cb->bRop2);\n\tORDER_FIELD_BYTE(6, ellipse_cb->fillMode);\n\tORDER_FIELD_COLOR(orderInfo, s, 7, &ellipse_cb->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 8, &ellipse_cb->foreColor);\n\treturn update_read_brush(s, &ellipse_cb->brush, orderInfo->fieldFlags >> 8);\n}\n/* Secondary Drawing Orders */\nstatic CACHE_BITMAP_ORDER* update_read_cache_bitmap_order(rdpUpdate* update, wStream* s,\n                                                          BOOL compressed, UINT16 flags)\n{\n\tCACHE_BITMAP_ORDER* cache_bitmap;\n\n\tif (!update || !s)\n\t\treturn NULL;\n\n\tcache_bitmap = calloc(1, sizeof(CACHE_BITMAP_ORDER));\n\n\tif (!cache_bitmap)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 9)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_bitmap->cacheId);      /* cacheId (1 byte) */\n\tStream_Seek_UINT8(s);                             /* pad1Octet (1 byte) */\n\tStream_Read_UINT8(s, cache_bitmap->bitmapWidth);  /* bitmapWidth (1 byte) */\n\tStream_Read_UINT8(s, cache_bitmap->bitmapHeight); /* bitmapHeight (1 byte) */\n\tStream_Read_UINT8(s, cache_bitmap->bitmapBpp);    /* bitmapBpp (1 byte) */\n\n\tif ((cache_bitmap->bitmapBpp < 1) || (cache_bitmap->bitmapBpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bitmap bpp %\" PRIu32 \"\",\n\t\t           cache_bitmap->bitmapBpp);\n\t\tgoto fail;\n\t}\n\n\tStream_Read_UINT16(s, cache_bitmap->bitmapLength); /* bitmapLength (2 bytes) */\n\tStream_Read_UINT16(s, cache_bitmap->cacheIndex);   /* cacheIndex (2 bytes) */\n\n\tif (compressed)\n\t{\n\t\tif ((flags & NO_BITMAP_COMPRESSION_HDR) == 0)\n\t\t{\n\t\t\tBYTE* bitmapComprHdr = (BYTE*)&(cache_bitmap->bitmapComprHdr);\n\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\tgoto fail;\n\n\t\t\tStream_Read(s, bitmapComprHdr, 8); /* bitmapComprHdr (8 bytes) */\n\t\t\tcache_bitmap->bitmapLength -= 8;\n\t\t}\n\t}\n\n\tif (cache_bitmap->bitmapLength == 0)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < cache_bitmap->bitmapLength)\n\t\tgoto fail;\n\n\tcache_bitmap->bitmapDataStream = malloc(cache_bitmap->bitmapLength);\n\n\tif (!cache_bitmap->bitmapDataStream)\n\t\tgoto fail;\n\n\tStream_Read(s, cache_bitmap->bitmapDataStream, cache_bitmap->bitmapLength);\n\tcache_bitmap->compressed = compressed;\n\treturn cache_bitmap;\nfail:\n\tfree_cache_bitmap_order(update->context, cache_bitmap);\n\treturn NULL;\n}\nint update_approximate_cache_bitmap_order(const CACHE_BITMAP_ORDER* cache_bitmap, BOOL compressed,\n                                          UINT16* flags)\n{\n\treturn 64 + cache_bitmap->bitmapLength;\n}\nBOOL update_write_cache_bitmap_order(wStream* s, const CACHE_BITMAP_ORDER* cache_bitmap,\n                                     BOOL compressed, UINT16* flags)\n{\n\tUINT32 bitmapLength = cache_bitmap->bitmapLength;\n\tint inf = update_approximate_cache_bitmap_order(cache_bitmap, compressed, flags);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\t*flags = NO_BITMAP_COMPRESSION_HDR;\n\n\tif ((*flags & NO_BITMAP_COMPRESSION_HDR) == 0)\n\t\tbitmapLength += 8;\n\n\tStream_Write_UINT8(s, cache_bitmap->cacheId);      /* cacheId (1 byte) */\n\tStream_Write_UINT8(s, 0);                          /* pad1Octet (1 byte) */\n\tStream_Write_UINT8(s, cache_bitmap->bitmapWidth);  /* bitmapWidth (1 byte) */\n\tStream_Write_UINT8(s, cache_bitmap->bitmapHeight); /* bitmapHeight (1 byte) */\n\tStream_Write_UINT8(s, cache_bitmap->bitmapBpp);    /* bitmapBpp (1 byte) */\n\tStream_Write_UINT16(s, bitmapLength);              /* bitmapLength (2 bytes) */\n\tStream_Write_UINT16(s, cache_bitmap->cacheIndex);  /* cacheIndex (2 bytes) */\n\n\tif (compressed)\n\t{\n\t\tif ((*flags & NO_BITMAP_COMPRESSION_HDR) == 0)\n\t\t{\n\t\t\tBYTE* bitmapComprHdr = (BYTE*)&(cache_bitmap->bitmapComprHdr);\n\t\t\tStream_Write(s, bitmapComprHdr, 8); /* bitmapComprHdr (8 bytes) */\n\t\t\tbitmapLength -= 8;\n\t\t}\n\n\t\tStream_Write(s, cache_bitmap->bitmapDataStream, bitmapLength);\n\t}\n\telse\n\t{\n\t\tStream_Write(s, cache_bitmap->bitmapDataStream, bitmapLength);\n\t}\n\n\treturn TRUE;\n}\nstatic CACHE_BITMAP_V2_ORDER* update_read_cache_bitmap_v2_order(rdpUpdate* update, wStream* s,\n                                                                BOOL compressed, UINT16 flags)\n{\n\tBYTE bitsPerPixelId;\n\tCACHE_BITMAP_V2_ORDER* cache_bitmap_v2;\n\n\tif (!update || !s)\n\t\treturn NULL;\n\n\tcache_bitmap_v2 = calloc(1, sizeof(CACHE_BITMAP_V2_ORDER));\n\n\tif (!cache_bitmap_v2)\n\t\tgoto fail;\n\n\tcache_bitmap_v2->cacheId = flags & 0x0003;\n\tcache_bitmap_v2->flags = (flags & 0xFF80) >> 7;\n\tbitsPerPixelId = (flags & 0x0078) >> 3;\n\tcache_bitmap_v2->bitmapBpp = CBR2_BPP[bitsPerPixelId];\n\n\tif (cache_bitmap_v2->flags & CBR2_PERSISTENT_KEY_PRESENT)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UINT32(s, cache_bitmap_v2->key1); /* key1 (4 bytes) */\n\t\tStream_Read_UINT32(s, cache_bitmap_v2->key2); /* key2 (4 bytes) */\n\t}\n\n\tif (cache_bitmap_v2->flags & CBR2_HEIGHT_SAME_AS_WIDTH)\n\t{\n\t\tif (!update_read_2byte_unsigned(s, &cache_bitmap_v2->bitmapWidth)) /* bitmapWidth */\n\t\t\tgoto fail;\n\n\t\tcache_bitmap_v2->bitmapHeight = cache_bitmap_v2->bitmapWidth;\n\t}\n\telse\n\t{\n\t\tif (!update_read_2byte_unsigned(s, &cache_bitmap_v2->bitmapWidth) || /* bitmapWidth */\n\t\t    !update_read_2byte_unsigned(s, &cache_bitmap_v2->bitmapHeight))  /* bitmapHeight */\n\t\t\tgoto fail;\n\t}\n\n\tif (!update_read_4byte_unsigned(s, &cache_bitmap_v2->bitmapLength) || /* bitmapLength */\n\t    !update_read_2byte_unsigned(s, &cache_bitmap_v2->cacheIndex))     /* cacheIndex */\n\t\tgoto fail;\n\n\tif (cache_bitmap_v2->flags & CBR2_DO_NOT_CACHE)\n\t\tcache_bitmap_v2->cacheIndex = BITMAP_CACHE_WAITING_LIST_INDEX;\n\n\tif (compressed)\n\t{\n\t\tif (!(cache_bitmap_v2->flags & CBR2_NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\tgoto fail;\n\n\t\t\tStream_Read_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Read_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompMainBodySize);         /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Read_UINT16(s, cache_bitmap_v2->cbScanWidth); /* cbScanWidth (2 bytes) */\n\t\t\tStream_Read_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t\tcache_bitmap_v2->bitmapLength = cache_bitmap_v2->cbCompMainBodySize;\n\t\t}\n\t}\n\n\tif (cache_bitmap_v2->bitmapLength == 0)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < cache_bitmap_v2->bitmapLength)\n\t\tgoto fail;\n\n\tif (cache_bitmap_v2->bitmapLength == 0)\n\t\tgoto fail;\n\n\tcache_bitmap_v2->bitmapDataStream = malloc(cache_bitmap_v2->bitmapLength);\n\n\tif (!cache_bitmap_v2->bitmapDataStream)\n\t\tgoto fail;\n\n\tStream_Read(s, cache_bitmap_v2->bitmapDataStream, cache_bitmap_v2->bitmapLength);\n\tcache_bitmap_v2->compressed = compressed;\n\treturn cache_bitmap_v2;\nfail:\n\tfree_cache_bitmap_v2_order(update->context, cache_bitmap_v2);\n\treturn NULL;\n}\nint update_approximate_cache_bitmap_v2_order(CACHE_BITMAP_V2_ORDER* cache_bitmap_v2,\n                                             BOOL compressed, UINT16* flags)\n{\n\treturn 64 + cache_bitmap_v2->bitmapLength;\n}\nBOOL update_write_cache_bitmap_v2_order(wStream* s, CACHE_BITMAP_V2_ORDER* cache_bitmap_v2,\n                                        BOOL compressed, UINT16* flags)\n{\n\tBYTE bitsPerPixelId;\n\n\tif (!Stream_EnsureRemainingCapacity(\n\t        s, update_approximate_cache_bitmap_v2_order(cache_bitmap_v2, compressed, flags)))\n\t\treturn FALSE;\n\n\tbitsPerPixelId = BPP_CBR2[cache_bitmap_v2->bitmapBpp];\n\t*flags = (cache_bitmap_v2->cacheId & 0x0003) | (bitsPerPixelId << 3) |\n\t         ((cache_bitmap_v2->flags << 7) & 0xFF80);\n\n\tif (cache_bitmap_v2->flags & CBR2_PERSISTENT_KEY_PRESENT)\n\t{\n\t\tStream_Write_UINT32(s, cache_bitmap_v2->key1); /* key1 (4 bytes) */\n\t\tStream_Write_UINT32(s, cache_bitmap_v2->key2); /* key2 (4 bytes) */\n\t}\n\n\tif (cache_bitmap_v2->flags & CBR2_HEIGHT_SAME_AS_WIDTH)\n\t{\n\t\tif (!update_write_2byte_unsigned(s, cache_bitmap_v2->bitmapWidth)) /* bitmapWidth */\n\t\t\treturn FALSE;\n\t}\n\telse\n\t{\n\t\tif (!update_write_2byte_unsigned(s, cache_bitmap_v2->bitmapWidth) || /* bitmapWidth */\n\t\t    !update_write_2byte_unsigned(s, cache_bitmap_v2->bitmapHeight))  /* bitmapHeight */\n\t\t\treturn FALSE;\n\t}\n\n\tif (cache_bitmap_v2->flags & CBR2_DO_NOT_CACHE)\n\t\tcache_bitmap_v2->cacheIndex = BITMAP_CACHE_WAITING_LIST_INDEX;\n\n\tif (!update_write_4byte_unsigned(s, cache_bitmap_v2->bitmapLength) || /* bitmapLength */\n\t    !update_write_2byte_unsigned(s, cache_bitmap_v2->cacheIndex))     /* cacheIndex */\n\t\treturn FALSE;\n\n\tif (compressed)\n\t{\n\t\tif (!(cache_bitmap_v2->flags & CBR2_NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tStream_Write_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Write_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompMainBodySize);          /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Write_UINT16(s, cache_bitmap_v2->cbScanWidth); /* cbScanWidth (2 bytes) */\n\t\t\tStream_Write_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t\tcache_bitmap_v2->bitmapLength = cache_bitmap_v2->cbCompMainBodySize;\n\t\t}\n\n\t\tif (!Stream_EnsureRemainingCapacity(s, cache_bitmap_v2->bitmapLength))\n\t\t\treturn FALSE;\n\n\t\tStream_Write(s, cache_bitmap_v2->bitmapDataStream, cache_bitmap_v2->bitmapLength);\n\t}\n\telse\n\t{\n\t\tif (!Stream_EnsureRemainingCapacity(s, cache_bitmap_v2->bitmapLength))\n\t\t\treturn FALSE;\n\n\t\tStream_Write(s, cache_bitmap_v2->bitmapDataStream, cache_bitmap_v2->bitmapLength);\n\t}\n\n\tcache_bitmap_v2->compressed = compressed;\n\treturn TRUE;\n}\nstatic CACHE_BITMAP_V3_ORDER* update_read_cache_bitmap_v3_order(rdpUpdate* update, wStream* s,\n                                                                UINT16 flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tUINT32 new_len;\n\tBYTE* new_data;\n\tCACHE_BITMAP_V3_ORDER* cache_bitmap_v3;\n\n\tif (!update || !s)\n\t\treturn NULL;\n\n\tcache_bitmap_v3 = calloc(1, sizeof(CACHE_BITMAP_V3_ORDER));\n\n\tif (!cache_bitmap_v3)\n\t\tgoto fail;\n\n\tcache_bitmap_v3->cacheId = flags & 0x00000003;\n\tcache_bitmap_v3->flags = (flags & 0x0000FF80) >> 7;\n\tbitsPerPixelId = (flags & 0x00000078) >> 3;\n\tcache_bitmap_v3->bpp = CBR23_BPP[bitsPerPixelId];\n\n\tif (Stream_GetRemainingLength(s) < 21)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, cache_bitmap_v3->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Read_UINT32(s, cache_bitmap_v3->key1);       /* key1 (4 bytes) */\n\tStream_Read_UINT32(s, cache_bitmap_v3->key2);       /* key2 (4 bytes) */\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tStream_Read_UINT8(s, bitmapData->bpp);\n\n\tif ((bitmapData->bpp < 1) || (bitmapData->bpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bpp value %\" PRIu32 \"\", bitmapData->bpp);\n\t\tgoto fail;\n\t}\n\n\tStream_Seek_UINT8(s);                      /* reserved1 (1 byte) */\n\tStream_Seek_UINT8(s);                      /* reserved2 (1 byte) */\n\tStream_Read_UINT8(s, bitmapData->codecID); /* codecID (1 byte) */\n\tStream_Read_UINT16(s, bitmapData->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, bitmapData->height); /* height (2 bytes) */\n\tStream_Read_UINT32(s, new_len);            /* length (4 bytes) */\n\n\tif ((new_len == 0) || (Stream_GetRemainingLength(s) < new_len))\n\t\tgoto fail;\n\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\n\tif (!new_data)\n\t\tgoto fail;\n\n\tbitmapData->data = new_data;\n\tbitmapData->length = new_len;\n\tStream_Read(s, bitmapData->data, bitmapData->length);\n\treturn cache_bitmap_v3;\nfail:\n\tfree_cache_bitmap_v3_order(update->context, cache_bitmap_v3);\n\treturn NULL;\n}\nint update_approximate_cache_bitmap_v3_order(CACHE_BITMAP_V3_ORDER* cache_bitmap_v3, UINT16* flags)\n{\n\tBITMAP_DATA_EX* bitmapData = &cache_bitmap_v3->bitmapData;\n\treturn 64 + bitmapData->length;\n}\nBOOL update_write_cache_bitmap_v3_order(wStream* s, CACHE_BITMAP_V3_ORDER* cache_bitmap_v3,\n                                        UINT16* flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\n\tif (!Stream_EnsureRemainingCapacity(\n\t        s, update_approximate_cache_bitmap_v3_order(cache_bitmap_v3, flags)))\n\t\treturn FALSE;\n\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tbitsPerPixelId = BPP_CBR23[cache_bitmap_v3->bpp];\n\t*flags = (cache_bitmap_v3->cacheId & 0x00000003) |\n\t         ((cache_bitmap_v3->flags << 7) & 0x0000FF80) | ((bitsPerPixelId << 3) & 0x00000078);\n\tStream_Write_UINT16(s, cache_bitmap_v3->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Write_UINT32(s, cache_bitmap_v3->key1);       /* key1 (4 bytes) */\n\tStream_Write_UINT32(s, cache_bitmap_v3->key2);       /* key2 (4 bytes) */\n\tStream_Write_UINT8(s, bitmapData->bpp);\n\tStream_Write_UINT8(s, 0);                   /* reserved1 (1 byte) */\n\tStream_Write_UINT8(s, 0);                   /* reserved2 (1 byte) */\n\tStream_Write_UINT8(s, bitmapData->codecID); /* codecID (1 byte) */\n\tStream_Write_UINT16(s, bitmapData->width);  /* width (2 bytes) */\n\tStream_Write_UINT16(s, bitmapData->height); /* height (2 bytes) */\n\tStream_Write_UINT32(s, bitmapData->length); /* length (4 bytes) */\n\tStream_Write(s, bitmapData->data, bitmapData->length);\n\treturn TRUE;\n}\nstatic CACHE_COLOR_TABLE_ORDER* update_read_cache_color_table_order(rdpUpdate* update, wStream* s,\n                                                                    UINT16 flags)\n{\n\tint i;\n\tUINT32* colorTable;\n\tCACHE_COLOR_TABLE_ORDER* cache_color_table = calloc(1, sizeof(CACHE_COLOR_TABLE_ORDER));\n\n\tif (!cache_color_table)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 3)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_color_table->cacheIndex);    /* cacheIndex (1 byte) */\n\tStream_Read_UINT16(s, cache_color_table->numberColors); /* numberColors (2 bytes) */\n\n\tif (cache_color_table->numberColors != 256)\n\t{\n\t\t/* This field MUST be set to 256 */\n\t\tgoto fail;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < cache_color_table->numberColors * 4)\n\t\tgoto fail;\n\n\tcolorTable = (UINT32*)&cache_color_table->colorTable;\n\n\tfor (i = 0; i < (int)cache_color_table->numberColors; i++)\n\t\tupdate_read_color_quad(s, &colorTable[i]);\n\n\treturn cache_color_table;\nfail:\n\tfree_cache_color_table_order(update->context, cache_color_table);\n\treturn NULL;\n}\nint update_approximate_cache_color_table_order(const CACHE_COLOR_TABLE_ORDER* cache_color_table,\n                                               UINT16* flags)\n{\n\treturn 16 + (256 * 4);\n}\nBOOL update_write_cache_color_table_order(wStream* s,\n                                          const CACHE_COLOR_TABLE_ORDER* cache_color_table,\n                                          UINT16* flags)\n{\n\tint i, inf;\n\tUINT32* colorTable;\n\n\tif (cache_color_table->numberColors != 256)\n\t\treturn FALSE;\n\n\tinf = update_approximate_cache_color_table_order(cache_color_table, flags);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\tStream_Write_UINT8(s, cache_color_table->cacheIndex);    /* cacheIndex (1 byte) */\n\tStream_Write_UINT16(s, cache_color_table->numberColors); /* numberColors (2 bytes) */\n\tcolorTable = (UINT32*)&cache_color_table->colorTable;\n\n\tfor (i = 0; i < (int)cache_color_table->numberColors; i++)\n\t{\n\t\tupdate_write_color_quad(s, colorTable[i]);\n\t}\n\n\treturn TRUE;\n}\nstatic CACHE_GLYPH_ORDER* update_read_cache_glyph_order(rdpUpdate* update, wStream* s, UINT16 flags)\n{\n\tUINT32 i;\n\tCACHE_GLYPH_ORDER* cache_glyph_order = calloc(1, sizeof(CACHE_GLYPH_ORDER));\n\n\tif (!cache_glyph_order || !update || !s)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_glyph_order->cacheId); /* cacheId (1 byte) */\n\tStream_Read_UINT8(s, cache_glyph_order->cGlyphs); /* cGlyphs (1 byte) */\n\n\tfor (i = 0; i < cache_glyph_order->cGlyphs; i++)\n\t{\n\t\tGLYPH_DATA* glyph = &cache_glyph_order->glyphData[i];\n\n\t\tif (Stream_GetRemainingLength(s) < 10)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UINT16(s, glyph->cacheIndex);\n\t\tStream_Read_INT16(s, glyph->x);\n\t\tStream_Read_INT16(s, glyph->y);\n\t\tStream_Read_UINT16(s, glyph->cx);\n\t\tStream_Read_UINT16(s, glyph->cy);\n\t\tglyph->cb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\tglyph->cb += ((glyph->cb % 4) > 0) ? 4 - (glyph->cb % 4) : 0;\n\n\t\tif (Stream_GetRemainingLength(s) < glyph->cb)\n\t\t\tgoto fail;\n\n\t\tglyph->aj = (BYTE*)malloc(glyph->cb);\n\n\t\tif (!glyph->aj)\n\t\t\tgoto fail;\n\n\t\tStream_Read(s, glyph->aj, glyph->cb);\n\t}\n\n\tif ((flags & CG_GLYPH_UNICODE_PRESENT) && (cache_glyph_order->cGlyphs > 0))\n\t{\n\t\tcache_glyph_order->unicodeCharacters = calloc(cache_glyph_order->cGlyphs, sizeof(WCHAR));\n\n\t\tif (!cache_glyph_order->unicodeCharacters)\n\t\t\tgoto fail;\n\n\t\tif (Stream_GetRemainingLength(s) < sizeof(WCHAR) * cache_glyph_order->cGlyphs)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UTF16_String(s, cache_glyph_order->unicodeCharacters,\n\t\t                         cache_glyph_order->cGlyphs);\n\t}\n\n\treturn cache_glyph_order;\nfail:\n\tfree_cache_glyph_order(update->context, cache_glyph_order);\n\treturn NULL;\n}\nint update_approximate_cache_glyph_order(const CACHE_GLYPH_ORDER* cache_glyph, UINT16* flags)\n{\n\treturn 2 + cache_glyph->cGlyphs * 32;\n}\nBOOL update_write_cache_glyph_order(wStream* s, const CACHE_GLYPH_ORDER* cache_glyph, UINT16* flags)\n{\n\tint i, inf;\n\tINT16 lsi16;\n\tconst GLYPH_DATA* glyph;\n\tinf = update_approximate_cache_glyph_order(cache_glyph, flags);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\tStream_Write_UINT8(s, cache_glyph->cacheId); /* cacheId (1 byte) */\n\tStream_Write_UINT8(s, cache_glyph->cGlyphs); /* cGlyphs (1 byte) */\n\n\tfor (i = 0; i < (int)cache_glyph->cGlyphs; i++)\n\t{\n\t\tUINT32 cb;\n\t\tglyph = &cache_glyph->glyphData[i];\n\t\tStream_Write_UINT16(s, glyph->cacheIndex); /* cacheIndex (2 bytes) */\n\t\tlsi16 = glyph->x;\n\t\tStream_Write_UINT16(s, lsi16); /* x (2 bytes) */\n\t\tlsi16 = glyph->y;\n\t\tStream_Write_UINT16(s, lsi16);     /* y (2 bytes) */\n\t\tStream_Write_UINT16(s, glyph->cx); /* cx (2 bytes) */\n\t\tStream_Write_UINT16(s, glyph->cy); /* cy (2 bytes) */\n\t\tcb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\tcb += ((cb % 4) > 0) ? 4 - (cb % 4) : 0;\n\t\tStream_Write(s, glyph->aj, cb);\n\t}\n\n\tif (*flags & CG_GLYPH_UNICODE_PRESENT)\n\t{\n\t\tStream_Zero(s, cache_glyph->cGlyphs * 2);\n\t}\n\n\treturn TRUE;\n}\nstatic CACHE_GLYPH_V2_ORDER* update_read_cache_glyph_v2_order(rdpUpdate* update, wStream* s,\n                                                              UINT16 flags)\n{\n\tUINT32 i;\n\tCACHE_GLYPH_V2_ORDER* cache_glyph_v2 = calloc(1, sizeof(CACHE_GLYPH_V2_ORDER));\n\n\tif (!cache_glyph_v2)\n\t\tgoto fail;\n\n\tcache_glyph_v2->cacheId = (flags & 0x000F);\n\tcache_glyph_v2->flags = (flags & 0x00F0) >> 4;\n\tcache_glyph_v2->cGlyphs = (flags & 0xFF00) >> 8;\n\n\tfor (i = 0; i < cache_glyph_v2->cGlyphs; i++)\n\t{\n\t\tGLYPH_DATA_V2* glyph = &cache_glyph_v2->glyphData[i];\n\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UINT8(s, glyph->cacheIndex);\n\n\t\tif (!update_read_2byte_signed(s, &glyph->x) || !update_read_2byte_signed(s, &glyph->y) ||\n\t\t    !update_read_2byte_unsigned(s, &glyph->cx) ||\n\t\t    !update_read_2byte_unsigned(s, &glyph->cy))\n\t\t{\n\t\t\tgoto fail;\n\t\t}\n\n\t\tglyph->cb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\tglyph->cb += ((glyph->cb % 4) > 0) ? 4 - (glyph->cb % 4) : 0;\n\n\t\tif (Stream_GetRemainingLength(s) < glyph->cb)\n\t\t\tgoto fail;\n\n\t\tglyph->aj = (BYTE*)malloc(glyph->cb);\n\n\t\tif (!glyph->aj)\n\t\t\tgoto fail;\n\n\t\tStream_Read(s, glyph->aj, glyph->cb);\n\t}\n\n\tif ((flags & CG_GLYPH_UNICODE_PRESENT) && (cache_glyph_v2->cGlyphs > 0))\n\t{\n\t\tcache_glyph_v2->unicodeCharacters = calloc(cache_glyph_v2->cGlyphs, sizeof(WCHAR));\n\n\t\tif (!cache_glyph_v2->unicodeCharacters)\n\t\t\tgoto fail;\n\n\t\tif (Stream_GetRemainingLength(s) < sizeof(WCHAR) * cache_glyph_v2->cGlyphs)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UTF16_String(s, cache_glyph_v2->unicodeCharacters, cache_glyph_v2->cGlyphs);\n\t}\n\n\treturn cache_glyph_v2;\nfail:\n\tfree_cache_glyph_v2_order(update->context, cache_glyph_v2);\n\treturn NULL;\n}\nint update_approximate_cache_glyph_v2_order(const CACHE_GLYPH_V2_ORDER* cache_glyph_v2,\n                                            UINT16* flags)\n{\n\treturn 8 + cache_glyph_v2->cGlyphs * 32;\n}\nBOOL update_write_cache_glyph_v2_order(wStream* s, const CACHE_GLYPH_V2_ORDER* cache_glyph_v2,\n                                       UINT16* flags)\n{\n\tUINT32 i, inf;\n\tinf = update_approximate_cache_glyph_v2_order(cache_glyph_v2, flags);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\t*flags = (cache_glyph_v2->cacheId & 0x000F) | ((cache_glyph_v2->flags & 0x000F) << 4) |\n\t         ((cache_glyph_v2->cGlyphs & 0x00FF) << 8);\n\n\tfor (i = 0; i < cache_glyph_v2->cGlyphs; i++)\n\t{\n\t\tUINT32 cb;\n\t\tconst GLYPH_DATA_V2* glyph = &cache_glyph_v2->glyphData[i];\n\t\tStream_Write_UINT8(s, glyph->cacheIndex);\n\n\t\tif (!update_write_2byte_signed(s, glyph->x) || !update_write_2byte_signed(s, glyph->y) ||\n\t\t    !update_write_2byte_unsigned(s, glyph->cx) ||\n\t\t    !update_write_2byte_unsigned(s, glyph->cy))\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tcb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\tcb += ((cb % 4) > 0) ? 4 - (cb % 4) : 0;\n\t\tStream_Write(s, glyph->aj, cb);\n\t}\n\n\tif (*flags & CG_GLYPH_UNICODE_PRESENT)\n\t{\n\t\tStream_Zero(s, cache_glyph_v2->cGlyphs * 2);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_decompress_brush(wStream* s, BYTE* output, size_t outSize, BYTE bpp)\n{\n\tINT32 x, y, k;\n\tBYTE byte = 0;\n\tconst BYTE* palette = Stream_Pointer(s) + 16;\n\tconst INT32 bytesPerPixel = ((bpp + 1) / 8);\n\n\tif (!Stream_SafeSeek(s, 16ULL + 7ULL * bytesPerPixel)) // 64 / 4\n\t\treturn FALSE;\n\n\tfor (y = 7; y >= 0; y--)\n\t{\n\t\tfor (x = 0; x < 8; x++)\n\t\t{\n\t\t\tUINT32 index;\n\t\t\tif ((x % 4) == 0)\n\t\t\t\tStream_Read_UINT8(s, byte);\n\n\t\t\tindex = ((byte >> ((3 - (x % 4)) * 2)) & 0x03);\n\n\t\t\tfor (k = 0; k < bytesPerPixel; k++)\n\t\t\t{\n\t\t\t\tconst size_t dstIndex = ((y * 8 + x) * bytesPerPixel) + k;\n\t\t\t\tconst size_t srcIndex = (index * bytesPerPixel) + k;\n\t\t\t\tif (dstIndex >= outSize)\n\t\t\t\t\treturn FALSE;\n\t\t\t\toutput[dstIndex] = palette[srcIndex];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_compress_brush(wStream* s, const BYTE* input, BYTE bpp)\n{\n\treturn FALSE;\n}\nstatic CACHE_BRUSH_ORDER* update_read_cache_brush_order(rdpUpdate* update, wStream* s, UINT16 flags)\n{\n\tint i;\n\tBYTE iBitmapFormat;\n\tBOOL compressed = FALSE;\n\tCACHE_BRUSH_ORDER* cache_brush = calloc(1, sizeof(CACHE_BRUSH_ORDER));\n\n\tif (!cache_brush)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_brush->index); /* cacheEntry (1 byte) */\n\tStream_Read_UINT8(s, iBitmapFormat);      /* iBitmapFormat (1 byte) */\n\n\tif (iBitmapFormat >= ARRAYSIZE(BMF_BPP))\n\t\tgoto fail;\n\n\tcache_brush->bpp = BMF_BPP[iBitmapFormat];\n\tStream_Read_UINT8(s, cache_brush->cx);     /* cx (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->cy);     /* cy (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->style);  /* style (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->length); /* iBytes (1 byte) */\n\n\tif ((cache_brush->cx == 8) && (cache_brush->cy == 8))\n\t{\n\t\tif (cache_brush->bpp == 1)\n\t\t{\n\t\t\tif (cache_brush->length != 8)\n\t\t\t{\n\t\t\t\tWLog_Print(update->log, WLOG_ERROR, \"incompatible 1bpp brush of length:%\" PRIu32 \"\",\n\t\t\t\t           cache_brush->length);\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\t/* rows are encoded in reverse order */\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\tgoto fail;\n\n\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t{\n\t\t\t\tStream_Read_UINT8(s, cache_brush->data[i]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((iBitmapFormat == BMF_8BPP) && (cache_brush->length == 20))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_16BPP) && (cache_brush->length == 24))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_32BPP) && (cache_brush->length == 32))\n\t\t\t\tcompressed = TRUE;\n\n\t\t\tif (compressed != FALSE)\n\t\t\t{\n\t\t\t\t/* compressed brush */\n\t\t\t\tif (!update_decompress_brush(s, cache_brush->data, sizeof(cache_brush->data),\n\t\t\t\t                             cache_brush->bpp))\n\t\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* uncompressed brush */\n\t\t\t\tUINT32 scanline = (cache_brush->bpp / 8) * 8;\n\n\t\t\t\tif (Stream_GetRemainingLength(s) < scanline * 8)\n\t\t\t\t\tgoto fail;\n\n\t\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\tStream_Read(s, &cache_brush->data[i * scanline], scanline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cache_brush;\nfail:\n\tfree_cache_brush_order(update->context, cache_brush);\n\treturn NULL;\n}\nint update_approximate_cache_brush_order(const CACHE_BRUSH_ORDER* cache_brush, UINT16* flags)\n{\n\treturn 64;\n}\nBOOL update_write_cache_brush_order(wStream* s, const CACHE_BRUSH_ORDER* cache_brush, UINT16* flags)\n{\n\tint i;\n\tBYTE iBitmapFormat;\n\tBOOL compressed = FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s,\n\t                                    update_approximate_cache_brush_order(cache_brush, flags)))\n\t\treturn FALSE;\n\n\tiBitmapFormat = BPP_BMF[cache_brush->bpp];\n\tStream_Write_UINT8(s, cache_brush->index);  /* cacheEntry (1 byte) */\n\tStream_Write_UINT8(s, iBitmapFormat);       /* iBitmapFormat (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->cx);     /* cx (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->cy);     /* cy (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->style);  /* style (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->length); /* iBytes (1 byte) */\n\n\tif ((cache_brush->cx == 8) && (cache_brush->cy == 8))\n\t{\n\t\tif (cache_brush->bpp == 1)\n\t\t{\n\t\t\tif (cache_brush->length != 8)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"incompatible 1bpp brush of length:%\" PRIu32 \"\", cache_brush->length);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t{\n\t\t\t\tStream_Write_UINT8(s, cache_brush->data[i]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((iBitmapFormat == BMF_8BPP) && (cache_brush->length == 20))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_16BPP) && (cache_brush->length == 24))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_32BPP) && (cache_brush->length == 32))\n\t\t\t\tcompressed = TRUE;\n\n\t\t\tif (compressed != FALSE)\n\t\t\t{\n\t\t\t\t/* compressed brush */\n\t\t\t\tif (!update_compress_brush(s, cache_brush->data, cache_brush->bpp))\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* uncompressed brush */\n\t\t\t\tint scanline = (cache_brush->bpp / 8) * 8;\n\n\t\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\tStream_Write(s, &cache_brush->data[i * scanline], scanline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n/* Alternate Secondary Drawing Orders */\nstatic BOOL\nupdate_read_create_offscreen_bitmap_order(wStream* s,\n                                          CREATE_OFFSCREEN_BITMAP_ORDER* create_offscreen_bitmap)\n{\n\tUINT16 flags;\n\tBOOL deleteListPresent;\n\tOFFSCREEN_DELETE_LIST* deleteList;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, flags); /* flags (2 bytes) */\n\tcreate_offscreen_bitmap->id = flags & 0x7FFF;\n\tdeleteListPresent = (flags & 0x8000) ? TRUE : FALSE;\n\tStream_Read_UINT16(s, create_offscreen_bitmap->cx); /* cx (2 bytes) */\n\tStream_Read_UINT16(s, create_offscreen_bitmap->cy); /* cy (2 bytes) */\n\tdeleteList = &(create_offscreen_bitmap->deleteList);\n\n\tif (deleteListPresent)\n\t{\n\t\tUINT32 i;\n\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, deleteList->cIndices);\n\n\t\tif (deleteList->cIndices > deleteList->sIndices)\n\t\t{\n\t\t\tUINT16* new_indices;\n\t\t\tnew_indices = (UINT16*)realloc(deleteList->indices, deleteList->cIndices * 2);\n\n\t\t\tif (!new_indices)\n\t\t\t\treturn FALSE;\n\n\t\t\tdeleteList->sIndices = deleteList->cIndices;\n\t\t\tdeleteList->indices = new_indices;\n\t\t}\n\n\t\tif (Stream_GetRemainingLength(s) < 2 * deleteList->cIndices)\n\t\t\treturn FALSE;\n\n\t\tfor (i = 0; i < deleteList->cIndices; i++)\n\t\t{\n\t\t\tStream_Read_UINT16(s, deleteList->indices[i]);\n\t\t}\n\t}\n\telse\n\t{\n\t\tdeleteList->cIndices = 0;\n\t}\n\n\treturn TRUE;\n}\nint update_approximate_create_offscreen_bitmap_order(\n    const CREATE_OFFSCREEN_BITMAP_ORDER* create_offscreen_bitmap)\n{\n\tconst OFFSCREEN_DELETE_LIST* deleteList = &(create_offscreen_bitmap->deleteList);\n\treturn 32 + deleteList->cIndices * 2;\n}\nBOOL update_write_create_offscreen_bitmap_order(\n    wStream* s, const CREATE_OFFSCREEN_BITMAP_ORDER* create_offscreen_bitmap)\n{\n\tUINT16 flags;\n\tBOOL deleteListPresent;\n\tconst OFFSCREEN_DELETE_LIST* deleteList;\n\n\tif (!Stream_EnsureRemainingCapacity(\n\t        s, update_approximate_create_offscreen_bitmap_order(create_offscreen_bitmap)))\n\t\treturn FALSE;\n\n\tdeleteList = &(create_offscreen_bitmap->deleteList);\n\tflags = create_offscreen_bitmap->id & 0x7FFF;\n\tdeleteListPresent = (deleteList->cIndices > 0) ? TRUE : FALSE;\n\n\tif (deleteListPresent)\n\t\tflags |= 0x8000;\n\n\tStream_Write_UINT16(s, flags);                       /* flags (2 bytes) */\n\tStream_Write_UINT16(s, create_offscreen_bitmap->cx); /* cx (2 bytes) */\n\tStream_Write_UINT16(s, create_offscreen_bitmap->cy); /* cy (2 bytes) */\n\n\tif (deleteListPresent)\n\t{\n\t\tint i;\n\t\tStream_Write_UINT16(s, deleteList->cIndices);\n\n\t\tfor (i = 0; i < (int)deleteList->cIndices; i++)\n\t\t{\n\t\t\tStream_Write_UINT16(s, deleteList->indices[i]);\n\t\t}\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_switch_surface_order(wStream* s, SWITCH_SURFACE_ORDER* switch_surface)\n{\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, switch_surface->bitmapId); /* bitmapId (2 bytes) */\n\treturn TRUE;\n}\nint update_approximate_switch_surface_order(const SWITCH_SURFACE_ORDER* switch_surface)\n{\n\treturn 2;\n}\nBOOL update_write_switch_surface_order(wStream* s, const SWITCH_SURFACE_ORDER* switch_surface)\n{\n\tint inf = update_approximate_switch_surface_order(switch_surface);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, switch_surface->bitmapId); /* bitmapId (2 bytes) */\n\treturn TRUE;\n}\nstatic BOOL\nupdate_read_create_nine_grid_bitmap_order(wStream* s,\n                                          CREATE_NINE_GRID_BITMAP_ORDER* create_nine_grid_bitmap)\n{\n\tNINE_GRID_BITMAP_INFO* nineGridInfo;\n\n\tif (Stream_GetRemainingLength(s) < 19)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, create_nine_grid_bitmap->bitmapBpp); /* bitmapBpp (1 byte) */\n\n\tif ((create_nine_grid_bitmap->bitmapBpp < 1) || (create_nine_grid_bitmap->bitmapBpp > 32))\n\t{\n\t\tWLog_ERR(TAG, \"invalid bpp value %\" PRIu32 \"\", create_nine_grid_bitmap->bitmapBpp);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, create_nine_grid_bitmap->bitmapId); /* bitmapId (2 bytes) */\n\tnineGridInfo = &(create_nine_grid_bitmap->nineGridInfo);\n\tStream_Read_UINT32(s, nineGridInfo->flFlags);          /* flFlags (4 bytes) */\n\tStream_Read_UINT16(s, nineGridInfo->ulLeftWidth);      /* ulLeftWidth (2 bytes) */\n\tStream_Read_UINT16(s, nineGridInfo->ulRightWidth);     /* ulRightWidth (2 bytes) */\n\tStream_Read_UINT16(s, nineGridInfo->ulTopHeight);      /* ulTopHeight (2 bytes) */\n\tStream_Read_UINT16(s, nineGridInfo->ulBottomHeight);   /* ulBottomHeight (2 bytes) */\n\tupdate_read_colorref(s, &nineGridInfo->crTransparent); /* crTransparent (4 bytes) */\n\treturn TRUE;\n}\nstatic BOOL update_read_frame_marker_order(wStream* s, FRAME_MARKER_ORDER* frame_marker)\n{\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, frame_marker->action); /* action (4 bytes) */\n\treturn TRUE;\n}\nstatic BOOL update_read_stream_bitmap_first_order(wStream* s,\n                                                  STREAM_BITMAP_FIRST_ORDER* stream_bitmap_first)\n{\n\tif (Stream_GetRemainingLength(s) < 10) // 8 + 2 at least\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, stream_bitmap_first->bitmapFlags); /* bitmapFlags (1 byte) */\n\tStream_Read_UINT8(s, stream_bitmap_first->bitmapBpp);   /* bitmapBpp (1 byte) */\n\n\tif ((stream_bitmap_first->bitmapBpp < 1) || (stream_bitmap_first->bitmapBpp > 32))\n\t{\n\t\tWLog_ERR(TAG, \"invalid bpp value %\" PRIu32 \"\", stream_bitmap_first->bitmapBpp);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, stream_bitmap_first->bitmapType);   /* bitmapType (2 bytes) */\n\tStream_Read_UINT16(s, stream_bitmap_first->bitmapWidth);  /* bitmapWidth (2 bytes) */\n\tStream_Read_UINT16(s, stream_bitmap_first->bitmapHeight); /* bitmapHeigth (2 bytes) */\n\n\tif (stream_bitmap_first->bitmapFlags & STREAM_BITMAP_V2)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, stream_bitmap_first->bitmapSize); /* bitmapSize (4 bytes) */\n\t}\n\telse\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, stream_bitmap_first->bitmapSize); /* bitmapSize (2 bytes) */\n\t}\n\n\tFIELD_SKIP_BUFFER16(\n\t    s, stream_bitmap_first->bitmapBlockSize); /* bitmapBlockSize(2 bytes) + bitmapBlock */\n\treturn TRUE;\n}\nstatic BOOL update_read_stream_bitmap_next_order(wStream* s,\n                                                 STREAM_BITMAP_NEXT_ORDER* stream_bitmap_next)\n{\n\tif (Stream_GetRemainingLength(s) < 5)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, stream_bitmap_next->bitmapFlags); /* bitmapFlags (1 byte) */\n\tStream_Read_UINT16(s, stream_bitmap_next->bitmapType); /* bitmapType (2 bytes) */\n\tFIELD_SKIP_BUFFER16(\n\t    s, stream_bitmap_next->bitmapBlockSize); /* bitmapBlockSize(2 bytes) + bitmapBlock */\n\treturn TRUE;\n}\nstatic BOOL update_read_draw_gdiplus_first_order(wStream* s,\n                                                 DRAW_GDIPLUS_FIRST_ORDER* draw_gdiplus_first)\n{\n\tif (Stream_GetRemainingLength(s) < 11)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT8(s);                                      /* pad1Octet (1 byte) */\n\tStream_Read_UINT16(s, draw_gdiplus_first->cbSize);         /* cbSize (2 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_first->cbTotalSize);    /* cbTotalSize (4 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_first->cbTotalEmfSize); /* cbTotalEmfSize (4 bytes) */\n\treturn Stream_SafeSeek(s, draw_gdiplus_first->cbSize);     /* emfRecords */\n}\nstatic BOOL update_read_draw_gdiplus_next_order(wStream* s,\n                                                DRAW_GDIPLUS_NEXT_ORDER* draw_gdiplus_next)\n{\n\tif (Stream_GetRemainingLength(s) < 3)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT8(s);                              /* pad1Octet (1 byte) */\n\tFIELD_SKIP_BUFFER16(s, draw_gdiplus_next->cbSize); /* cbSize(2 bytes) + emfRecords */\n\treturn TRUE;\n}\nstatic BOOL update_read_draw_gdiplus_end_order(wStream* s, DRAW_GDIPLUS_END_ORDER* draw_gdiplus_end)\n{\n\tif (Stream_GetRemainingLength(s) < 11)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT8(s);                                    /* pad1Octet (1 byte) */\n\tStream_Read_UINT16(s, draw_gdiplus_end->cbSize);         /* cbSize (2 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_end->cbTotalSize);    /* cbTotalSize (4 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_end->cbTotalEmfSize); /* cbTotalEmfSize (4 bytes) */\n\treturn Stream_SafeSeek(s, draw_gdiplus_end->cbSize);     /* emfRecords */\n}\nstatic BOOL\nupdate_read_draw_gdiplus_cache_first_order(wStream* s,\n                                           DRAW_GDIPLUS_CACHE_FIRST_ORDER* draw_gdiplus_cache_first)\n{\n\tif (Stream_GetRemainingLength(s) < 11)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, draw_gdiplus_cache_first->flags);        /* flags (1 byte) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_first->cacheType);   /* cacheType (2 bytes) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_first->cacheIndex);  /* cacheIndex (2 bytes) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_first->cbSize);      /* cbSize (2 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_cache_first->cbTotalSize); /* cbTotalSize (4 bytes) */\n\treturn Stream_SafeSeek(s, draw_gdiplus_cache_first->cbSize);  /* emfRecords */\n}\nstatic BOOL\nupdate_read_draw_gdiplus_cache_next_order(wStream* s,\n                                          DRAW_GDIPLUS_CACHE_NEXT_ORDER* draw_gdiplus_cache_next)\n{\n\tif (Stream_GetRemainingLength(s) < 7)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, draw_gdiplus_cache_next->flags);       /* flags (1 byte) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_next->cacheType);  /* cacheType (2 bytes) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_next->cacheIndex); /* cacheIndex (2 bytes) */\n\tFIELD_SKIP_BUFFER16(s, draw_gdiplus_cache_next->cbSize);    /* cbSize(2 bytes) + emfRecords */\n\treturn TRUE;\n}\nstatic BOOL\nupdate_read_draw_gdiplus_cache_end_order(wStream* s,\n                                         DRAW_GDIPLUS_CACHE_END_ORDER* draw_gdiplus_cache_end)\n{\n\tif (Stream_GetRemainingLength(s) < 11)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, draw_gdiplus_cache_end->flags);        /* flags (1 byte) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_end->cacheType);   /* cacheType (2 bytes) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_end->cacheIndex);  /* cacheIndex (2 bytes) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_end->cbSize);      /* cbSize (2 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_cache_end->cbTotalSize); /* cbTotalSize (4 bytes) */\n\treturn Stream_SafeSeek(s, draw_gdiplus_cache_end->cbSize);  /* emfRecords */\n}\nstatic BOOL update_read_field_flags(wStream* s, UINT32* fieldFlags, BYTE flags, BYTE fieldBytes)\n{\n\tint i;\n\tBYTE byte;\n\n\tif (flags & ORDER_ZERO_FIELD_BYTE_BIT0)\n\t\tfieldBytes--;\n\n\tif (flags & ORDER_ZERO_FIELD_BYTE_BIT1)\n\t{\n\t\tif (fieldBytes > 1)\n\t\t\tfieldBytes -= 2;\n\t\telse\n\t\t\tfieldBytes = 0;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < fieldBytes)\n\t\treturn FALSE;\n\n\t*fieldFlags = 0;\n\n\tfor (i = 0; i < fieldBytes; i++)\n\t{\n\t\tStream_Read_UINT8(s, byte);\n\t\t*fieldFlags |= byte << (i * 8);\n\t}\n\n\treturn TRUE;\n}\nBOOL update_write_field_flags(wStream* s, UINT32 fieldFlags, BYTE flags, BYTE fieldBytes)\n{\n\tBYTE byte;\n\n\tif (fieldBytes == 1)\n\t{\n\t\tbyte = fieldFlags & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse if (fieldBytes == 2)\n\t{\n\t\tbyte = fieldFlags & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (fieldFlags >> 8) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse if (fieldBytes == 3)\n\t{\n\t\tbyte = fieldFlags & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (fieldFlags >> 8) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (fieldFlags >> 16) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse\n\t{\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_bounds(wStream* s, rdpBounds* bounds)\n{\n\tBYTE flags;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, flags); /* field flags */\n\n\tif (flags & BOUND_LEFT)\n\t{\n\t\tif (!update_read_coord(s, &bounds->left, FALSE))\n\t\t\treturn FALSE;\n\t}\n\telse if (flags & BOUND_DELTA_LEFT)\n\t{\n\t\tif (!update_read_coord(s, &bounds->left, TRUE))\n\t\t\treturn FALSE;\n\t}\n\n\tif (flags & BOUND_TOP)\n\t{\n\t\tif (!update_read_coord(s, &bounds->top, FALSE))\n\t\t\treturn FALSE;\n\t}\n\telse if (flags & BOUND_DELTA_TOP)\n\t{\n\t\tif (!update_read_coord(s, &bounds->top, TRUE))\n\t\t\treturn FALSE;\n\t}\n\n\tif (flags & BOUND_RIGHT)\n\t{\n\t\tif (!update_read_coord(s, &bounds->right, FALSE))\n\t\t\treturn FALSE;\n\t}\n\telse if (flags & BOUND_DELTA_RIGHT)\n\t{\n\t\tif (!update_read_coord(s, &bounds->right, TRUE))\n\t\t\treturn FALSE;\n\t}\n\n\tif (flags & BOUND_BOTTOM)\n\t{\n\t\tif (!update_read_coord(s, &bounds->bottom, FALSE))\n\t\t\treturn FALSE;\n\t}\n\telse if (flags & BOUND_DELTA_BOTTOM)\n\t{\n\t\tif (!update_read_coord(s, &bounds->bottom, TRUE))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\nBOOL update_write_bounds(wStream* s, ORDER_INFO* orderInfo)\n{\n\tif (!(orderInfo->controlFlags & ORDER_BOUNDS))\n\t\treturn TRUE;\n\n\tif (orderInfo->controlFlags & ORDER_ZERO_BOUNDS_DELTAS)\n\t\treturn TRUE;\n\n\tStream_Write_UINT8(s, orderInfo->boundsFlags); /* field flags */\n\n\tif (orderInfo->boundsFlags & BOUND_LEFT)\n\t{\n\t\tif (!update_write_coord(s, orderInfo->bounds.left))\n\t\t\treturn FALSE;\n\t}\n\telse if (orderInfo->boundsFlags & BOUND_DELTA_LEFT)\n\t{\n\t}\n\n\tif (orderInfo->boundsFlags & BOUND_TOP)\n\t{\n\t\tif (!update_write_coord(s, orderInfo->bounds.top))\n\t\t\treturn FALSE;\n\t}\n\telse if (orderInfo->boundsFlags & BOUND_DELTA_TOP)\n\t{\n\t}\n\n\tif (orderInfo->boundsFlags & BOUND_RIGHT)\n\t{\n\t\tif (!update_write_coord(s, orderInfo->bounds.right))\n\t\t\treturn FALSE;\n\t}\n\telse if (orderInfo->boundsFlags & BOUND_DELTA_RIGHT)\n\t{\n\t}\n\n\tif (orderInfo->boundsFlags & BOUND_BOTTOM)\n\t{\n\t\tif (!update_write_coord(s, orderInfo->bounds.bottom))\n\t\t\treturn FALSE;\n\t}\n\telse if (orderInfo->boundsFlags & BOUND_DELTA_BOTTOM)\n\t{\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL read_primary_order(wLog* log, const char* orderName, wStream* s,\n                               const ORDER_INFO* orderInfo, rdpPrimaryUpdate* primary)\n{\n\tBOOL rc = FALSE;\n\n\tif (!s || !orderInfo || !primary || !orderName)\n\t\treturn FALSE;\n\n\tswitch (orderInfo->orderType)\n\t{\n\t\tcase ORDER_TYPE_DSTBLT:\n\t\t\trc = update_read_dstblt_order(s, orderInfo, &(primary->dstblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_PATBLT:\n\t\t\trc = update_read_patblt_order(s, orderInfo, &(primary->patblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SCRBLT:\n\t\t\trc = update_read_scrblt_order(s, orderInfo, &(primary->scrblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_OPAQUE_RECT:\n\t\t\trc = update_read_opaque_rect_order(s, orderInfo, &(primary->opaque_rect));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_DRAW_NINE_GRID:\n\t\t\trc = update_read_draw_nine_grid_order(s, orderInfo, &(primary->draw_nine_grid));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DSTBLT:\n\t\t\trc = update_read_multi_dstblt_order(s, orderInfo, &(primary->multi_dstblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_PATBLT:\n\t\t\trc = update_read_multi_patblt_order(s, orderInfo, &(primary->multi_patblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_SCRBLT:\n\t\t\trc = update_read_multi_scrblt_order(s, orderInfo, &(primary->multi_scrblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_OPAQUE_RECT:\n\t\t\trc = update_read_multi_opaque_rect_order(s, orderInfo, &(primary->multi_opaque_rect));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DRAW_NINE_GRID:\n\t\t\trc = update_read_multi_draw_nine_grid_order(s, orderInfo,\n\t\t\t                                            &(primary->multi_draw_nine_grid));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_LINE_TO:\n\t\t\trc = update_read_line_to_order(s, orderInfo, &(primary->line_to));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYLINE:\n\t\t\trc = update_read_polyline_order(s, orderInfo, &(primary->polyline));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEMBLT:\n\t\t\trc = update_read_memblt_order(s, orderInfo, &(primary->memblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEM3BLT:\n\t\t\trc = update_read_mem3blt_order(s, orderInfo, &(primary->mem3blt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SAVE_BITMAP:\n\t\t\trc = update_read_save_bitmap_order(s, orderInfo, &(primary->save_bitmap));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GLYPH_INDEX:\n\t\t\trc = update_read_glyph_index_order(s, orderInfo, &(primary->glyph_index));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_INDEX:\n\t\t\trc = update_read_fast_index_order(s, orderInfo, &(primary->fast_index));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_GLYPH:\n\t\t\trc = update_read_fast_glyph_order(s, orderInfo, &(primary->fast_glyph));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_SC:\n\t\t\trc = update_read_polygon_sc_order(s, orderInfo, &(primary->polygon_sc));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_CB:\n\t\t\trc = update_read_polygon_cb_order(s, orderInfo, &(primary->polygon_cb));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_SC:\n\t\t\trc = update_read_ellipse_sc_order(s, orderInfo, &(primary->ellipse_sc));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_CB:\n\t\t\trc = update_read_ellipse_cb_order(s, orderInfo, &(primary->ellipse_cb));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(log, WLOG_WARN, \"Primary Drawing Order %s not supported, ignoring\",\n\t\t\t           orderName);\n\t\t\trc = TRUE;\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(log, WLOG_ERROR, \"%s - update_read_dstblt_order() failed\", orderName);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_recv_primary_order(rdpUpdate* update, wStream* s, BYTE flags)\n{\n\tBOOL rc = FALSE;\n\trdpContext* context = update->context;\n\trdpPrimaryUpdate* primary = update->primary;\n\tORDER_INFO* orderInfo = &(primary->order_info);\n\trdpSettings* settings = context->settings;\n\tconst char* orderName;\n\n\tif (flags & ORDER_TYPE_CHANGE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) < 1\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tStream_Read_UINT8(s, orderInfo->orderType); /* orderType (1 byte) */\n\t}\n\n\torderName = primary_order_string(orderInfo->orderType);\n\n\tif (!check_primary_order_supported(update->log, settings, orderInfo->orderType, orderName))\n\t\treturn FALSE;\n\n\tif (!update_read_field_flags(s, &(orderInfo->fieldFlags), flags,\n\t                             PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType]))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"update_read_field_flags() failed\");\n\t\treturn FALSE;\n\t}\n\n\tif (flags & ORDER_BOUNDS)\n\t{\n\t\tif (!(flags & ORDER_ZERO_BOUNDS_DELTAS))\n\t\t{\n\t\t\tif (!update_read_bounds(s, &orderInfo->bounds))\n\t\t\t{\n\t\t\t\tWLog_Print(update->log, WLOG_ERROR, \"update_read_bounds() failed\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\n\t\trc = IFCALLRESULT(FALSE, update->SetBounds, context, &orderInfo->bounds);\n\n\t\tif (!rc)\n\t\t\treturn FALSE;\n\t}\n\n\torderInfo->deltaCoordinates = (flags & ORDER_DELTA_COORDINATES) ? TRUE : FALSE;\n\n\tif (!read_primary_order(update->log, orderName, s, orderInfo, primary))\n\t\treturn FALSE;\n\n\tswitch (orderInfo->orderType)\n\t{\n\t\tcase ORDER_TYPE_DSTBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->dstblt.bRop),\n\t\t\t           gdi_rop3_code(primary->dstblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->DstBlt, context, &primary->dstblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_PATBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->patblt.bRop),\n\t\t\t           gdi_rop3_code(primary->patblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->PatBlt, context, &primary->patblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_SCRBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->scrblt.bRop),\n\t\t\t           gdi_rop3_code(primary->scrblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->ScrBlt, context, &primary->scrblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_OPAQUE_RECT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->OpaqueRect, context, &primary->opaque_rect);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_DRAW_NINE_GRID:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->DrawNineGrid, context, &primary->draw_nine_grid);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DSTBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->multi_dstblt.bRop),\n\t\t\t           gdi_rop3_code(primary->multi_dstblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->MultiDstBlt, context, &primary->multi_dstblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_PATBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->multi_patblt.bRop),\n\t\t\t           gdi_rop3_code(primary->multi_patblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->MultiPatBlt, context, &primary->multi_patblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_SCRBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->multi_scrblt.bRop),\n\t\t\t           gdi_rop3_code(primary->multi_scrblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->MultiScrBlt, context, &primary->multi_scrblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_OPAQUE_RECT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc =\n\t\t\t    IFCALLRESULT(FALSE, primary->MultiOpaqueRect, context, &primary->multi_opaque_rect);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DRAW_NINE_GRID:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->MultiDrawNineGrid, context,\n\t\t\t                  &primary->multi_draw_nine_grid);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_LINE_TO:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->LineTo, context, &primary->line_to);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYLINE:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->Polyline, context, &primary->polyline);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEMBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->memblt.bRop),\n\t\t\t           gdi_rop3_code(primary->memblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->MemBlt, context, &primary->memblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEM3BLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->mem3blt.bRop),\n\t\t\t           gdi_rop3_code(primary->mem3blt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->Mem3Blt, context, &primary->mem3blt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_SAVE_BITMAP:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->SaveBitmap, context, &primary->save_bitmap);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_GLYPH_INDEX:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->GlyphIndex, context, &primary->glyph_index);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_INDEX:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->FastIndex, context, &primary->fast_index);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_GLYPH:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->FastGlyph, context, &primary->fast_glyph);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_SC:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->PolygonSC, context, &primary->polygon_sc);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_CB:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->PolygonCB, context, &primary->polygon_cb);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_SC:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->EllipseSC, context, &primary->ellipse_sc);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_CB:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->EllipseCB, context, &primary->ellipse_cb);\n\t\t}\n\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(update->log, WLOG_WARN, \"Primary Drawing Order %s not supported\", orderName);\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(update->log, WLOG_WARN, \"Primary Drawing Order %s failed\", orderName);\n\t\treturn FALSE;\n\t}\n\n\tif (flags & ORDER_BOUNDS)\n\t{\n\t\trc = IFCALLRESULT(FALSE, update->SetBounds, context, NULL);\n\t}\n\n\treturn rc;\n}\n\nstatic BOOL update_recv_secondary_order(rdpUpdate* update, wStream* s, BYTE flags)\n{\n\tBOOL rc = FALSE;\n\tsize_t start, end, diff;\n\tBYTE orderType;\n\tUINT16 extraFlags;\n\tUINT16 orderLength;\n\trdpContext* context = update->context;\n\trdpSettings* settings = context->settings;\n\trdpSecondaryUpdate* secondary = update->secondary;\n\tconst char* name;\n\n\tif (Stream_GetRemainingLength(s) < 5)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) < 5\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, orderLength); /* orderLength (2 bytes) */\n\tStream_Read_UINT16(s, extraFlags);  /* extraFlags (2 bytes) */\n\tStream_Read_UINT8(s, orderType);    /* orderType (1 byte) */\n\tif (Stream_GetRemainingLength(s) < orderLength + 7U)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) %\" PRIuz \" < %\" PRIu16,\n\t\t           Stream_GetRemainingLength(s), orderLength + 7);\n\t\treturn FALSE;\n\t}\n\n\tstart = Stream_GetPosition(s);\n\tname = secondary_order_string(orderType);\n\tWLog_Print(update->log, WLOG_DEBUG, \"Secondary Drawing Order %s\", name);\n\n\tif (!check_secondary_order_supported(update->log, settings, orderType, name))\n\t\treturn FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED:\n\t\tcase ORDER_TYPE_CACHE_BITMAP_COMPRESSED:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_CACHE_BITMAP_COMPRESSED);\n\t\t\tCACHE_BITMAP_ORDER* order =\n\t\t\t    update_read_cache_bitmap_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmap, context, order);\n\t\t\t\tfree_cache_bitmap_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED_V2:\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V2:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_BITMAP_COMPRESSED_V2);\n\t\t\tCACHE_BITMAP_V2_ORDER* order =\n\t\t\t    update_read_cache_bitmap_v2_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV2, context, order);\n\t\t\t\tfree_cache_bitmap_v2_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V3:\n\t\t{\n\t\t\tCACHE_BITMAP_V3_ORDER* order = update_read_cache_bitmap_v3_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV3, context, order);\n\t\t\t\tfree_cache_bitmap_v3_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_COLOR_TABLE:\n\t\t{\n\t\t\tCACHE_COLOR_TABLE_ORDER* order =\n\t\t\t    update_read_cache_color_table_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheColorTable, context, order);\n\t\t\t\tfree_cache_color_table_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_GLYPH:\n\t\t{\n\t\t\tswitch (settings->GlyphSupportLevel)\n\t\t\t{\n\t\t\t\tcase GLYPH_SUPPORT_PARTIAL:\n\t\t\t\tcase GLYPH_SUPPORT_FULL:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_ORDER* order = update_read_cache_glyph_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyph, context, order);\n\t\t\t\t\t\tfree_cache_glyph_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_ENCODE:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_V2_ORDER* order =\n\t\t\t\t\t    update_read_cache_glyph_v2_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyphV2, context, order);\n\t\t\t\t\t\tfree_cache_glyph_v2_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_NONE:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_BRUSH:\n\t\t\t/* [MS-RDPEGDI] 2.2.2.2.1.2.7 Cache Brush (CACHE_BRUSH_ORDER) */\n\t\t\t{\n\t\t\t\tCACHE_BRUSH_ORDER* order = update_read_cache_brush_order(update, s, extraFlags);\n\n\t\t\t\tif (order)\n\t\t\t\t{\n\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBrush, context, order);\n\t\t\t\t\tfree_cache_brush_order(context, order);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(update->log, WLOG_WARN, \"SECONDARY ORDER %s not supported\", name);\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"SECONDARY ORDER %s failed\", name);\n\t}\n\n\tstart += orderLength + 7;\n\tend = Stream_GetPosition(s);\n\tif (start > end)\n\t{\n\t\tWLog_Print(update->log, WLOG_WARN, \"SECONDARY_ORDER %s: read %\" PRIuz \"bytes too much\",\n\t\t           name, end - start);\n\t\treturn FALSE;\n\t}\n\tdiff = start - end;\n\tif (diff > 0)\n\t{\n\t\tWLog_Print(update->log, WLOG_DEBUG,\n\t\t           \"SECONDARY_ORDER %s: read %\" PRIuz \"bytes short, skipping\", name, diff);\n\t\tStream_Seek(s, diff);\n\t}\n\treturn rc;\n}\n\nstatic BOOL read_altsec_order(wStream* s, BYTE orderType, rdpAltSecUpdate* altsec)\n{\n\tBOOL rc = FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_CREATE_OFFSCREEN_BITMAP:\n\t\t\trc = update_read_create_offscreen_bitmap_order(s, &(altsec->create_offscreen_bitmap));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SWITCH_SURFACE:\n\t\t\trc = update_read_switch_surface_order(s, &(altsec->switch_surface));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CREATE_NINE_GRID_BITMAP:\n\t\t\trc = update_read_create_nine_grid_bitmap_order(s, &(altsec->create_nine_grid_bitmap));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FRAME_MARKER:\n\t\t\trc = update_read_frame_marker_order(s, &(altsec->frame_marker));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_STREAM_BITMAP_FIRST:\n\t\t\trc = update_read_stream_bitmap_first_order(s, &(altsec->stream_bitmap_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_STREAM_BITMAP_NEXT:\n\t\t\trc = update_read_stream_bitmap_next_order(s, &(altsec->stream_bitmap_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_FIRST:\n\t\t\trc = update_read_draw_gdiplus_first_order(s, &(altsec->draw_gdiplus_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_NEXT:\n\t\t\trc = update_read_draw_gdiplus_next_order(s, &(altsec->draw_gdiplus_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_END:\n\t\t\trc = update_read_draw_gdiplus_end_order(s, &(altsec->draw_gdiplus_end));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_FIRST:\n\t\t\trc = update_read_draw_gdiplus_cache_first_order(s, &(altsec->draw_gdiplus_cache_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_NEXT:\n\t\t\trc = update_read_draw_gdiplus_cache_next_order(s, &(altsec->draw_gdiplus_cache_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_END:\n\t\t\trc = update_read_draw_gdiplus_cache_end_order(s, &(altsec->draw_gdiplus_cache_end));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_WINDOW:\n\t\t\t/* This order is handled elsewhere. */\n\t\t\trc = TRUE;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_COMPDESK_FIRST:\n\t\t\trc = TRUE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic BOOL update_recv_altsec_order(rdpUpdate* update, wStream* s, BYTE flags)\n{\n\tBYTE orderType = flags >>= 2; /* orderType is in higher 6 bits of flags field */\n\tBOOL rc = FALSE;\n\trdpContext* context = update->context;\n\trdpSettings* settings = context->settings;\n\trdpAltSecUpdate* altsec = update->altsec;\n\tconst char* orderName = altsec_order_string(orderType);\n\tWLog_Print(update->log, WLOG_DEBUG, \"Alternate Secondary Drawing Order %s\", orderName);\n\n\tif (!check_alt_order_supported(update->log, settings, orderType, orderName))\n\t\treturn FALSE;\n\n\tif (!read_altsec_order(s, orderType, altsec))\n\t\treturn FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_CREATE_OFFSCREEN_BITMAP:\n\t\t\tIFCALLRET(altsec->CreateOffscreenBitmap, rc, context,\n\t\t\t          &(altsec->create_offscreen_bitmap));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SWITCH_SURFACE:\n\t\t\tIFCALLRET(altsec->SwitchSurface, rc, context, &(altsec->switch_surface));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CREATE_NINE_GRID_BITMAP:\n\t\t\tIFCALLRET(altsec->CreateNineGridBitmap, rc, context,\n\t\t\t          &(altsec->create_nine_grid_bitmap));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FRAME_MARKER:\n\t\t\tIFCALLRET(altsec->FrameMarker, rc, context, &(altsec->frame_marker));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_STREAM_BITMAP_FIRST:\n\t\t\tIFCALLRET(altsec->StreamBitmapFirst, rc, context, &(altsec->stream_bitmap_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_STREAM_BITMAP_NEXT:\n\t\t\tIFCALLRET(altsec->StreamBitmapNext, rc, context, &(altsec->stream_bitmap_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_FIRST:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusFirst, rc, context, &(altsec->draw_gdiplus_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_NEXT:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusNext, rc, context, &(altsec->draw_gdiplus_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_END:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusEnd, rc, context, &(altsec->draw_gdiplus_end));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_FIRST:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusCacheFirst, rc, context,\n\t\t\t          &(altsec->draw_gdiplus_cache_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_NEXT:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusCacheNext, rc, context,\n\t\t\t          &(altsec->draw_gdiplus_cache_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_END:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusCacheEnd, rc, context, &(altsec->draw_gdiplus_cache_end));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_WINDOW:\n\t\t\trc = update_recv_altsec_window_order(update, s);\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_COMPDESK_FIRST:\n\t\t\trc = TRUE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(update->log, WLOG_WARN, \"Alternate Secondary Drawing Order %s failed\",\n\t\t           orderName);\n\t}\n\n\treturn rc;\n}\nBOOL update_recv_order(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc;\n\tBYTE controlFlags;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) < 1\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT8(s, controlFlags); /* controlFlags (1 byte) */\n\n\tif (!(controlFlags & ORDER_STANDARD))\n\t\trc = update_recv_altsec_order(update, s, controlFlags);\n\telse if (controlFlags & ORDER_SECONDARY)\n\t\trc = update_recv_secondary_order(update, s, controlFlags);\n\telse\n\t\trc = update_recv_primary_order(update, s, controlFlags);\n\n\tif (!rc)\n\t\tWLog_Print(update->log, WLOG_ERROR, \"order flags %02\" PRIx8 \" failed\", controlFlags);\n\n\treturn rc;\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Drawing Orders\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2016 Armin Novak <armin.novak@thincast.com>\n * Copyright 2016 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef FREERDP_LIB_CORE_ORDERS_H\n#define FREERDP_LIB_CORE_ORDERS_H\n\n#include \"rdp.h\"\n\n#include <freerdp/types.h>\n#include <freerdp/update.h>\n#include <freerdp/api.h>\n\n#include <winpr/stream.h>\n\n/* Order Control Flags */\n#define ORDER_STANDARD 0x01\n#define ORDER_SECONDARY 0x02\n#define ORDER_BOUNDS 0x04\n#define ORDER_TYPE_CHANGE 0x08\n#define ORDER_DELTA_COORDINATES 0x10\n#define ORDER_ZERO_BOUNDS_DELTAS 0x20\n#define ORDER_ZERO_FIELD_BYTE_BIT0 0x40\n#define ORDER_ZERO_FIELD_BYTE_BIT1 0x80\n\n/* Bound Field Flags */\n#define BOUND_LEFT 0x01\n#define BOUND_TOP 0x02\n#define BOUND_RIGHT 0x04\n#define BOUND_BOTTOM 0x08\n#define BOUND_DELTA_LEFT 0x10\n#define BOUND_DELTA_TOP 0x20\n#define BOUND_DELTA_RIGHT 0x40\n#define BOUND_DELTA_BOTTOM 0x80\n\n/* Field Presence Flags */\n#define ORDER_FIELD_01 0x000001\n#define ORDER_FIELD_02 0x000002\n#define ORDER_FIELD_03 0x000004\n#define ORDER_FIELD_04 0x000008\n#define ORDER_FIELD_05 0x000010\n#define ORDER_FIELD_06 0x000020\n#define ORDER_FIELD_07 0x000040\n#define ORDER_FIELD_08 0x000080\n#define ORDER_FIELD_09 0x000100\n#define ORDER_FIELD_10 0x000200\n#define ORDER_FIELD_11 0x000400\n#define ORDER_FIELD_12 0x000800\n#define ORDER_FIELD_13 0x001000\n#define ORDER_FIELD_14 0x002000\n#define ORDER_FIELD_15 0x004000\n#define ORDER_FIELD_16 0x008000\n#define ORDER_FIELD_17 0x010000\n#define ORDER_FIELD_18 0x020000\n#define ORDER_FIELD_19 0x040000\n#define ORDER_FIELD_20 0x080000\n#define ORDER_FIELD_21 0x100000\n#define ORDER_FIELD_22 0x200000\n#define ORDER_FIELD_23 0x400000\n\n/* Bitmap Cache Flags */\n#define CBR2_8BPP 0x3\n#define CBR2_16BPP 0x4\n#define CBR2_24BPP 0x5\n#define CBR2_32BPP 0x6\n\n#define CBR23_8BPP 0x3\n#define CBR23_16BPP 0x4\n#define CBR23_24BPP 0x5\n#define CBR23_32BPP 0x6\n\n#define CBR3_IGNORABLE_FLAG 0x08\n#define CBR3_DO_NOT_CACHE 0x10\n\n/* Primary Drawing Orders */\n#define ORDER_TYPE_DSTBLT 0x00\n#define ORDER_TYPE_PATBLT 0x01\n#define ORDER_TYPE_SCRBLT 0x02\n#define ORDER_TYPE_DRAW_NINE_GRID 0x07\n#define ORDER_TYPE_MULTI_DRAW_NINE_GRID 0x08\n#define ORDER_TYPE_LINE_TO 0x09\n#define ORDER_TYPE_OPAQUE_RECT 0x0A\n#define ORDER_TYPE_SAVE_BITMAP 0x0B\n#define ORDER_TYPE_MEMBLT 0x0D\n#define ORDER_TYPE_MEM3BLT 0x0E\n#define ORDER_TYPE_MULTI_DSTBLT 0x0F\n#define ORDER_TYPE_MULTI_PATBLT 0x10\n#define ORDER_TYPE_MULTI_SCRBLT 0x11\n#define ORDER_TYPE_MULTI_OPAQUE_RECT 0x12\n#define ORDER_TYPE_FAST_INDEX 0x13\n#define ORDER_TYPE_POLYGON_SC 0x14\n#define ORDER_TYPE_POLYGON_CB 0x15\n#define ORDER_TYPE_POLYLINE 0x16\n#define ORDER_TYPE_FAST_GLYPH 0x18\n#define ORDER_TYPE_ELLIPSE_SC 0x19\n#define ORDER_TYPE_ELLIPSE_CB 0x1A\n#define ORDER_TYPE_GLYPH_INDEX 0x1B\n\n/* Primary Drawing Orders Fields */\n#define DSTBLT_ORDER_FIELDS 5\n#define PATBLT_ORDER_FIELDS 12\n#define SCRBLT_ORDER_FIELDS 7\n#define DRAW_NINE_GRID_ORDER_FIELDS 5\n#define MULTI_DRAW_NINE_GRID_ORDER_FIELDS 7\n#define LINE_TO_ORDER_FIELDS 10\n#define OPAQUE_RECT_ORDER_FIELDS 7\n#define SAVE_BITMAP_ORDER_FIELDS 6\n#define MEMBLT_ORDER_FIELDS 9\n#define MEM3BLT_ORDER_FIELDS 16\n#define MULTI_DSTBLT_ORDER_FIELDS 7\n#define MULTI_PATBLT_ORDER_FIELDS 14\n#define MULTI_SCRBLT_ORDER_FIELDS 9\n#define MULTI_OPAQUE_RECT_ORDER_FIELDS 9\n#define FAST_INDEX_ORDER_FIELDS 15\n#define POLYGON_SC_ORDER_FIELDS 7\n#define POLYGON_CB_ORDER_FIELDS 13\n#define POLYLINE_ORDER_FIELDS 7\n#define FAST_GLYPH_ORDER_FIELDS 15\n#define ELLIPSE_SC_ORDER_FIELDS 7\n#define ELLIPSE_CB_ORDER_FIELDS 13\n#define GLYPH_INDEX_ORDER_FIELDS 22\n\n/* Primary Drawing Orders Field Bytes */\n#define DSTBLT_ORDER_FIELD_BYTES 1\n#define PATBLT_ORDER_FIELD_BYTES 2\n#define SCRBLT_ORDER_FIELD_BYTES 1\n#define DRAW_NINE_GRID_ORDER_FIELD_BYTES 1\n#define MULTI_DRAW_NINE_GRID_ORDER_FIELD_BYTES 1\n#define LINE_TO_ORDER_FIELD_BYTES 2\n#define OPAQUE_RECT_ORDER_FIELD_BYTES 1\n#define SAVE_BITMAP_ORDER_FIELD_BYTES 1\n#define MEMBLT_ORDER_FIELD_BYTES 2\n#define MEM3BLT_ORDER_FIELD_BYTES 3\n#define MULTI_DSTBLT_ORDER_FIELD_BYTES 1\n#define MULTI_PATBLT_ORDER_FIELD_BYTES 2\n#define MULTI_SCRBLT_ORDER_FIELD_BYTES 2\n#define MULTI_OPAQUE_RECT_ORDER_FIELD_BYTES 2\n#define FAST_INDEX_ORDER_FIELD_BYTES 2\n#define POLYGON_SC_ORDER_FIELD_BYTES 1\n#define POLYGON_CB_ORDER_FIELD_BYTES 2\n#define POLYLINE_ORDER_FIELD_BYTES 1\n#define FAST_GLYPH_ORDER_FIELD_BYTES 2\n#define ELLIPSE_SC_ORDER_FIELD_BYTES 1\n#define ELLIPSE_CB_ORDER_FIELD_BYTES 2\n#define GLYPH_INDEX_ORDER_FIELD_BYTES 3\n\n/* Secondary Drawing Orders */\n#define ORDER_TYPE_BITMAP_UNCOMPRESSED 0x00\n#define ORDER_TYPE_CACHE_COLOR_TABLE 0x01\n#define ORDER_TYPE_CACHE_BITMAP_COMPRESSED 0x02\n#define ORDER_TYPE_CACHE_GLYPH 0x03\n#define ORDER_TYPE_BITMAP_UNCOMPRESSED_V2 0x04\n#define ORDER_TYPE_BITMAP_COMPRESSED_V2 0x05\n#define ORDER_TYPE_CACHE_BRUSH 0x07\n#define ORDER_TYPE_BITMAP_COMPRESSED_V3 0x08\n\n/* Alternate Secondary Drawing Orders */\n#define ORDER_TYPE_SWITCH_SURFACE 0x00\n#define ORDER_TYPE_CREATE_OFFSCREEN_BITMAP 0x01\n#define ORDER_TYPE_STREAM_BITMAP_FIRST 0x02\n#define ORDER_TYPE_STREAM_BITMAP_NEXT 0x03\n#define ORDER_TYPE_CREATE_NINE_GRID_BITMAP 0x04\n#define ORDER_TYPE_GDIPLUS_FIRST 0x05\n#define ORDER_TYPE_GDIPLUS_NEXT 0x06\n#define ORDER_TYPE_GDIPLUS_END 0x07\n#define ORDER_TYPE_GDIPLUS_CACHE_FIRST 0x08\n#define ORDER_TYPE_GDIPLUS_CACHE_NEXT 0x09\n#define ORDER_TYPE_GDIPLUS_CACHE_END 0x0A\n#define ORDER_TYPE_WINDOW 0x0B\n#define ORDER_TYPE_COMPDESK_FIRST 0x0C\n#define ORDER_TYPE_FRAME_MARKER 0x0D\n\n#define CG_GLYPH_UNICODE_PRESENT 0x0010\n\nFREERDP_LOCAL extern const BYTE PRIMARY_DRAWING_ORDER_FIELD_BYTES[];\n\nFREERDP_LOCAL BOOL update_recv_order(rdpUpdate* update, wStream* s);\n\nFREERDP_LOCAL BOOL update_write_field_flags(wStream* s, UINT32 fieldFlags, BYTE flags,\n                                            BYTE fieldBytes);\n\nFREERDP_LOCAL BOOL update_write_bounds(wStream* s, ORDER_INFO* orderInfo);\n\nFREERDP_LOCAL int update_approximate_dstblt_order(ORDER_INFO* orderInfo,\n                                                  const DSTBLT_ORDER* dstblt);\nFREERDP_LOCAL BOOL update_write_dstblt_order(wStream* s, ORDER_INFO* orderInfo,\n                                             const DSTBLT_ORDER* dstblt);\n\nFREERDP_LOCAL int update_approximate_patblt_order(ORDER_INFO* orderInfo, PATBLT_ORDER* patblt);\nFREERDP_LOCAL BOOL update_write_patblt_order(wStream* s, ORDER_INFO* orderInfo,\n                                             PATBLT_ORDER* patblt);\n\nFREERDP_LOCAL int update_approximate_scrblt_order(ORDER_INFO* orderInfo,\n                                                  const SCRBLT_ORDER* scrblt);\nFREERDP_LOCAL BOOL update_write_scrblt_order(wStream* s, ORDER_INFO* orderInfo,\n                                             const SCRBLT_ORDER* scrblt);\n\nFREERDP_LOCAL int update_approximate_opaque_rect_order(ORDER_INFO* orderInfo,\n                                                       const OPAQUE_RECT_ORDER* opaque_rect);\nFREERDP_LOCAL BOOL update_write_opaque_rect_order(wStream* s, ORDER_INFO* orderInfo,\n                                                  const OPAQUE_RECT_ORDER* opaque_rect);\n\nFREERDP_LOCAL int update_approximate_line_to_order(ORDER_INFO* orderInfo,\n                                                   const LINE_TO_ORDER* line_to);\nFREERDP_LOCAL BOOL update_write_line_to_order(wStream* s, ORDER_INFO* orderInfo,\n                                              const LINE_TO_ORDER* line_to);\n\nFREERDP_LOCAL int update_approximate_memblt_order(ORDER_INFO* orderInfo,\n                                                  const MEMBLT_ORDER* memblt);\nFREERDP_LOCAL BOOL update_write_memblt_order(wStream* s, ORDER_INFO* orderInfo,\n                                             const MEMBLT_ORDER* memblt);\n\nFREERDP_LOCAL int update_approximate_glyph_index_order(ORDER_INFO* orderInfo,\n                                                       const GLYPH_INDEX_ORDER* glyph_index);\nFREERDP_LOCAL BOOL update_write_glyph_index_order(wStream* s, ORDER_INFO* orderInfo,\n                                                  GLYPH_INDEX_ORDER* glyph_index);\n\nFREERDP_LOCAL int update_approximate_cache_bitmap_order(const CACHE_BITMAP_ORDER* cache_bitmap,\n                                                        BOOL compressed, UINT16* flags);\nFREERDP_LOCAL BOOL update_write_cache_bitmap_order(wStream* s,\n                                                   const CACHE_BITMAP_ORDER* cache_bitmap_order,\n                                                   BOOL compressed, UINT16* flags);\n\nFREERDP_LOCAL int update_approximate_cache_bitmap_v2_order(CACHE_BITMAP_V2_ORDER* cache_bitmap_v2,\n                                                           BOOL compressed, UINT16* flags);\nFREERDP_LOCAL BOOL update_write_cache_bitmap_v2_order(wStream* s,\n                                                      CACHE_BITMAP_V2_ORDER* cache_bitmap_v2_order,\n                                                      BOOL compressed, UINT16* flags);\n\nFREERDP_LOCAL int update_approximate_cache_bitmap_v3_order(CACHE_BITMAP_V3_ORDER* cache_bitmap_v3,\n                                                           UINT16* flags);\nFREERDP_LOCAL BOOL update_write_cache_bitmap_v3_order(wStream* s,\n                                                      CACHE_BITMAP_V3_ORDER* cache_bitmap_v3_order,\n                                                      UINT16* flags);\n\nFREERDP_LOCAL int\nupdate_approximate_cache_color_table_order(const CACHE_COLOR_TABLE_ORDER* cache_color_table,\n                                           UINT16* flags);\nFREERDP_LOCAL BOOL update_write_cache_color_table_order(\n    wStream* s, const CACHE_COLOR_TABLE_ORDER* cache_color_table_order, UINT16* flags);\n\nFREERDP_LOCAL int update_approximate_cache_glyph_order(const CACHE_GLYPH_ORDER* cache_glyph,\n                                                       UINT16* flags);\nFREERDP_LOCAL BOOL update_write_cache_glyph_order(wStream* s,\n                                                  const CACHE_GLYPH_ORDER* cache_glyph_order,\n                                                  UINT16* flags);\n\nFREERDP_LOCAL int\nupdate_approximate_cache_glyph_v2_order(const CACHE_GLYPH_V2_ORDER* cache_glyph_v2, UINT16* flags);\nFREERDP_LOCAL BOOL update_write_cache_glyph_v2_order(wStream* s,\n                                                     const CACHE_GLYPH_V2_ORDER* cache_glyph_v2,\n                                                     UINT16* flags);\n\nFREERDP_LOCAL int update_approximate_cache_brush_order(const CACHE_BRUSH_ORDER* cache_brush,\n                                                       UINT16* flags);\nFREERDP_LOCAL BOOL update_write_cache_brush_order(wStream* s,\n                                                  const CACHE_BRUSH_ORDER* cache_brush_order,\n                                                  UINT16* flags);\n\nFREERDP_LOCAL int update_approximate_create_offscreen_bitmap_order(\n    const CREATE_OFFSCREEN_BITMAP_ORDER* create_offscreen_bitmap);\nFREERDP_LOCAL BOOL update_write_create_offscreen_bitmap_order(\n    wStream* s, const CREATE_OFFSCREEN_BITMAP_ORDER* create_offscreen_bitmap);\n\nFREERDP_LOCAL int\nupdate_approximate_switch_surface_order(const SWITCH_SURFACE_ORDER* switch_surface);\nFREERDP_LOCAL BOOL update_write_switch_surface_order(wStream* s,\n                                                     const SWITCH_SURFACE_ORDER* switch_surface);\n\n#endif /* FREERDP_LIB_CORE_ORDERS_H */\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Update Data PDUs\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2016 Armin Novak <armin.novak@thincast.com>\n * Copyright 2016 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n#include <winpr/print.h>\n#include <winpr/synch.h>\n#include <winpr/thread.h>\n#include <winpr/collections.h>\n\n#include \"update.h\"\n#include \"surface.h\"\n#include \"message.h\"\n#include \"info.h\"\n#include \"window.h\"\n\n#include <freerdp/log.h>\n#include <freerdp/peer.h>\n#include <freerdp/codec/bitmap.h>\n\n#include \"../cache/pointer.h\"\n#include \"../cache/palette.h\"\n#include \"../cache/bitmap.h\"\n\n#define TAG FREERDP_TAG(\"core.update\")\n\nstatic const char* const UPDATE_TYPE_STRINGS[] = { \"Orders\", \"Bitmap\", \"Palette\", \"Synchronize\" };\n\nstatic const char* update_type_to_string(UINT16 updateType)\n{\n\tif (updateType >= ARRAYSIZE(UPDATE_TYPE_STRINGS))\n\t\treturn \"UNKNOWN\";\n\n\treturn UPDATE_TYPE_STRINGS[updateType];\n}\n\nstatic BOOL update_recv_orders(rdpUpdate* update, wStream* s)\n{\n\tUINT16 numberOrders;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 6\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Seek_UINT16(s);               /* pad2OctetsA (2 bytes) */\n\tStream_Read_UINT16(s, numberOrders); /* numberOrders (2 bytes) */\n\tStream_Seek_UINT16(s);               /* pad2OctetsB (2 bytes) */\n\n\twhile (numberOrders > 0)\n\t{\n\t\tif (!update_recv_order(update, s))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"update_recv_order() failed\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tnumberOrders--;\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_read_bitmap_data(rdpUpdate* update, wStream* s, BITMAP_DATA* bitmapData)\n{\n\tWINPR_UNUSED(update);\n\tif (Stream_GetRemainingLength(s) < 18)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, bitmapData->destLeft);\n\tStream_Read_UINT16(s, bitmapData->destTop);\n\tStream_Read_UINT16(s, bitmapData->destRight);\n\tStream_Read_UINT16(s, bitmapData->destBottom);\n\tStream_Read_UINT16(s, bitmapData->width);\n\tStream_Read_UINT16(s, bitmapData->height);\n\tStream_Read_UINT16(s, bitmapData->bitsPerPixel);\n\tStream_Read_UINT16(s, bitmapData->flags);\n\tStream_Read_UINT16(s, bitmapData->bitmapLength);\n\n\tif (bitmapData->flags & BITMAP_COMPRESSION)\n\t{\n\t\tif (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\treturn FALSE;\n\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompMainBodySize); /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Read_UINT16(s, bitmapData->cbScanWidth);     /* cbScanWidth (2 bytes) */\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t\tbitmapData->bitmapLength = bitmapData->cbCompMainBodySize;\n\t\t}\n\n\t\tbitmapData->compressed = TRUE;\n\t}\n\telse\n\t\tbitmapData->compressed = FALSE;\n\n\tif (Stream_GetRemainingLength(s) < bitmapData->bitmapLength)\n\t\treturn FALSE;\n\n\tif (bitmapData->bitmapLength > 0)\n\t{\n\t\tbitmapData->bitmapDataStream = malloc(bitmapData->bitmapLength);\n\n\t\tif (!bitmapData->bitmapDataStream)\n\t\t\treturn FALSE;\n\n\t\tmemcpy(bitmapData->bitmapDataStream, Stream_Pointer(s), bitmapData->bitmapLength);\n\t\tStream_Seek(s, bitmapData->bitmapLength);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_write_bitmap_data(rdpUpdate* update, wStream* s, BITMAP_DATA* bitmapData)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, 64 + bitmapData->bitmapLength))\n\t\treturn FALSE;\n\n\tif (update->autoCalculateBitmapData)\n\t{\n\t\tbitmapData->flags = 0;\n\t\tbitmapData->cbCompFirstRowSize = 0;\n\n\t\tif (bitmapData->compressed)\n\t\t\tbitmapData->flags |= BITMAP_COMPRESSION;\n\n\t\tif (update->context->settings->NoBitmapCompressionHeader)\n\t\t{\n\t\t\tbitmapData->flags |= NO_BITMAP_COMPRESSION_HDR;\n\t\t\tbitmapData->cbCompMainBodySize = bitmapData->bitmapLength;\n\t\t}\n\t}\n\n\tStream_Write_UINT16(s, bitmapData->destLeft);\n\tStream_Write_UINT16(s, bitmapData->destTop);\n\tStream_Write_UINT16(s, bitmapData->destRight);\n\tStream_Write_UINT16(s, bitmapData->destBottom);\n\tStream_Write_UINT16(s, bitmapData->width);\n\tStream_Write_UINT16(s, bitmapData->height);\n\tStream_Write_UINT16(s, bitmapData->bitsPerPixel);\n\tStream_Write_UINT16(s, bitmapData->flags);\n\tStream_Write_UINT16(s, bitmapData->bitmapLength);\n\n\tif (bitmapData->flags & BITMAP_COMPRESSION)\n\t{\n\t\tif (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tStream_Write_UINT16(s,\n\t\t\t                    bitmapData->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Write_UINT16(s,\n\t\t\t                    bitmapData->cbCompMainBodySize); /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Write_UINT16(s, bitmapData->cbScanWidth);     /* cbScanWidth (2 bytes) */\n\t\t\tStream_Write_UINT16(s,\n\t\t\t                    bitmapData->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t}\n\n\t\tStream_Write(s, bitmapData->bitmapDataStream, bitmapData->bitmapLength);\n\t}\n\telse\n\t{\n\t\tStream_Write(s, bitmapData->bitmapDataStream, bitmapData->bitmapLength);\n\t}\n\n\treturn TRUE;\n}\n\nBITMAP_UPDATE* update_read_bitmap_update(rdpUpdate* update, wStream* s)\n{\n\tUINT32 i;\n\tBITMAP_UPDATE* bitmapUpdate = calloc(1, sizeof(BITMAP_UPDATE));\n\n\tif (!bitmapUpdate)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, bitmapUpdate->number); /* numberRectangles (2 bytes) */\n\tWLog_Print(update->log, WLOG_TRACE, \"BitmapUpdate: %\" PRIu32 \"\", bitmapUpdate->number);\n\n\tif (bitmapUpdate->number > bitmapUpdate->count)\n\t{\n\t\tUINT32 count = bitmapUpdate->number * 2;\n\t\tBITMAP_DATA* newdata =\n\t\t    (BITMAP_DATA*)realloc(bitmapUpdate->rectangles, sizeof(BITMAP_DATA) * count);\n\n\t\tif (!newdata)\n\t\t\tgoto fail;\n\n\t\tbitmapUpdate->rectangles = newdata;\n\t\tZeroMemory(&bitmapUpdate->rectangles[bitmapUpdate->count],\n\t\t           sizeof(BITMAP_DATA) * (count - bitmapUpdate->count));\n\t\tbitmapUpdate->count = count;\n\t}\n\n\t/* rectangles */\n\tfor (i = 0; i < bitmapUpdate->number; i++)\n\t{\n\t\tif (!update_read_bitmap_data(update, s, &bitmapUpdate->rectangles[i]))\n\t\t\tgoto fail;\n\t}\n\n\treturn bitmapUpdate;\nfail:\n\tfree_bitmap_update(update->context, bitmapUpdate);\n\treturn NULL;\n}\n\nstatic BOOL update_write_bitmap_update(rdpUpdate* update, wStream* s,\n                                       const BITMAP_UPDATE* bitmapUpdate)\n{\n\tint i;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, UPDATE_TYPE_BITMAP);   /* updateType */\n\tStream_Write_UINT16(s, bitmapUpdate->number); /* numberRectangles (2 bytes) */\n\n\t/* rectangles */\n\tfor (i = 0; i < (int)bitmapUpdate->number; i++)\n\t{\n\t\tif (!update_write_bitmap_data(update, s, &bitmapUpdate->rectangles[i]))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nPALETTE_UPDATE* update_read_palette(rdpUpdate* update, wStream* s)\n{\n\tint i;\n\tPALETTE_ENTRY* entry;\n\tPALETTE_UPDATE* palette_update = calloc(1, sizeof(PALETTE_UPDATE));\n\n\tif (!palette_update)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\tgoto fail;\n\n\tStream_Seek_UINT16(s);                         /* pad2Octets (2 bytes) */\n\tStream_Read_UINT32(s, palette_update->number); /* numberColors (4 bytes), must be set to 256 */\n\n\tif (palette_update->number > 256)\n\t\tpalette_update->number = 256;\n\n\tif (Stream_GetRemainingLength(s) < palette_update->number * 3)\n\t\tgoto fail;\n\n\t/* paletteEntries */\n\tfor (i = 0; i < (int)palette_update->number; i++)\n\t{\n\t\tentry = &palette_update->entries[i];\n\t\tStream_Read_UINT8(s, entry->red);\n\t\tStream_Read_UINT8(s, entry->green);\n\t\tStream_Read_UINT8(s, entry->blue);\n\t}\n\n\treturn palette_update;\nfail:\n\tfree_palette_update(update->context, palette_update);\n\treturn NULL;\n}\n\nstatic BOOL update_read_synchronize(rdpUpdate* update, wStream* s)\n{\n\tWINPR_UNUSED(update);\n\treturn Stream_SafeSeek(s, 2); /* pad2Octets (2 bytes) */\n\t                              /**\n\t                               * The Synchronize Update is an artifact from the\n\t                               * T.128 protocol and should be ignored.\n\t                               */\n}\n\nstatic BOOL update_read_play_sound(wStream* s, PLAY_SOUND_UPDATE* play_sound)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, play_sound->duration);  /* duration (4 bytes) */\n\tStream_Read_UINT32(s, play_sound->frequency); /* frequency (4 bytes) */\n\treturn TRUE;\n}\n\nBOOL update_recv_play_sound(rdpUpdate* update, wStream* s)\n{\n\tPLAY_SOUND_UPDATE play_sound;\n\n\tif (!update_read_play_sound(s, &play_sound))\n\t\treturn FALSE;\n\n\treturn IFCALLRESULT(FALSE, update->PlaySound, update->context, &play_sound);\n}\n\nPOINTER_POSITION_UPDATE* update_read_pointer_position(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_POSITION_UPDATE* pointer_position = calloc(1, sizeof(POINTER_POSITION_UPDATE));\n\n\tif (!pointer_position)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer_position->xPos); /* xPos (2 bytes) */\n\tStream_Read_UINT16(s, pointer_position->yPos); /* yPos (2 bytes) */\n\treturn pointer_position;\nfail:\n\tfree_pointer_position_update(update->context, pointer_position);\n\treturn NULL;\n}\n\nPOINTER_SYSTEM_UPDATE* update_read_pointer_system(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_SYSTEM_UPDATE* pointer_system = calloc(1, sizeof(POINTER_SYSTEM_UPDATE));\n\n\tif (!pointer_system)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\tgoto fail;\n\n\tStream_Read_UINT32(s, pointer_system->type); /* systemPointerType (4 bytes) */\n\treturn pointer_system;\nfail:\n\tfree_pointer_system_update(update->context, pointer_system);\n\treturn NULL;\n}\n\nstatic BOOL _update_read_pointer_color(wStream* s, POINTER_COLOR_UPDATE* pointer_color, BYTE xorBpp,\n                                       UINT32 flags)\n{\n\tBYTE* newMask;\n\tUINT32 scanlineSize;\n\tUINT32 max = 32;\n\n\tif (flags & LARGE_POINTER_FLAG_96x96)\n\t\tmax = 96;\n\n\tif (!pointer_color)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 14)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer_color->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Read_UINT16(s, pointer_color->xPos);       /* xPos (2 bytes) */\n\tStream_Read_UINT16(s, pointer_color->yPos);       /* yPos (2 bytes) */\n\t/**\n\t *  As stated in 2.2.9.1.1.4.4 Color Pointer Update:\n\t *  The maximum allowed pointer width/height is 96 pixels if the client indicated support\n\t *  for large pointers by setting the LARGE_POINTER_FLAG (0x00000001) in the Large\n\t *  Pointer Capability Set (section 2.2.7.2.7). If the LARGE_POINTER_FLAG was not\n\t *  set, the maximum allowed pointer width/height is 32 pixels.\n\t *\n\t *  So we check for a maximum for CVE-2014-0250.\n\t */\n\tStream_Read_UINT16(s, pointer_color->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, pointer_color->height); /* height (2 bytes) */\n\n\tif ((pointer_color->width > max) || (pointer_color->height > max))\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer_color->lengthAndMask); /* lengthAndMask (2 bytes) */\n\tStream_Read_UINT16(s, pointer_color->lengthXorMask); /* lengthXorMask (2 bytes) */\n\n\t/**\n\t * There does not seem to be any documentation on why\n\t * xPos / yPos can be larger than width / height\n\t * so it is missing in documentation or a bug in implementation\n\t * 2.2.9.1.1.4.4 Color Pointer Update (TS_COLORPOINTERATTRIBUTE)\n\t */\n\tif (pointer_color->xPos >= pointer_color->width)\n\t\tpointer_color->xPos = 0;\n\n\tif (pointer_color->yPos >= pointer_color->height)\n\t\tpointer_color->yPos = 0;\n\n\tif (pointer_color->lengthXorMask > 0)\n\t{\n\t\t/**\n\t\t * Spec states that:\n\t\t *\n\t\t * xorMaskData (variable): A variable-length array of bytes. Contains the 24-bpp, bottom-up\n\t\t * XOR mask scan-line data. The XOR mask is padded to a 2-byte boundary for each encoded\n\t\t * scan-line. For example, if a 3x3 pixel cursor is being sent, then each scan-line will\n\t\t * consume 10 bytes (3 pixels per scan-line multiplied by 3 bytes per pixel, rounded up to\n\t\t * the next even number of bytes).\n\t\t *\n\t\t * In fact instead of 24-bpp, the bpp parameter is given by the containing packet.\n\t\t */\n\t\tif (Stream_GetRemainingLength(s) < pointer_color->lengthXorMask)\n\t\t\tgoto fail;\n\n\t\tscanlineSize = (7 + xorBpp * pointer_color->width) / 8;\n\t\tscanlineSize = ((scanlineSize + 1) / 2) * 2;\n\n\t\tif (scanlineSize * pointer_color->height != pointer_color->lengthXorMask)\n\t\t{\n\t\t\tWLog_ERR(TAG,\n\t\t\t         \"invalid lengthXorMask: width=%\" PRIu32 \" height=%\" PRIu32 \", %\" PRIu32\n\t\t\t         \" instead of %\" PRIu32 \"\",\n\t\t\t         pointer_color->width, pointer_color->height, pointer_color->lengthXorMask,\n\t\t\t         scanlineSize * pointer_color->height);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnewMask = realloc(pointer_color->xorMaskData, pointer_color->lengthXorMask);\n\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\n\t\tpointer_color->xorMaskData = newMask;\n\t\tStream_Read(s, pointer_color->xorMaskData, pointer_color->lengthXorMask);\n\t}\n\n\tif (pointer_color->lengthAndMask > 0)\n\t{\n\t\t/**\n\t\t * andMaskData (variable): A variable-length array of bytes. Contains the 1-bpp, bottom-up\n\t\t * AND mask scan-line data. The AND mask is padded to a 2-byte boundary for each encoded\n\t\t * scan-line. For example, if a 7x7 pixel cursor is being sent, then each scan-line will\n\t\t * consume 2 bytes (7 pixels per scan-line multiplied by 1 bpp, rounded up to the next even\n\t\t * number of bytes).\n\t\t */\n\t\tif (Stream_GetRemainingLength(s) < pointer_color->lengthAndMask)\n\t\t\tgoto fail;\n\n\t\tscanlineSize = ((7 + pointer_color->width) / 8);\n\t\tscanlineSize = ((1 + scanlineSize) / 2) * 2;\n\n\t\tif (scanlineSize * pointer_color->height != pointer_color->lengthAndMask)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"invalid lengthAndMask: %\" PRIu32 \" instead of %\" PRIu32 \"\",\n\t\t\t         pointer_color->lengthAndMask, scanlineSize * pointer_color->height);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnewMask = realloc(pointer_color->andMaskData, pointer_color->lengthAndMask);\n\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\n\t\tpointer_color->andMaskData = newMask;\n\t\tStream_Read(s, pointer_color->andMaskData, pointer_color->lengthAndMask);\n\t}\n\n\tif (Stream_GetRemainingLength(s) > 0)\n\t\tStream_Seek_UINT8(s); /* pad (1 byte) */\n\n\treturn TRUE;\nfail:\n\treturn FALSE;\n}\n\nPOINTER_COLOR_UPDATE* update_read_pointer_color(rdpUpdate* update, wStream* s, BYTE xorBpp)\n{\n\tPOINTER_COLOR_UPDATE* pointer_color = calloc(1, sizeof(POINTER_COLOR_UPDATE));\n\n\tif (!pointer_color)\n\t\tgoto fail;\n\n\tif (!_update_read_pointer_color(s, pointer_color, xorBpp,\n\t                                update->context->settings->LargePointerFlag))\n\t\tgoto fail;\n\n\treturn pointer_color;\nfail:\n\tfree_pointer_color_update(update->context, pointer_color);\n\treturn NULL;\n}\n\nstatic BOOL _update_read_pointer_large(wStream* s, POINTER_LARGE_UPDATE* pointer)\n{\n\tBYTE* newMask;\n\tUINT32 scanlineSize;\n\n\tif (!pointer)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 20)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer->xorBpp);\n\tStream_Read_UINT16(s, pointer->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Read_UINT16(s, pointer->hotSpotX);   /* xPos (2 bytes) */\n\tStream_Read_UINT16(s, pointer->hotSpotY);   /* yPos (2 bytes) */\n\n\tStream_Read_UINT16(s, pointer->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, pointer->height); /* height (2 bytes) */\n\n\tif ((pointer->width > 384) || (pointer->height > 384))\n\t\tgoto fail;\n\n\tStream_Read_UINT32(s, pointer->lengthAndMask); /* lengthAndMask (4 bytes) */\n\tStream_Read_UINT32(s, pointer->lengthXorMask); /* lengthXorMask (4 bytes) */\n\n\tif (pointer->hotSpotX >= pointer->width)\n\t\tpointer->hotSpotX = 0;\n\n\tif (pointer->hotSpotY >= pointer->height)\n\t\tpointer->hotSpotY = 0;\n\n\tif (pointer->lengthXorMask > 0)\n\t{\n\t\t/**\n\t\t * Spec states that:\n\t\t *\n\t\t * xorMaskData (variable): A variable-length array of bytes. Contains the 24-bpp, bottom-up\n\t\t * XOR mask scan-line data. The XOR mask is padded to a 2-byte boundary for each encoded\n\t\t * scan-line. For example, if a 3x3 pixel cursor is being sent, then each scan-line will\n\t\t * consume 10 bytes (3 pixels per scan-line multiplied by 3 bytes per pixel, rounded up to\n\t\t * the next even number of bytes).\n\t\t *\n\t\t * In fact instead of 24-bpp, the bpp parameter is given by the containing packet.\n\t\t */\n\t\tif (Stream_GetRemainingLength(s) < pointer->lengthXorMask)\n\t\t\tgoto fail;\n\n\t\tscanlineSize = (7 + pointer->xorBpp * pointer->width) / 8;\n\t\tscanlineSize = ((scanlineSize + 1) / 2) * 2;\n\n\t\tif (scanlineSize * pointer->height != pointer->lengthXorMask)\n\t\t{\n\t\t\tWLog_ERR(TAG,\n\t\t\t         \"invalid lengthXorMask: width=%\" PRIu32 \" height=%\" PRIu32 \", %\" PRIu32\n\t\t\t         \" instead of %\" PRIu32 \"\",\n\t\t\t         pointer->width, pointer->height, pointer->lengthXorMask,\n\t\t\t         scanlineSize * pointer->height);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnewMask = realloc(pointer->xorMaskData, pointer->lengthXorMask);\n\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\n\t\tpointer->xorMaskData = newMask;\n\t\tStream_Read(s, pointer->xorMaskData, pointer->lengthXorMask);\n\t}\n\n\tif (pointer->lengthAndMask > 0)\n\t{\n\t\t/**\n\t\t * andMaskData (variable): A variable-length array of bytes. Contains the 1-bpp, bottom-up\n\t\t * AND mask scan-line data. The AND mask is padded to a 2-byte boundary for each encoded\n\t\t * scan-line. For example, if a 7x7 pixel cursor is being sent, then each scan-line will\n\t\t * consume 2 bytes (7 pixels per scan-line multiplied by 1 bpp, rounded up to the next even\n\t\t * number of bytes).\n\t\t */\n\t\tif (Stream_GetRemainingLength(s) < pointer->lengthAndMask)\n\t\t\tgoto fail;\n\n\t\tscanlineSize = ((7 + pointer->width) / 8);\n\t\tscanlineSize = ((1 + scanlineSize) / 2) * 2;\n\n\t\tif (scanlineSize * pointer->height != pointer->lengthAndMask)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"invalid lengthAndMask: %\" PRIu32 \" instead of %\" PRIu32 \"\",\n\t\t\t         pointer->lengthAndMask, scanlineSize * pointer->height);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnewMask = realloc(pointer->andMaskData, pointer->lengthAndMask);\n\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\n\t\tpointer->andMaskData = newMask;\n\t\tStream_Read(s, pointer->andMaskData, pointer->lengthAndMask);\n\t}\n\n\tif (Stream_GetRemainingLength(s) > 0)\n\t\tStream_Seek_UINT8(s); /* pad (1 byte) */\n\n\treturn TRUE;\nfail:\n\treturn FALSE;\n}\n\nPOINTER_LARGE_UPDATE* update_read_pointer_large(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_LARGE_UPDATE* pointer = calloc(1, sizeof(POINTER_LARGE_UPDATE));\n\n\tif (!pointer)\n\t\tgoto fail;\n\n\tif (!_update_read_pointer_large(s, pointer))\n\t\tgoto fail;\n\n\treturn pointer;\nfail:\n\tfree_pointer_large_update(update->context, pointer);\n\treturn NULL;\n}\n\nPOINTER_NEW_UPDATE* update_read_pointer_new(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_NEW_UPDATE* pointer_new = calloc(1, sizeof(POINTER_NEW_UPDATE));\n\n\tif (!pointer_new)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer_new->xorBpp); /* xorBpp (2 bytes) */\n\n\tif ((pointer_new->xorBpp < 1) || (pointer_new->xorBpp > 32))\n\t{\n\t\tWLog_ERR(TAG, \"invalid xorBpp %\" PRIu32 \"\", pointer_new->xorBpp);\n\t\tgoto fail;\n\t}\n\n\tif (!_update_read_pointer_color(s, &pointer_new->colorPtrAttr, pointer_new->xorBpp,\n\t                                update->context->settings->LargePointerFlag)) /* colorPtrAttr */\n\t\tgoto fail;\n\n\treturn pointer_new;\nfail:\n\tfree_pointer_new_update(update->context, pointer_new);\n\treturn NULL;\n}\n\nPOINTER_CACHED_UPDATE* update_read_pointer_cached(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_CACHED_UPDATE* pointer = calloc(1, sizeof(POINTER_CACHED_UPDATE));\n\n\tif (!pointer)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer->cacheIndex); /* cacheIndex (2 bytes) */\n\treturn pointer;\nfail:\n\tfree_pointer_cached_update(update->context, pointer);\n\treturn NULL;\n}\n\nBOOL update_recv_pointer(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = FALSE;\n\tUINT16 messageType;\n\trdpContext* context = update->context;\n\trdpPointerUpdate* pointer = update->pointer;\n\n\tif (Stream_GetRemainingLength(s) < 2 + 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, messageType); /* messageType (2 bytes) */\n\tStream_Seek_UINT16(s);              /* pad2Octets (2 bytes) */\n\n\tswitch (messageType)\n\t{\n\t\tcase PTR_MSG_TYPE_POSITION:\n\t\t{\n\t\t\tPOINTER_POSITION_UPDATE* pointer_position = update_read_pointer_position(update, s);\n\n\t\t\tif (pointer_position)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerPosition, context, pointer_position);\n\t\t\t\tfree_pointer_position_update(context, pointer_position);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_SYSTEM:\n\t\t{\n\t\t\tPOINTER_SYSTEM_UPDATE* pointer_system = update_read_pointer_system(update, s);\n\n\t\t\tif (pointer_system)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerSystem, context, pointer_system);\n\t\t\t\tfree_pointer_system_update(context, pointer_system);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_COLOR:\n\t\t{\n\t\t\tPOINTER_COLOR_UPDATE* pointer_color = update_read_pointer_color(update, s, 24);\n\n\t\t\tif (pointer_color)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerColor, context, pointer_color);\n\t\t\t\tfree_pointer_color_update(context, pointer_color);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_POINTER_LARGE:\n\t\t{\n\t\t\tPOINTER_LARGE_UPDATE* pointer_large = update_read_pointer_large(update, s);\n\n\t\t\tif (pointer_large)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerLarge, context, pointer_large);\n\t\t\t\tfree_pointer_large_update(context, pointer_large);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_POINTER:\n\t\t{\n\t\t\tPOINTER_NEW_UPDATE* pointer_new = update_read_pointer_new(update, s);\n\n\t\t\tif (pointer_new)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerNew, context, pointer_new);\n\t\t\t\tfree_pointer_new_update(context, pointer_new);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_CACHED:\n\t\t{\n\t\t\tPOINTER_CACHED_UPDATE* pointer_cached = update_read_pointer_cached(update, s);\n\n\t\t\tif (pointer_cached)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerCached, context, pointer_cached);\n\t\t\t\tfree_pointer_cached_update(context, pointer_cached);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nBOOL update_recv(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = FALSE;\n\tUINT16 updateType;\n\trdpContext* context = update->context;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 2\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, updateType); /* updateType (2 bytes) */\n\tWLog_Print(update->log, WLOG_TRACE, \"%s Update Data PDU\", update_type_to_string(updateType));\n\n\tif (!update_begin_paint(update))\n\t\tgoto fail;\n\n\tswitch (updateType)\n\t{\n\t\tcase UPDATE_TYPE_ORDERS:\n\t\t\trc = update_recv_orders(update, s);\n\t\t\tbreak;\n\n\t\tcase UPDATE_TYPE_BITMAP:\n\t\t{\n\t\t\tBITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s);\n\n\t\t\tif (!bitmap_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update);\n\t\t\tfree_bitmap_update(update->context, bitmap_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_PALETTE:\n\t\t{\n\t\t\tPALETTE_UPDATE* palette_update = update_read_palette(update, s);\n\n\t\t\tif (!palette_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_PALETTE - update_read_palette() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);\n\t\t\tfree_palette_update(context, palette_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_SYNCHRONIZE:\n\t\t\tif (!update_read_synchronize(update, s))\n\t\t\t\tgoto fail;\n\t\t\trc = IFCALLRESULT(TRUE, update->Synchronize, context);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\nfail:\n\n\tif (!update_end_paint(update))\n\t\trc = FALSE;\n\n\tif (!rc)\n\t{\n\t\tWLog_ERR(TAG, \"UPDATE_TYPE %s [%\" PRIu16 \"] failed\", update_type_to_string(updateType),\n\t\t         updateType);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nvoid update_reset_state(rdpUpdate* update)\n{\n\trdpPrimaryUpdate* primary = update->primary;\n\trdpAltSecUpdate* altsec = update->altsec;\n\n\tif (primary->fast_glyph.glyphData.aj)\n\t{\n\t\tfree(primary->fast_glyph.glyphData.aj);\n\t\tprimary->fast_glyph.glyphData.aj = NULL;\n\t}\n\n\tZeroMemory(&primary->order_info, sizeof(ORDER_INFO));\n\tZeroMemory(&primary->dstblt, sizeof(DSTBLT_ORDER));\n\tZeroMemory(&primary->patblt, sizeof(PATBLT_ORDER));\n\tZeroMemory(&primary->scrblt, sizeof(SCRBLT_ORDER));\n\tZeroMemory(&primary->opaque_rect, sizeof(OPAQUE_RECT_ORDER));\n\tZeroMemory(&primary->draw_nine_grid, sizeof(DRAW_NINE_GRID_ORDER));\n\tZeroMemory(&primary->multi_dstblt, sizeof(MULTI_DSTBLT_ORDER));\n\tZeroMemory(&primary->multi_patblt, sizeof(MULTI_PATBLT_ORDER));\n\tZeroMemory(&primary->multi_scrblt, sizeof(MULTI_SCRBLT_ORDER));\n\tZeroMemory(&primary->multi_opaque_rect, sizeof(MULTI_OPAQUE_RECT_ORDER));\n\tZeroMemory(&primary->multi_draw_nine_grid, sizeof(MULTI_DRAW_NINE_GRID_ORDER));\n\tZeroMemory(&primary->line_to, sizeof(LINE_TO_ORDER));\n\tZeroMemory(&primary->polyline, sizeof(POLYLINE_ORDER));\n\tZeroMemory(&primary->memblt, sizeof(MEMBLT_ORDER));\n\tZeroMemory(&primary->mem3blt, sizeof(MEM3BLT_ORDER));\n\tZeroMemory(&primary->save_bitmap, sizeof(SAVE_BITMAP_ORDER));\n\tZeroMemory(&primary->glyph_index, sizeof(GLYPH_INDEX_ORDER));\n\tZeroMemory(&primary->fast_index, sizeof(FAST_INDEX_ORDER));\n\tZeroMemory(&primary->fast_glyph, sizeof(FAST_GLYPH_ORDER));\n\tZeroMemory(&primary->polygon_sc, sizeof(POLYGON_SC_ORDER));\n\tZeroMemory(&primary->polygon_cb, sizeof(POLYGON_CB_ORDER));\n\tZeroMemory(&primary->ellipse_sc, sizeof(ELLIPSE_SC_ORDER));\n\tZeroMemory(&primary->ellipse_cb, sizeof(ELLIPSE_CB_ORDER));\n\tprimary->order_info.orderType = ORDER_TYPE_PATBLT;\n\n\tif (!update->initialState)\n\t{\n\t\taltsec->switch_surface.bitmapId = SCREEN_BITMAP_SURFACE;\n\t\tIFCALL(altsec->SwitchSurface, update->context, &(altsec->switch_surface));\n\t}\n}\n\nBOOL update_post_connect(rdpUpdate* update)\n{\n\tupdate->asynchronous = update->context->settings->AsyncUpdate;\n\n\tif (update->asynchronous)\n\t\tif (!(update->proxy = update_message_proxy_new(update)))\n\t\t\treturn FALSE;\n\n\tupdate->altsec->switch_surface.bitmapId = SCREEN_BITMAP_SURFACE;\n\tIFCALL(update->altsec->SwitchSurface, update->context, &(update->altsec->switch_surface));\n\tupdate->initialState = FALSE;\n\treturn TRUE;\n}\n\nvoid update_post_disconnect(rdpUpdate* update)\n{\n\tupdate->asynchronous = update->context->settings->AsyncUpdate;\n\n\tif (update->asynchronous)\n\t\tupdate_message_proxy_free(update->proxy);\n\n\tupdate->initialState = TRUE;\n}\n\nstatic BOOL _update_begin_paint(rdpContext* context)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\n\tif (update->us)\n\t{\n\t\tif (!update_end_paint(update))\n\t\t\treturn FALSE;\n\t}\n\n\ts = fastpath_update_pdu_init_new(context->rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_SealLength(s);\n\tStream_Seek(s, 2); /* numberOrders (2 bytes) */\n\tupdate->combineUpdates = TRUE;\n\tupdate->numberOrders = 0;\n\tupdate->us = s;\n\treturn TRUE;\n}\n\nstatic BOOL _update_end_paint(rdpContext* context)\n{\n\twStream* s;\n\tint headerLength;\n\trdpUpdate* update = context->update;\n\n\tif (!update->us)\n\t\treturn FALSE;\n\n\ts = update->us;\n\theaderLength = Stream_Length(s);\n\tStream_SealLength(s);\n\tStream_SetPosition(s, headerLength);\n\tStream_Write_UINT16(s, update->numberOrders); /* numberOrders (2 bytes) */\n\tStream_SetPosition(s, Stream_Length(s));\n\n\tif (update->numberOrders > 0)\n\t{\n\t\tWLog_DBG(TAG, \"sending %\" PRIu16 \" orders\", update->numberOrders);\n\t\tfastpath_send_update_pdu(context->rdp->fastpath, FASTPATH_UPDATETYPE_ORDERS, s, FALSE);\n\t}\n\n\tupdate->combineUpdates = FALSE;\n\tupdate->numberOrders = 0;\n\tupdate->us = NULL;\n\tStream_Free(s, TRUE);\n\treturn TRUE;\n}\n\nstatic void update_flush(rdpContext* context)\n{\n\trdpUpdate* update = context->update;\n\n\tif (update->numberOrders > 0)\n\t{\n\t\tupdate_end_paint(update);\n\t\tupdate_begin_paint(update);\n\t}\n}\n\nstatic void update_force_flush(rdpContext* context)\n{\n\tupdate_flush(context);\n}\n\nstatic BOOL update_check_flush(rdpContext* context, int size)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\ts = update->us;\n\n\tif (!update->us)\n\t{\n\t\tupdate_begin_paint(update);\n\t\treturn FALSE;\n\t}\n\n\tif (Stream_GetPosition(s) + size + 64 >= 0x3FFF)\n\t{\n\t\tupdate_flush(context);\n\t\treturn TRUE;\n\t}\n\n\treturn FALSE;\n}\n\nstatic BOOL update_set_bounds(rdpContext* context, const rdpBounds* bounds)\n{\n\trdpUpdate* update = context->update;\n\tCopyMemory(&update->previousBounds, &update->currentBounds, sizeof(rdpBounds));\n\n\tif (!bounds)\n\t\tZeroMemory(&update->currentBounds, sizeof(rdpBounds));\n\telse\n\t\tCopyMemory(&update->currentBounds, bounds, sizeof(rdpBounds));\n\n\treturn TRUE;\n}\n\nstatic BOOL update_bounds_is_null(rdpBounds* bounds)\n{\n\tif ((bounds->left == 0) && (bounds->top == 0) && (bounds->right == 0) && (bounds->bottom == 0))\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n\nstatic BOOL update_bounds_equals(rdpBounds* bounds1, rdpBounds* bounds2)\n{\n\tif ((bounds1->left == bounds2->left) && (bounds1->top == bounds2->top) &&\n\t    (bounds1->right == bounds2->right) && (bounds1->bottom == bounds2->bottom))\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n\nstatic int update_prepare_bounds(rdpContext* context, ORDER_INFO* orderInfo)\n{\n\tint length = 0;\n\trdpUpdate* update = context->update;\n\torderInfo->boundsFlags = 0;\n\n\tif (update_bounds_is_null(&update->currentBounds))\n\t\treturn 0;\n\n\torderInfo->controlFlags |= ORDER_BOUNDS;\n\n\tif (update_bounds_equals(&update->previousBounds, &update->currentBounds))\n\t{\n\t\torderInfo->controlFlags |= ORDER_ZERO_BOUNDS_DELTAS;\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tlength += 1;\n\n\t\tif (update->previousBounds.left != update->currentBounds.left)\n\t\t{\n\t\t\torderInfo->bounds.left = update->currentBounds.left;\n\t\t\torderInfo->boundsFlags |= BOUND_LEFT;\n\t\t\tlength += 2;\n\t\t}\n\n\t\tif (update->previousBounds.top != update->currentBounds.top)\n\t\t{\n\t\t\torderInfo->bounds.top = update->currentBounds.top;\n\t\t\torderInfo->boundsFlags |= BOUND_TOP;\n\t\t\tlength += 2;\n\t\t}\n\n\t\tif (update->previousBounds.right != update->currentBounds.right)\n\t\t{\n\t\t\torderInfo->bounds.right = update->currentBounds.right;\n\t\t\torderInfo->boundsFlags |= BOUND_RIGHT;\n\t\t\tlength += 2;\n\t\t}\n\n\t\tif (update->previousBounds.bottom != update->currentBounds.bottom)\n\t\t{\n\t\t\torderInfo->bounds.bottom = update->currentBounds.bottom;\n\t\t\torderInfo->boundsFlags |= BOUND_BOTTOM;\n\t\t\tlength += 2;\n\t\t}\n\t}\n\n\treturn length;\n}\n\nstatic int update_prepare_order_info(rdpContext* context, ORDER_INFO* orderInfo, UINT32 orderType)\n{\n\tint length = 1;\n\torderInfo->fieldFlags = 0;\n\torderInfo->orderType = orderType;\n\torderInfo->controlFlags = ORDER_STANDARD;\n\torderInfo->controlFlags |= ORDER_TYPE_CHANGE;\n\tlength += 1;\n\tlength += PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType];\n\tlength += update_prepare_bounds(context, orderInfo);\n\treturn length;\n}\n\nstatic int update_write_order_info(rdpContext* context, wStream* s, ORDER_INFO* orderInfo,\n                                   size_t offset)\n{\n\tsize_t position;\n\tWINPR_UNUSED(context);\n\tposition = Stream_GetPosition(s);\n\tStream_SetPosition(s, offset);\n\tStream_Write_UINT8(s, orderInfo->controlFlags); /* controlFlags (1 byte) */\n\n\tif (orderInfo->controlFlags & ORDER_TYPE_CHANGE)\n\t\tStream_Write_UINT8(s, orderInfo->orderType); /* orderType (1 byte) */\n\n\tupdate_write_field_flags(s, orderInfo->fieldFlags, orderInfo->controlFlags,\n\t                         PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType]);\n\tupdate_write_bounds(s, orderInfo);\n\tStream_SetPosition(s, position);\n\treturn 0;\n}\n\nstatic void update_write_refresh_rect(wStream* s, BYTE count, const RECTANGLE_16* areas)\n{\n\tint i;\n\tStream_Write_UINT8(s, count); /* numberOfAreas (1 byte) */\n\tStream_Seek(s, 3);            /* pad3Octets (3 bytes) */\n\n\tfor (i = 0; i < count; i++)\n\t{\n\t\tStream_Write_UINT16(s, areas[i].left);   /* left (2 bytes) */\n\t\tStream_Write_UINT16(s, areas[i].top);    /* top (2 bytes) */\n\t\tStream_Write_UINT16(s, areas[i].right);  /* right (2 bytes) */\n\t\tStream_Write_UINT16(s, areas[i].bottom); /* bottom (2 bytes) */\n\t}\n}\n\nstatic BOOL update_send_refresh_rect(rdpContext* context, BYTE count, const RECTANGLE_16* areas)\n{\n\trdpRdp* rdp = context->rdp;\n\n\tif (rdp->settings->RefreshRect)\n\t{\n\t\twStream* s = rdp_data_pdu_init(rdp);\n\n\t\tif (!s)\n\t\t\treturn FALSE;\n\n\t\tupdate_write_refresh_rect(s, count, areas);\n\t\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_REFRESH_RECT, rdp->mcs->userId);\n\t}\n\n\treturn TRUE;\n}\n\nstatic void update_write_suppress_output(wStream* s, BYTE allow, const RECTANGLE_16* area)\n{\n\tStream_Write_UINT8(s, allow); /* allowDisplayUpdates (1 byte) */\n\t/* Use zeros for padding (like mstsc) for compatibility with legacy servers */\n\tStream_Zero(s, 3); /* pad3Octets (3 bytes) */\n\n\tif (allow > 0)\n\t{\n\t\tStream_Write_UINT16(s, area->left);   /* left (2 bytes) */\n\t\tStream_Write_UINT16(s, area->top);    /* top (2 bytes) */\n\t\tStream_Write_UINT16(s, area->right);  /* right (2 bytes) */\n\t\tStream_Write_UINT16(s, area->bottom); /* bottom (2 bytes) */\n\t}\n}\n\nstatic BOOL update_send_suppress_output(rdpContext* context, BYTE allow, const RECTANGLE_16* area)\n{\n\trdpRdp* rdp = context->rdp;\n\n\tif (rdp->settings->SuppressOutput)\n\t{\n\t\twStream* s = rdp_data_pdu_init(rdp);\n\n\t\tif (!s)\n\t\t\treturn FALSE;\n\n\t\tupdate_write_suppress_output(s, allow, area);\n\t\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_SUPPRESS_OUTPUT, rdp->mcs->userId);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_send_surface_command(rdpContext* context, wStream* s)\n{\n\twStream* update;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\tupdate = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!update)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(update, Stream_GetPosition(s)))\n\t{\n\t\tret = FALSE;\n\t\tgoto out;\n\t}\n\n\tStream_Write(update, Stream_Buffer(s), Stream_GetPosition(s));\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS, update, FALSE);\nout:\n\tStream_Release(update);\n\treturn ret;\n}\n\nstatic BOOL update_send_surface_bits(rdpContext* context,\n                                     const SURFACE_BITS_COMMAND* surfaceBitsCommand)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_surfcmd_surface_bits(s, surfaceBitsCommand))\n\t\tgoto out_fail;\n\n\tif (!fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS, s,\n\t                              surfaceBitsCommand->skipCompression))\n\t\tgoto out_fail;\n\n\tupdate_force_flush(context);\n\tret = TRUE;\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_surface_frame_marker(rdpContext* context,\n                                             const SURFACE_FRAME_MARKER* surfaceFrameMarker)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_surfcmd_frame_marker(s, surfaceFrameMarker->frameAction,\n\t                                       surfaceFrameMarker->frameId) ||\n\t    !fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS, s, FALSE))\n\t\tgoto out_fail;\n\n\tupdate_force_flush(context);\n\tret = TRUE;\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_surface_frame_bits(rdpContext* context, const SURFACE_BITS_COMMAND* cmd,\n                                           BOOL first, BOOL last, UINT32 frameId)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (first)\n\t{\n\t\tif (!update_write_surfcmd_frame_marker(s, SURFACECMD_FRAMEACTION_BEGIN, frameId))\n\t\t\tgoto out_fail;\n\t}\n\n\tif (!update_write_surfcmd_surface_bits(s, cmd))\n\t\tgoto out_fail;\n\n\tif (last)\n\t{\n\t\tif (!update_write_surfcmd_frame_marker(s, SURFACECMD_FRAMEACTION_END, frameId))\n\t\t\tgoto out_fail;\n\t}\n\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS, s,\n\t                               cmd->skipCompression);\n\tupdate_force_flush(context);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_frame_acknowledge(rdpContext* context, UINT32 frameId)\n{\n\trdpRdp* rdp = context->rdp;\n\n\tif (rdp->settings->ReceivedCapabilities[CAPSET_TYPE_FRAME_ACKNOWLEDGE])\n\t{\n\t\twStream* s = rdp_data_pdu_init(rdp);\n\n\t\tif (!s)\n\t\t\treturn FALSE;\n\n\t\tStream_Write_UINT32(s, frameId);\n\t\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_FRAME_ACKNOWLEDGE, rdp->mcs->userId);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_send_synchronize(rdpContext* context)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Zero(s, 2); /* pad2Octets (2 bytes) */\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SYNCHRONIZE, s, FALSE);\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_desktop_resize(rdpContext* context)\n{\n\treturn rdp_server_reactivate(context->rdp);\n}\n\nstatic BOOL update_send_bitmap_update(rdpContext* context, const BITMAP_UPDATE* bitmapUpdate)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\trdpUpdate* update = context->update;\n\tBOOL ret = TRUE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_bitmap_update(update, s, bitmapUpdate) ||\n\t    !fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_BITMAP, s,\n\t                              bitmapUpdate->skipCompression))\n\t{\n\t\tret = FALSE;\n\t\tgoto out_fail;\n\t}\n\n\tupdate_force_flush(context);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_play_sound(rdpContext* context, const PLAY_SOUND_UPDATE* play_sound)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\n\tif (!rdp->settings->ReceivedCapabilities[CAPSET_TYPE_SOUND])\n\t{\n\t\treturn TRUE;\n\t}\n\n\ts = rdp_data_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT32(s, play_sound->duration);\n\tStream_Write_UINT32(s, play_sound->frequency);\n\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_PLAY_SOUND, rdp->mcs->userId);\n}\n\n/**\n * Primary Drawing Orders\n */\n\nstatic BOOL update_send_dstblt(rdpContext* context, const DSTBLT_ORDER* dstblt)\n{\n\twStream* s;\n\tUINT32 offset;\n\tUINT32 headerLength;\n\tORDER_INFO orderInfo;\n\tint inf;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_DSTBLT);\n\tinf = update_approximate_dstblt_order(&orderInfo, dstblt);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_dstblt_order(s, &orderInfo, dstblt))\n\t\treturn FALSE;\n\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_patblt(rdpContext* context, PATBLT_ORDER* patblt)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_PATBLT);\n\tupdate_check_flush(context, headerLength + update_approximate_patblt_order(&orderInfo, patblt));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_patblt_order(s, &orderInfo, patblt);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_scrblt(rdpContext* context, const SCRBLT_ORDER* scrblt)\n{\n\twStream* s;\n\tUINT32 offset;\n\tUINT32 headerLength;\n\tORDER_INFO orderInfo;\n\tint inf;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_SCRBLT);\n\tinf = update_approximate_scrblt_order(&orderInfo, scrblt);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn TRUE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_scrblt_order(s, &orderInfo, scrblt);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_opaque_rect(rdpContext* context, const OPAQUE_RECT_ORDER* opaque_rect)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_OPAQUE_RECT);\n\tupdate_check_flush(context, headerLength +\n\t                                update_approximate_opaque_rect_order(&orderInfo, opaque_rect));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_opaque_rect_order(s, &orderInfo, opaque_rect);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_line_to(rdpContext* context, const LINE_TO_ORDER* line_to)\n{\n\twStream* s;\n\tint offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\tint inf;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_LINE_TO);\n\tinf = update_approximate_line_to_order(&orderInfo, line_to);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_line_to_order(s, &orderInfo, line_to);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_memblt(rdpContext* context, MEMBLT_ORDER* memblt)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_MEMBLT);\n\tupdate_check_flush(context, headerLength + update_approximate_memblt_order(&orderInfo, memblt));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_memblt_order(s, &orderInfo, memblt);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_glyph_index(rdpContext* context, GLYPH_INDEX_ORDER* glyph_index)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tint inf;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_GLYPH_INDEX);\n\tinf = update_approximate_glyph_index_order(&orderInfo, glyph_index);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_glyph_index_order(s, &orderInfo, glyph_index);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\n/*\n * Secondary Drawing Orders\n */\n\nstatic BOOL update_send_cache_bitmap(rdpContext* context, const CACHE_BITMAP_ORDER* cache_bitmap)\n{\n\twStream* s;\n\tsize_t bm, em;\n\tBYTE orderType;\n\tint headerLength;\n\tint inf;\n\tUINT16 extraFlags;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\textraFlags = 0;\n\theaderLength = 6;\n\torderType = cache_bitmap->compressed ? ORDER_TYPE_CACHE_BITMAP_COMPRESSED\n\t                                     : ORDER_TYPE_BITMAP_UNCOMPRESSED;\n\tinf =\n\t    update_approximate_cache_bitmap_order(cache_bitmap, cache_bitmap->compressed, &extraFlags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_bitmap_order(s, cache_bitmap, cache_bitmap->compressed, &extraFlags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, extraFlags);                      /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, orderType);                        /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_bitmap_v2(rdpContext* context, CACHE_BITMAP_V2_ORDER* cache_bitmap_v2)\n{\n\twStream* s;\n\tsize_t bm, em;\n\tBYTE orderType;\n\tint headerLength;\n\tUINT16 extraFlags;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\textraFlags = 0;\n\theaderLength = 6;\n\torderType = cache_bitmap_v2->compressed ? ORDER_TYPE_BITMAP_COMPRESSED_V2\n\t                                        : ORDER_TYPE_BITMAP_UNCOMPRESSED_V2;\n\n\tif (context->settings->NoBitmapCompressionHeader)\n\t\tcache_bitmap_v2->flags |= CBR2_NO_BITMAP_COMPRESSION_HDR;\n\n\tupdate_check_flush(context, headerLength +\n\t                                update_approximate_cache_bitmap_v2_order(\n\t                                    cache_bitmap_v2, cache_bitmap_v2->compressed, &extraFlags));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_bitmap_v2_order(s, cache_bitmap_v2, cache_bitmap_v2->compressed,\n\t                                        &extraFlags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, extraFlags);                      /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, orderType);                        /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_bitmap_v3(rdpContext* context, CACHE_BITMAP_V3_ORDER* cache_bitmap_v3)\n{\n\twStream* s;\n\tsize_t bm, em;\n\tBYTE orderType;\n\tint headerLength;\n\tUINT16 extraFlags;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\textraFlags = 0;\n\theaderLength = 6;\n\torderType = ORDER_TYPE_BITMAP_COMPRESSED_V3;\n\tupdate_check_flush(context, headerLength + update_approximate_cache_bitmap_v3_order(\n\t                                               cache_bitmap_v3, &extraFlags));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_bitmap_v3_order(s, cache_bitmap_v3, &extraFlags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, extraFlags);                      /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, orderType);                        /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_color_table(rdpContext* context,\n                                          const CACHE_COLOR_TABLE_ORDER* cache_color_table)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_color_table_order(cache_color_table, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_color_table_order(s, cache_color_table, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags);                           /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_COLOR_TABLE);     /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_glyph(rdpContext* context, const CACHE_GLYPH_ORDER* cache_glyph)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_glyph_order(cache_glyph, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_glyph_order(s, cache_glyph, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags);                           /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_GLYPH);           /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_glyph_v2(rdpContext* context,\n                                       const CACHE_GLYPH_V2_ORDER* cache_glyph_v2)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_glyph_v2_order(cache_glyph_v2, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_glyph_v2_order(s, cache_glyph_v2, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags);                           /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_GLYPH);           /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_brush(rdpContext* context, const CACHE_BRUSH_ORDER* cache_brush)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_brush_order(cache_brush, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_brush_order(s, cache_brush, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags);                           /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_BRUSH);           /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\n/**\n * Alternate Secondary Drawing Orders\n */\n\nstatic BOOL update_send_create_offscreen_bitmap_order(\n    rdpContext* context, const CREATE_OFFSCREEN_BITMAP_ORDER* create_offscreen_bitmap)\n{\n\twStream* s;\n\tsize_t bm, em, inf;\n\tBYTE orderType;\n\tBYTE controlFlags;\n\tint headerLength;\n\trdpUpdate* update = context->update;\n\theaderLength = 1;\n\torderType = ORDER_TYPE_CREATE_OFFSCREEN_BITMAP;\n\tcontrolFlags = ORDER_SECONDARY | (orderType << 2);\n\tinf = update_approximate_create_offscreen_bitmap_order(create_offscreen_bitmap);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_create_offscreen_bitmap_order(s, create_offscreen_bitmap))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, controlFlags); /* controlFlags (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_switch_surface_order(rdpContext* context,\n                                             const SWITCH_SURFACE_ORDER* switch_surface)\n{\n\twStream* s;\n\tsize_t bm, em, inf;\n\tBYTE orderType;\n\tBYTE controlFlags;\n\tint headerLength;\n\trdpUpdate* update;\n\n\tif (!context || !switch_surface || !context->update)\n\t\treturn FALSE;\n\n\tupdate = context->update;\n\theaderLength = 1;\n\torderType = ORDER_TYPE_SWITCH_SURFACE;\n\tcontrolFlags = ORDER_SECONDARY | (orderType << 2);\n\tinf = update_approximate_switch_surface_order(switch_surface);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_switch_surface_order(s, switch_surface))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, controlFlags); /* controlFlags (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_pointer_system(rdpContext* context,\n                                       const POINTER_SYSTEM_UPDATE* pointer_system)\n{\n\twStream* s;\n\tBYTE updateCode;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (pointer_system->type == SYSPTR_NULL)\n\t\tupdateCode = FASTPATH_UPDATETYPE_PTR_NULL;\n\telse\n\t\tupdateCode = FASTPATH_UPDATETYPE_PTR_DEFAULT;\n\n\tret = fastpath_send_update_pdu(rdp->fastpath, updateCode, s, FALSE);\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_pointer_position(rdpContext* context,\n                                         const POINTER_POSITION_UPDATE* pointerPosition)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 16))\n\t\tgoto out_fail;\n\n\tStream_Write_UINT16(s, pointerPosition->xPos); /* xPos (2 bytes) */\n\tStream_Write_UINT16(s, pointerPosition->yPos); /* yPos (2 bytes) */\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_PTR_POSITION, s, FALSE);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_write_pointer_color(wStream* s, const POINTER_COLOR_UPDATE* pointer_color)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, 32 + pointer_color->lengthAndMask +\n\t                                           pointer_color->lengthXorMask))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, pointer_color->cacheIndex);\n\tStream_Write_UINT16(s, pointer_color->xPos);\n\tStream_Write_UINT16(s, pointer_color->yPos);\n\tStream_Write_UINT16(s, pointer_color->width);\n\tStream_Write_UINT16(s, pointer_color->height);\n\tStream_Write_UINT16(s, pointer_color->lengthAndMask);\n\tStream_Write_UINT16(s, pointer_color->lengthXorMask);\n\n\tif (pointer_color->lengthXorMask > 0)\n\t\tStream_Write(s, pointer_color->xorMaskData, pointer_color->lengthXorMask);\n\n\tif (pointer_color->lengthAndMask > 0)\n\t\tStream_Write(s, pointer_color->andMaskData, pointer_color->lengthAndMask);\n\n\tStream_Write_UINT8(s, 0); /* pad (1 byte) */\n\treturn TRUE;\n}\n\nstatic BOOL update_send_pointer_color(rdpContext* context,\n                                      const POINTER_COLOR_UPDATE* pointer_color)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_pointer_color(s, pointer_color))\n\t\tgoto out_fail;\n\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_COLOR, s, FALSE);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_write_pointer_large(wStream* s, const POINTER_LARGE_UPDATE* pointer)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, 32 + pointer->lengthAndMask + pointer->lengthXorMask))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, pointer->xorBpp);\n\tStream_Write_UINT16(s, pointer->cacheIndex);\n\tStream_Write_UINT16(s, pointer->hotSpotX);\n\tStream_Write_UINT16(s, pointer->hotSpotY);\n\tStream_Write_UINT16(s, pointer->width);\n\tStream_Write_UINT16(s, pointer->height);\n\tStream_Write_UINT32(s, pointer->lengthAndMask);\n\tStream_Write_UINT32(s, pointer->lengthXorMask);\n\tStream_Write(s, pointer->xorMaskData, pointer->lengthXorMask);\n\tStream_Write(s, pointer->andMaskData, pointer->lengthAndMask);\n\tStream_Write_UINT8(s, 0); /* pad (1 byte) */\n\treturn TRUE;\n}\n\nstatic BOOL update_send_pointer_large(rdpContext* context, const POINTER_LARGE_UPDATE* pointer)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_pointer_large(s, pointer))\n\t\tgoto out_fail;\n\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_LARGE_POINTER, s, FALSE);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_pointer_new(rdpContext* context, const POINTER_NEW_UPDATE* pointer_new)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 16))\n\t\tgoto out_fail;\n\n\tStream_Write_UINT16(s, pointer_new->xorBpp); /* xorBpp (2 bytes) */\n\tupdate_write_pointer_color(s, &pointer_new->colorPtrAttr);\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_POINTER, s, FALSE);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_pointer_cached(rdpContext* context,\n                                       const POINTER_CACHED_UPDATE* pointer_cached)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, pointer_cached->cacheIndex); /* cacheIndex (2 bytes) */\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_CACHED, s, FALSE);\n\tStream_Release(s);\n\treturn ret;\n}\n\nBOOL update_read_refresh_rect(rdpUpdate* update, wStream* s)\n{\n\tint index;\n\tBYTE numberOfAreas;\n\tRECTANGLE_16* areas;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, numberOfAreas);\n\tStream_Seek(s, 3); /* pad3Octects */\n\n\tif (Stream_GetRemainingLength(s) < ((size_t)numberOfAreas * 4 * 2))\n\t\treturn FALSE;\n\n\tareas = (RECTANGLE_16*)calloc(numberOfAreas, sizeof(RECTANGLE_16));\n\n\tif (!areas)\n\t\treturn FALSE;\n\n\tfor (index = 0; index < numberOfAreas; index++)\n\t{\n\t\tStream_Read_UINT16(s, areas[index].left);\n\t\tStream_Read_UINT16(s, areas[index].top);\n\t\tStream_Read_UINT16(s, areas[index].right);\n\t\tStream_Read_UINT16(s, areas[index].bottom);\n\t}\n\n\tif (update->context->settings->RefreshRect)\n\t\tIFCALL(update->RefreshRect, update->context, numberOfAreas, areas);\n\telse\n\t\tWLog_Print(update->log, WLOG_WARN, \"ignoring refresh rect request from client\");\n\n\tfree(areas);\n\treturn TRUE;\n}\n\nBOOL update_read_suppress_output(rdpUpdate* update, wStream* s)\n{\n\tRECTANGLE_16* prect = NULL;\n\tRECTANGLE_16 rect = { 0 };\n\tBYTE allowDisplayUpdates;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, allowDisplayUpdates);\n\tStream_Seek(s, 3); /* pad3Octects */\n\n\tif (allowDisplayUpdates > 0)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < sizeof(RECTANGLE_16))\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT16(s, rect.left);\n\t\tStream_Read_UINT16(s, rect.top);\n\t\tStream_Read_UINT16(s, rect.right);\n\t\tStream_Read_UINT16(s, rect.bottom);\n\n\t\tprect = &rect;\n\t}\n\n\tif (update->context->settings->SuppressOutput)\n\t\tIFCALL(update->SuppressOutput, update->context, allowDisplayUpdates, prect);\n\telse\n\t\tWLog_Print(update->log, WLOG_WARN, \"ignoring suppress output request from client\");\n\n\treturn TRUE;\n}\n\nstatic BOOL update_send_set_keyboard_indicators(rdpContext* context, UINT16 led_flags)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\ts = rdp_data_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, 0);         /* unitId should be 0 according to MS-RDPBCGR 2.2.8.2.1.1 */\n\tStream_Write_UINT16(s, led_flags); /* ledFlags (2 bytes) */\n\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_SET_KEYBOARD_INDICATORS, rdp->mcs->userId);\n}\n\nstatic BOOL update_send_set_keyboard_ime_status(rdpContext* context, UINT16 imeId, UINT32 imeState,\n                                                UINT32 imeConvMode)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\ts = rdp_data_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\t/* unitId should be 0 according to MS-RDPBCGR 2.2.8.2.2.1 */\n\tStream_Write_UINT16(s, imeId);\n\tStream_Write_UINT32(s, imeState);\n\tStream_Write_UINT32(s, imeConvMode);\n\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_SET_KEYBOARD_IME_STATUS, rdp->mcs->userId);\n}\n\nstatic UINT16 update_calculate_new_or_existing_window(const WINDOW_ORDER_INFO* orderInfo,\n                                                      const WINDOW_STATE_ORDER* stateOrder)\n{\n\tUINT16 orderSize = 11;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OWNER) != 0)\n\t\torderSize += 4;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_STYLE) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_SHOW) != 0)\n\t\torderSize += 1;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TITLE) != 0)\n\t\torderSize += 2 + stateOrder->titleInfo.length;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_OFFSET) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_SIZE) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_X) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_Y) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RP_CONTENT) != 0)\n\t\torderSize += 1;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ROOT_PARENT) != 0)\n\t\torderSize += 4;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_OFFSET) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_CLIENT_DELTA) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_SIZE) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_RECTS) != 0)\n\t\torderSize += 2 + stateOrder->numWindowRects * sizeof(RECTANGLE_16);\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VIS_OFFSET) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VISIBILITY) != 0)\n\t\torderSize += 2 + stateOrder->numVisibilityRects * sizeof(RECTANGLE_16);\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OVERLAY_DESCRIPTION) != 0)\n\t\torderSize += 2 + stateOrder->OverlayDescription.length;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TASKBAR_BUTTON) != 0)\n\t\torderSize += 1;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ENFORCE_SERVER_ZORDER) != 0)\n\t\torderSize += 1;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_STATE) != 0)\n\t\torderSize += 1;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_EDGE) != 0)\n\t\torderSize += 1;\n\n\treturn orderSize;\n}\n\nstatic BOOL update_send_new_or_existing_window(rdpContext* context,\n                                               const WINDOW_ORDER_INFO* orderInfo,\n                                               const WINDOW_STATE_ORDER* stateOrder)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = update_calculate_new_or_existing_window(orderInfo, stateOrder);\n\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);   /* WindowID (4 bytes) */\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OWNER) != 0)\n\t\tStream_Write_UINT32(s, stateOrder->ownerWindowId);\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_STYLE) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->style);\n\t\tStream_Write_UINT32(s, stateOrder->extendedStyle);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_SHOW) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->showState);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TITLE) != 0)\n\t{\n\t\tStream_Write_UINT16(s, stateOrder->titleInfo.length);\n\t\tStream_Write(s, stateOrder->titleInfo.string, stateOrder->titleInfo.length);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_OFFSET) != 0)\n\t{\n\t\tStream_Write_INT32(s, stateOrder->clientOffsetX);\n\t\tStream_Write_INT32(s, stateOrder->clientOffsetY);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_SIZE) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->clientAreaWidth);\n\t\tStream_Write_UINT32(s, stateOrder->clientAreaHeight);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_X) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->resizeMarginLeft);\n\t\tStream_Write_UINT32(s, stateOrder->resizeMarginRight);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_Y) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->resizeMarginTop);\n\t\tStream_Write_UINT32(s, stateOrder->resizeMarginBottom);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RP_CONTENT) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->RPContent);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ROOT_PARENT) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->rootParentHandle);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_OFFSET) != 0)\n\t{\n\t\tStream_Write_INT32(s, stateOrder->windowOffsetX);\n\t\tStream_Write_INT32(s, stateOrder->windowOffsetY);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_CLIENT_DELTA) != 0)\n\t{\n\t\tStream_Write_INT32(s, stateOrder->windowClientDeltaX);\n\t\tStream_Write_INT32(s, stateOrder->windowClientDeltaY);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_SIZE) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->windowWidth);\n\t\tStream_Write_UINT32(s, stateOrder->windowHeight);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_RECTS) != 0)\n\t{\n\t\tStream_Write_UINT16(s, stateOrder->numWindowRects);\n\t\tStream_Write(s, stateOrder->windowRects, stateOrder->numWindowRects * sizeof(RECTANGLE_16));\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VIS_OFFSET) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->visibleOffsetX);\n\t\tStream_Write_UINT32(s, stateOrder->visibleOffsetY);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VISIBILITY) != 0)\n\t{\n\t\tStream_Write_UINT16(s, stateOrder->numVisibilityRects);\n\t\tStream_Write(s, stateOrder->visibilityRects,\n\t\t             stateOrder->numVisibilityRects * sizeof(RECTANGLE_16));\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OVERLAY_DESCRIPTION) != 0)\n\t{\n\t\tStream_Write_UINT16(s, stateOrder->OverlayDescription.length);\n\t\tStream_Write(s, stateOrder->OverlayDescription.string,\n\t\t             stateOrder->OverlayDescription.length);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TASKBAR_BUTTON) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->TaskbarButton);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ENFORCE_SERVER_ZORDER) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->EnforceServerZOrder);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_STATE) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->AppBarState);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_EDGE) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->AppBarEdge);\n\t}\n\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_window_create(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                      const WINDOW_STATE_ORDER* stateOrder)\n{\n\treturn update_send_new_or_existing_window(context, orderInfo, stateOrder);\n}\n\nstatic BOOL update_send_window_update(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                      const WINDOW_STATE_ORDER* stateOrder)\n{\n\treturn update_send_new_or_existing_window(context, orderInfo, stateOrder);\n}\n\nstatic UINT16 update_calculate_window_icon_order(const WINDOW_ORDER_INFO* orderInfo,\n                                                 const WINDOW_ICON_ORDER* iconOrder)\n{\n\tUINT16 orderSize = 23;\n\tICON_INFO* iconInfo = iconOrder->iconInfo;\n\n\torderSize += iconInfo->cbBitsColor + iconInfo->cbBitsMask;\n\n\tif (iconInfo->bpp <= 8)\n\t\torderSize += 2 + iconInfo->cbColorTable;\n\n\treturn orderSize;\n}\n\nstatic BOOL update_send_window_icon(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                    const WINDOW_ICON_ORDER* iconOrder)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tICON_INFO* iconInfo = iconOrder->iconInfo;\n\tUINT16 orderSize = update_calculate_window_icon_order(orderInfo, iconOrder);\n\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s || !iconInfo)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\n\t/* Write Hdr */\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);   /* WindowID (4 bytes) */\n\t/* Write body */\n\tStream_Write_UINT16(s, iconInfo->cacheEntry); /* CacheEntry (2 bytes) */\n\tStream_Write_UINT8(s, iconInfo->cacheId);     /* CacheId (1 byte) */\n\tStream_Write_UINT8(s, iconInfo->bpp);         /* Bpp (1 byte) */\n\tStream_Write_UINT16(s, iconInfo->width);      /* Width (2 bytes) */\n\tStream_Write_UINT16(s, iconInfo->height);     /* Height (2 bytes) */\n\n\tif (iconInfo->bpp <= 8)\n\t{\n\t\tStream_Write_UINT16(s, iconInfo->cbColorTable); /* CbColorTable (2 bytes) */\n\t}\n\n\tStream_Write_UINT16(s, iconInfo->cbBitsMask);              /* CbBitsMask (2 bytes) */\n\tStream_Write_UINT16(s, iconInfo->cbBitsColor);             /* CbBitsColor (2 bytes) */\n\tStream_Write(s, iconInfo->bitsMask, iconInfo->cbBitsMask); /* BitsMask (variable) */\n\n\tif (iconInfo->bpp <= 8)\n\t{\n\t\tStream_Write(s, iconInfo->colorTable, iconInfo->cbColorTable); /* ColorTable (variable) */\n\t}\n\n\tStream_Write(s, iconInfo->bitsColor, iconInfo->cbBitsColor); /* BitsColor (variable) */\n\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_window_cached_icon(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                           const WINDOW_CACHED_ICON_ORDER* cachedIconOrder)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = 14;\n\tCACHED_ICON_INFO cachedIcon = cachedIconOrder->cachedIcon;\n\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\n\t/* Write Hdr */\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);   /* WindowID (4 bytes) */\n\t/* Write body */\n\tStream_Write_UINT16(s, cachedIcon.cacheEntry); /* CacheEntry (2 bytes) */\n\tStream_Write_UINT8(s, cachedIcon.cacheId);     /* CacheId (1 byte) */\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_window_delete(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = 11;\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\n\t/* Write Hdr */\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);   /* WindowID (4 bytes) */\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic UINT16 update_calculate_new_or_existing_notification_icons_order(\n    const WINDOW_ORDER_INFO* orderInfo, const NOTIFY_ICON_STATE_ORDER* iconStateOrder)\n{\n\tUINT16 orderSize = 15;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_VERSION) != 0)\n\t\torderSize += 4;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_TIP) != 0)\n\t{\n\t\torderSize += 2 + iconStateOrder->toolTip.length;\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_INFO_TIP) != 0)\n\t{\n\t\tNOTIFY_ICON_INFOTIP infoTip = iconStateOrder->infoTip;\n\t\torderSize += 12 + infoTip.text.length + infoTip.title.length;\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_STATE) != 0)\n\t{\n\t\torderSize += 4;\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_ICON) != 0)\n\t{\n\t\tICON_INFO iconInfo = iconStateOrder->icon;\n\t\torderSize += 12;\n\n\t\tif (iconInfo.bpp <= 8)\n\t\t\torderSize += 2 + iconInfo.cbColorTable;\n\n\t\torderSize += iconInfo.cbBitsMask + iconInfo.cbBitsColor;\n\t}\n\telse if ((orderInfo->fieldFlags & WINDOW_ORDER_CACHED_ICON) != 0)\n\t{\n\t\torderSize += 3;\n\t}\n\n\treturn orderSize;\n}\n\nstatic BOOL\nupdate_send_new_or_existing_notification_icons(rdpContext* context,\n                                               const WINDOW_ORDER_INFO* orderInfo,\n                                               const NOTIFY_ICON_STATE_ORDER* iconStateOrder)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tBOOL versionFieldPresent = FALSE;\n\tUINT16 orderSize =\n\t    update_calculate_new_or_existing_notification_icons_order(orderInfo, iconStateOrder);\n\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\n\t/* Write Hdr */\n\tStream_Write_UINT8(s, controlFlags);             /* Header (1 byte) */\n\tStream_Write_INT16(s, orderSize);                /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags);   /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);     /* WindowID (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->notifyIconId); /* NotifyIconId (4 bytes) */\n\n\t/* Write body */\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_VERSION) != 0)\n\t{\n\t\tversionFieldPresent = TRUE;\n\t\tStream_Write_UINT32(s, iconStateOrder->version);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_TIP) != 0)\n\t{\n\t\tStream_Write_UINT16(s, iconStateOrder->toolTip.length);\n\t\tStream_Write(s, iconStateOrder->toolTip.string, iconStateOrder->toolTip.length);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_INFO_TIP) != 0)\n\t{\n\t\tNOTIFY_ICON_INFOTIP infoTip = iconStateOrder->infoTip;\n\n\t\t/* info tip should not be sent when version is 0 */\n\t\tif (versionFieldPresent && iconStateOrder->version == 0)\n\t\t\treturn FALSE;\n\n\t\tStream_Write_UINT32(s, infoTip.timeout);     /* Timeout (4 bytes) */\n\t\tStream_Write_UINT32(s, infoTip.flags);       /* InfoFlags (4 bytes) */\n\t\tStream_Write_UINT16(s, infoTip.text.length); /* InfoTipText (variable) */\n\t\tStream_Write(s, infoTip.text.string, infoTip.text.length);\n\t\tStream_Write_UINT16(s, infoTip.title.length); /* Title (variable) */\n\t\tStream_Write(s, infoTip.title.string, infoTip.title.length);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_STATE) != 0)\n\t{\n\t\t/* notify state should not be sent when version is 0 */\n\t\tif (versionFieldPresent && iconStateOrder->version == 0)\n\t\t\treturn FALSE;\n\n\t\tStream_Write_UINT32(s, iconStateOrder->state);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_ICON) != 0)\n\t{\n\t\tICON_INFO iconInfo = iconStateOrder->icon;\n\t\tStream_Write_UINT16(s, iconInfo.cacheEntry); /* CacheEntry (2 bytes) */\n\t\tStream_Write_UINT8(s, iconInfo.cacheId);     /* CacheId (1 byte) */\n\t\tStream_Write_UINT8(s, iconInfo.bpp);         /* Bpp (1 byte) */\n\t\tStream_Write_UINT16(s, iconInfo.width);      /* Width (2 bytes) */\n\t\tStream_Write_UINT16(s, iconInfo.height);     /* Height (2 bytes) */\n\n\t\tif (iconInfo.bpp <= 8)\n\t\t{\n\t\t\tStream_Write_UINT16(s, iconInfo.cbColorTable); /* CbColorTable (2 bytes) */\n\t\t}\n\n\t\tStream_Write_UINT16(s, iconInfo.cbBitsMask);             /* CbBitsMask (2 bytes) */\n\t\tStream_Write_UINT16(s, iconInfo.cbBitsColor);            /* CbBitsColor (2 bytes) */\n\t\tStream_Write(s, iconInfo.bitsMask, iconInfo.cbBitsMask); /* BitsMask (variable) */\n\t\torderSize += iconInfo.cbBitsMask;\n\n\t\tif (iconInfo.bpp <= 8)\n\t\t{\n\t\t\tStream_Write(s, iconInfo.colorTable, iconInfo.cbColorTable); /* ColorTable (variable) */\n\t\t}\n\n\t\tStream_Write(s, iconInfo.bitsColor, iconInfo.cbBitsColor); /* BitsColor (variable) */\n\t}\n\telse if ((orderInfo->fieldFlags & WINDOW_ORDER_CACHED_ICON) != 0)\n\t{\n\t\tCACHED_ICON_INFO cachedIcon = iconStateOrder->cachedIcon;\n\t\tStream_Write_UINT16(s, cachedIcon.cacheEntry); /* CacheEntry (2 bytes) */\n\t\tStream_Write_UINT8(s, cachedIcon.cacheId);     /* CacheId (1 byte) */\n\t}\n\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_notify_icon_create(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                           const NOTIFY_ICON_STATE_ORDER* iconStateOrder)\n{\n\treturn update_send_new_or_existing_notification_icons(context, orderInfo, iconStateOrder);\n}\n\nstatic BOOL update_send_notify_icon_update(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                           const NOTIFY_ICON_STATE_ORDER* iconStateOrder)\n{\n\treturn update_send_new_or_existing_notification_icons(context, orderInfo, iconStateOrder);\n}\n\nstatic BOOL update_send_notify_icon_delete(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = 15;\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\t/* Write Hdr */\n\tStream_Write_UINT8(s, controlFlags);             /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);               /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags);   /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);     /* WindowID (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->notifyIconId); /* NotifyIconId (4 bytes) */\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic UINT16 update_calculate_monitored_desktop(const WINDOW_ORDER_INFO* orderInfo,\n                                                 const MONITORED_DESKTOP_ORDER* monitoredDesktop)\n{\n\tUINT16 orderSize = 7;\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ACTIVE_WND)\n\t{\n\t\torderSize += 4;\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ZORDER)\n\t{\n\t\torderSize += 1 + (4 * monitoredDesktop->numWindowIds);\n\t}\n\n\treturn orderSize;\n}\n\nstatic BOOL update_send_monitored_desktop(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                          const MONITORED_DESKTOP_ORDER* monitoredDesktop)\n{\n\tUINT32 i;\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = update_calculate_monitored_desktop(orderInfo, monitoredDesktop);\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ACTIVE_WND)\n\t{\n\t\tStream_Write_UINT32(s, monitoredDesktop->activeWindowId); /* activeWindowId (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ZORDER)\n\t{\n\t\tStream_Write_UINT8(s, monitoredDesktop->numWindowIds); /* numWindowIds (1 byte) */\n\n\t\t/* windowIds */\n\t\tfor (i = 0; i < monitoredDesktop->numWindowIds; i++)\n\t\t{\n\t\t\tStream_Write_UINT32(s, monitoredDesktop->windowIds[i]);\n\t\t}\n\t}\n\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_non_monitored_desktop(rdpContext* context,\n                                              const WINDOW_ORDER_INFO* orderInfo)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = 7;\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nvoid update_register_server_callbacks(rdpUpdate* update)\n{\n\tupdate->BeginPaint = _update_begin_paint;\n\tupdate->EndPaint = _update_end_paint;\n\tupdate->SetBounds = update_set_bounds;\n\tupdate->Synchronize = update_send_synchronize;\n\tupdate->DesktopResize = update_send_desktop_resize;\n\tupdate->BitmapUpdate = update_send_bitmap_update;\n\tupdate->SurfaceBits = update_send_surface_bits;\n\tupdate->SurfaceFrameMarker = update_send_surface_frame_marker;\n\tupdate->SurfaceCommand = update_send_surface_command;\n\tupdate->SurfaceFrameBits = update_send_surface_frame_bits;\n\tupdate->PlaySound = update_send_play_sound;\n\tupdate->SetKeyboardIndicators = update_send_set_keyboard_indicators;\n\tupdate->SetKeyboardImeStatus = update_send_set_keyboard_ime_status;\n\tupdate->SaveSessionInfo = rdp_send_save_session_info;\n\tupdate->ServerStatusInfo = rdp_send_server_status_info;\n\tupdate->primary->DstBlt = update_send_dstblt;\n\tupdate->primary->PatBlt = update_send_patblt;\n\tupdate->primary->ScrBlt = update_send_scrblt;\n\tupdate->primary->OpaqueRect = update_send_opaque_rect;\n\tupdate->primary->LineTo = update_send_line_to;\n\tupdate->primary->MemBlt = update_send_memblt;\n\tupdate->primary->GlyphIndex = update_send_glyph_index;\n\tupdate->secondary->CacheBitmap = update_send_cache_bitmap;\n\tupdate->secondary->CacheBitmapV2 = update_send_cache_bitmap_v2;\n\tupdate->secondary->CacheBitmapV3 = update_send_cache_bitmap_v3;\n\tupdate->secondary->CacheColorTable = update_send_cache_color_table;\n\tupdate->secondary->CacheGlyph = update_send_cache_glyph;\n\tupdate->secondary->CacheGlyphV2 = update_send_cache_glyph_v2;\n\tupdate->secondary->CacheBrush = update_send_cache_brush;\n\tupdate->altsec->CreateOffscreenBitmap = update_send_create_offscreen_bitmap_order;\n\tupdate->altsec->SwitchSurface = update_send_switch_surface_order;\n\tupdate->pointer->PointerSystem = update_send_pointer_system;\n\tupdate->pointer->PointerPosition = update_send_pointer_position;\n\tupdate->pointer->PointerColor = update_send_pointer_color;\n\tupdate->pointer->PointerLarge = update_send_pointer_large;\n\tupdate->pointer->PointerNew = update_send_pointer_new;\n\tupdate->pointer->PointerCached = update_send_pointer_cached;\n\tupdate->window->WindowCreate = update_send_window_create;\n\tupdate->window->WindowUpdate = update_send_window_update;\n\tupdate->window->WindowIcon = update_send_window_icon;\n\tupdate->window->WindowCachedIcon = update_send_window_cached_icon;\n\tupdate->window->WindowDelete = update_send_window_delete;\n\tupdate->window->NotifyIconCreate = update_send_notify_icon_create;\n\tupdate->window->NotifyIconUpdate = update_send_notify_icon_update;\n\tupdate->window->NotifyIconDelete = update_send_notify_icon_delete;\n\tupdate->window->MonitoredDesktop = update_send_monitored_desktop;\n\tupdate->window->NonMonitoredDesktop = update_send_non_monitored_desktop;\n}\n\nvoid update_register_client_callbacks(rdpUpdate* update)\n{\n\tupdate->RefreshRect = update_send_refresh_rect;\n\tupdate->SuppressOutput = update_send_suppress_output;\n\tupdate->SurfaceFrameAcknowledge = update_send_frame_acknowledge;\n}\n\nint update_process_messages(rdpUpdate* update)\n{\n\treturn update_message_queue_process_pending_messages(update);\n}\n\nstatic void update_free_queued_message(void* obj)\n{\n\twMessage* msg = (wMessage*)obj;\n\tupdate_message_queue_free_message(msg);\n}\n\nvoid update_free_window_state(WINDOW_STATE_ORDER* window_state)\n{\n\tif (!window_state)\n\t\treturn;\n\n\tfree(window_state->OverlayDescription.string);\n\tfree(window_state->titleInfo.string);\n\tfree(window_state->windowRects);\n\tfree(window_state->visibilityRects);\n\tmemset(window_state, 0, sizeof(WINDOW_STATE_ORDER));\n}\n\nrdpUpdate* update_new(rdpRdp* rdp)\n{\n\tconst wObject cb = { NULL, NULL, NULL, update_free_queued_message, NULL };\n\trdpUpdate* update;\n\tOFFSCREEN_DELETE_LIST* deleteList;\n\tWINPR_UNUSED(rdp);\n\tupdate = (rdpUpdate*)calloc(1, sizeof(rdpUpdate));\n\n\tif (!update)\n\t\treturn NULL;\n\n\tupdate->log = WLog_Get(\"com.freerdp.core.update\");\n\tInitializeCriticalSection(&(update->mux));\n\tupdate->pointer = (rdpPointerUpdate*)calloc(1, sizeof(rdpPointerUpdate));\n\n\tif (!update->pointer)\n\t\tgoto fail;\n\n\tupdate->primary = (rdpPrimaryUpdate*)calloc(1, sizeof(rdpPrimaryUpdate));\n\n\tif (!update->primary)\n\t\tgoto fail;\n\n\tupdate->secondary = (rdpSecondaryUpdate*)calloc(1, sizeof(rdpSecondaryUpdate));\n\n\tif (!update->secondary)\n\t\tgoto fail;\n\n\tupdate->altsec = (rdpAltSecUpdate*)calloc(1, sizeof(rdpAltSecUpdate));\n\n\tif (!update->altsec)\n\t\tgoto fail;\n\n\tupdate->window = (rdpWindowUpdate*)calloc(1, sizeof(rdpWindowUpdate));\n\n\tif (!update->window)\n\t\tgoto fail;\n\n\tdeleteList = &(update->altsec->create_offscreen_bitmap.deleteList);\n\tdeleteList->sIndices = 64;\n\tdeleteList->indices = calloc(deleteList->sIndices, 2);\n\n\tif (!deleteList->indices)\n\t\tgoto fail;\n\n\tdeleteList->cIndices = 0;\n\tupdate->SuppressOutput = update_send_suppress_output;\n\tupdate->initialState = TRUE;\n\tupdate->autoCalculateBitmapData = TRUE;\n\tupdate->queue = MessageQueue_New(&cb);\n\n\tif (!update->queue)\n\t\tgoto fail;\n\n\treturn update;\nfail:\n\tupdate_free(update);\n\treturn NULL;\n}\n\nvoid update_free(rdpUpdate* update)\n{\n\tif (update != NULL)\n\t{\n\t\tOFFSCREEN_DELETE_LIST* deleteList = &(update->altsec->create_offscreen_bitmap.deleteList);\n\n\t\tif (deleteList)\n\t\t\tfree(deleteList->indices);\n\n\t\tfree(update->pointer);\n\n\t\tif (update->primary)\n\t\t{\n\t\t\tfree(update->primary->polyline.points);\n\t\t\tfree(update->primary->polygon_sc.points);\n\t\t\tfree(update->primary->fast_glyph.glyphData.aj);\n\t\t\tfree(update->primary);\n\t\t}\n\n\t\tfree(update->secondary);\n\t\tfree(update->altsec);\n\n\t\tif (update->window)\n\t\t{\n\t\t\tfree(update->window);\n\t\t}\n\n\t\tMessageQueue_Free(update->queue);\n\t\tDeleteCriticalSection(&update->mux);\n\t\tfree(update);\n\t}\n}\n\nBOOL update_begin_paint(rdpUpdate* update)\n{\n\tif (!update)\n\t\treturn FALSE;\n\n\tEnterCriticalSection(&update->mux);\n\n\tif (!update->BeginPaint)\n\t\treturn TRUE;\n\n\treturn update->BeginPaint(update->context);\n}\n\nBOOL update_end_paint(rdpUpdate* update)\n{\n\tBOOL rc = FALSE;\n\n\tif (!update)\n\t\treturn FALSE;\n\n\tif (update->EndPaint)\n\t\trc = update->EndPaint(update->context);\n\n\tLeaveCriticalSection(&update->mux);\n\treturn rc;\n}\n"], "fixing_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Drawing Orders\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2016 Armin Novak <armin.novak@thincast.com>\n * Copyright 2016 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"window.h\"\n\n#include <winpr/wtypes.h>\n#include <winpr/crt.h>\n\n#include <freerdp/api.h>\n#include <freerdp/log.h>\n#include <freerdp/graphics.h>\n#include <freerdp/codec/bitmap.h>\n#include <freerdp/gdi/gdi.h>\n\n#include \"orders.h\"\n\n#include \"../cache/glyph.h\"\n#include \"../cache/bitmap.h\"\n#include \"../cache/brush.h\"\n#include \"../cache/cache.h\"\n\n#define TAG FREERDP_TAG(\"core.orders\")\n\nBYTE get_primary_drawing_order_field_bytes(UINT32 orderType, BOOL* pValid)\n{\n\tif (pValid)\n\t\t*pValid = TRUE;\n\tswitch (orderType)\n\t{\n\t\tcase 0:\n\t\t\treturn DSTBLT_ORDER_FIELD_BYTES;\n\t\tcase 1:\n\t\t\treturn PATBLT_ORDER_FIELD_BYTES;\n\t\tcase 2:\n\t\t\treturn SCRBLT_ORDER_FIELD_BYTES;\n\t\tcase 3:\n\t\t\treturn 0;\n\t\tcase 4:\n\t\t\treturn 0;\n\t\tcase 5:\n\t\t\treturn 0;\n\t\tcase 6:\n\t\t\treturn 0;\n\t\tcase 7:\n\t\t\treturn DRAW_NINE_GRID_ORDER_FIELD_BYTES;\n\t\tcase 8:\n\t\t\treturn MULTI_DRAW_NINE_GRID_ORDER_FIELD_BYTES;\n\t\tcase 9:\n\t\t\treturn LINE_TO_ORDER_FIELD_BYTES;\n\t\tcase 10:\n\t\t\treturn OPAQUE_RECT_ORDER_FIELD_BYTES;\n\t\tcase 11:\n\t\t\treturn SAVE_BITMAP_ORDER_FIELD_BYTES;\n\t\tcase 12:\n\t\t\treturn 0;\n\t\tcase 13:\n\t\t\treturn MEMBLT_ORDER_FIELD_BYTES;\n\t\tcase 14:\n\t\t\treturn MEM3BLT_ORDER_FIELD_BYTES;\n\t\tcase 15:\n\t\t\treturn MULTI_DSTBLT_ORDER_FIELD_BYTES;\n\t\tcase 16:\n\t\t\treturn MULTI_PATBLT_ORDER_FIELD_BYTES;\n\t\tcase 17:\n\t\t\treturn MULTI_SCRBLT_ORDER_FIELD_BYTES;\n\t\tcase 18:\n\t\t\treturn MULTI_OPAQUE_RECT_ORDER_FIELD_BYTES;\n\t\tcase 19:\n\t\t\treturn FAST_INDEX_ORDER_FIELD_BYTES;\n\t\tcase 20:\n\t\t\treturn POLYGON_SC_ORDER_FIELD_BYTES;\n\t\tcase 21:\n\t\t\treturn POLYGON_CB_ORDER_FIELD_BYTES;\n\t\tcase 22:\n\t\t\treturn POLYLINE_ORDER_FIELD_BYTES;\n\t\tcase 23:\n\t\t\treturn 0;\n\t\tcase 24:\n\t\t\treturn FAST_GLYPH_ORDER_FIELD_BYTES;\n\t\tcase 25:\n\t\t\treturn ELLIPSE_SC_ORDER_FIELD_BYTES;\n\t\tcase 26:\n\t\t\treturn ELLIPSE_CB_ORDER_FIELD_BYTES;\n\t\tcase 27:\n\t\t\treturn GLYPH_INDEX_ORDER_FIELD_BYTES;\n\t\tdefault:\n\t\t\tif (pValid)\n\t\t\t\t*pValid = FALSE;\n\t\t\tWLog_WARN(TAG, \"Invalid orderType 0x%08X received\", orderType);\n\t\t\treturn 0;\n\t}\n}\n\nstatic const BYTE CBR2_BPP[] = { 0, 0, 0, 8, 16, 24, 32 };\n\nstatic const BYTE BPP_CBR2[] = { 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,\n\t                             0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 };\n\nstatic const BYTE CBR23_BPP[] = { 0, 0, 0, 8, 16, 24, 32 };\n\nstatic const BYTE BPP_CBR23[] = { 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,\n\t                              0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 };\n\nstatic const BYTE BMF_BPP[] = { 0, 1, 0, 8, 16, 24, 32, 0 };\n\nstatic const BYTE BPP_BMF[] = { 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,\n\t                            0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 };\n\nstatic BOOL check_order_activated(wLog* log, rdpSettings* settings, const char* orderName,\n                                  BOOL condition)\n{\n\tif (!condition)\n\t{\n\t\tif (settings->AllowUnanouncedOrdersFromServer)\n\t\t{\n\t\t\tWLog_Print(log, WLOG_WARN,\n\t\t\t           \"%s - SERVER BUG: The support for this feature was not announced!\",\n\t\t\t           orderName);\n\t\t\treturn TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWLog_Print(log, WLOG_ERROR,\n\t\t\t           \"%s - SERVER BUG: The support for this feature was not announced! Use \"\n\t\t\t           \"/relax-order-checks to ignore\",\n\t\t\t           orderName);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL check_alt_order_supported(wLog* log, rdpSettings* settings, BYTE orderType,\n                                      const char* orderName)\n{\n\tBOOL condition = FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_CREATE_OFFSCREEN_BITMAP:\n\t\tcase ORDER_TYPE_SWITCH_SURFACE:\n\t\t\tcondition = settings->OffscreenSupportLevel != 0;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CREATE_NINE_GRID_BITMAP:\n\t\t\tcondition = settings->DrawNineGridEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FRAME_MARKER:\n\t\t\tcondition = settings->FrameMarkerCommandEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_FIRST:\n\t\tcase ORDER_TYPE_GDIPLUS_NEXT:\n\t\tcase ORDER_TYPE_GDIPLUS_END:\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_FIRST:\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_NEXT:\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_END:\n\t\t\tcondition = settings->DrawGdiPlusCacheEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_WINDOW:\n\t\t\tcondition = settings->RemoteWndSupportLevel != WINDOW_LEVEL_NOT_SUPPORTED;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_STREAM_BITMAP_FIRST:\n\t\tcase ORDER_TYPE_STREAM_BITMAP_NEXT:\n\t\tcase ORDER_TYPE_COMPDESK_FIRST:\n\t\t\tcondition = TRUE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(log, WLOG_WARN, \"%s - Alternate Secondary Drawing Order UNKNOWN\", orderName);\n\t\t\tcondition = FALSE;\n\t\t\tbreak;\n\t}\n\n\treturn check_order_activated(log, settings, orderName, condition);\n}\n\nstatic BOOL check_secondary_order_supported(wLog* log, rdpSettings* settings, BYTE orderType,\n                                            const char* orderName)\n{\n\tBOOL condition = FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED:\n\t\tcase ORDER_TYPE_CACHE_BITMAP_COMPRESSED:\n\t\t\tcondition = settings->BitmapCacheEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED_V2:\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V2:\n\t\t\tcondition = settings->BitmapCacheEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V3:\n\t\t\tcondition = settings->BitmapCacheV3Enabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_COLOR_TABLE:\n\t\t\tcondition = (settings->OrderSupport[NEG_MEMBLT_INDEX] ||\n\t\t\t             settings->OrderSupport[NEG_MEM3BLT_INDEX]);\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_GLYPH:\n\t\t{\n\t\t\tswitch (settings->GlyphSupportLevel)\n\t\t\t{\n\t\t\t\tcase GLYPH_SUPPORT_PARTIAL:\n\t\t\t\tcase GLYPH_SUPPORT_FULL:\n\t\t\t\tcase GLYPH_SUPPORT_ENCODE:\n\t\t\t\t\tcondition = TRUE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_NONE:\n\t\t\t\tdefault:\n\t\t\t\t\tcondition = FALSE;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_BRUSH:\n\t\t\tcondition = TRUE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(log, WLOG_WARN, \"SECONDARY ORDER %s not supported\", orderName);\n\t\t\tbreak;\n\t}\n\n\treturn check_order_activated(log, settings, orderName, condition);\n}\n\nstatic BOOL check_primary_order_supported(wLog* log, rdpSettings* settings, UINT32 orderType,\n                                          const char* orderName)\n{\n\tBOOL condition = FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_DSTBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_DSTBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SCRBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_SCRBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_DRAW_NINE_GRID:\n\t\t\tcondition = settings->OrderSupport[NEG_DRAWNINEGRID_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DRAW_NINE_GRID:\n\t\t\tcondition = settings->OrderSupport[NEG_MULTI_DRAWNINEGRID_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_LINE_TO:\n\t\t\tcondition = settings->OrderSupport[NEG_LINETO_INDEX];\n\t\t\tbreak;\n\n\t\t/* [MS-RDPEGDI] 2.2.2.2.1.1.2.5 OpaqueRect (OPAQUERECT_ORDER)\n\t\t * suggests that PatBlt and OpaqueRect imply each other. */\n\t\tcase ORDER_TYPE_PATBLT:\n\t\tcase ORDER_TYPE_OPAQUE_RECT:\n\t\t\tcondition = settings->OrderSupport[NEG_OPAQUE_RECT_INDEX] ||\n\t\t\t            settings->OrderSupport[NEG_PATBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SAVE_BITMAP:\n\t\t\tcondition = settings->OrderSupport[NEG_SAVEBITMAP_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEMBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_MEMBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEM3BLT:\n\t\t\tcondition = settings->OrderSupport[NEG_MEM3BLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DSTBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_MULTIDSTBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_PATBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_MULTIPATBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_SCRBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_MULTIDSTBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_OPAQUE_RECT:\n\t\t\tcondition = settings->OrderSupport[NEG_MULTIOPAQUERECT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_INDEX:\n\t\t\tcondition = settings->OrderSupport[NEG_FAST_INDEX_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_SC:\n\t\t\tcondition = settings->OrderSupport[NEG_POLYGON_SC_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_CB:\n\t\t\tcondition = settings->OrderSupport[NEG_POLYGON_CB_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYLINE:\n\t\t\tcondition = settings->OrderSupport[NEG_POLYLINE_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_GLYPH:\n\t\t\tcondition = settings->OrderSupport[NEG_FAST_GLYPH_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_SC:\n\t\t\tcondition = settings->OrderSupport[NEG_ELLIPSE_SC_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_CB:\n\t\t\tcondition = settings->OrderSupport[NEG_ELLIPSE_CB_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GLYPH_INDEX:\n\t\t\tcondition = settings->OrderSupport[NEG_GLYPH_INDEX_INDEX];\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(log, WLOG_WARN, \"%s Primary Drawing Order not supported\", orderName);\n\t\t\tbreak;\n\t}\n\n\treturn check_order_activated(log, settings, orderName, condition);\n}\n\nstatic const char* primary_order_string(UINT32 orderType)\n{\n\tconst char* orders[] = { \"[0x%02\" PRIx8 \"] DstBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] PatBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] ScrBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] DrawNineGrid\",\n\t\t                     \"[0x%02\" PRIx8 \"] MultiDrawNineGrid\",\n\t\t                     \"[0x%02\" PRIx8 \"] LineTo\",\n\t\t                     \"[0x%02\" PRIx8 \"] OpaqueRect\",\n\t\t                     \"[0x%02\" PRIx8 \"] SaveBitmap\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] MemBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] Mem3Blt\",\n\t\t                     \"[0x%02\" PRIx8 \"] MultiDstBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] MultiPatBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] MultiScrBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] MultiOpaqueRect\",\n\t\t                     \"[0x%02\" PRIx8 \"] FastIndex\",\n\t\t                     \"[0x%02\" PRIx8 \"] PolygonSC\",\n\t\t                     \"[0x%02\" PRIx8 \"] PolygonCB\",\n\t\t                     \"[0x%02\" PRIx8 \"] Polyline\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] FastGlyph\",\n\t\t                     \"[0x%02\" PRIx8 \"] EllipseSC\",\n\t\t                     \"[0x%02\" PRIx8 \"] EllipseCB\",\n\t\t                     \"[0x%02\" PRIx8 \"] GlyphIndex\" };\n\tconst char* fmt = \"[0x%02\" PRIx8 \"] UNKNOWN\";\n\tstatic char buffer[64] = { 0 };\n\n\tif (orderType < ARRAYSIZE(orders))\n\t\tfmt = orders[orderType];\n\n\tsprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);\n\treturn buffer;\n}\nstatic const char* secondary_order_string(UINT32 orderType)\n{\n\tconst char* orders[] = { \"[0x%02\" PRIx8 \"] Cache Bitmap\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Color Table\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap (Compressed)\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Glyph\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap V2\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap V2 (Compressed)\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Brush\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap V3\" };\n\tconst char* fmt = \"[0x%02\" PRIx8 \"] UNKNOWN\";\n\tstatic char buffer[64] = { 0 };\n\n\tif (orderType < ARRAYSIZE(orders))\n\t\tfmt = orders[orderType];\n\n\tsprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);\n\treturn buffer;\n}\nstatic const char* altsec_order_string(BYTE orderType)\n{\n\tconst char* orders[] = {\n\t\t\"[0x%02\" PRIx8 \"] Switch Surface\",         \"[0x%02\" PRIx8 \"] Create Offscreen Bitmap\",\n\t\t\"[0x%02\" PRIx8 \"] Stream Bitmap First\",    \"[0x%02\" PRIx8 \"] Stream Bitmap Next\",\n\t\t\"[0x%02\" PRIx8 \"] Create NineGrid Bitmap\", \"[0x%02\" PRIx8 \"] Draw GDI+ First\",\n\t\t\"[0x%02\" PRIx8 \"] Draw GDI+ Next\",         \"[0x%02\" PRIx8 \"] Draw GDI+ End\",\n\t\t\"[0x%02\" PRIx8 \"] Draw GDI+ Cache First\",  \"[0x%02\" PRIx8 \"] Draw GDI+ Cache Next\",\n\t\t\"[0x%02\" PRIx8 \"] Draw GDI+ Cache End\",    \"[0x%02\" PRIx8 \"] Windowing\",\n\t\t\"[0x%02\" PRIx8 \"] Desktop Composition\",    \"[0x%02\" PRIx8 \"] Frame Marker\"\n\t};\n\tconst char* fmt = \"[0x%02\" PRIx8 \"] UNKNOWN\";\n\tstatic char buffer[64] = { 0 };\n\n\tif (orderType < ARRAYSIZE(orders))\n\t\tfmt = orders[orderType];\n\n\tsprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);\n\treturn buffer;\n}\n\nstatic INLINE BOOL update_read_coord(wStream* s, INT32* coord, BOOL delta)\n{\n\tINT8 lsi8;\n\tINT16 lsi16;\n\n\tif (delta)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_INT8(s, lsi8);\n\t\t*coord += lsi8;\n\t}\n\telse\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_INT16(s, lsi16);\n\t\t*coord = lsi16;\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_coord(wStream* s, INT32 coord)\n{\n\tStream_Write_UINT16(s, coord);\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_color(wStream* s, UINT32* color)\n{\n\tBYTE byte;\n\n\tif (Stream_GetRemainingLength(s) < 3)\n\t\treturn FALSE;\n\n\t*color = 0;\n\tStream_Read_UINT8(s, byte);\n\t*color = (UINT32)byte;\n\tStream_Read_UINT8(s, byte);\n\t*color |= ((UINT32)byte << 8) & 0xFF00;\n\tStream_Read_UINT8(s, byte);\n\t*color |= ((UINT32)byte << 16) & 0xFF0000;\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_color(wStream* s, UINT32 color)\n{\n\tBYTE byte;\n\tbyte = (color & 0xFF);\n\tStream_Write_UINT8(s, byte);\n\tbyte = ((color >> 8) & 0xFF);\n\tStream_Write_UINT8(s, byte);\n\tbyte = ((color >> 16) & 0xFF);\n\tStream_Write_UINT8(s, byte);\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_colorref(wStream* s, UINT32* color)\n{\n\tBYTE byte;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\t*color = 0;\n\tStream_Read_UINT8(s, byte);\n\t*color = byte;\n\tStream_Read_UINT8(s, byte);\n\t*color |= ((UINT32)byte << 8);\n\tStream_Read_UINT8(s, byte);\n\t*color |= ((UINT32)byte << 16);\n\tStream_Seek_UINT8(s);\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_color_quad(wStream* s, UINT32* color)\n{\n\treturn update_read_colorref(s, color);\n}\nstatic INLINE void update_write_color_quad(wStream* s, UINT32 color)\n{\n\tBYTE byte;\n\tbyte = (color >> 16) & 0xFF;\n\tStream_Write_UINT8(s, byte);\n\tbyte = (color >> 8) & 0xFF;\n\tStream_Write_UINT8(s, byte);\n\tbyte = color & 0xFF;\n\tStream_Write_UINT8(s, byte);\n}\nstatic INLINE BOOL update_read_2byte_unsigned(wStream* s, UINT32* value)\n{\n\tBYTE byte;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, byte);\n\n\tif (byte & 0x80)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\t*value = (byte & 0x7F) << 8;\n\t\tStream_Read_UINT8(s, byte);\n\t\t*value |= byte;\n\t}\n\telse\n\t{\n\t\t*value = (byte & 0x7F);\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_2byte_unsigned(wStream* s, UINT32 value)\n{\n\tBYTE byte;\n\n\tif (value > 0x7FFF)\n\t\treturn FALSE;\n\n\tif (value >= 0x7F)\n\t{\n\t\tbyte = ((value & 0x7F00) >> 8);\n\t\tStream_Write_UINT8(s, byte | 0x80);\n\t\tbyte = (value & 0xFF);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse\n\t{\n\t\tbyte = (value & 0x7F);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_2byte_signed(wStream* s, INT32* value)\n{\n\tBYTE byte;\n\tBOOL negative;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, byte);\n\tnegative = (byte & 0x40) ? TRUE : FALSE;\n\t*value = (byte & 0x3F);\n\n\tif (byte & 0x80)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\t*value = (*value << 8) | byte;\n\t}\n\n\tif (negative)\n\t\t*value *= -1;\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_2byte_signed(wStream* s, INT32 value)\n{\n\tBYTE byte;\n\tBOOL negative = FALSE;\n\n\tif (value < 0)\n\t{\n\t\tnegative = TRUE;\n\t\tvalue *= -1;\n\t}\n\n\tif (value > 0x3FFF)\n\t\treturn FALSE;\n\n\tif (value >= 0x3F)\n\t{\n\t\tbyte = ((value & 0x3F00) >> 8);\n\n\t\tif (negative)\n\t\t\tbyte |= 0x40;\n\n\t\tStream_Write_UINT8(s, byte | 0x80);\n\t\tbyte = (value & 0xFF);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse\n\t{\n\t\tbyte = (value & 0x3F);\n\n\t\tif (negative)\n\t\t\tbyte |= 0x40;\n\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_4byte_unsigned(wStream* s, UINT32* value)\n{\n\tBYTE byte;\n\tBYTE count;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, byte);\n\tcount = (byte & 0xC0) >> 6;\n\n\tif (Stream_GetRemainingLength(s) < count)\n\t\treturn FALSE;\n\n\tswitch (count)\n\t{\n\t\tcase 0:\n\t\t\t*value = (byte & 0x3F);\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\t*value = (byte & 0x3F) << 8;\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= byte;\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\t*value = (byte & 0x3F) << 16;\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= (byte << 8);\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= byte;\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\t*value = (byte & 0x3F) << 24;\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= (byte << 16);\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= (byte << 8);\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= byte;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_4byte_unsigned(wStream* s, UINT32 value)\n{\n\tBYTE byte;\n\n\tif (value <= 0x3F)\n\t{\n\t\tStream_Write_UINT8(s, value);\n\t}\n\telse if (value <= 0x3FFF)\n\t{\n\t\tbyte = (value >> 8) & 0x3F;\n\t\tStream_Write_UINT8(s, byte | 0x40);\n\t\tbyte = (value & 0xFF);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse if (value <= 0x3FFFFF)\n\t{\n\t\tbyte = (value >> 16) & 0x3F;\n\t\tStream_Write_UINT8(s, byte | 0x80);\n\t\tbyte = (value >> 8) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (value & 0xFF);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse if (value <= 0x3FFFFFFF)\n\t{\n\t\tbyte = (value >> 24) & 0x3F;\n\t\tStream_Write_UINT8(s, byte | 0xC0);\n\t\tbyte = (value >> 16) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (value >> 8) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (value & 0xFF);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_delta(wStream* s, INT32* value)\n{\n\tBYTE byte;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 1\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT8(s, byte);\n\n\tif (byte & 0x40)\n\t\t*value = (byte | ~0x3F);\n\telse\n\t\t*value = (byte & 0x3F);\n\n\tif (byte & 0x80)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 1\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tStream_Read_UINT8(s, byte);\n\t\t*value = (*value << 8) | byte;\n\t}\n\n\treturn TRUE;\n}\n#if 0\nstatic INLINE void update_read_glyph_delta(wStream* s, UINT16* value)\n{\n\tBYTE byte;\n\tStream_Read_UINT8(s, byte);\n\n\tif (byte == 0x80)\n\t\tStream_Read_UINT16(s, *value);\n\telse\n\t\t*value = (byte & 0x3F);\n}\nstatic INLINE void update_seek_glyph_delta(wStream* s)\n{\n\tBYTE byte;\n\tStream_Read_UINT8(s, byte);\n\n\tif (byte & 0x80)\n\t\tStream_Seek_UINT8(s);\n}\n#endif\nstatic INLINE BOOL update_read_brush(wStream* s, rdpBrush* brush, BYTE fieldFlags)\n{\n\tif (fieldFlags & ORDER_FIELD_01)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, brush->x);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_02)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, brush->y);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_03)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, brush->style);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_04)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, brush->hatch);\n\t}\n\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->index = brush->hatch;\n\t\tbrush->bpp = BMF_BPP[brush->style & 0x07];\n\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 7)\n\t\t\treturn FALSE;\n\n\t\tbrush->data = (BYTE*)brush->p8x8;\n\t\tStream_Read_UINT8(s, brush->data[7]);\n\t\tStream_Read_UINT8(s, brush->data[6]);\n\t\tStream_Read_UINT8(s, brush->data[5]);\n\t\tStream_Read_UINT8(s, brush->data[4]);\n\t\tStream_Read_UINT8(s, brush->data[3]);\n\t\tStream_Read_UINT8(s, brush->data[2]);\n\t\tStream_Read_UINT8(s, brush->data[1]);\n\t\tbrush->data[0] = brush->hatch;\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_brush(wStream* s, rdpBrush* brush, BYTE fieldFlags)\n{\n\tif (fieldFlags & ORDER_FIELD_01)\n\t{\n\t\tStream_Write_UINT8(s, brush->x);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_02)\n\t{\n\t\tStream_Write_UINT8(s, brush->y);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_03)\n\t{\n\t\tStream_Write_UINT8(s, brush->style);\n\t}\n\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->hatch = brush->index;\n\t\tbrush->bpp = BMF_BPP[brush->style & 0x07];\n\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_04)\n\t{\n\t\tStream_Write_UINT8(s, brush->hatch);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tbrush->data = (BYTE*)brush->p8x8;\n\t\tStream_Write_UINT8(s, brush->data[7]);\n\t\tStream_Write_UINT8(s, brush->data[6]);\n\t\tStream_Write_UINT8(s, brush->data[5]);\n\t\tStream_Write_UINT8(s, brush->data[4]);\n\t\tStream_Write_UINT8(s, brush->data[3]);\n\t\tStream_Write_UINT8(s, brush->data[2]);\n\t\tStream_Write_UINT8(s, brush->data[1]);\n\t\tbrush->data[0] = brush->hatch;\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_delta_rects(wStream* s, DELTA_RECT* rectangles, UINT32* nr)\n{\n\tUINT32 number = *nr;\n\tUINT32 i;\n\tBYTE flags = 0;\n\tBYTE* zeroBits;\n\tUINT32 zeroBitsSize;\n\n\tif (number > 45)\n\t{\n\t\tWLog_WARN(TAG, \"Invalid number of delta rectangles %\" PRIu32, number);\n\t\treturn FALSE;\n\t}\n\n\tzeroBitsSize = ((number + 1) / 2);\n\n\tif (Stream_GetRemainingLength(s) < zeroBitsSize)\n\t\treturn FALSE;\n\n\tStream_GetPointer(s, zeroBits);\n\tStream_Seek(s, zeroBitsSize);\n\tZeroMemory(rectangles, sizeof(DELTA_RECT) * number);\n\n\tfor (i = 0; i < number; i++)\n\t{\n\t\tif (i % 2 == 0)\n\t\t\tflags = zeroBits[i / 2];\n\n\t\tif ((~flags & 0x80) && !update_read_delta(s, &rectangles[i].left))\n\t\t\treturn FALSE;\n\n\t\tif ((~flags & 0x40) && !update_read_delta(s, &rectangles[i].top))\n\t\t\treturn FALSE;\n\n\t\tif (~flags & 0x20)\n\t\t{\n\t\t\tif (!update_read_delta(s, &rectangles[i].width))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse if (i > 0)\n\t\t\trectangles[i].width = rectangles[i - 1].width;\n\t\telse\n\t\t\trectangles[i].width = 0;\n\n\t\tif (~flags & 0x10)\n\t\t{\n\t\t\tif (!update_read_delta(s, &rectangles[i].height))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse if (i > 0)\n\t\t\trectangles[i].height = rectangles[i - 1].height;\n\t\telse\n\t\t\trectangles[i].height = 0;\n\n\t\tif (i > 0)\n\t\t{\n\t\t\trectangles[i].left += rectangles[i - 1].left;\n\t\t\trectangles[i].top += rectangles[i - 1].top;\n\t\t}\n\n\t\tflags <<= 4;\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_delta_points(wStream* s, DELTA_POINT* points, int number, INT16 x,\n                                            INT16 y)\n{\n\tint i;\n\tBYTE flags = 0;\n\tBYTE* zeroBits;\n\tUINT32 zeroBitsSize;\n\tzeroBitsSize = ((number + 3) / 4);\n\n\tif (Stream_GetRemainingLength(s) < zeroBitsSize)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < %\" PRIu32 \"\", zeroBitsSize);\n\t\treturn FALSE;\n\t}\n\n\tStream_GetPointer(s, zeroBits);\n\tStream_Seek(s, zeroBitsSize);\n\tZeroMemory(points, sizeof(DELTA_POINT) * number);\n\n\tfor (i = 0; i < number; i++)\n\t{\n\t\tif (i % 4 == 0)\n\t\t\tflags = zeroBits[i / 4];\n\n\t\tif ((~flags & 0x80) && !update_read_delta(s, &points[i].x))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"update_read_delta(x) failed\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif ((~flags & 0x40) && !update_read_delta(s, &points[i].y))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"update_read_delta(y) failed\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tflags <<= 2;\n\t}\n\n\treturn TRUE;\n}\n#define ORDER_FIELD_BYTE(NO, TARGET)                        \\\n\tdo                                                      \\\n\t{                                                       \\\n\t\tif (orderInfo->fieldFlags & (1 << (NO - 1)))        \\\n\t\t{                                                   \\\n\t\t\tif (Stream_GetRemainingLength(s) < 1)           \\\n\t\t\t{                                               \\\n\t\t\t\tWLog_ERR(TAG, \"error reading %s\", #TARGET); \\\n\t\t\t\treturn FALSE;                               \\\n\t\t\t}                                               \\\n\t\t\tStream_Read_UINT8(s, TARGET);                   \\\n\t\t}                                                   \\\n\t} while (0)\n#define ORDER_FIELD_2BYTE(NO, TARGET1, TARGET2)                              \\\n\tdo                                                                       \\\n\t{                                                                        \\\n\t\tif (orderInfo->fieldFlags & (1 << (NO - 1)))                         \\\n\t\t{                                                                    \\\n\t\t\tif (Stream_GetRemainingLength(s) < 2)                            \\\n\t\t\t{                                                                \\\n\t\t\t\tWLog_ERR(TAG, \"error reading %s or %s\", #TARGET1, #TARGET2); \\\n\t\t\t\treturn FALSE;                                                \\\n\t\t\t}                                                                \\\n\t\t\tStream_Read_UINT8(s, TARGET1);                                   \\\n\t\t\tStream_Read_UINT8(s, TARGET2);                                   \\\n\t\t}                                                                    \\\n\t} while (0)\n#define ORDER_FIELD_UINT16(NO, TARGET)                      \\\n\tdo                                                      \\\n\t{                                                       \\\n\t\tif (orderInfo->fieldFlags & (1 << (NO - 1)))        \\\n\t\t{                                                   \\\n\t\t\tif (Stream_GetRemainingLength(s) < 2)           \\\n\t\t\t{                                               \\\n\t\t\t\tWLog_ERR(TAG, \"error reading %s\", #TARGET); \\\n\t\t\t\treturn FALSE;                               \\\n\t\t\t}                                               \\\n\t\t\tStream_Read_UINT16(s, TARGET);                  \\\n\t\t}                                                   \\\n\t} while (0)\n#define ORDER_FIELD_UINT32(NO, TARGET)                      \\\n\tdo                                                      \\\n\t{                                                       \\\n\t\tif (orderInfo->fieldFlags & (1 << (NO - 1)))        \\\n\t\t{                                                   \\\n\t\t\tif (Stream_GetRemainingLength(s) < 4)           \\\n\t\t\t{                                               \\\n\t\t\t\tWLog_ERR(TAG, \"error reading %s\", #TARGET); \\\n\t\t\t\treturn FALSE;                               \\\n\t\t\t}                                               \\\n\t\t\tStream_Read_UINT32(s, TARGET);                  \\\n\t\t}                                                   \\\n\t} while (0)\n#define ORDER_FIELD_COORD(NO, TARGET)                                    \\\n\tdo                                                                   \\\n\t{                                                                    \\\n\t\tif ((orderInfo->fieldFlags & (1 << (NO - 1))) &&                 \\\n\t\t    !update_read_coord(s, &TARGET, orderInfo->deltaCoordinates)) \\\n\t\t{                                                                \\\n\t\t\tWLog_ERR(TAG, \"error reading %s\", #TARGET);                  \\\n\t\t\treturn FALSE;                                                \\\n\t\t}                                                                \\\n\t} while (0)\nstatic INLINE BOOL ORDER_FIELD_COLOR(const ORDER_INFO* orderInfo, wStream* s, UINT32 NO,\n                                     UINT32* TARGET)\n{\n\tif (!TARGET || !orderInfo)\n\t\treturn FALSE;\n\n\tif ((orderInfo->fieldFlags & (1 << (NO - 1))) && !update_read_color(s, TARGET))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\nstatic INLINE BOOL FIELD_SKIP_BUFFER16(wStream* s, UINT32 TARGET_LEN)\n{\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, TARGET_LEN);\n\n\tif (!Stream_SafeSeek(s, TARGET_LEN))\n\t{\n\t\tWLog_ERR(TAG, \"error skipping %\" PRIu32 \" bytes\", TARGET_LEN);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n/* Primary Drawing Orders */\nstatic BOOL update_read_dstblt_order(wStream* s, const ORDER_INFO* orderInfo, DSTBLT_ORDER* dstblt)\n{\n\tORDER_FIELD_COORD(1, dstblt->nLeftRect);\n\tORDER_FIELD_COORD(2, dstblt->nTopRect);\n\tORDER_FIELD_COORD(3, dstblt->nWidth);\n\tORDER_FIELD_COORD(4, dstblt->nHeight);\n\tORDER_FIELD_BYTE(5, dstblt->bRop);\n\treturn TRUE;\n}\nint update_approximate_dstblt_order(ORDER_INFO* orderInfo, const DSTBLT_ORDER* dstblt)\n{\n\treturn 32;\n}\nBOOL update_write_dstblt_order(wStream* s, ORDER_INFO* orderInfo, const DSTBLT_ORDER* dstblt)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, update_approximate_dstblt_order(orderInfo, dstblt)))\n\t\treturn FALSE;\n\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tupdate_write_coord(s, dstblt->nLeftRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, dstblt->nTopRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, dstblt->nWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, dstblt->nHeight);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tStream_Write_UINT8(s, dstblt->bRop);\n\treturn TRUE;\n}\nstatic BOOL update_read_patblt_order(wStream* s, const ORDER_INFO* orderInfo, PATBLT_ORDER* patblt)\n{\n\tORDER_FIELD_COORD(1, patblt->nLeftRect);\n\tORDER_FIELD_COORD(2, patblt->nTopRect);\n\tORDER_FIELD_COORD(3, patblt->nWidth);\n\tORDER_FIELD_COORD(4, patblt->nHeight);\n\tORDER_FIELD_BYTE(5, patblt->bRop);\n\tORDER_FIELD_COLOR(orderInfo, s, 6, &patblt->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 7, &patblt->foreColor);\n\treturn update_read_brush(s, &patblt->brush, orderInfo->fieldFlags >> 7);\n}\nint update_approximate_patblt_order(ORDER_INFO* orderInfo, PATBLT_ORDER* patblt)\n{\n\treturn 32;\n}\nBOOL update_write_patblt_order(wStream* s, ORDER_INFO* orderInfo, PATBLT_ORDER* patblt)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, update_approximate_patblt_order(orderInfo, patblt)))\n\t\treturn FALSE;\n\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tupdate_write_coord(s, patblt->nLeftRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, patblt->nTopRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, patblt->nWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, patblt->nHeight);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tStream_Write_UINT8(s, patblt->bRop);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tupdate_write_color(s, patblt->backColor);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tupdate_write_color(s, patblt->foreColor);\n\torderInfo->fieldFlags |= ORDER_FIELD_08;\n\torderInfo->fieldFlags |= ORDER_FIELD_09;\n\torderInfo->fieldFlags |= ORDER_FIELD_10;\n\torderInfo->fieldFlags |= ORDER_FIELD_11;\n\torderInfo->fieldFlags |= ORDER_FIELD_12;\n\tupdate_write_brush(s, &patblt->brush, orderInfo->fieldFlags >> 7);\n\treturn TRUE;\n}\nstatic BOOL update_read_scrblt_order(wStream* s, const ORDER_INFO* orderInfo, SCRBLT_ORDER* scrblt)\n{\n\tORDER_FIELD_COORD(1, scrblt->nLeftRect);\n\tORDER_FIELD_COORD(2, scrblt->nTopRect);\n\tORDER_FIELD_COORD(3, scrblt->nWidth);\n\tORDER_FIELD_COORD(4, scrblt->nHeight);\n\tORDER_FIELD_BYTE(5, scrblt->bRop);\n\tORDER_FIELD_COORD(6, scrblt->nXSrc);\n\tORDER_FIELD_COORD(7, scrblt->nYSrc);\n\treturn TRUE;\n}\nint update_approximate_scrblt_order(ORDER_INFO* orderInfo, const SCRBLT_ORDER* scrblt)\n{\n\treturn 32;\n}\nBOOL update_write_scrblt_order(wStream* s, ORDER_INFO* orderInfo, const SCRBLT_ORDER* scrblt)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, update_approximate_scrblt_order(orderInfo, scrblt)))\n\t\treturn FALSE;\n\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tupdate_write_coord(s, scrblt->nLeftRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, scrblt->nTopRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, scrblt->nWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, scrblt->nHeight);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tStream_Write_UINT8(s, scrblt->bRop);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tupdate_write_coord(s, scrblt->nXSrc);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tupdate_write_coord(s, scrblt->nYSrc);\n\treturn TRUE;\n}\nstatic BOOL update_read_opaque_rect_order(wStream* s, const ORDER_INFO* orderInfo,\n                                          OPAQUE_RECT_ORDER* opaque_rect)\n{\n\tBYTE byte;\n\tORDER_FIELD_COORD(1, opaque_rect->nLeftRect);\n\tORDER_FIELD_COORD(2, opaque_rect->nTopRect);\n\tORDER_FIELD_COORD(3, opaque_rect->nWidth);\n\tORDER_FIELD_COORD(4, opaque_rect->nHeight);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\topaque_rect->color = (opaque_rect->color & 0x00FFFF00) | ((UINT32)byte);\n\t}\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_06)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\topaque_rect->color = (opaque_rect->color & 0x00FF00FF) | ((UINT32)byte << 8);\n\t}\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\topaque_rect->color = (opaque_rect->color & 0x0000FFFF) | ((UINT32)byte << 16);\n\t}\n\n\treturn TRUE;\n}\nint update_approximate_opaque_rect_order(ORDER_INFO* orderInfo,\n                                         const OPAQUE_RECT_ORDER* opaque_rect)\n{\n\treturn 32;\n}\nBOOL update_write_opaque_rect_order(wStream* s, ORDER_INFO* orderInfo,\n                                    const OPAQUE_RECT_ORDER* opaque_rect)\n{\n\tBYTE byte;\n\tint inf = update_approximate_opaque_rect_order(orderInfo, opaque_rect);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\t// TODO: Color format conversion\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tupdate_write_coord(s, opaque_rect->nLeftRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, opaque_rect->nTopRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, opaque_rect->nWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, opaque_rect->nHeight);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tbyte = opaque_rect->color & 0x000000FF;\n\tStream_Write_UINT8(s, byte);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tbyte = (opaque_rect->color & 0x0000FF00) >> 8;\n\tStream_Write_UINT8(s, byte);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tbyte = (opaque_rect->color & 0x00FF0000) >> 16;\n\tStream_Write_UINT8(s, byte);\n\treturn TRUE;\n}\nstatic BOOL update_read_draw_nine_grid_order(wStream* s, const ORDER_INFO* orderInfo,\n                                             DRAW_NINE_GRID_ORDER* draw_nine_grid)\n{\n\tORDER_FIELD_COORD(1, draw_nine_grid->srcLeft);\n\tORDER_FIELD_COORD(2, draw_nine_grid->srcTop);\n\tORDER_FIELD_COORD(3, draw_nine_grid->srcRight);\n\tORDER_FIELD_COORD(4, draw_nine_grid->srcBottom);\n\tORDER_FIELD_UINT16(5, draw_nine_grid->bitmapId);\n\treturn TRUE;\n}\nstatic BOOL update_read_multi_dstblt_order(wStream* s, const ORDER_INFO* orderInfo,\n                                           MULTI_DSTBLT_ORDER* multi_dstblt)\n{\n\tORDER_FIELD_COORD(1, multi_dstblt->nLeftRect);\n\tORDER_FIELD_COORD(2, multi_dstblt->nTopRect);\n\tORDER_FIELD_COORD(3, multi_dstblt->nWidth);\n\tORDER_FIELD_COORD(4, multi_dstblt->nHeight);\n\tORDER_FIELD_BYTE(5, multi_dstblt->bRop);\n\tORDER_FIELD_BYTE(6, multi_dstblt->numRectangles);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, multi_dstblt->cbData);\n\t\treturn update_read_delta_rects(s, multi_dstblt->rectangles, &multi_dstblt->numRectangles);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_multi_patblt_order(wStream* s, const ORDER_INFO* orderInfo,\n                                           MULTI_PATBLT_ORDER* multi_patblt)\n{\n\tORDER_FIELD_COORD(1, multi_patblt->nLeftRect);\n\tORDER_FIELD_COORD(2, multi_patblt->nTopRect);\n\tORDER_FIELD_COORD(3, multi_patblt->nWidth);\n\tORDER_FIELD_COORD(4, multi_patblt->nHeight);\n\tORDER_FIELD_BYTE(5, multi_patblt->bRop);\n\tORDER_FIELD_COLOR(orderInfo, s, 6, &multi_patblt->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 7, &multi_patblt->foreColor);\n\n\tif (!update_read_brush(s, &multi_patblt->brush, orderInfo->fieldFlags >> 7))\n\t\treturn FALSE;\n\n\tORDER_FIELD_BYTE(13, multi_patblt->numRectangles);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_14)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, multi_patblt->cbData);\n\n\t\tif (!update_read_delta_rects(s, multi_patblt->rectangles, &multi_patblt->numRectangles))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_multi_scrblt_order(wStream* s, const ORDER_INFO* orderInfo,\n                                           MULTI_SCRBLT_ORDER* multi_scrblt)\n{\n\tORDER_FIELD_COORD(1, multi_scrblt->nLeftRect);\n\tORDER_FIELD_COORD(2, multi_scrblt->nTopRect);\n\tORDER_FIELD_COORD(3, multi_scrblt->nWidth);\n\tORDER_FIELD_COORD(4, multi_scrblt->nHeight);\n\tORDER_FIELD_BYTE(5, multi_scrblt->bRop);\n\tORDER_FIELD_COORD(6, multi_scrblt->nXSrc);\n\tORDER_FIELD_COORD(7, multi_scrblt->nYSrc);\n\tORDER_FIELD_BYTE(8, multi_scrblt->numRectangles);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_09)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, multi_scrblt->cbData);\n\t\treturn update_read_delta_rects(s, multi_scrblt->rectangles, &multi_scrblt->numRectangles);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_multi_opaque_rect_order(wStream* s, const ORDER_INFO* orderInfo,\n                                                MULTI_OPAQUE_RECT_ORDER* multi_opaque_rect)\n{\n\tBYTE byte;\n\tORDER_FIELD_COORD(1, multi_opaque_rect->nLeftRect);\n\tORDER_FIELD_COORD(2, multi_opaque_rect->nTopRect);\n\tORDER_FIELD_COORD(3, multi_opaque_rect->nWidth);\n\tORDER_FIELD_COORD(4, multi_opaque_rect->nHeight);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\tmulti_opaque_rect->color = (multi_opaque_rect->color & 0x00FFFF00) | ((UINT32)byte);\n\t}\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_06)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\tmulti_opaque_rect->color = (multi_opaque_rect->color & 0x00FF00FF) | ((UINT32)byte << 8);\n\t}\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\tmulti_opaque_rect->color = (multi_opaque_rect->color & 0x0000FFFF) | ((UINT32)byte << 16);\n\t}\n\n\tORDER_FIELD_BYTE(8, multi_opaque_rect->numRectangles);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_09)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, multi_opaque_rect->cbData);\n\t\treturn update_read_delta_rects(s, multi_opaque_rect->rectangles,\n\t\t                               &multi_opaque_rect->numRectangles);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_multi_draw_nine_grid_order(wStream* s, const ORDER_INFO* orderInfo,\n                                                   MULTI_DRAW_NINE_GRID_ORDER* multi_draw_nine_grid)\n{\n\tORDER_FIELD_COORD(1, multi_draw_nine_grid->srcLeft);\n\tORDER_FIELD_COORD(2, multi_draw_nine_grid->srcTop);\n\tORDER_FIELD_COORD(3, multi_draw_nine_grid->srcRight);\n\tORDER_FIELD_COORD(4, multi_draw_nine_grid->srcBottom);\n\tORDER_FIELD_UINT16(5, multi_draw_nine_grid->bitmapId);\n\tORDER_FIELD_BYTE(6, multi_draw_nine_grid->nDeltaEntries);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, multi_draw_nine_grid->cbData);\n\t\treturn update_read_delta_rects(s, multi_draw_nine_grid->rectangles,\n\t\t                               &multi_draw_nine_grid->nDeltaEntries);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_line_to_order(wStream* s, const ORDER_INFO* orderInfo,\n                                      LINE_TO_ORDER* line_to)\n{\n\tORDER_FIELD_UINT16(1, line_to->backMode);\n\tORDER_FIELD_COORD(2, line_to->nXStart);\n\tORDER_FIELD_COORD(3, line_to->nYStart);\n\tORDER_FIELD_COORD(4, line_to->nXEnd);\n\tORDER_FIELD_COORD(5, line_to->nYEnd);\n\tORDER_FIELD_COLOR(orderInfo, s, 6, &line_to->backColor);\n\tORDER_FIELD_BYTE(7, line_to->bRop2);\n\tORDER_FIELD_BYTE(8, line_to->penStyle);\n\tORDER_FIELD_BYTE(9, line_to->penWidth);\n\tORDER_FIELD_COLOR(orderInfo, s, 10, &line_to->penColor);\n\treturn TRUE;\n}\nint update_approximate_line_to_order(ORDER_INFO* orderInfo, const LINE_TO_ORDER* line_to)\n{\n\treturn 32;\n}\nBOOL update_write_line_to_order(wStream* s, ORDER_INFO* orderInfo, const LINE_TO_ORDER* line_to)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, update_approximate_line_to_order(orderInfo, line_to)))\n\t\treturn FALSE;\n\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tStream_Write_UINT16(s, line_to->backMode);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, line_to->nXStart);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, line_to->nYStart);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, line_to->nXEnd);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tupdate_write_coord(s, line_to->nYEnd);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tupdate_write_color(s, line_to->backColor);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tStream_Write_UINT8(s, line_to->bRop2);\n\torderInfo->fieldFlags |= ORDER_FIELD_08;\n\tStream_Write_UINT8(s, line_to->penStyle);\n\torderInfo->fieldFlags |= ORDER_FIELD_09;\n\tStream_Write_UINT8(s, line_to->penWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_10;\n\tupdate_write_color(s, line_to->penColor);\n\treturn TRUE;\n}\nstatic BOOL update_read_polyline_order(wStream* s, const ORDER_INFO* orderInfo,\n                                       POLYLINE_ORDER* polyline)\n{\n\tUINT16 word;\n\tUINT32 new_num = polyline->numDeltaEntries;\n\tORDER_FIELD_COORD(1, polyline->xStart);\n\tORDER_FIELD_COORD(2, polyline->yStart);\n\tORDER_FIELD_BYTE(3, polyline->bRop2);\n\tORDER_FIELD_UINT16(4, word);\n\tORDER_FIELD_COLOR(orderInfo, s, 5, &polyline->penColor);\n\tORDER_FIELD_BYTE(6, new_num);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tDELTA_POINT* new_points;\n\n\t\tif (new_num == 0)\n\t\t\treturn FALSE;\n\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 1\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tStream_Read_UINT8(s, polyline->cbData);\n\t\tnew_points = (DELTA_POINT*)realloc(polyline->points, sizeof(DELTA_POINT) * new_num);\n\n\t\tif (!new_points)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"realloc(%\" PRIu32 \") failed\", new_num);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tpolyline->points = new_points;\n\t\tpolyline->numDeltaEntries = new_num;\n\t\treturn update_read_delta_points(s, polyline->points, polyline->numDeltaEntries,\n\t\t                                polyline->xStart, polyline->yStart);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_memblt_order(wStream* s, const ORDER_INFO* orderInfo, MEMBLT_ORDER* memblt)\n{\n\tif (!s || !orderInfo || !memblt)\n\t\treturn FALSE;\n\n\tORDER_FIELD_UINT16(1, memblt->cacheId);\n\tORDER_FIELD_COORD(2, memblt->nLeftRect);\n\tORDER_FIELD_COORD(3, memblt->nTopRect);\n\tORDER_FIELD_COORD(4, memblt->nWidth);\n\tORDER_FIELD_COORD(5, memblt->nHeight);\n\tORDER_FIELD_BYTE(6, memblt->bRop);\n\tORDER_FIELD_COORD(7, memblt->nXSrc);\n\tORDER_FIELD_COORD(8, memblt->nYSrc);\n\tORDER_FIELD_UINT16(9, memblt->cacheIndex);\n\tmemblt->colorIndex = (memblt->cacheId >> 8);\n\tmemblt->cacheId = (memblt->cacheId & 0xFF);\n\tmemblt->bitmap = NULL;\n\treturn TRUE;\n}\nint update_approximate_memblt_order(ORDER_INFO* orderInfo, const MEMBLT_ORDER* memblt)\n{\n\treturn 64;\n}\nBOOL update_write_memblt_order(wStream* s, ORDER_INFO* orderInfo, const MEMBLT_ORDER* memblt)\n{\n\tUINT16 cacheId;\n\n\tif (!Stream_EnsureRemainingCapacity(s, update_approximate_memblt_order(orderInfo, memblt)))\n\t\treturn FALSE;\n\n\tcacheId = (memblt->cacheId & 0xFF) | ((memblt->colorIndex & 0xFF) << 8);\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tStream_Write_UINT16(s, cacheId);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, memblt->nLeftRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, memblt->nTopRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, memblt->nWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tupdate_write_coord(s, memblt->nHeight);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tStream_Write_UINT8(s, memblt->bRop);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tupdate_write_coord(s, memblt->nXSrc);\n\torderInfo->fieldFlags |= ORDER_FIELD_08;\n\tupdate_write_coord(s, memblt->nYSrc);\n\torderInfo->fieldFlags |= ORDER_FIELD_09;\n\tStream_Write_UINT16(s, memblt->cacheIndex);\n\treturn TRUE;\n}\nstatic BOOL update_read_mem3blt_order(wStream* s, const ORDER_INFO* orderInfo,\n                                      MEM3BLT_ORDER* mem3blt)\n{\n\tORDER_FIELD_UINT16(1, mem3blt->cacheId);\n\tORDER_FIELD_COORD(2, mem3blt->nLeftRect);\n\tORDER_FIELD_COORD(3, mem3blt->nTopRect);\n\tORDER_FIELD_COORD(4, mem3blt->nWidth);\n\tORDER_FIELD_COORD(5, mem3blt->nHeight);\n\tORDER_FIELD_BYTE(6, mem3blt->bRop);\n\tORDER_FIELD_COORD(7, mem3blt->nXSrc);\n\tORDER_FIELD_COORD(8, mem3blt->nYSrc);\n\tORDER_FIELD_COLOR(orderInfo, s, 9, &mem3blt->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 10, &mem3blt->foreColor);\n\n\tif (!update_read_brush(s, &mem3blt->brush, orderInfo->fieldFlags >> 10))\n\t\treturn FALSE;\n\n\tORDER_FIELD_UINT16(16, mem3blt->cacheIndex);\n\tmem3blt->colorIndex = (mem3blt->cacheId >> 8);\n\tmem3blt->cacheId = (mem3blt->cacheId & 0xFF);\n\tmem3blt->bitmap = NULL;\n\treturn TRUE;\n}\nstatic BOOL update_read_save_bitmap_order(wStream* s, const ORDER_INFO* orderInfo,\n                                          SAVE_BITMAP_ORDER* save_bitmap)\n{\n\tORDER_FIELD_UINT32(1, save_bitmap->savedBitmapPosition);\n\tORDER_FIELD_COORD(2, save_bitmap->nLeftRect);\n\tORDER_FIELD_COORD(3, save_bitmap->nTopRect);\n\tORDER_FIELD_COORD(4, save_bitmap->nRightRect);\n\tORDER_FIELD_COORD(5, save_bitmap->nBottomRect);\n\tORDER_FIELD_BYTE(6, save_bitmap->operation);\n\treturn TRUE;\n}\nstatic BOOL update_read_glyph_index_order(wStream* s, const ORDER_INFO* orderInfo,\n                                          GLYPH_INDEX_ORDER* glyph_index)\n{\n\tORDER_FIELD_BYTE(1, glyph_index->cacheId);\n\tORDER_FIELD_BYTE(2, glyph_index->flAccel);\n\tORDER_FIELD_BYTE(3, glyph_index->ulCharInc);\n\tORDER_FIELD_BYTE(4, glyph_index->fOpRedundant);\n\tORDER_FIELD_COLOR(orderInfo, s, 5, &glyph_index->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 6, &glyph_index->foreColor);\n\tORDER_FIELD_UINT16(7, glyph_index->bkLeft);\n\tORDER_FIELD_UINT16(8, glyph_index->bkTop);\n\tORDER_FIELD_UINT16(9, glyph_index->bkRight);\n\tORDER_FIELD_UINT16(10, glyph_index->bkBottom);\n\tORDER_FIELD_UINT16(11, glyph_index->opLeft);\n\tORDER_FIELD_UINT16(12, glyph_index->opTop);\n\tORDER_FIELD_UINT16(13, glyph_index->opRight);\n\tORDER_FIELD_UINT16(14, glyph_index->opBottom);\n\n\tif (!update_read_brush(s, &glyph_index->brush, orderInfo->fieldFlags >> 14))\n\t\treturn FALSE;\n\n\tORDER_FIELD_UINT16(20, glyph_index->x);\n\tORDER_FIELD_UINT16(21, glyph_index->y);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_22)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, glyph_index->cbData);\n\n\t\tif (Stream_GetRemainingLength(s) < glyph_index->cbData)\n\t\t\treturn FALSE;\n\n\t\tCopyMemory(glyph_index->data, Stream_Pointer(s), glyph_index->cbData);\n\t\tStream_Seek(s, glyph_index->cbData);\n\t}\n\n\treturn TRUE;\n}\nint update_approximate_glyph_index_order(ORDER_INFO* orderInfo,\n                                         const GLYPH_INDEX_ORDER* glyph_index)\n{\n\treturn 64;\n}\nBOOL update_write_glyph_index_order(wStream* s, ORDER_INFO* orderInfo,\n                                    GLYPH_INDEX_ORDER* glyph_index)\n{\n\tint inf = update_approximate_glyph_index_order(orderInfo, glyph_index);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tStream_Write_UINT8(s, glyph_index->cacheId);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tStream_Write_UINT8(s, glyph_index->flAccel);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tStream_Write_UINT8(s, glyph_index->ulCharInc);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tStream_Write_UINT8(s, glyph_index->fOpRedundant);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tupdate_write_color(s, glyph_index->backColor);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tupdate_write_color(s, glyph_index->foreColor);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tStream_Write_UINT16(s, glyph_index->bkLeft);\n\torderInfo->fieldFlags |= ORDER_FIELD_08;\n\tStream_Write_UINT16(s, glyph_index->bkTop);\n\torderInfo->fieldFlags |= ORDER_FIELD_09;\n\tStream_Write_UINT16(s, glyph_index->bkRight);\n\torderInfo->fieldFlags |= ORDER_FIELD_10;\n\tStream_Write_UINT16(s, glyph_index->bkBottom);\n\torderInfo->fieldFlags |= ORDER_FIELD_11;\n\tStream_Write_UINT16(s, glyph_index->opLeft);\n\torderInfo->fieldFlags |= ORDER_FIELD_12;\n\tStream_Write_UINT16(s, glyph_index->opTop);\n\torderInfo->fieldFlags |= ORDER_FIELD_13;\n\tStream_Write_UINT16(s, glyph_index->opRight);\n\torderInfo->fieldFlags |= ORDER_FIELD_14;\n\tStream_Write_UINT16(s, glyph_index->opBottom);\n\torderInfo->fieldFlags |= ORDER_FIELD_15;\n\torderInfo->fieldFlags |= ORDER_FIELD_16;\n\torderInfo->fieldFlags |= ORDER_FIELD_17;\n\torderInfo->fieldFlags |= ORDER_FIELD_18;\n\torderInfo->fieldFlags |= ORDER_FIELD_19;\n\tupdate_write_brush(s, &glyph_index->brush, orderInfo->fieldFlags >> 14);\n\torderInfo->fieldFlags |= ORDER_FIELD_20;\n\tStream_Write_UINT16(s, glyph_index->x);\n\torderInfo->fieldFlags |= ORDER_FIELD_21;\n\tStream_Write_UINT16(s, glyph_index->y);\n\torderInfo->fieldFlags |= ORDER_FIELD_22;\n\tStream_Write_UINT8(s, glyph_index->cbData);\n\tStream_Write(s, glyph_index->data, glyph_index->cbData);\n\treturn TRUE;\n}\nstatic BOOL update_read_fast_index_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         FAST_INDEX_ORDER* fast_index)\n{\n\tORDER_FIELD_BYTE(1, fast_index->cacheId);\n\tORDER_FIELD_2BYTE(2, fast_index->ulCharInc, fast_index->flAccel);\n\tORDER_FIELD_COLOR(orderInfo, s, 3, &fast_index->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 4, &fast_index->foreColor);\n\tORDER_FIELD_COORD(5, fast_index->bkLeft);\n\tORDER_FIELD_COORD(6, fast_index->bkTop);\n\tORDER_FIELD_COORD(7, fast_index->bkRight);\n\tORDER_FIELD_COORD(8, fast_index->bkBottom);\n\tORDER_FIELD_COORD(9, fast_index->opLeft);\n\tORDER_FIELD_COORD(10, fast_index->opTop);\n\tORDER_FIELD_COORD(11, fast_index->opRight);\n\tORDER_FIELD_COORD(12, fast_index->opBottom);\n\tORDER_FIELD_COORD(13, fast_index->x);\n\tORDER_FIELD_COORD(14, fast_index->y);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_15)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, fast_index->cbData);\n\n\t\tif (Stream_GetRemainingLength(s) < fast_index->cbData)\n\t\t\treturn FALSE;\n\n\t\tCopyMemory(fast_index->data, Stream_Pointer(s), fast_index->cbData);\n\t\tStream_Seek(s, fast_index->cbData);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_fast_glyph_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         FAST_GLYPH_ORDER* fastGlyph)\n{\n\tGLYPH_DATA_V2* glyph = &fastGlyph->glyphData;\n\tORDER_FIELD_BYTE(1, fastGlyph->cacheId);\n\tORDER_FIELD_2BYTE(2, fastGlyph->ulCharInc, fastGlyph->flAccel);\n\tORDER_FIELD_COLOR(orderInfo, s, 3, &fastGlyph->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 4, &fastGlyph->foreColor);\n\tORDER_FIELD_COORD(5, fastGlyph->bkLeft);\n\tORDER_FIELD_COORD(6, fastGlyph->bkTop);\n\tORDER_FIELD_COORD(7, fastGlyph->bkRight);\n\tORDER_FIELD_COORD(8, fastGlyph->bkBottom);\n\tORDER_FIELD_COORD(9, fastGlyph->opLeft);\n\tORDER_FIELD_COORD(10, fastGlyph->opTop);\n\tORDER_FIELD_COORD(11, fastGlyph->opRight);\n\tORDER_FIELD_COORD(12, fastGlyph->opBottom);\n\tORDER_FIELD_COORD(13, fastGlyph->x);\n\tORDER_FIELD_COORD(14, fastGlyph->y);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_15)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, fastGlyph->cbData);\n\n\t\tif (Stream_GetRemainingLength(s) < fastGlyph->cbData)\n\t\t\treturn FALSE;\n\n\t\tCopyMemory(fastGlyph->data, Stream_Pointer(s), fastGlyph->cbData);\n\t\tif (Stream_GetRemainingLength(s) < fastGlyph->cbData)\n\t\t\treturn FALSE;\n\n\t\tif (!Stream_SafeSeek(s, 1))\n\t\t\treturn FALSE;\n\n\t\tif (fastGlyph->cbData > 1)\n\t\t{\n\t\t\tUINT32 new_cb;\n\t\t\t/* parse optional glyph data */\n\t\t\tglyph->cacheIndex = fastGlyph->data[0];\n\n\t\t\tif (!update_read_2byte_signed(s, &glyph->x) ||\n\t\t\t    !update_read_2byte_signed(s, &glyph->y) ||\n\t\t\t    !update_read_2byte_unsigned(s, &glyph->cx) ||\n\t\t\t    !update_read_2byte_unsigned(s, &glyph->cy))\n\t\t\t\treturn FALSE;\n\n\t\t\tglyph->cb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\t\tglyph->cb += ((glyph->cb % 4) > 0) ? 4 - (glyph->cb % 4) : 0;\n\t\t\tnew_cb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\t\tnew_cb += ((new_cb % 4) > 0) ? 4 - (new_cb % 4) : 0;\n\n\t\t\tif (fastGlyph->cbData < new_cb)\n\t\t\t\treturn FALSE;\n\n\t\t\tif (new_cb > 0)\n\t\t\t{\n\t\t\t\tBYTE* new_aj;\n\t\t\t\tnew_aj = (BYTE*)realloc(glyph->aj, new_cb);\n\n\t\t\t\tif (!new_aj)\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tglyph->aj = new_aj;\n\t\t\t\tglyph->cb = new_cb;\n\t\t\t\tStream_Read(s, glyph->aj, glyph->cb);\n\t\t\t}\n\t\t\tStream_Seek(s, fastGlyph->cbData - new_cb);\n\t\t}\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_polygon_sc_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         POLYGON_SC_ORDER* polygon_sc)\n{\n\tUINT32 num = polygon_sc->numPoints;\n\tORDER_FIELD_COORD(1, polygon_sc->xStart);\n\tORDER_FIELD_COORD(2, polygon_sc->yStart);\n\tORDER_FIELD_BYTE(3, polygon_sc->bRop2);\n\tORDER_FIELD_BYTE(4, polygon_sc->fillMode);\n\tORDER_FIELD_COLOR(orderInfo, s, 5, &polygon_sc->brushColor);\n\tORDER_FIELD_BYTE(6, num);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tDELTA_POINT* newpoints;\n\n\t\tif (num == 0)\n\t\t\treturn FALSE;\n\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, polygon_sc->cbData);\n\t\tnewpoints = (DELTA_POINT*)realloc(polygon_sc->points, sizeof(DELTA_POINT) * num);\n\n\t\tif (!newpoints)\n\t\t\treturn FALSE;\n\n\t\tpolygon_sc->points = newpoints;\n\t\tpolygon_sc->numPoints = num;\n\t\treturn update_read_delta_points(s, polygon_sc->points, polygon_sc->numPoints,\n\t\t                                polygon_sc->xStart, polygon_sc->yStart);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_polygon_cb_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         POLYGON_CB_ORDER* polygon_cb)\n{\n\tUINT32 num = polygon_cb->numPoints;\n\tORDER_FIELD_COORD(1, polygon_cb->xStart);\n\tORDER_FIELD_COORD(2, polygon_cb->yStart);\n\tORDER_FIELD_BYTE(3, polygon_cb->bRop2);\n\tORDER_FIELD_BYTE(4, polygon_cb->fillMode);\n\tORDER_FIELD_COLOR(orderInfo, s, 5, &polygon_cb->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 6, &polygon_cb->foreColor);\n\n\tif (!update_read_brush(s, &polygon_cb->brush, orderInfo->fieldFlags >> 6))\n\t\treturn FALSE;\n\n\tORDER_FIELD_BYTE(12, num);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_13)\n\t{\n\t\tDELTA_POINT* newpoints;\n\n\t\tif (num == 0)\n\t\t\treturn FALSE;\n\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, polygon_cb->cbData);\n\t\tnewpoints = (DELTA_POINT*)realloc(polygon_cb->points, sizeof(DELTA_POINT) * num);\n\n\t\tif (!newpoints)\n\t\t\treturn FALSE;\n\n\t\tpolygon_cb->points = newpoints;\n\t\tpolygon_cb->numPoints = num;\n\n\t\tif (!update_read_delta_points(s, polygon_cb->points, polygon_cb->numPoints,\n\t\t                              polygon_cb->xStart, polygon_cb->yStart))\n\t\t\treturn FALSE;\n\t}\n\n\tpolygon_cb->backMode = (polygon_cb->bRop2 & 0x80) ? BACKMODE_TRANSPARENT : BACKMODE_OPAQUE;\n\tpolygon_cb->bRop2 = (polygon_cb->bRop2 & 0x1F);\n\treturn TRUE;\n}\nstatic BOOL update_read_ellipse_sc_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         ELLIPSE_SC_ORDER* ellipse_sc)\n{\n\tORDER_FIELD_COORD(1, ellipse_sc->leftRect);\n\tORDER_FIELD_COORD(2, ellipse_sc->topRect);\n\tORDER_FIELD_COORD(3, ellipse_sc->rightRect);\n\tORDER_FIELD_COORD(4, ellipse_sc->bottomRect);\n\tORDER_FIELD_BYTE(5, ellipse_sc->bRop2);\n\tORDER_FIELD_BYTE(6, ellipse_sc->fillMode);\n\tORDER_FIELD_COLOR(orderInfo, s, 7, &ellipse_sc->color);\n\treturn TRUE;\n}\nstatic BOOL update_read_ellipse_cb_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         ELLIPSE_CB_ORDER* ellipse_cb)\n{\n\tORDER_FIELD_COORD(1, ellipse_cb->leftRect);\n\tORDER_FIELD_COORD(2, ellipse_cb->topRect);\n\tORDER_FIELD_COORD(3, ellipse_cb->rightRect);\n\tORDER_FIELD_COORD(4, ellipse_cb->bottomRect);\n\tORDER_FIELD_BYTE(5, ellipse_cb->bRop2);\n\tORDER_FIELD_BYTE(6, ellipse_cb->fillMode);\n\tORDER_FIELD_COLOR(orderInfo, s, 7, &ellipse_cb->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 8, &ellipse_cb->foreColor);\n\treturn update_read_brush(s, &ellipse_cb->brush, orderInfo->fieldFlags >> 8);\n}\n/* Secondary Drawing Orders */\nstatic CACHE_BITMAP_ORDER* update_read_cache_bitmap_order(rdpUpdate* update, wStream* s,\n                                                          BOOL compressed, UINT16 flags)\n{\n\tCACHE_BITMAP_ORDER* cache_bitmap;\n\n\tif (!update || !s)\n\t\treturn NULL;\n\n\tcache_bitmap = calloc(1, sizeof(CACHE_BITMAP_ORDER));\n\n\tif (!cache_bitmap)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 9)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_bitmap->cacheId);      /* cacheId (1 byte) */\n\tStream_Seek_UINT8(s);                             /* pad1Octet (1 byte) */\n\tStream_Read_UINT8(s, cache_bitmap->bitmapWidth);  /* bitmapWidth (1 byte) */\n\tStream_Read_UINT8(s, cache_bitmap->bitmapHeight); /* bitmapHeight (1 byte) */\n\tStream_Read_UINT8(s, cache_bitmap->bitmapBpp);    /* bitmapBpp (1 byte) */\n\n\tif ((cache_bitmap->bitmapBpp < 1) || (cache_bitmap->bitmapBpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bitmap bpp %\" PRIu32 \"\",\n\t\t           cache_bitmap->bitmapBpp);\n\t\tgoto fail;\n\t}\n\n\tStream_Read_UINT16(s, cache_bitmap->bitmapLength); /* bitmapLength (2 bytes) */\n\tStream_Read_UINT16(s, cache_bitmap->cacheIndex);   /* cacheIndex (2 bytes) */\n\n\tif (compressed)\n\t{\n\t\tif ((flags & NO_BITMAP_COMPRESSION_HDR) == 0)\n\t\t{\n\t\t\tBYTE* bitmapComprHdr = (BYTE*)&(cache_bitmap->bitmapComprHdr);\n\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\tgoto fail;\n\n\t\t\tStream_Read(s, bitmapComprHdr, 8); /* bitmapComprHdr (8 bytes) */\n\t\t\tcache_bitmap->bitmapLength -= 8;\n\t\t}\n\t}\n\n\tif (cache_bitmap->bitmapLength == 0)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < cache_bitmap->bitmapLength)\n\t\tgoto fail;\n\n\tcache_bitmap->bitmapDataStream = malloc(cache_bitmap->bitmapLength);\n\n\tif (!cache_bitmap->bitmapDataStream)\n\t\tgoto fail;\n\n\tStream_Read(s, cache_bitmap->bitmapDataStream, cache_bitmap->bitmapLength);\n\tcache_bitmap->compressed = compressed;\n\treturn cache_bitmap;\nfail:\n\tfree_cache_bitmap_order(update->context, cache_bitmap);\n\treturn NULL;\n}\nint update_approximate_cache_bitmap_order(const CACHE_BITMAP_ORDER* cache_bitmap, BOOL compressed,\n                                          UINT16* flags)\n{\n\treturn 64 + cache_bitmap->bitmapLength;\n}\nBOOL update_write_cache_bitmap_order(wStream* s, const CACHE_BITMAP_ORDER* cache_bitmap,\n                                     BOOL compressed, UINT16* flags)\n{\n\tUINT32 bitmapLength = cache_bitmap->bitmapLength;\n\tint inf = update_approximate_cache_bitmap_order(cache_bitmap, compressed, flags);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\t*flags = NO_BITMAP_COMPRESSION_HDR;\n\n\tif ((*flags & NO_BITMAP_COMPRESSION_HDR) == 0)\n\t\tbitmapLength += 8;\n\n\tStream_Write_UINT8(s, cache_bitmap->cacheId);      /* cacheId (1 byte) */\n\tStream_Write_UINT8(s, 0);                          /* pad1Octet (1 byte) */\n\tStream_Write_UINT8(s, cache_bitmap->bitmapWidth);  /* bitmapWidth (1 byte) */\n\tStream_Write_UINT8(s, cache_bitmap->bitmapHeight); /* bitmapHeight (1 byte) */\n\tStream_Write_UINT8(s, cache_bitmap->bitmapBpp);    /* bitmapBpp (1 byte) */\n\tStream_Write_UINT16(s, bitmapLength);              /* bitmapLength (2 bytes) */\n\tStream_Write_UINT16(s, cache_bitmap->cacheIndex);  /* cacheIndex (2 bytes) */\n\n\tif (compressed)\n\t{\n\t\tif ((*flags & NO_BITMAP_COMPRESSION_HDR) == 0)\n\t\t{\n\t\t\tBYTE* bitmapComprHdr = (BYTE*)&(cache_bitmap->bitmapComprHdr);\n\t\t\tStream_Write(s, bitmapComprHdr, 8); /* bitmapComprHdr (8 bytes) */\n\t\t\tbitmapLength -= 8;\n\t\t}\n\n\t\tStream_Write(s, cache_bitmap->bitmapDataStream, bitmapLength);\n\t}\n\telse\n\t{\n\t\tStream_Write(s, cache_bitmap->bitmapDataStream, bitmapLength);\n\t}\n\n\treturn TRUE;\n}\nstatic CACHE_BITMAP_V2_ORDER* update_read_cache_bitmap_v2_order(rdpUpdate* update, wStream* s,\n                                                                BOOL compressed, UINT16 flags)\n{\n\tBYTE bitsPerPixelId;\n\tCACHE_BITMAP_V2_ORDER* cache_bitmap_v2;\n\n\tif (!update || !s)\n\t\treturn NULL;\n\n\tcache_bitmap_v2 = calloc(1, sizeof(CACHE_BITMAP_V2_ORDER));\n\n\tif (!cache_bitmap_v2)\n\t\tgoto fail;\n\n\tcache_bitmap_v2->cacheId = flags & 0x0003;\n\tcache_bitmap_v2->flags = (flags & 0xFF80) >> 7;\n\tbitsPerPixelId = (flags & 0x0078) >> 3;\n\tcache_bitmap_v2->bitmapBpp = CBR2_BPP[bitsPerPixelId];\n\n\tif (cache_bitmap_v2->flags & CBR2_PERSISTENT_KEY_PRESENT)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UINT32(s, cache_bitmap_v2->key1); /* key1 (4 bytes) */\n\t\tStream_Read_UINT32(s, cache_bitmap_v2->key2); /* key2 (4 bytes) */\n\t}\n\n\tif (cache_bitmap_v2->flags & CBR2_HEIGHT_SAME_AS_WIDTH)\n\t{\n\t\tif (!update_read_2byte_unsigned(s, &cache_bitmap_v2->bitmapWidth)) /* bitmapWidth */\n\t\t\tgoto fail;\n\n\t\tcache_bitmap_v2->bitmapHeight = cache_bitmap_v2->bitmapWidth;\n\t}\n\telse\n\t{\n\t\tif (!update_read_2byte_unsigned(s, &cache_bitmap_v2->bitmapWidth) || /* bitmapWidth */\n\t\t    !update_read_2byte_unsigned(s, &cache_bitmap_v2->bitmapHeight))  /* bitmapHeight */\n\t\t\tgoto fail;\n\t}\n\n\tif (!update_read_4byte_unsigned(s, &cache_bitmap_v2->bitmapLength) || /* bitmapLength */\n\t    !update_read_2byte_unsigned(s, &cache_bitmap_v2->cacheIndex))     /* cacheIndex */\n\t\tgoto fail;\n\n\tif (cache_bitmap_v2->flags & CBR2_DO_NOT_CACHE)\n\t\tcache_bitmap_v2->cacheIndex = BITMAP_CACHE_WAITING_LIST_INDEX;\n\n\tif (compressed)\n\t{\n\t\tif (!(cache_bitmap_v2->flags & CBR2_NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\tgoto fail;\n\n\t\t\tStream_Read_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Read_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompMainBodySize);         /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Read_UINT16(s, cache_bitmap_v2->cbScanWidth); /* cbScanWidth (2 bytes) */\n\t\t\tStream_Read_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t\tcache_bitmap_v2->bitmapLength = cache_bitmap_v2->cbCompMainBodySize;\n\t\t}\n\t}\n\n\tif (cache_bitmap_v2->bitmapLength == 0)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < cache_bitmap_v2->bitmapLength)\n\t\tgoto fail;\n\n\tif (cache_bitmap_v2->bitmapLength == 0)\n\t\tgoto fail;\n\n\tcache_bitmap_v2->bitmapDataStream = malloc(cache_bitmap_v2->bitmapLength);\n\n\tif (!cache_bitmap_v2->bitmapDataStream)\n\t\tgoto fail;\n\n\tStream_Read(s, cache_bitmap_v2->bitmapDataStream, cache_bitmap_v2->bitmapLength);\n\tcache_bitmap_v2->compressed = compressed;\n\treturn cache_bitmap_v2;\nfail:\n\tfree_cache_bitmap_v2_order(update->context, cache_bitmap_v2);\n\treturn NULL;\n}\nint update_approximate_cache_bitmap_v2_order(CACHE_BITMAP_V2_ORDER* cache_bitmap_v2,\n                                             BOOL compressed, UINT16* flags)\n{\n\treturn 64 + cache_bitmap_v2->bitmapLength;\n}\nBOOL update_write_cache_bitmap_v2_order(wStream* s, CACHE_BITMAP_V2_ORDER* cache_bitmap_v2,\n                                        BOOL compressed, UINT16* flags)\n{\n\tBYTE bitsPerPixelId;\n\n\tif (!Stream_EnsureRemainingCapacity(\n\t        s, update_approximate_cache_bitmap_v2_order(cache_bitmap_v2, compressed, flags)))\n\t\treturn FALSE;\n\n\tbitsPerPixelId = BPP_CBR2[cache_bitmap_v2->bitmapBpp];\n\t*flags = (cache_bitmap_v2->cacheId & 0x0003) | (bitsPerPixelId << 3) |\n\t         ((cache_bitmap_v2->flags << 7) & 0xFF80);\n\n\tif (cache_bitmap_v2->flags & CBR2_PERSISTENT_KEY_PRESENT)\n\t{\n\t\tStream_Write_UINT32(s, cache_bitmap_v2->key1); /* key1 (4 bytes) */\n\t\tStream_Write_UINT32(s, cache_bitmap_v2->key2); /* key2 (4 bytes) */\n\t}\n\n\tif (cache_bitmap_v2->flags & CBR2_HEIGHT_SAME_AS_WIDTH)\n\t{\n\t\tif (!update_write_2byte_unsigned(s, cache_bitmap_v2->bitmapWidth)) /* bitmapWidth */\n\t\t\treturn FALSE;\n\t}\n\telse\n\t{\n\t\tif (!update_write_2byte_unsigned(s, cache_bitmap_v2->bitmapWidth) || /* bitmapWidth */\n\t\t    !update_write_2byte_unsigned(s, cache_bitmap_v2->bitmapHeight))  /* bitmapHeight */\n\t\t\treturn FALSE;\n\t}\n\n\tif (cache_bitmap_v2->flags & CBR2_DO_NOT_CACHE)\n\t\tcache_bitmap_v2->cacheIndex = BITMAP_CACHE_WAITING_LIST_INDEX;\n\n\tif (!update_write_4byte_unsigned(s, cache_bitmap_v2->bitmapLength) || /* bitmapLength */\n\t    !update_write_2byte_unsigned(s, cache_bitmap_v2->cacheIndex))     /* cacheIndex */\n\t\treturn FALSE;\n\n\tif (compressed)\n\t{\n\t\tif (!(cache_bitmap_v2->flags & CBR2_NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tStream_Write_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Write_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompMainBodySize);          /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Write_UINT16(s, cache_bitmap_v2->cbScanWidth); /* cbScanWidth (2 bytes) */\n\t\t\tStream_Write_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t\tcache_bitmap_v2->bitmapLength = cache_bitmap_v2->cbCompMainBodySize;\n\t\t}\n\n\t\tif (!Stream_EnsureRemainingCapacity(s, cache_bitmap_v2->bitmapLength))\n\t\t\treturn FALSE;\n\n\t\tStream_Write(s, cache_bitmap_v2->bitmapDataStream, cache_bitmap_v2->bitmapLength);\n\t}\n\telse\n\t{\n\t\tif (!Stream_EnsureRemainingCapacity(s, cache_bitmap_v2->bitmapLength))\n\t\t\treturn FALSE;\n\n\t\tStream_Write(s, cache_bitmap_v2->bitmapDataStream, cache_bitmap_v2->bitmapLength);\n\t}\n\n\tcache_bitmap_v2->compressed = compressed;\n\treturn TRUE;\n}\nstatic CACHE_BITMAP_V3_ORDER* update_read_cache_bitmap_v3_order(rdpUpdate* update, wStream* s,\n                                                                UINT16 flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tUINT32 new_len;\n\tBYTE* new_data;\n\tCACHE_BITMAP_V3_ORDER* cache_bitmap_v3;\n\n\tif (!update || !s)\n\t\treturn NULL;\n\n\tcache_bitmap_v3 = calloc(1, sizeof(CACHE_BITMAP_V3_ORDER));\n\n\tif (!cache_bitmap_v3)\n\t\tgoto fail;\n\n\tcache_bitmap_v3->cacheId = flags & 0x00000003;\n\tcache_bitmap_v3->flags = (flags & 0x0000FF80) >> 7;\n\tbitsPerPixelId = (flags & 0x00000078) >> 3;\n\tcache_bitmap_v3->bpp = CBR23_BPP[bitsPerPixelId];\n\n\tif (Stream_GetRemainingLength(s) < 21)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, cache_bitmap_v3->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Read_UINT32(s, cache_bitmap_v3->key1);       /* key1 (4 bytes) */\n\tStream_Read_UINT32(s, cache_bitmap_v3->key2);       /* key2 (4 bytes) */\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tStream_Read_UINT8(s, bitmapData->bpp);\n\n\tif ((bitmapData->bpp < 1) || (bitmapData->bpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bpp value %\" PRIu32 \"\", bitmapData->bpp);\n\t\tgoto fail;\n\t}\n\n\tStream_Seek_UINT8(s);                      /* reserved1 (1 byte) */\n\tStream_Seek_UINT8(s);                      /* reserved2 (1 byte) */\n\tStream_Read_UINT8(s, bitmapData->codecID); /* codecID (1 byte) */\n\tStream_Read_UINT16(s, bitmapData->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, bitmapData->height); /* height (2 bytes) */\n\tStream_Read_UINT32(s, new_len);            /* length (4 bytes) */\n\n\tif ((new_len == 0) || (Stream_GetRemainingLength(s) < new_len))\n\t\tgoto fail;\n\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\n\tif (!new_data)\n\t\tgoto fail;\n\n\tbitmapData->data = new_data;\n\tbitmapData->length = new_len;\n\tStream_Read(s, bitmapData->data, bitmapData->length);\n\treturn cache_bitmap_v3;\nfail:\n\tfree_cache_bitmap_v3_order(update->context, cache_bitmap_v3);\n\treturn NULL;\n}\nint update_approximate_cache_bitmap_v3_order(CACHE_BITMAP_V3_ORDER* cache_bitmap_v3, UINT16* flags)\n{\n\tBITMAP_DATA_EX* bitmapData = &cache_bitmap_v3->bitmapData;\n\treturn 64 + bitmapData->length;\n}\nBOOL update_write_cache_bitmap_v3_order(wStream* s, CACHE_BITMAP_V3_ORDER* cache_bitmap_v3,\n                                        UINT16* flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\n\tif (!Stream_EnsureRemainingCapacity(\n\t        s, update_approximate_cache_bitmap_v3_order(cache_bitmap_v3, flags)))\n\t\treturn FALSE;\n\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tbitsPerPixelId = BPP_CBR23[cache_bitmap_v3->bpp];\n\t*flags = (cache_bitmap_v3->cacheId & 0x00000003) |\n\t         ((cache_bitmap_v3->flags << 7) & 0x0000FF80) | ((bitsPerPixelId << 3) & 0x00000078);\n\tStream_Write_UINT16(s, cache_bitmap_v3->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Write_UINT32(s, cache_bitmap_v3->key1);       /* key1 (4 bytes) */\n\tStream_Write_UINT32(s, cache_bitmap_v3->key2);       /* key2 (4 bytes) */\n\tStream_Write_UINT8(s, bitmapData->bpp);\n\tStream_Write_UINT8(s, 0);                   /* reserved1 (1 byte) */\n\tStream_Write_UINT8(s, 0);                   /* reserved2 (1 byte) */\n\tStream_Write_UINT8(s, bitmapData->codecID); /* codecID (1 byte) */\n\tStream_Write_UINT16(s, bitmapData->width);  /* width (2 bytes) */\n\tStream_Write_UINT16(s, bitmapData->height); /* height (2 bytes) */\n\tStream_Write_UINT32(s, bitmapData->length); /* length (4 bytes) */\n\tStream_Write(s, bitmapData->data, bitmapData->length);\n\treturn TRUE;\n}\nstatic CACHE_COLOR_TABLE_ORDER* update_read_cache_color_table_order(rdpUpdate* update, wStream* s,\n                                                                    UINT16 flags)\n{\n\tint i;\n\tUINT32* colorTable;\n\tCACHE_COLOR_TABLE_ORDER* cache_color_table = calloc(1, sizeof(CACHE_COLOR_TABLE_ORDER));\n\n\tif (!cache_color_table)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 3)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_color_table->cacheIndex);    /* cacheIndex (1 byte) */\n\tStream_Read_UINT16(s, cache_color_table->numberColors); /* numberColors (2 bytes) */\n\n\tif (cache_color_table->numberColors != 256)\n\t{\n\t\t/* This field MUST be set to 256 */\n\t\tgoto fail;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < cache_color_table->numberColors * 4)\n\t\tgoto fail;\n\n\tcolorTable = (UINT32*)&cache_color_table->colorTable;\n\n\tfor (i = 0; i < (int)cache_color_table->numberColors; i++)\n\t\tupdate_read_color_quad(s, &colorTable[i]);\n\n\treturn cache_color_table;\nfail:\n\tfree_cache_color_table_order(update->context, cache_color_table);\n\treturn NULL;\n}\nint update_approximate_cache_color_table_order(const CACHE_COLOR_TABLE_ORDER* cache_color_table,\n                                               UINT16* flags)\n{\n\treturn 16 + (256 * 4);\n}\nBOOL update_write_cache_color_table_order(wStream* s,\n                                          const CACHE_COLOR_TABLE_ORDER* cache_color_table,\n                                          UINT16* flags)\n{\n\tint i, inf;\n\tUINT32* colorTable;\n\n\tif (cache_color_table->numberColors != 256)\n\t\treturn FALSE;\n\n\tinf = update_approximate_cache_color_table_order(cache_color_table, flags);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\tStream_Write_UINT8(s, cache_color_table->cacheIndex);    /* cacheIndex (1 byte) */\n\tStream_Write_UINT16(s, cache_color_table->numberColors); /* numberColors (2 bytes) */\n\tcolorTable = (UINT32*)&cache_color_table->colorTable;\n\n\tfor (i = 0; i < (int)cache_color_table->numberColors; i++)\n\t{\n\t\tupdate_write_color_quad(s, colorTable[i]);\n\t}\n\n\treturn TRUE;\n}\nstatic CACHE_GLYPH_ORDER* update_read_cache_glyph_order(rdpUpdate* update, wStream* s, UINT16 flags)\n{\n\tUINT32 i;\n\tCACHE_GLYPH_ORDER* cache_glyph_order = calloc(1, sizeof(CACHE_GLYPH_ORDER));\n\n\tif (!cache_glyph_order || !update || !s)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_glyph_order->cacheId); /* cacheId (1 byte) */\n\tStream_Read_UINT8(s, cache_glyph_order->cGlyphs); /* cGlyphs (1 byte) */\n\n\tfor (i = 0; i < cache_glyph_order->cGlyphs; i++)\n\t{\n\t\tGLYPH_DATA* glyph = &cache_glyph_order->glyphData[i];\n\n\t\tif (Stream_GetRemainingLength(s) < 10)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UINT16(s, glyph->cacheIndex);\n\t\tStream_Read_INT16(s, glyph->x);\n\t\tStream_Read_INT16(s, glyph->y);\n\t\tStream_Read_UINT16(s, glyph->cx);\n\t\tStream_Read_UINT16(s, glyph->cy);\n\t\tglyph->cb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\tglyph->cb += ((glyph->cb % 4) > 0) ? 4 - (glyph->cb % 4) : 0;\n\n\t\tif (Stream_GetRemainingLength(s) < glyph->cb)\n\t\t\tgoto fail;\n\n\t\tglyph->aj = (BYTE*)malloc(glyph->cb);\n\n\t\tif (!glyph->aj)\n\t\t\tgoto fail;\n\n\t\tStream_Read(s, glyph->aj, glyph->cb);\n\t}\n\n\tif ((flags & CG_GLYPH_UNICODE_PRESENT) && (cache_glyph_order->cGlyphs > 0))\n\t{\n\t\tcache_glyph_order->unicodeCharacters = calloc(cache_glyph_order->cGlyphs, sizeof(WCHAR));\n\n\t\tif (!cache_glyph_order->unicodeCharacters)\n\t\t\tgoto fail;\n\n\t\tif (Stream_GetRemainingLength(s) < sizeof(WCHAR) * cache_glyph_order->cGlyphs)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UTF16_String(s, cache_glyph_order->unicodeCharacters,\n\t\t                         cache_glyph_order->cGlyphs);\n\t}\n\n\treturn cache_glyph_order;\nfail:\n\tfree_cache_glyph_order(update->context, cache_glyph_order);\n\treturn NULL;\n}\nint update_approximate_cache_glyph_order(const CACHE_GLYPH_ORDER* cache_glyph, UINT16* flags)\n{\n\treturn 2 + cache_glyph->cGlyphs * 32;\n}\nBOOL update_write_cache_glyph_order(wStream* s, const CACHE_GLYPH_ORDER* cache_glyph, UINT16* flags)\n{\n\tint i, inf;\n\tINT16 lsi16;\n\tconst GLYPH_DATA* glyph;\n\tinf = update_approximate_cache_glyph_order(cache_glyph, flags);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\tStream_Write_UINT8(s, cache_glyph->cacheId); /* cacheId (1 byte) */\n\tStream_Write_UINT8(s, cache_glyph->cGlyphs); /* cGlyphs (1 byte) */\n\n\tfor (i = 0; i < (int)cache_glyph->cGlyphs; i++)\n\t{\n\t\tUINT32 cb;\n\t\tglyph = &cache_glyph->glyphData[i];\n\t\tStream_Write_UINT16(s, glyph->cacheIndex); /* cacheIndex (2 bytes) */\n\t\tlsi16 = glyph->x;\n\t\tStream_Write_UINT16(s, lsi16); /* x (2 bytes) */\n\t\tlsi16 = glyph->y;\n\t\tStream_Write_UINT16(s, lsi16);     /* y (2 bytes) */\n\t\tStream_Write_UINT16(s, glyph->cx); /* cx (2 bytes) */\n\t\tStream_Write_UINT16(s, glyph->cy); /* cy (2 bytes) */\n\t\tcb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\tcb += ((cb % 4) > 0) ? 4 - (cb % 4) : 0;\n\t\tStream_Write(s, glyph->aj, cb);\n\t}\n\n\tif (*flags & CG_GLYPH_UNICODE_PRESENT)\n\t{\n\t\tStream_Zero(s, cache_glyph->cGlyphs * 2);\n\t}\n\n\treturn TRUE;\n}\nstatic CACHE_GLYPH_V2_ORDER* update_read_cache_glyph_v2_order(rdpUpdate* update, wStream* s,\n                                                              UINT16 flags)\n{\n\tUINT32 i;\n\tCACHE_GLYPH_V2_ORDER* cache_glyph_v2 = calloc(1, sizeof(CACHE_GLYPH_V2_ORDER));\n\n\tif (!cache_glyph_v2)\n\t\tgoto fail;\n\n\tcache_glyph_v2->cacheId = (flags & 0x000F);\n\tcache_glyph_v2->flags = (flags & 0x00F0) >> 4;\n\tcache_glyph_v2->cGlyphs = (flags & 0xFF00) >> 8;\n\n\tfor (i = 0; i < cache_glyph_v2->cGlyphs; i++)\n\t{\n\t\tGLYPH_DATA_V2* glyph = &cache_glyph_v2->glyphData[i];\n\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UINT8(s, glyph->cacheIndex);\n\n\t\tif (!update_read_2byte_signed(s, &glyph->x) || !update_read_2byte_signed(s, &glyph->y) ||\n\t\t    !update_read_2byte_unsigned(s, &glyph->cx) ||\n\t\t    !update_read_2byte_unsigned(s, &glyph->cy))\n\t\t{\n\t\t\tgoto fail;\n\t\t}\n\n\t\tglyph->cb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\tglyph->cb += ((glyph->cb % 4) > 0) ? 4 - (glyph->cb % 4) : 0;\n\n\t\tif (Stream_GetRemainingLength(s) < glyph->cb)\n\t\t\tgoto fail;\n\n\t\tglyph->aj = (BYTE*)malloc(glyph->cb);\n\n\t\tif (!glyph->aj)\n\t\t\tgoto fail;\n\n\t\tStream_Read(s, glyph->aj, glyph->cb);\n\t}\n\n\tif ((flags & CG_GLYPH_UNICODE_PRESENT) && (cache_glyph_v2->cGlyphs > 0))\n\t{\n\t\tcache_glyph_v2->unicodeCharacters = calloc(cache_glyph_v2->cGlyphs, sizeof(WCHAR));\n\n\t\tif (!cache_glyph_v2->unicodeCharacters)\n\t\t\tgoto fail;\n\n\t\tif (Stream_GetRemainingLength(s) < sizeof(WCHAR) * cache_glyph_v2->cGlyphs)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UTF16_String(s, cache_glyph_v2->unicodeCharacters, cache_glyph_v2->cGlyphs);\n\t}\n\n\treturn cache_glyph_v2;\nfail:\n\tfree_cache_glyph_v2_order(update->context, cache_glyph_v2);\n\treturn NULL;\n}\nint update_approximate_cache_glyph_v2_order(const CACHE_GLYPH_V2_ORDER* cache_glyph_v2,\n                                            UINT16* flags)\n{\n\treturn 8 + cache_glyph_v2->cGlyphs * 32;\n}\nBOOL update_write_cache_glyph_v2_order(wStream* s, const CACHE_GLYPH_V2_ORDER* cache_glyph_v2,\n                                       UINT16* flags)\n{\n\tUINT32 i, inf;\n\tinf = update_approximate_cache_glyph_v2_order(cache_glyph_v2, flags);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\t*flags = (cache_glyph_v2->cacheId & 0x000F) | ((cache_glyph_v2->flags & 0x000F) << 4) |\n\t         ((cache_glyph_v2->cGlyphs & 0x00FF) << 8);\n\n\tfor (i = 0; i < cache_glyph_v2->cGlyphs; i++)\n\t{\n\t\tUINT32 cb;\n\t\tconst GLYPH_DATA_V2* glyph = &cache_glyph_v2->glyphData[i];\n\t\tStream_Write_UINT8(s, glyph->cacheIndex);\n\n\t\tif (!update_write_2byte_signed(s, glyph->x) || !update_write_2byte_signed(s, glyph->y) ||\n\t\t    !update_write_2byte_unsigned(s, glyph->cx) ||\n\t\t    !update_write_2byte_unsigned(s, glyph->cy))\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tcb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\tcb += ((cb % 4) > 0) ? 4 - (cb % 4) : 0;\n\t\tStream_Write(s, glyph->aj, cb);\n\t}\n\n\tif (*flags & CG_GLYPH_UNICODE_PRESENT)\n\t{\n\t\tStream_Zero(s, cache_glyph_v2->cGlyphs * 2);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_decompress_brush(wStream* s, BYTE* output, size_t outSize, BYTE bpp)\n{\n\tINT32 x, y, k;\n\tBYTE byte = 0;\n\tconst BYTE* palette = Stream_Pointer(s) + 16;\n\tconst INT32 bytesPerPixel = ((bpp + 1) / 8);\n\n\tif (!Stream_SafeSeek(s, 16ULL + 7ULL * bytesPerPixel)) // 64 / 4\n\t\treturn FALSE;\n\n\tfor (y = 7; y >= 0; y--)\n\t{\n\t\tfor (x = 0; x < 8; x++)\n\t\t{\n\t\t\tUINT32 index;\n\t\t\tif ((x % 4) == 0)\n\t\t\t\tStream_Read_UINT8(s, byte);\n\n\t\t\tindex = ((byte >> ((3 - (x % 4)) * 2)) & 0x03);\n\n\t\t\tfor (k = 0; k < bytesPerPixel; k++)\n\t\t\t{\n\t\t\t\tconst size_t dstIndex = ((y * 8 + x) * bytesPerPixel) + k;\n\t\t\t\tconst size_t srcIndex = (index * bytesPerPixel) + k;\n\t\t\t\tif (dstIndex >= outSize)\n\t\t\t\t\treturn FALSE;\n\t\t\t\toutput[dstIndex] = palette[srcIndex];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_compress_brush(wStream* s, const BYTE* input, BYTE bpp)\n{\n\treturn FALSE;\n}\nstatic CACHE_BRUSH_ORDER* update_read_cache_brush_order(rdpUpdate* update, wStream* s, UINT16 flags)\n{\n\tint i;\n\tBYTE iBitmapFormat;\n\tBOOL compressed = FALSE;\n\tCACHE_BRUSH_ORDER* cache_brush = calloc(1, sizeof(CACHE_BRUSH_ORDER));\n\n\tif (!cache_brush)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_brush->index); /* cacheEntry (1 byte) */\n\tStream_Read_UINT8(s, iBitmapFormat);      /* iBitmapFormat (1 byte) */\n\n\tif (iBitmapFormat >= ARRAYSIZE(BMF_BPP))\n\t\tgoto fail;\n\n\tcache_brush->bpp = BMF_BPP[iBitmapFormat];\n\tStream_Read_UINT8(s, cache_brush->cx);     /* cx (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->cy);     /* cy (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->style);  /* style (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->length); /* iBytes (1 byte) */\n\n\tif ((cache_brush->cx == 8) && (cache_brush->cy == 8))\n\t{\n\t\tif (cache_brush->bpp == 1)\n\t\t{\n\t\t\tif (cache_brush->length != 8)\n\t\t\t{\n\t\t\t\tWLog_Print(update->log, WLOG_ERROR, \"incompatible 1bpp brush of length:%\" PRIu32 \"\",\n\t\t\t\t           cache_brush->length);\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\t/* rows are encoded in reverse order */\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\tgoto fail;\n\n\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t{\n\t\t\t\tStream_Read_UINT8(s, cache_brush->data[i]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((iBitmapFormat == BMF_8BPP) && (cache_brush->length == 20))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_16BPP) && (cache_brush->length == 24))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_32BPP) && (cache_brush->length == 32))\n\t\t\t\tcompressed = TRUE;\n\n\t\t\tif (compressed != FALSE)\n\t\t\t{\n\t\t\t\t/* compressed brush */\n\t\t\t\tif (!update_decompress_brush(s, cache_brush->data, sizeof(cache_brush->data),\n\t\t\t\t                             cache_brush->bpp))\n\t\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* uncompressed brush */\n\t\t\t\tUINT32 scanline = (cache_brush->bpp / 8) * 8;\n\n\t\t\t\tif (Stream_GetRemainingLength(s) < scanline * 8)\n\t\t\t\t\tgoto fail;\n\n\t\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\tStream_Read(s, &cache_brush->data[i * scanline], scanline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cache_brush;\nfail:\n\tfree_cache_brush_order(update->context, cache_brush);\n\treturn NULL;\n}\nint update_approximate_cache_brush_order(const CACHE_BRUSH_ORDER* cache_brush, UINT16* flags)\n{\n\treturn 64;\n}\nBOOL update_write_cache_brush_order(wStream* s, const CACHE_BRUSH_ORDER* cache_brush, UINT16* flags)\n{\n\tint i;\n\tBYTE iBitmapFormat;\n\tBOOL compressed = FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s,\n\t                                    update_approximate_cache_brush_order(cache_brush, flags)))\n\t\treturn FALSE;\n\n\tiBitmapFormat = BPP_BMF[cache_brush->bpp];\n\tStream_Write_UINT8(s, cache_brush->index);  /* cacheEntry (1 byte) */\n\tStream_Write_UINT8(s, iBitmapFormat);       /* iBitmapFormat (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->cx);     /* cx (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->cy);     /* cy (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->style);  /* style (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->length); /* iBytes (1 byte) */\n\n\tif ((cache_brush->cx == 8) && (cache_brush->cy == 8))\n\t{\n\t\tif (cache_brush->bpp == 1)\n\t\t{\n\t\t\tif (cache_brush->length != 8)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"incompatible 1bpp brush of length:%\" PRIu32 \"\", cache_brush->length);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t{\n\t\t\t\tStream_Write_UINT8(s, cache_brush->data[i]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((iBitmapFormat == BMF_8BPP) && (cache_brush->length == 20))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_16BPP) && (cache_brush->length == 24))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_32BPP) && (cache_brush->length == 32))\n\t\t\t\tcompressed = TRUE;\n\n\t\t\tif (compressed != FALSE)\n\t\t\t{\n\t\t\t\t/* compressed brush */\n\t\t\t\tif (!update_compress_brush(s, cache_brush->data, cache_brush->bpp))\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* uncompressed brush */\n\t\t\t\tint scanline = (cache_brush->bpp / 8) * 8;\n\n\t\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\tStream_Write(s, &cache_brush->data[i * scanline], scanline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n/* Alternate Secondary Drawing Orders */\nstatic BOOL\nupdate_read_create_offscreen_bitmap_order(wStream* s,\n                                          CREATE_OFFSCREEN_BITMAP_ORDER* create_offscreen_bitmap)\n{\n\tUINT16 flags;\n\tBOOL deleteListPresent;\n\tOFFSCREEN_DELETE_LIST* deleteList;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, flags); /* flags (2 bytes) */\n\tcreate_offscreen_bitmap->id = flags & 0x7FFF;\n\tdeleteListPresent = (flags & 0x8000) ? TRUE : FALSE;\n\tStream_Read_UINT16(s, create_offscreen_bitmap->cx); /* cx (2 bytes) */\n\tStream_Read_UINT16(s, create_offscreen_bitmap->cy); /* cy (2 bytes) */\n\tdeleteList = &(create_offscreen_bitmap->deleteList);\n\n\tif (deleteListPresent)\n\t{\n\t\tUINT32 i;\n\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, deleteList->cIndices);\n\n\t\tif (deleteList->cIndices > deleteList->sIndices)\n\t\t{\n\t\t\tUINT16* new_indices;\n\t\t\tnew_indices = (UINT16*)realloc(deleteList->indices, deleteList->cIndices * 2);\n\n\t\t\tif (!new_indices)\n\t\t\t\treturn FALSE;\n\n\t\t\tdeleteList->sIndices = deleteList->cIndices;\n\t\t\tdeleteList->indices = new_indices;\n\t\t}\n\n\t\tif (Stream_GetRemainingLength(s) < 2 * deleteList->cIndices)\n\t\t\treturn FALSE;\n\n\t\tfor (i = 0; i < deleteList->cIndices; i++)\n\t\t{\n\t\t\tStream_Read_UINT16(s, deleteList->indices[i]);\n\t\t}\n\t}\n\telse\n\t{\n\t\tdeleteList->cIndices = 0;\n\t}\n\n\treturn TRUE;\n}\nint update_approximate_create_offscreen_bitmap_order(\n    const CREATE_OFFSCREEN_BITMAP_ORDER* create_offscreen_bitmap)\n{\n\tconst OFFSCREEN_DELETE_LIST* deleteList = &(create_offscreen_bitmap->deleteList);\n\treturn 32 + deleteList->cIndices * 2;\n}\nBOOL update_write_create_offscreen_bitmap_order(\n    wStream* s, const CREATE_OFFSCREEN_BITMAP_ORDER* create_offscreen_bitmap)\n{\n\tUINT16 flags;\n\tBOOL deleteListPresent;\n\tconst OFFSCREEN_DELETE_LIST* deleteList;\n\n\tif (!Stream_EnsureRemainingCapacity(\n\t        s, update_approximate_create_offscreen_bitmap_order(create_offscreen_bitmap)))\n\t\treturn FALSE;\n\n\tdeleteList = &(create_offscreen_bitmap->deleteList);\n\tflags = create_offscreen_bitmap->id & 0x7FFF;\n\tdeleteListPresent = (deleteList->cIndices > 0) ? TRUE : FALSE;\n\n\tif (deleteListPresent)\n\t\tflags |= 0x8000;\n\n\tStream_Write_UINT16(s, flags);                       /* flags (2 bytes) */\n\tStream_Write_UINT16(s, create_offscreen_bitmap->cx); /* cx (2 bytes) */\n\tStream_Write_UINT16(s, create_offscreen_bitmap->cy); /* cy (2 bytes) */\n\n\tif (deleteListPresent)\n\t{\n\t\tint i;\n\t\tStream_Write_UINT16(s, deleteList->cIndices);\n\n\t\tfor (i = 0; i < (int)deleteList->cIndices; i++)\n\t\t{\n\t\t\tStream_Write_UINT16(s, deleteList->indices[i]);\n\t\t}\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_switch_surface_order(wStream* s, SWITCH_SURFACE_ORDER* switch_surface)\n{\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, switch_surface->bitmapId); /* bitmapId (2 bytes) */\n\treturn TRUE;\n}\nint update_approximate_switch_surface_order(const SWITCH_SURFACE_ORDER* switch_surface)\n{\n\treturn 2;\n}\nBOOL update_write_switch_surface_order(wStream* s, const SWITCH_SURFACE_ORDER* switch_surface)\n{\n\tint inf = update_approximate_switch_surface_order(switch_surface);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, switch_surface->bitmapId); /* bitmapId (2 bytes) */\n\treturn TRUE;\n}\nstatic BOOL\nupdate_read_create_nine_grid_bitmap_order(wStream* s,\n                                          CREATE_NINE_GRID_BITMAP_ORDER* create_nine_grid_bitmap)\n{\n\tNINE_GRID_BITMAP_INFO* nineGridInfo;\n\n\tif (Stream_GetRemainingLength(s) < 19)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, create_nine_grid_bitmap->bitmapBpp); /* bitmapBpp (1 byte) */\n\n\tif ((create_nine_grid_bitmap->bitmapBpp < 1) || (create_nine_grid_bitmap->bitmapBpp > 32))\n\t{\n\t\tWLog_ERR(TAG, \"invalid bpp value %\" PRIu32 \"\", create_nine_grid_bitmap->bitmapBpp);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, create_nine_grid_bitmap->bitmapId); /* bitmapId (2 bytes) */\n\tnineGridInfo = &(create_nine_grid_bitmap->nineGridInfo);\n\tStream_Read_UINT32(s, nineGridInfo->flFlags);          /* flFlags (4 bytes) */\n\tStream_Read_UINT16(s, nineGridInfo->ulLeftWidth);      /* ulLeftWidth (2 bytes) */\n\tStream_Read_UINT16(s, nineGridInfo->ulRightWidth);     /* ulRightWidth (2 bytes) */\n\tStream_Read_UINT16(s, nineGridInfo->ulTopHeight);      /* ulTopHeight (2 bytes) */\n\tStream_Read_UINT16(s, nineGridInfo->ulBottomHeight);   /* ulBottomHeight (2 bytes) */\n\tupdate_read_colorref(s, &nineGridInfo->crTransparent); /* crTransparent (4 bytes) */\n\treturn TRUE;\n}\nstatic BOOL update_read_frame_marker_order(wStream* s, FRAME_MARKER_ORDER* frame_marker)\n{\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, frame_marker->action); /* action (4 bytes) */\n\treturn TRUE;\n}\nstatic BOOL update_read_stream_bitmap_first_order(wStream* s,\n                                                  STREAM_BITMAP_FIRST_ORDER* stream_bitmap_first)\n{\n\tif (Stream_GetRemainingLength(s) < 10) // 8 + 2 at least\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, stream_bitmap_first->bitmapFlags); /* bitmapFlags (1 byte) */\n\tStream_Read_UINT8(s, stream_bitmap_first->bitmapBpp);   /* bitmapBpp (1 byte) */\n\n\tif ((stream_bitmap_first->bitmapBpp < 1) || (stream_bitmap_first->bitmapBpp > 32))\n\t{\n\t\tWLog_ERR(TAG, \"invalid bpp value %\" PRIu32 \"\", stream_bitmap_first->bitmapBpp);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, stream_bitmap_first->bitmapType);   /* bitmapType (2 bytes) */\n\tStream_Read_UINT16(s, stream_bitmap_first->bitmapWidth);  /* bitmapWidth (2 bytes) */\n\tStream_Read_UINT16(s, stream_bitmap_first->bitmapHeight); /* bitmapHeigth (2 bytes) */\n\n\tif (stream_bitmap_first->bitmapFlags & STREAM_BITMAP_V2)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, stream_bitmap_first->bitmapSize); /* bitmapSize (4 bytes) */\n\t}\n\telse\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, stream_bitmap_first->bitmapSize); /* bitmapSize (2 bytes) */\n\t}\n\n\tFIELD_SKIP_BUFFER16(\n\t    s, stream_bitmap_first->bitmapBlockSize); /* bitmapBlockSize(2 bytes) + bitmapBlock */\n\treturn TRUE;\n}\nstatic BOOL update_read_stream_bitmap_next_order(wStream* s,\n                                                 STREAM_BITMAP_NEXT_ORDER* stream_bitmap_next)\n{\n\tif (Stream_GetRemainingLength(s) < 5)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, stream_bitmap_next->bitmapFlags); /* bitmapFlags (1 byte) */\n\tStream_Read_UINT16(s, stream_bitmap_next->bitmapType); /* bitmapType (2 bytes) */\n\tFIELD_SKIP_BUFFER16(\n\t    s, stream_bitmap_next->bitmapBlockSize); /* bitmapBlockSize(2 bytes) + bitmapBlock */\n\treturn TRUE;\n}\nstatic BOOL update_read_draw_gdiplus_first_order(wStream* s,\n                                                 DRAW_GDIPLUS_FIRST_ORDER* draw_gdiplus_first)\n{\n\tif (Stream_GetRemainingLength(s) < 11)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT8(s);                                      /* pad1Octet (1 byte) */\n\tStream_Read_UINT16(s, draw_gdiplus_first->cbSize);         /* cbSize (2 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_first->cbTotalSize);    /* cbTotalSize (4 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_first->cbTotalEmfSize); /* cbTotalEmfSize (4 bytes) */\n\treturn Stream_SafeSeek(s, draw_gdiplus_first->cbSize);     /* emfRecords */\n}\nstatic BOOL update_read_draw_gdiplus_next_order(wStream* s,\n                                                DRAW_GDIPLUS_NEXT_ORDER* draw_gdiplus_next)\n{\n\tif (Stream_GetRemainingLength(s) < 3)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT8(s);                              /* pad1Octet (1 byte) */\n\tFIELD_SKIP_BUFFER16(s, draw_gdiplus_next->cbSize); /* cbSize(2 bytes) + emfRecords */\n\treturn TRUE;\n}\nstatic BOOL update_read_draw_gdiplus_end_order(wStream* s, DRAW_GDIPLUS_END_ORDER* draw_gdiplus_end)\n{\n\tif (Stream_GetRemainingLength(s) < 11)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT8(s);                                    /* pad1Octet (1 byte) */\n\tStream_Read_UINT16(s, draw_gdiplus_end->cbSize);         /* cbSize (2 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_end->cbTotalSize);    /* cbTotalSize (4 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_end->cbTotalEmfSize); /* cbTotalEmfSize (4 bytes) */\n\treturn Stream_SafeSeek(s, draw_gdiplus_end->cbSize);     /* emfRecords */\n}\nstatic BOOL\nupdate_read_draw_gdiplus_cache_first_order(wStream* s,\n                                           DRAW_GDIPLUS_CACHE_FIRST_ORDER* draw_gdiplus_cache_first)\n{\n\tif (Stream_GetRemainingLength(s) < 11)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, draw_gdiplus_cache_first->flags);        /* flags (1 byte) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_first->cacheType);   /* cacheType (2 bytes) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_first->cacheIndex);  /* cacheIndex (2 bytes) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_first->cbSize);      /* cbSize (2 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_cache_first->cbTotalSize); /* cbTotalSize (4 bytes) */\n\treturn Stream_SafeSeek(s, draw_gdiplus_cache_first->cbSize);  /* emfRecords */\n}\nstatic BOOL\nupdate_read_draw_gdiplus_cache_next_order(wStream* s,\n                                          DRAW_GDIPLUS_CACHE_NEXT_ORDER* draw_gdiplus_cache_next)\n{\n\tif (Stream_GetRemainingLength(s) < 7)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, draw_gdiplus_cache_next->flags);       /* flags (1 byte) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_next->cacheType);  /* cacheType (2 bytes) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_next->cacheIndex); /* cacheIndex (2 bytes) */\n\tFIELD_SKIP_BUFFER16(s, draw_gdiplus_cache_next->cbSize);    /* cbSize(2 bytes) + emfRecords */\n\treturn TRUE;\n}\nstatic BOOL\nupdate_read_draw_gdiplus_cache_end_order(wStream* s,\n                                         DRAW_GDIPLUS_CACHE_END_ORDER* draw_gdiplus_cache_end)\n{\n\tif (Stream_GetRemainingLength(s) < 11)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, draw_gdiplus_cache_end->flags);        /* flags (1 byte) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_end->cacheType);   /* cacheType (2 bytes) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_end->cacheIndex);  /* cacheIndex (2 bytes) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_end->cbSize);      /* cbSize (2 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_cache_end->cbTotalSize); /* cbTotalSize (4 bytes) */\n\treturn Stream_SafeSeek(s, draw_gdiplus_cache_end->cbSize);  /* emfRecords */\n}\nstatic BOOL update_read_field_flags(wStream* s, UINT32* fieldFlags, BYTE flags, BYTE fieldBytes)\n{\n\tint i;\n\tBYTE byte;\n\n\tif (flags & ORDER_ZERO_FIELD_BYTE_BIT0)\n\t\tfieldBytes--;\n\n\tif (flags & ORDER_ZERO_FIELD_BYTE_BIT1)\n\t{\n\t\tif (fieldBytes > 1)\n\t\t\tfieldBytes -= 2;\n\t\telse\n\t\t\tfieldBytes = 0;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < fieldBytes)\n\t\treturn FALSE;\n\n\t*fieldFlags = 0;\n\n\tfor (i = 0; i < fieldBytes; i++)\n\t{\n\t\tStream_Read_UINT8(s, byte);\n\t\t*fieldFlags |= byte << (i * 8);\n\t}\n\n\treturn TRUE;\n}\nBOOL update_write_field_flags(wStream* s, UINT32 fieldFlags, BYTE flags, BYTE fieldBytes)\n{\n\tBYTE byte;\n\n\tif (fieldBytes == 1)\n\t{\n\t\tbyte = fieldFlags & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse if (fieldBytes == 2)\n\t{\n\t\tbyte = fieldFlags & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (fieldFlags >> 8) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse if (fieldBytes == 3)\n\t{\n\t\tbyte = fieldFlags & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (fieldFlags >> 8) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (fieldFlags >> 16) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse\n\t{\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_bounds(wStream* s, rdpBounds* bounds)\n{\n\tBYTE flags;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, flags); /* field flags */\n\n\tif (flags & BOUND_LEFT)\n\t{\n\t\tif (!update_read_coord(s, &bounds->left, FALSE))\n\t\t\treturn FALSE;\n\t}\n\telse if (flags & BOUND_DELTA_LEFT)\n\t{\n\t\tif (!update_read_coord(s, &bounds->left, TRUE))\n\t\t\treturn FALSE;\n\t}\n\n\tif (flags & BOUND_TOP)\n\t{\n\t\tif (!update_read_coord(s, &bounds->top, FALSE))\n\t\t\treturn FALSE;\n\t}\n\telse if (flags & BOUND_DELTA_TOP)\n\t{\n\t\tif (!update_read_coord(s, &bounds->top, TRUE))\n\t\t\treturn FALSE;\n\t}\n\n\tif (flags & BOUND_RIGHT)\n\t{\n\t\tif (!update_read_coord(s, &bounds->right, FALSE))\n\t\t\treturn FALSE;\n\t}\n\telse if (flags & BOUND_DELTA_RIGHT)\n\t{\n\t\tif (!update_read_coord(s, &bounds->right, TRUE))\n\t\t\treturn FALSE;\n\t}\n\n\tif (flags & BOUND_BOTTOM)\n\t{\n\t\tif (!update_read_coord(s, &bounds->bottom, FALSE))\n\t\t\treturn FALSE;\n\t}\n\telse if (flags & BOUND_DELTA_BOTTOM)\n\t{\n\t\tif (!update_read_coord(s, &bounds->bottom, TRUE))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\nBOOL update_write_bounds(wStream* s, ORDER_INFO* orderInfo)\n{\n\tif (!(orderInfo->controlFlags & ORDER_BOUNDS))\n\t\treturn TRUE;\n\n\tif (orderInfo->controlFlags & ORDER_ZERO_BOUNDS_DELTAS)\n\t\treturn TRUE;\n\n\tStream_Write_UINT8(s, orderInfo->boundsFlags); /* field flags */\n\n\tif (orderInfo->boundsFlags & BOUND_LEFT)\n\t{\n\t\tif (!update_write_coord(s, orderInfo->bounds.left))\n\t\t\treturn FALSE;\n\t}\n\telse if (orderInfo->boundsFlags & BOUND_DELTA_LEFT)\n\t{\n\t}\n\n\tif (orderInfo->boundsFlags & BOUND_TOP)\n\t{\n\t\tif (!update_write_coord(s, orderInfo->bounds.top))\n\t\t\treturn FALSE;\n\t}\n\telse if (orderInfo->boundsFlags & BOUND_DELTA_TOP)\n\t{\n\t}\n\n\tif (orderInfo->boundsFlags & BOUND_RIGHT)\n\t{\n\t\tif (!update_write_coord(s, orderInfo->bounds.right))\n\t\t\treturn FALSE;\n\t}\n\telse if (orderInfo->boundsFlags & BOUND_DELTA_RIGHT)\n\t{\n\t}\n\n\tif (orderInfo->boundsFlags & BOUND_BOTTOM)\n\t{\n\t\tif (!update_write_coord(s, orderInfo->bounds.bottom))\n\t\t\treturn FALSE;\n\t}\n\telse if (orderInfo->boundsFlags & BOUND_DELTA_BOTTOM)\n\t{\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL read_primary_order(wLog* log, const char* orderName, wStream* s,\n                               const ORDER_INFO* orderInfo, rdpPrimaryUpdate* primary)\n{\n\tBOOL rc = FALSE;\n\n\tif (!s || !orderInfo || !primary || !orderName)\n\t\treturn FALSE;\n\n\tswitch (orderInfo->orderType)\n\t{\n\t\tcase ORDER_TYPE_DSTBLT:\n\t\t\trc = update_read_dstblt_order(s, orderInfo, &(primary->dstblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_PATBLT:\n\t\t\trc = update_read_patblt_order(s, orderInfo, &(primary->patblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SCRBLT:\n\t\t\trc = update_read_scrblt_order(s, orderInfo, &(primary->scrblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_OPAQUE_RECT:\n\t\t\trc = update_read_opaque_rect_order(s, orderInfo, &(primary->opaque_rect));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_DRAW_NINE_GRID:\n\t\t\trc = update_read_draw_nine_grid_order(s, orderInfo, &(primary->draw_nine_grid));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DSTBLT:\n\t\t\trc = update_read_multi_dstblt_order(s, orderInfo, &(primary->multi_dstblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_PATBLT:\n\t\t\trc = update_read_multi_patblt_order(s, orderInfo, &(primary->multi_patblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_SCRBLT:\n\t\t\trc = update_read_multi_scrblt_order(s, orderInfo, &(primary->multi_scrblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_OPAQUE_RECT:\n\t\t\trc = update_read_multi_opaque_rect_order(s, orderInfo, &(primary->multi_opaque_rect));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DRAW_NINE_GRID:\n\t\t\trc = update_read_multi_draw_nine_grid_order(s, orderInfo,\n\t\t\t                                            &(primary->multi_draw_nine_grid));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_LINE_TO:\n\t\t\trc = update_read_line_to_order(s, orderInfo, &(primary->line_to));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYLINE:\n\t\t\trc = update_read_polyline_order(s, orderInfo, &(primary->polyline));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEMBLT:\n\t\t\trc = update_read_memblt_order(s, orderInfo, &(primary->memblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEM3BLT:\n\t\t\trc = update_read_mem3blt_order(s, orderInfo, &(primary->mem3blt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SAVE_BITMAP:\n\t\t\trc = update_read_save_bitmap_order(s, orderInfo, &(primary->save_bitmap));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GLYPH_INDEX:\n\t\t\trc = update_read_glyph_index_order(s, orderInfo, &(primary->glyph_index));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_INDEX:\n\t\t\trc = update_read_fast_index_order(s, orderInfo, &(primary->fast_index));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_GLYPH:\n\t\t\trc = update_read_fast_glyph_order(s, orderInfo, &(primary->fast_glyph));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_SC:\n\t\t\trc = update_read_polygon_sc_order(s, orderInfo, &(primary->polygon_sc));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_CB:\n\t\t\trc = update_read_polygon_cb_order(s, orderInfo, &(primary->polygon_cb));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_SC:\n\t\t\trc = update_read_ellipse_sc_order(s, orderInfo, &(primary->ellipse_sc));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_CB:\n\t\t\trc = update_read_ellipse_cb_order(s, orderInfo, &(primary->ellipse_cb));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(log, WLOG_WARN, \"Primary Drawing Order %s not supported, ignoring\",\n\t\t\t           orderName);\n\t\t\trc = TRUE;\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(log, WLOG_ERROR, \"%s - update_read_dstblt_order() failed\", orderName);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_recv_primary_order(rdpUpdate* update, wStream* s, BYTE flags)\n{\n\tBYTE field;\n\tBOOL rc = FALSE;\n\trdpContext* context = update->context;\n\trdpPrimaryUpdate* primary = update->primary;\n\tORDER_INFO* orderInfo = &(primary->order_info);\n\trdpSettings* settings = context->settings;\n\tconst char* orderName;\n\n\tif (flags & ORDER_TYPE_CHANGE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) < 1\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tStream_Read_UINT8(s, orderInfo->orderType); /* orderType (1 byte) */\n\t}\n\n\torderName = primary_order_string(orderInfo->orderType);\n\n\tif (!check_primary_order_supported(update->log, settings, orderInfo->orderType, orderName))\n\t\treturn FALSE;\n\n\tfield = get_primary_drawing_order_field_bytes(orderInfo->orderType, &rc);\n\tif (!rc)\n\t\treturn FALSE;\n\n\tif (!update_read_field_flags(s, &(orderInfo->fieldFlags), flags, field))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"update_read_field_flags() failed\");\n\t\treturn FALSE;\n\t}\n\n\tif (flags & ORDER_BOUNDS)\n\t{\n\t\tif (!(flags & ORDER_ZERO_BOUNDS_DELTAS))\n\t\t{\n\t\t\tif (!update_read_bounds(s, &orderInfo->bounds))\n\t\t\t{\n\t\t\t\tWLog_Print(update->log, WLOG_ERROR, \"update_read_bounds() failed\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\n\t\trc = IFCALLRESULT(FALSE, update->SetBounds, context, &orderInfo->bounds);\n\n\t\tif (!rc)\n\t\t\treturn FALSE;\n\t}\n\n\torderInfo->deltaCoordinates = (flags & ORDER_DELTA_COORDINATES) ? TRUE : FALSE;\n\n\tif (!read_primary_order(update->log, orderName, s, orderInfo, primary))\n\t\treturn FALSE;\n\n\tswitch (orderInfo->orderType)\n\t{\n\t\tcase ORDER_TYPE_DSTBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->dstblt.bRop),\n\t\t\t           gdi_rop3_code(primary->dstblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->DstBlt, context, &primary->dstblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_PATBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->patblt.bRop),\n\t\t\t           gdi_rop3_code(primary->patblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->PatBlt, context, &primary->patblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_SCRBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->scrblt.bRop),\n\t\t\t           gdi_rop3_code(primary->scrblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->ScrBlt, context, &primary->scrblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_OPAQUE_RECT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->OpaqueRect, context, &primary->opaque_rect);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_DRAW_NINE_GRID:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->DrawNineGrid, context, &primary->draw_nine_grid);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DSTBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->multi_dstblt.bRop),\n\t\t\t           gdi_rop3_code(primary->multi_dstblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->MultiDstBlt, context, &primary->multi_dstblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_PATBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->multi_patblt.bRop),\n\t\t\t           gdi_rop3_code(primary->multi_patblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->MultiPatBlt, context, &primary->multi_patblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_SCRBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->multi_scrblt.bRop),\n\t\t\t           gdi_rop3_code(primary->multi_scrblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->MultiScrBlt, context, &primary->multi_scrblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_OPAQUE_RECT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc =\n\t\t\t    IFCALLRESULT(FALSE, primary->MultiOpaqueRect, context, &primary->multi_opaque_rect);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DRAW_NINE_GRID:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->MultiDrawNineGrid, context,\n\t\t\t                  &primary->multi_draw_nine_grid);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_LINE_TO:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->LineTo, context, &primary->line_to);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYLINE:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->Polyline, context, &primary->polyline);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEMBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->memblt.bRop),\n\t\t\t           gdi_rop3_code(primary->memblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->MemBlt, context, &primary->memblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEM3BLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->mem3blt.bRop),\n\t\t\t           gdi_rop3_code(primary->mem3blt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->Mem3Blt, context, &primary->mem3blt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_SAVE_BITMAP:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->SaveBitmap, context, &primary->save_bitmap);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_GLYPH_INDEX:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->GlyphIndex, context, &primary->glyph_index);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_INDEX:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->FastIndex, context, &primary->fast_index);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_GLYPH:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->FastGlyph, context, &primary->fast_glyph);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_SC:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->PolygonSC, context, &primary->polygon_sc);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_CB:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->PolygonCB, context, &primary->polygon_cb);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_SC:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->EllipseSC, context, &primary->ellipse_sc);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_CB:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->EllipseCB, context, &primary->ellipse_cb);\n\t\t}\n\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(update->log, WLOG_WARN, \"Primary Drawing Order %s not supported\", orderName);\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(update->log, WLOG_WARN, \"Primary Drawing Order %s failed\", orderName);\n\t\treturn FALSE;\n\t}\n\n\tif (flags & ORDER_BOUNDS)\n\t{\n\t\trc = IFCALLRESULT(FALSE, update->SetBounds, context, NULL);\n\t}\n\n\treturn rc;\n}\n\nstatic BOOL update_recv_secondary_order(rdpUpdate* update, wStream* s, BYTE flags)\n{\n\tBOOL rc = FALSE;\n\tsize_t start, end, diff;\n\tBYTE orderType;\n\tUINT16 extraFlags;\n\tUINT16 orderLength;\n\trdpContext* context = update->context;\n\trdpSettings* settings = context->settings;\n\trdpSecondaryUpdate* secondary = update->secondary;\n\tconst char* name;\n\n\tif (Stream_GetRemainingLength(s) < 5)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) < 5\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, orderLength); /* orderLength (2 bytes) */\n\tStream_Read_UINT16(s, extraFlags);  /* extraFlags (2 bytes) */\n\tStream_Read_UINT8(s, orderType);    /* orderType (1 byte) */\n\tif (Stream_GetRemainingLength(s) < orderLength + 7U)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) %\" PRIuz \" < %\" PRIu16,\n\t\t           Stream_GetRemainingLength(s), orderLength + 7);\n\t\treturn FALSE;\n\t}\n\n\tstart = Stream_GetPosition(s);\n\tname = secondary_order_string(orderType);\n\tWLog_Print(update->log, WLOG_DEBUG, \"Secondary Drawing Order %s\", name);\n\n\tif (!check_secondary_order_supported(update->log, settings, orderType, name))\n\t\treturn FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED:\n\t\tcase ORDER_TYPE_CACHE_BITMAP_COMPRESSED:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_CACHE_BITMAP_COMPRESSED);\n\t\t\tCACHE_BITMAP_ORDER* order =\n\t\t\t    update_read_cache_bitmap_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmap, context, order);\n\t\t\t\tfree_cache_bitmap_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED_V2:\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V2:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_BITMAP_COMPRESSED_V2);\n\t\t\tCACHE_BITMAP_V2_ORDER* order =\n\t\t\t    update_read_cache_bitmap_v2_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV2, context, order);\n\t\t\t\tfree_cache_bitmap_v2_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V3:\n\t\t{\n\t\t\tCACHE_BITMAP_V3_ORDER* order = update_read_cache_bitmap_v3_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV3, context, order);\n\t\t\t\tfree_cache_bitmap_v3_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_COLOR_TABLE:\n\t\t{\n\t\t\tCACHE_COLOR_TABLE_ORDER* order =\n\t\t\t    update_read_cache_color_table_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheColorTable, context, order);\n\t\t\t\tfree_cache_color_table_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_GLYPH:\n\t\t{\n\t\t\tswitch (settings->GlyphSupportLevel)\n\t\t\t{\n\t\t\t\tcase GLYPH_SUPPORT_PARTIAL:\n\t\t\t\tcase GLYPH_SUPPORT_FULL:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_ORDER* order = update_read_cache_glyph_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyph, context, order);\n\t\t\t\t\t\tfree_cache_glyph_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_ENCODE:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_V2_ORDER* order =\n\t\t\t\t\t    update_read_cache_glyph_v2_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyphV2, context, order);\n\t\t\t\t\t\tfree_cache_glyph_v2_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_NONE:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_BRUSH:\n\t\t\t/* [MS-RDPEGDI] 2.2.2.2.1.2.7 Cache Brush (CACHE_BRUSH_ORDER) */\n\t\t\t{\n\t\t\t\tCACHE_BRUSH_ORDER* order = update_read_cache_brush_order(update, s, extraFlags);\n\n\t\t\t\tif (order)\n\t\t\t\t{\n\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBrush, context, order);\n\t\t\t\t\tfree_cache_brush_order(context, order);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(update->log, WLOG_WARN, \"SECONDARY ORDER %s not supported\", name);\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"SECONDARY ORDER %s failed\", name);\n\t}\n\n\tstart += orderLength + 7;\n\tend = Stream_GetPosition(s);\n\tif (start > end)\n\t{\n\t\tWLog_Print(update->log, WLOG_WARN, \"SECONDARY_ORDER %s: read %\" PRIuz \"bytes too much\",\n\t\t           name, end - start);\n\t\treturn FALSE;\n\t}\n\tdiff = start - end;\n\tif (diff > 0)\n\t{\n\t\tWLog_Print(update->log, WLOG_DEBUG,\n\t\t           \"SECONDARY_ORDER %s: read %\" PRIuz \"bytes short, skipping\", name, diff);\n\t\tStream_Seek(s, diff);\n\t}\n\treturn rc;\n}\n\nstatic BOOL read_altsec_order(wStream* s, BYTE orderType, rdpAltSecUpdate* altsec)\n{\n\tBOOL rc = FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_CREATE_OFFSCREEN_BITMAP:\n\t\t\trc = update_read_create_offscreen_bitmap_order(s, &(altsec->create_offscreen_bitmap));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SWITCH_SURFACE:\n\t\t\trc = update_read_switch_surface_order(s, &(altsec->switch_surface));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CREATE_NINE_GRID_BITMAP:\n\t\t\trc = update_read_create_nine_grid_bitmap_order(s, &(altsec->create_nine_grid_bitmap));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FRAME_MARKER:\n\t\t\trc = update_read_frame_marker_order(s, &(altsec->frame_marker));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_STREAM_BITMAP_FIRST:\n\t\t\trc = update_read_stream_bitmap_first_order(s, &(altsec->stream_bitmap_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_STREAM_BITMAP_NEXT:\n\t\t\trc = update_read_stream_bitmap_next_order(s, &(altsec->stream_bitmap_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_FIRST:\n\t\t\trc = update_read_draw_gdiplus_first_order(s, &(altsec->draw_gdiplus_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_NEXT:\n\t\t\trc = update_read_draw_gdiplus_next_order(s, &(altsec->draw_gdiplus_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_END:\n\t\t\trc = update_read_draw_gdiplus_end_order(s, &(altsec->draw_gdiplus_end));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_FIRST:\n\t\t\trc = update_read_draw_gdiplus_cache_first_order(s, &(altsec->draw_gdiplus_cache_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_NEXT:\n\t\t\trc = update_read_draw_gdiplus_cache_next_order(s, &(altsec->draw_gdiplus_cache_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_END:\n\t\t\trc = update_read_draw_gdiplus_cache_end_order(s, &(altsec->draw_gdiplus_cache_end));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_WINDOW:\n\t\t\t/* This order is handled elsewhere. */\n\t\t\trc = TRUE;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_COMPDESK_FIRST:\n\t\t\trc = TRUE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic BOOL update_recv_altsec_order(rdpUpdate* update, wStream* s, BYTE flags)\n{\n\tBYTE orderType = flags >>= 2; /* orderType is in higher 6 bits of flags field */\n\tBOOL rc = FALSE;\n\trdpContext* context = update->context;\n\trdpSettings* settings = context->settings;\n\trdpAltSecUpdate* altsec = update->altsec;\n\tconst char* orderName = altsec_order_string(orderType);\n\tWLog_Print(update->log, WLOG_DEBUG, \"Alternate Secondary Drawing Order %s\", orderName);\n\n\tif (!check_alt_order_supported(update->log, settings, orderType, orderName))\n\t\treturn FALSE;\n\n\tif (!read_altsec_order(s, orderType, altsec))\n\t\treturn FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_CREATE_OFFSCREEN_BITMAP:\n\t\t\tIFCALLRET(altsec->CreateOffscreenBitmap, rc, context,\n\t\t\t          &(altsec->create_offscreen_bitmap));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SWITCH_SURFACE:\n\t\t\tIFCALLRET(altsec->SwitchSurface, rc, context, &(altsec->switch_surface));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CREATE_NINE_GRID_BITMAP:\n\t\t\tIFCALLRET(altsec->CreateNineGridBitmap, rc, context,\n\t\t\t          &(altsec->create_nine_grid_bitmap));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FRAME_MARKER:\n\t\t\tIFCALLRET(altsec->FrameMarker, rc, context, &(altsec->frame_marker));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_STREAM_BITMAP_FIRST:\n\t\t\tIFCALLRET(altsec->StreamBitmapFirst, rc, context, &(altsec->stream_bitmap_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_STREAM_BITMAP_NEXT:\n\t\t\tIFCALLRET(altsec->StreamBitmapNext, rc, context, &(altsec->stream_bitmap_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_FIRST:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusFirst, rc, context, &(altsec->draw_gdiplus_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_NEXT:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusNext, rc, context, &(altsec->draw_gdiplus_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_END:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusEnd, rc, context, &(altsec->draw_gdiplus_end));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_FIRST:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusCacheFirst, rc, context,\n\t\t\t          &(altsec->draw_gdiplus_cache_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_NEXT:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusCacheNext, rc, context,\n\t\t\t          &(altsec->draw_gdiplus_cache_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_END:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusCacheEnd, rc, context, &(altsec->draw_gdiplus_cache_end));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_WINDOW:\n\t\t\trc = update_recv_altsec_window_order(update, s);\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_COMPDESK_FIRST:\n\t\t\trc = TRUE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(update->log, WLOG_WARN, \"Alternate Secondary Drawing Order %s failed\",\n\t\t           orderName);\n\t}\n\n\treturn rc;\n}\nBOOL update_recv_order(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc;\n\tBYTE controlFlags;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) < 1\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT8(s, controlFlags); /* controlFlags (1 byte) */\n\n\tif (!(controlFlags & ORDER_STANDARD))\n\t\trc = update_recv_altsec_order(update, s, controlFlags);\n\telse if (controlFlags & ORDER_SECONDARY)\n\t\trc = update_recv_secondary_order(update, s, controlFlags);\n\telse\n\t\trc = update_recv_primary_order(update, s, controlFlags);\n\n\tif (!rc)\n\t\tWLog_Print(update->log, WLOG_ERROR, \"order flags %02\" PRIx8 \" failed\", controlFlags);\n\n\treturn rc;\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Drawing Orders\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2016 Armin Novak <armin.novak@thincast.com>\n * Copyright 2016 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef FREERDP_LIB_CORE_ORDERS_H\n#define FREERDP_LIB_CORE_ORDERS_H\n\n#include \"rdp.h\"\n\n#include <freerdp/types.h>\n#include <freerdp/update.h>\n#include <freerdp/api.h>\n\n#include <winpr/stream.h>\n\n/* Order Control Flags */\n#define ORDER_STANDARD 0x01\n#define ORDER_SECONDARY 0x02\n#define ORDER_BOUNDS 0x04\n#define ORDER_TYPE_CHANGE 0x08\n#define ORDER_DELTA_COORDINATES 0x10\n#define ORDER_ZERO_BOUNDS_DELTAS 0x20\n#define ORDER_ZERO_FIELD_BYTE_BIT0 0x40\n#define ORDER_ZERO_FIELD_BYTE_BIT1 0x80\n\n/* Bound Field Flags */\n#define BOUND_LEFT 0x01\n#define BOUND_TOP 0x02\n#define BOUND_RIGHT 0x04\n#define BOUND_BOTTOM 0x08\n#define BOUND_DELTA_LEFT 0x10\n#define BOUND_DELTA_TOP 0x20\n#define BOUND_DELTA_RIGHT 0x40\n#define BOUND_DELTA_BOTTOM 0x80\n\n/* Field Presence Flags */\n#define ORDER_FIELD_01 0x000001\n#define ORDER_FIELD_02 0x000002\n#define ORDER_FIELD_03 0x000004\n#define ORDER_FIELD_04 0x000008\n#define ORDER_FIELD_05 0x000010\n#define ORDER_FIELD_06 0x000020\n#define ORDER_FIELD_07 0x000040\n#define ORDER_FIELD_08 0x000080\n#define ORDER_FIELD_09 0x000100\n#define ORDER_FIELD_10 0x000200\n#define ORDER_FIELD_11 0x000400\n#define ORDER_FIELD_12 0x000800\n#define ORDER_FIELD_13 0x001000\n#define ORDER_FIELD_14 0x002000\n#define ORDER_FIELD_15 0x004000\n#define ORDER_FIELD_16 0x008000\n#define ORDER_FIELD_17 0x010000\n#define ORDER_FIELD_18 0x020000\n#define ORDER_FIELD_19 0x040000\n#define ORDER_FIELD_20 0x080000\n#define ORDER_FIELD_21 0x100000\n#define ORDER_FIELD_22 0x200000\n#define ORDER_FIELD_23 0x400000\n\n/* Bitmap Cache Flags */\n#define CBR2_8BPP 0x3\n#define CBR2_16BPP 0x4\n#define CBR2_24BPP 0x5\n#define CBR2_32BPP 0x6\n\n#define CBR23_8BPP 0x3\n#define CBR23_16BPP 0x4\n#define CBR23_24BPP 0x5\n#define CBR23_32BPP 0x6\n\n#define CBR3_IGNORABLE_FLAG 0x08\n#define CBR3_DO_NOT_CACHE 0x10\n\n/* Primary Drawing Orders */\n#define ORDER_TYPE_DSTBLT 0x00\n#define ORDER_TYPE_PATBLT 0x01\n#define ORDER_TYPE_SCRBLT 0x02\n#define ORDER_TYPE_DRAW_NINE_GRID 0x07\n#define ORDER_TYPE_MULTI_DRAW_NINE_GRID 0x08\n#define ORDER_TYPE_LINE_TO 0x09\n#define ORDER_TYPE_OPAQUE_RECT 0x0A\n#define ORDER_TYPE_SAVE_BITMAP 0x0B\n#define ORDER_TYPE_MEMBLT 0x0D\n#define ORDER_TYPE_MEM3BLT 0x0E\n#define ORDER_TYPE_MULTI_DSTBLT 0x0F\n#define ORDER_TYPE_MULTI_PATBLT 0x10\n#define ORDER_TYPE_MULTI_SCRBLT 0x11\n#define ORDER_TYPE_MULTI_OPAQUE_RECT 0x12\n#define ORDER_TYPE_FAST_INDEX 0x13\n#define ORDER_TYPE_POLYGON_SC 0x14\n#define ORDER_TYPE_POLYGON_CB 0x15\n#define ORDER_TYPE_POLYLINE 0x16\n#define ORDER_TYPE_FAST_GLYPH 0x18\n#define ORDER_TYPE_ELLIPSE_SC 0x19\n#define ORDER_TYPE_ELLIPSE_CB 0x1A\n#define ORDER_TYPE_GLYPH_INDEX 0x1B\n\n/* Primary Drawing Orders Fields */\n#define DSTBLT_ORDER_FIELDS 5\n#define PATBLT_ORDER_FIELDS 12\n#define SCRBLT_ORDER_FIELDS 7\n#define DRAW_NINE_GRID_ORDER_FIELDS 5\n#define MULTI_DRAW_NINE_GRID_ORDER_FIELDS 7\n#define LINE_TO_ORDER_FIELDS 10\n#define OPAQUE_RECT_ORDER_FIELDS 7\n#define SAVE_BITMAP_ORDER_FIELDS 6\n#define MEMBLT_ORDER_FIELDS 9\n#define MEM3BLT_ORDER_FIELDS 16\n#define MULTI_DSTBLT_ORDER_FIELDS 7\n#define MULTI_PATBLT_ORDER_FIELDS 14\n#define MULTI_SCRBLT_ORDER_FIELDS 9\n#define MULTI_OPAQUE_RECT_ORDER_FIELDS 9\n#define FAST_INDEX_ORDER_FIELDS 15\n#define POLYGON_SC_ORDER_FIELDS 7\n#define POLYGON_CB_ORDER_FIELDS 13\n#define POLYLINE_ORDER_FIELDS 7\n#define FAST_GLYPH_ORDER_FIELDS 15\n#define ELLIPSE_SC_ORDER_FIELDS 7\n#define ELLIPSE_CB_ORDER_FIELDS 13\n#define GLYPH_INDEX_ORDER_FIELDS 22\n\n/* Primary Drawing Orders Field Bytes */\n#define DSTBLT_ORDER_FIELD_BYTES 1\n#define PATBLT_ORDER_FIELD_BYTES 2\n#define SCRBLT_ORDER_FIELD_BYTES 1\n#define DRAW_NINE_GRID_ORDER_FIELD_BYTES 1\n#define MULTI_DRAW_NINE_GRID_ORDER_FIELD_BYTES 1\n#define LINE_TO_ORDER_FIELD_BYTES 2\n#define OPAQUE_RECT_ORDER_FIELD_BYTES 1\n#define SAVE_BITMAP_ORDER_FIELD_BYTES 1\n#define MEMBLT_ORDER_FIELD_BYTES 2\n#define MEM3BLT_ORDER_FIELD_BYTES 3\n#define MULTI_DSTBLT_ORDER_FIELD_BYTES 1\n#define MULTI_PATBLT_ORDER_FIELD_BYTES 2\n#define MULTI_SCRBLT_ORDER_FIELD_BYTES 2\n#define MULTI_OPAQUE_RECT_ORDER_FIELD_BYTES 2\n#define FAST_INDEX_ORDER_FIELD_BYTES 2\n#define POLYGON_SC_ORDER_FIELD_BYTES 1\n#define POLYGON_CB_ORDER_FIELD_BYTES 2\n#define POLYLINE_ORDER_FIELD_BYTES 1\n#define FAST_GLYPH_ORDER_FIELD_BYTES 2\n#define ELLIPSE_SC_ORDER_FIELD_BYTES 1\n#define ELLIPSE_CB_ORDER_FIELD_BYTES 2\n#define GLYPH_INDEX_ORDER_FIELD_BYTES 3\n\n/* Secondary Drawing Orders */\n#define ORDER_TYPE_BITMAP_UNCOMPRESSED 0x00\n#define ORDER_TYPE_CACHE_COLOR_TABLE 0x01\n#define ORDER_TYPE_CACHE_BITMAP_COMPRESSED 0x02\n#define ORDER_TYPE_CACHE_GLYPH 0x03\n#define ORDER_TYPE_BITMAP_UNCOMPRESSED_V2 0x04\n#define ORDER_TYPE_BITMAP_COMPRESSED_V2 0x05\n#define ORDER_TYPE_CACHE_BRUSH 0x07\n#define ORDER_TYPE_BITMAP_COMPRESSED_V3 0x08\n\n/* Alternate Secondary Drawing Orders */\n#define ORDER_TYPE_SWITCH_SURFACE 0x00\n#define ORDER_TYPE_CREATE_OFFSCREEN_BITMAP 0x01\n#define ORDER_TYPE_STREAM_BITMAP_FIRST 0x02\n#define ORDER_TYPE_STREAM_BITMAP_NEXT 0x03\n#define ORDER_TYPE_CREATE_NINE_GRID_BITMAP 0x04\n#define ORDER_TYPE_GDIPLUS_FIRST 0x05\n#define ORDER_TYPE_GDIPLUS_NEXT 0x06\n#define ORDER_TYPE_GDIPLUS_END 0x07\n#define ORDER_TYPE_GDIPLUS_CACHE_FIRST 0x08\n#define ORDER_TYPE_GDIPLUS_CACHE_NEXT 0x09\n#define ORDER_TYPE_GDIPLUS_CACHE_END 0x0A\n#define ORDER_TYPE_WINDOW 0x0B\n#define ORDER_TYPE_COMPDESK_FIRST 0x0C\n#define ORDER_TYPE_FRAME_MARKER 0x0D\n\n#define CG_GLYPH_UNICODE_PRESENT 0x0010\n\nFREERDP_LOCAL BYTE get_primary_drawing_order_field_bytes(UINT32 orderType, BOOL* pValid);\n\nFREERDP_LOCAL BOOL update_recv_order(rdpUpdate* update, wStream* s);\n\nFREERDP_LOCAL BOOL update_write_field_flags(wStream* s, UINT32 fieldFlags, BYTE flags,\n                                            BYTE fieldBytes);\n\nFREERDP_LOCAL BOOL update_write_bounds(wStream* s, ORDER_INFO* orderInfo);\n\nFREERDP_LOCAL int update_approximate_dstblt_order(ORDER_INFO* orderInfo,\n                                                  const DSTBLT_ORDER* dstblt);\nFREERDP_LOCAL BOOL update_write_dstblt_order(wStream* s, ORDER_INFO* orderInfo,\n                                             const DSTBLT_ORDER* dstblt);\n\nFREERDP_LOCAL int update_approximate_patblt_order(ORDER_INFO* orderInfo, PATBLT_ORDER* patblt);\nFREERDP_LOCAL BOOL update_write_patblt_order(wStream* s, ORDER_INFO* orderInfo,\n                                             PATBLT_ORDER* patblt);\n\nFREERDP_LOCAL int update_approximate_scrblt_order(ORDER_INFO* orderInfo,\n                                                  const SCRBLT_ORDER* scrblt);\nFREERDP_LOCAL BOOL update_write_scrblt_order(wStream* s, ORDER_INFO* orderInfo,\n                                             const SCRBLT_ORDER* scrblt);\n\nFREERDP_LOCAL int update_approximate_opaque_rect_order(ORDER_INFO* orderInfo,\n                                                       const OPAQUE_RECT_ORDER* opaque_rect);\nFREERDP_LOCAL BOOL update_write_opaque_rect_order(wStream* s, ORDER_INFO* orderInfo,\n                                                  const OPAQUE_RECT_ORDER* opaque_rect);\n\nFREERDP_LOCAL int update_approximate_line_to_order(ORDER_INFO* orderInfo,\n                                                   const LINE_TO_ORDER* line_to);\nFREERDP_LOCAL BOOL update_write_line_to_order(wStream* s, ORDER_INFO* orderInfo,\n                                              const LINE_TO_ORDER* line_to);\n\nFREERDP_LOCAL int update_approximate_memblt_order(ORDER_INFO* orderInfo,\n                                                  const MEMBLT_ORDER* memblt);\nFREERDP_LOCAL BOOL update_write_memblt_order(wStream* s, ORDER_INFO* orderInfo,\n                                             const MEMBLT_ORDER* memblt);\n\nFREERDP_LOCAL int update_approximate_glyph_index_order(ORDER_INFO* orderInfo,\n                                                       const GLYPH_INDEX_ORDER* glyph_index);\nFREERDP_LOCAL BOOL update_write_glyph_index_order(wStream* s, ORDER_INFO* orderInfo,\n                                                  GLYPH_INDEX_ORDER* glyph_index);\n\nFREERDP_LOCAL int update_approximate_cache_bitmap_order(const CACHE_BITMAP_ORDER* cache_bitmap,\n                                                        BOOL compressed, UINT16* flags);\nFREERDP_LOCAL BOOL update_write_cache_bitmap_order(wStream* s,\n                                                   const CACHE_BITMAP_ORDER* cache_bitmap_order,\n                                                   BOOL compressed, UINT16* flags);\n\nFREERDP_LOCAL int update_approximate_cache_bitmap_v2_order(CACHE_BITMAP_V2_ORDER* cache_bitmap_v2,\n                                                           BOOL compressed, UINT16* flags);\nFREERDP_LOCAL BOOL update_write_cache_bitmap_v2_order(wStream* s,\n                                                      CACHE_BITMAP_V2_ORDER* cache_bitmap_v2_order,\n                                                      BOOL compressed, UINT16* flags);\n\nFREERDP_LOCAL int update_approximate_cache_bitmap_v3_order(CACHE_BITMAP_V3_ORDER* cache_bitmap_v3,\n                                                           UINT16* flags);\nFREERDP_LOCAL BOOL update_write_cache_bitmap_v3_order(wStream* s,\n                                                      CACHE_BITMAP_V3_ORDER* cache_bitmap_v3_order,\n                                                      UINT16* flags);\n\nFREERDP_LOCAL int\nupdate_approximate_cache_color_table_order(const CACHE_COLOR_TABLE_ORDER* cache_color_table,\n                                           UINT16* flags);\nFREERDP_LOCAL BOOL update_write_cache_color_table_order(\n    wStream* s, const CACHE_COLOR_TABLE_ORDER* cache_color_table_order, UINT16* flags);\n\nFREERDP_LOCAL int update_approximate_cache_glyph_order(const CACHE_GLYPH_ORDER* cache_glyph,\n                                                       UINT16* flags);\nFREERDP_LOCAL BOOL update_write_cache_glyph_order(wStream* s,\n                                                  const CACHE_GLYPH_ORDER* cache_glyph_order,\n                                                  UINT16* flags);\n\nFREERDP_LOCAL int\nupdate_approximate_cache_glyph_v2_order(const CACHE_GLYPH_V2_ORDER* cache_glyph_v2, UINT16* flags);\nFREERDP_LOCAL BOOL update_write_cache_glyph_v2_order(wStream* s,\n                                                     const CACHE_GLYPH_V2_ORDER* cache_glyph_v2,\n                                                     UINT16* flags);\n\nFREERDP_LOCAL int update_approximate_cache_brush_order(const CACHE_BRUSH_ORDER* cache_brush,\n                                                       UINT16* flags);\nFREERDP_LOCAL BOOL update_write_cache_brush_order(wStream* s,\n                                                  const CACHE_BRUSH_ORDER* cache_brush_order,\n                                                  UINT16* flags);\n\nFREERDP_LOCAL int update_approximate_create_offscreen_bitmap_order(\n    const CREATE_OFFSCREEN_BITMAP_ORDER* create_offscreen_bitmap);\nFREERDP_LOCAL BOOL update_write_create_offscreen_bitmap_order(\n    wStream* s, const CREATE_OFFSCREEN_BITMAP_ORDER* create_offscreen_bitmap);\n\nFREERDP_LOCAL int\nupdate_approximate_switch_surface_order(const SWITCH_SURFACE_ORDER* switch_surface);\nFREERDP_LOCAL BOOL update_write_switch_surface_order(wStream* s,\n                                                     const SWITCH_SURFACE_ORDER* switch_surface);\n\n#endif /* FREERDP_LIB_CORE_ORDERS_H */\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Update Data PDUs\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2016 Armin Novak <armin.novak@thincast.com>\n * Copyright 2016 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n#include <winpr/print.h>\n#include <winpr/synch.h>\n#include <winpr/thread.h>\n#include <winpr/collections.h>\n\n#include \"update.h\"\n#include \"surface.h\"\n#include \"message.h\"\n#include \"info.h\"\n#include \"window.h\"\n\n#include <freerdp/log.h>\n#include <freerdp/peer.h>\n#include <freerdp/codec/bitmap.h>\n\n#include \"../cache/pointer.h\"\n#include \"../cache/palette.h\"\n#include \"../cache/bitmap.h\"\n\n#define TAG FREERDP_TAG(\"core.update\")\n\nstatic const char* const UPDATE_TYPE_STRINGS[] = { \"Orders\", \"Bitmap\", \"Palette\", \"Synchronize\" };\n\nstatic const char* update_type_to_string(UINT16 updateType)\n{\n\tif (updateType >= ARRAYSIZE(UPDATE_TYPE_STRINGS))\n\t\treturn \"UNKNOWN\";\n\n\treturn UPDATE_TYPE_STRINGS[updateType];\n}\n\nstatic BOOL update_recv_orders(rdpUpdate* update, wStream* s)\n{\n\tUINT16 numberOrders;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 6\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Seek_UINT16(s);               /* pad2OctetsA (2 bytes) */\n\tStream_Read_UINT16(s, numberOrders); /* numberOrders (2 bytes) */\n\tStream_Seek_UINT16(s);               /* pad2OctetsB (2 bytes) */\n\n\twhile (numberOrders > 0)\n\t{\n\t\tif (!update_recv_order(update, s))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"update_recv_order() failed\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tnumberOrders--;\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_read_bitmap_data(rdpUpdate* update, wStream* s, BITMAP_DATA* bitmapData)\n{\n\tWINPR_UNUSED(update);\n\tif (Stream_GetRemainingLength(s) < 18)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, bitmapData->destLeft);\n\tStream_Read_UINT16(s, bitmapData->destTop);\n\tStream_Read_UINT16(s, bitmapData->destRight);\n\tStream_Read_UINT16(s, bitmapData->destBottom);\n\tStream_Read_UINT16(s, bitmapData->width);\n\tStream_Read_UINT16(s, bitmapData->height);\n\tStream_Read_UINT16(s, bitmapData->bitsPerPixel);\n\tStream_Read_UINT16(s, bitmapData->flags);\n\tStream_Read_UINT16(s, bitmapData->bitmapLength);\n\n\tif (bitmapData->flags & BITMAP_COMPRESSION)\n\t{\n\t\tif (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\treturn FALSE;\n\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompMainBodySize); /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Read_UINT16(s, bitmapData->cbScanWidth);     /* cbScanWidth (2 bytes) */\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t\tbitmapData->bitmapLength = bitmapData->cbCompMainBodySize;\n\t\t}\n\n\t\tbitmapData->compressed = TRUE;\n\t}\n\telse\n\t\tbitmapData->compressed = FALSE;\n\n\tif (Stream_GetRemainingLength(s) < bitmapData->bitmapLength)\n\t\treturn FALSE;\n\n\tif (bitmapData->bitmapLength > 0)\n\t{\n\t\tbitmapData->bitmapDataStream = malloc(bitmapData->bitmapLength);\n\n\t\tif (!bitmapData->bitmapDataStream)\n\t\t\treturn FALSE;\n\n\t\tmemcpy(bitmapData->bitmapDataStream, Stream_Pointer(s), bitmapData->bitmapLength);\n\t\tStream_Seek(s, bitmapData->bitmapLength);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_write_bitmap_data(rdpUpdate* update, wStream* s, BITMAP_DATA* bitmapData)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, 64 + bitmapData->bitmapLength))\n\t\treturn FALSE;\n\n\tif (update->autoCalculateBitmapData)\n\t{\n\t\tbitmapData->flags = 0;\n\t\tbitmapData->cbCompFirstRowSize = 0;\n\n\t\tif (bitmapData->compressed)\n\t\t\tbitmapData->flags |= BITMAP_COMPRESSION;\n\n\t\tif (update->context->settings->NoBitmapCompressionHeader)\n\t\t{\n\t\t\tbitmapData->flags |= NO_BITMAP_COMPRESSION_HDR;\n\t\t\tbitmapData->cbCompMainBodySize = bitmapData->bitmapLength;\n\t\t}\n\t}\n\n\tStream_Write_UINT16(s, bitmapData->destLeft);\n\tStream_Write_UINT16(s, bitmapData->destTop);\n\tStream_Write_UINT16(s, bitmapData->destRight);\n\tStream_Write_UINT16(s, bitmapData->destBottom);\n\tStream_Write_UINT16(s, bitmapData->width);\n\tStream_Write_UINT16(s, bitmapData->height);\n\tStream_Write_UINT16(s, bitmapData->bitsPerPixel);\n\tStream_Write_UINT16(s, bitmapData->flags);\n\tStream_Write_UINT16(s, bitmapData->bitmapLength);\n\n\tif (bitmapData->flags & BITMAP_COMPRESSION)\n\t{\n\t\tif (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tStream_Write_UINT16(s,\n\t\t\t                    bitmapData->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Write_UINT16(s,\n\t\t\t                    bitmapData->cbCompMainBodySize); /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Write_UINT16(s, bitmapData->cbScanWidth);     /* cbScanWidth (2 bytes) */\n\t\t\tStream_Write_UINT16(s,\n\t\t\t                    bitmapData->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t}\n\n\t\tStream_Write(s, bitmapData->bitmapDataStream, bitmapData->bitmapLength);\n\t}\n\telse\n\t{\n\t\tStream_Write(s, bitmapData->bitmapDataStream, bitmapData->bitmapLength);\n\t}\n\n\treturn TRUE;\n}\n\nBITMAP_UPDATE* update_read_bitmap_update(rdpUpdate* update, wStream* s)\n{\n\tUINT32 i;\n\tBITMAP_UPDATE* bitmapUpdate = calloc(1, sizeof(BITMAP_UPDATE));\n\n\tif (!bitmapUpdate)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, bitmapUpdate->number); /* numberRectangles (2 bytes) */\n\tWLog_Print(update->log, WLOG_TRACE, \"BitmapUpdate: %\" PRIu32 \"\", bitmapUpdate->number);\n\n\tif (bitmapUpdate->number > bitmapUpdate->count)\n\t{\n\t\tUINT32 count = bitmapUpdate->number * 2;\n\t\tBITMAP_DATA* newdata =\n\t\t    (BITMAP_DATA*)realloc(bitmapUpdate->rectangles, sizeof(BITMAP_DATA) * count);\n\n\t\tif (!newdata)\n\t\t\tgoto fail;\n\n\t\tbitmapUpdate->rectangles = newdata;\n\t\tZeroMemory(&bitmapUpdate->rectangles[bitmapUpdate->count],\n\t\t           sizeof(BITMAP_DATA) * (count - bitmapUpdate->count));\n\t\tbitmapUpdate->count = count;\n\t}\n\n\t/* rectangles */\n\tfor (i = 0; i < bitmapUpdate->number; i++)\n\t{\n\t\tif (!update_read_bitmap_data(update, s, &bitmapUpdate->rectangles[i]))\n\t\t\tgoto fail;\n\t}\n\n\treturn bitmapUpdate;\nfail:\n\tfree_bitmap_update(update->context, bitmapUpdate);\n\treturn NULL;\n}\n\nstatic BOOL update_write_bitmap_update(rdpUpdate* update, wStream* s,\n                                       const BITMAP_UPDATE* bitmapUpdate)\n{\n\tint i;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, UPDATE_TYPE_BITMAP);   /* updateType */\n\tStream_Write_UINT16(s, bitmapUpdate->number); /* numberRectangles (2 bytes) */\n\n\t/* rectangles */\n\tfor (i = 0; i < (int)bitmapUpdate->number; i++)\n\t{\n\t\tif (!update_write_bitmap_data(update, s, &bitmapUpdate->rectangles[i]))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nPALETTE_UPDATE* update_read_palette(rdpUpdate* update, wStream* s)\n{\n\tint i;\n\tPALETTE_ENTRY* entry;\n\tPALETTE_UPDATE* palette_update = calloc(1, sizeof(PALETTE_UPDATE));\n\n\tif (!palette_update)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\tgoto fail;\n\n\tStream_Seek_UINT16(s);                         /* pad2Octets (2 bytes) */\n\tStream_Read_UINT32(s, palette_update->number); /* numberColors (4 bytes), must be set to 256 */\n\n\tif (palette_update->number > 256)\n\t\tpalette_update->number = 256;\n\n\tif (Stream_GetRemainingLength(s) < palette_update->number * 3)\n\t\tgoto fail;\n\n\t/* paletteEntries */\n\tfor (i = 0; i < (int)palette_update->number; i++)\n\t{\n\t\tentry = &palette_update->entries[i];\n\t\tStream_Read_UINT8(s, entry->red);\n\t\tStream_Read_UINT8(s, entry->green);\n\t\tStream_Read_UINT8(s, entry->blue);\n\t}\n\n\treturn palette_update;\nfail:\n\tfree_palette_update(update->context, palette_update);\n\treturn NULL;\n}\n\nstatic BOOL update_read_synchronize(rdpUpdate* update, wStream* s)\n{\n\tWINPR_UNUSED(update);\n\treturn Stream_SafeSeek(s, 2); /* pad2Octets (2 bytes) */\n\t                              /**\n\t                               * The Synchronize Update is an artifact from the\n\t                               * T.128 protocol and should be ignored.\n\t                               */\n}\n\nstatic BOOL update_read_play_sound(wStream* s, PLAY_SOUND_UPDATE* play_sound)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, play_sound->duration);  /* duration (4 bytes) */\n\tStream_Read_UINT32(s, play_sound->frequency); /* frequency (4 bytes) */\n\treturn TRUE;\n}\n\nBOOL update_recv_play_sound(rdpUpdate* update, wStream* s)\n{\n\tPLAY_SOUND_UPDATE play_sound;\n\n\tif (!update_read_play_sound(s, &play_sound))\n\t\treturn FALSE;\n\n\treturn IFCALLRESULT(FALSE, update->PlaySound, update->context, &play_sound);\n}\n\nPOINTER_POSITION_UPDATE* update_read_pointer_position(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_POSITION_UPDATE* pointer_position = calloc(1, sizeof(POINTER_POSITION_UPDATE));\n\n\tif (!pointer_position)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer_position->xPos); /* xPos (2 bytes) */\n\tStream_Read_UINT16(s, pointer_position->yPos); /* yPos (2 bytes) */\n\treturn pointer_position;\nfail:\n\tfree_pointer_position_update(update->context, pointer_position);\n\treturn NULL;\n}\n\nPOINTER_SYSTEM_UPDATE* update_read_pointer_system(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_SYSTEM_UPDATE* pointer_system = calloc(1, sizeof(POINTER_SYSTEM_UPDATE));\n\n\tif (!pointer_system)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\tgoto fail;\n\n\tStream_Read_UINT32(s, pointer_system->type); /* systemPointerType (4 bytes) */\n\treturn pointer_system;\nfail:\n\tfree_pointer_system_update(update->context, pointer_system);\n\treturn NULL;\n}\n\nstatic BOOL _update_read_pointer_color(wStream* s, POINTER_COLOR_UPDATE* pointer_color, BYTE xorBpp,\n                                       UINT32 flags)\n{\n\tBYTE* newMask;\n\tUINT32 scanlineSize;\n\tUINT32 max = 32;\n\n\tif (flags & LARGE_POINTER_FLAG_96x96)\n\t\tmax = 96;\n\n\tif (!pointer_color)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 14)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer_color->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Read_UINT16(s, pointer_color->xPos);       /* xPos (2 bytes) */\n\tStream_Read_UINT16(s, pointer_color->yPos);       /* yPos (2 bytes) */\n\t/**\n\t *  As stated in 2.2.9.1.1.4.4 Color Pointer Update:\n\t *  The maximum allowed pointer width/height is 96 pixels if the client indicated support\n\t *  for large pointers by setting the LARGE_POINTER_FLAG (0x00000001) in the Large\n\t *  Pointer Capability Set (section 2.2.7.2.7). If the LARGE_POINTER_FLAG was not\n\t *  set, the maximum allowed pointer width/height is 32 pixels.\n\t *\n\t *  So we check for a maximum for CVE-2014-0250.\n\t */\n\tStream_Read_UINT16(s, pointer_color->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, pointer_color->height); /* height (2 bytes) */\n\n\tif ((pointer_color->width > max) || (pointer_color->height > max))\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer_color->lengthAndMask); /* lengthAndMask (2 bytes) */\n\tStream_Read_UINT16(s, pointer_color->lengthXorMask); /* lengthXorMask (2 bytes) */\n\n\t/**\n\t * There does not seem to be any documentation on why\n\t * xPos / yPos can be larger than width / height\n\t * so it is missing in documentation or a bug in implementation\n\t * 2.2.9.1.1.4.4 Color Pointer Update (TS_COLORPOINTERATTRIBUTE)\n\t */\n\tif (pointer_color->xPos >= pointer_color->width)\n\t\tpointer_color->xPos = 0;\n\n\tif (pointer_color->yPos >= pointer_color->height)\n\t\tpointer_color->yPos = 0;\n\n\tif (pointer_color->lengthXorMask > 0)\n\t{\n\t\t/**\n\t\t * Spec states that:\n\t\t *\n\t\t * xorMaskData (variable): A variable-length array of bytes. Contains the 24-bpp, bottom-up\n\t\t * XOR mask scan-line data. The XOR mask is padded to a 2-byte boundary for each encoded\n\t\t * scan-line. For example, if a 3x3 pixel cursor is being sent, then each scan-line will\n\t\t * consume 10 bytes (3 pixels per scan-line multiplied by 3 bytes per pixel, rounded up to\n\t\t * the next even number of bytes).\n\t\t *\n\t\t * In fact instead of 24-bpp, the bpp parameter is given by the containing packet.\n\t\t */\n\t\tif (Stream_GetRemainingLength(s) < pointer_color->lengthXorMask)\n\t\t\tgoto fail;\n\n\t\tscanlineSize = (7 + xorBpp * pointer_color->width) / 8;\n\t\tscanlineSize = ((scanlineSize + 1) / 2) * 2;\n\n\t\tif (scanlineSize * pointer_color->height != pointer_color->lengthXorMask)\n\t\t{\n\t\t\tWLog_ERR(TAG,\n\t\t\t         \"invalid lengthXorMask: width=%\" PRIu32 \" height=%\" PRIu32 \", %\" PRIu32\n\t\t\t         \" instead of %\" PRIu32 \"\",\n\t\t\t         pointer_color->width, pointer_color->height, pointer_color->lengthXorMask,\n\t\t\t         scanlineSize * pointer_color->height);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnewMask = realloc(pointer_color->xorMaskData, pointer_color->lengthXorMask);\n\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\n\t\tpointer_color->xorMaskData = newMask;\n\t\tStream_Read(s, pointer_color->xorMaskData, pointer_color->lengthXorMask);\n\t}\n\n\tif (pointer_color->lengthAndMask > 0)\n\t{\n\t\t/**\n\t\t * andMaskData (variable): A variable-length array of bytes. Contains the 1-bpp, bottom-up\n\t\t * AND mask scan-line data. The AND mask is padded to a 2-byte boundary for each encoded\n\t\t * scan-line. For example, if a 7x7 pixel cursor is being sent, then each scan-line will\n\t\t * consume 2 bytes (7 pixels per scan-line multiplied by 1 bpp, rounded up to the next even\n\t\t * number of bytes).\n\t\t */\n\t\tif (Stream_GetRemainingLength(s) < pointer_color->lengthAndMask)\n\t\t\tgoto fail;\n\n\t\tscanlineSize = ((7 + pointer_color->width) / 8);\n\t\tscanlineSize = ((1 + scanlineSize) / 2) * 2;\n\n\t\tif (scanlineSize * pointer_color->height != pointer_color->lengthAndMask)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"invalid lengthAndMask: %\" PRIu32 \" instead of %\" PRIu32 \"\",\n\t\t\t         pointer_color->lengthAndMask, scanlineSize * pointer_color->height);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnewMask = realloc(pointer_color->andMaskData, pointer_color->lengthAndMask);\n\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\n\t\tpointer_color->andMaskData = newMask;\n\t\tStream_Read(s, pointer_color->andMaskData, pointer_color->lengthAndMask);\n\t}\n\n\tif (Stream_GetRemainingLength(s) > 0)\n\t\tStream_Seek_UINT8(s); /* pad (1 byte) */\n\n\treturn TRUE;\nfail:\n\treturn FALSE;\n}\n\nPOINTER_COLOR_UPDATE* update_read_pointer_color(rdpUpdate* update, wStream* s, BYTE xorBpp)\n{\n\tPOINTER_COLOR_UPDATE* pointer_color = calloc(1, sizeof(POINTER_COLOR_UPDATE));\n\n\tif (!pointer_color)\n\t\tgoto fail;\n\n\tif (!_update_read_pointer_color(s, pointer_color, xorBpp,\n\t                                update->context->settings->LargePointerFlag))\n\t\tgoto fail;\n\n\treturn pointer_color;\nfail:\n\tfree_pointer_color_update(update->context, pointer_color);\n\treturn NULL;\n}\n\nstatic BOOL _update_read_pointer_large(wStream* s, POINTER_LARGE_UPDATE* pointer)\n{\n\tBYTE* newMask;\n\tUINT32 scanlineSize;\n\n\tif (!pointer)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 20)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer->xorBpp);\n\tStream_Read_UINT16(s, pointer->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Read_UINT16(s, pointer->hotSpotX);   /* xPos (2 bytes) */\n\tStream_Read_UINT16(s, pointer->hotSpotY);   /* yPos (2 bytes) */\n\n\tStream_Read_UINT16(s, pointer->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, pointer->height); /* height (2 bytes) */\n\n\tif ((pointer->width > 384) || (pointer->height > 384))\n\t\tgoto fail;\n\n\tStream_Read_UINT32(s, pointer->lengthAndMask); /* lengthAndMask (4 bytes) */\n\tStream_Read_UINT32(s, pointer->lengthXorMask); /* lengthXorMask (4 bytes) */\n\n\tif (pointer->hotSpotX >= pointer->width)\n\t\tpointer->hotSpotX = 0;\n\n\tif (pointer->hotSpotY >= pointer->height)\n\t\tpointer->hotSpotY = 0;\n\n\tif (pointer->lengthXorMask > 0)\n\t{\n\t\t/**\n\t\t * Spec states that:\n\t\t *\n\t\t * xorMaskData (variable): A variable-length array of bytes. Contains the 24-bpp, bottom-up\n\t\t * XOR mask scan-line data. The XOR mask is padded to a 2-byte boundary for each encoded\n\t\t * scan-line. For example, if a 3x3 pixel cursor is being sent, then each scan-line will\n\t\t * consume 10 bytes (3 pixels per scan-line multiplied by 3 bytes per pixel, rounded up to\n\t\t * the next even number of bytes).\n\t\t *\n\t\t * In fact instead of 24-bpp, the bpp parameter is given by the containing packet.\n\t\t */\n\t\tif (Stream_GetRemainingLength(s) < pointer->lengthXorMask)\n\t\t\tgoto fail;\n\n\t\tscanlineSize = (7 + pointer->xorBpp * pointer->width) / 8;\n\t\tscanlineSize = ((scanlineSize + 1) / 2) * 2;\n\n\t\tif (scanlineSize * pointer->height != pointer->lengthXorMask)\n\t\t{\n\t\t\tWLog_ERR(TAG,\n\t\t\t         \"invalid lengthXorMask: width=%\" PRIu32 \" height=%\" PRIu32 \", %\" PRIu32\n\t\t\t         \" instead of %\" PRIu32 \"\",\n\t\t\t         pointer->width, pointer->height, pointer->lengthXorMask,\n\t\t\t         scanlineSize * pointer->height);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnewMask = realloc(pointer->xorMaskData, pointer->lengthXorMask);\n\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\n\t\tpointer->xorMaskData = newMask;\n\t\tStream_Read(s, pointer->xorMaskData, pointer->lengthXorMask);\n\t}\n\n\tif (pointer->lengthAndMask > 0)\n\t{\n\t\t/**\n\t\t * andMaskData (variable): A variable-length array of bytes. Contains the 1-bpp, bottom-up\n\t\t * AND mask scan-line data. The AND mask is padded to a 2-byte boundary for each encoded\n\t\t * scan-line. For example, if a 7x7 pixel cursor is being sent, then each scan-line will\n\t\t * consume 2 bytes (7 pixels per scan-line multiplied by 1 bpp, rounded up to the next even\n\t\t * number of bytes).\n\t\t */\n\t\tif (Stream_GetRemainingLength(s) < pointer->lengthAndMask)\n\t\t\tgoto fail;\n\n\t\tscanlineSize = ((7 + pointer->width) / 8);\n\t\tscanlineSize = ((1 + scanlineSize) / 2) * 2;\n\n\t\tif (scanlineSize * pointer->height != pointer->lengthAndMask)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"invalid lengthAndMask: %\" PRIu32 \" instead of %\" PRIu32 \"\",\n\t\t\t         pointer->lengthAndMask, scanlineSize * pointer->height);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnewMask = realloc(pointer->andMaskData, pointer->lengthAndMask);\n\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\n\t\tpointer->andMaskData = newMask;\n\t\tStream_Read(s, pointer->andMaskData, pointer->lengthAndMask);\n\t}\n\n\tif (Stream_GetRemainingLength(s) > 0)\n\t\tStream_Seek_UINT8(s); /* pad (1 byte) */\n\n\treturn TRUE;\nfail:\n\treturn FALSE;\n}\n\nPOINTER_LARGE_UPDATE* update_read_pointer_large(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_LARGE_UPDATE* pointer = calloc(1, sizeof(POINTER_LARGE_UPDATE));\n\n\tif (!pointer)\n\t\tgoto fail;\n\n\tif (!_update_read_pointer_large(s, pointer))\n\t\tgoto fail;\n\n\treturn pointer;\nfail:\n\tfree_pointer_large_update(update->context, pointer);\n\treturn NULL;\n}\n\nPOINTER_NEW_UPDATE* update_read_pointer_new(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_NEW_UPDATE* pointer_new = calloc(1, sizeof(POINTER_NEW_UPDATE));\n\n\tif (!pointer_new)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer_new->xorBpp); /* xorBpp (2 bytes) */\n\n\tif ((pointer_new->xorBpp < 1) || (pointer_new->xorBpp > 32))\n\t{\n\t\tWLog_ERR(TAG, \"invalid xorBpp %\" PRIu32 \"\", pointer_new->xorBpp);\n\t\tgoto fail;\n\t}\n\n\tif (!_update_read_pointer_color(s, &pointer_new->colorPtrAttr, pointer_new->xorBpp,\n\t                                update->context->settings->LargePointerFlag)) /* colorPtrAttr */\n\t\tgoto fail;\n\n\treturn pointer_new;\nfail:\n\tfree_pointer_new_update(update->context, pointer_new);\n\treturn NULL;\n}\n\nPOINTER_CACHED_UPDATE* update_read_pointer_cached(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_CACHED_UPDATE* pointer = calloc(1, sizeof(POINTER_CACHED_UPDATE));\n\n\tif (!pointer)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer->cacheIndex); /* cacheIndex (2 bytes) */\n\treturn pointer;\nfail:\n\tfree_pointer_cached_update(update->context, pointer);\n\treturn NULL;\n}\n\nBOOL update_recv_pointer(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = FALSE;\n\tUINT16 messageType;\n\trdpContext* context = update->context;\n\trdpPointerUpdate* pointer = update->pointer;\n\n\tif (Stream_GetRemainingLength(s) < 2 + 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, messageType); /* messageType (2 bytes) */\n\tStream_Seek_UINT16(s);              /* pad2Octets (2 bytes) */\n\n\tswitch (messageType)\n\t{\n\t\tcase PTR_MSG_TYPE_POSITION:\n\t\t{\n\t\t\tPOINTER_POSITION_UPDATE* pointer_position = update_read_pointer_position(update, s);\n\n\t\t\tif (pointer_position)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerPosition, context, pointer_position);\n\t\t\t\tfree_pointer_position_update(context, pointer_position);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_SYSTEM:\n\t\t{\n\t\t\tPOINTER_SYSTEM_UPDATE* pointer_system = update_read_pointer_system(update, s);\n\n\t\t\tif (pointer_system)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerSystem, context, pointer_system);\n\t\t\t\tfree_pointer_system_update(context, pointer_system);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_COLOR:\n\t\t{\n\t\t\tPOINTER_COLOR_UPDATE* pointer_color = update_read_pointer_color(update, s, 24);\n\n\t\t\tif (pointer_color)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerColor, context, pointer_color);\n\t\t\t\tfree_pointer_color_update(context, pointer_color);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_POINTER_LARGE:\n\t\t{\n\t\t\tPOINTER_LARGE_UPDATE* pointer_large = update_read_pointer_large(update, s);\n\n\t\t\tif (pointer_large)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerLarge, context, pointer_large);\n\t\t\t\tfree_pointer_large_update(context, pointer_large);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_POINTER:\n\t\t{\n\t\t\tPOINTER_NEW_UPDATE* pointer_new = update_read_pointer_new(update, s);\n\n\t\t\tif (pointer_new)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerNew, context, pointer_new);\n\t\t\t\tfree_pointer_new_update(context, pointer_new);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_CACHED:\n\t\t{\n\t\t\tPOINTER_CACHED_UPDATE* pointer_cached = update_read_pointer_cached(update, s);\n\n\t\t\tif (pointer_cached)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerCached, context, pointer_cached);\n\t\t\t\tfree_pointer_cached_update(context, pointer_cached);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nBOOL update_recv(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = FALSE;\n\tUINT16 updateType;\n\trdpContext* context = update->context;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 2\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, updateType); /* updateType (2 bytes) */\n\tWLog_Print(update->log, WLOG_TRACE, \"%s Update Data PDU\", update_type_to_string(updateType));\n\n\tif (!update_begin_paint(update))\n\t\tgoto fail;\n\n\tswitch (updateType)\n\t{\n\t\tcase UPDATE_TYPE_ORDERS:\n\t\t\trc = update_recv_orders(update, s);\n\t\t\tbreak;\n\n\t\tcase UPDATE_TYPE_BITMAP:\n\t\t{\n\t\t\tBITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s);\n\n\t\t\tif (!bitmap_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update);\n\t\t\tfree_bitmap_update(update->context, bitmap_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_PALETTE:\n\t\t{\n\t\t\tPALETTE_UPDATE* palette_update = update_read_palette(update, s);\n\n\t\t\tif (!palette_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_PALETTE - update_read_palette() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);\n\t\t\tfree_palette_update(context, palette_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_SYNCHRONIZE:\n\t\t\tif (!update_read_synchronize(update, s))\n\t\t\t\tgoto fail;\n\t\t\trc = IFCALLRESULT(TRUE, update->Synchronize, context);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\nfail:\n\n\tif (!update_end_paint(update))\n\t\trc = FALSE;\n\n\tif (!rc)\n\t{\n\t\tWLog_ERR(TAG, \"UPDATE_TYPE %s [%\" PRIu16 \"] failed\", update_type_to_string(updateType),\n\t\t         updateType);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nvoid update_reset_state(rdpUpdate* update)\n{\n\trdpPrimaryUpdate* primary = update->primary;\n\trdpAltSecUpdate* altsec = update->altsec;\n\n\tif (primary->fast_glyph.glyphData.aj)\n\t{\n\t\tfree(primary->fast_glyph.glyphData.aj);\n\t\tprimary->fast_glyph.glyphData.aj = NULL;\n\t}\n\n\tZeroMemory(&primary->order_info, sizeof(ORDER_INFO));\n\tZeroMemory(&primary->dstblt, sizeof(DSTBLT_ORDER));\n\tZeroMemory(&primary->patblt, sizeof(PATBLT_ORDER));\n\tZeroMemory(&primary->scrblt, sizeof(SCRBLT_ORDER));\n\tZeroMemory(&primary->opaque_rect, sizeof(OPAQUE_RECT_ORDER));\n\tZeroMemory(&primary->draw_nine_grid, sizeof(DRAW_NINE_GRID_ORDER));\n\tZeroMemory(&primary->multi_dstblt, sizeof(MULTI_DSTBLT_ORDER));\n\tZeroMemory(&primary->multi_patblt, sizeof(MULTI_PATBLT_ORDER));\n\tZeroMemory(&primary->multi_scrblt, sizeof(MULTI_SCRBLT_ORDER));\n\tZeroMemory(&primary->multi_opaque_rect, sizeof(MULTI_OPAQUE_RECT_ORDER));\n\tZeroMemory(&primary->multi_draw_nine_grid, sizeof(MULTI_DRAW_NINE_GRID_ORDER));\n\tZeroMemory(&primary->line_to, sizeof(LINE_TO_ORDER));\n\tZeroMemory(&primary->polyline, sizeof(POLYLINE_ORDER));\n\tZeroMemory(&primary->memblt, sizeof(MEMBLT_ORDER));\n\tZeroMemory(&primary->mem3blt, sizeof(MEM3BLT_ORDER));\n\tZeroMemory(&primary->save_bitmap, sizeof(SAVE_BITMAP_ORDER));\n\tZeroMemory(&primary->glyph_index, sizeof(GLYPH_INDEX_ORDER));\n\tZeroMemory(&primary->fast_index, sizeof(FAST_INDEX_ORDER));\n\tZeroMemory(&primary->fast_glyph, sizeof(FAST_GLYPH_ORDER));\n\tZeroMemory(&primary->polygon_sc, sizeof(POLYGON_SC_ORDER));\n\tZeroMemory(&primary->polygon_cb, sizeof(POLYGON_CB_ORDER));\n\tZeroMemory(&primary->ellipse_sc, sizeof(ELLIPSE_SC_ORDER));\n\tZeroMemory(&primary->ellipse_cb, sizeof(ELLIPSE_CB_ORDER));\n\tprimary->order_info.orderType = ORDER_TYPE_PATBLT;\n\n\tif (!update->initialState)\n\t{\n\t\taltsec->switch_surface.bitmapId = SCREEN_BITMAP_SURFACE;\n\t\tIFCALL(altsec->SwitchSurface, update->context, &(altsec->switch_surface));\n\t}\n}\n\nBOOL update_post_connect(rdpUpdate* update)\n{\n\tupdate->asynchronous = update->context->settings->AsyncUpdate;\n\n\tif (update->asynchronous)\n\t\tif (!(update->proxy = update_message_proxy_new(update)))\n\t\t\treturn FALSE;\n\n\tupdate->altsec->switch_surface.bitmapId = SCREEN_BITMAP_SURFACE;\n\tIFCALL(update->altsec->SwitchSurface, update->context, &(update->altsec->switch_surface));\n\tupdate->initialState = FALSE;\n\treturn TRUE;\n}\n\nvoid update_post_disconnect(rdpUpdate* update)\n{\n\tupdate->asynchronous = update->context->settings->AsyncUpdate;\n\n\tif (update->asynchronous)\n\t\tupdate_message_proxy_free(update->proxy);\n\n\tupdate->initialState = TRUE;\n}\n\nstatic BOOL _update_begin_paint(rdpContext* context)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\n\tif (update->us)\n\t{\n\t\tif (!update_end_paint(update))\n\t\t\treturn FALSE;\n\t}\n\n\ts = fastpath_update_pdu_init_new(context->rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_SealLength(s);\n\tStream_Seek(s, 2); /* numberOrders (2 bytes) */\n\tupdate->combineUpdates = TRUE;\n\tupdate->numberOrders = 0;\n\tupdate->us = s;\n\treturn TRUE;\n}\n\nstatic BOOL _update_end_paint(rdpContext* context)\n{\n\twStream* s;\n\tint headerLength;\n\trdpUpdate* update = context->update;\n\n\tif (!update->us)\n\t\treturn FALSE;\n\n\ts = update->us;\n\theaderLength = Stream_Length(s);\n\tStream_SealLength(s);\n\tStream_SetPosition(s, headerLength);\n\tStream_Write_UINT16(s, update->numberOrders); /* numberOrders (2 bytes) */\n\tStream_SetPosition(s, Stream_Length(s));\n\n\tif (update->numberOrders > 0)\n\t{\n\t\tWLog_DBG(TAG, \"sending %\" PRIu16 \" orders\", update->numberOrders);\n\t\tfastpath_send_update_pdu(context->rdp->fastpath, FASTPATH_UPDATETYPE_ORDERS, s, FALSE);\n\t}\n\n\tupdate->combineUpdates = FALSE;\n\tupdate->numberOrders = 0;\n\tupdate->us = NULL;\n\tStream_Free(s, TRUE);\n\treturn TRUE;\n}\n\nstatic void update_flush(rdpContext* context)\n{\n\trdpUpdate* update = context->update;\n\n\tif (update->numberOrders > 0)\n\t{\n\t\tupdate_end_paint(update);\n\t\tupdate_begin_paint(update);\n\t}\n}\n\nstatic void update_force_flush(rdpContext* context)\n{\n\tupdate_flush(context);\n}\n\nstatic BOOL update_check_flush(rdpContext* context, int size)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\ts = update->us;\n\n\tif (!update->us)\n\t{\n\t\tupdate_begin_paint(update);\n\t\treturn FALSE;\n\t}\n\n\tif (Stream_GetPosition(s) + size + 64 >= 0x3FFF)\n\t{\n\t\tupdate_flush(context);\n\t\treturn TRUE;\n\t}\n\n\treturn FALSE;\n}\n\nstatic BOOL update_set_bounds(rdpContext* context, const rdpBounds* bounds)\n{\n\trdpUpdate* update = context->update;\n\tCopyMemory(&update->previousBounds, &update->currentBounds, sizeof(rdpBounds));\n\n\tif (!bounds)\n\t\tZeroMemory(&update->currentBounds, sizeof(rdpBounds));\n\telse\n\t\tCopyMemory(&update->currentBounds, bounds, sizeof(rdpBounds));\n\n\treturn TRUE;\n}\n\nstatic BOOL update_bounds_is_null(rdpBounds* bounds)\n{\n\tif ((bounds->left == 0) && (bounds->top == 0) && (bounds->right == 0) && (bounds->bottom == 0))\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n\nstatic BOOL update_bounds_equals(rdpBounds* bounds1, rdpBounds* bounds2)\n{\n\tif ((bounds1->left == bounds2->left) && (bounds1->top == bounds2->top) &&\n\t    (bounds1->right == bounds2->right) && (bounds1->bottom == bounds2->bottom))\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n\nstatic int update_prepare_bounds(rdpContext* context, ORDER_INFO* orderInfo)\n{\n\tint length = 0;\n\trdpUpdate* update = context->update;\n\torderInfo->boundsFlags = 0;\n\n\tif (update_bounds_is_null(&update->currentBounds))\n\t\treturn 0;\n\n\torderInfo->controlFlags |= ORDER_BOUNDS;\n\n\tif (update_bounds_equals(&update->previousBounds, &update->currentBounds))\n\t{\n\t\torderInfo->controlFlags |= ORDER_ZERO_BOUNDS_DELTAS;\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tlength += 1;\n\n\t\tif (update->previousBounds.left != update->currentBounds.left)\n\t\t{\n\t\t\torderInfo->bounds.left = update->currentBounds.left;\n\t\t\torderInfo->boundsFlags |= BOUND_LEFT;\n\t\t\tlength += 2;\n\t\t}\n\n\t\tif (update->previousBounds.top != update->currentBounds.top)\n\t\t{\n\t\t\torderInfo->bounds.top = update->currentBounds.top;\n\t\t\torderInfo->boundsFlags |= BOUND_TOP;\n\t\t\tlength += 2;\n\t\t}\n\n\t\tif (update->previousBounds.right != update->currentBounds.right)\n\t\t{\n\t\t\torderInfo->bounds.right = update->currentBounds.right;\n\t\t\torderInfo->boundsFlags |= BOUND_RIGHT;\n\t\t\tlength += 2;\n\t\t}\n\n\t\tif (update->previousBounds.bottom != update->currentBounds.bottom)\n\t\t{\n\t\t\torderInfo->bounds.bottom = update->currentBounds.bottom;\n\t\t\torderInfo->boundsFlags |= BOUND_BOTTOM;\n\t\t\tlength += 2;\n\t\t}\n\t}\n\n\treturn length;\n}\n\nstatic int update_prepare_order_info(rdpContext* context, ORDER_INFO* orderInfo, UINT32 orderType)\n{\n\tint length = 1;\n\torderInfo->fieldFlags = 0;\n\torderInfo->orderType = orderType;\n\torderInfo->controlFlags = ORDER_STANDARD;\n\torderInfo->controlFlags |= ORDER_TYPE_CHANGE;\n\tlength += 1;\n\tlength += get_primary_drawing_order_field_bytes(orderInfo->orderType, NULL);\n\tlength += update_prepare_bounds(context, orderInfo);\n\treturn length;\n}\n\nstatic int update_write_order_info(rdpContext* context, wStream* s, ORDER_INFO* orderInfo,\n                                   size_t offset)\n{\n\tsize_t position;\n\tWINPR_UNUSED(context);\n\tposition = Stream_GetPosition(s);\n\tStream_SetPosition(s, offset);\n\tStream_Write_UINT8(s, orderInfo->controlFlags); /* controlFlags (1 byte) */\n\n\tif (orderInfo->controlFlags & ORDER_TYPE_CHANGE)\n\t\tStream_Write_UINT8(s, orderInfo->orderType); /* orderType (1 byte) */\n\n\tupdate_write_field_flags(s, orderInfo->fieldFlags, orderInfo->controlFlags,\n\t                         get_primary_drawing_order_field_bytes(orderInfo->orderType, NULL));\n\tupdate_write_bounds(s, orderInfo);\n\tStream_SetPosition(s, position);\n\treturn 0;\n}\n\nstatic void update_write_refresh_rect(wStream* s, BYTE count, const RECTANGLE_16* areas)\n{\n\tint i;\n\tStream_Write_UINT8(s, count); /* numberOfAreas (1 byte) */\n\tStream_Seek(s, 3);            /* pad3Octets (3 bytes) */\n\n\tfor (i = 0; i < count; i++)\n\t{\n\t\tStream_Write_UINT16(s, areas[i].left);   /* left (2 bytes) */\n\t\tStream_Write_UINT16(s, areas[i].top);    /* top (2 bytes) */\n\t\tStream_Write_UINT16(s, areas[i].right);  /* right (2 bytes) */\n\t\tStream_Write_UINT16(s, areas[i].bottom); /* bottom (2 bytes) */\n\t}\n}\n\nstatic BOOL update_send_refresh_rect(rdpContext* context, BYTE count, const RECTANGLE_16* areas)\n{\n\trdpRdp* rdp = context->rdp;\n\n\tif (rdp->settings->RefreshRect)\n\t{\n\t\twStream* s = rdp_data_pdu_init(rdp);\n\n\t\tif (!s)\n\t\t\treturn FALSE;\n\n\t\tupdate_write_refresh_rect(s, count, areas);\n\t\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_REFRESH_RECT, rdp->mcs->userId);\n\t}\n\n\treturn TRUE;\n}\n\nstatic void update_write_suppress_output(wStream* s, BYTE allow, const RECTANGLE_16* area)\n{\n\tStream_Write_UINT8(s, allow); /* allowDisplayUpdates (1 byte) */\n\t/* Use zeros for padding (like mstsc) for compatibility with legacy servers */\n\tStream_Zero(s, 3); /* pad3Octets (3 bytes) */\n\n\tif (allow > 0)\n\t{\n\t\tStream_Write_UINT16(s, area->left);   /* left (2 bytes) */\n\t\tStream_Write_UINT16(s, area->top);    /* top (2 bytes) */\n\t\tStream_Write_UINT16(s, area->right);  /* right (2 bytes) */\n\t\tStream_Write_UINT16(s, area->bottom); /* bottom (2 bytes) */\n\t}\n}\n\nstatic BOOL update_send_suppress_output(rdpContext* context, BYTE allow, const RECTANGLE_16* area)\n{\n\trdpRdp* rdp = context->rdp;\n\n\tif (rdp->settings->SuppressOutput)\n\t{\n\t\twStream* s = rdp_data_pdu_init(rdp);\n\n\t\tif (!s)\n\t\t\treturn FALSE;\n\n\t\tupdate_write_suppress_output(s, allow, area);\n\t\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_SUPPRESS_OUTPUT, rdp->mcs->userId);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_send_surface_command(rdpContext* context, wStream* s)\n{\n\twStream* update;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\tupdate = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!update)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(update, Stream_GetPosition(s)))\n\t{\n\t\tret = FALSE;\n\t\tgoto out;\n\t}\n\n\tStream_Write(update, Stream_Buffer(s), Stream_GetPosition(s));\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS, update, FALSE);\nout:\n\tStream_Release(update);\n\treturn ret;\n}\n\nstatic BOOL update_send_surface_bits(rdpContext* context,\n                                     const SURFACE_BITS_COMMAND* surfaceBitsCommand)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_surfcmd_surface_bits(s, surfaceBitsCommand))\n\t\tgoto out_fail;\n\n\tif (!fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS, s,\n\t                              surfaceBitsCommand->skipCompression))\n\t\tgoto out_fail;\n\n\tupdate_force_flush(context);\n\tret = TRUE;\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_surface_frame_marker(rdpContext* context,\n                                             const SURFACE_FRAME_MARKER* surfaceFrameMarker)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_surfcmd_frame_marker(s, surfaceFrameMarker->frameAction,\n\t                                       surfaceFrameMarker->frameId) ||\n\t    !fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS, s, FALSE))\n\t\tgoto out_fail;\n\n\tupdate_force_flush(context);\n\tret = TRUE;\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_surface_frame_bits(rdpContext* context, const SURFACE_BITS_COMMAND* cmd,\n                                           BOOL first, BOOL last, UINT32 frameId)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (first)\n\t{\n\t\tif (!update_write_surfcmd_frame_marker(s, SURFACECMD_FRAMEACTION_BEGIN, frameId))\n\t\t\tgoto out_fail;\n\t}\n\n\tif (!update_write_surfcmd_surface_bits(s, cmd))\n\t\tgoto out_fail;\n\n\tif (last)\n\t{\n\t\tif (!update_write_surfcmd_frame_marker(s, SURFACECMD_FRAMEACTION_END, frameId))\n\t\t\tgoto out_fail;\n\t}\n\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS, s,\n\t                               cmd->skipCompression);\n\tupdate_force_flush(context);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_frame_acknowledge(rdpContext* context, UINT32 frameId)\n{\n\trdpRdp* rdp = context->rdp;\n\n\tif (rdp->settings->ReceivedCapabilities[CAPSET_TYPE_FRAME_ACKNOWLEDGE])\n\t{\n\t\twStream* s = rdp_data_pdu_init(rdp);\n\n\t\tif (!s)\n\t\t\treturn FALSE;\n\n\t\tStream_Write_UINT32(s, frameId);\n\t\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_FRAME_ACKNOWLEDGE, rdp->mcs->userId);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_send_synchronize(rdpContext* context)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Zero(s, 2); /* pad2Octets (2 bytes) */\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SYNCHRONIZE, s, FALSE);\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_desktop_resize(rdpContext* context)\n{\n\treturn rdp_server_reactivate(context->rdp);\n}\n\nstatic BOOL update_send_bitmap_update(rdpContext* context, const BITMAP_UPDATE* bitmapUpdate)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\trdpUpdate* update = context->update;\n\tBOOL ret = TRUE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_bitmap_update(update, s, bitmapUpdate) ||\n\t    !fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_BITMAP, s,\n\t                              bitmapUpdate->skipCompression))\n\t{\n\t\tret = FALSE;\n\t\tgoto out_fail;\n\t}\n\n\tupdate_force_flush(context);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_play_sound(rdpContext* context, const PLAY_SOUND_UPDATE* play_sound)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\n\tif (!rdp->settings->ReceivedCapabilities[CAPSET_TYPE_SOUND])\n\t{\n\t\treturn TRUE;\n\t}\n\n\ts = rdp_data_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT32(s, play_sound->duration);\n\tStream_Write_UINT32(s, play_sound->frequency);\n\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_PLAY_SOUND, rdp->mcs->userId);\n}\n\n/**\n * Primary Drawing Orders\n */\n\nstatic BOOL update_send_dstblt(rdpContext* context, const DSTBLT_ORDER* dstblt)\n{\n\twStream* s;\n\tUINT32 offset;\n\tUINT32 headerLength;\n\tORDER_INFO orderInfo;\n\tint inf;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_DSTBLT);\n\tinf = update_approximate_dstblt_order(&orderInfo, dstblt);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_dstblt_order(s, &orderInfo, dstblt))\n\t\treturn FALSE;\n\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_patblt(rdpContext* context, PATBLT_ORDER* patblt)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_PATBLT);\n\tupdate_check_flush(context, headerLength + update_approximate_patblt_order(&orderInfo, patblt));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_patblt_order(s, &orderInfo, patblt);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_scrblt(rdpContext* context, const SCRBLT_ORDER* scrblt)\n{\n\twStream* s;\n\tUINT32 offset;\n\tUINT32 headerLength;\n\tORDER_INFO orderInfo;\n\tint inf;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_SCRBLT);\n\tinf = update_approximate_scrblt_order(&orderInfo, scrblt);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn TRUE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_scrblt_order(s, &orderInfo, scrblt);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_opaque_rect(rdpContext* context, const OPAQUE_RECT_ORDER* opaque_rect)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_OPAQUE_RECT);\n\tupdate_check_flush(context, headerLength +\n\t                                update_approximate_opaque_rect_order(&orderInfo, opaque_rect));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_opaque_rect_order(s, &orderInfo, opaque_rect);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_line_to(rdpContext* context, const LINE_TO_ORDER* line_to)\n{\n\twStream* s;\n\tint offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\tint inf;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_LINE_TO);\n\tinf = update_approximate_line_to_order(&orderInfo, line_to);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_line_to_order(s, &orderInfo, line_to);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_memblt(rdpContext* context, MEMBLT_ORDER* memblt)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_MEMBLT);\n\tupdate_check_flush(context, headerLength + update_approximate_memblt_order(&orderInfo, memblt));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_memblt_order(s, &orderInfo, memblt);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_glyph_index(rdpContext* context, GLYPH_INDEX_ORDER* glyph_index)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tint inf;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_GLYPH_INDEX);\n\tinf = update_approximate_glyph_index_order(&orderInfo, glyph_index);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_glyph_index_order(s, &orderInfo, glyph_index);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\n/*\n * Secondary Drawing Orders\n */\n\nstatic BOOL update_send_cache_bitmap(rdpContext* context, const CACHE_BITMAP_ORDER* cache_bitmap)\n{\n\twStream* s;\n\tsize_t bm, em;\n\tBYTE orderType;\n\tint headerLength;\n\tint inf;\n\tUINT16 extraFlags;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\textraFlags = 0;\n\theaderLength = 6;\n\torderType = cache_bitmap->compressed ? ORDER_TYPE_CACHE_BITMAP_COMPRESSED\n\t                                     : ORDER_TYPE_BITMAP_UNCOMPRESSED;\n\tinf =\n\t    update_approximate_cache_bitmap_order(cache_bitmap, cache_bitmap->compressed, &extraFlags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_bitmap_order(s, cache_bitmap, cache_bitmap->compressed, &extraFlags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, extraFlags);                      /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, orderType);                        /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_bitmap_v2(rdpContext* context, CACHE_BITMAP_V2_ORDER* cache_bitmap_v2)\n{\n\twStream* s;\n\tsize_t bm, em;\n\tBYTE orderType;\n\tint headerLength;\n\tUINT16 extraFlags;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\textraFlags = 0;\n\theaderLength = 6;\n\torderType = cache_bitmap_v2->compressed ? ORDER_TYPE_BITMAP_COMPRESSED_V2\n\t                                        : ORDER_TYPE_BITMAP_UNCOMPRESSED_V2;\n\n\tif (context->settings->NoBitmapCompressionHeader)\n\t\tcache_bitmap_v2->flags |= CBR2_NO_BITMAP_COMPRESSION_HDR;\n\n\tupdate_check_flush(context, headerLength +\n\t                                update_approximate_cache_bitmap_v2_order(\n\t                                    cache_bitmap_v2, cache_bitmap_v2->compressed, &extraFlags));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_bitmap_v2_order(s, cache_bitmap_v2, cache_bitmap_v2->compressed,\n\t                                        &extraFlags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, extraFlags);                      /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, orderType);                        /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_bitmap_v3(rdpContext* context, CACHE_BITMAP_V3_ORDER* cache_bitmap_v3)\n{\n\twStream* s;\n\tsize_t bm, em;\n\tBYTE orderType;\n\tint headerLength;\n\tUINT16 extraFlags;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\textraFlags = 0;\n\theaderLength = 6;\n\torderType = ORDER_TYPE_BITMAP_COMPRESSED_V3;\n\tupdate_check_flush(context, headerLength + update_approximate_cache_bitmap_v3_order(\n\t                                               cache_bitmap_v3, &extraFlags));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_bitmap_v3_order(s, cache_bitmap_v3, &extraFlags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, extraFlags);                      /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, orderType);                        /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_color_table(rdpContext* context,\n                                          const CACHE_COLOR_TABLE_ORDER* cache_color_table)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_color_table_order(cache_color_table, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_color_table_order(s, cache_color_table, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags);                           /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_COLOR_TABLE);     /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_glyph(rdpContext* context, const CACHE_GLYPH_ORDER* cache_glyph)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_glyph_order(cache_glyph, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_glyph_order(s, cache_glyph, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags);                           /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_GLYPH);           /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_glyph_v2(rdpContext* context,\n                                       const CACHE_GLYPH_V2_ORDER* cache_glyph_v2)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_glyph_v2_order(cache_glyph_v2, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_glyph_v2_order(s, cache_glyph_v2, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags);                           /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_GLYPH);           /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_brush(rdpContext* context, const CACHE_BRUSH_ORDER* cache_brush)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_brush_order(cache_brush, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_brush_order(s, cache_brush, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags);                           /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_BRUSH);           /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\n/**\n * Alternate Secondary Drawing Orders\n */\n\nstatic BOOL update_send_create_offscreen_bitmap_order(\n    rdpContext* context, const CREATE_OFFSCREEN_BITMAP_ORDER* create_offscreen_bitmap)\n{\n\twStream* s;\n\tsize_t bm, em, inf;\n\tBYTE orderType;\n\tBYTE controlFlags;\n\tint headerLength;\n\trdpUpdate* update = context->update;\n\theaderLength = 1;\n\torderType = ORDER_TYPE_CREATE_OFFSCREEN_BITMAP;\n\tcontrolFlags = ORDER_SECONDARY | (orderType << 2);\n\tinf = update_approximate_create_offscreen_bitmap_order(create_offscreen_bitmap);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_create_offscreen_bitmap_order(s, create_offscreen_bitmap))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, controlFlags); /* controlFlags (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_switch_surface_order(rdpContext* context,\n                                             const SWITCH_SURFACE_ORDER* switch_surface)\n{\n\twStream* s;\n\tsize_t bm, em, inf;\n\tBYTE orderType;\n\tBYTE controlFlags;\n\tint headerLength;\n\trdpUpdate* update;\n\n\tif (!context || !switch_surface || !context->update)\n\t\treturn FALSE;\n\n\tupdate = context->update;\n\theaderLength = 1;\n\torderType = ORDER_TYPE_SWITCH_SURFACE;\n\tcontrolFlags = ORDER_SECONDARY | (orderType << 2);\n\tinf = update_approximate_switch_surface_order(switch_surface);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_switch_surface_order(s, switch_surface))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, controlFlags); /* controlFlags (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_pointer_system(rdpContext* context,\n                                       const POINTER_SYSTEM_UPDATE* pointer_system)\n{\n\twStream* s;\n\tBYTE updateCode;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (pointer_system->type == SYSPTR_NULL)\n\t\tupdateCode = FASTPATH_UPDATETYPE_PTR_NULL;\n\telse\n\t\tupdateCode = FASTPATH_UPDATETYPE_PTR_DEFAULT;\n\n\tret = fastpath_send_update_pdu(rdp->fastpath, updateCode, s, FALSE);\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_pointer_position(rdpContext* context,\n                                         const POINTER_POSITION_UPDATE* pointerPosition)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 16))\n\t\tgoto out_fail;\n\n\tStream_Write_UINT16(s, pointerPosition->xPos); /* xPos (2 bytes) */\n\tStream_Write_UINT16(s, pointerPosition->yPos); /* yPos (2 bytes) */\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_PTR_POSITION, s, FALSE);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_write_pointer_color(wStream* s, const POINTER_COLOR_UPDATE* pointer_color)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, 32 + pointer_color->lengthAndMask +\n\t                                           pointer_color->lengthXorMask))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, pointer_color->cacheIndex);\n\tStream_Write_UINT16(s, pointer_color->xPos);\n\tStream_Write_UINT16(s, pointer_color->yPos);\n\tStream_Write_UINT16(s, pointer_color->width);\n\tStream_Write_UINT16(s, pointer_color->height);\n\tStream_Write_UINT16(s, pointer_color->lengthAndMask);\n\tStream_Write_UINT16(s, pointer_color->lengthXorMask);\n\n\tif (pointer_color->lengthXorMask > 0)\n\t\tStream_Write(s, pointer_color->xorMaskData, pointer_color->lengthXorMask);\n\n\tif (pointer_color->lengthAndMask > 0)\n\t\tStream_Write(s, pointer_color->andMaskData, pointer_color->lengthAndMask);\n\n\tStream_Write_UINT8(s, 0); /* pad (1 byte) */\n\treturn TRUE;\n}\n\nstatic BOOL update_send_pointer_color(rdpContext* context,\n                                      const POINTER_COLOR_UPDATE* pointer_color)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_pointer_color(s, pointer_color))\n\t\tgoto out_fail;\n\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_COLOR, s, FALSE);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_write_pointer_large(wStream* s, const POINTER_LARGE_UPDATE* pointer)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, 32 + pointer->lengthAndMask + pointer->lengthXorMask))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, pointer->xorBpp);\n\tStream_Write_UINT16(s, pointer->cacheIndex);\n\tStream_Write_UINT16(s, pointer->hotSpotX);\n\tStream_Write_UINT16(s, pointer->hotSpotY);\n\tStream_Write_UINT16(s, pointer->width);\n\tStream_Write_UINT16(s, pointer->height);\n\tStream_Write_UINT32(s, pointer->lengthAndMask);\n\tStream_Write_UINT32(s, pointer->lengthXorMask);\n\tStream_Write(s, pointer->xorMaskData, pointer->lengthXorMask);\n\tStream_Write(s, pointer->andMaskData, pointer->lengthAndMask);\n\tStream_Write_UINT8(s, 0); /* pad (1 byte) */\n\treturn TRUE;\n}\n\nstatic BOOL update_send_pointer_large(rdpContext* context, const POINTER_LARGE_UPDATE* pointer)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_pointer_large(s, pointer))\n\t\tgoto out_fail;\n\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_LARGE_POINTER, s, FALSE);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_pointer_new(rdpContext* context, const POINTER_NEW_UPDATE* pointer_new)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 16))\n\t\tgoto out_fail;\n\n\tStream_Write_UINT16(s, pointer_new->xorBpp); /* xorBpp (2 bytes) */\n\tupdate_write_pointer_color(s, &pointer_new->colorPtrAttr);\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_POINTER, s, FALSE);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_pointer_cached(rdpContext* context,\n                                       const POINTER_CACHED_UPDATE* pointer_cached)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, pointer_cached->cacheIndex); /* cacheIndex (2 bytes) */\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_CACHED, s, FALSE);\n\tStream_Release(s);\n\treturn ret;\n}\n\nBOOL update_read_refresh_rect(rdpUpdate* update, wStream* s)\n{\n\tint index;\n\tBYTE numberOfAreas;\n\tRECTANGLE_16* areas;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, numberOfAreas);\n\tStream_Seek(s, 3); /* pad3Octects */\n\n\tif (Stream_GetRemainingLength(s) < ((size_t)numberOfAreas * 4 * 2))\n\t\treturn FALSE;\n\n\tareas = (RECTANGLE_16*)calloc(numberOfAreas, sizeof(RECTANGLE_16));\n\n\tif (!areas)\n\t\treturn FALSE;\n\n\tfor (index = 0; index < numberOfAreas; index++)\n\t{\n\t\tStream_Read_UINT16(s, areas[index].left);\n\t\tStream_Read_UINT16(s, areas[index].top);\n\t\tStream_Read_UINT16(s, areas[index].right);\n\t\tStream_Read_UINT16(s, areas[index].bottom);\n\t}\n\n\tif (update->context->settings->RefreshRect)\n\t\tIFCALL(update->RefreshRect, update->context, numberOfAreas, areas);\n\telse\n\t\tWLog_Print(update->log, WLOG_WARN, \"ignoring refresh rect request from client\");\n\n\tfree(areas);\n\treturn TRUE;\n}\n\nBOOL update_read_suppress_output(rdpUpdate* update, wStream* s)\n{\n\tRECTANGLE_16* prect = NULL;\n\tRECTANGLE_16 rect = { 0 };\n\tBYTE allowDisplayUpdates;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, allowDisplayUpdates);\n\tStream_Seek(s, 3); /* pad3Octects */\n\n\tif (allowDisplayUpdates > 0)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < sizeof(RECTANGLE_16))\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT16(s, rect.left);\n\t\tStream_Read_UINT16(s, rect.top);\n\t\tStream_Read_UINT16(s, rect.right);\n\t\tStream_Read_UINT16(s, rect.bottom);\n\n\t\tprect = &rect;\n\t}\n\n\tif (update->context->settings->SuppressOutput)\n\t\tIFCALL(update->SuppressOutput, update->context, allowDisplayUpdates, prect);\n\telse\n\t\tWLog_Print(update->log, WLOG_WARN, \"ignoring suppress output request from client\");\n\n\treturn TRUE;\n}\n\nstatic BOOL update_send_set_keyboard_indicators(rdpContext* context, UINT16 led_flags)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\ts = rdp_data_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, 0);         /* unitId should be 0 according to MS-RDPBCGR 2.2.8.2.1.1 */\n\tStream_Write_UINT16(s, led_flags); /* ledFlags (2 bytes) */\n\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_SET_KEYBOARD_INDICATORS, rdp->mcs->userId);\n}\n\nstatic BOOL update_send_set_keyboard_ime_status(rdpContext* context, UINT16 imeId, UINT32 imeState,\n                                                UINT32 imeConvMode)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\ts = rdp_data_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\t/* unitId should be 0 according to MS-RDPBCGR 2.2.8.2.2.1 */\n\tStream_Write_UINT16(s, imeId);\n\tStream_Write_UINT32(s, imeState);\n\tStream_Write_UINT32(s, imeConvMode);\n\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_SET_KEYBOARD_IME_STATUS, rdp->mcs->userId);\n}\n\nstatic UINT16 update_calculate_new_or_existing_window(const WINDOW_ORDER_INFO* orderInfo,\n                                                      const WINDOW_STATE_ORDER* stateOrder)\n{\n\tUINT16 orderSize = 11;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OWNER) != 0)\n\t\torderSize += 4;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_STYLE) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_SHOW) != 0)\n\t\torderSize += 1;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TITLE) != 0)\n\t\torderSize += 2 + stateOrder->titleInfo.length;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_OFFSET) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_SIZE) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_X) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_Y) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RP_CONTENT) != 0)\n\t\torderSize += 1;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ROOT_PARENT) != 0)\n\t\torderSize += 4;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_OFFSET) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_CLIENT_DELTA) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_SIZE) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_RECTS) != 0)\n\t\torderSize += 2 + stateOrder->numWindowRects * sizeof(RECTANGLE_16);\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VIS_OFFSET) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VISIBILITY) != 0)\n\t\torderSize += 2 + stateOrder->numVisibilityRects * sizeof(RECTANGLE_16);\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OVERLAY_DESCRIPTION) != 0)\n\t\torderSize += 2 + stateOrder->OverlayDescription.length;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TASKBAR_BUTTON) != 0)\n\t\torderSize += 1;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ENFORCE_SERVER_ZORDER) != 0)\n\t\torderSize += 1;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_STATE) != 0)\n\t\torderSize += 1;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_EDGE) != 0)\n\t\torderSize += 1;\n\n\treturn orderSize;\n}\n\nstatic BOOL update_send_new_or_existing_window(rdpContext* context,\n                                               const WINDOW_ORDER_INFO* orderInfo,\n                                               const WINDOW_STATE_ORDER* stateOrder)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = update_calculate_new_or_existing_window(orderInfo, stateOrder);\n\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);   /* WindowID (4 bytes) */\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OWNER) != 0)\n\t\tStream_Write_UINT32(s, stateOrder->ownerWindowId);\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_STYLE) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->style);\n\t\tStream_Write_UINT32(s, stateOrder->extendedStyle);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_SHOW) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->showState);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TITLE) != 0)\n\t{\n\t\tStream_Write_UINT16(s, stateOrder->titleInfo.length);\n\t\tStream_Write(s, stateOrder->titleInfo.string, stateOrder->titleInfo.length);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_OFFSET) != 0)\n\t{\n\t\tStream_Write_INT32(s, stateOrder->clientOffsetX);\n\t\tStream_Write_INT32(s, stateOrder->clientOffsetY);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_SIZE) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->clientAreaWidth);\n\t\tStream_Write_UINT32(s, stateOrder->clientAreaHeight);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_X) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->resizeMarginLeft);\n\t\tStream_Write_UINT32(s, stateOrder->resizeMarginRight);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_Y) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->resizeMarginTop);\n\t\tStream_Write_UINT32(s, stateOrder->resizeMarginBottom);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RP_CONTENT) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->RPContent);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ROOT_PARENT) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->rootParentHandle);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_OFFSET) != 0)\n\t{\n\t\tStream_Write_INT32(s, stateOrder->windowOffsetX);\n\t\tStream_Write_INT32(s, stateOrder->windowOffsetY);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_CLIENT_DELTA) != 0)\n\t{\n\t\tStream_Write_INT32(s, stateOrder->windowClientDeltaX);\n\t\tStream_Write_INT32(s, stateOrder->windowClientDeltaY);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_SIZE) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->windowWidth);\n\t\tStream_Write_UINT32(s, stateOrder->windowHeight);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_RECTS) != 0)\n\t{\n\t\tStream_Write_UINT16(s, stateOrder->numWindowRects);\n\t\tStream_Write(s, stateOrder->windowRects, stateOrder->numWindowRects * sizeof(RECTANGLE_16));\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VIS_OFFSET) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->visibleOffsetX);\n\t\tStream_Write_UINT32(s, stateOrder->visibleOffsetY);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VISIBILITY) != 0)\n\t{\n\t\tStream_Write_UINT16(s, stateOrder->numVisibilityRects);\n\t\tStream_Write(s, stateOrder->visibilityRects,\n\t\t             stateOrder->numVisibilityRects * sizeof(RECTANGLE_16));\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OVERLAY_DESCRIPTION) != 0)\n\t{\n\t\tStream_Write_UINT16(s, stateOrder->OverlayDescription.length);\n\t\tStream_Write(s, stateOrder->OverlayDescription.string,\n\t\t             stateOrder->OverlayDescription.length);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TASKBAR_BUTTON) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->TaskbarButton);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ENFORCE_SERVER_ZORDER) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->EnforceServerZOrder);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_STATE) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->AppBarState);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_EDGE) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->AppBarEdge);\n\t}\n\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_window_create(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                      const WINDOW_STATE_ORDER* stateOrder)\n{\n\treturn update_send_new_or_existing_window(context, orderInfo, stateOrder);\n}\n\nstatic BOOL update_send_window_update(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                      const WINDOW_STATE_ORDER* stateOrder)\n{\n\treturn update_send_new_or_existing_window(context, orderInfo, stateOrder);\n}\n\nstatic UINT16 update_calculate_window_icon_order(const WINDOW_ORDER_INFO* orderInfo,\n                                                 const WINDOW_ICON_ORDER* iconOrder)\n{\n\tUINT16 orderSize = 23;\n\tICON_INFO* iconInfo = iconOrder->iconInfo;\n\n\torderSize += iconInfo->cbBitsColor + iconInfo->cbBitsMask;\n\n\tif (iconInfo->bpp <= 8)\n\t\torderSize += 2 + iconInfo->cbColorTable;\n\n\treturn orderSize;\n}\n\nstatic BOOL update_send_window_icon(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                    const WINDOW_ICON_ORDER* iconOrder)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tICON_INFO* iconInfo = iconOrder->iconInfo;\n\tUINT16 orderSize = update_calculate_window_icon_order(orderInfo, iconOrder);\n\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s || !iconInfo)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\n\t/* Write Hdr */\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);   /* WindowID (4 bytes) */\n\t/* Write body */\n\tStream_Write_UINT16(s, iconInfo->cacheEntry); /* CacheEntry (2 bytes) */\n\tStream_Write_UINT8(s, iconInfo->cacheId);     /* CacheId (1 byte) */\n\tStream_Write_UINT8(s, iconInfo->bpp);         /* Bpp (1 byte) */\n\tStream_Write_UINT16(s, iconInfo->width);      /* Width (2 bytes) */\n\tStream_Write_UINT16(s, iconInfo->height);     /* Height (2 bytes) */\n\n\tif (iconInfo->bpp <= 8)\n\t{\n\t\tStream_Write_UINT16(s, iconInfo->cbColorTable); /* CbColorTable (2 bytes) */\n\t}\n\n\tStream_Write_UINT16(s, iconInfo->cbBitsMask);              /* CbBitsMask (2 bytes) */\n\tStream_Write_UINT16(s, iconInfo->cbBitsColor);             /* CbBitsColor (2 bytes) */\n\tStream_Write(s, iconInfo->bitsMask, iconInfo->cbBitsMask); /* BitsMask (variable) */\n\n\tif (iconInfo->bpp <= 8)\n\t{\n\t\tStream_Write(s, iconInfo->colorTable, iconInfo->cbColorTable); /* ColorTable (variable) */\n\t}\n\n\tStream_Write(s, iconInfo->bitsColor, iconInfo->cbBitsColor); /* BitsColor (variable) */\n\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_window_cached_icon(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                           const WINDOW_CACHED_ICON_ORDER* cachedIconOrder)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = 14;\n\tCACHED_ICON_INFO cachedIcon = cachedIconOrder->cachedIcon;\n\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\n\t/* Write Hdr */\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);   /* WindowID (4 bytes) */\n\t/* Write body */\n\tStream_Write_UINT16(s, cachedIcon.cacheEntry); /* CacheEntry (2 bytes) */\n\tStream_Write_UINT8(s, cachedIcon.cacheId);     /* CacheId (1 byte) */\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_window_delete(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = 11;\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\n\t/* Write Hdr */\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);   /* WindowID (4 bytes) */\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic UINT16 update_calculate_new_or_existing_notification_icons_order(\n    const WINDOW_ORDER_INFO* orderInfo, const NOTIFY_ICON_STATE_ORDER* iconStateOrder)\n{\n\tUINT16 orderSize = 15;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_VERSION) != 0)\n\t\torderSize += 4;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_TIP) != 0)\n\t{\n\t\torderSize += 2 + iconStateOrder->toolTip.length;\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_INFO_TIP) != 0)\n\t{\n\t\tNOTIFY_ICON_INFOTIP infoTip = iconStateOrder->infoTip;\n\t\torderSize += 12 + infoTip.text.length + infoTip.title.length;\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_STATE) != 0)\n\t{\n\t\torderSize += 4;\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_ICON) != 0)\n\t{\n\t\tICON_INFO iconInfo = iconStateOrder->icon;\n\t\torderSize += 12;\n\n\t\tif (iconInfo.bpp <= 8)\n\t\t\torderSize += 2 + iconInfo.cbColorTable;\n\n\t\torderSize += iconInfo.cbBitsMask + iconInfo.cbBitsColor;\n\t}\n\telse if ((orderInfo->fieldFlags & WINDOW_ORDER_CACHED_ICON) != 0)\n\t{\n\t\torderSize += 3;\n\t}\n\n\treturn orderSize;\n}\n\nstatic BOOL\nupdate_send_new_or_existing_notification_icons(rdpContext* context,\n                                               const WINDOW_ORDER_INFO* orderInfo,\n                                               const NOTIFY_ICON_STATE_ORDER* iconStateOrder)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tBOOL versionFieldPresent = FALSE;\n\tUINT16 orderSize =\n\t    update_calculate_new_or_existing_notification_icons_order(orderInfo, iconStateOrder);\n\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\n\t/* Write Hdr */\n\tStream_Write_UINT8(s, controlFlags);             /* Header (1 byte) */\n\tStream_Write_INT16(s, orderSize);                /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags);   /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);     /* WindowID (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->notifyIconId); /* NotifyIconId (4 bytes) */\n\n\t/* Write body */\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_VERSION) != 0)\n\t{\n\t\tversionFieldPresent = TRUE;\n\t\tStream_Write_UINT32(s, iconStateOrder->version);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_TIP) != 0)\n\t{\n\t\tStream_Write_UINT16(s, iconStateOrder->toolTip.length);\n\t\tStream_Write(s, iconStateOrder->toolTip.string, iconStateOrder->toolTip.length);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_INFO_TIP) != 0)\n\t{\n\t\tNOTIFY_ICON_INFOTIP infoTip = iconStateOrder->infoTip;\n\n\t\t/* info tip should not be sent when version is 0 */\n\t\tif (versionFieldPresent && iconStateOrder->version == 0)\n\t\t\treturn FALSE;\n\n\t\tStream_Write_UINT32(s, infoTip.timeout);     /* Timeout (4 bytes) */\n\t\tStream_Write_UINT32(s, infoTip.flags);       /* InfoFlags (4 bytes) */\n\t\tStream_Write_UINT16(s, infoTip.text.length); /* InfoTipText (variable) */\n\t\tStream_Write(s, infoTip.text.string, infoTip.text.length);\n\t\tStream_Write_UINT16(s, infoTip.title.length); /* Title (variable) */\n\t\tStream_Write(s, infoTip.title.string, infoTip.title.length);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_STATE) != 0)\n\t{\n\t\t/* notify state should not be sent when version is 0 */\n\t\tif (versionFieldPresent && iconStateOrder->version == 0)\n\t\t\treturn FALSE;\n\n\t\tStream_Write_UINT32(s, iconStateOrder->state);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_ICON) != 0)\n\t{\n\t\tICON_INFO iconInfo = iconStateOrder->icon;\n\t\tStream_Write_UINT16(s, iconInfo.cacheEntry); /* CacheEntry (2 bytes) */\n\t\tStream_Write_UINT8(s, iconInfo.cacheId);     /* CacheId (1 byte) */\n\t\tStream_Write_UINT8(s, iconInfo.bpp);         /* Bpp (1 byte) */\n\t\tStream_Write_UINT16(s, iconInfo.width);      /* Width (2 bytes) */\n\t\tStream_Write_UINT16(s, iconInfo.height);     /* Height (2 bytes) */\n\n\t\tif (iconInfo.bpp <= 8)\n\t\t{\n\t\t\tStream_Write_UINT16(s, iconInfo.cbColorTable); /* CbColorTable (2 bytes) */\n\t\t}\n\n\t\tStream_Write_UINT16(s, iconInfo.cbBitsMask);             /* CbBitsMask (2 bytes) */\n\t\tStream_Write_UINT16(s, iconInfo.cbBitsColor);            /* CbBitsColor (2 bytes) */\n\t\tStream_Write(s, iconInfo.bitsMask, iconInfo.cbBitsMask); /* BitsMask (variable) */\n\t\torderSize += iconInfo.cbBitsMask;\n\n\t\tif (iconInfo.bpp <= 8)\n\t\t{\n\t\t\tStream_Write(s, iconInfo.colorTable, iconInfo.cbColorTable); /* ColorTable (variable) */\n\t\t}\n\n\t\tStream_Write(s, iconInfo.bitsColor, iconInfo.cbBitsColor); /* BitsColor (variable) */\n\t}\n\telse if ((orderInfo->fieldFlags & WINDOW_ORDER_CACHED_ICON) != 0)\n\t{\n\t\tCACHED_ICON_INFO cachedIcon = iconStateOrder->cachedIcon;\n\t\tStream_Write_UINT16(s, cachedIcon.cacheEntry); /* CacheEntry (2 bytes) */\n\t\tStream_Write_UINT8(s, cachedIcon.cacheId);     /* CacheId (1 byte) */\n\t}\n\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_notify_icon_create(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                           const NOTIFY_ICON_STATE_ORDER* iconStateOrder)\n{\n\treturn update_send_new_or_existing_notification_icons(context, orderInfo, iconStateOrder);\n}\n\nstatic BOOL update_send_notify_icon_update(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                           const NOTIFY_ICON_STATE_ORDER* iconStateOrder)\n{\n\treturn update_send_new_or_existing_notification_icons(context, orderInfo, iconStateOrder);\n}\n\nstatic BOOL update_send_notify_icon_delete(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = 15;\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\t/* Write Hdr */\n\tStream_Write_UINT8(s, controlFlags);             /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);               /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags);   /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);     /* WindowID (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->notifyIconId); /* NotifyIconId (4 bytes) */\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic UINT16 update_calculate_monitored_desktop(const WINDOW_ORDER_INFO* orderInfo,\n                                                 const MONITORED_DESKTOP_ORDER* monitoredDesktop)\n{\n\tUINT16 orderSize = 7;\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ACTIVE_WND)\n\t{\n\t\torderSize += 4;\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ZORDER)\n\t{\n\t\torderSize += 1 + (4 * monitoredDesktop->numWindowIds);\n\t}\n\n\treturn orderSize;\n}\n\nstatic BOOL update_send_monitored_desktop(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                          const MONITORED_DESKTOP_ORDER* monitoredDesktop)\n{\n\tUINT32 i;\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = update_calculate_monitored_desktop(orderInfo, monitoredDesktop);\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ACTIVE_WND)\n\t{\n\t\tStream_Write_UINT32(s, monitoredDesktop->activeWindowId); /* activeWindowId (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ZORDER)\n\t{\n\t\tStream_Write_UINT8(s, monitoredDesktop->numWindowIds); /* numWindowIds (1 byte) */\n\n\t\t/* windowIds */\n\t\tfor (i = 0; i < monitoredDesktop->numWindowIds; i++)\n\t\t{\n\t\t\tStream_Write_UINT32(s, monitoredDesktop->windowIds[i]);\n\t\t}\n\t}\n\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_non_monitored_desktop(rdpContext* context,\n                                              const WINDOW_ORDER_INFO* orderInfo)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = 7;\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nvoid update_register_server_callbacks(rdpUpdate* update)\n{\n\tupdate->BeginPaint = _update_begin_paint;\n\tupdate->EndPaint = _update_end_paint;\n\tupdate->SetBounds = update_set_bounds;\n\tupdate->Synchronize = update_send_synchronize;\n\tupdate->DesktopResize = update_send_desktop_resize;\n\tupdate->BitmapUpdate = update_send_bitmap_update;\n\tupdate->SurfaceBits = update_send_surface_bits;\n\tupdate->SurfaceFrameMarker = update_send_surface_frame_marker;\n\tupdate->SurfaceCommand = update_send_surface_command;\n\tupdate->SurfaceFrameBits = update_send_surface_frame_bits;\n\tupdate->PlaySound = update_send_play_sound;\n\tupdate->SetKeyboardIndicators = update_send_set_keyboard_indicators;\n\tupdate->SetKeyboardImeStatus = update_send_set_keyboard_ime_status;\n\tupdate->SaveSessionInfo = rdp_send_save_session_info;\n\tupdate->ServerStatusInfo = rdp_send_server_status_info;\n\tupdate->primary->DstBlt = update_send_dstblt;\n\tupdate->primary->PatBlt = update_send_patblt;\n\tupdate->primary->ScrBlt = update_send_scrblt;\n\tupdate->primary->OpaqueRect = update_send_opaque_rect;\n\tupdate->primary->LineTo = update_send_line_to;\n\tupdate->primary->MemBlt = update_send_memblt;\n\tupdate->primary->GlyphIndex = update_send_glyph_index;\n\tupdate->secondary->CacheBitmap = update_send_cache_bitmap;\n\tupdate->secondary->CacheBitmapV2 = update_send_cache_bitmap_v2;\n\tupdate->secondary->CacheBitmapV3 = update_send_cache_bitmap_v3;\n\tupdate->secondary->CacheColorTable = update_send_cache_color_table;\n\tupdate->secondary->CacheGlyph = update_send_cache_glyph;\n\tupdate->secondary->CacheGlyphV2 = update_send_cache_glyph_v2;\n\tupdate->secondary->CacheBrush = update_send_cache_brush;\n\tupdate->altsec->CreateOffscreenBitmap = update_send_create_offscreen_bitmap_order;\n\tupdate->altsec->SwitchSurface = update_send_switch_surface_order;\n\tupdate->pointer->PointerSystem = update_send_pointer_system;\n\tupdate->pointer->PointerPosition = update_send_pointer_position;\n\tupdate->pointer->PointerColor = update_send_pointer_color;\n\tupdate->pointer->PointerLarge = update_send_pointer_large;\n\tupdate->pointer->PointerNew = update_send_pointer_new;\n\tupdate->pointer->PointerCached = update_send_pointer_cached;\n\tupdate->window->WindowCreate = update_send_window_create;\n\tupdate->window->WindowUpdate = update_send_window_update;\n\tupdate->window->WindowIcon = update_send_window_icon;\n\tupdate->window->WindowCachedIcon = update_send_window_cached_icon;\n\tupdate->window->WindowDelete = update_send_window_delete;\n\tupdate->window->NotifyIconCreate = update_send_notify_icon_create;\n\tupdate->window->NotifyIconUpdate = update_send_notify_icon_update;\n\tupdate->window->NotifyIconDelete = update_send_notify_icon_delete;\n\tupdate->window->MonitoredDesktop = update_send_monitored_desktop;\n\tupdate->window->NonMonitoredDesktop = update_send_non_monitored_desktop;\n}\n\nvoid update_register_client_callbacks(rdpUpdate* update)\n{\n\tupdate->RefreshRect = update_send_refresh_rect;\n\tupdate->SuppressOutput = update_send_suppress_output;\n\tupdate->SurfaceFrameAcknowledge = update_send_frame_acknowledge;\n}\n\nint update_process_messages(rdpUpdate* update)\n{\n\treturn update_message_queue_process_pending_messages(update);\n}\n\nstatic void update_free_queued_message(void* obj)\n{\n\twMessage* msg = (wMessage*)obj;\n\tupdate_message_queue_free_message(msg);\n}\n\nvoid update_free_window_state(WINDOW_STATE_ORDER* window_state)\n{\n\tif (!window_state)\n\t\treturn;\n\n\tfree(window_state->OverlayDescription.string);\n\tfree(window_state->titleInfo.string);\n\tfree(window_state->windowRects);\n\tfree(window_state->visibilityRects);\n\tmemset(window_state, 0, sizeof(WINDOW_STATE_ORDER));\n}\n\nrdpUpdate* update_new(rdpRdp* rdp)\n{\n\tconst wObject cb = { NULL, NULL, NULL, update_free_queued_message, NULL };\n\trdpUpdate* update;\n\tOFFSCREEN_DELETE_LIST* deleteList;\n\tWINPR_UNUSED(rdp);\n\tupdate = (rdpUpdate*)calloc(1, sizeof(rdpUpdate));\n\n\tif (!update)\n\t\treturn NULL;\n\n\tupdate->log = WLog_Get(\"com.freerdp.core.update\");\n\tInitializeCriticalSection(&(update->mux));\n\tupdate->pointer = (rdpPointerUpdate*)calloc(1, sizeof(rdpPointerUpdate));\n\n\tif (!update->pointer)\n\t\tgoto fail;\n\n\tupdate->primary = (rdpPrimaryUpdate*)calloc(1, sizeof(rdpPrimaryUpdate));\n\n\tif (!update->primary)\n\t\tgoto fail;\n\n\tupdate->secondary = (rdpSecondaryUpdate*)calloc(1, sizeof(rdpSecondaryUpdate));\n\n\tif (!update->secondary)\n\t\tgoto fail;\n\n\tupdate->altsec = (rdpAltSecUpdate*)calloc(1, sizeof(rdpAltSecUpdate));\n\n\tif (!update->altsec)\n\t\tgoto fail;\n\n\tupdate->window = (rdpWindowUpdate*)calloc(1, sizeof(rdpWindowUpdate));\n\n\tif (!update->window)\n\t\tgoto fail;\n\n\tdeleteList = &(update->altsec->create_offscreen_bitmap.deleteList);\n\tdeleteList->sIndices = 64;\n\tdeleteList->indices = calloc(deleteList->sIndices, 2);\n\n\tif (!deleteList->indices)\n\t\tgoto fail;\n\n\tdeleteList->cIndices = 0;\n\tupdate->SuppressOutput = update_send_suppress_output;\n\tupdate->initialState = TRUE;\n\tupdate->autoCalculateBitmapData = TRUE;\n\tupdate->queue = MessageQueue_New(&cb);\n\n\tif (!update->queue)\n\t\tgoto fail;\n\n\treturn update;\nfail:\n\tupdate_free(update);\n\treturn NULL;\n}\n\nvoid update_free(rdpUpdate* update)\n{\n\tif (update != NULL)\n\t{\n\t\tOFFSCREEN_DELETE_LIST* deleteList = &(update->altsec->create_offscreen_bitmap.deleteList);\n\n\t\tif (deleteList)\n\t\t\tfree(deleteList->indices);\n\n\t\tfree(update->pointer);\n\n\t\tif (update->primary)\n\t\t{\n\t\t\tfree(update->primary->polyline.points);\n\t\t\tfree(update->primary->polygon_sc.points);\n\t\t\tfree(update->primary->fast_glyph.glyphData.aj);\n\t\t\tfree(update->primary);\n\t\t}\n\n\t\tfree(update->secondary);\n\t\tfree(update->altsec);\n\n\t\tif (update->window)\n\t\t{\n\t\t\tfree(update->window);\n\t\t}\n\n\t\tMessageQueue_Free(update->queue);\n\t\tDeleteCriticalSection(&update->mux);\n\t\tfree(update);\n\t}\n}\n\nBOOL update_begin_paint(rdpUpdate* update)\n{\n\tif (!update)\n\t\treturn FALSE;\n\n\tEnterCriticalSection(&update->mux);\n\n\tif (!update->BeginPaint)\n\t\treturn TRUE;\n\n\treturn update->BeginPaint(update->context);\n}\n\nBOOL update_end_paint(rdpUpdate* update)\n{\n\tBOOL rc = FALSE;\n\n\tif (!update)\n\t\treturn FALSE;\n\n\tif (update->EndPaint)\n\t\trc = update->EndPaint(update->context);\n\n\tLeaveCriticalSection(&update->mux);\n\treturn rc;\n}\n"], "filenames": ["libfreerdp/core/orders.c", "libfreerdp/core/orders.h", "libfreerdp/core/update.c"], "buggy_code_start_loc": [46, 192, 1090], "buggy_code_end_loc": [3268, 193, 1109], "fixing_code_start_loc": [46, 192, 1090], "fixing_code_end_loc": [3311, 193, 1109], "type": "CWE-125", "message": "In FreeRDP before version 2.1.2, an out of bound reads occurs resulting in accessing a memory location that is outside of the boundaries of the static array PRIMARY_DRAWING_ORDER_FIELD_BYTES. This is fixed in version 2.1.2.", "other": {"cve": {"id": "CVE-2020-11095", "sourceIdentifier": "security-advisories@github.com", "published": "2020-06-22T22:15:11.913", "lastModified": "2022-07-19T11:43:49.190", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In FreeRDP before version 2.1.2, an out of bound reads occurs resulting in accessing a memory location that is outside of the boundaries of the static array PRIMARY_DRAWING_ORDER_FIELD_BYTES. This is fixed in version 2.1.2."}, {"lang": "es", "value": "En FreeRDP versiones anteriores a 2.1.2, se producen lecturas fuera de l\u00edmite que resultan en el acceso a una ubicaci\u00f3n de memoria que est\u00e1 fuera de l\u00edmites de la matriz est\u00e1tica de PRIMARY_DRAWING_ORDER_FIELD_BYTES. Esto es corregido en la versi\u00f3n 2.1.2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.2", "matchCriteriaId": "DDAC8E89-8F23-4799-AA42-AD419455D1F6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00080.html", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.freerdp.com/2020/06/22/2_1_2-released", "source": "security-advisories@github.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/commit/733ee3208306b1ea32697b356c0215180fc3f049", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-563r-pvh7-4fw2", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6Y35HBHG2INICLSGCIKNAR7GCXEHQACQ/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XOZLH35OJWIQLM7FYDXAP2EAUBDXE76V/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4481-1/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/733ee3208306b1ea32697b356c0215180fc3f049"}}