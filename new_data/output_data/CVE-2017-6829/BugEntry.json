{"buggy_code": ["/*\n\tAudio File Library\n\tCopyright (C) 2010-2013, Michael Pruett <michael@68k.org>\n\tCopyright (C) 2001, Silicon Graphics, Inc.\n\n\tThis library is free software; you can redistribute it and/or\n\tmodify it under the terms of the GNU Lesser General Public\n\tLicense as published by the Free Software Foundation; either\n\tversion 2.1 of the License, or (at your option) any later version.\n\n\tThis library is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n\tLesser General Public License for more details.\n\n\tYou should have received a copy of the GNU Lesser General Public\n\tLicense along with this library; if not, write to the\n\tFree Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n\tBoston, MA  02110-1301  USA\n*/\n\n/*\n\tThis module implements IMA ADPCM compression.\n*/\n\n#include \"config.h\"\n#include \"IMA.h\"\n\n#include <assert.h>\n\n#include <audiofile.h>\n\n#include \"BlockCodec.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"Track.h\"\n#include \"afinternal.h\"\n#include \"byteorder.h\"\n#include \"util.h\"\n#include \"../pcm.h\"\n\nstruct adpcmState\n{\n\tint previousValue;\t// previous output value\n\tint index;\t\t\t// index into step table\n\n\tadpcmState()\n\t{\n\t\tpreviousValue = 0;\n\t\tindex = 0;\n\t}\n};\n\nclass IMA : public BlockCodec\n{\npublic:\n\tstatic IMA *createDecompress(Track *track, File *fh, bool canSeek,\n\t\tbool headerless, AFframecount *chunkFrames);\n\tstatic IMA *createCompress(Track *track, File *fh, bool canSeek,\n\t\tbool headerless, AFframecount *chunkFrames);\n\n\tvirtual ~IMA();\n\n\tvirtual const char *name() const OVERRIDE\n\t{\n\t\treturn mode() == Compress ?\n\t\t\t\"ima_adpcm_compress\" : \"ima_adpcm_decompress\";\n\t}\n\tvirtual void describe() OVERRIDE;\n\nprivate:\n\tint m_imaType;\n\tadpcmState *m_adpcmState;\n\n\tIMA(Mode, Track *, File *fh, bool canSeek);\n\n\tint decodeBlock(const uint8_t *encoded, int16_t *decoded) OVERRIDE;\n\tint decodeBlockWAVE(const uint8_t *encoded, int16_t *decoded);\n\tint decodeBlockQT(const uint8_t *encoded, int16_t *decoded);\n\n\tint encodeBlock(const int16_t *input, uint8_t *output) OVERRIDE;\n\tint encodeBlockWAVE(const int16_t *input, uint8_t *output);\n\tint encodeBlockQT(const int16_t *input, uint8_t *output);\n};\n\nIMA::IMA(Mode mode, Track *track, File *fh, bool canSeek) :\n\tBlockCodec(mode, track, fh, canSeek),\n\tm_imaType(0)\n{\n\tAUpvlist pv = (AUpvlist) track->f.compressionParams;\n\n\tm_framesPerPacket = track->f.framesPerPacket;\n\tm_bytesPerPacket = track->f.bytesPerPacket;\n\n\tlong l;\n\tif (_af_pv_getlong(pv, _AF_IMA_ADPCM_TYPE, &l))\n\t\tm_imaType = l;\n\n\tm_adpcmState = new adpcmState[track->f.channelCount];\n}\n\nIMA::~IMA()\n{\n\tdelete [] m_adpcmState;\n}\n\nint IMA::decodeBlock(const uint8_t *encoded, int16_t *decoded)\n{\n\tif (m_imaType == _AF_IMA_ADPCM_TYPE_WAVE)\n\t\treturn decodeBlockWAVE(encoded, decoded);\n\telse if (m_imaType == _AF_IMA_ADPCM_TYPE_QT)\n\t\treturn decodeBlockQT(encoded, decoded);\n\treturn 0;\n}\n\nstatic const int8_t indexTable[16] =\n{\n\t-1, -1, -1, -1, 2, 4, 6, 8,\n\t-1, -1, -1, -1, 2, 4, 6, 8,\n};\n\nstatic const int16_t stepTable[89] =\n{\n\t7, 8, 9, 10, 11, 12, 13, 14, 16, 17,\n\t19, 21, 23, 25, 28, 31, 34, 37, 41, 45,\n\t50, 55, 60, 66, 73, 80, 88, 97, 107, 118,\n\t130, 143, 157, 173, 190, 209, 230, 253, 279, 307,\n\t337, 371, 408, 449, 494, 544, 598, 658, 724, 796,\n\t876, 963, 1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066,\n\t2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358,\n\t5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899,\n\t15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767\n};\n\nstatic inline int clamp(int x, int low, int high)\n{\n\tif (x < low) return low;\n\tif (x > high) return high;\n\treturn x;\n}\n\nstatic inline int16_t decodeSample(adpcmState &state, uint8_t code)\n{\n\tint step = stepTable[state.index];\n\n\tint diff = step >> 3;\n\tif (code & 4) diff += step;\n\tif (code & 2) diff += step>>1;\n\tif (code & 1) diff += step>>2;\n\n\tint predictor = state.previousValue;\n\tif (code & 8)\n\t\tpredictor -= diff;\n\telse\n\t\tpredictor += diff;\n\n\tstate.previousValue = clamp(predictor, MIN_INT16, MAX_INT16);\n\tstate.index = clamp(state.index + indexTable[code], 0, 88);\n\treturn state.previousValue;\n}\n\nint IMA::decodeBlockWAVE(const uint8_t *encoded, int16_t *decoded)\n{\n\tint channelCount = m_track->f.channelCount;\n\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\tm_adpcmState[c].previousValue = (encoded[1]<<8) | encoded[0];\n\t\tif (encoded[1] & 0x80)\n\t\t\tm_adpcmState[c].previousValue -= 0x10000;\n\n\t\tm_adpcmState[c].index = encoded[2];\n\n\t\t*decoded++ = m_adpcmState[c].previousValue;\n\n\t\tencoded += 4;\n\t}\n\n\tfor (int n=0; n<m_framesPerPacket - 1; n += 8)\n\t{\n\t\tfor (int c=0; c<channelCount; c++)\n\t\t{\n\t\t\tint16_t *output = decoded + c;\n\t\t\tfor (int s=0; s<4; s++)\n\t\t\t{\n\t\t\t\t*output = decodeSample(m_adpcmState[c], *encoded & 0xf);\n\t\t\t\toutput += channelCount;\n\t\t\t\t*output = decodeSample(m_adpcmState[c], *encoded >> 4);\n\t\t\t\toutput += channelCount;\n\t\t\t\tencoded++;\n\t\t\t}\n\t\t}\n\n\t\tdecoded += channelCount * 8;\n\t}\n\n\treturn m_framesPerPacket * channelCount * sizeof (int16_t);\n}\n\n\nint IMA::decodeBlockQT(const uint8_t *encoded, int16_t *decoded)\n{\n\tint channelCount = m_track->f.channelCount;\n\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\tadpcmState state;\n\t\tint predictor = (encoded[0] << 8) | (encoded[1] & 0x80);\n\t\tif (predictor & 0x8000)\n\t\t\tpredictor -= 0x10000;\n\n\t\tstate.previousValue = clamp(predictor, MIN_INT16, MAX_INT16);\n\t\tstate.index = encoded[1] & 0x7f;\n\t\tencoded += 2;\n\n\t\tfor (int n=0; n<m_framesPerPacket; n+=2)\n\t\t{\n\t\t\tuint8_t e = *encoded;\n\t\t\tdecoded[n*channelCount + c] = decodeSample(state, e & 0xf);\n\t\t\tdecoded[(n+1)*channelCount + c] = decodeSample(state, e >> 4);\n\t\t\tencoded++;\n\t\t}\n\t}\n\n\treturn m_framesPerPacket * channelCount * sizeof (int16_t);\n}\n\nint IMA::encodeBlock(const int16_t *input, uint8_t *output)\n{\n\tif (m_imaType == _AF_IMA_ADPCM_TYPE_WAVE)\n\t\treturn encodeBlockWAVE(input, output);\n\telse if (m_imaType == _AF_IMA_ADPCM_TYPE_QT)\n\t\treturn encodeBlockQT(input, output);\n\treturn 0;\n}\n\nstatic inline uint8_t encodeSample(adpcmState &state, int16_t sample)\n{\n\tint step = stepTable[state.index];\n\tint diff = sample - state.previousValue;\n\tint vpdiff = step >> 3;\n\tuint8_t code = 0;\n\tif (diff < 0)\n\t{\n\t\tcode = 8;\n\t\tdiff = -diff;\n\t}\n\tif (diff >= step)\n\t{\n\t\tcode |= 4;\n\t\tdiff -= step;\n\t\tvpdiff += step;\n\t}\n\tstep >>= 1;\n\tif (diff >= step)\n\t{\n\t\tcode |= 2;\n\t\tdiff -= step;\n\t\tvpdiff += step;\n\t}\n\tstep >>= 1;\n\tif (diff >= step)\n\t{\n\t\tcode |= 1;\n\t\tvpdiff += step;\n\t}\n\n\tif (code & 8)\n\t\tvpdiff = -vpdiff;\n\tstate.previousValue = clamp(state.previousValue + vpdiff,\n\t\tMIN_INT16, MAX_INT16);\n\n\tstate.index = clamp(state.index + indexTable[code], 0, 88);\n\treturn code & 0xf;\n}\n\nint IMA::encodeBlockWAVE(const int16_t *input, uint8_t *output)\n{\n\tint channelCount = m_track->f.channelCount;\n\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\toutput[0] = m_adpcmState[c].previousValue & 0xff;\n\t\toutput[1] = m_adpcmState[c].previousValue >> 8;\n\t\toutput[2] = m_adpcmState[c].index;\n\t\toutput[3] = 0;\n\n\t\toutput += 4;\n\t}\n\n\tfor (int n=0; n<m_framesPerPacket - 1; n += 8)\n\t{\n\t\tfor (int c=0; c<channelCount; c++)\n\t\t{\n\t\t\tconst int16_t *currentInput = input + c;\n\t\t\tfor (int s=0; s<4; s++)\n\t\t\t{\n\t\t\t\tuint8_t encodedValue = encodeSample(m_adpcmState[c], *currentInput);\n\t\t\t\tcurrentInput += channelCount;\n\t\t\t\tencodedValue |= encodeSample(m_adpcmState[c], *currentInput) << 4;\n\t\t\t\tcurrentInput += channelCount;\n\t\t\t\t*output++ = encodedValue;\n\t\t\t}\n\t\t}\n\n\t\tinput += channelCount * 8;\n\t}\n\n\treturn m_bytesPerPacket;\n}\n\nint IMA::encodeBlockQT(const int16_t *input, uint8_t *output)\n{\n\tint channelCount = m_track->f.channelCount;\n\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\tadpcmState state = m_adpcmState[c];\n\n\t\tstate.previousValue &= ~0x7f;\n\n\t\toutput[0] = (state.previousValue >> 8) & 0xff;\n\t\toutput[1] = (state.previousValue & 0x80) | (state.index & 0x7f);\n\t\toutput += 2;\n\n\t\tfor (int n=0; n<m_framesPerPacket; n+=2)\n\t\t{\n\t\t\tuint8_t encoded = encodeSample(state, input[n*channelCount + c]);\n\t\t\tencoded |= encodeSample(state, input[(n+1)*channelCount + c]) << 4;\n\t\t\t*output++ = encoded;\n\t\t}\n\n\t\tm_adpcmState[c] = state;\n\t}\n\n\treturn m_bytesPerPacket;\n}\n\nbool _af_ima_adpcm_format_ok (AudioFormat *f)\n{\n\tif (f->channelCount != 1 && f->channelCount != 2)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"IMA ADPCM compression requires 1 or 2 channels\");\n\t\treturn false;\n\t}\n\n\tif (f->sampleFormat != AF_SAMPFMT_TWOSCOMP || f->sampleWidth != 16)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"IMA ADPCM compression requires 16-bit signed integer format\");\n\t\treturn false;\n\t}\n\n\tif (f->byteOrder != _AF_BYTEORDER_NATIVE)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"IMA ADPCM compression requires native byte order\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid IMA::describe()\n{\n\tm_outChunk->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\tm_outChunk->f.compressionType = AF_COMPRESSION_NONE;\n\tm_outChunk->f.compressionParams = AU_NULL_PVLIST;\n}\n\nIMA *IMA::createDecompress(Track *track, File *fh, bool canSeek,\n\tbool headerless, AFframecount *chunkFrames)\n{\n\tassert(fh->tell() == track->fpos_first_frame);\n\n\tIMA *ima = new IMA(Decompress, track, fh, canSeek);\n\n\tif (!ima->m_imaType)\n\t{\n\t\t_af_error(AF_BAD_CODEC_CONFIG, \"IMA type not set\");\n\t\tdelete ima;\n\t\treturn NULL;\n\t}\n\n\t*chunkFrames = ima->m_framesPerPacket;\n\treturn ima;\n}\n\nIMA *IMA::createCompress(Track *track, File *fh, bool canSeek,\n\tbool headerless, AFframecount *chunkFrames)\n{\n\tassert(fh->tell() == track->fpos_first_frame);\n\n\tIMA *ima = new IMA(Compress, track, fh, canSeek);\n\n\tif (!ima->m_imaType)\n\t{\n\t\t_af_error(AF_BAD_CODEC_CONFIG, \"IMA type not set\");\n\t\tdelete ima;\n\t\treturn NULL;\n\t}\n\n\t*chunkFrames = ima->m_framesPerPacket;\n\treturn ima;\n}\n\nFileModule *_af_ima_adpcm_init_decompress(Track *track, File *fh,\n\tbool canSeek, bool headerless, AFframecount *chunkFrames)\n{\n\treturn IMA::createDecompress(track, fh, canSeek, headerless, chunkFrames);\n}\n\nFileModule *_af_ima_adpcm_init_compress(Track *track, File *fh,\n\tbool canSeek, bool headerless, AFframecount *chunkFrames)\n{\n\treturn IMA::createCompress(track, fh, canSeek, headerless, chunkFrames);\n}\n"], "fixing_code": ["/*\n\tAudio File Library\n\tCopyright (C) 2010-2013, Michael Pruett <michael@68k.org>\n\tCopyright (C) 2001, Silicon Graphics, Inc.\n\n\tThis library is free software; you can redistribute it and/or\n\tmodify it under the terms of the GNU Lesser General Public\n\tLicense as published by the Free Software Foundation; either\n\tversion 2.1 of the License, or (at your option) any later version.\n\n\tThis library is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n\tLesser General Public License for more details.\n\n\tYou should have received a copy of the GNU Lesser General Public\n\tLicense along with this library; if not, write to the\n\tFree Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n\tBoston, MA  02110-1301  USA\n*/\n\n/*\n\tThis module implements IMA ADPCM compression.\n*/\n\n#include \"config.h\"\n#include \"IMA.h\"\n\n#include <assert.h>\n\n#include <audiofile.h>\n\n#include \"BlockCodec.h\"\n#include \"Compiler.h\"\n#include \"File.h\"\n#include \"Track.h\"\n#include \"afinternal.h\"\n#include \"byteorder.h\"\n#include \"util.h\"\n#include \"../pcm.h\"\n\nstruct adpcmState\n{\n\tint previousValue;\t// previous output value\n\tint index;\t\t\t// index into step table\n\n\tadpcmState()\n\t{\n\t\tpreviousValue = 0;\n\t\tindex = 0;\n\t}\n};\n\nclass IMA : public BlockCodec\n{\npublic:\n\tstatic IMA *createDecompress(Track *track, File *fh, bool canSeek,\n\t\tbool headerless, AFframecount *chunkFrames);\n\tstatic IMA *createCompress(Track *track, File *fh, bool canSeek,\n\t\tbool headerless, AFframecount *chunkFrames);\n\n\tvirtual ~IMA();\n\n\tvirtual const char *name() const OVERRIDE\n\t{\n\t\treturn mode() == Compress ?\n\t\t\t\"ima_adpcm_compress\" : \"ima_adpcm_decompress\";\n\t}\n\tvirtual void describe() OVERRIDE;\n\nprivate:\n\tint m_imaType;\n\tadpcmState *m_adpcmState;\n\n\tIMA(Mode, Track *, File *fh, bool canSeek);\n\n\tint decodeBlock(const uint8_t *encoded, int16_t *decoded) OVERRIDE;\n\tint decodeBlockWAVE(const uint8_t *encoded, int16_t *decoded);\n\tint decodeBlockQT(const uint8_t *encoded, int16_t *decoded);\n\n\tint encodeBlock(const int16_t *input, uint8_t *output) OVERRIDE;\n\tint encodeBlockWAVE(const int16_t *input, uint8_t *output);\n\tint encodeBlockQT(const int16_t *input, uint8_t *output);\n};\n\nIMA::IMA(Mode mode, Track *track, File *fh, bool canSeek) :\n\tBlockCodec(mode, track, fh, canSeek),\n\tm_imaType(0)\n{\n\tAUpvlist pv = (AUpvlist) track->f.compressionParams;\n\n\tm_framesPerPacket = track->f.framesPerPacket;\n\tm_bytesPerPacket = track->f.bytesPerPacket;\n\n\tlong l;\n\tif (_af_pv_getlong(pv, _AF_IMA_ADPCM_TYPE, &l))\n\t\tm_imaType = l;\n\n\tm_adpcmState = new adpcmState[track->f.channelCount];\n}\n\nIMA::~IMA()\n{\n\tdelete [] m_adpcmState;\n}\n\nint IMA::decodeBlock(const uint8_t *encoded, int16_t *decoded)\n{\n\tif (m_imaType == _AF_IMA_ADPCM_TYPE_WAVE)\n\t\treturn decodeBlockWAVE(encoded, decoded);\n\telse if (m_imaType == _AF_IMA_ADPCM_TYPE_QT)\n\t\treturn decodeBlockQT(encoded, decoded);\n\treturn 0;\n}\n\nstatic const int8_t indexTable[16] =\n{\n\t-1, -1, -1, -1, 2, 4, 6, 8,\n\t-1, -1, -1, -1, 2, 4, 6, 8,\n};\n\nstatic const int16_t stepTable[89] =\n{\n\t7, 8, 9, 10, 11, 12, 13, 14, 16, 17,\n\t19, 21, 23, 25, 28, 31, 34, 37, 41, 45,\n\t50, 55, 60, 66, 73, 80, 88, 97, 107, 118,\n\t130, 143, 157, 173, 190, 209, 230, 253, 279, 307,\n\t337, 371, 408, 449, 494, 544, 598, 658, 724, 796,\n\t876, 963, 1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066,\n\t2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358,\n\t5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899,\n\t15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767\n};\n\nstatic inline int clamp(int x, int low, int high)\n{\n\tif (x < low) return low;\n\tif (x > high) return high;\n\treturn x;\n}\n\nstatic inline int16_t decodeSample(adpcmState &state, uint8_t code)\n{\n\tint step = stepTable[state.index];\n\n\tint diff = step >> 3;\n\tif (code & 4) diff += step;\n\tif (code & 2) diff += step>>1;\n\tif (code & 1) diff += step>>2;\n\n\tint predictor = state.previousValue;\n\tif (code & 8)\n\t\tpredictor -= diff;\n\telse\n\t\tpredictor += diff;\n\n\tstate.previousValue = clamp(predictor, MIN_INT16, MAX_INT16);\n\tstate.index = clamp(state.index + indexTable[code], 0, 88);\n\treturn state.previousValue;\n}\n\nint IMA::decodeBlockWAVE(const uint8_t *encoded, int16_t *decoded)\n{\n\tint channelCount = m_track->f.channelCount;\n\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\tm_adpcmState[c].previousValue = (encoded[1]<<8) | encoded[0];\n\t\tif (encoded[1] & 0x80)\n\t\t\tm_adpcmState[c].previousValue -= 0x10000;\n\n\t\tm_adpcmState[c].index = clamp(encoded[2], 0, 88);\n\n\t\t*decoded++ = m_adpcmState[c].previousValue;\n\n\t\tencoded += 4;\n\t}\n\n\tfor (int n=0; n<m_framesPerPacket - 1; n += 8)\n\t{\n\t\tfor (int c=0; c<channelCount; c++)\n\t\t{\n\t\t\tint16_t *output = decoded + c;\n\t\t\tfor (int s=0; s<4; s++)\n\t\t\t{\n\t\t\t\t*output = decodeSample(m_adpcmState[c], *encoded & 0xf);\n\t\t\t\toutput += channelCount;\n\t\t\t\t*output = decodeSample(m_adpcmState[c], *encoded >> 4);\n\t\t\t\toutput += channelCount;\n\t\t\t\tencoded++;\n\t\t\t}\n\t\t}\n\n\t\tdecoded += channelCount * 8;\n\t}\n\n\treturn m_framesPerPacket * channelCount * sizeof (int16_t);\n}\n\n\nint IMA::decodeBlockQT(const uint8_t *encoded, int16_t *decoded)\n{\n\tint channelCount = m_track->f.channelCount;\n\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\tadpcmState state;\n\t\tint predictor = (encoded[0] << 8) | (encoded[1] & 0x80);\n\t\tif (predictor & 0x8000)\n\t\t\tpredictor -= 0x10000;\n\n\t\tstate.previousValue = clamp(predictor, MIN_INT16, MAX_INT16);\n\t\tstate.index = clamp(encoded[1] & 0x7f, 0, 88);\n\t\tencoded += 2;\n\n\t\tfor (int n=0; n<m_framesPerPacket; n+=2)\n\t\t{\n\t\t\tuint8_t e = *encoded;\n\t\t\tdecoded[n*channelCount + c] = decodeSample(state, e & 0xf);\n\t\t\tdecoded[(n+1)*channelCount + c] = decodeSample(state, e >> 4);\n\t\t\tencoded++;\n\t\t}\n\t}\n\n\treturn m_framesPerPacket * channelCount * sizeof (int16_t);\n}\n\nint IMA::encodeBlock(const int16_t *input, uint8_t *output)\n{\n\tif (m_imaType == _AF_IMA_ADPCM_TYPE_WAVE)\n\t\treturn encodeBlockWAVE(input, output);\n\telse if (m_imaType == _AF_IMA_ADPCM_TYPE_QT)\n\t\treturn encodeBlockQT(input, output);\n\treturn 0;\n}\n\nstatic inline uint8_t encodeSample(adpcmState &state, int16_t sample)\n{\n\tint step = stepTable[state.index];\n\tint diff = sample - state.previousValue;\n\tint vpdiff = step >> 3;\n\tuint8_t code = 0;\n\tif (diff < 0)\n\t{\n\t\tcode = 8;\n\t\tdiff = -diff;\n\t}\n\tif (diff >= step)\n\t{\n\t\tcode |= 4;\n\t\tdiff -= step;\n\t\tvpdiff += step;\n\t}\n\tstep >>= 1;\n\tif (diff >= step)\n\t{\n\t\tcode |= 2;\n\t\tdiff -= step;\n\t\tvpdiff += step;\n\t}\n\tstep >>= 1;\n\tif (diff >= step)\n\t{\n\t\tcode |= 1;\n\t\tvpdiff += step;\n\t}\n\n\tif (code & 8)\n\t\tvpdiff = -vpdiff;\n\tstate.previousValue = clamp(state.previousValue + vpdiff,\n\t\tMIN_INT16, MAX_INT16);\n\n\tstate.index = clamp(state.index + indexTable[code], 0, 88);\n\treturn code & 0xf;\n}\n\nint IMA::encodeBlockWAVE(const int16_t *input, uint8_t *output)\n{\n\tint channelCount = m_track->f.channelCount;\n\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\toutput[0] = m_adpcmState[c].previousValue & 0xff;\n\t\toutput[1] = m_adpcmState[c].previousValue >> 8;\n\t\toutput[2] = m_adpcmState[c].index;\n\t\toutput[3] = 0;\n\n\t\toutput += 4;\n\t}\n\n\tfor (int n=0; n<m_framesPerPacket - 1; n += 8)\n\t{\n\t\tfor (int c=0; c<channelCount; c++)\n\t\t{\n\t\t\tconst int16_t *currentInput = input + c;\n\t\t\tfor (int s=0; s<4; s++)\n\t\t\t{\n\t\t\t\tuint8_t encodedValue = encodeSample(m_adpcmState[c], *currentInput);\n\t\t\t\tcurrentInput += channelCount;\n\t\t\t\tencodedValue |= encodeSample(m_adpcmState[c], *currentInput) << 4;\n\t\t\t\tcurrentInput += channelCount;\n\t\t\t\t*output++ = encodedValue;\n\t\t\t}\n\t\t}\n\n\t\tinput += channelCount * 8;\n\t}\n\n\treturn m_bytesPerPacket;\n}\n\nint IMA::encodeBlockQT(const int16_t *input, uint8_t *output)\n{\n\tint channelCount = m_track->f.channelCount;\n\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\tadpcmState state = m_adpcmState[c];\n\n\t\tstate.previousValue &= ~0x7f;\n\n\t\toutput[0] = (state.previousValue >> 8) & 0xff;\n\t\toutput[1] = (state.previousValue & 0x80) | (state.index & 0x7f);\n\t\toutput += 2;\n\n\t\tfor (int n=0; n<m_framesPerPacket; n+=2)\n\t\t{\n\t\t\tuint8_t encoded = encodeSample(state, input[n*channelCount + c]);\n\t\t\tencoded |= encodeSample(state, input[(n+1)*channelCount + c]) << 4;\n\t\t\t*output++ = encoded;\n\t\t}\n\n\t\tm_adpcmState[c] = state;\n\t}\n\n\treturn m_bytesPerPacket;\n}\n\nbool _af_ima_adpcm_format_ok (AudioFormat *f)\n{\n\tif (f->channelCount != 1 && f->channelCount != 2)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"IMA ADPCM compression requires 1 or 2 channels\");\n\t\treturn false;\n\t}\n\n\tif (f->sampleFormat != AF_SAMPFMT_TWOSCOMP || f->sampleWidth != 16)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"IMA ADPCM compression requires 16-bit signed integer format\");\n\t\treturn false;\n\t}\n\n\tif (f->byteOrder != _AF_BYTEORDER_NATIVE)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"IMA ADPCM compression requires native byte order\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid IMA::describe()\n{\n\tm_outChunk->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\tm_outChunk->f.compressionType = AF_COMPRESSION_NONE;\n\tm_outChunk->f.compressionParams = AU_NULL_PVLIST;\n}\n\nIMA *IMA::createDecompress(Track *track, File *fh, bool canSeek,\n\tbool headerless, AFframecount *chunkFrames)\n{\n\tassert(fh->tell() == track->fpos_first_frame);\n\n\tIMA *ima = new IMA(Decompress, track, fh, canSeek);\n\n\tif (!ima->m_imaType)\n\t{\n\t\t_af_error(AF_BAD_CODEC_CONFIG, \"IMA type not set\");\n\t\tdelete ima;\n\t\treturn NULL;\n\t}\n\n\t*chunkFrames = ima->m_framesPerPacket;\n\treturn ima;\n}\n\nIMA *IMA::createCompress(Track *track, File *fh, bool canSeek,\n\tbool headerless, AFframecount *chunkFrames)\n{\n\tassert(fh->tell() == track->fpos_first_frame);\n\n\tIMA *ima = new IMA(Compress, track, fh, canSeek);\n\n\tif (!ima->m_imaType)\n\t{\n\t\t_af_error(AF_BAD_CODEC_CONFIG, \"IMA type not set\");\n\t\tdelete ima;\n\t\treturn NULL;\n\t}\n\n\t*chunkFrames = ima->m_framesPerPacket;\n\treturn ima;\n}\n\nFileModule *_af_ima_adpcm_init_decompress(Track *track, File *fh,\n\tbool canSeek, bool headerless, AFframecount *chunkFrames)\n{\n\treturn IMA::createDecompress(track, fh, canSeek, headerless, chunkFrames);\n}\n\nFileModule *_af_ima_adpcm_init_compress(Track *track, File *fh,\n\tbool canSeek, bool headerless, AFframecount *chunkFrames)\n{\n\treturn IMA::createCompress(track, fh, canSeek, headerless, chunkFrames);\n}\n"], "filenames": ["libaudiofile/modules/IMA.cpp"], "buggy_code_start_loc": [172], "buggy_code_end_loc": [214], "fixing_code_start_loc": [172], "fixing_code_end_loc": [214], "type": "CWE-125", "message": "The decodeSample function in IMA.cpp in Audio File Library (aka audiofile) 0.3.6 allows remote attackers to cause a denial of service (crash) via a crafted file.", "other": {"cve": {"id": "CVE-2017-6829", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-20T16:59:02.627", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The decodeSample function in IMA.cpp in Audio File Library (aka audiofile) 0.3.6 allows remote attackers to cause a denial of service (crash) via a crafted file."}, {"lang": "es", "value": "La funci\u00f3n decodeSample en IMA.cpp en Audio File Library (tambi\u00e9n conocido como audiofile) 0.3.6 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (ca\u00edda) a trav\u00e9s de un archivo manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:audiofile:audiofile:0.3.6:*:*:*:*:*:*:*", "matchCriteriaId": "3C7E74B2-432B-4CCD-873F-AA7E012D8C7F"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3814", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2017/03/13/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/97189", "source": "cve@mitre.org"}, {"url": "https://blogs.gentoo.org/ago/2017/02/20/audiofile-global-buffer-overflow-in-decodesample-ima-cpp/", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/antlarr/audiofile/commit/25eb00ce913452c2e614548d7df93070bf0d066f", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/mpruett/audiofile/issues/33", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/antlarr/audiofile/commit/25eb00ce913452c2e614548d7df93070bf0d066f"}}