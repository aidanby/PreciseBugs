{"buggy_code": ["2020-10-28: David Anderson\n    * dwarf_ranges.c: Altered lines longer than libdwarf\n      standard.\n2020-10-27: David Anderson\n    * dwarf_generic_init.c: Now checks for a null PATH\n      passed to dwarf_init_path() or dwarf_init_path_dl()\n      and returns error.\n2020-10-20: David Anderson\n    * libdwarf_version.h: updated version string\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n      dwarf_names_new.h: regenerated with new version string.\n    * crc32.c: Computing from first principles.  LGPL 2.1\n2020-10-19: David Anderson\n    * dwarf_line_table_reader_common.h: Everywhere ptr - ptr\n      generates an unnamed ptrdiff_t is called out by\n      a short comment.\n2020-10-19: David Anderson\n    * crc32.c,dwarf_debuglink.c,dwarf_die_deliv.c,dwarf_line.c,\n\t  dwarf_line.h,dwarf_line_table_reader_common.h,dwarf_query.c,\n\t  dwarf_str_offsets.c: Fixed indents and removed\n      trailing whitespace.\n2020-10-19: David Anderson\n    * crc32.c: Revised line lengths to under\n      20 characters for a better appearance.\n      No change in wording.\n\t* pro_frame.c,pro_funcs.c: Removed a blank line\n      before the copyright text for a better appearance.\n2020-10-19: David Anderson\n    * dwarf_arange.h,dwarf_base_types.h,dwarf_die_deliv.h,\n\t  dwarf_dsc.h,dwarf_elf_access.h,dwarf_errmsg_list.h,\n\t  dwarf_error.h,dwarf_frame.h,dwarf_funcs.h,dwarf_gdbindex.h,\n\t  dwarf_global.h,dwarf_harmless.h,dwarf_line.h,dwarf_macro.h,\n\t  dwarf_macro5.h,dwarf_reloc_386.h,dwarf_reloc_arm.h,\n\t  dwarf_reloc_mips.h,dwarf_reloc_ppc.h,dwarf_reloc_ppc64.h,\n\t  dwarf_reloc_x86_64.h,dwarf_tied_decls.h,dwarf_types.h,\n\t  dwarf_util.h,dwarf_vars.h,dwarf_weaks.h,dwarf_xu_index.h,\n\t  libdwarfdefs.h,malloc_check.h,pro_alloc.h,pro_arange.h,\n\t  pro_die.h,pro_encode_nm.h,pro_error.h,pro_expr.h,\n\t  pro_frame.h,pro_incl.h,pro_macinfo.h,pro_reloc.h,\n\t  pro_reloc_stream.h,pro_reloc_symbolic.h,pro_section.h,\n\t  pro_types.h,pro_util.h: License text reformatted\n      to fit libdwarf line lengths. No change in terms.\n2020-10-19: David Anderson\n    *  dwarf_debuglink.c,dwarf_die_deliv.c,dwarf_query.c,\n\t   dwarf_str_offsets.c,dwarf_util.c: These no longer\n       explicitly use ptrdiff_t. Only non-negative pointer\n       differences are converted to unsigned. The other\n       side of a compare is given an appropriate constant unsigned\n       value that will cause an immediate error (this side\n       represents an astonishing and impossible situation).\n    * crc32.c,dwarf_alloc.c,dwarf_crc32.c,dwarf_debuglink.c,\n      dwarf_die_deliv.c,dwarf_elf_access.c,dwarf_elf_load_headers.c,\n      dwarf_elfread.c,dwarf_error.c dwarf_generic_init.c,\n      dwarf_init_finish.c,dwarf_machoread.c,dwarf_object_detector.c,\n      dwarf_object_read_common.c,dwarf_original_elf_init.c,\n      dwarf_peread.c,dwarf_query.c,dwarf_str_offsets.c,\n      dwarf_util.c,pro_error.c,test_linkedtopath.c: Consistent\n      use of HAVE_SYS_STATS_H throughout.\n2020-10-17: David Anderson\n    * libdwarf_version.h: updated version string\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n      dwarf_names_new.h: regenerated with new version string.\n2020-10-15: David Anderson\n    * dwarf_line.c:Set up the default registers correctly\n      for DWARF5 as well as earlier versions.\n    * dwarf_line.h: update a comment.\n    * dwarf_line_table_reader_common.c: Using ptrdiff_t\n      is completely unnecessary. So not using now.\n      Removing with #if 0 some lines of checking code\n      which are now up a few lines in a corrected\n      version of earlier checking.\n    * libdwarf2.1.pdf: Regenerated 3.15. Forgot\n      to do it earlier.\n2020-10-13: David Anderson\n    * dwarf_debuglink.c: Now _dwarf_pathjoinl works\n      for Windows too (see HAVE_WINDOWS_PATH) and\n      transforms all backslash to /.  This\n      has always been the behavior, it just vanished\n      for a couple days.\n    * dwarf_line_table_reader_common.h: Removed a trailing blank.\n    * dwarf_macro5.c: Now correctly handles the null byte\n      at the end of a list of macro operands. Added\n      macro CHECKNULLCONTEXT to avoid lots of 8 line\n      sequences just checking basic call sanity.\n      Gave the structure sentinal a name: MC_SENTINAL\n      (only exists in this one source file).\n    * dwarf_macro5.h: Added mc_section_size so offset\n      insanity is caught.  Added comments about\n      Dwarf_Macro_Operator_s for clarity.\n    * libdwarf.h;.in: Added comment on the DWARF 5\n      macro operands table.\n    * libdwarf2.1.mm: Rev 3.15 Added a comment in examplep5\n      on dwarf_get_macro_op() about the DWARF5\n      macro operator value 0, and\n      amplified the function wording on this point..\n    * libdwarf2.1.pdf: Rev 3.15. Regenerated.\n      .\n2020-10-12: David Anderson\n    * dwarf_alloc.c: Creation of Dwarf_Error_ with\n      null dbg is now gracefully handled.\n    * dwarf_debuglink.c: Now handles\n      HAVE_WINDOWS_PATH. Needed additional #include\n      and create_fullest_file_path() now uses dwarfstsring.\n    * dwarf_line.h: Trailing whitespace.\n    * dwarf_line_table_reader_common.h: Shorten a couple lines\n      to fit libdwarf standards.\n    * dwarf_object_detector.c: Free debuglinkfull path\n      where appropriate. Ensure fd's (other than -1)\n      get closed where appropriate.\n    * dwarf_object_detector.h: Removed #if 0 lines.\n    * dwarf_peread.c: Assures fd which is not -1\n      gets closed.\n    * dwarf_print_lines.c:  Now uses \n      dwarfstring_constructor_static() so in nearly all\n      cases no malloc/free needed. Adds DWARF5\n      specific support for indexing into includes.\n    * libdwarf.h.in: Corrected comments about what to\n      free after calling dwarf_gnu_debuglink().\n    * generated_libdwarf.h.in: regenerated.\n    * libdwarf2.1.mm: Version 3.14. Correctet\n      description of dwarf_gnu_debuglink().  \n    * libdwarf2.1.pdf: Version 3.14. Regenerated.\n    * testdebuglinksh: Remove trailing whitespace.\n2020-10-11: David Anderson\n    * dwarf_object_detector.h: Deleted #if 0 prototype.\n    * testdebuglink.sh: Removed a trailing blank.\n2020-10-11: David Anderson\n\t* libdwarf_version.h: updated version string\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n\t  dwarf_names_new.h: regenerated with new version string.\n2020-10-11: David Anderson\n    * CMakeLists.txt: Added crc32.c, a new source file.\n    * Makefile.am: Same addition.\n    * Makefile.in: Regenerated.\n    * crc32.c: The crc needed to interoperate with GNU\n      debuglink.\n    * dwarf_alloc.c: Clarifying comment and removing\n      old unnecessary () around return values.\n    * dwarf_crc32.c: Removing crc from here, it was\n      the wrong crc32! Modified crc calls to match\n      the needs of the correct crc calculation. Ensured\n      a local malloc always gets freed.\n    * dwarf_debuglink.c: Added short comments.\n    * dwarf_errmsg_list.h: New error DW_DLE_DEBUGLINK_PATH_SHORT.\n    * dwarf_generic_init.c.: Updated to work properly\n      with debuglink and dSYM.\n    * dwarf_incl.h: Reformatted copyright for shorter\n      lines per libdwarf formatting, no change in content.\n    * dwarf_init_finish.c: Added comment. Removed\n      a pointless test for error (error not \n      not set, guaranteed) in dwarf_object_finish().\n    * dwarf_object_detector.c: Implemented support\n      for debuglink, significant changes involved.\n    * dwarf_object_detector.h: Comment change\n    * dwarf_opaque.h: Updated a comment and\n      declared the internal function _dwarf_crc32();\n    * libdwarf.h.in:  Functions added for debuglink\n      and a mistake corrected (now comment the arg names\n      to avoid macro disaster) in several functions.\n      New error DW_DLE_DEBUGLINK_PATH_SHORT.\n      New function dwarf_object_detector_path_b()\n      lets one supply global paths for debuglink and\n      get back a (new!) value, one of \n      DW_PATHSOURCE_basic, DW_PATHSOURCE_dsym,or\n      DW_PATHSOURCE_debuglink so callers know what\n      the path source by type.\n    * generated_libdwarf.h.in: Regenerated.\n    * libdwarf2.1.mm: Clarified lifetimes of several\n      arguments of debuglink-related functions. Revision 3.13.\n    * libdwarf2.1.pdf: Regenerated, version 3.13.\n2020-10-05: David Anderson\n    * libdwarf.h.in: Removed DW_DLC_NO_FOLLOW_DEBUGLINK\n      as it is never needed and was never used or\n      documented (it's only been there for a handful\n      of days).  Updated commentary.\n    * generated_libdwar.h.in: Regenerated.\n    * libdwarf2.1.mm: Rev 3.12. Beginning documentation\n      of GNU debuglink support.\n    * libdwarf2.1.pdf: Regenerated as 3.12.\n2020-10-02: David Anderson\n    * dwarf_crc32.c,dwarf_fission_to_cu.c,dwarf_macro5.c,\n\t  dwarf_opaque.h,libdwarf.h.in,test_linkedtopath.c,\n\t  test_linkedtopath.c: Removed whitespace and\n      tabs and make indents dwarf-standard.\n    * COPYING: Corrected the references to the BSD copyright\n      to use \"two-clause BSD license\".\n2020-10-02: David Anderson\n    * dwarf_generic_init.c: Implements the new\n      dwarf_init_path_dl() which allows passing debuglink\n      global paths (if one desires to). Global paths not\n      used here yet.\n    * libdwarf.h.in: Added prototype dwarf_init_path_dl()\n      but it is not yet used. Relevant commentary updated.\n    * generated_libdwarf.h.in: regenerated\n2020-10-01: David Anderson\n    * libdwarf2.1.mm: Revision 3.11. Added new debuglink\n      function dwarf_crc32().\n    * libdwarf2.1.pdf: Revision 3.11. Regenerated.\n2020-10-01: David Anderson\n    * dwarf_crc32.c: Refined the #includes so they work\n      with cmake too.\n    * dwarf_debuglink.c,dwarf_object_detector.c,\n      dwarf_peread.c: Refined the #includes to work\n      in more general circumstances.\n2020-10-01: David Anderson\n    * libdwarf.h.in: Added DW_DLC_NO_FOLLOW_DEBUGLINK\n      but it is not yet used.\n    * generated_libdwarf.h.in: regenerated\n2020-09-30: David Anderson\n    * CMakeLists.txt,Makefile.am: Added dwarf_crc32.c\n    * Makefile.am: Regenerated.\n    * dwarf_crc32.c: So libdwarf can interoperate with GNU\n      debuglink to locate separate debug object files.\n    * dwarf_debuglink.c: Added {} one place. No real change.\n    * libdwarf.h.in: New interfaces for crc32.\n    * generated_libdwarf.h.in: Regenerated\n2020-09-28: David Anderson\n    * libdwarf.h.in: Rearranged the DW_DLC_* values\n      for clarity and added commentary on the main\n      point (the 'access' argument to dwarf init\n      functions for the consumer/reader calls\n      should be zero).  This is not a change.\n    * generated_libdwarf.h.in: Documented\n      the longstanding handling of that same\n      argument to consumer/reader functions.\n    * libdwarf2.1.mm: Version 3.10. Documenting\n      that same thing.\n    * libdwarf2.1.pdf: Regenerated as version 3.10.\n2020-09-26: David Anderson\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n\t  dwarf_names_new.h,libdwarf_version.h: Updated  version\n      string, regenerated files that reference it.\n2020-09-26: David Anderson\n    * baseline.ltp: new test baseline for debuglink.\n\t* test_linkedtopath.c: Now with better coverage\n      of the paths in tbe debuglink code, we\n      add a getcwd here to return a test cwd\n      of /exam/ple so the output of debuglink\n      does not depend on the real build\n      directory location.\n2020-09-25: David Anderson\n\t* dwarf_debuglink.c: Corrected and clarified.\n2020-09-22: David Anderson\n    * CMakeLists.txt, Makefile.am: Added new file \n      dwarf_fission_to_cu.c.\n    * Makefile.in: Regenerated.\n    * dwarf_die_deliv.c: Renamed _dwarf_find_offsets_via_fission\n      to be _dwarf_find_all_offsets_via_fission().\n      Added status check following the call to it.\n    * dwarf_fission_to_cu.c: Now the above function\n      and supporting functions are in this source file to\n      deal with DW_SECT_LOCLISTS,DW_SECT_STR_OFFSETS,\n      DW_SECT_MACRO, DW_SECT_RNGLISTS.\n    * dwarf_loc.h: Updated prototypes for these\n      functions.\n    * dwarf_loclists.h: Now deleted. It's long been\n      unused.\n    * dwarf_loclists.c: Renamed internal_read_header as\n      _dwarf_internal_read_loclists_header for more general\n      access.\n    * dwarf_macro5.c: Now the cu-context cc_macro_base\n      field is used when needed for DWP files.\n    * dwarf_opaque.h: Rearranged some fields of\n      Dwarf_CU_Context\n      into more logical groupings (related to debug fission).\n    * dwarf_rnglists.c: renamed internal_read_header\n      to _dwarf_internal_read_rnglists_header().\n    * dwarf_rnglists.h: Added protype for\n      _dwarf_internal_read_rnglists_header().\n    * dwarf_str_offsets.c: Removed \n      _dwarf_find_offsets_via_fission\n      (which does more than just str_offsets now)\n      and put into dwarf_fission_to_cu.c as\n      _dwarf_find_all_offsets_via_fission().\n    * dwarf_str_offsets.h: Prototype renamed.\n    * libdwarf.h.in: Added a comment.\n    * generated_libdwarf.h.in: Regenerated.\n2020-09-18: David Anderson\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n\t  dwarf_names_new.h,libdwarf_version.h: Updated  version\n      string, regenerated files that reference it.\n2020-09-18: David Anderson\n    * dwarf_debug_names.c: If allocation fails in setting up\n      a Dwarf_Dnames head we now get an error and a more tailored\n      error than just memory-allocation-failed.\n    * dwarf_elf_load_headers.c: If the symtab section size\n      is really big (larger than the object file size!) we now\n      get a relevant error message.  Used to get malloc fail on\n      32bit systems and do a large malloc on 64bit systems before\n      getting an error eventually.\n    * dwarf_frame.c: Calling the frame-retrieval functions\n      on a corrupted object file could result in leaking memory.\n      Fixed.\n2020-09-17: David Anderson\n    * dwarf_peread.c: Deleted several blank lines.\n    * dwarf_global.c: Removed trailing whitespace,\n      fixed indents.\n    * dwarf_errmsg_list.h: Various error strings now\n      have extra text with meaningful, but generic,\n      content.\n2020-09-17: David Anderson\n    * dwarf_global.c: Refactored to eliminate 50 lines\n      of duplicated code and ensure no leaks while\n      improving error messages when the object or DWARF\n      data is damaged (fuzzed).\n    * dwarf_global.h,dwarf_funcs.c,dwarf_pubtypes.c,\n      dwarf_types.c,dwarf_vars.c,dwarf_weaks.c: Eliminated \n      useless arguments to library-internal function.\n    * dwarf_util.h: Errors detected in a macro now \n      report more useful information.\n    * dwarf_alloc.c: Two DEBUG lines were too long,\n      broke those lines to shorter ones.\n      Added DEBUG-only output where it had not\n      reported earler.\n2020-09-15: David Anderson\n    * dwarf_alloc.c: Added ifdef DEBUG\n      printf for cases it should exist.\n      #undef debug at the top guaranties it will not\n      be turned on by accident.\n    * dwarf_loc.c(_dwarf_read_loc_section): Was missing dbg\n      in a call to _dwarf_error. Corrupt object lead to leak.\n    * dwarf_die_deliv.c(_dwarf_make_CU_Context) was missing\n      a _dwarf_error call where one was required.\n      A corrupt object lead to memory leak.\n      And _dwarf_next_die_info_ptr was failing to \n      initialize dbg from the passed in cu_context.\n      Also causing a memory leak on some corrupt objects.\n    * dwarf_peread.c(pe_section_name_get): Was failing\n      to check for a valid null-terminated\n      string in the string table.\n      A corrupted object could cause segmentation violation.\n    * dwarf_error.c (_dwarf_error_string): Added ifdef DEBUG\n      printf where they should have been all along.\n      #undef debug at the top guaranties it will not\n      be turned on by accident.\n2020-09-10: David Anderson\n    * dwarf_die_deliv.c: Now handle DW_AT_GNU_ranges_base\n      properly.\n    * dwarf_ranges.c: New function dwarf_get_ranges_b()\n      so we can pass back the true split-dwarf offset\n      when we have DWARF4 split-dwarf extension objects.\n      And we calculate that true offset.\n    * libdwarf.h.in: New function prototype:\n      dwarf_get_ranges_b().\n    * generated_libdwarf.h.in: Regenerated.\n    * libdwarf2.1.mm:  Version 3.09. Now documents\n      dwarf_get_ranges_b().\n    * libdwarf2.1.pdf:  Version 3.09. Regenerated.\n2020-09-10: David Anderson\n    * checkexamples.c,dwarf_die_deliv.c,dwarf_form.c,\n      dwarf_line_table_reader_common.h,dwarf_query.c,\n      dwarf_ranges.c,dwarf_str_offset.c,dwarf_tied.c:\n      Remove trailing whitespace. Fix indentation.\n2020-09-09: David Anderson\n    * dwarf_alloc.c: dwarf_dealloc_error(dbg,error)\n      and dwarf_dealloc(dbg,error,DW_DLA_ERROR)\n      should now be called with a null dbg if\n      the failing libdwarf was one of the dwarf_init*()\n      or dwarf_elf_init*() functions and the storage\n      in the error will be freed.\n      See libdwarf2.1.pdf rev 3.08 or later for\n      details.\n      With DEBUG set additional allocation details are\n      revealed.\n    * dwarf_error.c: Repair a comparison with NULL.\n    * dwarf_finish.c(dwarf_finish): Simplify the !dbg test.\n    * dwarf_ranges.c: Remove dead code.\n    * libdwarf2.1.mm: Version 3.08. The Table of\n      Contents points to returns from dwarf_init*\n      calls (around page 28) now.\n    * libdwarf2.1.pdf: Generated Version 3.08.\n2020-09-08: David Anderson\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n\t  dwarf_names_new.h,libdwarf_version.h: Updated  version\n      string, regenerated files that reference it.\n2020-09-07: David Anderson\n    * dwarf_xu_index.c: We were not checking the\n      value of N (in the header of .debug_cu/tu_index)\n      to ensure it was sane. Now we check and error\n      if insane (the test object is fuzzed to provoke\n      the error).\n    * dwarf_elf_access.c: Reformatted commentary so\n      the lines are not too long.\n2020-09-07: David Anderson\n    * dwarf_opaque.h, dwarf_str_offsets.c: Removed trailing\n      whitespace.\n    * dwarf_line_table_reader_common.h: Fixed an accidental\n      deletion of a crucual _ (underbar) in preceeding commit.\n2020-09-07: David Anderson\n    * dwarf_line_table_reader_common.h: Places needing\n      additional dealloc in case of error:\n      lines 1232,2255,2404 (line#s in the updated version). \n2020-09-07: David Anderson\n    * dwarf_tied_decls.h: Removed declaration of\n      _dwarf_loop_reading_debug_info_for_cu().\n    * dwarf_tied.c: The return value from dwarf_tsearch() was\n      not being handled properly. Lead to leaks.\n      Could, possibly, have lead to coredump.\n      Other places tsearch return values were done properly.\n      _dwarf_loop_reading_debug_info_for_cu() is\n      now static function.\n    * dwarf_groups.c: Moved _dwarf_grp_destroy_free_node()\n      down to just before the function that references it.\n    * dwarf_alloc.c: Removed an abort() call from\n      #ifdef DEBUG code.\n2020-09-05: David Anderson\n    * dwarf_die_deliv.c: Delete old #if 0 lines.\n      Pick up Fission data about DW_SECT_STR_OFFSETS\n      to help find strings.\n      Merge any helpful base data from the skeleton (tied file)\n      CU dies into the dwp CU dies.\n    * dwarf_base_types.h: Add DW_STR_OFFSETS_VERSION4\n      to help with reading that GNU extension.\n    * dwarf_form.c: Corrected code reading from\n      .debug_str_offsets.\n    * dwarf_opaque.h: Added new fields to the CU context\n      record to support .debug_str_offsets, and a new\n      function declaration related to that.\n    * dwarf_query.c: Deleted no-longer-used functions\n      (the tied-file attribute merge happens much\n      earlier) and added \n      _dwarf_merge_all_base_attrs_of_cu_die().\n    * dwarf_ranges.c: Better represents using .debug_ranges.dwo\n      if it's present in the dwp  .\n    * dwarf_str_offsets.c: Refactoring and revising to support\n      the two formats of .debug_str_offsets: DWARF5 and\n      GNU DWARF4.\n    * dwarf_str_offsets.h. New function prototypes for the revised\n      .debug_str_offsets[.dwo] code.\n2020-09-01: David Anderson\n    * dwarf_loclists.c(internal_load_loclists_contexts): Added\n      a missing 'return DW_DLV_ERROR' when an error was detected.\n2020-08-28: David Anderson\n    * dwarf_die_deliv.c,dwarf_loc.c,dwarf_util.c:Fixed\n      indents and trailing whitespace.\n2020-08-27: David Anderson\n    * dwarf_die_deliv.c: Some error messages now have more\n      detail.\n    * dwarf_line_table_reader_common.h: In an error condition\n      (meaning corrupt dwarf) _dwarf_free_chain_entries()\n      was called twice on the same data, referring to\n      freed space in doing so. Deleted the extra call.\n    * dwarf_loc.c(_dwarf_setup_loc): Removed a \n      bogus _dwarf_error \n      using DW_DLE_LOC_EXPR_BAD: Let the just-called\n      function error code be returned.\n      Some error conditions detected here now report\n      detailed information on the error.\n    * dwarf_query.c(dwarf_attrlist): Refined the detailed\n      error message already present.\n    * dwarf_util.c:New internal function\n      _dwarf_create_area_len_error() lets dwarf_util.h\n      macro report a more detailed error without\n      bloating the macro.\n    * dwarf_util.h: Calls that new function rather\n      than calling _dwarf_error() itself.\n2020-08-25: David Anderson\n    * dwarf_form.c: Previous change failed to show\n      the actual error string \n      DW_DLE_STRP_OFFSET_BAD or DW_DLE_STRING_OFFSET_BAD\n      along with the\n      details. Oops. Now it shows.\n2020-08-23: David Anderson\n    * dwarf_form.c: Slightly changed the error message \n      for an error in DW_FORM_strp.\n2020-08-23: David Anderson\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n\t  dwarf_names_new.h,libdwarf_version.h: Updated  version\n      string, regenerated files that reference it.\n2020-08-23: David Anderson\n    * dwarf_form.c,dwarf_generic_init.c,dwarf_loc.c,\n      dwarf_loc.h,dwarf_loclists.c,dwarf_query.c, dwarf_rnglists.c,\n      pro_opaque.h: Remove trailing whitespace. Fix indents.\n2020-08-23: David Anderson\n    * dwarf_form.c: In case an strp offset seems wrong\n      we get a more detailed error message.\n    * dwarf_macro5.c: Deleted gratuitous blank line.\n2020-08-22: David Anderson\n    * dwarf_loc.c,dwarf_rnglists.c: call \n      _dwarf_look_in_local_and_tied_by_index\n      not _dwarf_extract_address_from_debug_addr so \n      .debug_addr in the tied file will be found.\n    * dwarf_opaque.h,dwarf_query.c: Make  \n      _dwarf_look_in_local_and_tied_by_index global,not\n      _dwarf_extract_address_from_debug_addr.\n2020-08-22: David Anderson\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n\t  dwarf_names_new.h,libdwarf_version.h: Updated  version\n      string, regenerated files that reference it.\n2020-08-21: David Anderson\n    * dwarf_init_finish.c(insert_sht_list_in_group_map):\n      Added checks of dss_data_was_malloc around\n      a couple of calls saying free(secdata.dss_data).\n      The missing checks could only result in duplicate\n      free with user calls that allocated their\n      own section data to load a section and a certain\n      error arising during the call.\n    * dwarf_loc.c: To elminate ambiguity, renamed\n      some fields from lowpc to rawlowpc (for example).\n    * dwarf_loclists.c(build_array_of_lle): Removed\n      a block of code duplicating work done in dwarf_loc.c.\n      Fixed arguments passing ld_lopc, ld_highpc\n      to pass ld_rawlow, ld_rawhigh for correctness.\n2020-08-21: David Anderson\n    * libdwarf2.1.mm: Rev 3.07. Corrected quote mismatches\n      in the mm commands, and a couple of stray\n      characters after a .P command\n    * libdwarf2.1.pdf: Rev 3.07. Regenerated.\n2020-08-18: David Anderson\n    * checkexamples.c: Corrected example_rnglist_for_attribute()\n      example.\n    * dwarf_ranges.c: Corrected a comment and removed #if 0\n      code as it is obsolete.\n    * dwarf_rnglists.c(dwarf_get_rnglists_entry_fields_a):\n      Allow the pointer-arguments used to return data to\n      the caller to be null pointers safely, as libdwarf2.1.pdf\n      suggested that was legal.\n    * libdwarf2.1.mm: Version 3.06. Corrected the example\n      calling dwarf_get_rnglists_entry_fields_a().\n    * libdwarf2.1.pdf: Regenerated, Version 3.06\n     \n      \n2020-08-10: David Anderson\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n\t  dwarf_names_new.h,libdwarf_version.h: Updated  version\n      string, regenerated files that reference it.\n2020-08-10: David Anderson\n    * dwarf_elf_defines.h,dwarf_elfread.c: A linux kernel used a\n      R_X86_64_NONE (which means ignore the relocation) and\n      now we deal with it properly for EM_X86_64.\n2020-08-02: David Anderson\n    * dwarf_alloc.c: Added a constructor for Dwarf_Locdesc_c\n      (DW_DLA_LOCDESC_C) so fields ld_lle_value and\n      ld_kind get non-zero and \n      erroneous initial values so\n      the values can be checked later for correctness.\n    * dwarf_errmsg_list.h: Added error DW_DLE_LOCATION_ERROR.\n    * dwarf_loc.c: Now we rigorously set and check the fields\n      ld_lle_value and ld_kind. \n      _dwarf_locdesc_c_constructor() sets those two fields\n      so we can check correctness and in case of error, \n      report the details.\n    * dwarf_loc.h: Added constructor prototype and a special\n      DW_LLE_VALUE_BOGUS initial value (invisible to \n      library callers).\n    * dwarf_loclists.c: After malloc use the  Dwarf_Locdesc_c\n      constructor so later error checking possible.\n    * libdwarf.h.in: Added error DW_DLE_LOCATION_ERROR.\n    * libdwarf2.1.mm: Rev 3.05. Additional detail on\n      return values for dwarf_get_locdesc_entry_d()\n      and documented dwarf_get_locdesc_entry_c() \n      (recommending use of dwarf_get_locdesc_entry_d()\n      instead)\n    * libdwarf2.1.pdf: Rev 3.05. Regenerated.\n2020-07-28: David Anderson\n    * dwarf_locationop_read.c: Added DW_OP_GNU_variable_value.\n    * dwarf_names.c, dwarf_names_enum.h: Regenerated.\n    * dwarf.h: Added in GNU names that had been accidentally\n      ommitted: DW_AT_GNU_deleted,DW_AT_GNU_locviews,\n      DW_AT_GNU_entry_view,DW_OP_GNU_variable_value.\n      These caused the regeneration of dwarf_names.h.\n2020-07-22: David Anderson\n    * dwarf_abbrev.c,dwarf_debug_names.c, dwarf_debuglink.c,\n\t  dwarf_dsc.c,dwarf_error.c,dwarf_form.c,dwarf_funcs.c,\n\t  dwarf_gdbindex.c,dwarf_harmless.c,dwarf_init_finish.c,\n\t  dwarf_leb.c,dwarf_leb_test.c,dwarf_line.c,dwarf_macro.c,\n\t  dwarf_macro5.c,dwarf_original_elf_init.c,dwarf_pubtypes.c,\n\t  dwarf_str_offsets.c,dwarf_stringsection.c,dwarf_stubs.c,\n\t  dwarf_test_errmsg_list.c,dwarf_types.c,dwarf_vars.c,\n\t  dwarf_weaks.c,dwarf_xu_index.c,gennames.c,malloc_check.c,\n\t  pro_arange.c,pro_encode_nm.c,pro_error.c,pro_finish.c,\n\t  pro_forms.c,pro_funcs.c,pro_line.c,pro_macinfo.c,\n\t  pro_pubnames.c,pro_reloc.c,pro_reloc_stream.c,\n\t  pro_reloc_symbolic.c,pro_types.c,pro_vars.c,pro_weaks.c:\n      Updated copyright date. Reformatted copyright to\n      have slightly shorter lines, no change in content.\n2020-07-22: David Anderson\n    * libdwarf2.1.mm: Now Rev 3.04. Revised the \n      Error Handling section for greater clarity.\n      Revised dwarf_init_path() to correct formatting\n      errors. \n    * libdwarf2.1.pdf: Regenerated as rev 3.04 .\n    * dwarf_generic_init.c(dwarf_init_pathh): Removed\n      the error-handling so when the call fails the\n      Dwarf_Debug argument is not touched. \n      For the PE case return  the DW_DLV_ERROR or\n      DW_DLV_NO_ENTRY (return left off by accident).\n    * dwarf_arange.c: Reformatted the copyright\n      to have shorter lines.\n2020-07-17: David Anderson\n    * libdwarf/libdwarf_version.h: Version string updated.\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n      dwarf_names_new.h,libdwarf_version.h : regenerated\n      with latest version string\n2020-07-17: David Anderson\n    * dwarf_frame.c: rearrange comments a little and\n      add a web reference as documentation.\n\t* pro_debug_sup.c,pro_section.c: Remove trailing \n      whitespace.  Fix indents.\n2020-07-15: David Anderson\n    * dwarf_alloc.c: Improved printf if DEBUG\n      is turned on, with #undef DEBUG in source so\n      necessary to modify the source and rebuild\n      to get the voluminous alloc/dealloc debugging\n      printf turned on.\n2020-07-14: David Anderson\n    * libdwarf2.1.mm: Version 3.02. Documents the new call\n      dwarf_get_debug_sup() to access the DWARF5\n      .debug_sup section.\n    * libdwarf2p.1.mm: Version 1.51.  Documents the new\n      call dwarf_add_debug_sup() to create the DWARF5\n      .debug_sup section.\n    * libdwarf2.1.pdf,libdwarf2p.1.pdf: Regenerated.\n2020-07-14: David Anderson\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n\t  dwarf_names_new.h,libdwarf_version.h: Regenerated\n      with new version string.\n2020-07-13: David Anderson\n    * CMakeLists.txt, Makefile.am: Added dwarf_debug_sup.c\n    * Makefile.in: Regenerated.\n    * dwarf_errmsg_list.h: Added DW_DLE_DEBUG_SUP_STRING_ERROR\n      and DW_DLE_DEBUG_SUP_ERROR.\n    * dwarf_names.c dwarf_names_enum.h: Reflects correction\n      of value of\n      DW_GNUIVIS_static (a new non-standard name in dwarf.h)\n    * generated_libdwarf.h.in,libdwarf.h.in: With the\n      two new errors and declaration of\n      dwarf_add_debug_sup() to produce .debug_sup\n      and dwarf_get_debug_sup() to retrieve the section values..\n    * pro_finish.c: Support for creating .debug_sup.\n    * pro_opaque.h: Support for creating .debug_sup.\n    * pro_section.c: Support for creating .debug_sup.\n    * dwarf_debug_sup.c: New, for .debug_sup access.\n\t* pro_debug_sup.c: New. for .debug_sup creation.\n2020-07-10: David Anderson\n    * dwarf_die_deliv.c: Handle\n      DW_AT_GNU_ranges_base in a CU DIE.\n    * dwarf_opaque.h: Added 2lines of comment\n      about cc_debug_offset.\n    * dwarf_query.c(_dwarf_get_ranges_base_attr_value):\n      Simplified as the cu_context\n      has the base values, no need to read\n      DIEs/Attributes here.\n2020-07-09: David Anderson\n    * dwarf_opaque.h: Changing a comment about libdwarf\n      and the tied file (if any).\n2020-07-08: David Anderson\n    * libdwarf2.1.mm: Added documentation of\n      .debug_gnu_pybtypes and .debug_gnu_pubnames.\n      See dwarf_get_gnu_index_head() in the document.\n    # libdwarf2.1.pdf: Regenerated. Rev 3.01\n2020-07-08: David Anderson\n    * dwarf_init_finish.c: setup of .debug_names was\n      done twice (not harmful but the duplicate removed now).\n2020-07-08: David Anderson\n    * dwarf_elf_load_headers.c,dwarf_gdbindex.c,dwarf_gnu_index.c,\n\t  dwarf_gnu_index.h,dwarf_init_finish.c,\n      dwarf_locationop_read.c: Fixed indents and trailing\n      whitespace.\n2020-07-08: David Anderson\n    * dwarf.h: Fixed error in DW_GNUIVIS values.\n    * dwarf_debug_names.h: Arranging shorter\n      lines in a block of comments.\n    * dwarf_elfread.c( find_section_to_relocate): Added \n      de_debug_gnu_pubnames, de_dbug_gnu_pubtypes to sections\n      that can have relocations (in  a dwo.o before linking).\n    * dwarf_gnu_index.c: Now loads debug_info so that\n      in near future correctness of offsets in \n      .debug_gnu_pubnames/pubtypes can be checked.\n2020-07-08: David Anderson\n    * dwarf_gnu_index.c: Remove debug printf. Small corrections\n      to the section reading.\n2020-07-06: David Anderson\n    * dwarf_loc.c: Too-long lines in comments adjusted shorter.\n    * dwarf_loc.h: Renamed _dwarf_free_loclists_head to\n      _dwarf_free_loclists_head_content for clarity.\n    * dwarf_loclists.c: Deleted dead code. Renamed that\n      function here too. Corrected a bug in\n      _dwarf_free_loclists_head()\n    * dwarf_gnu_index.c,dwarf_gnu_index.h: New files\n      to handle sections .debug_gnu_pubnames and\n      .debug_gnu_pubtypes\n    * dwarf_init_finish.c: Added the new sections to\n      enter_section_in_de_debug_sections_array().\n    * CMakeLists.txt,Makefile.am: Added dwarf_gnu_index.c and\n      dwarf_gnu_index.h\n    * Makefile.in: Regenerated.\n    * dwarf.h: Added new nonstandard DW_GNUIVIS* and\n      DW_GNUIKIND* in support of these sections.\n    * dwarf_alloc.c: New record type DW_DLA_GNU_INDEX_HEAD\n      for these new sections.\n    * dwarf_errmsg_list.h: New errors\n    * dwarf_names.c, dwarf_names.h: Regenerated with\n      DW_GNUIVIS and DW_GNUIKIND name functions.\n    * dwarf_names_enum.h: Regenerated this too.\n    * dwarf_names_new.h: Regenerated this.\n    * libdwarf.h.in: Added Dwarf_Gnu_Index_Head type\n      and new functions and new error codes. Dropped\n      a dead DLA type and assigned it to be for\n      DW_DLA_GNU_INDEX_HEAD. Added new functions \n      dwarf_get_gnu_index_head()\n      dwarf_gnu_index_dealloc()\n      dwarf_get_gnu_index_block() \n      dwarf_get_gnu_index_block_entry() allowing\n      access to the data in .debug_gnu_pubtypes\n      and .debug_gu_pubnames.\n    * generated_libdwarf.h.in: Regenerated.\n2020-07-04: David Anderson\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n\t  dwarf_names_new.h,libdwarf_version.h: new version string.\n2020-07-03: David Anderson\n    * CMakeLists.txt, Makefile.am: renamed dwarf_dnames.h ->\n      dwarf_debug_names.h and dwarf_dnames.c to \n      dwarf_debug_names.c.\n    * Makefile.in: Regenerated.\n    * dwarf_alloc.c, dwarf_debug_names.c: Include\n      name updated dwarf_dnames.h to dwarf_debug_names.h .\n    * dwarf_elfread.c(_dwarf_elf_object_access_internals_init):\n      In case of a null gh_namestring we notice and skip\n      over it.\n    * dwarf_init_finish.c(_dwarf_load_section): Added to\n      the comment on zero-size sections.\n2020-07-02: David Anderson\n    * dwarf_gdbindex.h: Removed gdbindex_offset_type typedef\n      as it is not used anywhere.\n    * dwarf_global.c(dwarf_get_cu_die_offset_given_cu_header_offset):\n      Updated a commment to reflect handling of DWARF5 and more.\n    * dwarf_util.h: Removed SKIP_LEB128_WORD_CK as it\n      is no longer used and replaced by a better function.\n    * dwarf_query.c: Removed comment about that macro.\n    * dwarf_form.c: Revised the commentary on\n      DW_AT_str_offsets_base to match the final DWARF5.\n2020-07-02: David Anderson\n    * libdwarf.h.in: Added DW_DLE_GDBINDEX_STRING_ERROR.\n    * generated-libdwarf.h.in: Regenerated.\n    * dwarf_errmsg_list.h: Added DW_DLE_GDBINDEX_STRING_ERROR.\n    * dwarf_gdbindex.c(dwarf_gdbindex_addressarea_entry): Now\n      checks its arguments and the return string for problems.\n2020-07-01: David Anderson\n    * libdwarf.h.in: Comment now deprecates \n      dwarf_get_loclist_entry().\n    * generated_libdwarf.h.in: regenerated.\n    * libdwarf2.1.mm: Deprecates dwarf_get_loclist_entry().\n    * libdwarf2.1.pdf: Regenerated, version 2.99.\n    * dwarf_locationop_read.c: Pass real address-size to\n      read_encoded_addr() so it will work properly.\n2020-06-29: David Anderson\n    * dwarf_elf_load_headers.c: Added sanity checks\n      on section size of the section strings and\n      the symbol strings.\n      All the section-size errors now use\n      the new error code DW_DLE_SECTION_SIZE_OR_OFFSET_LARGE.\n    * dwarf_errmsg_list.h: Added string for\n      DW_DLE_SECTION_SIZE_OR_OFFSET_LARGE.\n    * libdwarf.h.in: Added DW_DLE_SECTION_SIZE_OR_OFFSET_LARGE.\n    * generated_libdwarf.h.in: Regenerated.\n2020-06-29: David Anderson\n    * libdwarf_version.h: updated version string.\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n      dwarf_names_new.h: Regenerated.\n2020-06-29: David Anderson\n    * dwarf_elfread.c: Added checks on section sizes\n      and offsets to ensure they don't exceed file size\n      (but only check when we try to read them, we\n      want to read dwarf even if sections we do not\n      care about have damaged section headers).\n    * dwarf_peread.c: Fixed indentation mistake.\n2020-06-28: David Anderson\n    * dwarf_elf_defines.h: Adding R_386_GOTPC\n      so we don't rely on /usr/include to have the\n      ones we need.\n    * dwarf_elf_rel_detector.c: Adding R_386_GOTPC\n      to identify the relocation as 32bit.\n2020-06-27: David Anderson\n    * dwarf_alloc.c(_dwarf_free_all_of_one_debug): If space \n      for debug_rnglists or\n      debug_loclists was malloc'd (relocations\n      or compressed sections force malloc) we\n      now call the function that frees that\n      data.  That function renamed:\n      rela_free->malloc_section_free.\n2020-06-25: David Anderson\n    * dwarf_loc.c: Corrected indents.\n    * dwarf_loclists.c: Corrected indents, removed\n      trailing whitespace.\n    * dwarf_peread.c: Removed trailing whitespace.\n    * dwarf_rnglists.c: Removed trailing whitespace.\n    * libdwarf2.1.mm: Rev 2.98. Added documentation\n      on the .debug_names section printing functions.\n      These intended for debugging .debug_names\n      (that is, by dwarfdump),\n      not things user code are likely to want to use. \n      Documented the new function \n      dwarf_get_rnglists_entry_fields_a() as the original\n      dwarf_get_rnglists_entry_fields() \n      (which is still there and works as well as before)\n      left off a field important to callers.\n    * libdwarf2.1.pdf: Rev 2.98. Regenerated.\n2020-06-22: David Anderson\n    * dwarf_loc.c: Using knowledge of the base address status\n      improve messaging while reducing execution time.\n    * dwarf_loclists.c: Properly deal with setting\n      up for output in case .debug_addr missing (fixing\n      an omission).\n    * dwarf_peread.c: In load_optional_header64() we were\n      failing to read hdr.ImageBase which caused addresses\n      to be wrong (base address needed to be set).\n    * dwarf_rnglists.c: Based on knowledge of lack/presence\n      of .debug_addr improve messaging and reduce\n      cpu-time spent.\n    * dwarf_rnglists.h: Added 2 line commentary.\n    * libdwarf.h.in,generated_libdwarf.h.in: Added\n      dwarf_get_rnglists_entry_fields_a(), the original\n      function was inadequate.\n2020-06-19: David Anderson\n    * dwarf_reloc_x86_64.hr,dwarf_reloc_x86_64.h: Added in\n      R_X86_64_PC64 relocation as llvm is using it.\n2020-06-17: David Anderson\n    * dwarf_elf_load_headers.c: Catch a potential division by \n      zero error. \n    * dwarf_peread.c: Added comments.\n2020-06-17: David Anderson\n    * dwarf_loclists.c, dwarf_rnglists.c: Rename \n      length_size->offset_size\n      for clarity and correct the computation of the\n      length of the offsets array.\n2020-06-17: David Anderson\n    * dwarf_die_deliv.c: Pick up CU DIE base fields\n      always. Not just for DWARF4,5.\n    * dwarf_loc.c: Clarify the flow. A comment added.\n    * dwarf_form.c: Added missing DW_FORM_loclistx from\n      a switch.\n2020-06-16: David Anderson\n    * dwarf_query.c, dwarf_util.c: Remove trailing whitespace.\n      Changed indents and line lengths in a small area to match\n      the usual look.\n2020-06-16: Jorge Gorbe Moya \n    * dwarf_query.c, dwarf_util.c: Correct the handling\n      of DW_UT initializations.\n2020-06-16: David Anderson\n    * dwarf_die_deliv.c,dwarf_frame2.c,dwarf_loc.c:\n      Remove trailing whitespace.\n2020-06-14: David Anderson\n    * libdwarf1.1.mm: Added examples to the Error Handling\n      section as the previous version was pretty vague\n      about the best way to call libdwarf to deal\n      with errors.\n    * libdwarf1.1.pdf: Generated version 2.97.\n     \n2020-06-14: David Anderson\n    * dwarf_die_deliv.c: Adds the highest known\n      abbrev code to certain error messages.\n    * dwarf_die_deliv.h: Corrected a comment.\n    * dwarf_frame2.c: Now uses (uintptr_t) to avoid\n      warnings from certain compiler/pointer-size\n      environments.\n    * dwarf_loc.c: Update the loclist head\n      structure  ll_bytes_total\n      field with DWARF 2,3,4 loclists too.\n    * dwarf_opaque.h: Add cc_highest_known_code\n      to Dwarf_CU_Context_s for better\n      error reporting and align some field names\n      for a better appearance.\n    * dwarf_query.c: Improved error reporting\n      when an abbrev code missing.\n    * dwarf_util.c: Keep track of highest abbrev\n      code seen (per compilation unit).\n    * dwarf_util.h: Internal function declaration\n      changed to allow reporting of highest\n      abbrev code.\n2020-06-12: David Anderson\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n      dwarf_names_new.h,libdwarf_version.h: updated\n      version string.\n2020-06-12: David Anderson\n    * checkexamples.c,dwarf_alloc.c,dwarf_arange.c,\n      dwarf_frame.c,dwarf_line.c,dwarf_line_table_reader_common.h,\n      dwarf_loc.c,dwarf_loc.h,dwarf_locationop_read.c,\n      dwarf_loclists.c,dwarf_query.c,dwarf_rnglists.c,\n      dwarf_util.c,libdwarf.h.in: Fixed indents\n      and removed trailing whitespace.\n2020-06-12: David Anderson\n    * dwarf_alloc.c: Added free of loclists to \n      _dwarf_free_all_of_one_debug().\n    * dwarf_loc.c: Created _dwarf_free_op_chain()\n      and call it so even in case of error nothing leaks.\n      Some adjustments to indents.\n    * dwarf_loclists.c: _dwarf_dealloc_loclists ->\n      _dwarf_dealloc_loclists_context for clarity.\n      Modified _dwarf_free_loclists_head() to get\n      leak-free behavior.\n    * dwarf_opaque.h: Reflects above name change.\n    * libdwarf2.1.mm: Corrected and amplified\n      words on the new functions.\n    * libdwarf2.1.pdf: Regenerated.\n2020-06-10: David Anderson\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n      dwarf_names_new.h,libdwarf/libdwarf_version.h:\n      updated version string.\n2020-06-09: David Anderson\n    * CMakeLists.txt,Makefile.am : Deleted dwarf_loc2.h reference.\n      Added dwarf_locationop_read.c, dwarf_loclists.c.\n    * Makefile.in: Regenerated.\n    * dwarf_alloc.c: Corrected a comment about reserved numbers.\n      Reflects name change from struct Dwarf_Loc_c_s to\n      struct Dwarf_Loc_Expr_Op_s. \n    * dwarf_errmsg_list.h: Added DW_DLE_LOCLISTS_ERROR.\n    * dwarf_form.c: Added arguments to the library\n      internal function _dwarf_formblock_internal()\n      for better support of DWARF5 loclist creation.\n    * dwarf_frame2.c: Changed a local from unsigned\n      to Dwarf_Unsigned as well as changing pointer\n      casts from 'unsigned long' to Dwarf_Unsigned.\n    * dwarf_loc.c: Lots of refactoring to make\n      the flow easier to understand.\n      Moved _dwarf_read_loc_expr_op() to\n      a new file dwarf_locationop_read.c as the \n      function is quite large.\n      Renamed other functions so the names are not\n      so much alike.\n    * dwarf_loc.h: New fields in Dwarf_Loc_Chain_s\n      to support the raw vs. cooked values of location\n      low/high. New fields to support DWARF 5 loclists\n    * dwarf_loc2.h: Deleted. Relevant contents in\n      dwarf_loc.c and dwarf_loclists.c\n    * dwarf_locationop_read.c: Existing code\n      to read location ops refactored to a routine\n      by themselves.  Long enough by itself\n    * dwarf_loclists.c: New file with .debug_loclists\n      support. \n    * dwarf_loclists.h: Nothing here. will be deleted.\n    * dwarf_opaque.h: New functions and arguments\n      for internal debug_loclists data.\n    * dwarf_rnglists.c: Changed certain arguments\n      to Dwarf_Half (address_size etc) where that\n      makes sense.  \n    * dwarf_util.c: Now dwarf_load_debug_info()\n      loads the base data from .debug_rnglists\n      and .debug_loclists (DWARF5)\n    * libdwarf.h.in: 'unsigned' now 'unsigned int'\n      existing function unchanged: dwarf_get_loclist_c()\n      new function dwarf_get_locdesc_entry_d()\n      new function dwarf_get_loclist_head_basics()\n      new function dwarf_get_location_op_value_d()\n      new function dwarf_get_loclist_head_kind()\n      - Following for printing raw loclists, not\n      usually used.\n      new function dwarf_load_loclists()\n      new function dwarf_get_loclist_context_basics()\n      new function dwarf_get_loclist_lle()\n      new function dwarf_get_loclist_offset_index_value()\n      new function dwarf_get_loclist_raw_entry_detail()\n    * libdwarf2.1.mm: 2.96, documents the new calls.\n    * libdwarf2.1.pdf: Version 2.96.\n2020-05-23: David Anderson\n    * dwarf_opaque.h: Defines DWARFSTRING_ALLOC_SIZE   200\n    * dwarf_form.c: Using DWARFSTRING_ALLOC_SIZE for the\n      initial allocation, (mostly) avoiding the need\n      for malloc here.  dwarfstring is mainly used\n      for error messages, so preallocation is rarely useful\n    * dwarf_line.c(create_fullest_file_path): Corrected\n      the comments for this function.\n2020-05-22: David Anderson\n    * dwarf_alloc.c: New functions with proper type checking:\n      dwarf_dealloc_error(), dwarf_dealloc_attribute(),\n      dwarf_dealloc_die().\n    * dwarf_arange.c: Now does correct free_aranges_chain() \n      and ensures chain entry stuff dealloc-d as appropriate.  \n    * dwarf_die_deliv.c: Improved an error message in reports\n      an address-size error.\n    * dwarf_frame.c: Initialize more local variables at the\n      point of declaration. Do  all needed dealloc of\n      the chain entries \n      when creating the list.\n    * dwarf_global.c: Now uses the new ch_itemtype\n      to dealloc properly.  Which simplifies the \n      dealloc_globals_chain() call.\n    * dwarf_line.c:  Now uses the new ch_itemtype\n      to dealloc properly.\n    * dwarf_line_table_reader_common.h: Now uses wrappers\n      for the READ_UNALIGNED_CK DECODE_LEB128_UWORD_CK etc\n      macros so the code\n      now deallocs appropriately in case of error.\n      Most places were not doing full dealloc. Now\n      all are.\n    * dwarf_opaque.h: New field ar_dbg so attribute\n      dealloc is easier.  New chain field ch_itemtype\n      so dealloc is simpler and safer.\n    * dwarf_query.c: Removed comment about leaking memory,\n      the leaks are fixed by using the DECODE_LEB128_UWORD_CK\n      etc wrapper functions.\n    * libdwarf.h.in: Declares the new dealloc functions\n      dwarf_dealloc_error(),dwarf_dealloc_die(),\n      dwarf_dealloc_attribute().\n    * generated_libdwarf.h.in: Regenerated.\n    * libdwarf2.1.mm: New documentation of dwarf_dealloc()\n      as well as documentation of\n      dwarf_dealloc_error(),dwarf_dealloc_die(),\n      dwarf_dealloc_attribute().\n    * libdwarf2.1.pdf: Regenerated. Version 2.94.\n2020-05-19: David Anderson\n    * dwarf_rnglists.c: Ommited a crucial assign to rh_debug so it\n      leaked if de_alloc_tree absent.\n2020-05-19: David Anderson\n    *  dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,dwarf_names_new.h,\n       libdwarf_version.h : New version strings.\n2020-05-19: David Anderson\n    * libdwarf.h.in: Revised a couple rnglists functions\n      by removing unneeded arguments and revising the arguments\n      to dwarf_rnglists_offset_get_rle_head(),\n      dwarf_get_rnglist_head_basics(), and\n      dwarf_get_rnglists_entry_fields()\n    * generated_libdwarf.h.in: Regenerated.\n    * dwarf_rnglists.c: Checked a pointer argument for null before using.\n      Remove the unneeded function arguments (affecting several internal\n      functions too). Renamed a few internal things for clarity.\n    * libdwarf2.1.mm: Documented the new rnglists functions\n      and added examples of use.\n    * libdwarf2.1.pdf: Regenerated. Version 2.93.\n2020-05-17: David Anderson\n    * dwarf_dnames.c: Improved error reporting of the names generation\n      when something goes wrong.\n    * dwarf_elf_access.c,dwarf_elfread.c: Add MATCH_REL_SEC \n      for the .debug_addr section.\n    * dwarf_form.c: Improved error reporting by showing specific details.\n      Now supports DW_FORM_rnglistx.  New function\n      dwarf_addr_form_is_indexed(theform) created, now using\n      it here and in dwarfdump as needed..\n    * dwarf_line_table_reader_common.h: Corrected indents.\n    * dwarf_opaque.h:  Small commentary changes, added the \n      CU Context field cc_dwo_name_present (used for \n      non-standard DWARF4).\n    * dwarf_query.c: Simplified some pointlessly messy code.\n      Now also using dwarf_addr_form_is_indexed() instead of\n      a list missing some DWARF5 values.\n    * dwarf_ranges.c: #if 0 some useless code for now. \n    * dwarf_rnglists.c: The .debug_rnglists code is here.\n    * dwarf_rnglists.h: For use inside libdwarf. Opaque\n      to libdwarf callers.\n    * dwarf_tsearchhash.c: Trivial change. No logic change.\n    * dwarf_util.c: Removed pointless blank line.\n    * dwarf_util.h, dwarf_xu_index.h: Fix trailing whitespace.\n    * libdwarf.h.in: New functions and opaque types for reading\n      the .debug_rnglists section.\n    * generated_libdwarf.h.in: Regenerated.\n2020-05-05: David Anderson\n    * dwarf_rnglists.h, dwarf_opaque.h, dwarf_rnglists.c: \n      Preliminary new fields/code for Rnglists_Context.\n2020-05-04: David Anderson\n    * dwarf_alloc.c: renamed dwarf_dealloc_rnglists\n      to _dwarf_dealloc_rnglists.\n    * dwarf_errmsg_list.h: Added DW_DLE_RNGLISTS_ERROR.\n    * dwarf_opaque.h: Added _dwarf_dealloc_rnglists() prototype.\n    * dwarf_rnglists.c: Minor corrections of this new code.\n    * dwarf_rnglists.h: Added a new field for internal use.\n      Deleted some #if 0 lines.\n    * dwarf_util.c(_dwarf_load_debug_info): Now also\n      calls dwarf_load_rnglists as we need that in the\n      Dwarf_Debug.\n    * libdwarf.h.in: Added DW_DLE_RNGLISTS_ERROR.\n      Deleted dwarf_dealloc_rnglists as it is renamed\n      and made private to libdwarf.\n    * generated_libdwarf.h.in: Regenerated.\n2020-05-02: David Anderson\n    * libdwarf2.1.mm: Added a note to Changes that\n      instances of 'length_size' in the code and headers\n      variable naming will, over time, be changed to \n      'offset_size' as this name suggests what they really\n      represent: a 4 or 8 byte offset size.\n    * libdwarf2.1.pdf: Regenerated, version 2.92\n2020-05-02: David Anderson\n    * CMakeLists.txt, Makefile.am: Added dwarf_rnglists.h,\n      dwarf_rnglists.c\n    * Makefile.in: Regenerated.\n    * dwarf_alloc.c: Now calls dwarf_dealloc_rnglists() at\n      finish to clean up rnglists data, if any.\n    * dwarf_arange.c: Deleted some blank lines and added one.\n    * dwarf_opaque.h: Added de_rnglists_context_count and\n      de_rnglists_context to support rnglists.\n    * dwarf_rnglists.h:  Defines the Dwarf_Rnglists_Context\n      structure.\n    * dwarf_rnglists.c:  Implements initial support of the\n      .debug_rnglists section.\n    * libdwarf.h.in: Declares new rnglist-related functions\n      and an opaque struct Dwarf_Rnglists_Context_s.\n    * generated_libdwarf.h.in: Regenerated.\n2020-04-26: David Anderson\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n      dwarf_names_new.h,libdwarf_version.h: Updated\n      version string.\n2020-04-25: David Anderson\n    * dwarf_abbrev.c: Fix trailing whitespace.\n    * dwarf_arange.c: Delete macro READ_UNALIGNED_CK\n      use an just use  _dwarf_read_unaligned_ck_wrapper.\n    * dwarf_die_deliv.c: Uses wrapper instead\n      of READ_UNALIGNED_CK where necessary.\n      Delete commented-out lines.\n    * dwarf_error.c: Remove unwanted debug  code.\n    * dwarf_form.c: Remove trailing whitespace.\n    * dwarf_global.c: Rename some arguments for greater\n      clarity.\n    * dwarf_line.c: Fix line handling so both DW5\n      and earlier handled better.  Improve some error\n      messages.\n    * dwarf_macro5.c:  Use wrapper() funcs, not\n      READ_UNALIGNED_CK and fix a couple local\n      variables so that works.\n    * dwarf_ranges.c: Remove trailing whitespace.\n    * dwarf_util.c: Remove trailing whitespace.\n2020-04-24: David Anderson\n    * dwarf_die_deliv.c: Now using wrappers so that\n      errors do not lead to a temporary leak.\n    * dwarf_global.c: Now ensures that an error\n      in reading globals does not lead to temporary\n      leaks that rely on dwarf_finish() to clean up.\n2020-04-24: David Anderson\n    * dwarf_names.c,dwarf_names.h, dwarf_names_enum.h,\n      dwarf_names_new.h, libdwarf_version.h: \n      updated version string.\n2020-04-23: David Anderson\n    * dwarf_arange.c: Using new wrapper() code\n      so that the reader macros do not interfere\n      with doing appropriate dealloc.\n    * dwarf_util.c: Implement new wrapper functions\n      _dwarf_read_unaligned_ck_wrapper() and\n      _dwarf_read_area_length_ck_wrapper.\n    * dwarf_util.h: Declare the new functions.\n2020-04-22: David Anderson\n    * libdwarf.h.in: Added DW_DLE_USER_DECLARED_ERROR\n      and the dwarf_error_creation() function that creates\n      the Dwarf_Error.\n    * generated_libdwarf.h.in: Regenerated.\n2020-04-20: David Anderson\n    * dwarf_form.c: Split a too-long comment line.\n2020-04-16: David Anderson\n    * dwarf_line_table_reader_common.h: more detailed error\n      messages in a few cases.\n    * dwarf_print_lines.c: Added dwarf_check_lineheader_b()\n      as dwarf_check_lineheader() did not return error\n      details.\n    * libdwarf.h.in: defined prototype for \n      dwarf_check_lineheader_b();\n    * generated_libdwarf.h.in: regenerated.\n2020-04-14: David Anderson\n    * libdwarf2.1.mm: Fixed wording \n      of dwarf_get_fde_info_for_cfa_reg3_b()\n      which had the 1/0 value of has_more_rows\n      backwards.\n      Corrected several misspellings. \n    * libdwarf2.1.pdf: Regenerated, v2.91.\n2020-04-13: David Anderson\n    * dwarf_abbrev.c: Various errors now show additional detail\n      about what exactly is wrong.\n2020-04-11: David Anderson\n    * dwarf_die_deliv.c,dwarf_xu_index.c: Each had\n      a single trailing space. Removed. \n2020-04-11: David Anderson\n    * dwarf_global.c: Changed break to continue\n      so we don't stop the loop too early, yet\n      still avoid leaking a useless.\n2020-04-10: David Anderson\n    * debug-cu-tu-indexes-layout.odg: The Split-Dwarf\n      (aka debugfission) table layout is simple, but\n      this is an introduction to the \n      layout of the arrays.  LibreOffice Draw document.\n    * dwarf_init_finish.c: Small enhancements of error messages.\n    * dwarf_util.c: Reformatted a macro here\n      (READ_UNALIGNED_CK) so the lines are not so long\n      and the backslashes are easily seen as complete.\n    * dwarf_xu_index.c: There was some confusion in the\n      code which prevented it from working.\n      Interfaces remain the same, but things work now.\n      The first part is a 20 line (or so) explanation\n      of some of the internal handling of the tables.\n      Now things work. Many error messges get\n      detailed information.\n    * dwarf_xu_index.h: Added new fields and relabeled\n      the N U S fields in the header to match the\n      DWARF5 standard.\n    * libdwarf2.1.mm: Rev 2.90 10 April 2020.\n      A little bit of reformatting to shorten the lines\n      here. Has little or no effect on the output pdf.\n      corrected the wording about the\n      dwarf_get_xu_section_offset() function. \n    * libdwarf2.1.pdf: Regenerated Rev 2.90.\n2020-04-07: David Anderson\n    * dwarf_alloc.c: Deleted useless comment and added\n      a blank line to separate declarations from code.\n    * dwarf_frame2.c:  Fixed a too-long line.\n    * dwarf_query.c: Now DW_DLE_ALLOC_FAIL has a meaningful\n      error string attached.\n    * dwarf_util.c: Added comment before CHECK_DIE macro.\n2020-04-03: David Anderson\n    * dwarf_arange.c: Deleted a useless blank line.\n      Removed useless () around a return value.\n2020-04-03: David Anderson\n    *  dwarf_form.c,dwarf_frame2.c,dwarf_query.c: Fix indents and\n       remove trailing whitespace.\n2020-04-02: David Anderson\n    * dwarf_die_deliv.c: Better text printed for an address size error\n      including reporting the actual addrss-size found by libdwarf.\n    * dwarf_frame2.c: Deleted a static version of\n      _dwarf_create_address_size_dwarf_error() and use\n      the global one. Revised some error messages to\n      have specific details. Each instance of\n      DW_DLE_DEBUG_FRAME_LENGTH_BAD now reports something\n      specific about each case.\n    * dwarf_opaque.h: Added a declaration of\n      _dwarf_create_address_size_dwarf_error().\n2020-03-28: David Anderson\n    * dwarf_global.c: dwarf_return_empty_pubnames() revised\n      so it cannot fail.\n    * libdwarf.h.in: Revised comments attached to\n      dwarf_return_empty_pubnames() function prototype.\n    * generated_libdwarf.h.in: Regenerated.\n2020-03-27: David Anderson\n    * dwarf_names.c,dwarf_names.h, dwarf_names_enum.h,\n      dwarf_names_new.h, libdwarf_version.h: \n      updated version string.\n2020-03-27: David Anderson\n    * dwarf_form.c,dwarf_query.c,dwarf_ranges.c: Improve various\n      error messages with specific information about the\n      error.\n2020-03-27: David Anderson\n    * dwarf_ranges.c: Properly detect end-of-section\n      again.\n2020-03-27: David Anderson\n    * dwarf_alloc.c, dwarf_form.c: Removed\n      trailing whitespace.\n2020-03-27: David Anderson\n    * dwarf_alloc.c: The (static) list of DW_DLA \n      initializers was very messy and hard to read.\n      Cleaned up its appearance.`\n      Added the 'type' to the fields that -DDEBUG\n      prints.\n    * dwarf_form.c,dwarf_util.c: The DW_DLE_FORM_BLOCK_LENGTH_ERROR\n      error messages now have a longer and more\n      complete error string.\n2020-03-26: David Anderson\n    * dwarf_alloc.c,dwarf_error.c: Changed spelling of the\n      -DDEBUG prefixes to \"libdwarfdetector\"\n    * libdwarf2.1.mm: Documented hints on finding libdwarf\n      and libdwarf-caller memory leaks. Section 6.33\n    * libdwarf2.1.pdf: Regenerated, version 2.89\n2020-03-26: David Anderson\n    * dwarf_alloc.c,dwarf_error.c:  Now DEBUG can be turned on via\n      CFLAGS at configure time. Or left off by default.\n      Changed all the fprintf here (debug stuff) to\n      do printf instead.\n    * dwarf_die_deliv.c,dwarf_frame2.c: Altered the \n      DW_DLE_ADDRESS_SIZE_ERROR\n      strings so the 3 cases can be distinquished easily\n      (just a convenience for debugging).\n    * dwarf_globals.c: Removed one superfluous ().\n    * dwarf_query.c: Reforatted lgpl text for shorter\n      lines (no change in the content).\n      Removed one superfluous ().\n2020-03-25: David Anderson\n    * dwarf_alloc.c, dwarf_error.c: Revised the debug\n      output created if DEBUG is defined.\n2020-03-25: David Anderson\n    * dwarf_die_deliv.c: Fix trailing whitespace.\n    * dwarf_frame2.c:    Fix trailing whitespace.\n2020-03-24: David Anderson\n    * dwarf_line.c: Deleted useless blank line.\n2020-03-24: David Anderson\n    * dwarf_alloc.c: Now with #ifdef DEBUG of debug messages in\n      various places as thise get needed over and over.\n    * dwarf_die_deliv.c: Working toward complete dealloc\n      of resources to eliminate the  dependence on de_alloc_tree.\n    * dwarf_error.c: #if 0 a debug message.\n    * dwarf_form.c: Remove superflous ().\n    * dwarf_global.c(_dwarf_internal_globals_dealloc):\n      Recreated and documented critical dealloc code\n      so Dwarf_Global_Context gets dealloc-c.\n    * dwarf_line.c: Add a return DW_DLV_ERROR after\n      an error Dwarf_Error is created..\n2020-03-23: David Anderson\n    * dwarf_die_deliv.c,dwarf_frame2.c: Some error messages\n      are now far more precise (showing values).\n    * dwarf_global.c: Correcting leakage and making\n      some error messages more precise.\n    * dwarf_print_lines.c: Correcting leakages.\n    * dwarf_pubtypes.c: Minor readability change.\n2020-03-21: David Anderson\n    * dwarf_abbrev.c Move leb wrapper functions to dwarf_util.[ch]:\n      and rename as _dwarf.....\n      Make certain error conditions more explicit (better\n      text in the error string).\n    * dwarf_die_deliv.c: Move leb wrapper functions to dwarf_util.[ch]\n      and rename as _dwarf.....\n    * dwarf_frame2.c: Add {} for the few 'if' missing same.\n    * dwarf_line.c: In case of form error make the error\n      text more useful.\n    * dwarf_query.c: Move leb wrapper functions to dwarf_util.[ch]\n      and rename as _dwarf.....\n    * dwarf_util.c, dwarf_util.h: Add the renamed\n      _dwarf_leb128_uword_wrapper() and\n      _dwarf_leb128_sword_wrapper() for general use\n      where better error messages are advisable.\n    * dwarf_init_finish.c: Removed a single trailing blank.\n    * libdwarf.h.in: Removed trailing spaces.\n    * generated_libdwarf.h.in: Regenerated.\n2020-03-20: David Anderson\n    * dwarf_arange.c: In case of error, was failing\n      to clean up all allocations.\n    * dwarf_macro5.c: Was preventing some dwarf_dealloc().\n      Fixed.\n2020-03-19: David Anderson\n    * dwarf_abbrev.c: Generates a more useful and specific\n      message in case a TAG is corrupt.\n    * dwarf_line.c: After dealloc assign 0 to the pointer.\n    * dwarf_die_deliv.c: Improved insert_into_context_list()\n      for clarity and correctness. \n    * dwarf_error.c: Removed a couple \"!= NULL\" in if\n      conditions.\n    * dwarf_query.c: Uses local variable now to\n      satisfy the usual libdwarf convention that in case\n      of DW_DLV_NO_ENTRY or DW_DLV_ERROR only the\n      Dwarf_Error argument is altered, not other\n      pointer args.\n    * dwarf_util.h: Declaration for _dwarf_format_TAG_err_msg()\n    * dwarf_util.c: Generates a more useful and specific\n      message in in _dwarf_format_TAG_err_msg()\n      in case a TAG is corrupt.\n2020-03-18: David Anderson\n    * dwarf_die_deliv.c: Rewrote the function that\n      keeps the cu_context list in the proper order.\n      For clarity and correctness.\n2020-03-16: David Anderson\n    * dwarf_alloc.c: A recent change had the wrong\n      test during initial Dwarf_Debug\n      struct setup meaning dwarf_finish() was not cleaning\n      up allocations. This made the runtimes better\n      than they should be. Important correction here.\n    * dwarf_die_deliv.c: Drop use of the dwarf_dieoff()\n      context list, that was never appropriate. Now\n      again with one list.\n    * dwarf_opaque.h: Removed a list of Dwarf_CU_Contexts,\n      that was never correct to have dwarf_offdie maintain\n      a list separate from iterating through CUs.\n    * dwarf_query.c (dwarf_attrlist): Add a \n      dwarf_dealloc on abbrev_list\n      in an error case.\n    * dwarf_util.c: Make the lines look a tiny bit\n      better avoiding too-long lines.\n2020-03-15: David Anderson\n    * dwarf_frame2.c: On an internal error (bad dwarf)\n      the necessary cleanup function was not being called\n      in two places.\n2020-03-15: David Anderson\n    * dwarf_alloc.c: Now with configure-time options\n      for tracking the alloc/dealloc actions in detail.\n2020-03-15: David Anderson\n    * dwarf_alloc.c: Now with the de_alloc_tree tests\n      in final form. Respecting dwarf_set_de_alloc_flag().\n2020-03-14: David Anderson\n    * dwarf_alloc.c: Now adds an optional DEBUG\n      macro that libdwarf developers may find useful.\n      Revised the dwarf_dealloc code to not require de_alloc_tree.\n    * dwarf_line.c: Now dwarf_srcfiles() and dwarf_filename()\n      always allocate DW_DLA_STRINGS. Whereas earlier some\n      of the strings were actually in a .debug section,\n      not allocated. \n    * libdwarf2.1.mm: Now dwarf_diename()  and\n      dwarf_die_text are documented\n      as returning static strings that are not be be\n      freed or dwarf_dealloc'd.  This was always true\n      but the documentation said dwarf_dealloc() was\n      required. Don't use dwarf_dealloc on these returned\n      strings.\n    * libdwarf2.1.pdf: Regenerated, version 2.88\n    * dwarf_loc.c: Was incorrectly passing NULL instead\n      of dbg to _dwarf_get_alloc in a few places.\n    * dwarf_util.c, dwarf_global.c: Now checks more for\n      incomplete setup\n      of an internal structure to avoid calling dwarf_dealloc\n      with NULL as the space to be freed.\n2020-03-13: David Anderson\n    * dwarf_abbrev.c: Remove erroneous dwarf_dealloc\n      introduced yesterday. Caused a coredump\n      in FreeBSD 64bit dwarfdump testing.\n    * dwarfstring.c: Introduced an extra zero initializer in\n      the dwarfstring_destructor() as safe and harmless.\n2020-03-12: David Anderson\n    * dwarf_abbrev.c: Use a wrapper on macro\n      DECODE_LEB128_UWORD_CK\n      so we can dwarf_dealloc in case of a problem.\n      And be more thorough in various places\n      for those dwarf_dealloc.\n2020-03-12: David Anderson\n    * dwarf_die_deliv.c:  A local function now explicitly\n      static (_dwarf_siblingof_internal). \n      Following dwarf_dealloc of cudie  we assign 0 to it.`\n      New function local_dealloc_cu_context() enables\n      accurate and full dealloc of a cu context\n      (which means there was some error fount) in\n      an easy and complete way.\n      local_attrlist_dealloc() does similarly for attrlists.\n      A DECODE_LEB128_UWORD_CK now in a wrapper so on error\n      we can dwarf_dealloc a DIE.\n    * dwarf_macro5.c: Now dwarf_dealloc_macro_context() is safe\n      if called with a null argument (and in that case there\n      is nothing to do).\n    * dwarf_opaque.h: Removed _dwarf_siblingof_internal()\n      from the declared functions.\n2020-03-12: David Anderson\n    * dwarf_alloc.h, dwarf_opaque.h: Removed trailing whitespace.\n      Shortened the lines of the LGPL text (the text\n      is unchanged).\n2020-03-12: David Anderson\n    * dwarf_str_offsets.c,dwarf_util.c: Removed trailing whitespace\n      and fixed indent mistakes.\n2020-03-12: David Anderson\n    * dwarf_query.c: Adds wrapper code around some\n      dwarf_util.h macros\n      so in case of a serious DWARF error we can\n      free locally allocated things.\n2020-03-12: David Anderson\n    * dwarf_errmsg_list.h: Corrected DW_DLE_STR_OFFSETS_EXTRA_BYTES\n      text. The error messages have more detail due to \n      the dwarf_str_offsets.c changes below, so fixed\n      the string here.\n2020-03-12: David Anderson\n    * dwarf_macro5.c: Do proper dwarf_dealloc, avoiding\n      a pointless dependency on de_alloc_tree freeing \n      things.\n2020-03-12: David Anderson\n    * dwarf_alloc.c: Minor cleanup that assigns\n      zero after dwarf_dealloc so dead pointers\n      not left around.\n2020-03-12: David Anderson\n    * dwarf_str_offsets.c: Improve messages in case of\n      a serious DWARF error, reporting what is wrong\n      more precisely and allowing a few bytes of all-zero-bits\n      to be allowed at end of section (no error needed).\n2020-03-12: David Anderson\n    * dwarf_util.c: Revise too-long lines and checks for NULL\n      pointers for moderm readability.\n      Improve _dwarf_free_abbrev_hash_table_contents() so\n      it can safely free an incompletely set up hash table.\n2020-03-09: David Anderson\n    * dwarf_alloc.c: Implements optional (at run time)\n      reduced use of the de_alloc_tree search tree\n      as a performance enhancement (see libdwarf2.1.mm/pdf).\n    * dwarf_alloc.h: Declares _dwarf_alloc_tree_counts(),\n      a new hidden function.\n    * libdwarf_version.h: New date string\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n      dwarf_names_new.h: New date string so regenerated\n      these.\n    * libdwarf.h.in: New function dwarf_set_de_alloc_flag()\n      declared.\n    * generated_libdwarf.h.in: Regenerated\n2020-03-02: David Anderson\n    * dwarf_print_lines.c: Removed one-line #if 0\n      code that serves no purpose.\n2020-02-25: David Anderson\n    * dwarf_print_lines.c: Removed space character just before newline\n      as it  has no useful prupose. 3 places.\n2020-02-25: David Anderson\n    * dwarf_names.c,dwarf_names.h, dwarf_names_enum.h,\n      dwarf_names_new.h:\n      libdwarf_version.h: updated version string.\n2020-02-25: David Anderson\n    * dwarf_line_table_reader_common.h: Now with dwarfstring\n      containers in local scopes and easily evaluated\n      as to lifetime and correctness.\n2020-02-25: David Anderson\n    * dwarf_elfread.c: Deleted a #if 0 ...#endif few lines.\n    * dwarf_line.c: Fixed trailing whitespace.\n    * dwarf_line_table_reader_common.h: Removed all use of the\n      old dwarf_printf varargs code.  Instead using dwarfstring\n      and dwarfstring_append_printf_i() etc.\n      And a far simpler _dwarf_printf().\n      No longer any sprintf/snprintf/vsnprintf here.\n    * dwarf_opaque.h: Remove trailing whitespace.\n    * dwarf_print_lines.c: Removed all use of the\n      old dwarf_printf varargs code.\n      No longer any sprintf/snprintf/vsnprintf here.\n    * dwarf_util.c: Delete unused buffersetsize function.\n      Delete now-unuised dwarf_printf()\n    * dwarfstring.c: Now using TRUE FALSE, not DW_DLV anything.\n      No one will be testing the integer return value anyway.\n      Fixed the code where %-4s was truncating if the string\n      to be processed was longer than 4 characters.\n    * dwarfstring.h: Added commentary.\n    * test_dwarfstring.c: New testcase for dwarfstring\n2020-02-21: David Anderson\n    * dwarf_arange.c,dwarf_debuglink.c,dwarf_frame2.c:\n      removed the last sprintf/snprintf, changed to \n      use dwarfstring.h functions.\n2020-02-18: David Anderson\n    * dwarf_line.c: Added free() calls to delete_line_context_itself\n      to avoid a leak that was created in last commit..\n    * dwarf_line.h: Deleted a now-spurious comment.\n    * dwarf_line_table_reader_common.h: Removed an == NULL\n      comparison in favor of a !filename_entry_pairs.\n2020-02-16: David Anderson\n    * libdwarf2.1.mm: Now explains how dwarf_srcfiles()\n      name arrays differ in DWARF5 from earlier\n      debug_info versions. So callers can use\n      the srcfiles array properly.\n    * libdwarf2.1.pdf: Now version 2.87, dated 16 February 2020.\n    * dwarf_line.c, dwarf_line.h,dwarf_print_lines.c,\n      dwarf_line_table_reader_common.h: Recording DW5 line table\n      header data more fully so lines print verbose\n      prints more of the actual line table header.\n2020-02-15: David Anderson\n    * dwarf_elf_access.c,dwarf_init_finish.c: With libelf\n      in use there was a mistake that broke dumping some objects that\n      needed relocations.\n    * dwarf_opaque.h: Corrected a is_rela to r_is_rela\n2020-02-13: David Anderson\n    * dwarf_elfread.c,dwarf_errmsg_list.h: Removed\n      trailing whitespace.\n2020-02-13: David Anderson\n    *  libdwarf_version.h: New version string \n    *  dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n       dwarf_names_new.h: Regenerated with new\n       version string.\n2020-02-13: David Anderson\n     * libdwarf/libdwarf.h.in: Added a new error code to\n       properly distinguish between distinct elf section\n       header issues related to relocations versus\n       other section header issues.\n     * libdwarf/generated_libdwarf.h.in: regenerated\n\n    * dwarf_elf_access.c: Adding local READ_UNALIGNED_SAFE\n      so we can do libelf relocations properly; .rel and .rela.\n    * dwarf_elf_defines.h: Adding R_386_PC32 to the \n      applicable relocation sets.\n    * dwarf_elf_load_headers.c: Now we deal with .rel.\n      and .rela. relocations for better completeness.\n      Removed some code duplication and complexity\n      too.\n    * dwarf_elf_rel_detector.c: Deals with R_386_PC32 now.\n    * dwarf_elfread.c: Add READ_UNALIGNED_SAFE so we can\n      do no-libelf relocations properly; .rel and .rela\n    * dwarf_elfread.h: Added gr_is_rela field and\n      two enums RelocRela and RelocOffsetSize so we have\n      type-safety in the argument lists.\n    * dwarf_init_finish.c: A new function ensures we\n      skip various sections we know we do not want to\n      look at.\n    * dwarf_opaque.h: Declare _dwarf_ignorethissection()\n      so libelf and non-libelf can ignore the unwanted\n      sections.\n    *  dwarf_errmsg_list.h: Entry added for the new\n       DW_DLE error code.\n2020-02-11: David Anderson\n    * dwarf_elf_access.c,dwarf_line_table_reader_common.h,\n      dwarf_tied_decls.h:\n      removed trailing whitespace and final blank line.\n2020-02-11: David Anderson\n    * dwarf_init_finish.c: Removed code that was #if 0 #endif\n2020-02-10: David Anderson\n    * dwarf_elf_access.c: Now allows for .rel and .rela.\n    * dwarf_elf_defines.h: Now allows for .rel and .rela.\n    * dwarf_init_finish.c: Now allows for .rel and .rela.\n    * dwarf_opaque.h: Adding dss_is_rela so we can\n      process .rel. sections too.\n2020-01-25: David Anderson\n    * dwarf_form.c: DW_FORM_rnglistx was ommitted from a switch statement.\n      Adding it in fixed the resulting errors in a DWARF5 object file\n      built by clang 9.0.0.0\n2020-01-16: David Anderson\n    * dwarf_alloc.c,dwarf_die_deliv.c,dwarf_form.a,\n      dwarf_query.c,dwarfstring.c,\n      pro_reloc.c,pro_reloc_stream.c,pro_reloc_symbolic.c,\n      pro_section.c,pro_types.c,pro_vars.c,pro_weaks.c,\n      test_dwarfstring.c: Fixed indentations and\n      removed trailing whitespace.\n    * dwarf_xu_index.c: Ensure local Dwarf_Sig8 variables\n      are always initialized. Does not fix any bug but\n      does make it easier to read the code.\n      Fixes indentation and removes trailing whitespace too.\n2020-01-14: David Anderson\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n      dwarf_names_new.h,libdwarf_version.h: Updated version string.\n2020-01-05: David Anderson\n    * dwarf_query.c(dwarf_offset_list): Coverity Scan CID 206598.\n      Now checks for DW_DLV_ERROR where it failed to do so before,\n      and returns an error instead of letting it slip through.\n2020-01-03: David Anderson\n    * dwarf_load_elf_headers.c(dwarf_elf_load_rela_32):\n      Coverity Scan uncovered a memory leak in one\n      case. CID 206524\n", "/*\n  Copyright (C) 2000,2002,2004,2005,2006 Silicon Graphics, Inc.  All Rights Reserved.\n  Portions Copyright (C) 2007-2020 David Anderson. All Rights Reserved.\n  Portions Copyright 2012 SN Systems Ltd. All rights reserved.\n\n  This program is free software; you can redistribute it\n  and/or modify it under the terms of version 2.1 of the\n  GNU Lesser General Public License as published by the Free\n  Software Foundation.\n\n  This program is distributed in the hope that it would be\n  useful, but WITHOUT ANY WARRANTY; without even the implied\n  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n  PURPOSE.\n\n  Further, this software is distributed without any warranty\n  that it is free of the rightful claim of any third person\n  regarding infringement or the like.  Any license provided\n  herein, whether implied or otherwise, applies only to this\n  software file.  Patent licenses, if any, provided herein\n  do not apply to combinations of this program with other\n  software, or any other product whatsoever.\n\n  You should have received a copy of the GNU Lesser General\n  Public License along with this program; if not, write the\n  Free Software Foundation, Inc., 51 Franklin Street - Fifth\n  Floor, Boston MA 02110-1301, USA.\n\n*/\n\n#include \"config.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#include \"dwarf_incl.h\"\n#include \"dwarf_alloc.h\"\n#include \"dwarf_error.h\"\n#include \"dwarf_util.h\"\n#include \"dwarf_line.h\"\n#include \"dwarfstring.h\"\n\n#define PRINTING_DETAILS 1\n/*  for dwarfstring_constructor_static, saving lots of malloc\n    and free but beware: make sure each routine using\n    this DOES NOT call another routine using it.\n    would be safer to have a buffer per function, but\n    currently not necessary. */\nstatic char locallinebuf[200];\n\nstatic void\nprint_line_header(Dwarf_Debug dbg,\n    Dwarf_Bool is_single_tab,\n    Dwarf_Bool is_actuals_tab)\n{\nif (!is_single_tab) {\n    /* Ugly indenting follows, it makes lines shorter to see them better.\n        Best to use a wider text window to really see how it looks.*/\nif (is_actuals_tab) {\n_dwarf_printf(dbg,\"\\nActuals Table\\n\");\n_dwarf_printf(dbg,\n\"                                                         be\\n\"\n\"                                                         ls\\n\"\n\"                                                         ce\\n\"\n\" section    op                                           kq\\n\"\n\" offset     code                address/index    row isa ??\\n\");\n    return;\n} else {\n_dwarf_printf(dbg,\"\\nLogicals Table\\n\");\n_dwarf_printf(dbg,\n\"                                                                              s pe\\n\"\n\"                                                                              tirp\\n\"\n\"                                                                              msoi\\n\"\n\" section          op                                                          tall\\n\"\n\" offset      row  code                address/indx fil lne col disc cntx subp ????\\n\");\n    return;\n}\n}\n\n/* Single level table */\n_dwarf_printf(dbg,\n\"                                                         s b e p e i d\\n\"\n\"                                                         t l s r p s i\\n\"\n\"                                                         m c e o i a s\\n\"\n\" section    op                                       col t k q l l   c\\n\"\n\" offset     code               address     file line umn ? ? ? ? ?\\n\");\n} /* End of function with ugly indenting. */\n\nstatic void\nprint_line_detail(\n    Dwarf_Debug dbg,\n    const char *prefix,\n    int opcode,\n    unsigned curr_line,\n    struct Dwarf_Line_Registers_s * regs,\n    Dwarf_Bool is_single_table, Dwarf_Bool is_actuals_table)\n{\n    dwarfstring m1;\n\n    dwarfstring_constructor_static(&m1,locallinebuf,\n        sizeof(locallinebuf));\n    if(!is_single_table && is_actuals_table) {\n        dwarfstring_append_printf_s(&m1,\"%-15s \",(char *)prefix);\n        dwarfstring_append_printf_i(&m1,\"%3d \",opcode);\n        dwarfstring_append_printf_u(&m1,\"0x%\" DW_PR_XZEROS DW_PR_DUx ,\n            regs->lr_address);\n        dwarfstring_append_printf_u(&m1,\"/%01u\",regs->lr_op_index);\n        dwarfstring_append_printf_u(&m1,\" %5lu\", regs->lr_line);\n        dwarfstring_append_printf_u(&m1,\" %3d\",regs->lr_isa);\n        dwarfstring_append_printf_i(&m1,\"   %1d\", regs->lr_basic_block);\n        dwarfstring_append_printf_i(&m1,\"%1d\\n\",  regs->lr_end_sequence);\n        _dwarf_printf(dbg,dwarfstring_string(&m1));\n        dwarfstring_destructor(&m1);\n        return;\n    }\n    if(!is_single_table && !is_actuals_table) {\n        dwarfstring_append_printf_i(&m1,\n            \"[%3d] \"  /* row number */, curr_line);\n        dwarfstring_append_printf_s(&m1,\n            \"%-15s \",(char *)prefix);\n        dwarfstring_append_printf_i(&m1,\n            \"%3d \",opcode);\n        dwarfstring_append_printf_u(&m1,\n            \"x%\" DW_PR_XZEROS DW_PR_DUx, regs->lr_address);\n        dwarfstring_append_printf_u(&m1,\n            \"/%01u\", regs->lr_op_index);\n        dwarfstring_append_printf_u(&m1,\" %2lu \",regs->lr_file);\n        dwarfstring_append_printf_u(&m1,\"%4lu  \",regs->lr_line);\n        dwarfstring_append_printf_u(&m1,\"%1lu\",regs->lr_column);\n        if (regs->lr_discriminator ||\n            regs->lr_prologue_end ||\n            regs->lr_epilogue_begin ||\n            regs->lr_isa ||\n            regs->lr_is_stmt ||\n            regs->lr_call_context ||\n            regs->lr_subprogram) {\n            dwarfstring_append_printf_u(&m1,\n                \"   x%02\" DW_PR_DUx ,\n                regs->lr_discriminator); /* DWARF4 */\n            dwarfstring_append_printf_u(&m1,\n                \"  x%02\" DW_PR_DUx , regs->lr_call_context); /* EXPERIMENTAL */\n            dwarfstring_append_printf_u(&m1,\n                \"  x%02\" DW_PR_DUx , regs->lr_subprogram); /* EXPERIMENTAL */\n            dwarfstring_append_printf_i(&m1,\n                \"  %1d\", regs->lr_is_stmt);\n            dwarfstring_append_printf_i(&m1,\n                \"%1d\", (int) regs->lr_isa);\n            dwarfstring_append_printf_i(&m1,\n                \"%1d\", regs->lr_prologue_end); /* DWARF3 */\n            dwarfstring_append_printf_i(&m1,\n                \"%1d\", regs->lr_epilogue_begin); /* DWARF3 */\n        }\n        dwarfstring_append(&m1,\"\\n\");\n        _dwarf_printf(dbg,dwarfstring_string(&m1));\n        dwarfstring_destructor(&m1);\n        return;\n    }\n    /*  In the first quoted line below:\n        3d looks better than 2d, but best to do that as separate\n        change and test from two-level-line-tables.  */\n    dwarfstring_append_printf_s(&m1,\n        \"%-15s \",(char *)prefix);\n    dwarfstring_append_printf_i(&m1,\n        \"%2d \",opcode);\n    dwarfstring_append_printf_u(&m1,\n        \"0x%\" DW_PR_XZEROS DW_PR_DUx \" \",\n        regs->lr_address);\n    dwarfstring_append_printf_u(&m1,\n        \"%2lu   \", regs->lr_file);\n    dwarfstring_append_printf_u(&m1,\n        \"%4lu \", regs->lr_line);\n    dwarfstring_append_printf_u(&m1,\n        \"%2lu   \", regs->lr_column);\n    dwarfstring_append_printf_i(&m1,\n        \"%1d \",regs->lr_is_stmt);\n    dwarfstring_append_printf_i(&m1,\n        \"%1d \", regs->lr_basic_block);\n    dwarfstring_append_printf_i(&m1,\n        \"%1d\",regs->lr_end_sequence);\n    if (regs->lr_discriminator ||\n        regs->lr_prologue_end ||\n        regs->lr_epilogue_begin ||\n        regs->lr_isa) {\n        dwarfstring_append_printf_i(&m1,\n            \" %1d\", regs->lr_prologue_end); /* DWARF3 */\n        dwarfstring_append_printf_i(&m1,\n            \" %1d\", regs->lr_epilogue_begin); /* DWARF3 */\n        dwarfstring_append_printf_i(&m1,\n            \" %1d\", regs->lr_isa); /* DWARF3 */\n        dwarfstring_append_printf_u(&m1,\n            \" 0x%\" DW_PR_DUx , regs->lr_discriminator); /* DWARF4 */\n    }\n    dwarfstring_append(&m1, \"\\n\");\n    _dwarf_printf(dbg,dwarfstring_string(&m1));\n    dwarfstring_destructor(&m1);\n}\n\n\n#include \"dwarf_line_table_reader_common.h\"\n\n\nstatic void\nprint_include_directory_details(Dwarf_Debug dbg,\n    unsigned int line_version,\n    Dwarf_Line_Context line_context)\n{\n    Dwarf_Unsigned u = 0;\n    dwarfstring    m4;\n    Dwarf_Unsigned indexbase = 0;\n    Dwarf_Unsigned indexlimit = 0;\n\n    dwarfstring_constructor_static(&m4,locallinebuf,\n        sizeof(locallinebuf));\n    if (line_version == DW_LINE_VERSION5) {\n        unsigned i = 0;\n        unsigned dfcount =\n            line_context->lc_directory_entry_format_count;\n\n        dwarfstring_constructor(&m4);\n        dwarfstring_append_printf_u(&m4,\n            \"  directory entry format count %u\\n\",dfcount);\n        _dwarf_printf(dbg,dwarfstring_string(&m4));\n        dwarfstring_reset(&m4);\n        for ( ; i < dfcount;++i) {\n            struct Dwarf_Unsigned_Pair_s *valpair = 0;\n            const char *tname = 0;\n            const char *fname = 0;\n            int res;\n\n            valpair = line_context->lc_directory_format_values +i;\n            dwarfstring_append_printf_u(&m4,\n                \"  format [%2u] \",i);\n            res = dwarf_get_LNCT_name(valpair->up_first,\n                &tname);\n            if ( res != DW_DLV_OK) {\n                tname = \"<unknown type>\";\n            }\n            dwarfstring_append_printf_u (&m4,\n                \" type 0x%\" DW_PR_XZEROS DW_PR_DUx ,valpair->up_first);\n            dwarfstring_append_printf_s (&m4,\n                \" %-20s\\n\",(char *)tname);\n            res = dwarf_get_FORM_name(valpair->up_second,&fname);\n            if ( res != DW_DLV_OK) {\n                fname = \"<unknown form>\";\n            }\n            dwarfstring_append_printf_u(&m4,\n                \"               code 0x%\" DW_PR_XZEROS DW_PR_DUx ,\n                valpair->up_second);\n            dwarfstring_append_printf_s(&m4,\n                \" %-20s\\n\", (char *)fname);\n            _dwarf_printf(dbg,dwarfstring_string(&m4));\n            dwarfstring_reset(&m4);\n\n        }\n    }\n    /*  Common print of the directories.\n        For DWARF 2,3,4 it has always started\n        the indexing at 0 even though the directory index\n        in line entries starts at 1 (zero meaning\n        current directory at compile time).\n        That is odd, given the non-dash-v printed\n        starting at 1.  So lets adjust for consistency. */\n    if (line_version == DW_LINE_VERSION5) {\n        dwarfstring_append_printf_i(&m4,\n            \"  include directories count %d\\n\",\n            (int) line_context->lc_include_directories_count);\n    } else {\n        if(!line_context->lc_include_directories_count) {\n            dwarfstring_append_printf_i(&m4,\n                \"  include directories count %d\\n\",\n                (int) line_context->lc_include_directories_count);\n        } else {\n            dwarfstring_append_printf_i(&m4,\n                \"  include directories count %d\"\n                \" (index starts at 1)\\n\",\n                (int) line_context->lc_include_directories_count);\n        }\n    }\n    _dwarf_printf(dbg,dwarfstring_string(&m4));\n    dwarfstring_reset(&m4);\n    if (line_version == DW_LINE_VERSION5) {\n        indexbase = 0;\n        indexlimit =  line_context->lc_include_directories_count;\n    } else {\n        indexbase = 1;\n        indexlimit = 1 + line_context->lc_include_directories_count;\n    }\n    for (u = indexbase; u < indexlimit; ++u) {\n        dwarfstring_append_printf_u(&m4,\n            \"  include dir[%u] \",u);\n        dwarfstring_append_printf_s(&m4,\n            \"%s\\n\",(char *)\n            line_context->lc_include_directories[u-indexbase]);\n        _dwarf_printf(dbg,dwarfstring_string(&m4));\n        dwarfstring_reset(&m4);\n    }\n    dwarfstring_destructor(&m4);\n}\n\nstatic void\nprint_just_file_entry_details(Dwarf_Debug dbg,\n    Dwarf_Line_Context line_context)\n{\n    unsigned fiu = 0;\n    Dwarf_File_Entry fe = line_context->lc_file_entries;\n    Dwarf_File_Entry fe2 = fe;\n    dwarfstring m3;\n\n    dwarfstring_constructor_static(&m3,locallinebuf,\n        sizeof(locallinebuf));\n    dwarfstring_append_printf_i(&m3,\n        \"  file names count      %d\\n\",\n        line_context->lc_file_entry_count);\n    _dwarf_printf(dbg,dwarfstring_string(&m3));\n    dwarfstring_reset(&m3);\n    for (fiu = 0 ; fe2 ; fe2 = fe->fi_next,++fiu ) {\n        Dwarf_Unsigned tlm2 = 0;\n        unsigned filenum = 0;\n\n        fe = fe2;\n        tlm2 = fe->fi_time_last_mod;\n        filenum = fiu+1;\n\n        /*  The space character at the end of line is silly,\n            but lets leave it there for the moment to avoid\n            changing output.  */\n        if (line_context->lc_file_entry_count > 9) {\n            dwarfstring_append_printf_u(&m3,\n                \"  file[%2u] \",fiu);\n            dwarfstring_append_printf_s(&m3,\n                \"%-20s \",\n                (char *) fe->fi_file_name);\n            dwarfstring_append_printf_u(&m3,\n                \"(file-number: %u)\\n\",\n                filenum);\n        } else {\n            dwarfstring_append_printf_u(&m3,\n                \"  file[%u]  \", fiu);\n            dwarfstring_append_printf_s(&m3,\n                \"%-20s \",(char *)fe->fi_file_name);\n            dwarfstring_append_printf_u(&m3,\n                \"(file-number: %u)\\n\",filenum);\n        }\n        _dwarf_printf(dbg,dwarfstring_string(&m3));\n        dwarfstring_reset(&m3);\n        if (fe->fi_dir_index_present) {\n            Dwarf_Unsigned di = 0;\n            di = fe->fi_dir_index;\n            dwarfstring_append_printf_i(&m3,\n                \"    dir index %d\\n\", di);\n        }\n        if (fe->fi_time_last_mod_present) {\n            time_t tt = (time_t) tlm2;\n\n            /* ctime supplies newline */\n            dwarfstring_append_printf_u(&m3,\n                \"    last time 0x%x \",tlm2);\n            dwarfstring_append(&m3,(char *)ctime(&tt));\n        }\n        if (fe->fi_file_length_present) {\n            Dwarf_Unsigned fl = 0;\n\n            fl = fe->fi_file_length;\n            dwarfstring_append_printf_i(&m3,\n                \"    file length %ld \",fl);\n            dwarfstring_append_printf_u(&m3,\n                \"0x%lx\\n\",fl);\n        }\n        if (fe->fi_md5_present) {\n            char *c = (char *)&fe->fi_md5_value;\n            char *end = c+sizeof(fe->fi_md5_value);\n            dwarfstring_append(&m3, \"    file md5 value 0x\");\n            while(c < end) {\n                dwarfstring_append_printf_u(&m3,\n                    \"%02x\",0xff&*c);\n                ++c;\n            }\n            dwarfstring_append(&m3,\"\\n\");\n        }\n        if (dwarfstring_strlen(&m3)) {\n            _dwarf_printf(dbg,dwarfstring_string(&m3));\n            dwarfstring_reset(&m3);\n        }\n    }\n    dwarfstring_destructor(&m3);\n}\n\nstatic void\nprint_file_entry_details(Dwarf_Debug dbg,\n    unsigned int line_version,\n    Dwarf_Line_Context line_context)\n{\n    dwarfstring m5;\n\n    dwarfstring_constructor_static(&m5,locallinebuf,\n        sizeof(locallinebuf));\n    if (line_version == DW_LINE_VERSION5) {\n        unsigned i = 0;\n        unsigned dfcount = line_context->lc_file_name_format_count;\n\n        dwarfstring_append_printf_u(&m5,\n            \"  file entry format count      %u\\n\",dfcount);\n        for ( ; i < dfcount;++i) {\n            struct Dwarf_Unsigned_Pair_s *valpair = 0;\n            const char *tname = 0;\n            const char *fname = 0;\n            int res;\n\n            valpair = line_context->lc_file_format_values +i;\n            dwarfstring_append_printf_u(&m5,\n                \"  format [%2u] \",i);\n            res = dwarf_get_LNCT_name(valpair->up_first,&tname);\n            if ( res != DW_DLV_OK) {\n                tname = \"<unknown type>\";\n            }\n            dwarfstring_append_printf_u(&m5,\n                \" type 0x%\" DW_PR_XZEROS DW_PR_DUx,\n                valpair->up_first);\n            dwarfstring_append_printf_s(&m5,\n                \" %-20s\\n\",(char *)tname);\n            res = dwarf_get_FORM_name(valpair->up_second,&fname);\n            if ( res != DW_DLV_OK) {\n                fname = \"<unknown form>\";\n            }\n            dwarfstring_append_printf_u(&m5,\n                \"               code 0x%\"\n                DW_PR_XZEROS DW_PR_DUx,\n                valpair->up_second);\n            dwarfstring_append_printf_s(&m5, \" %-20s\\n\",\n                (char *)fname);\n            _dwarf_printf(dbg,dwarfstring_string(&m5));\n            dwarfstring_reset(&m5);\n        }\n        dwarfstring_destructor(&m5);\n        print_just_file_entry_details(dbg,line_context);\n    } else {\n        print_just_file_entry_details(dbg,line_context);\n        dwarfstring_destructor(&m5);\n    }\n\n}\n\nstatic void\nprint_experimental_subprograms_list(Dwarf_Debug dbg,\n    Dwarf_Line_Context line_context)\n{\n    /*  Print the subprograms list. */\n    Dwarf_Unsigned count = line_context->lc_subprogs_count;\n    Dwarf_Unsigned exu = 0;\n    Dwarf_Subprog_Entry sub = line_context->lc_subprogs;\n    dwarfstring m6;\n\n    dwarfstring_constructor_static(&m6,locallinebuf,\n        sizeof(locallinebuf));\n    dwarfstring_append_printf_u(&m6,\n        \"  subprograms count %\" DW_PR_DUu \"\\n\",count);\n    if (count > 0) {\n        dwarfstring_append(&m6,\"    indx  file   line   name\\n\");\n    }\n    _dwarf_printf(dbg,dwarfstring_string(&m6));\n    dwarfstring_reset(&m6);\n    for (exu = 0 ; exu < count ; exu++,sub++) {\n        dwarfstring_append_printf_u(&m6,\n            \"    [%2\" DW_PR_DUu,exu+1);\n        dwarfstring_append_printf_u(&m6,\n            \"] %4\" DW_PR_DUu,sub->ds_decl_file);\n        dwarfstring_append_printf_u(&m6,\n            \"    %4\" DW_PR_DUu ,sub->ds_decl_line);\n        dwarfstring_append_printf_s(&m6,\n            \" %s\\n\",(char *)sub->ds_subprog_name);\n        _dwarf_printf(dbg,dwarfstring_string(&m6));\n        dwarfstring_reset(&m6);\n    }\n    dwarfstring_destructor(&m6);\n}\n\nstatic void\ndo_line_print_now(Dwarf_Debug dbg,int line_version,\n    Dwarf_Small * comp_dir,\n    Dwarf_Line_Context line_context) ;\nstatic void print_experimental_counts(Dwarf_Debug dbg,\n    int line_version,\n    Dwarf_Line_Context line_context);\n\nstatic int print_actuals_and_locals(Dwarf_Debug dbg,\n    Dwarf_Line_Context line_context,\n    Dwarf_Unsigned bogus_bytes_count,\n    Dwarf_Small *bogus_bytes_ptr,\n    Dwarf_Small *orig_line_ptr,\n    Dwarf_Small *line_ptr,\n    Dwarf_Small *section_start,\n    Dwarf_Small *line_ptr_actuals,\n    Dwarf_Small *line_ptr_end,\n    Dwarf_Half   address_size,\n    int *        err_count_out,\n    Dwarf_Error *err);\n\n/*  return DW_DLV_OK if ok. else DW_DLV_NO_ENTRY or DW_DLV_ERROR\n    If err_count_out is non-NULL, this is a special 'check'\n    call.  */\nstatic int\n_dwarf_internal_printlines(Dwarf_Die die,\n    int * err_count_out,\n    int only_line_header,\n    Dwarf_Error * error)\n{\n    /*  This pointer is used to scan the portion of the .debug_line\n        section for the current cu. */\n    Dwarf_Small *line_ptr = 0;\n    Dwarf_Small *orig_line_ptr = 0;\n\n    /*  Pointer to a DW_AT_stmt_list attribute in case it exists in the\n        die. */\n    Dwarf_Attribute stmt_list_attr = 0;\n\n    /*  Pointer to DW_AT_comp_dir attribute in die. */\n    Dwarf_Attribute comp_dir_attr = 0;\n\n    /*  Pointer to name of compilation directory. */\n    Dwarf_Small *comp_dir = NULL;\n\n    /*  Offset into .debug_line specified by a DW_AT_stmt_list\n        attribute. */\n    Dwarf_Unsigned line_offset = 0;\n\n    /*  These variables are used to decode leb128 numbers. Leb128_num\n        holds the decoded number, and leb128_length is its length in\n        bytes. */\n    Dwarf_Half attrform = 0;\n\n    /*  In case there are wierd bytes 'after' the line table\n        prologue this lets us print something. This is a gcc\n        compiler bug and we expect the bytes count to be 12.  */\n    Dwarf_Small* bogus_bytes_ptr = 0;\n    Dwarf_Unsigned bogus_bytes_count = 0;\n    Dwarf_Half address_size = 0;\n    Dwarf_Unsigned fission_offset = 0;\n    unsigned line_version = 0;\n\n\n    /* The Dwarf_Debug this die belongs to. */\n    Dwarf_Debug dbg = 0;\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Line_Context line_context = 0;\n    int resattr = DW_DLV_ERROR;\n    int lres =    DW_DLV_ERROR;\n    int res  =    DW_DLV_ERROR;\n    Dwarf_Small *line_ptr_actuals  = 0;\n    Dwarf_Small *line_ptr_end = 0;\n    Dwarf_Small *section_start = 0;\n\n    /* ***** BEGIN CODE ***** */\n\n    if (error != NULL) {\n        *error = NULL;\n    }\n\n    CHECK_DIE(die, DW_DLV_ERROR);\n    cu_context = die->di_cu_context;\n    dbg = cu_context->cc_dbg;\n\n    res = _dwarf_load_section(dbg, &dbg->de_debug_line,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    if (!dbg->de_debug_line.dss_size) {\n        return (DW_DLV_NO_ENTRY);\n    }\n\n    address_size = _dwarf_get_address_size(dbg, die);\n    resattr = dwarf_attr(die, DW_AT_stmt_list, &stmt_list_attr, error);\n    if (resattr != DW_DLV_OK) {\n        return resattr;\n    }\n    /*  The list of relevant FORMs is small.\n        DW_FORM_data4, DW_FORM_data8, DW_FORM_sec_offset\n    */\n    lres = dwarf_whatform(stmt_list_attr,&attrform,error);\n    if (lres != DW_DLV_OK) {\n        dwarf_dealloc(dbg,stmt_list_attr, DW_DLA_ATTR);\n        return lres;\n    }\n    if (attrform != DW_FORM_data4 && attrform != DW_FORM_data8 &&\n        attrform != DW_FORM_sec_offset ) {\n        dwarf_dealloc(dbg,stmt_list_attr, DW_DLA_ATTR);\n        _dwarf_error(dbg, error, DW_DLE_LINE_OFFSET_BAD);\n        return (DW_DLV_ERROR);\n    }\n    lres = dwarf_global_formref(stmt_list_attr, &line_offset, error);\n    if (lres != DW_DLV_OK) {\n        dwarf_dealloc(dbg,stmt_list_attr, DW_DLA_ATTR);\n        return lres;\n    }\n\n    if (line_offset >= dbg->de_debug_line.dss_size) {\n        dwarf_dealloc(dbg,stmt_list_attr, DW_DLA_ATTR);\n        _dwarf_error(dbg, error, DW_DLE_LINE_OFFSET_BAD);\n        return (DW_DLV_ERROR);\n    }\n    section_start =  dbg->de_debug_line.dss_data;\n    {\n        Dwarf_Unsigned fission_size = 0;\n        int resfis = _dwarf_get_fission_addition_die(die, DW_SECT_LINE,\n            &fission_offset,&fission_size,error);\n        if(resfis != DW_DLV_OK) {\n            dwarf_dealloc(dbg,stmt_list_attr, DW_DLA_ATTR);\n            return resfis;\n        }\n    }\n\n    orig_line_ptr = section_start + line_offset + fission_offset;\n    line_ptr = orig_line_ptr;\n    dwarf_dealloc(dbg, stmt_list_attr, DW_DLA_ATTR);\n\n    /*  If die has DW_AT_comp_dir attribute, get the string that names\n        the compilation directory. */\n    resattr = dwarf_attr(die, DW_AT_comp_dir, &comp_dir_attr, error);\n    if (resattr == DW_DLV_ERROR) {\n        return resattr;\n    }\n    if (resattr == DW_DLV_OK) {\n        int cres = DW_DLV_ERROR;\n        char *cdir = 0;\n\n        cres = dwarf_formstring(comp_dir_attr, &cdir, error);\n        if (cres == DW_DLV_ERROR) {\n            return cres;\n        } else if (cres == DW_DLV_OK) {\n            comp_dir = (Dwarf_Small *) cdir;\n        }\n    }\n    if (resattr == DW_DLV_OK) {\n        dwarf_dealloc(dbg, comp_dir_attr, DW_DLA_ATTR);\n    }\n    line_context = (Dwarf_Line_Context)\n        _dwarf_get_alloc(dbg, DW_DLA_LINE_CONTEXT, 1);\n    if (line_context == NULL) {\n        _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);\n        return (DW_DLV_ERROR);\n    }\n    {\n        Dwarf_Small *newlinep = 0;\n        int dres = _dwarf_read_line_table_header(dbg,\n            cu_context,\n            section_start,\n            line_ptr,\n            dbg->de_debug_line.dss_size,\n            &newlinep,\n            line_context,\n            &bogus_bytes_ptr,\n            &bogus_bytes_count,\n            error,\n            err_count_out);\n        if (dres == DW_DLV_ERROR) {\n            dwarf_srclines_dealloc_b(line_context);\n            return dres;\n        }\n        if (dres == DW_DLV_NO_ENTRY) {\n            dwarf_srclines_dealloc_b(line_context);\n            return dres;\n        }\n        line_ptr_end = line_context->lc_line_ptr_end;\n        line_ptr = newlinep;\n        if (line_context->lc_actuals_table_offset > 0) {\n            line_ptr_actuals = line_context->lc_line_prologue_start +\n                line_context->lc_actuals_table_offset;\n        }\n    }\n    line_version = line_context->lc_version_number;\n    line_context->lc_compilation_directory = comp_dir;\n    if (only_line_header) {\n        /* Just checking for header errors, nothing more here.*/\n        dwarf_srclines_dealloc_b(line_context);\n        return DW_DLV_OK;\n    }\n    do_line_print_now(dbg,line_version,comp_dir,line_context);\n    print_include_directory_details(dbg,line_version,line_context);\n    print_file_entry_details(dbg,line_version,line_context);\n    print_experimental_counts(dbg, line_version,line_context);\n    res = print_actuals_and_locals(dbg, line_context,\n        bogus_bytes_count,bogus_bytes_ptr,\n        orig_line_ptr,\n        line_ptr,\n        section_start,\n        line_ptr_actuals,\n        line_ptr_end,\n        address_size,\n        err_count_out,\n        error);\n    if (res  !=  DW_DLV_OK) {\n        return res;\n    }\n    return DW_DLV_OK;\n}\n\nstatic void\ndo_line_print_now(Dwarf_Debug dbg,\n    int line_version,\n    Dwarf_Small *comp_dir,\n    Dwarf_Line_Context line_context)\n{\n    dwarfstring m7;\n    Dwarf_Unsigned i = 0;\n\n    dwarfstring_constructor(&m7);\n    dwarfstring_append_printf_i(&m7,\n        \"total line info length %ld bytes,\",\n        line_context->lc_total_length);\n\n    dwarfstring_append_printf_u(&m7,\n        \" line offset 0x%\" DW_PR_XZEROS DW_PR_DUx,\n        line_context->lc_section_offset);\n\n    dwarfstring_append_printf_u(&m7,\n        \" %\" DW_PR_DUu \"\\n\",\n        line_context->lc_section_offset);\n\n    if (line_version <= DW_LINE_VERSION5) {\n        dwarfstring_append_printf_i(&m7,\n            \"  line table version     %d\\n\",\n        (int) line_context->lc_version_number);\n    } else {\n        dwarfstring_append_printf_u(&m7,\n            \"  line table version 0x%x\\n\",\n            (int) line_context->lc_version_number);\n    }\n    if (line_version == DW_LINE_VERSION5) {\n        dwarfstring_append_printf_i(&m7,\n            \"  address size          %d\\n\",\n            line_context->lc_address_size);\n        dwarfstring_append_printf_i(&m7,\n            \"  segment selector size %d\\n\",\n            line_context->lc_segment_selector_size);\n    }\n    _dwarf_printf(dbg,dwarfstring_string(&m7));\n    dwarfstring_reset(&m7);\n    dwarfstring_append_printf_i(&m7,\n        \"  line table length field length %d\\n\",\n        line_context->lc_length_field_length);\n    dwarfstring_append_printf_i(&m7,\n        \"  prologue length       %d\\n\",\n        line_context->lc_prologue_length);\n    dwarfstring_append_printf_s(&m7,\n        \"  compilation_directory %s\\n\",\n        comp_dir ? ((char *) comp_dir) : \"\");\n\n    dwarfstring_append_printf_i(&m7,\n        \"  min instruction length %d\\n\",\n        line_context->lc_minimum_instruction_length);\n    _dwarf_printf(dbg,dwarfstring_string(&m7));\n    dwarfstring_reset(&m7);\n    if (line_version == DW_LINE_VERSION5 ||\n        line_version == DW_LINE_VERSION4 ||\n        line_version == EXPERIMENTAL_LINE_TABLES_VERSION) {\n        dwarfstring_append_printf_u(&m7,\n            \"  maximum ops per instruction %u\\n\",\n            line_context->lc_maximum_ops_per_instruction);\n        _dwarf_printf(dbg,dwarfstring_string(&m7));\n        dwarfstring_reset(&m7);\n    }\n    if (line_version == EXPERIMENTAL_LINE_TABLES_VERSION) {\n        dwarfstring_append_printf_u(&m7, \"  actuals table offset \"\n            \"0x%\" DW_PR_XZEROS DW_PR_DUx \"\\n\",\n            line_context->lc_actuals_table_offset);\n        dwarfstring_append_printf_u(&m7,\"  logicals table offset \"\n            \"0x%\" DW_PR_XZEROS DW_PR_DUx \"\\n\",\n            line_context->lc_logicals_table_offset);\n        _dwarf_printf(dbg,dwarfstring_string(&m7));\n        dwarfstring_reset(&m7);\n    }\n    dwarfstring_append_printf_i(&m7,\n        \"  default is stmt        %d\\n\",\n        (int)line_context->lc_default_is_stmt);\n    dwarfstring_append_printf_i(&m7,\n        \"  line base              %d\\n\",\n        (int)line_context->lc_line_base);\n    dwarfstring_append_printf_i(&m7,\n        \"  line_range             %d\\n\",\n        (int)line_context->lc_line_range);\n    dwarfstring_append_printf_i(&m7,\n        \"  opcode base            %d\\n\",\n        (int)line_context->lc_opcode_base);\n    dwarfstring_append_printf_i(&m7,\n        \"  standard opcode count  %d\\n\",\n        (int)line_context->lc_std_op_count);\n    _dwarf_printf(dbg,dwarfstring_string(&m7));\n    dwarfstring_reset(&m7);\n\n    for (i = 1; i < line_context->lc_opcode_base; i++) {\n        dwarfstring_append_printf_i(&m7,\n            \"  opcode[%2d] length\", (int) i);\n        dwarfstring_append_printf_i(&m7,\n            \"  %d\\n\",\n            (int) line_context->lc_opcode_length_table[i - 1]);\n        _dwarf_printf(dbg,dwarfstring_string(&m7));\n        dwarfstring_reset(&m7);\n    }\n    dwarfstring_destructor(&m7);\n}\n\nstatic void\nprint_experimental_counts(Dwarf_Debug dbg, int line_version,\n    Dwarf_Line_Context line_context)\n{\n    if (line_version == EXPERIMENTAL_LINE_TABLES_VERSION) {\n        print_experimental_subprograms_list(dbg,line_context);\n    }\n}\n\nstatic int\nprint_actuals_and_locals(Dwarf_Debug dbg,\n    Dwarf_Line_Context line_context,\n    Dwarf_Unsigned bogus_bytes_count,\n    Dwarf_Small *bogus_bytes_ptr,\n    Dwarf_Small *orig_line_ptr,\n    Dwarf_Small *line_ptr,\n    Dwarf_Small *section_start,\n    Dwarf_Small *line_ptr_actuals,\n    Dwarf_Small *line_ptr_end,\n    Dwarf_Half   address_size,\n    int *        err_count_out,\n    Dwarf_Error *error)\n{\n    int res = 0;\n    dwarfstring m8;\n    Dwarf_Unsigned offset = 0;\n\n    dwarfstring_constructor(&m8);\n    if (bogus_bytes_count > 0) {\n        Dwarf_Unsigned wcount = bogus_bytes_count;\n        Dwarf_Unsigned boffset = bogus_bytes_ptr - section_start;\n\n        dwarfstring_append_printf_u(&m8,\n            \"*** DWARF CHECK: the line table prologue  header_length \"\n            \" is %\" DW_PR_DUu \" too high, we pretend it is smaller.\",\n            wcount);\n        dwarfstring_append_printf_u(&m8,\n            \"Section offset: 0x%\"\n            DW_PR_XZEROS DW_PR_DUx,\n            boffset);\n        dwarfstring_append_printf_u(&m8,\n            \" (%\" DW_PR_DUu \") ***\\n\",\n            boffset);\n        *err_count_out += 1;\n    }\n    offset = line_ptr - section_start;\n    dwarfstring_append_printf_u(&m8,\n        \"  statement prog offset in section: 0x%\"\n        DW_PR_XZEROS DW_PR_DUx,\n        offset);\n    dwarfstring_append_printf_u(&m8,\n        \" (%\" DW_PR_DUu \")\\n\",\n        offset);\n    _dwarf_printf(dbg,dwarfstring_string(&m8));\n    dwarfstring_reset(&m8);\n\n    {\n        Dwarf_Bool doaddrs = false;\n        Dwarf_Bool dolines = true;\n\n        if (!line_ptr_actuals) {\n            /* Normal single level line table. */\n\n            Dwarf_Bool is_single_table = true;\n            Dwarf_Bool is_actuals_table = false;\n            print_line_header(dbg, is_single_table, is_actuals_table);\n            res = read_line_table_program(dbg,\n                line_ptr, line_ptr_end, orig_line_ptr,\n                section_start,\n                line_context,\n                address_size, doaddrs, dolines,\n                is_single_table,\n                is_actuals_table,\n                error,\n                err_count_out);\n            if (res != DW_DLV_OK) {\n                dwarfstring_destructor(&m8);\n                dwarf_srclines_dealloc_b(line_context);\n                return res;\n            }\n        } else {\n            Dwarf_Bool is_single_table = false;\n            Dwarf_Bool is_actuals_table = false;\n            if (line_context->lc_version_number !=\n                EXPERIMENTAL_LINE_TABLES_VERSION) {\n                dwarf_srclines_dealloc_b(line_context);\n                dwarfstring_destructor(&m8);\n                _dwarf_error(dbg, error, DW_DLE_VERSION_STAMP_ERROR);\n                return (DW_DLV_ERROR);\n            }\n            /* Read Logicals */\n            print_line_header(dbg, is_single_table, is_actuals_table);\n            res = read_line_table_program(dbg,\n                line_ptr, line_ptr_actuals, orig_line_ptr,\n                section_start,\n                line_context,\n                address_size, doaddrs, dolines,\n                is_single_table,\n                is_actuals_table,\n                error,err_count_out);\n            if (res != DW_DLV_OK) {\n                dwarfstring_destructor(&m8);\n                dwarf_srclines_dealloc_b(line_context);\n                return res;\n            }\n            if (line_context->lc_actuals_table_offset > 0) {\n                is_actuals_table = true;\n                /* Read Actuals */\n\n                print_line_header(dbg, is_single_table, is_actuals_table);\n                res = read_line_table_program(dbg,\n                    line_ptr_actuals, line_ptr_end, orig_line_ptr,\n                    section_start,\n                    line_context,\n                    address_size, doaddrs, dolines,\n                    is_single_table,\n                    is_actuals_table,\n                    error,\n                    err_count_out);\n                if (res != DW_DLV_OK) {\n                    dwarfstring_destructor(&m8);\n                    dwarf_srclines_dealloc_b(line_context);\n                    return res;\n                }\n            }\n        }\n    }\n    dwarfstring_destructor(&m8);\n    dwarf_srclines_dealloc_b(line_context);\n    return DW_DLV_OK;\n}\n\n\n\n/*  This is support for dwarfdump: making it possible\n    for clients wanting line detail info on stdout\n    to get that detail without including internal libdwarf\n    header information.\n    Caller passes in compilation unit DIE.\n    The _dwarf_ version is obsolete (though supported for\n    compatibility).\n    The dwarf_ version is preferred.\n    The functions are intentionally identical: having\n    _dwarf_print_lines call dwarf_print_lines might\n    better emphasize they are intentionally identical, but\n    that seemed slightly silly given how short the functions are.\n    Interface adds error_count (output value) February 2009.\n\n    These *print_lines() functions print two-level tables in full\n    even when the user is not asking for both (ie, when\n    the caller asked for dwarf_srclines().\n    It was an accident, but after a short reflection\n    this seems like a good idea for -vvv. */\nint\ndwarf_print_lines(Dwarf_Die die,\n    Dwarf_Error * error,\n    int *error_count)\n{\n    int only_line_header = 0;\n    int res = _dwarf_internal_printlines(die,\n        error_count,\n        only_line_header,error);\n    return res;\n}\nint\n_dwarf_print_lines(Dwarf_Die die, Dwarf_Error * error)\n{\n    int only_line_header = 0;\n    int err_count = 0;\n    int res = _dwarf_internal_printlines(die,\n        &err_count,\n        only_line_header,error);\n    /* No way to get error count back in this interface */\n    return res;\n}\n\n/* The check is in case we are not printing full line data,\n   this gets some of the issues noted with .debug_line,\n   but not all. Call dwarf_print_lines() to get all issues.\n   Intended for apps like dwarfdump.\n   dwarf_check_lineheader_b() new 14 April 2020.\n*/\nint\ndwarf_check_lineheader_b(Dwarf_Die die, int *err_count_out,\n    Dwarf_Error *err)\n{\n    int res = 0;\n\n    int only_line_header = 1;\n    res = _dwarf_internal_printlines(die,err_count_out,\n        only_line_header,err);\n    return res;\n}\n\n/*  This is ugly, no way to detect errors. They get ignored.\n    see dwarf_check_lineheader_b() above. */\nvoid\ndwarf_check_lineheader(Dwarf_Die die, int *err_count_out)\n{\n    int res = 0;\n    Dwarf_Error err = 0;\n\n    int only_line_header = 1;\n    res = _dwarf_internal_printlines(die,err_count_out,\n        only_line_header,&err);\n    if (res == DW_DLV_ERROR) {\n        Dwarf_CU_Context c = 0;\n        Dwarf_Debug dbg = 0;\n\n        c = die->di_cu_context;\n        if (!c) {\n            return;\n        }\n        dbg = c->cc_dbg;\n        dwarf_dealloc(dbg,err,DW_DLA_ERROR);\n        err = 0;\n    }\n}\n"], "fixing_code": ["2020-10-28: David Anderson\n    * dwarf_print_lines.c: In case of corrupted\n      DWARF5 line header the fi_file_name field\n      for a file entry can be null. Now\n      we print a <no file name> string in that case\n      to avoid passing a null to dwarfstring_append.\n      Dwarfbug DW202010-003.\n      Also some lines longer than libdwarf standard\n      were shortened, but a few long lines really\n      must remain.\n2020-10-28: David Anderson\n    * dwarf_ranges.c: Altered lines longer than libdwarf\n      standard.\n2020-10-27: David Anderson\n    * dwarf_generic_init.c: Now checks for a null PATH\n      passed to dwarf_init_path() or dwarf_init_path_dl()\n      and returns error.\n2020-10-20: David Anderson\n    * libdwarf_version.h: updated version string\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n      dwarf_names_new.h: regenerated with new version string.\n    * crc32.c: Computing from first principles.  LGPL 2.1\n2020-10-19: David Anderson\n    * dwarf_line_table_reader_common.h: Everywhere ptr - ptr\n      generates an unnamed ptrdiff_t is called out by\n      a short comment.\n2020-10-19: David Anderson\n    * crc32.c,dwarf_debuglink.c,dwarf_die_deliv.c,dwarf_line.c,\n\t  dwarf_line.h,dwarf_line_table_reader_common.h,dwarf_query.c,\n\t  dwarf_str_offsets.c: Fixed indents and removed\n      trailing whitespace.\n2020-10-19: David Anderson\n    * crc32.c: Revised line lengths to under\n      20 characters for a better appearance.\n      No change in wording.\n\t* pro_frame.c,pro_funcs.c: Removed a blank line\n      before the copyright text for a better appearance.\n2020-10-19: David Anderson\n    * dwarf_arange.h,dwarf_base_types.h,dwarf_die_deliv.h,\n\t  dwarf_dsc.h,dwarf_elf_access.h,dwarf_errmsg_list.h,\n\t  dwarf_error.h,dwarf_frame.h,dwarf_funcs.h,dwarf_gdbindex.h,\n\t  dwarf_global.h,dwarf_harmless.h,dwarf_line.h,dwarf_macro.h,\n\t  dwarf_macro5.h,dwarf_reloc_386.h,dwarf_reloc_arm.h,\n\t  dwarf_reloc_mips.h,dwarf_reloc_ppc.h,dwarf_reloc_ppc64.h,\n\t  dwarf_reloc_x86_64.h,dwarf_tied_decls.h,dwarf_types.h,\n\t  dwarf_util.h,dwarf_vars.h,dwarf_weaks.h,dwarf_xu_index.h,\n\t  libdwarfdefs.h,malloc_check.h,pro_alloc.h,pro_arange.h,\n\t  pro_die.h,pro_encode_nm.h,pro_error.h,pro_expr.h,\n\t  pro_frame.h,pro_incl.h,pro_macinfo.h,pro_reloc.h,\n\t  pro_reloc_stream.h,pro_reloc_symbolic.h,pro_section.h,\n\t  pro_types.h,pro_util.h: License text reformatted\n      to fit libdwarf line lengths. No change in terms.\n2020-10-19: David Anderson\n    *  dwarf_debuglink.c,dwarf_die_deliv.c,dwarf_query.c,\n\t   dwarf_str_offsets.c,dwarf_util.c: These no longer\n       explicitly use ptrdiff_t. Only non-negative pointer\n       differences are converted to unsigned. The other\n       side of a compare is given an appropriate constant unsigned\n       value that will cause an immediate error (this side\n       represents an astonishing and impossible situation).\n    * crc32.c,dwarf_alloc.c,dwarf_crc32.c,dwarf_debuglink.c,\n      dwarf_die_deliv.c,dwarf_elf_access.c,dwarf_elf_load_headers.c,\n      dwarf_elfread.c,dwarf_error.c dwarf_generic_init.c,\n      dwarf_init_finish.c,dwarf_machoread.c,dwarf_object_detector.c,\n      dwarf_object_read_common.c,dwarf_original_elf_init.c,\n      dwarf_peread.c,dwarf_query.c,dwarf_str_offsets.c,\n      dwarf_util.c,pro_error.c,test_linkedtopath.c: Consistent\n      use of HAVE_SYS_STATS_H throughout.\n2020-10-17: David Anderson\n    * libdwarf_version.h: updated version string\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n      dwarf_names_new.h: regenerated with new version string.\n2020-10-15: David Anderson\n    * dwarf_line.c:Set up the default registers correctly\n      for DWARF5 as well as earlier versions.\n    * dwarf_line.h: update a comment.\n    * dwarf_line_table_reader_common.c: Using ptrdiff_t\n      is completely unnecessary. So not using now.\n      Removing with #if 0 some lines of checking code\n      which are now up a few lines in a corrected\n      version of earlier checking.\n    * libdwarf2.1.pdf: Regenerated 3.15. Forgot\n      to do it earlier.\n2020-10-13: David Anderson\n    * dwarf_debuglink.c: Now _dwarf_pathjoinl works\n      for Windows too (see HAVE_WINDOWS_PATH) and\n      transforms all backslash to /.  This\n      has always been the behavior, it just vanished\n      for a couple days.\n    * dwarf_line_table_reader_common.h: Removed a trailing blank.\n    * dwarf_macro5.c: Now correctly handles the null byte\n      at the end of a list of macro operands. Added\n      macro CHECKNULLCONTEXT to avoid lots of 8 line\n      sequences just checking basic call sanity.\n      Gave the structure sentinal a name: MC_SENTINAL\n      (only exists in this one source file).\n    * dwarf_macro5.h: Added mc_section_size so offset\n      insanity is caught.  Added comments about\n      Dwarf_Macro_Operator_s for clarity.\n    * libdwarf.h;.in: Added comment on the DWARF 5\n      macro operands table.\n    * libdwarf2.1.mm: Rev 3.15 Added a comment in examplep5\n      on dwarf_get_macro_op() about the DWARF5\n      macro operator value 0, and\n      amplified the function wording on this point..\n    * libdwarf2.1.pdf: Rev 3.15. Regenerated.\n      .\n2020-10-12: David Anderson\n    * dwarf_alloc.c: Creation of Dwarf_Error_ with\n      null dbg is now gracefully handled.\n    * dwarf_debuglink.c: Now handles\n      HAVE_WINDOWS_PATH. Needed additional #include\n      and create_fullest_file_path() now uses dwarfstsring.\n    * dwarf_line.h: Trailing whitespace.\n    * dwarf_line_table_reader_common.h: Shorten a couple lines\n      to fit libdwarf standards.\n    * dwarf_object_detector.c: Free debuglinkfull path\n      where appropriate. Ensure fd's (other than -1)\n      get closed where appropriate.\n    * dwarf_object_detector.h: Removed #if 0 lines.\n    * dwarf_peread.c: Assures fd which is not -1\n      gets closed.\n    * dwarf_print_lines.c:  Now uses \n      dwarfstring_constructor_static() so in nearly all\n      cases no malloc/free needed. Adds DWARF5\n      specific support for indexing into includes.\n    * libdwarf.h.in: Corrected comments about what to\n      free after calling dwarf_gnu_debuglink().\n    * generated_libdwarf.h.in: regenerated.\n    * libdwarf2.1.mm: Version 3.14. Correctet\n      description of dwarf_gnu_debuglink().  \n    * libdwarf2.1.pdf: Version 3.14. Regenerated.\n    * testdebuglinksh: Remove trailing whitespace.\n2020-10-11: David Anderson\n    * dwarf_object_detector.h: Deleted #if 0 prototype.\n    * testdebuglink.sh: Removed a trailing blank.\n2020-10-11: David Anderson\n\t* libdwarf_version.h: updated version string\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n\t  dwarf_names_new.h: regenerated with new version string.\n2020-10-11: David Anderson\n    * CMakeLists.txt: Added crc32.c, a new source file.\n    * Makefile.am: Same addition.\n    * Makefile.in: Regenerated.\n    * crc32.c: The crc needed to interoperate with GNU\n      debuglink.\n    * dwarf_alloc.c: Clarifying comment and removing\n      old unnecessary () around return values.\n    * dwarf_crc32.c: Removing crc from here, it was\n      the wrong crc32! Modified crc calls to match\n      the needs of the correct crc calculation. Ensured\n      a local malloc always gets freed.\n    * dwarf_debuglink.c: Added short comments.\n    * dwarf_errmsg_list.h: New error DW_DLE_DEBUGLINK_PATH_SHORT.\n    * dwarf_generic_init.c.: Updated to work properly\n      with debuglink and dSYM.\n    * dwarf_incl.h: Reformatted copyright for shorter\n      lines per libdwarf formatting, no change in content.\n    * dwarf_init_finish.c: Added comment. Removed\n      a pointless test for error (error not \n      not set, guaranteed) in dwarf_object_finish().\n    * dwarf_object_detector.c: Implemented support\n      for debuglink, significant changes involved.\n    * dwarf_object_detector.h: Comment change\n    * dwarf_opaque.h: Updated a comment and\n      declared the internal function _dwarf_crc32();\n    * libdwarf.h.in:  Functions added for debuglink\n      and a mistake corrected (now comment the arg names\n      to avoid macro disaster) in several functions.\n      New error DW_DLE_DEBUGLINK_PATH_SHORT.\n      New function dwarf_object_detector_path_b()\n      lets one supply global paths for debuglink and\n      get back a (new!) value, one of \n      DW_PATHSOURCE_basic, DW_PATHSOURCE_dsym,or\n      DW_PATHSOURCE_debuglink so callers know what\n      the path source by type.\n    * generated_libdwarf.h.in: Regenerated.\n    * libdwarf2.1.mm: Clarified lifetimes of several\n      arguments of debuglink-related functions. Revision 3.13.\n    * libdwarf2.1.pdf: Regenerated, version 3.13.\n2020-10-05: David Anderson\n    * libdwarf.h.in: Removed DW_DLC_NO_FOLLOW_DEBUGLINK\n      as it is never needed and was never used or\n      documented (it's only been there for a handful\n      of days).  Updated commentary.\n    * generated_libdwar.h.in: Regenerated.\n    * libdwarf2.1.mm: Rev 3.12. Beginning documentation\n      of GNU debuglink support.\n    * libdwarf2.1.pdf: Regenerated as 3.12.\n2020-10-02: David Anderson\n    * dwarf_crc32.c,dwarf_fission_to_cu.c,dwarf_macro5.c,\n\t  dwarf_opaque.h,libdwarf.h.in,test_linkedtopath.c,\n\t  test_linkedtopath.c: Removed whitespace and\n      tabs and make indents dwarf-standard.\n    * COPYING: Corrected the references to the BSD copyright\n      to use \"two-clause BSD license\".\n2020-10-02: David Anderson\n    * dwarf_generic_init.c: Implements the new\n      dwarf_init_path_dl() which allows passing debuglink\n      global paths (if one desires to). Global paths not\n      used here yet.\n    * libdwarf.h.in: Added prototype dwarf_init_path_dl()\n      but it is not yet used. Relevant commentary updated.\n    * generated_libdwarf.h.in: regenerated\n2020-10-01: David Anderson\n    * libdwarf2.1.mm: Revision 3.11. Added new debuglink\n      function dwarf_crc32().\n    * libdwarf2.1.pdf: Revision 3.11. Regenerated.\n2020-10-01: David Anderson\n    * dwarf_crc32.c: Refined the #includes so they work\n      with cmake too.\n    * dwarf_debuglink.c,dwarf_object_detector.c,\n      dwarf_peread.c: Refined the #includes to work\n      in more general circumstances.\n2020-10-01: David Anderson\n    * libdwarf.h.in: Added DW_DLC_NO_FOLLOW_DEBUGLINK\n      but it is not yet used.\n    * generated_libdwarf.h.in: regenerated\n2020-09-30: David Anderson\n    * CMakeLists.txt,Makefile.am: Added dwarf_crc32.c\n    * Makefile.am: Regenerated.\n    * dwarf_crc32.c: So libdwarf can interoperate with GNU\n      debuglink to locate separate debug object files.\n    * dwarf_debuglink.c: Added {} one place. No real change.\n    * libdwarf.h.in: New interfaces for crc32.\n    * generated_libdwarf.h.in: Regenerated\n2020-09-28: David Anderson\n    * libdwarf.h.in: Rearranged the DW_DLC_* values\n      for clarity and added commentary on the main\n      point (the 'access' argument to dwarf init\n      functions for the consumer/reader calls\n      should be zero).  This is not a change.\n    * generated_libdwarf.h.in: Documented\n      the longstanding handling of that same\n      argument to consumer/reader functions.\n    * libdwarf2.1.mm: Version 3.10. Documenting\n      that same thing.\n    * libdwarf2.1.pdf: Regenerated as version 3.10.\n2020-09-26: David Anderson\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n\t  dwarf_names_new.h,libdwarf_version.h: Updated  version\n      string, regenerated files that reference it.\n2020-09-26: David Anderson\n    * baseline.ltp: new test baseline for debuglink.\n\t* test_linkedtopath.c: Now with better coverage\n      of the paths in tbe debuglink code, we\n      add a getcwd here to return a test cwd\n      of /exam/ple so the output of debuglink\n      does not depend on the real build\n      directory location.\n2020-09-25: David Anderson\n\t* dwarf_debuglink.c: Corrected and clarified.\n2020-09-22: David Anderson\n    * CMakeLists.txt, Makefile.am: Added new file \n      dwarf_fission_to_cu.c.\n    * Makefile.in: Regenerated.\n    * dwarf_die_deliv.c: Renamed _dwarf_find_offsets_via_fission\n      to be _dwarf_find_all_offsets_via_fission().\n      Added status check following the call to it.\n    * dwarf_fission_to_cu.c: Now the above function\n      and supporting functions are in this source file to\n      deal with DW_SECT_LOCLISTS,DW_SECT_STR_OFFSETS,\n      DW_SECT_MACRO, DW_SECT_RNGLISTS.\n    * dwarf_loc.h: Updated prototypes for these\n      functions.\n    * dwarf_loclists.h: Now deleted. It's long been\n      unused.\n    * dwarf_loclists.c: Renamed internal_read_header as\n      _dwarf_internal_read_loclists_header for more general\n      access.\n    * dwarf_macro5.c: Now the cu-context cc_macro_base\n      field is used when needed for DWP files.\n    * dwarf_opaque.h: Rearranged some fields of\n      Dwarf_CU_Context\n      into more logical groupings (related to debug fission).\n    * dwarf_rnglists.c: renamed internal_read_header\n      to _dwarf_internal_read_rnglists_header().\n    * dwarf_rnglists.h: Added protype for\n      _dwarf_internal_read_rnglists_header().\n    * dwarf_str_offsets.c: Removed \n      _dwarf_find_offsets_via_fission\n      (which does more than just str_offsets now)\n      and put into dwarf_fission_to_cu.c as\n      _dwarf_find_all_offsets_via_fission().\n    * dwarf_str_offsets.h: Prototype renamed.\n    * libdwarf.h.in: Added a comment.\n    * generated_libdwarf.h.in: Regenerated.\n2020-09-18: David Anderson\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n\t  dwarf_names_new.h,libdwarf_version.h: Updated  version\n      string, regenerated files that reference it.\n2020-09-18: David Anderson\n    * dwarf_debug_names.c: If allocation fails in setting up\n      a Dwarf_Dnames head we now get an error and a more tailored\n      error than just memory-allocation-failed.\n    * dwarf_elf_load_headers.c: If the symtab section size\n      is really big (larger than the object file size!) we now\n      get a relevant error message.  Used to get malloc fail on\n      32bit systems and do a large malloc on 64bit systems before\n      getting an error eventually.\n    * dwarf_frame.c: Calling the frame-retrieval functions\n      on a corrupted object file could result in leaking memory.\n      Fixed.\n2020-09-17: David Anderson\n    * dwarf_peread.c: Deleted several blank lines.\n    * dwarf_global.c: Removed trailing whitespace,\n      fixed indents.\n    * dwarf_errmsg_list.h: Various error strings now\n      have extra text with meaningful, but generic,\n      content.\n2020-09-17: David Anderson\n    * dwarf_global.c: Refactored to eliminate 50 lines\n      of duplicated code and ensure no leaks while\n      improving error messages when the object or DWARF\n      data is damaged (fuzzed).\n    * dwarf_global.h,dwarf_funcs.c,dwarf_pubtypes.c,\n      dwarf_types.c,dwarf_vars.c,dwarf_weaks.c: Eliminated \n      useless arguments to library-internal function.\n    * dwarf_util.h: Errors detected in a macro now \n      report more useful information.\n    * dwarf_alloc.c: Two DEBUG lines were too long,\n      broke those lines to shorter ones.\n      Added DEBUG-only output where it had not\n      reported earler.\n2020-09-15: David Anderson\n    * dwarf_alloc.c: Added ifdef DEBUG\n      printf for cases it should exist.\n      #undef debug at the top guaranties it will not\n      be turned on by accident.\n    * dwarf_loc.c(_dwarf_read_loc_section): Was missing dbg\n      in a call to _dwarf_error. Corrupt object lead to leak.\n    * dwarf_die_deliv.c(_dwarf_make_CU_Context) was missing\n      a _dwarf_error call where one was required.\n      A corrupt object lead to memory leak.\n      And _dwarf_next_die_info_ptr was failing to \n      initialize dbg from the passed in cu_context.\n      Also causing a memory leak on some corrupt objects.\n    * dwarf_peread.c(pe_section_name_get): Was failing\n      to check for a valid null-terminated\n      string in the string table.\n      A corrupted object could cause segmentation violation.\n    * dwarf_error.c (_dwarf_error_string): Added ifdef DEBUG\n      printf where they should have been all along.\n      #undef debug at the top guaranties it will not\n      be turned on by accident.\n2020-09-10: David Anderson\n    * dwarf_die_deliv.c: Now handle DW_AT_GNU_ranges_base\n      properly.\n    * dwarf_ranges.c: New function dwarf_get_ranges_b()\n      so we can pass back the true split-dwarf offset\n      when we have DWARF4 split-dwarf extension objects.\n      And we calculate that true offset.\n    * libdwarf.h.in: New function prototype:\n      dwarf_get_ranges_b().\n    * generated_libdwarf.h.in: Regenerated.\n    * libdwarf2.1.mm:  Version 3.09. Now documents\n      dwarf_get_ranges_b().\n    * libdwarf2.1.pdf:  Version 3.09. Regenerated.\n2020-09-10: David Anderson\n    * checkexamples.c,dwarf_die_deliv.c,dwarf_form.c,\n      dwarf_line_table_reader_common.h,dwarf_query.c,\n      dwarf_ranges.c,dwarf_str_offset.c,dwarf_tied.c:\n      Remove trailing whitespace. Fix indentation.\n2020-09-09: David Anderson\n    * dwarf_alloc.c: dwarf_dealloc_error(dbg,error)\n      and dwarf_dealloc(dbg,error,DW_DLA_ERROR)\n      should now be called with a null dbg if\n      the failing libdwarf was one of the dwarf_init*()\n      or dwarf_elf_init*() functions and the storage\n      in the error will be freed.\n      See libdwarf2.1.pdf rev 3.08 or later for\n      details.\n      With DEBUG set additional allocation details are\n      revealed.\n    * dwarf_error.c: Repair a comparison with NULL.\n    * dwarf_finish.c(dwarf_finish): Simplify the !dbg test.\n    * dwarf_ranges.c: Remove dead code.\n    * libdwarf2.1.mm: Version 3.08. The Table of\n      Contents points to returns from dwarf_init*\n      calls (around page 28) now.\n    * libdwarf2.1.pdf: Generated Version 3.08.\n2020-09-08: David Anderson\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n\t  dwarf_names_new.h,libdwarf_version.h: Updated  version\n      string, regenerated files that reference it.\n2020-09-07: David Anderson\n    * dwarf_xu_index.c: We were not checking the\n      value of N (in the header of .debug_cu/tu_index)\n      to ensure it was sane. Now we check and error\n      if insane (the test object is fuzzed to provoke\n      the error).\n    * dwarf_elf_access.c: Reformatted commentary so\n      the lines are not too long.\n2020-09-07: David Anderson\n    * dwarf_opaque.h, dwarf_str_offsets.c: Removed trailing\n      whitespace.\n    * dwarf_line_table_reader_common.h: Fixed an accidental\n      deletion of a crucual _ (underbar) in preceeding commit.\n2020-09-07: David Anderson\n    * dwarf_line_table_reader_common.h: Places needing\n      additional dealloc in case of error:\n      lines 1232,2255,2404 (line#s in the updated version). \n2020-09-07: David Anderson\n    * dwarf_tied_decls.h: Removed declaration of\n      _dwarf_loop_reading_debug_info_for_cu().\n    * dwarf_tied.c: The return value from dwarf_tsearch() was\n      not being handled properly. Lead to leaks.\n      Could, possibly, have lead to coredump.\n      Other places tsearch return values were done properly.\n      _dwarf_loop_reading_debug_info_for_cu() is\n      now static function.\n    * dwarf_groups.c: Moved _dwarf_grp_destroy_free_node()\n      down to just before the function that references it.\n    * dwarf_alloc.c: Removed an abort() call from\n      #ifdef DEBUG code.\n2020-09-05: David Anderson\n    * dwarf_die_deliv.c: Delete old #if 0 lines.\n      Pick up Fission data about DW_SECT_STR_OFFSETS\n      to help find strings.\n      Merge any helpful base data from the skeleton (tied file)\n      CU dies into the dwp CU dies.\n    * dwarf_base_types.h: Add DW_STR_OFFSETS_VERSION4\n      to help with reading that GNU extension.\n    * dwarf_form.c: Corrected code reading from\n      .debug_str_offsets.\n    * dwarf_opaque.h: Added new fields to the CU context\n      record to support .debug_str_offsets, and a new\n      function declaration related to that.\n    * dwarf_query.c: Deleted no-longer-used functions\n      (the tied-file attribute merge happens much\n      earlier) and added \n      _dwarf_merge_all_base_attrs_of_cu_die().\n    * dwarf_ranges.c: Better represents using .debug_ranges.dwo\n      if it's present in the dwp  .\n    * dwarf_str_offsets.c: Refactoring and revising to support\n      the two formats of .debug_str_offsets: DWARF5 and\n      GNU DWARF4.\n    * dwarf_str_offsets.h. New function prototypes for the revised\n      .debug_str_offsets[.dwo] code.\n2020-09-01: David Anderson\n    * dwarf_loclists.c(internal_load_loclists_contexts): Added\n      a missing 'return DW_DLV_ERROR' when an error was detected.\n2020-08-28: David Anderson\n    * dwarf_die_deliv.c,dwarf_loc.c,dwarf_util.c:Fixed\n      indents and trailing whitespace.\n2020-08-27: David Anderson\n    * dwarf_die_deliv.c: Some error messages now have more\n      detail.\n    * dwarf_line_table_reader_common.h: In an error condition\n      (meaning corrupt dwarf) _dwarf_free_chain_entries()\n      was called twice on the same data, referring to\n      freed space in doing so. Deleted the extra call.\n    * dwarf_loc.c(_dwarf_setup_loc): Removed a \n      bogus _dwarf_error \n      using DW_DLE_LOC_EXPR_BAD: Let the just-called\n      function error code be returned.\n      Some error conditions detected here now report\n      detailed information on the error.\n    * dwarf_query.c(dwarf_attrlist): Refined the detailed\n      error message already present.\n    * dwarf_util.c:New internal function\n      _dwarf_create_area_len_error() lets dwarf_util.h\n      macro report a more detailed error without\n      bloating the macro.\n    * dwarf_util.h: Calls that new function rather\n      than calling _dwarf_error() itself.\n2020-08-25: David Anderson\n    * dwarf_form.c: Previous change failed to show\n      the actual error string \n      DW_DLE_STRP_OFFSET_BAD or DW_DLE_STRING_OFFSET_BAD\n      along with the\n      details. Oops. Now it shows.\n2020-08-23: David Anderson\n    * dwarf_form.c: Slightly changed the error message \n      for an error in DW_FORM_strp.\n2020-08-23: David Anderson\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n\t  dwarf_names_new.h,libdwarf_version.h: Updated  version\n      string, regenerated files that reference it.\n2020-08-23: David Anderson\n    * dwarf_form.c,dwarf_generic_init.c,dwarf_loc.c,\n      dwarf_loc.h,dwarf_loclists.c,dwarf_query.c, dwarf_rnglists.c,\n      pro_opaque.h: Remove trailing whitespace. Fix indents.\n2020-08-23: David Anderson\n    * dwarf_form.c: In case an strp offset seems wrong\n      we get a more detailed error message.\n    * dwarf_macro5.c: Deleted gratuitous blank line.\n2020-08-22: David Anderson\n    * dwarf_loc.c,dwarf_rnglists.c: call \n      _dwarf_look_in_local_and_tied_by_index\n      not _dwarf_extract_address_from_debug_addr so \n      .debug_addr in the tied file will be found.\n    * dwarf_opaque.h,dwarf_query.c: Make  \n      _dwarf_look_in_local_and_tied_by_index global,not\n      _dwarf_extract_address_from_debug_addr.\n2020-08-22: David Anderson\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n\t  dwarf_names_new.h,libdwarf_version.h: Updated  version\n      string, regenerated files that reference it.\n2020-08-21: David Anderson\n    * dwarf_init_finish.c(insert_sht_list_in_group_map):\n      Added checks of dss_data_was_malloc around\n      a couple of calls saying free(secdata.dss_data).\n      The missing checks could only result in duplicate\n      free with user calls that allocated their\n      own section data to load a section and a certain\n      error arising during the call.\n    * dwarf_loc.c: To elminate ambiguity, renamed\n      some fields from lowpc to rawlowpc (for example).\n    * dwarf_loclists.c(build_array_of_lle): Removed\n      a block of code duplicating work done in dwarf_loc.c.\n      Fixed arguments passing ld_lopc, ld_highpc\n      to pass ld_rawlow, ld_rawhigh for correctness.\n2020-08-21: David Anderson\n    * libdwarf2.1.mm: Rev 3.07. Corrected quote mismatches\n      in the mm commands, and a couple of stray\n      characters after a .P command\n    * libdwarf2.1.pdf: Rev 3.07. Regenerated.\n2020-08-18: David Anderson\n    * checkexamples.c: Corrected example_rnglist_for_attribute()\n      example.\n    * dwarf_ranges.c: Corrected a comment and removed #if 0\n      code as it is obsolete.\n    * dwarf_rnglists.c(dwarf_get_rnglists_entry_fields_a):\n      Allow the pointer-arguments used to return data to\n      the caller to be null pointers safely, as libdwarf2.1.pdf\n      suggested that was legal.\n    * libdwarf2.1.mm: Version 3.06. Corrected the example\n      calling dwarf_get_rnglists_entry_fields_a().\n    * libdwarf2.1.pdf: Regenerated, Version 3.06\n     \n      \n2020-08-10: David Anderson\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n\t  dwarf_names_new.h,libdwarf_version.h: Updated  version\n      string, regenerated files that reference it.\n2020-08-10: David Anderson\n    * dwarf_elf_defines.h,dwarf_elfread.c: A linux kernel used a\n      R_X86_64_NONE (which means ignore the relocation) and\n      now we deal with it properly for EM_X86_64.\n2020-08-02: David Anderson\n    * dwarf_alloc.c: Added a constructor for Dwarf_Locdesc_c\n      (DW_DLA_LOCDESC_C) so fields ld_lle_value and\n      ld_kind get non-zero and \n      erroneous initial values so\n      the values can be checked later for correctness.\n    * dwarf_errmsg_list.h: Added error DW_DLE_LOCATION_ERROR.\n    * dwarf_loc.c: Now we rigorously set and check the fields\n      ld_lle_value and ld_kind. \n      _dwarf_locdesc_c_constructor() sets those two fields\n      so we can check correctness and in case of error, \n      report the details.\n    * dwarf_loc.h: Added constructor prototype and a special\n      DW_LLE_VALUE_BOGUS initial value (invisible to \n      library callers).\n    * dwarf_loclists.c: After malloc use the  Dwarf_Locdesc_c\n      constructor so later error checking possible.\n    * libdwarf.h.in: Added error DW_DLE_LOCATION_ERROR.\n    * libdwarf2.1.mm: Rev 3.05. Additional detail on\n      return values for dwarf_get_locdesc_entry_d()\n      and documented dwarf_get_locdesc_entry_c() \n      (recommending use of dwarf_get_locdesc_entry_d()\n      instead)\n    * libdwarf2.1.pdf: Rev 3.05. Regenerated.\n2020-07-28: David Anderson\n    * dwarf_locationop_read.c: Added DW_OP_GNU_variable_value.\n    * dwarf_names.c, dwarf_names_enum.h: Regenerated.\n    * dwarf.h: Added in GNU names that had been accidentally\n      ommitted: DW_AT_GNU_deleted,DW_AT_GNU_locviews,\n      DW_AT_GNU_entry_view,DW_OP_GNU_variable_value.\n      These caused the regeneration of dwarf_names.h.\n2020-07-22: David Anderson\n    * dwarf_abbrev.c,dwarf_debug_names.c, dwarf_debuglink.c,\n\t  dwarf_dsc.c,dwarf_error.c,dwarf_form.c,dwarf_funcs.c,\n\t  dwarf_gdbindex.c,dwarf_harmless.c,dwarf_init_finish.c,\n\t  dwarf_leb.c,dwarf_leb_test.c,dwarf_line.c,dwarf_macro.c,\n\t  dwarf_macro5.c,dwarf_original_elf_init.c,dwarf_pubtypes.c,\n\t  dwarf_str_offsets.c,dwarf_stringsection.c,dwarf_stubs.c,\n\t  dwarf_test_errmsg_list.c,dwarf_types.c,dwarf_vars.c,\n\t  dwarf_weaks.c,dwarf_xu_index.c,gennames.c,malloc_check.c,\n\t  pro_arange.c,pro_encode_nm.c,pro_error.c,pro_finish.c,\n\t  pro_forms.c,pro_funcs.c,pro_line.c,pro_macinfo.c,\n\t  pro_pubnames.c,pro_reloc.c,pro_reloc_stream.c,\n\t  pro_reloc_symbolic.c,pro_types.c,pro_vars.c,pro_weaks.c:\n      Updated copyright date. Reformatted copyright to\n      have slightly shorter lines, no change in content.\n2020-07-22: David Anderson\n    * libdwarf2.1.mm: Now Rev 3.04. Revised the \n      Error Handling section for greater clarity.\n      Revised dwarf_init_path() to correct formatting\n      errors. \n    * libdwarf2.1.pdf: Regenerated as rev 3.04 .\n    * dwarf_generic_init.c(dwarf_init_pathh): Removed\n      the error-handling so when the call fails the\n      Dwarf_Debug argument is not touched. \n      For the PE case return  the DW_DLV_ERROR or\n      DW_DLV_NO_ENTRY (return left off by accident).\n    * dwarf_arange.c: Reformatted the copyright\n      to have shorter lines.\n2020-07-17: David Anderson\n    * libdwarf/libdwarf_version.h: Version string updated.\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n      dwarf_names_new.h,libdwarf_version.h : regenerated\n      with latest version string\n2020-07-17: David Anderson\n    * dwarf_frame.c: rearrange comments a little and\n      add a web reference as documentation.\n\t* pro_debug_sup.c,pro_section.c: Remove trailing \n      whitespace.  Fix indents.\n2020-07-15: David Anderson\n    * dwarf_alloc.c: Improved printf if DEBUG\n      is turned on, with #undef DEBUG in source so\n      necessary to modify the source and rebuild\n      to get the voluminous alloc/dealloc debugging\n      printf turned on.\n2020-07-14: David Anderson\n    * libdwarf2.1.mm: Version 3.02. Documents the new call\n      dwarf_get_debug_sup() to access the DWARF5\n      .debug_sup section.\n    * libdwarf2p.1.mm: Version 1.51.  Documents the new\n      call dwarf_add_debug_sup() to create the DWARF5\n      .debug_sup section.\n    * libdwarf2.1.pdf,libdwarf2p.1.pdf: Regenerated.\n2020-07-14: David Anderson\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n\t  dwarf_names_new.h,libdwarf_version.h: Regenerated\n      with new version string.\n2020-07-13: David Anderson\n    * CMakeLists.txt, Makefile.am: Added dwarf_debug_sup.c\n    * Makefile.in: Regenerated.\n    * dwarf_errmsg_list.h: Added DW_DLE_DEBUG_SUP_STRING_ERROR\n      and DW_DLE_DEBUG_SUP_ERROR.\n    * dwarf_names.c dwarf_names_enum.h: Reflects correction\n      of value of\n      DW_GNUIVIS_static (a new non-standard name in dwarf.h)\n    * generated_libdwarf.h.in,libdwarf.h.in: With the\n      two new errors and declaration of\n      dwarf_add_debug_sup() to produce .debug_sup\n      and dwarf_get_debug_sup() to retrieve the section values..\n    * pro_finish.c: Support for creating .debug_sup.\n    * pro_opaque.h: Support for creating .debug_sup.\n    * pro_section.c: Support for creating .debug_sup.\n    * dwarf_debug_sup.c: New, for .debug_sup access.\n\t* pro_debug_sup.c: New. for .debug_sup creation.\n2020-07-10: David Anderson\n    * dwarf_die_deliv.c: Handle\n      DW_AT_GNU_ranges_base in a CU DIE.\n    * dwarf_opaque.h: Added 2lines of comment\n      about cc_debug_offset.\n    * dwarf_query.c(_dwarf_get_ranges_base_attr_value):\n      Simplified as the cu_context\n      has the base values, no need to read\n      DIEs/Attributes here.\n2020-07-09: David Anderson\n    * dwarf_opaque.h: Changing a comment about libdwarf\n      and the tied file (if any).\n2020-07-08: David Anderson\n    * libdwarf2.1.mm: Added documentation of\n      .debug_gnu_pybtypes and .debug_gnu_pubnames.\n      See dwarf_get_gnu_index_head() in the document.\n    # libdwarf2.1.pdf: Regenerated. Rev 3.01\n2020-07-08: David Anderson\n    * dwarf_init_finish.c: setup of .debug_names was\n      done twice (not harmful but the duplicate removed now).\n2020-07-08: David Anderson\n    * dwarf_elf_load_headers.c,dwarf_gdbindex.c,dwarf_gnu_index.c,\n\t  dwarf_gnu_index.h,dwarf_init_finish.c,\n      dwarf_locationop_read.c: Fixed indents and trailing\n      whitespace.\n2020-07-08: David Anderson\n    * dwarf.h: Fixed error in DW_GNUIVIS values.\n    * dwarf_debug_names.h: Arranging shorter\n      lines in a block of comments.\n    * dwarf_elfread.c( find_section_to_relocate): Added \n      de_debug_gnu_pubnames, de_dbug_gnu_pubtypes to sections\n      that can have relocations (in  a dwo.o before linking).\n    * dwarf_gnu_index.c: Now loads debug_info so that\n      in near future correctness of offsets in \n      .debug_gnu_pubnames/pubtypes can be checked.\n2020-07-08: David Anderson\n    * dwarf_gnu_index.c: Remove debug printf. Small corrections\n      to the section reading.\n2020-07-06: David Anderson\n    * dwarf_loc.c: Too-long lines in comments adjusted shorter.\n    * dwarf_loc.h: Renamed _dwarf_free_loclists_head to\n      _dwarf_free_loclists_head_content for clarity.\n    * dwarf_loclists.c: Deleted dead code. Renamed that\n      function here too. Corrected a bug in\n      _dwarf_free_loclists_head()\n    * dwarf_gnu_index.c,dwarf_gnu_index.h: New files\n      to handle sections .debug_gnu_pubnames and\n      .debug_gnu_pubtypes\n    * dwarf_init_finish.c: Added the new sections to\n      enter_section_in_de_debug_sections_array().\n    * CMakeLists.txt,Makefile.am: Added dwarf_gnu_index.c and\n      dwarf_gnu_index.h\n    * Makefile.in: Regenerated.\n    * dwarf.h: Added new nonstandard DW_GNUIVIS* and\n      DW_GNUIKIND* in support of these sections.\n    * dwarf_alloc.c: New record type DW_DLA_GNU_INDEX_HEAD\n      for these new sections.\n    * dwarf_errmsg_list.h: New errors\n    * dwarf_names.c, dwarf_names.h: Regenerated with\n      DW_GNUIVIS and DW_GNUIKIND name functions.\n    * dwarf_names_enum.h: Regenerated this too.\n    * dwarf_names_new.h: Regenerated this.\n    * libdwarf.h.in: Added Dwarf_Gnu_Index_Head type\n      and new functions and new error codes. Dropped\n      a dead DLA type and assigned it to be for\n      DW_DLA_GNU_INDEX_HEAD. Added new functions \n      dwarf_get_gnu_index_head()\n      dwarf_gnu_index_dealloc()\n      dwarf_get_gnu_index_block() \n      dwarf_get_gnu_index_block_entry() allowing\n      access to the data in .debug_gnu_pubtypes\n      and .debug_gu_pubnames.\n    * generated_libdwarf.h.in: Regenerated.\n2020-07-04: David Anderson\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n\t  dwarf_names_new.h,libdwarf_version.h: new version string.\n2020-07-03: David Anderson\n    * CMakeLists.txt, Makefile.am: renamed dwarf_dnames.h ->\n      dwarf_debug_names.h and dwarf_dnames.c to \n      dwarf_debug_names.c.\n    * Makefile.in: Regenerated.\n    * dwarf_alloc.c, dwarf_debug_names.c: Include\n      name updated dwarf_dnames.h to dwarf_debug_names.h .\n    * dwarf_elfread.c(_dwarf_elf_object_access_internals_init):\n      In case of a null gh_namestring we notice and skip\n      over it.\n    * dwarf_init_finish.c(_dwarf_load_section): Added to\n      the comment on zero-size sections.\n2020-07-02: David Anderson\n    * dwarf_gdbindex.h: Removed gdbindex_offset_type typedef\n      as it is not used anywhere.\n    * dwarf_global.c(dwarf_get_cu_die_offset_given_cu_header_offset):\n      Updated a commment to reflect handling of DWARF5 and more.\n    * dwarf_util.h: Removed SKIP_LEB128_WORD_CK as it\n      is no longer used and replaced by a better function.\n    * dwarf_query.c: Removed comment about that macro.\n    * dwarf_form.c: Revised the commentary on\n      DW_AT_str_offsets_base to match the final DWARF5.\n2020-07-02: David Anderson\n    * libdwarf.h.in: Added DW_DLE_GDBINDEX_STRING_ERROR.\n    * generated-libdwarf.h.in: Regenerated.\n    * dwarf_errmsg_list.h: Added DW_DLE_GDBINDEX_STRING_ERROR.\n    * dwarf_gdbindex.c(dwarf_gdbindex_addressarea_entry): Now\n      checks its arguments and the return string for problems.\n2020-07-01: David Anderson\n    * libdwarf.h.in: Comment now deprecates \n      dwarf_get_loclist_entry().\n    * generated_libdwarf.h.in: regenerated.\n    * libdwarf2.1.mm: Deprecates dwarf_get_loclist_entry().\n    * libdwarf2.1.pdf: Regenerated, version 2.99.\n    * dwarf_locationop_read.c: Pass real address-size to\n      read_encoded_addr() so it will work properly.\n2020-06-29: David Anderson\n    * dwarf_elf_load_headers.c: Added sanity checks\n      on section size of the section strings and\n      the symbol strings.\n      All the section-size errors now use\n      the new error code DW_DLE_SECTION_SIZE_OR_OFFSET_LARGE.\n    * dwarf_errmsg_list.h: Added string for\n      DW_DLE_SECTION_SIZE_OR_OFFSET_LARGE.\n    * libdwarf.h.in: Added DW_DLE_SECTION_SIZE_OR_OFFSET_LARGE.\n    * generated_libdwarf.h.in: Regenerated.\n2020-06-29: David Anderson\n    * libdwarf_version.h: updated version string.\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n      dwarf_names_new.h: Regenerated.\n2020-06-29: David Anderson\n    * dwarf_elfread.c: Added checks on section sizes\n      and offsets to ensure they don't exceed file size\n      (but only check when we try to read them, we\n      want to read dwarf even if sections we do not\n      care about have damaged section headers).\n    * dwarf_peread.c: Fixed indentation mistake.\n2020-06-28: David Anderson\n    * dwarf_elf_defines.h: Adding R_386_GOTPC\n      so we don't rely on /usr/include to have the\n      ones we need.\n    * dwarf_elf_rel_detector.c: Adding R_386_GOTPC\n      to identify the relocation as 32bit.\n2020-06-27: David Anderson\n    * dwarf_alloc.c(_dwarf_free_all_of_one_debug): If space \n      for debug_rnglists or\n      debug_loclists was malloc'd (relocations\n      or compressed sections force malloc) we\n      now call the function that frees that\n      data.  That function renamed:\n      rela_free->malloc_section_free.\n2020-06-25: David Anderson\n    * dwarf_loc.c: Corrected indents.\n    * dwarf_loclists.c: Corrected indents, removed\n      trailing whitespace.\n    * dwarf_peread.c: Removed trailing whitespace.\n    * dwarf_rnglists.c: Removed trailing whitespace.\n    * libdwarf2.1.mm: Rev 2.98. Added documentation\n      on the .debug_names section printing functions.\n      These intended for debugging .debug_names\n      (that is, by dwarfdump),\n      not things user code are likely to want to use. \n      Documented the new function \n      dwarf_get_rnglists_entry_fields_a() as the original\n      dwarf_get_rnglists_entry_fields() \n      (which is still there and works as well as before)\n      left off a field important to callers.\n    * libdwarf2.1.pdf: Rev 2.98. Regenerated.\n2020-06-22: David Anderson\n    * dwarf_loc.c: Using knowledge of the base address status\n      improve messaging while reducing execution time.\n    * dwarf_loclists.c: Properly deal with setting\n      up for output in case .debug_addr missing (fixing\n      an omission).\n    * dwarf_peread.c: In load_optional_header64() we were\n      failing to read hdr.ImageBase which caused addresses\n      to be wrong (base address needed to be set).\n    * dwarf_rnglists.c: Based on knowledge of lack/presence\n      of .debug_addr improve messaging and reduce\n      cpu-time spent.\n    * dwarf_rnglists.h: Added 2 line commentary.\n    * libdwarf.h.in,generated_libdwarf.h.in: Added\n      dwarf_get_rnglists_entry_fields_a(), the original\n      function was inadequate.\n2020-06-19: David Anderson\n    * dwarf_reloc_x86_64.hr,dwarf_reloc_x86_64.h: Added in\n      R_X86_64_PC64 relocation as llvm is using it.\n2020-06-17: David Anderson\n    * dwarf_elf_load_headers.c: Catch a potential division by \n      zero error. \n    * dwarf_peread.c: Added comments.\n2020-06-17: David Anderson\n    * dwarf_loclists.c, dwarf_rnglists.c: Rename \n      length_size->offset_size\n      for clarity and correct the computation of the\n      length of the offsets array.\n2020-06-17: David Anderson\n    * dwarf_die_deliv.c: Pick up CU DIE base fields\n      always. Not just for DWARF4,5.\n    * dwarf_loc.c: Clarify the flow. A comment added.\n    * dwarf_form.c: Added missing DW_FORM_loclistx from\n      a switch.\n2020-06-16: David Anderson\n    * dwarf_query.c, dwarf_util.c: Remove trailing whitespace.\n      Changed indents and line lengths in a small area to match\n      the usual look.\n2020-06-16: Jorge Gorbe Moya \n    * dwarf_query.c, dwarf_util.c: Correct the handling\n      of DW_UT initializations.\n2020-06-16: David Anderson\n    * dwarf_die_deliv.c,dwarf_frame2.c,dwarf_loc.c:\n      Remove trailing whitespace.\n2020-06-14: David Anderson\n    * libdwarf1.1.mm: Added examples to the Error Handling\n      section as the previous version was pretty vague\n      about the best way to call libdwarf to deal\n      with errors.\n    * libdwarf1.1.pdf: Generated version 2.97.\n     \n2020-06-14: David Anderson\n    * dwarf_die_deliv.c: Adds the highest known\n      abbrev code to certain error messages.\n    * dwarf_die_deliv.h: Corrected a comment.\n    * dwarf_frame2.c: Now uses (uintptr_t) to avoid\n      warnings from certain compiler/pointer-size\n      environments.\n    * dwarf_loc.c: Update the loclist head\n      structure  ll_bytes_total\n      field with DWARF 2,3,4 loclists too.\n    * dwarf_opaque.h: Add cc_highest_known_code\n      to Dwarf_CU_Context_s for better\n      error reporting and align some field names\n      for a better appearance.\n    * dwarf_query.c: Improved error reporting\n      when an abbrev code missing.\n    * dwarf_util.c: Keep track of highest abbrev\n      code seen (per compilation unit).\n    * dwarf_util.h: Internal function declaration\n      changed to allow reporting of highest\n      abbrev code.\n2020-06-12: David Anderson\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n      dwarf_names_new.h,libdwarf_version.h: updated\n      version string.\n2020-06-12: David Anderson\n    * checkexamples.c,dwarf_alloc.c,dwarf_arange.c,\n      dwarf_frame.c,dwarf_line.c,dwarf_line_table_reader_common.h,\n      dwarf_loc.c,dwarf_loc.h,dwarf_locationop_read.c,\n      dwarf_loclists.c,dwarf_query.c,dwarf_rnglists.c,\n      dwarf_util.c,libdwarf.h.in: Fixed indents\n      and removed trailing whitespace.\n2020-06-12: David Anderson\n    * dwarf_alloc.c: Added free of loclists to \n      _dwarf_free_all_of_one_debug().\n    * dwarf_loc.c: Created _dwarf_free_op_chain()\n      and call it so even in case of error nothing leaks.\n      Some adjustments to indents.\n    * dwarf_loclists.c: _dwarf_dealloc_loclists ->\n      _dwarf_dealloc_loclists_context for clarity.\n      Modified _dwarf_free_loclists_head() to get\n      leak-free behavior.\n    * dwarf_opaque.h: Reflects above name change.\n    * libdwarf2.1.mm: Corrected and amplified\n      words on the new functions.\n    * libdwarf2.1.pdf: Regenerated.\n2020-06-10: David Anderson\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n      dwarf_names_new.h,libdwarf/libdwarf_version.h:\n      updated version string.\n2020-06-09: David Anderson\n    * CMakeLists.txt,Makefile.am : Deleted dwarf_loc2.h reference.\n      Added dwarf_locationop_read.c, dwarf_loclists.c.\n    * Makefile.in: Regenerated.\n    * dwarf_alloc.c: Corrected a comment about reserved numbers.\n      Reflects name change from struct Dwarf_Loc_c_s to\n      struct Dwarf_Loc_Expr_Op_s. \n    * dwarf_errmsg_list.h: Added DW_DLE_LOCLISTS_ERROR.\n    * dwarf_form.c: Added arguments to the library\n      internal function _dwarf_formblock_internal()\n      for better support of DWARF5 loclist creation.\n    * dwarf_frame2.c: Changed a local from unsigned\n      to Dwarf_Unsigned as well as changing pointer\n      casts from 'unsigned long' to Dwarf_Unsigned.\n    * dwarf_loc.c: Lots of refactoring to make\n      the flow easier to understand.\n      Moved _dwarf_read_loc_expr_op() to\n      a new file dwarf_locationop_read.c as the \n      function is quite large.\n      Renamed other functions so the names are not\n      so much alike.\n    * dwarf_loc.h: New fields in Dwarf_Loc_Chain_s\n      to support the raw vs. cooked values of location\n      low/high. New fields to support DWARF 5 loclists\n    * dwarf_loc2.h: Deleted. Relevant contents in\n      dwarf_loc.c and dwarf_loclists.c\n    * dwarf_locationop_read.c: Existing code\n      to read location ops refactored to a routine\n      by themselves.  Long enough by itself\n    * dwarf_loclists.c: New file with .debug_loclists\n      support. \n    * dwarf_loclists.h: Nothing here. will be deleted.\n    * dwarf_opaque.h: New functions and arguments\n      for internal debug_loclists data.\n    * dwarf_rnglists.c: Changed certain arguments\n      to Dwarf_Half (address_size etc) where that\n      makes sense.  \n    * dwarf_util.c: Now dwarf_load_debug_info()\n      loads the base data from .debug_rnglists\n      and .debug_loclists (DWARF5)\n    * libdwarf.h.in: 'unsigned' now 'unsigned int'\n      existing function unchanged: dwarf_get_loclist_c()\n      new function dwarf_get_locdesc_entry_d()\n      new function dwarf_get_loclist_head_basics()\n      new function dwarf_get_location_op_value_d()\n      new function dwarf_get_loclist_head_kind()\n      - Following for printing raw loclists, not\n      usually used.\n      new function dwarf_load_loclists()\n      new function dwarf_get_loclist_context_basics()\n      new function dwarf_get_loclist_lle()\n      new function dwarf_get_loclist_offset_index_value()\n      new function dwarf_get_loclist_raw_entry_detail()\n    * libdwarf2.1.mm: 2.96, documents the new calls.\n    * libdwarf2.1.pdf: Version 2.96.\n2020-05-23: David Anderson\n    * dwarf_opaque.h: Defines DWARFSTRING_ALLOC_SIZE   200\n    * dwarf_form.c: Using DWARFSTRING_ALLOC_SIZE for the\n      initial allocation, (mostly) avoiding the need\n      for malloc here.  dwarfstring is mainly used\n      for error messages, so preallocation is rarely useful\n    * dwarf_line.c(create_fullest_file_path): Corrected\n      the comments for this function.\n2020-05-22: David Anderson\n    * dwarf_alloc.c: New functions with proper type checking:\n      dwarf_dealloc_error(), dwarf_dealloc_attribute(),\n      dwarf_dealloc_die().\n    * dwarf_arange.c: Now does correct free_aranges_chain() \n      and ensures chain entry stuff dealloc-d as appropriate.  \n    * dwarf_die_deliv.c: Improved an error message in reports\n      an address-size error.\n    * dwarf_frame.c: Initialize more local variables at the\n      point of declaration. Do  all needed dealloc of\n      the chain entries \n      when creating the list.\n    * dwarf_global.c: Now uses the new ch_itemtype\n      to dealloc properly.  Which simplifies the \n      dealloc_globals_chain() call.\n    * dwarf_line.c:  Now uses the new ch_itemtype\n      to dealloc properly.\n    * dwarf_line_table_reader_common.h: Now uses wrappers\n      for the READ_UNALIGNED_CK DECODE_LEB128_UWORD_CK etc\n      macros so the code\n      now deallocs appropriately in case of error.\n      Most places were not doing full dealloc. Now\n      all are.\n    * dwarf_opaque.h: New field ar_dbg so attribute\n      dealloc is easier.  New chain field ch_itemtype\n      so dealloc is simpler and safer.\n    * dwarf_query.c: Removed comment about leaking memory,\n      the leaks are fixed by using the DECODE_LEB128_UWORD_CK\n      etc wrapper functions.\n    * libdwarf.h.in: Declares the new dealloc functions\n      dwarf_dealloc_error(),dwarf_dealloc_die(),\n      dwarf_dealloc_attribute().\n    * generated_libdwarf.h.in: Regenerated.\n    * libdwarf2.1.mm: New documentation of dwarf_dealloc()\n      as well as documentation of\n      dwarf_dealloc_error(),dwarf_dealloc_die(),\n      dwarf_dealloc_attribute().\n    * libdwarf2.1.pdf: Regenerated. Version 2.94.\n2020-05-19: David Anderson\n    * dwarf_rnglists.c: Ommited a crucial assign to rh_debug so it\n      leaked if de_alloc_tree absent.\n2020-05-19: David Anderson\n    *  dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,dwarf_names_new.h,\n       libdwarf_version.h : New version strings.\n2020-05-19: David Anderson\n    * libdwarf.h.in: Revised a couple rnglists functions\n      by removing unneeded arguments and revising the arguments\n      to dwarf_rnglists_offset_get_rle_head(),\n      dwarf_get_rnglist_head_basics(), and\n      dwarf_get_rnglists_entry_fields()\n    * generated_libdwarf.h.in: Regenerated.\n    * dwarf_rnglists.c: Checked a pointer argument for null before using.\n      Remove the unneeded function arguments (affecting several internal\n      functions too). Renamed a few internal things for clarity.\n    * libdwarf2.1.mm: Documented the new rnglists functions\n      and added examples of use.\n    * libdwarf2.1.pdf: Regenerated. Version 2.93.\n2020-05-17: David Anderson\n    * dwarf_dnames.c: Improved error reporting of the names generation\n      when something goes wrong.\n    * dwarf_elf_access.c,dwarf_elfread.c: Add MATCH_REL_SEC \n      for the .debug_addr section.\n    * dwarf_form.c: Improved error reporting by showing specific details.\n      Now supports DW_FORM_rnglistx.  New function\n      dwarf_addr_form_is_indexed(theform) created, now using\n      it here and in dwarfdump as needed..\n    * dwarf_line_table_reader_common.h: Corrected indents.\n    * dwarf_opaque.h:  Small commentary changes, added the \n      CU Context field cc_dwo_name_present (used for \n      non-standard DWARF4).\n    * dwarf_query.c: Simplified some pointlessly messy code.\n      Now also using dwarf_addr_form_is_indexed() instead of\n      a list missing some DWARF5 values.\n    * dwarf_ranges.c: #if 0 some useless code for now. \n    * dwarf_rnglists.c: The .debug_rnglists code is here.\n    * dwarf_rnglists.h: For use inside libdwarf. Opaque\n      to libdwarf callers.\n    * dwarf_tsearchhash.c: Trivial change. No logic change.\n    * dwarf_util.c: Removed pointless blank line.\n    * dwarf_util.h, dwarf_xu_index.h: Fix trailing whitespace.\n    * libdwarf.h.in: New functions and opaque types for reading\n      the .debug_rnglists section.\n    * generated_libdwarf.h.in: Regenerated.\n2020-05-05: David Anderson\n    * dwarf_rnglists.h, dwarf_opaque.h, dwarf_rnglists.c: \n      Preliminary new fields/code for Rnglists_Context.\n2020-05-04: David Anderson\n    * dwarf_alloc.c: renamed dwarf_dealloc_rnglists\n      to _dwarf_dealloc_rnglists.\n    * dwarf_errmsg_list.h: Added DW_DLE_RNGLISTS_ERROR.\n    * dwarf_opaque.h: Added _dwarf_dealloc_rnglists() prototype.\n    * dwarf_rnglists.c: Minor corrections of this new code.\n    * dwarf_rnglists.h: Added a new field for internal use.\n      Deleted some #if 0 lines.\n    * dwarf_util.c(_dwarf_load_debug_info): Now also\n      calls dwarf_load_rnglists as we need that in the\n      Dwarf_Debug.\n    * libdwarf.h.in: Added DW_DLE_RNGLISTS_ERROR.\n      Deleted dwarf_dealloc_rnglists as it is renamed\n      and made private to libdwarf.\n    * generated_libdwarf.h.in: Regenerated.\n2020-05-02: David Anderson\n    * libdwarf2.1.mm: Added a note to Changes that\n      instances of 'length_size' in the code and headers\n      variable naming will, over time, be changed to \n      'offset_size' as this name suggests what they really\n      represent: a 4 or 8 byte offset size.\n    * libdwarf2.1.pdf: Regenerated, version 2.92\n2020-05-02: David Anderson\n    * CMakeLists.txt, Makefile.am: Added dwarf_rnglists.h,\n      dwarf_rnglists.c\n    * Makefile.in: Regenerated.\n    * dwarf_alloc.c: Now calls dwarf_dealloc_rnglists() at\n      finish to clean up rnglists data, if any.\n    * dwarf_arange.c: Deleted some blank lines and added one.\n    * dwarf_opaque.h: Added de_rnglists_context_count and\n      de_rnglists_context to support rnglists.\n    * dwarf_rnglists.h:  Defines the Dwarf_Rnglists_Context\n      structure.\n    * dwarf_rnglists.c:  Implements initial support of the\n      .debug_rnglists section.\n    * libdwarf.h.in: Declares new rnglist-related functions\n      and an opaque struct Dwarf_Rnglists_Context_s.\n    * generated_libdwarf.h.in: Regenerated.\n2020-04-26: David Anderson\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n      dwarf_names_new.h,libdwarf_version.h: Updated\n      version string.\n2020-04-25: David Anderson\n    * dwarf_abbrev.c: Fix trailing whitespace.\n    * dwarf_arange.c: Delete macro READ_UNALIGNED_CK\n      use an just use  _dwarf_read_unaligned_ck_wrapper.\n    * dwarf_die_deliv.c: Uses wrapper instead\n      of READ_UNALIGNED_CK where necessary.\n      Delete commented-out lines.\n    * dwarf_error.c: Remove unwanted debug  code.\n    * dwarf_form.c: Remove trailing whitespace.\n    * dwarf_global.c: Rename some arguments for greater\n      clarity.\n    * dwarf_line.c: Fix line handling so both DW5\n      and earlier handled better.  Improve some error\n      messages.\n    * dwarf_macro5.c:  Use wrapper() funcs, not\n      READ_UNALIGNED_CK and fix a couple local\n      variables so that works.\n    * dwarf_ranges.c: Remove trailing whitespace.\n    * dwarf_util.c: Remove trailing whitespace.\n2020-04-24: David Anderson\n    * dwarf_die_deliv.c: Now using wrappers so that\n      errors do not lead to a temporary leak.\n    * dwarf_global.c: Now ensures that an error\n      in reading globals does not lead to temporary\n      leaks that rely on dwarf_finish() to clean up.\n2020-04-24: David Anderson\n    * dwarf_names.c,dwarf_names.h, dwarf_names_enum.h,\n      dwarf_names_new.h, libdwarf_version.h: \n      updated version string.\n2020-04-23: David Anderson\n    * dwarf_arange.c: Using new wrapper() code\n      so that the reader macros do not interfere\n      with doing appropriate dealloc.\n    * dwarf_util.c: Implement new wrapper functions\n      _dwarf_read_unaligned_ck_wrapper() and\n      _dwarf_read_area_length_ck_wrapper.\n    * dwarf_util.h: Declare the new functions.\n2020-04-22: David Anderson\n    * libdwarf.h.in: Added DW_DLE_USER_DECLARED_ERROR\n      and the dwarf_error_creation() function that creates\n      the Dwarf_Error.\n    * generated_libdwarf.h.in: Regenerated.\n2020-04-20: David Anderson\n    * dwarf_form.c: Split a too-long comment line.\n2020-04-16: David Anderson\n    * dwarf_line_table_reader_common.h: more detailed error\n      messages in a few cases.\n    * dwarf_print_lines.c: Added dwarf_check_lineheader_b()\n      as dwarf_check_lineheader() did not return error\n      details.\n    * libdwarf.h.in: defined prototype for \n      dwarf_check_lineheader_b();\n    * generated_libdwarf.h.in: regenerated.\n2020-04-14: David Anderson\n    * libdwarf2.1.mm: Fixed wording \n      of dwarf_get_fde_info_for_cfa_reg3_b()\n      which had the 1/0 value of has_more_rows\n      backwards.\n      Corrected several misspellings. \n    * libdwarf2.1.pdf: Regenerated, v2.91.\n2020-04-13: David Anderson\n    * dwarf_abbrev.c: Various errors now show additional detail\n      about what exactly is wrong.\n2020-04-11: David Anderson\n    * dwarf_die_deliv.c,dwarf_xu_index.c: Each had\n      a single trailing space. Removed. \n2020-04-11: David Anderson\n    * dwarf_global.c: Changed break to continue\n      so we don't stop the loop too early, yet\n      still avoid leaking a useless.\n2020-04-10: David Anderson\n    * debug-cu-tu-indexes-layout.odg: The Split-Dwarf\n      (aka debugfission) table layout is simple, but\n      this is an introduction to the \n      layout of the arrays.  LibreOffice Draw document.\n    * dwarf_init_finish.c: Small enhancements of error messages.\n    * dwarf_util.c: Reformatted a macro here\n      (READ_UNALIGNED_CK) so the lines are not so long\n      and the backslashes are easily seen as complete.\n    * dwarf_xu_index.c: There was some confusion in the\n      code which prevented it from working.\n      Interfaces remain the same, but things work now.\n      The first part is a 20 line (or so) explanation\n      of some of the internal handling of the tables.\n      Now things work. Many error messges get\n      detailed information.\n    * dwarf_xu_index.h: Added new fields and relabeled\n      the N U S fields in the header to match the\n      DWARF5 standard.\n    * libdwarf2.1.mm: Rev 2.90 10 April 2020.\n      A little bit of reformatting to shorten the lines\n      here. Has little or no effect on the output pdf.\n      corrected the wording about the\n      dwarf_get_xu_section_offset() function. \n    * libdwarf2.1.pdf: Regenerated Rev 2.90.\n2020-04-07: David Anderson\n    * dwarf_alloc.c: Deleted useless comment and added\n      a blank line to separate declarations from code.\n    * dwarf_frame2.c:  Fixed a too-long line.\n    * dwarf_query.c: Now DW_DLE_ALLOC_FAIL has a meaningful\n      error string attached.\n    * dwarf_util.c: Added comment before CHECK_DIE macro.\n2020-04-03: David Anderson\n    * dwarf_arange.c: Deleted a useless blank line.\n      Removed useless () around a return value.\n2020-04-03: David Anderson\n    *  dwarf_form.c,dwarf_frame2.c,dwarf_query.c: Fix indents and\n       remove trailing whitespace.\n2020-04-02: David Anderson\n    * dwarf_die_deliv.c: Better text printed for an address size error\n      including reporting the actual addrss-size found by libdwarf.\n    * dwarf_frame2.c: Deleted a static version of\n      _dwarf_create_address_size_dwarf_error() and use\n      the global one. Revised some error messages to\n      have specific details. Each instance of\n      DW_DLE_DEBUG_FRAME_LENGTH_BAD now reports something\n      specific about each case.\n    * dwarf_opaque.h: Added a declaration of\n      _dwarf_create_address_size_dwarf_error().\n2020-03-28: David Anderson\n    * dwarf_global.c: dwarf_return_empty_pubnames() revised\n      so it cannot fail.\n    * libdwarf.h.in: Revised comments attached to\n      dwarf_return_empty_pubnames() function prototype.\n    * generated_libdwarf.h.in: Regenerated.\n2020-03-27: David Anderson\n    * dwarf_names.c,dwarf_names.h, dwarf_names_enum.h,\n      dwarf_names_new.h, libdwarf_version.h: \n      updated version string.\n2020-03-27: David Anderson\n    * dwarf_form.c,dwarf_query.c,dwarf_ranges.c: Improve various\n      error messages with specific information about the\n      error.\n2020-03-27: David Anderson\n    * dwarf_ranges.c: Properly detect end-of-section\n      again.\n2020-03-27: David Anderson\n    * dwarf_alloc.c, dwarf_form.c: Removed\n      trailing whitespace.\n2020-03-27: David Anderson\n    * dwarf_alloc.c: The (static) list of DW_DLA \n      initializers was very messy and hard to read.\n      Cleaned up its appearance.`\n      Added the 'type' to the fields that -DDEBUG\n      prints.\n    * dwarf_form.c,dwarf_util.c: The DW_DLE_FORM_BLOCK_LENGTH_ERROR\n      error messages now have a longer and more\n      complete error string.\n2020-03-26: David Anderson\n    * dwarf_alloc.c,dwarf_error.c: Changed spelling of the\n      -DDEBUG prefixes to \"libdwarfdetector\"\n    * libdwarf2.1.mm: Documented hints on finding libdwarf\n      and libdwarf-caller memory leaks. Section 6.33\n    * libdwarf2.1.pdf: Regenerated, version 2.89\n2020-03-26: David Anderson\n    * dwarf_alloc.c,dwarf_error.c:  Now DEBUG can be turned on via\n      CFLAGS at configure time. Or left off by default.\n      Changed all the fprintf here (debug stuff) to\n      do printf instead.\n    * dwarf_die_deliv.c,dwarf_frame2.c: Altered the \n      DW_DLE_ADDRESS_SIZE_ERROR\n      strings so the 3 cases can be distinquished easily\n      (just a convenience for debugging).\n    * dwarf_globals.c: Removed one superfluous ().\n    * dwarf_query.c: Reforatted lgpl text for shorter\n      lines (no change in the content).\n      Removed one superfluous ().\n2020-03-25: David Anderson\n    * dwarf_alloc.c, dwarf_error.c: Revised the debug\n      output created if DEBUG is defined.\n2020-03-25: David Anderson\n    * dwarf_die_deliv.c: Fix trailing whitespace.\n    * dwarf_frame2.c:    Fix trailing whitespace.\n2020-03-24: David Anderson\n    * dwarf_line.c: Deleted useless blank line.\n2020-03-24: David Anderson\n    * dwarf_alloc.c: Now with #ifdef DEBUG of debug messages in\n      various places as thise get needed over and over.\n    * dwarf_die_deliv.c: Working toward complete dealloc\n      of resources to eliminate the  dependence on de_alloc_tree.\n    * dwarf_error.c: #if 0 a debug message.\n    * dwarf_form.c: Remove superflous ().\n    * dwarf_global.c(_dwarf_internal_globals_dealloc):\n      Recreated and documented critical dealloc code\n      so Dwarf_Global_Context gets dealloc-c.\n    * dwarf_line.c: Add a return DW_DLV_ERROR after\n      an error Dwarf_Error is created..\n2020-03-23: David Anderson\n    * dwarf_die_deliv.c,dwarf_frame2.c: Some error messages\n      are now far more precise (showing values).\n    * dwarf_global.c: Correcting leakage and making\n      some error messages more precise.\n    * dwarf_print_lines.c: Correcting leakages.\n    * dwarf_pubtypes.c: Minor readability change.\n2020-03-21: David Anderson\n    * dwarf_abbrev.c Move leb wrapper functions to dwarf_util.[ch]:\n      and rename as _dwarf.....\n      Make certain error conditions more explicit (better\n      text in the error string).\n    * dwarf_die_deliv.c: Move leb wrapper functions to dwarf_util.[ch]\n      and rename as _dwarf.....\n    * dwarf_frame2.c: Add {} for the few 'if' missing same.\n    * dwarf_line.c: In case of form error make the error\n      text more useful.\n    * dwarf_query.c: Move leb wrapper functions to dwarf_util.[ch]\n      and rename as _dwarf.....\n    * dwarf_util.c, dwarf_util.h: Add the renamed\n      _dwarf_leb128_uword_wrapper() and\n      _dwarf_leb128_sword_wrapper() for general use\n      where better error messages are advisable.\n    * dwarf_init_finish.c: Removed a single trailing blank.\n    * libdwarf.h.in: Removed trailing spaces.\n    * generated_libdwarf.h.in: Regenerated.\n2020-03-20: David Anderson\n    * dwarf_arange.c: In case of error, was failing\n      to clean up all allocations.\n    * dwarf_macro5.c: Was preventing some dwarf_dealloc().\n      Fixed.\n2020-03-19: David Anderson\n    * dwarf_abbrev.c: Generates a more useful and specific\n      message in case a TAG is corrupt.\n    * dwarf_line.c: After dealloc assign 0 to the pointer.\n    * dwarf_die_deliv.c: Improved insert_into_context_list()\n      for clarity and correctness. \n    * dwarf_error.c: Removed a couple \"!= NULL\" in if\n      conditions.\n    * dwarf_query.c: Uses local variable now to\n      satisfy the usual libdwarf convention that in case\n      of DW_DLV_NO_ENTRY or DW_DLV_ERROR only the\n      Dwarf_Error argument is altered, not other\n      pointer args.\n    * dwarf_util.h: Declaration for _dwarf_format_TAG_err_msg()\n    * dwarf_util.c: Generates a more useful and specific\n      message in in _dwarf_format_TAG_err_msg()\n      in case a TAG is corrupt.\n2020-03-18: David Anderson\n    * dwarf_die_deliv.c: Rewrote the function that\n      keeps the cu_context list in the proper order.\n      For clarity and correctness.\n2020-03-16: David Anderson\n    * dwarf_alloc.c: A recent change had the wrong\n      test during initial Dwarf_Debug\n      struct setup meaning dwarf_finish() was not cleaning\n      up allocations. This made the runtimes better\n      than they should be. Important correction here.\n    * dwarf_die_deliv.c: Drop use of the dwarf_dieoff()\n      context list, that was never appropriate. Now\n      again with one list.\n    * dwarf_opaque.h: Removed a list of Dwarf_CU_Contexts,\n      that was never correct to have dwarf_offdie maintain\n      a list separate from iterating through CUs.\n    * dwarf_query.c (dwarf_attrlist): Add a \n      dwarf_dealloc on abbrev_list\n      in an error case.\n    * dwarf_util.c: Make the lines look a tiny bit\n      better avoiding too-long lines.\n2020-03-15: David Anderson\n    * dwarf_frame2.c: On an internal error (bad dwarf)\n      the necessary cleanup function was not being called\n      in two places.\n2020-03-15: David Anderson\n    * dwarf_alloc.c: Now with configure-time options\n      for tracking the alloc/dealloc actions in detail.\n2020-03-15: David Anderson\n    * dwarf_alloc.c: Now with the de_alloc_tree tests\n      in final form. Respecting dwarf_set_de_alloc_flag().\n2020-03-14: David Anderson\n    * dwarf_alloc.c: Now adds an optional DEBUG\n      macro that libdwarf developers may find useful.\n      Revised the dwarf_dealloc code to not require de_alloc_tree.\n    * dwarf_line.c: Now dwarf_srcfiles() and dwarf_filename()\n      always allocate DW_DLA_STRINGS. Whereas earlier some\n      of the strings were actually in a .debug section,\n      not allocated. \n    * libdwarf2.1.mm: Now dwarf_diename()  and\n      dwarf_die_text are documented\n      as returning static strings that are not be be\n      freed or dwarf_dealloc'd.  This was always true\n      but the documentation said dwarf_dealloc() was\n      required. Don't use dwarf_dealloc on these returned\n      strings.\n    * libdwarf2.1.pdf: Regenerated, version 2.88\n    * dwarf_loc.c: Was incorrectly passing NULL instead\n      of dbg to _dwarf_get_alloc in a few places.\n    * dwarf_util.c, dwarf_global.c: Now checks more for\n      incomplete setup\n      of an internal structure to avoid calling dwarf_dealloc\n      with NULL as the space to be freed.\n2020-03-13: David Anderson\n    * dwarf_abbrev.c: Remove erroneous dwarf_dealloc\n      introduced yesterday. Caused a coredump\n      in FreeBSD 64bit dwarfdump testing.\n    * dwarfstring.c: Introduced an extra zero initializer in\n      the dwarfstring_destructor() as safe and harmless.\n2020-03-12: David Anderson\n    * dwarf_abbrev.c: Use a wrapper on macro\n      DECODE_LEB128_UWORD_CK\n      so we can dwarf_dealloc in case of a problem.\n      And be more thorough in various places\n      for those dwarf_dealloc.\n2020-03-12: David Anderson\n    * dwarf_die_deliv.c:  A local function now explicitly\n      static (_dwarf_siblingof_internal). \n      Following dwarf_dealloc of cudie  we assign 0 to it.`\n      New function local_dealloc_cu_context() enables\n      accurate and full dealloc of a cu context\n      (which means there was some error fount) in\n      an easy and complete way.\n      local_attrlist_dealloc() does similarly for attrlists.\n      A DECODE_LEB128_UWORD_CK now in a wrapper so on error\n      we can dwarf_dealloc a DIE.\n    * dwarf_macro5.c: Now dwarf_dealloc_macro_context() is safe\n      if called with a null argument (and in that case there\n      is nothing to do).\n    * dwarf_opaque.h: Removed _dwarf_siblingof_internal()\n      from the declared functions.\n2020-03-12: David Anderson\n    * dwarf_alloc.h, dwarf_opaque.h: Removed trailing whitespace.\n      Shortened the lines of the LGPL text (the text\n      is unchanged).\n2020-03-12: David Anderson\n    * dwarf_str_offsets.c,dwarf_util.c: Removed trailing whitespace\n      and fixed indent mistakes.\n2020-03-12: David Anderson\n    * dwarf_query.c: Adds wrapper code around some\n      dwarf_util.h macros\n      so in case of a serious DWARF error we can\n      free locally allocated things.\n2020-03-12: David Anderson\n    * dwarf_errmsg_list.h: Corrected DW_DLE_STR_OFFSETS_EXTRA_BYTES\n      text. The error messages have more detail due to \n      the dwarf_str_offsets.c changes below, so fixed\n      the string here.\n2020-03-12: David Anderson\n    * dwarf_macro5.c: Do proper dwarf_dealloc, avoiding\n      a pointless dependency on de_alloc_tree freeing \n      things.\n2020-03-12: David Anderson\n    * dwarf_alloc.c: Minor cleanup that assigns\n      zero after dwarf_dealloc so dead pointers\n      not left around.\n2020-03-12: David Anderson\n    * dwarf_str_offsets.c: Improve messages in case of\n      a serious DWARF error, reporting what is wrong\n      more precisely and allowing a few bytes of all-zero-bits\n      to be allowed at end of section (no error needed).\n2020-03-12: David Anderson\n    * dwarf_util.c: Revise too-long lines and checks for NULL\n      pointers for moderm readability.\n      Improve _dwarf_free_abbrev_hash_table_contents() so\n      it can safely free an incompletely set up hash table.\n2020-03-09: David Anderson\n    * dwarf_alloc.c: Implements optional (at run time)\n      reduced use of the de_alloc_tree search tree\n      as a performance enhancement (see libdwarf2.1.mm/pdf).\n    * dwarf_alloc.h: Declares _dwarf_alloc_tree_counts(),\n      a new hidden function.\n    * libdwarf_version.h: New date string\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n      dwarf_names_new.h: New date string so regenerated\n      these.\n    * libdwarf.h.in: New function dwarf_set_de_alloc_flag()\n      declared.\n    * generated_libdwarf.h.in: Regenerated\n2020-03-02: David Anderson\n    * dwarf_print_lines.c: Removed one-line #if 0\n      code that serves no purpose.\n2020-02-25: David Anderson\n    * dwarf_print_lines.c: Removed space character just before newline\n      as it  has no useful prupose. 3 places.\n2020-02-25: David Anderson\n    * dwarf_names.c,dwarf_names.h, dwarf_names_enum.h,\n      dwarf_names_new.h:\n      libdwarf_version.h: updated version string.\n2020-02-25: David Anderson\n    * dwarf_line_table_reader_common.h: Now with dwarfstring\n      containers in local scopes and easily evaluated\n      as to lifetime and correctness.\n2020-02-25: David Anderson\n    * dwarf_elfread.c: Deleted a #if 0 ...#endif few lines.\n    * dwarf_line.c: Fixed trailing whitespace.\n    * dwarf_line_table_reader_common.h: Removed all use of the\n      old dwarf_printf varargs code.  Instead using dwarfstring\n      and dwarfstring_append_printf_i() etc.\n      And a far simpler _dwarf_printf().\n      No longer any sprintf/snprintf/vsnprintf here.\n    * dwarf_opaque.h: Remove trailing whitespace.\n    * dwarf_print_lines.c: Removed all use of the\n      old dwarf_printf varargs code.\n      No longer any sprintf/snprintf/vsnprintf here.\n    * dwarf_util.c: Delete unused buffersetsize function.\n      Delete now-unuised dwarf_printf()\n    * dwarfstring.c: Now using TRUE FALSE, not DW_DLV anything.\n      No one will be testing the integer return value anyway.\n      Fixed the code where %-4s was truncating if the string\n      to be processed was longer than 4 characters.\n    * dwarfstring.h: Added commentary.\n    * test_dwarfstring.c: New testcase for dwarfstring\n2020-02-21: David Anderson\n    * dwarf_arange.c,dwarf_debuglink.c,dwarf_frame2.c:\n      removed the last sprintf/snprintf, changed to \n      use dwarfstring.h functions.\n2020-02-18: David Anderson\n    * dwarf_line.c: Added free() calls to delete_line_context_itself\n      to avoid a leak that was created in last commit..\n    * dwarf_line.h: Deleted a now-spurious comment.\n    * dwarf_line_table_reader_common.h: Removed an == NULL\n      comparison in favor of a !filename_entry_pairs.\n2020-02-16: David Anderson\n    * libdwarf2.1.mm: Now explains how dwarf_srcfiles()\n      name arrays differ in DWARF5 from earlier\n      debug_info versions. So callers can use\n      the srcfiles array properly.\n    * libdwarf2.1.pdf: Now version 2.87, dated 16 February 2020.\n    * dwarf_line.c, dwarf_line.h,dwarf_print_lines.c,\n      dwarf_line_table_reader_common.h: Recording DW5 line table\n      header data more fully so lines print verbose\n      prints more of the actual line table header.\n2020-02-15: David Anderson\n    * dwarf_elf_access.c,dwarf_init_finish.c: With libelf\n      in use there was a mistake that broke dumping some objects that\n      needed relocations.\n    * dwarf_opaque.h: Corrected a is_rela to r_is_rela\n2020-02-13: David Anderson\n    * dwarf_elfread.c,dwarf_errmsg_list.h: Removed\n      trailing whitespace.\n2020-02-13: David Anderson\n    *  libdwarf_version.h: New version string \n    *  dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n       dwarf_names_new.h: Regenerated with new\n       version string.\n2020-02-13: David Anderson\n     * libdwarf/libdwarf.h.in: Added a new error code to\n       properly distinguish between distinct elf section\n       header issues related to relocations versus\n       other section header issues.\n     * libdwarf/generated_libdwarf.h.in: regenerated\n\n    * dwarf_elf_access.c: Adding local READ_UNALIGNED_SAFE\n      so we can do libelf relocations properly; .rel and .rela.\n    * dwarf_elf_defines.h: Adding R_386_PC32 to the \n      applicable relocation sets.\n    * dwarf_elf_load_headers.c: Now we deal with .rel.\n      and .rela. relocations for better completeness.\n      Removed some code duplication and complexity\n      too.\n    * dwarf_elf_rel_detector.c: Deals with R_386_PC32 now.\n    * dwarf_elfread.c: Add READ_UNALIGNED_SAFE so we can\n      do no-libelf relocations properly; .rel and .rela\n    * dwarf_elfread.h: Added gr_is_rela field and\n      two enums RelocRela and RelocOffsetSize so we have\n      type-safety in the argument lists.\n    * dwarf_init_finish.c: A new function ensures we\n      skip various sections we know we do not want to\n      look at.\n    * dwarf_opaque.h: Declare _dwarf_ignorethissection()\n      so libelf and non-libelf can ignore the unwanted\n      sections.\n    *  dwarf_errmsg_list.h: Entry added for the new\n       DW_DLE error code.\n2020-02-11: David Anderson\n    * dwarf_elf_access.c,dwarf_line_table_reader_common.h,\n      dwarf_tied_decls.h:\n      removed trailing whitespace and final blank line.\n2020-02-11: David Anderson\n    * dwarf_init_finish.c: Removed code that was #if 0 #endif\n2020-02-10: David Anderson\n    * dwarf_elf_access.c: Now allows for .rel and .rela.\n    * dwarf_elf_defines.h: Now allows for .rel and .rela.\n    * dwarf_init_finish.c: Now allows for .rel and .rela.\n    * dwarf_opaque.h: Adding dss_is_rela so we can\n      process .rel. sections too.\n2020-01-25: David Anderson\n    * dwarf_form.c: DW_FORM_rnglistx was ommitted from a switch statement.\n      Adding it in fixed the resulting errors in a DWARF5 object file\n      built by clang 9.0.0.0\n2020-01-16: David Anderson\n    * dwarf_alloc.c,dwarf_die_deliv.c,dwarf_form.a,\n      dwarf_query.c,dwarfstring.c,\n      pro_reloc.c,pro_reloc_stream.c,pro_reloc_symbolic.c,\n      pro_section.c,pro_types.c,pro_vars.c,pro_weaks.c,\n      test_dwarfstring.c: Fixed indentations and\n      removed trailing whitespace.\n    * dwarf_xu_index.c: Ensure local Dwarf_Sig8 variables\n      are always initialized. Does not fix any bug but\n      does make it easier to read the code.\n      Fixes indentation and removes trailing whitespace too.\n2020-01-14: David Anderson\n    * dwarf_names.c,dwarf_names.h,dwarf_names_enum.h,\n      dwarf_names_new.h,libdwarf_version.h: Updated version string.\n2020-01-05: David Anderson\n    * dwarf_query.c(dwarf_offset_list): Coverity Scan CID 206598.\n      Now checks for DW_DLV_ERROR where it failed to do so before,\n      and returns an error instead of letting it slip through.\n2020-01-03: David Anderson\n    * dwarf_load_elf_headers.c(dwarf_elf_load_rela_32):\n      Coverity Scan uncovered a memory leak in one\n      case. CID 206524\n", "/*\n  Copyright (C) 2000,2002,2004,2005,2006 Silicon Graphics, Inc.  All Rights Reserved.\n  Portions Copyright (C) 2007-2020 David Anderson. All Rights Reserved.\n  Portions Copyright 2012 SN Systems Ltd. All rights reserved.\n\n  This program is free software; you can redistribute it\n  and/or modify it under the terms of version 2.1 of the\n  GNU Lesser General Public License as published by the Free\n  Software Foundation.\n\n  This program is distributed in the hope that it would be\n  useful, but WITHOUT ANY WARRANTY; without even the implied\n  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n  PURPOSE.\n\n  Further, this software is distributed without any warranty\n  that it is free of the rightful claim of any third person\n  regarding infringement or the like.  Any license provided\n  herein, whether implied or otherwise, applies only to this\n  software file.  Patent licenses, if any, provided herein\n  do not apply to combinations of this program with other\n  software, or any other product whatsoever.\n\n  You should have received a copy of the GNU Lesser General\n  Public License along with this program; if not, write the\n  Free Software Foundation, Inc., 51 Franklin Street - Fifth\n  Floor, Boston MA 02110-1301, USA.\n\n*/\n\n#include \"config.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#include \"dwarf_incl.h\"\n#include \"dwarf_alloc.h\"\n#include \"dwarf_error.h\"\n#include \"dwarf_util.h\"\n#include \"dwarf_line.h\"\n#include \"dwarfstring.h\"\n\n#define PRINTING_DETAILS 1\n/*  for dwarfstring_constructor_static, saving lots of malloc\n    and free but beware: make sure each routine using\n    this DOES NOT call another routine using it.\n    would be safer to have a buffer per function, but\n    currently not necessary. */\nstatic char locallinebuf[200];\n\nstatic void\nprint_line_header(Dwarf_Debug dbg,\n    Dwarf_Bool is_single_tab,\n    Dwarf_Bool is_actuals_tab)\n{\nif (!is_single_tab) {\n    /*  Ugly indenting follows, it makes lines shorter\n        to see them better.\n        Best to use a wider text window to really\n        see how it looks.*/\nif (is_actuals_tab) {\n_dwarf_printf(dbg,\"\\nActuals Table\\n\");\n_dwarf_printf(dbg,\n\"                                                         be\\n\"\n\"                                                         ls\\n\"\n\"                                                         ce\\n\"\n\" section    op                                           kq\\n\"\n\" offset     code                address/index    row isa ??\\n\");\n    return;\n} else {\n_dwarf_printf(dbg,\"\\nLogicals Table\\n\");\n_dwarf_printf(dbg,\n\"                                                                              s pe\\n\"\n\"                                                                              tirp\\n\"\n\"                                                                              msoi\\n\"\n\" section          op                                                          tall\\n\"\n\" offset      row  code                address/indx fil lne col disc cntx subp ????\\n\");\n    return;\n}\n}\n\n/* Single level table */\n_dwarf_printf(dbg,\n\"                                                         s b e p e i d\\n\"\n\"                                                         t l s r p s i\\n\"\n\"                                                         m c e o i a s\\n\"\n\" section    op                                       col t k q l l   c\\n\"\n\" offset     code               address     file line umn ? ? ? ? ?\\n\");\n} /* End of function with ugly indenting. */\n\nstatic void\nprint_line_detail(\n    Dwarf_Debug dbg,\n    const char *prefix,\n    int opcode,\n    unsigned curr_line,\n    struct Dwarf_Line_Registers_s * regs,\n    Dwarf_Bool is_single_table, Dwarf_Bool is_actuals_table)\n{\n    dwarfstring m1;\n\n    dwarfstring_constructor_static(&m1,locallinebuf,\n        sizeof(locallinebuf));\n    if(!is_single_table && is_actuals_table) {\n        dwarfstring_append_printf_s(&m1,\"%-15s \",(char *)prefix);\n        dwarfstring_append_printf_i(&m1,\"%3d \",opcode);\n        dwarfstring_append_printf_u(&m1,\"0x%\" DW_PR_XZEROS DW_PR_DUx,\n            regs->lr_address);\n        dwarfstring_append_printf_u(&m1,\"/%01u\",regs->lr_op_index);\n        dwarfstring_append_printf_u(&m1,\" %5lu\", regs->lr_line);\n        dwarfstring_append_printf_u(&m1,\" %3d\",regs->lr_isa);\n        dwarfstring_append_printf_i(&m1,\"   %1d\",\n            regs->lr_basic_block);\n        dwarfstring_append_printf_i(&m1,\"%1d\\n\",\n            regs->lr_end_sequence);\n        _dwarf_printf(dbg,dwarfstring_string(&m1));\n        dwarfstring_destructor(&m1);\n        return;\n    }\n    if(!is_single_table && !is_actuals_table) {\n        dwarfstring_append_printf_i(&m1,\n            \"[%3d] \"  /* row number */, curr_line);\n        dwarfstring_append_printf_s(&m1,\n            \"%-15s \",(char *)prefix);\n        dwarfstring_append_printf_i(&m1,\n            \"%3d \",opcode);\n        dwarfstring_append_printf_u(&m1,\n            \"x%\" DW_PR_XZEROS DW_PR_DUx, regs->lr_address);\n        dwarfstring_append_printf_u(&m1,\n            \"/%01u\", regs->lr_op_index);\n        dwarfstring_append_printf_u(&m1,\" %2lu \",regs->lr_file);\n        dwarfstring_append_printf_u(&m1,\"%4lu  \",regs->lr_line);\n        dwarfstring_append_printf_u(&m1,\"%1lu\",regs->lr_column);\n        if (regs->lr_discriminator ||\n            regs->lr_prologue_end ||\n            regs->lr_epilogue_begin ||\n            regs->lr_isa ||\n            regs->lr_is_stmt ||\n            regs->lr_call_context ||\n            regs->lr_subprogram) {\n            dwarfstring_append_printf_u(&m1,\n                \"   x%02\" DW_PR_DUx ,\n                regs->lr_discriminator); /* DWARF4 */\n            dwarfstring_append_printf_u(&m1,\n                \"  x%02\" DW_PR_DUx,\n                regs->lr_call_context); /* EXPERIMENTAL */\n            dwarfstring_append_printf_u(&m1,\n                \"  x%02\" DW_PR_DUx ,\n                regs->lr_subprogram); /* EXPERIMENTAL */\n            dwarfstring_append_printf_i(&m1,\n                \"  %1d\", regs->lr_is_stmt);\n            dwarfstring_append_printf_i(&m1,\n                \"%1d\", (int) regs->lr_isa);\n            dwarfstring_append_printf_i(&m1,\n                \"%1d\", regs->lr_prologue_end); /* DWARF3 */\n            dwarfstring_append_printf_i(&m1,\n                \"%1d\", regs->lr_epilogue_begin); /* DWARF3 */\n        }\n        dwarfstring_append(&m1,\"\\n\");\n        _dwarf_printf(dbg,dwarfstring_string(&m1));\n        dwarfstring_destructor(&m1);\n        return;\n    }\n    /*  In the first quoted line below:\n        3d looks better than 2d, but best to do that as separate\n        change and test from two-level-line-tables.  */\n    dwarfstring_append_printf_s(&m1,\n        \"%-15s \",(char *)prefix);\n    dwarfstring_append_printf_i(&m1,\n        \"%2d \",opcode);\n    dwarfstring_append_printf_u(&m1,\n        \"0x%\" DW_PR_XZEROS DW_PR_DUx \" \",\n        regs->lr_address);\n    dwarfstring_append_printf_u(&m1,\n        \"%2lu   \", regs->lr_file);\n    dwarfstring_append_printf_u(&m1,\n        \"%4lu \", regs->lr_line);\n    dwarfstring_append_printf_u(&m1,\n        \"%2lu   \", regs->lr_column);\n    dwarfstring_append_printf_i(&m1,\n        \"%1d \",regs->lr_is_stmt);\n    dwarfstring_append_printf_i(&m1,\n        \"%1d \", regs->lr_basic_block);\n    dwarfstring_append_printf_i(&m1,\n        \"%1d\",regs->lr_end_sequence);\n    if (regs->lr_discriminator ||\n        regs->lr_prologue_end ||\n        regs->lr_epilogue_begin ||\n        regs->lr_isa) {\n        dwarfstring_append_printf_i(&m1,\n            \" %1d\", regs->lr_prologue_end); /* DWARF3 */\n        dwarfstring_append_printf_i(&m1,\n            \" %1d\", regs->lr_epilogue_begin); /* DWARF3 */\n        dwarfstring_append_printf_i(&m1,\n            \" %1d\", regs->lr_isa); /* DWARF3 */\n        dwarfstring_append_printf_u(&m1,\n            \" 0x%\" DW_PR_DUx , regs->lr_discriminator); /* DWARF4 */\n    }\n    dwarfstring_append(&m1, \"\\n\");\n    _dwarf_printf(dbg,dwarfstring_string(&m1));\n    dwarfstring_destructor(&m1);\n}\n\n\n#include \"dwarf_line_table_reader_common.h\"\n\n\nstatic void\nprint_include_directory_details(Dwarf_Debug dbg,\n    unsigned int line_version,\n    Dwarf_Line_Context line_context)\n{\n    Dwarf_Unsigned u = 0;\n    dwarfstring    m4;\n    Dwarf_Unsigned indexbase = 0;\n    Dwarf_Unsigned indexlimit = 0;\n\n    dwarfstring_constructor_static(&m4,locallinebuf,\n        sizeof(locallinebuf));\n    if (line_version == DW_LINE_VERSION5) {\n        unsigned i = 0;\n        unsigned dfcount =\n            line_context->lc_directory_entry_format_count;\n\n        dwarfstring_constructor(&m4);\n        dwarfstring_append_printf_u(&m4,\n            \"  directory entry format count %u\\n\",dfcount);\n        _dwarf_printf(dbg,dwarfstring_string(&m4));\n        dwarfstring_reset(&m4);\n        for ( ; i < dfcount;++i) {\n            struct Dwarf_Unsigned_Pair_s *valpair = 0;\n            const char *tname = 0;\n            const char *fname = 0;\n            int res;\n\n            valpair = line_context->lc_directory_format_values +i;\n            dwarfstring_append_printf_u(&m4,\n                \"  format [%2u] \",i);\n            res = dwarf_get_LNCT_name(valpair->up_first,\n                &tname);\n            if ( res != DW_DLV_OK) {\n                tname = \"<unknown type>\";\n            }\n            dwarfstring_append_printf_u (&m4,\n                \" type 0x%\" DW_PR_XZEROS DW_PR_DUx,\n                valpair->up_first);\n            dwarfstring_append_printf_s (&m4,\n                \" %-20s\\n\",(char *)tname);\n            res = dwarf_get_FORM_name(valpair->up_second,&fname);\n            if ( res != DW_DLV_OK) {\n                fname = \"<unknown form>\";\n            }\n            dwarfstring_append_printf_u(&m4,\n                \"               code 0x%\" DW_PR_XZEROS DW_PR_DUx ,\n                valpair->up_second);\n            dwarfstring_append_printf_s(&m4,\n                \" %-20s\\n\", (char *)fname);\n            _dwarf_printf(dbg,dwarfstring_string(&m4));\n            dwarfstring_reset(&m4);\n\n        }\n    }\n    /*  Common print of the directories.\n        For DWARF 2,3,4 it has always started\n        the indexing at 0 even though the directory index\n        in line entries starts at 1 (zero meaning\n        current directory at compile time).\n        That is odd, given the non-dash-v printed\n        starting at 1.  So lets adjust for consistency. */\n    if (line_version == DW_LINE_VERSION5) {\n        dwarfstring_append_printf_i(&m4,\n            \"  include directories count %d\\n\",\n            (int) line_context->lc_include_directories_count);\n    } else {\n        if(!line_context->lc_include_directories_count) {\n            dwarfstring_append_printf_i(&m4,\n                \"  include directories count %d\\n\",\n                (int) line_context->lc_include_directories_count);\n        } else {\n            dwarfstring_append_printf_i(&m4,\n                \"  include directories count %d\"\n                \" (index starts at 1)\\n\",\n                (int) line_context->lc_include_directories_count);\n        }\n    }\n    _dwarf_printf(dbg,dwarfstring_string(&m4));\n    dwarfstring_reset(&m4);\n    if (line_version == DW_LINE_VERSION5) {\n        indexbase = 0;\n        indexlimit =  line_context->lc_include_directories_count;\n    } else {\n        indexbase = 1;\n        indexlimit = 1 + line_context->lc_include_directories_count;\n    }\n    for (u = indexbase; u < indexlimit; ++u) {\n        dwarfstring_append_printf_u(&m4,\n            \"  include dir[%u] \",u);\n        dwarfstring_append_printf_s(&m4,\n            \"%s\\n\",(char *)\n            line_context->lc_include_directories[u-indexbase]);\n        _dwarf_printf(dbg,dwarfstring_string(&m4));\n        dwarfstring_reset(&m4);\n    }\n    dwarfstring_destructor(&m4);\n}\n\nstatic void\nprint_just_file_entry_details(Dwarf_Debug dbg,\n    Dwarf_Line_Context line_context)\n{\n    unsigned fiu = 0;\n    Dwarf_File_Entry fe = line_context->lc_file_entries;\n    Dwarf_File_Entry fe2 = fe;\n    dwarfstring m3;\n\n    dwarfstring_constructor_static(&m3,locallinebuf,\n        sizeof(locallinebuf));\n    dwarfstring_append_printf_i(&m3,\n        \"  file names count      %d\\n\",\n        line_context->lc_file_entry_count);\n    _dwarf_printf(dbg,dwarfstring_string(&m3));\n    dwarfstring_reset(&m3);\n    for (fiu = 0 ; fe2 ; fe2 = fe->fi_next,++fiu ) {\n        Dwarf_Unsigned tlm2 = 0;\n        unsigned filenum = 0;\n\n        fe = fe2;\n        tlm2 = fe->fi_time_last_mod;\n        filenum = fiu+1;\n\n        /*  The space character at the end of line is silly,\n            but lets leave it there for the moment to avoid\n            changing output.  */\n        if (line_context->lc_file_entry_count > 9) {\n            dwarfstring_append_printf_u(&m3,\n                \"  file[%2u] \",fiu);\n        } else {\n            dwarfstring_append_printf_u(&m3,\n                \"  file[%u]  \", fiu);\n        }\n        /*  DWARF5 can have a null fi_file_name\n            if  the format code in the\n            line table header is unknown, such\n            as in a corrupt object file. */\n        dwarfstring_append_printf_s(&m3,\n            \"%-20s \",\n            fe->fi_file_name?\n            (char *) fe->fi_file_name:\n            \"<no file name>\");\n        dwarfstring_append_printf_u(&m3,\n            \"(file-number: %u)\\n\",\n            filenum);\n        _dwarf_printf(dbg,dwarfstring_string(&m3));\n        dwarfstring_reset(&m3);\n        if (fe->fi_dir_index_present) {\n            Dwarf_Unsigned di = 0;\n            di = fe->fi_dir_index;\n            dwarfstring_append_printf_i(&m3,\n                \"    dir index %d\\n\", di);\n        }\n        if (fe->fi_time_last_mod_present) {\n            time_t tt = (time_t) tlm2;\n\n            /* ctime supplies newline */\n            dwarfstring_append_printf_u(&m3,\n                \"    last time 0x%x \",tlm2);\n            dwarfstring_append(&m3,(char *)ctime(&tt));\n        }\n        if (fe->fi_file_length_present) {\n            Dwarf_Unsigned fl = 0;\n\n            fl = fe->fi_file_length;\n            dwarfstring_append_printf_i(&m3,\n                \"    file length %ld \",fl);\n            dwarfstring_append_printf_u(&m3,\n                \"0x%lx\\n\",fl);\n        }\n        if (fe->fi_md5_present) {\n            char *c = (char *)&fe->fi_md5_value;\n            char *end = c+sizeof(fe->fi_md5_value);\n            dwarfstring_append(&m3, \"    file md5 value 0x\");\n            while(c < end) {\n                dwarfstring_append_printf_u(&m3,\n                    \"%02x\",0xff&*c);\n                ++c;\n            }\n            dwarfstring_append(&m3,\"\\n\");\n        }\n        if (dwarfstring_strlen(&m3)) {\n            _dwarf_printf(dbg,dwarfstring_string(&m3));\n            dwarfstring_reset(&m3);\n        }\n    }\n    dwarfstring_destructor(&m3);\n}\n\nstatic void\nprint_file_entry_details(Dwarf_Debug dbg,\n    unsigned int line_version,\n    Dwarf_Line_Context line_context)\n{\n    dwarfstring m5;\n\n    dwarfstring_constructor_static(&m5,locallinebuf,\n        sizeof(locallinebuf));\n    if (line_version == DW_LINE_VERSION5) {\n        unsigned i = 0;\n        unsigned dfcount = line_context->lc_file_name_format_count;\n\n        dwarfstring_append_printf_u(&m5,\n            \"  file entry format count      %u\\n\",dfcount);\n        for ( ; i < dfcount;++i) {\n            struct Dwarf_Unsigned_Pair_s *valpair = 0;\n            const char *tname = 0;\n            const char *fname = 0;\n            int res;\n\n            valpair = line_context->lc_file_format_values +i;\n            dwarfstring_append_printf_u(&m5,\n                \"  format [%2u] \",i);\n            res = dwarf_get_LNCT_name(valpair->up_first,&tname);\n            if ( res != DW_DLV_OK) {\n                tname = \"<unknown type>\";\n            }\n            dwarfstring_append_printf_u(&m5,\n                \" type 0x%\" DW_PR_XZEROS DW_PR_DUx,\n                valpair->up_first);\n            dwarfstring_append_printf_s(&m5,\n                \" %-20s\\n\",(char *)tname);\n            res = dwarf_get_FORM_name(valpair->up_second,&fname);\n            if ( res != DW_DLV_OK) {\n                fname = \"<unknown form>\";\n            }\n            dwarfstring_append_printf_u(&m5,\n                \"               code 0x%\"\n                DW_PR_XZEROS DW_PR_DUx,\n                valpair->up_second);\n            dwarfstring_append_printf_s(&m5, \" %-20s\\n\",\n                (char *)fname);\n            _dwarf_printf(dbg,dwarfstring_string(&m5));\n            dwarfstring_reset(&m5);\n        }\n        dwarfstring_destructor(&m5);\n        print_just_file_entry_details(dbg,line_context);\n    } else {\n        print_just_file_entry_details(dbg,line_context);\n        dwarfstring_destructor(&m5);\n    }\n\n}\n\nstatic void\nprint_experimental_subprograms_list(Dwarf_Debug dbg,\n    Dwarf_Line_Context line_context)\n{\n    /*  Print the subprograms list. */\n    Dwarf_Unsigned count = line_context->lc_subprogs_count;\n    Dwarf_Unsigned exu = 0;\n    Dwarf_Subprog_Entry sub = line_context->lc_subprogs;\n    dwarfstring m6;\n\n    dwarfstring_constructor_static(&m6,locallinebuf,\n        sizeof(locallinebuf));\n    dwarfstring_append_printf_u(&m6,\n        \"  subprograms count %\" DW_PR_DUu \"\\n\",count);\n    if (count > 0) {\n        dwarfstring_append(&m6,\"    indx  file   line   name\\n\");\n    }\n    _dwarf_printf(dbg,dwarfstring_string(&m6));\n    dwarfstring_reset(&m6);\n    for (exu = 0 ; exu < count ; exu++,sub++) {\n        dwarfstring_append_printf_u(&m6,\n            \"    [%2\" DW_PR_DUu,exu+1);\n        dwarfstring_append_printf_u(&m6,\n            \"] %4\" DW_PR_DUu,sub->ds_decl_file);\n        dwarfstring_append_printf_u(&m6,\n            \"    %4\" DW_PR_DUu ,sub->ds_decl_line);\n        dwarfstring_append_printf_s(&m6,\n            \" %s\\n\",(char *)sub->ds_subprog_name);\n        _dwarf_printf(dbg,dwarfstring_string(&m6));\n        dwarfstring_reset(&m6);\n    }\n    dwarfstring_destructor(&m6);\n}\n\nstatic void\ndo_line_print_now(Dwarf_Debug dbg,int line_version,\n    Dwarf_Small * comp_dir,\n    Dwarf_Line_Context line_context) ;\nstatic void print_experimental_counts(Dwarf_Debug dbg,\n    int line_version,\n    Dwarf_Line_Context line_context);\n\nstatic int print_actuals_and_locals(Dwarf_Debug dbg,\n    Dwarf_Line_Context line_context,\n    Dwarf_Unsigned bogus_bytes_count,\n    Dwarf_Small *bogus_bytes_ptr,\n    Dwarf_Small *orig_line_ptr,\n    Dwarf_Small *line_ptr,\n    Dwarf_Small *section_start,\n    Dwarf_Small *line_ptr_actuals,\n    Dwarf_Small *line_ptr_end,\n    Dwarf_Half   address_size,\n    int *        err_count_out,\n    Dwarf_Error *err);\n\n/*  return DW_DLV_OK if ok. else DW_DLV_NO_ENTRY or DW_DLV_ERROR\n    If err_count_out is non-NULL, this is a special 'check'\n    call.  */\nstatic int\n_dwarf_internal_printlines(Dwarf_Die die,\n    int * err_count_out,\n    int only_line_header,\n    Dwarf_Error * error)\n{\n    /*  This pointer is used to scan the portion of the .debug_line\n        section for the current cu. */\n    Dwarf_Small *line_ptr = 0;\n    Dwarf_Small *orig_line_ptr = 0;\n\n    /*  Pointer to a DW_AT_stmt_list attribute in case\n        it exists in the die. */\n    Dwarf_Attribute stmt_list_attr = 0;\n\n    /*  Pointer to DW_AT_comp_dir attribute in die. */\n    Dwarf_Attribute comp_dir_attr = 0;\n\n    /*  Pointer to name of compilation directory. */\n    Dwarf_Small *comp_dir = NULL;\n\n    /*  Offset into .debug_line specified by a DW_AT_stmt_list\n        attribute. */\n    Dwarf_Unsigned line_offset = 0;\n\n    /*  These variables are used to decode leb128 numbers. Leb128_num\n        holds the decoded number, and leb128_length is its length in\n        bytes. */\n    Dwarf_Half attrform = 0;\n\n    /*  In case there are wierd bytes 'after' the line table\n        prologue this lets us print something. This is a gcc\n        compiler bug and we expect the bytes count to be 12.  */\n    Dwarf_Small* bogus_bytes_ptr = 0;\n    Dwarf_Unsigned bogus_bytes_count = 0;\n    Dwarf_Half address_size = 0;\n    Dwarf_Unsigned fission_offset = 0;\n    unsigned line_version = 0;\n\n\n    /* The Dwarf_Debug this die belongs to. */\n    Dwarf_Debug dbg = 0;\n    Dwarf_CU_Context cu_context = 0;\n    Dwarf_Line_Context line_context = 0;\n    int resattr = DW_DLV_ERROR;\n    int lres =    DW_DLV_ERROR;\n    int res  =    DW_DLV_ERROR;\n    Dwarf_Small *line_ptr_actuals  = 0;\n    Dwarf_Small *line_ptr_end = 0;\n    Dwarf_Small *section_start = 0;\n\n    /* ***** BEGIN CODE ***** */\n\n    if (error != NULL) {\n        *error = NULL;\n    }\n\n    CHECK_DIE(die, DW_DLV_ERROR);\n    cu_context = die->di_cu_context;\n    dbg = cu_context->cc_dbg;\n\n    res = _dwarf_load_section(dbg, &dbg->de_debug_line,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    if (!dbg->de_debug_line.dss_size) {\n        return (DW_DLV_NO_ENTRY);\n    }\n\n    address_size = _dwarf_get_address_size(dbg, die);\n    resattr = dwarf_attr(die, DW_AT_stmt_list, &stmt_list_attr,\n        error);\n    if (resattr != DW_DLV_OK) {\n        return resattr;\n    }\n    /*  The list of relevant FORMs is small.\n        DW_FORM_data4, DW_FORM_data8, DW_FORM_sec_offset\n    */\n    lres = dwarf_whatform(stmt_list_attr,&attrform,error);\n    if (lres != DW_DLV_OK) {\n        dwarf_dealloc(dbg,stmt_list_attr, DW_DLA_ATTR);\n        return lres;\n    }\n    if (attrform != DW_FORM_data4 && attrform != DW_FORM_data8 &&\n        attrform != DW_FORM_sec_offset ) {\n        dwarf_dealloc(dbg,stmt_list_attr, DW_DLA_ATTR);\n        _dwarf_error(dbg, error, DW_DLE_LINE_OFFSET_BAD);\n        return (DW_DLV_ERROR);\n    }\n    lres = dwarf_global_formref(stmt_list_attr, &line_offset, error);\n    if (lres != DW_DLV_OK) {\n        dwarf_dealloc(dbg,stmt_list_attr, DW_DLA_ATTR);\n        return lres;\n    }\n\n    if (line_offset >= dbg->de_debug_line.dss_size) {\n        dwarf_dealloc(dbg,stmt_list_attr, DW_DLA_ATTR);\n        _dwarf_error(dbg, error, DW_DLE_LINE_OFFSET_BAD);\n        return (DW_DLV_ERROR);\n    }\n    section_start =  dbg->de_debug_line.dss_data;\n    {\n        Dwarf_Unsigned fission_size = 0;\n        int resfis = _dwarf_get_fission_addition_die(die,\n            DW_SECT_LINE,\n            &fission_offset,&fission_size,error);\n        if(resfis != DW_DLV_OK) {\n            dwarf_dealloc(dbg,stmt_list_attr, DW_DLA_ATTR);\n            return resfis;\n        }\n    }\n\n    orig_line_ptr = section_start + line_offset + fission_offset;\n    line_ptr = orig_line_ptr;\n    dwarf_dealloc(dbg, stmt_list_attr, DW_DLA_ATTR);\n\n    /*  If die has DW_AT_comp_dir attribute, get the string\n        that names the compilation directory. */\n    resattr = dwarf_attr(die, DW_AT_comp_dir, &comp_dir_attr, error);\n    if (resattr == DW_DLV_ERROR) {\n        return resattr;\n    }\n    if (resattr == DW_DLV_OK) {\n        int cres = DW_DLV_ERROR;\n        char *cdir = 0;\n\n        cres = dwarf_formstring(comp_dir_attr, &cdir, error);\n        if (cres == DW_DLV_ERROR) {\n            return cres;\n        } else if (cres == DW_DLV_OK) {\n            comp_dir = (Dwarf_Small *) cdir;\n        }\n    }\n    if (resattr == DW_DLV_OK) {\n        dwarf_dealloc(dbg, comp_dir_attr, DW_DLA_ATTR);\n    }\n    line_context = (Dwarf_Line_Context)\n        _dwarf_get_alloc(dbg, DW_DLA_LINE_CONTEXT, 1);\n    if (line_context == NULL) {\n        _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);\n        return (DW_DLV_ERROR);\n    }\n    {\n        Dwarf_Small *newlinep = 0;\n        int dres = _dwarf_read_line_table_header(dbg,\n            cu_context,\n            section_start,\n            line_ptr,\n            dbg->de_debug_line.dss_size,\n            &newlinep,\n            line_context,\n            &bogus_bytes_ptr,\n            &bogus_bytes_count,\n            error,\n            err_count_out);\n        if (dres == DW_DLV_ERROR) {\n            dwarf_srclines_dealloc_b(line_context);\n            return dres;\n        }\n        if (dres == DW_DLV_NO_ENTRY) {\n            dwarf_srclines_dealloc_b(line_context);\n            return dres;\n        }\n        line_ptr_end = line_context->lc_line_ptr_end;\n        line_ptr = newlinep;\n        if (line_context->lc_actuals_table_offset > 0) {\n            line_ptr_actuals = line_context->lc_line_prologue_start +\n                line_context->lc_actuals_table_offset;\n        }\n    }\n    line_version = line_context->lc_version_number;\n    line_context->lc_compilation_directory = comp_dir;\n    if (only_line_header) {\n        /* Just checking for header errors, nothing more here.*/\n        dwarf_srclines_dealloc_b(line_context);\n        return DW_DLV_OK;\n    }\n    do_line_print_now(dbg,line_version,comp_dir,line_context);\n    print_include_directory_details(dbg,line_version,line_context);\n    print_file_entry_details(dbg,line_version,line_context);\n    print_experimental_counts(dbg, line_version,line_context);\n    res = print_actuals_and_locals(dbg, line_context,\n        bogus_bytes_count,bogus_bytes_ptr,\n        orig_line_ptr,\n        line_ptr,\n        section_start,\n        line_ptr_actuals,\n        line_ptr_end,\n        address_size,\n        err_count_out,\n        error);\n    if (res  !=  DW_DLV_OK) {\n        return res;\n    }\n    return DW_DLV_OK;\n}\n\nstatic void\ndo_line_print_now(Dwarf_Debug dbg,\n    int line_version,\n    Dwarf_Small *comp_dir,\n    Dwarf_Line_Context line_context)\n{\n    dwarfstring m7;\n    Dwarf_Unsigned i = 0;\n\n    dwarfstring_constructor(&m7);\n    dwarfstring_append_printf_i(&m7,\n        \"total line info length %ld bytes,\",\n        line_context->lc_total_length);\n\n    dwarfstring_append_printf_u(&m7,\n        \" line offset 0x%\" DW_PR_XZEROS DW_PR_DUx,\n        line_context->lc_section_offset);\n\n    dwarfstring_append_printf_u(&m7,\n        \" %\" DW_PR_DUu \"\\n\",\n        line_context->lc_section_offset);\n\n    if (line_version <= DW_LINE_VERSION5) {\n        dwarfstring_append_printf_i(&m7,\n            \"  line table version     %d\\n\",\n        (int) line_context->lc_version_number);\n    } else {\n        dwarfstring_append_printf_u(&m7,\n            \"  line table version 0x%x\\n\",\n            (int) line_context->lc_version_number);\n    }\n    if (line_version == DW_LINE_VERSION5) {\n        dwarfstring_append_printf_i(&m7,\n            \"  address size          %d\\n\",\n            line_context->lc_address_size);\n        dwarfstring_append_printf_i(&m7,\n            \"  segment selector size %d\\n\",\n            line_context->lc_segment_selector_size);\n    }\n    _dwarf_printf(dbg,dwarfstring_string(&m7));\n    dwarfstring_reset(&m7);\n    dwarfstring_append_printf_i(&m7,\n        \"  line table length field length %d\\n\",\n        line_context->lc_length_field_length);\n    dwarfstring_append_printf_i(&m7,\n        \"  prologue length       %d\\n\",\n        line_context->lc_prologue_length);\n    dwarfstring_append_printf_s(&m7,\n        \"  compilation_directory %s\\n\",\n        comp_dir ? ((char *) comp_dir) : \"\");\n\n    dwarfstring_append_printf_i(&m7,\n        \"  min instruction length %d\\n\",\n        line_context->lc_minimum_instruction_length);\n    _dwarf_printf(dbg,dwarfstring_string(&m7));\n    dwarfstring_reset(&m7);\n    if (line_version == DW_LINE_VERSION5 ||\n        line_version == DW_LINE_VERSION4 ||\n        line_version == EXPERIMENTAL_LINE_TABLES_VERSION) {\n        dwarfstring_append_printf_u(&m7,\n            \"  maximum ops per instruction %u\\n\",\n            line_context->lc_maximum_ops_per_instruction);\n        _dwarf_printf(dbg,dwarfstring_string(&m7));\n        dwarfstring_reset(&m7);\n    }\n    if (line_version == EXPERIMENTAL_LINE_TABLES_VERSION) {\n        dwarfstring_append_printf_u(&m7, \"  actuals table offset \"\n            \"0x%\" DW_PR_XZEROS DW_PR_DUx \"\\n\",\n            line_context->lc_actuals_table_offset);\n        dwarfstring_append_printf_u(&m7,\"  logicals table offset \"\n            \"0x%\" DW_PR_XZEROS DW_PR_DUx \"\\n\",\n            line_context->lc_logicals_table_offset);\n        _dwarf_printf(dbg,dwarfstring_string(&m7));\n        dwarfstring_reset(&m7);\n    }\n    dwarfstring_append_printf_i(&m7,\n        \"  default is stmt        %d\\n\",\n        (int)line_context->lc_default_is_stmt);\n    dwarfstring_append_printf_i(&m7,\n        \"  line base              %d\\n\",\n        (int)line_context->lc_line_base);\n    dwarfstring_append_printf_i(&m7,\n        \"  line_range             %d\\n\",\n        (int)line_context->lc_line_range);\n    dwarfstring_append_printf_i(&m7,\n        \"  opcode base            %d\\n\",\n        (int)line_context->lc_opcode_base);\n    dwarfstring_append_printf_i(&m7,\n        \"  standard opcode count  %d\\n\",\n        (int)line_context->lc_std_op_count);\n    _dwarf_printf(dbg,dwarfstring_string(&m7));\n    dwarfstring_reset(&m7);\n\n    for (i = 1; i < line_context->lc_opcode_base; i++) {\n        dwarfstring_append_printf_i(&m7,\n            \"  opcode[%2d] length\", (int) i);\n        dwarfstring_append_printf_i(&m7,\n            \"  %d\\n\",\n            (int) line_context->lc_opcode_length_table[i - 1]);\n        _dwarf_printf(dbg,dwarfstring_string(&m7));\n        dwarfstring_reset(&m7);\n    }\n    dwarfstring_destructor(&m7);\n}\n\nstatic void\nprint_experimental_counts(Dwarf_Debug dbg, int line_version,\n    Dwarf_Line_Context line_context)\n{\n    if (line_version == EXPERIMENTAL_LINE_TABLES_VERSION) {\n        print_experimental_subprograms_list(dbg,line_context);\n    }\n}\n\nstatic int\nprint_actuals_and_locals(Dwarf_Debug dbg,\n    Dwarf_Line_Context line_context,\n    Dwarf_Unsigned bogus_bytes_count,\n    Dwarf_Small *bogus_bytes_ptr,\n    Dwarf_Small *orig_line_ptr,\n    Dwarf_Small *line_ptr,\n    Dwarf_Small *section_start,\n    Dwarf_Small *line_ptr_actuals,\n    Dwarf_Small *line_ptr_end,\n    Dwarf_Half   address_size,\n    int *        err_count_out,\n    Dwarf_Error *error)\n{\n    int res = 0;\n    dwarfstring m8;\n    Dwarf_Unsigned offset = 0;\n\n    dwarfstring_constructor(&m8);\n    if (bogus_bytes_count > 0) {\n        Dwarf_Unsigned wcount = bogus_bytes_count;\n        Dwarf_Unsigned boffset = bogus_bytes_ptr - section_start;\n\n        dwarfstring_append_printf_u(&m8,\n            \"*** DWARF CHECK: the line table prologue  header_length \"\n            \" is %\" DW_PR_DUu \" too high, we pretend it is smaller.\",\n            wcount);\n        dwarfstring_append_printf_u(&m8,\n            \"Section offset: 0x%\"\n            DW_PR_XZEROS DW_PR_DUx,\n            boffset);\n        dwarfstring_append_printf_u(&m8,\n            \" (%\" DW_PR_DUu \") ***\\n\",\n            boffset);\n        *err_count_out += 1;\n    }\n    offset = line_ptr - section_start;\n    dwarfstring_append_printf_u(&m8,\n        \"  statement prog offset in section: 0x%\"\n        DW_PR_XZEROS DW_PR_DUx,\n        offset);\n    dwarfstring_append_printf_u(&m8,\n        \" (%\" DW_PR_DUu \")\\n\",\n        offset);\n    _dwarf_printf(dbg,dwarfstring_string(&m8));\n    dwarfstring_reset(&m8);\n\n    {\n        Dwarf_Bool doaddrs = false;\n        Dwarf_Bool dolines = true;\n\n        if (!line_ptr_actuals) {\n            /* Normal single level line table. */\n\n            Dwarf_Bool is_single_table = true;\n            Dwarf_Bool is_actuals_table = false;\n            print_line_header(dbg, is_single_table, is_actuals_table);\n            res = read_line_table_program(dbg,\n                line_ptr, line_ptr_end, orig_line_ptr,\n                section_start,\n                line_context,\n                address_size, doaddrs, dolines,\n                is_single_table,\n                is_actuals_table,\n                error,\n                err_count_out);\n            if (res != DW_DLV_OK) {\n                dwarfstring_destructor(&m8);\n                dwarf_srclines_dealloc_b(line_context);\n                return res;\n            }\n        } else {\n            Dwarf_Bool is_single_table = false;\n            Dwarf_Bool is_actuals_table = false;\n            if (line_context->lc_version_number !=\n                EXPERIMENTAL_LINE_TABLES_VERSION) {\n                dwarf_srclines_dealloc_b(line_context);\n                dwarfstring_destructor(&m8);\n                _dwarf_error(dbg, error, DW_DLE_VERSION_STAMP_ERROR);\n                return (DW_DLV_ERROR);\n            }\n            /* Read Logicals */\n            print_line_header(dbg, is_single_table, is_actuals_table);\n            res = read_line_table_program(dbg,\n                line_ptr, line_ptr_actuals, orig_line_ptr,\n                section_start,\n                line_context,\n                address_size, doaddrs, dolines,\n                is_single_table,\n                is_actuals_table,\n                error,err_count_out);\n            if (res != DW_DLV_OK) {\n                dwarfstring_destructor(&m8);\n                dwarf_srclines_dealloc_b(line_context);\n                return res;\n            }\n            if (line_context->lc_actuals_table_offset > 0) {\n                is_actuals_table = true;\n                /* Read Actuals */\n\n                print_line_header(dbg, is_single_table,\n                    is_actuals_table);\n                res = read_line_table_program(dbg,\n                    line_ptr_actuals, line_ptr_end, orig_line_ptr,\n                    section_start,\n                    line_context,\n                    address_size, doaddrs, dolines,\n                    is_single_table,\n                    is_actuals_table,\n                    error,\n                    err_count_out);\n                if (res != DW_DLV_OK) {\n                    dwarfstring_destructor(&m8);\n                    dwarf_srclines_dealloc_b(line_context);\n                    return res;\n                }\n            }\n        }\n    }\n    dwarfstring_destructor(&m8);\n    dwarf_srclines_dealloc_b(line_context);\n    return DW_DLV_OK;\n}\n\n\n\n/*  This is support for dwarfdump: making it possible\n    for clients wanting line detail info on stdout\n    to get that detail without including internal libdwarf\n    header information.\n    Caller passes in compilation unit DIE.\n    The _dwarf_ version is obsolete (though supported for\n    compatibility).\n    The dwarf_ version is preferred.\n    The functions are intentionally identical: having\n    _dwarf_print_lines call dwarf_print_lines might\n    better emphasize they are intentionally identical, but\n    that seemed slightly silly given how short the functions are.\n    Interface adds error_count (output value) February 2009.\n\n    These *print_lines() functions print two-level tables in full\n    even when the user is not asking for both (ie, when\n    the caller asked for dwarf_srclines().\n    It was an accident, but after a short reflection\n    this seems like a good idea for -vvv. */\nint\ndwarf_print_lines(Dwarf_Die die,\n    Dwarf_Error * error,\n    int *error_count)\n{\n    int only_line_header = 0;\n    int res = _dwarf_internal_printlines(die,\n        error_count,\n        only_line_header,error);\n    return res;\n}\nint\n_dwarf_print_lines(Dwarf_Die die, Dwarf_Error * error)\n{\n    int only_line_header = 0;\n    int err_count = 0;\n    int res = _dwarf_internal_printlines(die,\n        &err_count,\n        only_line_header,error);\n    /* No way to get error count back in this interface */\n    return res;\n}\n\n/* The check is in case we are not printing full line data,\n   this gets some of the issues noted with .debug_line,\n   but not all. Call dwarf_print_lines() to get all issues.\n   Intended for apps like dwarfdump.\n   dwarf_check_lineheader_b() new 14 April 2020.\n*/\nint\ndwarf_check_lineheader_b(Dwarf_Die die, int *err_count_out,\n    Dwarf_Error *err)\n{\n    int res = 0;\n\n    int only_line_header = 1;\n    res = _dwarf_internal_printlines(die,err_count_out,\n        only_line_header,err);\n    return res;\n}\n\n/*  This is ugly, no way to detect errors. They get ignored.\n    see dwarf_check_lineheader_b() above. */\nvoid\ndwarf_check_lineheader(Dwarf_Die die, int *err_count_out)\n{\n    int res = 0;\n    Dwarf_Error err = 0;\n\n    int only_line_header = 1;\n    res = _dwarf_internal_printlines(die,err_count_out,\n        only_line_header,&err);\n    if (res == DW_DLV_ERROR) {\n        Dwarf_CU_Context c = 0;\n        Dwarf_Debug dbg = 0;\n\n        c = die->di_cu_context;\n        if (!c) {\n            return;\n        }\n        dbg = c->cc_dbg;\n        dwarf_dealloc(dbg,err,DW_DLA_ERROR);\n        err = 0;\n    }\n}\n"], "filenames": ["libdwarf/ChangeLog", "libdwarf/dwarf_print_lines.c"], "buggy_code_start_loc": [0, 57], "buggy_code_end_loc": [0, 911], "fixing_code_start_loc": [1, 57], "fixing_code_end_loc": [11, 923], "type": "CWE-476", "message": "libdwarf before 20201201 allows a dwarf_print_lines.c NULL pointer dereference and application crash via a DWARF5 line-table header that has an invalid FORM for a pathname.", "other": {"cve": {"id": "CVE-2020-28163", "sourceIdentifier": "cve@mitre.org", "published": "2023-04-16T00:15:07.313", "lastModified": "2023-04-26T15:42:38.570", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "libdwarf before 20201201 allows a dwarf_print_lines.c NULL pointer dereference and application crash via a DWARF5 line-table header that has an invalid FORM for a pathname."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libdwarf_project:libdwarf:*:*:*:*:*:*:*:*", "versionEndExcluding": "2020-12-01", "matchCriteriaId": "943A7698-9618-4025-80CB-D1D2C70345BA"}]}]}], "references": [{"url": "http://web.archive.org/web/20190601140703/https://sourceforge.net/projects/libdwarf/", "source": "cve@mitre.org", "tags": ["Product"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2026000", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Permissions Required", "Third Party Advisory"]}, {"url": "https://github.com/davea42/libdwarf-code/commit/faf99408e3f9f706fc3809dd400e831f989778d3", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://www.prevanders.net/dwarfbug.html#DW202010-003", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/davea42/libdwarf-code/commit/faf99408e3f9f706fc3809dd400e831f989778d3"}}