{"buggy_code": ["/* Copyright libuv contributors. All rights reserved.\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n/* Derived from https://github.com/bnoordhuis/punycode\n * but updated to support IDNA 2008.\n */\n\n#include \"uv.h\"\n#include \"uv-common.h\"\n#include \"idna.h\"\n#include <assert.h>\n#include <string.h>\n#include <limits.h> /* UINT_MAX */\n\n\nstatic int32_t uv__wtf8_decode1(const char** input) {\n  uint32_t code_point;\n  uint8_t b1;\n  uint8_t b2;\n  uint8_t b3;\n  uint8_t b4;\n\n  b1 = **input;\n  if (b1 <= 0x7F)\n    return b1; /* ASCII code point */\n  if (b1 < 0xC2)\n    return -1; /* invalid: continuation byte */\n  code_point = b1;\n\n  b2 = *++*input;\n  if ((b2 & 0xC0) != 0x80)\n    return -1; /* invalid: not a continuation byte */\n  code_point = (code_point << 6) | (b2 & 0x3F);\n  if (b1 <= 0xDF)\n    return 0x7FF & code_point; /* two-byte character */\n\n  b3 = *++*input;\n  if ((b3 & 0xC0) != 0x80)\n    return -1; /* invalid: not a continuation byte */\n  code_point = (code_point << 6) | (b3 & 0x3F);\n  if (b1 <= 0xEF)\n    return 0xFFFF & code_point; /* three-byte character */\n\n  b4 = *++*input;\n  if ((b4 & 0xC0) != 0x80)\n    return -1; /* invalid: not a continuation byte */\n  code_point = (code_point << 6) | (b4 & 0x3F);\n  if (b1 <= 0xF4) {\n    code_point &= 0x1FFFFF;\n    if (code_point <= 0x10FFFF)\n      return code_point; /* four-byte character */\n  }\n\n  /* code point too large */\n  return -1;\n}\n\n\nstatic unsigned uv__utf8_decode1_slow(const char** p,\n                                      const char* pe,\n                                      unsigned a) {\n  unsigned b;\n  unsigned c;\n  unsigned d;\n  unsigned min;\n\n  if (a > 0xF7)\n    return -1;\n\n  switch (pe - *p) {\n  default:\n    if (a > 0xEF) {\n      min = 0x10000;\n      a = a & 7;\n      b = (unsigned char) *(*p)++;\n      c = (unsigned char) *(*p)++;\n      d = (unsigned char) *(*p)++;\n      break;\n    }\n    /* Fall through. */\n  case 2:\n    if (a > 0xDF) {\n      min = 0x800;\n      b = 0x80 | (a & 15);\n      c = (unsigned char) *(*p)++;\n      d = (unsigned char) *(*p)++;\n      a = 0;\n      break;\n    }\n    /* Fall through. */\n  case 1:\n    if (a > 0xBF) {\n      min = 0x80;\n      b = 0x80;\n      c = 0x80 | (a & 31);\n      d = (unsigned char) *(*p)++;\n      a = 0;\n      break;\n    }\n    /* Fall through. */\n  case 0:\n    return -1;  /* Invalid continuation byte. */\n  }\n\n  if (0x80 != (0xC0 & (b ^ c ^ d)))\n    return -1;  /* Invalid sequence. */\n\n  b &= 63;\n  c &= 63;\n  d &= 63;\n  a = (a << 18) | (b << 12) | (c << 6) | d;\n\n  if (a < min)\n    return -1;  /* Overlong sequence. */\n\n  if (a > 0x10FFFF)\n    return -1;  /* Four-byte sequence > U+10FFFF. */\n\n  if (a >= 0xD800 && a <= 0xDFFF)\n    return -1;  /* Surrogate pair. */\n\n  return a;\n}\n\n\nunsigned uv__utf8_decode1(const char** p, const char* pe) {\n  unsigned a;\n\n  assert(*p < pe);\n\n  a = (unsigned char) *(*p)++;\n\n  if (a < 128)\n    return a;  /* ASCII, common case. */\n\n  return uv__utf8_decode1_slow(p, pe, a);\n}\n\n\nstatic int uv__idna_toascii_label(const char* s, const char* se,\n                                  char** d, char* de) {\n  static const char alphabet[] = \"abcdefghijklmnopqrstuvwxyz0123456789\";\n  const char* ss;\n  unsigned c;\n  unsigned h;\n  unsigned k;\n  unsigned n;\n  unsigned m;\n  unsigned q;\n  unsigned t;\n  unsigned x;\n  unsigned y;\n  unsigned bias;\n  unsigned delta;\n  unsigned todo;\n  int first;\n\n  h = 0;\n  ss = s;\n  todo = 0;\n\n  /* Note: after this loop we've visited all UTF-8 characters and know\n   * they're legal so we no longer need to check for decode errors.\n   */\n  while (s < se) {\n    c = uv__utf8_decode1(&s, se);\n\n    if (c == UINT_MAX)\n      return UV_EINVAL;\n\n    if (c < 128)\n      h++;\n    else\n      todo++;\n  }\n\n  /* Only write \"xn--\" when there are non-ASCII characters. */\n  if (todo > 0) {\n    if (*d < de) *(*d)++ = 'x';\n    if (*d < de) *(*d)++ = 'n';\n    if (*d < de) *(*d)++ = '-';\n    if (*d < de) *(*d)++ = '-';\n  }\n\n  /* Write ASCII characters. */\n  x = 0;\n  s = ss;\n  while (s < se) {\n    c = uv__utf8_decode1(&s, se);\n    assert(c != UINT_MAX);\n\n    if (c > 127)\n      continue;\n\n    if (*d < de)\n      *(*d)++ = c;\n\n    if (++x == h)\n      break;  /* Visited all ASCII characters. */\n  }\n\n  if (todo == 0)\n    return h;\n\n  /* Only write separator when we've written ASCII characters first. */\n  if (h > 0)\n    if (*d < de)\n      *(*d)++ = '-';\n\n  n = 128;\n  bias = 72;\n  delta = 0;\n  first = 1;\n\n  while (todo > 0) {\n    m = -1;\n    s = ss;\n\n    while (s < se) {\n      c = uv__utf8_decode1(&s, se);\n      assert(c != UINT_MAX);\n\n      if (c >= n)\n        if (c < m)\n          m = c;\n    }\n\n    x = m - n;\n    y = h + 1;\n\n    if (x > ~delta / y)\n      return UV_E2BIG;  /* Overflow. */\n\n    delta += x * y;\n    n = m;\n\n    s = ss;\n    while (s < se) {\n      c = uv__utf8_decode1(&s, se);\n      assert(c != UINT_MAX);\n\n      if (c < n)\n        if (++delta == 0)\n          return UV_E2BIG;  /* Overflow. */\n\n      if (c != n)\n        continue;\n\n      for (k = 36, q = delta; /* empty */; k += 36) {\n        t = 1;\n\n        if (k > bias)\n          t = k - bias;\n\n        if (t > 26)\n          t = 26;\n\n        if (q < t)\n          break;\n\n        /* TODO(bnoordhuis) Since 1 <= t <= 26 and therefore\n         * 10 <= y <= 35, we can optimize the long division\n         * into a table-based reciprocal multiplication.\n         */\n        x = q - t;\n        y = 36 - t;  /* 10 <= y <= 35 since 1 <= t <= 26. */\n        q = x / y;\n        t = t + x % y;  /* 1 <= t <= 35 because of y. */\n\n        if (*d < de)\n          *(*d)++ = alphabet[t];\n      }\n\n      if (*d < de)\n        *(*d)++ = alphabet[q];\n\n      delta /= 2;\n\n      if (first) {\n        delta /= 350;\n        first = 0;\n      }\n\n      /* No overflow check is needed because |delta| was just\n       * divided by 2 and |delta+delta >= delta + delta/h|.\n       */\n      h++;\n      delta += delta / h;\n\n      for (bias = 0; delta > 35 * 26 / 2; bias += 36)\n        delta /= 35;\n\n      bias += 36 * delta / (delta + 38);\n      delta = 0;\n      todo--;\n    }\n\n    delta++;\n    n++;\n  }\n\n  return 0;\n}\n\n\nssize_t uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n\n  ds = d;\n\n  si = s;\n  while (si < se) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n\n    if (c == UINT_MAX)\n      return UV_EINVAL;\n\n    if (c != '.')\n      if (c != 0x3002)  /* \u3002 */\n        if (c != 0xFF0E)  /* \uff0e */\n          if (c != 0xFF61)  /* \uff61 */\n            continue;\n\n    rc = uv__idna_toascii_label(s, st, &d, de);\n\n    if (rc < 0)\n      return rc;\n\n    if (d < de)\n      *d++ = '.';\n\n    s = si;\n  }\n\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n\n    if (rc < 0)\n      return rc;\n  }\n\n  if (d < de)\n    *d++ = '\\0';\n\n  return d - ds;  /* Number of bytes written. */\n}\n\n\nssize_t uv_wtf8_length_as_utf16(const char* source_ptr) {\n  size_t w_target_len = 0;\n  int32_t code_point;\n\n  do {\n    code_point = uv__wtf8_decode1(&source_ptr);\n    if (code_point < 0)\n      return -1;\n    if (code_point > 0xFFFF)\n      w_target_len++;\n    w_target_len++;\n  } while (*source_ptr++);\n\n  return w_target_len;\n}\n\n\nvoid uv_wtf8_to_utf16(const char* source_ptr,\n                      uint16_t* w_target,\n                      size_t w_target_len) {\n  int32_t code_point;\n\n  do {\n    code_point = uv__wtf8_decode1(&source_ptr);\n    /* uv_wtf8_length_as_utf16 should have been called and checked first. */\n    assert(code_point >= 0);\n    if (code_point > 0x10000) {\n      assert(code_point < 0x10FFFF);\n      *w_target++ = (((code_point - 0x10000) >> 10) + 0xD800);\n      *w_target++ = ((code_point - 0x10000) & 0x3FF) + 0xDC00;\n      w_target_len -= 2;\n    } else {\n      *w_target++ = code_point;\n      w_target_len -= 1;\n    }\n  } while (*source_ptr++);\n\n  (void)w_target_len;\n  assert(w_target_len == 0);\n}\n\n\nstatic int32_t uv__get_surrogate_value(const uint16_t* w_source_ptr,\n                                       ssize_t w_source_len) {\n  uint16_t u;\n  uint16_t next;\n\n  u = w_source_ptr[0];\n  if (u >= 0xD800 && u <= 0xDBFF && w_source_len != 1) {\n    next = w_source_ptr[1];\n    if (next >= 0xDC00 && next <= 0xDFFF)\n      return 0x10000 + ((u - 0xD800) << 10) + (next - 0xDC00);\n  }\n  return u;\n}\n\n\nsize_t uv_utf16_length_as_wtf8(const uint16_t* w_source_ptr,\n                               ssize_t w_source_len) {\n  size_t target_len;\n  int32_t code_point;\n\n  target_len = 0;\n  while (w_source_len) {\n    code_point = uv__get_surrogate_value(w_source_ptr, w_source_len);\n    /* Can be invalid UTF-8 but must be valid WTF-8. */\n    assert(code_point >= 0);\n    if (w_source_len < 0 && code_point == 0)\n      break;\n    if (code_point < 0x80)\n      target_len += 1;\n    else if (code_point < 0x800)\n      target_len += 2;\n    else if (code_point < 0x10000)\n      target_len += 3;\n    else {\n      target_len += 4;\n      w_source_ptr++;\n      if (w_source_len > 0)\n        w_source_len--;\n    }\n    w_source_ptr++;\n    if (w_source_len > 0)\n      w_source_len--;\n  }\n\n  return target_len;\n}\n\n\nint uv_utf16_to_wtf8(const uint16_t* w_source_ptr,\n                     ssize_t w_source_len,\n                     char** target_ptr,\n                     size_t* target_len_ptr) {\n  size_t target_len;\n  char* target;\n  char* target_end;\n  int32_t code_point;\n\n  /* If *target_ptr is provided, then *target_len_ptr must be its length\n   * (excluding space for NUL), otherwise we will compute the target_len_ptr\n   * length and may return a new allocation in *target_ptr if target_ptr is\n   * provided. */\n  if (target_ptr == NULL || *target_ptr == NULL) {\n    target_len = uv_utf16_length_as_wtf8(w_source_ptr, w_source_len);\n    if (target_len_ptr != NULL)\n      *target_len_ptr = target_len;\n  } else {\n    target_len = *target_len_ptr;\n  }\n\n  if (target_ptr == NULL)\n    return 0;\n\n  if (*target_ptr == NULL) {\n    target = uv__malloc(target_len + 1);\n    if (target == NULL) {\n      return UV_ENOMEM;\n    }\n    *target_ptr = target;\n  } else {\n    target = *target_ptr;\n  }\n\n  target_end = target + target_len;\n\n  while (target != target_end && w_source_len) {\n    code_point = uv__get_surrogate_value(w_source_ptr, w_source_len);\n    /* Can be invalid UTF-8 but must be valid WTF-8. */\n    assert(code_point >= 0);\n    if (w_source_len < 0 && code_point == 0) {\n      w_source_len = 0;\n      break;\n    }\n    if (code_point < 0x80) {\n      *target++ = code_point;\n    } else if (code_point < 0x800) {\n      *target++ = 0xC0 | (code_point >> 6);\n      if (target == target_end)\n        break;\n      *target++ = 0x80 | (code_point & 0x3F);\n    } else if (code_point < 0x10000) {\n      *target++ = 0xE0 | (code_point >> 12);\n      if (target == target_end)\n        break;\n      *target++ = 0x80 | ((code_point >> 6) & 0x3F);\n      if (target == target_end)\n        break;\n      *target++ = 0x80 | (code_point & 0x3F);\n    } else {\n      *target++ = 0xF0 | (code_point >> 18);\n      if (target == target_end)\n        break;\n      *target++ = 0x80 | ((code_point >> 12) & 0x3F);\n      if (target == target_end)\n        break;\n      *target++ = 0x80 | ((code_point >> 6) & 0x3F);\n      if (target == target_end)\n        break;\n      *target++ = 0x80 | (code_point & 0x3F);\n      /* uv__get_surrogate_value consumed 2 input characters */\n      w_source_ptr++;\n      if (w_source_len > 0)\n        w_source_len--;\n    }\n    target_len = target - *target_ptr;\n    w_source_ptr++;\n    if (w_source_len > 0)\n      w_source_len--;\n  }\n\n  if (target != target_end && target_len_ptr != NULL)\n    /* Did not fill all of the provided buffer, so update the target_len_ptr\n     * output with the space used. */\n    *target_len_ptr = target - *target_ptr;\n\n  /* Check if input fit into target exactly. */\n  if (w_source_len < 0 && target == target_end && w_source_ptr[0] == 0)\n    w_source_len = 0;\n\n  *target++ = '\\0';\n\n  /* Characters remained after filling the buffer, compute the remaining length now. */\n  if (w_source_len) {\n    if (target_len_ptr != NULL)\n      *target_len_ptr = target_len + uv_utf16_length_as_wtf8(w_source_ptr, w_source_len);\n    return UV_ENOBUFS;\n  }\n\n  return 0;\n}\n", "/* Copyright The libuv project and contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"task.h\"\n#define uv__malloc malloc\n#include \"../src/idna.c\"\n#include <string.h>\n\nTEST_IMPL(utf8_decode1) {\n  const char* p;\n  char b[32];\n  int i;\n\n  /* ASCII. */\n  p = b;\n  snprintf(b, sizeof(b), \"%c\\x7F\", 0x00);\n  ASSERT_OK(uv__utf8_decode1(&p, b + sizeof(b)));\n  ASSERT_PTR_EQ(p, b + 1);\n  ASSERT_EQ(127, uv__utf8_decode1(&p, b + sizeof(b)));\n  ASSERT_PTR_EQ(p, b + 2);\n\n  /* Two-byte sequences. */\n  p = b;\n  snprintf(b, sizeof(b), \"\\xC2\\x80\\xDF\\xBF\");\n  ASSERT_EQ(128, uv__utf8_decode1(&p, b + sizeof(b)));\n  ASSERT_PTR_EQ(p, b + 2);\n  ASSERT_EQ(0x7FF, uv__utf8_decode1(&p, b + sizeof(b)));\n  ASSERT_PTR_EQ(p, b + 4);\n\n  /* Three-byte sequences. */\n  p = b;\n  snprintf(b, sizeof(b), \"\\xE0\\xA0\\x80\\xEF\\xBF\\xBF\");\n  ASSERT_EQ(0x800, uv__utf8_decode1(&p, b + sizeof(b)));\n  ASSERT_PTR_EQ(p, b + 3);\n  ASSERT_EQ(0xFFFF, uv__utf8_decode1(&p, b + sizeof(b)));\n  ASSERT_PTR_EQ(p, b + 6);\n\n  /* Four-byte sequences. */\n  p = b;\n  snprintf(b, sizeof(b), \"\\xF0\\x90\\x80\\x80\\xF4\\x8F\\xBF\\xBF\");\n  ASSERT_EQ(0x10000, uv__utf8_decode1(&p, b + sizeof(b)));\n  ASSERT_PTR_EQ(p, b + 4);\n  ASSERT_EQ(0x10FFFF, uv__utf8_decode1(&p, b + sizeof(b)));\n  ASSERT_PTR_EQ(p, b + 8);\n\n  /* Four-byte sequences > U+10FFFF; disallowed. */\n  p = b;\n  snprintf(b, sizeof(b), \"\\xF4\\x90\\xC0\\xC0\\xF7\\xBF\\xBF\\xBF\");\n  ASSERT_EQ((unsigned) -1, uv__utf8_decode1(&p, b + sizeof(b)));\n  ASSERT_PTR_EQ(p, b + 4);\n  ASSERT_EQ((unsigned) -1, uv__utf8_decode1(&p, b + sizeof(b)));\n  ASSERT_PTR_EQ(p, b + 8);\n\n  /* Overlong; disallowed. */\n  p = b;\n  snprintf(b, sizeof(b), \"\\xC0\\x80\\xC1\\x80\");\n  ASSERT_EQ((unsigned) -1, uv__utf8_decode1(&p, b + sizeof(b)));\n  ASSERT_PTR_EQ(p, b + 2);\n  ASSERT_EQ((unsigned) -1, uv__utf8_decode1(&p, b + sizeof(b)));\n  ASSERT_PTR_EQ(p, b + 4);\n\n  /* Surrogate pairs; disallowed. */\n  p = b;\n  snprintf(b, sizeof(b), \"\\xED\\xA0\\x80\\xED\\xA3\\xBF\");\n  ASSERT_EQ((unsigned) -1, uv__utf8_decode1(&p, b + sizeof(b)));\n  ASSERT_PTR_EQ(p, b + 3);\n  ASSERT_EQ((unsigned) -1, uv__utf8_decode1(&p, b + sizeof(b)));\n  ASSERT_PTR_EQ(p, b + 6);\n\n  /* Simply illegal. */\n  p = b;\n  snprintf(b, sizeof(b), \"\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xFF\");\n\n  for (i = 1; i <= 8; i++) {\n    ASSERT_EQ((unsigned) -1, uv__utf8_decode1(&p, b + sizeof(b)));\n    ASSERT_PTR_EQ(p, b + i);\n  }\n\n  return 0;\n}\n\nTEST_IMPL(utf8_decode1_overrun) {\n  const char* p;\n  char b[1];\n\n  /* Single byte. */\n  p = b;\n  b[0] = 0x7F;\n  ASSERT_EQ(0x7F, uv__utf8_decode1(&p, b + 1));\n  ASSERT_PTR_EQ(p, b + 1);\n\n  /* Multi-byte. */\n  p = b;\n  b[0] = 0xC0;\n  ASSERT_EQ((unsigned) -1, uv__utf8_decode1(&p, b + 1));\n  ASSERT_PTR_EQ(p, b + 1);\n\n  return 0;\n}\n\n/* Doesn't work on z/OS because that platform uses EBCDIC, not ASCII. */\n#ifndef __MVS__\n\n#define F(input, err)                                                         \\\n  do {                                                                        \\\n    char d[256] = {0};                                                        \\\n    static const char s[] = \"\" input \"\";                                      \\\n    ASSERT_EQ(err, uv__idna_toascii(s, s + sizeof(s) - 1, d, d + sizeof(d))); \\\n  } while (0)\n\n#define T(input, expected)                                                    \\\n  do {                                                                        \\\n    long n;                                                                   \\\n    char d1[256] = {0};                                                       \\\n    char d2[256] = {0};                                                       \\\n    static const char s[] = \"\" input \"\";                                      \\\n    n = uv__idna_toascii(s, s + sizeof(s) - 1, d1, d1 + sizeof(d1));          \\\n    ASSERT_EQ(n, sizeof(expected));                                           \\\n    ASSERT_OK(memcmp(d1, expected, n));                                       \\\n    /* Sanity check: encoding twice should not change the output. */          \\\n    n = uv__idna_toascii(d1, d1 + strlen(d1), d2, d2 + sizeof(d2));           \\\n    ASSERT_EQ(n, sizeof(expected));                                           \\\n    ASSERT_OK(memcmp(d2, expected, n));                                       \\\n    ASSERT_OK(memcmp(d1, d2, sizeof(d2)));                                    \\\n  } while (0)\n\nTEST_IMPL(idna_toascii) {\n  /* Illegal inputs. */\n  F(\"\\xC0\\x80\\xC1\\x80\", UV_EINVAL);  /* Overlong UTF-8 sequence. */\n  F(\"\\xC0\\x80\\xC1\\x80.com\", UV_EINVAL);  /* Overlong UTF-8 sequence. */\n  /* No conversion. */\n  T(\"\", \"\");\n  T(\".\", \".\");\n  T(\".com\", \".com\");\n  T(\"example\", \"example\");\n  T(\"example-\", \"example-\");\n  T(\"stra\u00dfe.de\", \"xn--strae-oqa.de\");\n  /* Test cases adapted from punycode.js. Most are from RFC 3492. */\n  T(\"foo.bar\", \"foo.bar\");\n  T(\"ma\u00f1ana.com\", \"xn--maana-pta.com\");\n  T(\"example.com.\", \"example.com.\");\n  T(\"b\u00fccher.com\", \"xn--bcher-kva.com\");\n  T(\"caf\u00e9.com\", \"xn--caf-dma.com\");\n  T(\"caf\u00e9.caf\u00e9.com\", \"xn--caf-dma.xn--caf-dma.com\");\n  T(\"\u2603-\u2318.com\", \"xn----dqo34k.com\");\n  T(\"\ud400\u2603-\u2318.com\", \"xn----dqo34kn65z.com\");\n  T(\"\ud83d\udca9.la\", \"xn--ls8h.la\");\n  T(\"ma\u00f1ana.com\", \"xn--maana-pta.com\");\n  T(\"ma\u00f1ana\u3002com\", \"xn--maana-pta.com\");\n  T(\"ma\u00f1ana\uff0ecom\", \"xn--maana-pta.com\");\n  T(\"ma\u00f1ana\uff61com\", \"xn--maana-pta.com\");\n  T(\"\u00fc\", \"xn--tda\");\n  T(\".\u00fc\", \".xn--tda\");\n  T(\"\u00fc.\u00fc\", \"xn--tda.xn--tda\");\n  T(\"\u00fc.\u00fc.\", \"xn--tda.xn--tda.\");\n  T(\"\u00fc\u00eb\u00e4\u00f6\u2665\", \"xn--4can8av2009b\");\n  T(\"Willst du die Bl\u00fcthe des fr\u00fchen, die Fr\u00fcchte des sp\u00e4teren Jahres\",\n    \"xn--Willst du die Blthe des frhen, \"\n    \"die Frchte des spteren Jahres-x9e96lkal\");\n  T(\"\u0644\u064a\u0647\u0645\u0627\u0628\u062a\u0643\u0644\u0645\u0648\u0634\u0639\u0631\u0628\u064a\u061f\", \"xn--egbpdaj6bu4bxfgehfvwxn\");\n  T(\"\u4ed6\u4eec\u4e3a\u4ec0\u4e48\u4e0d\u8bf4\u4e2d\u6587\", \"xn--ihqwcrb4cv8a8dqg056pqjye\");\n  T(\"\u4ed6\u5011\u7232\u4ec0\u9ebd\u4e0d\u8aaa\u4e2d\u6587\", \"xn--ihqwctvzc91f659drss3x8bo0yb\");\n  T(\"Pro\u010dprost\u011bnemluv\u00ed\u010desky\", \"xn--Proprostnemluvesky-uyb24dma41a\");\n  T(\"\u05dc\u05de\u05d4\u05d4\u05dd\u05e4\u05e9\u05d5\u05d8\u05dc\u05d0\u05de\u05d3\u05d1\u05e8\u05d9\u05dd\u05e2\u05d1\u05e8\u05d9\u05ea\", \"xn--4dbcagdahymbxekheh6e0a7fei0b\");\n  T(\"\u092f\u0939\u0932\u094b\u0917\u0939\u093f\u0928\u094d\u0926\u0940\u0915\u094d\u092f\u094b\u0902\u0928\u0939\u0940\u0902\u092c\u094b\u0932\u0938\u0915\u0924\u0947\u0939\u0948\u0902\",\n    \"xn--i1baa7eci9glrd9b2ae1bj0hfcgg6iyaf8o0a1dig0cd\");\n  T(\"\u306a\u305c\u307f\u3093\u306a\u65e5\u672c\u8a9e\u3092\u8a71\u3057\u3066\u304f\u308c\u306a\u3044\u306e\u304b\",\n    \"xn--n8jok5ay5dzabd5bym9f0cm5685rrjetr6pdxa\");\n  T(\"\uc138\uacc4\uc758\ubaa8\ub4e0\uc0ac\ub78c\ub4e4\uc774\ud55c\uad6d\uc5b4\ub97c\uc774\ud574\ud55c\ub2e4\uba74\uc5bc\ub9c8\ub098\uc88b\uc744\uae4c\",\n    \"xn--989aomsvi5e83db1d2a355cv1e0vak1d\"\n    \"wrv93d5xbh15a0dt30a5jpsd879ccm6fea98c\");\n  T(\"\u043f\u043e\u0447\u0435\u043c\u0443\u0436\u0435\u043e\u043d\u0438\u043d\u0435\u0433\u043e\u0432\u043e\u0440\u044f\u0442\u043f\u043e\u0440\u0443\u0441\u0441\u043a\u0438\", \"xn--b1abfaaepdrnnbgefbadotcwatmq2g4l\");\n  T(\"Porqu\u00e9nopuedensimplementehablarenEspa\u00f1ol\",\n    \"xn--PorqunopuedensimplementehablarenEspaol-fmd56a\");\n  T(\"T\u1ea1isaoh\u1ecdkh\u00f4ngth\u1ec3ch\u1ec9n\u00f3iti\u1ebfngVi\u1ec7t\",\n    \"xn--TisaohkhngthchnitingVit-kjcr8268qyxafd2f1b9g\");\n  T(\"3\u5e74B\u7d44\u91d1\u516b\u5148\u751f\", \"xn--3B-ww4c5e180e575a65lsy2b\");\n  T(\"\u5b89\u5ba4\u5948\u7f8e\u6075-with-SUPER-MONKEYS\",\n    \"xn---with-SUPER-MONKEYS-pc58ag80a8qai00g7n9n\");\n  T(\"Hello-Another-Way-\u305d\u308c\u305e\u308c\u306e\u5834\u6240\",\n    \"xn--Hello-Another-Way--fc4qua05auwb3674vfr0b\");\n  T(\"\u3072\u3068\u3064\u5c4b\u6839\u306e\u4e0b2\", \"xn--2-u9tlzr9756bt3uc0v\");\n  T(\"Maji\u3067Koi\u3059\u308b5\u79d2\u524d\", \"xn--MajiKoi5-783gue6qz075azm5e\");\n  T(\"\u30d1\u30d5\u30a3\u30fcde\u30eb\u30f3\u30d0\", \"xn--de-jg4avhby1noc0d\");\n  T(\"\u305d\u306e\u30b9\u30d4\u30fc\u30c9\u3067\", \"xn--d9juau41awczczp\");\n  T(\"-> $1.00 <-\", \"-> $1.00 <-\");\n  /* Test cases from https://unicode.org/reports/tr46/ */\n  T(\"fa\u00df.de\", \"xn--fa-hia.de\");\n  T(\"\u03b2\u03cc\u03bb\u03bf\u03c2.com\", \"xn--nxasmm1c.com\");\n  T(\"\u0dc1\u0dca\u200d\u0dbb\u0dd3.com\", \"xn--10cl1a0b660p.com\");\n  T(\"\u0646\u0627\u0645\u0647\u200c\u0627\u06cc.com\", \"xn--mgba3gch31f060k.com\");\n  return 0;\n}\n\n#undef T\n\n#endif  /* __MVS__ */\n"], "fixing_code": ["/* Copyright libuv contributors. All rights reserved.\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n/* Derived from https://github.com/bnoordhuis/punycode\n * but updated to support IDNA 2008.\n */\n\n#include \"uv.h\"\n#include \"uv-common.h\"\n#include \"idna.h\"\n#include <assert.h>\n#include <string.h>\n#include <limits.h> /* UINT_MAX */\n\n\nstatic int32_t uv__wtf8_decode1(const char** input) {\n  uint32_t code_point;\n  uint8_t b1;\n  uint8_t b2;\n  uint8_t b3;\n  uint8_t b4;\n\n  b1 = **input;\n  if (b1 <= 0x7F)\n    return b1; /* ASCII code point */\n  if (b1 < 0xC2)\n    return -1; /* invalid: continuation byte */\n  code_point = b1;\n\n  b2 = *++*input;\n  if ((b2 & 0xC0) != 0x80)\n    return -1; /* invalid: not a continuation byte */\n  code_point = (code_point << 6) | (b2 & 0x3F);\n  if (b1 <= 0xDF)\n    return 0x7FF & code_point; /* two-byte character */\n\n  b3 = *++*input;\n  if ((b3 & 0xC0) != 0x80)\n    return -1; /* invalid: not a continuation byte */\n  code_point = (code_point << 6) | (b3 & 0x3F);\n  if (b1 <= 0xEF)\n    return 0xFFFF & code_point; /* three-byte character */\n\n  b4 = *++*input;\n  if ((b4 & 0xC0) != 0x80)\n    return -1; /* invalid: not a continuation byte */\n  code_point = (code_point << 6) | (b4 & 0x3F);\n  if (b1 <= 0xF4) {\n    code_point &= 0x1FFFFF;\n    if (code_point <= 0x10FFFF)\n      return code_point; /* four-byte character */\n  }\n\n  /* code point too large */\n  return -1;\n}\n\n\nstatic unsigned uv__utf8_decode1_slow(const char** p,\n                                      const char* pe,\n                                      unsigned a) {\n  unsigned b;\n  unsigned c;\n  unsigned d;\n  unsigned min;\n\n  if (a > 0xF7)\n    return -1;\n\n  switch (pe - *p) {\n  default:\n    if (a > 0xEF) {\n      min = 0x10000;\n      a = a & 7;\n      b = (unsigned char) *(*p)++;\n      c = (unsigned char) *(*p)++;\n      d = (unsigned char) *(*p)++;\n      break;\n    }\n    /* Fall through. */\n  case 2:\n    if (a > 0xDF) {\n      min = 0x800;\n      b = 0x80 | (a & 15);\n      c = (unsigned char) *(*p)++;\n      d = (unsigned char) *(*p)++;\n      a = 0;\n      break;\n    }\n    /* Fall through. */\n  case 1:\n    if (a > 0xBF) {\n      min = 0x80;\n      b = 0x80;\n      c = 0x80 | (a & 31);\n      d = (unsigned char) *(*p)++;\n      a = 0;\n      break;\n    }\n    /* Fall through. */\n  case 0:\n    return -1;  /* Invalid continuation byte. */\n  }\n\n  if (0x80 != (0xC0 & (b ^ c ^ d)))\n    return -1;  /* Invalid sequence. */\n\n  b &= 63;\n  c &= 63;\n  d &= 63;\n  a = (a << 18) | (b << 12) | (c << 6) | d;\n\n  if (a < min)\n    return -1;  /* Overlong sequence. */\n\n  if (a > 0x10FFFF)\n    return -1;  /* Four-byte sequence > U+10FFFF. */\n\n  if (a >= 0xD800 && a <= 0xDFFF)\n    return -1;  /* Surrogate pair. */\n\n  return a;\n}\n\n\nunsigned uv__utf8_decode1(const char** p, const char* pe) {\n  unsigned a;\n\n  assert(*p < pe);\n\n  a = (unsigned char) *(*p)++;\n\n  if (a < 128)\n    return a;  /* ASCII, common case. */\n\n  return uv__utf8_decode1_slow(p, pe, a);\n}\n\n\nstatic int uv__idna_toascii_label(const char* s, const char* se,\n                                  char** d, char* de) {\n  static const char alphabet[] = \"abcdefghijklmnopqrstuvwxyz0123456789\";\n  const char* ss;\n  unsigned c;\n  unsigned h;\n  unsigned k;\n  unsigned n;\n  unsigned m;\n  unsigned q;\n  unsigned t;\n  unsigned x;\n  unsigned y;\n  unsigned bias;\n  unsigned delta;\n  unsigned todo;\n  int first;\n\n  h = 0;\n  ss = s;\n  todo = 0;\n\n  /* Note: after this loop we've visited all UTF-8 characters and know\n   * they're legal so we no longer need to check for decode errors.\n   */\n  while (s < se) {\n    c = uv__utf8_decode1(&s, se);\n\n    if (c == UINT_MAX)\n      return UV_EINVAL;\n\n    if (c < 128)\n      h++;\n    else\n      todo++;\n  }\n\n  /* Only write \"xn--\" when there are non-ASCII characters. */\n  if (todo > 0) {\n    if (*d < de) *(*d)++ = 'x';\n    if (*d < de) *(*d)++ = 'n';\n    if (*d < de) *(*d)++ = '-';\n    if (*d < de) *(*d)++ = '-';\n  }\n\n  /* Write ASCII characters. */\n  x = 0;\n  s = ss;\n  while (s < se) {\n    c = uv__utf8_decode1(&s, se);\n    assert(c != UINT_MAX);\n\n    if (c > 127)\n      continue;\n\n    if (*d < de)\n      *(*d)++ = c;\n\n    if (++x == h)\n      break;  /* Visited all ASCII characters. */\n  }\n\n  if (todo == 0)\n    return h;\n\n  /* Only write separator when we've written ASCII characters first. */\n  if (h > 0)\n    if (*d < de)\n      *(*d)++ = '-';\n\n  n = 128;\n  bias = 72;\n  delta = 0;\n  first = 1;\n\n  while (todo > 0) {\n    m = -1;\n    s = ss;\n\n    while (s < se) {\n      c = uv__utf8_decode1(&s, se);\n      assert(c != UINT_MAX);\n\n      if (c >= n)\n        if (c < m)\n          m = c;\n    }\n\n    x = m - n;\n    y = h + 1;\n\n    if (x > ~delta / y)\n      return UV_E2BIG;  /* Overflow. */\n\n    delta += x * y;\n    n = m;\n\n    s = ss;\n    while (s < se) {\n      c = uv__utf8_decode1(&s, se);\n      assert(c != UINT_MAX);\n\n      if (c < n)\n        if (++delta == 0)\n          return UV_E2BIG;  /* Overflow. */\n\n      if (c != n)\n        continue;\n\n      for (k = 36, q = delta; /* empty */; k += 36) {\n        t = 1;\n\n        if (k > bias)\n          t = k - bias;\n\n        if (t > 26)\n          t = 26;\n\n        if (q < t)\n          break;\n\n        /* TODO(bnoordhuis) Since 1 <= t <= 26 and therefore\n         * 10 <= y <= 35, we can optimize the long division\n         * into a table-based reciprocal multiplication.\n         */\n        x = q - t;\n        y = 36 - t;  /* 10 <= y <= 35 since 1 <= t <= 26. */\n        q = x / y;\n        t = t + x % y;  /* 1 <= t <= 35 because of y. */\n\n        if (*d < de)\n          *(*d)++ = alphabet[t];\n      }\n\n      if (*d < de)\n        *(*d)++ = alphabet[q];\n\n      delta /= 2;\n\n      if (first) {\n        delta /= 350;\n        first = 0;\n      }\n\n      /* No overflow check is needed because |delta| was just\n       * divided by 2 and |delta+delta >= delta + delta/h|.\n       */\n      h++;\n      delta += delta / h;\n\n      for (bias = 0; delta > 35 * 26 / 2; bias += 36)\n        delta /= 35;\n\n      bias += 36 * delta / (delta + 38);\n      delta = 0;\n      todo--;\n    }\n\n    delta++;\n    n++;\n  }\n\n  return 0;\n}\n\n\nssize_t uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n\n  ds = d;\n\n  si = s;\n  while (si < se) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n\n    if (c == UINT_MAX)\n      return UV_EINVAL;\n\n    if (c != '.')\n      if (c != 0x3002)  /* \u3002 */\n        if (c != 0xFF0E)  /* \uff0e */\n          if (c != 0xFF61)  /* \uff61 */\n            continue;\n\n    rc = uv__idna_toascii_label(s, st, &d, de);\n\n    if (rc < 0)\n      return rc;\n\n    if (d < de)\n      *d++ = '.';\n\n    s = si;\n  }\n\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n\n    if (rc < 0)\n      return rc;\n  }\n\n  if (d >= de)\n    return UV_EINVAL;\n\n  *d++ = '\\0';\n  return d - ds;  /* Number of bytes written. */\n}\n\n\nssize_t uv_wtf8_length_as_utf16(const char* source_ptr) {\n  size_t w_target_len = 0;\n  int32_t code_point;\n\n  do {\n    code_point = uv__wtf8_decode1(&source_ptr);\n    if (code_point < 0)\n      return -1;\n    if (code_point > 0xFFFF)\n      w_target_len++;\n    w_target_len++;\n  } while (*source_ptr++);\n\n  return w_target_len;\n}\n\n\nvoid uv_wtf8_to_utf16(const char* source_ptr,\n                      uint16_t* w_target,\n                      size_t w_target_len) {\n  int32_t code_point;\n\n  do {\n    code_point = uv__wtf8_decode1(&source_ptr);\n    /* uv_wtf8_length_as_utf16 should have been called and checked first. */\n    assert(code_point >= 0);\n    if (code_point > 0x10000) {\n      assert(code_point < 0x10FFFF);\n      *w_target++ = (((code_point - 0x10000) >> 10) + 0xD800);\n      *w_target++ = ((code_point - 0x10000) & 0x3FF) + 0xDC00;\n      w_target_len -= 2;\n    } else {\n      *w_target++ = code_point;\n      w_target_len -= 1;\n    }\n  } while (*source_ptr++);\n\n  (void)w_target_len;\n  assert(w_target_len == 0);\n}\n\n\nstatic int32_t uv__get_surrogate_value(const uint16_t* w_source_ptr,\n                                       ssize_t w_source_len) {\n  uint16_t u;\n  uint16_t next;\n\n  u = w_source_ptr[0];\n  if (u >= 0xD800 && u <= 0xDBFF && w_source_len != 1) {\n    next = w_source_ptr[1];\n    if (next >= 0xDC00 && next <= 0xDFFF)\n      return 0x10000 + ((u - 0xD800) << 10) + (next - 0xDC00);\n  }\n  return u;\n}\n\n\nsize_t uv_utf16_length_as_wtf8(const uint16_t* w_source_ptr,\n                               ssize_t w_source_len) {\n  size_t target_len;\n  int32_t code_point;\n\n  target_len = 0;\n  while (w_source_len) {\n    code_point = uv__get_surrogate_value(w_source_ptr, w_source_len);\n    /* Can be invalid UTF-8 but must be valid WTF-8. */\n    assert(code_point >= 0);\n    if (w_source_len < 0 && code_point == 0)\n      break;\n    if (code_point < 0x80)\n      target_len += 1;\n    else if (code_point < 0x800)\n      target_len += 2;\n    else if (code_point < 0x10000)\n      target_len += 3;\n    else {\n      target_len += 4;\n      w_source_ptr++;\n      if (w_source_len > 0)\n        w_source_len--;\n    }\n    w_source_ptr++;\n    if (w_source_len > 0)\n      w_source_len--;\n  }\n\n  return target_len;\n}\n\n\nint uv_utf16_to_wtf8(const uint16_t* w_source_ptr,\n                     ssize_t w_source_len,\n                     char** target_ptr,\n                     size_t* target_len_ptr) {\n  size_t target_len;\n  char* target;\n  char* target_end;\n  int32_t code_point;\n\n  /* If *target_ptr is provided, then *target_len_ptr must be its length\n   * (excluding space for NUL), otherwise we will compute the target_len_ptr\n   * length and may return a new allocation in *target_ptr if target_ptr is\n   * provided. */\n  if (target_ptr == NULL || *target_ptr == NULL) {\n    target_len = uv_utf16_length_as_wtf8(w_source_ptr, w_source_len);\n    if (target_len_ptr != NULL)\n      *target_len_ptr = target_len;\n  } else {\n    target_len = *target_len_ptr;\n  }\n\n  if (target_ptr == NULL)\n    return 0;\n\n  if (*target_ptr == NULL) {\n    target = uv__malloc(target_len + 1);\n    if (target == NULL) {\n      return UV_ENOMEM;\n    }\n    *target_ptr = target;\n  } else {\n    target = *target_ptr;\n  }\n\n  target_end = target + target_len;\n\n  while (target != target_end && w_source_len) {\n    code_point = uv__get_surrogate_value(w_source_ptr, w_source_len);\n    /* Can be invalid UTF-8 but must be valid WTF-8. */\n    assert(code_point >= 0);\n    if (w_source_len < 0 && code_point == 0) {\n      w_source_len = 0;\n      break;\n    }\n    if (code_point < 0x80) {\n      *target++ = code_point;\n    } else if (code_point < 0x800) {\n      *target++ = 0xC0 | (code_point >> 6);\n      if (target == target_end)\n        break;\n      *target++ = 0x80 | (code_point & 0x3F);\n    } else if (code_point < 0x10000) {\n      *target++ = 0xE0 | (code_point >> 12);\n      if (target == target_end)\n        break;\n      *target++ = 0x80 | ((code_point >> 6) & 0x3F);\n      if (target == target_end)\n        break;\n      *target++ = 0x80 | (code_point & 0x3F);\n    } else {\n      *target++ = 0xF0 | (code_point >> 18);\n      if (target == target_end)\n        break;\n      *target++ = 0x80 | ((code_point >> 12) & 0x3F);\n      if (target == target_end)\n        break;\n      *target++ = 0x80 | ((code_point >> 6) & 0x3F);\n      if (target == target_end)\n        break;\n      *target++ = 0x80 | (code_point & 0x3F);\n      /* uv__get_surrogate_value consumed 2 input characters */\n      w_source_ptr++;\n      if (w_source_len > 0)\n        w_source_len--;\n    }\n    target_len = target - *target_ptr;\n    w_source_ptr++;\n    if (w_source_len > 0)\n      w_source_len--;\n  }\n\n  if (target != target_end && target_len_ptr != NULL)\n    /* Did not fill all of the provided buffer, so update the target_len_ptr\n     * output with the space used. */\n    *target_len_ptr = target - *target_ptr;\n\n  /* Check if input fit into target exactly. */\n  if (w_source_len < 0 && target == target_end && w_source_ptr[0] == 0)\n    w_source_len = 0;\n\n  *target++ = '\\0';\n\n  /* Characters remained after filling the buffer, compute the remaining length now. */\n  if (w_source_len) {\n    if (target_len_ptr != NULL)\n      *target_len_ptr = target_len + uv_utf16_length_as_wtf8(w_source_ptr, w_source_len);\n    return UV_ENOBUFS;\n  }\n\n  return 0;\n}\n", "/* Copyright The libuv project and contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"task.h\"\n#define uv__malloc malloc\n#include \"../src/idna.c\"\n#include <string.h>\n\nTEST_IMPL(utf8_decode1) {\n  const char* p;\n  char b[32];\n  int i;\n\n  /* ASCII. */\n  p = b;\n  snprintf(b, sizeof(b), \"%c\\x7F\", 0x00);\n  ASSERT_OK(uv__utf8_decode1(&p, b + sizeof(b)));\n  ASSERT_PTR_EQ(p, b + 1);\n  ASSERT_EQ(127, uv__utf8_decode1(&p, b + sizeof(b)));\n  ASSERT_PTR_EQ(p, b + 2);\n\n  /* Two-byte sequences. */\n  p = b;\n  snprintf(b, sizeof(b), \"\\xC2\\x80\\xDF\\xBF\");\n  ASSERT_EQ(128, uv__utf8_decode1(&p, b + sizeof(b)));\n  ASSERT_PTR_EQ(p, b + 2);\n  ASSERT_EQ(0x7FF, uv__utf8_decode1(&p, b + sizeof(b)));\n  ASSERT_PTR_EQ(p, b + 4);\n\n  /* Three-byte sequences. */\n  p = b;\n  snprintf(b, sizeof(b), \"\\xE0\\xA0\\x80\\xEF\\xBF\\xBF\");\n  ASSERT_EQ(0x800, uv__utf8_decode1(&p, b + sizeof(b)));\n  ASSERT_PTR_EQ(p, b + 3);\n  ASSERT_EQ(0xFFFF, uv__utf8_decode1(&p, b + sizeof(b)));\n  ASSERT_PTR_EQ(p, b + 6);\n\n  /* Four-byte sequences. */\n  p = b;\n  snprintf(b, sizeof(b), \"\\xF0\\x90\\x80\\x80\\xF4\\x8F\\xBF\\xBF\");\n  ASSERT_EQ(0x10000, uv__utf8_decode1(&p, b + sizeof(b)));\n  ASSERT_PTR_EQ(p, b + 4);\n  ASSERT_EQ(0x10FFFF, uv__utf8_decode1(&p, b + sizeof(b)));\n  ASSERT_PTR_EQ(p, b + 8);\n\n  /* Four-byte sequences > U+10FFFF; disallowed. */\n  p = b;\n  snprintf(b, sizeof(b), \"\\xF4\\x90\\xC0\\xC0\\xF7\\xBF\\xBF\\xBF\");\n  ASSERT_EQ((unsigned) -1, uv__utf8_decode1(&p, b + sizeof(b)));\n  ASSERT_PTR_EQ(p, b + 4);\n  ASSERT_EQ((unsigned) -1, uv__utf8_decode1(&p, b + sizeof(b)));\n  ASSERT_PTR_EQ(p, b + 8);\n\n  /* Overlong; disallowed. */\n  p = b;\n  snprintf(b, sizeof(b), \"\\xC0\\x80\\xC1\\x80\");\n  ASSERT_EQ((unsigned) -1, uv__utf8_decode1(&p, b + sizeof(b)));\n  ASSERT_PTR_EQ(p, b + 2);\n  ASSERT_EQ((unsigned) -1, uv__utf8_decode1(&p, b + sizeof(b)));\n  ASSERT_PTR_EQ(p, b + 4);\n\n  /* Surrogate pairs; disallowed. */\n  p = b;\n  snprintf(b, sizeof(b), \"\\xED\\xA0\\x80\\xED\\xA3\\xBF\");\n  ASSERT_EQ((unsigned) -1, uv__utf8_decode1(&p, b + sizeof(b)));\n  ASSERT_PTR_EQ(p, b + 3);\n  ASSERT_EQ((unsigned) -1, uv__utf8_decode1(&p, b + sizeof(b)));\n  ASSERT_PTR_EQ(p, b + 6);\n\n  /* Simply illegal. */\n  p = b;\n  snprintf(b, sizeof(b), \"\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xFF\");\n\n  for (i = 1; i <= 8; i++) {\n    ASSERT_EQ((unsigned) -1, uv__utf8_decode1(&p, b + sizeof(b)));\n    ASSERT_PTR_EQ(p, b + i);\n  }\n\n  return 0;\n}\n\nTEST_IMPL(utf8_decode1_overrun) {\n  const char* p;\n  char b[1];\n  char c[1];\n\n  /* Single byte. */\n  p = b;\n  b[0] = 0x7F;\n  ASSERT_EQ(0x7F, uv__utf8_decode1(&p, b + 1));\n  ASSERT_PTR_EQ(p, b + 1);\n\n  /* Multi-byte. */\n  p = b;\n  b[0] = 0xC0;\n  ASSERT_EQ((unsigned) -1, uv__utf8_decode1(&p, b + 1));\n  ASSERT_PTR_EQ(p, b + 1);\n\n  b[0] = 0x7F;\n  ASSERT_EQ(UV_EINVAL, uv__idna_toascii(b, b + 1, c, c + 1));\n\n  return 0;\n}\n\n/* Doesn't work on z/OS because that platform uses EBCDIC, not ASCII. */\n#ifndef __MVS__\n\n#define F(input, err)                                                         \\\n  do {                                                                        \\\n    char d[256] = {0};                                                        \\\n    static const char s[] = \"\" input \"\";                                      \\\n    ASSERT_EQ(err, uv__idna_toascii(s, s + sizeof(s) - 1, d, d + sizeof(d))); \\\n  } while (0)\n\n#define T(input, expected)                                                    \\\n  do {                                                                        \\\n    long n;                                                                   \\\n    char d1[256] = {0};                                                       \\\n    char d2[256] = {0};                                                       \\\n    static const char s[] = \"\" input \"\";                                      \\\n    n = uv__idna_toascii(s, s + sizeof(s) - 1, d1, d1 + sizeof(d1));          \\\n    ASSERT_EQ(n, sizeof(expected));                                           \\\n    ASSERT_OK(memcmp(d1, expected, n));                                       \\\n    /* Sanity check: encoding twice should not change the output. */          \\\n    n = uv__idna_toascii(d1, d1 + strlen(d1), d2, d2 + sizeof(d2));           \\\n    ASSERT_EQ(n, sizeof(expected));                                           \\\n    ASSERT_OK(memcmp(d2, expected, n));                                       \\\n    ASSERT_OK(memcmp(d1, d2, sizeof(d2)));                                    \\\n  } while (0)\n\nTEST_IMPL(idna_toascii) {\n  /* Illegal inputs. */\n  F(\"\\xC0\\x80\\xC1\\x80\", UV_EINVAL);  /* Overlong UTF-8 sequence. */\n  F(\"\\xC0\\x80\\xC1\\x80.com\", UV_EINVAL);  /* Overlong UTF-8 sequence. */\n  /* No conversion. */\n  T(\"\", \"\");\n  T(\".\", \".\");\n  T(\".com\", \".com\");\n  T(\"example\", \"example\");\n  T(\"example-\", \"example-\");\n  T(\"stra\u00dfe.de\", \"xn--strae-oqa.de\");\n  /* Test cases adapted from punycode.js. Most are from RFC 3492. */\n  T(\"foo.bar\", \"foo.bar\");\n  T(\"ma\u00f1ana.com\", \"xn--maana-pta.com\");\n  T(\"example.com.\", \"example.com.\");\n  T(\"b\u00fccher.com\", \"xn--bcher-kva.com\");\n  T(\"caf\u00e9.com\", \"xn--caf-dma.com\");\n  T(\"caf\u00e9.caf\u00e9.com\", \"xn--caf-dma.xn--caf-dma.com\");\n  T(\"\u2603-\u2318.com\", \"xn----dqo34k.com\");\n  T(\"\ud400\u2603-\u2318.com\", \"xn----dqo34kn65z.com\");\n  T(\"\ud83d\udca9.la\", \"xn--ls8h.la\");\n  T(\"ma\u00f1ana.com\", \"xn--maana-pta.com\");\n  T(\"ma\u00f1ana\u3002com\", \"xn--maana-pta.com\");\n  T(\"ma\u00f1ana\uff0ecom\", \"xn--maana-pta.com\");\n  T(\"ma\u00f1ana\uff61com\", \"xn--maana-pta.com\");\n  T(\"\u00fc\", \"xn--tda\");\n  T(\".\u00fc\", \".xn--tda\");\n  T(\"\u00fc.\u00fc\", \"xn--tda.xn--tda\");\n  T(\"\u00fc.\u00fc.\", \"xn--tda.xn--tda.\");\n  T(\"\u00fc\u00eb\u00e4\u00f6\u2665\", \"xn--4can8av2009b\");\n  T(\"Willst du die Bl\u00fcthe des fr\u00fchen, die Fr\u00fcchte des sp\u00e4teren Jahres\",\n    \"xn--Willst du die Blthe des frhen, \"\n    \"die Frchte des spteren Jahres-x9e96lkal\");\n  T(\"\u0644\u064a\u0647\u0645\u0627\u0628\u062a\u0643\u0644\u0645\u0648\u0634\u0639\u0631\u0628\u064a\u061f\", \"xn--egbpdaj6bu4bxfgehfvwxn\");\n  T(\"\u4ed6\u4eec\u4e3a\u4ec0\u4e48\u4e0d\u8bf4\u4e2d\u6587\", \"xn--ihqwcrb4cv8a8dqg056pqjye\");\n  T(\"\u4ed6\u5011\u7232\u4ec0\u9ebd\u4e0d\u8aaa\u4e2d\u6587\", \"xn--ihqwctvzc91f659drss3x8bo0yb\");\n  T(\"Pro\u010dprost\u011bnemluv\u00ed\u010desky\", \"xn--Proprostnemluvesky-uyb24dma41a\");\n  T(\"\u05dc\u05de\u05d4\u05d4\u05dd\u05e4\u05e9\u05d5\u05d8\u05dc\u05d0\u05de\u05d3\u05d1\u05e8\u05d9\u05dd\u05e2\u05d1\u05e8\u05d9\u05ea\", \"xn--4dbcagdahymbxekheh6e0a7fei0b\");\n  T(\"\u092f\u0939\u0932\u094b\u0917\u0939\u093f\u0928\u094d\u0926\u0940\u0915\u094d\u092f\u094b\u0902\u0928\u0939\u0940\u0902\u092c\u094b\u0932\u0938\u0915\u0924\u0947\u0939\u0948\u0902\",\n    \"xn--i1baa7eci9glrd9b2ae1bj0hfcgg6iyaf8o0a1dig0cd\");\n  T(\"\u306a\u305c\u307f\u3093\u306a\u65e5\u672c\u8a9e\u3092\u8a71\u3057\u3066\u304f\u308c\u306a\u3044\u306e\u304b\",\n    \"xn--n8jok5ay5dzabd5bym9f0cm5685rrjetr6pdxa\");\n  T(\"\uc138\uacc4\uc758\ubaa8\ub4e0\uc0ac\ub78c\ub4e4\uc774\ud55c\uad6d\uc5b4\ub97c\uc774\ud574\ud55c\ub2e4\uba74\uc5bc\ub9c8\ub098\uc88b\uc744\uae4c\",\n    \"xn--989aomsvi5e83db1d2a355cv1e0vak1d\"\n    \"wrv93d5xbh15a0dt30a5jpsd879ccm6fea98c\");\n  T(\"\u043f\u043e\u0447\u0435\u043c\u0443\u0436\u0435\u043e\u043d\u0438\u043d\u0435\u0433\u043e\u0432\u043e\u0440\u044f\u0442\u043f\u043e\u0440\u0443\u0441\u0441\u043a\u0438\", \"xn--b1abfaaepdrnnbgefbadotcwatmq2g4l\");\n  T(\"Porqu\u00e9nopuedensimplementehablarenEspa\u00f1ol\",\n    \"xn--PorqunopuedensimplementehablarenEspaol-fmd56a\");\n  T(\"T\u1ea1isaoh\u1ecdkh\u00f4ngth\u1ec3ch\u1ec9n\u00f3iti\u1ebfngVi\u1ec7t\",\n    \"xn--TisaohkhngthchnitingVit-kjcr8268qyxafd2f1b9g\");\n  T(\"3\u5e74B\u7d44\u91d1\u516b\u5148\u751f\", \"xn--3B-ww4c5e180e575a65lsy2b\");\n  T(\"\u5b89\u5ba4\u5948\u7f8e\u6075-with-SUPER-MONKEYS\",\n    \"xn---with-SUPER-MONKEYS-pc58ag80a8qai00g7n9n\");\n  T(\"Hello-Another-Way-\u305d\u308c\u305e\u308c\u306e\u5834\u6240\",\n    \"xn--Hello-Another-Way--fc4qua05auwb3674vfr0b\");\n  T(\"\u3072\u3068\u3064\u5c4b\u6839\u306e\u4e0b2\", \"xn--2-u9tlzr9756bt3uc0v\");\n  T(\"Maji\u3067Koi\u3059\u308b5\u79d2\u524d\", \"xn--MajiKoi5-783gue6qz075azm5e\");\n  T(\"\u30d1\u30d5\u30a3\u30fcde\u30eb\u30f3\u30d0\", \"xn--de-jg4avhby1noc0d\");\n  T(\"\u305d\u306e\u30b9\u30d4\u30fc\u30c9\u3067\", \"xn--d9juau41awczczp\");\n  T(\"-> $1.00 <-\", \"-> $1.00 <-\");\n  /* Test cases from https://unicode.org/reports/tr46/ */\n  T(\"fa\u00df.de\", \"xn--fa-hia.de\");\n  T(\"\u03b2\u03cc\u03bb\u03bf\u03c2.com\", \"xn--nxasmm1c.com\");\n  T(\"\u0dc1\u0dca\u200d\u0dbb\u0dd3.com\", \"xn--10cl1a0b660p.com\");\n  T(\"\u0646\u0627\u0645\u0647\u200c\u0627\u06cc.com\", \"xn--mgba3gch31f060k.com\");\n  return 0;\n}\n\n#undef T\n\n#endif  /* __MVS__ */\n"], "filenames": ["src/idna.c", "test/test-idna.c"], "buggy_code_start_loc": [359, 102], "buggy_code_end_loc": [362, 114], "fixing_code_start_loc": [359, 103], "fixing_code_end_loc": [363, 119], "type": "CWE-918", "message": "libuv is a multi-platform support library with a focus on asynchronous I/O. The `uv_getaddrinfo` function in `src/unix/getaddrinfo.c` (and its windows counterpart `src/win/getaddrinfo.c`), truncates hostnames to 256 characters before calling `getaddrinfo`. This behavior can be exploited to create addresses like `0x00007f000001`, which are considered valid by `getaddrinfo` and could allow an attacker to craft payloads that resolve to unintended IP addresses, bypassing developer checks. The vulnerability arises due to how the `hostname_ascii` variable (with a length of 256 bytes) is handled in `uv_getaddrinfo` and subsequently in `uv__idna_toascii`. When the hostname exceeds 256 characters, it gets truncated without a terminating null byte. As a result attackers may be able to access internal APIs or for websites (similar to MySpace) that allows users to have `username.example.com` pages. Internal services that crawl or cache these user pages can be exposed to SSRF attacks if a malicious user chooses a long vulnerable username. This issue has been addressed in release version 1.48.0. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2024-24806", "sourceIdentifier": "security-advisories@github.com", "published": "2024-02-07T22:15:10.173", "lastModified": "2024-03-05T23:15:07.867", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "libuv is a multi-platform support library with a focus on asynchronous I/O. The `uv_getaddrinfo` function in `src/unix/getaddrinfo.c` (and its windows counterpart `src/win/getaddrinfo.c`), truncates hostnames to 256 characters before calling `getaddrinfo`. This behavior can be exploited to create addresses like `0x00007f000001`, which are considered valid by `getaddrinfo` and could allow an attacker to craft payloads that resolve to unintended IP addresses, bypassing developer checks. The vulnerability arises due to how the `hostname_ascii` variable (with a length of 256 bytes) is handled in `uv_getaddrinfo` and subsequently in `uv__idna_toascii`. When the hostname exceeds 256 characters, it gets truncated without a terminating null byte. As a result attackers may be able to access internal APIs or for websites (similar to MySpace) that allows users to have `username.example.com` pages. Internal services that crawl or cache these user pages can be exposed to SSRF attacks if a malicious user chooses a long vulnerable username. This issue has been addressed in release version 1.48.0. Users are advised to upgrade. There are no known workarounds for this vulnerability."}, {"lang": "es", "value": "libuv es una librer\u00eda de soporte multiplataforma centrada en E/S as\u00edncrona. La funci\u00f3n `uv_getaddrinfo` en `src/unix/getaddrinfo.c` (y su contraparte de Windows `src/win/getaddrinfo.c`), trunca los nombres de host a 256 caracteres antes de llamar a `getaddrinfo`. Este comportamiento se puede aprovechar para crear direcciones como `0x00007f000001`, que `getaddrinfo` considera v\u00e1lidas y podr\u00edan permitir a un atacante crear payloads que se resuelvan en direcciones IP no deseadas, evitando las comprobaciones de los desarrolladores. La vulnerabilidad surge debido a c\u00f3mo se maneja la variable `hostname_ascii` (con una longitud de 256 bytes) en `uv_getaddrinfo` y posteriormente en `uv__idna_toascii`. Cuando el nombre de host supera los 256 caracteres, se trunca sin un byte nulo final. Como resultado, los atacantes pueden acceder a API internas o a sitios web (similares a MySpace) que permiten a los usuarios tener p\u00e1ginas `nombre de usuario.ejemplo.com`. Los servicios internos que rastrean o almacenan en cach\u00e9 estas p\u00e1ginas de usuario pueden quedar expuestos a ataques SSRF si un usuario malintencionado elige un nombre de usuario largo y vulnerable. Este problema se solucion\u00f3 en la versi\u00f3n 1.48.0. Se recomienda a los usuarios que actualicen. No se conocen workarounds para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libuv:libuv:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.24.0", "versionEndExcluding": "1.48.0", "matchCriteriaId": "7A5D8905-1DA8-45F4-886D-2FDAA3C722DF"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2024/02/08/2", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2024/02/11/1", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/libuv/libuv/commit/0f2d7e784a256b54b2385043438848047bc2a629", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/libuv/libuv/commit/3530bcc30350d4a6ccf35d2f7b33e23292b9de70", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/libuv/libuv/commit/c858a147643de38a09dd4164758ae5b685f2b488", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/libuv/libuv/commit/e0327e1d508b8207c9150b6e582f0adf26213c39", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/libuv/libuv/security/advisories/GHSA-f74f-cvh7-c6q6", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2024/03/msg00005.html", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/libuv/libuv/commit/0f2d7e784a256b54b2385043438848047bc2a629"}}