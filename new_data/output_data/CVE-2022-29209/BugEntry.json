{"buggy_code": ["/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#if defined(_WIN32)\n// prevent compile error because MSVC doesn't realize in debug build that\n// LOG(FATAL) finally invokes abort()\n#pragma warning(disable : 4716)\n#endif  // _WIN32\n\n#ifndef TENSORFLOW_CORE_PLATFORM_DEFAULT_LOGGING_H_\n#define TENSORFLOW_CORE_PLATFORM_DEFAULT_LOGGING_H_\n\n// IWYU pragma: private, include \"third_party/tensorflow/core/platform/logging.h\"\n// IWYU pragma: friend third_party/tensorflow/core/platform/logging.h\n\n#include <atomic>\n#include <limits>\n#include <memory>\n#include <sstream>\n#include <vector>\n\n#include \"absl/base/log_severity.h\"\n#include \"absl/strings/string_view.h\"\n#include \"tensorflow/core/platform/macros.h\"\n#include \"tensorflow/core/platform/types.h\"\n\n// TODO(mrry): Prevent this Windows.h #define from leaking out of our headers.\n#undef ERROR\n\nnamespace tensorflow {\nconst int INFO = 0;            // base_logging::INFO;\nconst int WARNING = 1;         // base_logging::WARNING;\nconst int ERROR = 2;           // base_logging::ERROR;\nconst int FATAL = 3;           // base_logging::FATAL;\nconst int NUM_SEVERITIES = 4;  // base_logging::NUM_SEVERITIES;\n\nnamespace internal {\n\nclass LogMessage : public std::basic_ostringstream<char> {\n public:\n  LogMessage(const char* fname, int line, int severity);\n  ~LogMessage() override;\n\n  // Change the location of the log message.\n  LogMessage& AtLocation(const char* fname, int line);\n\n  // Returns the maximum log level for VLOG statements.\n  // E.g., if MaxVLogLevel() is 2, then VLOG(2) statements will produce output,\n  // but VLOG(3) will not. Defaults to 0.\n  static int64_t MaxVLogLevel();\n\n  // Returns whether VLOG level lvl is activated for the file fname.\n  //\n  // E.g. if the environment variable TF_CPP_VMODULE contains foo=3 and fname is\n  // foo.cc and lvl is <= 3, this will return true. It will also return true if\n  // the level is lower or equal to TF_CPP_MAX_VLOG_LEVEL (default zero).\n  //\n  // It is expected that the result of this query will be cached in the VLOG-ing\n  // call site to avoid repeated lookups. This routine performs a hash-map\n  // access against the VLOG-ing specification provided by the env var.\n  static bool VmoduleActivated(const char* fname, int level);\n\n protected:\n  void GenerateLogMessage();\n\n private:\n  const char* fname_;\n  int line_;\n  int severity_;\n};\n\n// Uses the lower operator & precedence to voidify a LogMessage reference, so\n// that the ternary VLOG() implementation is balanced, type wise.\nstruct Voidifier {\n  template <typename T>\n  void operator&(const T&)const {}\n};\n\n// LogMessageFatal ensures the process will exit in failure after\n// logging this message.\nclass LogMessageFatal : public LogMessage {\n public:\n  LogMessageFatal(const char* file, int line) TF_ATTRIBUTE_COLD;\n  TF_ATTRIBUTE_NORETURN ~LogMessageFatal() override;\n};\n\n// LogMessageNull supports the DVLOG macro by simply dropping any log messages.\nclass LogMessageNull : public std::basic_ostringstream<char> {\n public:\n  LogMessageNull() {}\n  ~LogMessageNull() override {}\n};\n\n#define _TF_LOG_INFO \\\n  ::tensorflow::internal::LogMessage(__FILE__, __LINE__, ::tensorflow::INFO)\n#define _TF_LOG_WARNING \\\n  ::tensorflow::internal::LogMessage(__FILE__, __LINE__, ::tensorflow::WARNING)\n#define _TF_LOG_ERROR \\\n  ::tensorflow::internal::LogMessage(__FILE__, __LINE__, ::tensorflow::ERROR)\n#define _TF_LOG_FATAL \\\n  ::tensorflow::internal::LogMessageFatal(__FILE__, __LINE__)\n\n#define _TF_LOG_QFATAL _TF_LOG_FATAL\n\n#define LOG(severity) _TF_LOG_##severity\n\n#ifdef IS_MOBILE_PLATFORM\n\n// Turn VLOG off when under mobile devices for considerations of binary size.\n#define VLOG_IS_ON(lvl) ((lvl) <= 0)\n\n#else\n\n// Otherwise, set TF_CPP_MAX_VLOG_LEVEL environment to update minimum log level\n// of VLOG, or TF_CPP_VMODULE to set the minimum log level for individual\n// translation units.\n#define VLOG_IS_ON(lvl)                                                     \\\n  (([](int level, const char* fname) {                                      \\\n    static const bool vmodule_activated =                                   \\\n        ::tensorflow::internal::LogMessage::VmoduleActivated(fname, level); \\\n    return vmodule_activated;                                               \\\n  })(lvl, __FILE__))\n\n#endif\n\n#define VLOG(level)                                              \\\n  TF_PREDICT_TRUE(!VLOG_IS_ON(level))                            \\\n  ? (void)0                                                      \\\n  : ::tensorflow::internal::Voidifier() &                        \\\n          ::tensorflow::internal::LogMessage(__FILE__, __LINE__, \\\n                                             tensorflow::INFO)\n\n// `DVLOG` behaves like `VLOG` in debug mode (i.e. `#ifndef NDEBUG`).\n// Otherwise, it compiles away and does nothing.\n#ifndef NDEBUG\n#define DVLOG VLOG\n#else\n#define DVLOG(verbose_level) \\\n  while (false && (verbose_level) > 0) ::tensorflow::internal::LogMessageNull()\n#endif\n\nclass LogEveryNState {\n public:\n  bool ShouldLog(int n);\n  uint32_t counter() { return counter_.load(std::memory_order_relaxed); }\n\n private:\n  std::atomic<uint32> counter_{0};\n};\n\nclass LogFirstNState {\n public:\n  bool ShouldLog(int n);\n  uint32 counter() { return counter_.load(std::memory_order_relaxed); }\n\n private:\n  std::atomic<uint32> counter_{0};\n};\n\nclass LogEveryPow2State {\n public:\n  bool ShouldLog(int ignored);\n  uint32 counter() { return counter_.load(std::memory_order_relaxed); }\n\n private:\n  std::atomic<uint32> counter_{0};\n};\n\nclass LogEveryNSecState {\n public:\n  bool ShouldLog(double seconds);\n  uint32 counter() { return counter_.load(std::memory_order_relaxed); }\n\n private:\n  std::atomic<uint32> counter_{0};\n  // Cycle count according to CycleClock that we should next log at.\n  std::atomic<int64_t> next_log_time_cycles_{0};\n};\n\n// This macro has a lot going on!\n//\n// * A local static (`logging_internal_stateful_condition_state`) is\n//   declared in a scope such that each `LOG_EVERY_N` (etc.) line has its own\n//   state.\n// * `COUNTER`, the third variable, is used to support `<< COUNTER`. It is not\n//   mangled, so shadowing can be a problem, albeit more of a\n//   shoot-yourself-in-the-foot one.  Don't name your variables `COUNTER`.\n// * A single for loop can declare state and also test\n//   `condition && state.ShouldLog()`, but there's no way to constrain it to run\n//   only once (or not at all) without declaring another variable.  The outer\n//   for-loop declares this variable (`do_log`).\n// * Using for loops instead of if statements means there's no risk of an\n//   ambiguous dangling else statement.\n#define LOGGING_INTERNAL_STATEFUL_CONDITION(kind, condition, arg)   \\\n  for (bool logging_internal_stateful_condition_do_log(condition);  \\\n       logging_internal_stateful_condition_do_log;                  \\\n       logging_internal_stateful_condition_do_log = false)          \\\n    for (static ::tensorflow::internal::Log##kind##State            \\\n             logging_internal_stateful_condition_state;             \\\n         logging_internal_stateful_condition_do_log &&              \\\n         logging_internal_stateful_condition_state.ShouldLog(arg);  \\\n         logging_internal_stateful_condition_do_log = false)        \\\n      for (const uint32_t COUNTER ABSL_ATTRIBUTE_UNUSED =           \\\n               logging_internal_stateful_condition_state.counter(); \\\n           logging_internal_stateful_condition_do_log;              \\\n           logging_internal_stateful_condition_do_log = false)\n\n// An instance of `LOG_EVERY_N` increments a hidden zero-initialized counter\n// every time execution passes through it and logs the specified message when\n// the counter's value is a multiple of `n`, doing nothing otherwise.  Each\n// instance has its own counter.  The counter's value can be logged by streaming\n// the symbol `COUNTER`.  `LOG_EVERY_N` is thread-safe.\n// Example:\n//\n//   for (const auto& user : all_users) {\n//     LOG_EVERY_N(INFO, 1000) << \"Processing user #\" << COUNTER;\n//     ProcessUser(user);\n//   }\n#define LOG_EVERY_N(severity, n)                       \\\n  LOGGING_INTERNAL_STATEFUL_CONDITION(EveryN, true, n) \\\n  LOG(severity)\n// `LOG_FIRST_N` behaves like `LOG_EVERY_N` except that the specified message is\n// logged when the counter's value is less than `n`.  `LOG_FIRST_N` is\n// thread-safe.\n#define LOG_FIRST_N(severity, n)                       \\\n  LOGGING_INTERNAL_STATEFUL_CONDITION(FirstN, true, n) \\\n  LOG(severity)\n// `LOG_EVERY_POW_2` behaves like `LOG_EVERY_N` except that the specified\n// message is logged when the counter's value is a power of 2.\n// `LOG_EVERY_POW_2` is thread-safe.\n#define LOG_EVERY_POW_2(severity)                         \\\n  LOGGING_INTERNAL_STATEFUL_CONDITION(EveryPow2, true, 0) \\\n  LOG(severity)\n// An instance of `LOG_EVERY_N_SEC` uses a hidden state variable to log the\n// specified message at most once every `n_seconds`.  A hidden counter of\n// executions (whether a message is logged or not) is also maintained and can be\n// logged by streaming the symbol `COUNTER`.  `LOG_EVERY_N_SEC` is thread-safe.\n// Example:\n//\n//   LOG_EVERY_N_SEC(INFO, 2.5) << \"Got \" << COUNTER << \" cookies so far\";\n#define LOG_EVERY_N_SEC(severity, n_seconds)                      \\\n  LOGGING_INTERNAL_STATEFUL_CONDITION(EveryNSec, true, n_seconds) \\\n  LOG(severity)\n\n// CHECK dies with a fatal error if condition is not true.  It is *not*\n// controlled by NDEBUG, so the check will be executed regardless of\n// compilation mode.  Therefore, it is safe to do things like:\n//    CHECK(fp->Write(x) == 4)\n#define CHECK(condition)              \\\n  if (TF_PREDICT_FALSE(!(condition))) \\\n  LOG(FATAL) << \"Check failed: \" #condition \" \"\n\n// Function is overloaded for integral types to allow static const\n// integrals declared in classes and not defined to be used as arguments to\n// CHECK* macros. It's not encouraged though.\ntemplate <typename T>\ninline const T& GetReferenceableValue(const T& t) {\n  return t;\n}\ninline char GetReferenceableValue(char t) { return t; }\ninline unsigned char GetReferenceableValue(unsigned char t) { return t; }\ninline signed char GetReferenceableValue(signed char t) { return t; }\ninline int16 GetReferenceableValue(int16_t t) { return t; }\ninline uint16 GetReferenceableValue(uint16 t) { return t; }\ninline int GetReferenceableValue(int t) { return t; }\ninline unsigned int GetReferenceableValue(unsigned int t) { return t; }\ninline int64_t GetReferenceableValue(int64_t t) { return t; }\ninline uint64 GetReferenceableValue(uint64 t) { return t; }\n\n// This formats a value for a failing CHECK_XX statement.  Ordinarily,\n// it uses the definition for operator<<, with a few special cases below.\ntemplate <typename T>\ninline void MakeCheckOpValueString(std::ostream* os, const T& v) {\n  (*os) << v;\n}\n\n// Overrides for char types provide readable values for unprintable\n// characters.\ntemplate <>\nvoid MakeCheckOpValueString(std::ostream* os, const char& v);\ntemplate <>\nvoid MakeCheckOpValueString(std::ostream* os, const signed char& v);\ntemplate <>\nvoid MakeCheckOpValueString(std::ostream* os, const unsigned char& v);\n\n#if LANG_CXX11\n// We need an explicit specialization for std::nullptr_t.\ntemplate <>\nvoid MakeCheckOpValueString(std::ostream* os, const std::nullptr_t& v);\n#endif\n\n// A container for a string pointer which can be evaluated to a bool -\n// true iff the pointer is non-NULL.\nstruct CheckOpString {\n  explicit CheckOpString(string* str) : str_(str) {}\n  // No destructor: if str_ is non-NULL, we're about to LOG(FATAL),\n  // so there's no point in cleaning up str_.\n  explicit operator bool() const { return TF_PREDICT_FALSE(str_ != nullptr); }\n  string* str_;\n};\n\n// Build the error message string. Specify no inlining for code size.\ntemplate <typename T1, typename T2>\nstring* MakeCheckOpString(const T1& v1, const T2& v2,\n                          const char* exprtext) TF_ATTRIBUTE_NOINLINE;\n\n// A helper class for formatting \"expr (V1 vs. V2)\" in a CHECK_XX\n// statement.  See MakeCheckOpString for sample usage.  Other\n// approaches were considered: use of a template method (e.g.,\n// base::BuildCheckOpString(exprtext, base::Print<T1>, &v1,\n// base::Print<T2>, &v2), however this approach has complications\n// related to volatile arguments and function-pointer arguments).\nclass CheckOpMessageBuilder {\n public:\n  // Inserts \"exprtext\" and \" (\" to the stream.\n  explicit CheckOpMessageBuilder(const char* exprtext);\n  // Deletes \"stream_\".\n  ~CheckOpMessageBuilder();\n  // For inserting the first variable.\n  std::ostream* ForVar1() { return stream_; }\n  // For inserting the second variable (adds an intermediate \" vs. \").\n  std::ostream* ForVar2();\n  // Get the result (inserts the closing \")\").\n  string* NewString();\n\n private:\n  std::ostringstream* stream_;\n};\n\ntemplate <typename T1, typename T2>\nstring* MakeCheckOpString(const T1& v1, const T2& v2, const char* exprtext) {\n  CheckOpMessageBuilder comb(exprtext);\n  MakeCheckOpValueString(comb.ForVar1(), v1);\n  MakeCheckOpValueString(comb.ForVar2(), v2);\n  return comb.NewString();\n}\n\n// Helper functions for CHECK_OP macro.\n// The (int, int) specialization works around the issue that the compiler\n// will not instantiate the template version of the function on values of\n// unnamed enum type - see comment below.\n// The (size_t, int) and (int, size_t) specialization are to handle unsigned\n// comparison errors while still being thorough with the comparison.\n#define TF_DEFINE_CHECK_OP_IMPL(name, op)                                 \\\n  template <typename T1, typename T2>                                     \\\n  inline string* name##Impl(const T1& v1, const T2& v2,                   \\\n                            const char* exprtext) {                       \\\n    if (TF_PREDICT_TRUE(v1 op v2))                                        \\\n      return NULL;                                                        \\\n    else                                                                  \\\n      return ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext); \\\n  }                                                                       \\\n  inline string* name##Impl(int v1, int v2, const char* exprtext) {       \\\n    return name##Impl<int, int>(v1, v2, exprtext);                        \\\n  }                                                                       \\\n  inline string* name##Impl(const size_t v1, const int v2,                \\\n                            const char* exprtext) {                       \\\n    if (TF_PREDICT_FALSE(v2 < 0)) {                                       \\\n      return ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext); \\\n    }                                                                     \\\n    return name##Impl<size_t, size_t>(v1, v2, exprtext);                  \\\n  }                                                                       \\\n  inline string* name##Impl(const int v1, const size_t v2,                \\\n                            const char* exprtext) {                       \\\n    if (TF_PREDICT_FALSE(v2 >= std::numeric_limits<int>::max())) {        \\\n      return ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext); \\\n    }                                                                     \\\n    const size_t uval = (size_t)((unsigned)v2);                           \\\n    return name##Impl<size_t, size_t>(v1, uval, exprtext);                \\\n  }\n\n// We use the full name Check_EQ, Check_NE, etc. in case the file including\n// base/logging.h provides its own #defines for the simpler names EQ, NE, etc.\n// This happens if, for example, those are used as token names in a\n// yacc grammar.\nTF_DEFINE_CHECK_OP_IMPL(Check_EQ,\n                        ==)  // Compilation error with CHECK_EQ(NULL, x)?\nTF_DEFINE_CHECK_OP_IMPL(Check_NE, !=)  // Use CHECK(x == NULL) instead.\nTF_DEFINE_CHECK_OP_IMPL(Check_LE, <=)\nTF_DEFINE_CHECK_OP_IMPL(Check_LT, <)\nTF_DEFINE_CHECK_OP_IMPL(Check_GE, >=)\nTF_DEFINE_CHECK_OP_IMPL(Check_GT, >)\n#undef TF_DEFINE_CHECK_OP_IMPL\n\n// In optimized mode, use CheckOpString to hint to compiler that\n// the while condition is unlikely.\n#define CHECK_OP_LOG(name, op, val1, val2)                     \\\n  while (::tensorflow::internal::CheckOpString _result{        \\\n      ::tensorflow::internal::name##Impl(                      \\\n          ::tensorflow::internal::GetReferenceableValue(val1), \\\n          ::tensorflow::internal::GetReferenceableValue(val2), \\\n          #val1 \" \" #op \" \" #val2)})                           \\\n  ::tensorflow::internal::LogMessageFatal(__FILE__, __LINE__) << *(_result.str_)\n\n#define CHECK_OP(name, op, val1, val2) CHECK_OP_LOG(name, op, val1, val2)\n\n// CHECK_EQ/NE/...\n#define CHECK_EQ(val1, val2) CHECK_OP(Check_EQ, ==, val1, val2)\n#define CHECK_NE(val1, val2) CHECK_OP(Check_NE, !=, val1, val2)\n#define CHECK_LE(val1, val2) CHECK_OP(Check_LE, <=, val1, val2)\n#define CHECK_LT(val1, val2) CHECK_OP(Check_LT, <, val1, val2)\n#define CHECK_GE(val1, val2) CHECK_OP(Check_GE, >=, val1, val2)\n#define CHECK_GT(val1, val2) CHECK_OP(Check_GT, >, val1, val2)\n#define CHECK_NOTNULL(val)                                 \\\n  ::tensorflow::internal::CheckNotNull(__FILE__, __LINE__, \\\n                                       \"'\" #val \"' Must be non NULL\", (val))\n\n#ifndef NDEBUG\n// DCHECK_EQ/NE/...\n#define DCHECK(condition) CHECK(condition)\n#define DCHECK_EQ(val1, val2) CHECK_EQ(val1, val2)\n#define DCHECK_NE(val1, val2) CHECK_NE(val1, val2)\n#define DCHECK_LE(val1, val2) CHECK_LE(val1, val2)\n#define DCHECK_LT(val1, val2) CHECK_LT(val1, val2)\n#define DCHECK_GE(val1, val2) CHECK_GE(val1, val2)\n#define DCHECK_GT(val1, val2) CHECK_GT(val1, val2)\n\n#else\n\n#define DCHECK(condition) \\\n  while (false && (condition)) LOG(FATAL)\n\n// NDEBUG is defined, so DCHECK_EQ(x, y) and so on do nothing.\n// However, we still want the compiler to parse x and y, because\n// we don't want to lose potentially useful errors and warnings.\n// _DCHECK_NOP is a helper, and should not be used outside of this file.\n#define _TF_DCHECK_NOP(x, y) \\\n  while (false && ((void)(x), (void)(y), 0)) LOG(FATAL)\n\n#define DCHECK_EQ(x, y) _TF_DCHECK_NOP(x, y)\n#define DCHECK_NE(x, y) _TF_DCHECK_NOP(x, y)\n#define DCHECK_LE(x, y) _TF_DCHECK_NOP(x, y)\n#define DCHECK_LT(x, y) _TF_DCHECK_NOP(x, y)\n#define DCHECK_GE(x, y) _TF_DCHECK_NOP(x, y)\n#define DCHECK_GT(x, y) _TF_DCHECK_NOP(x, y)\n\n#endif\n\n// These are for when you don't want a CHECK failure to print a verbose\n// stack trace.  The implementation of CHECK* in this file already doesn't.\n#define QCHECK(condition) CHECK(condition)\n#define QCHECK_EQ(x, y) CHECK_EQ(x, y)\n#define QCHECK_NE(x, y) CHECK_NE(x, y)\n#define QCHECK_LE(x, y) CHECK_LE(x, y)\n#define QCHECK_LT(x, y) CHECK_LT(x, y)\n#define QCHECK_GE(x, y) CHECK_GE(x, y)\n#define QCHECK_GT(x, y) CHECK_GT(x, y)\n\ntemplate <typename T>\nT&& CheckNotNull(const char* file, int line, const char* exprtext, T&& t) {\n  if (t == nullptr) {\n    LogMessageFatal(file, line) << string(exprtext);\n  }\n  return std::forward<T>(t);\n}\n\nint64_t MinLogLevelFromEnv();\n\nint64_t MaxVLogLevelFromEnv();\n\n}  // namespace internal\n\n// LogSink support adapted from //base/logging.h\n//\n// `LogSink` is an interface which can be extended to intercept and process\n// all log messages. LogSink implementations must be thread-safe. A single\n// instance will be called from whichever thread is performing a logging\n// operation.\nclass TFLogEntry {\n  static absl::LogSeverity AsAbslLogSeverity(int severity) {\n    return static_cast<absl::LogSeverity>(severity);\n  }\n\n public:\n  explicit TFLogEntry(int severity, absl::string_view message)\n      : severity_(AsAbslLogSeverity(severity)), message_(message) {}\n\n  explicit TFLogEntry(int severity, absl::string_view fname, int line,\n                      absl::string_view message)\n      : severity_(AsAbslLogSeverity(severity)),\n        fname_(fname),\n        line_(line),\n        message_(message) {}\n\n  absl::LogSeverity log_severity() const { return severity_; }\n  std::string FName() const { return fname_; }\n  int Line() const { return line_; }\n  std::string ToString() const { return message_; }\n  absl::string_view text_message() const { return message_; }\n\n private:\n  const absl::LogSeverity severity_;\n  const std::string fname_;\n  int line_ = -1;\n  const std::string message_;\n};\n\nclass TFLogSink {\n public:\n  virtual ~TFLogSink() = default;\n\n  // `Send` is called synchronously during the log statement.  The logging\n  // module guarantees not to call `Send` concurrently on the same log sink.\n  // Implementations should be careful not to call`LOG` or `CHECK` or take\n  // any locks that might be held by the `LOG` caller, to avoid deadlock.\n  //\n  // `e` is guaranteed to remain valid until the subsequent call to\n  // `WaitTillSent` completes, so implementations may store a pointer to or\n  // copy of `e` (e.g. in a thread local variable) for use in `WaitTillSent`.\n  virtual void Send(const TFLogEntry& entry) = 0;\n\n  // `WaitTillSent` blocks the calling thread (the thread that generated a log\n  // message) until the sink has finished processing the log message.\n  // `WaitTillSent` is called once per log message, following the call to\n  // `Send`.  This may be useful when log messages are buffered or processed\n  // asynchronously by an expensive log sink.\n  // The default implementation returns immediately.  Like `Send`,\n  // implementations should be careful not to call `LOG` or `CHECK or take any\n  // locks that might be held by the `LOG` caller, to avoid deadlock.\n  virtual void WaitTillSent() {}\n};\n\n// This is the default log sink. This log sink is used if there are no other\n// log sinks registered. To disable the default log sink, set the\n// \"no_default_logger\" Bazel config setting to true or define a\n// NO_DEFAULT_LOGGER preprocessor symbol. This log sink will always log to\n// stderr.\nclass TFDefaultLogSink : public TFLogSink {\n public:\n  void Send(const TFLogEntry& entry) override;\n};\n\n// Add or remove a `LogSink` as a consumer of logging data.  Thread-safe.\nvoid TFAddLogSink(TFLogSink* sink);\nvoid TFRemoveLogSink(TFLogSink* sink);\n\n// Get all the log sinks.  Thread-safe.\nstd::vector<TFLogSink*> TFGetLogSinks();\n\n// Change verbose level of pre-defined files if envorionment\n// variable `env_var` is defined. This is currently a no op.\nvoid UpdateLogVerbosityIfDefined(const char* env_var);\n\n}  // namespace tensorflow\n\n#endif  // TENSORFLOW_CORE_PLATFORM_DEFAULT_LOGGING_H_\n"], "fixing_code": ["/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#if defined(_WIN32)\n// prevent compile error because MSVC doesn't realize in debug build that\n// LOG(FATAL) finally invokes abort()\n#pragma warning(disable : 4716)\n#endif  // _WIN32\n\n#ifndef TENSORFLOW_CORE_PLATFORM_DEFAULT_LOGGING_H_\n#define TENSORFLOW_CORE_PLATFORM_DEFAULT_LOGGING_H_\n\n// IWYU pragma: private, include \"third_party/tensorflow/core/platform/logging.h\"\n// IWYU pragma: friend third_party/tensorflow/core/platform/logging.h\n\n#include <atomic>\n#include <limits>\n#include <memory>\n#include <sstream>\n#include <vector>\n\n#include \"absl/base/log_severity.h\"\n#include \"absl/strings/string_view.h\"\n#include \"tensorflow/core/platform/macros.h\"\n#include \"tensorflow/core/platform/types.h\"\n\n// TODO(mrry): Prevent this Windows.h #define from leaking out of our headers.\n#undef ERROR\n\nnamespace tensorflow {\nconst int INFO = 0;            // base_logging::INFO;\nconst int WARNING = 1;         // base_logging::WARNING;\nconst int ERROR = 2;           // base_logging::ERROR;\nconst int FATAL = 3;           // base_logging::FATAL;\nconst int NUM_SEVERITIES = 4;  // base_logging::NUM_SEVERITIES;\n\nnamespace internal {\n\nclass LogMessage : public std::basic_ostringstream<char> {\n public:\n  LogMessage(const char* fname, int line, int severity);\n  ~LogMessage() override;\n\n  // Change the location of the log message.\n  LogMessage& AtLocation(const char* fname, int line);\n\n  // Returns the maximum log level for VLOG statements.\n  // E.g., if MaxVLogLevel() is 2, then VLOG(2) statements will produce output,\n  // but VLOG(3) will not. Defaults to 0.\n  static int64_t MaxVLogLevel();\n\n  // Returns whether VLOG level lvl is activated for the file fname.\n  //\n  // E.g. if the environment variable TF_CPP_VMODULE contains foo=3 and fname is\n  // foo.cc and lvl is <= 3, this will return true. It will also return true if\n  // the level is lower or equal to TF_CPP_MAX_VLOG_LEVEL (default zero).\n  //\n  // It is expected that the result of this query will be cached in the VLOG-ing\n  // call site to avoid repeated lookups. This routine performs a hash-map\n  // access against the VLOG-ing specification provided by the env var.\n  static bool VmoduleActivated(const char* fname, int level);\n\n protected:\n  void GenerateLogMessage();\n\n private:\n  const char* fname_;\n  int line_;\n  int severity_;\n};\n\n// Uses the lower operator & precedence to voidify a LogMessage reference, so\n// that the ternary VLOG() implementation is balanced, type wise.\nstruct Voidifier {\n  template <typename T>\n  void operator&(const T&) const {}\n};\n\n// LogMessageFatal ensures the process will exit in failure after\n// logging this message.\nclass LogMessageFatal : public LogMessage {\n public:\n  LogMessageFatal(const char* file, int line) TF_ATTRIBUTE_COLD;\n  TF_ATTRIBUTE_NORETURN ~LogMessageFatal() override;\n};\n\n// LogMessageNull supports the DVLOG macro by simply dropping any log messages.\nclass LogMessageNull : public std::basic_ostringstream<char> {\n public:\n  LogMessageNull() {}\n  ~LogMessageNull() override {}\n};\n\n#define _TF_LOG_INFO \\\n  ::tensorflow::internal::LogMessage(__FILE__, __LINE__, ::tensorflow::INFO)\n#define _TF_LOG_WARNING \\\n  ::tensorflow::internal::LogMessage(__FILE__, __LINE__, ::tensorflow::WARNING)\n#define _TF_LOG_ERROR \\\n  ::tensorflow::internal::LogMessage(__FILE__, __LINE__, ::tensorflow::ERROR)\n#define _TF_LOG_FATAL \\\n  ::tensorflow::internal::LogMessageFatal(__FILE__, __LINE__)\n\n#define _TF_LOG_QFATAL _TF_LOG_FATAL\n\n#define LOG(severity) _TF_LOG_##severity\n\n#ifdef IS_MOBILE_PLATFORM\n\n// Turn VLOG off when under mobile devices for considerations of binary size.\n#define VLOG_IS_ON(lvl) ((lvl) <= 0)\n\n#else\n\n// Otherwise, set TF_CPP_MAX_VLOG_LEVEL environment to update minimum log level\n// of VLOG, or TF_CPP_VMODULE to set the minimum log level for individual\n// translation units.\n#define VLOG_IS_ON(lvl)                                                     \\\n  (([](int level, const char* fname) {                                      \\\n    static const bool vmodule_activated =                                   \\\n        ::tensorflow::internal::LogMessage::VmoduleActivated(fname, level); \\\n    return vmodule_activated;                                               \\\n  })(lvl, __FILE__))\n\n#endif\n\n#define VLOG(level)                                              \\\n  TF_PREDICT_TRUE(!VLOG_IS_ON(level))                            \\\n  ? (void)0                                                      \\\n  : ::tensorflow::internal::Voidifier() &                        \\\n          ::tensorflow::internal::LogMessage(__FILE__, __LINE__, \\\n                                             tensorflow::INFO)\n\n// `DVLOG` behaves like `VLOG` in debug mode (i.e. `#ifndef NDEBUG`).\n// Otherwise, it compiles away and does nothing.\n#ifndef NDEBUG\n#define DVLOG VLOG\n#else\n#define DVLOG(verbose_level) \\\n  while (false && (verbose_level) > 0) ::tensorflow::internal::LogMessageNull()\n#endif\n\nclass LogEveryNState {\n public:\n  bool ShouldLog(int n);\n  uint32_t counter() { return counter_.load(std::memory_order_relaxed); }\n\n private:\n  std::atomic<uint32> counter_{0};\n};\n\nclass LogFirstNState {\n public:\n  bool ShouldLog(int n);\n  uint32 counter() { return counter_.load(std::memory_order_relaxed); }\n\n private:\n  std::atomic<uint32> counter_{0};\n};\n\nclass LogEveryPow2State {\n public:\n  bool ShouldLog(int ignored);\n  uint32 counter() { return counter_.load(std::memory_order_relaxed); }\n\n private:\n  std::atomic<uint32> counter_{0};\n};\n\nclass LogEveryNSecState {\n public:\n  bool ShouldLog(double seconds);\n  uint32 counter() { return counter_.load(std::memory_order_relaxed); }\n\n private:\n  std::atomic<uint32> counter_{0};\n  // Cycle count according to CycleClock that we should next log at.\n  std::atomic<int64_t> next_log_time_cycles_{0};\n};\n\n// This macro has a lot going on!\n//\n// * A local static (`logging_internal_stateful_condition_state`) is\n//   declared in a scope such that each `LOG_EVERY_N` (etc.) line has its own\n//   state.\n// * `COUNTER`, the third variable, is used to support `<< COUNTER`. It is not\n//   mangled, so shadowing can be a problem, albeit more of a\n//   shoot-yourself-in-the-foot one.  Don't name your variables `COUNTER`.\n// * A single for loop can declare state and also test\n//   `condition && state.ShouldLog()`, but there's no way to constrain it to run\n//   only once (or not at all) without declaring another variable.  The outer\n//   for-loop declares this variable (`do_log`).\n// * Using for loops instead of if statements means there's no risk of an\n//   ambiguous dangling else statement.\n#define LOGGING_INTERNAL_STATEFUL_CONDITION(kind, condition, arg)   \\\n  for (bool logging_internal_stateful_condition_do_log(condition);  \\\n       logging_internal_stateful_condition_do_log;                  \\\n       logging_internal_stateful_condition_do_log = false)          \\\n    for (static ::tensorflow::internal::Log##kind##State            \\\n             logging_internal_stateful_condition_state;             \\\n         logging_internal_stateful_condition_do_log &&              \\\n         logging_internal_stateful_condition_state.ShouldLog(arg);  \\\n         logging_internal_stateful_condition_do_log = false)        \\\n      for (const uint32_t COUNTER ABSL_ATTRIBUTE_UNUSED =           \\\n               logging_internal_stateful_condition_state.counter(); \\\n           logging_internal_stateful_condition_do_log;              \\\n           logging_internal_stateful_condition_do_log = false)\n\n// An instance of `LOG_EVERY_N` increments a hidden zero-initialized counter\n// every time execution passes through it and logs the specified message when\n// the counter's value is a multiple of `n`, doing nothing otherwise.  Each\n// instance has its own counter.  The counter's value can be logged by streaming\n// the symbol `COUNTER`.  `LOG_EVERY_N` is thread-safe.\n// Example:\n//\n//   for (const auto& user : all_users) {\n//     LOG_EVERY_N(INFO, 1000) << \"Processing user #\" << COUNTER;\n//     ProcessUser(user);\n//   }\n#define LOG_EVERY_N(severity, n)                       \\\n  LOGGING_INTERNAL_STATEFUL_CONDITION(EveryN, true, n) \\\n  LOG(severity)\n// `LOG_FIRST_N` behaves like `LOG_EVERY_N` except that the specified message is\n// logged when the counter's value is less than `n`.  `LOG_FIRST_N` is\n// thread-safe.\n#define LOG_FIRST_N(severity, n)                       \\\n  LOGGING_INTERNAL_STATEFUL_CONDITION(FirstN, true, n) \\\n  LOG(severity)\n// `LOG_EVERY_POW_2` behaves like `LOG_EVERY_N` except that the specified\n// message is logged when the counter's value is a power of 2.\n// `LOG_EVERY_POW_2` is thread-safe.\n#define LOG_EVERY_POW_2(severity)                         \\\n  LOGGING_INTERNAL_STATEFUL_CONDITION(EveryPow2, true, 0) \\\n  LOG(severity)\n// An instance of `LOG_EVERY_N_SEC` uses a hidden state variable to log the\n// specified message at most once every `n_seconds`.  A hidden counter of\n// executions (whether a message is logged or not) is also maintained and can be\n// logged by streaming the symbol `COUNTER`.  `LOG_EVERY_N_SEC` is thread-safe.\n// Example:\n//\n//   LOG_EVERY_N_SEC(INFO, 2.5) << \"Got \" << COUNTER << \" cookies so far\";\n#define LOG_EVERY_N_SEC(severity, n_seconds)                      \\\n  LOGGING_INTERNAL_STATEFUL_CONDITION(EveryNSec, true, n_seconds) \\\n  LOG(severity)\n\n// CHECK dies with a fatal error if condition is not true.  It is *not*\n// controlled by NDEBUG, so the check will be executed regardless of\n// compilation mode.  Therefore, it is safe to do things like:\n//    CHECK(fp->Write(x) == 4)\n#define CHECK(condition)              \\\n  if (TF_PREDICT_FALSE(!(condition))) \\\n  LOG(FATAL) << \"Check failed: \" #condition \" \"\n\n// Function is overloaded for integral types to allow static const\n// integrals declared in classes and not defined to be used as arguments to\n// CHECK* macros. It's not encouraged though.\ntemplate <typename T>\ninline const T& GetReferenceableValue(const T& t) {\n  return t;\n}\ninline char GetReferenceableValue(char t) { return t; }\ninline unsigned char GetReferenceableValue(unsigned char t) { return t; }\ninline signed char GetReferenceableValue(signed char t) { return t; }\ninline int16 GetReferenceableValue(int16_t t) { return t; }\ninline uint16 GetReferenceableValue(uint16 t) { return t; }\ninline int GetReferenceableValue(int t) { return t; }\ninline unsigned int GetReferenceableValue(unsigned int t) { return t; }\ninline int64_t GetReferenceableValue(int64_t t) { return t; }\ninline uint64 GetReferenceableValue(uint64 t) { return t; }\n\n// This formats a value for a failing CHECK_XX statement.  Ordinarily,\n// it uses the definition for operator<<, with a few special cases below.\ntemplate <typename T>\ninline void MakeCheckOpValueString(std::ostream* os, const T& v) {\n  (*os) << v;\n}\n\n// Overrides for char types provide readable values for unprintable\n// characters.\ntemplate <>\nvoid MakeCheckOpValueString(std::ostream* os, const char& v);\ntemplate <>\nvoid MakeCheckOpValueString(std::ostream* os, const signed char& v);\ntemplate <>\nvoid MakeCheckOpValueString(std::ostream* os, const unsigned char& v);\n\n#if LANG_CXX11\n// We need an explicit specialization for std::nullptr_t.\ntemplate <>\nvoid MakeCheckOpValueString(std::ostream* os, const std::nullptr_t& v);\n#endif\n\n// A container for a string pointer which can be evaluated to a bool -\n// true iff the pointer is non-NULL.\nstruct CheckOpString {\n  explicit CheckOpString(string* str) : str_(str) {}\n  // No destructor: if str_ is non-NULL, we're about to LOG(FATAL),\n  // so there's no point in cleaning up str_.\n  explicit operator bool() const { return TF_PREDICT_FALSE(str_ != nullptr); }\n  string* str_;\n};\n\n// Build the error message string. Specify no inlining for code size.\ntemplate <typename T1, typename T2>\nstring* MakeCheckOpString(const T1& v1, const T2& v2,\n                          const char* exprtext) TF_ATTRIBUTE_NOINLINE;\n\n// A helper class for formatting \"expr (V1 vs. V2)\" in a CHECK_XX\n// statement.  See MakeCheckOpString for sample usage.  Other\n// approaches were considered: use of a template method (e.g.,\n// base::BuildCheckOpString(exprtext, base::Print<T1>, &v1,\n// base::Print<T2>, &v2), however this approach has complications\n// related to volatile arguments and function-pointer arguments).\nclass CheckOpMessageBuilder {\n public:\n  // Inserts \"exprtext\" and \" (\" to the stream.\n  explicit CheckOpMessageBuilder(const char* exprtext);\n  // Deletes \"stream_\".\n  ~CheckOpMessageBuilder();\n  // For inserting the first variable.\n  std::ostream* ForVar1() { return stream_; }\n  // For inserting the second variable (adds an intermediate \" vs. \").\n  std::ostream* ForVar2();\n  // Get the result (inserts the closing \")\").\n  string* NewString();\n\n private:\n  std::ostringstream* stream_;\n};\n\ntemplate <typename T1, typename T2>\nstring* MakeCheckOpString(const T1& v1, const T2& v2, const char* exprtext) {\n  CheckOpMessageBuilder comb(exprtext);\n  MakeCheckOpValueString(comb.ForVar1(), v1);\n  MakeCheckOpValueString(comb.ForVar2(), v2);\n  return comb.NewString();\n}\n\n// Helper functions for CHECK_OP macro.\n// We use the full name Check_EQ, Check_NE, etc. in case the file including\n// base/logging.h provides its own #defines for the simpler names EQ, NE, etc.\n// This happens if, for example, those are used as token names in a\n// yacc grammar.\n// The (int, int) overload works around the issue that the compiler\n// will not instantiate the template version of the function on values of\n// unnamed enum type - see comment below.\n#define TF_DEFINE_CHECK_OP_IMPL(name, op)                                 \\\n  template <typename T1, typename T2>                                     \\\n  inline string* name##Impl(const T1& v1, const T2& v2,                   \\\n                            const char* exprtext) {                       \\\n    if (TF_PREDICT_TRUE(v1 op v2))                                        \\\n      return NULL;                                                        \\\n    else                                                                  \\\n      return ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext); \\\n  }                                                                       \\\n  inline string* name##Impl(int v1, int v2, const char* exprtext) {       \\\n    return name##Impl<int, int>(v1, v2, exprtext);                        \\\n  }\n\n// The (size_t, int) and (int, size_t) specialization are to handle unsigned\n// comparison errors while still being thorough with the comparison.\n\nTF_DEFINE_CHECK_OP_IMPL(Check_EQ, ==)\n// Compilation error with CHECK_EQ(NULL, x)?\n// Use CHECK(x == NULL) instead.\n\ninline string* Check_EQImpl(int v1, size_t v2, const char* exprtext) {\n  if (TF_PREDICT_FALSE(v1 < 0))\n    ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext);\n\n  return Check_EQImpl(size_t(v1), v2, exprtext);\n}\n\ninline string* Check_EQImpl(size_t v1, int v2, const char* exprtext) {\n  return Check_EQImpl(v2, v1, exprtext);\n}\n\nTF_DEFINE_CHECK_OP_IMPL(Check_NE, !=)\n\ninline string* Check_NEImpl(int v1, size_t v2, const char* exprtext) {\n  if (v1 < 0) return NULL;\n\n  return Check_NEImpl(size_t(v1), v2, exprtext);\n}\n\ninline string* Check_NEImpl(size_t v1, int v2, const char* exprtext) {\n  return Check_NEImpl(v2, v1, exprtext);\n}\n\nTF_DEFINE_CHECK_OP_IMPL(Check_LE, <=)\n\ninline string* Check_LEImpl(int v1, size_t v2, const char* exprtext) {\n  if (v1 <= 0) return NULL;\n\n  return Check_LEImpl(size_t(v1), v2, exprtext);\n}\n\ninline string* Check_LEImpl(size_t v1, int v2, const char* exprtext) {\n  if (TF_PREDICT_FALSE(v2 < 0))\n    return ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext);\n  return Check_LEImpl(v1, size_t(v2), exprtext);\n}\n\nTF_DEFINE_CHECK_OP_IMPL(Check_LT, <)\n\ninline string* Check_LTImpl(int v1, size_t v2, const char* exprtext) {\n  if (v1 < 0) return NULL;\n\n  return Check_LTImpl(size_t(v1), v2, exprtext);\n}\n\ninline string* Check_LTImpl(size_t v1, int v2, const char* exprtext) {\n  if (v2 < 0)\n    return ::tensorflow::internal::MakeCheckOpString(v1, v2, exprtext);\n  return Check_LTImpl(v1, size_t(v2), exprtext);\n}\n\n// Implement GE,GT in terms of LE,LT\ntemplate <typename T1, typename T2>\ninline string* Check_GEImpl(const T1& v1, const T2& v2, const char* exprtext) {\n  return Check_LEImpl(v2, v1, exprtext);\n}\n\ntemplate <typename T1, typename T2>\ninline string* Check_GTImpl(const T1& v1, const T2& v2, const char* exprtext) {\n  return Check_LTImpl(v2, v1, exprtext);\n}\n\n#undef TF_DEFINE_CHECK_OP_IMPL\n\n// In optimized mode, use CheckOpString to hint to compiler that\n// the while condition is unlikely.\n#define CHECK_OP_LOG(name, op, val1, val2)                     \\\n  while (::tensorflow::internal::CheckOpString _result{        \\\n      ::tensorflow::internal::name##Impl(                      \\\n          ::tensorflow::internal::GetReferenceableValue(val1), \\\n          ::tensorflow::internal::GetReferenceableValue(val2), \\\n          #val1 \" \" #op \" \" #val2)})                           \\\n  ::tensorflow::internal::LogMessageFatal(__FILE__, __LINE__) << *(_result.str_)\n\n#define CHECK_OP(name, op, val1, val2) CHECK_OP_LOG(name, op, val1, val2)\n\n// CHECK_EQ/NE/...\n#define CHECK_EQ(val1, val2) CHECK_OP(Check_EQ, ==, val1, val2)\n#define CHECK_NE(val1, val2) CHECK_OP(Check_NE, !=, val1, val2)\n#define CHECK_LE(val1, val2) CHECK_OP(Check_LE, <=, val1, val2)\n#define CHECK_LT(val1, val2) CHECK_OP(Check_LT, <, val1, val2)\n#define CHECK_GE(val1, val2) CHECK_OP(Check_GE, >=, val1, val2)\n#define CHECK_GT(val1, val2) CHECK_OP(Check_GT, >, val1, val2)\n#define CHECK_NOTNULL(val)                                 \\\n  ::tensorflow::internal::CheckNotNull(__FILE__, __LINE__, \\\n                                       \"'\" #val \"' Must be non NULL\", (val))\n\n#ifndef NDEBUG\n// DCHECK_EQ/NE/...\n#define DCHECK(condition) CHECK(condition)\n#define DCHECK_EQ(val1, val2) CHECK_EQ(val1, val2)\n#define DCHECK_NE(val1, val2) CHECK_NE(val1, val2)\n#define DCHECK_LE(val1, val2) CHECK_LE(val1, val2)\n#define DCHECK_LT(val1, val2) CHECK_LT(val1, val2)\n#define DCHECK_GE(val1, val2) CHECK_GE(val1, val2)\n#define DCHECK_GT(val1, val2) CHECK_GT(val1, val2)\n\n#else\n\n#define DCHECK(condition) \\\n  while (false && (condition)) LOG(FATAL)\n\n// NDEBUG is defined, so DCHECK_EQ(x, y) and so on do nothing.\n// However, we still want the compiler to parse x and y, because\n// we don't want to lose potentially useful errors and warnings.\n// _DCHECK_NOP is a helper, and should not be used outside of this file.\n#define _TF_DCHECK_NOP(x, y) \\\n  while (false && ((void)(x), (void)(y), 0)) LOG(FATAL)\n\n#define DCHECK_EQ(x, y) _TF_DCHECK_NOP(x, y)\n#define DCHECK_NE(x, y) _TF_DCHECK_NOP(x, y)\n#define DCHECK_LE(x, y) _TF_DCHECK_NOP(x, y)\n#define DCHECK_LT(x, y) _TF_DCHECK_NOP(x, y)\n#define DCHECK_GE(x, y) _TF_DCHECK_NOP(x, y)\n#define DCHECK_GT(x, y) _TF_DCHECK_NOP(x, y)\n\n#endif\n\n// These are for when you don't want a CHECK failure to print a verbose\n// stack trace.  The implementation of CHECK* in this file already doesn't.\n#define QCHECK(condition) CHECK(condition)\n#define QCHECK_EQ(x, y) CHECK_EQ(x, y)\n#define QCHECK_NE(x, y) CHECK_NE(x, y)\n#define QCHECK_LE(x, y) CHECK_LE(x, y)\n#define QCHECK_LT(x, y) CHECK_LT(x, y)\n#define QCHECK_GE(x, y) CHECK_GE(x, y)\n#define QCHECK_GT(x, y) CHECK_GT(x, y)\n\ntemplate <typename T>\nT&& CheckNotNull(const char* file, int line, const char* exprtext, T&& t) {\n  if (t == nullptr) {\n    LogMessageFatal(file, line) << string(exprtext);\n  }\n  return std::forward<T>(t);\n}\n\nint64_t MinLogLevelFromEnv();\n\nint64_t MaxVLogLevelFromEnv();\n\n}  // namespace internal\n\n// LogSink support adapted from //base/logging.h\n//\n// `LogSink` is an interface which can be extended to intercept and process\n// all log messages. LogSink implementations must be thread-safe. A single\n// instance will be called from whichever thread is performing a logging\n// operation.\nclass TFLogEntry {\n  static absl::LogSeverity AsAbslLogSeverity(int severity) {\n    return static_cast<absl::LogSeverity>(severity);\n  }\n\n public:\n  explicit TFLogEntry(int severity, absl::string_view message)\n      : severity_(AsAbslLogSeverity(severity)), message_(message) {}\n\n  explicit TFLogEntry(int severity, absl::string_view fname, int line,\n                      absl::string_view message)\n      : severity_(AsAbslLogSeverity(severity)),\n        fname_(fname),\n        line_(line),\n        message_(message) {}\n\n  absl::LogSeverity log_severity() const { return severity_; }\n  std::string FName() const { return fname_; }\n  int Line() const { return line_; }\n  std::string ToString() const { return message_; }\n  absl::string_view text_message() const { return message_; }\n\n private:\n  const absl::LogSeverity severity_;\n  const std::string fname_;\n  int line_ = -1;\n  const std::string message_;\n};\n\nclass TFLogSink {\n public:\n  virtual ~TFLogSink() = default;\n\n  // `Send` is called synchronously during the log statement.  The logging\n  // module guarantees not to call `Send` concurrently on the same log sink.\n  // Implementations should be careful not to call`LOG` or `CHECK` or take\n  // any locks that might be held by the `LOG` caller, to avoid deadlock.\n  //\n  // `e` is guaranteed to remain valid until the subsequent call to\n  // `WaitTillSent` completes, so implementations may store a pointer to or\n  // copy of `e` (e.g. in a thread local variable) for use in `WaitTillSent`.\n  virtual void Send(const TFLogEntry& entry) = 0;\n\n  // `WaitTillSent` blocks the calling thread (the thread that generated a log\n  // message) until the sink has finished processing the log message.\n  // `WaitTillSent` is called once per log message, following the call to\n  // `Send`.  This may be useful when log messages are buffered or processed\n  // asynchronously by an expensive log sink.\n  // The default implementation returns immediately.  Like `Send`,\n  // implementations should be careful not to call `LOG` or `CHECK or take any\n  // locks that might be held by the `LOG` caller, to avoid deadlock.\n  virtual void WaitTillSent() {}\n};\n\n// This is the default log sink. This log sink is used if there are no other\n// log sinks registered. To disable the default log sink, set the\n// \"no_default_logger\" Bazel config setting to true or define a\n// NO_DEFAULT_LOGGER preprocessor symbol. This log sink will always log to\n// stderr.\nclass TFDefaultLogSink : public TFLogSink {\n public:\n  void Send(const TFLogEntry& entry) override;\n};\n\n// Add or remove a `LogSink` as a consumer of logging data.  Thread-safe.\nvoid TFAddLogSink(TFLogSink* sink);\nvoid TFRemoveLogSink(TFLogSink* sink);\n\n// Get all the log sinks.  Thread-safe.\nstd::vector<TFLogSink*> TFGetLogSinks();\n\n// Change verbose level of pre-defined files if envorionment\n// variable `env_var` is defined. This is currently a no op.\nvoid UpdateLogVerbosityIfDefined(const char* env_var);\n\n}  // namespace tensorflow\n\n#endif  // TENSORFLOW_CORE_PLATFORM_DEFAULT_LOGGING_H_\n"], "filenames": ["tensorflow/core/platform/default/logging.h"], "buggy_code_start_loc": [88], "buggy_code_end_loc": [395], "fixing_code_start_loc": [88], "fixing_code_end_loc": [440], "type": "CWE-843", "message": "TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the macros that TensorFlow uses for writing assertions (e.g., `CHECK_LT`, `CHECK_GT`, etc.) have an incorrect logic when comparing `size_t` and `int` values. Due to type conversion rules, several of the macros would trigger incorrectly. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue.", "other": {"cve": {"id": "CVE-2022-29209", "sourceIdentifier": "security-advisories@github.com", "published": "2022-05-21T00:15:11.517", "lastModified": "2022-06-03T02:14:54.750", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the macros that TensorFlow uses for writing assertions (e.g., `CHECK_LT`, `CHECK_GT`, etc.) have an incorrect logic when comparing `size_t` and `int` values. Due to type conversion rules, several of the macros would trigger incorrectly. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto para el aprendizaje autom\u00e1tico. En versiones anteriores a 2.9.0, 2.8.1, 2.7.2 y 2.6.4, las macros que TensorFlow usa para escribir aserciones (por ejemplo, \"CHECK_LT\", \"CHECK_GT\", etc.) presentan una l\u00f3gica incorrecta cuando comparan valores \"size_t\" e \"int\". Debido a las reglas de conversi\u00f3n de tipos, varias de las macros eran desencadenadas incorrectamente. Las versiones 2.9.0, 2.8.1, 2.7.2 y 2.6.4 contienen un parche para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-843"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.6.4", "matchCriteriaId": "D9359D32-D090-44CF-AC43-2046084A28BB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.7.0", "versionEndExcluding": "2.7.2", "matchCriteriaId": "C4DFBF2D-5283-42F6-8800-D653BFA5CE82"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.7.0:rc0:*:*:*:*:*:*", "matchCriteriaId": "A58EDA5C-66D6-46F1-962E-60AFB7C784A7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.7.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "89522760-C2DF-400D-9624-626D8F160CBA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.8.0:-:*:*:*:*:*:*", "matchCriteriaId": "E9EA1898-ACAA-4699-8BAE-54D62C1819FB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.8.0:rc0:*:*:*:*:*:*", "matchCriteriaId": "130DE3C9-6842-456F-A259-BF8FF8457217"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.8.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "BBF2FCEF-989C-409D-9F4C-81418C65B972"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.9.0:rc0:*:*:*:*:*:*", "matchCriteriaId": "9CFB1CFC-579D-4647-A472-6DE8BE1951DE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.9.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "F3F3F37E-D27F-4060-830C-0AFF16150777"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/blob/f3b9bf4c3c0597563b289c0512e98d4ce81f886e/tensorflow/core/platform/default/logging.h", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/commit/b917181c29b50cb83399ba41f4d938dc369109a1", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/issues/55530", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/pull/55730", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/releases/tag/v2.6.4", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/releases/tag/v2.7.2", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/releases/tag/v2.8.1", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/releases/tag/v2.9.0", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-f4rr-5m7v-wxcw", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/b917181c29b50cb83399ba41f4d938dc369109a1"}}