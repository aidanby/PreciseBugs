{"buggy_code": ["/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Updated:    6/24/19 5:32 PM\n *  Copyright (c) 2014-2019 Trudesk, Inc. All rights reserved.\n */\n\nimport React, { Fragment } from 'react'\nimport PropTypes from 'prop-types'\nimport { connect } from 'react-redux'\nimport { observer } from 'mobx-react'\nimport { makeObservable, observable } from 'mobx'\n\nimport Avatar from 'components/Avatar/Avatar'\nimport ReactHtmlParser from 'react-html-parser'\n\nimport helpers from 'lib/helpers'\nimport socket from 'lib/socket'\nimport axios from 'axios'\nimport Log from '../../logger'\n\nconst setupImages = parent => {\n  const imagesEl = parent.issueBody.querySelectorAll('img:not(.hasLinked)')\n  imagesEl.forEach(i => helpers.setupImageLink(i))\n}\n\nconst setupLinks = parent => {\n  const linksEl = parent.issueBody.querySelectorAll('a')\n  linksEl.forEach(i => helpers.setupLinkWarning(i))\n}\n\n@observer\nclass IssuePartial extends React.Component {\n  @observable ticketId = ''\n  @observable status = null\n  @observable owner = null\n  @observable subject = ''\n  @observable issue = ''\n  @observable attachments = []\n\n  constructor (props) {\n    super(props)\n    makeObservable(this)\n\n    this.ticketId = this.props.ticketId\n    this.status = this.props.status\n    this.owner = this.props.owner\n    this.subject = this.props.subject\n    this.issue = this.props.issue\n    this.attachments = this.props.attachments\n\n    this.onUpdateTicketIssue = this.onUpdateTicketIssue.bind(this)\n    this.onUpdateTicketAttachments = this.onUpdateTicketAttachments.bind(this)\n  }\n\n  componentDidMount () {\n    setupImages(this)\n    setupLinks(this)\n\n    socket.socket.on('updateTicketIssue', this.onUpdateTicketIssue)\n    socket.socket.on('updateTicketAttachments', this.onUpdateTicketAttachments)\n  }\n\n  componentDidUpdate (prevProps) {\n    if (prevProps.ticketId !== this.props.ticketId) this.ticketId = this.props.ticketId\n    if (prevProps.status !== this.props.status) this.status = this.props.status\n    if (prevProps.owner !== this.props.owner) this.owner = this.props.owner\n    if (prevProps.subject !== this.props.subject) this.subject = this.props.subject\n    if (prevProps.issue !== this.props.issue) this.issue = this.props.issue\n    if (prevProps.attachments !== this.props.attachments) this.attachments = this.props.attachments\n  }\n\n  componentWillUnmount () {\n    socket.socket.off('updateTicketIssue', this.onUpdateTicketIssue)\n    socket.socket.off('updateTicketAttachments', this.onUpdateTicketAttachments)\n  }\n\n  onUpdateTicketIssue (data) {\n    if (this.ticketId === data._id) {\n      this.subject = data.subject\n      this.issue = data.issue\n    }\n  }\n\n  onUpdateTicketAttachments (data) {\n    if (this.ticketId === data.ticket._id) {\n      this.attachments = data.ticket.attachments\n    }\n  }\n\n  onAttachmentInputChange (e) {\n    const formData = new FormData()\n    const attachmentFile = e.target.files[0]\n    formData.append('ticketId', this.ticketId)\n    formData.append('attachment', attachmentFile)\n    axios\n      .post(`/tickets/uploadattachment`, formData, {\n        headers: {\n          'Content-Type': 'multipart/form-data'\n        }\n      })\n      .then(() => {\n        socket.ui.refreshTicketAttachments(this.ticketId)\n        helpers.UI.showSnackbar('Attachment Successfully Uploaded')\n      })\n      .catch(error => {\n        Log.error(error)\n        if (error.response) Log.error(error.response)\n        helpers.UI.showSnackbar(error, true)\n      })\n  }\n\n  removeAttachment (e, attachmentId) {\n    axios\n      .delete(`/api/v1/tickets/${this.ticketId}/attachments/remove/${attachmentId}`)\n      .then(() => {\n        socket.ui.refreshTicketAttachments(this.ticketId)\n        helpers.UI.showSnackbar('Attachment Removed')\n      })\n      .catch(error => {\n        Log.error(error)\n        if (error.response) Log.error(error.response)\n        helpers.UI.showSnackbar(error, true)\n      })\n  }\n\n  render () {\n    return (\n      <div className='initial-issue uk-clearfix'>\n        <Avatar image={this.owner.image} userId={this.owner._id} />\n        {/* Issue */}\n        <div className='issue-text'>\n          <h3 className='subject-text'>{this.subject}</h3>\n          <a href={`mailto:${this.owner.email}`}>\n            {this.owner.fullname} &lt;{this.owner.email}&gt;\n          </a>\n          <br />\n          <time dateTime={helpers.formatDate(this.props.date, 'YYYY-MM-DD HH:mm')}>\n            {helpers.formatDate(this.props.date, this.props.dateFormat)}\n          </time>\n          <br />\n          {/* Attachments */}\n          <ul className='attachments'>\n            {this.attachments &&\n              this.attachments.map(attachment => (\n                <li key={attachment._id}>\n                  <a href={attachment.path} className='no-ajaxy' rel='noopener noreferrer' target='_blank'>\n                    {attachment.name}\n                  </a>\n                  {this.status !== 3 && (\n                    <a\n                      role='button'\n                      className={'remove-attachment'}\n                      onClick={e => this.removeAttachment(e, attachment._id)}\n                    >\n                      <i className='fa fa-remove' />\n                    </a>\n                  )}\n                </li>\n              ))}\n          </ul>\n          <div className='issue-body' ref={r => (this.issueBody = r)}>\n            {ReactHtmlParser(this.issue)}\n          </div>\n        </div>\n        {/* Permissions on Fragment for edit */}\n        {this.status !== 3 && helpers.hasPermOverRole(this.props.owner.role, null, 'tickets:update', true) && (\n          <Fragment>\n            <div\n              className={'edit-issue'}\n              onClick={() => {\n                if (this.props.editorWindow)\n                  this.props.editorWindow.openEditorWindow({\n                    subject: this.subject,\n                    text: this.issue,\n                    onPrimaryClick: data => {\n                      socket.ui.setTicketIssue(this.ticketId, data.text, data.subjectText)\n                    }\n                  })\n              }}\n            >\n              <i className='material-icons'>&#xE254;</i>\n            </div>\n            <form className='form nomargin' encType='multipart/form-data'>\n              <div className='add-attachment' onClick={e => this.attachmentInput.click()}>\n                <i className='material-icons'>&#xE226;</i>\n              </div>\n\n              <input\n                ref={r => (this.attachmentInput = r)}\n                className='hide'\n                type='file'\n                onChange={e => this.onAttachmentInputChange(e)}\n              />\n            </form>\n          </Fragment>\n        )}\n      </div>\n    )\n  }\n}\n\nIssuePartial.propTypes = {\n  ticketId: PropTypes.string.isRequired,\n  status: PropTypes.number.isRequired,\n  owner: PropTypes.object.isRequired,\n  subject: PropTypes.string.isRequired,\n  issue: PropTypes.string.isRequired,\n  date: PropTypes.string.isRequired,\n  dateFormat: PropTypes.string.isRequired,\n  attachments: PropTypes.array,\n  editorWindow: PropTypes.object\n}\n\nexport default IssuePartial\n", "/*\n      .                              .o8                     oooo\n   .o8                             \"888                     `888\n .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n   888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n   888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n   888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n   \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n ========================================================================\n **/\n\nconst ticketSchema = require('../models/ticket')\nconst async = require('async')\nconst path = require('path')\nconst _ = require('lodash')\nconst winston = require('../logger')\nconst groupSchema = require('../models/group')\nconst departmentSchema = require('../models/department')\nconst permissions = require('../permissions')\nconst xss = require('xss')\nconst fs = require('fs-extra')\n/**\n * @since 1.0\n * @author Chris Brame <polonel@gmail.com>\n * @copyright 2015 Chris Brame\n **/\n\n/**\n * @namespace\n * @description Controller for each Ticket View\n * @requires {@link Ticket}\n * @requires {@link Group}\n * @requires {@link TicketType}\n * @requires {@link Emitter}\n *\n */\nconst ticketsController = {}\n\n/**\n * @name ticketsController.content\n * @description Main Content sent to the view\n */\nticketsController.content = {}\n\nticketsController.pubNewIssue = function (req, res) {\n  const marked = require('marked')\n  const settings = require('../models/setting')\n  settings.getSettingByName('allowPublicTickets:enable', function (err, setting) {\n    if (err) return handleError(res, err)\n    if (setting && setting.value === true) {\n      settings.getSettingByName('legal:privacypolicy', function (err, privacyPolicy) {\n        if (err) return handleError(res, err)\n\n        const content = {}\n        content.title = 'New Issue'\n        content.layout = false\n        content.data = {}\n        if (privacyPolicy === null || _.isUndefined(privacyPolicy.value)) {\n          content.data.privacyPolicy = 'No Privacy Policy has been set.'\n        } else {\n          content.data.privacyPolicy = xss(marked.parse(privacyPolicy.value))\n        }\n\n        return res.render('pub_createTicket', content)\n      })\n    } else {\n      return res.redirect('/')\n    }\n  })\n}\n\n/**\n * Get Ticket View based on ticket status\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @param {function} next Sends the ```req.processor``` object to the processor\n * @see Ticket\n */\nticketsController.getByStatus = function (req, res, next) {\n  const url = require('url')\n  let page = req.params.page\n  if (_.isUndefined(page)) page = 0\n\n  const processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.subnav = 'tickets-'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'active'\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: []\n  }\n\n  const fullUrl = url.format({\n    protocol: req.protocol,\n    host: req.get('host'),\n    pathname: req.originalUrl\n  })\n\n  const pathname = new url.URL(fullUrl).pathname\n  const arr = pathname.split('/')\n  let tType = 'new'\n  let s = 0\n  if (_.size(arr) > 2) tType = arr[2]\n\n  switch (tType) {\n    case 'open':\n      s = 1\n      break\n    case 'pending':\n      s = 2\n      break\n    case 'closed':\n      s = 3\n      break\n  }\n\n  processor.subnav += tType\n  processor.pagetype = tType\n  processor.object.status.push(s)\n\n  req.processor = processor\n  return next()\n}\n\n/**\n * Get Ticket View based on ticket active tickets\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @param {function} next Sends the ```req.processor``` object to the processor\n * @see Ticket\n */\nticketsController.getActive = function (req, res, next) {\n  let page = req.params.page\n  if (_.isUndefined(page)) page = 0\n\n  const processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.subnav = 'tickets-active'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'active'\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: [0, 1, 2]\n  }\n\n  req.processor = processor\n\n  return next()\n}\n\n/**\n * Get Ticket View based on tickets assigned to a given user\n * _calls ```next()``` to send to processor_\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @param {callback} next Sends the ```req.processor``` object to the processor\n * @see Ticket\n */\nticketsController.getAssigned = function (req, res, next) {\n  let page = req.params.page\n  if (_.isUndefined(page)) page = 0\n\n  const processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.subnav = 'tickets-assigned'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'assigned'\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: [0, 1, 2],\n    assignedSelf: true,\n    user: req.user._id\n  }\n\n  req.processor = processor\n\n  return next()\n}\n\n/**\n * Get Ticket View based on tickets assigned to a given user\n * _calls ```next()``` to send to processor_\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @param {callback} next Sends the ```req.processor``` object to the processor\n * @see Ticket\n */\nticketsController.getUnassigned = function (req, res, next) {\n  let page = req.params.page\n  if (_.isUndefined(page)) page = 0\n\n  const processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.subnav = 'tickets-unassigned'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'unassigned'\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: [0, 1, 2],\n    unassigned: true,\n    user: req.user._id\n  }\n\n  req.processor = processor\n\n  return next()\n}\n\nticketsController.filter = function (req, res, next) {\n  let page = req.query.page\n  if (_.isUndefined(page)) page = 0\n\n  const queryString = req.query\n  const uid = queryString.uid\n  const subject = queryString.fs\n  const issue = queryString.it\n  const dateStart = queryString.ds\n  const dateEnd = queryString.de\n  let status = queryString.st\n  let priority = queryString.pr\n  let groups = queryString.gp\n  let types = queryString.tt\n  let tags = queryString.tag\n  let assignee = queryString.au\n\n  const rawNoPage = req.originalUrl.replace(/[?&]page=[^&#]*(#.*)?$/, '$1').replace(/([?&])page=[^&]*&/, '$1')\n\n  if (!_.isUndefined(status)) status = xss(status)\n  if (!_.isUndefined(status) && !_.isArray(status)) status = [status]\n  if (!_.isUndefined(priority)) priority = xss(priority)\n  if (!_.isUndefined(priority) && !_.isArray(priority)) priority = [priority]\n  if (!_.isUndefined(groups)) groups = xss(groups)\n  if (!_.isUndefined(groups) && !_.isArray(groups)) groups = [groups]\n  if (!_.isUndefined(types)) types = xss(types)\n  if (!_.isUndefined(types) && !_.isArray(types)) types = [types]\n  if (!_.isUndefined(tags)) tags = xss(tags)\n  if (!_.isUndefined(tags) && !_.isArray(tags)) tags = [tags]\n  if (!_.isUndefined(assignee)) assignee = xss(assignee)\n  if (!_.isUndefined(assignee) && !_.isArray(assignee)) assignee = [assignee]\n\n  const filter = {\n    uid: uid,\n    subject: xss(subject),\n    issue: issue,\n    date: {\n      start: dateStart,\n      end: dateEnd\n    },\n    status: status,\n    priority: priority,\n    groups: groups,\n    tags: tags,\n    types: types,\n    assignee: assignee,\n    raw: rawNoPage\n  }\n\n  const processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'filter'\n  processor.filter = filter\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: filter.status,\n    user: req.user._id,\n    filter: filter\n  }\n\n  req.processor = processor\n\n  return next()\n}\n\n/**\n * Process the ```req.processor``` object and render the correct view\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @return {View} Tickets View\n * @see Ticket\n */\nticketsController.processor = function (req, res) {\n  const processor = req.processor\n  if (_.isUndefined(processor)) return res.redirect('/')\n\n  const content = {}\n  content.title = processor.title\n  content.nav = processor.nav\n  content.subnav = processor.subnav\n  content.view = processor.pagetype\n\n  content.data = {}\n  content.data.user = req.user\n  content.data.common = req.viewdata\n\n  const object = processor.object\n  content.data.page = object.page\n  content.data.filter = object.filter\n\n  return res.render(processor.renderpage, content)\n}\n\nticketsController.pdf = function (req, res) {\n  const TicketPDFGenerator = require('../pdf/ticketGenerator')\n  let uid = null\n  try {\n    uid = parseInt(req.params.uid)\n  } catch (e) {\n    winston.warn(e)\n    return res.status(404).send('Invalid Ticket UID')\n  }\n\n  ticketSchema.getTicketByUid(uid, function (err, ticket) {\n    if (err) return handleError(res, err)\n\n    const ticketGenerator = new TicketPDFGenerator(ticket)\n\n    ticketGenerator.generate(function (err, obj) {\n      if (err) return res.redirect('/tickets')\n\n      return res.writeHead(200, obj.headers).end(obj.data)\n    })\n  })\n}\n\n/**\n * Print Ticket View\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @return {View} Subviews/PrintTicket View\n */\nticketsController.print = function (req, res) {\n  const user = req.user\n  let uid = null\n  try {\n    uid = parseInt(req.params.uid)\n  } catch (e) {\n    winston.warn(e)\n    return res.redirect('/tickets')\n  }\n\n  const content = {}\n  content.title = 'Tickets - ' + req.params.uid\n  content.nav = 'tickets'\n\n  content.data = {}\n  content.data.user = req.user\n  content.data.common = req.viewdata\n  content.data.ticket = {}\n\n  ticketSchema.getTicketByUid(uid, function (err, ticket) {\n    if (err) return handleError(res, err)\n    if (_.isNull(ticket) || _.isUndefined(ticket)) return res.redirect('/tickets')\n\n    const hasPublic = permissions.canThis(user.role, 'tickets:public')\n    let hasAccess = false\n    async.series(\n      [\n        function (next) {\n          if (user.role.isAdmin || user.role.isAgent) {\n            departmentSchema.getDepartmentGroupsOfUser(user._id, function (err, groups) {\n              if (err) return res.redirect('/tickets')\n              const gIds = groups.map(function (g) {\n                return g._id\n              })\n\n              if (_.some(gIds, ticket.group._id)) {\n                if (!permissions.canThis(user.role, 'tickets:notes')) {\n                  ticket.notes = []\n                }\n\n                hasAccess = true\n                return next()\n              } else {\n                return next('UNAUTHORIZED_GROUP_ACCESS')\n              }\n            })\n          } else {\n            return next()\n          }\n        },\n        function (next) {\n          if (hasAccess) return next()\n\n          const members = ticket.group.members.map(function (m) {\n            return m._id.toString()\n          })\n\n          if (!members.includes(user._id.toString())) {\n            if (ticket.group.public && hasPublic) {\n              // Blank to bypass\n            } else {\n              return next('UNAUTHORIZED_GROUP_ACCESS')\n            }\n          }\n\n          if (!permissions.canThis(user.role, 'tickets:notes')) {\n            ticket.notes = []\n          }\n\n          return next()\n        }\n      ],\n      function (err) {\n        if (err) {\n          if (err === 'UNAUTHORIZED_GROUP_ACCESS')\n            winston.warn(\n              'User tried to access ticket outside of group - UserId: ' + user._id + ' (' + user.username + ')'\n            )\n\n          return res.redirect('/tickets')\n        }\n\n        content.data.ticket = ticket\n        content.data.ticket.priorityname = ticket.priority.name\n        content.data.ticket.tagsArray = ticket.tags\n        content.data.ticket.commentCount = _.size(ticket.comments)\n        content.layout = 'layout/print'\n\n        return res.render('subviews/printticket', content)\n      }\n    )\n  })\n}\n\n/**\n * Get Single Ticket view based on UID\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @return {View} Single Ticket View\n * @see Ticket\n * @example\n * //Content Object\n * content.title = \"Tickets - \" + req.params.id;\n * content.nav = 'tickets';\n *\n * content.data = {};\n * content.data.user = req.user;\n * content.data.common = req.viewdata;\n *\n * //Ticket Data\n * content.data.ticket = ticket;\n * content.data.ticket.priorityname = getPriorityName(ticket.priority);\n * content.data.ticket.tagsArray = ticket.tags;\n * content.data.ticket.commentCount = _.size(ticket.comments);\n */\nticketsController.single = function (req, res) {\n  const user = req.user\n  const uid = req.params.id\n  if (isNaN(uid)) {\n    return res.redirect('/tickets')\n  }\n\n  const content = {}\n  content.title = 'Tickets - ' + req.params.id\n  content.nav = 'tickets'\n\n  content.data = {}\n  content.data.user = user\n  content.data.common = req.viewdata\n  content.data.ticket = {}\n\n  ticketSchema.getTicketByUid(uid, function (err, ticket) {\n    if (err) return handleError(res, err)\n    if (_.isNull(ticket) || _.isUndefined(ticket)) return res.redirect('/tickets')\n\n    const departmentSchema = require('../models/department')\n    async.waterfall(\n      [\n        function (next) {\n          if (!req.user.role.isAdmin && !req.user.role.isAgent) {\n            return groupSchema.getAllGroupsOfUserNoPopulate(req.user._id, next)\n          }\n\n          departmentSchema.getUserDepartments(req.user._id, function (err, departments) {\n            if (err) return next(err)\n            if (_.some(departments, { allGroups: true })) {\n              return groupSchema.find({}, next)\n            }\n\n            const groups = _.flattenDeep(\n              departments.map(function (d) {\n                return d.groups\n              })\n            )\n\n            return next(null, groups)\n          })\n        },\n        function (userGroups, next) {\n          const hasPublic = permissions.canThis(user.role, 'tickets:public')\n          const groupIds = userGroups.map(function (g) {\n            return g._id.toString()\n          })\n\n          if (!groupIds.includes(ticket.group._id.toString())) {\n            if (ticket.group.public && hasPublic) {\n              // Blank to bypass\n            } else {\n              winston.warn('User access ticket outside of group - UserId: ' + user._id)\n              return res.redirect('/tickets')\n            }\n          }\n\n          if (\n            ticket.owner._id.toString() !== req.user._id.toString() &&\n            !permissions.canThis(user.role, 'tickets:viewall')\n          ) {\n            return res.redirect('/tickets')\n          }\n\n          if (!permissions.canThis(user.role, 'comments:view')) ticket.comments = []\n\n          if (!permissions.canThis(user.role, 'tickets:notes')) ticket.notes = []\n\n          content.data.ticket = ticket\n          content.data.ticket.priorityname = ticket.priority.name\n\n          return next()\n        }\n      ],\n      function (err) {\n        if (err) {\n          winston.warn(err)\n          return res.redirect('/tickets')\n        }\n\n        return res.render('subviews/singleticket', content)\n      }\n    )\n  })\n}\n\nticketsController.uploadImageMDE = function (req, res) {\n  const Chance = require('chance')\n  const chance = new Chance()\n  const fs = require('fs-extra')\n  const Busboy = require('busboy')\n  const busboy = Busboy({\n    headers: req.headers,\n    limits: {\n      files: 1,\n      fileSize: 5 * 1024 * 1024 // 5mb limit\n    }\n  })\n\n  const object = {}\n  let error\n\n  object.ticketId = req.headers.ticketid\n  if (!object.ticketId) return res.status(400).json({ success: false })\n\n  busboy.on('file', function (name, file, info) {\n    const filename = info.filename\n    const mimetype = info.mimeType\n    if (mimetype.indexOf('image/') === -1) {\n      error = {\n        status: 500,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n\n    const ext = path.extname(filename)\n    const allowedExtensions = [\n      '.jpg',\n      '.jpeg',\n      '.jpe',\n      '.jif',\n      '.jfif',\n      '.jfi',\n      '.png',\n      '.gif',\n      '.webp',\n      '.tiff',\n      '.tif',\n      '.bmp',\n      '.dib',\n      '.heif',\n      '.heic'\n    ]\n\n    if (!allowedExtensions.includes(ext.toLocaleLowerCase())) {\n      error = {\n        status: 400,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n\n    const savePath = path.join(__dirname, '../../public/uploads/tickets', object.ticketId)\n    // const sanitizedFilename = filename.replace(/[^a-z0-9.]/gi, '_').toLowerCase();\n    const sanitizedFilename = chance.hash({ length: 20 }) + ext\n    if (!fs.existsSync(savePath)) fs.ensureDirSync(savePath)\n\n    object.filePath = path.join(savePath, 'inline_' + sanitizedFilename)\n    object.filename = sanitizedFilename\n    object.mimetype = mimetype\n\n    if (fs.existsSync(object.filePath)) {\n      error = {\n        status: 500,\n        message: 'File already exists'\n      }\n\n      return file.resume()\n    }\n\n    file.on('limit', function () {\n      error = {\n        status: 500,\n        message: 'File too large'\n      }\n\n      // Delete the temp file\n      if (fs.existsSync(object.filePath)) fs.unlinkSync(object.filePath)\n\n      return file.resume()\n    })\n\n    file.pipe(fs.createWriteStream(object.filePath))\n  })\n\n  busboy.on('finish', function () {\n    if (error) return res.status(error.status).send(error.message)\n\n    if (_.isUndefined(object.ticketId) || _.isUndefined(object.filename) || _.isUndefined(object.filePath)) {\n      return res.status(400).send('Invalid Form Data')\n    }\n\n    // Everything Checks out lets make sure the file exists and then add it to the attachments array\n    if (!fs.existsSync(object.filePath)) return res.status(500).send('File Failed to Save to Disk')\n\n    const fileUrl = '/uploads/tickets/' + object.ticketId + '/inline_' + object.filename\n\n    return res.json({ filename: fileUrl, ticketId: object.ticketId })\n  })\n\n  req.pipe(busboy)\n}\n\nticketsController.uploadAttachment = function (req, res) {\n  const Busboy = require('busboy')\n  const busboy = Busboy({\n    headers: req.headers,\n    limits: {\n      files: 1,\n      fileSize: 10 * 1024 * 1024 // 10mb limit\n    }\n  })\n\n  const object = {\n    ownerId: req.user._id\n  }\n  let error\n\n  const events = []\n\n  busboy.on('field', function (fieldname, val) {\n    if (fieldname === 'ticketId') object.ticketId = val\n    if (fieldname === 'ownerId') object.ownerId = val\n  })\n\n  busboy.on('file', function (name, file, info) {\n    const filename = info.filename\n    const mimetype = info.mimeType\n\n    if (\n      mimetype.indexOf('image/') === -1 &&\n      mimetype.indexOf('text/plain') === -1 &&\n      mimetype.indexOf('audio/mpeg') === -1 &&\n      mimetype.indexOf('audio/mp3') === -1 &&\n      mimetype.indexOf('audio/wav') === -1 &&\n      mimetype.indexOf('application/x-zip-compressed') === -1 &&\n      mimetype.indexOf('application/pdf') === -1 &&\n      //  Office Mime-Types\n      mimetype.indexOf('application/msword') === -1 &&\n      mimetype.indexOf('application/vnd.openxmlformats-officedocument.wordprocessingml.document') === -1 &&\n      mimetype.indexOf('application/vnd.ms-excel') === -1 &&\n      mimetype.indexOf('application/vnd.openxmlformats-officedocument.spreadsheetml.sheet') === -1\n    ) {\n      error = {\n        status: 400,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n\n    const savePath = path.join(__dirname, '../../public/uploads/tickets', object.ticketId)\n    let sanitizedFilename = filename.replace(/[^a-z0-9.]/gi, '_').toLowerCase()\n\n    const ext = path.extname(sanitizedFilename)\n    const badExts = ['.html', '.htm', '.js', '.svg']\n\n    if (badExts.includes(ext)) {\n      error = {\n        status: 400,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n\n    if (!fs.existsSync(savePath)) fs.ensureDirSync(savePath)\n\n    object.filePath = path.join(savePath, 'attachment_' + sanitizedFilename)\n    object.filename = sanitizedFilename.replace('/', '').replace('..', '')\n    object.mimetype = mimetype\n\n    if (fs.existsSync(object.filePath)) {\n      const Chance = require('chance')\n      const chance = new Chance()\n      sanitizedFilename = chance.hash({ length: 15 }) + '-' + sanitizedFilename\n      object.filePath = path.join(savePath, 'attachment_' + sanitizedFilename)\n      object.filename = sanitizedFilename\n    }\n\n    if (fs.existsSync(object.filePath)) {\n      error = {\n        status: 400,\n        message: 'File already exists'\n      }\n\n      return file.resume()\n    }\n\n    file.on('limit', function () {\n      error = {\n        status: 400,\n        message: 'File too large'\n      }\n\n      // Delete the temp file\n      if (fs.existsSync(object.filePath)) fs.unlinkSync(object.filePath)\n\n      return file.resume()\n    })\n\n    const fstream = fs.createWriteStream(object.filePath)\n    events.push(function (cb) {\n      fstream.on('finish', cb)\n    })\n\n    file.pipe(fstream)\n  })\n\n  busboy.on('finish', function () {\n    async.series(events, function () {\n      if (error) return res.status(error.status).send(error.message)\n\n      if (_.isUndefined(object.ticketId) || _.isUndefined(object.ownerId) || _.isUndefined(object.filePath)) {\n        fs.unlinkSync(object.filePath)\n        return res.status(400).send('Invalid Form Data')\n      }\n\n      // Everything Checks out lets make sure the file exists and then add it to the attachments array\n      if (!fs.existsSync(object.filePath)) {\n        winston.warn('Unable to save file to disk: ' + object.filePath)\n        return res.status(500).send('File Failed to Save to Disk')\n      }\n\n      ticketSchema.getTicketById(object.ticketId, function (err, ticket) {\n        if (err) {\n          winston.warn(err)\n          return res.status(500).send(err.message)\n        }\n\n        const attachment = {\n          owner: object.ownerId,\n          name: object.filename,\n          path: '/uploads/tickets/' + object.ticketId + '/attachment_' + object.filename,\n          type: object.mimetype\n        }\n        ticket.attachments.push(attachment)\n\n        const historyItem = {\n          action: 'ticket:added:attachment',\n          description: 'Attachment ' + object.filename + ' was added.',\n          owner: object.ownerId\n        }\n        ticket.history.push(historyItem)\n\n        ticket.updated = Date.now()\n        ticket.save(function (err, t) {\n          if (err) {\n            fs.unlinkSync(object.filePath)\n            winston.warn(err)\n            return res.status(500).send(err.message)\n          }\n\n          const returnData = {\n            ticket: t\n          }\n\n          return res.json(returnData)\n        })\n      })\n    })\n  })\n\n  req.pipe(busboy)\n}\n\nfunction handleError (res, err) {\n  if (err) {\n    winston.warn(err)\n    if (!err.status) res.status = 500\n    else res.status = err.status\n    return res.render('error', {\n      layout: false,\n      error: err,\n      message: err.message\n    })\n  }\n}\n\nmodule.exports = ticketsController\n", "/*\n      .                              .o8                     oooo\n   .o8                             \"888                     `888\n .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n   888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n   888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n   888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n   \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n ========================================================================\n **/\n\nconst express = require('express')\nconst router = express.Router()\nconst controllers = require('../controllers')\nconst path = require('path')\nconst winston = require('../logger')\nconst packagejson = require('../../package.json')\n\nfunction mainRoutes (router, middleware, controllers) {\n  router.get('/', middleware.redirectToDashboardIfLoggedIn, controllers.main.index)\n  router.get('/healthz', function (req, res) {\n    return res.status(200).send('OK')\n  })\n  router.get('/version', function (req, res) {\n    return res.json({ version: packagejson.version })\n  })\n  router.get('/install', function (req, res) {\n    return res.redirect('/')\n  })\n\n  router.get('/login', function (req, res) {\n    return res.redirect('/')\n  })\n\n  router.post('/login', controllers.main.loginPost)\n  router.get('/l2auth', controllers.main.l2authget)\n  router.post('/l2auth', controllers.main.l2AuthPost)\n  router.get('/logout', controllers.main.logout)\n  router.post('/forgotpass', controllers.main.forgotPass)\n  router.get('/resetpassword/:hash', controllers.main.resetPass)\n  router.post('/forgotl2auth', controllers.main.forgotL2Auth)\n  router.get('/resetl2auth/:hash', controllers.main.resetl2auth)\n\n  router.get('/about', middleware.redirectToLogin, middleware.loadCommonData, controllers.main.about)\n\n  router.get('/captcha', function (req, res) {\n    const svgCaptcha = require('svg-captcha')\n    const captcha = svgCaptcha.create()\n    req.session.captcha = captcha.text\n    res.set('Content-Type', 'image/svg+xml')\n    res.send(captcha.data)\n  })\n\n  // Public\n  router.get('/newissue', controllers.tickets.pubNewIssue)\n  router.get('/register', controllers.accounts.signup)\n  router.get('/signup', controllers.accounts.signup)\n\n  router.get('/logoimage', function (req, res) {\n    const s = require('../models/setting')\n    const _ = require('lodash')\n    s.getSettingByName('gen:customlogo', function (err, hasCustomLogo) {\n      if (!err && hasCustomLogo && hasCustomLogo.value) {\n        s.getSettingByName('gen:customlogofilename', function (err, logoFilename) {\n          if (!err && logoFilename && !_.isUndefined(logoFilename)) {\n            return res.send('/assets/topLogo.png')\n          }\n\n          return res.send('/img/defaultLogoLight.png')\n        })\n      } else {\n        return res.send('/img/defaultLogoLight.png')\n      }\n    })\n  })\n\n  // Maintenance\n  router.get('/maintenance', function (req, res) {\n    return res.redirect('/')\n  })\n\n  router.get(\n    '/dashboard',\n    middleware.redirectToLogin,\n    middleware.redirectIfUser,\n    middleware.loadCommonData,\n    controllers.main.dashboard\n  )\n\n  // Tickets\n  router.get(\n    '/tickets',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.getActive,\n    controllers.tickets.processor\n  )\n  router.get(\n    '/tickets/filter',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.filter,\n    controllers.tickets.processor\n  )\n  router.get(\n    '/tickets/active',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.getActive,\n    controllers.tickets.processor\n  )\n  router.get(\n    '/tickets/active/page/:page',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.getActive,\n    controllers.tickets.processor\n  )\n  router.get(\n    '/tickets/new',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.getByStatus,\n    controllers.tickets.processor\n  )\n  router.get(\n    '/tickets/new/page/:page',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.getByStatus,\n    controllers.tickets.processor\n  )\n  router.get(\n    '/tickets/open',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.getByStatus,\n    controllers.tickets.processor\n  )\n  router.get(\n    '/tickets/open/page/:page',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.getByStatus,\n    controllers.tickets.processor\n  )\n  router.get(\n    '/tickets/pending',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.getByStatus,\n    controllers.tickets.processor\n  )\n  router.get(\n    '/tickets/pending/page/:page',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.getByStatus,\n    controllers.tickets.processor\n  )\n  router.get(\n    '/tickets/closed',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.getByStatus,\n    controllers.tickets.processor\n  )\n  router.get(\n    '/tickets/closed/page/:page',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.getByStatus,\n    controllers.tickets.processor\n  )\n  router.get(\n    '/tickets/assigned',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.getAssigned,\n    controllers.tickets.processor\n  )\n  router.get(\n    '/tickets/assigned/page/:page',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.getAssigned,\n    controllers.tickets.processor\n  )\n  router.get(\n    '/tickets/unassigned',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.getUnassigned,\n    controllers.tickets.processor\n  )\n  router.get(\n    '/tickets/unassigned/page/:page',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.getUnassigned,\n    controllers.tickets.processor\n  )\n  router.get('/tickets/print/:uid', middleware.redirectToLogin, middleware.loadCommonData, controllers.tickets.print)\n  router.get('/tickets/:id', middleware.redirectToLogin, middleware.loadCommonData, controllers.tickets.single)\n  // router.post('/tickets/postcomment', middleware.redirectToLogin, controllers.tickets.postcomment);\n  router.post('/tickets/uploadattachment', middleware.redirectToLogin, controllers.tickets.uploadAttachment)\n  router.post('/tickets/uploadmdeimage', middleware.redirectToLogin, controllers.tickets.uploadImageMDE)\n\n  // Messages\n  router.get('/messages', middleware.redirectToLogin, middleware.loadCommonData, controllers.messages.get)\n  router.get(\n    '/messages/startconversation',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    function (req, res, next) {\n      req.showNewConvo = true\n      next()\n    },\n    controllers.messages.get\n  )\n  router.get(\n    '/messages/:convoid',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.messages.getConversation\n  )\n\n  // Accounts\n  router.get(\n    '/profile',\n    middleware.redirectToLogin,\n    middleware.csrfCheck,\n    middleware.loadCommonData,\n    controllers.accounts.profile\n  )\n  router.get('/accounts', middleware.redirectToLogin, middleware.loadCommonData, controllers.accounts.getCustomers)\n  router.get(\n    '/accounts/customers',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.accounts.getCustomers\n  )\n  router.get('/accounts/agents', middleware.redirectToLogin, middleware.loadCommonData, controllers.accounts.getAgents)\n  router.get('/accounts/admins', middleware.redirectToLogin, middleware.loadCommonData, controllers.accounts.getAdmins)\n  router.post('/accounts/uploadimage', middleware.redirectToLogin, controllers.accounts.uploadImage)\n  // router.get('/accounts/import', middleware.redirectToLogin, middleware.loadCommonData, controllers.accounts.importPage)\n  // router.post('/accounts/import/csv/upload', middleware.redirectToLogin, controllers.accounts.uploadCSV)\n  // router.post('/accounts/import/json/upload', middleware.redirectToLogin, controllers.accounts.uploadJSON)\n  // router.post('/accounts/import/ldap/bind', middleware.redirectToLogin, controllers.accounts.bindLdap)\n\n  // Groups\n  router.get('/groups', middleware.redirectToLogin, middleware.loadCommonData, controllers.groups.get)\n  router.get('/groups/create', middleware.redirectToLogin, middleware.loadCommonData, controllers.groups.getCreate)\n  router.get('/groups/:id', middleware.redirectToLogin, middleware.loadCommonData, controllers.groups.edit)\n\n  // Teams\n  router.get('/teams', middleware.redirectToLogin, middleware.loadCommonData, controllers.teams.get)\n\n  // Departments\n  router.get('/departments', middleware.redirectToLogin, middleware.loadCommonData, controllers.departments.get)\n\n  // Reports\n  router.get('/reports', middleware.redirectToLogin, middleware.loadCommonData, controllers.reports.overview)\n  router.get('/reports/overview', middleware.redirectToLogin, middleware.loadCommonData, controllers.reports.overview)\n  router.get('/reports/generate', middleware.redirectToLogin, middleware.loadCommonData, controllers.reports.generate)\n  router.get(\n    '/reports/breakdown/group',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.reports.breakdownGroup\n  )\n  router.get(\n    '/reports/breakdown/user',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.reports.breakdownUser\n  )\n\n  // Notices\n  router.get('/notices', middleware.redirectToLogin, middleware.loadCommonData, controllers.notices.get)\n  router.get('/notices/create', middleware.redirectToLogin, middleware.loadCommonData, controllers.notices.create)\n  router.get('/notices/:id', middleware.redirectToLogin, middleware.loadCommonData, controllers.notices.edit)\n\n  router.get('/settings', middleware.redirectToLogin, middleware.loadCommonData, controllers.settings.general)\n  router.get('/settings/general', middleware.redirectToLogin, middleware.loadCommonData, controllers.settings.general)\n  router.get('/settings/accounts', middleware.redirectToLogin, middleware.loadCommonData, controllers.settings.accounts)\n  router.get(\n    '/settings/appearance',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.settings.appearance\n  )\n  router.post('/settings/general/uploadlogo', middleware.redirectToLogin, controllers.main.uploadLogo)\n  router.post('/settings/general/uploadpagelogo', middleware.redirectToLogin, controllers.main.uploadPageLogo)\n  router.post('/settings/general/uploadfavicon', middleware.redirectToLogin, controllers.main.uploadFavicon)\n  router.get(\n    '/settings/permissions',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.settings.permissionsSettings\n  )\n  router.get(\n    '/settings/tickets',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.settings.ticketSettings\n  )\n  router.get(\n    '/settings/mailer',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.settings.mailerSettings\n  )\n  router.get(\n    '/settings/notifications',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.settings.notificationsSettings\n  )\n  router.get(\n    '/settings/elasticsearch',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.settings.elasticsearchSettings\n  )\n  router.get('/settings/tps', middleware.redirectToLogin, middleware.loadCommonData, controllers.settings.tpsSettings)\n  router.get(\n    '/settings/backup',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.settings.backupSettings\n  )\n  router.get(\n    '/settings/server',\n    middleware.redirectToLogin,\n    middleware.isAdmin,\n    middleware.loadCommonData,\n    middleware.csrfCheck,\n    controllers.settings.serverSettings\n  )\n  router.get('/settings/legal', middleware.redirectToLogin, middleware.loadCommonData, controllers.settings.legal)\n  router.get('/settings/logs', middleware.redirectToLogin, middleware.loadCommonData, controllers.settings.logs)\n\n  router.get(\n    '/settings/editor/:template',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.editor.page\n  )\n\n  // Plugins\n  router.get('/plugins', middleware.redirectToLogin, middleware.loadCommonData, controllers.plugins.get)\n\n  // API\n  // v1\n  require('../controllers/api/v1/routes')(middleware, router, controllers)\n  // v2\n  require('../controllers/api/v2/routes')(middleware, router, controllers)\n\n  router.get('/api/v1/plugins/list/installed', middleware.api, function (req, res) {\n    return res.json({ success: true, loadedPlugins: global.plugins })\n  })\n  router.get(\n    '/api/v1/plugins/install/:packageid',\n    middleware.api,\n    middleware.isAdmin,\n    controllers.api.v1.plugins.installPlugin\n  )\n  router.delete(\n    '/api/v1/plugins/remove/:packageid',\n    middleware.api,\n    middleware.isAdmin,\n    controllers.api.v1.plugins.removePlugin\n  )\n\n  router.post('/api/v1/admin/restart', middleware.csrfCheck, middleware.api, middleware.isAdmin, function (req, res) {\n    if (process.env.DISABLE_RESTART) return res.json({ success: true })\n\n    const pm2 = require('pm2')\n    pm2.connect(function (err) {\n      if (err) {\n        winston.error(err)\n        res.status(400).send(err)\n        return\n      }\n      pm2.restart('trudesk', function (err) {\n        if (err) {\n          res.status(400).send(err)\n          return winston.error(err)\n        }\n\n        pm2.disconnect()\n        res.json({ success: true })\n      })\n    })\n  })\n\n  if (global.env === 'development') {\n    router.get('/debug/populatedb', controllers.debug.populatedatabase)\n    router.get('/debug/sendmail', controllers.debug.sendmail)\n    router.get('/debug/mailcheck/refetch', function (req, res) {\n      const mailCheck = require('../mailer/mailCheck')\n      mailCheck.refetch()\n      res.send('OK')\n    })\n\n    router.get('/debug/cache/refresh', function (req, res) {\n      const cache = require('../cache/cache.js')\n      cache.forceRefresh()\n      return res.send('OK')\n    })\n\n    router.get('/debug/restart', function (req, res) {\n      if (process.env.DISABLE_RESTART) return res.send('RESTART DISABLED')\n      const pm2 = require('pm2')\n      pm2.connect(function (err) {\n        if (err) {\n          winston.error(err)\n          res.status(400).send(err)\n          return\n        }\n        pm2.restart('trudesk', function (err) {\n          if (err) {\n            res.status(400).send(err)\n            return winston.error(err)\n          }\n\n          pm2.disconnect()\n          res.send('OK')\n        })\n      })\n    })\n  }\n}\n\nmodule.exports = function (app, middleware) {\n  mainRoutes(router, middleware, controllers)\n  app.use('/', router)\n\n  // Load Plugin routes\n  const dive = require('dive')\n  const fs = require('fs')\n  const pluginDir = path.join(__dirname, '../../plugins')\n  if (!fs.existsSync(pluginDir)) fs.mkdirSync(pluginDir)\n  dive(pluginDir, { directories: true, files: false, recursive: false }, function (err, dir) {\n    if (err) throw err\n    const pluginRoutes = require(path.join(dir, '/routes'))\n    if (pluginRoutes) {\n      pluginRoutes(router, middleware)\n    } else {\n      winston.warn('Unable to load plugin: ' + pluginDir)\n    }\n  })\n\n  app.use(handle404)\n  app.use(handleErrors)\n}\n\nfunction handleErrors (err, req, res) {\n  const status = err.status || 500\n  res.status(err.status)\n\n  if (status === 429) {\n    res.render('429', { layout: false })\n    return\n  }\n\n  if (status === 500) {\n    res.render('500', { layout: false })\n    return\n  }\n\n  if (status === 503) {\n    res.render('503', { layout: false })\n    return\n  }\n\n  winston.warn(err.stack)\n\n  res.render('error', {\n    message: err.message,\n    error: err,\n    layout: false\n  })\n}\n\nfunction handle404 (req, res) {\n  return res.status(404).render('404', { layout: false })\n}\n"], "fixing_code": ["/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Updated:    6/24/19 5:32 PM\n *  Copyright (c) 2014-2019 Trudesk, Inc. All rights reserved.\n */\n\nimport React, { Fragment } from 'react'\nimport PropTypes from 'prop-types'\nimport { connect } from 'react-redux'\nimport { observer } from 'mobx-react'\nimport { makeObservable, observable } from 'mobx'\n\nimport Avatar from 'components/Avatar/Avatar'\nimport ReactHtmlParser from 'react-html-parser'\n\nimport helpers from 'lib/helpers'\nimport socket from 'lib/socket'\nimport axios from 'axios'\nimport Log from '../../logger'\n\nconst setupImages = parent => {\n  const imagesEl = parent.issueBody.querySelectorAll('img:not(.hasLinked)')\n  imagesEl.forEach(i => helpers.setupImageLink(i))\n}\n\nconst setupLinks = parent => {\n  const linksEl = parent.issueBody.querySelectorAll('a')\n  linksEl.forEach(i => helpers.setupLinkWarning(i))\n}\n\n@observer\nclass IssuePartial extends React.Component {\n  @observable ticketId = ''\n  @observable status = null\n  @observable owner = null\n  @observable subject = ''\n  @observable issue = ''\n  @observable attachments = []\n\n  constructor (props) {\n    super(props)\n    makeObservable(this)\n\n    this.ticketId = this.props.ticketId\n    this.status = this.props.status\n    this.owner = this.props.owner\n    this.subject = this.props.subject\n    this.issue = this.props.issue\n    this.attachments = this.props.attachments\n\n    this.onUpdateTicketIssue = this.onUpdateTicketIssue.bind(this)\n    this.onUpdateTicketAttachments = this.onUpdateTicketAttachments.bind(this)\n  }\n\n  componentDidMount () {\n    setupImages(this)\n    setupLinks(this)\n\n    socket.socket.on('updateTicketIssue', this.onUpdateTicketIssue)\n    socket.socket.on('updateTicketAttachments', this.onUpdateTicketAttachments)\n  }\n\n  componentDidUpdate (prevProps) {\n    if (prevProps.ticketId !== this.props.ticketId) this.ticketId = this.props.ticketId\n    if (prevProps.status !== this.props.status) this.status = this.props.status\n    if (prevProps.owner !== this.props.owner) this.owner = this.props.owner\n    if (prevProps.subject !== this.props.subject) this.subject = this.props.subject\n    if (prevProps.issue !== this.props.issue) this.issue = this.props.issue\n    if (prevProps.attachments !== this.props.attachments) this.attachments = this.props.attachments\n  }\n\n  componentWillUnmount () {\n    socket.socket.off('updateTicketIssue', this.onUpdateTicketIssue)\n    socket.socket.off('updateTicketAttachments', this.onUpdateTicketAttachments)\n  }\n\n  onUpdateTicketIssue (data) {\n    if (this.ticketId === data._id) {\n      this.subject = data.subject\n      this.issue = data.issue\n    }\n  }\n\n  onUpdateTicketAttachments (data) {\n    if (this.ticketId === data.ticket._id) {\n      this.attachments = data.ticket.attachments\n    }\n  }\n\n  onAttachmentInputChange (e) {\n    const formData = new FormData()\n    const attachmentFile = e.target.files[0]\n    formData.append('ticketId', this.ticketId)\n    formData.append('attachment', attachmentFile)\n    const token = document.querySelector('meta[name=\"csrf-token\"]').getAttribute('content')\n    axios\n      .post(`/tickets/uploadattachment`, formData, {\n        headers: {\n          'Content-Type': 'multipart/form-data',\n          'CSRF-TOKEN': token\n        }\n      })\n      .then(() => {\n        socket.ui.refreshTicketAttachments(this.ticketId)\n        helpers.UI.showSnackbar('Attachment Successfully Uploaded')\n      })\n      .catch(error => {\n        Log.error(error)\n        if (error.response) Log.error(error.response)\n        helpers.UI.showSnackbar(error, true)\n      })\n  }\n\n  removeAttachment (e, attachmentId) {\n    axios\n      .delete(`/api/v1/tickets/${this.ticketId}/attachments/remove/${attachmentId}`)\n      .then(() => {\n        socket.ui.refreshTicketAttachments(this.ticketId)\n        helpers.UI.showSnackbar('Attachment Removed')\n      })\n      .catch(error => {\n        Log.error(error)\n        if (error.response) Log.error(error.response)\n        helpers.UI.showSnackbar(error, true)\n      })\n  }\n\n  render () {\n    return (\n      <div className='initial-issue uk-clearfix'>\n        <Avatar image={this.owner.image} userId={this.owner._id} />\n        {/* Issue */}\n        <div className='issue-text'>\n          <h3 className='subject-text'>{this.subject}</h3>\n          <a href={`mailto:${this.owner.email}`}>\n            {this.owner.fullname} &lt;{this.owner.email}&gt;\n          </a>\n          <br />\n          <time dateTime={helpers.formatDate(this.props.date, 'YYYY-MM-DD HH:mm')}>\n            {helpers.formatDate(this.props.date, this.props.dateFormat)}\n          </time>\n          <br />\n          {/* Attachments */}\n          <ul className='attachments'>\n            {this.attachments &&\n              this.attachments.map(attachment => (\n                <li key={attachment._id}>\n                  <a href={attachment.path} className='no-ajaxy' rel='noopener noreferrer' target='_blank'>\n                    {attachment.name}\n                  </a>\n                  {this.status !== 3 && (\n                    <a\n                      role='button'\n                      className={'remove-attachment'}\n                      onClick={e => this.removeAttachment(e, attachment._id)}\n                    >\n                      <i className='fa fa-remove' />\n                    </a>\n                  )}\n                </li>\n              ))}\n          </ul>\n          <div className='issue-body' ref={r => (this.issueBody = r)}>\n            {ReactHtmlParser(this.issue)}\n          </div>\n        </div>\n        {/* Permissions on Fragment for edit */}\n        {this.status !== 3 && helpers.hasPermOverRole(this.props.owner.role, null, 'tickets:update', true) && (\n          <Fragment>\n            <div\n              className={'edit-issue'}\n              onClick={() => {\n                if (this.props.editorWindow)\n                  this.props.editorWindow.openEditorWindow({\n                    subject: this.subject,\n                    text: this.issue,\n                    onPrimaryClick: data => {\n                      socket.ui.setTicketIssue(this.ticketId, data.text, data.subjectText)\n                    }\n                  })\n              }}\n            >\n              <i className='material-icons'>&#xE254;</i>\n            </div>\n            <form className='form nomargin' encType='multipart/form-data'>\n              <div className='add-attachment' onClick={e => this.attachmentInput.click()}>\n                <i className='material-icons'>&#xE226;</i>\n              </div>\n\n              <input\n                ref={r => (this.attachmentInput = r)}\n                className='hide'\n                type='file'\n                onChange={e => this.onAttachmentInputChange(e)}\n              />\n            </form>\n          </Fragment>\n        )}\n      </div>\n    )\n  }\n}\n\nIssuePartial.propTypes = {\n  ticketId: PropTypes.string.isRequired,\n  status: PropTypes.number.isRequired,\n  owner: PropTypes.object.isRequired,\n  subject: PropTypes.string.isRequired,\n  issue: PropTypes.string.isRequired,\n  date: PropTypes.string.isRequired,\n  dateFormat: PropTypes.string.isRequired,\n  attachments: PropTypes.array,\n  editorWindow: PropTypes.object\n}\n\nexport default IssuePartial\n", "/*\n      .                              .o8                     oooo\n   .o8                             \"888                     `888\n .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n   888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n   888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n   888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n   \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n ========================================================================\n **/\n\nconst ticketSchema = require('../models/ticket')\nconst async = require('async')\nconst path = require('path')\nconst _ = require('lodash')\nconst winston = require('../logger')\nconst groupSchema = require('../models/group')\nconst departmentSchema = require('../models/department')\nconst permissions = require('../permissions')\nconst xss = require('xss')\nconst fs = require('fs-extra')\n/**\n * @since 1.0\n * @author Chris Brame <polonel@gmail.com>\n * @copyright 2015 Chris Brame\n **/\n\n/**\n * @namespace\n * @description Controller for each Ticket View\n * @requires {@link Ticket}\n * @requires {@link Group}\n * @requires {@link TicketType}\n * @requires {@link Emitter}\n *\n */\nconst ticketsController = {}\n\n/**\n * @name ticketsController.content\n * @description Main Content sent to the view\n */\nticketsController.content = {}\n\nticketsController.pubNewIssue = function (req, res) {\n  const marked = require('marked')\n  const settings = require('../models/setting')\n  settings.getSettingByName('allowPublicTickets:enable', function (err, setting) {\n    if (err) return handleError(res, err)\n    if (setting && setting.value === true) {\n      settings.getSettingByName('legal:privacypolicy', function (err, privacyPolicy) {\n        if (err) return handleError(res, err)\n\n        const content = {}\n        content.title = 'New Issue'\n        content.layout = false\n        content.data = {}\n        if (privacyPolicy === null || _.isUndefined(privacyPolicy.value)) {\n          content.data.privacyPolicy = 'No Privacy Policy has been set.'\n        } else {\n          content.data.privacyPolicy = xss(marked.parse(privacyPolicy.value))\n        }\n\n        return res.render('pub_createTicket', content)\n      })\n    } else {\n      return res.redirect('/')\n    }\n  })\n}\n\n/**\n * Get Ticket View based on ticket status\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @param {function} next Sends the ```req.processor``` object to the processor\n * @see Ticket\n */\nticketsController.getByStatus = function (req, res, next) {\n  const url = require('url')\n  let page = req.params.page\n  if (_.isUndefined(page)) page = 0\n\n  const processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.subnav = 'tickets-'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'active'\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: []\n  }\n\n  const fullUrl = url.format({\n    protocol: req.protocol,\n    host: req.get('host'),\n    pathname: req.originalUrl\n  })\n\n  const pathname = new url.URL(fullUrl).pathname\n  const arr = pathname.split('/')\n  let tType = 'new'\n  let s = 0\n  if (_.size(arr) > 2) tType = arr[2]\n\n  switch (tType) {\n    case 'open':\n      s = 1\n      break\n    case 'pending':\n      s = 2\n      break\n    case 'closed':\n      s = 3\n      break\n  }\n\n  processor.subnav += tType\n  processor.pagetype = tType\n  processor.object.status.push(s)\n\n  req.processor = processor\n  return next()\n}\n\n/**\n * Get Ticket View based on ticket active tickets\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @param {function} next Sends the ```req.processor``` object to the processor\n * @see Ticket\n */\nticketsController.getActive = function (req, res, next) {\n  let page = req.params.page\n  if (_.isUndefined(page)) page = 0\n\n  const processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.subnav = 'tickets-active'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'active'\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: [0, 1, 2]\n  }\n\n  req.processor = processor\n\n  return next()\n}\n\n/**\n * Get Ticket View based on tickets assigned to a given user\n * _calls ```next()``` to send to processor_\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @param {callback} next Sends the ```req.processor``` object to the processor\n * @see Ticket\n */\nticketsController.getAssigned = function (req, res, next) {\n  let page = req.params.page\n  if (_.isUndefined(page)) page = 0\n\n  const processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.subnav = 'tickets-assigned'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'assigned'\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: [0, 1, 2],\n    assignedSelf: true,\n    user: req.user._id\n  }\n\n  req.processor = processor\n\n  return next()\n}\n\n/**\n * Get Ticket View based on tickets assigned to a given user\n * _calls ```next()``` to send to processor_\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @param {callback} next Sends the ```req.processor``` object to the processor\n * @see Ticket\n */\nticketsController.getUnassigned = function (req, res, next) {\n  let page = req.params.page\n  if (_.isUndefined(page)) page = 0\n\n  const processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.subnav = 'tickets-unassigned'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'unassigned'\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: [0, 1, 2],\n    unassigned: true,\n    user: req.user._id\n  }\n\n  req.processor = processor\n\n  return next()\n}\n\nticketsController.filter = function (req, res, next) {\n  let page = req.query.page\n  if (_.isUndefined(page)) page = 0\n\n  const queryString = req.query\n  const uid = queryString.uid\n  const subject = queryString.fs\n  const issue = queryString.it\n  const dateStart = queryString.ds\n  const dateEnd = queryString.de\n  let status = queryString.st\n  let priority = queryString.pr\n  let groups = queryString.gp\n  let types = queryString.tt\n  let tags = queryString.tag\n  let assignee = queryString.au\n\n  const rawNoPage = req.originalUrl.replace(/[?&]page=[^&#]*(#.*)?$/, '$1').replace(/([?&])page=[^&]*&/, '$1')\n\n  if (!_.isUndefined(status)) status = xss(status)\n  if (!_.isUndefined(status) && !_.isArray(status)) status = [status]\n  if (!_.isUndefined(priority)) priority = xss(priority)\n  if (!_.isUndefined(priority) && !_.isArray(priority)) priority = [priority]\n  if (!_.isUndefined(groups)) groups = xss(groups)\n  if (!_.isUndefined(groups) && !_.isArray(groups)) groups = [groups]\n  if (!_.isUndefined(types)) types = xss(types)\n  if (!_.isUndefined(types) && !_.isArray(types)) types = [types]\n  if (!_.isUndefined(tags)) tags = xss(tags)\n  if (!_.isUndefined(tags) && !_.isArray(tags)) tags = [tags]\n  if (!_.isUndefined(assignee)) assignee = xss(assignee)\n  if (!_.isUndefined(assignee) && !_.isArray(assignee)) assignee = [assignee]\n\n  const filter = {\n    uid: uid,\n    subject: xss(subject),\n    issue: issue,\n    date: {\n      start: dateStart,\n      end: dateEnd\n    },\n    status: status,\n    priority: priority,\n    groups: groups,\n    tags: tags,\n    types: types,\n    assignee: assignee,\n    raw: rawNoPage\n  }\n\n  const processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'filter'\n  processor.filter = filter\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: filter.status,\n    user: req.user._id,\n    filter: filter\n  }\n\n  req.processor = processor\n\n  return next()\n}\n\n/**\n * Process the ```req.processor``` object and render the correct view\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @return {View} Tickets View\n * @see Ticket\n */\nticketsController.processor = function (req, res) {\n  const processor = req.processor\n  if (_.isUndefined(processor)) return res.redirect('/')\n\n  const content = {}\n  content.title = processor.title\n  content.nav = processor.nav\n  content.subnav = processor.subnav\n  content.view = processor.pagetype\n\n  content.data = {}\n  content.data.user = req.user\n  content.data.common = req.viewdata\n\n  const object = processor.object\n  content.data.page = object.page\n  content.data.filter = object.filter\n\n  return res.render(processor.renderpage, content)\n}\n\nticketsController.pdf = function (req, res) {\n  const TicketPDFGenerator = require('../pdf/ticketGenerator')\n  let uid = null\n  try {\n    uid = parseInt(req.params.uid)\n  } catch (e) {\n    winston.warn(e)\n    return res.status(404).send('Invalid Ticket UID')\n  }\n\n  ticketSchema.getTicketByUid(uid, function (err, ticket) {\n    if (err) return handleError(res, err)\n\n    const ticketGenerator = new TicketPDFGenerator(ticket)\n\n    ticketGenerator.generate(function (err, obj) {\n      if (err) return res.redirect('/tickets')\n\n      return res.writeHead(200, obj.headers).end(obj.data)\n    })\n  })\n}\n\n/**\n * Print Ticket View\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @return {View} Subviews/PrintTicket View\n */\nticketsController.print = function (req, res) {\n  const user = req.user\n  let uid = null\n  try {\n    uid = parseInt(req.params.uid)\n  } catch (e) {\n    winston.warn(e)\n    return res.redirect('/tickets')\n  }\n\n  const content = {}\n  content.title = 'Tickets - ' + req.params.uid\n  content.nav = 'tickets'\n\n  content.data = {}\n  content.data.user = req.user\n  content.data.common = req.viewdata\n  content.data.ticket = {}\n\n  ticketSchema.getTicketByUid(uid, function (err, ticket) {\n    if (err) return handleError(res, err)\n    if (_.isNull(ticket) || _.isUndefined(ticket)) return res.redirect('/tickets')\n\n    const hasPublic = permissions.canThis(user.role, 'tickets:public')\n    let hasAccess = false\n    async.series(\n      [\n        function (next) {\n          if (user.role.isAdmin || user.role.isAgent) {\n            departmentSchema.getDepartmentGroupsOfUser(user._id, function (err, groups) {\n              if (err) return res.redirect('/tickets')\n              const gIds = groups.map(function (g) {\n                return g._id\n              })\n\n              if (_.some(gIds, ticket.group._id)) {\n                if (!permissions.canThis(user.role, 'tickets:notes')) {\n                  ticket.notes = []\n                }\n\n                hasAccess = true\n                return next()\n              } else {\n                return next('UNAUTHORIZED_GROUP_ACCESS')\n              }\n            })\n          } else {\n            return next()\n          }\n        },\n        function (next) {\n          if (hasAccess) return next()\n\n          const members = ticket.group.members.map(function (m) {\n            return m._id.toString()\n          })\n\n          if (!members.includes(user._id.toString())) {\n            if (ticket.group.public && hasPublic) {\n              // Blank to bypass\n            } else {\n              return next('UNAUTHORIZED_GROUP_ACCESS')\n            }\n          }\n\n          if (!permissions.canThis(user.role, 'tickets:notes')) {\n            ticket.notes = []\n          }\n\n          return next()\n        }\n      ],\n      function (err) {\n        if (err) {\n          if (err === 'UNAUTHORIZED_GROUP_ACCESS')\n            winston.warn(\n              'User tried to access ticket outside of group - UserId: ' + user._id + ' (' + user.username + ')'\n            )\n\n          return res.redirect('/tickets')\n        }\n\n        content.data.ticket = ticket\n        content.data.ticket.priorityname = ticket.priority.name\n        content.data.ticket.tagsArray = ticket.tags\n        content.data.ticket.commentCount = _.size(ticket.comments)\n        content.layout = 'layout/print'\n\n        return res.render('subviews/printticket', content)\n      }\n    )\n  })\n}\n\n/**\n * Get Single Ticket view based on UID\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @return {View} Single Ticket View\n * @see Ticket\n * @example\n * //Content Object\n * content.title = \"Tickets - \" + req.params.id;\n * content.nav = 'tickets';\n *\n * content.data = {};\n * content.data.user = req.user;\n * content.data.common = req.viewdata;\n *\n * //Ticket Data\n * content.data.ticket = ticket;\n * content.data.ticket.priorityname = getPriorityName(ticket.priority);\n * content.data.ticket.tagsArray = ticket.tags;\n * content.data.ticket.commentCount = _.size(ticket.comments);\n */\nticketsController.single = function (req, res) {\n  const user = req.user\n  const uid = req.params.id\n  if (isNaN(uid)) {\n    return res.redirect('/tickets')\n  }\n\n  const content = {}\n  content.title = 'Tickets - ' + req.params.id\n  content.nav = 'tickets'\n\n  content.data = {}\n  content.data.user = user\n  content.data.common = req.viewdata\n  content.data.ticket = {}\n\n  ticketSchema.getTicketByUid(uid, function (err, ticket) {\n    if (err) return handleError(res, err)\n    if (_.isNull(ticket) || _.isUndefined(ticket)) return res.redirect('/tickets')\n\n    const departmentSchema = require('../models/department')\n    async.waterfall(\n      [\n        function (next) {\n          if (!req.user.role.isAdmin && !req.user.role.isAgent) {\n            return groupSchema.getAllGroupsOfUserNoPopulate(req.user._id, next)\n          }\n\n          departmentSchema.getUserDepartments(req.user._id, function (err, departments) {\n            if (err) return next(err)\n            if (_.some(departments, { allGroups: true })) {\n              return groupSchema.find({}, next)\n            }\n\n            const groups = _.flattenDeep(\n              departments.map(function (d) {\n                return d.groups\n              })\n            )\n\n            return next(null, groups)\n          })\n        },\n        function (userGroups, next) {\n          const hasPublic = permissions.canThis(user.role, 'tickets:public')\n          const groupIds = userGroups.map(function (g) {\n            return g._id.toString()\n          })\n\n          if (!groupIds.includes(ticket.group._id.toString())) {\n            if (ticket.group.public && hasPublic) {\n              // Blank to bypass\n            } else {\n              winston.warn('User access ticket outside of group - UserId: ' + user._id)\n              return res.redirect('/tickets')\n            }\n          }\n\n          if (\n            ticket.owner._id.toString() !== req.user._id.toString() &&\n            !permissions.canThis(user.role, 'tickets:viewall')\n          ) {\n            return res.redirect('/tickets')\n          }\n\n          if (!permissions.canThis(user.role, 'comments:view')) ticket.comments = []\n\n          if (!permissions.canThis(user.role, 'tickets:notes')) ticket.notes = []\n\n          content.data.ticket = ticket\n          content.data.ticket.priorityname = ticket.priority.name\n\n          return next()\n        }\n      ],\n      function (err) {\n        if (err) {\n          winston.warn(err)\n          return res.redirect('/tickets')\n        }\n\n        return res.render('subviews/singleticket', content)\n      }\n    )\n  })\n}\n\nticketsController.uploadImageMDE = function (req, res) {\n  const Chance = require('chance')\n  const chance = new Chance()\n  const fs = require('fs-extra')\n  const Busboy = require('busboy')\n  const busboy = Busboy({\n    headers: req.headers,\n    limits: {\n      files: 1,\n      fileSize: 5 * 1024 * 1024 // 5mb limit\n    }\n  })\n\n  const object = {}\n  let error\n\n  object.ticketId = req.headers.ticketid\n  if (!object.ticketId) return res.status(400).json({ success: false })\n\n  busboy.on('file', function (name, file, info) {\n    const filename = info.filename\n    const mimetype = info.mimeType\n    if (mimetype.indexOf('image/') === -1) {\n      error = {\n        status: 500,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n\n    const ext = path.extname(filename)\n    const allowedExtensions = [\n      '.jpg',\n      '.jpeg',\n      '.jpe',\n      '.jif',\n      '.jfif',\n      '.jfi',\n      '.png',\n      '.gif',\n      '.webp',\n      '.tiff',\n      '.tif',\n      '.bmp',\n      '.dib',\n      '.heif',\n      '.heic'\n    ]\n\n    if (!allowedExtensions.includes(ext.toLocaleLowerCase())) {\n      error = {\n        status: 400,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n\n    const savePath = path.join(__dirname, '../../public/uploads/tickets', object.ticketId)\n    // const sanitizedFilename = filename.replace(/[^a-z0-9.]/gi, '_').toLowerCase();\n    const sanitizedFilename = chance.hash({ length: 20 }) + ext\n    if (!fs.existsSync(savePath)) fs.ensureDirSync(savePath)\n\n    object.filePath = path.join(savePath, 'inline_' + sanitizedFilename)\n    object.filename = sanitizedFilename\n    object.mimetype = mimetype\n\n    if (fs.existsSync(object.filePath)) {\n      error = {\n        status: 500,\n        message: 'File already exists'\n      }\n\n      return file.resume()\n    }\n\n    file.on('limit', function () {\n      error = {\n        status: 500,\n        message: 'File too large'\n      }\n\n      // Delete the temp file\n      if (fs.existsSync(object.filePath)) fs.unlinkSync(object.filePath)\n\n      return file.resume()\n    })\n\n    file.pipe(fs.createWriteStream(object.filePath))\n  })\n\n  busboy.on('finish', function () {\n    if (error) return res.status(error.status).send(error.message)\n\n    if (_.isUndefined(object.ticketId) || _.isUndefined(object.filename) || _.isUndefined(object.filePath)) {\n      return res.status(400).send('Invalid Form Data')\n    }\n\n    // Everything Checks out lets make sure the file exists and then add it to the attachments array\n    if (!fs.existsSync(object.filePath)) return res.status(500).send('File Failed to Save to Disk')\n\n    const fileUrl = '/uploads/tickets/' + object.ticketId + '/inline_' + object.filename\n\n    return res.json({ filename: fileUrl, ticketId: object.ticketId })\n  })\n\n  req.pipe(busboy)\n}\n\nticketsController.uploadAttachment = function (req, res) {\n  const Busboy = require('busboy')\n  const busboy = Busboy({\n    headers: req.headers,\n    limits: {\n      files: 1,\n      fileSize: 10 * 1024 * 1024 // 10mb limit\n    }\n  })\n\n  const object = {\n    ownerId: req.user._id\n  }\n  let error\n\n  const events = []\n\n  busboy.on('field', function (fieldname, val) {\n    if (fieldname === 'ticketId') object.ticketId = val\n    if (fieldname === 'ownerId') object.ownerId = val\n  })\n\n  busboy.on('file', function (name, file, info) {\n    const filename = info.filename\n    const mimetype = info.mimeType\n\n    if (\n      mimetype.indexOf('image/') === -1 &&\n      mimetype.indexOf('text/plain') === -1 &&\n      mimetype.indexOf('audio/mpeg') === -1 &&\n      mimetype.indexOf('audio/mp3') === -1 &&\n      mimetype.indexOf('audio/wav') === -1 &&\n      mimetype.indexOf('application/x-zip-compressed') === -1 &&\n      mimetype.indexOf('application/pdf') === -1 &&\n      //  Office Mime-Types\n      mimetype.indexOf('application/msword') === -1 &&\n      mimetype.indexOf('application/vnd.openxmlformats-officedocument.wordprocessingml.document') === -1 &&\n      mimetype.indexOf('application/vnd.ms-excel') === -1 &&\n      mimetype.indexOf('application/vnd.openxmlformats-officedocument.spreadsheetml.sheet') === -1\n    ) {\n      error = {\n        status: 400,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n\n    const savePath = path.join(__dirname, '../../public/uploads/tickets', object.ticketId)\n    let sanitizedFilename = filename.replace(/[^a-z0-9.]/gi, '_').toLowerCase()\n\n    const ext = path.extname(sanitizedFilename)\n    const allowedExts = [\n      '.png',\n      '.jpg',\n      '.jpeg',\n      '.tif',\n      '.gif',\n      '.doc',\n      '.docx',\n      '.xlsx',\n      '.xls',\n      '.pdf',\n      '.zip',\n      '.rar',\n      '.7z',\n      '.mp3',\n      '.wav',\n      '.txt',\n      '.mp4',\n      '.avi',\n      '.mpeg',\n      '.eps',\n      '.ai',\n      '.psd'\n    ]\n    const badExts = ['.html', '.htm', '.js', '.svg']\n\n    if (!allowedExts.includes(ext)) {\n      error = {\n        status: 400,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n\n    if (!fs.existsSync(savePath)) fs.ensureDirSync(savePath)\n\n    object.filePath = path.join(savePath, 'attachment_' + sanitizedFilename)\n    object.filename = sanitizedFilename.replace('/', '').replace('..', '')\n    object.mimetype = mimetype\n\n    if (fs.existsSync(object.filePath)) {\n      const Chance = require('chance')\n      const chance = new Chance()\n      sanitizedFilename = chance.hash({ length: 15 }) + '-' + sanitizedFilename\n      object.filePath = path.join(savePath, 'attachment_' + sanitizedFilename)\n      object.filename = sanitizedFilename\n    }\n\n    if (fs.existsSync(object.filePath)) {\n      error = {\n        status: 400,\n        message: 'File already exists'\n      }\n\n      return file.resume()\n    }\n\n    file.on('limit', function () {\n      error = {\n        status: 400,\n        message: 'File too large'\n      }\n\n      // Delete the temp file\n      if (fs.existsSync(object.filePath)) fs.unlinkSync(object.filePath)\n\n      return file.resume()\n    })\n\n    const fstream = fs.createWriteStream(object.filePath)\n    events.push(function (cb) {\n      fstream.on('finish', cb)\n    })\n\n    file.pipe(fstream)\n  })\n\n  busboy.on('finish', function () {\n    async.series(events, function () {\n      if (error) return res.status(error.status).send(error.message)\n\n      if (_.isUndefined(object.ticketId) || _.isUndefined(object.ownerId) || _.isUndefined(object.filePath)) {\n        fs.unlinkSync(object.filePath)\n        return res.status(400).send('Invalid Form Data')\n      }\n\n      // Everything Checks out lets make sure the file exists and then add it to the attachments array\n      if (!fs.existsSync(object.filePath)) {\n        winston.warn('Unable to save file to disk: ' + object.filePath)\n        return res.status(500).send('File Failed to Save to Disk')\n      }\n\n      ticketSchema.getTicketById(object.ticketId, function (err, ticket) {\n        if (err) {\n          winston.warn(err)\n          return res.status(500).send(err.message)\n        }\n\n        const attachment = {\n          owner: object.ownerId,\n          name: object.filename,\n          path: '/uploads/tickets/' + object.ticketId + '/attachment_' + object.filename,\n          type: object.mimetype\n        }\n        ticket.attachments.push(attachment)\n\n        const historyItem = {\n          action: 'ticket:added:attachment',\n          description: 'Attachment ' + object.filename + ' was added.',\n          owner: object.ownerId\n        }\n        ticket.history.push(historyItem)\n\n        ticket.updated = Date.now()\n        ticket.save(function (err, t) {\n          if (err) {\n            fs.unlinkSync(object.filePath)\n            winston.warn(err)\n            return res.status(500).send(err.message)\n          }\n\n          const returnData = {\n            ticket: t\n          }\n\n          return res.json(returnData)\n        })\n      })\n    })\n  })\n\n  req.pipe(busboy)\n}\n\nfunction handleError (res, err) {\n  if (err) {\n    winston.warn(err)\n    if (!err.status) res.status = 500\n    else res.status = err.status\n    return res.render('error', {\n      layout: false,\n      error: err,\n      message: err.message\n    })\n  }\n}\n\nmodule.exports = ticketsController\n", "/*\n      .                              .o8                     oooo\n   .o8                             \"888                     `888\n .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n   888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n   888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n   888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n   \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n ========================================================================\n **/\n\nconst express = require('express')\nconst router = express.Router()\nconst controllers = require('../controllers')\nconst path = require('path')\nconst winston = require('../logger')\nconst packagejson = require('../../package.json')\n\nfunction mainRoutes (router, middleware, controllers) {\n  router.get('/', middleware.redirectToDashboardIfLoggedIn, controllers.main.index)\n  router.get('/healthz', function (req, res) {\n    return res.status(200).send('OK')\n  })\n  router.get('/version', function (req, res) {\n    return res.json({ version: packagejson.version })\n  })\n  router.get('/install', function (req, res) {\n    return res.redirect('/')\n  })\n\n  router.get('/login', function (req, res) {\n    return res.redirect('/')\n  })\n\n  router.post('/login', controllers.main.loginPost)\n  router.get('/l2auth', controllers.main.l2authget)\n  router.post('/l2auth', controllers.main.l2AuthPost)\n  router.get('/logout', controllers.main.logout)\n  router.post('/forgotpass', controllers.main.forgotPass)\n  router.get('/resetpassword/:hash', controllers.main.resetPass)\n  router.post('/forgotl2auth', controllers.main.forgotL2Auth)\n  router.get('/resetl2auth/:hash', controllers.main.resetl2auth)\n\n  router.get('/about', middleware.redirectToLogin, middleware.loadCommonData, controllers.main.about)\n\n  router.get('/captcha', function (req, res) {\n    const svgCaptcha = require('svg-captcha')\n    const captcha = svgCaptcha.create()\n    req.session.captcha = captcha.text\n    res.set('Content-Type', 'image/svg+xml')\n    res.send(captcha.data)\n  })\n\n  // Public\n  router.get('/newissue', controllers.tickets.pubNewIssue)\n  router.get('/register', controllers.accounts.signup)\n  router.get('/signup', controllers.accounts.signup)\n\n  router.get('/logoimage', function (req, res) {\n    const s = require('../models/setting')\n    const _ = require('lodash')\n    s.getSettingByName('gen:customlogo', function (err, hasCustomLogo) {\n      if (!err && hasCustomLogo && hasCustomLogo.value) {\n        s.getSettingByName('gen:customlogofilename', function (err, logoFilename) {\n          if (!err && logoFilename && !_.isUndefined(logoFilename)) {\n            return res.send('/assets/topLogo.png')\n          }\n\n          return res.send('/img/defaultLogoLight.png')\n        })\n      } else {\n        return res.send('/img/defaultLogoLight.png')\n      }\n    })\n  })\n\n  // Maintenance\n  router.get('/maintenance', function (req, res) {\n    return res.redirect('/')\n  })\n\n  router.get(\n    '/dashboard',\n    middleware.redirectToLogin,\n    middleware.redirectIfUser,\n    middleware.loadCommonData,\n    controllers.main.dashboard\n  )\n\n  // Tickets\n  router.get(\n    '/tickets',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.getActive,\n    controllers.tickets.processor\n  )\n  router.get(\n    '/tickets/filter',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.filter,\n    controllers.tickets.processor\n  )\n  router.get(\n    '/tickets/active',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.getActive,\n    controllers.tickets.processor\n  )\n  router.get(\n    '/tickets/active/page/:page',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.getActive,\n    controllers.tickets.processor\n  )\n  router.get(\n    '/tickets/new',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.getByStatus,\n    controllers.tickets.processor\n  )\n  router.get(\n    '/tickets/new/page/:page',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.getByStatus,\n    controllers.tickets.processor\n  )\n  router.get(\n    '/tickets/open',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.getByStatus,\n    controllers.tickets.processor\n  )\n  router.get(\n    '/tickets/open/page/:page',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.getByStatus,\n    controllers.tickets.processor\n  )\n  router.get(\n    '/tickets/pending',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.getByStatus,\n    controllers.tickets.processor\n  )\n  router.get(\n    '/tickets/pending/page/:page',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.getByStatus,\n    controllers.tickets.processor\n  )\n  router.get(\n    '/tickets/closed',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.getByStatus,\n    controllers.tickets.processor\n  )\n  router.get(\n    '/tickets/closed/page/:page',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.getByStatus,\n    controllers.tickets.processor\n  )\n  router.get(\n    '/tickets/assigned',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.getAssigned,\n    controllers.tickets.processor\n  )\n  router.get(\n    '/tickets/assigned/page/:page',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.getAssigned,\n    controllers.tickets.processor\n  )\n  router.get(\n    '/tickets/unassigned',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.getUnassigned,\n    controllers.tickets.processor\n  )\n  router.get(\n    '/tickets/unassigned/page/:page',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.tickets.getUnassigned,\n    controllers.tickets.processor\n  )\n  router.get('/tickets/print/:uid', middleware.redirectToLogin, middleware.loadCommonData, controllers.tickets.print)\n  router.get('/tickets/:id', middleware.redirectToLogin, middleware.loadCommonData, controllers.tickets.single)\n  // router.post('/tickets/postcomment', middleware.redirectToLogin, controllers.tickets.postcomment);\n  router.post(\n    '/tickets/uploadattachment',\n    middleware.redirectToLogin,\n    middleware.csrfCheck,\n    controllers.tickets.uploadAttachment\n  )\n  router.post('/tickets/uploadmdeimage', middleware.redirectToLogin, controllers.tickets.uploadImageMDE)\n\n  // Messages\n  router.get('/messages', middleware.redirectToLogin, middleware.loadCommonData, controllers.messages.get)\n  router.get(\n    '/messages/startconversation',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    function (req, res, next) {\n      req.showNewConvo = true\n      next()\n    },\n    controllers.messages.get\n  )\n  router.get(\n    '/messages/:convoid',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.messages.getConversation\n  )\n\n  // Accounts\n  router.get(\n    '/profile',\n    middleware.redirectToLogin,\n    middleware.csrfCheck,\n    middleware.loadCommonData,\n    controllers.accounts.profile\n  )\n  router.get('/accounts', middleware.redirectToLogin, middleware.loadCommonData, controllers.accounts.getCustomers)\n  router.get(\n    '/accounts/customers',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.accounts.getCustomers\n  )\n  router.get('/accounts/agents', middleware.redirectToLogin, middleware.loadCommonData, controllers.accounts.getAgents)\n  router.get('/accounts/admins', middleware.redirectToLogin, middleware.loadCommonData, controllers.accounts.getAdmins)\n  router.post('/accounts/uploadimage', middleware.redirectToLogin, controllers.accounts.uploadImage)\n  // router.get('/accounts/import', middleware.redirectToLogin, middleware.loadCommonData, controllers.accounts.importPage)\n  // router.post('/accounts/import/csv/upload', middleware.redirectToLogin, controllers.accounts.uploadCSV)\n  // router.post('/accounts/import/json/upload', middleware.redirectToLogin, controllers.accounts.uploadJSON)\n  // router.post('/accounts/import/ldap/bind', middleware.redirectToLogin, controllers.accounts.bindLdap)\n\n  // Groups\n  router.get('/groups', middleware.redirectToLogin, middleware.loadCommonData, controllers.groups.get)\n  router.get('/groups/create', middleware.redirectToLogin, middleware.loadCommonData, controllers.groups.getCreate)\n  router.get('/groups/:id', middleware.redirectToLogin, middleware.loadCommonData, controllers.groups.edit)\n\n  // Teams\n  router.get('/teams', middleware.redirectToLogin, middleware.loadCommonData, controllers.teams.get)\n\n  // Departments\n  router.get('/departments', middleware.redirectToLogin, middleware.loadCommonData, controllers.departments.get)\n\n  // Reports\n  router.get('/reports', middleware.redirectToLogin, middleware.loadCommonData, controllers.reports.overview)\n  router.get('/reports/overview', middleware.redirectToLogin, middleware.loadCommonData, controllers.reports.overview)\n  router.get('/reports/generate', middleware.redirectToLogin, middleware.loadCommonData, controllers.reports.generate)\n  router.get(\n    '/reports/breakdown/group',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.reports.breakdownGroup\n  )\n  router.get(\n    '/reports/breakdown/user',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.reports.breakdownUser\n  )\n\n  // Notices\n  router.get('/notices', middleware.redirectToLogin, middleware.loadCommonData, controllers.notices.get)\n  router.get('/notices/create', middleware.redirectToLogin, middleware.loadCommonData, controllers.notices.create)\n  router.get('/notices/:id', middleware.redirectToLogin, middleware.loadCommonData, controllers.notices.edit)\n\n  router.get('/settings', middleware.redirectToLogin, middleware.loadCommonData, controllers.settings.general)\n  router.get('/settings/general', middleware.redirectToLogin, middleware.loadCommonData, controllers.settings.general)\n  router.get('/settings/accounts', middleware.redirectToLogin, middleware.loadCommonData, controllers.settings.accounts)\n  router.get(\n    '/settings/appearance',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.settings.appearance\n  )\n  router.post('/settings/general/uploadlogo', middleware.redirectToLogin, controllers.main.uploadLogo)\n  router.post('/settings/general/uploadpagelogo', middleware.redirectToLogin, controllers.main.uploadPageLogo)\n  router.post('/settings/general/uploadfavicon', middleware.redirectToLogin, controllers.main.uploadFavicon)\n  router.get(\n    '/settings/permissions',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.settings.permissionsSettings\n  )\n  router.get(\n    '/settings/tickets',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.settings.ticketSettings\n  )\n  router.get(\n    '/settings/mailer',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.settings.mailerSettings\n  )\n  router.get(\n    '/settings/notifications',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.settings.notificationsSettings\n  )\n  router.get(\n    '/settings/elasticsearch',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.settings.elasticsearchSettings\n  )\n  router.get('/settings/tps', middleware.redirectToLogin, middleware.loadCommonData, controllers.settings.tpsSettings)\n  router.get(\n    '/settings/backup',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.settings.backupSettings\n  )\n  router.get(\n    '/settings/server',\n    middleware.redirectToLogin,\n    middleware.isAdmin,\n    middleware.loadCommonData,\n    middleware.csrfCheck,\n    controllers.settings.serverSettings\n  )\n  router.get('/settings/legal', middleware.redirectToLogin, middleware.loadCommonData, controllers.settings.legal)\n  router.get('/settings/logs', middleware.redirectToLogin, middleware.loadCommonData, controllers.settings.logs)\n\n  router.get(\n    '/settings/editor/:template',\n    middleware.redirectToLogin,\n    middleware.loadCommonData,\n    controllers.editor.page\n  )\n\n  // Plugins\n  router.get('/plugins', middleware.redirectToLogin, middleware.loadCommonData, controllers.plugins.get)\n\n  // API\n  // v1\n  require('../controllers/api/v1/routes')(middleware, router, controllers)\n  // v2\n  require('../controllers/api/v2/routes')(middleware, router, controllers)\n\n  router.get('/api/v1/plugins/list/installed', middleware.api, function (req, res) {\n    return res.json({ success: true, loadedPlugins: global.plugins })\n  })\n  router.get(\n    '/api/v1/plugins/install/:packageid',\n    middleware.api,\n    middleware.isAdmin,\n    controllers.api.v1.plugins.installPlugin\n  )\n  router.delete(\n    '/api/v1/plugins/remove/:packageid',\n    middleware.api,\n    middleware.isAdmin,\n    controllers.api.v1.plugins.removePlugin\n  )\n\n  router.post('/api/v1/admin/restart', middleware.csrfCheck, middleware.api, middleware.isAdmin, function (req, res) {\n    if (process.env.DISABLE_RESTART) return res.json({ success: true })\n\n    const pm2 = require('pm2')\n    pm2.connect(function (err) {\n      if (err) {\n        winston.error(err)\n        res.status(400).send(err)\n        return\n      }\n      pm2.restart('trudesk', function (err) {\n        if (err) {\n          res.status(400).send(err)\n          return winston.error(err)\n        }\n\n        pm2.disconnect()\n        res.json({ success: true })\n      })\n    })\n  })\n\n  if (global.env === 'development') {\n    router.get('/debug/populatedb', controllers.debug.populatedatabase)\n    router.get('/debug/sendmail', controllers.debug.sendmail)\n    router.get('/debug/mailcheck/refetch', function (req, res) {\n      const mailCheck = require('../mailer/mailCheck')\n      mailCheck.refetch()\n      res.send('OK')\n    })\n\n    router.get('/debug/cache/refresh', function (req, res) {\n      const cache = require('../cache/cache.js')\n      cache.forceRefresh()\n      return res.send('OK')\n    })\n\n    router.get('/debug/restart', function (req, res) {\n      if (process.env.DISABLE_RESTART) return res.send('RESTART DISABLED')\n      const pm2 = require('pm2')\n      pm2.connect(function (err) {\n        if (err) {\n          winston.error(err)\n          res.status(400).send(err)\n          return\n        }\n        pm2.restart('trudesk', function (err) {\n          if (err) {\n            res.status(400).send(err)\n            return winston.error(err)\n          }\n\n          pm2.disconnect()\n          res.send('OK')\n        })\n      })\n    })\n  }\n}\n\nmodule.exports = function (app, middleware) {\n  mainRoutes(router, middleware, controllers)\n  app.use('/', router)\n\n  // Load Plugin routes\n  const dive = require('dive')\n  const fs = require('fs')\n  const pluginDir = path.join(__dirname, '../../plugins')\n  if (!fs.existsSync(pluginDir)) fs.mkdirSync(pluginDir)\n  dive(pluginDir, { directories: true, files: false, recursive: false }, function (err, dir) {\n    if (err) throw err\n    const pluginRoutes = require(path.join(dir, '/routes'))\n    if (pluginRoutes) {\n      pluginRoutes(router, middleware)\n    } else {\n      winston.warn('Unable to load plugin: ' + pluginDir)\n    }\n  })\n\n  app.use(handle404)\n  app.use(handleErrors)\n}\n\nfunction handleErrors (err, req, res) {\n  const status = err.status || 500\n  res.status(err.status)\n\n  if (status === 429) {\n    res.render('429', { layout: false })\n    return\n  }\n\n  if (status === 500) {\n    res.render('500', { layout: false })\n    return\n  }\n\n  if (status === 503) {\n    res.render('503', { layout: false })\n    return\n  }\n\n  winston.warn(err.stack)\n\n  res.render('error', {\n    message: err.message,\n    error: err,\n    layout: false\n  })\n}\n\nfunction handle404 (req, res) {\n  return res.status(404).render('404', { layout: false })\n}\n"], "filenames": ["src/client/containers/Tickets/IssuePartial.jsx", "src/controllers/tickets.js", "src/routes/index.js"], "buggy_code_start_loc": [101, 706, 206], "buggy_code_end_loc": [106, 710, 207], "fixing_code_start_loc": [102, 707, 206], "fixing_code_end_loc": [108, 734, 212], "type": "CWE-434", "message": "Unrestricted Upload of File with Dangerous Type in GitHub repository polonel/trudesk prior to 1.2.4.", "other": {"cve": {"id": "CVE-2022-2128", "sourceIdentifier": "security@huntr.dev", "published": "2022-06-20T17:15:08.713", "lastModified": "2022-06-28T12:13:51.730", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Unrestricted Upload of File with Dangerous Type in GitHub repository polonel/trudesk prior to 1.2.4."}, {"lang": "es", "value": "Una Carga no Restringida de Archivos de Tipo Peligroso en el repositorio de GitHub polonel/trudesk versiones anteriores a 1.2.4"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.6, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.8, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-434"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:trudesk_project:trudesk:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.4", "matchCriteriaId": "5B059E3C-427E-4142-88A1-E5BC70BE26FE"}]}]}], "references": [{"url": "https://github.com/polonel/trudesk/commit/fb2ef82b0a39d0a560a261e07c3c73ba25332ecb", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/ec40ec76-c7db-4384-a33b-024f3dd21d75", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/polonel/trudesk/commit/fb2ef82b0a39d0a560a261e07c3c73ba25332ecb"}}