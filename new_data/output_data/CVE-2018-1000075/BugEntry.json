{"buggy_code": ["# -*- coding: utf-8 -*-\n# frozen_string_literal: true\n#--\n# Copyright (C) 2004 Mauricio Julio Fern\u00e1ndez Pradier\n# See LICENSE.txt for additional licensing information.\n#++\n\n##\n#--\n# struct tarfile_entry_posix {\n#   char name[100];     # ASCII + (Z unless filled)\n#   char mode[8];       # 0 padded, octal, null\n#   char uid[8];        # ditto\n#   char gid[8];        # ditto\n#   char size[12];      # 0 padded, octal, null\n#   char mtime[12];     # 0 padded, octal, null\n#   char checksum[8];   # 0 padded, octal, null, space\n#   char typeflag[1];   # file: \"0\"  dir: \"5\"\n#   char linkname[100]; # ASCII + (Z unless filled)\n#   char magic[6];      # \"ustar\\0\"\n#   char version[2];    # \"00\"\n#   char uname[32];     # ASCIIZ\n#   char gname[32];     # ASCIIZ\n#   char devmajor[8];   # 0 padded, octal, null\n#   char devminor[8];   # o padded, octal, null\n#   char prefix[155];   # ASCII + (Z unless filled)\n# };\n#++\n# A header for a tar file\n\nclass Gem::Package::TarHeader\n\n  ##\n  # Fields in the tar header\n\n  FIELDS = [\n    :checksum,\n    :devmajor,\n    :devminor,\n    :gid,\n    :gname,\n    :linkname,\n    :magic,\n    :mode,\n    :mtime,\n    :name,\n    :prefix,\n    :size,\n    :typeflag,\n    :uid,\n    :uname,\n    :version,\n  ]\n\n  ##\n  # Pack format for a tar header\n\n  PACK_FORMAT = 'a100' + # name\n                'a8'   + # mode\n                'a8'   + # uid\n                'a8'   + # gid\n                'a12'  + # size\n                'a12'  + # mtime\n                'a7a'  + # chksum\n                'a'    + # typeflag\n                'a100' + # linkname\n                'a6'   + # magic\n                'a2'   + # version\n                'a32'  + # uname\n                'a32'  + # gname\n                'a8'   + # devmajor\n                'a8'   + # devminor\n                'a155'   # prefix\n\n  ##\n  # Unpack format for a tar header\n\n  UNPACK_FORMAT = 'A100' + # name\n                  'A8'   + # mode\n                  'A8'   + # uid\n                  'A8'   + # gid\n                  'A12'  + # size\n                  'A12'  + # mtime\n                  'A8'   + # checksum\n                  'A'    + # typeflag\n                  'A100' + # linkname\n                  'A6'   + # magic\n                  'A2'   + # version\n                  'A32'  + # uname\n                  'A32'  + # gname\n                  'A8'   + # devmajor\n                  'A8'   + # devminor\n                  'A155'   # prefix\n\n  attr_reader(*FIELDS)\n\n  ##\n  # Creates a tar header from IO +stream+\n\n  def self.from(stream)\n    header = stream.read 512\n    empty = (header == \"\\0\" * 512)\n\n    fields = header.unpack UNPACK_FORMAT\n\n    new :name     => fields.shift,\n        :mode     => fields.shift.oct,\n        :uid      => fields.shift.oct,\n        :gid      => fields.shift.oct,\n        :size     => fields.shift.oct,\n        :mtime    => fields.shift.oct,\n        :checksum => fields.shift.oct,\n        :typeflag => fields.shift,\n        :linkname => fields.shift,\n        :magic    => fields.shift,\n        :version  => fields.shift.oct,\n        :uname    => fields.shift,\n        :gname    => fields.shift,\n        :devmajor => fields.shift.oct,\n        :devminor => fields.shift.oct,\n        :prefix   => fields.shift,\n\n        :empty => empty\n  end\n\n  ##\n  # Creates a new TarHeader using +vals+\n\n  def initialize(vals)\n    unless vals[:name] && vals[:size] && vals[:prefix] && vals[:mode] then\n      raise ArgumentError, \":name, :size, :prefix and :mode required\"\n    end\n\n    vals[:uid] ||= 0\n    vals[:gid] ||= 0\n    vals[:mtime] ||= 0\n    vals[:checksum] ||= \"\"\n    vals[:typeflag] = \"0\" if vals[:typeflag].nil? || vals[:typeflag].empty?\n    vals[:magic] ||= \"ustar\"\n    vals[:version] ||= \"00\"\n    vals[:uname] ||= \"wheel\"\n    vals[:gname] ||= \"wheel\"\n    vals[:devmajor] ||= 0\n    vals[:devminor] ||= 0\n\n    FIELDS.each do |name|\n      instance_variable_set \"@#{name}\", vals[name]\n    end\n\n    @empty = vals[:empty]\n  end\n\n  ##\n  # Is the tar entry empty?\n\n  def empty?\n    @empty\n  end\n\n  def ==(other) # :nodoc:\n    self.class === other and\n    @checksum == other.checksum and\n    @devmajor == other.devmajor and\n    @devminor == other.devminor and\n    @gid      == other.gid      and\n    @gname    == other.gname    and\n    @linkname == other.linkname and\n    @magic    == other.magic    and\n    @mode     == other.mode     and\n    @mtime    == other.mtime    and\n    @name     == other.name     and\n    @prefix   == other.prefix   and\n    @size     == other.size     and\n    @typeflag == other.typeflag and\n    @uid      == other.uid      and\n    @uname    == other.uname    and\n    @version  == other.version\n  end\n\n  def to_s # :nodoc:\n    update_checksum\n    header\n  end\n\n  ##\n  # Updates the TarHeader's checksum\n\n  def update_checksum\n    header = header \" \" * 8\n    @checksum = oct calculate_checksum(header), 6\n  end\n\n  private\n\n  def calculate_checksum(header)\n    header.unpack(\"C*\").inject { |a, b| a + b }\n  end\n\n  def header(checksum = @checksum)\n    header = [\n      name,\n      oct(mode, 7),\n      oct(uid, 7),\n      oct(gid, 7),\n      oct(size, 11),\n      oct(mtime, 11),\n      checksum,\n      \" \",\n      typeflag,\n      linkname,\n      magic,\n      oct(version, 2),\n      uname,\n      gname,\n      oct(devmajor, 7),\n      oct(devminor, 7),\n      prefix\n    ]\n\n    header = header.pack PACK_FORMAT\n\n    header << (\"\\0\" * ((512 - header.size) % 512))\n  end\n\n  def oct(num, len)\n    \"%0#{len}o\" % num\n  end\n\nend\n", "# frozen_string_literal: true\nrequire 'rubygems/package/tar_test_case'\nrequire 'rubygems/package'\n\nclass TestGemPackageTarHeader < Gem::Package::TarTestCase\n\n  def setup\n    super\n\n    header = {\n      :name     => 'x',\n      :mode     => 0644,\n      :uid      => 1000,\n      :gid      => 10000,\n      :size     => 100,\n      :mtime    => 12345,\n      :typeflag => '0',\n      :linkname => 'link',\n      :uname    => 'user',\n      :gname    => 'group',\n      :devmajor => 1,\n      :devminor => 2,\n      :prefix   => 'y',\n    }\n\n    @tar_header = Gem::Package::TarHeader.new header\n  end\n\n  def test_self_from\n    io = TempIO.new @tar_header.to_s\n\n    new_header = Gem::Package::TarHeader.from io\n\n    assert_headers_equal @tar_header, new_header\n  ensure\n    io.close!\n  end\n\n  def test_initialize\n    assert_equal '',      @tar_header.checksum, 'checksum'\n    assert_equal 1,       @tar_header.devmajor, 'devmajor'\n    assert_equal 2,       @tar_header.devminor, 'devminor'\n    assert_equal 10000,   @tar_header.gid,      'gid'\n    assert_equal 'group', @tar_header.gname,    'gname'\n    assert_equal 'link',  @tar_header.linkname, 'linkname'\n    assert_equal 'ustar', @tar_header.magic,    'magic'\n    assert_equal 0644,    @tar_header.mode,     'mode'\n    assert_equal 12345,   @tar_header.mtime,    'mtime'\n    assert_equal 'x',     @tar_header.name,     'name'\n    assert_equal 'y',     @tar_header.prefix,   'prefix'\n    assert_equal 100,     @tar_header.size,     'size'\n    assert_equal '0',     @tar_header.typeflag, 'typeflag'\n    assert_equal 1000,    @tar_header.uid,      'uid'\n    assert_equal 'user',  @tar_header.uname,    'uname'\n    assert_equal '00',    @tar_header.version,  'version'\n\n    refute_empty @tar_header, 'empty'\n  end\n\n  def test_initialize_bad\n    assert_raises ArgumentError do\n      Gem::Package::TarHeader.new :name => '', :size => '', :mode => ''\n    end\n\n    assert_raises ArgumentError do\n      Gem::Package::TarHeader.new :name => '', :size => '', :prefix => ''\n    end\n\n    assert_raises ArgumentError do\n      Gem::Package::TarHeader.new :name => '', :prefix => '', :mode => ''\n    end\n\n    assert_raises ArgumentError do\n      Gem::Package::TarHeader.new :prefix => '', :size => '', :mode => ''\n    end\n  end\n\n  def test_initialize_typeflag\n    header = {\n      :mode     => '',\n      :name     => '',\n      :prefix   => '',\n      :size     => '',\n      :typeflag => '',\n    }\n\n    tar_header = Gem::Package::TarHeader.new header\n\n    assert_equal '0', tar_header.typeflag\n  end\n\n  def test_empty_eh\n    refute_empty @tar_header\n\n    @tar_header = Gem::Package::TarHeader.new :name => 'x', :prefix => '',\n                                              :mode => 0, :size => 0,\n                                              :empty => true\n\n    assert_empty @tar_header\n  end\n\n  def test_equals2\n    assert_equal @tar_header, @tar_header\n    assert_equal @tar_header, @tar_header.dup\n  end\n\n  def test_to_s\n    expected = <<-EOF.split(\"\\n\").join\nx\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\0000000644\\0000001750\\0000023420\\00000000000144\\00000000030071\n\\000012467\\000 0link\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000ustar\\00000user\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\ngroup\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\0000000001\\0000000002\\000y\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n    EOF\n\n    assert_headers_equal expected, @tar_header\n  end\n\n  def test_update_checksum\n    assert_equal '', @tar_header.checksum\n\n    @tar_header.update_checksum\n\n    assert_equal '012467', @tar_header.checksum\n  end\n\nend\n\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n# frozen_string_literal: true\n#--\n# Copyright (C) 2004 Mauricio Julio Fern\u00e1ndez Pradier\n# See LICENSE.txt for additional licensing information.\n#++\n\n##\n#--\n# struct tarfile_entry_posix {\n#   char name[100];     # ASCII + (Z unless filled)\n#   char mode[8];       # 0 padded, octal, null\n#   char uid[8];        # ditto\n#   char gid[8];        # ditto\n#   char size[12];      # 0 padded, octal, null\n#   char mtime[12];     # 0 padded, octal, null\n#   char checksum[8];   # 0 padded, octal, null, space\n#   char typeflag[1];   # file: \"0\"  dir: \"5\"\n#   char linkname[100]; # ASCII + (Z unless filled)\n#   char magic[6];      # \"ustar\\0\"\n#   char version[2];    # \"00\"\n#   char uname[32];     # ASCIIZ\n#   char gname[32];     # ASCIIZ\n#   char devmajor[8];   # 0 padded, octal, null\n#   char devminor[8];   # o padded, octal, null\n#   char prefix[155];   # ASCII + (Z unless filled)\n# };\n#++\n# A header for a tar file\n\nclass Gem::Package::TarHeader\n\n  ##\n  # Fields in the tar header\n\n  FIELDS = [\n    :checksum,\n    :devmajor,\n    :devminor,\n    :gid,\n    :gname,\n    :linkname,\n    :magic,\n    :mode,\n    :mtime,\n    :name,\n    :prefix,\n    :size,\n    :typeflag,\n    :uid,\n    :uname,\n    :version,\n  ]\n\n  ##\n  # Pack format for a tar header\n\n  PACK_FORMAT = 'a100' + # name\n                'a8'   + # mode\n                'a8'   + # uid\n                'a8'   + # gid\n                'a12'  + # size\n                'a12'  + # mtime\n                'a7a'  + # chksum\n                'a'    + # typeflag\n                'a100' + # linkname\n                'a6'   + # magic\n                'a2'   + # version\n                'a32'  + # uname\n                'a32'  + # gname\n                'a8'   + # devmajor\n                'a8'   + # devminor\n                'a155'   # prefix\n\n  ##\n  # Unpack format for a tar header\n\n  UNPACK_FORMAT = 'A100' + # name\n                  'A8'   + # mode\n                  'A8'   + # uid\n                  'A8'   + # gid\n                  'A12'  + # size\n                  'A12'  + # mtime\n                  'A8'   + # checksum\n                  'A'    + # typeflag\n                  'A100' + # linkname\n                  'A6'   + # magic\n                  'A2'   + # version\n                  'A32'  + # uname\n                  'A32'  + # gname\n                  'A8'   + # devmajor\n                  'A8'   + # devminor\n                  'A155'   # prefix\n\n  attr_reader(*FIELDS)\n\n  ##\n  # Creates a tar header from IO +stream+\n\n  def self.from(stream)\n    header = stream.read 512\n    empty = (header == \"\\0\" * 512)\n\n    fields = header.unpack UNPACK_FORMAT\n\n    new :name     => fields.shift,\n        :mode     => strict_oct(fields.shift),\n        :uid      => strict_oct(fields.shift),\n        :gid      => strict_oct(fields.shift),\n        :size     => strict_oct(fields.shift),\n        :mtime    => strict_oct(fields.shift),\n        :checksum => strict_oct(fields.shift),\n        :typeflag => fields.shift,\n        :linkname => fields.shift,\n        :magic    => fields.shift,\n        :version  => strict_oct(fields.shift),\n        :uname    => fields.shift,\n        :gname    => fields.shift,\n        :devmajor => strict_oct(fields.shift),\n        :devminor => strict_oct(fields.shift),\n        :prefix   => fields.shift,\n\n        :empty => empty\n  end\n\n  def self.strict_oct(str)\n    return str.oct if str =~ /\\A[0-7]*\\z/\n    raise ArgumentError, \"#{str.inspect} is not an octal string\"\n  end\n\n  ##\n  # Creates a new TarHeader using +vals+\n\n  def initialize(vals)\n    unless vals[:name] && vals[:size] && vals[:prefix] && vals[:mode] then\n      raise ArgumentError, \":name, :size, :prefix and :mode required\"\n    end\n\n    vals[:uid] ||= 0\n    vals[:gid] ||= 0\n    vals[:mtime] ||= 0\n    vals[:checksum] ||= \"\"\n    vals[:typeflag] = \"0\" if vals[:typeflag].nil? || vals[:typeflag].empty?\n    vals[:magic] ||= \"ustar\"\n    vals[:version] ||= \"00\"\n    vals[:uname] ||= \"wheel\"\n    vals[:gname] ||= \"wheel\"\n    vals[:devmajor] ||= 0\n    vals[:devminor] ||= 0\n\n    FIELDS.each do |name|\n      instance_variable_set \"@#{name}\", vals[name]\n    end\n\n    @empty = vals[:empty]\n  end\n\n  ##\n  # Is the tar entry empty?\n\n  def empty?\n    @empty\n  end\n\n  def ==(other) # :nodoc:\n    self.class === other and\n    @checksum == other.checksum and\n    @devmajor == other.devmajor and\n    @devminor == other.devminor and\n    @gid      == other.gid      and\n    @gname    == other.gname    and\n    @linkname == other.linkname and\n    @magic    == other.magic    and\n    @mode     == other.mode     and\n    @mtime    == other.mtime    and\n    @name     == other.name     and\n    @prefix   == other.prefix   and\n    @size     == other.size     and\n    @typeflag == other.typeflag and\n    @uid      == other.uid      and\n    @uname    == other.uname    and\n    @version  == other.version\n  end\n\n  def to_s # :nodoc:\n    update_checksum\n    header\n  end\n\n  ##\n  # Updates the TarHeader's checksum\n\n  def update_checksum\n    header = header \" \" * 8\n    @checksum = oct calculate_checksum(header), 6\n  end\n\n  private\n\n  def calculate_checksum(header)\n    header.unpack(\"C*\").inject { |a, b| a + b }\n  end\n\n  def header(checksum = @checksum)\n    header = [\n      name,\n      oct(mode, 7),\n      oct(uid, 7),\n      oct(gid, 7),\n      oct(size, 11),\n      oct(mtime, 11),\n      checksum,\n      \" \",\n      typeflag,\n      linkname,\n      magic,\n      oct(version, 2),\n      uname,\n      gname,\n      oct(devmajor, 7),\n      oct(devminor, 7),\n      prefix\n    ]\n\n    header = header.pack PACK_FORMAT\n\n    header << (\"\\0\" * ((512 - header.size) % 512))\n  end\n\n  def oct(num, len)\n    \"%0#{len}o\" % num\n  end\n\nend\n", "# frozen_string_literal: true\nrequire 'rubygems/package/tar_test_case'\nrequire 'rubygems/package'\n\nclass TestGemPackageTarHeader < Gem::Package::TarTestCase\n\n  def setup\n    super\n\n    header = {\n      :name     => 'x',\n      :mode     => 0644,\n      :uid      => 1000,\n      :gid      => 10000,\n      :size     => 100,\n      :mtime    => 12345,\n      :typeflag => '0',\n      :linkname => 'link',\n      :uname    => 'user',\n      :gname    => 'group',\n      :devmajor => 1,\n      :devminor => 2,\n      :prefix   => 'y',\n    }\n\n    @tar_header = Gem::Package::TarHeader.new header\n  end\n\n  def test_self_from\n    io = TempIO.new @tar_header.to_s\n\n    new_header = Gem::Package::TarHeader.from io\n\n    assert_headers_equal @tar_header, new_header\n  ensure\n    io.close!\n  end\n\n  def test_initialize\n    assert_equal '',      @tar_header.checksum, 'checksum'\n    assert_equal 1,       @tar_header.devmajor, 'devmajor'\n    assert_equal 2,       @tar_header.devminor, 'devminor'\n    assert_equal 10000,   @tar_header.gid,      'gid'\n    assert_equal 'group', @tar_header.gname,    'gname'\n    assert_equal 'link',  @tar_header.linkname, 'linkname'\n    assert_equal 'ustar', @tar_header.magic,    'magic'\n    assert_equal 0644,    @tar_header.mode,     'mode'\n    assert_equal 12345,   @tar_header.mtime,    'mtime'\n    assert_equal 'x',     @tar_header.name,     'name'\n    assert_equal 'y',     @tar_header.prefix,   'prefix'\n    assert_equal 100,     @tar_header.size,     'size'\n    assert_equal '0',     @tar_header.typeflag, 'typeflag'\n    assert_equal 1000,    @tar_header.uid,      'uid'\n    assert_equal 'user',  @tar_header.uname,    'uname'\n    assert_equal '00',    @tar_header.version,  'version'\n\n    refute_empty @tar_header, 'empty'\n  end\n\n  def test_initialize_bad\n    assert_raises ArgumentError do\n      Gem::Package::TarHeader.new :name => '', :size => '', :mode => ''\n    end\n\n    assert_raises ArgumentError do\n      Gem::Package::TarHeader.new :name => '', :size => '', :prefix => ''\n    end\n\n    assert_raises ArgumentError do\n      Gem::Package::TarHeader.new :name => '', :prefix => '', :mode => ''\n    end\n\n    assert_raises ArgumentError do\n      Gem::Package::TarHeader.new :prefix => '', :size => '', :mode => ''\n    end\n  end\n\n  def test_initialize_typeflag\n    header = {\n      :mode     => '',\n      :name     => '',\n      :prefix   => '',\n      :size     => '',\n      :typeflag => '',\n    }\n\n    tar_header = Gem::Package::TarHeader.new header\n\n    assert_equal '0', tar_header.typeflag\n  end\n\n  def test_empty_eh\n    refute_empty @tar_header\n\n    @tar_header = Gem::Package::TarHeader.new :name => 'x', :prefix => '',\n                                              :mode => 0, :size => 0,\n                                              :empty => true\n\n    assert_empty @tar_header\n  end\n\n  def test_equals2\n    assert_equal @tar_header, @tar_header\n    assert_equal @tar_header, @tar_header.dup\n  end\n\n  def test_to_s\n    expected = <<-EOF.split(\"\\n\").join\nx\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\0000000644\\0000001750\\0000023420\\00000000000144\\00000000030071\n\\000012467\\000 0link\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000ustar\\00000user\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\ngroup\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\0000000001\\0000000002\\000y\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\n    EOF\n\n    assert_headers_equal expected, @tar_header\n  end\n\n  def test_update_checksum\n    assert_equal '', @tar_header.checksum\n\n    @tar_header.update_checksum\n\n    assert_equal '012467', @tar_header.checksum\n  end\n\n  def test_from_bad_octal\n    test_cases = [\n      \"00000006,44\\000\", # bogus character\n      \"00000006789\\000\", # non-octal digit\n      \"+0000001234\\000\", # positive sign\n      \"-0000001000\\000\", # negative sign\n      \"0x000123abc\\000\", # radix prefix\n    ]\n\n    test_cases.each do |val|\n      header_s = @tar_header.to_s\n      # overwrite the size field\n      header_s[124, 12] = val\n      io = TempIO.new header_s\n      assert_raises ArgumentError do\n        new_header = Gem::Package::TarHeader.from io\n      end\n    end\n  end\n\nend\n\n"], "filenames": ["lib/rubygems/package/tar_header.rb", "test/rubygems/test_gem_package_tar_header.rb"], "buggy_code_start_loc": [107, 145], "buggy_code_end_loc": [123, 145], "fixing_code_start_loc": [107, 146], "fixing_code_end_loc": [129, 166], "type": "CWE-835", "message": "RubyGems version Ruby 2.2 series: 2.2.9 and earlier, Ruby 2.3 series: 2.3.6 and earlier, Ruby 2.4 series: 2.4.3 and earlier, Ruby 2.5 series: 2.5.0 and earlier, prior to trunk revision 62422 contains a infinite loop caused by negative size vulnerability in ruby gem package tar header that can result in a negative size could cause an infinite loop.. This vulnerability appears to have been fixed in 2.7.6.", "other": {"cve": {"id": "CVE-2018-1000075", "sourceIdentifier": "cve@mitre.org", "published": "2018-03-13T15:29:00.550", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "RubyGems version Ruby 2.2 series: 2.2.9 and earlier, Ruby 2.3 series: 2.3.6 and earlier, Ruby 2.4 series: 2.4.3 and earlier, Ruby 2.5 series: 2.5.0 and earlier, prior to trunk revision 62422 contains a infinite loop caused by negative size vulnerability in ruby gem package tar header that can result in a negative size could cause an infinite loop.. This vulnerability appears to have been fixed in 2.7.6."}, {"lang": "es", "value": "Las versiones de RubyGems de la serie Ruby 2.2: 2.2.9 y anteriores, de la serie Ruby 2.3: 2.3.6 y anteriores, de la serie Ruby 2.4: 2.4.3 y anteriores, y de la serie Ruby 2.5: versiones 2.5.0 y anteriores, anteriores a la revisi\u00f3n del trunk 62422 contiene un bucle infinito provocado por una vulnerabilidad de tama\u00f1o negativo en la cabecera tar del paquete de ruby gem que puede resultar en un tama\u00f1o negativo que desemboque en un bucle infinito. La vulnerabilidad parece haber sido solucionada en la versi\u00f3n 2.7.6."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rubygems:rubygems:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.2.9", "matchCriteriaId": "BEE89FF0-0079-4DF5-ACFC-E1B5415E54F4"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rubygems:rubygems:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.3.6", "matchCriteriaId": "8080FB82-5445-4A17-9ECB-806991906E80"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rubygems:rubygems:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.4.3", "matchCriteriaId": "CCBC38C5-781E-4998-877D-42265F1DBD05"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rubygems:rubygems:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.5.0", "matchCriteriaId": "6ACE6376-2E27-4F56-9315-03367963DB09"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}]}]}], "references": [{"url": "http://blog.rubygems.org/2018/02/15/2.7.6-released.html", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-07/msg00036.html", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:3729", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:3730", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:3731", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:2028", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2020:0542", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2020:0591", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2020:0663", "source": "cve@mitre.org"}, {"url": "https://github.com/rubygems/rubygems/commit/92e98bf8f810bd812f919120d4832df51bc25d83", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/04/msg00000.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/04/msg00001.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/04/msg00023.html", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2018/07/msg00012.html", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2019/05/msg00028.html", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3621-1/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2018/dsa-4219", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2018/dsa-4259", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/rubygems/rubygems/commit/92e98bf8f810bd812f919120d4832df51bc25d83"}}