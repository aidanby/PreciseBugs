{"buggy_code": ["import { Component, componentQrl, isQwikComponent } from '../component/component.public';\nimport { parseQRL, serializeQRL } from '../qrl/qrl';\nimport { isQrl, QRLInternal } from '../qrl/qrl-class';\nimport type { QRL } from '../qrl/qrl.public';\nimport type { ContainerState, GetObject, MustGetObjID } from './container';\nimport { isResourceReturn, parseResourceReturn, serializeResource } from '../use/use-resource';\nimport {\n  isSubscriberDescriptor,\n  parseTask,\n  ResourceReturnInternal,\n  serializeWatch,\n  SubscriberEffect,\n} from '../use/use-task';\nimport { isDocument } from '../util/element';\nimport { SignalImpl, SignalWrapper } from '../state/signal';\nimport { Collector, collectSubscriptions, collectValue } from './pause';\nimport {\n  fastWeakSerialize,\n  getProxyManager,\n  LocalSubscriptionManager,\n  SubscriptionManager,\n  Subscriptions,\n} from '../state/common';\nimport { getOrCreateProxy } from '../state/store';\nimport { QObjectManagerSymbol } from '../state/constants';\nimport type { QwikElement } from '../render/dom/virtual-element';\n\n/**\n * 0, 8, 9, A, B, C, D\n\\0: null character (U+0000 NULL) (only if the next character is not a decimal digit; else it\u2019s an octal escape sequence)\n\\b: backspace (U+0008 BACKSPACE)\n\\t: horizontal tab (U+0009 CHARACTER TABULATION)\n\\n: line feed (U+000A LINE FEED)\n\\v: vertical tab (U+000B LINE TABULATION)\n\\f: form feed (U+000C FORM FEED)\n\\r: carriage return (U+000D CARRIAGE RETURN)\n\\\": double quote (U+0022 QUOTATION MARK)\n\\': single quote (U+0027 APOSTROPHE)\n\\\\: backslash (U+005C REVERSE SOLIDUS)\n */\nexport const UNDEFINED_PREFIX = '\\u0001';\n\nexport interface Serializer<T> {\n  prefix: string;\n  /**\n   * Return true if this serializer can serialize the given object.\n   */\n  test: (obj: any) => boolean;\n  /**\n   * Convert the object to a string.\n   */\n  serialize:\n    | ((obj: T, getObjID: MustGetObjID, containerState: ContainerState) => string)\n    | undefined;\n\n  /**\n   * Return of\n   */\n  collect?: (obj: T, collector: Collector, leaks: boolean | QwikElement) => void;\n\n  /**\n   * Deserialize the object.\n   */\n  prepare: (data: string, containerState: ContainerState, doc: Document) => T;\n  /**\n   * Second pass to fill in the object.\n   */\n  subs?: (obj: T, subs: Subscriptions[], containerState: ContainerState) => void;\n\n  /**\n   * Second pass to fill in the object.\n   */\n  fill: ((obj: T, getObject: GetObject, containerState: ContainerState) => void) | undefined;\n}\n\nconst QRLSerializer: Serializer<QRLInternal> = {\n  prefix: '\\u0002',\n  test: (v) => isQrl(v),\n  collect: (v, collector, leaks) => {\n    if (v.$captureRef$) {\n      for (const item of v.$captureRef$) {\n        collectValue(item, collector, leaks);\n      }\n    }\n    if (collector.$prefetch$ === 0) {\n      collector.$qrls$.push(v);\n    }\n  },\n  serialize: (obj, getObjId) => {\n    return serializeQRL(obj, {\n      $getObjId$: getObjId,\n    });\n  },\n  prepare: (data, containerState) => {\n    return parseQRL(data, containerState.$containerEl$);\n  },\n  fill: (qrl, getObject) => {\n    if (qrl.$capture$ && qrl.$capture$.length > 0) {\n      qrl.$captureRef$ = qrl.$capture$.map(getObject);\n      qrl.$capture$ = null;\n    }\n  },\n};\n\nconst WatchSerializer: Serializer<SubscriberEffect> = {\n  prefix: '\\u0003',\n  test: (v) => isSubscriberDescriptor(v),\n  collect: (v, collector, leaks) => {\n    collectValue(v.$qrl$, collector, leaks);\n    if (v.$state$) {\n      collectValue(v.$state$, collector, leaks);\n    }\n  },\n  serialize: (obj, getObjId) => serializeWatch(obj, getObjId),\n  prepare: (data) => parseTask(data) as any,\n  fill: (watch, getObject) => {\n    watch.$el$ = getObject(watch.$el$ as any);\n    watch.$qrl$ = getObject(watch.$qrl$ as any);\n    if (watch.$state$) {\n      watch.$state$ = getObject(watch.$state$ as any);\n    }\n  },\n};\n\nconst ResourceSerializer: Serializer<ResourceReturnInternal<any>> = {\n  prefix: '\\u0004',\n  test: (v) => isResourceReturn(v),\n  collect: (obj, collector, leaks) => {\n    collectValue(obj.value, collector, leaks);\n    collectValue(obj._resolved, collector, leaks);\n  },\n  serialize: (obj, getObjId) => {\n    return serializeResource(obj, getObjId);\n  },\n  prepare: (data) => {\n    return parseResourceReturn(data);\n  },\n  fill: (resource, getObject) => {\n    if (resource._state === 'resolved') {\n      resource._resolved = getObject(resource._resolved);\n      resource.value = Promise.resolve(resource._resolved);\n    } else if (resource._state === 'rejected') {\n      const p = Promise.reject(resource._error);\n      p.catch(() => null);\n      resource._error = getObject(resource._error);\n      resource.value = p;\n    }\n  },\n};\n\nconst URLSerializer: Serializer<URL> = {\n  prefix: '\\u0005',\n  test: (v) => v instanceof URL,\n  serialize: (obj) => obj.href,\n  prepare: (data) => new URL(data),\n  fill: undefined,\n};\n\nconst DateSerializer: Serializer<Date> = {\n  prefix: '\\u0006',\n  test: (v) => v instanceof Date,\n  serialize: (obj) => obj.toISOString(),\n  prepare: (data) => new Date(data),\n  fill: undefined,\n};\n\nconst RegexSerializer: Serializer<RegExp> = {\n  prefix: '\\u0007',\n  test: (v) => v instanceof RegExp,\n  serialize: (obj) => `${obj.flags} ${obj.source}`,\n  prepare: (data) => {\n    const space = data.indexOf(' ');\n    const source = data.slice(space + 1);\n    const flags = data.slice(0, space);\n    return new RegExp(source, flags);\n  },\n  fill: undefined,\n};\n\nconst ErrorSerializer: Serializer<Error> = {\n  prefix: '\\u000E',\n  test: (v) => v instanceof Error,\n  serialize: (obj) => {\n    return obj.message;\n  },\n  prepare: (text) => {\n    const err = new Error(text);\n    err.stack = undefined;\n    return err;\n  },\n  fill: undefined,\n};\n\nconst DocumentSerializer: Serializer<Document> = {\n  prefix: '\\u000F',\n  test: (v) => isDocument(v),\n  serialize: undefined,\n  prepare: (_, _c, doc) => {\n    return doc;\n  },\n  fill: undefined,\n};\n\nexport const SERIALIZABLE_STATE = Symbol('serializable-data');\nconst ComponentSerializer: Serializer<Component<any>> = {\n  prefix: '\\u0010',\n  test: (obj) => isQwikComponent(obj),\n  serialize: (obj, getObjId) => {\n    const [qrl]: [QRLInternal] = (obj as any)[SERIALIZABLE_STATE];\n    return serializeQRL(qrl, {\n      $getObjId$: getObjId,\n    });\n  },\n  prepare: (data, containerState) => {\n    const optionsIndex = data.indexOf('{');\n    const qrlString = optionsIndex == -1 ? data : data.slice(0, optionsIndex);\n    const qrl: QRL<any> = parseQRL(qrlString, containerState.$containerEl$);\n    return componentQrl(qrl);\n  },\n  fill: (component, getObject) => {\n    const [qrl]: [QRLInternal] = (component as any)[SERIALIZABLE_STATE];\n    if (qrl.$capture$ && qrl.$capture$.length > 0) {\n      qrl.$captureRef$ = qrl.$capture$.map(getObject);\n      qrl.$capture$ = null;\n    }\n  },\n};\n\nconst PureFunctionSerializer: Serializer<Function> = {\n  prefix: '\\u0011',\n  test: (obj) => typeof obj === 'function' && obj.__qwik_serializable__ !== undefined,\n  serialize: (obj) => {\n    return obj.toString();\n  },\n  prepare: (data) => {\n    const fn = new Function('return ' + data)();\n    fn.__qwik_serializable__ = true;\n    return fn;\n  },\n  fill: undefined,\n};\n\nconst SignalSerializer: Serializer<SignalImpl<any>> = {\n  prefix: '\\u0012',\n  test: (v) => v instanceof SignalImpl,\n  collect: (obj, collector, leaks) => {\n    collectValue(obj.untrackedValue, collector, leaks);\n    if (leaks === true) {\n      collectSubscriptions(obj[QObjectManagerSymbol], collector);\n    }\n    return obj;\n  },\n  serialize: (obj, getObjId) => {\n    return getObjId(obj.untrackedValue);\n  },\n  prepare: (data, containerState) => {\n    return new SignalImpl(data, containerState?.$subsManager$?.$createManager$(), 0);\n  },\n  subs: (signal, subs) => {\n    signal[QObjectManagerSymbol].$addSubs$(subs);\n  },\n  fill: (signal, getObject) => {\n    signal.untrackedValue = getObject(signal.untrackedValue);\n  },\n};\n\nconst SignalWrapperSerializer: Serializer<SignalWrapper<any, any>> = {\n  prefix: '\\u0013',\n  test: (v) => v instanceof SignalWrapper,\n  collect(obj, collector, leaks) {\n    collectValue(obj.ref, collector, leaks);\n    if (fastWeakSerialize(obj.ref)) {\n      const localManager = getProxyManager(obj.ref)!;\n      if (isTreeshakeable(collector.$containerState$.$subsManager$, localManager, leaks)) {\n        collectValue(obj.ref[obj.prop], collector, leaks);\n      }\n    }\n    return obj;\n  },\n  serialize: (obj, getObjId) => {\n    return `${getObjId(obj.ref)} ${obj.prop}`;\n  },\n  prepare: (data) => {\n    const [id, prop] = data.split(' ');\n    return new SignalWrapper(id as any, prop);\n  },\n  fill: (signal, getObject) => {\n    signal.ref = getObject(signal.ref);\n  },\n};\n\nconst NoFiniteNumberSerializer: Serializer<number> = {\n  prefix: '\\u0014',\n  test: (v) => typeof v === 'number',\n  serialize: (v) => {\n    return String(v);\n  },\n  prepare: (data) => {\n    return Number(data);\n  },\n  fill: undefined,\n};\n\nconst URLSearchParamsSerializer: Serializer<URLSearchParams> = {\n  prefix: '\\u0015',\n  test: (v) => v instanceof URLSearchParams,\n  serialize: (obj) => obj.toString(),\n  prepare: (data) => new URLSearchParams(data),\n  fill: undefined,\n};\n\nconst FormDataSerializer: Serializer<FormData> = {\n  prefix: '\\u0016',\n  test: (v) => typeof FormData !== 'undefined' && v instanceof globalThis.FormData,\n  serialize: (formData) => {\n    const array: [string, string][] = [];\n    formData.forEach((value, key) => {\n      if (typeof value === 'string') {\n        array.push([key, value]);\n      } else {\n        array.push([key, value.name]);\n      }\n    });\n    return JSON.stringify(array);\n  },\n  prepare: (data) => {\n    const array = JSON.parse(data);\n    const formData = new FormData();\n    for (const [key, value] of array) {\n      formData.append(key, value);\n    }\n    return formData;\n  },\n  fill: undefined,\n};\n\nconst serializers: Serializer<any>[] = [\n  QRLSerializer,\n  SignalSerializer,\n  SignalWrapperSerializer,\n  WatchSerializer,\n  ResourceSerializer,\n  URLSerializer,\n  DateSerializer,\n  RegexSerializer,\n  ErrorSerializer,\n  DocumentSerializer,\n  ComponentSerializer,\n  PureFunctionSerializer,\n  NoFiniteNumberSerializer,\n  URLSearchParamsSerializer,\n  FormDataSerializer,\n];\n\nconst collectorSerializers = /*#__PURE__*/ serializers.filter((a) => a.collect);\n\nexport const canSerialize = (obj: any): boolean => {\n  for (const s of serializers) {\n    if (s.test(obj)) {\n      return true;\n    }\n  }\n  return false;\n};\n\nexport const collectDeps = (obj: any, collector: Collector, leaks: boolean | QwikElement) => {\n  for (const s of collectorSerializers) {\n    if (s.test(obj)) {\n      s.collect!(obj, collector, leaks);\n      return true;\n    }\n  }\n  return false;\n};\n\nexport const serializeValue = (\n  obj: any,\n  getObjID: MustGetObjID,\n  containerState: ContainerState\n) => {\n  for (const s of serializers) {\n    if (s.test(obj)) {\n      let value = s.prefix;\n      if (s.serialize) {\n        value += s.serialize(obj, getObjID, containerState);\n      }\n      return value;\n    }\n  }\n  return undefined;\n};\n\nexport interface Parser {\n  prepare(data: string): any;\n  subs(obj: any, subs: Subscriptions[]): boolean;\n  fill(obj: any, getObject: GetObject): boolean;\n}\n\nexport const createParser = (containerState: ContainerState, doc: Document): Parser => {\n  const fillMap = new Map<any, Serializer<any>>();\n  const subsMap = new Map<any, Serializer<any>>();\n\n  return {\n    prepare(data: string) {\n      for (const s of serializers) {\n        const prefix = s.prefix;\n        if (data.startsWith(prefix)) {\n          const value = s.prepare(data.slice(prefix.length), containerState, doc);\n          if (s.fill) {\n            fillMap.set(value, s);\n          }\n          if (s.subs) {\n            subsMap.set(value, s);\n          }\n          return value;\n        }\n      }\n      return data;\n    },\n    subs(obj: any, subs: Subscriptions[]) {\n      const serializer = subsMap.get(obj);\n      if (serializer) {\n        serializer.subs!(obj, subs, containerState);\n        return true;\n      }\n      return false;\n    },\n    fill(obj: any, getObject: GetObject) {\n      const serializer = fillMap.get(obj);\n      if (serializer) {\n        serializer.fill!(obj, getObject, containerState);\n        return true;\n      }\n      return false;\n    },\n  };\n};\n\nexport const OBJECT_TRANSFORMS: Record<string, (obj: any, containerState: ContainerState) => any> =\n  {\n    '!': (obj: any, containerState: ContainerState) => {\n      return containerState.$proxyMap$.get(obj) ?? getOrCreateProxy(obj, containerState);\n    },\n    '~': (obj: any) => {\n      return Promise.resolve(obj);\n    },\n    _: (obj: any) => {\n      return Promise.reject(obj);\n    },\n  };\n\nconst isTreeshakeable = (\n  manager: SubscriptionManager,\n  target: LocalSubscriptionManager,\n  leaks: QwikElement | boolean\n) => {\n  if (typeof leaks === 'boolean') {\n    return leaks;\n  }\n  const localManager = manager.$groupToManagers$.get(leaks);\n  if (localManager && localManager.length > 0) {\n    if (localManager.length === 1) {\n      return localManager[0] !== target;\n    }\n  }\n  return false;\n};\n"], "fixing_code": ["import { Component, componentQrl, isQwikComponent } from '../component/component.public';\nimport { parseQRL, serializeQRL } from '../qrl/qrl';\nimport { isQrl, QRLInternal } from '../qrl/qrl-class';\nimport type { QRL } from '../qrl/qrl.public';\nimport type { ContainerState, GetObject, MustGetObjID } from './container';\nimport { isResourceReturn, parseResourceReturn, serializeResource } from '../use/use-resource';\nimport {\n  isSubscriberDescriptor,\n  parseTask,\n  ResourceReturnInternal,\n  serializeWatch,\n  SubscriberEffect,\n} from '../use/use-task';\nimport { isDocument } from '../util/element';\nimport { SignalImpl, SignalWrapper } from '../state/signal';\nimport { Collector, collectSubscriptions, collectValue } from './pause';\nimport {\n  fastWeakSerialize,\n  getProxyManager,\n  LocalSubscriptionManager,\n  SubscriptionManager,\n  Subscriptions,\n} from '../state/common';\nimport { getOrCreateProxy } from '../state/store';\nimport { QObjectManagerSymbol } from '../state/constants';\nimport type { QwikElement } from '../render/dom/virtual-element';\n\n/**\n * 0, 8, 9, A, B, C, D\n\\0: null character (U+0000 NULL) (only if the next character is not a decimal digit; else it\u2019s an octal escape sequence)\n\\b: backspace (U+0008 BACKSPACE)\n\\t: horizontal tab (U+0009 CHARACTER TABULATION)\n\\n: line feed (U+000A LINE FEED)\n\\v: vertical tab (U+000B LINE TABULATION)\n\\f: form feed (U+000C FORM FEED)\n\\r: carriage return (U+000D CARRIAGE RETURN)\n\\\": double quote (U+0022 QUOTATION MARK)\n\\': single quote (U+0027 APOSTROPHE)\n\\\\: backslash (U+005C REVERSE SOLIDUS)\n */\nexport const UNDEFINED_PREFIX = '\\u0001';\n\nexport interface Serializer<T> {\n  prefix: string;\n  /**\n   * Return true if this serializer can serialize the given object.\n   */\n  test: (obj: any) => boolean;\n  /**\n   * Convert the object to a string.\n   */\n  serialize:\n    | ((obj: T, getObjID: MustGetObjID, containerState: ContainerState) => string)\n    | undefined;\n\n  /**\n   * Return of\n   */\n  collect?: (obj: T, collector: Collector, leaks: boolean | QwikElement) => void;\n\n  /**\n   * Deserialize the object.\n   */\n  prepare: (data: string, containerState: ContainerState, doc: Document) => T;\n  /**\n   * Second pass to fill in the object.\n   */\n  subs?: (obj: T, subs: Subscriptions[], containerState: ContainerState) => void;\n\n  /**\n   * Second pass to fill in the object.\n   */\n  fill: ((obj: T, getObject: GetObject, containerState: ContainerState) => void) | undefined;\n}\n\nconst QRLSerializer: Serializer<QRLInternal> = {\n  prefix: '\\u0002',\n  test: (v) => isQrl(v),\n  collect: (v, collector, leaks) => {\n    if (v.$captureRef$) {\n      for (const item of v.$captureRef$) {\n        collectValue(item, collector, leaks);\n      }\n    }\n    if (collector.$prefetch$ === 0) {\n      collector.$qrls$.push(v);\n    }\n  },\n  serialize: (obj, getObjId) => {\n    return serializeQRL(obj, {\n      $getObjId$: getObjId,\n    });\n  },\n  prepare: (data, containerState) => {\n    return parseQRL(data, containerState.$containerEl$);\n  },\n  fill: (qrl, getObject) => {\n    if (qrl.$capture$ && qrl.$capture$.length > 0) {\n      qrl.$captureRef$ = qrl.$capture$.map(getObject);\n      qrl.$capture$ = null;\n    }\n  },\n};\n\nconst WatchSerializer: Serializer<SubscriberEffect> = {\n  prefix: '\\u0003',\n  test: (v) => isSubscriberDescriptor(v),\n  collect: (v, collector, leaks) => {\n    collectValue(v.$qrl$, collector, leaks);\n    if (v.$state$) {\n      collectValue(v.$state$, collector, leaks);\n    }\n  },\n  serialize: (obj, getObjId) => serializeWatch(obj, getObjId),\n  prepare: (data) => parseTask(data) as any,\n  fill: (watch, getObject) => {\n    watch.$el$ = getObject(watch.$el$ as any);\n    watch.$qrl$ = getObject(watch.$qrl$ as any);\n    if (watch.$state$) {\n      watch.$state$ = getObject(watch.$state$ as any);\n    }\n  },\n};\n\nconst ResourceSerializer: Serializer<ResourceReturnInternal<any>> = {\n  prefix: '\\u0004',\n  test: (v) => isResourceReturn(v),\n  collect: (obj, collector, leaks) => {\n    collectValue(obj.value, collector, leaks);\n    collectValue(obj._resolved, collector, leaks);\n  },\n  serialize: (obj, getObjId) => {\n    return serializeResource(obj, getObjId);\n  },\n  prepare: (data) => {\n    return parseResourceReturn(data);\n  },\n  fill: (resource, getObject) => {\n    if (resource._state === 'resolved') {\n      resource._resolved = getObject(resource._resolved);\n      resource.value = Promise.resolve(resource._resolved);\n    } else if (resource._state === 'rejected') {\n      const p = Promise.reject(resource._error);\n      p.catch(() => null);\n      resource._error = getObject(resource._error);\n      resource.value = p;\n    }\n  },\n};\n\nconst URLSerializer: Serializer<URL> = {\n  prefix: '\\u0005',\n  test: (v) => v instanceof URL,\n  serialize: (obj) => obj.href,\n  prepare: (data) => new URL(data),\n  fill: undefined,\n};\n\nconst DateSerializer: Serializer<Date> = {\n  prefix: '\\u0006',\n  test: (v) => v instanceof Date,\n  serialize: (obj) => obj.toISOString(),\n  prepare: (data) => new Date(data),\n  fill: undefined,\n};\n\nconst RegexSerializer: Serializer<RegExp> = {\n  prefix: '\\u0007',\n  test: (v) => v instanceof RegExp,\n  serialize: (obj) => `${obj.flags} ${obj.source}`,\n  prepare: (data) => {\n    const space = data.indexOf(' ');\n    const source = data.slice(space + 1);\n    const flags = data.slice(0, space);\n    return new RegExp(source, flags);\n  },\n  fill: undefined,\n};\n\nconst ErrorSerializer: Serializer<Error> = {\n  prefix: '\\u000E',\n  test: (v) => v instanceof Error,\n  serialize: (obj) => {\n    return obj.message;\n  },\n  prepare: (text) => {\n    const err = new Error(text);\n    err.stack = undefined;\n    return err;\n  },\n  fill: undefined,\n};\n\nconst DocumentSerializer: Serializer<Document> = {\n  prefix: '\\u000F',\n  test: (v) => isDocument(v),\n  serialize: undefined,\n  prepare: (_, _c, doc) => {\n    return doc;\n  },\n  fill: undefined,\n};\n\nexport const SERIALIZABLE_STATE = Symbol('serializable-data');\nconst ComponentSerializer: Serializer<Component<any>> = {\n  prefix: '\\u0010',\n  test: (obj) => isQwikComponent(obj),\n  serialize: (obj, getObjId) => {\n    const [qrl]: [QRLInternal] = (obj as any)[SERIALIZABLE_STATE];\n    return serializeQRL(qrl, {\n      $getObjId$: getObjId,\n    });\n  },\n  prepare: (data, containerState) => {\n    const optionsIndex = data.indexOf('{');\n    const qrlString = optionsIndex == -1 ? data : data.slice(0, optionsIndex);\n    const qrl: QRL<any> = parseQRL(qrlString, containerState.$containerEl$);\n    return componentQrl(qrl);\n  },\n  fill: (component, getObject) => {\n    const [qrl]: [QRLInternal] = (component as any)[SERIALIZABLE_STATE];\n    if (qrl.$capture$ && qrl.$capture$.length > 0) {\n      qrl.$captureRef$ = qrl.$capture$.map(getObject);\n      qrl.$capture$ = null;\n    }\n  },\n};\n\nconst SignalSerializer: Serializer<SignalImpl<any>> = {\n  prefix: '\\u0012',\n  test: (v) => v instanceof SignalImpl,\n  collect: (obj, collector, leaks) => {\n    collectValue(obj.untrackedValue, collector, leaks);\n    if (leaks === true) {\n      collectSubscriptions(obj[QObjectManagerSymbol], collector);\n    }\n    return obj;\n  },\n  serialize: (obj, getObjId) => {\n    return getObjId(obj.untrackedValue);\n  },\n  prepare: (data, containerState) => {\n    return new SignalImpl(data, containerState?.$subsManager$?.$createManager$(), 0);\n  },\n  subs: (signal, subs) => {\n    signal[QObjectManagerSymbol].$addSubs$(subs);\n  },\n  fill: (signal, getObject) => {\n    signal.untrackedValue = getObject(signal.untrackedValue);\n  },\n};\n\nconst SignalWrapperSerializer: Serializer<SignalWrapper<any, any>> = {\n  prefix: '\\u0013',\n  test: (v) => v instanceof SignalWrapper,\n  collect(obj, collector, leaks) {\n    collectValue(obj.ref, collector, leaks);\n    if (fastWeakSerialize(obj.ref)) {\n      const localManager = getProxyManager(obj.ref)!;\n      if (isTreeshakeable(collector.$containerState$.$subsManager$, localManager, leaks)) {\n        collectValue(obj.ref[obj.prop], collector, leaks);\n      }\n    }\n    return obj;\n  },\n  serialize: (obj, getObjId) => {\n    return `${getObjId(obj.ref)} ${obj.prop}`;\n  },\n  prepare: (data) => {\n    const [id, prop] = data.split(' ');\n    return new SignalWrapper(id as any, prop);\n  },\n  fill: (signal, getObject) => {\n    signal.ref = getObject(signal.ref);\n  },\n};\n\nconst NoFiniteNumberSerializer: Serializer<number> = {\n  prefix: '\\u0014',\n  test: (v) => typeof v === 'number',\n  serialize: (v) => {\n    return String(v);\n  },\n  prepare: (data) => {\n    return Number(data);\n  },\n  fill: undefined,\n};\n\nconst URLSearchParamsSerializer: Serializer<URLSearchParams> = {\n  prefix: '\\u0015',\n  test: (v) => v instanceof URLSearchParams,\n  serialize: (obj) => obj.toString(),\n  prepare: (data) => new URLSearchParams(data),\n  fill: undefined,\n};\n\nconst FormDataSerializer: Serializer<FormData> = {\n  prefix: '\\u0016',\n  test: (v) => typeof FormData !== 'undefined' && v instanceof globalThis.FormData,\n  serialize: (formData) => {\n    const array: [string, string][] = [];\n    formData.forEach((value, key) => {\n      if (typeof value === 'string') {\n        array.push([key, value]);\n      } else {\n        array.push([key, value.name]);\n      }\n    });\n    return JSON.stringify(array);\n  },\n  prepare: (data) => {\n    const array = JSON.parse(data);\n    const formData = new FormData();\n    for (const [key, value] of array) {\n      formData.append(key, value);\n    }\n    return formData;\n  },\n  fill: undefined,\n};\n\nconst serializers: Serializer<any>[] = [\n  QRLSerializer, ////////////// \\u0002\n  SignalSerializer, /////////// \\u0012\n  SignalWrapperSerializer, //// \\u0013\n  WatchSerializer, //////////// \\u0003\n  ResourceSerializer, ///////// \\u0004\n  URLSerializer, ////////////// \\u0005\n  DateSerializer, ///////////// \\u0006\n  RegexSerializer, //////////// \\u0007\n  ErrorSerializer, //////////// \\u000E\n  DocumentSerializer, ///////// \\u000F\n  ComponentSerializer, //////// \\u0010\n  NoFiniteNumberSerializer, /// \\u0014\n  URLSearchParamsSerializer, // \\u0015\n  FormDataSerializer, ///////// \\u0016\n];\n\nconst collectorSerializers = /*#__PURE__*/ serializers.filter((a) => a.collect);\n\nexport const canSerialize = (obj: any): boolean => {\n  for (const s of serializers) {\n    if (s.test(obj)) {\n      return true;\n    }\n  }\n  return false;\n};\n\nexport const collectDeps = (obj: any, collector: Collector, leaks: boolean | QwikElement) => {\n  for (const s of collectorSerializers) {\n    if (s.test(obj)) {\n      s.collect!(obj, collector, leaks);\n      return true;\n    }\n  }\n  return false;\n};\n\nexport const serializeValue = (\n  obj: any,\n  getObjID: MustGetObjID,\n  containerState: ContainerState\n) => {\n  for (const s of serializers) {\n    if (s.test(obj)) {\n      let value = s.prefix;\n      if (s.serialize) {\n        value += s.serialize(obj, getObjID, containerState);\n      }\n      return value;\n    }\n  }\n  return undefined;\n};\n\nexport interface Parser {\n  prepare(data: string): any;\n  subs(obj: any, subs: Subscriptions[]): boolean;\n  fill(obj: any, getObject: GetObject): boolean;\n}\n\nexport const createParser = (containerState: ContainerState, doc: Document): Parser => {\n  const fillMap = new Map<any, Serializer<any>>();\n  const subsMap = new Map<any, Serializer<any>>();\n\n  return {\n    prepare(data: string) {\n      for (const s of serializers) {\n        const prefix = s.prefix;\n        if (data.startsWith(prefix)) {\n          const value = s.prepare(data.slice(prefix.length), containerState, doc);\n          if (s.fill) {\n            fillMap.set(value, s);\n          }\n          if (s.subs) {\n            subsMap.set(value, s);\n          }\n          return value;\n        }\n      }\n      return data;\n    },\n    subs(obj: any, subs: Subscriptions[]) {\n      const serializer = subsMap.get(obj);\n      if (serializer) {\n        serializer.subs!(obj, subs, containerState);\n        return true;\n      }\n      return false;\n    },\n    fill(obj: any, getObject: GetObject) {\n      const serializer = fillMap.get(obj);\n      if (serializer) {\n        serializer.fill!(obj, getObject, containerState);\n        return true;\n      }\n      return false;\n    },\n  };\n};\n\nexport const OBJECT_TRANSFORMS: Record<string, (obj: any, containerState: ContainerState) => any> =\n  {\n    '!': (obj: any, containerState: ContainerState) => {\n      return containerState.$proxyMap$.get(obj) ?? getOrCreateProxy(obj, containerState);\n    },\n    '~': (obj: any) => {\n      return Promise.resolve(obj);\n    },\n    _: (obj: any) => {\n      return Promise.reject(obj);\n    },\n  };\n\nconst isTreeshakeable = (\n  manager: SubscriptionManager,\n  target: LocalSubscriptionManager,\n  leaks: QwikElement | boolean\n) => {\n  if (typeof leaks === 'boolean') {\n    return leaks;\n  }\n  const localManager = manager.$groupToManagers$.get(leaks);\n  if (localManager && localManager.length > 0) {\n    if (localManager.length === 1) {\n      return localManager[0] !== target;\n    }\n  }\n  return false;\n};\n"], "filenames": ["packages/qwik/src/core/container/serializers.ts"], "buggy_code_start_loc": [229], "buggy_code_end_loc": [353], "fixing_code_start_loc": [228], "fixing_code_end_loc": [338], "type": "CWE-94", "message": "Code Injection in GitHub repository builderio/qwik prior to 0.21.0.", "other": {"cve": {"id": "CVE-2023-1283", "sourceIdentifier": "security@huntr.dev", "published": "2023-03-08T22:15:09.683", "lastModified": "2023-03-14T19:39:32.307", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Code Injection in GitHub repository builderio/qwik prior to 0.21.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 6.0}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-94"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:builder:qwik:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.21.0", "matchCriteriaId": "1079FBE3-11D4-44DB-9B1E-7235D145D2C8"}]}]}], "references": [{"url": "https://github.com/builderio/qwik/commit/4d9ba6e098ae6e537aa55abb6b8369bb670ffe66", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/63f1ff91-48f3-4886-a179-103f1ddd8ff8", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/builderio/qwik/commit/4d9ba6e098ae6e537aa55abb6b8369bb670ffe66"}}