{"buggy_code": ["//\n// Wire\n// Copyright (C) 2018 Wire Swiss GmbH\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see http://www.gnu.org/licenses/.\n//\n\nimport Foundation\nimport WireProtos\n\nextension ZMConversation {\n        \n    func sortedUsers(_ users: Set<ZMUser>) -> [ZMUser] {\n        let nameDescriptor = NSSortDescriptor(key: \"normalizedName\", ascending: true)\n        let sortedUser = (users as NSSet?)?.sortedArray(using: [nameDescriptor]) as? [ZMUser]\n\n        return sortedUser ?? []\n    }\n    \n    @objc public var sortedActiveParticipants: [ZMUser] {\n        return sortedUsers(localParticipants)\n    }\n\n    \n    /// Whether the roles defined for this conversation should be re-downloaded\n    @NSManaged public var needsToDownloadRoles: Bool\n    \n    @objc\n    public var isSelfAnActiveMember: Bool {\n        return self.participantRoles.contains(where: { (role) -> Bool in\n            role.user.isSelfUser == true\n        })\n    }\n    // MARK: - keyPathsForValuesAffecting\n    \n    static var participantRolesKeys: [String] {\n        return [#keyPath(ZMConversation.participantRoles)]\n    }\n    \n    @objc\n    public class func keyPathsForValuesAffectingActiveParticipants() -> Set<String> {\n        return Set(participantRolesKeys)\n    }\n    \n    @objc\n    public class func keyPathsForValuesAffectingLocalParticipants() -> Set<String> {\n        return Set(participantRolesKeys)\n    }\n    \n    @objc\n    public class func keyPathsForValuesAffectingLocalParticipantRoles() -> Set<String> {\n        return Set(participantRolesKeys + [#keyPath(ZMConversation.participantRoles.role)])\n    }\n    \n    @objc\n    public class func keyPathsForValuesAffectingDisplayName() -> Set<String> {\n        return Set([ZMConversationConversationTypeKey,\n                    \"participantRoles.user.name\",\n                    \"connection.to.name\",\n                    \"connection.to.availability\",\n                    ZMConversationUserDefinedNameKey] +\n                   ZMConversation.participantRolesKeys)\n    }\n    \n    @objc\n    public class func keyPathsForValuesAffectingLocalParticipantsExcludingSelf() -> Set<String> {\n        return Set(ZMConversation.participantRolesKeys)\n    }\n    \n    //MARK: - Participants methods\n    \n    /// Participants that are in the conversation, according to the local state,\n    /// even if that state is not yet synchronized with the backend\n    @objc\n    public var localParticipantRoles: Set<ParticipantRole> {\n        return participantRoles\n    }\n    \n    /// Participants that are in the conversation, according to the local state\n    /// even if that state is not yet synchronized with the backend\n    @objc\n    public var localParticipants: Set<ZMUser> {\n        return Set(localParticipantRoles.map { $0.user })\n    }\n    \n    /// Participants that are in the conversation, according to the local state\n    /// even if that state is not yet synchronized with the backend\n\n    @objc\n    public var localParticipantsExcludingSelf: Set<ZMUser> {\n        return self.localParticipants.filter { !$0.isSelfUser }\n    }\n    \n    // MARK: - Participant operations\n    \n    /// Add participants to the conversation. The method will decide on its own whether\n    /// this operation need to be synchronized to the backend or not based on the current context.\n    /// If the operation is executed from the UI context, then the operation will be synchronized.\n    /// If the operation is executed from the sync context, then the operation will not be synchronized.\n    ///\n    /// The method will handle the case when the participant is already there, so it's safe to call\n    /// it multiple time for the same user. It will update the role if the user is already there with\n    /// a different role.\n    ///\n    /// The method will also check if the addition of the users will change the verification status, the archive\n    /// status, etc.\n    @objc\n    public func addParticipantAndUpdateConversationState(user: ZMUser, role: Role?) {\n        self.addParticipantsAndUpdateConversationState(usersAndRoles: [(user, role)])\n    }\n    \n    /// Add participants to the conversation. The method will decide on its own whether\n    /// this operation need to be synchronized to the backend or not based on the current context.\n    /// If the operation is executed from the UI context, then the operation will be synchronized.\n    /// If the operation is executed from the sync context, then the operation will not be synchronized.\n    ///\n    /// The method will handle the case when the participant is already there, so it's safe to call\n    /// it multiple time for the same user. It will update the role if the user is already there with\n    /// a different role.\n    ///\n    /// The method will also check if the addition of the users will change the verification status, the archive\n    /// status, etc.\n    @objc\n    public func addParticipantsAndUpdateConversationState(users: Set<ZMUser>, role: Role?) {\n        self.addParticipantsAndUpdateConversationState(usersAndRoles: users.map { ($0, role) })\n    }\n    \n    /// Add participants to the conversation. The method will decide on its own whether\n    /// this operation need to be synchronized to the backend or not based on the current context.\n    /// If the operation is executed from the UI context, then the operation will be synchronized.\n    /// If the operation is executed from the sync context, then the operation will not be synchronized.\n    ///\n    /// The method will handle the case when the participant is already there, so it's safe to call\n    /// it multiple time for the same user. It will update the role if the user is already there with\n    /// a different role.\n    ///\n    /// The method will also check if the addition of the users will change the verification status, the archive\n    /// status, etc.\n    public func addParticipantsAndUpdateConversationState(usersAndRoles: [(ZMUser, Role?)]) {\n        \n        // Is this a new conversation, or an existing one that is being updated?\n        let doesExistsOnBackend = self.remoteIdentifier != nil\n        \n        let addedRoles = usersAndRoles.compactMap { (user, role) -> ParticipantRole? in\n            guard !user.isAccountDeleted else { return nil }\n            \n            // make sure the role is the right team/conversation role\n            require(\n                role == nil || (role!.team == self.team || role!.conversation == self),\n                \"Tried to add a role that does not belong to the conversation\"\n            )\n            \n            guard let (result, pr) = updateExistingOrCreateParticipantRole(for: user, with: role) else { return nil }\n            return (result == .created) ? pr : nil\n        }\n        \n        let addedSelfUser = doesExistsOnBackend && addedRoles.contains(where: {$0.user.isSelfUser})\n        if addedSelfUser {\n            self.markToDownloadRolesIfNeeded()\n            self.needsToBeUpdatedFromBackend = true\n        }\n        \n        if !addedRoles.isEmpty {\n            self.checkIfArchivedStatusChanged(addedSelfUser: addedSelfUser)\n            self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}))\n        }\n    }\n\n    private enum FetchOrCreation {\n        case fetched\n        case created\n    }\n\n    // Fetch an existing role or create a new one if needed\n    // Returns whether it was created or found\n    private func updateExistingOrCreateParticipantRole(for user: ZMUser, with role: Role?) -> (FetchOrCreation, ParticipantRole)? {\n        \n        guard let moc = self.managedObjectContext else { return nil }\n        \n        // If the user is already there, just change the role\n        if let current = self.participantRoles.first(where: {$0.user == user}) {\n            if let role = role {\n                current.role = role\n            }\n            \n            return (.fetched, current)\n            \n        } else {\n            // A new participant role\n            let participantRole = ParticipantRole.insertNewObject(in: moc)\n            participantRole.conversation = self\n            participantRole.user = user\n            participantRole.role = role\n            \n            return (.created, participantRole)\n        }\n    }\n    \n    private func checkIfArchivedStatusChanged(addedSelfUser: Bool) {\n        if addedSelfUser &&\n            self.mutedStatus == MutedMessageOptionValue.none.rawValue &&\n            self.isArchived\n        {\n            self.isArchived = false\n        }\n    }\n    \n    private func checkIfVerificationLevelChanged(addedUsers: Set<ZMUser>) {\n        self.decreaseSecurityLevelIfNeededAfterDiscovering(clients: Set(addedUsers.flatMap { $0.clients }), causedBy: addedUsers)\n    }\n    \n    /// Remove participants to the conversation. The method will decide on its own whether\n    /// this operation need to be synchronized to the backend or not based on the current context.\n    /// If the operation is executed from the UI context, then the operation will be synchronized.\n    /// If the operation is executed from the sync context, then the operation will not be synchronized.\n    ///\n    /// The method will handle the case when the participant is not there, so it's safe to call\n    /// it even if the user is not there.\n    ///\n    /// The method will also check if the addition of the users will change the verification status, the archive\n    /// status, etc.\n    @objc\n    public func removeParticipantsAndUpdateConversationState(users: Set<ZMUser>, initiatingUser: ZMUser? = nil) {\n        \n        guard let moc = self.managedObjectContext else { return }\n        let existingUsers = Set(self.participantRoles.map { $0.user })\n        \n        let removedUsers = Set(users.compactMap { user -> ZMUser? in\n            \n            guard existingUsers.contains(user),\n                let existingRole = participantRoles.first(where: { $0.user == user })\n                else { return nil }\n            \n            participantRoles.remove(existingRole)\n            moc.delete(existingRole)\n            return user\n        })\n        \n        if !removedUsers.isEmpty {\n            let removedSelf = removedUsers.contains(where: { $0.isSelfUser })\n            self.checkIfArchivedStatusChanged(removedSelfUser: removedSelf, initiatingUser: initiatingUser)\n            self.checkIfVerificationLevelChanged(removedUsers: removedUsers)\n        }\n    }\n    \n    /// Remove participants to the conversation. The method will decide on its own whether\n    /// this operation need to be synchronized to the backend or not based on the current context.\n    /// If the operation is executed from the UI context, then the operation will be synchronized.\n    /// If the operation is executed from the sync context, then the operation will not be synchronized.\n    ///\n    /// The method will handle the case when the participant is not there, so it's safe to call\n    /// it even if the user is not there.\n    ///\n    /// The method will also check if the addition of the users will change the verification status, the archive\n    /// status, etc.\n    @objc\n    public func removeParticipantAndUpdateConversationState(user: ZMUser, initiatingUser: ZMUser? = nil) {\n        self.removeParticipantsAndUpdateConversationState(users: Set(arrayLiteral: user), initiatingUser: initiatingUser)\n    }\n    \n    private func checkIfArchivedStatusChanged(removedSelfUser: Bool, initiatingUser: ZMUser?) {\n        if removedSelfUser, let initiatingUser = initiatingUser {\n            self.isArchived = initiatingUser.isSelfUser\n        }\n    }\n    \n    private func checkIfVerificationLevelChanged(removedUsers: Set<ZMUser>) {\n        self.increaseSecurityLevelIfNeededAfterRemoving(users: removedUsers)\n    }\n    \n    \n    // MARK: - Conversation roles\n    \n    /// List of roles for the conversation whether it's linked with a team or not\n    @objc\n    public func getRoles() -> Set<Role> {\n        if let team = team {\n            return team.roles\n        }\n        return nonTeamRoles\n    }\n    \n    /// Check if roles are missing, and mark them to download if needed\n    @objc public func markToDownloadRolesIfNeeded() {\n        guard self.conversationType == .group else { return }\n        \n        let selfUser = ZMUser.selfUser(in: self.managedObjectContext!)\n        let notInMyTeam = self.teamRemoteIdentifier == nil ||\n            selfUser.team?.remoteIdentifier != self.teamRemoteIdentifier\n        \n        guard notInMyTeam else { return }\n        \n        if self.nonTeamRoles.isEmpty ||\n            self.nonTeamRoles.first(where: {!$0.actions.isEmpty}) == nil // there are no roles with actions\n        {\n            self.needsToDownloadRoles = true\n        }\n    }\n    \n    // MARK: - Utils\n    func has(participantWithId userId: UserId?) -> Bool {\n        return localParticipants.contains { $0.userId == userId }\n    }\n}\n\n\n", "//\n// Wire\n// Copyright (C) 2016 Wire Swiss GmbH\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see http://www.gnu.org/licenses/.\n//\n\nimport Foundation\nimport WireCryptobox\n\nprivate let zmLog = ZMSLog(tag: \"event-processing\")\n\n@objc public enum ZMConversationLegalHoldStatus: Int16 {\n    case disabled = 0\n    case pendingApproval = 1\n    case enabled = 2\n\n    public var denotesEnabledComplianceDevice: Bool {\n        switch self {\n        case .pendingApproval, .enabled:\n            return true\n        case .disabled:\n            return false\n        }\n    }\n}\n\n/**\n * Represents a set of client changes in a conversation.\n */\n\npublic struct ZMConversationRemoteClientChangeSet: OptionSet {\n    public let rawValue: Int\n\n    public init(rawValue: Int) {\n        self.rawValue = rawValue\n    }\n\n    /// Deleted clients were detected.\n    public static let deleted = ZMConversationRemoteClientChangeSet(rawValue: 1 << 0)\n\n    /// Missing clients were detected.\n    public static let missing = ZMConversationRemoteClientChangeSet(rawValue: 1 << 1)\n\n    /// Redundant clients were detected.\n    public static let redundant = ZMConversationRemoteClientChangeSet(rawValue: 1 << 2)\n}\n\n\nextension ZMConversation {\n\n    /// Contains current security level of conversation.\n    /// Client should check this property to properly annotate conversation.\n    @NSManaged public internal(set) var securityLevel: ZMConversationSecurityLevel\n\n    @NSManaged private var primitiveLegalHoldStatus: NSNumber\n    \n    /// Indicates that we need verify that our local knowledge of clients matches the clients known to the backend.\n    @NSManaged public internal(set) var needsToVerifyLegalHold: Bool\n\n    /// Whether the conversation is under legal hold.\n    @objc public internal(set) var legalHoldStatus: ZMConversationLegalHoldStatus {\n        get {\n            willAccessValue(forKey: #keyPath(legalHoldStatus))\n            defer { didAccessValue(forKey: #keyPath(legalHoldStatus)) }\n\n            if let status = ZMConversationLegalHoldStatus(rawValue: primitiveLegalHoldStatus.int16Value) {\n                return status\n            } else {\n                return .disabled\n            }\n        }\n        set {\n            willChangeValue(forKey: #keyPath(legalHoldStatus))\n            primitiveLegalHoldStatus = NSNumber(value: newValue.rawValue)\n            didChangeValue(forKey: #keyPath(legalHoldStatus))\n        }\n    }\n\n    /// Whether the conversation is under legal hold.\n    @objc public var isUnderLegalHold: Bool {\n        return legalHoldStatus.denotesEnabledComplianceDevice\n    }\n\n    /// Whether the self user can send messages in this conversation.\n    @objc public var selfUserCanSendMessages: Bool {\n        return !isReadOnly && securityLevel != .secureWithIgnored && legalHoldStatus != .pendingApproval\n    }\n    \n    /// Verify the legal hold subjects in the conversation. This will synchronize with the backend on who's currently under legal hold.\n    @objc public func verifyLegalHoldSubjects() {\n        needsToVerifyLegalHold = true\n        managedObjectContext?.saveOrRollback()\n    }\n\n    // MARK: - Events\n\n    /// Should be called when a message is received.\n    /// If the legal hold status hint inside the received message is different than the local status,\n    /// we update the local version to match the remote one.\n    public func updateSecurityLevelIfNeededAfterReceiving(message: GenericMessage, timestamp: Date) {\n        updateLegalHoldIfNeededWithHint(from: message, timestamp: timestamp)\n    }\n    \n    /// Should be called if we need to verify the legal hold status after fetching the clients in a conversation.\n    public func updateSecurityLevelIfNeededAfterFetchingClients(changes: ZMConversationRemoteClientChangeSet) {\n        needsToVerifyLegalHold = false\n\n        if changes.isEmpty {\n            applySecurityChanges(cause: .verifyLegalHold)\n        }\n    }\n\n    /// Should be called when client is trusted.\n    /// If the conversation became trusted, it will trigger UI notification and add system message for all devices verified\n    @objc(increaseSecurityLevelIfNeededAfterTrustingClients:)\n    public func increaseSecurityLevelIfNeededAfterTrusting(clients: Set<UserClient>) {\n         applySecurityChanges(cause: .verifiedClients(clients))\n    }\n\n    /// Should be called when client is deleted.\n    /// If the conversation became trusted, it will trigger UI notification and add system message for all devices verified\n    @objc(increaseSecurityLevelIfNeededAfterRemovingClientForUsers:)\n    public func increaseSecurityLevelIfNeededAfterRemoving(clients: [ZMUser: Set<UserClient>]) {\n        applySecurityChanges(cause: .removedClients(clients))\n    }\n\n    /// Should be called when a user is deleted.\n    /// If the conversation became trusted, it will trigger UI notification and add system message for all devices verified\n    @objc(increaseSecurityLevelIfNeededAfterRemovingUsers:)\n    public func increaseSecurityLevelIfNeededAfterRemoving(users: Set<ZMUser>) {\n        applySecurityChanges(cause: .removedUsers(users))\n    }\n\n    /// Should be called when a new client is discovered\n    @objc(decreaseSecurityLevelIfNeededAfterDiscoveringClients:causedByMessage:)\n    public func decreaseSecurityLevelIfNeededAfterDiscovering(clients: Set<UserClient>, causedBy message: ZMOTRMessage?) {\n        applySecurityChanges(cause: .addedClients(clients, source: message))\n    }\n    \n    /// Should be called when a new user is added to the conversation\n    @objc(decreaseSecurityLevelIfNeededAfterDiscoveringClients:causedByAddedUsers:)\n    public func decreaseSecurityLevelIfNeededAfterDiscovering(clients: Set<UserClient>, causedBy users: Set<ZMUser>) {\n        applySecurityChanges(cause: .addedUsers(users))\n    }\n\n    /// Should be called when a client is ignored\n    @objc(decreaseSecurityLevelIfNeededAfterIgnoringClients:)\n    public func decreaseSecurityLevelIfNeededAfterIgnoring(clients: Set<UserClient>) {\n        applySecurityChanges(cause: .ignoredClients(clients))\n    }\n\n    /// Applies the security changes for the set of users.\n    private func applySecurityChanges(cause: SecurityChangeCause) {\n        updateLegalHoldState(cause: cause)\n        updateSecurityLevel(cause: cause)\n    }\n\n    private func updateLegalHoldState(cause: SecurityChangeCause) {\n        guard !needsToVerifyLegalHold, !localParticipants.any({ $0.clients.any(\\.needsToBeUpdatedFromBackend) }) else {\n            // We don't update the legal hold status if we are still gathering information about which clients were added/deleted\n            return\n        }\n        \n        let detectedParticipantsUnderLegalHold = localParticipants.any(\\.isUnderLegalHold)\n\n        switch (legalHoldStatus, detectedParticipantsUnderLegalHold) {\n        case (.disabled, true):\n            legalHoldStatus = .pendingApproval\n            appendLegalHoldEnabledSystemMessageForConversation(cause: cause)\n            expireAllPendingMessagesBecauseOfSecurityLevelDegradation()\n\n        case (.pendingApproval, false), (.enabled, false):\n            legalHoldStatus = .disabled\n            appendLegalHoldDisabledSystemMessageForConversation()\n\n        default:\n            // no changes required\n            break\n        }\n    }\n\n    private func updateSecurityLevel(cause: SecurityChangeCause) {\n        switch cause {\n        case .addedUsers, .addedClients, .ignoredClients:\n            degradeSecurityLevelIfNeeded(for: cause)\n\n        case .removedUsers, .removedClients, .verifiedClients:\n            increaseSecurityLevelIfNeeded(for: cause)\n            \n        case .verifyLegalHold:\n            // no-op: verifying legal hold does not impact security level\n            break\n        }\n    }\n\n    private func increaseSecurityLevelIfNeeded(for cause: SecurityChangeCause) {\n        guard securityLevel != .secure &&\n            allUsersTrusted &&\n            allParticipantsHaveClients &&\n            conversationType != .connection else {\n                return\n        }\n\n        securityLevel = .secure\n        appendNewIsSecureSystemMessage(cause: cause)\n        notifyOnUI(name: ZMConversation.isVerifiedNotificationName)\n    }\n\n    private func degradeSecurityLevelIfNeeded(for cause: SecurityChangeCause) {\n        guard securityLevel == .secure && !allUsersTrusted else {\n            return\n        }\n\n        securityLevel = .secureWithIgnored\n\n        switch cause {\n        case .addedClients, .addedUsers:\n            appendNewAddedClientSystemMessage(cause: cause)\n            expireAllPendingMessagesBecauseOfSecurityLevelDegradation()\n        case .ignoredClients(let clients):\n            appendIgnoredClientsSystemMessage(ignored: clients)\n        default:\n            break\n        }\n    }\n\n    /// Update the legal hold status based on the hint of a message.    \n    private func updateLegalHoldIfNeededWithHint(from message: GenericMessage, timestamp: Date) {\n        switch message.legalHoldStatus {\n        case .enabled where !legalHoldStatus.denotesEnabledComplianceDevice:\n            needsToVerifyLegalHold = true\n            legalHoldStatus = .pendingApproval\n            appendLegalHoldEnabledSystemMessageForConversationAfterReceivingMessage(at: timestamp)\n            expireAllPendingMessagesBecauseOfSecurityLevelDegradation()\n        case .disabled where legalHoldStatus.denotesEnabledComplianceDevice:\n            needsToVerifyLegalHold = true\n            legalHoldStatus = .disabled\n            appendLegalHoldDisabledSystemMessageForConversationAfterReceivingMessage(at: timestamp)\n        default:\n            break\n        }\n    }\n\n    // MARK: - Messages\n\n    /// Creates a system message that inform that there are pontential lost messages, and that some users were added to the conversation\n    @objc public func appendNewPotentialGapSystemMessage(users: Set<ZMUser>?, timestamp: Date) {\n        \n        let previousLastMessage = lastMessage\n        let systemMessage = self.appendSystemMessage(type: .potentialGap,\n                                                     sender: ZMUser.selfUser(in: self.managedObjectContext!),\n                                                     users: users,\n                                                     clients: nil,\n                                                     timestamp: timestamp)\n        systemMessage.needsUpdatingUsers = true\n        \n        if let previousLastMessage = previousLastMessage as? ZMSystemMessage, previousLastMessage.systemMessageType == .potentialGap,\n           let previousLastMessageTimestamp = previousLastMessage.serverTimestamp, previousLastMessageTimestamp <= timestamp {\n            // In case the message before the new system message was also a system message of\n            // the type ZMSystemMessageTypePotentialGap, we delete the old one and update the\n            // users property of the new one to use old users and calculate the added / removed users\n            // from the time the previous one was added\n            systemMessage.users = previousLastMessage.users\n            self.managedObjectContext?.delete(previousLastMessage)\n        }\n    }\n\n    /// Creates the message that warns user about the fact that decryption of incoming message is failed\n    @objc(appendDecryptionFailedSystemMessageAtTime:sender:client:errorCode:)\n    public func appendDecryptionFailedSystemMessage(at date: Date?, sender: ZMUser, client: UserClient?, errorCode: Int) {\n        let type = (UInt32(errorCode) == CBOX_REMOTE_IDENTITY_CHANGED.rawValue) ? ZMSystemMessageType.decryptionFailed_RemoteIdentityChanged : ZMSystemMessageType.decryptionFailed\n        let clients = client.flatMap { Set(arrayLiteral: $0) } ?? Set<UserClient>()\n        let serverTimestamp = date ?? timestampAfterLastMessage()\n        let systemMessage = appendSystemMessage(type: type,\n                                               sender: sender,\n                                               users: nil,\n                                               clients: clients,\n                                               timestamp: serverTimestamp)\n        \n        systemMessage.senderClientID = client?.remoteIdentifier\n        systemMessage.decryptionErrorCode = NSNumber(integerLiteral: errorCode)\n    }\n\n    /// Adds the user to the list of participants if not already present and inserts a .participantsAdded system message\n    ///\n    /// - Parameters:\n    ///   - user: the participant to add\n    ///   - dateOptional: if provide a nil, current date will be used\n    public func addParticipantAndSystemMessageIfMissing(_ user: ZMUser, date dateOptional: Date?) {\n        let date = dateOptional ?? Date()\n\n        guard !user.isSelfUser, !localParticipants.contains(user) else { return }\n        \n        zmLog.debug(\"Sender: \\(user.remoteIdentifier?.transportString() ?? \"n/a\") missing from participant list: \\(localParticipants.map{ $0.remoteIdentifier} )\")\n        \n        switch conversationType {\n        case .group:\n            appendSystemMessage(type: .participantsAdded, sender: user, users: Set(arrayLiteral: user), clients: nil, timestamp: date)\n        case .oneOnOne, .connection:\n            if user.connection == nil {\n                user.connection = connection ?? ZMConnection.insertNewObject(in: managedObjectContext!)\n            } else if connection == nil {\n                connection = user.connection\n            }\n            user.connection?.needsToBeUpdatedFromBackend = true\n        default:\n            break\n        }\n        \n        // we will fetch the role once we fetch the entire convo metadata\n        self.addParticipantAndUpdateConversationState(user: user, role: nil)\n        \n        // A missing user indicate that we are out of sync with the BE so we'll re-sync the conversation\n        needsToBeUpdatedFromBackend = true\n    }\n\n    private func appendLegalHoldEnabledSystemMessageForConversation(cause: SecurityChangeCause) {\n        var timestamp : Date?\n        \n        if case .addedClients(_, let message) = cause, message?.conversation == self, message?.isUpdatingExistingMessage == false {\n            timestamp = self.timestamp(before: message)\n        }\n        \n        appendSystemMessage(type: .legalHoldEnabled,\n                            sender: ZMUser.selfUser(in: self.managedObjectContext!),\n                            users: nil,\n                            clients: nil,\n                            timestamp: timestamp ?? timestampAfterLastMessage())\n    }\n\n    private func appendLegalHoldEnabledSystemMessageForConversationAfterReceivingMessage(at timestamp: Date) {\n        appendSystemMessage(type: .legalHoldEnabled,\n                            sender: ZMUser.selfUser(in: self.managedObjectContext!),\n                            users: nil,\n                            clients: nil,\n                            timestamp: timestamp.previousNearestTimestamp)\n    }\n\n    private func appendLegalHoldDisabledSystemMessageForConversation() {\n        appendSystemMessage(type: .legalHoldDisabled,\n                            sender: ZMUser.selfUser(in: self.managedObjectContext!),\n                            users: nil,\n                            clients: nil,\n                            timestamp: timestampAfterLastMessage())\n    }\n\n    private func appendLegalHoldDisabledSystemMessageForConversationAfterReceivingMessage(at timestamp: Date) {\n        appendSystemMessage(type: .legalHoldDisabled,\n                            sender: ZMUser.selfUser(in: self.managedObjectContext!),\n                            users: nil,\n                            clients: nil,\n                            timestamp: timestamp.previousNearestTimestamp)\n    }\n\n}\n\n// MARK: - Messages resend/expiration\nextension ZMConversation {\n\n    private func acknowledgePrivacyChanges() {\n        precondition(managedObjectContext?.zm_isUserInterfaceContext == true)\n\n        // Downgrade the conversation to be unverified\n        if securityLevel == .secureWithIgnored {\n            securityLevel = .notSecure\n        }\n\n        // Accept legal hold\n        if legalHoldStatus == .pendingApproval {\n            legalHoldStatus = .enabled\n        }\n\n        managedObjectContext?.saveOrRollback()\n    }\n\n    private func resendPendingMessagesAfterPrivacyChanges() {\n        enumerateReverseMessagesThatCausedDegradationUntilFirstSystemMessageOnSyncContext {\n            $0.causedSecurityLevelDegradation = false\n            $0.resend()\n        }\n    }\n\n    private func discardPendingMessagesAfterPrivacyChanges() {\n        guard let syncMOC = managedObjectContext?.zm_sync else { return }\n        syncMOC.performGroupedBlock {\n            guard let conversation = (try? syncMOC.existingObject(with: self.objectID)) as? ZMConversation else { return }\n            conversation.clearMessagesThatCausedSecurityLevelDegradation()\n            syncMOC.saveOrRollback()\n        }\n    }\n\n    /// Accepts the privacy changes (legal hold and/or degradation) and resend the pending messages.\n    @objc(acknowledgePrivacyWarningWithResendIntent:) public func acknowledgePrivacyWarning(withResendIntent shouldResendMessages: Bool) {\n        acknowledgePrivacyChanges()\n\n        if shouldResendMessages {\n            resendPendingMessagesAfterPrivacyChanges()\n        } else {\n            discardPendingMessagesAfterPrivacyChanges()\n        }\n    }\n\n    /// Enumerates all messages from newest to oldest and apply a block to all ZMOTRMessage encountered, \n    /// halting the enumeration when a system message for security level degradation is found.\n    /// This is executed asychronously on the sync context\n    private func enumerateReverseMessagesThatCausedDegradationUntilFirstSystemMessageOnSyncContext(block: @escaping (ZMOTRMessage)->()) {\n        guard let syncMOC = self.managedObjectContext?.zm_sync else { return }\n        syncMOC.performGroupedBlock {\n            guard let conversation = (try? syncMOC.existingObject(with: self.objectID)) as? ZMConversation else { return }\n            conversation.messagesThatCausedSecurityLevelDegradation.forEach(block)\n            syncMOC.saveOrRollback()\n        }\n    }\n    \n    /// Expire all pending messages\n    fileprivate func expireAllPendingMessagesBecauseOfSecurityLevelDegradation() {\n        for message in undeliveredMessages {\n            if let clientMessage = message as? ZMClientMessage,\n                let genericMessage = clientMessage.underlyingMessage,\n                genericMessage.hasConfirmation {\n                // Delivery receipt: just expire it\n                message.expire()\n            } else {\n                // All other messages: expire and mark that it caused security degradation\n                message.expire()\n                message.causedSecurityLevelDegradation = true\n            }\n        }\n    }\n    \n    fileprivate var undeliveredMessages: [ZMOTRMessage] {\n        guard let managedObjectContext = managedObjectContext else { return [] }\n        \n        let timeoutLimit = Date().addingTimeInterval(-ZMMessage.defaultExpirationTime())\n        let selfUser = ZMUser.selfUser(in: managedObjectContext)\n        let undeliveredMessagesPredicate = NSPredicate(format: \"%K == %@ AND %K == %@ AND %K == NO\",\n                                                       ZMMessageConversationKey, self,\n                                                       ZMMessageSenderKey, selfUser,\n                                                       DeliveredKey)\n        \n        let fetchRequest = NSFetchRequest<ZMClientMessage>(entityName: ZMClientMessage.entityName())\n        fetchRequest.predicate = undeliveredMessagesPredicate\n        \n        let assetFetchRequest = NSFetchRequest<ZMAssetClientMessage>(entityName: ZMAssetClientMessage.entityName())\n        assetFetchRequest.predicate = undeliveredMessagesPredicate\n        \n        var undeliveredMessages: [ZMOTRMessage] = []\n        undeliveredMessages += managedObjectContext.fetchOrAssert(request: fetchRequest) as [ZMOTRMessage]\n        undeliveredMessages += managedObjectContext.fetchOrAssert(request: assetFetchRequest) as [ZMOTRMessage]\n        \n        return undeliveredMessages.filter { message in\n            return message.serverTimestamp > timeoutLimit || message.updatedAt > timeoutLimit\n        }\n    }\n    \n}\n\n// MARK: - HotFix\nextension ZMConversation {\n\n    /// Replaces the first NewClient systemMessage for the selfClient with a UsingNewDevice system message\n    @objc public func replaceNewClientMessageIfNeededWithNewDeviceMesssage() {\n\n        let selfUser = ZMUser.selfUser(in: self.managedObjectContext!)\n        guard let selfClient = selfUser.selfClient() else { return }\n        \n        NSOrderedSet(array: lastMessages()).enumerateObjects() { (msg, idx, stop) in\n            guard idx <= 2 else {\n                stop.initialize(to: true)\n                return\n            }\n            \n            guard let systemMessage = msg as? ZMSystemMessage,\n                systemMessage.systemMessageType == .newClient,\n                systemMessage.sender == selfUser else {\n                    return\n            }\n            \n            if systemMessage.clients.contains(selfClient) {\n                systemMessage.systemMessageType = .usingNewDevice\n                stop.initialize(to: true)\n            }\n        }\n    }\n}\n\n// MARK: - Appending system messages\nextension ZMConversation {\n    \n    fileprivate func appendNewIsSecureSystemMessage(cause: SecurityChangeCause) {\n        switch cause {\n        case .removedUsers(let users):\n            appendNewIsSecureSystemMessage(verified: [], for: users)\n        case .verifiedClients(let userClients):\n            let users = Set(userClients.compactMap { $0.user })\n            appendNewIsSecureSystemMessage(verified: userClients, for: users)\n        case .removedClients(let userClients):\n            let users = Set(userClients.keys)\n            let clients = Set(userClients.values.flatMap { $0 })\n            appendNewIsSecureSystemMessage(verified: clients, for: users)\n        default:\n            // no-op: the conversation is not secure in other cases\n            return\n        }\n    }\n    \n    fileprivate func appendNewIsSecureSystemMessage(verified clients: Set<UserClient>, for users: Set<ZMUser>) {\n        guard !users.isEmpty, securityLevel != .secureWithIgnored else {\n            return\n        }\n\n        appendSystemMessage(type: .conversationIsSecure,\n                            sender: ZMUser.selfUser(in: self.managedObjectContext!),\n                            users: users,\n                            clients: clients,\n                            timestamp: timestampAfterLastMessage())\n    }\n    \n    fileprivate enum SecurityChangeCause {\n        case addedClients(Set<UserClient>, source: ZMOTRMessage?)\n        case addedUsers(Set<ZMUser>)\n        case removedUsers(Set<ZMUser>)\n        case verifiedClients(Set<UserClient>)\n        case removedClients([ZMUser: Set<UserClient>])\n        case ignoredClients(Set<UserClient>)\n        case verifyLegalHold\n    }\n    \n    fileprivate func appendNewAddedClientSystemMessage(cause: SecurityChangeCause) {\n        var timestamp : Date?\n        var affectedUsers: Set<ZMUser> = []\n        var addedUsers: Set<ZMUser> = []\n        var addedClients: Set<UserClient> = []\n        \n        switch cause {\n        case .addedUsers(let users):\n            affectedUsers = users\n            addedUsers = users\n        case .addedClients(let clients, let message):\n            affectedUsers = Set(clients.compactMap(\\.user))\n            addedClients = clients\n            if let message = message, message.conversation == self {\n                timestamp = self.timestamp(before: message)\n            } else {\n                timestamp = clients.compactMap(\\.discoveryDate).first?.previousNearestTimestamp\n            }\n        default:\n            // unsupported cause\n            return\n        }\n        \n        guard !addedClients.isEmpty || !addedUsers.isEmpty else { return }\n        \n        self.appendSystemMessage(type: .newClient,\n                                 sender: ZMUser.selfUser(in: self.managedObjectContext!),\n                                 users: affectedUsers,\n                                 addedUsers: addedUsers,\n                                 clients: addedClients,\n                                 timestamp: timestamp ?? timestampAfterLastMessage())\n    }\n    \n    fileprivate func appendIgnoredClientsSystemMessage(ignored clients: Set<UserClient>) {\n        guard !clients.isEmpty else { return }\n        let users = Set(clients.compactMap { $0.user })\n        self.appendSystemMessage(type: .ignoredClient,\n                                 sender: ZMUser.selfUser(in: self.managedObjectContext!),\n                                 users: users,\n                                 clients: clients,\n                                 timestamp: timestampAfterLastMessage())\n    }\n    \n    @discardableResult\n    func appendSystemMessage(type: ZMSystemMessageType,\n                                         sender: ZMUser,\n                                         users: Set<ZMUser>?,\n                                         addedUsers: Set<ZMUser> = Set(),\n                                         clients: Set<UserClient>?,\n                                         timestamp: Date,\n                                         duration: TimeInterval? = nil,\n                                         messageTimer: Double? = nil,\n                                         relevantForStatus: Bool = true) -> ZMSystemMessage {\n        let systemMessage = ZMSystemMessage(nonce: UUID(), managedObjectContext: managedObjectContext!)\n        systemMessage.systemMessageType = type\n        systemMessage.sender = sender\n        systemMessage.users = users ?? Set()\n        systemMessage.addedUsers = addedUsers\n        systemMessage.clients = clients ?? Set()\n        systemMessage.serverTimestamp = timestamp\n        if let duration = duration {\n            systemMessage.duration = duration\n        }\n        \n        if let messageTimer = messageTimer {\n            systemMessage.messageTimer = NSNumber(value: messageTimer)\n        }\n        \n        systemMessage.relevantForConversationStatus = relevantForStatus\n        \n        self.append(systemMessage)\n        \n        return systemMessage\n    }\n    \n    /// Returns a timestamp that is shortly (as short as possible) before the given message,\n    /// or the last modified date if the message is nil\n    fileprivate func timestamp(before: ZMMessage?) -> Date? {\n        guard let timestamp = before?.serverTimestamp ?? self.lastModifiedDate else { return nil }\n        return timestamp.previousNearestTimestamp\n    }\n    \n    /// Returns a timestamp that is shortly (as short as possible) after the given message,\n    /// or the last modified date if the message is nil\n    fileprivate func timestamp(after: ZMConversationMessage?) -> Date? {\n        guard let timestamp = after?.serverTimestamp ?? self.lastModifiedDate else { return nil }\n        return timestamp.nextNearestTimestamp\n    }\n    \n    // Returns a timestamp that is shortly (as short as possible) after the last message in the conversation,\n    // or current time if there's no last message\n    fileprivate func timestampAfterLastMessage() -> Date {\n        return timestamp(after: lastMessage) ?? Date()\n    }\n}\n\n// MARK: - Conversation participants status\nextension ZMConversation {\n    \n    /// Returns true if all participants are connected to the self user and all participants are trusted\n    @objc\n    public var allUsersTrusted : Bool {\n        guard !localParticipants.isEmpty,\n              isSelfAnActiveMember else { return false }\n        \n        let hasOnlyTrustedUsers = localParticipants.allSatisfy { ($0.isTrusted && !$0.clients.isEmpty) }\n        \n        return hasOnlyTrustedUsers && !containsUnconnectedOrExternalParticipant\n    }\n    \n    fileprivate var containsUnconnectedOrExternalParticipant : Bool {\n        guard let managedObjectContext = self.managedObjectContext else {\n            return true\n        }\n        \n        let selfUser = ZMUser.selfUser(in: managedObjectContext)\n        return localParticipants.first {\n            if $0.isConnected || $0 == selfUser {\n                return false\n            } else if $0.isWirelessUser {\n                return false\n            }\n            else {\n                return selfUser.team == nil || $0.team != selfUser.team\n            }\n        } != nil\n    }\n    \n    fileprivate var allParticipantsHaveClients : Bool {\n        return self.localParticipants.first { $0.clients.count == 0 } == nil\n    }\n    \n    /// If true the conversation might still be trusted / ignored\n    @objc public var hasUntrustedClients : Bool {\n        return self.localParticipants.contains { !$0.isTrusted }\n    }\n}\n\n// MARK: - System messages\nextension ZMSystemMessage {\n\n    /// Fetch the first system message in the conversation about \"started to use this device\"\n    fileprivate static func fetchStartedUsingOnThisDeviceMessage(conversation: ZMConversation) -> ZMSystemMessage? {\n        guard let selfClient = ZMUser.selfUser(in: conversation.managedObjectContext!).selfClient() else { return nil }\n        let conversationPredicate = NSPredicate(format: \"%K == %@ OR %K == %@\", ZMMessageConversationKey, conversation, ZMMessageHiddenInConversationKey, conversation)\n        let newClientPredicate = NSPredicate(format: \"%K == %d\", ZMMessageSystemMessageTypeKey, ZMSystemMessageType.newClient.rawValue)\n        let containsSelfClient = NSPredicate(format: \"ANY %K == %@\", ZMMessageSystemMessageClientsKey, selfClient)\n        let compound = NSCompoundPredicate(andPredicateWithSubpredicates: [conversationPredicate, newClientPredicate, containsSelfClient])\n        \n        let fetchRequest = ZMSystemMessage.sortedFetchRequest(with: compound)\n        \n        let result = conversation.managedObjectContext!.fetchOrAssert(request: fetchRequest)\n        return result.first as? ZMSystemMessage\n    }\n}\n\nextension ZMMessage {\n    \n    /// True if the message is a \"conversation degraded because of new client\"\n    /// system message\n    fileprivate var isConversationNotVerifiedSystemMessage : Bool {\n        guard let system = self as? ZMSystemMessage else { return false }\n        return system.systemMessageType == .ignoredClient\n    }\n}\n\nextension Date {\n    var nextNearestTimestamp: Date {\n        return Date(timeIntervalSinceReferenceDate: timeIntervalSinceReferenceDate.nextUp)\n    }\n    var previousNearestTimestamp: Date {\n        return Date(timeIntervalSinceReferenceDate: timeIntervalSinceReferenceDate.nextDown)\n    }\n}\n\nextension NSDate {\n    @objc var nextNearestTimestamp: NSDate {\n        return NSDate(timeIntervalSinceReferenceDate: timeIntervalSinceReferenceDate.nextUp)\n    }\n    @objc var previousNearestTimestamp: NSDate {\n        return NSDate(timeIntervalSinceReferenceDate: timeIntervalSinceReferenceDate.nextDown)\n    }\n}\n", "//\n// Wire\n// Copyright (C) 2019 Wire Swiss GmbH\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see http://www.gnu.org/licenses/.\n//\n\nimport XCTest\n@testable import WireDataModel\n\nclass ZMConversationTests_SecurityLevel: ZMConversationTestsBase {\n    \n    private func createUsersWithClientsOnSyncMOC(count: Int) -> [ZMUser] {\n        self.selfUser = ZMUser.selfUser(in: self.syncMOC)\n        return (0..<count).map { i in\n            let user = ZMUser.insertNewObject(in: self.syncMOC)\n            let userClient = UserClient.insertNewObject(in: self.syncMOC)\n            let userConnection = ZMConnection.insertNewSentConnection(to: user)!\n            userConnection.status = .accepted\n            userClient.user = user\n            user.name = \"createdUser \\(i+1)\"\n            return user\n        }\n    }\n    \n    func testThatConversationInitialSecurityLevelIsNotSecured()\n    {\n        self.syncMOC.performGroupedAndWait {_ in\n            // given\n            let users = self.createUsersWithClientsOnSyncMOC(count: 2)\n            let conversation = ZMConversation.insertGroupConversation(moc: self.syncMOC, participants: users)!\n\n            // then\n            XCTAssertEqual(conversation.securityLevel, .notSecure)\n        }\n    }\n    \n    func testThatItIncreasesSecurityLevelIfAllClientsInConversationAreTrusted()\n    {\n        self.syncMOC.performGroupedAndWait {_ in\n            // given\n            let users = self.createUsersWithClientsOnSyncMOC(count: 2)\n            let conversation = ZMConversation.insertGroupConversation(moc: self.syncMOC, participants: users)!\n            let selfClient = self.createSelfClient(onMOC: self.syncMOC)\n            \n            // when\n            selfClient.trustClients(Set(users.map { $0.clients.first! }))\n            \n            // then\n            XCTAssertEqual(conversation.securityLevel, .secure)\n        }\n    }\n    \n    func testThatItDoesNotIncreaseTheSecurityLevelIfAConversationIsAConnection() {\n        self.syncMOC.performGroupedAndWait {_ in\n            // given\n            let selfUser = ZMUser.selfUser(in: self.uiMOC)\n            \n            let conversation = ZMConversation.insertNewObject(in: self.uiMOC)\n            conversation.conversationType = .connection\n            conversation.addParticipantAndUpdateConversationState(user: selfUser, role: nil)\n            let selfClient = self.createSelfClient(onMOC: self.uiMOC)\n            \n            let userClient = UserClient.insertNewObject(in: self.uiMOC)\n            userClient.remoteIdentifier = UUID.create().uuidString\n            userClient.user = selfUser\n            \n            // when\n            XCTAssertEqual(conversation.securityLevel, .notSecure)\n            XCTAssertFalse(conversation.allUsersTrusted)\n            \n            selfClient.trustClient(userClient)\n            conversation.increaseSecurityLevelIfNeededAfterTrusting(clients: Set([userClient]))\n            \n            // then\n            XCTAssertTrue(conversation.allUsersTrusted)\n            XCTAssertEqual(conversation.securityLevel, .notSecure)\n        }\n    }\n    \n    func testThatItDoesNotIncreaseTheSecurityLevelIfAConversationContainsUsersWithoutAConnection()\n    {\n        self.syncMOC.performGroupedAndWait {_ in\n            // given\n            let users = self.createUsersWithClientsOnSyncMOC(count: 2)\n            \n            let unconnectedUser = users.first!\n            let connectedUser = users.last!\n            unconnectedUser.connection!.status = .sent\n            \n            let conversation = ZMConversation.insertGroupConversation(moc: self.syncMOC, participants: users)!\n            let selfClient = self.createSelfClient(onMOC: self.syncMOC)\n            \n            // when\n            selfClient.trustClients(connectedUser.clients)\n            \n            // then\n            XCTAssertFalse(conversation.allUsersTrusted)\n            XCTAssertEqual(conversation.securityLevel, .notSecure)\n            \n            // when\n            unconnectedUser.connection!.status = .accepted\n            selfClient.trustClients(unconnectedUser.clients)\n            \n            // then\n            XCTAssertTrue(conversation.allUsersTrusted)\n            XCTAssertEqual(conversation.securityLevel, .secure)\n            \n            let newUnconnectedUser = ZMUser.insertNewObject(in: self.syncMOC)\n            let unconnectedUserClient = UserClient.insertNewObject(in: self.syncMOC)\n            unconnectedUserClient.user = newUnconnectedUser\n            \n            // when adding a new participant\n            conversation.addParticipantAndUpdateConversationState(user: newUnconnectedUser, role: nil)\n            \n            // then the conversation should degrade\n            XCTAssertFalse(conversation.allUsersTrusted)\n            XCTAssertEqual(conversation.securityLevel, .secureWithIgnored)\n            \n            // when\n            conversation.removeParticipantAndUpdateConversationState(user: newUnconnectedUser, initiatingUser:  self.selfUser)\n            \n            // then\n            XCTAssertTrue(conversation.allUsersTrusted)\n            XCTAssertEqual(conversation.securityLevel, .secure)\n        }\n    }\n\n    func testThatItIncreaseTheSecurityLevelIfAConversationContainsUsersWithoutAConnection_Wireless()\n    {\n        self.syncMOC.performGroupedAndWait {_ in\n            // given\n            let users = self.createUsersWithClientsOnSyncMOC(count: 2)\n            \n            let unconnectedUser = users.first!\n            let connectedUser = users.last!\n            unconnectedUser.expiresAt = Date(timeIntervalSinceNow: 60)\n            unconnectedUser.connection = nil\n            \n            XCTAssertTrue(unconnectedUser.isWirelessUser)\n            XCTAssertFalse(unconnectedUser.isConnected)\n            XCTAssertNil(unconnectedUser.team)\n            \n            let conversation = ZMConversation.insertGroupConversation(moc: self.syncMOC, participants: users)!\n            let selfClient = self.createSelfClient(onMOC: self.syncMOC)\n            \n            // when\n            selfClient.trustClients(connectedUser.clients)\n            selfClient.trustClients(unconnectedUser.clients)\n            \n            // then\n            XCTAssertTrue(conversation.allUsersTrusted)\n            XCTAssertEqual(conversation.securityLevel, .secure)\n        }\n    }\n    \n    func testThatItDoesDecreaseTheSecurityLevelWhenAskedToMakeNotSecure()\n    {\n        // given\n        let conversation = ZMConversation.insertNewObject(in: self.uiMOC)\n        conversation.conversationType = .oneOnOne\n        conversation.securityLevel = .secureWithIgnored\n        \n        // when\n        conversation.acknowledgePrivacyWarning(withResendIntent: false)\n        \n        // then\n        XCTAssertEqual(conversation.securityLevel, .notSecure)\n    }\n    \n    func testThatItInsertsAnIgnoredClientsSystemMessageWhenAddingAConversationParticipantInASecuredConversation()\n    {\n        self.syncMOC.performGroupedAndWait { _ in\n            // given\n            let users = self.createUsersWithClientsOnSyncMOC(count: 2)\n            \n            let conversation = ZMConversation.insertGroupConversation(moc: self.syncMOC, participants: users)!\n            let selfClient = self.createSelfClient(onMOC: self.syncMOC)\n            \n            // when\n            selfClient.trustClients(users.first!.clients)\n            selfClient.trustClients(users.last!.clients)\n            \n            // then\n            XCTAssertTrue(conversation.allUsersTrusted)\n            XCTAssertEqual(conversation.securityLevel, .secure)\n            \n            // when adding a new participant\n            let user3 = self.createUsersWithClientsOnSyncMOC(count: 1).last!\n            conversation.addParticipantAndUpdateConversationState(user: user3, role: nil)\n            \n            // then the conversation should degrade\n            XCTAssertFalse(conversation.allUsersTrusted)\n            XCTAssertEqual(conversation.securityLevel, .secureWithIgnored)\n            \n            // Conversation degraded message\n            let conversationDegradedMessage = conversation.lastMessage as? ZMSystemMessage\n            XCTAssertEqual(conversationDegradedMessage?.systemMessageType, .newClient)\n            XCTAssertEqual(conversationDegradedMessage?.addedUsers, Set([user3]))\n            XCTAssertEqual(conversationDegradedMessage?.users, Set([user3]))\n            \n            // when\n            conversation.removeParticipantAndUpdateConversationState(user: user3, initiatingUser:  self.selfUser)\n            \n            // then\n            XCTAssertTrue(conversation.allUsersTrusted)\n            XCTAssertEqual(conversation.securityLevel, .secure)\n            let message2 = conversation.lastMessage as? ZMSystemMessage\n            XCTAssertEqual(message2?.systemMessageType, .conversationIsSecure)\n        }\n    }\n    \n    func testThatItDoesNotIncreaseSecurityLevelIfNotAllClientsAreTrusted()\n    {\n        self.syncMOC.performGroupedAndWait { _ in\n            // given\n            let users = self.createUsersWithClientsOnSyncMOC(count: 2)\n            let conversation = ZMConversation.insertGroupConversation(moc: self.syncMOC, participants: users)!\n            let selfClient = self.createSelfClient(onMOC: self.syncMOC)\n            \n            // when\n            selfClient.trustClients(users.first!.clients)\n            \n            // then\n            XCTAssertEqual(conversation.securityLevel, .notSecure)\n        }\n    }\n    \n    func testThatItDoesNotIncreaseSecurityLevelIfNotAllUsersHaveClients()\n    {\n        self.syncMOC.performGroupedAndWait { _ in\n            // given\n            let userWithoutClients = ZMUser.insertNewObject(in: self.syncMOC)\n            let users = self.createUsersWithClientsOnSyncMOC(count: 2) + [userWithoutClients]\n            let conversation = ZMConversation.insertGroupConversation(moc: self.syncMOC, participants: users)!\n            let selfClient = self.createSelfClient(onMOC: self.syncMOC)\n            \n            let allClients = users.flatMap {\n                $0.clients\n            }\n            \n            // when\n            selfClient.trustClients(Set(allClients))\n            \n            // then\n            XCTAssertEqual(conversation.securityLevel, .notSecure)\n        }\n    }\n    \n    func testThatItDecreaseSecurityLevelIfSomeOfTheClientsIsIgnored()\n    {\n        self.syncMOC.performGroupedAndWait { _ in\n            // given\n            let users = self.createUsersWithClientsOnSyncMOC(count: 2)\n            let conversation = ZMConversation.insertGroupConversation(moc: self.syncMOC, participants: users)!\n            let selfClient = self.createSelfClient(onMOC: self.syncMOC)\n            \n            // when\n            selfClient.trustClients(users.first!.clients.union(users.last!.clients))\n            selfClient.ignoreClients(users.first!.clients)\n            \n            // then\n            XCTAssertEqual(conversation.securityLevel, .secureWithIgnored)\n        }\n    }\n    \n    func testThatItDoesNotDecreaseSecurityLevelIfItIsInPartialSecureLevel()\n    {\n        self.syncMOC.performGroupedAndWait { _ in\n            // given\n            let users = self.createUsersWithClientsOnSyncMOC(count: 2)\n            let conversation = ZMConversation.insertGroupConversation(moc: self.syncMOC, participants: users)!\n            let selfClient = self.createSelfClient(onMOC: self.syncMOC)\n            \n            // when\n            selfClient.trustClients(users.first!.clients.union(users.last!.clients))\n            selfClient.ignoreClients(users.first!.clients)\n            \n            // then\n            XCTAssertEqual(conversation.securityLevel, .secureWithIgnored)\n            \n            // and when\n            selfClient.ignoreClients(users.last!.clients)\n            \n            // then we should not change the security level as we were already ignored\n            XCTAssertEqual(conversation.securityLevel, .secureWithIgnored)\n        }\n    }\n    \n    func testThatItCorrectlySetsNeedUpdatingUsersFlagOnPotentialGapSystemMessage()\n    {\n        // given\n        let conversation = ZMConversation.insertNewObject(in: self.uiMOC)\n        conversation.remoteIdentifier = UUID.create()\n        conversation.appendNewPotentialGapSystemMessage(users: nil, timestamp: Date())\n        \n        // then\n        var fetchedMessage = ZMSystemMessage.fetchLatestPotentialGapSystemMessage(in: conversation)\n        XCTAssertEqual(conversation.allMessages.count, 1)\n        XCTAssertNotNil(fetchedMessage)\n        XCTAssertTrue(fetchedMessage!.needsUpdatingUsers)\n        \n        // when\n        conversation.updatePotentialGapSystemMessagesIfNeeded(users: Set())\n        \n        // then\n        XCTAssertFalse(fetchedMessage!.needsUpdatingUsers)\n        fetchedMessage = ZMSystemMessage.fetchLatestPotentialGapSystemMessage(in: conversation)\n        XCTAssertEqual(conversation.allMessages.count, 1)\n        XCTAssertNil(fetchedMessage)\n    }\n    \n    func testThatItNotifiesWhenAllClientAreVerified()\n    {\n        var conversationObjectID: NSManagedObjectID! = nil\n        var token: Any? = nil\n        self.syncMOC.performGroupedAndWait { _ in\n            // given\n            let users = self.createUsersWithClientsOnSyncMOC(count: 2)\n            let conversation = ZMConversation.insertGroupConversation(moc: self.syncMOC, participants: users)!\n            let selfClient = self.createSelfClient(onMOC: self.syncMOC)\n            \n            // expect\n            let expectation = self.expectation(description: \"Notified\")\n            token = NotificationInContext.addObserver(\n                name: ZMConversation.isVerifiedNotificationName,\n                context: self.uiMOC.notificationContext) {\n                    XCTAssertEqual($0.object as? ZMConversation, conversation)\n                    if ($0.object as? ZMConversation) == conversation {\n                        expectation.fulfill()\n                    }\n                }\n        \n            // when\n            XCTAssertNotEqual(conversation.securityLevel, .secure)\n            selfClient.trustClients(users.first!.clients.union(users.last!.clients))\n            \n            conversationObjectID = conversation.objectID\n            self.syncMOC.saveOrRollback()\n        }\n        \n        // then\n        let uiConversation = try! self.uiMOC.existingObject(with: conversationObjectID!) as! ZMConversation\n        XCTAssertEqual(uiConversation.securityLevel, .secure)\n        XCTAssertTrue(self.waitForCustomExpectations(withTimeout: 0.5))\n        _ = String(describing: token) // so that it does not complain that is never read\n    }\n    \n    func testThatIncreasesSecurityLevelOfCreatedGroupConversationWithAllParticipantsAlreadyTrusted()\n    {\n        \n        self.syncMOC.performGroupedAndWait { _ -> () in\n            // given\n            let users = self.createUsersWithClientsOnSyncMOC(count: 2)\n            let clients = users.first!.clients.union(users.last!.clients)\n            let selfClient = self.createSelfClient(onMOC: self.syncMOC)\n            selfClient.trustClients(clients)\n            \n            // when\n            let conversation = ZMConversation.insertGroupConversation(moc: self.syncMOC, participants: users)!\n            // then\n            XCTAssertEqual(conversation.securityLevel, .secure)\n            guard let message = conversation.lastMessage as? ZMSystemMessage,\n                let systemMessageData = message.systemMessageData else {\n                return XCTFail()\n            }\n            XCTAssertEqual(systemMessageData.systemMessageType, .conversationIsSecure)\n            XCTAssertEqual(systemMessageData.clients, clients.union([selfClient]))\n        }\n        \n        XCTAssertTrue(self.waitForCustomExpectations(withTimeout: 0.5))\n    }\n    \n    func testThatItDoesNotIncreaseSecurityLevelOfCreatedGroupConversationWithAllParticipantsIfNotAlreadyTrusted()\n    {\n        self.syncMOC.performGroupedAndWait { _ -> () in\n            // given\n            let users = self.createUsersWithClientsOnSyncMOC(count: 2)\n            let selfClient = self.createSelfClient(onMOC: self.syncMOC)\n            selfClient.trustClients(users.first!.clients)\n            \n            // when\n            let conversation = ZMConversation.insertGroupConversation(moc: self.syncMOC, participants: users)!\n            // then\n            XCTAssertEqual(conversation.securityLevel, .notSecure)\n            guard let message = conversation.lastMessage as? ZMSystemMessage else {\n                return XCTFail()\n            }\n            XCTAssertNotEqual(message.systemMessageType, .conversationIsSecure)\n        }\n        \n        XCTAssertTrue(self.waitForCustomExpectations(withTimeout: 0.5))\n    }\n    \n    private var creationCounter = 1 // used to distinguish users\n    \n    func insertUser(conversation: ZMConversation, userIsTrusted: Bool, moc: NSManagedObjectContext) -> ZMUser\n    {\n        let selfClient = self.createSelfClient(onMOC: moc)\n        self.uiMOC.refreshAllObjects()\n        \n        let user = ZMUser.insertNewObject(in: moc)\n        user.name = \"insertUser \\(creationCounter)\"\n        self.creationCounter += 1\n        conversation.addParticipantAndUpdateConversationState(user: user, role: nil)\n        let client = UserClient.insertNewObject(in: moc)\n        client.user  = user\n        if (userIsTrusted) {\n            selfClient.trustClient(client)\n        } else {\n            selfClient.ignoreClient(client)\n        }\n        return user\n    }\n    \n    func testThatItReturns_HasUntrustedClients_YES_ifThereAreUntrustedClients()\n    {\n        // given\n        let conversation = ZMConversation.insertNewObject(in: self.uiMOC)\n        conversation.conversationType = .group\n        \n        // when\n        _ = self.insertUser(conversation: conversation, userIsTrusted: false, moc: self.uiMOC)\n        let hasUntrustedClients = conversation.hasUntrustedClients\n        \n        // then\n        XCTAssertTrue(hasUntrustedClients)\n        \n    }\n    \n    func testThatItReturns_HasUntrustedClients_NO_ifThereAreNoUntrustedClients()\n    {\n        // given\n        let conversation = ZMConversation.insertNewObject(in: self.uiMOC)\n        conversation.conversationType = .group\n        \n        // when\n        _ = self.insertUser(conversation: conversation, userIsTrusted: true, moc: self.uiMOC)\n        let hasUntrustedClients = conversation.hasUntrustedClients\n        \n        // then\n        XCTAssertFalse(hasUntrustedClients)\n    }\n    \n    func testThatItReturns_HasUntrustedClients_NO_ifThereAreNoOtherClients()\n    {\n        // given\n        let conversation = ZMConversation.insertNewObject(in: self.uiMOC)\n        conversation.conversationType = .group\n        let user = ZMUser.insertNewObject(in: self.uiMOC)\n        conversation.addParticipantAndUpdateConversationState(user: user, role: nil)\n        \n        // when\n        let hasUntrustedClients = conversation.hasUntrustedClients\n        \n        // then\n        XCTAssertFalse(hasUntrustedClients)\n    }\n    \n    \n    func testThatItReturns_HasUntrustedClients_NO_ifThereAreNoOtherUsers()\n    {\n        // given\n        let conversation = ZMConversation.insertNewObject(in: self.uiMOC)\n        conversation.conversationType = .group\n        \n        // when\n        let hasUntrustedClients = conversation.hasUntrustedClients\n        \n        // then\n        XCTAssertFalse(hasUntrustedClients)\n    }\n    \n    func testThatItAppendsASystemMessageOfTypeRemoteIDChangedForCBErrorCodeRemoteIdentityChanged()\n    {\n        // given\n        let conversation = ZMConversation.insertNewObject(in: self.uiMOC)\n        conversation.conversationType = .group\n        let user = ZMUser.insertNewObject(in: self.uiMOC)\n        user.name = \"Fancy One\"\n        let decryptionError = CBOX_REMOTE_IDENTITY_CHANGED\n        \n        // when\n        conversation.appendDecryptionFailedSystemMessage(at: Date(), sender: user, client: nil, errorCode: Int(decryptionError.rawValue))\n        \n        // then\n        guard let lastMessage = conversation.lastMessage as? ZMSystemMessage else {\n            return XCTFail()\n        }\n        XCTAssertEqual(lastMessage.systemMessageType, ZMSystemMessageType.decryptionFailed_RemoteIdentityChanged)\n        XCTAssertEqual(lastMessage.decryptionErrorCode?.intValue, Int(decryptionError.rawValue))\n    }\n    \n    func testThatItAppendsASystemMessageOfGeneralTypeForCBErrorCodeInvalidMessage()\n    {\n        // given\n        let conversation = ZMConversation.insertNewObject(in: self.uiMOC)\n        conversation.conversationType = .group\n        let user = ZMUser.insertNewObject(in: self.uiMOC)\n        user.name = \"Fancy One\"\n        let decryptionError = CBOX_INVALID_MESSAGE\n        \n        // when\n        conversation.appendDecryptionFailedSystemMessage(at: Date(), sender: user, client: nil, errorCode: Int(decryptionError.rawValue))\n        \n        // then\n        guard let lastMessage = conversation.lastMessage as? ZMSystemMessage else {\n            return XCTFail()\n        }\n        XCTAssertEqual(lastMessage.systemMessageType, ZMSystemMessageType.decryptionFailed)\n        XCTAssertEqual(lastMessage.decryptionErrorCode?.intValue, Int(decryptionError.rawValue))\n    }\n        \n    func testThatAConversationIsNotTrustedIfItHasNoOtherParticipants()\n    {\n        // GIVEN\n        let conversation = ZMConversation.insertNewObject(in: self.uiMOC)\n        conversation.conversationType = .group\n        \n        // THEN\n        XCTAssertFalse(conversation.allUsersTrusted)\n    }\n    \n    func testThatAConversationIsTrustedIfItHasTeamUsers()\n    {\n        self.syncMOC.performGroupedAndWait { _ in\n            // GIVEN\n            let conversation = ZMConversation.insertNewObject(in: self.syncMOC)\n            conversation.conversationType = .group\n            \n            let selfUser = ZMUser.selfUser(in: self.syncMOC)\n            selfUser.name = \"MYSELF\"\n            conversation.addParticipantAndUpdateConversationState(user: selfUser, role: nil)\n            \n            let mainTeam = Team.fetchOrCreate(with: UUID.create(),\n                                              create: true,\n                                              in: self.syncMOC,\n                                              created: nil)!\n            \n            _ = Member.getOrCreateMember(for: selfUser, in: mainTeam, context: self.syncMOC)\n            \n            // WHEN\n            let user = self.insertUser(conversation: conversation, userIsTrusted: true, moc: self.syncMOC)\n            _ = Member.getOrCreateMember(for: user, in: mainTeam, context: self.syncMOC)\n\n            // THEN\n            XCTAssertTrue(conversation.allUsersTrusted)\n        }\n    }\n    \n    func testThatAConversationIsNotTrustedIfItExternalUsers()\n    {\n        self.syncMOC.performGroupedAndWait { _ in\n            // GIVEN\n            let conversation = ZMConversation.insertNewObject(in: self.syncMOC)\n            conversation.conversationType = .group\n            \n            let selfUser = ZMUser.selfUser(in: self.syncMOC)\n            \n            let mainTeam = Team.fetchOrCreate(with: UUID.create(),\n                                              create: true,\n                                              in: self.syncMOC,\n                                              created: nil)!\n            \n            _ = Member.getOrCreateMember(for: selfUser, in: mainTeam, context: self.syncMOC)\n            \n            // WHEN\n            _ = self.insertUser(conversation: conversation, userIsTrusted: true, moc: self.syncMOC)\n            \n            // THEN\n            XCTAssertFalse(conversation.allUsersTrusted)\n        }\n    }\n    \n    func testThatAConversationIsNotTrustedIfNotAMemberAnymore()\n    {\n        // GIVEN\n        let conversation = ZMConversation.insertNewObject(in: self.uiMOC)\n        conversation.conversationType = .group\n        let otherUser = ZMUser.insertNewObject(in: self.uiMOC)\n        conversation.addParticipantAndUpdateConversationState(user: otherUser, role: nil)\n        let client = UserClient.insertNewObject(in: self.uiMOC)\n        client.user = otherUser\n        let selfUser = ZMUser.selfUser(in: self.uiMOC)\n        selfUser.selfClient()?.trustClient(client)\n        \n        // WHEN\n        conversation.removeParticipantAndUpdateConversationState(user: selfUser, initiatingUser:  otherUser)\n        \n        // THEN\n        XCTAssertFalse(conversation.allUsersTrusted)\n    }\n    \n    \n    //MARK:- Resending / cancelling messages in degraded conversation\n    \n    func testItExpiresAllMessagesAfterTheCurrentOneWhenAUserCausesDegradation()\n    {\n        self.syncMOC.performGroupedAndWait { _ in\n            \n            // GIVEN\n            self.createSelfClient()\n            let conversation = ZMConversation.insertNewObject(in: self.syncMOC)\n            conversation.conversationType = .group\n            let selfUser = ZMUser.selfUser(in: self.syncMOC)\n            \n            let user = ZMUser.insertNewObject(in: self.syncMOC)\n            conversation.addParticipantsAndUpdateConversationState(users: Set([user, selfUser]), role: nil)\n            conversation.securityLevel = .secure\n            \n            let message1 = try! conversation.appendImage(from: self.verySmallJPEGData()) as! ZMOTRMessage\n            Thread.sleep(forTimeInterval: 0.1)  // cause system time to advance\n            let message2 = try! conversation.appendText(content: \"foo 2\") as! ZMOTRMessage\n            \n            let client = UserClient.insertNewObject(in: self.syncMOC)\n            client.remoteIdentifier = \"aabbccdd\"\n            client.user = user\n            \n            // WHEN\n            conversation.decreaseSecurityLevelIfNeededAfterDiscovering(\n                clients: Set([client]), causedBy: Set([user]))\n            \n            // THEN\n            XCTAssertTrue(message1.isExpired)\n            XCTAssertTrue(message1.causedSecurityLevelDegradation)\n            XCTAssertTrue(message2.isExpired)\n            XCTAssertTrue(message2.causedSecurityLevelDegradation)\n            XCTAssertFalse(conversation.allUsersTrusted)\n            XCTAssertEqual(conversation.securityLevel, .secureWithIgnored)\n        }\n    }\n    \n    func testItExpiresAllMessagesAfterTheCurrentOneWhenAMessageCausesDegradation()\n    {\n        self.syncMOC.performGroupedAndWait { _ in\n            \n            // GIVEN\n            self.createSelfClient()\n            let conversation = ZMConversation.insertNewObject(in: self.syncMOC)\n            conversation.conversationType = .group\n            let user = self.insertUser(conversation: conversation, userIsTrusted: true, moc: self.syncMOC)\n            conversation.securityLevel = .secure\n            \n            let message1 = try! conversation.appendImage(from: self.verySmallJPEGData()) as! ZMOTRMessage\n            Thread.sleep(forTimeInterval: 0.1) // cause system time to advance\n            let message2 = try! conversation.appendText(content: \"foo 2\") as! ZMOTRMessage\n            Thread.sleep(forTimeInterval: 0.1) // cause system time to advance\n            let message3 = try! conversation.appendText(content: \"foo 3\") as! ZMOTRMessage\n            Thread.sleep(forTimeInterval: 0.1) // cause system time to advance\n            let message4 = try! conversation.appendText(content: \"foo 4\") as! ZMOTRMessage\n            Thread.sleep(forTimeInterval: 0.1) // cause system time to advance\n            let message5 = try! conversation.appendImage(from: self.verySmallJPEGData()) as! ZMOTRMessage\n            \n            \n            let client = UserClient.insertNewObject(in: self.syncMOC)\n            client.remoteIdentifier = \"aabbccdd\"\n            client.user = user\n            \n            // WHEN\n            conversation.decreaseSecurityLevelIfNeededAfterDiscovering(clients: Set([client]), causedBy: message3)\n            \n            // THEN\n            XCTAssertTrue(message1.isExpired)\n            XCTAssertTrue(message1.causedSecurityLevelDegradation)\n            XCTAssertTrue(message2.isExpired)\n            XCTAssertTrue(message2.causedSecurityLevelDegradation)\n            XCTAssertTrue(message3.isExpired)\n            XCTAssertTrue(message3.causedSecurityLevelDegradation)\n            XCTAssertTrue(message4.isExpired)\n            XCTAssertTrue(message4.causedSecurityLevelDegradation)\n            XCTAssertTrue(message5.isExpired)\n            XCTAssertTrue(message5.causedSecurityLevelDegradation)\n            XCTAssertFalse(conversation.allUsersTrusted)\n            XCTAssertEqual(conversation.securityLevel, .secureWithIgnored)\n        }\n    }\n    \n    func testItCancelsAllMessagesThatCausedDegradation()\n    {\n        var conversation: ZMConversation! = nil\n        var message1: ZMOTRMessage! = nil\n        var message2: ZMOTRMessage! = nil\n        var message3: ZMOTRMessage! = nil\n        \n        self.syncMOC.performGroupedAndWait { _ in\n            \n            // GIVEN\n            self.createSelfClient()\n            conversation = ZMConversation.insertNewObject(in: self.syncMOC)\n            conversation.conversationType = .group\n            let user = self.insertUser(conversation: conversation, userIsTrusted: true, moc: self.syncMOC)\n            conversation.securityLevel = .secure\n            \n            message1 = try! conversation.appendText(content: \"foo 2\") as! ZMOTRMessage\n            Thread.sleep(forTimeInterval: 0.1) // cause system time to advance\n            message2 = try! conversation.appendText(content: \"foo 3\") as! ZMOTRMessage\n            Thread.sleep(forTimeInterval: 0.1) // cause system time to advance\n            message3 = try! conversation.appendImage(from: self.verySmallJPEGData()) as! ZMOTRMessage\n            \n            \n            let client = UserClient.insertNewObject(in: self.syncMOC)\n            client.remoteIdentifier = \"aabbccdd\"\n            client.user = user\n            conversation.decreaseSecurityLevelIfNeededAfterDiscovering(clients: Set([client]), causedBy: message2)\n            self.syncMOC.saveOrRollback()\n        }\n        \n        // WHEN\n        let uiConversation = try! self.uiMOC.existingObject(with: conversation.objectID) as! ZMConversation\n        uiConversation.acknowledgePrivacyWarning(withResendIntent: false)\n        \n        self.syncMOC.performGroupedAndWait { moc in\n            moc.refreshAllObjects()\n            \n            // THEN\n            XCTAssertTrue(message1.isExpired)\n            XCTAssertFalse(message1.causedSecurityLevelDegradation)\n            XCTAssertTrue(message2.isExpired)\n            XCTAssertFalse(message2.causedSecurityLevelDegradation)\n            XCTAssertEqual(message2.deliveryState, .failedToSend)\n            XCTAssertTrue(message3.isExpired)\n            XCTAssertFalse(message3.causedSecurityLevelDegradation)\n            XCTAssertEqual(message3.deliveryState, .failedToSend)\n            XCTAssertFalse(conversation.allUsersTrusted)\n            XCTAssertEqual(conversation.securityLevel, .notSecure)\n        }\n    }\n    \n    func testItMarksConversationAsNotSecureAfterResendMessages()\n    {\n        var conversation: ZMConversation! = nil\n        self.syncMOC.performGroupedAndWait { _ in\n            // GIVEN\n            conversation = ZMConversation.insertNewObject(in: self.syncMOC)\n            conversation.conversationType = .group\n            conversation.securityLevel = .secureWithIgnored\n            self.syncMOC.saveOrRollback()\n        }\n        \n        // WHEN\n        let uiConversation = try! self.uiMOC.existingObject(with: conversation.objectID) as! ZMConversation\n        uiConversation.acknowledgePrivacyWarning(withResendIntent: true)\n        self.uiMOC.saveOrRollback()\n        \n        self.syncMOC.performGroupedAndWait { _ in\n            self.syncMOC.refreshAllObjects()\n            \n            // THEN\n            XCTAssertEqual(conversation.securityLevel, .notSecure)\n        }\n    }\n    \n    func testItResendsAllMessagesThatCausedDegradation()\n    {\n        var conversation: ZMConversation! = nil\n        var message1: ZMOTRMessage! = nil\n        var message2: ZMOTRMessage! = nil\n        var message3: ZMOTRMessage! = nil\n        \n        self.syncMOC.performGroupedAndWait { _ in\n            \n            // GIVEN\n            self.createSelfClient()\n            conversation = ZMConversation.insertNewObject(in: self.syncMOC)\n            conversation.conversationType = .group\n            let user = self.insertUser(conversation: conversation, userIsTrusted: true, moc: self.syncMOC)\n            conversation.securityLevel = .secure\n            \n            message1 = try! conversation.appendText(content: \"foo 2\") as! ZMOTRMessage\n            Thread.sleep(forTimeInterval: 0.1) // cause system time to advance\n            message2 = try! conversation.appendText(content: \"foo 3\") as! ZMOTRMessage\n            Thread.sleep(forTimeInterval: 0.1) // cause system time to advance\n            message3 = try! conversation.appendImage(from: self.verySmallJPEGData()) as! ZMOTRMessage\n            \n            \n            let client = UserClient.insertNewObject(in: self.syncMOC)\n            client.remoteIdentifier = \"aabbccdd\"\n            client.user = user\n            conversation.decreaseSecurityLevelIfNeededAfterDiscovering(clients: Set([client]), causedBy: message2)\n            self.syncMOC.saveOrRollback()\n            \n            XCTAssertTrue(message1.isExpired)\n            XCTAssertTrue(message1.causedSecurityLevelDegradation)\n            XCTAssertTrue(message2.isExpired)\n            XCTAssertTrue(message2.causedSecurityLevelDegradation)\n            XCTAssertTrue(message3.isExpired)\n            XCTAssertTrue(message3.causedSecurityLevelDegradation)\n        }\n        \n        // WHEN\n        let uiConversation = try! self.uiMOC.existingObject(with: conversation.objectID) as! ZMConversation\n        uiConversation.acknowledgePrivacyWarning(withResendIntent: true)\n        \n        self.syncMOC.performGroupedAndWait { _ in\n            \n            // THEN\n            XCTAssertFalse(message1.isExpired)\n            XCTAssertFalse(message1.causedSecurityLevelDegradation)\n            XCTAssertFalse(message2.isExpired)\n            XCTAssertFalse(message3.causedSecurityLevelDegradation)\n            XCTAssertEqual(message2.deliveryState, .pending)\n            XCTAssertFalse(message3.isExpired)\n            XCTAssertFalse(message3.causedSecurityLevelDegradation)\n            XCTAssertEqual(message3.deliveryState, .pending)\n            XCTAssertFalse(conversation.allUsersTrusted)\n            XCTAssertNotEqual(conversation.securityLevel, .secure)\n        }\n    }\n    \n    //MARK: - Hotfix\n    \n    func testThatItUpdatesFirstNewClientSystemMessage()\n    {\n        // given\n        self.createSelfClient()\n        self.uiMOC.refreshAllObjects()\n        \n        let selfUser = ZMUser.selfUser(in: self.uiMOC)\n        let selfClient = selfUser.selfClient()\n        let systemMessageClients = Set(arrayLiteral: selfClient)\n        XCTAssertNotNil(selfClient)\n        \n        let conv = ZMConversation.insertNewObject(in: self.uiMOC)\n        conv.conversationType = .oneOnOne\n        \n        let systemMessage = ZMSystemMessage(nonce: UUID.create(), managedObjectContext: self.uiMOC)\n        systemMessage.visibleInConversation = conv\n        systemMessage.systemMessageType = .newClient\n        systemMessage.sender = selfUser\n        systemMessage.clients = systemMessageClients\n        systemMessage.serverTimestamp = Date()\n        \n        // when\n        conv.replaceNewClientMessageIfNeededWithNewDeviceMesssage()\n        \n        // then\n        XCTAssertEqual(systemMessage.systemMessageType, .usingNewDevice)\n    }\n    \n    //MARK: - Add/Remove participants\n    \n    func simulateAdding(users: Set<ZMUser>, conversation: ZMConversation, by actionUser: ZMUser) -> ZMSystemMessage {\n\n        let userIDs = users.map { $0.remoteIdentifier.transportString() }\n        let data = [\"user_ids\": userIDs]\n        let payload = self.payloadForMessage(\n            in: conversation,\n            type: EventConversationMemberJoin,\n            data: data,\n            time: Date(),\n            from: actionUser\n        )\n        let event = ZMUpdateEvent(fromEventStreamPayload: payload, uuid: nil)!\n        \n        var result: ZMSystemMessage! = nil\n        self.performPretendingUiMocIsSyncMoc() {\n            users.forEach {\n                conversation.addParticipantAndUpdateConversationState(user: $0, role: nil)\n            }\n            result = ZMSystemMessage.createOrUpdate(from: event, in: conversation.managedObjectContext!, prefetchResult: nil)\n        }\n        return result\n    }\n    \n    func simulateRemoving(users: Set<ZMUser>, conversation: ZMConversation, by actionUser: ZMUser) -> ZMSystemMessage {\n        let userIDs = users.map { $0.remoteIdentifier.transportString() }\n        let data = [\"user_ids\": userIDs]\n        let payload = self.payloadForMessage(\n            in: conversation,\n            type: EventConversationMemberLeave,\n            data: data,\n            time: Date(),\n            from: actionUser\n        )\n        let event = ZMUpdateEvent(fromEventStreamPayload: payload, uuid: nil)!\n        \n        var result: ZMSystemMessage! = nil\n        self.performPretendingUiMocIsSyncMoc() {\n            conversation.removeParticipantsAndUpdateConversationState(users: users, initiatingUser: actionUser)\n            result = ZMSystemMessage.createOrUpdate(from: event, in: conversation.managedObjectContext!, prefetchResult: nil)\n        }\n        return result\n    }\n    \n    func setupVerifiedConversation() -> ZMConversation {\n        let selfUser = ZMUser.selfUser(in: self.uiMOC)\n        selfUser.remoteIdentifier = UUID()\n        let selfClient = self.createSelfClient(onMOC: self.uiMOC)\n        \n        let conversation = ZMConversation.insertNewObject(in: self.uiMOC)\n        conversation.conversationType = .group\n        conversation.remoteIdentifier = UUID()\n        conversation.addParticipantAndUpdateConversationState(user: selfUser, role: nil)\n        \n        let verifiedUser = ZMUser.insertNewObject(in: self.uiMOC)\n        verifiedUser.remoteIdentifier = UUID()\n        let verifiedUserConnection = ZMConnection.insertNewSentConnection(to: verifiedUser)!\n        verifiedUserConnection.status = .accepted\n        \n        let verifiedUserClient = UserClient.insertNewObject(in: self.uiMOC)\n        verifiedUserClient.user = verifiedUser\n        \n        conversation.addParticipantAndUpdateConversationState(user: verifiedUser, role: nil)\n        \n        selfClient.trustClients(Set([verifiedUserClient]))\n        conversation.increaseSecurityLevelIfNeededAfterTrusting(clients: Set([verifiedUserClient]))\n        return conversation\n    }\n    \n    func setupUnverifiedUsers(count: Int) -> Set<ZMUser> {\n        \n        return Set((0..<count).map { _ in\n            let unverifiedUser = ZMUser.insertNewObject(in: self.uiMOC)\n            let unverifiedUserConnection = ZMConnection.insertNewSentConnection(to: unverifiedUser)!\n            unverifiedUserConnection.status = .accepted\n            unverifiedUser.remoteIdentifier = UUID()\n            return unverifiedUser\n        })\n    }\n    \n    func testThatItDoesNotInsertDegradedMessageWhenAddingVerifiedUsers()\n    {\n        // GIVEN\n        let conversation = self.setupVerifiedConversation()\n        let selfUser = ZMUser.selfUser(in: self.uiMOC)\n        \n        // WHEN\n        let verifiedUser = ZMUser.insertNewObject(in: self.uiMOC)\n        verifiedUser.remoteIdentifier = UUID()\n        let verifiedUserConnection = ZMConnection.insertNewSentConnection(to: verifiedUser)!\n        verifiedUserConnection.status = .accepted\n        \n        let verifiedUserClient = UserClient.insertNewObject(in: self.uiMOC)\n        verifiedUserClient.user = verifiedUser\n        selfUser.selfClient()!.trustClient(verifiedUserClient)\n        \n        conversation.addParticipantAndUpdateConversationState(user: verifiedUser, role: nil)\n        \n        // THEN\n        guard let lastMessage1 = conversation.lastMessage as? ZMSystemMessage else {\n            return XCTFail()\n        }\n\n        XCTAssertEqual(lastMessage1.systemMessageType, .conversationIsSecure)\n        \n        // WHEN\n        _ = self.simulateAdding(users: Set([verifiedUser]), conversation: conversation, by: verifiedUser)\n        \n        // THEN\n        guard let lastMessage2 = conversation.lastMessage as? ZMSystemMessage else {\n            return XCTFail()\n        }\n        XCTAssertEqual(lastMessage2.systemMessageType, .participantsAdded)\n\n    }\n    \n    func testThatItDoesNotMoveExistingDegradedMessageWhenRemoteParticpantsAdd_OtherParticipants()\n    {\n        // GIVEN\n        let conversation = self.setupVerifiedConversation()\n        let selfUser = ZMUser.selfUser(in: self.uiMOC)\n\n        // WHEN\n        let unverifiedUsers = self.setupUnverifiedUsers(count: 1)\n        conversation.addParticipantsAndUpdateConversationState(users: unverifiedUsers, role: nil)\n        let otherUnverifiedUsers = self.setupUnverifiedUsers(count: 1)\n        \n        // THEN\n        XCTAssertEqual(conversation.allMessages.count, 2)\n        guard let lastMessage1 = conversation.lastMessage as? ZMSystemMessage else {\n            return XCTFail()\n        }\n        XCTAssertEqual(lastMessage1.systemMessageType, .newClient)\n        XCTAssertEqual(lastMessage1.addedUsers, unverifiedUsers)\n        \n        // WHEN\n        _ = self.simulateAdding(users: otherUnverifiedUsers, conversation: conversation, by: selfUser)\n        \n        // THEN\n        XCTAssertEqual(conversation.allMessages.count, 3)\n        guard let lastMessage2 = conversation.lastMessage as? ZMSystemMessage else {\n            return XCTFail()\n        }\n        XCTAssertEqual(lastMessage2.systemMessageType, .participantsAdded)\n    }\n    \n    func testThatAddingABlockedUserThatAlreadyIsMemberOfTheConversationDoesNotDegradeTheConversation()\n    {\n        // This happens when we are blocking a user in a 1on1: We recieve a conversation update from the backend as a response to blocking the user, which then \"readds\" the user. Since the user is already part of the conversation it should not degrade the conversation.\n        \n        // given\n        let conversation = self.setupVerifiedConversation()\n        let participant = conversation.participantRoles.first!.user\n        XCTAssertEqual(conversation.securityLevel, .secure)\n        participant.block()\n        \n        // when\n        conversation.addParticipantAndUpdateConversationState(user: participant, role: nil)\n        \n        // then\n        XCTAssertEqual(conversation.securityLevel, .secure)\n    }\n\n}\n", "//\n// Wire\n// Copyright (C) 2019 Wire Swiss GmbH\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see http://www.gnu.org/licenses/.\n//\n\nimport XCTest\nimport WireDataModel\n\nclass ZMUserLegalHoldTests: ModelObjectsTests {\n\n    func testThatLegalHoldStatusIsDisabled_ByDefault() {\n        // GIVEN\n        let selfUser = ZMUser.selfUser(in: uiMOC)\n\n        // THEN\n        XCTAssertEqual(selfUser.legalHoldStatus, .disabled)\n    }\n    \n    func testThatLegalHoldStatusIsDisabled_AfterCancelingRequest() {\n        // GIVEN\n        let selfUser = ZMUser.selfUser(in: uiMOC)\n        let request = LegalHoldRequest.mockRequest(for: selfUser)\n        selfUser.userDidReceiveLegalHoldRequest(request)\n        \n        // WHEN\n        selfUser.legalHoldRequestWasCancelled()\n        \n        // THEN\n        XCTAssertEqual(selfUser.legalHoldStatus, .disabled)\n        XCTAssertFalse(selfUser.needsToAcknowledgeLegalHoldStatus)\n    }\n    \n    func testThatLegalHoldStatusIsDisabled_AfterReceivingRequestTargetingAnotherUser() {\n        // GIVEN\n        let otherUser = createUser(in: uiMOC)\n        let selfUser = ZMUser.selfUser(in: uiMOC)\n        \n        // WHEN\n        let request = LegalHoldRequest.mockRequest(for: otherUser)\n        selfUser.userDidReceiveLegalHoldRequest(request)\n        \n        // THEN\n        XCTAssertEqual(selfUser.legalHoldStatus, .disabled)\n        XCTAssertFalse(selfUser.needsToAcknowledgeLegalHoldStatus)\n    }\n\n    func testThatLegalHoldStatusIsPending_AfterReceivingRequest() {\n        // GIVEN\n        let selfUser = ZMUser.selfUser(in: uiMOC)\n\n        // WHEN\n        let request = LegalHoldRequest.mockRequest(for: selfUser)\n        selfUser.userDidReceiveLegalHoldRequest(request)\n\n        // THEN\n        XCTAssertEqual(selfUser.legalHoldStatus, .pending(request))\n        XCTAssertTrue(selfUser.needsToAcknowledgeLegalHoldStatus)\n    }\n\n    func testThatLegalHoldStatusIsEnabled_AfterAcceptingRequest() {\n        // GIVEN\n        let selfUser = ZMUser.selfUser(in: uiMOC)\n        createSelfClient(onMOC: uiMOC)\n\n        let conversation = createConversation(in: uiMOC)\n        conversation.addParticipantAndUpdateConversationState(user: selfUser, role: nil)\n\n        // WHEN\n        let request = LegalHoldRequest.mockRequest(for: selfUser)\n        selfUser.userDidReceiveLegalHoldRequest(request)\n\n        performPretendingUiMocIsSyncMoc {\n            _ = selfUser.addLegalHoldClient(from: request)\n            selfUser.userDidAcceptLegalHoldRequest(request)\n        }\n\n        // THEN\n        XCTAssertEqual(selfUser.legalHoldStatus, .enabled)\n        XCTAssertTrue(selfUser.needsToAcknowledgeLegalHoldStatus)\n\n        let lastMessage = conversation.lastMessage as? ZMSystemMessage\n        XCTAssertEqual(lastMessage?.systemMessageType, .legalHoldEnabled)\n        XCTAssertTrue(conversation.isUnderLegalHold)\n    }\n\n    func testThatLegalHoldStatusIsEnabled_AfterAddingClient() {\n        // GIVEN\n        let selfUser = ZMUser.selfUser(in: uiMOC)\n\n        // WHEN\n        UserClient.createMockLegalHoldSelfUserClient(in: uiMOC)\n\n        // THEN\n        XCTAssertEqual(selfUser.legalHoldStatus, .enabled)\n        XCTAssertTrue(selfUser.needsToAcknowledgeLegalHoldStatus)\n    }\n\n    func testThatItDoesntClearNotificationFlag_AfterAddingNormalClient() {\n        // GIVEN\n        let selfUser = ZMUser.selfUser(in: uiMOC)\n\n        // WHEN\n        UserClient.createMockLegalHoldSelfUserClient(in: uiMOC)\n        UserClient.createMockPhoneUserClient(in: uiMOC)\n\n        // THEN\n        XCTAssertEqual(selfUser.legalHoldStatus, .enabled)\n        XCTAssertTrue(selfUser.needsToAcknowledgeLegalHoldStatus)\n    }\n\n    func testThatLegalHoldStatusIsDisabled_AfterRemovingClient() {\n        // GIVEN\n        let selfUser = ZMUser.selfUser(in: uiMOC)\n\n        let legalHoldClient = UserClient.createMockLegalHoldSelfUserClient(in: uiMOC)\n        XCTAssertEqual(selfUser.legalHoldStatus, .enabled)\n\n        selfUser.acknowledgeLegalHoldStatus()\n        XCTAssertFalse(selfUser.needsToAcknowledgeLegalHoldStatus)\n\n        // WHEN\n        performPretendingUiMocIsSyncMoc {\n            legalHoldClient.deleteClientAndEndSession()\n        }\n\n        // THEN\n        XCTAssertEqual(selfUser.legalHoldStatus, .disabled)\n        XCTAssertTrue(selfUser.needsToAcknowledgeLegalHoldStatus)\n    }\n\n    func testThatItDoesntClearNotificationFlag_AfterRemovingNormalClient() {\n        // GIVEN\n        let selfUser = ZMUser.selfUser(in: uiMOC)\n\n        let normalClient = UserClient.createMockPhoneUserClient(in: uiMOC)\n        UserClient.createMockLegalHoldSelfUserClient(in: uiMOC)\n        XCTAssertEqual(selfUser.legalHoldStatus, .enabled)\n\n        // WHEN\n        performPretendingUiMocIsSyncMoc {\n            normalClient.deleteClientAndEndSession()\n        }\n\n        // THEN\n        XCTAssertEqual(selfUser.legalHoldStatus, .enabled)\n        XCTAssertTrue(selfUser.needsToAcknowledgeLegalHoldStatus)\n    }\n\n}\n\n\nextension LegalHoldRequest {\n\n    static func mockRequest(for user: ZMUser) -> LegalHoldRequest {\n        let prekey = LegalHoldRequest.Prekey(id: 65535, key: Data(base64Encoded: \"pQABARn//wKhAFggHsa0CszLXYLFcOzg8AA//E1+Dl1rDHQ5iuk44X0/PNYDoQChAFgg309rkhG6SglemG6kWae81P1HtQPx9lyb6wExTovhU4cE9g==\")!)\n        return LegalHoldRequest(target: user.remoteIdentifier!, requester: UUID(), clientIdentifier: \"eca3c87cfe28be49\", lastPrekey: prekey)\n    }\n\n}\n\nextension UserClient {\n\n    @discardableResult\n    static func createMockLegalHoldSelfUserClient(in moc: NSManagedObjectContext) -> UserClient {\n        let payload: [String: AnyObject] = [\n            \"id\": NSUUID().transportString() as NSString,\n            \"type\": DeviceType.legalHold.rawValue as NSString,\n            \"class\": DeviceClass.legalHold.rawValue as NSString,\n            \"time\": NSDate()\n        ]\n\n        return createOrUpdateSelfUserClient(payload, context: moc)!\n    }\n\n    @discardableResult\n    static func createMockPhoneUserClient(in moc: NSManagedObjectContext) -> UserClient {\n        let payload: [String: AnyObject] = [\n            \"id\": NSUUID().transportString() as NSString,\n            \"type\": DeviceType.permanent.rawValue as NSString,\n            \"class\": DeviceClass.phone.rawValue as NSString,\n            \"time\": NSDate()\n        ]\n\n        return createOrUpdateSelfUserClient(payload, context: moc)!\n    }\n\n}\n"], "fixing_code": ["//\n// Wire\n// Copyright (C) 2018 Wire Swiss GmbH\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see http://www.gnu.org/licenses/.\n//\n\nimport Foundation\nimport WireProtos\n\nextension ZMConversation {\n        \n    func sortedUsers(_ users: Set<ZMUser>) -> [ZMUser] {\n        let nameDescriptor = NSSortDescriptor(key: \"normalizedName\", ascending: true)\n        let sortedUser = (users as NSSet?)?.sortedArray(using: [nameDescriptor]) as? [ZMUser]\n\n        return sortedUser ?? []\n    }\n    \n    @objc public var sortedActiveParticipants: [ZMUser] {\n        return sortedUsers(localParticipants)\n    }\n\n    \n    /// Whether the roles defined for this conversation should be re-downloaded\n    @NSManaged public var needsToDownloadRoles: Bool\n    \n    @objc\n    public var isSelfAnActiveMember: Bool {\n        return self.participantRoles.contains(where: { (role) -> Bool in\n            role.user.isSelfUser == true\n        })\n    }\n    // MARK: - keyPathsForValuesAffecting\n    \n    static var participantRolesKeys: [String] {\n        return [#keyPath(ZMConversation.participantRoles)]\n    }\n    \n    @objc\n    public class func keyPathsForValuesAffectingActiveParticipants() -> Set<String> {\n        return Set(participantRolesKeys)\n    }\n    \n    @objc\n    public class func keyPathsForValuesAffectingLocalParticipants() -> Set<String> {\n        return Set(participantRolesKeys)\n    }\n    \n    @objc\n    public class func keyPathsForValuesAffectingLocalParticipantRoles() -> Set<String> {\n        return Set(participantRolesKeys + [#keyPath(ZMConversation.participantRoles.role)])\n    }\n    \n    @objc\n    public class func keyPathsForValuesAffectingDisplayName() -> Set<String> {\n        return Set([ZMConversationConversationTypeKey,\n                    \"participantRoles.user.name\",\n                    \"connection.to.name\",\n                    \"connection.to.availability\",\n                    ZMConversationUserDefinedNameKey] +\n                   ZMConversation.participantRolesKeys)\n    }\n    \n    @objc\n    public class func keyPathsForValuesAffectingLocalParticipantsExcludingSelf() -> Set<String> {\n        return Set(ZMConversation.participantRolesKeys)\n    }\n    \n    //MARK: - Participants methods\n    \n    /// Participants that are in the conversation, according to the local state,\n    /// even if that state is not yet synchronized with the backend\n    @objc\n    public var localParticipantRoles: Set<ParticipantRole> {\n        return participantRoles\n    }\n    \n    /// Participants that are in the conversation, according to the local state\n    /// even if that state is not yet synchronized with the backend\n    @objc\n    public var localParticipants: Set<ZMUser> {\n        return Set(localParticipantRoles.map { $0.user })\n    }\n    \n    /// Participants that are in the conversation, according to the local state\n    /// even if that state is not yet synchronized with the backend\n\n    @objc\n    public var localParticipantsExcludingSelf: Set<ZMUser> {\n        return self.localParticipants.filter { !$0.isSelfUser }\n    }\n    \n    // MARK: - Participant operations\n    \n    /// Add participants to the conversation. The method will decide on its own whether\n    /// this operation need to be synchronized to the backend or not based on the current context.\n    /// If the operation is executed from the UI context, then the operation will be synchronized.\n    /// If the operation is executed from the sync context, then the operation will not be synchronized.\n    ///\n    /// The method will handle the case when the participant is already there, so it's safe to call\n    /// it multiple time for the same user. It will update the role if the user is already there with\n    /// a different role.\n    ///\n    /// The method will also check if the addition of the users will change the verification status, the archive\n    /// status, etc.\n    @objc\n    public func addParticipantAndUpdateConversationState(user: ZMUser, role: Role?) {\n        self.addParticipantsAndUpdateConversationState(usersAndRoles: [(user, role)])\n    }\n    \n    /// Add participants to the conversation. The method will decide on its own whether\n    /// this operation need to be synchronized to the backend or not based on the current context.\n    /// If the operation is executed from the UI context, then the operation will be synchronized.\n    /// If the operation is executed from the sync context, then the operation will not be synchronized.\n    ///\n    /// The method will handle the case when the participant is already there, so it's safe to call\n    /// it multiple time for the same user. It will update the role if the user is already there with\n    /// a different role.\n    ///\n    /// The method will also check if the addition of the users will change the verification status, the archive\n    /// status, etc.\n    @objc\n    public func addParticipantsAndUpdateConversationState(users: Set<ZMUser>, role: Role?) {\n        self.addParticipantsAndUpdateConversationState(usersAndRoles: users.map { ($0, role) })\n    }\n    \n    /// Add participants to the conversation. The method will decide on its own whether\n    /// this operation need to be synchronized to the backend or not based on the current context.\n    /// If the operation is executed from the UI context, then the operation will be synchronized.\n    /// If the operation is executed from the sync context, then the operation will not be synchronized.\n    ///\n    /// The method will handle the case when the participant is already there, so it's safe to call\n    /// it multiple time for the same user. It will update the role if the user is already there with\n    /// a different role.\n    ///\n    /// The method will also check if the addition of the users will change the verification status, the archive\n    /// status, etc.\n    public func addParticipantsAndUpdateConversationState(usersAndRoles: [(ZMUser, Role?)]) {\n        \n        // Is this a new conversation, or an existing one that is being updated?\n        let doesExistsOnBackend = self.remoteIdentifier != nil\n        \n        let addedRoles = usersAndRoles.compactMap { (user, role) -> ParticipantRole? in\n            guard !user.isAccountDeleted else { return nil }\n            \n            // make sure the role is the right team/conversation role\n            require(\n                role == nil || (role!.team == self.team || role!.conversation == self),\n                \"Tried to add a role that does not belong to the conversation\"\n            )\n            \n            guard let (result, pr) = updateExistingOrCreateParticipantRole(for: user, with: role) else { return nil }\n            return (result == .created) ? pr : nil\n        }\n        \n        let addedSelfUser = doesExistsOnBackend && addedRoles.contains(where: {$0.user.isSelfUser})\n        if addedSelfUser {\n            self.markToDownloadRolesIfNeeded()\n            self.needsToBeUpdatedFromBackend = true\n        }\n        \n        if !addedRoles.isEmpty {\n            self.checkIfArchivedStatusChanged(addedSelfUser: addedSelfUser)\n            self.checkIfVerificationLevelChanged(addedUsers: Set(addedRoles.map { $0.user}),  addedSelfUser: addedSelfUser)\n        }\n    }\n\n    private enum FetchOrCreation {\n        case fetched\n        case created\n    }\n\n    // Fetch an existing role or create a new one if needed\n    // Returns whether it was created or found\n    private func updateExistingOrCreateParticipantRole(for user: ZMUser, with role: Role?) -> (FetchOrCreation, ParticipantRole)? {\n        \n        guard let moc = self.managedObjectContext else { return nil }\n        \n        // If the user is already there, just change the role\n        if let current = self.participantRoles.first(where: {$0.user == user}) {\n            if let role = role {\n                current.role = role\n            }\n            \n            return (.fetched, current)\n            \n        } else {\n            // A new participant role\n            let participantRole = ParticipantRole.insertNewObject(in: moc)\n            participantRole.conversation = self\n            participantRole.user = user\n            participantRole.role = role\n            \n            return (.created, participantRole)\n        }\n    }\n    \n    private func checkIfArchivedStatusChanged(addedSelfUser: Bool) {\n        if addedSelfUser &&\n            self.mutedStatus == MutedMessageOptionValue.none.rawValue &&\n            self.isArchived\n        {\n            self.isArchived = false\n        }\n    }\n    \n    private func checkIfVerificationLevelChanged(addedUsers: Set<ZMUser>, addedSelfUser: Bool) {\n        let clients = Set(addedUsers.flatMap { $0.clients })\n        self.decreaseSecurityLevelIfNeededAfterDiscovering(clients: clients, causedBy: addedUsers)\n\n        if addedSelfUser {\n            self.increaseSecurityLevelIfNeededAfterTrusting(clients: clients)\n        }\n    }\n    \n    /// Remove participants to the conversation. The method will decide on its own whether\n    /// this operation need to be synchronized to the backend or not based on the current context.\n    /// If the operation is executed from the UI context, then the operation will be synchronized.\n    /// If the operation is executed from the sync context, then the operation will not be synchronized.\n    ///\n    /// The method will handle the case when the participant is not there, so it's safe to call\n    /// it even if the user is not there.\n    ///\n    /// The method will also check if the addition of the users will change the verification status, the archive\n    /// status, etc.\n    @objc\n    public func removeParticipantsAndUpdateConversationState(users: Set<ZMUser>, initiatingUser: ZMUser? = nil) {\n        \n        guard let moc = self.managedObjectContext else { return }\n        let existingUsers = Set(self.participantRoles.map { $0.user })\n        \n        let removedUsers = Set(users.compactMap { user -> ZMUser? in\n            \n            guard existingUsers.contains(user),\n                let existingRole = participantRoles.first(where: { $0.user == user })\n                else { return nil }\n            \n            participantRoles.remove(existingRole)\n            moc.delete(existingRole)\n            return user\n        })\n        \n        if !removedUsers.isEmpty {\n            let removedSelf = removedUsers.contains(where: { $0.isSelfUser })\n            self.checkIfArchivedStatusChanged(removedSelfUser: removedSelf, initiatingUser: initiatingUser)\n            self.checkIfVerificationLevelChanged(removedUsers: removedUsers)\n        }\n    }\n    \n    /// Remove participants to the conversation. The method will decide on its own whether\n    /// this operation need to be synchronized to the backend or not based on the current context.\n    /// If the operation is executed from the UI context, then the operation will be synchronized.\n    /// If the operation is executed from the sync context, then the operation will not be synchronized.\n    ///\n    /// The method will handle the case when the participant is not there, so it's safe to call\n    /// it even if the user is not there.\n    ///\n    /// The method will also check if the addition of the users will change the verification status, the archive\n    /// status, etc.\n    @objc\n    public func removeParticipantAndUpdateConversationState(user: ZMUser, initiatingUser: ZMUser? = nil) {\n        self.removeParticipantsAndUpdateConversationState(users: Set(arrayLiteral: user), initiatingUser: initiatingUser)\n    }\n    \n    private func checkIfArchivedStatusChanged(removedSelfUser: Bool, initiatingUser: ZMUser?) {\n        if removedSelfUser, let initiatingUser = initiatingUser {\n            self.isArchived = initiatingUser.isSelfUser\n        }\n    }\n    \n    private func checkIfVerificationLevelChanged(removedUsers: Set<ZMUser>) {\n        self.increaseSecurityLevelIfNeededAfterRemoving(users: removedUsers)\n    }\n    \n    \n    // MARK: - Conversation roles\n    \n    /// List of roles for the conversation whether it's linked with a team or not\n    @objc\n    public func getRoles() -> Set<Role> {\n        if let team = team {\n            return team.roles\n        }\n        return nonTeamRoles\n    }\n    \n    /// Check if roles are missing, and mark them to download if needed\n    @objc public func markToDownloadRolesIfNeeded() {\n        guard self.conversationType == .group else { return }\n        \n        let selfUser = ZMUser.selfUser(in: self.managedObjectContext!)\n        let notInMyTeam = self.teamRemoteIdentifier == nil ||\n            selfUser.team?.remoteIdentifier != self.teamRemoteIdentifier\n        \n        guard notInMyTeam else { return }\n        \n        if self.nonTeamRoles.isEmpty ||\n            self.nonTeamRoles.first(where: {!$0.actions.isEmpty}) == nil // there are no roles with actions\n        {\n            self.needsToDownloadRoles = true\n        }\n    }\n    \n    // MARK: - Utils\n    func has(participantWithId userId: UserId?) -> Bool {\n        return localParticipants.contains { $0.userId == userId }\n    }\n}\n\n\n", "//\n// Wire\n// Copyright (C) 2016 Wire Swiss GmbH\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see http://www.gnu.org/licenses/.\n//\n\nimport Foundation\nimport WireCryptobox\n\nprivate let zmLog = ZMSLog(tag: \"event-processing\")\n\n@objc public enum ZMConversationLegalHoldStatus: Int16 {\n    case disabled = 0\n    case pendingApproval = 1\n    case enabled = 2\n\n    public var denotesEnabledComplianceDevice: Bool {\n        switch self {\n        case .pendingApproval, .enabled:\n            return true\n        case .disabled:\n            return false\n        }\n    }\n}\n\n/**\n * Represents a set of client changes in a conversation.\n */\n\npublic struct ZMConversationRemoteClientChangeSet: OptionSet {\n    public let rawValue: Int\n\n    public init(rawValue: Int) {\n        self.rawValue = rawValue\n    }\n\n    /// Deleted clients were detected.\n    public static let deleted = ZMConversationRemoteClientChangeSet(rawValue: 1 << 0)\n\n    /// Missing clients were detected.\n    public static let missing = ZMConversationRemoteClientChangeSet(rawValue: 1 << 1)\n\n    /// Redundant clients were detected.\n    public static let redundant = ZMConversationRemoteClientChangeSet(rawValue: 1 << 2)\n}\n\n\nextension ZMConversation {\n\n    /// Contains current security level of conversation.\n    /// Client should check this property to properly annotate conversation.\n    @NSManaged public internal(set) var securityLevel: ZMConversationSecurityLevel\n\n    @NSManaged private var primitiveLegalHoldStatus: NSNumber\n    \n    /// Indicates that we need verify that our local knowledge of clients matches the clients known to the backend.\n    @NSManaged public internal(set) var needsToVerifyLegalHold: Bool\n\n    /// Whether the conversation is under legal hold.\n    @objc public internal(set) var legalHoldStatus: ZMConversationLegalHoldStatus {\n        get {\n            willAccessValue(forKey: #keyPath(legalHoldStatus))\n            defer { didAccessValue(forKey: #keyPath(legalHoldStatus)) }\n\n            if let status = ZMConversationLegalHoldStatus(rawValue: primitiveLegalHoldStatus.int16Value) {\n                return status\n            } else {\n                return .disabled\n            }\n        }\n        set {\n            willChangeValue(forKey: #keyPath(legalHoldStatus))\n            primitiveLegalHoldStatus = NSNumber(value: newValue.rawValue)\n            didChangeValue(forKey: #keyPath(legalHoldStatus))\n        }\n    }\n\n    /// Whether the conversation is under legal hold.\n    @objc public var isUnderLegalHold: Bool {\n        return legalHoldStatus.denotesEnabledComplianceDevice\n    }\n\n    /// Whether the self user can send messages in this conversation.\n    @objc public var selfUserCanSendMessages: Bool {\n        return !isReadOnly && securityLevel != .secureWithIgnored && legalHoldStatus != .pendingApproval\n    }\n    \n    /// Verify the legal hold subjects in the conversation. This will synchronize with the backend on who's currently under legal hold.\n    @objc public func verifyLegalHoldSubjects() {\n        needsToVerifyLegalHold = true\n        managedObjectContext?.saveOrRollback()\n    }\n\n    // MARK: - Events\n\n    /// Should be called when a message is received.\n    /// If the legal hold status hint inside the received message is different than the local status,\n    /// we update the local version to match the remote one.\n    public func updateSecurityLevelIfNeededAfterReceiving(message: GenericMessage, timestamp: Date) {\n        updateLegalHoldIfNeededWithHint(from: message, timestamp: timestamp)\n    }\n    \n    /// Should be called if we need to verify the legal hold status after fetching the clients in a conversation.\n    public func updateSecurityLevelIfNeededAfterFetchingClients(changes: ZMConversationRemoteClientChangeSet) {\n        needsToVerifyLegalHold = false\n\n        if changes.isEmpty {\n            applySecurityChanges(cause: .verifyLegalHold)\n        }\n    }\n\n    /// Should be called when client is trusted.\n    /// If the conversation became trusted, it will trigger UI notification and add system message for all devices verified\n    @objc(increaseSecurityLevelIfNeededAfterTrustingClients:)\n    public func increaseSecurityLevelIfNeededAfterTrusting(clients: Set<UserClient>) {\n         applySecurityChanges(cause: .verifiedClients(clients))\n    }\n\n    /// Should be called when client is deleted.\n    /// If the conversation became trusted, it will trigger UI notification and add system message for all devices verified\n    @objc(increaseSecurityLevelIfNeededAfterRemovingClientForUsers:)\n    public func increaseSecurityLevelIfNeededAfterRemoving(clients: [ZMUser: Set<UserClient>]) {\n        applySecurityChanges(cause: .removedClients(clients))\n    }\n\n    /// Should be called when a user is deleted.\n    /// If the conversation became trusted, it will trigger UI notification and add system message for all devices verified\n    @objc(increaseSecurityLevelIfNeededAfterRemovingUsers:)\n    public func increaseSecurityLevelIfNeededAfterRemoving(users: Set<ZMUser>) {\n        applySecurityChanges(cause: .removedUsers(users))\n    }\n\n    /// Should be called when a new client is discovered\n    @objc(decreaseSecurityLevelIfNeededAfterDiscoveringClients:causedByMessage:)\n    public func decreaseSecurityLevelIfNeededAfterDiscovering(clients: Set<UserClient>, causedBy message: ZMOTRMessage?) {\n        applySecurityChanges(cause: .addedClients(clients, source: message))\n    }\n    \n    /// Should be called when a new user is added to the conversation\n    @objc(decreaseSecurityLevelIfNeededAfterDiscoveringClients:causedByAddedUsers:)\n    public func decreaseSecurityLevelIfNeededAfterDiscovering(clients: Set<UserClient>, causedBy users: Set<ZMUser>) {\n        applySecurityChanges(cause: .addedUsers(users))\n    }\n\n    /// Should be called when a client is ignored\n    @objc(decreaseSecurityLevelIfNeededAfterIgnoringClients:)\n    public func decreaseSecurityLevelIfNeededAfterIgnoring(clients: Set<UserClient>) {\n        applySecurityChanges(cause: .ignoredClients(clients))\n    }\n\n    /// Applies the security changes for the set of users.\n    private func applySecurityChanges(cause: SecurityChangeCause) {\n        updateLegalHoldState(cause: cause)\n        updateSecurityLevel(cause: cause)\n    }\n\n    private func updateLegalHoldState(cause: SecurityChangeCause) {\n        guard !needsToVerifyLegalHold, !localParticipants.any({ $0.clients.any(\\.needsToBeUpdatedFromBackend) }) else {\n            // We don't update the legal hold status if we are still gathering information about which clients were added/deleted\n            return\n        }\n        \n        let detectedParticipantsUnderLegalHold = localParticipants.any(\\.isUnderLegalHold)\n\n        switch (legalHoldStatus, detectedParticipantsUnderLegalHold) {\n        case (.disabled, true):\n            legalHoldStatus = .pendingApproval\n            appendLegalHoldEnabledSystemMessageForConversation(cause: cause)\n            expireAllPendingMessagesBecauseOfSecurityLevelDegradation()\n\n        case (.pendingApproval, false), (.enabled, false):\n            legalHoldStatus = .disabled\n            appendLegalHoldDisabledSystemMessageForConversation()\n\n        default:\n            // no changes required\n            break\n        }\n    }\n\n    private func updateSecurityLevel(cause: SecurityChangeCause) {\n        switch cause {\n        case .addedUsers, .addedClients, .ignoredClients:\n            degradeSecurityLevelIfNeeded(for: cause)\n\n        case .removedUsers, .removedClients, .verifiedClients:\n            increaseSecurityLevelIfNeeded(for: cause)\n            \n        case .verifyLegalHold:\n            // no-op: verifying legal hold does not impact security level\n            break\n        }\n    }\n\n    private func increaseSecurityLevelIfNeeded(for cause: SecurityChangeCause) {\n        guard\n            securityLevel != .secure &&\n            allUsersTrusted &&\n            allParticipantsHaveClients &&\n            conversationType.isOne(of: .group, .oneOnOne, .invalid)\n        else {\n            return\n        }\n\n        securityLevel = .secure\n        appendNewIsSecureSystemMessage(cause: cause)\n        notifyOnUI(name: ZMConversation.isVerifiedNotificationName)\n    }\n\n    private func degradeSecurityLevelIfNeeded(for cause: SecurityChangeCause) {\n        guard securityLevel == .secure && !allUsersTrusted else {\n            return\n        }\n\n        securityLevel = .secureWithIgnored\n\n        switch cause {\n        case .addedClients, .addedUsers:\n            appendNewAddedClientSystemMessage(cause: cause)\n            expireAllPendingMessagesBecauseOfSecurityLevelDegradation()\n        case .ignoredClients(let clients):\n            appendIgnoredClientsSystemMessage(ignored: clients)\n        default:\n            break\n        }\n    }\n\n    /// Update the legal hold status based on the hint of a message.    \n    private func updateLegalHoldIfNeededWithHint(from message: GenericMessage, timestamp: Date) {\n        switch message.legalHoldStatus {\n        case .enabled where !legalHoldStatus.denotesEnabledComplianceDevice:\n            needsToVerifyLegalHold = true\n            legalHoldStatus = .pendingApproval\n            appendLegalHoldEnabledSystemMessageForConversationAfterReceivingMessage(at: timestamp)\n            expireAllPendingMessagesBecauseOfSecurityLevelDegradation()\n        case .disabled where legalHoldStatus.denotesEnabledComplianceDevice:\n            needsToVerifyLegalHold = true\n            legalHoldStatus = .disabled\n            appendLegalHoldDisabledSystemMessageForConversationAfterReceivingMessage(at: timestamp)\n        default:\n            break\n        }\n    }\n\n    // MARK: - Messages\n\n    /// Creates a system message that inform that there are pontential lost messages, and that some users were added to the conversation\n    @objc public func appendNewPotentialGapSystemMessage(users: Set<ZMUser>?, timestamp: Date) {\n        \n        let previousLastMessage = lastMessage\n        let systemMessage = self.appendSystemMessage(type: .potentialGap,\n                                                     sender: ZMUser.selfUser(in: self.managedObjectContext!),\n                                                     users: users,\n                                                     clients: nil,\n                                                     timestamp: timestamp)\n        systemMessage.needsUpdatingUsers = true\n        \n        if let previousLastMessage = previousLastMessage as? ZMSystemMessage, previousLastMessage.systemMessageType == .potentialGap,\n           let previousLastMessageTimestamp = previousLastMessage.serverTimestamp, previousLastMessageTimestamp <= timestamp {\n            // In case the message before the new system message was also a system message of\n            // the type ZMSystemMessageTypePotentialGap, we delete the old one and update the\n            // users property of the new one to use old users and calculate the added / removed users\n            // from the time the previous one was added\n            systemMessage.users = previousLastMessage.users\n            self.managedObjectContext?.delete(previousLastMessage)\n        }\n    }\n\n    /// Creates the message that warns user about the fact that decryption of incoming message is failed\n    @objc(appendDecryptionFailedSystemMessageAtTime:sender:client:errorCode:)\n    public func appendDecryptionFailedSystemMessage(at date: Date?, sender: ZMUser, client: UserClient?, errorCode: Int) {\n        let type = (UInt32(errorCode) == CBOX_REMOTE_IDENTITY_CHANGED.rawValue) ? ZMSystemMessageType.decryptionFailed_RemoteIdentityChanged : ZMSystemMessageType.decryptionFailed\n        let clients = client.flatMap { Set(arrayLiteral: $0) } ?? Set<UserClient>()\n        let serverTimestamp = date ?? timestampAfterLastMessage()\n        let systemMessage = appendSystemMessage(type: type,\n                                               sender: sender,\n                                               users: nil,\n                                               clients: clients,\n                                               timestamp: serverTimestamp)\n        \n        systemMessage.senderClientID = client?.remoteIdentifier\n        systemMessage.decryptionErrorCode = NSNumber(integerLiteral: errorCode)\n    }\n\n    /// Adds the user to the list of participants if not already present and inserts a .participantsAdded system message\n    ///\n    /// - Parameters:\n    ///   - user: the participant to add\n    ///   - dateOptional: if provide a nil, current date will be used\n    public func addParticipantAndSystemMessageIfMissing(_ user: ZMUser, date dateOptional: Date?) {\n        let date = dateOptional ?? Date()\n\n        guard !user.isSelfUser, !localParticipants.contains(user) else { return }\n        \n        zmLog.debug(\"Sender: \\(user.remoteIdentifier?.transportString() ?? \"n/a\") missing from participant list: \\(localParticipants.map{ $0.remoteIdentifier} )\")\n        \n        switch conversationType {\n        case .group:\n            appendSystemMessage(type: .participantsAdded, sender: user, users: Set(arrayLiteral: user), clients: nil, timestamp: date)\n        case .oneOnOne, .connection:\n            if user.connection == nil {\n                user.connection = connection ?? ZMConnection.insertNewObject(in: managedObjectContext!)\n            } else if connection == nil {\n                connection = user.connection\n            }\n            user.connection?.needsToBeUpdatedFromBackend = true\n        default:\n            break\n        }\n        \n        // we will fetch the role once we fetch the entire convo metadata\n        self.addParticipantAndUpdateConversationState(user: user, role: nil)\n        \n        // A missing user indicate that we are out of sync with the BE so we'll re-sync the conversation\n        needsToBeUpdatedFromBackend = true\n    }\n\n    private func appendLegalHoldEnabledSystemMessageForConversation(cause: SecurityChangeCause) {\n        var timestamp : Date?\n        \n        if case .addedClients(_, let message) = cause, message?.conversation == self, message?.isUpdatingExistingMessage == false {\n            timestamp = self.timestamp(before: message)\n        }\n        \n        appendSystemMessage(type: .legalHoldEnabled,\n                            sender: ZMUser.selfUser(in: self.managedObjectContext!),\n                            users: nil,\n                            clients: nil,\n                            timestamp: timestamp ?? timestampAfterLastMessage())\n    }\n\n    private func appendLegalHoldEnabledSystemMessageForConversationAfterReceivingMessage(at timestamp: Date) {\n        appendSystemMessage(type: .legalHoldEnabled,\n                            sender: ZMUser.selfUser(in: self.managedObjectContext!),\n                            users: nil,\n                            clients: nil,\n                            timestamp: timestamp.previousNearestTimestamp)\n    }\n\n    private func appendLegalHoldDisabledSystemMessageForConversation() {\n        appendSystemMessage(type: .legalHoldDisabled,\n                            sender: ZMUser.selfUser(in: self.managedObjectContext!),\n                            users: nil,\n                            clients: nil,\n                            timestamp: timestampAfterLastMessage())\n    }\n\n    private func appendLegalHoldDisabledSystemMessageForConversationAfterReceivingMessage(at timestamp: Date) {\n        appendSystemMessage(type: .legalHoldDisabled,\n                            sender: ZMUser.selfUser(in: self.managedObjectContext!),\n                            users: nil,\n                            clients: nil,\n                            timestamp: timestamp.previousNearestTimestamp)\n    }\n\n}\n\n// MARK: - Messages resend/expiration\nextension ZMConversation {\n\n    private func acknowledgePrivacyChanges() {\n        precondition(managedObjectContext?.zm_isUserInterfaceContext == true)\n\n        // Downgrade the conversation to be unverified\n        if securityLevel == .secureWithIgnored {\n            securityLevel = .notSecure\n        }\n\n        // Accept legal hold\n        if legalHoldStatus == .pendingApproval {\n            legalHoldStatus = .enabled\n        }\n\n        managedObjectContext?.saveOrRollback()\n    }\n\n    private func resendPendingMessagesAfterPrivacyChanges() {\n        enumerateReverseMessagesThatCausedDegradationUntilFirstSystemMessageOnSyncContext {\n            $0.causedSecurityLevelDegradation = false\n            $0.resend()\n        }\n    }\n\n    private func discardPendingMessagesAfterPrivacyChanges() {\n        guard let syncMOC = managedObjectContext?.zm_sync else { return }\n        syncMOC.performGroupedBlock {\n            guard let conversation = (try? syncMOC.existingObject(with: self.objectID)) as? ZMConversation else { return }\n            conversation.clearMessagesThatCausedSecurityLevelDegradation()\n            syncMOC.saveOrRollback()\n        }\n    }\n\n    /// Accepts the privacy changes (legal hold and/or degradation) and resend the pending messages.\n    @objc(acknowledgePrivacyWarningWithResendIntent:) public func acknowledgePrivacyWarning(withResendIntent shouldResendMessages: Bool) {\n        acknowledgePrivacyChanges()\n\n        if shouldResendMessages {\n            resendPendingMessagesAfterPrivacyChanges()\n        } else {\n            discardPendingMessagesAfterPrivacyChanges()\n        }\n    }\n\n    /// Enumerates all messages from newest to oldest and apply a block to all ZMOTRMessage encountered, \n    /// halting the enumeration when a system message for security level degradation is found.\n    /// This is executed asychronously on the sync context\n    private func enumerateReverseMessagesThatCausedDegradationUntilFirstSystemMessageOnSyncContext(block: @escaping (ZMOTRMessage)->()) {\n        guard let syncMOC = self.managedObjectContext?.zm_sync else { return }\n        syncMOC.performGroupedBlock {\n            guard let conversation = (try? syncMOC.existingObject(with: self.objectID)) as? ZMConversation else { return }\n            conversation.messagesThatCausedSecurityLevelDegradation.forEach(block)\n            syncMOC.saveOrRollback()\n        }\n    }\n    \n    /// Expire all pending messages\n    fileprivate func expireAllPendingMessagesBecauseOfSecurityLevelDegradation() {\n        for message in undeliveredMessages {\n            if let clientMessage = message as? ZMClientMessage,\n                let genericMessage = clientMessage.underlyingMessage,\n                genericMessage.hasConfirmation {\n                // Delivery receipt: just expire it\n                message.expire()\n            } else {\n                // All other messages: expire and mark that it caused security degradation\n                message.expire()\n                message.causedSecurityLevelDegradation = true\n            }\n        }\n    }\n    \n    fileprivate var undeliveredMessages: [ZMOTRMessage] {\n        guard let managedObjectContext = managedObjectContext else { return [] }\n        \n        let timeoutLimit = Date().addingTimeInterval(-ZMMessage.defaultExpirationTime())\n        let selfUser = ZMUser.selfUser(in: managedObjectContext)\n        let undeliveredMessagesPredicate = NSPredicate(format: \"%K == %@ AND %K == %@ AND %K == NO\",\n                                                       ZMMessageConversationKey, self,\n                                                       ZMMessageSenderKey, selfUser,\n                                                       DeliveredKey)\n        \n        let fetchRequest = NSFetchRequest<ZMClientMessage>(entityName: ZMClientMessage.entityName())\n        fetchRequest.predicate = undeliveredMessagesPredicate\n        \n        let assetFetchRequest = NSFetchRequest<ZMAssetClientMessage>(entityName: ZMAssetClientMessage.entityName())\n        assetFetchRequest.predicate = undeliveredMessagesPredicate\n        \n        var undeliveredMessages: [ZMOTRMessage] = []\n        undeliveredMessages += managedObjectContext.fetchOrAssert(request: fetchRequest) as [ZMOTRMessage]\n        undeliveredMessages += managedObjectContext.fetchOrAssert(request: assetFetchRequest) as [ZMOTRMessage]\n        \n        return undeliveredMessages.filter { message in\n            return message.serverTimestamp > timeoutLimit || message.updatedAt > timeoutLimit\n        }\n    }\n    \n}\n\n// MARK: - HotFix\nextension ZMConversation {\n\n    /// Replaces the first NewClient systemMessage for the selfClient with a UsingNewDevice system message\n    @objc public func replaceNewClientMessageIfNeededWithNewDeviceMesssage() {\n\n        let selfUser = ZMUser.selfUser(in: self.managedObjectContext!)\n        guard let selfClient = selfUser.selfClient() else { return }\n        \n        NSOrderedSet(array: lastMessages()).enumerateObjects() { (msg, idx, stop) in\n            guard idx <= 2 else {\n                stop.initialize(to: true)\n                return\n            }\n            \n            guard let systemMessage = msg as? ZMSystemMessage,\n                systemMessage.systemMessageType == .newClient,\n                systemMessage.sender == selfUser else {\n                    return\n            }\n            \n            if systemMessage.clients.contains(selfClient) {\n                systemMessage.systemMessageType = .usingNewDevice\n                stop.initialize(to: true)\n            }\n        }\n    }\n}\n\n// MARK: - Appending system messages\nextension ZMConversation {\n    \n    fileprivate func appendNewIsSecureSystemMessage(cause: SecurityChangeCause) {\n        switch cause {\n        case .removedUsers(let users):\n            appendNewIsSecureSystemMessage(verified: [], for: users)\n        case .verifiedClients(let userClients):\n            let users = Set(userClients.compactMap { $0.user })\n            appendNewIsSecureSystemMessage(verified: userClients, for: users)\n        case .removedClients(let userClients):\n            let users = Set(userClients.keys)\n            let clients = Set(userClients.values.flatMap { $0 })\n            appendNewIsSecureSystemMessage(verified: clients, for: users)\n        default:\n            // no-op: the conversation is not secure in other cases\n            return\n        }\n    }\n    \n    fileprivate func appendNewIsSecureSystemMessage(verified clients: Set<UserClient>, for users: Set<ZMUser>) {\n        guard !users.isEmpty, securityLevel != .secureWithIgnored else {\n            return\n        }\n\n        appendSystemMessage(type: .conversationIsSecure,\n                            sender: ZMUser.selfUser(in: self.managedObjectContext!),\n                            users: users,\n                            clients: clients,\n                            timestamp: timestampAfterLastMessage())\n    }\n    \n    fileprivate enum SecurityChangeCause {\n        case addedClients(Set<UserClient>, source: ZMOTRMessage?)\n        case addedUsers(Set<ZMUser>)\n        case removedUsers(Set<ZMUser>)\n        case verifiedClients(Set<UserClient>)\n        case removedClients([ZMUser: Set<UserClient>])\n        case ignoredClients(Set<UserClient>)\n        case verifyLegalHold\n    }\n    \n    fileprivate func appendNewAddedClientSystemMessage(cause: SecurityChangeCause) {\n        var timestamp : Date?\n        var affectedUsers: Set<ZMUser> = []\n        var addedUsers: Set<ZMUser> = []\n        var addedClients: Set<UserClient> = []\n        \n        switch cause {\n        case .addedUsers(let users):\n            affectedUsers = users\n            addedUsers = users\n        case .addedClients(let clients, let message):\n            affectedUsers = Set(clients.compactMap(\\.user))\n            addedClients = clients\n            if let message = message, message.conversation == self {\n                timestamp = self.timestamp(before: message)\n            } else {\n                timestamp = clients.compactMap(\\.discoveryDate).first?.previousNearestTimestamp\n            }\n        default:\n            // unsupported cause\n            return\n        }\n        \n        guard !addedClients.isEmpty || !addedUsers.isEmpty else { return }\n        \n        self.appendSystemMessage(type: .newClient,\n                                 sender: ZMUser.selfUser(in: self.managedObjectContext!),\n                                 users: affectedUsers,\n                                 addedUsers: addedUsers,\n                                 clients: addedClients,\n                                 timestamp: timestamp ?? timestampAfterLastMessage())\n    }\n    \n    fileprivate func appendIgnoredClientsSystemMessage(ignored clients: Set<UserClient>) {\n        guard !clients.isEmpty else { return }\n        let users = Set(clients.compactMap { $0.user })\n        self.appendSystemMessage(type: .ignoredClient,\n                                 sender: ZMUser.selfUser(in: self.managedObjectContext!),\n                                 users: users,\n                                 clients: clients,\n                                 timestamp: timestampAfterLastMessage())\n    }\n    \n    @discardableResult\n    func appendSystemMessage(type: ZMSystemMessageType,\n                                         sender: ZMUser,\n                                         users: Set<ZMUser>?,\n                                         addedUsers: Set<ZMUser> = Set(),\n                                         clients: Set<UserClient>?,\n                                         timestamp: Date,\n                                         duration: TimeInterval? = nil,\n                                         messageTimer: Double? = nil,\n                                         relevantForStatus: Bool = true) -> ZMSystemMessage {\n        let systemMessage = ZMSystemMessage(nonce: UUID(), managedObjectContext: managedObjectContext!)\n        systemMessage.systemMessageType = type\n        systemMessage.sender = sender\n        systemMessage.users = users ?? Set()\n        systemMessage.addedUsers = addedUsers\n        systemMessage.clients = clients ?? Set()\n        systemMessage.serverTimestamp = timestamp\n        if let duration = duration {\n            systemMessage.duration = duration\n        }\n        \n        if let messageTimer = messageTimer {\n            systemMessage.messageTimer = NSNumber(value: messageTimer)\n        }\n        \n        systemMessage.relevantForConversationStatus = relevantForStatus\n        \n        self.append(systemMessage)\n        \n        return systemMessage\n    }\n    \n    /// Returns a timestamp that is shortly (as short as possible) before the given message,\n    /// or the last modified date if the message is nil\n    fileprivate func timestamp(before: ZMMessage?) -> Date? {\n        guard let timestamp = before?.serverTimestamp ?? self.lastModifiedDate else { return nil }\n        return timestamp.previousNearestTimestamp\n    }\n    \n    /// Returns a timestamp that is shortly (as short as possible) after the given message,\n    /// or the last modified date if the message is nil\n    fileprivate func timestamp(after: ZMConversationMessage?) -> Date? {\n        guard let timestamp = after?.serverTimestamp ?? self.lastModifiedDate else { return nil }\n        return timestamp.nextNearestTimestamp\n    }\n    \n    // Returns a timestamp that is shortly (as short as possible) after the last message in the conversation,\n    // or current time if there's no last message\n    fileprivate func timestampAfterLastMessage() -> Date {\n        return timestamp(after: lastMessage) ?? Date()\n    }\n}\n\n// MARK: - Conversation participants status\nextension ZMConversation {\n    \n    /// Returns true if all participants are connected to the self user and all participants are trusted\n    @objc\n    public var allUsersTrusted : Bool {\n        guard !localParticipants.isEmpty,\n              isSelfAnActiveMember else { return false }\n        \n        let hasOnlyTrustedUsers = localParticipants.allSatisfy { ($0.isTrusted && !$0.clients.isEmpty) }\n        \n        return hasOnlyTrustedUsers && !containsUnconnectedOrExternalParticipant\n    }\n    \n    fileprivate var containsUnconnectedOrExternalParticipant : Bool {\n        guard let managedObjectContext = self.managedObjectContext else {\n            return true\n        }\n        \n        let selfUser = ZMUser.selfUser(in: managedObjectContext)\n        return localParticipants.first {\n            if $0.isConnected || $0 == selfUser {\n                return false\n            } else if $0.isWirelessUser {\n                return false\n            }\n            else {\n                return selfUser.team == nil || $0.team != selfUser.team\n            }\n        } != nil\n    }\n    \n    fileprivate var allParticipantsHaveClients : Bool {\n        return self.localParticipants.first { $0.clients.count == 0 } == nil\n    }\n    \n    /// If true the conversation might still be trusted / ignored\n    @objc public var hasUntrustedClients : Bool {\n        return self.localParticipants.contains { !$0.isTrusted }\n    }\n}\n\n// MARK: - System messages\nextension ZMSystemMessage {\n\n    /// Fetch the first system message in the conversation about \"started to use this device\"\n    fileprivate static func fetchStartedUsingOnThisDeviceMessage(conversation: ZMConversation) -> ZMSystemMessage? {\n        guard let selfClient = ZMUser.selfUser(in: conversation.managedObjectContext!).selfClient() else { return nil }\n        let conversationPredicate = NSPredicate(format: \"%K == %@ OR %K == %@\", ZMMessageConversationKey, conversation, ZMMessageHiddenInConversationKey, conversation)\n        let newClientPredicate = NSPredicate(format: \"%K == %d\", ZMMessageSystemMessageTypeKey, ZMSystemMessageType.newClient.rawValue)\n        let containsSelfClient = NSPredicate(format: \"ANY %K == %@\", ZMMessageSystemMessageClientsKey, selfClient)\n        let compound = NSCompoundPredicate(andPredicateWithSubpredicates: [conversationPredicate, newClientPredicate, containsSelfClient])\n        \n        let fetchRequest = ZMSystemMessage.sortedFetchRequest(with: compound)\n        \n        let result = conversation.managedObjectContext!.fetchOrAssert(request: fetchRequest)\n        return result.first as? ZMSystemMessage\n    }\n}\n\nextension ZMMessage {\n    \n    /// True if the message is a \"conversation degraded because of new client\"\n    /// system message\n    fileprivate var isConversationNotVerifiedSystemMessage : Bool {\n        guard let system = self as? ZMSystemMessage else { return false }\n        return system.systemMessageType == .ignoredClient\n    }\n}\n\nextension Date {\n    var nextNearestTimestamp: Date {\n        return Date(timeIntervalSinceReferenceDate: timeIntervalSinceReferenceDate.nextUp)\n    }\n    var previousNearestTimestamp: Date {\n        return Date(timeIntervalSinceReferenceDate: timeIntervalSinceReferenceDate.nextDown)\n    }\n}\n\nextension NSDate {\n    @objc var nextNearestTimestamp: NSDate {\n        return NSDate(timeIntervalSinceReferenceDate: timeIntervalSinceReferenceDate.nextUp)\n    }\n    @objc var previousNearestTimestamp: NSDate {\n        return NSDate(timeIntervalSinceReferenceDate: timeIntervalSinceReferenceDate.nextDown)\n    }\n}\n", "//\n// Wire\n// Copyright (C) 2019 Wire Swiss GmbH\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see http://www.gnu.org/licenses/.\n//\n\nimport XCTest\n@testable import WireDataModel\n\nclass ZMConversationTests_SecurityLevel: ZMConversationTestsBase {\n    \n    private func createUsersWithClientsOnSyncMOC(count: Int) -> [ZMUser] {\n        self.selfUser = ZMUser.selfUser(in: self.syncMOC)\n        return (0..<count).map { i in\n            let user = ZMUser.insertNewObject(in: self.syncMOC)\n            let userClient = UserClient.insertNewObject(in: self.syncMOC)\n            let userConnection = ZMConnection.insertNewSentConnection(to: user)!\n            userConnection.status = .accepted\n            userClient.user = user\n            user.name = \"createdUser \\(i+1)\"\n            return user\n        }\n    }\n    \n    func testThatConversationInitialSecurityLevelIsNotSecured()\n    {\n        self.syncMOC.performGroupedAndWait {_ in\n            // given\n            let users = self.createUsersWithClientsOnSyncMOC(count: 2)\n            let conversation = ZMConversation.insertGroupConversation(moc: self.syncMOC, participants: users)!\n\n            // then\n            XCTAssertEqual(conversation.securityLevel, .notSecure)\n        }\n    }\n    \n    func testThatItIncreasesSecurityLevelIfAllClientsInConversationAreTrusted()\n    {\n        self.syncMOC.performGroupedAndWait {_ in\n            // given\n            let users = self.createUsersWithClientsOnSyncMOC(count: 2)\n            let conversation = ZMConversation.insertGroupConversation(moc: self.syncMOC, participants: users)!\n            let selfClient = self.createSelfClient(onMOC: self.syncMOC)\n            \n            // when\n            selfClient.trustClients(Set(users.map { $0.clients.first! }))\n            \n            // then\n            XCTAssertEqual(conversation.securityLevel, .secure)\n        }\n    }\n    \n    func testThatItDoesNotIncreaseTheSecurityLevelIfAConversationIsAConnection() {\n        self.syncMOC.performGroupedAndWait {_ in\n            // given\n            let selfUser = ZMUser.selfUser(in: self.uiMOC)\n            \n            let conversation = ZMConversation.insertNewObject(in: self.uiMOC)\n            conversation.conversationType = .connection\n            conversation.addParticipantAndUpdateConversationState(user: selfUser, role: nil)\n            let selfClient = self.createSelfClient(onMOC: self.uiMOC)\n            \n            let userClient = UserClient.insertNewObject(in: self.uiMOC)\n            userClient.remoteIdentifier = UUID.create().uuidString\n            userClient.user = selfUser\n            \n            // when\n            XCTAssertEqual(conversation.securityLevel, .notSecure)\n            XCTAssertFalse(conversation.allUsersTrusted)\n            \n            selfClient.trustClient(userClient)\n            conversation.increaseSecurityLevelIfNeededAfterTrusting(clients: Set([userClient]))\n            \n            // then\n            XCTAssertTrue(conversation.allUsersTrusted)\n            XCTAssertEqual(conversation.securityLevel, .notSecure)\n        }\n    }\n    \n    func testThatItDoesNotIncreaseTheSecurityLevelIfAConversationContainsUsersWithoutAConnection()\n    {\n        self.syncMOC.performGroupedAndWait {_ in\n            // given\n            let users = self.createUsersWithClientsOnSyncMOC(count: 2)\n            \n            let unconnectedUser = users.first!\n            let connectedUser = users.last!\n            unconnectedUser.connection!.status = .sent\n            \n            let conversation = ZMConversation.insertGroupConversation(moc: self.syncMOC, participants: users)!\n            let selfClient = self.createSelfClient(onMOC: self.syncMOC)\n            \n            // when\n            selfClient.trustClients(connectedUser.clients)\n            \n            // then\n            XCTAssertFalse(conversation.allUsersTrusted)\n            XCTAssertEqual(conversation.securityLevel, .notSecure)\n            \n            // when\n            unconnectedUser.connection!.status = .accepted\n            selfClient.trustClients(unconnectedUser.clients)\n            \n            // then\n            XCTAssertTrue(conversation.allUsersTrusted)\n            XCTAssertEqual(conversation.securityLevel, .secure)\n            \n            let newUnconnectedUser = ZMUser.insertNewObject(in: self.syncMOC)\n            let unconnectedUserClient = UserClient.insertNewObject(in: self.syncMOC)\n            unconnectedUserClient.user = newUnconnectedUser\n            \n            // when adding a new participant\n            conversation.addParticipantAndUpdateConversationState(user: newUnconnectedUser, role: nil)\n            \n            // then the conversation should degrade\n            XCTAssertFalse(conversation.allUsersTrusted)\n            XCTAssertEqual(conversation.securityLevel, .secureWithIgnored)\n            \n            // when\n            conversation.removeParticipantAndUpdateConversationState(user: newUnconnectedUser, initiatingUser:  self.selfUser)\n            \n            // then\n            XCTAssertTrue(conversation.allUsersTrusted)\n            XCTAssertEqual(conversation.securityLevel, .secure)\n        }\n    }\n\n    func testThatItIncreaseTheSecurityLevelIfAConversationContainsUsersWithoutAConnection_Wireless()\n    {\n        self.syncMOC.performGroupedAndWait {_ in\n            // given\n            let users = self.createUsersWithClientsOnSyncMOC(count: 2)\n            \n            let unconnectedUser = users.first!\n            let connectedUser = users.last!\n            unconnectedUser.expiresAt = Date(timeIntervalSinceNow: 60)\n            unconnectedUser.connection = nil\n            \n            XCTAssertTrue(unconnectedUser.isWirelessUser)\n            XCTAssertFalse(unconnectedUser.isConnected)\n            XCTAssertNil(unconnectedUser.team)\n            \n            let conversation = ZMConversation.insertGroupConversation(moc: self.syncMOC, participants: users)!\n            let selfClient = self.createSelfClient(onMOC: self.syncMOC)\n            \n            // when\n            selfClient.trustClients(connectedUser.clients)\n            selfClient.trustClients(unconnectedUser.clients)\n            \n            // then\n            XCTAssertTrue(conversation.allUsersTrusted)\n            XCTAssertEqual(conversation.securityLevel, .secure)\n        }\n    }\n    \n    func testThatItDoesDecreaseTheSecurityLevelWhenAskedToMakeNotSecure()\n    {\n        // given\n        let conversation = ZMConversation.insertNewObject(in: self.uiMOC)\n        conversation.conversationType = .oneOnOne\n        conversation.securityLevel = .secureWithIgnored\n        \n        // when\n        conversation.acknowledgePrivacyWarning(withResendIntent: false)\n        \n        // then\n        XCTAssertEqual(conversation.securityLevel, .notSecure)\n    }\n    \n    func testThatItInsertsAnIgnoredClientsSystemMessageWhenAddingAConversationParticipantInASecuredConversation()\n    {\n        self.syncMOC.performGroupedAndWait { _ in\n            // given\n            let users = self.createUsersWithClientsOnSyncMOC(count: 2)\n            \n            let conversation = ZMConversation.insertGroupConversation(moc: self.syncMOC, participants: users)!\n            let selfClient = self.createSelfClient(onMOC: self.syncMOC)\n            \n            // when\n            selfClient.trustClients(users.first!.clients)\n            selfClient.trustClients(users.last!.clients)\n            \n            // then\n            XCTAssertTrue(conversation.allUsersTrusted)\n            XCTAssertEqual(conversation.securityLevel, .secure)\n            \n            // when adding a new participant\n            let user3 = self.createUsersWithClientsOnSyncMOC(count: 1).last!\n            conversation.addParticipantAndUpdateConversationState(user: user3, role: nil)\n            \n            // then the conversation should degrade\n            XCTAssertFalse(conversation.allUsersTrusted)\n            XCTAssertEqual(conversation.securityLevel, .secureWithIgnored)\n            \n            // Conversation degraded message\n            let conversationDegradedMessage = conversation.lastMessage as? ZMSystemMessage\n            XCTAssertEqual(conversationDegradedMessage?.systemMessageType, .newClient)\n            XCTAssertEqual(conversationDegradedMessage?.addedUsers, Set([user3]))\n            XCTAssertEqual(conversationDegradedMessage?.users, Set([user3]))\n            \n            // when\n            conversation.removeParticipantAndUpdateConversationState(user: user3, initiatingUser:  self.selfUser)\n            \n            // then\n            XCTAssertTrue(conversation.allUsersTrusted)\n            XCTAssertEqual(conversation.securityLevel, .secure)\n            let message2 = conversation.lastMessage as? ZMSystemMessage\n            XCTAssertEqual(message2?.systemMessageType, .conversationIsSecure)\n        }\n    }\n    \n    func testThatItDoesNotIncreaseSecurityLevelIfNotAllClientsAreTrusted()\n    {\n        self.syncMOC.performGroupedAndWait { _ in\n            // given\n            let users = self.createUsersWithClientsOnSyncMOC(count: 2)\n            let conversation = ZMConversation.insertGroupConversation(moc: self.syncMOC, participants: users)!\n            let selfClient = self.createSelfClient(onMOC: self.syncMOC)\n            \n            // when\n            selfClient.trustClients(users.first!.clients)\n            \n            // then\n            XCTAssertEqual(conversation.securityLevel, .notSecure)\n        }\n    }\n    \n    func testThatItDoesNotIncreaseSecurityLevelIfNotAllUsersHaveClients()\n    {\n        self.syncMOC.performGroupedAndWait { _ in\n            // given\n            let userWithoutClients = ZMUser.insertNewObject(in: self.syncMOC)\n            let users = self.createUsersWithClientsOnSyncMOC(count: 2) + [userWithoutClients]\n            let conversation = ZMConversation.insertGroupConversation(moc: self.syncMOC, participants: users)!\n            let selfClient = self.createSelfClient(onMOC: self.syncMOC)\n            \n            let allClients = users.flatMap {\n                $0.clients\n            }\n            \n            // when\n            selfClient.trustClients(Set(allClients))\n            \n            // then\n            XCTAssertEqual(conversation.securityLevel, .notSecure)\n        }\n    }\n    \n    func testThatItDecreaseSecurityLevelIfSomeOfTheClientsIsIgnored()\n    {\n        self.syncMOC.performGroupedAndWait { _ in\n            // given\n            let users = self.createUsersWithClientsOnSyncMOC(count: 2)\n            let conversation = ZMConversation.insertGroupConversation(moc: self.syncMOC, participants: users)!\n            let selfClient = self.createSelfClient(onMOC: self.syncMOC)\n            \n            // when\n            selfClient.trustClients(users.first!.clients.union(users.last!.clients))\n            selfClient.ignoreClients(users.first!.clients)\n            \n            // then\n            XCTAssertEqual(conversation.securityLevel, .secureWithIgnored)\n        }\n    }\n    \n    func testThatItDoesNotDecreaseSecurityLevelIfItIsInPartialSecureLevel()\n    {\n        self.syncMOC.performGroupedAndWait { _ in\n            // given\n            let users = self.createUsersWithClientsOnSyncMOC(count: 2)\n            let conversation = ZMConversation.insertGroupConversation(moc: self.syncMOC, participants: users)!\n            let selfClient = self.createSelfClient(onMOC: self.syncMOC)\n            \n            // when\n            selfClient.trustClients(users.first!.clients.union(users.last!.clients))\n            selfClient.ignoreClients(users.first!.clients)\n            \n            // then\n            XCTAssertEqual(conversation.securityLevel, .secureWithIgnored)\n            \n            // and when\n            selfClient.ignoreClients(users.last!.clients)\n            \n            // then we should not change the security level as we were already ignored\n            XCTAssertEqual(conversation.securityLevel, .secureWithIgnored)\n        }\n    }\n    \n    func testThatItCorrectlySetsNeedUpdatingUsersFlagOnPotentialGapSystemMessage()\n    {\n        // given\n        let conversation = ZMConversation.insertNewObject(in: self.uiMOC)\n        conversation.remoteIdentifier = UUID.create()\n        conversation.appendNewPotentialGapSystemMessage(users: nil, timestamp: Date())\n        \n        // then\n        var fetchedMessage = ZMSystemMessage.fetchLatestPotentialGapSystemMessage(in: conversation)\n        XCTAssertEqual(conversation.allMessages.count, 1)\n        XCTAssertNotNil(fetchedMessage)\n        XCTAssertTrue(fetchedMessage!.needsUpdatingUsers)\n        \n        // when\n        conversation.updatePotentialGapSystemMessagesIfNeeded(users: Set())\n        \n        // then\n        XCTAssertFalse(fetchedMessage!.needsUpdatingUsers)\n        fetchedMessage = ZMSystemMessage.fetchLatestPotentialGapSystemMessage(in: conversation)\n        XCTAssertEqual(conversation.allMessages.count, 1)\n        XCTAssertNil(fetchedMessage)\n    }\n    \n    func testThatItNotifiesWhenAllClientAreVerified()\n    {\n        var conversationObjectID: NSManagedObjectID! = nil\n        var token: Any? = nil\n        self.syncMOC.performGroupedAndWait { _ in\n            // given\n            let users = self.createUsersWithClientsOnSyncMOC(count: 2)\n            let conversation = ZMConversation.insertGroupConversation(moc: self.syncMOC, participants: users)!\n            let selfClient = self.createSelfClient(onMOC: self.syncMOC)\n            \n            // expect\n            let expectation = self.expectation(description: \"Notified\")\n            token = NotificationInContext.addObserver(\n                name: ZMConversation.isVerifiedNotificationName,\n                context: self.uiMOC.notificationContext) {\n                    XCTAssertEqual($0.object as? ZMConversation, conversation)\n                    if ($0.object as? ZMConversation) == conversation {\n                        expectation.fulfill()\n                    }\n                }\n        \n            // when\n            XCTAssertNotEqual(conversation.securityLevel, .secure)\n            selfClient.trustClients(users.first!.clients.union(users.last!.clients))\n            \n            conversationObjectID = conversation.objectID\n            self.syncMOC.saveOrRollback()\n        }\n        \n        // then\n        let uiConversation = try! self.uiMOC.existingObject(with: conversationObjectID!) as! ZMConversation\n        XCTAssertEqual(uiConversation.securityLevel, .secure)\n        XCTAssertTrue(self.waitForCustomExpectations(withTimeout: 0.5))\n        _ = String(describing: token) // so that it does not complain that is never read\n    }\n    \n    func testThatIncreasesSecurityLevelOfCreatedGroupConversationWithAllParticipantsAlreadyTrusted()\n    {\n        \n        self.syncMOC.performGroupedAndWait { _ -> () in\n            // given\n            let users = self.createUsersWithClientsOnSyncMOC(count: 2)\n            let clients = users.first!.clients.union(users.last!.clients)\n            let selfClient = self.createSelfClient(onMOC: self.syncMOC)\n            selfClient.trustClients(clients)\n            \n            // when\n            let conversation = ZMConversation.insertGroupConversation(moc: self.syncMOC, participants: users)!\n            // then\n            XCTAssertEqual(conversation.securityLevel, .secure)\n            guard let message = conversation.lastMessage as? ZMSystemMessage,\n                let systemMessageData = message.systemMessageData else {\n                return XCTFail()\n            }\n            XCTAssertEqual(systemMessageData.systemMessageType, .conversationIsSecure)\n            XCTAssertEqual(systemMessageData.clients, clients.union([selfClient]))\n        }\n        \n        XCTAssertTrue(self.waitForCustomExpectations(withTimeout: 0.5))\n    }\n    \n    func testThatItDoesNotIncreaseSecurityLevelOfCreatedGroupConversationWithAllParticipantsIfNotAlreadyTrusted()\n    {\n        self.syncMOC.performGroupedAndWait { _ -> () in\n            // given\n            let users = self.createUsersWithClientsOnSyncMOC(count: 2)\n            let selfClient = self.createSelfClient(onMOC: self.syncMOC)\n            selfClient.trustClients(users.first!.clients)\n            \n            // when\n            let conversation = ZMConversation.insertGroupConversation(moc: self.syncMOC, participants: users)!\n            // then\n            XCTAssertEqual(conversation.securityLevel, .notSecure)\n            guard let message = conversation.lastMessage as? ZMSystemMessage else {\n                return XCTFail()\n            }\n            XCTAssertNotEqual(message.systemMessageType, .conversationIsSecure)\n        }\n        \n        XCTAssertTrue(self.waitForCustomExpectations(withTimeout: 0.5))\n    }\n    \n    private var creationCounter = 1 // used to distinguish users\n    \n    func insertUser(conversation: ZMConversation, userIsTrusted: Bool, moc: NSManagedObjectContext) -> ZMUser\n    {\n        let selfClient = self.createSelfClient(onMOC: moc)\n        self.uiMOC.refreshAllObjects()\n        \n        let user = ZMUser.insertNewObject(in: moc)\n        user.name = \"insertUser \\(creationCounter)\"\n        self.creationCounter += 1\n        conversation.addParticipantAndUpdateConversationState(user: user, role: nil)\n        let client = UserClient.insertNewObject(in: moc)\n        client.user  = user\n        if (userIsTrusted) {\n            selfClient.trustClient(client)\n        } else {\n            selfClient.ignoreClient(client)\n        }\n        return user\n    }\n    \n    func testThatItReturns_HasUntrustedClients_YES_ifThereAreUntrustedClients()\n    {\n        // given\n        let conversation = ZMConversation.insertNewObject(in: self.uiMOC)\n        conversation.conversationType = .group\n        \n        // when\n        _ = self.insertUser(conversation: conversation, userIsTrusted: false, moc: self.uiMOC)\n        let hasUntrustedClients = conversation.hasUntrustedClients\n        \n        // then\n        XCTAssertTrue(hasUntrustedClients)\n        \n    }\n    \n    func testThatItReturns_HasUntrustedClients_NO_ifThereAreNoUntrustedClients()\n    {\n        // given\n        let conversation = ZMConversation.insertNewObject(in: self.uiMOC)\n        conversation.conversationType = .group\n        \n        // when\n        _ = self.insertUser(conversation: conversation, userIsTrusted: true, moc: self.uiMOC)\n        let hasUntrustedClients = conversation.hasUntrustedClients\n        \n        // then\n        XCTAssertFalse(hasUntrustedClients)\n    }\n    \n    func testThatItReturns_HasUntrustedClients_NO_ifThereAreNoOtherClients()\n    {\n        // given\n        let conversation = ZMConversation.insertNewObject(in: self.uiMOC)\n        conversation.conversationType = .group\n        let user = ZMUser.insertNewObject(in: self.uiMOC)\n        conversation.addParticipantAndUpdateConversationState(user: user, role: nil)\n        \n        // when\n        let hasUntrustedClients = conversation.hasUntrustedClients\n        \n        // then\n        XCTAssertFalse(hasUntrustedClients)\n    }\n    \n    \n    func testThatItReturns_HasUntrustedClients_NO_ifThereAreNoOtherUsers()\n    {\n        // given\n        let conversation = ZMConversation.insertNewObject(in: self.uiMOC)\n        conversation.conversationType = .group\n        \n        // when\n        let hasUntrustedClients = conversation.hasUntrustedClients\n        \n        // then\n        XCTAssertFalse(hasUntrustedClients)\n    }\n    \n    func testThatItAppendsASystemMessageOfTypeRemoteIDChangedForCBErrorCodeRemoteIdentityChanged()\n    {\n        // given\n        let conversation = ZMConversation.insertNewObject(in: self.uiMOC)\n        conversation.conversationType = .group\n        let user = ZMUser.insertNewObject(in: self.uiMOC)\n        user.name = \"Fancy One\"\n        let decryptionError = CBOX_REMOTE_IDENTITY_CHANGED\n        \n        // when\n        conversation.appendDecryptionFailedSystemMessage(at: Date(), sender: user, client: nil, errorCode: Int(decryptionError.rawValue))\n        \n        // then\n        guard let lastMessage = conversation.lastMessage as? ZMSystemMessage else {\n            return XCTFail()\n        }\n        XCTAssertEqual(lastMessage.systemMessageType, ZMSystemMessageType.decryptionFailed_RemoteIdentityChanged)\n        XCTAssertEqual(lastMessage.decryptionErrorCode?.intValue, Int(decryptionError.rawValue))\n    }\n    \n    func testThatItAppendsASystemMessageOfGeneralTypeForCBErrorCodeInvalidMessage()\n    {\n        // given\n        let conversation = ZMConversation.insertNewObject(in: self.uiMOC)\n        conversation.conversationType = .group\n        let user = ZMUser.insertNewObject(in: self.uiMOC)\n        user.name = \"Fancy One\"\n        let decryptionError = CBOX_INVALID_MESSAGE\n        \n        // when\n        conversation.appendDecryptionFailedSystemMessage(at: Date(), sender: user, client: nil, errorCode: Int(decryptionError.rawValue))\n        \n        // then\n        guard let lastMessage = conversation.lastMessage as? ZMSystemMessage else {\n            return XCTFail()\n        }\n        XCTAssertEqual(lastMessage.systemMessageType, ZMSystemMessageType.decryptionFailed)\n        XCTAssertEqual(lastMessage.decryptionErrorCode?.intValue, Int(decryptionError.rawValue))\n    }\n        \n    func testThatAConversationIsNotTrustedIfItHasNoOtherParticipants()\n    {\n        // GIVEN\n        let conversation = ZMConversation.insertNewObject(in: self.uiMOC)\n        conversation.conversationType = .group\n        \n        // THEN\n        XCTAssertFalse(conversation.allUsersTrusted)\n    }\n    \n    func testThatAConversationIsTrustedIfItHasTeamUsers()\n    {\n        self.syncMOC.performGroupedAndWait { _ in\n            // GIVEN\n            let conversation = ZMConversation.insertNewObject(in: self.syncMOC)\n            conversation.conversationType = .group\n            \n            let selfUser = ZMUser.selfUser(in: self.syncMOC)\n            selfUser.name = \"MYSELF\"\n            conversation.addParticipantAndUpdateConversationState(user: selfUser, role: nil)\n            \n            let mainTeam = Team.fetchOrCreate(with: UUID.create(),\n                                              create: true,\n                                              in: self.syncMOC,\n                                              created: nil)!\n            \n            _ = Member.getOrCreateMember(for: selfUser, in: mainTeam, context: self.syncMOC)\n            \n            // WHEN\n            let user = self.insertUser(conversation: conversation, userIsTrusted: true, moc: self.syncMOC)\n            _ = Member.getOrCreateMember(for: user, in: mainTeam, context: self.syncMOC)\n\n            // THEN\n            XCTAssertTrue(conversation.allUsersTrusted)\n        }\n    }\n    \n    func testThatAConversationIsNotTrustedIfItExternalUsers()\n    {\n        self.syncMOC.performGroupedAndWait { _ in\n            // GIVEN\n            let conversation = ZMConversation.insertNewObject(in: self.syncMOC)\n            conversation.conversationType = .group\n            \n            let selfUser = ZMUser.selfUser(in: self.syncMOC)\n            \n            let mainTeam = Team.fetchOrCreate(with: UUID.create(),\n                                              create: true,\n                                              in: self.syncMOC,\n                                              created: nil)!\n            \n            _ = Member.getOrCreateMember(for: selfUser, in: mainTeam, context: self.syncMOC)\n            \n            // WHEN\n            _ = self.insertUser(conversation: conversation, userIsTrusted: true, moc: self.syncMOC)\n            \n            // THEN\n            XCTAssertFalse(conversation.allUsersTrusted)\n        }\n    }\n    \n    func testThatAConversationIsNotTrustedIfNotAMemberAnymore()\n    {\n        // GIVEN\n        let conversation = ZMConversation.insertNewObject(in: self.uiMOC)\n        conversation.conversationType = .group\n        let otherUser = ZMUser.insertNewObject(in: self.uiMOC)\n        conversation.addParticipantAndUpdateConversationState(user: otherUser, role: nil)\n        let client = UserClient.insertNewObject(in: self.uiMOC)\n        client.user = otherUser\n        let selfUser = ZMUser.selfUser(in: self.uiMOC)\n        selfUser.selfClient()?.trustClient(client)\n        \n        // WHEN\n        conversation.removeParticipantAndUpdateConversationState(user: selfUser, initiatingUser:  otherUser)\n        \n        // THEN\n        XCTAssertFalse(conversation.allUsersTrusted)\n    }\n    \n    \n    //MARK:- Resending / cancelling messages in degraded conversation\n    \n    func testItExpiresAllMessagesAfterTheCurrentOneWhenAUserCausesDegradation()\n    {\n        self.syncMOC.performGroupedAndWait { _ in\n            \n            // GIVEN\n            self.createSelfClient()\n            let conversation = ZMConversation.insertNewObject(in: self.syncMOC)\n            conversation.conversationType = .group\n            let selfUser = ZMUser.selfUser(in: self.syncMOC)\n            \n            let user = ZMUser.insertNewObject(in: self.syncMOC)\n            conversation.addParticipantsAndUpdateConversationState(users: Set([user, selfUser]), role: nil)\n            conversation.securityLevel = .secure\n            \n            let message1 = try! conversation.appendImage(from: self.verySmallJPEGData()) as! ZMOTRMessage\n            Thread.sleep(forTimeInterval: 0.1)  // cause system time to advance\n            let message2 = try! conversation.appendText(content: \"foo 2\") as! ZMOTRMessage\n            \n            let client = UserClient.insertNewObject(in: self.syncMOC)\n            client.remoteIdentifier = \"aabbccdd\"\n            client.user = user\n            \n            // WHEN\n            conversation.decreaseSecurityLevelIfNeededAfterDiscovering(\n                clients: Set([client]), causedBy: Set([user]))\n            \n            // THEN\n            XCTAssertTrue(message1.isExpired)\n            XCTAssertTrue(message1.causedSecurityLevelDegradation)\n            XCTAssertTrue(message2.isExpired)\n            XCTAssertTrue(message2.causedSecurityLevelDegradation)\n            XCTAssertFalse(conversation.allUsersTrusted)\n            XCTAssertEqual(conversation.securityLevel, .secureWithIgnored)\n        }\n    }\n    \n    func testItExpiresAllMessagesAfterTheCurrentOneWhenAMessageCausesDegradation()\n    {\n        self.syncMOC.performGroupedAndWait { _ in\n            \n            // GIVEN\n            self.createSelfClient()\n            let conversation = ZMConversation.insertNewObject(in: self.syncMOC)\n            conversation.conversationType = .group\n            let user = self.insertUser(conversation: conversation, userIsTrusted: true, moc: self.syncMOC)\n            conversation.securityLevel = .secure\n            \n            let message1 = try! conversation.appendImage(from: self.verySmallJPEGData()) as! ZMOTRMessage\n            Thread.sleep(forTimeInterval: 0.1) // cause system time to advance\n            let message2 = try! conversation.appendText(content: \"foo 2\") as! ZMOTRMessage\n            Thread.sleep(forTimeInterval: 0.1) // cause system time to advance\n            let message3 = try! conversation.appendText(content: \"foo 3\") as! ZMOTRMessage\n            Thread.sleep(forTimeInterval: 0.1) // cause system time to advance\n            let message4 = try! conversation.appendText(content: \"foo 4\") as! ZMOTRMessage\n            Thread.sleep(forTimeInterval: 0.1) // cause system time to advance\n            let message5 = try! conversation.appendImage(from: self.verySmallJPEGData()) as! ZMOTRMessage\n            \n            \n            let client = UserClient.insertNewObject(in: self.syncMOC)\n            client.remoteIdentifier = \"aabbccdd\"\n            client.user = user\n            \n            // WHEN\n            conversation.decreaseSecurityLevelIfNeededAfterDiscovering(clients: Set([client]), causedBy: message3)\n            \n            // THEN\n            XCTAssertTrue(message1.isExpired)\n            XCTAssertTrue(message1.causedSecurityLevelDegradation)\n            XCTAssertTrue(message2.isExpired)\n            XCTAssertTrue(message2.causedSecurityLevelDegradation)\n            XCTAssertTrue(message3.isExpired)\n            XCTAssertTrue(message3.causedSecurityLevelDegradation)\n            XCTAssertTrue(message4.isExpired)\n            XCTAssertTrue(message4.causedSecurityLevelDegradation)\n            XCTAssertTrue(message5.isExpired)\n            XCTAssertTrue(message5.causedSecurityLevelDegradation)\n            XCTAssertFalse(conversation.allUsersTrusted)\n            XCTAssertEqual(conversation.securityLevel, .secureWithIgnored)\n        }\n    }\n    \n    func testItCancelsAllMessagesThatCausedDegradation()\n    {\n        var conversation: ZMConversation! = nil\n        var message1: ZMOTRMessage! = nil\n        var message2: ZMOTRMessage! = nil\n        var message3: ZMOTRMessage! = nil\n        \n        self.syncMOC.performGroupedAndWait { _ in\n            \n            // GIVEN\n            self.createSelfClient()\n            conversation = ZMConversation.insertNewObject(in: self.syncMOC)\n            conversation.conversationType = .group\n            let user = self.insertUser(conversation: conversation, userIsTrusted: true, moc: self.syncMOC)\n            conversation.securityLevel = .secure\n            \n            message1 = try! conversation.appendText(content: \"foo 2\") as! ZMOTRMessage\n            Thread.sleep(forTimeInterval: 0.1) // cause system time to advance\n            message2 = try! conversation.appendText(content: \"foo 3\") as! ZMOTRMessage\n            Thread.sleep(forTimeInterval: 0.1) // cause system time to advance\n            message3 = try! conversation.appendImage(from: self.verySmallJPEGData()) as! ZMOTRMessage\n            \n            \n            let client = UserClient.insertNewObject(in: self.syncMOC)\n            client.remoteIdentifier = \"aabbccdd\"\n            client.user = user\n            conversation.decreaseSecurityLevelIfNeededAfterDiscovering(clients: Set([client]), causedBy: message2)\n            self.syncMOC.saveOrRollback()\n        }\n        \n        // WHEN\n        let uiConversation = try! self.uiMOC.existingObject(with: conversation.objectID) as! ZMConversation\n        uiConversation.acknowledgePrivacyWarning(withResendIntent: false)\n        \n        self.syncMOC.performGroupedAndWait { moc in\n            moc.refreshAllObjects()\n            \n            // THEN\n            XCTAssertTrue(message1.isExpired)\n            XCTAssertFalse(message1.causedSecurityLevelDegradation)\n            XCTAssertTrue(message2.isExpired)\n            XCTAssertFalse(message2.causedSecurityLevelDegradation)\n            XCTAssertEqual(message2.deliveryState, .failedToSend)\n            XCTAssertTrue(message3.isExpired)\n            XCTAssertFalse(message3.causedSecurityLevelDegradation)\n            XCTAssertEqual(message3.deliveryState, .failedToSend)\n            XCTAssertFalse(conversation.allUsersTrusted)\n            XCTAssertEqual(conversation.securityLevel, .notSecure)\n        }\n    }\n    \n    func testItMarksConversationAsNotSecureAfterResendMessages()\n    {\n        var conversation: ZMConversation! = nil\n        self.syncMOC.performGroupedAndWait { _ in\n            // GIVEN\n            conversation = ZMConversation.insertNewObject(in: self.syncMOC)\n            conversation.conversationType = .group\n            conversation.securityLevel = .secureWithIgnored\n            self.syncMOC.saveOrRollback()\n        }\n        \n        // WHEN\n        let uiConversation = try! self.uiMOC.existingObject(with: conversation.objectID) as! ZMConversation\n        uiConversation.acknowledgePrivacyWarning(withResendIntent: true)\n        self.uiMOC.saveOrRollback()\n        \n        self.syncMOC.performGroupedAndWait { _ in\n            self.syncMOC.refreshAllObjects()\n            \n            // THEN\n            XCTAssertEqual(conversation.securityLevel, .notSecure)\n        }\n    }\n    \n    func testItResendsAllMessagesThatCausedDegradation()\n    {\n        var conversation: ZMConversation! = nil\n        var message1: ZMOTRMessage! = nil\n        var message2: ZMOTRMessage! = nil\n        var message3: ZMOTRMessage! = nil\n        \n        self.syncMOC.performGroupedAndWait { _ in\n            \n            // GIVEN\n            self.createSelfClient()\n            conversation = ZMConversation.insertNewObject(in: self.syncMOC)\n            conversation.conversationType = .group\n            let user = self.insertUser(conversation: conversation, userIsTrusted: true, moc: self.syncMOC)\n            conversation.securityLevel = .secure\n            \n            message1 = try! conversation.appendText(content: \"foo 2\") as! ZMOTRMessage\n            Thread.sleep(forTimeInterval: 0.1) // cause system time to advance\n            message2 = try! conversation.appendText(content: \"foo 3\") as! ZMOTRMessage\n            Thread.sleep(forTimeInterval: 0.1) // cause system time to advance\n            message3 = try! conversation.appendImage(from: self.verySmallJPEGData()) as! ZMOTRMessage\n            \n            \n            let client = UserClient.insertNewObject(in: self.syncMOC)\n            client.remoteIdentifier = \"aabbccdd\"\n            client.user = user\n            conversation.decreaseSecurityLevelIfNeededAfterDiscovering(clients: Set([client]), causedBy: message2)\n            self.syncMOC.saveOrRollback()\n            \n            XCTAssertTrue(message1.isExpired)\n            XCTAssertTrue(message1.causedSecurityLevelDegradation)\n            XCTAssertTrue(message2.isExpired)\n            XCTAssertTrue(message2.causedSecurityLevelDegradation)\n            XCTAssertTrue(message3.isExpired)\n            XCTAssertTrue(message3.causedSecurityLevelDegradation)\n        }\n        \n        // WHEN\n        let uiConversation = try! self.uiMOC.existingObject(with: conversation.objectID) as! ZMConversation\n        uiConversation.acknowledgePrivacyWarning(withResendIntent: true)\n        \n        self.syncMOC.performGroupedAndWait { _ in\n            \n            // THEN\n            XCTAssertFalse(message1.isExpired)\n            XCTAssertFalse(message1.causedSecurityLevelDegradation)\n            XCTAssertFalse(message2.isExpired)\n            XCTAssertFalse(message3.causedSecurityLevelDegradation)\n            XCTAssertEqual(message2.deliveryState, .pending)\n            XCTAssertFalse(message3.isExpired)\n            XCTAssertFalse(message3.causedSecurityLevelDegradation)\n            XCTAssertEqual(message3.deliveryState, .pending)\n            XCTAssertFalse(conversation.allUsersTrusted)\n            XCTAssertNotEqual(conversation.securityLevel, .secure)\n        }\n    }\n    \n    //MARK: - Hotfix\n    \n    func testThatItUpdatesFirstNewClientSystemMessage()\n    {\n        // given\n        self.createSelfClient()\n        self.uiMOC.refreshAllObjects()\n        \n        let selfUser = ZMUser.selfUser(in: self.uiMOC)\n        let selfClient = selfUser.selfClient()\n        let systemMessageClients = Set(arrayLiteral: selfClient)\n        XCTAssertNotNil(selfClient)\n        \n        let conv = ZMConversation.insertNewObject(in: self.uiMOC)\n        conv.conversationType = .oneOnOne\n        \n        let systemMessage = ZMSystemMessage(nonce: UUID.create(), managedObjectContext: self.uiMOC)\n        systemMessage.visibleInConversation = conv\n        systemMessage.systemMessageType = .newClient\n        systemMessage.sender = selfUser\n        systemMessage.clients = systemMessageClients\n        systemMessage.serverTimestamp = Date()\n        \n        // when\n        conv.replaceNewClientMessageIfNeededWithNewDeviceMesssage()\n        \n        // then\n        XCTAssertEqual(systemMessage.systemMessageType, .usingNewDevice)\n    }\n    \n    //MARK: - Add/Remove participants\n    \n    func simulateAdding(users: Set<ZMUser>, conversation: ZMConversation, by actionUser: ZMUser) -> ZMSystemMessage {\n\n        let userIDs = users.map { $0.remoteIdentifier.transportString() }\n        let data = [\"user_ids\": userIDs]\n        let payload = self.payloadForMessage(\n            in: conversation,\n            type: EventConversationMemberJoin,\n            data: data,\n            time: Date(),\n            from: actionUser\n        )\n        let event = ZMUpdateEvent(fromEventStreamPayload: payload, uuid: nil)!\n        \n        var result: ZMSystemMessage! = nil\n        self.performPretendingUiMocIsSyncMoc() {\n            users.forEach {\n                conversation.addParticipantAndUpdateConversationState(user: $0, role: nil)\n            }\n            result = ZMSystemMessage.createOrUpdate(from: event, in: conversation.managedObjectContext!, prefetchResult: nil)\n        }\n        return result\n    }\n    \n    func simulateRemoving(users: Set<ZMUser>, conversation: ZMConversation, by actionUser: ZMUser) -> ZMSystemMessage {\n        let userIDs = users.map { $0.remoteIdentifier.transportString() }\n        let data = [\"user_ids\": userIDs]\n        let payload = self.payloadForMessage(\n            in: conversation,\n            type: EventConversationMemberLeave,\n            data: data,\n            time: Date(),\n            from: actionUser\n        )\n        let event = ZMUpdateEvent(fromEventStreamPayload: payload, uuid: nil)!\n        \n        var result: ZMSystemMessage! = nil\n        self.performPretendingUiMocIsSyncMoc() {\n            conversation.removeParticipantsAndUpdateConversationState(users: users, initiatingUser: actionUser)\n            result = ZMSystemMessage.createOrUpdate(from: event, in: conversation.managedObjectContext!, prefetchResult: nil)\n        }\n        return result\n    }\n    \n    func setupVerifiedConversation() -> ZMConversation {\n        let selfUser = ZMUser.selfUser(in: self.uiMOC)\n        selfUser.remoteIdentifier = UUID()\n        let selfClient = self.createSelfClient(onMOC: self.uiMOC)\n        \n        let conversation = ZMConversation.insertNewObject(in: self.uiMOC)\n        conversation.conversationType = .group\n        conversation.remoteIdentifier = UUID()\n        conversation.addParticipantAndUpdateConversationState(user: selfUser, role: nil)\n        \n        let verifiedUser = ZMUser.insertNewObject(in: self.uiMOC)\n        verifiedUser.remoteIdentifier = UUID()\n        let verifiedUserConnection = ZMConnection.insertNewSentConnection(to: verifiedUser)!\n        verifiedUserConnection.status = .accepted\n        \n        let verifiedUserClient = UserClient.insertNewObject(in: self.uiMOC)\n        verifiedUserClient.user = verifiedUser\n        \n        conversation.addParticipantAndUpdateConversationState(user: verifiedUser, role: nil)\n        \n        selfClient.trustClients(Set([verifiedUserClient]))\n        conversation.increaseSecurityLevelIfNeededAfterTrusting(clients: Set([verifiedUserClient]))\n        return conversation\n    }\n    \n    func setupUnverifiedUsers(count: Int) -> Set<ZMUser> {\n        \n        return Set((0..<count).map { _ in\n            let unverifiedUser = ZMUser.insertNewObject(in: self.uiMOC)\n            let unverifiedUserConnection = ZMConnection.insertNewSentConnection(to: unverifiedUser)!\n            unverifiedUserConnection.status = .accepted\n            unverifiedUser.remoteIdentifier = UUID()\n            return unverifiedUser\n        })\n    }\n    \n    func testThatItDoesNotInsertDegradedMessageWhenAddingVerifiedUsers()\n    {\n        // GIVEN\n        let conversation = self.setupVerifiedConversation()\n        let selfUser = ZMUser.selfUser(in: self.uiMOC)\n        \n        // WHEN\n        let verifiedUser = ZMUser.insertNewObject(in: self.uiMOC)\n        verifiedUser.remoteIdentifier = UUID()\n        let verifiedUserConnection = ZMConnection.insertNewSentConnection(to: verifiedUser)!\n        verifiedUserConnection.status = .accepted\n        \n        let verifiedUserClient = UserClient.insertNewObject(in: self.uiMOC)\n        verifiedUserClient.user = verifiedUser\n        selfUser.selfClient()!.trustClient(verifiedUserClient)\n        \n        conversation.addParticipantAndUpdateConversationState(user: verifiedUser, role: nil)\n        \n        // THEN\n        guard let lastMessage1 = conversation.lastMessage as? ZMSystemMessage else {\n            return XCTFail()\n        }\n\n        XCTAssertEqual(lastMessage1.systemMessageType, .conversationIsSecure)\n        \n        // WHEN\n        _ = self.simulateAdding(users: Set([verifiedUser]), conversation: conversation, by: verifiedUser)\n        \n        // THEN\n        guard let lastMessage2 = conversation.lastMessage as? ZMSystemMessage else {\n            return XCTFail()\n        }\n        XCTAssertEqual(lastMessage2.systemMessageType, .participantsAdded)\n\n    }\n    \n    func testThatItDoesNotMoveExistingDegradedMessageWhenRemoteParticpantsAdd_OtherParticipants()\n    {\n        // GIVEN\n        let conversation = self.setupVerifiedConversation()\n        let selfUser = ZMUser.selfUser(in: self.uiMOC)\n\n        // WHEN\n        let unverifiedUsers = self.setupUnverifiedUsers(count: 1)\n        conversation.addParticipantsAndUpdateConversationState(users: unverifiedUsers, role: nil)\n        let otherUnverifiedUsers = self.setupUnverifiedUsers(count: 1)\n        \n        // THEN\n        XCTAssertEqual(conversation.allMessages.count, 4)\n        guard let lastMessage1 = conversation.lastMessage as? ZMSystemMessage else {\n            return XCTFail()\n        }\n        XCTAssertEqual(lastMessage1.systemMessageType, .newClient)\n        XCTAssertEqual(lastMessage1.addedUsers, unverifiedUsers)\n        \n        // WHEN\n        _ = self.simulateAdding(users: otherUnverifiedUsers, conversation: conversation, by: selfUser)\n        \n        // THEN\n        XCTAssertEqual(conversation.allMessages.count, 5)\n        guard let lastMessage2 = conversation.lastMessage as? ZMSystemMessage else {\n            return XCTFail()\n        }\n        XCTAssertEqual(lastMessage2.systemMessageType, .participantsAdded)\n    }\n    \n    func testThatAddingABlockedUserThatAlreadyIsMemberOfTheConversationDoesNotDegradeTheConversation()\n    {\n        // This happens when we are blocking a user in a 1on1: We recieve a conversation update from the backend as a response to blocking the user, which then \"readds\" the user. Since the user is already part of the conversation it should not degrade the conversation.\n        \n        // given\n        let conversation = self.setupVerifiedConversation()\n        let participant = conversation.participantRoles.first!.user\n        XCTAssertEqual(conversation.securityLevel, .secure)\n        participant.block()\n        \n        // when\n        conversation.addParticipantAndUpdateConversationState(user: participant, role: nil)\n        \n        // then\n        XCTAssertEqual(conversation.securityLevel, .secure)\n    }\n\n    func testThatSecurityLevelIsIncreased_WhenAddingSelfUserToAnExistingConversation() {\n        // given\n        let selfUser = ZMUser.selfUser(in: self.uiMOC)\n        self.createSelfClient(onMOC: self.uiMOC)\n        let conversation = ZMConversation.insertNewObject(in: self.uiMOC)\n        conversation.conversationType = .group\n        conversation.remoteIdentifier = UUID()\n\n\n        // when\n        conversation.addParticipantAndUpdateConversationState(user: selfUser, role: nil)\n\n        // then\n        XCTAssertEqual(conversation.securityLevel, .secure)\n    }\n\n}\n", "//\n// Wire\n// Copyright (C) 2019 Wire Swiss GmbH\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see http://www.gnu.org/licenses/.\n//\n\nimport XCTest\nimport WireDataModel\n\nclass ZMUserLegalHoldTests: ModelObjectsTests {\n\n    func testThatLegalHoldStatusIsDisabled_ByDefault() {\n        // GIVEN\n        let selfUser = ZMUser.selfUser(in: uiMOC)\n\n        // THEN\n        XCTAssertEqual(selfUser.legalHoldStatus, .disabled)\n    }\n    \n    func testThatLegalHoldStatusIsDisabled_AfterCancelingRequest() {\n        // GIVEN\n        let selfUser = ZMUser.selfUser(in: uiMOC)\n        let request = LegalHoldRequest.mockRequest(for: selfUser)\n        selfUser.userDidReceiveLegalHoldRequest(request)\n        \n        // WHEN\n        selfUser.legalHoldRequestWasCancelled()\n        \n        // THEN\n        XCTAssertEqual(selfUser.legalHoldStatus, .disabled)\n        XCTAssertFalse(selfUser.needsToAcknowledgeLegalHoldStatus)\n    }\n    \n    func testThatLegalHoldStatusIsDisabled_AfterReceivingRequestTargetingAnotherUser() {\n        // GIVEN\n        let otherUser = createUser(in: uiMOC)\n        let selfUser = ZMUser.selfUser(in: uiMOC)\n        \n        // WHEN\n        let request = LegalHoldRequest.mockRequest(for: otherUser)\n        selfUser.userDidReceiveLegalHoldRequest(request)\n        \n        // THEN\n        XCTAssertEqual(selfUser.legalHoldStatus, .disabled)\n        XCTAssertFalse(selfUser.needsToAcknowledgeLegalHoldStatus)\n    }\n\n    func testThatLegalHoldStatusIsPending_AfterReceivingRequest() {\n        // GIVEN\n        let selfUser = ZMUser.selfUser(in: uiMOC)\n\n        // WHEN\n        let request = LegalHoldRequest.mockRequest(for: selfUser)\n        selfUser.userDidReceiveLegalHoldRequest(request)\n\n        // THEN\n        XCTAssertEqual(selfUser.legalHoldStatus, .pending(request))\n        XCTAssertTrue(selfUser.needsToAcknowledgeLegalHoldStatus)\n    }\n\n    func testThatLegalHoldStatusIsEnabled_AfterAcceptingRequest() {\n        // GIVEN\n        let selfUser = ZMUser.selfUser(in: uiMOC)\n        createSelfClient(onMOC: uiMOC)\n\n        let conversation = createConversation(in: uiMOC)\n        conversation.addParticipantAndUpdateConversationState(user: selfUser, role: nil)\n\n        // WHEN\n        let request = LegalHoldRequest.mockRequest(for: selfUser)\n        selfUser.userDidReceiveLegalHoldRequest(request)\n\n        performPretendingUiMocIsSyncMoc {\n            _ = selfUser.addLegalHoldClient(from: request)\n            selfUser.userDidAcceptLegalHoldRequest(request)\n        }\n\n        // THEN\n        XCTAssertEqual(selfUser.legalHoldStatus, .enabled)\n        XCTAssertTrue(selfUser.needsToAcknowledgeLegalHoldStatus)\n        XCTAssertTrue(conversation.allMessages.contains(where: { ($0 as? ZMSystemMessage)?.systemMessageType == .legalHoldEnabled }))\n        XCTAssertTrue(conversation.isUnderLegalHold)\n    }\n\n    func testThatLegalHoldStatusIsEnabled_AfterAddingClient() {\n        // GIVEN\n        let selfUser = ZMUser.selfUser(in: uiMOC)\n\n        // WHEN\n        UserClient.createMockLegalHoldSelfUserClient(in: uiMOC)\n\n        // THEN\n        XCTAssertEqual(selfUser.legalHoldStatus, .enabled)\n        XCTAssertTrue(selfUser.needsToAcknowledgeLegalHoldStatus)\n    }\n\n    func testThatItDoesntClearNotificationFlag_AfterAddingNormalClient() {\n        // GIVEN\n        let selfUser = ZMUser.selfUser(in: uiMOC)\n\n        // WHEN\n        UserClient.createMockLegalHoldSelfUserClient(in: uiMOC)\n        UserClient.createMockPhoneUserClient(in: uiMOC)\n\n        // THEN\n        XCTAssertEqual(selfUser.legalHoldStatus, .enabled)\n        XCTAssertTrue(selfUser.needsToAcknowledgeLegalHoldStatus)\n    }\n\n    func testThatLegalHoldStatusIsDisabled_AfterRemovingClient() {\n        // GIVEN\n        let selfUser = ZMUser.selfUser(in: uiMOC)\n\n        let legalHoldClient = UserClient.createMockLegalHoldSelfUserClient(in: uiMOC)\n        XCTAssertEqual(selfUser.legalHoldStatus, .enabled)\n\n        selfUser.acknowledgeLegalHoldStatus()\n        XCTAssertFalse(selfUser.needsToAcknowledgeLegalHoldStatus)\n\n        // WHEN\n        performPretendingUiMocIsSyncMoc {\n            legalHoldClient.deleteClientAndEndSession()\n        }\n\n        // THEN\n        XCTAssertEqual(selfUser.legalHoldStatus, .disabled)\n        XCTAssertTrue(selfUser.needsToAcknowledgeLegalHoldStatus)\n    }\n\n    func testThatItDoesntClearNotificationFlag_AfterRemovingNormalClient() {\n        // GIVEN\n        let selfUser = ZMUser.selfUser(in: uiMOC)\n\n        let normalClient = UserClient.createMockPhoneUserClient(in: uiMOC)\n        UserClient.createMockLegalHoldSelfUserClient(in: uiMOC)\n        XCTAssertEqual(selfUser.legalHoldStatus, .enabled)\n\n        // WHEN\n        performPretendingUiMocIsSyncMoc {\n            normalClient.deleteClientAndEndSession()\n        }\n\n        // THEN\n        XCTAssertEqual(selfUser.legalHoldStatus, .enabled)\n        XCTAssertTrue(selfUser.needsToAcknowledgeLegalHoldStatus)\n    }\n\n}\n\n\nextension LegalHoldRequest {\n\n    static func mockRequest(for user: ZMUser) -> LegalHoldRequest {\n        let prekey = LegalHoldRequest.Prekey(id: 65535, key: Data(base64Encoded: \"pQABARn//wKhAFggHsa0CszLXYLFcOzg8AA//E1+Dl1rDHQ5iuk44X0/PNYDoQChAFgg309rkhG6SglemG6kWae81P1HtQPx9lyb6wExTovhU4cE9g==\")!)\n        return LegalHoldRequest(target: user.remoteIdentifier!, requester: UUID(), clientIdentifier: \"eca3c87cfe28be49\", lastPrekey: prekey)\n    }\n\n}\n\nextension UserClient {\n\n    @discardableResult\n    static func createMockLegalHoldSelfUserClient(in moc: NSManagedObjectContext) -> UserClient {\n        let payload: [String: AnyObject] = [\n            \"id\": NSUUID().transportString() as NSString,\n            \"type\": DeviceType.legalHold.rawValue as NSString,\n            \"class\": DeviceClass.legalHold.rawValue as NSString,\n            \"time\": NSDate()\n        ]\n\n        return createOrUpdateSelfUserClient(payload, context: moc)!\n    }\n\n    @discardableResult\n    static func createMockPhoneUserClient(in moc: NSManagedObjectContext) -> UserClient {\n        let payload: [String: AnyObject] = [\n            \"id\": NSUUID().transportString() as NSString,\n            \"type\": DeviceType.permanent.rawValue as NSString,\n            \"class\": DeviceClass.phone.rawValue as NSString,\n            \"time\": NSDate()\n        ]\n\n        return createOrUpdateSelfUserClient(payload, context: moc)!\n    }\n\n}\n"], "filenames": ["Source/Model/Conversation/ZMConversation+Participants.swift", "Source/Model/Conversation/ZMConversation+SecurityLevel.swift", "Tests/Source/Model/Conversation/ZMConversationTests+SecurityLevel.swift", "Tests/Source/Model/User/ZMUserLegalHoldTests.swift"], "buggy_code_start_loc": [176, 209, 980, 93], "buggy_code_end_loc": [221, 214, 1014, 96], "fixing_code_start_loc": [176, 209, 980, 93], "fixing_code_end_loc": [226, 216, 1031, 94], "type": "CWE-345", "message": "wire-ios is the iOS version of Wire, an open-source secure messaging app. wire-ios versions 3.8.0 and earlier have a bug in which a conversation could be incorrectly set to \"unverified. This occurs when: - Self user is added to a new conversation - Self user is added to an existing conversation - All the participants in the conversation were previously marked as verified. The vulnerability is patched in wire-ios version 3.8.1. As a workaround, one can unverify & verify a device in the conversation.", "other": {"cve": {"id": "CVE-2021-32665", "sourceIdentifier": "security-advisories@github.com", "published": "2021-06-03T21:15:07.997", "lastModified": "2021-06-11T19:31:38.000", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "wire-ios is the iOS version of Wire, an open-source secure messaging app. wire-ios versions 3.8.0 and earlier have a bug in which a conversation could be incorrectly set to \"unverified. This occurs when: - Self user is added to a new conversation - Self user is added to an existing conversation - All the participants in the conversation were previously marked as verified. The vulnerability is patched in wire-ios version 3.8.1. As a workaround, one can unverify & verify a device in the conversation."}, {"lang": "es", "value": "wire-ios es la versi\u00f3n para iOS de Wire, una aplicaci\u00f3n de mensajer\u00eda segura de c\u00f3digo abierto. Las versiones 3.8.0 y anteriores de wire-ios tienen un bug en el que una conversaci\u00f3n podr\u00eda ser incorrectamente establecida como \"no verificada\". Esto ocurre cuando: - Se a\u00f1ade un usuario propio a una nueva conversaci\u00f3n - Es a\u00f1adido un usuario propio a una conversaci\u00f3n existente - Todos los participantes en la conversaci\u00f3n estaban previamente marcados como verificados. La vulnerabilidad est\u00e1 parcheada en wire-ios versi\u00f3n 3.8.1. Como soluci\u00f3n, se puede desverificar y verificar un dispositivo en la conversaci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-345"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire:*:*:*:*:*:iphone_os:*:*", "versionEndExcluding": "3.81", "matchCriteriaId": "2DD070A1-55C9-4B0A-85F1-DA8C996520FE"}]}]}], "references": [{"url": "https://github.com/wireapp/wire-ios-data-model/commit/bf9db85886b12a20c8374f55b7c4a610e8ae9220", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/wireapp/wire-ios/security/advisories/GHSA-mc65-7w99-c6qv", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/wireapp/wire-ios-data-model/commit/bf9db85886b12a20c8374f55b7c4a610e8ae9220"}}