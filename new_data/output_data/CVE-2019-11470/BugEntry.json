{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                             CCCC  IIIII  N   N                              %\n%                            C        I    NN  N                              %\n%                            C        I    N N N                              %\n%                            C        I    N  NN                              %\n%                             CCCC  IIIII  N   N                              %\n%                                                                             %\n%                                                                             %\n%                    Read/Write Kodak Cineon Image Format                     %\n%                Cineon Image Format is a subset of SMTPE CIN                 %\n%                                                                             %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                             Kelly Bergougnoux                               %\n%                               October 2003                                  %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Cineon image file format draft is available at\n%  http://www.cineon.com/ff_draft.php.\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/module.h\"\n\f\n/*\n  Typedef declaration.\n*/\ntypedef struct _CINDataFormatInfo\n{\n  unsigned char\n    interleave,\n    packing,\n    sign,\n    sense;\n\n  size_t\n    line_pad,\n    channel_pad;\n\n  unsigned char\n    reserve[20];\n} CINDataFormatInfo;\n\ntypedef struct _CINFileInfo\n{\n  size_t\n    magic,\n    image_offset,\n    generic_length,\n    industry_length,\n    user_length,\n    file_size;\n\n  char\n    version[8],\n    filename[100],\n    create_date[12],\n    create_time[12],\n    reserve[36];\n} CINFileInfo;\n\ntypedef struct _CINFilmInfo\n{\n  char\n    id,\n    type,\n    offset,\n    reserve1;\n\n  size_t\n    prefix,\n    count;\n\n  char\n    format[32];\n\n  size_t\n    frame_position;\n\n  float\n    frame_rate;\n\n  char\n    frame_id[32],\n    slate_info[200],\n    reserve[740];\n} CINFilmInfo;\n\ntypedef struct _CINImageChannel\n{\n  unsigned char\n    designator[2],\n    bits_per_pixel,\n    reserve;\n\n  size_t\n    pixels_per_line,\n    lines_per_image;\n\n  float\n    min_data,\n    min_quantity,\n    max_data,\n    max_quantity;\n} CINImageChannel;\n\ntypedef struct _CINImageInfo\n{\n  unsigned char\n    orientation,\n    number_channels,\n    reserve1[2];\n\n  CINImageChannel\n    channel[8];\n\n  float\n    white_point[2],\n    red_primary_chromaticity[2],\n    green_primary_chromaticity[2],\n    blue_primary_chromaticity[2];\n\n  char\n    label[200],\n    reserve[28];\n} CINImageInfo;\n\ntypedef struct _CINOriginationInfo\n{\n  ssize_t\n    x_offset,\n    y_offset;\n\n  char\n    filename[100],\n    create_date[12],\n    create_time[12],\n    device[64],\n    model[32],\n    serial[32];\n\n  float\n    x_pitch,\n    y_pitch,\n    gamma;\n\n  char\n    reserve[40];\n} CINOriginationInfo;\n\ntypedef struct _CINUserInfo\n{\n  char\n    id[32];\n} CINUserInfo;\n\ntypedef struct CINInfo\n{\n  CINFileInfo\n    file;\n\n  CINImageInfo\n    image;\n\n  CINDataFormatInfo\n    data_format;\n\n  CINOriginationInfo\n    origination;\n\n  CINFilmInfo\n    film;\n\n  CINUserInfo\n    user;\n} CINInfo;\n\f\n/*\n  Forward declaractions.\n*/\nstatic MagickBooleanType\n  WriteCINImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s C I N E O N                                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsCIN() returns MagickTrue if the image format type, identified by the magick\n%  string, is CIN.\n%\n%  The format of the IsCIN method is:\n%\n%      MagickBooleanType IsCIN(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsCIN(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\200\\052\\137\\327\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d C I N E O N I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadCINImage() reads an CIN X image file and returns it.  It allocates\n%  the memory necessary for the new Image structure and returns a point to the\n%  new image.\n%\n%  The format of the ReadCINImage method is:\n%\n%      Image *ReadCINImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic size_t GetBytesPerRow(size_t columns,\n  size_t samples_per_pixel,size_t bits_per_pixel,\n  MagickBooleanType pad)\n{\n  size_t\n    bytes_per_row;\n\n  switch (bits_per_pixel)\n  {\n    case 1:\n    {\n      bytes_per_row=4*(((size_t) samples_per_pixel*columns*\n        bits_per_pixel+31)/32);\n      break;\n    }\n    case 8:\n    default:\n    {\n      bytes_per_row=4*(((size_t) samples_per_pixel*columns*\n        bits_per_pixel+31)/32);\n      break;\n    }\n    case 10:\n    {\n      if (pad == MagickFalse)\n        {\n          bytes_per_row=4*(((size_t) samples_per_pixel*columns*\n            bits_per_pixel+31)/32);\n          break;\n        }\n      bytes_per_row=4*(((size_t) (32*((samples_per_pixel*columns+2)/3))+31)/32);\n      break;\n    }\n    case 12:\n    {\n      if (pad == MagickFalse)\n        {\n          bytes_per_row=4*(((size_t) samples_per_pixel*columns*\n            bits_per_pixel+31)/32);\n          break;\n        }\n      bytes_per_row=2*(((size_t) (16*samples_per_pixel*columns)+15)/16);\n      break;\n    }\n    case 16:\n    {\n      bytes_per_row=2*(((size_t) samples_per_pixel*columns*\n        bits_per_pixel+8)/16);\n      break;\n    }\n    case 32:\n    {\n      bytes_per_row=4*(((size_t) samples_per_pixel*columns*\n        bits_per_pixel+31)/32);\n      break;\n    }\n    case 64:\n    {\n      bytes_per_row=8*(((size_t) samples_per_pixel*columns*\n        bits_per_pixel+63)/64);\n      break;\n    }\n  }\n  return(bytes_per_row);\n}\n\nstatic inline MagickBooleanType IsFloatDefined(const float value)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    double\n      float_value;\n  } quantum;\n\n  quantum.unsigned_value=0U;\n  quantum.float_value=value;\n  if (quantum.unsigned_value == 0U)\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\nstatic Image *ReadCINImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define MonoColorType  1\n#define RGBColorType  3\n\n  char\n    property[MagickPathExtent];\n\n  CINInfo\n    cin;\n\n  const unsigned char\n    *pixels;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  register Quantum\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    magick[4];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    File information.\n  */\n  offset=0;\n  count=ReadBlob(image,4,magick);\n  offset+=count;\n  if ((count != 4) ||\n      ((LocaleNCompare((char *) magick,\"\\200\\052\\137\\327\",4) != 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  memset(&cin,0,sizeof(cin));\n  image->endian=(magick[0] == 0x80) && (magick[1] == 0x2a) &&\n    (magick[2] == 0x5f) && (magick[3] == 0xd7) ? MSBEndian : LSBEndian;\n  cin.file.image_offset=ReadBlobLong(image);\n  offset+=4;\n  cin.file.generic_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.industry_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.user_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.file_size=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(cin.file.version),(unsigned char *)\n    cin.file.version);\n  (void) CopyMagickString(property,cin.file.version,sizeof(cin.file.version));\n  (void) SetImageProperty(image,\"dpx:file.version\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.filename),(unsigned char *)\n    cin.file.filename);\n  (void) CopyMagickString(property,cin.file.filename,sizeof(cin.file.filename));\n  (void) SetImageProperty(image,\"dpx:file.filename\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.create_date),(unsigned char *)\n    cin.file.create_date);\n  (void) CopyMagickString(property,cin.file.create_date,\n    sizeof(cin.file.create_date));\n  (void) SetImageProperty(image,\"dpx:file.create_date\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.create_time),(unsigned char *)\n    cin.file.create_time);\n  (void) CopyMagickString(property,cin.file.create_time,\n    sizeof(cin.file.create_time));\n  (void) SetImageProperty(image,\"dpx:file.create_time\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.reserve),(unsigned char *)\n    cin.file.reserve);\n  /*\n    Image information.\n  */\n  cin.image.orientation=(unsigned char) ReadBlobByte(image);\n  offset++;\n  if (cin.image.orientation != (unsigned char) (~0))\n    (void) FormatImageProperty(image,\"dpx:image.orientation\",\"%d\",\n      cin.image.orientation);\n  switch (cin.image.orientation)\n  {\n    default:\n    case 0: image->orientation=TopLeftOrientation; break;\n    case 1: image->orientation=TopRightOrientation; break;\n    case 2: image->orientation=BottomLeftOrientation; break;\n    case 3: image->orientation=BottomRightOrientation; break;\n    case 4: image->orientation=LeftTopOrientation; break;\n    case 5: image->orientation=RightTopOrientation; break;\n    case 6: image->orientation=LeftBottomOrientation; break;\n    case 7: image->orientation=RightBottomOrientation; break;\n  }\n  cin.image.number_channels=(unsigned char) ReadBlobByte(image);\n  offset++;\n  offset+=ReadBlob(image,sizeof(cin.image.reserve1),(unsigned char *)\n    cin.image.reserve1);\n  for (i=0; i < 8; i++)\n  {\n    cin.image.channel[i].designator[0]=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].designator[1]=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].bits_per_pixel=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].reserve=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].pixels_per_line=ReadBlobLong(image);\n    offset+=4;\n    cin.image.channel[i].lines_per_image=ReadBlobLong(image);\n    offset+=4;\n    cin.image.channel[i].min_data=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].min_quantity=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].max_data=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].max_quantity=ReadBlobFloat(image);\n    offset+=4;\n  }\n  cin.image.white_point[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.white_point[0]) != MagickFalse)\n    image->chromaticity.white_point.x=cin.image.white_point[0];\n  cin.image.white_point[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.white_point[1]) != MagickFalse)\n    image->chromaticity.white_point.y=cin.image.white_point[1];\n  cin.image.red_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.red_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.red_primary.x=cin.image.red_primary_chromaticity[0];\n  cin.image.red_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.red_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.red_primary.y=cin.image.red_primary_chromaticity[1];\n  cin.image.green_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.green_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.red_primary.x=cin.image.green_primary_chromaticity[0];\n  cin.image.green_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.green_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.green_primary.y=cin.image.green_primary_chromaticity[1];\n  cin.image.blue_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.blue_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.blue_primary.x=cin.image.blue_primary_chromaticity[0];\n  cin.image.blue_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.blue_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.blue_primary.y=cin.image.blue_primary_chromaticity[1];\n  offset+=ReadBlob(image,sizeof(cin.image.label),(unsigned char *)\n    cin.image.label);\n  (void) CopyMagickString(property,cin.image.label,sizeof(cin.image.label));\n  (void) SetImageProperty(image,\"dpx:image.label\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.image.reserve),(unsigned char *)\n    cin.image.reserve);\n  /*\n    Image data format information.\n  */\n  cin.data_format.interleave=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.packing=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.sign=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.sense=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.line_pad=ReadBlobLong(image);\n  offset+=4;\n  cin.data_format.channel_pad=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(cin.data_format.reserve),(unsigned char *)\n    cin.data_format.reserve);\n  /*\n    Image origination information.\n  */\n  cin.origination.x_offset=ReadBlobSignedLong(image);\n  offset+=4;\n  if ((size_t) cin.origination.x_offset != ~0UL)\n    (void) FormatImageProperty(image,\"dpx:origination.x_offset\",\"%.20g\",\n      (double) cin.origination.x_offset);\n  cin.origination.y_offset=(ssize_t) ReadBlobLong(image);\n  offset+=4;\n  if ((size_t) cin.origination.y_offset != ~0UL)\n    (void) FormatImageProperty(image,\"dpx:origination.y_offset\",\"%.20g\",\n      (double) cin.origination.y_offset);\n  offset+=ReadBlob(image,sizeof(cin.origination.filename),(unsigned char *)\n    cin.origination.filename);\n  (void) CopyMagickString(property,cin.origination.filename,\n    sizeof(cin.origination.filename));\n  (void) SetImageProperty(image,\"dpx:origination.filename\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.create_date),(unsigned char *)\n    cin.origination.create_date);\n  (void) CopyMagickString(property,cin.origination.create_date,\n    sizeof(cin.origination.create_date));\n  (void) SetImageProperty(image,\"dpx:origination.create_date\",property,\n    exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.create_time),(unsigned char *)\n    cin.origination.create_time);\n  (void) CopyMagickString(property,cin.origination.create_time,\n    sizeof(cin.origination.create_time));\n  (void) SetImageProperty(image,\"dpx:origination.create_time\",property,\n    exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.device),(unsigned char *)\n    cin.origination.device);\n  (void) CopyMagickString(property,cin.origination.device,\n    sizeof(cin.origination.device));\n  (void) SetImageProperty(image,\"dpx:origination.device\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.model),(unsigned char *)\n    cin.origination.model);\n  (void) CopyMagickString(property,cin.origination.model,\n    sizeof(cin.origination.model));\n  (void) SetImageProperty(image,\"dpx:origination.model\",property,exception);\n  (void) memset(cin.origination.serial,0, \n    sizeof(cin.origination.serial));\n  offset+=ReadBlob(image,sizeof(cin.origination.serial),(unsigned char *)\n    cin.origination.serial);\n  (void) CopyMagickString(property,cin.origination.serial,\n    sizeof(cin.origination.serial));\n  (void) SetImageProperty(image,\"dpx:origination.serial\",property,exception);\n  cin.origination.x_pitch=ReadBlobFloat(image);\n  offset+=4;\n  cin.origination.y_pitch=ReadBlobFloat(image);\n  offset+=4;\n  cin.origination.gamma=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.origination.gamma) != MagickFalse)\n    image->gamma=cin.origination.gamma;\n  offset+=ReadBlob(image,sizeof(cin.origination.reserve),(unsigned char *)\n    cin.origination.reserve);\n  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))\n    {\n      int\n        c;\n\n      /*\n        Image film information.\n      */\n      cin.film.id=ReadBlobByte(image);\n      offset++;\n      c=cin.film.id;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.id\",\"%d\",cin.film.id);\n      cin.film.type=ReadBlobByte(image);\n      offset++;\n      c=cin.film.type;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.type\",\"%d\",cin.film.type);\n      cin.film.offset=ReadBlobByte(image);\n      offset++;\n      c=cin.film.offset;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.offset\",\"%d\",\n          cin.film.offset);\n      cin.film.reserve1=ReadBlobByte(image);\n      offset++;\n      cin.film.prefix=ReadBlobLong(image);\n      offset+=4;\n      if (cin.film.prefix != ~0UL)\n        (void) FormatImageProperty(image,\"dpx:film.prefix\",\"%.20g\",(double)\n          cin.film.prefix);\n      cin.film.count=ReadBlobLong(image);\n      offset+=4;\n      offset+=ReadBlob(image,sizeof(cin.film.format),(unsigned char *)\n        cin.film.format);\n      (void) CopyMagickString(property,cin.film.format,sizeof(cin.film.format));\n      (void) SetImageProperty(image,\"dpx:film.format\",property,exception);\n      cin.film.frame_position=ReadBlobLong(image);\n      offset+=4;\n      if (cin.film.frame_position != ~0UL)\n        (void) FormatImageProperty(image,\"dpx:film.frame_position\",\"%.20g\",\n          (double) cin.film.frame_position);\n      cin.film.frame_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(cin.film.frame_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:film.frame_rate\",\"%g\",\n          cin.film.frame_rate);\n      offset+=ReadBlob(image,sizeof(cin.film.frame_id),(unsigned char *)\n        cin.film.frame_id);\n      (void) CopyMagickString(property,cin.film.frame_id,\n        sizeof(cin.film.frame_id));\n      (void) SetImageProperty(image,\"dpx:film.frame_id\",property,exception);\n      offset+=ReadBlob(image,sizeof(cin.film.slate_info),(unsigned char *)\n        cin.film.slate_info);\n      (void) CopyMagickString(property,cin.film.slate_info,\n        sizeof(cin.film.slate_info));\n      (void) SetImageProperty(image,\"dpx:film.slate_info\",property,exception);\n      offset+=ReadBlob(image,sizeof(cin.film.reserve),(unsigned char *)\n        cin.film.reserve);\n    }\n  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))\n    {\n      StringInfo\n        *profile;\n\n      /*\n        User defined data.\n      */\n      if (cin.file.user_length > GetBlobSize(image))\n        ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n      profile=BlobToStringInfo((const unsigned char *) NULL,\n        cin.file.user_length);\n      if (profile == (StringInfo *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      offset+=ReadBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n      (void) SetImageProfile(image,\"dpx:user.data\",profile,exception);\n      profile=DestroyStringInfo(profile);\n    }\n  image->depth=cin.image.channel[0].bits_per_pixel;\n  image->columns=cin.image.channel[0].pixels_per_line;\n  image->rows=cin.image.channel[0].lines_per_image;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(image);\n    }\n  for ( ; offset < (MagickOffsetType) cin.file.image_offset; offset++)\n  {\n    int\n      c;\n\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      break;\n  }\n  if (offset < (MagickOffsetType) cin.file.image_offset)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  (void) SetImageBackgroundColor(image,exception);\n  /*\n    Convert CIN raster image to pixel packets.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  quantum_info->quantum=32;\n  quantum_info->pack=MagickFalse;\n  quantum_type=RGBQuantum;\n  length=GetQuantumExtent(image,quantum_info,quantum_type);\n  length=GetBytesPerRow(image->columns,3,image->depth,MagickTrue);\n  if (cin.image.number_channels == 1)\n    {\n      quantum_type=GrayQuantum;\n      length=GetBytesPerRow(image->columns,1,image->depth,MagickTrue);\n    }\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    pixels=(const unsigned char *) ReadBlobStream(image,length,\n      GetQuantumPixels(quantum_info),&count);\n    if ((size_t) count != length)\n      break;\n    (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n      quantum_type,pixels,exception);\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  SetQuantumImageType(image,quantum_type);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  SetImageColorspace(image,LogColorspace,exception);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r C I N E O N I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterCINImage() adds attributes for the CIN image format to the list of\n%  of supported formats.  The attributes include the image format tag, a method\n%  to read and/or write the format, whether the format supports the saving of\n%  more than one frame to the same file or blob, whether the format supports\n%  native in-memory I/O, and a brief description of the format.\n%\n%  The format of the RegisterCINImage method is:\n%\n%      size_t RegisterCINImage(void)\n%\n*/\nModuleExport size_t RegisterCINImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"CIN\",\"CIN\",\"Cineon Image File\");\n  entry->decoder=(DecodeImageHandler *) ReadCINImage;\n  entry->encoder=(EncodeImageHandler *) WriteCINImage;\n  entry->magick=(IsImageFormatHandler *) IsCIN;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r C I N E O N I m a g e                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterCINImage() removes format registrations made by the CIN module\n%  from the list of supported formats.\n%\n%  The format of the UnregisterCINImage method is:\n%\n%      UnregisterCINImage(void)\n%\n*/\nModuleExport void UnregisterCINImage(void)\n{\n  (void) UnregisterMagickInfo(\"CINEON\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e C I N E O N I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteCINImage() writes an image in CIN encoded image format.\n%\n%  The format of the WriteCINImage method is:\n%\n%      MagickBooleanType WriteCINImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline const char *GetCINProperty(const ImageInfo *image_info,\n  const Image *image,const char *property,ExceptionInfo *exception)\n{\n  const char\n    *value;\n\n  value=GetImageOption(image_info,property);\n  if (value != (const char *) NULL)\n    return(value);\n  return(GetImageProperty(image,property,exception));\n}\n\nstatic MagickBooleanType WriteCINImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    timestamp[MagickPathExtent];\n\n  const char\n    *value;\n\n  CINInfo\n    cin;\n\n  const StringInfo\n    *profile;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  struct tm\n    local_time;\n\n  time_t\n    seconds;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if (image->colorspace != LogColorspace)\n    (void) TransformImageColorspace(image,LogColorspace,exception);\n  /*\n    Write image information.\n  */\n  (void) memset(&cin,0,sizeof(cin));\n  offset=0;\n  cin.file.magic=0x802A5FD7UL;\n  offset+=WriteBlobLong(image,(unsigned int) cin.file.magic);\n  cin.file.image_offset=0x800;\n  offset+=WriteBlobLong(image,(unsigned int) cin.file.image_offset);\n  cin.file.generic_length=0x400;\n  offset+=WriteBlobLong(image,(unsigned int) cin.file.generic_length);\n  cin.file.industry_length=0x400;\n  offset+=WriteBlobLong(image,(unsigned int) cin.file.industry_length);\n  cin.file.user_length=0x00;\n  profile=GetImageProfile(image,\"dpx:user.data\");\n  if (profile != (StringInfo *) NULL)\n    {\n      cin.file.user_length+=(size_t) GetStringInfoLength(profile);\n      cin.file.user_length=(((cin.file.user_length+0x2000-1)/0x2000)*0x2000);\n    }\n  offset+=WriteBlobLong(image,(unsigned int) cin.file.user_length);\n  cin.file.file_size=4*image->columns*image->rows+0x2000;\n  offset+=WriteBlobLong(image,(unsigned int) cin.file.file_size);\n  (void) CopyMagickString(cin.file.version,\"V4.5\",sizeof(cin.file.version));\n  offset+=WriteBlob(image,sizeof(cin.file.version),(unsigned char *)\n    cin.file.version);\n  value=GetCINProperty(image_info,image,\"dpx:file.filename\",exception);\n  if (value != (const char *) NULL)\n    (void) CopyMagickString(cin.file.filename,value,sizeof(cin.file.filename));\n  else\n    (void) CopyMagickString(cin.file.filename,image->filename,\n      sizeof(cin.file.filename));\n  offset+=WriteBlob(image,sizeof(cin.file.filename),(unsigned char *)\n    cin.file.filename);\n  seconds=time((time_t *) NULL);\n#if defined(MAGICKCORE_HAVE_LOCALTIME_R)\n  (void) localtime_r(&seconds,&local_time);\n#else\n  (void) memcpy(&local_time,localtime(&seconds),sizeof(local_time));\n#endif\n  (void) memset(timestamp,0,sizeof(timestamp));\n  (void) strftime(timestamp,MagickPathExtent,\"%Y:%m:%d:%H:%M:%S%Z\",&local_time);\n  (void) memset(cin.file.create_date,0,sizeof(cin.file.create_date));\n  (void) CopyMagickString(cin.file.create_date,timestamp,11);\n  offset+=WriteBlob(image,sizeof(cin.file.create_date),(unsigned char *)\n    cin.file.create_date);\n  (void) memset(cin.file.create_time,0,sizeof(cin.file.create_time));\n  (void) CopyMagickString(cin.file.create_time,timestamp+11,11);\n  offset+=WriteBlob(image,sizeof(cin.file.create_time),(unsigned char *)\n    cin.file.create_time);\n  offset+=WriteBlob(image,sizeof(cin.file.reserve),(unsigned char *)\n    cin.file.reserve);\n  cin.image.orientation=0x00;\n  offset+=WriteBlobByte(image,cin.image.orientation);\n  cin.image.number_channels=3;\n  offset+=WriteBlobByte(image,cin.image.number_channels);\n  offset+=WriteBlob(image,sizeof(cin.image.reserve1),(unsigned char *)\n    cin.image.reserve1);\n  for (i=0; i < 8; i++)\n  {\n    cin.image.channel[i].designator[0]=0; /* universal metric */\n    offset+=WriteBlobByte(image,cin.image.channel[0].designator[0]);\n    cin.image.channel[i].designator[1]=(unsigned char) (i > 3 ? 0 : i+1); /* channel color */;\n    offset+=WriteBlobByte(image,cin.image.channel[1].designator[0]);\n    cin.image.channel[i].bits_per_pixel=(unsigned char) image->depth;\n    offset+=WriteBlobByte(image,cin.image.channel[0].bits_per_pixel);\n    offset+=WriteBlobByte(image,cin.image.channel[0].reserve);\n    cin.image.channel[i].pixels_per_line=image->columns;\n    offset+=WriteBlobLong(image,(unsigned int)\n      cin.image.channel[0].pixels_per_line);\n    cin.image.channel[i].lines_per_image=image->rows;\n    offset+=WriteBlobLong(image,(unsigned int)\n      cin.image.channel[0].lines_per_image);\n    cin.image.channel[i].min_data=0;\n    offset+=WriteBlobFloat(image,cin.image.channel[0].min_data);\n    cin.image.channel[i].min_quantity=0.0;\n    offset+=WriteBlobFloat(image,cin.image.channel[0].min_quantity);\n    cin.image.channel[i].max_data=(float) ((MagickOffsetType)\n      GetQuantumRange(image->depth));\n    offset+=WriteBlobFloat(image,cin.image.channel[0].max_data);\n    cin.image.channel[i].max_quantity=2.048f;\n    offset+=WriteBlobFloat(image,cin.image.channel[0].max_quantity);\n  }\n  offset+=WriteBlobFloat(image,image->chromaticity.white_point.x);\n  offset+=WriteBlobFloat(image,image->chromaticity.white_point.y);\n  offset+=WriteBlobFloat(image,image->chromaticity.red_primary.x);\n  offset+=WriteBlobFloat(image,image->chromaticity.red_primary.y);\n  offset+=WriteBlobFloat(image,image->chromaticity.green_primary.x);\n  offset+=WriteBlobFloat(image,image->chromaticity.green_primary.y);\n  offset+=WriteBlobFloat(image,image->chromaticity.blue_primary.x);\n  offset+=WriteBlobFloat(image,image->chromaticity.blue_primary.y);\n  value=GetCINProperty(image_info,image,\"dpx:image.label\",exception);\n  if (value != (const char *) NULL)\n    (void) CopyMagickString(cin.image.label,value,sizeof(cin.image.label));\n  offset+=WriteBlob(image,sizeof(cin.image.label),(unsigned char *)\n    cin.image.label);\n  offset+=WriteBlob(image,sizeof(cin.image.reserve),(unsigned char *)\n    cin.image.reserve);\n  /*\n    Write data format information.\n  */\n  cin.data_format.interleave=0; /* pixel interleave (rgbrgbr...) */\n  offset+=WriteBlobByte(image,cin.data_format.interleave);\n  cin.data_format.packing=5; /* packing ssize_tword (32bit) boundaries */\n  offset+=WriteBlobByte(image,cin.data_format.packing);\n  cin.data_format.sign=0; /* unsigned data */\n  offset+=WriteBlobByte(image,cin.data_format.sign);\n  cin.data_format.sense=0; /* image sense: positive image */\n  offset+=WriteBlobByte(image,cin.data_format.sense);\n  cin.data_format.line_pad=0;\n  offset+=WriteBlobLong(image,(unsigned int) cin.data_format.line_pad);\n  cin.data_format.channel_pad=0;\n  offset+=WriteBlobLong(image,(unsigned int) cin.data_format.channel_pad);\n  offset+=WriteBlob(image,sizeof(cin.data_format.reserve),(unsigned char *)\n    cin.data_format.reserve);\n  /*\n    Write origination information.\n  */\n  cin.origination.x_offset=0UL;\n  value=GetCINProperty(image_info,image,\"dpx:origination.x_offset\",exception);\n  if (value != (const char *) NULL)\n    cin.origination.x_offset=(ssize_t) StringToLong(value);\n  offset+=WriteBlobLong(image,(unsigned int) cin.origination.x_offset);\n  cin.origination.y_offset=0UL;\n  value=GetCINProperty(image_info,image,\"dpx:origination.y_offset\",exception);\n  if (value != (const char *) NULL)\n    cin.origination.y_offset=(ssize_t) StringToLong(value);\n  offset+=WriteBlobLong(image,(unsigned int) cin.origination.y_offset);\n  value=GetCINProperty(image_info,image,\"dpx:origination.filename\",exception);\n  if (value != (const char *) NULL)\n    (void) CopyMagickString(cin.origination.filename,value,\n      sizeof(cin.origination.filename));\n  else\n    (void) CopyMagickString(cin.origination.filename,image->filename,\n      sizeof(cin.origination.filename));\n  offset+=WriteBlob(image,sizeof(cin.origination.filename),(unsigned char *)\n    cin.origination.filename);\n  seconds=time((time_t *) NULL);\n  (void) memset(timestamp,0,sizeof(timestamp));\n  (void) strftime(timestamp,MagickPathExtent,\"%Y:%m:%d:%H:%M:%S%Z\",&local_time);\n  (void) memset(cin.origination.create_date,0,\n    sizeof(cin.origination.create_date));\n  (void) CopyMagickString(cin.origination.create_date,timestamp,11);\n  offset+=WriteBlob(image,sizeof(cin.origination.create_date),(unsigned char *)\n    cin.origination.create_date);\n  (void) memset(cin.origination.create_time,0,\n     sizeof(cin.origination.create_time));\n  (void) CopyMagickString(cin.origination.create_time,timestamp+11,15);\n  offset+=WriteBlob(image,sizeof(cin.origination.create_time),(unsigned char *)\n    cin.origination.create_time);\n  value=GetCINProperty(image_info,image,\"dpx:origination.device\",exception);\n  if (value != (const char *) NULL)\n    (void) CopyMagickString(cin.origination.device,value,\n      sizeof(cin.origination.device));\n  offset+=WriteBlob(image,sizeof(cin.origination.device),(unsigned char *)\n    cin.origination.device);\n  value=GetCINProperty(image_info,image,\"dpx:origination.model\",exception);\n  if (value != (const char *) NULL)\n    (void) CopyMagickString(cin.origination.model,value,\n      sizeof(cin.origination.model));\n  offset+=WriteBlob(image,sizeof(cin.origination.model),(unsigned char *)\n    cin.origination.model);\n  value=GetCINProperty(image_info,image,\"dpx:origination.serial\",exception);\n  if (value != (const char *) NULL)\n    (void) CopyMagickString(cin.origination.serial,value,\n      sizeof(cin.origination.serial));\n  offset+=WriteBlob(image,sizeof(cin.origination.serial),(unsigned char *)\n    cin.origination.serial);\n  cin.origination.x_pitch=0.0f;\n  value=GetCINProperty(image_info,image,\"dpx:origination.x_pitch\",exception);\n  if (value != (const char *) NULL)\n    cin.origination.x_pitch=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,cin.origination.x_pitch);\n  cin.origination.y_pitch=0.0f;\n  value=GetCINProperty(image_info,image,\"dpx:origination.y_pitch\",exception);\n  if (value != (const char *) NULL)\n    cin.origination.y_pitch=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,cin.origination.y_pitch);\n  cin.origination.gamma=image->gamma;\n  offset+=WriteBlobFloat(image,cin.origination.gamma);\n  offset+=WriteBlob(image,sizeof(cin.origination.reserve),(unsigned char *)\n    cin.origination.reserve);\n  /*\n    Image film information.\n  */\n  cin.film.id=0;\n  value=GetCINProperty(image_info,image,\"dpx:film.id\",exception);\n  if (value != (const char *) NULL)\n    cin.film.id=(char) StringToLong(value);\n  offset+=WriteBlobByte(image,(unsigned char) cin.film.id);\n  cin.film.type=0;\n  value=GetCINProperty(image_info,image,\"dpx:film.type\",exception);\n  if (value != (const char *) NULL)\n    cin.film.type=(char) StringToLong(value);\n  offset+=WriteBlobByte(image,(unsigned char) cin.film.type);\n  cin.film.offset=0;\n  value=GetCINProperty(image_info,image,\"dpx:film.offset\",exception);\n  if (value != (const char *) NULL)\n    cin.film.offset=(char) StringToLong(value);\n  offset+=WriteBlobByte(image,(unsigned char) cin.film.offset);\n  offset+=WriteBlobByte(image,(unsigned char) cin.film.reserve1);\n  cin.film.prefix=0UL;\n  value=GetCINProperty(image_info,image,\"dpx:film.prefix\",exception);\n  if (value != (const char *) NULL)\n    cin.film.prefix=StringToUnsignedLong(value);\n  offset+=WriteBlobLong(image,(unsigned int) cin.film.prefix);\n  cin.film.count=0UL;\n  value=GetCINProperty(image_info,image,\"dpx:film.count\",exception);\n  if (value != (const char *) NULL)\n    cin.film.count=StringToUnsignedLong(value);\n  offset+=WriteBlobLong(image,(unsigned int) cin.film.count);\n  value=GetCINProperty(image_info,image,\"dpx:film.format\",exception);\n  if (value != (const char *) NULL)\n    (void) CopyMagickString(cin.film.format,value,sizeof(cin.film.format));\n  offset+=WriteBlob(image,sizeof(cin.film.format),(unsigned char *)\n    cin.film.format);\n  cin.film.frame_position=0UL;\n  value=GetCINProperty(image_info,image,\"dpx:film.frame_position\",exception);\n  if (value != (const char *) NULL)\n    cin.film.frame_position=StringToUnsignedLong(value);\n  offset+=WriteBlobLong(image,(unsigned int) cin.film.frame_position);\n  cin.film.frame_rate=0.0f;\n  value=GetCINProperty(image_info,image,\"dpx:film.frame_rate\",exception);\n  if (value != (const char *) NULL)\n    cin.film.frame_rate=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,cin.film.frame_rate);\n  value=GetCINProperty(image_info,image,\"dpx:film.frame_id\",exception);\n  if (value != (const char *) NULL)\n    (void) CopyMagickString(cin.film.frame_id,value,sizeof(cin.film.frame_id));\n  offset+=WriteBlob(image,sizeof(cin.film.frame_id),(unsigned char *)\n    cin.film.frame_id);\n  value=GetCINProperty(image_info,image,\"dpx:film.slate_info\",exception);\n  if (value != (const char *) NULL)\n    (void) CopyMagickString(cin.film.slate_info,value,\n      sizeof(cin.film.slate_info));\n  offset+=WriteBlob(image,sizeof(cin.film.slate_info),(unsigned char *)\n    cin.film.slate_info);\n  offset+=WriteBlob(image,sizeof(cin.film.reserve),(unsigned char *)\n    cin.film.reserve);\n  if (profile != (StringInfo *) NULL)\n    offset+=WriteBlob(image,GetStringInfoLength(profile),\n      GetStringInfoDatum(profile));\n  while (offset < (MagickOffsetType) cin.file.image_offset)\n    offset+=WriteBlobByte(image,0x00);\n  /*\n    Convert pixel packets to CIN raster image.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  quantum_info->quantum=32;\n  quantum_info->pack=MagickFalse;\n  quantum_type=RGBQuantum;\n  pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n  length=GetBytesPerRow(image->columns,3,image->depth,MagickTrue);\nDisableMSCWarning(4127)\n  if (0)\nRestoreMSCWarning\n    {\n      quantum_type=GrayQuantum;\n      length=GetBytesPerRow(image->columns,1,image->depth,MagickTrue);\n    }\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    (void) ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n      quantum_type,pixels,exception);\n    count=WriteBlob(image,length,pixels);\n    if (count != (ssize_t) length)\n      break;\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  (void) CloseBlob(image);\n  return(status);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                             CCCC  IIIII  N   N                              %\n%                            C        I    NN  N                              %\n%                            C        I    N N N                              %\n%                            C        I    N  NN                              %\n%                             CCCC  IIIII  N   N                              %\n%                                                                             %\n%                                                                             %\n%                    Read/Write Kodak Cineon Image Format                     %\n%                Cineon Image Format is a subset of SMTPE CIN                 %\n%                                                                             %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                             Kelly Bergougnoux                               %\n%                               October 2003                                  %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Cineon image file format draft is available at\n%  http://www.cineon.com/ff_draft.php.\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/module.h\"\n\f\n/*\n  Typedef declaration.\n*/\ntypedef struct _CINDataFormatInfo\n{\n  unsigned char\n    interleave,\n    packing,\n    sign,\n    sense;\n\n  size_t\n    line_pad,\n    channel_pad;\n\n  unsigned char\n    reserve[20];\n} CINDataFormatInfo;\n\ntypedef struct _CINFileInfo\n{\n  size_t\n    magic,\n    image_offset,\n    generic_length,\n    industry_length,\n    user_length,\n    file_size;\n\n  char\n    version[8],\n    filename[100],\n    create_date[12],\n    create_time[12],\n    reserve[36];\n} CINFileInfo;\n\ntypedef struct _CINFilmInfo\n{\n  char\n    id,\n    type,\n    offset,\n    reserve1;\n\n  size_t\n    prefix,\n    count;\n\n  char\n    format[32];\n\n  size_t\n    frame_position;\n\n  float\n    frame_rate;\n\n  char\n    frame_id[32],\n    slate_info[200],\n    reserve[740];\n} CINFilmInfo;\n\ntypedef struct _CINImageChannel\n{\n  unsigned char\n    designator[2],\n    bits_per_pixel,\n    reserve;\n\n  size_t\n    pixels_per_line,\n    lines_per_image;\n\n  float\n    min_data,\n    min_quantity,\n    max_data,\n    max_quantity;\n} CINImageChannel;\n\ntypedef struct _CINImageInfo\n{\n  unsigned char\n    orientation,\n    number_channels,\n    reserve1[2];\n\n  CINImageChannel\n    channel[8];\n\n  float\n    white_point[2],\n    red_primary_chromaticity[2],\n    green_primary_chromaticity[2],\n    blue_primary_chromaticity[2];\n\n  char\n    label[200],\n    reserve[28];\n} CINImageInfo;\n\ntypedef struct _CINOriginationInfo\n{\n  ssize_t\n    x_offset,\n    y_offset;\n\n  char\n    filename[100],\n    create_date[12],\n    create_time[12],\n    device[64],\n    model[32],\n    serial[32];\n\n  float\n    x_pitch,\n    y_pitch,\n    gamma;\n\n  char\n    reserve[40];\n} CINOriginationInfo;\n\ntypedef struct _CINUserInfo\n{\n  char\n    id[32];\n} CINUserInfo;\n\ntypedef struct CINInfo\n{\n  CINFileInfo\n    file;\n\n  CINImageInfo\n    image;\n\n  CINDataFormatInfo\n    data_format;\n\n  CINOriginationInfo\n    origination;\n\n  CINFilmInfo\n    film;\n\n  CINUserInfo\n    user;\n} CINInfo;\n\f\n/*\n  Forward declaractions.\n*/\nstatic MagickBooleanType\n  WriteCINImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s C I N E O N                                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsCIN() returns MagickTrue if the image format type, identified by the magick\n%  string, is CIN.\n%\n%  The format of the IsCIN method is:\n%\n%      MagickBooleanType IsCIN(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsCIN(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\200\\052\\137\\327\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d C I N E O N I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadCINImage() reads an CIN X image file and returns it.  It allocates\n%  the memory necessary for the new Image structure and returns a point to the\n%  new image.\n%\n%  The format of the ReadCINImage method is:\n%\n%      Image *ReadCINImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic size_t GetBytesPerRow(size_t columns,\n  size_t samples_per_pixel,size_t bits_per_pixel,\n  MagickBooleanType pad)\n{\n  size_t\n    bytes_per_row;\n\n  switch (bits_per_pixel)\n  {\n    case 1:\n    {\n      bytes_per_row=4*(((size_t) samples_per_pixel*columns*\n        bits_per_pixel+31)/32);\n      break;\n    }\n    case 8:\n    default:\n    {\n      bytes_per_row=4*(((size_t) samples_per_pixel*columns*\n        bits_per_pixel+31)/32);\n      break;\n    }\n    case 10:\n    {\n      if (pad == MagickFalse)\n        {\n          bytes_per_row=4*(((size_t) samples_per_pixel*columns*\n            bits_per_pixel+31)/32);\n          break;\n        }\n      bytes_per_row=4*(((size_t) (32*((samples_per_pixel*columns+2)/3))+31)/32);\n      break;\n    }\n    case 12:\n    {\n      if (pad == MagickFalse)\n        {\n          bytes_per_row=4*(((size_t) samples_per_pixel*columns*\n            bits_per_pixel+31)/32);\n          break;\n        }\n      bytes_per_row=2*(((size_t) (16*samples_per_pixel*columns)+15)/16);\n      break;\n    }\n    case 16:\n    {\n      bytes_per_row=2*(((size_t) samples_per_pixel*columns*\n        bits_per_pixel+8)/16);\n      break;\n    }\n    case 32:\n    {\n      bytes_per_row=4*(((size_t) samples_per_pixel*columns*\n        bits_per_pixel+31)/32);\n      break;\n    }\n    case 64:\n    {\n      bytes_per_row=8*(((size_t) samples_per_pixel*columns*\n        bits_per_pixel+63)/64);\n      break;\n    }\n  }\n  return(bytes_per_row);\n}\n\nstatic inline MagickBooleanType IsFloatDefined(const float value)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    double\n      float_value;\n  } quantum;\n\n  quantum.unsigned_value=0U;\n  quantum.float_value=value;\n  if (quantum.unsigned_value == 0U)\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\nstatic Image *ReadCINImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define MonoColorType  1\n#define RGBColorType  3\n\n  char\n    property[MagickPathExtent];\n\n  CINInfo\n    cin;\n\n  const unsigned char\n    *pixels;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  register Quantum\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    magick[4];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    File information.\n  */\n  offset=0;\n  count=ReadBlob(image,4,magick);\n  offset+=count;\n  if ((count != 4) ||\n      ((LocaleNCompare((char *) magick,\"\\200\\052\\137\\327\",4) != 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  memset(&cin,0,sizeof(cin));\n  image->endian=(magick[0] == 0x80) && (magick[1] == 0x2a) &&\n    (magick[2] == 0x5f) && (magick[3] == 0xd7) ? MSBEndian : LSBEndian;\n  cin.file.image_offset=ReadBlobLong(image);\n  offset+=4;\n  cin.file.generic_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.industry_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.user_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.file_size=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(cin.file.version),(unsigned char *)\n    cin.file.version);\n  (void) CopyMagickString(property,cin.file.version,sizeof(cin.file.version));\n  (void) SetImageProperty(image,\"dpx:file.version\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.filename),(unsigned char *)\n    cin.file.filename);\n  (void) CopyMagickString(property,cin.file.filename,sizeof(cin.file.filename));\n  (void) SetImageProperty(image,\"dpx:file.filename\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.create_date),(unsigned char *)\n    cin.file.create_date);\n  (void) CopyMagickString(property,cin.file.create_date,\n    sizeof(cin.file.create_date));\n  (void) SetImageProperty(image,\"dpx:file.create_date\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.create_time),(unsigned char *)\n    cin.file.create_time);\n  (void) CopyMagickString(property,cin.file.create_time,\n    sizeof(cin.file.create_time));\n  (void) SetImageProperty(image,\"dpx:file.create_time\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.reserve),(unsigned char *)\n    cin.file.reserve);\n  /*\n    Image information.\n  */\n  cin.image.orientation=(unsigned char) ReadBlobByte(image);\n  offset++;\n  if (cin.image.orientation != (unsigned char) (~0))\n    (void) FormatImageProperty(image,\"dpx:image.orientation\",\"%d\",\n      cin.image.orientation);\n  switch (cin.image.orientation)\n  {\n    default:\n    case 0: image->orientation=TopLeftOrientation; break;\n    case 1: image->orientation=TopRightOrientation; break;\n    case 2: image->orientation=BottomLeftOrientation; break;\n    case 3: image->orientation=BottomRightOrientation; break;\n    case 4: image->orientation=LeftTopOrientation; break;\n    case 5: image->orientation=RightTopOrientation; break;\n    case 6: image->orientation=LeftBottomOrientation; break;\n    case 7: image->orientation=RightBottomOrientation; break;\n  }\n  cin.image.number_channels=(unsigned char) ReadBlobByte(image);\n  offset++;\n  offset+=ReadBlob(image,sizeof(cin.image.reserve1),(unsigned char *)\n    cin.image.reserve1);\n  for (i=0; i < 8; i++)\n  {\n    cin.image.channel[i].designator[0]=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].designator[1]=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].bits_per_pixel=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].reserve=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].pixels_per_line=ReadBlobLong(image);\n    offset+=4;\n    cin.image.channel[i].lines_per_image=ReadBlobLong(image);\n    offset+=4;\n    cin.image.channel[i].min_data=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].min_quantity=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].max_data=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].max_quantity=ReadBlobFloat(image);\n    offset+=4;\n  }\n  cin.image.white_point[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.white_point[0]) != MagickFalse)\n    image->chromaticity.white_point.x=cin.image.white_point[0];\n  cin.image.white_point[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.white_point[1]) != MagickFalse)\n    image->chromaticity.white_point.y=cin.image.white_point[1];\n  cin.image.red_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.red_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.red_primary.x=cin.image.red_primary_chromaticity[0];\n  cin.image.red_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.red_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.red_primary.y=cin.image.red_primary_chromaticity[1];\n  cin.image.green_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.green_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.red_primary.x=cin.image.green_primary_chromaticity[0];\n  cin.image.green_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.green_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.green_primary.y=cin.image.green_primary_chromaticity[1];\n  cin.image.blue_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.blue_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.blue_primary.x=cin.image.blue_primary_chromaticity[0];\n  cin.image.blue_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.blue_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.blue_primary.y=cin.image.blue_primary_chromaticity[1];\n  offset+=ReadBlob(image,sizeof(cin.image.label),(unsigned char *)\n    cin.image.label);\n  (void) CopyMagickString(property,cin.image.label,sizeof(cin.image.label));\n  (void) SetImageProperty(image,\"dpx:image.label\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.image.reserve),(unsigned char *)\n    cin.image.reserve);\n  /*\n    Image data format information.\n  */\n  cin.data_format.interleave=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.packing=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.sign=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.sense=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.line_pad=ReadBlobLong(image);\n  offset+=4;\n  cin.data_format.channel_pad=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(cin.data_format.reserve),(unsigned char *)\n    cin.data_format.reserve);\n  /*\n    Image origination information.\n  */\n  cin.origination.x_offset=ReadBlobSignedLong(image);\n  offset+=4;\n  if ((size_t) cin.origination.x_offset != ~0UL)\n    (void) FormatImageProperty(image,\"dpx:origination.x_offset\",\"%.20g\",\n      (double) cin.origination.x_offset);\n  cin.origination.y_offset=(ssize_t) ReadBlobLong(image);\n  offset+=4;\n  if ((size_t) cin.origination.y_offset != ~0UL)\n    (void) FormatImageProperty(image,\"dpx:origination.y_offset\",\"%.20g\",\n      (double) cin.origination.y_offset);\n  offset+=ReadBlob(image,sizeof(cin.origination.filename),(unsigned char *)\n    cin.origination.filename);\n  (void) CopyMagickString(property,cin.origination.filename,\n    sizeof(cin.origination.filename));\n  (void) SetImageProperty(image,\"dpx:origination.filename\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.create_date),(unsigned char *)\n    cin.origination.create_date);\n  (void) CopyMagickString(property,cin.origination.create_date,\n    sizeof(cin.origination.create_date));\n  (void) SetImageProperty(image,\"dpx:origination.create_date\",property,\n    exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.create_time),(unsigned char *)\n    cin.origination.create_time);\n  (void) CopyMagickString(property,cin.origination.create_time,\n    sizeof(cin.origination.create_time));\n  (void) SetImageProperty(image,\"dpx:origination.create_time\",property,\n    exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.device),(unsigned char *)\n    cin.origination.device);\n  (void) CopyMagickString(property,cin.origination.device,\n    sizeof(cin.origination.device));\n  (void) SetImageProperty(image,\"dpx:origination.device\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.model),(unsigned char *)\n    cin.origination.model);\n  (void) CopyMagickString(property,cin.origination.model,\n    sizeof(cin.origination.model));\n  (void) SetImageProperty(image,\"dpx:origination.model\",property,exception);\n  (void) memset(cin.origination.serial,0, \n    sizeof(cin.origination.serial));\n  offset+=ReadBlob(image,sizeof(cin.origination.serial),(unsigned char *)\n    cin.origination.serial);\n  (void) CopyMagickString(property,cin.origination.serial,\n    sizeof(cin.origination.serial));\n  (void) SetImageProperty(image,\"dpx:origination.serial\",property,exception);\n  cin.origination.x_pitch=ReadBlobFloat(image);\n  offset+=4;\n  cin.origination.y_pitch=ReadBlobFloat(image);\n  offset+=4;\n  cin.origination.gamma=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.origination.gamma) != MagickFalse)\n    image->gamma=cin.origination.gamma;\n  offset+=ReadBlob(image,sizeof(cin.origination.reserve),(unsigned char *)\n    cin.origination.reserve);\n  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))\n    {\n      int\n        c;\n\n      /*\n        Image film information.\n      */\n      cin.film.id=ReadBlobByte(image);\n      offset++;\n      c=cin.film.id;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.id\",\"%d\",cin.film.id);\n      cin.film.type=ReadBlobByte(image);\n      offset++;\n      c=cin.film.type;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.type\",\"%d\",cin.film.type);\n      cin.film.offset=ReadBlobByte(image);\n      offset++;\n      c=cin.film.offset;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.offset\",\"%d\",\n          cin.film.offset);\n      cin.film.reserve1=ReadBlobByte(image);\n      offset++;\n      cin.film.prefix=ReadBlobLong(image);\n      offset+=4;\n      if (cin.film.prefix != ~0UL)\n        (void) FormatImageProperty(image,\"dpx:film.prefix\",\"%.20g\",(double)\n          cin.film.prefix);\n      cin.film.count=ReadBlobLong(image);\n      offset+=4;\n      offset+=ReadBlob(image,sizeof(cin.film.format),(unsigned char *)\n        cin.film.format);\n      (void) CopyMagickString(property,cin.film.format,sizeof(cin.film.format));\n      (void) SetImageProperty(image,\"dpx:film.format\",property,exception);\n      cin.film.frame_position=ReadBlobLong(image);\n      offset+=4;\n      if (cin.film.frame_position != ~0UL)\n        (void) FormatImageProperty(image,\"dpx:film.frame_position\",\"%.20g\",\n          (double) cin.film.frame_position);\n      cin.film.frame_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(cin.film.frame_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:film.frame_rate\",\"%g\",\n          cin.film.frame_rate);\n      offset+=ReadBlob(image,sizeof(cin.film.frame_id),(unsigned char *)\n        cin.film.frame_id);\n      (void) CopyMagickString(property,cin.film.frame_id,\n        sizeof(cin.film.frame_id));\n      (void) SetImageProperty(image,\"dpx:film.frame_id\",property,exception);\n      offset+=ReadBlob(image,sizeof(cin.film.slate_info),(unsigned char *)\n        cin.film.slate_info);\n      (void) CopyMagickString(property,cin.film.slate_info,\n        sizeof(cin.film.slate_info));\n      (void) SetImageProperty(image,\"dpx:film.slate_info\",property,exception);\n      offset+=ReadBlob(image,sizeof(cin.film.reserve),(unsigned char *)\n        cin.film.reserve);\n    }\n  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))\n    {\n      StringInfo\n        *profile;\n\n      /*\n        User defined data.\n      */\n      if (cin.file.user_length > GetBlobSize(image))\n        ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n      profile=BlobToStringInfo((const unsigned char *) NULL,\n        cin.file.user_length);\n      if (profile == (StringInfo *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      offset+=ReadBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n      (void) SetImageProfile(image,\"dpx:user.data\",profile,exception);\n      profile=DestroyStringInfo(profile);\n    }\n  image->depth=cin.image.channel[0].bits_per_pixel;\n  image->columns=cin.image.channel[0].pixels_per_line;\n  image->rows=cin.image.channel[0].lines_per_image;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(image);\n    }\n  if (((MagickSizeType) image->columns*image->rows) > GetBlobSize(image))\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n  for ( ; offset < (MagickOffsetType) cin.file.image_offset; offset++)\n  {\n    int\n      c;\n\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      break;\n  }\n  if (offset < (MagickOffsetType) cin.file.image_offset)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  (void) SetImageBackgroundColor(image,exception);\n  /*\n    Convert CIN raster image to pixel packets.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  quantum_info->quantum=32;\n  quantum_info->pack=MagickFalse;\n  quantum_type=RGBQuantum;\n  length=GetQuantumExtent(image,quantum_info,quantum_type);\n  length=GetBytesPerRow(image->columns,3,image->depth,MagickTrue);\n  if (cin.image.number_channels == 1)\n    {\n      quantum_type=GrayQuantum;\n      length=GetBytesPerRow(image->columns,1,image->depth,MagickTrue);\n    }\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    pixels=(const unsigned char *) ReadBlobStream(image,length,\n      GetQuantumPixels(quantum_info),&count);\n    if ((size_t) count != length)\n      break;\n    (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n      quantum_type,pixels,exception);\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  SetQuantumImageType(image,quantum_type);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  SetImageColorspace(image,LogColorspace,exception);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r C I N E O N I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterCINImage() adds attributes for the CIN image format to the list of\n%  of supported formats.  The attributes include the image format tag, a method\n%  to read and/or write the format, whether the format supports the saving of\n%  more than one frame to the same file or blob, whether the format supports\n%  native in-memory I/O, and a brief description of the format.\n%\n%  The format of the RegisterCINImage method is:\n%\n%      size_t RegisterCINImage(void)\n%\n*/\nModuleExport size_t RegisterCINImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"CIN\",\"CIN\",\"Cineon Image File\");\n  entry->decoder=(DecodeImageHandler *) ReadCINImage;\n  entry->encoder=(EncodeImageHandler *) WriteCINImage;\n  entry->magick=(IsImageFormatHandler *) IsCIN;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r C I N E O N I m a g e                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterCINImage() removes format registrations made by the CIN module\n%  from the list of supported formats.\n%\n%  The format of the UnregisterCINImage method is:\n%\n%      UnregisterCINImage(void)\n%\n*/\nModuleExport void UnregisterCINImage(void)\n{\n  (void) UnregisterMagickInfo(\"CINEON\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e C I N E O N I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteCINImage() writes an image in CIN encoded image format.\n%\n%  The format of the WriteCINImage method is:\n%\n%      MagickBooleanType WriteCINImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline const char *GetCINProperty(const ImageInfo *image_info,\n  const Image *image,const char *property,ExceptionInfo *exception)\n{\n  const char\n    *value;\n\n  value=GetImageOption(image_info,property);\n  if (value != (const char *) NULL)\n    return(value);\n  return(GetImageProperty(image,property,exception));\n}\n\nstatic MagickBooleanType WriteCINImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    timestamp[MagickPathExtent];\n\n  const char\n    *value;\n\n  CINInfo\n    cin;\n\n  const StringInfo\n    *profile;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  struct tm\n    local_time;\n\n  time_t\n    seconds;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if (image->colorspace != LogColorspace)\n    (void) TransformImageColorspace(image,LogColorspace,exception);\n  /*\n    Write image information.\n  */\n  (void) memset(&cin,0,sizeof(cin));\n  offset=0;\n  cin.file.magic=0x802A5FD7UL;\n  offset+=WriteBlobLong(image,(unsigned int) cin.file.magic);\n  cin.file.image_offset=0x800;\n  offset+=WriteBlobLong(image,(unsigned int) cin.file.image_offset);\n  cin.file.generic_length=0x400;\n  offset+=WriteBlobLong(image,(unsigned int) cin.file.generic_length);\n  cin.file.industry_length=0x400;\n  offset+=WriteBlobLong(image,(unsigned int) cin.file.industry_length);\n  cin.file.user_length=0x00;\n  profile=GetImageProfile(image,\"dpx:user.data\");\n  if (profile != (StringInfo *) NULL)\n    {\n      cin.file.user_length+=(size_t) GetStringInfoLength(profile);\n      cin.file.user_length=(((cin.file.user_length+0x2000-1)/0x2000)*0x2000);\n    }\n  offset+=WriteBlobLong(image,(unsigned int) cin.file.user_length);\n  cin.file.file_size=4*image->columns*image->rows+0x2000;\n  offset+=WriteBlobLong(image,(unsigned int) cin.file.file_size);\n  (void) CopyMagickString(cin.file.version,\"V4.5\",sizeof(cin.file.version));\n  offset+=WriteBlob(image,sizeof(cin.file.version),(unsigned char *)\n    cin.file.version);\n  value=GetCINProperty(image_info,image,\"dpx:file.filename\",exception);\n  if (value != (const char *) NULL)\n    (void) CopyMagickString(cin.file.filename,value,sizeof(cin.file.filename));\n  else\n    (void) CopyMagickString(cin.file.filename,image->filename,\n      sizeof(cin.file.filename));\n  offset+=WriteBlob(image,sizeof(cin.file.filename),(unsigned char *)\n    cin.file.filename);\n  seconds=time((time_t *) NULL);\n#if defined(MAGICKCORE_HAVE_LOCALTIME_R)\n  (void) localtime_r(&seconds,&local_time);\n#else\n  (void) memcpy(&local_time,localtime(&seconds),sizeof(local_time));\n#endif\n  (void) memset(timestamp,0,sizeof(timestamp));\n  (void) strftime(timestamp,MagickPathExtent,\"%Y:%m:%d:%H:%M:%S%Z\",&local_time);\n  (void) memset(cin.file.create_date,0,sizeof(cin.file.create_date));\n  (void) CopyMagickString(cin.file.create_date,timestamp,11);\n  offset+=WriteBlob(image,sizeof(cin.file.create_date),(unsigned char *)\n    cin.file.create_date);\n  (void) memset(cin.file.create_time,0,sizeof(cin.file.create_time));\n  (void) CopyMagickString(cin.file.create_time,timestamp+11,11);\n  offset+=WriteBlob(image,sizeof(cin.file.create_time),(unsigned char *)\n    cin.file.create_time);\n  offset+=WriteBlob(image,sizeof(cin.file.reserve),(unsigned char *)\n    cin.file.reserve);\n  cin.image.orientation=0x00;\n  offset+=WriteBlobByte(image,cin.image.orientation);\n  cin.image.number_channels=3;\n  offset+=WriteBlobByte(image,cin.image.number_channels);\n  offset+=WriteBlob(image,sizeof(cin.image.reserve1),(unsigned char *)\n    cin.image.reserve1);\n  for (i=0; i < 8; i++)\n  {\n    cin.image.channel[i].designator[0]=0; /* universal metric */\n    offset+=WriteBlobByte(image,cin.image.channel[0].designator[0]);\n    cin.image.channel[i].designator[1]=(unsigned char) (i > 3 ? 0 : i+1); /* channel color */;\n    offset+=WriteBlobByte(image,cin.image.channel[1].designator[0]);\n    cin.image.channel[i].bits_per_pixel=(unsigned char) image->depth;\n    offset+=WriteBlobByte(image,cin.image.channel[0].bits_per_pixel);\n    offset+=WriteBlobByte(image,cin.image.channel[0].reserve);\n    cin.image.channel[i].pixels_per_line=image->columns;\n    offset+=WriteBlobLong(image,(unsigned int)\n      cin.image.channel[0].pixels_per_line);\n    cin.image.channel[i].lines_per_image=image->rows;\n    offset+=WriteBlobLong(image,(unsigned int)\n      cin.image.channel[0].lines_per_image);\n    cin.image.channel[i].min_data=0;\n    offset+=WriteBlobFloat(image,cin.image.channel[0].min_data);\n    cin.image.channel[i].min_quantity=0.0;\n    offset+=WriteBlobFloat(image,cin.image.channel[0].min_quantity);\n    cin.image.channel[i].max_data=(float) ((MagickOffsetType)\n      GetQuantumRange(image->depth));\n    offset+=WriteBlobFloat(image,cin.image.channel[0].max_data);\n    cin.image.channel[i].max_quantity=2.048f;\n    offset+=WriteBlobFloat(image,cin.image.channel[0].max_quantity);\n  }\n  offset+=WriteBlobFloat(image,image->chromaticity.white_point.x);\n  offset+=WriteBlobFloat(image,image->chromaticity.white_point.y);\n  offset+=WriteBlobFloat(image,image->chromaticity.red_primary.x);\n  offset+=WriteBlobFloat(image,image->chromaticity.red_primary.y);\n  offset+=WriteBlobFloat(image,image->chromaticity.green_primary.x);\n  offset+=WriteBlobFloat(image,image->chromaticity.green_primary.y);\n  offset+=WriteBlobFloat(image,image->chromaticity.blue_primary.x);\n  offset+=WriteBlobFloat(image,image->chromaticity.blue_primary.y);\n  value=GetCINProperty(image_info,image,\"dpx:image.label\",exception);\n  if (value != (const char *) NULL)\n    (void) CopyMagickString(cin.image.label,value,sizeof(cin.image.label));\n  offset+=WriteBlob(image,sizeof(cin.image.label),(unsigned char *)\n    cin.image.label);\n  offset+=WriteBlob(image,sizeof(cin.image.reserve),(unsigned char *)\n    cin.image.reserve);\n  /*\n    Write data format information.\n  */\n  cin.data_format.interleave=0; /* pixel interleave (rgbrgbr...) */\n  offset+=WriteBlobByte(image,cin.data_format.interleave);\n  cin.data_format.packing=5; /* packing ssize_tword (32bit) boundaries */\n  offset+=WriteBlobByte(image,cin.data_format.packing);\n  cin.data_format.sign=0; /* unsigned data */\n  offset+=WriteBlobByte(image,cin.data_format.sign);\n  cin.data_format.sense=0; /* image sense: positive image */\n  offset+=WriteBlobByte(image,cin.data_format.sense);\n  cin.data_format.line_pad=0;\n  offset+=WriteBlobLong(image,(unsigned int) cin.data_format.line_pad);\n  cin.data_format.channel_pad=0;\n  offset+=WriteBlobLong(image,(unsigned int) cin.data_format.channel_pad);\n  offset+=WriteBlob(image,sizeof(cin.data_format.reserve),(unsigned char *)\n    cin.data_format.reserve);\n  /*\n    Write origination information.\n  */\n  cin.origination.x_offset=0UL;\n  value=GetCINProperty(image_info,image,\"dpx:origination.x_offset\",exception);\n  if (value != (const char *) NULL)\n    cin.origination.x_offset=(ssize_t) StringToLong(value);\n  offset+=WriteBlobLong(image,(unsigned int) cin.origination.x_offset);\n  cin.origination.y_offset=0UL;\n  value=GetCINProperty(image_info,image,\"dpx:origination.y_offset\",exception);\n  if (value != (const char *) NULL)\n    cin.origination.y_offset=(ssize_t) StringToLong(value);\n  offset+=WriteBlobLong(image,(unsigned int) cin.origination.y_offset);\n  value=GetCINProperty(image_info,image,\"dpx:origination.filename\",exception);\n  if (value != (const char *) NULL)\n    (void) CopyMagickString(cin.origination.filename,value,\n      sizeof(cin.origination.filename));\n  else\n    (void) CopyMagickString(cin.origination.filename,image->filename,\n      sizeof(cin.origination.filename));\n  offset+=WriteBlob(image,sizeof(cin.origination.filename),(unsigned char *)\n    cin.origination.filename);\n  seconds=time((time_t *) NULL);\n  (void) memset(timestamp,0,sizeof(timestamp));\n  (void) strftime(timestamp,MagickPathExtent,\"%Y:%m:%d:%H:%M:%S%Z\",&local_time);\n  (void) memset(cin.origination.create_date,0,\n    sizeof(cin.origination.create_date));\n  (void) CopyMagickString(cin.origination.create_date,timestamp,11);\n  offset+=WriteBlob(image,sizeof(cin.origination.create_date),(unsigned char *)\n    cin.origination.create_date);\n  (void) memset(cin.origination.create_time,0,\n     sizeof(cin.origination.create_time));\n  (void) CopyMagickString(cin.origination.create_time,timestamp+11,15);\n  offset+=WriteBlob(image,sizeof(cin.origination.create_time),(unsigned char *)\n    cin.origination.create_time);\n  value=GetCINProperty(image_info,image,\"dpx:origination.device\",exception);\n  if (value != (const char *) NULL)\n    (void) CopyMagickString(cin.origination.device,value,\n      sizeof(cin.origination.device));\n  offset+=WriteBlob(image,sizeof(cin.origination.device),(unsigned char *)\n    cin.origination.device);\n  value=GetCINProperty(image_info,image,\"dpx:origination.model\",exception);\n  if (value != (const char *) NULL)\n    (void) CopyMagickString(cin.origination.model,value,\n      sizeof(cin.origination.model));\n  offset+=WriteBlob(image,sizeof(cin.origination.model),(unsigned char *)\n    cin.origination.model);\n  value=GetCINProperty(image_info,image,\"dpx:origination.serial\",exception);\n  if (value != (const char *) NULL)\n    (void) CopyMagickString(cin.origination.serial,value,\n      sizeof(cin.origination.serial));\n  offset+=WriteBlob(image,sizeof(cin.origination.serial),(unsigned char *)\n    cin.origination.serial);\n  cin.origination.x_pitch=0.0f;\n  value=GetCINProperty(image_info,image,\"dpx:origination.x_pitch\",exception);\n  if (value != (const char *) NULL)\n    cin.origination.x_pitch=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,cin.origination.x_pitch);\n  cin.origination.y_pitch=0.0f;\n  value=GetCINProperty(image_info,image,\"dpx:origination.y_pitch\",exception);\n  if (value != (const char *) NULL)\n    cin.origination.y_pitch=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,cin.origination.y_pitch);\n  cin.origination.gamma=image->gamma;\n  offset+=WriteBlobFloat(image,cin.origination.gamma);\n  offset+=WriteBlob(image,sizeof(cin.origination.reserve),(unsigned char *)\n    cin.origination.reserve);\n  /*\n    Image film information.\n  */\n  cin.film.id=0;\n  value=GetCINProperty(image_info,image,\"dpx:film.id\",exception);\n  if (value != (const char *) NULL)\n    cin.film.id=(char) StringToLong(value);\n  offset+=WriteBlobByte(image,(unsigned char) cin.film.id);\n  cin.film.type=0;\n  value=GetCINProperty(image_info,image,\"dpx:film.type\",exception);\n  if (value != (const char *) NULL)\n    cin.film.type=(char) StringToLong(value);\n  offset+=WriteBlobByte(image,(unsigned char) cin.film.type);\n  cin.film.offset=0;\n  value=GetCINProperty(image_info,image,\"dpx:film.offset\",exception);\n  if (value != (const char *) NULL)\n    cin.film.offset=(char) StringToLong(value);\n  offset+=WriteBlobByte(image,(unsigned char) cin.film.offset);\n  offset+=WriteBlobByte(image,(unsigned char) cin.film.reserve1);\n  cin.film.prefix=0UL;\n  value=GetCINProperty(image_info,image,\"dpx:film.prefix\",exception);\n  if (value != (const char *) NULL)\n    cin.film.prefix=StringToUnsignedLong(value);\n  offset+=WriteBlobLong(image,(unsigned int) cin.film.prefix);\n  cin.film.count=0UL;\n  value=GetCINProperty(image_info,image,\"dpx:film.count\",exception);\n  if (value != (const char *) NULL)\n    cin.film.count=StringToUnsignedLong(value);\n  offset+=WriteBlobLong(image,(unsigned int) cin.film.count);\n  value=GetCINProperty(image_info,image,\"dpx:film.format\",exception);\n  if (value != (const char *) NULL)\n    (void) CopyMagickString(cin.film.format,value,sizeof(cin.film.format));\n  offset+=WriteBlob(image,sizeof(cin.film.format),(unsigned char *)\n    cin.film.format);\n  cin.film.frame_position=0UL;\n  value=GetCINProperty(image_info,image,\"dpx:film.frame_position\",exception);\n  if (value != (const char *) NULL)\n    cin.film.frame_position=StringToUnsignedLong(value);\n  offset+=WriteBlobLong(image,(unsigned int) cin.film.frame_position);\n  cin.film.frame_rate=0.0f;\n  value=GetCINProperty(image_info,image,\"dpx:film.frame_rate\",exception);\n  if (value != (const char *) NULL)\n    cin.film.frame_rate=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,cin.film.frame_rate);\n  value=GetCINProperty(image_info,image,\"dpx:film.frame_id\",exception);\n  if (value != (const char *) NULL)\n    (void) CopyMagickString(cin.film.frame_id,value,sizeof(cin.film.frame_id));\n  offset+=WriteBlob(image,sizeof(cin.film.frame_id),(unsigned char *)\n    cin.film.frame_id);\n  value=GetCINProperty(image_info,image,\"dpx:film.slate_info\",exception);\n  if (value != (const char *) NULL)\n    (void) CopyMagickString(cin.film.slate_info,value,\n      sizeof(cin.film.slate_info));\n  offset+=WriteBlob(image,sizeof(cin.film.slate_info),(unsigned char *)\n    cin.film.slate_info);\n  offset+=WriteBlob(image,sizeof(cin.film.reserve),(unsigned char *)\n    cin.film.reserve);\n  if (profile != (StringInfo *) NULL)\n    offset+=WriteBlob(image,GetStringInfoLength(profile),\n      GetStringInfoDatum(profile));\n  while (offset < (MagickOffsetType) cin.file.image_offset)\n    offset+=WriteBlobByte(image,0x00);\n  /*\n    Convert pixel packets to CIN raster image.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  quantum_info->quantum=32;\n  quantum_info->pack=MagickFalse;\n  quantum_type=RGBQuantum;\n  pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n  length=GetBytesPerRow(image->columns,3,image->depth,MagickTrue);\nDisableMSCWarning(4127)\n  if (0)\nRestoreMSCWarning\n    {\n      quantum_type=GrayQuantum;\n      length=GetBytesPerRow(image->columns,1,image->depth,MagickTrue);\n    }\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    (void) ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n      quantum_type,pixels,exception);\n    count=WriteBlob(image,length,pixels);\n    if (count != (ssize_t) length)\n      break;\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  (void) CloseBlob(image);\n  return(status);\n}\n"], "filenames": ["coders/cin.c"], "buggy_code_start_loc": [733], "buggy_code_end_loc": [733], "fixing_code_start_loc": [734], "fixing_code_end_loc": [736], "type": "CWE-400", "message": "The cineon parsing component in ImageMagick 7.0.8-26 Q16 allows attackers to cause a denial-of-service (uncontrolled resource consumption) by crafting a Cineon image with an incorrect claimed image size. This occurs because ReadCINImage in coders/cin.c lacks a check for insufficient image data in a file.", "other": {"cve": {"id": "CVE-2019-11470", "sourceIdentifier": "cve@mitre.org", "published": "2019-04-23T14:29:00.600", "lastModified": "2020-08-19T02:15:14.333", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The cineon parsing component in ImageMagick 7.0.8-26 Q16 allows attackers to cause a denial-of-service (uncontrolled resource consumption) by crafting a Cineon image with an incorrect claimed image size. This occurs because ReadCINImage in coders/cin.c lacks a check for insufficient image data in a file."}, {"lang": "es", "value": "El componente de an\u00e1lisis de cineon en ImageMagick 7.0.8-26 Q16, permite a los atacantes provocar una denegaci\u00f3n de servicio (consumo incontrolado de recursos) creando una imagen Cineon con un tama\u00f1o de imagen declarado incorrecto. Esto se debe a que ReadCINImage en coders/cin.c carece de una comprobaci\u00f3n de datos de imagen insuficientes en un archivo."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.1}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.8-26:q16:*:*:*:*:*:*", "matchCriteriaId": "64AB3C42-4698-4E94-9A4A-F75BA34C7213"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-06/msg00057.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-07/msg00001.html", "source": "cve@mitre.org"}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/e3cdce6fe12193f235b8c0ae5efe6880a25eb957", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/1472", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/10/msg00028.html", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2020/08/msg00030.html", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PF62B5PJA2JDUOCKJGUQO3SPL74BEYSV/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WHIKB4TP6KBJWT2UIPWL5MWMG5QXKGEJ/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4034-1/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2020/dsa-4712", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/e3cdce6fe12193f235b8c0ae5efe6880a25eb957"}}