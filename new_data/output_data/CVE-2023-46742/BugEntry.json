{"buggy_code": ["package master\n\nimport (\n\t\"crypto/sha1\"\n\t\"encoding/hex\"\n\t\"io\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/cubefs/cubefs/proto\"\n\t\"github.com/cubefs/cubefs/raftstore\"\n\t\"github.com/cubefs/cubefs/util\"\n\t\"github.com/cubefs/cubefs/util/log\"\n)\n\nconst (\n\taccessKeyLength     = 16\n\tsecretKeyLength     = 32\n\tRootUserID          = \"root\"\n\tDefaultRootPasswd   = \"CubeFSRoot\"\n\tDefaultUserPassword = \"CubeFSUser\"\n)\n\ntype User struct {\n\tfsm            *MetadataFsm\n\tpartition      raftstore.Partition\n\tuserStore      sync.Map //K: userID, V: UserInfo\n\tAKStore        sync.Map //K: ak, V: userID\n\tvolUser        sync.Map //K: vol, V: userIDs\n\tuserStoreMutex sync.RWMutex\n\tAKStoreMutex   sync.RWMutex\n\tvolUserMutex   sync.RWMutex\n}\n\nfunc newUser(fsm *MetadataFsm, partition raftstore.Partition) (u *User) {\n\tu = new(User)\n\tu.fsm = fsm\n\tu.partition = partition\n\treturn\n}\n\nfunc (u *User) createKey(param *proto.UserCreateParam) (userInfo *proto.UserInfo, err error) {\n\tvar (\n\t\tAKUser     *proto.AKUser\n\t\tuserPolicy *proto.UserPolicy\n\t\texist      bool\n\t)\n\tif param.ID == \"\" {\n\t\terr = proto.ErrInvalidUserID\n\t\treturn\n\t}\n\tif !param.Type.Valid() {\n\t\terr = proto.ErrInvalidUserType\n\t\treturn\n\t}\n\n\tvar userID = param.ID\n\tvar password = param.Password\n\tif password == \"\" {\n\t\tpassword = DefaultUserPassword\n\t}\n\tvar accessKey = param.AccessKey\n\tif accessKey == \"\" {\n\t\taccessKey = util.RandomString(accessKeyLength, util.Numeric|util.LowerLetter|util.UpperLetter)\n\t} else {\n\t\tif !proto.IsValidAK(accessKey) {\n\t\t\terr = proto.ErrInvalidAccessKey\n\t\t\treturn\n\t\t}\n\t}\n\tvar secretKey = param.SecretKey\n\tif secretKey == \"\" {\n\t\tsecretKey = util.RandomString(secretKeyLength, util.Numeric|util.LowerLetter|util.UpperLetter)\n\t} else {\n\t\tif !proto.IsValidSK(secretKey) {\n\t\t\terr = proto.ErrInvalidSecretKey\n\t\t\treturn\n\t\t}\n\t}\n\tvar userType = param.Type\n\tvar description = param.Description\n\tu.userStoreMutex.Lock()\n\tdefer u.userStoreMutex.Unlock()\n\tu.AKStoreMutex.Lock()\n\tdefer u.AKStoreMutex.Unlock()\n\t//check duplicate\n\tif _, exist = u.userStore.Load(userID); exist {\n\t\terr = proto.ErrDuplicateUserID\n\t\treturn\n\t}\n\t_, exist = u.AKStore.Load(accessKey)\n\tfor exist {\n\t\taccessKey = util.RandomString(accessKeyLength, util.Numeric|util.LowerLetter|util.UpperLetter)\n\t\t_, exist = u.AKStore.Load(accessKey)\n\t}\n\tuserPolicy = proto.NewUserPolicy()\n\tuserInfo = &proto.UserInfo{UserID: userID, AccessKey: accessKey, SecretKey: secretKey, Policy: userPolicy,\n\t\tUserType: userType, CreateTime: time.Unix(time.Now().Unix(), 0).Format(proto.TimeFormat), Description: description}\n\tAKUser = &proto.AKUser{AccessKey: accessKey, UserID: userID, Password: encodingPassword(password)}\n\tif err = u.syncAddUserInfo(userInfo); err != nil {\n\t\treturn\n\t}\n\tif err = u.syncAddAKUser(AKUser); err != nil {\n\t\treturn\n\t}\n\tu.userStore.Store(userID, userInfo)\n\tu.AKStore.Store(accessKey, AKUser)\n\tlog.LogInfof(\"action[createUser], userID: %v, accesskey[%v], secretkey[%v]\", userID, accessKey, secretKey)\n\treturn\n}\n\nfunc (u *User) deleteKey(userID string) (err error) {\n\tvar (\n\t\takUser   *proto.AKUser\n\t\tuserInfo *proto.UserInfo\n\t)\n\n\tu.userStoreMutex.Lock()\n\tdefer u.userStoreMutex.Unlock()\n\tu.AKStoreMutex.Lock()\n\tdefer u.AKStoreMutex.Unlock()\n\n\tif value, exist := u.userStore.Load(userID); !exist {\n\t\terr = proto.ErrUserNotExists\n\t\treturn\n\t} else {\n\t\tuserInfo = value.(*proto.UserInfo)\n\t}\n\tuserInfo.Mu.Lock()\n\tdefer userInfo.Mu.Unlock()\n\tif len(userInfo.Policy.OwnVols) > 0 {\n\t\terr = proto.ErrOwnVolExists\n\t\treturn\n\t}\n\tif userInfo.UserType == proto.UserTypeRoot {\n\t\terr = proto.ErrNoPermission\n\t\treturn\n\t}\n\tif akUser, err = u.getAKUser(userInfo.AccessKey); err != nil {\n\t\treturn\n\t}\n\tif err = u.syncDeleteUserInfo(userInfo); err != nil {\n\t\treturn\n\t}\n\tif err = u.syncDeleteAKUser(akUser); err != nil {\n\t\treturn\n\t}\n\tu.userStore.Delete(userID)\n\tu.AKStore.Delete(akUser.AccessKey)\n\t// delete userID from related policy in volUserStore\n\tu.removeUserFromAllVol(userID)\n\tlog.LogInfof(\"action[deleteUser], userID: %v, accesskey[%v]\", userID, userInfo.AccessKey)\n\treturn\n}\n\nfunc (u *User) updateKey(param *proto.UserUpdateParam) (userInfo *proto.UserInfo, err error) {\n\tif param.UserID == \"\" {\n\t\terr = proto.ErrInvalidUserID\n\t\treturn\n\t}\n\n\tu.userStoreMutex.Lock()\n\tdefer u.userStoreMutex.Unlock()\n\tu.AKStoreMutex.Lock()\n\tdefer u.AKStoreMutex.Unlock()\n\n\tif value, exist := u.userStore.Load(param.UserID); !exist {\n\t\terr = proto.ErrUserNotExists\n\t\treturn\n\t} else {\n\t\tuserInfo = value.(*proto.UserInfo)\n\t}\n\tuserInfo.Mu.Lock()\n\tdefer userInfo.Mu.Unlock()\n\tif userInfo.UserType == proto.UserTypeRoot {\n\t\terr = proto.ErrNoPermission\n\t\treturn\n\t}\n\tvar formerAK = userInfo.AccessKey\n\tvar akMark, skMark, typeMark, describeMark int\n\tif param.AccessKey != \"\" {\n\t\tif !proto.IsValidAK(param.AccessKey) {\n\t\t\terr = proto.ErrInvalidAccessKey\n\t\t\treturn\n\t\t}\n\t\tif _, exist := u.AKStore.Load(param.AccessKey); exist {\n\t\t\terr = proto.ErrDuplicateAccessKey\n\t\t\treturn\n\t\t}\n\t\takMark = 1\n\t}\n\tif param.SecretKey != \"\" {\n\t\tif !proto.IsValidSK(param.SecretKey) {\n\t\t\terr = proto.ErrInvalidSecretKey\n\t\t\treturn\n\t\t}\n\t\tskMark = 1\n\t}\n\t//Type == 0,do not modify type\n\tif param.Type != 0 {\n\t\tif param.Type.Valid() {\n\t\t\ttypeMark = 1\n\t\t} else {\n\t\t\terr = proto.ErrInvalidUserType\n\t\t\treturn\n\t\t}\n\t}\n\tif param.Description != \"\" {\n\t\tdescribeMark = 1\n\t}\n\n\tvar akUserBef *proto.AKUser\n\tvar akUserAft *proto.AKUser\n\n\tif value, exist := u.AKStore.Load(formerAK); exist {\n\t\takUserBef = value.(*proto.AKUser)\n\t} else {\n\t\terr = proto.ErrAccessKeyNotExists\n\t\treturn\n\t}\n\tif akMark == 1 {\n\t\tuserInfo.AccessKey = param.AccessKey\n\t}\n\tif skMark == 1 {\n\t\tuserInfo.SecretKey = param.SecretKey\n\t}\n\tif typeMark == 1 {\n\t\tuserInfo.UserType = param.Type\n\t}\n\tif describeMark == 1 {\n\t\tuserInfo.Description = param.Description\n\t}\n\n\tif len(strings.TrimSpace(param.Password)) != 0 {\n\t\takUserBef.Password = encodingPassword(param.Password)\n\t}\n\n\takUserAft = &proto.AKUser{AccessKey: userInfo.AccessKey, UserID: param.UserID, Password: akUserBef.Password}\n\n\tif err = u.syncUpdateUserInfo(userInfo); err != nil {\n\t\treturn\n\t}\n\tif err = u.syncDeleteAKUser(akUserBef); err != nil {\n\t\treturn\n\t}\n\tif err = u.syncAddAKUser(akUserAft); err != nil {\n\t\treturn\n\t}\n\tu.AKStore.Delete(formerAK)\n\tu.AKStore.Store(akUserAft.AccessKey, akUserAft)\n\n\tlog.LogInfof(\"action[updateUser], userID: %v, accesskey[%v], secretkey[%v]\", userInfo.UserID, userInfo.AccessKey, userInfo.SecretKey)\n\treturn\n}\n\nfunc (u *User) getKeyInfo(ak string) (userInfo *proto.UserInfo, err error) {\n\tvar akUser *proto.AKUser\n\tif akUser, err = u.getAKUser(ak); err != nil {\n\t\treturn\n\t}\n\tif userInfo, err = u.getUserInfo(akUser.UserID); err != nil {\n\t\treturn\n\t}\n\tlog.LogInfof(\"action[getKeyInfo], accesskey[%v]\", ak)\n\treturn\n}\n\nfunc (u *User) getUserInfo(userID string) (userInfo *proto.UserInfo, err error) {\n\tif value, exist := u.userStore.Load(userID); exist {\n\t\tuserInfo = value.(*proto.UserInfo)\n\t} else {\n\t\terr = proto.ErrUserNotExists\n\t\treturn\n\t}\n\tlog.LogInfof(\"action[getUserInfo], userID: %v\", userID)\n\treturn\n}\n\nfunc (u *User) updatePolicy(params *proto.UserPermUpdateParam) (userInfo *proto.UserInfo, err error) {\n\tif userInfo, err = u.getUserInfo(params.UserID); err != nil {\n\t\treturn\n\t}\n\tuserInfo.Mu.Lock()\n\tdefer userInfo.Mu.Unlock()\n\tif userInfo.Policy.IsOwn(params.Volume) {\n\t\terr = proto.ErrIsOwner\n\t\treturn\n\t}\n\tuserInfo.Policy.AddAuthorizedVol(params.Volume, params.Policy)\n\tif err = u.syncUpdateUserInfo(userInfo); err != nil {\n\t\terr = proto.ErrPersistenceByRaft\n\t\treturn\n\t}\n\tif err = u.addUserToVol(params.UserID, params.Volume); err != nil {\n\t\treturn\n\t}\n\tlog.LogInfof(\"action[updatePolicy], userID: %v, volume: %v\", params.UserID, params.Volume)\n\treturn\n}\n\nfunc (u *User) removePolicy(params *proto.UserPermRemoveParam) (userInfo *proto.UserInfo, err error) {\n\tif userInfo, err = u.getUserInfo(params.UserID); err != nil {\n\t\treturn\n\t}\n\tuserInfo.Mu.Lock()\n\tdefer userInfo.Mu.Unlock()\n\tif userInfo.Policy.IsOwn(params.Volume) {\n\t\terr = proto.ErrIsOwner\n\t\treturn\n\t}\n\tuserInfo.Policy.RemoveAuthorizedVol(params.Volume)\n\tif err = u.syncUpdateUserInfo(userInfo); err != nil {\n\t\terr = proto.ErrPersistenceByRaft\n\t\treturn\n\t}\n\tif err = u.removeUserFromVol(params.UserID, params.Volume); err != nil {\n\t\treturn\n\t}\n\tlog.LogInfof(\"action[removePolicy], userID: %v, volume: %v\", params.UserID, params.Volume)\n\treturn\n}\n\nfunc (u *User) addOwnVol(userID, volName string) (userInfo *proto.UserInfo, err error) {\n\tif userInfo, err = u.getUserInfo(userID); err != nil {\n\t\treturn\n\t}\n\tuserInfo.Mu.Lock()\n\tdefer userInfo.Mu.Unlock()\n\tuserInfo.Policy.AddOwnVol(volName)\n\tuserInfo.Policy.RemoveAuthorizedVol(volName)\n\tif err = u.syncUpdateUserInfo(userInfo); err != nil {\n\t\terr = proto.ErrPersistenceByRaft\n\t\treturn\n\t}\n\tif err = u.addUserToVol(userID, volName); err != nil {\n\t\treturn\n\t}\n\tlog.LogInfof(\"action[addOwnVol], userID: %v, volume: %v\", userID, volName)\n\treturn\n}\n\nfunc (u *User) removeOwnVol(userID, volName string) (userInfo *proto.UserInfo, err error) {\n\tif userInfo, err = u.getUserInfo(userID); err != nil {\n\t\treturn\n\t}\n\tuserInfo.Mu.Lock()\n\tdefer userInfo.Mu.Unlock()\n\tuserInfo.Policy.RemoveOwnVol(volName)\n\tif err = u.syncUpdateUserInfo(userInfo); err != nil {\n\t\terr = proto.ErrPersistenceByRaft\n\t\treturn\n\t}\n\tif err = u.removeUserFromVol(userID, volName); err != nil {\n\t\treturn\n\t}\n\tlog.LogInfof(\"action[removeOwnVol], userID: %v, volume: %v\", userID, volName)\n\treturn\n}\n\nfunc (u *User) deleteVolPolicy(volName string) (err error) {\n\tvar (\n\t\tvolUser  *proto.VolUser\n\t\tuserInfo *proto.UserInfo\n\t)\n\t//delete policy\n\tvar deletedUsers = make([]string, 0)\n\tvar userIDs []string\n\tif userIDs, err = u.getUsersOfVol(volName); err != nil {\n\t\treturn\n\t}\n\tfor _, userID := range userIDs {\n\t\tif userInfo, err = u.getUserInfo(userID); err != nil {\n\t\t\tif err == proto.ErrUserNotExists {\n\t\t\t\tdeletedUsers = append(deletedUsers, userID)\n\t\t\t\tlog.LogWarnf(\"action[deleteVolPolicy], userID: %v does not exist\", userID)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tuserInfo.Mu.Lock()\n\t\tuserInfo.Policy.RemoveOwnVol(volName)\n\t\tuserInfo.Policy.RemoveAuthorizedVol(volName)\n\t\tif err = u.syncUpdateUserInfo(userInfo); err != nil {\n\t\t\terr = proto.ErrPersistenceByRaft\n\t\t\tuserInfo.Mu.Unlock()\n\t\t\treturn\n\t\t}\n\t\tuserInfo.Mu.Unlock()\n\t}\n\t//delete volName index\n\tif value, exist := u.volUser.Load(volName); exist {\n\t\tvolUser = value.(*proto.VolUser)\n\t} else {\n\t\treturn nil\n\t}\n\tvolUser.Mu.Lock()\n\tif err = u.syncDeleteVolUser(volUser); err != nil {\n\t\tvolUser.Mu.Unlock()\n\t\treturn\n\t}\n\tu.volUser.Delete(volUser.Vol)\n\tvolUser.Mu.Unlock()\n\tfor _, deletedUser := range deletedUsers {\n\t\tu.removeUserFromAllVol(deletedUser)\n\t}\n\tlog.LogInfof(\"action[deleteVolPolicy], volName: %v\", volName)\n\treturn\n}\n\nfunc (u *User) transferVol(params *proto.UserTransferVolParam) (targetUserInfo *proto.UserInfo, err error) {\n\tvar userInfo *proto.UserInfo\n\tuserInfo, err = u.getUserInfo(params.UserSrc)\n\tif (err != nil && err != proto.ErrUserNotExists) || (!params.Force && err == proto.ErrUserNotExists) {\n\t\treturn\n\t}\n\tif err == nil {\n\t\tvar isOwned = userInfo.Policy.IsOwn(params.Volume)\n\t\tif !isOwned && !params.Force && params.UserSrc != params.UserDst {\n\t\t\terr = proto.ErrHaveNoPolicy\n\t\t\treturn\n\t\t}\n\t\tif isOwned {\n\t\t\tif _, err = u.removeOwnVol(params.UserSrc, params.Volume); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\tif targetUserInfo, err = u.addOwnVol(params.UserDst, params.Volume); err != nil {\n\t\treturn\n\t}\n\tlog.LogInfof(\"action[transferVol], volName: %v, userSrc: %v, userDst: %v\", params.Volume, params.UserSrc, params.UserDst)\n\treturn\n}\n\nfunc (u *User) getAllUserInfo(keywords string) (users []*proto.UserInfo) {\n\tusers = make([]*proto.UserInfo, 0)\n\tu.userStore.Range(func(key, value interface{}) bool {\n\t\tuserInfo := value.(*proto.UserInfo)\n\t\tif strings.Contains(userInfo.UserID, keywords) {\n\t\t\tusers = append(users, userInfo)\n\t\t}\n\t\treturn true\n\t})\n\tlog.LogInfof(\"action[getAllUserInfo], keywords: %v, total numbers: %v\", keywords, len(users))\n\treturn\n}\n\nfunc (u *User) getUsersOfVol(volName string) (userIDs []string, err error) {\n\tvar volUser *proto.VolUser\n\tuserIDs = make([]string, 0)\n\tif value, exist := u.volUser.Load(volName); exist {\n\t\tvolUser = value.(*proto.VolUser)\n\t} else {\n\t\terr = proto.ErrHaveNoPolicy\n\t\treturn\n\t}\n\tvolUser.Mu.RLock()\n\tdefer volUser.Mu.RUnlock()\n\tfor _, userID := range volUser.UserIDs {\n\t\tuserIDs = append(userIDs, userID)\n\t}\n\tlog.LogInfof(\"action[getUsersOfVol], vol: %v, user numbers: %v\", volName, len(userIDs))\n\treturn\n}\n\nfunc (u *User) getAKUser(ak string) (akUser *proto.AKUser, err error) {\n\tif value, exist := u.AKStore.Load(ak); exist {\n\t\takUser = value.(*proto.AKUser)\n\t} else {\n\t\terr = proto.ErrAccessKeyNotExists\n\t}\n\treturn\n}\n\nfunc (u *User) addUserToVol(userID, volName string) (err error) {\n\tu.volUserMutex.Lock()\n\tdefer u.volUserMutex.Unlock()\n\tvar (\n\t\tvolUser *proto.VolUser\n\t)\n\tif value, ok := u.volUser.Load(volName); ok {\n\t\tvolUser = value.(*proto.VolUser)\n\t\tvolUser.Mu.Lock()\n\t\tdefer volUser.Mu.Unlock()\n\t\tif contains(volUser.UserIDs, userID) {\n\t\t\treturn\n\t\t}\n\t\tvolUser.UserIDs = append(volUser.UserIDs, userID)\n\t} else {\n\t\tvolUser = &proto.VolUser{Vol: volName, UserIDs: []string{userID}}\n\t\tu.volUser.Store(volName, volUser)\n\t}\n\tif err = u.syncAddVolUser(volUser); err != nil {\n\t\terr = proto.ErrPersistenceByRaft\n\t\treturn\n\t}\n\treturn\n}\nfunc (u *User) removeUserFromVol(userID, volName string) (err error) {\n\tvar (\n\t\tvolUser *proto.VolUser\n\t)\n\tif value, ok := u.volUser.Load(volName); ok {\n\t\tvolUser = value.(*proto.VolUser)\n\t\tvolUser.Mu.Lock()\n\t\tdefer volUser.Mu.Unlock()\n\t\tvolUser.UserIDs, _ = removeString(volUser.UserIDs, userID)\n\t} else {\n\t\terr = proto.ErrHaveNoPolicy\n\t\treturn\n\t}\n\tif err = u.syncUpdateVolUser(volUser); err != nil {\n\t\terr = proto.ErrPersistenceByRaft\n\t\treturn\n\t}\n\treturn\n}\n\nfunc (u *User) removeUserFromAllVol(userID string) {\n\tu.volUser.Range(func(key, value interface{}) bool {\n\t\tvolUser := value.(*proto.VolUser)\n\t\tvolUser.Mu.Lock()\n\t\tvar exist bool\n\t\tvolUser.UserIDs, exist = removeString(volUser.UserIDs, userID)\n\t\tif exist {\n\t\t\tif err := u.syncUpdateVolUser(volUser); err != nil {\n\t\t\t\terr = proto.ErrPersistenceByRaft\n\t\t\t\tlog.LogErrorf(\"action[deleteUser], userID: %v, volUser: %v, err: %v\", userID, volUser, err)\n\t\t\t}\n\t\t}\n\t\tvolUser.Mu.Unlock()\n\t\treturn true\n\t})\n}\n\nfunc removeString(array []string, element string) ([]string, bool) {\n\tfor k, v := range array {\n\t\tif v == element {\n\t\t\treturn append(array[:k], array[k+1:]...), true\n\t\t}\n\t}\n\treturn array, false\n}\n\nfunc encodingPassword(s string) string {\n\tt := sha1.New()\n\tio.WriteString(t, s)\n\treturn hex.EncodeToString(t.Sum(nil))\n}\n\nfunc (u *User) clearUserStore() {\n\tu.userStore.Range(func(key, value interface{}) bool {\n\t\tu.userStore.Delete(key)\n\t\treturn true\n\t})\n}\n\nfunc (u *User) clearAKStore() {\n\tu.AKStore.Range(func(key, value interface{}) bool {\n\t\tu.AKStore.Delete(key)\n\t\treturn true\n\t})\n}\n\nfunc (u *User) clearVolUsers() {\n\tu.volUser.Range(func(key, value interface{}) bool {\n\t\tu.volUser.Delete(key)\n\t\treturn true\n\t})\n}\n"], "fixing_code": ["package master\n\nimport (\n\t\"crypto/sha1\"\n\t\"encoding/hex\"\n\t\"io\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/cubefs/cubefs/proto\"\n\t\"github.com/cubefs/cubefs/raftstore\"\n\t\"github.com/cubefs/cubefs/util\"\n\t\"github.com/cubefs/cubefs/util/log\"\n)\n\nconst (\n\taccessKeyLength     = 16\n\tsecretKeyLength     = 32\n\tRootUserID          = \"root\"\n\tDefaultRootPasswd   = \"CubeFSRoot\"\n\tDefaultUserPassword = \"CubeFSUser\"\n)\n\ntype User struct {\n\tfsm            *MetadataFsm\n\tpartition      raftstore.Partition\n\tuserStore      sync.Map //K: userID, V: UserInfo\n\tAKStore        sync.Map //K: ak, V: userID\n\tvolUser        sync.Map //K: vol, V: userIDs\n\tuserStoreMutex sync.RWMutex\n\tAKStoreMutex   sync.RWMutex\n\tvolUserMutex   sync.RWMutex\n}\n\nfunc newUser(fsm *MetadataFsm, partition raftstore.Partition) (u *User) {\n\tu = new(User)\n\tu.fsm = fsm\n\tu.partition = partition\n\treturn\n}\n\nfunc (u *User) createKey(param *proto.UserCreateParam) (userInfo *proto.UserInfo, err error) {\n\tvar (\n\t\tAKUser     *proto.AKUser\n\t\tuserPolicy *proto.UserPolicy\n\t\texist      bool\n\t)\n\tif param.ID == \"\" {\n\t\terr = proto.ErrInvalidUserID\n\t\treturn\n\t}\n\tif !param.Type.Valid() {\n\t\terr = proto.ErrInvalidUserType\n\t\treturn\n\t}\n\n\tvar userID = param.ID\n\tvar password = param.Password\n\tif password == \"\" {\n\t\tpassword = DefaultUserPassword\n\t}\n\tvar accessKey = param.AccessKey\n\tif accessKey == \"\" {\n\t\taccessKey = util.RandomString(accessKeyLength, util.Numeric|util.LowerLetter|util.UpperLetter)\n\t} else {\n\t\tif !proto.IsValidAK(accessKey) {\n\t\t\terr = proto.ErrInvalidAccessKey\n\t\t\treturn\n\t\t}\n\t}\n\tvar secretKey = param.SecretKey\n\tif secretKey == \"\" {\n\t\tsecretKey = util.RandomString(secretKeyLength, util.Numeric|util.LowerLetter|util.UpperLetter)\n\t} else {\n\t\tif !proto.IsValidSK(secretKey) {\n\t\t\terr = proto.ErrInvalidSecretKey\n\t\t\treturn\n\t\t}\n\t}\n\tvar userType = param.Type\n\tvar description = param.Description\n\tu.userStoreMutex.Lock()\n\tdefer u.userStoreMutex.Unlock()\n\tu.AKStoreMutex.Lock()\n\tdefer u.AKStoreMutex.Unlock()\n\t//check duplicate\n\tif _, exist = u.userStore.Load(userID); exist {\n\t\terr = proto.ErrDuplicateUserID\n\t\treturn\n\t}\n\t_, exist = u.AKStore.Load(accessKey)\n\tfor exist {\n\t\taccessKey = util.RandomString(accessKeyLength, util.Numeric|util.LowerLetter|util.UpperLetter)\n\t\t_, exist = u.AKStore.Load(accessKey)\n\t}\n\tuserPolicy = proto.NewUserPolicy()\n\tuserInfo = &proto.UserInfo{UserID: userID, AccessKey: accessKey, SecretKey: secretKey, Policy: userPolicy,\n\t\tUserType: userType, CreateTime: time.Unix(time.Now().Unix(), 0).Format(proto.TimeFormat), Description: description}\n\tAKUser = &proto.AKUser{AccessKey: accessKey, UserID: userID, Password: encodingPassword(password)}\n\tif err = u.syncAddUserInfo(userInfo); err != nil {\n\t\treturn\n\t}\n\tif err = u.syncAddAKUser(AKUser); err != nil {\n\t\treturn\n\t}\n\tu.userStore.Store(userID, userInfo)\n\tu.AKStore.Store(accessKey, AKUser)\n\n\treturn\n}\n\nfunc (u *User) deleteKey(userID string) (err error) {\n\tvar (\n\t\takUser   *proto.AKUser\n\t\tuserInfo *proto.UserInfo\n\t)\n\n\tu.userStoreMutex.Lock()\n\tdefer u.userStoreMutex.Unlock()\n\tu.AKStoreMutex.Lock()\n\tdefer u.AKStoreMutex.Unlock()\n\n\tif value, exist := u.userStore.Load(userID); !exist {\n\t\terr = proto.ErrUserNotExists\n\t\treturn\n\t} else {\n\t\tuserInfo = value.(*proto.UserInfo)\n\t}\n\tuserInfo.Mu.Lock()\n\tdefer userInfo.Mu.Unlock()\n\tif len(userInfo.Policy.OwnVols) > 0 {\n\t\terr = proto.ErrOwnVolExists\n\t\treturn\n\t}\n\tif userInfo.UserType == proto.UserTypeRoot {\n\t\terr = proto.ErrNoPermission\n\t\treturn\n\t}\n\tif akUser, err = u.getAKUser(userInfo.AccessKey); err != nil {\n\t\treturn\n\t}\n\tif err = u.syncDeleteUserInfo(userInfo); err != nil {\n\t\treturn\n\t}\n\tif err = u.syncDeleteAKUser(akUser); err != nil {\n\t\treturn\n\t}\n\tu.userStore.Delete(userID)\n\tu.AKStore.Delete(akUser.AccessKey)\n\t// delete userID from related policy in volUserStore\n\tu.removeUserFromAllVol(userID)\n\tlog.LogInfof(\"action[deleteUser], userID: %v, accesskey[%v]\", userID, userInfo.AccessKey)\n\treturn\n}\n\nfunc (u *User) updateKey(param *proto.UserUpdateParam) (userInfo *proto.UserInfo, err error) {\n\tif param.UserID == \"\" {\n\t\terr = proto.ErrInvalidUserID\n\t\treturn\n\t}\n\n\tu.userStoreMutex.Lock()\n\tdefer u.userStoreMutex.Unlock()\n\tu.AKStoreMutex.Lock()\n\tdefer u.AKStoreMutex.Unlock()\n\n\tif value, exist := u.userStore.Load(param.UserID); !exist {\n\t\terr = proto.ErrUserNotExists\n\t\treturn\n\t} else {\n\t\tuserInfo = value.(*proto.UserInfo)\n\t}\n\tuserInfo.Mu.Lock()\n\tdefer userInfo.Mu.Unlock()\n\tif userInfo.UserType == proto.UserTypeRoot {\n\t\terr = proto.ErrNoPermission\n\t\treturn\n\t}\n\tvar formerAK = userInfo.AccessKey\n\tvar akMark, skMark, typeMark, describeMark int\n\tif param.AccessKey != \"\" {\n\t\tif !proto.IsValidAK(param.AccessKey) {\n\t\t\terr = proto.ErrInvalidAccessKey\n\t\t\treturn\n\t\t}\n\t\tif _, exist := u.AKStore.Load(param.AccessKey); exist {\n\t\t\terr = proto.ErrDuplicateAccessKey\n\t\t\treturn\n\t\t}\n\t\takMark = 1\n\t}\n\tif param.SecretKey != \"\" {\n\t\tif !proto.IsValidSK(param.SecretKey) {\n\t\t\terr = proto.ErrInvalidSecretKey\n\t\t\treturn\n\t\t}\n\t\tskMark = 1\n\t}\n\t//Type == 0,do not modify type\n\tif param.Type != 0 {\n\t\tif param.Type.Valid() {\n\t\t\ttypeMark = 1\n\t\t} else {\n\t\t\terr = proto.ErrInvalidUserType\n\t\t\treturn\n\t\t}\n\t}\n\tif param.Description != \"\" {\n\t\tdescribeMark = 1\n\t}\n\n\tvar akUserBef *proto.AKUser\n\tvar akUserAft *proto.AKUser\n\n\tif value, exist := u.AKStore.Load(formerAK); exist {\n\t\takUserBef = value.(*proto.AKUser)\n\t} else {\n\t\terr = proto.ErrAccessKeyNotExists\n\t\treturn\n\t}\n\tif akMark == 1 {\n\t\tuserInfo.AccessKey = param.AccessKey\n\t}\n\tif skMark == 1 {\n\t\tuserInfo.SecretKey = param.SecretKey\n\t}\n\tif typeMark == 1 {\n\t\tuserInfo.UserType = param.Type\n\t}\n\tif describeMark == 1 {\n\t\tuserInfo.Description = param.Description\n\t}\n\n\tif len(strings.TrimSpace(param.Password)) != 0 {\n\t\takUserBef.Password = encodingPassword(param.Password)\n\t}\n\n\takUserAft = &proto.AKUser{AccessKey: userInfo.AccessKey, UserID: param.UserID, Password: akUserBef.Password}\n\n\tif err = u.syncUpdateUserInfo(userInfo); err != nil {\n\t\treturn\n\t}\n\tif err = u.syncDeleteAKUser(akUserBef); err != nil {\n\t\treturn\n\t}\n\tif err = u.syncAddAKUser(akUserAft); err != nil {\n\t\treturn\n\t}\n\tu.AKStore.Delete(formerAK)\n\tu.AKStore.Store(akUserAft.AccessKey, akUserAft)\n\n\tlog.LogInfof(\"action[updateUser], userID: %v, accesskey[%v], secretkey[%v]\", userInfo.UserID, userInfo.AccessKey, userInfo.SecretKey)\n\treturn\n}\n\nfunc (u *User) getKeyInfo(ak string) (userInfo *proto.UserInfo, err error) {\n\tvar akUser *proto.AKUser\n\tif akUser, err = u.getAKUser(ak); err != nil {\n\t\treturn\n\t}\n\tif userInfo, err = u.getUserInfo(akUser.UserID); err != nil {\n\t\treturn\n\t}\n\tlog.LogInfof(\"action[getKeyInfo], accesskey[%v]\", ak)\n\treturn\n}\n\nfunc (u *User) getUserInfo(userID string) (userInfo *proto.UserInfo, err error) {\n\tif value, exist := u.userStore.Load(userID); exist {\n\t\tuserInfo = value.(*proto.UserInfo)\n\t} else {\n\t\terr = proto.ErrUserNotExists\n\t\treturn\n\t}\n\tlog.LogInfof(\"action[getUserInfo], userID: %v\", userID)\n\treturn\n}\n\nfunc (u *User) updatePolicy(params *proto.UserPermUpdateParam) (userInfo *proto.UserInfo, err error) {\n\tif userInfo, err = u.getUserInfo(params.UserID); err != nil {\n\t\treturn\n\t}\n\tuserInfo.Mu.Lock()\n\tdefer userInfo.Mu.Unlock()\n\tif userInfo.Policy.IsOwn(params.Volume) {\n\t\terr = proto.ErrIsOwner\n\t\treturn\n\t}\n\tuserInfo.Policy.AddAuthorizedVol(params.Volume, params.Policy)\n\tif err = u.syncUpdateUserInfo(userInfo); err != nil {\n\t\terr = proto.ErrPersistenceByRaft\n\t\treturn\n\t}\n\tif err = u.addUserToVol(params.UserID, params.Volume); err != nil {\n\t\treturn\n\t}\n\tlog.LogInfof(\"action[updatePolicy], userID: %v, volume: %v\", params.UserID, params.Volume)\n\treturn\n}\n\nfunc (u *User) removePolicy(params *proto.UserPermRemoveParam) (userInfo *proto.UserInfo, err error) {\n\tif userInfo, err = u.getUserInfo(params.UserID); err != nil {\n\t\treturn\n\t}\n\tuserInfo.Mu.Lock()\n\tdefer userInfo.Mu.Unlock()\n\tif userInfo.Policy.IsOwn(params.Volume) {\n\t\terr = proto.ErrIsOwner\n\t\treturn\n\t}\n\tuserInfo.Policy.RemoveAuthorizedVol(params.Volume)\n\tif err = u.syncUpdateUserInfo(userInfo); err != nil {\n\t\terr = proto.ErrPersistenceByRaft\n\t\treturn\n\t}\n\tif err = u.removeUserFromVol(params.UserID, params.Volume); err != nil {\n\t\treturn\n\t}\n\tlog.LogInfof(\"action[removePolicy], userID: %v, volume: %v\", params.UserID, params.Volume)\n\treturn\n}\n\nfunc (u *User) addOwnVol(userID, volName string) (userInfo *proto.UserInfo, err error) {\n\tif userInfo, err = u.getUserInfo(userID); err != nil {\n\t\treturn\n\t}\n\tuserInfo.Mu.Lock()\n\tdefer userInfo.Mu.Unlock()\n\tuserInfo.Policy.AddOwnVol(volName)\n\tuserInfo.Policy.RemoveAuthorizedVol(volName)\n\tif err = u.syncUpdateUserInfo(userInfo); err != nil {\n\t\terr = proto.ErrPersistenceByRaft\n\t\treturn\n\t}\n\tif err = u.addUserToVol(userID, volName); err != nil {\n\t\treturn\n\t}\n\tlog.LogInfof(\"action[addOwnVol], userID: %v, volume: %v\", userID, volName)\n\treturn\n}\n\nfunc (u *User) removeOwnVol(userID, volName string) (userInfo *proto.UserInfo, err error) {\n\tif userInfo, err = u.getUserInfo(userID); err != nil {\n\t\treturn\n\t}\n\tuserInfo.Mu.Lock()\n\tdefer userInfo.Mu.Unlock()\n\tuserInfo.Policy.RemoveOwnVol(volName)\n\tif err = u.syncUpdateUserInfo(userInfo); err != nil {\n\t\terr = proto.ErrPersistenceByRaft\n\t\treturn\n\t}\n\tif err = u.removeUserFromVol(userID, volName); err != nil {\n\t\treturn\n\t}\n\tlog.LogInfof(\"action[removeOwnVol], userID: %v, volume: %v\", userID, volName)\n\treturn\n}\n\nfunc (u *User) deleteVolPolicy(volName string) (err error) {\n\tvar (\n\t\tvolUser  *proto.VolUser\n\t\tuserInfo *proto.UserInfo\n\t)\n\t//delete policy\n\tvar deletedUsers = make([]string, 0)\n\tvar userIDs []string\n\tif userIDs, err = u.getUsersOfVol(volName); err != nil {\n\t\treturn\n\t}\n\tfor _, userID := range userIDs {\n\t\tif userInfo, err = u.getUserInfo(userID); err != nil {\n\t\t\tif err == proto.ErrUserNotExists {\n\t\t\t\tdeletedUsers = append(deletedUsers, userID)\n\t\t\t\tlog.LogWarnf(\"action[deleteVolPolicy], userID: %v does not exist\", userID)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tuserInfo.Mu.Lock()\n\t\tuserInfo.Policy.RemoveOwnVol(volName)\n\t\tuserInfo.Policy.RemoveAuthorizedVol(volName)\n\t\tif err = u.syncUpdateUserInfo(userInfo); err != nil {\n\t\t\terr = proto.ErrPersistenceByRaft\n\t\t\tuserInfo.Mu.Unlock()\n\t\t\treturn\n\t\t}\n\t\tuserInfo.Mu.Unlock()\n\t}\n\t//delete volName index\n\tif value, exist := u.volUser.Load(volName); exist {\n\t\tvolUser = value.(*proto.VolUser)\n\t} else {\n\t\treturn nil\n\t}\n\tvolUser.Mu.Lock()\n\tif err = u.syncDeleteVolUser(volUser); err != nil {\n\t\tvolUser.Mu.Unlock()\n\t\treturn\n\t}\n\tu.volUser.Delete(volUser.Vol)\n\tvolUser.Mu.Unlock()\n\tfor _, deletedUser := range deletedUsers {\n\t\tu.removeUserFromAllVol(deletedUser)\n\t}\n\tlog.LogInfof(\"action[deleteVolPolicy], volName: %v\", volName)\n\treturn\n}\n\nfunc (u *User) transferVol(params *proto.UserTransferVolParam) (targetUserInfo *proto.UserInfo, err error) {\n\tvar userInfo *proto.UserInfo\n\tuserInfo, err = u.getUserInfo(params.UserSrc)\n\tif (err != nil && err != proto.ErrUserNotExists) || (!params.Force && err == proto.ErrUserNotExists) {\n\t\treturn\n\t}\n\tif err == nil {\n\t\tvar isOwned = userInfo.Policy.IsOwn(params.Volume)\n\t\tif !isOwned && !params.Force && params.UserSrc != params.UserDst {\n\t\t\terr = proto.ErrHaveNoPolicy\n\t\t\treturn\n\t\t}\n\t\tif isOwned {\n\t\t\tif _, err = u.removeOwnVol(params.UserSrc, params.Volume); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\tif targetUserInfo, err = u.addOwnVol(params.UserDst, params.Volume); err != nil {\n\t\treturn\n\t}\n\tlog.LogInfof(\"action[transferVol], volName: %v, userSrc: %v, userDst: %v\", params.Volume, params.UserSrc, params.UserDst)\n\treturn\n}\n\nfunc (u *User) getAllUserInfo(keywords string) (users []*proto.UserInfo) {\n\tusers = make([]*proto.UserInfo, 0)\n\tu.userStore.Range(func(key, value interface{}) bool {\n\t\tuserInfo := value.(*proto.UserInfo)\n\t\tif strings.Contains(userInfo.UserID, keywords) {\n\t\t\tusers = append(users, userInfo)\n\t\t}\n\t\treturn true\n\t})\n\tlog.LogInfof(\"action[getAllUserInfo], keywords: %v, total numbers: %v\", keywords, len(users))\n\treturn\n}\n\nfunc (u *User) getUsersOfVol(volName string) (userIDs []string, err error) {\n\tvar volUser *proto.VolUser\n\tuserIDs = make([]string, 0)\n\tif value, exist := u.volUser.Load(volName); exist {\n\t\tvolUser = value.(*proto.VolUser)\n\t} else {\n\t\terr = proto.ErrHaveNoPolicy\n\t\treturn\n\t}\n\tvolUser.Mu.RLock()\n\tdefer volUser.Mu.RUnlock()\n\tfor _, userID := range volUser.UserIDs {\n\t\tuserIDs = append(userIDs, userID)\n\t}\n\tlog.LogInfof(\"action[getUsersOfVol], vol: %v, user numbers: %v\", volName, len(userIDs))\n\treturn\n}\n\nfunc (u *User) getAKUser(ak string) (akUser *proto.AKUser, err error) {\n\tif value, exist := u.AKStore.Load(ak); exist {\n\t\takUser = value.(*proto.AKUser)\n\t} else {\n\t\terr = proto.ErrAccessKeyNotExists\n\t}\n\treturn\n}\n\nfunc (u *User) addUserToVol(userID, volName string) (err error) {\n\tu.volUserMutex.Lock()\n\tdefer u.volUserMutex.Unlock()\n\tvar (\n\t\tvolUser *proto.VolUser\n\t)\n\tif value, ok := u.volUser.Load(volName); ok {\n\t\tvolUser = value.(*proto.VolUser)\n\t\tvolUser.Mu.Lock()\n\t\tdefer volUser.Mu.Unlock()\n\t\tif contains(volUser.UserIDs, userID) {\n\t\t\treturn\n\t\t}\n\t\tvolUser.UserIDs = append(volUser.UserIDs, userID)\n\t} else {\n\t\tvolUser = &proto.VolUser{Vol: volName, UserIDs: []string{userID}}\n\t\tu.volUser.Store(volName, volUser)\n\t}\n\tif err = u.syncAddVolUser(volUser); err != nil {\n\t\terr = proto.ErrPersistenceByRaft\n\t\treturn\n\t}\n\treturn\n}\nfunc (u *User) removeUserFromVol(userID, volName string) (err error) {\n\tvar (\n\t\tvolUser *proto.VolUser\n\t)\n\tif value, ok := u.volUser.Load(volName); ok {\n\t\tvolUser = value.(*proto.VolUser)\n\t\tvolUser.Mu.Lock()\n\t\tdefer volUser.Mu.Unlock()\n\t\tvolUser.UserIDs, _ = removeString(volUser.UserIDs, userID)\n\t} else {\n\t\terr = proto.ErrHaveNoPolicy\n\t\treturn\n\t}\n\tif err = u.syncUpdateVolUser(volUser); err != nil {\n\t\terr = proto.ErrPersistenceByRaft\n\t\treturn\n\t}\n\treturn\n}\n\nfunc (u *User) removeUserFromAllVol(userID string) {\n\tu.volUser.Range(func(key, value interface{}) bool {\n\t\tvolUser := value.(*proto.VolUser)\n\t\tvolUser.Mu.Lock()\n\t\tvar exist bool\n\t\tvolUser.UserIDs, exist = removeString(volUser.UserIDs, userID)\n\t\tif exist {\n\t\t\tif err := u.syncUpdateVolUser(volUser); err != nil {\n\t\t\t\terr = proto.ErrPersistenceByRaft\n\t\t\t\tlog.LogErrorf(\"action[deleteUser], userID: %v, volUser: %v, err: %v\", userID, volUser, err)\n\t\t\t}\n\t\t}\n\t\tvolUser.Mu.Unlock()\n\t\treturn true\n\t})\n}\n\nfunc removeString(array []string, element string) ([]string, bool) {\n\tfor k, v := range array {\n\t\tif v == element {\n\t\t\treturn append(array[:k], array[k+1:]...), true\n\t\t}\n\t}\n\treturn array, false\n}\n\nfunc encodingPassword(s string) string {\n\tt := sha1.New()\n\tio.WriteString(t, s)\n\treturn hex.EncodeToString(t.Sum(nil))\n}\n\nfunc (u *User) clearUserStore() {\n\tu.userStore.Range(func(key, value interface{}) bool {\n\t\tu.userStore.Delete(key)\n\t\treturn true\n\t})\n}\n\nfunc (u *User) clearAKStore() {\n\tu.AKStore.Range(func(key, value interface{}) bool {\n\t\tu.AKStore.Delete(key)\n\t\treturn true\n\t})\n}\n\nfunc (u *User) clearVolUsers() {\n\tu.volUser.Range(func(key, value interface{}) bool {\n\t\tu.volUser.Delete(key)\n\t\treturn true\n\t})\n}\n"], "filenames": ["master/user.go"], "buggy_code_start_loc": [109], "buggy_code_end_loc": [110], "fixing_code_start_loc": [109], "fixing_code_end_loc": [110], "type": "CWE-532", "message": "CubeFS is an open-source cloud-native file storage system. CubeFS prior to version 3.3.1 was found to leak users secret keys and access keys in the logs in multiple components. When CubeCS creates new users, it leaks the users secret key. This could allow a lower-privileged user with access to the logs to retrieve sensitive information and impersonate other users with higher privileges than themselves. The issue has been patched in v3.3.1. There is no other mitigation than upgrading CubeFS.", "other": {"cve": {"id": "CVE-2023-46742", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-03T17:15:11.010", "lastModified": "2024-01-10T17:53:48.967", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "CubeFS is an open-source cloud-native file storage system. CubeFS prior to version 3.3.1 was found to leak users secret keys and access keys in the logs in multiple components. When CubeCS creates new users, it leaks the users secret key. This could allow a lower-privileged user with access to the logs to retrieve sensitive information and impersonate other users with higher privileges than themselves. The issue has been patched in v3.3.1. There is no other mitigation than upgrading CubeFS."}, {"lang": "es", "value": "CubeFS es un sistema de almacenamiento de archivos nativo de la nube de c\u00f3digo abierto. Se descubri\u00f3 que CubeFS anterior a la versi\u00f3n 3.3.1 filtraba claves secretas de usuarios y claves de acceso en los registros de m\u00faltiples componentes. Cuando CubeCS crea nuevos usuarios, filtra la clave secreta de los usuarios. Esto podr\u00eda permitir que un usuario con menos privilegios y acceso a los registros recupere informaci\u00f3n confidencial y se haga pasar por otros usuarios con mayores privilegios que \u00e9l. El problema se solucion\u00f3 en la versi\u00f3n 3.3.1. No hay otra mitigaci\u00f3n que actualizar CubeFS."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:R/S:U/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 4.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.3, "impactScore": 3.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-532"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:cubefs:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.3.1", "matchCriteriaId": "6E8D59D8-6863-4398-9D77-2442BAF81108"}]}]}], "references": [{"url": "https://github.com/cubefs/cubefs/commit/8dccce6ac8dff3db44d7e9074094c7303a5ff5dd", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/cubefs/cubefs/security/advisories/GHSA-vwch-g97w-hfg2", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/cubefs/cubefs/commit/8dccce6ac8dff3db44d7e9074094c7303a5ff5dd"}}