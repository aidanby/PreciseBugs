{"buggy_code": ["/**\n * The contents of this file are subject to the license and copyright\n * detailed in the LICENSE and NOTICE files at the root of the source\n * tree and available online at\n *\n * http://www.dspace.org/license/\n */\npackage org.dspace.content;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.UUID;\n\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.solr.client.solrj.util.ClientUtils;\nimport org.dspace.app.util.AuthorizeUtil;\nimport org.dspace.authorize.AuthorizeConfiguration;\nimport org.dspace.authorize.AuthorizeException;\nimport org.dspace.authorize.ResourcePolicy;\nimport org.dspace.authorize.service.AuthorizeService;\nimport org.dspace.authorize.service.ResourcePolicyService;\nimport org.dspace.content.dao.CollectionDAO;\nimport org.dspace.content.service.BitstreamService;\nimport org.dspace.content.service.CollectionService;\nimport org.dspace.content.service.CommunityService;\nimport org.dspace.content.service.ItemService;\nimport org.dspace.content.service.WorkspaceItemService;\nimport org.dspace.core.Constants;\nimport org.dspace.core.Context;\nimport org.dspace.core.I18nUtil;\nimport org.dspace.core.LogHelper;\nimport org.dspace.core.service.LicenseService;\nimport org.dspace.discovery.DiscoverQuery;\nimport org.dspace.discovery.DiscoverResult;\nimport org.dspace.discovery.IndexableObject;\nimport org.dspace.discovery.SearchService;\nimport org.dspace.discovery.SearchServiceException;\nimport org.dspace.discovery.indexobject.IndexableCollection;\nimport org.dspace.eperson.EPerson;\nimport org.dspace.eperson.Group;\nimport org.dspace.eperson.service.GroupService;\nimport org.dspace.eperson.service.SubscribeService;\nimport org.dspace.event.Event;\nimport org.dspace.harvest.HarvestedCollection;\nimport org.dspace.harvest.service.HarvestedCollectionService;\nimport org.dspace.identifier.IdentifierException;\nimport org.dspace.identifier.service.IdentifierService;\nimport org.dspace.services.ConfigurationService;\nimport org.dspace.workflow.factory.WorkflowServiceFactory;\nimport org.dspace.xmlworkflow.WorkflowConfigurationException;\nimport org.dspace.xmlworkflow.factory.XmlWorkflowFactory;\nimport org.dspace.xmlworkflow.state.Workflow;\nimport org.dspace.xmlworkflow.storedcomponents.CollectionRole;\nimport org.dspace.xmlworkflow.storedcomponents.service.CollectionRoleService;\nimport org.springframework.beans.factory.annotation.Autowired;\n\n/**\n * Service implementation for the Collection object.\n * This class is responsible for all business logic calls for the Collection object and is autowired by spring.\n * This class should never be accessed directly.\n *\n * @author kevinvandevelde at atmire.com\n */\npublic class CollectionServiceImpl extends DSpaceObjectServiceImpl<Collection> implements CollectionService {\n\n    /**\n     * log4j category\n     */\n    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(CollectionServiceImpl.class);\n\n    @Autowired(required = true)\n    protected CollectionDAO collectionDAO;\n\n    @Autowired(required = true)\n    protected AuthorizeService authorizeService;\n    @Autowired(required = true)\n    protected ResourcePolicyService resourcePolicyService;\n    @Autowired(required = true)\n    protected BitstreamService bitstreamService;\n    @Autowired(required = true)\n    protected ItemService itemService;\n    @Autowired(required = true)\n    protected CommunityService communityService;\n    @Autowired(required = true)\n    protected GroupService groupService;\n    @Autowired(required = true)\n    protected IdentifierService identifierService;\n\n    @Autowired(required = true)\n    protected LicenseService licenseService;\n    @Autowired(required = true)\n    protected SubscribeService subscribeService;\n    @Autowired(required = true)\n    protected WorkspaceItemService workspaceItemService;\n    @Autowired(required = true)\n    protected HarvestedCollectionService harvestedCollectionService;\n\n    @Autowired(required = true)\n    protected XmlWorkflowFactory workflowFactory;\n\n    @Autowired(required = true)\n    protected CollectionRoleService collectionRoleService;\n\n    @Autowired(required = true)\n    protected SearchService searchService;\n\n    @Autowired(required = true)\n    protected ConfigurationService configurationService;\n\n    protected CollectionServiceImpl() {\n        super();\n    }\n\n    @Override\n    public Collection create(Context context, Community community) throws SQLException, AuthorizeException {\n        return create(context, community, null);\n    }\n\n    @Override\n    public Collection create(Context context, Community community, String handle)\n            throws SQLException, AuthorizeException {\n        return create(context, community, handle, null);\n    }\n\n    @Override\n    public Collection create(Context context, Community community,\n                             String handle, UUID uuid) throws SQLException, AuthorizeException {\n        if (community == null) {\n            throw new IllegalArgumentException(\"Community cannot be null when creating a new collection.\");\n        }\n\n        Collection newCollection;\n        if (uuid != null) {\n            newCollection = collectionDAO.create(context, new Collection(uuid));\n        }  else {\n            newCollection = collectionDAO.create(context, new Collection());\n        }\n        //Add our newly created collection to our community, authorization checks occur in THIS method\n        communityService.addCollection(context, community, newCollection);\n\n        // create the default authorization policy for collections\n        // of 'anonymous' READ\n        Group anonymousGroup = groupService.findByName(context, Group.ANONYMOUS);\n\n\n        authorizeService.createResourcePolicy(context, newCollection, anonymousGroup, null, Constants.READ, null);\n        // now create the default policies for submitted items\n        authorizeService\n                .createResourcePolicy(context, newCollection, anonymousGroup, null, Constants.DEFAULT_ITEM_READ, null);\n        authorizeService\n                .createResourcePolicy(context, newCollection, anonymousGroup, null,\n                        Constants.DEFAULT_BITSTREAM_READ, null);\n\n        collectionDAO.save(context, newCollection);\n\n        //Update our collection so we have a collection identifier\n        try {\n            if (handle == null) {\n                identifierService.register(context, newCollection);\n            } else {\n                identifierService.register(context, newCollection, handle);\n            }\n        } catch (IllegalStateException | IdentifierException ex) {\n            throw new IllegalStateException(ex);\n        }\n\n        context.addEvent(new Event(Event.CREATE, Constants.COLLECTION,\n                newCollection.getID(), newCollection.getHandle(),\n                getIdentifiers(context, newCollection)));\n\n        log.info(LogHelper.getHeader(context, \"create_collection\",\n                \"collection_id=\" + newCollection.getID())\n                + \",handle=\" + newCollection.getHandle());\n\n        return newCollection;\n    }\n\n    @Override\n    public List<Collection> findAll(Context context) throws SQLException {\n        MetadataField nameField = metadataFieldService.findByElement(context, MetadataSchemaEnum.DC.getName(),\n                                                                     \"title\", null);\n        if (nameField == null) {\n            throw new IllegalArgumentException(\n                \"Required metadata field '\" + MetadataSchemaEnum.DC.getName() + \".title' doesn't exist!\");\n        }\n\n        return collectionDAO.findAll(context, nameField);\n    }\n\n    @Override\n    public List<Collection> findAll(Context context, Integer limit, Integer offset) throws SQLException {\n        MetadataField nameField = metadataFieldService.findByElement(context, MetadataSchemaEnum.DC.getName(),\n                                                                     \"title\", null);\n        if (nameField == null) {\n            throw new IllegalArgumentException(\n                \"Required metadata field '\" + MetadataSchemaEnum.DC.getName() + \".title' doesn't exist!\");\n        }\n\n        return collectionDAO.findAll(context, nameField, limit, offset);\n    }\n\n    @Override\n    public List<Collection> findAuthorizedOptimized(Context context, int actionID) throws SQLException {\n        if (!configurationService\n            .getBooleanProperty(\"org.dspace.content.Collection.findAuthorizedPerformanceOptimize\", false)) {\n            // Fallback to legacy query if config says so. The rationale could be that a site found a bug.\n            return findAuthorized(context, null, actionID);\n        }\n\n        List<Collection> myResults = new ArrayList<>();\n\n        if (authorizeService.isAdmin(context)) {\n            return findAll(context);\n        }\n\n        //Check eperson->policy\n        List<Collection> directToCollection = findDirectMapped(context, actionID);\n        for (int i = 0; i < directToCollection.size(); i++) {\n            if (!myResults.contains(directToCollection.get(i))) {\n                myResults.add(directToCollection.get(i));\n            }\n        }\n\n        //Check eperson->groups->policy\n        List<Collection> groupToCollection = findGroupMapped(context, actionID);\n\n        for (Collection aGroupToCollection : groupToCollection) {\n            if (!myResults.contains(aGroupToCollection)) {\n                myResults.add(aGroupToCollection);\n            }\n        }\n\n        //Check eperson->groups->groups->policy->collection\n        //i.e. Malcolm Litchfield is a member of OSU_Press_Embargo,\n        // which is a member of: COLLECTION_24_ADMIN, COLLECTION_24_SUBMIT\n        List<Collection> group2GroupToCollection = findGroup2GroupMapped(context, actionID);\n\n        for (Collection aGroup2GroupToCollection : group2GroupToCollection) {\n            if (!myResults.contains(aGroup2GroupToCollection)) {\n                myResults.add(aGroup2GroupToCollection);\n            }\n        }\n\n        //TODO Check eperson->groups->groups->policy->community\n\n\n        //TODO Check eperson->groups->policy->community\n        // i.e. Typical Community Admin -- name.# > COMMUNITY_10_ADMIN > Ohio State University Press\n\n        //Check eperson->comm-admin\n        List<Collection> group2commCollections = findGroup2CommunityMapped(context);\n        for (Collection group2commCollection : group2commCollections) {\n            if (!myResults.contains(group2commCollection)) {\n                myResults.add(group2commCollection);\n            }\n        }\n\n\n        // Return the collections, sorted alphabetically\n        Collections.sort(myResults, new CollectionNameComparator());\n\n        return myResults;\n    }\n\n    @Override\n    public List<Collection> findDirectMapped(Context context, int actionID) throws SQLException {\n        return collectionDAO\n            .findAuthorized(context, context.getCurrentUser(), Arrays.asList(Constants.ADD, Constants.ADMIN));\n    }\n\n    @Override\n    public List<Collection> findGroup2CommunityMapped(Context context) throws SQLException {\n        List<Community> communities = communityService\n            .findAuthorizedGroupMapped(context, Arrays.asList(Constants.ADD, Constants.ADMIN));\n        List<Collection> collections = new ArrayList<>();\n        for (Community community : communities) {\n            collections.addAll(community.getCollections());\n        }\n        return collections;\n    }\n\n    @Override\n    public List<Collection> findGroup2GroupMapped(Context context, int actionID) throws SQLException {\n        return collectionDAO\n            .findAuthorizedByGroup(context, context.getCurrentUser(), Collections.singletonList(actionID));\n    }\n\n    @Override\n    public List<Collection> findGroupMapped(Context context, int actionID) throws SQLException {\n        List<Community> communities = communityService\n            .findAuthorized(context, Arrays.asList(Constants.ADD, Constants.ADMIN));\n        List<Collection> collections = new ArrayList<>();\n        for (Community community : communities) {\n            collections.addAll(community.getCollections());\n        }\n        return collections;\n    }\n\n    @Override\n    public Collection find(Context context, UUID id) throws SQLException {\n        return collectionDAO.findByID(context, Collection.class, id);\n    }\n\n    @Override\n    public void setMetadataSingleValue(Context context, Collection collection,\n            MetadataFieldName field, String language, String value)\n            throws MissingResourceException, SQLException {\n        if (field.equals(MD_NAME) && (value == null || value.trim().equals(\"\"))) {\n            try {\n                value = I18nUtil.getMessage(\"org.dspace.content.untitled\");\n            } catch (MissingResourceException e) {\n                value = \"Untitled\";\n            }\n        }\n\n        /*\n         * Set metadata field to null if null\n         * and trim strings to eliminate excess\n         * whitespace.\n         */\n        if (value == null) {\n            clearMetadata(context, collection, field.schema, field.element, field.qualifier, Item.ANY);\n            collection.setMetadataModified();\n        } else {\n            super.setMetadataSingleValue(context, collection, field, null, value);\n        }\n\n        collection.addDetails(field.toString());\n    }\n\n    @Override\n    public Bitstream setLogo(Context context, Collection collection, InputStream is)\n        throws AuthorizeException, IOException, SQLException {\n        // Check authorisation\n        // authorized to remove the logo when DELETE rights\n        // authorized when canEdit\n        if (!((is == null) && authorizeService.authorizeActionBoolean(\n            context, collection, Constants.DELETE))) {\n            canEdit(context, collection, true);\n        }\n\n        // First, delete any existing logo\n        if (collection.getLogo() != null) {\n            bitstreamService.delete(context, collection.getLogo());\n        }\n\n        if (is == null) {\n            collection.setLogo(null);\n            log.info(LogHelper.getHeader(context, \"remove_logo\",\n                                          \"collection_id=\" + collection.getID()));\n        } else {\n            Bitstream newLogo = bitstreamService.create(context, is);\n            collection.setLogo(newLogo);\n\n            // now create policy for logo bitstream\n            // to match our READ policy\n            List<ResourcePolicy> policies = authorizeService\n                .getPoliciesActionFilter(context, collection, Constants.READ);\n            authorizeService.addPolicies(context, policies, newLogo);\n\n            log.info(LogHelper.getHeader(context, \"set_logo\",\n                                          \"collection_id=\" + collection.getID() + \"logo_bitstream_id=\"\n                                              + newLogo.getID()));\n        }\n\n        collection.setModified();\n        return collection.getLogo();\n    }\n\n    @Override\n    public Group createWorkflowGroup(Context context, Collection collection, int step)\n        throws SQLException, AuthorizeException {\n        // Check authorisation - Must be an Admin to create Workflow Group\n        AuthorizeUtil.authorizeManageWorkflowsGroup(context, collection);\n\n        if (getWorkflowGroup(context, collection, step) == null) {\n            //turn off authorization so that Collection Admins can create Collection Workflow Groups\n            context.turnOffAuthorisationSystem();\n            Group g = groupService.create(context);\n            groupService.setName(g,\n                                 \"COLLECTION_\" + collection.getID() + \"_WORKFLOW_STEP_\" + step);\n            groupService.update(context, g);\n            context.restoreAuthSystemState();\n            setWorkflowGroup(context, collection, step, g);\n        }\n\n        return getWorkflowGroup(context, collection, step);\n    }\n\n    @Override\n    public void setWorkflowGroup(Context context, Collection collection, int step, Group group)\n        throws SQLException {\n        Workflow workflow = null;\n        try {\n            workflow = workflowFactory.getWorkflow(collection);\n        } catch (WorkflowConfigurationException e) {\n            log.error(LogHelper.getHeader(context, \"setWorkflowGroup\",\n                    \"collection_id=\" + collection.getID() + \" \" + e.getMessage()), e);\n        }\n        if (!StringUtils.equals(workflowFactory.getDefaultWorkflow().getID(), workflow.getID())) {\n            throw new IllegalArgumentException(\n                    \"setWorkflowGroup can be used only on collection with the default basic dspace workflow. \"\n                    + \"Instead, the collection: \"\n                            + collection.getID() + \" has the workflow: \" + workflow.getID());\n        }\n        String roleId;\n\n        switch (step) {\n            case 1:\n                roleId = CollectionRoleService.LEGACY_WORKFLOW_STEP1_NAME;\n                break;\n            case 2:\n                roleId = CollectionRoleService.LEGACY_WORKFLOW_STEP2_NAME;\n                break;\n            case 3:\n                roleId = CollectionRoleService.LEGACY_WORKFLOW_STEP3_NAME;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal step count: \" + step);\n        }\n\n        CollectionRole colRole = collectionRoleService.find(context, collection, roleId);\n        if (colRole == null) {\n            if (group != null) {\n                colRole = collectionRoleService.create(context, collection, roleId, group);\n            }\n        } else {\n            if (group != null) {\n                colRole.setGroup(group);\n                collectionRoleService.update(context, colRole);\n            } else {\n                collectionRoleService.delete(context, colRole);\n            }\n        }\n        collection.setModified();\n    }\n\n    @Override\n    public Group getWorkflowGroup(Context context, Collection collection, int step) {\n        String roleId;\n\n        switch (step) {\n            case 1:\n                roleId = CollectionRoleService.LEGACY_WORKFLOW_STEP1_NAME;\n                break;\n            case 2:\n                roleId = CollectionRoleService.LEGACY_WORKFLOW_STEP2_NAME;\n                break;\n            case 3:\n                roleId = CollectionRoleService.LEGACY_WORKFLOW_STEP3_NAME;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal step count: \" + step);\n        }\n\n        CollectionRole colRole;\n        try {\n            colRole = collectionRoleService.find(context, collection, roleId);\n            if (colRole != null) {\n                return colRole.getGroup();\n            }\n            return null;\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public Group createSubmitters(Context context, Collection collection) throws SQLException, AuthorizeException {\n        // Check authorisation - Must be an Admin to create Submitters Group\n        AuthorizeUtil.authorizeManageSubmittersGroup(context, collection);\n\n        Group submitters = collection.getSubmitters();\n        if (submitters == null) {\n            //turn off authorization so that Collection Admins can create Collection Submitters\n            context.turnOffAuthorisationSystem();\n            submitters = groupService.create(context);\n            context.restoreAuthSystemState();\n\n            groupService.setName(submitters,\n                                 \"COLLECTION_\" + collection.getID() + \"_SUBMIT\");\n            groupService.update(context, submitters);\n        }\n\n        // register this as the submitter group\n        collection.setSubmitters(submitters);\n\n        authorizeService.addPolicy(context, collection, Constants.ADD, submitters);\n\n        return submitters;\n    }\n\n    @Override\n    public void removeSubmitters(Context context, Collection collection) throws SQLException, AuthorizeException {\n        // Check authorisation - Must be an Admin to delete Submitters Group\n        AuthorizeUtil.authorizeManageSubmittersGroup(context, collection);\n\n        // just return if there is no administrative group.\n        if (collection.getSubmitters() == null) {\n            return;\n        }\n\n        // Remove the link to the collection table.\n        collection.setSubmitters(null);\n    }\n\n    @Override\n    public Group createAdministrators(Context context, Collection collection) throws SQLException, AuthorizeException {\n        // Check authorisation - Must be an Admin to create more Admins\n        AuthorizeUtil.authorizeManageAdminGroup(context, collection);\n\n        Group admins = collection.getAdministrators();\n        if (admins == null) {\n            //turn off authorization so that Community Admins can create Collection Admins\n            context.turnOffAuthorisationSystem();\n            admins = groupService.create(context);\n            context.restoreAuthSystemState();\n\n            groupService.setName(admins, \"COLLECTION_\" + collection.getID() + \"_ADMIN\");\n            groupService.update(context, admins);\n        }\n\n        authorizeService.addPolicy(context, collection,\n                                   Constants.ADMIN, admins);\n\n        // register this as the admin group\n        collection.setAdmins(admins);\n        context.addEvent(new Event(Event.MODIFY, Constants.COLLECTION, collection.getID(),\n                                              null, getIdentifiers(context, collection)));\n        return admins;\n    }\n\n    @Override\n    public void removeAdministrators(Context context, Collection collection) throws SQLException, AuthorizeException {\n        // Check authorisation - Must be an Admin of the parent community to delete Admin Group\n        AuthorizeUtil.authorizeRemoveAdminGroup(context, collection);\n\n        Group admins = collection.getAdministrators();\n        // just return if there is no administrative group.\n        if (admins == null) {\n            return;\n        }\n\n        // Remove the link to the collection table.\n        collection.setAdmins(null);\n        context.addEvent(new Event(Event.MODIFY, Constants.COLLECTION, collection.getID(),\n                                              null, getIdentifiers(context, collection)));\n    }\n\n    @Override\n    public String getLicense(Collection collection) {\n        String license = getMetadataFirstValue(collection, CollectionService.MD_LICENSE, Item.ANY);\n\n        if (license == null || license.trim().equals(\"\")) {\n            // Fallback to site-wide default\n            license = licenseService.getDefaultSubmissionLicense();\n        }\n\n        return license;\n    }\n\n    @Override\n    public boolean hasCustomLicense(Collection collection) {\n        String license = collection.getLicenseCollection();\n        return StringUtils.isNotBlank(license);\n    }\n\n    @Override\n    public void createTemplateItem(Context context, Collection collection) throws SQLException, AuthorizeException {\n        // Check authorisation\n        AuthorizeUtil.authorizeManageTemplateItem(context, collection);\n\n        if (collection.getTemplateItem() == null) {\n            Item template = itemService.createTemplateItem(context, collection);\n            collection.setTemplateItem(template);\n\n            log.info(LogHelper.getHeader(context, \"create_template_item\",\n                                          \"collection_id=\" + collection.getID() + \",template_item_id=\"\n                                              + template.getID()));\n        }\n    }\n\n    @Override\n    public void removeTemplateItem(Context context, Collection collection)\n        throws SQLException, AuthorizeException, IOException {\n        // Check authorisation\n        AuthorizeUtil.authorizeManageTemplateItem(context, collection);\n\n        Item template = collection.getTemplateItem();\n\n        if (template != null) {\n            log.info(LogHelper.getHeader(context, \"remove_template_item\",\n                                          \"collection_id=\" + collection.getID() + \",template_item_id=\"\n                                              + template.getID()));\n            // temporarily turn off auth system, we have already checked the permission on the top of the method\n            // check it again will fail because we have already broken the relation between the collection and the item\n            context.turnOffAuthorisationSystem();\n            collection.setTemplateItem(null);\n            itemService.delete(context, template);\n            context.restoreAuthSystemState();\n        }\n\n        context.addEvent(new Event(Event.MODIFY, Constants.COLLECTION,\n                                   collection.getID(), \"remove_template_item\", getIdentifiers(context, collection)));\n    }\n\n    @Override\n    public void addItem(Context context, Collection collection, Item item) throws SQLException, AuthorizeException {\n        // Check authorisation\n        authorizeService.authorizeAction(context, collection, Constants.ADD);\n\n        log.info(LogHelper.getHeader(context, \"add_item\", \"collection_id=\"\n            + collection.getID() + \",item_id=\" + item.getID()));\n\n        // Create mapping\n        // We do NOT add the item to the collection template since we would have to load in all our items\n        // Instead we add the collection to an item which works in the same way.\n        if (!item.getCollections().contains(collection)) {\n            item.addCollection(collection);\n        }\n\n        context.addEvent(new Event(Event.ADD, Constants.COLLECTION, collection.getID(),\n                                   Constants.ITEM, item.getID(), item.getHandle(),\n                                   getIdentifiers(context, collection)));\n    }\n\n    @Override\n    public void removeItem(Context context, Collection collection, Item item)\n        throws SQLException, AuthorizeException, IOException {\n        // Check authorisation\n        authorizeService.authorizeAction(context, collection, Constants.REMOVE);\n\n        //Check if we orphaned our poor item\n        if (item.getCollections().size() == 1) {\n            // Orphan; delete it\n            itemService.delete(context, item);\n        } else {\n            //Remove the item from the collection if we have multiple collections\n            item.removeCollection(collection);\n\n        }\n\n        context.addEvent(new Event(Event.REMOVE, Constants.COLLECTION,\n                                   collection.getID(), Constants.ITEM, item.getID(), item.getHandle(),\n                                   getIdentifiers(context, collection)));\n    }\n\n    @Override\n    public void update(Context context, Collection collection) throws SQLException, AuthorizeException {\n        // Check authorisation\n        canEdit(context, collection, true);\n\n        log.info(LogHelper.getHeader(context, \"update_collection\",\n                                      \"collection_id=\" + collection.getID()));\n\n        super.update(context, collection);\n        collectionDAO.save(context, collection);\n\n        if (collection.isModified()) {\n            context.addEvent(new Event(Event.MODIFY, Constants.COLLECTION,\n                                       collection.getID(), null, getIdentifiers(context, collection)));\n            collection.clearModified();\n        }\n        if (collection.isMetadataModified()) {\n            context.addEvent(new Event(Event.MODIFY_METADATA, Constants.COLLECTION, collection.getID(),\n                                         collection.getDetails(),getIdentifiers(context, collection)));\n            collection.clearModified();\n        }\n        collection.clearDetails();\n    }\n\n    @Override\n    public boolean canEditBoolean(Context context, Collection collection) throws SQLException {\n        return canEditBoolean(context, collection, true);\n    }\n\n    @Override\n    public boolean canEditBoolean(Context context, Collection collection, boolean useInheritance) throws SQLException {\n        try {\n            canEdit(context, collection, useInheritance);\n\n            return true;\n        } catch (AuthorizeException e) {\n            return false;\n        }\n    }\n\n    @Override\n    public void canEdit(Context context, Collection collection) throws SQLException, AuthorizeException {\n        canEdit(context, collection, true);\n    }\n\n    @Override\n    public void canEdit(Context context, Collection collection, boolean useInheritance)\n        throws SQLException, AuthorizeException {\n        List<Community> parents = communityService.getAllParents(context, collection);\n        for (Community parent : parents) {\n            if (authorizeService.authorizeActionBoolean(context, parent,\n                                                        Constants.WRITE, useInheritance)) {\n                return;\n            }\n\n            if (authorizeService.authorizeActionBoolean(context, parent,\n                                                        Constants.ADD, useInheritance)) {\n                return;\n            }\n        }\n        authorizeService.authorizeAction(context, collection, Constants.WRITE, useInheritance);\n    }\n\n    @Override\n    public void delete(Context context, Collection collection) throws SQLException, AuthorizeException, IOException {\n        log.info(LogHelper.getHeader(context, \"delete_collection\",\n                                      \"collection_id=\" + collection.getID()));\n\n        // remove harvested collections.\n        HarvestedCollection hc = harvestedCollectionService.find(context, collection);\n        if (hc != null) {\n            harvestedCollectionService.delete(context, hc);\n        }\n\n        context.addEvent(new Event(Event.DELETE, Constants.COLLECTION,\n                                   collection.getID(), collection.getHandle(), getIdentifiers(context, collection)));\n\n        // remove subscriptions - hmm, should this be in Subscription.java?\n        subscribeService.deleteByCollection(context, collection);\n\n        // Remove Template Item\n        removeTemplateItem(context, collection);\n\n        // Remove items\n        // Remove items\n        Iterator<Item> items = itemService.findAllByCollection(context, collection);\n        while (items.hasNext()) {\n            Item item = items.next();\n//            items.remove();\n            if (itemService.isOwningCollection(item, collection)) {\n                // the collection to be deleted is the owning collection, thus remove\n                // the item from all collections it belongs to\n                itemService.delete(context, item);\n            } else {\n                // the item was only mapped to this collection, so just remove it\n                removeItem(context, collection, item);\n            }\n        }\n\n\n        // Delete bitstream logo\n        setLogo(context, collection, null);\n\n        Iterator<WorkspaceItem> workspaceItems = workspaceItemService.findByCollection(context, collection).iterator();\n        while (workspaceItems.hasNext()) {\n            WorkspaceItem workspaceItem = workspaceItems.next();\n            workspaceItems.remove();\n            workspaceItemService.deleteAll(context, workspaceItem);\n        }\n\n\n        WorkflowServiceFactory.getInstance().getWorkflowService().deleteCollection(context, collection);\n        WorkflowServiceFactory.getInstance().getWorkflowItemService().deleteByCollection(context, collection);\n\n        //  get rid of the content count cache if it exists\n        // Remove any Handle\n        handleService.unbindHandle(context, collection);\n\n        // Remove any workflow roles\n        collectionRoleService.deleteByCollection(context, collection);\n\n        collection.getResourcePolicies().clear();\n\n        // Remove default administrators group\n        Group g = collection.getAdministrators();\n\n        if (g != null) {\n            collection.setAdmins(null);\n            groupService.delete(context, g);\n        }\n\n        // Remove default submitters group\n        g = collection.getSubmitters();\n\n        if (g != null) {\n            collection.setSubmitters(null);\n            groupService.delete(context, g);\n        }\n\n        Iterator<Community> owningCommunities = collection.getCommunities().iterator();\n        while (owningCommunities.hasNext()) {\n            Community owningCommunity = owningCommunities.next();\n            collection.removeCommunity(owningCommunity);\n            owningCommunity.removeCollection(collection);\n        }\n\n        collectionDAO.delete(context, collection);\n    }\n\n    @Override\n    public int getSupportsTypeConstant() {\n        return Constants.COLLECTION;\n    }\n\n    @Override\n    public List<Collection> findAuthorized(Context context, Community community, int actionID) throws SQLException {\n        List<Collection> myResults = new ArrayList<>();\n\n        List<Collection> myCollections;\n\n        if (community != null) {\n            myCollections = community.getCollections();\n        } else {\n            myCollections = findAll(context);\n        }\n\n        // now build a list of collections you have authorization for\n        for (Collection myCollection : myCollections) {\n            if (authorizeService.authorizeActionBoolean(context,\n                                                        myCollection, actionID)) {\n                myResults.add(myCollection);\n            }\n        }\n        return myResults;\n    }\n\n    @Override\n    public Collection findByGroup(Context context, Group group) throws SQLException {\n        return collectionDAO.findByGroup(context, group);\n    }\n\n    @Override\n    public List<Collection> findCollectionsWithSubscribers(Context context) throws SQLException {\n        return collectionDAO.findCollectionsWithSubscribers(context);\n    }\n\n    @Override\n    public DSpaceObject getAdminObject(Context context, Collection collection, int action) throws SQLException {\n        DSpaceObject adminObject = null;\n        Community community = null;\n        List<Community> communities = collection.getCommunities();\n        if (CollectionUtils.isNotEmpty(communities)) {\n            community = communities.get(0);\n        }\n\n        switch (action) {\n            case Constants.REMOVE:\n                if (AuthorizeConfiguration.canCollectionAdminPerformItemDeletion()) {\n                    adminObject = collection;\n                } else if (AuthorizeConfiguration.canCommunityAdminPerformItemDeletion()) {\n                    adminObject = community;\n                }\n                break;\n\n            case Constants.DELETE:\n                if (AuthorizeConfiguration.canCommunityAdminPerformSubelementDeletion()) {\n                    adminObject = community;\n                }\n                break;\n            default:\n                adminObject = collection;\n                break;\n        }\n        return adminObject;\n    }\n\n    @Override\n    public DSpaceObject getParentObject(Context context, Collection collection) throws SQLException {\n        List<Community> communities = collection.getCommunities();\n        if (CollectionUtils.isNotEmpty(communities)) {\n            return communities.get(0);\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public void updateLastModified(Context context, Collection collection) throws SQLException, AuthorizeException {\n        //Also fire a modified event since the collection HAS been modified\n        context.addEvent(new Event(Event.MODIFY, Constants.COLLECTION,\n                                   collection.getID(), null, getIdentifiers(context, collection)));\n    }\n\n    @Override\n    public Collection findByIdOrLegacyId(Context context, String id) throws SQLException {\n        if (StringUtils.isNumeric(id)) {\n            return findByLegacyId(context, Integer.parseInt(id));\n        } else {\n            return find(context, UUID.fromString(id));\n        }\n    }\n\n    @Override\n    public Collection findByLegacyId(Context context, int id) throws SQLException {\n        return collectionDAO.findByLegacyId(context, id, Collection.class);\n    }\n\n    @Override\n    public int countTotal(Context context) throws SQLException {\n        return collectionDAO.countRows(context);\n    }\n\n    @Override\n    public List<Map.Entry<Collection, Long>> getCollectionsWithBitstreamSizesTotal(Context context)\n        throws SQLException {\n        return collectionDAO.getCollectionsWithBitstreamSizesTotal(context);\n    }\n\n    @Override\n    public Group createDefaultReadGroup(Context context, Collection collection, String typeOfGroupString,\n                                        int defaultRead)\n        throws SQLException, AuthorizeException {\n        Group role = groupService.create(context);\n        groupService.setName(role, \"COLLECTION_\" + collection.getID().toString() + \"_\" + typeOfGroupString +\n            \"_DEFAULT_READ\");\n\n        // Remove existing privileges from the anonymous group.\n        authorizeService.removePoliciesActionFilter(context, collection, defaultRead);\n\n        // Grant our new role the default privileges.\n        authorizeService.addPolicy(context, collection, defaultRead, role);\n        groupService.update(context, role);\n        return role;\n    }\n\n    @Override\n    public List<Collection> findCollectionsWithSubmit(String q, Context context, Community community,\n        int offset, int limit) throws SQLException, SearchServiceException {\n\n        List<Collection> collections = new ArrayList<>();\n        DiscoverQuery discoverQuery = new DiscoverQuery();\n        discoverQuery.setDSpaceObjectFilter(IndexableCollection.TYPE);\n        discoverQuery.setStart(offset);\n        discoverQuery.setMaxResults(limit);\n        DiscoverResult resp = retrieveCollectionsWithSubmit(context, discoverQuery, null, community, q);\n        for (IndexableObject solrCollections : resp.getIndexableObjects()) {\n            Collection c = ((IndexableCollection) solrCollections).getIndexedObject();\n            collections.add(c);\n        }\n        return collections;\n    }\n\n    @Override\n    public int countCollectionsWithSubmit(String q, Context context, Community community)\n        throws SQLException, SearchServiceException {\n\n        DiscoverQuery discoverQuery = new DiscoverQuery();\n        discoverQuery.setMaxResults(0);\n        discoverQuery.setDSpaceObjectFilter(IndexableCollection.TYPE);\n        DiscoverResult resp = retrieveCollectionsWithSubmit(context, discoverQuery, null, community, q);\n        return (int)resp.getTotalSearchResults();\n    }\n\n    /**\n     * Finds all Indexed Collections where the current user has submit rights. If the user is an Admin,\n     * this is all Indexed Collections. Otherwise, it includes those collections where\n     * an indexed \"submit\" policy lists either the eperson or one of the eperson's groups\n     *\n     * @param context                    DSpace context\n     * @param discoverQuery\n     * @param entityType                 limit the returned collection to those related to given entity type\n     * @param community                  parent community, could be null\n     * @param q                          limit the returned collection to those with metadata values matching the query\n     *                                   terms. The terms are used to make also a prefix query on SOLR\n     *                                   so it can be used to implement an autosuggest feature over the collection name\n     * @return                           discovery search result objects\n     * @throws SQLException              if something goes wrong\n     * @throws SearchServiceException    if search error\n     */\n    private DiscoverResult retrieveCollectionsWithSubmit(Context context, DiscoverQuery discoverQuery,\n        String entityType, Community community, String q)\n        throws SQLException, SearchServiceException {\n\n        StringBuilder query = new StringBuilder();\n        EPerson currentUser = context.getCurrentUser();\n        if (!authorizeService.isAdmin(context)) {\n            String userId = \"\";\n            if (currentUser != null) {\n                userId = currentUser.getID().toString();\n            }\n            query.append(\"submit:(e\").append(userId);\n\n            Set<Group> groups = groupService.allMemberGroupsSet(context, currentUser);\n            for (Group group : groups) {\n                query.append(\" OR g\").append(group.getID());\n            }\n            query.append(\")\");\n            discoverQuery.addFilterQueries(query.toString());\n        }\n        if (Objects.nonNull(community)) {\n            discoverQuery.addFilterQueries(\"location.comm:\" + community.getID().toString());\n        }\n        if (StringUtils.isNotBlank(entityType)) {\n            discoverQuery.addFilterQueries(\"search.entitytype:\" + entityType);\n        }\n        if (StringUtils.isNotBlank(q)) {\n            StringBuilder buildQuery = new StringBuilder();\n            String escapedQuery = ClientUtils.escapeQueryChars(q);\n            buildQuery.append(escapedQuery).append(\" OR \").append(escapedQuery).append(\"*\");\n            discoverQuery.setQuery(buildQuery.toString());\n        }\n        DiscoverResult resp = searchService.search(context, discoverQuery);\n        return resp;\n    }\n\n    @Override\n    public List<Collection> findCollectionsWithSubmit(String q, Context context, Community community, String entityType,\n            int offset, int limit) throws SQLException, SearchServiceException {\n        List<Collection> collections = new ArrayList<>();\n        DiscoverQuery discoverQuery = new DiscoverQuery();\n        discoverQuery.setDSpaceObjectFilter(IndexableCollection.TYPE);\n        discoverQuery.setStart(offset);\n        discoverQuery.setMaxResults(limit);\n        DiscoverResult resp = retrieveCollectionsWithSubmit(context, discoverQuery,\n                entityType, community, q);\n        for (IndexableObject solrCollections : resp.getIndexableObjects()) {\n            Collection c = ((IndexableCollection) solrCollections).getIndexedObject();\n            collections.add(c);\n        }\n        return collections;\n    }\n\n    @Override\n    public int countCollectionsWithSubmit(String q, Context context, Community community, String entityType)\n            throws SQLException, SearchServiceException {\n        DiscoverQuery discoverQuery = new DiscoverQuery();\n        discoverQuery.setMaxResults(0);\n        discoverQuery.setDSpaceObjectFilter(IndexableCollection.TYPE);\n        DiscoverResult resp = retrieveCollectionsWithSubmit(context, discoverQuery, entityType, community, q);\n        return (int) resp.getTotalSearchResults();\n    }\n\n}\n", "/**\n * The contents of this file are subject to the license and copyright\n * detailed in the LICENSE and NOTICE files at the root of the source\n * tree and available online at\n *\n * http://www.dspace.org/license/\n */\npackage org.dspace.content.service;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.sql.SQLException;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.UUID;\n\nimport org.dspace.authorize.AuthorizeException;\nimport org.dspace.content.Bitstream;\nimport org.dspace.content.Collection;\nimport org.dspace.content.Community;\nimport org.dspace.content.Item;\nimport org.dspace.core.Context;\nimport org.dspace.discovery.SearchServiceException;\nimport org.dspace.eperson.Group;\n\n/**\n * Service interface class for the Collection object.\n * The implementation of this class is responsible for all business logic calls\n * for the Collection object and is autowired by Spring.\n *\n * @author kevinvandevelde at atmire.com\n */\npublic interface CollectionService\n        extends DSpaceObjectService<Collection>, DSpaceObjectLegacySupportService<Collection> {\n\n    /**\n     * Create a new collection with a new ID.\n     * Once created the collection is added to the given community\n     *\n     * @param context   DSpace context object\n     * @param community DSpace Community (parent)\n     * @return the newly created collection\n     * @throws SQLException       if database error\n     * @throws AuthorizeException if authorization error\n     */\n    public Collection create(Context context, Community community) throws SQLException,\n        AuthorizeException;\n\n\n    /**\n     * Create a new collection with the supplied handle and with a new ID.\n     * Once created the collection is added to the given community\n     *\n     * @param context   DSpace context object\n     * @param community DSpace Community (parent)\n     * @param handle    the pre-determined Handle to assign to the new community\n     * @return the newly created collection\n     * @throws SQLException       if database error\n     * @throws AuthorizeException if authorization error\n     */\n    public Collection create(Context context, Community community, String handle) throws SQLException,\n        AuthorizeException;\n\n    /**\n     * Create a new collection with the supplied handle and ID.\n     * Once created the collection is added to the given community\n     *\n     * @param context DSpace context object\n     * @param community DSpace Community (parent)\n     * @param handle the pre-determined Handle to assign to the new collection\n     * @param uuid the pre-determined UUID to assign to the new collection\n     * @return the newly created collection\n     * @throws SQLException if database error\n     * @throws AuthorizeException if authorization error\n     */\n    public Collection create(Context context, Community community, String handle, UUID uuid) throws SQLException,\n            AuthorizeException;\n\n    /**\n     * Get all collections in the system. These are alphabetically sorted by\n     * collection name.\n     *\n     * @param context DSpace context object\n     * @return the collections in the system\n     * @throws SQLException if database error\n     */\n    public List<Collection> findAll(Context context) throws SQLException;\n\n    /**\n     * Get all collections in the system. Adds support for limit and offset.\n     *\n     * @param context The relevant DSpace Context.\n     * @param limit   paging limit\n     * @param offset  paging offset\n     * @return List of Collections\n     * @throws SQLException if database error\n     */\n    public List<Collection> findAll(Context context, Integer limit, Integer offset) throws SQLException;\n\n    public List<Collection> findAuthorizedOptimized(Context context, int actionID) throws java.sql.SQLException;\n\n    public List<Collection> findDirectMapped(Context context, int actionID) throws java.sql.SQLException;\n\n    public List<Collection> findGroup2CommunityMapped(Context context) throws SQLException;\n\n    public List<Collection> findGroup2GroupMapped(Context context, int actionID) throws SQLException;\n\n    public List<Collection> findGroupMapped(Context context, int actionID) throws java.sql.SQLException;\n\n    /**\n     * Give the collection a logo. Passing in <code>null</code> removes any\n     * existing logo. You will need to set the format of the new logo bitstream\n     * before it will work, for example to \"JPEG\". Note that\n     * <code>update</code> will need to be called for the change to take\n     * effect.  Setting a logo and not calling <code>update</code> later may\n     * result in a previous logo lying around as an \"orphaned\" bitstream.\n     *\n     * @param context    DSpace Context\n     * @param collection Collection\n     * @param is         the stream to use as the new logo\n     * @return the new logo bitstream, or <code>null</code> if there is no\n     * logo (<code>null</code> was passed in)\n     * @throws AuthorizeException if authorization error\n     * @throws IOException        if IO error\n     * @throws SQLException       if database error\n     */\n    public Bitstream setLogo(Context context, Collection collection, InputStream is) throws AuthorizeException,\n        IOException, SQLException;\n\n    /**\n     * Create a workflow group for the given step if one does not already exist.\n     * Returns either the newly created group or the previously existing one.\n     * Note that while the new group is created in the database, the association\n     * between the group and the collection is not written until\n     * <code>update</code> is called.\n     *\n     * @param context    DSpace Context\n     * @param collection Collection\n     * @param step       the step (1-3) of the workflow to create or get the group for\n     * @return the workflow group associated with this collection\n     * @throws SQLException       if database error\n     * @throws AuthorizeException if authorization error\n     */\n    public Group createWorkflowGroup(Context context, Collection collection, int step) throws SQLException,\n        AuthorizeException;\n\n    /**\n     * Set the workflow group corresponding to a particular workflow step.\n     * <code>null</code> can be passed in if there should be no associated\n     * group for that workflow step; any existing group is NOT deleted.\n     *\n     * @param context    current DSpace session.\n     * @param collection Collection\n     * @param step       the workflow step (1-3)\n     * @param group      the new workflow group, or <code>null</code>\n     * @throws SQLException passed through.\n     * @throws AuthorizeException passed through.\n     */\n    public void setWorkflowGroup(Context context, Collection collection, int step, Group group)\n        throws SQLException, AuthorizeException;\n\n    /**\n     * Get the the workflow group corresponding to a particular workflow step.\n     * This returns <code>null</code> if there is no group associated with\n     * this collection for the given step.\n     *\n     * @param context    DSpace Context\n     * @param collection Collection\n     * @param step       the workflow step (1-3)\n     * @return the group of reviewers or <code>null</code>\n     */\n    public Group getWorkflowGroup(Context context, Collection collection, int step);\n\n    /**\n     * Create a default submitters group if one does not already exist. Returns\n     * either the newly created group or the previously existing one. Note that\n     * other groups may also be allowed to submit to this collection by the\n     * authorization system.\n     *\n     * @param context    DSpace Context\n     * @param collection Collection\n     * @return the default group of submitters associated with this collection\n     * @throws SQLException       if database error\n     * @throws AuthorizeException if authorization error\n     */\n    public Group createSubmitters(Context context, Collection collection) throws SQLException, AuthorizeException;\n\n    /**\n     * Remove the submitters group, if no group has already been created\n     * then return without error. This will merely dereference the current\n     * submitters group from the collection so that it may be deleted\n     * without violating database constraints.\n     *\n     * @param context    DSpace Context\n     * @param collection Collection\n     * @throws SQLException       if database error\n     * @throws AuthorizeException if authorization error\n     */\n    public void removeSubmitters(Context context, Collection collection) throws SQLException, AuthorizeException;\n\n\n    /**\n     * Create a default administrators group if one does not already exist.\n     * Returns either the newly created group or the previously existing one.\n     * Note that other groups may also be administrators.\n     *\n     * @param context    DSpace Context\n     * @param collection Collection\n     * @return the default group of editors associated with this collection\n     * @throws SQLException       if database error\n     * @throws AuthorizeException if authorization error\n     */\n    public Group createAdministrators(Context context, Collection collection) throws SQLException, AuthorizeException;\n\n    /**\n     * Remove the administrators group, if no group has already been created\n     * then return without error. This will merely dereference the current\n     * administrators group from the collection so that it may be deleted\n     * without violating database constraints.\n     *\n     * @param context    DSpace Context\n     * @param collection Collection\n     * @throws SQLException       if database error\n     * @throws AuthorizeException if authorization error\n     */\n    public void removeAdministrators(Context context, Collection collection) throws SQLException, AuthorizeException;\n\n    /**\n     * Get the license that users must grant before submitting to this\n     * collection. If the collection does not have a specific license, the\n     * site-wide default is returned.\n     *\n     * @param collection Collection\n     * @return the license for this collection\n     */\n    public String getLicense(Collection collection);\n\n    /**\n     * Find out if the collection has a custom license\n     *\n     * @param collection Collection\n     * @return <code>true</code> if the collection has a custom license\n     */\n    public boolean hasCustomLicense(Collection collection);\n\n    /**\n     * Create an empty template item for this collection. If one already exists,\n     * no action is taken. Caution: Make sure you call <code>update</code> on\n     * the collection after doing this, or the item will have been created but\n     * the collection record will not refer to it.\n     *\n     * @param context    DSpace Context\n     * @param collection Collection\n     * @throws SQLException       if database error\n     * @throws AuthorizeException if authorization error\n     */\n    public void createTemplateItem(Context context, Collection collection) throws SQLException, AuthorizeException;\n\n    /**\n     * Remove the template item for this collection, if there is one. Note that\n     * since this has to remove the old template item ID from the collection\n     * record in the database, the collection record will be changed, including\n     * any other changes made; in other words, this method does an\n     * <code>update</code>.\n     *\n     * @param context    DSpace Context\n     * @param collection Collection\n     * @throws SQLException       if database error\n     * @throws AuthorizeException if authorization error\n     * @throws IOException        if IO error\n     */\n    public void removeTemplateItem(Context context, Collection collection)\n        throws SQLException, AuthorizeException, IOException;\n\n    /**\n     * Add an item to the collection. This simply adds a relationship between\n     * the item and the collection - it does nothing like set an issue date,\n     * remove a personal workspace item etc. This has instant effect;\n     * <code>update</code> need not be called.\n     *\n     * @param context    DSpace Context\n     * @param collection Collection\n     * @param item       item to add\n     * @throws SQLException       if database error\n     * @throws AuthorizeException if authorization error\n     */\n    public void addItem(Context context, Collection collection, Item item) throws SQLException, AuthorizeException;\n\n    /**\n     * Remove an item. If the item is then orphaned, it is deleted.\n     *\n     * @param context    DSpace Context\n     * @param collection Collection\n     * @param item       item to remove\n     * @throws SQLException       if database error\n     * @throws AuthorizeException if authorization error\n     * @throws IOException        if IO error\n     */\n    public void removeItem(Context context, Collection collection, Item item) throws SQLException, AuthorizeException,\n        IOException;\n\n    public boolean canEditBoolean(Context context, Collection collection) throws SQLException;\n\n    public boolean canEditBoolean(Context context, Collection collection, boolean useInheritance)\n        throws java.sql.SQLException;\n\n    public void canEdit(Context context, Collection collection) throws SQLException, AuthorizeException;\n\n    public void canEdit(Context context, Collection collection, boolean useInheritance)\n        throws SQLException, AuthorizeException;\n\n    /**\n     * return an array of collections that user has a given permission on\n     * (useful for trimming 'select to collection' list) or figuring out which\n     * collections a person is an editor for.\n     *\n     * @param context   DSpace Context\n     * @param community (optional) restrict search to a community, else null\n     * @param actionID  of the action\n     * @return Collection [] of collections with matching permissions\n     * @throws SQLException if database error\n     */\n    public List<Collection> findAuthorized(Context context, Community community, int actionID)\n        throws java.sql.SQLException;\n\n    /**\n     *\n     * @param context DSpace Context\n     * @param group EPerson Group\n     * @return the collection, if any, that has the specified group as administrators or submitters\n     * @throws SQLException\n     */\n    public Collection findByGroup(Context context, Group group) throws SQLException;\n\n    List<Collection> findCollectionsWithSubscribers(Context context) throws SQLException;\n\n    int countTotal(Context context) throws SQLException;\n\n    /**\n     * The map entry returned contains a collection as a key and sum of bitstream sizes in bytes as a value\n     *\n     * @param context DSpace Context\n     * @return List of Collections and bitstream sizes map\n     * @throws SQLException if database error\n     */\n    List<Map.Entry<Collection, Long>> getCollectionsWithBitstreamSizesTotal(Context context) throws SQLException;\n\n    /**\n     * This method will create a default read group for the given Collection. It'll create either a defaultItemRead or\n     * a defaultBitstreamRead group depending on the given parameters\n     *\n     * @param context           The relevant DSpace context\n     * @param collection        The collection for which it'll be created\n     * @param typeOfGroupString The type of group to be made, item or bitstream\n     * @param defaultRead       The defaultRead int, item or bitstream\n     * @return                  The created Group\n     * @throws SQLException     If something goes wrong\n     * @throws AuthorizeException   If something goes wrong\n     */\n    Group createDefaultReadGroup(Context context, Collection collection, String typeOfGroupString, int defaultRead)\n        throws SQLException, AuthorizeException;\n\n    /**\n     * Returns Collections for which the current user has 'submit' privileges.\n     * NOTE: for better performance, this method retrieves its results from an\n     *       index (cache) and does not query the database directly.\n     *       This means that results may be stale or outdated until https://github.com/DSpace/DSpace/issues/2853 is resolved\"\n     * \n     * @param q                limit the returned collection to those with metadata values matching the query terms.\n     *                         The terms are used to make also a prefix query on SOLR so it can be used to implement\n     *                         an autosuggest feature over the collection name\n     * @param context          DSpace Context\n     * @param community        parent community\n     * @param entityType       limit the returned collection to those related to given entity type\n     * @param offset           the position of the first result to return\n     * @param limit            paging limit\n     * @return                 discovery search result objects\n     * @throws SQLException              if something goes wrong\n     * @throws SearchServiceException    if search error\n     */\n    public List<Collection> findCollectionsWithSubmit(String q, Context context, Community community,\n            String entityType, int offset, int limit) throws SQLException, SearchServiceException;\n\n    /**\n     * Returns Collections for which the current user has 'submit' privileges.\n     * NOTE: for better performance, this method retrieves its results from an\n     *       index (cache) and does not query the database directly.\n     *       This means that results may be stale or outdated until\n     *       https://github.com/DSpace/DSpace/issues/2853 is resolved\"\n     * \n     * @param q                limit the returned collection to those with metadata values matching the query terms.\n     *                         The terms are used to make also a prefix query on SOLR so it can be used to implement\n     *                         an autosuggest feature over the collection name\n     * @param context          DSpace Context\n     * @param community        parent community\n     * @param offset           the position of the first result to return\n     * @param limit            paging limit\n     * @return                 discovery search result objects\n     * @throws SQLException              if something goes wrong\n     * @throws SearchServiceException    if search error\n     */\n    public List<Collection> findCollectionsWithSubmit(String q, Context context, Community community,\n        int offset, int limit) throws SQLException, SearchServiceException;\n\n    /**\n     * Counts the number of Collection for which the current user has 'submit' privileges.\n     * NOTE: for better performance, this method retrieves its results from an index (cache)\n     *       and does not query the database directly.\n     *       This means that results may be stale or outdated until\n     *       https://github.com/DSpace/DSpace/issues/2853 is resolved.\"\n     * \n     * @param q                limit the returned collection to those with metadata values matching the query terms.\n     *                         The terms are used to make also a prefix query on SOLR so it can be used to implement\n     *                         an autosuggest feature over the collection name\n     * @param context          DSpace Context\n     * @param community        parent community\n     * @return                 total collections found\n     * @throws SQLException              if something goes wrong\n     * @throws SearchServiceException    if search error\n     */\n    public int countCollectionsWithSubmit(String q, Context context, Community community)\n        throws SQLException, SearchServiceException;\n\n    /**\n     * Counts the number of Collection for which the current user has 'submit' privileges.\n     * NOTE: for better performance, this method retrieves its results from an index (cache)\n     *       and does not query the database directly.\n     *       This means that results may be stale or outdated until\n     *       https://github.com/DSpace/DSpace/issues/2853 is resolved.\"\n     * \n     * @param q                limit the returned collection to those with metadata values matching the query terms.\n     *                         The terms are used to make also a prefix query on SOLR so it can be used to implement\n     *                         an autosuggest feature over the collection name\n     * @param context          DSpace Context\n     * @param community        parent community\n     * @param entityType       limit the returned collection to those related to given entity type\n     * @return                 total collections found\n     * @throws SQLException              if something goes wrong\n     * @throws SearchServiceException    if search error\n     */\n    public int countCollectionsWithSubmit(String q, Context context, Community community, String entityType)\n        throws SQLException, SearchServiceException;\n\n}\n", "/**\n * The contents of this file are subject to the license and copyright\n * detailed in the LICENSE and NOTICE files at the root of the source\n * tree and available online at\n *\n * http://www.dspace.org/license/\n */\npackage org.dspace.eperson;\n\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.UUID;\n\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.dspace.authorize.AuthorizeConfiguration;\nimport org.dspace.authorize.AuthorizeException;\nimport org.dspace.authorize.ResourcePolicy;\nimport org.dspace.authorize.service.AuthorizeService;\nimport org.dspace.authorize.service.ResourcePolicyService;\nimport org.dspace.content.Collection;\nimport org.dspace.content.DSpaceObject;\nimport org.dspace.content.DSpaceObjectServiceImpl;\nimport org.dspace.content.MetadataField;\nimport org.dspace.content.service.CollectionService;\nimport org.dspace.content.service.CommunityService;\nimport org.dspace.core.Constants;\nimport org.dspace.core.Context;\nimport org.dspace.core.LogHelper;\nimport org.dspace.eperson.dao.Group2GroupCacheDAO;\nimport org.dspace.eperson.dao.GroupDAO;\nimport org.dspace.eperson.factory.EPersonServiceFactory;\nimport org.dspace.eperson.service.EPersonService;\nimport org.dspace.eperson.service.GroupService;\nimport org.dspace.event.Event;\nimport org.dspace.util.UUIDUtils;\nimport org.dspace.xmlworkflow.Role;\nimport org.dspace.xmlworkflow.factory.XmlWorkflowFactory;\nimport org.dspace.xmlworkflow.state.Step;\nimport org.dspace.xmlworkflow.storedcomponents.ClaimedTask;\nimport org.dspace.xmlworkflow.storedcomponents.CollectionRole;\nimport org.dspace.xmlworkflow.storedcomponents.PoolTask;\nimport org.dspace.xmlworkflow.storedcomponents.service.ClaimedTaskService;\nimport org.dspace.xmlworkflow.storedcomponents.service.CollectionRoleService;\nimport org.dspace.xmlworkflow.storedcomponents.service.PoolTaskService;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\n\n/**\n * Service implementation for the Group object.\n * This class is responsible for all business logic calls for the Group object and is autowired by spring.\n * This class should never be accessed directly.\n *\n * @author kevinvandevelde at atmire.com\n */\npublic class GroupServiceImpl extends DSpaceObjectServiceImpl<Group> implements GroupService {\n    private static final Logger log = LoggerFactory.getLogger(GroupServiceImpl.class);\n\n    @Autowired(required = true)\n    protected GroupDAO groupDAO;\n\n    @Autowired(required = true)\n    protected Group2GroupCacheDAO group2GroupCacheDAO;\n\n    @Autowired(required = true)\n    protected CollectionService collectionService;\n\n    @Autowired(required = true)\n    protected CollectionRoleService collectionRoleService;\n\n    @Autowired(required = true)\n    protected EPersonService ePersonService;\n\n    @Autowired(required = true)\n    protected CommunityService communityService;\n\n    @Autowired(required = true)\n    protected AuthorizeService authorizeService;\n    @Autowired(required = true)\n    protected ResourcePolicyService resourcePolicyService;\n\n    @Autowired(required = true)\n    protected PoolTaskService poolTaskService;\n    @Autowired(required = true)\n    protected ClaimedTaskService claimedTaskService;\n    @Autowired(required = true)\n    protected XmlWorkflowFactory workflowFactory;\n\n    protected GroupServiceImpl() {\n        super();\n    }\n\n    @Override\n    public Group create(Context context) throws SQLException, AuthorizeException {\n        // FIXME - authorization?\n        if (!authorizeService.isAdmin(context)) {\n            throw new AuthorizeException(\n                \"You must be an admin to create an EPerson Group\");\n        }\n\n        // Create a table row\n        Group g = groupDAO.create(context, new Group());\n\n        log.info(LogHelper.getHeader(context, \"create_group\", \"group_id=\"\n            + g.getID()));\n\n        context.addEvent(new Event(Event.CREATE, Constants.GROUP, g.getID(), null, getIdentifiers(context, g)));\n        update(context, g);\n\n        return g;\n    }\n\n    @Override\n    public void setName(Group group, String name) throws SQLException {\n        if (group.isPermanent()) {\n            log.error(\"Attempt to rename permanent Group {} to {}.\",\n                      group.getName(), name);\n            throw new SQLException(\"Attempt to rename a permanent Group\");\n        } else {\n            group.setName(name);\n        }\n    }\n\n    @Override\n    public void addMember(Context context, Group group, EPerson e) {\n        if (isDirectMember(group, e)) {\n            return;\n        }\n        group.addMember(e);\n        e.getGroups().add(group);\n        context.addEvent(\n            new Event(Event.ADD, Constants.GROUP, group.getID(), Constants.EPERSON, e.getID(), e.getEmail(),\n                      getIdentifiers(context, group)));\n    }\n\n    @Override\n    public void addMember(Context context, Group groupParent, Group groupChild) throws SQLException {\n        // don't add if it's already a member\n        // and don't add itself\n        if (groupParent.contains(groupChild) || groupParent.getID() == groupChild.getID()) {\n            return;\n        }\n\n        groupParent.addMember(groupChild);\n        groupChild.addParentGroup(groupParent);\n\n        context.addEvent(new Event(Event.ADD, Constants.GROUP, groupParent.getID(), Constants.GROUP, groupChild.getID(),\n                                   groupChild.getName(), getIdentifiers(context, groupParent)));\n    }\n\n    /**\n     * Removes a member of a group.\n     * The removal will be refused if the group is linked to a workflow step which has claimed tasks or pool tasks\n     * and no other member is present in the group to handle these.\n     * @param context DSpace context object\n     * @param group   DSpace group\n     * @param ePerson eperson\n     * @throws SQLException\n     */\n    @Override\n    public void removeMember(Context context, Group group, EPerson ePerson) throws SQLException {\n        List<CollectionRole> collectionRoles = collectionRoleService.findByGroup(context, group);\n        if (!collectionRoles.isEmpty()) {\n            List<PoolTask> poolTasks = poolTaskService.findByGroup(context, group);\n            List<ClaimedTask> claimedTasks = claimedTaskService.findByEperson(context, ePerson);\n            for (ClaimedTask claimedTask : claimedTasks) {\n                Step stepByName = workflowFactory.getStepByName(claimedTask.getStepID());\n                Role role = stepByName.getRole();\n                for (CollectionRole collectionRole : collectionRoles) {\n                    if (StringUtils.equals(collectionRole.getRoleId(), role.getId())\n                            && claimedTask.getWorkflowItem().getCollection() == collectionRole.getCollection()) {\n                        List<EPerson> ePeople = allMembers(context, group);\n                        if (ePeople.size() == 1 && ePeople.contains(ePerson)) {\n                            throw new IllegalStateException(\n                                    \"Refused to remove user \" + ePerson\n                                            .getID() + \" from workflow group because the group \" + group\n                                            .getID() + \" has tasks assigned and no other members\");\n                        }\n\n                    }\n                }\n            }\n            if (!poolTasks.isEmpty()) {\n                List<EPerson> ePeople = allMembers(context, group);\n                if (ePeople.size() == 1 && ePeople.contains(ePerson)) {\n                    throw new IllegalStateException(\n                            \"Refused to remove user \" + ePerson\n                                    .getID() + \" from workflow group because the group \" + group\n                                    .getID() + \" has tasks assigned and no other members\");\n                }\n            }\n        }\n        if (group.remove(ePerson)) {\n            context.addEvent(new Event(Event.REMOVE, Constants.GROUP, group.getID(), Constants.EPERSON, ePerson.getID(),\n                                       ePerson.getEmail(), getIdentifiers(context, group)));\n        }\n    }\n\n    @Override\n    public void removeMember(Context context, Group groupParent, Group childGroup) throws SQLException {\n        List<CollectionRole> collectionRoles = collectionRoleService.findByGroup(context, groupParent);\n        if (!collectionRoles.isEmpty()) {\n            List<PoolTask> poolTasks = poolTaskService.findByGroup(context, groupParent);\n            if (!poolTasks.isEmpty()) {\n                List<EPerson> parentPeople = allMembers(context, groupParent);\n                List<EPerson> childPeople = allMembers(context, childGroup);\n                if (childPeople.containsAll(parentPeople)) {\n                    throw new IllegalStateException(\n                            \"Refused to remove sub group \" + childGroup\n                                    .getID() + \" from workflow group because the group \" + groupParent\n                                    .getID() + \" has tasks assigned and no other members\");\n                }\n            }\n        }\n        if (groupParent.remove(childGroup)) {\n            childGroup.removeParentGroup(groupParent);\n            context.addEvent(\n                new Event(Event.REMOVE, Constants.GROUP, groupParent.getID(), Constants.GROUP, childGroup.getID(),\n                          childGroup.getName(), getIdentifiers(context, groupParent)));\n        }\n    }\n\n    @Override\n    public boolean isDirectMember(Group group, EPerson ePerson) {\n        // special, group 0 is anonymous\n        return StringUtils.equals(group.getName(), Group.ANONYMOUS) || group.contains(ePerson);\n    }\n\n    @Override\n    public boolean isMember(Group owningGroup, Group childGroup) {\n        return owningGroup.contains(childGroup);\n    }\n\n    @Override\n    public boolean isParentOf(Context context, Group parentGroup, Group childGroup) throws SQLException {\n        return group2GroupCacheDAO.findByParentAndChild(context, parentGroup, childGroup) != null;\n    }\n\n    @Override\n    public boolean isMember(Context context, Group group) throws SQLException {\n        return isMember(context, context.getCurrentUser(), group);\n    }\n\n    @Override\n    public boolean isMember(Context context, EPerson ePerson, Group group)\n        throws SQLException {\n        if (group == null) {\n            return false;\n\n            // special, everyone is member of group 0 (anonymous)\n        } else if (StringUtils.equals(group.getName(), Group.ANONYMOUS) ||\n                   isParentOf(context, group, findByName(context, Group.ANONYMOUS))) {\n            return true;\n\n        } else {\n            Boolean cachedGroupMembership = context.getCachedGroupMembership(group, ePerson);\n\n            if (cachedGroupMembership != null) {\n                return cachedGroupMembership;\n\n            } else {\n                boolean isMember = false;\n\n                //If we have an ePerson, check we can find membership in the database\n                if (ePerson != null) {\n                    //lookup eperson in normal groups and subgroups with 1 query\n                    isMember = isEPersonInGroup(context, group, ePerson);\n                }\n\n                //If we did not find the group membership in the database, check the special groups.\n                //If there are special groups we need to check direct membership or check if the\n                //special group is a subgroup of the provided group.\n                //Note that special groups should only be checked if the current user == the ePerson.\n                //This also works for anonymous users (ePerson == null) if IP authentication used\n                if (!isMember && CollectionUtils.isNotEmpty(context.getSpecialGroups()) &&\n                    isAuthenticatedUser(context, ePerson)) {\n\n                    Iterator<Group> it = context.getSpecialGroups().iterator();\n\n                    while (it.hasNext() && !isMember) {\n                        Group specialGroup = it.next();\n                        //Check if the special group matches the given group or if it is a subgroup (with 1 query)\n                        if (specialGroup.equals(group) || isParentOf(context, group, specialGroup)) {\n                            isMember = true;\n                        }\n                    }\n                }\n\n                context.cacheGroupMembership(group, ePerson, isMember);\n                return isMember;\n\n            }\n        }\n    }\n\n    private boolean isAuthenticatedUser(final Context context, final EPerson ePerson) {\n        return Objects.equals(context.getCurrentUser(), ePerson);\n    }\n\n    @Override\n    public boolean isMember(final Context context, final String groupName) throws SQLException {\n        return isMember(context, findByName(context, groupName));\n    }\n\n    @Override\n    public boolean isMember(final Context context, EPerson eperson, final String groupName) throws SQLException {\n        return isMember(context, eperson, findByName(context, groupName));\n    }\n\n    @Override\n    public List<Group> allMemberGroups(Context context, EPerson ePerson) throws SQLException {\n        return new ArrayList<>(allMemberGroupsSet(context, ePerson));\n    }\n\n    @Override\n    public Set<Group> allMemberGroupsSet(Context context, EPerson ePerson) throws SQLException {\n        Set<Group> cachedGroupMembership = context.getCachedAllMemberGroupsSet(ePerson);\n        if (cachedGroupMembership != null) {\n            return cachedGroupMembership;\n        }\n\n        Set<Group> groups = new HashSet<>();\n\n        if (ePerson != null) {\n            // two queries - first to get groups eperson is a member of\n            // second query gets parent groups for groups eperson is a member of\n            groups.addAll(groupDAO.findByEPerson(context, ePerson));\n        }\n        // Also need to get all \"Special Groups\" user is a member of!\n        // Otherwise, you're ignoring the user's membership to these groups!\n        // However, we only do this is we are looking up the special groups\n        // of the current user, as we cannot look up the special groups\n        // of a user who is not logged in.\n        if ((context.getCurrentUser() == null) || (context.getCurrentUser().equals(ePerson))) {\n            List<Group> specialGroups = context.getSpecialGroups();\n            for (Group special : specialGroups) {\n                groups.add(special);\n            }\n        }\n\n        // all the users are members of the anonymous group\n        groups.add(findByName(context, Group.ANONYMOUS));\n\n        List<Group2GroupCache> groupCache = group2GroupCacheDAO.findByChildren(context, groups);\n        // now we have all owning groups, also grab all parents of owning groups\n        // yes, I know this could have been done as one big query and a union,\n        // but doing the Oracle port taught me to keep to simple SQL!\n        for (Group2GroupCache group2GroupCache : groupCache) {\n            groups.add(group2GroupCache.getParent());\n        }\n\n        context.cacheAllMemberGroupsSet(ePerson, groups);\n        return groups;\n    }\n\n    @Override\n    public List<EPerson> allMembers(Context c, Group g) throws SQLException {\n        // two queries - first to get all groups which are a member of this group\n        // second query gets all members of each group in the first query\n\n        // Get all groups which are a member of this group\n        List<Group2GroupCache> group2GroupCaches = group2GroupCacheDAO.findByParent(c, g);\n        Set<Group> groups = new HashSet<>();\n        for (Group2GroupCache group2GroupCache : group2GroupCaches) {\n            groups.add(group2GroupCache.getChild());\n        }\n\n\n        Set<EPerson> childGroupChildren = new HashSet<>(ePersonService.findByGroups(c, groups));\n        //Don't forget to add our direct children\n        childGroupChildren.addAll(g.getMembers());\n\n        return new ArrayList<>(childGroupChildren);\n    }\n\n    @Override\n    public Group find(Context context, UUID id) throws SQLException {\n        if (id == null) {\n            return null;\n        } else {\n            return groupDAO.findByID(context, Group.class, id);\n        }\n    }\n\n    @Override\n    public Group findByName(Context context, String name) throws SQLException {\n        if (name == null) {\n            return null;\n        }\n\n        return groupDAO.findByName(context, name);\n    }\n\n    /**\n     * DEPRECATED: Please use {@code findAll(Context context, List<MetadataField> metadataSortFields)} instead\n     */\n    @Override\n    @Deprecated\n    public List<Group> findAll(Context context, int sortField) throws SQLException {\n        if (sortField == GroupService.NAME) {\n            return findAll(context, null);\n        } else {\n            throw new UnsupportedOperationException(\"You can only find all groups sorted by name with this method\");\n        }\n    }\n\n    @Override\n    public List<Group> findAll(Context context, List<MetadataField> metadataSortFields) throws SQLException {\n        return findAll(context, metadataSortFields, -1, -1);\n    }\n\n    @Override\n    public List<Group> findAll(Context context, List<MetadataField> metadataSortFields, int pageSize, int offset)\n        throws SQLException {\n        if (CollectionUtils.isEmpty(metadataSortFields)) {\n            return groupDAO.findAll(context, pageSize, offset);\n        } else {\n            return groupDAO.findAll(context, metadataSortFields, pageSize, offset);\n        }\n    }\n\n    @Override\n    public List<Group> search(Context context, String groupIdentifier) throws SQLException {\n        return search(context, groupIdentifier, -1, -1);\n    }\n\n    @Override\n    public List<Group> search(Context context, String groupIdentifier, int offset, int limit) throws SQLException {\n        List<Group> groups = new ArrayList<>();\n        UUID uuid = UUIDUtils.fromString(groupIdentifier);\n        if (uuid == null) {\n            //Search by group name\n            groups = groupDAO.findByNameLike(context, groupIdentifier, offset, limit);\n        } else {\n            //Search by group id\n            Group group = find(context, uuid);\n            if (group != null) {\n                groups.add(group);\n            }\n        }\n\n        return groups;\n    }\n\n    @Override\n    public int searchResultCount(Context context, String groupIdentifier) throws SQLException {\n        int result = 0;\n        UUID uuid = UUIDUtils.fromString(groupIdentifier);\n        if (uuid == null) {\n            //Search by group name\n            result = groupDAO.countByNameLike(context, groupIdentifier);\n        } else {\n            //Search by group id\n            Group group = find(context, uuid);\n            if (group != null) {\n                result = 1;\n            }\n        }\n\n        return result;\n    }\n\n    @Override\n    public void delete(Context context, Group group) throws SQLException {\n        if (group.isPermanent()) {\n            log.error(\"Attempt to delete permanent Group $\", group.getName());\n            throw new SQLException(\"Attempt to delete a permanent Group\");\n        }\n\n        context.addEvent(new Event(Event.DELETE, Constants.GROUP, group.getID(),\n                                   group.getName(), getIdentifiers(context, group)));\n\n        //Remove the supervised group from any workspace items linked to us.\n        group.getSupervisedItems().clear();\n\n        // Remove any ResourcePolicies that reference this group\n        authorizeService.removeGroupPolicies(context, group);\n\n        group.getMemberGroups().clear();\n        group.getParentGroups().clear();\n\n        //Remove all eperson references from this group\n        Iterator<EPerson> ePeople = group.getMembers().iterator();\n        while (ePeople.hasNext()) {\n            EPerson ePerson = ePeople.next();\n            ePeople.remove();\n            ePerson.getGroups().remove(group);\n        }\n\n        // empty out group2groupcache table (if we do it after we delete our object we get an issue with references)\n        group2GroupCacheDAO.deleteAll(context);\n        // Remove ourself\n        groupDAO.delete(context, group);\n        rethinkGroupCache(context, false);\n\n        log.info(LogHelper.getHeader(context, \"delete_group\", \"group_id=\"\n            + group.getID()));\n    }\n\n    @Override\n    public int getSupportsTypeConstant() {\n        return Constants.GROUP;\n    }\n\n    /**\n     * Return true if group has no direct or indirect members\n     */\n    @Override\n    public boolean isEmpty(Group group) {\n        // the only fast check available is on epeople...\n        boolean hasMembers = (!group.getMembers().isEmpty());\n\n        if (hasMembers) {\n            return false;\n        } else {\n            // well, groups is never null...\n            for (Group subGroup : group.getMemberGroups()) {\n                hasMembers = !isEmpty(subGroup);\n                if (hasMembers) {\n                    return false;\n                }\n            }\n            return !hasMembers;\n        }\n    }\n\n    @Override\n    public void initDefaultGroupNames(Context context) throws SQLException, AuthorizeException {\n        GroupService groupService = EPersonServiceFactory.getInstance().getGroupService();\n        // Check for Anonymous group. If not found, create it\n        Group anonymousGroup = groupService.findByName(context, Group.ANONYMOUS);\n        if (anonymousGroup == null) {\n            anonymousGroup = groupService.create(context);\n            anonymousGroup.setName(Group.ANONYMOUS);\n            anonymousGroup.setPermanent(true);\n            groupService.update(context, anonymousGroup);\n        }\n\n\n        // Check for Administrator group. If not found, create it\n        Group adminGroup = groupService.findByName(context, Group.ADMIN);\n        if (adminGroup == null) {\n            adminGroup = groupService.create(context);\n            adminGroup.setName(Group.ADMIN);\n            adminGroup.setPermanent(true);\n            groupService.update(context, adminGroup);\n        }\n    }\n\n    /**\n     * Get a list of groups with no members.\n     *\n     * @param context The relevant DSpace Context.\n     * @return list of groups with no members\n     * @throws SQLException An exception that provides information on a database access error or other errors.\n     */\n    @Override\n    public List<Group> getEmptyGroups(Context context) throws SQLException {\n        return groupDAO.getEmptyGroups(context);\n    }\n\n    /**\n     * Update the group - writing out group object and EPerson list if necessary\n     *\n     * @param context The relevant DSpace Context.\n     * @param group   Group to update\n     * @throws SQLException       An exception that provides information on a database access error or other errors.\n     * @throws AuthorizeException Exception indicating the current user of the context does not have permission\n     *                            to perform a particular action.\n     */\n    @Override\n    public void update(Context context, Group group) throws SQLException, AuthorizeException {\n\n        super.update(context, group);\n        // FIXME: Check authorisation\n        groupDAO.save(context, group);\n\n        if (group.isMetadataModified()) {\n            context.addEvent(new Event(Event.MODIFY_METADATA, Constants.GROUP, group.getID(), group.getDetails(),\n                                       getIdentifiers(context, group)));\n            group.clearDetails();\n        }\n\n        if (group.isGroupsChanged()) {\n            rethinkGroupCache(context, true);\n            group.clearGroupsChanged();\n        }\n\n        log.info(LogHelper.getHeader(context, \"update_group\", \"group_id=\"\n            + group.getID()));\n    }\n\n\n    protected boolean isEPersonInGroup(Context context, Group group, EPerson ePerson)\n        throws SQLException {\n        return groupDAO.findByIdAndMembership(context, group.getID(), ePerson) != null;\n    }\n\n\n    /**\n     * Regenerate the group cache AKA the group2groupcache table in the database -\n     * meant to be called when a group is added or removed from another group\n     *\n     * @param context      The relevant DSpace Context.\n     * @param flushQueries flushQueries Flush all pending queries\n     * @throws SQLException An exception that provides information on a database access error or other errors.\n     */\n    protected void rethinkGroupCache(Context context, boolean flushQueries) throws SQLException {\n\n        Map<UUID, Set<UUID>> parents = new HashMap<>();\n\n        List<Pair<UUID, UUID>> group2groupResults = groupDAO.getGroup2GroupResults(context, flushQueries);\n        for (Pair<UUID, UUID> group2groupResult : group2groupResults) {\n            UUID parent = group2groupResult.getLeft();\n            UUID child = group2groupResult.getRight();\n\n            // if parent doesn't have an entry, create one\n            if (!parents.containsKey(parent)) {\n                Set<UUID> children = new HashSet<>();\n\n                // add child id to the list\n                children.add(child);\n                parents.put(parent, children);\n            } else {\n                // parent has an entry, now add the child to the parent's record\n                // of children\n                Set<UUID> children = parents.get(parent);\n                children.add(child);\n            }\n        }\n\n        // now parents is a hash of all of the IDs of groups that are parents\n        // and each hash entry is a hash of all of the IDs of children of those\n        // parent groups\n        // so now to establish all parent,child relationships we can iterate\n        // through the parents hash\n        for (Map.Entry<UUID, Set<UUID>> parent : parents.entrySet()) {\n            Set<UUID> myChildren = getChildren(parents, parent.getKey());\n            parent.getValue().addAll(myChildren);\n        }\n\n        // empty out group2groupcache table\n        group2GroupCacheDAO.deleteAll(context);\n\n        // write out new one\n        for (Map.Entry<UUID, Set<UUID>> parent : parents.entrySet()) {\n            UUID key = parent.getKey();\n\n            for (UUID child : parent.getValue()) {\n\n                Group parentGroup = find(context, key);\n                Group childGroup = find(context, child);\n\n\n                if (parentGroup != null && childGroup != null && group2GroupCacheDAO\n                    .find(context, parentGroup, childGroup) == null) {\n                    Group2GroupCache group2GroupCache = group2GroupCacheDAO.create(context, new Group2GroupCache());\n                    group2GroupCache.setParent(parentGroup);\n                    group2GroupCache.setChild(childGroup);\n                    group2GroupCacheDAO.save(context, group2GroupCache);\n                }\n            }\n        }\n    }\n\n    @Override\n    public DSpaceObject getParentObject(Context context, Group group) throws SQLException {\n        if (group == null) {\n            return null;\n        }\n        // could a collection/community administrator manage related groups?\n        // check before the configuration options could give a performance gain\n        // if all group management are disallowed\n        if (AuthorizeConfiguration.canCollectionAdminManageAdminGroup()\n            || AuthorizeConfiguration.canCollectionAdminManageSubmitters()\n            || AuthorizeConfiguration.canCollectionAdminManageWorkflows()\n            || AuthorizeConfiguration.canCommunityAdminManageAdminGroup()\n            || AuthorizeConfiguration\n            .canCommunityAdminManageCollectionAdminGroup()\n            || AuthorizeConfiguration\n            .canCommunityAdminManageCollectionSubmitters()\n            || AuthorizeConfiguration\n            .canCommunityAdminManageCollectionWorkflows()) {\n            // is this a collection related group?\n            org.dspace.content.Collection collection = collectionService.findByGroup(context, group);\n\n            if (collection != null) {\n                if (group.equals(collection.getSubmitters())) {\n                    if (AuthorizeConfiguration.canCollectionAdminManageSubmitters()) {\n                        return collection;\n                    } else if (AuthorizeConfiguration.canCommunityAdminManageCollectionSubmitters()) {\n                        return collectionService.getParentObject(context, collection);\n                    }\n                }\n                if (group.equals(collection.getAdministrators())) {\n                    if (AuthorizeConfiguration.canCollectionAdminManageAdminGroup()) {\n                        return collection;\n                    } else if (AuthorizeConfiguration.canCommunityAdminManageCollectionAdminGroup()) {\n                        return collectionService.getParentObject(context, collection);\n                    }\n                }\n            } else {\n                if (AuthorizeConfiguration.canCollectionAdminManageWorkflows()\n                        || AuthorizeConfiguration.canCommunityAdminManageCollectionWorkflows()) {\n                    // if the group is used for one or more roles on a single collection,\n                    // admins can eventually manage it\n                    List<CollectionRole> collectionRoles = collectionRoleService.findByGroup(context, group);\n                    if (collectionRoles != null && collectionRoles.size() > 0) {\n                        Set<Collection> colls = new HashSet<>();\n                        for (CollectionRole cr : collectionRoles) {\n                            colls.add(cr.getCollection());\n                        }\n                        if (colls.size() == 1) {\n                            collection = colls.iterator().next();\n                            if (AuthorizeConfiguration.canCollectionAdminManageWorkflows()) {\n                                return collection;\n                            } else {\n                                return collectionService.getParentObject(context, collection);\n                            }\n                        }\n                    } else {\n                        if (AuthorizeConfiguration.canCollectionAdminManagePolicies()\n                            || AuthorizeConfiguration.canCommunityAdminManagePolicies()\n                            || AuthorizeConfiguration.canCommunityAdminManageCollectionWorkflows()) {\n                            List<Group> groups = new ArrayList<>();\n                            groups.add(group);\n                            List<ResourcePolicy> policies = resourcePolicyService.find(context, null, groups,\n                                                            Constants.DEFAULT_ITEM_READ, Constants.COLLECTION);\n                            if (policies.size() > 0) {\n                                return policies.get(0).getdSpaceObject();\n                            }\n                            policies = resourcePolicyService.find(context, null, groups,\n                                                             Constants.DEFAULT_BITSTREAM_READ, Constants.COLLECTION);\n                            if (policies.size() > 0) {\n                                return policies.get(0).getdSpaceObject();\n                            }\n                        }\n                    }\n                }\n                if (AuthorizeConfiguration.canCommunityAdminManageAdminGroup()) {\n                    // is the group related to a community and community administrator allowed\n                    // to manage it?\n                    return communityService.findByAdminGroup(context, group);\n                }\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public void updateLastModified(Context context, Group dso) {\n        //Not needed.\n    }\n\n    /**\n     * Used recursively to generate a map of ALL of the children of the given\n     * parent\n     *\n     * @param parents Map of parent,child relationships\n     * @param parent  the parent you're interested in\n     * @return Map whose keys are all of the children of a parent\n     */\n    protected Set<UUID> getChildren(Map<UUID, Set<UUID>> parents, UUID parent) {\n        Set<UUID> myChildren = new HashSet<>();\n\n        // degenerate case, this parent has no children\n        if (!parents.containsKey(parent)) {\n            return myChildren;\n        }\n\n        // got this far, so we must have children\n        Set<UUID> children = parents.get(parent);\n\n        // now iterate over all of the children\n\n        for (UUID child : children) {\n            // add this child's ID to our return set\n            myChildren.add(child);\n\n            // and now its children\n            myChildren.addAll(getChildren(parents, child));\n        }\n\n        return myChildren;\n    }\n\n    @Override\n    public Group findByIdOrLegacyId(Context context, String id) throws SQLException {\n        if (org.apache.commons.lang3.StringUtils.isNumeric(id)) {\n            return findByLegacyId(context, Integer.parseInt(id));\n        } else {\n            return find(context, UUIDUtils.fromString(id));\n        }\n    }\n\n    @Override\n    public Group findByLegacyId(Context context, int id) throws SQLException {\n        return groupDAO.findByLegacyId(context, id, Group.class);\n    }\n\n    @Override\n    public int countTotal(Context context) throws SQLException {\n        return groupDAO.countRows(context);\n    }\n\n    @Override\n    public List<Group> findByMetadataField(final Context context, final String searchValue,\n                                           final MetadataField metadataField) throws SQLException {\n        return groupDAO.findByMetadataField(context, searchValue, metadataField);\n    }\n}\n"], "fixing_code": ["/**\n * The contents of this file are subject to the license and copyright\n * detailed in the LICENSE and NOTICE files at the root of the source\n * tree and available online at\n *\n * http://www.dspace.org/license/\n */\npackage org.dspace.content;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.UUID;\n\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.solr.client.solrj.util.ClientUtils;\nimport org.dspace.app.util.AuthorizeUtil;\nimport org.dspace.authorize.AuthorizeConfiguration;\nimport org.dspace.authorize.AuthorizeException;\nimport org.dspace.authorize.ResourcePolicy;\nimport org.dspace.authorize.service.AuthorizeService;\nimport org.dspace.authorize.service.ResourcePolicyService;\nimport org.dspace.content.dao.CollectionDAO;\nimport org.dspace.content.service.BitstreamService;\nimport org.dspace.content.service.CollectionService;\nimport org.dspace.content.service.CommunityService;\nimport org.dspace.content.service.ItemService;\nimport org.dspace.content.service.WorkspaceItemService;\nimport org.dspace.core.Constants;\nimport org.dspace.core.Context;\nimport org.dspace.core.I18nUtil;\nimport org.dspace.core.LogHelper;\nimport org.dspace.core.service.LicenseService;\nimport org.dspace.discovery.DiscoverQuery;\nimport org.dspace.discovery.DiscoverResult;\nimport org.dspace.discovery.IndexableObject;\nimport org.dspace.discovery.SearchService;\nimport org.dspace.discovery.SearchServiceException;\nimport org.dspace.discovery.indexobject.IndexableCollection;\nimport org.dspace.eperson.EPerson;\nimport org.dspace.eperson.Group;\nimport org.dspace.eperson.service.GroupService;\nimport org.dspace.eperson.service.SubscribeService;\nimport org.dspace.event.Event;\nimport org.dspace.harvest.HarvestedCollection;\nimport org.dspace.harvest.service.HarvestedCollectionService;\nimport org.dspace.identifier.IdentifierException;\nimport org.dspace.identifier.service.IdentifierService;\nimport org.dspace.services.ConfigurationService;\nimport org.dspace.workflow.factory.WorkflowServiceFactory;\nimport org.dspace.xmlworkflow.WorkflowConfigurationException;\nimport org.dspace.xmlworkflow.factory.XmlWorkflowFactory;\nimport org.dspace.xmlworkflow.state.Workflow;\nimport org.dspace.xmlworkflow.storedcomponents.CollectionRole;\nimport org.dspace.xmlworkflow.storedcomponents.service.CollectionRoleService;\nimport org.springframework.beans.factory.annotation.Autowired;\n\n/**\n * Service implementation for the Collection object.\n * This class is responsible for all business logic calls for the Collection object and is autowired by spring.\n * This class should never be accessed directly.\n *\n * @author kevinvandevelde at atmire.com\n */\npublic class CollectionServiceImpl extends DSpaceObjectServiceImpl<Collection> implements CollectionService {\n\n    /**\n     * log4j category\n     */\n    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(CollectionServiceImpl.class);\n\n    @Autowired(required = true)\n    protected CollectionDAO collectionDAO;\n\n    @Autowired(required = true)\n    protected AuthorizeService authorizeService;\n    @Autowired(required = true)\n    protected ResourcePolicyService resourcePolicyService;\n    @Autowired(required = true)\n    protected BitstreamService bitstreamService;\n    @Autowired(required = true)\n    protected ItemService itemService;\n    @Autowired(required = true)\n    protected CommunityService communityService;\n    @Autowired(required = true)\n    protected GroupService groupService;\n    @Autowired(required = true)\n    protected IdentifierService identifierService;\n\n    @Autowired(required = true)\n    protected LicenseService licenseService;\n    @Autowired(required = true)\n    protected SubscribeService subscribeService;\n    @Autowired(required = true)\n    protected WorkspaceItemService workspaceItemService;\n    @Autowired(required = true)\n    protected HarvestedCollectionService harvestedCollectionService;\n\n    @Autowired(required = true)\n    protected XmlWorkflowFactory workflowFactory;\n\n    @Autowired(required = true)\n    protected CollectionRoleService collectionRoleService;\n\n    @Autowired(required = true)\n    protected SearchService searchService;\n\n    @Autowired(required = true)\n    protected ConfigurationService configurationService;\n\n    protected CollectionServiceImpl() {\n        super();\n    }\n\n    @Override\n    public Collection create(Context context, Community community) throws SQLException, AuthorizeException {\n        return create(context, community, null);\n    }\n\n    @Override\n    public Collection create(Context context, Community community, String handle)\n            throws SQLException, AuthorizeException {\n        return create(context, community, handle, null);\n    }\n\n    @Override\n    public Collection create(Context context, Community community,\n                             String handle, UUID uuid) throws SQLException, AuthorizeException {\n        if (community == null) {\n            throw new IllegalArgumentException(\"Community cannot be null when creating a new collection.\");\n        }\n\n        Collection newCollection;\n        if (uuid != null) {\n            newCollection = collectionDAO.create(context, new Collection(uuid));\n        }  else {\n            newCollection = collectionDAO.create(context, new Collection());\n        }\n        //Add our newly created collection to our community, authorization checks occur in THIS method\n        communityService.addCollection(context, community, newCollection);\n\n        // create the default authorization policy for collections\n        // of 'anonymous' READ\n        Group anonymousGroup = groupService.findByName(context, Group.ANONYMOUS);\n\n\n        authorizeService.createResourcePolicy(context, newCollection, anonymousGroup, null, Constants.READ, null);\n        // now create the default policies for submitted items\n        authorizeService\n                .createResourcePolicy(context, newCollection, anonymousGroup, null, Constants.DEFAULT_ITEM_READ, null);\n        authorizeService\n                .createResourcePolicy(context, newCollection, anonymousGroup, null,\n                        Constants.DEFAULT_BITSTREAM_READ, null);\n\n        collectionDAO.save(context, newCollection);\n\n        //Update our collection so we have a collection identifier\n        try {\n            if (handle == null) {\n                identifierService.register(context, newCollection);\n            } else {\n                identifierService.register(context, newCollection, handle);\n            }\n        } catch (IllegalStateException | IdentifierException ex) {\n            throw new IllegalStateException(ex);\n        }\n\n        context.addEvent(new Event(Event.CREATE, Constants.COLLECTION,\n                newCollection.getID(), newCollection.getHandle(),\n                getIdentifiers(context, newCollection)));\n\n        log.info(LogHelper.getHeader(context, \"create_collection\",\n                \"collection_id=\" + newCollection.getID())\n                + \",handle=\" + newCollection.getHandle());\n\n        return newCollection;\n    }\n\n    @Override\n    public List<Collection> findAll(Context context) throws SQLException {\n        MetadataField nameField = metadataFieldService.findByElement(context, MetadataSchemaEnum.DC.getName(),\n                                                                     \"title\", null);\n        if (nameField == null) {\n            throw new IllegalArgumentException(\n                \"Required metadata field '\" + MetadataSchemaEnum.DC.getName() + \".title' doesn't exist!\");\n        }\n\n        return collectionDAO.findAll(context, nameField);\n    }\n\n    @Override\n    public List<Collection> findAll(Context context, Integer limit, Integer offset) throws SQLException {\n        MetadataField nameField = metadataFieldService.findByElement(context, MetadataSchemaEnum.DC.getName(),\n                                                                     \"title\", null);\n        if (nameField == null) {\n            throw new IllegalArgumentException(\n                \"Required metadata field '\" + MetadataSchemaEnum.DC.getName() + \".title' doesn't exist!\");\n        }\n\n        return collectionDAO.findAll(context, nameField, limit, offset);\n    }\n\n    @Override\n    public List<Collection> findAuthorizedOptimized(Context context, int actionID) throws SQLException {\n        if (!configurationService\n            .getBooleanProperty(\"org.dspace.content.Collection.findAuthorizedPerformanceOptimize\", false)) {\n            // Fallback to legacy query if config says so. The rationale could be that a site found a bug.\n            return findAuthorized(context, null, actionID);\n        }\n\n        List<Collection> myResults = new ArrayList<>();\n\n        if (authorizeService.isAdmin(context)) {\n            return findAll(context);\n        }\n\n        //Check eperson->policy\n        List<Collection> directToCollection = findDirectMapped(context, actionID);\n        for (int i = 0; i < directToCollection.size(); i++) {\n            if (!myResults.contains(directToCollection.get(i))) {\n                myResults.add(directToCollection.get(i));\n            }\n        }\n\n        //Check eperson->groups->policy\n        List<Collection> groupToCollection = findGroupMapped(context, actionID);\n\n        for (Collection aGroupToCollection : groupToCollection) {\n            if (!myResults.contains(aGroupToCollection)) {\n                myResults.add(aGroupToCollection);\n            }\n        }\n\n        //Check eperson->groups->groups->policy->collection\n        //i.e. Malcolm Litchfield is a member of OSU_Press_Embargo,\n        // which is a member of: COLLECTION_24_ADMIN, COLLECTION_24_SUBMIT\n        List<Collection> group2GroupToCollection = findGroup2GroupMapped(context, actionID);\n\n        for (Collection aGroup2GroupToCollection : group2GroupToCollection) {\n            if (!myResults.contains(aGroup2GroupToCollection)) {\n                myResults.add(aGroup2GroupToCollection);\n            }\n        }\n\n        //TODO Check eperson->groups->groups->policy->community\n\n\n        //TODO Check eperson->groups->policy->community\n        // i.e. Typical Community Admin -- name.# > COMMUNITY_10_ADMIN > Ohio State University Press\n\n        //Check eperson->comm-admin\n        List<Collection> group2commCollections = findGroup2CommunityMapped(context);\n        for (Collection group2commCollection : group2commCollections) {\n            if (!myResults.contains(group2commCollection)) {\n                myResults.add(group2commCollection);\n            }\n        }\n\n\n        // Return the collections, sorted alphabetically\n        Collections.sort(myResults, new CollectionNameComparator());\n\n        return myResults;\n    }\n\n    @Override\n    public List<Collection> findDirectMapped(Context context, int actionID) throws SQLException {\n        return collectionDAO\n            .findAuthorized(context, context.getCurrentUser(), Arrays.asList(Constants.ADD, Constants.ADMIN));\n    }\n\n    @Override\n    public List<Collection> findGroup2CommunityMapped(Context context) throws SQLException {\n        List<Community> communities = communityService\n            .findAuthorizedGroupMapped(context, Arrays.asList(Constants.ADD, Constants.ADMIN));\n        List<Collection> collections = new ArrayList<>();\n        for (Community community : communities) {\n            collections.addAll(community.getCollections());\n        }\n        return collections;\n    }\n\n    @Override\n    public List<Collection> findGroup2GroupMapped(Context context, int actionID) throws SQLException {\n        return collectionDAO\n            .findAuthorizedByGroup(context, context.getCurrentUser(), Collections.singletonList(actionID));\n    }\n\n    @Override\n    public List<Collection> findGroupMapped(Context context, int actionID) throws SQLException {\n        List<Community> communities = communityService\n            .findAuthorized(context, Arrays.asList(Constants.ADD, Constants.ADMIN));\n        List<Collection> collections = new ArrayList<>();\n        for (Community community : communities) {\n            collections.addAll(community.getCollections());\n        }\n        return collections;\n    }\n\n    @Override\n    public Collection find(Context context, UUID id) throws SQLException {\n        return collectionDAO.findByID(context, Collection.class, id);\n    }\n\n    @Override\n    public void setMetadataSingleValue(Context context, Collection collection,\n            MetadataFieldName field, String language, String value)\n            throws MissingResourceException, SQLException {\n        if (field.equals(MD_NAME) && (value == null || value.trim().equals(\"\"))) {\n            try {\n                value = I18nUtil.getMessage(\"org.dspace.content.untitled\");\n            } catch (MissingResourceException e) {\n                value = \"Untitled\";\n            }\n        }\n\n        /*\n         * Set metadata field to null if null\n         * and trim strings to eliminate excess\n         * whitespace.\n         */\n        if (value == null) {\n            clearMetadata(context, collection, field.schema, field.element, field.qualifier, Item.ANY);\n            collection.setMetadataModified();\n        } else {\n            super.setMetadataSingleValue(context, collection, field, null, value);\n        }\n\n        collection.addDetails(field.toString());\n    }\n\n    @Override\n    public Bitstream setLogo(Context context, Collection collection, InputStream is)\n        throws AuthorizeException, IOException, SQLException {\n        // Check authorisation\n        // authorized to remove the logo when DELETE rights\n        // authorized when canEdit\n        if (!((is == null) && authorizeService.authorizeActionBoolean(\n            context, collection, Constants.DELETE))) {\n            canEdit(context, collection, true);\n        }\n\n        // First, delete any existing logo\n        if (collection.getLogo() != null) {\n            bitstreamService.delete(context, collection.getLogo());\n        }\n\n        if (is == null) {\n            collection.setLogo(null);\n            log.info(LogHelper.getHeader(context, \"remove_logo\",\n                                          \"collection_id=\" + collection.getID()));\n        } else {\n            Bitstream newLogo = bitstreamService.create(context, is);\n            collection.setLogo(newLogo);\n\n            // now create policy for logo bitstream\n            // to match our READ policy\n            List<ResourcePolicy> policies = authorizeService\n                .getPoliciesActionFilter(context, collection, Constants.READ);\n            authorizeService.addPolicies(context, policies, newLogo);\n\n            log.info(LogHelper.getHeader(context, \"set_logo\",\n                                          \"collection_id=\" + collection.getID() + \"logo_bitstream_id=\"\n                                              + newLogo.getID()));\n        }\n\n        collection.setModified();\n        return collection.getLogo();\n    }\n\n    @Override\n    public Group createWorkflowGroup(Context context, Collection collection, int step)\n        throws SQLException, AuthorizeException {\n        // Check authorisation - Must be an Admin to create Workflow Group\n        AuthorizeUtil.authorizeManageWorkflowsGroup(context, collection);\n\n        if (getWorkflowGroup(context, collection, step) == null) {\n            //turn off authorization so that Collection Admins can create Collection Workflow Groups\n            context.turnOffAuthorisationSystem();\n            Group g = groupService.create(context);\n            groupService.setName(g,\n                                 \"COLLECTION_\" + collection.getID() + \"_WORKFLOW_STEP_\" + step);\n            groupService.update(context, g);\n            context.restoreAuthSystemState();\n            setWorkflowGroup(context, collection, step, g);\n        }\n\n        return getWorkflowGroup(context, collection, step);\n    }\n\n    @Override\n    public void setWorkflowGroup(Context context, Collection collection, int step, Group group)\n        throws SQLException {\n        Workflow workflow = null;\n        try {\n            workflow = workflowFactory.getWorkflow(collection);\n        } catch (WorkflowConfigurationException e) {\n            log.error(LogHelper.getHeader(context, \"setWorkflowGroup\",\n                    \"collection_id=\" + collection.getID() + \" \" + e.getMessage()), e);\n        }\n        if (!StringUtils.equals(workflowFactory.getDefaultWorkflow().getID(), workflow.getID())) {\n            throw new IllegalArgumentException(\n                    \"setWorkflowGroup can be used only on collection with the default basic dspace workflow. \"\n                    + \"Instead, the collection: \"\n                            + collection.getID() + \" has the workflow: \" + workflow.getID());\n        }\n        String roleId;\n\n        switch (step) {\n            case 1:\n                roleId = CollectionRoleService.LEGACY_WORKFLOW_STEP1_NAME;\n                break;\n            case 2:\n                roleId = CollectionRoleService.LEGACY_WORKFLOW_STEP2_NAME;\n                break;\n            case 3:\n                roleId = CollectionRoleService.LEGACY_WORKFLOW_STEP3_NAME;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal step count: \" + step);\n        }\n\n        CollectionRole colRole = collectionRoleService.find(context, collection, roleId);\n        if (colRole == null) {\n            if (group != null) {\n                colRole = collectionRoleService.create(context, collection, roleId, group);\n            }\n        } else {\n            if (group != null) {\n                colRole.setGroup(group);\n                collectionRoleService.update(context, colRole);\n            } else {\n                collectionRoleService.delete(context, colRole);\n            }\n        }\n        collection.setModified();\n    }\n\n    @Override\n    public Group getWorkflowGroup(Context context, Collection collection, int step) {\n        String roleId;\n\n        switch (step) {\n            case 1:\n                roleId = CollectionRoleService.LEGACY_WORKFLOW_STEP1_NAME;\n                break;\n            case 2:\n                roleId = CollectionRoleService.LEGACY_WORKFLOW_STEP2_NAME;\n                break;\n            case 3:\n                roleId = CollectionRoleService.LEGACY_WORKFLOW_STEP3_NAME;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal step count: \" + step);\n        }\n\n        CollectionRole colRole;\n        try {\n            colRole = collectionRoleService.find(context, collection, roleId);\n            if (colRole != null) {\n                return colRole.getGroup();\n            }\n            return null;\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public Group createSubmitters(Context context, Collection collection) throws SQLException, AuthorizeException {\n        // Check authorisation - Must be an Admin to create Submitters Group\n        AuthorizeUtil.authorizeManageSubmittersGroup(context, collection);\n\n        Group submitters = collection.getSubmitters();\n        if (submitters == null) {\n            //turn off authorization so that Collection Admins can create Collection Submitters\n            context.turnOffAuthorisationSystem();\n            submitters = groupService.create(context);\n            context.restoreAuthSystemState();\n\n            groupService.setName(submitters,\n                                 \"COLLECTION_\" + collection.getID() + \"_SUBMIT\");\n            groupService.update(context, submitters);\n        }\n\n        // register this as the submitter group\n        collection.setSubmitters(submitters);\n\n        authorizeService.addPolicy(context, collection, Constants.ADD, submitters);\n\n        return submitters;\n    }\n\n    @Override\n    public void removeSubmitters(Context context, Collection collection) throws SQLException, AuthorizeException {\n        // Check authorisation - Must be an Admin to delete Submitters Group\n        AuthorizeUtil.authorizeManageSubmittersGroup(context, collection);\n\n        // just return if there is no administrative group.\n        if (collection.getSubmitters() == null) {\n            return;\n        }\n\n        // Remove the link to the collection table.\n        collection.setSubmitters(null);\n    }\n\n    @Override\n    public Group createAdministrators(Context context, Collection collection) throws SQLException, AuthorizeException {\n        // Check authorisation - Must be an Admin to create more Admins\n        AuthorizeUtil.authorizeManageAdminGroup(context, collection);\n\n        Group admins = collection.getAdministrators();\n        if (admins == null) {\n            //turn off authorization so that Community Admins can create Collection Admins\n            context.turnOffAuthorisationSystem();\n            admins = groupService.create(context);\n            context.restoreAuthSystemState();\n\n            groupService.setName(admins, \"COLLECTION_\" + collection.getID() + \"_ADMIN\");\n            groupService.update(context, admins);\n        }\n\n        authorizeService.addPolicy(context, collection,\n                                   Constants.ADMIN, admins);\n\n        // register this as the admin group\n        collection.setAdmins(admins);\n        context.addEvent(new Event(Event.MODIFY, Constants.COLLECTION, collection.getID(),\n                                              null, getIdentifiers(context, collection)));\n        return admins;\n    }\n\n    @Override\n    public void removeAdministrators(Context context, Collection collection) throws SQLException, AuthorizeException {\n        // Check authorisation - Must be an Admin of the parent community to delete Admin Group\n        AuthorizeUtil.authorizeRemoveAdminGroup(context, collection);\n\n        Group admins = collection.getAdministrators();\n        // just return if there is no administrative group.\n        if (admins == null) {\n            return;\n        }\n\n        // Remove the link to the collection table.\n        collection.setAdmins(null);\n        context.addEvent(new Event(Event.MODIFY, Constants.COLLECTION, collection.getID(),\n                                              null, getIdentifiers(context, collection)));\n    }\n\n    @Override\n    public String getLicense(Collection collection) {\n        String license = getMetadataFirstValue(collection, CollectionService.MD_LICENSE, Item.ANY);\n\n        if (license == null || license.trim().equals(\"\")) {\n            // Fallback to site-wide default\n            license = licenseService.getDefaultSubmissionLicense();\n        }\n\n        return license;\n    }\n\n    @Override\n    public boolean hasCustomLicense(Collection collection) {\n        String license = collection.getLicenseCollection();\n        return StringUtils.isNotBlank(license);\n    }\n\n    @Override\n    public void createTemplateItem(Context context, Collection collection) throws SQLException, AuthorizeException {\n        // Check authorisation\n        AuthorizeUtil.authorizeManageTemplateItem(context, collection);\n\n        if (collection.getTemplateItem() == null) {\n            Item template = itemService.createTemplateItem(context, collection);\n            collection.setTemplateItem(template);\n\n            log.info(LogHelper.getHeader(context, \"create_template_item\",\n                                          \"collection_id=\" + collection.getID() + \",template_item_id=\"\n                                              + template.getID()));\n        }\n    }\n\n    @Override\n    public void removeTemplateItem(Context context, Collection collection)\n        throws SQLException, AuthorizeException, IOException {\n        // Check authorisation\n        AuthorizeUtil.authorizeManageTemplateItem(context, collection);\n\n        Item template = collection.getTemplateItem();\n\n        if (template != null) {\n            log.info(LogHelper.getHeader(context, \"remove_template_item\",\n                                          \"collection_id=\" + collection.getID() + \",template_item_id=\"\n                                              + template.getID()));\n            // temporarily turn off auth system, we have already checked the permission on the top of the method\n            // check it again will fail because we have already broken the relation between the collection and the item\n            context.turnOffAuthorisationSystem();\n            collection.setTemplateItem(null);\n            itemService.delete(context, template);\n            context.restoreAuthSystemState();\n        }\n\n        context.addEvent(new Event(Event.MODIFY, Constants.COLLECTION,\n                                   collection.getID(), \"remove_template_item\", getIdentifiers(context, collection)));\n    }\n\n    @Override\n    public void addItem(Context context, Collection collection, Item item) throws SQLException, AuthorizeException {\n        // Check authorisation\n        authorizeService.authorizeAction(context, collection, Constants.ADD);\n\n        log.info(LogHelper.getHeader(context, \"add_item\", \"collection_id=\"\n            + collection.getID() + \",item_id=\" + item.getID()));\n\n        // Create mapping\n        // We do NOT add the item to the collection template since we would have to load in all our items\n        // Instead we add the collection to an item which works in the same way.\n        if (!item.getCollections().contains(collection)) {\n            item.addCollection(collection);\n        }\n\n        context.addEvent(new Event(Event.ADD, Constants.COLLECTION, collection.getID(),\n                                   Constants.ITEM, item.getID(), item.getHandle(),\n                                   getIdentifiers(context, collection)));\n    }\n\n    @Override\n    public void removeItem(Context context, Collection collection, Item item)\n        throws SQLException, AuthorizeException, IOException {\n        // Check authorisation\n        authorizeService.authorizeAction(context, collection, Constants.REMOVE);\n\n        //Check if we orphaned our poor item\n        if (item.getCollections().size() == 1) {\n            // Orphan; delete it\n            itemService.delete(context, item);\n        } else {\n            //Remove the item from the collection if we have multiple collections\n            item.removeCollection(collection);\n\n        }\n\n        context.addEvent(new Event(Event.REMOVE, Constants.COLLECTION,\n                                   collection.getID(), Constants.ITEM, item.getID(), item.getHandle(),\n                                   getIdentifiers(context, collection)));\n    }\n\n    @Override\n    public void update(Context context, Collection collection) throws SQLException, AuthorizeException {\n        // Check authorisation\n        canEdit(context, collection, true);\n\n        log.info(LogHelper.getHeader(context, \"update_collection\",\n                                      \"collection_id=\" + collection.getID()));\n\n        super.update(context, collection);\n        collectionDAO.save(context, collection);\n\n        if (collection.isModified()) {\n            context.addEvent(new Event(Event.MODIFY, Constants.COLLECTION,\n                                       collection.getID(), null, getIdentifiers(context, collection)));\n            collection.clearModified();\n        }\n        if (collection.isMetadataModified()) {\n            context.addEvent(new Event(Event.MODIFY_METADATA, Constants.COLLECTION, collection.getID(),\n                                         collection.getDetails(),getIdentifiers(context, collection)));\n            collection.clearModified();\n        }\n        collection.clearDetails();\n    }\n\n    @Override\n    public boolean canEditBoolean(Context context, Collection collection) throws SQLException {\n        return canEditBoolean(context, collection, true);\n    }\n\n    @Override\n    public boolean canEditBoolean(Context context, Collection collection, boolean useInheritance) throws SQLException {\n        try {\n            canEdit(context, collection, useInheritance);\n\n            return true;\n        } catch (AuthorizeException e) {\n            return false;\n        }\n    }\n\n    @Override\n    public void canEdit(Context context, Collection collection) throws SQLException, AuthorizeException {\n        canEdit(context, collection, true);\n    }\n\n    @Override\n    public void canEdit(Context context, Collection collection, boolean useInheritance)\n        throws SQLException, AuthorizeException {\n        List<Community> parents = communityService.getAllParents(context, collection);\n        for (Community parent : parents) {\n            if (authorizeService.authorizeActionBoolean(context, parent,\n                                                        Constants.WRITE, useInheritance)) {\n                return;\n            }\n\n            if (authorizeService.authorizeActionBoolean(context, parent,\n                                                        Constants.ADD, useInheritance)) {\n                return;\n            }\n        }\n        authorizeService.authorizeAction(context, collection, Constants.WRITE, useInheritance);\n    }\n\n    @Override\n    public void delete(Context context, Collection collection) throws SQLException, AuthorizeException, IOException {\n        log.info(LogHelper.getHeader(context, \"delete_collection\",\n                                      \"collection_id=\" + collection.getID()));\n\n        // remove harvested collections.\n        HarvestedCollection hc = harvestedCollectionService.find(context, collection);\n        if (hc != null) {\n            harvestedCollectionService.delete(context, hc);\n        }\n\n        context.addEvent(new Event(Event.DELETE, Constants.COLLECTION,\n                                   collection.getID(), collection.getHandle(), getIdentifiers(context, collection)));\n\n        // remove subscriptions - hmm, should this be in Subscription.java?\n        subscribeService.deleteByCollection(context, collection);\n\n        // Remove Template Item\n        removeTemplateItem(context, collection);\n\n        // Remove items\n        // Remove items\n        Iterator<Item> items = itemService.findAllByCollection(context, collection);\n        while (items.hasNext()) {\n            Item item = items.next();\n//            items.remove();\n            if (itemService.isOwningCollection(item, collection)) {\n                // the collection to be deleted is the owning collection, thus remove\n                // the item from all collections it belongs to\n                itemService.delete(context, item);\n            } else {\n                // the item was only mapped to this collection, so just remove it\n                removeItem(context, collection, item);\n            }\n        }\n\n\n        // Delete bitstream logo\n        setLogo(context, collection, null);\n\n        Iterator<WorkspaceItem> workspaceItems = workspaceItemService.findByCollection(context, collection).iterator();\n        while (workspaceItems.hasNext()) {\n            WorkspaceItem workspaceItem = workspaceItems.next();\n            workspaceItems.remove();\n            workspaceItemService.deleteAll(context, workspaceItem);\n        }\n\n\n        WorkflowServiceFactory.getInstance().getWorkflowService().deleteCollection(context, collection);\n        WorkflowServiceFactory.getInstance().getWorkflowItemService().deleteByCollection(context, collection);\n\n        //  get rid of the content count cache if it exists\n        // Remove any Handle\n        handleService.unbindHandle(context, collection);\n\n        // Remove any workflow roles\n        collectionRoleService.deleteByCollection(context, collection);\n\n        collection.getResourcePolicies().clear();\n\n        // Remove default administrators group\n        Group g = collection.getAdministrators();\n\n        if (g != null) {\n            collection.setAdmins(null);\n            groupService.delete(context, g);\n        }\n\n        // Remove default submitters group\n        g = collection.getSubmitters();\n\n        if (g != null) {\n            collection.setSubmitters(null);\n            groupService.delete(context, g);\n        }\n\n        Iterator<Community> owningCommunities = collection.getCommunities().iterator();\n        while (owningCommunities.hasNext()) {\n            Community owningCommunity = owningCommunities.next();\n            collection.removeCommunity(owningCommunity);\n            owningCommunity.removeCollection(collection);\n        }\n\n        collectionDAO.delete(context, collection);\n    }\n\n    @Override\n    public int getSupportsTypeConstant() {\n        return Constants.COLLECTION;\n    }\n\n    @Override\n    public List<Collection> findAuthorized(Context context, Community community, int actionID) throws SQLException {\n        List<Collection> myResults = new ArrayList<>();\n\n        List<Collection> myCollections;\n\n        if (community != null) {\n            myCollections = community.getCollections();\n        } else {\n            myCollections = findAll(context);\n        }\n\n        // now build a list of collections you have authorization for\n        for (Collection myCollection : myCollections) {\n            if (authorizeService.authorizeActionBoolean(context,\n                                                        myCollection, actionID)) {\n                myResults.add(myCollection);\n            }\n        }\n        return myResults;\n    }\n\n    @Override\n    public Collection findByGroup(Context context, Group group) throws SQLException {\n        return collectionDAO.findByGroup(context, group);\n    }\n\n    @Override\n    public List<Collection> findCollectionsWithSubscribers(Context context) throws SQLException {\n        return collectionDAO.findCollectionsWithSubscribers(context);\n    }\n\n    @Override\n    public DSpaceObject getAdminObject(Context context, Collection collection, int action) throws SQLException {\n        DSpaceObject adminObject = null;\n        Community community = null;\n        List<Community> communities = collection.getCommunities();\n        if (CollectionUtils.isNotEmpty(communities)) {\n            community = communities.get(0);\n        }\n\n        switch (action) {\n            case Constants.REMOVE:\n                if (AuthorizeConfiguration.canCollectionAdminPerformItemDeletion()) {\n                    adminObject = collection;\n                } else if (AuthorizeConfiguration.canCommunityAdminPerformItemDeletion()) {\n                    adminObject = community;\n                }\n                break;\n\n            case Constants.DELETE:\n                if (AuthorizeConfiguration.canCommunityAdminPerformSubelementDeletion()) {\n                    adminObject = community;\n                }\n                break;\n            default:\n                adminObject = collection;\n                break;\n        }\n        return adminObject;\n    }\n\n    @Override\n    public DSpaceObject getParentObject(Context context, Collection collection) throws SQLException {\n        List<Community> communities = collection.getCommunities();\n        if (CollectionUtils.isNotEmpty(communities)) {\n            return communities.get(0);\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public void updateLastModified(Context context, Collection collection) throws SQLException, AuthorizeException {\n        //Also fire a modified event since the collection HAS been modified\n        context.addEvent(new Event(Event.MODIFY, Constants.COLLECTION,\n                                   collection.getID(), null, getIdentifiers(context, collection)));\n    }\n\n    @Override\n    public Collection findByIdOrLegacyId(Context context, String id) throws SQLException {\n        if (StringUtils.isNumeric(id)) {\n            return findByLegacyId(context, Integer.parseInt(id));\n        } else {\n            return find(context, UUID.fromString(id));\n        }\n    }\n\n    @Override\n    public Collection findByLegacyId(Context context, int id) throws SQLException {\n        return collectionDAO.findByLegacyId(context, id, Collection.class);\n    }\n\n    @Override\n    public int countTotal(Context context) throws SQLException {\n        return collectionDAO.countRows(context);\n    }\n\n    @Override\n    public List<Map.Entry<Collection, Long>> getCollectionsWithBitstreamSizesTotal(Context context)\n        throws SQLException {\n        return collectionDAO.getCollectionsWithBitstreamSizesTotal(context);\n    }\n\n    @Override\n    public Group createDefaultReadGroup(Context context, Collection collection, String typeOfGroupString,\n                                        int defaultRead)\n        throws SQLException, AuthorizeException {\n        Group role = groupService.create(context);\n        groupService.setName(role, getDefaultReadGroupName(collection, typeOfGroupString));\n\n        // Remove existing privileges from the anonymous group.\n        authorizeService.removePoliciesActionFilter(context, collection, defaultRead);\n\n        // Grant our new role the default privileges.\n        authorizeService.addPolicy(context, collection, defaultRead, role);\n        groupService.update(context, role);\n        return role;\n    }\n\n    @Override\n    public String getDefaultReadGroupName(Collection collection, String typeOfGroupString) {\n        return \"COLLECTION_\" + collection.getID().toString() + \"_\" + typeOfGroupString +\n            \"_DEFAULT_READ\";\n    }\n\n    @Override\n    public List<Collection> findCollectionsWithSubmit(String q, Context context, Community community,\n        int offset, int limit) throws SQLException, SearchServiceException {\n\n        List<Collection> collections = new ArrayList<>();\n        DiscoverQuery discoverQuery = new DiscoverQuery();\n        discoverQuery.setDSpaceObjectFilter(IndexableCollection.TYPE);\n        discoverQuery.setStart(offset);\n        discoverQuery.setMaxResults(limit);\n        DiscoverResult resp = retrieveCollectionsWithSubmit(context, discoverQuery, null, community, q);\n        for (IndexableObject solrCollections : resp.getIndexableObjects()) {\n            Collection c = ((IndexableCollection) solrCollections).getIndexedObject();\n            collections.add(c);\n        }\n        return collections;\n    }\n\n    @Override\n    public int countCollectionsWithSubmit(String q, Context context, Community community)\n        throws SQLException, SearchServiceException {\n\n        DiscoverQuery discoverQuery = new DiscoverQuery();\n        discoverQuery.setMaxResults(0);\n        discoverQuery.setDSpaceObjectFilter(IndexableCollection.TYPE);\n        DiscoverResult resp = retrieveCollectionsWithSubmit(context, discoverQuery, null, community, q);\n        return (int)resp.getTotalSearchResults();\n    }\n\n    /**\n     * Finds all Indexed Collections where the current user has submit rights. If the user is an Admin,\n     * this is all Indexed Collections. Otherwise, it includes those collections where\n     * an indexed \"submit\" policy lists either the eperson or one of the eperson's groups\n     *\n     * @param context                    DSpace context\n     * @param discoverQuery\n     * @param entityType                 limit the returned collection to those related to given entity type\n     * @param community                  parent community, could be null\n     * @param q                          limit the returned collection to those with metadata values matching the query\n     *                                   terms. The terms are used to make also a prefix query on SOLR\n     *                                   so it can be used to implement an autosuggest feature over the collection name\n     * @return                           discovery search result objects\n     * @throws SQLException              if something goes wrong\n     * @throws SearchServiceException    if search error\n     */\n    private DiscoverResult retrieveCollectionsWithSubmit(Context context, DiscoverQuery discoverQuery,\n        String entityType, Community community, String q)\n        throws SQLException, SearchServiceException {\n\n        StringBuilder query = new StringBuilder();\n        EPerson currentUser = context.getCurrentUser();\n        if (!authorizeService.isAdmin(context)) {\n            String userId = \"\";\n            if (currentUser != null) {\n                userId = currentUser.getID().toString();\n            }\n            query.append(\"submit:(e\").append(userId);\n\n            Set<Group> groups = groupService.allMemberGroupsSet(context, currentUser);\n            for (Group group : groups) {\n                query.append(\" OR g\").append(group.getID());\n            }\n            query.append(\")\");\n            discoverQuery.addFilterQueries(query.toString());\n        }\n        if (Objects.nonNull(community)) {\n            discoverQuery.addFilterQueries(\"location.comm:\" + community.getID().toString());\n        }\n        if (StringUtils.isNotBlank(entityType)) {\n            discoverQuery.addFilterQueries(\"search.entitytype:\" + entityType);\n        }\n        if (StringUtils.isNotBlank(q)) {\n            StringBuilder buildQuery = new StringBuilder();\n            String escapedQuery = ClientUtils.escapeQueryChars(q);\n            buildQuery.append(escapedQuery).append(\" OR \").append(escapedQuery).append(\"*\");\n            discoverQuery.setQuery(buildQuery.toString());\n        }\n        DiscoverResult resp = searchService.search(context, discoverQuery);\n        return resp;\n    }\n\n    @Override\n    public List<Collection> findCollectionsWithSubmit(String q, Context context, Community community, String entityType,\n            int offset, int limit) throws SQLException, SearchServiceException {\n        List<Collection> collections = new ArrayList<>();\n        DiscoverQuery discoverQuery = new DiscoverQuery();\n        discoverQuery.setDSpaceObjectFilter(IndexableCollection.TYPE);\n        discoverQuery.setStart(offset);\n        discoverQuery.setMaxResults(limit);\n        DiscoverResult resp = retrieveCollectionsWithSubmit(context, discoverQuery,\n                entityType, community, q);\n        for (IndexableObject solrCollections : resp.getIndexableObjects()) {\n            Collection c = ((IndexableCollection) solrCollections).getIndexedObject();\n            collections.add(c);\n        }\n        return collections;\n    }\n\n    @Override\n    public int countCollectionsWithSubmit(String q, Context context, Community community, String entityType)\n            throws SQLException, SearchServiceException {\n        DiscoverQuery discoverQuery = new DiscoverQuery();\n        discoverQuery.setMaxResults(0);\n        discoverQuery.setDSpaceObjectFilter(IndexableCollection.TYPE);\n        DiscoverResult resp = retrieveCollectionsWithSubmit(context, discoverQuery, entityType, community, q);\n        return (int) resp.getTotalSearchResults();\n    }\n\n}\n", "/**\n * The contents of this file are subject to the license and copyright\n * detailed in the LICENSE and NOTICE files at the root of the source\n * tree and available online at\n *\n * http://www.dspace.org/license/\n */\npackage org.dspace.content.service;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.sql.SQLException;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.UUID;\n\nimport org.dspace.authorize.AuthorizeException;\nimport org.dspace.content.Bitstream;\nimport org.dspace.content.Collection;\nimport org.dspace.content.Community;\nimport org.dspace.content.Item;\nimport org.dspace.core.Context;\nimport org.dspace.discovery.SearchServiceException;\nimport org.dspace.eperson.Group;\n\n/**\n * Service interface class for the Collection object.\n * The implementation of this class is responsible for all business logic calls\n * for the Collection object and is autowired by Spring.\n *\n * @author kevinvandevelde at atmire.com\n */\npublic interface CollectionService\n        extends DSpaceObjectService<Collection>, DSpaceObjectLegacySupportService<Collection> {\n\n    /**\n     * Create a new collection with a new ID.\n     * Once created the collection is added to the given community\n     *\n     * @param context   DSpace context object\n     * @param community DSpace Community (parent)\n     * @return the newly created collection\n     * @throws SQLException       if database error\n     * @throws AuthorizeException if authorization error\n     */\n    public Collection create(Context context, Community community) throws SQLException,\n        AuthorizeException;\n\n\n    /**\n     * Create a new collection with the supplied handle and with a new ID.\n     * Once created the collection is added to the given community\n     *\n     * @param context   DSpace context object\n     * @param community DSpace Community (parent)\n     * @param handle    the pre-determined Handle to assign to the new community\n     * @return the newly created collection\n     * @throws SQLException       if database error\n     * @throws AuthorizeException if authorization error\n     */\n    public Collection create(Context context, Community community, String handle) throws SQLException,\n        AuthorizeException;\n\n    /**\n     * Create a new collection with the supplied handle and ID.\n     * Once created the collection is added to the given community\n     *\n     * @param context DSpace context object\n     * @param community DSpace Community (parent)\n     * @param handle the pre-determined Handle to assign to the new collection\n     * @param uuid the pre-determined UUID to assign to the new collection\n     * @return the newly created collection\n     * @throws SQLException if database error\n     * @throws AuthorizeException if authorization error\n     */\n    public Collection create(Context context, Community community, String handle, UUID uuid) throws SQLException,\n            AuthorizeException;\n\n    /**\n     * Get all collections in the system. These are alphabetically sorted by\n     * collection name.\n     *\n     * @param context DSpace context object\n     * @return the collections in the system\n     * @throws SQLException if database error\n     */\n    public List<Collection> findAll(Context context) throws SQLException;\n\n    /**\n     * Get all collections in the system. Adds support for limit and offset.\n     *\n     * @param context The relevant DSpace Context.\n     * @param limit   paging limit\n     * @param offset  paging offset\n     * @return List of Collections\n     * @throws SQLException if database error\n     */\n    public List<Collection> findAll(Context context, Integer limit, Integer offset) throws SQLException;\n\n    public List<Collection> findAuthorizedOptimized(Context context, int actionID) throws java.sql.SQLException;\n\n    public List<Collection> findDirectMapped(Context context, int actionID) throws java.sql.SQLException;\n\n    public List<Collection> findGroup2CommunityMapped(Context context) throws SQLException;\n\n    public List<Collection> findGroup2GroupMapped(Context context, int actionID) throws SQLException;\n\n    public List<Collection> findGroupMapped(Context context, int actionID) throws java.sql.SQLException;\n\n    /**\n     * Give the collection a logo. Passing in <code>null</code> removes any\n     * existing logo. You will need to set the format of the new logo bitstream\n     * before it will work, for example to \"JPEG\". Note that\n     * <code>update</code> will need to be called for the change to take\n     * effect.  Setting a logo and not calling <code>update</code> later may\n     * result in a previous logo lying around as an \"orphaned\" bitstream.\n     *\n     * @param context    DSpace Context\n     * @param collection Collection\n     * @param is         the stream to use as the new logo\n     * @return the new logo bitstream, or <code>null</code> if there is no\n     * logo (<code>null</code> was passed in)\n     * @throws AuthorizeException if authorization error\n     * @throws IOException        if IO error\n     * @throws SQLException       if database error\n     */\n    public Bitstream setLogo(Context context, Collection collection, InputStream is) throws AuthorizeException,\n        IOException, SQLException;\n\n    /**\n     * Create a workflow group for the given step if one does not already exist.\n     * Returns either the newly created group or the previously existing one.\n     * Note that while the new group is created in the database, the association\n     * between the group and the collection is not written until\n     * <code>update</code> is called.\n     *\n     * @param context    DSpace Context\n     * @param collection Collection\n     * @param step       the step (1-3) of the workflow to create or get the group for\n     * @return the workflow group associated with this collection\n     * @throws SQLException       if database error\n     * @throws AuthorizeException if authorization error\n     */\n    public Group createWorkflowGroup(Context context, Collection collection, int step) throws SQLException,\n        AuthorizeException;\n\n    /**\n     * Set the workflow group corresponding to a particular workflow step.\n     * <code>null</code> can be passed in if there should be no associated\n     * group for that workflow step; any existing group is NOT deleted.\n     *\n     * @param context    current DSpace session.\n     * @param collection Collection\n     * @param step       the workflow step (1-3)\n     * @param group      the new workflow group, or <code>null</code>\n     * @throws SQLException passed through.\n     * @throws AuthorizeException passed through.\n     */\n    public void setWorkflowGroup(Context context, Collection collection, int step, Group group)\n        throws SQLException, AuthorizeException;\n\n    /**\n     * Get the the workflow group corresponding to a particular workflow step.\n     * This returns <code>null</code> if there is no group associated with\n     * this collection for the given step.\n     *\n     * @param context    DSpace Context\n     * @param collection Collection\n     * @param step       the workflow step (1-3)\n     * @return the group of reviewers or <code>null</code>\n     */\n    public Group getWorkflowGroup(Context context, Collection collection, int step);\n\n    /**\n     * Create a default submitters group if one does not already exist. Returns\n     * either the newly created group or the previously existing one. Note that\n     * other groups may also be allowed to submit to this collection by the\n     * authorization system.\n     *\n     * @param context    DSpace Context\n     * @param collection Collection\n     * @return the default group of submitters associated with this collection\n     * @throws SQLException       if database error\n     * @throws AuthorizeException if authorization error\n     */\n    public Group createSubmitters(Context context, Collection collection) throws SQLException, AuthorizeException;\n\n    /**\n     * Remove the submitters group, if no group has already been created\n     * then return without error. This will merely dereference the current\n     * submitters group from the collection so that it may be deleted\n     * without violating database constraints.\n     *\n     * @param context    DSpace Context\n     * @param collection Collection\n     * @throws SQLException       if database error\n     * @throws AuthorizeException if authorization error\n     */\n    public void removeSubmitters(Context context, Collection collection) throws SQLException, AuthorizeException;\n\n\n    /**\n     * Create a default administrators group if one does not already exist.\n     * Returns either the newly created group or the previously existing one.\n     * Note that other groups may also be administrators.\n     *\n     * @param context    DSpace Context\n     * @param collection Collection\n     * @return the default group of editors associated with this collection\n     * @throws SQLException       if database error\n     * @throws AuthorizeException if authorization error\n     */\n    public Group createAdministrators(Context context, Collection collection) throws SQLException, AuthorizeException;\n\n    /**\n     * Remove the administrators group, if no group has already been created\n     * then return without error. This will merely dereference the current\n     * administrators group from the collection so that it may be deleted\n     * without violating database constraints.\n     *\n     * @param context    DSpace Context\n     * @param collection Collection\n     * @throws SQLException       if database error\n     * @throws AuthorizeException if authorization error\n     */\n    public void removeAdministrators(Context context, Collection collection) throws SQLException, AuthorizeException;\n\n    /**\n     * Get the license that users must grant before submitting to this\n     * collection. If the collection does not have a specific license, the\n     * site-wide default is returned.\n     *\n     * @param collection Collection\n     * @return the license for this collection\n     */\n    public String getLicense(Collection collection);\n\n    /**\n     * Find out if the collection has a custom license\n     *\n     * @param collection Collection\n     * @return <code>true</code> if the collection has a custom license\n     */\n    public boolean hasCustomLicense(Collection collection);\n\n    /**\n     * Create an empty template item for this collection. If one already exists,\n     * no action is taken. Caution: Make sure you call <code>update</code> on\n     * the collection after doing this, or the item will have been created but\n     * the collection record will not refer to it.\n     *\n     * @param context    DSpace Context\n     * @param collection Collection\n     * @throws SQLException       if database error\n     * @throws AuthorizeException if authorization error\n     */\n    public void createTemplateItem(Context context, Collection collection) throws SQLException, AuthorizeException;\n\n    /**\n     * Remove the template item for this collection, if there is one. Note that\n     * since this has to remove the old template item ID from the collection\n     * record in the database, the collection record will be changed, including\n     * any other changes made; in other words, this method does an\n     * <code>update</code>.\n     *\n     * @param context    DSpace Context\n     * @param collection Collection\n     * @throws SQLException       if database error\n     * @throws AuthorizeException if authorization error\n     * @throws IOException        if IO error\n     */\n    public void removeTemplateItem(Context context, Collection collection)\n        throws SQLException, AuthorizeException, IOException;\n\n    /**\n     * Add an item to the collection. This simply adds a relationship between\n     * the item and the collection - it does nothing like set an issue date,\n     * remove a personal workspace item etc. This has instant effect;\n     * <code>update</code> need not be called.\n     *\n     * @param context    DSpace Context\n     * @param collection Collection\n     * @param item       item to add\n     * @throws SQLException       if database error\n     * @throws AuthorizeException if authorization error\n     */\n    public void addItem(Context context, Collection collection, Item item) throws SQLException, AuthorizeException;\n\n    /**\n     * Remove an item. If the item is then orphaned, it is deleted.\n     *\n     * @param context    DSpace Context\n     * @param collection Collection\n     * @param item       item to remove\n     * @throws SQLException       if database error\n     * @throws AuthorizeException if authorization error\n     * @throws IOException        if IO error\n     */\n    public void removeItem(Context context, Collection collection, Item item) throws SQLException, AuthorizeException,\n        IOException;\n\n    public boolean canEditBoolean(Context context, Collection collection) throws SQLException;\n\n    public boolean canEditBoolean(Context context, Collection collection, boolean useInheritance)\n        throws java.sql.SQLException;\n\n    public void canEdit(Context context, Collection collection) throws SQLException, AuthorizeException;\n\n    public void canEdit(Context context, Collection collection, boolean useInheritance)\n        throws SQLException, AuthorizeException;\n\n    /**\n     * return an array of collections that user has a given permission on\n     * (useful for trimming 'select to collection' list) or figuring out which\n     * collections a person is an editor for.\n     *\n     * @param context   DSpace Context\n     * @param community (optional) restrict search to a community, else null\n     * @param actionID  of the action\n     * @return Collection [] of collections with matching permissions\n     * @throws SQLException if database error\n     */\n    public List<Collection> findAuthorized(Context context, Community community, int actionID)\n        throws java.sql.SQLException;\n\n    /**\n     *\n     * @param context DSpace Context\n     * @param group EPerson Group\n     * @return the collection, if any, that has the specified group as administrators or submitters\n     * @throws SQLException\n     */\n    public Collection findByGroup(Context context, Group group) throws SQLException;\n\n    List<Collection> findCollectionsWithSubscribers(Context context) throws SQLException;\n\n    int countTotal(Context context) throws SQLException;\n\n    /**\n     * The map entry returned contains a collection as a key and sum of bitstream sizes in bytes as a value\n     *\n     * @param context DSpace Context\n     * @return List of Collections and bitstream sizes map\n     * @throws SQLException if database error\n     */\n    List<Map.Entry<Collection, Long>> getCollectionsWithBitstreamSizesTotal(Context context) throws SQLException;\n\n    /**\n     * This method will create a default read group for the given Collection. It'll create either a defaultItemRead or\n     * a defaultBitstreamRead group depending on the given parameters\n     *\n     * @param context           The relevant DSpace context\n     * @param collection        The collection for which it'll be created\n     * @param typeOfGroupString The type of group to be made, item or bitstream\n     * @param defaultRead       The defaultRead int, item or bitstream\n     * @return                  The created Group\n     * @throws SQLException     If something goes wrong\n     * @throws AuthorizeException   If something goes wrong\n     */\n    Group createDefaultReadGroup(Context context, Collection collection, String typeOfGroupString, int defaultRead)\n        throws SQLException, AuthorizeException;\n\n    /**\n     * This method will return the name to give to the group created by the\n     * {@link #createDefaultReadGroup(Context, Collection, String, int)} method\n     * \n     * @param collection        The DSpace collection to use in the name generation\n     * @param typeOfGroupString The type of group to use in the name generation\n     * @return the name to give to the group that hold default read for the collection\n     */\n    String getDefaultReadGroupName(Collection collection, String typeOfGroupString);\n\n    /**\n     * Returns Collections for which the current user has 'submit' privileges.\n     * NOTE: for better performance, this method retrieves its results from an\n     *       index (cache) and does not query the database directly.\n     *       This means that results may be stale or outdated until https://github.com/DSpace/DSpace/issues/2853 is resolved\"\n     * \n     * @param q                limit the returned collection to those with metadata values matching the query terms.\n     *                         The terms are used to make also a prefix query on SOLR so it can be used to implement\n     *                         an autosuggest feature over the collection name\n     * @param context          DSpace Context\n     * @param community        parent community\n     * @param entityType       limit the returned collection to those related to given entity type\n     * @param offset           the position of the first result to return\n     * @param limit            paging limit\n     * @return                 discovery search result objects\n     * @throws SQLException              if something goes wrong\n     * @throws SearchServiceException    if search error\n     */\n    public List<Collection> findCollectionsWithSubmit(String q, Context context, Community community,\n            String entityType, int offset, int limit) throws SQLException, SearchServiceException;\n\n    /**\n     * Returns Collections for which the current user has 'submit' privileges.\n     * NOTE: for better performance, this method retrieves its results from an\n     *       index (cache) and does not query the database directly.\n     *       This means that results may be stale or outdated until\n     *       https://github.com/DSpace/DSpace/issues/2853 is resolved\"\n     * \n     * @param q                limit the returned collection to those with metadata values matching the query terms.\n     *                         The terms are used to make also a prefix query on SOLR so it can be used to implement\n     *                         an autosuggest feature over the collection name\n     * @param context          DSpace Context\n     * @param community        parent community\n     * @param offset           the position of the first result to return\n     * @param limit            paging limit\n     * @return                 discovery search result objects\n     * @throws SQLException              if something goes wrong\n     * @throws SearchServiceException    if search error\n     */\n    public List<Collection> findCollectionsWithSubmit(String q, Context context, Community community,\n        int offset, int limit) throws SQLException, SearchServiceException;\n\n    /**\n     * Counts the number of Collection for which the current user has 'submit' privileges.\n     * NOTE: for better performance, this method retrieves its results from an index (cache)\n     *       and does not query the database directly.\n     *       This means that results may be stale or outdated until\n     *       https://github.com/DSpace/DSpace/issues/2853 is resolved.\"\n     * \n     * @param q                limit the returned collection to those with metadata values matching the query terms.\n     *                         The terms are used to make also a prefix query on SOLR so it can be used to implement\n     *                         an autosuggest feature over the collection name\n     * @param context          DSpace Context\n     * @param community        parent community\n     * @return                 total collections found\n     * @throws SQLException              if something goes wrong\n     * @throws SearchServiceException    if search error\n     */\n    public int countCollectionsWithSubmit(String q, Context context, Community community)\n        throws SQLException, SearchServiceException;\n\n    /**\n     * Counts the number of Collection for which the current user has 'submit' privileges.\n     * NOTE: for better performance, this method retrieves its results from an index (cache)\n     *       and does not query the database directly.\n     *       This means that results may be stale or outdated until\n     *       https://github.com/DSpace/DSpace/issues/2853 is resolved.\"\n     * \n     * @param q                limit the returned collection to those with metadata values matching the query terms.\n     *                         The terms are used to make also a prefix query on SOLR so it can be used to implement\n     *                         an autosuggest feature over the collection name\n     * @param context          DSpace Context\n     * @param community        parent community\n     * @param entityType       limit the returned collection to those related to given entity type\n     * @return                 total collections found\n     * @throws SQLException              if something goes wrong\n     * @throws SearchServiceException    if search error\n     */\n    public int countCollectionsWithSubmit(String q, Context context, Community community, String entityType)\n        throws SQLException, SearchServiceException;\n\n}\n", "/**\n * The contents of this file are subject to the license and copyright\n * detailed in the LICENSE and NOTICE files at the root of the source\n * tree and available online at\n *\n * http://www.dspace.org/license/\n */\npackage org.dspace.eperson;\n\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.UUID;\n\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.dspace.authorize.AuthorizeConfiguration;\nimport org.dspace.authorize.AuthorizeException;\nimport org.dspace.authorize.ResourcePolicy;\nimport org.dspace.authorize.service.AuthorizeService;\nimport org.dspace.authorize.service.ResourcePolicyService;\nimport org.dspace.content.Collection;\nimport org.dspace.content.DSpaceObject;\nimport org.dspace.content.DSpaceObjectServiceImpl;\nimport org.dspace.content.MetadataField;\nimport org.dspace.content.service.CollectionService;\nimport org.dspace.content.service.CommunityService;\nimport org.dspace.core.Constants;\nimport org.dspace.core.Context;\nimport org.dspace.core.LogHelper;\nimport org.dspace.eperson.dao.Group2GroupCacheDAO;\nimport org.dspace.eperson.dao.GroupDAO;\nimport org.dspace.eperson.factory.EPersonServiceFactory;\nimport org.dspace.eperson.service.EPersonService;\nimport org.dspace.eperson.service.GroupService;\nimport org.dspace.event.Event;\nimport org.dspace.util.UUIDUtils;\nimport org.dspace.xmlworkflow.Role;\nimport org.dspace.xmlworkflow.factory.XmlWorkflowFactory;\nimport org.dspace.xmlworkflow.state.Step;\nimport org.dspace.xmlworkflow.storedcomponents.ClaimedTask;\nimport org.dspace.xmlworkflow.storedcomponents.CollectionRole;\nimport org.dspace.xmlworkflow.storedcomponents.PoolTask;\nimport org.dspace.xmlworkflow.storedcomponents.service.ClaimedTaskService;\nimport org.dspace.xmlworkflow.storedcomponents.service.CollectionRoleService;\nimport org.dspace.xmlworkflow.storedcomponents.service.PoolTaskService;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\n\n/**\n * Service implementation for the Group object.\n * This class is responsible for all business logic calls for the Group object and is autowired by spring.\n * This class should never be accessed directly.\n *\n * @author kevinvandevelde at atmire.com\n */\npublic class GroupServiceImpl extends DSpaceObjectServiceImpl<Group> implements GroupService {\n    private static final Logger log = LoggerFactory.getLogger(GroupServiceImpl.class);\n\n    @Autowired(required = true)\n    protected GroupDAO groupDAO;\n\n    @Autowired(required = true)\n    protected Group2GroupCacheDAO group2GroupCacheDAO;\n\n    @Autowired(required = true)\n    protected CollectionService collectionService;\n\n    @Autowired(required = true)\n    protected CollectionRoleService collectionRoleService;\n\n    @Autowired(required = true)\n    protected EPersonService ePersonService;\n\n    @Autowired(required = true)\n    protected CommunityService communityService;\n\n    @Autowired(required = true)\n    protected AuthorizeService authorizeService;\n    @Autowired(required = true)\n    protected ResourcePolicyService resourcePolicyService;\n\n    @Autowired(required = true)\n    protected PoolTaskService poolTaskService;\n    @Autowired(required = true)\n    protected ClaimedTaskService claimedTaskService;\n    @Autowired(required = true)\n    protected XmlWorkflowFactory workflowFactory;\n\n    protected GroupServiceImpl() {\n        super();\n    }\n\n    @Override\n    public Group create(Context context) throws SQLException, AuthorizeException {\n        // FIXME - authorization?\n        if (!authorizeService.isAdmin(context)) {\n            throw new AuthorizeException(\n                \"You must be an admin to create an EPerson Group\");\n        }\n\n        // Create a table row\n        Group g = groupDAO.create(context, new Group());\n\n        log.info(LogHelper.getHeader(context, \"create_group\", \"group_id=\"\n            + g.getID()));\n\n        context.addEvent(new Event(Event.CREATE, Constants.GROUP, g.getID(), null, getIdentifiers(context, g)));\n        update(context, g);\n\n        return g;\n    }\n\n    @Override\n    public void setName(Group group, String name) throws SQLException {\n        if (group.isPermanent()) {\n            log.error(\"Attempt to rename permanent Group {} to {}.\",\n                      group.getName(), name);\n            throw new SQLException(\"Attempt to rename a permanent Group\");\n        } else {\n            group.setName(name);\n        }\n    }\n\n    @Override\n    public void addMember(Context context, Group group, EPerson e) {\n        if (isDirectMember(group, e)) {\n            return;\n        }\n        group.addMember(e);\n        e.getGroups().add(group);\n        context.addEvent(\n            new Event(Event.ADD, Constants.GROUP, group.getID(), Constants.EPERSON, e.getID(), e.getEmail(),\n                      getIdentifiers(context, group)));\n    }\n\n    @Override\n    public void addMember(Context context, Group groupParent, Group groupChild) throws SQLException {\n        // don't add if it's already a member\n        // and don't add itself\n        if (groupParent.contains(groupChild) || groupParent.getID() == groupChild.getID()) {\n            return;\n        }\n\n        groupParent.addMember(groupChild);\n        groupChild.addParentGroup(groupParent);\n\n        context.addEvent(new Event(Event.ADD, Constants.GROUP, groupParent.getID(), Constants.GROUP, groupChild.getID(),\n                                   groupChild.getName(), getIdentifiers(context, groupParent)));\n    }\n\n    /**\n     * Removes a member of a group.\n     * The removal will be refused if the group is linked to a workflow step which has claimed tasks or pool tasks\n     * and no other member is present in the group to handle these.\n     * @param context DSpace context object\n     * @param group   DSpace group\n     * @param ePerson eperson\n     * @throws SQLException\n     */\n    @Override\n    public void removeMember(Context context, Group group, EPerson ePerson) throws SQLException {\n        List<CollectionRole> collectionRoles = collectionRoleService.findByGroup(context, group);\n        if (!collectionRoles.isEmpty()) {\n            List<PoolTask> poolTasks = poolTaskService.findByGroup(context, group);\n            List<ClaimedTask> claimedTasks = claimedTaskService.findByEperson(context, ePerson);\n            for (ClaimedTask claimedTask : claimedTasks) {\n                Step stepByName = workflowFactory.getStepByName(claimedTask.getStepID());\n                Role role = stepByName.getRole();\n                for (CollectionRole collectionRole : collectionRoles) {\n                    if (StringUtils.equals(collectionRole.getRoleId(), role.getId())\n                            && claimedTask.getWorkflowItem().getCollection() == collectionRole.getCollection()) {\n                        List<EPerson> ePeople = allMembers(context, group);\n                        if (ePeople.size() == 1 && ePeople.contains(ePerson)) {\n                            throw new IllegalStateException(\n                                    \"Refused to remove user \" + ePerson\n                                            .getID() + \" from workflow group because the group \" + group\n                                            .getID() + \" has tasks assigned and no other members\");\n                        }\n\n                    }\n                }\n            }\n            if (!poolTasks.isEmpty()) {\n                List<EPerson> ePeople = allMembers(context, group);\n                if (ePeople.size() == 1 && ePeople.contains(ePerson)) {\n                    throw new IllegalStateException(\n                            \"Refused to remove user \" + ePerson\n                                    .getID() + \" from workflow group because the group \" + group\n                                    .getID() + \" has tasks assigned and no other members\");\n                }\n            }\n        }\n        if (group.remove(ePerson)) {\n            context.addEvent(new Event(Event.REMOVE, Constants.GROUP, group.getID(), Constants.EPERSON, ePerson.getID(),\n                                       ePerson.getEmail(), getIdentifiers(context, group)));\n        }\n    }\n\n    @Override\n    public void removeMember(Context context, Group groupParent, Group childGroup) throws SQLException {\n        List<CollectionRole> collectionRoles = collectionRoleService.findByGroup(context, groupParent);\n        if (!collectionRoles.isEmpty()) {\n            List<PoolTask> poolTasks = poolTaskService.findByGroup(context, groupParent);\n            if (!poolTasks.isEmpty()) {\n                List<EPerson> parentPeople = allMembers(context, groupParent);\n                List<EPerson> childPeople = allMembers(context, childGroup);\n                if (childPeople.containsAll(parentPeople)) {\n                    throw new IllegalStateException(\n                            \"Refused to remove sub group \" + childGroup\n                                    .getID() + \" from workflow group because the group \" + groupParent\n                                    .getID() + \" has tasks assigned and no other members\");\n                }\n            }\n        }\n        if (groupParent.remove(childGroup)) {\n            childGroup.removeParentGroup(groupParent);\n            context.addEvent(\n                new Event(Event.REMOVE, Constants.GROUP, groupParent.getID(), Constants.GROUP, childGroup.getID(),\n                          childGroup.getName(), getIdentifiers(context, groupParent)));\n        }\n    }\n\n    @Override\n    public boolean isDirectMember(Group group, EPerson ePerson) {\n        // special, group 0 is anonymous\n        return StringUtils.equals(group.getName(), Group.ANONYMOUS) || group.contains(ePerson);\n    }\n\n    @Override\n    public boolean isMember(Group owningGroup, Group childGroup) {\n        return owningGroup.contains(childGroup);\n    }\n\n    @Override\n    public boolean isParentOf(Context context, Group parentGroup, Group childGroup) throws SQLException {\n        return group2GroupCacheDAO.findByParentAndChild(context, parentGroup, childGroup) != null;\n    }\n\n    @Override\n    public boolean isMember(Context context, Group group) throws SQLException {\n        return isMember(context, context.getCurrentUser(), group);\n    }\n\n    @Override\n    public boolean isMember(Context context, EPerson ePerson, Group group)\n        throws SQLException {\n        if (group == null) {\n            return false;\n\n            // special, everyone is member of group 0 (anonymous)\n        } else if (StringUtils.equals(group.getName(), Group.ANONYMOUS) ||\n                   isParentOf(context, group, findByName(context, Group.ANONYMOUS))) {\n            return true;\n\n        } else {\n            Boolean cachedGroupMembership = context.getCachedGroupMembership(group, ePerson);\n\n            if (cachedGroupMembership != null) {\n                return cachedGroupMembership;\n\n            } else {\n                boolean isMember = false;\n\n                //If we have an ePerson, check we can find membership in the database\n                if (ePerson != null) {\n                    //lookup eperson in normal groups and subgroups with 1 query\n                    isMember = isEPersonInGroup(context, group, ePerson);\n                }\n\n                //If we did not find the group membership in the database, check the special groups.\n                //If there are special groups we need to check direct membership or check if the\n                //special group is a subgroup of the provided group.\n                //Note that special groups should only be checked if the current user == the ePerson.\n                //This also works for anonymous users (ePerson == null) if IP authentication used\n                if (!isMember && CollectionUtils.isNotEmpty(context.getSpecialGroups()) &&\n                    isAuthenticatedUser(context, ePerson)) {\n\n                    Iterator<Group> it = context.getSpecialGroups().iterator();\n\n                    while (it.hasNext() && !isMember) {\n                        Group specialGroup = it.next();\n                        //Check if the special group matches the given group or if it is a subgroup (with 1 query)\n                        if (specialGroup.equals(group) || isParentOf(context, group, specialGroup)) {\n                            isMember = true;\n                        }\n                    }\n                }\n\n                context.cacheGroupMembership(group, ePerson, isMember);\n                return isMember;\n\n            }\n        }\n    }\n\n    private boolean isAuthenticatedUser(final Context context, final EPerson ePerson) {\n        return Objects.equals(context.getCurrentUser(), ePerson);\n    }\n\n    @Override\n    public boolean isMember(final Context context, final String groupName) throws SQLException {\n        return isMember(context, findByName(context, groupName));\n    }\n\n    @Override\n    public boolean isMember(final Context context, EPerson eperson, final String groupName) throws SQLException {\n        return isMember(context, eperson, findByName(context, groupName));\n    }\n\n    @Override\n    public List<Group> allMemberGroups(Context context, EPerson ePerson) throws SQLException {\n        return new ArrayList<>(allMemberGroupsSet(context, ePerson));\n    }\n\n    @Override\n    public Set<Group> allMemberGroupsSet(Context context, EPerson ePerson) throws SQLException {\n        Set<Group> cachedGroupMembership = context.getCachedAllMemberGroupsSet(ePerson);\n        if (cachedGroupMembership != null) {\n            return cachedGroupMembership;\n        }\n\n        Set<Group> groups = new HashSet<>();\n\n        if (ePerson != null) {\n            // two queries - first to get groups eperson is a member of\n            // second query gets parent groups for groups eperson is a member of\n            groups.addAll(groupDAO.findByEPerson(context, ePerson));\n        }\n        // Also need to get all \"Special Groups\" user is a member of!\n        // Otherwise, you're ignoring the user's membership to these groups!\n        // However, we only do this is we are looking up the special groups\n        // of the current user, as we cannot look up the special groups\n        // of a user who is not logged in.\n        if ((context.getCurrentUser() == null) || (context.getCurrentUser().equals(ePerson))) {\n            List<Group> specialGroups = context.getSpecialGroups();\n            for (Group special : specialGroups) {\n                groups.add(special);\n            }\n        }\n\n        // all the users are members of the anonymous group\n        groups.add(findByName(context, Group.ANONYMOUS));\n\n        List<Group2GroupCache> groupCache = group2GroupCacheDAO.findByChildren(context, groups);\n        // now we have all owning groups, also grab all parents of owning groups\n        // yes, I know this could have been done as one big query and a union,\n        // but doing the Oracle port taught me to keep to simple SQL!\n        for (Group2GroupCache group2GroupCache : groupCache) {\n            groups.add(group2GroupCache.getParent());\n        }\n\n        context.cacheAllMemberGroupsSet(ePerson, groups);\n        return groups;\n    }\n\n    @Override\n    public List<EPerson> allMembers(Context c, Group g) throws SQLException {\n        // two queries - first to get all groups which are a member of this group\n        // second query gets all members of each group in the first query\n\n        // Get all groups which are a member of this group\n        List<Group2GroupCache> group2GroupCaches = group2GroupCacheDAO.findByParent(c, g);\n        Set<Group> groups = new HashSet<>();\n        for (Group2GroupCache group2GroupCache : group2GroupCaches) {\n            groups.add(group2GroupCache.getChild());\n        }\n\n\n        Set<EPerson> childGroupChildren = new HashSet<>(ePersonService.findByGroups(c, groups));\n        //Don't forget to add our direct children\n        childGroupChildren.addAll(g.getMembers());\n\n        return new ArrayList<>(childGroupChildren);\n    }\n\n    @Override\n    public Group find(Context context, UUID id) throws SQLException {\n        if (id == null) {\n            return null;\n        } else {\n            return groupDAO.findByID(context, Group.class, id);\n        }\n    }\n\n    @Override\n    public Group findByName(Context context, String name) throws SQLException {\n        if (name == null) {\n            return null;\n        }\n\n        return groupDAO.findByName(context, name);\n    }\n\n    /**\n     * DEPRECATED: Please use {@code findAll(Context context, List<MetadataField> metadataSortFields)} instead\n     */\n    @Override\n    @Deprecated\n    public List<Group> findAll(Context context, int sortField) throws SQLException {\n        if (sortField == GroupService.NAME) {\n            return findAll(context, null);\n        } else {\n            throw new UnsupportedOperationException(\"You can only find all groups sorted by name with this method\");\n        }\n    }\n\n    @Override\n    public List<Group> findAll(Context context, List<MetadataField> metadataSortFields) throws SQLException {\n        return findAll(context, metadataSortFields, -1, -1);\n    }\n\n    @Override\n    public List<Group> findAll(Context context, List<MetadataField> metadataSortFields, int pageSize, int offset)\n        throws SQLException {\n        if (CollectionUtils.isEmpty(metadataSortFields)) {\n            return groupDAO.findAll(context, pageSize, offset);\n        } else {\n            return groupDAO.findAll(context, metadataSortFields, pageSize, offset);\n        }\n    }\n\n    @Override\n    public List<Group> search(Context context, String groupIdentifier) throws SQLException {\n        return search(context, groupIdentifier, -1, -1);\n    }\n\n    @Override\n    public List<Group> search(Context context, String groupIdentifier, int offset, int limit) throws SQLException {\n        List<Group> groups = new ArrayList<>();\n        UUID uuid = UUIDUtils.fromString(groupIdentifier);\n        if (uuid == null) {\n            //Search by group name\n            groups = groupDAO.findByNameLike(context, groupIdentifier, offset, limit);\n        } else {\n            //Search by group id\n            Group group = find(context, uuid);\n            if (group != null) {\n                groups.add(group);\n            }\n        }\n\n        return groups;\n    }\n\n    @Override\n    public int searchResultCount(Context context, String groupIdentifier) throws SQLException {\n        int result = 0;\n        UUID uuid = UUIDUtils.fromString(groupIdentifier);\n        if (uuid == null) {\n            //Search by group name\n            result = groupDAO.countByNameLike(context, groupIdentifier);\n        } else {\n            //Search by group id\n            Group group = find(context, uuid);\n            if (group != null) {\n                result = 1;\n            }\n        }\n\n        return result;\n    }\n\n    @Override\n    public void delete(Context context, Group group) throws SQLException {\n        if (group.isPermanent()) {\n            log.error(\"Attempt to delete permanent Group $\", group.getName());\n            throw new SQLException(\"Attempt to delete a permanent Group\");\n        }\n\n        context.addEvent(new Event(Event.DELETE, Constants.GROUP, group.getID(),\n                                   group.getName(), getIdentifiers(context, group)));\n\n        //Remove the supervised group from any workspace items linked to us.\n        group.getSupervisedItems().clear();\n\n        // Remove any ResourcePolicies that reference this group\n        authorizeService.removeGroupPolicies(context, group);\n\n        group.getMemberGroups().clear();\n        group.getParentGroups().clear();\n\n        //Remove all eperson references from this group\n        Iterator<EPerson> ePeople = group.getMembers().iterator();\n        while (ePeople.hasNext()) {\n            EPerson ePerson = ePeople.next();\n            ePeople.remove();\n            ePerson.getGroups().remove(group);\n        }\n\n        // empty out group2groupcache table (if we do it after we delete our object we get an issue with references)\n        group2GroupCacheDAO.deleteAll(context);\n        // Remove ourself\n        groupDAO.delete(context, group);\n        rethinkGroupCache(context, false);\n\n        log.info(LogHelper.getHeader(context, \"delete_group\", \"group_id=\"\n            + group.getID()));\n    }\n\n    @Override\n    public int getSupportsTypeConstant() {\n        return Constants.GROUP;\n    }\n\n    /**\n     * Return true if group has no direct or indirect members\n     */\n    @Override\n    public boolean isEmpty(Group group) {\n        // the only fast check available is on epeople...\n        boolean hasMembers = (!group.getMembers().isEmpty());\n\n        if (hasMembers) {\n            return false;\n        } else {\n            // well, groups is never null...\n            for (Group subGroup : group.getMemberGroups()) {\n                hasMembers = !isEmpty(subGroup);\n                if (hasMembers) {\n                    return false;\n                }\n            }\n            return !hasMembers;\n        }\n    }\n\n    @Override\n    public void initDefaultGroupNames(Context context) throws SQLException, AuthorizeException {\n        GroupService groupService = EPersonServiceFactory.getInstance().getGroupService();\n        // Check for Anonymous group. If not found, create it\n        Group anonymousGroup = groupService.findByName(context, Group.ANONYMOUS);\n        if (anonymousGroup == null) {\n            anonymousGroup = groupService.create(context);\n            anonymousGroup.setName(Group.ANONYMOUS);\n            anonymousGroup.setPermanent(true);\n            groupService.update(context, anonymousGroup);\n        }\n\n\n        // Check for Administrator group. If not found, create it\n        Group adminGroup = groupService.findByName(context, Group.ADMIN);\n        if (adminGroup == null) {\n            adminGroup = groupService.create(context);\n            adminGroup.setName(Group.ADMIN);\n            adminGroup.setPermanent(true);\n            groupService.update(context, adminGroup);\n        }\n    }\n\n    /**\n     * Get a list of groups with no members.\n     *\n     * @param context The relevant DSpace Context.\n     * @return list of groups with no members\n     * @throws SQLException An exception that provides information on a database access error or other errors.\n     */\n    @Override\n    public List<Group> getEmptyGroups(Context context) throws SQLException {\n        return groupDAO.getEmptyGroups(context);\n    }\n\n    /**\n     * Update the group - writing out group object and EPerson list if necessary\n     *\n     * @param context The relevant DSpace Context.\n     * @param group   Group to update\n     * @throws SQLException       An exception that provides information on a database access error or other errors.\n     * @throws AuthorizeException Exception indicating the current user of the context does not have permission\n     *                            to perform a particular action.\n     */\n    @Override\n    public void update(Context context, Group group) throws SQLException, AuthorizeException {\n\n        super.update(context, group);\n        // FIXME: Check authorisation\n        groupDAO.save(context, group);\n\n        if (group.isMetadataModified()) {\n            context.addEvent(new Event(Event.MODIFY_METADATA, Constants.GROUP, group.getID(), group.getDetails(),\n                                       getIdentifiers(context, group)));\n            group.clearDetails();\n        }\n\n        if (group.isGroupsChanged()) {\n            rethinkGroupCache(context, true);\n            group.clearGroupsChanged();\n        }\n\n        log.info(LogHelper.getHeader(context, \"update_group\", \"group_id=\"\n            + group.getID()));\n    }\n\n\n    protected boolean isEPersonInGroup(Context context, Group group, EPerson ePerson)\n        throws SQLException {\n        return groupDAO.findByIdAndMembership(context, group.getID(), ePerson) != null;\n    }\n\n\n    /**\n     * Regenerate the group cache AKA the group2groupcache table in the database -\n     * meant to be called when a group is added or removed from another group\n     *\n     * @param context      The relevant DSpace Context.\n     * @param flushQueries flushQueries Flush all pending queries\n     * @throws SQLException An exception that provides information on a database access error or other errors.\n     */\n    protected void rethinkGroupCache(Context context, boolean flushQueries) throws SQLException {\n\n        Map<UUID, Set<UUID>> parents = new HashMap<>();\n\n        List<Pair<UUID, UUID>> group2groupResults = groupDAO.getGroup2GroupResults(context, flushQueries);\n        for (Pair<UUID, UUID> group2groupResult : group2groupResults) {\n            UUID parent = group2groupResult.getLeft();\n            UUID child = group2groupResult.getRight();\n\n            // if parent doesn't have an entry, create one\n            if (!parents.containsKey(parent)) {\n                Set<UUID> children = new HashSet<>();\n\n                // add child id to the list\n                children.add(child);\n                parents.put(parent, children);\n            } else {\n                // parent has an entry, now add the child to the parent's record\n                // of children\n                Set<UUID> children = parents.get(parent);\n                children.add(child);\n            }\n        }\n\n        // now parents is a hash of all of the IDs of groups that are parents\n        // and each hash entry is a hash of all of the IDs of children of those\n        // parent groups\n        // so now to establish all parent,child relationships we can iterate\n        // through the parents hash\n        for (Map.Entry<UUID, Set<UUID>> parent : parents.entrySet()) {\n            Set<UUID> myChildren = getChildren(parents, parent.getKey());\n            parent.getValue().addAll(myChildren);\n        }\n\n        // empty out group2groupcache table\n        group2GroupCacheDAO.deleteAll(context);\n\n        // write out new one\n        for (Map.Entry<UUID, Set<UUID>> parent : parents.entrySet()) {\n            UUID key = parent.getKey();\n\n            for (UUID child : parent.getValue()) {\n\n                Group parentGroup = find(context, key);\n                Group childGroup = find(context, child);\n\n\n                if (parentGroup != null && childGroup != null && group2GroupCacheDAO\n                    .find(context, parentGroup, childGroup) == null) {\n                    Group2GroupCache group2GroupCache = group2GroupCacheDAO.create(context, new Group2GroupCache());\n                    group2GroupCache.setParent(parentGroup);\n                    group2GroupCache.setChild(childGroup);\n                    group2GroupCacheDAO.save(context, group2GroupCache);\n                }\n            }\n        }\n    }\n\n    @Override\n    public DSpaceObject getParentObject(Context context, Group group) throws SQLException {\n        if (group == null) {\n            return null;\n        }\n        // could a collection/community administrator manage related groups?\n        // check before the configuration options could give a performance gain\n        // if all group management are disallowed\n        if (AuthorizeConfiguration.canCollectionAdminManageAdminGroup()\n            || AuthorizeConfiguration.canCollectionAdminManageSubmitters()\n            || AuthorizeConfiguration.canCollectionAdminManageWorkflows()\n            || AuthorizeConfiguration.canCommunityAdminManageAdminGroup()\n            || AuthorizeConfiguration\n            .canCommunityAdminManageCollectionAdminGroup()\n            || AuthorizeConfiguration\n            .canCommunityAdminManageCollectionSubmitters()\n            || AuthorizeConfiguration\n            .canCommunityAdminManageCollectionWorkflows()) {\n            // is this a collection related group?\n            org.dspace.content.Collection collection = collectionService.findByGroup(context, group);\n\n            if (collection != null) {\n                if (group.equals(collection.getSubmitters())) {\n                    if (AuthorizeConfiguration.canCollectionAdminManageSubmitters()) {\n                        return collection;\n                    } else if (AuthorizeConfiguration.canCommunityAdminManageCollectionSubmitters()) {\n                        return collectionService.getParentObject(context, collection);\n                    }\n                }\n                if (group.equals(collection.getAdministrators())) {\n                    if (AuthorizeConfiguration.canCollectionAdminManageAdminGroup()) {\n                        return collection;\n                    } else if (AuthorizeConfiguration.canCommunityAdminManageCollectionAdminGroup()) {\n                        return collectionService.getParentObject(context, collection);\n                    }\n                }\n            } else {\n                if (AuthorizeConfiguration.canCollectionAdminManageWorkflows()\n                        || AuthorizeConfiguration.canCommunityAdminManageCollectionWorkflows()) {\n                    // if the group is used for one or more roles on a single collection,\n                    // admins can eventually manage it\n                    List<CollectionRole> collectionRoles = collectionRoleService.findByGroup(context, group);\n                    if (collectionRoles != null && collectionRoles.size() > 0) {\n                        Set<Collection> colls = new HashSet<>();\n                        for (CollectionRole cr : collectionRoles) {\n                            colls.add(cr.getCollection());\n                        }\n                        if (colls.size() == 1) {\n                            collection = colls.iterator().next();\n                            if (AuthorizeConfiguration.canCollectionAdminManageWorkflows()) {\n                                return collection;\n                            } else {\n                                return collectionService.getParentObject(context, collection);\n                            }\n                        }\n                    } else {\n                        if (AuthorizeConfiguration.canCollectionAdminManagePolicies()\n                            || AuthorizeConfiguration.canCommunityAdminManagePolicies()\n                            || AuthorizeConfiguration.canCommunityAdminManageCollectionWorkflows()) {\n                            List<Group> groups = new ArrayList<>();\n                            groups.add(group);\n                            List<ResourcePolicy> policies = resourcePolicyService.find(context, null, groups,\n                                                            Constants.DEFAULT_ITEM_READ, Constants.COLLECTION);\n\n                            Optional<ResourcePolicy> defaultPolicy = policies.stream().filter(p -> StringUtils.equals(\n                                    collectionService.getDefaultReadGroupName((Collection) p.getdSpaceObject(), \"ITEM\"),\n                                    group.getName())).findFirst();\n\n                            if (defaultPolicy.isPresent()) {\n                                return defaultPolicy.get().getdSpaceObject();\n                            }\n                            policies = resourcePolicyService.find(context, null, groups,\n                                                             Constants.DEFAULT_BITSTREAM_READ, Constants.COLLECTION);\n\n                            defaultPolicy = policies.stream()\n                                    .filter(p -> StringUtils.equals(collectionService.getDefaultReadGroupName(\n                                            (Collection) p.getdSpaceObject(), \"BITSTREAM\"), group.getName()))\n                                    .findFirst();\n\n                            if (defaultPolicy.isPresent()) {\n                                return defaultPolicy.get().getdSpaceObject();\n                            }\n                        }\n                    }\n                }\n                if (AuthorizeConfiguration.canCommunityAdminManageAdminGroup()) {\n                    // is the group related to a community and community administrator allowed\n                    // to manage it?\n                    return communityService.findByAdminGroup(context, group);\n                }\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public void updateLastModified(Context context, Group dso) {\n        //Not needed.\n    }\n\n    /**\n     * Used recursively to generate a map of ALL of the children of the given\n     * parent\n     *\n     * @param parents Map of parent,child relationships\n     * @param parent  the parent you're interested in\n     * @return Map whose keys are all of the children of a parent\n     */\n    protected Set<UUID> getChildren(Map<UUID, Set<UUID>> parents, UUID parent) {\n        Set<UUID> myChildren = new HashSet<>();\n\n        // degenerate case, this parent has no children\n        if (!parents.containsKey(parent)) {\n            return myChildren;\n        }\n\n        // got this far, so we must have children\n        Set<UUID> children = parents.get(parent);\n\n        // now iterate over all of the children\n\n        for (UUID child : children) {\n            // add this child's ID to our return set\n            myChildren.add(child);\n\n            // and now its children\n            myChildren.addAll(getChildren(parents, child));\n        }\n\n        return myChildren;\n    }\n\n    @Override\n    public Group findByIdOrLegacyId(Context context, String id) throws SQLException {\n        if (org.apache.commons.lang3.StringUtils.isNumeric(id)) {\n            return findByLegacyId(context, Integer.parseInt(id));\n        } else {\n            return find(context, UUIDUtils.fromString(id));\n        }\n    }\n\n    @Override\n    public Group findByLegacyId(Context context, int id) throws SQLException {\n        return groupDAO.findByLegacyId(context, id, Group.class);\n    }\n\n    @Override\n    public int countTotal(Context context) throws SQLException {\n        return groupDAO.countRows(context);\n    }\n\n    @Override\n    public List<Group> findByMetadataField(final Context context, final String searchValue,\n                                           final MetadataField metadataField) throws SQLException {\n        return groupDAO.findByMetadataField(context, searchValue, metadataField);\n    }\n}\n"], "filenames": ["dspace-api/src/main/java/org/dspace/content/CollectionServiceImpl.java", "dspace-api/src/main/java/org/dspace/content/service/CollectionService.java", "dspace-api/src/main/java/org/dspace/eperson/GroupServiceImpl.java"], "buggy_code_start_loc": [923, 361, 17], "buggy_code_end_loc": [932, 361, 745], "fixing_code_start_loc": [923, 362, 18], "fixing_code_end_loc": [938, 372, 757], "type": "CWE-863", "message": "DSpace is an open source turnkey repository application. In version 7.0, any community or collection administrator can escalate their permission up to become system administrator. This vulnerability only exists in 7.0 and does not impact 6.x or below. This issue is patched in version 7.1. As a workaround, users of 7.0 may temporarily disable the ability for community or collection administrators to manage permissions or workflows settings.", "other": {"cve": {"id": "CVE-2021-41189", "sourceIdentifier": "security-advisories@github.com", "published": "2021-10-29T18:15:08.167", "lastModified": "2021-11-03T12:47:36.327", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "DSpace is an open source turnkey repository application. In version 7.0, any community or collection administrator can escalate their permission up to become system administrator. This vulnerability only exists in 7.0 and does not impact 6.x or below. This issue is patched in version 7.1. As a workaround, users of 7.0 may temporarily disable the ability for community or collection administrators to manage permissions or workflows settings."}, {"lang": "es", "value": "DSpace es una aplicaci\u00f3n de repositorio de c\u00f3digo abierto llave en mano. En la versi\u00f3n 7.0, cualquier administrador de una comunidad o colecci\u00f3n puede escalar sus permisos hasta convertirse en administrador del sistema. Esta vulnerabilidad s\u00f3lo se presenta en la versi\u00f3n 7.0 y no afecta a las versiones 6.x o por debajo. Este problema est\u00e1 parcheado en la versi\u00f3n 7.1. Como soluci\u00f3n, los usuarios de la versi\u00f3n 7.0 pueden deshabilitar temporalmente la capacidad para los administradores de comunidades o colecciones para administrar los permisos o la configuraci\u00f3n de los flujos de trabajo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 9.0}, "baseSeverity": "HIGH", "exploitabilityScore": 8.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:duraspace:dspace:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "EC2273B4-D6B6-4968-BF9A-65812B5799A1"}]}]}], "references": [{"url": "https://github.com/DSpace/DSpace/commit/277b499a5cd3a4f5eb2370513a1b7e4ec2a6e041", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/DSpace/DSpace/commit/c3bea16ab911606e15ae96c97a1575e1ffb14f8a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/DSpace/DSpace/issues/7928", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/DSpace/DSpace/security/advisories/GHSA-cf2j-vf36-c6w8", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/DSpace/DSpace/commit/277b499a5cd3a4f5eb2370513a1b7e4ec2a6e041"}}