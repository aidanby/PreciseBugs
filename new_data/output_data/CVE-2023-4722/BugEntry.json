{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2017-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISOBMF mux filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/filters.h>\n#include <gpac/constants.h>\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/internal/media_dev.h>\n\n#if !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_MP4MX)\n\n#define TEXT_DEFAULT_WIDTH\t400\n#define TEXT_DEFAULT_HEIGHT\t60\n#define TEXT_DEFAULT_FONT_SIZE\t18\n\n#define GF_VENDOR_GPAC\t\tGF_4CC('G','P','A','C')\n\n#define GF_IMPORT_AUDIO_SAMPLE_ENTRY_v2_QTFF (GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF+1)\n\n#define ISOM_FILE_EXT \"mp4|mpg4|m4a|m4i|3gp|3gpp|3g2|3gp2|iso|ismv|m4s|heif|heic|iff|avci|avif|mj2|mov|qt\"\n#define ISOM_FILE_MIME \"video/mp4|audio/mp4|application/mp4|video/3gpp|audio/3gpp|video/3gp2|audio/3gp2|video/iso.segment|audio/iso.segment|image/heif|image/heic|image/avci|video/jp2|video/quicktime\"\n\nenum{\n\tNALU_NONE,\n\tNALU_AVC,\n\tNALU_HEVC,\n\tNALU_VVC\n};\n\n\nenum\n{\n\tCENC_NONE=0,\n\tCENC_NEED_SETUP,\n\tCENC_SETUP_DONE,\n\tCENC_SETUP_ERROR\n};\n\nenum{\n\tTAG_NONE,\n\tTAG_STRICT,\n\tTAG_ALL\n};\n\nenum\n{\n\tXPS_IB_NO = 0,\n\tXPS_IB_PPS,\n\tXPS_IB_ALL,\n\tXPS_IB_BOTH,\n\tXPS_IB_MIX,\n\tXPS_IB_AUTO\n};\n\ntypedef struct\n{\n\tGF_FilterPid *ipid;\n\tu32 track_num, track_id;\n\tGF_ISOSample sample;\n\tu32 prev_duration;\n\n\tu32 src_timescale;\n\tu32 tk_timescale;\n\tu32 stream_type;\n\tu32 codecid;\n\tBool is_encrypted;\n\n\tu32 cfg_crc, enh_cfg_crc;\n\tu32 dep_id;\n\tu32 stsd_idx;\n\tu32 clear_stsd_idx;\n\tBool reused_stsd;\n\n\tBool use_dref;\n\tBool aborted;\n\tBool suspended;\n\tBool has_append;\n\tBool has_ctts;\n\ts64 min_neg_ctts;\n\tu32 nb_samples, samples_in_stsd;\n\tu32 nb_frames_per_sample;\n\tu64 ts_shift;\n\tu64 si_min_ts_plus_one;\n\tBool has_subs;\n\n\tBool skip_bitrate_update;\n\tBool has_open_gop;\n\tGF_FilterSAPType gdr_type;\n\n\tu32 media_profile_level;\n\n\tBool import_msg_header_done;\n\n\tu32 nal_unit_size;\n\n\tGF_AVCConfig *avcc, *svcc;\n\tGF_HEVCConfig *hvcc, *lvcc;\n\tGF_VVCConfig *vvcc;\n\n\tu8 *inband_hdr, *inband_hdr_non_rap;\n\tu32 inband_hdr_size, inband_hdr_non_rap_size;\n\tu32 is_nalu;\n\tBool is_av1, is_vpx;\n\tBool fragment_done;\n\ts32 ts_delay, negctts_shift;\n\tBool insert_tfdt, probe_min_ctts;\n\tu64 first_dts_in_seg_plus_one, next_seg_cts, cts_next;\n\ts64 tfdt_offset;\n\tu32 samples_in_frag;\n\tBool patch_tfdt;\n\n\t//0: not cenc, 1: needs setup of stsd entry, 2: setup done\n\tu32 cenc_state;\n\tBool cenc_subsamples;\n\tu32 scheme_type;\n\tu32 def_skip_byte_block, def_crypt_byte_block;\n\tu32 def_cenc_key_info_crc;\n\tconst GF_PropertyValue *cenc_ki;\n\tu32 cenc_key_info_crc;\n\tu32 constant_IV_size;\n\tBool cenc_multikey;\n\tBool cenc_frag_protected;\n\tu32 skip_byte_block, crypt_byte_block;\n\n\tBool fake_track;\n\n\tBool has_brands;\n\tBool force_inband_inject;\n\n\tu64 dur_in_frag;\n\n\tu32 amr_mode_set;\n\tBool has_seig;\n\tu64 empty_init_dur;\n\tu32 raw_audio_bytes_per_sample, raw_samplerate;\n\tu64 dts_patch;\n\n\tBool is_item;\n\tu32 item_id;\n\tchar status_type;\n\tu32 last_import_pc;\n\n\tu32 nb_frames, frame_offset;\n\tu64 down_bytes, down_size;\n\tGF_Fraction64 pid_dur;\n\t//for import message\n\tu64 prog_done, prog_total;\n\n\tu32 prev_tid_group;\n\n\tBool box_patched;\n\n\tu64 imported_edit_sdur, imported_edit_offset;\n\n\tBool force_ctts;\n\n\tBool is_hevc_tile_base;\n\tBool insert_pssh;\n\n\tBool wait_sap;\n\tu64 min_ts_seek_plus_one;\n\tu64 clamp_ts_plus_one;\n\tBool check_seek_ts;\n\n\tu64 max_cts, min_cts;\n\tu32 max_cts_samp_dur;\n\n\tu32 w_or_sr, h_or_ch, pf_or_af;\n\tu32 xps_inband;\n\n\tu8 *dyn_pssh;\n\tu32 dyn_pssh_len;\n\n\tBool sparse_inject;\n\tBool is_chap;\n\n\tGF_FilterPacket *dgl_copy;\n\tu32 all_stsd_crc;\n} TrackWriter;\n\nenum\n{\n\tMP4MX_MODE_INTER=0,\n\tMP4MX_MODE_FLAT,\n\tMP4MX_MODE_FASTSTART,\n\tMP4MX_MODE_TIGHT,\n\tMP4MX_MODE_FRAG,\n\tMP4MX_MODE_SFRAG,\n};\n\n\nenum\n{\n\tMP4MX_DASH_OFF=0,\n\tMP4MX_DASH_ON,\n\tMP4MX_DASH_VOD,\n};\n\nenum\n{\n\tMP4MX_PSSH_MOOV=0,\n\tMP4MX_PSSH_MOOF,\n\tMP4MX_PSSH_BOTH,\n\tMP4MX_PSSH_SKIP,\n};\n\nenum\n{\n\tMP4MX_CT_EDIT=0,\n\tMP4MX_CT_NOEDIT,\n\tMP4MX_CT_NEGCTTS,\n};\n\nenum\n{\n\tMP4MX_VODCACHE_ON=0,\n\tMP4MX_VODCACHE_INSERT,\n\tMP4MX_VODCACHE_REPLACE,\n};\n\nenum\n{\n\tMP4MX_CMAF_NO=0,\n\tMP4MX_CMAF_CMFC,\n\tMP4MX_CMAF_CMF2,\n};\n\nenum\n{\n\tMP4MX_CHAPM_OFF=0,\n\tMP4MX_CHAPM_TRACK,\n\tMP4MX_CHAPM_UDTA,\n\tMP4MX_CHAPM_BOTH\n};\n\nenum\n{\n\tMP4MX_UNCV_OFF=0,\n\tMP4MX_UNCV_NOPROF,\n\tMP4MX_UNCV_PROF,\n\tMP4MX_UNCV_PROF_ONLY\n};\n\n\ntypedef struct\n{\n\t//filter args\n\tGF_ISOFile *file;\n\tBool m4sys, dref;\n\tGF_Fraction dur;\n\tu32 pack3gp, ctmode;\n\tBool importer, pack_nal, moof_first, abs_offset, fsap, tfdt_traf, keep_utc, pps_inband;\n\tu32 xps_inband, moovpad;\n\tu32 block_size;\n\tu32 store, tktpl, mudta;\n\ts32 subs_sidx;\n\tGF_Fraction cdur;\n\ts32 moovts;\n\tchar *m4cc;\n\tBool chain_sidx;\n\tu32 msn, msninc;\n\tGF_Fraction64 tfdt;\n\tBool nofragdef, straf, strun, sgpd_traf, noinit;\n\tu32 vodcache;\n\tu32 psshs;\n\tu32 trackid;\n\tBool fragdur;\n\tBool btrt;\n\tBool ssix;\n\tBool ccst;\n\ts32 mediats;\n\tGF_AudioSampleEntryImportMode ase;\n\tchar *styp;\n\tBool sseg;\n\tBool noroll, norap;\n\tBool saio32, tfdt64;\n\tu32 compress;\n\tBool trun_inter;\n\tBool truns_first;\n\tchar *boxpatch;\n\tBool fcomp, otyp;\n\tBool deps;\n\tBool mvex;\n\tu32 sdtp_traf;\n\tu32 cmaf;\n#ifdef GF_ENABLE_CTRN\n\tBool ctrn;\n\tBool ctrni;\n#endif\n\tBool mfra;\n\tu32 uncv;\n\tBool forcesync, refrag, pad_sparse;\n\tBool force_dv, tsalign, dvsingle, patch_dts;\n\tu32 itags;\n\tDouble start;\n\tu32 chapm;\n\n\n\t//internal\n\tGF_Filter *filter;\n\tBool owns_mov;\n\tGF_FilterPid *opid;\n\tBool first_pck_sent;\n\n\tGF_List *tracks;\n\n\tGF_BitStream *bs_r;\n\t//fragmentation state\n\tBool init_movie_done, fragment_started, segment_started, insert_tfdt, insert_pssh, cdur_set;\n\n\tu64 next_frag_start, adjusted_next_frag_start;\n\n\tu64 current_offset;\n\tu64 current_size;\n\n\tu32 nb_segs, nb_frags, nb_frags_in_seg;\n\n\tGF_FilterPacket *dst_pck;\n\tchar *seg_name;\n\tu32 dash_seg_num_plus_one;\n\tBool flush_seg;\n\tu32 eos_marker;\n\tTrackWriter *ref_tkw;\n\tBool single_file;\n\tBool store_output;\n\tFILE *tmp_store;\n\tu64 flush_size, flush_done;\n\n\tu32 dash_mode, llhls_mode;\n\tGF_Fraction dash_dur;\n\tDouble media_dur;\n\tu32 sidx_max_size, sidx_chunk_offset;\n\tBool final_sidx_flush;\n\tBool sidx_size_exact;\n\n\tu32 *seg_sizes;\n\tu32 nb_seg_sizes, alloc_seg_sizes, config_retry_start;\n\tBool config_timing;\n\n\tu32 major_brand_set;\n\tBool def_brand_patched;\n\n\tBool force_play;\n\n\tBool moov_inserted;\n\tBool update_report;\n\tu64 total_bytes_in, total_bytes_out;\n\tu32 total_samples, last_mux_pc;\n\n\tu32 maxchunk;\n\tu32 make_qt;\n\tTrackWriter *prores_track;\n\n\tGF_SegmentIndexBox *cloned_sidx;\n\tu32 cloned_sidx_index;\n\tGF_Fraction faststart_ts_regulate;\n\n\tBool is_rewind;\n\tBool box_patched;\n\tu32 cur_file_idx_plus_one;\n\tchar *cur_file_suffix;\n\tBool notify_filename;\n\n\tu32 next_file_idx;\n\tconst char *next_file_suffix;\n\n\t//for route scheduling\n\tu64 min_cts_plus_one, next_seg_start;\n\tu64 min_cts_next_frag;\n\n\tu64 frag_size, frag_offset;\n\tu32 frag_num;\n\tu64 frag_duration;\n\tu32 frag_timescale;\n\tBool frag_has_intra;\n\n\tu64 wait_dts_plus_one;\n\tu32 wait_dts_timescale;\n\tBool force_seg_sync;\n\tu32 seg_flush_state;\n\tu64 flush_idx_start_range, flush_idx_end_range;\n\tBool flush_ll_hls;\n\n\tBool has_def_vid, has_def_aud, has_def_txt;\n\n\t//created from chapters prop\n\tu32 chap_track_num;\n\tBool has_chap_tracks;\n\n\tGF_List *ref_pcks;\n} GF_MP4MuxCtx;\n\nstatic void mp4_mux_update_init_edit(GF_MP4MuxCtx *ctx, TrackWriter *tkw, u64 min_ts_service, Bool skip_adjust);\n\nstatic void mp4_mux_set_hevc_groups(GF_MP4MuxCtx *ctx, TrackWriter *tkw);\n\nstatic GF_Err mp4mx_setup_dash_vod(GF_MP4MuxCtx *ctx, TrackWriter *tkw)\n{\n\tif (tkw) {\n\t\tconst GF_PropertyValue *p;\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DASH_DUR);\n\t\tif (p) {\n\t\t\tctx->dash_dur = p->value.frac;\n\t\t}\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DURATION);\n\t\tif (p && p->value.lfrac.den) {\n\t\t\tDouble mdur = (Double) p->value.lfrac.num;\n\t\t\tif (mdur<0) mdur = -mdur;\n\t\t\tmdur /= p->value.lfrac.den;\n\t\t\tif (ctx->media_dur < mdur) ctx->media_dur = mdur;\n\t\t}\n\t}\n\tctx->dash_mode = MP4MX_DASH_VOD;\n\tctx->llhls_mode = 0;\n\tif ((ctx->vodcache==MP4MX_VODCACHE_ON) && !ctx->tmp_store) {\n\t\tctx->tmp_store = gf_file_temp(NULL);\n\t\tif (!ctx->tmp_store) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot allocate temp file for VOD sidx generation\\n\"));\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\tif (!ctx->block_size) ctx->block_size = 10000;\n\t}\n\n\treturn GF_OK;\n}\n\n\nstatic u32 gf_isom_stream_type_to_media_type(u32 stream_type, u32 codecid)\n{\n\tswitch (stream_type) {\n\tcase GF_STREAM_SCENE: return GF_ISOM_MEDIA_SCENE;\n\tcase GF_STREAM_OD: return GF_ISOM_MEDIA_OD;\n\tcase GF_STREAM_OCR: return GF_ISOM_MEDIA_OCR;\n\tcase GF_STREAM_OCI: return GF_ISOM_MEDIA_OCI;\n\tcase GF_STREAM_MPEG7: return GF_ISOM_MEDIA_MPEG7;\n\tcase GF_STREAM_METADATA: return GF_ISOM_MEDIA_META;\n\tcase GF_STREAM_VISUAL: return GF_ISOM_MEDIA_VISUAL;\n\tcase GF_STREAM_AUDIO: return GF_ISOM_MEDIA_AUDIO;\n\tcase GF_STREAM_TEXT:\n\t\tif (codecid==GF_ISOM_SUBTYPE_STPP)\n\t\t\treturn GF_ISOM_MEDIA_MPEG_SUBT;\n\t\tif (codecid == GF_CODECID_SUBPIC)\n\t\t\treturn GF_ISOM_MEDIA_SUBPIC;\n\t\treturn GF_ISOM_MEDIA_TEXT;\n\tcase GF_STREAM_INTERACT: return GF_ISOM_MEDIA_SCENE;\n\tcase GF_STREAM_IPMP: return GF_ISOM_MEDIA_IPMP;\n\tcase GF_STREAM_MPEGJ: return GF_ISOM_MEDIA_MPEGJ;\n\tcase GF_STREAM_IPMP_TOOL: return GF_ISOM_MEDIA_IPMP;\n\tcase GF_STREAM_FONT: return GF_ISOM_MEDIA_MPEGJ;//TOCHECK !!\n\n\tcase GF_STREAM_PRIVATE_SCENE:\n\tcase GF_STREAM_ENCRYPTED:\n\tcase GF_STREAM_FILE:\n\t\treturn 0;\n\tdefault:\n\t\treturn stream_type;\n\t}\n\treturn 0;\n}\n\nstatic void mp4_mux_write_ps_list(GF_BitStream *bs, GF_List *list, u32 nalu_size_length)\n{\n\tu32 i, count = list ? gf_list_count(list) : 0;\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(list, i);\n\t\tgf_bs_write_int(bs, sl->size, 8*nalu_size_length);\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n}\n\nstatic GF_List *mp4_mux_get_nalus_ps(GF_List *list, u8 type)\n{\n\tu32 i, count = gf_list_count(list);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParamArray *pa = gf_list_get(list, i);\n\t\tif (pa->type == type) return pa->nalus;\n\t}\n\treturn NULL;\n}\n\nstatic void mp4_mux_make_inband_header(GF_MP4MuxCtx *ctx, TrackWriter *tkw, Bool for_non_rap)\n{\n\tGF_BitStream *bs;\n\tif (for_non_rap) {\n\t\tif (tkw->inband_hdr_non_rap) gf_free(tkw->inband_hdr_non_rap);\n\t\ttkw->inband_hdr_non_rap = NULL;\n\t} else {\n\t\tif (tkw->inband_hdr) gf_free(tkw->inband_hdr);\n\t\ttkw->inband_hdr = NULL;\n\t}\n\n\ttkw->nal_unit_size = 0;\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (tkw->avcc || tkw->svcc) {\n\t\tif (tkw->avcc) {\n\t\t\tif (!for_non_rap)\n\t\t\t\tmp4_mux_write_ps_list(bs, tkw->avcc->sequenceParameterSets, tkw->avcc->nal_unit_size);\n\t\t\t/*if (!tkw->nal_unit_size) */tkw->nal_unit_size = tkw->avcc->nal_unit_size;\n\t\t}\n\n\t\tif (tkw->svcc) {\n\t\t\tif (!for_non_rap)\n\t\t\t\tmp4_mux_write_ps_list(bs, tkw->svcc->sequenceParameterSets, tkw->svcc->nal_unit_size);\n\t\t\tif (!tkw->nal_unit_size) tkw->nal_unit_size = tkw->svcc->nal_unit_size;\n\t\t}\n\n\t\tif (tkw->avcc && tkw->avcc->sequenceParameterSetExtensions && !for_non_rap)\n\t\t\tmp4_mux_write_ps_list(bs, tkw->avcc->sequenceParameterSetExtensions, tkw->avcc->nal_unit_size);\n\n\t\tif (tkw->svcc && tkw->svcc->sequenceParameterSetExtensions && !for_non_rap)\n\t\t\tmp4_mux_write_ps_list(bs, tkw->svcc->sequenceParameterSetExtensions, tkw->svcc->nal_unit_size);\n\n\t\tif (tkw->avcc)\n\t\t\tmp4_mux_write_ps_list(bs, tkw->avcc->pictureParameterSets, tkw->avcc->nal_unit_size);\n\n\t\tif (tkw->svcc)\n\t\t\tmp4_mux_write_ps_list(bs, tkw->svcc->pictureParameterSets, tkw->svcc->nal_unit_size);\n\t}\n\tif (tkw->hvcc || tkw->lvcc) {\n\t\tif (tkw->hvcc) {\n\t\t\tif (!for_non_rap)\n\t\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->hvcc->param_array, GF_HEVC_NALU_VID_PARAM), tkw->hvcc->nal_unit_size);\n\t\t\tif (!tkw->nal_unit_size) tkw->nal_unit_size = tkw->hvcc->nal_unit_size;\n\t\t}\n\t\tif (tkw->lvcc) {\n\t\t\tif (!for_non_rap)\n\t\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->lvcc->param_array, GF_HEVC_NALU_VID_PARAM), tkw->lvcc->nal_unit_size);\n\t\t\tif (!tkw->nal_unit_size) tkw->nal_unit_size = tkw->lvcc->nal_unit_size;\n\t\t}\n\t\tif (tkw->hvcc && !for_non_rap)\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->hvcc->param_array, GF_HEVC_NALU_SEQ_PARAM), tkw->hvcc->nal_unit_size);\n\t\tif (tkw->lvcc && !for_non_rap)\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->lvcc->param_array, GF_HEVC_NALU_SEQ_PARAM), tkw->lvcc->nal_unit_size);\n\t\tif (tkw->hvcc)\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->hvcc->param_array, GF_HEVC_NALU_PIC_PARAM), tkw->hvcc->nal_unit_size);\n\t\tif (tkw->lvcc)\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->lvcc->param_array, GF_HEVC_NALU_PIC_PARAM), tkw->lvcc->nal_unit_size);\n\t}\n\n\tif (tkw->vvcc) {\n\t\tif (tkw->xps_inband==XPS_IB_PPS) {\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_PIC_PARAM), tkw->vvcc->nal_unit_size);\n\t\t\tif (!tkw->nal_unit_size) tkw->nal_unit_size = tkw->vvcc->nal_unit_size;\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_APS_PREFIX), tkw->vvcc->nal_unit_size);\n\t\t} else {\n\t\t\tif (!for_non_rap) {\n\t\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_OPI), tkw->vvcc->nal_unit_size);\n\t\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_DEC_PARAM), tkw->vvcc->nal_unit_size);\n\t\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_VID_PARAM), tkw->vvcc->nal_unit_size);\n\t\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_SEQ_PARAM), tkw->vvcc->nal_unit_size);\n\t\t\t}\n\t\t\tif (!tkw->nal_unit_size) tkw->nal_unit_size = tkw->vvcc->nal_unit_size;\n\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_PIC_PARAM), tkw->vvcc->nal_unit_size);\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_APS_PREFIX), tkw->vvcc->nal_unit_size);\n\t\t}\n\t}\n\n\tif (for_non_rap) {\n\t\tgf_bs_get_content(bs, &tkw->inband_hdr_non_rap, &tkw->inband_hdr_non_rap_size);\n\t} else {\n\t\tgf_bs_get_content(bs, &tkw->inband_hdr, &tkw->inband_hdr_size);\n\t}\n\tgf_bs_del(bs);\n\t//we may have cases where the param sets are updated before a non-IDR/SAP3 picture, we must inject asap at least once\n\ttkw->force_inband_inject = GF_TRUE;\n}\n\nvoid mp4_mux_get_video_size(GF_MP4MuxCtx *ctx, u32 *width, u32 *height)\n{\n\tu32 w, h, f_w, f_h, i;\n\n\tf_w = f_h = 0;\n\tfor (i=0; i<gf_isom_get_track_count(ctx->file); i++) {\n\t\tswitch (gf_isom_get_media_type(ctx->file, i+1)) {\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\tgf_isom_get_visual_info(ctx->file, i+1, 1, &w, &h);\n\t\t\tif (w > f_w) f_w = w;\n\t\t\tif (h > f_h) f_h = h;\n\t\t\t//fallthrough\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\t\tgf_isom_get_track_layout_info(ctx->file, i+1, &w, &h, NULL, NULL, NULL);\n\t\t\tif (w > f_w) f_w = w;\n\t\t\tif (h > f_h) f_h = h;\n\t\t\tbreak;\n\t\t}\n\t}\n\t(*width) = f_w ? f_w : TEXT_DEFAULT_WIDTH;\n\t(*height) = f_h ? f_h : TEXT_DEFAULT_HEIGHT;\n}\n\nstatic void mp4_mux_track_writer_del(TrackWriter *tkw)\n{\n\tif (tkw->avcc) gf_odf_avc_cfg_del(tkw->avcc);\n\tif (tkw->svcc) gf_odf_avc_cfg_del(tkw->svcc);\n\tif (tkw->hvcc) gf_odf_hevc_cfg_del(tkw->hvcc);\n\tif (tkw->lvcc) gf_odf_hevc_cfg_del(tkw->lvcc);\n\tif (tkw->vvcc) gf_odf_vvc_cfg_del(tkw->vvcc);\n\tif (tkw->inband_hdr) gf_free(tkw->inband_hdr);\n\tif (tkw->inband_hdr_non_rap) gf_free(tkw->inband_hdr_non_rap);\n\tif (tkw->dyn_pssh) gf_free(tkw->dyn_pssh);\n\tif (tkw->dgl_copy) gf_filter_pck_discard(tkw->dgl_copy);\n\tgf_free(tkw);\n}\n\nstatic void mp4_mux_write_track_refs(GF_MP4MuxCtx *ctx, TrackWriter *tkw, const char *rname, u32 rtype, Bool remove_from_pres)\n{\n\tu32 i;\n\tconst GF_PropertyValue *p = gf_filter_pid_get_property_str(tkw->ipid, rname);\n\tif (!p) return;\n\tfor (i=0; i<p->value.uint_list.nb_items; i++) {\n\t\tgf_isom_set_track_reference(ctx->file, tkw->track_num, rtype, p->value.uint_list.vals[i]);\n\t\tif (remove_from_pres) {\n\t\t\tgf_isom_set_track_flags(ctx->file, tkw->track_num, GF_ISOM_TK_IN_MOVIE|GF_ISOM_TK_IN_PREVIEW, GF_ISOM_TKFLAGS_REM);\n\t\t}\n\t}\n}\n\nstatic void mp4mux_track_reorder(void *udta, u32 old_track_num, u32 new_track_num)\n{\n\tGF_MP4MuxCtx *ctx = (GF_MP4MuxCtx *) udta;\n\tu32 i, count;\n\n\tif (ctx->chap_track_num==old_track_num) {\n\t\tctx->chap_track_num = new_track_num;\n\t\treturn;\n\t}\n\tcount = gf_list_count(ctx->tracks);\n\tfor (i=0; i<count; i++) {\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tif (!tkw->track_id) continue;\n\t\tif (tkw->track_num==old_track_num) {\n\t\t\ttkw->track_num = new_track_num;\n\t\t\t//prevent any further changes, trackID is restored in mp4mux_reorder_tracks\n\t\t\ttkw->track_id = 0;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void mp4mux_reorder_tracks(GF_MP4MuxCtx *ctx)\n{\n\tu32 i, count, prev_num, prev_pos;\n\tGF_List *new_tracks = gf_list_new();\n\tprev_num = prev_pos = 0;\n\tcount = gf_list_count(ctx->tracks);\n\tfor (i=0; i<count; i++) {\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tif (!tkw->track_id)\n\t\t\ttkw->track_id = gf_isom_get_track_id(ctx->file, tkw->track_num);\n\n\t\tif (tkw->track_num<prev_num) {\n\t\t\tgf_list_insert(new_tracks, tkw, prev_pos);\n\t\t} else {\n\t\t\tgf_list_add(new_tracks, tkw);\n\t\t}\n\t\tprev_pos = gf_list_count(new_tracks) - 1;\n\t\tprev_num = tkw->track_num;\n\t}\n\tif (gf_list_count(new_tracks)!=count) {\n\t\tgf_list_del(new_tracks);\n\t\treturn;\n\t}\n\tgf_list_del(ctx->tracks);\n\tctx->tracks = new_tracks;\n}\n\nstatic void mp4mx_set_track_group(GF_MP4MuxCtx *ctx, TrackWriter *tkw, char *name, const GF_PropertyValue *p)\n{\n\ts32 grp_id=0;\n\tu32 grp_type;\n\tu32 len = (u32) strlen(name);\n\tBool do_add=GF_TRUE;\n\tif (len!=4) return;\n\n\tif ((p->type==GF_PROP_STRING) || (p->type==GF_PROP_NAME)) {\n\t\tgrp_id = atoi(p->value.string);\n\t} else {\n\t\tgrp_id = p->value.sint;\n\t}\n\tif (grp_id<0) {\n\t\tgrp_id = -grp_id;\n\t\tdo_add = GF_FALSE;\n\t}\n\tgrp_type = GF_4CC(name[0], name[1], name[2], name[3]);\n\tgf_isom_set_track_group(ctx->file, tkw->track_num, grp_id, grp_type, do_add);\n}\n\n\n#include <gpac/revision.h>\nstatic void mp4_mux_set_tags(GF_MP4MuxCtx *ctx, TrackWriter *tkw)\n{\n\tu32 idx=0;\n\n\tif (!gf_sys_is_test_mode() && !gf_sys_old_arch_compat() ) {\n\t\tconst char *tool = \"GPAC-\"GPAC_VERSION\"-rev\"GPAC_GIT_REVISION;\n\t\tu32 len = (u32) strlen(tool);\n\t\tgf_isom_apple_set_tag(ctx->file, GF_ISOM_ITUNE_TOOL, tool, len, 0, 0);\n\t}\n\n\tif (ctx->itags==TAG_NONE) return;\n\n\twhile (1) {\n\t\tGF_Err e;\n\t\tu32 len;\n\t\tu32 prop_4cc=0;\n\t\tu32 itag;\n\t\ts32 tag_idx;\n\t\tconst char *tag_name=NULL;\n\t\tconst GF_PropertyValue *tag = gf_filter_pid_enum_properties(tkw->ipid, &idx, &prop_4cc, &tag_name);\n\t\tif (!tag) break;\n\n\t\tif (prop_4cc==GF_PROP_PID_COVER_ART) {\n\t\t\te = gf_isom_apple_set_tag(ctx->file, GF_ISOM_ITUNE_COVER_ART, tag->value.data.ptr, tag->value.data.size, 0, 0);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set cover art: %s\\n\", gf_error_to_string(e)));\n\t\t\t}\n\t\t}\n\t\tif (!tag_name)\n\t\t\tcontinue;\n\n\t\tif (!strncmp(tag_name, \"tkgp_\", 5)) {\n\t\t\tmp4mx_set_track_group(ctx, tkw, (char*) tag_name+5, tag);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttag_idx = gf_itags_find_by_name(tag_name);\n\t\tif (tag_idx>=0) {\n\t\t\titag = gf_itags_get_itag(tag_idx);\n\t\t} else if (!strnicmp(tag_name, \"qtt_\", 4)) {\n\t\t\ttag_name += 4;\n\n\t\t\tswitch (tag->type) {\n\t\t\tcase GF_PROP_DATA:\n\t\t\tcase GF_PROP_CONST_DATA:\n\t\t\tcase GF_PROP_DATA_NO_COPY:\n\t\t\t{\n\t\t\t\tGF_QT_UDTAKey key;\n\t\t\t\tkey.type = GF_QT_KEY_OPAQUE;\n\t\t\t\tkey.name = tag_name;\n\t\t\t\tkey.ns = GF_4CC('m','d','t','a');\n\t\t\t\tchar *sep = strchr(tag_name, '@');\n\t\t\t\tif (sep) {\n\t\t\t\t\tkey.name = sep+1;\n\t\t\t\t\tkey.ns = GF_4CC(tag_name[0], tag_name[1],tag_name[2],tag_name[3]);\n\t\t\t\t}\n\t\t\t\tkey.value.data.data = tag->value.data.ptr;\n\t\t\t\tkey.value.data.data_len = tag->value.data.size;\n\t\t\t\te = gf_isom_set_qt_key(ctx->file, &key);\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GF_PROP_POINTER:\n\t\t\t\te = GF_NOT_SUPPORTED;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\tchar szDump[GF_PROP_DUMP_ARG_SIZE];\n\t\t\t\tconst char *str = gf_props_dump_val(tag, szDump, GF_PROP_DUMP_DATA_NONE, NULL);\n\t\t\t\te = gf_media_isom_apply_qt_key(ctx->file, tag_name, str);\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set QT tag: %s\\n\", gf_error_to_string(e)));\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (ctx->itags==TAG_STRICT)\n\t\t\t\tcontinue;\n\n\t\t\tif (strnicmp(tag_name, \"tag_\", 4))\n\t\t\t\tcontinue;\n\n\t\t\ttag_name += 4;\n\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MP4Mux] Unrecognized tag %s: %s\\n\", tag_name, tag->value.string));\n\n\t\t\tif (strlen(tag_name)==4) {\n\t\t\t\titag = GF_4CC(tag_name[0], tag_name[1], tag_name[2], tag_name[3]);\n\t\t\t} else if (strlen(tag_name)==3) {\n\t\t\t\titag = GF_4CC(0xA9, tag_name[0], tag_name[1], tag_name[2]);\n\t\t\t} else {\n\t\t\t\titag = gf_crc_32(tag_name, (u32) strlen(tag_name));\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[MP4Mux] Tag name %s is not a 4CC, using CRC32 %08X as value\\n\", tag_name, itag));\n\t\t\t}\n\t\t}\n\n\t\tif (itag==GF_ISOM_ITUNE_TOOL) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (tag->type) {\n\t\tcase GF_PROP_STRING:\n\t\tcase GF_PROP_NAME:\n\t\t\tlen = tag->value.string ? (u32) strlen(tag->value.string) : 0;\n\t\t\te = gf_isom_apple_set_tag(ctx->file, itag, tag->value.string, len, 0, 0);\n\t\t\tbreak;\n\t\tcase GF_PROP_BOOL:\n\t\t\te = gf_isom_apple_set_tag(ctx->file, itag, NULL, 0, tag->value.boolean, 0);\n\t\t\tbreak;\n\t\tcase GF_PROP_UINT:\n\t\tcase GF_PROP_4CC:\n\t\t\te = gf_isom_apple_set_tag(ctx->file, itag, NULL, 0, tag->value.uint, 0);\n\t\t\tbreak;\n\t\tcase GF_PROP_LUINT:\n\t\t\te = gf_isom_apple_set_tag(ctx->file, itag, NULL, 0, tag->value.longuint, 0);\n\t\t\tbreak;\n\t\tcase GF_PROP_FRACTION:\n\t\t\te = gf_isom_apple_set_tag(ctx->file, itag, NULL, 0, tag->value.frac.num, tag->value.frac.den);\n\t\t\tbreak;\n\t\tcase GF_PROP_DATA:\n\t\tcase GF_PROP_CONST_DATA:\n\t\t\te = gf_isom_apple_set_tag(ctx->file, itag, tag->value.data.ptr, tag->value.data.size, 0, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set tag %s: invalid data format\\n\", gf_itags_get_name(tag_idx) ));\n\t\t\te = GF_OK;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set tag %s: %s\\n\", tag_name, gf_error_to_string(e)));\n\t\t}\n\t}\n}\n\nstatic void mp4_mux_set_udta(GF_MP4MuxCtx *ctx, TrackWriter *tkw)\n{\n\tu32 idx=0;\n\twhile (1) {\n\t\tGF_Err e;\n\t\tu32 prop_4cc=0;\n\t\tconst char *udta_name=NULL;\n\t\tconst GF_PropertyValue *udta = gf_filter_pid_enum_properties(tkw->ipid, &idx, &prop_4cc, &udta_name);\n\t\tif (!udta) break;\n\t\tif (!udta_name)\n\t\t\tcontinue;\n\t\tif (!strncmp(udta_name, \"udta_\", 5) || !strncmp(udta_name, \"mudta_\", 6) ) {\n\t\t\tu32 udta_type;\n\t\t\tu8 *data=NULL;\n\t\t\tu32 size=0;\n\t\t\tu32 track_num = 0;\n\n\t\t\tif (!strncmp(udta_name, \"udta_\", 5)) {\n\t\t\t\tudta_name += 5;\n\t\t\t\ttrack_num = tkw->track_num;\n\t\t\t} else {\n\t\t\t\tudta_name += 6;\n\t\t\t}\n\n\t\t\tif (strlen(udta_name) != 4) continue;\n\t\t\tudta_type = GF_4CC(udta_name[0], udta_name[1], udta_name[2], udta_name[3]);\n\n\t\t\tif (udta->type==GF_PROP_DATA) {\n\t\t\t\tdata = (u8 *) udta->value.data.ptr;\n\t\t\t\tsize = udta->value.data.size;\n\t\t\t} else if ((udta->type == GF_PROP_STRING) && udta->value.string) {\n\t\t\t\tdata = (u8 *) udta->value.string;\n\t\t\t\tsize = (u32) strlen(udta->value.string)+1;\n\t\t\t}\n\t\t\tif (!data) {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t} else {\n\t\t\t\te = gf_isom_add_user_data(ctx->file, track_num, udta_type, NULL, data, size);\n\t\t\t}\n\t\t}\n\t\telse if (!strcmp(udta_name, \"udtab\") || !strcmp(udta_name, \"mudtab\")) {\n\t\t\tu32 track_num = (!strcmp(udta_name, \"mudtab\")) ? 0 : tkw->track_num;\n\t\t\tif (udta->type == GF_PROP_DATA) {\n\t\t\t\te = gf_isom_add_user_data_boxes(ctx->file, track_num, udta->value.data.ptr, udta->value.data.size);\n\t\t\t} else {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t}\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set udta %s: %s\\n\", udta_name, gf_error_to_string(e)));\n\t\t}\n\t}\n}\n\nstatic void update_chap_refs(GF_MP4MuxCtx *ctx)\n{\n\tu32 i, j, count = gf_list_count(ctx->tracks);\n\tfor (i=0; i<count; i++) {\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tif (!tkw->is_chap) continue;\n\t\tfor (j=0; j<count; j++) {\n\t\t\tTrackWriter *atkw = gf_list_get(ctx->tracks, j);\n\t\t\tif (atkw->is_chap) continue;\n\t\t\tif ((atkw->stream_type==GF_STREAM_AUDIO) || (atkw->stream_type==GF_STREAM_VISUAL))\n\t\t\t\tgf_isom_set_track_reference(ctx->file, atkw->track_num, GF_ISOM_REF_CHAP, tkw->track_id);\n\t\t}\n\t}\n}\n\n\n\nstatic GF_Err mp4_mux_setup_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_true_pid)\n{\n\tvoid mux_assign_mime_file_ext(GF_FilterPid *ipid, GF_FilterPid *opid, const char *file_exts, const char *mime_types, const char *def_ext);\n\tBool use_m4sys = GF_FALSE;\n\tBool use_tx3g = GF_FALSE;\n\tBool use_webvtt = GF_FALSE;\n\tBool needs_track = GF_FALSE;\n\tu32 needs_sample_entry = 0; //1: change of codecID, 2 change of decoder config\n\tBool use_gen_sample_entry = GF_FALSE;\n\tBool skip_crypto = GF_FALSE;\n\tBool use_3gpp_config = GF_FALSE;\n\tBool use_ac3_entry = GF_FALSE;\n\tBool use_flac_entry = GF_FALSE;\n\tBool use_avc = GF_FALSE;\n\tBool use_hevc = GF_FALSE;\n\tBool use_vvc = GF_FALSE;\n\tBool use_hvt1 = GF_FALSE;\n\tBool use_av1 = GF_FALSE;\n\tBool use_vpX = GF_FALSE;\n\tBool use_mj2 = GF_FALSE;\n\tBool use_opus = GF_FALSE;\n\tBool use_dref = GF_FALSE;\n\tBool skip_dsi = GF_FALSE;\n\tBool is_text_subs = GF_FALSE;\n\tBool force_colr = GF_FALSE;\n\tu32 gen_dsi_wrap = 0;\n\tu32 m_subtype=0;\n\tu32 m_subtype_src=0;\n\tu32 m_subtype_alt_raw=0;\n\tu32 override_stype=0;\n\tu32 width, height, sr, nb_chan, nb_bps, z_order, txt_fsize;\n\tu32 afmt_flags = 0;\n\tu64 ch_layout;\n\tGF_Fraction fps, sar;\n\tGF_List *multi_pid_stsd = NULL;\n\tu32 multi_pid_idx = 0;\n\tGF_FilterPid *orig_pid = NULL;\n\tu32 codec_id, pix_fmt=0;\n\tu32 frames_per_sample_backup=0;\n\tu32 is_nalu_backup = NALU_NONE;\n\tBool is_tile_base = GF_FALSE;\n\tBool unknown_generic = GF_FALSE;\n\tu32 multi_pid_final_stsd_idx = 0;\n\tu32 audio_pli=0;\n\tu32 prev_codecid=0;\n\tBool force_tk_layout = GF_FALSE;\n\tBool force_mix_xps = GF_FALSE;\n\tBool make_inband_headers = GF_FALSE;\n\tBool is_prores = GF_FALSE;\n\tconst char *lang_name = NULL;\n\tconst char *comp_name = NULL;\n\tconst char *imp_name = NULL;\n\tconst char *src_url = NULL;\n\tconst char *meta_mime = NULL;\n\tconst char *meta_encoding = NULL;\n\tconst char *meta_config = NULL;\n\tconst char *meta_xmlns = NULL;\n\tconst char *meta_schemaloc = NULL;\n\tconst char *meta_auxmimes = NULL;\n\tconst char *meta_content_encoding = NULL;\n\tchar *txt_font = NULL;\n\n\tu32 i, count, reuse_stsd = 0;\n\tGF_Err e;\n\tconst GF_PropertyValue *dsi=NULL;\n\tconst GF_PropertyValue *enh_dsi=NULL;\n\tconst GF_PropertyValue *p;\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_AudioSampleEntryImportMode ase_mode = ctx->ase;\n\tTrackWriter *tkw;\n\tu32 xps_inband = XPS_IB_NO;\n\n\tif (ctx->owns_mov && !ctx->opid) {\n\t\tchar *dst;\n\t\tctx->opid = gf_filter_pid_new(filter);\n\n\t\tdst = gf_filter_get_dst_name(filter);\n\t\tif (dst) {\n\t\t\tchar *ext = gf_file_ext_start(dst);\n\t\t\tif (ext && (!stricmp(ext, \".mov\") || !stricmp(ext, \".qt\")) ) {\n\t\t\t\tctx->make_qt = 1;\n\t\t\t}\n\t\t\tgf_free(dst);\n\t\t}\n\t} else {\n\t\tconst char *fname = gf_isom_get_filename(ctx->file);\n\t\tchar *ext = fname ? gf_file_ext_start(fname) : NULL;\n\t\tif (ext && (!stricmp(ext, \".mov\") || !stricmp(ext, \".qt\")) ) {\n\t\t\tctx->make_qt = 1;\n\t\t}\n\t}\n\t//copy properties at init or reconfig\n\tif (ctx->opid && is_true_pid) {\n\t\tgf_filter_pid_copy_properties(ctx->opid, pid);\n\t\tif (gf_list_count(ctx->tracks)>1)\n\t\t\tgf_filter_pid_set_name(ctx->opid, \"isobmf_mux\");\n\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, NULL);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT, NULL);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, NULL);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_FILE) );\n\n\t\tmux_assign_mime_file_ext(pid, ctx->opid, ISOM_FILE_EXT, ISOM_FILE_MIME, NULL);\n\t\t\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DASH_MODE, NULL);\n\t\t//we dispatch timing in milliseconds\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(1000));\n\n\t\tswitch (ctx->store) {\n\t\tcase MP4MX_MODE_FLAT:\n\t\tcase MP4MX_MODE_FASTSTART:\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DISABLE_PROGRESSIVE, &PROP_UINT(GF_PID_FILE_PATCH_INSERT) );\n\t\t\tbreak;\n\t\tcase MP4MX_MODE_INTER:\n\t\tcase MP4MX_MODE_TIGHT:\n\t\t\tgf_filter_pid_allow_direct_dispatch(ctx->opid);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TILE_BASE);\n\tif (p && p->value.boolean)\n\t\tis_tile_base = GF_TRUE;\n\n\tif (is_true_pid && !is_tile_base) {\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DASH_MULTI_TRACK);\n\t\tif (p) {\n\t\t\tu32 j, count2;\n\t\t\tGF_List *multi_tracks = p->value.ptr;\n\t\t\tcount = gf_list_count(multi_tracks);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_FilterPid *a_ipid = gf_list_get(multi_tracks, i);\n\t\t\t\tconst GF_PropertyValue *a_pidid = gf_filter_pid_get_property(a_ipid, GF_PROP_PID_ID);\n\t\t\t\tcount2 = gf_list_count(ctx->tracks);\n\t\t\t\tfor (j=0; j<count2; j++) {\n\t\t\t\t\tTrackWriter *atkw = gf_list_get(ctx->tracks, j);\n\t\t\t\t\tconst GF_PropertyValue *c_pidid = gf_filter_pid_get_property(atkw->ipid, GF_PROP_PID_ID);\n\t\t\t\t\tif (gf_props_equal(a_pidid, c_pidid)) {\n\t\t\t\t\t\ta_ipid = NULL;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (a_ipid)\n\t\t\t\t\tmp4_mux_setup_pid(filter, a_ipid, GF_FALSE);\n\t\t\t}\n\t\t}\n\t}\n\n\taudio_pli = gf_isom_get_pl_indication(ctx->file, GF_ISOM_PL_AUDIO);\n\n\t//new pid ?\n\ttkw = gf_filter_pid_get_udta(pid);\n\tif (!tkw) {\n\t\tGF_FilterEvent evt;\n\t\tGF_SAFEALLOC(tkw, TrackWriter);\n\t\tif (!tkw) return GF_OUT_OF_MEM;\n\t\t\n\t\tgf_list_add(ctx->tracks, tkw);\n\t\ttkw->ipid = pid;\n\t\ttkw->fake_track = !is_true_pid;\n\t\ttkw->min_cts = (u64) -1;\n\n\t\tif (is_true_pid) {\n\t\t\tgf_filter_pid_set_udta(pid, tkw);\n\n\t\t\ttkw->is_hevc_tile_base = is_tile_base;\n#ifdef GPAC_ENABLE_COVERAGE\n\t\t\tif (gf_sys_is_cov_mode()) {\n\t\t\t\tgf_filter_pid_get_min_pck_duration(pid);\n\t\t\t}\n#endif\n\t\t\tif (!ctx->owns_mov || ctx->force_play) {\n\t\t\t\tif (!ctx->owns_mov) {\n\t\t\t\t\tif (ctx->start != 0)\n\t\t\t\t\t\ttkw->wait_sap = GF_TRUE;\n\t\t\t\t\tgf_filter_pid_init_play_event(pid, &evt, ctx->start, 0, \"MP4Mux\");\n\t\t\t\t} else {\n\t\t\t\t\tGF_FEVT_INIT(evt, GF_FEVT_PLAY, pid);\n\t\t\t\t}\n\t\t\t\tgf_filter_pid_send_event(pid, &evt);\n\t\t\t}\n\t\t\tgf_filter_pid_set_framing_mode(pid, GF_TRUE);\n\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ITEM_ID);\n\t\t\tif (p) {\n\t\t\t\ttkw->is_item = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tctx->config_timing = GF_TRUE;\n\t\t\t\tctx->update_report = GF_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\t//check change of pid config\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DEPENDENCY_ID);\n\tif (p) {\n\t\tif (p->value.uint!=tkw->dep_id) needs_track = GF_TRUE;\n\t\ttkw->dep_id = p->value.uint;\n\t}\n\n\t//check change of pid config\n\tprev_codecid = tkw->codecid;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CODECID);\n\tif (p) {\n\t\tif (p->value.uint!=tkw->codecid) needs_sample_entry = 1;\n\t\ttkw->codecid = p->value.uint;\n\t}\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_STREAM_TYPE);\n\tif (p) {\n\t\tu32 stype = p->value.uint;\n\t\tif (tkw->is_encrypted && (p->value.uint==GF_STREAM_ENCRYPTED) ) {\n\t\t\tstype = gf_codecid_type(tkw->codecid);\n\t\t}\n\t\tif (stype != tkw->stream_type) {\n\t\t\tneeds_track = GF_TRUE;\n\t\t\ttkw->stream_type = stype;\n\t\t\tconst char *name = gf_stream_type_name(stype);\n\t\t\ttkw->status_type = name ? name[0] : 'U';\n\t\t}\n\t}\n\n\tdsi = gf_filter_pid_get_property(pid, GF_PROP_PID_DECODER_CONFIG);\n\tif (dsi) {\n\t\tu32 cfg_crc = gf_crc_32(dsi->value.data.ptr, dsi->value.data.size);\n\t\tif ((cfg_crc!=tkw->cfg_crc) && !needs_sample_entry)\n\t\t\tneeds_sample_entry = 2;\n\t\ttkw->cfg_crc = cfg_crc;\n\t} else if (tkw->cfg_crc) {\n\t\ttkw->cfg_crc = 0;\n\t\tif (!needs_sample_entry)\n\t\t\tneeds_sample_entry = 2;\n\t}\n\n\tenh_dsi = gf_filter_pid_get_property(pid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT);\n\tif (enh_dsi && (enh_dsi->type==GF_PROP_DATA) ) {\n\t\tu32 cfg_crc = gf_crc_32(enh_dsi->value.data.ptr, enh_dsi->value.data.size);\n\t\tif ((cfg_crc!=tkw->enh_cfg_crc) && !needs_sample_entry)\n\t\t\tneeds_sample_entry = 2;\n\t\ttkw->enh_cfg_crc = cfg_crc;\n\t} else if (tkw->enh_cfg_crc) {\n\t\ttkw->enh_cfg_crc = 0;\n\t\tif (!needs_sample_entry)\n\t\t\tneeds_sample_entry = 2;\n\t}\n\n\t//store current cenc pattern if any\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CENC_PATTERN);\n\tif (p) {\n\t\ttkw->skip_byte_block = p->value.frac.num;\n\t\ttkw->crypt_byte_block = p->value.frac.den;\n\t} else {\n\t\ttkw->skip_byte_block = tkw->crypt_byte_block = 0;\n\t}\n\n\t//TODO: try to merge PPS/SPS for AVC and HEVC rather than creating a new sample description\n\n\tswitch (tkw->codecid) {\n\tcase GF_CODECID_AAC_MPEG4:\n\tcase GF_CODECID_AAC_MPEG2_MP:\n\tcase GF_CODECID_AAC_MPEG2_LCP:\n\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\tcase GF_CODECID_USAC:\n\tcase GF_CODECID_MPEG4_PART2:\n\tcase GF_CODECID_AVC:\n\tcase GF_CODECID_SVC:\n\tcase GF_CODECID_HEVC:\n\tcase GF_CODECID_LHVC:\n\tcase GF_CODECID_MPEG1:\n\tcase GF_CODECID_MPEG2_422:\n\tcase GF_CODECID_MPEG2_SNR:\n\tcase GF_CODECID_MPEG2_HIGH:\n\tcase GF_CODECID_MPEG2_MAIN:\n\tcase GF_CODECID_MPEG2_SIMPLE:\n\tcase GF_CODECID_MPEG2_SPATIAL:\n\tcase GF_CODECID_VP8:\n\tcase GF_CODECID_VP9:\n\tcase GF_CODECID_AV1:\n\tcase GF_CODECID_AC3:\n\tcase GF_CODECID_EAC3:\n\tcase GF_CODECID_OPUS:\n\tcase GF_CODECID_TRUEHD:\n\tcase GF_CODECID_RAW_UNCV:\n\t\tif (!dsi && !enh_dsi) return GF_OK;\n\t\tbreak;\n\tcase GF_CODECID_APCH:\n\tcase GF_CODECID_APCO:\n\tcase GF_CODECID_APCN:\n\tcase GF_CODECID_APCS:\n\tcase GF_CODECID_AP4X:\n\tcase GF_CODECID_AP4H:\n\t\tif (!ctx->make_qt) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[MP4Mux] ProRes track detected, muxing to QTFF even though ISOBMFF was asked\\n\"));\n\t\t\tctx->make_qt = 2;\n\t\t}\n\t\tif (ctx->prores_track && (ctx->prores_track != tkw)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] More than one ProRes track detected, result might be non compliant\\n\"));\n\t\t}\n\t\tis_prores = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_TX3G:\n\tcase GF_CODECID_WEBVTT:\n\tcase GF_CODECID_DVB_SUBS:\n\t\tif (!dsi && !enh_dsi) return GF_OK;\n\t\tbreak;\n\tcase GF_CODECID_RAW:\n\t\tif (tkw->stream_type==GF_STREAM_VISUAL) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PIXFMT);\n\t\t\tif (!p) return GF_OK;\n\t\t}\n\t\tif (tkw->stream_type==GF_STREAM_AUDIO) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_AUDIO_FORMAT);\n\t\t\tif (!p) return GF_OK;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (!tkw->track_num) {\n\t\tneeds_sample_entry = 1;\n\t\tneeds_track = GF_TRUE;\n\t}\n\n\tif (ctx->make_qt) {\n\t\tgf_isom_remove_root_od(ctx->file);\n\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_QT, 512);\n\t\tgf_isom_reset_alt_brands(ctx->file);\n\t\ttkw->has_brands = GF_TRUE;\n\t\tctx->major_brand_set = GF_ISOM_BRAND_QT;\n\t\tctx->btrt = GF_FALSE;\n\n\t\tif (is_prores && !ctx->prores_track) {\n\t\t\tctx->prores_track = tkw;\n\t\t}\n\t}\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_URL);\n\tif (p) src_url = p->value.string;\n\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DASH_MODE);\n\tif (p) {\n\t\tctx->dash_mode = MP4MX_DASH_ON;\n\t\tif (p->value.uint==2) {\n\t\t\te = mp4mx_setup_dash_vod(ctx, tkw);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\t//we consider that when muxing single segments, we are always in DASH, not VoD mode\n\telse if (ctx->noinit) {\n\t\tctx->dash_mode = MP4MX_DASH_ON;\n\t}\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_LLHLS);\n\tctx->llhls_mode = p ? p->value.uint : 0;\n\t//insert tfdt in each traf for LL-HLS so that correct timing can be found when doing in-segment tune-in\n\tif (ctx->llhls_mode) {\n\t\tctx->tfdt_traf = GF_TRUE;\n\t\tctx->store = MP4MX_MODE_SFRAG;\n\t}\n\n\tif (ctx->dash_mode == MP4MX_DASH_ON) {\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FORCE_SEG_SYNC);\n\t\tif (p && p->value.boolean)\n\t\t\tctx->force_seg_sync = GF_TRUE;\n\t}\n\n\tif (!ctx->cdur_set) {\n\t\tctx->cdur_set = GF_TRUE;\n\t\tif (ctx->cdur.num<0) {\n\t\t\tif (ctx->make_qt) {\n\t\t\t\tctx->cdur.num = 1000;\n\t\t\t\tctx->cdur.den = 2000;\n\t\t\t} else {\n\t\t\t\tctx->cdur.num = 1000;\n\t\t\t\tctx->cdur.den = 1000;\n\t\t\t\tif (ctx->dash_mode)\n\t\t\t\t\tctx->fragdur = GF_FALSE;\n\t\t\t}\n\t\t} else if (ctx->dash_mode)\n\t\t\tctx->fragdur = GF_TRUE;\n\t}\n\n\tif (needs_track) {\n\t\tif (ctx->init_movie_done) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot add track to already finalized movie in fragmented file, will request a new muxer for that track\\n\"));\n\t\t\treturn GF_REQUIRES_NEW_INSTANCE;\n\t\t}\n\t\tif (tkw->is_item) {\n\t\t\tneeds_track = GF_FALSE;\n\n\t\t\tif (tkw->stream_type == GF_STREAM_ENCRYPTED) {\n\t\t\t\ttkw->is_encrypted = GF_TRUE;\n\t\t\t\ttkw->stream_type = gf_codecid_type(tkw->codecid);\n\t\t\t\ttkw->insert_pssh = GF_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (needs_track) {\n\t\tu32 tkid=0;\n\t\tu32 tk_idx=0;\n\t\tu32 mtype=0;\n\t\tu32 target_timescale = 0;\n\t\tBool hdlr_name_set=GF_FALSE;\n\n\t\tif (ctx->make_qt && (tkw->stream_type==GF_STREAM_VISUAL)) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FPS);\n\t\t\tif (p) {\n\t\t\t\tu32 ts=p->value.frac.num, inc=p->value.frac.den;\n\t\t\t\tif (inc * 24000 == ts * 1001) target_timescale = 24000;\n\t\t\t\telse if (inc * 2400 == ts * 100) target_timescale = 2400;\n\t\t\t\telse if (inc * 2500 == ts * 100) target_timescale = 2500;\n\t\t\t\telse if (inc * 30000 == ts * 1001) target_timescale = 30000;\n\t\t\t\telse if (inc * 2997 == ts * 100) target_timescale = 30000;\n\t\t\t\telse if (inc * 3000 == ts * 100) target_timescale = 3000;\n\t\t\t\telse if (inc * 5000 == ts * 100) target_timescale = 5000;\n\t\t\t\telse if (inc * 60000 == ts * 1001) target_timescale = 60000;\n\t\t\t\telse if (inc * 5994 == ts * 100) target_timescale = 60000;\n\t\t\t\telse if (is_prores) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[ProRes] Unrecognized frame rate %g\\n\", ((Double)ts)/inc ));\n\t\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ctx->prores_track)\n\t\t\t\tctx->prores_track = tkw;\n\t\t}\n\n\t\tif (!ctx->moov_inserted) {\n\t\t\tif (target_timescale) {\n\t\t\t\tctx->moovts = target_timescale;\n\t\t\t\tgf_isom_set_timescale(ctx->file, target_timescale);\n\t\t\t} else if (ctx->moovts>=0) {\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_MOVIE_TIME);\n\t\t\t\tif (p && p->value.lfrac.den) {\n\t\t\t\t\tgf_isom_set_timescale(ctx->file, (u32) p->value.lfrac.den);\n\t\t\t\t\tctx->moovts = (u32) p->value.lfrac.den;\n\t\t\t\t} else {\n\t\t\t\t\tgf_isom_set_timescale(ctx->file, ctx->moovts);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ctx->store==MP4MX_MODE_FASTSTART) {\n\t\t\t\tgf_isom_make_interleave_ex(ctx->file, &ctx->cdur);\n\t\t\t}\n\t\t}\n\n\t\t//assign some defaults\n\t\ttkw->src_timescale = 0;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\t\tif (p) tkw->src_timescale = p->value.uint;\n\n\t\tu32 mtimescale = 1000;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_SAMPLE_RATE);\n\t\tif (p) mtimescale = p->value.uint;\n\t\telse {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FPS);\n\t\t\tif (p && p->value.frac.den) mtimescale = p->value.frac.den;\n\t\t}\n\t\tif (!tkw->src_timescale) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] No timescale specified, guessing from media: %d\\n\", mtimescale));\n\t\t\ttkw->src_timescale = mtimescale;\n\t\t}\n\t\tif (target_timescale) tkw->tk_timescale = target_timescale;\n\t\telse if (ctx->mediats>0) tkw->tk_timescale = ctx->mediats;\n\t\telse if (ctx->mediats<0) tkw->tk_timescale = mtimescale;\n\t\telse tkw->tk_timescale = tkw->src_timescale;\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ESID);\n\t\tif (!p) p = gf_filter_pid_get_property(pid, GF_PROP_PID_ID);\n\t\tif (p) tkid = p->value.uint;\n\n\t\tif (tkw->stream_type == GF_STREAM_ENCRYPTED) {\n\t\t\ttkw->is_encrypted = GF_TRUE;\n\t\t\ttkw->stream_type = gf_codecid_type(tkw->codecid);\n\t\t}\n\t\tmtype = gf_isom_stream_type_to_media_type(tkw->stream_type, tkw->codecid);\n\n\t\tif (ctx->moovts<0) {\n\t\t\tctx->moovts = tkw->tk_timescale;\n\t\t\tgf_isom_set_timescale(ctx->file, (u32) ctx->moovts);\n\t\t}\n\t\tif (ctx->pad_sparse) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_SPARSE);\n\t\t\tif (p) {\n\t\t\t\ttkw->sparse_inject = p->value.boolean;\n\t\t\t} else {\n\t\t\t\tswitch (tkw->stream_type) {\n\t\t\t\tcase GF_STREAM_TEXT:\n\t\t\t\tcase GF_STREAM_METADATA:\n\t\t\t\t\tswitch (tkw->codecid) {\n\t\t\t\t\tcase GF_CODECID_TEXT_MPEG4:\n\t\t\t\t\tcase GF_CODECID_TX3G:\n\t\t\t\t\tcase GF_CODECID_WEBVTT:\n\t\t\t\t\tcase GF_CODECID_SUBS_XML:\n\t\t\t\t\tcase GF_CODECID_SUBPIC:\n\t\t\t\t\tcase GF_CODECID_TMCD:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\ttkw->sparse_inject = GF_TRUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_MUX_INDEX);\n\t\tif (p) {\n\t\t\ttk_idx = p->value.uint;\n\t\t\tif (!ctx->owns_mov) {\n\t\t\t\tu32 nb_dst_tk = gf_isom_get_track_count(ctx->file);\n\t\t\t\tif (tk_idx < nb_dst_tk) {\n\t\t\t\t\t//tk_idx = nb_dst_tk;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->keep_utc) {\n\t\t\tif (!gf_isom_get_track_count(ctx->file)) {\n\t\t\t\tu64 create_date=0, modif_date=0;\n\t\t\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"isom:creation_date\");\n\t\t\t\tif (p && (p->type==GF_PROP_LUINT)) create_date = p->value.longuint;\n\t\t\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"isom:modification_date\");\n\t\t\t\tif (p && (p->type==GF_PROP_LUINT)) modif_date = p->value.longuint;\n\n\t\t\t\tif (create_date && modif_date)\n\t\t\t\t\tgf_isom_set_creation_time(ctx->file, create_date, modif_date);\n\t\t\t}\n\t\t\tgf_isom_keep_utc_times(ctx->file, GF_TRUE);\n\t\t}\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_TRACK_TEMPLATE);\n\t\tif (ctx->tktpl && p && p->value.data.ptr) {\n\t\t\tBool udta_only = (ctx->tktpl==2) ? GF_TRUE : GF_FALSE;\n\n\n\t\t\ttkw->track_num = gf_isom_new_track_from_template(ctx->file, tkid, mtype, tkw->tk_timescale, p->value.data.ptr, p->value.data.size, udta_only);\n\t\t\tif (!tkw->track_num) {\n\t\t\t\ttkw->track_num = gf_isom_new_track_from_template(ctx->file, 0, mtype, tkw->tk_timescale, p->value.data.ptr, p->value.data.size, udta_only);\n\t\t\t}\n\t\t\t//purge all track references we inject internally\n\t\t\tif (tkw->track_num) {\n\t\t\t\tgf_isom_remove_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_SCAL);\n\t\t\t\tgf_isom_remove_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_SABT);\n\t\t\t\tgf_isom_remove_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_TBAS);\n\t\t\t\tgf_isom_remove_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_OREF);\n\t\t\t\tgf_isom_remove_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_BASE);\n\t\t\t}\n\n\t\t\tif (!ctx->btrt) {\n\t\t\t\tgf_isom_update_bitrate(ctx->file, tkw->track_num, 0, 0, 0, 0);\n\t\t\t}\n\t\t\tif (!udta_only) {\n\t\t\t\tGF_Err gf_isom_set_track_stsd_templates(GF_ISOFile *movie, u32 trackNumber, u8 *stsd_data, u32 stsd_data_size);\n\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_STSD_ALL_TEMPLATES);\n\t\t\t\tif (p) {\n\t\t\t\t\tgf_isom_set_track_stsd_templates(ctx->file, tkw->track_num, p->value.data.ptr, p->value.data.size);\n\t\t\t\t\ttkw->all_stsd_crc = gf_crc_32(p->value.data.ptr, p->value.data.size);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tif (!mtype) {\n\t\t\t\tmtype = GF_4CC('u','n','k','n');\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to find ISOM media type for stream type %s codec %s\\n\", gf_stream_type_name(tkw->stream_type), gf_codecid_name(tkw->codecid) ));\n\t\t\t}\n\t\t\tif (!tkid) tkid = tk_idx;\n\n\t\t\tif (ctx->trackid) {\n\t\t\t\tif (ctx->trackid==(u32)-1) tkid = 0;\n\t\t\t\telse tkid = ctx->trackid;\n\t\t\t}\n\n\t\t\ttkw->track_num = gf_isom_new_track(ctx->file, tkid, mtype, tkw->tk_timescale);\n\t\t\tif (!tkw->track_num) {\n\t\t\t\ttkw->track_num = gf_isom_new_track(ctx->file, 0, mtype, tkw->tk_timescale);\n\t\t\t}\n\t\t\t//FIXME once we finally merge to filters, there is an old bug in isobmff initializing the width and height to 320x240 which breaks text import\n\t\t\t//this should be removed and hashes regenerated\n\t\t\tgf_isom_set_track_layout_info(ctx->file, tkw->track_num, 0, 0, 0, 0, 0);\n\n\t\t\tif (!gf_sys_is_test_mode() && !gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_HANDLER)) {\n\t\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_URL);\n\t\t\t\tif (tkw->track_num && p && p->value.string) {\n\t\t\t\t\tchar szHName[1025];\n\t\t\t\t\tchar *f = gf_file_basename(p->value.string);\n\t\t\t\t\tszHName[1024]=0;\n\t\t\t\t\tsnprintf(szHName, 1024, \"*%s@GPAC%s\", f ? f : \"\", gf_gpac_version() );\n\t\t\t\t\tgf_isom_set_handler_name(ctx->file, tkw->track_num, szHName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!tkw->track_num) {\n\t\t\te = gf_isom_last_error(ctx->file);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to create new track: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->track_id = gf_isom_get_track_id(ctx->file, tkw->track_num);\n\n\t\tBool is_disabled = GF_FALSE;\n\t\t//cmaf mandates these flags and only them are set\n\t\tif (ctx->cmaf) {\n\t\t\tgf_isom_set_track_flags(ctx->file, tkw->track_num, GF_ISOM_TK_ENABLED|GF_ISOM_TK_IN_MOVIE|GF_ISOM_TK_IN_PREVIEW, GF_ISOM_TKFLAGS_SET);\n\t\t}\n\t\telse {\n\t\t\t//unless in test mode or old arch compat, set track to be enabled, in movie and in preview\n\t\t\tif (!gf_sys_is_test_mode() && !gf_sys_old_arch_compat()) {\n\t\t\t\tgf_isom_set_track_flags(ctx->file, tkw->track_num, GF_ISOM_TK_IN_MOVIE|GF_ISOM_TK_IN_PREVIEW, GF_ISOM_TKFLAGS_SET);\n\t\t\t}\n\n\t\t\t//override flags if provided\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_TRACK_FLAGS);\n\t\t\tif (p) {\n\t\t\t\tgf_isom_set_track_flags(ctx->file, tkw->track_num, p->value.uint, GF_ISOM_TKFLAGS_SET);\n\t\t\t} else {\n\t\t\t\tgf_isom_set_track_enabled(ctx->file, tkw->track_num, GF_TRUE);\n\t\t\t}\n\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DISABLED);\n\t\t\tif (p && p->value.boolean) {\n\t\t\t\tgf_isom_set_track_enabled(ctx->file, tkw->track_num, GF_FALSE);\n\t\t\t\tis_disabled = GF_TRUE;\n\t\t\t}\n\t\t}\n\n\t\t//if we have a subtype set for the pid, use it\n\t\tp = NULL;\n\t\tif ((tkw->stream_type==GF_STREAM_TEXT) && (tkw->codecid==GF_CODECID_TX3G)) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_IS_CHAP);\n\t\t\tif (p && p->value.boolean) {\n\t\t\t\tmtype = GF_ISOM_MEDIA_TEXT;\n\t\t\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, mtype);\n\t\t\t\ttkw->is_chap = GF_TRUE;\n\t\t\t\tctx->has_chap_tracks = GF_TRUE;\n\t\t\t\tgf_isom_set_track_enabled(ctx->file, tkw->track_num, GF_FALSE);\n\t\t\t} else {\n\t\t\t\tp = NULL;\n\t\t\t}\n\t\t}\n\t\tif (!p) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_SUBTYPE);\n\t\t\tif (p) {\n\t\t\t\tmtype = p->value.uint;\n\t\t\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, mtype);\n\t\t\t}\n\t\t}\n\t\tif (ctx->has_chap_tracks)\n\t\t\tupdate_chap_refs(ctx);\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_HANDLER);\n\t\tif (p && p->value.string) {\n\t\t\tgf_isom_set_handler_name(ctx->file, tkw->track_num, p->value.string);\n\t\t\thdlr_name_set = GF_TRUE;\n\t\t}\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_ALT_GROUP);\n\t\tif (p && p->value.uint) {\n\t\t\tgf_isom_set_alternate_group_id(ctx->file, tkw->track_num, p->value.uint);\n\t\t} else if (!p && !gf_sys_is_test_mode()) {\n\t\t\t//we by default set groups for audio and subs if group is not present\n\t\t\tif (mtype==GF_ISOM_SUBTYPE_SUBTITLE) {\n\t\t\t\tgf_isom_set_alternate_group_id(ctx->file, tkw->track_num, 2);\n\t\t\t}\n\t\t\tif (tkw->stream_type==GF_STREAM_AUDIO) {\n\t\t\t\tgf_isom_set_alternate_group_id(ctx->file, tkw->track_num, 1);\n\t\t\t}\n\t\t}\n\n\t\t//check if we have default flag set\n\t\tif (!is_disabled && !ctx->cmaf) {\n\t\t\tBool *has_def = NULL;\n\t\t\tif (tkw->stream_type==GF_STREAM_VISUAL) has_def = &ctx->has_def_vid;\n\t\t\telse if (tkw->stream_type==GF_STREAM_AUDIO) has_def = &ctx->has_def_aud;\n\t\t\telse if (tkw->stream_type==GF_STREAM_TEXT) has_def = &ctx->has_def_txt;\n\n\t\t\tBool set_def = GF_FALSE;\n\t\t\tBool set_all_def = GF_FALSE;\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_IS_DEFAULT);\n\t\t\t//first track of this kind set to default, deactivate all except this track\n\t\t\tif (has_def && ! *has_def && p && p->value.boolean) {\n\t\t\t\t*has_def = GF_TRUE;\n\t\t\t\tset_def = GF_TRUE;\n\t\t\t}\n\t\t\t//second or more track of this kind set to default, re-activate all\n\t\t\telse if (has_def && *has_def && p && p->value.boolean) {\n\t\t\t\tset_all_def = GF_TRUE;\n\t\t\t}\n\t\t\tif (set_def || set_all_def) {\n\t\t\t\tu32 nb_tk = gf_list_count(ctx->tracks);\n\t\t\t\tfor (i=0; i<nb_tk; i++) {\n\t\t\t\t\tTrackWriter *atk = gf_list_get(ctx->tracks, i);\n\t\t\t\t\tif (atk->stream_type != tkw->stream_type) continue;\n\t\t\t\t\tif (set_all_def || (tkw == atk)) {\n\t\t\t\t\t\tgf_isom_set_track_flags(ctx->file, atk->track_num, GF_ISOM_TK_IN_MOVIE|GF_ISOM_TK_IN_PREVIEW, GF_ISOM_TKFLAGS_ADD);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_isom_set_track_flags(ctx->file, atk->track_num, GF_ISOM_TK_IN_MOVIE|GF_ISOM_TK_IN_PREVIEW, GF_ISOM_TKFLAGS_REM);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//no default prop and a default exists for this kind, update flags\n\t\t\telse if (has_def && *has_def) {\n\t\t\t\tgf_isom_set_track_flags(ctx->file, tkw->track_num, GF_ISOM_TK_IN_MOVIE|GF_ISOM_TK_IN_PREVIEW, GF_ISOM_TKFLAGS_REM);\n\t\t\t}\n\t\t}\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_TRACK_MATRIX);\n\t\tif (p && (p->value.sint_list.nb_items==9)) {\n\t\t\tgf_isom_set_track_matrix(ctx->file, tkw->track_num, (s32 *) p->value.sint_list.vals);\n\t\t}\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_SRC_MAGIC);\n\t\tif (p) {\n\t\t\tu64 magic = 0;\n\t\t\tif (hdlr_name_set) {\n\t\t\t\tmagic |= 1;\n\t\t\t\tmagic <<= 32;\n\t\t\t}\n\t\t\tmagic |= p->value.longuint;\n\t\t\tgf_isom_set_track_magic(ctx->file, tkw->track_num, magic);\n\t\t}\n\t\tif (tk_idx) {\n\t\t\tgf_isom_set_track_index(ctx->file, tkw->track_num, tk_idx, mp4mux_track_reorder, ctx);\n\t\t\tmp4mux_reorder_tracks(ctx);\n\t\t}\n\n\t\t//by default use cttsv1 (negative ctts)\n\t\tgf_isom_set_composition_offset_mode(ctx->file, tkw->track_num, GF_TRUE);\n\n\t\tp = ctx->make_qt ? NULL : gf_filter_pid_get_property(pid, GF_PROP_PID_PROFILE_LEVEL);\n\t\tif (p) {\n\t\t\ttkw->media_profile_level = p->value.uint;\n\t\t\tif (tkw->stream_type == GF_STREAM_AUDIO) {\n\t\t\t\t//patch to align old arch (IOD not written in dash) with new\n\t\t\t\tif (!ctx->dash_mode) {\n\t\t\t\t\tgf_isom_set_pl_indication(ctx->file, GF_ISOM_PL_AUDIO, p->value.uint);\n\t\t\t\t}\n\t\t\t} else if (tkw->stream_type == GF_STREAM_VISUAL) {\n\t\t\t\t//patch to align old arch (IOD not written in dash) with new\n\t\t\t\tif (!ctx->dash_mode) {\n\t\t\t\t\tgf_isom_set_pl_indication(ctx->file, GF_ISOM_PL_VISUAL, p->value.uint);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->mudta && gf_isom_get_track_count(ctx->file)==1) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_UDTA);\n\t\t\tif (ctx->tktpl && p && p->value.data.ptr) {\n\t\t\t\tgf_isom_load_extra_boxes(ctx->file, p->value.data.ptr, p->value.data.size, (ctx->mudta==2) ? GF_TRUE : GF_FALSE);\n\t\t\t}\n\t\t}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (ctx->sgpd_traf)\n\t\t\tgf_isom_set_sample_group_in_traf(ctx->file);\n#endif\n\t\tif (ctx->noroll) {\n\t\t\tgf_isom_remove_sample_group(ctx->file, tkw->track_num, GF_ISOM_SAMPLE_GROUP_ROLL);\n\t\t}\n\t\tif (ctx->norap) {\n\t\t\tgf_isom_remove_sample_group(ctx->file, tkw->track_num, GF_ISOM_SAMPLE_GROUP_RAP);\n\t\t}\n\n\n\t\tif (ctx->dash_mode==MP4MX_DASH_VOD) {\n\t\t\tBool use_cache = (ctx->vodcache == MP4MX_VODCACHE_ON) ? GF_TRUE : GF_FALSE;\n\t\t\tif ((ctx->vodcache == MP4MX_VODCACHE_REPLACE) && (!ctx->media_dur || !ctx->dash_dur.num) ) {\n\t\t\t\tuse_cache = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (ctx->vodcache==MP4MX_VODCACHE_INSERT) {\n\t\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DISABLE_PROGRESSIVE, &PROP_UINT(GF_PID_FILE_PATCH_INSERT) );\n\t\t\t}\n\t\t\telse if (!use_cache) {\n\t\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DISABLE_PROGRESSIVE, &PROP_UINT(GF_PID_FILE_PATCH_REPLACE) );\n\t\t\t}\n\t\t}\n\n\t\tif (gf_sys_old_arch_compat()) {\n\t\t\tp = gf_filter_pid_get_property_str(pid, \"isom_force_ctts\");\n\t\t\tif (p && p->value.boolean) tkw->force_ctts = GF_TRUE;\n\t\t}\n\t} else {\n\n\t\tu32 old_timescale = tkw->src_timescale;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\t\tif (p) tkw->src_timescale = p->value.uint;\n\t\tif (old_timescale && (tkw->src_timescale != old_timescale)) {\n\t\t\tif (tkw->ts_shift)\n\t\t\t\ttkw->ts_shift = gf_timestamp_rescale(tkw->ts_shift, old_timescale, tkw->src_timescale);\n\t\t}\n\t}\n\n\tif (!tkw->has_brands) {\n\t\tBool ignore_alt = GF_FALSE;\n\t\tBool is_isom = GF_FALSE;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_MBRAND);\n\t\tif (p) {\n\t\t\tu32 brand = p->value.uint;\n\t\t\t//remove QT brand\n\t\t\tif ((brand==GF_ISOM_BRAND_QT) && !ctx->make_qt) {\n\t\t\t\tis_isom = GF_TRUE;\n\t\t\t\tctx->major_brand_set = brand = GF_ISOM_BRAND_ISOM;\n\t\t\t\tgf_isom_set_brand_info(ctx->file, brand, 1);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_QT, GF_FALSE);\n\t\t\t\tignore_alt = GF_TRUE;\n\t\t\t}\n\t\t\telse if (!ctx->major_brand_set) {\n\t\t\t\tgf_isom_set_brand_info(ctx->file, brand, 1);\n\t\t\t\tctx->major_brand_set = brand;\n\t\t\t} else {\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, brand, GF_TRUE);\n\t\t\t}\n\t\t\tif (p->value.uint == GF_ISOM_BRAND_ISOM) is_isom = GF_TRUE;\n\t\t}\n\t\tp = ignore_alt ? NULL : gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_BRANDS);\n\t\tif (p && p->value.uint_list.nb_items) {\n\t\t\ttkw->has_brands = GF_TRUE;\n\t\t\tif (!ctx->major_brand_set) {\n\t\t\t\tctx->major_brand_set = p->value.uint_list.vals[0];\n\t\t\t\tgf_isom_set_brand_info(ctx->file, p->value.uint_list.vals[0], 1);\n\t\t\t}\n\t\t\t//reset alt brands, push old ones\n\t\t\tgf_isom_reset_alt_brands_ex(ctx->file, GF_TRUE);\n\t\t\tfor (i=0; i<p->value.uint_list.nb_items; i++) {\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, p->value.uint_list.vals[i], GF_TRUE);\n\t\t\t\tif (p->value.uint_list.vals[i] == GF_ISOM_BRAND_ISOM) is_isom = GF_TRUE;\n\t\t\t}\n\t\t\t//and in case it was not present add major brand\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, ctx->major_brand_set, GF_TRUE);\n\t\t}\n\t\tif (!ctx->m4sys && !is_isom && !ctx->def_brand_patched) {\n\t\t\t//remove default brand\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\t\tctx->def_brand_patched = GF_TRUE;\n\t\t}\n\n\t\tif (ctx->cmaf) {\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, (ctx->cmaf==MP4MX_CMAF_CMF2) ? GF_ISOM_BRAND_CMF2 : GF_ISOM_BRAND_CMFC, GF_TRUE);\n\t\t}\n\t}\n\n\twidth = height = sr = nb_chan = z_order = txt_fsize = 0;\n\tnb_bps = 16;\n\tch_layout = 0;\n\tfps.num = 25;\n\tfps.den = 1;\n\tsar.num = sar.den = 0;\n\tcodec_id = tkw->codecid;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DASH_MULTI_PID);\n\tif (p) {\n\t\tmulti_pid_stsd = p->value.ptr;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DASH_MULTI_PID_IDX);\n\t\tassert(p);\n\t\tmulti_pid_final_stsd_idx = p->value.uint;\n\n\t\t//should never be the case\n\t\ttkw->xps_inband = XPS_IB_NO;\n\t\tctx->dref = GF_FALSE;\n\t\torig_pid = pid;\n\t\tgoto multipid_stsd_setup;\n\t}\n\n\n\t//WARNING !! from this point on until the goto multipid_stsd_setup, use pid and not tkw->ipid\n\t//so that we setup the sample entry properly for each PIDs\nsample_entry_setup:\n\n\tuse_m4sys = ctx->m4sys;\n\tuse_gen_sample_entry = GF_TRUE;\n\tuse_dref = ctx->dref;\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_WIDTH);\n\tif (p) width = p->value.uint;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_HEIGHT);\n\tif (p) height = p->value.uint;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FPS);\n\tif (p) fps = p->value.frac;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_SAR);\n\tif (p) sar = p->value.frac;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ZORDER);\n\tif (p) z_order = p->value.uint;\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_SAMPLE_RATE);\n\tif (p) sr = p->value.uint;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_NUM_CHANNELS);\n\tif (p) nb_chan = p->value.uint;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_AUDIO_BPS);\n\tif (p) nb_bps = p->value.uint;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CHANNEL_LAYOUT);\n\tif (p) ch_layout = p->value.longuint;\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_LANGUAGE);\n\tif (p) lang_name = p->value.string;\n\n\tif (is_true_pid) {\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_NB_FRAMES);\n\t\ttkw->nb_frames = p ? p->value.uint : 0;\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FRAME_OFFSET);\n\t\ttkw->frame_offset = p ? p->value.uint : 0;\n\t}\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_SUBTYPE);\n\tif (p) m_subtype_src = p->value.uint;\n\n\t//if crypto scheme type changes, we will need a new sample entry\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PROTECTION_SCHEME_TYPE);\n\tif (p && (tkw->scheme_type != p->value.uint))\n\t\tneeds_sample_entry = 1;\n\telse if (!p && tkw->scheme_type)\n\t\tneeds_sample_entry = 1;\n\telse if (tkw->scheme_type) {\n\t\tif (codec_id == prev_codecid)\n\t\t\tskip_crypto = GF_TRUE;\n\t}\n\n\t//get our subtype\n\tswitch (codec_id) {\n\tcase GF_CODECID_MPEG_AUDIO:\n\tcase GF_CODECID_MPEG2_PART3:\n\tcase GF_CODECID_MPEG_AUDIO_L1:\n\t\tm_subtype = GF_ISOM_SUBTYPE_MP3;\n\t\tcomp_name = \"MP3\";\n\t\t//if source had a DSI, this was mpeg4 systems signaling, reuse that\n\t\tif (dsi)\n\t\t\tuse_m4sys = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_AAC_MPEG4:\n\tcase GF_CODECID_AAC_MPEG2_MP:\n\tcase GF_CODECID_AAC_MPEG2_LCP:\n\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\t\tm_subtype = GF_ISOM_SUBTYPE_MPEG4;\n\t\tuse_m4sys = GF_TRUE;\n\t\tcomp_name = \"AAC\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\n\t\tif (ctx->importer) {\n\t\t\tconst char *pid_args = gf_filter_pid_get_args(pid);\n\t\t\tif (pid_args) {\n\t\t\t\tBool sbr_i = strstr(pid_args, \"sbr=imp\") ? GF_TRUE : GF_FALSE;\n\t\t\t\tBool sbr_x = strstr(pid_args, \"sbr=exp\") ? GF_TRUE : GF_FALSE;\n\t\t\t\tBool ps_i = strstr(pid_args, \"ps=imp\") ? GF_TRUE : GF_FALSE;\n\t\t\t\tBool ps_x = strstr(pid_args, \"ps=exp\") ? GF_TRUE : GF_FALSE;\n\n\t\t\t\tif (sbr_x) {\n\t\t\t\t\tif (ps_i) imp_name = \"AAC explicit SBR implict PS\";\n\t\t\t\t\telse if (ps_x) imp_name = \"AAC explicit SBR+PS\";\n\t\t\t\t\telse imp_name = \"AAC explicit SBR\";\n\t\t\t\t} else if (sbr_i) {\n\t\t\t\t\tif (ps_i) imp_name = \"AAC implicit SBR+PS\";\n\t\t\t\t\telse if (ps_x) imp_name = \"AAC implicit SBR explicit PS\";\n\t\t\t\t\telse imp_name = \"AAC implicit SBR\";\n\t\t\t\t} else {\n\t\t\t\t\tif (ps_i) imp_name = \"AAC implicit PS\";\n\t\t\t\t\telse if (ps_x) imp_name = \"AAC explicit PS\";\n\t\t\t\t\telse imp_name = \"AAC \";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GF_CODECID_USAC:\n\t\tm_subtype = GF_ISOM_SUBTYPE_MPEG4;\n\t\tuse_m4sys = GF_TRUE;\n\t\tcomp_name = \"xHE-AAC / USAC\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tbreak;\n\tcase GF_CODECID_JPEG:\n\t\tm_subtype = GF_ISOM_BOX_TYPE_JPEG;\n\t\tcomp_name = \"JPEG\";\n\t\t//use generic sample desc, but don't inject dsi\n\t\tif (!use_m4sys)\n\t\t\tdsi = NULL;\n\t\tbreak;\n\tcase GF_CODECID_PNG:\n\t\tm_subtype = GF_ISOM_BOX_TYPE_PNG;\n\t\tcomp_name = \"PNG\";\n\t\t//use generic sample desc, but don't inject dsi\n\t\tdsi = NULL;\n\t\tbreak;\n\tcase GF_CODECID_J2K:\n\t\tm_subtype = GF_ISOM_BOX_TYPE_MJP2;\n\t\tcomp_name = \"JPEG2000\";\n\t\tuse_mj2 = GF_TRUE;\n\t\tbreak;\n\n\tcase GF_CODECID_AMR:\n\t\tm_subtype = GF_ISOM_SUBTYPE_3GP_AMR;\n\t\tcomp_name = \"AMR\";\n\t\tuse_3gpp_config = GF_TRUE;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_AMR_MODE_SET);\n\t\tif (p && (p->value.uint!=tkw->amr_mode_set)) {\n\t\t\ttkw->amr_mode_set = p->value.uint;\n\t\t\tif (!needs_sample_entry)\n\t\t\t\tneeds_sample_entry = 2;\n\t\t}\n\t\tbreak;\n\tcase GF_CODECID_AMR_WB:\n\t\tm_subtype = GF_ISOM_SUBTYPE_3GP_AMR_WB;\n\t\tcomp_name = \"AMR-WB\";\n\t\tuse_3gpp_config = GF_TRUE;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_AMR_MODE_SET);\n\t\tif (p && (p->value.uint!=tkw->amr_mode_set)) {\n\t\t\ttkw->amr_mode_set = p->value.uint;\n\t\t\tif (!needs_sample_entry)\n\t\t\t\tneeds_sample_entry = 2;\n\t\t}\n\t\tbreak;\n\tcase GF_CODECID_EVRC:\n\t\tm_subtype = GF_ISOM_SUBTYPE_3GP_EVRC;\n\t\tcomp_name = \"EVRC\";\n\t\tuse_3gpp_config = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_SMV:\n\t\tm_subtype = GF_ISOM_SUBTYPE_3GP_SMV;\n\t\tcomp_name = \"SMV\";\n\t\tuse_3gpp_config = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_QCELP:\n\t\tm_subtype = GF_ISOM_SUBTYPE_3GP_QCELP;\n\t\tcomp_name = \"QCELP\";\n\t\tuse_3gpp_config = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_S263:\n\tcase GF_CODECID_H263:\n\t\tm_subtype = GF_ISOM_SUBTYPE_3GP_H263;\n\t\tcomp_name = \"H263\";\n\t\tuse_3gpp_config = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_AC3:\n\t\tm_subtype = GF_ISOM_SUBTYPE_AC3;\n\t\tcomp_name = \"AC-3\";\n\t\tuse_ac3_entry = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_EAC3:\n\t\tm_subtype = GF_ISOM_SUBTYPE_EC3;\n\t\tcomp_name = \"EAC-3\";\n\t\tuse_ac3_entry = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_MPHA:\n\t\tif ((m_subtype_src!=GF_ISOM_SUBTYPE_MH3D_MHA1) && (m_subtype_src!=GF_ISOM_SUBTYPE_MH3D_MHA2))\n\t\t\tm_subtype = GF_ISOM_SUBTYPE_MH3D_MHA1;\n\t\telse\n\t\t\tm_subtype = m_subtype_src;\n\t\tcomp_name = \"MPEG-H Audio\";\n\t\tnb_chan = 0;\n\t\tbreak;\n\tcase GF_CODECID_MHAS:\n\t\tif ((m_subtype_src!=GF_ISOM_SUBTYPE_MH3D_MHM1) && (m_subtype_src!=GF_ISOM_SUBTYPE_MH3D_MHM2))\n\t\t\tm_subtype = GF_ISOM_SUBTYPE_MH3D_MHM1;\n\t\telse\n\t\t\tm_subtype = m_subtype_src;\n\t\tcomp_name = \"MPEG-H AudioMux\";\n\t\tnb_chan = 0;\n\t\tbreak;\n\tcase GF_CODECID_FLAC:\n\t\tm_subtype = GF_ISOM_SUBTYPE_FLAC;\n\t\tcomp_name = \"FLAC\";\n\t\tuse_flac_entry = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_OPUS:\n\t\tm_subtype = GF_ISOM_SUBTYPE_OPUS;\n\t\tcomp_name = \"Opus\";\n\t\tuse_opus = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_MPEG4_PART2:\n\t\tm_subtype = GF_ISOM_SUBTYPE_MPEG4;\n\t\tuse_m4sys = GF_TRUE;\n\t\tcomp_name = \"MPEG-4 Visual Part 2\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tbreak;\n\tcase GF_CODECID_AVC:\n\tcase GF_CODECID_SVC:\n\t\tif (ctx->xps_inband==XPS_IB_AUTO) {\n\t\t\tswitch (m_subtype_src) {\n\t\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_DVAV:\n\t\t\t\tm_subtype = m_subtype_src;\n\t\t\t\txps_inband = XPS_IB_ALL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tm_subtype = GF_ISOM_SUBTYPE_AVC_H264;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\txps_inband = ctx->xps_inband;\n\t\t\tm_subtype = ((xps_inband==XPS_IB_ALL) || (xps_inband==XPS_IB_BOTH)) ? GF_ISOM_SUBTYPE_AVC3_H264 : GF_ISOM_SUBTYPE_AVC_H264;\n\t\t}\n\t\tuse_avc = GF_TRUE;\n\t\tcomp_name = (codec_id == GF_CODECID_SVC) ? \"MPEG-4 SVC\" : \"MPEG-4 AVC\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tif (m_subtype != GF_ISOM_SUBTYPE_AVC_H264) {\n\t\t\tuse_m4sys = GF_FALSE;\n\t\t\tif (xps_inband==XPS_IB_ALL) skip_dsi = GF_TRUE;\n\t\t}\n\t\tbreak;\n\tcase GF_CODECID_HEVC:\n\tcase GF_CODECID_LHVC:\n\t\tif (ctx->xps_inband==XPS_IB_AUTO) {\n\t\t\tswitch (m_subtype_src) {\n\t\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\t\tcase GF_ISOM_SUBTYPE_DVHE:\n\t\t\t\tm_subtype = m_subtype_src;\n\t\t\t\txps_inband = XPS_IB_ALL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tm_subtype = GF_ISOM_SUBTYPE_HVC1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\txps_inband = ctx->xps_inband;\n\t\t\tm_subtype = ((xps_inband==XPS_IB_ALL) || (xps_inband==XPS_IB_BOTH)) ? GF_ISOM_SUBTYPE_HEV1  : GF_ISOM_SUBTYPE_HVC1;\n\t\t}\n\t\tuse_hevc = GF_TRUE;\n\t\tcomp_name = (codec_id == GF_CODECID_LHVC) ? \"L-HEVC\" : \"HEVC\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tif (m_subtype != GF_ISOM_SUBTYPE_HVC1) {\n\t\t\tuse_m4sys = GF_FALSE;\n\t\t\tif (xps_inband==XPS_IB_ALL) skip_dsi = GF_TRUE;\n\t\t}\n\t\tbreak;\n\tcase GF_CODECID_HEVC_TILES:\n\t\tm_subtype = GF_ISOM_SUBTYPE_HVT1;\n\t\tskip_dsi = GF_TRUE;\n\t\tuse_hvt1 = GF_TRUE;\n\t\tuse_m4sys = GF_FALSE;\n\t\tcomp_name = \"HEVC Tiles\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tbreak;\n\tcase GF_CODECID_VVC:\n\t\tif (ctx->xps_inband==XPS_IB_AUTO) {\n\t\t\tif (m_subtype_src == GF_ISOM_SUBTYPE_VVI1) {\n\t\t\t\tm_subtype = GF_ISOM_SUBTYPE_VVI1;\n\t\t\t\txps_inband = XPS_IB_ALL;\n\t\t\t} else {\n\t\t\t\tm_subtype = GF_ISOM_SUBTYPE_VVC1;\n\t\t\t}\n\t\t} else {\n\t\t\txps_inband = ctx->xps_inband;\n\t\t\tm_subtype = ((xps_inband==XPS_IB_PPS) || (xps_inband==XPS_IB_ALL) || (xps_inband==XPS_IB_BOTH)) ? GF_ISOM_SUBTYPE_VVI1  : GF_ISOM_SUBTYPE_VVC1;\n\t\t}\n\t\tuse_vvc = GF_TRUE;\n\t\tcomp_name = \"VVC\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tif (xps_inband==XPS_IB_ALL) skip_dsi = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_VVC_SUBPIC:\n\t\tm_subtype = GF_ISOM_SUBTYPE_VVS1;\n\t\tskip_dsi = GF_TRUE;\n\t\tuse_vvc = GF_TRUE;\n\t\tuse_m4sys = GF_FALSE;\n\t\tcomp_name = \"VVC Subpicture\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tbreak;\n\tcase GF_CODECID_MPEG1:\n\tcase GF_CODECID_MPEG2_422:\n\tcase GF_CODECID_MPEG2_SNR:\n\tcase GF_CODECID_MPEG2_HIGH:\n\tcase GF_CODECID_MPEG2_MAIN:\n\tcase GF_CODECID_MPEG2_SIMPLE:\n\tcase GF_CODECID_MPEG2_SPATIAL:\n\t\tm_subtype = GF_ISOM_SUBTYPE_MPEG4;\n\t\tuse_m4sys = GF_TRUE;\n\t\tcomp_name = \"MPEG-2 Video\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tbreak;\n\tcase 0:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] muxing codecID %d not yet implemented - patch welcome\\n\", codec_id));\n\t\treturn GF_NOT_SUPPORTED;\n\n\tcase GF_ISOM_SUBTYPE_TX3G:\n\t\tm_subtype = GF_ISOM_SUBTYPE_TX3G;\n\t\tuse_tx3g = GF_TRUE;\n\t\tcomp_name = \"Timed Text\";\n\t\tis_text_subs = GF_TRUE;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_WVTT:\n\t\tm_subtype = GF_ISOM_SUBTYPE_WVTT;\n\t\tuse_webvtt = GF_TRUE;\n\t\tcomp_name = \"WebVTT\";\n\t\tis_text_subs = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_DVB_SUBS:\n\t\tuse_gen_sample_entry = GF_TRUE;\n\t\tcomp_name = \"DVB Subtitles\";\n\t\tm_subtype = GF_ISOM_SUBTYPE_DVB_SUBS;\n\t\tgen_dsi_wrap = GF_4CC('d', 'v', 's', 'C');\n\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_MEDIA_SUBT);\n\t\tif (!width && !height) {\n\t\t\tmp4_mux_get_video_size(ctx, &width, &height);\n\t\t}\n\t\tbreak;\n\tcase GF_CODECID_DVB_TELETEXT:\n\t\tuse_gen_sample_entry = GF_TRUE;\n\t\tcomp_name = \"DVB Subtitles\";\n\t\tm_subtype = GF_ISOM_SUBTYPE_DVB_TELETEXT;\n\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_MEDIA_SUBT);\n\t\tif (!width && !height) {\n\t\t\tmp4_mux_get_video_size(ctx, &width, &height);\n\t\t}\n\t\tbreak;\n\n\tcase GF_CODECID_SUBPIC:\n\t\tuse_m4sys = GF_TRUE;\n\t\toverride_stype = GF_STREAM_ND_SUBPIC;\n\t\tcomp_name = \"VobSub\";\n\t\tbreak;\n\tcase GF_CODECID_TEXT_MPEG4:\n\t\tuse_m4sys = GF_TRUE;\n\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_MEDIA_SCENE);\n\t\tcomp_name = \"MPEG4 Streaming Text\";\n\t\tbreak;\n\tcase GF_CODECID_AV1:\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tm_subtype = GF_ISOM_SUBTYPE_AV01;\n\t\tuse_av1 = GF_TRUE;\n\t\tcomp_name = \"AOM AV1 Video\";\n\t\tbreak;\n\n\tcase GF_CODECID_VP8:\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tm_subtype = GF_ISOM_SUBTYPE_VP08;\n\t\tuse_vpX = GF_TRUE;\n\t\tcomp_name = \"VP8 Video\";\n\t\tbreak;\n\tcase GF_CODECID_VP9:\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tm_subtype = GF_ISOM_SUBTYPE_VP09;\n\t\tuse_vpX = GF_TRUE;\n\t\tcomp_name = \"VP9 Video\";\n\t\tbreak;\n\tcase GF_CODECID_VP10:\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tm_subtype = GF_ISOM_SUBTYPE_VP10;\n\t\tuse_vpX = GF_TRUE;\n\t\tcomp_name = \"VP10 Video\";\n\t\tbreak;\n\n\tcase GF_CODECID_VORBIS:\n\tcase GF_CODECID_THEORA:\n\t\tuse_m4sys = GF_TRUE;\n\t\tbreak;\n\n\tcase GF_CODECID_TRUEHD:\n\t\tm_subtype = GF_ISOM_SUBTYPE_MLPA;\n\t\tcomp_name = \"Dolby TrueHD\";\n\t\tbreak;\n\n\tcase GF_CODECID_DTS_CA:\n\t\tm_subtype = GF_ISOM_SUBTYPE_DTSC;\n\t\tbreak;\n\tcase GF_CODECID_DTS_HD_HR_MASTER:\n\t\tm_subtype = GF_ISOM_SUBTYPE_DTSH;\n\t\tbreak;\n\tcase GF_CODECID_DTS_HD_LOSSLESS:\n\t\tm_subtype = GF_ISOM_SUBTYPE_DTSL;\n\t\tbreak;\n\tcase GF_CODECID_DTS_EXPRESS_LBR:\n\t\tm_subtype = GF_ISOM_SUBTYPE_DTSE;\n\t\tbreak;\n\tcase GF_CODECID_DTS_X:\n\t\tm_subtype = GF_ISOM_SUBTYPE_DTSX;\n\t\tbreak;\n\tcase GF_CODECID_DTS_Y:\n\t\tm_subtype = GF_ISOM_SUBTYPE_DTSY;\n\t\tbreak;\n\tcase GF_CODECID_ALAC:\n\t\tm_subtype = GF_QT_SUBTYPE_ALAC;\n\t\tbreak;\n\n\tcase GF_CODECID_BIFS:\n/* ==  GF_CODECID_OD_V1:*/\n\tcase GF_CODECID_BIFS_V2:\n/*\t== GF_CODECID_OD_V2:*/\n\tcase GF_CODECID_BIFS_EXTENDED:\n\tcase GF_CODECID_LASER:\n\t\tuse_m4sys = GF_TRUE;\n\t\tbreak;\n\n\tcase GF_CODECID_RAW:\n\t\tm_subtype = codec_id;\n\t\tunknown_generic = GF_TRUE;\n\t\tuse_gen_sample_entry = GF_TRUE;\n\t\tuse_m4sys = GF_FALSE;\n\t\ttkw->skip_bitrate_update = GF_TRUE;\n\t\tif (tkw->stream_type == GF_STREAM_AUDIO) {\n\t\t\tu32 afmt;\n\t\t\tu32 req_non_planar_type = 0;\n\t\t\tBool qt_only=GF_FALSE;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_AUDIO_FORMAT);\n\t\t\tif (!p) break;\n\t\t\tcomp_name = \"RawAudio\";\n\t\t\tunknown_generic = GF_FALSE;\n\n\t\t\tafmt = p->value.uint;\n\t\t\tafmt_flags |= 1<<2; //signed\n\t\t\t//m_subtype used for QTFF-style raw media, m_subtype_alt_raw for ISOBMFF raw audio\n\t\t\tswitch (afmt) {\n\t\t\tcase GF_AUDIO_FMT_U8P:\n\t\t\t \treq_non_planar_type = GF_AUDIO_FMT_U8;\n\t\t\tcase GF_AUDIO_FMT_U8:\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_RAW;\n\t\t\t\tafmt_flags &= ~(1<<2); //unsigned\n\t\t\t\tqt_only = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_S16P:\n\t\t\t \treq_non_planar_type = GF_AUDIO_FMT_S16;\n\t\t\tcase GF_AUDIO_FMT_S16:\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_SOWT;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_IPCM;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_S16_BE:\n\t\t\t\tafmt_flags |= 1<<1;\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_TWOS;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_IPCM;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_S24P:\n\t\t\t \treq_non_planar_type = GF_AUDIO_FMT_S24;\n\t\t\tcase GF_AUDIO_FMT_S24:\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_IN24;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_IPCM;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_S24_BE:\n\t\t\t\tafmt_flags |= 1<<1;\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_IN24;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_IPCM;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_S32P:\n\t\t\t \treq_non_planar_type = GF_AUDIO_FMT_S32P;\n\t\t\tcase GF_AUDIO_FMT_S32:\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_IN32;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_IPCM;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_S32_BE:\n\t\t\t\tafmt_flags |= 1<<1;\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_IN32;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_IPCM;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_FLTP:\n\t\t\t \treq_non_planar_type = GF_AUDIO_FMT_FLTP;\n\t\t\tcase GF_AUDIO_FMT_FLT:\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_FL32;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_FPCM;\n\t\t\t\tafmt_flags |= 1;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_FLT_BE:\n\t\t\t\tafmt_flags |= 1<<1;\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_FL32;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_FPCM;\n\t\t\t\tafmt_flags |= 1;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_DBLP:\n\t\t\t \treq_non_planar_type = GF_AUDIO_FMT_DBL;\n\t\t\tcase GF_AUDIO_FMT_DBL:\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_FL64;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_FPCM;\n\t\t\t\tafmt_flags |= 1;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_DBL_BE:\n\t\t\t\tafmt_flags |= 1<<1;\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_FL64;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_FPCM;\n\t\t\t\tafmt_flags |= 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tunknown_generic = GF_TRUE;\n\t\t\t\tm_subtype = p->value.uint;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ctx->make_qt && (ase_mode==GF_IMPORT_AUDIO_SAMPLE_ENTRY_v2_QTFF)) {\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_LPCM;\n\t\t\t}\n\t\t\t//if qt-only sample desc available, force ase mode\n\t\t\telse if (!ctx->make_qt && qt_only) {\n\t\t\t\tase_mode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF;\n\t\t\t}\n\n\t\t\tif (req_non_planar_type) {\n\t\t\t\tif (is_true_pid)\n\t\t\t\t\tgf_filter_pid_negociate_property(pid, GF_PROP_PID_AUDIO_FORMAT, &PROP_UINT(GF_AUDIO_FMT_S16));\n\t\t\t\telse {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] raw audio format planar in DASH multi-stsd mode is not supported, try assigning a resampler before the dasher\\n\"));\n\t\t\t\t\treturn GF_NOT_SUPPORTED;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnb_bps = gf_audio_fmt_bit_depth(afmt);\n\t\t\ttkw->raw_audio_bytes_per_sample = nb_bps;\n\t\t\ttkw->raw_audio_bytes_per_sample *= nb_chan;\n\t\t\ttkw->raw_audio_bytes_per_sample /= 8;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_SAMPLE_RATE);\n\t\t\ttkw->raw_samplerate = p ? p->value.uint : 0;\n\t\t\t//force timescale to be samplerate, except if explicit overwrite\n\t\t\tif (ctx->mediats==0)\n\t\t\t\ttkw->tk_timescale = tkw->raw_samplerate;\n\n\t\t\tif ((sr == tkw->w_or_sr) && (nb_chan==tkw->h_or_ch) && (afmt==tkw->pf_or_af)) {\n\n\t\t\t} else {\n\t\t\t\tif (!needs_sample_entry)\n\t\t\t\t\tneeds_sample_entry = 2;\n\t\t\t\ttkw->w_or_sr = sr;\n\t\t\t\ttkw->h_or_ch = nb_chan;\n\t\t\t\ttkw->pf_or_af = afmt;\n\t\t\t}\n\t\t}\n\t\telse if (tkw->stream_type == GF_STREAM_VISUAL) {\n\t\t\tu32 pfmt;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PIXFMT);\n\t\t\tif (!p) break;\n\t\t\tpfmt = p->value.uint;\n\t\t\tcomp_name = \"RawVideo\";\n\t\t\tunknown_generic = GF_FALSE;\n\t\t\ttkw->skip_bitrate_update = GF_TRUE;\n\t\t\tpix_fmt = p->value.uint;\n\n\t\t\tm_subtype = gf_pixel_fmt_to_qt_type(pix_fmt);\n\t\t\tif (m_subtype) {\n\t\t\t\tif (gf_pixel_fmt_is_yuv(p->value.uint))\n\t\t\t\t\tforce_colr = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tunknown_generic = GF_TRUE;\n\t\t\t\tm_subtype = pix_fmt;\n\t\t\t}\n\n\t\t\tif ((width == tkw->w_or_sr) && (height==tkw->h_or_ch) && (pfmt==tkw->pf_or_af)) {\n\n\t\t\t} else {\n\t\t\t\tif (!needs_sample_entry)\n\t\t\t\t\tneeds_sample_entry = 2;\n\t\t\t\ttkw->w_or_sr = width;\n\t\t\t\ttkw->h_or_ch = height;\n\t\t\t\ttkw->pf_or_af = pfmt;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase GF_CODECID_RAW_UNCV:\n\t\tm_subtype = GF_ISOM_SUBTYPE_UNCV;\n\t\tunknown_generic = GF_FALSE;\n\t\tuse_gen_sample_entry = GF_TRUE;\n\t\tuse_m4sys = GF_FALSE;\n\t\tbreak;\n\n\tdefault:\n\t\tm_subtype = codec_id;\n\t\tunknown_generic = GF_TRUE;\n\t\tuse_gen_sample_entry = GF_TRUE;\n\t\tuse_m4sys = GF_FALSE;\n\t\tif (is_prores)\n\t\t\tunknown_generic = GF_FALSE;\n\n\t\tp = gf_filter_pid_get_property_str(pid, \"meta:mime\");\n\t\tif (p) meta_mime = p->value.string;\n\t\tp = gf_filter_pid_get_property_str(pid, \"meta:encoding\");\n\t\tif (p) meta_encoding = p->value.string;\n\t\tp = gf_filter_pid_get_property_str(pid, \"meta:content_encoding\");\n\t\tif (p) meta_content_encoding = p->value.string;\n\t\tp = gf_filter_pid_get_property_str(pid, \"meta:xmlns\");\n\t\tif (p) meta_xmlns = p->value.string;\n\t\tp = gf_filter_pid_get_property_str(pid, \"meta:schemaloc\");\n\t\tif (p) meta_schemaloc = p->value.string;\n\t\tp = gf_filter_pid_get_property_str(pid, \"meta:aux_mimes\");\n\t\tif (p) meta_auxmimes = p->value.string;\n\t\tbreak;\n\t}\n\tif (!comp_name) comp_name = gf_codecid_name(codec_id);\n\tif (!comp_name) comp_name = gf_4cc_to_str(m_subtype);\n\n\tif (dsi)\n\t\tmeta_config = dsi->value.data.ptr;\n\n\tif (is_text_subs && !width && !height) {\n\t\tmp4_mux_get_video_size(ctx, &width, &height);\n\t}\n\n\t//if not LPCM and qt v2 is requested, move to qtv1\n\tif ((ase_mode==GF_IMPORT_AUDIO_SAMPLE_ENTRY_v2_QTFF) && (m_subtype != GF_QT_SUBTYPE_LPCM) ) {\n\t\tase_mode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF;\n\t}\n\n\n\tif (!ctx->init_movie_done && !tkw->nb_samples && (ctx->mediats<0) && (tkw->tk_timescale==1000)) {\n\t\tif (sr) {\n\t\t\ttkw->tk_timescale = sr;\n\t\t\tgf_isom_set_media_timescale(ctx->file, tkw->track_num, sr, 0, 1);\n\t\t}\n\t\telse if (width && fps.den) {\n\t\t\ttkw->tk_timescale = fps.den;\n\t\t\tgf_isom_set_media_timescale(ctx->file, tkw->track_num, fps.den, 0, 1);\n\t\t}\n\t}\n\tif (!needs_sample_entry || tkw->is_item) {\n\t\tgoto sample_entry_done;\n\t}\n\n\t//we are fragmented, init movie done, we cannot update the sample description\n\tif (ctx->init_movie_done) {\n\t\tif (needs_sample_entry==1) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot create a new sample description entry (codec change) for finalized movie in fragmented mode\\n\"));\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t\tforce_mix_xps = GF_TRUE;\n\t} else if (ctx->store < MP4MX_MODE_FRAG) {\n\t\tif ((needs_sample_entry==2) && (xps_inband==XPS_IB_BOTH)) {\n\t\t\tforce_mix_xps = GF_TRUE;\n\t\t}\n\t\telse if ((needs_sample_entry==2) && ((xps_inband==XPS_IB_ALL) || (xps_inband==XPS_IB_MIX)) ) {\n\t\t\tneeds_sample_entry = 0;\n\t\t\tmake_inband_headers = GF_TRUE;\n\t\t}\n\t}\n\n\tif (force_mix_xps) {\n\t\tif (tkw->all_stsd_crc) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_STSD_ALL_TEMPLATES);\n\t\t\tu32 crc = p ? gf_crc_32(p->value.data.ptr, p->value.data.size) : 0;\n\t\t\tif (crc == tkw->all_stsd_crc) {\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_STSD_TEMPLATE_IDX);\n\t\t\t\tif (p) {\n\t\t\t\t\ttkw->stsd_idx = p->value.uint;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//for AVC and HEVC, move to inband params if config changed\n\t\tif (use_avc && dsi) {\n\t\t\tif (tkw->avcc) gf_odf_avc_cfg_del(tkw->avcc);\n\n\t\t\ttkw->avcc = gf_odf_avc_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\n\t\t\tif (enh_dsi) {\n\t\t\t\tif (tkw->svcc) gf_odf_avc_cfg_del(tkw->svcc);\n\t\t\t\ttkw->svcc = gf_odf_avc_cfg_read(enh_dsi->value.data.ptr, enh_dsi->value.data.size);\n\t\t\t}\n\t\t\tif (!xps_inband) {\n\t\t\t\tif (ctx->init_movie_done) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] AVC config update after movie has been finalized, moving all SPS/PPS inband (file might not be compliant)\\n\"));\n\t\t\t\t}\n\t\t\t\ttkw->xps_inband = XPS_IB_BOTH;\n\t\t\t}\n\t\t\tmp4_mux_make_inband_header(ctx, tkw, GF_FALSE);\n\t\t\tif (ctx->pps_inband || tkw->xps_inband)\n\t\t\t\tmp4_mux_make_inband_header(ctx, tkw, GF_TRUE);\n\t\t\treturn GF_OK;\n\t\t}\n\t\telse if (use_hevc && dsi) {\n\t\t\tif (tkw->hvcc) gf_odf_hevc_cfg_del(tkw->hvcc);\n\t\t\ttkw->hvcc = gf_odf_hevc_cfg_read(dsi->value.data.ptr, dsi->value.data.size,  (codec_id == GF_CODECID_LHVC) ? GF_TRUE : GF_FALSE);\n\n\t\t\tif (enh_dsi) {\n\t\t\t\tif (tkw->lvcc) gf_odf_hevc_cfg_del(tkw->lvcc);\n\t\t\t\ttkw->lvcc = gf_odf_hevc_cfg_read(enh_dsi->value.data.ptr, enh_dsi->value.data.size, GF_TRUE);\n\t\t\t}\n\t\t\tif (!xps_inband) {\n\t\t\t\tif (ctx->init_movie_done) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] HEVC config update after movie has been finalized, moving all SPS/PPS inband (file might not be compliant)\\n\"));\n\t\t\t\t}\n\t\t\t\ttkw->xps_inband = XPS_IB_BOTH;\n\t\t\t}\n\t\t\tmp4_mux_make_inband_header(ctx, tkw, GF_FALSE);\n\t\t\tif (ctx->pps_inband || tkw->xps_inband)\n\t\t\t\tmp4_mux_make_inband_header(ctx, tkw, GF_TRUE);\n\t\t\treturn GF_OK;\n\t\t}\n\t\telse if (use_vvc && dsi) {\n\t\t\tif (tkw->vvcc) gf_odf_vvc_cfg_del(tkw->vvcc);\n\t\t\ttkw->vvcc = gf_odf_vvc_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\n\t\t\tif (!xps_inband) {\n\t\t\t\tif (ctx->init_movie_done) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] VVC config update after movie has been finalized, moving all SPS/PPS inband (file might not be compliant)\\n\"));\n\t\t\t\t}\n\t\t\t\ttkw->xps_inband = XPS_IB_BOTH;\n\t\t\t}\n\t\t\tmp4_mux_make_inband_header(ctx, tkw, GF_FALSE);\n\t\t\tif (ctx->pps_inband || tkw->xps_inband)\n\t\t\t\tmp4_mux_make_inband_header(ctx, tkw, GF_TRUE);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot create a new sample description entry (config changed) for finalized movie in fragmented mode\\n\"));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\ttkw->xps_inband = xps_inband;\n\tp = needs_sample_entry ? gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DSI_SUPERSET) : NULL;\n\n\t//if dsi is a superset of previous one, remove stream description\n\tif ((p && p->value.boolean)\n\t\t//little optim here: if no samples were added on the stream description remove it\n\t\t|| (!tkw->samples_in_stsd && tkw->stsd_idx && needs_sample_entry)\n\t) {\n\t\tgf_isom_remove_stream_description(ctx->file, tkw->track_num, tkw->stsd_idx);\n\t}\n\n\tif (!use_dref) src_url = NULL;\n\n\tif (use_m4sys && !gf_codecid_oti(codec_id)) {\n\t\tuse_m4sys = GF_FALSE;\n\t}\n\t//nope, create sample entry\n\tif (use_m4sys) {\n\t\tGF_ESD *esd = gf_odf_desc_esd_new(2);\n\t\tesd->decoderConfig->streamType = override_stype ? override_stype : tkw->stream_type;\n\t\tesd->decoderConfig->objectTypeIndication = gf_codecid_oti(codec_id);\n\t\tif (!esd->decoderConfig->objectTypeIndication) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Codec %s does not have an official MPEG-4 systems mapping, cannot mux\\n\", gf_codecid_name(codec_id) ));\n\t\t\treturn GF_NOT_SUPPORTED;\n\n\t\t}\n\t\tesd->slConfig->timestampResolution = tkw->tk_timescale;\n\t\tif (dsi && !skip_dsi) {\n\t\t\tesd->decoderConfig->decoderSpecificInfo->data = dsi->value.data.ptr;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->dataLength = dsi->value.data.size;\n\t\t}\n\n\t\te = gf_isom_new_mpeg4_description(ctx->file, tkw->track_num, esd, (char *)src_url, NULL, &tkw->stsd_idx);\n\t\tif (dsi && !skip_dsi) {\n\t\t\tesd->decoderConfig->decoderSpecificInfo->data = NULL;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->dataLength = 0;\n\t\t}\n\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new MPEG-4 Systems sample description for stream type %d OTI %d: %s\\n\", tkw->stream_type, codec_id, gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\n\t\ttkw->use_dref = src_url ? GF_TRUE : GF_FALSE;\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_IN_IOD);\n\t\tif (p && p->value.boolean)\n\t\t\tgf_isom_add_track_to_root_od(ctx->file, tkw->track_num);\n\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tif (dsi && (tkw->stream_type==GF_STREAM_AUDIO)) {\n\t\t\tGF_M4ADecSpecInfo acfg;\n\t\t\tgf_m4a_get_config(dsi->value.data.ptr, dsi->value.data.size, &acfg);\n\t\t\taudio_pli = acfg.audioPL;\n\t\t}\n\t\t//patch to align old arch (IOD not written in dash) with new\n\t\tif (audio_pli && !ctx->dash_mode)\n\t\t\tgf_isom_set_pl_indication(ctx->file, GF_ISOM_PL_AUDIO, audio_pli);\n#endif\n\n\t} else if (use_avc) {\n\t\t//not yet known\n\t\tif (!dsi && !enh_dsi) return GF_OK;\n\n\t\tif (!dsi) {\n\t\t\tdsi = enh_dsi;\n\t\t\tenh_dsi = NULL;\n\t\t}\n\t\tif (tkw->avcc) gf_odf_avc_cfg_del(tkw->avcc);\n\t\ttkw->avcc = gf_odf_avc_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\n\t\tif (needs_sample_entry) {\n\t\t\tif (tkw->codecid == GF_CODECID_SVC) {\n\t\t\t\te = gf_isom_svc_config_new(ctx->file, tkw->track_num, tkw->avcc, NULL, NULL, &tkw->stsd_idx);\n\t\t\t} else if (tkw->codecid == GF_CODECID_MVC) {\n\t\t\t\te = gf_isom_mvc_config_new(ctx->file, tkw->track_num, tkw->avcc, NULL, NULL, &tkw->stsd_idx);\n\t\t\t} else {\n\t\t\t\te = gf_isom_avc_config_new(ctx->file, tkw->track_num, tkw->avcc, NULL, NULL, &tkw->stsd_idx);\n\t\t\t}\n\n\t\t\tif (!e && enh_dsi) {\n\t\t\t\tif (tkw->svcc) gf_odf_avc_cfg_del(tkw->svcc);\n\t\t\t\ttkw->svcc = gf_odf_avc_cfg_read(enh_dsi->value.data.ptr, enh_dsi->value.data.size);\n\t\t\t\tif (tkw->svcc) {\n\t\t\t\t\tif ((tkw->svcc->AVCProfileIndication==118) || (tkw->svcc->AVCProfileIndication==128)) {\n\t\t\t\t\t\te = gf_isom_mvc_config_update(ctx->file, tkw->track_num, tkw->stsd_idx, tkw->svcc, GF_TRUE);\n\t\t\t\t\t} else {\n\t\t\t\t\t\te = gf_isom_svc_config_update(ctx->file, tkw->track_num, tkw->stsd_idx, tkw->svcc, GF_TRUE);\n\t\t\t\t\t}\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tgf_odf_avc_cfg_del(tkw->svcc);\n\t\t\t\t\t\ttkw->svcc = NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (xps_inband) {\n\t\t\t\t\t\tgf_isom_avc_set_inband_config(ctx->file, tkw->track_num, tkw->stsd_idx, (xps_inband==XPS_IB_BOTH) ? GF_TRUE : GF_FALSE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new AVC sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (xps_inband) {\n\t\t\t//this will cleanup all PS in avcC / svcC\n\t\t\tgf_isom_avc_set_inband_config(ctx->file, tkw->track_num, tkw->stsd_idx, (xps_inband==XPS_IB_BOTH) ? GF_TRUE : GF_FALSE);\n\t\t\tif (xps_inband==XPS_IB_BOTH) make_inband_headers = GF_TRUE;\n\t\t} else {\n\t\t\tgf_odf_avc_cfg_del(tkw->avcc);\n\t\t\ttkw->avcc = NULL;\n\t\t}\n\t\t//patch to align old arch with filters\n\t\tif (!ctx->dash_mode && !ctx->make_qt && !gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_TREX_TEMPLATE) )\n\t\t\tgf_isom_set_pl_indication(ctx->file, GF_ISOM_PL_VISUAL, 0x7F);\n\n\t\tif (!tkw->has_brands)\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_AVC1, GF_TRUE);\n\n\t\ttkw->is_nalu = NALU_AVC;\n\n\t\ttkw->use_dref = GF_FALSE;\n\n\t} else if (use_hvt1) {\n\t\tif (tkw->hvcc) gf_odf_hevc_cfg_del(tkw->hvcc);\n\t\ttkw->hvcc = gf_odf_hevc_cfg_new();\n\t\te = gf_isom_hevc_config_new(ctx->file, tkw->track_num, tkw->hvcc, NULL, NULL, &tkw->stsd_idx);\n\t\tif (!e) {\n\t\t\tgf_isom_hevc_set_tile_config(ctx->file, tkw->track_num, tkw->stsd_idx, NULL, GF_FALSE);\n\t\t}\n\t\tgf_odf_hevc_cfg_del(tkw->hvcc);\n\t\ttkw->hvcc = NULL;\n\t\ttkw->is_nalu = NALU_HEVC;\n\t\ttkw->use_dref = GF_FALSE;\n\t\tif (!tkw->has_brands)\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_HVTI, GF_TRUE);\n\t} else if (use_hevc) {\n\t\tif (tkw->hvcc) gf_odf_hevc_cfg_del(tkw->hvcc);\n\n\t\tif (!dsi && !enh_dsi) {\n\t\t\t//not yet known\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (dsi) {\n\t\t\ttkw->hvcc = gf_odf_hevc_cfg_read(dsi->value.data.ptr, dsi->value.data.size,  (codec_id == GF_CODECID_LHVC) ? GF_TRUE : GF_FALSE);\n\t\t} else {\n\t\t\ttkw->hvcc = gf_odf_hevc_cfg_new();\n\t\t}\n\t\ttkw->is_nalu = NALU_HEVC;\n\n\t\tif (needs_sample_entry) {\n\t\t\te = gf_isom_hevc_config_new(ctx->file, tkw->track_num, tkw->hvcc, NULL, NULL, &tkw->stsd_idx);\n\n\t\t\tif (!tkw->has_brands) {\n\t\t\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_ISO4, 1);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\t\t}\n\t\t\t//patch for old arch\n\t\t\telse if (ctx->dash_mode) {\n\t\t\t\tBool force_brand=GF_FALSE;\n\t\t\t\tif (((ctx->major_brand_set>>24)=='i') && (((ctx->major_brand_set>>16)&0xFF)=='s') && (((ctx->major_brand_set>>8)&0xFF)=='o')) {\n\t\t\t\t\tif ( (ctx->major_brand_set&0xFF) <'6') force_brand=GF_TRUE;\n\t\t\t\t}\n\n\t\t\t\tif (!force_brand && ctx->major_brand_set) {\n\t\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO6, GF_TRUE);\n\t\t\t\t} else {\n\t\t\t\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_ISO6, 1);\n\t\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!e && enh_dsi) {\n\t\t\t\tif (tkw->lvcc) gf_odf_hevc_cfg_del(tkw->lvcc);\n\t\t\t\ttkw->lvcc = gf_odf_hevc_cfg_read(enh_dsi->value.data.ptr, enh_dsi->value.data.size, GF_TRUE);\n\t\t\t\tif (tkw->lvcc) {\n\t\t\t\t\te = gf_isom_lhvc_config_update(ctx->file, tkw->track_num, tkw->stsd_idx, tkw->lvcc, dsi ? GF_ISOM_LEHVC_WITH_BASE_BACKWARD : GF_ISOM_LEHVC_ONLY);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tgf_odf_hevc_cfg_del(tkw->lvcc);\n\t\t\t\t\t\ttkw->lvcc = NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!dsi && tkw->xps_inband) {\n\t\t\t\t\t\tgf_isom_hevc_set_inband_config(ctx->file, tkw->track_num, tkw->stsd_idx, (tkw->xps_inband==XPS_IB_BOTH) ? GF_TRUE : GF_FALSE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (codec_id == GF_CODECID_LHVC) {\n\t\t\t\tgf_isom_lhvc_config_update(ctx->file, tkw->track_num, tkw->stsd_idx, tkw->hvcc, GF_ISOM_LEHVC_ONLY);\n\t\t\t} else if (is_tile_base) {\n\t\t\t\tgf_isom_lhvc_config_update(ctx->file, tkw->track_num, tkw->stsd_idx, tkw->hvcc, GF_ISOM_HEVC_TILE_BASE);\n\t\t\t}\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new HEVC sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\n\t\tif (dsi && tkw->xps_inband) {\n\t\t\t//this will cleanup all PS in avcC / svcC\n\t\t\tgf_isom_hevc_set_inband_config(ctx->file, tkw->track_num, tkw->stsd_idx, (tkw->xps_inband==XPS_IB_BOTH) ? GF_TRUE : GF_FALSE);\n\t\t} else {\n\t\t\tgf_odf_hevc_cfg_del(tkw->hvcc);\n\t\t\ttkw->hvcc = NULL;\n\t\t}\n\n\t\ttkw->use_dref = GF_FALSE;\n\t} else if (use_vvc) {\n\t\tif (tkw->vvcc) gf_odf_vvc_cfg_del(tkw->vvcc);\n\n\t\tif (!dsi) {\n\t\t\t//not yet known\n\t\t\treturn GF_OK;\n\t\t}\n\t\ttkw->vvcc = gf_odf_vvc_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\n\t\ttkw->is_nalu = NALU_VVC;\n\n\t\tif (needs_sample_entry) {\n\t\t\tif (tkw->xps_inband == XPS_IB_PPS) {\n\t\t\t\tu32 k; count=gf_list_count(tkw->vvcc->param_array);\n\t\t\t\tfor (k=0;k<count;k++) {\n\t\t\t\t\tGF_NALUFFParamArray *pa = gf_list_get(tkw->vvcc->param_array, k);\n\t\t\t\t\tif (pa->type==GF_VVC_NALU_PIC_PARAM)\n\t\t\t\t\t\tpa->array_completeness = GF_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\te = gf_isom_vvc_config_new(ctx->file, tkw->track_num, tkw->vvcc, NULL, NULL, &tkw->stsd_idx);\n\n\t\t\tif (!tkw->has_brands) {\n\t\t\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_ISO4, 1);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\t\t}\n\t\t\t//patch for old arch\n\t\t\telse if (ctx->dash_mode) {\n\t\t\t\tBool force_brand=GF_FALSE;\n\t\t\t\tif (((ctx->major_brand_set>>24)=='i') && (((ctx->major_brand_set>>16)&0xFF)=='s') && (((ctx->major_brand_set>>8)&0xFF)=='o')) {\n\t\t\t\t\tif ( (ctx->major_brand_set&0xFF) <'6') force_brand=GF_TRUE;\n\t\t\t\t}\n\n\t\t\t\tif (!force_brand && ctx->major_brand_set) {\n\t\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO6, GF_TRUE);\n\t\t\t\t} else {\n\t\t\t\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_ISO6, 1);\n\t\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new HEVC sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\n\t\tif (tkw->xps_inband) {\n\t\t\t//this will cleanup all PS in vvcC\n\t\t\tgf_isom_vvc_set_inband_config(ctx->file, tkw->track_num, tkw->stsd_idx, ((tkw->xps_inband==XPS_IB_PPS) || (tkw->xps_inband==XPS_IB_BOTH)) ? GF_TRUE : GF_FALSE);\n\t\t} else {\n\t\t\tgf_odf_vvc_cfg_del(tkw->vvcc);\n\t\t\ttkw->vvcc = NULL;\n\t\t}\n\n\t\ttkw->use_dref = GF_FALSE;\n\t} else if (use_av1) {\n\t\tGF_AV1Config *av1c;\n\n\t\tif (!dsi) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] No decoder specific info found for AV1\\n\"));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tav1c = gf_odf_av1_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\t\tif (!av1c) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to parser AV1 decoder specific info\\n\"));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\n\t\te = gf_isom_av1_config_new(ctx->file, tkw->track_num, av1c, (char *) src_url, NULL, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new AV1 sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->is_av1 = GF_TRUE;\n\n\t\tif (!tkw->has_brands) {\n\t\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_ISO4, 1);\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_AV01, GF_TRUE);\n\t\t}\n\n\t\tgf_odf_av1_cfg_del(av1c);\n\t} else if (use_vpX) {\n\t\tGF_VPConfig *vpc;\n\n\t\tif (!dsi) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] No decoder specific info found for %s\\n\", gf_4cc_to_str(codec_id) ));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tvpc = gf_odf_vp_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\t\tif (!vpc) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to parser %s decoder specific info\\n\", gf_4cc_to_str(codec_id)));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\n\t\te = gf_isom_vp_config_new(ctx->file, tkw->track_num, vpc, (char *) src_url, NULL, &tkw->stsd_idx, m_subtype);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new %s sample description: %s\\n\", gf_4cc_to_str(codec_id), gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->is_vpx = GF_TRUE;\n\t\tgf_odf_vp_cfg_del(vpc);\n\t} else if (use_3gpp_config) {\n\t\tGF_3GPConfig gpp_cfg;\n\t\tmemset(&gpp_cfg, 0, sizeof(GF_3GPConfig));\n\t\tgpp_cfg.type = m_subtype;\n\t\tgpp_cfg.vendor = GF_VENDOR_GPAC;\n\n\t\tif (use_dref) {\n\t\t\tgpp_cfg.frames_per_sample  = 1;\n\t\t} else {\n\t\t\tgpp_cfg.frames_per_sample = ctx->pack3gp;\n\t\t\tif (!gpp_cfg.frames_per_sample) gpp_cfg.frames_per_sample  = 1;\n\t\t\telse if (gpp_cfg.frames_per_sample >15) gpp_cfg.frames_per_sample = 15;\n\t\t}\n\t\tgpp_cfg.AMR_mode_set = tkw->amr_mode_set;\n\t\tif (tkw->stream_type==GF_STREAM_VISUAL) {\n\t\t\t/*FIXME - we need more in-depth parsing of the bitstream to detect P3@L10 (streaming wireless)*/\n\t\t\tgpp_cfg.H263_profile = 0;\n\t\t\tgpp_cfg.H263_level = 10;\n\t\t\tgpp_cfg.frames_per_sample = 0;\n\t\t}\n\t\ttkw->nb_frames_per_sample = gpp_cfg.frames_per_sample;\n\n\t\te = gf_isom_3gp_config_new(ctx->file, tkw->track_num, &gpp_cfg, (char *) src_url, NULL, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new 3GPP audio sample description for stream type %d codecid %d: %s\\n\", tkw->stream_type, codec_id, gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->use_dref = src_url ? GF_TRUE : GF_FALSE;\n\n\t\tif (!tkw->has_brands) {\n\t\t\tswitch (gpp_cfg.type) {\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_3G2A, 65536);\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_3GG6, GF_TRUE);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_3GG5, GF_TRUE);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttkw->skip_bitrate_update = GF_TRUE;\n\t} else if (use_ac3_entry) {\n\t\tGF_AC3Config ac3cfg;\n\t\tmemset(&ac3cfg, 0, sizeof(GF_AC3Config));\n\n\t\tif (dsi) {\n\t\t\tgf_odf_ac3_config_parse(dsi->value.data.ptr, dsi->value.data.size, (codec_id==GF_CODECID_EAC3) ? GF_TRUE : GF_FALSE, &ac3cfg);\n\t\t} else {\n\t\t\tif (codec_id==GF_CODECID_EAC3) ac3cfg.is_ec3 = GF_TRUE;\n\t\t}\n\t\te = gf_isom_ac3_config_new(ctx->file, tkw->track_num, &ac3cfg, (char *)src_url, NULL, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new AC3 audio sample description for stream type %d codecid %d: %s\\n\", tkw->stream_type, codec_id, gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->use_dref = src_url ? GF_TRUE : GF_FALSE;\n\t} else if (use_flac_entry) {\n\t\te = gf_isom_flac_config_new(ctx->file, tkw->track_num, dsi ? dsi->value.data.ptr : NULL, dsi ? dsi->value.data.size : 0, (char *)src_url, NULL, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new FLAC audio sample description for stream type %d codecid %d: %s\\n\", tkw->stream_type, codec_id, gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->use_dref = src_url ? GF_TRUE : GF_FALSE;\n\t} else if (use_opus) {\n\t\tGF_OpusConfig opus_cfg;\n\n\t\tif (!dsi) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] No decoder specific info found for opus\\n\" ));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\te = gf_odf_opus_cfg_parse(dsi->value.data.ptr, dsi->value.data.size, &opus_cfg);\n\t\tif (!e)\n\t\t\te = gf_isom_opus_config_new(ctx->file, tkw->track_num, &opus_cfg, (char *)src_url, NULL, &tkw->stsd_idx);\n\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new Opus audio sample description for stream type %d codecid %d: %s\\n\", tkw->stream_type, codec_id, gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->use_dref = src_url ? GF_TRUE : GF_FALSE;\n\t} else if (m_subtype == GF_ISOM_SUBTYPE_METX) {\n\t\tcomp_name = \"XML Metadata\";\n\t\te = gf_isom_new_xml_metadata_description(ctx->file, tkw->track_num, meta_xmlns, meta_schemaloc, meta_encoding, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new METX sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t} else if (m_subtype == GF_ISOM_SUBTYPE_METT) {\n\t\tcomp_name = \"Text Metadata\";\n\t\te = gf_isom_new_stxt_description(ctx->file, tkw->track_num, GF_ISOM_SUBTYPE_METT, meta_mime, meta_encoding, meta_config, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new METT sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t} else if (m_subtype == GF_ISOM_SUBTYPE_STPP) {\n\t\tif (meta_xmlns && !strcmp(meta_xmlns, \"http://www.w3.org/ns/ttml\")) {\n\t\t\tcomp_name = \"TTML\";\n\t\t} else {\n\t\t\tcomp_name = \"XML Subtitle\";\n\t\t}\n\t\te = gf_isom_new_xml_subtitle_description(ctx->file, tkw->track_num, meta_xmlns, meta_schemaloc, meta_auxmimes, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new XML subtitle sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\n\t\t//CMAF 11.3.2\n\t\tif (ctx->cmaf) {\n\t\t\tif (!meta_mime) meta_mime = gf_isom_subtitle_get_mime(ctx->file, tkw->track_num, tkw->stsd_idx);\n\t\t\tif (!meta_mime || (!strstr(meta_mime, \"im1t\") && !strstr(meta_mime, \"im1i\"))) {\n\t\t\t\tgf_isom_subtitle_set_mime(ctx->file, tkw->track_num, tkw->stsd_idx, \"application/ttml+xml;codecs=im1t\");\n\t\t\t}\n\t\t}\n\n\n\t} else if ((m_subtype == GF_ISOM_SUBTYPE_SBTT) || (m_subtype == GF_ISOM_SUBTYPE_STXT) ) {\n\t\tcomp_name = (m_subtype == GF_ISOM_SUBTYPE_STXT) ? \"Simple Timed Text\" : \"Textual Subtitle\";\n\t\te = gf_isom_new_stxt_description(ctx->file, tkw->track_num, m_subtype, meta_mime, meta_content_encoding, meta_config, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new %s sample description: %s\\n\", gf_4cc_to_str(m_subtype), gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\tif (m_subtype == GF_ISOM_SUBTYPE_STXT) force_tk_layout = GF_TRUE;\n\t} else if (use_tx3g) {\n\t\tGF_TextSampleDescriptor *txtc;\n\t\tif (!dsi) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] No decoder specific info found for TX3G\\n\"));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\ttxtc = gf_odf_tx3g_read(dsi->value.data.ptr, dsi->value.data.size);\n\t\tif (!txtc) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to parse TX3G config\\n\"));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\n\t\tif (!txtc->default_pos.right) txtc->default_pos.right = width + txtc->default_pos.left;\n\t\tif (!txtc->default_pos.bottom) txtc->default_pos.bottom = height + txtc->default_pos.top;\n\n\n\t\te = gf_isom_new_text_description(ctx->file, tkw->track_num, txtc, NULL, NULL, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tgf_odf_desc_del((GF_Descriptor *)txtc);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new %s sample description: %s\\n\", gf_4cc_to_str(m_subtype), gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\tif (ctx->importer) {\n\t\t\ttxt_fsize = txtc->default_style.font_size;\n\t\t\tif (txtc->font_count && txtc->fonts[0].fontName) txt_font = gf_strdup(txtc->fonts[0].fontName);\n\t\t}\n\t\tgf_odf_desc_del((GF_Descriptor *)txtc);\n\n\t\ttkw->skip_bitrate_update = GF_TRUE;\n\t} else if (use_webvtt) {\n#ifndef GPAC_DISABLE_VTT\n\t\te = gf_isom_new_webvtt_description(ctx->file, tkw->track_num, NULL, NULL, &tkw->stsd_idx, dsi ? dsi->value.data.ptr : NULL);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new %s sample description: %s\\n\", gf_4cc_to_str(m_subtype), gf_error_to_string(e)));\n\t\t\treturn e;\n\t\t}\n#else\n\t\treturn GF_NOT_SUPPORTED;\n#endif\n\t\ttkw->skip_bitrate_update = GF_TRUE;\n\t} else if (use_mj2) {\n\t\te = gf_isom_new_mj2k_description(ctx->file, tkw->track_num, NULL, NULL, &tkw->stsd_idx, dsi ? dsi->value.data.ptr : NULL, dsi ? dsi->value.data.size : 0);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new %s sample description: %s\\n\", gf_4cc_to_str(m_subtype), gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t} else if (codec_id==GF_CODECID_TMCD) {\n\t\tu32 tmcd_flags=0, tmcd_fps_num=0, tmcd_fps_den=0;\n\t\ts32 tmcd_fpt=0;\n\n\t\tp = gf_filter_pid_get_property_str(pid, \"tmcd:flags\");\n\t\tif (p) tmcd_flags = p->value.uint;\n\t\tp = gf_filter_pid_get_property_str(pid, \"tmcd:framerate\");\n\t\tif (p) {\n\t\t\ttmcd_fps_num = p->value.frac.num;\n\t\t\ttmcd_fps_den = p->value.frac.den;\n\t\t}\n\t\tp = gf_filter_pid_get_property_str(pid, \"tmcd:frames_per_tick\");\n\t\tif (p) tmcd_fpt = p->value.uint;\n\t\tif (tkw->tk_timescale != tmcd_fps_num) {\n\t\t\ttmcd_fps_den *= tmcd_fps_num;\n\t\t\ttmcd_fps_den /= tkw->tk_timescale;\n\t\t}\n\n\t\te = gf_isom_tmcd_config_new(ctx->file, tkw->track_num, tmcd_fps_num, tmcd_fps_den, tmcd_fpt, (tmcd_flags & 0x1), (tmcd_flags & 0x8), &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new tmcd sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t} else if (codec_id==GF_CODECID_DIMS) {\n\t\tGF_DIMSDescription dims_c;\n\t\tmemset(&dims_c, 0, sizeof(GF_DIMSDescription));\n\t\tdims_c.contentEncoding = meta_content_encoding;\n\t\tdims_c.mime_type = meta_mime;\n\t\tdims_c.textEncoding = meta_encoding;\n\t\tdims_c.xml_schema_loc = meta_xmlns;\n\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"dims:profile\");\n\t\tif (p) dims_c.profile = p->value.uint;\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"dims:level\");\n\t\tif (p) dims_c.level = p->value.uint;\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"dims:pathComponents\");\n\t\tif (p) dims_c.pathComponents = p->value.uint;\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"dims:fullRequestHost\");\n\t\tif (p) dims_c.fullRequestHost = p->value.uint;\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"dims:streamType\");\n\t\tif (p) dims_c.streamType = p->value.boolean;\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"dims:redundant\");\n\t\tif (p) dims_c.containsRedundant = p->value.uint;\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"dims:scriptTypes\");\n\t\tif (p) dims_c.content_script_types = p->value.string;\n\n\t\te = gf_isom_new_dims_description(ctx->file, tkw->track_num, &dims_c, NULL, NULL, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new DIMS sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t} else if ((codec_id==GF_CODECID_MPHA) || (codec_id==GF_CODECID_MHAS)) {\n\t\t//not ready yet\n\t\tu8 *pdsi=NULL;\n\t\tu32 dsi_len=0;\n\t\tif (codec_id==GF_CODECID_MPHA) {\n\t\t\tif (!dsi) return GF_OK;\n\t\t\tpdsi = dsi->value.data.ptr;\n\t\t\tdsi_len = dsi->value.data.size;\n\t\t}\n\t\te = gf_isom_new_mpha_description(ctx->file, tkw->track_num, NULL, NULL, &tkw->stsd_idx, pdsi, dsi_len, m_subtype);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new MPEG-H Audio sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_MHA_COMPATIBLE_PROFILES);\n\t\tif (p) {\n\t\t\tgf_isom_set_mpegh_compatible_profiles(ctx->file, tkw->track_num, tkw->stsd_idx, p->value.uint_list.vals, p->value.uint_list.nb_items);\n\t\t}\n\t} else if (codec_id==GF_CODECID_TRUEHD) {\n\t\tu32 fmt=0, prate=0;\n\t\t//not ready yet\n\t\tif (!dsi) return GF_OK;\n\t\tif (dsi->value.data.size < 6) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\tfmt = dsi->value.data.ptr[0];\n\t\tfmt <<= 8;\n\t\tfmt |= dsi->value.data.ptr[1];\n\t\tprate = dsi->value.data.ptr[2];\n\t\tprate <<= 8;\n\t\tprate |= dsi->value.data.ptr[3];\n\t\tprate >>= 1;\n\n\t\te = gf_isom_truehd_config_new(ctx->file, tkw->track_num, (char *)src_url, NULL, fmt, prate, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new TrueHD Audio sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t} else if (use_gen_sample_entry) {\n\t\tu8 isor_ext_buf[14], *gpac_meta_dsi=NULL;\n\t\tu32 len = 0;\n\t\tGF_GenericSampleDescription udesc;\n\t\tmemset(&udesc, 0, sizeof(GF_GenericSampleDescription));\n\n\t\tif (!comp_name) comp_name = \"Unknown\";\n\t\tlen = (u32) strlen(comp_name);\n\t\tif (len>32) len = 32;\n\t\tudesc.compressor_name[0] = len;\n\t\tmemcpy(udesc.compressor_name+1, comp_name, len);\n\t\tif ((codec_id==GF_CODECID_RAW) || unknown_generic)\n\t\t\tudesc.vendor_code = GF_4CC('G','P','A','C');\n\n\t\tudesc.samplerate = sr;\n\t\tudesc.nb_channels = nb_chan;\n\t\tudesc.bits_per_sample = nb_bps;\n\t\tudesc.lpcm_flags = afmt_flags | (1<<3); //add packed flag\n\t\t//for raw audio, select qt vs isom and set version\n\t\tif (sr && (codec_id==GF_CODECID_RAW)) {\n\t\t\tif (ctx->make_qt && (ase_mode==GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_BS)) {\n\t\t\t\tudesc.is_qtff = GF_TRUE;\n\t\t\t\t//if extensions or not 'raw ' or 'twos', use v1\n\t\t\t\tif (dsi ||\n\t\t\t\t\t((m_subtype!=GF_QT_SUBTYPE_TWOS) && (m_subtype!=GF_QT_SUBTYPE_RAW))\n\t\t\t\t) {\n\t\t\t\t\tudesc.version = 1;\n\t\t\t\t\tase_mode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ase_mode<=GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_MPEG) {\n\t\t\t\tm_subtype = m_subtype_alt_raw;\n\t\t\t\tudesc.extension_buf_size = 14;\n\t\t\t\tudesc.extension_buf = isor_ext_buf;\n\t\t\t\tmemset(isor_ext_buf, 0, sizeof(u8)*14);\n\t\t\t\tisor_ext_buf[3] = 14;\n\t\t\t\tisor_ext_buf[4] = 'p';\n\t\t\t\tisor_ext_buf[5] = 'c';\n\t\t\t\tisor_ext_buf[6] = 'm';\n\t\t\t\tisor_ext_buf[7] = 'C';\n\t\t\t\tisor_ext_buf[12] = (afmt_flags & (1<<1)) ? 0 : 1; //big/little endian\n\t\t\t\tisor_ext_buf[13] = nb_bps;\n\t\t\t\tif (ase_mode==GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_MPEG)\n\t\t\t\t\tudesc.version = 1;\n\t\t\t} else {\n\t\t\t\tudesc.is_qtff = GF_TRUE;\n\t\t\t\tudesc.version = 1;\n\t\t\t\tase_mode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF;\n\t\t\t}\n\t\t}\n\n\t\tif (codec_id == GF_CODECID_FFMPEG) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_SUBTYPE);\n\t\t\tif (p) {\n\t\t\t\tm_subtype = p->value.uint;\n\t\t\t} else {\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_META_DEMUX_CODEC_ID);\n\t\t\t\tif (p && p->type==GF_PROP_UINT)\n\t\t\t\t\tm_subtype = p->value.uint;\n\t\t\t}\n\t\t}\n\n\t\tudesc.codec_tag = m_subtype;\n\t\tudesc.width = width;\n\t\tudesc.height = height;\n\t\tif (width) {\n\t\t\tudesc.v_res = 72;\n\t\t\tudesc.h_res = 72;\n\t\t\tudesc.depth = 24;\n\t\t}\n\t\tif (dsi) {\n\t\t\tudesc.extension_buf = dsi->value.data.ptr;\n\t\t\tudesc.extension_buf_size = dsi->value.data.size;\n\t\t\tudesc.ext_box_wrap = gen_dsi_wrap;\n\t\t\tp = gf_filter_pid_get_property_str(pid, \"DSIWrap\");\n\t\t\tif (p) {\n\t\t\t\tif (p->type==GF_PROP_UINT) udesc.ext_box_wrap = p->value.uint;\n\t\t\t\telse if (p->type==GF_PROP_STRING) udesc.ext_box_wrap = gf_4cc_parse(p->value.string);\n\t\t\t}\n\t\t}\n\t\tif (codec_id==GF_CODECID_FFV1) {\n\t\t\tudesc.codec_tag = GF_4CC('F', 'F', 'V', '1');\n\t\t\tudesc.ext_box_wrap = GF_4CC('g', 'l', 'b', 'l');\n\t\t\tunknown_generic = GF_FALSE;\n\t\t}\n\t\tif (codec_id==GF_CODECID_SMPTE_VC1) {\n\t\t\tudesc.codec_tag = GF_4CC('v', 'c', '-', '1');\n\t\t\tunknown_generic = GF_FALSE;\n\t\t\tif (udesc.extension_buf)\n\t\t\t\tudesc.ext_box_wrap = GF_4CC('d', 'v', 'c', '1');\n\t\t}\n\t\t//move to uncv\n\t\tif ((codec_id==GF_CODECID_RAW) && !ctx->make_qt && ctx->uncv && (tkw->stream_type==GF_STREAM_VISUAL)) {\n\t\t\tif ( gf_pixel_fmt_get_uncc(pix_fmt, ctx->uncv-1, &gpac_meta_dsi, &udesc.extension_buf_size) == GF_TRUE) {\n\t\t\t\tunknown_generic = GF_FALSE;\n\t\t\t\tudesc.extension_buf = gpac_meta_dsi;\n\t\t\t\tudesc.codec_tag = m_subtype = GF_ISOM_SUBTYPE_UNCV;\n\t\t\t}\n\t\t}\n\n\t\tif (unknown_generic) {\n\t\t\t//check if this is a meta codec (unmapped codec from ffmpeg or other)\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_META_DEMUX_CODEC_ID);\n\t\t\tconst GF_PropertyValue *p2 = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_META_DEMUX_CODEC_NAME);\n\t\t\tif (p || p2) {\n\t\t\t\tu32 cid = (p && (p->type==GF_PROP_UINT)) ? p->value.uint : m_subtype;\n\t\t\t\tconst char *cname = p2 ? p2->value.string : NULL;\n\t\t\t\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t\t\tgf_bs_write_u32(bs, codec_id);\n\t\t\t\tgf_bs_write_u32(bs, cid);\n\t\t\t\tgf_bs_write_utf8(bs, cname ? cname : gf_4cc_to_str(cid));\n\t\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_META_DEMUX_OPAQUE);\n\t\t\t\tgf_bs_write_u32(bs, p ? p->value.uint : 0);\n\n\t\t\t\tif (dsi && (dsi->type != GF_PROP_DATA) && (dsi->type != GF_PROP_CONST_DATA))\n\t\t\t\t\tdsi = NULL;\n\n\t\t\t\tif (dsi) {\n\t\t\t\t\tgf_bs_write_data(bs, dsi->value.data.ptr, dsi->value.data.size);\n\t\t\t\t}\n\t\t\t\tgf_bs_get_content(bs, &gpac_meta_dsi, &udesc.extension_buf_size);\n\t\t\t\tudesc.extension_buf = gpac_meta_dsi;\n\t\t\t\tudesc.ext_box_wrap = GF_FALSE;\n\n\t\t\t\tgf_bs_del(bs);\n\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] muxing %s, using generic sample entry with 4CC \\\"GMCW\\\" and \\\"GMCC\\\" config box\\n\", gf_codecid_name(codec_id)));\n\t\t\t\tudesc.codec_tag = GF_4CC('G', 'M', 'C', 'W');\n\t\t\t\tudesc.ext_box_wrap = GF_4CC('G', 'M', 'C', 'C');\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] muxing unknown codec ID %s, using generic sample entry with 4CC \\\"%s\\\"\\n\", gf_codecid_name(codec_id), gf_4cc_to_str(m_subtype) ));\n\t\t\t}\n\t\t}\n\t\t\n\t\te = gf_isom_new_generic_sample_description(ctx->file, tkw->track_num, (char *)src_url, NULL, &udesc, &tkw->stsd_idx);\n\t\tif (gpac_meta_dsi) gf_free(gpac_meta_dsi);\n\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new sample description for stream type %d codecid %d: %s\\n\", tkw->stream_type, codec_id, gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->use_dref = src_url ? GF_TRUE : GF_FALSE;\n\n\t} else {\n\t\tassert(0);\n\t}\n\n\tif (!tkw->all_stsd_crc) {\n\t\tif (ctx->btrt && !tkw->skip_bitrate_update) {\n\t\t\tu32 avg_rate, max_rate, dbsize;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_BITRATE);\n\t\t\tavg_rate = p ? p->value.uint : 0;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_MAXRATE);\n\t\t\tmax_rate = p ? p->value.uint : 0;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DBSIZE);\n\t\t\tdbsize = p ? p->value.uint : 0;\n\n\t\t\tif (avg_rate && max_rate) {\n\t\t\t\tgf_isom_update_bitrate(ctx->file, tkw->track_num, tkw->stsd_idx, avg_rate, max_rate, dbsize);\n\t\t\t}\n\t\t} else {\n\t\t\tgf_isom_update_bitrate(ctx->file, tkw->track_num, tkw->stsd_idx, 0, 0, 0);\n\t\t}\n\t}\n\nmultipid_stsd_setup:\n\tif (multi_pid_stsd) {\n\t\tif (multi_pid_idx<gf_list_count(multi_pid_stsd)) {\n\n\t\t\tif (multi_pid_final_stsd_idx == multi_pid_idx) {\n\t\t\t\tframes_per_sample_backup = tkw->nb_frames_per_sample;\n\t\t\t\tis_nalu_backup = tkw->is_nalu;\n\t\t\t}\n\t\t\tpid = gf_list_get(multi_pid_stsd, multi_pid_idx);\n\t\t\tmulti_pid_idx ++;\n\t\t\t//reload codecID, decoder config and enhancement decoder config\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CODECID);\n\t\t\tif (p) codec_id = p->value.uint;\n\t\t\tdsi = gf_filter_pid_get_property(pid, GF_PROP_PID_DECODER_CONFIG);\n\t\t\tenh_dsi = gf_filter_pid_get_property(pid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT);\n\t\t\t//force stsd idx to be 0 to avoid removing the stsd\n\t\t\ttkw->stsd_idx = 0;\n\t\t\tgoto sample_entry_setup;\n\t\t}\n\t\ttkw->stsd_idx = multi_pid_final_stsd_idx;\n\t\t//restore input pid\n\t\tpid = orig_pid;\n\t\tcodec_id = tkw->codecid;\n\n\t\ttkw->is_nalu = is_nalu_backup;\n\t\ttkw->nb_frames_per_sample = frames_per_sample_backup;\n\t}\n\n\n\t//final opt: we couldn't detect before if the same stsd was possible, now that we have create a new one, check again\n\tif (needs_sample_entry) {\n\t\treuse_stsd = 0;\n\t\t//don't try to reuse STSDs in multi STSD setup for DASH\n\t\tif (multi_pid_stsd) count = 0;\n\t\telse count = gf_isom_get_sample_description_count(ctx->file, tkw->track_num);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tif (i+1 == tkw->stsd_idx) continue;\n\n\t\t\tif (gf_isom_is_same_sample_description(ctx->file, tkw->track_num, tkw->stsd_idx, ctx->file, tkw->track_num, i+1) ) {\n\t\t\t\tgf_isom_remove_stream_description(ctx->file, tkw->track_num, tkw->stsd_idx);\n\t\t\t\ttkw->stsd_idx = i+1;\n\t\t\t\treuse_stsd = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttkw->reused_stsd = reuse_stsd;\n\t\tif (!reuse_stsd) {\n\t\t\ttkw->samples_in_stsd = 0;\n\t\t} else if (use_3gpp_config) {\n\t\t\tGF_3GPConfig *gpp_cfg = gf_isom_3gp_config_get(ctx->file, tkw->track_num, tkw->stsd_idx);\n\t\t\tif (gpp_cfg) {\n\t\t\t\tgpp_cfg->AMR_mode_set = tkw->amr_mode_set;\n\t\t\t\tgf_isom_3gp_config_update(ctx->file, tkw->track_num, gpp_cfg, tkw->stsd_idx);\n\t\t\t\tgf_free(gpp_cfg);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tkw->is_encrypted && !skip_crypto) {\n\t\tconst char *scheme_uri=NULL;\n\t\tconst char *kms_uri=NULL;\n\t\tu32 scheme_version=0;\n\t\tu32 scheme_type = 0;\n\t\tBool is_sel_enc = GF_FALSE;\n\t\tu32 KI_length=0;\n\t\tu32 IV_length=0;\n\t\t/*todo !*/\n\t\tconst char *oma_contentID=0;\n\t\tu32 oma_encryption_type=0;\n\t\tu64 oma_plainTextLength=0;\n\t\tconst char *oma_textual_headers=NULL;\n\t\tu32 textual_headers_len=0;\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PROTECTION_SCHEME_TYPE);\n\t\tif (p) scheme_type = p->value.uint;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PROTECTION_SCHEME_VERSION);\n\t\tif (p) scheme_version = p->value.uint;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PROTECTION_SCHEME_URI);\n\t\tif (p) scheme_uri = p->value.string;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PROTECTION_KMS_URI);\n\t\tif (p) kms_uri = p->value.string;\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISMA_SELECTIVE_ENC);\n\t\tif (p) is_sel_enc = p->value.boolean;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISMA_IV_LENGTH);\n\t\tif (p) IV_length = p->value.uint;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISMA_KI_LENGTH);\n\t\tif (p) KI_length = p->value.uint;\n\n\t\ttkw->scheme_type = scheme_type;\n\t\tswitch (scheme_type) {\n\t\tcase GF_ISOM_ISMACRYP_SCHEME:\n\t\t\tgf_isom_set_ismacryp_protection(ctx->file, tkw->track_num, tkw->stsd_idx, scheme_type, scheme_version, (char *) scheme_uri, (char *) kms_uri, is_sel_enc, KI_length, IV_length);\n\t\t\tbreak;\n\t\tcase GF_ISOM_OMADRM_SCHEME:\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_OMA_CRYPT_TYPE);\n\t\t\tif (p) oma_encryption_type = p->value.uint;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_OMA_CID);\n\t\t\tif (p) oma_contentID = p->value.string;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_OMA_TXT_HDR);\n\t\t\tif (p) oma_textual_headers = p->value.string;\n\t\t\tif (oma_textual_headers) textual_headers_len = (u32) strlen(oma_textual_headers);\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_OMA_CLEAR_LEN);\n\t\t\tif (p) oma_plainTextLength = p->value.longuint;\n\t\t\tgf_isom_set_oma_protection(ctx->file, tkw->track_num, tkw->stsd_idx, (char *) oma_contentID, (char*) kms_uri, oma_encryption_type, oma_plainTextLength, (char*)oma_textual_headers, textual_headers_len,\n                                  is_sel_enc, KI_length, IV_length);\n\n\t\t\tbreak;\n\t\tcase GF_ISOM_ADOBE_SCHEME:\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ADOBE_CRYPT_META);\n\t\t\tgf_isom_set_adobe_protection(ctx->file, tkw->track_num, tkw->stsd_idx, scheme_type, 1/*scheme_version*/, 1/*is_sel_enc*/,p ? p->value.data.ptr : NULL, p ? p->value.data.size : 0);\n\t\t\tbreak;\n\t\tcase GF_ISOM_PIFF_SCHEME:\n\t\tcase GF_ISOM_CENC_SCHEME:\n\t\tcase GF_ISOM_CENS_SCHEME:\n\t\tcase GF_ISOM_CBC_SCHEME:\n\t\tcase GF_ISOM_CBCS_SCHEME:\n\t\tcase GF_HLS_SAMPLE_AES_SCHEME:\n\t\t\ttkw->cenc_state = CENC_NEED_SETUP;\n\t\t\tif (tkw->is_nalu || tkw->is_av1 || tkw->is_vpx) tkw->cenc_subsamples = GF_TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Unrecognized protection scheme type %s, using generic signaling\\n\", gf_4cc_to_str(scheme_type) ));\n\t\t\tswitch (tkw->stream_type) {\n\t\t\tcase GF_STREAM_VISUAL:\n\t\t\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_ENCV);\n\t\t\t\tbreak;\n\t\t\tcase GF_STREAM_AUDIO:\n\t\t\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_ENCA);\n\t\t\t\tbreak;\n\t\t\tcase GF_STREAM_TEXT:\n\t\t\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_ENCT);\n\t\t\t\tbreak;\n\t\t\tcase GF_STREAM_FONT:\n\t\t\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_ENCF);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_ENCS);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgf_isom_set_generic_protection(ctx->file, tkw->track_num, tkw->stsd_idx, scheme_type, scheme_version, (char*)scheme_uri, (char*)kms_uri);\n\t\t}\n\t} else if (!tkw->is_encrypted) {\n\t\t//in case we used track template\n\t\tgf_isom_remove_samp_enc_box(ctx->file, tkw->track_num);\n\t\tgf_isom_remove_samp_group_box(ctx->file, tkw->track_num);\n\t}\n\n\tif (is_true_pid) {\n\t\tmp4_mux_write_track_refs(ctx, tkw, \"isom:scal\", GF_ISOM_REF_SCAL, GF_FALSE);\n\t\tmp4_mux_write_track_refs(ctx, tkw, \"isom:sabt\", GF_ISOM_REF_SABT, GF_FALSE);\n\t\tmp4_mux_write_track_refs(ctx, tkw, \"isom:tbas\", GF_ISOM_REF_TBAS, GF_TRUE);\n\t\tmp4_mux_write_track_refs(ctx, tkw, \"isom:sbas\", GF_ISOM_REF_BASE, GF_FALSE);\n\t\t//whenever we add a new tile track, rewrite sabt on main tile track\n\t\tif (codec_id==GF_CODECID_HEVC_TILES) {\n\t\t\tcount = gf_list_count(ctx->tracks);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tTrackWriter *base_tk = gf_list_get(ctx->tracks, i);\n\t\t\t\tif (base_tk->is_hevc_tile_base)\n\t\t\t\t\tmp4_mux_write_track_refs(ctx, base_tk, \"isom:sabt\", GF_ISOM_REF_SABT, GF_FALSE);\n\t\t\t}\n\t\t}\n\n\t\t//check if we have sample-accurate seek info for the pid. If so, enable seek ts checking\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PCK_SKIP_BEGIN);\n\t\tif (p && p->value.sint)\n\t\t\ttkw->check_seek_ts = GF_TRUE;\n\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DURATION);\n\t\tif (p && p->value.lfrac.den) {\n\t\t\ttkw->pid_dur = p->value.lfrac;\n\t\t\tif (tkw->pid_dur.num<0) tkw->pid_dur.num = -tkw->pid_dur.num;\n\t\t}\n\n\t} else if (codec_id==GF_CODECID_HEVC_TILES) {\n\t\tmp4_mux_write_track_refs(ctx, tkw, \"isom:tbas\", GF_ISOM_REF_TBAS, GF_TRUE);\n\t}\n\n\tif (is_true_pid && ctx->dash_mode && is_tile_base) {\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DASH_MULTI_TRACK);\n\t\tif (p) {\n\t\t\tGF_List *multi_tracks = p->value.ptr;\n\t\t\tcount = gf_list_count(multi_tracks);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_FilterPid *a_ipid = gf_list_get(multi_tracks, i);\n\t\t\t\tmp4_mux_setup_pid(filter, a_ipid, GF_FALSE);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (width) {\n\t\tif (ctx->ccst) {\n\t\t\te = gf_isom_set_image_sequence_coding_constraints(ctx->file, tkw->track_num, tkw->stsd_idx, GF_FALSE, GF_FALSE, GF_TRUE, 15);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set coding constraints parameter: %s\\n\", gf_error_to_string(e) ));\n\t\t\t}\n\t\t}\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ALPHA);\n\t\tif (p && p->value.boolean) {\n\t\t\te = gf_isom_set_image_sequence_alpha(ctx->file, tkw->track_num, tkw->stsd_idx, GF_FALSE);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set alpha config: %s\\n\", gf_error_to_string(e) ));\n\t\t\t}\n\t\t}\n\t}\n\nsample_entry_done:\n\tif (!tkw->is_item) {\n\t\tif (ctx->maxchunk)\n\t\t\tgf_isom_hint_max_chunk_size(ctx->file, tkw->track_num, ctx->maxchunk);\n\n\t\tif (ctx->store==MP4MX_MODE_FLAT)\n\t\t\tgf_isom_hint_max_chunk_duration(ctx->file, tkw->track_num, tkw->tk_timescale * ctx->cdur.num / ctx->cdur.den);\n\n\t\tif (sr) {\n\t\t\tif (use_flac_entry) {\n\t\t\t\twhile (sr>65535) {\n\t\t\t\t\tu32 val = sr/2;\n\t\t\t\t\tif (val*2 != sr) {\n\t\t\t\t\t\tsr=65535;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsr = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (m_subtype!=GF_QT_SUBTYPE_LPCM) {\n\t\t\t\tgf_isom_set_audio_info(ctx->file, tkw->track_num, tkw->stsd_idx, sr, nb_chan, nb_bps, ctx->make_qt ? GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF : ase_mode);\n\t\t\t}\n\n\t\t\tif ((m_subtype==GF_ISOM_SUBTYPE_IPCM) || (m_subtype==GF_ISOM_SUBTYPE_FPCM)) {\n\t\t\t\tGF_AudioChannelLayout layout;\n\t\t\t\tmemset(&layout, 0, sizeof(GF_AudioChannelLayout));\n\t\t\t\tlayout.stream_structure = 1;\n\t\t\t\tlayout.channels_count = nb_chan;\n\t\t\t\tif (ch_layout)\n\t\t\t\t\tlayout.definedLayout = gf_audio_fmt_get_cicp_from_layout(ch_layout);\n\t\t\t\telse\n\t\t\t\t\tlayout.definedLayout = gf_audio_fmt_get_cicp_layout(nb_chan, 0, 0);\n\t\t\t\tgf_isom_set_audio_layout(ctx->file, tkw->track_num, tkw->stsd_idx, &layout);\n\t\t\t}\n\t\t}\n\t\telse if (width) {\n\t\t\tu32 colour_type=0;\n\t\t\tu16 colour_primaries=0, transfer_characteristics=0, matrix_coefficients=0;\n\t\t\tBool full_range_flag=GF_FALSE;\n\n\t\t\tgf_isom_set_visual_info(ctx->file, tkw->track_num, tkw->stsd_idx, width, height);\n\t\t\tif (sar.den) {\n\t\t\t\tif (sar.num != sar.den) {\n\t\t\t\t\tgf_isom_set_pixel_aspect_ratio(ctx->file, tkw->track_num, tkw->stsd_idx, sar.num, sar.den, GF_FALSE);\n\t\t\t\t\twidth = width * sar.num / sar.den;\n\t\t\t\t}\n\t\t\t\t//old importer did not set PASP for\n\t\t\t\telse if (!gf_sys_old_arch_compat() || (codec_id!=GF_CODECID_MPEG4_PART2) ) {\n\t\t\t\t\tgf_isom_set_pixel_aspect_ratio(ctx->file, tkw->track_num, tkw->stsd_idx, 1, 1, GF_TRUE);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgf_isom_set_track_layout_info(ctx->file, tkw->track_num, width<<16, height<<16, 0, 0, z_order);\n\t\t\tif (codec_id==GF_CODECID_HEVC_TILES) {\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ORIG_SIZE);\n\t\t\t\tif (p) {\n\t\t\t\t\tgf_isom_set_track_layout_info(ctx->file, tkw->track_num, p->value.vec2i.x<<16, p->value.vec2i.y<<16, 0, 0, z_order);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_COLR_PRIMARIES);\n\t\t\tif (p) colour_primaries = p->value.uint;\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_COLR_TRANSFER);\n\t\t\tif (p) transfer_characteristics = p->value.uint;\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_COLR_MX);\n\t\t\tif (p) matrix_coefficients = p->value.uint;\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_COLR_RANGE);\n\t\t\tif (p) full_range_flag = p->value.boolean;\n\n\t\t\tif (ctx->cmaf) {\n\t\t\t\tu32 hspac=0, vspac=0;\n\t\t\t\tforce_colr = GF_TRUE;\n\t\t\t\tgf_isom_get_pixel_aspect_ratio(ctx->file, tkw->track_num, tkw->stsd_idx, &hspac, &vspac);\n\t\t\t\tif (hspac && vspac) {\n\t\t\t\t\tsar.num = hspac;\n\t\t\t\t\tsar.den = vspac;\n\t\t\t\t} else {\n\t\t\t\t\tsar.den = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((ctx->prores_track == tkw) || force_colr) {\n\t\t\t\tu32 colr_mode;\n\n\t\t\t\tif ((ctx->prores_track == tkw) || ctx->make_qt)\n\t\t\t\t\tcolr_mode = GF_4CC('n','c','l','c');\n\t\t\t\telse\n\t\t\t\t\tcolr_mode = GF_4CC('n','c','l','x');\n\n\t\t\t\t//other conditions were set above, here we force 1:1 pasp box even if no sar or 1:1\n\t\t\t\tif (!sar.den || (sar.num == 1)) {\n\t\t\t\t\tgf_isom_set_pixel_aspect_ratio(ctx->file, tkw->track_num, tkw->stsd_idx, -1, -1, GF_TRUE);\n\t\t\t\t}\n\n\t\t\t\tif (colour_primaries || transfer_characteristics || matrix_coefficients) {\n\t\t\t\t\tgf_isom_set_visual_color_info(ctx->file, tkw->track_num, tkw->stsd_idx, colr_mode, colour_primaries, transfer_characteristics, matrix_coefficients, GF_FALSE, NULL, 0);\n\t\t\t\t} else {\n\t\t\t\t\te = gf_isom_get_color_info(ctx->file, tkw->track_num, tkw->stsd_idx, &colour_type, &colour_primaries, &transfer_characteristics, &matrix_coefficients, &full_range_flag);\n\t\t\t\t\tif (e==GF_NOT_FOUND) {\n\t\t\t\t\t\te = gf_media_get_color_info(ctx->file, tkw->track_num, tkw->stsd_idx, &colour_type, &colour_primaries, &transfer_characteristics, &matrix_coefficients, &full_range_flag);\n\t\t\t\t\t\tif (e)\n\t\t\t\t\t\t\te = GF_NOT_FOUND;\n\t\t\t\t\t}\n\t\t\t\t\tif (e==GF_NOT_FOUND) {\n\t\t\t\t\t\tcolour_primaries = 1;\n\t\t\t\t\t\ttransfer_characteristics = 1;\n\t\t\t\t\t\tmatrix_coefficients = 1;\n\t\t\t\t\t\tfull_range_flag = GF_FALSE;\n\t\t\t\t\t\tif (ctx->make_qt==1) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[ProRes] No color info present in visual track, defaulting to BT709\\n\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ctx->cmaf) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[CMAF] No color info present in visual track, defaulting to BT709\\n\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_set_visual_color_info(ctx->file, tkw->track_num, tkw->stsd_idx, colr_mode, colour_primaries, transfer_characteristics, matrix_coefficients, full_range_flag, NULL, 0);\n\t\t\t\t}\n\n\t\t\t\tif (ctx->prores_track == tkw) {\n\t\t\t\t\tu32 chunk_size;\n\t\t\t\t\tif ((width<=720) && (height<=576)) chunk_size = 2000000;\n\t\t\t\t\telse chunk_size = 4000000;\n\t\t\t\t\tgf_isom_hint_max_chunk_size(ctx->file, tkw->track_num, chunk_size);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (colour_primaries || transfer_characteristics || matrix_coefficients) {\n\t\t\t\t\tgf_isom_set_visual_color_info(ctx->file, tkw->track_num, tkw->stsd_idx, GF_4CC('n','c','l','x'), colour_primaries, transfer_characteristics, matrix_coefficients, full_range_flag, NULL, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//check if we have an icc profile\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ICC_PROFILE);\n\t\t\tif (p && (p->type==GF_PROP_DATA) && p->value.data.ptr) {\n\t\t\t\tgf_isom_set_visual_color_info(ctx->file, tkw->track_num, tkw->stsd_idx, 0, 0, 0, 0, GF_FALSE, p->value.data.ptr, p->value.data.size);\n\t\t\t}\n\n\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CONTENT_LIGHT_LEVEL);\n\t\t\tconst GF_PropertyValue *p2 = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_MASTER_DISPLAY_COLOUR);\n\t\t\tif (p || p2) {\n\t\t\t\tGF_MasteringDisplayColourVolumeInfo mdcv;\n\t\t\t\tGF_ContentLightLevelInfo clli;\n\t\t\t\tGF_BitStream *bs;\n\t\t\t\tif (p) {\n\t\t\t\t\tbs = gf_bs_new(p->value.data.ptr, p->value.data.size, GF_BITSTREAM_READ);\n\t\t\t\t\tclli.max_content_light_level = gf_bs_read_int(bs, 16);\n\t\t\t\t\tclli.max_pic_average_light_level = gf_bs_read_int(bs, 16);\n\t\t\t\t\tgf_bs_del(bs);\n\t\t\t\t}\n\t\t\t\tif (p2) {\n\t\t\t\t\tbs = gf_bs_new(p2->value.data.ptr, p2->value.data.size, GF_BITSTREAM_READ);\n\n\t\t\t\t\tfor(u32 c=0;c<3;c++) {\n\t\t\t\t\t\tmdcv.display_primaries[c].x = gf_bs_read_int(bs, 16);\n\t\t\t\t\t\tmdcv.display_primaries[c].y = gf_bs_read_int(bs, 16);\n\t\t\t\t\t}\n\t\t\t\t\tmdcv.white_point_x = gf_bs_read_int(bs, 16);\n\t\t\t\t\tmdcv.white_point_y = gf_bs_read_int(bs, 16);\n\t\t\t\t\tmdcv.max_display_mastering_luminance = gf_bs_read_int(bs, 32);\n\t\t\t\t\tmdcv.min_display_mastering_luminance = gf_bs_read_int(bs, 32);\n\t\t\t\t\tgf_bs_del(bs);\n\t\t\t\t}\n\t\t\t\tgf_isom_set_high_dynamic_range_info(ctx->file, tkw->track_num, tkw->stsd_idx, p2 ? &mdcv : NULL, p ? &clli : NULL);\n\t\t\t}\n\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DOLBY_VISION);\n\t\t\tif (p) {\n\t\t\t\tGF_BitStream *bs = gf_bs_new(p->value.data.ptr, p->value.data.size, GF_BITSTREAM_READ);\n\t\t\t\tGF_DOVIDecoderConfigurationRecord *dvcc = gf_odf_dovi_cfg_read_bs(bs);\n\t\t\t\tgf_bs_del(bs);\n\t\t\t\tif (dvcc && tkw->xps_inband && (dvcc->dv_profile==8) && ctx->dvsingle) {\n\t\t\t\t\tGF_DOVIDecoderConfigurationRecord *dovi = gf_isom_dovi_config_get(ctx->file, tkw->track_num, tkw->stsd_idx);\n\t\t\t\t\tif (dovi) {\n\t\t\t\t\t\tif (dovi->dv_profile==5) {\n\t\t\t\t\t\t\tgf_odf_dovi_cfg_del(dvcc);\n\t\t\t\t\t\t\tdvcc = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_odf_dovi_cfg_del(dovi);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dvcc) {\n\t\t\t\t\tif (ctx->force_dv)\n\t\t\t\t\t\tdvcc->force_dv = 1;\n\n\t\t\t\t\tgf_isom_set_dolby_vision_profile(ctx->file, tkw->track_num, tkw->stsd_idx, dvcc);\n\n\t\t\t\t\tif (!dvcc->bl_present_flag) {\n\t\t\t\t\t\tu32 ref_id = 0;\n\n\t\t\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DEPENDENCY_ID);\n\t\t\t\t\t\tif (p) ref_id = p->value.uint;\n\t\t\t\t\t\tfor (i=0; i<gf_list_count(ctx->tracks); i++) {\n\t\t\t\t\t\t\tTrackWriter *tkw_base = gf_list_get(ctx->tracks, i);\n\t\t\t\t\t\t\tif (tkw_base == tkw) continue;\n\t\t\t\t\t\t\tif (tkw->codecid!=tkw_base->codecid) continue;\n\t\t\t\t\t\t\tif (ref_id) {\n\t\t\t\t\t\t\t\tp = gf_filter_pid_get_property(tkw_base->ipid, GF_PROP_PID_ID);\n\t\t\t\t\t\t\t\tif (!p || (p->value.uint!=ref_id)) continue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tref_id = gf_isom_get_track_id(ctx->file, tkw_base->track_num);\n\t\t\t\t\t\t\tgf_isom_set_track_reference(ctx->file, tkw->track_num, GF_4CC('v','d','e','p'), ref_id);\n\n\t\t\t\t\t\t\t//dolby requires seperate moof for each track fragment for base and el\n\t\t\t\t\t\t\tif (ctx->store>=MP4MX_MODE_FRAG) {\n\t\t\t\t\t\t\t\tctx->straf = GF_TRUE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tgf_odf_dovi_cfg_del(dvcc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//default for old arch\n\t\telse if (force_tk_layout\n\t\t\t|| (use_m4sys && (tkw->stream_type==GF_STREAM_VISUAL) && !width && !height)\n\t\t)  {\n\t\t\tgf_isom_set_track_layout_info(ctx->file, tkw->track_num, 320<<16, 240<<16, 0, 0, 0);\n\t\t}\n\n\t\tif (lang_name) gf_isom_set_media_language(ctx->file, tkw->track_num, (char*)lang_name);\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_STSD_TEMPLATE);\n\t\tif (ctx->tktpl && p && p->value.data.ptr) {\n\t\t\tgf_isom_update_sample_description_from_template(ctx->file, tkw->track_num, tkw->stsd_idx, p->value.data.ptr, p->value.data.size);\n\t\t}\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CHAP_TIMES);\n\t\tconst GF_PropertyValue *p2 = gf_filter_pid_get_property(pid, GF_PROP_PID_CHAP_NAMES);\n\t\tif (p && p2 && (p->value.uint_list.nb_items == p2->value.string_list.nb_items)) {\n\t\t\tBool add_chap=GF_FALSE;\n\t\t\tBool add_tk=GF_FALSE;\n\t\t\tu32 trak_di=0;\n\t\t\tif ((ctx->chapm==MP4MX_CHAPM_BOTH) || (ctx->chapm==MP4MX_CHAPM_UDTA)) {\n\t\t\t\tgf_isom_remove_chapter(ctx->file, 0, 0);\n\t\t\t\tadd_chap = GF_TRUE;\n\t\t\t}\n\t\t\tif (((ctx->chapm==MP4MX_CHAPM_BOTH) || (ctx->chapm==MP4MX_CHAPM_TRACK))\n\t\t\t\t&& !ctx->chap_track_num\n\t\t\t) {\n\t\t\t\tGF_FontRecord frec;\n\t\t\t\tGF_TextSampleDescriptor txtdesc;\n\t\t\t\tctx->chap_track_num = gf_isom_new_track(ctx->file, 0xFFFE, GF_ISOM_MEDIA_TEXT, 1000);\n\t\t\t\tgf_isom_set_track_flags (ctx->file, ctx->chap_track_num, GF_ISOM_TK_IN_MOVIE|GF_ISOM_TK_IN_PREVIEW, GF_ISOM_TKFLAGS_SET);\n\t\t\t\t//move chapter track last\n\t\t\t\tgf_isom_set_track_index(ctx->file, ctx->chap_track_num, 0xFFFE, mp4mux_track_reorder, ctx);\n\t\t\t\tmemset(&txtdesc, 0, sizeof(GF_TextSampleDescriptor));\n\t\t\t\ttxtdesc.font_count = 1;\n\t\t\t\ttxtdesc.fonts = &frec;\n\t\t\t\tfrec.fontName = \"SANS\";\n\t\t\t\tfrec.fontID=1;\n\t\t\t\ttxtdesc.default_style.fontID=1;\n\t\t\t\ttxtdesc.default_style.font_size = 32;\n\t\t\t\t//txtdesc.default_style.text_color = 0xFFFFFFFF;\n\t\t\t\t//txtdesc.horiz_justif = 1;\n\t\t\t\t//txtdesc.vert_justif = (s8) -1;\t/*bottom of scene*/\n\n\t\t\t\tgf_isom_new_text_description(ctx->file, ctx->chap_track_num, &txtdesc, NULL, NULL, &trak_di);\n\t\t\t\tadd_tk = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (add_tk || add_chap) {\n\t\t\t\tu32 j;\n\t\t\t\tu64 maxts = (ctx->dur.num && ctx->dur.den) ? gf_timestamp_rescale(ctx->dur.num, ctx->dur.den, 1000) : 0;\n\t\t\t\tfor (j=0; j<p->value.uint_list.nb_items; j++) {\n\t\t\t\t\tu32 start_time = p->value.uint_list.vals[j];\n\t\t\t\t\tif (ctx->start > start_time) {\n\t\t\t\t\t\tif (j+1 < p->value.uint_list.nb_items) {\n\t\t\t\t\t\t\tu64 next = p->value.uint_list.vals[j+1];\n\t\t\t\t\t\t\tif (ctx->start>=next)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (start_time > (u32) ctx->start) start_time -= (u32) ctx->start;\n\t\t\t\t\t\telse start_time=0;\n\t\t\t\t\t}\n\t\t\t\t\tif (maxts && (maxts<=start_time))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tif (add_chap) {\n\t\t\t\t\t\tgf_isom_add_chapter(ctx->file, 0, start_time, p2->value.string_list.vals[j]);\n\t\t\t\t\t}\n\t\t\t\t\tif (add_tk) {\n\t\t\t\t\t\tGF_TextSample tx;\n\t\t\t\t\t\tmemset(&tx, 0, sizeof(tx));\n\t\t\t\t\t\ttx.text = p2->value.string_list.vals[j];\n\t\t\t\t\t\ttx.len = (u32) strlen(p2->value.string_list.vals[j])+1;\n\t\t\t\t\t\tGF_ISOSample *samp = gf_isom_text_to_sample(&tx);\n\t\t\t\t\t\tsamp->DTS = start_time;\n\t\t\t\t\t\tsamp->IsRAP = 1;\n\n\t\t\t\t\t\t//force fist chapter to start at 0\n\t\t\t\t\t\tif (!j && samp->DTS) {\n\t\t\t\t\t\t\tsamp->DTS = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_add_sample(ctx->file, ctx->chap_track_num, trak_di, samp);\n\t\t\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((ctx->chapm==MP4MX_CHAPM_BOTH) || (ctx->chapm==MP4MX_CHAPM_TRACK)) {\n\t\t\t\tgf_isom_set_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_CHAP, gf_isom_get_track_id(ctx->file, ctx->chap_track_num));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tkw->is_encrypted) {\n\t\ttkw->cenc_ki = gf_filter_pid_get_property(pid, GF_PROP_PID_CENC_KEY_INFO);\n\t\tif (tkw->cenc_ki && ((tkw->cenc_ki->type != GF_PROP_DATA) || !gf_cenc_validate_key_info(tkw->cenc_ki->value.data.ptr, tkw->cenc_ki->value.data.size))\n\t\t) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Invalid CENC key info\\n\"));\n\t\t\ttkw->cenc_ki = NULL;\n\t\t}\n\n\t\ttkw->constant_IV_size = 0;\n\t\tif (tkw->cenc_ki && tkw->cenc_ki->value.data.ptr) {\n\t\t\ttkw->cenc_multikey = tkw->cenc_ki->value.data.ptr[0] ? GF_TRUE : GF_FALSE;\n\n\t\t\tif (!tkw->cenc_ki->value.data.ptr[3])\n\t\t\t\ttkw->constant_IV_size = !tkw->cenc_ki->value.data.ptr[20];\n\n\t\t\ttkw->cenc_key_info_crc = gf_crc_32(tkw->cenc_ki->value.data.ptr, tkw->cenc_ki->value.data.size);\n\t\t}\n\t}\n\n\tif (is_true_pid) {\n\t\tconst GF_PropertyValue *ster = gf_filter_pid_get_property(pid, GF_PROP_PID_STEREO_TYPE);\n\t\tconst GF_PropertyValue *proj = gf_filter_pid_get_property(pid, GF_PROP_PID_PROJECTION_TYPE);\n\t\tconst GF_PropertyValue *pose = gf_filter_pid_get_property(pid, GF_PROP_PID_VR_POSE);\n\n\t\tif (ster || proj) {\n\t\t\tGF_ISOM_Y3D_Info yt3d;\n\t\t\tmemset(&yt3d, 0, sizeof(GF_ISOM_Y3D_Info));\n\t\t\tyt3d.projection_type = proj ? proj->value.uint : 0;\n\t\t\tyt3d.stereo_type = ster ? ster->value.uint : 0;\n\t\t\tif (pose) {\n\t\t\t\tyt3d.pose_present = GF_TRUE;\n\t\t\t\tyt3d.yaw = pose->value.vec3i.x;\n\t\t\t\tyt3d.pitch = pose->value.vec3i.y;\n\t\t\t\tyt3d.roll = pose->value.vec3i.z;\n\t\t\t\tyt3d.stereo_type = ster ? ster->value.uint : 0;\n\t\t\t}\n\t\t\tif (yt3d.projection_type==GF_PROJ360_CUBE_MAP) {\n\t\t\t\tproj = gf_filter_pid_get_property(pid, GF_PROP_PID_CUBE_MAP_PAD);\n\t\t\t\tyt3d.padding = proj ? proj->value.uint : 0;\n\t\t\t}\n\t\t\telse if (yt3d.projection_type==GF_PROJ360_EQR) {\n\t\t\t\tproj = gf_filter_pid_get_property(pid, GF_PROP_PID_EQR_CLAMP);\n\t\t\t\tif (proj) {\n\t\t\t\t\tyt3d.top = proj->value.vec4i.x;\n\t\t\t\t\tyt3d.bottom = proj->value.vec4i.y;\n\t\t\t\t\tyt3d.left = proj->value.vec4i.z;\n\t\t\t\t\tyt3d.right = proj->value.vec4i.w;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_isom_set_y3d_info(ctx->file, tkw->track_num, tkw->stsd_idx, &yt3d);\n\t\t}\n\t}\n\n\n\tif (is_true_pid && ctx->importer && !tkw->import_msg_header_done) {\n#ifndef GPAC_DISABLE_LOG\n\t\tconst char *dst_type = tkw->is_item ? \"Item Importing\" : \"Track Importing\";\n#endif\n\t\ttkw->import_msg_header_done = GF_TRUE;\n\t\tif (!imp_name) imp_name = comp_name;\n\t\tif (sr) {\n\t\t\tif (nb_chan) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s - SampleRate %d Num Channels %d\\n\", dst_type, imp_name, sr, nb_chan));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s - SampleRate %d\\n\", dst_type, imp_name, sr));\n\t\t\t}\n\t\t} else if (is_text_subs) {\n\t\t\tif (txt_fsize || txt_font) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s - Text track %d x %d font %s (size %d) layer %d\\n\", dst_type, imp_name, width, height, txt_font ? txt_font : \"unspecified\", txt_fsize, z_order));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s - Text track %d x %d layer %d\\n\", dst_type, imp_name, width, height, z_order));\n\n\t\t\t}\n\t\t} else if (width) {\n\t\t\tif (sar.den && sar.num) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s - Width %d Height %d FPS %d/%d SAR %d/%u\\n\", dst_type, imp_name, width, height, fps.num, fps.den, sar.num, sar.den));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s - Width %d Height %d FPS %d/%d\\n\", dst_type, imp_name, width, height, fps.num, fps.den));\n\t\t\t}\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s\\n\", dst_type, imp_name));\n\t\t}\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tif (tkw->svcc) {\n\t\t\tAVCState avc;\n\t\t\tmemset(&avc, 0, sizeof(AVCState));\n\t\t\tcount = gf_list_count(tkw->svcc->sequenceParameterSets);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_NALUFFParam *sl = gf_list_get(tkw->svcc->sequenceParameterSets, i);\n\t\t\t\tu8 nal_type = sl->data[0] & 0x1F;\n\t\t\t\tBool is_subseq = (nal_type == GF_AVC_NALU_SVC_SUBSEQ_PARAM) ? GF_TRUE : GF_FALSE;\n\t\t\t\ts32 ps_idx = gf_avc_read_sps(sl->data, sl->size, &avc, is_subseq, NULL);\n\t\t\t\tif (ps_idx>=0) {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"SVC Detected - SSPS ID %d - frame size %d x %d\\n\", ps_idx-GF_SVC_SSPS_ID_SHIFT, avc.sps[ps_idx].width, avc.sps[ps_idx].height ));\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\n\t}\n\tif (txt_font) gf_free(txt_font);\n\tif (!tkw->xps_inband || tkw->is_item) {\n\t\tif (tkw->svcc) {\n\t\t\tgf_odf_avc_cfg_del(tkw->svcc);\n\t\t\ttkw->svcc = NULL;\n\t\t}\n\t\tif (tkw->lvcc) {\n\t\t\tgf_odf_hevc_cfg_del(tkw->lvcc);\n\t\t\ttkw->lvcc = NULL;\n\t\t}\n\t} else if (needs_sample_entry || make_inband_headers) {\n\t\tmp4_mux_make_inband_header(ctx, tkw, GF_FALSE);\n\t\tif (ctx->pps_inband || tkw->xps_inband)\n\t\t\tmp4_mux_make_inband_header(ctx, tkw, GF_TRUE);\n\t}\n\n\ttkw->negctts_shift = 0;\n\ttkw->probe_min_ctts = GF_FALSE;\n\tif (is_true_pid && !tkw->nb_samples && !tkw->is_item) {\n\t\tBool use_negccts = GF_FALSE;\n\t\tBool remove_edits = GF_FALSE;\n\t\ts64 moffset=0;\n\t\tctx->config_timing = GF_TRUE;\n\t\tctx->update_report = GF_TRUE;\n\n\t\t//if we have an edit list (due to track template) only providing media offset, trash it\n\t\tif (!gf_isom_get_edit_list_type(ctx->file, tkw->track_num, &moffset)) {\n\t\t\tif (!gf_sys_old_arch_compat()) {\n\t\t\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\t\t\t} else {\n\t\t\t\t//old arch compat: if we had a simple edit list in source, keep dur and offset\n\t\t\t\t//and avoid rewriting it when recomputing edit for b-frames\n\t\t\t\tu64 etime, sdur;\n\t\t\t\tGF_ISOEditType etype;\n\t\t\t\tgf_isom_get_edit(ctx->file, tkw->track_num, 1, &etime, &sdur, &moffset, &etype);\n\t\t\t\tif (!etime && sdur) {\n\t\t\t\t\ttkw->imported_edit_sdur = sdur;\n\t\t\t\t\ttkw->imported_edit_offset = moffset;\n\t\t\t\t}\n\t\t\t\tremove_edits = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_FORCE_NEGCTTS);\n\t\tif (p && p->value.boolean) use_negccts = GF_TRUE;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DELAY);\n\t\tif (p) {\n\t\t\t//media skip\n\t\t\tif (p->value.longsint < 0) {\n\t\t\t\t//if cmf2, remove edits and use negctss\n\t\t\t\tif ((ctx->cmaf==MP4MX_CMAF_CMF2) && (tkw->stream_type==GF_STREAM_VISUAL)) {\n\t\t\t\t\tctx->ctmode = MP4MX_CT_NEGCTTS;\n\t\t\t\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\t\t\t\t\tuse_negccts = GF_TRUE;\n\t\t\t\t}\n\t\t\t\telse if ((ctx->ctmode==MP4MX_CT_NEGCTTS) && (tkw->stream_type==GF_STREAM_VISUAL)) {\n\t\t\t\t\tuse_negccts = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tif (remove_edits) {\n\t\t\t\t\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_set_edit(ctx->file, tkw->track_num, 0, 0, -p->value.longsint, GF_ISOM_EDIT_NORMAL);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//media delay\n\t\t\telse if (p->value.longsint > 0) {\n\t\t\t\t//if cmaf (whether cmfc or cmf2), remove edits and add delay to tfdt\n\t\t\t\tif (ctx->cmaf) {\n\t\t\t\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\t\t\t\t\ttkw->patch_tfdt = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\ts64 dur = gf_timestamp_rescale_signed(p->value.longsint, tkw->src_timescale, ctx->moovts);\n\t\t\t\t\ts64 diff_low = (s64) p->value.longuint - dur * tkw->src_timescale / ctx->moovts;\n\t\t\t\t\t//we are loosing precision, check if true value is closer to next representable value in movie timescale\n\t\t\t\t\tif (diff_low>0) {\n\t\t\t\t\t\ts64 diff_high = (dur+1) * tkw->src_timescale / ctx->moovts - (s64) p->value.longuint;\n\t\t\t\t\t\tif (diff_high < diff_low) dur++;\n\t\t\t\t\t}\n\t\t\t\t\tif (remove_edits) {\n\t\t\t\t\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\t\t\t\t\t}\n\t\t\t\t\tif (dur) {\n\t\t\t\t\t\tgf_isom_set_edit(ctx->file, tkw->track_num, 0, dur, 0, GF_ISOM_EDIT_EMPTY);\n\t\t\t\t\t\tgf_isom_set_edit(ctx->file, tkw->track_num, dur, 0, 0, GF_ISOM_EDIT_NORMAL);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttkw->ts_delay = (s32) p->value.longsint;\n\t\t} else if (tkw->stream_type==GF_STREAM_VISUAL) {\n\t\t\ttkw->probe_min_ctts = GF_TRUE;\n\t\t}\n\t\t//for old arch compatibility\n\t\telse if (remove_edits) {\n\t\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"reframer_rem_edits\");\n\t\t\tif (p && p->value.boolean) {\n\t\t\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\t\t\t}\n\t\t}\n\t\tif (use_negccts) {\n\t\t\tgf_isom_set_composition_offset_mode(ctx->file, tkw->track_num, GF_TRUE);\n\n\t\t\tif (!tkw->has_brands) {\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO4, GF_TRUE);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO1, GF_FALSE);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO2, GF_FALSE);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO3, GF_FALSE);\n\t\t\t}\n\n\t\t\ttkw->negctts_shift = (tkw->ts_delay<0) ? -tkw->ts_delay : 0;\n\t\t} else {\n\t\t\t//this will remove any cslg in the track due to template\n\t\t\tgf_isom_set_composition_offset_mode(ctx->file, tkw->track_num, GF_FALSE);\n\t\t}\n\n\t\tif (!ctx->noinit) {\n\t\t\tmp4_mux_set_tags(ctx, tkw);\n\t\t\tmp4_mux_set_udta(ctx, tkw);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nstatic GF_Err mp4_mux_flush_fragmented(GF_MP4MuxCtx *ctx);\n#endif\nstatic GF_Err mp4_mux_done(GF_MP4MuxCtx *ctx, Bool is_final);\n\nstatic GF_Err mp4_mux_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (is_remove) {\n\t\tTrackWriter *tkw = gf_filter_pid_get_udta(pid);\n\t\tif (tkw) {\n\t\t\tgf_list_del_item(ctx->tracks, tkw);\n\t\t\tgf_free(tkw);\n\t\t}\n\t\t//removing last pid\n\t\tif (ctx->opid && !gf_list_count(ctx->tracks)) {\n\t\t\tif (ctx->file) {\n\t\t\t\t//non-frag file, flush file\n\t\t\t\tif (!ctx->init_movie_done) {\n\t\t\t\t\tmp4_mux_done(ctx, GF_TRUE);\n\t\t\t\t}\n\t\t\t} else {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\twhile (ctx->flush_size) {\n\t\t\t\t\tGF_Err e = mp4_mux_flush_fragmented(ctx);\n\t\t\t\t\tif (e) break;\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t\t//delete output pid (to flush destruction of filter chain)\n\t\t\tgf_filter_pid_remove(ctx->opid);\n\t\t\tctx->opid = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\treturn mp4_mux_setup_pid(filter, pid, GF_TRUE);\n}\n\nstatic Bool mp4_mux_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (evt->base.on_pid && (evt->base.type==GF_FEVT_INFO_UPDATE) ) {\n\t\tTrackWriter *tkw = gf_filter_pid_get_udta(evt->base.on_pid);\n\t\tif (tkw) {\n\t\t\tGF_PropertyEntry *pe=NULL;\n\t\t\tconst GF_PropertyValue *p;\n\t\t\tp = gf_filter_pid_get_info(tkw->ipid, GF_PROP_PID_DOWN_BYTES, &pe);\n\t\t\tif (p) tkw->down_bytes = p->value.longuint;\n\n\t\t\tp = gf_filter_pid_get_info(tkw->ipid, GF_PROP_PID_DOWN_SIZE, &pe);\n\t\t\tif (p) tkw->down_size = p->value.longuint;\n\n\t\t\tgf_filter_release_property(pe);\n\t\t}\n\n\t\treturn GF_FALSE;\n\t}\n\tif (!evt->base.on_pid && (evt->base.type==GF_FEVT_STOP) ) {\n\t\tif (ctx->file && ctx->owns_mov) {\n\t\t\tmp4_mux_done(ctx, GF_TRUE);\n\t\t}\n\t}\n\tif (evt->base.on_pid && (evt->base.type==GF_FEVT_PLAY) ) {\n\t\tu32 i, count;\n\t\tGF_FilterEvent anevt;\n\t\tctx->force_play = GF_TRUE;\n\t\tif (evt->play.speed<0)\n\t\t\tctx->is_rewind = GF_TRUE;\n\n\t\tif (ctx->start == 0)\n\t\t\treturn GF_FALSE;\n\n\t\tcount = gf_list_count(ctx->tracks);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\t\tif (tkw->fake_track) continue;\n\n\t\t\tanevt.play = evt->play;\n\t\t\tgf_filter_pid_init_play_event(tkw->ipid, &anevt, ctx->start, 0, \"MP4Mux\");\n\t\t\tif (anevt.play.start_range > 0)\n\t\t\t\ttkw->wait_sap = GF_TRUE;\n\n\t\t\tgf_filter_pid_send_event(tkw->ipid, &anevt);\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\n\nenum\n{\n\tCENC_CONFIG=0,\n\tCENC_ADD_NORMAL,\n\tCENC_ADD_FRAG,\n};\n\nstatic void mp4_mux_cenc_insert_pssh(GF_MP4MuxCtx *ctx, TrackWriter *tkw, const GF_PropertyValue *pssh, u32 dyn_pssh_mode)\n{\n\tbin128 *keyIDs=NULL;\n\tu32 max_keys = 0;\n\tu32 i, nb_pssh;\n\tGF_PropertyValue _the_prop;\n\n\t//set pssh\n\tconst GF_PropertyValue *p=NULL;\n\n\t//only inject if pssh in packet\n\tif (dyn_pssh_mode==2) {\n\t\tGF_FilterPacket *pck;\n\t\t//nothing to inject\n\t\tif (!tkw->dyn_pssh) return;\n\t\tpck = gf_filter_pid_get_packet(tkw->ipid);\n\t\tif (pck) {\n\t\t\tpssh = gf_filter_pck_get_property(pck, GF_PROP_PID_CENC_PSSH);\n\t\t\t//change of dynamic pssh is pending, don't inject the old one\n\t\t\tif (pssh) return;\n\t\t}\n\t\t_the_prop.type = GF_PROP_DATA;\n\t\t_the_prop.value.data.ptr = tkw->dyn_pssh;\n\t\t_the_prop.value.data.size = tkw->dyn_pssh_len;\n\t\tp = &_the_prop;\n\t} else {\n\t\tif (pssh) {\n\t\t\tp = pssh;\n\t\t} else {\n\t\t\t//inject pssh from packet if any, or from PID (used for keyroll of master+leaf schemes)\n\t\t\tif (dyn_pssh_mode) {\n\t\t\t\tGF_FilterPacket *pck = gf_filter_pid_get_packet(tkw->ipid);\n\t\t\t\tif (pck) {\n\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PID_CENC_PSSH);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p)\n\t\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CENC_PSSH);\n\t\t}\n\t\tif (!p) return;\n\t}\n\n\tif (!ctx->bs_r) ctx->bs_r = gf_bs_new(p->value.data.ptr, p->value.data.size, GF_BITSTREAM_READ);\n\telse gf_bs_reassign_buffer(ctx->bs_r, p->value.data.ptr, p->value.data.size);\n\n\tnb_pssh = gf_bs_read_u32(ctx->bs_r);\n\tfor (i = 0; i < nb_pssh; i++) {\n\t\tu32 mode;\n\t\tbin128 sysID;\n\t\tu32 j, kid_count, version=0;\n\t\tchar *data;\n\t\tu32 len;\n\n\t\tgf_bs_read_data(ctx->bs_r, sysID, 16);\n\t\tversion = gf_bs_read_u32(ctx->bs_r);\n\t\tkid_count = version ? gf_bs_read_u32(ctx->bs_r) : 0;\n\n\t\tif (kid_count>=max_keys) {\n\t\t\tmax_keys = kid_count;\n\t\t\tkeyIDs = gf_realloc(keyIDs, sizeof(bin128)*max_keys);\n\t\t}\n\t\tfor (j=0; j<kid_count; j++) {\n\t\t\tgf_bs_read_data(ctx->bs_r, keyIDs[j], 16);\n\t\t}\n\t\tlen = gf_bs_read_u32(ctx->bs_r);\n\t\tdata = p->value.data.ptr + gf_bs_get_position(ctx->bs_r);\n\n\t\tif (tkw->is_item) mode = 2;\n\t\telse if (tkw->scheme_type==GF_ISOM_PIFF_SCHEME) mode = 1;\n\t\telse mode = 0;\n\n\t\tgf_cenc_set_pssh(ctx->file, sysID, version, kid_count, keyIDs, data, len, mode);\n\t\tgf_bs_skip_bytes(ctx->bs_r, len);\n\t\tif (gf_bs_is_overflow(ctx->bs_r))\n\t\t\tbreak;\n\t}\n\tif (keyIDs) gf_free(keyIDs);\n\n\n\tif (pssh) {\n\t\tif (tkw->dyn_pssh) gf_free(tkw->dyn_pssh);\n\t\ttkw->dyn_pssh = gf_malloc(sizeof(u8) * pssh->value.data.size);\n\t\tif (!tkw->dyn_pssh) return;\n\t\tmemcpy(tkw->dyn_pssh, pssh->value.data.ptr, sizeof(u8) * pssh->value.data.size);\n\t\ttkw->dyn_pssh_len = pssh->value.data.size;\n\t}\n\n}\n\nstatic GF_Err mp4_mux_cenc_update(GF_MP4MuxCtx *ctx, TrackWriter *tkw, GF_FilterPacket *pck, u32 act_type, u32 pck_size, u32 injected_hdr_size)\n{\n\tconst GF_PropertyValue *p;\n\tGF_Err e;\n\tBool pck_is_encrypted;\n\tu32 IV_size=0;\n\tu8 *fake_sai = NULL;\n\tu8 *sai = NULL;\n\tu32 sai_size = 0;\n\tBool needs_seig = GF_FALSE;\n\tu32 sample_num;\n\n\tif (tkw->cenc_state == CENC_SETUP_ERROR)\n\t\treturn GF_SERVICE_ERROR;\n\n\n\tif (pck) {\n\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_CENC_SAI);\n\t\tif (p) {\n\t\t\tsai = p->value.data.ptr;\n\t\t\tsai_size = p->value.data.size;\n\t\t}\n\t}\n\n\n\t//initial setup\n\tif (tkw->cenc_state==CENC_NEED_SETUP) {\n\t\tu32 scheme_type=0;\n\t\tu32 scheme_version=0;\n\t\tu32 cenc_stsd_mode=0;\n\t\tu32 container_type = GF_ISOM_BOX_TYPE_SENC;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_PROTECTION_SCHEME_TYPE);\n\t\tif (p) scheme_type = p->value.uint;\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_PROTECTION_SCHEME_VERSION);\n\t\tif (p) scheme_version = p->value.uint;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CENC_STSD_MODE);\n\t\tif (p) cenc_stsd_mode = p->value.uint;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ENCRYPTED);\n\t\tif (p) pck_is_encrypted = p->value.boolean;\n\t\telse pck_is_encrypted = GF_FALSE;\n\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CENC_STORE);\n\t\tif (p && p->value.uint) container_type = p->value.uint;\n\n\t\ttkw->clear_stsd_idx = 0;\n\t\tif (cenc_stsd_mode) {\n\t\t\tu32 clone_stsd_idx;\n\t\t\te = gf_isom_clone_sample_description(ctx->file, tkw->track_num, ctx->file, tkw->track_num, tkw->stsd_idx, NULL, NULL, &clone_stsd_idx);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to clone sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\t//current stsd reused, use clone one for encrypted stsd\n\t\t\tif (tkw->reused_stsd) {\n\t\t\t\ttkw->clear_stsd_idx = tkw->stsd_idx;\n\t\t\t\ttkw->stsd_idx = clone_stsd_idx;\n\t\t\t}\n\t\t\t//before\n\t\t\telse if (cenc_stsd_mode==1) {\n\t\t\t\ttkw->clear_stsd_idx = tkw->stsd_idx;\n\t\t\t\ttkw->stsd_idx = clone_stsd_idx;\n\t\t\t}\n\t\t\t//after\n\t\t\telse {\n\t\t\t\ttkw->clear_stsd_idx = clone_stsd_idx;\n\t\t\t}\n\t\t}\n\t\ttkw->def_crypt_byte_block = tkw->crypt_byte_block;\n\t\ttkw->def_skip_byte_block = tkw->skip_byte_block;\n\n\t\ttkw->cenc_state = CENC_SETUP_DONE;\n\t\ttkw->def_cenc_key_info_crc = tkw->cenc_key_info_crc;\n\t\tif (tkw->cenc_ki) {\n\t\t\te = gf_isom_set_cenc_protection(ctx->file, tkw->track_num, tkw->stsd_idx, scheme_type, scheme_version, pck_is_encrypted, tkw->def_crypt_byte_block, tkw->def_skip_byte_block, tkw->cenc_ki->value.data.ptr, tkw->cenc_ki->value.data.size);\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Missing CENC Key config, cannot mux\\n\"));\n\t\t\ttkw->cenc_state = CENC_SETUP_ERROR;\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to setup CENC information: %s\\n\", gf_error_to_string(e) ));\n\t\t\ttkw->cenc_state = CENC_SETUP_ERROR;\n\t\t\treturn e;\n\t\t}\n\n\t\t//purge duplicates\n\t\tu32 k, nb_sdesc = gf_isom_get_sample_description_count(ctx->file, tkw->track_num);\n\t\tif (nb_sdesc>2) {\n\t\t\tfor (k=0; k<nb_sdesc; k++) {\n\t\t\t\tif (k+1 == tkw->stsd_idx) continue;\n\n\t\t\t\tif (gf_isom_is_same_sample_description(ctx->file, tkw->track_num, tkw->stsd_idx, ctx->file, tkw->track_num, k+1) ) {\n\t\t\t\t\tgf_isom_remove_stream_description(ctx->file, tkw->track_num, tkw->stsd_idx);\n\t\t\t\t\ttkw->stsd_idx = k+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((ctx->psshs == MP4MX_PSSH_MOOV) || (ctx->psshs == MP4MX_PSSH_BOTH))\n\t\t\tmp4_mux_cenc_insert_pssh(ctx, tkw, NULL, 0);\n\n\t\tif (!tkw->has_brands && (scheme_type==GF_ISOM_OMADRM_SCHEME))\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_OPF2, GF_TRUE);\n\n\t\tif (container_type) {\n\t\t\tif (container_type==GF_ISOM_BOX_UUID_PSEC) {\n\t\t\t\te = gf_isom_piff_allocate_storage(ctx->file, tkw->track_num, 0, 0, NULL);\n\t\t\t} else {\n\t\t\t\te = gf_isom_cenc_allocate_storage(ctx->file, tkw->track_num);\n\t\t\t}\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to setup CENC storage: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\ttkw->cenc_state = CENC_SETUP_ERROR;\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t}\n\tif (act_type==CENC_CONFIG) return GF_OK;\n\n\tpck_is_encrypted = GF_FALSE;\n\tif (pck)\n\t\tpck_is_encrypted = gf_filter_pck_get_crypt_flags(pck);\n\n\t//!! tkw->nb_samples / tkw->samples_in_frag not yet incremented !!\n\tif (act_type == CENC_ADD_FRAG) {\n\t\tsample_num = tkw->samples_in_frag + 1;\n\n\t\tif (ctx->cmaf) {\n\t\t\tif (!tkw->samples_in_frag) {\n\t\t\t\ttkw->cenc_frag_protected = pck_is_encrypted;\n\t\t\t} else {\n\t\t\t\tif (tkw->cenc_frag_protected != pck_is_encrypted) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] CMAF forbids mixing protected and unprotected samples in a single fragment, please re-encrypt or change target segment duration\\n\"));\n\t\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsample_num = tkw->nb_samples + 1;\n\t}\n\tif (!pck_is_encrypted) {\n\t\tif (tkw->clear_stsd_idx) {\n\t\t\tif (act_type==CENC_ADD_FRAG) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\treturn gf_isom_fragment_set_cenc_sai(ctx->file, tkw->track_id, NULL, 0, GF_FALSE, ctx->saio32, tkw->cenc_multikey);\n#else\n\t\t\t\treturn GF_NOT_SUPPORTED;\n#endif\n\t\t\t} else {\n\t\t\t\treturn gf_isom_track_cenc_add_sample_info(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_SENC, NULL, 0, tkw->cenc_subsamples, ctx->saio32, tkw->cenc_multikey);\n\t\t\t}\n\t\t} else {\n\t\t\tchar dumb_key[20];\n\t\t\tmemset(dumb_key, 0, 20); //dumb key, IV size 0, not protected\n\t\t\te = gf_isom_set_sample_cenc_group(ctx->file, tkw->track_num, sample_num, GF_FALSE, 0, 0, dumb_key, 20);\n\t\t\tIV_size = 0;\n\t\t\ttkw->has_seig = GF_TRUE;\n\t\t}\n\t} else {\n\t\n\t\te = GF_OK;\n\t\t//multikey ALWAYS uses seig\n\t\tif (tkw->cenc_ki->value.data.ptr[0])\n\t\t\tneeds_seig = GF_TRUE;\n\t\telse if (tkw->def_crypt_byte_block != tkw->crypt_byte_block)\n\t\t\tneeds_seig = GF_TRUE;\n\t\telse if (tkw->def_skip_byte_block != tkw->skip_byte_block)\n\t\t\tneeds_seig = GF_TRUE;\n\t\telse if (tkw->def_cenc_key_info_crc != tkw->cenc_key_info_crc)\n\t\t\tneeds_seig = GF_TRUE;\n\n\t\tif (needs_seig) {\n\t\t\te = gf_isom_set_sample_cenc_group(ctx->file, tkw->track_num, sample_num, 1, tkw->crypt_byte_block, tkw->skip_byte_block, tkw->cenc_ki->value.data.ptr, tkw->cenc_ki->value.data.size);\n\t\t\ttkw->has_seig = GF_TRUE;\n\t\t} else if (tkw->has_seig) {\n\t\t\te = gf_isom_set_sample_cenc_default_group(ctx->file, tkw->track_num, sample_num);\n\t\t}\n\t}\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set sample encryption group entry: %s)\\n\", gf_error_to_string(e) ));\n\t\treturn e;\n\t}\n\n\tp = gf_filter_pck_get_property(pck, GF_PROP_PID_CENC_PSSH);\n\tif (p && (p->type == GF_PROP_DATA) && p->value.data.ptr) {\n\t\tif (ctx->store>=MP4MX_MODE_FRAG) {\n\t\t\tmp4_mux_cenc_insert_pssh(ctx, tkw, p, 0);\n\t\t} else {\n\t\t\tgf_isom_set_sample_group_description(ctx->file, tkw->track_num, sample_num, GF_4CC('P','S','S','H'), 0, p->value.data.ptr, p->value.data.size, 0);\n\t\t}\n\t}\n\n\tif (!sai) {\n\t\tif (tkw->constant_IV_size && !tkw->cenc_subsamples)\n\t\t\treturn GF_OK;\n\n\t\tif (IV_size) {\n\t\t\t//generate clear SAI data with a non-0 IV\n\t\t\tu32 olen = pck_size;\n\t\t\tGF_BitStream *bs = gf_bs_new(NULL, 9, GF_BITSTREAM_WRITE);\n\t\t\tif (tkw->cenc_multikey) {\n\t\t\t\tgf_bs_write_u16(bs, 0);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_long_int(bs, 0, IV_size*8);\n\t\t\t}\n\n\t\t\tif (tkw->cenc_subsamples) {\n\t\t\t\tu32 i;\n\t\t\t\tu32 subsample_count = 1;\n\t\t\t\twhile (olen>0xFFFF) {\n\t\t\t\t\tolen -= 0xFFFF;\n\t\t\t\t\tsubsample_count ++;\n\t\t\t\t}\n\t\t\t\tgf_bs_write_u16(bs, subsample_count);\n\t\t\t\tolen = pck_size;\n\t\t\t\tfor (i = 0; i < subsample_count; i++) {\n\t\t\t\t\tu32 clear_size;\n\t\t\t\t\tif (olen<0xFFFF) {\n\t\t\t\t\t\tclear_size = olen;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclear_size = 0xFFFF;\n\t\t\t\t\t\tolen -= 0xFFFF;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tkw->cenc_multikey)\n\t\t\t\t\t\tgf_bs_write_u16(bs, 0);\n\t\t\t\t\tgf_bs_write_u16(bs, clear_size);\n\t\t\t\t\tgf_bs_write_u32(bs, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_bs_get_content(bs, &fake_sai, &sai_size);\n\t\t\tgf_bs_del(bs);\n\t\t\tsai = fake_sai;\n\t\t}\n\t}\n\t//we injected xPS at the beginning of the sample (AVC/HEVC/VVC), we must patch the first subsample\n\t//of SAI data\n\telse if (injected_hdr_size) {\n\t\tu32 offset = 0;\n\t\tu32 first_sub_clear, sub_count_size;\n\t\tu8 *sai_d;\n\t\tu8 key_info_get_iv_size(const u8 *key_info, u32 nb_keys, u32 idx, u8 *const_iv_size, const u8 **const_iv);\n\n\t\tassert(tkw->cenc_subsamples);\n\n\t\t//multi-key skip all IV inits\n\t\tif (tkw->cenc_ki->value.data.ptr[0]) {\n\t\t\tu32 remain;\n\t\t\tu32 j, nb_iv_init = sai[0];\n\t\t\tnb_iv_init <<= 8;\n\t\t\tnb_iv_init |= sai[1];\n\t\t\tu8 *sai_p = sai + 2;\n\t\t\tremain = sai_size-2;\n\n\t\t\tfor (j=0; j<nb_iv_init; j++) {\n\t\t\t\tu32 mk_iv_size;\n\t\t\t\tu32 idx = sai_p[0];\n\t\t\t\tidx<<=8;\n\t\t\t\tidx |= sai_p[1];\n\n\t\t\t\tmk_iv_size = key_info_get_iv_size(tkw->cenc_ki->value.data.ptr, tkw->cenc_ki->value.data.size, idx, NULL, NULL);\n\t\t\t\tmk_iv_size += 2; //idx\n\t\t\t\tif (mk_iv_size > remain) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Invalid multi-key CENC SAI, cannot modify first subsample !\\n\"));\n\t\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t}\n\t\t\t\tsai_p += mk_iv_size;\n\t\t\t\tremain -= mk_iv_size;\n\t\t\t\tif (remain && (remain<=2)) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Invalid multi-key CENC SAI, cannot modify first subsample !\\n\"));\n\t\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t}\n\t\t\t}\n\t\t\toffset = (u32) (sai_p - sai);\n\t\t\tsub_count_size = 4; //32bit sub count\n\n\t\t} else {\n\t\t\toffset = key_info_get_iv_size(tkw->cenc_ki->value.data.ptr, tkw->cenc_ki->value.data.size, 1, NULL, NULL);\n\t\t\tsub_count_size = 2; //16bit sub count\n\t\t}\n\t\tif (sai_size < offset + sub_count_size + 6) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Invalid CENC SAI !\\n\"));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\t//get size of first subsample\n\t\toffset += sub_count_size;\n\t\tsai_d = sai + offset;\n\t\tfirst_sub_clear = sai_d[0];\n\t\tfirst_sub_clear<<=8;\n\t\tfirst_sub_clear |= sai_d[1];\n\t\tfirst_sub_clear += injected_hdr_size;\n\t\t//fits, only patch first subsample size\n\t\tif (first_sub_clear < 0xFFFF) {\n\t\t\tfake_sai = gf_malloc(sizeof(u8) * sai_size);\n\t\t\tif (!fake_sai) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(fake_sai, sai, sizeof(u8) * sai_size);\n\t\t\tsai_d = fake_sai + offset;\n\t\t\tsai_d[0] = (first_sub_clear>>8) & 0xFF;\n\t\t\tsai_d[1] = (first_sub_clear) & 0xFF;\n\t\t\tsai = fake_sai;\n\t\t}\n\t\t//injected header size does not fit in first subsample, add a new subsample\n\t\telse {\n\t\t\tfake_sai = gf_malloc(sizeof(u8) * (sai_size+6));\n\t\t\tif (!fake_sai) return GF_OUT_OF_MEM;\n\t\t\t//copy till start of first subsample (including subsample_count)\n\t\t\tmemcpy(fake_sai, sai, sizeof(u8) * offset);\n\t\t\t//copy all subsamples\n\t\t\tmemcpy(fake_sai+offset+6, sai+offset, sizeof(u8) * (sai_size - offset) );\n\t\t\t//insert subsample\n\t\t\tsai_d = fake_sai + offset;\n\t\t\tsai_d[0] = (injected_hdr_size>>8) & 0xFF;\n\t\t\tsai_d[1] = (injected_hdr_size) & 0xFF;\n\t\t\tsai_d[2] = sai_d[3] = sai_d[4] = sai_d[5] = 0;\n\t\t\t//update subsample count\n\t\t\tsai_d = fake_sai + offset - sub_count_size;\n\t\t\tif (sub_count_size==2) {\n\t\t\t\tu32 cnt = ((u32) sai_d[0]) << 8 | (u32) sai_d[1];\n\t\t\t\tcnt++;\n\t\t\t\tsai_d[0] = (cnt>>8) & 0xFF;\n\t\t\t\tsai_d[1] = (cnt) & 0xFF;\n\t\t\t} else {\n\t\t\t\tu32 cnt = GF_4CC( sai_d[0], sai_d[1], sai_d[2], sai_d[3]);\n\t\t\t\tcnt++;\n\t\t\t\tsai_d[0] = (cnt>>24) & 0xFF;\n\t\t\t\tsai_d[1] = (cnt>>16) & 0xFF;\n\t\t\t\tsai_d[2] = (cnt>>8) & 0xFF;\n\t\t\t\tsai_d[3] = (cnt) & 0xFF;\n\t\t\t}\n\t\t\tsai = fake_sai;\n\t\t\tsai_size += 6;\n\t\t}\n\t}\n\n\tif (act_type==CENC_ADD_FRAG) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (pck_is_encrypted) {\n\t\t\te = gf_isom_fragment_set_cenc_sai(ctx->file, tkw->track_id, sai, sai_size, tkw->cenc_subsamples, ctx->saio32, tkw->cenc_multikey);\n\t\t} else {\n\t\t\te = gf_isom_fragment_set_cenc_sai(ctx->file, tkw->track_id, NULL, 0, GF_FALSE, ctx->saio32, tkw->cenc_multikey);\n\t\t}\n#else\n\t\te = GF_NOT_SUPPORTED;\n#endif\n\t} else {\n\t\tif (sai) {\n\t\t\te = gf_isom_track_cenc_add_sample_info(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_SENC, sai, sai_size, tkw->cenc_subsamples, ctx->saio32, tkw->cenc_multikey);\n\t\t} else if (!pck_is_encrypted) {\n\t\t\te = gf_isom_track_cenc_add_sample_info(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_SENC, NULL, 0, tkw->cenc_subsamples, ctx->saio32, tkw->cenc_multikey);\n\t\t}\n\t}\n\tif (fake_sai) gf_free(fake_sai);\n\treturn e;\n}\n\nGF_FilterSAPType mp4_mux_get_sap(GF_MP4MuxCtx *ctx, GF_FilterPacket *pck)\n{\n\tGF_FilterSAPType sap = gf_filter_pck_get_sap(pck);\n\tif (!sap) return sap;\n\tif (ctx->forcesync) return GF_FILTER_SAP_1;\n\treturn sap;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nGF_Err gf_isom_fragment_add_sample_ex(GF_ISOFile *movie, GF_ISOTrackID TrackID, const GF_ISOSample *sample, u32 DescIndex,\n                                   u32 Duration, u8 PaddingBits, u16 DegradationPriority, Bool redundant_coding, void **ref, u32 ref_offset);\nGF_Err gf_isom_fragment_append_data_ex(GF_ISOFile *movie, GF_ISOTrackID TrackID, u8 *data, u32 data_size, u8 PaddingBits, void **ref, u32 ref_offset);\n#endif\n\nstatic GF_Err mp4_mux_process_sample(GF_MP4MuxCtx *ctx, TrackWriter *tkw, GF_FilterPacket *pck, Bool for_fragment)\n{\n\tGF_Err e=GF_OK;\n\tu64 cts, prev_dts;\n\tu32 prev_size=0;\n\tu32 duration = 0;\n\tu32 timescale = 0;\n\tconst GF_PropertyValue *subs;\n\tGF_FilterSAPType sap_type;\n\tu32 insert_subsample_dsi_size = 0;\n\tu32 first_nal_is_audelim = GF_FALSE;\n\tu32 sample_desc_index = tkw->stsd_idx;\n\tBool sample_timing_ok = GF_TRUE;\n\n\ttimescale = gf_filter_pck_get_timescale(pck);\n\n\tprev_dts = tkw->nb_samples ? tkw->sample.DTS : GF_FILTER_NO_TS;\n\tprev_size = tkw->sample.dataLength;\n\ttkw->sample.CTS_Offset = 0;\n\tif (gf_filter_pck_get_frame_interface(pck)) {\n\t\ttkw->dgl_copy = gf_filter_pck_dangling_copy(pck, tkw->dgl_copy);\n\t\tif (!tkw->dgl_copy) return GF_IO_ERR;\n\t\ttkw->sample.data = (char *)gf_filter_pck_get_data(tkw->dgl_copy, &tkw->sample.dataLength);\n\t} else {\n\t\ttkw->sample.data = (char *)gf_filter_pck_get_data(pck, &tkw->sample.dataLength);\n\t}\n\n\tctx->update_report = GF_TRUE;\n\tctx->total_bytes_in += tkw->sample.dataLength;\n\tctx->total_samples++;\n\n\ttkw->sample.DTS = gf_filter_pck_get_dts(pck);\n\tcts = gf_filter_pck_get_cts(pck);\n\n\tif (tkw->sample.DTS == GF_FILTER_NO_TS) {\n\t\tif (cts == GF_FILTER_NO_TS) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Sample with no DTS/CTS, cannot add (last DTS \"LLU\", last size %d)\\n\", prev_dts, prev_size ));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t} else {\n\t\t\tu32 min_pck_dur = gf_filter_pid_get_min_pck_duration(tkw->ipid);\n\t\t\tif (min_pck_dur) {\n\t\t\t\ttkw->sample.DTS = prev_dts;\n\t\t\t\t//transform back to inpput timescale\n\t\t\t\tif (timescale != tkw->tk_timescale) {\n\t\t\t\t\ttkw->sample.DTS = gf_timestamp_rescale(tkw->sample.DTS, tkw->tk_timescale, timescale);\n\t\t\t\t}\n\t\t\t\ttkw->sample.DTS += min_pck_dur;\n\t\t\t} else {\n\t\t\t\ttkw->sample.DTS = cts;\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttkw->sample.CTS_Offset = (s32) ((s64) cts - (s64) tkw->sample.DTS);\n\t}\n\n\t//do our best to patch init ts if timing config aborted\n\tif (tkw->si_min_ts_plus_one) {\n\t\tu64 si_min_ts = tkw->si_min_ts_plus_one - 1;\n\t\ttkw->si_min_ts_plus_one = 0;\n\t\ttkw->ts_shift = tkw->sample.DTS;\n\t\tmp4_mux_update_init_edit(ctx, tkw, si_min_ts, GF_FALSE);\n\t}\n\t//tkw->ts_shift is in source timescale, apply it before rescaling TSs/duration\n\tif (tkw->ts_shift) {\n\t\tif (ctx->is_rewind) {\n\t\t\tif (tkw->sample.DTS <= tkw->ts_shift) {\n\t\t\t\ttkw->sample.DTS = tkw->ts_shift - tkw->sample.DTS;\n\t\t\t\tcts = tkw->ts_shift - cts;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] broken timing in track, initial ts \"LLU\" less than TS \"LLU\"\\n\", tkw->ts_shift, tkw->sample.DTS));\n\t\t\t\tsample_timing_ok = GF_FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tif (tkw->sample.DTS >= tkw->ts_shift) {\n\t\t\t\ttkw->sample.DTS -= tkw->ts_shift;\n\t\t\t\tcts -= tkw->ts_shift;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] broken timing in track, initial ts \"LLU\" greater than TS \"LLU\"\\n\", tkw->ts_shift, tkw->sample.DTS));\n\t\t\t\tsample_timing_ok = GF_FALSE;\n\t\t\t}\n\t\t}\n\t}\n\n\t//sample-accurate seek info, start logging min CTS of packets marked as non-sync\n\tif (tkw->check_seek_ts && !gf_filter_pck_get_seek_flag(pck)) {\n\t\tu64 ts_check = cts;\n\t\tsubs = gf_filter_pck_get_property(pck, GF_PROP_PCK_SKIP_BEGIN);\n\t\tif (subs)\n\t\t\tts_check += subs->value.uint;\n\n\t\tif (!tkw->min_ts_seek_plus_one) {\n\t\t\ttkw->min_ts_seek_plus_one = ts_check + 1;\n\t\t} else if (tkw->min_ts_seek_plus_one > ts_check + 1) {\n\t\t\ttkw->min_ts_seek_plus_one = ts_check + 1;\n\t\t} else {\n\t\t\t//TS is greater than last non-seek packet TS, we're done seeking\n\t\t\ttkw->check_seek_ts = GF_FALSE;\n\t\t}\n\t}\n\n\tduration = gf_filter_pck_get_duration(pck);\n\tif (timescale != tkw->tk_timescale) {\n\t\ts64 ctso;\n\t\ttkw->sample.DTS = gf_timestamp_rescale(tkw->sample.DTS, timescale, tkw->tk_timescale);\n\n\t\tctso = (s64) tkw->sample.CTS_Offset;\n\t\tctso *= tkw->tk_timescale;\n\t\tctso /= timescale;\n\t\ttkw->sample.CTS_Offset = (s32) ctso;\n\t\tduration *= tkw->tk_timescale;\n\t\tduration /= timescale;\n\n\t\tif (cts != GF_FILTER_NO_TS) {\n\t\t\tcts = gf_timestamp_rescale(cts, timescale, tkw->tk_timescale);\n\t\t}\n\t}\n\n\ttkw->sample.IsRAP = 0;\n\tif (tkw->codecid==GF_CODECID_RAW) {\n\t\tsap_type = GF_FILTER_SAP_1;\n\t} else {\n\t\tsap_type = mp4_mux_get_sap(ctx, pck);\n\n\t\t//if pps inband mode is used, turn sap3 into sap1\n\t\tif ((tkw->xps_inband==XPS_IB_PPS) && sap_type==GF_FILTER_SAP_3)\n\t\t\tsap_type=GF_FILTER_SAP_1;\n\t}\n\tif (sap_type==GF_FILTER_SAP_1)\n\t\ttkw->sample.IsRAP = SAP_TYPE_1;\n\telse if (sap_type==GF_FILTER_SAP_2)\n\t\ttkw->sample.IsRAP = SAP_TYPE_2;\n\telse if ( (sap_type == GF_FILTER_SAP_4) && (tkw->stream_type != GF_STREAM_VISUAL) )\n\t\ttkw->sample.IsRAP = SAP_TYPE_1;\n\n\t/*RFC8216bis is not clear here:\n\t\"if the Partial Segment contains an independent frame.\"\n\t\t-> this would allow SAP1,2,3 (independent being only defined for segments)\n\n\tbut\n\n\t\"Partial Segment containing an independent frame SHOULD carry it to increase the efficiency with which clients can join and switch Renditions\"\n\t\t-> if used for switching, this only allows SAP 1 and 2\n\n\tSpec should be fixed to allow for both cases (fast tune-in or in-segment switching\u00e0)\n\t*/\n\tif ((tkw->sample.IsRAP == SAP_TYPE_1) || (tkw->sample.IsRAP == SAP_TYPE_2))\n\t\tctx->frag_has_intra = GF_TRUE;\n\n\ttkw->sample.DTS += tkw->dts_patch;\n\tif (tkw->nb_samples && (prev_dts >= tkw->sample.DTS) ) {\n\t\t//the fragmented API will patch the duration on the fly\n\t\tif (!for_fragment && ctx->patch_dts) {\n\t\t\tgf_isom_patch_last_sample_duration(ctx->file, tkw->track_num, prev_dts ? prev_dts : 1);\n\t\t}\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] PID %s ID %d Sample %d with DTS \"LLU\" less than previous sample DTS \"LLU\", patching DTS%s\\n\", gf_filter_pid_get_name(tkw->ipid), tkw->track_id, tkw->nb_samples+1, tkw->sample.DTS, prev_dts, ctx->patch_dts ? \"and adjusting prev sample duration\" : \"\" ));\n\t\tsample_timing_ok = GF_FALSE;\n\n\t\tif (prev_dts) {\n\t\t\ttkw->dts_patch = prev_dts - tkw->sample.DTS;\n\t\t\ttkw->sample.DTS += tkw->dts_patch+1; //+1 to avoid 0-dur samples\n\t\t} else {\n\t\t\ttkw->sample.DTS += 1;\n\t\t\tif (tkw->sample.CTS_Offset) tkw->sample.CTS_Offset -= 1;\n\t\t\tduration-=1;\n\t\t}\n\t}\n\n\n\tif (tkw->negctts_shift)\n\t\ttkw->sample.CTS_Offset -= tkw->negctts_shift;\n\n\tif (sample_timing_ok) {\n\t\tif (tkw->probe_min_ctts) {\n\t\t\ts32 diff = (s32) ((s64) cts - (s64) tkw->sample.DTS);\n\t\t\tif (diff < tkw->min_neg_ctts)\n\t\t\t\ttkw->min_neg_ctts = diff;\n\t\t}\n\t\tif (tkw->sample.CTS_Offset) tkw->has_ctts = GF_TRUE;\n\n\t\tif (tkw->sample.CTS_Offset < tkw->min_neg_ctts)\n\t\t\ttkw->min_neg_ctts = tkw->sample.CTS_Offset;\n\t}\n\n\ttkw->sample.nb_pack = 0;\n\tif (tkw->raw_audio_bytes_per_sample) {\n\t\ttkw->sample.nb_pack = tkw->sample.dataLength / tkw->raw_audio_bytes_per_sample;\n\t\tif (tkw->sample.nb_pack) {\n\t\t\tduration = 1;\n\t\t\tif (tkw->raw_samplerate && (tkw->tk_timescale != tkw->raw_samplerate)) {\n\t\t\t\tduration *= tkw->tk_timescale;\n\t\t\t\tduration /= tkw->raw_samplerate;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tkw->cenc_state && tkw->clear_stsd_idx && !gf_filter_pck_get_crypt_flags(pck)) {\n\t\tsample_desc_index = tkw->clear_stsd_idx;\n\t}\n\n\tif (tkw->sparse_inject && (prev_dts!=GF_FILTER_NO_TS) && (tkw->sample.DTS!=GF_FILTER_NO_TS) && tkw->prev_duration) {\n\t\tu64 est_time = prev_dts + tkw->prev_duration;\n\t\tif (est_time < tkw->sample.DTS) {\n\t\t\tu32 ins_dur;\n\t\t\tGF_ISOSample s;\n\t\t\tmemset(&s, 0, sizeof(GF_ISOSample));\n\t\t\ts.DTS = est_time;\n\n\t\t\ts.IsRAP = SAP_TYPE_1;\n\t\t\tins_dur = (u32) (tkw->sample.DTS - est_time);\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\te = gf_isom_fragment_add_sample(ctx->file, tkw->track_id, &s, tkw->stsd_idx, ins_dur, 0, 0, 0);\n#else\n\t\t\t\te = GF_NOT_SUPPORTED;\n#endif\n\t\t\t} else {\n\t\t\t\te = gf_isom_add_sample(ctx->file, tkw->track_num, tkw->stsd_idx, &s);\n\t\t\t\tgf_isom_set_last_sample_duration(ctx->file, tkw->track_num, ins_dur);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tkw->use_dref) {\n\t\tu64 data_offset = gf_filter_pck_get_byte_offset(pck);\n\t\tif (data_offset != GF_FILTER_NO_BO) {\n\t\t\te = gf_isom_add_sample_reference(ctx->file, tkw->track_num, sample_desc_index, &tkw->sample, data_offset);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to add sample DTS \"LLU\" from %s as reference: %s\\n\", tkw->sample.DTS, gf_filter_pid_get_name(tkw->ipid), gf_error_to_string(e) ));\n\t\t\t}\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot add sample reference at DTS \"LLU\" , input sample data is not continous in source\\n\", tkw->sample.DTS ));\n\t\t}\n\t} else if (tkw->nb_frames_per_sample && (tkw->nb_samples % tkw->nb_frames_per_sample)) {\n\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t \te = gf_isom_fragment_append_data(ctx->file, tkw->track_id, tkw->sample.data, tkw->sample.dataLength, 0);\n#else\n\t\t\te = GF_NOT_SUPPORTED;\n#endif\n\t\t} else {\n\t\t\te = gf_isom_append_sample_data(ctx->file, tkw->track_num, tkw->sample.data, tkw->sample.dataLength);\n\t\t}\n\t\ttkw->has_append = GF_TRUE;\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to append sample DTS \"LLU\" data: %s\\n\", tkw->sample.DTS, gf_error_to_string(e) ));\n\t\t}\n\t} else {\n\t\tBool inject_pps = ctx->pps_inband;\n\t\tif (ctx->xps_inband==XPS_IB_AUTO) {\n\t\t\tconst GF_PropertyValue *p = gf_filter_pck_get_property(pck, GF_PROP_PCK_XPS_MASK);\n\t\t\tif (p && (p->value.uint & (1<<2) ) )\n\t\t\t\tinject_pps = GF_TRUE;\n\t\t}\n\n\t\tif ((tkw->sample.IsRAP || tkw->force_inband_inject || inject_pps) && tkw->xps_inband) {\n\t\t\tu8 *inband_xps;\n\t\t\tu32 inband_xps_size;\n\t\t\tchar *au_delim=NULL;\n\t\t\tu32 au_delim_size=0;\n\t\t\tchar *pck_data = tkw->sample.data;\n\t\t\tu32 pck_data_len = tkw->sample.dataLength;\n\t\t\tif (tkw->sample.IsRAP || tkw->force_inband_inject) {\n\t\t\t\tinband_xps = tkw->inband_hdr;\n\t\t\t\tinband_xps_size = tkw->inband_hdr_size;\n\t\t\t\ttkw->force_inband_inject = GF_FALSE;\n\t\t\t} else {\n\t\t\t\tinband_xps = tkw->inband_hdr_non_rap;\n\t\t\t\tinband_xps_size = tkw->inband_hdr_non_rap_size;\n\t\t\t}\n\t\t\ttkw->sample.data = inband_xps;\n\t\t\ttkw->sample.dataLength = inband_xps_size;\n\n\t\t\tif (tkw->is_nalu==NALU_AVC) {\n\t\t\t\tif (pck_data_len >= 2 + tkw->nal_unit_size) {\n\t\t\t\t\tchar *nal = pck_data + tkw->nal_unit_size;\n\t\t\t\t\tif ((nal[0] & 0x1F) == GF_AVC_NALU_ACCESS_UNIT) {\n\t\t\t\t\t\tfirst_nal_is_audelim = au_delim_size = 2 + tkw->nal_unit_size;\n\t\t\t\t\t\tau_delim = pck_data;\n\t\t\t\t\t\tif (au_delim_size >= pck_data_len) au_delim = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (pck_data_len >= 3 + tkw->nal_unit_size) {\n\t\t\t\t\tchar *nal = pck_data + tkw->nal_unit_size;\n\t\t\t\t\tif (((nal[0] & 0x7E)>>1) == GF_HEVC_NALU_ACCESS_UNIT) {\n\t\t\t\t\t\tfirst_nal_is_audelim = au_delim_size = 3 + tkw->nal_unit_size;\n\t\t\t\t\t\tau_delim = pck_data;\n\t\t\t\t\t\tif (au_delim_size >= pck_data_len) au_delim = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (au_delim) {\n\t\t\t\ttkw->sample.data = au_delim;\n\t\t\t\ttkw->sample.dataLength = au_delim_size;\n\t\t\t\tpck_data += au_delim_size;\n\t\t\t\tpck_data_len -= au_delim_size;\n\t\t\t}\n\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\t//force using ref mode\n\t\t\t\tvoid *ref=NULL;\n\t\t\t\te = gf_isom_fragment_add_sample_ex(ctx->file, tkw->track_id, &tkw->sample, sample_desc_index, duration, 0, 0, 0, &ref, 0);\n\t\t\t\tif (!e && au_delim) {\n\t\t\t\t\te = gf_isom_fragment_append_data(ctx->file, tkw->track_id, inband_xps, inband_xps_size, 0);\n\t\t\t\t}\n\t\t\t\tif (!e) {\n\t\t\t\t\tif (gf_filter_pck_is_blocking_ref(pck)) {\n\t\t\t\t\t\te = gf_isom_fragment_append_data(ctx->file, tkw->track_id, pck_data, pck_data_len, 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_filter_pck_ref(&pck);\n\t\t\t\t\t\tGF_FilterPacket *ref = pck;\n\t\t\t\t\t\te = gf_isom_fragment_append_data_ex(ctx->file, tkw->track_id, pck_data, pck_data_len, 0, (void**)&ref, au_delim ? au_delim_size : 0);\n\t\t\t\t\t\tif (!ref) {\n\t\t\t\t\t\t\tgf_list_add(ctx->ref_pcks, pck);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_filter_pck_unref(pck);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n#else\n\t\t\t\te = GF_NOT_SUPPORTED;\n#endif // GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t} else {\n\t\t\t\te = gf_isom_add_sample(ctx->file, tkw->track_num, sample_desc_index, &tkw->sample);\n\t\t\t\tif (au_delim && !e) {\n\t\t\t\t\te = gf_isom_append_sample_data(ctx->file, tkw->track_num, inband_xps, inband_xps_size);\n\t\t\t\t}\n\t\t\t\tif (!e) e = gf_isom_append_sample_data(ctx->file, tkw->track_num, pck_data, pck_data_len);\n\t\t\t}\n\t\t\tinsert_subsample_dsi_size = inband_xps_size;\n\t\t} else if (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (gf_filter_pck_is_blocking_ref(pck)) {\n\t\t\t\te = gf_isom_fragment_add_sample(ctx->file, tkw->track_id, &tkw->sample, sample_desc_index, duration, 0, 0, 0);\n\t\t\t} else {\n\t\t\t\tgf_filter_pck_ref(&pck);\n\t\t\t\tGF_FilterPacket *ref = pck;\n\t\t\t\te = gf_isom_fragment_add_sample_ex(ctx->file, tkw->track_id, &tkw->sample, sample_desc_index, duration, 0, 0, 0, (void**) &ref, 0);\n\t\t\t\tif (!ref) {\n\t\t\t\t\tgf_list_add(ctx->ref_pcks, pck);\n\t\t\t\t} else {\n\t\t\t\t\tgf_filter_pck_unref(pck);\n\t\t\t\t}\n\t\t\t}\n#else\n\t\t\te = GF_NOT_SUPPORTED;\n#endif // GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t} else {\n\t\t\te = gf_isom_add_sample(ctx->file, tkw->track_num, sample_desc_index, &tkw->sample);\n\t\t\tif (!e && !duration) {\n\t\t\t\tgf_isom_set_last_sample_duration(ctx->file, tkw->track_num, 0);\n\t\t\t}\n\t\t}\n\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to add sample DTS \"LLU\" from %s - prev DTS \"LLU\": %s\\n\", tkw->sample.DTS, gf_filter_pid_get_name(tkw->ipid), prev_dts, gf_error_to_string(e) ));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MP4Mux] added sample DTS \"LLU\" - prev DTS \"LLU\" - prev size %d\\n\", tkw->sample.DTS, prev_dts, prev_size));\n\t\t}\n\n\t\tif (!e && tkw->cenc_state) {\n\t\t\te = mp4_mux_cenc_update(ctx, tkw, pck, for_fragment ? CENC_ADD_FRAG : CENC_ADD_NORMAL, tkw->sample.dataLength, insert_subsample_dsi_size);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set sample CENC information: %s\\n\", gf_error_to_string(e) ));\n\t\t\t}\n\t\t}\n\t}\n\n\ttkw->nb_samples++;\n\ttkw->samples_in_stsd++;\n\ttkw->samples_in_frag++;\n\n\tif (e) return e;\n\n\tif (!for_fragment && sample_timing_ok) {\n\t\tu64 samp_cts;\n\t\tif (!tkw->clamp_ts_plus_one) {\n\t\t\tconst GF_PropertyValue *skp = gf_filter_pck_get_property(pck, GF_PROP_PCK_SKIP_PRES);\n\t\t\tif (skp && skp->value.boolean) {\n\t\t\t\ttkw->clamp_ts_plus_one = 1 + tkw->sample.DTS + tkw->sample.CTS_Offset;\n\t\t\t}\n\t\t}\n\t\t//store min max cts for edit list updates\n\t\tsamp_cts = tkw->sample.DTS + tkw->sample.CTS_Offset;\n\t\tif (!tkw->clamp_ts_plus_one || (samp_cts + 1 < tkw->clamp_ts_plus_one)) {\n\t\t\tif (samp_cts > tkw->max_cts) {\n\t\t\t\ttkw->max_cts = samp_cts;\n\t\t\t\ttkw->max_cts_samp_dur = duration;\n\t\t\t}\n\n\t\t\tif (tkw->min_cts > samp_cts)\n\t\t\t\ttkw->min_cts = samp_cts;\n\t\t}\n\t}\n\n\t//compat with old arch: write sample to group info for all samples\n\tif ((sap_type==3) || tkw->has_open_gop)  {\n\t\tif (!ctx->norap) {\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\te = gf_isom_fragment_set_sample_rap_group(ctx->file, tkw->track_id, tkw->samples_in_frag, (sap_type==3) ? GF_TRUE : GF_FALSE, 0);\n#else\n\t\t\t\te = GF_NOT_SUPPORTED;\n#endif\n\t\t\t} else if (sap_type==3) {\n\t\t\t\te = gf_isom_set_sample_rap_group(ctx->file, tkw->track_num, tkw->nb_samples, GF_TRUE /*(sap_type==3) ? GF_TRUE : GF_FALSE*/, 0);\n\t\t\t}\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set sample DTS \"LLU\" SAP 3 in RAP group: %s\\n\", tkw->sample.DTS, gf_error_to_string(e) ));\n\t\t\t}\n\t\t}\n\t\ttkw->has_open_gop = GF_TRUE;\n\t}\n\tif (!ctx->noroll) {\n\t\tif ((sap_type==GF_FILTER_SAP_4) || (sap_type==GF_FILTER_SAP_4_PROL) || tkw->gdr_type) {\n\t\t\tGF_ISOSampleRollType roll_type = 0;\n\t\t\ts16 roll = gf_filter_pck_get_roll_info(pck);\n\t\t\tif (sap_type==GF_FILTER_SAP_4) roll_type = GF_ISOM_SAMPLE_ROLL;\n\t\t\telse if (sap_type==GF_FILTER_SAP_4_PROL) roll_type = GF_ISOM_SAMPLE_PREROLL;\n\t\t\telse if (tkw->gdr_type==GF_FILTER_SAP_4_PROL) {\n\t\t\t\troll_type = GF_ISOM_SAMPLE_PREROLL_NONE;\n\t\t\t}\n\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\te = gf_isom_fragment_set_sample_roll_group(ctx->file, tkw->track_id, tkw->samples_in_frag, roll_type, roll);\n#else\n\t\t\t\te = GF_NOT_SUPPORTED;\n#endif\n\t\t\t} else {\n\t\t\t\te = gf_isom_set_sample_roll_group(ctx->file, tkw->track_num, tkw->nb_samples, roll_type, roll);\n\t\t\t}\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set sample DTS \"LLU\" SAP 4 roll %s in roll group: %s\\n\", tkw->sample.DTS, roll, gf_error_to_string(e) ));\n\t\t\t}\n\t\t\tif (sap_type && !tkw->gdr_type)\n\t\t\t\ttkw->gdr_type = sap_type;\n\t\t}\n\t}\n\t\n\tsubs = gf_filter_pck_get_property(pck, GF_PROP_PCK_SUBS);\n\tif (subs) {\n\t\t//if no AUDelim nal and inband header injection, push new subsample\n\t\tif (!first_nal_is_audelim && insert_subsample_dsi_size) {\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\tgf_isom_fragment_add_subsample(ctx->file, tkw->track_id, 0, insert_subsample_dsi_size, 0, 0, 0);\n#endif\n\t\t\t} else {\n\t\t\t\tgf_isom_add_subsample(ctx->file, tkw->track_num, tkw->nb_samples, 0, insert_subsample_dsi_size, 0, 0, 0);\n\t\t\t}\n\t\t\tinsert_subsample_dsi_size = 0;\n\t\t}\n\t\ttkw->has_subs = GF_TRUE;\n\n\t\tif (!ctx->bs_r) ctx->bs_r = gf_bs_new(subs->value.data.ptr, subs->value.data.size, GF_BITSTREAM_READ);\n\t\telse gf_bs_reassign_buffer(ctx->bs_r, subs->value.data.ptr, subs->value.data.size);\n\n\t\twhile (gf_bs_available(ctx->bs_r)) {\n\t\t\tu32 flags = gf_bs_read_u32(ctx->bs_r);\n\t\t\tu32 subs_size = gf_bs_read_u32(ctx->bs_r);\n\t\t\tu32 reserved = gf_bs_read_u32(ctx->bs_r);\n\t\t\tu8 priority = gf_bs_read_u8(ctx->bs_r);\n\t\t\tu8 discardable = gf_bs_read_u8(ctx->bs_r);\n\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\tgf_isom_fragment_add_subsample(ctx->file, tkw->track_id, flags, subs_size, priority, reserved, discardable);\n#endif\n\t\t\t} else {\n\t\t\t\tgf_isom_add_subsample(ctx->file, tkw->track_num, tkw->nb_samples, flags, subs_size, priority, reserved, discardable);\n\t\t\t}\n\n\t\t\t//we have AUDelim nal and inband header injection, push new subsample for inband header once we have pushed the first subsample (au delim)\n\t\t\tif (insert_subsample_dsi_size) {\n\t\t\t\tif (first_nal_is_audelim != subs_size) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] inserting inband param after AU delimiter NALU, but sample has subsample information not aligned on NALU (got %d subsample size but expecting %d) - file might be broken!\\n\", subs_size, first_nal_is_audelim));\n\t\t\t\t}\n\t\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\t\tgf_isom_fragment_add_subsample(ctx->file, tkw->track_id, 0, insert_subsample_dsi_size, 0, 0, 0);\n#endif\n\t\t\t\t} else {\n\t\t\t\t\tgf_isom_add_subsample(ctx->file, tkw->track_num, tkw->nb_samples, 0, insert_subsample_dsi_size, 0, 0, 0);\n\t\t\t\t}\n\t\t\t\tinsert_subsample_dsi_size = GF_FALSE;\n\t\t\t}\n\t\t}\n\t} else if (for_fragment && tkw->has_subs && ctx->cmaf && (tkw->codecid==GF_CODECID_SUBS_XML)) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t//tentative implemntation of CMAF 7.5.20 which is just nonsense text !!:\n\t\t//\"the value of subsample_count shall equal 1 for the first image sub-sample, and the subsample_count of the TTML document shall equal 0.\"\n\t\t//\n\t\t//we simply signal a single subsample\n\t\tgf_isom_fragment_add_subsample(ctx->file, tkw->track_id, 0, tkw->sample.dataLength, 0, 0, 0);\n#endif\n\t}\n\n\tif (ctx->deps) {\n\t\tu8 dep_flags = gf_filter_pck_get_dependency_flags(pck);\n\t\tif (dep_flags) {\n\t\t\tu32 is_leading = (dep_flags>>6) & 0x3;\n\t\t\tu32 depends_on = (dep_flags>>4) & 0x3;\n\t\t\tu32 depended_on = (dep_flags>>2) & 0x3;\n\t\t\tu32 redundant = (dep_flags) & 0x3;\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\tgf_isom_fragment_set_sample_flags(ctx->file, tkw->track_id, is_leading, depends_on, depended_on, redundant);\n#endif\n\t\t\t} else {\n\t\t\t\tgf_isom_set_sample_flags(ctx->file, tkw->track_num, tkw->nb_samples, is_leading, depends_on, depended_on, redundant);\n\t\t\t}\n\t\t}\n\t}\n\n\tu32 idx = 0;\n\twhile (1) {\n\t\tBool is_sample_group=GF_FALSE;\n\t\tu32 aux_type=0, aux_info=0, sg_flags=0;\n\t\tu32 p4cc;\n\t\tconst char *pname=NULL;\n\t\tconst GF_PropertyValue *p = gf_filter_pck_enum_properties(pck, &idx, &p4cc, &pname);\n\t\tif (!p) break;\n\t\tif ((p->type!=GF_PROP_DATA) && (p->type!=GF_PROP_CONST_DATA)) continue;\n\t\tif (!p->value.data.size || !p->value.data.ptr) continue;\n\t\tif (!pname) continue;\n\n\t\tif (!strncmp(pname, \"sai_\", 4)) {\n\n\t\t} else if (!strncmp(pname, \"grp_\", 4)) {\n\t\t\t//discard emsg if fragmented, otherwise add as internal sample group - TODO, support for EventMessage tracks\n\t\t\tif (!strcmp(pname, \"grp_EMSG\") && (ctx->store>=MP4MX_MODE_FRAG)) continue;\n\t\t\tis_sample_group = GF_TRUE;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\tpname+=4;\n\t\tu32 plen = (u32) strlen(pname);\n\t\tif (plen==3) {\n\t\t\taux_type = GF_4CC(pname[0], pname[1], pname[2], ' ');\n\t\t\tpname+=3;\n\t\t} else if (plen >= 4) {\n\t\t\taux_type = GF_4CC(pname[0], pname[1], pname[2], pname[3]);\n\t\t\tpname+=4;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tif (pname[0] == '_') {\n\t\t\tif (is_sample_group) {\n\t\t\t\tchar *flags = strstr(pname, \"_z\");\n\t\t\t\tif (flags) flags[0]=0;\n\t\t\t\tif (pname[0]) aux_info = atoi(pname);\n\t\t\t\tif (flags) {\n\t\t\t\t\tsscanf(flags+2, \"%x\", &sg_flags);\n\t\t\t\t\tflags[0]='_';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taux_info = atoi(pname);\n\t\t\t}\n\t\t}\n\t\tif (!aux_type) continue;\n\n\t\tif (is_sample_group) {\n\t\t\tif (aux_type==GF_ISOM_SAMPLE_GROUP_ESGH) {\n\t\t\t\tGF_Err gf_isom_set_sample_description_restricted(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescIndex, u32 scheme_type);\n\t\t\t\tgf_isom_set_sample_description_restricted(ctx->file, tkw->track_num, tkw->stsd_idx, GF_4CC( 'e', 's', 's', 'g'));\n\n\t\t\t\tsg_flags |= 0x40000000;\n\t\t\t}\n\n\t\t\tgf_isom_set_sample_group_description(ctx->file, tkw->track_num, for_fragment ? 0 : tkw->nb_samples, aux_type, aux_info, p->value.data.ptr, p->value.data.size, sg_flags);\n\n\t\t} else {\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\tgf_isom_fragment_set_sample_aux_info(ctx->file, tkw->track_id, tkw->samples_in_frag, aux_type, aux_info, p->value.data.ptr, p->value.data.size);\n#endif\n\t\t\t} else {\n\t\t\t\tgf_isom_add_sample_aux_info(ctx->file, tkw->track_num, tkw->nb_samples, aux_type, aux_info, p->value.data.ptr, p->value.data.size);\n\t\t\t}\n\t\t}\n\t}\n\n\ttkw->prev_duration = duration;\n\tif (duration && !for_fragment && !tkw->raw_audio_bytes_per_sample)\n\t\tgf_isom_set_last_sample_duration(ctx->file, tkw->track_num, duration);\n\n\tif (ctx->dur.num) {\n\t\tBool abort = GF_FALSE;\n\t\tif (ctx->dur.num>0) {\n\t\t\tu64 mdur = gf_isom_get_media_duration(ctx->file, tkw->track_num);\n\n\t\t\t/*patch to align to old arch */\n\t\t\tif (gf_sys_old_arch_compat()) {\n\t\t\t\tif (tkw->stream_type==GF_STREAM_VISUAL) {\n\t\t\t\t\tmdur = tkw->sample.DTS;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//adjust if shift is below half sec (to take AV delay into account)\n\t\t\t//if larger, we imported from non-0 initial ts, do not compensate\n\t\t\telse if (tkw->ts_shift<tkw->tk_timescale/2) {\n\t\t\t\tmdur += tkw->ts_shift;\n\t\t\t}\n\n\t\t\tif (ctx->importer) {\n\t\t\t\ttkw->prog_done = mdur * ctx->dur.den;\n\t\t\t\ttkw->prog_total =  ((u64)tkw->tk_timescale) * ctx->dur.num;\n\t\t\t}\n\n\t\t\t/*patch to align to old arch */\n\t\t\tif (gf_sys_old_arch_compat()) {\n\t\t\t\tif (gf_timestamp_greater(mdur, tkw->tk_timescale, ctx->dur.num, ctx->dur.den))\n\t\t\t\t\tabort = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tif (gf_timestamp_greater_or_equal(mdur, tkw->tk_timescale, ctx->dur.num, ctx->dur.den))\n\t\t\t\t\tabort = GF_TRUE;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((s32) tkw->nb_samples >= -ctx->dur.num)\n\t\t\t\tabort = GF_TRUE;\n\t\t}\n\n\t\tif (abort) {\n\t\t\tGF_FilterEvent evt;\n\t\t\tGF_FEVT_INIT(evt, GF_FEVT_STOP, tkw->ipid);\n\t\t\tgf_filter_pid_send_event(tkw->ipid, &evt);\n\n\t\t\ttkw->aborted = GF_TRUE;\n\t\t}\n\t} else if (ctx->importer) {\n\t\tif (tkw->nb_frames) {\n\t\t\ttkw->prog_done = tkw->nb_samples + tkw->frame_offset;\n\t\t\ttkw->prog_total = tkw->nb_frames;\n\t\t} else {\n\t\t\tu64 data_offset = gf_filter_pck_get_byte_offset(pck);\n\t\t\tif (data_offset == GF_FILTER_NO_BO) {\n\t\t\t\tdata_offset = tkw->down_bytes;\n\t\t\t}\n\t\t\tif ((data_offset != GF_FILTER_NO_BO) && tkw->down_size) {\n\t\t\t\ttkw->prog_done = data_offset;\n\t\t\t\ttkw->prog_total = tkw->down_size;\n\t\t\t} else {\n\t\t\t\tif (tkw->pid_dur.den && tkw->pid_dur.num) {\n\t\t\t\t\ttkw->prog_done = tkw->sample.DTS * tkw->pid_dur.den;\n\t\t\t\t\ttkw->prog_total = tkw->pid_dur.num * tkw->tk_timescale;\n\t\t\t\t} else {\n\t\t\t\t\ttkw->prog_done = 0;\n\t\t\t\t\ttkw->prog_total = 1;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err mp4_mux_process_item(GF_MP4MuxCtx *ctx, TrackWriter *tkw, GF_FilterPacket *pck)\n{\n\tGF_Err e;\n\tu32 meta_type, item_id, size, item_type, nb_items, media_brand = GF_ISOM_BRAND_HEIF;\n\tGF_ImageItemProperties image_props;\n\tGF_ImageItemProtection cenc_info;\n\tconst char *data, *item_name=NULL;\n\tconst GF_PropertyValue *p, *dsi, *dsi_enh;\n\tGF_Box *config_box = NULL;\n\n\n\tif (ctx->init_movie_done) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot add item to a finalized movie, not supported\\n\"));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tif (tkw->stream_type != GF_STREAM_VISUAL) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot add item other than visual, not supported - use MP4Box for this\\n\"));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tctx->update_report = GF_TRUE;\n\n\tmeta_type = gf_isom_get_meta_type(ctx->file, GF_TRUE, 0);\n\tif (!meta_type) {\n\t\te = gf_isom_set_meta_type(ctx->file, GF_TRUE, 0, GF_META_ITEM_TYPE_PICT);\n\t} else if (meta_type != GF_META_ITEM_TYPE_PICT) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] File already has a root 'meta' box of type %s\\n\", gf_4cc_to_str(meta_type)));\n\t\te= GF_BAD_PARAM;\n\t} else {\n\t\te = GF_OK;\n\t}\n\tif (e) return e;\n\n\tdata = (char *)gf_filter_pck_get_data(pck, &size);\n\tif (!data) {\n\t\tif (gf_filter_pck_get_frame_interface(pck)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot add items from raw decoder outputs, not supported\\n\"));\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tctx->total_bytes_in += size;\n\tctx->total_samples++;\n\n\n\titem_id = 0;\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ITEM_ID);\n\tif (p) item_id = p->value.uint;\n\n\titem_name = \"Image\";\n\tp = gf_filter_pid_get_property_str(tkw->ipid, \"meta:name\");\n\tif (p && p->value.string) item_name = p->value.string;\n\n\tmemset(&image_props, 0, sizeof(GF_ImageItemProperties));\n\n\tdsi = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DECODER_CONFIG);\n\tdsi_enh = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT);\n\tBool free_config_ba = GF_FALSE;\n\n\tswitch (tkw->codecid) {\n\tcase GF_CODECID_AVC:\n\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\tif (!dsi) return GF_OK;\n\n\t\tif (tkw->codecid==GF_CODECID_AVC) {\n\t\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_AVCC);\n\t\t\titem_type = GF_ISOM_SUBTYPE_AVC_H264;\n\t\t} else if (tkw->codecid==GF_CODECID_MVC) {\n\t\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_MVCC);\n\t\t\titem_type = GF_ISOM_SUBTYPE_MVC_H264;\n\t\t\tif (dsi_enh) dsi = dsi_enh;\n\t\t} else {\n\t\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_SVCC);\n\t\t\titem_type = GF_ISOM_SUBTYPE_SVC_H264;\n\t\t\tif (dsi_enh) dsi = dsi_enh;\n\t\t}\n\n\t\t((GF_AVCConfigurationBox *)config_box)->config = gf_odf_avc_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\t\tif (! ((GF_AVCConfigurationBox *)config_box)->config) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\timage_props.num_channels = 3;\n\t\timage_props.bits_per_channel[0] = ((GF_AVCConfigurationBox *)config_box)->config->luma_bit_depth;\n\t\timage_props.bits_per_channel[1] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\timage_props.bits_per_channel[2] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tmedia_brand = GF_ISOM_BRAND_AVCI;\n\t\tbreak;\n\n\tcase GF_CODECID_HEVC:\n\tcase GF_CODECID_HEVC_TILES:\n\tcase GF_CODECID_LHVC:\n\t\tif (tkw->codecid == GF_CODECID_LHVC) {\n\t\t\tif (dsi_enh) dsi = dsi_enh;\n\t\t\tif (!dsi) return GF_OK;\n\t\t}\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_HVCC);\n\n\t\tif (dsi_enh) {\n\t\t\t((GF_HEVCConfigurationBox *)config_box)->config = gf_odf_hevc_cfg_read(dsi->value.data.ptr, dsi->value.data.size, GF_TRUE);\n\t\t\titem_type = GF_ISOM_SUBTYPE_LHV1;\n\t\t} else {\n\t\t\tif ((tkw->codecid == GF_CODECID_HEVC) && !dsi) return GF_OK;\n\n\t\t\t((GF_HEVCConfigurationBox *)config_box)->config = gf_odf_hevc_cfg_read(dsi->value.data.ptr, dsi->value.data.size, GF_FALSE);\n\t\t\titem_type = (tkw->codecid == GF_CODECID_HEVC_TILES) ? GF_ISOM_SUBTYPE_HVT1 : GF_ISOM_SUBTYPE_HVC1;\n\t\t}\n\t\tif (! ((GF_HEVCConfigurationBox *)config_box)->config) {\n\t\t\tif ((tkw->codecid != GF_CODECID_HEVC_TILES) && !dsi) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t} else {\n\t\t\timage_props.num_channels = 3;\n\t\t\timage_props.bits_per_channel[0] = ((GF_HEVCConfigurationBox *)config_box)->config->luma_bit_depth;\n\t\t\timage_props.bits_per_channel[1] = ((GF_HEVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\t\timage_props.bits_per_channel[2] = ((GF_HEVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\t}\n\t\tmedia_brand = GF_ISOM_BRAND_HEIC;\n\t\tif (tkw->codecid==GF_CODECID_LHVC) {\n\t\t\tmedia_brand = GF_ISOM_BRAND_HEIM;\n\t\t}\n\t\tbreak;\n\tcase GF_CODECID_AV1:\n\t\tif (!dsi) return GF_OK;\n\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_AV1C);\n\t\t((GF_AV1ConfigurationBox *)config_box)->config = gf_odf_av1_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\n\t\tif (! ((GF_AV1ConfigurationBox *)config_box)->config) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\titem_type = GF_ISOM_SUBTYPE_AV01;\n\t\tu8 depth = ((GF_AV1ConfigurationBox *)config_box)->config->high_bitdepth ? (((GF_AV1ConfigurationBox *)config_box)->config->twelve_bit ? 12 : 10 ) : 8;\n\t\tif (((GF_AV1ConfigurationBox *)config_box)->config->monochrome) {\n\t\t\timage_props.num_channels = 1;\n\t\t\timage_props.bits_per_channel[0] = depth;\n\t\t\timage_props.bits_per_channel[1] = 0;\n\t\t\timage_props.bits_per_channel[2] = 0;\n\t\t} else {\n\t\t\timage_props.num_channels = 3;\n\t\t\timage_props.bits_per_channel[0] = depth;\n\t\t\timage_props.bits_per_channel[1] = depth;\n\t\t\timage_props.bits_per_channel[2] = depth;\n\t\t}\n\t\tmedia_brand = GF_ISOM_BRAND_AVIF;\n\t\tbreak;\n\tcase GF_CODECID_JPEG:\n\t\titem_type = GF_ISOM_SUBTYPE_JPEG;\n\t\tmedia_brand = GF_ISOM_SUBTYPE_JPEG /* == GF_4CC('j', 'p', 'e', 'g') */;\n\t\tbreak;\n\tcase GF_CODECID_J2K:\n\t\titem_type = GF_ISOM_SUBTYPE_JP2K;\n\t\tmedia_brand = GF_4CC('j', '2', 'k', 'i');\n\t\tbreak;\n\tcase GF_CODECID_PNG:\n\t\titem_type = GF_ISOM_SUBTYPE_PNG;\n\t\t//not defined !\n\t\tmedia_brand = GF_ISOM_SUBTYPE_PNG /* == GF_4CC('j', 'p', 'e', 'g') */;\n\t\tbreak;\n\n\tcase GF_CODECID_VVC:\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_VVCC);\n\n\t\tif ((tkw->codecid == GF_CODECID_VVC) && !dsi) return GF_OK;\n\n\t\t((GF_VVCConfigurationBox *)config_box)->config = gf_odf_vvc_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\t\titem_type = GF_ISOM_SUBTYPE_VVC1;\n\n\t\tif (! ((GF_VVCConfigurationBox *)config_box)->config) {\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t} else {\n\t\t\timage_props.num_channels = 3;\n\t\t\timage_props.bits_per_channel[0] = ((GF_VVCConfigurationBox *)config_box)->config->bit_depth;\n\t\t\timage_props.bits_per_channel[1] = ((GF_VVCConfigurationBox *)config_box)->config->bit_depth;\n\t\t\timage_props.bits_per_channel[2] = ((GF_VVCConfigurationBox *)config_box)->config->bit_depth;\n\t\t}\n\t\tmedia_brand = GF_ISOM_BRAND_VVIC;\n\t\tbreak;\n\tcase GF_CODECID_RAW:\n\tcase GF_CODECID_RAW_UNCV:\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_PIXFMT);\n\t\tif (p && (p->value.uint==GF_PIXEL_UNCV)) {\n\t\t\timage_props.config_ba = dsi->value.data.ptr;\n\t\t\timage_props.config_ba_size = dsi->value.data.size;\n\t\t\titem_type = GF_4CC('u','n','c','i');\n\t\t\tbreak;\n\t\t} else {\n\t\t\tif (gf_pixel_fmt_get_uncc(p->value.uint, ctx->uncv-1, &image_props.config_ba, &image_props.config_ba_size)==GF_TRUE) {\n\t\t\t\tfree_config_ba = GF_TRUE;\n\t\t\t\titem_type = GF_4CC('u','n','c','i');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tdefault:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error: Codec %s not supported to create HEIF image items\\n\", gf_codecid_name(tkw->codecid) ));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_WIDTH);\n\tif (p) image_props.width = p->value.uint;\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_HEIGHT);\n\tif (p) image_props.height = p->value.uint;\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ALPHA);\n\tif (p) image_props.alpha = p->value.boolean;\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_SAR);\n\tif (p) {\n\t\timage_props.hSpacing = p->value.frac.num;\n\t\timage_props.vSpacing = p->value.frac.den;\n\t} else {\n\t\timage_props.hSpacing = image_props.vSpacing = 1;\n\t}\n\timage_props.config = config_box;\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_HIDDEN);\n\tif (p) image_props.hidden = p->value.boolean;\n\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_MIRROR);\n\tif (p && p->value.uint) image_props.mirror = p->value.uint;\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ROTATE);\n\tif (p) image_props.angle = p->value.uint;\n\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CLAP_W);\n\tif (p) { image_props.clap_wnum = p->value.frac.num; image_props.clap_wden = p->value.frac.den; }\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CLAP_H);\n\tif (p) { image_props.clap_hnum = p->value.frac.num; image_props.clap_hden = p->value.frac.den; }\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CLAP_X);\n\tif (p) { image_props.clap_honum = p->value.frac.num; image_props.clap_hoden = p->value.frac.den; }\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CLAP_Y);\n\tif (p) { image_props.clap_vonum = p->value.frac.num; image_props.clap_voden = p->value.frac.den; }\n\n\tp = gf_filter_pck_get_property_str(pck, \"grp_ilce\");\n\tif (p && ((p->type==GF_PROP_DATA)||(p->type==GF_PROP_CONST_DATA)) && p->value.data.ptr) {\n\t\timage_props.interlace_type = p->value.data.ptr[0];\n\t}\n\n\t//setup crypto\n\tif (tkw->is_encrypted && gf_filter_pck_get_crypt_flags(pck)) {\n\t\tmemset(&cenc_info, 0, sizeof(GF_ImageItemProtection));\n\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_CENC_SAI);\n\t\tif (!p) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error: Missing CENC SAI on protected packet\\n\"));\n\t\t\tif (config_box) gf_isom_box_del(config_box);\n\t\t\tif (free_config_ba) gf_free(image_props.config_ba);\n\t\t\treturn GF_SERVICE_ERROR;\n\t\t}\n\t\tcenc_info.sai_data = p->value.data.ptr;\n\t\tcenc_info.sai_data_size = p->value.data.size;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_PROTECTION_SCHEME_TYPE);\n\t\tif (!p) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error: Missing CENC scheme type on protected item\\n\"));\n\t\t\tif (config_box) gf_isom_box_del(config_box);\n\t\t\tif (free_config_ba) gf_free(image_props.config_ba);\n\t\t\treturn GF_SERVICE_ERROR;\n\t\t}\n\t\tcenc_info.scheme_type = p->value.uint;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_PROTECTION_SCHEME_VERSION);\n\t\tif (!p) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error: Missing CENC scheme version on protected item\\n\"));\n\t\t\tif (config_box) gf_isom_box_del(config_box);\n\t\t\tif (free_config_ba) gf_free(image_props.config_ba);\n\t\t\treturn GF_SERVICE_ERROR;\n\t\t}\n\t\tcenc_info.scheme_version = p->value.uint;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CENC_KEY_INFO);\n\t\tif (!p || (p->type != GF_PROP_DATA) || !gf_cenc_validate_key_info(p->value.data.ptr, p->value.data.size)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error: %s CENC Key info on protected item\\n\", p ? \"Corrupted\" : \"Missing\"));\n\t\t\tif (config_box) gf_isom_box_del(config_box);\n\t\t\tif (free_config_ba) gf_free(image_props.config_ba);\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tcenc_info.key_info = p->value.data.ptr;\n\t\tcenc_info.key_info_size = p->value.data.size;\n\n\t\timage_props.cenc_info = &cenc_info;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CENC_PATTERN);\n\t\tif (p) {\n\t\t\tcenc_info.skip_byte_block = p->value.frac.num;\n\t\t\tcenc_info.crypt_byte_block = p->value.frac.den;\n\t\t}\n\n\n\t\tif (tkw->insert_pssh) {\n\t\t\tmp4_mux_cenc_insert_pssh(ctx, tkw, NULL, 0);\n\t\t\ttkw->insert_pssh = GF_FALSE;\n\t\t}\n\t}\n\n\tnb_items = gf_isom_get_meta_item_count(ctx->file, GF_TRUE, 0);\n\n\te = gf_isom_add_meta_item_memory(ctx->file, GF_TRUE, 0, item_name, &item_id, item_type, NULL, NULL, &image_props, (u8 *)data, size, NULL);\n\n\tif (config_box) gf_isom_box_del(config_box);\n\tif (free_config_ba) gf_free(image_props.config_ba);\n\n\tif (e) return e;\n\n\n\t//retrieve the final itemID\n\tgf_isom_get_meta_item_info(ctx->file, GF_TRUE, 0, nb_items+1, &item_id, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);\n\ttkw->item_id = item_id;\n\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_PRIMARY_ITEM);\n\tif (p && p->value.boolean) {\n\t\te = gf_isom_set_meta_primary_item(ctx->file, GF_TRUE, 0, item_id);\n\t\tif (e) return e;\n\t}\n\t//if primary item is not set, assign one\n\telse if (! gf_isom_get_meta_primary_item_id(ctx->file, GF_TRUE, 0)) {\n\t\te = gf_isom_set_meta_primary_item(ctx->file, GF_TRUE, 0, item_id);\n\t\tif (e) return e;\n\t}\n\n\tif (!ctx->major_brand_set) {\n\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_MIF1, 0);\n\t\tgf_isom_reset_alt_brands(ctx->file);\n\t\tctx->major_brand_set = 2;\n\t}\n\tif (media_brand && (ctx->major_brand_set==2)) {\n\t\tgf_isom_modify_alternate_brand(ctx->file, media_brand, 1);\n\t}\n#if 0\n\tif (e == GF_OK && meta->ref_type) {\n\t\te = gf_isom_meta_add_item_ref(file, meta->root_meta, tk, meta->item_id, meta->ref_item_id, meta->ref_type, NULL);\n\t}\n#endif\n\treturn GF_OK;\n}\n\nstatic void mp4mux_send_output(GF_MP4MuxCtx *ctx)\n{\n\tif (ctx->dst_pck) {\n\t\tif (ctx->notify_filename) {\n\t\t\tgf_filter_pck_set_framing(ctx->dst_pck, GF_TRUE, GF_FALSE);\n\t\t\tgf_filter_pck_set_property(ctx->dst_pck, GF_PROP_PCK_FILENUM, &PROP_UINT(ctx->cur_file_idx_plus_one-1) );\n\t\t\tif (ctx->cur_file_suffix) {\n\t\t\t\tgf_filter_pck_set_property(ctx->dst_pck, GF_PROP_PCK_FILESUF, &PROP_STRING_NO_COPY(ctx->cur_file_suffix) );\n\t\t\t\tctx->cur_file_suffix = NULL;\n\t\t\t}\n\t\t\tctx->notify_filename = 0;\n\t\t}\n\t\tgf_filter_pck_send(ctx->dst_pck);\n\t\tctx->dst_pck = NULL;\n\t}\n}\n\nstatic void mp4_mux_flush_frag_hls(GF_MP4MuxCtx *ctx)\n{\n\tGF_FilterEvent evt;\n\tTrackWriter *tkw = NULL;\n\n\t//send event on first track only\n\ttkw = gf_list_get(ctx->tracks, 0);\n\tGF_FEVT_INIT(evt, GF_FEVT_FRAGMENT_SIZE, tkw->ipid);\n\tevt.frag_size.is_last = ctx->flush_seg ? GF_TRUE : GF_FALSE;\n\tevt.frag_size.offset = ctx->frag_offset;\n\tevt.frag_size.size = ctx->frag_size;\n\tevt.frag_size.duration.num = (s64) ctx->frag_duration;\n\tevt.frag_size.duration.den = ctx->frag_timescale;\n\tevt.frag_size.independent = ctx->frag_has_intra;\n\n\tgf_filter_pid_send_event(tkw->ipid, &evt);\n\n\tctx->frag_offset += ctx->frag_size;\n\tctx->frag_size = 0;\n\tctx->frag_duration = 0;\n\tctx->frag_has_intra = GF_FALSE;\n}\n\nstatic GF_Err mp4_mux_on_data(void *cbk, u8 *data, u32 block_size, void *cbk_data, u32 cbk_magic);\n\nstatic void mp4_mux_flush_seg(GF_MP4MuxCtx *ctx, Bool is_init, u64 idx_start_range, u64 idx_end_range, Bool signal_flush)\n{\n\tGF_FilterEvent evt;\n\tTrackWriter *tkw = NULL;\n\n\tif (ctx->dst_pck) {\n\t\tif (!ctx->single_file) {\n\t\t\tBool s, e;\n\t\t\tgf_filter_pck_get_framing(ctx->dst_pck, &s, &e);\n\t\t\tgf_filter_pck_set_framing(ctx->dst_pck, s, GF_TRUE);\n\t\t\tif (!is_init) {\n\t\t\t\tu64 dur = ctx->next_seg_start - (ctx->min_cts_plus_one-1);\n\t\t\t\tgf_filter_pck_set_duration(ctx->dst_pck, (u32) dur);\n\t\t\t}\n\t\t\tctx->first_pck_sent = GF_FALSE;\n\t\t\tctx->current_offset = 0;\n\t\t\tif (is_init && s)\n\t\t\t\tgf_filter_pck_set_property(ctx->dst_pck, GF_PROP_PCK_INIT, &PROP_BOOL(GF_TRUE) );\n\t\t}\n\t\tif (is_init) {\n\t\t\tgf_filter_pck_set_dependency_flags(ctx->dst_pck, 0xFF);\n\t\t\tgf_filter_pck_set_carousel_version(ctx->dst_pck, 1);\n\t\t}\n\t\t//also inject m4cc after init seg - cf issue 2482\n\t\tif (is_init && ctx->eos_marker) {\n\t\t\tu8 data[8];\n\t\t\tmemset(data, 0, 8);\n\t\t\tdata[3] = 8;\n\t\t\tdata[4] = ctx->m4cc[0];\n\t\t\tdata[5] = ctx->m4cc[1];\n\t\t\tdata[6] = ctx->m4cc[2];\n\t\t\tdata[7] = ctx->m4cc[3];\n\t\t\tmp4_mux_on_data(ctx, data, 8, NULL, 0);\n\t\t}\n\t\tmp4mux_send_output(ctx);\n\t\tif (signal_flush)\n\t\t\tgf_filter_pid_send_flush(ctx->opid);\n\t}\n\tif (!is_init && ctx->llhls_mode && ctx->frag_size) {\n\t\tmp4_mux_flush_frag_hls(ctx);\n\t}\n\tif (ctx->dash_mode) {\n\t\t//send event on first track only\n\t\ttkw = gf_list_get(ctx->tracks, 0);\n\t\tGF_FEVT_INIT(evt, GF_FEVT_SEGMENT_SIZE, tkw->ipid);\n\t\tevt.seg_size.seg_url = NULL;\n\t\tevt.seg_size.is_init = is_init ? 1 : 0;\n\t\tif (!is_init || !idx_end_range) {\n\t\t\tevt.seg_size.media_range_start = ctx->current_offset;\n\t\t\tevt.seg_size.media_range_end = ctx->current_offset + ctx->current_size - 1;\n\t\t}\n\t\tif (idx_end_range && (ctx->vodcache==MP4MX_VODCACHE_INSERT))\n\t\t\tevt.seg_size.is_shift = 1;\n\n\t\tevt.seg_size.idx_range_start = idx_start_range;\n\t\tevt.seg_size.idx_range_end = idx_end_range;\n\t\tgf_filter_pid_send_event(tkw->ipid, &evt);\n\n\t\tctx->current_offset += ctx->current_size;\n\t\tctx->current_size = 0;\n\t\tctx->frag_offset = 0;\n\t\tctx->frag_size = 0;\n\t\tctx->frag_num = 0;\n\t\tctx->frag_has_intra = GF_FALSE;\n\t\t//changing file\n\t\tif (ctx->seg_name) {\n\t\t\tctx->first_pck_sent = GF_FALSE;\n\t\t}\n\t}\n}\n\nstatic GF_Err mp4_mux_initialize_movie(GF_MP4MuxCtx *ctx)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_Err e;\n\tu32 i, count = gf_list_count(ctx->tracks);\n\tTrackWriter *ref_tkw = NULL;\n\tu64 min_dts = 0;\n\tu32 min_dts_scale=0;\n\tu32 def_fake_dur=0;\n\tu32 def_fake_scale=0;\n#ifdef GF_ENABLE_CTRN\n\tu32 traf_inherit_base_id=0;\n#endif\n\tu32 nb_segments=0;\n\tGF_Fraction64 max_dur;\n\tctx->single_file = GF_TRUE;\n\tctx->current_offset = ctx->current_size = 0;\n\tmax_dur.den = 1;\n\tmax_dur.num = 0;\n\n\tif (ctx->sseg && ctx->noinit)\n\t\tctx->single_file = GF_FALSE;\n\n\tif (ctx->dur.num && ctx->dur.den) {\n\t\tmax_dur.num = ctx->dur.num;\n\t\tmax_dur.den = ctx->dur.den;\n\t}\n\n\t//make sure we have one sample from each PID. This will trigger potential pending reconfigure\n\t//for filters updating the PID caps before the first packet dispatch\n\tfor (i=0; i<count; i++) {\n\t\tconst GF_PropertyValue *p;\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tGF_FilterPacket *pck;\n\t\tif (tkw->fake_track) continue;\n\n\t\tpck = gf_filter_pid_get_packet(tkw->ipid);\n\t\tif (!pck) {\n\t\t\t//eos (wether real or flush event), continue setup\n\t\t\tif (gf_filter_pid_is_eos(tkw->ipid)) {\n\t\t\t\tif (tkw->dgl_copy) {\n\t\t\t\t\tgf_filter_pck_discard(tkw->dgl_copy);\n\t\t\t\t\ttkw->dgl_copy = NULL;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tif (!ctx->dash_mode && !ctx->cur_file_idx_plus_one) {\n\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILENUM);\n\t\t\tif (p) {\n\t\t\t\tctx->cur_file_idx_plus_one = p->value.uint + 1;\n\t\t\t\tif (!ctx->cur_file_suffix) {\n\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILESUF);\n\t\t\t\t\tif (p && p->value.string) ctx->cur_file_suffix = gf_strdup(p->value.string);\n\t\t\t\t}\n\t\t\t\tctx->notify_filename = GF_TRUE;\n\t\t\t}\n\t\t}\n\n\t\tif (tkw->cenc_state==CENC_NEED_SETUP) {\n\t\t\tmp4_mux_cenc_update(ctx, tkw, pck, CENC_CONFIG, 0, 0);\n\t\t}\n\n\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILENAME);\n\t\tif (p && strlen(p->value.string)) ctx->single_file = GF_FALSE;\n\n\t\tdef_fake_dur = gf_filter_pck_get_duration(pck);\n\t\tdef_fake_scale = tkw->src_timescale;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DURATION);\n\t\tif (p && p->value.lfrac.den) {\n\t\t\ttkw->pid_dur = p->value.lfrac;\n\t\t\tif (tkw->pid_dur.num<0) tkw->pid_dur.num = -tkw->pid_dur.num;\n\t\t\tif (max_dur.num * (s64) tkw->pid_dur.den < (s64) max_dur.den * tkw->pid_dur.num) {\n\t\t\t\tmax_dur.num = tkw->pid_dur.num;\n\t\t\t\tmax_dur.den = tkw->pid_dur.den;\n\t\t\t}\n\t\t}\n#ifdef GF_ENABLE_CTRN\n\t\tif (tkw->codecid==GF_CODECID_HEVC)\n\t\t\ttraf_inherit_base_id = tkw->track_id;\n#endif\n\t}\n\t//good to go, finalize for fragments\n\tfor (i=0; i<count; i++) {\n\t\tu32 def_pck_dur;\n\t\tu32 def_samp_size=0;\n\t\tu8 def_is_rap;\n#ifdef GF_ENABLE_CTRN\n\t\tu32 inherit_traf_from_track = 0;\n#endif\n\t\tu64 dts;\n\t\tconst GF_PropertyValue *p;\n\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\n\t\tif (tkw->fake_track) {\n\t\t\tif (def_fake_scale) {\n\t\t\t\tdef_pck_dur = def_fake_dur;\n\t\t\t\tdef_pck_dur *= tkw->src_timescale;\n\t\t\t\tdef_pck_dur /= def_fake_scale;\n\t\t\t} else {\n\t\t\t\tdef_pck_dur = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tGF_FilterPacket *pck = gf_filter_pid_get_packet(tkw->ipid);\n\t\t\t//can be null if eos\n\t\t\tif (pck) {\n\t\t\t\tu32 tscale;\n\t\t\t\t//otherwise setup fragmentation, using first sample desc as default idx\n\t\t\t\t//first pck dur as default\n\t\t\t\tdef_pck_dur = gf_filter_pck_get_duration(pck);\n\n\t\t\t\tdts = gf_filter_pck_get_dts(pck);\n\t\t\t\tif (dts == GF_FILTER_NO_TS)\n\t\t\t\t\tdts = gf_filter_pck_get_cts(pck);\n\t\t\t\ttscale = gf_filter_pck_get_timescale(pck);\n\n\t\t\t\tif (!min_dts || gf_timestamp_greater(min_dts, min_dts_scale, dts, tscale)) {\n\t\t\t\t\tmin_dts = dts;\n\t\t\t\t\tmin_dts_scale = tscale;\n\t\t\t\t}\n\t\t\t\tif (tkw->raw_audio_bytes_per_sample) {\n\t\t\t\t\tu32 pck_size;\n\t\t\t\t\tgf_filter_pck_get_data(pck, &pck_size);\n\t\t\t\t\tpck_size /= tkw->raw_audio_bytes_per_sample;\n\t\t\t\t\tif (pck_size)\n\t\t\t\t\t\tdef_pck_dur /= pck_size;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//check if we have a default constant duration set, if so use it\n\t\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CONSTANT_DURATION);\n\t\t\t\tdef_pck_dur = p ? p->value.uint : 0;\n\t\t\t}\n\t\t\tif (tkw->raw_audio_bytes_per_sample)\n\t\t\t\tdef_samp_size = tkw->raw_audio_bytes_per_sample;\n\t\t}\n\t\tif (tkw->src_timescale != tkw->tk_timescale) {\n\t\t\tdef_pck_dur *= tkw->tk_timescale;\n\t\t\tdef_pck_dur /= tkw->src_timescale;\n\t\t}\n\n\t\t//and consider audio & text all RAPs, the rest not rap - this will need refinement later on\n\t\t//but won't break the generated files\n\t\tswitch (tkw->stream_type) {\n\t\tcase GF_STREAM_AUDIO:\n\t\tcase GF_STREAM_TEXT:\n\t\t\tdef_is_rap = GF_ISOM_FRAG_DEF_IS_SYNC;\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_HAS_SYNC);\n\t\t\tif (p && p->value.boolean)\n\t\t\t\tdef_is_rap = 0;\n\t\t\tbreak;\n\t\tcase GF_STREAM_VISUAL:\n\t\t\tswitch (tkw->codecid) {\n\t\t\tcase GF_CODECID_PNG:\n\t\t\tcase GF_CODECID_JPEG:\n\t\t\tcase GF_CODECID_J2K:\n\t\t\t\tbreak;\n\t\t\tcase GF_CODECID_HEVC_TILES:\n#ifdef GF_ENABLE_CTRN\n\t\t\t\tif (ctx->ctrn && ctx->ctrni)\n\t\t\t\t\tinherit_traf_from_track = traf_inherit_base_id;\n#endif\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!ref_tkw) ref_tkw = tkw;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdef_is_rap = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdef_is_rap = 0;\n\t\t\tbreak;\n\t\t}\n\t\t//CMAF 7.5.17, if non-sync sample are present stss SHALL be present and empty...\n\t\tif (ctx->cmaf && !def_is_rap) {\n\t\t\tdef_is_rap |= GF_ISOM_FRAG_USE_SYNC_TABLE;\n\t\t}\n\n\t\tmp4_mux_set_hevc_groups(ctx, tkw);\n\n\t\t//use 1 for the default sample description index. If no multi stsd, this is always the case\n\t\t//otherwise we need to update the stsd idx in the traf headers\n\t\te = gf_isom_setup_track_fragment(ctx->file, tkw->track_id, tkw->stsd_idx, def_pck_dur, def_samp_size, def_is_rap, 0, 0, ctx->nofragdef ? GF_TRUE : GF_FALSE);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to setup fragmentation for track ID %d: %s\\n\", tkw->track_id, gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (ctx->refrag) {\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_TREX_TEMPLATE);\n\t\t\tif (p) {\n\t\t\t\tgf_isom_setup_track_fragment_template(ctx->file, tkw->track_id, p->value.data.ptr, p->value.data.size, ctx->nofragdef);\n\t\t\t} else if (!ctx->nofragdef) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Refragmentation with default track fragment flags signaling but no TREX found in source track %d, using defaults computed from PID, result might be broken\\n\", tkw->track_id));\n\t\t\t}\n\t\t}\n#endif\n\n\n\t\tif (ctx->tfdt.den && ctx->tfdt.num) {\n\t\t\ttkw->tfdt_offset = gf_timestamp_rescale(ctx->tfdt.num, ctx->tfdt.den, tkw->tk_timescale);\n\t\t}\n\n\t\tif (tkw->fake_track) {\n\t\t\tgf_list_del_item(ctx->tracks, tkw);\n\t\t\tif (ref_tkw==tkw) ref_tkw=NULL;\n\t\t\tmp4_mux_track_writer_del(tkw);\n\t\t\ti--;\n\t\t\tcount--;\n\t\t\tcontinue;\n\t\t}\n\n#ifdef GF_ENABLE_CTRN\n\t\tif (inherit_traf_from_track)\n\t\t\tgf_isom_enable_traf_inherit(ctx->file, tkw->track_id, inherit_traf_from_track);\n#endif\n\n\t\tif (!tkw->box_patched) {\n\t\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"boxpatch\");\n\t\t\tif (p && p->value.string) {\n\t\t\t\te = gf_isom_apply_box_patch(ctx->file, tkw->track_id, p->value.string, GF_FALSE);\n\t\t\t\tif (e) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to apply box patch %s to track %d: %s\\n\",\n\t\t\t\t\t\tp->value.string, tkw->track_id, gf_error_to_string(e) ));\n\t\t\t\t}\n\t\t\t}\n\t\t\ttkw->box_patched = GF_TRUE;\n\t\t}\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DASH_SEGMENTS);\n\t\tif (p && (p->value.uint>nb_segments))\n\t\t\tnb_segments = p->value.uint;\n\n\t\tif (!ctx->dash_mode)\n\t\t\tgf_isom_purge_track_reference(ctx->file, tkw->track_num);\n\t}\n\n\tif (max_dur.num && max_dur.den) {\n\t\tu64 mdur = max_dur.num;\n\t\tif (ctx->moovts != max_dur.den) {\n\t\t\tmdur *= (u32) ctx->moovts;\n\t\t\tmdur /= max_dur.den;\n\t\t}\n\t\tgf_isom_set_movie_duration(ctx->file, mdur, GF_FALSE);\n\t}\n\telse if (ctx->cmaf) {\n\t\t//CMAF 7.3.2.1.c.6) \"The MovieExtendsBox may contain a MovieExtendsHeaderBox,\n\t\t//as defined in ISO/IEC 14496-12, and if so, shall provide the overall duration\n\t\t//of the CMAF track. If the duration is unknown, this box shall be omitted.\"\n\t\tgf_isom_set_movie_duration(ctx->file, 0, GF_TRUE);\n\t}\n\n\t//if we have an explicit track reference for fragmenting, move it first in our list\n\tif (ref_tkw) {\n\t\tgf_list_del_item(ctx->tracks, ref_tkw);\n\t\tgf_list_insert(ctx->tracks, ref_tkw, 0);\n\t}\n\tctx->ref_tkw = gf_list_get(ctx->tracks, 0);\n\n\tif (!ctx->abs_offset) {\n\t\tu32 mval = ctx->dash_mode ? '6' : '5';\n\t\tu32 mbrand, mcount, found=0;\n\t\tu8 szB[GF_4CC_MSIZE];\n\t\tgf_isom_set_fragment_option(ctx->file, 0, GF_ISOM_TFHD_FORCE_MOOF_BASE_OFFSET, 1);\n\n\t\tgf_isom_get_brand_info(ctx->file, &mbrand, NULL, &mcount);\n\t\tstrcpy(szB, gf_4cc_to_str(mbrand));\n\t\tif (!strncmp(szB, \"iso\", 3) && (szB[3] >= mval) && (szB[3] <= 'F') ) found = 1;\n\t\ti=0;\n\t\twhile (!found && (i<mcount)) {\n\t\t\ti++;\n\t\t\tgf_isom_get_alternate_brand(ctx->file, i, &mbrand);\n\t\t\tstrcpy(szB, gf_4cc_to_str(mbrand));\n\t\t\tif (!strncmp(szB, \"iso\", 3) && (szB[3] >= mval) && (szB[3] <= 'F') ) found = 1;\n\t\t}\n\n\t\t/*because of movie fragments MOOF based offset, ISOM <4 is forbidden*/\n\t\tif (!found) {\n\t\t\tgf_isom_set_brand_info(ctx->file, ctx->dash_mode ? GF_ISOM_BRAND_ISO6 : GF_ISOM_BRAND_ISO5, 1);\n\t\t}\n\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO1, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO2, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO3, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO4, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_AVC1, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_MP41, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_MP42, GF_FALSE);\n\t}\n\n\tif (ctx->dash_mode) {\n\t\t/*DASH self-init media segment*/\n\t\tif (ctx->dash_mode==MP4MX_DASH_VOD) {\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_DSMS, GF_TRUE);\n\t\t} else {\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_DASH, GF_TRUE);\n\t\t}\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_MSIX, ((ctx->dash_mode==MP4MX_DASH_VOD) && (ctx->subs_sidx>=0)) ? GF_TRUE : GF_FALSE);\n\t}\n\n\tif (ctx->boxpatch && !ctx->box_patched) {\n\t\te = gf_isom_apply_box_patch(ctx->file, 0, ctx->boxpatch, GF_FALSE);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to apply box patch %s: %s\\n\", ctx->boxpatch, gf_error_to_string(e) ));\n\t\t}\n\t\tctx->box_patched = GF_TRUE;\n\t}\n\n\te = gf_isom_finalize_for_fragment(ctx->file, ctx->dash_mode ? 1 : 0, ctx->mvex);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to finalize moov for fragmentation: %s\\n\", gf_error_to_string(e) ));\n\t\treturn e;\n\t}\n\tctx->init_movie_done = GF_TRUE;\n\n\tif (min_dts_scale) {\n\t\tu64 rs_dts = gf_timestamp_rescale(min_dts, min_dts_scale, ctx->cdur.den);\n\t\tctx->next_frag_start = rs_dts;\n\t}\n\tctx->next_frag_start += ctx->cdur.num;\n\tctx->adjusted_next_frag_start = ctx->next_frag_start;\n\tctx->fragment_started = GF_FALSE;\n\n\tif (ctx->noinit) {\n\t\tif (ctx->dst_pck) gf_filter_pck_discard(ctx->dst_pck);\n\t\tctx->dst_pck = NULL;\n\t\tctx->current_size = ctx->current_offset = 0;\n\t\tctx->first_pck_sent = GF_FALSE;\n\t} else {\n\t\tmp4_mux_flush_seg(ctx, GF_TRUE, 0, 0, GF_TRUE);\n\t}\n\tassert(!ctx->dst_pck);\n\n\t//change major brand for segments\n\tif (ctx->styp && (strlen(ctx->styp)>=4)) {\n\t\tu32 styp_brand = GF_4CC(ctx->styp[0], ctx->styp[1], ctx->styp[2], ctx->styp[3]);\n\t\tu32 version = 0;\n\t\tchar *sep = strchr(ctx->styp, '.');\n\t\tif (sep) version = atoi(sep+1);\n\t\tgf_isom_set_brand_info(ctx->file, styp_brand, version);\n\t}\n\n\tif (ctx->dash_mode==MP4MX_DASH_VOD) {\n\t\tif ((ctx->vodcache==MP4MX_VODCACHE_REPLACE) && !nb_segments && (!ctx->media_dur || !ctx->dash_dur.num) ) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Media duration unknown, cannot use replace mode of vodcache, using temp file for VoD storage\\n\"));\n\t\t\tctx->vodcache = MP4MX_VODCACHE_ON;\n\t\t\te = mp4mx_setup_dash_vod(ctx, NULL);\n\t\t\tif (e) return e;\n\t\t}\n\n\t\tif (ctx->vodcache==MP4MX_VODCACHE_REPLACE) {\n\t\t\tGF_BitStream *bs;\n\t\t\tu8 *output;\n\t\t\tchar *msg;\n\t\t\tGF_FilterPacket *pck;\n\t\t\tu32 len;\n\t\t\tBool exact_sidx = GF_TRUE;\n\n\t\t\tif (!nb_segments) {\n\t\t\t\texact_sidx = GF_FALSE;\n\t\t\t\tnb_segments = (u32) ( ctx->media_dur * ctx->dash_dur.den / ctx->dash_dur.num);\n\t\t\t\t//always add an extra segment\n\t\t\t\tnb_segments ++;\n\t\t\t\t//and safety alloc of 10%\n\t\t\t\tif (nb_segments>10)\n\t\t\t\t\tnb_segments += 10*nb_segments/100;\n\t\t\t\telse\n\t\t\t\t\tnb_segments ++;\n\t\t\t}\n\n\t\t\t//max sidx size: full box + sidx fields + timing 64 bit + nb segs (each 12 bytes)\n\t\t\tctx->sidx_max_size = 12 + (12 + 16) + 12 * nb_segments;\n\n\t\t\t//we produce an ssix, add full box + nb subsegs + nb_segments * (range_count=2 + 2*(range+size))\n\t\t\tif (ctx->ssix) {\n\t\t\t\tctx->sidx_max_size += 12 + 4 + nb_segments * 12;\n\t\t\t}\n\n\t\t\tif (!exact_sidx) {\n\t\t\t\t//and a free box\n\t\t\t\tctx->sidx_max_size += 8;\n\t\t\t\tctx->sidx_size_exact = GF_FALSE;\n\t\t\t} else {\n\t\t\t\tctx->sidx_size_exact = GF_TRUE;\n\t\t\t}\n\t\t\tctx->sidx_chunk_offset = (u32) (ctx->current_offset + ctx->current_size);\n\t\t\t//send a dummy packet\n\t\t\tpck = gf_filter_pck_new_alloc(ctx->opid, ctx->sidx_max_size, &output);\n\t\t\tif (!pck) return GF_OUT_OF_MEM;\n\n\t\t\tgf_filter_pck_set_framing(pck, GF_FALSE, GF_FALSE);\n\t\t\t//format as free box for now\n\t\t\tbs = gf_bs_new(output, ctx->sidx_max_size, GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_u32(bs, ctx->sidx_max_size);\n\t\t\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_FREE);\n\t\t\tmsg = \"GPAC \" GPAC_VERSION\" SIDX placeholder\";\n\t\t\tlen = (u32) strlen(msg);\n\t\t\tif (len+8>ctx->sidx_max_size) len = ctx->sidx_max_size - 8;\n\t\t\tgf_bs_write_data(bs, msg, len );\n\t\t\tgf_bs_del(bs);\n\t\t\tgf_filter_pck_send(pck);\n\n\t\t\tctx->current_offset += ctx->sidx_max_size;\n\t\t} else if (ctx->vodcache==MP4MX_VODCACHE_ON) {\n\t\t\tctx->store_output = GF_TRUE;\n\t\t} else {\n\t\t\tctx->store_output = GF_FALSE;\n\t\t\tctx->sidx_chunk_offset = (u32) (ctx->current_offset + ctx->current_size);\n\t\t}\n\t\tgf_isom_allocate_sidx(ctx->file, ctx->subs_sidx, ctx->chain_sidx, 0, NULL, NULL, NULL, ctx->ssix);\n\t}\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\nstatic GF_Err mp4_mux_start_fragment(GF_MP4MuxCtx *ctx, GF_FilterPacket *pck)\n{\n\tGF_Err e;\n\tu32 i, count = gf_list_count(ctx->tracks);\n\tBool has_tfdt=GF_FALSE;\n\tGF_ISOStartFragmentFlags flags=0;\n\n\t//setup some default\n\tgf_isom_set_next_moof_number(ctx->file, ctx->msn);\n\tctx->msn += ctx->msninc;\n\tctx->min_cts_plus_one = 0;\n\n\tif (ctx->moof_first) flags |= GF_ISOM_FRAG_MOOF_FIRST;\n#ifdef GF_ENABLE_CTRN\n\tif (ctx->ctrn) flags |= GF_ISOM_FRAG_USE_COMPACT;\n#endif\n\n\te = gf_isom_start_fragment(ctx->file, flags);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to start new fragment: %s\\n\", gf_error_to_string(e) ));\n\t\treturn e;\n\t}\n\tif (pck) {\n\t\tconst GF_PropertyValue *p = gf_filter_pck_get_property(pck, GF_PROP_PCK_MOOF_TEMPLATE);\n\t\tif (p && p->value.data.ptr) {\n\t\t\tGF_SegmentIndexBox *out_sidx = NULL;\n\t\t\tgf_isom_set_fragment_template(ctx->file, p->value.data.ptr, p->value.data.size, &has_tfdt, &out_sidx);\n\t\t\tif (out_sidx) {\n\t\t\t\tif (ctx->cloned_sidx) gf_isom_box_del((GF_Box *)ctx->cloned_sidx);\n\t\t\t\tctx->cloned_sidx = out_sidx;\n\t\t\t\tctx->cloned_sidx_index = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t//setup some default\n\tfor (i=0; i<count; i++) {\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\te = GF_OK;\n\t\tif (ctx->strun) {\n\t\t\te = gf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRAF_RANDOM_ACCESS, 0);\n\t\t}\n\t\t//fragment at sap boundaries for video, but not in dash mode (compatibility with old arch)\n\t\telse if (ctx->fsap && (tkw->stream_type == GF_STREAM_VISUAL) && !ctx->dash_mode) {\n\t\t\te = gf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRAF_RANDOM_ACCESS, 1);\n\t\t}\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Unable set fragment options: %s\\n\", gf_error_to_string(e) ));\n\t\t}\n\t\ttkw->fragment_done = GF_FALSE;\n\t\ttkw->insert_tfdt = (has_tfdt || ctx->tfdt_traf || tkw->tfdt_offset) ? GF_TRUE : ctx->insert_tfdt;\n\t\ttkw->dur_in_frag = 0;\n\n\t\tif (ctx->trun_inter) {\n\t\t\tgf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRUN_SET_INTERLEAVE_ID, 0);\n\t\t}\n\t\tif (ctx->truns_first) {\n\t\t\tgf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRAF_TRUNS_FIRST, 1);\n\t\t}\n\t\t//7.7 cmf2 For video CMAF Tracks not contained in Track Files, Version 1 shall be used.\n\t\tif ((ctx->cmaf==MP4MX_CMAF_CMF2) && (tkw->stream_type==GF_STREAM_VISUAL))\n\t\t\tgf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRAF_TRUN_V1, 1);\n\n\t\tif (ctx->sdtp_traf)\n\t\t\tgf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRAF_USE_SAMPLE_DEPS_BOX, ctx->sdtp_traf);\n\n\t\tif (ctx->tfdt64)\n\t\t\tgf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRAF_USE_LARGE_TFDT, ctx->tfdt64);\n\n\t\tif (tkw->dyn_pssh) {\n\t\t\tmp4_mux_cenc_insert_pssh(ctx, tkw, NULL, 2);\n\t\t}\n\t\telse if (ctx->insert_pssh)\n\t\t\tmp4_mux_cenc_insert_pssh(ctx, tkw, NULL, 1);\n\t}\n\tctx->fragment_started = GF_TRUE;\n\tctx->insert_tfdt = GF_FALSE;\n\tctx->insert_pssh = GF_FALSE;\n\treturn GF_OK;\n}\n\nstatic GF_Err mp4_mux_flush_fragmented(GF_MP4MuxCtx *ctx)\n{\n\tGF_FilterPacket *pck;\n\tu8 *output;\n\tu32 nb_read, blocksize = ctx->block_size;\n\tif (ctx->flush_done + blocksize>ctx->flush_size) {\n\t\tblocksize = (u32) (ctx->flush_size - ctx->flush_done);\n\t}\n\tif (!blocksize) return GF_EOS;\n\tpck = gf_filter_pck_new_alloc(ctx->opid, blocksize, &output);\n\tif (!pck) return GF_OUT_OF_MEM;\n\n\tnb_read = (u32) gf_fread(output, blocksize, ctx->tmp_store);\n\tif (nb_read != blocksize) {\n\t\tchar tmp[1];\n\t\t//weird behavior on some file systems, dump debug info\n\t\tgf_fread(tmp, 1, ctx->tmp_store);\n\t\tBool is_eof = gf_feof(ctx->tmp_store);\n\t\tGF_LOG(is_eof ? GF_LOG_WARNING : GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error reading from VOD temp cache, read %d bytes but asked %d bytes\\n\\tCache EOF %d - cache size \"LLU\" - read pos \"LLU\" - file pos \"LLU\"\\n\", nb_read, blocksize, is_eof, ctx->flush_size, ctx->flush_done, gf_ftell(ctx->tmp_store)));\n\t}\n\tctx->flush_done += nb_read;\n\tif (ctx->flush_done==ctx->flush_size) {\n\t\tgf_filter_pck_set_framing(pck, GF_FALSE, GF_TRUE);\n\t\tgf_filter_pck_send(pck);\n\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\treturn GF_EOS;\n\t}\n\tgf_filter_pck_set_framing(pck, GF_FALSE, GF_FALSE);\n\tgf_filter_pck_send(pck);\n\t//we are not done flushing but we have no more input packets, signal we still need processing\n\tgf_filter_ask_rt_reschedule(ctx->filter, 1);\n\treturn GF_OK;\n}\n\nstatic void mp4mx_frag_box_patch(GF_MP4MuxCtx *ctx)\n{\n\tGF_Err e;\n\tu32 i, count = gf_list_count(ctx->tracks);\n\tfor (i=0; i<count; i++) {\n\t\tconst GF_PropertyValue *p;\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tif (!tkw->track_id) continue;\n\t\t//no box patched set (todo, do we want to allow changing boxpatch props ?)\n\t\tif (!tkw->box_patched) continue;\n\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"boxpatch\");\n\t\tif (p && p->value.string) {\n\t\t\te = gf_isom_apply_box_patch(ctx->file, tkw->track_id ? tkw->track_id : tkw->item_id, p->value.string, GF_TRUE);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to apply box patch %s to track fragment %d: %s\\n\",\n\t\t\t\t\tp->value.string, tkw->track_id, gf_error_to_string(e) ));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ctx->boxpatch) {\n\t\te = gf_isom_apply_box_patch(ctx->file, 0, ctx->boxpatch, GF_TRUE);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to apply box patch %s to fragment: %s\\n\", ctx->boxpatch, gf_error_to_string(e) ));\n\t\t}\n\t\tctx->box_patched = GF_TRUE;\n\t}\n}\n#endif // GPAC_DISABLE_ISOM_FRAGMENTS\n\n\nstatic GF_Err mp4_mux_initialize(GF_Filter *filter);\n\nGF_Err mp4mx_reload_output(GF_MP4MuxCtx *ctx)\n{\n\tGF_Err e;\n\tu32 i, count = gf_list_count(ctx->tracks);\n\n\t//done with the file\n\tif (ctx->file) {\n\t\te = mp4_mux_done(ctx, GF_FALSE);\n\t\tif (e) return e;\n\t\tctx->file = NULL;\n\t}\n\tctx->init_movie_done = GF_FALSE;\n\te = mp4_mux_initialize(ctx->filter);\n\tif (e) return e;\n\tctx->config_timing = GF_TRUE;\n\n\tfor (i=0; i<count; i++) {\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\ttkw->suspended = GF_FALSE;\n\t\ttkw->track_num = 0;\n\t\ttkw->nb_samples = 0;\n\t\ttkw->max_cts = 0;\n\t\ttkw->min_cts = (u64) -1;\n\t\te = mp4_mux_configure_pid(ctx->filter, tkw->ipid, GF_FALSE);\n\t\tif (e) return e;\n\t\ttkw->nb_samples = 0;\n\t\ttkw->sample.DTS = 0;\n\t\ttkw->sample.CTS_Offset = 0;\n\t\ttkw->samples_in_stsd = 0;\n\t\ttkw->samples_in_frag = 0;\n\t}\n\tassert(ctx->next_file_idx);\n\tctx->cur_file_idx_plus_one = ctx->next_file_idx;\n\tctx->next_file_idx = 0;\n\tctx->notify_filename = GF_TRUE;\n\tassert(!ctx->cur_file_suffix);\n\tif (ctx->next_file_suffix) {\n\t\tctx->cur_file_suffix = gf_strdup(ctx->next_file_suffix);\n\t\tctx->next_file_suffix = NULL;\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err mp4_mux_process_fragmented(GF_MP4MuxCtx *ctx)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_Err e = GF_OK;\n\tu32 nb_eos, nb_done, nb_suspended, i, count;\n\n\tif (ctx->flush_size) {\n\t\treturn mp4_mux_flush_fragmented(ctx);\n\t}\n\n\tif (!ctx->file)\n\t\treturn GF_EOS;\n\n\t//init movie not yet produced\n\tif (!ctx->init_movie_done) {\n\t\te = mp4_mux_initialize_movie(ctx);\n\t\tif (e) return e;\n\t\tif (!ctx->init_movie_done)\n\t\t\treturn GF_OK;\n\t}\n\t/*get count after init, some tracks may have been remove*/\n\tcount = gf_list_count(ctx->tracks);\n\n\t//process pid by pid\n\tnb_eos=0;\n\tnb_done = 0;\n\tnb_suspended = 0;\n\tfor (i=0; i<count; i++) {\n\t\tu64 cts, dts, ncts;\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\n\t\tif (ctx->fragment_started && tkw->fragment_done) {\n\t\t\tnb_done ++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (tkw->suspended) {\n\t\t\tif (ctx->fragment_started) nb_done++;\n\t\t\tnb_suspended++;\n\t\t\tcontinue;\n\t\t}\n\n\t\twhile (1) {\n\t\t\tconst GF_PropertyValue *p;\n\t\t\tu32 orig_frag_bounds=0;\n\t\t\tGF_FilterPacket *pck = gf_filter_pid_get_packet(tkw->ipid);\n\n\t\t\tif (!pck) {\n\t\t\t\tif (gf_filter_pid_is_eos(tkw->ipid)) {\n\t\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\t\tif (ctx->dash_mode) ctx->flush_seg = GF_TRUE;\n\t\t\t\t\tif (ctx->next_file_idx)\n\t\t\t\t\t\tnb_suspended++;\n\t\t\t\t\tnb_done ++;\n\t\t\t\t\tif (tkw->dgl_copy) {\n\t\t\t\t\t\tgf_filter_pck_discard(tkw->dgl_copy);\n\t\t\t\t\t\ttkw->dgl_copy = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (!gf_filter_pid_is_flush_eos(tkw->ipid))\n\t\t\t\t\t\tnb_eos++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tif (tkw->aborted) {\n\t\t\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\t\t\t\tnb_eos++;\n\t\t\t\tnb_done ++;\n\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\tif (ctx->dash_mode) ctx->flush_seg = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//we create dash segment only when we know we have a packet, not before this loop.\n\t\t\t//This allows taking into account flush signals, otherwise we would create empty segments\n\t\t\tif (ctx->dash_mode && !ctx->segment_started) {\n\t\t\t\tctx->segment_started = GF_TRUE;\n\t\t\t\tctx->insert_tfdt = GF_TRUE;\n\t\t\t\tswitch (ctx->psshs) {\n\t\t\t\tcase MP4MX_PSSH_MOOF:\n\t\t\t\tcase MP4MX_PSSH_BOTH:\n\t\t\t\t\tctx->insert_pssh = GF_TRUE; break;\n\t\t\t\tdefault:\n\t\t\t\t\tctx->insert_pssh = GF_FALSE; break;\n\t\t\t\t}\n\t\t\t\tgf_isom_start_segment(ctx->file, ctx->single_file ? NULL : \"_gpac_isobmff_redirect\", GF_FALSE);\n\t\t\t}\n\n\t\t\tcts = gf_filter_pck_get_cts(pck);\n\n\t\t\tif (cts == GF_FILTER_NO_TS) {\n\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_EODS);\n\t\t\t\tif (p && p->value.boolean) {\n\t\t\t\t\tnb_done ++;\n\t\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\t\ttkw->samples_in_frag = 0;\n\t\t\t\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\t\t\t\t\tctx->flush_seg = GF_TRUE;\n\t\t\t\t\ttkw->next_seg_cts = tkw->cts_next;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MuxIsom] Packet with no CTS assigned, cannot store to track, ignoring\\n\"));\n\t\t\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FRAG_START);\n\t\t\tif (p) {\n\t\t\t\torig_frag_bounds = p->value.uint;\n\n\t\t\t\tif (orig_frag_bounds==2) {\n\t\t\t\t\tif (!ctx->segment_started) {\n\t\t\t\t\t\tctx->dash_mode = 1;\n\t\t\t\t\t\tctx->insert_tfdt = GF_TRUE;\n\t\t\t\t\t\tgf_isom_start_segment(ctx->file, ctx->single_file ? NULL : \"_gpac_isobmff_redirect\", GF_FALSE);\n\t\t\t\t\t} else if (tkw->samples_in_frag) {\n\t\t\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\t\t\ttkw->samples_in_frag = 0;\n\t\t\t\t\t\tnb_done ++;\n\t\t\t\t\t\t//make sure we flush until the end of the segment\n\t\t\t\t\t\tctx->flush_seg = GF_TRUE;\n\t\t\t\t\t\t//store CTS of next packet (first in next segment) for sidx compute\n\t\t\t\t\t\ttkw->next_seg_cts = cts;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//get dash/file segment number\n\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILENUM);\n\n\t\t\t//not dash and file end, we need to wait for all streams and resetup\n\t\t\tif (!ctx->dash_mode && p) {\n\t\t\t\tif (!ctx->cur_file_idx_plus_one) {\n\t\t\t\t\tctx->cur_file_idx_plus_one = p->value.uint + 1;\n\t\t\t\t\tif (!ctx->cur_file_suffix) {\n\t\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILESUF);\n\t\t\t\t\t\tif (p && p->value.string) ctx->cur_file_suffix = gf_strdup(p->value.string);\n\t\t\t\t\t}\n\t\t\t\t\tctx->notify_filename = GF_TRUE;\n\t\t\t\t} else if (ctx->cur_file_idx_plus_one == p->value.uint+1) {\n\t\t\t\t} else if (!tkw->suspended) {\n\t\t\t\t\ttkw->suspended = GF_TRUE;\n\t\t\t\t\tnb_suspended++;\n\t\t\t\t\tctx->next_file_idx =  p->value.uint + 1;\n\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILESUF);\n\t\t\t\t\tif (p && p->value.string)\n\t\t\t\t\t\tctx->next_file_suffix = p->value.string;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif (!ctx->fragment_started) {\n\t\t\t\te = mp4_mux_start_fragment(ctx, orig_frag_bounds ? pck : NULL);\n\t\t\t\tif (e) return e;\n\n\t\t\t\t//push emsgonce the segment is started\n\t\t\t\tconst GF_PropertyValue *emsg = gf_filter_pck_get_property_str(pck, \"grp_EMSG\");\n\t\t\t\tif (emsg && (emsg->type==GF_PROP_DATA) && emsg->value.data.ptr) {\n\t\t\t\t\tGF_Err gf_isom_set_emsg(GF_ISOFile *movie, u8 *data, u32 size);\n\n\t\t\t\t\tgf_isom_set_emsg(ctx->file, emsg->value.data.ptr, emsg->value.data.size);\n\t\t\t\t}\n\n\t\t\t\tctx->nb_frags++;\n\t\t\t\tif (ctx->dash_mode)\n\t\t\t\t\tctx->nb_frags_in_seg++;\n\n\t\t\t}\n\n\n\t\t\tif (ctx->dash_mode) {\n\t\t\t\tif (p) {\n\t\t\t\t\t//start of next segment, abort fragmentation for this track and flush all other writers\n\t\t\t\t\tif (ctx->dash_seg_num_plus_one && (ctx->dash_seg_num_plus_one != 1 + p->value.uint) ) {\n\t\t\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\t\t\ttkw->samples_in_frag = 0;\n\t\t\t\t\t\tnb_done ++;\n\t\t\t\t\t\t//make sure we flush until the end of the segment\n\t\t\t\t\t\tctx->flush_seg = GF_TRUE;\n\t\t\t\t\t\t//store CTS of next packet (first in next segment) for sidx compute\n\t\t\t\t\t\ttkw->next_seg_cts = cts;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//start of current segment, remember segment number and name\n\t\t\t\t\tctx->dash_seg_num_plus_one = 1 + p->value.uint;\n\t\t\t\t\t//get file name prop if any - only send on one pid for muxed content\n\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILENAME);\n\t\t\t\t\tif (p && p->value.string) {\n\t\t\t\t\t\tif (ctx->seg_name) gf_free(ctx->seg_name);\n\t\t\t\t\t\tctx->seg_name = gf_strdup(p->value.string);\n\t\t\t\t\t}\n\t\t\t\t\t//store PRFT only for reference track at segment start\n\t\t\t\t\tif (tkw==ctx->ref_tkw) {\n\t\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_SENDER_NTP);\n\t\t\t\t\t\tif (p) {\n\t\t\t\t\t\t\tgf_isom_set_fragment_reference_time(ctx->file, tkw->track_id, p->value.longuint, cts);\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[MuxIsom] Segment %s, storing NTP TS \"LLU\" for CTS \"LLU\" at \"LLU\" us, at UTC \"LLU\"\\n\", ctx->seg_name ? ctx->seg_name : \"singlefile\", p->value.longuint, cts, gf_sys_clock_high_res(), gf_net_get_utc()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdts = gf_filter_pck_get_dts(pck);\n\t\t\t\tif (dts==GF_FILTER_NO_TS) dts = cts;\n\t\t\t\tif (tkw->first_dts_in_seg_plus_one && (tkw->first_dts_in_seg_plus_one - 1 > dts))\n\t\t\t\t\ttkw->first_dts_in_seg_plus_one = 1 + dts;\n\t\t\t}\n\t\t\tncts = cts + gf_filter_pck_get_duration(pck);\n\t\t\tif (tkw->cts_next < ncts)\n\t\t\t\ttkw->cts_next = ncts;\n\n\t\t\t//compute ts after delay/skip for fragment interleaving\n\t\t\tu64 check_ts;\n\t\t\tif ((tkw->ts_delay<0) && (cts < -tkw->ts_delay))\n\t\t\t\tcheck_ts = 0;\n\t\t\telse\n\t\t\t\tcheck_ts = cts+tkw->ts_delay;\n\n\t\t\t//we have samples and either a request to flush fragment or a emsg, start new fragment\n\t\t\tif (tkw->samples_in_frag && (orig_frag_bounds || (gf_filter_pck_get_property_str(pck, \"grp_EMSG\")!=NULL))) {\n\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\tnb_done ++;\n\t\t\t\ttkw->samples_in_frag = 0;\n\t\t\t\ttkw->dur_in_frag = 0;\n\t\t\t\tbreak;\n\t\t\t} else if (ctx->fragdur && (!ctx->dash_mode || !tkw->fragment_done) ) {\n\t\t\t\tBool frag_done = GF_FALSE;\n\t\t\t\tu32 dur = gf_filter_pck_get_duration(pck);\n\t\t\t\tif (tkw->dur_in_frag && gf_timestamp_greater_or_equal(tkw->dur_in_frag, tkw->src_timescale, ctx->cdur.num, ctx->cdur.den)) {\n\t\t\t\t\tfrag_done = GF_TRUE;\n\t\t\t\t} else if ((ctx->store==MP4MX_MODE_SFRAG)\n\t\t\t\t\t&& gf_timestamp_greater_or_equal(check_ts, tkw->src_timescale, ctx->adjusted_next_frag_start, ctx->cdur.den)\n\t\t\t\t) {\n\t\t\t\t\tGF_FilterSAPType sap = mp4_mux_get_sap(ctx, pck);\n\t\t\t\t\tif ((sap && sap<GF_FILTER_SAP_3)) {\n\t\t\t\t\t\tfrag_done = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (frag_done) {\n\t\t\t\t\tctx->adjusted_next_frag_start = gf_timestamp_rescale(check_ts, tkw->src_timescale, ctx->cdur.den);\n\t\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\t\tnb_done ++;\n\t\t\t\t\ttkw->dur_in_frag = 0;\n\t\t\t\t\ttkw->samples_in_frag = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttkw->dur_in_frag += dur;\n\t\t\t\tif (ctx->llhls_mode && (ctx->frag_duration * tkw->src_timescale <= tkw->dur_in_frag * ctx->frag_timescale)) {\n\t\t\t\t\tctx->frag_duration = tkw->dur_in_frag;\n\t\t\t\t\tctx->frag_timescale = tkw->src_timescale;\n\t\t\t\t}\n\t\t\t} else if (!ctx->flush_seg && !ctx->dash_mode\n\t\t\t\t&& gf_timestamp_greater_or_equal(check_ts, tkw->src_timescale, ctx->adjusted_next_frag_start, ctx->cdur.den)\n\t\t\t ) {\n\t\t\t\tGF_FilterSAPType sap = mp4_mux_get_sap(ctx, pck);\n\t\t\t\t//consider roll SAP as sap1 for the fragmentation\n\t\t\t\tif ((sap==GF_FILTER_SAP_4) && (tkw->stream_type==GF_STREAM_AUDIO))\n\t\t\t\t\tsap = GF_FILTER_SAP_1;\n\n\t\t\t\tif ((ctx->store==MP4MX_MODE_FRAG) || (sap && sap<GF_FILTER_SAP_3)) {\n\t\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\t\ttkw->samples_in_frag = 0;\n\t\t\t\t\tnb_done ++;\n\t\t\t\t\tif (ctx->store==MP4MX_MODE_SFRAG) {\n\t\t\t\t\t\tctx->adjusted_next_frag_start = gf_timestamp_rescale(check_ts, tkw->src_timescale, ctx->cdur.den);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((ctx->store>=MP4MX_MODE_FRAG) && tkw->samples_in_frag) {\n\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PID_CENC_PSSH);\n\t\t\t\tif (p && (p->type == GF_PROP_DATA) && p->value.data.ptr && !ctx->flush_seg && !ctx->dash_mode) {\n\t\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\t\ttkw->samples_in_frag = 0;\n\t\t\t\t\tnb_done ++;\n\t\t\t\t\tif (ctx->store==MP4MX_MODE_SFRAG) {\n\t\t\t\t\t\tctx->adjusted_next_frag_start = gf_timestamp_rescale(check_ts, tkw->src_timescale, ctx->cdur.den);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tkw->insert_tfdt) {\n\t\t\t\tu64 odts = gf_filter_pck_get_dts(pck);\n\t\t\t\tif (odts==GF_FILTER_NO_TS)\n\t\t\t\t\todts = gf_filter_pck_get_cts(pck);\n\n\t\t\t\tif (tkw->tfdt_offset) {\n\t\t\t\t\t//first sample, set offset dts such that first sample dts - offset_dts = target time\n\t\t\t\t\tif (tkw->nb_samples==0) {\n\t\t\t\t\t\tu64 target = tkw->tfdt_offset;\n\t\t\t\t\t\ttkw->tfdt_offset = odts - target;\n\n\t\t\t\t\t}\n\t\t\t\t\todts = odts - tkw->tfdt_offset;\n\t\t\t\t}\n\n\t\t\t\ttkw->insert_tfdt = GF_FALSE;\n\t\t\t\tif (tkw->patch_tfdt)\n\t\t\t\t\t//if patch_tfdt is true, tkw->ts_delay is always >0\n\t\t\t\t\tgf_isom_set_traf_base_media_decode_time(ctx->file, tkw->track_id, odts + tkw->ts_delay);\n\t\t\t\telse\n\t\t\t\t\tgf_isom_set_traf_base_media_decode_time(ctx->file, tkw->track_id, odts);\n\n\t\t\t\tif (!tkw->first_dts_in_seg_plus_one)\n\t\t\t\t\ttkw->first_dts_in_seg_plus_one = 1 + (u64) odts;\n\t\t\t}\n\n\t\t\tif (ctx->trun_inter) {\n\t\t\t\tGF_FilterSAPType sap = mp4_mux_get_sap(ctx, pck);\n\t\t\t\ts32 tid_group = 0;\n\t\t\t\tif (sap) {\n\t\t\t\t\ttkw->prev_tid_group = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts64 dts_diff;\n\t\t\t\t\ts64 p_dts = gf_filter_pck_get_dts(pck);\n\t\t\t\t\ts64 p_cts = gf_filter_pck_get_cts(pck);\n\t\t\t\t\ts64 cts_o = p_cts - p_dts;\n\t\t\t\t\tdts_diff = p_dts - tkw->sample.DTS;\n\t\t\t\t\ttid_group = (s32) (cts_o / dts_diff);\n\t\t\t\t\ttid_group = 20 - tid_group;\n\t\t\t\t\tif (tid_group != tkw->prev_tid_group) {\n\t\t\t\t\t\ttkw->prev_tid_group = tid_group;\n\t\t\t\t\t\tgf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRUN_SET_INTERLEAVE_ID, tid_group);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//process packet\n\t\t\te = mp4_mux_process_sample(ctx, tkw, pck, GF_TRUE);\n\n\t\t\t//discard\n\t\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\n\t\t\tcts = gf_timestamp_rescale(cts, tkw->src_timescale, 1000);\n\t\t\tif (!ctx->min_cts_plus_one) ctx->min_cts_plus_one = cts + 1;\n\t\t\telse if (ctx->min_cts_plus_one-1 > cts) ctx->min_cts_plus_one = cts + 1;\n\n\t\t\tif (e) return e;\n\t\t}\n\t\t//done with this track - if single track per moof, request new fragment but don't touch the\n\t\t//fragmentation state of the track writers\n\t\tif (ctx->straf && (i+1 < count)) {\n\t\t\tGF_ISOStartFragmentFlags flags = 0;\n\t\t\tif (ctx->moof_first) flags |= GF_ISOM_FRAG_MOOF_FIRST;\n#ifdef GF_ENABLE_CTRN\n\t\t\tif (ctx->ctrn) flags |= GF_ISOM_FRAG_USE_COMPACT;\n#endif\n\t\t\te = gf_isom_start_fragment(ctx->file, flags);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to start new fragment: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\tgf_isom_set_next_moof_number(ctx->file, ctx->msn);\n\t\t\tctx->msn++;\n\t\t\tif (ctx->sdtp_traf)\n\t\t\t\tgf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRAF_USE_SAMPLE_DEPS_BOX, ctx->sdtp_traf);\n\t\t}\n\t}\n\n\t//all suspended tracks done, flush fragment\n\tif (nb_suspended && (nb_suspended==count)) {\n\t\tnb_done = count;\n\t}\n\n\n\tif (nb_done==count) {\n\t\t//nothing open (this happens when flushing segments/fragments)\n\t\tif (!ctx->segment_started && !ctx->fragment_started)\n\t\t\tgoto check_eos;\n\n\t\tBool is_eos = (count == nb_eos) ? GF_TRUE : GF_FALSE;\n\t\tu32 ref_timescale;\n\t\tBool flush_refs = ctx->dash_mode ? GF_FALSE : GF_TRUE;\n\t\tu64 next_ref_ts = ctx->ref_tkw->next_seg_cts;\n\t\tif (is_eos)\n\t\t\tnext_ref_ts = ctx->ref_tkw->cts_next;\n\n\t\tref_timescale = ctx->ref_tkw->src_timescale;\n\t\t//both in ms\n\t\tctx->next_seg_start = (u64) gf_timestamp_rescale(next_ref_ts, ref_timescale, 1000);\n\t\tctx->min_cts_next_frag = (u64) gf_timestamp_rescale(ctx->next_frag_start, ctx->cdur.den, 1000);\n\n\t\tctx->next_frag_start += ctx->cdur.num;\n\t\twhile (ctx->next_frag_start <= ctx->adjusted_next_frag_start) {\n\t\t\tctx->next_frag_start += ctx->cdur.num;\n\t\t}\n\t\tctx->adjusted_next_frag_start = ctx->next_frag_start;\n\n\t\tmp4mx_frag_box_patch(ctx);\n\n\t\t//end of DASH segment\n\t\tif (ctx->dash_mode && (ctx->flush_seg || is_eos) ) {\n\t\t\tu64 offset = ctx->single_file ? ctx->current_offset : 0;\n\t\t\tu64 idx_start_range, idx_end_range, segment_size_in_bytes;\n\t\t\ts32 subs_sidx = -1;\n\t\t\tu32 track_ref_id = 0;\n\n\t\t\tidx_start_range = idx_end_range = 0;\n\t\t\tif (ctx->subs_sidx>=0) {\n\t\t\t\tsubs_sidx = ctx->subs_sidx;\n\t\t\t\ttrack_ref_id = ctx->ref_tkw->track_id;\n\t\t\t}\n\t\t\tif (ctx->cloned_sidx && (ctx->subs_sidx!=-2) ) {\n\t\t\t\tsubs_sidx = (s32) ctx->cloned_sidx->nb_refs;\n\t\t\t\ttrack_ref_id = ctx->cloned_sidx->reference_ID;\n\t\t\t\tgf_isom_box_del((GF_Box *)ctx->cloned_sidx);\n\t\t\t\tctx->cloned_sidx = NULL;\n\t\t\t}\n\n\t\t\te = gf_isom_close_segment(ctx->file, subs_sidx, track_ref_id, ctx->ref_tkw->first_dts_in_seg_plus_one ? ctx->ref_tkw->first_dts_in_seg_plus_one-1 : 0,\n\t\t\t\tctx->ref_tkw->negctts_shift ? 0 : ctx->ref_tkw->ts_delay,\n\t\t\t\tnext_ref_ts, ctx->chain_sidx, ctx->ssix, ctx->sseg ? GF_FALSE : is_eos, GF_FALSE, ctx->eos_marker, &idx_start_range, &idx_end_range, &segment_size_in_bytes);\n\t\t\tctx->ref_tkw->first_dts_in_seg_plus_one = 0;\n\t\t\tif (e) return e;\n\t\t\tflush_refs = GF_TRUE;\n\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MP4Mux] Done writing segment %d - estimated next fragment times start %g end %g\\n\", ctx->dash_seg_num_plus_one - 1, ((Double)next_ref_ts)/ref_timescale, ((Double)ctx->next_frag_start)/ctx->cdur.den ));\n\n\t\t\tif (ctx->dash_mode != MP4MX_DASH_VOD) {\n\t\t\t\t//we need to wait for packet to be written\n\t\t\t\tif (ctx->seg_flush_state) {\n\t\t\t\t\tctx->flush_idx_start_range = offset + idx_start_range;\n\t\t\t\t\tctx->flush_idx_end_range = idx_end_range ? offset + idx_end_range : 0;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t\tmp4_mux_flush_seg(ctx, GF_FALSE, offset + idx_start_range, idx_end_range ? offset + idx_end_range : 0, !is_eos);\n\t\t\t} else if (ctx->vodcache==MP4MX_VODCACHE_REPLACE) {\n\t\t\t\tmp4_mux_flush_seg(ctx, GF_FALSE, 0, 0, GF_FALSE);\n\t\t\t} else {\n\t\t\t\tif (ctx->nb_seg_sizes == ctx->alloc_seg_sizes) {\n\t\t\t\t\t ctx->alloc_seg_sizes *= 2;\n\t\t\t\t\t if (!ctx->alloc_seg_sizes) ctx->alloc_seg_sizes = 10;\n\t\t\t\t\t ctx->seg_sizes = gf_realloc(ctx->seg_sizes, sizeof(u32) * ctx->alloc_seg_sizes);\n\t\t\t\t}\n\t\t\t\tassert(segment_size_in_bytes);\n\t\t\t\tctx->seg_sizes[ctx->nb_seg_sizes] = (u32) segment_size_in_bytes;\n\t\t\t\tctx->nb_seg_sizes++;\n\t\t\t}\n\t\t\t//we still need to send seg size info for for HLS !\n\t\t\tif (ctx->vodcache==MP4MX_VODCACHE_INSERT)\n\t\t\t\tmp4_mux_flush_seg(ctx, GF_FALSE, 0, 0, !is_eos);\n\t\t}\n\t\t//cannot flush in DASH mode if using sidx (vod single sidx or live 1 sidx/seg)\n\t\telse if (!ctx->dash_mode || ((ctx->subs_sidx<0) && (ctx->dash_mode<MP4MX_DASH_VOD) && !ctx->cloned_sidx) ) {\n\t\t\tgf_isom_flush_fragments(ctx->file, GF_FALSE);\n\t\t\tflush_refs = GF_TRUE;\n\t\t\t//if not in dash and EOS marker is set, inject marker after each fragment\n\t\t\tif (!ctx->dash_mode && ctx->eos_marker && ctx->fragment_started) {\n\t\t\t\tu8 data[8];\n\t\t\t\tmemset(data, 0, 8);\n\t\t\t\tdata[3] = 8;\n\t\t\t\tdata[4] = ctx->m4cc[0];\n\t\t\t\tdata[5] = ctx->m4cc[1];\n\t\t\t\tdata[6] = ctx->m4cc[2];\n\t\t\t\tdata[7] = ctx->m4cc[3];\n\t\t\t\tmp4_mux_on_data(ctx, data, 8, NULL, 0);\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MP4Mux] Done writing fragment - next fragment start time %g\\n\", ((Double)ctx->next_frag_start)/ctx->cdur.den ));\n\n\t\t\t//we need to wait for packet to be written\n\t\t\tif (ctx->seg_flush_state) {\n\t\t\t\tif (ctx->llhls_mode) ctx->flush_ll_hls = GF_TRUE;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\n\t\t\tif (ctx->llhls_mode) {\n\t\t\t\tmp4_mux_flush_frag_hls(ctx);\n\t\t\t}\n\n\t\t\tif (!ctx->dash_mode || ctx->flush_seg) {\n\t\t\t\tmp4_mux_flush_seg(ctx, GF_FALSE, 0, 0, !is_eos);\n\t\t\t}\n\t\t}\n\t\tctx->fragment_started = GF_FALSE;\n\n\t\tif (ctx->flush_seg) {\n\t\t\tctx->segment_started = GF_FALSE;\n\t\t\tctx->flush_seg = GF_FALSE;\n\t\t\tctx->dash_seg_num_plus_one = 0;\n\t\t\tctx->nb_segs++;\n\t\t\tctx->nb_frags_in_seg=0;\n\t\t}\n\t\t//destroy any pending refs\n\t\tif (flush_refs) {\n\t\t\twhile (gf_list_count(ctx->ref_pcks)) {\n\t\t\t\tGF_FilterPacket *pckr = gf_list_pop_back(ctx->ref_pcks);\n\t\t\t\tgf_filter_pck_unref(pckr);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nb_suspended && (nb_suspended==count)) {\n\t\tctx->nb_segs=0;\n\t\treturn mp4mx_reload_output(ctx);\n\t}\n\ncheck_eos:\n\tif (count == nb_eos) {\n\t\tif (ctx->dash_mode==MP4MX_DASH_VOD) {\n\t\t\tif (ctx->vodcache!=MP4MX_VODCACHE_ON) {\n\t\t\t\tctx->final_sidx_flush = GF_TRUE;\n\t\t\t\t//flush SIDX in given space - this will reserve 8 bytes for free box if not fitting\n\t\t\t\tgf_isom_flush_sidx(ctx->file, ctx->sidx_max_size, (ctx->sidx_size_exact || ctx->tfdt64) ? GF_TRUE : GF_FALSE);\n\t\t\t} else {\n\t\t\t\tu64 start_offset;\n\t\t\t\t//reenable packet dispatch\n\t\t\t\tctx->store_output = GF_FALSE;\n\t\t\t\tgf_isom_flush_sidx(ctx->file, 0, ctx->tfdt64);\n\t\t\t\t//flush sidx packet\n\t\t\t\tmp4mux_send_output(ctx);\n\n\t\t\t\tmp4_mux_flush_seg(ctx, GF_TRUE, ctx->current_offset, ctx->current_offset + ctx->current_size - 1, GF_FALSE);\n\n\t\t\t\tgf_fflush(ctx->tmp_store);\n\t\t\t\tctx->flush_size = gf_ftell(ctx->tmp_store);\n\t\t\t\tctx->flush_done = 0;\n\t\t\t\tgf_fseek(ctx->tmp_store, 0, SEEK_SET);\n\n\t\t\t\tif (ctx->seg_sizes) {\n\t\t\t\t\tstart_offset = ctx->current_offset;\n\t\t\t\t\tfor (i=0; i<ctx->nb_seg_sizes; i++) {\n\t\t\t\t\t\tctx->current_size = ctx->seg_sizes[i];\n\t\t\t\t\t\tmp4_mux_flush_seg(ctx, GF_FALSE, 0, 0, GF_FALSE);\n\t\t\t\t\t}\n\t\t\t\t\tctx->current_offset = start_offset;\n\t\t\t\t\tctx->current_size = 0;\n\n\t\t\t\t\tgf_free(ctx->seg_sizes);\n\t\t\t\t\tctx->seg_sizes = NULL;\n\t\t\t\t\tctx->alloc_seg_sizes = ctx->nb_seg_sizes = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//only destroy file if not dash or not onDemand, otherwise (regular dash) the file will be needed to append further segments\n\t\tif (ctx->dash_mode!=MP4MX_DASH_ON) {\n\t\t\t//only delete file in vod mode\n\t\t\tif (ctx->file) {\n\t\t\t\tgf_isom_close(ctx->file);\n\t\t\t\tctx->file = NULL;\n\t\t\t}\n\t\t}\n\n\t\tmp4mux_send_output(ctx);\n\n\t\tif (!ctx->flush_size) gf_filter_pid_set_eos(ctx->opid);\n\n\t\treturn ctx->flush_size ? GF_OK : GF_EOS;\n\t}\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\nstruct _service_info\n{\n\tu32 service_id;\n\tu64 first_ts_min;\n\tu32 nb_non_sparse, nb_non_sparse_ready;\n\tu32 nb_sparse, nb_sparse_ready;\n};\nstatic struct _service_info *get_service_info(GF_List *services, TrackWriter *tkw)\n{\n\tstruct _service_info *si;\n\tconst GF_PropertyValue *p = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_SERVICE_ID);\n\tu32 ID, i, count=gf_list_count(services);\n\tID = p ? p->value.uint : 0;\n\n\tfor (i=0; i<count; i++) {\n\t\tsi = gf_list_get(services, i);\n\t\tif (si->service_id == ID) return si;\n\t}\n\tGF_SAFEALLOC(si, struct _service_info)\n\tsi->service_id = ID;\n\tsi->first_ts_min = (u64) -1;\n\tgf_list_add(services, si);\n\treturn si;\n}\nstatic void del_service_info(GF_List *services)\n{\n\twhile (gf_list_count(services)) {\n\t\tstruct _service_info *si = gf_list_pop_back(services);\n\t\tgf_free(si);\n\t}\n\tgf_list_del(services);\n}\n\nstatic void mp4_mux_update_init_edit(GF_MP4MuxCtx *ctx, TrackWriter *tkw, u64 min_ts_service, Bool skip_adjust)\n{\n\t//compute offsets\n\ts64 dts_diff = ctx->tsalign ? gf_timestamp_rescale(min_ts_service, 1000000, tkw->src_timescale) : 0;\n\n\tif (!skip_adjust) {\n\t\tdts_diff = (s64) tkw->ts_shift - dts_diff;\n\t}\n\tif (ctx->is_rewind) dts_diff = -dts_diff;\n\t//negative could happen due to rounding, ignore them\n\tif (dts_diff <= (gf_sys_old_arch_compat() ? 0 : 1)) return;\n\n\t// dts_diff > 0, we need to delay the track\n\tu64 dur = gf_timestamp_rescale(dts_diff, tkw->src_timescale, ctx->moovts);\n\tif (dur) {\n\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\n\t\tgf_isom_set_edit(ctx->file, tkw->track_num, 0, dur, dts_diff, GF_ISOM_EDIT_EMPTY);\n\t\tgf_isom_set_edit(ctx->file, tkw->track_num, dur, 0, 0, GF_ISOM_EDIT_NORMAL);\n\t\ttkw->empty_init_dur = (u64) dur;\n\t}\n}\n\nstatic void mp4_mux_config_timing(GF_MP4MuxCtx *ctx)\n{\n\tif ((ctx->store>=MP4MX_MODE_FRAG) && !ctx->tsalign) {\n\t\tctx->config_timing = GF_FALSE;\n\t\treturn;\n\t}\n\tGF_List *services = gf_list_new();\n\tu32 i, count;\n\tBool not_ready, blocking_refs, has_ready;\n\nretry_all:\n\tcount = gf_list_count(ctx->tracks);\n\tnot_ready = GF_FALSE;\n\tblocking_refs = GF_FALSE;\n\thas_ready = GF_FALSE;\n\n\tfor (i=0; i<gf_list_count(services);i++) {\n\t\tstruct _service_info *si = gf_list_get(services, i);\n\t\tsi->nb_non_sparse = si->nb_non_sparse_ready = 0;\n\t\tsi->nb_sparse = si->nb_sparse_ready = 0;\n\t}\n\n\t//compute min dts of first packet on each track - this assume all tracks are synchronized, might need adjustment for MPEG4 Systems\n\tfor (i=0; i<count; i++) {\n\t\tu64 ts, dts_min;\n\t\tGF_FilterPacket *pck;\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tif (tkw->fake_track) continue;\n\t\t//get associated service\n\t\tstruct _service_info *si = get_service_info(services, tkw);\n\n\t\t//already setup (happens when new PIDs are declared after a packet has already been written on other PIDs)\n\t\tif (tkw->nb_samples) {\n\t\t\tdts_min = gf_timestamp_rescale(tkw->ts_shift, tkw->src_timescale, 1000000);\n\n\t\t\tif (si->first_ts_min > dts_min) {\n\t\t\t\tsi->first_ts_min = (u64) dts_min;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\nretry_pck:\n\t\tpck = gf_filter_pid_get_packet(tkw->ipid);\n\t\t//check this after fetching a packet since it may reconfigure the track\n\t\tif (!tkw->track_num) {\n\t\t\tif (gf_filter_pid_is_eos(tkw->ipid)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] PID has no input packet and configuration not known after 10 retries, aborting initial timing sync\\n\"));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnot_ready = GF_TRUE;\n\t\t\ttkw->ts_shift = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pck) {\n\t\t\tif (gf_filter_pck_is_blocking_ref(pck))\n\t\t\t\tblocking_refs = GF_TRUE;\n\t\t\tif (tkw->wait_sap) {\n\t\t\t\tGF_FilterSAPType sap = gf_filter_pck_get_sap(pck);\n\t\t\t\tBool seek = gf_filter_pck_get_seek_flag(pck);\n\t\t\t\tif (seek || !sap) {\n\t\t\t\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\t\t\t\t\tgoto retry_pck;\n\t\t\t\t} else {\n\t\t\t\t\ttkw->wait_sap = GF_FALSE;\n\n\t\t\t\t\tif (!ctx->wait_dts_plus_one) {\n\t\t\t\t\t\tctx->wait_dts_plus_one = 1 + gf_filter_pck_get_dts(pck);\n\t\t\t\t\t\tctx->wait_dts_timescale = tkw->src_timescale;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ctx->wait_dts_plus_one) {\n\t\t\t\tts = gf_filter_pck_get_dts(pck);\n\t\t\t\tif (ts==GF_FILTER_NO_TS)\n\t\t\t\t\tts = gf_filter_pck_get_cts(pck);\n\t\t\t\tif (ts==GF_FILTER_NO_TS)\n\t\t\t\t\tts=0;\n\n\t\t\t\tif (gf_timestamp_less(ts, tkw->src_timescale, (ctx->wait_dts_plus_one-1), ctx->wait_dts_timescale)) {\n\t\t\t\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\t\t\t\t\tgoto retry_pck;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswitch (tkw->stream_type) {\n\t\tcase GF_STREAM_VISUAL:\n\t\tcase GF_STREAM_AUDIO:\n\t\t\tsi->nb_non_sparse++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsi->nb_sparse++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!pck) {\n\t\t\t//eos (wether real or flush event), setup cenc\n\t\t\tif (gf_filter_pid_is_eos(tkw->ipid)) {\n\t\t\t\tif (tkw->cenc_state==CENC_NEED_SETUP)\n\t\t\t\t\tmp4_mux_cenc_update(ctx, tkw, NULL, CENC_CONFIG, 0, 0);\n\n\t\t\t\tif (!tkw->nb_samples) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_TREX_TEMPLATE);\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\tgf_isom_setup_track_fragment_template(ctx->file, tkw->track_id, p->value.data.ptr, p->value.data.size, ctx->nofragdef);\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\t\t\t\tif (tkw->dgl_copy) {\n\t\t\t\t\tgf_filter_pck_discard(tkw->dgl_copy);\n\t\t\t\t\ttkw->dgl_copy = NULL;\n\t\t\t\t}\n\t\t\t\tswitch (tkw->stream_type) {\n\t\t\t\tcase GF_STREAM_VISUAL:\n\t\t\t\tcase GF_STREAM_AUDIO:\n\t\t\t\t\tsi->nb_non_sparse_ready++;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tsi->nb_sparse_ready++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttkw->ts_shift = 0;\n\t\t\ttkw->si_min_ts_plus_one = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t//we may have reorder tracks after the get_packet, redo\n\t\tif (gf_list_find(ctx->tracks, tkw) != i) {\n\t\t\tgoto retry_all;\n\t\t}\n\t\tts = gf_filter_pck_get_dts(pck);\n\t\tif (ts==GF_FILTER_NO_TS)\n\t\t\tts = gf_filter_pck_get_cts(pck);\n\t\tif (ts==GF_FILTER_NO_TS)\n\t\t\tts=0;\n\n\t\tdts_min = gf_timestamp_rescale(ts, tkw->src_timescale, 1000000);\n\n\t\tif (si->first_ts_min > dts_min) {\n\t\t\tsi->first_ts_min = (u64) dts_min;\n\t\t\thas_ready = GF_TRUE;\n\t\t}\n\n\t\tswitch (tkw->stream_type) {\n\t\tcase GF_STREAM_VISUAL:\n\t\tcase GF_STREAM_AUDIO:\n\t\t\tsi->nb_non_sparse_ready++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsi->nb_sparse_ready++;\n\t\t\tbreak;\n\t\t}\n\n\t\ttkw->ts_shift = ts;\n\t\ttkw->si_min_ts_plus_one = 0;\n\t}\n\n\tfor (i=0; i<gf_list_count(services); i++) {\n\t\tstruct _service_info *si = gf_list_get(services, i);\n\t\t//if some non-sparse streams are not ready, try to wait\n\t\tif (si->nb_non_sparse) {\n\t\t\tif (si->nb_non_sparse > si->nb_non_sparse_ready) not_ready = GF_TRUE;\n\t\t}\n\t\t//otherwise (only sparse stream), wait until first\n\t\telse if (si->nb_sparse) {\n\t\t\tif (!si->nb_sparse_ready) not_ready = GF_TRUE;\n\t\t}\n\t}\n\n\tif (not_ready) {\n\t\tif (blocking_refs && has_ready) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Blocking input packets present, aborting initial timing sync\\n\"));\n\t\t}\n\t\t//this may be quite long until we have a packet in case input pid is video encoding \n\t\telse if (ctx->config_retry_start && (gf_sys_clock() - ctx->config_retry_start > 10000)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] No input packets present on one or more inputs for more than 10s, aborting initial timing sync\\n\"));\n\t\t} else {\n\t\t\tctx->config_retry_start = gf_sys_clock();\n\t\t\tdel_service_info(services);\n\t\t\treturn;\n\t\t}\n\t}\n\tctx->config_retry_start = 0;\n\tfor (i=0; i<gf_list_count(services); i++) {\n\t\tstruct _service_info *si = gf_list_get(services, i);\n\t\tif (si->first_ts_min==(u64)-1)\n\t\t\tsi->first_ts_min = 0;\n\t}\n\n\t//for all packets with dts greater than min dts, we need to add a pause\n\tfor (i=0; i<count; i++) {\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tstruct _service_info *si = get_service_info(services, tkw);\n\t\tif (tkw->si_min_ts_plus_one) {\n\t\t\ttkw->si_min_ts_plus_one = si->first_ts_min + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//if single text track don't reset back to 0\n\t\tmp4_mux_update_init_edit(ctx, tkw, si->first_ts_min, ((count==1) && (tkw->stream_type == GF_STREAM_TEXT)) ? GF_TRUE : GF_FALSE);\n\t}\n\n\tctx->config_timing = GF_FALSE;\n\tdel_service_info(services);\n}\n\nvoid mp4_mux_format_report(GF_MP4MuxCtx *ctx, u64 done, u64 total)\n{\n\tBool status_changed=GF_FALSE;\n\tu32 total_pc = 0;\n\tchar *status = NULL, szTmp[2048], szTK[20];\n\tif (!gf_filter_reporting_enabled(ctx->filter))\n\t\treturn;\n\tif (!ctx->update_report)\n\t\treturn;\n\n\tctx->update_report = GF_FALSE;\n\n\tif (ctx->config_timing) {\n\t\tgf_dynstrcat(&status, \"waiting for clock init\", NULL);\n\t\tstatus_changed = GF_TRUE;\n\t} else if (total) {\n\t\tif (done>=total) {\n\t\t\tDouble ohead = 0;\n\t\t\tif (ctx->total_bytes_in) ohead =  ((Double) (ctx->total_bytes_out - ctx->total_bytes_in)*100 / ctx->total_bytes_in);\n\n\t\t\tsprintf(szTmp, \"done %d samples - bytes \"LLU\" in \"LLU\" out - overhead %02.02f%% (%02.02g B/sample)\", ctx->total_samples, ctx->total_bytes_in, ctx->total_bytes_out, ohead, ((Double)(ctx->total_bytes_out-ctx->total_bytes_in))/ctx->total_samples);\n\t\t\tstatus_changed = GF_TRUE;\n\t\t\ttotal_pc = 10000;\n\n\t\t} else {\n\t\t\tu32 pc = (u32) ((done*10000)/total);\n\t\t\tif (ctx->last_mux_pc == pc + 1) return;\n\t\t\tctx->last_mux_pc = pc + 1;\n\t\t\tsprintf(szTmp, \"mux %d%%\", pc);\n\t\t\tstatus_changed = GF_TRUE;\n\t\t}\n\t\tgf_dynstrcat(&status, szTmp, NULL);\n\t} else {\n\t\tu32 i, count = gf_list_count(ctx->tracks);\n\t\tBool is_frag = GF_FALSE;\n\n\t\tif (ctx->store>=MP4MX_MODE_FRAG) {\n\t\t\tDouble next = ((Double)ctx->next_frag_start)/ctx->cdur.den;\n\t\t\tis_frag = GF_TRUE;\n\t\t\tif (ctx->dash_mode) {\n\t\t\t\tsprintf(szTmp, \"mux segments %d (frags %d) next %02.3f\", ctx->nb_segs, ctx->nb_frags_in_seg, next);\n\t\t\t} else {\n\t\t\t\tsprintf(szTmp, \"mux frags %d next %02.3f\", ctx->nb_frags, next);\n\t\t\t}\n\t\t} else {\n\t\t\tsprintf(szTmp, \"%s\", ((ctx->store==MP4MX_MODE_FLAT) || (ctx->store==MP4MX_MODE_FASTSTART)) ? \"mux\" : \"import\");\n\t\t}\n\t\tgf_dynstrcat(&status, szTmp, NULL);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 pc=0;\n\t\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\t\tif (tkw->aborted) {\n\t\t\t\tpc=10000;\n\t\t\t} else if (ctx->dur.num) {\n\t\t\t\tif (ctx->dur.num>0) {\n\t\t\t\t\tu64 mdur = gf_isom_get_media_duration(ctx->file, tkw->track_num);\n\t\t\t\t\tu64 tk_done = mdur * ctx->dur.den;\n\t\t\t\t\tu64 tk_total = ((u64)tkw->tk_timescale) * ctx->dur.num;\n\t\t\t\t\tpc = (u32) ((tk_done*10000)/tk_total);\n\t\t\t\t} else {\n\t\t\t\t\tpc = (u32) ( (10000 * (u64) (tkw->nb_samples + tkw->frame_offset) ) / (-ctx->dur.num) );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (tkw->nb_frames) {\n\t\t\t\t\tpc = (u32) ( (10000 * (u64) (tkw->nb_samples + tkw->frame_offset)) / tkw->nb_frames);\n\t\t\t\t} else {\n\t\t\t\t\tif (tkw->pid_dur.num && tkw->pid_dur.den) {\n\t\t\t\t\t\tpc = (u32) ((tkw->sample.DTS*10000 * tkw->pid_dur.den) / (tkw->pid_dur.num * tkw->tk_timescale));\n\t\t\t\t\t} else if (tkw->down_bytes && tkw->down_size) {\n\t\t\t\t\t\tpc = (u32) (((tkw->down_bytes*10000) / tkw->down_size));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pc>10000)\n\t\t\t\tpc=0;\n\t\t\tif (tkw->last_import_pc != pc + 1) {\n\t\t\t\tstatus_changed = GF_TRUE;\n\t\t\t\ttkw->last_import_pc = pc + 1;\n\t\t\t}\n\t\t\tif (!total_pc || (total_pc > pc))\n\t\t\t\ttotal_pc = pc;\n\n\t\t\tif (is_frag) {\n\t\t\t\tsprintf(szTK, \" TK%d(%c): %d\", tkw->track_id, tkw->status_type, tkw->samples_in_frag);\n\t\t\t\tgf_dynstrcat(&status, szTK, NULL);\n\t\t\t\tstatus_changed = GF_TRUE;\n\t\t\t\tif (pc) {\n\t\t\t\t\tsprintf(szTK, \" %d %%\", pc/100);\n\t\t\t\t\tgf_dynstrcat(&status, szTK, NULL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsprintf(szTK, \" %s%d(%c): %d %%\", tkw->is_item ? \"IT\" : \"TK\", tkw->track_id, tkw->status_type, pc/100);\n\t\t\t\tgf_dynstrcat(&status, szTK, NULL);\n\t\t\t}\n\t\t}\n\t}\n\tif (status_changed) {\n\t\tgf_filter_update_status(ctx->filter, total_pc, status);\n\t}\n\tif (status) gf_free(status);\n}\n\nstatic void mp4_mux_flush_seg_events(GF_MP4MuxCtx *ctx);\n\nGF_Err mp4_mux_process(GF_Filter *filter)\n{\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\tu32 nb_skip, nb_eos, nb_suspended, i, count = gf_list_count(ctx->tracks);\n\tnb_skip = 0;\n\tnb_eos = 0;\n\n\tif (ctx->config_timing) {\n\t\tmp4_mux_config_timing(ctx);\n\t\tif (ctx->config_timing) {\n\t\t\tmp4_mux_format_report(ctx, 0, 0);\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\t//fragmented mode\n\tif (ctx->store>=MP4MX_MODE_FRAG) {\n\t\tu32 done=0;\n\t\t//postpone until no pending connections, otherwise we will create init segment without all tracks\n\t\tif (gf_filter_connections_pending(filter))\n\t\t\treturn GF_OK;\n\n\t\tif (ctx->seg_flush_state==1) return GF_OK;\n\t\telse if (ctx->seg_flush_state==2)\n\t\t\tmp4_mux_flush_seg_events(ctx);\n\n\t\tGF_Err e = mp4_mux_process_fragmented(ctx);\n\t\tif (e==GF_EOS) done=100;\n\t\tmp4_mux_format_report(ctx, done, done);\n\t\treturn e;\n\t}\n\n\t//regular mode\n\tnb_suspended = 0;\n\tfor (i=0; i<count; i++) {\n\t\tGF_Err e;\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tGF_FilterPacket *pck = gf_filter_pid_get_packet(tkw->ipid);\n\n\t\tif (tkw->suspended) {\n\t\t\tnb_suspended++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!pck) {\n\t\t\tif (gf_filter_pid_is_eos(tkw->ipid) && !gf_filter_pid_is_flush_eos(tkw->ipid)) {\n\t\t\t\ttkw->suspended = GF_FALSE;\n\t\t\t\tnb_eos++;\n\t\t\t}\n\t\t\tif (tkw->aborted) {\n\t\t\t\tnb_eos++;\n\t\t\t}\n\t\t\tif (ctx->store==MP4MX_MODE_FASTSTART) {\n\t\t\t\tnb_skip++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (tkw->aborted) {\n\t\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\t\t\tnb_eos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ctx->owns_mov) {\n\t\t\tconst GF_PropertyValue *p;\n\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILENUM);\n\t\t\tif (p) {\n\t\t\t\tif (!ctx->cur_file_idx_plus_one) {\n\t\t\t\t\tctx->cur_file_idx_plus_one = p->value.uint + 1;\n\t\t\t\t\tif (!ctx->cur_file_suffix) {\n\t\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILESUF);\n\t\t\t\t\t\tif (p && p->value.string) ctx->cur_file_suffix = gf_strdup(p->value.string);\n\t\t\t\t\t}\n\t\t\t\t\tctx->notify_filename = GF_TRUE;\n\t\t\t\t} else if (ctx->cur_file_idx_plus_one == p->value.uint+1) {\n\t\t\t\t} else if (!tkw->suspended) {\n\t\t\t\t\ttkw->suspended = GF_TRUE;\n\t\t\t\t\tnb_suspended++;\n\t\t\t\t\tctx->next_file_idx =  p->value.uint + 1;\n\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILESUF);\n\t\t\t\t\tif (p && p->value.string)\n\t\t\t\t\t\tctx->next_file_suffix = p->value.string;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//basic regulation in case we do on-the-fly interleaving\n\t\t//we need to regulate because sources do not produce packets at the same rate\n\t\tif (ctx->store==MP4MX_MODE_FASTSTART) {\n\t\t\tu64 cts = gf_filter_pck_get_cts(pck);\n\t\t\tif (ctx->is_rewind)\n\t\t\t\tcts = tkw->ts_shift - cts;\n\t\t\telse\n\t\t\t\tcts -= tkw->ts_shift;\n\n\t\t\tif (!ctx->faststart_ts_regulate.num) {\n\t\t\t\tctx->faststart_ts_regulate = ctx->cdur;\n\t\t\t}\n\t\t\t//ahead of our interleaving window, don't write yet\n\t\t\telse if (gf_timestamp_greater(cts, tkw->src_timescale, ctx->faststart_ts_regulate.num, ctx->faststart_ts_regulate.den)) {\n\t\t\t\tnb_skip++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (tkw->cenc_state==CENC_NEED_SETUP)\n\t\t\tmp4_mux_cenc_update(ctx, tkw, pck, CENC_CONFIG, 0, 0);\n\n\t\tif (tkw->is_item) {\n\t\t\te = mp4_mux_process_item(ctx, tkw, pck);\n\t\t} else {\n\t\t\te = mp4_mux_process_sample(ctx, tkw, pck, GF_FALSE);\n\t\t}\n\n\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\t\tif (tkw->aborted) {\n\t\t\tnb_eos++;\n\t\t}\n\t\tif (e) return e;\n\t}\n\tmp4_mux_format_report(ctx, 0, 0);\n\n\tif (nb_suspended && (nb_suspended+nb_eos==count)) {\n\t\treturn mp4mx_reload_output(ctx);\n\t}\n\n\tif (count == nb_eos) {\n\t\tif (ctx->file) {\n\t\t\tGF_Err e = mp4_mux_done(ctx, GF_TRUE);\n\t\t\tif (e) return e;\n\t\t}\n\t\treturn GF_EOS;\n\t}\n\t//done with this interleaving window, start next one\n\telse if (nb_skip + nb_eos >= count) {\n\t\tctx->faststart_ts_regulate.num += ctx->cdur.num;\n\t} else if (ctx->importer) {\n\t\tu64 prog_done=0, prog_total=0;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\t\tprog_done += tkw->prog_done;\n\t\t\tprog_total += tkw->prog_total;\n\t\t}\n\t\tgf_set_progress(\"Import\", prog_done, prog_total);\n\t}\n\n\treturn GF_OK;\n}\n\nstatic GF_Err mp4_mux_on_data_patch(void *cbk, u8 *data, u32 block_size, u64 file_offset, Bool is_insert)\n{\n\tGF_MP4MuxCtx *ctx = (GF_MP4MuxCtx *) cbk;\n\tu8 *output;\n\n\tGF_FilterPacket *pck = gf_filter_pck_new_alloc(ctx->opid, block_size, &output);\n\tif (!pck) return GF_OUT_OF_MEM;\n\n\tmemcpy(output, data, block_size);\n\tgf_filter_pck_set_framing(pck, GF_FALSE, GF_FALSE);\n\tgf_filter_pck_set_seek_flag(pck, GF_TRUE);\n\tif (is_insert)\n\t\tgf_filter_pck_set_interlaced(pck, 1);\n\tgf_filter_pck_set_byte_offset(pck, file_offset);\n\tgf_filter_pck_send(pck);\n\treturn GF_OK;\n}\n\nstatic void mp4_mux_flush_seg_events(GF_MP4MuxCtx *ctx)\n{\n\tif (ctx->flush_ll_hls) {\n\t\tmp4_mux_flush_frag_hls(ctx);\n\t}\n\n\tif (!ctx->dash_mode || ctx->flush_seg) {\n\t\tmp4_mux_flush_seg(ctx, GF_FALSE, ctx->flush_idx_start_range, ctx->flush_idx_end_range, GF_FALSE);\n\t}\n\n\tctx->fragment_started = GF_FALSE;\n\n\tif (ctx->flush_seg) {\n\t\tctx->segment_started = GF_FALSE;\n\t\tctx->flush_seg = GF_FALSE;\n\t\tctx->dash_seg_num_plus_one = 0;\n\t\tctx->nb_segs++;\n\t\tctx->nb_frags_in_seg=0;\n\t}\n\tctx->seg_flush_state = 0;\n\tctx->flush_idx_start_range = 0;\n\tctx->flush_idx_end_range = 0;\n\tctx->flush_ll_hls = GF_FALSE;\n}\n\nstatic void mp4_mux_on_packet_destruct(GF_Filter *filter, GF_FilterPid *PID, GF_FilterPacket *pck)\n{\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\t//no need to lock filter here, only this callback modifies the state\n\tctx->seg_flush_state = 2;\n\tgf_filter_post_process_task(filter);\n}\n\nstatic void mp4_mux_on_last_block_start(void *cbk)\n{\n\tGF_MP4MuxCtx *ctx = (GF_MP4MuxCtx *) cbk;\n\tif (ctx->force_seg_sync)\n\t\tctx->seg_flush_state = 1;\n}\n\nstatic GF_Err mp4_mux_on_data(void *cbk, u8 *data, u32 block_size, void *cbk_data, u32 cbk_magic)\n{\n\tGF_MP4MuxCtx *ctx = (GF_MP4MuxCtx *) cbk;\n\tu8 *output;\n\tu32 src_pck_dur=0;\n\n\tctx->total_bytes_out += block_size;\n\n\t//flush pending packet in frag mode\n\tmp4mux_send_output(ctx);\n\n\tif (ctx->final_sidx_flush) {\n\t\tGF_FilterPacket *pck;\n\t\tu32 free_size=0;\n\n\t\tif (ctx->vodcache==MP4MX_VODCACHE_INSERT) {\n\t\t\tpck = gf_filter_pck_new_alloc(ctx->opid, block_size, &output);\n\t\t\tif (!pck) return GF_OUT_OF_MEM;\n\n\t\t\tmemcpy(output, data, block_size);\n\t\t\tgf_filter_pck_set_framing(pck, GF_FALSE, GF_FALSE);\n\t\t\tgf_filter_pck_set_byte_offset(pck, ctx->sidx_chunk_offset);\n\t\t\tgf_filter_pck_set_seek_flag(pck, GF_TRUE);\n\t\t\tgf_filter_pck_set_interlaced(pck, 1);\n\t\t\tgf_filter_pck_send(pck);\n\t\t} else {\n\t\t\tGF_BitStream *bs;\n\t\t\tassert(!ctx->dst_pck);\n\n\t\t\tif (block_size > ctx->sidx_max_size) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Final SIDX chunk larger than preallocated block, will not flush SIDX (output file still readable). Try disabling nocache mode\\n\"));\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tfree_size = ctx->sidx_max_size - block_size;\n\t\t\tpck = gf_filter_pck_new_alloc(ctx->opid, ctx->sidx_max_size, &output);\n\t\t\tif (!pck) return GF_OUT_OF_MEM;\n\n\t\t\tgf_filter_pck_set_framing(pck, GF_FALSE, GF_FALSE);\n\t\t\tgf_filter_pck_set_byte_offset(pck, ctx->sidx_chunk_offset);\n\t\t\tgf_filter_pck_set_seek_flag(pck, GF_TRUE);\n\t\t\tbs = gf_bs_new(output, ctx->sidx_max_size, GF_BITSTREAM_WRITE);\n\t\t\tif (free_size) {\n\t\t\t\tgf_bs_write_u32(bs, free_size);\n\t\t\t\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_FREE);\n\t\t\t\tgf_bs_skip_bytes(bs, free_size-8);\n\t\t\t}\n\t\t\tgf_bs_write_data(bs, data, block_size);\n\t\t\tgf_bs_del(bs);\n\t\t\tgf_filter_pck_send(pck);\n\t\t}\n\t\tmp4_mux_flush_seg(ctx, GF_TRUE, ctx->sidx_chunk_offset+free_size, ctx->sidx_chunk_offset+free_size + block_size - 1, GF_FALSE);\n\t\treturn GF_OK;\n\t}\n\n\tif (ctx->store_output) {\n\t\tu32 nb_write = (u32) gf_fwrite(data, block_size, ctx->tmp_store);\n\t\tif (nb_write != block_size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error writing to temp cache: %d bytes write instead of %d\\n\", nb_write, block_size));\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tGF_FilterPacket *srcp = (GF_FilterPacket *)cbk_data;\n\tif (srcp && gf_list_find(ctx->ref_pcks, srcp)<0) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Data callback on non-existing packet reference !\\n\"));\n\t\treturn GF_IO_ERR;\n\t}\n\n\tif (srcp) {\n\t\tif (ctx->seg_flush_state) {\n\t\t\tctx->dst_pck = gf_filter_pck_new_ref_destructor(ctx->opid, cbk_magic, block_size, srcp, mp4_mux_on_packet_destruct);\n\t\t} else {\n\t\t\tctx->dst_pck = gf_filter_pck_new_ref(ctx->opid, cbk_magic, block_size, srcp);\n\t\t}\n\t\tgf_list_del_item(ctx->ref_pcks, srcp);\n\t\tsrc_pck_dur = gf_timestamp_rescale(gf_filter_pck_get_duration(srcp), gf_filter_pck_get_timescale(srcp), 1000);\n\t\tgf_filter_pck_unref(srcp);\n\t}\n\t//allocate new one\n\telse if (ctx->seg_flush_state) {\n\t\tctx->dst_pck = gf_filter_pck_new_alloc_destructor(ctx->opid, block_size, &output, mp4_mux_on_packet_destruct);\n\t} else {\n\t\tctx->dst_pck = gf_filter_pck_new_alloc(ctx->opid, block_size, &output);\n\t}\n\tif (!ctx->dst_pck) return GF_OUT_OF_MEM;\n\n\tif (!cbk_data)\n\t\tmemcpy(output, data, block_size);\n\tgf_filter_pck_set_framing(ctx->dst_pck, !ctx->first_pck_sent, GF_FALSE);\n\n\t//set packet prop as string since we may discard the seg_name  packet before this packet is processed\n\tif (!ctx->first_pck_sent && ctx->seg_name) {\n\t\tctx->current_offset = 0;\n\t\tgf_filter_pck_set_property(ctx->dst_pck, GF_PROP_PCK_FILENAME, &PROP_STRING(ctx->seg_name) );\n\t\tgf_filter_pck_set_property(ctx->dst_pck, GF_PROP_PCK_FILENUM, &PROP_UINT(ctx->dash_seg_num_plus_one-1) );\n\t}\n\n\tif (ctx->min_cts_plus_one) {\n\t\tu64 orig = ctx->min_cts_plus_one-1;\n\t\tgf_filter_pck_set_cts(ctx->dst_pck, orig);\n\t\t//if we have a source packet duration, use it\n\t\tif (src_pck_dur)\n\t\t\tgf_filter_pck_set_duration(ctx->dst_pck, src_pck_dur);\n\t\t//it may happen that we don't know precisely the min_cts_next_frag, this is a rough compute based on desire frag dur\n\t\t//if duration is wrong, signal to send asap (dur = 1)\n\t\telse if (ctx->min_cts_next_frag > orig)\n\t\t\tgf_filter_pck_set_duration(ctx->dst_pck, (u32) (ctx->min_cts_next_frag - orig) );\n\t\telse\n\t\t\tgf_filter_pck_set_duration(ctx->dst_pck, 1);\n\t}\n\n\tif ((ctx->llhls_mode>1) && ctx->fragment_started && !ctx->frag_size && ctx->dst_pck) {\n\t\tctx->frag_num++;\n\t\tgf_filter_pck_set_property(ctx->dst_pck, GF_PROP_PCK_HLS_FRAG_NUM, &PROP_UINT(ctx->frag_num));\n\t}\n\tctx->frag_size += block_size;\n\n\tctx->first_pck_sent = GF_TRUE;\n\tctx->current_size += block_size;\n\t//non-frag mode, send right away\n\tif ((ctx->store<MP4MX_MODE_FRAG) || ctx->seg_flush_state) {\n\t\tmp4mux_send_output(ctx);\n\t}\n\treturn GF_OK;\n}\n\nvoid mp4_mux_progress_cbk(void *udta, u64 done, u64 total)\n{\n\tGF_Filter *filter = (GF_Filter *)udta;\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\tctx->update_report = GF_TRUE;\n\tmp4_mux_format_report(ctx, done, total);\n}\n\nstatic GF_Err mp4_mux_initialize(GF_Filter *filter)\n{\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\tgf_filter_set_max_extra_input_pids(filter, -1);\n\tctx->filter = filter;\n#ifdef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (ctx->store>=MP4MX_MODE_FRAG) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot use fragmented mode, disabled in build\\n\"));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n#endif\n\tif (ctx->file) {\n\t\tif (gf_isom_get_mode(ctx->file) < GF_ISOM_OPEN_WRITE) return GF_BAD_PARAM;\n\t\tif (ctx->store>=MP4MX_MODE_FRAG) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot use fragmented output on already opened ISOBMF file\\n\"));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tctx->owns_mov = GF_FALSE;\n\t\tgf_filter_act_as_sink(filter);\n\t} else {\n\t\tu32 open_mode = GF_ISOM_OPEN_WRITE;\n\t\tctx->owns_mov = GF_TRUE;\n\n\t\tswitch (ctx->store) {\n\t\tcase MP4MX_MODE_INTER:\n\t\tcase MP4MX_MODE_TIGHT:\n\t\t\topen_mode = GF_ISOM_WRITE_EDIT;\n\t\t\tbreak;\n\t\t}\n\t\tctx->file = gf_isom_open(\"_gpac_isobmff_redirect\", open_mode, NULL);\n\t\tif (!ctx->file) return GF_OUT_OF_MEM;\n\n\t\tgf_isom_set_write_callback(ctx->file, mp4_mux_on_data, mp4_mux_on_data_patch, mp4_mux_on_last_block_start, ctx, ctx->block_size);\n\n\t\tgf_isom_set_progress_callback(ctx->file, mp4_mux_progress_cbk, filter);\n\n\t\tif (ctx->dref && (ctx->store>=MP4MX_MODE_FRAG)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot use data reference in movie fragments, not supported. Ignoring it\\n\"));\n\t\t\tctx->dref = GF_FALSE;\n\t\t}\n\n\t\tif (ctx->store==MP4MX_MODE_FASTSTART) {\n\t\t\tgf_isom_set_storage_mode(ctx->file, GF_ISOM_STORE_FASTSTART);\n\t\t}\n\t}\n\n\tif (!ctx->moovts)\n\t\tctx->moovts=600;\n\n\tif ((ctx->store==MP4MX_MODE_FASTSTART) && (!ctx->cdur.num || !ctx->cdur.den)) {\n\t\tctx->cdur.num = 1;\n\t\tctx->cdur.den = 1;\n\t}\n\tif (!ctx->cdur.den) {\n\t\tctx->cdur.num = 0;\n\t\tctx->cdur.den = 1000;\n\t}\n\t//we need at least ms precision for sfrag mode\n\tif (ctx->cdur.den < 1000) {\n\t\tctx->cdur.num = (s32) ( ((s64)ctx->cdur.num) * 1000 / ctx->cdur.den);\n\t\tctx->cdur.den = 1000;\n\t}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (ctx->mfra && (ctx->store>=MP4MX_MODE_FRAG)) {\n\t\tGF_Err e = gf_isom_enable_mfra(ctx->file);\n\t\tif (e) return e;\n\t}\n#endif\n\n\tif (!ctx->tracks)\n\t\tctx->tracks = gf_list_new();\n\n\tif (!ctx->ref_pcks)\n\t\tctx->ref_pcks = gf_list_new();\n\n#ifdef GF_ENABLE_CTRN\n\tif (ctx->ctrni)\n\t\tctx->ctrn = GF_TRUE;\n#endif\n\n\tif (ctx->m4cc) {\n\t\tif (strlen(ctx->m4cc)==4)\n\t\t\tctx->eos_marker = GF_4CC(ctx->m4cc[0], ctx->m4cc[1], ctx->m4cc[2], ctx->m4cc[3]);\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Invalid segment marker 4cc %s, ignoring\\n\", ctx->m4cc));\n\t\t}\n\t}\n\tif (ctx->compress) {\n\t\tu32 flags = 0;\n\t\tif (ctx->fcomp) flags |= GF_ISOM_COMP_FORCE_ALL;\n\t\tif (ctx->otyp) flags |= GF_ISOM_COMP_WRAP_FTYPE;\n\t\tgf_isom_enable_compression(ctx->file, ctx->compress, flags);\n\t}\n\n\tif ((ctx->store>=MP4MX_MODE_FRAG) && !ctx->tsalign)\n\t\tctx->insert_tfdt = GF_TRUE;\n\n\tif (ctx->cmaf) {\n\t\t//cf table 3, 4, 5 of CMAF\n\t\tctx->mvex = GF_TRUE;\n\t\tctx->truns_first = GF_TRUE;\n\t\t//single trun, single traf (table 5 of CMAF)\n\t\tctx->strun = GF_TRUE;\n\t\tctx->straf = GF_TRUE;\n\t\t//7.5.16 Every TrackFragmentBox shall contain a TrackFragmentBaseMediaDecodeTimeBox\n\t\tctx->tfdt_traf = GF_TRUE;\n\t\t//7.3.3 : If SegmentIndexBoxes exist, each subsegment referenced in the SegmentIndexBox shall be a single CMAF fragment\n\t\tctx->chain_sidx = GF_FALSE;\n\t\tif (ctx->subs_sidx>0)\n\t\t\tctx->subs_sidx = 0;\n\n\t\tif (ctx->cmaf==MP4MX_CMAF_CMF2) {\n\t\t\t/*7.7 cmf2\n- default_sample_flags, sample_flags and first_sample_flags shall be set in the TrackFragmentHeaderBox and/or TrackRunBox to provide sample dependency information within each CMAF chunk and CMAF fragment.\n- Default values or per sample values of sample duration and sample size shall be stored in each CMAF chunk\u2019s TrackRunBox and/or TrackFragmentHeaderBox\n\t\t\t*/\n\t\t\tctx->nofragdef = GF_TRUE;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nstatic void mp4_mux_update_edit_list_for_bframes(GF_MP4MuxCtx *ctx, TrackWriter *tkw, u32 ctts_mode)\n{\n\tu64 max_cts, min_cts;\n\ts64 moffset;\n\n\tif (ctts_mode > MP4MX_CT_EDIT) return;\n\n\t//if we have a complex edit list (due to track template), don't override\n\tif (gf_isom_get_edit_list_type(ctx->file, tkw->track_num, &moffset)) return;\n\n\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\n\tmax_cts = tkw->max_cts - tkw->min_neg_ctts;\n\tmin_cts = tkw->min_cts - tkw->min_neg_ctts;\n\n\tif (min_cts || tkw->empty_init_dur) {\n\t\tmax_cts -= min_cts;\n\t\tu32 count = gf_isom_get_sample_count(ctx->file, tkw->track_num);\n\t\tmax_cts += gf_isom_get_sample_duration(ctx->file, tkw->track_num, count);\n\n\t\tmax_cts = gf_timestamp_rescale(max_cts, tkw->tk_timescale, ctx->moovts);\n\n\t\tif (tkw->empty_init_dur) {\n\t\t\tgf_isom_set_edit(ctx->file, tkw->track_num, 0, tkw->empty_init_dur, 0, GF_ISOM_EDIT_EMPTY);\n\t\t}\n\t\t//old arch compat: if we had a simple edit list in source try to keep the original segduration indicated\n\t\t//we tolerate a diff of 100ms\n\t\telse if (gf_sys_old_arch_compat() && tkw->imported_edit_sdur && (tkw->imported_edit_offset==min_cts)) {\n\t\t\ts32 diff;\n\t\t\tu64 old_dur_ms = gf_timestamp_rescale(tkw->imported_edit_sdur, tkw->src_timescale, 1000);\n\t\t\tu64 new_dur_ms = gf_timestamp_rescale(max_cts, tkw->tk_timescale, 1000);\n\t\t\tdiff = (s32) new_dur_ms - (s32) old_dur_ms;\n\t\t\tif (ABS(diff)<100)\n\t\t\t\tmax_cts = tkw->imported_edit_sdur;\n\t\t}\n\n\t\tgf_isom_set_edit(ctx->file, tkw->track_num, tkw->empty_init_dur, max_cts, min_cts, GF_ISOM_EDIT_NORMAL);\n\t}\n}\n\n//todo: move from media_import.c to here once done\nvoid gf_media_update_bitrate(GF_ISOFile *file, u32 track);\n\n\nstatic void mp4_mux_set_hevc_groups(GF_MP4MuxCtx *ctx, TrackWriter *tkw)\n{\n\tu32 avc_base_track, hevc_base_track, ref_track_id;\n\tavc_base_track = hevc_base_track = 0;\n\tu32 i;\n\tu32 min_lid = 0;\n\tGF_PropertyEntry *pe=NULL;\n\tconst GF_PropertyValue *p = gf_filter_pid_get_info_str(tkw->ipid, \"hevc:oinf\", &pe);\n\tif (p) {\n\t\tu32 gi=0;\n\t\tgf_isom_remove_sample_group(ctx->file, tkw->track_num, GF_ISOM_SAMPLE_GROUP_OINF);\n\t\tgf_isom_add_sample_group_info(ctx->file, tkw->track_num, GF_ISOM_SAMPLE_GROUP_OINF, p->value.data.ptr, p->value.data.size, GF_TRUE, &gi);\n\t}\n\tp = gf_filter_pid_get_info_str(tkw->ipid, \"hevc:linf\", &pe);\n\tif (p) {\n\t\tu32 gi=0;\n\t\tgf_isom_remove_sample_group(ctx->file, tkw->track_num, GF_ISOM_SAMPLE_GROUP_LINF);\n\t\tgf_isom_add_sample_group_info(ctx->file, tkw->track_num, GF_ISOM_SAMPLE_GROUP_LINF, p->value.data.ptr, p->value.data.size, GF_TRUE, &gi);\n\t\tgf_isom_set_track_group(ctx->file, tkw->track_num, 1000+gf_isom_get_track_id(ctx->file, tkw->track_num), GF_ISOM_BOX_TYPE_CSTG, GF_TRUE);\n\t}\n\n\tp = gf_filter_pid_get_info_str(tkw->ipid, \"hevc:min_lid\", &pe);\n\tif (p) min_lid = p->value.uint;\n\n\tgf_filter_release_property(pe);\n\n\tif (!min_lid && (tkw->codecid!=GF_CODECID_LHVC)) {\n\t\treturn;\n\t}\n\t//set linf\n\tfor (i=0; i < gf_isom_get_track_count(ctx->file); i++) {\n\t\tu32 subtype = gf_isom_get_media_subtype(ctx->file, i+1, 1);\n\t\tswitch (subtype) {\n\t\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\t\tif (!avc_base_track) {\n\t\t\t\tavc_base_track = i+1;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Warning: More than one AVC bitstream found, use track %d as base layer\", avc_base_track));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t\tif (!hevc_base_track) {\n\t\t\t\thevc_base_track = i+1;\n\t\t\t\tif (avc_base_track) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Warning: Found both AVC and HEVC tracks, using HEVC track %d as base layer\\n\", hevc_base_track));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Warning: More than one HEVC bitstream found, use track %d as base layer\\n\", avc_base_track));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!hevc_base_track && !avc_base_track) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Using LHVC external base layer, but no base layer not found - NOT SETTING SBAS TRACK REFERENCE!\\n\"));\n\t} else {\n\t\tref_track_id = gf_isom_get_track_id(ctx->file, hevc_base_track ? hevc_base_track : avc_base_track);\n\t\tgf_isom_set_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_BASE, ref_track_id);\n\n\t\tif (hevc_base_track) {\n\t\t\tref_track_id = gf_isom_get_track_id(ctx->file, hevc_base_track);\n\t\t\tgf_isom_set_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_OREF, ref_track_id);\n\t\t\tgf_isom_remove_sample_group(ctx->file, tkw->track_num, GF_ISOM_SAMPLE_GROUP_OINF);\n\t\t}\n\t}\n}\n\nstatic GF_Err mp4_mux_done(GF_MP4MuxCtx *ctx, Bool is_final)\n{\n\tGF_Err e = GF_OK;\n\tu32 i, count;\n\tGF_PropertyEntry *pe=NULL;\n\n\tcount = gf_list_count(ctx->tracks);\n\tfor (i=0; i<count; i++) {\n\t\tu32 ctts_mode = ctx->ctmode;\n\t\tconst GF_PropertyValue *p;\n\t\tBool has_bframes = GF_FALSE;\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_FORCE_NEGCTTS);\n\t\tif (p && p->value.boolean) ctts_mode = MP4MX_CT_NEGCTTS;\n\n\t\tif (tkw->min_neg_ctts<0) {\n\t\t\t//use ctts v1 negative offsets\n\t\t\tif (ctts_mode==MP4MX_CT_NEGCTTS) {\n\t\t\t\tgf_isom_set_ctts_v1(ctx->file, tkw->track_num, (u32) -tkw->min_neg_ctts);\n\t\t\t}\n\t\t\t//ctts v0\n\t\t\telse {\n\t\t\t\tgf_isom_set_cts_packing(ctx->file, tkw->track_num, GF_TRUE);\n\t\t\t\tgf_isom_shift_cts_offset(ctx->file, tkw->track_num, (s32) tkw->min_neg_ctts);\n\t\t\t\tgf_isom_set_cts_packing(ctx->file, tkw->track_num, GF_FALSE);\n\t\t\t\tgf_isom_set_composition_offset_mode(ctx->file, tkw->track_num, GF_FALSE);\n\n\t\t\t\tmp4_mux_update_edit_list_for_bframes(ctx, tkw, ctts_mode);\n\t\t\t}\n\t\t\thas_bframes = GF_TRUE;\n\t\t} else if (tkw->has_ctts && (tkw->stream_type==GF_STREAM_VISUAL)) {\n\t\t\tmp4_mux_update_edit_list_for_bframes(ctx, tkw, ctts_mode);\n\n\t\t\thas_bframes = GF_TRUE;\n\t\t} else if (tkw->ts_delay || tkw->empty_init_dur) {\n\t\t\tgf_isom_update_edit_list_duration(ctx->file, tkw->track_num);\n\t\t}\n\n\t\tif (tkw->min_ts_seek_plus_one) {\n\t\t\tu64 min_ts = tkw->min_ts_seek_plus_one - 1;\n\t\t\tu64 mdur = gf_isom_get_media_duration(ctx->file, tkw->track_num);\n\t\t\tu32 delay = 0;\n\t\t\tif (tkw->clamp_ts_plus_one) {\n\t\t\t\tmdur = tkw->max_cts - tkw->min_cts;\n\t\t\t\tmdur += tkw->max_cts_samp_dur;\n\t\t\t}\n\t\t\tif (mdur > min_ts)\n\t\t\t\tmdur -= min_ts;\n\t\t\telse\n\t\t\t\tmdur = 0;\n\n\t\t\tif ((ctts_mode != MP4MX_CT_NEGCTTS) && (tkw->ts_delay<0) && (tkw->stream_type==GF_STREAM_VISUAL)) {\n\t\t\t\tdelay = (u32) -tkw->ts_delay;\n\t\t\t}\n\n\t\t\tif (tkw->src_timescale != tkw->tk_timescale) {\n\t\t\t\tmin_ts = gf_timestamp_rescale(min_ts, tkw->src_timescale, tkw->tk_timescale);\n\t\t\t\tdelay = (u32) gf_timestamp_rescale(delay, tkw->src_timescale, tkw->tk_timescale);\n\t\t\t}\n\t\t\tmdur += delay;\n\n\t\t\tif (ctx->moovts != tkw->tk_timescale) {\n\t\t\t\tmdur = gf_timestamp_rescale(mdur, tkw->tk_timescale, ctx->moovts);\n\t\t\t}\n\t\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\t\t\tif (tkw->empty_init_dur)\n\t\t\t\tgf_isom_set_edit(ctx->file, tkw->track_num, 0, tkw->empty_init_dur, 0, GF_ISOM_EDIT_EMPTY);\n\t\t\tgf_isom_set_edit(ctx->file, tkw->track_num, tkw->empty_init_dur, mdur, min_ts, GF_ISOM_EDIT_NORMAL);\n\t\t}\n\n\t\tif (tkw->force_ctts) {\n\t\t\tGF_Err gf_isom_force_ctts(GF_ISOFile *file, u32 track);\n\t\t\tgf_isom_force_ctts(ctx->file, tkw->track_num);\n\t\t}\n\n\t\tgf_isom_purge_track_reference(ctx->file, tkw->track_num);\n\t\t\n\t\tif (ctx->importer && ctx->dur.num && ctx->dur.den) {\n\t\t\tu64 mdur = gf_isom_get_media_duration(ctx->file, tkw->track_num);\n\t\t\tu64 pdur = gf_isom_get_track_duration(ctx->file, tkw->track_num);\n\t\t\tif (pdur==mdur) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[MP4Mux] Imported %d frames - duration %g\\n\", tkw->nb_samples, ((Double)mdur)/tkw->tk_timescale ));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[MP4Mux] Imported %d frames - media duration %g - track duration %g\\n\", tkw->nb_samples, ((Double)mdur)/tkw->tk_timescale, ((Double)pdur)/ctx->moovts ));\n\t\t\t}\n\t\t}\n\n\t\t/*this is plain ugly but since some encoders (divx) don't use the video PL correctly\n\t\t we force the system video_pl to ASP@L5 since we have I, P, B in base layer*/\n\t\tif (tkw->codecid == GF_CODECID_MPEG4_PART2) {\n\t\t\tBool force_rewrite = GF_FALSE;\n\t\t\tu32 PL = tkw->media_profile_level;\n\t\t\tif (!PL) PL = 0x01;\n\n\t\t\tif (ctx->importer) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"Indicated Profile: %s\\n\", gf_m4v_get_profile_name((u8) PL) ));\n\t\t\t}\n\n\t\t\tif (has_bframes && (tkw->media_profile_level <= 3)) {\n\t\t\t\tPL = 0xF5;\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Indicated profile doesn't include B-VOPs - forcing %s\\n\", gf_m4v_get_profile_name((u8) PL) ));\n\t\t\t\tforce_rewrite = GF_TRUE;\n\t\t\t}\n\t\t\tif (PL != tkw->media_profile_level) {\n\t\t\t\tif (force_rewrite) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tGF_ESD *esd = gf_isom_get_esd(ctx->file, tkw->track_num, tkw->stsd_idx);\n\t\t\t\t\tassert(esd);\n\t\t\t\t\tgf_m4v_rewrite_pl(&esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength, (u8) PL);\n\t\t\t\t\tgf_isom_change_mpeg4_description(ctx->file, tkw->track_num, tkw->stsd_idx, esd);\n\t\t\t\t\tgf_odf_desc_del((GF_Descriptor*)esd);\n#endif\n\n\t\t\t\t}\n\t\t\t\tif (!ctx->make_qt)\n\t\t\t\t\tgf_isom_set_pl_indication(ctx->file, GF_ISOM_PL_VISUAL, PL);\n\t\t\t}\n\t\t}\n\n\n\t\tif (tkw->has_append)\n\t\t\tgf_isom_refresh_size_info(ctx->file, tkw->track_num);\n\n\t\tif ((tkw->nb_samples == 1) && (ctx->dur.num>0) && ctx->dur.den) {\n\t\t\tu32 dur = (u32) gf_timestamp_rescale(ctx->dur.num, ctx->dur.den, tkw->tk_timescale);\n\t\t\tgf_isom_set_last_sample_duration(ctx->file, tkw->track_num, dur);\n\t\t}\n\n\t\tif (tkw->has_open_gop) {\n\t\t\tif (ctx->importer) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"OpenGOP detected - adjusting file brand\\n\"));\n\t\t\t}\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO6, GF_TRUE);\n\t\t}\n\n\t\tmp4_mux_set_hevc_groups(ctx, tkw);\n\n\t\tp = gf_filter_pid_get_info_str(tkw->ipid, \"ttxt:rem_last\", &pe);\n\t\tif (p && p->value.boolean)\n\t\t\tgf_isom_remove_sample(ctx->file, tkw->track_num, tkw->nb_samples);\n\n\t\tp = gf_filter_pid_get_info_str(tkw->ipid, \"ttxt:last_dur\", &pe);\n\t\tif (p) {\n\t\t\tu64 val = p->value.uint;\n\t\t\tif (tkw->src_timescale != tkw->tk_timescale) {\n\t\t\t\tval = gf_timestamp_rescale(val, tkw->src_timescale, tkw->tk_timescale);\n\t\t\t}\n\t\t\tgf_isom_set_last_sample_duration(ctx->file, tkw->track_num, (u32) val);\n\t\t}\n\n\t\tif (tkw->is_nalu && ctx->pack_nal && (gf_isom_get_mode(ctx->file)!=GF_ISOM_OPEN_WRITE)) {\n\t\t\tu32 msize = 0;\n\t\t\tBool do_rewrite = GF_FALSE;\n\t\t\tu32 j, stsd_count = gf_isom_get_sample_description_count(ctx->file, tkw->track_num);\n\t\t\tp = gf_filter_pid_get_info(tkw->ipid, GF_PROP_PID_MAX_NALU_SIZE, &pe);\n\t\t\tmsize = gf_get_bit_size(p->value.uint);\n\t\t\tif (msize<8) msize = 8;\n\t\t\telse if (msize<16) msize = 16;\n\t\t\telse msize = 32;\n\n\t\t\tif (msize<=0xFFFF) {\n\t\t\t\tfor (j=0; j<stsd_count; j++) {\n\t\t\t\t\tu32 k = 8 * gf_isom_get_nalu_length_field(ctx->file, tkw->track_num, j+1);\n\t\t\t\t\tif (k > msize) {\n\t\t\t\t\t\tdo_rewrite = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (do_rewrite) {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[MP4Mux] Adjusting NALU SizeLength to %d bits\\n\", msize ));\n\t\t\t\t\tgf_media_nal_rewrite_samples(ctx->file, tkw->track_num, msize);\n\t\t\t\t\tmsize /= 8;\n\t\t\t\t\tfor (j=0; j<stsd_count; j++) {\n\t\t\t\t\t\tgf_isom_set_nalu_length_field(ctx->file, tkw->track_num, j+1, msize);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//don't update bitrate info for single sample tracks, unless MPEG-4 Systems - compatibility with old arch\n\t\tif (ctx->btrt && !tkw->skip_bitrate_update && ((tkw->nb_samples>1) || ctx->m4sys) )\n\t\t\tgf_media_update_bitrate(ctx->file, tkw->track_num);\n\n\t\tif (!tkw->box_patched) {\n\t\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"boxpatch\");\n\t\t\tif (p && p->value.string) {\n\t\t\t\te = gf_isom_apply_box_patch(ctx->file, tkw->track_id ? tkw->track_id : tkw->item_id, p->value.string, GF_FALSE);\n\t\t\t\tif (e) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to apply box patch %s to track %d: %s\\n\",\n\t\t\t\t\t\tp->value.string, tkw->track_id, gf_error_to_string(e) ));\n\t\t\t\t}\n\t\t\t}\n\t\t\ttkw->box_patched = GF_TRUE;\n\t\t}\n\t}\n\n\tgf_filter_release_property(pe);\n\n\tif (ctx->boxpatch && !ctx->box_patched) {\n\t\te = gf_isom_apply_box_patch(ctx->file, 0, ctx->boxpatch, GF_FALSE);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to apply box patch %s: %s\\n\", ctx->boxpatch, gf_error_to_string(e) ));\n\t\t}\n\t\tctx->box_patched = GF_TRUE;\n\t}\n\n\n\tif (ctx->owns_mov) {\n\t\tif (ctx->moovpad)\n\t\t\tgf_isom_set_inplace_padding(ctx->file, ctx->moovpad);\n\n\t\tswitch (ctx->store) {\n\t\tcase MP4MX_MODE_INTER:\n\t\t\tif (ctx->cdur.num==0) {\n\t\t\t\te = gf_isom_set_storage_mode(ctx->file, GF_ISOM_STORE_STREAMABLE);\n\t\t\t} else {\n\t\t\t\tif (ctx->cdur.num < 0) ctx->cdur.num = 1000;\n\t\t\t\te = gf_isom_make_interleave_ex(ctx->file, &ctx->cdur);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MP4MX_MODE_FLAT:\n\t\t\te = gf_isom_set_storage_mode(ctx->file, GF_ISOM_STORE_FLAT);\n\t\t\tbreak;\n\t\tcase MP4MX_MODE_FASTSTART:\n\t\t\te = gf_isom_set_storage_mode(ctx->file, GF_ISOM_STORE_FASTSTART);\n\t\t\tbreak;\n\t\tcase MP4MX_MODE_TIGHT:\n\t\t\te = gf_isom_set_storage_mode(ctx->file, GF_ISOM_STORE_TIGHT);\n\t\t\tbreak;\n\t\t}\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set storage mode: %s\\n\", gf_error_to_string(e) ));\n\t\t\tgf_isom_delete(ctx->file);\n\t\t} else {\n\t\t\te = gf_isom_close(ctx->file);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to write file: %s\\n\", gf_error_to_string(e) ));\n\t\t\t}\n\t\t}\n\t\tctx->file = NULL;\n\t\tif (is_final)\n\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t} else {\n\t\tctx->file = NULL;\n\t}\n\treturn e;\n}\n\nstatic void mp4_mux_finalize(GF_Filter *filter)\n{\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (ctx->owns_mov && (ctx->file || (ctx->store>=MP4MX_MODE_FRAG))) {\n\t\tif (ctx->store < MP4MX_MODE_FRAG) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Session aborted before writing to file, use fragmented storage mode to record session\\n\"));\n\t\t}\n\t\tgf_isom_delete(ctx->file);\n\t}\n\n\twhile (gf_list_count(ctx->tracks)) {\n\t\tTrackWriter *tkw = gf_list_pop_back(ctx->tracks);\n\t\tmp4_mux_track_writer_del(tkw);\n\t}\n\tgf_list_del(ctx->tracks);\n\tgf_list_del(ctx->ref_pcks);\n\tif (ctx->bs_r) gf_bs_del(ctx->bs_r);\n\tif (ctx->seg_name) gf_free(ctx->seg_name);\n\tif (ctx->tmp_store) gf_fclose(ctx->tmp_store);\n\tif (ctx->seg_sizes) gf_free(ctx->seg_sizes);\n\n\tif (ctx->cur_file_suffix) gf_free(ctx->cur_file_suffix);\n\n}\n\nstatic const GF_FilterCapability MP4MuxCaps[] =\n{\n\t//for now don't accept files as input, although we could store them as items, to refine\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_SCENE),\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_OD),\n\t//we want framed media only\n\tCAP_BOOL(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t//and any codecid\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED,  GF_PROP_PID_CODECID, GF_CODECID_NONE),\n\tCAP_STRING(GF_CAPS_OUTPUT_STATIC,  GF_PROP_PID_FILE_EXT, ISOM_FILE_EXT),\n\tCAP_STRING(GF_CAPS_OUTPUT_STATIC,  GF_PROP_PID_MIME, ISOM_FILE_MIME),\n\t{0},\n\t//for scene / OD / text, we don't want raw codecid (filters modifying a scene graph we don't expose)\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_SCENE),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_OD),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_TEXT),\n\tCAP_BOOL(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_CODECID, GF_CODECID_RAW),\n};\n\n\n#define OFFS(_n)\t#_n, offsetof(GF_MP4MuxCtx, _n)\nstatic const GF_FilterArgs MP4MuxArgs[] =\n{\n\t{ OFFS(m4sys), \"force MPEG-4 Systems signaling of tracks\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(dref), \"only reference data from source file - not compatible with all media sources\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ctmode), \"set composition offset mode for video tracks\\n\"\n\t\"- edit: uses edit lists to shift first frame to presentation time 0\\n\"\n\t\"- noedit: ignore edit lists and does not shift timeline\\n\"\n\t\"- negctts: uses ctts v1 with possibly negative offsets and no edit lists\", GF_PROP_UINT, \"edit\", \"edit|noedit|negctts\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(dur), \"only import the specified duration. If negative, specify the number of coded frames to import\", GF_PROP_FRACTION, \"0\", NULL, 0},\n\t{ OFFS(pack3gp), \"pack a given number of 3GPP audio frames in one sample\", GF_PROP_UINT, \"1\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(importer), \"compatibility with old importer, displays import progress\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(pack_nal), \"repack NALU size length to minimum possible size for NALU-based video (AVC/HEVC/...)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(xps_inband), \"use inband (in sample data) parameter set for NALU-based video (AVC/HEVC/...)\\n\"\n\t\"- no: parameter sets are not inband, several sample descriptions might be created\\n\"\n\t\"- pps: picture parameter sets are inband, all other parameter sets are in sample description\\n\"\n\t\"- all: parameter sets are inband, no parameter sets in sample description\\n\"\n\t\"- both: parameter sets are inband, signaled as inband, and also first set is kept in sample description\\n\"\n\t\"- mix: creates non-standard files using single sample entry with first PSs found, and moves other PS inband\\n\"\n\t\"- auto: keep source config, or defaults to no if source is not ISOBMFF\", GF_PROP_UINT, \"no\", \"no|pps|all|both|mix|auto\", 0},\n\t{ OFFS(store), \"file storage mode\\n\"\n\t\"- inter: perform precise interleave of the file using [-cdur]() (requires temporary storage of all media)\\n\"\n\t\"- flat: write samples as they arrive and `moov` at end (fastest mode)\\n\"\n\t\"- fstart: write samples as they arrive and `moov` before `mdat`\\n\"\n\t\"- tight: uses per-sample interleaving of all tracks (requires temporary storage of all media)\\n\"\n\t\"- frag: fragments the file using cdur duration\\n\"\n\t\"- sfrag: fragments the file using cdur duration but adjusting to start with SAP1/3\", GF_PROP_UINT, \"inter\", \"inter|flat|fstart|tight|frag|sfrag\", 0},\n\t{ OFFS(cdur), \"chunk duration for flat and interleaving modes or fragment duration for fragmentation modes\\n\"\n\t\"- 0: no specific interleaving but moov first\\n\"\n\t\"- negative: defaults to 1.0 unless overridden by storage profile\", GF_PROP_FRACTION, \"-1/1\", NULL, 0},\n\t{ OFFS(moovts), \"timescale to use for movie. A negative value picks the media timescale of the first track added\", GF_PROP_SINT, \"600\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(moof_first), \"generate fragments starting with moof then mdat\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(abs_offset), \"use absolute file offset in fragments rather than offsets from moof\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(fsap), \"split truns in video fragments at SAPs to reduce file size\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(file), \"pointer to a write/edit ISOBMF file used internally by importers and exporters\", GF_PROP_POINTER, NULL, NULL, GF_FS_ARG_HINT_HIDE},\n\t{ OFFS(subs_sidx), \"number of subsegments per sidx. negative value disables sidx, -2 removes sidx if present in source PID\", GF_PROP_SINT, \"-1\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(m4cc), \"4 character code of empty box to append at the end of a segment (DASH mode) or of a fragment (non-DASH mode)\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(chain_sidx), \"use daisy-chaining of SIDX\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(msn), \"sequence number of first moof to N\", GF_PROP_UINT, \"1\", NULL, 0},\n\t{ OFFS(msninc), \"sequence number increase between `moof` boxes\", GF_PROP_UINT, \"1\", NULL, 0},\n\t{ OFFS(tfdt), \"set initial decode time (`tfdt`) of first traf\", GF_PROP_FRACTION64, \"0\", NULL, 0},\n\t{ OFFS(tfdt_traf), \"force `tfdt` box in each traf\", GF_PROP_BOOL, \"false\", NULL, 0},\n\t{ OFFS(nofragdef), \"disable default flags in fragments\", GF_PROP_BOOL, \"false\", NULL, 0},\n\t{ OFFS(straf), \"use a single traf per moof (smooth streaming and co)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(strun), \"use a single trun per traf (smooth streaming and co)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(psshs), \"set `pssh` boxes store mode\\n\"\n\t\"- moof: in first moof of each segments\\n\"\n\t\"- moov: in movie box\\n\"\n\t\"- both: in movie box and in first moof of each segment\\n\"\n\t\"- none: pssh is discarded\", GF_PROP_UINT, \"moov\", \"moov|moof|both|none\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(sgpd_traf), \"store sample group descriptions in traf (duplicated for each traf). If not used, sample group descriptions are stored in the movie box\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(vodcache), \"enable temp storage for VoD dash modes\\n\"\n\t\t\"- on: use temp storage of complete file for sidx and ssix injection\\n\"\n\t\t\"- insert: insert sidx and ssix by shifting bytes in output file\\n\"\n\t\t\"- replace: precompute pace requirements for sidx and ssix and rewrite file range at end\", GF_PROP_UINT, \"replace\", \"on|insert|replace\", 0},\n\t{ OFFS(noinit), \"do not produce initial `moov, used for DASH bitstream switching mode\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(tktpl), \"use track box from input if any as a template to create new track\\n\"\n\t\"- no: disables template\\n\"\n\t\"- yes: clones the track (except edits and decoder config)\\n\"\n\t\"- udta: only loads udta\", GF_PROP_UINT, \"yes\", \"no|yes|udta\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(mudta), \"use `udta` and other `moov` extension boxes from input if any\\n\"\n\t\"- no: disables import\\n\"\n\t\"- yes: clones all extension boxes\\n\"\n\t\"- udta: only loads udta\", GF_PROP_UINT, \"yes\", \"no|yes|udta\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(mvex), \"set `mvex` boxes after `trak` boxes\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(sdtp_traf), \"use `sdtp` box in `traf` box rather than using flags in trun sample entries\\n\"\n\t\t\"- no: do not use `sdtp`\\n\"\n\t\t\"- sdtp: use `sdtp` box to indicate sample dependencies and do not write info in `trun` sample flags\\n\"\n\t\t\"- both: use `sdtp` box to indicate sample dependencies and also write info in `trun` sample flags\", GF_PROP_UINT, \"no\", \"no|sdtp|both\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(trackid), \"track ID of created track for single track. Default 0 uses next available trackID\", GF_PROP_UINT, \"0\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(fragdur), \"fragment based on fragment duration rather than CTS. Mostly used for `MP4Box -frag` option\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(btrt), \"set `btrt` box in sample description\", GF_PROP_BOOL, \"true\", NULL, 0},\n\t{ OFFS(styp), \"set segment `styp` major brand (and optionally version) to the given 4CC[.version]\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(mediats), \"set media timescale. A value of 0 means inherit from PID, a value of -1 means derive from samplerate or frame rate\", GF_PROP_SINT, \"0\", NULL, 0},\n\t{ OFFS(ase), \"set audio sample entry mode for more than stereo layouts\\n\"\n\t\t\t\"- v0: use v0 signaling but channel count from stream, recommended for backward compatibility\\n\"\n\t\t\t\"- v0s: use v0 signaling and force channel count to 2 (stereo) if more than 2 channels\\n\"\n\t\t\t\"- v1: use v1 signaling, ISOBMFF style (will mux raw PCM as ISOBMFF style)\\n\"\n\t\t\t\"- v1qt: use v1 signaling, QTFF style\\n\"\n\t\t\t\"- v2qt: use v2 signaling, QTFF style (lpcm entry type)\"\n\t\t, GF_PROP_UINT, \"v0\", \"|v0|v0s|v1|v1qt|v2qt\", 0},\n\t{ OFFS(ssix), \"create `ssix` box when `sidx` box is present, level 1 mapping I-frames byte ranges, level 0xFF mapping the rest\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ccst), \"insert coding constraint box for video tracks\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(maxchunk), \"set max chunk size in bytes for runs (only used in non-fragmented mode). 0 means no constraints\", GF_PROP_UINT, \"0\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(noroll), \"disable roll sample grouping\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(norap), \"disable rap sample grouping\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(saio32), \"use 32 bit offset for side data location instead of 64 bit offset\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(tfdt64), \"use 64 bit tfdt and sidx even for 32 bits timestamps\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n#ifdef GF_ENABLE_CTRN\n\t{ OFFS(ctrn), \"use compact track run (experimental)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ctrni), \"use inheritance in compact track run for HEVC tile tracks (highly experimental)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n#endif\n\t{ OFFS(sseg), \"set single segment mode for dash\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_HIDE},\n\n\t{ OFFS(compress), \"set top-level box compression mode\\n\"\n\t\t\t\t\t\t\"- no: disable box compression\\n\"\n\t\t\t\t\t\t\"- moov: compress only moov box (uses cmov for QT)\\n\"\n\t\t\t\t\t\t\"- moof: compress only moof boxes\\n\"\n\t\t\t\t\t\t\"- sidx: compress moof and sidx boxes\\n\"\n\t\t\t\t\t\t\"- ssix: compress moof, sidx and ssix boxes\\n\"\n\t\t\t\t\t\t\"- all: compress moov, moof, sidx and ssix boxes\", GF_PROP_UINT, \"no\", \"no|moov|moof|sidx|ssix|all\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(fcomp), \"force using compress box even when compressed size is larger than uncompressed\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(otyp), \"inject original file type when using compressed boxes\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\n\t{ OFFS(trun_inter), \"interleave samples in `trun` based on the temporal level, the lowest level are stored first (this will create as many `trun` boxes as required)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(truns_first), \"store track runs before sample group description and sample encryption information\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(block_size), \"target output block size, 0 for default internal value (10k)\", GF_PROP_UINT, \"10000\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(boxpatch), \"apply box patch before writing\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(deps), \"add samples dependencies information\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(mfra), \"enable movie fragment random access when fragmenting (ignored when dashing)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(forcesync), \"force all SAP types to be considered sync samples (might produce non-compliant files)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(refrag), \"use track fragment defaults from initial file if any rather than computing them from PID properties (used when processing standalone segments/fragments)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(itags), \"tag injection mode\\n\"\n\t\t\t\"- none: do not inject tags\\n\"\n\t\t\t\"- strict: only inject recognized itunes tags\\n\"\n\t\t\t\"- all: inject all possible tags\"\n\t\t\t, GF_PROP_UINT, \"strict\", \"none|strict|all\", GF_FS_ARG_HINT_EXPERT},\n\n\t{ OFFS(keep_utc), \"force all new files and tracks to keep the source UTC creation and modification times\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(pps_inband), \"when [-xps_inband]() is set, inject PPS in each non SAP 1/2/3 sample\", GF_PROP_BOOL, \"no\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(moovpad), \"insert `free` box of given size after `moov` for future in-place editing\", GF_PROP_UINT, \"0\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(cmaf), \"use CMAF guidelines (turns on `mvex`, `truns_first`, `strun`, `straf`, `tfdt_traf`, `chain_sidx` and restricts `subs_sidx` to -1 or 0)\\n\"\n\t\t\"- no: CMAF not enforced\\n\"\n\t\t\"- cmfc: use CMAF `cmfc` guidelines\\n\"\n\t\t\"- cmf2: use CMAF `cmf2` guidelines (turns on `nofragdef`)\"\n\t\t, GF_PROP_UINT, \"no\", \"no|cmfc|cmf2\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(start), \"set playback start offset for MP4Box import only. A negative value means percent of media duration with -1 equal to duration\", GF_PROP_DOUBLE, \"0.0\", NULL, GF_FS_ARG_HINT_HIDE},\n\t{ OFFS(pad_sparse), \"inject sample with no data (size 0) to keep durations in unknown sparse text and metadata tracks\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(force_dv), \"force DV sample entry types even when AVC/HEVC compatibility is signaled\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(dvsingle), \"ignore DolbyVision profile 8 in xps inband mode if profile 5 is already set\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(tsalign), \"enable timeline realignment to 0 for first sample - if false, this will keep original timing with empty edit (possibly long) at begin)\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(chapm), \"chapter storage mode\\n\"\n\t\"- off: disable chapters\\n\"\n\t\"- tk: use chapter track (QT-style)\\n\"\n\t\"- udta: use user-data box chapters\\n\"\n\t\"- both: use both chapter tracks and udta\"\n\t, GF_PROP_UINT, \"both\", \"off|tk|udta|both\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(patch_dts), \"patch previous samples duration when dts do not increase monotonically\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(uncv), \"use uncv (ISO 23001-17) for raw video\\n\"\n\t\"- off: disabled (always the case when muxing to QT)\\n\"\n\t\"- gen: enabled, do not write profile\\n\"\n\t\"- prof: enabled and write profile if known\\n\"\n\t\"- tiny: enabled and write reduced version if profile known and compatible\", GF_PROP_UINT, \"prof\", \"off|gen|prof|tiny\", GF_FS_ARG_HINT_EXPERT},\n\t{0}\n};\n\n\nGF_FilterRegister MP4MuxRegister = {\n\t.name = \"mp4mx\",\n\tGF_FS_SET_DESCRIPTION(\"ISOBMFF/QT multiplexer\")\n\tGF_FS_SET_HELP(\"This filter multiplexes streams to ISOBMFF (14496-12 and derived specifications) or QuickTime\\n\"\n\t\"  \\n\"\n\t\"# Tracks and Items\\n\"\n\t\"By default all input PIDs with ItemID property set are multiplexed as items, otherwise they are multiplexed as tracks.\\n\"\n\t\"To prevent source items to be multiplexed as items, use [-itemid](mp4dmx) option from ISOBMFF demultiplexer.\\n\"\n\t\"EX gpac -i source.mp4:itemid=false -o file.mp4\\n\"\n\t\"  \\n\"\n\t\"To force non-item streams to be multiplexed as items, use __#ItemID__ option on that PID:\\n\"\n\t\"EX gpac -i source.jpg:#ItemID=1 -o file.mp4\\n\"\n\t\"  \\n\"\n\t\"# Storage\\n\"\n\t\"The [-store]() option allows controlling if the file is fragmented or not, and when not fragmented, how interleaving is done. For cases where disk requirements are tight and fragmentation cannot be used, it is recommended to use either `flat` or `fstart` modes.\\n\"\n\t\"  \\n\"\n\t\"The [-vodcache]() option allows controlling how DASH onDemand segments are generated:\\n\"\n\t\"- If set to `on`, file data is stored to a temporary file on disk and flushed upon completion, no padding is present.\\n\"\n\t\"- If set to `insert`, SIDX/SSIX will be injected upon completion of the file by shifting bytes in file. In this case, no padding is required but this might not be compatible with all output sinks and will take longer to write the file.\\n\"\n\t\"- If set to `replace`, SIDX/SSIX size will be estimated based on duration and DASH segment length, and padding will be used in the file __before__ the final SIDX. If input PIDs have the properties `DSegs` set, this will used be as the number of segments.\\n\"\n\t\"The `on` and `insert` modes will produce exactly the same file, while the mode `replace` may inject a `free` box before the sidx.\\n\"\n\t\"  \\n\"\n\t\"# Custom boxes\\n\"\n\t\"Custom boxes can be specified as box patches:\\n\"\n\t\"For movie-level patch, the [-boxpatch]() option of the filter should be used.\\n\"\n\t\"Per PID box patch can be specified through the PID property `boxpatch`.\\n\"\n\t\"EX gpac -i source:#boxpatch=myfile.xml -o mux.mp4\\n\"\n\t\"Per Item box patch can be specified through the PID property `boxpatch`.\\n\"\n\t\"EX gpac -i source:1ItemID=1:#boxpatch=myfile.xml -o mux.mp4\\n\"\n\t\"  \\n\"\n\t\"The box patch is applied before writing the initial `moov box in fragmented mode, or when writing the complete file otherwise.\\n\"\n\t\"The box patch can either be a filename or the full XML string.\\n\"\n\t\"  \\n\"\n\t\"# Tagging\\n\"\n\t\"When tagging is enabled, the filter will watch the property `CoverArt` and all custom properties on incoming PID.\\n\"\n\t\"The built-in tag names are indicated by `MP4Box -h tags`.\\n\"\n\t\"QT tags can be specified using `qtt_NAME` property names, and will be added using formatting specified in `MP4Box -h tags`.\\n\"\n\t\"Other tag class may be specified using `tag_NAME` property names, and will be added if [-tags]() is set to `all` using:\\n\"\n\t\"- `NAME` as a box 4CC if `NAME` is four characters long\\n\"\n\t\"- `NAME` as a box 4CC if `NAME` is 3 characters long, and will be prefixed by 0xA9\\n\"\n\t\"- the CRC32 of the `NAME` as a box 4CC if `NAME` is not four characters long\\n\"\n\t\"  \\n\"\n\t\"# User data\\n\"\n\t\"The filter will look for the following PID properties to create user data entries:\\n\"\n\t\"- `udtab`: set the track user-data box to the property value which __must__ be a serialized box array blob\\n\"\n\t\"- `mudtab`: set the movie user-data box to the property value which __must__ be a serialized box array blob\\n\"\n\t\"- `udta_U4CC`: set track user-data box entry of type `U4CC` to property value\\n\"\n\t\"- `mudta_U4CC`: set movie user-data box entry of type `U4CC` to property value\\n\"\n\t\"- `tkgp_T4CC`: set/remove membership to track group with type `T4CC` and ID given by property value. A negative value N removes from track group with ID -N\\n\"\n\t\"  \\n\"\n\t\"EX gpac -i src.mp4:#udta_tagc='My Awesome Tag' -o tag.mp4\\n\"\n\t\"EX gpac -i src.mp4:#mudtab=data@box.bin -o tag.mp4\\n\"\n\t\"  \\n\"\n\t\"# Custom sample group descriptions and sample auxiliary info\\n\"\n\t\"The filter watches the following custom data properties on incoming packets:\\n\"\n\t\"- `grp_A4CC`: maps packet to sample group description of type `A4CC` and entry set to property payload\\n\"\n\t\"- `grp_A4CC_param`: same as above and sets sample to group `grouping_type_parameter` to `param`\\n\"\n\t\"- `sai_A4CC`: adds property payload as sample auxiliary information of type `A4CC`\\n\"\n\t\"- `sai_A4CC_param`: same as above and sets `aux_info_type_parameter`to `param`\\n\"\n\t\"  \\n\"\n\t\"The property `grp_EMSG` consists in one or more `EventMessageBox` as defined in MPEG-DASH.\\n\"\n\t\"- in fragmented mode, presence of these boxes in a packet will start a new fragment, with the boxes written before the `moof`\\n\"\n\t\"- in regular mode, an internal sample group of type `EMSG` is currently used for `emsg` box storage\\n\"\n\t\"  \\n\"\n\t\"# Notes\\n\"\n\t\"The filter watches the property `FileNumber` on incoming packets to create new files (regular mode) or new segments (DASH mode).\\n\"\n\t\"  \\n\"\n\t\"The filter watches the property `DSIWrap` (4CC as int or string) on incoming PID to wrap decoder configuration in a box of given type (unknown wrapping)\\n\"\n\t\"EX -i unkn.mkv:#ISOMSubtype=VIUK:#DSIWrap=cfgv -o t.mp4\\n\"\n\t\"This will wrap the unknown stream using `VIUK` code point in `stsd` and wrap any decoder configuration data in a `cfgv` box.\\n\"\n\t\"\\n\"\n\t\"If [-pad_sparse]() is set, the filter watches the property `Sparse` on incoming PID to decide whether empty packets should be injected to keep packet duration info.\\n\"\n\t\"Such packets are only injected when a whole in the timeline is detected.\\n\"\n\t\"- if `Sparse` is absent, empty packet is inserted for unknown text and metadata streams\\n\"\n\t\"- if `Sparse` is true, empty packet is inserted for all stream types\\n\"\n\t\"- if `Sparse` is false, empty packet is never injected\\n\"\n\t\"  \\n\"\n\t\"The default media type used for a PID can be overriden using property `StreamSubtype`. \\n\"\n\t\"EX -i src.srt:#StreamSubtype=sbtl [-i ...]  -o test.mp4 \\n\"\n\t\"This will force the text stream to use `sbtl` handler type instead of default `text` one.\"\n\t\"\\n\"\n\t\"Subtitle streams may be used as chapters by setting the property `IsChap` on the desired PID.\\n\"\n\t\"EX -i src.srt:#IsChap  [-i ...] -o test.mp4 \\n\"\n\t\"This will force the text stream to be used as a QT chapter track.\"\n\t\"  \\n\"\n\t)\n\t.private_size = sizeof(GF_MP4MuxCtx),\n\t.args = MP4MuxArgs,\n\t.initialize = mp4_mux_initialize,\n\t.finalize = mp4_mux_finalize,\n\t.flags = GF_FS_REG_DYNAMIC_REDIRECT,\n\tSETCAPS(MP4MuxCaps),\n\t.configure_pid = mp4_mux_configure_pid,\n\t.process = mp4_mux_process,\n\t.process_event = mp4_mux_process_event\n};\n\n\nconst GF_FilterRegister *mp4mx_register(GF_FilterSession *session)\n{\n\treturn &MP4MuxRegister;\n}\n#else\nconst GF_FilterRegister *mp4mx_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n#endif // GPAC_DISABLE_ISOM_WRITE\n\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2017-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISOBMF mux filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/filters.h>\n#include <gpac/constants.h>\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/internal/media_dev.h>\n\n#if !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_MP4MX)\n\n#define TEXT_DEFAULT_WIDTH\t400\n#define TEXT_DEFAULT_HEIGHT\t60\n#define TEXT_DEFAULT_FONT_SIZE\t18\n\n#define GF_VENDOR_GPAC\t\tGF_4CC('G','P','A','C')\n\n#define GF_IMPORT_AUDIO_SAMPLE_ENTRY_v2_QTFF (GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF+1)\n\n#define ISOM_FILE_EXT \"mp4|mpg4|m4a|m4i|3gp|3gpp|3g2|3gp2|iso|ismv|m4s|heif|heic|iff|avci|avif|mj2|mov|qt\"\n#define ISOM_FILE_MIME \"video/mp4|audio/mp4|application/mp4|video/3gpp|audio/3gpp|video/3gp2|audio/3gp2|video/iso.segment|audio/iso.segment|image/heif|image/heic|image/avci|video/jp2|video/quicktime\"\n\nenum{\n\tNALU_NONE,\n\tNALU_AVC,\n\tNALU_HEVC,\n\tNALU_VVC\n};\n\n\nenum\n{\n\tCENC_NONE=0,\n\tCENC_NEED_SETUP,\n\tCENC_SETUP_DONE,\n\tCENC_SETUP_ERROR\n};\n\nenum{\n\tTAG_NONE,\n\tTAG_STRICT,\n\tTAG_ALL\n};\n\nenum\n{\n\tXPS_IB_NO = 0,\n\tXPS_IB_PPS,\n\tXPS_IB_ALL,\n\tXPS_IB_BOTH,\n\tXPS_IB_MIX,\n\tXPS_IB_AUTO\n};\n\ntypedef struct\n{\n\tGF_FilterPid *ipid;\n\tu32 track_num, track_id;\n\tGF_ISOSample sample;\n\tu32 prev_duration;\n\n\tu32 src_timescale;\n\tu32 tk_timescale;\n\tu32 stream_type;\n\tu32 codecid;\n\tBool is_encrypted;\n\n\tu32 cfg_crc, enh_cfg_crc;\n\tu32 dep_id;\n\tu32 stsd_idx;\n\tu32 clear_stsd_idx;\n\tBool reused_stsd;\n\n\tBool use_dref;\n\tBool aborted;\n\tBool suspended;\n\tBool has_append;\n\tBool has_ctts;\n\ts64 min_neg_ctts;\n\tu32 nb_samples, samples_in_stsd;\n\tu32 nb_frames_per_sample;\n\tu64 ts_shift;\n\tu64 si_min_ts_plus_one;\n\tBool has_subs;\n\n\tBool skip_bitrate_update;\n\tBool has_open_gop;\n\tGF_FilterSAPType gdr_type;\n\n\tu32 media_profile_level;\n\n\tBool import_msg_header_done;\n\n\tu32 nal_unit_size;\n\n\tGF_AVCConfig *avcc, *svcc;\n\tGF_HEVCConfig *hvcc, *lvcc;\n\tGF_VVCConfig *vvcc;\n\n\tu8 *inband_hdr, *inband_hdr_non_rap;\n\tu32 inband_hdr_size, inband_hdr_non_rap_size;\n\tu32 is_nalu;\n\tBool is_av1, is_vpx;\n\tBool fragment_done;\n\ts32 ts_delay, negctts_shift;\n\tBool insert_tfdt, probe_min_ctts;\n\tu64 first_dts_in_seg_plus_one, next_seg_cts, cts_next;\n\ts64 tfdt_offset;\n\tu32 samples_in_frag;\n\tBool patch_tfdt;\n\n\t//0: not cenc, 1: needs setup of stsd entry, 2: setup done\n\tu32 cenc_state;\n\tBool cenc_subsamples;\n\tu32 scheme_type;\n\tu32 def_skip_byte_block, def_crypt_byte_block;\n\tu32 def_cenc_key_info_crc;\n\tconst GF_PropertyValue *cenc_ki;\n\tu32 cenc_key_info_crc;\n\tu32 constant_IV_size;\n\tBool cenc_multikey;\n\tBool cenc_frag_protected;\n\tu32 skip_byte_block, crypt_byte_block;\n\n\tBool fake_track;\n\n\tBool has_brands;\n\tBool force_inband_inject;\n\n\tu64 dur_in_frag;\n\n\tu32 amr_mode_set;\n\tBool has_seig;\n\tu64 empty_init_dur;\n\tu32 raw_audio_bytes_per_sample, raw_samplerate;\n\tu64 dts_patch;\n\n\tBool is_item;\n\tu32 item_id;\n\tchar status_type;\n\tu32 last_import_pc;\n\n\tu32 nb_frames, frame_offset;\n\tu64 down_bytes, down_size;\n\tGF_Fraction64 pid_dur;\n\t//for import message\n\tu64 prog_done, prog_total;\n\n\tu32 prev_tid_group;\n\n\tBool box_patched;\n\n\tu64 imported_edit_sdur, imported_edit_offset;\n\n\tBool force_ctts;\n\n\tBool is_hevc_tile_base;\n\tBool insert_pssh;\n\n\tBool wait_sap;\n\tu64 min_ts_seek_plus_one;\n\tu64 clamp_ts_plus_one;\n\tBool check_seek_ts;\n\n\tu64 max_cts, min_cts;\n\tu32 max_cts_samp_dur;\n\n\tu32 w_or_sr, h_or_ch, pf_or_af;\n\tu32 xps_inband;\n\n\tu8 *dyn_pssh;\n\tu32 dyn_pssh_len;\n\n\tBool sparse_inject;\n\tBool is_chap;\n\n\tGF_FilterPacket *dgl_copy;\n\tu32 all_stsd_crc;\n} TrackWriter;\n\nenum\n{\n\tMP4MX_MODE_INTER=0,\n\tMP4MX_MODE_FLAT,\n\tMP4MX_MODE_FASTSTART,\n\tMP4MX_MODE_TIGHT,\n\tMP4MX_MODE_FRAG,\n\tMP4MX_MODE_SFRAG,\n};\n\n\nenum\n{\n\tMP4MX_DASH_OFF=0,\n\tMP4MX_DASH_ON,\n\tMP4MX_DASH_VOD,\n};\n\nenum\n{\n\tMP4MX_PSSH_MOOV=0,\n\tMP4MX_PSSH_MOOF,\n\tMP4MX_PSSH_BOTH,\n\tMP4MX_PSSH_SKIP,\n};\n\nenum\n{\n\tMP4MX_CT_EDIT=0,\n\tMP4MX_CT_NOEDIT,\n\tMP4MX_CT_NEGCTTS,\n};\n\nenum\n{\n\tMP4MX_VODCACHE_ON=0,\n\tMP4MX_VODCACHE_INSERT,\n\tMP4MX_VODCACHE_REPLACE,\n};\n\nenum\n{\n\tMP4MX_CMAF_NO=0,\n\tMP4MX_CMAF_CMFC,\n\tMP4MX_CMAF_CMF2,\n};\n\nenum\n{\n\tMP4MX_CHAPM_OFF=0,\n\tMP4MX_CHAPM_TRACK,\n\tMP4MX_CHAPM_UDTA,\n\tMP4MX_CHAPM_BOTH\n};\n\nenum\n{\n\tMP4MX_UNCV_OFF=0,\n\tMP4MX_UNCV_NOPROF,\n\tMP4MX_UNCV_PROF,\n\tMP4MX_UNCV_PROF_ONLY\n};\n\n\ntypedef struct\n{\n\t//filter args\n\tGF_ISOFile *file;\n\tBool m4sys, dref;\n\tGF_Fraction dur;\n\tu32 pack3gp, ctmode;\n\tBool importer, pack_nal, moof_first, abs_offset, fsap, tfdt_traf, keep_utc, pps_inband;\n\tu32 xps_inband, moovpad;\n\tu32 block_size;\n\tu32 store, tktpl, mudta;\n\ts32 subs_sidx;\n\tGF_Fraction cdur;\n\ts32 moovts;\n\tchar *m4cc;\n\tBool chain_sidx;\n\tu32 msn, msninc;\n\tGF_Fraction64 tfdt;\n\tBool nofragdef, straf, strun, sgpd_traf, noinit;\n\tu32 vodcache;\n\tu32 psshs;\n\tu32 trackid;\n\tBool fragdur;\n\tBool btrt;\n\tBool ssix;\n\tBool ccst;\n\ts32 mediats;\n\tGF_AudioSampleEntryImportMode ase;\n\tchar *styp;\n\tBool sseg;\n\tBool noroll, norap;\n\tBool saio32, tfdt64;\n\tu32 compress;\n\tBool trun_inter;\n\tBool truns_first;\n\tchar *boxpatch;\n\tBool fcomp, otyp;\n\tBool deps;\n\tBool mvex;\n\tu32 sdtp_traf;\n\tu32 cmaf;\n#ifdef GF_ENABLE_CTRN\n\tBool ctrn;\n\tBool ctrni;\n#endif\n\tBool mfra;\n\tu32 uncv;\n\tBool forcesync, refrag, pad_sparse;\n\tBool force_dv, tsalign, dvsingle, patch_dts;\n\tu32 itags;\n\tDouble start;\n\tu32 chapm;\n\n\n\t//internal\n\tGF_Filter *filter;\n\tBool owns_mov;\n\tGF_FilterPid *opid;\n\tBool first_pck_sent;\n\n\tGF_List *tracks;\n\n\tGF_BitStream *bs_r;\n\t//fragmentation state\n\tBool init_movie_done, fragment_started, segment_started, insert_tfdt, insert_pssh, cdur_set;\n\n\tu64 next_frag_start, adjusted_next_frag_start;\n\n\tu64 current_offset;\n\tu64 current_size;\n\n\tu32 nb_segs, nb_frags, nb_frags_in_seg;\n\n\tGF_FilterPacket *dst_pck;\n\tchar *seg_name;\n\tu32 dash_seg_num_plus_one;\n\tBool flush_seg;\n\tu32 eos_marker;\n\tTrackWriter *ref_tkw;\n\tBool single_file;\n\tBool store_output;\n\tFILE *tmp_store;\n\tu64 flush_size, flush_done;\n\n\tu32 dash_mode, llhls_mode;\n\tGF_Fraction dash_dur;\n\tDouble media_dur;\n\tu32 sidx_max_size, sidx_chunk_offset;\n\tBool final_sidx_flush;\n\tBool sidx_size_exact;\n\n\tu32 *seg_sizes;\n\tu32 nb_seg_sizes, alloc_seg_sizes, config_retry_start;\n\tBool config_timing;\n\n\tu32 major_brand_set;\n\tBool def_brand_patched;\n\n\tBool force_play;\n\n\tBool moov_inserted;\n\tBool update_report;\n\tu64 total_bytes_in, total_bytes_out;\n\tu32 total_samples, last_mux_pc;\n\n\tu32 maxchunk;\n\tu32 make_qt;\n\tTrackWriter *prores_track;\n\n\tGF_SegmentIndexBox *cloned_sidx;\n\tu32 cloned_sidx_index;\n\tGF_Fraction faststart_ts_regulate;\n\n\tBool is_rewind;\n\tBool box_patched;\n\tu32 cur_file_idx_plus_one;\n\tchar *cur_file_suffix;\n\tBool notify_filename;\n\n\tu32 next_file_idx;\n\tconst char *next_file_suffix;\n\n\t//for route scheduling\n\tu64 min_cts_plus_one, next_seg_start;\n\tu64 min_cts_next_frag;\n\n\tu64 frag_size, frag_offset;\n\tu32 frag_num;\n\tu64 frag_duration;\n\tu32 frag_timescale;\n\tBool frag_has_intra;\n\n\tu64 wait_dts_plus_one;\n\tu32 wait_dts_timescale;\n\tBool force_seg_sync;\n\tu32 seg_flush_state;\n\tu64 flush_idx_start_range, flush_idx_end_range;\n\tBool flush_ll_hls;\n\n\tBool has_def_vid, has_def_aud, has_def_txt;\n\n\t//created from chapters prop\n\tu32 chap_track_num;\n\tBool has_chap_tracks;\n\n\tGF_List *ref_pcks;\n} GF_MP4MuxCtx;\n\nstatic void mp4_mux_update_init_edit(GF_MP4MuxCtx *ctx, TrackWriter *tkw, u64 min_ts_service, Bool skip_adjust);\n\nstatic void mp4_mux_set_hevc_groups(GF_MP4MuxCtx *ctx, TrackWriter *tkw);\n\nstatic GF_Err mp4mx_setup_dash_vod(GF_MP4MuxCtx *ctx, TrackWriter *tkw)\n{\n\tif (tkw) {\n\t\tconst GF_PropertyValue *p;\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DASH_DUR);\n\t\tif (p) {\n\t\t\tctx->dash_dur = p->value.frac;\n\t\t}\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DURATION);\n\t\tif (p && p->value.lfrac.den) {\n\t\t\tDouble mdur = (Double) p->value.lfrac.num;\n\t\t\tif (mdur<0) mdur = -mdur;\n\t\t\tmdur /= p->value.lfrac.den;\n\t\t\tif (ctx->media_dur < mdur) ctx->media_dur = mdur;\n\t\t}\n\t}\n\tctx->dash_mode = MP4MX_DASH_VOD;\n\tctx->llhls_mode = 0;\n\tif ((ctx->vodcache==MP4MX_VODCACHE_ON) && !ctx->tmp_store) {\n\t\tctx->tmp_store = gf_file_temp(NULL);\n\t\tif (!ctx->tmp_store) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot allocate temp file for VOD sidx generation\\n\"));\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\tif (!ctx->block_size) ctx->block_size = 10000;\n\t}\n\n\treturn GF_OK;\n}\n\n\nstatic u32 gf_isom_stream_type_to_media_type(u32 stream_type, u32 codecid)\n{\n\tswitch (stream_type) {\n\tcase GF_STREAM_SCENE: return GF_ISOM_MEDIA_SCENE;\n\tcase GF_STREAM_OD: return GF_ISOM_MEDIA_OD;\n\tcase GF_STREAM_OCR: return GF_ISOM_MEDIA_OCR;\n\tcase GF_STREAM_OCI: return GF_ISOM_MEDIA_OCI;\n\tcase GF_STREAM_MPEG7: return GF_ISOM_MEDIA_MPEG7;\n\tcase GF_STREAM_METADATA: return GF_ISOM_MEDIA_META;\n\tcase GF_STREAM_VISUAL: return GF_ISOM_MEDIA_VISUAL;\n\tcase GF_STREAM_AUDIO: return GF_ISOM_MEDIA_AUDIO;\n\tcase GF_STREAM_TEXT:\n\t\tif (codecid==GF_ISOM_SUBTYPE_STPP)\n\t\t\treturn GF_ISOM_MEDIA_MPEG_SUBT;\n\t\tif (codecid == GF_CODECID_SUBPIC)\n\t\t\treturn GF_ISOM_MEDIA_SUBPIC;\n\t\treturn GF_ISOM_MEDIA_TEXT;\n\tcase GF_STREAM_INTERACT: return GF_ISOM_MEDIA_SCENE;\n\tcase GF_STREAM_IPMP: return GF_ISOM_MEDIA_IPMP;\n\tcase GF_STREAM_MPEGJ: return GF_ISOM_MEDIA_MPEGJ;\n\tcase GF_STREAM_IPMP_TOOL: return GF_ISOM_MEDIA_IPMP;\n\tcase GF_STREAM_FONT: return GF_ISOM_MEDIA_MPEGJ;//TOCHECK !!\n\n\tcase GF_STREAM_PRIVATE_SCENE:\n\tcase GF_STREAM_ENCRYPTED:\n\tcase GF_STREAM_FILE:\n\t\treturn 0;\n\tdefault:\n\t\treturn stream_type;\n\t}\n\treturn 0;\n}\n\nstatic void mp4_mux_write_ps_list(GF_BitStream *bs, GF_List *list, u32 nalu_size_length)\n{\n\tu32 i, count = list ? gf_list_count(list) : 0;\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(list, i);\n\t\tgf_bs_write_int(bs, sl->size, 8*nalu_size_length);\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n}\n\nstatic GF_List *mp4_mux_get_nalus_ps(GF_List *list, u8 type)\n{\n\tu32 i, count = gf_list_count(list);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParamArray *pa = gf_list_get(list, i);\n\t\tif (pa->type == type) return pa->nalus;\n\t}\n\treturn NULL;\n}\n\nstatic void mp4_mux_make_inband_header(GF_MP4MuxCtx *ctx, TrackWriter *tkw, Bool for_non_rap)\n{\n\tGF_BitStream *bs;\n\tif (for_non_rap) {\n\t\tif (tkw->inband_hdr_non_rap) gf_free(tkw->inband_hdr_non_rap);\n\t\ttkw->inband_hdr_non_rap = NULL;\n\t} else {\n\t\tif (tkw->inband_hdr) gf_free(tkw->inband_hdr);\n\t\ttkw->inband_hdr = NULL;\n\t}\n\n\ttkw->nal_unit_size = 0;\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (tkw->avcc || tkw->svcc) {\n\t\tif (tkw->avcc) {\n\t\t\tif (!for_non_rap)\n\t\t\t\tmp4_mux_write_ps_list(bs, tkw->avcc->sequenceParameterSets, tkw->avcc->nal_unit_size);\n\t\t\t/*if (!tkw->nal_unit_size) */tkw->nal_unit_size = tkw->avcc->nal_unit_size;\n\t\t}\n\n\t\tif (tkw->svcc) {\n\t\t\tif (!for_non_rap)\n\t\t\t\tmp4_mux_write_ps_list(bs, tkw->svcc->sequenceParameterSets, tkw->svcc->nal_unit_size);\n\t\t\tif (!tkw->nal_unit_size) tkw->nal_unit_size = tkw->svcc->nal_unit_size;\n\t\t}\n\n\t\tif (tkw->avcc && tkw->avcc->sequenceParameterSetExtensions && !for_non_rap)\n\t\t\tmp4_mux_write_ps_list(bs, tkw->avcc->sequenceParameterSetExtensions, tkw->avcc->nal_unit_size);\n\n\t\tif (tkw->svcc && tkw->svcc->sequenceParameterSetExtensions && !for_non_rap)\n\t\t\tmp4_mux_write_ps_list(bs, tkw->svcc->sequenceParameterSetExtensions, tkw->svcc->nal_unit_size);\n\n\t\tif (tkw->avcc)\n\t\t\tmp4_mux_write_ps_list(bs, tkw->avcc->pictureParameterSets, tkw->avcc->nal_unit_size);\n\n\t\tif (tkw->svcc)\n\t\t\tmp4_mux_write_ps_list(bs, tkw->svcc->pictureParameterSets, tkw->svcc->nal_unit_size);\n\t}\n\tif (tkw->hvcc || tkw->lvcc) {\n\t\tif (tkw->hvcc) {\n\t\t\tif (!for_non_rap)\n\t\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->hvcc->param_array, GF_HEVC_NALU_VID_PARAM), tkw->hvcc->nal_unit_size);\n\t\t\tif (!tkw->nal_unit_size) tkw->nal_unit_size = tkw->hvcc->nal_unit_size;\n\t\t}\n\t\tif (tkw->lvcc) {\n\t\t\tif (!for_non_rap)\n\t\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->lvcc->param_array, GF_HEVC_NALU_VID_PARAM), tkw->lvcc->nal_unit_size);\n\t\t\tif (!tkw->nal_unit_size) tkw->nal_unit_size = tkw->lvcc->nal_unit_size;\n\t\t}\n\t\tif (tkw->hvcc && !for_non_rap)\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->hvcc->param_array, GF_HEVC_NALU_SEQ_PARAM), tkw->hvcc->nal_unit_size);\n\t\tif (tkw->lvcc && !for_non_rap)\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->lvcc->param_array, GF_HEVC_NALU_SEQ_PARAM), tkw->lvcc->nal_unit_size);\n\t\tif (tkw->hvcc)\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->hvcc->param_array, GF_HEVC_NALU_PIC_PARAM), tkw->hvcc->nal_unit_size);\n\t\tif (tkw->lvcc)\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->lvcc->param_array, GF_HEVC_NALU_PIC_PARAM), tkw->lvcc->nal_unit_size);\n\t}\n\n\tif (tkw->vvcc) {\n\t\tif (tkw->xps_inband==XPS_IB_PPS) {\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_PIC_PARAM), tkw->vvcc->nal_unit_size);\n\t\t\tif (!tkw->nal_unit_size) tkw->nal_unit_size = tkw->vvcc->nal_unit_size;\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_APS_PREFIX), tkw->vvcc->nal_unit_size);\n\t\t} else {\n\t\t\tif (!for_non_rap) {\n\t\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_OPI), tkw->vvcc->nal_unit_size);\n\t\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_DEC_PARAM), tkw->vvcc->nal_unit_size);\n\t\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_VID_PARAM), tkw->vvcc->nal_unit_size);\n\t\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_SEQ_PARAM), tkw->vvcc->nal_unit_size);\n\t\t\t}\n\t\t\tif (!tkw->nal_unit_size) tkw->nal_unit_size = tkw->vvcc->nal_unit_size;\n\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_PIC_PARAM), tkw->vvcc->nal_unit_size);\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_APS_PREFIX), tkw->vvcc->nal_unit_size);\n\t\t}\n\t}\n\n\tif (for_non_rap) {\n\t\tgf_bs_get_content(bs, &tkw->inband_hdr_non_rap, &tkw->inband_hdr_non_rap_size);\n\t} else {\n\t\tgf_bs_get_content(bs, &tkw->inband_hdr, &tkw->inband_hdr_size);\n\t}\n\tgf_bs_del(bs);\n\t//we may have cases where the param sets are updated before a non-IDR/SAP3 picture, we must inject asap at least once\n\ttkw->force_inband_inject = GF_TRUE;\n}\n\nvoid mp4_mux_get_video_size(GF_MP4MuxCtx *ctx, u32 *width, u32 *height)\n{\n\tu32 w, h, f_w, f_h, i;\n\n\tf_w = f_h = 0;\n\tfor (i=0; i<gf_isom_get_track_count(ctx->file); i++) {\n\t\tswitch (gf_isom_get_media_type(ctx->file, i+1)) {\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\tgf_isom_get_visual_info(ctx->file, i+1, 1, &w, &h);\n\t\t\tif (w > f_w) f_w = w;\n\t\t\tif (h > f_h) f_h = h;\n\t\t\t//fallthrough\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\t\tgf_isom_get_track_layout_info(ctx->file, i+1, &w, &h, NULL, NULL, NULL);\n\t\t\tif (w > f_w) f_w = w;\n\t\t\tif (h > f_h) f_h = h;\n\t\t\tbreak;\n\t\t}\n\t}\n\t(*width) = f_w ? f_w : TEXT_DEFAULT_WIDTH;\n\t(*height) = f_h ? f_h : TEXT_DEFAULT_HEIGHT;\n}\n\nstatic void mp4_mux_track_writer_del(TrackWriter *tkw)\n{\n\tif (tkw->avcc) gf_odf_avc_cfg_del(tkw->avcc);\n\tif (tkw->svcc) gf_odf_avc_cfg_del(tkw->svcc);\n\tif (tkw->hvcc) gf_odf_hevc_cfg_del(tkw->hvcc);\n\tif (tkw->lvcc) gf_odf_hevc_cfg_del(tkw->lvcc);\n\tif (tkw->vvcc) gf_odf_vvc_cfg_del(tkw->vvcc);\n\tif (tkw->inband_hdr) gf_free(tkw->inband_hdr);\n\tif (tkw->inband_hdr_non_rap) gf_free(tkw->inband_hdr_non_rap);\n\tif (tkw->dyn_pssh) gf_free(tkw->dyn_pssh);\n\tif (tkw->dgl_copy) gf_filter_pck_discard(tkw->dgl_copy);\n\tgf_free(tkw);\n}\n\nstatic void mp4_mux_write_track_refs(GF_MP4MuxCtx *ctx, TrackWriter *tkw, const char *rname, u32 rtype, Bool remove_from_pres)\n{\n\tu32 i;\n\tconst GF_PropertyValue *p = gf_filter_pid_get_property_str(tkw->ipid, rname);\n\tif (!p) return;\n\tfor (i=0; i<p->value.uint_list.nb_items; i++) {\n\t\tgf_isom_set_track_reference(ctx->file, tkw->track_num, rtype, p->value.uint_list.vals[i]);\n\t\tif (remove_from_pres) {\n\t\t\tgf_isom_set_track_flags(ctx->file, tkw->track_num, GF_ISOM_TK_IN_MOVIE|GF_ISOM_TK_IN_PREVIEW, GF_ISOM_TKFLAGS_REM);\n\t\t}\n\t}\n}\n\nstatic void mp4mux_track_reorder(void *udta, u32 old_track_num, u32 new_track_num)\n{\n\tGF_MP4MuxCtx *ctx = (GF_MP4MuxCtx *) udta;\n\tu32 i, count;\n\n\tif (ctx->chap_track_num==old_track_num) {\n\t\tctx->chap_track_num = new_track_num;\n\t\treturn;\n\t}\n\tcount = gf_list_count(ctx->tracks);\n\tfor (i=0; i<count; i++) {\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tif (!tkw->track_id) continue;\n\t\tif (tkw->track_num==old_track_num) {\n\t\t\ttkw->track_num = new_track_num;\n\t\t\t//prevent any further changes, trackID is restored in mp4mux_reorder_tracks\n\t\t\ttkw->track_id = 0;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void mp4mux_reorder_tracks(GF_MP4MuxCtx *ctx)\n{\n\tu32 i, count, prev_num, prev_pos;\n\tGF_List *new_tracks = gf_list_new();\n\tprev_num = prev_pos = 0;\n\tcount = gf_list_count(ctx->tracks);\n\tfor (i=0; i<count; i++) {\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tif (!tkw->track_id)\n\t\t\ttkw->track_id = gf_isom_get_track_id(ctx->file, tkw->track_num);\n\n\t\tif (tkw->track_num<prev_num) {\n\t\t\tgf_list_insert(new_tracks, tkw, prev_pos);\n\t\t} else {\n\t\t\tgf_list_add(new_tracks, tkw);\n\t\t}\n\t\tprev_pos = gf_list_count(new_tracks) - 1;\n\t\tprev_num = tkw->track_num;\n\t}\n\tif (gf_list_count(new_tracks)!=count) {\n\t\tgf_list_del(new_tracks);\n\t\treturn;\n\t}\n\tgf_list_del(ctx->tracks);\n\tctx->tracks = new_tracks;\n}\n\nstatic void mp4mx_set_track_group(GF_MP4MuxCtx *ctx, TrackWriter *tkw, char *name, const GF_PropertyValue *p)\n{\n\ts32 grp_id=0;\n\tu32 grp_type;\n\tu32 len = (u32) strlen(name);\n\tBool do_add=GF_TRUE;\n\tif (len!=4) return;\n\n\tif ((p->type==GF_PROP_STRING) || (p->type==GF_PROP_NAME)) {\n\t\tgrp_id = atoi(p->value.string);\n\t} else {\n\t\tgrp_id = p->value.sint;\n\t}\n\tif (grp_id<0) {\n\t\tgrp_id = -grp_id;\n\t\tdo_add = GF_FALSE;\n\t}\n\tgrp_type = GF_4CC(name[0], name[1], name[2], name[3]);\n\tgf_isom_set_track_group(ctx->file, tkw->track_num, grp_id, grp_type, do_add);\n}\n\n\n#include <gpac/revision.h>\nstatic void mp4_mux_set_tags(GF_MP4MuxCtx *ctx, TrackWriter *tkw)\n{\n\tu32 idx=0;\n\n\tif (!gf_sys_is_test_mode() && !gf_sys_old_arch_compat() ) {\n\t\tconst char *tool = \"GPAC-\"GPAC_VERSION\"-rev\"GPAC_GIT_REVISION;\n\t\tu32 len = (u32) strlen(tool);\n\t\tgf_isom_apple_set_tag(ctx->file, GF_ISOM_ITUNE_TOOL, tool, len, 0, 0);\n\t}\n\n\tif (ctx->itags==TAG_NONE) return;\n\n\twhile (1) {\n\t\tGF_Err e;\n\t\tu32 len;\n\t\tu32 prop_4cc=0;\n\t\tu32 itag;\n\t\ts32 tag_idx;\n\t\tconst char *tag_name=NULL;\n\t\tconst GF_PropertyValue *tag = gf_filter_pid_enum_properties(tkw->ipid, &idx, &prop_4cc, &tag_name);\n\t\tif (!tag) break;\n\n\t\tif (prop_4cc==GF_PROP_PID_COVER_ART) {\n\t\t\te = gf_isom_apple_set_tag(ctx->file, GF_ISOM_ITUNE_COVER_ART, tag->value.data.ptr, tag->value.data.size, 0, 0);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set cover art: %s\\n\", gf_error_to_string(e)));\n\t\t\t}\n\t\t}\n\t\tif (!tag_name)\n\t\t\tcontinue;\n\n\t\tif (!strncmp(tag_name, \"tkgp_\", 5)) {\n\t\t\tmp4mx_set_track_group(ctx, tkw, (char*) tag_name+5, tag);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttag_idx = gf_itags_find_by_name(tag_name);\n\t\tif (tag_idx>=0) {\n\t\t\titag = gf_itags_get_itag(tag_idx);\n\t\t} else if (!strnicmp(tag_name, \"qtt_\", 4)) {\n\t\t\ttag_name += 4;\n\n\t\t\tswitch (tag->type) {\n\t\t\tcase GF_PROP_DATA:\n\t\t\tcase GF_PROP_CONST_DATA:\n\t\t\tcase GF_PROP_DATA_NO_COPY:\n\t\t\t{\n\t\t\t\tGF_QT_UDTAKey key;\n\t\t\t\tkey.type = GF_QT_KEY_OPAQUE;\n\t\t\t\tkey.name = tag_name;\n\t\t\t\tkey.ns = GF_4CC('m','d','t','a');\n\t\t\t\tchar *sep = strchr(tag_name, '@');\n\t\t\t\tif (sep) {\n\t\t\t\t\tkey.name = sep+1;\n\t\t\t\t\tkey.ns = GF_4CC(tag_name[0], tag_name[1],tag_name[2],tag_name[3]);\n\t\t\t\t}\n\t\t\t\tkey.value.data.data = tag->value.data.ptr;\n\t\t\t\tkey.value.data.data_len = tag->value.data.size;\n\t\t\t\te = gf_isom_set_qt_key(ctx->file, &key);\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GF_PROP_POINTER:\n\t\t\t\te = GF_NOT_SUPPORTED;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\tchar szDump[GF_PROP_DUMP_ARG_SIZE];\n\t\t\t\tconst char *str = gf_props_dump_val(tag, szDump, GF_PROP_DUMP_DATA_NONE, NULL);\n\t\t\t\te = gf_media_isom_apply_qt_key(ctx->file, tag_name, str);\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set QT tag: %s\\n\", gf_error_to_string(e)));\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (ctx->itags==TAG_STRICT)\n\t\t\t\tcontinue;\n\n\t\t\tif (strnicmp(tag_name, \"tag_\", 4))\n\t\t\t\tcontinue;\n\n\t\t\ttag_name += 4;\n\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MP4Mux] Unrecognized tag %s: %s\\n\", tag_name, tag->value.string));\n\n\t\t\tif (strlen(tag_name)==4) {\n\t\t\t\titag = GF_4CC(tag_name[0], tag_name[1], tag_name[2], tag_name[3]);\n\t\t\t} else if (strlen(tag_name)==3) {\n\t\t\t\titag = GF_4CC(0xA9, tag_name[0], tag_name[1], tag_name[2]);\n\t\t\t} else {\n\t\t\t\titag = gf_crc_32(tag_name, (u32) strlen(tag_name));\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[MP4Mux] Tag name %s is not a 4CC, using CRC32 %08X as value\\n\", tag_name, itag));\n\t\t\t}\n\t\t}\n\n\t\tif (itag==GF_ISOM_ITUNE_TOOL) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (tag->type) {\n\t\tcase GF_PROP_STRING:\n\t\tcase GF_PROP_NAME:\n\t\t\tlen = tag->value.string ? (u32) strlen(tag->value.string) : 0;\n\t\t\te = gf_isom_apple_set_tag(ctx->file, itag, tag->value.string, len, 0, 0);\n\t\t\tbreak;\n\t\tcase GF_PROP_BOOL:\n\t\t\te = gf_isom_apple_set_tag(ctx->file, itag, NULL, 0, tag->value.boolean, 0);\n\t\t\tbreak;\n\t\tcase GF_PROP_UINT:\n\t\tcase GF_PROP_4CC:\n\t\t\te = gf_isom_apple_set_tag(ctx->file, itag, NULL, 0, tag->value.uint, 0);\n\t\t\tbreak;\n\t\tcase GF_PROP_LUINT:\n\t\t\te = gf_isom_apple_set_tag(ctx->file, itag, NULL, 0, tag->value.longuint, 0);\n\t\t\tbreak;\n\t\tcase GF_PROP_FRACTION:\n\t\t\te = gf_isom_apple_set_tag(ctx->file, itag, NULL, 0, tag->value.frac.num, tag->value.frac.den);\n\t\t\tbreak;\n\t\tcase GF_PROP_DATA:\n\t\tcase GF_PROP_CONST_DATA:\n\t\t\te = gf_isom_apple_set_tag(ctx->file, itag, tag->value.data.ptr, tag->value.data.size, 0, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set tag %s: invalid data format\\n\", gf_itags_get_name(tag_idx) ));\n\t\t\te = GF_OK;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set tag %s: %s\\n\", tag_name, gf_error_to_string(e)));\n\t\t}\n\t}\n}\n\nstatic void mp4_mux_set_udta(GF_MP4MuxCtx *ctx, TrackWriter *tkw)\n{\n\tu32 idx=0;\n\twhile (1) {\n\t\tGF_Err e;\n\t\tu32 prop_4cc=0;\n\t\tconst char *udta_name=NULL;\n\t\tconst GF_PropertyValue *udta = gf_filter_pid_enum_properties(tkw->ipid, &idx, &prop_4cc, &udta_name);\n\t\tif (!udta) break;\n\t\tif (!udta_name)\n\t\t\tcontinue;\n\t\tif (!strncmp(udta_name, \"udta_\", 5) || !strncmp(udta_name, \"mudta_\", 6) ) {\n\t\t\tu32 udta_type;\n\t\t\tu8 *data=NULL;\n\t\t\tu32 size=0;\n\t\t\tu32 track_num = 0;\n\n\t\t\tif (!strncmp(udta_name, \"udta_\", 5)) {\n\t\t\t\tudta_name += 5;\n\t\t\t\ttrack_num = tkw->track_num;\n\t\t\t} else {\n\t\t\t\tudta_name += 6;\n\t\t\t}\n\n\t\t\tif (strlen(udta_name) != 4) continue;\n\t\t\tudta_type = GF_4CC(udta_name[0], udta_name[1], udta_name[2], udta_name[3]);\n\n\t\t\tif (udta->type==GF_PROP_DATA) {\n\t\t\t\tdata = (u8 *) udta->value.data.ptr;\n\t\t\t\tsize = udta->value.data.size;\n\t\t\t} else if ((udta->type == GF_PROP_STRING) && udta->value.string) {\n\t\t\t\tdata = (u8 *) udta->value.string;\n\t\t\t\tsize = (u32) strlen(udta->value.string)+1;\n\t\t\t}\n\t\t\tif (!data) {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t} else {\n\t\t\t\te = gf_isom_add_user_data(ctx->file, track_num, udta_type, NULL, data, size);\n\t\t\t}\n\t\t}\n\t\telse if (!strcmp(udta_name, \"udtab\") || !strcmp(udta_name, \"mudtab\")) {\n\t\t\tu32 track_num = (!strcmp(udta_name, \"mudtab\")) ? 0 : tkw->track_num;\n\t\t\tif (udta->type == GF_PROP_DATA) {\n\t\t\t\te = gf_isom_add_user_data_boxes(ctx->file, track_num, udta->value.data.ptr, udta->value.data.size);\n\t\t\t} else {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t}\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set udta %s: %s\\n\", udta_name, gf_error_to_string(e)));\n\t\t}\n\t}\n}\n\nstatic void update_chap_refs(GF_MP4MuxCtx *ctx)\n{\n\tu32 i, j, count = gf_list_count(ctx->tracks);\n\tfor (i=0; i<count; i++) {\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tif (!tkw->is_chap) continue;\n\t\tfor (j=0; j<count; j++) {\n\t\t\tTrackWriter *atkw = gf_list_get(ctx->tracks, j);\n\t\t\tif (atkw->is_chap) continue;\n\t\t\tif ((atkw->stream_type==GF_STREAM_AUDIO) || (atkw->stream_type==GF_STREAM_VISUAL))\n\t\t\t\tgf_isom_set_track_reference(ctx->file, atkw->track_num, GF_ISOM_REF_CHAP, tkw->track_id);\n\t\t}\n\t}\n}\n\n\n\nstatic GF_Err mp4_mux_setup_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_true_pid)\n{\n\tvoid mux_assign_mime_file_ext(GF_FilterPid *ipid, GF_FilterPid *opid, const char *file_exts, const char *mime_types, const char *def_ext);\n\tBool use_m4sys = GF_FALSE;\n\tBool use_tx3g = GF_FALSE;\n\tBool use_webvtt = GF_FALSE;\n\tBool needs_track = GF_FALSE;\n\tu32 needs_sample_entry = 0; //1: change of codecID, 2 change of decoder config\n\tBool use_gen_sample_entry = GF_FALSE;\n\tBool skip_crypto = GF_FALSE;\n\tBool use_3gpp_config = GF_FALSE;\n\tBool use_ac3_entry = GF_FALSE;\n\tBool use_flac_entry = GF_FALSE;\n\tBool use_avc = GF_FALSE;\n\tBool use_hevc = GF_FALSE;\n\tBool use_vvc = GF_FALSE;\n\tBool use_hvt1 = GF_FALSE;\n\tBool use_av1 = GF_FALSE;\n\tBool use_vpX = GF_FALSE;\n\tBool use_mj2 = GF_FALSE;\n\tBool use_opus = GF_FALSE;\n\tBool use_dref = GF_FALSE;\n\tBool skip_dsi = GF_FALSE;\n\tBool is_text_subs = GF_FALSE;\n\tBool force_colr = GF_FALSE;\n\tu32 gen_dsi_wrap = 0;\n\tu32 m_subtype=0;\n\tu32 m_subtype_src=0;\n\tu32 m_subtype_alt_raw=0;\n\tu32 override_stype=0;\n\tu32 width, height, sr, nb_chan, nb_bps, z_order, txt_fsize;\n\tu32 afmt_flags = 0;\n\tu64 ch_layout;\n\tGF_Fraction fps, sar;\n\tGF_List *multi_pid_stsd = NULL;\n\tu32 multi_pid_idx = 0;\n\tGF_FilterPid *orig_pid = NULL;\n\tu32 codec_id, pix_fmt=0;\n\tu32 frames_per_sample_backup=0;\n\tu32 is_nalu_backup = NALU_NONE;\n\tBool is_tile_base = GF_FALSE;\n\tBool unknown_generic = GF_FALSE;\n\tu32 multi_pid_final_stsd_idx = 0;\n\tu32 audio_pli=0;\n\tu32 prev_codecid=0;\n\tBool force_tk_layout = GF_FALSE;\n\tBool force_mix_xps = GF_FALSE;\n\tBool make_inband_headers = GF_FALSE;\n\tBool is_prores = GF_FALSE;\n\tconst char *lang_name = NULL;\n\tconst char *comp_name = NULL;\n\tconst char *imp_name = NULL;\n\tconst char *src_url = NULL;\n\tconst char *meta_mime = NULL;\n\tconst char *meta_encoding = NULL;\n\tconst char *meta_config = NULL;\n\tconst char *meta_xmlns = NULL;\n\tconst char *meta_schemaloc = NULL;\n\tconst char *meta_auxmimes = NULL;\n\tconst char *meta_content_encoding = NULL;\n\tchar *txt_font = NULL;\n\n\tu32 i, count, reuse_stsd = 0;\n\tGF_Err e;\n\tconst GF_PropertyValue *dsi=NULL;\n\tconst GF_PropertyValue *enh_dsi=NULL;\n\tconst GF_PropertyValue *p;\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_AudioSampleEntryImportMode ase_mode = ctx->ase;\n\tTrackWriter *tkw;\n\tu32 xps_inband = XPS_IB_NO;\n\n\tif (ctx->owns_mov && !ctx->opid) {\n\t\tchar *dst;\n\t\tctx->opid = gf_filter_pid_new(filter);\n\n\t\tdst = gf_filter_get_dst_name(filter);\n\t\tif (dst) {\n\t\t\tchar *ext = gf_file_ext_start(dst);\n\t\t\tif (ext && (!stricmp(ext, \".mov\") || !stricmp(ext, \".qt\")) ) {\n\t\t\t\tctx->make_qt = 1;\n\t\t\t}\n\t\t\tgf_free(dst);\n\t\t}\n\t} else {\n\t\tconst char *fname = gf_isom_get_filename(ctx->file);\n\t\tchar *ext = fname ? gf_file_ext_start(fname) : NULL;\n\t\tif (ext && (!stricmp(ext, \".mov\") || !stricmp(ext, \".qt\")) ) {\n\t\t\tctx->make_qt = 1;\n\t\t}\n\t}\n\t//copy properties at init or reconfig\n\tif (ctx->opid && is_true_pid) {\n\t\tgf_filter_pid_copy_properties(ctx->opid, pid);\n\t\tif (gf_list_count(ctx->tracks)>1)\n\t\t\tgf_filter_pid_set_name(ctx->opid, \"isobmf_mux\");\n\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, NULL);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT, NULL);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, NULL);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_FILE) );\n\n\t\tmux_assign_mime_file_ext(pid, ctx->opid, ISOM_FILE_EXT, ISOM_FILE_MIME, NULL);\n\t\t\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DASH_MODE, NULL);\n\t\t//we dispatch timing in milliseconds\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(1000));\n\n\t\tswitch (ctx->store) {\n\t\tcase MP4MX_MODE_FLAT:\n\t\tcase MP4MX_MODE_FASTSTART:\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DISABLE_PROGRESSIVE, &PROP_UINT(GF_PID_FILE_PATCH_INSERT) );\n\t\t\tbreak;\n\t\tcase MP4MX_MODE_INTER:\n\t\tcase MP4MX_MODE_TIGHT:\n\t\t\tgf_filter_pid_allow_direct_dispatch(ctx->opid);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TILE_BASE);\n\tif (p && p->value.boolean)\n\t\tis_tile_base = GF_TRUE;\n\n\tif (is_true_pid && !is_tile_base) {\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DASH_MULTI_TRACK);\n\t\tif (p) {\n\t\t\tu32 j, count2;\n\t\t\tGF_List *multi_tracks = p->value.ptr;\n\t\t\tcount = gf_list_count(multi_tracks);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_FilterPid *a_ipid = gf_list_get(multi_tracks, i);\n\t\t\t\tconst GF_PropertyValue *a_pidid = gf_filter_pid_get_property(a_ipid, GF_PROP_PID_ID);\n\t\t\t\tcount2 = gf_list_count(ctx->tracks);\n\t\t\t\tfor (j=0; j<count2; j++) {\n\t\t\t\t\tTrackWriter *atkw = gf_list_get(ctx->tracks, j);\n\t\t\t\t\tconst GF_PropertyValue *c_pidid = gf_filter_pid_get_property(atkw->ipid, GF_PROP_PID_ID);\n\t\t\t\t\tif (gf_props_equal(a_pidid, c_pidid)) {\n\t\t\t\t\t\ta_ipid = NULL;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (a_ipid)\n\t\t\t\t\tmp4_mux_setup_pid(filter, a_ipid, GF_FALSE);\n\t\t\t}\n\t\t}\n\t}\n\n\taudio_pli = gf_isom_get_pl_indication(ctx->file, GF_ISOM_PL_AUDIO);\n\n\t//new pid ?\n\ttkw = gf_filter_pid_get_udta(pid);\n\tif (!tkw) {\n\t\tGF_FilterEvent evt;\n\t\tGF_SAFEALLOC(tkw, TrackWriter);\n\t\tif (!tkw) return GF_OUT_OF_MEM;\n\t\t\n\t\tgf_list_add(ctx->tracks, tkw);\n\t\ttkw->ipid = pid;\n\t\ttkw->fake_track = !is_true_pid;\n\t\ttkw->min_cts = (u64) -1;\n\n\t\tif (is_true_pid) {\n\t\t\tgf_filter_pid_set_udta(pid, tkw);\n\n\t\t\ttkw->is_hevc_tile_base = is_tile_base;\n#ifdef GPAC_ENABLE_COVERAGE\n\t\t\tif (gf_sys_is_cov_mode()) {\n\t\t\t\tgf_filter_pid_get_min_pck_duration(pid);\n\t\t\t}\n#endif\n\t\t\tif (!ctx->owns_mov || ctx->force_play) {\n\t\t\t\tif (!ctx->owns_mov) {\n\t\t\t\t\tif (ctx->start != 0)\n\t\t\t\t\t\ttkw->wait_sap = GF_TRUE;\n\t\t\t\t\tgf_filter_pid_init_play_event(pid, &evt, ctx->start, 0, \"MP4Mux\");\n\t\t\t\t} else {\n\t\t\t\t\tGF_FEVT_INIT(evt, GF_FEVT_PLAY, pid);\n\t\t\t\t}\n\t\t\t\tgf_filter_pid_send_event(pid, &evt);\n\t\t\t}\n\t\t\tgf_filter_pid_set_framing_mode(pid, GF_TRUE);\n\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ITEM_ID);\n\t\t\tif (p) {\n\t\t\t\ttkw->is_item = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tctx->config_timing = GF_TRUE;\n\t\t\t\tctx->update_report = GF_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\t//check change of pid config\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DEPENDENCY_ID);\n\tif (p) {\n\t\tif (p->value.uint!=tkw->dep_id) needs_track = GF_TRUE;\n\t\ttkw->dep_id = p->value.uint;\n\t}\n\n\t//check change of pid config\n\tprev_codecid = tkw->codecid;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CODECID);\n\tif (p) {\n\t\tif (p->value.uint!=tkw->codecid) needs_sample_entry = 1;\n\t\ttkw->codecid = p->value.uint;\n\t}\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_STREAM_TYPE);\n\tif (p) {\n\t\tu32 stype = p->value.uint;\n\t\tif (tkw->is_encrypted && (p->value.uint==GF_STREAM_ENCRYPTED) ) {\n\t\t\tstype = gf_codecid_type(tkw->codecid);\n\t\t}\n\t\tif (stype != tkw->stream_type) {\n\t\t\tneeds_track = GF_TRUE;\n\t\t\ttkw->stream_type = stype;\n\t\t\tconst char *name = gf_stream_type_name(stype);\n\t\t\ttkw->status_type = name ? name[0] : 'U';\n\t\t}\n\t}\n\n\tdsi = gf_filter_pid_get_property(pid, GF_PROP_PID_DECODER_CONFIG);\n\tif (dsi) {\n\t\tu32 cfg_crc = gf_crc_32(dsi->value.data.ptr, dsi->value.data.size);\n\t\tif ((cfg_crc!=tkw->cfg_crc) && !needs_sample_entry)\n\t\t\tneeds_sample_entry = 2;\n\t\ttkw->cfg_crc = cfg_crc;\n\t} else if (tkw->cfg_crc) {\n\t\ttkw->cfg_crc = 0;\n\t\tif (!needs_sample_entry)\n\t\t\tneeds_sample_entry = 2;\n\t}\n\n\tenh_dsi = gf_filter_pid_get_property(pid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT);\n\tif (enh_dsi && (enh_dsi->type==GF_PROP_DATA) ) {\n\t\tu32 cfg_crc = gf_crc_32(enh_dsi->value.data.ptr, enh_dsi->value.data.size);\n\t\tif ((cfg_crc!=tkw->enh_cfg_crc) && !needs_sample_entry)\n\t\t\tneeds_sample_entry = 2;\n\t\ttkw->enh_cfg_crc = cfg_crc;\n\t} else if (tkw->enh_cfg_crc) {\n\t\ttkw->enh_cfg_crc = 0;\n\t\tif (!needs_sample_entry)\n\t\t\tneeds_sample_entry = 2;\n\t}\n\n\t//store current cenc pattern if any\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CENC_PATTERN);\n\tif (p) {\n\t\ttkw->skip_byte_block = p->value.frac.num;\n\t\ttkw->crypt_byte_block = p->value.frac.den;\n\t} else {\n\t\ttkw->skip_byte_block = tkw->crypt_byte_block = 0;\n\t}\n\n\t//TODO: try to merge PPS/SPS for AVC and HEVC rather than creating a new sample description\n\n\tswitch (tkw->codecid) {\n\tcase GF_CODECID_AAC_MPEG4:\n\tcase GF_CODECID_AAC_MPEG2_MP:\n\tcase GF_CODECID_AAC_MPEG2_LCP:\n\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\tcase GF_CODECID_USAC:\n\tcase GF_CODECID_MPEG4_PART2:\n\tcase GF_CODECID_AVC:\n\tcase GF_CODECID_SVC:\n\tcase GF_CODECID_HEVC:\n\tcase GF_CODECID_LHVC:\n\tcase GF_CODECID_MPEG1:\n\tcase GF_CODECID_MPEG2_422:\n\tcase GF_CODECID_MPEG2_SNR:\n\tcase GF_CODECID_MPEG2_HIGH:\n\tcase GF_CODECID_MPEG2_MAIN:\n\tcase GF_CODECID_MPEG2_SIMPLE:\n\tcase GF_CODECID_MPEG2_SPATIAL:\n\tcase GF_CODECID_VP8:\n\tcase GF_CODECID_VP9:\n\tcase GF_CODECID_AV1:\n\tcase GF_CODECID_AC3:\n\tcase GF_CODECID_EAC3:\n\tcase GF_CODECID_OPUS:\n\tcase GF_CODECID_TRUEHD:\n\tcase GF_CODECID_RAW_UNCV:\n\t\tif (!dsi && !enh_dsi) return GF_OK;\n\t\tbreak;\n\tcase GF_CODECID_APCH:\n\tcase GF_CODECID_APCO:\n\tcase GF_CODECID_APCN:\n\tcase GF_CODECID_APCS:\n\tcase GF_CODECID_AP4X:\n\tcase GF_CODECID_AP4H:\n\t\tif (!ctx->make_qt) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[MP4Mux] ProRes track detected, muxing to QTFF even though ISOBMFF was asked\\n\"));\n\t\t\tctx->make_qt = 2;\n\t\t}\n\t\tif (ctx->prores_track && (ctx->prores_track != tkw)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] More than one ProRes track detected, result might be non compliant\\n\"));\n\t\t}\n\t\tis_prores = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_TX3G:\n\tcase GF_CODECID_WEBVTT:\n\tcase GF_CODECID_DVB_SUBS:\n\t\tif (!dsi && !enh_dsi) return GF_OK;\n\t\tbreak;\n\tcase GF_CODECID_RAW:\n\t\tif (tkw->stream_type==GF_STREAM_VISUAL) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PIXFMT);\n\t\t\tif (!p) return GF_OK;\n\t\t}\n\t\tif (tkw->stream_type==GF_STREAM_AUDIO) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_AUDIO_FORMAT);\n\t\t\tif (!p) return GF_OK;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (!tkw->track_num) {\n\t\tneeds_sample_entry = 1;\n\t\tneeds_track = GF_TRUE;\n\t}\n\n\tif (ctx->make_qt) {\n\t\tgf_isom_remove_root_od(ctx->file);\n\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_QT, 512);\n\t\tgf_isom_reset_alt_brands(ctx->file);\n\t\ttkw->has_brands = GF_TRUE;\n\t\tctx->major_brand_set = GF_ISOM_BRAND_QT;\n\t\tctx->btrt = GF_FALSE;\n\n\t\tif (is_prores && !ctx->prores_track) {\n\t\t\tctx->prores_track = tkw;\n\t\t}\n\t}\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_URL);\n\tif (p) src_url = p->value.string;\n\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DASH_MODE);\n\tif (p) {\n\t\tctx->dash_mode = MP4MX_DASH_ON;\n\t\tif (p->value.uint==2) {\n\t\t\te = mp4mx_setup_dash_vod(ctx, tkw);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\t//we consider that when muxing single segments, we are always in DASH, not VoD mode\n\telse if (ctx->noinit) {\n\t\tctx->dash_mode = MP4MX_DASH_ON;\n\t}\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_LLHLS);\n\tctx->llhls_mode = p ? p->value.uint : 0;\n\t//insert tfdt in each traf for LL-HLS so that correct timing can be found when doing in-segment tune-in\n\tif (ctx->llhls_mode) {\n\t\tctx->tfdt_traf = GF_TRUE;\n\t\tctx->store = MP4MX_MODE_SFRAG;\n\t}\n\n\tif (ctx->dash_mode == MP4MX_DASH_ON) {\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FORCE_SEG_SYNC);\n\t\tif (p && p->value.boolean)\n\t\t\tctx->force_seg_sync = GF_TRUE;\n\t}\n\n\tif (!ctx->cdur_set) {\n\t\tctx->cdur_set = GF_TRUE;\n\t\tif (ctx->cdur.num<0) {\n\t\t\tif (ctx->make_qt) {\n\t\t\t\tctx->cdur.num = 1000;\n\t\t\t\tctx->cdur.den = 2000;\n\t\t\t} else {\n\t\t\t\tctx->cdur.num = 1000;\n\t\t\t\tctx->cdur.den = 1000;\n\t\t\t\tif (ctx->dash_mode)\n\t\t\t\t\tctx->fragdur = GF_FALSE;\n\t\t\t}\n\t\t} else if (ctx->dash_mode)\n\t\t\tctx->fragdur = GF_TRUE;\n\t}\n\n\tif (needs_track) {\n\t\tif (ctx->init_movie_done) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot add track to already finalized movie in fragmented file, will request a new muxer for that track\\n\"));\n\t\t\treturn GF_REQUIRES_NEW_INSTANCE;\n\t\t}\n\t\tif (tkw->is_item) {\n\t\t\tneeds_track = GF_FALSE;\n\n\t\t\tif (tkw->stream_type == GF_STREAM_ENCRYPTED) {\n\t\t\t\ttkw->is_encrypted = GF_TRUE;\n\t\t\t\ttkw->stream_type = gf_codecid_type(tkw->codecid);\n\t\t\t\ttkw->insert_pssh = GF_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (needs_track) {\n\t\tu32 tkid=0;\n\t\tu32 tk_idx=0;\n\t\tu32 mtype=0;\n\t\tu32 target_timescale = 0;\n\t\tBool hdlr_name_set=GF_FALSE;\n\n\t\tif (ctx->make_qt && (tkw->stream_type==GF_STREAM_VISUAL)) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FPS);\n\t\t\tif (p) {\n\t\t\t\tu32 ts=p->value.frac.num, inc=p->value.frac.den;\n\t\t\t\tif (inc * 24000 == ts * 1001) target_timescale = 24000;\n\t\t\t\telse if (inc * 2400 == ts * 100) target_timescale = 2400;\n\t\t\t\telse if (inc * 2500 == ts * 100) target_timescale = 2500;\n\t\t\t\telse if (inc * 30000 == ts * 1001) target_timescale = 30000;\n\t\t\t\telse if (inc * 2997 == ts * 100) target_timescale = 30000;\n\t\t\t\telse if (inc * 3000 == ts * 100) target_timescale = 3000;\n\t\t\t\telse if (inc * 5000 == ts * 100) target_timescale = 5000;\n\t\t\t\telse if (inc * 60000 == ts * 1001) target_timescale = 60000;\n\t\t\t\telse if (inc * 5994 == ts * 100) target_timescale = 60000;\n\t\t\t\telse if (is_prores) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[ProRes] Unrecognized frame rate %g\\n\", ((Double)ts)/inc ));\n\t\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ctx->prores_track)\n\t\t\t\tctx->prores_track = tkw;\n\t\t}\n\n\t\tif (!ctx->moov_inserted) {\n\t\t\tif (target_timescale) {\n\t\t\t\tctx->moovts = target_timescale;\n\t\t\t\tgf_isom_set_timescale(ctx->file, target_timescale);\n\t\t\t} else if (ctx->moovts>=0) {\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_MOVIE_TIME);\n\t\t\t\tif (p && p->value.lfrac.den) {\n\t\t\t\t\tgf_isom_set_timescale(ctx->file, (u32) p->value.lfrac.den);\n\t\t\t\t\tctx->moovts = (u32) p->value.lfrac.den;\n\t\t\t\t} else {\n\t\t\t\t\tgf_isom_set_timescale(ctx->file, ctx->moovts);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ctx->store==MP4MX_MODE_FASTSTART) {\n\t\t\t\tgf_isom_make_interleave_ex(ctx->file, &ctx->cdur);\n\t\t\t}\n\t\t}\n\n\t\t//assign some defaults\n\t\ttkw->src_timescale = 0;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\t\tif (p) tkw->src_timescale = p->value.uint;\n\n\t\tu32 mtimescale = 1000;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_SAMPLE_RATE);\n\t\tif (p) mtimescale = p->value.uint;\n\t\telse {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FPS);\n\t\t\tif (p && p->value.frac.den) mtimescale = p->value.frac.den;\n\t\t}\n\t\tif (!tkw->src_timescale) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] No timescale specified, guessing from media: %d\\n\", mtimescale));\n\t\t\ttkw->src_timescale = mtimescale;\n\t\t}\n\t\tif (target_timescale) tkw->tk_timescale = target_timescale;\n\t\telse if (ctx->mediats>0) tkw->tk_timescale = ctx->mediats;\n\t\telse if (ctx->mediats<0) tkw->tk_timescale = mtimescale;\n\t\telse tkw->tk_timescale = tkw->src_timescale;\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ESID);\n\t\tif (!p) p = gf_filter_pid_get_property(pid, GF_PROP_PID_ID);\n\t\tif (p) tkid = p->value.uint;\n\n\t\tif (tkw->stream_type == GF_STREAM_ENCRYPTED) {\n\t\t\ttkw->is_encrypted = GF_TRUE;\n\t\t\ttkw->stream_type = gf_codecid_type(tkw->codecid);\n\t\t}\n\t\tmtype = gf_isom_stream_type_to_media_type(tkw->stream_type, tkw->codecid);\n\n\t\tif (ctx->moovts<0) {\n\t\t\tctx->moovts = tkw->tk_timescale;\n\t\t\tgf_isom_set_timescale(ctx->file, (u32) ctx->moovts);\n\t\t}\n\t\tif (ctx->pad_sparse) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_SPARSE);\n\t\t\tif (p) {\n\t\t\t\ttkw->sparse_inject = p->value.boolean;\n\t\t\t} else {\n\t\t\t\tswitch (tkw->stream_type) {\n\t\t\t\tcase GF_STREAM_TEXT:\n\t\t\t\tcase GF_STREAM_METADATA:\n\t\t\t\t\tswitch (tkw->codecid) {\n\t\t\t\t\tcase GF_CODECID_TEXT_MPEG4:\n\t\t\t\t\tcase GF_CODECID_TX3G:\n\t\t\t\t\tcase GF_CODECID_WEBVTT:\n\t\t\t\t\tcase GF_CODECID_SUBS_XML:\n\t\t\t\t\tcase GF_CODECID_SUBPIC:\n\t\t\t\t\tcase GF_CODECID_TMCD:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\ttkw->sparse_inject = GF_TRUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_MUX_INDEX);\n\t\tif (p) {\n\t\t\ttk_idx = p->value.uint;\n\t\t\tif (!ctx->owns_mov) {\n\t\t\t\tu32 nb_dst_tk = gf_isom_get_track_count(ctx->file);\n\t\t\t\tif (tk_idx < nb_dst_tk) {\n\t\t\t\t\t//tk_idx = nb_dst_tk;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->keep_utc) {\n\t\t\tif (!gf_isom_get_track_count(ctx->file)) {\n\t\t\t\tu64 create_date=0, modif_date=0;\n\t\t\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"isom:creation_date\");\n\t\t\t\tif (p && (p->type==GF_PROP_LUINT)) create_date = p->value.longuint;\n\t\t\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"isom:modification_date\");\n\t\t\t\tif (p && (p->type==GF_PROP_LUINT)) modif_date = p->value.longuint;\n\n\t\t\t\tif (create_date && modif_date)\n\t\t\t\t\tgf_isom_set_creation_time(ctx->file, create_date, modif_date);\n\t\t\t}\n\t\t\tgf_isom_keep_utc_times(ctx->file, GF_TRUE);\n\t\t}\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_TRACK_TEMPLATE);\n\t\tif (ctx->tktpl && p && p->value.data.ptr) {\n\t\t\tBool udta_only = (ctx->tktpl==2) ? GF_TRUE : GF_FALSE;\n\n\n\t\t\ttkw->track_num = gf_isom_new_track_from_template(ctx->file, tkid, mtype, tkw->tk_timescale, p->value.data.ptr, p->value.data.size, udta_only);\n\t\t\tif (!tkw->track_num) {\n\t\t\t\ttkw->track_num = gf_isom_new_track_from_template(ctx->file, 0, mtype, tkw->tk_timescale, p->value.data.ptr, p->value.data.size, udta_only);\n\t\t\t}\n\t\t\t//purge all track references we inject internally\n\t\t\tif (tkw->track_num) {\n\t\t\t\tgf_isom_remove_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_SCAL);\n\t\t\t\tgf_isom_remove_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_SABT);\n\t\t\t\tgf_isom_remove_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_TBAS);\n\t\t\t\tgf_isom_remove_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_OREF);\n\t\t\t\tgf_isom_remove_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_BASE);\n\t\t\t}\n\n\t\t\tif (!ctx->btrt) {\n\t\t\t\tgf_isom_update_bitrate(ctx->file, tkw->track_num, 0, 0, 0, 0);\n\t\t\t}\n\t\t\tif (!udta_only) {\n\t\t\t\tGF_Err gf_isom_set_track_stsd_templates(GF_ISOFile *movie, u32 trackNumber, u8 *stsd_data, u32 stsd_data_size);\n\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_STSD_ALL_TEMPLATES);\n\t\t\t\tif (p) {\n\t\t\t\t\tgf_isom_set_track_stsd_templates(ctx->file, tkw->track_num, p->value.data.ptr, p->value.data.size);\n\t\t\t\t\ttkw->all_stsd_crc = gf_crc_32(p->value.data.ptr, p->value.data.size);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tif (!mtype) {\n\t\t\t\tmtype = GF_4CC('u','n','k','n');\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to find ISOM media type for stream type %s codec %s\\n\", gf_stream_type_name(tkw->stream_type), gf_codecid_name(tkw->codecid) ));\n\t\t\t}\n\t\t\tif (!tkid) tkid = tk_idx;\n\n\t\t\tif (ctx->trackid) {\n\t\t\t\tif (ctx->trackid==(u32)-1) tkid = 0;\n\t\t\t\telse tkid = ctx->trackid;\n\t\t\t}\n\n\t\t\ttkw->track_num = gf_isom_new_track(ctx->file, tkid, mtype, tkw->tk_timescale);\n\t\t\tif (!tkw->track_num) {\n\t\t\t\ttkw->track_num = gf_isom_new_track(ctx->file, 0, mtype, tkw->tk_timescale);\n\t\t\t}\n\t\t\t//FIXME once we finally merge to filters, there is an old bug in isobmff initializing the width and height to 320x240 which breaks text import\n\t\t\t//this should be removed and hashes regenerated\n\t\t\tgf_isom_set_track_layout_info(ctx->file, tkw->track_num, 0, 0, 0, 0, 0);\n\n\t\t\tif (!gf_sys_is_test_mode() && !gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_HANDLER)) {\n\t\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_URL);\n\t\t\t\tif (tkw->track_num && p && p->value.string) {\n\t\t\t\t\tchar szHName[1025];\n\t\t\t\t\tchar *f = gf_file_basename(p->value.string);\n\t\t\t\t\tszHName[1024]=0;\n\t\t\t\t\tsnprintf(szHName, 1024, \"*%s@GPAC%s\", f ? f : \"\", gf_gpac_version() );\n\t\t\t\t\tgf_isom_set_handler_name(ctx->file, tkw->track_num, szHName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!tkw->track_num) {\n\t\t\te = gf_isom_last_error(ctx->file);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to create new track: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->track_id = gf_isom_get_track_id(ctx->file, tkw->track_num);\n\n\t\tBool is_disabled = GF_FALSE;\n\t\t//cmaf mandates these flags and only them are set\n\t\tif (ctx->cmaf) {\n\t\t\tgf_isom_set_track_flags(ctx->file, tkw->track_num, GF_ISOM_TK_ENABLED|GF_ISOM_TK_IN_MOVIE|GF_ISOM_TK_IN_PREVIEW, GF_ISOM_TKFLAGS_SET);\n\t\t}\n\t\telse {\n\t\t\t//unless in test mode or old arch compat, set track to be enabled, in movie and in preview\n\t\t\tif (!gf_sys_is_test_mode() && !gf_sys_old_arch_compat()) {\n\t\t\t\tgf_isom_set_track_flags(ctx->file, tkw->track_num, GF_ISOM_TK_IN_MOVIE|GF_ISOM_TK_IN_PREVIEW, GF_ISOM_TKFLAGS_SET);\n\t\t\t}\n\n\t\t\t//override flags if provided\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_TRACK_FLAGS);\n\t\t\tif (p) {\n\t\t\t\tgf_isom_set_track_flags(ctx->file, tkw->track_num, p->value.uint, GF_ISOM_TKFLAGS_SET);\n\t\t\t} else {\n\t\t\t\tgf_isom_set_track_enabled(ctx->file, tkw->track_num, GF_TRUE);\n\t\t\t}\n\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DISABLED);\n\t\t\tif (p && p->value.boolean) {\n\t\t\t\tgf_isom_set_track_enabled(ctx->file, tkw->track_num, GF_FALSE);\n\t\t\t\tis_disabled = GF_TRUE;\n\t\t\t}\n\t\t}\n\n\t\t//if we have a subtype set for the pid, use it\n\t\tp = NULL;\n\t\tif ((tkw->stream_type==GF_STREAM_TEXT) && (tkw->codecid==GF_CODECID_TX3G)) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_IS_CHAP);\n\t\t\tif (p && p->value.boolean) {\n\t\t\t\tmtype = GF_ISOM_MEDIA_TEXT;\n\t\t\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, mtype);\n\t\t\t\ttkw->is_chap = GF_TRUE;\n\t\t\t\tctx->has_chap_tracks = GF_TRUE;\n\t\t\t\tgf_isom_set_track_enabled(ctx->file, tkw->track_num, GF_FALSE);\n\t\t\t} else {\n\t\t\t\tp = NULL;\n\t\t\t}\n\t\t}\n\t\tif (!p) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_SUBTYPE);\n\t\t\tif (p) {\n\t\t\t\tmtype = p->value.uint;\n\t\t\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, mtype);\n\t\t\t}\n\t\t}\n\t\tif (ctx->has_chap_tracks)\n\t\t\tupdate_chap_refs(ctx);\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_HANDLER);\n\t\tif (p && p->value.string) {\n\t\t\tgf_isom_set_handler_name(ctx->file, tkw->track_num, p->value.string);\n\t\t\thdlr_name_set = GF_TRUE;\n\t\t}\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_ALT_GROUP);\n\t\tif (p && p->value.uint) {\n\t\t\tgf_isom_set_alternate_group_id(ctx->file, tkw->track_num, p->value.uint);\n\t\t} else if (!p && !gf_sys_is_test_mode()) {\n\t\t\t//we by default set groups for audio and subs if group is not present\n\t\t\tif (mtype==GF_ISOM_SUBTYPE_SUBTITLE) {\n\t\t\t\tgf_isom_set_alternate_group_id(ctx->file, tkw->track_num, 2);\n\t\t\t}\n\t\t\tif (tkw->stream_type==GF_STREAM_AUDIO) {\n\t\t\t\tgf_isom_set_alternate_group_id(ctx->file, tkw->track_num, 1);\n\t\t\t}\n\t\t}\n\n\t\t//check if we have default flag set\n\t\tif (!is_disabled && !ctx->cmaf) {\n\t\t\tBool *has_def = NULL;\n\t\t\tif (tkw->stream_type==GF_STREAM_VISUAL) has_def = &ctx->has_def_vid;\n\t\t\telse if (tkw->stream_type==GF_STREAM_AUDIO) has_def = &ctx->has_def_aud;\n\t\t\telse if (tkw->stream_type==GF_STREAM_TEXT) has_def = &ctx->has_def_txt;\n\n\t\t\tBool set_def = GF_FALSE;\n\t\t\tBool set_all_def = GF_FALSE;\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_IS_DEFAULT);\n\t\t\t//first track of this kind set to default, deactivate all except this track\n\t\t\tif (has_def && ! *has_def && p && p->value.boolean) {\n\t\t\t\t*has_def = GF_TRUE;\n\t\t\t\tset_def = GF_TRUE;\n\t\t\t}\n\t\t\t//second or more track of this kind set to default, re-activate all\n\t\t\telse if (has_def && *has_def && p && p->value.boolean) {\n\t\t\t\tset_all_def = GF_TRUE;\n\t\t\t}\n\t\t\tif (set_def || set_all_def) {\n\t\t\t\tu32 nb_tk = gf_list_count(ctx->tracks);\n\t\t\t\tfor (i=0; i<nb_tk; i++) {\n\t\t\t\t\tTrackWriter *atk = gf_list_get(ctx->tracks, i);\n\t\t\t\t\tif (atk->stream_type != tkw->stream_type) continue;\n\t\t\t\t\tif (set_all_def || (tkw == atk)) {\n\t\t\t\t\t\tgf_isom_set_track_flags(ctx->file, atk->track_num, GF_ISOM_TK_IN_MOVIE|GF_ISOM_TK_IN_PREVIEW, GF_ISOM_TKFLAGS_ADD);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_isom_set_track_flags(ctx->file, atk->track_num, GF_ISOM_TK_IN_MOVIE|GF_ISOM_TK_IN_PREVIEW, GF_ISOM_TKFLAGS_REM);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//no default prop and a default exists for this kind, update flags\n\t\t\telse if (has_def && *has_def) {\n\t\t\t\tgf_isom_set_track_flags(ctx->file, tkw->track_num, GF_ISOM_TK_IN_MOVIE|GF_ISOM_TK_IN_PREVIEW, GF_ISOM_TKFLAGS_REM);\n\t\t\t}\n\t\t}\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_TRACK_MATRIX);\n\t\tif (p && (p->value.sint_list.nb_items==9)) {\n\t\t\tgf_isom_set_track_matrix(ctx->file, tkw->track_num, (s32 *) p->value.sint_list.vals);\n\t\t}\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_SRC_MAGIC);\n\t\tif (p) {\n\t\t\tu64 magic = 0;\n\t\t\tif (hdlr_name_set) {\n\t\t\t\tmagic |= 1;\n\t\t\t\tmagic <<= 32;\n\t\t\t}\n\t\t\tmagic |= p->value.longuint;\n\t\t\tgf_isom_set_track_magic(ctx->file, tkw->track_num, magic);\n\t\t}\n\t\tif (tk_idx) {\n\t\t\tgf_isom_set_track_index(ctx->file, tkw->track_num, tk_idx, mp4mux_track_reorder, ctx);\n\t\t\tmp4mux_reorder_tracks(ctx);\n\t\t}\n\n\t\t//by default use cttsv1 (negative ctts)\n\t\tgf_isom_set_composition_offset_mode(ctx->file, tkw->track_num, GF_TRUE);\n\n\t\tp = ctx->make_qt ? NULL : gf_filter_pid_get_property(pid, GF_PROP_PID_PROFILE_LEVEL);\n\t\tif (p) {\n\t\t\ttkw->media_profile_level = p->value.uint;\n\t\t\tif (tkw->stream_type == GF_STREAM_AUDIO) {\n\t\t\t\t//patch to align old arch (IOD not written in dash) with new\n\t\t\t\tif (!ctx->dash_mode) {\n\t\t\t\t\tgf_isom_set_pl_indication(ctx->file, GF_ISOM_PL_AUDIO, p->value.uint);\n\t\t\t\t}\n\t\t\t} else if (tkw->stream_type == GF_STREAM_VISUAL) {\n\t\t\t\t//patch to align old arch (IOD not written in dash) with new\n\t\t\t\tif (!ctx->dash_mode) {\n\t\t\t\t\tgf_isom_set_pl_indication(ctx->file, GF_ISOM_PL_VISUAL, p->value.uint);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->mudta && gf_isom_get_track_count(ctx->file)==1) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_UDTA);\n\t\t\tif (ctx->tktpl && p && p->value.data.ptr) {\n\t\t\t\tgf_isom_load_extra_boxes(ctx->file, p->value.data.ptr, p->value.data.size, (ctx->mudta==2) ? GF_TRUE : GF_FALSE);\n\t\t\t}\n\t\t}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (ctx->sgpd_traf)\n\t\t\tgf_isom_set_sample_group_in_traf(ctx->file);\n#endif\n\t\tif (ctx->noroll) {\n\t\t\tgf_isom_remove_sample_group(ctx->file, tkw->track_num, GF_ISOM_SAMPLE_GROUP_ROLL);\n\t\t}\n\t\tif (ctx->norap) {\n\t\t\tgf_isom_remove_sample_group(ctx->file, tkw->track_num, GF_ISOM_SAMPLE_GROUP_RAP);\n\t\t}\n\n\n\t\tif (ctx->dash_mode==MP4MX_DASH_VOD) {\n\t\t\tBool use_cache = (ctx->vodcache == MP4MX_VODCACHE_ON) ? GF_TRUE : GF_FALSE;\n\t\t\tif ((ctx->vodcache == MP4MX_VODCACHE_REPLACE) && (!ctx->media_dur || !ctx->dash_dur.num) ) {\n\t\t\t\tuse_cache = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (ctx->vodcache==MP4MX_VODCACHE_INSERT) {\n\t\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DISABLE_PROGRESSIVE, &PROP_UINT(GF_PID_FILE_PATCH_INSERT) );\n\t\t\t}\n\t\t\telse if (!use_cache) {\n\t\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DISABLE_PROGRESSIVE, &PROP_UINT(GF_PID_FILE_PATCH_REPLACE) );\n\t\t\t}\n\t\t}\n\n\t\tif (gf_sys_old_arch_compat()) {\n\t\t\tp = gf_filter_pid_get_property_str(pid, \"isom_force_ctts\");\n\t\t\tif (p && p->value.boolean) tkw->force_ctts = GF_TRUE;\n\t\t}\n\t} else {\n\n\t\tu32 old_timescale = tkw->src_timescale;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\t\tif (p) tkw->src_timescale = p->value.uint;\n\t\tif (old_timescale && (tkw->src_timescale != old_timescale)) {\n\t\t\tif (tkw->ts_shift)\n\t\t\t\ttkw->ts_shift = gf_timestamp_rescale(tkw->ts_shift, old_timescale, tkw->src_timescale);\n\t\t}\n\t}\n\n\tif (!tkw->has_brands) {\n\t\tBool ignore_alt = GF_FALSE;\n\t\tBool is_isom = GF_FALSE;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_MBRAND);\n\t\tif (p) {\n\t\t\tu32 brand = p->value.uint;\n\t\t\t//remove QT brand\n\t\t\tif ((brand==GF_ISOM_BRAND_QT) && !ctx->make_qt) {\n\t\t\t\tis_isom = GF_TRUE;\n\t\t\t\tctx->major_brand_set = brand = GF_ISOM_BRAND_ISOM;\n\t\t\t\tgf_isom_set_brand_info(ctx->file, brand, 1);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_QT, GF_FALSE);\n\t\t\t\tignore_alt = GF_TRUE;\n\t\t\t}\n\t\t\telse if (!ctx->major_brand_set) {\n\t\t\t\tgf_isom_set_brand_info(ctx->file, brand, 1);\n\t\t\t\tctx->major_brand_set = brand;\n\t\t\t} else {\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, brand, GF_TRUE);\n\t\t\t}\n\t\t\tif (p->value.uint == GF_ISOM_BRAND_ISOM) is_isom = GF_TRUE;\n\t\t}\n\t\tp = ignore_alt ? NULL : gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_BRANDS);\n\t\tif (p && p->value.uint_list.nb_items) {\n\t\t\ttkw->has_brands = GF_TRUE;\n\t\t\tif (!ctx->major_brand_set) {\n\t\t\t\tctx->major_brand_set = p->value.uint_list.vals[0];\n\t\t\t\tgf_isom_set_brand_info(ctx->file, p->value.uint_list.vals[0], 1);\n\t\t\t}\n\t\t\t//reset alt brands, push old ones\n\t\t\tgf_isom_reset_alt_brands_ex(ctx->file, GF_TRUE);\n\t\t\tfor (i=0; i<p->value.uint_list.nb_items; i++) {\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, p->value.uint_list.vals[i], GF_TRUE);\n\t\t\t\tif (p->value.uint_list.vals[i] == GF_ISOM_BRAND_ISOM) is_isom = GF_TRUE;\n\t\t\t}\n\t\t\t//and in case it was not present add major brand\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, ctx->major_brand_set, GF_TRUE);\n\t\t}\n\t\tif (!ctx->m4sys && !is_isom && !ctx->def_brand_patched) {\n\t\t\t//remove default brand\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\t\tctx->def_brand_patched = GF_TRUE;\n\t\t}\n\n\t\tif (ctx->cmaf) {\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, (ctx->cmaf==MP4MX_CMAF_CMF2) ? GF_ISOM_BRAND_CMF2 : GF_ISOM_BRAND_CMFC, GF_TRUE);\n\t\t}\n\t}\n\n\twidth = height = sr = nb_chan = z_order = txt_fsize = 0;\n\tnb_bps = 16;\n\tch_layout = 0;\n\tfps.num = 25;\n\tfps.den = 1;\n\tsar.num = sar.den = 0;\n\tcodec_id = tkw->codecid;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DASH_MULTI_PID);\n\tif (p) {\n\t\tmulti_pid_stsd = p->value.ptr;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DASH_MULTI_PID_IDX);\n\t\tassert(p);\n\t\tmulti_pid_final_stsd_idx = p->value.uint;\n\n\t\t//should never be the case\n\t\ttkw->xps_inband = XPS_IB_NO;\n\t\tctx->dref = GF_FALSE;\n\t\torig_pid = pid;\n\t\tgoto multipid_stsd_setup;\n\t}\n\n\n\t//WARNING !! from this point on until the goto multipid_stsd_setup, use pid and not tkw->ipid\n\t//so that we setup the sample entry properly for each PIDs\nsample_entry_setup:\n\n\tuse_m4sys = ctx->m4sys;\n\tuse_gen_sample_entry = GF_TRUE;\n\tuse_dref = ctx->dref;\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_WIDTH);\n\tif (p) width = p->value.uint;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_HEIGHT);\n\tif (p) height = p->value.uint;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FPS);\n\tif (p) fps = p->value.frac;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_SAR);\n\tif (p) sar = p->value.frac;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ZORDER);\n\tif (p) z_order = p->value.uint;\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_SAMPLE_RATE);\n\tif (p) sr = p->value.uint;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_NUM_CHANNELS);\n\tif (p) nb_chan = p->value.uint;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_AUDIO_BPS);\n\tif (p) nb_bps = p->value.uint;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CHANNEL_LAYOUT);\n\tif (p) ch_layout = p->value.longuint;\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_LANGUAGE);\n\tif (p) lang_name = p->value.string;\n\n\tif (is_true_pid) {\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_NB_FRAMES);\n\t\ttkw->nb_frames = p ? p->value.uint : 0;\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FRAME_OFFSET);\n\t\ttkw->frame_offset = p ? p->value.uint : 0;\n\t}\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_SUBTYPE);\n\tif (p) m_subtype_src = p->value.uint;\n\n\t//if crypto scheme type changes, we will need a new sample entry\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PROTECTION_SCHEME_TYPE);\n\tif (p && (tkw->scheme_type != p->value.uint))\n\t\tneeds_sample_entry = 1;\n\telse if (!p && tkw->scheme_type)\n\t\tneeds_sample_entry = 1;\n\telse if (tkw->scheme_type) {\n\t\tif (codec_id == prev_codecid)\n\t\t\tskip_crypto = GF_TRUE;\n\t}\n\n\t//get our subtype\n\tswitch (codec_id) {\n\tcase GF_CODECID_MPEG_AUDIO:\n\tcase GF_CODECID_MPEG2_PART3:\n\tcase GF_CODECID_MPEG_AUDIO_L1:\n\t\tm_subtype = GF_ISOM_SUBTYPE_MP3;\n\t\tcomp_name = \"MP3\";\n\t\t//if source had a DSI, this was mpeg4 systems signaling, reuse that\n\t\tif (dsi)\n\t\t\tuse_m4sys = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_AAC_MPEG4:\n\tcase GF_CODECID_AAC_MPEG2_MP:\n\tcase GF_CODECID_AAC_MPEG2_LCP:\n\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\t\tm_subtype = GF_ISOM_SUBTYPE_MPEG4;\n\t\tuse_m4sys = GF_TRUE;\n\t\tcomp_name = \"AAC\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\n\t\tif (ctx->importer) {\n\t\t\tconst char *pid_args = gf_filter_pid_get_args(pid);\n\t\t\tif (pid_args) {\n\t\t\t\tBool sbr_i = strstr(pid_args, \"sbr=imp\") ? GF_TRUE : GF_FALSE;\n\t\t\t\tBool sbr_x = strstr(pid_args, \"sbr=exp\") ? GF_TRUE : GF_FALSE;\n\t\t\t\tBool ps_i = strstr(pid_args, \"ps=imp\") ? GF_TRUE : GF_FALSE;\n\t\t\t\tBool ps_x = strstr(pid_args, \"ps=exp\") ? GF_TRUE : GF_FALSE;\n\n\t\t\t\tif (sbr_x) {\n\t\t\t\t\tif (ps_i) imp_name = \"AAC explicit SBR implict PS\";\n\t\t\t\t\telse if (ps_x) imp_name = \"AAC explicit SBR+PS\";\n\t\t\t\t\telse imp_name = \"AAC explicit SBR\";\n\t\t\t\t} else if (sbr_i) {\n\t\t\t\t\tif (ps_i) imp_name = \"AAC implicit SBR+PS\";\n\t\t\t\t\telse if (ps_x) imp_name = \"AAC implicit SBR explicit PS\";\n\t\t\t\t\telse imp_name = \"AAC implicit SBR\";\n\t\t\t\t} else {\n\t\t\t\t\tif (ps_i) imp_name = \"AAC implicit PS\";\n\t\t\t\t\telse if (ps_x) imp_name = \"AAC explicit PS\";\n\t\t\t\t\telse imp_name = \"AAC \";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GF_CODECID_USAC:\n\t\tm_subtype = GF_ISOM_SUBTYPE_MPEG4;\n\t\tuse_m4sys = GF_TRUE;\n\t\tcomp_name = \"xHE-AAC / USAC\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tbreak;\n\tcase GF_CODECID_JPEG:\n\t\tm_subtype = GF_ISOM_BOX_TYPE_JPEG;\n\t\tcomp_name = \"JPEG\";\n\t\t//use generic sample desc, but don't inject dsi\n\t\tif (!use_m4sys)\n\t\t\tdsi = NULL;\n\t\tbreak;\n\tcase GF_CODECID_PNG:\n\t\tm_subtype = GF_ISOM_BOX_TYPE_PNG;\n\t\tcomp_name = \"PNG\";\n\t\t//use generic sample desc, but don't inject dsi\n\t\tdsi = NULL;\n\t\tbreak;\n\tcase GF_CODECID_J2K:\n\t\tm_subtype = GF_ISOM_BOX_TYPE_MJP2;\n\t\tcomp_name = \"JPEG2000\";\n\t\tuse_mj2 = GF_TRUE;\n\t\tbreak;\n\n\tcase GF_CODECID_AMR:\n\t\tm_subtype = GF_ISOM_SUBTYPE_3GP_AMR;\n\t\tcomp_name = \"AMR\";\n\t\tuse_3gpp_config = GF_TRUE;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_AMR_MODE_SET);\n\t\tif (p && (p->value.uint!=tkw->amr_mode_set)) {\n\t\t\ttkw->amr_mode_set = p->value.uint;\n\t\t\tif (!needs_sample_entry)\n\t\t\t\tneeds_sample_entry = 2;\n\t\t}\n\t\tbreak;\n\tcase GF_CODECID_AMR_WB:\n\t\tm_subtype = GF_ISOM_SUBTYPE_3GP_AMR_WB;\n\t\tcomp_name = \"AMR-WB\";\n\t\tuse_3gpp_config = GF_TRUE;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_AMR_MODE_SET);\n\t\tif (p && (p->value.uint!=tkw->amr_mode_set)) {\n\t\t\ttkw->amr_mode_set = p->value.uint;\n\t\t\tif (!needs_sample_entry)\n\t\t\t\tneeds_sample_entry = 2;\n\t\t}\n\t\tbreak;\n\tcase GF_CODECID_EVRC:\n\t\tm_subtype = GF_ISOM_SUBTYPE_3GP_EVRC;\n\t\tcomp_name = \"EVRC\";\n\t\tuse_3gpp_config = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_SMV:\n\t\tm_subtype = GF_ISOM_SUBTYPE_3GP_SMV;\n\t\tcomp_name = \"SMV\";\n\t\tuse_3gpp_config = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_QCELP:\n\t\tm_subtype = GF_ISOM_SUBTYPE_3GP_QCELP;\n\t\tcomp_name = \"QCELP\";\n\t\tuse_3gpp_config = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_S263:\n\tcase GF_CODECID_H263:\n\t\tm_subtype = GF_ISOM_SUBTYPE_3GP_H263;\n\t\tcomp_name = \"H263\";\n\t\tuse_3gpp_config = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_AC3:\n\t\tm_subtype = GF_ISOM_SUBTYPE_AC3;\n\t\tcomp_name = \"AC-3\";\n\t\tuse_ac3_entry = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_EAC3:\n\t\tm_subtype = GF_ISOM_SUBTYPE_EC3;\n\t\tcomp_name = \"EAC-3\";\n\t\tuse_ac3_entry = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_MPHA:\n\t\tif ((m_subtype_src!=GF_ISOM_SUBTYPE_MH3D_MHA1) && (m_subtype_src!=GF_ISOM_SUBTYPE_MH3D_MHA2))\n\t\t\tm_subtype = GF_ISOM_SUBTYPE_MH3D_MHA1;\n\t\telse\n\t\t\tm_subtype = m_subtype_src;\n\t\tcomp_name = \"MPEG-H Audio\";\n\t\tnb_chan = 0;\n\t\tbreak;\n\tcase GF_CODECID_MHAS:\n\t\tif ((m_subtype_src!=GF_ISOM_SUBTYPE_MH3D_MHM1) && (m_subtype_src!=GF_ISOM_SUBTYPE_MH3D_MHM2))\n\t\t\tm_subtype = GF_ISOM_SUBTYPE_MH3D_MHM1;\n\t\telse\n\t\t\tm_subtype = m_subtype_src;\n\t\tcomp_name = \"MPEG-H AudioMux\";\n\t\tnb_chan = 0;\n\t\tbreak;\n\tcase GF_CODECID_FLAC:\n\t\tm_subtype = GF_ISOM_SUBTYPE_FLAC;\n\t\tcomp_name = \"FLAC\";\n\t\tuse_flac_entry = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_OPUS:\n\t\tm_subtype = GF_ISOM_SUBTYPE_OPUS;\n\t\tcomp_name = \"Opus\";\n\t\tuse_opus = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_MPEG4_PART2:\n\t\tm_subtype = GF_ISOM_SUBTYPE_MPEG4;\n\t\tuse_m4sys = GF_TRUE;\n\t\tcomp_name = \"MPEG-4 Visual Part 2\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tbreak;\n\tcase GF_CODECID_AVC:\n\tcase GF_CODECID_SVC:\n\t\tif (ctx->xps_inband==XPS_IB_AUTO) {\n\t\t\tswitch (m_subtype_src) {\n\t\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_DVAV:\n\t\t\t\tm_subtype = m_subtype_src;\n\t\t\t\txps_inband = XPS_IB_ALL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tm_subtype = GF_ISOM_SUBTYPE_AVC_H264;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\txps_inband = ctx->xps_inband;\n\t\t\tm_subtype = ((xps_inband==XPS_IB_ALL) || (xps_inband==XPS_IB_BOTH)) ? GF_ISOM_SUBTYPE_AVC3_H264 : GF_ISOM_SUBTYPE_AVC_H264;\n\t\t}\n\t\tuse_avc = GF_TRUE;\n\t\tcomp_name = (codec_id == GF_CODECID_SVC) ? \"MPEG-4 SVC\" : \"MPEG-4 AVC\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tif (m_subtype != GF_ISOM_SUBTYPE_AVC_H264) {\n\t\t\tuse_m4sys = GF_FALSE;\n\t\t\tif (xps_inband==XPS_IB_ALL) skip_dsi = GF_TRUE;\n\t\t}\n\t\tbreak;\n\tcase GF_CODECID_HEVC:\n\tcase GF_CODECID_LHVC:\n\t\tif (ctx->xps_inband==XPS_IB_AUTO) {\n\t\t\tswitch (m_subtype_src) {\n\t\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\t\tcase GF_ISOM_SUBTYPE_DVHE:\n\t\t\t\tm_subtype = m_subtype_src;\n\t\t\t\txps_inband = XPS_IB_ALL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tm_subtype = GF_ISOM_SUBTYPE_HVC1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\txps_inband = ctx->xps_inband;\n\t\t\tm_subtype = ((xps_inband==XPS_IB_ALL) || (xps_inband==XPS_IB_BOTH)) ? GF_ISOM_SUBTYPE_HEV1  : GF_ISOM_SUBTYPE_HVC1;\n\t\t}\n\t\tuse_hevc = GF_TRUE;\n\t\tcomp_name = (codec_id == GF_CODECID_LHVC) ? \"L-HEVC\" : \"HEVC\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tif (m_subtype != GF_ISOM_SUBTYPE_HVC1) {\n\t\t\tuse_m4sys = GF_FALSE;\n\t\t\tif (xps_inband==XPS_IB_ALL) skip_dsi = GF_TRUE;\n\t\t}\n\t\tbreak;\n\tcase GF_CODECID_HEVC_TILES:\n\t\tm_subtype = GF_ISOM_SUBTYPE_HVT1;\n\t\tskip_dsi = GF_TRUE;\n\t\tuse_hvt1 = GF_TRUE;\n\t\tuse_m4sys = GF_FALSE;\n\t\tcomp_name = \"HEVC Tiles\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tbreak;\n\tcase GF_CODECID_VVC:\n\t\tif (ctx->xps_inband==XPS_IB_AUTO) {\n\t\t\tif (m_subtype_src == GF_ISOM_SUBTYPE_VVI1) {\n\t\t\t\tm_subtype = GF_ISOM_SUBTYPE_VVI1;\n\t\t\t\txps_inband = XPS_IB_ALL;\n\t\t\t} else {\n\t\t\t\tm_subtype = GF_ISOM_SUBTYPE_VVC1;\n\t\t\t}\n\t\t} else {\n\t\t\txps_inband = ctx->xps_inband;\n\t\t\tm_subtype = ((xps_inband==XPS_IB_PPS) || (xps_inband==XPS_IB_ALL) || (xps_inband==XPS_IB_BOTH)) ? GF_ISOM_SUBTYPE_VVI1  : GF_ISOM_SUBTYPE_VVC1;\n\t\t}\n\t\tuse_vvc = GF_TRUE;\n\t\tcomp_name = \"VVC\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tif (xps_inband==XPS_IB_ALL) skip_dsi = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_VVC_SUBPIC:\n\t\tm_subtype = GF_ISOM_SUBTYPE_VVS1;\n\t\tskip_dsi = GF_TRUE;\n\t\tuse_vvc = GF_TRUE;\n\t\tuse_m4sys = GF_FALSE;\n\t\tcomp_name = \"VVC Subpicture\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tbreak;\n\tcase GF_CODECID_MPEG1:\n\tcase GF_CODECID_MPEG2_422:\n\tcase GF_CODECID_MPEG2_SNR:\n\tcase GF_CODECID_MPEG2_HIGH:\n\tcase GF_CODECID_MPEG2_MAIN:\n\tcase GF_CODECID_MPEG2_SIMPLE:\n\tcase GF_CODECID_MPEG2_SPATIAL:\n\t\tm_subtype = GF_ISOM_SUBTYPE_MPEG4;\n\t\tuse_m4sys = GF_TRUE;\n\t\tcomp_name = \"MPEG-2 Video\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tbreak;\n\tcase 0:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] muxing codecID %d not yet implemented - patch welcome\\n\", codec_id));\n\t\treturn GF_NOT_SUPPORTED;\n\n\tcase GF_ISOM_SUBTYPE_TX3G:\n\t\tm_subtype = GF_ISOM_SUBTYPE_TX3G;\n\t\tuse_tx3g = GF_TRUE;\n\t\tcomp_name = \"Timed Text\";\n\t\tis_text_subs = GF_TRUE;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_WVTT:\n\t\tm_subtype = GF_ISOM_SUBTYPE_WVTT;\n\t\tuse_webvtt = GF_TRUE;\n\t\tcomp_name = \"WebVTT\";\n\t\tis_text_subs = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_DVB_SUBS:\n\t\tuse_gen_sample_entry = GF_TRUE;\n\t\tcomp_name = \"DVB Subtitles\";\n\t\tm_subtype = GF_ISOM_SUBTYPE_DVB_SUBS;\n\t\tgen_dsi_wrap = GF_4CC('d', 'v', 's', 'C');\n\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_MEDIA_SUBT);\n\t\tif (!width && !height) {\n\t\t\tmp4_mux_get_video_size(ctx, &width, &height);\n\t\t}\n\t\tbreak;\n\tcase GF_CODECID_DVB_TELETEXT:\n\t\tuse_gen_sample_entry = GF_TRUE;\n\t\tcomp_name = \"DVB Subtitles\";\n\t\tm_subtype = GF_ISOM_SUBTYPE_DVB_TELETEXT;\n\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_MEDIA_SUBT);\n\t\tif (!width && !height) {\n\t\t\tmp4_mux_get_video_size(ctx, &width, &height);\n\t\t}\n\t\tbreak;\n\n\tcase GF_CODECID_SUBPIC:\n\t\tuse_m4sys = GF_TRUE;\n\t\toverride_stype = GF_STREAM_ND_SUBPIC;\n\t\tcomp_name = \"VobSub\";\n\t\tbreak;\n\tcase GF_CODECID_TEXT_MPEG4:\n\t\tuse_m4sys = GF_TRUE;\n\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_MEDIA_SCENE);\n\t\tcomp_name = \"MPEG4 Streaming Text\";\n\t\tbreak;\n\tcase GF_CODECID_AV1:\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tm_subtype = GF_ISOM_SUBTYPE_AV01;\n\t\tuse_av1 = GF_TRUE;\n\t\tcomp_name = \"AOM AV1 Video\";\n\t\tbreak;\n\n\tcase GF_CODECID_VP8:\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tm_subtype = GF_ISOM_SUBTYPE_VP08;\n\t\tuse_vpX = GF_TRUE;\n\t\tcomp_name = \"VP8 Video\";\n\t\tbreak;\n\tcase GF_CODECID_VP9:\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tm_subtype = GF_ISOM_SUBTYPE_VP09;\n\t\tuse_vpX = GF_TRUE;\n\t\tcomp_name = \"VP9 Video\";\n\t\tbreak;\n\tcase GF_CODECID_VP10:\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tm_subtype = GF_ISOM_SUBTYPE_VP10;\n\t\tuse_vpX = GF_TRUE;\n\t\tcomp_name = \"VP10 Video\";\n\t\tbreak;\n\n\tcase GF_CODECID_VORBIS:\n\tcase GF_CODECID_THEORA:\n\t\tuse_m4sys = GF_TRUE;\n\t\tbreak;\n\n\tcase GF_CODECID_TRUEHD:\n\t\tm_subtype = GF_ISOM_SUBTYPE_MLPA;\n\t\tcomp_name = \"Dolby TrueHD\";\n\t\tbreak;\n\n\tcase GF_CODECID_DTS_CA:\n\t\tm_subtype = GF_ISOM_SUBTYPE_DTSC;\n\t\tbreak;\n\tcase GF_CODECID_DTS_HD_HR_MASTER:\n\t\tm_subtype = GF_ISOM_SUBTYPE_DTSH;\n\t\tbreak;\n\tcase GF_CODECID_DTS_HD_LOSSLESS:\n\t\tm_subtype = GF_ISOM_SUBTYPE_DTSL;\n\t\tbreak;\n\tcase GF_CODECID_DTS_EXPRESS_LBR:\n\t\tm_subtype = GF_ISOM_SUBTYPE_DTSE;\n\t\tbreak;\n\tcase GF_CODECID_DTS_X:\n\t\tm_subtype = GF_ISOM_SUBTYPE_DTSX;\n\t\tbreak;\n\tcase GF_CODECID_DTS_Y:\n\t\tm_subtype = GF_ISOM_SUBTYPE_DTSY;\n\t\tbreak;\n\tcase GF_CODECID_ALAC:\n\t\tm_subtype = GF_QT_SUBTYPE_ALAC;\n\t\tbreak;\n\n\tcase GF_CODECID_BIFS:\n/* ==  GF_CODECID_OD_V1:*/\n\tcase GF_CODECID_BIFS_V2:\n/*\t== GF_CODECID_OD_V2:*/\n\tcase GF_CODECID_BIFS_EXTENDED:\n\tcase GF_CODECID_LASER:\n\t\tuse_m4sys = GF_TRUE;\n\t\tbreak;\n\n\tcase GF_CODECID_RAW:\n\t\tm_subtype = codec_id;\n\t\tunknown_generic = GF_TRUE;\n\t\tuse_gen_sample_entry = GF_TRUE;\n\t\tuse_m4sys = GF_FALSE;\n\t\ttkw->skip_bitrate_update = GF_TRUE;\n\t\tif (tkw->stream_type == GF_STREAM_AUDIO) {\n\t\t\tu32 afmt;\n\t\t\tu32 req_non_planar_type = 0;\n\t\t\tBool qt_only=GF_FALSE;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_AUDIO_FORMAT);\n\t\t\tif (!p) break;\n\t\t\tcomp_name = \"RawAudio\";\n\t\t\tunknown_generic = GF_FALSE;\n\n\t\t\tafmt = p->value.uint;\n\t\t\tafmt_flags |= 1<<2; //signed\n\t\t\t//m_subtype used for QTFF-style raw media, m_subtype_alt_raw for ISOBMFF raw audio\n\t\t\tswitch (afmt) {\n\t\t\tcase GF_AUDIO_FMT_U8P:\n\t\t\t \treq_non_planar_type = GF_AUDIO_FMT_U8;\n\t\t\tcase GF_AUDIO_FMT_U8:\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_RAW;\n\t\t\t\tafmt_flags &= ~(1<<2); //unsigned\n\t\t\t\tqt_only = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_S16P:\n\t\t\t \treq_non_planar_type = GF_AUDIO_FMT_S16;\n\t\t\tcase GF_AUDIO_FMT_S16:\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_SOWT;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_IPCM;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_S16_BE:\n\t\t\t\tafmt_flags |= 1<<1;\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_TWOS;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_IPCM;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_S24P:\n\t\t\t \treq_non_planar_type = GF_AUDIO_FMT_S24;\n\t\t\tcase GF_AUDIO_FMT_S24:\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_IN24;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_IPCM;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_S24_BE:\n\t\t\t\tafmt_flags |= 1<<1;\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_IN24;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_IPCM;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_S32P:\n\t\t\t \treq_non_planar_type = GF_AUDIO_FMT_S32P;\n\t\t\tcase GF_AUDIO_FMT_S32:\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_IN32;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_IPCM;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_S32_BE:\n\t\t\t\tafmt_flags |= 1<<1;\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_IN32;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_IPCM;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_FLTP:\n\t\t\t \treq_non_planar_type = GF_AUDIO_FMT_FLTP;\n\t\t\tcase GF_AUDIO_FMT_FLT:\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_FL32;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_FPCM;\n\t\t\t\tafmt_flags |= 1;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_FLT_BE:\n\t\t\t\tafmt_flags |= 1<<1;\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_FL32;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_FPCM;\n\t\t\t\tafmt_flags |= 1;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_DBLP:\n\t\t\t \treq_non_planar_type = GF_AUDIO_FMT_DBL;\n\t\t\tcase GF_AUDIO_FMT_DBL:\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_FL64;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_FPCM;\n\t\t\t\tafmt_flags |= 1;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_DBL_BE:\n\t\t\t\tafmt_flags |= 1<<1;\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_FL64;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_FPCM;\n\t\t\t\tafmt_flags |= 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tunknown_generic = GF_TRUE;\n\t\t\t\tm_subtype = p->value.uint;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ctx->make_qt && (ase_mode==GF_IMPORT_AUDIO_SAMPLE_ENTRY_v2_QTFF)) {\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_LPCM;\n\t\t\t}\n\t\t\t//if qt-only sample desc available, force ase mode\n\t\t\telse if (!ctx->make_qt && qt_only) {\n\t\t\t\tase_mode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF;\n\t\t\t}\n\n\t\t\tif (req_non_planar_type) {\n\t\t\t\tif (is_true_pid)\n\t\t\t\t\tgf_filter_pid_negociate_property(pid, GF_PROP_PID_AUDIO_FORMAT, &PROP_UINT(GF_AUDIO_FMT_S16));\n\t\t\t\telse {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] raw audio format planar in DASH multi-stsd mode is not supported, try assigning a resampler before the dasher\\n\"));\n\t\t\t\t\treturn GF_NOT_SUPPORTED;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnb_bps = gf_audio_fmt_bit_depth(afmt);\n\t\t\ttkw->raw_audio_bytes_per_sample = nb_bps;\n\t\t\ttkw->raw_audio_bytes_per_sample *= nb_chan;\n\t\t\ttkw->raw_audio_bytes_per_sample /= 8;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_SAMPLE_RATE);\n\t\t\ttkw->raw_samplerate = p ? p->value.uint : 0;\n\t\t\t//force timescale to be samplerate, except if explicit overwrite\n\t\t\tif (ctx->mediats==0)\n\t\t\t\ttkw->tk_timescale = tkw->raw_samplerate;\n\n\t\t\tif ((sr == tkw->w_or_sr) && (nb_chan==tkw->h_or_ch) && (afmt==tkw->pf_or_af)) {\n\n\t\t\t} else {\n\t\t\t\tif (!needs_sample_entry)\n\t\t\t\t\tneeds_sample_entry = 2;\n\t\t\t\ttkw->w_or_sr = sr;\n\t\t\t\ttkw->h_or_ch = nb_chan;\n\t\t\t\ttkw->pf_or_af = afmt;\n\t\t\t}\n\t\t}\n\t\telse if (tkw->stream_type == GF_STREAM_VISUAL) {\n\t\t\tu32 pfmt;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PIXFMT);\n\t\t\tif (!p) break;\n\t\t\tpfmt = p->value.uint;\n\t\t\tcomp_name = \"RawVideo\";\n\t\t\tunknown_generic = GF_FALSE;\n\t\t\ttkw->skip_bitrate_update = GF_TRUE;\n\t\t\tpix_fmt = p->value.uint;\n\n\t\t\tm_subtype = gf_pixel_fmt_to_qt_type(pix_fmt);\n\t\t\tif (m_subtype) {\n\t\t\t\tif (gf_pixel_fmt_is_yuv(p->value.uint))\n\t\t\t\t\tforce_colr = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tunknown_generic = GF_TRUE;\n\t\t\t\tm_subtype = pix_fmt;\n\t\t\t}\n\n\t\t\tif ((width == tkw->w_or_sr) && (height==tkw->h_or_ch) && (pfmt==tkw->pf_or_af)) {\n\n\t\t\t} else {\n\t\t\t\tif (!needs_sample_entry)\n\t\t\t\t\tneeds_sample_entry = 2;\n\t\t\t\ttkw->w_or_sr = width;\n\t\t\t\ttkw->h_or_ch = height;\n\t\t\t\ttkw->pf_or_af = pfmt;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase GF_CODECID_RAW_UNCV:\n\t\tm_subtype = GF_ISOM_SUBTYPE_UNCV;\n\t\tunknown_generic = GF_FALSE;\n\t\tuse_gen_sample_entry = GF_TRUE;\n\t\tuse_m4sys = GF_FALSE;\n\t\tbreak;\n\n\tdefault:\n\t\tm_subtype = codec_id;\n\t\tunknown_generic = GF_TRUE;\n\t\tuse_gen_sample_entry = GF_TRUE;\n\t\tuse_m4sys = GF_FALSE;\n\t\tif (is_prores)\n\t\t\tunknown_generic = GF_FALSE;\n\n\t\tp = gf_filter_pid_get_property_str(pid, \"meta:mime\");\n\t\tif (p) meta_mime = p->value.string;\n\t\tp = gf_filter_pid_get_property_str(pid, \"meta:encoding\");\n\t\tif (p) meta_encoding = p->value.string;\n\t\tp = gf_filter_pid_get_property_str(pid, \"meta:content_encoding\");\n\t\tif (p) meta_content_encoding = p->value.string;\n\t\tp = gf_filter_pid_get_property_str(pid, \"meta:xmlns\");\n\t\tif (p) meta_xmlns = p->value.string;\n\t\tp = gf_filter_pid_get_property_str(pid, \"meta:schemaloc\");\n\t\tif (p) meta_schemaloc = p->value.string;\n\t\tp = gf_filter_pid_get_property_str(pid, \"meta:aux_mimes\");\n\t\tif (p) meta_auxmimes = p->value.string;\n\t\tbreak;\n\t}\n\tif (!comp_name) comp_name = gf_codecid_name(codec_id);\n\tif (!comp_name) comp_name = gf_4cc_to_str(m_subtype);\n\n\tif (dsi)\n\t\tmeta_config = dsi->value.data.ptr;\n\n\tif (is_text_subs && !width && !height) {\n\t\tmp4_mux_get_video_size(ctx, &width, &height);\n\t}\n\n\t//if not LPCM and qt v2 is requested, move to qtv1\n\tif ((ase_mode==GF_IMPORT_AUDIO_SAMPLE_ENTRY_v2_QTFF) && (m_subtype != GF_QT_SUBTYPE_LPCM) ) {\n\t\tase_mode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF;\n\t}\n\n\n\tif (!ctx->init_movie_done && !tkw->nb_samples && (ctx->mediats<0) && (tkw->tk_timescale==1000)) {\n\t\tif (sr) {\n\t\t\ttkw->tk_timescale = sr;\n\t\t\tgf_isom_set_media_timescale(ctx->file, tkw->track_num, sr, 0, 1);\n\t\t}\n\t\telse if (width && fps.den) {\n\t\t\ttkw->tk_timescale = fps.den;\n\t\t\tgf_isom_set_media_timescale(ctx->file, tkw->track_num, fps.den, 0, 1);\n\t\t}\n\t}\n\tif (!needs_sample_entry || tkw->is_item) {\n\t\tgoto sample_entry_done;\n\t}\n\n\t//we are fragmented, init movie done, we cannot update the sample description\n\tif (ctx->init_movie_done) {\n\t\tif (needs_sample_entry==1) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot create a new sample description entry (codec change) for finalized movie in fragmented mode\\n\"));\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t\tforce_mix_xps = GF_TRUE;\n\t} else if (ctx->store < MP4MX_MODE_FRAG) {\n\t\tif ((needs_sample_entry==2) && (xps_inband==XPS_IB_BOTH)) {\n\t\t\tforce_mix_xps = GF_TRUE;\n\t\t}\n\t\telse if ((needs_sample_entry==2) && ((xps_inband==XPS_IB_ALL) || (xps_inband==XPS_IB_MIX)) ) {\n\t\t\tneeds_sample_entry = 0;\n\t\t\tmake_inband_headers = GF_TRUE;\n\t\t}\n\t}\n\n\tif (force_mix_xps) {\n\t\tif (tkw->all_stsd_crc) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_STSD_ALL_TEMPLATES);\n\t\t\tu32 crc = p ? gf_crc_32(p->value.data.ptr, p->value.data.size) : 0;\n\t\t\tif (crc == tkw->all_stsd_crc) {\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_STSD_TEMPLATE_IDX);\n\t\t\t\tif (p) {\n\t\t\t\t\ttkw->stsd_idx = p->value.uint;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//for AVC and HEVC, move to inband params if config changed\n\t\tif (use_avc && dsi) {\n\t\t\tif (tkw->avcc) gf_odf_avc_cfg_del(tkw->avcc);\n\n\t\t\ttkw->avcc = gf_odf_avc_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\n\t\t\tif (enh_dsi) {\n\t\t\t\tif (tkw->svcc) gf_odf_avc_cfg_del(tkw->svcc);\n\t\t\t\ttkw->svcc = gf_odf_avc_cfg_read(enh_dsi->value.data.ptr, enh_dsi->value.data.size);\n\t\t\t}\n\t\t\tif (!xps_inband) {\n\t\t\t\tif (ctx->init_movie_done) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] AVC config update after movie has been finalized, moving all SPS/PPS inband (file might not be compliant)\\n\"));\n\t\t\t\t}\n\t\t\t\ttkw->xps_inband = XPS_IB_BOTH;\n\t\t\t}\n\t\t\tmp4_mux_make_inband_header(ctx, tkw, GF_FALSE);\n\t\t\tif (ctx->pps_inband || tkw->xps_inband)\n\t\t\t\tmp4_mux_make_inband_header(ctx, tkw, GF_TRUE);\n\t\t\treturn GF_OK;\n\t\t}\n\t\telse if (use_hevc && dsi) {\n\t\t\tif (tkw->hvcc) gf_odf_hevc_cfg_del(tkw->hvcc);\n\t\t\ttkw->hvcc = gf_odf_hevc_cfg_read(dsi->value.data.ptr, dsi->value.data.size,  (codec_id == GF_CODECID_LHVC) ? GF_TRUE : GF_FALSE);\n\n\t\t\tif (enh_dsi) {\n\t\t\t\tif (tkw->lvcc) gf_odf_hevc_cfg_del(tkw->lvcc);\n\t\t\t\ttkw->lvcc = gf_odf_hevc_cfg_read(enh_dsi->value.data.ptr, enh_dsi->value.data.size, GF_TRUE);\n\t\t\t}\n\t\t\tif (!xps_inband) {\n\t\t\t\tif (ctx->init_movie_done) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] HEVC config update after movie has been finalized, moving all SPS/PPS inband (file might not be compliant)\\n\"));\n\t\t\t\t}\n\t\t\t\ttkw->xps_inband = XPS_IB_BOTH;\n\t\t\t}\n\t\t\tmp4_mux_make_inband_header(ctx, tkw, GF_FALSE);\n\t\t\tif (ctx->pps_inband || tkw->xps_inband)\n\t\t\t\tmp4_mux_make_inband_header(ctx, tkw, GF_TRUE);\n\t\t\treturn GF_OK;\n\t\t}\n\t\telse if (use_vvc && dsi) {\n\t\t\tif (tkw->vvcc) gf_odf_vvc_cfg_del(tkw->vvcc);\n\t\t\ttkw->vvcc = gf_odf_vvc_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\n\t\t\tif (!xps_inband) {\n\t\t\t\tif (ctx->init_movie_done) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] VVC config update after movie has been finalized, moving all SPS/PPS inband (file might not be compliant)\\n\"));\n\t\t\t\t}\n\t\t\t\ttkw->xps_inband = XPS_IB_BOTH;\n\t\t\t}\n\t\t\tmp4_mux_make_inband_header(ctx, tkw, GF_FALSE);\n\t\t\tif (ctx->pps_inband || tkw->xps_inband)\n\t\t\t\tmp4_mux_make_inband_header(ctx, tkw, GF_TRUE);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot create a new sample description entry (config changed) for finalized movie in fragmented mode\\n\"));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\ttkw->xps_inband = xps_inband;\n\tp = needs_sample_entry ? gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DSI_SUPERSET) : NULL;\n\n\t//if dsi is a superset of previous one, remove stream description\n\tif ((p && p->value.boolean)\n\t\t//little optim here: if no samples were added on the stream description remove it\n\t\t|| (!tkw->samples_in_stsd && tkw->stsd_idx && needs_sample_entry)\n\t) {\n\t\tgf_isom_remove_stream_description(ctx->file, tkw->track_num, tkw->stsd_idx);\n\t}\n\n\tif (!use_dref) src_url = NULL;\n\n\tif (use_m4sys && !gf_codecid_oti(codec_id)) {\n\t\tuse_m4sys = GF_FALSE;\n\t}\n\t//nope, create sample entry\n\tif (use_m4sys) {\n\t\tGF_ESD *esd = gf_odf_desc_esd_new(2);\n\t\tesd->decoderConfig->streamType = override_stype ? override_stype : tkw->stream_type;\n\t\tesd->decoderConfig->objectTypeIndication = gf_codecid_oti(codec_id);\n\t\tif (!esd->decoderConfig->objectTypeIndication) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Codec %s does not have an official MPEG-4 systems mapping, cannot mux\\n\", gf_codecid_name(codec_id) ));\n\t\t\treturn GF_NOT_SUPPORTED;\n\n\t\t}\n\t\tesd->slConfig->timestampResolution = tkw->tk_timescale;\n\t\tif (dsi && !skip_dsi) {\n\t\t\tesd->decoderConfig->decoderSpecificInfo->data = dsi->value.data.ptr;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->dataLength = dsi->value.data.size;\n\t\t}\n\n\t\te = gf_isom_new_mpeg4_description(ctx->file, tkw->track_num, esd, (char *)src_url, NULL, &tkw->stsd_idx);\n\t\tif (dsi && !skip_dsi) {\n\t\t\tesd->decoderConfig->decoderSpecificInfo->data = NULL;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->dataLength = 0;\n\t\t}\n\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new MPEG-4 Systems sample description for stream type %d OTI %d: %s\\n\", tkw->stream_type, codec_id, gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\n\t\ttkw->use_dref = src_url ? GF_TRUE : GF_FALSE;\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_IN_IOD);\n\t\tif (p && p->value.boolean)\n\t\t\tgf_isom_add_track_to_root_od(ctx->file, tkw->track_num);\n\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tif (dsi && (tkw->stream_type==GF_STREAM_AUDIO)) {\n\t\t\tGF_M4ADecSpecInfo acfg;\n\t\t\tgf_m4a_get_config(dsi->value.data.ptr, dsi->value.data.size, &acfg);\n\t\t\taudio_pli = acfg.audioPL;\n\t\t}\n\t\t//patch to align old arch (IOD not written in dash) with new\n\t\tif (audio_pli && !ctx->dash_mode)\n\t\t\tgf_isom_set_pl_indication(ctx->file, GF_ISOM_PL_AUDIO, audio_pli);\n#endif\n\n\t} else if (use_avc) {\n\t\t//not yet known\n\t\tif (!dsi && !enh_dsi) return GF_OK;\n\n\t\tif (!dsi) {\n\t\t\tdsi = enh_dsi;\n\t\t\tenh_dsi = NULL;\n\t\t}\n\t\tif (tkw->avcc) gf_odf_avc_cfg_del(tkw->avcc);\n\t\ttkw->avcc = gf_odf_avc_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\n\t\tif (needs_sample_entry) {\n\t\t\tif (tkw->codecid == GF_CODECID_SVC) {\n\t\t\t\te = gf_isom_svc_config_new(ctx->file, tkw->track_num, tkw->avcc, NULL, NULL, &tkw->stsd_idx);\n\t\t\t} else if (tkw->codecid == GF_CODECID_MVC) {\n\t\t\t\te = gf_isom_mvc_config_new(ctx->file, tkw->track_num, tkw->avcc, NULL, NULL, &tkw->stsd_idx);\n\t\t\t} else {\n\t\t\t\te = gf_isom_avc_config_new(ctx->file, tkw->track_num, tkw->avcc, NULL, NULL, &tkw->stsd_idx);\n\t\t\t}\n\n\t\t\tif (!e && enh_dsi) {\n\t\t\t\tif (tkw->svcc) gf_odf_avc_cfg_del(tkw->svcc);\n\t\t\t\ttkw->svcc = gf_odf_avc_cfg_read(enh_dsi->value.data.ptr, enh_dsi->value.data.size);\n\t\t\t\tif (tkw->svcc) {\n\t\t\t\t\tif ((tkw->svcc->AVCProfileIndication==118) || (tkw->svcc->AVCProfileIndication==128)) {\n\t\t\t\t\t\te = gf_isom_mvc_config_update(ctx->file, tkw->track_num, tkw->stsd_idx, tkw->svcc, GF_TRUE);\n\t\t\t\t\t} else {\n\t\t\t\t\t\te = gf_isom_svc_config_update(ctx->file, tkw->track_num, tkw->stsd_idx, tkw->svcc, GF_TRUE);\n\t\t\t\t\t}\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tgf_odf_avc_cfg_del(tkw->svcc);\n\t\t\t\t\t\ttkw->svcc = NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (xps_inband) {\n\t\t\t\t\t\tgf_isom_avc_set_inband_config(ctx->file, tkw->track_num, tkw->stsd_idx, (xps_inband==XPS_IB_BOTH) ? GF_TRUE : GF_FALSE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new AVC sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (xps_inband) {\n\t\t\t//this will cleanup all PS in avcC / svcC\n\t\t\tgf_isom_avc_set_inband_config(ctx->file, tkw->track_num, tkw->stsd_idx, (xps_inband==XPS_IB_BOTH) ? GF_TRUE : GF_FALSE);\n\t\t\tif (xps_inband==XPS_IB_BOTH) make_inband_headers = GF_TRUE;\n\t\t} else {\n\t\t\tgf_odf_avc_cfg_del(tkw->avcc);\n\t\t\ttkw->avcc = NULL;\n\t\t}\n\t\t//patch to align old arch with filters\n\t\tif (!ctx->dash_mode && !ctx->make_qt && !gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_TREX_TEMPLATE) )\n\t\t\tgf_isom_set_pl_indication(ctx->file, GF_ISOM_PL_VISUAL, 0x7F);\n\n\t\tif (!tkw->has_brands)\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_AVC1, GF_TRUE);\n\n\t\ttkw->is_nalu = NALU_AVC;\n\n\t\ttkw->use_dref = GF_FALSE;\n\n\t} else if (use_hvt1) {\n\t\tif (tkw->hvcc) gf_odf_hevc_cfg_del(tkw->hvcc);\n\t\ttkw->hvcc = gf_odf_hevc_cfg_new();\n\t\te = gf_isom_hevc_config_new(ctx->file, tkw->track_num, tkw->hvcc, NULL, NULL, &tkw->stsd_idx);\n\t\tif (!e) {\n\t\t\tgf_isom_hevc_set_tile_config(ctx->file, tkw->track_num, tkw->stsd_idx, NULL, GF_FALSE);\n\t\t}\n\t\tgf_odf_hevc_cfg_del(tkw->hvcc);\n\t\ttkw->hvcc = NULL;\n\t\ttkw->is_nalu = NALU_HEVC;\n\t\ttkw->use_dref = GF_FALSE;\n\t\tif (!tkw->has_brands)\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_HVTI, GF_TRUE);\n\t} else if (use_hevc) {\n\t\tif (tkw->hvcc) gf_odf_hevc_cfg_del(tkw->hvcc);\n\n\t\tif (!dsi && !enh_dsi) {\n\t\t\t//not yet known\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (dsi) {\n\t\t\ttkw->hvcc = gf_odf_hevc_cfg_read(dsi->value.data.ptr, dsi->value.data.size,  (codec_id == GF_CODECID_LHVC) ? GF_TRUE : GF_FALSE);\n\t\t} else {\n\t\t\ttkw->hvcc = gf_odf_hevc_cfg_new();\n\t\t}\n\t\ttkw->is_nalu = NALU_HEVC;\n\n\t\tif (needs_sample_entry) {\n\t\t\te = gf_isom_hevc_config_new(ctx->file, tkw->track_num, tkw->hvcc, NULL, NULL, &tkw->stsd_idx);\n\n\t\t\tif (!tkw->has_brands) {\n\t\t\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_ISO4, 1);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\t\t}\n\t\t\t//patch for old arch\n\t\t\telse if (ctx->dash_mode) {\n\t\t\t\tBool force_brand=GF_FALSE;\n\t\t\t\tif (((ctx->major_brand_set>>24)=='i') && (((ctx->major_brand_set>>16)&0xFF)=='s') && (((ctx->major_brand_set>>8)&0xFF)=='o')) {\n\t\t\t\t\tif ( (ctx->major_brand_set&0xFF) <'6') force_brand=GF_TRUE;\n\t\t\t\t}\n\n\t\t\t\tif (!force_brand && ctx->major_brand_set) {\n\t\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO6, GF_TRUE);\n\t\t\t\t} else {\n\t\t\t\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_ISO6, 1);\n\t\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!e && enh_dsi) {\n\t\t\t\tif (tkw->lvcc) gf_odf_hevc_cfg_del(tkw->lvcc);\n\t\t\t\ttkw->lvcc = gf_odf_hevc_cfg_read(enh_dsi->value.data.ptr, enh_dsi->value.data.size, GF_TRUE);\n\t\t\t\tif (tkw->lvcc) {\n\t\t\t\t\te = gf_isom_lhvc_config_update(ctx->file, tkw->track_num, tkw->stsd_idx, tkw->lvcc, dsi ? GF_ISOM_LEHVC_WITH_BASE_BACKWARD : GF_ISOM_LEHVC_ONLY);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tgf_odf_hevc_cfg_del(tkw->lvcc);\n\t\t\t\t\t\ttkw->lvcc = NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!dsi && tkw->xps_inband) {\n\t\t\t\t\t\tgf_isom_hevc_set_inband_config(ctx->file, tkw->track_num, tkw->stsd_idx, (tkw->xps_inband==XPS_IB_BOTH) ? GF_TRUE : GF_FALSE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (codec_id == GF_CODECID_LHVC) {\n\t\t\t\tgf_isom_lhvc_config_update(ctx->file, tkw->track_num, tkw->stsd_idx, tkw->hvcc, GF_ISOM_LEHVC_ONLY);\n\t\t\t} else if (is_tile_base) {\n\t\t\t\tgf_isom_lhvc_config_update(ctx->file, tkw->track_num, tkw->stsd_idx, tkw->hvcc, GF_ISOM_HEVC_TILE_BASE);\n\t\t\t}\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new HEVC sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\n\t\tif (dsi && tkw->xps_inband) {\n\t\t\t//this will cleanup all PS in avcC / svcC\n\t\t\tgf_isom_hevc_set_inband_config(ctx->file, tkw->track_num, tkw->stsd_idx, (tkw->xps_inband==XPS_IB_BOTH) ? GF_TRUE : GF_FALSE);\n\t\t} else {\n\t\t\tgf_odf_hevc_cfg_del(tkw->hvcc);\n\t\t\ttkw->hvcc = NULL;\n\t\t}\n\n\t\ttkw->use_dref = GF_FALSE;\n\t} else if (use_vvc) {\n\t\tif (tkw->vvcc) gf_odf_vvc_cfg_del(tkw->vvcc);\n\n\t\tif (!dsi) {\n\t\t\t//not yet known\n\t\t\treturn GF_OK;\n\t\t}\n\t\ttkw->vvcc = gf_odf_vvc_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\n\t\ttkw->is_nalu = NALU_VVC;\n\n\t\tif (needs_sample_entry) {\n\t\t\tif (tkw->xps_inband == XPS_IB_PPS) {\n\t\t\t\tu32 k; count=gf_list_count(tkw->vvcc->param_array);\n\t\t\t\tfor (k=0;k<count;k++) {\n\t\t\t\t\tGF_NALUFFParamArray *pa = gf_list_get(tkw->vvcc->param_array, k);\n\t\t\t\t\tif (pa->type==GF_VVC_NALU_PIC_PARAM)\n\t\t\t\t\t\tpa->array_completeness = GF_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\te = gf_isom_vvc_config_new(ctx->file, tkw->track_num, tkw->vvcc, NULL, NULL, &tkw->stsd_idx);\n\n\t\t\tif (!tkw->has_brands) {\n\t\t\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_ISO4, 1);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\t\t}\n\t\t\t//patch for old arch\n\t\t\telse if (ctx->dash_mode) {\n\t\t\t\tBool force_brand=GF_FALSE;\n\t\t\t\tif (((ctx->major_brand_set>>24)=='i') && (((ctx->major_brand_set>>16)&0xFF)=='s') && (((ctx->major_brand_set>>8)&0xFF)=='o')) {\n\t\t\t\t\tif ( (ctx->major_brand_set&0xFF) <'6') force_brand=GF_TRUE;\n\t\t\t\t}\n\n\t\t\t\tif (!force_brand && ctx->major_brand_set) {\n\t\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO6, GF_TRUE);\n\t\t\t\t} else {\n\t\t\t\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_ISO6, 1);\n\t\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new HEVC sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\n\t\tif (tkw->xps_inband) {\n\t\t\t//this will cleanup all PS in vvcC\n\t\t\tgf_isom_vvc_set_inband_config(ctx->file, tkw->track_num, tkw->stsd_idx, ((tkw->xps_inband==XPS_IB_PPS) || (tkw->xps_inband==XPS_IB_BOTH)) ? GF_TRUE : GF_FALSE);\n\t\t} else {\n\t\t\tgf_odf_vvc_cfg_del(tkw->vvcc);\n\t\t\ttkw->vvcc = NULL;\n\t\t}\n\n\t\ttkw->use_dref = GF_FALSE;\n\t} else if (use_av1) {\n\t\tGF_AV1Config *av1c;\n\n\t\tif (!dsi) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] No decoder specific info found for AV1\\n\"));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tav1c = gf_odf_av1_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\t\tif (!av1c) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to parser AV1 decoder specific info\\n\"));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\n\t\te = gf_isom_av1_config_new(ctx->file, tkw->track_num, av1c, (char *) src_url, NULL, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new AV1 sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->is_av1 = GF_TRUE;\n\n\t\tif (!tkw->has_brands) {\n\t\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_ISO4, 1);\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_AV01, GF_TRUE);\n\t\t}\n\n\t\tgf_odf_av1_cfg_del(av1c);\n\t} else if (use_vpX) {\n\t\tGF_VPConfig *vpc;\n\n\t\tif (!dsi) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] No decoder specific info found for %s\\n\", gf_4cc_to_str(codec_id) ));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tvpc = gf_odf_vp_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\t\tif (!vpc) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to parser %s decoder specific info\\n\", gf_4cc_to_str(codec_id)));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\n\t\te = gf_isom_vp_config_new(ctx->file, tkw->track_num, vpc, (char *) src_url, NULL, &tkw->stsd_idx, m_subtype);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new %s sample description: %s\\n\", gf_4cc_to_str(codec_id), gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->is_vpx = GF_TRUE;\n\t\tgf_odf_vp_cfg_del(vpc);\n\t} else if (use_3gpp_config) {\n\t\tGF_3GPConfig gpp_cfg;\n\t\tmemset(&gpp_cfg, 0, sizeof(GF_3GPConfig));\n\t\tgpp_cfg.type = m_subtype;\n\t\tgpp_cfg.vendor = GF_VENDOR_GPAC;\n\n\t\tif (use_dref) {\n\t\t\tgpp_cfg.frames_per_sample  = 1;\n\t\t} else {\n\t\t\tgpp_cfg.frames_per_sample = ctx->pack3gp;\n\t\t\tif (!gpp_cfg.frames_per_sample) gpp_cfg.frames_per_sample  = 1;\n\t\t\telse if (gpp_cfg.frames_per_sample >15) gpp_cfg.frames_per_sample = 15;\n\t\t}\n\t\tgpp_cfg.AMR_mode_set = tkw->amr_mode_set;\n\t\tif (tkw->stream_type==GF_STREAM_VISUAL) {\n\t\t\t/*FIXME - we need more in-depth parsing of the bitstream to detect P3@L10 (streaming wireless)*/\n\t\t\tgpp_cfg.H263_profile = 0;\n\t\t\tgpp_cfg.H263_level = 10;\n\t\t\tgpp_cfg.frames_per_sample = 0;\n\t\t}\n\t\ttkw->nb_frames_per_sample = gpp_cfg.frames_per_sample;\n\n\t\te = gf_isom_3gp_config_new(ctx->file, tkw->track_num, &gpp_cfg, (char *) src_url, NULL, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new 3GPP audio sample description for stream type %d codecid %d: %s\\n\", tkw->stream_type, codec_id, gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->use_dref = src_url ? GF_TRUE : GF_FALSE;\n\n\t\tif (!tkw->has_brands) {\n\t\t\tswitch (gpp_cfg.type) {\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_3G2A, 65536);\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_3GG6, GF_TRUE);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_3GG5, GF_TRUE);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttkw->skip_bitrate_update = GF_TRUE;\n\t} else if (use_ac3_entry) {\n\t\tGF_AC3Config ac3cfg;\n\t\tmemset(&ac3cfg, 0, sizeof(GF_AC3Config));\n\n\t\tif (dsi) {\n\t\t\tgf_odf_ac3_config_parse(dsi->value.data.ptr, dsi->value.data.size, (codec_id==GF_CODECID_EAC3) ? GF_TRUE : GF_FALSE, &ac3cfg);\n\t\t} else {\n\t\t\tif (codec_id==GF_CODECID_EAC3) ac3cfg.is_ec3 = GF_TRUE;\n\t\t}\n\t\te = gf_isom_ac3_config_new(ctx->file, tkw->track_num, &ac3cfg, (char *)src_url, NULL, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new AC3 audio sample description for stream type %d codecid %d: %s\\n\", tkw->stream_type, codec_id, gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->use_dref = src_url ? GF_TRUE : GF_FALSE;\n\t} else if (use_flac_entry) {\n\t\te = gf_isom_flac_config_new(ctx->file, tkw->track_num, dsi ? dsi->value.data.ptr : NULL, dsi ? dsi->value.data.size : 0, (char *)src_url, NULL, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new FLAC audio sample description for stream type %d codecid %d: %s\\n\", tkw->stream_type, codec_id, gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->use_dref = src_url ? GF_TRUE : GF_FALSE;\n\t} else if (use_opus) {\n\t\tGF_OpusConfig opus_cfg;\n\n\t\tif (!dsi) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] No decoder specific info found for opus\\n\" ));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\te = gf_odf_opus_cfg_parse(dsi->value.data.ptr, dsi->value.data.size, &opus_cfg);\n\t\tif (!e)\n\t\t\te = gf_isom_opus_config_new(ctx->file, tkw->track_num, &opus_cfg, (char *)src_url, NULL, &tkw->stsd_idx);\n\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new Opus audio sample description for stream type %d codecid %d: %s\\n\", tkw->stream_type, codec_id, gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->use_dref = src_url ? GF_TRUE : GF_FALSE;\n\t} else if (m_subtype == GF_ISOM_SUBTYPE_METX) {\n\t\tcomp_name = \"XML Metadata\";\n\t\te = gf_isom_new_xml_metadata_description(ctx->file, tkw->track_num, meta_xmlns, meta_schemaloc, meta_encoding, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new METX sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t} else if (m_subtype == GF_ISOM_SUBTYPE_METT) {\n\t\tcomp_name = \"Text Metadata\";\n\t\te = gf_isom_new_stxt_description(ctx->file, tkw->track_num, GF_ISOM_SUBTYPE_METT, meta_mime, meta_encoding, meta_config, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new METT sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t} else if (m_subtype == GF_ISOM_SUBTYPE_STPP) {\n\t\tif (meta_xmlns && !strcmp(meta_xmlns, \"http://www.w3.org/ns/ttml\")) {\n\t\t\tcomp_name = \"TTML\";\n\t\t} else {\n\t\t\tcomp_name = \"XML Subtitle\";\n\t\t}\n\t\te = gf_isom_new_xml_subtitle_description(ctx->file, tkw->track_num, meta_xmlns, meta_schemaloc, meta_auxmimes, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new XML subtitle sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\n\t\t//CMAF 11.3.2\n\t\tif (ctx->cmaf) {\n\t\t\tif (!meta_mime) meta_mime = gf_isom_subtitle_get_mime(ctx->file, tkw->track_num, tkw->stsd_idx);\n\t\t\tif (!meta_mime || (!strstr(meta_mime, \"im1t\") && !strstr(meta_mime, \"im1i\"))) {\n\t\t\t\tgf_isom_subtitle_set_mime(ctx->file, tkw->track_num, tkw->stsd_idx, \"application/ttml+xml;codecs=im1t\");\n\t\t\t}\n\t\t}\n\n\n\t} else if ((m_subtype == GF_ISOM_SUBTYPE_SBTT) || (m_subtype == GF_ISOM_SUBTYPE_STXT) ) {\n\t\tcomp_name = (m_subtype == GF_ISOM_SUBTYPE_STXT) ? \"Simple Timed Text\" : \"Textual Subtitle\";\n\t\te = gf_isom_new_stxt_description(ctx->file, tkw->track_num, m_subtype, meta_mime, meta_content_encoding, meta_config, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new %s sample description: %s\\n\", gf_4cc_to_str(m_subtype), gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\tif (m_subtype == GF_ISOM_SUBTYPE_STXT) force_tk_layout = GF_TRUE;\n\t} else if (use_tx3g) {\n\t\tGF_TextSampleDescriptor *txtc;\n\t\tif (!dsi) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] No decoder specific info found for TX3G\\n\"));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\ttxtc = gf_odf_tx3g_read(dsi->value.data.ptr, dsi->value.data.size);\n\t\tif (!txtc) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to parse TX3G config\\n\"));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\n\t\tif (!txtc->default_pos.right) txtc->default_pos.right = width + txtc->default_pos.left;\n\t\tif (!txtc->default_pos.bottom) txtc->default_pos.bottom = height + txtc->default_pos.top;\n\n\n\t\te = gf_isom_new_text_description(ctx->file, tkw->track_num, txtc, NULL, NULL, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tgf_odf_desc_del((GF_Descriptor *)txtc);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new %s sample description: %s\\n\", gf_4cc_to_str(m_subtype), gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\tif (ctx->importer) {\n\t\t\ttxt_fsize = txtc->default_style.font_size;\n\t\t\tif (txtc->font_count && txtc->fonts[0].fontName) txt_font = gf_strdup(txtc->fonts[0].fontName);\n\t\t}\n\t\tgf_odf_desc_del((GF_Descriptor *)txtc);\n\n\t\ttkw->skip_bitrate_update = GF_TRUE;\n\t} else if (use_webvtt) {\n#ifndef GPAC_DISABLE_VTT\n\t\te = gf_isom_new_webvtt_description(ctx->file, tkw->track_num, NULL, NULL, &tkw->stsd_idx, dsi ? dsi->value.data.ptr : NULL);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new %s sample description: %s\\n\", gf_4cc_to_str(m_subtype), gf_error_to_string(e)));\n\t\t\treturn e;\n\t\t}\n#else\n\t\treturn GF_NOT_SUPPORTED;\n#endif\n\t\ttkw->skip_bitrate_update = GF_TRUE;\n\t} else if (use_mj2) {\n\t\te = gf_isom_new_mj2k_description(ctx->file, tkw->track_num, NULL, NULL, &tkw->stsd_idx, dsi ? dsi->value.data.ptr : NULL, dsi ? dsi->value.data.size : 0);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new %s sample description: %s\\n\", gf_4cc_to_str(m_subtype), gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t} else if (codec_id==GF_CODECID_TMCD) {\n\t\tu32 tmcd_flags=0, tmcd_fps_num=0, tmcd_fps_den=0;\n\t\ts32 tmcd_fpt=0;\n\n\t\tp = gf_filter_pid_get_property_str(pid, \"tmcd:flags\");\n\t\tif (p) tmcd_flags = p->value.uint;\n\t\tp = gf_filter_pid_get_property_str(pid, \"tmcd:framerate\");\n\t\tif (p) {\n\t\t\ttmcd_fps_num = p->value.frac.num;\n\t\t\ttmcd_fps_den = p->value.frac.den;\n\t\t}\n\t\tp = gf_filter_pid_get_property_str(pid, \"tmcd:frames_per_tick\");\n\t\tif (p) tmcd_fpt = p->value.uint;\n\t\tif (tkw->tk_timescale != tmcd_fps_num) {\n\t\t\ttmcd_fps_den *= tmcd_fps_num;\n\t\t\ttmcd_fps_den /= tkw->tk_timescale;\n\t\t}\n\n\t\te = gf_isom_tmcd_config_new(ctx->file, tkw->track_num, tmcd_fps_num, tmcd_fps_den, tmcd_fpt, (tmcd_flags & 0x1), (tmcd_flags & 0x8), &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new tmcd sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t} else if (codec_id==GF_CODECID_DIMS) {\n\t\tGF_DIMSDescription dims_c;\n\t\tmemset(&dims_c, 0, sizeof(GF_DIMSDescription));\n\t\tdims_c.contentEncoding = meta_content_encoding;\n\t\tdims_c.mime_type = meta_mime;\n\t\tdims_c.textEncoding = meta_encoding;\n\t\tdims_c.xml_schema_loc = meta_xmlns;\n\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"dims:profile\");\n\t\tif (p) dims_c.profile = p->value.uint;\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"dims:level\");\n\t\tif (p) dims_c.level = p->value.uint;\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"dims:pathComponents\");\n\t\tif (p) dims_c.pathComponents = p->value.uint;\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"dims:fullRequestHost\");\n\t\tif (p) dims_c.fullRequestHost = p->value.uint;\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"dims:streamType\");\n\t\tif (p) dims_c.streamType = p->value.boolean;\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"dims:redundant\");\n\t\tif (p) dims_c.containsRedundant = p->value.uint;\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"dims:scriptTypes\");\n\t\tif (p) dims_c.content_script_types = p->value.string;\n\n\t\te = gf_isom_new_dims_description(ctx->file, tkw->track_num, &dims_c, NULL, NULL, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new DIMS sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t} else if ((codec_id==GF_CODECID_MPHA) || (codec_id==GF_CODECID_MHAS)) {\n\t\t//not ready yet\n\t\tu8 *pdsi=NULL;\n\t\tu32 dsi_len=0;\n\t\tif (codec_id==GF_CODECID_MPHA) {\n\t\t\tif (!dsi) return GF_OK;\n\t\t\tpdsi = dsi->value.data.ptr;\n\t\t\tdsi_len = dsi->value.data.size;\n\t\t}\n\t\te = gf_isom_new_mpha_description(ctx->file, tkw->track_num, NULL, NULL, &tkw->stsd_idx, pdsi, dsi_len, m_subtype);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new MPEG-H Audio sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_MHA_COMPATIBLE_PROFILES);\n\t\tif (p) {\n\t\t\tgf_isom_set_mpegh_compatible_profiles(ctx->file, tkw->track_num, tkw->stsd_idx, p->value.uint_list.vals, p->value.uint_list.nb_items);\n\t\t}\n\t} else if (codec_id==GF_CODECID_TRUEHD) {\n\t\tu32 fmt=0, prate=0;\n\t\t//not ready yet\n\t\tif (!dsi) return GF_OK;\n\t\tif (dsi->value.data.size < 6) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\tfmt = dsi->value.data.ptr[0];\n\t\tfmt <<= 8;\n\t\tfmt |= dsi->value.data.ptr[1];\n\t\tprate = dsi->value.data.ptr[2];\n\t\tprate <<= 8;\n\t\tprate |= dsi->value.data.ptr[3];\n\t\tprate >>= 1;\n\n\t\te = gf_isom_truehd_config_new(ctx->file, tkw->track_num, (char *)src_url, NULL, fmt, prate, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new TrueHD Audio sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t} else if (use_gen_sample_entry) {\n\t\tu8 isor_ext_buf[14], *gpac_meta_dsi=NULL;\n\t\tu32 len = 0;\n\t\tGF_GenericSampleDescription udesc;\n\t\tmemset(&udesc, 0, sizeof(GF_GenericSampleDescription));\n\n\t\tif (!comp_name) comp_name = \"Unknown\";\n\t\tlen = (u32) strlen(comp_name);\n\t\tif (len>32) len = 32;\n\t\tudesc.compressor_name[0] = len;\n\t\tmemcpy(udesc.compressor_name+1, comp_name, len);\n\t\tif ((codec_id==GF_CODECID_RAW) || unknown_generic)\n\t\t\tudesc.vendor_code = GF_4CC('G','P','A','C');\n\n\t\tudesc.samplerate = sr;\n\t\tudesc.nb_channels = nb_chan;\n\t\tudesc.bits_per_sample = nb_bps;\n\t\tudesc.lpcm_flags = afmt_flags | (1<<3); //add packed flag\n\t\t//for raw audio, select qt vs isom and set version\n\t\tif (sr && (codec_id==GF_CODECID_RAW)) {\n\t\t\tif (ctx->make_qt && (ase_mode==GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_BS)) {\n\t\t\t\tudesc.is_qtff = GF_TRUE;\n\t\t\t\t//if extensions or not 'raw ' or 'twos', use v1\n\t\t\t\tif (dsi ||\n\t\t\t\t\t((m_subtype!=GF_QT_SUBTYPE_TWOS) && (m_subtype!=GF_QT_SUBTYPE_RAW))\n\t\t\t\t) {\n\t\t\t\t\tudesc.version = 1;\n\t\t\t\t\tase_mode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ase_mode<=GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_MPEG) {\n\t\t\t\tm_subtype = m_subtype_alt_raw;\n\t\t\t\tudesc.extension_buf_size = 14;\n\t\t\t\tudesc.extension_buf = isor_ext_buf;\n\t\t\t\tmemset(isor_ext_buf, 0, sizeof(u8)*14);\n\t\t\t\tisor_ext_buf[3] = 14;\n\t\t\t\tisor_ext_buf[4] = 'p';\n\t\t\t\tisor_ext_buf[5] = 'c';\n\t\t\t\tisor_ext_buf[6] = 'm';\n\t\t\t\tisor_ext_buf[7] = 'C';\n\t\t\t\tisor_ext_buf[12] = (afmt_flags & (1<<1)) ? 0 : 1; //big/little endian\n\t\t\t\tisor_ext_buf[13] = nb_bps;\n\t\t\t\tif (ase_mode==GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_MPEG)\n\t\t\t\t\tudesc.version = 1;\n\t\t\t} else {\n\t\t\t\tudesc.is_qtff = GF_TRUE;\n\t\t\t\tudesc.version = 1;\n\t\t\t\tase_mode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF;\n\t\t\t}\n\t\t}\n\n\t\tif (codec_id == GF_CODECID_FFMPEG) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_SUBTYPE);\n\t\t\tif (p) {\n\t\t\t\tm_subtype = p->value.uint;\n\t\t\t} else {\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_META_DEMUX_CODEC_ID);\n\t\t\t\tif (p && p->type==GF_PROP_UINT)\n\t\t\t\t\tm_subtype = p->value.uint;\n\t\t\t}\n\t\t}\n\n\t\tudesc.codec_tag = m_subtype;\n\t\tudesc.width = width;\n\t\tudesc.height = height;\n\t\tif (width) {\n\t\t\tudesc.v_res = 72;\n\t\t\tudesc.h_res = 72;\n\t\t\tudesc.depth = 24;\n\t\t}\n\t\tif (dsi) {\n\t\t\tudesc.extension_buf = dsi->value.data.ptr;\n\t\t\tudesc.extension_buf_size = dsi->value.data.size;\n\t\t\tudesc.ext_box_wrap = gen_dsi_wrap;\n\t\t\tp = gf_filter_pid_get_property_str(pid, \"DSIWrap\");\n\t\t\tif (p) {\n\t\t\t\tif (p->type==GF_PROP_UINT) udesc.ext_box_wrap = p->value.uint;\n\t\t\t\telse if (p->type==GF_PROP_STRING) udesc.ext_box_wrap = gf_4cc_parse(p->value.string);\n\t\t\t}\n\t\t}\n\t\tif (codec_id==GF_CODECID_FFV1) {\n\t\t\tudesc.codec_tag = GF_4CC('F', 'F', 'V', '1');\n\t\t\tudesc.ext_box_wrap = GF_4CC('g', 'l', 'b', 'l');\n\t\t\tunknown_generic = GF_FALSE;\n\t\t}\n\t\tif (codec_id==GF_CODECID_SMPTE_VC1) {\n\t\t\tudesc.codec_tag = GF_4CC('v', 'c', '-', '1');\n\t\t\tunknown_generic = GF_FALSE;\n\t\t\tif (udesc.extension_buf)\n\t\t\t\tudesc.ext_box_wrap = GF_4CC('d', 'v', 'c', '1');\n\t\t}\n\t\t//move to uncv\n\t\tif ((codec_id==GF_CODECID_RAW) && !ctx->make_qt && ctx->uncv && (tkw->stream_type==GF_STREAM_VISUAL)) {\n\t\t\tif ( gf_pixel_fmt_get_uncc(pix_fmt, ctx->uncv-1, &gpac_meta_dsi, &udesc.extension_buf_size) == GF_TRUE) {\n\t\t\t\tunknown_generic = GF_FALSE;\n\t\t\t\tudesc.extension_buf = gpac_meta_dsi;\n\t\t\t\tudesc.codec_tag = m_subtype = GF_ISOM_SUBTYPE_UNCV;\n\t\t\t}\n\t\t}\n\n\t\tif (unknown_generic) {\n\t\t\t//check if this is a meta codec (unmapped codec from ffmpeg or other)\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_META_DEMUX_CODEC_ID);\n\t\t\tconst GF_PropertyValue *p2 = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_META_DEMUX_CODEC_NAME);\n\t\t\tif (p || p2) {\n\t\t\t\tu32 cid = (p && (p->type==GF_PROP_UINT)) ? p->value.uint : m_subtype;\n\t\t\t\tconst char *cname = p2 ? p2->value.string : NULL;\n\t\t\t\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t\t\tgf_bs_write_u32(bs, codec_id);\n\t\t\t\tgf_bs_write_u32(bs, cid);\n\t\t\t\tgf_bs_write_utf8(bs, cname ? cname : gf_4cc_to_str(cid));\n\t\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_META_DEMUX_OPAQUE);\n\t\t\t\tgf_bs_write_u32(bs, p ? p->value.uint : 0);\n\n\t\t\t\tif (dsi && (dsi->type != GF_PROP_DATA) && (dsi->type != GF_PROP_CONST_DATA))\n\t\t\t\t\tdsi = NULL;\n\n\t\t\t\tif (dsi) {\n\t\t\t\t\tgf_bs_write_data(bs, dsi->value.data.ptr, dsi->value.data.size);\n\t\t\t\t}\n\t\t\t\tgf_bs_get_content(bs, &gpac_meta_dsi, &udesc.extension_buf_size);\n\t\t\t\tudesc.extension_buf = gpac_meta_dsi;\n\t\t\t\tudesc.ext_box_wrap = GF_FALSE;\n\n\t\t\t\tgf_bs_del(bs);\n\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] muxing %s, using generic sample entry with 4CC \\\"GMCW\\\" and \\\"GMCC\\\" config box\\n\", gf_codecid_name(codec_id)));\n\t\t\t\tudesc.codec_tag = GF_4CC('G', 'M', 'C', 'W');\n\t\t\t\tudesc.ext_box_wrap = GF_4CC('G', 'M', 'C', 'C');\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] muxing unknown codec ID %s, using generic sample entry with 4CC \\\"%s\\\"\\n\", gf_codecid_name(codec_id), gf_4cc_to_str(m_subtype) ));\n\t\t\t}\n\t\t}\n\t\t\n\t\te = gf_isom_new_generic_sample_description(ctx->file, tkw->track_num, (char *)src_url, NULL, &udesc, &tkw->stsd_idx);\n\t\tif (gpac_meta_dsi) gf_free(gpac_meta_dsi);\n\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new sample description for stream type %d codecid %d: %s\\n\", tkw->stream_type, codec_id, gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->use_dref = src_url ? GF_TRUE : GF_FALSE;\n\n\t} else {\n\t\tassert(0);\n\t}\n\n\tif (!tkw->all_stsd_crc) {\n\t\tif (ctx->btrt && !tkw->skip_bitrate_update) {\n\t\t\tu32 avg_rate, max_rate, dbsize;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_BITRATE);\n\t\t\tavg_rate = p ? p->value.uint : 0;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_MAXRATE);\n\t\t\tmax_rate = p ? p->value.uint : 0;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DBSIZE);\n\t\t\tdbsize = p ? p->value.uint : 0;\n\n\t\t\tif (avg_rate && max_rate) {\n\t\t\t\tgf_isom_update_bitrate(ctx->file, tkw->track_num, tkw->stsd_idx, avg_rate, max_rate, dbsize);\n\t\t\t}\n\t\t} else {\n\t\t\tgf_isom_update_bitrate(ctx->file, tkw->track_num, tkw->stsd_idx, 0, 0, 0);\n\t\t}\n\t}\n\nmultipid_stsd_setup:\n\tif (multi_pid_stsd) {\n\t\tif (multi_pid_idx<gf_list_count(multi_pid_stsd)) {\n\n\t\t\tif (multi_pid_final_stsd_idx == multi_pid_idx) {\n\t\t\t\tframes_per_sample_backup = tkw->nb_frames_per_sample;\n\t\t\t\tis_nalu_backup = tkw->is_nalu;\n\t\t\t}\n\t\t\tpid = gf_list_get(multi_pid_stsd, multi_pid_idx);\n\t\t\tmulti_pid_idx ++;\n\t\t\t//reload codecID, decoder config and enhancement decoder config\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CODECID);\n\t\t\tif (p) codec_id = p->value.uint;\n\t\t\tdsi = gf_filter_pid_get_property(pid, GF_PROP_PID_DECODER_CONFIG);\n\t\t\tenh_dsi = gf_filter_pid_get_property(pid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT);\n\t\t\t//force stsd idx to be 0 to avoid removing the stsd\n\t\t\ttkw->stsd_idx = 0;\n\t\t\tgoto sample_entry_setup;\n\t\t}\n\t\ttkw->stsd_idx = multi_pid_final_stsd_idx;\n\t\t//restore input pid\n\t\tpid = orig_pid;\n\t\tcodec_id = tkw->codecid;\n\n\t\ttkw->is_nalu = is_nalu_backup;\n\t\ttkw->nb_frames_per_sample = frames_per_sample_backup;\n\t}\n\n\n\t//final opt: we couldn't detect before if the same stsd was possible, now that we have create a new one, check again\n\tif (needs_sample_entry) {\n\t\treuse_stsd = 0;\n\t\t//don't try to reuse STSDs in multi STSD setup for DASH\n\t\tif (multi_pid_stsd) count = 0;\n\t\telse count = gf_isom_get_sample_description_count(ctx->file, tkw->track_num);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tif (i+1 == tkw->stsd_idx) continue;\n\n\t\t\tif (gf_isom_is_same_sample_description(ctx->file, tkw->track_num, tkw->stsd_idx, ctx->file, tkw->track_num, i+1) ) {\n\t\t\t\tgf_isom_remove_stream_description(ctx->file, tkw->track_num, tkw->stsd_idx);\n\t\t\t\ttkw->stsd_idx = i+1;\n\t\t\t\treuse_stsd = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttkw->reused_stsd = reuse_stsd;\n\t\tif (!reuse_stsd) {\n\t\t\ttkw->samples_in_stsd = 0;\n\t\t} else if (use_3gpp_config) {\n\t\t\tGF_3GPConfig *gpp_cfg = gf_isom_3gp_config_get(ctx->file, tkw->track_num, tkw->stsd_idx);\n\t\t\tif (gpp_cfg) {\n\t\t\t\tgpp_cfg->AMR_mode_set = tkw->amr_mode_set;\n\t\t\t\tgf_isom_3gp_config_update(ctx->file, tkw->track_num, gpp_cfg, tkw->stsd_idx);\n\t\t\t\tgf_free(gpp_cfg);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tkw->is_encrypted && !skip_crypto) {\n\t\tconst char *scheme_uri=NULL;\n\t\tconst char *kms_uri=NULL;\n\t\tu32 scheme_version=0;\n\t\tu32 scheme_type = 0;\n\t\tBool is_sel_enc = GF_FALSE;\n\t\tu32 KI_length=0;\n\t\tu32 IV_length=0;\n\t\t/*todo !*/\n\t\tconst char *oma_contentID=0;\n\t\tu32 oma_encryption_type=0;\n\t\tu64 oma_plainTextLength=0;\n\t\tconst char *oma_textual_headers=NULL;\n\t\tu32 textual_headers_len=0;\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PROTECTION_SCHEME_TYPE);\n\t\tif (p) scheme_type = p->value.uint;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PROTECTION_SCHEME_VERSION);\n\t\tif (p) scheme_version = p->value.uint;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PROTECTION_SCHEME_URI);\n\t\tif (p) scheme_uri = p->value.string;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PROTECTION_KMS_URI);\n\t\tif (p) kms_uri = p->value.string;\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISMA_SELECTIVE_ENC);\n\t\tif (p) is_sel_enc = p->value.boolean;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISMA_IV_LENGTH);\n\t\tif (p) IV_length = p->value.uint;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISMA_KI_LENGTH);\n\t\tif (p) KI_length = p->value.uint;\n\n\t\ttkw->scheme_type = scheme_type;\n\t\tswitch (scheme_type) {\n\t\tcase GF_ISOM_ISMACRYP_SCHEME:\n\t\t\tgf_isom_set_ismacryp_protection(ctx->file, tkw->track_num, tkw->stsd_idx, scheme_type, scheme_version, (char *) scheme_uri, (char *) kms_uri, is_sel_enc, KI_length, IV_length);\n\t\t\tbreak;\n\t\tcase GF_ISOM_OMADRM_SCHEME:\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_OMA_CRYPT_TYPE);\n\t\t\tif (p) oma_encryption_type = p->value.uint;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_OMA_CID);\n\t\t\tif (p) oma_contentID = p->value.string;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_OMA_TXT_HDR);\n\t\t\tif (p) oma_textual_headers = p->value.string;\n\t\t\tif (oma_textual_headers) textual_headers_len = (u32) strlen(oma_textual_headers);\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_OMA_CLEAR_LEN);\n\t\t\tif (p) oma_plainTextLength = p->value.longuint;\n\t\t\tgf_isom_set_oma_protection(ctx->file, tkw->track_num, tkw->stsd_idx, (char *) oma_contentID, (char*) kms_uri, oma_encryption_type, oma_plainTextLength, (char*)oma_textual_headers, textual_headers_len,\n                                  is_sel_enc, KI_length, IV_length);\n\n\t\t\tbreak;\n\t\tcase GF_ISOM_ADOBE_SCHEME:\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ADOBE_CRYPT_META);\n\t\t\tgf_isom_set_adobe_protection(ctx->file, tkw->track_num, tkw->stsd_idx, scheme_type, 1/*scheme_version*/, 1/*is_sel_enc*/,p ? p->value.data.ptr : NULL, p ? p->value.data.size : 0);\n\t\t\tbreak;\n\t\tcase GF_ISOM_PIFF_SCHEME:\n\t\tcase GF_ISOM_CENC_SCHEME:\n\t\tcase GF_ISOM_CENS_SCHEME:\n\t\tcase GF_ISOM_CBC_SCHEME:\n\t\tcase GF_ISOM_CBCS_SCHEME:\n\t\tcase GF_HLS_SAMPLE_AES_SCHEME:\n\t\t\ttkw->cenc_state = CENC_NEED_SETUP;\n\t\t\tif (tkw->is_nalu || tkw->is_av1 || tkw->is_vpx) tkw->cenc_subsamples = GF_TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Unrecognized protection scheme type %s, using generic signaling\\n\", gf_4cc_to_str(scheme_type) ));\n\t\t\tswitch (tkw->stream_type) {\n\t\t\tcase GF_STREAM_VISUAL:\n\t\t\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_ENCV);\n\t\t\t\tbreak;\n\t\t\tcase GF_STREAM_AUDIO:\n\t\t\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_ENCA);\n\t\t\t\tbreak;\n\t\t\tcase GF_STREAM_TEXT:\n\t\t\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_ENCT);\n\t\t\t\tbreak;\n\t\t\tcase GF_STREAM_FONT:\n\t\t\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_ENCF);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_ENCS);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgf_isom_set_generic_protection(ctx->file, tkw->track_num, tkw->stsd_idx, scheme_type, scheme_version, (char*)scheme_uri, (char*)kms_uri);\n\t\t}\n\t} else if (!tkw->is_encrypted) {\n\t\t//in case we used track template\n\t\tgf_isom_remove_samp_enc_box(ctx->file, tkw->track_num);\n\t\tgf_isom_remove_samp_group_box(ctx->file, tkw->track_num);\n\t}\n\n\tif (is_true_pid) {\n\t\tmp4_mux_write_track_refs(ctx, tkw, \"isom:scal\", GF_ISOM_REF_SCAL, GF_FALSE);\n\t\tmp4_mux_write_track_refs(ctx, tkw, \"isom:sabt\", GF_ISOM_REF_SABT, GF_FALSE);\n\t\tmp4_mux_write_track_refs(ctx, tkw, \"isom:tbas\", GF_ISOM_REF_TBAS, GF_TRUE);\n\t\tmp4_mux_write_track_refs(ctx, tkw, \"isom:sbas\", GF_ISOM_REF_BASE, GF_FALSE);\n\t\t//whenever we add a new tile track, rewrite sabt on main tile track\n\t\tif (codec_id==GF_CODECID_HEVC_TILES) {\n\t\t\tcount = gf_list_count(ctx->tracks);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tTrackWriter *base_tk = gf_list_get(ctx->tracks, i);\n\t\t\t\tif (base_tk->is_hevc_tile_base)\n\t\t\t\t\tmp4_mux_write_track_refs(ctx, base_tk, \"isom:sabt\", GF_ISOM_REF_SABT, GF_FALSE);\n\t\t\t}\n\t\t}\n\n\t\t//check if we have sample-accurate seek info for the pid. If so, enable seek ts checking\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PCK_SKIP_BEGIN);\n\t\tif (p && p->value.sint)\n\t\t\ttkw->check_seek_ts = GF_TRUE;\n\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DURATION);\n\t\tif (p && p->value.lfrac.den) {\n\t\t\ttkw->pid_dur = p->value.lfrac;\n\t\t\tif (tkw->pid_dur.num<0) tkw->pid_dur.num = -tkw->pid_dur.num;\n\t\t}\n\n\t} else if (codec_id==GF_CODECID_HEVC_TILES) {\n\t\tmp4_mux_write_track_refs(ctx, tkw, \"isom:tbas\", GF_ISOM_REF_TBAS, GF_TRUE);\n\t}\n\n\tif (is_true_pid && ctx->dash_mode && is_tile_base) {\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DASH_MULTI_TRACK);\n\t\tif (p) {\n\t\t\tGF_List *multi_tracks = p->value.ptr;\n\t\t\tcount = gf_list_count(multi_tracks);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_FilterPid *a_ipid = gf_list_get(multi_tracks, i);\n\t\t\t\tmp4_mux_setup_pid(filter, a_ipid, GF_FALSE);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (width) {\n\t\tif (ctx->ccst) {\n\t\t\te = gf_isom_set_image_sequence_coding_constraints(ctx->file, tkw->track_num, tkw->stsd_idx, GF_FALSE, GF_FALSE, GF_TRUE, 15);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set coding constraints parameter: %s\\n\", gf_error_to_string(e) ));\n\t\t\t}\n\t\t}\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ALPHA);\n\t\tif (p && p->value.boolean) {\n\t\t\te = gf_isom_set_image_sequence_alpha(ctx->file, tkw->track_num, tkw->stsd_idx, GF_FALSE);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set alpha config: %s\\n\", gf_error_to_string(e) ));\n\t\t\t}\n\t\t}\n\t}\n\nsample_entry_done:\n\tif (!tkw->is_item) {\n\t\tif (ctx->maxchunk)\n\t\t\tgf_isom_hint_max_chunk_size(ctx->file, tkw->track_num, ctx->maxchunk);\n\n\t\tif (ctx->store==MP4MX_MODE_FLAT)\n\t\t\tgf_isom_hint_max_chunk_duration(ctx->file, tkw->track_num, tkw->tk_timescale * ctx->cdur.num / ctx->cdur.den);\n\n\t\tif (sr) {\n\t\t\tif (use_flac_entry) {\n\t\t\t\twhile (sr>65535) {\n\t\t\t\t\tu32 val = sr/2;\n\t\t\t\t\tif (val*2 != sr) {\n\t\t\t\t\t\tsr=65535;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsr = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (m_subtype!=GF_QT_SUBTYPE_LPCM) {\n\t\t\t\tgf_isom_set_audio_info(ctx->file, tkw->track_num, tkw->stsd_idx, sr, nb_chan, nb_bps, ctx->make_qt ? GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF : ase_mode);\n\t\t\t}\n\n\t\t\tif ((m_subtype==GF_ISOM_SUBTYPE_IPCM) || (m_subtype==GF_ISOM_SUBTYPE_FPCM)) {\n\t\t\t\tGF_AudioChannelLayout layout;\n\t\t\t\tmemset(&layout, 0, sizeof(GF_AudioChannelLayout));\n\t\t\t\tlayout.stream_structure = 1;\n\t\t\t\tlayout.channels_count = nb_chan;\n\t\t\t\tif (ch_layout)\n\t\t\t\t\tlayout.definedLayout = gf_audio_fmt_get_cicp_from_layout(ch_layout);\n\t\t\t\telse\n\t\t\t\t\tlayout.definedLayout = gf_audio_fmt_get_cicp_layout(nb_chan, 0, 0);\n\t\t\t\tgf_isom_set_audio_layout(ctx->file, tkw->track_num, tkw->stsd_idx, &layout);\n\t\t\t}\n\t\t}\n\t\telse if (width) {\n\t\t\tu32 colour_type=0;\n\t\t\tu16 colour_primaries=0, transfer_characteristics=0, matrix_coefficients=0;\n\t\t\tBool full_range_flag=GF_FALSE;\n\n\t\t\tgf_isom_set_visual_info(ctx->file, tkw->track_num, tkw->stsd_idx, width, height);\n\t\t\tif (sar.den) {\n\t\t\t\tif (sar.num != sar.den) {\n\t\t\t\t\tgf_isom_set_pixel_aspect_ratio(ctx->file, tkw->track_num, tkw->stsd_idx, sar.num, sar.den, GF_FALSE);\n\t\t\t\t\twidth = width * sar.num / sar.den;\n\t\t\t\t}\n\t\t\t\t//old importer did not set PASP for\n\t\t\t\telse if (!gf_sys_old_arch_compat() || (codec_id!=GF_CODECID_MPEG4_PART2) ) {\n\t\t\t\t\tgf_isom_set_pixel_aspect_ratio(ctx->file, tkw->track_num, tkw->stsd_idx, 1, 1, GF_TRUE);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgf_isom_set_track_layout_info(ctx->file, tkw->track_num, width<<16, height<<16, 0, 0, z_order);\n\t\t\tif (codec_id==GF_CODECID_HEVC_TILES) {\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ORIG_SIZE);\n\t\t\t\tif (p) {\n\t\t\t\t\tgf_isom_set_track_layout_info(ctx->file, tkw->track_num, p->value.vec2i.x<<16, p->value.vec2i.y<<16, 0, 0, z_order);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_COLR_PRIMARIES);\n\t\t\tif (p) colour_primaries = p->value.uint;\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_COLR_TRANSFER);\n\t\t\tif (p) transfer_characteristics = p->value.uint;\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_COLR_MX);\n\t\t\tif (p) matrix_coefficients = p->value.uint;\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_COLR_RANGE);\n\t\t\tif (p) full_range_flag = p->value.boolean;\n\n\t\t\tif (ctx->cmaf) {\n\t\t\t\tu32 hspac=0, vspac=0;\n\t\t\t\tforce_colr = GF_TRUE;\n\t\t\t\tgf_isom_get_pixel_aspect_ratio(ctx->file, tkw->track_num, tkw->stsd_idx, &hspac, &vspac);\n\t\t\t\tif (hspac && vspac) {\n\t\t\t\t\tsar.num = hspac;\n\t\t\t\t\tsar.den = vspac;\n\t\t\t\t} else {\n\t\t\t\t\tsar.den = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((ctx->prores_track == tkw) || force_colr) {\n\t\t\t\tu32 colr_mode;\n\n\t\t\t\tif ((ctx->prores_track == tkw) || ctx->make_qt)\n\t\t\t\t\tcolr_mode = GF_4CC('n','c','l','c');\n\t\t\t\telse\n\t\t\t\t\tcolr_mode = GF_4CC('n','c','l','x');\n\n\t\t\t\t//other conditions were set above, here we force 1:1 pasp box even if no sar or 1:1\n\t\t\t\tif (!sar.den || (sar.num == 1)) {\n\t\t\t\t\tgf_isom_set_pixel_aspect_ratio(ctx->file, tkw->track_num, tkw->stsd_idx, -1, -1, GF_TRUE);\n\t\t\t\t}\n\n\t\t\t\tif (colour_primaries || transfer_characteristics || matrix_coefficients) {\n\t\t\t\t\tgf_isom_set_visual_color_info(ctx->file, tkw->track_num, tkw->stsd_idx, colr_mode, colour_primaries, transfer_characteristics, matrix_coefficients, GF_FALSE, NULL, 0);\n\t\t\t\t} else {\n\t\t\t\t\te = gf_isom_get_color_info(ctx->file, tkw->track_num, tkw->stsd_idx, &colour_type, &colour_primaries, &transfer_characteristics, &matrix_coefficients, &full_range_flag);\n\t\t\t\t\tif (e==GF_NOT_FOUND) {\n\t\t\t\t\t\te = gf_media_get_color_info(ctx->file, tkw->track_num, tkw->stsd_idx, &colour_type, &colour_primaries, &transfer_characteristics, &matrix_coefficients, &full_range_flag);\n\t\t\t\t\t\tif (e)\n\t\t\t\t\t\t\te = GF_NOT_FOUND;\n\t\t\t\t\t}\n\t\t\t\t\tif (e==GF_NOT_FOUND) {\n\t\t\t\t\t\tcolour_primaries = 1;\n\t\t\t\t\t\ttransfer_characteristics = 1;\n\t\t\t\t\t\tmatrix_coefficients = 1;\n\t\t\t\t\t\tfull_range_flag = GF_FALSE;\n\t\t\t\t\t\tif (ctx->make_qt==1) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[ProRes] No color info present in visual track, defaulting to BT709\\n\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ctx->cmaf) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[CMAF] No color info present in visual track, defaulting to BT709\\n\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_set_visual_color_info(ctx->file, tkw->track_num, tkw->stsd_idx, colr_mode, colour_primaries, transfer_characteristics, matrix_coefficients, full_range_flag, NULL, 0);\n\t\t\t\t}\n\n\t\t\t\tif (ctx->prores_track == tkw) {\n\t\t\t\t\tu32 chunk_size;\n\t\t\t\t\tif ((width<=720) && (height<=576)) chunk_size = 2000000;\n\t\t\t\t\telse chunk_size = 4000000;\n\t\t\t\t\tgf_isom_hint_max_chunk_size(ctx->file, tkw->track_num, chunk_size);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (colour_primaries || transfer_characteristics || matrix_coefficients) {\n\t\t\t\t\tgf_isom_set_visual_color_info(ctx->file, tkw->track_num, tkw->stsd_idx, GF_4CC('n','c','l','x'), colour_primaries, transfer_characteristics, matrix_coefficients, full_range_flag, NULL, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//check if we have an icc profile\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ICC_PROFILE);\n\t\t\tif (p && (p->type==GF_PROP_DATA) && p->value.data.ptr) {\n\t\t\t\tgf_isom_set_visual_color_info(ctx->file, tkw->track_num, tkw->stsd_idx, 0, 0, 0, 0, GF_FALSE, p->value.data.ptr, p->value.data.size);\n\t\t\t}\n\n\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CONTENT_LIGHT_LEVEL);\n\t\t\tconst GF_PropertyValue *p2 = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_MASTER_DISPLAY_COLOUR);\n\t\t\tif (p || p2) {\n\t\t\t\tGF_MasteringDisplayColourVolumeInfo mdcv;\n\t\t\t\tGF_ContentLightLevelInfo clli;\n\t\t\t\tGF_BitStream *bs;\n\t\t\t\tif (p) {\n\t\t\t\t\tbs = gf_bs_new(p->value.data.ptr, p->value.data.size, GF_BITSTREAM_READ);\n\t\t\t\t\tclli.max_content_light_level = gf_bs_read_int(bs, 16);\n\t\t\t\t\tclli.max_pic_average_light_level = gf_bs_read_int(bs, 16);\n\t\t\t\t\tgf_bs_del(bs);\n\t\t\t\t}\n\t\t\t\tif (p2) {\n\t\t\t\t\tbs = gf_bs_new(p2->value.data.ptr, p2->value.data.size, GF_BITSTREAM_READ);\n\n\t\t\t\t\tfor(u32 c=0;c<3;c++) {\n\t\t\t\t\t\tmdcv.display_primaries[c].x = gf_bs_read_int(bs, 16);\n\t\t\t\t\t\tmdcv.display_primaries[c].y = gf_bs_read_int(bs, 16);\n\t\t\t\t\t}\n\t\t\t\t\tmdcv.white_point_x = gf_bs_read_int(bs, 16);\n\t\t\t\t\tmdcv.white_point_y = gf_bs_read_int(bs, 16);\n\t\t\t\t\tmdcv.max_display_mastering_luminance = gf_bs_read_int(bs, 32);\n\t\t\t\t\tmdcv.min_display_mastering_luminance = gf_bs_read_int(bs, 32);\n\t\t\t\t\tgf_bs_del(bs);\n\t\t\t\t}\n\t\t\t\tgf_isom_set_high_dynamic_range_info(ctx->file, tkw->track_num, tkw->stsd_idx, p2 ? &mdcv : NULL, p ? &clli : NULL);\n\t\t\t}\n\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DOLBY_VISION);\n\t\t\tif (p) {\n\t\t\t\tGF_BitStream *bs = gf_bs_new(p->value.data.ptr, p->value.data.size, GF_BITSTREAM_READ);\n\t\t\t\tGF_DOVIDecoderConfigurationRecord *dvcc = gf_odf_dovi_cfg_read_bs(bs);\n\t\t\t\tgf_bs_del(bs);\n\t\t\t\tif (dvcc && tkw->xps_inband && (dvcc->dv_profile==8) && ctx->dvsingle) {\n\t\t\t\t\tGF_DOVIDecoderConfigurationRecord *dovi = gf_isom_dovi_config_get(ctx->file, tkw->track_num, tkw->stsd_idx);\n\t\t\t\t\tif (dovi) {\n\t\t\t\t\t\tif (dovi->dv_profile==5) {\n\t\t\t\t\t\t\tgf_odf_dovi_cfg_del(dvcc);\n\t\t\t\t\t\t\tdvcc = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_odf_dovi_cfg_del(dovi);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dvcc) {\n\t\t\t\t\tif (ctx->force_dv)\n\t\t\t\t\t\tdvcc->force_dv = 1;\n\n\t\t\t\t\tgf_isom_set_dolby_vision_profile(ctx->file, tkw->track_num, tkw->stsd_idx, dvcc);\n\n\t\t\t\t\tif (!dvcc->bl_present_flag) {\n\t\t\t\t\t\tu32 ref_id = 0;\n\n\t\t\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DEPENDENCY_ID);\n\t\t\t\t\t\tif (p) ref_id = p->value.uint;\n\t\t\t\t\t\tfor (i=0; i<gf_list_count(ctx->tracks); i++) {\n\t\t\t\t\t\t\tTrackWriter *tkw_base = gf_list_get(ctx->tracks, i);\n\t\t\t\t\t\t\tif (tkw_base == tkw) continue;\n\t\t\t\t\t\t\tif (tkw->codecid!=tkw_base->codecid) continue;\n\t\t\t\t\t\t\tif (ref_id) {\n\t\t\t\t\t\t\t\tp = gf_filter_pid_get_property(tkw_base->ipid, GF_PROP_PID_ID);\n\t\t\t\t\t\t\t\tif (!p || (p->value.uint!=ref_id)) continue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tref_id = gf_isom_get_track_id(ctx->file, tkw_base->track_num);\n\t\t\t\t\t\t\tgf_isom_set_track_reference(ctx->file, tkw->track_num, GF_4CC('v','d','e','p'), ref_id);\n\n\t\t\t\t\t\t\t//dolby requires seperate moof for each track fragment for base and el\n\t\t\t\t\t\t\tif (ctx->store>=MP4MX_MODE_FRAG) {\n\t\t\t\t\t\t\t\tctx->straf = GF_TRUE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tgf_odf_dovi_cfg_del(dvcc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//default for old arch\n\t\telse if (force_tk_layout\n\t\t\t|| (use_m4sys && (tkw->stream_type==GF_STREAM_VISUAL) && !width && !height)\n\t\t)  {\n\t\t\tgf_isom_set_track_layout_info(ctx->file, tkw->track_num, 320<<16, 240<<16, 0, 0, 0);\n\t\t}\n\n\t\tif (lang_name) gf_isom_set_media_language(ctx->file, tkw->track_num, (char*)lang_name);\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_STSD_TEMPLATE);\n\t\tif (ctx->tktpl && p && p->value.data.ptr) {\n\t\t\tgf_isom_update_sample_description_from_template(ctx->file, tkw->track_num, tkw->stsd_idx, p->value.data.ptr, p->value.data.size);\n\t\t}\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CHAP_TIMES);\n\t\tconst GF_PropertyValue *p2 = gf_filter_pid_get_property(pid, GF_PROP_PID_CHAP_NAMES);\n\t\tif (p && p2 && (p->value.uint_list.nb_items == p2->value.string_list.nb_items)) {\n\t\t\tBool add_chap=GF_FALSE;\n\t\t\tBool add_tk=GF_FALSE;\n\t\t\tu32 trak_di=0;\n\t\t\tif ((ctx->chapm==MP4MX_CHAPM_BOTH) || (ctx->chapm==MP4MX_CHAPM_UDTA)) {\n\t\t\t\tgf_isom_remove_chapter(ctx->file, 0, 0);\n\t\t\t\tadd_chap = GF_TRUE;\n\t\t\t}\n\t\t\tif (((ctx->chapm==MP4MX_CHAPM_BOTH) || (ctx->chapm==MP4MX_CHAPM_TRACK))\n\t\t\t\t&& !ctx->chap_track_num\n\t\t\t) {\n\t\t\t\tGF_FontRecord frec;\n\t\t\t\tGF_TextSampleDescriptor txtdesc;\n\t\t\t\tctx->chap_track_num = gf_isom_new_track(ctx->file, 0xFFFE, GF_ISOM_MEDIA_TEXT, 1000);\n\t\t\t\tgf_isom_set_track_flags (ctx->file, ctx->chap_track_num, GF_ISOM_TK_IN_MOVIE|GF_ISOM_TK_IN_PREVIEW, GF_ISOM_TKFLAGS_SET);\n\t\t\t\t//move chapter track last\n\t\t\t\tgf_isom_set_track_index(ctx->file, ctx->chap_track_num, 0xFFFE, mp4mux_track_reorder, ctx);\n\t\t\t\tmemset(&txtdesc, 0, sizeof(GF_TextSampleDescriptor));\n\t\t\t\ttxtdesc.font_count = 1;\n\t\t\t\ttxtdesc.fonts = &frec;\n\t\t\t\tfrec.fontName = \"SANS\";\n\t\t\t\tfrec.fontID=1;\n\t\t\t\ttxtdesc.default_style.fontID=1;\n\t\t\t\ttxtdesc.default_style.font_size = 32;\n\t\t\t\t//txtdesc.default_style.text_color = 0xFFFFFFFF;\n\t\t\t\t//txtdesc.horiz_justif = 1;\n\t\t\t\t//txtdesc.vert_justif = (s8) -1;\t/*bottom of scene*/\n\n\t\t\t\tgf_isom_new_text_description(ctx->file, ctx->chap_track_num, &txtdesc, NULL, NULL, &trak_di);\n\t\t\t\tadd_tk = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (add_tk || add_chap) {\n\t\t\t\tu32 j;\n\t\t\t\tu64 maxts = (ctx->dur.num && ctx->dur.den) ? gf_timestamp_rescale(ctx->dur.num, ctx->dur.den, 1000) : 0;\n\t\t\t\tfor (j=0; j<p->value.uint_list.nb_items; j++) {\n\t\t\t\t\tu32 start_time = p->value.uint_list.vals[j];\n\t\t\t\t\tif (ctx->start > start_time) {\n\t\t\t\t\t\tif (j+1 < p->value.uint_list.nb_items) {\n\t\t\t\t\t\t\tu64 next = p->value.uint_list.vals[j+1];\n\t\t\t\t\t\t\tif (ctx->start>=next)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (start_time > (u32) ctx->start) start_time -= (u32) ctx->start;\n\t\t\t\t\t\telse start_time=0;\n\t\t\t\t\t}\n\t\t\t\t\tif (maxts && (maxts<=start_time))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tif (add_chap) {\n\t\t\t\t\t\tgf_isom_add_chapter(ctx->file, 0, start_time, p2->value.string_list.vals[j]);\n\t\t\t\t\t}\n\t\t\t\t\tif (add_tk) {\n\t\t\t\t\t\tGF_TextSample tx;\n\t\t\t\t\t\tmemset(&tx, 0, sizeof(tx));\n\t\t\t\t\t\ttx.text = p2->value.string_list.vals[j];\n\t\t\t\t\t\ttx.len = (u32) strlen(p2->value.string_list.vals[j])+1;\n\t\t\t\t\t\tGF_ISOSample *samp = gf_isom_text_to_sample(&tx);\n\t\t\t\t\t\tsamp->DTS = start_time;\n\t\t\t\t\t\tsamp->IsRAP = 1;\n\n\t\t\t\t\t\t//force fist chapter to start at 0\n\t\t\t\t\t\tif (!j && samp->DTS) {\n\t\t\t\t\t\t\tsamp->DTS = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_add_sample(ctx->file, ctx->chap_track_num, trak_di, samp);\n\t\t\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((ctx->chapm==MP4MX_CHAPM_BOTH) || (ctx->chapm==MP4MX_CHAPM_TRACK)) {\n\t\t\t\tgf_isom_set_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_CHAP, gf_isom_get_track_id(ctx->file, ctx->chap_track_num));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tkw->is_encrypted) {\n\t\ttkw->cenc_ki = gf_filter_pid_get_property(pid, GF_PROP_PID_CENC_KEY_INFO);\n\t\tif (tkw->cenc_ki && ((tkw->cenc_ki->type != GF_PROP_DATA) || !gf_cenc_validate_key_info(tkw->cenc_ki->value.data.ptr, tkw->cenc_ki->value.data.size))\n\t\t) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Invalid CENC key info\\n\"));\n\t\t\ttkw->cenc_ki = NULL;\n\t\t}\n\n\t\ttkw->constant_IV_size = 0;\n\t\tif (tkw->cenc_ki && tkw->cenc_ki->value.data.ptr) {\n\t\t\ttkw->cenc_multikey = tkw->cenc_ki->value.data.ptr[0] ? GF_TRUE : GF_FALSE;\n\n\t\t\tif (!tkw->cenc_ki->value.data.ptr[3])\n\t\t\t\ttkw->constant_IV_size = !tkw->cenc_ki->value.data.ptr[20];\n\n\t\t\ttkw->cenc_key_info_crc = gf_crc_32(tkw->cenc_ki->value.data.ptr, tkw->cenc_ki->value.data.size);\n\t\t}\n\t}\n\n\tif (is_true_pid) {\n\t\tconst GF_PropertyValue *ster = gf_filter_pid_get_property(pid, GF_PROP_PID_STEREO_TYPE);\n\t\tconst GF_PropertyValue *proj = gf_filter_pid_get_property(pid, GF_PROP_PID_PROJECTION_TYPE);\n\t\tconst GF_PropertyValue *pose = gf_filter_pid_get_property(pid, GF_PROP_PID_VR_POSE);\n\n\t\tif (ster || proj) {\n\t\t\tGF_ISOM_Y3D_Info yt3d;\n\t\t\tmemset(&yt3d, 0, sizeof(GF_ISOM_Y3D_Info));\n\t\t\tyt3d.projection_type = proj ? proj->value.uint : 0;\n\t\t\tyt3d.stereo_type = ster ? ster->value.uint : 0;\n\t\t\tif (pose) {\n\t\t\t\tyt3d.pose_present = GF_TRUE;\n\t\t\t\tyt3d.yaw = pose->value.vec3i.x;\n\t\t\t\tyt3d.pitch = pose->value.vec3i.y;\n\t\t\t\tyt3d.roll = pose->value.vec3i.z;\n\t\t\t\tyt3d.stereo_type = ster ? ster->value.uint : 0;\n\t\t\t}\n\t\t\tif (yt3d.projection_type==GF_PROJ360_CUBE_MAP) {\n\t\t\t\tproj = gf_filter_pid_get_property(pid, GF_PROP_PID_CUBE_MAP_PAD);\n\t\t\t\tyt3d.padding = proj ? proj->value.uint : 0;\n\t\t\t}\n\t\t\telse if (yt3d.projection_type==GF_PROJ360_EQR) {\n\t\t\t\tproj = gf_filter_pid_get_property(pid, GF_PROP_PID_EQR_CLAMP);\n\t\t\t\tif (proj) {\n\t\t\t\t\tyt3d.top = proj->value.vec4i.x;\n\t\t\t\t\tyt3d.bottom = proj->value.vec4i.y;\n\t\t\t\t\tyt3d.left = proj->value.vec4i.z;\n\t\t\t\t\tyt3d.right = proj->value.vec4i.w;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_isom_set_y3d_info(ctx->file, tkw->track_num, tkw->stsd_idx, &yt3d);\n\t\t}\n\t}\n\n\n\tif (is_true_pid && ctx->importer && !tkw->import_msg_header_done) {\n#ifndef GPAC_DISABLE_LOG\n\t\tconst char *dst_type = tkw->is_item ? \"Item Importing\" : \"Track Importing\";\n#endif\n\t\ttkw->import_msg_header_done = GF_TRUE;\n\t\tif (!imp_name) imp_name = comp_name;\n\t\tif (sr) {\n\t\t\tif (nb_chan) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s - SampleRate %d Num Channels %d\\n\", dst_type, imp_name, sr, nb_chan));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s - SampleRate %d\\n\", dst_type, imp_name, sr));\n\t\t\t}\n\t\t} else if (is_text_subs) {\n\t\t\tif (txt_fsize || txt_font) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s - Text track %d x %d font %s (size %d) layer %d\\n\", dst_type, imp_name, width, height, txt_font ? txt_font : \"unspecified\", txt_fsize, z_order));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s - Text track %d x %d layer %d\\n\", dst_type, imp_name, width, height, z_order));\n\n\t\t\t}\n\t\t} else if (width) {\n\t\t\tif (sar.den && sar.num) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s - Width %d Height %d FPS %d/%d SAR %d/%u\\n\", dst_type, imp_name, width, height, fps.num, fps.den, sar.num, sar.den));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s - Width %d Height %d FPS %d/%d\\n\", dst_type, imp_name, width, height, fps.num, fps.den));\n\t\t\t}\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s\\n\", dst_type, imp_name));\n\t\t}\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tif (tkw->svcc) {\n\t\t\tAVCState avc;\n\t\t\tmemset(&avc, 0, sizeof(AVCState));\n\t\t\tcount = gf_list_count(tkw->svcc->sequenceParameterSets);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_NALUFFParam *sl = gf_list_get(tkw->svcc->sequenceParameterSets, i);\n\t\t\t\tu8 nal_type = sl->data[0] & 0x1F;\n\t\t\t\tBool is_subseq = (nal_type == GF_AVC_NALU_SVC_SUBSEQ_PARAM) ? GF_TRUE : GF_FALSE;\n\t\t\t\ts32 ps_idx = gf_avc_read_sps(sl->data, sl->size, &avc, is_subseq, NULL);\n\t\t\t\tif (ps_idx>=0) {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"SVC Detected - SSPS ID %d - frame size %d x %d\\n\", ps_idx-GF_SVC_SSPS_ID_SHIFT, avc.sps[ps_idx].width, avc.sps[ps_idx].height ));\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\n\t}\n\tif (txt_font) gf_free(txt_font);\n\tif (!tkw->xps_inband || tkw->is_item) {\n\t\tif (tkw->svcc) {\n\t\t\tgf_odf_avc_cfg_del(tkw->svcc);\n\t\t\ttkw->svcc = NULL;\n\t\t}\n\t\tif (tkw->lvcc) {\n\t\t\tgf_odf_hevc_cfg_del(tkw->lvcc);\n\t\t\ttkw->lvcc = NULL;\n\t\t}\n\t} else if (needs_sample_entry || make_inband_headers) {\n\t\tmp4_mux_make_inband_header(ctx, tkw, GF_FALSE);\n\t\tif (ctx->pps_inband || tkw->xps_inband)\n\t\t\tmp4_mux_make_inband_header(ctx, tkw, GF_TRUE);\n\t}\n\n\ttkw->negctts_shift = 0;\n\ttkw->probe_min_ctts = GF_FALSE;\n\tif (is_true_pid && !tkw->nb_samples && !tkw->is_item) {\n\t\tBool use_negccts = GF_FALSE;\n\t\tBool remove_edits = GF_FALSE;\n\t\ts64 moffset=0;\n\t\tctx->config_timing = GF_TRUE;\n\t\tctx->update_report = GF_TRUE;\n\n\t\t//if we have an edit list (due to track template) only providing media offset, trash it\n\t\tif (!gf_isom_get_edit_list_type(ctx->file, tkw->track_num, &moffset)) {\n\t\t\tif (!gf_sys_old_arch_compat()) {\n\t\t\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\t\t\t} else {\n\t\t\t\t//old arch compat: if we had a simple edit list in source, keep dur and offset\n\t\t\t\t//and avoid rewriting it when recomputing edit for b-frames\n\t\t\t\tu64 etime, sdur;\n\t\t\t\tGF_ISOEditType etype;\n\t\t\t\tgf_isom_get_edit(ctx->file, tkw->track_num, 1, &etime, &sdur, &moffset, &etype);\n\t\t\t\tif (!etime && sdur) {\n\t\t\t\t\ttkw->imported_edit_sdur = sdur;\n\t\t\t\t\ttkw->imported_edit_offset = moffset;\n\t\t\t\t}\n\t\t\t\tremove_edits = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_FORCE_NEGCTTS);\n\t\tif (p && p->value.boolean) use_negccts = GF_TRUE;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DELAY);\n\t\tif (p) {\n\t\t\t//media skip\n\t\t\tif (p->value.longsint < 0) {\n\t\t\t\t//if cmf2, remove edits and use negctss\n\t\t\t\tif ((ctx->cmaf==MP4MX_CMAF_CMF2) && (tkw->stream_type==GF_STREAM_VISUAL)) {\n\t\t\t\t\tctx->ctmode = MP4MX_CT_NEGCTTS;\n\t\t\t\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\t\t\t\t\tuse_negccts = GF_TRUE;\n\t\t\t\t}\n\t\t\t\telse if ((ctx->ctmode==MP4MX_CT_NEGCTTS) && (tkw->stream_type==GF_STREAM_VISUAL)) {\n\t\t\t\t\tuse_negccts = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tif (remove_edits) {\n\t\t\t\t\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_set_edit(ctx->file, tkw->track_num, 0, 0, -p->value.longsint, GF_ISOM_EDIT_NORMAL);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//media delay\n\t\t\telse if (p->value.longsint > 0) {\n\t\t\t\t//if cmaf (whether cmfc or cmf2), remove edits and add delay to tfdt\n\t\t\t\tif (ctx->cmaf) {\n\t\t\t\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\t\t\t\t\ttkw->patch_tfdt = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\ts64 dur = gf_timestamp_rescale_signed(p->value.longsint, tkw->src_timescale, ctx->moovts);\n\t\t\t\t\ts64 diff_low = (s64) p->value.longuint - dur * tkw->src_timescale / ctx->moovts;\n\t\t\t\t\t//we are loosing precision, check if true value is closer to next representable value in movie timescale\n\t\t\t\t\tif (diff_low>0) {\n\t\t\t\t\t\ts64 diff_high = (dur+1) * tkw->src_timescale / ctx->moovts - (s64) p->value.longuint;\n\t\t\t\t\t\tif (diff_high < diff_low) dur++;\n\t\t\t\t\t}\n\t\t\t\t\tif (remove_edits) {\n\t\t\t\t\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\t\t\t\t\t}\n\t\t\t\t\tif (dur) {\n\t\t\t\t\t\tgf_isom_set_edit(ctx->file, tkw->track_num, 0, dur, 0, GF_ISOM_EDIT_EMPTY);\n\t\t\t\t\t\tgf_isom_set_edit(ctx->file, tkw->track_num, dur, 0, 0, GF_ISOM_EDIT_NORMAL);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttkw->ts_delay = (s32) p->value.longsint;\n\t\t} else if (tkw->stream_type==GF_STREAM_VISUAL) {\n\t\t\ttkw->probe_min_ctts = GF_TRUE;\n\t\t}\n\t\t//for old arch compatibility\n\t\telse if (remove_edits) {\n\t\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"reframer_rem_edits\");\n\t\t\tif (p && p->value.boolean) {\n\t\t\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\t\t\t}\n\t\t}\n\t\tif (use_negccts) {\n\t\t\tgf_isom_set_composition_offset_mode(ctx->file, tkw->track_num, GF_TRUE);\n\n\t\t\tif (!tkw->has_brands) {\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO4, GF_TRUE);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO1, GF_FALSE);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO2, GF_FALSE);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO3, GF_FALSE);\n\t\t\t}\n\n\t\t\ttkw->negctts_shift = (tkw->ts_delay<0) ? -tkw->ts_delay : 0;\n\t\t} else {\n\t\t\t//this will remove any cslg in the track due to template\n\t\t\tgf_isom_set_composition_offset_mode(ctx->file, tkw->track_num, GF_FALSE);\n\t\t}\n\n\t\tif (!ctx->noinit) {\n\t\t\tmp4_mux_set_tags(ctx, tkw);\n\t\t\tmp4_mux_set_udta(ctx, tkw);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nstatic GF_Err mp4_mux_flush_fragmented(GF_MP4MuxCtx *ctx);\n#endif\nstatic GF_Err mp4_mux_done(GF_MP4MuxCtx *ctx, Bool is_final);\n\nstatic GF_Err mp4_mux_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (is_remove) {\n\t\tTrackWriter *tkw = gf_filter_pid_get_udta(pid);\n\t\tif (tkw) {\n\t\t\tgf_list_del_item(ctx->tracks, tkw);\n\t\t\tgf_free(tkw);\n\t\t}\n\t\t//removing last pid\n\t\tif (ctx->opid && !gf_list_count(ctx->tracks)) {\n\t\t\tif (ctx->file) {\n\t\t\t\t//non-frag file, flush file\n\t\t\t\tif (!ctx->init_movie_done) {\n\t\t\t\t\tmp4_mux_done(ctx, GF_TRUE);\n\t\t\t\t}\n\t\t\t} else {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\twhile (ctx->flush_size) {\n\t\t\t\t\tGF_Err e = mp4_mux_flush_fragmented(ctx);\n\t\t\t\t\tif (e) break;\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t\t//delete output pid (to flush destruction of filter chain)\n\t\t\tgf_filter_pid_remove(ctx->opid);\n\t\t\tctx->opid = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\treturn mp4_mux_setup_pid(filter, pid, GF_TRUE);\n}\n\nstatic Bool mp4_mux_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (evt->base.on_pid && (evt->base.type==GF_FEVT_INFO_UPDATE) ) {\n\t\tTrackWriter *tkw = gf_filter_pid_get_udta(evt->base.on_pid);\n\t\tif (tkw) {\n\t\t\tGF_PropertyEntry *pe=NULL;\n\t\t\tconst GF_PropertyValue *p;\n\t\t\tp = gf_filter_pid_get_info(tkw->ipid, GF_PROP_PID_DOWN_BYTES, &pe);\n\t\t\tif (p) tkw->down_bytes = p->value.longuint;\n\n\t\t\tp = gf_filter_pid_get_info(tkw->ipid, GF_PROP_PID_DOWN_SIZE, &pe);\n\t\t\tif (p) tkw->down_size = p->value.longuint;\n\n\t\t\tgf_filter_release_property(pe);\n\t\t}\n\n\t\treturn GF_FALSE;\n\t}\n\tif (!evt->base.on_pid && (evt->base.type==GF_FEVT_STOP) ) {\n\t\tif (ctx->file && ctx->owns_mov) {\n\t\t\tmp4_mux_done(ctx, GF_TRUE);\n\t\t}\n\t}\n\tif (evt->base.on_pid && (evt->base.type==GF_FEVT_PLAY) ) {\n\t\tu32 i, count;\n\t\tGF_FilterEvent anevt;\n\t\tctx->force_play = GF_TRUE;\n\t\tif (evt->play.speed<0)\n\t\t\tctx->is_rewind = GF_TRUE;\n\n\t\tif (ctx->start == 0)\n\t\t\treturn GF_FALSE;\n\n\t\tcount = gf_list_count(ctx->tracks);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\t\tif (tkw->fake_track) continue;\n\n\t\t\tanevt.play = evt->play;\n\t\t\tgf_filter_pid_init_play_event(tkw->ipid, &anevt, ctx->start, 0, \"MP4Mux\");\n\t\t\tif (anevt.play.start_range > 0)\n\t\t\t\ttkw->wait_sap = GF_TRUE;\n\n\t\t\tgf_filter_pid_send_event(tkw->ipid, &anevt);\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\n\nenum\n{\n\tCENC_CONFIG=0,\n\tCENC_ADD_NORMAL,\n\tCENC_ADD_FRAG,\n};\n\nstatic void mp4_mux_cenc_insert_pssh(GF_MP4MuxCtx *ctx, TrackWriter *tkw, const GF_PropertyValue *pssh, u32 dyn_pssh_mode)\n{\n\tbin128 *keyIDs=NULL;\n\tu32 max_keys = 0;\n\tu32 i, nb_pssh;\n\tGF_PropertyValue _the_prop;\n\n\t//set pssh\n\tconst GF_PropertyValue *p=NULL;\n\n\t//only inject if pssh in packet\n\tif (dyn_pssh_mode==2) {\n\t\tGF_FilterPacket *pck;\n\t\t//nothing to inject\n\t\tif (!tkw->dyn_pssh) return;\n\t\tpck = gf_filter_pid_get_packet(tkw->ipid);\n\t\tif (pck) {\n\t\t\tpssh = gf_filter_pck_get_property(pck, GF_PROP_PID_CENC_PSSH);\n\t\t\t//change of dynamic pssh is pending, don't inject the old one\n\t\t\tif (pssh) return;\n\t\t}\n\t\t_the_prop.type = GF_PROP_DATA;\n\t\t_the_prop.value.data.ptr = tkw->dyn_pssh;\n\t\t_the_prop.value.data.size = tkw->dyn_pssh_len;\n\t\tp = &_the_prop;\n\t} else {\n\t\tif (pssh) {\n\t\t\tp = pssh;\n\t\t} else {\n\t\t\t//inject pssh from packet if any, or from PID (used for keyroll of master+leaf schemes)\n\t\t\tif (dyn_pssh_mode) {\n\t\t\t\tGF_FilterPacket *pck = gf_filter_pid_get_packet(tkw->ipid);\n\t\t\t\tif (pck) {\n\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PID_CENC_PSSH);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p)\n\t\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CENC_PSSH);\n\t\t}\n\t\tif (!p) return;\n\t}\n\n\tif (!ctx->bs_r) ctx->bs_r = gf_bs_new(p->value.data.ptr, p->value.data.size, GF_BITSTREAM_READ);\n\telse gf_bs_reassign_buffer(ctx->bs_r, p->value.data.ptr, p->value.data.size);\n\n\tnb_pssh = gf_bs_read_u32(ctx->bs_r);\n\tfor (i = 0; i < nb_pssh; i++) {\n\t\tu32 mode;\n\t\tbin128 sysID;\n\t\tu32 j, kid_count, version=0;\n\t\tchar *data;\n\t\tu32 len;\n\n\t\tgf_bs_read_data(ctx->bs_r, sysID, 16);\n\t\tversion = gf_bs_read_u32(ctx->bs_r);\n\t\tkid_count = version ? gf_bs_read_u32(ctx->bs_r) : 0;\n\n\t\tif (kid_count>=max_keys) {\n\t\t\tmax_keys = kid_count;\n\t\t\tkeyIDs = gf_realloc(keyIDs, sizeof(bin128)*max_keys);\n\t\t}\n\t\tfor (j=0; j<kid_count; j++) {\n\t\t\tgf_bs_read_data(ctx->bs_r, keyIDs[j], 16);\n\t\t}\n\t\tlen = gf_bs_read_u32(ctx->bs_r);\n\t\tdata = p->value.data.ptr + gf_bs_get_position(ctx->bs_r);\n\n\t\tif (tkw->is_item) mode = 2;\n\t\telse if (tkw->scheme_type==GF_ISOM_PIFF_SCHEME) mode = 1;\n\t\telse mode = 0;\n\n\t\tgf_cenc_set_pssh(ctx->file, sysID, version, kid_count, keyIDs, data, len, mode);\n\t\tgf_bs_skip_bytes(ctx->bs_r, len);\n\t\tif (gf_bs_is_overflow(ctx->bs_r))\n\t\t\tbreak;\n\t}\n\tif (keyIDs) gf_free(keyIDs);\n\n\n\tif (pssh) {\n\t\tif (tkw->dyn_pssh) gf_free(tkw->dyn_pssh);\n\t\ttkw->dyn_pssh = gf_malloc(sizeof(u8) * pssh->value.data.size);\n\t\tif (!tkw->dyn_pssh) return;\n\t\tmemcpy(tkw->dyn_pssh, pssh->value.data.ptr, sizeof(u8) * pssh->value.data.size);\n\t\ttkw->dyn_pssh_len = pssh->value.data.size;\n\t}\n\n}\n\nstatic GF_Err mp4_mux_cenc_update(GF_MP4MuxCtx *ctx, TrackWriter *tkw, GF_FilterPacket *pck, u32 act_type, u32 pck_size, u32 injected_hdr_size)\n{\n\tconst GF_PropertyValue *p;\n\tGF_Err e;\n\tBool pck_is_encrypted;\n\tu32 IV_size=0;\n\tu8 *fake_sai = NULL;\n\tu8 *sai = NULL;\n\tu32 sai_size = 0;\n\tBool needs_seig = GF_FALSE;\n\tu32 sample_num;\n\n\tif (tkw->cenc_state == CENC_SETUP_ERROR)\n\t\treturn GF_SERVICE_ERROR;\n\n\n\tif (pck) {\n\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_CENC_SAI);\n\t\tif (p) {\n\t\t\tsai = p->value.data.ptr;\n\t\t\tsai_size = p->value.data.size;\n\t\t}\n\t}\n\n\n\t//initial setup\n\tif (tkw->cenc_state==CENC_NEED_SETUP) {\n\t\tu32 scheme_type=0;\n\t\tu32 scheme_version=0;\n\t\tu32 cenc_stsd_mode=0;\n\t\tu32 container_type = GF_ISOM_BOX_TYPE_SENC;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_PROTECTION_SCHEME_TYPE);\n\t\tif (p) scheme_type = p->value.uint;\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_PROTECTION_SCHEME_VERSION);\n\t\tif (p) scheme_version = p->value.uint;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CENC_STSD_MODE);\n\t\tif (p) cenc_stsd_mode = p->value.uint;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ENCRYPTED);\n\t\tif (p) pck_is_encrypted = p->value.boolean;\n\t\telse pck_is_encrypted = GF_FALSE;\n\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CENC_STORE);\n\t\tif (p && p->value.uint) container_type = p->value.uint;\n\n\t\ttkw->clear_stsd_idx = 0;\n\t\tif (cenc_stsd_mode) {\n\t\t\tu32 clone_stsd_idx;\n\t\t\te = gf_isom_clone_sample_description(ctx->file, tkw->track_num, ctx->file, tkw->track_num, tkw->stsd_idx, NULL, NULL, &clone_stsd_idx);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to clone sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\t//current stsd reused, use clone one for encrypted stsd\n\t\t\tif (tkw->reused_stsd) {\n\t\t\t\ttkw->clear_stsd_idx = tkw->stsd_idx;\n\t\t\t\ttkw->stsd_idx = clone_stsd_idx;\n\t\t\t}\n\t\t\t//before\n\t\t\telse if (cenc_stsd_mode==1) {\n\t\t\t\ttkw->clear_stsd_idx = tkw->stsd_idx;\n\t\t\t\ttkw->stsd_idx = clone_stsd_idx;\n\t\t\t}\n\t\t\t//after\n\t\t\telse {\n\t\t\t\ttkw->clear_stsd_idx = clone_stsd_idx;\n\t\t\t}\n\t\t}\n\t\ttkw->def_crypt_byte_block = tkw->crypt_byte_block;\n\t\ttkw->def_skip_byte_block = tkw->skip_byte_block;\n\n\t\ttkw->cenc_state = CENC_SETUP_DONE;\n\t\ttkw->def_cenc_key_info_crc = tkw->cenc_key_info_crc;\n\t\tif (tkw->cenc_ki) {\n\t\t\te = gf_isom_set_cenc_protection(ctx->file, tkw->track_num, tkw->stsd_idx, scheme_type, scheme_version, pck_is_encrypted, tkw->def_crypt_byte_block, tkw->def_skip_byte_block, tkw->cenc_ki->value.data.ptr, tkw->cenc_ki->value.data.size);\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Missing CENC Key config, cannot mux\\n\"));\n\t\t\ttkw->cenc_state = CENC_SETUP_ERROR;\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to setup CENC information: %s\\n\", gf_error_to_string(e) ));\n\t\t\ttkw->cenc_state = CENC_SETUP_ERROR;\n\t\t\treturn e;\n\t\t}\n\n\t\t//purge duplicates\n\t\tu32 k, nb_sdesc = gf_isom_get_sample_description_count(ctx->file, tkw->track_num);\n\t\tif (nb_sdesc>2) {\n\t\t\tfor (k=0; k<nb_sdesc; k++) {\n\t\t\t\tif (k+1 == tkw->stsd_idx) continue;\n\n\t\t\t\tif (gf_isom_is_same_sample_description(ctx->file, tkw->track_num, tkw->stsd_idx, ctx->file, tkw->track_num, k+1) ) {\n\t\t\t\t\tgf_isom_remove_stream_description(ctx->file, tkw->track_num, tkw->stsd_idx);\n\t\t\t\t\ttkw->stsd_idx = k+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((ctx->psshs == MP4MX_PSSH_MOOV) || (ctx->psshs == MP4MX_PSSH_BOTH))\n\t\t\tmp4_mux_cenc_insert_pssh(ctx, tkw, NULL, 0);\n\n\t\tif (!tkw->has_brands && (scheme_type==GF_ISOM_OMADRM_SCHEME))\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_OPF2, GF_TRUE);\n\n\t\tif (container_type) {\n\t\t\tif (container_type==GF_ISOM_BOX_UUID_PSEC) {\n\t\t\t\te = gf_isom_piff_allocate_storage(ctx->file, tkw->track_num, 0, 0, NULL);\n\t\t\t} else {\n\t\t\t\te = gf_isom_cenc_allocate_storage(ctx->file, tkw->track_num);\n\t\t\t}\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to setup CENC storage: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\ttkw->cenc_state = CENC_SETUP_ERROR;\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t}\n\tif (act_type==CENC_CONFIG) return GF_OK;\n\n\tpck_is_encrypted = GF_FALSE;\n\tif (pck)\n\t\tpck_is_encrypted = gf_filter_pck_get_crypt_flags(pck);\n\n\t//!! tkw->nb_samples / tkw->samples_in_frag not yet incremented !!\n\tif (act_type == CENC_ADD_FRAG) {\n\t\tsample_num = tkw->samples_in_frag + 1;\n\n\t\tif (ctx->cmaf) {\n\t\t\tif (!tkw->samples_in_frag) {\n\t\t\t\ttkw->cenc_frag_protected = pck_is_encrypted;\n\t\t\t} else {\n\t\t\t\tif (tkw->cenc_frag_protected != pck_is_encrypted) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] CMAF forbids mixing protected and unprotected samples in a single fragment, please re-encrypt or change target segment duration\\n\"));\n\t\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsample_num = tkw->nb_samples + 1;\n\t}\n\tif (!pck_is_encrypted) {\n\t\tif (tkw->clear_stsd_idx) {\n\t\t\tif (act_type==CENC_ADD_FRAG) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\treturn gf_isom_fragment_set_cenc_sai(ctx->file, tkw->track_id, NULL, 0, GF_FALSE, ctx->saio32, tkw->cenc_multikey);\n#else\n\t\t\t\treturn GF_NOT_SUPPORTED;\n#endif\n\t\t\t} else {\n\t\t\t\treturn gf_isom_track_cenc_add_sample_info(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_SENC, NULL, 0, tkw->cenc_subsamples, ctx->saio32, tkw->cenc_multikey);\n\t\t\t}\n\t\t} else {\n\t\t\tchar dumb_key[20];\n\t\t\tmemset(dumb_key, 0, 20); //dumb key, IV size 0, not protected\n\t\t\te = gf_isom_set_sample_cenc_group(ctx->file, tkw->track_num, sample_num, GF_FALSE, 0, 0, dumb_key, 20);\n\t\t\tIV_size = 0;\n\t\t\ttkw->has_seig = GF_TRUE;\n\t\t}\n\t} else {\n\t\n\t\te = GF_OK;\n\t\t//multikey ALWAYS uses seig\n\t\tif (tkw->cenc_ki->value.data.ptr[0])\n\t\t\tneeds_seig = GF_TRUE;\n\t\telse if (tkw->def_crypt_byte_block != tkw->crypt_byte_block)\n\t\t\tneeds_seig = GF_TRUE;\n\t\telse if (tkw->def_skip_byte_block != tkw->skip_byte_block)\n\t\t\tneeds_seig = GF_TRUE;\n\t\telse if (tkw->def_cenc_key_info_crc != tkw->cenc_key_info_crc)\n\t\t\tneeds_seig = GF_TRUE;\n\n\t\tif (needs_seig) {\n\t\t\te = gf_isom_set_sample_cenc_group(ctx->file, tkw->track_num, sample_num, 1, tkw->crypt_byte_block, tkw->skip_byte_block, tkw->cenc_ki->value.data.ptr, tkw->cenc_ki->value.data.size);\n\t\t\ttkw->has_seig = GF_TRUE;\n\t\t} else if (tkw->has_seig) {\n\t\t\te = gf_isom_set_sample_cenc_default_group(ctx->file, tkw->track_num, sample_num);\n\t\t}\n\t}\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set sample encryption group entry: %s)\\n\", gf_error_to_string(e) ));\n\t\treturn e;\n\t}\n\n\tp = gf_filter_pck_get_property(pck, GF_PROP_PID_CENC_PSSH);\n\tif (p && (p->type == GF_PROP_DATA) && p->value.data.ptr) {\n\t\tif (ctx->store>=MP4MX_MODE_FRAG) {\n\t\t\tmp4_mux_cenc_insert_pssh(ctx, tkw, p, 0);\n\t\t} else {\n\t\t\tgf_isom_set_sample_group_description(ctx->file, tkw->track_num, sample_num, GF_4CC('P','S','S','H'), 0, p->value.data.ptr, p->value.data.size, 0);\n\t\t}\n\t}\n\n\tif (!sai) {\n\t\tif (tkw->constant_IV_size && !tkw->cenc_subsamples)\n\t\t\treturn GF_OK;\n\n\t\tif (IV_size) {\n\t\t\t//generate clear SAI data with a non-0 IV\n\t\t\tu32 olen = pck_size;\n\t\t\tGF_BitStream *bs = gf_bs_new(NULL, 9, GF_BITSTREAM_WRITE);\n\t\t\tif (tkw->cenc_multikey) {\n\t\t\t\tgf_bs_write_u16(bs, 0);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_long_int(bs, 0, IV_size*8);\n\t\t\t}\n\n\t\t\tif (tkw->cenc_subsamples) {\n\t\t\t\tu32 i;\n\t\t\t\tu32 subsample_count = 1;\n\t\t\t\twhile (olen>0xFFFF) {\n\t\t\t\t\tolen -= 0xFFFF;\n\t\t\t\t\tsubsample_count ++;\n\t\t\t\t}\n\t\t\t\tgf_bs_write_u16(bs, subsample_count);\n\t\t\t\tolen = pck_size;\n\t\t\t\tfor (i = 0; i < subsample_count; i++) {\n\t\t\t\t\tu32 clear_size;\n\t\t\t\t\tif (olen<0xFFFF) {\n\t\t\t\t\t\tclear_size = olen;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclear_size = 0xFFFF;\n\t\t\t\t\t\tolen -= 0xFFFF;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tkw->cenc_multikey)\n\t\t\t\t\t\tgf_bs_write_u16(bs, 0);\n\t\t\t\t\tgf_bs_write_u16(bs, clear_size);\n\t\t\t\t\tgf_bs_write_u32(bs, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_bs_get_content(bs, &fake_sai, &sai_size);\n\t\t\tgf_bs_del(bs);\n\t\t\tsai = fake_sai;\n\t\t}\n\t}\n\t//we injected xPS at the beginning of the sample (AVC/HEVC/VVC), we must patch the first subsample\n\t//of SAI data\n\telse if (injected_hdr_size) {\n\t\tu32 offset = 0;\n\t\tu32 first_sub_clear, sub_count_size;\n\t\tu8 *sai_d;\n\t\tu8 key_info_get_iv_size(const u8 *key_info, u32 nb_keys, u32 idx, u8 *const_iv_size, const u8 **const_iv);\n\n\t\tassert(tkw->cenc_subsamples);\n\n\t\t//multi-key skip all IV inits\n\t\tif (tkw->cenc_ki->value.data.ptr[0]) {\n\t\t\tu32 remain;\n\t\t\tu32 j, nb_iv_init = sai[0];\n\t\t\tnb_iv_init <<= 8;\n\t\t\tnb_iv_init |= sai[1];\n\t\t\tu8 *sai_p = sai + 2;\n\t\t\tremain = sai_size-2;\n\n\t\t\tfor (j=0; j<nb_iv_init; j++) {\n\t\t\t\tu32 mk_iv_size;\n\t\t\t\tu32 idx = sai_p[0];\n\t\t\t\tidx<<=8;\n\t\t\t\tidx |= sai_p[1];\n\n\t\t\t\tmk_iv_size = key_info_get_iv_size(tkw->cenc_ki->value.data.ptr, tkw->cenc_ki->value.data.size, idx, NULL, NULL);\n\t\t\t\tmk_iv_size += 2; //idx\n\t\t\t\tif (mk_iv_size > remain) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Invalid multi-key CENC SAI, cannot modify first subsample !\\n\"));\n\t\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t}\n\t\t\t\tsai_p += mk_iv_size;\n\t\t\t\tremain -= mk_iv_size;\n\t\t\t\tif (remain && (remain<=2)) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Invalid multi-key CENC SAI, cannot modify first subsample !\\n\"));\n\t\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t}\n\t\t\t}\n\t\t\toffset = (u32) (sai_p - sai);\n\t\t\tsub_count_size = 4; //32bit sub count\n\n\t\t} else {\n\t\t\toffset = key_info_get_iv_size(tkw->cenc_ki->value.data.ptr, tkw->cenc_ki->value.data.size, 1, NULL, NULL);\n\t\t\tsub_count_size = 2; //16bit sub count\n\t\t}\n\t\tif (sai_size < offset + sub_count_size + 6) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Invalid CENC SAI !\\n\"));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\t//get size of first subsample\n\t\toffset += sub_count_size;\n\t\tsai_d = sai + offset;\n\t\tfirst_sub_clear = sai_d[0];\n\t\tfirst_sub_clear<<=8;\n\t\tfirst_sub_clear |= sai_d[1];\n\t\tfirst_sub_clear += injected_hdr_size;\n\t\t//fits, only patch first subsample size\n\t\tif (first_sub_clear < 0xFFFF) {\n\t\t\tfake_sai = gf_malloc(sizeof(u8) * sai_size);\n\t\t\tif (!fake_sai) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(fake_sai, sai, sizeof(u8) * sai_size);\n\t\t\tsai_d = fake_sai + offset;\n\t\t\tsai_d[0] = (first_sub_clear>>8) & 0xFF;\n\t\t\tsai_d[1] = (first_sub_clear) & 0xFF;\n\t\t\tsai = fake_sai;\n\t\t}\n\t\t//injected header size does not fit in first subsample, add a new subsample\n\t\telse {\n\t\t\tfake_sai = gf_malloc(sizeof(u8) * (sai_size+6));\n\t\t\tif (!fake_sai) return GF_OUT_OF_MEM;\n\t\t\t//copy till start of first subsample (including subsample_count)\n\t\t\tmemcpy(fake_sai, sai, sizeof(u8) * offset);\n\t\t\t//copy all subsamples\n\t\t\tmemcpy(fake_sai+offset+6, sai+offset, sizeof(u8) * (sai_size - offset) );\n\t\t\t//insert subsample\n\t\t\tsai_d = fake_sai + offset;\n\t\t\tsai_d[0] = (injected_hdr_size>>8) & 0xFF;\n\t\t\tsai_d[1] = (injected_hdr_size) & 0xFF;\n\t\t\tsai_d[2] = sai_d[3] = sai_d[4] = sai_d[5] = 0;\n\t\t\t//update subsample count\n\t\t\tsai_d = fake_sai + offset - sub_count_size;\n\t\t\tif (sub_count_size==2) {\n\t\t\t\tu32 cnt = ((u32) sai_d[0]) << 8 | (u32) sai_d[1];\n\t\t\t\tcnt++;\n\t\t\t\tsai_d[0] = (cnt>>8) & 0xFF;\n\t\t\t\tsai_d[1] = (cnt) & 0xFF;\n\t\t\t} else {\n\t\t\t\tu32 cnt = GF_4CC( sai_d[0], sai_d[1], sai_d[2], sai_d[3]);\n\t\t\t\tcnt++;\n\t\t\t\tsai_d[0] = (cnt>>24) & 0xFF;\n\t\t\t\tsai_d[1] = (cnt>>16) & 0xFF;\n\t\t\t\tsai_d[2] = (cnt>>8) & 0xFF;\n\t\t\t\tsai_d[3] = (cnt) & 0xFF;\n\t\t\t}\n\t\t\tsai = fake_sai;\n\t\t\tsai_size += 6;\n\t\t}\n\t}\n\n\tif (act_type==CENC_ADD_FRAG) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (pck_is_encrypted) {\n\t\t\te = gf_isom_fragment_set_cenc_sai(ctx->file, tkw->track_id, sai, sai_size, tkw->cenc_subsamples, ctx->saio32, tkw->cenc_multikey);\n\t\t} else {\n\t\t\te = gf_isom_fragment_set_cenc_sai(ctx->file, tkw->track_id, NULL, 0, GF_FALSE, ctx->saio32, tkw->cenc_multikey);\n\t\t}\n#else\n\t\te = GF_NOT_SUPPORTED;\n#endif\n\t} else {\n\t\tif (sai) {\n\t\t\te = gf_isom_track_cenc_add_sample_info(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_SENC, sai, sai_size, tkw->cenc_subsamples, ctx->saio32, tkw->cenc_multikey);\n\t\t} else if (!pck_is_encrypted) {\n\t\t\te = gf_isom_track_cenc_add_sample_info(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_SENC, NULL, 0, tkw->cenc_subsamples, ctx->saio32, tkw->cenc_multikey);\n\t\t}\n\t}\n\tif (fake_sai) gf_free(fake_sai);\n\treturn e;\n}\n\nGF_FilterSAPType mp4_mux_get_sap(GF_MP4MuxCtx *ctx, GF_FilterPacket *pck)\n{\n\tGF_FilterSAPType sap = gf_filter_pck_get_sap(pck);\n\tif (!sap) return sap;\n\tif (ctx->forcesync) return GF_FILTER_SAP_1;\n\treturn sap;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nGF_Err gf_isom_fragment_add_sample_ex(GF_ISOFile *movie, GF_ISOTrackID TrackID, const GF_ISOSample *sample, u32 DescIndex,\n                                   u32 Duration, u8 PaddingBits, u16 DegradationPriority, Bool redundant_coding, void **ref, u32 ref_offset);\nGF_Err gf_isom_fragment_append_data_ex(GF_ISOFile *movie, GF_ISOTrackID TrackID, u8 *data, u32 data_size, u8 PaddingBits, void **ref, u32 ref_offset);\n#endif\n\nstatic GF_Err mp4_mux_process_sample(GF_MP4MuxCtx *ctx, TrackWriter *tkw, GF_FilterPacket *pck, Bool for_fragment)\n{\n\tGF_Err e=GF_OK;\n\tu64 cts, prev_dts;\n\tu32 prev_size=0;\n\tu32 duration = 0;\n\tu32 timescale = 0;\n\tconst GF_PropertyValue *subs;\n\tGF_FilterSAPType sap_type;\n\tu32 insert_subsample_dsi_size = 0;\n\tu32 first_nal_is_audelim = GF_FALSE;\n\tu32 sample_desc_index = tkw->stsd_idx;\n\tBool sample_timing_ok = GF_TRUE;\n\n\ttimescale = gf_filter_pck_get_timescale(pck);\n\n\tprev_dts = tkw->nb_samples ? tkw->sample.DTS : GF_FILTER_NO_TS;\n\tprev_size = tkw->sample.dataLength;\n\ttkw->sample.CTS_Offset = 0;\n\tif (gf_filter_pck_get_frame_interface(pck)) {\n\t\ttkw->dgl_copy = gf_filter_pck_dangling_copy(pck, tkw->dgl_copy);\n\t\tif (!tkw->dgl_copy) return GF_IO_ERR;\n\t\ttkw->sample.data = (char *)gf_filter_pck_get_data(tkw->dgl_copy, &tkw->sample.dataLength);\n\t} else {\n\t\ttkw->sample.data = (char *)gf_filter_pck_get_data(pck, &tkw->sample.dataLength);\n\t}\n\n\tctx->update_report = GF_TRUE;\n\tctx->total_bytes_in += tkw->sample.dataLength;\n\tctx->total_samples++;\n\n\ttkw->sample.DTS = gf_filter_pck_get_dts(pck);\n\tcts = gf_filter_pck_get_cts(pck);\n\n\tif (tkw->sample.DTS == GF_FILTER_NO_TS) {\n\t\tif (cts == GF_FILTER_NO_TS) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Sample with no DTS/CTS, cannot add (last DTS \"LLU\", last size %d)\\n\", prev_dts, prev_size ));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t} else {\n\t\t\tu32 min_pck_dur = gf_filter_pid_get_min_pck_duration(tkw->ipid);\n\t\t\tif (min_pck_dur) {\n\t\t\t\ttkw->sample.DTS = prev_dts;\n\t\t\t\t//transform back to inpput timescale\n\t\t\t\tif (timescale != tkw->tk_timescale) {\n\t\t\t\t\ttkw->sample.DTS = gf_timestamp_rescale(tkw->sample.DTS, tkw->tk_timescale, timescale);\n\t\t\t\t}\n\t\t\t\ttkw->sample.DTS += min_pck_dur;\n\t\t\t} else {\n\t\t\t\ttkw->sample.DTS = cts;\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttkw->sample.CTS_Offset = (s32) ((s64) cts - (s64) tkw->sample.DTS);\n\t}\n\n\t//do our best to patch init ts if timing config aborted\n\tif (tkw->si_min_ts_plus_one) {\n\t\tu64 si_min_ts = tkw->si_min_ts_plus_one - 1;\n\t\ttkw->si_min_ts_plus_one = 0;\n\t\ttkw->ts_shift = tkw->sample.DTS;\n\t\tmp4_mux_update_init_edit(ctx, tkw, si_min_ts, GF_FALSE);\n\t}\n\t//tkw->ts_shift is in source timescale, apply it before rescaling TSs/duration\n\tif (tkw->ts_shift) {\n\t\tif (ctx->is_rewind) {\n\t\t\tif (tkw->sample.DTS <= tkw->ts_shift) {\n\t\t\t\ttkw->sample.DTS = tkw->ts_shift - tkw->sample.DTS;\n\t\t\t\tcts = tkw->ts_shift - cts;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] broken timing in track, initial ts \"LLU\" less than TS \"LLU\"\\n\", tkw->ts_shift, tkw->sample.DTS));\n\t\t\t\tsample_timing_ok = GF_FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tif (tkw->sample.DTS >= tkw->ts_shift) {\n\t\t\t\ttkw->sample.DTS -= tkw->ts_shift;\n\t\t\t\tcts -= tkw->ts_shift;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] broken timing in track, initial ts \"LLU\" greater than TS \"LLU\"\\n\", tkw->ts_shift, tkw->sample.DTS));\n\t\t\t\tsample_timing_ok = GF_FALSE;\n\t\t\t}\n\t\t}\n\t}\n\n\t//sample-accurate seek info, start logging min CTS of packets marked as non-sync\n\tif (tkw->check_seek_ts && !gf_filter_pck_get_seek_flag(pck)) {\n\t\tu64 ts_check = cts;\n\t\tsubs = gf_filter_pck_get_property(pck, GF_PROP_PCK_SKIP_BEGIN);\n\t\tif (subs)\n\t\t\tts_check += subs->value.uint;\n\n\t\tif (!tkw->min_ts_seek_plus_one) {\n\t\t\ttkw->min_ts_seek_plus_one = ts_check + 1;\n\t\t} else if (tkw->min_ts_seek_plus_one > ts_check + 1) {\n\t\t\ttkw->min_ts_seek_plus_one = ts_check + 1;\n\t\t} else {\n\t\t\t//TS is greater than last non-seek packet TS, we're done seeking\n\t\t\ttkw->check_seek_ts = GF_FALSE;\n\t\t}\n\t}\n\n\tduration = gf_filter_pck_get_duration(pck);\n\tif (timescale != tkw->tk_timescale) {\n\t\ts64 ctso;\n\t\ttkw->sample.DTS = gf_timestamp_rescale(tkw->sample.DTS, timescale, tkw->tk_timescale);\n\n\t\tctso = (s64) tkw->sample.CTS_Offset;\n\t\tctso *= tkw->tk_timescale;\n\t\tctso /= timescale;\n\t\ttkw->sample.CTS_Offset = (s32) ctso;\n\t\tduration *= tkw->tk_timescale;\n\t\tduration /= timescale;\n\n\t\tif (cts != GF_FILTER_NO_TS) {\n\t\t\tcts = gf_timestamp_rescale(cts, timescale, tkw->tk_timescale);\n\t\t}\n\t}\n\n\ttkw->sample.IsRAP = 0;\n\tif (tkw->codecid==GF_CODECID_RAW) {\n\t\tsap_type = GF_FILTER_SAP_1;\n\t} else {\n\t\tsap_type = mp4_mux_get_sap(ctx, pck);\n\n\t\t//if pps inband mode is used, turn sap3 into sap1\n\t\tif ((tkw->xps_inband==XPS_IB_PPS) && sap_type==GF_FILTER_SAP_3)\n\t\t\tsap_type=GF_FILTER_SAP_1;\n\t}\n\tif (sap_type==GF_FILTER_SAP_1)\n\t\ttkw->sample.IsRAP = SAP_TYPE_1;\n\telse if (sap_type==GF_FILTER_SAP_2)\n\t\ttkw->sample.IsRAP = SAP_TYPE_2;\n\telse if ( (sap_type == GF_FILTER_SAP_4) && (tkw->stream_type != GF_STREAM_VISUAL) )\n\t\ttkw->sample.IsRAP = SAP_TYPE_1;\n\n\t/*RFC8216bis is not clear here:\n\t\"if the Partial Segment contains an independent frame.\"\n\t\t-> this would allow SAP1,2,3 (independent being only defined for segments)\n\n\tbut\n\n\t\"Partial Segment containing an independent frame SHOULD carry it to increase the efficiency with which clients can join and switch Renditions\"\n\t\t-> if used for switching, this only allows SAP 1 and 2\n\n\tSpec should be fixed to allow for both cases (fast tune-in or in-segment switching\u00e0)\n\t*/\n\tif ((tkw->sample.IsRAP == SAP_TYPE_1) || (tkw->sample.IsRAP == SAP_TYPE_2))\n\t\tctx->frag_has_intra = GF_TRUE;\n\n\ttkw->sample.DTS += tkw->dts_patch;\n\tif (tkw->nb_samples && (prev_dts >= tkw->sample.DTS) ) {\n\t\t//the fragmented API will patch the duration on the fly\n\t\tif (!for_fragment && ctx->patch_dts) {\n\t\t\tgf_isom_patch_last_sample_duration(ctx->file, tkw->track_num, prev_dts ? prev_dts : 1);\n\t\t}\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] PID %s ID %d Sample %d with DTS \"LLU\" less than previous sample DTS \"LLU\", patching DTS%s\\n\", gf_filter_pid_get_name(tkw->ipid), tkw->track_id, tkw->nb_samples+1, tkw->sample.DTS, prev_dts, ctx->patch_dts ? \"and adjusting prev sample duration\" : \"\" ));\n\t\tsample_timing_ok = GF_FALSE;\n\n\t\tif (prev_dts) {\n\t\t\ttkw->dts_patch = prev_dts - tkw->sample.DTS;\n\t\t\ttkw->sample.DTS += tkw->dts_patch+1; //+1 to avoid 0-dur samples\n\t\t} else {\n\t\t\ttkw->sample.DTS += 1;\n\t\t\tif (tkw->sample.CTS_Offset) tkw->sample.CTS_Offset -= 1;\n\t\t\tduration-=1;\n\t\t}\n\t}\n\n\n\tif (tkw->negctts_shift)\n\t\ttkw->sample.CTS_Offset -= tkw->negctts_shift;\n\n\tif (sample_timing_ok) {\n\t\tif (tkw->probe_min_ctts) {\n\t\t\ts32 diff = (s32) ((s64) cts - (s64) tkw->sample.DTS);\n\t\t\tif (diff < tkw->min_neg_ctts)\n\t\t\t\ttkw->min_neg_ctts = diff;\n\t\t}\n\t\tif (tkw->sample.CTS_Offset) tkw->has_ctts = GF_TRUE;\n\n\t\tif (tkw->sample.CTS_Offset < tkw->min_neg_ctts)\n\t\t\ttkw->min_neg_ctts = tkw->sample.CTS_Offset;\n\t}\n\n\ttkw->sample.nb_pack = 0;\n\tif (tkw->raw_audio_bytes_per_sample) {\n\t\ttkw->sample.nb_pack = tkw->sample.dataLength / tkw->raw_audio_bytes_per_sample;\n\t\tif (tkw->sample.nb_pack) {\n\t\t\tduration = 1;\n\t\t\tif (tkw->raw_samplerate && (tkw->tk_timescale != tkw->raw_samplerate)) {\n\t\t\t\tduration *= tkw->tk_timescale;\n\t\t\t\tduration /= tkw->raw_samplerate;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tkw->cenc_state && tkw->clear_stsd_idx && !gf_filter_pck_get_crypt_flags(pck)) {\n\t\tsample_desc_index = tkw->clear_stsd_idx;\n\t}\n\n\tif (tkw->sparse_inject && (prev_dts!=GF_FILTER_NO_TS) && (tkw->sample.DTS!=GF_FILTER_NO_TS) && tkw->prev_duration) {\n\t\tu64 est_time = prev_dts + tkw->prev_duration;\n\t\tif (est_time < tkw->sample.DTS) {\n\t\t\tu32 ins_dur;\n\t\t\tGF_ISOSample s;\n\t\t\tmemset(&s, 0, sizeof(GF_ISOSample));\n\t\t\ts.DTS = est_time;\n\n\t\t\ts.IsRAP = SAP_TYPE_1;\n\t\t\tins_dur = (u32) (tkw->sample.DTS - est_time);\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\te = gf_isom_fragment_add_sample(ctx->file, tkw->track_id, &s, tkw->stsd_idx, ins_dur, 0, 0, 0);\n#else\n\t\t\t\te = GF_NOT_SUPPORTED;\n#endif\n\t\t\t} else {\n\t\t\t\te = gf_isom_add_sample(ctx->file, tkw->track_num, tkw->stsd_idx, &s);\n\t\t\t\tgf_isom_set_last_sample_duration(ctx->file, tkw->track_num, ins_dur);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tkw->use_dref) {\n\t\tu64 data_offset = gf_filter_pck_get_byte_offset(pck);\n\t\tif (data_offset != GF_FILTER_NO_BO) {\n\t\t\te = gf_isom_add_sample_reference(ctx->file, tkw->track_num, sample_desc_index, &tkw->sample, data_offset);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to add sample DTS \"LLU\" from %s as reference: %s\\n\", tkw->sample.DTS, gf_filter_pid_get_name(tkw->ipid), gf_error_to_string(e) ));\n\t\t\t}\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot add sample reference at DTS \"LLU\" , input sample data is not continous in source\\n\", tkw->sample.DTS ));\n\t\t}\n\t} else if (tkw->nb_frames_per_sample && (tkw->nb_samples % tkw->nb_frames_per_sample)) {\n\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t \te = gf_isom_fragment_append_data(ctx->file, tkw->track_id, tkw->sample.data, tkw->sample.dataLength, 0);\n#else\n\t\t\te = GF_NOT_SUPPORTED;\n#endif\n\t\t} else {\n\t\t\te = gf_isom_append_sample_data(ctx->file, tkw->track_num, tkw->sample.data, tkw->sample.dataLength);\n\t\t}\n\t\ttkw->has_append = GF_TRUE;\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to append sample DTS \"LLU\" data: %s\\n\", tkw->sample.DTS, gf_error_to_string(e) ));\n\t\t}\n\t} else {\n\t\tBool inject_pps = ctx->pps_inband;\n\t\tif (ctx->xps_inband==XPS_IB_AUTO) {\n\t\t\tconst GF_PropertyValue *p = gf_filter_pck_get_property(pck, GF_PROP_PCK_XPS_MASK);\n\t\t\tif (p && (p->value.uint & (1<<2) ) )\n\t\t\t\tinject_pps = GF_TRUE;\n\t\t}\n\n\t\tif ((tkw->sample.IsRAP || tkw->force_inband_inject || inject_pps) && tkw->xps_inband) {\n\t\t\tu8 *inband_xps;\n\t\t\tu32 inband_xps_size;\n\t\t\tchar *au_delim=NULL;\n\t\t\tu32 au_delim_size=0;\n\t\t\tchar *pck_data = tkw->sample.data;\n\t\t\tu32 pck_data_len = tkw->sample.dataLength;\n\t\t\tif (tkw->sample.IsRAP || tkw->force_inband_inject) {\n\t\t\t\tinband_xps = tkw->inband_hdr;\n\t\t\t\tinband_xps_size = tkw->inband_hdr_size;\n\t\t\t\ttkw->force_inband_inject = GF_FALSE;\n\t\t\t} else {\n\t\t\t\tinband_xps = tkw->inband_hdr_non_rap;\n\t\t\t\tinband_xps_size = tkw->inband_hdr_non_rap_size;\n\t\t\t}\n\t\t\ttkw->sample.data = inband_xps;\n\t\t\ttkw->sample.dataLength = inband_xps_size;\n\n\t\t\tif (tkw->is_nalu==NALU_AVC) {\n\t\t\t\tif (pck_data_len >= 2 + tkw->nal_unit_size) {\n\t\t\t\t\tchar *nal = pck_data + tkw->nal_unit_size;\n\t\t\t\t\tif ((nal[0] & 0x1F) == GF_AVC_NALU_ACCESS_UNIT) {\n\t\t\t\t\t\tfirst_nal_is_audelim = au_delim_size = 2 + tkw->nal_unit_size;\n\t\t\t\t\t\tau_delim = pck_data;\n\t\t\t\t\t\tif (au_delim_size >= pck_data_len) au_delim = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (pck_data_len >= 3 + tkw->nal_unit_size) {\n\t\t\t\t\tchar *nal = pck_data + tkw->nal_unit_size;\n\t\t\t\t\tif (((nal[0] & 0x7E)>>1) == GF_HEVC_NALU_ACCESS_UNIT) {\n\t\t\t\t\t\tfirst_nal_is_audelim = au_delim_size = 3 + tkw->nal_unit_size;\n\t\t\t\t\t\tau_delim = pck_data;\n\t\t\t\t\t\tif (au_delim_size >= pck_data_len) au_delim = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (au_delim) {\n\t\t\t\ttkw->sample.data = au_delim;\n\t\t\t\ttkw->sample.dataLength = au_delim_size;\n\t\t\t\tpck_data += au_delim_size;\n\t\t\t\tpck_data_len -= au_delim_size;\n\t\t\t}\n\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\t//force using ref mode\n\t\t\t\tvoid *ref=NULL;\n\t\t\t\te = gf_isom_fragment_add_sample_ex(ctx->file, tkw->track_id, &tkw->sample, sample_desc_index, duration, 0, 0, 0, &ref, 0);\n\t\t\t\tif (!e && au_delim) {\n\t\t\t\t\te = gf_isom_fragment_append_data(ctx->file, tkw->track_id, inband_xps, inband_xps_size, 0);\n\t\t\t\t}\n\t\t\t\tif (!e) {\n\t\t\t\t\tif (gf_filter_pck_is_blocking_ref(pck)) {\n\t\t\t\t\t\te = gf_isom_fragment_append_data(ctx->file, tkw->track_id, pck_data, pck_data_len, 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_filter_pck_ref(&pck);\n\t\t\t\t\t\tGF_FilterPacket *ref = pck;\n\t\t\t\t\t\te = gf_isom_fragment_append_data_ex(ctx->file, tkw->track_id, pck_data, pck_data_len, 0, (void**)&ref, au_delim ? au_delim_size : 0);\n\t\t\t\t\t\tif (!ref) {\n\t\t\t\t\t\t\tgf_list_add(ctx->ref_pcks, pck);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_filter_pck_unref(pck);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n#else\n\t\t\t\te = GF_NOT_SUPPORTED;\n#endif // GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t} else {\n\t\t\t\te = gf_isom_add_sample(ctx->file, tkw->track_num, sample_desc_index, &tkw->sample);\n\t\t\t\tif (au_delim && !e) {\n\t\t\t\t\te = gf_isom_append_sample_data(ctx->file, tkw->track_num, inband_xps, inband_xps_size);\n\t\t\t\t}\n\t\t\t\tif (!e) e = gf_isom_append_sample_data(ctx->file, tkw->track_num, pck_data, pck_data_len);\n\t\t\t}\n\t\t\tinsert_subsample_dsi_size = inband_xps_size;\n\t\t} else if (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (gf_filter_pck_is_blocking_ref(pck)) {\n\t\t\t\te = gf_isom_fragment_add_sample(ctx->file, tkw->track_id, &tkw->sample, sample_desc_index, duration, 0, 0, 0);\n\t\t\t} else {\n\t\t\t\tgf_filter_pck_ref(&pck);\n\t\t\t\tGF_FilterPacket *ref = pck;\n\t\t\t\te = gf_isom_fragment_add_sample_ex(ctx->file, tkw->track_id, &tkw->sample, sample_desc_index, duration, 0, 0, 0, (void**) &ref, 0);\n\t\t\t\tif (!ref) {\n\t\t\t\t\tgf_list_add(ctx->ref_pcks, pck);\n\t\t\t\t} else {\n\t\t\t\t\tgf_filter_pck_unref(pck);\n\t\t\t\t}\n\t\t\t}\n#else\n\t\t\te = GF_NOT_SUPPORTED;\n#endif // GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t} else {\n\t\t\te = gf_isom_add_sample(ctx->file, tkw->track_num, sample_desc_index, &tkw->sample);\n\t\t\tif (!e && !duration) {\n\t\t\t\tgf_isom_set_last_sample_duration(ctx->file, tkw->track_num, 0);\n\t\t\t}\n\t\t}\n\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to add sample DTS \"LLU\" from %s - prev DTS \"LLU\": %s\\n\", tkw->sample.DTS, gf_filter_pid_get_name(tkw->ipid), prev_dts, gf_error_to_string(e) ));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MP4Mux] added sample DTS \"LLU\" - prev DTS \"LLU\" - prev size %d\\n\", tkw->sample.DTS, prev_dts, prev_size));\n\t\t}\n\n\t\tif (!e && tkw->cenc_state) {\n\t\t\te = mp4_mux_cenc_update(ctx, tkw, pck, for_fragment ? CENC_ADD_FRAG : CENC_ADD_NORMAL, tkw->sample.dataLength, insert_subsample_dsi_size);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set sample CENC information: %s\\n\", gf_error_to_string(e) ));\n\t\t\t}\n\t\t}\n\t}\n\n\ttkw->nb_samples++;\n\ttkw->samples_in_stsd++;\n\ttkw->samples_in_frag++;\n\n\tif (e) return e;\n\n\tif (!for_fragment && sample_timing_ok) {\n\t\tu64 samp_cts;\n\t\tif (!tkw->clamp_ts_plus_one) {\n\t\t\tconst GF_PropertyValue *skp = gf_filter_pck_get_property(pck, GF_PROP_PCK_SKIP_PRES);\n\t\t\tif (skp && skp->value.boolean) {\n\t\t\t\ttkw->clamp_ts_plus_one = 1 + tkw->sample.DTS + tkw->sample.CTS_Offset;\n\t\t\t}\n\t\t}\n\t\t//store min max cts for edit list updates\n\t\tsamp_cts = tkw->sample.DTS + tkw->sample.CTS_Offset;\n\t\tif (!tkw->clamp_ts_plus_one || (samp_cts + 1 < tkw->clamp_ts_plus_one)) {\n\t\t\tif (samp_cts > tkw->max_cts) {\n\t\t\t\ttkw->max_cts = samp_cts;\n\t\t\t\ttkw->max_cts_samp_dur = duration;\n\t\t\t}\n\n\t\t\tif (tkw->min_cts > samp_cts)\n\t\t\t\ttkw->min_cts = samp_cts;\n\t\t}\n\t}\n\n\t//compat with old arch: write sample to group info for all samples\n\tif ((sap_type==3) || tkw->has_open_gop)  {\n\t\tif (!ctx->norap) {\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\te = gf_isom_fragment_set_sample_rap_group(ctx->file, tkw->track_id, tkw->samples_in_frag, (sap_type==3) ? GF_TRUE : GF_FALSE, 0);\n#else\n\t\t\t\te = GF_NOT_SUPPORTED;\n#endif\n\t\t\t} else if (sap_type==3) {\n\t\t\t\te = gf_isom_set_sample_rap_group(ctx->file, tkw->track_num, tkw->nb_samples, GF_TRUE /*(sap_type==3) ? GF_TRUE : GF_FALSE*/, 0);\n\t\t\t}\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set sample DTS \"LLU\" SAP 3 in RAP group: %s\\n\", tkw->sample.DTS, gf_error_to_string(e) ));\n\t\t\t}\n\t\t}\n\t\ttkw->has_open_gop = GF_TRUE;\n\t}\n\tif (!ctx->noroll) {\n\t\tif ((sap_type==GF_FILTER_SAP_4) || (sap_type==GF_FILTER_SAP_4_PROL) || tkw->gdr_type) {\n\t\t\tGF_ISOSampleRollType roll_type = 0;\n\t\t\ts16 roll = gf_filter_pck_get_roll_info(pck);\n\t\t\tif (sap_type==GF_FILTER_SAP_4) roll_type = GF_ISOM_SAMPLE_ROLL;\n\t\t\telse if (sap_type==GF_FILTER_SAP_4_PROL) roll_type = GF_ISOM_SAMPLE_PREROLL;\n\t\t\telse if (tkw->gdr_type==GF_FILTER_SAP_4_PROL) {\n\t\t\t\troll_type = GF_ISOM_SAMPLE_PREROLL_NONE;\n\t\t\t}\n\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\te = gf_isom_fragment_set_sample_roll_group(ctx->file, tkw->track_id, tkw->samples_in_frag, roll_type, roll);\n#else\n\t\t\t\te = GF_NOT_SUPPORTED;\n#endif\n\t\t\t} else {\n\t\t\t\te = gf_isom_set_sample_roll_group(ctx->file, tkw->track_num, tkw->nb_samples, roll_type, roll);\n\t\t\t}\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set sample DTS \"LLU\" SAP 4 roll %s in roll group: %s\\n\", tkw->sample.DTS, roll, gf_error_to_string(e) ));\n\t\t\t}\n\t\t\tif (sap_type && !tkw->gdr_type)\n\t\t\t\ttkw->gdr_type = sap_type;\n\t\t}\n\t}\n\t\n\tsubs = gf_filter_pck_get_property(pck, GF_PROP_PCK_SUBS);\n\tif (subs) {\n\t\t//if no AUDelim nal and inband header injection, push new subsample\n\t\tif (!first_nal_is_audelim && insert_subsample_dsi_size) {\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\tgf_isom_fragment_add_subsample(ctx->file, tkw->track_id, 0, insert_subsample_dsi_size, 0, 0, 0);\n#endif\n\t\t\t} else {\n\t\t\t\tgf_isom_add_subsample(ctx->file, tkw->track_num, tkw->nb_samples, 0, insert_subsample_dsi_size, 0, 0, 0);\n\t\t\t}\n\t\t\tinsert_subsample_dsi_size = 0;\n\t\t}\n\t\ttkw->has_subs = GF_TRUE;\n\n\t\tif (!ctx->bs_r) ctx->bs_r = gf_bs_new(subs->value.data.ptr, subs->value.data.size, GF_BITSTREAM_READ);\n\t\telse gf_bs_reassign_buffer(ctx->bs_r, subs->value.data.ptr, subs->value.data.size);\n\n\t\twhile (gf_bs_available(ctx->bs_r)) {\n\t\t\tu32 flags = gf_bs_read_u32(ctx->bs_r);\n\t\t\tu32 subs_size = gf_bs_read_u32(ctx->bs_r);\n\t\t\tu32 reserved = gf_bs_read_u32(ctx->bs_r);\n\t\t\tu8 priority = gf_bs_read_u8(ctx->bs_r);\n\t\t\tu8 discardable = gf_bs_read_u8(ctx->bs_r);\n\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\tgf_isom_fragment_add_subsample(ctx->file, tkw->track_id, flags, subs_size, priority, reserved, discardable);\n#endif\n\t\t\t} else {\n\t\t\t\tgf_isom_add_subsample(ctx->file, tkw->track_num, tkw->nb_samples, flags, subs_size, priority, reserved, discardable);\n\t\t\t}\n\n\t\t\t//we have AUDelim nal and inband header injection, push new subsample for inband header once we have pushed the first subsample (au delim)\n\t\t\tif (insert_subsample_dsi_size) {\n\t\t\t\tif (first_nal_is_audelim != subs_size) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] inserting inband param after AU delimiter NALU, but sample has subsample information not aligned on NALU (got %d subsample size but expecting %d) - file might be broken!\\n\", subs_size, first_nal_is_audelim));\n\t\t\t\t}\n\t\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\t\tgf_isom_fragment_add_subsample(ctx->file, tkw->track_id, 0, insert_subsample_dsi_size, 0, 0, 0);\n#endif\n\t\t\t\t} else {\n\t\t\t\t\tgf_isom_add_subsample(ctx->file, tkw->track_num, tkw->nb_samples, 0, insert_subsample_dsi_size, 0, 0, 0);\n\t\t\t\t}\n\t\t\t\tinsert_subsample_dsi_size = GF_FALSE;\n\t\t\t}\n\t\t}\n\t} else if (for_fragment && tkw->has_subs && ctx->cmaf && (tkw->codecid==GF_CODECID_SUBS_XML)) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t//tentative implemntation of CMAF 7.5.20 which is just nonsense text !!:\n\t\t//\"the value of subsample_count shall equal 1 for the first image sub-sample, and the subsample_count of the TTML document shall equal 0.\"\n\t\t//\n\t\t//we simply signal a single subsample\n\t\tgf_isom_fragment_add_subsample(ctx->file, tkw->track_id, 0, tkw->sample.dataLength, 0, 0, 0);\n#endif\n\t}\n\n\tif (ctx->deps) {\n\t\tu8 dep_flags = gf_filter_pck_get_dependency_flags(pck);\n\t\tif (dep_flags) {\n\t\t\tu32 is_leading = (dep_flags>>6) & 0x3;\n\t\t\tu32 depends_on = (dep_flags>>4) & 0x3;\n\t\t\tu32 depended_on = (dep_flags>>2) & 0x3;\n\t\t\tu32 redundant = (dep_flags) & 0x3;\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\tgf_isom_fragment_set_sample_flags(ctx->file, tkw->track_id, is_leading, depends_on, depended_on, redundant);\n#endif\n\t\t\t} else {\n\t\t\t\tgf_isom_set_sample_flags(ctx->file, tkw->track_num, tkw->nb_samples, is_leading, depends_on, depended_on, redundant);\n\t\t\t}\n\t\t}\n\t}\n\n\tu32 idx = 0;\n\twhile (1) {\n\t\tBool is_sample_group=GF_FALSE;\n\t\tu32 aux_type=0, aux_info=0, sg_flags=0;\n\t\tu32 p4cc;\n\t\tconst char *pname=NULL;\n\t\tconst GF_PropertyValue *p = gf_filter_pck_enum_properties(pck, &idx, &p4cc, &pname);\n\t\tif (!p) break;\n\t\tif ((p->type!=GF_PROP_DATA) && (p->type!=GF_PROP_CONST_DATA)) continue;\n\t\tif (!p->value.data.size || !p->value.data.ptr) continue;\n\t\tif (!pname) continue;\n\n\t\tif (!strncmp(pname, \"sai_\", 4)) {\n\n\t\t} else if (!strncmp(pname, \"grp_\", 4)) {\n\t\t\t//discard emsg if fragmented, otherwise add as internal sample group - TODO, support for EventMessage tracks\n\t\t\tif (!strcmp(pname, \"grp_EMSG\") && (ctx->store>=MP4MX_MODE_FRAG)) continue;\n\t\t\tis_sample_group = GF_TRUE;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\tpname+=4;\n\t\tu32 plen = (u32) strlen(pname);\n\t\tif (plen==3) {\n\t\t\taux_type = GF_4CC(pname[0], pname[1], pname[2], ' ');\n\t\t\tpname+=3;\n\t\t} else if (plen >= 4) {\n\t\t\taux_type = GF_4CC(pname[0], pname[1], pname[2], pname[3]);\n\t\t\tpname+=4;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tif (pname[0] == '_') {\n\t\t\tif (is_sample_group) {\n\t\t\t\tchar *flags = strstr(pname, \"_z\");\n\t\t\t\tif (flags) flags[0]=0;\n\t\t\t\tif (pname[0]) aux_info = atoi(pname);\n\t\t\t\tif (flags) {\n\t\t\t\t\tsscanf(flags+2, \"%x\", &sg_flags);\n\t\t\t\t\tflags[0]='_';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taux_info = atoi(pname);\n\t\t\t}\n\t\t}\n\t\tif (!aux_type) continue;\n\n\t\tif (is_sample_group) {\n\t\t\tif (aux_type==GF_ISOM_SAMPLE_GROUP_ESGH) {\n\t\t\t\tGF_Err gf_isom_set_sample_description_restricted(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescIndex, u32 scheme_type);\n\t\t\t\tgf_isom_set_sample_description_restricted(ctx->file, tkw->track_num, tkw->stsd_idx, GF_4CC( 'e', 's', 's', 'g'));\n\n\t\t\t\tsg_flags |= 0x40000000;\n\t\t\t}\n\n\t\t\tgf_isom_set_sample_group_description(ctx->file, tkw->track_num, for_fragment ? 0 : tkw->nb_samples, aux_type, aux_info, p->value.data.ptr, p->value.data.size, sg_flags);\n\n\t\t} else {\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\tgf_isom_fragment_set_sample_aux_info(ctx->file, tkw->track_id, tkw->samples_in_frag, aux_type, aux_info, p->value.data.ptr, p->value.data.size);\n#endif\n\t\t\t} else {\n\t\t\t\tgf_isom_add_sample_aux_info(ctx->file, tkw->track_num, tkw->nb_samples, aux_type, aux_info, p->value.data.ptr, p->value.data.size);\n\t\t\t}\n\t\t}\n\t}\n\n\ttkw->prev_duration = duration;\n\tif (duration && !for_fragment && !tkw->raw_audio_bytes_per_sample)\n\t\tgf_isom_set_last_sample_duration(ctx->file, tkw->track_num, duration);\n\n\tif (ctx->dur.num) {\n\t\tBool abort = GF_FALSE;\n\t\tif (ctx->dur.num>0) {\n\t\t\tu64 mdur = gf_isom_get_media_duration(ctx->file, tkw->track_num);\n\n\t\t\t/*patch to align to old arch */\n\t\t\tif (gf_sys_old_arch_compat()) {\n\t\t\t\tif (tkw->stream_type==GF_STREAM_VISUAL) {\n\t\t\t\t\tmdur = tkw->sample.DTS;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//adjust if shift is below half sec (to take AV delay into account)\n\t\t\t//if larger, we imported from non-0 initial ts, do not compensate\n\t\t\telse if (tkw->ts_shift<tkw->tk_timescale/2) {\n\t\t\t\tmdur += tkw->ts_shift;\n\t\t\t}\n\n\t\t\tif (ctx->importer) {\n\t\t\t\ttkw->prog_done = mdur * ctx->dur.den;\n\t\t\t\ttkw->prog_total =  ((u64)tkw->tk_timescale) * ctx->dur.num;\n\t\t\t}\n\n\t\t\t/*patch to align to old arch */\n\t\t\tif (gf_sys_old_arch_compat()) {\n\t\t\t\tif (gf_timestamp_greater(mdur, tkw->tk_timescale, ctx->dur.num, ctx->dur.den))\n\t\t\t\t\tabort = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tif (gf_timestamp_greater_or_equal(mdur, tkw->tk_timescale, ctx->dur.num, ctx->dur.den))\n\t\t\t\t\tabort = GF_TRUE;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((s32) tkw->nb_samples >= -ctx->dur.num)\n\t\t\t\tabort = GF_TRUE;\n\t\t}\n\n\t\tif (abort) {\n\t\t\tGF_FilterEvent evt;\n\t\t\tGF_FEVT_INIT(evt, GF_FEVT_STOP, tkw->ipid);\n\t\t\tgf_filter_pid_send_event(tkw->ipid, &evt);\n\n\t\t\ttkw->aborted = GF_TRUE;\n\t\t}\n\t} else if (ctx->importer) {\n\t\tif (tkw->nb_frames) {\n\t\t\ttkw->prog_done = tkw->nb_samples + tkw->frame_offset;\n\t\t\ttkw->prog_total = tkw->nb_frames;\n\t\t} else {\n\t\t\tu64 data_offset = gf_filter_pck_get_byte_offset(pck);\n\t\t\tif (data_offset == GF_FILTER_NO_BO) {\n\t\t\t\tdata_offset = tkw->down_bytes;\n\t\t\t}\n\t\t\tif ((data_offset != GF_FILTER_NO_BO) && tkw->down_size) {\n\t\t\t\ttkw->prog_done = data_offset;\n\t\t\t\ttkw->prog_total = tkw->down_size;\n\t\t\t} else {\n\t\t\t\tif (tkw->pid_dur.den && tkw->pid_dur.num) {\n\t\t\t\t\ttkw->prog_done = tkw->sample.DTS * tkw->pid_dur.den;\n\t\t\t\t\ttkw->prog_total = tkw->pid_dur.num * tkw->tk_timescale;\n\t\t\t\t} else {\n\t\t\t\t\ttkw->prog_done = 0;\n\t\t\t\t\ttkw->prog_total = 1;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err mp4_mux_process_item(GF_MP4MuxCtx *ctx, TrackWriter *tkw, GF_FilterPacket *pck)\n{\n\tGF_Err e;\n\tu32 meta_type, item_id, size, item_type, nb_items, media_brand = GF_ISOM_BRAND_HEIF;\n\tGF_ImageItemProperties image_props;\n\tGF_ImageItemProtection cenc_info;\n\tconst char *data, *item_name=NULL;\n\tconst GF_PropertyValue *p, *dsi, *dsi_enh;\n\tGF_Box *config_box = NULL;\n\n\n\tif (ctx->init_movie_done) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot add item to a finalized movie, not supported\\n\"));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tif (tkw->stream_type != GF_STREAM_VISUAL) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot add item other than visual, not supported - use MP4Box for this\\n\"));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tctx->update_report = GF_TRUE;\n\n\tmeta_type = gf_isom_get_meta_type(ctx->file, GF_TRUE, 0);\n\tif (!meta_type) {\n\t\te = gf_isom_set_meta_type(ctx->file, GF_TRUE, 0, GF_META_ITEM_TYPE_PICT);\n\t} else if (meta_type != GF_META_ITEM_TYPE_PICT) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] File already has a root 'meta' box of type %s\\n\", gf_4cc_to_str(meta_type)));\n\t\te= GF_BAD_PARAM;\n\t} else {\n\t\te = GF_OK;\n\t}\n\tif (e) return e;\n\n\tdata = (char *)gf_filter_pck_get_data(pck, &size);\n\tif (!data) {\n\t\tif (gf_filter_pck_get_frame_interface(pck)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot add items from raw decoder outputs, not supported\\n\"));\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tctx->total_bytes_in += size;\n\tctx->total_samples++;\n\n\n\titem_id = 0;\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ITEM_ID);\n\tif (p) item_id = p->value.uint;\n\n\titem_name = \"Image\";\n\tp = gf_filter_pid_get_property_str(tkw->ipid, \"meta:name\");\n\tif (p && p->value.string) item_name = p->value.string;\n\n\tmemset(&image_props, 0, sizeof(GF_ImageItemProperties));\n\n\tdsi = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DECODER_CONFIG);\n\tdsi_enh = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT);\n\tBool free_config_ba = GF_FALSE;\n\n\tswitch (tkw->codecid) {\n\tcase GF_CODECID_AVC:\n\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\tif (!dsi) return GF_OK;\n\n\t\tif (tkw->codecid==GF_CODECID_AVC) {\n\t\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_AVCC);\n\t\t\titem_type = GF_ISOM_SUBTYPE_AVC_H264;\n\t\t} else if (tkw->codecid==GF_CODECID_MVC) {\n\t\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_MVCC);\n\t\t\titem_type = GF_ISOM_SUBTYPE_MVC_H264;\n\t\t\tif (dsi_enh) dsi = dsi_enh;\n\t\t} else {\n\t\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_SVCC);\n\t\t\titem_type = GF_ISOM_SUBTYPE_SVC_H264;\n\t\t\tif (dsi_enh) dsi = dsi_enh;\n\t\t}\n\n\t\t((GF_AVCConfigurationBox *)config_box)->config = gf_odf_avc_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\t\tif (! ((GF_AVCConfigurationBox *)config_box)->config) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\timage_props.num_channels = 3;\n\t\timage_props.bits_per_channel[0] = ((GF_AVCConfigurationBox *)config_box)->config->luma_bit_depth;\n\t\timage_props.bits_per_channel[1] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\timage_props.bits_per_channel[2] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tmedia_brand = GF_ISOM_BRAND_AVCI;\n\t\tbreak;\n\n\tcase GF_CODECID_HEVC:\n\tcase GF_CODECID_HEVC_TILES:\n\tcase GF_CODECID_LHVC:\n\t\tif (tkw->codecid == GF_CODECID_LHVC) {\n\t\t\tif (dsi_enh) dsi = dsi_enh;\n\t\t\tif (!dsi) return GF_OK;\n\t\t}\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_HVCC);\n\n\t\tif (dsi_enh) {\n\t\t\t((GF_HEVCConfigurationBox *)config_box)->config = gf_odf_hevc_cfg_read(dsi->value.data.ptr, dsi->value.data.size, GF_TRUE);\n\t\t\titem_type = GF_ISOM_SUBTYPE_LHV1;\n\t\t} else {\n\t\t\tif ((tkw->codecid == GF_CODECID_HEVC) && !dsi) return GF_OK;\n\n\t\t\t((GF_HEVCConfigurationBox *)config_box)->config = gf_odf_hevc_cfg_read(dsi->value.data.ptr, dsi->value.data.size, GF_FALSE);\n\t\t\titem_type = (tkw->codecid == GF_CODECID_HEVC_TILES) ? GF_ISOM_SUBTYPE_HVT1 : GF_ISOM_SUBTYPE_HVC1;\n\t\t}\n\t\tif (! ((GF_HEVCConfigurationBox *)config_box)->config) {\n\t\t\tif ((tkw->codecid != GF_CODECID_HEVC_TILES) && !dsi) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t} else {\n\t\t\timage_props.num_channels = 3;\n\t\t\timage_props.bits_per_channel[0] = ((GF_HEVCConfigurationBox *)config_box)->config->luma_bit_depth;\n\t\t\timage_props.bits_per_channel[1] = ((GF_HEVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\t\timage_props.bits_per_channel[2] = ((GF_HEVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\t}\n\t\tmedia_brand = GF_ISOM_BRAND_HEIC;\n\t\tif (tkw->codecid==GF_CODECID_LHVC) {\n\t\t\tmedia_brand = GF_ISOM_BRAND_HEIM;\n\t\t}\n\t\tbreak;\n\tcase GF_CODECID_AV1:\n\t\tif (!dsi) return GF_OK;\n\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_AV1C);\n\t\t((GF_AV1ConfigurationBox *)config_box)->config = gf_odf_av1_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\n\t\tif (! ((GF_AV1ConfigurationBox *)config_box)->config) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\titem_type = GF_ISOM_SUBTYPE_AV01;\n\t\tu8 depth = ((GF_AV1ConfigurationBox *)config_box)->config->high_bitdepth ? (((GF_AV1ConfigurationBox *)config_box)->config->twelve_bit ? 12 : 10 ) : 8;\n\t\tif (((GF_AV1ConfigurationBox *)config_box)->config->monochrome) {\n\t\t\timage_props.num_channels = 1;\n\t\t\timage_props.bits_per_channel[0] = depth;\n\t\t\timage_props.bits_per_channel[1] = 0;\n\t\t\timage_props.bits_per_channel[2] = 0;\n\t\t} else {\n\t\t\timage_props.num_channels = 3;\n\t\t\timage_props.bits_per_channel[0] = depth;\n\t\t\timage_props.bits_per_channel[1] = depth;\n\t\t\timage_props.bits_per_channel[2] = depth;\n\t\t}\n\t\tmedia_brand = GF_ISOM_BRAND_AVIF;\n\t\tbreak;\n\tcase GF_CODECID_JPEG:\n\t\titem_type = GF_ISOM_SUBTYPE_JPEG;\n\t\tmedia_brand = GF_ISOM_SUBTYPE_JPEG /* == GF_4CC('j', 'p', 'e', 'g') */;\n\t\tbreak;\n\tcase GF_CODECID_J2K:\n\t\titem_type = GF_ISOM_SUBTYPE_JP2K;\n\t\tmedia_brand = GF_4CC('j', '2', 'k', 'i');\n\t\tbreak;\n\tcase GF_CODECID_PNG:\n\t\titem_type = GF_ISOM_SUBTYPE_PNG;\n\t\t//not defined !\n\t\tmedia_brand = GF_ISOM_SUBTYPE_PNG /* == GF_4CC('j', 'p', 'e', 'g') */;\n\t\tbreak;\n\n\tcase GF_CODECID_VVC:\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_VVCC);\n\n\t\tif ((tkw->codecid == GF_CODECID_VVC) && !dsi) return GF_OK;\n\n\t\t((GF_VVCConfigurationBox *)config_box)->config = gf_odf_vvc_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\t\titem_type = GF_ISOM_SUBTYPE_VVC1;\n\n\t\tif (! ((GF_VVCConfigurationBox *)config_box)->config) {\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t} else {\n\t\t\timage_props.num_channels = 3;\n\t\t\timage_props.bits_per_channel[0] = ((GF_VVCConfigurationBox *)config_box)->config->bit_depth;\n\t\t\timage_props.bits_per_channel[1] = ((GF_VVCConfigurationBox *)config_box)->config->bit_depth;\n\t\t\timage_props.bits_per_channel[2] = ((GF_VVCConfigurationBox *)config_box)->config->bit_depth;\n\t\t}\n\t\tmedia_brand = GF_ISOM_BRAND_VVIC;\n\t\tbreak;\n\tcase GF_CODECID_RAW:\n\tcase GF_CODECID_RAW_UNCV:\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_PIXFMT);\n\t\tif (p && (p->value.uint==GF_PIXEL_UNCV)) {\n\t\t\timage_props.config_ba = dsi->value.data.ptr;\n\t\t\timage_props.config_ba_size = dsi->value.data.size;\n\t\t\titem_type = GF_4CC('u','n','c','i');\n\t\t\tbreak;\n\t\t} else {\n\t\t\tif (gf_pixel_fmt_get_uncc(p->value.uint, ctx->uncv-1, &image_props.config_ba, &image_props.config_ba_size)==GF_TRUE) {\n\t\t\t\tfree_config_ba = GF_TRUE;\n\t\t\t\titem_type = GF_4CC('u','n','c','i');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tdefault:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error: Codec %s not supported to create HEIF image items\\n\", gf_codecid_name(tkw->codecid) ));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_WIDTH);\n\tif (p) image_props.width = p->value.uint;\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_HEIGHT);\n\tif (p) image_props.height = p->value.uint;\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ALPHA);\n\tif (p) image_props.alpha = p->value.boolean;\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_SAR);\n\tif (p) {\n\t\timage_props.hSpacing = p->value.frac.num;\n\t\timage_props.vSpacing = p->value.frac.den;\n\t} else {\n\t\timage_props.hSpacing = image_props.vSpacing = 1;\n\t}\n\timage_props.config = config_box;\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_HIDDEN);\n\tif (p) image_props.hidden = p->value.boolean;\n\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_MIRROR);\n\tif (p && p->value.uint) image_props.mirror = p->value.uint;\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ROTATE);\n\tif (p) image_props.angle = p->value.uint;\n\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CLAP_W);\n\tif (p) { image_props.clap_wnum = p->value.frac.num; image_props.clap_wden = p->value.frac.den; }\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CLAP_H);\n\tif (p) { image_props.clap_hnum = p->value.frac.num; image_props.clap_hden = p->value.frac.den; }\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CLAP_X);\n\tif (p) { image_props.clap_honum = p->value.frac.num; image_props.clap_hoden = p->value.frac.den; }\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CLAP_Y);\n\tif (p) { image_props.clap_vonum = p->value.frac.num; image_props.clap_voden = p->value.frac.den; }\n\n\tp = gf_filter_pck_get_property_str(pck, \"grp_ilce\");\n\tif (p && ((p->type==GF_PROP_DATA)||(p->type==GF_PROP_CONST_DATA)) && p->value.data.ptr) {\n\t\timage_props.interlace_type = p->value.data.ptr[0];\n\t}\n\n\t//setup crypto\n\tif (tkw->is_encrypted && gf_filter_pck_get_crypt_flags(pck)) {\n\t\tmemset(&cenc_info, 0, sizeof(GF_ImageItemProtection));\n\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_CENC_SAI);\n\t\tif (!p) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error: Missing CENC SAI on protected packet\\n\"));\n\t\t\tif (config_box) gf_isom_box_del(config_box);\n\t\t\tif (free_config_ba) gf_free(image_props.config_ba);\n\t\t\treturn GF_SERVICE_ERROR;\n\t\t}\n\t\tcenc_info.sai_data = p->value.data.ptr;\n\t\tcenc_info.sai_data_size = p->value.data.size;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_PROTECTION_SCHEME_TYPE);\n\t\tif (!p) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error: Missing CENC scheme type on protected item\\n\"));\n\t\t\tif (config_box) gf_isom_box_del(config_box);\n\t\t\tif (free_config_ba) gf_free(image_props.config_ba);\n\t\t\treturn GF_SERVICE_ERROR;\n\t\t}\n\t\tcenc_info.scheme_type = p->value.uint;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_PROTECTION_SCHEME_VERSION);\n\t\tif (!p) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error: Missing CENC scheme version on protected item\\n\"));\n\t\t\tif (config_box) gf_isom_box_del(config_box);\n\t\t\tif (free_config_ba) gf_free(image_props.config_ba);\n\t\t\treturn GF_SERVICE_ERROR;\n\t\t}\n\t\tcenc_info.scheme_version = p->value.uint;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CENC_KEY_INFO);\n\t\tif (!p || (p->type != GF_PROP_DATA) || !gf_cenc_validate_key_info(p->value.data.ptr, p->value.data.size)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error: %s CENC Key info on protected item\\n\", p ? \"Corrupted\" : \"Missing\"));\n\t\t\tif (config_box) gf_isom_box_del(config_box);\n\t\t\tif (free_config_ba) gf_free(image_props.config_ba);\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tcenc_info.key_info = p->value.data.ptr;\n\t\tcenc_info.key_info_size = p->value.data.size;\n\n\t\timage_props.cenc_info = &cenc_info;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CENC_PATTERN);\n\t\tif (p) {\n\t\t\tcenc_info.skip_byte_block = p->value.frac.num;\n\t\t\tcenc_info.crypt_byte_block = p->value.frac.den;\n\t\t}\n\n\n\t\tif (tkw->insert_pssh) {\n\t\t\tmp4_mux_cenc_insert_pssh(ctx, tkw, NULL, 0);\n\t\t\ttkw->insert_pssh = GF_FALSE;\n\t\t}\n\t}\n\n\tnb_items = gf_isom_get_meta_item_count(ctx->file, GF_TRUE, 0);\n\n\te = gf_isom_add_meta_item_memory(ctx->file, GF_TRUE, 0, item_name, &item_id, item_type, NULL, NULL, &image_props, (u8 *)data, size, NULL);\n\n\tif (config_box) gf_isom_box_del(config_box);\n\tif (free_config_ba) gf_free(image_props.config_ba);\n\n\tif (e) return e;\n\n\n\t//retrieve the final itemID\n\tgf_isom_get_meta_item_info(ctx->file, GF_TRUE, 0, nb_items+1, &item_id, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);\n\ttkw->item_id = item_id;\n\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_PRIMARY_ITEM);\n\tif (p && p->value.boolean) {\n\t\te = gf_isom_set_meta_primary_item(ctx->file, GF_TRUE, 0, item_id);\n\t\tif (e) return e;\n\t}\n\t//if primary item is not set, assign one\n\telse if (! gf_isom_get_meta_primary_item_id(ctx->file, GF_TRUE, 0)) {\n\t\te = gf_isom_set_meta_primary_item(ctx->file, GF_TRUE, 0, item_id);\n\t\tif (e) return e;\n\t}\n\n\tif (!ctx->major_brand_set) {\n\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_MIF1, 0);\n\t\tgf_isom_reset_alt_brands(ctx->file);\n\t\tctx->major_brand_set = 2;\n\t}\n\tif (media_brand && (ctx->major_brand_set==2)) {\n\t\tgf_isom_modify_alternate_brand(ctx->file, media_brand, 1);\n\t}\n#if 0\n\tif (e == GF_OK && meta->ref_type) {\n\t\te = gf_isom_meta_add_item_ref(file, meta->root_meta, tk, meta->item_id, meta->ref_item_id, meta->ref_type, NULL);\n\t}\n#endif\n\treturn GF_OK;\n}\n\nstatic void mp4mux_send_output(GF_MP4MuxCtx *ctx)\n{\n\tif (ctx->dst_pck) {\n\t\tif (ctx->notify_filename) {\n\t\t\tgf_filter_pck_set_framing(ctx->dst_pck, GF_TRUE, GF_FALSE);\n\t\t\tgf_filter_pck_set_property(ctx->dst_pck, GF_PROP_PCK_FILENUM, &PROP_UINT(ctx->cur_file_idx_plus_one-1) );\n\t\t\tif (ctx->cur_file_suffix) {\n\t\t\t\tgf_filter_pck_set_property(ctx->dst_pck, GF_PROP_PCK_FILESUF, &PROP_STRING_NO_COPY(ctx->cur_file_suffix) );\n\t\t\t\tctx->cur_file_suffix = NULL;\n\t\t\t}\n\t\t\tctx->notify_filename = 0;\n\t\t}\n\t\tgf_filter_pck_send(ctx->dst_pck);\n\t\tctx->dst_pck = NULL;\n\t}\n}\n\nstatic void mp4_mux_flush_frag_hls(GF_MP4MuxCtx *ctx)\n{\n\tGF_FilterEvent evt;\n\tTrackWriter *tkw = NULL;\n\n\t//send event on first track only\n\ttkw = gf_list_get(ctx->tracks, 0);\n\tGF_FEVT_INIT(evt, GF_FEVT_FRAGMENT_SIZE, tkw->ipid);\n\tevt.frag_size.is_last = ctx->flush_seg ? GF_TRUE : GF_FALSE;\n\tevt.frag_size.offset = ctx->frag_offset;\n\tevt.frag_size.size = ctx->frag_size;\n\tevt.frag_size.duration.num = (s64) ctx->frag_duration;\n\tevt.frag_size.duration.den = ctx->frag_timescale;\n\tevt.frag_size.independent = ctx->frag_has_intra;\n\n\tgf_filter_pid_send_event(tkw->ipid, &evt);\n\n\tctx->frag_offset += ctx->frag_size;\n\tctx->frag_size = 0;\n\tctx->frag_duration = 0;\n\tctx->frag_has_intra = GF_FALSE;\n}\n\nstatic GF_Err mp4_mux_on_data(void *cbk, u8 *data, u32 block_size, void *cbk_data, u32 cbk_magic);\n\nstatic void mp4_mux_flush_seg(GF_MP4MuxCtx *ctx, Bool is_init, u64 idx_start_range, u64 idx_end_range, Bool signal_flush)\n{\n\tGF_FilterEvent evt;\n\tTrackWriter *tkw = NULL;\n\n\tif (ctx->dst_pck) {\n\t\tif (!ctx->single_file) {\n\t\t\tBool s, e;\n\t\t\tgf_filter_pck_get_framing(ctx->dst_pck, &s, &e);\n\t\t\tgf_filter_pck_set_framing(ctx->dst_pck, s, GF_TRUE);\n\t\t\tif (!is_init) {\n\t\t\t\tu64 dur = ctx->next_seg_start - (ctx->min_cts_plus_one-1);\n\t\t\t\tgf_filter_pck_set_duration(ctx->dst_pck, (u32) dur);\n\t\t\t}\n\t\t\tctx->first_pck_sent = GF_FALSE;\n\t\t\tctx->current_offset = 0;\n\t\t\tif (is_init && s)\n\t\t\t\tgf_filter_pck_set_property(ctx->dst_pck, GF_PROP_PCK_INIT, &PROP_BOOL(GF_TRUE) );\n\t\t}\n\t\tif (is_init) {\n\t\t\tgf_filter_pck_set_dependency_flags(ctx->dst_pck, 0xFF);\n\t\t\tgf_filter_pck_set_carousel_version(ctx->dst_pck, 1);\n\t\t}\n\t\t//also inject m4cc after init seg - cf issue 2482\n\t\tif (is_init && ctx->eos_marker) {\n\t\t\tu8 data[8];\n\t\t\tmemset(data, 0, 8);\n\t\t\tdata[3] = 8;\n\t\t\tdata[4] = ctx->m4cc[0];\n\t\t\tdata[5] = ctx->m4cc[1];\n\t\t\tdata[6] = ctx->m4cc[2];\n\t\t\tdata[7] = ctx->m4cc[3];\n\t\t\tmp4_mux_on_data(ctx, data, 8, NULL, 0);\n\t\t}\n\t\tmp4mux_send_output(ctx);\n\t\tif (signal_flush)\n\t\t\tgf_filter_pid_send_flush(ctx->opid);\n\t}\n\tif (!is_init && ctx->llhls_mode && ctx->frag_size) {\n\t\tmp4_mux_flush_frag_hls(ctx);\n\t}\n\tif (ctx->dash_mode) {\n\t\t//send event on first track only\n\t\ttkw = gf_list_get(ctx->tracks, 0);\n\t\tGF_FEVT_INIT(evt, GF_FEVT_SEGMENT_SIZE, tkw->ipid);\n\t\tevt.seg_size.seg_url = NULL;\n\t\tevt.seg_size.is_init = is_init ? 1 : 0;\n\t\tif (!is_init || !idx_end_range) {\n\t\t\tevt.seg_size.media_range_start = ctx->current_offset;\n\t\t\tevt.seg_size.media_range_end = ctx->current_offset + ctx->current_size - 1;\n\t\t}\n\t\tif (idx_end_range && (ctx->vodcache==MP4MX_VODCACHE_INSERT))\n\t\t\tevt.seg_size.is_shift = 1;\n\n\t\tevt.seg_size.idx_range_start = idx_start_range;\n\t\tevt.seg_size.idx_range_end = idx_end_range;\n\t\tgf_filter_pid_send_event(tkw->ipid, &evt);\n\n\t\tctx->current_offset += ctx->current_size;\n\t\tctx->current_size = 0;\n\t\tctx->frag_offset = 0;\n\t\tctx->frag_size = 0;\n\t\tctx->frag_num = 0;\n\t\tctx->frag_has_intra = GF_FALSE;\n\t\t//changing file\n\t\tif (ctx->seg_name) {\n\t\t\tctx->first_pck_sent = GF_FALSE;\n\t\t}\n\t}\n}\n\nstatic GF_Err mp4_mux_initialize_movie(GF_MP4MuxCtx *ctx)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_Err e;\n\tu32 i, count = gf_list_count(ctx->tracks);\n\tTrackWriter *ref_tkw = NULL;\n\tu64 min_dts = 0;\n\tu32 min_dts_scale=0;\n\tu32 def_fake_dur=0;\n\tu32 def_fake_scale=0;\n#ifdef GF_ENABLE_CTRN\n\tu32 traf_inherit_base_id=0;\n#endif\n\tu32 nb_segments=0;\n\tGF_Fraction64 max_dur;\n\tctx->single_file = GF_TRUE;\n\tctx->current_offset = ctx->current_size = 0;\n\tmax_dur.den = 1;\n\tmax_dur.num = 0;\n\n\tif (ctx->sseg && ctx->noinit)\n\t\tctx->single_file = GF_FALSE;\n\n\tif (ctx->dur.num && ctx->dur.den) {\n\t\tmax_dur.num = ctx->dur.num;\n\t\tmax_dur.den = ctx->dur.den;\n\t}\n\n\t//make sure we have one sample from each PID. This will trigger potential pending reconfigure\n\t//for filters updating the PID caps before the first packet dispatch\n\tfor (i=0; i<count; i++) {\n\t\tconst GF_PropertyValue *p;\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tGF_FilterPacket *pck;\n\t\tif (tkw->fake_track) continue;\n\n\t\tpck = gf_filter_pid_get_packet(tkw->ipid);\n\t\tif (!pck) {\n\t\t\t//eos (wether real or flush event), continue setup\n\t\t\tif (gf_filter_pid_is_eos(tkw->ipid)) {\n\t\t\t\tif (tkw->dgl_copy) {\n\t\t\t\t\tgf_filter_pck_discard(tkw->dgl_copy);\n\t\t\t\t\ttkw->dgl_copy = NULL;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tif (!ctx->dash_mode && !ctx->cur_file_idx_plus_one) {\n\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILENUM);\n\t\t\tif (p) {\n\t\t\t\tctx->cur_file_idx_plus_one = p->value.uint + 1;\n\t\t\t\tif (!ctx->cur_file_suffix) {\n\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILESUF);\n\t\t\t\t\tif (p && p->value.string) ctx->cur_file_suffix = gf_strdup(p->value.string);\n\t\t\t\t}\n\t\t\t\tctx->notify_filename = GF_TRUE;\n\t\t\t}\n\t\t}\n\n\t\tif (tkw->cenc_state==CENC_NEED_SETUP) {\n\t\t\tmp4_mux_cenc_update(ctx, tkw, pck, CENC_CONFIG, 0, 0);\n\t\t}\n\n\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILENAME);\n\t\tif (p && strlen(p->value.string)) ctx->single_file = GF_FALSE;\n\n\t\tdef_fake_dur = gf_filter_pck_get_duration(pck);\n\t\tdef_fake_scale = tkw->src_timescale;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DURATION);\n\t\tif (p && p->value.lfrac.den) {\n\t\t\ttkw->pid_dur = p->value.lfrac;\n\t\t\tif (tkw->pid_dur.num<0) tkw->pid_dur.num = -tkw->pid_dur.num;\n\t\t\tif (gf_timestamp_less(max_dur.num, max_dur.den, tkw->pid_dur.num, tkw->pid_dur.den)) {\n\t\t\t\tmax_dur.num = tkw->pid_dur.num;\n\t\t\t\tmax_dur.den = tkw->pid_dur.den;\n\t\t\t}\n\t\t}\n#ifdef GF_ENABLE_CTRN\n\t\tif (tkw->codecid==GF_CODECID_HEVC)\n\t\t\ttraf_inherit_base_id = tkw->track_id;\n#endif\n\t}\n\t//good to go, finalize for fragments\n\tfor (i=0; i<count; i++) {\n\t\tu32 def_pck_dur;\n\t\tu32 def_samp_size=0;\n\t\tu8 def_is_rap;\n#ifdef GF_ENABLE_CTRN\n\t\tu32 inherit_traf_from_track = 0;\n#endif\n\t\tu64 dts;\n\t\tconst GF_PropertyValue *p;\n\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\n\t\tif (tkw->fake_track) {\n\t\t\tif (def_fake_scale) {\n\t\t\t\tdef_pck_dur = def_fake_dur;\n\t\t\t\tdef_pck_dur *= tkw->src_timescale;\n\t\t\t\tdef_pck_dur /= def_fake_scale;\n\t\t\t} else {\n\t\t\t\tdef_pck_dur = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tGF_FilterPacket *pck = gf_filter_pid_get_packet(tkw->ipid);\n\t\t\t//can be null if eos\n\t\t\tif (pck) {\n\t\t\t\tu32 tscale;\n\t\t\t\t//otherwise setup fragmentation, using first sample desc as default idx\n\t\t\t\t//first pck dur as default\n\t\t\t\tdef_pck_dur = gf_filter_pck_get_duration(pck);\n\n\t\t\t\tdts = gf_filter_pck_get_dts(pck);\n\t\t\t\tif (dts == GF_FILTER_NO_TS)\n\t\t\t\t\tdts = gf_filter_pck_get_cts(pck);\n\t\t\t\ttscale = gf_filter_pck_get_timescale(pck);\n\n\t\t\t\tif (!min_dts || gf_timestamp_greater(min_dts, min_dts_scale, dts, tscale)) {\n\t\t\t\t\tmin_dts = dts;\n\t\t\t\t\tmin_dts_scale = tscale;\n\t\t\t\t}\n\t\t\t\tif (tkw->raw_audio_bytes_per_sample) {\n\t\t\t\t\tu32 pck_size;\n\t\t\t\t\tgf_filter_pck_get_data(pck, &pck_size);\n\t\t\t\t\tpck_size /= tkw->raw_audio_bytes_per_sample;\n\t\t\t\t\tif (pck_size)\n\t\t\t\t\t\tdef_pck_dur /= pck_size;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//check if we have a default constant duration set, if so use it\n\t\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CONSTANT_DURATION);\n\t\t\t\tdef_pck_dur = p ? p->value.uint : 0;\n\t\t\t}\n\t\t\tif (tkw->raw_audio_bytes_per_sample)\n\t\t\t\tdef_samp_size = tkw->raw_audio_bytes_per_sample;\n\t\t}\n\t\tif (tkw->src_timescale != tkw->tk_timescale) {\n\t\t\tdef_pck_dur *= tkw->tk_timescale;\n\t\t\tdef_pck_dur /= tkw->src_timescale;\n\t\t}\n\n\t\t//and consider audio & text all RAPs, the rest not rap - this will need refinement later on\n\t\t//but won't break the generated files\n\t\tswitch (tkw->stream_type) {\n\t\tcase GF_STREAM_AUDIO:\n\t\tcase GF_STREAM_TEXT:\n\t\t\tdef_is_rap = GF_ISOM_FRAG_DEF_IS_SYNC;\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_HAS_SYNC);\n\t\t\tif (p && p->value.boolean)\n\t\t\t\tdef_is_rap = 0;\n\t\t\tbreak;\n\t\tcase GF_STREAM_VISUAL:\n\t\t\tswitch (tkw->codecid) {\n\t\t\tcase GF_CODECID_PNG:\n\t\t\tcase GF_CODECID_JPEG:\n\t\t\tcase GF_CODECID_J2K:\n\t\t\t\tbreak;\n\t\t\tcase GF_CODECID_HEVC_TILES:\n#ifdef GF_ENABLE_CTRN\n\t\t\t\tif (ctx->ctrn && ctx->ctrni)\n\t\t\t\t\tinherit_traf_from_track = traf_inherit_base_id;\n#endif\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!ref_tkw) ref_tkw = tkw;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdef_is_rap = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdef_is_rap = 0;\n\t\t\tbreak;\n\t\t}\n\t\t//CMAF 7.5.17, if non-sync sample are present stss SHALL be present and empty...\n\t\tif (ctx->cmaf && !def_is_rap) {\n\t\t\tdef_is_rap |= GF_ISOM_FRAG_USE_SYNC_TABLE;\n\t\t}\n\n\t\tmp4_mux_set_hevc_groups(ctx, tkw);\n\n\t\t//use 1 for the default sample description index. If no multi stsd, this is always the case\n\t\t//otherwise we need to update the stsd idx in the traf headers\n\t\te = gf_isom_setup_track_fragment(ctx->file, tkw->track_id, tkw->stsd_idx, def_pck_dur, def_samp_size, def_is_rap, 0, 0, ctx->nofragdef ? GF_TRUE : GF_FALSE);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to setup fragmentation for track ID %d: %s\\n\", tkw->track_id, gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (ctx->refrag) {\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_TREX_TEMPLATE);\n\t\t\tif (p) {\n\t\t\t\tgf_isom_setup_track_fragment_template(ctx->file, tkw->track_id, p->value.data.ptr, p->value.data.size, ctx->nofragdef);\n\t\t\t} else if (!ctx->nofragdef) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Refragmentation with default track fragment flags signaling but no TREX found in source track %d, using defaults computed from PID, result might be broken\\n\", tkw->track_id));\n\t\t\t}\n\t\t}\n#endif\n\n\n\t\tif (ctx->tfdt.den && ctx->tfdt.num) {\n\t\t\ttkw->tfdt_offset = gf_timestamp_rescale(ctx->tfdt.num, ctx->tfdt.den, tkw->tk_timescale);\n\t\t}\n\n\t\tif (tkw->fake_track) {\n\t\t\tgf_list_del_item(ctx->tracks, tkw);\n\t\t\tif (ref_tkw==tkw) ref_tkw=NULL;\n\t\t\tmp4_mux_track_writer_del(tkw);\n\t\t\ti--;\n\t\t\tcount--;\n\t\t\tcontinue;\n\t\t}\n\n#ifdef GF_ENABLE_CTRN\n\t\tif (inherit_traf_from_track)\n\t\t\tgf_isom_enable_traf_inherit(ctx->file, tkw->track_id, inherit_traf_from_track);\n#endif\n\n\t\tif (!tkw->box_patched) {\n\t\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"boxpatch\");\n\t\t\tif (p && p->value.string) {\n\t\t\t\te = gf_isom_apply_box_patch(ctx->file, tkw->track_id, p->value.string, GF_FALSE);\n\t\t\t\tif (e) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to apply box patch %s to track %d: %s\\n\",\n\t\t\t\t\t\tp->value.string, tkw->track_id, gf_error_to_string(e) ));\n\t\t\t\t}\n\t\t\t}\n\t\t\ttkw->box_patched = GF_TRUE;\n\t\t}\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DASH_SEGMENTS);\n\t\tif (p && (p->value.uint>nb_segments))\n\t\t\tnb_segments = p->value.uint;\n\n\t\tif (!ctx->dash_mode)\n\t\t\tgf_isom_purge_track_reference(ctx->file, tkw->track_num);\n\t}\n\n\tif (max_dur.num && max_dur.den) {\n\t\tu64 mdur = max_dur.num;\n\t\tif (ctx->moovts != max_dur.den) {\n\t\t\tmdur *= (u32) ctx->moovts;\n\t\t\tmdur /= max_dur.den;\n\t\t}\n\t\tgf_isom_set_movie_duration(ctx->file, mdur, GF_FALSE);\n\t}\n\telse if (ctx->cmaf) {\n\t\t//CMAF 7.3.2.1.c.6) \"The MovieExtendsBox may contain a MovieExtendsHeaderBox,\n\t\t//as defined in ISO/IEC 14496-12, and if so, shall provide the overall duration\n\t\t//of the CMAF track. If the duration is unknown, this box shall be omitted.\"\n\t\tgf_isom_set_movie_duration(ctx->file, 0, GF_TRUE);\n\t}\n\n\t//if we have an explicit track reference for fragmenting, move it first in our list\n\tif (ref_tkw) {\n\t\tgf_list_del_item(ctx->tracks, ref_tkw);\n\t\tgf_list_insert(ctx->tracks, ref_tkw, 0);\n\t}\n\tctx->ref_tkw = gf_list_get(ctx->tracks, 0);\n\n\tif (!ctx->abs_offset) {\n\t\tu32 mval = ctx->dash_mode ? '6' : '5';\n\t\tu32 mbrand, mcount, found=0;\n\t\tu8 szB[GF_4CC_MSIZE];\n\t\tgf_isom_set_fragment_option(ctx->file, 0, GF_ISOM_TFHD_FORCE_MOOF_BASE_OFFSET, 1);\n\n\t\tgf_isom_get_brand_info(ctx->file, &mbrand, NULL, &mcount);\n\t\tstrcpy(szB, gf_4cc_to_str(mbrand));\n\t\tif (!strncmp(szB, \"iso\", 3) && (szB[3] >= mval) && (szB[3] <= 'F') ) found = 1;\n\t\ti=0;\n\t\twhile (!found && (i<mcount)) {\n\t\t\ti++;\n\t\t\tgf_isom_get_alternate_brand(ctx->file, i, &mbrand);\n\t\t\tstrcpy(szB, gf_4cc_to_str(mbrand));\n\t\t\tif (!strncmp(szB, \"iso\", 3) && (szB[3] >= mval) && (szB[3] <= 'F') ) found = 1;\n\t\t}\n\n\t\t/*because of movie fragments MOOF based offset, ISOM <4 is forbidden*/\n\t\tif (!found) {\n\t\t\tgf_isom_set_brand_info(ctx->file, ctx->dash_mode ? GF_ISOM_BRAND_ISO6 : GF_ISOM_BRAND_ISO5, 1);\n\t\t}\n\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO1, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO2, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO3, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO4, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_AVC1, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_MP41, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_MP42, GF_FALSE);\n\t}\n\n\tif (ctx->dash_mode) {\n\t\t/*DASH self-init media segment*/\n\t\tif (ctx->dash_mode==MP4MX_DASH_VOD) {\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_DSMS, GF_TRUE);\n\t\t} else {\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_DASH, GF_TRUE);\n\t\t}\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_MSIX, ((ctx->dash_mode==MP4MX_DASH_VOD) && (ctx->subs_sidx>=0)) ? GF_TRUE : GF_FALSE);\n\t}\n\n\tif (ctx->boxpatch && !ctx->box_patched) {\n\t\te = gf_isom_apply_box_patch(ctx->file, 0, ctx->boxpatch, GF_FALSE);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to apply box patch %s: %s\\n\", ctx->boxpatch, gf_error_to_string(e) ));\n\t\t}\n\t\tctx->box_patched = GF_TRUE;\n\t}\n\n\te = gf_isom_finalize_for_fragment(ctx->file, ctx->dash_mode ? 1 : 0, ctx->mvex);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to finalize moov for fragmentation: %s\\n\", gf_error_to_string(e) ));\n\t\treturn e;\n\t}\n\tctx->init_movie_done = GF_TRUE;\n\n\tif (min_dts_scale) {\n\t\tu64 rs_dts = gf_timestamp_rescale(min_dts, min_dts_scale, ctx->cdur.den);\n\t\tctx->next_frag_start = rs_dts;\n\t}\n\tctx->next_frag_start += ctx->cdur.num;\n\tctx->adjusted_next_frag_start = ctx->next_frag_start;\n\tctx->fragment_started = GF_FALSE;\n\n\tif (ctx->noinit) {\n\t\tif (ctx->dst_pck) gf_filter_pck_discard(ctx->dst_pck);\n\t\tctx->dst_pck = NULL;\n\t\tctx->current_size = ctx->current_offset = 0;\n\t\tctx->first_pck_sent = GF_FALSE;\n\t} else {\n\t\tmp4_mux_flush_seg(ctx, GF_TRUE, 0, 0, GF_TRUE);\n\t}\n\tassert(!ctx->dst_pck);\n\n\t//change major brand for segments\n\tif (ctx->styp && (strlen(ctx->styp)>=4)) {\n\t\tu32 styp_brand = GF_4CC(ctx->styp[0], ctx->styp[1], ctx->styp[2], ctx->styp[3]);\n\t\tu32 version = 0;\n\t\tchar *sep = strchr(ctx->styp, '.');\n\t\tif (sep) version = atoi(sep+1);\n\t\tgf_isom_set_brand_info(ctx->file, styp_brand, version);\n\t}\n\n\tif (ctx->dash_mode==MP4MX_DASH_VOD) {\n\t\tif ((ctx->vodcache==MP4MX_VODCACHE_REPLACE) && !nb_segments && (!ctx->media_dur || !ctx->dash_dur.num) ) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Media duration unknown, cannot use replace mode of vodcache, using temp file for VoD storage\\n\"));\n\t\t\tctx->vodcache = MP4MX_VODCACHE_ON;\n\t\t\te = mp4mx_setup_dash_vod(ctx, NULL);\n\t\t\tif (e) return e;\n\t\t}\n\n\t\tif (ctx->vodcache==MP4MX_VODCACHE_REPLACE) {\n\t\t\tGF_BitStream *bs;\n\t\t\tu8 *output;\n\t\t\tchar *msg;\n\t\t\tGF_FilterPacket *pck;\n\t\t\tu32 len;\n\t\t\tBool exact_sidx = GF_TRUE;\n\n\t\t\tif (!nb_segments) {\n\t\t\t\texact_sidx = GF_FALSE;\n\t\t\t\tnb_segments = (u32) ( ctx->media_dur * ctx->dash_dur.den / ctx->dash_dur.num);\n\t\t\t\t//always add an extra segment\n\t\t\t\tnb_segments ++;\n\t\t\t\t//and safety alloc of 10%\n\t\t\t\tif (nb_segments>10)\n\t\t\t\t\tnb_segments += 10*nb_segments/100;\n\t\t\t\telse\n\t\t\t\t\tnb_segments ++;\n\t\t\t}\n\n\t\t\t//max sidx size: full box + sidx fields + timing 64 bit + nb segs (each 12 bytes)\n\t\t\tctx->sidx_max_size = 12 + (12 + 16) + 12 * nb_segments;\n\n\t\t\t//we produce an ssix, add full box + nb subsegs + nb_segments * (range_count=2 + 2*(range+size))\n\t\t\tif (ctx->ssix) {\n\t\t\t\tctx->sidx_max_size += 12 + 4 + nb_segments * 12;\n\t\t\t}\n\n\t\t\tif (!exact_sidx) {\n\t\t\t\t//and a free box\n\t\t\t\tctx->sidx_max_size += 8;\n\t\t\t\tctx->sidx_size_exact = GF_FALSE;\n\t\t\t} else {\n\t\t\t\tctx->sidx_size_exact = GF_TRUE;\n\t\t\t}\n\t\t\tctx->sidx_chunk_offset = (u32) (ctx->current_offset + ctx->current_size);\n\t\t\t//send a dummy packet\n\t\t\tpck = gf_filter_pck_new_alloc(ctx->opid, ctx->sidx_max_size, &output);\n\t\t\tif (!pck) return GF_OUT_OF_MEM;\n\n\t\t\tgf_filter_pck_set_framing(pck, GF_FALSE, GF_FALSE);\n\t\t\t//format as free box for now\n\t\t\tbs = gf_bs_new(output, ctx->sidx_max_size, GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_u32(bs, ctx->sidx_max_size);\n\t\t\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_FREE);\n\t\t\tmsg = \"GPAC \" GPAC_VERSION\" SIDX placeholder\";\n\t\t\tlen = (u32) strlen(msg);\n\t\t\tif (len+8>ctx->sidx_max_size) len = ctx->sidx_max_size - 8;\n\t\t\tgf_bs_write_data(bs, msg, len );\n\t\t\tgf_bs_del(bs);\n\t\t\tgf_filter_pck_send(pck);\n\n\t\t\tctx->current_offset += ctx->sidx_max_size;\n\t\t} else if (ctx->vodcache==MP4MX_VODCACHE_ON) {\n\t\t\tctx->store_output = GF_TRUE;\n\t\t} else {\n\t\t\tctx->store_output = GF_FALSE;\n\t\t\tctx->sidx_chunk_offset = (u32) (ctx->current_offset + ctx->current_size);\n\t\t}\n\t\tgf_isom_allocate_sidx(ctx->file, ctx->subs_sidx, ctx->chain_sidx, 0, NULL, NULL, NULL, ctx->ssix);\n\t}\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\nstatic GF_Err mp4_mux_start_fragment(GF_MP4MuxCtx *ctx, GF_FilterPacket *pck)\n{\n\tGF_Err e;\n\tu32 i, count = gf_list_count(ctx->tracks);\n\tBool has_tfdt=GF_FALSE;\n\tGF_ISOStartFragmentFlags flags=0;\n\n\t//setup some default\n\tgf_isom_set_next_moof_number(ctx->file, ctx->msn);\n\tctx->msn += ctx->msninc;\n\tctx->min_cts_plus_one = 0;\n\n\tif (ctx->moof_first) flags |= GF_ISOM_FRAG_MOOF_FIRST;\n#ifdef GF_ENABLE_CTRN\n\tif (ctx->ctrn) flags |= GF_ISOM_FRAG_USE_COMPACT;\n#endif\n\n\te = gf_isom_start_fragment(ctx->file, flags);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to start new fragment: %s\\n\", gf_error_to_string(e) ));\n\t\treturn e;\n\t}\n\tif (pck) {\n\t\tconst GF_PropertyValue *p = gf_filter_pck_get_property(pck, GF_PROP_PCK_MOOF_TEMPLATE);\n\t\tif (p && p->value.data.ptr) {\n\t\t\tGF_SegmentIndexBox *out_sidx = NULL;\n\t\t\tgf_isom_set_fragment_template(ctx->file, p->value.data.ptr, p->value.data.size, &has_tfdt, &out_sidx);\n\t\t\tif (out_sidx) {\n\t\t\t\tif (ctx->cloned_sidx) gf_isom_box_del((GF_Box *)ctx->cloned_sidx);\n\t\t\t\tctx->cloned_sidx = out_sidx;\n\t\t\t\tctx->cloned_sidx_index = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t//setup some default\n\tfor (i=0; i<count; i++) {\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\te = GF_OK;\n\t\tif (ctx->strun) {\n\t\t\te = gf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRAF_RANDOM_ACCESS, 0);\n\t\t}\n\t\t//fragment at sap boundaries for video, but not in dash mode (compatibility with old arch)\n\t\telse if (ctx->fsap && (tkw->stream_type == GF_STREAM_VISUAL) && !ctx->dash_mode) {\n\t\t\te = gf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRAF_RANDOM_ACCESS, 1);\n\t\t}\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Unable set fragment options: %s\\n\", gf_error_to_string(e) ));\n\t\t}\n\t\ttkw->fragment_done = GF_FALSE;\n\t\ttkw->insert_tfdt = (has_tfdt || ctx->tfdt_traf || tkw->tfdt_offset) ? GF_TRUE : ctx->insert_tfdt;\n\t\ttkw->dur_in_frag = 0;\n\n\t\tif (ctx->trun_inter) {\n\t\t\tgf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRUN_SET_INTERLEAVE_ID, 0);\n\t\t}\n\t\tif (ctx->truns_first) {\n\t\t\tgf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRAF_TRUNS_FIRST, 1);\n\t\t}\n\t\t//7.7 cmf2 For video CMAF Tracks not contained in Track Files, Version 1 shall be used.\n\t\tif ((ctx->cmaf==MP4MX_CMAF_CMF2) && (tkw->stream_type==GF_STREAM_VISUAL))\n\t\t\tgf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRAF_TRUN_V1, 1);\n\n\t\tif (ctx->sdtp_traf)\n\t\t\tgf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRAF_USE_SAMPLE_DEPS_BOX, ctx->sdtp_traf);\n\n\t\tif (ctx->tfdt64)\n\t\t\tgf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRAF_USE_LARGE_TFDT, ctx->tfdt64);\n\n\t\tif (tkw->dyn_pssh) {\n\t\t\tmp4_mux_cenc_insert_pssh(ctx, tkw, NULL, 2);\n\t\t}\n\t\telse if (ctx->insert_pssh)\n\t\t\tmp4_mux_cenc_insert_pssh(ctx, tkw, NULL, 1);\n\t}\n\tctx->fragment_started = GF_TRUE;\n\tctx->insert_tfdt = GF_FALSE;\n\tctx->insert_pssh = GF_FALSE;\n\treturn GF_OK;\n}\n\nstatic GF_Err mp4_mux_flush_fragmented(GF_MP4MuxCtx *ctx)\n{\n\tGF_FilterPacket *pck;\n\tu8 *output;\n\tu32 nb_read, blocksize = ctx->block_size;\n\tif (ctx->flush_done + blocksize>ctx->flush_size) {\n\t\tblocksize = (u32) (ctx->flush_size - ctx->flush_done);\n\t}\n\tif (!blocksize) return GF_EOS;\n\tpck = gf_filter_pck_new_alloc(ctx->opid, blocksize, &output);\n\tif (!pck) return GF_OUT_OF_MEM;\n\n\tnb_read = (u32) gf_fread(output, blocksize, ctx->tmp_store);\n\tif (nb_read != blocksize) {\n\t\tchar tmp[1];\n\t\t//weird behavior on some file systems, dump debug info\n\t\tgf_fread(tmp, 1, ctx->tmp_store);\n\t\tBool is_eof = gf_feof(ctx->tmp_store);\n\t\tGF_LOG(is_eof ? GF_LOG_WARNING : GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error reading from VOD temp cache, read %d bytes but asked %d bytes\\n\\tCache EOF %d - cache size \"LLU\" - read pos \"LLU\" - file pos \"LLU\"\\n\", nb_read, blocksize, is_eof, ctx->flush_size, ctx->flush_done, gf_ftell(ctx->tmp_store)));\n\t}\n\tctx->flush_done += nb_read;\n\tif (ctx->flush_done==ctx->flush_size) {\n\t\tgf_filter_pck_set_framing(pck, GF_FALSE, GF_TRUE);\n\t\tgf_filter_pck_send(pck);\n\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\treturn GF_EOS;\n\t}\n\tgf_filter_pck_set_framing(pck, GF_FALSE, GF_FALSE);\n\tgf_filter_pck_send(pck);\n\t//we are not done flushing but we have no more input packets, signal we still need processing\n\tgf_filter_ask_rt_reschedule(ctx->filter, 1);\n\treturn GF_OK;\n}\n\nstatic void mp4mx_frag_box_patch(GF_MP4MuxCtx *ctx)\n{\n\tGF_Err e;\n\tu32 i, count = gf_list_count(ctx->tracks);\n\tfor (i=0; i<count; i++) {\n\t\tconst GF_PropertyValue *p;\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tif (!tkw->track_id) continue;\n\t\t//no box patched set (todo, do we want to allow changing boxpatch props ?)\n\t\tif (!tkw->box_patched) continue;\n\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"boxpatch\");\n\t\tif (p && p->value.string) {\n\t\t\te = gf_isom_apply_box_patch(ctx->file, tkw->track_id ? tkw->track_id : tkw->item_id, p->value.string, GF_TRUE);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to apply box patch %s to track fragment %d: %s\\n\",\n\t\t\t\t\tp->value.string, tkw->track_id, gf_error_to_string(e) ));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ctx->boxpatch) {\n\t\te = gf_isom_apply_box_patch(ctx->file, 0, ctx->boxpatch, GF_TRUE);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to apply box patch %s to fragment: %s\\n\", ctx->boxpatch, gf_error_to_string(e) ));\n\t\t}\n\t\tctx->box_patched = GF_TRUE;\n\t}\n}\n#endif // GPAC_DISABLE_ISOM_FRAGMENTS\n\n\nstatic GF_Err mp4_mux_initialize(GF_Filter *filter);\n\nGF_Err mp4mx_reload_output(GF_MP4MuxCtx *ctx)\n{\n\tGF_Err e;\n\tu32 i, count = gf_list_count(ctx->tracks);\n\n\t//done with the file\n\tif (ctx->file) {\n\t\te = mp4_mux_done(ctx, GF_FALSE);\n\t\tif (e) return e;\n\t\tctx->file = NULL;\n\t}\n\tctx->init_movie_done = GF_FALSE;\n\te = mp4_mux_initialize(ctx->filter);\n\tif (e) return e;\n\tctx->config_timing = GF_TRUE;\n\n\tfor (i=0; i<count; i++) {\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\ttkw->suspended = GF_FALSE;\n\t\ttkw->track_num = 0;\n\t\ttkw->nb_samples = 0;\n\t\ttkw->max_cts = 0;\n\t\ttkw->min_cts = (u64) -1;\n\t\te = mp4_mux_configure_pid(ctx->filter, tkw->ipid, GF_FALSE);\n\t\tif (e) return e;\n\t\ttkw->nb_samples = 0;\n\t\ttkw->sample.DTS = 0;\n\t\ttkw->sample.CTS_Offset = 0;\n\t\ttkw->samples_in_stsd = 0;\n\t\ttkw->samples_in_frag = 0;\n\t}\n\tassert(ctx->next_file_idx);\n\tctx->cur_file_idx_plus_one = ctx->next_file_idx;\n\tctx->next_file_idx = 0;\n\tctx->notify_filename = GF_TRUE;\n\tassert(!ctx->cur_file_suffix);\n\tif (ctx->next_file_suffix) {\n\t\tctx->cur_file_suffix = gf_strdup(ctx->next_file_suffix);\n\t\tctx->next_file_suffix = NULL;\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err mp4_mux_process_fragmented(GF_MP4MuxCtx *ctx)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_Err e = GF_OK;\n\tu32 nb_eos, nb_done, nb_suspended, i, count;\n\n\tif (ctx->flush_size) {\n\t\treturn mp4_mux_flush_fragmented(ctx);\n\t}\n\n\tif (!ctx->file)\n\t\treturn GF_EOS;\n\n\t//init movie not yet produced\n\tif (!ctx->init_movie_done) {\n\t\te = mp4_mux_initialize_movie(ctx);\n\t\tif (e) return e;\n\t\tif (!ctx->init_movie_done)\n\t\t\treturn GF_OK;\n\t}\n\t/*get count after init, some tracks may have been remove*/\n\tcount = gf_list_count(ctx->tracks);\n\n\t//process pid by pid\n\tnb_eos=0;\n\tnb_done = 0;\n\tnb_suspended = 0;\n\tfor (i=0; i<count; i++) {\n\t\tu64 cts, dts, ncts;\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\n\t\tif (ctx->fragment_started && tkw->fragment_done) {\n\t\t\tnb_done ++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (tkw->suspended) {\n\t\t\tif (ctx->fragment_started) nb_done++;\n\t\t\tnb_suspended++;\n\t\t\tcontinue;\n\t\t}\n\n\t\twhile (1) {\n\t\t\tconst GF_PropertyValue *p;\n\t\t\tu32 orig_frag_bounds=0;\n\t\t\tGF_FilterPacket *pck = gf_filter_pid_get_packet(tkw->ipid);\n\n\t\t\tif (!pck) {\n\t\t\t\tif (gf_filter_pid_is_eos(tkw->ipid)) {\n\t\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\t\tif (ctx->dash_mode) ctx->flush_seg = GF_TRUE;\n\t\t\t\t\tif (ctx->next_file_idx)\n\t\t\t\t\t\tnb_suspended++;\n\t\t\t\t\tnb_done ++;\n\t\t\t\t\tif (tkw->dgl_copy) {\n\t\t\t\t\t\tgf_filter_pck_discard(tkw->dgl_copy);\n\t\t\t\t\t\ttkw->dgl_copy = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (!gf_filter_pid_is_flush_eos(tkw->ipid))\n\t\t\t\t\t\tnb_eos++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tif (tkw->aborted) {\n\t\t\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\t\t\t\tnb_eos++;\n\t\t\t\tnb_done ++;\n\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\tif (ctx->dash_mode) ctx->flush_seg = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//we create dash segment only when we know we have a packet, not before this loop.\n\t\t\t//This allows taking into account flush signals, otherwise we would create empty segments\n\t\t\tif (ctx->dash_mode && !ctx->segment_started) {\n\t\t\t\tctx->segment_started = GF_TRUE;\n\t\t\t\tctx->insert_tfdt = GF_TRUE;\n\t\t\t\tswitch (ctx->psshs) {\n\t\t\t\tcase MP4MX_PSSH_MOOF:\n\t\t\t\tcase MP4MX_PSSH_BOTH:\n\t\t\t\t\tctx->insert_pssh = GF_TRUE; break;\n\t\t\t\tdefault:\n\t\t\t\t\tctx->insert_pssh = GF_FALSE; break;\n\t\t\t\t}\n\t\t\t\tgf_isom_start_segment(ctx->file, ctx->single_file ? NULL : \"_gpac_isobmff_redirect\", GF_FALSE);\n\t\t\t}\n\n\t\t\tcts = gf_filter_pck_get_cts(pck);\n\n\t\t\tif (cts == GF_FILTER_NO_TS) {\n\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_EODS);\n\t\t\t\tif (p && p->value.boolean) {\n\t\t\t\t\tnb_done ++;\n\t\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\t\ttkw->samples_in_frag = 0;\n\t\t\t\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\t\t\t\t\tctx->flush_seg = GF_TRUE;\n\t\t\t\t\ttkw->next_seg_cts = tkw->cts_next;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MuxIsom] Packet with no CTS assigned, cannot store to track, ignoring\\n\"));\n\t\t\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FRAG_START);\n\t\t\tif (p) {\n\t\t\t\torig_frag_bounds = p->value.uint;\n\n\t\t\t\tif (orig_frag_bounds==2) {\n\t\t\t\t\tif (!ctx->segment_started) {\n\t\t\t\t\t\tctx->dash_mode = 1;\n\t\t\t\t\t\tctx->insert_tfdt = GF_TRUE;\n\t\t\t\t\t\tgf_isom_start_segment(ctx->file, ctx->single_file ? NULL : \"_gpac_isobmff_redirect\", GF_FALSE);\n\t\t\t\t\t} else if (tkw->samples_in_frag) {\n\t\t\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\t\t\ttkw->samples_in_frag = 0;\n\t\t\t\t\t\tnb_done ++;\n\t\t\t\t\t\t//make sure we flush until the end of the segment\n\t\t\t\t\t\tctx->flush_seg = GF_TRUE;\n\t\t\t\t\t\t//store CTS of next packet (first in next segment) for sidx compute\n\t\t\t\t\t\ttkw->next_seg_cts = cts;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//get dash/file segment number\n\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILENUM);\n\n\t\t\t//not dash and file end, we need to wait for all streams and resetup\n\t\t\tif (!ctx->dash_mode && p) {\n\t\t\t\tif (!ctx->cur_file_idx_plus_one) {\n\t\t\t\t\tctx->cur_file_idx_plus_one = p->value.uint + 1;\n\t\t\t\t\tif (!ctx->cur_file_suffix) {\n\t\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILESUF);\n\t\t\t\t\t\tif (p && p->value.string) ctx->cur_file_suffix = gf_strdup(p->value.string);\n\t\t\t\t\t}\n\t\t\t\t\tctx->notify_filename = GF_TRUE;\n\t\t\t\t} else if (ctx->cur_file_idx_plus_one == p->value.uint+1) {\n\t\t\t\t} else if (!tkw->suspended) {\n\t\t\t\t\ttkw->suspended = GF_TRUE;\n\t\t\t\t\tnb_suspended++;\n\t\t\t\t\tctx->next_file_idx =  p->value.uint + 1;\n\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILESUF);\n\t\t\t\t\tif (p && p->value.string)\n\t\t\t\t\t\tctx->next_file_suffix = p->value.string;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif (!ctx->fragment_started) {\n\t\t\t\te = mp4_mux_start_fragment(ctx, orig_frag_bounds ? pck : NULL);\n\t\t\t\tif (e) return e;\n\n\t\t\t\t//push emsgonce the segment is started\n\t\t\t\tconst GF_PropertyValue *emsg = gf_filter_pck_get_property_str(pck, \"grp_EMSG\");\n\t\t\t\tif (emsg && (emsg->type==GF_PROP_DATA) && emsg->value.data.ptr) {\n\t\t\t\t\tGF_Err gf_isom_set_emsg(GF_ISOFile *movie, u8 *data, u32 size);\n\n\t\t\t\t\tgf_isom_set_emsg(ctx->file, emsg->value.data.ptr, emsg->value.data.size);\n\t\t\t\t}\n\n\t\t\t\tctx->nb_frags++;\n\t\t\t\tif (ctx->dash_mode)\n\t\t\t\t\tctx->nb_frags_in_seg++;\n\n\t\t\t}\n\n\n\t\t\tif (ctx->dash_mode) {\n\t\t\t\tif (p) {\n\t\t\t\t\t//start of next segment, abort fragmentation for this track and flush all other writers\n\t\t\t\t\tif (ctx->dash_seg_num_plus_one && (ctx->dash_seg_num_plus_one != 1 + p->value.uint) ) {\n\t\t\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\t\t\ttkw->samples_in_frag = 0;\n\t\t\t\t\t\tnb_done ++;\n\t\t\t\t\t\t//make sure we flush until the end of the segment\n\t\t\t\t\t\tctx->flush_seg = GF_TRUE;\n\t\t\t\t\t\t//store CTS of next packet (first in next segment) for sidx compute\n\t\t\t\t\t\ttkw->next_seg_cts = cts;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//start of current segment, remember segment number and name\n\t\t\t\t\tctx->dash_seg_num_plus_one = 1 + p->value.uint;\n\t\t\t\t\t//get file name prop if any - only send on one pid for muxed content\n\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILENAME);\n\t\t\t\t\tif (p && p->value.string) {\n\t\t\t\t\t\tif (ctx->seg_name) gf_free(ctx->seg_name);\n\t\t\t\t\t\tctx->seg_name = gf_strdup(p->value.string);\n\t\t\t\t\t}\n\t\t\t\t\t//store PRFT only for reference track at segment start\n\t\t\t\t\tif (tkw==ctx->ref_tkw) {\n\t\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_SENDER_NTP);\n\t\t\t\t\t\tif (p) {\n\t\t\t\t\t\t\tgf_isom_set_fragment_reference_time(ctx->file, tkw->track_id, p->value.longuint, cts);\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[MuxIsom] Segment %s, storing NTP TS \"LLU\" for CTS \"LLU\" at \"LLU\" us, at UTC \"LLU\"\\n\", ctx->seg_name ? ctx->seg_name : \"singlefile\", p->value.longuint, cts, gf_sys_clock_high_res(), gf_net_get_utc()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdts = gf_filter_pck_get_dts(pck);\n\t\t\t\tif (dts==GF_FILTER_NO_TS) dts = cts;\n\t\t\t\tif (tkw->first_dts_in_seg_plus_one && (tkw->first_dts_in_seg_plus_one - 1 > dts))\n\t\t\t\t\ttkw->first_dts_in_seg_plus_one = 1 + dts;\n\t\t\t}\n\t\t\tncts = cts + gf_filter_pck_get_duration(pck);\n\t\t\tif (tkw->cts_next < ncts)\n\t\t\t\ttkw->cts_next = ncts;\n\n\t\t\t//compute ts after delay/skip for fragment interleaving\n\t\t\tu64 check_ts;\n\t\t\tif ((tkw->ts_delay<0) && (cts < -tkw->ts_delay))\n\t\t\t\tcheck_ts = 0;\n\t\t\telse\n\t\t\t\tcheck_ts = cts+tkw->ts_delay;\n\n\t\t\t//we have samples and either a request to flush fragment or a emsg, start new fragment\n\t\t\tif (tkw->samples_in_frag && (orig_frag_bounds || (gf_filter_pck_get_property_str(pck, \"grp_EMSG\")!=NULL))) {\n\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\tnb_done ++;\n\t\t\t\ttkw->samples_in_frag = 0;\n\t\t\t\ttkw->dur_in_frag = 0;\n\t\t\t\tbreak;\n\t\t\t} else if (ctx->fragdur && (!ctx->dash_mode || !tkw->fragment_done) ) {\n\t\t\t\tBool frag_done = GF_FALSE;\n\t\t\t\tu32 dur = gf_filter_pck_get_duration(pck);\n\t\t\t\tif (tkw->dur_in_frag && gf_timestamp_greater_or_equal(tkw->dur_in_frag, tkw->src_timescale, ctx->cdur.num, ctx->cdur.den)) {\n\t\t\t\t\tfrag_done = GF_TRUE;\n\t\t\t\t} else if ((ctx->store==MP4MX_MODE_SFRAG)\n\t\t\t\t\t&& gf_timestamp_greater_or_equal(check_ts, tkw->src_timescale, ctx->adjusted_next_frag_start, ctx->cdur.den)\n\t\t\t\t) {\n\t\t\t\t\tGF_FilterSAPType sap = mp4_mux_get_sap(ctx, pck);\n\t\t\t\t\tif ((sap && sap<GF_FILTER_SAP_3)) {\n\t\t\t\t\t\tfrag_done = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (frag_done) {\n\t\t\t\t\tctx->adjusted_next_frag_start = gf_timestamp_rescale(check_ts, tkw->src_timescale, ctx->cdur.den);\n\t\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\t\tnb_done ++;\n\t\t\t\t\ttkw->dur_in_frag = 0;\n\t\t\t\t\ttkw->samples_in_frag = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttkw->dur_in_frag += dur;\n\t\t\t\tif (ctx->llhls_mode && (ctx->frag_duration * tkw->src_timescale <= tkw->dur_in_frag * ctx->frag_timescale)) {\n\t\t\t\t\tctx->frag_duration = tkw->dur_in_frag;\n\t\t\t\t\tctx->frag_timescale = tkw->src_timescale;\n\t\t\t\t}\n\t\t\t} else if (!ctx->flush_seg && !ctx->dash_mode\n\t\t\t\t&& gf_timestamp_greater_or_equal(check_ts, tkw->src_timescale, ctx->adjusted_next_frag_start, ctx->cdur.den)\n\t\t\t ) {\n\t\t\t\tGF_FilterSAPType sap = mp4_mux_get_sap(ctx, pck);\n\t\t\t\t//consider roll SAP as sap1 for the fragmentation\n\t\t\t\tif ((sap==GF_FILTER_SAP_4) && (tkw->stream_type==GF_STREAM_AUDIO))\n\t\t\t\t\tsap = GF_FILTER_SAP_1;\n\n\t\t\t\tif ((ctx->store==MP4MX_MODE_FRAG) || (sap && sap<GF_FILTER_SAP_3)) {\n\t\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\t\ttkw->samples_in_frag = 0;\n\t\t\t\t\tnb_done ++;\n\t\t\t\t\tif (ctx->store==MP4MX_MODE_SFRAG) {\n\t\t\t\t\t\tctx->adjusted_next_frag_start = gf_timestamp_rescale(check_ts, tkw->src_timescale, ctx->cdur.den);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((ctx->store>=MP4MX_MODE_FRAG) && tkw->samples_in_frag) {\n\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PID_CENC_PSSH);\n\t\t\t\tif (p && (p->type == GF_PROP_DATA) && p->value.data.ptr && !ctx->flush_seg && !ctx->dash_mode) {\n\t\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\t\ttkw->samples_in_frag = 0;\n\t\t\t\t\tnb_done ++;\n\t\t\t\t\tif (ctx->store==MP4MX_MODE_SFRAG) {\n\t\t\t\t\t\tctx->adjusted_next_frag_start = gf_timestamp_rescale(check_ts, tkw->src_timescale, ctx->cdur.den);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tkw->insert_tfdt) {\n\t\t\t\tu64 odts = gf_filter_pck_get_dts(pck);\n\t\t\t\tif (odts==GF_FILTER_NO_TS)\n\t\t\t\t\todts = gf_filter_pck_get_cts(pck);\n\n\t\t\t\tif (tkw->tfdt_offset) {\n\t\t\t\t\t//first sample, set offset dts such that first sample dts - offset_dts = target time\n\t\t\t\t\tif (tkw->nb_samples==0) {\n\t\t\t\t\t\tu64 target = tkw->tfdt_offset;\n\t\t\t\t\t\ttkw->tfdt_offset = odts - target;\n\n\t\t\t\t\t}\n\t\t\t\t\todts = odts - tkw->tfdt_offset;\n\t\t\t\t}\n\n\t\t\t\ttkw->insert_tfdt = GF_FALSE;\n\t\t\t\tif (tkw->patch_tfdt)\n\t\t\t\t\t//if patch_tfdt is true, tkw->ts_delay is always >0\n\t\t\t\t\tgf_isom_set_traf_base_media_decode_time(ctx->file, tkw->track_id, odts + tkw->ts_delay);\n\t\t\t\telse\n\t\t\t\t\tgf_isom_set_traf_base_media_decode_time(ctx->file, tkw->track_id, odts);\n\n\t\t\t\tif (!tkw->first_dts_in_seg_plus_one)\n\t\t\t\t\ttkw->first_dts_in_seg_plus_one = 1 + (u64) odts;\n\t\t\t}\n\n\t\t\tif (ctx->trun_inter) {\n\t\t\t\tGF_FilterSAPType sap = mp4_mux_get_sap(ctx, pck);\n\t\t\t\ts32 tid_group = 0;\n\t\t\t\tif (sap) {\n\t\t\t\t\ttkw->prev_tid_group = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts64 dts_diff;\n\t\t\t\t\ts64 p_dts = gf_filter_pck_get_dts(pck);\n\t\t\t\t\ts64 p_cts = gf_filter_pck_get_cts(pck);\n\t\t\t\t\ts64 cts_o = p_cts - p_dts;\n\t\t\t\t\tdts_diff = p_dts - tkw->sample.DTS;\n\t\t\t\t\ttid_group = (s32) (cts_o / dts_diff);\n\t\t\t\t\ttid_group = 20 - tid_group;\n\t\t\t\t\tif (tid_group != tkw->prev_tid_group) {\n\t\t\t\t\t\ttkw->prev_tid_group = tid_group;\n\t\t\t\t\t\tgf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRUN_SET_INTERLEAVE_ID, tid_group);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//process packet\n\t\t\te = mp4_mux_process_sample(ctx, tkw, pck, GF_TRUE);\n\n\t\t\t//discard\n\t\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\n\t\t\tcts = gf_timestamp_rescale(cts, tkw->src_timescale, 1000);\n\t\t\tif (!ctx->min_cts_plus_one) ctx->min_cts_plus_one = cts + 1;\n\t\t\telse if (ctx->min_cts_plus_one-1 > cts) ctx->min_cts_plus_one = cts + 1;\n\n\t\t\tif (e) return e;\n\t\t}\n\t\t//done with this track - if single track per moof, request new fragment but don't touch the\n\t\t//fragmentation state of the track writers\n\t\tif (ctx->straf && (i+1 < count)) {\n\t\t\tGF_ISOStartFragmentFlags flags = 0;\n\t\t\tif (ctx->moof_first) flags |= GF_ISOM_FRAG_MOOF_FIRST;\n#ifdef GF_ENABLE_CTRN\n\t\t\tif (ctx->ctrn) flags |= GF_ISOM_FRAG_USE_COMPACT;\n#endif\n\t\t\te = gf_isom_start_fragment(ctx->file, flags);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to start new fragment: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\tgf_isom_set_next_moof_number(ctx->file, ctx->msn);\n\t\t\tctx->msn++;\n\t\t\tif (ctx->sdtp_traf)\n\t\t\t\tgf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRAF_USE_SAMPLE_DEPS_BOX, ctx->sdtp_traf);\n\t\t}\n\t}\n\n\t//all suspended tracks done, flush fragment\n\tif (nb_suspended && (nb_suspended==count)) {\n\t\tnb_done = count;\n\t}\n\n\n\tif (nb_done==count) {\n\t\t//nothing open (this happens when flushing segments/fragments)\n\t\tif (!ctx->segment_started && !ctx->fragment_started)\n\t\t\tgoto check_eos;\n\n\t\tBool is_eos = (count == nb_eos) ? GF_TRUE : GF_FALSE;\n\t\tu32 ref_timescale;\n\t\tBool flush_refs = ctx->dash_mode ? GF_FALSE : GF_TRUE;\n\t\tu64 next_ref_ts = ctx->ref_tkw->next_seg_cts;\n\t\tif (is_eos)\n\t\t\tnext_ref_ts = ctx->ref_tkw->cts_next;\n\n\t\tref_timescale = ctx->ref_tkw->src_timescale;\n\t\t//both in ms\n\t\tctx->next_seg_start = (u64) gf_timestamp_rescale(next_ref_ts, ref_timescale, 1000);\n\t\tctx->min_cts_next_frag = (u64) gf_timestamp_rescale(ctx->next_frag_start, ctx->cdur.den, 1000);\n\n\t\tctx->next_frag_start += ctx->cdur.num;\n\t\twhile (ctx->next_frag_start <= ctx->adjusted_next_frag_start) {\n\t\t\tctx->next_frag_start += ctx->cdur.num;\n\t\t}\n\t\tctx->adjusted_next_frag_start = ctx->next_frag_start;\n\n\t\tmp4mx_frag_box_patch(ctx);\n\n\t\t//end of DASH segment\n\t\tif (ctx->dash_mode && (ctx->flush_seg || is_eos) ) {\n\t\t\tu64 offset = ctx->single_file ? ctx->current_offset : 0;\n\t\t\tu64 idx_start_range, idx_end_range, segment_size_in_bytes;\n\t\t\ts32 subs_sidx = -1;\n\t\t\tu32 track_ref_id = 0;\n\n\t\t\tidx_start_range = idx_end_range = 0;\n\t\t\tif (ctx->subs_sidx>=0) {\n\t\t\t\tsubs_sidx = ctx->subs_sidx;\n\t\t\t\ttrack_ref_id = ctx->ref_tkw->track_id;\n\t\t\t}\n\t\t\tif (ctx->cloned_sidx && (ctx->subs_sidx!=-2) ) {\n\t\t\t\tsubs_sidx = (s32) ctx->cloned_sidx->nb_refs;\n\t\t\t\ttrack_ref_id = ctx->cloned_sidx->reference_ID;\n\t\t\t\tgf_isom_box_del((GF_Box *)ctx->cloned_sidx);\n\t\t\t\tctx->cloned_sidx = NULL;\n\t\t\t}\n\n\t\t\te = gf_isom_close_segment(ctx->file, subs_sidx, track_ref_id, ctx->ref_tkw->first_dts_in_seg_plus_one ? ctx->ref_tkw->first_dts_in_seg_plus_one-1 : 0,\n\t\t\t\tctx->ref_tkw->negctts_shift ? 0 : ctx->ref_tkw->ts_delay,\n\t\t\t\tnext_ref_ts, ctx->chain_sidx, ctx->ssix, ctx->sseg ? GF_FALSE : is_eos, GF_FALSE, ctx->eos_marker, &idx_start_range, &idx_end_range, &segment_size_in_bytes);\n\t\t\tctx->ref_tkw->first_dts_in_seg_plus_one = 0;\n\t\t\tif (e) return e;\n\t\t\tflush_refs = GF_TRUE;\n\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MP4Mux] Done writing segment %d - estimated next fragment times start %g end %g\\n\", ctx->dash_seg_num_plus_one - 1, ((Double)next_ref_ts)/ref_timescale, ((Double)ctx->next_frag_start)/ctx->cdur.den ));\n\n\t\t\tif (ctx->dash_mode != MP4MX_DASH_VOD) {\n\t\t\t\t//we need to wait for packet to be written\n\t\t\t\tif (ctx->seg_flush_state) {\n\t\t\t\t\tctx->flush_idx_start_range = offset + idx_start_range;\n\t\t\t\t\tctx->flush_idx_end_range = idx_end_range ? offset + idx_end_range : 0;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t\tmp4_mux_flush_seg(ctx, GF_FALSE, offset + idx_start_range, idx_end_range ? offset + idx_end_range : 0, !is_eos);\n\t\t\t} else if (ctx->vodcache==MP4MX_VODCACHE_REPLACE) {\n\t\t\t\tmp4_mux_flush_seg(ctx, GF_FALSE, 0, 0, GF_FALSE);\n\t\t\t} else {\n\t\t\t\tif (ctx->nb_seg_sizes == ctx->alloc_seg_sizes) {\n\t\t\t\t\t ctx->alloc_seg_sizes *= 2;\n\t\t\t\t\t if (!ctx->alloc_seg_sizes) ctx->alloc_seg_sizes = 10;\n\t\t\t\t\t ctx->seg_sizes = gf_realloc(ctx->seg_sizes, sizeof(u32) * ctx->alloc_seg_sizes);\n\t\t\t\t}\n\t\t\t\tassert(segment_size_in_bytes);\n\t\t\t\tctx->seg_sizes[ctx->nb_seg_sizes] = (u32) segment_size_in_bytes;\n\t\t\t\tctx->nb_seg_sizes++;\n\t\t\t}\n\t\t\t//we still need to send seg size info for for HLS !\n\t\t\tif (ctx->vodcache==MP4MX_VODCACHE_INSERT)\n\t\t\t\tmp4_mux_flush_seg(ctx, GF_FALSE, 0, 0, !is_eos);\n\t\t}\n\t\t//cannot flush in DASH mode if using sidx (vod single sidx or live 1 sidx/seg)\n\t\telse if (!ctx->dash_mode || ((ctx->subs_sidx<0) && (ctx->dash_mode<MP4MX_DASH_VOD) && !ctx->cloned_sidx) ) {\n\t\t\tgf_isom_flush_fragments(ctx->file, GF_FALSE);\n\t\t\tflush_refs = GF_TRUE;\n\t\t\t//if not in dash and EOS marker is set, inject marker after each fragment\n\t\t\tif (!ctx->dash_mode && ctx->eos_marker && ctx->fragment_started) {\n\t\t\t\tu8 data[8];\n\t\t\t\tmemset(data, 0, 8);\n\t\t\t\tdata[3] = 8;\n\t\t\t\tdata[4] = ctx->m4cc[0];\n\t\t\t\tdata[5] = ctx->m4cc[1];\n\t\t\t\tdata[6] = ctx->m4cc[2];\n\t\t\t\tdata[7] = ctx->m4cc[3];\n\t\t\t\tmp4_mux_on_data(ctx, data, 8, NULL, 0);\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MP4Mux] Done writing fragment - next fragment start time %g\\n\", ((Double)ctx->next_frag_start)/ctx->cdur.den ));\n\n\t\t\t//we need to wait for packet to be written\n\t\t\tif (ctx->seg_flush_state) {\n\t\t\t\tif (ctx->llhls_mode) ctx->flush_ll_hls = GF_TRUE;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\n\t\t\tif (ctx->llhls_mode) {\n\t\t\t\tmp4_mux_flush_frag_hls(ctx);\n\t\t\t}\n\n\t\t\tif (!ctx->dash_mode || ctx->flush_seg) {\n\t\t\t\tmp4_mux_flush_seg(ctx, GF_FALSE, 0, 0, !is_eos);\n\t\t\t}\n\t\t}\n\t\tctx->fragment_started = GF_FALSE;\n\n\t\tif (ctx->flush_seg) {\n\t\t\tctx->segment_started = GF_FALSE;\n\t\t\tctx->flush_seg = GF_FALSE;\n\t\t\tctx->dash_seg_num_plus_one = 0;\n\t\t\tctx->nb_segs++;\n\t\t\tctx->nb_frags_in_seg=0;\n\t\t}\n\t\t//destroy any pending refs\n\t\tif (flush_refs) {\n\t\t\twhile (gf_list_count(ctx->ref_pcks)) {\n\t\t\t\tGF_FilterPacket *pckr = gf_list_pop_back(ctx->ref_pcks);\n\t\t\t\tgf_filter_pck_unref(pckr);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nb_suspended && (nb_suspended==count)) {\n\t\tctx->nb_segs=0;\n\t\treturn mp4mx_reload_output(ctx);\n\t}\n\ncheck_eos:\n\tif (count == nb_eos) {\n\t\tif (ctx->dash_mode==MP4MX_DASH_VOD) {\n\t\t\tif (ctx->vodcache!=MP4MX_VODCACHE_ON) {\n\t\t\t\tctx->final_sidx_flush = GF_TRUE;\n\t\t\t\t//flush SIDX in given space - this will reserve 8 bytes for free box if not fitting\n\t\t\t\tgf_isom_flush_sidx(ctx->file, ctx->sidx_max_size, (ctx->sidx_size_exact || ctx->tfdt64) ? GF_TRUE : GF_FALSE);\n\t\t\t} else {\n\t\t\t\tu64 start_offset;\n\t\t\t\t//reenable packet dispatch\n\t\t\t\tctx->store_output = GF_FALSE;\n\t\t\t\tgf_isom_flush_sidx(ctx->file, 0, ctx->tfdt64);\n\t\t\t\t//flush sidx packet\n\t\t\t\tmp4mux_send_output(ctx);\n\n\t\t\t\tmp4_mux_flush_seg(ctx, GF_TRUE, ctx->current_offset, ctx->current_offset + ctx->current_size - 1, GF_FALSE);\n\n\t\t\t\tgf_fflush(ctx->tmp_store);\n\t\t\t\tctx->flush_size = gf_ftell(ctx->tmp_store);\n\t\t\t\tctx->flush_done = 0;\n\t\t\t\tgf_fseek(ctx->tmp_store, 0, SEEK_SET);\n\n\t\t\t\tif (ctx->seg_sizes) {\n\t\t\t\t\tstart_offset = ctx->current_offset;\n\t\t\t\t\tfor (i=0; i<ctx->nb_seg_sizes; i++) {\n\t\t\t\t\t\tctx->current_size = ctx->seg_sizes[i];\n\t\t\t\t\t\tmp4_mux_flush_seg(ctx, GF_FALSE, 0, 0, GF_FALSE);\n\t\t\t\t\t}\n\t\t\t\t\tctx->current_offset = start_offset;\n\t\t\t\t\tctx->current_size = 0;\n\n\t\t\t\t\tgf_free(ctx->seg_sizes);\n\t\t\t\t\tctx->seg_sizes = NULL;\n\t\t\t\t\tctx->alloc_seg_sizes = ctx->nb_seg_sizes = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//only destroy file if not dash or not onDemand, otherwise (regular dash) the file will be needed to append further segments\n\t\tif (ctx->dash_mode!=MP4MX_DASH_ON) {\n\t\t\t//only delete file in vod mode\n\t\t\tif (ctx->file) {\n\t\t\t\tgf_isom_close(ctx->file);\n\t\t\t\tctx->file = NULL;\n\t\t\t}\n\t\t}\n\n\t\tmp4mux_send_output(ctx);\n\n\t\tif (!ctx->flush_size) gf_filter_pid_set_eos(ctx->opid);\n\n\t\treturn ctx->flush_size ? GF_OK : GF_EOS;\n\t}\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\nstruct _service_info\n{\n\tu32 service_id;\n\tu64 first_ts_min;\n\tu32 nb_non_sparse, nb_non_sparse_ready;\n\tu32 nb_sparse, nb_sparse_ready;\n};\nstatic struct _service_info *get_service_info(GF_List *services, TrackWriter *tkw)\n{\n\tstruct _service_info *si;\n\tconst GF_PropertyValue *p = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_SERVICE_ID);\n\tu32 ID, i, count=gf_list_count(services);\n\tID = p ? p->value.uint : 0;\n\n\tfor (i=0; i<count; i++) {\n\t\tsi = gf_list_get(services, i);\n\t\tif (si->service_id == ID) return si;\n\t}\n\tGF_SAFEALLOC(si, struct _service_info)\n\tsi->service_id = ID;\n\tsi->first_ts_min = (u64) -1;\n\tgf_list_add(services, si);\n\treturn si;\n}\nstatic void del_service_info(GF_List *services)\n{\n\twhile (gf_list_count(services)) {\n\t\tstruct _service_info *si = gf_list_pop_back(services);\n\t\tgf_free(si);\n\t}\n\tgf_list_del(services);\n}\n\nstatic void mp4_mux_update_init_edit(GF_MP4MuxCtx *ctx, TrackWriter *tkw, u64 min_ts_service, Bool skip_adjust)\n{\n\t//compute offsets\n\ts64 dts_diff = ctx->tsalign ? gf_timestamp_rescale(min_ts_service, 1000000, tkw->src_timescale) : 0;\n\n\tif (!skip_adjust) {\n\t\tdts_diff = (s64) tkw->ts_shift - dts_diff;\n\t}\n\tif (ctx->is_rewind) dts_diff = -dts_diff;\n\t//negative could happen due to rounding, ignore them\n\tif (dts_diff <= (gf_sys_old_arch_compat() ? 0 : 1)) return;\n\n\t// dts_diff > 0, we need to delay the track\n\tu64 dur = gf_timestamp_rescale(dts_diff, tkw->src_timescale, ctx->moovts);\n\tif (dur) {\n\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\n\t\tgf_isom_set_edit(ctx->file, tkw->track_num, 0, dur, dts_diff, GF_ISOM_EDIT_EMPTY);\n\t\tgf_isom_set_edit(ctx->file, tkw->track_num, dur, 0, 0, GF_ISOM_EDIT_NORMAL);\n\t\ttkw->empty_init_dur = (u64) dur;\n\t}\n}\n\nstatic void mp4_mux_config_timing(GF_MP4MuxCtx *ctx)\n{\n\tif ((ctx->store>=MP4MX_MODE_FRAG) && !ctx->tsalign) {\n\t\tctx->config_timing = GF_FALSE;\n\t\treturn;\n\t}\n\tGF_List *services = gf_list_new();\n\tu32 i, count;\n\tBool not_ready, blocking_refs, has_ready;\n\nretry_all:\n\tcount = gf_list_count(ctx->tracks);\n\tnot_ready = GF_FALSE;\n\tblocking_refs = GF_FALSE;\n\thas_ready = GF_FALSE;\n\n\tfor (i=0; i<gf_list_count(services);i++) {\n\t\tstruct _service_info *si = gf_list_get(services, i);\n\t\tsi->nb_non_sparse = si->nb_non_sparse_ready = 0;\n\t\tsi->nb_sparse = si->nb_sparse_ready = 0;\n\t}\n\n\t//compute min dts of first packet on each track - this assume all tracks are synchronized, might need adjustment for MPEG4 Systems\n\tfor (i=0; i<count; i++) {\n\t\tu64 ts, dts_min;\n\t\tGF_FilterPacket *pck;\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tif (tkw->fake_track) continue;\n\t\t//get associated service\n\t\tstruct _service_info *si = get_service_info(services, tkw);\n\n\t\t//already setup (happens when new PIDs are declared after a packet has already been written on other PIDs)\n\t\tif (tkw->nb_samples) {\n\t\t\tdts_min = gf_timestamp_rescale(tkw->ts_shift, tkw->src_timescale, 1000000);\n\n\t\t\tif (si->first_ts_min > dts_min) {\n\t\t\t\tsi->first_ts_min = (u64) dts_min;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\nretry_pck:\n\t\tpck = gf_filter_pid_get_packet(tkw->ipid);\n\t\t//check this after fetching a packet since it may reconfigure the track\n\t\tif (!tkw->track_num) {\n\t\t\tif (gf_filter_pid_is_eos(tkw->ipid)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] PID has no input packet and configuration not known after 10 retries, aborting initial timing sync\\n\"));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnot_ready = GF_TRUE;\n\t\t\ttkw->ts_shift = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pck) {\n\t\t\tif (gf_filter_pck_is_blocking_ref(pck))\n\t\t\t\tblocking_refs = GF_TRUE;\n\t\t\tif (tkw->wait_sap) {\n\t\t\t\tGF_FilterSAPType sap = gf_filter_pck_get_sap(pck);\n\t\t\t\tBool seek = gf_filter_pck_get_seek_flag(pck);\n\t\t\t\tif (seek || !sap) {\n\t\t\t\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\t\t\t\t\tgoto retry_pck;\n\t\t\t\t} else {\n\t\t\t\t\ttkw->wait_sap = GF_FALSE;\n\n\t\t\t\t\tif (!ctx->wait_dts_plus_one) {\n\t\t\t\t\t\tctx->wait_dts_plus_one = 1 + gf_filter_pck_get_dts(pck);\n\t\t\t\t\t\tctx->wait_dts_timescale = tkw->src_timescale;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ctx->wait_dts_plus_one) {\n\t\t\t\tts = gf_filter_pck_get_dts(pck);\n\t\t\t\tif (ts==GF_FILTER_NO_TS)\n\t\t\t\t\tts = gf_filter_pck_get_cts(pck);\n\t\t\t\tif (ts==GF_FILTER_NO_TS)\n\t\t\t\t\tts=0;\n\n\t\t\t\tif (gf_timestamp_less(ts, tkw->src_timescale, (ctx->wait_dts_plus_one-1), ctx->wait_dts_timescale)) {\n\t\t\t\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\t\t\t\t\tgoto retry_pck;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswitch (tkw->stream_type) {\n\t\tcase GF_STREAM_VISUAL:\n\t\tcase GF_STREAM_AUDIO:\n\t\t\tsi->nb_non_sparse++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsi->nb_sparse++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!pck) {\n\t\t\t//eos (wether real or flush event), setup cenc\n\t\t\tif (gf_filter_pid_is_eos(tkw->ipid)) {\n\t\t\t\tif (tkw->cenc_state==CENC_NEED_SETUP)\n\t\t\t\t\tmp4_mux_cenc_update(ctx, tkw, NULL, CENC_CONFIG, 0, 0);\n\n\t\t\t\tif (!tkw->nb_samples) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_TREX_TEMPLATE);\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\tgf_isom_setup_track_fragment_template(ctx->file, tkw->track_id, p->value.data.ptr, p->value.data.size, ctx->nofragdef);\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\t\t\t\tif (tkw->dgl_copy) {\n\t\t\t\t\tgf_filter_pck_discard(tkw->dgl_copy);\n\t\t\t\t\ttkw->dgl_copy = NULL;\n\t\t\t\t}\n\t\t\t\tswitch (tkw->stream_type) {\n\t\t\t\tcase GF_STREAM_VISUAL:\n\t\t\t\tcase GF_STREAM_AUDIO:\n\t\t\t\t\tsi->nb_non_sparse_ready++;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tsi->nb_sparse_ready++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttkw->ts_shift = 0;\n\t\t\ttkw->si_min_ts_plus_one = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t//we may have reorder tracks after the get_packet, redo\n\t\tif (gf_list_find(ctx->tracks, tkw) != i) {\n\t\t\tgoto retry_all;\n\t\t}\n\t\tts = gf_filter_pck_get_dts(pck);\n\t\tif (ts==GF_FILTER_NO_TS)\n\t\t\tts = gf_filter_pck_get_cts(pck);\n\t\tif (ts==GF_FILTER_NO_TS)\n\t\t\tts=0;\n\n\t\tdts_min = gf_timestamp_rescale(ts, tkw->src_timescale, 1000000);\n\n\t\tif (si->first_ts_min > dts_min) {\n\t\t\tsi->first_ts_min = (u64) dts_min;\n\t\t\thas_ready = GF_TRUE;\n\t\t}\n\n\t\tswitch (tkw->stream_type) {\n\t\tcase GF_STREAM_VISUAL:\n\t\tcase GF_STREAM_AUDIO:\n\t\t\tsi->nb_non_sparse_ready++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsi->nb_sparse_ready++;\n\t\t\tbreak;\n\t\t}\n\n\t\ttkw->ts_shift = ts;\n\t\ttkw->si_min_ts_plus_one = 0;\n\t}\n\n\tfor (i=0; i<gf_list_count(services); i++) {\n\t\tstruct _service_info *si = gf_list_get(services, i);\n\t\t//if some non-sparse streams are not ready, try to wait\n\t\tif (si->nb_non_sparse) {\n\t\t\tif (si->nb_non_sparse > si->nb_non_sparse_ready) not_ready = GF_TRUE;\n\t\t}\n\t\t//otherwise (only sparse stream), wait until first\n\t\telse if (si->nb_sparse) {\n\t\t\tif (!si->nb_sparse_ready) not_ready = GF_TRUE;\n\t\t}\n\t}\n\n\tif (not_ready) {\n\t\tif (blocking_refs && has_ready) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Blocking input packets present, aborting initial timing sync\\n\"));\n\t\t}\n\t\t//this may be quite long until we have a packet in case input pid is video encoding \n\t\telse if (ctx->config_retry_start && (gf_sys_clock() - ctx->config_retry_start > 10000)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] No input packets present on one or more inputs for more than 10s, aborting initial timing sync\\n\"));\n\t\t} else {\n\t\t\tctx->config_retry_start = gf_sys_clock();\n\t\t\tdel_service_info(services);\n\t\t\treturn;\n\t\t}\n\t}\n\tctx->config_retry_start = 0;\n\tfor (i=0; i<gf_list_count(services); i++) {\n\t\tstruct _service_info *si = gf_list_get(services, i);\n\t\tif (si->first_ts_min==(u64)-1)\n\t\t\tsi->first_ts_min = 0;\n\t}\n\n\t//for all packets with dts greater than min dts, we need to add a pause\n\tfor (i=0; i<count; i++) {\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tstruct _service_info *si = get_service_info(services, tkw);\n\t\tif (tkw->si_min_ts_plus_one) {\n\t\t\ttkw->si_min_ts_plus_one = si->first_ts_min + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//if single text track don't reset back to 0\n\t\tmp4_mux_update_init_edit(ctx, tkw, si->first_ts_min, ((count==1) && (tkw->stream_type == GF_STREAM_TEXT)) ? GF_TRUE : GF_FALSE);\n\t}\n\n\tctx->config_timing = GF_FALSE;\n\tdel_service_info(services);\n}\n\nvoid mp4_mux_format_report(GF_MP4MuxCtx *ctx, u64 done, u64 total)\n{\n\tBool status_changed=GF_FALSE;\n\tu32 total_pc = 0;\n\tchar *status = NULL, szTmp[2048], szTK[20];\n\tif (!gf_filter_reporting_enabled(ctx->filter))\n\t\treturn;\n\tif (!ctx->update_report)\n\t\treturn;\n\n\tctx->update_report = GF_FALSE;\n\n\tif (ctx->config_timing) {\n\t\tgf_dynstrcat(&status, \"waiting for clock init\", NULL);\n\t\tstatus_changed = GF_TRUE;\n\t} else if (total) {\n\t\tif (done>=total) {\n\t\t\tDouble ohead = 0;\n\t\t\tif (ctx->total_bytes_in) ohead =  ((Double) (ctx->total_bytes_out - ctx->total_bytes_in)*100 / ctx->total_bytes_in);\n\n\t\t\tsprintf(szTmp, \"done %d samples - bytes \"LLU\" in \"LLU\" out - overhead %02.02f%% (%02.02g B/sample)\", ctx->total_samples, ctx->total_bytes_in, ctx->total_bytes_out, ohead, ((Double)(ctx->total_bytes_out-ctx->total_bytes_in))/ctx->total_samples);\n\t\t\tstatus_changed = GF_TRUE;\n\t\t\ttotal_pc = 10000;\n\n\t\t} else {\n\t\t\tu32 pc = (u32) ((done*10000)/total);\n\t\t\tif (ctx->last_mux_pc == pc + 1) return;\n\t\t\tctx->last_mux_pc = pc + 1;\n\t\t\tsprintf(szTmp, \"mux %d%%\", pc);\n\t\t\tstatus_changed = GF_TRUE;\n\t\t}\n\t\tgf_dynstrcat(&status, szTmp, NULL);\n\t} else {\n\t\tu32 i, count = gf_list_count(ctx->tracks);\n\t\tBool is_frag = GF_FALSE;\n\n\t\tif (ctx->store>=MP4MX_MODE_FRAG) {\n\t\t\tDouble next = ((Double)ctx->next_frag_start)/ctx->cdur.den;\n\t\t\tis_frag = GF_TRUE;\n\t\t\tif (ctx->dash_mode) {\n\t\t\t\tsprintf(szTmp, \"mux segments %d (frags %d) next %02.3f\", ctx->nb_segs, ctx->nb_frags_in_seg, next);\n\t\t\t} else {\n\t\t\t\tsprintf(szTmp, \"mux frags %d next %02.3f\", ctx->nb_frags, next);\n\t\t\t}\n\t\t} else {\n\t\t\tsprintf(szTmp, \"%s\", ((ctx->store==MP4MX_MODE_FLAT) || (ctx->store==MP4MX_MODE_FASTSTART)) ? \"mux\" : \"import\");\n\t\t}\n\t\tgf_dynstrcat(&status, szTmp, NULL);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 pc=0;\n\t\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\t\tif (tkw->aborted) {\n\t\t\t\tpc=10000;\n\t\t\t} else if (ctx->dur.num) {\n\t\t\t\tif (ctx->dur.num>0) {\n\t\t\t\t\tu64 mdur = gf_isom_get_media_duration(ctx->file, tkw->track_num);\n\t\t\t\t\tu64 tk_done = mdur * ctx->dur.den;\n\t\t\t\t\tu64 tk_total = ((u64)tkw->tk_timescale) * ctx->dur.num;\n\t\t\t\t\tpc = (u32) ((tk_done*10000)/tk_total);\n\t\t\t\t} else {\n\t\t\t\t\tpc = (u32) ( (10000 * (u64) (tkw->nb_samples + tkw->frame_offset) ) / (-ctx->dur.num) );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (tkw->nb_frames) {\n\t\t\t\t\tpc = (u32) ( (10000 * (u64) (tkw->nb_samples + tkw->frame_offset)) / tkw->nb_frames);\n\t\t\t\t} else {\n\t\t\t\t\tif (tkw->pid_dur.num && tkw->pid_dur.den) {\n\t\t\t\t\t\tpc = (u32) ((tkw->sample.DTS*10000 * tkw->pid_dur.den) / (tkw->pid_dur.num * tkw->tk_timescale));\n\t\t\t\t\t} else if (tkw->down_bytes && tkw->down_size) {\n\t\t\t\t\t\tpc = (u32) (((tkw->down_bytes*10000) / tkw->down_size));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pc>10000)\n\t\t\t\tpc=0;\n\t\t\tif (tkw->last_import_pc != pc + 1) {\n\t\t\t\tstatus_changed = GF_TRUE;\n\t\t\t\ttkw->last_import_pc = pc + 1;\n\t\t\t}\n\t\t\tif (!total_pc || (total_pc > pc))\n\t\t\t\ttotal_pc = pc;\n\n\t\t\tif (is_frag) {\n\t\t\t\tsprintf(szTK, \" TK%d(%c): %d\", tkw->track_id, tkw->status_type, tkw->samples_in_frag);\n\t\t\t\tgf_dynstrcat(&status, szTK, NULL);\n\t\t\t\tstatus_changed = GF_TRUE;\n\t\t\t\tif (pc) {\n\t\t\t\t\tsprintf(szTK, \" %d %%\", pc/100);\n\t\t\t\t\tgf_dynstrcat(&status, szTK, NULL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsprintf(szTK, \" %s%d(%c): %d %%\", tkw->is_item ? \"IT\" : \"TK\", tkw->track_id, tkw->status_type, pc/100);\n\t\t\t\tgf_dynstrcat(&status, szTK, NULL);\n\t\t\t}\n\t\t}\n\t}\n\tif (status_changed) {\n\t\tgf_filter_update_status(ctx->filter, total_pc, status);\n\t}\n\tif (status) gf_free(status);\n}\n\nstatic void mp4_mux_flush_seg_events(GF_MP4MuxCtx *ctx);\n\nGF_Err mp4_mux_process(GF_Filter *filter)\n{\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\tu32 nb_skip, nb_eos, nb_suspended, i, count = gf_list_count(ctx->tracks);\n\tnb_skip = 0;\n\tnb_eos = 0;\n\n\tif (ctx->config_timing) {\n\t\tmp4_mux_config_timing(ctx);\n\t\tif (ctx->config_timing) {\n\t\t\tmp4_mux_format_report(ctx, 0, 0);\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\t//fragmented mode\n\tif (ctx->store>=MP4MX_MODE_FRAG) {\n\t\tu32 done=0;\n\t\t//postpone until no pending connections, otherwise we will create init segment without all tracks\n\t\tif (gf_filter_connections_pending(filter))\n\t\t\treturn GF_OK;\n\n\t\tif (ctx->seg_flush_state==1) return GF_OK;\n\t\telse if (ctx->seg_flush_state==2)\n\t\t\tmp4_mux_flush_seg_events(ctx);\n\n\t\tGF_Err e = mp4_mux_process_fragmented(ctx);\n\t\tif (e==GF_EOS) done=100;\n\t\tmp4_mux_format_report(ctx, done, done);\n\t\treturn e;\n\t}\n\n\t//regular mode\n\tnb_suspended = 0;\n\tfor (i=0; i<count; i++) {\n\t\tGF_Err e;\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tGF_FilterPacket *pck = gf_filter_pid_get_packet(tkw->ipid);\n\n\t\tif (tkw->suspended) {\n\t\t\tnb_suspended++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!pck) {\n\t\t\tif (gf_filter_pid_is_eos(tkw->ipid) && !gf_filter_pid_is_flush_eos(tkw->ipid)) {\n\t\t\t\ttkw->suspended = GF_FALSE;\n\t\t\t\tnb_eos++;\n\t\t\t}\n\t\t\tif (tkw->aborted) {\n\t\t\t\tnb_eos++;\n\t\t\t}\n\t\t\tif (ctx->store==MP4MX_MODE_FASTSTART) {\n\t\t\t\tnb_skip++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (tkw->aborted) {\n\t\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\t\t\tnb_eos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ctx->owns_mov) {\n\t\t\tconst GF_PropertyValue *p;\n\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILENUM);\n\t\t\tif (p) {\n\t\t\t\tif (!ctx->cur_file_idx_plus_one) {\n\t\t\t\t\tctx->cur_file_idx_plus_one = p->value.uint + 1;\n\t\t\t\t\tif (!ctx->cur_file_suffix) {\n\t\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILESUF);\n\t\t\t\t\t\tif (p && p->value.string) ctx->cur_file_suffix = gf_strdup(p->value.string);\n\t\t\t\t\t}\n\t\t\t\t\tctx->notify_filename = GF_TRUE;\n\t\t\t\t} else if (ctx->cur_file_idx_plus_one == p->value.uint+1) {\n\t\t\t\t} else if (!tkw->suspended) {\n\t\t\t\t\ttkw->suspended = GF_TRUE;\n\t\t\t\t\tnb_suspended++;\n\t\t\t\t\tctx->next_file_idx =  p->value.uint + 1;\n\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILESUF);\n\t\t\t\t\tif (p && p->value.string)\n\t\t\t\t\t\tctx->next_file_suffix = p->value.string;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//basic regulation in case we do on-the-fly interleaving\n\t\t//we need to regulate because sources do not produce packets at the same rate\n\t\tif (ctx->store==MP4MX_MODE_FASTSTART) {\n\t\t\tu64 cts = gf_filter_pck_get_cts(pck);\n\t\t\tif (ctx->is_rewind)\n\t\t\t\tcts = tkw->ts_shift - cts;\n\t\t\telse\n\t\t\t\tcts -= tkw->ts_shift;\n\n\t\t\tif (!ctx->faststart_ts_regulate.num) {\n\t\t\t\tctx->faststart_ts_regulate = ctx->cdur;\n\t\t\t}\n\t\t\t//ahead of our interleaving window, don't write yet\n\t\t\telse if (gf_timestamp_greater(cts, tkw->src_timescale, ctx->faststart_ts_regulate.num, ctx->faststart_ts_regulate.den)) {\n\t\t\t\tnb_skip++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (tkw->cenc_state==CENC_NEED_SETUP)\n\t\t\tmp4_mux_cenc_update(ctx, tkw, pck, CENC_CONFIG, 0, 0);\n\n\t\tif (tkw->is_item) {\n\t\t\te = mp4_mux_process_item(ctx, tkw, pck);\n\t\t} else {\n\t\t\te = mp4_mux_process_sample(ctx, tkw, pck, GF_FALSE);\n\t\t}\n\n\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\t\tif (tkw->aborted) {\n\t\t\tnb_eos++;\n\t\t}\n\t\tif (e) return e;\n\t}\n\tmp4_mux_format_report(ctx, 0, 0);\n\n\tif (nb_suspended && (nb_suspended+nb_eos==count)) {\n\t\treturn mp4mx_reload_output(ctx);\n\t}\n\n\tif (count == nb_eos) {\n\t\tif (ctx->file) {\n\t\t\tGF_Err e = mp4_mux_done(ctx, GF_TRUE);\n\t\t\tif (e) return e;\n\t\t}\n\t\treturn GF_EOS;\n\t}\n\t//done with this interleaving window, start next one\n\telse if (nb_skip + nb_eos >= count) {\n\t\tctx->faststart_ts_regulate.num += ctx->cdur.num;\n\t} else if (ctx->importer) {\n\t\tu64 prog_done=0, prog_total=0;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\t\tprog_done += tkw->prog_done;\n\t\t\tprog_total += tkw->prog_total;\n\t\t}\n\t\tgf_set_progress(\"Import\", prog_done, prog_total);\n\t}\n\n\treturn GF_OK;\n}\n\nstatic GF_Err mp4_mux_on_data_patch(void *cbk, u8 *data, u32 block_size, u64 file_offset, Bool is_insert)\n{\n\tGF_MP4MuxCtx *ctx = (GF_MP4MuxCtx *) cbk;\n\tu8 *output;\n\n\tGF_FilterPacket *pck = gf_filter_pck_new_alloc(ctx->opid, block_size, &output);\n\tif (!pck) return GF_OUT_OF_MEM;\n\n\tmemcpy(output, data, block_size);\n\tgf_filter_pck_set_framing(pck, GF_FALSE, GF_FALSE);\n\tgf_filter_pck_set_seek_flag(pck, GF_TRUE);\n\tif (is_insert)\n\t\tgf_filter_pck_set_interlaced(pck, 1);\n\tgf_filter_pck_set_byte_offset(pck, file_offset);\n\tgf_filter_pck_send(pck);\n\treturn GF_OK;\n}\n\nstatic void mp4_mux_flush_seg_events(GF_MP4MuxCtx *ctx)\n{\n\tif (ctx->flush_ll_hls) {\n\t\tmp4_mux_flush_frag_hls(ctx);\n\t}\n\n\tif (!ctx->dash_mode || ctx->flush_seg) {\n\t\tmp4_mux_flush_seg(ctx, GF_FALSE, ctx->flush_idx_start_range, ctx->flush_idx_end_range, GF_FALSE);\n\t}\n\n\tctx->fragment_started = GF_FALSE;\n\n\tif (ctx->flush_seg) {\n\t\tctx->segment_started = GF_FALSE;\n\t\tctx->flush_seg = GF_FALSE;\n\t\tctx->dash_seg_num_plus_one = 0;\n\t\tctx->nb_segs++;\n\t\tctx->nb_frags_in_seg=0;\n\t}\n\tctx->seg_flush_state = 0;\n\tctx->flush_idx_start_range = 0;\n\tctx->flush_idx_end_range = 0;\n\tctx->flush_ll_hls = GF_FALSE;\n}\n\nstatic void mp4_mux_on_packet_destruct(GF_Filter *filter, GF_FilterPid *PID, GF_FilterPacket *pck)\n{\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\t//no need to lock filter here, only this callback modifies the state\n\tctx->seg_flush_state = 2;\n\tgf_filter_post_process_task(filter);\n}\n\nstatic void mp4_mux_on_last_block_start(void *cbk)\n{\n\tGF_MP4MuxCtx *ctx = (GF_MP4MuxCtx *) cbk;\n\tif (ctx->force_seg_sync)\n\t\tctx->seg_flush_state = 1;\n}\n\nstatic GF_Err mp4_mux_on_data(void *cbk, u8 *data, u32 block_size, void *cbk_data, u32 cbk_magic)\n{\n\tGF_MP4MuxCtx *ctx = (GF_MP4MuxCtx *) cbk;\n\tu8 *output;\n\tu32 src_pck_dur=0;\n\n\tctx->total_bytes_out += block_size;\n\n\t//flush pending packet in frag mode\n\tmp4mux_send_output(ctx);\n\n\tif (ctx->final_sidx_flush) {\n\t\tGF_FilterPacket *pck;\n\t\tu32 free_size=0;\n\n\t\tif (ctx->vodcache==MP4MX_VODCACHE_INSERT) {\n\t\t\tpck = gf_filter_pck_new_alloc(ctx->opid, block_size, &output);\n\t\t\tif (!pck) return GF_OUT_OF_MEM;\n\n\t\t\tmemcpy(output, data, block_size);\n\t\t\tgf_filter_pck_set_framing(pck, GF_FALSE, GF_FALSE);\n\t\t\tgf_filter_pck_set_byte_offset(pck, ctx->sidx_chunk_offset);\n\t\t\tgf_filter_pck_set_seek_flag(pck, GF_TRUE);\n\t\t\tgf_filter_pck_set_interlaced(pck, 1);\n\t\t\tgf_filter_pck_send(pck);\n\t\t} else {\n\t\t\tGF_BitStream *bs;\n\t\t\tassert(!ctx->dst_pck);\n\n\t\t\tif (block_size > ctx->sidx_max_size) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Final SIDX chunk larger than preallocated block, will not flush SIDX (output file still readable). Try disabling nocache mode\\n\"));\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tfree_size = ctx->sidx_max_size - block_size;\n\t\t\tpck = gf_filter_pck_new_alloc(ctx->opid, ctx->sidx_max_size, &output);\n\t\t\tif (!pck) return GF_OUT_OF_MEM;\n\n\t\t\tgf_filter_pck_set_framing(pck, GF_FALSE, GF_FALSE);\n\t\t\tgf_filter_pck_set_byte_offset(pck, ctx->sidx_chunk_offset);\n\t\t\tgf_filter_pck_set_seek_flag(pck, GF_TRUE);\n\t\t\tbs = gf_bs_new(output, ctx->sidx_max_size, GF_BITSTREAM_WRITE);\n\t\t\tif (free_size) {\n\t\t\t\tgf_bs_write_u32(bs, free_size);\n\t\t\t\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_FREE);\n\t\t\t\tgf_bs_skip_bytes(bs, free_size-8);\n\t\t\t}\n\t\t\tgf_bs_write_data(bs, data, block_size);\n\t\t\tgf_bs_del(bs);\n\t\t\tgf_filter_pck_send(pck);\n\t\t}\n\t\tmp4_mux_flush_seg(ctx, GF_TRUE, ctx->sidx_chunk_offset+free_size, ctx->sidx_chunk_offset+free_size + block_size - 1, GF_FALSE);\n\t\treturn GF_OK;\n\t}\n\n\tif (ctx->store_output) {\n\t\tu32 nb_write = (u32) gf_fwrite(data, block_size, ctx->tmp_store);\n\t\tif (nb_write != block_size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error writing to temp cache: %d bytes write instead of %d\\n\", nb_write, block_size));\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tGF_FilterPacket *srcp = (GF_FilterPacket *)cbk_data;\n\tif (srcp && gf_list_find(ctx->ref_pcks, srcp)<0) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Data callback on non-existing packet reference !\\n\"));\n\t\treturn GF_IO_ERR;\n\t}\n\n\tif (srcp) {\n\t\tif (ctx->seg_flush_state) {\n\t\t\tctx->dst_pck = gf_filter_pck_new_ref_destructor(ctx->opid, cbk_magic, block_size, srcp, mp4_mux_on_packet_destruct);\n\t\t} else {\n\t\t\tctx->dst_pck = gf_filter_pck_new_ref(ctx->opid, cbk_magic, block_size, srcp);\n\t\t}\n\t\tgf_list_del_item(ctx->ref_pcks, srcp);\n\t\tsrc_pck_dur = gf_timestamp_rescale(gf_filter_pck_get_duration(srcp), gf_filter_pck_get_timescale(srcp), 1000);\n\t\tgf_filter_pck_unref(srcp);\n\t}\n\t//allocate new one\n\telse if (ctx->seg_flush_state) {\n\t\tctx->dst_pck = gf_filter_pck_new_alloc_destructor(ctx->opid, block_size, &output, mp4_mux_on_packet_destruct);\n\t} else {\n\t\tctx->dst_pck = gf_filter_pck_new_alloc(ctx->opid, block_size, &output);\n\t}\n\tif (!ctx->dst_pck) return GF_OUT_OF_MEM;\n\n\tif (!cbk_data)\n\t\tmemcpy(output, data, block_size);\n\tgf_filter_pck_set_framing(ctx->dst_pck, !ctx->first_pck_sent, GF_FALSE);\n\n\t//set packet prop as string since we may discard the seg_name  packet before this packet is processed\n\tif (!ctx->first_pck_sent && ctx->seg_name) {\n\t\tctx->current_offset = 0;\n\t\tgf_filter_pck_set_property(ctx->dst_pck, GF_PROP_PCK_FILENAME, &PROP_STRING(ctx->seg_name) );\n\t\tgf_filter_pck_set_property(ctx->dst_pck, GF_PROP_PCK_FILENUM, &PROP_UINT(ctx->dash_seg_num_plus_one-1) );\n\t}\n\n\tif (ctx->min_cts_plus_one) {\n\t\tu64 orig = ctx->min_cts_plus_one-1;\n\t\tgf_filter_pck_set_cts(ctx->dst_pck, orig);\n\t\t//if we have a source packet duration, use it\n\t\tif (src_pck_dur)\n\t\t\tgf_filter_pck_set_duration(ctx->dst_pck, src_pck_dur);\n\t\t//it may happen that we don't know precisely the min_cts_next_frag, this is a rough compute based on desire frag dur\n\t\t//if duration is wrong, signal to send asap (dur = 1)\n\t\telse if (ctx->min_cts_next_frag > orig)\n\t\t\tgf_filter_pck_set_duration(ctx->dst_pck, (u32) (ctx->min_cts_next_frag - orig) );\n\t\telse\n\t\t\tgf_filter_pck_set_duration(ctx->dst_pck, 1);\n\t}\n\n\tif ((ctx->llhls_mode>1) && ctx->fragment_started && !ctx->frag_size && ctx->dst_pck) {\n\t\tctx->frag_num++;\n\t\tgf_filter_pck_set_property(ctx->dst_pck, GF_PROP_PCK_HLS_FRAG_NUM, &PROP_UINT(ctx->frag_num));\n\t}\n\tctx->frag_size += block_size;\n\n\tctx->first_pck_sent = GF_TRUE;\n\tctx->current_size += block_size;\n\t//non-frag mode, send right away\n\tif ((ctx->store<MP4MX_MODE_FRAG) || ctx->seg_flush_state) {\n\t\tmp4mux_send_output(ctx);\n\t}\n\treturn GF_OK;\n}\n\nvoid mp4_mux_progress_cbk(void *udta, u64 done, u64 total)\n{\n\tGF_Filter *filter = (GF_Filter *)udta;\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\tctx->update_report = GF_TRUE;\n\tmp4_mux_format_report(ctx, done, total);\n}\n\nstatic GF_Err mp4_mux_initialize(GF_Filter *filter)\n{\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\tgf_filter_set_max_extra_input_pids(filter, -1);\n\tctx->filter = filter;\n#ifdef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (ctx->store>=MP4MX_MODE_FRAG) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot use fragmented mode, disabled in build\\n\"));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n#endif\n\tif (ctx->file) {\n\t\tif (gf_isom_get_mode(ctx->file) < GF_ISOM_OPEN_WRITE) return GF_BAD_PARAM;\n\t\tif (ctx->store>=MP4MX_MODE_FRAG) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot use fragmented output on already opened ISOBMF file\\n\"));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tctx->owns_mov = GF_FALSE;\n\t\tgf_filter_act_as_sink(filter);\n\t} else {\n\t\tu32 open_mode = GF_ISOM_OPEN_WRITE;\n\t\tctx->owns_mov = GF_TRUE;\n\n\t\tswitch (ctx->store) {\n\t\tcase MP4MX_MODE_INTER:\n\t\tcase MP4MX_MODE_TIGHT:\n\t\t\topen_mode = GF_ISOM_WRITE_EDIT;\n\t\t\tbreak;\n\t\t}\n\t\tctx->file = gf_isom_open(\"_gpac_isobmff_redirect\", open_mode, NULL);\n\t\tif (!ctx->file) return GF_OUT_OF_MEM;\n\n\t\tgf_isom_set_write_callback(ctx->file, mp4_mux_on_data, mp4_mux_on_data_patch, mp4_mux_on_last_block_start, ctx, ctx->block_size);\n\n\t\tgf_isom_set_progress_callback(ctx->file, mp4_mux_progress_cbk, filter);\n\n\t\tif (ctx->dref && (ctx->store>=MP4MX_MODE_FRAG)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot use data reference in movie fragments, not supported. Ignoring it\\n\"));\n\t\t\tctx->dref = GF_FALSE;\n\t\t}\n\n\t\tif (ctx->store==MP4MX_MODE_FASTSTART) {\n\t\t\tgf_isom_set_storage_mode(ctx->file, GF_ISOM_STORE_FASTSTART);\n\t\t}\n\t}\n\n\tif (!ctx->moovts)\n\t\tctx->moovts=600;\n\n\tif ((ctx->store==MP4MX_MODE_FASTSTART) && (!ctx->cdur.num || !ctx->cdur.den)) {\n\t\tctx->cdur.num = 1;\n\t\tctx->cdur.den = 1;\n\t}\n\tif (!ctx->cdur.den) {\n\t\tctx->cdur.num = 0;\n\t\tctx->cdur.den = 1000;\n\t}\n\t//we need at least ms precision for sfrag mode\n\tif (ctx->cdur.den < 1000) {\n\t\tctx->cdur.num = (s32) ( ((s64)ctx->cdur.num) * 1000 / ctx->cdur.den);\n\t\tctx->cdur.den = 1000;\n\t}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (ctx->mfra && (ctx->store>=MP4MX_MODE_FRAG)) {\n\t\tGF_Err e = gf_isom_enable_mfra(ctx->file);\n\t\tif (e) return e;\n\t}\n#endif\n\n\tif (!ctx->tracks)\n\t\tctx->tracks = gf_list_new();\n\n\tif (!ctx->ref_pcks)\n\t\tctx->ref_pcks = gf_list_new();\n\n#ifdef GF_ENABLE_CTRN\n\tif (ctx->ctrni)\n\t\tctx->ctrn = GF_TRUE;\n#endif\n\n\tif (ctx->m4cc) {\n\t\tif (strlen(ctx->m4cc)==4)\n\t\t\tctx->eos_marker = GF_4CC(ctx->m4cc[0], ctx->m4cc[1], ctx->m4cc[2], ctx->m4cc[3]);\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Invalid segment marker 4cc %s, ignoring\\n\", ctx->m4cc));\n\t\t}\n\t}\n\tif (ctx->compress) {\n\t\tu32 flags = 0;\n\t\tif (ctx->fcomp) flags |= GF_ISOM_COMP_FORCE_ALL;\n\t\tif (ctx->otyp) flags |= GF_ISOM_COMP_WRAP_FTYPE;\n\t\tgf_isom_enable_compression(ctx->file, ctx->compress, flags);\n\t}\n\n\tif ((ctx->store>=MP4MX_MODE_FRAG) && !ctx->tsalign)\n\t\tctx->insert_tfdt = GF_TRUE;\n\n\tif (ctx->cmaf) {\n\t\t//cf table 3, 4, 5 of CMAF\n\t\tctx->mvex = GF_TRUE;\n\t\tctx->truns_first = GF_TRUE;\n\t\t//single trun, single traf (table 5 of CMAF)\n\t\tctx->strun = GF_TRUE;\n\t\tctx->straf = GF_TRUE;\n\t\t//7.5.16 Every TrackFragmentBox shall contain a TrackFragmentBaseMediaDecodeTimeBox\n\t\tctx->tfdt_traf = GF_TRUE;\n\t\t//7.3.3 : If SegmentIndexBoxes exist, each subsegment referenced in the SegmentIndexBox shall be a single CMAF fragment\n\t\tctx->chain_sidx = GF_FALSE;\n\t\tif (ctx->subs_sidx>0)\n\t\t\tctx->subs_sidx = 0;\n\n\t\tif (ctx->cmaf==MP4MX_CMAF_CMF2) {\n\t\t\t/*7.7 cmf2\n- default_sample_flags, sample_flags and first_sample_flags shall be set in the TrackFragmentHeaderBox and/or TrackRunBox to provide sample dependency information within each CMAF chunk and CMAF fragment.\n- Default values or per sample values of sample duration and sample size shall be stored in each CMAF chunk\u2019s TrackRunBox and/or TrackFragmentHeaderBox\n\t\t\t*/\n\t\t\tctx->nofragdef = GF_TRUE;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nstatic void mp4_mux_update_edit_list_for_bframes(GF_MP4MuxCtx *ctx, TrackWriter *tkw, u32 ctts_mode)\n{\n\tu64 max_cts, min_cts;\n\ts64 moffset;\n\n\tif (ctts_mode > MP4MX_CT_EDIT) return;\n\n\t//if we have a complex edit list (due to track template), don't override\n\tif (gf_isom_get_edit_list_type(ctx->file, tkw->track_num, &moffset)) return;\n\n\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\n\tmax_cts = tkw->max_cts - tkw->min_neg_ctts;\n\tmin_cts = tkw->min_cts - tkw->min_neg_ctts;\n\n\tif (min_cts || tkw->empty_init_dur) {\n\t\tmax_cts -= min_cts;\n\t\tu32 count = gf_isom_get_sample_count(ctx->file, tkw->track_num);\n\t\tmax_cts += gf_isom_get_sample_duration(ctx->file, tkw->track_num, count);\n\n\t\tmax_cts = gf_timestamp_rescale(max_cts, tkw->tk_timescale, ctx->moovts);\n\n\t\tif (tkw->empty_init_dur) {\n\t\t\tgf_isom_set_edit(ctx->file, tkw->track_num, 0, tkw->empty_init_dur, 0, GF_ISOM_EDIT_EMPTY);\n\t\t}\n\t\t//old arch compat: if we had a simple edit list in source try to keep the original segduration indicated\n\t\t//we tolerate a diff of 100ms\n\t\telse if (gf_sys_old_arch_compat() && tkw->imported_edit_sdur && (tkw->imported_edit_offset==min_cts)) {\n\t\t\ts32 diff;\n\t\t\tu64 old_dur_ms = gf_timestamp_rescale(tkw->imported_edit_sdur, tkw->src_timescale, 1000);\n\t\t\tu64 new_dur_ms = gf_timestamp_rescale(max_cts, tkw->tk_timescale, 1000);\n\t\t\tdiff = (s32) new_dur_ms - (s32) old_dur_ms;\n\t\t\tif (ABS(diff)<100)\n\t\t\t\tmax_cts = tkw->imported_edit_sdur;\n\t\t}\n\n\t\tgf_isom_set_edit(ctx->file, tkw->track_num, tkw->empty_init_dur, max_cts, min_cts, GF_ISOM_EDIT_NORMAL);\n\t}\n}\n\n//todo: move from media_import.c to here once done\nvoid gf_media_update_bitrate(GF_ISOFile *file, u32 track);\n\n\nstatic void mp4_mux_set_hevc_groups(GF_MP4MuxCtx *ctx, TrackWriter *tkw)\n{\n\tu32 avc_base_track, hevc_base_track, ref_track_id;\n\tavc_base_track = hevc_base_track = 0;\n\tu32 i;\n\tu32 min_lid = 0;\n\tGF_PropertyEntry *pe=NULL;\n\tconst GF_PropertyValue *p = gf_filter_pid_get_info_str(tkw->ipid, \"hevc:oinf\", &pe);\n\tif (p) {\n\t\tu32 gi=0;\n\t\tgf_isom_remove_sample_group(ctx->file, tkw->track_num, GF_ISOM_SAMPLE_GROUP_OINF);\n\t\tgf_isom_add_sample_group_info(ctx->file, tkw->track_num, GF_ISOM_SAMPLE_GROUP_OINF, p->value.data.ptr, p->value.data.size, GF_TRUE, &gi);\n\t}\n\tp = gf_filter_pid_get_info_str(tkw->ipid, \"hevc:linf\", &pe);\n\tif (p) {\n\t\tu32 gi=0;\n\t\tgf_isom_remove_sample_group(ctx->file, tkw->track_num, GF_ISOM_SAMPLE_GROUP_LINF);\n\t\tgf_isom_add_sample_group_info(ctx->file, tkw->track_num, GF_ISOM_SAMPLE_GROUP_LINF, p->value.data.ptr, p->value.data.size, GF_TRUE, &gi);\n\t\tgf_isom_set_track_group(ctx->file, tkw->track_num, 1000+gf_isom_get_track_id(ctx->file, tkw->track_num), GF_ISOM_BOX_TYPE_CSTG, GF_TRUE);\n\t}\n\n\tp = gf_filter_pid_get_info_str(tkw->ipid, \"hevc:min_lid\", &pe);\n\tif (p) min_lid = p->value.uint;\n\n\tgf_filter_release_property(pe);\n\n\tif (!min_lid && (tkw->codecid!=GF_CODECID_LHVC)) {\n\t\treturn;\n\t}\n\t//set linf\n\tfor (i=0; i < gf_isom_get_track_count(ctx->file); i++) {\n\t\tu32 subtype = gf_isom_get_media_subtype(ctx->file, i+1, 1);\n\t\tswitch (subtype) {\n\t\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\t\tif (!avc_base_track) {\n\t\t\t\tavc_base_track = i+1;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Warning: More than one AVC bitstream found, use track %d as base layer\", avc_base_track));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t\tif (!hevc_base_track) {\n\t\t\t\thevc_base_track = i+1;\n\t\t\t\tif (avc_base_track) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Warning: Found both AVC and HEVC tracks, using HEVC track %d as base layer\\n\", hevc_base_track));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Warning: More than one HEVC bitstream found, use track %d as base layer\\n\", avc_base_track));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!hevc_base_track && !avc_base_track) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Using LHVC external base layer, but no base layer not found - NOT SETTING SBAS TRACK REFERENCE!\\n\"));\n\t} else {\n\t\tref_track_id = gf_isom_get_track_id(ctx->file, hevc_base_track ? hevc_base_track : avc_base_track);\n\t\tgf_isom_set_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_BASE, ref_track_id);\n\n\t\tif (hevc_base_track) {\n\t\t\tref_track_id = gf_isom_get_track_id(ctx->file, hevc_base_track);\n\t\t\tgf_isom_set_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_OREF, ref_track_id);\n\t\t\tgf_isom_remove_sample_group(ctx->file, tkw->track_num, GF_ISOM_SAMPLE_GROUP_OINF);\n\t\t}\n\t}\n}\n\nstatic GF_Err mp4_mux_done(GF_MP4MuxCtx *ctx, Bool is_final)\n{\n\tGF_Err e = GF_OK;\n\tu32 i, count;\n\tGF_PropertyEntry *pe=NULL;\n\n\tcount = gf_list_count(ctx->tracks);\n\tfor (i=0; i<count; i++) {\n\t\tu32 ctts_mode = ctx->ctmode;\n\t\tconst GF_PropertyValue *p;\n\t\tBool has_bframes = GF_FALSE;\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_FORCE_NEGCTTS);\n\t\tif (p && p->value.boolean) ctts_mode = MP4MX_CT_NEGCTTS;\n\n\t\tif (tkw->min_neg_ctts<0) {\n\t\t\t//use ctts v1 negative offsets\n\t\t\tif (ctts_mode==MP4MX_CT_NEGCTTS) {\n\t\t\t\tgf_isom_set_ctts_v1(ctx->file, tkw->track_num, (u32) -tkw->min_neg_ctts);\n\t\t\t}\n\t\t\t//ctts v0\n\t\t\telse {\n\t\t\t\tgf_isom_set_cts_packing(ctx->file, tkw->track_num, GF_TRUE);\n\t\t\t\tgf_isom_shift_cts_offset(ctx->file, tkw->track_num, (s32) tkw->min_neg_ctts);\n\t\t\t\tgf_isom_set_cts_packing(ctx->file, tkw->track_num, GF_FALSE);\n\t\t\t\tgf_isom_set_composition_offset_mode(ctx->file, tkw->track_num, GF_FALSE);\n\n\t\t\t\tmp4_mux_update_edit_list_for_bframes(ctx, tkw, ctts_mode);\n\t\t\t}\n\t\t\thas_bframes = GF_TRUE;\n\t\t} else if (tkw->has_ctts && (tkw->stream_type==GF_STREAM_VISUAL)) {\n\t\t\tmp4_mux_update_edit_list_for_bframes(ctx, tkw, ctts_mode);\n\n\t\t\thas_bframes = GF_TRUE;\n\t\t} else if (tkw->ts_delay || tkw->empty_init_dur) {\n\t\t\tgf_isom_update_edit_list_duration(ctx->file, tkw->track_num);\n\t\t}\n\n\t\tif (tkw->min_ts_seek_plus_one) {\n\t\t\tu64 min_ts = tkw->min_ts_seek_plus_one - 1;\n\t\t\tu64 mdur = gf_isom_get_media_duration(ctx->file, tkw->track_num);\n\t\t\tu32 delay = 0;\n\t\t\tif (tkw->clamp_ts_plus_one) {\n\t\t\t\tmdur = tkw->max_cts - tkw->min_cts;\n\t\t\t\tmdur += tkw->max_cts_samp_dur;\n\t\t\t}\n\t\t\tif (mdur > min_ts)\n\t\t\t\tmdur -= min_ts;\n\t\t\telse\n\t\t\t\tmdur = 0;\n\n\t\t\tif ((ctts_mode != MP4MX_CT_NEGCTTS) && (tkw->ts_delay<0) && (tkw->stream_type==GF_STREAM_VISUAL)) {\n\t\t\t\tdelay = (u32) -tkw->ts_delay;\n\t\t\t}\n\n\t\t\tif (tkw->src_timescale != tkw->tk_timescale) {\n\t\t\t\tmin_ts = gf_timestamp_rescale(min_ts, tkw->src_timescale, tkw->tk_timescale);\n\t\t\t\tdelay = (u32) gf_timestamp_rescale(delay, tkw->src_timescale, tkw->tk_timescale);\n\t\t\t}\n\t\t\tmdur += delay;\n\n\t\t\tif (ctx->moovts != tkw->tk_timescale) {\n\t\t\t\tmdur = gf_timestamp_rescale(mdur, tkw->tk_timescale, ctx->moovts);\n\t\t\t}\n\t\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\t\t\tif (tkw->empty_init_dur)\n\t\t\t\tgf_isom_set_edit(ctx->file, tkw->track_num, 0, tkw->empty_init_dur, 0, GF_ISOM_EDIT_EMPTY);\n\t\t\tgf_isom_set_edit(ctx->file, tkw->track_num, tkw->empty_init_dur, mdur, min_ts, GF_ISOM_EDIT_NORMAL);\n\t\t}\n\n\t\tif (tkw->force_ctts) {\n\t\t\tGF_Err gf_isom_force_ctts(GF_ISOFile *file, u32 track);\n\t\t\tgf_isom_force_ctts(ctx->file, tkw->track_num);\n\t\t}\n\n\t\tgf_isom_purge_track_reference(ctx->file, tkw->track_num);\n\t\t\n\t\tif (ctx->importer && ctx->dur.num && ctx->dur.den) {\n\t\t\tu64 mdur = gf_isom_get_media_duration(ctx->file, tkw->track_num);\n\t\t\tu64 pdur = gf_isom_get_track_duration(ctx->file, tkw->track_num);\n\t\t\tif (pdur==mdur) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[MP4Mux] Imported %d frames - duration %g\\n\", tkw->nb_samples, ((Double)mdur)/tkw->tk_timescale ));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[MP4Mux] Imported %d frames - media duration %g - track duration %g\\n\", tkw->nb_samples, ((Double)mdur)/tkw->tk_timescale, ((Double)pdur)/ctx->moovts ));\n\t\t\t}\n\t\t}\n\n\t\t/*this is plain ugly but since some encoders (divx) don't use the video PL correctly\n\t\t we force the system video_pl to ASP@L5 since we have I, P, B in base layer*/\n\t\tif (tkw->codecid == GF_CODECID_MPEG4_PART2) {\n\t\t\tBool force_rewrite = GF_FALSE;\n\t\t\tu32 PL = tkw->media_profile_level;\n\t\t\tif (!PL) PL = 0x01;\n\n\t\t\tif (ctx->importer) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"Indicated Profile: %s\\n\", gf_m4v_get_profile_name((u8) PL) ));\n\t\t\t}\n\n\t\t\tif (has_bframes && (tkw->media_profile_level <= 3)) {\n\t\t\t\tPL = 0xF5;\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Indicated profile doesn't include B-VOPs - forcing %s\\n\", gf_m4v_get_profile_name((u8) PL) ));\n\t\t\t\tforce_rewrite = GF_TRUE;\n\t\t\t}\n\t\t\tif (PL != tkw->media_profile_level) {\n\t\t\t\tif (force_rewrite) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tGF_ESD *esd = gf_isom_get_esd(ctx->file, tkw->track_num, tkw->stsd_idx);\n\t\t\t\t\tassert(esd);\n\t\t\t\t\tgf_m4v_rewrite_pl(&esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength, (u8) PL);\n\t\t\t\t\tgf_isom_change_mpeg4_description(ctx->file, tkw->track_num, tkw->stsd_idx, esd);\n\t\t\t\t\tgf_odf_desc_del((GF_Descriptor*)esd);\n#endif\n\n\t\t\t\t}\n\t\t\t\tif (!ctx->make_qt)\n\t\t\t\t\tgf_isom_set_pl_indication(ctx->file, GF_ISOM_PL_VISUAL, PL);\n\t\t\t}\n\t\t}\n\n\n\t\tif (tkw->has_append)\n\t\t\tgf_isom_refresh_size_info(ctx->file, tkw->track_num);\n\n\t\tif ((tkw->nb_samples == 1) && (ctx->dur.num>0) && ctx->dur.den) {\n\t\t\tu32 dur = (u32) gf_timestamp_rescale(ctx->dur.num, ctx->dur.den, tkw->tk_timescale);\n\t\t\tgf_isom_set_last_sample_duration(ctx->file, tkw->track_num, dur);\n\t\t}\n\n\t\tif (tkw->has_open_gop) {\n\t\t\tif (ctx->importer) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"OpenGOP detected - adjusting file brand\\n\"));\n\t\t\t}\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO6, GF_TRUE);\n\t\t}\n\n\t\tmp4_mux_set_hevc_groups(ctx, tkw);\n\n\t\tp = gf_filter_pid_get_info_str(tkw->ipid, \"ttxt:rem_last\", &pe);\n\t\tif (p && p->value.boolean)\n\t\t\tgf_isom_remove_sample(ctx->file, tkw->track_num, tkw->nb_samples);\n\n\t\tp = gf_filter_pid_get_info_str(tkw->ipid, \"ttxt:last_dur\", &pe);\n\t\tif (p) {\n\t\t\tu64 val = p->value.uint;\n\t\t\tif (tkw->src_timescale != tkw->tk_timescale) {\n\t\t\t\tval = gf_timestamp_rescale(val, tkw->src_timescale, tkw->tk_timescale);\n\t\t\t}\n\t\t\tgf_isom_set_last_sample_duration(ctx->file, tkw->track_num, (u32) val);\n\t\t}\n\n\t\tif (tkw->is_nalu && ctx->pack_nal && (gf_isom_get_mode(ctx->file)!=GF_ISOM_OPEN_WRITE)) {\n\t\t\tu32 msize = 0;\n\t\t\tBool do_rewrite = GF_FALSE;\n\t\t\tu32 j, stsd_count = gf_isom_get_sample_description_count(ctx->file, tkw->track_num);\n\t\t\tp = gf_filter_pid_get_info(tkw->ipid, GF_PROP_PID_MAX_NALU_SIZE, &pe);\n\t\t\tmsize = gf_get_bit_size(p->value.uint);\n\t\t\tif (msize<8) msize = 8;\n\t\t\telse if (msize<16) msize = 16;\n\t\t\telse msize = 32;\n\n\t\t\tif (msize<=0xFFFF) {\n\t\t\t\tfor (j=0; j<stsd_count; j++) {\n\t\t\t\t\tu32 k = 8 * gf_isom_get_nalu_length_field(ctx->file, tkw->track_num, j+1);\n\t\t\t\t\tif (k > msize) {\n\t\t\t\t\t\tdo_rewrite = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (do_rewrite) {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[MP4Mux] Adjusting NALU SizeLength to %d bits\\n\", msize ));\n\t\t\t\t\tgf_media_nal_rewrite_samples(ctx->file, tkw->track_num, msize);\n\t\t\t\t\tmsize /= 8;\n\t\t\t\t\tfor (j=0; j<stsd_count; j++) {\n\t\t\t\t\t\tgf_isom_set_nalu_length_field(ctx->file, tkw->track_num, j+1, msize);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//don't update bitrate info for single sample tracks, unless MPEG-4 Systems - compatibility with old arch\n\t\tif (ctx->btrt && !tkw->skip_bitrate_update && ((tkw->nb_samples>1) || ctx->m4sys) )\n\t\t\tgf_media_update_bitrate(ctx->file, tkw->track_num);\n\n\t\tif (!tkw->box_patched) {\n\t\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"boxpatch\");\n\t\t\tif (p && p->value.string) {\n\t\t\t\te = gf_isom_apply_box_patch(ctx->file, tkw->track_id ? tkw->track_id : tkw->item_id, p->value.string, GF_FALSE);\n\t\t\t\tif (e) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to apply box patch %s to track %d: %s\\n\",\n\t\t\t\t\t\tp->value.string, tkw->track_id, gf_error_to_string(e) ));\n\t\t\t\t}\n\t\t\t}\n\t\t\ttkw->box_patched = GF_TRUE;\n\t\t}\n\t}\n\n\tgf_filter_release_property(pe);\n\n\tif (ctx->boxpatch && !ctx->box_patched) {\n\t\te = gf_isom_apply_box_patch(ctx->file, 0, ctx->boxpatch, GF_FALSE);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to apply box patch %s: %s\\n\", ctx->boxpatch, gf_error_to_string(e) ));\n\t\t}\n\t\tctx->box_patched = GF_TRUE;\n\t}\n\n\n\tif (ctx->owns_mov) {\n\t\tif (ctx->moovpad)\n\t\t\tgf_isom_set_inplace_padding(ctx->file, ctx->moovpad);\n\n\t\tswitch (ctx->store) {\n\t\tcase MP4MX_MODE_INTER:\n\t\t\tif (ctx->cdur.num==0) {\n\t\t\t\te = gf_isom_set_storage_mode(ctx->file, GF_ISOM_STORE_STREAMABLE);\n\t\t\t} else {\n\t\t\t\tif (ctx->cdur.num < 0) ctx->cdur.num = 1000;\n\t\t\t\te = gf_isom_make_interleave_ex(ctx->file, &ctx->cdur);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MP4MX_MODE_FLAT:\n\t\t\te = gf_isom_set_storage_mode(ctx->file, GF_ISOM_STORE_FLAT);\n\t\t\tbreak;\n\t\tcase MP4MX_MODE_FASTSTART:\n\t\t\te = gf_isom_set_storage_mode(ctx->file, GF_ISOM_STORE_FASTSTART);\n\t\t\tbreak;\n\t\tcase MP4MX_MODE_TIGHT:\n\t\t\te = gf_isom_set_storage_mode(ctx->file, GF_ISOM_STORE_TIGHT);\n\t\t\tbreak;\n\t\t}\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set storage mode: %s\\n\", gf_error_to_string(e) ));\n\t\t\tgf_isom_delete(ctx->file);\n\t\t} else {\n\t\t\te = gf_isom_close(ctx->file);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to write file: %s\\n\", gf_error_to_string(e) ));\n\t\t\t}\n\t\t}\n\t\tctx->file = NULL;\n\t\tif (is_final)\n\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t} else {\n\t\tctx->file = NULL;\n\t}\n\treturn e;\n}\n\nstatic void mp4_mux_finalize(GF_Filter *filter)\n{\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (ctx->owns_mov && (ctx->file || (ctx->store>=MP4MX_MODE_FRAG))) {\n\t\tif (ctx->store < MP4MX_MODE_FRAG) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Session aborted before writing to file, use fragmented storage mode to record session\\n\"));\n\t\t}\n\t\tgf_isom_delete(ctx->file);\n\t}\n\n\twhile (gf_list_count(ctx->tracks)) {\n\t\tTrackWriter *tkw = gf_list_pop_back(ctx->tracks);\n\t\tmp4_mux_track_writer_del(tkw);\n\t}\n\tgf_list_del(ctx->tracks);\n\tgf_list_del(ctx->ref_pcks);\n\tif (ctx->bs_r) gf_bs_del(ctx->bs_r);\n\tif (ctx->seg_name) gf_free(ctx->seg_name);\n\tif (ctx->tmp_store) gf_fclose(ctx->tmp_store);\n\tif (ctx->seg_sizes) gf_free(ctx->seg_sizes);\n\n\tif (ctx->cur_file_suffix) gf_free(ctx->cur_file_suffix);\n\n}\n\nstatic const GF_FilterCapability MP4MuxCaps[] =\n{\n\t//for now don't accept files as input, although we could store them as items, to refine\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_SCENE),\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_OD),\n\t//we want framed media only\n\tCAP_BOOL(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t//and any codecid\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED,  GF_PROP_PID_CODECID, GF_CODECID_NONE),\n\tCAP_STRING(GF_CAPS_OUTPUT_STATIC,  GF_PROP_PID_FILE_EXT, ISOM_FILE_EXT),\n\tCAP_STRING(GF_CAPS_OUTPUT_STATIC,  GF_PROP_PID_MIME, ISOM_FILE_MIME),\n\t{0},\n\t//for scene / OD / text, we don't want raw codecid (filters modifying a scene graph we don't expose)\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_SCENE),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_OD),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_TEXT),\n\tCAP_BOOL(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_CODECID, GF_CODECID_RAW),\n};\n\n\n#define OFFS(_n)\t#_n, offsetof(GF_MP4MuxCtx, _n)\nstatic const GF_FilterArgs MP4MuxArgs[] =\n{\n\t{ OFFS(m4sys), \"force MPEG-4 Systems signaling of tracks\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(dref), \"only reference data from source file - not compatible with all media sources\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ctmode), \"set composition offset mode for video tracks\\n\"\n\t\"- edit: uses edit lists to shift first frame to presentation time 0\\n\"\n\t\"- noedit: ignore edit lists and does not shift timeline\\n\"\n\t\"- negctts: uses ctts v1 with possibly negative offsets and no edit lists\", GF_PROP_UINT, \"edit\", \"edit|noedit|negctts\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(dur), \"only import the specified duration. If negative, specify the number of coded frames to import\", GF_PROP_FRACTION, \"0\", NULL, 0},\n\t{ OFFS(pack3gp), \"pack a given number of 3GPP audio frames in one sample\", GF_PROP_UINT, \"1\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(importer), \"compatibility with old importer, displays import progress\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(pack_nal), \"repack NALU size length to minimum possible size for NALU-based video (AVC/HEVC/...)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(xps_inband), \"use inband (in sample data) parameter set for NALU-based video (AVC/HEVC/...)\\n\"\n\t\"- no: parameter sets are not inband, several sample descriptions might be created\\n\"\n\t\"- pps: picture parameter sets are inband, all other parameter sets are in sample description\\n\"\n\t\"- all: parameter sets are inband, no parameter sets in sample description\\n\"\n\t\"- both: parameter sets are inband, signaled as inband, and also first set is kept in sample description\\n\"\n\t\"- mix: creates non-standard files using single sample entry with first PSs found, and moves other PS inband\\n\"\n\t\"- auto: keep source config, or defaults to no if source is not ISOBMFF\", GF_PROP_UINT, \"no\", \"no|pps|all|both|mix|auto\", 0},\n\t{ OFFS(store), \"file storage mode\\n\"\n\t\"- inter: perform precise interleave of the file using [-cdur]() (requires temporary storage of all media)\\n\"\n\t\"- flat: write samples as they arrive and `moov` at end (fastest mode)\\n\"\n\t\"- fstart: write samples as they arrive and `moov` before `mdat`\\n\"\n\t\"- tight: uses per-sample interleaving of all tracks (requires temporary storage of all media)\\n\"\n\t\"- frag: fragments the file using cdur duration\\n\"\n\t\"- sfrag: fragments the file using cdur duration but adjusting to start with SAP1/3\", GF_PROP_UINT, \"inter\", \"inter|flat|fstart|tight|frag|sfrag\", 0},\n\t{ OFFS(cdur), \"chunk duration for flat and interleaving modes or fragment duration for fragmentation modes\\n\"\n\t\"- 0: no specific interleaving but moov first\\n\"\n\t\"- negative: defaults to 1.0 unless overridden by storage profile\", GF_PROP_FRACTION, \"-1/1\", NULL, 0},\n\t{ OFFS(moovts), \"timescale to use for movie. A negative value picks the media timescale of the first track added\", GF_PROP_SINT, \"600\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(moof_first), \"generate fragments starting with moof then mdat\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(abs_offset), \"use absolute file offset in fragments rather than offsets from moof\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(fsap), \"split truns in video fragments at SAPs to reduce file size\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(file), \"pointer to a write/edit ISOBMF file used internally by importers and exporters\", GF_PROP_POINTER, NULL, NULL, GF_FS_ARG_HINT_HIDE},\n\t{ OFFS(subs_sidx), \"number of subsegments per sidx. negative value disables sidx, -2 removes sidx if present in source PID\", GF_PROP_SINT, \"-1\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(m4cc), \"4 character code of empty box to append at the end of a segment (DASH mode) or of a fragment (non-DASH mode)\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(chain_sidx), \"use daisy-chaining of SIDX\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(msn), \"sequence number of first moof to N\", GF_PROP_UINT, \"1\", NULL, 0},\n\t{ OFFS(msninc), \"sequence number increase between `moof` boxes\", GF_PROP_UINT, \"1\", NULL, 0},\n\t{ OFFS(tfdt), \"set initial decode time (`tfdt`) of first traf\", GF_PROP_FRACTION64, \"0\", NULL, 0},\n\t{ OFFS(tfdt_traf), \"force `tfdt` box in each traf\", GF_PROP_BOOL, \"false\", NULL, 0},\n\t{ OFFS(nofragdef), \"disable default flags in fragments\", GF_PROP_BOOL, \"false\", NULL, 0},\n\t{ OFFS(straf), \"use a single traf per moof (smooth streaming and co)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(strun), \"use a single trun per traf (smooth streaming and co)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(psshs), \"set `pssh` boxes store mode\\n\"\n\t\"- moof: in first moof of each segments\\n\"\n\t\"- moov: in movie box\\n\"\n\t\"- both: in movie box and in first moof of each segment\\n\"\n\t\"- none: pssh is discarded\", GF_PROP_UINT, \"moov\", \"moov|moof|both|none\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(sgpd_traf), \"store sample group descriptions in traf (duplicated for each traf). If not used, sample group descriptions are stored in the movie box\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(vodcache), \"enable temp storage for VoD dash modes\\n\"\n\t\t\"- on: use temp storage of complete file for sidx and ssix injection\\n\"\n\t\t\"- insert: insert sidx and ssix by shifting bytes in output file\\n\"\n\t\t\"- replace: precompute pace requirements for sidx and ssix and rewrite file range at end\", GF_PROP_UINT, \"replace\", \"on|insert|replace\", 0},\n\t{ OFFS(noinit), \"do not produce initial `moov, used for DASH bitstream switching mode\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(tktpl), \"use track box from input if any as a template to create new track\\n\"\n\t\"- no: disables template\\n\"\n\t\"- yes: clones the track (except edits and decoder config)\\n\"\n\t\"- udta: only loads udta\", GF_PROP_UINT, \"yes\", \"no|yes|udta\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(mudta), \"use `udta` and other `moov` extension boxes from input if any\\n\"\n\t\"- no: disables import\\n\"\n\t\"- yes: clones all extension boxes\\n\"\n\t\"- udta: only loads udta\", GF_PROP_UINT, \"yes\", \"no|yes|udta\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(mvex), \"set `mvex` boxes after `trak` boxes\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(sdtp_traf), \"use `sdtp` box in `traf` box rather than using flags in trun sample entries\\n\"\n\t\t\"- no: do not use `sdtp`\\n\"\n\t\t\"- sdtp: use `sdtp` box to indicate sample dependencies and do not write info in `trun` sample flags\\n\"\n\t\t\"- both: use `sdtp` box to indicate sample dependencies and also write info in `trun` sample flags\", GF_PROP_UINT, \"no\", \"no|sdtp|both\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(trackid), \"track ID of created track for single track. Default 0 uses next available trackID\", GF_PROP_UINT, \"0\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(fragdur), \"fragment based on fragment duration rather than CTS. Mostly used for `MP4Box -frag` option\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(btrt), \"set `btrt` box in sample description\", GF_PROP_BOOL, \"true\", NULL, 0},\n\t{ OFFS(styp), \"set segment `styp` major brand (and optionally version) to the given 4CC[.version]\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(mediats), \"set media timescale. A value of 0 means inherit from PID, a value of -1 means derive from samplerate or frame rate\", GF_PROP_SINT, \"0\", NULL, 0},\n\t{ OFFS(ase), \"set audio sample entry mode for more than stereo layouts\\n\"\n\t\t\t\"- v0: use v0 signaling but channel count from stream, recommended for backward compatibility\\n\"\n\t\t\t\"- v0s: use v0 signaling and force channel count to 2 (stereo) if more than 2 channels\\n\"\n\t\t\t\"- v1: use v1 signaling, ISOBMFF style (will mux raw PCM as ISOBMFF style)\\n\"\n\t\t\t\"- v1qt: use v1 signaling, QTFF style\\n\"\n\t\t\t\"- v2qt: use v2 signaling, QTFF style (lpcm entry type)\"\n\t\t, GF_PROP_UINT, \"v0\", \"|v0|v0s|v1|v1qt|v2qt\", 0},\n\t{ OFFS(ssix), \"create `ssix` box when `sidx` box is present, level 1 mapping I-frames byte ranges, level 0xFF mapping the rest\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ccst), \"insert coding constraint box for video tracks\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(maxchunk), \"set max chunk size in bytes for runs (only used in non-fragmented mode). 0 means no constraints\", GF_PROP_UINT, \"0\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(noroll), \"disable roll sample grouping\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(norap), \"disable rap sample grouping\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(saio32), \"use 32 bit offset for side data location instead of 64 bit offset\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(tfdt64), \"use 64 bit tfdt and sidx even for 32 bits timestamps\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n#ifdef GF_ENABLE_CTRN\n\t{ OFFS(ctrn), \"use compact track run (experimental)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ctrni), \"use inheritance in compact track run for HEVC tile tracks (highly experimental)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n#endif\n\t{ OFFS(sseg), \"set single segment mode for dash\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_HIDE},\n\n\t{ OFFS(compress), \"set top-level box compression mode\\n\"\n\t\t\t\t\t\t\"- no: disable box compression\\n\"\n\t\t\t\t\t\t\"- moov: compress only moov box (uses cmov for QT)\\n\"\n\t\t\t\t\t\t\"- moof: compress only moof boxes\\n\"\n\t\t\t\t\t\t\"- sidx: compress moof and sidx boxes\\n\"\n\t\t\t\t\t\t\"- ssix: compress moof, sidx and ssix boxes\\n\"\n\t\t\t\t\t\t\"- all: compress moov, moof, sidx and ssix boxes\", GF_PROP_UINT, \"no\", \"no|moov|moof|sidx|ssix|all\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(fcomp), \"force using compress box even when compressed size is larger than uncompressed\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(otyp), \"inject original file type when using compressed boxes\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\n\t{ OFFS(trun_inter), \"interleave samples in `trun` based on the temporal level, the lowest level are stored first (this will create as many `trun` boxes as required)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(truns_first), \"store track runs before sample group description and sample encryption information\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(block_size), \"target output block size, 0 for default internal value (10k)\", GF_PROP_UINT, \"10000\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(boxpatch), \"apply box patch before writing\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(deps), \"add samples dependencies information\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(mfra), \"enable movie fragment random access when fragmenting (ignored when dashing)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(forcesync), \"force all SAP types to be considered sync samples (might produce non-compliant files)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(refrag), \"use track fragment defaults from initial file if any rather than computing them from PID properties (used when processing standalone segments/fragments)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(itags), \"tag injection mode\\n\"\n\t\t\t\"- none: do not inject tags\\n\"\n\t\t\t\"- strict: only inject recognized itunes tags\\n\"\n\t\t\t\"- all: inject all possible tags\"\n\t\t\t, GF_PROP_UINT, \"strict\", \"none|strict|all\", GF_FS_ARG_HINT_EXPERT},\n\n\t{ OFFS(keep_utc), \"force all new files and tracks to keep the source UTC creation and modification times\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(pps_inband), \"when [-xps_inband]() is set, inject PPS in each non SAP 1/2/3 sample\", GF_PROP_BOOL, \"no\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(moovpad), \"insert `free` box of given size after `moov` for future in-place editing\", GF_PROP_UINT, \"0\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(cmaf), \"use CMAF guidelines (turns on `mvex`, `truns_first`, `strun`, `straf`, `tfdt_traf`, `chain_sidx` and restricts `subs_sidx` to -1 or 0)\\n\"\n\t\t\"- no: CMAF not enforced\\n\"\n\t\t\"- cmfc: use CMAF `cmfc` guidelines\\n\"\n\t\t\"- cmf2: use CMAF `cmf2` guidelines (turns on `nofragdef`)\"\n\t\t, GF_PROP_UINT, \"no\", \"no|cmfc|cmf2\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(start), \"set playback start offset for MP4Box import only. A negative value means percent of media duration with -1 equal to duration\", GF_PROP_DOUBLE, \"0.0\", NULL, GF_FS_ARG_HINT_HIDE},\n\t{ OFFS(pad_sparse), \"inject sample with no data (size 0) to keep durations in unknown sparse text and metadata tracks\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(force_dv), \"force DV sample entry types even when AVC/HEVC compatibility is signaled\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(dvsingle), \"ignore DolbyVision profile 8 in xps inband mode if profile 5 is already set\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(tsalign), \"enable timeline realignment to 0 for first sample - if false, this will keep original timing with empty edit (possibly long) at begin)\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(chapm), \"chapter storage mode\\n\"\n\t\"- off: disable chapters\\n\"\n\t\"- tk: use chapter track (QT-style)\\n\"\n\t\"- udta: use user-data box chapters\\n\"\n\t\"- both: use both chapter tracks and udta\"\n\t, GF_PROP_UINT, \"both\", \"off|tk|udta|both\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(patch_dts), \"patch previous samples duration when dts do not increase monotonically\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(uncv), \"use uncv (ISO 23001-17) for raw video\\n\"\n\t\"- off: disabled (always the case when muxing to QT)\\n\"\n\t\"- gen: enabled, do not write profile\\n\"\n\t\"- prof: enabled and write profile if known\\n\"\n\t\"- tiny: enabled and write reduced version if profile known and compatible\", GF_PROP_UINT, \"prof\", \"off|gen|prof|tiny\", GF_FS_ARG_HINT_EXPERT},\n\t{0}\n};\n\n\nGF_FilterRegister MP4MuxRegister = {\n\t.name = \"mp4mx\",\n\tGF_FS_SET_DESCRIPTION(\"ISOBMFF/QT multiplexer\")\n\tGF_FS_SET_HELP(\"This filter multiplexes streams to ISOBMFF (14496-12 and derived specifications) or QuickTime\\n\"\n\t\"  \\n\"\n\t\"# Tracks and Items\\n\"\n\t\"By default all input PIDs with ItemID property set are multiplexed as items, otherwise they are multiplexed as tracks.\\n\"\n\t\"To prevent source items to be multiplexed as items, use [-itemid](mp4dmx) option from ISOBMFF demultiplexer.\\n\"\n\t\"EX gpac -i source.mp4:itemid=false -o file.mp4\\n\"\n\t\"  \\n\"\n\t\"To force non-item streams to be multiplexed as items, use __#ItemID__ option on that PID:\\n\"\n\t\"EX gpac -i source.jpg:#ItemID=1 -o file.mp4\\n\"\n\t\"  \\n\"\n\t\"# Storage\\n\"\n\t\"The [-store]() option allows controlling if the file is fragmented or not, and when not fragmented, how interleaving is done. For cases where disk requirements are tight and fragmentation cannot be used, it is recommended to use either `flat` or `fstart` modes.\\n\"\n\t\"  \\n\"\n\t\"The [-vodcache]() option allows controlling how DASH onDemand segments are generated:\\n\"\n\t\"- If set to `on`, file data is stored to a temporary file on disk and flushed upon completion, no padding is present.\\n\"\n\t\"- If set to `insert`, SIDX/SSIX will be injected upon completion of the file by shifting bytes in file. In this case, no padding is required but this might not be compatible with all output sinks and will take longer to write the file.\\n\"\n\t\"- If set to `replace`, SIDX/SSIX size will be estimated based on duration and DASH segment length, and padding will be used in the file __before__ the final SIDX. If input PIDs have the properties `DSegs` set, this will used be as the number of segments.\\n\"\n\t\"The `on` and `insert` modes will produce exactly the same file, while the mode `replace` may inject a `free` box before the sidx.\\n\"\n\t\"  \\n\"\n\t\"# Custom boxes\\n\"\n\t\"Custom boxes can be specified as box patches:\\n\"\n\t\"For movie-level patch, the [-boxpatch]() option of the filter should be used.\\n\"\n\t\"Per PID box patch can be specified through the PID property `boxpatch`.\\n\"\n\t\"EX gpac -i source:#boxpatch=myfile.xml -o mux.mp4\\n\"\n\t\"Per Item box patch can be specified through the PID property `boxpatch`.\\n\"\n\t\"EX gpac -i source:1ItemID=1:#boxpatch=myfile.xml -o mux.mp4\\n\"\n\t\"  \\n\"\n\t\"The box patch is applied before writing the initial `moov box in fragmented mode, or when writing the complete file otherwise.\\n\"\n\t\"The box patch can either be a filename or the full XML string.\\n\"\n\t\"  \\n\"\n\t\"# Tagging\\n\"\n\t\"When tagging is enabled, the filter will watch the property `CoverArt` and all custom properties on incoming PID.\\n\"\n\t\"The built-in tag names are indicated by `MP4Box -h tags`.\\n\"\n\t\"QT tags can be specified using `qtt_NAME` property names, and will be added using formatting specified in `MP4Box -h tags`.\\n\"\n\t\"Other tag class may be specified using `tag_NAME` property names, and will be added if [-tags]() is set to `all` using:\\n\"\n\t\"- `NAME` as a box 4CC if `NAME` is four characters long\\n\"\n\t\"- `NAME` as a box 4CC if `NAME` is 3 characters long, and will be prefixed by 0xA9\\n\"\n\t\"- the CRC32 of the `NAME` as a box 4CC if `NAME` is not four characters long\\n\"\n\t\"  \\n\"\n\t\"# User data\\n\"\n\t\"The filter will look for the following PID properties to create user data entries:\\n\"\n\t\"- `udtab`: set the track user-data box to the property value which __must__ be a serialized box array blob\\n\"\n\t\"- `mudtab`: set the movie user-data box to the property value which __must__ be a serialized box array blob\\n\"\n\t\"- `udta_U4CC`: set track user-data box entry of type `U4CC` to property value\\n\"\n\t\"- `mudta_U4CC`: set movie user-data box entry of type `U4CC` to property value\\n\"\n\t\"- `tkgp_T4CC`: set/remove membership to track group with type `T4CC` and ID given by property value. A negative value N removes from track group with ID -N\\n\"\n\t\"  \\n\"\n\t\"EX gpac -i src.mp4:#udta_tagc='My Awesome Tag' -o tag.mp4\\n\"\n\t\"EX gpac -i src.mp4:#mudtab=data@box.bin -o tag.mp4\\n\"\n\t\"  \\n\"\n\t\"# Custom sample group descriptions and sample auxiliary info\\n\"\n\t\"The filter watches the following custom data properties on incoming packets:\\n\"\n\t\"- `grp_A4CC`: maps packet to sample group description of type `A4CC` and entry set to property payload\\n\"\n\t\"- `grp_A4CC_param`: same as above and sets sample to group `grouping_type_parameter` to `param`\\n\"\n\t\"- `sai_A4CC`: adds property payload as sample auxiliary information of type `A4CC`\\n\"\n\t\"- `sai_A4CC_param`: same as above and sets `aux_info_type_parameter`to `param`\\n\"\n\t\"  \\n\"\n\t\"The property `grp_EMSG` consists in one or more `EventMessageBox` as defined in MPEG-DASH.\\n\"\n\t\"- in fragmented mode, presence of these boxes in a packet will start a new fragment, with the boxes written before the `moof`\\n\"\n\t\"- in regular mode, an internal sample group of type `EMSG` is currently used for `emsg` box storage\\n\"\n\t\"  \\n\"\n\t\"# Notes\\n\"\n\t\"The filter watches the property `FileNumber` on incoming packets to create new files (regular mode) or new segments (DASH mode).\\n\"\n\t\"  \\n\"\n\t\"The filter watches the property `DSIWrap` (4CC as int or string) on incoming PID to wrap decoder configuration in a box of given type (unknown wrapping)\\n\"\n\t\"EX -i unkn.mkv:#ISOMSubtype=VIUK:#DSIWrap=cfgv -o t.mp4\\n\"\n\t\"This will wrap the unknown stream using `VIUK` code point in `stsd` and wrap any decoder configuration data in a `cfgv` box.\\n\"\n\t\"\\n\"\n\t\"If [-pad_sparse]() is set, the filter watches the property `Sparse` on incoming PID to decide whether empty packets should be injected to keep packet duration info.\\n\"\n\t\"Such packets are only injected when a whole in the timeline is detected.\\n\"\n\t\"- if `Sparse` is absent, empty packet is inserted for unknown text and metadata streams\\n\"\n\t\"- if `Sparse` is true, empty packet is inserted for all stream types\\n\"\n\t\"- if `Sparse` is false, empty packet is never injected\\n\"\n\t\"  \\n\"\n\t\"The default media type used for a PID can be overriden using property `StreamSubtype`. \\n\"\n\t\"EX -i src.srt:#StreamSubtype=sbtl [-i ...]  -o test.mp4 \\n\"\n\t\"This will force the text stream to use `sbtl` handler type instead of default `text` one.\"\n\t\"\\n\"\n\t\"Subtitle streams may be used as chapters by setting the property `IsChap` on the desired PID.\\n\"\n\t\"EX -i src.srt:#IsChap  [-i ...] -o test.mp4 \\n\"\n\t\"This will force the text stream to be used as a QT chapter track.\"\n\t\"  \\n\"\n\t)\n\t.private_size = sizeof(GF_MP4MuxCtx),\n\t.args = MP4MuxArgs,\n\t.initialize = mp4_mux_initialize,\n\t.finalize = mp4_mux_finalize,\n\t.flags = GF_FS_REG_DYNAMIC_REDIRECT,\n\tSETCAPS(MP4MuxCaps),\n\t.configure_pid = mp4_mux_configure_pid,\n\t.process = mp4_mux_process,\n\t.process_event = mp4_mux_process_event\n};\n\n\nconst GF_FilterRegister *mp4mx_register(GF_FilterSession *session)\n{\n\treturn &MP4MuxRegister;\n}\n#else\nconst GF_FilterRegister *mp4mx_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n#endif // GPAC_DISABLE_ISOM_WRITE\n\n"], "filenames": ["src/filters/mux_isom.c"], "buggy_code_start_loc": [5716], "buggy_code_end_loc": [5717], "fixing_code_start_loc": [5716], "fixing_code_end_loc": [5717], "type": "CWE-190", "message": "Integer Overflow or Wraparound in GitHub repository gpac/gpac prior to 2.3-DEV.", "other": {"cve": {"id": "CVE-2023-4722", "sourceIdentifier": "security@huntr.dev", "published": "2023-09-01T16:15:08.737", "lastModified": "2023-09-06T00:15:42.687", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Integer Overflow or Wraparound in GitHub repository gpac/gpac prior to 2.3-DEV."}, {"lang": "es", "value": "Un Desbordamiento de Enteros o Wraparound en el repositorio de GitHub gpac/gpac versiones anteriores a 2.3-DEV."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 3.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.3-dev", "matchCriteriaId": "F76B0068-AE98-4B7C-885D-B083842F6521"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/de7f3a852bef72a52825fd307cf4e8f486401a76", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/ddfdb41d-e708-4fec-afe5-68ff1f88f830", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/de7f3a852bef72a52825fd307cf4e8f486401a76"}}