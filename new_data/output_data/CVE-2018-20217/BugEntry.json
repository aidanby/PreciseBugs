{"buggy_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* kdc/kdc_util.c - Utility functions for the KDC implementation */\n/*\n * Copyright 1990,1991,2007,2008,2009 by the Massachusetts Institute of Technology.\n * All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n/*\n * Copyright (c) 2006-2008, Novell, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *   * The copyright holder's name is not used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"k5-int.h\"\n#include \"kdc_util.h\"\n#include \"extern.h\"\n#include <stdio.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <kadm5/admin.h>\n#include \"adm_proto.h\"\n#include \"net-server.h\"\n#include <limits.h>\n\n#ifdef KRBCONF_VAGUE_ERRORS\nconst int vague_errors = 1;\n#else\nconst int vague_errors = 0;\n#endif\n\nstatic krb5_error_code kdc_rd_ap_req(kdc_realm_t *kdc_active_realm,\n                                     krb5_ap_req *apreq,\n                                     krb5_auth_context auth_context,\n                                     krb5_db_entry **server,\n                                     krb5_keyblock **tgskey);\nstatic krb5_error_code find_server_key(krb5_context,\n                                       krb5_db_entry *, krb5_enctype,\n                                       krb5_kvno, krb5_keyblock **,\n                                       krb5_kvno *);\n\n/*\n * concatenate first two authdata arrays, returning an allocated replacement.\n * The replacement should be freed with krb5_free_authdata().\n */\nkrb5_error_code\nconcat_authorization_data(krb5_context context,\n                          krb5_authdata **first, krb5_authdata **second,\n                          krb5_authdata ***output)\n{\n    int i, j;\n    krb5_authdata **ptr, **retdata;\n\n    /* count up the entries */\n    i = 0;\n    if (first)\n        for (ptr = first; *ptr; ptr++)\n            i++;\n    if (second)\n        for (ptr = second; *ptr; ptr++)\n            i++;\n\n    retdata = (krb5_authdata **)malloc((i+1)*sizeof(*retdata));\n    if (!retdata)\n        return ENOMEM;\n    retdata[i] = 0;                     /* null-terminated array */\n    for (i = 0, j = 0, ptr = first; j < 2 ; ptr = second, j++)\n        while (ptr && *ptr) {\n            /* now walk & copy */\n            retdata[i] = (krb5_authdata *)malloc(sizeof(*retdata[i]));\n            if (!retdata[i]) {\n                krb5_free_authdata(context, retdata);\n                return ENOMEM;\n            }\n            *retdata[i] = **ptr;\n            if (!(retdata[i]->contents =\n                  (krb5_octet *)malloc(retdata[i]->length))) {\n                free(retdata[i]);\n                retdata[i] = 0;\n                krb5_free_authdata(context, retdata);\n                return ENOMEM;\n            }\n            memcpy(retdata[i]->contents, (*ptr)->contents, retdata[i]->length);\n\n            ptr++;\n            i++;\n        }\n    *output = retdata;\n    return 0;\n}\n\nkrb5_boolean\nis_local_principal(kdc_realm_t *kdc_active_realm, krb5_const_principal princ1)\n{\n    return krb5_realm_compare(kdc_context, princ1, tgs_server);\n}\n\n/*\n * Returns TRUE if the kerberos principal is the name of a Kerberos ticket\n * service.\n */\nkrb5_boolean\nkrb5_is_tgs_principal(krb5_const_principal principal)\n{\n    if (krb5_princ_size(kdc_context, principal) != 2)\n        return FALSE;\n    if (data_eq_string(*krb5_princ_component(kdc_context, principal, 0),\n                       KRB5_TGS_NAME))\n        return TRUE;\n    else\n        return FALSE;\n}\n\n/* Returns TRUE if principal is the name of a cross-realm TGS. */\nkrb5_boolean\nis_cross_tgs_principal(krb5_const_principal principal)\n{\n    if (!krb5_is_tgs_principal(principal))\n        return FALSE;\n    if (!data_eq(*krb5_princ_component(kdc_context, principal, 1),\n                 *krb5_princ_realm(kdc_context, principal)))\n        return TRUE;\n    else\n        return FALSE;\n}\n\n/*\n * given authentication data (provides seed for checksum), verify checksum\n * for source data.\n */\nstatic krb5_error_code\ncomp_cksum(krb5_context kcontext, krb5_data *source, krb5_ticket *ticket,\n           krb5_checksum *his_cksum)\n{\n    krb5_error_code       retval;\n    krb5_boolean          valid;\n\n    if (!krb5_c_valid_cksumtype(his_cksum->checksum_type))\n        return KRB5KDC_ERR_SUMTYPE_NOSUPP;\n\n    /* must be collision proof */\n    if (!krb5_c_is_coll_proof_cksum(his_cksum->checksum_type))\n        return KRB5KRB_AP_ERR_INAPP_CKSUM;\n\n    /* verify checksum */\n    if ((retval = krb5_c_verify_checksum(kcontext, ticket->enc_part2->session,\n                                         KRB5_KEYUSAGE_TGS_REQ_AUTH_CKSUM,\n                                         source, his_cksum, &valid)))\n        return(retval);\n\n    if (!valid)\n        return(KRB5KRB_AP_ERR_BAD_INTEGRITY);\n\n    return(0);\n}\n\n/* If a header ticket is decrypted, *ticket_out is filled in even on error. */\nkrb5_error_code\nkdc_process_tgs_req(kdc_realm_t *kdc_active_realm,\n                    krb5_kdc_req *request, const krb5_fulladdr *from,\n                    krb5_data *pkt, krb5_ticket **ticket_out,\n                    krb5_db_entry **krbtgt_ptr,\n                    krb5_keyblock **tgskey,\n                    krb5_keyblock **subkey,\n                    krb5_pa_data **pa_tgs_req)\n{\n    krb5_pa_data        * tmppa;\n    krb5_ap_req         * apreq;\n    krb5_error_code       retval;\n    krb5_authdata **authdata = NULL;\n    krb5_data             scratch1;\n    krb5_data           * scratch = NULL;\n    krb5_boolean          foreign_server = FALSE;\n    krb5_auth_context     auth_context = NULL;\n    krb5_authenticator  * authenticator = NULL;\n    krb5_checksum       * his_cksum = NULL;\n    krb5_db_entry       * krbtgt = NULL;\n    krb5_ticket         * ticket;\n\n    *ticket_out = NULL;\n    *krbtgt_ptr = NULL;\n    *tgskey = NULL;\n\n    tmppa = krb5int_find_pa_data(kdc_context,\n                                 request->padata, KRB5_PADATA_AP_REQ);\n    if (!tmppa)\n        return KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n    scratch1.length = tmppa->length;\n    scratch1.data = (char *)tmppa->contents;\n    if ((retval = decode_krb5_ap_req(&scratch1, &apreq)))\n        return retval;\n    ticket = apreq->ticket;\n\n    if (isflagset(apreq->ap_options, AP_OPTS_USE_SESSION_KEY) ||\n        isflagset(apreq->ap_options, AP_OPTS_MUTUAL_REQUIRED)) {\n        krb5_klog_syslog(LOG_INFO, _(\"TGS_REQ: SESSION KEY or MUTUAL\"));\n        retval = KRB5KDC_ERR_POLICY;\n        goto cleanup;\n    }\n\n    /* If the \"server\" principal in the ticket is not something\n       in the local realm, then we must refuse to service the request\n       if the client claims to be from the local realm.\n\n       If we don't do this, then some other realm's nasty KDC can\n       claim to be authenticating a client from our realm, and we'll\n       give out tickets concurring with it!\n\n       we set a flag here for checking below.\n    */\n    foreign_server = !is_local_principal(kdc_active_realm,\n                                         apreq->ticket->server);\n\n    if ((retval = krb5_auth_con_init(kdc_context, &auth_context)))\n        goto cleanup;\n\n    /* Don't use a replay cache. */\n    if ((retval = krb5_auth_con_setflags(kdc_context, auth_context, 0)))\n        goto cleanup;\n\n    if ((retval = krb5_auth_con_setaddrs(kdc_context, auth_context, NULL,\n                                         from->address)) )\n        goto cleanup_auth_context;\n\n    retval = kdc_rd_ap_req(kdc_active_realm,\n                           apreq, auth_context, &krbtgt, tgskey);\n    if (retval)\n        goto cleanup_auth_context;\n\n    /* \"invalid flag\" tickets can must be used to validate */\n    if (isflagset(ticket->enc_part2->flags, TKT_FLG_INVALID) &&\n        !isflagset(request->kdc_options, KDC_OPT_VALIDATE)) {\n        retval = KRB5KRB_AP_ERR_TKT_INVALID;\n        goto cleanup_auth_context;\n    }\n\n    if ((retval = krb5_auth_con_getrecvsubkey(kdc_context,\n                                              auth_context, subkey)))\n        goto cleanup_auth_context;\n\n    if ((retval = krb5_auth_con_getauthenticator(kdc_context, auth_context,\n                                                 &authenticator)))\n        goto cleanup_auth_context;\n\n    retval = krb5_find_authdata(kdc_context,\n                                ticket->enc_part2->authorization_data,\n                                authenticator->authorization_data,\n                                KRB5_AUTHDATA_FX_ARMOR, &authdata);\n    if (retval != 0)\n        goto cleanup_authenticator;\n    if (authdata&& authdata[0]) {\n        k5_setmsg(kdc_context, KRB5KDC_ERR_POLICY,\n                  \"ticket valid only as FAST armor\");\n        retval = KRB5KDC_ERR_POLICY;\n        krb5_free_authdata(kdc_context, authdata);\n        goto cleanup_authenticator;\n    }\n    krb5_free_authdata(kdc_context, authdata);\n\n\n    /* Check for a checksum */\n    if (!(his_cksum = authenticator->checksum)) {\n        retval = KRB5KRB_AP_ERR_INAPP_CKSUM;\n        goto cleanup_authenticator;\n    }\n\n    /* make sure the client is of proper lineage (see above) */\n    if (foreign_server &&\n        !krb5int_find_pa_data(kdc_context,\n                              request->padata, KRB5_PADATA_FOR_USER)) {\n        if (is_local_principal(kdc_active_realm,\n                               ticket->enc_part2->client)) {\n            /* someone in a foreign realm claiming to be local */\n            krb5_klog_syslog(LOG_INFO, _(\"PROCESS_TGS: failed lineage check\"));\n            retval = KRB5KDC_ERR_POLICY;\n            goto cleanup_authenticator;\n        }\n    }\n\n    /*\n     * Check application checksum vs. tgs request\n     *\n     * We try checksumming the req-body two different ways: first we\n     * try reaching into the raw asn.1 stream (if available), and\n     * checksum that directly; if that fails, then we try encoding\n     * using our local asn.1 library.\n     */\n    if (pkt && (fetch_asn1_field((unsigned char *) pkt->data,\n                                 1, 4, &scratch1) >= 0)) {\n        if (comp_cksum(kdc_context, &scratch1, ticket, his_cksum)) {\n            if (!(retval = encode_krb5_kdc_req_body(request, &scratch)))\n                retval = comp_cksum(kdc_context, scratch, ticket, his_cksum);\n            krb5_free_data(kdc_context, scratch);\n            if (retval)\n                goto cleanup_authenticator;\n        }\n    }\n\n    *pa_tgs_req = tmppa;\n    *krbtgt_ptr = krbtgt;\n    krbtgt = NULL;\n\ncleanup_authenticator:\n    krb5_free_authenticator(kdc_context, authenticator);\n\ncleanup_auth_context:\n    krb5_auth_con_free(kdc_context, auth_context);\n\ncleanup:\n    if (retval != 0) {\n        krb5_free_keyblock(kdc_context, *tgskey);\n        *tgskey = NULL;\n    }\n    if (apreq->ticket->enc_part2 != NULL) {\n        /* Steal the decrypted ticket pointer, even on error. */\n        *ticket_out = apreq->ticket;\n        apreq->ticket = NULL;\n    }\n    krb5_free_ap_req(kdc_context, apreq);\n    krb5_db_free_principal(kdc_context, krbtgt);\n    return retval;\n}\n\n/*\n * This is a KDC wrapper around krb5_rd_req_decoded_anyflag().\n *\n * We can't depend on KDB-as-keytab for handling the AP-REQ here for\n * optimization reasons: we want to minimize the number of KDB lookups.  We'll\n * need the KDB entry for the TGS principal, and the TGS key used to decrypt\n * the TGT, elsewhere in the TGS code.\n *\n * This function also implements key rollover support for kvno 0 cross-realm\n * TGTs issued by AD.\n */\nstatic\nkrb5_error_code\nkdc_rd_ap_req(kdc_realm_t *kdc_active_realm,\n              krb5_ap_req *apreq, krb5_auth_context auth_context,\n              krb5_db_entry **server, krb5_keyblock **tgskey)\n{\n    krb5_error_code     retval;\n    krb5_enctype        search_enctype = apreq->ticket->enc_part.enctype;\n    krb5_boolean        match_enctype = 1;\n    krb5_kvno           kvno;\n    size_t              tries = 3;\n\n    /*\n     * When we issue tickets we use the first key in the principals' highest\n     * kvno keyset.  For non-cross-realm krbtgt principals we want to only\n     * allow the use of the first key of the principal's keyset that matches\n     * the given kvno.\n     */\n    if (krb5_is_tgs_principal(apreq->ticket->server) &&\n        !is_cross_tgs_principal(apreq->ticket->server)) {\n        search_enctype = -1;\n        match_enctype = 0;\n    }\n\n    retval = kdc_get_server_key(kdc_context, apreq->ticket,\n                                KRB5_KDB_FLAG_ALIAS_OK, match_enctype, server,\n                                NULL, NULL);\n    if (retval)\n        return retval;\n\n    *tgskey = NULL;\n    kvno = apreq->ticket->enc_part.kvno;\n    do {\n        krb5_free_keyblock(kdc_context, *tgskey);\n        retval = find_server_key(kdc_context,\n                                 *server, search_enctype, kvno, tgskey, &kvno);\n        if (retval)\n            continue;\n\n        /* Make the TGS key available to krb5_rd_req_decoded_anyflag() */\n        retval = krb5_auth_con_setuseruserkey(kdc_context, auth_context,\n                                              *tgskey);\n        if (retval)\n            return retval;\n\n        retval = krb5_rd_req_decoded_anyflag(kdc_context, &auth_context, apreq,\n                                             apreq->ticket->server,\n                                             kdc_active_realm->realm_keytab,\n                                             NULL, NULL);\n\n        /* If the ticket was decrypted, don't try any more keys. */\n        if (apreq->ticket->enc_part2 != NULL)\n            break;\n\n    } while (retval && apreq->ticket->enc_part.kvno == 0 && kvno-- > 1 &&\n             --tries > 0);\n\n    return retval;\n}\n\n/*\n * The KDC should take the keytab associated with the realm and pass\n * that to the krb5_rd_req_decoded_anyflag(), but we still need to use\n * the service (TGS, here) key elsewhere.  This approach is faster than\n * the KDB keytab approach too.\n *\n * This is also used by do_tgs_req() for u2u auth.\n */\nkrb5_error_code\nkdc_get_server_key(krb5_context context,\n                   krb5_ticket *ticket, unsigned int flags,\n                   krb5_boolean match_enctype, krb5_db_entry **server_ptr,\n                   krb5_keyblock **key, krb5_kvno *kvno)\n{\n    krb5_error_code       retval;\n    krb5_db_entry       * server = NULL;\n    krb5_enctype          search_enctype = -1;\n    krb5_kvno             search_kvno = -1;\n\n    if (match_enctype)\n        search_enctype = ticket->enc_part.enctype;\n    if (ticket->enc_part.kvno)\n        search_kvno = ticket->enc_part.kvno;\n\n    *server_ptr = NULL;\n\n    retval = krb5_db_get_principal(context, ticket->server, flags,\n                                   &server);\n    if (retval == KRB5_KDB_NOENTRY) {\n        char *sname;\n        if (!krb5_unparse_name(context, ticket->server, &sname)) {\n            limit_string(sname);\n            krb5_klog_syslog(LOG_ERR,\n                             _(\"TGS_REQ: UNKNOWN SERVER: server='%s'\"), sname);\n            free(sname);\n        }\n        return KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n    } else if (retval)\n        return retval;\n    if (server->attributes & KRB5_KDB_DISALLOW_SVR ||\n        server->attributes & KRB5_KDB_DISALLOW_ALL_TIX) {\n        retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        goto errout;\n    }\n\n    if (key) {\n        retval = find_server_key(context, server, search_enctype, search_kvno,\n                                 key, kvno);\n        if (retval)\n            goto errout;\n    }\n    *server_ptr = server;\n    server = NULL;\n    return 0;\n\nerrout:\n    krb5_db_free_principal(context, server);\n    return retval;\n}\n\n/*\n * A utility function to get the right key from a KDB entry.  Used in handling\n * of kvno 0 TGTs, for example.\n */\nstatic\nkrb5_error_code\nfind_server_key(krb5_context context,\n                krb5_db_entry *server, krb5_enctype enctype, krb5_kvno kvno,\n                krb5_keyblock **key_out, krb5_kvno *kvno_out)\n{\n    krb5_error_code       retval;\n    krb5_key_data       * server_key;\n    krb5_keyblock       * key;\n\n    *key_out = NULL;\n    retval = krb5_dbe_find_enctype(context, server, enctype, -1,\n                                   kvno ? (krb5_int32)kvno : -1, &server_key);\n    if (retval)\n        return retval;\n    if (!server_key)\n        return KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n    if ((key = (krb5_keyblock *)malloc(sizeof *key)) == NULL)\n        return ENOMEM;\n    retval = krb5_dbe_decrypt_key_data(context, NULL, server_key,\n                                       key, NULL);\n    if (retval)\n        goto errout;\n    if (enctype != -1) {\n        krb5_boolean similar;\n        retval = krb5_c_enctype_compare(context, enctype, key->enctype,\n                                        &similar);\n        if (retval)\n            goto errout;\n        if (!similar) {\n            retval = KRB5_KDB_NO_PERMITTED_KEY;\n            goto errout;\n        }\n        key->enctype = enctype;\n    }\n    *key_out = key;\n    key = NULL;\n    if (kvno_out)\n        *kvno_out = server_key->key_data_kvno;\nerrout:\n    krb5_free_keyblock(context, key);\n    return retval;\n}\n\n/*\n * If candidate is the local TGT for realm, set *alias_out to candidate and\n * *storage_out to NULL.  Otherwise, load the local TGT into *storage_out and\n * set *alias_out to *storage_out.\n *\n * In the future we might generalize this to a small per-request principal\n * cache.  For now, it saves a load operation in the common case where the AS\n * server or TGS header ticket server is the local TGT.\n */\nkrb5_error_code\nget_local_tgt(krb5_context context, const krb5_data *realm,\n              krb5_db_entry *candidate, krb5_db_entry **alias_out,\n              krb5_db_entry **storage_out)\n{\n    krb5_error_code ret;\n    krb5_principal princ;\n    krb5_db_entry *tgt;\n\n    *alias_out = NULL;\n    *storage_out = NULL;\n\n    ret = krb5_build_principal_ext(context, &princ, realm->length, realm->data,\n                                   KRB5_TGS_NAME_SIZE, KRB5_TGS_NAME,\n                                   realm->length, realm->data, 0);\n    if (ret)\n        return ret;\n\n    if (!krb5_principal_compare(context, candidate->princ, princ)) {\n        ret = krb5_db_get_principal(context, princ, 0, &tgt);\n        if (!ret)\n            *storage_out = *alias_out = tgt;\n    } else {\n        *alias_out = candidate;\n    }\n\n    krb5_free_principal(context, princ);\n    return ret;\n}\n\n/* This probably wants to be updated if you support last_req stuff */\n\nstatic krb5_last_req_entry nolrentry = { KV5M_LAST_REQ_ENTRY, KRB5_LRQ_NONE, 0 };\nstatic krb5_last_req_entry *nolrarray[] = { &nolrentry, 0 };\n\nkrb5_error_code\nfetch_last_req_info(krb5_db_entry *dbentry, krb5_last_req_entry ***lrentry)\n{\n    *lrentry = nolrarray;\n    return 0;\n}\n\n\n/* XXX!  This is a temporary place-holder */\n\nkrb5_error_code\ncheck_hot_list(krb5_ticket *ticket)\n{\n    return 0;\n}\n\n\n/* Convert an API error code to a protocol error code. */\nint\nerrcode_to_protocol(krb5_error_code code)\n{\n    int protcode;\n\n    protcode = code - ERROR_TABLE_BASE_krb5;\n    return (protcode >= 0 && protcode <= 128) ? protcode : KRB_ERR_GENERIC;\n}\n\n/* Return -1 if the AS or TGS request is disallowed due to KDC policy on\n * anonymous tickets. */\nint\ncheck_anon(kdc_realm_t *kdc_active_realm,\n           krb5_principal client, krb5_principal server)\n{\n    /* If restrict_anon is set, reject requests from anonymous to principals\n     * other than the local TGT. */\n    if (kdc_active_realm->realm_restrict_anon &&\n        krb5_principal_compare_any_realm(kdc_context, client,\n                                         krb5_anonymous_principal()) &&\n        !krb5_principal_compare(kdc_context, server, tgs_server))\n        return -1;\n    return 0;\n}\n\n/*\n * Routines that validate a AS request; checks a lot of things.  :-)\n *\n * Returns a Kerberos protocol error number, which is _not_ the same\n * as a com_err error number!\n */\n#define AS_INVALID_OPTIONS (KDC_OPT_FORWARDED | KDC_OPT_PROXY |         \\\n                            KDC_OPT_VALIDATE | KDC_OPT_RENEW |          \\\n                            KDC_OPT_ENC_TKT_IN_SKEY | KDC_OPT_CNAME_IN_ADDL_TKT)\nint\nvalidate_as_request(kdc_realm_t *kdc_active_realm,\n                    krb5_kdc_req *request, krb5_db_entry client,\n                    krb5_db_entry server, krb5_timestamp kdc_time,\n                    const char **status, krb5_pa_data ***e_data)\n{\n    krb5_error_code ret;\n\n    /*\n     * If an option is set that is only allowed in TGS requests, complain.\n     */\n    if (request->kdc_options & AS_INVALID_OPTIONS) {\n        *status = \"INVALID AS OPTIONS\";\n        return KDC_ERR_BADOPTION;\n    }\n\n    /* The client must not be expired */\n    if (client.expiration && ts_after(kdc_time, client.expiration)) {\n        *status = \"CLIENT EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_NAME_EXP);\n    }\n\n    /* The client's password must not be expired, unless the server is\n       a KRB5_KDC_PWCHANGE_SERVICE. */\n    if (client.pw_expiration && ts_after(kdc_time, client.pw_expiration) &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"CLIENT KEY EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_KEY_EXP);\n    }\n\n    /* The server must not be expired */\n    if (server.expiration && ts_after(kdc_time, server.expiration)) {\n        *status = \"SERVICE EXPIRED\";\n        return(KDC_ERR_SERVICE_EXP);\n    }\n\n    /*\n     * If the client requires password changing, then only allow the\n     * pwchange service.\n     */\n    if (isflagset(client.attributes, KRB5_KDB_REQUIRES_PWCHANGE) &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"REQUIRED PWCHANGE\";\n        return(KDC_ERR_KEY_EXP);\n    }\n\n    /* Client and server must allow postdating tickets */\n    if ((isflagset(request->kdc_options, KDC_OPT_ALLOW_POSTDATE) ||\n         isflagset(request->kdc_options, KDC_OPT_POSTDATED)) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_POSTDATED) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_POSTDATED))) {\n        *status = \"POSTDATE NOT ALLOWED\";\n        return(KDC_ERR_CANNOT_POSTDATE);\n    }\n\n    /* Check to see if client is locked out */\n    if (isflagset(client.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"CLIENT LOCKED OUT\";\n        return(KDC_ERR_CLIENT_REVOKED);\n    }\n\n    /* Check to see if server is locked out */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"SERVICE LOCKED OUT\";\n        return(KDC_ERR_S_PRINCIPAL_UNKNOWN);\n    }\n\n    /* Check to see if server is allowed to be a service */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_SVR)) {\n        *status = \"SERVICE NOT ALLOWED\";\n        return(KDC_ERR_MUST_USE_USER2USER);\n    }\n\n    if (check_anon(kdc_active_realm, client.princ, request->server) != 0) {\n        *status = \"ANONYMOUS NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Perform KDB module policy checks. */\n    ret = krb5_db_check_policy_as(kdc_context, request, &client, &server,\n                                  kdc_time, status, e_data);\n    if (ret && ret != KRB5_PLUGIN_OP_NOTSUPP)\n        return errcode_to_protocol(ret);\n\n    return 0;\n}\n\n/*\n * Compute ticket flags based on the request, the client and server DB entry\n * (which may prohibit forwardable or proxiable tickets), and the header\n * ticket.  client may be NULL for a TGS request (although it may be set, such\n * as for an S4U2Self request).  header_enc may be NULL for an AS request.\n */\nkrb5_flags\nget_ticket_flags(krb5_flags reqflags, krb5_db_entry *client,\n                 krb5_db_entry *server, krb5_enc_tkt_part *header_enc)\n{\n    krb5_flags flags;\n\n    /* Indicate support for encrypted padata (RFC 6806), and set flags based on\n     * request options and the header ticket. */\n    flags = OPTS2FLAGS(reqflags) | TKT_FLG_ENC_PA_REP;\n    if (reqflags & KDC_OPT_POSTDATED)\n        flags |= TKT_FLG_INVALID;\n    if (header_enc != NULL)\n        flags |= COPY_TKT_FLAGS(header_enc->flags);\n    if (header_enc == NULL)\n        flags |= TKT_FLG_INITIAL;\n\n    /* For TGS requests, indicate if the service is marked ok-as-delegate. */\n    if (header_enc != NULL && (server->attributes & KRB5_KDB_OK_AS_DELEGATE))\n        flags |= TKT_FLG_OK_AS_DELEGATE;\n\n    /* Unset PROXIABLE if it is disallowed. */\n    if (client != NULL && (client->attributes & KRB5_KDB_DISALLOW_PROXIABLE))\n        flags &= ~TKT_FLG_PROXIABLE;\n    if (server->attributes & KRB5_KDB_DISALLOW_PROXIABLE)\n        flags &= ~TKT_FLG_PROXIABLE;\n    if (header_enc != NULL && !(header_enc->flags & TKT_FLG_PROXIABLE))\n        flags &= ~TKT_FLG_PROXIABLE;\n\n    /* Unset FORWARDABLE if it is disallowed. */\n    if (client != NULL && (client->attributes & KRB5_KDB_DISALLOW_FORWARDABLE))\n        flags &= ~TKT_FLG_FORWARDABLE;\n    if (server->attributes & KRB5_KDB_DISALLOW_FORWARDABLE)\n        flags &= ~TKT_FLG_FORWARDABLE;\n    if (header_enc != NULL && !(header_enc->flags & TKT_FLG_FORWARDABLE))\n        flags &= ~TKT_FLG_FORWARDABLE;\n\n    /* We don't currently handle issuing anonymous tickets based on\n     * non-anonymous ones. */\n    if (header_enc != NULL && !(header_enc->flags & TKT_FLG_ANONYMOUS))\n        flags &= ~TKT_FLG_ANONYMOUS;\n\n    return flags;\n}\n\n/* Return KRB5KDC_ERR_POLICY if indicators does not contain the required auth\n * indicators for server, ENOMEM on allocation error, 0 otherwise. */\nkrb5_error_code\ncheck_indicators(krb5_context context, krb5_db_entry *server,\n                 krb5_data *const *indicators)\n{\n    krb5_error_code ret;\n    char *str = NULL, *copy = NULL, *save, *ind;\n\n    ret = krb5_dbe_get_string(context, server, KRB5_KDB_SK_REQUIRE_AUTH, &str);\n    if (ret || str == NULL)\n        goto cleanup;\n    copy = strdup(str);\n    if (copy == NULL) {\n        ret = ENOMEM;\n        goto cleanup;\n    }\n\n    /* Look for any of the space-separated strings in indicators. */\n    ind = strtok_r(copy, \" \", &save);\n    while (ind != NULL) {\n        if (authind_contains(indicators, ind))\n            goto cleanup;\n        ind = strtok_r(NULL, \" \", &save);\n    }\n\n    ret = KRB5KDC_ERR_POLICY;\n    k5_setmsg(context, ret,\n              _(\"Required auth indicators not present in ticket: %s\"), str);\n\ncleanup:\n    krb5_dbe_free_string(context, str);\n    free(copy);\n    return ret;\n}\n\n#define ASN1_ID_CLASS   (0xc0)\n#define ASN1_ID_TYPE    (0x20)\n#define ASN1_ID_TAG     (0x1f)\n#define ASN1_CLASS_UNIV (0)\n#define ASN1_CLASS_APP  (1)\n#define ASN1_CLASS_CTX  (2)\n#define ASN1_CLASS_PRIV (3)\n#define asn1_id_constructed(x)  (x & ASN1_ID_TYPE)\n#define asn1_id_primitive(x)    (!asn1_id_constructed(x))\n#define asn1_id_class(x)        ((x & ASN1_ID_CLASS) >> 6)\n#define asn1_id_tag(x)          (x & ASN1_ID_TAG)\n\n/*\n * asn1length - return encoded length of value.\n *\n * passed a pointer into the asn.1 stream, which is updated\n * to point right after the length bits.\n *\n * returns -1 on failure.\n */\nstatic int\nasn1length(unsigned char **astream)\n{\n    int length;         /* resulting length */\n    int sublen;         /* sublengths */\n    int blen;           /* bytes of length */\n    unsigned char *p;   /* substring searching */\n\n    if (**astream & 0x80) {\n        blen = **astream & 0x7f;\n        if (blen > 3) {\n            return(-1);\n        }\n        for (++*astream, length = 0; blen; ++*astream, blen--) {\n            length = (length << 8) | **astream;\n        }\n        if (length == 0) {\n            /* indefinite length, figure out by hand */\n            p = *astream;\n            p++;\n            while (1) {\n                /* compute value length. */\n                if ((sublen = asn1length(&p)) < 0) {\n                    return(-1);\n                }\n                p += sublen;\n                /* check for termination */\n                if ((!*p++) && (!*p)) {\n                    p++;\n                    break;\n                }\n            }\n            length = p - *astream;\n        }\n    } else {\n        length = **astream;\n        ++*astream;\n    }\n    return(length);\n}\n\n/*\n * fetch_asn1_field - return raw asn.1 stream of subfield.\n *\n * this routine is passed a context-dependent tag number and \"level\" and returns\n * the size and length of the corresponding level subfield.\n *\n * levels and are numbered starting from 1.\n *\n * returns 0 on success, -1 otherwise.\n */\nint\nfetch_asn1_field(unsigned char *astream, unsigned int level,\n                 unsigned int field, krb5_data *data)\n{\n    unsigned char *estream;     /* end of stream */\n    int classes;                /* # classes seen so far this level */\n    unsigned int levels = 0;            /* levels seen so far */\n    int lastlevel = 1000;       /* last level seen */\n    int length;                 /* various lengths */\n    int tag;                    /* tag number */\n    unsigned char savelen;      /* saved length of our field */\n\n    classes = -1;\n    /* we assume that the first identifier/length will tell us\n       how long the entire stream is. */\n    astream++;\n    estream = astream;\n    if ((length = asn1length(&astream)) < 0) {\n        return(-1);\n    }\n    estream += length;\n    /* search down the stream, checking identifiers.  we process identifiers\n       until we hit the \"level\" we want, and then process that level for our\n       subfield, always making sure we don't go off the end of the stream.  */\n    while (astream < estream) {\n        if (!asn1_id_constructed(*astream)) {\n            return(-1);\n        }\n        if (asn1_id_class(*astream) == ASN1_CLASS_CTX) {\n            if ((tag = (int)asn1_id_tag(*astream)) <= lastlevel) {\n                levels++;\n                classes = -1;\n            }\n            lastlevel = tag;\n            if (levels == level) {\n                /* in our context-dependent class, is this the one we're looking for ? */\n                if (tag == (int)field) {\n                    /* return length and data */\n                    astream++;\n                    savelen = *astream;\n                    if ((length = asn1length(&astream)) < 0) {\n                        return(-1);\n                    }\n                    data->length = length;\n                    /* if the field length is indefinite, we will have to subtract two\n                       (terminating octets) from the length returned since we don't want\n                       to pass any info from the \"wrapper\" back.  asn1length will always return\n                       the *total* length of the field, not just what's contained in it */\n                    if ((savelen & 0xff) == 0x80) {\n                        data->length -=2 ;\n                    }\n                    data->data = (char *)astream;\n                    return(0);\n                } else if (tag <= classes) {\n                    /* we've seen this class before, something must be wrong */\n                    return(-1);\n                } else {\n                    classes = tag;\n                }\n            }\n        }\n        /* if we're not on our level yet, process this value.  otherwise skip over it */\n        astream++;\n        if ((length = asn1length(&astream)) < 0) {\n            return(-1);\n        }\n        if (levels == level) {\n            astream += length;\n        }\n    }\n    return(-1);\n}\n\n/* Return true if we believe server can support enctype as a session key. */\nstatic krb5_boolean\ndbentry_supports_enctype(kdc_realm_t *kdc_active_realm, krb5_db_entry *server,\n                         krb5_enctype enctype)\n{\n    krb5_error_code     retval;\n    krb5_key_data       *datap;\n    char                *etypes_str = NULL;\n    krb5_enctype        default_enctypes[1] = { 0 };\n    krb5_enctype        *etypes = NULL;\n    krb5_boolean        in_list;\n\n    /* Look up the supported session key enctypes list in the KDB. */\n    retval = krb5_dbe_get_string(kdc_context, server,\n                                 KRB5_KDB_SK_SESSION_ENCTYPES,\n                                 &etypes_str);\n    if (retval == 0 && etypes_str != NULL && *etypes_str != '\\0') {\n        /* Pass a fake profile key for tracing of unrecognized tokens. */\n        retval = krb5int_parse_enctype_list(kdc_context, \"KDB-session_etypes\",\n                                            etypes_str, default_enctypes,\n                                            &etypes);\n        if (retval == 0 && etypes != NULL && etypes[0]) {\n            in_list = k5_etypes_contains(etypes, enctype);\n            free(etypes_str);\n            free(etypes);\n            return in_list;\n        }\n        /* Fall through on error or empty list */\n    }\n    free(etypes_str);\n    free(etypes);\n\n    /* If configured to, assume every server without a session_enctypes\n     * attribute supports DES_CBC_CRC. */\n    if (kdc_active_realm->realm_assume_des_crc_sess &&\n        enctype == ENCTYPE_DES_CBC_CRC)\n        return TRUE;\n\n    /* Due to an ancient interop problem, assume nothing supports des-cbc-md5\n     * unless there's a session_enctypes explicitly saying that it does. */\n    if (enctype == ENCTYPE_DES_CBC_MD5)\n        return FALSE;\n\n    /* Assume the server supports any enctype it has a long-term key for. */\n    return !krb5_dbe_find_enctype(kdc_context, server, enctype, -1, 0, &datap);\n}\n\n/*\n * This function returns the keytype which should be selected for the\n * session key.  It is based on the ordered list which the user\n * requested, and what the KDC and the application server can support.\n */\nkrb5_enctype\nselect_session_keytype(kdc_realm_t *kdc_active_realm, krb5_db_entry *server,\n                       int nktypes, krb5_enctype *ktype)\n{\n    int         i;\n\n    for (i = 0; i < nktypes; i++) {\n        if (!krb5_c_valid_enctype(ktype[i]))\n            continue;\n\n        if (!krb5_is_permitted_enctype(kdc_context, ktype[i]))\n            continue;\n\n        if (dbentry_supports_enctype(kdc_active_realm, server, ktype[i]))\n            return ktype[i];\n    }\n\n    return 0;\n}\n\n/*\n * Limit strings to a \"reasonable\" length to prevent crowding out of\n * other useful information in the log entry\n */\n#define NAME_LENGTH_LIMIT 128\n\nvoid limit_string(char *name)\n{\n    int     i;\n\n    if (!name)\n        return;\n\n    if (strlen(name) < NAME_LENGTH_LIMIT)\n        return;\n\n    i = NAME_LENGTH_LIMIT-4;\n    name[i++] = '.';\n    name[i++] = '.';\n    name[i++] = '.';\n    name[i] = '\\0';\n    return;\n}\n\n/*\n * L10_2 = log10(2**x), rounded up; log10(2) ~= 0.301.\n */\n#define L10_2(x) ((int)(((x * 301) + 999) / 1000))\n\n/*\n * Max length of sprintf(\"%ld\") for an int of type T; includes leading\n * minus sign and terminating NUL.\n */\n#define D_LEN(t) (L10_2(sizeof(t) * CHAR_BIT) + 2)\n\nvoid\nktypes2str(char *s, size_t len, int nktypes, krb5_enctype *ktype)\n{\n    int i;\n    char stmp[D_LEN(krb5_enctype) + 1];\n    char *p;\n\n    if (nktypes < 0\n        || len < (sizeof(\" etypes {...}\") + D_LEN(int))) {\n        *s = '\\0';\n        return;\n    }\n\n    snprintf(s, len, \"%d etypes {\", nktypes);\n    for (i = 0; i < nktypes; i++) {\n        snprintf(stmp, sizeof(stmp), \"%s%ld\", i ? \" \" : \"\", (long)ktype[i]);\n        if (strlen(s) + strlen(stmp) + sizeof(\"}\") > len)\n            break;\n        strlcat(s, stmp, len);\n    }\n    if (i < nktypes) {\n        /*\n         * We broke out of the loop. Try to truncate the list.\n         */\n        p = s + strlen(s);\n        while (p - s + sizeof(\"...}\") > len) {\n            while (p > s && *p != ' ' && *p != '{')\n                *p-- = '\\0';\n            if (p > s && *p == ' ') {\n                *p-- = '\\0';\n                continue;\n            }\n        }\n        strlcat(s, \"...\", len);\n    }\n    strlcat(s, \"}\", len);\n    return;\n}\n\nvoid\nrep_etypes2str(char *s, size_t len, krb5_kdc_rep *rep)\n{\n    char stmp[sizeof(\"ses=\") + D_LEN(krb5_enctype)];\n\n    if (len < (3 * D_LEN(krb5_enctype)\n               + sizeof(\"etypes {rep= tkt= ses=}\"))) {\n        *s = '\\0';\n        return;\n    }\n\n    snprintf(s, len, \"etypes {rep=%ld\", (long)rep->enc_part.enctype);\n\n    if (rep->ticket != NULL) {\n        snprintf(stmp, sizeof(stmp),\n                 \" tkt=%ld\", (long)rep->ticket->enc_part.enctype);\n        strlcat(s, stmp, len);\n    }\n\n    if (rep->ticket != NULL\n        && rep->ticket->enc_part2 != NULL\n        && rep->ticket->enc_part2->session != NULL) {\n        snprintf(stmp, sizeof(stmp), \" ses=%ld\",\n                 (long)rep->ticket->enc_part2->session->enctype);\n        strlcat(s, stmp, len);\n    }\n    strlcat(s, \"}\", len);\n    return;\n}\n\nstatic krb5_error_code\nverify_for_user_checksum(krb5_context context,\n                         krb5_keyblock *key,\n                         krb5_pa_for_user *req)\n{\n    krb5_error_code             code;\n    int                         i;\n    krb5_int32                  name_type;\n    char                        *p;\n    krb5_data                   data;\n    krb5_boolean                valid = FALSE;\n\n    if (!krb5_c_is_keyed_cksum(req->cksum.checksum_type)) {\n        return KRB5KRB_AP_ERR_INAPP_CKSUM;\n    }\n\n    /*\n     * Checksum is over name type and string components of\n     * client principal name and auth_package.\n     */\n    data.length = 4;\n    for (i = 0; i < krb5_princ_size(context, req->user); i++) {\n        data.length += krb5_princ_component(context, req->user, i)->length;\n    }\n    data.length += krb5_princ_realm(context, req->user)->length;\n    data.length += req->auth_package.length;\n\n    p = data.data = malloc(data.length);\n    if (data.data == NULL) {\n        return ENOMEM;\n    }\n\n    name_type = krb5_princ_type(context, req->user);\n    p[0] = (name_type >> 0 ) & 0xFF;\n    p[1] = (name_type >> 8 ) & 0xFF;\n    p[2] = (name_type >> 16) & 0xFF;\n    p[3] = (name_type >> 24) & 0xFF;\n    p += 4;\n\n    for (i = 0; i < krb5_princ_size(context, req->user); i++) {\n        if (krb5_princ_component(context, req->user, i)->length > 0) {\n            memcpy(p, krb5_princ_component(context, req->user, i)->data,\n                   krb5_princ_component(context, req->user, i)->length);\n        }\n        p += krb5_princ_component(context, req->user, i)->length;\n    }\n\n    if (krb5_princ_realm(context, req->user)->length > 0) {\n        memcpy(p, krb5_princ_realm(context, req->user)->data,\n               krb5_princ_realm(context, req->user)->length);\n    }\n    p += krb5_princ_realm(context, req->user)->length;\n\n    if (req->auth_package.length > 0)\n        memcpy(p, req->auth_package.data, req->auth_package.length);\n    p += req->auth_package.length;\n\n    code = krb5_c_verify_checksum(context,\n                                  key,\n                                  KRB5_KEYUSAGE_APP_DATA_CKSUM,\n                                  &data,\n                                  &req->cksum,\n                                  &valid);\n\n    if (code == 0 && valid == FALSE)\n        code = KRB5KRB_AP_ERR_MODIFIED;\n\n    free(data.data);\n\n    return code;\n}\n\n/*\n * Legacy protocol transition (Windows 2003 and above)\n */\nstatic krb5_error_code\nkdc_process_for_user(kdc_realm_t *kdc_active_realm,\n                     krb5_pa_data *pa_data,\n                     krb5_keyblock *tgs_session,\n                     krb5_pa_s4u_x509_user **s4u_x509_user,\n                     const char **status)\n{\n    krb5_error_code             code;\n    krb5_pa_for_user            *for_user;\n    krb5_data                   req_data;\n\n    req_data.length = pa_data->length;\n    req_data.data = (char *)pa_data->contents;\n\n    code = decode_krb5_pa_for_user(&req_data, &for_user);\n    if (code) {\n        *status = \"DECODE_PA_FOR_USER\";\n        return code;\n    }\n\n    code = verify_for_user_checksum(kdc_context, tgs_session, for_user);\n    if (code) {\n        *status = \"INVALID_S4U2SELF_CHECKSUM\";\n        krb5_free_pa_for_user(kdc_context, for_user);\n        return code;\n    }\n\n    *s4u_x509_user = calloc(1, sizeof(krb5_pa_s4u_x509_user));\n    if (*s4u_x509_user == NULL) {\n        krb5_free_pa_for_user(kdc_context, for_user);\n        return ENOMEM;\n    }\n\n    (*s4u_x509_user)->user_id.user = for_user->user;\n    for_user->user = NULL;\n    krb5_free_pa_for_user(kdc_context, for_user);\n\n    return 0;\n}\n\nstatic krb5_error_code\nverify_s4u_x509_user_checksum(krb5_context context,\n                              krb5_keyblock *key,\n                              krb5_data *req_data,\n                              krb5_int32 kdc_req_nonce,\n                              krb5_pa_s4u_x509_user *req)\n{\n    krb5_error_code             code;\n    krb5_data                   scratch;\n    krb5_boolean                valid = FALSE;\n\n    if (enctype_requires_etype_info_2(key->enctype) &&\n        !krb5_c_is_keyed_cksum(req->cksum.checksum_type))\n        return KRB5KRB_AP_ERR_INAPP_CKSUM;\n\n    if (req->user_id.nonce != kdc_req_nonce)\n        return KRB5KRB_AP_ERR_MODIFIED;\n\n    /*\n     * Verify checksum over the encoded userid. If that fails,\n     * re-encode, and verify that. This is similar to the\n     * behaviour in kdc_process_tgs_req().\n     */\n    if (fetch_asn1_field((unsigned char *)req_data->data, 1, 0, &scratch) < 0)\n        return ASN1_PARSE_ERROR;\n\n    code = krb5_c_verify_checksum(context,\n                                  key,\n                                  KRB5_KEYUSAGE_PA_S4U_X509_USER_REQUEST,\n                                  &scratch,\n                                  &req->cksum,\n                                  &valid);\n    if (code != 0)\n        return code;\n\n    if (valid == FALSE) {\n        krb5_data *data;\n\n        code = encode_krb5_s4u_userid(&req->user_id, &data);\n        if (code != 0)\n            return code;\n\n        code = krb5_c_verify_checksum(context,\n                                      key,\n                                      KRB5_KEYUSAGE_PA_S4U_X509_USER_REQUEST,\n                                      data,\n                                      &req->cksum,\n                                      &valid);\n\n        krb5_free_data(context, data);\n\n        if (code != 0)\n            return code;\n    }\n\n    return valid ? 0 : KRB5KRB_AP_ERR_MODIFIED;\n}\n\n/*\n * New protocol transition request (Windows 2008 and above)\n */\nstatic krb5_error_code\nkdc_process_s4u_x509_user(krb5_context context,\n                          krb5_kdc_req *request,\n                          krb5_pa_data *pa_data,\n                          krb5_keyblock *tgs_subkey,\n                          krb5_keyblock *tgs_session,\n                          krb5_pa_s4u_x509_user **s4u_x509_user,\n                          const char **status)\n{\n    krb5_error_code             code;\n    krb5_data                   req_data;\n\n    req_data.length = pa_data->length;\n    req_data.data = (char *)pa_data->contents;\n\n    code = decode_krb5_pa_s4u_x509_user(&req_data, s4u_x509_user);\n    if (code) {\n        *status = \"DECODE_PA_S4U_X509_USER\";\n        return code;\n    }\n\n    code = verify_s4u_x509_user_checksum(context,\n                                         tgs_subkey ? tgs_subkey :\n                                         tgs_session,\n                                         &req_data,\n                                         request->nonce, *s4u_x509_user);\n\n    if (code) {\n        *status = \"INVALID_S4U2SELF_CHECKSUM\";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return code;\n    }\n\n    if (krb5_princ_size(context, (*s4u_x509_user)->user_id.user) == 0 ||\n        (*s4u_x509_user)->user_id.subject_cert.length != 0) {\n        *status = \"INVALID_S4U2SELF_REQUEST\";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n    }\n\n    return 0;\n}\n\nkrb5_error_code\nkdc_make_s4u2self_rep(krb5_context context,\n                      krb5_keyblock *tgs_subkey,\n                      krb5_keyblock *tgs_session,\n                      krb5_pa_s4u_x509_user *req_s4u_user,\n                      krb5_kdc_rep *reply,\n                      krb5_enc_kdc_rep_part *reply_encpart)\n{\n    krb5_error_code             code;\n    krb5_data                   *der_user_id = NULL, *der_s4u_x509_user = NULL;\n    krb5_pa_s4u_x509_user       rep_s4u_user;\n    krb5_pa_data                *pa;\n    krb5_enctype                enctype;\n    krb5_keyusage               usage;\n\n    memset(&rep_s4u_user, 0, sizeof(rep_s4u_user));\n\n    rep_s4u_user.user_id.nonce   = req_s4u_user->user_id.nonce;\n    rep_s4u_user.user_id.user    = req_s4u_user->user_id.user;\n    rep_s4u_user.user_id.options =\n        req_s4u_user->user_id.options & KRB5_S4U_OPTS_USE_REPLY_KEY_USAGE;\n\n    code = encode_krb5_s4u_userid(&rep_s4u_user.user_id, &der_user_id);\n    if (code != 0)\n        goto cleanup;\n\n    if (req_s4u_user->user_id.options & KRB5_S4U_OPTS_USE_REPLY_KEY_USAGE)\n        usage = KRB5_KEYUSAGE_PA_S4U_X509_USER_REPLY;\n    else\n        usage = KRB5_KEYUSAGE_PA_S4U_X509_USER_REQUEST;\n\n    code = krb5_c_make_checksum(context, req_s4u_user->cksum.checksum_type,\n                                tgs_subkey != NULL ? tgs_subkey : tgs_session,\n                                usage, der_user_id, &rep_s4u_user.cksum);\n    if (code != 0)\n        goto cleanup;\n\n    code = encode_krb5_pa_s4u_x509_user(&rep_s4u_user, &der_s4u_x509_user);\n    if (code != 0)\n        goto cleanup;\n\n    /* Add a padata element, stealing memory from der_s4u_x509_user. */\n    code = alloc_pa_data(KRB5_PADATA_S4U_X509_USER, 0, &pa);\n    if (code != 0)\n        goto cleanup;\n    pa->length = der_s4u_x509_user->length;\n    pa->contents = (uint8_t *)der_s4u_x509_user->data;\n    der_s4u_x509_user->data = NULL;\n    /* add_pa_data_element() claims pa on success or failure. */\n    code = add_pa_data_element(&reply->padata, pa);\n    if (code != 0)\n        goto cleanup;\n\n    if (tgs_subkey != NULL)\n        enctype = tgs_subkey->enctype;\n    else\n        enctype = tgs_session->enctype;\n\n    /*\n     * Owing to a bug in Windows, unkeyed checksums were used for older\n     * enctypes, including rc4-hmac. A forthcoming workaround for this\n     * includes the checksum bytes in the encrypted padata.\n     */\n    if ((req_s4u_user->user_id.options & KRB5_S4U_OPTS_USE_REPLY_KEY_USAGE) &&\n        enctype_requires_etype_info_2(enctype) == FALSE) {\n        code = alloc_pa_data(KRB5_PADATA_S4U_X509_USER,\n                             req_s4u_user->cksum.length +\n                             rep_s4u_user.cksum.length, &pa);\n        if (code != 0)\n            goto cleanup;\n        memcpy(pa->contents,\n               req_s4u_user->cksum.contents, req_s4u_user->cksum.length);\n        memcpy(&pa->contents[req_s4u_user->cksum.length],\n               rep_s4u_user.cksum.contents, rep_s4u_user.cksum.length);\n\n        /* add_pa_data_element() claims pa on success or failure. */\n        code = add_pa_data_element(&reply_encpart->enc_padata, pa);\n        if (code != 0)\n            goto cleanup;\n    }\n\ncleanup:\n    if (rep_s4u_user.cksum.contents != NULL)\n        krb5_free_checksum_contents(context, &rep_s4u_user.cksum);\n    krb5_free_data(context, der_user_id);\n    krb5_free_data(context, der_s4u_x509_user);\n\n    return code;\n}\n\n/*\n * Protocol transition (S4U2Self)\n */\nkrb5_error_code\nkdc_process_s4u2self_req(kdc_realm_t *kdc_active_realm,\n                         krb5_kdc_req *request,\n                         krb5_const_principal client_princ,\n                         krb5_const_principal header_srv_princ,\n                         krb5_boolean issuing_referral,\n                         const krb5_db_entry *server,\n                         krb5_keyblock *tgs_subkey,\n                         krb5_keyblock *tgs_session,\n                         krb5_timestamp kdc_time,\n                         krb5_pa_s4u_x509_user **s4u_x509_user,\n                         krb5_db_entry **princ_ptr,\n                         const char **status)\n{\n    krb5_error_code             code;\n    krb5_boolean                is_local_tgt;\n    krb5_pa_data                *pa_data;\n    int                         flags;\n    krb5_db_entry               *princ;\n\n    *princ_ptr = NULL;\n\n    pa_data = krb5int_find_pa_data(kdc_context,\n                                   request->padata, KRB5_PADATA_S4U_X509_USER);\n    if (pa_data != NULL) {\n        code = kdc_process_s4u_x509_user(kdc_context,\n                                         request,\n                                         pa_data,\n                                         tgs_subkey,\n                                         tgs_session,\n                                         s4u_x509_user,\n                                         status);\n        if (code != 0)\n            return code;\n    } else {\n        pa_data = krb5int_find_pa_data(kdc_context,\n                                       request->padata, KRB5_PADATA_FOR_USER);\n        if (pa_data != NULL) {\n            code = kdc_process_for_user(kdc_active_realm,\n                                        pa_data,\n                                        tgs_session,\n                                        s4u_x509_user,\n                                        status);\n            if (code != 0)\n                return code;\n        } else\n            return 0;\n    }\n\n    /*\n     * We need to compare the client name in the TGT with the requested\n     * server name. Supporting server name aliases without assuming a\n     * global name service makes this difficult to do.\n     *\n     * The comparison below handles the following cases (note that the\n     * term \"principal name\" below excludes the realm).\n     *\n     * (1) The requested service is a host-based service with two name\n     *     components, in which case we assume the principal name to\n     *     contain sufficient qualifying information. The realm is\n     *     ignored for the purpose of comparison.\n     *\n     * (2) The requested service name is an enterprise principal name:\n     *     the service principal name is compared with the unparsed\n     *     form of the client name (including its realm).\n     *\n     * (3) The requested service is some other name type: an exact\n     *     match is required.\n     *\n     * An alternative would be to look up the server once again with\n     * FLAG_CANONICALIZE | FLAG_CLIENT_REFERRALS_ONLY set, do an exact\n     * match between the returned name and client_princ. However, this\n     * assumes that the client set FLAG_CANONICALIZE when requesting\n     * the TGT and that we have a global name service.\n     */\n    flags = 0;\n    switch (krb5_princ_type(kdc_context, request->server)) {\n    case KRB5_NT_SRV_HST:                   /* (1) */\n        if (krb5_princ_size(kdc_context, request->server) == 2)\n            flags |= KRB5_PRINCIPAL_COMPARE_IGNORE_REALM;\n        break;\n    case KRB5_NT_ENTERPRISE_PRINCIPAL:      /* (2) */\n        flags |= KRB5_PRINCIPAL_COMPARE_ENTERPRISE;\n        break;\n    default:                                /* (3) */\n        break;\n    }\n\n    if (!krb5_principal_compare_flags(kdc_context,\n                                      request->server,\n                                      client_princ,\n                                      flags)) {\n        *status = \"INVALID_S4U2SELF_REQUEST\";\n        return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN; /* match Windows error code */\n    }\n\n    /*\n     * Protocol transition is mutually exclusive with renew/forward/etc\n     * as well as user-to-user and constrained delegation. This check\n     * is also made in validate_as_request().\n     *\n     * We can assert from this check that the header ticket was a TGT, as\n     * that is validated previously in validate_tgs_request().\n     */\n    if (request->kdc_options & AS_INVALID_OPTIONS) {\n        *status = \"INVALID AS OPTIONS\";\n        return KRB5KDC_ERR_BADOPTION;\n    }\n\n    /*\n     * Valid S4U2Self requests can occur in the following combinations:\n     *\n     * (1) local TGT, local user, local server\n     * (2) cross TGT, local user, issuing referral\n     * (3) cross TGT, non-local user, issuing referral\n     * (4) cross TGT, non-local user, local server\n     *\n     * The first case is for a single-realm S4U2Self scenario; the second,\n     * third, and fourth cases are for the initial, intermediate (if any), and\n     * final cross-realm requests in a multi-realm scenario.\n     */\n\n    is_local_tgt = !is_cross_tgs_principal(header_srv_princ);\n    if (is_local_tgt && issuing_referral) {\n        /* The requesting server appears to no longer exist, and we found\n         * a referral instead.  Treat this as a server lookup failure. */\n        *status = \"LOOKING_UP_SERVER\";\n        return KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n    }\n\n    /*\n     * Do not attempt to lookup principals in foreign realms.\n     */\n    if (is_local_principal(kdc_active_realm,\n                           (*s4u_x509_user)->user_id.user)) {\n        krb5_db_entry no_server;\n        krb5_pa_data **e_data = NULL;\n\n        if (!is_local_tgt && !issuing_referral) {\n            /* A local server should not need a cross-realm TGT to impersonate\n             * a local principal. */\n            *status = \"NOT_CROSS_REALM_REQUEST\";\n            return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN; /* match Windows error */\n        }\n\n        code = krb5_db_get_principal(kdc_context,\n                                     (*s4u_x509_user)->user_id.user,\n                                     KRB5_KDB_FLAG_INCLUDE_PAC, &princ);\n        if (code == KRB5_KDB_NOENTRY) {\n            *status = \"UNKNOWN_S4U2SELF_PRINCIPAL\";\n            return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n        } else if (code) {\n            *status = \"LOOKING_UP_S4U2SELF_PRINCIPAL\";\n            return code; /* caller can free for_user */\n        }\n\n        memset(&no_server, 0, sizeof(no_server));\n\n        code = validate_as_request(kdc_active_realm, request, *princ,\n                                   no_server, kdc_time, status, &e_data);\n        if (code) {\n            krb5_db_free_principal(kdc_context, princ);\n            krb5_free_pa_data(kdc_context, e_data);\n            return code;\n        }\n\n        *princ_ptr = princ;\n    } else if (is_local_tgt) {\n        /*\n         * The server is asking to impersonate a principal from another realm,\n         * using a local TGT.  It should instead ask that principal's realm and\n         * follow referrals back to us.\n         */\n        *status = \"S4U2SELF_CLIENT_NOT_OURS\";\n        return KRB5KDC_ERR_POLICY; /* match Windows error */\n    }\n\n    return 0;\n}\n\nstatic krb5_error_code\ncheck_allowed_to_delegate_to(krb5_context context, krb5_const_principal client,\n                             const krb5_db_entry *server,\n                             krb5_const_principal proxy)\n{\n    /* Can't get a TGT (otherwise it would be unconstrained delegation) */\n    if (krb5_is_tgs_principal(proxy))\n        return KRB5KDC_ERR_POLICY;\n\n    /* Must be in same realm */\n    if (!krb5_realm_compare(context, server->princ, proxy))\n        return KRB5KDC_ERR_POLICY;\n\n    return krb5_db_check_allowed_to_delegate(context, client, server, proxy);\n}\n\nkrb5_error_code\nkdc_process_s4u2proxy_req(kdc_realm_t *kdc_active_realm,\n                          krb5_kdc_req *request,\n                          const krb5_enc_tkt_part *t2enc,\n                          const krb5_db_entry *server,\n                          krb5_const_principal server_princ,\n                          krb5_const_principal proxy_princ,\n                          const char **status)\n{\n    krb5_error_code errcode;\n\n    /*\n     * Constrained delegation is mutually exclusive with renew/forward/etc.\n     * We can assert from this check that the header ticket was a TGT, as\n     * that is validated previously in validate_tgs_request().\n     */\n    if (request->kdc_options & (NON_TGT_OPTION | KDC_OPT_ENC_TKT_IN_SKEY)) {\n        *status = \"INVALID_S4U2PROXY_OPTIONS\";\n        return KRB5KDC_ERR_BADOPTION;\n    }\n\n    /* Ensure that evidence ticket server matches TGT client */\n    if (!krb5_principal_compare(kdc_context,\n                                server->princ, /* after canon */\n                                server_princ)) {\n        *status = \"EVIDENCE_TICKET_MISMATCH\";\n        return KRB5KDC_ERR_SERVER_NOMATCH;\n    }\n\n    if (!isflagset(t2enc->flags, TKT_FLG_FORWARDABLE)) {\n        *status = \"EVIDENCE_TKT_NOT_FORWARDABLE\";\n        return KRB5_TKT_NOT_FORWARDABLE;\n    }\n\n    /* Backend policy check */\n    errcode = check_allowed_to_delegate_to(kdc_context,\n                                           t2enc->client,\n                                           server,\n                                           proxy_princ);\n    if (errcode) {\n        *status = \"NOT_ALLOWED_TO_DELEGATE\";\n        return errcode;\n    }\n\n    return 0;\n}\n\nkrb5_error_code\nkdc_check_transited_list(kdc_realm_t *kdc_active_realm,\n                         const krb5_data *trans,\n                         const krb5_data *realm1,\n                         const krb5_data *realm2)\n{\n    krb5_error_code             code;\n\n    /* Check against the KDB module.  Treat this answer as authoritative if the\n     * method is supported and doesn't explicitly pass control. */\n    code = krb5_db_check_transited_realms(kdc_context, trans, realm1, realm2);\n    if (code != KRB5_PLUGIN_OP_NOTSUPP && code != KRB5_PLUGIN_NO_HANDLE)\n        return code;\n\n    /* Check using krb5.conf [capaths] or hierarchical relationships. */\n    return krb5_check_transited_list(kdc_context, trans, realm1, realm2);\n}\n\nkrb5_error_code\nvalidate_transit_path(krb5_context context,\n                      krb5_const_principal client,\n                      krb5_db_entry *server,\n                      krb5_db_entry *header_srv)\n{\n    /* Incoming */\n    if (isflagset(server->attributes, KRB5_KDB_XREALM_NON_TRANSITIVE)) {\n        return KRB5KDC_ERR_PATH_NOT_ACCEPTED;\n    }\n\n    /* Outgoing */\n    if (isflagset(header_srv->attributes, KRB5_KDB_XREALM_NON_TRANSITIVE) &&\n        (!krb5_principal_compare(context, server->princ, header_srv->princ) ||\n         !krb5_realm_compare(context, client, header_srv->princ))) {\n        return KRB5KDC_ERR_PATH_NOT_ACCEPTED;\n    }\n\n    return 0;\n}\n\nkrb5_boolean\nenctype_requires_etype_info_2(krb5_enctype enctype)\n{\n    switch(enctype) {\n    case ENCTYPE_DES_CBC_CRC:\n    case ENCTYPE_DES_CBC_MD4:\n    case ENCTYPE_DES_CBC_MD5:\n    case ENCTYPE_DES3_CBC_SHA1:\n    case ENCTYPE_DES3_CBC_RAW:\n    case ENCTYPE_ARCFOUR_HMAC:\n    case ENCTYPE_ARCFOUR_HMAC_EXP :\n        return 0;\n    default:\n        return krb5_c_valid_enctype(enctype);\n    }\n}\n\n/* Allocate a pa-data entry with an uninitialized buffer of size len. */\nkrb5_error_code\nalloc_pa_data(krb5_preauthtype pa_type, size_t len, krb5_pa_data **out)\n{\n    krb5_pa_data *pa;\n    uint8_t *buf = NULL;\n\n    *out = NULL;\n    if (len > 0) {\n        buf = malloc(len);\n        if (buf == NULL)\n            return ENOMEM;\n    }\n    pa = malloc(sizeof(*pa));\n    if (pa == NULL) {\n        free(buf);\n        return ENOMEM;\n    }\n    pa->magic = KV5M_PA_DATA;\n    pa->pa_type = pa_type;\n    pa->length = len;\n    pa->contents = buf;\n    *out = pa;\n    return 0;\n}\n\n/* Add pa to list, claiming its memory.  Free pa on failure. */\nkrb5_error_code\nadd_pa_data_element(krb5_pa_data ***list, krb5_pa_data *pa)\n{\n    size_t count;\n    krb5_pa_data **newlist;\n\n    for (count = 0; *list != NULL && (*list)[count] != NULL; count++);\n\n    newlist = realloc(*list, (count + 2) * sizeof(*newlist));\n    if (newlist == NULL) {\n        free(pa->contents);\n        free(pa);\n        return ENOMEM;\n    }\n    newlist[count] = pa;\n    newlist[count + 1] = NULL;\n    *list = newlist;\n    return 0;\n}\n\nvoid\nkdc_get_ticket_endtime(kdc_realm_t *kdc_active_realm,\n                       krb5_timestamp starttime,\n                       krb5_timestamp endtime,\n                       krb5_timestamp till,\n                       krb5_db_entry *client,\n                       krb5_db_entry *server,\n                       krb5_timestamp *out_endtime)\n{\n    krb5_timestamp until;\n    krb5_deltat life;\n\n    if (till == 0)\n        till = kdc_infinity;\n\n    until = ts_min(till, endtime);\n\n    /* Determine the requested lifetime, capped at the maximum valid time\n     * interval. */\n    life = ts_delta(until, starttime);\n    if (ts_after(until, starttime) && life < 0)\n        life = INT32_MAX;\n\n    if (client != NULL && client->max_life != 0)\n        life = min(life, client->max_life);\n    if (server->max_life != 0)\n        life = min(life, server->max_life);\n    if (kdc_active_realm->realm_maxlife != 0)\n        life = min(life, kdc_active_realm->realm_maxlife);\n\n    *out_endtime = ts_incr(starttime, life);\n}\n\n/*\n * Set tkt->renew_till to the requested renewable lifetime as modified by\n * policy.  Set the TKT_FLG_RENEWABLE flag if we set a nonzero renew_till.\n * client and tgt may be NULL.\n */\nvoid\nkdc_get_ticket_renewtime(kdc_realm_t *realm, krb5_kdc_req *request,\n                         krb5_enc_tkt_part *tgt, krb5_db_entry *client,\n                         krb5_db_entry *server, krb5_enc_tkt_part *tkt)\n{\n    krb5_timestamp rtime, max_rlife;\n\n    clear(tkt->flags, TKT_FLG_RENEWABLE);\n    tkt->times.renew_till = 0;\n\n    /* Don't issue renewable tickets if the client or server don't allow it,\n     * or if this is a TGS request and the TGT isn't renewable. */\n    if (server->attributes & KRB5_KDB_DISALLOW_RENEWABLE)\n        return;\n    if (client != NULL && (client->attributes & KRB5_KDB_DISALLOW_RENEWABLE))\n        return;\n    if (tgt != NULL && !(tgt->flags & TKT_FLG_RENEWABLE))\n        return;\n\n    /* Determine the requested renewable time. */\n    if (isflagset(request->kdc_options, KDC_OPT_RENEWABLE))\n        rtime = request->rtime ? request->rtime : kdc_infinity;\n    else if (isflagset(request->kdc_options, KDC_OPT_RENEWABLE_OK) &&\n             ts_after(request->till, tkt->times.endtime))\n        rtime = request->till;\n    else\n        return;\n\n    /* Truncate it to the allowable renewable time. */\n    if (tgt != NULL)\n        rtime = ts_min(rtime, tgt->times.renew_till);\n    max_rlife = min(server->max_renewable_life, realm->realm_maxrlife);\n    if (client != NULL)\n        max_rlife = min(max_rlife, client->max_renewable_life);\n    rtime = ts_min(rtime, ts_incr(tkt->times.starttime, max_rlife));\n\n    /* If the client only specified renewable-ok, don't issue a renewable\n     * ticket unless the truncated renew time exceeds the ticket end time. */\n    if (!isflagset(request->kdc_options, KDC_OPT_RENEWABLE) &&\n        !ts_after(rtime, tkt->times.endtime))\n        return;\n\n    setflag(tkt->flags, TKT_FLG_RENEWABLE);\n    tkt->times.renew_till = rtime;\n}\n\n/**\n * Handle protected negotiation of FAST using enc_padata\n * - If ENCPADATA_REQ_ENC_PA_REP is present, then:\n * - Return ENCPADATA_REQ_ENC_PA_REP with checksum of AS-REQ from client\n * - Include PADATA_FX_FAST in the enc_padata to indicate FAST\n * @pre @c out_enc_padata has space for at least two more padata\n * @param index in/out index into @c out_enc_padata for next item\n */\nkrb5_error_code\nkdc_handle_protected_negotiation(krb5_context context,\n                                 krb5_data *req_pkt, krb5_kdc_req *request,\n                                 const krb5_keyblock *reply_key,\n                                 krb5_pa_data ***out_enc_padata)\n{\n    krb5_error_code retval = 0;\n    krb5_checksum checksum;\n    krb5_data *der_cksum = NULL;\n    krb5_pa_data *pa, *pa_in;\n\n    memset(&checksum, 0, sizeof(checksum));\n\n    pa_in = krb5int_find_pa_data(context, request->padata,\n                                 KRB5_ENCPADATA_REQ_ENC_PA_REP);\n    if (pa_in == NULL)\n        return 0;\n\n    /* Compute and encode a checksum over the AS-REQ. */\n    retval = krb5_c_make_checksum(context, 0, reply_key, KRB5_KEYUSAGE_AS_REQ,\n                                  req_pkt, &checksum);\n    if (retval != 0)\n        goto cleanup;\n    retval = encode_krb5_checksum(&checksum, &der_cksum);\n    if (retval != 0)\n        goto cleanup;\n\n    /* Add a pa-data element to the list, stealing memory from der_cksum. */\n    retval = alloc_pa_data(KRB5_ENCPADATA_REQ_ENC_PA_REP, 0, &pa);\n    if (retval)\n        goto cleanup;\n    pa->length = der_cksum->length;\n    pa->contents = (uint8_t *)der_cksum->data;\n    der_cksum->data = NULL;\n    /* add_pa_data_element() claims pa on success or failure. */\n    retval = add_pa_data_element(out_enc_padata, pa);\n    if (retval)\n        goto cleanup;\n\n    /* Add a zero-length PA-FX-FAST element to the list. */\n    retval = alloc_pa_data(KRB5_PADATA_FX_FAST, 0, &pa);\n    if (retval)\n        goto cleanup;\n    /* add_pa_data_element() claims pa on success or failure. */\n    retval = add_pa_data_element(out_enc_padata, pa);\n\ncleanup:\n    krb5_free_checksum_contents(context, &checksum);\n    krb5_free_data(context, der_cksum);\n    return retval;\n}\n\n/*\n * Although the KDC doesn't call this function directly,\n * process_tcp_connection_read() in net-server.c does call it.\n */\nkrb5_error_code\nmake_toolong_error (void *handle, krb5_data **out)\n{\n    krb5_error errpkt;\n    krb5_error_code retval;\n    krb5_data *scratch;\n    struct server_handle *h = handle;\n\n    retval = krb5_us_timeofday(h->kdc_err_context,\n                               &errpkt.stime, &errpkt.susec);\n    if (retval)\n        return retval;\n    errpkt.error = KRB_ERR_FIELD_TOOLONG;\n    errpkt.server = h->kdc_realmlist[0]->realm_tgsprinc;\n    errpkt.client = NULL;\n    errpkt.cusec = 0;\n    errpkt.ctime = 0;\n    errpkt.text.length = 0;\n    errpkt.text.data = 0;\n    errpkt.e_data.length = 0;\n    errpkt.e_data.data = 0;\n    scratch = malloc(sizeof(*scratch));\n    if (scratch == NULL)\n        return ENOMEM;\n    retval = krb5_mk_error(h->kdc_err_context, &errpkt, scratch);\n    if (retval) {\n        free(scratch);\n        return retval;\n    }\n\n    *out = scratch;\n    return 0;\n}\n\nvoid reset_for_hangup(void *ctx)\n{\n    int k;\n    struct server_handle *h = ctx;\n\n    for (k = 0; k < h->kdc_numrealms; k++)\n        krb5_db_refresh_config(h->kdc_realmlist[k]->realm_context);\n}\n", "/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* lib/krb5/krb/s4u_creds.c */\n/*\n * Copyright (C) 2009 by the Massachusetts Institute of Technology.\n * All rights reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n\n#include \"k5-int.h\"\n#include \"int-proto.h\"\n\n/* Convert ticket flags to necessary KDC options */\n#define FLAGS2OPTS(flags) (flags & KDC_TKT_COMMON_MASK)\n\n/*\n * Implements S4U2Self, by which a service can request a ticket to\n * itself on behalf of an arbitrary principal.\n */\n\nstatic krb5_error_code\nkrb5_get_as_key_noop(\n    krb5_context context,\n    krb5_principal client,\n    krb5_enctype etype,\n    krb5_prompter_fct prompter,\n    void *prompter_data,\n    krb5_data *salt,\n    krb5_data *params,\n    krb5_keyblock *as_key,\n    void *gak_data,\n    k5_response_items *ritems)\n{\n    /* force a hard error, we don't actually have the key */\n    return KRB5_PREAUTH_FAILED;\n}\n\nstatic krb5_error_code\ns4u_identify_user(krb5_context context,\n                  krb5_creds *in_creds,\n                  krb5_data *subject_cert,\n                  krb5_principal *canon_user)\n{\n    krb5_error_code code;\n    krb5_preauthtype ptypes[1] = { KRB5_PADATA_S4U_X509_USER };\n    krb5_creds creds;\n    int use_master = 0;\n    krb5_get_init_creds_opt *opts = NULL;\n    krb5_principal_data client;\n    krb5_s4u_userid userid;\n\n    *canon_user = NULL;\n\n    if (in_creds->client == NULL && subject_cert == NULL) {\n        return EINVAL;\n    }\n\n    if (in_creds->client != NULL &&\n        in_creds->client->type != KRB5_NT_ENTERPRISE_PRINCIPAL) {\n        int anonymous;\n\n        anonymous = krb5_principal_compare(context, in_creds->client,\n                                           krb5_anonymous_principal());\n\n        return krb5_copy_principal(context,\n                                   anonymous ? in_creds->server\n                                   : in_creds->client,\n                                   canon_user);\n    }\n\n    memset(&creds, 0, sizeof(creds));\n\n    memset(&userid, 0, sizeof(userid));\n    if (subject_cert != NULL)\n        userid.subject_cert = *subject_cert;\n\n    code = krb5_get_init_creds_opt_alloc(context, &opts);\n    if (code != 0)\n        goto cleanup;\n    krb5_get_init_creds_opt_set_tkt_life(opts, 15);\n    krb5_get_init_creds_opt_set_renew_life(opts, 0);\n    krb5_get_init_creds_opt_set_forwardable(opts, 0);\n    krb5_get_init_creds_opt_set_proxiable(opts, 0);\n    krb5_get_init_creds_opt_set_canonicalize(opts, 1);\n    krb5_get_init_creds_opt_set_preauth_list(opts, ptypes, 1);\n\n    if (in_creds->client != NULL) {\n        client = *in_creds->client;\n        client.realm = in_creds->server->realm;\n    } else {\n        client.magic = KV5M_PRINCIPAL;\n        client.realm = in_creds->server->realm;\n        /* should this be NULL, empty or a fixed string? XXX */\n        client.data = NULL;\n        client.length = 0;\n        client.type = KRB5_NT_ENTERPRISE_PRINCIPAL;\n    }\n\n    code = k5_get_init_creds(context, &creds, &client, NULL, NULL, 0, NULL,\n                             opts, krb5_get_as_key_noop, &userid, &use_master,\n                             NULL);\n    if (code == 0 || code == KRB5_PREAUTH_FAILED) {\n        *canon_user = userid.user;\n        userid.user = NULL;\n        code = 0;\n    }\n\ncleanup:\n    krb5_free_cred_contents(context, &creds);\n    if (opts != NULL)\n        krb5_get_init_creds_opt_free(context, opts);\n    if (userid.user != NULL)\n        krb5_free_principal(context, userid.user);\n\n    return code;\n}\n\nstatic krb5_error_code\nmake_pa_for_user_checksum(krb5_context context,\n                          krb5_keyblock *key,\n                          krb5_pa_for_user *req,\n                          krb5_checksum *cksum)\n{\n    krb5_error_code code;\n    int i;\n    char *p;\n    krb5_data data;\n\n    data.length = 4;\n    for (i = 0; i < req->user->length; i++)\n        data.length += req->user->data[i].length;\n    data.length += req->user->realm.length;\n    data.length += req->auth_package.length;\n\n    p = data.data = malloc(data.length);\n    if (data.data == NULL)\n        return ENOMEM;\n\n    p[0] = (req->user->type >> 0) & 0xFF;\n    p[1] = (req->user->type >> 8) & 0xFF;\n    p[2] = (req->user->type >> 16) & 0xFF;\n    p[3] = (req->user->type >> 24) & 0xFF;\n    p += 4;\n\n    for (i = 0; i < req->user->length; i++) {\n        if (req->user->data[i].length > 0)\n            memcpy(p, req->user->data[i].data, req->user->data[i].length);\n        p += req->user->data[i].length;\n    }\n\n    if (req->user->realm.length > 0)\n        memcpy(p, req->user->realm.data, req->user->realm.length);\n    p += req->user->realm.length;\n\n    if (req->auth_package.length > 0)\n        memcpy(p, req->auth_package.data, req->auth_package.length);\n\n    /* Per spec, use hmac-md5 checksum regardless of key type. */\n    code = krb5_c_make_checksum(context, CKSUMTYPE_HMAC_MD5_ARCFOUR, key,\n                                KRB5_KEYUSAGE_APP_DATA_CKSUM, &data,\n                                cksum);\n\n    free(data.data);\n\n    return code;\n}\n\nstatic krb5_error_code\nbuild_pa_for_user(krb5_context context,\n                  krb5_creds *tgt,\n                  krb5_s4u_userid *userid,\n                  krb5_pa_data **out_padata)\n{\n    krb5_error_code code;\n    krb5_pa_data *padata;\n    krb5_pa_for_user for_user;\n    krb5_data *for_user_data = NULL;\n    char package[] = \"Kerberos\";\n\n    if (userid->user == NULL)\n        return EINVAL;\n\n    memset(&for_user, 0, sizeof(for_user));\n    for_user.user = userid->user;\n    for_user.auth_package.data = package;\n    for_user.auth_package.length = sizeof(package) - 1;\n\n    code = make_pa_for_user_checksum(context, &tgt->keyblock,\n                                     &for_user, &for_user.cksum);\n    if (code != 0)\n        goto cleanup;\n\n    code = encode_krb5_pa_for_user(&for_user, &for_user_data);\n    if (code != 0)\n        goto cleanup;\n\n    padata = malloc(sizeof(*padata));\n    if (padata == NULL) {\n        code = ENOMEM;\n        goto cleanup;\n    }\n\n    padata->magic = KV5M_PA_DATA;\n    padata->pa_type = KRB5_PADATA_FOR_USER;\n    padata->length = for_user_data->length;\n    padata->contents = (krb5_octet *)for_user_data->data;\n\n    free(for_user_data);\n    for_user_data = NULL;\n\n    *out_padata = padata;\n\ncleanup:\n    if (for_user.cksum.contents != NULL)\n        krb5_free_checksum_contents(context, &for_user.cksum);\n    krb5_free_data(context, for_user_data);\n\n    return code;\n}\n\n/*\n * This function is invoked by krb5int_make_tgs_request_ext() just before the\n * request is encoded; it gives us access to the nonce and subkey without\n * requiring them to be generated by the caller.\n */\nstatic krb5_error_code\nbuild_pa_s4u_x509_user(krb5_context context,\n                       krb5_keyblock *subkey,\n                       krb5_kdc_req *tgsreq,\n                       void *gcvt_data)\n{\n    krb5_error_code code;\n    krb5_pa_s4u_x509_user *s4u_user = (krb5_pa_s4u_x509_user *)gcvt_data;\n    krb5_data *data = NULL;\n    krb5_pa_data **padata;\n    krb5_cksumtype cksumtype;\n    int i;\n\n    assert(s4u_user->cksum.contents == NULL);\n\n    s4u_user->user_id.nonce = tgsreq->nonce;\n\n    code = encode_krb5_s4u_userid(&s4u_user->user_id, &data);\n    if (code != 0)\n        goto cleanup;\n\n    /* [MS-SFU] 2.2.2: unusual to say the least, but enc_padata secures it */\n    if (subkey->enctype == ENCTYPE_ARCFOUR_HMAC ||\n        subkey->enctype == ENCTYPE_ARCFOUR_HMAC_EXP) {\n        cksumtype = CKSUMTYPE_RSA_MD4;\n    } else {\n        code = krb5int_c_mandatory_cksumtype(context, subkey->enctype,\n                                             &cksumtype);\n    }\n    if (code != 0)\n        goto cleanup;\n\n    code = krb5_c_make_checksum(context, cksumtype, subkey,\n                                KRB5_KEYUSAGE_PA_S4U_X509_USER_REQUEST, data,\n                                &s4u_user->cksum);\n    if (code != 0)\n        goto cleanup;\n\n    krb5_free_data(context, data);\n    data = NULL;\n\n    code = encode_krb5_pa_s4u_x509_user(s4u_user, &data);\n    if (code != 0)\n        goto cleanup;\n\n    assert(tgsreq->padata != NULL);\n\n    for (i = 0; tgsreq->padata[i] != NULL; i++)\n        ;\n\n    padata = realloc(tgsreq->padata,\n                     (i + 2) * sizeof(krb5_pa_data *));\n    if (padata == NULL) {\n        code = ENOMEM;\n        goto cleanup;\n    }\n    tgsreq->padata = padata;\n\n    padata[i] = malloc(sizeof(krb5_pa_data));\n    if (padata[i] == NULL) {\n        code = ENOMEM;\n        goto cleanup;\n    }\n    padata[i]->magic = KV5M_PA_DATA;\n    padata[i]->pa_type = KRB5_PADATA_S4U_X509_USER;\n    padata[i]->length = data->length;\n    padata[i]->contents = (krb5_octet *)data->data;\n\n    padata[i + 1] = NULL;\n\n    free(data);\n    data = NULL;\n\ncleanup:\n    if (code != 0 && s4u_user->cksum.contents != NULL) {\n        krb5_free_checksum_contents(context, &s4u_user->cksum);\n        s4u_user->cksum.contents = NULL;\n    }\n    krb5_free_data(context, data);\n\n    return code;\n}\n\nstatic krb5_error_code\nverify_s4u2self_reply(krb5_context context,\n                      krb5_keyblock *subkey,\n                      krb5_pa_s4u_x509_user *req_s4u_user,\n                      krb5_pa_data **rep_padata,\n                      krb5_pa_data **enc_padata)\n{\n    krb5_error_code code;\n    krb5_pa_data *rep_s4u_padata, *enc_s4u_padata;\n    krb5_pa_s4u_x509_user *rep_s4u_user = NULL;\n    krb5_data data, *datap = NULL;\n    krb5_keyusage usage;\n    krb5_boolean valid;\n    krb5_boolean not_newer;\n\n    assert(req_s4u_user != NULL);\n\n    switch (subkey->enctype) {\n    case ENCTYPE_DES_CBC_CRC:\n    case ENCTYPE_DES_CBC_MD4:\n    case ENCTYPE_DES_CBC_MD5:\n    case ENCTYPE_DES3_CBC_SHA1:\n    case ENCTYPE_DES3_CBC_RAW:\n    case ENCTYPE_ARCFOUR_HMAC:\n    case ENCTYPE_ARCFOUR_HMAC_EXP :\n        not_newer = TRUE;\n        break;\n    default:\n        not_newer = FALSE;\n        break;\n    }\n\n    enc_s4u_padata = krb5int_find_pa_data(context,\n                                          enc_padata,\n                                          KRB5_PADATA_S4U_X509_USER);\n\n    /* XXX this will break newer enctypes with a MIT 1.7 KDC */\n    rep_s4u_padata = krb5int_find_pa_data(context,\n                                          rep_padata,\n                                          KRB5_PADATA_S4U_X509_USER);\n    if (rep_s4u_padata == NULL) {\n        if (not_newer == FALSE || enc_s4u_padata != NULL)\n            return KRB5_KDCREP_MODIFIED;\n        else\n            return 0;\n    }\n\n    data.length = rep_s4u_padata->length;\n    data.data = (char *)rep_s4u_padata->contents;\n\n    code = decode_krb5_pa_s4u_x509_user(&data, &rep_s4u_user);\n    if (code != 0)\n        goto cleanup;\n\n    if (rep_s4u_user->user_id.nonce != req_s4u_user->user_id.nonce) {\n        code = KRB5_KDCREP_MODIFIED;\n        goto cleanup;\n    }\n\n    code = encode_krb5_s4u_userid(&rep_s4u_user->user_id, &datap);\n    if (code != 0)\n        goto cleanup;\n\n    if (rep_s4u_user->user_id.options & KRB5_S4U_OPTS_USE_REPLY_KEY_USAGE)\n        usage = KRB5_KEYUSAGE_PA_S4U_X509_USER_REPLY;\n    else\n        usage = KRB5_KEYUSAGE_PA_S4U_X509_USER_REQUEST;\n\n    code = krb5_c_verify_checksum(context, subkey, usage, datap,\n                                  &rep_s4u_user->cksum, &valid);\n    if (code != 0)\n        goto cleanup;\n    if (valid == FALSE) {\n        code = KRB5_KDCREP_MODIFIED;\n        goto cleanup;\n    }\n\n    /*\n     * KDCs that support KRB5_S4U_OPTS_USE_REPLY_KEY_USAGE also return\n     * S4U enc_padata for older (pre-AES) encryption types only.\n     */\n    if (not_newer) {\n        if (enc_s4u_padata == NULL) {\n            if (rep_s4u_user->user_id.options &\n                KRB5_S4U_OPTS_USE_REPLY_KEY_USAGE) {\n                code = KRB5_KDCREP_MODIFIED;\n                goto cleanup;\n            }\n        } else {\n            if (enc_s4u_padata->length !=\n                req_s4u_user->cksum.length + rep_s4u_user->cksum.length) {\n                code = KRB5_KDCREP_MODIFIED;\n                goto cleanup;\n            }\n            if (memcmp(enc_s4u_padata->contents,\n                       req_s4u_user->cksum.contents,\n                       req_s4u_user->cksum.length) ||\n                memcmp(&enc_s4u_padata->contents[req_s4u_user->cksum.length],\n                       rep_s4u_user->cksum.contents,\n                       rep_s4u_user->cksum.length)) {\n                code = KRB5_KDCREP_MODIFIED;\n                goto cleanup;\n            }\n        }\n    } else if (!krb5_c_is_keyed_cksum(rep_s4u_user->cksum.checksum_type)) {\n        code = KRB5KRB_AP_ERR_INAPP_CKSUM;\n        goto cleanup;\n    }\n\ncleanup:\n    krb5_free_pa_s4u_x509_user(context, rep_s4u_user);\n    krb5_free_data(context, datap);\n\n    return code;\n}\n\n/* Unparse princ and re-parse it as an enterprise principal. */\nstatic krb5_error_code\nconvert_to_enterprise(krb5_context context, krb5_principal princ,\n                      krb5_principal *eprinc_out)\n{\n    krb5_error_code code;\n    char *str;\n\n    *eprinc_out = NULL;\n    code = krb5_unparse_name(context, princ, &str);\n    if (code != 0)\n        return code;\n    code = krb5_parse_name_flags(context, str,\n                                 KRB5_PRINCIPAL_PARSE_ENTERPRISE |\n                                 KRB5_PRINCIPAL_PARSE_IGNORE_REALM,\n                                 eprinc_out);\n    krb5_free_unparsed_name(context, str);\n    return code;\n}\n\nstatic krb5_error_code\nkrb5_get_self_cred_from_kdc(krb5_context context,\n                            krb5_flags options,\n                            krb5_ccache ccache,\n                            krb5_creds *in_creds,\n                            krb5_data *subject_cert,\n                            krb5_data *user_realm,\n                            krb5_creds **out_creds)\n{\n    krb5_error_code code;\n    krb5_principal tgs = NULL, eprinc = NULL;\n    krb5_principal_data sprinc;\n    krb5_creds tgtq, s4u_creds, *tgt = NULL, *tgtptr;\n    krb5_creds *referral_tgts[KRB5_REFERRAL_MAXHOPS];\n    krb5_pa_s4u_x509_user s4u_user;\n    int referral_count = 0, i;\n    krb5_flags kdcopt;\n\n    memset(&tgtq, 0, sizeof(tgtq));\n    memset(referral_tgts, 0, sizeof(referral_tgts));\n    *out_creds = NULL;\n\n    memset(&s4u_user, 0, sizeof(s4u_user));\n\n    if (in_creds->client != NULL && in_creds->client->length > 0) {\n        if (in_creds->client->type == KRB5_NT_ENTERPRISE_PRINCIPAL) {\n            code = krb5_build_principal_ext(context,\n                                            &s4u_user.user_id.user,\n                                            user_realm->length,\n                                            user_realm->data,\n                                            in_creds->client->data[0].length,\n                                            in_creds->client->data[0].data,\n                                            0);\n            if (code != 0)\n                goto cleanup;\n            s4u_user.user_id.user->type = KRB5_NT_ENTERPRISE_PRINCIPAL;\n        } else {\n            code = krb5_copy_principal(context,\n                                       in_creds->client,\n                                       &s4u_user.user_id.user);\n            if (code != 0)\n                goto cleanup;\n        }\n    } else {\n        code = krb5_build_principal_ext(context, &s4u_user.user_id.user,\n                                        user_realm->length,\n                                        user_realm->data);\n        if (code != 0)\n            goto cleanup;\n        s4u_user.user_id.user->type = KRB5_NT_ENTERPRISE_PRINCIPAL;\n    }\n    if (subject_cert != NULL)\n        s4u_user.user_id.subject_cert = *subject_cert;\n    s4u_user.user_id.options = KRB5_S4U_OPTS_USE_REPLY_KEY_USAGE;\n\n    /* First, acquire a TGT to the user's realm. */\n    code = krb5int_tgtname(context, user_realm, &in_creds->server->realm,\n                           &tgs);\n    if (code != 0)\n        goto cleanup;\n\n    tgtq.client = in_creds->server;\n    tgtq.server = tgs;\n\n    code = krb5_get_credentials(context, options, ccache, &tgtq, &tgt);\n    if (code != 0)\n        goto cleanup;\n\n    tgtptr = tgt;\n\n    /* Convert the server principal to an enterprise principal, for use with\n     * foreign realms. */\n    code = convert_to_enterprise(context, in_creds->server, &eprinc);\n    if (code != 0)\n        goto cleanup;\n\n    /* Make a shallow copy of in_creds with client pointing to the server\n     * principal.  We will set s4u_creds.server for each request. */\n    s4u_creds = *in_creds;\n    s4u_creds.client = in_creds->server;\n\n    /* Then, walk back the referral path to S4U2Self for user */\n    kdcopt = 0;\n    if (options & KRB5_GC_CANONICALIZE)\n        kdcopt |= KDC_OPT_CANONICALIZE;\n    if (options & KRB5_GC_FORWARDABLE)\n        kdcopt |= KDC_OPT_FORWARDABLE;\n    if (options & KRB5_GC_NO_TRANSIT_CHECK)\n        kdcopt |= KDC_OPT_DISABLE_TRANSITED_CHECK;\n\n    for (referral_count = 0;\n         referral_count < KRB5_REFERRAL_MAXHOPS;\n         referral_count++)\n    {\n        krb5_pa_data **in_padata = NULL;\n        krb5_pa_data **out_padata = NULL;\n        krb5_pa_data **enc_padata = NULL;\n        krb5_keyblock *subkey = NULL;\n\n        if (s4u_user.user_id.user != NULL && s4u_user.user_id.user->length) {\n            in_padata = calloc(2, sizeof(krb5_pa_data *));\n            if (in_padata == NULL) {\n                code = ENOMEM;\n                goto cleanup;\n            }\n            code = build_pa_for_user(context,\n                                     tgtptr,\n                                     &s4u_user.user_id, &in_padata[0]);\n            if (code != 0) {\n                krb5_free_pa_data(context, in_padata);\n                goto cleanup;\n            }\n        }\n\n        if (data_eq(tgtptr->server->data[1], in_creds->server->realm)) {\n            /* When asking the server realm, use the real principal. */\n            s4u_creds.server = in_creds->server;\n        } else {\n            /* When asking a foreign realm, use the enterprise principal, with\n             * the realm set to the TGS realm. */\n            sprinc = *eprinc;\n            sprinc.realm = tgtptr->server->data[1];\n            s4u_creds.server = &sprinc;\n        }\n\n        code = krb5_get_cred_via_tkt_ext(context, tgtptr,\n                                         KDC_OPT_CANONICALIZE |\n                                         FLAGS2OPTS(tgtptr->ticket_flags) |\n                                         kdcopt,\n                                         tgtptr->addresses,\n                                         in_padata, &s4u_creds,\n                                         build_pa_s4u_x509_user, &s4u_user,\n                                         &out_padata, &enc_padata,\n                                         out_creds, &subkey);\n        if (code != 0) {\n            krb5_free_checksum_contents(context, &s4u_user.cksum);\n            krb5_free_pa_data(context, in_padata);\n            goto cleanup;\n        }\n\n        code = verify_s4u2self_reply(context, subkey, &s4u_user,\n                                     out_padata, enc_padata);\n\n        krb5_free_checksum_contents(context, &s4u_user.cksum);\n        krb5_free_pa_data(context, in_padata);\n        krb5_free_pa_data(context, out_padata);\n        krb5_free_pa_data(context, enc_padata);\n        krb5_free_keyblock(context, subkey);\n\n        if (code != 0)\n            goto cleanup;\n\n        if (krb5_principal_compare(context,\n                                   in_creds->server,\n                                   (*out_creds)->server)) {\n            code = 0;\n            goto cleanup;\n        } else if (IS_TGS_PRINC((*out_creds)->server)) {\n            krb5_data *r1 = &tgtptr->server->data[1];\n            krb5_data *r2 = &(*out_creds)->server->data[1];\n\n            if (data_eq(*r1, *r2)) {\n                krb5_free_creds(context, *out_creds);\n                *out_creds = NULL;\n                code = KRB5_ERR_HOST_REALM_UNKNOWN;\n                break;\n            }\n            for (i = 0; i < referral_count; i++) {\n                if (krb5_principal_compare(context,\n                                           (*out_creds)->server,\n                                           referral_tgts[i]->server)) {\n                    code = KRB5_KDC_UNREACH;\n                    goto cleanup;\n                }\n            }\n\n            tgtptr = *out_creds;\n            referral_tgts[referral_count] = *out_creds;\n            *out_creds = NULL;\n        } else {\n            krb5_free_creds(context, *out_creds);\n            *out_creds = NULL;\n            code = KRB5KRB_AP_WRONG_PRINC; /* XXX */\n            break;\n        }\n    }\n\ncleanup:\n    for (i = 0; i < KRB5_REFERRAL_MAXHOPS; i++) {\n        if (referral_tgts[i] != NULL)\n            krb5_free_creds(context, referral_tgts[i]);\n    }\n    krb5_free_principal(context, tgs);\n    krb5_free_principal(context, eprinc);\n    krb5_free_creds(context, tgt);\n    krb5_free_principal(context, s4u_user.user_id.user);\n    krb5_free_checksum_contents(context, &s4u_user.cksum);\n\n    return code;\n}\n\nkrb5_error_code KRB5_CALLCONV\nkrb5_get_credentials_for_user(krb5_context context, krb5_flags options,\n                              krb5_ccache ccache, krb5_creds *in_creds,\n                              krb5_data *subject_cert,\n                              krb5_creds **out_creds)\n{\n    krb5_error_code code;\n    krb5_principal realm = NULL;\n\n    *out_creds = NULL;\n\n    if (options & KRB5_GC_CONSTRAINED_DELEGATION) {\n        code = EINVAL;\n        goto cleanup;\n    }\n\n    if (in_creds->client != NULL) {\n        /* Uncanonicalised check */\n        code = krb5_get_credentials(context, options | KRB5_GC_CACHED,\n                                    ccache, in_creds, out_creds);\n        if (code != KRB5_CC_NOTFOUND && code != KRB5_CC_NOT_KTYPE)\n            goto cleanup;\n\n        if ((options & KRB5_GC_CACHED) && !(options & KRB5_GC_CANONICALIZE))\n            goto cleanup;\n    }\n\n    code = s4u_identify_user(context, in_creds, subject_cert, &realm);\n    if (code != 0)\n        goto cleanup;\n\n    if (in_creds->client != NULL &&\n        in_creds->client->type == KRB5_NT_ENTERPRISE_PRINCIPAL) {\n        /* Post-canonicalisation check for enterprise principals */\n        krb5_creds mcreds = *in_creds;\n        mcreds.client = realm;\n        code = krb5_get_credentials(context, options | KRB5_GC_CACHED,\n                                    ccache, &mcreds, out_creds);\n        if ((code != KRB5_CC_NOTFOUND && code != KRB5_CC_NOT_KTYPE)\n            || (options & KRB5_GC_CACHED))\n            goto cleanup;\n    }\n\n    code = krb5_get_self_cred_from_kdc(context, options, ccache, in_creds,\n                                       subject_cert, &realm->realm, out_creds);\n    if (code != 0)\n        goto cleanup;\n\n    assert(*out_creds != NULL);\n\n    if ((options & KRB5_GC_NO_STORE) == 0) {\n        code = krb5_cc_store_cred(context, ccache, *out_creds);\n        if (code != 0)\n            goto cleanup;\n    }\n\ncleanup:\n    if (code != 0 && *out_creds != NULL) {\n        krb5_free_creds(context, *out_creds);\n        *out_creds = NULL;\n    }\n\n    krb5_free_principal(context, realm);\n\n    return code;\n}\n\n/*\n * Exported API for constrained delegation (S4U2Proxy).\n *\n * This is preferable to using krb5_get_credentials directly because\n * it can perform some additional checks.\n */\nkrb5_error_code KRB5_CALLCONV\nkrb5_get_credentials_for_proxy(krb5_context context,\n                               krb5_flags options,\n                               krb5_ccache ccache,\n                               krb5_creds *in_creds,\n                               krb5_ticket *evidence_tkt,\n                               krb5_creds **out_creds)\n{\n    krb5_error_code code;\n    krb5_creds mcreds;\n    krb5_creds *ncreds = NULL;\n    krb5_flags fields;\n    krb5_data *evidence_tkt_data = NULL;\n    krb5_creds s4u_creds;\n\n    *out_creds = NULL;\n\n    if (in_creds == NULL || in_creds->client == NULL ||\n        evidence_tkt == NULL || evidence_tkt->enc_part2 == NULL) {\n        code = EINVAL;\n        goto cleanup;\n    }\n\n    /*\n     * Caller should have set in_creds->client to match evidence\n     * ticket client\n     */\n    if (!krb5_principal_compare(context, evidence_tkt->enc_part2->client,\n                                in_creds->client)) {\n        code = EINVAL;\n        goto cleanup;\n    }\n\n    if ((evidence_tkt->enc_part2->flags & TKT_FLG_FORWARDABLE) == 0) {\n        code = KRB5_TKT_NOT_FORWARDABLE;\n        goto cleanup;\n    }\n\n    code = krb5int_construct_matching_creds(context, options, in_creds,\n                                            &mcreds, &fields);\n    if (code != 0)\n        goto cleanup;\n\n    ncreds = calloc(1, sizeof(*ncreds));\n    if (ncreds == NULL) {\n        code = ENOMEM;\n        goto cleanup;\n    }\n    ncreds->magic = KV5M_CRED;\n\n    code = krb5_cc_retrieve_cred(context, ccache, fields, &mcreds, ncreds);\n    if (code != 0) {\n        free(ncreds);\n        ncreds = in_creds;\n    } else {\n        *out_creds = ncreds;\n    }\n\n    if ((code != KRB5_CC_NOTFOUND && code != KRB5_CC_NOT_KTYPE)\n        || options & KRB5_GC_CACHED)\n        goto cleanup;\n\n    code = encode_krb5_ticket(evidence_tkt, &evidence_tkt_data);\n    if (code != 0)\n        goto cleanup;\n\n    s4u_creds = *in_creds;\n    s4u_creds.client = evidence_tkt->server;\n    s4u_creds.second_ticket = *evidence_tkt_data;\n\n    code = krb5_get_credentials(context,\n                                options | KRB5_GC_CONSTRAINED_DELEGATION,\n                                ccache,\n                                &s4u_creds,\n                                out_creds);\n    if (code != 0)\n        goto cleanup;\n\n    /*\n     * Check client name because we couldn't compare that inside\n     * krb5_get_credentials() (enc_part2 is unavailable in clear)\n     */\n    if (!krb5_principal_compare(context,\n                                evidence_tkt->enc_part2->client,\n                                (*out_creds)->client)) {\n        code = KRB5_KDCREP_MODIFIED;\n        goto cleanup;\n    }\n\ncleanup:\n    if (*out_creds != NULL && code != 0) {\n        krb5_free_creds(context, *out_creds);\n        *out_creds = NULL;\n    }\n    if (evidence_tkt_data != NULL)\n        krb5_free_data(context, evidence_tkt_data);\n\n    return code;\n}\n", "from k5test import *\n\nrealm = K5Realm(create_host=False, get_creds=False)\nusercache = 'FILE:' + os.path.join(realm.testdir, 'usercache')\nstoragecache = 'FILE:' + os.path.join(realm.testdir, 'save')\n\n# Create two service principals with keys in the default keytab.\nservice1 = 'service/1@%s' % realm.realm\nrealm.addprinc(service1)\nrealm.extract_keytab(service1, realm.keytab)\nservice2 = 'service/2@%s' % realm.realm\nrealm.addprinc(service2)\nrealm.extract_keytab(service2, realm.keytab)\n\npuser = 'p:' + realm.user_princ\npservice1 = 'p:' + service1\npservice2 = 'p:' + service2\n\n# Get forwardable creds for service1 in the default cache.\nrealm.kinit(service1, None, ['-f', '-k'])\n\n# Try krb5 -> S4U2Proxy with forwardable user creds.  This should fail\n# at the S4U2Proxy step since the DB2 back end currently has no\n# support for allowing it.\nrealm.kinit(realm.user_princ, password('user'), ['-f', '-c', usercache])\noutput = realm.run(['./t_s4u2proxy_krb5', usercache, storagecache, '-',\n                    pservice1, pservice2], expected_code=1)\nif ('auth1: ' + realm.user_princ not in output or\n    'NOT_ALLOWED_TO_DELEGATE' not in output):\n    fail('krb5 -> s4u2proxy')\n\n# Again with SPNEGO.\noutput = realm.run(['./t_s4u2proxy_krb5', '--spnego', usercache, storagecache,\n                    '-', pservice1, pservice2],\n                   expected_code=1)\nif ('auth1: ' + realm.user_princ not in output or\n    'NOT_ALLOWED_TO_DELEGATE' not in output):\n    fail('krb5 -> s4u2proxy (SPNEGO)')\n\n# Try krb5 -> S4U2Proxy without forwardable user creds.  This should\n# result in no delegated credential being created by\n# accept_sec_context.\nrealm.kinit(realm.user_princ, password('user'), ['-c', usercache])\nrealm.run(['./t_s4u2proxy_krb5', usercache, storagecache, pservice1,\n           pservice1, pservice2], expected_msg='no credential delegated')\n\n# Try S4U2Self.  Ask for an S4U2Proxy step; this won't happen because\n# service/1 isn't allowed to get a forwardable S4U2Self ticket.\noutput = realm.run(['./t_s4u', puser, pservice2])\nif ('Warning: no delegated cred handle' not in output or\n    'Source name:\\t' + realm.user_princ not in output):\n    fail('s4u2self')\noutput = realm.run(['./t_s4u', '--spnego', puser, pservice2])\nif ('Warning: no delegated cred handle' not in output or\n    'Source name:\\t' + realm.user_princ not in output):\n    fail('s4u2self (SPNEGO)')\n\n# Correct that problem and try again.  As above, the S4U2Proxy step\n# won't actually succeed since we don't support that in DB2.\nrealm.run([kadminl, 'modprinc', '+ok_to_auth_as_delegate', service1])\nrealm.run(['./t_s4u', puser, pservice2], expected_code=1,\n          expected_msg='NOT_ALLOWED_TO_DELEGATE')\n\n# Again with SPNEGO.  This uses SPNEGO for the initial authentication,\n# but still uses krb5 for S4U2Proxy--the delegated cred is returned as\n# a krb5 cred, not a SPNEGO cred, and t_s4u uses the delegated cred\n# directly rather than saving and reacquiring it.\nrealm.run(['./t_s4u', '--spnego', puser, pservice2], expected_code=1,\n          expected_msg='NOT_ALLOWED_TO_DELEGATE')\n\nrealm.stop()\n\n# Set up a realm using the test KDB module so that we can do\n# successful S4U2Proxy delegations.\ntestprincs = {'krbtgt/KRBTEST.COM': {'keys': 'aes128-cts'},\n              'user': {'keys': 'aes128-cts'},\n              'service/1': {'flags': '+ok-to-auth-as-delegate',\n                            'keys': 'aes128-cts'},\n              'service/2': {'keys': 'aes128-cts'}}\nconf = {'realms': {'$realm': {'database_module': 'test'}},\n        'dbmodules': {'test': {'db_library': 'test',\n                               'princs': testprincs,\n                               'delegation': {'service/1': 'service/2'}}}}\nrealm = K5Realm(create_kdb=False, kdc_conf=conf)\nuserkeytab = 'FILE:' + os.path.join(realm.testdir, 'userkeytab')\nrealm.extract_keytab(realm.user_princ, userkeytab)\nrealm.extract_keytab(service1, realm.keytab)\nrealm.extract_keytab(service2, realm.keytab)\nrealm.start_kdc()\n\n# Get forwardable creds for service1 in the default cache.\nrealm.kinit(service1, None, ['-f', '-k'])\n\n# Successful krb5 -> S4U2Proxy, with krb5 and SPNEGO mechs.\nrealm.kinit(realm.user_princ, None, ['-f', '-k', '-c', usercache,\n                                     '-t', userkeytab])\nout = realm.run(['./t_s4u2proxy_krb5', usercache, storagecache, '-',\n                 pservice1, pservice2])\nif 'auth1: user@' not in out or 'auth2: user@' not in out:\n    fail('krb5 -> s4u2proxy')\nout = realm.run(['./t_s4u2proxy_krb5', '--spnego', usercache, storagecache,\n                 '-', pservice1, pservice2])\nif 'auth1: user@' not in out or 'auth2: user@' not in out:\n    fail('krb5 -> s4u2proxy')\n\n# Successful S4U2Self -> S4U2Proxy.\nout = realm.run(['./t_s4u', puser, pservice2])\n\n# Regression test for #8139: get a user ticket directly for service1 and\n# try krb5 -> S4U2Proxy.\nrealm.kinit(realm.user_princ, None, ['-f', '-k', '-c', usercache,\n                                     '-t', userkeytab, '-S', service1])\nout = realm.run(['./t_s4u2proxy_krb5', usercache, storagecache, '-',\n                 pservice1, pservice2])\nif 'auth1: user@' not in out or 'auth2: user@' not in out:\n    fail('krb5 -> s4u2proxy')\n\n# Simulate a krbtgt rollover and verify that the user ticket can still\n# be validated.\nrealm.stop_kdc()\nnewtgt_keys = ['2 aes128-cts', '1 aes128-cts']\nnewtgt_princs = {'krbtgt/KRBTEST.COM': {'keys': newtgt_keys}}\nnewtgt_conf = {'dbmodules': {'test': {'princs': newtgt_princs}}}\nnewtgt_env = realm.special_env('newtgt', True, kdc_conf=newtgt_conf)\nrealm.start_kdc(env=newtgt_env)\nout = realm.run(['./t_s4u2proxy_krb5', usercache, storagecache, '-',\n                 pservice1, pservice2])\nif 'auth1: user@' not in out or 'auth2: user@' not in out:\n    fail('krb5 -> s4u2proxy')\n\n# Get a user ticket after the krbtgt rollover and verify that\n# S4U2Proxy delegation works (also a #8139 regression test).\nrealm.kinit(realm.user_princ, None, ['-f', '-k', '-c', usercache,\n                                     '-t', userkeytab])\nout = realm.run(['./t_s4u2proxy_krb5', usercache, storagecache, '-',\n                 pservice1, pservice2])\nif 'auth1: user@' not in out or 'auth2: user@' not in out:\n    fail('krb5 -> s4u2proxy')\n\nrealm.stop()\n\n# Test cross realm S4U2Self using server referrals.\nmark('cross-realm S4U2Self')\ntestprincs = {'krbtgt/SREALM': {'keys': 'aes128-cts'},\n              'krbtgt/UREALM': {'keys': 'aes128-cts'},\n              'user': {'keys': 'aes128-cts', 'flags': '+preauth'}}\nkdcconf1 = {'realms': {'$realm': {'database_module': 'test'}},\n            'dbmodules': {'test': {'db_library': 'test',\n                                   'princs': testprincs,\n                                   'alias': {'enterprise@abc': '@UREALM'}}}}\nkdcconf2 = {'realms': {'$realm': {'database_module': 'test'}},\n            'dbmodules': {'test': {'db_library': 'test',\n                                   'princs': testprincs,\n                                   'alias': {'user@SREALM': '@SREALM',\n                                             'enterprise@abc': 'user'}}}}\nr1, r2 = cross_realms(2, xtgts=(),\n                      args=({'realm': 'SREALM', 'kdc_conf': kdcconf1},\n                            {'realm': 'UREALM', 'kdc_conf': kdcconf2}),\n                      create_kdb=False)\n\nr1.start_kdc()\nr2.start_kdc()\nr1.extract_keytab(r1.user_princ, r1.keytab)\nr1.kinit(r1.user_princ, None, ['-k', '-t', r1.keytab])\n\n# Include a regression test for #8741 by unsetting the default realm.\nremove_default = {'libdefaults': {'default_realm': None}}\nno_default = r1.special_env('no_default', False, krb5_conf=remove_default)\nmsgs = ('Getting credentials user@UREALM -> user@SREALM',\n        '/Matching credential not found',\n        'Getting credentials user@SREALM -> krbtgt/UREALM@SREALM',\n        'Received creds for desired service krbtgt/UREALM@SREALM',\n        'via TGT krbtgt/UREALM@SREALM after requesting user\\\\@SREALM@UREALM',\n        'krbtgt/SREALM@UREALM differs from requested user\\\\@SREALM@UREALM',\n        'via TGT krbtgt/SREALM@UREALM after requesting user@SREALM',\n        'TGS reply is for user@UREALM -> user@SREALM')\nr1.run(['./t_s4u', 'p:' + r2.user_princ, '-', r1.keytab], env=no_default,\n       expected_trace=msgs)\n\n# Test realm identification of enterprise principal names ([MS-S4U]\n# 3.1.5.1.1.1).  Attach a bogus realm to the enterprise name to verify\n# that we start at the server realm.\nmark('cross-realm S4U2Self with enterprise name')\nmsgs = ('Getting initial credentials for enterprise\\\\@abc@SREALM',\n        'Processing preauth types: PA-FOR-X509-USER (130)',\n        'Sending unauthenticated request',\n        '/Realm not local to KDC',\n        'Following referral to realm UREALM',\n        'Processing preauth types: PA-FOR-X509-USER (130)',\n        'Sending unauthenticated request',\n        '/Additional pre-authentication required',\n        '/Generic preauthentication failure',\n        'Getting credentials enterprise\\\\@abc@UREALM -> user@SREALM',\n        'TGS reply is for enterprise\\@abc@UREALM -> user@SREALM')\nr1.run(['./t_s4u', 'e:enterprise@abc@NOREALM', '-', r1.keytab],\n       expected_trace=msgs)\n\nr1.stop()\nr2.stop()\n\nsuccess('S4U test cases')\n"], "fixing_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* kdc/kdc_util.c - Utility functions for the KDC implementation */\n/*\n * Copyright 1990,1991,2007,2008,2009 by the Massachusetts Institute of Technology.\n * All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n/*\n * Copyright (c) 2006-2008, Novell, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *   * The copyright holder's name is not used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"k5-int.h\"\n#include \"kdc_util.h\"\n#include \"extern.h\"\n#include <stdio.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <kadm5/admin.h>\n#include \"adm_proto.h\"\n#include \"net-server.h\"\n#include <limits.h>\n\n#ifdef KRBCONF_VAGUE_ERRORS\nconst int vague_errors = 1;\n#else\nconst int vague_errors = 0;\n#endif\n\nstatic krb5_error_code kdc_rd_ap_req(kdc_realm_t *kdc_active_realm,\n                                     krb5_ap_req *apreq,\n                                     krb5_auth_context auth_context,\n                                     krb5_db_entry **server,\n                                     krb5_keyblock **tgskey);\nstatic krb5_error_code find_server_key(krb5_context,\n                                       krb5_db_entry *, krb5_enctype,\n                                       krb5_kvno, krb5_keyblock **,\n                                       krb5_kvno *);\n\n/*\n * concatenate first two authdata arrays, returning an allocated replacement.\n * The replacement should be freed with krb5_free_authdata().\n */\nkrb5_error_code\nconcat_authorization_data(krb5_context context,\n                          krb5_authdata **first, krb5_authdata **second,\n                          krb5_authdata ***output)\n{\n    int i, j;\n    krb5_authdata **ptr, **retdata;\n\n    /* count up the entries */\n    i = 0;\n    if (first)\n        for (ptr = first; *ptr; ptr++)\n            i++;\n    if (second)\n        for (ptr = second; *ptr; ptr++)\n            i++;\n\n    retdata = (krb5_authdata **)malloc((i+1)*sizeof(*retdata));\n    if (!retdata)\n        return ENOMEM;\n    retdata[i] = 0;                     /* null-terminated array */\n    for (i = 0, j = 0, ptr = first; j < 2 ; ptr = second, j++)\n        while (ptr && *ptr) {\n            /* now walk & copy */\n            retdata[i] = (krb5_authdata *)malloc(sizeof(*retdata[i]));\n            if (!retdata[i]) {\n                krb5_free_authdata(context, retdata);\n                return ENOMEM;\n            }\n            *retdata[i] = **ptr;\n            if (!(retdata[i]->contents =\n                  (krb5_octet *)malloc(retdata[i]->length))) {\n                free(retdata[i]);\n                retdata[i] = 0;\n                krb5_free_authdata(context, retdata);\n                return ENOMEM;\n            }\n            memcpy(retdata[i]->contents, (*ptr)->contents, retdata[i]->length);\n\n            ptr++;\n            i++;\n        }\n    *output = retdata;\n    return 0;\n}\n\nkrb5_boolean\nis_local_principal(kdc_realm_t *kdc_active_realm, krb5_const_principal princ1)\n{\n    return krb5_realm_compare(kdc_context, princ1, tgs_server);\n}\n\n/*\n * Returns TRUE if the kerberos principal is the name of a Kerberos ticket\n * service.\n */\nkrb5_boolean\nkrb5_is_tgs_principal(krb5_const_principal principal)\n{\n    if (krb5_princ_size(kdc_context, principal) != 2)\n        return FALSE;\n    if (data_eq_string(*krb5_princ_component(kdc_context, principal, 0),\n                       KRB5_TGS_NAME))\n        return TRUE;\n    else\n        return FALSE;\n}\n\n/* Returns TRUE if principal is the name of a cross-realm TGS. */\nkrb5_boolean\nis_cross_tgs_principal(krb5_const_principal principal)\n{\n    if (!krb5_is_tgs_principal(principal))\n        return FALSE;\n    if (!data_eq(*krb5_princ_component(kdc_context, principal, 1),\n                 *krb5_princ_realm(kdc_context, principal)))\n        return TRUE;\n    else\n        return FALSE;\n}\n\n/*\n * given authentication data (provides seed for checksum), verify checksum\n * for source data.\n */\nstatic krb5_error_code\ncomp_cksum(krb5_context kcontext, krb5_data *source, krb5_ticket *ticket,\n           krb5_checksum *his_cksum)\n{\n    krb5_error_code       retval;\n    krb5_boolean          valid;\n\n    if (!krb5_c_valid_cksumtype(his_cksum->checksum_type))\n        return KRB5KDC_ERR_SUMTYPE_NOSUPP;\n\n    /* must be collision proof */\n    if (!krb5_c_is_coll_proof_cksum(his_cksum->checksum_type))\n        return KRB5KRB_AP_ERR_INAPP_CKSUM;\n\n    /* verify checksum */\n    if ((retval = krb5_c_verify_checksum(kcontext, ticket->enc_part2->session,\n                                         KRB5_KEYUSAGE_TGS_REQ_AUTH_CKSUM,\n                                         source, his_cksum, &valid)))\n        return(retval);\n\n    if (!valid)\n        return(KRB5KRB_AP_ERR_BAD_INTEGRITY);\n\n    return(0);\n}\n\n/* If a header ticket is decrypted, *ticket_out is filled in even on error. */\nkrb5_error_code\nkdc_process_tgs_req(kdc_realm_t *kdc_active_realm,\n                    krb5_kdc_req *request, const krb5_fulladdr *from,\n                    krb5_data *pkt, krb5_ticket **ticket_out,\n                    krb5_db_entry **krbtgt_ptr,\n                    krb5_keyblock **tgskey,\n                    krb5_keyblock **subkey,\n                    krb5_pa_data **pa_tgs_req)\n{\n    krb5_pa_data        * tmppa;\n    krb5_ap_req         * apreq;\n    krb5_error_code       retval;\n    krb5_authdata **authdata = NULL;\n    krb5_data             scratch1;\n    krb5_data           * scratch = NULL;\n    krb5_boolean          foreign_server = FALSE;\n    krb5_auth_context     auth_context = NULL;\n    krb5_authenticator  * authenticator = NULL;\n    krb5_checksum       * his_cksum = NULL;\n    krb5_db_entry       * krbtgt = NULL;\n    krb5_ticket         * ticket;\n\n    *ticket_out = NULL;\n    *krbtgt_ptr = NULL;\n    *tgskey = NULL;\n\n    tmppa = krb5int_find_pa_data(kdc_context,\n                                 request->padata, KRB5_PADATA_AP_REQ);\n    if (!tmppa)\n        return KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n    scratch1.length = tmppa->length;\n    scratch1.data = (char *)tmppa->contents;\n    if ((retval = decode_krb5_ap_req(&scratch1, &apreq)))\n        return retval;\n    ticket = apreq->ticket;\n\n    if (isflagset(apreq->ap_options, AP_OPTS_USE_SESSION_KEY) ||\n        isflagset(apreq->ap_options, AP_OPTS_MUTUAL_REQUIRED)) {\n        krb5_klog_syslog(LOG_INFO, _(\"TGS_REQ: SESSION KEY or MUTUAL\"));\n        retval = KRB5KDC_ERR_POLICY;\n        goto cleanup;\n    }\n\n    /* If the \"server\" principal in the ticket is not something\n       in the local realm, then we must refuse to service the request\n       if the client claims to be from the local realm.\n\n       If we don't do this, then some other realm's nasty KDC can\n       claim to be authenticating a client from our realm, and we'll\n       give out tickets concurring with it!\n\n       we set a flag here for checking below.\n    */\n    foreign_server = !is_local_principal(kdc_active_realm,\n                                         apreq->ticket->server);\n\n    if ((retval = krb5_auth_con_init(kdc_context, &auth_context)))\n        goto cleanup;\n\n    /* Don't use a replay cache. */\n    if ((retval = krb5_auth_con_setflags(kdc_context, auth_context, 0)))\n        goto cleanup;\n\n    if ((retval = krb5_auth_con_setaddrs(kdc_context, auth_context, NULL,\n                                         from->address)) )\n        goto cleanup_auth_context;\n\n    retval = kdc_rd_ap_req(kdc_active_realm,\n                           apreq, auth_context, &krbtgt, tgskey);\n    if (retval)\n        goto cleanup_auth_context;\n\n    /* \"invalid flag\" tickets can must be used to validate */\n    if (isflagset(ticket->enc_part2->flags, TKT_FLG_INVALID) &&\n        !isflagset(request->kdc_options, KDC_OPT_VALIDATE)) {\n        retval = KRB5KRB_AP_ERR_TKT_INVALID;\n        goto cleanup_auth_context;\n    }\n\n    if ((retval = krb5_auth_con_getrecvsubkey(kdc_context,\n                                              auth_context, subkey)))\n        goto cleanup_auth_context;\n\n    if ((retval = krb5_auth_con_getauthenticator(kdc_context, auth_context,\n                                                 &authenticator)))\n        goto cleanup_auth_context;\n\n    retval = krb5_find_authdata(kdc_context,\n                                ticket->enc_part2->authorization_data,\n                                authenticator->authorization_data,\n                                KRB5_AUTHDATA_FX_ARMOR, &authdata);\n    if (retval != 0)\n        goto cleanup_authenticator;\n    if (authdata&& authdata[0]) {\n        k5_setmsg(kdc_context, KRB5KDC_ERR_POLICY,\n                  \"ticket valid only as FAST armor\");\n        retval = KRB5KDC_ERR_POLICY;\n        krb5_free_authdata(kdc_context, authdata);\n        goto cleanup_authenticator;\n    }\n    krb5_free_authdata(kdc_context, authdata);\n\n\n    /* Check for a checksum */\n    if (!(his_cksum = authenticator->checksum)) {\n        retval = KRB5KRB_AP_ERR_INAPP_CKSUM;\n        goto cleanup_authenticator;\n    }\n\n    /* make sure the client is of proper lineage (see above) */\n    if (foreign_server &&\n        !krb5int_find_pa_data(kdc_context,\n                              request->padata, KRB5_PADATA_FOR_USER)) {\n        if (is_local_principal(kdc_active_realm,\n                               ticket->enc_part2->client)) {\n            /* someone in a foreign realm claiming to be local */\n            krb5_klog_syslog(LOG_INFO, _(\"PROCESS_TGS: failed lineage check\"));\n            retval = KRB5KDC_ERR_POLICY;\n            goto cleanup_authenticator;\n        }\n    }\n\n    /*\n     * Check application checksum vs. tgs request\n     *\n     * We try checksumming the req-body two different ways: first we\n     * try reaching into the raw asn.1 stream (if available), and\n     * checksum that directly; if that fails, then we try encoding\n     * using our local asn.1 library.\n     */\n    if (pkt && (fetch_asn1_field((unsigned char *) pkt->data,\n                                 1, 4, &scratch1) >= 0)) {\n        if (comp_cksum(kdc_context, &scratch1, ticket, his_cksum)) {\n            if (!(retval = encode_krb5_kdc_req_body(request, &scratch)))\n                retval = comp_cksum(kdc_context, scratch, ticket, his_cksum);\n            krb5_free_data(kdc_context, scratch);\n            if (retval)\n                goto cleanup_authenticator;\n        }\n    }\n\n    *pa_tgs_req = tmppa;\n    *krbtgt_ptr = krbtgt;\n    krbtgt = NULL;\n\ncleanup_authenticator:\n    krb5_free_authenticator(kdc_context, authenticator);\n\ncleanup_auth_context:\n    krb5_auth_con_free(kdc_context, auth_context);\n\ncleanup:\n    if (retval != 0) {\n        krb5_free_keyblock(kdc_context, *tgskey);\n        *tgskey = NULL;\n    }\n    if (apreq->ticket->enc_part2 != NULL) {\n        /* Steal the decrypted ticket pointer, even on error. */\n        *ticket_out = apreq->ticket;\n        apreq->ticket = NULL;\n    }\n    krb5_free_ap_req(kdc_context, apreq);\n    krb5_db_free_principal(kdc_context, krbtgt);\n    return retval;\n}\n\n/*\n * This is a KDC wrapper around krb5_rd_req_decoded_anyflag().\n *\n * We can't depend on KDB-as-keytab for handling the AP-REQ here for\n * optimization reasons: we want to minimize the number of KDB lookups.  We'll\n * need the KDB entry for the TGS principal, and the TGS key used to decrypt\n * the TGT, elsewhere in the TGS code.\n *\n * This function also implements key rollover support for kvno 0 cross-realm\n * TGTs issued by AD.\n */\nstatic\nkrb5_error_code\nkdc_rd_ap_req(kdc_realm_t *kdc_active_realm,\n              krb5_ap_req *apreq, krb5_auth_context auth_context,\n              krb5_db_entry **server, krb5_keyblock **tgskey)\n{\n    krb5_error_code     retval;\n    krb5_enctype        search_enctype = apreq->ticket->enc_part.enctype;\n    krb5_boolean        match_enctype = 1;\n    krb5_kvno           kvno;\n    size_t              tries = 3;\n\n    /*\n     * When we issue tickets we use the first key in the principals' highest\n     * kvno keyset.  For non-cross-realm krbtgt principals we want to only\n     * allow the use of the first key of the principal's keyset that matches\n     * the given kvno.\n     */\n    if (krb5_is_tgs_principal(apreq->ticket->server) &&\n        !is_cross_tgs_principal(apreq->ticket->server)) {\n        search_enctype = -1;\n        match_enctype = 0;\n    }\n\n    retval = kdc_get_server_key(kdc_context, apreq->ticket,\n                                KRB5_KDB_FLAG_ALIAS_OK, match_enctype, server,\n                                NULL, NULL);\n    if (retval)\n        return retval;\n\n    *tgskey = NULL;\n    kvno = apreq->ticket->enc_part.kvno;\n    do {\n        krb5_free_keyblock(kdc_context, *tgskey);\n        retval = find_server_key(kdc_context,\n                                 *server, search_enctype, kvno, tgskey, &kvno);\n        if (retval)\n            continue;\n\n        /* Make the TGS key available to krb5_rd_req_decoded_anyflag() */\n        retval = krb5_auth_con_setuseruserkey(kdc_context, auth_context,\n                                              *tgskey);\n        if (retval)\n            return retval;\n\n        retval = krb5_rd_req_decoded_anyflag(kdc_context, &auth_context, apreq,\n                                             apreq->ticket->server,\n                                             kdc_active_realm->realm_keytab,\n                                             NULL, NULL);\n\n        /* If the ticket was decrypted, don't try any more keys. */\n        if (apreq->ticket->enc_part2 != NULL)\n            break;\n\n    } while (retval && apreq->ticket->enc_part.kvno == 0 && kvno-- > 1 &&\n             --tries > 0);\n\n    return retval;\n}\n\n/*\n * The KDC should take the keytab associated with the realm and pass\n * that to the krb5_rd_req_decoded_anyflag(), but we still need to use\n * the service (TGS, here) key elsewhere.  This approach is faster than\n * the KDB keytab approach too.\n *\n * This is also used by do_tgs_req() for u2u auth.\n */\nkrb5_error_code\nkdc_get_server_key(krb5_context context,\n                   krb5_ticket *ticket, unsigned int flags,\n                   krb5_boolean match_enctype, krb5_db_entry **server_ptr,\n                   krb5_keyblock **key, krb5_kvno *kvno)\n{\n    krb5_error_code       retval;\n    krb5_db_entry       * server = NULL;\n    krb5_enctype          search_enctype = -1;\n    krb5_kvno             search_kvno = -1;\n\n    if (match_enctype)\n        search_enctype = ticket->enc_part.enctype;\n    if (ticket->enc_part.kvno)\n        search_kvno = ticket->enc_part.kvno;\n\n    *server_ptr = NULL;\n\n    retval = krb5_db_get_principal(context, ticket->server, flags,\n                                   &server);\n    if (retval == KRB5_KDB_NOENTRY) {\n        char *sname;\n        if (!krb5_unparse_name(context, ticket->server, &sname)) {\n            limit_string(sname);\n            krb5_klog_syslog(LOG_ERR,\n                             _(\"TGS_REQ: UNKNOWN SERVER: server='%s'\"), sname);\n            free(sname);\n        }\n        return KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n    } else if (retval)\n        return retval;\n    if (server->attributes & KRB5_KDB_DISALLOW_SVR ||\n        server->attributes & KRB5_KDB_DISALLOW_ALL_TIX) {\n        retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        goto errout;\n    }\n\n    if (key) {\n        retval = find_server_key(context, server, search_enctype, search_kvno,\n                                 key, kvno);\n        if (retval)\n            goto errout;\n    }\n    *server_ptr = server;\n    server = NULL;\n    return 0;\n\nerrout:\n    krb5_db_free_principal(context, server);\n    return retval;\n}\n\n/*\n * A utility function to get the right key from a KDB entry.  Used in handling\n * of kvno 0 TGTs, for example.\n */\nstatic\nkrb5_error_code\nfind_server_key(krb5_context context,\n                krb5_db_entry *server, krb5_enctype enctype, krb5_kvno kvno,\n                krb5_keyblock **key_out, krb5_kvno *kvno_out)\n{\n    krb5_error_code       retval;\n    krb5_key_data       * server_key;\n    krb5_keyblock       * key;\n\n    *key_out = NULL;\n    retval = krb5_dbe_find_enctype(context, server, enctype, -1,\n                                   kvno ? (krb5_int32)kvno : -1, &server_key);\n    if (retval)\n        return retval;\n    if (!server_key)\n        return KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n    if ((key = (krb5_keyblock *)malloc(sizeof *key)) == NULL)\n        return ENOMEM;\n    retval = krb5_dbe_decrypt_key_data(context, NULL, server_key,\n                                       key, NULL);\n    if (retval)\n        goto errout;\n    if (enctype != -1) {\n        krb5_boolean similar;\n        retval = krb5_c_enctype_compare(context, enctype, key->enctype,\n                                        &similar);\n        if (retval)\n            goto errout;\n        if (!similar) {\n            retval = KRB5_KDB_NO_PERMITTED_KEY;\n            goto errout;\n        }\n        key->enctype = enctype;\n    }\n    *key_out = key;\n    key = NULL;\n    if (kvno_out)\n        *kvno_out = server_key->key_data_kvno;\nerrout:\n    krb5_free_keyblock(context, key);\n    return retval;\n}\n\n/*\n * If candidate is the local TGT for realm, set *alias_out to candidate and\n * *storage_out to NULL.  Otherwise, load the local TGT into *storage_out and\n * set *alias_out to *storage_out.\n *\n * In the future we might generalize this to a small per-request principal\n * cache.  For now, it saves a load operation in the common case where the AS\n * server or TGS header ticket server is the local TGT.\n */\nkrb5_error_code\nget_local_tgt(krb5_context context, const krb5_data *realm,\n              krb5_db_entry *candidate, krb5_db_entry **alias_out,\n              krb5_db_entry **storage_out)\n{\n    krb5_error_code ret;\n    krb5_principal princ;\n    krb5_db_entry *tgt;\n\n    *alias_out = NULL;\n    *storage_out = NULL;\n\n    ret = krb5_build_principal_ext(context, &princ, realm->length, realm->data,\n                                   KRB5_TGS_NAME_SIZE, KRB5_TGS_NAME,\n                                   realm->length, realm->data, 0);\n    if (ret)\n        return ret;\n\n    if (!krb5_principal_compare(context, candidate->princ, princ)) {\n        ret = krb5_db_get_principal(context, princ, 0, &tgt);\n        if (!ret)\n            *storage_out = *alias_out = tgt;\n    } else {\n        *alias_out = candidate;\n    }\n\n    krb5_free_principal(context, princ);\n    return ret;\n}\n\n/* This probably wants to be updated if you support last_req stuff */\n\nstatic krb5_last_req_entry nolrentry = { KV5M_LAST_REQ_ENTRY, KRB5_LRQ_NONE, 0 };\nstatic krb5_last_req_entry *nolrarray[] = { &nolrentry, 0 };\n\nkrb5_error_code\nfetch_last_req_info(krb5_db_entry *dbentry, krb5_last_req_entry ***lrentry)\n{\n    *lrentry = nolrarray;\n    return 0;\n}\n\n\n/* XXX!  This is a temporary place-holder */\n\nkrb5_error_code\ncheck_hot_list(krb5_ticket *ticket)\n{\n    return 0;\n}\n\n\n/* Convert an API error code to a protocol error code. */\nint\nerrcode_to_protocol(krb5_error_code code)\n{\n    int protcode;\n\n    protcode = code - ERROR_TABLE_BASE_krb5;\n    return (protcode >= 0 && protcode <= 128) ? protcode : KRB_ERR_GENERIC;\n}\n\n/* Return -1 if the AS or TGS request is disallowed due to KDC policy on\n * anonymous tickets. */\nint\ncheck_anon(kdc_realm_t *kdc_active_realm,\n           krb5_principal client, krb5_principal server)\n{\n    /* If restrict_anon is set, reject requests from anonymous to principals\n     * other than the local TGT. */\n    if (kdc_active_realm->realm_restrict_anon &&\n        krb5_principal_compare_any_realm(kdc_context, client,\n                                         krb5_anonymous_principal()) &&\n        !krb5_principal_compare(kdc_context, server, tgs_server))\n        return -1;\n    return 0;\n}\n\n/*\n * Routines that validate a AS request; checks a lot of things.  :-)\n *\n * Returns a Kerberos protocol error number, which is _not_ the same\n * as a com_err error number!\n */\n#define AS_INVALID_OPTIONS (KDC_OPT_FORWARDED | KDC_OPT_PROXY |         \\\n                            KDC_OPT_VALIDATE | KDC_OPT_RENEW |          \\\n                            KDC_OPT_ENC_TKT_IN_SKEY | KDC_OPT_CNAME_IN_ADDL_TKT)\nint\nvalidate_as_request(kdc_realm_t *kdc_active_realm,\n                    krb5_kdc_req *request, krb5_db_entry client,\n                    krb5_db_entry server, krb5_timestamp kdc_time,\n                    const char **status, krb5_pa_data ***e_data)\n{\n    krb5_error_code ret;\n\n    /*\n     * If an option is set that is only allowed in TGS requests, complain.\n     */\n    if (request->kdc_options & AS_INVALID_OPTIONS) {\n        *status = \"INVALID AS OPTIONS\";\n        return KDC_ERR_BADOPTION;\n    }\n\n    /* The client must not be expired */\n    if (client.expiration && ts_after(kdc_time, client.expiration)) {\n        *status = \"CLIENT EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_NAME_EXP);\n    }\n\n    /* The client's password must not be expired, unless the server is\n       a KRB5_KDC_PWCHANGE_SERVICE. */\n    if (client.pw_expiration && ts_after(kdc_time, client.pw_expiration) &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"CLIENT KEY EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_KEY_EXP);\n    }\n\n    /* The server must not be expired */\n    if (server.expiration && ts_after(kdc_time, server.expiration)) {\n        *status = \"SERVICE EXPIRED\";\n        return(KDC_ERR_SERVICE_EXP);\n    }\n\n    /*\n     * If the client requires password changing, then only allow the\n     * pwchange service.\n     */\n    if (isflagset(client.attributes, KRB5_KDB_REQUIRES_PWCHANGE) &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"REQUIRED PWCHANGE\";\n        return(KDC_ERR_KEY_EXP);\n    }\n\n    /* Client and server must allow postdating tickets */\n    if ((isflagset(request->kdc_options, KDC_OPT_ALLOW_POSTDATE) ||\n         isflagset(request->kdc_options, KDC_OPT_POSTDATED)) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_POSTDATED) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_POSTDATED))) {\n        *status = \"POSTDATE NOT ALLOWED\";\n        return(KDC_ERR_CANNOT_POSTDATE);\n    }\n\n    /* Check to see if client is locked out */\n    if (isflagset(client.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"CLIENT LOCKED OUT\";\n        return(KDC_ERR_CLIENT_REVOKED);\n    }\n\n    /* Check to see if server is locked out */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"SERVICE LOCKED OUT\";\n        return(KDC_ERR_S_PRINCIPAL_UNKNOWN);\n    }\n\n    /* Check to see if server is allowed to be a service */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_SVR)) {\n        *status = \"SERVICE NOT ALLOWED\";\n        return(KDC_ERR_MUST_USE_USER2USER);\n    }\n\n    if (check_anon(kdc_active_realm, client.princ, request->server) != 0) {\n        *status = \"ANONYMOUS NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Perform KDB module policy checks. */\n    ret = krb5_db_check_policy_as(kdc_context, request, &client, &server,\n                                  kdc_time, status, e_data);\n    if (ret && ret != KRB5_PLUGIN_OP_NOTSUPP)\n        return errcode_to_protocol(ret);\n\n    return 0;\n}\n\n/*\n * Compute ticket flags based on the request, the client and server DB entry\n * (which may prohibit forwardable or proxiable tickets), and the header\n * ticket.  client may be NULL for a TGS request (although it may be set, such\n * as for an S4U2Self request).  header_enc may be NULL for an AS request.\n */\nkrb5_flags\nget_ticket_flags(krb5_flags reqflags, krb5_db_entry *client,\n                 krb5_db_entry *server, krb5_enc_tkt_part *header_enc)\n{\n    krb5_flags flags;\n\n    /* Indicate support for encrypted padata (RFC 6806), and set flags based on\n     * request options and the header ticket. */\n    flags = OPTS2FLAGS(reqflags) | TKT_FLG_ENC_PA_REP;\n    if (reqflags & KDC_OPT_POSTDATED)\n        flags |= TKT_FLG_INVALID;\n    if (header_enc != NULL)\n        flags |= COPY_TKT_FLAGS(header_enc->flags);\n    if (header_enc == NULL)\n        flags |= TKT_FLG_INITIAL;\n\n    /* For TGS requests, indicate if the service is marked ok-as-delegate. */\n    if (header_enc != NULL && (server->attributes & KRB5_KDB_OK_AS_DELEGATE))\n        flags |= TKT_FLG_OK_AS_DELEGATE;\n\n    /* Unset PROXIABLE if it is disallowed. */\n    if (client != NULL && (client->attributes & KRB5_KDB_DISALLOW_PROXIABLE))\n        flags &= ~TKT_FLG_PROXIABLE;\n    if (server->attributes & KRB5_KDB_DISALLOW_PROXIABLE)\n        flags &= ~TKT_FLG_PROXIABLE;\n    if (header_enc != NULL && !(header_enc->flags & TKT_FLG_PROXIABLE))\n        flags &= ~TKT_FLG_PROXIABLE;\n\n    /* Unset FORWARDABLE if it is disallowed. */\n    if (client != NULL && (client->attributes & KRB5_KDB_DISALLOW_FORWARDABLE))\n        flags &= ~TKT_FLG_FORWARDABLE;\n    if (server->attributes & KRB5_KDB_DISALLOW_FORWARDABLE)\n        flags &= ~TKT_FLG_FORWARDABLE;\n    if (header_enc != NULL && !(header_enc->flags & TKT_FLG_FORWARDABLE))\n        flags &= ~TKT_FLG_FORWARDABLE;\n\n    /* We don't currently handle issuing anonymous tickets based on\n     * non-anonymous ones. */\n    if (header_enc != NULL && !(header_enc->flags & TKT_FLG_ANONYMOUS))\n        flags &= ~TKT_FLG_ANONYMOUS;\n\n    return flags;\n}\n\n/* Return KRB5KDC_ERR_POLICY if indicators does not contain the required auth\n * indicators for server, ENOMEM on allocation error, 0 otherwise. */\nkrb5_error_code\ncheck_indicators(krb5_context context, krb5_db_entry *server,\n                 krb5_data *const *indicators)\n{\n    krb5_error_code ret;\n    char *str = NULL, *copy = NULL, *save, *ind;\n\n    ret = krb5_dbe_get_string(context, server, KRB5_KDB_SK_REQUIRE_AUTH, &str);\n    if (ret || str == NULL)\n        goto cleanup;\n    copy = strdup(str);\n    if (copy == NULL) {\n        ret = ENOMEM;\n        goto cleanup;\n    }\n\n    /* Look for any of the space-separated strings in indicators. */\n    ind = strtok_r(copy, \" \", &save);\n    while (ind != NULL) {\n        if (authind_contains(indicators, ind))\n            goto cleanup;\n        ind = strtok_r(NULL, \" \", &save);\n    }\n\n    ret = KRB5KDC_ERR_POLICY;\n    k5_setmsg(context, ret,\n              _(\"Required auth indicators not present in ticket: %s\"), str);\n\ncleanup:\n    krb5_dbe_free_string(context, str);\n    free(copy);\n    return ret;\n}\n\n#define ASN1_ID_CLASS   (0xc0)\n#define ASN1_ID_TYPE    (0x20)\n#define ASN1_ID_TAG     (0x1f)\n#define ASN1_CLASS_UNIV (0)\n#define ASN1_CLASS_APP  (1)\n#define ASN1_CLASS_CTX  (2)\n#define ASN1_CLASS_PRIV (3)\n#define asn1_id_constructed(x)  (x & ASN1_ID_TYPE)\n#define asn1_id_primitive(x)    (!asn1_id_constructed(x))\n#define asn1_id_class(x)        ((x & ASN1_ID_CLASS) >> 6)\n#define asn1_id_tag(x)          (x & ASN1_ID_TAG)\n\n/*\n * asn1length - return encoded length of value.\n *\n * passed a pointer into the asn.1 stream, which is updated\n * to point right after the length bits.\n *\n * returns -1 on failure.\n */\nstatic int\nasn1length(unsigned char **astream)\n{\n    int length;         /* resulting length */\n    int sublen;         /* sublengths */\n    int blen;           /* bytes of length */\n    unsigned char *p;   /* substring searching */\n\n    if (**astream & 0x80) {\n        blen = **astream & 0x7f;\n        if (blen > 3) {\n            return(-1);\n        }\n        for (++*astream, length = 0; blen; ++*astream, blen--) {\n            length = (length << 8) | **astream;\n        }\n        if (length == 0) {\n            /* indefinite length, figure out by hand */\n            p = *astream;\n            p++;\n            while (1) {\n                /* compute value length. */\n                if ((sublen = asn1length(&p)) < 0) {\n                    return(-1);\n                }\n                p += sublen;\n                /* check for termination */\n                if ((!*p++) && (!*p)) {\n                    p++;\n                    break;\n                }\n            }\n            length = p - *astream;\n        }\n    } else {\n        length = **astream;\n        ++*astream;\n    }\n    return(length);\n}\n\n/*\n * fetch_asn1_field - return raw asn.1 stream of subfield.\n *\n * this routine is passed a context-dependent tag number and \"level\" and returns\n * the size and length of the corresponding level subfield.\n *\n * levels and are numbered starting from 1.\n *\n * returns 0 on success, -1 otherwise.\n */\nint\nfetch_asn1_field(unsigned char *astream, unsigned int level,\n                 unsigned int field, krb5_data *data)\n{\n    unsigned char *estream;     /* end of stream */\n    int classes;                /* # classes seen so far this level */\n    unsigned int levels = 0;            /* levels seen so far */\n    int lastlevel = 1000;       /* last level seen */\n    int length;                 /* various lengths */\n    int tag;                    /* tag number */\n    unsigned char savelen;      /* saved length of our field */\n\n    classes = -1;\n    /* we assume that the first identifier/length will tell us\n       how long the entire stream is. */\n    astream++;\n    estream = astream;\n    if ((length = asn1length(&astream)) < 0) {\n        return(-1);\n    }\n    estream += length;\n    /* search down the stream, checking identifiers.  we process identifiers\n       until we hit the \"level\" we want, and then process that level for our\n       subfield, always making sure we don't go off the end of the stream.  */\n    while (astream < estream) {\n        if (!asn1_id_constructed(*astream)) {\n            return(-1);\n        }\n        if (asn1_id_class(*astream) == ASN1_CLASS_CTX) {\n            if ((tag = (int)asn1_id_tag(*astream)) <= lastlevel) {\n                levels++;\n                classes = -1;\n            }\n            lastlevel = tag;\n            if (levels == level) {\n                /* in our context-dependent class, is this the one we're looking for ? */\n                if (tag == (int)field) {\n                    /* return length and data */\n                    astream++;\n                    savelen = *astream;\n                    if ((length = asn1length(&astream)) < 0) {\n                        return(-1);\n                    }\n                    data->length = length;\n                    /* if the field length is indefinite, we will have to subtract two\n                       (terminating octets) from the length returned since we don't want\n                       to pass any info from the \"wrapper\" back.  asn1length will always return\n                       the *total* length of the field, not just what's contained in it */\n                    if ((savelen & 0xff) == 0x80) {\n                        data->length -=2 ;\n                    }\n                    data->data = (char *)astream;\n                    return(0);\n                } else if (tag <= classes) {\n                    /* we've seen this class before, something must be wrong */\n                    return(-1);\n                } else {\n                    classes = tag;\n                }\n            }\n        }\n        /* if we're not on our level yet, process this value.  otherwise skip over it */\n        astream++;\n        if ((length = asn1length(&astream)) < 0) {\n            return(-1);\n        }\n        if (levels == level) {\n            astream += length;\n        }\n    }\n    return(-1);\n}\n\n/* Return true if we believe server can support enctype as a session key. */\nstatic krb5_boolean\ndbentry_supports_enctype(kdc_realm_t *kdc_active_realm, krb5_db_entry *server,\n                         krb5_enctype enctype)\n{\n    krb5_error_code     retval;\n    krb5_key_data       *datap;\n    char                *etypes_str = NULL;\n    krb5_enctype        default_enctypes[1] = { 0 };\n    krb5_enctype        *etypes = NULL;\n    krb5_boolean        in_list;\n\n    /* Look up the supported session key enctypes list in the KDB. */\n    retval = krb5_dbe_get_string(kdc_context, server,\n                                 KRB5_KDB_SK_SESSION_ENCTYPES,\n                                 &etypes_str);\n    if (retval == 0 && etypes_str != NULL && *etypes_str != '\\0') {\n        /* Pass a fake profile key for tracing of unrecognized tokens. */\n        retval = krb5int_parse_enctype_list(kdc_context, \"KDB-session_etypes\",\n                                            etypes_str, default_enctypes,\n                                            &etypes);\n        if (retval == 0 && etypes != NULL && etypes[0]) {\n            in_list = k5_etypes_contains(etypes, enctype);\n            free(etypes_str);\n            free(etypes);\n            return in_list;\n        }\n        /* Fall through on error or empty list */\n    }\n    free(etypes_str);\n    free(etypes);\n\n    /* If configured to, assume every server without a session_enctypes\n     * attribute supports DES_CBC_CRC. */\n    if (kdc_active_realm->realm_assume_des_crc_sess &&\n        enctype == ENCTYPE_DES_CBC_CRC)\n        return TRUE;\n\n    /* Due to an ancient interop problem, assume nothing supports des-cbc-md5\n     * unless there's a session_enctypes explicitly saying that it does. */\n    if (enctype == ENCTYPE_DES_CBC_MD5)\n        return FALSE;\n\n    /* Assume the server supports any enctype it has a long-term key for. */\n    return !krb5_dbe_find_enctype(kdc_context, server, enctype, -1, 0, &datap);\n}\n\n/*\n * This function returns the keytype which should be selected for the\n * session key.  It is based on the ordered list which the user\n * requested, and what the KDC and the application server can support.\n */\nkrb5_enctype\nselect_session_keytype(kdc_realm_t *kdc_active_realm, krb5_db_entry *server,\n                       int nktypes, krb5_enctype *ktype)\n{\n    int         i;\n\n    for (i = 0; i < nktypes; i++) {\n        if (!krb5_c_valid_enctype(ktype[i]))\n            continue;\n\n        if (!krb5_is_permitted_enctype(kdc_context, ktype[i]))\n            continue;\n\n        if (dbentry_supports_enctype(kdc_active_realm, server, ktype[i]))\n            return ktype[i];\n    }\n\n    return 0;\n}\n\n/*\n * Limit strings to a \"reasonable\" length to prevent crowding out of\n * other useful information in the log entry\n */\n#define NAME_LENGTH_LIMIT 128\n\nvoid limit_string(char *name)\n{\n    int     i;\n\n    if (!name)\n        return;\n\n    if (strlen(name) < NAME_LENGTH_LIMIT)\n        return;\n\n    i = NAME_LENGTH_LIMIT-4;\n    name[i++] = '.';\n    name[i++] = '.';\n    name[i++] = '.';\n    name[i] = '\\0';\n    return;\n}\n\n/*\n * L10_2 = log10(2**x), rounded up; log10(2) ~= 0.301.\n */\n#define L10_2(x) ((int)(((x * 301) + 999) / 1000))\n\n/*\n * Max length of sprintf(\"%ld\") for an int of type T; includes leading\n * minus sign and terminating NUL.\n */\n#define D_LEN(t) (L10_2(sizeof(t) * CHAR_BIT) + 2)\n\nvoid\nktypes2str(char *s, size_t len, int nktypes, krb5_enctype *ktype)\n{\n    int i;\n    char stmp[D_LEN(krb5_enctype) + 1];\n    char *p;\n\n    if (nktypes < 0\n        || len < (sizeof(\" etypes {...}\") + D_LEN(int))) {\n        *s = '\\0';\n        return;\n    }\n\n    snprintf(s, len, \"%d etypes {\", nktypes);\n    for (i = 0; i < nktypes; i++) {\n        snprintf(stmp, sizeof(stmp), \"%s%ld\", i ? \" \" : \"\", (long)ktype[i]);\n        if (strlen(s) + strlen(stmp) + sizeof(\"}\") > len)\n            break;\n        strlcat(s, stmp, len);\n    }\n    if (i < nktypes) {\n        /*\n         * We broke out of the loop. Try to truncate the list.\n         */\n        p = s + strlen(s);\n        while (p - s + sizeof(\"...}\") > len) {\n            while (p > s && *p != ' ' && *p != '{')\n                *p-- = '\\0';\n            if (p > s && *p == ' ') {\n                *p-- = '\\0';\n                continue;\n            }\n        }\n        strlcat(s, \"...\", len);\n    }\n    strlcat(s, \"}\", len);\n    return;\n}\n\nvoid\nrep_etypes2str(char *s, size_t len, krb5_kdc_rep *rep)\n{\n    char stmp[sizeof(\"ses=\") + D_LEN(krb5_enctype)];\n\n    if (len < (3 * D_LEN(krb5_enctype)\n               + sizeof(\"etypes {rep= tkt= ses=}\"))) {\n        *s = '\\0';\n        return;\n    }\n\n    snprintf(s, len, \"etypes {rep=%ld\", (long)rep->enc_part.enctype);\n\n    if (rep->ticket != NULL) {\n        snprintf(stmp, sizeof(stmp),\n                 \" tkt=%ld\", (long)rep->ticket->enc_part.enctype);\n        strlcat(s, stmp, len);\n    }\n\n    if (rep->ticket != NULL\n        && rep->ticket->enc_part2 != NULL\n        && rep->ticket->enc_part2->session != NULL) {\n        snprintf(stmp, sizeof(stmp), \" ses=%ld\",\n                 (long)rep->ticket->enc_part2->session->enctype);\n        strlcat(s, stmp, len);\n    }\n    strlcat(s, \"}\", len);\n    return;\n}\n\nstatic krb5_error_code\nverify_for_user_checksum(krb5_context context,\n                         krb5_keyblock *key,\n                         krb5_pa_for_user *req)\n{\n    krb5_error_code             code;\n    int                         i;\n    krb5_int32                  name_type;\n    char                        *p;\n    krb5_data                   data;\n    krb5_boolean                valid = FALSE;\n\n    if (!krb5_c_is_keyed_cksum(req->cksum.checksum_type)) {\n        return KRB5KRB_AP_ERR_INAPP_CKSUM;\n    }\n\n    /*\n     * Checksum is over name type and string components of\n     * client principal name and auth_package.\n     */\n    data.length = 4;\n    for (i = 0; i < krb5_princ_size(context, req->user); i++) {\n        data.length += krb5_princ_component(context, req->user, i)->length;\n    }\n    data.length += krb5_princ_realm(context, req->user)->length;\n    data.length += req->auth_package.length;\n\n    p = data.data = malloc(data.length);\n    if (data.data == NULL) {\n        return ENOMEM;\n    }\n\n    name_type = krb5_princ_type(context, req->user);\n    p[0] = (name_type >> 0 ) & 0xFF;\n    p[1] = (name_type >> 8 ) & 0xFF;\n    p[2] = (name_type >> 16) & 0xFF;\n    p[3] = (name_type >> 24) & 0xFF;\n    p += 4;\n\n    for (i = 0; i < krb5_princ_size(context, req->user); i++) {\n        if (krb5_princ_component(context, req->user, i)->length > 0) {\n            memcpy(p, krb5_princ_component(context, req->user, i)->data,\n                   krb5_princ_component(context, req->user, i)->length);\n        }\n        p += krb5_princ_component(context, req->user, i)->length;\n    }\n\n    if (krb5_princ_realm(context, req->user)->length > 0) {\n        memcpy(p, krb5_princ_realm(context, req->user)->data,\n               krb5_princ_realm(context, req->user)->length);\n    }\n    p += krb5_princ_realm(context, req->user)->length;\n\n    if (req->auth_package.length > 0)\n        memcpy(p, req->auth_package.data, req->auth_package.length);\n    p += req->auth_package.length;\n\n    code = krb5_c_verify_checksum(context,\n                                  key,\n                                  KRB5_KEYUSAGE_APP_DATA_CKSUM,\n                                  &data,\n                                  &req->cksum,\n                                  &valid);\n\n    if (code == 0 && valid == FALSE)\n        code = KRB5KRB_AP_ERR_MODIFIED;\n\n    free(data.data);\n\n    return code;\n}\n\n/*\n * Legacy protocol transition (Windows 2003 and above)\n */\nstatic krb5_error_code\nkdc_process_for_user(kdc_realm_t *kdc_active_realm,\n                     krb5_pa_data *pa_data,\n                     krb5_keyblock *tgs_session,\n                     krb5_pa_s4u_x509_user **s4u_x509_user,\n                     const char **status)\n{\n    krb5_error_code             code;\n    krb5_pa_for_user            *for_user;\n    krb5_data                   req_data;\n\n    req_data.length = pa_data->length;\n    req_data.data = (char *)pa_data->contents;\n\n    code = decode_krb5_pa_for_user(&req_data, &for_user);\n    if (code) {\n        *status = \"DECODE_PA_FOR_USER\";\n        return code;\n    }\n\n    code = verify_for_user_checksum(kdc_context, tgs_session, for_user);\n    if (code) {\n        *status = \"INVALID_S4U2SELF_CHECKSUM\";\n        krb5_free_pa_for_user(kdc_context, for_user);\n        return code;\n    }\n\n    *s4u_x509_user = calloc(1, sizeof(krb5_pa_s4u_x509_user));\n    if (*s4u_x509_user == NULL) {\n        krb5_free_pa_for_user(kdc_context, for_user);\n        return ENOMEM;\n    }\n\n    (*s4u_x509_user)->user_id.user = for_user->user;\n    for_user->user = NULL;\n    krb5_free_pa_for_user(kdc_context, for_user);\n\n    return 0;\n}\n\nstatic krb5_error_code\nverify_s4u_x509_user_checksum(krb5_context context,\n                              krb5_keyblock *key,\n                              krb5_data *req_data,\n                              krb5_int32 kdc_req_nonce,\n                              krb5_pa_s4u_x509_user *req)\n{\n    krb5_error_code             code;\n    krb5_data                   scratch;\n    krb5_boolean                valid = FALSE;\n\n    if (enctype_requires_etype_info_2(key->enctype) &&\n        !krb5_c_is_keyed_cksum(req->cksum.checksum_type))\n        return KRB5KRB_AP_ERR_INAPP_CKSUM;\n\n    if (req->user_id.nonce != kdc_req_nonce)\n        return KRB5KRB_AP_ERR_MODIFIED;\n\n    /*\n     * Verify checksum over the encoded userid. If that fails,\n     * re-encode, and verify that. This is similar to the\n     * behaviour in kdc_process_tgs_req().\n     */\n    if (fetch_asn1_field((unsigned char *)req_data->data, 1, 0, &scratch) < 0)\n        return ASN1_PARSE_ERROR;\n\n    code = krb5_c_verify_checksum(context,\n                                  key,\n                                  KRB5_KEYUSAGE_PA_S4U_X509_USER_REQUEST,\n                                  &scratch,\n                                  &req->cksum,\n                                  &valid);\n    if (code != 0)\n        return code;\n\n    if (valid == FALSE) {\n        krb5_data *data;\n\n        code = encode_krb5_s4u_userid(&req->user_id, &data);\n        if (code != 0)\n            return code;\n\n        code = krb5_c_verify_checksum(context,\n                                      key,\n                                      KRB5_KEYUSAGE_PA_S4U_X509_USER_REQUEST,\n                                      data,\n                                      &req->cksum,\n                                      &valid);\n\n        krb5_free_data(context, data);\n\n        if (code != 0)\n            return code;\n    }\n\n    return valid ? 0 : KRB5KRB_AP_ERR_MODIFIED;\n}\n\n/*\n * New protocol transition request (Windows 2008 and above)\n */\nstatic krb5_error_code\nkdc_process_s4u_x509_user(krb5_context context,\n                          krb5_kdc_req *request,\n                          krb5_pa_data *pa_data,\n                          krb5_keyblock *tgs_subkey,\n                          krb5_keyblock *tgs_session,\n                          krb5_pa_s4u_x509_user **s4u_x509_user,\n                          const char **status)\n{\n    krb5_error_code             code;\n    krb5_data                   req_data;\n\n    req_data.length = pa_data->length;\n    req_data.data = (char *)pa_data->contents;\n\n    code = decode_krb5_pa_s4u_x509_user(&req_data, s4u_x509_user);\n    if (code) {\n        *status = \"DECODE_PA_S4U_X509_USER\";\n        return code;\n    }\n\n    code = verify_s4u_x509_user_checksum(context,\n                                         tgs_subkey ? tgs_subkey :\n                                         tgs_session,\n                                         &req_data,\n                                         request->nonce, *s4u_x509_user);\n\n    if (code) {\n        *status = \"INVALID_S4U2SELF_CHECKSUM\";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return code;\n    }\n\n    if (krb5_princ_size(context, (*s4u_x509_user)->user_id.user) == 0 ||\n        (*s4u_x509_user)->user_id.subject_cert.length != 0) {\n        *status = \"INVALID_S4U2SELF_REQUEST\";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n    }\n\n    return 0;\n}\n\nkrb5_error_code\nkdc_make_s4u2self_rep(krb5_context context,\n                      krb5_keyblock *tgs_subkey,\n                      krb5_keyblock *tgs_session,\n                      krb5_pa_s4u_x509_user *req_s4u_user,\n                      krb5_kdc_rep *reply,\n                      krb5_enc_kdc_rep_part *reply_encpart)\n{\n    krb5_error_code             code;\n    krb5_data                   *der_user_id = NULL, *der_s4u_x509_user = NULL;\n    krb5_pa_s4u_x509_user       rep_s4u_user;\n    krb5_pa_data                *pa;\n    krb5_enctype                enctype;\n    krb5_keyusage               usage;\n\n    memset(&rep_s4u_user, 0, sizeof(rep_s4u_user));\n\n    rep_s4u_user.user_id.nonce   = req_s4u_user->user_id.nonce;\n    rep_s4u_user.user_id.user    = req_s4u_user->user_id.user;\n    rep_s4u_user.user_id.options =\n        req_s4u_user->user_id.options & KRB5_S4U_OPTS_USE_REPLY_KEY_USAGE;\n\n    code = encode_krb5_s4u_userid(&rep_s4u_user.user_id, &der_user_id);\n    if (code != 0)\n        goto cleanup;\n\n    if (req_s4u_user->user_id.options & KRB5_S4U_OPTS_USE_REPLY_KEY_USAGE)\n        usage = KRB5_KEYUSAGE_PA_S4U_X509_USER_REPLY;\n    else\n        usage = KRB5_KEYUSAGE_PA_S4U_X509_USER_REQUEST;\n\n    code = krb5_c_make_checksum(context, req_s4u_user->cksum.checksum_type,\n                                tgs_subkey != NULL ? tgs_subkey : tgs_session,\n                                usage, der_user_id, &rep_s4u_user.cksum);\n    if (code != 0)\n        goto cleanup;\n\n    code = encode_krb5_pa_s4u_x509_user(&rep_s4u_user, &der_s4u_x509_user);\n    if (code != 0)\n        goto cleanup;\n\n    /* Add a padata element, stealing memory from der_s4u_x509_user. */\n    code = alloc_pa_data(KRB5_PADATA_S4U_X509_USER, 0, &pa);\n    if (code != 0)\n        goto cleanup;\n    pa->length = der_s4u_x509_user->length;\n    pa->contents = (uint8_t *)der_s4u_x509_user->data;\n    der_s4u_x509_user->data = NULL;\n    /* add_pa_data_element() claims pa on success or failure. */\n    code = add_pa_data_element(&reply->padata, pa);\n    if (code != 0)\n        goto cleanup;\n\n    if (tgs_subkey != NULL)\n        enctype = tgs_subkey->enctype;\n    else\n        enctype = tgs_session->enctype;\n\n    /*\n     * Owing to a bug in Windows, unkeyed checksums were used for older\n     * enctypes, including rc4-hmac. A forthcoming workaround for this\n     * includes the checksum bytes in the encrypted padata.\n     */\n    if ((req_s4u_user->user_id.options & KRB5_S4U_OPTS_USE_REPLY_KEY_USAGE) &&\n        enctype_requires_etype_info_2(enctype) == FALSE) {\n        code = alloc_pa_data(KRB5_PADATA_S4U_X509_USER,\n                             req_s4u_user->cksum.length +\n                             rep_s4u_user.cksum.length, &pa);\n        if (code != 0)\n            goto cleanup;\n        memcpy(pa->contents,\n               req_s4u_user->cksum.contents, req_s4u_user->cksum.length);\n        memcpy(&pa->contents[req_s4u_user->cksum.length],\n               rep_s4u_user.cksum.contents, rep_s4u_user.cksum.length);\n\n        /* add_pa_data_element() claims pa on success or failure. */\n        code = add_pa_data_element(&reply_encpart->enc_padata, pa);\n        if (code != 0)\n            goto cleanup;\n    }\n\ncleanup:\n    if (rep_s4u_user.cksum.contents != NULL)\n        krb5_free_checksum_contents(context, &rep_s4u_user.cksum);\n    krb5_free_data(context, der_user_id);\n    krb5_free_data(context, der_s4u_x509_user);\n\n    return code;\n}\n\n/*\n * Protocol transition (S4U2Self)\n */\nkrb5_error_code\nkdc_process_s4u2self_req(kdc_realm_t *kdc_active_realm,\n                         krb5_kdc_req *request,\n                         krb5_const_principal client_princ,\n                         krb5_const_principal header_srv_princ,\n                         krb5_boolean issuing_referral,\n                         const krb5_db_entry *server,\n                         krb5_keyblock *tgs_subkey,\n                         krb5_keyblock *tgs_session,\n                         krb5_timestamp kdc_time,\n                         krb5_pa_s4u_x509_user **s4u_x509_user,\n                         krb5_db_entry **princ_ptr,\n                         const char **status)\n{\n    krb5_error_code             code;\n    krb5_boolean                is_local_tgt;\n    krb5_pa_data                *pa_data;\n    int                         flags;\n    krb5_db_entry               *princ;\n\n    *princ_ptr = NULL;\n\n    pa_data = krb5int_find_pa_data(kdc_context,\n                                   request->padata, KRB5_PADATA_S4U_X509_USER);\n    if (pa_data != NULL) {\n        code = kdc_process_s4u_x509_user(kdc_context,\n                                         request,\n                                         pa_data,\n                                         tgs_subkey,\n                                         tgs_session,\n                                         s4u_x509_user,\n                                         status);\n        if (code != 0)\n            return code;\n    } else {\n        pa_data = krb5int_find_pa_data(kdc_context,\n                                       request->padata, KRB5_PADATA_FOR_USER);\n        if (pa_data != NULL) {\n            code = kdc_process_for_user(kdc_active_realm,\n                                        pa_data,\n                                        tgs_session,\n                                        s4u_x509_user,\n                                        status);\n            if (code != 0)\n                return code;\n        } else\n            return 0;\n    }\n\n    /*\n     * We need to compare the client name in the TGT with the requested\n     * server name. Supporting server name aliases without assuming a\n     * global name service makes this difficult to do.\n     *\n     * The comparison below handles the following cases (note that the\n     * term \"principal name\" below excludes the realm).\n     *\n     * (1) The requested service is a host-based service with two name\n     *     components, in which case we assume the principal name to\n     *     contain sufficient qualifying information. The realm is\n     *     ignored for the purpose of comparison.\n     *\n     * (2) The requested service name is an enterprise principal name:\n     *     the service principal name is compared with the unparsed\n     *     form of the client name (including its realm).\n     *\n     * (3) The requested service is some other name type: an exact\n     *     match is required.\n     *\n     * An alternative would be to look up the server once again with\n     * FLAG_CANONICALIZE | FLAG_CLIENT_REFERRALS_ONLY set, do an exact\n     * match between the returned name and client_princ. However, this\n     * assumes that the client set FLAG_CANONICALIZE when requesting\n     * the TGT and that we have a global name service.\n     */\n    flags = 0;\n    switch (krb5_princ_type(kdc_context, request->server)) {\n    case KRB5_NT_SRV_HST:                   /* (1) */\n        if (krb5_princ_size(kdc_context, request->server) == 2)\n            flags |= KRB5_PRINCIPAL_COMPARE_IGNORE_REALM;\n        break;\n    case KRB5_NT_ENTERPRISE_PRINCIPAL:      /* (2) */\n        flags |= KRB5_PRINCIPAL_COMPARE_ENTERPRISE;\n        break;\n    default:                                /* (3) */\n        break;\n    }\n\n    if (!krb5_principal_compare_flags(kdc_context,\n                                      request->server,\n                                      client_princ,\n                                      flags)) {\n        *status = \"INVALID_S4U2SELF_REQUEST\";\n        return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN; /* match Windows error code */\n    }\n\n    /*\n     * Protocol transition is mutually exclusive with renew/forward/etc\n     * as well as user-to-user and constrained delegation. This check\n     * is also made in validate_as_request().\n     *\n     * We can assert from this check that the header ticket was a TGT, as\n     * that is validated previously in validate_tgs_request().\n     */\n    if (request->kdc_options & AS_INVALID_OPTIONS) {\n        *status = \"INVALID AS OPTIONS\";\n        return KRB5KDC_ERR_BADOPTION;\n    }\n\n    /*\n     * Valid S4U2Self requests can occur in the following combinations:\n     *\n     * (1) local TGT, local user, local server\n     * (2) cross TGT, local user, issuing referral\n     * (3) cross TGT, non-local user, issuing referral\n     * (4) cross TGT, non-local user, local server\n     *\n     * The first case is for a single-realm S4U2Self scenario; the second,\n     * third, and fourth cases are for the initial, intermediate (if any), and\n     * final cross-realm requests in a multi-realm scenario.\n     */\n\n    is_local_tgt = !is_cross_tgs_principal(header_srv_princ);\n    if (is_local_tgt && issuing_referral) {\n        /* The requesting server appears to no longer exist, and we found\n         * a referral instead.  Treat this as a server lookup failure. */\n        *status = \"LOOKING_UP_SERVER\";\n        return KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n    }\n\n    /*\n     * Do not attempt to lookup principals in foreign realms.\n     */\n    if (is_local_principal(kdc_active_realm,\n                           (*s4u_x509_user)->user_id.user)) {\n        krb5_db_entry no_server;\n        krb5_pa_data **e_data = NULL;\n\n        if (!is_local_tgt && !issuing_referral) {\n            /* A local server should not need a cross-realm TGT to impersonate\n             * a local principal. */\n            *status = \"NOT_CROSS_REALM_REQUEST\";\n            return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN; /* match Windows error */\n        }\n\n        code = krb5_db_get_principal(kdc_context,\n                                     (*s4u_x509_user)->user_id.user,\n                                     KRB5_KDB_FLAG_INCLUDE_PAC, &princ);\n        if (code == KRB5_KDB_NOENTRY) {\n            *status = \"UNKNOWN_S4U2SELF_PRINCIPAL\";\n            return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n        } else if (code) {\n            *status = \"LOOKING_UP_S4U2SELF_PRINCIPAL\";\n            return code; /* caller can free for_user */\n        }\n\n        memset(&no_server, 0, sizeof(no_server));\n\n        /* Ignore password expiration and needchange attributes (as Windows\n         * does), since S4U2Self is not password authentication. */\n        princ->pw_expiration = 0;\n        clear(princ->attributes, KRB5_KDB_REQUIRES_PWCHANGE);\n\n        code = validate_as_request(kdc_active_realm, request, *princ,\n                                   no_server, kdc_time, status, &e_data);\n        if (code) {\n            krb5_db_free_principal(kdc_context, princ);\n            krb5_free_pa_data(kdc_context, e_data);\n            return code;\n        }\n\n        *princ_ptr = princ;\n    } else if (is_local_tgt) {\n        /*\n         * The server is asking to impersonate a principal from another realm,\n         * using a local TGT.  It should instead ask that principal's realm and\n         * follow referrals back to us.\n         */\n        *status = \"S4U2SELF_CLIENT_NOT_OURS\";\n        return KRB5KDC_ERR_POLICY; /* match Windows error */\n    }\n\n    return 0;\n}\n\nstatic krb5_error_code\ncheck_allowed_to_delegate_to(krb5_context context, krb5_const_principal client,\n                             const krb5_db_entry *server,\n                             krb5_const_principal proxy)\n{\n    /* Can't get a TGT (otherwise it would be unconstrained delegation) */\n    if (krb5_is_tgs_principal(proxy))\n        return KRB5KDC_ERR_POLICY;\n\n    /* Must be in same realm */\n    if (!krb5_realm_compare(context, server->princ, proxy))\n        return KRB5KDC_ERR_POLICY;\n\n    return krb5_db_check_allowed_to_delegate(context, client, server, proxy);\n}\n\nkrb5_error_code\nkdc_process_s4u2proxy_req(kdc_realm_t *kdc_active_realm,\n                          krb5_kdc_req *request,\n                          const krb5_enc_tkt_part *t2enc,\n                          const krb5_db_entry *server,\n                          krb5_const_principal server_princ,\n                          krb5_const_principal proxy_princ,\n                          const char **status)\n{\n    krb5_error_code errcode;\n\n    /*\n     * Constrained delegation is mutually exclusive with renew/forward/etc.\n     * We can assert from this check that the header ticket was a TGT, as\n     * that is validated previously in validate_tgs_request().\n     */\n    if (request->kdc_options & (NON_TGT_OPTION | KDC_OPT_ENC_TKT_IN_SKEY)) {\n        *status = \"INVALID_S4U2PROXY_OPTIONS\";\n        return KRB5KDC_ERR_BADOPTION;\n    }\n\n    /* Ensure that evidence ticket server matches TGT client */\n    if (!krb5_principal_compare(kdc_context,\n                                server->princ, /* after canon */\n                                server_princ)) {\n        *status = \"EVIDENCE_TICKET_MISMATCH\";\n        return KRB5KDC_ERR_SERVER_NOMATCH;\n    }\n\n    if (!isflagset(t2enc->flags, TKT_FLG_FORWARDABLE)) {\n        *status = \"EVIDENCE_TKT_NOT_FORWARDABLE\";\n        return KRB5_TKT_NOT_FORWARDABLE;\n    }\n\n    /* Backend policy check */\n    errcode = check_allowed_to_delegate_to(kdc_context,\n                                           t2enc->client,\n                                           server,\n                                           proxy_princ);\n    if (errcode) {\n        *status = \"NOT_ALLOWED_TO_DELEGATE\";\n        return errcode;\n    }\n\n    return 0;\n}\n\nkrb5_error_code\nkdc_check_transited_list(kdc_realm_t *kdc_active_realm,\n                         const krb5_data *trans,\n                         const krb5_data *realm1,\n                         const krb5_data *realm2)\n{\n    krb5_error_code             code;\n\n    /* Check against the KDB module.  Treat this answer as authoritative if the\n     * method is supported and doesn't explicitly pass control. */\n    code = krb5_db_check_transited_realms(kdc_context, trans, realm1, realm2);\n    if (code != KRB5_PLUGIN_OP_NOTSUPP && code != KRB5_PLUGIN_NO_HANDLE)\n        return code;\n\n    /* Check using krb5.conf [capaths] or hierarchical relationships. */\n    return krb5_check_transited_list(kdc_context, trans, realm1, realm2);\n}\n\nkrb5_error_code\nvalidate_transit_path(krb5_context context,\n                      krb5_const_principal client,\n                      krb5_db_entry *server,\n                      krb5_db_entry *header_srv)\n{\n    /* Incoming */\n    if (isflagset(server->attributes, KRB5_KDB_XREALM_NON_TRANSITIVE)) {\n        return KRB5KDC_ERR_PATH_NOT_ACCEPTED;\n    }\n\n    /* Outgoing */\n    if (isflagset(header_srv->attributes, KRB5_KDB_XREALM_NON_TRANSITIVE) &&\n        (!krb5_principal_compare(context, server->princ, header_srv->princ) ||\n         !krb5_realm_compare(context, client, header_srv->princ))) {\n        return KRB5KDC_ERR_PATH_NOT_ACCEPTED;\n    }\n\n    return 0;\n}\n\nkrb5_boolean\nenctype_requires_etype_info_2(krb5_enctype enctype)\n{\n    switch(enctype) {\n    case ENCTYPE_DES_CBC_CRC:\n    case ENCTYPE_DES_CBC_MD4:\n    case ENCTYPE_DES_CBC_MD5:\n    case ENCTYPE_DES3_CBC_SHA1:\n    case ENCTYPE_DES3_CBC_RAW:\n    case ENCTYPE_ARCFOUR_HMAC:\n    case ENCTYPE_ARCFOUR_HMAC_EXP :\n        return 0;\n    default:\n        return krb5_c_valid_enctype(enctype);\n    }\n}\n\n/* Allocate a pa-data entry with an uninitialized buffer of size len. */\nkrb5_error_code\nalloc_pa_data(krb5_preauthtype pa_type, size_t len, krb5_pa_data **out)\n{\n    krb5_pa_data *pa;\n    uint8_t *buf = NULL;\n\n    *out = NULL;\n    if (len > 0) {\n        buf = malloc(len);\n        if (buf == NULL)\n            return ENOMEM;\n    }\n    pa = malloc(sizeof(*pa));\n    if (pa == NULL) {\n        free(buf);\n        return ENOMEM;\n    }\n    pa->magic = KV5M_PA_DATA;\n    pa->pa_type = pa_type;\n    pa->length = len;\n    pa->contents = buf;\n    *out = pa;\n    return 0;\n}\n\n/* Add pa to list, claiming its memory.  Free pa on failure. */\nkrb5_error_code\nadd_pa_data_element(krb5_pa_data ***list, krb5_pa_data *pa)\n{\n    size_t count;\n    krb5_pa_data **newlist;\n\n    for (count = 0; *list != NULL && (*list)[count] != NULL; count++);\n\n    newlist = realloc(*list, (count + 2) * sizeof(*newlist));\n    if (newlist == NULL) {\n        free(pa->contents);\n        free(pa);\n        return ENOMEM;\n    }\n    newlist[count] = pa;\n    newlist[count + 1] = NULL;\n    *list = newlist;\n    return 0;\n}\n\nvoid\nkdc_get_ticket_endtime(kdc_realm_t *kdc_active_realm,\n                       krb5_timestamp starttime,\n                       krb5_timestamp endtime,\n                       krb5_timestamp till,\n                       krb5_db_entry *client,\n                       krb5_db_entry *server,\n                       krb5_timestamp *out_endtime)\n{\n    krb5_timestamp until;\n    krb5_deltat life;\n\n    if (till == 0)\n        till = kdc_infinity;\n\n    until = ts_min(till, endtime);\n\n    /* Determine the requested lifetime, capped at the maximum valid time\n     * interval. */\n    life = ts_delta(until, starttime);\n    if (ts_after(until, starttime) && life < 0)\n        life = INT32_MAX;\n\n    if (client != NULL && client->max_life != 0)\n        life = min(life, client->max_life);\n    if (server->max_life != 0)\n        life = min(life, server->max_life);\n    if (kdc_active_realm->realm_maxlife != 0)\n        life = min(life, kdc_active_realm->realm_maxlife);\n\n    *out_endtime = ts_incr(starttime, life);\n}\n\n/*\n * Set tkt->renew_till to the requested renewable lifetime as modified by\n * policy.  Set the TKT_FLG_RENEWABLE flag if we set a nonzero renew_till.\n * client and tgt may be NULL.\n */\nvoid\nkdc_get_ticket_renewtime(kdc_realm_t *realm, krb5_kdc_req *request,\n                         krb5_enc_tkt_part *tgt, krb5_db_entry *client,\n                         krb5_db_entry *server, krb5_enc_tkt_part *tkt)\n{\n    krb5_timestamp rtime, max_rlife;\n\n    clear(tkt->flags, TKT_FLG_RENEWABLE);\n    tkt->times.renew_till = 0;\n\n    /* Don't issue renewable tickets if the client or server don't allow it,\n     * or if this is a TGS request and the TGT isn't renewable. */\n    if (server->attributes & KRB5_KDB_DISALLOW_RENEWABLE)\n        return;\n    if (client != NULL && (client->attributes & KRB5_KDB_DISALLOW_RENEWABLE))\n        return;\n    if (tgt != NULL && !(tgt->flags & TKT_FLG_RENEWABLE))\n        return;\n\n    /* Determine the requested renewable time. */\n    if (isflagset(request->kdc_options, KDC_OPT_RENEWABLE))\n        rtime = request->rtime ? request->rtime : kdc_infinity;\n    else if (isflagset(request->kdc_options, KDC_OPT_RENEWABLE_OK) &&\n             ts_after(request->till, tkt->times.endtime))\n        rtime = request->till;\n    else\n        return;\n\n    /* Truncate it to the allowable renewable time. */\n    if (tgt != NULL)\n        rtime = ts_min(rtime, tgt->times.renew_till);\n    max_rlife = min(server->max_renewable_life, realm->realm_maxrlife);\n    if (client != NULL)\n        max_rlife = min(max_rlife, client->max_renewable_life);\n    rtime = ts_min(rtime, ts_incr(tkt->times.starttime, max_rlife));\n\n    /* If the client only specified renewable-ok, don't issue a renewable\n     * ticket unless the truncated renew time exceeds the ticket end time. */\n    if (!isflagset(request->kdc_options, KDC_OPT_RENEWABLE) &&\n        !ts_after(rtime, tkt->times.endtime))\n        return;\n\n    setflag(tkt->flags, TKT_FLG_RENEWABLE);\n    tkt->times.renew_till = rtime;\n}\n\n/**\n * Handle protected negotiation of FAST using enc_padata\n * - If ENCPADATA_REQ_ENC_PA_REP is present, then:\n * - Return ENCPADATA_REQ_ENC_PA_REP with checksum of AS-REQ from client\n * - Include PADATA_FX_FAST in the enc_padata to indicate FAST\n * @pre @c out_enc_padata has space for at least two more padata\n * @param index in/out index into @c out_enc_padata for next item\n */\nkrb5_error_code\nkdc_handle_protected_negotiation(krb5_context context,\n                                 krb5_data *req_pkt, krb5_kdc_req *request,\n                                 const krb5_keyblock *reply_key,\n                                 krb5_pa_data ***out_enc_padata)\n{\n    krb5_error_code retval = 0;\n    krb5_checksum checksum;\n    krb5_data *der_cksum = NULL;\n    krb5_pa_data *pa, *pa_in;\n\n    memset(&checksum, 0, sizeof(checksum));\n\n    pa_in = krb5int_find_pa_data(context, request->padata,\n                                 KRB5_ENCPADATA_REQ_ENC_PA_REP);\n    if (pa_in == NULL)\n        return 0;\n\n    /* Compute and encode a checksum over the AS-REQ. */\n    retval = krb5_c_make_checksum(context, 0, reply_key, KRB5_KEYUSAGE_AS_REQ,\n                                  req_pkt, &checksum);\n    if (retval != 0)\n        goto cleanup;\n    retval = encode_krb5_checksum(&checksum, &der_cksum);\n    if (retval != 0)\n        goto cleanup;\n\n    /* Add a pa-data element to the list, stealing memory from der_cksum. */\n    retval = alloc_pa_data(KRB5_ENCPADATA_REQ_ENC_PA_REP, 0, &pa);\n    if (retval)\n        goto cleanup;\n    pa->length = der_cksum->length;\n    pa->contents = (uint8_t *)der_cksum->data;\n    der_cksum->data = NULL;\n    /* add_pa_data_element() claims pa on success or failure. */\n    retval = add_pa_data_element(out_enc_padata, pa);\n    if (retval)\n        goto cleanup;\n\n    /* Add a zero-length PA-FX-FAST element to the list. */\n    retval = alloc_pa_data(KRB5_PADATA_FX_FAST, 0, &pa);\n    if (retval)\n        goto cleanup;\n    /* add_pa_data_element() claims pa on success or failure. */\n    retval = add_pa_data_element(out_enc_padata, pa);\n\ncleanup:\n    krb5_free_checksum_contents(context, &checksum);\n    krb5_free_data(context, der_cksum);\n    return retval;\n}\n\n/*\n * Although the KDC doesn't call this function directly,\n * process_tcp_connection_read() in net-server.c does call it.\n */\nkrb5_error_code\nmake_toolong_error (void *handle, krb5_data **out)\n{\n    krb5_error errpkt;\n    krb5_error_code retval;\n    krb5_data *scratch;\n    struct server_handle *h = handle;\n\n    retval = krb5_us_timeofday(h->kdc_err_context,\n                               &errpkt.stime, &errpkt.susec);\n    if (retval)\n        return retval;\n    errpkt.error = KRB_ERR_FIELD_TOOLONG;\n    errpkt.server = h->kdc_realmlist[0]->realm_tgsprinc;\n    errpkt.client = NULL;\n    errpkt.cusec = 0;\n    errpkt.ctime = 0;\n    errpkt.text.length = 0;\n    errpkt.text.data = 0;\n    errpkt.e_data.length = 0;\n    errpkt.e_data.data = 0;\n    scratch = malloc(sizeof(*scratch));\n    if (scratch == NULL)\n        return ENOMEM;\n    retval = krb5_mk_error(h->kdc_err_context, &errpkt, scratch);\n    if (retval) {\n        free(scratch);\n        return retval;\n    }\n\n    *out = scratch;\n    return 0;\n}\n\nvoid reset_for_hangup(void *ctx)\n{\n    int k;\n    struct server_handle *h = ctx;\n\n    for (k = 0; k < h->kdc_numrealms; k++)\n        krb5_db_refresh_config(h->kdc_realmlist[k]->realm_context);\n}\n", "/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* lib/krb5/krb/s4u_creds.c */\n/*\n * Copyright (C) 2009 by the Massachusetts Institute of Technology.\n * All rights reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n\n#include \"k5-int.h\"\n#include \"int-proto.h\"\n\n/* Convert ticket flags to necessary KDC options */\n#define FLAGS2OPTS(flags) (flags & KDC_TKT_COMMON_MASK)\n\n/*\n * Implements S4U2Self, by which a service can request a ticket to\n * itself on behalf of an arbitrary principal.\n */\n\nstatic krb5_error_code\nkrb5_get_as_key_noop(\n    krb5_context context,\n    krb5_principal client,\n    krb5_enctype etype,\n    krb5_prompter_fct prompter,\n    void *prompter_data,\n    krb5_data *salt,\n    krb5_data *params,\n    krb5_keyblock *as_key,\n    void *gak_data,\n    k5_response_items *ritems)\n{\n    /* force a hard error, we don't actually have the key */\n    return KRB5_PREAUTH_FAILED;\n}\n\nstatic krb5_error_code\ns4u_identify_user(krb5_context context,\n                  krb5_creds *in_creds,\n                  krb5_data *subject_cert,\n                  krb5_principal *canon_user)\n{\n    krb5_error_code code;\n    krb5_preauthtype ptypes[1] = { KRB5_PADATA_S4U_X509_USER };\n    krb5_creds creds;\n    int use_master = 0;\n    krb5_get_init_creds_opt *opts = NULL;\n    krb5_principal_data client;\n    krb5_s4u_userid userid;\n\n    *canon_user = NULL;\n\n    if (in_creds->client == NULL && subject_cert == NULL) {\n        return EINVAL;\n    }\n\n    if (in_creds->client != NULL &&\n        in_creds->client->type != KRB5_NT_ENTERPRISE_PRINCIPAL) {\n        int anonymous;\n\n        anonymous = krb5_principal_compare(context, in_creds->client,\n                                           krb5_anonymous_principal());\n\n        return krb5_copy_principal(context,\n                                   anonymous ? in_creds->server\n                                   : in_creds->client,\n                                   canon_user);\n    }\n\n    memset(&creds, 0, sizeof(creds));\n\n    memset(&userid, 0, sizeof(userid));\n    if (subject_cert != NULL)\n        userid.subject_cert = *subject_cert;\n\n    code = krb5_get_init_creds_opt_alloc(context, &opts);\n    if (code != 0)\n        goto cleanup;\n    krb5_get_init_creds_opt_set_tkt_life(opts, 15);\n    krb5_get_init_creds_opt_set_renew_life(opts, 0);\n    krb5_get_init_creds_opt_set_forwardable(opts, 0);\n    krb5_get_init_creds_opt_set_proxiable(opts, 0);\n    krb5_get_init_creds_opt_set_canonicalize(opts, 1);\n    krb5_get_init_creds_opt_set_preauth_list(opts, ptypes, 1);\n\n    if (in_creds->client != NULL) {\n        client = *in_creds->client;\n        client.realm = in_creds->server->realm;\n    } else {\n        client.magic = KV5M_PRINCIPAL;\n        client.realm = in_creds->server->realm;\n        /* should this be NULL, empty or a fixed string? XXX */\n        client.data = NULL;\n        client.length = 0;\n        client.type = KRB5_NT_ENTERPRISE_PRINCIPAL;\n    }\n\n    code = k5_get_init_creds(context, &creds, &client, NULL, NULL, 0, NULL,\n                             opts, krb5_get_as_key_noop, &userid, &use_master,\n                             NULL);\n    if (!code || code == KRB5_PREAUTH_FAILED || code == KRB5KDC_ERR_KEY_EXP) {\n        *canon_user = userid.user;\n        userid.user = NULL;\n        code = 0;\n    }\n\ncleanup:\n    krb5_free_cred_contents(context, &creds);\n    if (opts != NULL)\n        krb5_get_init_creds_opt_free(context, opts);\n    if (userid.user != NULL)\n        krb5_free_principal(context, userid.user);\n\n    return code;\n}\n\nstatic krb5_error_code\nmake_pa_for_user_checksum(krb5_context context,\n                          krb5_keyblock *key,\n                          krb5_pa_for_user *req,\n                          krb5_checksum *cksum)\n{\n    krb5_error_code code;\n    int i;\n    char *p;\n    krb5_data data;\n\n    data.length = 4;\n    for (i = 0; i < req->user->length; i++)\n        data.length += req->user->data[i].length;\n    data.length += req->user->realm.length;\n    data.length += req->auth_package.length;\n\n    p = data.data = malloc(data.length);\n    if (data.data == NULL)\n        return ENOMEM;\n\n    p[0] = (req->user->type >> 0) & 0xFF;\n    p[1] = (req->user->type >> 8) & 0xFF;\n    p[2] = (req->user->type >> 16) & 0xFF;\n    p[3] = (req->user->type >> 24) & 0xFF;\n    p += 4;\n\n    for (i = 0; i < req->user->length; i++) {\n        if (req->user->data[i].length > 0)\n            memcpy(p, req->user->data[i].data, req->user->data[i].length);\n        p += req->user->data[i].length;\n    }\n\n    if (req->user->realm.length > 0)\n        memcpy(p, req->user->realm.data, req->user->realm.length);\n    p += req->user->realm.length;\n\n    if (req->auth_package.length > 0)\n        memcpy(p, req->auth_package.data, req->auth_package.length);\n\n    /* Per spec, use hmac-md5 checksum regardless of key type. */\n    code = krb5_c_make_checksum(context, CKSUMTYPE_HMAC_MD5_ARCFOUR, key,\n                                KRB5_KEYUSAGE_APP_DATA_CKSUM, &data,\n                                cksum);\n\n    free(data.data);\n\n    return code;\n}\n\nstatic krb5_error_code\nbuild_pa_for_user(krb5_context context,\n                  krb5_creds *tgt,\n                  krb5_s4u_userid *userid,\n                  krb5_pa_data **out_padata)\n{\n    krb5_error_code code;\n    krb5_pa_data *padata;\n    krb5_pa_for_user for_user;\n    krb5_data *for_user_data = NULL;\n    char package[] = \"Kerberos\";\n\n    if (userid->user == NULL)\n        return EINVAL;\n\n    memset(&for_user, 0, sizeof(for_user));\n    for_user.user = userid->user;\n    for_user.auth_package.data = package;\n    for_user.auth_package.length = sizeof(package) - 1;\n\n    code = make_pa_for_user_checksum(context, &tgt->keyblock,\n                                     &for_user, &for_user.cksum);\n    if (code != 0)\n        goto cleanup;\n\n    code = encode_krb5_pa_for_user(&for_user, &for_user_data);\n    if (code != 0)\n        goto cleanup;\n\n    padata = malloc(sizeof(*padata));\n    if (padata == NULL) {\n        code = ENOMEM;\n        goto cleanup;\n    }\n\n    padata->magic = KV5M_PA_DATA;\n    padata->pa_type = KRB5_PADATA_FOR_USER;\n    padata->length = for_user_data->length;\n    padata->contents = (krb5_octet *)for_user_data->data;\n\n    free(for_user_data);\n    for_user_data = NULL;\n\n    *out_padata = padata;\n\ncleanup:\n    if (for_user.cksum.contents != NULL)\n        krb5_free_checksum_contents(context, &for_user.cksum);\n    krb5_free_data(context, for_user_data);\n\n    return code;\n}\n\n/*\n * This function is invoked by krb5int_make_tgs_request_ext() just before the\n * request is encoded; it gives us access to the nonce and subkey without\n * requiring them to be generated by the caller.\n */\nstatic krb5_error_code\nbuild_pa_s4u_x509_user(krb5_context context,\n                       krb5_keyblock *subkey,\n                       krb5_kdc_req *tgsreq,\n                       void *gcvt_data)\n{\n    krb5_error_code code;\n    krb5_pa_s4u_x509_user *s4u_user = (krb5_pa_s4u_x509_user *)gcvt_data;\n    krb5_data *data = NULL;\n    krb5_pa_data **padata;\n    krb5_cksumtype cksumtype;\n    int i;\n\n    assert(s4u_user->cksum.contents == NULL);\n\n    s4u_user->user_id.nonce = tgsreq->nonce;\n\n    code = encode_krb5_s4u_userid(&s4u_user->user_id, &data);\n    if (code != 0)\n        goto cleanup;\n\n    /* [MS-SFU] 2.2.2: unusual to say the least, but enc_padata secures it */\n    if (subkey->enctype == ENCTYPE_ARCFOUR_HMAC ||\n        subkey->enctype == ENCTYPE_ARCFOUR_HMAC_EXP) {\n        cksumtype = CKSUMTYPE_RSA_MD4;\n    } else {\n        code = krb5int_c_mandatory_cksumtype(context, subkey->enctype,\n                                             &cksumtype);\n    }\n    if (code != 0)\n        goto cleanup;\n\n    code = krb5_c_make_checksum(context, cksumtype, subkey,\n                                KRB5_KEYUSAGE_PA_S4U_X509_USER_REQUEST, data,\n                                &s4u_user->cksum);\n    if (code != 0)\n        goto cleanup;\n\n    krb5_free_data(context, data);\n    data = NULL;\n\n    code = encode_krb5_pa_s4u_x509_user(s4u_user, &data);\n    if (code != 0)\n        goto cleanup;\n\n    assert(tgsreq->padata != NULL);\n\n    for (i = 0; tgsreq->padata[i] != NULL; i++)\n        ;\n\n    padata = realloc(tgsreq->padata,\n                     (i + 2) * sizeof(krb5_pa_data *));\n    if (padata == NULL) {\n        code = ENOMEM;\n        goto cleanup;\n    }\n    tgsreq->padata = padata;\n\n    padata[i] = malloc(sizeof(krb5_pa_data));\n    if (padata[i] == NULL) {\n        code = ENOMEM;\n        goto cleanup;\n    }\n    padata[i]->magic = KV5M_PA_DATA;\n    padata[i]->pa_type = KRB5_PADATA_S4U_X509_USER;\n    padata[i]->length = data->length;\n    padata[i]->contents = (krb5_octet *)data->data;\n\n    padata[i + 1] = NULL;\n\n    free(data);\n    data = NULL;\n\ncleanup:\n    if (code != 0 && s4u_user->cksum.contents != NULL) {\n        krb5_free_checksum_contents(context, &s4u_user->cksum);\n        s4u_user->cksum.contents = NULL;\n    }\n    krb5_free_data(context, data);\n\n    return code;\n}\n\nstatic krb5_error_code\nverify_s4u2self_reply(krb5_context context,\n                      krb5_keyblock *subkey,\n                      krb5_pa_s4u_x509_user *req_s4u_user,\n                      krb5_pa_data **rep_padata,\n                      krb5_pa_data **enc_padata)\n{\n    krb5_error_code code;\n    krb5_pa_data *rep_s4u_padata, *enc_s4u_padata;\n    krb5_pa_s4u_x509_user *rep_s4u_user = NULL;\n    krb5_data data, *datap = NULL;\n    krb5_keyusage usage;\n    krb5_boolean valid;\n    krb5_boolean not_newer;\n\n    assert(req_s4u_user != NULL);\n\n    switch (subkey->enctype) {\n    case ENCTYPE_DES_CBC_CRC:\n    case ENCTYPE_DES_CBC_MD4:\n    case ENCTYPE_DES_CBC_MD5:\n    case ENCTYPE_DES3_CBC_SHA1:\n    case ENCTYPE_DES3_CBC_RAW:\n    case ENCTYPE_ARCFOUR_HMAC:\n    case ENCTYPE_ARCFOUR_HMAC_EXP :\n        not_newer = TRUE;\n        break;\n    default:\n        not_newer = FALSE;\n        break;\n    }\n\n    enc_s4u_padata = krb5int_find_pa_data(context,\n                                          enc_padata,\n                                          KRB5_PADATA_S4U_X509_USER);\n\n    /* XXX this will break newer enctypes with a MIT 1.7 KDC */\n    rep_s4u_padata = krb5int_find_pa_data(context,\n                                          rep_padata,\n                                          KRB5_PADATA_S4U_X509_USER);\n    if (rep_s4u_padata == NULL) {\n        if (not_newer == FALSE || enc_s4u_padata != NULL)\n            return KRB5_KDCREP_MODIFIED;\n        else\n            return 0;\n    }\n\n    data.length = rep_s4u_padata->length;\n    data.data = (char *)rep_s4u_padata->contents;\n\n    code = decode_krb5_pa_s4u_x509_user(&data, &rep_s4u_user);\n    if (code != 0)\n        goto cleanup;\n\n    if (rep_s4u_user->user_id.nonce != req_s4u_user->user_id.nonce) {\n        code = KRB5_KDCREP_MODIFIED;\n        goto cleanup;\n    }\n\n    code = encode_krb5_s4u_userid(&rep_s4u_user->user_id, &datap);\n    if (code != 0)\n        goto cleanup;\n\n    if (rep_s4u_user->user_id.options & KRB5_S4U_OPTS_USE_REPLY_KEY_USAGE)\n        usage = KRB5_KEYUSAGE_PA_S4U_X509_USER_REPLY;\n    else\n        usage = KRB5_KEYUSAGE_PA_S4U_X509_USER_REQUEST;\n\n    code = krb5_c_verify_checksum(context, subkey, usage, datap,\n                                  &rep_s4u_user->cksum, &valid);\n    if (code != 0)\n        goto cleanup;\n    if (valid == FALSE) {\n        code = KRB5_KDCREP_MODIFIED;\n        goto cleanup;\n    }\n\n    /*\n     * KDCs that support KRB5_S4U_OPTS_USE_REPLY_KEY_USAGE also return\n     * S4U enc_padata for older (pre-AES) encryption types only.\n     */\n    if (not_newer) {\n        if (enc_s4u_padata == NULL) {\n            if (rep_s4u_user->user_id.options &\n                KRB5_S4U_OPTS_USE_REPLY_KEY_USAGE) {\n                code = KRB5_KDCREP_MODIFIED;\n                goto cleanup;\n            }\n        } else {\n            if (enc_s4u_padata->length !=\n                req_s4u_user->cksum.length + rep_s4u_user->cksum.length) {\n                code = KRB5_KDCREP_MODIFIED;\n                goto cleanup;\n            }\n            if (memcmp(enc_s4u_padata->contents,\n                       req_s4u_user->cksum.contents,\n                       req_s4u_user->cksum.length) ||\n                memcmp(&enc_s4u_padata->contents[req_s4u_user->cksum.length],\n                       rep_s4u_user->cksum.contents,\n                       rep_s4u_user->cksum.length)) {\n                code = KRB5_KDCREP_MODIFIED;\n                goto cleanup;\n            }\n        }\n    } else if (!krb5_c_is_keyed_cksum(rep_s4u_user->cksum.checksum_type)) {\n        code = KRB5KRB_AP_ERR_INAPP_CKSUM;\n        goto cleanup;\n    }\n\ncleanup:\n    krb5_free_pa_s4u_x509_user(context, rep_s4u_user);\n    krb5_free_data(context, datap);\n\n    return code;\n}\n\n/* Unparse princ and re-parse it as an enterprise principal. */\nstatic krb5_error_code\nconvert_to_enterprise(krb5_context context, krb5_principal princ,\n                      krb5_principal *eprinc_out)\n{\n    krb5_error_code code;\n    char *str;\n\n    *eprinc_out = NULL;\n    code = krb5_unparse_name(context, princ, &str);\n    if (code != 0)\n        return code;\n    code = krb5_parse_name_flags(context, str,\n                                 KRB5_PRINCIPAL_PARSE_ENTERPRISE |\n                                 KRB5_PRINCIPAL_PARSE_IGNORE_REALM,\n                                 eprinc_out);\n    krb5_free_unparsed_name(context, str);\n    return code;\n}\n\nstatic krb5_error_code\nkrb5_get_self_cred_from_kdc(krb5_context context,\n                            krb5_flags options,\n                            krb5_ccache ccache,\n                            krb5_creds *in_creds,\n                            krb5_data *subject_cert,\n                            krb5_data *user_realm,\n                            krb5_creds **out_creds)\n{\n    krb5_error_code code;\n    krb5_principal tgs = NULL, eprinc = NULL;\n    krb5_principal_data sprinc;\n    krb5_creds tgtq, s4u_creds, *tgt = NULL, *tgtptr;\n    krb5_creds *referral_tgts[KRB5_REFERRAL_MAXHOPS];\n    krb5_pa_s4u_x509_user s4u_user;\n    int referral_count = 0, i;\n    krb5_flags kdcopt;\n\n    memset(&tgtq, 0, sizeof(tgtq));\n    memset(referral_tgts, 0, sizeof(referral_tgts));\n    *out_creds = NULL;\n\n    memset(&s4u_user, 0, sizeof(s4u_user));\n\n    if (in_creds->client != NULL && in_creds->client->length > 0) {\n        if (in_creds->client->type == KRB5_NT_ENTERPRISE_PRINCIPAL) {\n            code = krb5_build_principal_ext(context,\n                                            &s4u_user.user_id.user,\n                                            user_realm->length,\n                                            user_realm->data,\n                                            in_creds->client->data[0].length,\n                                            in_creds->client->data[0].data,\n                                            0);\n            if (code != 0)\n                goto cleanup;\n            s4u_user.user_id.user->type = KRB5_NT_ENTERPRISE_PRINCIPAL;\n        } else {\n            code = krb5_copy_principal(context,\n                                       in_creds->client,\n                                       &s4u_user.user_id.user);\n            if (code != 0)\n                goto cleanup;\n        }\n    } else {\n        code = krb5_build_principal_ext(context, &s4u_user.user_id.user,\n                                        user_realm->length,\n                                        user_realm->data);\n        if (code != 0)\n            goto cleanup;\n        s4u_user.user_id.user->type = KRB5_NT_ENTERPRISE_PRINCIPAL;\n    }\n    if (subject_cert != NULL)\n        s4u_user.user_id.subject_cert = *subject_cert;\n    s4u_user.user_id.options = KRB5_S4U_OPTS_USE_REPLY_KEY_USAGE;\n\n    /* First, acquire a TGT to the user's realm. */\n    code = krb5int_tgtname(context, user_realm, &in_creds->server->realm,\n                           &tgs);\n    if (code != 0)\n        goto cleanup;\n\n    tgtq.client = in_creds->server;\n    tgtq.server = tgs;\n\n    code = krb5_get_credentials(context, options, ccache, &tgtq, &tgt);\n    if (code != 0)\n        goto cleanup;\n\n    tgtptr = tgt;\n\n    /* Convert the server principal to an enterprise principal, for use with\n     * foreign realms. */\n    code = convert_to_enterprise(context, in_creds->server, &eprinc);\n    if (code != 0)\n        goto cleanup;\n\n    /* Make a shallow copy of in_creds with client pointing to the server\n     * principal.  We will set s4u_creds.server for each request. */\n    s4u_creds = *in_creds;\n    s4u_creds.client = in_creds->server;\n\n    /* Then, walk back the referral path to S4U2Self for user */\n    kdcopt = 0;\n    if (options & KRB5_GC_CANONICALIZE)\n        kdcopt |= KDC_OPT_CANONICALIZE;\n    if (options & KRB5_GC_FORWARDABLE)\n        kdcopt |= KDC_OPT_FORWARDABLE;\n    if (options & KRB5_GC_NO_TRANSIT_CHECK)\n        kdcopt |= KDC_OPT_DISABLE_TRANSITED_CHECK;\n\n    for (referral_count = 0;\n         referral_count < KRB5_REFERRAL_MAXHOPS;\n         referral_count++)\n    {\n        krb5_pa_data **in_padata = NULL;\n        krb5_pa_data **out_padata = NULL;\n        krb5_pa_data **enc_padata = NULL;\n        krb5_keyblock *subkey = NULL;\n\n        if (s4u_user.user_id.user != NULL && s4u_user.user_id.user->length) {\n            in_padata = calloc(2, sizeof(krb5_pa_data *));\n            if (in_padata == NULL) {\n                code = ENOMEM;\n                goto cleanup;\n            }\n            code = build_pa_for_user(context,\n                                     tgtptr,\n                                     &s4u_user.user_id, &in_padata[0]);\n            if (code != 0) {\n                krb5_free_pa_data(context, in_padata);\n                goto cleanup;\n            }\n        }\n\n        if (data_eq(tgtptr->server->data[1], in_creds->server->realm)) {\n            /* When asking the server realm, use the real principal. */\n            s4u_creds.server = in_creds->server;\n        } else {\n            /* When asking a foreign realm, use the enterprise principal, with\n             * the realm set to the TGS realm. */\n            sprinc = *eprinc;\n            sprinc.realm = tgtptr->server->data[1];\n            s4u_creds.server = &sprinc;\n        }\n\n        code = krb5_get_cred_via_tkt_ext(context, tgtptr,\n                                         KDC_OPT_CANONICALIZE |\n                                         FLAGS2OPTS(tgtptr->ticket_flags) |\n                                         kdcopt,\n                                         tgtptr->addresses,\n                                         in_padata, &s4u_creds,\n                                         build_pa_s4u_x509_user, &s4u_user,\n                                         &out_padata, &enc_padata,\n                                         out_creds, &subkey);\n        if (code != 0) {\n            krb5_free_checksum_contents(context, &s4u_user.cksum);\n            krb5_free_pa_data(context, in_padata);\n            goto cleanup;\n        }\n\n        code = verify_s4u2self_reply(context, subkey, &s4u_user,\n                                     out_padata, enc_padata);\n\n        krb5_free_checksum_contents(context, &s4u_user.cksum);\n        krb5_free_pa_data(context, in_padata);\n        krb5_free_pa_data(context, out_padata);\n        krb5_free_pa_data(context, enc_padata);\n        krb5_free_keyblock(context, subkey);\n\n        if (code != 0)\n            goto cleanup;\n\n        if (krb5_principal_compare(context,\n                                   in_creds->server,\n                                   (*out_creds)->server)) {\n            code = 0;\n            goto cleanup;\n        } else if (IS_TGS_PRINC((*out_creds)->server)) {\n            krb5_data *r1 = &tgtptr->server->data[1];\n            krb5_data *r2 = &(*out_creds)->server->data[1];\n\n            if (data_eq(*r1, *r2)) {\n                krb5_free_creds(context, *out_creds);\n                *out_creds = NULL;\n                code = KRB5_ERR_HOST_REALM_UNKNOWN;\n                break;\n            }\n            for (i = 0; i < referral_count; i++) {\n                if (krb5_principal_compare(context,\n                                           (*out_creds)->server,\n                                           referral_tgts[i]->server)) {\n                    code = KRB5_KDC_UNREACH;\n                    goto cleanup;\n                }\n            }\n\n            tgtptr = *out_creds;\n            referral_tgts[referral_count] = *out_creds;\n            *out_creds = NULL;\n        } else {\n            krb5_free_creds(context, *out_creds);\n            *out_creds = NULL;\n            code = KRB5KRB_AP_WRONG_PRINC; /* XXX */\n            break;\n        }\n    }\n\ncleanup:\n    for (i = 0; i < KRB5_REFERRAL_MAXHOPS; i++) {\n        if (referral_tgts[i] != NULL)\n            krb5_free_creds(context, referral_tgts[i]);\n    }\n    krb5_free_principal(context, tgs);\n    krb5_free_principal(context, eprinc);\n    krb5_free_creds(context, tgt);\n    krb5_free_principal(context, s4u_user.user_id.user);\n    krb5_free_checksum_contents(context, &s4u_user.cksum);\n\n    return code;\n}\n\nkrb5_error_code KRB5_CALLCONV\nkrb5_get_credentials_for_user(krb5_context context, krb5_flags options,\n                              krb5_ccache ccache, krb5_creds *in_creds,\n                              krb5_data *subject_cert,\n                              krb5_creds **out_creds)\n{\n    krb5_error_code code;\n    krb5_principal realm = NULL;\n\n    *out_creds = NULL;\n\n    if (options & KRB5_GC_CONSTRAINED_DELEGATION) {\n        code = EINVAL;\n        goto cleanup;\n    }\n\n    if (in_creds->client != NULL) {\n        /* Uncanonicalised check */\n        code = krb5_get_credentials(context, options | KRB5_GC_CACHED,\n                                    ccache, in_creds, out_creds);\n        if (code != KRB5_CC_NOTFOUND && code != KRB5_CC_NOT_KTYPE)\n            goto cleanup;\n\n        if ((options & KRB5_GC_CACHED) && !(options & KRB5_GC_CANONICALIZE))\n            goto cleanup;\n    }\n\n    code = s4u_identify_user(context, in_creds, subject_cert, &realm);\n    if (code != 0)\n        goto cleanup;\n\n    if (in_creds->client != NULL &&\n        in_creds->client->type == KRB5_NT_ENTERPRISE_PRINCIPAL) {\n        /* Post-canonicalisation check for enterprise principals */\n        krb5_creds mcreds = *in_creds;\n        mcreds.client = realm;\n        code = krb5_get_credentials(context, options | KRB5_GC_CACHED,\n                                    ccache, &mcreds, out_creds);\n        if ((code != KRB5_CC_NOTFOUND && code != KRB5_CC_NOT_KTYPE)\n            || (options & KRB5_GC_CACHED))\n            goto cleanup;\n    }\n\n    code = krb5_get_self_cred_from_kdc(context, options, ccache, in_creds,\n                                       subject_cert, &realm->realm, out_creds);\n    if (code != 0)\n        goto cleanup;\n\n    assert(*out_creds != NULL);\n\n    if ((options & KRB5_GC_NO_STORE) == 0) {\n        code = krb5_cc_store_cred(context, ccache, *out_creds);\n        if (code != 0)\n            goto cleanup;\n    }\n\ncleanup:\n    if (code != 0 && *out_creds != NULL) {\n        krb5_free_creds(context, *out_creds);\n        *out_creds = NULL;\n    }\n\n    krb5_free_principal(context, realm);\n\n    return code;\n}\n\n/*\n * Exported API for constrained delegation (S4U2Proxy).\n *\n * This is preferable to using krb5_get_credentials directly because\n * it can perform some additional checks.\n */\nkrb5_error_code KRB5_CALLCONV\nkrb5_get_credentials_for_proxy(krb5_context context,\n                               krb5_flags options,\n                               krb5_ccache ccache,\n                               krb5_creds *in_creds,\n                               krb5_ticket *evidence_tkt,\n                               krb5_creds **out_creds)\n{\n    krb5_error_code code;\n    krb5_creds mcreds;\n    krb5_creds *ncreds = NULL;\n    krb5_flags fields;\n    krb5_data *evidence_tkt_data = NULL;\n    krb5_creds s4u_creds;\n\n    *out_creds = NULL;\n\n    if (in_creds == NULL || in_creds->client == NULL ||\n        evidence_tkt == NULL || evidence_tkt->enc_part2 == NULL) {\n        code = EINVAL;\n        goto cleanup;\n    }\n\n    /*\n     * Caller should have set in_creds->client to match evidence\n     * ticket client\n     */\n    if (!krb5_principal_compare(context, evidence_tkt->enc_part2->client,\n                                in_creds->client)) {\n        code = EINVAL;\n        goto cleanup;\n    }\n\n    if ((evidence_tkt->enc_part2->flags & TKT_FLG_FORWARDABLE) == 0) {\n        code = KRB5_TKT_NOT_FORWARDABLE;\n        goto cleanup;\n    }\n\n    code = krb5int_construct_matching_creds(context, options, in_creds,\n                                            &mcreds, &fields);\n    if (code != 0)\n        goto cleanup;\n\n    ncreds = calloc(1, sizeof(*ncreds));\n    if (ncreds == NULL) {\n        code = ENOMEM;\n        goto cleanup;\n    }\n    ncreds->magic = KV5M_CRED;\n\n    code = krb5_cc_retrieve_cred(context, ccache, fields, &mcreds, ncreds);\n    if (code != 0) {\n        free(ncreds);\n        ncreds = in_creds;\n    } else {\n        *out_creds = ncreds;\n    }\n\n    if ((code != KRB5_CC_NOTFOUND && code != KRB5_CC_NOT_KTYPE)\n        || options & KRB5_GC_CACHED)\n        goto cleanup;\n\n    code = encode_krb5_ticket(evidence_tkt, &evidence_tkt_data);\n    if (code != 0)\n        goto cleanup;\n\n    s4u_creds = *in_creds;\n    s4u_creds.client = evidence_tkt->server;\n    s4u_creds.second_ticket = *evidence_tkt_data;\n\n    code = krb5_get_credentials(context,\n                                options | KRB5_GC_CONSTRAINED_DELEGATION,\n                                ccache,\n                                &s4u_creds,\n                                out_creds);\n    if (code != 0)\n        goto cleanup;\n\n    /*\n     * Check client name because we couldn't compare that inside\n     * krb5_get_credentials() (enc_part2 is unavailable in clear)\n     */\n    if (!krb5_principal_compare(context,\n                                evidence_tkt->enc_part2->client,\n                                (*out_creds)->client)) {\n        code = KRB5_KDCREP_MODIFIED;\n        goto cleanup;\n    }\n\ncleanup:\n    if (*out_creds != NULL && code != 0) {\n        krb5_free_creds(context, *out_creds);\n        *out_creds = NULL;\n    }\n    if (evidence_tkt_data != NULL)\n        krb5_free_data(context, evidence_tkt_data);\n\n    return code;\n}\n", "from k5test import *\n\nrealm = K5Realm(create_host=False, get_creds=False)\nusercache = 'FILE:' + os.path.join(realm.testdir, 'usercache')\nstoragecache = 'FILE:' + os.path.join(realm.testdir, 'save')\n\n# Create two service principals with keys in the default keytab.\nservice1 = 'service/1@%s' % realm.realm\nrealm.addprinc(service1)\nrealm.extract_keytab(service1, realm.keytab)\nservice2 = 'service/2@%s' % realm.realm\nrealm.addprinc(service2)\nrealm.extract_keytab(service2, realm.keytab)\n\npuser = 'p:' + realm.user_princ\npservice1 = 'p:' + service1\npservice2 = 'p:' + service2\n\n# Get forwardable creds for service1 in the default cache.\nrealm.kinit(service1, None, ['-f', '-k'])\n\n# Try S4U2Self for user with a restricted password.\nrealm.run([kadminl, 'modprinc', '+needchange', realm.user_princ])\nrealm.run(['./t_s4u', 'e:user', '-'])\nrealm.run([kadminl, 'modprinc', '-needchange',\n          '-pwexpire', '1/1/2000', realm.user_princ])\nrealm.run(['./t_s4u', 'e:user', '-'])\nrealm.run([kadminl, 'modprinc', '-pwexpire', 'never', realm.user_princ])\n\n# Try krb5 -> S4U2Proxy with forwardable user creds.  This should fail\n# at the S4U2Proxy step since the DB2 back end currently has no\n# support for allowing it.\nrealm.kinit(realm.user_princ, password('user'), ['-f', '-c', usercache])\noutput = realm.run(['./t_s4u2proxy_krb5', usercache, storagecache, '-',\n                    pservice1, pservice2], expected_code=1)\nif ('auth1: ' + realm.user_princ not in output or\n    'NOT_ALLOWED_TO_DELEGATE' not in output):\n    fail('krb5 -> s4u2proxy')\n\n# Again with SPNEGO.\noutput = realm.run(['./t_s4u2proxy_krb5', '--spnego', usercache, storagecache,\n                    '-', pservice1, pservice2],\n                   expected_code=1)\nif ('auth1: ' + realm.user_princ not in output or\n    'NOT_ALLOWED_TO_DELEGATE' not in output):\n    fail('krb5 -> s4u2proxy (SPNEGO)')\n\n# Try krb5 -> S4U2Proxy without forwardable user creds.  This should\n# result in no delegated credential being created by\n# accept_sec_context.\nrealm.kinit(realm.user_princ, password('user'), ['-c', usercache])\nrealm.run(['./t_s4u2proxy_krb5', usercache, storagecache, pservice1,\n           pservice1, pservice2], expected_msg='no credential delegated')\n\n# Try S4U2Self.  Ask for an S4U2Proxy step; this won't happen because\n# service/1 isn't allowed to get a forwardable S4U2Self ticket.\noutput = realm.run(['./t_s4u', puser, pservice2])\nif ('Warning: no delegated cred handle' not in output or\n    'Source name:\\t' + realm.user_princ not in output):\n    fail('s4u2self')\noutput = realm.run(['./t_s4u', '--spnego', puser, pservice2])\nif ('Warning: no delegated cred handle' not in output or\n    'Source name:\\t' + realm.user_princ not in output):\n    fail('s4u2self (SPNEGO)')\n\n# Correct that problem and try again.  As above, the S4U2Proxy step\n# won't actually succeed since we don't support that in DB2.\nrealm.run([kadminl, 'modprinc', '+ok_to_auth_as_delegate', service1])\nrealm.run(['./t_s4u', puser, pservice2], expected_code=1,\n          expected_msg='NOT_ALLOWED_TO_DELEGATE')\n\n# Again with SPNEGO.  This uses SPNEGO for the initial authentication,\n# but still uses krb5 for S4U2Proxy--the delegated cred is returned as\n# a krb5 cred, not a SPNEGO cred, and t_s4u uses the delegated cred\n# directly rather than saving and reacquiring it.\nrealm.run(['./t_s4u', '--spnego', puser, pservice2], expected_code=1,\n          expected_msg='NOT_ALLOWED_TO_DELEGATE')\n\nrealm.stop()\n\n# Set up a realm using the test KDB module so that we can do\n# successful S4U2Proxy delegations.\ntestprincs = {'krbtgt/KRBTEST.COM': {'keys': 'aes128-cts'},\n              'user': {'keys': 'aes128-cts'},\n              'service/1': {'flags': '+ok-to-auth-as-delegate',\n                            'keys': 'aes128-cts'},\n              'service/2': {'keys': 'aes128-cts'}}\nconf = {'realms': {'$realm': {'database_module': 'test'}},\n        'dbmodules': {'test': {'db_library': 'test',\n                               'princs': testprincs,\n                               'delegation': {'service/1': 'service/2'}}}}\nrealm = K5Realm(create_kdb=False, kdc_conf=conf)\nuserkeytab = 'FILE:' + os.path.join(realm.testdir, 'userkeytab')\nrealm.extract_keytab(realm.user_princ, userkeytab)\nrealm.extract_keytab(service1, realm.keytab)\nrealm.extract_keytab(service2, realm.keytab)\nrealm.start_kdc()\n\n# Get forwardable creds for service1 in the default cache.\nrealm.kinit(service1, None, ['-f', '-k'])\n\n# Successful krb5 -> S4U2Proxy, with krb5 and SPNEGO mechs.\nrealm.kinit(realm.user_princ, None, ['-f', '-k', '-c', usercache,\n                                     '-t', userkeytab])\nout = realm.run(['./t_s4u2proxy_krb5', usercache, storagecache, '-',\n                 pservice1, pservice2])\nif 'auth1: user@' not in out or 'auth2: user@' not in out:\n    fail('krb5 -> s4u2proxy')\nout = realm.run(['./t_s4u2proxy_krb5', '--spnego', usercache, storagecache,\n                 '-', pservice1, pservice2])\nif 'auth1: user@' not in out or 'auth2: user@' not in out:\n    fail('krb5 -> s4u2proxy')\n\n# Successful S4U2Self -> S4U2Proxy.\nout = realm.run(['./t_s4u', puser, pservice2])\n\n# Regression test for #8139: get a user ticket directly for service1 and\n# try krb5 -> S4U2Proxy.\nrealm.kinit(realm.user_princ, None, ['-f', '-k', '-c', usercache,\n                                     '-t', userkeytab, '-S', service1])\nout = realm.run(['./t_s4u2proxy_krb5', usercache, storagecache, '-',\n                 pservice1, pservice2])\nif 'auth1: user@' not in out or 'auth2: user@' not in out:\n    fail('krb5 -> s4u2proxy')\n\n# Simulate a krbtgt rollover and verify that the user ticket can still\n# be validated.\nrealm.stop_kdc()\nnewtgt_keys = ['2 aes128-cts', '1 aes128-cts']\nnewtgt_princs = {'krbtgt/KRBTEST.COM': {'keys': newtgt_keys}}\nnewtgt_conf = {'dbmodules': {'test': {'princs': newtgt_princs}}}\nnewtgt_env = realm.special_env('newtgt', True, kdc_conf=newtgt_conf)\nrealm.start_kdc(env=newtgt_env)\nout = realm.run(['./t_s4u2proxy_krb5', usercache, storagecache, '-',\n                 pservice1, pservice2])\nif 'auth1: user@' not in out or 'auth2: user@' not in out:\n    fail('krb5 -> s4u2proxy')\n\n# Get a user ticket after the krbtgt rollover and verify that\n# S4U2Proxy delegation works (also a #8139 regression test).\nrealm.kinit(realm.user_princ, None, ['-f', '-k', '-c', usercache,\n                                     '-t', userkeytab])\nout = realm.run(['./t_s4u2proxy_krb5', usercache, storagecache, '-',\n                 pservice1, pservice2])\nif 'auth1: user@' not in out or 'auth2: user@' not in out:\n    fail('krb5 -> s4u2proxy')\n\nrealm.stop()\n\n# Test cross realm S4U2Self using server referrals.\nmark('cross-realm S4U2Self')\ntestprincs = {'krbtgt/SREALM': {'keys': 'aes128-cts'},\n              'krbtgt/UREALM': {'keys': 'aes128-cts'},\n              'user': {'keys': 'aes128-cts', 'flags': '+preauth'}}\nkdcconf1 = {'realms': {'$realm': {'database_module': 'test'}},\n            'dbmodules': {'test': {'db_library': 'test',\n                                   'princs': testprincs,\n                                   'alias': {'enterprise@abc': '@UREALM'}}}}\nkdcconf2 = {'realms': {'$realm': {'database_module': 'test'}},\n            'dbmodules': {'test': {'db_library': 'test',\n                                   'princs': testprincs,\n                                   'alias': {'user@SREALM': '@SREALM',\n                                             'enterprise@abc': 'user'}}}}\nr1, r2 = cross_realms(2, xtgts=(),\n                      args=({'realm': 'SREALM', 'kdc_conf': kdcconf1},\n                            {'realm': 'UREALM', 'kdc_conf': kdcconf2}),\n                      create_kdb=False)\n\nr1.start_kdc()\nr2.start_kdc()\nr1.extract_keytab(r1.user_princ, r1.keytab)\nr1.kinit(r1.user_princ, None, ['-k', '-t', r1.keytab])\n\n# Include a regression test for #8741 by unsetting the default realm.\nremove_default = {'libdefaults': {'default_realm': None}}\nno_default = r1.special_env('no_default', False, krb5_conf=remove_default)\nmsgs = ('Getting credentials user@UREALM -> user@SREALM',\n        '/Matching credential not found',\n        'Getting credentials user@SREALM -> krbtgt/UREALM@SREALM',\n        'Received creds for desired service krbtgt/UREALM@SREALM',\n        'via TGT krbtgt/UREALM@SREALM after requesting user\\\\@SREALM@UREALM',\n        'krbtgt/SREALM@UREALM differs from requested user\\\\@SREALM@UREALM',\n        'via TGT krbtgt/SREALM@UREALM after requesting user@SREALM',\n        'TGS reply is for user@UREALM -> user@SREALM')\nr1.run(['./t_s4u', 'p:' + r2.user_princ, '-', r1.keytab], env=no_default,\n       expected_trace=msgs)\n\n# Test realm identification of enterprise principal names ([MS-S4U]\n# 3.1.5.1.1.1).  Attach a bogus realm to the enterprise name to verify\n# that we start at the server realm.\nmark('cross-realm S4U2Self with enterprise name')\nmsgs = ('Getting initial credentials for enterprise\\\\@abc@SREALM',\n        'Processing preauth types: PA-FOR-X509-USER (130)',\n        'Sending unauthenticated request',\n        '/Realm not local to KDC',\n        'Following referral to realm UREALM',\n        'Processing preauth types: PA-FOR-X509-USER (130)',\n        'Sending unauthenticated request',\n        '/Additional pre-authentication required',\n        '/Generic preauthentication failure',\n        'Getting credentials enterprise\\\\@abc@UREALM -> user@SREALM',\n        'TGS reply is for enterprise\\@abc@UREALM -> user@SREALM')\nr1.run(['./t_s4u', 'e:enterprise@abc@NOREALM', '-', r1.keytab],\n       expected_trace=msgs)\n\nr1.stop()\nr2.stop()\n\nsuccess('S4U test cases')\n"], "filenames": ["src/kdc/kdc_util.c", "src/lib/krb5/krb/s4u_creds.c", "src/tests/gssapi/t_s4u.py"], "buggy_code_start_loc": [1609, 119, 20], "buggy_code_end_loc": [1609, 120, 20], "fixing_code_start_loc": [1610, 119, 21], "fixing_code_end_loc": [1615, 120, 29], "type": "CWE-617", "message": "A Reachable Assertion issue was discovered in the KDC in MIT Kerberos 5 (aka krb5) before 1.17. If an attacker can obtain a krbtgt ticket using an older encryption type (single-DES, triple-DES, or RC4), the attacker can crash the KDC by making an S4U2Self request.", "other": {"cve": {"id": "CVE-2018-20217", "sourceIdentifier": "cve@mitre.org", "published": "2018-12-26T21:29:02.543", "lastModified": "2021-10-18T12:03:56.083", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A Reachable Assertion issue was discovered in the KDC in MIT Kerberos 5 (aka krb5) before 1.17. If an attacker can obtain a krbtgt ticket using an older encryption type (single-DES, triple-DES, or RC4), the attacker can crash the KDC by making an S4U2Self request."}, {"lang": "es", "value": "Se ha descubierto un problema de aserci\u00f3n alcanzable en el KDC en MIT Kerberos 5 (tambi\u00e9n conocido como krb5), en versiones anteriores a la 1.17. Si un atacante puede obtener un ticket krbtgt mediante un tipo de cifrado m\u00e1s antiguo (DES, Triple DES o RC4), este puede provocar el cierre inesperado de KDC realizando una petici\u00f3n S4U2Self."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-617"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos:*:*:*:*:*:*:*:*", "versionEndExcluding": "5-1.17", "matchCriteriaId": "47D60B1D-E4D9-4FF8-8C98-7ACCF81D3F24"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://krbdev.mit.edu/rt/Ticket/Display.html?id=8763", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/krb5/krb5/commit/5e6d1796106df8ba6bc1973ee0917c170d929086", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/01/msg00020.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/09/msg00019.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/2KNHELH4YHNT6H2ESJWX2UIDXLBNGB2O/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20190416-0006/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/krb5/krb5/commit/5e6d1796106df8ba6bc1973ee0917c170d929086"}}