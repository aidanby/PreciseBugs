{"buggy_code": ["/*\n * Copyright 2012 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.buffer;\n\nimport io.netty.util.ByteProcessor;\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.IllegalReferenceCountException;\nimport io.netty.util.internal.PlatformDependent;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.nio.CharBuffer;\nimport java.nio.ReadOnlyBufferException;\nimport java.nio.channels.Channels;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.GatheringByteChannel;\nimport java.nio.channels.ScatteringByteChannel;\nimport java.nio.channels.WritableByteChannel;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.CyclicBarrier;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport static io.netty.buffer.Unpooled.LITTLE_ENDIAN;\nimport static io.netty.buffer.Unpooled.buffer;\nimport static io.netty.buffer.Unpooled.copiedBuffer;\nimport static io.netty.buffer.Unpooled.directBuffer;\nimport static io.netty.buffer.Unpooled.unreleasableBuffer;\nimport static io.netty.buffer.Unpooled.wrappedBuffer;\nimport static io.netty.util.internal.EmptyArrays.EMPTY_BYTES;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertSame;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\nimport static org.junit.Assume.assumeFalse;\nimport static org.junit.Assume.assumeTrue;\n\n/**\n * An abstract test class for channel buffers\n */\npublic abstract class AbstractByteBufTest {\n\n    private static final int CAPACITY = 4096; // Must be even\n    private static final int BLOCK_SIZE = 128;\n    private static final int JAVA_BYTEBUFFER_CONSISTENCY_ITERATIONS = 100;\n\n    private long seed;\n    private Random random;\n    private ByteBuf buffer;\n\n    protected final ByteBuf newBuffer(int capacity) {\n        return newBuffer(capacity, Integer.MAX_VALUE);\n    }\n\n    protected abstract ByteBuf newBuffer(int capacity, int maxCapacity);\n\n    protected boolean discardReadBytesDoesNotMoveWritableBytes() {\n        return true;\n    }\n\n    @Before\n    public void init() {\n        buffer = newBuffer(CAPACITY);\n        seed = System.currentTimeMillis();\n        random = new Random(seed);\n    }\n\n    @After\n    public void dispose() {\n        if (buffer != null) {\n            assertThat(buffer.release(), is(true));\n            assertThat(buffer.refCnt(), is(0));\n\n            try {\n                buffer.release();\n            } catch (Exception e) {\n                // Ignore.\n            }\n            buffer = null;\n        }\n    }\n\n    @Test\n    public void comparableInterfaceNotViolated() {\n        assumeFalse(buffer.isReadOnly());\n        buffer.writerIndex(buffer.readerIndex());\n        assumeTrue(buffer.writableBytes() >= 4);\n\n        buffer.writeLong(0);\n        ByteBuf buffer2 = newBuffer(CAPACITY);\n        assumeFalse(buffer2.isReadOnly());\n        buffer2.writerIndex(buffer2.readerIndex());\n        // Write an unsigned integer that will cause buffer.getUnsignedInt() - buffer2.getUnsignedInt() to underflow the\n        // int type and wrap around on the negative side.\n        buffer2.writeLong(0xF0000000L);\n        assertTrue(buffer.compareTo(buffer2) < 0);\n        assertTrue(buffer2.compareTo(buffer) > 0);\n        buffer2.release();\n    }\n\n    @Test\n    public void initialState() {\n        assertEquals(CAPACITY, buffer.capacity());\n        assertEquals(0, buffer.readerIndex());\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void readerIndexBoundaryCheck1() {\n        try {\n            buffer.writerIndex(0);\n        } catch (IndexOutOfBoundsException e) {\n            fail();\n        }\n        buffer.readerIndex(-1);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void readerIndexBoundaryCheck2() {\n        try {\n            buffer.writerIndex(buffer.capacity());\n        } catch (IndexOutOfBoundsException e) {\n            fail();\n        }\n        buffer.readerIndex(buffer.capacity() + 1);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void readerIndexBoundaryCheck3() {\n        try {\n            buffer.writerIndex(CAPACITY / 2);\n        } catch (IndexOutOfBoundsException e) {\n            fail();\n        }\n        buffer.readerIndex(CAPACITY * 3 / 2);\n    }\n\n    @Test\n    public void readerIndexBoundaryCheck4() {\n        buffer.writerIndex(0);\n        buffer.readerIndex(0);\n        buffer.writerIndex(buffer.capacity());\n        buffer.readerIndex(buffer.capacity());\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void writerIndexBoundaryCheck1() {\n        buffer.writerIndex(-1);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void writerIndexBoundaryCheck2() {\n        try {\n            buffer.writerIndex(CAPACITY);\n            buffer.readerIndex(CAPACITY);\n        } catch (IndexOutOfBoundsException e) {\n            fail();\n        }\n        buffer.writerIndex(buffer.capacity() + 1);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void writerIndexBoundaryCheck3() {\n        try {\n            buffer.writerIndex(CAPACITY);\n            buffer.readerIndex(CAPACITY / 2);\n        } catch (IndexOutOfBoundsException e) {\n            fail();\n        }\n        buffer.writerIndex(CAPACITY / 4);\n    }\n\n    @Test\n    public void writerIndexBoundaryCheck4() {\n        buffer.writerIndex(0);\n        buffer.readerIndex(0);\n        buffer.writerIndex(CAPACITY);\n\n        buffer.writeBytes(ByteBuffer.wrap(EMPTY_BYTES));\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getBooleanBoundaryCheck1() {\n        buffer.getBoolean(-1);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getBooleanBoundaryCheck2() {\n        buffer.getBoolean(buffer.capacity());\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getByteBoundaryCheck1() {\n        buffer.getByte(-1);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getByteBoundaryCheck2() {\n        buffer.getByte(buffer.capacity());\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getShortBoundaryCheck1() {\n        buffer.getShort(-1);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getShortBoundaryCheck2() {\n        buffer.getShort(buffer.capacity() - 1);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getMediumBoundaryCheck1() {\n        buffer.getMedium(-1);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getMediumBoundaryCheck2() {\n        buffer.getMedium(buffer.capacity() - 2);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getIntBoundaryCheck1() {\n        buffer.getInt(-1);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getIntBoundaryCheck2() {\n        buffer.getInt(buffer.capacity() - 3);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getLongBoundaryCheck1() {\n        buffer.getLong(-1);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getLongBoundaryCheck2() {\n        buffer.getLong(buffer.capacity() - 7);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getByteArrayBoundaryCheck1() {\n        buffer.getBytes(-1, EMPTY_BYTES);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getByteArrayBoundaryCheck2() {\n        buffer.getBytes(-1, EMPTY_BYTES, 0, 0);\n    }\n\n    @Test\n    public void getByteArrayBoundaryCheck3() {\n        byte[] dst = new byte[4];\n        buffer.setInt(0, 0x01020304);\n        try {\n            buffer.getBytes(0, dst, -1, 4);\n            fail();\n        } catch (IndexOutOfBoundsException e) {\n            // Success\n        }\n\n        // No partial copy is expected.\n        assertEquals(0, dst[0]);\n        assertEquals(0, dst[1]);\n        assertEquals(0, dst[2]);\n        assertEquals(0, dst[3]);\n    }\n\n    @Test\n    public void getByteArrayBoundaryCheck4() {\n        byte[] dst = new byte[4];\n        buffer.setInt(0, 0x01020304);\n        try {\n            buffer.getBytes(0, dst, 1, 4);\n            fail();\n        } catch (IndexOutOfBoundsException e) {\n            // Success\n        }\n\n        // No partial copy is expected.\n        assertEquals(0, dst[0]);\n        assertEquals(0, dst[1]);\n        assertEquals(0, dst[2]);\n        assertEquals(0, dst[3]);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getByteBufferBoundaryCheck() {\n        buffer.getBytes(-1, ByteBuffer.allocate(0));\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void copyBoundaryCheck1() {\n        buffer.copy(-1, 0);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void copyBoundaryCheck2() {\n        buffer.copy(0, buffer.capacity() + 1);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void copyBoundaryCheck3() {\n        buffer.copy(buffer.capacity() + 1, 0);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void copyBoundaryCheck4() {\n        buffer.copy(buffer.capacity(), 1);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void setIndexBoundaryCheck1() {\n        buffer.setIndex(-1, CAPACITY);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void setIndexBoundaryCheck2() {\n        buffer.setIndex(CAPACITY / 2, CAPACITY / 4);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void setIndexBoundaryCheck3() {\n        buffer.setIndex(0, CAPACITY + 1);\n    }\n\n    @Test\n    public void getByteBufferState() {\n        ByteBuffer dst = ByteBuffer.allocate(4);\n        dst.position(1);\n        dst.limit(3);\n\n        buffer.setByte(0, (byte) 1);\n        buffer.setByte(1, (byte) 2);\n        buffer.setByte(2, (byte) 3);\n        buffer.setByte(3, (byte) 4);\n        buffer.getBytes(1, dst);\n\n        assertEquals(3, dst.position());\n        assertEquals(3, dst.limit());\n\n        dst.clear();\n        assertEquals(0, dst.get(0));\n        assertEquals(2, dst.get(1));\n        assertEquals(3, dst.get(2));\n        assertEquals(0, dst.get(3));\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getDirectByteBufferBoundaryCheck() {\n        buffer.getBytes(-1, ByteBuffer.allocateDirect(0));\n    }\n\n    @Test\n    public void getDirectByteBufferState() {\n        ByteBuffer dst = ByteBuffer.allocateDirect(4);\n        dst.position(1);\n        dst.limit(3);\n\n        buffer.setByte(0, (byte) 1);\n        buffer.setByte(1, (byte) 2);\n        buffer.setByte(2, (byte) 3);\n        buffer.setByte(3, (byte) 4);\n        buffer.getBytes(1, dst);\n\n        assertEquals(3, dst.position());\n        assertEquals(3, dst.limit());\n\n        dst.clear();\n        assertEquals(0, dst.get(0));\n        assertEquals(2, dst.get(1));\n        assertEquals(3, dst.get(2));\n        assertEquals(0, dst.get(3));\n    }\n\n    @Test\n    public void testRandomByteAccess() {\n        for (int i = 0; i < buffer.capacity(); i ++) {\n            byte value = (byte) random.nextInt();\n            buffer.setByte(i, value);\n        }\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity(); i ++) {\n            byte value = (byte) random.nextInt();\n            assertEquals(value, buffer.getByte(i));\n        }\n    }\n\n    @Test\n    public void testRandomUnsignedByteAccess() {\n        for (int i = 0; i < buffer.capacity(); i ++) {\n            byte value = (byte) random.nextInt();\n            buffer.setByte(i, value);\n        }\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity(); i ++) {\n            int value = random.nextInt() & 0xFF;\n            assertEquals(value, buffer.getUnsignedByte(i));\n        }\n    }\n\n    @Test\n    public void testRandomShortAccess() {\n        testRandomShortAccess(true);\n    }\n    @Test\n    public void testRandomShortLEAccess() {\n        testRandomShortAccess(false);\n    }\n\n    private void testRandomShortAccess(boolean testBigEndian) {\n        for (int i = 0; i < buffer.capacity() - 1; i += 2) {\n            short value = (short) random.nextInt();\n            if (testBigEndian) {\n                buffer.setShort(i, value);\n            } else {\n                buffer.setShortLE(i, value);\n            }\n        }\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity() - 1; i += 2) {\n            short value = (short) random.nextInt();\n            if (testBigEndian) {\n                assertEquals(value, buffer.getShort(i));\n            } else {\n                assertEquals(value, buffer.getShortLE(i));\n            }\n        }\n    }\n\n    @Test\n    public void testShortConsistentWithByteBuffer() {\n        testShortConsistentWithByteBuffer(true, true);\n        testShortConsistentWithByteBuffer(true, false);\n        testShortConsistentWithByteBuffer(false, true);\n        testShortConsistentWithByteBuffer(false, false);\n    }\n\n    private void testShortConsistentWithByteBuffer(boolean direct, boolean testBigEndian) {\n        for (int i = 0; i < JAVA_BYTEBUFFER_CONSISTENCY_ITERATIONS; ++i) {\n            ByteBuffer javaBuffer = direct ? ByteBuffer.allocateDirect(buffer.capacity())\n                                           : ByteBuffer.allocate(buffer.capacity());\n            if (!testBigEndian) {\n                javaBuffer = javaBuffer.order(ByteOrder.LITTLE_ENDIAN);\n            }\n\n            short expected = (short) (random.nextInt() & 0xFFFF);\n            javaBuffer.putShort(expected);\n\n            final int bufferIndex = buffer.capacity() - 2;\n            if (testBigEndian) {\n                buffer.setShort(bufferIndex, expected);\n            } else {\n                buffer.setShortLE(bufferIndex, expected);\n            }\n            javaBuffer.flip();\n\n            short javaActual = javaBuffer.getShort();\n            assertEquals(expected, javaActual);\n            assertEquals(javaActual, testBigEndian ? buffer.getShort(bufferIndex)\n                                                   : buffer.getShortLE(bufferIndex));\n        }\n    }\n\n    @Test\n    public void testRandomUnsignedShortAccess() {\n        testRandomUnsignedShortAccess(true);\n    }\n\n    @Test\n    public void testRandomUnsignedShortLEAccess() {\n        testRandomUnsignedShortAccess(false);\n    }\n\n    private void testRandomUnsignedShortAccess(boolean testBigEndian) {\n        for (int i = 0; i < buffer.capacity() - 1; i += 2) {\n            short value = (short) random.nextInt();\n            if (testBigEndian) {\n                buffer.setShort(i, value);\n            } else {\n                buffer.setShortLE(i, value);\n            }\n        }\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity() - 1; i += 2) {\n            int value = random.nextInt() & 0xFFFF;\n            if (testBigEndian) {\n                assertEquals(value, buffer.getUnsignedShort(i));\n            } else {\n                assertEquals(value, buffer.getUnsignedShortLE(i));\n            }\n        }\n    }\n\n    @Test\n    public void testRandomMediumAccess() {\n        testRandomMediumAccess(true);\n    }\n\n    @Test\n    public void testRandomMediumLEAccess() {\n        testRandomMediumAccess(false);\n    }\n\n    private void testRandomMediumAccess(boolean testBigEndian) {\n        for (int i = 0; i < buffer.capacity() - 2; i += 3) {\n            int value = random.nextInt();\n            if (testBigEndian) {\n                buffer.setMedium(i, value);\n            } else {\n                buffer.setMediumLE(i, value);\n            }\n        }\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity() - 2; i += 3) {\n            int value = random.nextInt() << 8 >> 8;\n            if (testBigEndian) {\n                assertEquals(value, buffer.getMedium(i));\n            } else {\n                assertEquals(value, buffer.getMediumLE(i));\n            }\n        }\n    }\n\n    @Test\n    public void testRandomUnsignedMediumAccess() {\n        testRandomUnsignedMediumAccess(true);\n    }\n\n    @Test\n    public void testRandomUnsignedMediumLEAccess() {\n        testRandomUnsignedMediumAccess(false);\n    }\n\n    private void testRandomUnsignedMediumAccess(boolean testBigEndian) {\n        for (int i = 0; i < buffer.capacity() - 2; i += 3) {\n            int value = random.nextInt();\n            if (testBigEndian) {\n                buffer.setMedium(i, value);\n            } else {\n                buffer.setMediumLE(i, value);\n            }\n        }\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity() - 2; i += 3) {\n            int value = random.nextInt() & 0x00FFFFFF;\n            if (testBigEndian) {\n                assertEquals(value, buffer.getUnsignedMedium(i));\n            } else {\n                assertEquals(value, buffer.getUnsignedMediumLE(i));\n            }\n        }\n    }\n\n    @Test\n    public void testMediumConsistentWithByteBuffer() {\n        testMediumConsistentWithByteBuffer(true, true);\n        testMediumConsistentWithByteBuffer(true, false);\n        testMediumConsistentWithByteBuffer(false, true);\n        testMediumConsistentWithByteBuffer(false, false);\n    }\n\n    private void testMediumConsistentWithByteBuffer(boolean direct, boolean testBigEndian) {\n        for (int i = 0; i < JAVA_BYTEBUFFER_CONSISTENCY_ITERATIONS; ++i) {\n            ByteBuffer javaBuffer = direct ? ByteBuffer.allocateDirect(buffer.capacity())\n                                           : ByteBuffer.allocate(buffer.capacity());\n            if (!testBigEndian) {\n                javaBuffer = javaBuffer.order(ByteOrder.LITTLE_ENDIAN);\n            }\n\n            int expected = random.nextInt() & 0x00FFFFFF;\n            javaBuffer.putInt(expected);\n\n            final int bufferIndex = buffer.capacity() - 3;\n            if (testBigEndian) {\n                buffer.setMedium(bufferIndex, expected);\n            } else {\n                buffer.setMediumLE(bufferIndex, expected);\n            }\n            javaBuffer.flip();\n\n            int javaActual = javaBuffer.getInt();\n            assertEquals(expected, javaActual);\n            assertEquals(javaActual, testBigEndian ? buffer.getUnsignedMedium(bufferIndex)\n                                                   : buffer.getUnsignedMediumLE(bufferIndex));\n        }\n    }\n\n    @Test\n    public void testRandomIntAccess() {\n        testRandomIntAccess(true);\n    }\n\n    @Test\n    public void testRandomIntLEAccess() {\n        testRandomIntAccess(false);\n    }\n\n    private void testRandomIntAccess(boolean testBigEndian) {\n        for (int i = 0; i < buffer.capacity() - 3; i += 4) {\n            int value = random.nextInt();\n            if (testBigEndian) {\n                buffer.setInt(i, value);\n            } else {\n                buffer.setIntLE(i, value);\n            }\n        }\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity() - 3; i += 4) {\n            int value = random.nextInt();\n            if (testBigEndian) {\n                assertEquals(value, buffer.getInt(i));\n            } else {\n                assertEquals(value, buffer.getIntLE(i));\n            }\n        }\n    }\n\n    @Test\n    public void testIntConsistentWithByteBuffer() {\n        testIntConsistentWithByteBuffer(true, true);\n        testIntConsistentWithByteBuffer(true, false);\n        testIntConsistentWithByteBuffer(false, true);\n        testIntConsistentWithByteBuffer(false, false);\n    }\n\n    private void testIntConsistentWithByteBuffer(boolean direct, boolean testBigEndian) {\n        for (int i = 0; i < JAVA_BYTEBUFFER_CONSISTENCY_ITERATIONS; ++i) {\n            ByteBuffer javaBuffer = direct ? ByteBuffer.allocateDirect(buffer.capacity())\n                                           : ByteBuffer.allocate(buffer.capacity());\n            if (!testBigEndian) {\n                javaBuffer = javaBuffer.order(ByteOrder.LITTLE_ENDIAN);\n            }\n\n            int expected = random.nextInt();\n            javaBuffer.putInt(expected);\n\n            final int bufferIndex = buffer.capacity() - 4;\n            if (testBigEndian) {\n                buffer.setInt(bufferIndex, expected);\n            } else {\n                buffer.setIntLE(bufferIndex, expected);\n            }\n            javaBuffer.flip();\n\n            int javaActual = javaBuffer.getInt();\n            assertEquals(expected, javaActual);\n            assertEquals(javaActual, testBigEndian ? buffer.getInt(bufferIndex)\n                                                   : buffer.getIntLE(bufferIndex));\n        }\n    }\n\n    @Test\n    public void testRandomUnsignedIntAccess() {\n        testRandomUnsignedIntAccess(true);\n    }\n\n    @Test\n    public void testRandomUnsignedIntLEAccess() {\n        testRandomUnsignedIntAccess(false);\n    }\n\n    private void testRandomUnsignedIntAccess(boolean testBigEndian) {\n        for (int i = 0; i < buffer.capacity() - 3; i += 4) {\n            int value = random.nextInt();\n            if (testBigEndian) {\n                buffer.setInt(i, value);\n            } else {\n                buffer.setIntLE(i, value);\n            }\n        }\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity() - 3; i += 4) {\n            long value = random.nextInt() & 0xFFFFFFFFL;\n            if (testBigEndian) {\n                assertEquals(value, buffer.getUnsignedInt(i));\n            } else {\n                assertEquals(value, buffer.getUnsignedIntLE(i));\n            }\n        }\n    }\n\n    @Test\n    public void testRandomLongAccess() {\n        testRandomLongAccess(true);\n    }\n\n    @Test\n    public void testRandomLongLEAccess() {\n        testRandomLongAccess(false);\n    }\n\n    private void testRandomLongAccess(boolean testBigEndian) {\n        for (int i = 0; i < buffer.capacity() - 7; i += 8) {\n            long value = random.nextLong();\n            if (testBigEndian) {\n                buffer.setLong(i, value);\n            } else {\n                buffer.setLongLE(i, value);\n            }\n        }\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity() - 7; i += 8) {\n            long value = random.nextLong();\n            if (testBigEndian) {\n                assertEquals(value, buffer.getLong(i));\n            } else {\n                assertEquals(value, buffer.getLongLE(i));\n            }\n        }\n    }\n\n    @Test\n    public void testLongConsistentWithByteBuffer() {\n        testLongConsistentWithByteBuffer(true, true);\n        testLongConsistentWithByteBuffer(true, false);\n        testLongConsistentWithByteBuffer(false, true);\n        testLongConsistentWithByteBuffer(false, false);\n    }\n\n    private void testLongConsistentWithByteBuffer(boolean direct, boolean testBigEndian) {\n        for (int i = 0; i < JAVA_BYTEBUFFER_CONSISTENCY_ITERATIONS; ++i) {\n            ByteBuffer javaBuffer = direct ? ByteBuffer.allocateDirect(buffer.capacity())\n                                           : ByteBuffer.allocate(buffer.capacity());\n            if (!testBigEndian) {\n                javaBuffer = javaBuffer.order(ByteOrder.LITTLE_ENDIAN);\n            }\n\n            long expected = random.nextLong();\n            javaBuffer.putLong(expected);\n\n            final int bufferIndex = buffer.capacity() - 8;\n            if (testBigEndian) {\n                buffer.setLong(bufferIndex, expected);\n            } else {\n                buffer.setLongLE(bufferIndex, expected);\n            }\n            javaBuffer.flip();\n\n            long javaActual = javaBuffer.getLong();\n            assertEquals(expected, javaActual);\n            assertEquals(javaActual, testBigEndian ? buffer.getLong(bufferIndex)\n                                                   : buffer.getLongLE(bufferIndex));\n        }\n    }\n\n    @Test\n    public void testRandomFloatAccess() {\n        testRandomFloatAccess(true);\n    }\n\n    @Test\n    public void testRandomFloatLEAccess() {\n        testRandomFloatAccess(false);\n    }\n\n    private void testRandomFloatAccess(boolean testBigEndian) {\n        for (int i = 0; i < buffer.capacity() - 7; i += 8) {\n            float value = random.nextFloat();\n            if (testBigEndian) {\n                buffer.setFloat(i, value);\n            } else {\n                buffer.setFloatLE(i, value);\n            }\n        }\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity() - 7; i += 8) {\n            float expected = random.nextFloat();\n            float actual = testBigEndian? buffer.getFloat(i) : buffer.getFloatLE(i);\n            assertEquals(expected, actual, 0.01);\n        }\n    }\n\n    @Test\n    public void testRandomDoubleAccess() {\n        testRandomDoubleAccess(true);\n    }\n\n    @Test\n    public void testRandomDoubleLEAccess() {\n        testRandomDoubleAccess(false);\n    }\n\n    private void testRandomDoubleAccess(boolean testBigEndian) {\n        for (int i = 0; i < buffer.capacity() - 7; i += 8) {\n            double value = random.nextDouble();\n            if (testBigEndian) {\n                buffer.setDouble(i, value);\n            } else {\n                buffer.setDoubleLE(i, value);\n            }\n        }\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity() - 7; i += 8) {\n            double expected = random.nextDouble();\n            double actual = testBigEndian? buffer.getDouble(i) : buffer.getDoubleLE(i);\n            assertEquals(expected, actual, 0.01);\n        }\n    }\n\n    @Test\n    public void testSetZero() {\n        buffer.clear();\n        while (buffer.isWritable()) {\n            buffer.writeByte((byte) 0xFF);\n        }\n\n        for (int i = 0; i < buffer.capacity();) {\n            int length = Math.min(buffer.capacity() - i, random.nextInt(32));\n            buffer.setZero(i, length);\n            i += length;\n        }\n\n        for (int i = 0; i < buffer.capacity(); i ++) {\n            assertEquals(0, buffer.getByte(i));\n        }\n    }\n\n    @Test\n    public void testSequentialByteAccess() {\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity(); i ++) {\n            byte value = (byte) random.nextInt();\n            assertEquals(i, buffer.writerIndex());\n            assertTrue(buffer.isWritable());\n            buffer.writeByte(value);\n        }\n\n        assertEquals(0, buffer.readerIndex());\n        assertEquals(buffer.capacity(), buffer.writerIndex());\n        assertFalse(buffer.isWritable());\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity(); i ++) {\n            byte value = (byte) random.nextInt();\n            assertEquals(i, buffer.readerIndex());\n            assertTrue(buffer.isReadable());\n            assertEquals(value, buffer.readByte());\n        }\n\n        assertEquals(buffer.capacity(), buffer.readerIndex());\n        assertEquals(buffer.capacity(), buffer.writerIndex());\n        assertFalse(buffer.isReadable());\n        assertFalse(buffer.isWritable());\n    }\n\n    @Test\n    public void testSequentialUnsignedByteAccess() {\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity(); i ++) {\n            byte value = (byte) random.nextInt();\n            assertEquals(i, buffer.writerIndex());\n            assertTrue(buffer.isWritable());\n            buffer.writeByte(value);\n        }\n\n        assertEquals(0, buffer.readerIndex());\n        assertEquals(buffer.capacity(), buffer.writerIndex());\n        assertFalse(buffer.isWritable());\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity(); i ++) {\n            int value = random.nextInt() & 0xFF;\n            assertEquals(i, buffer.readerIndex());\n            assertTrue(buffer.isReadable());\n            assertEquals(value, buffer.readUnsignedByte());\n        }\n\n        assertEquals(buffer.capacity(), buffer.readerIndex());\n        assertEquals(buffer.capacity(), buffer.writerIndex());\n        assertFalse(buffer.isReadable());\n        assertFalse(buffer.isWritable());\n    }\n\n    @Test\n    public void testSequentialShortAccess() {\n        testSequentialShortAccess(true);\n    }\n\n    @Test\n    public void testSequentialShortLEAccess() {\n        testSequentialShortAccess(false);\n    }\n\n    private void testSequentialShortAccess(boolean testBigEndian) {\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity(); i += 2) {\n            short value = (short) random.nextInt();\n            assertEquals(i, buffer.writerIndex());\n            assertTrue(buffer.isWritable());\n            if (testBigEndian) {\n                buffer.writeShort(value);\n            } else {\n                buffer.writeShortLE(value);\n            }\n        }\n\n        assertEquals(0, buffer.readerIndex());\n        assertEquals(buffer.capacity(), buffer.writerIndex());\n        assertFalse(buffer.isWritable());\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity(); i += 2) {\n            short value = (short) random.nextInt();\n            assertEquals(i, buffer.readerIndex());\n            assertTrue(buffer.isReadable());\n            if (testBigEndian) {\n                assertEquals(value, buffer.readShort());\n            } else {\n                assertEquals(value, buffer.readShortLE());\n            }\n        }\n\n        assertEquals(buffer.capacity(), buffer.readerIndex());\n        assertEquals(buffer.capacity(), buffer.writerIndex());\n        assertFalse(buffer.isReadable());\n        assertFalse(buffer.isWritable());\n    }\n\n    @Test\n    public void testSequentialUnsignedShortAccess() {\n        testSequentialUnsignedShortAccess(true);\n    }\n\n    @Test\n    public void testSequentialUnsignedShortLEAccess() {\n        testSequentialUnsignedShortAccess(true);\n    }\n\n    private void testSequentialUnsignedShortAccess(boolean testBigEndian) {\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity(); i += 2) {\n            short value = (short) random.nextInt();\n            assertEquals(i, buffer.writerIndex());\n            assertTrue(buffer.isWritable());\n            if (testBigEndian) {\n                buffer.writeShort(value);\n            } else {\n                buffer.writeShortLE(value);\n            }\n        }\n\n        assertEquals(0, buffer.readerIndex());\n        assertEquals(buffer.capacity(), buffer.writerIndex());\n        assertFalse(buffer.isWritable());\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity(); i += 2) {\n            int value = random.nextInt() & 0xFFFF;\n            assertEquals(i, buffer.readerIndex());\n            assertTrue(buffer.isReadable());\n            if (testBigEndian) {\n                assertEquals(value, buffer.readUnsignedShort());\n            } else {\n                assertEquals(value, buffer.readUnsignedShortLE());\n            }\n        }\n\n        assertEquals(buffer.capacity(), buffer.readerIndex());\n        assertEquals(buffer.capacity(), buffer.writerIndex());\n        assertFalse(buffer.isReadable());\n        assertFalse(buffer.isWritable());\n    }\n\n    @Test\n    public void testSequentialMediumAccess() {\n        testSequentialMediumAccess(true);\n    }\n    @Test\n    public void testSequentialMediumLEAccess() {\n        testSequentialMediumAccess(false);\n    }\n\n    private void testSequentialMediumAccess(boolean testBigEndian) {\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity() / 3 * 3; i += 3) {\n            int value = random.nextInt();\n            assertEquals(i, buffer.writerIndex());\n            assertTrue(buffer.isWritable());\n            if (testBigEndian) {\n                buffer.writeMedium(value);\n            } else {\n                buffer.writeMediumLE(value);\n            }\n        }\n\n        assertEquals(0, buffer.readerIndex());\n        assertEquals(buffer.capacity() / 3 * 3, buffer.writerIndex());\n        assertEquals(buffer.capacity() % 3, buffer.writableBytes());\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity() / 3 * 3; i += 3) {\n            int value = random.nextInt() << 8 >> 8;\n            assertEquals(i, buffer.readerIndex());\n            assertTrue(buffer.isReadable());\n            if (testBigEndian) {\n                assertEquals(value, buffer.readMedium());\n            } else {\n                assertEquals(value, buffer.readMediumLE());\n            }\n        }\n\n        assertEquals(buffer.capacity() / 3 * 3, buffer.readerIndex());\n        assertEquals(buffer.capacity() / 3 * 3, buffer.writerIndex());\n        assertEquals(0, buffer.readableBytes());\n        assertEquals(buffer.capacity() % 3, buffer.writableBytes());\n    }\n\n    @Test\n    public void testSequentialUnsignedMediumAccess() {\n        testSequentialUnsignedMediumAccess(true);\n    }\n\n    @Test\n    public void testSequentialUnsignedMediumLEAccess() {\n        testSequentialUnsignedMediumAccess(false);\n    }\n\n    private void testSequentialUnsignedMediumAccess(boolean testBigEndian) {\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity() / 3 * 3; i += 3) {\n            int value = random.nextInt() & 0x00FFFFFF;\n            assertEquals(i, buffer.writerIndex());\n            assertTrue(buffer.isWritable());\n            if (testBigEndian) {\n                buffer.writeMedium(value);\n            } else {\n                buffer.writeMediumLE(value);\n            }\n        }\n\n        assertEquals(0, buffer.readerIndex());\n        assertEquals(buffer.capacity() / 3 * 3, buffer.writerIndex());\n        assertEquals(buffer.capacity() % 3, buffer.writableBytes());\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity() / 3 * 3; i += 3) {\n            int value = random.nextInt() & 0x00FFFFFF;\n            assertEquals(i, buffer.readerIndex());\n            assertTrue(buffer.isReadable());\n            if (testBigEndian) {\n                assertEquals(value, buffer.readUnsignedMedium());\n            } else {\n                assertEquals(value, buffer.readUnsignedMediumLE());\n            }\n        }\n\n        assertEquals(buffer.capacity() / 3 * 3, buffer.readerIndex());\n        assertEquals(buffer.capacity() / 3 * 3, buffer.writerIndex());\n        assertEquals(0, buffer.readableBytes());\n        assertEquals(buffer.capacity() % 3, buffer.writableBytes());\n    }\n\n    @Test\n    public void testSequentialIntAccess() {\n        testSequentialIntAccess(true);\n    }\n\n    @Test\n    public void testSequentialIntLEAccess() {\n        testSequentialIntAccess(false);\n    }\n\n    private void testSequentialIntAccess(boolean testBigEndian) {\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity(); i += 4) {\n            int value = random.nextInt();\n            assertEquals(i, buffer.writerIndex());\n            assertTrue(buffer.isWritable());\n            if (testBigEndian) {\n                buffer.writeInt(value);\n            } else {\n                buffer.writeIntLE(value);\n            }\n        }\n\n        assertEquals(0, buffer.readerIndex());\n        assertEquals(buffer.capacity(), buffer.writerIndex());\n        assertFalse(buffer.isWritable());\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity(); i += 4) {\n            int value = random.nextInt();\n            assertEquals(i, buffer.readerIndex());\n            assertTrue(buffer.isReadable());\n            if (testBigEndian) {\n                assertEquals(value, buffer.readInt());\n            } else {\n                assertEquals(value, buffer.readIntLE());\n            }\n        }\n\n        assertEquals(buffer.capacity(), buffer.readerIndex());\n        assertEquals(buffer.capacity(), buffer.writerIndex());\n        assertFalse(buffer.isReadable());\n        assertFalse(buffer.isWritable());\n    }\n\n    @Test\n    public void testSequentialUnsignedIntAccess() {\n        testSequentialUnsignedIntAccess(true);\n    }\n\n    @Test\n    public void testSequentialUnsignedIntLEAccess() {\n        testSequentialUnsignedIntAccess(false);\n    }\n\n    private void testSequentialUnsignedIntAccess(boolean testBigEndian) {\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity(); i += 4) {\n            int value = random.nextInt();\n            assertEquals(i, buffer.writerIndex());\n            assertTrue(buffer.isWritable());\n            if (testBigEndian) {\n                buffer.writeInt(value);\n            } else {\n                buffer.writeIntLE(value);\n            }\n        }\n\n        assertEquals(0, buffer.readerIndex());\n        assertEquals(buffer.capacity(), buffer.writerIndex());\n        assertFalse(buffer.isWritable());\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity(); i += 4) {\n            long value = random.nextInt() & 0xFFFFFFFFL;\n            assertEquals(i, buffer.readerIndex());\n            assertTrue(buffer.isReadable());\n            if (testBigEndian) {\n                assertEquals(value, buffer.readUnsignedInt());\n            } else {\n                assertEquals(value, buffer.readUnsignedIntLE());\n            }\n        }\n\n        assertEquals(buffer.capacity(), buffer.readerIndex());\n        assertEquals(buffer.capacity(), buffer.writerIndex());\n        assertFalse(buffer.isReadable());\n        assertFalse(buffer.isWritable());\n    }\n\n    @Test\n    public void testSequentialLongAccess() {\n        testSequentialLongAccess(true);\n    }\n\n    @Test\n    public void testSequentialLongLEAccess() {\n        testSequentialLongAccess(false);\n    }\n\n    private void testSequentialLongAccess(boolean testBigEndian) {\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity(); i += 8) {\n            long value = random.nextLong();\n            assertEquals(i, buffer.writerIndex());\n            assertTrue(buffer.isWritable());\n            if (testBigEndian) {\n                buffer.writeLong(value);\n            } else {\n                buffer.writeLongLE(value);\n            }\n        }\n\n        assertEquals(0, buffer.readerIndex());\n        assertEquals(buffer.capacity(), buffer.writerIndex());\n        assertFalse(buffer.isWritable());\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity(); i += 8) {\n            long value = random.nextLong();\n            assertEquals(i, buffer.readerIndex());\n            assertTrue(buffer.isReadable());\n            if (testBigEndian) {\n                assertEquals(value, buffer.readLong());\n            } else {\n                assertEquals(value, buffer.readLongLE());\n            }\n        }\n\n        assertEquals(buffer.capacity(), buffer.readerIndex());\n        assertEquals(buffer.capacity(), buffer.writerIndex());\n        assertFalse(buffer.isReadable());\n        assertFalse(buffer.isWritable());\n    }\n\n    @Test\n    public void testByteArrayTransfer() {\n        byte[] value = new byte[BLOCK_SIZE * 2];\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(value);\n            buffer.setBytes(i, value, random.nextInt(BLOCK_SIZE), BLOCK_SIZE);\n        }\n\n        random.setSeed(seed);\n        byte[] expectedValue = new byte[BLOCK_SIZE * 2];\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValue);\n            int valueOffset = random.nextInt(BLOCK_SIZE);\n            buffer.getBytes(i, value, valueOffset, BLOCK_SIZE);\n            for (int j = valueOffset; j < valueOffset + BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue[j], value[j]);\n            }\n        }\n    }\n\n    @Test\n    public void testRandomByteArrayTransfer1() {\n        byte[] value = new byte[BLOCK_SIZE];\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(value);\n            buffer.setBytes(i, value);\n        }\n\n        random.setSeed(seed);\n        byte[] expectedValueContent = new byte[BLOCK_SIZE];\n        ByteBuf expectedValue = wrappedBuffer(expectedValueContent);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValueContent);\n            buffer.getBytes(i, value);\n            for (int j = 0; j < BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue.getByte(j), value[j]);\n            }\n        }\n    }\n\n    @Test\n    public void testRandomByteArrayTransfer2() {\n        byte[] value = new byte[BLOCK_SIZE * 2];\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(value);\n            buffer.setBytes(i, value, random.nextInt(BLOCK_SIZE), BLOCK_SIZE);\n        }\n\n        random.setSeed(seed);\n        byte[] expectedValueContent = new byte[BLOCK_SIZE * 2];\n        ByteBuf expectedValue = wrappedBuffer(expectedValueContent);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValueContent);\n            int valueOffset = random.nextInt(BLOCK_SIZE);\n            buffer.getBytes(i, value, valueOffset, BLOCK_SIZE);\n            for (int j = valueOffset; j < valueOffset + BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue.getByte(j), value[j]);\n            }\n        }\n    }\n\n    @Test\n    public void testRandomHeapBufferTransfer1() {\n        byte[] valueContent = new byte[BLOCK_SIZE];\n        ByteBuf value = wrappedBuffer(valueContent);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(valueContent);\n            value.setIndex(0, BLOCK_SIZE);\n            buffer.setBytes(i, value);\n            assertEquals(BLOCK_SIZE, value.readerIndex());\n            assertEquals(BLOCK_SIZE, value.writerIndex());\n        }\n\n        random.setSeed(seed);\n        byte[] expectedValueContent = new byte[BLOCK_SIZE];\n        ByteBuf expectedValue = wrappedBuffer(expectedValueContent);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValueContent);\n            value.clear();\n            buffer.getBytes(i, value);\n            assertEquals(0, value.readerIndex());\n            assertEquals(BLOCK_SIZE, value.writerIndex());\n            for (int j = 0; j < BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue.getByte(j), value.getByte(j));\n            }\n        }\n    }\n\n    @Test\n    public void testRandomHeapBufferTransfer2() {\n        byte[] valueContent = new byte[BLOCK_SIZE * 2];\n        ByteBuf value = wrappedBuffer(valueContent);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(valueContent);\n            buffer.setBytes(i, value, random.nextInt(BLOCK_SIZE), BLOCK_SIZE);\n        }\n\n        random.setSeed(seed);\n        byte[] expectedValueContent = new byte[BLOCK_SIZE * 2];\n        ByteBuf expectedValue = wrappedBuffer(expectedValueContent);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValueContent);\n            int valueOffset = random.nextInt(BLOCK_SIZE);\n            buffer.getBytes(i, value, valueOffset, BLOCK_SIZE);\n            for (int j = valueOffset; j < valueOffset + BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue.getByte(j), value.getByte(j));\n            }\n        }\n    }\n\n    @Test\n    public void testRandomDirectBufferTransfer() {\n        byte[] tmp = new byte[BLOCK_SIZE * 2];\n        ByteBuf value = directBuffer(BLOCK_SIZE * 2);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(tmp);\n            value.setBytes(0, tmp, 0, value.capacity());\n            buffer.setBytes(i, value, random.nextInt(BLOCK_SIZE), BLOCK_SIZE);\n        }\n\n        random.setSeed(seed);\n        ByteBuf expectedValue = directBuffer(BLOCK_SIZE * 2);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(tmp);\n            expectedValue.setBytes(0, tmp, 0, expectedValue.capacity());\n            int valueOffset = random.nextInt(BLOCK_SIZE);\n            buffer.getBytes(i, value, valueOffset, BLOCK_SIZE);\n            for (int j = valueOffset; j < valueOffset + BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue.getByte(j), value.getByte(j));\n            }\n        }\n        value.release();\n        expectedValue.release();\n    }\n\n    @Test\n    public void testRandomByteBufferTransfer() {\n        ByteBuffer value = ByteBuffer.allocate(BLOCK_SIZE * 2);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(value.array());\n            value.clear().position(random.nextInt(BLOCK_SIZE));\n            value.limit(value.position() + BLOCK_SIZE);\n            buffer.setBytes(i, value);\n        }\n\n        random.setSeed(seed);\n        ByteBuffer expectedValue = ByteBuffer.allocate(BLOCK_SIZE * 2);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValue.array());\n            int valueOffset = random.nextInt(BLOCK_SIZE);\n            value.clear().position(valueOffset).limit(valueOffset + BLOCK_SIZE);\n            buffer.getBytes(i, value);\n            assertEquals(valueOffset + BLOCK_SIZE, value.position());\n            for (int j = valueOffset; j < valueOffset + BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue.get(j), value.get(j));\n            }\n        }\n    }\n\n    @Test\n    public void testSequentialByteArrayTransfer1() {\n        byte[] value = new byte[BLOCK_SIZE];\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(value);\n            assertEquals(0, buffer.readerIndex());\n            assertEquals(i, buffer.writerIndex());\n            buffer.writeBytes(value);\n        }\n\n        random.setSeed(seed);\n        byte[] expectedValue = new byte[BLOCK_SIZE];\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValue);\n            assertEquals(i, buffer.readerIndex());\n            assertEquals(CAPACITY, buffer.writerIndex());\n            buffer.readBytes(value);\n            for (int j = 0; j < BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue[j], value[j]);\n            }\n        }\n    }\n\n    @Test\n    public void testSequentialByteArrayTransfer2() {\n        byte[] value = new byte[BLOCK_SIZE * 2];\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(value);\n            assertEquals(0, buffer.readerIndex());\n            assertEquals(i, buffer.writerIndex());\n            int readerIndex = random.nextInt(BLOCK_SIZE);\n            buffer.writeBytes(value, readerIndex, BLOCK_SIZE);\n        }\n\n        random.setSeed(seed);\n        byte[] expectedValue = new byte[BLOCK_SIZE * 2];\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValue);\n            int valueOffset = random.nextInt(BLOCK_SIZE);\n            assertEquals(i, buffer.readerIndex());\n            assertEquals(CAPACITY, buffer.writerIndex());\n            buffer.readBytes(value, valueOffset, BLOCK_SIZE);\n            for (int j = valueOffset; j < valueOffset + BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue[j], value[j]);\n            }\n        }\n    }\n\n    @Test\n    public void testSequentialHeapBufferTransfer1() {\n        byte[] valueContent = new byte[BLOCK_SIZE * 2];\n        ByteBuf value = wrappedBuffer(valueContent);\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(valueContent);\n            assertEquals(0, buffer.readerIndex());\n            assertEquals(i, buffer.writerIndex());\n            buffer.writeBytes(value, random.nextInt(BLOCK_SIZE), BLOCK_SIZE);\n            assertEquals(0, value.readerIndex());\n            assertEquals(valueContent.length, value.writerIndex());\n        }\n\n        random.setSeed(seed);\n        byte[] expectedValueContent = new byte[BLOCK_SIZE * 2];\n        ByteBuf expectedValue = wrappedBuffer(expectedValueContent);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValueContent);\n            int valueOffset = random.nextInt(BLOCK_SIZE);\n            assertEquals(i, buffer.readerIndex());\n            assertEquals(CAPACITY, buffer.writerIndex());\n            buffer.readBytes(value, valueOffset, BLOCK_SIZE);\n            for (int j = valueOffset; j < valueOffset + BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue.getByte(j), value.getByte(j));\n            }\n            assertEquals(0, value.readerIndex());\n            assertEquals(valueContent.length, value.writerIndex());\n        }\n    }\n\n    @Test\n    public void testSequentialHeapBufferTransfer2() {\n        byte[] valueContent = new byte[BLOCK_SIZE * 2];\n        ByteBuf value = wrappedBuffer(valueContent);\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(valueContent);\n            assertEquals(0, buffer.readerIndex());\n            assertEquals(i, buffer.writerIndex());\n            int readerIndex = random.nextInt(BLOCK_SIZE);\n            value.readerIndex(readerIndex);\n            value.writerIndex(readerIndex + BLOCK_SIZE);\n            buffer.writeBytes(value);\n            assertEquals(readerIndex + BLOCK_SIZE, value.writerIndex());\n            assertEquals(value.writerIndex(), value.readerIndex());\n        }\n\n        random.setSeed(seed);\n        byte[] expectedValueContent = new byte[BLOCK_SIZE * 2];\n        ByteBuf expectedValue = wrappedBuffer(expectedValueContent);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValueContent);\n            int valueOffset = random.nextInt(BLOCK_SIZE);\n            assertEquals(i, buffer.readerIndex());\n            assertEquals(CAPACITY, buffer.writerIndex());\n            value.readerIndex(valueOffset);\n            value.writerIndex(valueOffset);\n            buffer.readBytes(value, BLOCK_SIZE);\n            for (int j = valueOffset; j < valueOffset + BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue.getByte(j), value.getByte(j));\n            }\n            assertEquals(valueOffset, value.readerIndex());\n            assertEquals(valueOffset + BLOCK_SIZE, value.writerIndex());\n        }\n    }\n\n    @Test\n    public void testSequentialDirectBufferTransfer1() {\n        byte[] valueContent = new byte[BLOCK_SIZE * 2];\n        ByteBuf value = directBuffer(BLOCK_SIZE * 2);\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(valueContent);\n            value.setBytes(0, valueContent);\n            assertEquals(0, buffer.readerIndex());\n            assertEquals(i, buffer.writerIndex());\n            buffer.writeBytes(value, random.nextInt(BLOCK_SIZE), BLOCK_SIZE);\n            assertEquals(0, value.readerIndex());\n            assertEquals(0, value.writerIndex());\n        }\n\n        random.setSeed(seed);\n        byte[] expectedValueContent = new byte[BLOCK_SIZE * 2];\n        ByteBuf expectedValue = wrappedBuffer(expectedValueContent);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValueContent);\n            int valueOffset = random.nextInt(BLOCK_SIZE);\n            value.setBytes(0, valueContent);\n            assertEquals(i, buffer.readerIndex());\n            assertEquals(CAPACITY, buffer.writerIndex());\n            buffer.readBytes(value, valueOffset, BLOCK_SIZE);\n            for (int j = valueOffset; j < valueOffset + BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue.getByte(j), value.getByte(j));\n            }\n            assertEquals(0, value.readerIndex());\n            assertEquals(0, value.writerIndex());\n        }\n        value.release();\n        expectedValue.release();\n    }\n\n    @Test\n    public void testSequentialDirectBufferTransfer2() {\n        byte[] valueContent = new byte[BLOCK_SIZE * 2];\n        ByteBuf value = directBuffer(BLOCK_SIZE * 2);\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(valueContent);\n            value.setBytes(0, valueContent);\n            assertEquals(0, buffer.readerIndex());\n            assertEquals(i, buffer.writerIndex());\n            int readerIndex = random.nextInt(BLOCK_SIZE);\n            value.readerIndex(0);\n            value.writerIndex(readerIndex + BLOCK_SIZE);\n            value.readerIndex(readerIndex);\n            buffer.writeBytes(value);\n            assertEquals(readerIndex + BLOCK_SIZE, value.writerIndex());\n            assertEquals(value.writerIndex(), value.readerIndex());\n        }\n\n        random.setSeed(seed);\n        byte[] expectedValueContent = new byte[BLOCK_SIZE * 2];\n        ByteBuf expectedValue = wrappedBuffer(expectedValueContent);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValueContent);\n            value.setBytes(0, valueContent);\n            int valueOffset = random.nextInt(BLOCK_SIZE);\n            assertEquals(i, buffer.readerIndex());\n            assertEquals(CAPACITY, buffer.writerIndex());\n            value.readerIndex(valueOffset);\n            value.writerIndex(valueOffset);\n            buffer.readBytes(value, BLOCK_SIZE);\n            for (int j = valueOffset; j < valueOffset + BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue.getByte(j), value.getByte(j));\n            }\n            assertEquals(valueOffset, value.readerIndex());\n            assertEquals(valueOffset + BLOCK_SIZE, value.writerIndex());\n        }\n        value.release();\n        expectedValue.release();\n    }\n\n    @Test\n    public void testSequentialByteBufferBackedHeapBufferTransfer1() {\n        byte[] valueContent = new byte[BLOCK_SIZE * 2];\n        ByteBuf value = wrappedBuffer(ByteBuffer.allocate(BLOCK_SIZE * 2));\n        value.writerIndex(0);\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(valueContent);\n            value.setBytes(0, valueContent);\n            assertEquals(0, buffer.readerIndex());\n            assertEquals(i, buffer.writerIndex());\n            buffer.writeBytes(value, random.nextInt(BLOCK_SIZE), BLOCK_SIZE);\n            assertEquals(0, value.readerIndex());\n            assertEquals(0, value.writerIndex());\n        }\n\n        random.setSeed(seed);\n        byte[] expectedValueContent = new byte[BLOCK_SIZE * 2];\n        ByteBuf expectedValue = wrappedBuffer(expectedValueContent);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValueContent);\n            int valueOffset = random.nextInt(BLOCK_SIZE);\n            value.setBytes(0, valueContent);\n            assertEquals(i, buffer.readerIndex());\n            assertEquals(CAPACITY, buffer.writerIndex());\n            buffer.readBytes(value, valueOffset, BLOCK_SIZE);\n            for (int j = valueOffset; j < valueOffset + BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue.getByte(j), value.getByte(j));\n            }\n            assertEquals(0, value.readerIndex());\n            assertEquals(0, value.writerIndex());\n        }\n    }\n\n    @Test\n    public void testSequentialByteBufferBackedHeapBufferTransfer2() {\n        byte[] valueContent = new byte[BLOCK_SIZE * 2];\n        ByteBuf value = wrappedBuffer(ByteBuffer.allocate(BLOCK_SIZE * 2));\n        value.writerIndex(0);\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(valueContent);\n            value.setBytes(0, valueContent);\n            assertEquals(0, buffer.readerIndex());\n            assertEquals(i, buffer.writerIndex());\n            int readerIndex = random.nextInt(BLOCK_SIZE);\n            value.readerIndex(0);\n            value.writerIndex(readerIndex + BLOCK_SIZE);\n            value.readerIndex(readerIndex);\n            buffer.writeBytes(value);\n            assertEquals(readerIndex + BLOCK_SIZE, value.writerIndex());\n            assertEquals(value.writerIndex(), value.readerIndex());\n        }\n\n        random.setSeed(seed);\n        byte[] expectedValueContent = new byte[BLOCK_SIZE * 2];\n        ByteBuf expectedValue = wrappedBuffer(expectedValueContent);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValueContent);\n            value.setBytes(0, valueContent);\n            int valueOffset = random.nextInt(BLOCK_SIZE);\n            assertEquals(i, buffer.readerIndex());\n            assertEquals(CAPACITY, buffer.writerIndex());\n            value.readerIndex(valueOffset);\n            value.writerIndex(valueOffset);\n            buffer.readBytes(value, BLOCK_SIZE);\n            for (int j = valueOffset; j < valueOffset + BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue.getByte(j), value.getByte(j));\n            }\n            assertEquals(valueOffset, value.readerIndex());\n            assertEquals(valueOffset + BLOCK_SIZE, value.writerIndex());\n        }\n    }\n\n    @Test\n    public void testSequentialByteBufferTransfer() {\n        buffer.writerIndex(0);\n        ByteBuffer value = ByteBuffer.allocate(BLOCK_SIZE * 2);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(value.array());\n            value.clear().position(random.nextInt(BLOCK_SIZE));\n            value.limit(value.position() + BLOCK_SIZE);\n            buffer.writeBytes(value);\n        }\n\n        random.setSeed(seed);\n        ByteBuffer expectedValue = ByteBuffer.allocate(BLOCK_SIZE * 2);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValue.array());\n            int valueOffset = random.nextInt(BLOCK_SIZE);\n            value.clear().position(valueOffset).limit(valueOffset + BLOCK_SIZE);\n            buffer.readBytes(value);\n            assertEquals(valueOffset + BLOCK_SIZE, value.position());\n            for (int j = valueOffset; j < valueOffset + BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue.get(j), value.get(j));\n            }\n        }\n    }\n\n    @Test\n    public void testSequentialCopiedBufferTransfer1() {\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            byte[] value = new byte[BLOCK_SIZE];\n            random.nextBytes(value);\n            assertEquals(0, buffer.readerIndex());\n            assertEquals(i, buffer.writerIndex());\n            buffer.writeBytes(value);\n        }\n\n        random.setSeed(seed);\n        byte[] expectedValue = new byte[BLOCK_SIZE];\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValue);\n            assertEquals(i, buffer.readerIndex());\n            assertEquals(CAPACITY, buffer.writerIndex());\n            ByteBuf actualValue = buffer.readBytes(BLOCK_SIZE);\n            assertEquals(wrappedBuffer(expectedValue), actualValue);\n\n            // Make sure if it is a copied buffer.\n            actualValue.setByte(0, (byte) (actualValue.getByte(0) + 1));\n            assertFalse(buffer.getByte(i) == actualValue.getByte(0));\n            actualValue.release();\n        }\n    }\n\n    @Test\n    public void testSequentialSlice1() {\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            byte[] value = new byte[BLOCK_SIZE];\n            random.nextBytes(value);\n            assertEquals(0, buffer.readerIndex());\n            assertEquals(i, buffer.writerIndex());\n            buffer.writeBytes(value);\n        }\n\n        random.setSeed(seed);\n        byte[] expectedValue = new byte[BLOCK_SIZE];\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValue);\n            assertEquals(i, buffer.readerIndex());\n            assertEquals(CAPACITY, buffer.writerIndex());\n            ByteBuf actualValue = buffer.readSlice(BLOCK_SIZE);\n            assertEquals(buffer.order(), actualValue.order());\n            assertEquals(wrappedBuffer(expectedValue), actualValue);\n\n            // Make sure if it is a sliced buffer.\n            actualValue.setByte(0, (byte) (actualValue.getByte(0) + 1));\n            assertEquals(buffer.getByte(i), actualValue.getByte(0));\n        }\n    }\n\n    @Test\n    public void testWriteZero() {\n        try {\n            buffer.writeZero(-1);\n            fail();\n        } catch (IllegalArgumentException e) {\n            // Expected\n        }\n\n        buffer.clear();\n        while (buffer.isWritable()) {\n            buffer.writeByte((byte) 0xFF);\n        }\n\n        buffer.clear();\n        for (int i = 0; i < buffer.capacity();) {\n            int length = Math.min(buffer.capacity() - i, random.nextInt(32));\n            buffer.writeZero(length);\n            i += length;\n        }\n\n        assertEquals(0, buffer.readerIndex());\n        assertEquals(buffer.capacity(), buffer.writerIndex());\n\n        for (int i = 0; i < buffer.capacity(); i ++) {\n            assertEquals(0, buffer.getByte(i));\n        }\n    }\n\n    @Test\n    public void testDiscardReadBytes() {\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity(); i += 4) {\n            buffer.writeInt(i);\n        }\n        ByteBuf copy = copiedBuffer(buffer);\n\n        // Make sure there's no effect if called when readerIndex is 0.\n        buffer.readerIndex(CAPACITY / 4);\n        buffer.markReaderIndex();\n        buffer.writerIndex(CAPACITY / 3);\n        buffer.markWriterIndex();\n        buffer.readerIndex(0);\n        buffer.writerIndex(CAPACITY / 2);\n        buffer.discardReadBytes();\n\n        assertEquals(0, buffer.readerIndex());\n        assertEquals(CAPACITY / 2, buffer.writerIndex());\n        assertEquals(copy.slice(0, CAPACITY / 2), buffer.slice(0, CAPACITY / 2));\n        buffer.resetReaderIndex();\n        assertEquals(CAPACITY / 4, buffer.readerIndex());\n        buffer.resetWriterIndex();\n        assertEquals(CAPACITY / 3, buffer.writerIndex());\n\n        // Make sure bytes after writerIndex is not copied.\n        buffer.readerIndex(1);\n        buffer.writerIndex(CAPACITY / 2);\n        buffer.discardReadBytes();\n\n        assertEquals(0, buffer.readerIndex());\n        assertEquals(CAPACITY / 2 - 1, buffer.writerIndex());\n        assertEquals(copy.slice(1, CAPACITY / 2 - 1), buffer.slice(0, CAPACITY / 2 - 1));\n\n        if (discardReadBytesDoesNotMoveWritableBytes()) {\n            // If writable bytes were copied, the test should fail to avoid unnecessary memory bandwidth consumption.\n            assertFalse(copy.slice(CAPACITY / 2, CAPACITY / 2).equals(buffer.slice(CAPACITY / 2 - 1, CAPACITY / 2)));\n        } else {\n            assertEquals(copy.slice(CAPACITY / 2, CAPACITY / 2), buffer.slice(CAPACITY / 2 - 1, CAPACITY / 2));\n        }\n\n        // Marks also should be relocated.\n        buffer.resetReaderIndex();\n        assertEquals(CAPACITY / 4 - 1, buffer.readerIndex());\n        buffer.resetWriterIndex();\n        assertEquals(CAPACITY / 3 - 1, buffer.writerIndex());\n        copy.release();\n    }\n\n    /**\n     * The similar test case with {@link #testDiscardReadBytes()} but this one\n     * discards a large chunk at once.\n     */\n    @Test\n    public void testDiscardReadBytes2() {\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity(); i ++) {\n            buffer.writeByte((byte) i);\n        }\n        ByteBuf copy = copiedBuffer(buffer);\n\n        // Discard the first (CAPACITY / 2 - 1) bytes.\n        buffer.setIndex(CAPACITY / 2 - 1, CAPACITY - 1);\n        buffer.discardReadBytes();\n        assertEquals(0, buffer.readerIndex());\n        assertEquals(CAPACITY / 2, buffer.writerIndex());\n        for (int i = 0; i < CAPACITY / 2; i ++) {\n            assertEquals(copy.slice(CAPACITY / 2 - 1 + i, CAPACITY / 2 - i), buffer.slice(i, CAPACITY / 2 - i));\n        }\n        copy.release();\n    }\n\n    @Test\n    public void testStreamTransfer1() throws Exception {\n        byte[] expected = new byte[buffer.capacity()];\n        random.nextBytes(expected);\n\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            ByteArrayInputStream in = new ByteArrayInputStream(expected, i, BLOCK_SIZE);\n            assertEquals(BLOCK_SIZE, buffer.setBytes(i, in, BLOCK_SIZE));\n            assertEquals(-1, buffer.setBytes(i, in, 0));\n        }\n\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            buffer.getBytes(i, out, BLOCK_SIZE);\n        }\n\n        assertTrue(Arrays.equals(expected, out.toByteArray()));\n    }\n\n    @Test\n    public void testStreamTransfer2() throws Exception {\n        byte[] expected = new byte[buffer.capacity()];\n        random.nextBytes(expected);\n        buffer.clear();\n\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            ByteArrayInputStream in = new ByteArrayInputStream(expected, i, BLOCK_SIZE);\n            assertEquals(i, buffer.writerIndex());\n            buffer.writeBytes(in, BLOCK_SIZE);\n            assertEquals(i + BLOCK_SIZE, buffer.writerIndex());\n        }\n\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            assertEquals(i, buffer.readerIndex());\n            buffer.readBytes(out, BLOCK_SIZE);\n            assertEquals(i + BLOCK_SIZE, buffer.readerIndex());\n        }\n\n        assertTrue(Arrays.equals(expected, out.toByteArray()));\n    }\n\n    @Test\n    public void testCopy() {\n        for (int i = 0; i < buffer.capacity(); i ++) {\n            byte value = (byte) random.nextInt();\n            buffer.setByte(i, value);\n        }\n\n        final int readerIndex = CAPACITY / 3;\n        final int writerIndex = CAPACITY * 2 / 3;\n        buffer.setIndex(readerIndex, writerIndex);\n\n        // Make sure all properties are copied.\n        ByteBuf copy = buffer.copy();\n        assertEquals(0, copy.readerIndex());\n        assertEquals(buffer.readableBytes(), copy.writerIndex());\n        assertEquals(buffer.readableBytes(), copy.capacity());\n        assertSame(buffer.order(), copy.order());\n        for (int i = 0; i < copy.capacity(); i ++) {\n            assertEquals(buffer.getByte(i + readerIndex), copy.getByte(i));\n        }\n\n        // Make sure the buffer content is independent from each other.\n        buffer.setByte(readerIndex, (byte) (buffer.getByte(readerIndex) + 1));\n        assertTrue(buffer.getByte(readerIndex) != copy.getByte(0));\n        copy.setByte(1, (byte) (copy.getByte(1) + 1));\n        assertTrue(buffer.getByte(readerIndex + 1) != copy.getByte(1));\n        copy.release();\n    }\n\n    @Test\n    public void testDuplicate() {\n        for (int i = 0; i < buffer.capacity(); i ++) {\n            byte value = (byte) random.nextInt();\n            buffer.setByte(i, value);\n        }\n\n        final int readerIndex = CAPACITY / 3;\n        final int writerIndex = CAPACITY * 2 / 3;\n        buffer.setIndex(readerIndex, writerIndex);\n\n        // Make sure all properties are copied.\n        ByteBuf duplicate = buffer.duplicate();\n        assertSame(buffer.order(), duplicate.order());\n        assertEquals(buffer.readableBytes(), duplicate.readableBytes());\n        assertEquals(0, buffer.compareTo(duplicate));\n\n        // Make sure the buffer content is shared.\n        buffer.setByte(readerIndex, (byte) (buffer.getByte(readerIndex) + 1));\n        assertEquals(buffer.getByte(readerIndex), duplicate.getByte(duplicate.readerIndex()));\n        duplicate.setByte(duplicate.readerIndex(), (byte) (duplicate.getByte(duplicate.readerIndex()) + 1));\n        assertEquals(buffer.getByte(readerIndex), duplicate.getByte(duplicate.readerIndex()));\n    }\n\n    @Test\n    public void testSliceEndianness() throws Exception {\n        assertEquals(buffer.order(), buffer.slice(0, buffer.capacity()).order());\n        assertEquals(buffer.order(), buffer.slice(0, buffer.capacity() - 1).order());\n        assertEquals(buffer.order(), buffer.slice(1, buffer.capacity() - 1).order());\n        assertEquals(buffer.order(), buffer.slice(1, buffer.capacity() - 2).order());\n    }\n\n    @Test\n    public void testSliceIndex() throws Exception {\n        assertEquals(0, buffer.slice(0, buffer.capacity()).readerIndex());\n        assertEquals(0, buffer.slice(0, buffer.capacity() - 1).readerIndex());\n        assertEquals(0, buffer.slice(1, buffer.capacity() - 1).readerIndex());\n        assertEquals(0, buffer.slice(1, buffer.capacity() - 2).readerIndex());\n\n        assertEquals(buffer.capacity(), buffer.slice(0, buffer.capacity()).writerIndex());\n        assertEquals(buffer.capacity() - 1, buffer.slice(0, buffer.capacity() - 1).writerIndex());\n        assertEquals(buffer.capacity() - 1, buffer.slice(1, buffer.capacity() - 1).writerIndex());\n        assertEquals(buffer.capacity() - 2, buffer.slice(1, buffer.capacity() - 2).writerIndex());\n    }\n\n    @Test\n    public void testRetainedSliceIndex() throws Exception {\n        ByteBuf retainedSlice = buffer.retainedSlice(0, buffer.capacity());\n        assertEquals(0, retainedSlice.readerIndex());\n        retainedSlice.release();\n\n        retainedSlice = buffer.retainedSlice(0, buffer.capacity() - 1);\n        assertEquals(0, retainedSlice.readerIndex());\n        retainedSlice.release();\n\n        retainedSlice = buffer.retainedSlice(1, buffer.capacity() - 1);\n        assertEquals(0, retainedSlice.readerIndex());\n        retainedSlice.release();\n\n        retainedSlice = buffer.retainedSlice(1, buffer.capacity() - 2);\n        assertEquals(0, retainedSlice.readerIndex());\n        retainedSlice.release();\n\n        retainedSlice = buffer.retainedSlice(0, buffer.capacity());\n        assertEquals(buffer.capacity(), retainedSlice.writerIndex());\n        retainedSlice.release();\n\n        retainedSlice = buffer.retainedSlice(0, buffer.capacity() - 1);\n        assertEquals(buffer.capacity() - 1, retainedSlice.writerIndex());\n        retainedSlice.release();\n\n        retainedSlice = buffer.retainedSlice(1, buffer.capacity() - 1);\n        assertEquals(buffer.capacity() - 1, retainedSlice.writerIndex());\n        retainedSlice.release();\n\n        retainedSlice = buffer.retainedSlice(1, buffer.capacity() - 2);\n        assertEquals(buffer.capacity() - 2, retainedSlice.writerIndex());\n        retainedSlice.release();\n    }\n\n    @Test\n    @SuppressWarnings(\"ObjectEqualsNull\")\n    public void testEquals() {\n        assertFalse(buffer.equals(null));\n        assertFalse(buffer.equals(new Object()));\n\n        byte[] value = new byte[32];\n        buffer.setIndex(0, value.length);\n        random.nextBytes(value);\n        buffer.setBytes(0, value);\n\n        assertEquals(buffer, wrappedBuffer(value));\n        assertEquals(buffer, wrappedBuffer(value).order(LITTLE_ENDIAN));\n\n        value[0] ++;\n        assertFalse(buffer.equals(wrappedBuffer(value)));\n        assertFalse(buffer.equals(wrappedBuffer(value).order(LITTLE_ENDIAN)));\n    }\n\n    @Test\n    public void testCompareTo() {\n        try {\n            buffer.compareTo(null);\n            fail();\n        } catch (NullPointerException e) {\n            // Expected\n        }\n\n        // Fill the random stuff\n        byte[] value = new byte[32];\n        random.nextBytes(value);\n        // Prevent overflow / underflow\n        if (value[0] == 0) {\n            value[0] ++;\n        } else if (value[0] == -1) {\n            value[0] --;\n        }\n\n        buffer.setIndex(0, value.length);\n        buffer.setBytes(0, value);\n\n        assertEquals(0, buffer.compareTo(wrappedBuffer(value)));\n        assertEquals(0, buffer.compareTo(wrappedBuffer(value).order(LITTLE_ENDIAN)));\n\n        value[0] ++;\n        assertTrue(buffer.compareTo(wrappedBuffer(value)) < 0);\n        assertTrue(buffer.compareTo(wrappedBuffer(value).order(LITTLE_ENDIAN)) < 0);\n        value[0] -= 2;\n        assertTrue(buffer.compareTo(wrappedBuffer(value)) > 0);\n        assertTrue(buffer.compareTo(wrappedBuffer(value).order(LITTLE_ENDIAN)) > 0);\n        value[0] ++;\n\n        assertTrue(buffer.compareTo(wrappedBuffer(value, 0, 31)) > 0);\n        assertTrue(buffer.compareTo(wrappedBuffer(value, 0, 31).order(LITTLE_ENDIAN)) > 0);\n        assertTrue(buffer.slice(0, 31).compareTo(wrappedBuffer(value)) < 0);\n        assertTrue(buffer.slice(0, 31).compareTo(wrappedBuffer(value).order(LITTLE_ENDIAN)) < 0);\n\n        ByteBuf retainedSlice = buffer.retainedSlice(0, 31);\n        assertTrue(retainedSlice.compareTo(wrappedBuffer(value)) < 0);\n        retainedSlice.release();\n\n        retainedSlice = buffer.retainedSlice(0, 31);\n        assertTrue(retainedSlice.compareTo(wrappedBuffer(value).order(LITTLE_ENDIAN)) < 0);\n        retainedSlice.release();\n    }\n\n    @Test\n    public void testCompareTo2() {\n        byte[] bytes = {1, 2, 3, 4};\n        byte[] bytesReversed = {4, 3, 2, 1};\n\n        ByteBuf buf1 = newBuffer(4).clear().writeBytes(bytes).order(ByteOrder.LITTLE_ENDIAN);\n        ByteBuf buf2 = newBuffer(4).clear().writeBytes(bytesReversed).order(ByteOrder.LITTLE_ENDIAN);\n        ByteBuf buf3 = newBuffer(4).clear().writeBytes(bytes).order(ByteOrder.BIG_ENDIAN);\n        ByteBuf buf4 = newBuffer(4).clear().writeBytes(bytesReversed).order(ByteOrder.BIG_ENDIAN);\n        try {\n            assertEquals(buf1.compareTo(buf2), buf3.compareTo(buf4));\n            assertEquals(buf2.compareTo(buf1), buf4.compareTo(buf3));\n            assertEquals(buf1.compareTo(buf3), buf2.compareTo(buf4));\n            assertEquals(buf3.compareTo(buf1), buf4.compareTo(buf2));\n        } finally {\n            buf1.release();\n            buf2.release();\n            buf3.release();\n            buf4.release();\n        }\n    }\n\n    @Test\n    public void testToString() {\n        ByteBuf copied = copiedBuffer(\"Hello, World!\", CharsetUtil.ISO_8859_1);\n        buffer.clear();\n        buffer.writeBytes(copied);\n        assertEquals(\"Hello, World!\", buffer.toString(CharsetUtil.ISO_8859_1));\n        copied.release();\n    }\n\n    @Test(timeout = 10000)\n    public void testToStringMultipleThreads() throws Throwable {\n        buffer.clear();\n        buffer.writeBytes(\"Hello, World!\".getBytes(CharsetUtil.ISO_8859_1));\n\n        final AtomicInteger counter = new AtomicInteger(30000);\n        final AtomicReference<Throwable> errorRef = new AtomicReference<Throwable>();\n        List<Thread> threads = new ArrayList<Thread>();\n        for (int i = 0; i < 10; i++) {\n            Thread thread = new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        while (errorRef.get() == null && counter.decrementAndGet() > 0) {\n                            assertEquals(\"Hello, World!\", buffer.toString(CharsetUtil.ISO_8859_1));\n                        }\n                    } catch (Throwable cause) {\n                        errorRef.compareAndSet(null, cause);\n                    }\n                }\n            });\n            threads.add(thread);\n        }\n        for (Thread thread : threads) {\n            thread.start();\n        }\n\n        for (Thread thread : threads) {\n            thread.join();\n        }\n\n        Throwable error = errorRef.get();\n        if (error != null) {\n            throw error;\n        }\n    }\n\n    @Test\n    public void testSWARIndexOf() {\n        ByteBuf buffer = newBuffer(16);\n        buffer.clear();\n        // Ensure the buffer is completely zero'ed.\n        buffer.setZero(0, buffer.capacity());\n        buffer.writeByte((byte) 0); // 0\n        buffer.writeByte((byte) 0);\n        buffer.writeByte((byte) 0);\n        buffer.writeByte((byte) 0);\n        buffer.writeByte((byte) 0);\n        buffer.writeByte((byte) 0);\n        buffer.writeByte((byte) 0);\n        buffer.writeByte((byte) 0); // 7\n\n        buffer.writeByte((byte) 0);\n        buffer.writeByte((byte) 0);\n        buffer.writeByte((byte) 0);\n        buffer.writeByte((byte) 1); // 11\n        buffer.writeByte((byte) 2);\n        buffer.writeByte((byte) 3);\n        buffer.writeByte((byte) 4);\n        buffer.writeByte((byte) 1);\n        assertEquals(11, buffer.indexOf(0, 12, (byte) 1));\n        assertEquals(12, buffer.indexOf(0, 16, (byte) 2));\n        assertEquals(-1, buffer.indexOf(0, 11, (byte) 1));\n        assertEquals(11, buffer.indexOf(0, 16, (byte) 1));\n        buffer.release();\n    }\n\n    @Test\n    public void testIndexOf() {\n        buffer.clear();\n        // Ensure the buffer is completely zero'ed.\n        buffer.setZero(0, buffer.capacity());\n\n        buffer.writeByte((byte) 1);\n        buffer.writeByte((byte) 2);\n        buffer.writeByte((byte) 3);\n        buffer.writeByte((byte) 2);\n        buffer.writeByte((byte) 1);\n\n        assertEquals(-1, buffer.indexOf(1, 4, (byte) 1));\n        assertEquals(-1, buffer.indexOf(4, 1, (byte) 1));\n        assertEquals(1, buffer.indexOf(1, 4, (byte) 2));\n        assertEquals(3, buffer.indexOf(4, 1, (byte) 2));\n\n        try {\n            buffer.indexOf(0, buffer.capacity() + 1, (byte) 0);\n            fail();\n        } catch (IndexOutOfBoundsException expected) {\n            // expected\n        }\n\n        try {\n            buffer.indexOf(buffer.capacity(), -1, (byte) 0);\n            fail();\n        } catch (IndexOutOfBoundsException expected) {\n            // expected\n        }\n\n        assertEquals(4, buffer.indexOf(buffer.capacity() + 1, 0, (byte) 1));\n        assertEquals(0, buffer.indexOf(-1, buffer.capacity(), (byte) 1));\n    }\n\n    @Test\n    public void testIndexOfReleaseBuffer() {\n        ByteBuf buffer = releasedBuffer();\n        if (buffer.capacity() != 0) {\n            try {\n                buffer.indexOf(0, 1, (byte) 1);\n                fail();\n            } catch (IllegalReferenceCountException expected) {\n                // expected\n            }\n        } else {\n            assertEquals(-1, buffer.indexOf(0, 1, (byte) 1));\n        }\n    }\n\n    @Test\n    public void testNioBuffer1() {\n        assumeTrue(buffer.nioBufferCount() == 1);\n\n        byte[] value = new byte[buffer.capacity()];\n        random.nextBytes(value);\n        buffer.clear();\n        buffer.writeBytes(value);\n\n        assertRemainingEquals(ByteBuffer.wrap(value), buffer.nioBuffer());\n    }\n\n    @Test\n    public void testToByteBuffer2() {\n        assumeTrue(buffer.nioBufferCount() == 1);\n\n        byte[] value = new byte[buffer.capacity()];\n        random.nextBytes(value);\n        buffer.clear();\n        buffer.writeBytes(value);\n\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            assertRemainingEquals(ByteBuffer.wrap(value, i, BLOCK_SIZE), buffer.nioBuffer(i, BLOCK_SIZE));\n        }\n    }\n\n    private static void assertRemainingEquals(ByteBuffer expected, ByteBuffer actual) {\n        int remaining = expected.remaining();\n        int remaining2 = actual.remaining();\n\n        assertEquals(remaining, remaining2);\n        byte[] array1 = new byte[remaining];\n        byte[] array2 = new byte[remaining2];\n        expected.get(array1);\n        actual.get(array2);\n        assertArrayEquals(array1, array2);\n    }\n\n    @Test\n    public void testToByteBuffer3() {\n        assumeTrue(buffer.nioBufferCount() == 1);\n\n        assertEquals(buffer.order(), buffer.nioBuffer().order());\n    }\n\n    @Test\n    public void testSkipBytes1() {\n        buffer.setIndex(CAPACITY / 4, CAPACITY / 2);\n\n        buffer.skipBytes(CAPACITY / 4);\n        assertEquals(CAPACITY / 4 * 2, buffer.readerIndex());\n\n        try {\n            buffer.skipBytes(CAPACITY / 4 + 1);\n            fail();\n        } catch (IndexOutOfBoundsException e) {\n            // Expected\n        }\n\n        // Should remain unchanged.\n        assertEquals(CAPACITY / 4 * 2, buffer.readerIndex());\n    }\n\n    @Test\n    public void testHashCode() {\n        ByteBuf elemA = buffer(15);\n        ByteBuf elemB = directBuffer(15);\n        elemA.writeBytes(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5 });\n        elemB.writeBytes(new byte[] { 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 9 });\n\n        Set<ByteBuf> set = new HashSet<ByteBuf>();\n        set.add(elemA);\n        set.add(elemB);\n\n        assertEquals(2, set.size());\n        ByteBuf elemACopy = elemA.copy();\n        assertTrue(set.contains(elemACopy));\n\n        ByteBuf elemBCopy = elemB.copy();\n        assertTrue(set.contains(elemBCopy));\n\n        buffer.clear();\n        buffer.writeBytes(elemA.duplicate());\n\n        assertTrue(set.remove(buffer));\n        assertFalse(set.contains(elemA));\n        assertEquals(1, set.size());\n\n        buffer.clear();\n        buffer.writeBytes(elemB.duplicate());\n        assertTrue(set.remove(buffer));\n        assertFalse(set.contains(elemB));\n        assertEquals(0, set.size());\n        elemA.release();\n        elemB.release();\n        elemACopy.release();\n        elemBCopy.release();\n    }\n\n    // Test case for https://github.com/netty/netty/issues/325\n    @Test\n    public void testDiscardAllReadBytes() {\n        buffer.writerIndex(buffer.capacity());\n        buffer.readerIndex(buffer.writerIndex());\n        buffer.discardReadBytes();\n    }\n\n    @Test\n    public void testForEachByte() {\n        buffer.clear();\n        for (int i = 0; i < CAPACITY; i ++) {\n            buffer.writeByte(i + 1);\n        }\n\n        final AtomicInteger lastIndex = new AtomicInteger();\n        buffer.setIndex(CAPACITY / 4, CAPACITY * 3 / 4);\n        assertThat(buffer.forEachByte(new ByteProcessor() {\n            int i = CAPACITY / 4;\n\n            @Override\n            public boolean process(byte value) throws Exception {\n                assertThat(value, is((byte) (i + 1)));\n                lastIndex.set(i);\n                i ++;\n                return true;\n            }\n        }), is(-1));\n\n        assertThat(lastIndex.get(), is(CAPACITY * 3 / 4 - 1));\n    }\n\n    @Test\n    public void testForEachByteAbort() {\n        buffer.clear();\n        for (int i = 0; i < CAPACITY; i ++) {\n            buffer.writeByte(i + 1);\n        }\n\n        final int stop = CAPACITY / 2;\n        assertThat(buffer.forEachByte(CAPACITY / 3, CAPACITY / 3, new ByteProcessor() {\n            int i = CAPACITY / 3;\n\n            @Override\n            public boolean process(byte value) throws Exception {\n                assertThat(value, is((byte) (i + 1)));\n                if (i == stop) {\n                    return false;\n                }\n\n                i++;\n                return true;\n            }\n        }), is(stop));\n    }\n\n    @Test\n    public void testForEachByteDesc() {\n        buffer.clear();\n        for (int i = 0; i < CAPACITY; i ++) {\n            buffer.writeByte(i + 1);\n        }\n\n        final AtomicInteger lastIndex = new AtomicInteger();\n        assertThat(buffer.forEachByteDesc(CAPACITY / 4, CAPACITY * 2 / 4, new ByteProcessor() {\n            int i = CAPACITY * 3 / 4 - 1;\n\n            @Override\n            public boolean process(byte value) throws Exception {\n                assertThat(value, is((byte) (i + 1)));\n                lastIndex.set(i);\n                i --;\n                return true;\n            }\n        }), is(-1));\n\n        assertThat(lastIndex.get(), is(CAPACITY / 4));\n    }\n\n    @Test\n    public void testInternalNioBuffer() {\n        testInternalNioBuffer(128);\n        testInternalNioBuffer(1024);\n        testInternalNioBuffer(4 * 1024);\n        testInternalNioBuffer(64 * 1024);\n        testInternalNioBuffer(32 * 1024 * 1024);\n        testInternalNioBuffer(64 * 1024 * 1024);\n    }\n\n    private void testInternalNioBuffer(int a) {\n        ByteBuf buffer = newBuffer(2);\n        ByteBuffer buf = buffer.internalNioBuffer(buffer.readerIndex(), 1);\n        assertEquals(1, buf.remaining());\n\n        byte[] data = new byte[a];\n        PlatformDependent.threadLocalRandom().nextBytes(data);\n        buffer.writeBytes(data);\n\n        buf = buffer.internalNioBuffer(buffer.readerIndex(), a);\n        assertEquals(a, buf.remaining());\n\n        for (int i = 0; i < a; i++) {\n            assertEquals(data[i], buf.get());\n        }\n        assertFalse(buf.hasRemaining());\n        buffer.release();\n    }\n\n    @Test\n    public void testDuplicateReadGatheringByteChannelMultipleThreads() throws Exception {\n        testReadGatheringByteChannelMultipleThreads(false);\n    }\n\n    @Test\n    public void testSliceReadGatheringByteChannelMultipleThreads() throws Exception {\n        testReadGatheringByteChannelMultipleThreads(true);\n    }\n\n    private void testReadGatheringByteChannelMultipleThreads(final boolean slice) throws Exception {\n        final byte[] bytes = new byte[8];\n        random.nextBytes(bytes);\n\n        final ByteBuf buffer = newBuffer(8);\n        buffer.writeBytes(bytes);\n        final CountDownLatch latch = new CountDownLatch(60000);\n        final CyclicBarrier barrier = new CyclicBarrier(11);\n        for (int i = 0; i < 10; i++) {\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    while (latch.getCount() > 0) {\n                        ByteBuf buf;\n                        if (slice) {\n                           buf = buffer.slice();\n                        } else {\n                           buf = buffer.duplicate();\n                        }\n                        TestGatheringByteChannel channel = new TestGatheringByteChannel();\n\n                        while (buf.isReadable()) {\n                            try {\n                                buf.readBytes(channel, buf.readableBytes());\n                            } catch (IOException e) {\n                                // Never happens\n                                return;\n                            }\n                        }\n                        assertArrayEquals(bytes, channel.writtenBytes());\n                        latch.countDown();\n                    }\n                    try {\n                        barrier.await();\n                    } catch (Exception e) {\n                        // ignore\n                    }\n                }\n            }).start();\n        }\n        latch.await(10, TimeUnit.SECONDS);\n        barrier.await(5, TimeUnit.SECONDS);\n        buffer.release();\n    }\n\n    @Test\n    public void testDuplicateReadOutputStreamMultipleThreads() throws Exception {\n        testReadOutputStreamMultipleThreads(false);\n    }\n\n    @Test\n    public void testSliceReadOutputStreamMultipleThreads() throws Exception {\n        testReadOutputStreamMultipleThreads(true);\n    }\n\n    private void testReadOutputStreamMultipleThreads(final boolean slice) throws Exception {\n        final byte[] bytes = new byte[8];\n        random.nextBytes(bytes);\n\n        final ByteBuf buffer = newBuffer(8);\n        buffer.writeBytes(bytes);\n        final CountDownLatch latch = new CountDownLatch(60000);\n        final CyclicBarrier barrier = new CyclicBarrier(11);\n        for (int i = 0; i < 10; i++) {\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    while (latch.getCount() > 0) {\n                        ByteBuf buf;\n                        if (slice) {\n                            buf = buffer.slice();\n                        } else {\n                            buf = buffer.duplicate();\n                        }\n                        ByteArrayOutputStream out = new ByteArrayOutputStream();\n\n                        while (buf.isReadable()) {\n                            try {\n                                buf.readBytes(out, buf.readableBytes());\n                            } catch (IOException e) {\n                                // Never happens\n                                return;\n                            }\n                        }\n                        assertArrayEquals(bytes, out.toByteArray());\n                        latch.countDown();\n                    }\n                    try {\n                        barrier.await();\n                    } catch (Exception e) {\n                        // ignore\n                    }\n                }\n            }).start();\n        }\n        latch.await(10, TimeUnit.SECONDS);\n        barrier.await(5, TimeUnit.SECONDS);\n        buffer.release();\n    }\n\n    @Test\n    public void testDuplicateBytesInArrayMultipleThreads() throws Exception {\n        testBytesInArrayMultipleThreads(false);\n    }\n\n    @Test\n    public void testSliceBytesInArrayMultipleThreads() throws Exception {\n        testBytesInArrayMultipleThreads(true);\n    }\n\n    private void testBytesInArrayMultipleThreads(final boolean slice) throws Exception {\n        final byte[] bytes = new byte[8];\n        random.nextBytes(bytes);\n\n        final ByteBuf buffer = newBuffer(8);\n        buffer.writeBytes(bytes);\n        final AtomicReference<Throwable> cause = new AtomicReference<Throwable>();\n        final CountDownLatch latch = new CountDownLatch(60000);\n        final CyclicBarrier barrier = new CyclicBarrier(11);\n        for (int i = 0; i < 10; i++) {\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    while (cause.get() == null && latch.getCount() > 0) {\n                        ByteBuf buf;\n                        if (slice) {\n                            buf = buffer.slice();\n                        } else {\n                            buf = buffer.duplicate();\n                        }\n\n                        byte[] array = new byte[8];\n                        buf.readBytes(array);\n\n                        assertArrayEquals(bytes, array);\n\n                        Arrays.fill(array, (byte) 0);\n                        buf.getBytes(0, array);\n                        assertArrayEquals(bytes, array);\n\n                        latch.countDown();\n                    }\n                    try {\n                        barrier.await();\n                    } catch (Exception e) {\n                        // ignore\n                    }\n                }\n            }).start();\n        }\n        latch.await(10, TimeUnit.SECONDS);\n        barrier.await(5, TimeUnit.SECONDS);\n        assertNull(cause.get());\n        buffer.release();\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void readByteThrowsIndexOutOfBoundsException() {\n        final ByteBuf buffer = newBuffer(8);\n        try {\n            buffer.writeByte(0);\n            assertEquals((byte) 0, buffer.readByte());\n            buffer.readByte();\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test\n    @SuppressWarnings(\"ForLoopThatDoesntUseLoopVariable\")\n    public void testNioBufferExposeOnlyRegion() {\n        final ByteBuf buffer = newBuffer(8);\n        byte[] data = new byte[8];\n        random.nextBytes(data);\n        buffer.writeBytes(data);\n\n        ByteBuffer nioBuf = buffer.nioBuffer(1, data.length - 2);\n        assertEquals(0, nioBuf.position());\n        assertEquals(6, nioBuf.remaining());\n\n        for (int i = 1; nioBuf.hasRemaining(); i++) {\n            assertEquals(data[i], nioBuf.get());\n        }\n        buffer.release();\n    }\n\n    @Test\n    public void ensureWritableWithForceDoesNotThrow() {\n        ensureWritableDoesNotThrow(true);\n    }\n\n    @Test\n    public void ensureWritableWithOutForceDoesNotThrow() {\n        ensureWritableDoesNotThrow(false);\n    }\n\n    private void ensureWritableDoesNotThrow(boolean force) {\n        final ByteBuf buffer = newBuffer(8);\n        buffer.writerIndex(buffer.capacity());\n        buffer.ensureWritable(8, force);\n        buffer.release();\n    }\n\n    // See:\n    // - https://github.com/netty/netty/issues/2587\n    // - https://github.com/netty/netty/issues/2580\n    @Test\n    public void testLittleEndianWithExpand() {\n        ByteBuf buffer = newBuffer(0).order(LITTLE_ENDIAN);\n        buffer.writeInt(0x12345678);\n        assertEquals(\"78563412\", ByteBufUtil.hexDump(buffer));\n        buffer.release();\n    }\n\n    private ByteBuf releasedBuffer() {\n        ByteBuf buffer = newBuffer(8);\n        // Clear the buffer so we are sure the reader and writer indices are 0.\n        // This is important as we may return a slice from newBuffer(...).\n        buffer.clear();\n        assertTrue(buffer.release());\n        return buffer;\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testDiscardReadBytesAfterRelease() {\n        releasedBuffer().discardReadBytes();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testDiscardSomeReadBytesAfterRelease() {\n        releasedBuffer().discardSomeReadBytes();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testEnsureWritableAfterRelease() {\n        releasedBuffer().ensureWritable(16);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetBooleanAfterRelease() {\n        releasedBuffer().getBoolean(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetByteAfterRelease() {\n        releasedBuffer().getByte(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetUnsignedByteAfterRelease() {\n        releasedBuffer().getUnsignedByte(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetShortAfterRelease() {\n        releasedBuffer().getShort(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetShortLEAfterRelease() {\n        releasedBuffer().getShortLE(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetUnsignedShortAfterRelease() {\n        releasedBuffer().getUnsignedShort(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetUnsignedShortLEAfterRelease() {\n        releasedBuffer().getUnsignedShortLE(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetMediumAfterRelease() {\n        releasedBuffer().getMedium(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetMediumLEAfterRelease() {\n        releasedBuffer().getMediumLE(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetUnsignedMediumAfterRelease() {\n        releasedBuffer().getUnsignedMedium(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetIntAfterRelease() {\n        releasedBuffer().getInt(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetIntLEAfterRelease() {\n        releasedBuffer().getIntLE(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetUnsignedIntAfterRelease() {\n        releasedBuffer().getUnsignedInt(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetUnsignedIntLEAfterRelease() {\n        releasedBuffer().getUnsignedIntLE(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetLongAfterRelease() {\n        releasedBuffer().getLong(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetLongLEAfterRelease() {\n        releasedBuffer().getLongLE(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetCharAfterRelease() {\n        releasedBuffer().getChar(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetFloatAfterRelease() {\n        releasedBuffer().getFloat(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetFloatLEAfterRelease() {\n        releasedBuffer().getFloatLE(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetDoubleAfterRelease() {\n        releasedBuffer().getDouble(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetDoubleLEAfterRelease() {\n        releasedBuffer().getDoubleLE(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetBytesAfterRelease() {\n        ByteBuf buffer = buffer(8);\n        try {\n            releasedBuffer().getBytes(0, buffer);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetBytesAfterRelease2() {\n        ByteBuf buffer = buffer();\n        try {\n            releasedBuffer().getBytes(0, buffer, 1);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetBytesAfterRelease3() {\n        ByteBuf buffer = buffer();\n        try {\n            releasedBuffer().getBytes(0, buffer, 0, 1);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetBytesAfterRelease4() {\n        releasedBuffer().getBytes(0, new byte[8]);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetBytesAfterRelease5() {\n        releasedBuffer().getBytes(0, new byte[8], 0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetBytesAfterRelease6() {\n        releasedBuffer().getBytes(0, ByteBuffer.allocate(8));\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetBytesAfterRelease7() throws IOException {\n        releasedBuffer().getBytes(0, new ByteArrayOutputStream(), 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetBytesAfterRelease8() throws IOException {\n        releasedBuffer().getBytes(0, new DevNullGatheringByteChannel(), 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetBooleanAfterRelease() {\n        releasedBuffer().setBoolean(0, true);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetByteAfterRelease() {\n        releasedBuffer().setByte(0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetShortAfterRelease() {\n        releasedBuffer().setShort(0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetShortLEAfterRelease() {\n        releasedBuffer().setShortLE(0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetMediumAfterRelease() {\n        releasedBuffer().setMedium(0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetMediumLEAfterRelease() {\n        releasedBuffer().setMediumLE(0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetIntAfterRelease() {\n        releasedBuffer().setInt(0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetIntLEAfterRelease() {\n        releasedBuffer().setIntLE(0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetLongAfterRelease() {\n        releasedBuffer().setLong(0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetLongLEAfterRelease() {\n        releasedBuffer().setLongLE(0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetCharAfterRelease() {\n        releasedBuffer().setChar(0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetFloatAfterRelease() {\n        releasedBuffer().setFloat(0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetDoubleAfterRelease() {\n        releasedBuffer().setDouble(0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetBytesAfterRelease() {\n        ByteBuf buffer = buffer();\n        try {\n            releasedBuffer().setBytes(0, buffer);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetBytesAfterRelease2() {\n        ByteBuf buffer = buffer();\n        try {\n            releasedBuffer().setBytes(0, buffer, 1);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetBytesAfterRelease3() {\n        ByteBuf buffer = buffer();\n        try {\n            releasedBuffer().setBytes(0, buffer, 0, 1);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetUsAsciiCharSequenceAfterRelease() {\n        testSetCharSequenceAfterRelease0(CharsetUtil.US_ASCII);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetIso88591CharSequenceAfterRelease() {\n        testSetCharSequenceAfterRelease0(CharsetUtil.ISO_8859_1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetUtf8CharSequenceAfterRelease() {\n        testSetCharSequenceAfterRelease0(CharsetUtil.UTF_8);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetUtf16CharSequenceAfterRelease() {\n        testSetCharSequenceAfterRelease0(CharsetUtil.UTF_16);\n    }\n\n    private void testSetCharSequenceAfterRelease0(Charset charset) {\n        releasedBuffer().setCharSequence(0, \"x\", charset);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetBytesAfterRelease4() {\n        releasedBuffer().setBytes(0, new byte[8]);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetBytesAfterRelease5() {\n        releasedBuffer().setBytes(0, new byte[8], 0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetBytesAfterRelease6() {\n        releasedBuffer().setBytes(0, ByteBuffer.allocate(8));\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetBytesAfterRelease7() throws IOException {\n        releasedBuffer().setBytes(0, new ByteArrayInputStream(new byte[8]), 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetBytesAfterRelease8() throws IOException {\n        releasedBuffer().setBytes(0, new TestScatteringByteChannel(), 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetZeroAfterRelease() {\n        releasedBuffer().setZero(0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadBooleanAfterRelease() {\n        releasedBuffer().readBoolean();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadByteAfterRelease() {\n        releasedBuffer().readByte();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadUnsignedByteAfterRelease() {\n        releasedBuffer().readUnsignedByte();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadShortAfterRelease() {\n        releasedBuffer().readShort();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadShortLEAfterRelease() {\n        releasedBuffer().readShortLE();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadUnsignedShortAfterRelease() {\n        releasedBuffer().readUnsignedShort();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadUnsignedShortLEAfterRelease() {\n        releasedBuffer().readUnsignedShortLE();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadMediumAfterRelease() {\n        releasedBuffer().readMedium();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadMediumLEAfterRelease() {\n        releasedBuffer().readMediumLE();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadUnsignedMediumAfterRelease() {\n        releasedBuffer().readUnsignedMedium();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadUnsignedMediumLEAfterRelease() {\n        releasedBuffer().readUnsignedMediumLE();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadIntAfterRelease() {\n        releasedBuffer().readInt();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadIntLEAfterRelease() {\n        releasedBuffer().readIntLE();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadUnsignedIntAfterRelease() {\n        releasedBuffer().readUnsignedInt();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadUnsignedIntLEAfterRelease() {\n        releasedBuffer().readUnsignedIntLE();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadLongAfterRelease() {\n        releasedBuffer().readLong();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadLongLEAfterRelease() {\n        releasedBuffer().readLongLE();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadCharAfterRelease() {\n        releasedBuffer().readChar();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadFloatAfterRelease() {\n        releasedBuffer().readFloat();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadFloatLEAfterRelease() {\n        releasedBuffer().readFloatLE();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadDoubleAfterRelease() {\n        releasedBuffer().readDouble();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadDoubleLEAfterRelease() {\n        releasedBuffer().readDoubleLE();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadBytesAfterRelease() {\n        releasedBuffer().readBytes(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadBytesAfterRelease2() {\n        ByteBuf buffer = buffer(8);\n        try {\n            releasedBuffer().readBytes(buffer);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadBytesAfterRelease3() {\n        ByteBuf buffer = buffer(8);\n        try {\n            releasedBuffer().readBytes(buffer);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadBytesAfterRelease4() {\n        ByteBuf buffer = buffer(8);\n        try {\n            releasedBuffer().readBytes(buffer, 0, 1);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadBytesAfterRelease5() {\n        releasedBuffer().readBytes(new byte[8]);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadBytesAfterRelease6() {\n        releasedBuffer().readBytes(new byte[8], 0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadBytesAfterRelease7() {\n        releasedBuffer().readBytes(ByteBuffer.allocate(8));\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadBytesAfterRelease8() throws IOException {\n        releasedBuffer().readBytes(new ByteArrayOutputStream(), 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadBytesAfterRelease9() throws IOException {\n        releasedBuffer().readBytes(new ByteArrayOutputStream(), 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadBytesAfterRelease10() throws IOException {\n        releasedBuffer().readBytes(new DevNullGatheringByteChannel(), 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteBooleanAfterRelease() {\n        releasedBuffer().writeBoolean(true);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteByteAfterRelease() {\n        releasedBuffer().writeByte(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteShortAfterRelease() {\n        releasedBuffer().writeShort(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteShortLEAfterRelease() {\n        releasedBuffer().writeShortLE(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteMediumAfterRelease() {\n        releasedBuffer().writeMedium(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteMediumLEAfterRelease() {\n        releasedBuffer().writeMediumLE(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteIntAfterRelease() {\n        releasedBuffer().writeInt(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteIntLEAfterRelease() {\n        releasedBuffer().writeIntLE(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteLongAfterRelease() {\n        releasedBuffer().writeLong(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteLongLEAfterRelease() {\n        releasedBuffer().writeLongLE(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteCharAfterRelease() {\n        releasedBuffer().writeChar(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteFloatAfterRelease() {\n        releasedBuffer().writeFloat(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteFloatLEAfterRelease() {\n        releasedBuffer().writeFloatLE(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteDoubleAfterRelease() {\n        releasedBuffer().writeDouble(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteDoubleLEAfterRelease() {\n        releasedBuffer().writeDoubleLE(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteBytesAfterRelease() {\n        ByteBuf buffer = buffer(8);\n        try {\n            releasedBuffer().writeBytes(buffer);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteBytesAfterRelease2() {\n        ByteBuf buffer = copiedBuffer(new byte[8]);\n        try {\n            releasedBuffer().writeBytes(buffer, 1);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteBytesAfterRelease3() {\n        ByteBuf buffer = buffer(8);\n        try {\n            releasedBuffer().writeBytes(buffer, 0, 1);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteBytesAfterRelease4() {\n        releasedBuffer().writeBytes(new byte[8]);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteBytesAfterRelease5() {\n        releasedBuffer().writeBytes(new byte[8], 0 , 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteBytesAfterRelease6() {\n        releasedBuffer().writeBytes(ByteBuffer.allocate(8));\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteBytesAfterRelease7() throws IOException {\n        releasedBuffer().writeBytes(new ByteArrayInputStream(new byte[8]), 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteBytesAfterRelease8() throws IOException {\n        releasedBuffer().writeBytes(new TestScatteringByteChannel(), 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteZeroAfterRelease() throws IOException {\n        releasedBuffer().writeZero(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteUsAsciiCharSequenceAfterRelease() {\n        testWriteCharSequenceAfterRelease0(CharsetUtil.US_ASCII);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteIso88591CharSequenceAfterRelease() {\n        testWriteCharSequenceAfterRelease0(CharsetUtil.ISO_8859_1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteUtf8CharSequenceAfterRelease() {\n        testWriteCharSequenceAfterRelease0(CharsetUtil.UTF_8);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteUtf16CharSequenceAfterRelease() {\n        testWriteCharSequenceAfterRelease0(CharsetUtil.UTF_16);\n    }\n\n    private void testWriteCharSequenceAfterRelease0(Charset charset) {\n        releasedBuffer().writeCharSequence(\"x\", charset);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testForEachByteAfterRelease() {\n        releasedBuffer().forEachByte(new TestByteProcessor());\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testForEachByteAfterRelease1() {\n        releasedBuffer().forEachByte(0, 1, new TestByteProcessor());\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testForEachByteDescAfterRelease() {\n        releasedBuffer().forEachByteDesc(new TestByteProcessor());\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testForEachByteDescAfterRelease1() {\n        releasedBuffer().forEachByteDesc(0, 1, new TestByteProcessor());\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testCopyAfterRelease() {\n        releasedBuffer().copy();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testCopyAfterRelease1() {\n        releasedBuffer().copy();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testNioBufferAfterRelease() {\n        releasedBuffer().nioBuffer();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testNioBufferAfterRelease1() {\n        releasedBuffer().nioBuffer(0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testInternalNioBufferAfterRelease() {\n        ByteBuf releasedBuffer = releasedBuffer();\n        releasedBuffer.internalNioBuffer(releasedBuffer.readerIndex(), 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testNioBuffersAfterRelease() {\n        releasedBuffer().nioBuffers();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testNioBuffersAfterRelease2() {\n        releasedBuffer().nioBuffers(0, 1);\n    }\n\n    @Test\n    public void testArrayAfterRelease() {\n        ByteBuf buf = releasedBuffer();\n        if (buf.hasArray()) {\n            try {\n                buf.array();\n                fail();\n            } catch (IllegalReferenceCountException e) {\n                // expected\n            }\n        }\n    }\n\n    @Test\n    public void testMemoryAddressAfterRelease() {\n        ByteBuf buf = releasedBuffer();\n        if (buf.hasMemoryAddress()) {\n            try {\n                buf.memoryAddress();\n                fail();\n            } catch (IllegalReferenceCountException e) {\n                // expected\n            }\n        }\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSliceAfterRelease() {\n        releasedBuffer().slice();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSliceAfterRelease2() {\n        releasedBuffer().slice(0, 1);\n    }\n\n    private static void assertSliceFailAfterRelease(ByteBuf... bufs) {\n        for (ByteBuf buf : bufs) {\n            if (buf.refCnt() > 0) {\n                buf.release();\n            }\n        }\n        for (ByteBuf buf : bufs) {\n            try {\n                assertEquals(0, buf.refCnt());\n                buf.slice();\n                fail();\n            } catch (IllegalReferenceCountException ignored) {\n                // as expected\n            }\n        }\n    }\n\n    @Test\n    public void testSliceAfterReleaseRetainedSlice() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.retainedSlice(0, 1);\n        assertSliceFailAfterRelease(buf, buf2);\n    }\n\n    @Test\n    public void testSliceAfterReleaseRetainedSliceDuplicate() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.retainedSlice(0, 1);\n        ByteBuf buf3 = buf2.duplicate();\n        assertSliceFailAfterRelease(buf, buf2, buf3);\n    }\n\n    @Test\n    public void testSliceAfterReleaseRetainedSliceRetainedDuplicate() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.retainedSlice(0, 1);\n        ByteBuf buf3 = buf2.retainedDuplicate();\n        assertSliceFailAfterRelease(buf, buf2, buf3);\n    }\n\n    @Test\n    public void testSliceAfterReleaseRetainedDuplicate() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.retainedDuplicate();\n        assertSliceFailAfterRelease(buf, buf2);\n    }\n\n    @Test\n    public void testSliceAfterReleaseRetainedDuplicateSlice() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.retainedDuplicate();\n        ByteBuf buf3 = buf2.slice(0, 1);\n        assertSliceFailAfterRelease(buf, buf2, buf3);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testRetainedSliceAfterRelease() {\n        releasedBuffer().retainedSlice();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testRetainedSliceAfterRelease2() {\n        releasedBuffer().retainedSlice(0, 1);\n    }\n\n    private static void assertRetainedSliceFailAfterRelease(ByteBuf... bufs) {\n        for (ByteBuf buf : bufs) {\n            if (buf.refCnt() > 0) {\n                buf.release();\n            }\n        }\n        for (ByteBuf buf : bufs) {\n            try {\n                assertEquals(0, buf.refCnt());\n                buf.retainedSlice();\n                fail();\n            } catch (IllegalReferenceCountException ignored) {\n                // as expected\n            }\n        }\n    }\n\n    @Test\n    public void testRetainedSliceAfterReleaseRetainedSlice() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.retainedSlice(0, 1);\n        assertRetainedSliceFailAfterRelease(buf, buf2);\n    }\n\n    @Test\n    public void testRetainedSliceAfterReleaseRetainedSliceDuplicate() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.retainedSlice(0, 1);\n        ByteBuf buf3 = buf2.duplicate();\n        assertRetainedSliceFailAfterRelease(buf, buf2, buf3);\n    }\n\n    @Test\n    public void testRetainedSliceAfterReleaseRetainedSliceRetainedDuplicate() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.retainedSlice(0, 1);\n        ByteBuf buf3 = buf2.retainedDuplicate();\n        assertRetainedSliceFailAfterRelease(buf, buf2, buf3);\n    }\n\n    @Test\n    public void testRetainedSliceAfterReleaseRetainedDuplicate() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.retainedDuplicate();\n        assertRetainedSliceFailAfterRelease(buf, buf2);\n    }\n\n    @Test\n    public void testRetainedSliceAfterReleaseRetainedDuplicateSlice() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.retainedDuplicate();\n        ByteBuf buf3 = buf2.slice(0, 1);\n        assertRetainedSliceFailAfterRelease(buf, buf2, buf3);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testDuplicateAfterRelease() {\n        releasedBuffer().duplicate();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testRetainedDuplicateAfterRelease() {\n        releasedBuffer().retainedDuplicate();\n    }\n\n    private static void assertDuplicateFailAfterRelease(ByteBuf... bufs) {\n        for (ByteBuf buf : bufs) {\n            if (buf.refCnt() > 0) {\n                buf.release();\n            }\n        }\n        for (ByteBuf buf : bufs) {\n            try {\n                assertEquals(0, buf.refCnt());\n                buf.duplicate();\n                fail();\n            } catch (IllegalReferenceCountException ignored) {\n                // as expected\n            }\n        }\n    }\n\n    @Test\n    public void testDuplicateAfterReleaseRetainedSliceDuplicate() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.retainedSlice(0, 1);\n        ByteBuf buf3 = buf2.duplicate();\n        assertDuplicateFailAfterRelease(buf, buf2, buf3);\n    }\n\n    @Test\n    public void testDuplicateAfterReleaseRetainedDuplicate() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.retainedDuplicate();\n        assertDuplicateFailAfterRelease(buf, buf2);\n    }\n\n    @Test\n    public void testDuplicateAfterReleaseRetainedDuplicateSlice() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.retainedDuplicate();\n        ByteBuf buf3 = buf2.slice(0, 1);\n        assertDuplicateFailAfterRelease(buf, buf2, buf3);\n    }\n\n    private static void assertRetainedDuplicateFailAfterRelease(ByteBuf... bufs) {\n        for (ByteBuf buf : bufs) {\n            if (buf.refCnt() > 0) {\n                buf.release();\n            }\n        }\n        for (ByteBuf buf : bufs) {\n            try {\n                assertEquals(0, buf.refCnt());\n                buf.retainedDuplicate();\n                fail();\n            } catch (IllegalReferenceCountException ignored) {\n                // as expected\n            }\n        }\n    }\n\n    @Test\n    public void testRetainedDuplicateAfterReleaseRetainedDuplicate() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.retainedDuplicate();\n        assertRetainedDuplicateFailAfterRelease(buf, buf2);\n    }\n\n    @Test\n    public void testRetainedDuplicateAfterReleaseDuplicate() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.duplicate();\n        assertRetainedDuplicateFailAfterRelease(buf, buf2);\n    }\n\n    @Test\n    public void testRetainedDuplicateAfterReleaseRetainedSlice() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.retainedSlice(0, 1);\n        assertRetainedDuplicateFailAfterRelease(buf, buf2);\n    }\n\n    @Test\n    public void testSliceRelease() {\n        ByteBuf buf = newBuffer(8);\n        assertEquals(1, buf.refCnt());\n        assertTrue(buf.slice().release());\n        assertEquals(0, buf.refCnt());\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testReadSliceOutOfBounds() {\n        testReadSliceOutOfBounds(false);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testReadRetainedSliceOutOfBounds() {\n        testReadSliceOutOfBounds(true);\n    }\n\n    private void testReadSliceOutOfBounds(boolean retainedSlice) {\n        ByteBuf buf = newBuffer(100);\n        try {\n            buf.writeZero(50);\n            if (retainedSlice) {\n                buf.readRetainedSlice(51);\n            } else {\n                buf.readSlice(51);\n            }\n            fail();\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test\n    public void testWriteUsAsciiCharSequenceExpand() {\n        testWriteCharSequenceExpand(CharsetUtil.US_ASCII);\n    }\n\n    @Test\n    public void testWriteUtf8CharSequenceExpand() {\n        testWriteCharSequenceExpand(CharsetUtil.UTF_8);\n    }\n\n    @Test\n    public void testWriteIso88591CharSequenceExpand() {\n        testWriteCharSequenceExpand(CharsetUtil.ISO_8859_1);\n    }\n    @Test\n    public void testWriteUtf16CharSequenceExpand() {\n        testWriteCharSequenceExpand(CharsetUtil.UTF_16);\n    }\n\n    private void testWriteCharSequenceExpand(Charset charset) {\n        ByteBuf buf = newBuffer(1);\n        try {\n            int writerIndex = buf.capacity() - 1;\n            buf.writerIndex(writerIndex);\n            int written = buf.writeCharSequence(\"AB\", charset);\n            assertEquals(writerIndex, buf.writerIndex() - written);\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testSetUsAsciiCharSequenceNoExpand() {\n        testSetCharSequenceNoExpand(CharsetUtil.US_ASCII);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testSetUtf8CharSequenceNoExpand() {\n        testSetCharSequenceNoExpand(CharsetUtil.UTF_8);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testSetIso88591CharSequenceNoExpand() {\n        testSetCharSequenceNoExpand(CharsetUtil.ISO_8859_1);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testSetUtf16CharSequenceNoExpand() {\n        testSetCharSequenceNoExpand(CharsetUtil.UTF_16);\n    }\n\n    private void testSetCharSequenceNoExpand(Charset charset) {\n        ByteBuf buf = newBuffer(1);\n        try {\n            buf.setCharSequence(0, \"AB\", charset);\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test\n    public void testSetUsAsciiCharSequence() {\n        testSetGetCharSequence(CharsetUtil.US_ASCII);\n    }\n\n    @Test\n    public void testSetUtf8CharSequence() {\n        testSetGetCharSequence(CharsetUtil.UTF_8);\n    }\n\n    @Test\n    public void testSetIso88591CharSequence() {\n        testSetGetCharSequence(CharsetUtil.ISO_8859_1);\n    }\n\n    @Test\n    public void testSetUtf16CharSequence() {\n        testSetGetCharSequence(CharsetUtil.UTF_16);\n    }\n\n    private static final CharBuffer EXTENDED_ASCII_CHARS, ASCII_CHARS;\n\n    static {\n        char[] chars = new char[256];\n        for (char c = 0; c < chars.length; c++) {\n            chars[c] = c;\n        }\n        EXTENDED_ASCII_CHARS = CharBuffer.wrap(chars);\n        ASCII_CHARS = CharBuffer.wrap(chars, 0, 128);\n    }\n\n    private void testSetGetCharSequence(Charset charset) {\n        ByteBuf buf = newBuffer(1024);\n        CharBuffer sequence = CharsetUtil.US_ASCII.equals(charset)\n                ? ASCII_CHARS : EXTENDED_ASCII_CHARS;\n        int bytes = buf.setCharSequence(1, sequence, charset);\n        assertEquals(sequence, CharBuffer.wrap(buf.getCharSequence(1, bytes, charset)));\n        buf.release();\n    }\n\n    @Test\n    public void testWriteReadUsAsciiCharSequence() {\n        testWriteReadCharSequence(CharsetUtil.US_ASCII);\n    }\n\n    @Test\n    public void testWriteReadUtf8CharSequence() {\n        testWriteReadCharSequence(CharsetUtil.UTF_8);\n    }\n\n    @Test\n    public void testWriteReadIso88591CharSequence() {\n        testWriteReadCharSequence(CharsetUtil.ISO_8859_1);\n    }\n\n    @Test\n    public void testWriteReadUtf16CharSequence() {\n        testWriteReadCharSequence(CharsetUtil.UTF_16);\n    }\n\n    private void testWriteReadCharSequence(Charset charset) {\n        ByteBuf buf = newBuffer(1024);\n        CharBuffer sequence = CharsetUtil.US_ASCII.equals(charset)\n                ? ASCII_CHARS : EXTENDED_ASCII_CHARS;\n        buf.writerIndex(1);\n        int bytes = buf.writeCharSequence(sequence, charset);\n        buf.readerIndex(1);\n        assertEquals(sequence, CharBuffer.wrap(buf.readCharSequence(bytes, charset)));\n        buf.release();\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testRetainedSliceIndexOutOfBounds() {\n        testSliceOutOfBounds(true, true, true);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testRetainedSliceLengthOutOfBounds() {\n        testSliceOutOfBounds(true, true, false);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testMixedSliceAIndexOutOfBounds() {\n        testSliceOutOfBounds(true, false, true);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testMixedSliceALengthOutOfBounds() {\n        testSliceOutOfBounds(true, false, false);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testMixedSliceBIndexOutOfBounds() {\n        testSliceOutOfBounds(false, true, true);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testMixedSliceBLengthOutOfBounds() {\n        testSliceOutOfBounds(false, true, false);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testSliceIndexOutOfBounds() {\n        testSliceOutOfBounds(false, false, true);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testSliceLengthOutOfBounds() {\n        testSliceOutOfBounds(false, false, false);\n    }\n\n    @Test\n    public void testRetainedSliceAndRetainedDuplicateContentIsExpected() {\n        ByteBuf buf = newBuffer(8).resetWriterIndex();\n        ByteBuf expected1 = newBuffer(6).resetWriterIndex();\n        ByteBuf expected2 = newBuffer(5).resetWriterIndex();\n        ByteBuf expected3 = newBuffer(4).resetWriterIndex();\n        ByteBuf expected4 = newBuffer(3).resetWriterIndex();\n        buf.writeBytes(new byte[] {1, 2, 3, 4, 5, 6, 7, 8});\n        expected1.writeBytes(new byte[] {2, 3, 4, 5, 6, 7});\n        expected2.writeBytes(new byte[] {3, 4, 5, 6, 7});\n        expected3.writeBytes(new byte[] {4, 5, 6, 7});\n        expected4.writeBytes(new byte[] {5, 6, 7});\n\n        ByteBuf slice1 = buf.retainedSlice(buf.readerIndex() + 1, 6);\n        assertEquals(0, slice1.compareTo(expected1));\n        assertEquals(0, slice1.compareTo(buf.slice(buf.readerIndex() + 1, 6)));\n        // Simulate a handler that releases the original buffer, and propagates a slice.\n        buf.release();\n\n        // Advance the reader index on the slice.\n        slice1.readByte();\n\n        ByteBuf dup1 = slice1.retainedDuplicate();\n        assertEquals(0, dup1.compareTo(expected2));\n        assertEquals(0, dup1.compareTo(slice1.duplicate()));\n\n        // Advance the reader index on dup1.\n        dup1.readByte();\n\n        ByteBuf dup2 = dup1.duplicate();\n        assertEquals(0, dup2.compareTo(expected3));\n\n        // Advance the reader index on dup2.\n        dup2.readByte();\n\n        ByteBuf slice2 = dup2.retainedSlice(dup2.readerIndex(), 3);\n        assertEquals(0, slice2.compareTo(expected4));\n        assertEquals(0, slice2.compareTo(dup2.slice(dup2.readerIndex(), 3)));\n\n        // Cleanup the expected buffers used for testing.\n        assertTrue(expected1.release());\n        assertTrue(expected2.release());\n        assertTrue(expected3.release());\n        assertTrue(expected4.release());\n\n        slice2.release();\n        dup2.release();\n\n        assertEquals(slice2.refCnt(), dup2.refCnt());\n        assertEquals(dup2.refCnt(), dup1.refCnt());\n\n        // The handler is now done with the original slice\n        assertTrue(slice1.release());\n\n        // Reference counting may be shared, or may be independently tracked, but at this point all buffers should\n        // be deallocated and have a reference count of 0.\n        assertEquals(0, buf.refCnt());\n        assertEquals(0, slice1.refCnt());\n        assertEquals(0, slice2.refCnt());\n        assertEquals(0, dup1.refCnt());\n        assertEquals(0, dup2.refCnt());\n    }\n\n    @Test\n    public void testRetainedDuplicateAndRetainedSliceContentIsExpected() {\n        ByteBuf buf = newBuffer(8).resetWriterIndex();\n        ByteBuf expected1 = newBuffer(6).resetWriterIndex();\n        ByteBuf expected2 = newBuffer(5).resetWriterIndex();\n        ByteBuf expected3 = newBuffer(4).resetWriterIndex();\n        buf.writeBytes(new byte[] {1, 2, 3, 4, 5, 6, 7, 8});\n        expected1.writeBytes(new byte[] {2, 3, 4, 5, 6, 7});\n        expected2.writeBytes(new byte[] {3, 4, 5, 6, 7});\n        expected3.writeBytes(new byte[] {5, 6, 7});\n\n        ByteBuf dup1 = buf.retainedDuplicate();\n        assertEquals(0, dup1.compareTo(buf));\n        assertEquals(0, dup1.compareTo(buf.slice()));\n        // Simulate a handler that releases the original buffer, and propagates a slice.\n        buf.release();\n\n        // Advance the reader index on the dup.\n        dup1.readByte();\n\n        ByteBuf slice1 = dup1.retainedSlice(dup1.readerIndex(), 6);\n        assertEquals(0, slice1.compareTo(expected1));\n        assertEquals(0, slice1.compareTo(slice1.duplicate()));\n\n        // Advance the reader index on slice1.\n        slice1.readByte();\n\n        ByteBuf dup2 = slice1.duplicate();\n        assertEquals(0, dup2.compareTo(slice1));\n\n        // Advance the reader index on dup2.\n        dup2.readByte();\n\n        ByteBuf slice2 = dup2.retainedSlice(dup2.readerIndex() + 1, 3);\n        assertEquals(0, slice2.compareTo(expected3));\n        assertEquals(0, slice2.compareTo(dup2.slice(dup2.readerIndex() + 1, 3)));\n\n        // Cleanup the expected buffers used for testing.\n        assertTrue(expected1.release());\n        assertTrue(expected2.release());\n        assertTrue(expected3.release());\n\n        slice2.release();\n        slice1.release();\n\n        assertEquals(slice2.refCnt(), dup2.refCnt());\n        assertEquals(dup2.refCnt(), slice1.refCnt());\n\n        // The handler is now done with the original slice\n        assertTrue(dup1.release());\n\n        // Reference counting may be shared, or may be independently tracked, but at this point all buffers should\n        // be deallocated and have a reference count of 0.\n        assertEquals(0, buf.refCnt());\n        assertEquals(0, slice1.refCnt());\n        assertEquals(0, slice2.refCnt());\n        assertEquals(0, dup1.refCnt());\n        assertEquals(0, dup2.refCnt());\n    }\n\n    @Test\n    public void testRetainedSliceContents() {\n        testSliceContents(true);\n    }\n\n    @Test\n    public void testMultipleLevelRetainedSlice1() {\n        testMultipleLevelRetainedSliceWithNonRetained(true, true);\n    }\n\n    @Test\n    public void testMultipleLevelRetainedSlice2() {\n        testMultipleLevelRetainedSliceWithNonRetained(true, false);\n    }\n\n    @Test\n    public void testMultipleLevelRetainedSlice3() {\n        testMultipleLevelRetainedSliceWithNonRetained(false, true);\n    }\n\n    @Test\n    public void testMultipleLevelRetainedSlice4() {\n        testMultipleLevelRetainedSliceWithNonRetained(false, false);\n    }\n\n    @Test\n    public void testRetainedSliceReleaseOriginal1() {\n        testSliceReleaseOriginal(true, true);\n    }\n\n    @Test\n    public void testRetainedSliceReleaseOriginal2() {\n        testSliceReleaseOriginal(true, false);\n    }\n\n    @Test\n    public void testRetainedSliceReleaseOriginal3() {\n        testSliceReleaseOriginal(false, true);\n    }\n\n    @Test\n    public void testRetainedSliceReleaseOriginal4() {\n        testSliceReleaseOriginal(false, false);\n    }\n\n    @Test\n    public void testRetainedDuplicateReleaseOriginal1() {\n        testDuplicateReleaseOriginal(true, true);\n    }\n\n    @Test\n    public void testRetainedDuplicateReleaseOriginal2() {\n        testDuplicateReleaseOriginal(true, false);\n    }\n\n    @Test\n    public void testRetainedDuplicateReleaseOriginal3() {\n        testDuplicateReleaseOriginal(false, true);\n    }\n\n    @Test\n    public void testRetainedDuplicateReleaseOriginal4() {\n        testDuplicateReleaseOriginal(false, false);\n    }\n\n    @Test\n    public void testMultipleRetainedSliceReleaseOriginal1() {\n        testMultipleRetainedSliceReleaseOriginal(true, true);\n    }\n\n    @Test\n    public void testMultipleRetainedSliceReleaseOriginal2() {\n        testMultipleRetainedSliceReleaseOriginal(true, false);\n    }\n\n    @Test\n    public void testMultipleRetainedSliceReleaseOriginal3() {\n        testMultipleRetainedSliceReleaseOriginal(false, true);\n    }\n\n    @Test\n    public void testMultipleRetainedSliceReleaseOriginal4() {\n        testMultipleRetainedSliceReleaseOriginal(false, false);\n    }\n\n    @Test\n    public void testMultipleRetainedDuplicateReleaseOriginal1() {\n        testMultipleRetainedDuplicateReleaseOriginal(true, true);\n    }\n\n    @Test\n    public void testMultipleRetainedDuplicateReleaseOriginal2() {\n        testMultipleRetainedDuplicateReleaseOriginal(true, false);\n    }\n\n    @Test\n    public void testMultipleRetainedDuplicateReleaseOriginal3() {\n        testMultipleRetainedDuplicateReleaseOriginal(false, true);\n    }\n\n    @Test\n    public void testMultipleRetainedDuplicateReleaseOriginal4() {\n        testMultipleRetainedDuplicateReleaseOriginal(false, false);\n    }\n\n    @Test\n    public void testSliceContents() {\n        testSliceContents(false);\n    }\n\n    @Test\n    public void testRetainedDuplicateContents() {\n        testDuplicateContents(true);\n    }\n\n    @Test\n    public void testDuplicateContents() {\n        testDuplicateContents(false);\n    }\n\n    @Test\n    public void testDuplicateCapacityChange() {\n        testDuplicateCapacityChange(false);\n    }\n\n    @Test\n    public void testRetainedDuplicateCapacityChange() {\n        testDuplicateCapacityChange(true);\n    }\n\n    @Test(expected = UnsupportedOperationException.class)\n    public void testSliceCapacityChange() {\n        testSliceCapacityChange(false);\n    }\n\n    @Test(expected = UnsupportedOperationException.class)\n    public void testRetainedSliceCapacityChange() {\n        testSliceCapacityChange(true);\n    }\n\n    @Test\n    public void testRetainedSliceUnreleasable1() {\n        testRetainedSliceUnreleasable(true, true);\n    }\n\n    @Test\n    public void testRetainedSliceUnreleasable2() {\n        testRetainedSliceUnreleasable(true, false);\n    }\n\n    @Test\n    public void testRetainedSliceUnreleasable3() {\n        testRetainedSliceUnreleasable(false, true);\n    }\n\n    @Test\n    public void testRetainedSliceUnreleasable4() {\n        testRetainedSliceUnreleasable(false, false);\n    }\n\n    @Test\n    public void testReadRetainedSliceUnreleasable1() {\n        testReadRetainedSliceUnreleasable(true, true);\n    }\n\n    @Test\n    public void testReadRetainedSliceUnreleasable2() {\n        testReadRetainedSliceUnreleasable(true, false);\n    }\n\n    @Test\n    public void testReadRetainedSliceUnreleasable3() {\n        testReadRetainedSliceUnreleasable(false, true);\n    }\n\n    @Test\n    public void testReadRetainedSliceUnreleasable4() {\n        testReadRetainedSliceUnreleasable(false, false);\n    }\n\n    @Test\n    public void testRetainedDuplicateUnreleasable1() {\n        testRetainedDuplicateUnreleasable(true, true);\n    }\n\n    @Test\n    public void testRetainedDuplicateUnreleasable2() {\n        testRetainedDuplicateUnreleasable(true, false);\n    }\n\n    @Test\n    public void testRetainedDuplicateUnreleasable3() {\n        testRetainedDuplicateUnreleasable(false, true);\n    }\n\n    @Test\n    public void testRetainedDuplicateUnreleasable4() {\n        testRetainedDuplicateUnreleasable(false, false);\n    }\n\n    private void testRetainedSliceUnreleasable(boolean initRetainedSlice, boolean finalRetainedSlice) {\n        ByteBuf buf = newBuffer(8);\n        ByteBuf buf1 = initRetainedSlice ? buf.retainedSlice() : buf.slice().retain();\n        ByteBuf buf2 = unreleasableBuffer(buf1);\n        ByteBuf buf3 = finalRetainedSlice ? buf2.retainedSlice() : buf2.slice().retain();\n        assertFalse(buf3.release());\n        assertFalse(buf2.release());\n        buf1.release();\n        assertTrue(buf.release());\n        assertEquals(0, buf1.refCnt());\n        assertEquals(0, buf.refCnt());\n    }\n\n    private void testReadRetainedSliceUnreleasable(boolean initRetainedSlice, boolean finalRetainedSlice) {\n        ByteBuf buf = newBuffer(8);\n        ByteBuf buf1 = initRetainedSlice ? buf.retainedSlice() : buf.slice().retain();\n        ByteBuf buf2 = unreleasableBuffer(buf1);\n        ByteBuf buf3 = finalRetainedSlice ? buf2.readRetainedSlice(buf2.readableBytes())\n                                          : buf2.readSlice(buf2.readableBytes()).retain();\n        assertFalse(buf3.release());\n        assertFalse(buf2.release());\n        buf1.release();\n        assertTrue(buf.release());\n        assertEquals(0, buf1.refCnt());\n        assertEquals(0, buf.refCnt());\n    }\n\n    private void testRetainedDuplicateUnreleasable(boolean initRetainedDuplicate, boolean finalRetainedDuplicate) {\n        ByteBuf buf = newBuffer(8);\n        ByteBuf buf1 = initRetainedDuplicate ? buf.retainedDuplicate() : buf.duplicate().retain();\n        ByteBuf buf2 = unreleasableBuffer(buf1);\n        ByteBuf buf3 = finalRetainedDuplicate ? buf2.retainedDuplicate() : buf2.duplicate().retain();\n        assertFalse(buf3.release());\n        assertFalse(buf2.release());\n        buf1.release();\n        assertTrue(buf.release());\n        assertEquals(0, buf1.refCnt());\n        assertEquals(0, buf.refCnt());\n    }\n\n    private void testDuplicateCapacityChange(boolean retainedDuplicate) {\n        ByteBuf buf = newBuffer(8);\n        ByteBuf dup = retainedDuplicate ? buf.retainedDuplicate() : buf.duplicate();\n        try {\n            dup.capacity(10);\n            assertEquals(buf.capacity(), dup.capacity());\n            dup.capacity(5);\n            assertEquals(buf.capacity(), dup.capacity());\n        } finally {\n            if (retainedDuplicate) {\n                dup.release();\n            }\n            buf.release();\n        }\n    }\n\n    private void testSliceCapacityChange(boolean retainedSlice) {\n        ByteBuf buf = newBuffer(8);\n        ByteBuf slice = retainedSlice ? buf.retainedSlice(buf.readerIndex() + 1, 3)\n                                      : buf.slice(buf.readerIndex() + 1, 3);\n        try {\n            slice.capacity(10);\n        } finally {\n            if (retainedSlice) {\n                slice.release();\n            }\n            buf.release();\n        }\n    }\n\n    private void testSliceOutOfBounds(boolean initRetainedSlice, boolean finalRetainedSlice, boolean indexOutOfBounds) {\n        ByteBuf buf = newBuffer(8);\n        ByteBuf slice = initRetainedSlice ? buf.retainedSlice(buf.readerIndex() + 1, 2)\n                                          : buf.slice(buf.readerIndex() + 1, 2);\n        try {\n            assertEquals(2, slice.capacity());\n            assertEquals(2, slice.maxCapacity());\n            final int index = indexOutOfBounds ? 3 : 0;\n            final int length = indexOutOfBounds ? 0 : 3;\n            if (finalRetainedSlice) {\n                // This is expected to fail ... so no need to release.\n                slice.retainedSlice(index, length);\n            } else {\n                slice.slice(index, length);\n            }\n        } finally {\n            if (initRetainedSlice) {\n                slice.release();\n            }\n            buf.release();\n        }\n    }\n\n    private void testSliceContents(boolean retainedSlice) {\n        ByteBuf buf = newBuffer(8).resetWriterIndex();\n        ByteBuf expected = newBuffer(3).resetWriterIndex();\n        buf.writeBytes(new byte[] {1, 2, 3, 4, 5, 6, 7, 8});\n        expected.writeBytes(new byte[] {4, 5, 6});\n        ByteBuf slice = retainedSlice ? buf.retainedSlice(buf.readerIndex() + 3, 3)\n                                      : buf.slice(buf.readerIndex() + 3, 3);\n        try {\n            assertEquals(0, slice.compareTo(expected));\n            assertEquals(0, slice.compareTo(slice.duplicate()));\n            ByteBuf b = slice.retainedDuplicate();\n            assertEquals(0, slice.compareTo(b));\n            b.release();\n            assertEquals(0, slice.compareTo(slice.slice(0, slice.capacity())));\n        } finally {\n            if (retainedSlice) {\n                slice.release();\n            }\n            buf.release();\n            expected.release();\n        }\n    }\n\n    private void testSliceReleaseOriginal(boolean retainedSlice1, boolean retainedSlice2) {\n        ByteBuf buf = newBuffer(8).resetWriterIndex();\n        ByteBuf expected1 = newBuffer(3).resetWriterIndex();\n        ByteBuf expected2 = newBuffer(2).resetWriterIndex();\n        buf.writeBytes(new byte[] {1, 2, 3, 4, 5, 6, 7, 8});\n        expected1.writeBytes(new byte[] {6, 7, 8});\n        expected2.writeBytes(new byte[] {7, 8});\n        ByteBuf slice1 = retainedSlice1 ? buf.retainedSlice(buf.readerIndex() + 5, 3)\n                                        : buf.slice(buf.readerIndex() + 5, 3).retain();\n        assertEquals(0, slice1.compareTo(expected1));\n        // Simulate a handler that releases the original buffer, and propagates a slice.\n        buf.release();\n\n        ByteBuf slice2 = retainedSlice2 ? slice1.retainedSlice(slice1.readerIndex() + 1, 2)\n                                        : slice1.slice(slice1.readerIndex() + 1, 2).retain();\n        assertEquals(0, slice2.compareTo(expected2));\n\n        // Cleanup the expected buffers used for testing.\n        assertTrue(expected1.release());\n        assertTrue(expected2.release());\n\n        // The handler created a slice of the slice and is now done with it.\n        slice2.release();\n\n        // The handler is now done with the original slice\n        assertTrue(slice1.release());\n\n        // Reference counting may be shared, or may be independently tracked, but at this point all buffers should\n        // be deallocated and have a reference count of 0.\n        assertEquals(0, buf.refCnt());\n        assertEquals(0, slice1.refCnt());\n        assertEquals(0, slice2.refCnt());\n    }\n\n    private void testMultipleLevelRetainedSliceWithNonRetained(boolean doSlice1, boolean doSlice2) {\n        ByteBuf buf = newBuffer(8).resetWriterIndex();\n        ByteBuf expected1 = newBuffer(6).resetWriterIndex();\n        ByteBuf expected2 = newBuffer(4).resetWriterIndex();\n        ByteBuf expected3 = newBuffer(2).resetWriterIndex();\n        ByteBuf expected4SliceSlice = newBuffer(1).resetWriterIndex();\n        ByteBuf expected4DupSlice = newBuffer(1).resetWriterIndex();\n        buf.writeBytes(new byte[] {1, 2, 3, 4, 5, 6, 7, 8});\n        expected1.writeBytes(new byte[] {2, 3, 4, 5, 6, 7});\n        expected2.writeBytes(new byte[] {3, 4, 5, 6});\n        expected3.writeBytes(new byte[] {4, 5});\n        expected4SliceSlice.writeBytes(new byte[] {5});\n        expected4DupSlice.writeBytes(new byte[] {4});\n\n        ByteBuf slice1 = buf.retainedSlice(buf.readerIndex() + 1, 6);\n        assertEquals(0, slice1.compareTo(expected1));\n        // Simulate a handler that releases the original buffer, and propagates a slice.\n        buf.release();\n\n        ByteBuf slice2 = slice1.retainedSlice(slice1.readerIndex() + 1, 4);\n        assertEquals(0, slice2.compareTo(expected2));\n        assertEquals(0, slice2.compareTo(slice2.duplicate()));\n        assertEquals(0, slice2.compareTo(slice2.slice()));\n\n        ByteBuf tmpBuf = slice2.retainedDuplicate();\n        assertEquals(0, slice2.compareTo(tmpBuf));\n        tmpBuf.release();\n        tmpBuf = slice2.retainedSlice();\n        assertEquals(0, slice2.compareTo(tmpBuf));\n        tmpBuf.release();\n\n        ByteBuf slice3 = doSlice1 ? slice2.slice(slice2.readerIndex() + 1, 2) : slice2.duplicate();\n        if (doSlice1) {\n            assertEquals(0, slice3.compareTo(expected3));\n        } else {\n            assertEquals(0, slice3.compareTo(expected2));\n        }\n\n        ByteBuf slice4 = doSlice2 ? slice3.slice(slice3.readerIndex() + 1, 1) : slice3.duplicate();\n        if (doSlice1 && doSlice2) {\n            assertEquals(0, slice4.compareTo(expected4SliceSlice));\n        } else if (doSlice2) {\n            assertEquals(0, slice4.compareTo(expected4DupSlice));\n        } else {\n            assertEquals(0, slice3.compareTo(slice4));\n        }\n\n        // Cleanup the expected buffers used for testing.\n        assertTrue(expected1.release());\n        assertTrue(expected2.release());\n        assertTrue(expected3.release());\n        assertTrue(expected4SliceSlice.release());\n        assertTrue(expected4DupSlice.release());\n\n        // Slice 4, 3, and 2 should effectively \"share\" a reference count.\n        slice4.release();\n        assertEquals(slice3.refCnt(), slice2.refCnt());\n        assertEquals(slice3.refCnt(), slice4.refCnt());\n\n        // Slice 1 should also release the original underlying buffer without throwing exceptions\n        assertTrue(slice1.release());\n\n        // Reference counting may be shared, or may be independently tracked, but at this point all buffers should\n        // be deallocated and have a reference count of 0.\n        assertEquals(0, buf.refCnt());\n        assertEquals(0, slice1.refCnt());\n        assertEquals(0, slice2.refCnt());\n        assertEquals(0, slice3.refCnt());\n    }\n\n    private void testDuplicateReleaseOriginal(boolean retainedDuplicate1, boolean retainedDuplicate2) {\n        ByteBuf buf = newBuffer(8).resetWriterIndex();\n        ByteBuf expected = newBuffer(8).resetWriterIndex();\n        buf.writeBytes(new byte[] {1, 2, 3, 4, 5, 6, 7, 8});\n        expected.writeBytes(buf, buf.readerIndex(), buf.readableBytes());\n        ByteBuf dup1 = retainedDuplicate1 ? buf.retainedDuplicate()\n                                          : buf.duplicate().retain();\n        assertEquals(0, dup1.compareTo(expected));\n        // Simulate a handler that releases the original buffer, and propagates a slice.\n        buf.release();\n\n        ByteBuf dup2 = retainedDuplicate2 ? dup1.retainedDuplicate()\n                                          : dup1.duplicate().retain();\n        assertEquals(0, dup2.compareTo(expected));\n\n        // Cleanup the expected buffers used for testing.\n        assertTrue(expected.release());\n\n        // The handler created a slice of the slice and is now done with it.\n        dup2.release();\n\n        // The handler is now done with the original slice\n        assertTrue(dup1.release());\n\n        // Reference counting may be shared, or may be independently tracked, but at this point all buffers should\n        // be deallocated and have a reference count of 0.\n        assertEquals(0, buf.refCnt());\n        assertEquals(0, dup1.refCnt());\n        assertEquals(0, dup2.refCnt());\n    }\n\n    private void testMultipleRetainedSliceReleaseOriginal(boolean retainedSlice1, boolean retainedSlice2) {\n        ByteBuf buf = newBuffer(8).resetWriterIndex();\n        ByteBuf expected1 = newBuffer(3).resetWriterIndex();\n        ByteBuf expected2 = newBuffer(2).resetWriterIndex();\n        ByteBuf expected3 = newBuffer(2).resetWriterIndex();\n        buf.writeBytes(new byte[] {1, 2, 3, 4, 5, 6, 7, 8});\n        expected1.writeBytes(new byte[] {6, 7, 8});\n        expected2.writeBytes(new byte[] {7, 8});\n        expected3.writeBytes(new byte[] {6, 7});\n        ByteBuf slice1 = retainedSlice1 ? buf.retainedSlice(buf.readerIndex() + 5, 3)\n                                        : buf.slice(buf.readerIndex() + 5, 3).retain();\n        assertEquals(0, slice1.compareTo(expected1));\n        // Simulate a handler that releases the original buffer, and propagates a slice.\n        buf.release();\n\n        ByteBuf slice2 = retainedSlice2 ? slice1.retainedSlice(slice1.readerIndex() + 1, 2)\n                                        : slice1.slice(slice1.readerIndex() + 1, 2).retain();\n        assertEquals(0, slice2.compareTo(expected2));\n\n        // The handler created a slice of the slice and is now done with it.\n        slice2.release();\n\n        ByteBuf slice3 = slice1.retainedSlice(slice1.readerIndex(), 2);\n        assertEquals(0, slice3.compareTo(expected3));\n\n        // The handler created another slice of the slice and is now done with it.\n        slice3.release();\n\n        // The handler is now done with the original slice\n        assertTrue(slice1.release());\n\n        // Cleanup the expected buffers used for testing.\n        assertTrue(expected1.release());\n        assertTrue(expected2.release());\n        assertTrue(expected3.release());\n\n        // Reference counting may be shared, or may be independently tracked, but at this point all buffers should\n        // be deallocated and have a reference count of 0.\n        assertEquals(0, buf.refCnt());\n        assertEquals(0, slice1.refCnt());\n        assertEquals(0, slice2.refCnt());\n        assertEquals(0, slice3.refCnt());\n    }\n\n    private void testMultipleRetainedDuplicateReleaseOriginal(boolean retainedDuplicate1, boolean retainedDuplicate2) {\n        ByteBuf buf = newBuffer(8).resetWriterIndex();\n        ByteBuf expected = newBuffer(8).resetWriterIndex();\n        buf.writeBytes(new byte[] {1, 2, 3, 4, 5, 6, 7, 8});\n        expected.writeBytes(buf, buf.readerIndex(), buf.readableBytes());\n        ByteBuf dup1 = retainedDuplicate1 ? buf.retainedDuplicate()\n                                          : buf.duplicate().retain();\n        assertEquals(0, dup1.compareTo(expected));\n        // Simulate a handler that releases the original buffer, and propagates a slice.\n        buf.release();\n\n        ByteBuf dup2 = retainedDuplicate2 ? dup1.retainedDuplicate()\n                                          : dup1.duplicate().retain();\n        assertEquals(0, dup2.compareTo(expected));\n        assertEquals(0, dup2.compareTo(dup2.duplicate()));\n        assertEquals(0, dup2.compareTo(dup2.slice()));\n\n        ByteBuf tmpBuf = dup2.retainedDuplicate();\n        assertEquals(0, dup2.compareTo(tmpBuf));\n        tmpBuf.release();\n        tmpBuf = dup2.retainedSlice();\n        assertEquals(0, dup2.compareTo(tmpBuf));\n        tmpBuf.release();\n\n        // The handler created a slice of the slice and is now done with it.\n        dup2.release();\n\n        ByteBuf dup3 = dup1.retainedDuplicate();\n        assertEquals(0, dup3.compareTo(expected));\n\n        // The handler created another slice of the slice and is now done with it.\n        dup3.release();\n\n        // The handler is now done with the original slice\n        assertTrue(dup1.release());\n\n        // Cleanup the expected buffers used for testing.\n        assertTrue(expected.release());\n\n        // Reference counting may be shared, or may be independently tracked, but at this point all buffers should\n        // be deallocated and have a reference count of 0.\n        assertEquals(0, buf.refCnt());\n        assertEquals(0, dup1.refCnt());\n        assertEquals(0, dup2.refCnt());\n        assertEquals(0, dup3.refCnt());\n    }\n\n    private void testDuplicateContents(boolean retainedDuplicate) {\n        ByteBuf buf = newBuffer(8).resetWriterIndex();\n        buf.writeBytes(new byte[] {1, 2, 3, 4, 5, 6, 7, 8});\n        ByteBuf dup = retainedDuplicate ? buf.retainedDuplicate() : buf.duplicate();\n        try {\n            assertEquals(0, dup.compareTo(buf));\n            assertEquals(0, dup.compareTo(dup.duplicate()));\n            ByteBuf b = dup.retainedDuplicate();\n            assertEquals(0, dup.compareTo(b));\n            b.release();\n            assertEquals(0, dup.compareTo(dup.slice(dup.readerIndex(), dup.readableBytes())));\n        } finally {\n            if (retainedDuplicate) {\n                dup.release();\n            }\n            buf.release();\n        }\n    }\n\n    @Test\n    public void testDuplicateRelease() {\n        ByteBuf buf = newBuffer(8);\n        assertEquals(1, buf.refCnt());\n        assertTrue(buf.duplicate().release());\n        assertEquals(0, buf.refCnt());\n    }\n\n    // Test-case trying to reproduce:\n    // https://github.com/netty/netty/issues/2843\n    @Test\n    public void testRefCnt() throws Exception {\n        testRefCnt0(false);\n    }\n\n    // Test-case trying to reproduce:\n    // https://github.com/netty/netty/issues/2843\n    @Test\n    public void testRefCnt2() throws Exception {\n        testRefCnt0(true);\n    }\n\n    @Test\n    public void testEmptyNioBuffers() throws Exception {\n        ByteBuf buffer = newBuffer(8);\n        buffer.clear();\n        assertFalse(buffer.isReadable());\n        ByteBuffer[] nioBuffers = buffer.nioBuffers();\n        assertEquals(1, nioBuffers.length);\n        assertFalse(nioBuffers[0].hasRemaining());\n        buffer.release();\n    }\n\n    @Test\n    public void testGetReadOnlyDirectDst() {\n        testGetReadOnlyDst(true);\n    }\n\n    @Test\n    public void testGetReadOnlyHeapDst() {\n        testGetReadOnlyDst(false);\n    }\n\n    private void testGetReadOnlyDst(boolean direct) {\n        byte[] bytes = { 'a', 'b', 'c', 'd' };\n\n        ByteBuf buffer = newBuffer(bytes.length);\n        buffer.writeBytes(bytes);\n\n        ByteBuffer dst = direct ? ByteBuffer.allocateDirect(bytes.length) : ByteBuffer.allocate(bytes.length);\n        ByteBuffer readOnlyDst = dst.asReadOnlyBuffer();\n        try {\n            buffer.getBytes(0, readOnlyDst);\n            fail();\n        } catch (ReadOnlyBufferException e) {\n            // expected\n        }\n        assertEquals(0, readOnlyDst.position());\n        buffer.release();\n    }\n\n    @Test\n    public void testReadBytesAndWriteBytesWithFileChannel() throws IOException {\n        File file = File.createTempFile(\"file-channel\", \".tmp\");\n        RandomAccessFile randomAccessFile = null;\n        try {\n            randomAccessFile = new RandomAccessFile(file, \"rw\");\n            FileChannel channel = randomAccessFile.getChannel();\n            // channelPosition should never be changed\n            long channelPosition = channel.position();\n\n            byte[] bytes = {'a', 'b', 'c', 'd'};\n            int len = bytes.length;\n            ByteBuf buffer = newBuffer(len);\n            buffer.resetReaderIndex();\n            buffer.resetWriterIndex();\n            buffer.writeBytes(bytes);\n\n            int oldReaderIndex = buffer.readerIndex();\n            assertEquals(len, buffer.readBytes(channel, 10, len));\n            assertEquals(oldReaderIndex + len, buffer.readerIndex());\n            assertEquals(channelPosition, channel.position());\n\n            ByteBuf buffer2 = newBuffer(len);\n            buffer2.resetReaderIndex();\n            buffer2.resetWriterIndex();\n            int oldWriterIndex = buffer2.writerIndex();\n            assertEquals(len, buffer2.writeBytes(channel, 10, len));\n            assertEquals(channelPosition, channel.position());\n            assertEquals(oldWriterIndex + len, buffer2.writerIndex());\n            assertEquals('a', buffer2.getByte(0));\n            assertEquals('b', buffer2.getByte(1));\n            assertEquals('c', buffer2.getByte(2));\n            assertEquals('d', buffer2.getByte(3));\n            buffer.release();\n            buffer2.release();\n        } finally {\n            if (randomAccessFile != null) {\n                randomAccessFile.close();\n            }\n            file.delete();\n        }\n    }\n\n    @Test\n    public void testGetBytesAndSetBytesWithFileChannel() throws IOException {\n        File file = File.createTempFile(\"file-channel\", \".tmp\");\n        RandomAccessFile randomAccessFile = null;\n        try {\n            randomAccessFile = new RandomAccessFile(file, \"rw\");\n            FileChannel channel = randomAccessFile.getChannel();\n            // channelPosition should never be changed\n            long channelPosition = channel.position();\n\n            byte[] bytes = {'a', 'b', 'c', 'd'};\n            int len = bytes.length;\n            ByteBuf buffer = newBuffer(len);\n            buffer.resetReaderIndex();\n            buffer.resetWriterIndex();\n            buffer.writeBytes(bytes);\n\n            int oldReaderIndex = buffer.readerIndex();\n            assertEquals(len, buffer.getBytes(oldReaderIndex, channel, 10, len));\n            assertEquals(oldReaderIndex, buffer.readerIndex());\n            assertEquals(channelPosition, channel.position());\n\n            ByteBuf buffer2 = newBuffer(len);\n            buffer2.resetReaderIndex();\n            buffer2.resetWriterIndex();\n            int oldWriterIndex = buffer2.writerIndex();\n            assertEquals(buffer2.setBytes(oldWriterIndex, channel, 10, len), len);\n            assertEquals(channelPosition, channel.position());\n\n            assertEquals(oldWriterIndex, buffer2.writerIndex());\n            assertEquals('a', buffer2.getByte(oldWriterIndex));\n            assertEquals('b', buffer2.getByte(oldWriterIndex + 1));\n            assertEquals('c', buffer2.getByte(oldWriterIndex + 2));\n            assertEquals('d', buffer2.getByte(oldWriterIndex + 3));\n\n            buffer.release();\n            buffer2.release();\n        } finally {\n            if (randomAccessFile != null) {\n                randomAccessFile.close();\n            }\n            file.delete();\n        }\n    }\n\n    @Test\n    public void testReadBytes() {\n        ByteBuf buffer = newBuffer(8);\n        byte[] bytes = new byte[8];\n        buffer.writeBytes(bytes);\n\n        ByteBuf buffer2 = buffer.readBytes(4);\n        assertSame(buffer.alloc(), buffer2.alloc());\n        assertEquals(4, buffer.readerIndex());\n        assertTrue(buffer.release());\n        assertEquals(0, buffer.refCnt());\n        assertTrue(buffer2.release());\n        assertEquals(0, buffer2.refCnt());\n    }\n\n    @Test\n    public void testForEachByteDesc2() {\n        byte[] expected = {1, 2, 3, 4};\n        ByteBuf buf = newBuffer(expected.length);\n        try {\n            buf.writeBytes(expected);\n            final byte[] bytes = new byte[expected.length];\n            int i = buf.forEachByteDesc(new ByteProcessor() {\n                private int index = bytes.length - 1;\n\n                @Override\n                public boolean process(byte value) throws Exception {\n                    bytes[index--] = value;\n                    return true;\n                }\n            });\n            assertEquals(-1, i);\n            assertArrayEquals(expected, bytes);\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test\n    public void testForEachByte2() {\n        byte[] expected = {1, 2, 3, 4};\n        ByteBuf buf = newBuffer(expected.length);\n        try {\n            buf.writeBytes(expected);\n            final byte[] bytes = new byte[expected.length];\n            int i = buf.forEachByte(new ByteProcessor() {\n                private int index;\n\n                @Override\n                public boolean process(byte value) throws Exception {\n                    bytes[index++] = value;\n                    return true;\n                }\n            });\n            assertEquals(-1, i);\n            assertArrayEquals(expected, bytes);\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testGetBytesByteBuffer() {\n        byte[] bytes = {'a', 'b', 'c', 'd', 'e', 'f', 'g'};\n        // Ensure destination buffer is bigger then what is in the ByteBuf.\n        ByteBuffer nioBuffer = ByteBuffer.allocate(bytes.length + 1);\n        ByteBuf buffer = newBuffer(bytes.length);\n        try {\n            buffer.writeBytes(bytes);\n            buffer.getBytes(buffer.readerIndex(), nioBuffer);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    private void testRefCnt0(final boolean parameter) throws Exception {\n        for (int i = 0; i < 10; i++) {\n            final CountDownLatch latch = new CountDownLatch(1);\n            final CountDownLatch innerLatch = new CountDownLatch(1);\n\n            final ByteBuf buffer = newBuffer(4);\n            assertEquals(1, buffer.refCnt());\n            final AtomicInteger cnt = new AtomicInteger(Integer.MAX_VALUE);\n            Thread t1 = new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    boolean released;\n                    if (parameter) {\n                        released = buffer.release(buffer.refCnt());\n                    } else {\n                        released = buffer.release();\n                    }\n                    assertTrue(released);\n                    Thread t2 = new Thread(new Runnable() {\n                        @Override\n                        public void run() {\n                            cnt.set(buffer.refCnt());\n                            latch.countDown();\n                        }\n                    });\n                    t2.start();\n                    try {\n                        // Keep Thread alive a bit so the ThreadLocal caches are not freed\n                        innerLatch.await();\n                    } catch (InterruptedException ignore) {\n                        // ignore\n                    }\n                }\n            });\n            t1.start();\n\n            latch.await();\n            assertEquals(0, cnt.get());\n            innerLatch.countDown();\n        }\n    }\n\n    static final class TestGatheringByteChannel implements GatheringByteChannel {\n        private final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        private final WritableByteChannel channel = Channels.newChannel(out);\n        private final int limit;\n        TestGatheringByteChannel(int limit) {\n            this.limit = limit;\n        }\n\n        TestGatheringByteChannel() {\n            this(Integer.MAX_VALUE);\n        }\n\n        @Override\n        public long write(ByteBuffer[] srcs, int offset, int length) throws IOException {\n            long written = 0;\n            for (; offset < length; offset++) {\n                written += write(srcs[offset]);\n                if (written >= limit) {\n                    break;\n                }\n            }\n            return written;\n        }\n\n        @Override\n        public long write(ByteBuffer[] srcs) throws IOException {\n            return write(srcs, 0, srcs.length);\n        }\n\n        @Override\n        public int write(ByteBuffer src) throws IOException {\n            int oldLimit = src.limit();\n            if (limit < src.remaining()) {\n                src.limit(src.position() + limit);\n            }\n            int w = channel.write(src);\n            src.limit(oldLimit);\n            return w;\n        }\n\n        @Override\n        public boolean isOpen() {\n            return channel.isOpen();\n        }\n\n        @Override\n        public void close() throws IOException {\n            channel.close();\n        }\n\n        public byte[] writtenBytes() {\n            return out.toByteArray();\n        }\n    }\n\n    private static final class DevNullGatheringByteChannel implements GatheringByteChannel {\n        @Override\n        public long write(ByteBuffer[] srcs, int offset, int length) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public long write(ByteBuffer[] srcs) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public int write(ByteBuffer src) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean isOpen() {\n            return false;\n        }\n\n        @Override\n        public void close() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    private static final class TestScatteringByteChannel implements ScatteringByteChannel {\n        @Override\n        public long read(ByteBuffer[] dsts, int offset, int length) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public long read(ByteBuffer[] dsts) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public int read(ByteBuffer dst) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean isOpen() {\n            return false;\n        }\n\n        @Override\n        public void close() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    private static final class TestByteProcessor implements ByteProcessor {\n        @Override\n        public boolean process(byte value) throws Exception {\n            return true;\n        }\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testCapacityEnforceMaxCapacity() {\n        ByteBuf buffer = newBuffer(3, 13);\n        assertEquals(13, buffer.maxCapacity());\n        assertEquals(3, buffer.capacity());\n        try {\n            buffer.capacity(14);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testCapacityNegative() {\n        ByteBuf buffer = newBuffer(3, 13);\n        assertEquals(13, buffer.maxCapacity());\n        assertEquals(3, buffer.capacity());\n        try {\n            buffer.capacity(-1);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test\n    public void testCapacityDecrease() {\n        ByteBuf buffer = newBuffer(3, 13);\n        assertEquals(13, buffer.maxCapacity());\n        assertEquals(3, buffer.capacity());\n        try {\n            buffer.capacity(2);\n            assertEquals(2, buffer.capacity());\n            assertEquals(13, buffer.maxCapacity());\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test\n    public void testCapacityIncrease() {\n        ByteBuf buffer = newBuffer(3, 13);\n        assertEquals(13, buffer.maxCapacity());\n        assertEquals(3, buffer.capacity());\n        try {\n            buffer.capacity(4);\n            assertEquals(4, buffer.capacity());\n            assertEquals(13, buffer.maxCapacity());\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testReaderIndexLargerThanWriterIndex() {\n        String content1 = \"hello\";\n        String content2 = \"world\";\n        int length = content1.length() + content2.length();\n        ByteBuf buffer = newBuffer(length);\n        buffer.setIndex(0, 0);\n        buffer.writeCharSequence(content1, CharsetUtil.US_ASCII);\n        buffer.markWriterIndex();\n        buffer.skipBytes(content1.length());\n        buffer.writeCharSequence(content2, CharsetUtil.US_ASCII);\n        buffer.skipBytes(content2.length());\n        assertTrue(buffer.readerIndex() <= buffer.writerIndex());\n\n        try {\n            buffer.resetWriterIndex();\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test\n    public void testMaxFastWritableBytes() {\n        ByteBuf buffer = newBuffer(150, 500).writerIndex(100);\n        assertEquals(50, buffer.writableBytes());\n        assertEquals(150, buffer.capacity());\n        assertEquals(500, buffer.maxCapacity());\n        assertEquals(400, buffer.maxWritableBytes());\n        // Default implementation has fast writable == writable\n        assertEquals(50, buffer.maxFastWritableBytes());\n        buffer.release();\n    }\n\n    @Test\n    public void testEnsureWritableIntegerOverflow() {\n        ByteBuf buffer = newBuffer(CAPACITY);\n        buffer.writerIndex(buffer.readerIndex());\n        buffer.writeByte(1);\n        try {\n            buffer.ensureWritable(Integer.MAX_VALUE);\n            fail();\n        } catch (IndexOutOfBoundsException e) {\n            // expected\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test\n    public void testEndiannessIndexOf() {\n        buffer.clear();\n        final int v = 0x02030201;\n        buffer.writeIntLE(v);\n        buffer.writeByte(0x01);\n\n        assertEquals(-1, buffer.indexOf(1, 4, (byte) 1));\n        assertEquals(-1, buffer.indexOf(4, 1, (byte) 1));\n        assertEquals(1, buffer.indexOf(1, 4, (byte) 2));\n        assertEquals(3, buffer.indexOf(4, 1, (byte) 2));\n    }\n\n    @Test\n    public void explicitLittleEndianReadMethodsMustAlwaysUseLittleEndianByteOrder() {\n        buffer.clear();\n        buffer.writeBytes(new byte[] {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08});\n        assertEquals(0x0201, buffer.readShortLE());\n        buffer.readerIndex(0);\n        assertEquals(0x0201, buffer.readUnsignedShortLE());\n        buffer.readerIndex(0);\n        assertEquals(0x030201, buffer.readMediumLE());\n        buffer.readerIndex(0);\n        assertEquals(0x030201, buffer.readUnsignedMediumLE());\n        buffer.readerIndex(0);\n        assertEquals(0x04030201, buffer.readIntLE());\n        buffer.readerIndex(0);\n        assertEquals(0x04030201, buffer.readUnsignedIntLE());\n        buffer.readerIndex(0);\n        assertEquals(0x04030201, Float.floatToRawIntBits(buffer.readFloatLE()));\n        buffer.readerIndex(0);\n        assertEquals(0x0807060504030201L, buffer.readLongLE());\n        buffer.readerIndex(0);\n        assertEquals(0x0807060504030201L, Double.doubleToRawLongBits(buffer.readDoubleLE()));\n        buffer.readerIndex(0);\n    }\n\n    @Test\n    public void explicitLittleEndianWriteMethodsMustAlwaysUseLittleEndianByteOrder() {\n        buffer.clear();\n        buffer.writeShortLE(0x0102);\n        assertEquals(0x0102, buffer.readShortLE());\n        buffer.clear();\n        buffer.writeMediumLE(0x010203);\n        assertEquals(0x010203, buffer.readMediumLE());\n        buffer.clear();\n        buffer.writeIntLE(0x01020304);\n        assertEquals(0x01020304, buffer.readIntLE());\n        buffer.clear();\n        buffer.writeFloatLE(Float.intBitsToFloat(0x01020304));\n        assertEquals(0x01020304, Float.floatToRawIntBits(buffer.readFloatLE()));\n        buffer.clear();\n        buffer.writeLongLE(0x0102030405060708L);\n        assertEquals(0x0102030405060708L, buffer.readLongLE());\n        buffer.clear();\n        buffer.writeDoubleLE(Double.longBitsToDouble(0x0102030405060708L));\n        assertEquals(0x0102030405060708L, Double.doubleToRawLongBits(buffer.readDoubleLE()));\n    }\n}\n", "/*\n * Copyright 2013 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.buffer;\n\nimport io.netty.util.internal.PlatformDependent;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.ByteBuffer;\nimport java.nio.ReadOnlyBufferException;\nimport java.nio.channels.FileChannel;\n\npublic class ReadOnlyDirectByteBufferBufTest {\n\n    protected ByteBuf buffer(ByteBuffer buffer) {\n        return new ReadOnlyByteBufferBuf(UnpooledByteBufAllocator.DEFAULT, buffer);\n    }\n\n    protected ByteBuffer allocate(int size) {\n        return ByteBuffer.allocateDirect(size);\n    }\n\n    @Test\n    public void testIsContiguous() {\n        ByteBuf buf = buffer(allocate(4).asReadOnlyBuffer());\n        Assert.assertTrue(buf.isContiguous());\n        buf.release();\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testConstructWithWritable() {\n        buffer(allocate(1));\n    }\n\n    @Test\n    public void shouldIndicateNotWritable() {\n        ByteBuf buf = buffer(allocate(8).asReadOnlyBuffer()).clear();\n        try {\n            Assert.assertFalse(buf.isWritable());\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test\n    public void shouldIndicateNotWritableAnyNumber() {\n        ByteBuf buf = buffer(allocate(8).asReadOnlyBuffer()).clear();\n        try {\n            Assert.assertFalse(buf.isWritable(1));\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test\n    public void ensureWritableIntStatusShouldFailButNotThrow() {\n        ByteBuf buf = buffer(allocate(8).asReadOnlyBuffer()).clear();\n        try {\n            int result = buf.ensureWritable(1, false);\n            Assert.assertEquals(1, result);\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test\n    public void ensureWritableForceIntStatusShouldFailButNotThrow() {\n        ByteBuf buf = buffer(allocate(8).asReadOnlyBuffer()).clear();\n        try {\n            int result = buf.ensureWritable(1, true);\n            Assert.assertEquals(1, result);\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test(expected = ReadOnlyBufferException.class)\n    public void ensureWritableShouldThrow() {\n        ByteBuf buf = buffer(allocate(8).asReadOnlyBuffer()).clear();\n        try {\n            buf.ensureWritable(1);\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test(expected = ReadOnlyBufferException.class)\n    public void testSetByte() {\n        ByteBuf buf = buffer(allocate(8).asReadOnlyBuffer());\n        try {\n            buf.setByte(0, 1);\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test(expected = ReadOnlyBufferException.class)\n    public void testSetInt() {\n        ByteBuf buf = buffer(allocate(8).asReadOnlyBuffer());\n        try {\n            buf.setInt(0, 1);\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test(expected = ReadOnlyBufferException.class)\n    public void testSetShort() {\n        ByteBuf buf = buffer(allocate(8).asReadOnlyBuffer());\n        try {\n            buf.setShort(0, 1);\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test(expected = ReadOnlyBufferException.class)\n    public void testSetMedium() {\n        ByteBuf buf = buffer(allocate(8).asReadOnlyBuffer());\n        try {\n            buf.setMedium(0, 1);\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test(expected = ReadOnlyBufferException.class)\n    public void testSetLong() {\n        ByteBuf buf = buffer(allocate(8).asReadOnlyBuffer());\n        try {\n            buf.setLong(0, 1);\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test(expected = ReadOnlyBufferException.class)\n    public void testSetBytesViaArray() {\n        ByteBuf buf = buffer(allocate(8).asReadOnlyBuffer());\n        try {\n            buf.setBytes(0, \"test\".getBytes());\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test(expected = ReadOnlyBufferException.class)\n    public void testSetBytesViaBuffer() {\n        ByteBuf buf = buffer(allocate(8).asReadOnlyBuffer());\n        ByteBuf copy = Unpooled.copyInt(1);\n        try {\n            buf.setBytes(0, copy);\n        } finally {\n            buf.release();\n            copy.release();\n        }\n    }\n\n    @Test(expected = ReadOnlyBufferException.class)\n    public void testSetBytesViaStream() throws IOException {\n        ByteBuf buf = buffer(ByteBuffer.allocateDirect(8).asReadOnlyBuffer());\n        try {\n            buf.setBytes(0, new ByteArrayInputStream(\"test\".getBytes()), 2);\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test\n    public void testGetReadByte() {\n        ByteBuf buf = buffer(\n                ((ByteBuffer) allocate(2).put(new byte[] { (byte) 1, (byte) 2 }).flip()).asReadOnlyBuffer());\n\n        Assert.assertEquals(1, buf.getByte(0));\n        Assert.assertEquals(2, buf.getByte(1));\n\n        Assert.assertEquals(1, buf.readByte());\n        Assert.assertEquals(2, buf.readByte());\n        Assert.assertFalse(buf.isReadable());\n\n        buf.release();\n    }\n\n    @Test\n    public void testGetReadInt() {\n        ByteBuf buf = buffer(((ByteBuffer) allocate(8).putInt(1).putInt(2).flip()).asReadOnlyBuffer());\n\n        Assert.assertEquals(1, buf.getInt(0));\n        Assert.assertEquals(2, buf.getInt(4));\n\n        Assert.assertEquals(1, buf.readInt());\n        Assert.assertEquals(2, buf.readInt());\n        Assert.assertFalse(buf.isReadable());\n\n        buf.release();\n    }\n\n    @Test\n    public void testGetReadShort() {\n        ByteBuf buf = buffer(((ByteBuffer) allocate(8)\n                .putShort((short) 1).putShort((short) 2).flip()).asReadOnlyBuffer());\n\n        Assert.assertEquals(1, buf.getShort(0));\n        Assert.assertEquals(2, buf.getShort(2));\n\n        Assert.assertEquals(1, buf.readShort());\n        Assert.assertEquals(2, buf.readShort());\n        Assert.assertFalse(buf.isReadable());\n\n        buf.release();\n    }\n\n    @Test\n    public void testGetReadLong() {\n        ByteBuf buf = buffer(((ByteBuffer) allocate(16)\n                .putLong(1).putLong(2).flip()).asReadOnlyBuffer());\n\n        Assert.assertEquals(1, buf.getLong(0));\n        Assert.assertEquals(2, buf.getLong(8));\n\n        Assert.assertEquals(1, buf.readLong());\n        Assert.assertEquals(2, buf.readLong());\n        Assert.assertFalse(buf.isReadable());\n\n        buf.release();\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testGetBytesByteBuffer() {\n        byte[] bytes = {'a', 'b', 'c', 'd', 'e', 'f', 'g'};\n        // Ensure destination buffer is bigger then what is in the ByteBuf.\n        ByteBuffer nioBuffer = ByteBuffer.allocate(bytes.length + 1);\n        ByteBuf buffer = buffer(((ByteBuffer) allocate(bytes.length)\n                .put(bytes).flip()).asReadOnlyBuffer());\n        try {\n            buffer.getBytes(buffer.readerIndex(), nioBuffer);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test\n    public void testCopy() {\n        ByteBuf buf = buffer(((ByteBuffer) allocate(16).putLong(1).putLong(2).flip()).asReadOnlyBuffer());\n        ByteBuf copy = buf.copy();\n\n        Assert.assertEquals(buf, copy);\n\n        buf.release();\n        copy.release();\n    }\n\n    @Test\n    public void testCopyWithOffset() {\n        ByteBuf buf = buffer(((ByteBuffer) allocate(16).putLong(1).putLong(2).flip()).asReadOnlyBuffer());\n        ByteBuf copy = buf.copy(1, 9);\n\n        Assert.assertEquals(buf.slice(1, 9), copy);\n\n        buf.release();\n        copy.release();\n    }\n\n    // Test for https://github.com/netty/netty/issues/1708\n    @Test\n    public void testWrapBufferWithNonZeroPosition() {\n        ByteBuf buf = buffer(((ByteBuffer) allocate(16)\n                .putLong(1).flip().position(1)).asReadOnlyBuffer());\n\n        ByteBuf slice = buf.slice();\n        Assert.assertEquals(buf, slice);\n\n        buf.release();\n    }\n\n    @Test\n    public void testWrapBufferRoundTrip() {\n        ByteBuf buf = buffer(((ByteBuffer) allocate(16).putInt(1).putInt(2).flip()).asReadOnlyBuffer());\n\n        Assert.assertEquals(1, buf.readInt());\n\n        ByteBuffer nioBuffer = buf.nioBuffer();\n\n        // Ensure this can be accessed without throwing a BufferUnderflowException\n        Assert.assertEquals(2, nioBuffer.getInt());\n\n        buf.release();\n    }\n\n    @Test\n    public void testWrapMemoryMapped() throws Exception {\n        File file = File.createTempFile(\"netty-test\", \"tmp\");\n        FileChannel output = null;\n        FileChannel input = null;\n        ByteBuf b1 = null;\n        ByteBuf b2 = null;\n\n        try {\n            output = new RandomAccessFile(file, \"rw\").getChannel();\n            byte[] bytes = new byte[1024];\n            PlatformDependent.threadLocalRandom().nextBytes(bytes);\n            output.write(ByteBuffer.wrap(bytes));\n\n            input = new RandomAccessFile(file, \"r\").getChannel();\n            ByteBuffer m = input.map(FileChannel.MapMode.READ_ONLY, 0, input.size());\n\n            b1 = buffer(m);\n\n            ByteBuffer dup = m.duplicate();\n            dup.position(2);\n            dup.limit(4);\n\n            b2 = buffer(dup);\n\n            Assert.assertEquals(b2, b1.slice(2, 2));\n        } finally {\n            if (b1 != null) {\n                b1.release();\n            }\n            if (b2 != null) {\n                b2.release();\n            }\n            if (output != null) {\n                output.close();\n            }\n            if (input != null) {\n                input.close();\n            }\n            file.delete();\n        }\n    }\n\n    @Test\n    public void testMemoryAddress() {\n        ByteBuf buf = buffer(allocate(8).asReadOnlyBuffer());\n        try {\n            Assert.assertFalse(buf.hasMemoryAddress());\n            try {\n                buf.memoryAddress();\n                Assert.fail();\n            } catch (UnsupportedOperationException expected) {\n                // expected\n            }\n        } finally {\n            buf.release();\n        }\n    }\n}\n", "/*\n * Copyright 2012 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.codec.http.multipart;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.handler.codec.http.HttpConstants;\nimport io.netty.util.internal.EmptyArrays;\nimport io.netty.util.internal.ObjectUtil;\nimport io.netty.util.internal.logging.InternalLogger;\nimport io.netty.util.internal.logging.InternalLoggerFactory;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.RandomAccessFile;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.charset.Charset;\n\nimport static io.netty.buffer.Unpooled.EMPTY_BUFFER;\nimport static io.netty.buffer.Unpooled.wrappedBuffer;\n\n/**\n * Abstract Disk HttpData implementation\n */\npublic abstract class AbstractDiskHttpData extends AbstractHttpData {\n\n    private static final InternalLogger logger = InternalLoggerFactory.getInstance(AbstractDiskHttpData.class);\n\n    private File file;\n    private boolean isRenamed;\n    private FileChannel fileChannel;\n\n    protected AbstractDiskHttpData(String name, Charset charset, long size) {\n        super(name, charset, size);\n    }\n\n    /**\n     *\n     * @return the real DiskFilename (basename)\n     */\n    protected abstract String getDiskFilename();\n    /**\n     *\n     * @return the default prefix\n     */\n    protected abstract String getPrefix();\n    /**\n     *\n     * @return the default base Directory\n     */\n    protected abstract String getBaseDirectory();\n    /**\n     *\n     * @return the default postfix\n     */\n    protected abstract String getPostfix();\n    /**\n     *\n     * @return True if the file should be deleted on Exit by default\n     */\n    protected abstract boolean deleteOnExit();\n\n    /**\n     * @return a new Temp File from getDiskFilename(), default prefix, postfix and baseDirectory\n     */\n    private File tempFile() throws IOException {\n        String newpostfix;\n        String diskFilename = getDiskFilename();\n        if (diskFilename != null) {\n            newpostfix = '_' + diskFilename;\n        } else {\n            newpostfix = getPostfix();\n        }\n        File tmpFile;\n        if (getBaseDirectory() == null) {\n            // create a temporary file\n            tmpFile = File.createTempFile(getPrefix(), newpostfix);\n        } else {\n            tmpFile = File.createTempFile(getPrefix(), newpostfix, new File(\n                    getBaseDirectory()));\n        }\n        if (deleteOnExit()) {\n            // See https://github.com/netty/netty/issues/10351\n            DeleteFileOnExitHook.add(tmpFile.getPath());\n        }\n        return tmpFile;\n    }\n\n    @Override\n    public void setContent(ByteBuf buffer) throws IOException {\n        ObjectUtil.checkNotNull(buffer, \"buffer\");\n        try {\n            size = buffer.readableBytes();\n            checkSize(size);\n            if (definedSize > 0 && definedSize < size) {\n                throw new IOException(\"Out of size: \" + size + \" > \" + definedSize);\n            }\n            if (file == null) {\n                file = tempFile();\n            }\n            if (buffer.readableBytes() == 0) {\n                // empty file\n                if (!file.createNewFile()) {\n                    if (file.length() == 0) {\n                        return;\n                    } else {\n                        if (!file.delete() || !file.createNewFile()) {\n                            throw new IOException(\"file exists already: \" + file);\n                        }\n                    }\n                }\n                return;\n            }\n            RandomAccessFile accessFile = new RandomAccessFile(file, \"rw\");\n            try {\n                accessFile.setLength(0);\n                FileChannel localfileChannel = accessFile.getChannel();\n                ByteBuffer byteBuffer = buffer.nioBuffer();\n                int written = 0;\n                while (written < size) {\n                    written += localfileChannel.write(byteBuffer);\n                }\n                buffer.readerIndex(buffer.readerIndex() + written);\n                localfileChannel.force(false);\n            } finally {\n                accessFile.close();\n            }\n            setCompleted();\n        } finally {\n            // Release the buffer as it was retained before and we not need a reference to it at all\n            // See https://github.com/netty/netty/issues/1516\n            buffer.release();\n        }\n    }\n\n    @Override\n    public void addContent(ByteBuf buffer, boolean last)\n            throws IOException {\n        if (buffer != null) {\n            try {\n                int localsize = buffer.readableBytes();\n                checkSize(size + localsize);\n                if (definedSize > 0 && definedSize < size + localsize) {\n                    throw new IOException(\"Out of size: \" + (size + localsize) +\n                            \" > \" + definedSize);\n                }\n                if (file == null) {\n                    file = tempFile();\n                }\n                if (fileChannel == null) {\n                    RandomAccessFile accessFile = new RandomAccessFile(file, \"rw\");\n                    fileChannel = accessFile.getChannel();\n                }\n                int remaining = localsize;\n                long position = fileChannel.position();\n                int index = buffer.readerIndex();\n                while (remaining > 0) {\n                    int written = buffer.getBytes(index, fileChannel, position, remaining);\n                    if (written < 0) {\n                        break;\n                    }\n                    remaining -= written;\n                    position += written;\n                    index += written;\n                }\n                fileChannel.position(position);\n                buffer.readerIndex(index);\n                size += localsize - remaining;\n            } finally {\n                // Release the buffer as it was retained before and we not need a reference to it at all\n                // See https://github.com/netty/netty/issues/1516\n                buffer.release();\n            }\n        }\n        if (last) {\n            if (file == null) {\n                file = tempFile();\n            }\n            if (fileChannel == null) {\n                RandomAccessFile accessFile = new RandomAccessFile(file, \"rw\");\n                fileChannel = accessFile.getChannel();\n            }\n            try {\n                fileChannel.force(false);\n            } finally {\n                fileChannel.close();\n            }\n            fileChannel = null;\n            setCompleted();\n        } else {\n            ObjectUtil.checkNotNull(buffer, \"buffer\");\n        }\n    }\n\n    @Override\n    public void setContent(File file) throws IOException {\n        long size = file.length();\n        checkSize(size);\n        this.size = size;\n        if (this.file != null) {\n            delete();\n        }\n        this.file = file;\n        isRenamed = true;\n        setCompleted();\n    }\n\n    @Override\n    public void setContent(InputStream inputStream) throws IOException {\n        ObjectUtil.checkNotNull(inputStream, \"inputStream\");\n        if (file != null) {\n            delete();\n        }\n        file = tempFile();\n        RandomAccessFile accessFile = new RandomAccessFile(file, \"rw\");\n        int written = 0;\n        try {\n            accessFile.setLength(0);\n            FileChannel localfileChannel = accessFile.getChannel();\n            byte[] bytes = new byte[4096 * 4];\n            ByteBuffer byteBuffer = ByteBuffer.wrap(bytes);\n            int read = inputStream.read(bytes);\n            while (read > 0) {\n                byteBuffer.position(read).flip();\n                written += localfileChannel.write(byteBuffer);\n                checkSize(written);\n                read = inputStream.read(bytes);\n            }\n            localfileChannel.force(false);\n        } finally {\n            accessFile.close();\n        }\n        size = written;\n        if (definedSize > 0 && definedSize < size) {\n            if (!file.delete()) {\n                logger.warn(\"Failed to delete: {}\", file);\n            }\n            file = null;\n            throw new IOException(\"Out of size: \" + size + \" > \" + definedSize);\n        }\n        isRenamed = true;\n        setCompleted();\n    }\n\n    @Override\n    public void delete() {\n        if (fileChannel != null) {\n            try {\n                fileChannel.force(false);\n            } catch (IOException e) {\n                logger.warn(\"Failed to force.\", e);\n            } finally {\n                try {\n                    fileChannel.close();\n                } catch (IOException e) {\n                    logger.warn(\"Failed to close a file.\", e);\n                }\n            }\n            fileChannel = null;\n        }\n        if (!isRenamed) {\n            String filePath = null;\n\n            if (file != null && file.exists()) {\n                filePath = file.getPath();\n                if (!file.delete()) {\n                    filePath = null;\n                    logger.warn(\"Failed to delete: {}\", file);\n                }\n            }\n\n            // If you turn on deleteOnExit make sure it is executed.\n            if (deleteOnExit() && filePath != null) {\n                DeleteFileOnExitHook.remove(filePath);\n            }\n            file = null;\n        }\n    }\n\n    @Override\n    public byte[] get() throws IOException {\n        if (file == null) {\n            return EmptyArrays.EMPTY_BYTES;\n        }\n        return readFrom(file);\n    }\n\n    @Override\n    public ByteBuf getByteBuf() throws IOException {\n        if (file == null) {\n            return EMPTY_BUFFER;\n        }\n        byte[] array = readFrom(file);\n        return wrappedBuffer(array);\n    }\n\n    @Override\n    public ByteBuf getChunk(int length) throws IOException {\n        if (file == null || length == 0) {\n            return EMPTY_BUFFER;\n        }\n        if (fileChannel == null) {\n            RandomAccessFile accessFile = new RandomAccessFile(file, \"r\");\n            fileChannel = accessFile.getChannel();\n        }\n        int read = 0;\n        ByteBuffer byteBuffer = ByteBuffer.allocate(length);\n        try {\n            while (read < length) {\n                int readnow = fileChannel.read(byteBuffer);\n                if (readnow == -1) {\n                    fileChannel.close();\n                    fileChannel = null;\n                    break;\n                }\n                read += readnow;\n            }\n        } catch (IOException e) {\n            fileChannel.close();\n            fileChannel = null;\n            throw e;\n        }\n        if (read == 0) {\n            return EMPTY_BUFFER;\n        }\n        byteBuffer.flip();\n        ByteBuf buffer = wrappedBuffer(byteBuffer);\n        buffer.readerIndex(0);\n        buffer.writerIndex(read);\n        return buffer;\n    }\n\n    @Override\n    public String getString() throws IOException {\n        return getString(HttpConstants.DEFAULT_CHARSET);\n    }\n\n    @Override\n    public String getString(Charset encoding) throws IOException {\n        if (file == null) {\n            return \"\";\n        }\n        if (encoding == null) {\n            byte[] array = readFrom(file);\n            return new String(array, HttpConstants.DEFAULT_CHARSET.name());\n        }\n        byte[] array = readFrom(file);\n        return new String(array, encoding.name());\n    }\n\n    @Override\n    public boolean isInMemory() {\n        return false;\n    }\n\n    @Override\n    public boolean renameTo(File dest) throws IOException {\n        ObjectUtil.checkNotNull(dest, \"dest\");\n        if (file == null) {\n            throw new IOException(\"No file defined so cannot be renamed\");\n        }\n        if (!file.renameTo(dest)) {\n            // must copy\n            IOException exception = null;\n            RandomAccessFile inputAccessFile = null;\n            RandomAccessFile outputAccessFile = null;\n            long chunkSize = 8196;\n            long position = 0;\n            try {\n                inputAccessFile = new RandomAccessFile(file, \"r\");\n                outputAccessFile = new RandomAccessFile(dest, \"rw\");\n                FileChannel in = inputAccessFile.getChannel();\n                FileChannel out = outputAccessFile.getChannel();\n                while (position < size) {\n                    if (chunkSize < size - position) {\n                        chunkSize = size - position;\n                    }\n                    position += in.transferTo(position, chunkSize, out);\n                }\n            } catch (IOException e) {\n                exception = e;\n            } finally {\n                if (inputAccessFile != null) {\n                    try {\n                        inputAccessFile.close();\n                    } catch (IOException e) {\n                        if (exception == null) { // Choose to report the first exception\n                            exception = e;\n                        } else {\n                            logger.warn(\"Multiple exceptions detected, the following will be suppressed {}\", e);\n                        }\n                    }\n                }\n                if (outputAccessFile != null) {\n                    try {\n                        outputAccessFile.close();\n                    } catch (IOException e) {\n                        if (exception == null) { // Choose to report the first exception\n                            exception = e;\n                        } else {\n                            logger.warn(\"Multiple exceptions detected, the following will be suppressed {}\", e);\n                        }\n                    }\n                }\n            }\n            if (exception != null) {\n                throw exception;\n            }\n            if (position == size) {\n                if (!file.delete()) {\n                    logger.warn(\"Failed to delete: {}\", file);\n                }\n                file = dest;\n                isRenamed = true;\n                return true;\n            } else {\n                if (!dest.delete()) {\n                    logger.warn(\"Failed to delete: {}\", dest);\n                }\n                return false;\n            }\n        }\n        file = dest;\n        isRenamed = true;\n        return true;\n    }\n\n    /**\n     * Utility function\n     *\n     * @return the array of bytes\n     */\n    private static byte[] readFrom(File src) throws IOException {\n        long srcsize = src.length();\n        if (srcsize > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"File too big to be loaded in memory\");\n        }\n        RandomAccessFile accessFile = new RandomAccessFile(src, \"r\");\n        byte[] array = new byte[(int) srcsize];\n        try {\n            FileChannel fileChannel = accessFile.getChannel();\n            ByteBuffer byteBuffer = ByteBuffer.wrap(array);\n            int read = 0;\n            while (read < srcsize) {\n                read += fileChannel.read(byteBuffer);\n            }\n        } finally {\n            accessFile.close();\n        }\n        return array;\n    }\n\n    @Override\n    public File getFile() throws IOException {\n        return file;\n    }\n\n    @Override\n    public HttpData touch() {\n        return this;\n    }\n\n    @Override\n    public HttpData touch(Object hint) {\n        return this;\n    }\n}\n", "/*\n * Copyright 2014 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.codec.http;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufAllocator;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.embedded.EmbeddedChannel;\nimport io.netty.handler.stream.ChunkedFile;\nimport io.netty.handler.stream.ChunkedInput;\nimport io.netty.handler.stream.ChunkedNioFile;\nimport io.netty.handler.stream.ChunkedNioStream;\nimport io.netty.handler.stream.ChunkedStream;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport org.junit.Test;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.channels.Channels;\n\nimport static org.junit.Assert.*;\n\npublic class HttpChunkedInputTest {\n    private static final byte[] BYTES = new byte[1024 * 64];\n    private static final File TMP;\n\n    static {\n        for (int i = 0; i < BYTES.length; i++) {\n            BYTES[i] = (byte) i;\n        }\n\n        FileOutputStream out = null;\n        try {\n            TMP = File.createTempFile(\"netty-chunk-\", \".tmp\");\n            TMP.deleteOnExit();\n            out = new FileOutputStream(TMP);\n            out.write(BYTES);\n            out.flush();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            if (out != null) {\n                try {\n                    out.close();\n                } catch (IOException e) {\n                    // ignore\n                }\n            }\n        }\n    }\n\n    @Test\n    public void testChunkedStream() {\n        check(new HttpChunkedInput(new ChunkedStream(new ByteArrayInputStream(BYTES))));\n    }\n\n    @Test\n    public void testChunkedNioStream() {\n        check(new HttpChunkedInput(new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES)))));\n    }\n\n    @Test\n    public void testChunkedFile() throws IOException {\n        check(new HttpChunkedInput(new ChunkedFile(TMP)));\n    }\n\n    @Test\n    public void testChunkedNioFile() throws IOException {\n        check(new HttpChunkedInput(new ChunkedNioFile(TMP)));\n    }\n\n    @Test\n    public void testWrappedReturnNull() throws Exception {\n        HttpChunkedInput input = new HttpChunkedInput(new ChunkedInput<ByteBuf>() {\n            @Override\n            public boolean isEndOfInput() throws Exception {\n                return false;\n            }\n\n            @Override\n            public void close() throws Exception {\n                // NOOP\n            }\n\n            @Override\n            public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {\n                return null;\n            }\n\n            @Override\n            public ByteBuf readChunk(ByteBufAllocator allocator) throws Exception {\n                return null;\n            }\n\n            @Override\n            public long length() {\n                return 0;\n            }\n\n            @Override\n            public long progress() {\n                return 0;\n            }\n        });\n        assertNull(input.readChunk(ByteBufAllocator.DEFAULT));\n    }\n\n    private static void check(ChunkedInput<?>... inputs) {\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n\n        for (ChunkedInput<?> input : inputs) {\n            ch.writeOutbound(input);\n        }\n\n        assertTrue(ch.finish());\n\n        int i = 0;\n        int read = 0;\n        HttpContent lastHttpContent = null;\n        for (;;) {\n            HttpContent httpContent = ch.readOutbound();\n            if (httpContent == null) {\n                break;\n            }\n            if (lastHttpContent != null) {\n                assertTrue(\"Chunk must be DefaultHttpContent\", lastHttpContent instanceof DefaultHttpContent);\n            }\n\n            ByteBuf buffer = httpContent.content();\n            while (buffer.isReadable()) {\n                assertEquals(BYTES[i++], buffer.readByte());\n                read++;\n                if (i == BYTES.length) {\n                    i = 0;\n                }\n            }\n            buffer.release();\n\n            // Save last chunk\n            lastHttpContent = httpContent;\n        }\n\n        assertEquals(BYTES.length * inputs.length, read);\n        assertSame(\"Last chunk must be LastHttpContent.EMPTY_LAST_CONTENT\",\n                LastHttpContent.EMPTY_LAST_CONTENT, lastHttpContent);\n    }\n}\n", "/*\n * Copyright 2020 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.codec.http.multipart;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufUtil;\nimport io.netty.util.internal.PlatformDependent;\nimport org.junit.Test;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.nio.charset.Charset;\nimport java.util.Arrays;\nimport java.util.UUID;\n\nimport static io.netty.util.CharsetUtil.UTF_8;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\n\n/**\n * {@link AbstractDiskHttpData} test cases\n */\npublic class AbstractDiskHttpDataTest {\n\n    @Test\n    public void testGetChunk() throws Exception {\n        TestHttpData test = new TestHttpData(\"test\", UTF_8, 0);\n        try {\n            File tmpFile = File.createTempFile(UUID.randomUUID().toString(), \".tmp\");\n            tmpFile.deleteOnExit();\n            FileOutputStream fos = new FileOutputStream(tmpFile);\n            byte[] bytes = new byte[4096];\n            PlatformDependent.threadLocalRandom().nextBytes(bytes);\n            try {\n                fos.write(bytes);\n                fos.flush();\n            } finally {\n                fos.close();\n            }\n            test.setContent(tmpFile);\n            ByteBuf buf1 = test.getChunk(1024);\n            assertEquals(buf1.readerIndex(), 0);\n            assertEquals(buf1.writerIndex(), 1024);\n            ByteBuf buf2 = test.getChunk(1024);\n            assertEquals(buf2.readerIndex(), 0);\n            assertEquals(buf2.writerIndex(), 1024);\n            assertFalse(\"Arrays should not be equal\",\n                    Arrays.equals(ByteBufUtil.getBytes(buf1), ByteBufUtil.getBytes(buf2)));\n        } finally {\n            test.delete();\n        }\n    }\n\n    private static final class TestHttpData extends AbstractDiskHttpData {\n\n        private TestHttpData(String name, Charset charset, long size) {\n            super(name, charset, size);\n        }\n\n        @Override\n        protected String getDiskFilename() {\n            return null;\n        }\n\n        @Override\n        protected String getPrefix() {\n            return null;\n        }\n\n        @Override\n        protected String getBaseDirectory() {\n            return null;\n        }\n\n        @Override\n        protected String getPostfix() {\n            return null;\n        }\n\n        @Override\n        protected boolean deleteOnExit() {\n            return false;\n        }\n\n        @Override\n        public HttpData copy() {\n            return null;\n        }\n\n        @Override\n        public HttpData duplicate() {\n            return null;\n        }\n\n        @Override\n        public HttpData retainedDuplicate() {\n            return null;\n        }\n\n        @Override\n        public HttpData replace(ByteBuf content) {\n            return null;\n        }\n\n        @Override\n        public HttpDataType getHttpDataType() {\n            return null;\n        }\n\n        @Override\n        public int compareTo(InterfaceHttpData o) {\n            return 0;\n        }\n    }\n}\n", "/*\n * Copyright 2012 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.codec.http.multipart;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufInputStream;\nimport io.netty.buffer.ByteBufUtil;\nimport io.netty.buffer.Unpooled;\nimport io.netty.util.internal.PlatformDependent;\n\nimport org.junit.Test;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.nio.charset.Charset;\nimport java.security.SecureRandom;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.UUID;\n\nimport static io.netty.util.CharsetUtil.*;\nimport static org.junit.Assert.*;\n\n/** {@link AbstractMemoryHttpData} test cases. */\npublic class AbstractMemoryHttpDataTest {\n\n    @Test\n    public void testSetContentFromFile() throws Exception {\n        TestHttpData test = new TestHttpData(\"test\", UTF_8, 0);\n        try {\n            File tmpFile = File.createTempFile(UUID.randomUUID().toString(), \".tmp\");\n            tmpFile.deleteOnExit();\n            FileOutputStream fos = new FileOutputStream(tmpFile);\n            byte[] bytes = new byte[4096];\n            PlatformDependent.threadLocalRandom().nextBytes(bytes);\n            try {\n                fos.write(bytes);\n                fos.flush();\n            } finally {\n                fos.close();\n            }\n            test.setContent(tmpFile);\n            ByteBuf buf = test.getByteBuf();\n            assertEquals(buf.readerIndex(), 0);\n            assertEquals(buf.writerIndex(), bytes.length);\n            assertArrayEquals(bytes, test.get());\n            assertArrayEquals(bytes, ByteBufUtil.getBytes(buf));\n        } finally {\n            //release the ByteBuf\n            test.delete();\n        }\n    }\n\n    @Test\n    public void testRenameTo() throws Exception {\n        TestHttpData test = new TestHttpData(\"test\", UTF_8, 0);\n        try {\n            File tmpFile = File.createTempFile(UUID.randomUUID().toString(), \".tmp\");\n            tmpFile.deleteOnExit();\n            final int totalByteCount = 4096;\n            byte[] bytes = new byte[totalByteCount];\n            PlatformDependent.threadLocalRandom().nextBytes(bytes);\n            ByteBuf content = Unpooled.wrappedBuffer(bytes);\n            test.setContent(content);\n            boolean succ = test.renameTo(tmpFile);\n            assertTrue(succ);\n            FileInputStream fis = new FileInputStream(tmpFile);\n            try {\n                byte[] buf = new byte[totalByteCount];\n                int count = 0;\n                int offset = 0;\n                int size = totalByteCount;\n                while ((count = fis.read(buf, offset, size)) > 0) {\n                    offset += count;\n                    size -= count;\n                    if (offset >= totalByteCount || size <= 0) {\n                        break;\n                    }\n                }\n                assertArrayEquals(bytes, buf);\n                assertEquals(0, fis.available());\n            } finally {\n                fis.close();\n            }\n        } finally {\n            //release the ByteBuf in AbstractMemoryHttpData\n            test.delete();\n        }\n    }\n    /**\n     * Provide content into HTTP data with input stream.\n     *\n     * @throws Exception In case of any exception.\n     */\n    @Test\n    public void testSetContentFromStream() throws Exception {\n        // definedSize=0\n        TestHttpData test = new TestHttpData(\"test\", UTF_8, 0);\n        String contentStr = \"foo_test\";\n        ByteBuf buf = Unpooled.wrappedBuffer(contentStr.getBytes(UTF_8));\n        buf.markReaderIndex();\n        ByteBufInputStream is = new ByteBufInputStream(buf);\n        try {\n            test.setContent(is);\n            assertFalse(buf.isReadable());\n            assertEquals(test.getString(UTF_8), contentStr);\n            buf.resetReaderIndex();\n            assertTrue(ByteBufUtil.equals(buf, test.getByteBuf()));\n        } finally {\n            is.close();\n        }\n\n        Random random = new SecureRandom();\n\n        for (int i = 0; i < 20; i++) {\n            // Generate input data bytes.\n            int size = random.nextInt(Short.MAX_VALUE);\n            byte[] bytes = new byte[size];\n\n            random.nextBytes(bytes);\n\n            // Generate parsed HTTP data block.\n            TestHttpData data = new TestHttpData(\"name\", UTF_8, 0);\n\n            data.setContent(new ByteArrayInputStream(bytes));\n\n            // Validate stored data.\n            ByteBuf buffer = data.getByteBuf();\n\n            assertEquals(0, buffer.readerIndex());\n            assertEquals(bytes.length, buffer.writerIndex());\n            assertArrayEquals(bytes, Arrays.copyOf(buffer.array(), bytes.length));\n            assertArrayEquals(bytes, data.get());\n        }\n    }\n\n    /** Memory-based HTTP data implementation for test purposes. */\n    private static final class TestHttpData extends AbstractMemoryHttpData {\n        /**\n         * Constructs HTTP data for tests.\n         *\n         * @param name    Name of parsed data block.\n         * @param charset Used charset for data decoding.\n         * @param size    Expected data block size.\n         */\n        private TestHttpData(String name, Charset charset, long size) {\n            super(name, charset, size);\n        }\n\n        @Override\n        public InterfaceHttpData.HttpDataType getHttpDataType() {\n            throw reject();\n        }\n\n        @Override\n        public HttpData copy() {\n            throw reject();\n        }\n\n        @Override\n        public HttpData duplicate() {\n            throw reject();\n        }\n\n        @Override\n        public HttpData retainedDuplicate() {\n            throw reject();\n        }\n\n        @Override\n        public HttpData replace(ByteBuf content) {\n            return null;\n        }\n\n        @Override\n        public int compareTo(InterfaceHttpData o) {\n            throw reject();\n        }\n\n        @Override\n        public int hashCode() {\n            return super.hashCode();\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            return super.equals(obj);\n        }\n\n        private static UnsupportedOperationException reject() {\n            throw new UnsupportedOperationException(\"Should never be called.\");\n        }\n    }\n}\n", "/*\n * Copyright 2016 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.codec.http.multipart;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufInputStream;\nimport io.netty.buffer.ByteBufUtil;\nimport io.netty.buffer.Unpooled;\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.internal.PlatformDependent;\n\nimport org.junit.Test;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.UUID;\n\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\npublic class DiskFileUploadTest {\n    @Test\n    public void testSpecificCustomBaseDir() throws IOException {\n        File baseDir = new File(\"target/DiskFileUploadTest/testSpecificCustomBaseDir\");\n        baseDir.mkdirs(); // we don't need to clean it since it is in volatile files anyway\n        DiskFileUpload f =\n                new DiskFileUpload(\"d1\", \"d1\", \"application/json\", null, null, 100,\n                        baseDir.getAbsolutePath(), false);\n\n        f.setContent(Unpooled.EMPTY_BUFFER);\n\n        assertTrue(f.getFile().getAbsolutePath().startsWith(baseDir.getAbsolutePath()));\n        assertTrue(f.getFile().exists());\n        assertEquals(0, f.getFile().length());\n        f.delete();\n    }\n\n    @Test\n    public final void testDiskFileUploadEquals() {\n        DiskFileUpload f2 =\n                new DiskFileUpload(\"d1\", \"d1\", \"application/json\", null, null, 100);\n        assertEquals(f2, f2);\n        f2.delete();\n    }\n\n     @Test\n     public void testEmptyBufferSetMultipleTimes() throws IOException {\n         DiskFileUpload f =\n                 new DiskFileUpload(\"d1\", \"d1\", \"application/json\", null, null, 100);\n\n         f.setContent(Unpooled.EMPTY_BUFFER);\n\n         assertTrue(f.getFile().exists());\n         assertEquals(0, f.getFile().length());\n         f.setContent(Unpooled.EMPTY_BUFFER);\n         assertTrue(f.getFile().exists());\n         assertEquals(0, f.getFile().length());\n         f.delete();\n     }\n\n    @Test\n    public void testEmptyBufferSetAfterNonEmptyBuffer() throws IOException {\n        DiskFileUpload f =\n                new DiskFileUpload(\"d1\", \"d1\", \"application/json\", null, null, 100);\n\n        f.setContent(Unpooled.wrappedBuffer(new byte[] { 1, 2, 3, 4 }));\n\n        assertTrue(f.getFile().exists());\n        assertEquals(4, f.getFile().length());\n        f.setContent(Unpooled.EMPTY_BUFFER);\n        assertTrue(f.getFile().exists());\n        assertEquals(0, f.getFile().length());\n        f.delete();\n    }\n\n    @Test\n    public void testNonEmptyBufferSetMultipleTimes() throws IOException {\n        DiskFileUpload f =\n                new DiskFileUpload(\"d1\", \"d1\", \"application/json\", null, null, 100);\n\n        f.setContent(Unpooled.wrappedBuffer(new byte[] { 1, 2, 3, 4 }));\n\n        assertTrue(f.getFile().exists());\n        assertEquals(4, f.getFile().length());\n        f.setContent(Unpooled.wrappedBuffer(new byte[] { 1, 2}));\n        assertTrue(f.getFile().exists());\n        assertEquals(2, f.getFile().length());\n        f.delete();\n    }\n\n    @Test\n    public void testAddContents() throws Exception {\n        DiskFileUpload f1 = new DiskFileUpload(\"file1\", \"file1\", \"application/json\", null, null, 0);\n        try {\n            byte[] jsonBytes = new byte[4096];\n            PlatformDependent.threadLocalRandom().nextBytes(jsonBytes);\n\n            f1.addContent(Unpooled.wrappedBuffer(jsonBytes, 0, 1024), false);\n            f1.addContent(Unpooled.wrappedBuffer(jsonBytes, 1024, jsonBytes.length - 1024), true);\n            assertArrayEquals(jsonBytes, f1.get());\n\n            File file = f1.getFile();\n            assertEquals(jsonBytes.length, file.length());\n\n            FileInputStream fis = new FileInputStream(file);\n            try {\n                byte[] buf = new byte[jsonBytes.length];\n                int offset = 0;\n                int read = 0;\n                int len = buf.length;\n                while ((read = fis.read(buf, offset, len)) > 0) {\n                    len -= read;\n                    offset += read;\n                    if (len <= 0 || offset >= buf.length) {\n                        break;\n                    }\n                }\n                assertArrayEquals(jsonBytes, buf);\n            } finally {\n                fis.close();\n            }\n        } finally {\n            f1.delete();\n        }\n    }\n\n    @Test\n    public void testSetContentFromByteBuf() throws Exception {\n        DiskFileUpload f1 = new DiskFileUpload(\"file2\", \"file2\", \"application/json\", null, null, 0);\n        try {\n            String json = \"{\\\"hello\\\":\\\"world\\\"}\";\n            byte[] bytes = json.getBytes(CharsetUtil.UTF_8);\n            f1.setContent(Unpooled.wrappedBuffer(bytes));\n            assertEquals(json, f1.getString());\n            assertArrayEquals(bytes, f1.get());\n            File file = f1.getFile();\n            assertEquals((long) bytes.length, file.length());\n            assertArrayEquals(bytes, doReadFile(file, bytes.length));\n        } finally {\n            f1.delete();\n        }\n    }\n\n    @Test\n    public void testSetContentFromInputStream() throws Exception {\n        String json = \"{\\\"hello\\\":\\\"world\\\",\\\"foo\\\":\\\"bar\\\"}\";\n        DiskFileUpload f1 = new DiskFileUpload(\"file3\", \"file3\", \"application/json\", null, null, 0);\n        try {\n            byte[] bytes = json.getBytes(CharsetUtil.UTF_8);\n            ByteBuf buf = Unpooled.wrappedBuffer(bytes);\n            InputStream is = new ByteBufInputStream(buf);\n            try {\n                f1.setContent(is);\n                assertEquals(json, f1.getString());\n                assertArrayEquals(bytes, f1.get());\n                File file = f1.getFile();\n                assertEquals((long) bytes.length, file.length());\n                assertArrayEquals(bytes, doReadFile(file, bytes.length));\n            } finally {\n                buf.release();\n                is.close();\n            }\n        } finally {\n            f1.delete();\n        }\n    }\n\n    @Test\n    public void testAddContentFromByteBuf() throws Exception {\n        testAddContentFromByteBuf0(false);\n    }\n\n    @Test\n    public void testAddContentFromCompositeByteBuf() throws Exception {\n        testAddContentFromByteBuf0(true);\n    }\n\n    private static void testAddContentFromByteBuf0(boolean composite) throws Exception {\n        DiskFileUpload f1 = new DiskFileUpload(\"file3\", \"file3\", \"application/json\", null, null, 0);\n        try {\n            byte[] bytes = new byte[4096];\n            PlatformDependent.threadLocalRandom().nextBytes(bytes);\n\n            final ByteBuf buffer;\n\n            if (composite) {\n                buffer = Unpooled.compositeBuffer()\n                        .addComponent(true, Unpooled.wrappedBuffer(bytes, 0 , bytes.length / 2))\n                        .addComponent(true, Unpooled.wrappedBuffer(bytes, bytes.length / 2, bytes.length / 2));\n            } else {\n                buffer = Unpooled.wrappedBuffer(bytes);\n            }\n            f1.addContent(buffer, true);\n            ByteBuf buf = f1.getByteBuf();\n            assertEquals(buf.readerIndex(), 0);\n            assertEquals(buf.writerIndex(), bytes.length);\n            assertArrayEquals(bytes, ByteBufUtil.getBytes(buf));\n        } finally {\n            //release the ByteBuf\n            f1.delete();\n        }\n    }\n\n    private static byte[] doReadFile(File file, int maxRead) throws Exception {\n        FileInputStream fis = new FileInputStream(file);\n        try {\n            byte[] buf = new byte[maxRead];\n            int offset = 0;\n            int read = 0;\n            int len = buf.length;\n            while ((read = fis.read(buf, offset, len)) > 0) {\n                len -= read;\n                offset += read;\n                if (len <= 0 || offset >= buf.length) {\n                    break;\n                }\n            }\n            return buf;\n        } finally {\n            fis.close();\n        }\n    }\n\n    @Test\n    public void testDelete() throws Exception {\n        String json = \"{\\\"foo\\\":\\\"bar\\\"}\";\n        byte[] bytes = json.getBytes(CharsetUtil.UTF_8);\n        File tmpFile = null;\n        DiskFileUpload f1 = new DiskFileUpload(\"file4\", \"file4\", \"application/json\", null, null, 0);\n        try {\n            assertNull(f1.getFile());\n            f1.setContent(Unpooled.wrappedBuffer(bytes));\n            assertNotNull(tmpFile = f1.getFile());\n        } finally {\n            f1.delete();\n            assertNull(f1.getFile());\n            assertNotNull(tmpFile);\n            assertFalse(tmpFile.exists());\n        }\n    }\n\n    @Test\n    public void setSetContentFromFileExceptionally() throws Exception {\n        final long maxSize = 4;\n        DiskFileUpload f1 = new DiskFileUpload(\"file5\", \"file5\", \"application/json\", null, null, 0);\n        f1.setMaxSize(maxSize);\n        try {\n            f1.setContent(Unpooled.wrappedBuffer(new byte[(int) maxSize]));\n            File originalFile = f1.getFile();\n            assertNotNull(originalFile);\n            assertEquals(maxSize, originalFile.length());\n            assertEquals(maxSize, f1.length());\n            byte[] bytes = new byte[8];\n            PlatformDependent.threadLocalRandom().nextBytes(bytes);\n            File tmpFile = File.createTempFile(UUID.randomUUID().toString(), \".tmp\");\n            tmpFile.deleteOnExit();\n            FileOutputStream fos = new FileOutputStream(tmpFile);\n            try {\n                fos.write(bytes);\n                fos.flush();\n            } finally {\n                fos.close();\n            }\n            try {\n                f1.setContent(tmpFile);\n                fail(\"should not reach here!\");\n            } catch (IOException e) {\n                assertNotNull(f1.getFile());\n                assertEquals(originalFile, f1.getFile());\n                assertEquals(maxSize, f1.length());\n            }\n        } finally {\n            f1.delete();\n        }\n    }\n}\n", "/*\n * Copyright 2014 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.util.internal;\n\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.internal.logging.InternalLogger;\nimport io.netty.util.internal.logging.InternalLoggerFactory;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.Method;\nimport java.net.URL;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Helper class to load JNI resources.\n *\n */\npublic final class NativeLibraryLoader {\n\n    private static final InternalLogger logger = InternalLoggerFactory.getInstance(NativeLibraryLoader.class);\n\n    private static final String NATIVE_RESOURCE_HOME = \"META-INF/native/\";\n    private static final File WORKDIR;\n    private static final boolean DELETE_NATIVE_LIB_AFTER_LOADING;\n    private static final boolean TRY_TO_PATCH_SHADED_ID;\n\n    // Just use a-Z and numbers as valid ID bytes.\n    private static final byte[] UNIQUE_ID_BYTES =\n            \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".getBytes(CharsetUtil.US_ASCII);\n\n    static {\n        String workdir = SystemPropertyUtil.get(\"io.netty.native.workdir\");\n        if (workdir != null) {\n            File f = new File(workdir);\n            f.mkdirs();\n\n            try {\n                f = f.getAbsoluteFile();\n            } catch (Exception ignored) {\n                // Good to have an absolute path, but it's OK.\n            }\n\n            WORKDIR = f;\n            logger.debug(\"-Dio.netty.native.workdir: \" + WORKDIR);\n        } else {\n            WORKDIR = PlatformDependent.tmpdir();\n            logger.debug(\"-Dio.netty.native.workdir: \" + WORKDIR + \" (io.netty.tmpdir)\");\n        }\n\n        DELETE_NATIVE_LIB_AFTER_LOADING = SystemPropertyUtil.getBoolean(\n                \"io.netty.native.deleteLibAfterLoading\", true);\n        logger.debug(\"-Dio.netty.native.deleteLibAfterLoading: {}\", DELETE_NATIVE_LIB_AFTER_LOADING);\n\n        TRY_TO_PATCH_SHADED_ID = SystemPropertyUtil.getBoolean(\n                \"io.netty.native.tryPatchShadedId\", true);\n        logger.debug(\"-Dio.netty.native.tryPatchShadedId: {}\", TRY_TO_PATCH_SHADED_ID);\n    }\n\n    /**\n     * Loads the first available library in the collection with the specified\n     * {@link ClassLoader}.\n     *\n     * @throws IllegalArgumentException\n     *         if none of the given libraries load successfully.\n     */\n    public static void loadFirstAvailable(ClassLoader loader, String... names) {\n        List<Throwable> suppressed = new ArrayList<Throwable>();\n        for (String name : names) {\n            try {\n                load(name, loader);\n                return;\n            } catch (Throwable t) {\n                suppressed.add(t);\n            }\n        }\n\n        IllegalArgumentException iae =\n                new IllegalArgumentException(\"Failed to load any of the given libraries: \" + Arrays.toString(names));\n        ThrowableUtil.addSuppressedAndClear(iae, suppressed);\n        throw iae;\n    }\n\n    /**\n     * The shading prefix added to this class's full name.\n     *\n     * @throws UnsatisfiedLinkError if the shader used something other than a prefix\n     */\n    private static String calculatePackagePrefix() {\n        String maybeShaded = NativeLibraryLoader.class.getName();\n        // Use ! instead of . to avoid shading utilities from modifying the string\n        String expected = \"io!netty!util!internal!NativeLibraryLoader\".replace('!', '.');\n        if (!maybeShaded.endsWith(expected)) {\n            throw new UnsatisfiedLinkError(String.format(\n                    \"Could not find prefix added to %s to get %s. When shading, only adding a \"\n                    + \"package prefix is supported\", expected, maybeShaded));\n        }\n        return maybeShaded.substring(0, maybeShaded.length() - expected.length());\n    }\n\n    /**\n     * Load the given library with the specified {@link ClassLoader}\n     */\n    public static void load(String originalName, ClassLoader loader) {\n        // Adjust expected name to support shading of native libraries.\n        String packagePrefix = calculatePackagePrefix().replace('.', '_');\n        String name = packagePrefix + originalName;\n        List<Throwable> suppressed = new ArrayList<Throwable>();\n        try {\n            // first try to load from java.library.path\n            loadLibrary(loader, name, false);\n            return;\n        } catch (Throwable ex) {\n            suppressed.add(ex);\n        }\n\n        String libname = System.mapLibraryName(name);\n        String path = NATIVE_RESOURCE_HOME + libname;\n\n        InputStream in = null;\n        OutputStream out = null;\n        File tmpFile = null;\n        URL url;\n        if (loader == null) {\n            url = ClassLoader.getSystemResource(path);\n        } else {\n            url = loader.getResource(path);\n        }\n        try {\n            if (url == null) {\n                if (PlatformDependent.isOsx()) {\n                    String fileName = path.endsWith(\".jnilib\") ? NATIVE_RESOURCE_HOME + \"lib\" + name + \".dynlib\" :\n                            NATIVE_RESOURCE_HOME + \"lib\" + name + \".jnilib\";\n                    if (loader == null) {\n                        url = ClassLoader.getSystemResource(fileName);\n                    } else {\n                        url = loader.getResource(fileName);\n                    }\n                    if (url == null) {\n                        FileNotFoundException fnf = new FileNotFoundException(fileName);\n                        ThrowableUtil.addSuppressedAndClear(fnf, suppressed);\n                        throw fnf;\n                    }\n                } else {\n                    FileNotFoundException fnf = new FileNotFoundException(path);\n                    ThrowableUtil.addSuppressedAndClear(fnf, suppressed);\n                    throw fnf;\n                }\n            }\n\n            int index = libname.lastIndexOf('.');\n            String prefix = libname.substring(0, index);\n            String suffix = libname.substring(index);\n\n            tmpFile = File.createTempFile(prefix, suffix, WORKDIR);\n            in = url.openStream();\n            out = new FileOutputStream(tmpFile);\n\n            if (shouldShadedLibraryIdBePatched(packagePrefix)) {\n                patchShadedLibraryId(in, out, originalName, name);\n            } else {\n                byte[] buffer = new byte[8192];\n                int length;\n                while ((length = in.read(buffer)) > 0) {\n                    out.write(buffer, 0, length);\n                }\n            }\n\n            out.flush();\n\n            // Close the output stream before loading the unpacked library,\n            // because otherwise Windows will refuse to load it when it's in use by other process.\n            closeQuietly(out);\n            out = null;\n            loadLibrary(loader, tmpFile.getPath(), true);\n        } catch (UnsatisfiedLinkError e) {\n            try {\n                if (tmpFile != null && tmpFile.isFile() && tmpFile.canRead() &&\n                    !NoexecVolumeDetector.canExecuteExecutable(tmpFile)) {\n                    // Pass \"io.netty.native.workdir\" as an argument to allow shading tools to see\n                    // the string. Since this is printed out to users to tell them what to do next,\n                    // we want the value to be correct even when shading.\n                    logger.info(\"{} exists but cannot be executed even when execute permissions set; \" +\n                                \"check volume for \\\"noexec\\\" flag; use -D{}=[path] \" +\n                                \"to set native working directory separately.\",\n                                tmpFile.getPath(), \"io.netty.native.workdir\");\n                }\n            } catch (Throwable t) {\n                suppressed.add(t);\n                logger.debug(\"Error checking if {} is on a file store mounted with noexec\", tmpFile, t);\n            }\n            // Re-throw to fail the load\n            ThrowableUtil.addSuppressedAndClear(e, suppressed);\n            throw e;\n        } catch (Exception e) {\n            UnsatisfiedLinkError ule = new UnsatisfiedLinkError(\"could not load a native library: \" + name);\n            ule.initCause(e);\n            ThrowableUtil.addSuppressedAndClear(ule, suppressed);\n            throw ule;\n        } finally {\n            closeQuietly(in);\n            closeQuietly(out);\n            // After we load the library it is safe to delete the file.\n            // We delete the file immediately to free up resources as soon as possible,\n            // and if this fails fallback to deleting on JVM exit.\n            if (tmpFile != null && (!DELETE_NATIVE_LIB_AFTER_LOADING || !tmpFile.delete())) {\n                tmpFile.deleteOnExit();\n            }\n        }\n    }\n\n    // Package-private for testing.\n    static boolean patchShadedLibraryId(InputStream in, OutputStream out, String originalName, String name)\n            throws IOException {\n        byte[] buffer = new byte[8192];\n        int length;\n        // We read the whole native lib into memory to make it easier to monkey-patch the id.\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(in.available());\n\n        while ((length = in.read(buffer)) > 0) {\n            byteArrayOutputStream.write(buffer, 0, length);\n        }\n        byteArrayOutputStream.flush();\n        byte[] bytes = byteArrayOutputStream.toByteArray();\n        byteArrayOutputStream.close();\n\n        final boolean patched;\n        // Try to patch the library id.\n        if (!patchShadedLibraryId(bytes, originalName, name)) {\n            // We did not find the Id, check if we used a originalName that has the os and arch as suffix.\n            // If this is the case we should also try to patch with the os and arch suffix removed.\n            String os = PlatformDependent.normalizedOs();\n            String arch = PlatformDependent.normalizedArch();\n            String osArch = \"_\" + os + \"_\" + arch;\n            if (originalName.endsWith(osArch)) {\n                patched = patchShadedLibraryId(bytes,\n                        originalName.substring(0, originalName.length() - osArch.length()), name);\n            } else {\n                patched = false;\n            }\n        } else {\n            patched = true;\n        }\n        out.write(bytes, 0, bytes.length);\n        return patched;\n    }\n\n    private static boolean shouldShadedLibraryIdBePatched(String packagePrefix) {\n        return TRY_TO_PATCH_SHADED_ID && PlatformDependent.isOsx() && !packagePrefix.isEmpty();\n    }\n\n    /**\n     * Try to patch shaded library to ensure it uses a unique ID.\n     */\n    private static boolean patchShadedLibraryId(byte[] bytes, String originalName, String name) {\n        // Our native libs always have the name as part of their id so we can search for it and replace it\n        // to make the ID unique if shading is used.\n        byte[] nameBytes = originalName.getBytes(CharsetUtil.UTF_8);\n        int idIdx = -1;\n\n        // Be aware this is a really raw way of patching a dylib but it does all we need without implementing\n        // a full mach-o parser and writer. Basically we just replace the the original bytes with some\n        // random bytes as part of the ID regeneration. The important thing here is that we need to use the same\n        // length to not corrupt the mach-o header.\n        outerLoop: for (int i = 0; i < bytes.length && bytes.length - i >= nameBytes.length; i++) {\n            int idx = i;\n            for (int j = 0; j < nameBytes.length;) {\n                if (bytes[idx++] != nameBytes[j++]) {\n                    // Did not match the name, increase the index and try again.\n                    break;\n                } else if (j == nameBytes.length) {\n                    // We found the index within the id.\n                    idIdx = i;\n                    break outerLoop;\n                }\n            }\n        }\n\n        if (idIdx == -1) {\n            logger.debug(\"Was not able to find the ID of the shaded native library {}, can't adjust it.\", name);\n            return false;\n        } else {\n            // We found our ID... now monkey-patch it!\n            for (int i = 0; i < nameBytes.length; i++) {\n                // We should only use bytes as replacement that are in our UNIQUE_ID_BYTES array.\n                bytes[idIdx + i] = UNIQUE_ID_BYTES[PlatformDependent.threadLocalRandom()\n                                                                    .nextInt(UNIQUE_ID_BYTES.length)];\n            }\n\n            if (logger.isDebugEnabled()) {\n                logger.debug(\n                        \"Found the ID of the shaded native library {}. Replacing ID part {} with {}\",\n                        name, originalName, new String(bytes, idIdx, nameBytes.length, CharsetUtil.UTF_8));\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Loading the native library into the specified {@link ClassLoader}.\n     * @param loader - The {@link ClassLoader} where the native library will be loaded into\n     * @param name - The native library path or name\n     * @param absolute - Whether the native library will be loaded by path or by name\n     */\n    private static void loadLibrary(final ClassLoader loader, final String name, final boolean absolute) {\n        Throwable suppressed = null;\n        try {\n            try {\n                // Make sure the helper is belong to the target ClassLoader.\n                final Class<?> newHelper = tryToLoadClass(loader, NativeLibraryUtil.class);\n                loadLibraryByHelper(newHelper, name, absolute);\n                logger.debug(\"Successfully loaded the library {}\", name);\n                return;\n            } catch (UnsatisfiedLinkError e) { // Should by pass the UnsatisfiedLinkError here!\n                suppressed = e;\n            } catch (Exception e) {\n                suppressed = e;\n            }\n            NativeLibraryUtil.loadLibrary(name, absolute);  // Fallback to local helper class.\n            logger.debug(\"Successfully loaded the library {}\", name);\n        } catch (NoSuchMethodError nsme) {\n            if (suppressed != null) {\n                ThrowableUtil.addSuppressed(nsme, suppressed);\n            }\n            rethrowWithMoreDetailsIfPossible(name, nsme);\n        } catch (UnsatisfiedLinkError ule) {\n            if (suppressed != null) {\n                ThrowableUtil.addSuppressed(ule, suppressed);\n            }\n            throw ule;\n        }\n    }\n\n    @SuppressJava6Requirement(reason = \"Guarded by version check\")\n    private static void rethrowWithMoreDetailsIfPossible(String name, NoSuchMethodError error) {\n        if (PlatformDependent.javaVersion() >= 7) {\n            throw new LinkageError(\n                    \"Possible multiple incompatible native libraries on the classpath for '\" + name + \"'?\", error);\n        }\n        throw error;\n    }\n\n    private static void loadLibraryByHelper(final Class<?> helper, final String name, final boolean absolute)\n            throws UnsatisfiedLinkError {\n        Object ret = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n            @Override\n            public Object run() {\n                try {\n                    // Invoke the helper to load the native library, if succeed, then the native\n                    // library belong to the specified ClassLoader.\n                    Method method = helper.getMethod(\"loadLibrary\", String.class, boolean.class);\n                    method.setAccessible(true);\n                    return method.invoke(null, name, absolute);\n                } catch (Exception e) {\n                    return e;\n                }\n            }\n        });\n        if (ret instanceof Throwable) {\n            Throwable t = (Throwable) ret;\n            assert !(t instanceof UnsatisfiedLinkError) : t + \" should be a wrapper throwable\";\n            Throwable cause = t.getCause();\n            if (cause instanceof UnsatisfiedLinkError) {\n                throw (UnsatisfiedLinkError) cause;\n            }\n            UnsatisfiedLinkError ule = new UnsatisfiedLinkError(t.getMessage());\n            ule.initCause(t);\n            throw ule;\n        }\n    }\n\n    /**\n     * Try to load the helper {@link Class} into specified {@link ClassLoader}.\n     * @param loader - The {@link ClassLoader} where to load the helper {@link Class}\n     * @param helper - The helper {@link Class}\n     * @return A new helper Class defined in the specified ClassLoader.\n     * @throws ClassNotFoundException Helper class not found or loading failed\n     */\n    private static Class<?> tryToLoadClass(final ClassLoader loader, final Class<?> helper)\n            throws ClassNotFoundException {\n        try {\n            return Class.forName(helper.getName(), false, loader);\n        } catch (ClassNotFoundException e1) {\n            if (loader == null) {\n                // cannot defineClass inside bootstrap class loader\n                throw e1;\n            }\n            try {\n                // The helper class is NOT found in target ClassLoader, we have to define the helper class.\n                final byte[] classBinary = classToByteArray(helper);\n                return AccessController.doPrivileged(new PrivilegedAction<Class<?>>() {\n                    @Override\n                    public Class<?> run() {\n                        try {\n                            // Define the helper class in the target ClassLoader,\n                            //  then we can call the helper to load the native library.\n                            Method defineClass = ClassLoader.class.getDeclaredMethod(\"defineClass\", String.class,\n                                    byte[].class, int.class, int.class);\n                            defineClass.setAccessible(true);\n                            return (Class<?>) defineClass.invoke(loader, helper.getName(), classBinary, 0,\n                                    classBinary.length);\n                        } catch (Exception e) {\n                            throw new IllegalStateException(\"Define class failed!\", e);\n                        }\n                    }\n                });\n            } catch (ClassNotFoundException e2) {\n                ThrowableUtil.addSuppressed(e2, e1);\n                throw e2;\n            } catch (RuntimeException e2) {\n                ThrowableUtil.addSuppressed(e2, e1);\n                throw e2;\n            } catch (Error e2) {\n                ThrowableUtil.addSuppressed(e2, e1);\n                throw e2;\n            }\n        }\n    }\n\n    /**\n     * Load the helper {@link Class} as a byte array, to be redefined in specified {@link ClassLoader}.\n     * @param clazz - The helper {@link Class} provided by this bundle\n     * @return The binary content of helper {@link Class}.\n     * @throws ClassNotFoundException Helper class not found or loading failed\n     */\n    private static byte[] classToByteArray(Class<?> clazz) throws ClassNotFoundException {\n        String fileName = clazz.getName();\n        int lastDot = fileName.lastIndexOf('.');\n        if (lastDot > 0) {\n            fileName = fileName.substring(lastDot + 1);\n        }\n        URL classUrl = clazz.getResource(fileName + \".class\");\n        if (classUrl == null) {\n            throw new ClassNotFoundException(clazz.getName());\n        }\n        byte[] buf = new byte[1024];\n        ByteArrayOutputStream out = new ByteArrayOutputStream(4096);\n        InputStream in = null;\n        try {\n            in = classUrl.openStream();\n            for (int r; (r = in.read(buf)) != -1;) {\n                out.write(buf, 0, r);\n            }\n            return out.toByteArray();\n        } catch (IOException ex) {\n            throw new ClassNotFoundException(clazz.getName(), ex);\n        } finally {\n            closeQuietly(in);\n            closeQuietly(out);\n        }\n    }\n\n    private static void closeQuietly(Closeable c) {\n        if (c != null) {\n            try {\n                c.close();\n            } catch (IOException ignore) {\n                // ignore\n            }\n        }\n    }\n\n    private NativeLibraryLoader() {\n        // Utility\n    }\n\n    private static final class NoexecVolumeDetector {\n\n        @SuppressJava6Requirement(reason = \"Usage guarded by java version check\")\n        private static boolean canExecuteExecutable(File file) throws IOException {\n            if (PlatformDependent.javaVersion() < 7) {\n                // Pre-JDK7, the Java API did not directly support POSIX permissions; instead of implementing a custom\n                // work-around, assume true, which disables the check.\n                return true;\n            }\n\n            // If we can already execute, there is nothing to do.\n            if (file.canExecute()) {\n                return true;\n            }\n\n            // On volumes, with noexec set, even files with the executable POSIX permissions will fail to execute.\n            // The File#canExecute() method honors this behavior, probaby via parsing the noexec flag when initializing\n            // the UnixFileStore, though the flag is not exposed via a public API.  To find out if library is being\n            // loaded off a volume with noexec, confirm or add executalbe permissions, then check File#canExecute().\n\n            // Note: We use FQCN to not break when netty is used in java6\n            Set<java.nio.file.attribute.PosixFilePermission> existingFilePermissions =\n                    java.nio.file.Files.getPosixFilePermissions(file.toPath());\n            Set<java.nio.file.attribute.PosixFilePermission> executePermissions =\n                    EnumSet.of(java.nio.file.attribute.PosixFilePermission.OWNER_EXECUTE,\n                            java.nio.file.attribute.PosixFilePermission.GROUP_EXECUTE,\n                            java.nio.file.attribute.PosixFilePermission.OTHERS_EXECUTE);\n            if (existingFilePermissions.containsAll(executePermissions)) {\n                return false;\n            }\n\n            Set<java.nio.file.attribute.PosixFilePermission> newPermissions = EnumSet.copyOf(existingFilePermissions);\n            newPermissions.addAll(executePermissions);\n            java.nio.file.Files.setPosixFilePermissions(file.toPath(), newPermissions);\n            return file.canExecute();\n        }\n\n        private NoexecVolumeDetector() {\n            // Utility\n        }\n    }\n}\n", "/*\n * Copyright 2012 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.util.internal;\n\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.internal.logging.InternalLogger;\nimport io.netty.util.internal.logging.InternalLoggerFactory;\nimport org.jctools.queues.MpscArrayQueue;\nimport org.jctools.queues.MpscChunkedArrayQueue;\nimport org.jctools.queues.MpscUnboundedArrayQueue;\nimport org.jctools.queues.SpscLinkedQueue;\nimport org.jctools.queues.atomic.MpscAtomicArrayQueue;\nimport org.jctools.queues.atomic.MpscChunkedAtomicArrayQueue;\nimport org.jctools.queues.atomic.MpscUnboundedAtomicArrayQueue;\nimport org.jctools.queues.atomic.SpscLinkedAtomicQueue;\nimport org.jctools.util.Pow2;\nimport org.jctools.util.UnsafeAccess;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Deque;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedDeque;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport static io.netty.util.internal.PlatformDependent0.HASH_CODE_ASCII_SEED;\nimport static io.netty.util.internal.PlatformDependent0.HASH_CODE_C1;\nimport static io.netty.util.internal.PlatformDependent0.HASH_CODE_C2;\nimport static io.netty.util.internal.PlatformDependent0.hashCodeAsciiSanitize;\nimport static io.netty.util.internal.PlatformDependent0.unalignedAccess;\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\n\n/**\n * Utility that detects various properties specific to the current runtime\n * environment, such as Java version and the availability of the\n * {@code sun.misc.Unsafe} object.\n * <p>\n * You can disable the use of {@code sun.misc.Unsafe} if you specify\n * the system property <strong>io.netty.noUnsafe</strong>.\n */\npublic final class PlatformDependent {\n\n    private static final InternalLogger logger = InternalLoggerFactory.getInstance(PlatformDependent.class);\n\n    private static final Pattern MAX_DIRECT_MEMORY_SIZE_ARG_PATTERN = Pattern.compile(\n            \"\\\\s*-XX:MaxDirectMemorySize\\\\s*=\\\\s*([0-9]+)\\\\s*([kKmMgG]?)\\\\s*$\");\n\n    private static final boolean IS_WINDOWS = isWindows0();\n    private static final boolean IS_OSX = isOsx0();\n    private static final boolean IS_J9_JVM = isJ9Jvm0();\n    private static final boolean IS_IVKVM_DOT_NET = isIkvmDotNet0();\n\n    private static final boolean MAYBE_SUPER_USER;\n\n    private static final boolean CAN_ENABLE_TCP_NODELAY_BY_DEFAULT = !isAndroid();\n\n    private static final Throwable UNSAFE_UNAVAILABILITY_CAUSE = unsafeUnavailabilityCause0();\n    private static final boolean DIRECT_BUFFER_PREFERRED;\n    private static final long MAX_DIRECT_MEMORY = maxDirectMemory0();\n\n    private static final int MPSC_CHUNK_SIZE =  1024;\n    private static final int MIN_MAX_MPSC_CAPACITY =  MPSC_CHUNK_SIZE * 2;\n    private static final int MAX_ALLOWED_MPSC_CAPACITY = Pow2.MAX_POW2;\n\n    private static final long BYTE_ARRAY_BASE_OFFSET = byteArrayBaseOffset0();\n\n    private static final File TMPDIR = tmpdir0();\n\n    private static final int BIT_MODE = bitMode0();\n    private static final String NORMALIZED_ARCH = normalizeArch(SystemPropertyUtil.get(\"os.arch\", \"\"));\n    private static final String NORMALIZED_OS = normalizeOs(SystemPropertyUtil.get(\"os.name\", \"\"));\n\n    // keep in sync with maven's pom.xml via os.detection.classifierWithLikes!\n    private static final String[] ALLOWED_LINUX_OS_CLASSIFIERS = {\"fedora\", \"suse\", \"arch\"};\n    private static final Set<String> LINUX_OS_CLASSIFIERS;\n\n    private static final int ADDRESS_SIZE = addressSize0();\n    private static final boolean USE_DIRECT_BUFFER_NO_CLEANER;\n    private static final AtomicLong DIRECT_MEMORY_COUNTER;\n    private static final long DIRECT_MEMORY_LIMIT;\n    private static final ThreadLocalRandomProvider RANDOM_PROVIDER;\n    private static final Cleaner CLEANER;\n    private static final int UNINITIALIZED_ARRAY_ALLOCATION_THRESHOLD;\n    // For specifications, see https://www.freedesktop.org/software/systemd/man/os-release.html\n    private static final String[] OS_RELEASE_FILES = {\"/etc/os-release\", \"/usr/lib/os-release\"};\n    private static final String LINUX_ID_PREFIX = \"ID=\";\n    private static final String LINUX_ID_LIKE_PREFIX = \"ID_LIKE=\";\n    public static final boolean BIG_ENDIAN_NATIVE_ORDER = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN;\n\n    private static final Cleaner NOOP = new Cleaner() {\n        @Override\n        public void freeDirectBuffer(ByteBuffer buffer) {\n            // NOOP\n        }\n    };\n\n    static {\n        if (javaVersion() >= 7) {\n            RANDOM_PROVIDER = new ThreadLocalRandomProvider() {\n                @Override\n                @SuppressJava6Requirement(reason = \"Usage guarded by java version check\")\n                public Random current() {\n                    return java.util.concurrent.ThreadLocalRandom.current();\n                }\n            };\n        } else {\n            RANDOM_PROVIDER = new ThreadLocalRandomProvider() {\n                @Override\n                public Random current() {\n                    return ThreadLocalRandom.current();\n                }\n            };\n        }\n\n        // Here is how the system property is used:\n        //\n        // * <  0  - Don't use cleaner, and inherit max direct memory from java. In this case the\n        //           \"practical max direct memory\" would be 2 * max memory as defined by the JDK.\n        // * == 0  - Use cleaner, Netty will not enforce max memory, and instead will defer to JDK.\n        // * >  0  - Don't use cleaner. This will limit Netty's total direct memory\n        //           (note: that JDK's direct memory limit is independent of this).\n        long maxDirectMemory = SystemPropertyUtil.getLong(\"io.netty.maxDirectMemory\", -1);\n\n        if (maxDirectMemory == 0 || !hasUnsafe() || !PlatformDependent0.hasDirectBufferNoCleanerConstructor()) {\n            USE_DIRECT_BUFFER_NO_CLEANER = false;\n            DIRECT_MEMORY_COUNTER = null;\n        } else {\n            USE_DIRECT_BUFFER_NO_CLEANER = true;\n            if (maxDirectMemory < 0) {\n                maxDirectMemory = MAX_DIRECT_MEMORY;\n                if (maxDirectMemory <= 0) {\n                    DIRECT_MEMORY_COUNTER = null;\n                } else {\n                    DIRECT_MEMORY_COUNTER = new AtomicLong();\n                }\n            } else {\n                DIRECT_MEMORY_COUNTER = new AtomicLong();\n            }\n        }\n        logger.debug(\"-Dio.netty.maxDirectMemory: {} bytes\", maxDirectMemory);\n        DIRECT_MEMORY_LIMIT = maxDirectMemory >= 1 ? maxDirectMemory : MAX_DIRECT_MEMORY;\n\n        int tryAllocateUninitializedArray =\n                SystemPropertyUtil.getInt(\"io.netty.uninitializedArrayAllocationThreshold\", 1024);\n        UNINITIALIZED_ARRAY_ALLOCATION_THRESHOLD = javaVersion() >= 9 && PlatformDependent0.hasAllocateArrayMethod() ?\n                tryAllocateUninitializedArray : -1;\n        logger.debug(\"-Dio.netty.uninitializedArrayAllocationThreshold: {}\", UNINITIALIZED_ARRAY_ALLOCATION_THRESHOLD);\n\n        MAYBE_SUPER_USER = maybeSuperUser0();\n\n        if (!isAndroid()) {\n            // only direct to method if we are not running on android.\n            // See https://github.com/netty/netty/issues/2604\n            if (javaVersion() >= 9) {\n                CLEANER = CleanerJava9.isSupported() ? new CleanerJava9() : NOOP;\n            } else {\n                CLEANER = CleanerJava6.isSupported() ? new CleanerJava6() : NOOP;\n            }\n        } else {\n            CLEANER = NOOP;\n        }\n\n        // We should always prefer direct buffers by default if we can use a Cleaner to release direct buffers.\n        DIRECT_BUFFER_PREFERRED = CLEANER != NOOP\n                                  && !SystemPropertyUtil.getBoolean(\"io.netty.noPreferDirect\", false);\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"-Dio.netty.noPreferDirect: {}\", !DIRECT_BUFFER_PREFERRED);\n        }\n\n        /*\n         * We do not want to log this message if unsafe is explicitly disabled. Do not remove the explicit no unsafe\n         * guard.\n         */\n        if (CLEANER == NOOP && !PlatformDependent0.isExplicitNoUnsafe()) {\n            logger.info(\n                    \"Your platform does not provide complete low-level API for accessing direct buffers reliably. \" +\n                    \"Unless explicitly requested, heap buffer will always be preferred to avoid potential system \" +\n                    \"instability.\");\n        }\n\n        final Set<String> allowedClassifiers = Collections.unmodifiableSet(\n                new HashSet<String>(Arrays.asList(ALLOWED_LINUX_OS_CLASSIFIERS)));\n        final Set<String> availableClassifiers = new LinkedHashSet<String>();\n        for (final String osReleaseFileName : OS_RELEASE_FILES) {\n            final File file = new File(osReleaseFileName);\n            boolean found = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {\n                @Override\n                public Boolean run() {\n                    try {\n                        if (file.exists()) {\n                            BufferedReader reader = null;\n                            try {\n                                reader = new BufferedReader(\n                                        new InputStreamReader(\n                                                new FileInputStream(file), CharsetUtil.UTF_8));\n\n                                String line;\n                                while ((line = reader.readLine()) != null) {\n                                    if (line.startsWith(LINUX_ID_PREFIX)) {\n                                        String id = normalizeOsReleaseVariableValue(\n                                                line.substring(LINUX_ID_PREFIX.length()));\n                                        addClassifier(allowedClassifiers, availableClassifiers, id);\n                                    } else if (line.startsWith(LINUX_ID_LIKE_PREFIX)) {\n                                        line = normalizeOsReleaseVariableValue(\n                                                line.substring(LINUX_ID_LIKE_PREFIX.length()));\n                                        addClassifier(allowedClassifiers, availableClassifiers, line.split(\"[ ]+\"));\n                                    }\n                                }\n                            } catch (SecurityException e) {\n                                logger.debug(\"Unable to read {}\", osReleaseFileName, e);\n                            } catch (IOException e) {\n                                logger.debug(\"Error while reading content of {}\", osReleaseFileName, e);\n                            } finally {\n                                if (reader != null) {\n                                    try {\n                                        reader.close();\n                                    } catch (IOException ignored) {\n                                        // Ignore\n                                    }\n                                }\n                            }\n                            // specification states we should only fall back if /etc/os-release does not exist\n                            return true;\n                        }\n                    } catch (SecurityException e) {\n                        logger.debug(\"Unable to check if {} exists\", osReleaseFileName, e);\n                    }\n                    return false;\n                }\n            });\n\n            if (found) {\n                break;\n            }\n        }\n        LINUX_OS_CLASSIFIERS = Collections.unmodifiableSet(availableClassifiers);\n    }\n\n    public static long byteArrayBaseOffset() {\n        return BYTE_ARRAY_BASE_OFFSET;\n    }\n\n    public static boolean hasDirectBufferNoCleanerConstructor() {\n        return PlatformDependent0.hasDirectBufferNoCleanerConstructor();\n    }\n\n    public static byte[] allocateUninitializedArray(int size) {\n        return UNINITIALIZED_ARRAY_ALLOCATION_THRESHOLD < 0 || UNINITIALIZED_ARRAY_ALLOCATION_THRESHOLD > size ?\n                new byte[size] : PlatformDependent0.allocateUninitializedArray(size);\n    }\n\n    /**\n     * Returns {@code true} if and only if the current platform is Android\n     */\n    public static boolean isAndroid() {\n        return PlatformDependent0.isAndroid();\n    }\n\n    /**\n     * Return {@code true} if the JVM is running on Windows\n     */\n    public static boolean isWindows() {\n        return IS_WINDOWS;\n    }\n\n    /**\n     * Return {@code true} if the JVM is running on OSX / MacOS\n     */\n    public static boolean isOsx() {\n        return IS_OSX;\n    }\n\n    /**\n     * Return {@code true} if the current user may be a super-user. Be aware that this is just an hint and so it may\n     * return false-positives.\n     */\n    public static boolean maybeSuperUser() {\n        return MAYBE_SUPER_USER;\n    }\n\n    /**\n     * Return the version of Java under which this library is used.\n     */\n    public static int javaVersion() {\n        return PlatformDependent0.javaVersion();\n    }\n\n    /**\n     * Returns {@code true} if and only if it is fine to enable TCP_NODELAY socket option by default.\n     */\n    public static boolean canEnableTcpNoDelayByDefault() {\n        return CAN_ENABLE_TCP_NODELAY_BY_DEFAULT;\n    }\n\n    /**\n     * Return {@code true} if {@code sun.misc.Unsafe} was found on the classpath and can be used for accelerated\n     * direct memory access.\n     */\n    public static boolean hasUnsafe() {\n        return UNSAFE_UNAVAILABILITY_CAUSE == null;\n    }\n\n    /**\n     * Return the reason (if any) why {@code sun.misc.Unsafe} was not available.\n     */\n    public static Throwable getUnsafeUnavailabilityCause() {\n        return UNSAFE_UNAVAILABILITY_CAUSE;\n    }\n\n    /**\n     * {@code true} if and only if the platform supports unaligned access.\n     *\n     * @see <a href=\"https://en.wikipedia.org/wiki/Segmentation_fault#Bus_error\">Wikipedia on segfault</a>\n     */\n    public static boolean isUnaligned() {\n        return PlatformDependent0.isUnaligned();\n    }\n\n    /**\n     * Returns {@code true} if the platform has reliable low-level direct buffer access API and a user has not specified\n     * {@code -Dio.netty.noPreferDirect} option.\n     */\n    public static boolean directBufferPreferred() {\n        return DIRECT_BUFFER_PREFERRED;\n    }\n\n    /**\n     * Returns the maximum memory reserved for direct buffer allocation.\n     */\n    public static long maxDirectMemory() {\n        return DIRECT_MEMORY_LIMIT;\n    }\n\n    /**\n     * Returns the current memory reserved for direct buffer allocation.\n     * This method returns -1 in case that a value is not available.\n     *\n     * @see #maxDirectMemory()\n     */\n    public static long usedDirectMemory() {\n        return DIRECT_MEMORY_COUNTER != null ? DIRECT_MEMORY_COUNTER.get() : -1;\n    }\n\n    /**\n     * Returns the temporary directory.\n     */\n    public static File tmpdir() {\n        return TMPDIR;\n    }\n\n    /**\n     * Returns the bit mode of the current VM (usually 32 or 64.)\n     */\n    public static int bitMode() {\n        return BIT_MODE;\n    }\n\n    /**\n     * Return the address size of the OS.\n     * 4 (for 32 bits systems ) and 8 (for 64 bits systems).\n     */\n    public static int addressSize() {\n        return ADDRESS_SIZE;\n    }\n\n    public static long allocateMemory(long size) {\n        return PlatformDependent0.allocateMemory(size);\n    }\n\n    public static void freeMemory(long address) {\n        PlatformDependent0.freeMemory(address);\n    }\n\n    public static long reallocateMemory(long address, long newSize) {\n        return PlatformDependent0.reallocateMemory(address, newSize);\n    }\n\n    /**\n     * Raises an exception bypassing compiler checks for checked exceptions.\n     */\n    public static void throwException(Throwable t) {\n        if (hasUnsafe()) {\n            PlatformDependent0.throwException(t);\n        } else {\n            PlatformDependent.<RuntimeException>throwException0(t);\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static <E extends Throwable> void throwException0(Throwable t) throws E {\n        throw (E) t;\n    }\n\n    /**\n     * Creates a new fastest {@link ConcurrentMap} implementation for the current platform.\n     */\n    public static <K, V> ConcurrentMap<K, V> newConcurrentHashMap() {\n        return new ConcurrentHashMap<K, V>();\n    }\n\n    /**\n     * Creates a new fastest {@link LongCounter} implementation for the current platform.\n     */\n    public static LongCounter newLongCounter() {\n        if (javaVersion() >= 8) {\n            return new LongAdderCounter();\n        } else {\n            return new AtomicLongCounter();\n        }\n    }\n\n    /**\n     * Creates a new fastest {@link ConcurrentMap} implementation for the current platform.\n     */\n    public static <K, V> ConcurrentMap<K, V> newConcurrentHashMap(int initialCapacity) {\n        return new ConcurrentHashMap<K, V>(initialCapacity);\n    }\n\n    /**\n     * Creates a new fastest {@link ConcurrentMap} implementation for the current platform.\n     */\n    public static <K, V> ConcurrentMap<K, V> newConcurrentHashMap(int initialCapacity, float loadFactor) {\n        return new ConcurrentHashMap<K, V>(initialCapacity, loadFactor);\n    }\n\n    /**\n     * Creates a new fastest {@link ConcurrentMap} implementation for the current platform.\n     */\n    public static <K, V> ConcurrentMap<K, V> newConcurrentHashMap(\n            int initialCapacity, float loadFactor, int concurrencyLevel) {\n        return new ConcurrentHashMap<K, V>(initialCapacity, loadFactor, concurrencyLevel);\n    }\n\n    /**\n     * Creates a new fastest {@link ConcurrentMap} implementation for the current platform.\n     */\n    public static <K, V> ConcurrentMap<K, V> newConcurrentHashMap(Map<? extends K, ? extends V> map) {\n        return new ConcurrentHashMap<K, V>(map);\n    }\n\n    /**\n     * Try to deallocate the specified direct {@link ByteBuffer}. Please note this method does nothing if\n     * the current platform does not support this operation or the specified buffer is not a direct buffer.\n     */\n    public static void freeDirectBuffer(ByteBuffer buffer) {\n        CLEANER.freeDirectBuffer(buffer);\n    }\n\n    public static long directBufferAddress(ByteBuffer buffer) {\n        return PlatformDependent0.directBufferAddress(buffer);\n    }\n\n    public static ByteBuffer directBuffer(long memoryAddress, int size) {\n        if (PlatformDependent0.hasDirectBufferNoCleanerConstructor()) {\n            return PlatformDependent0.newDirectBuffer(memoryAddress, size);\n        }\n        throw new UnsupportedOperationException(\n                \"sun.misc.Unsafe or java.nio.DirectByteBuffer.<init>(long, int) not available\");\n    }\n\n    public static Object getObject(Object object, long fieldOffset) {\n        return PlatformDependent0.getObject(object, fieldOffset);\n    }\n\n    public static int getInt(Object object, long fieldOffset) {\n        return PlatformDependent0.getInt(object, fieldOffset);\n    }\n\n    public static int getIntVolatile(long address) {\n        return PlatformDependent0.getIntVolatile(address);\n    }\n\n    public static void putIntOrdered(long adddress, int newValue) {\n        PlatformDependent0.putIntOrdered(adddress, newValue);\n    }\n\n    public static byte getByte(long address) {\n        return PlatformDependent0.getByte(address);\n    }\n\n    public static short getShort(long address) {\n        return PlatformDependent0.getShort(address);\n    }\n\n    public static int getInt(long address) {\n        return PlatformDependent0.getInt(address);\n    }\n\n    public static long getLong(long address) {\n        return PlatformDependent0.getLong(address);\n    }\n\n    public static byte getByte(byte[] data, int index) {\n        return PlatformDependent0.getByte(data, index);\n    }\n\n    public static byte getByte(byte[] data, long index) {\n        return PlatformDependent0.getByte(data, index);\n    }\n\n    public static short getShort(byte[] data, int index) {\n        return PlatformDependent0.getShort(data, index);\n    }\n\n    public static int getInt(byte[] data, int index) {\n        return PlatformDependent0.getInt(data, index);\n    }\n\n    public static int getInt(int[] data, long index) {\n        return PlatformDependent0.getInt(data, index);\n    }\n\n    public static long getLong(byte[] data, int index) {\n        return PlatformDependent0.getLong(data, index);\n    }\n\n    public static long getLong(long[] data, long index) {\n        return PlatformDependent0.getLong(data, index);\n    }\n\n    private static long getLongSafe(byte[] bytes, int offset) {\n        if (BIG_ENDIAN_NATIVE_ORDER) {\n            return (long) bytes[offset] << 56 |\n                    ((long) bytes[offset + 1] & 0xff) << 48 |\n                    ((long) bytes[offset + 2] & 0xff) << 40 |\n                    ((long) bytes[offset + 3] & 0xff) << 32 |\n                    ((long) bytes[offset + 4] & 0xff) << 24 |\n                    ((long) bytes[offset + 5] & 0xff) << 16 |\n                    ((long) bytes[offset + 6] & 0xff) <<  8 |\n                    (long) bytes[offset + 7] & 0xff;\n        }\n        return (long) bytes[offset] & 0xff |\n                ((long) bytes[offset + 1] & 0xff) << 8 |\n                ((long) bytes[offset + 2] & 0xff) << 16 |\n                ((long) bytes[offset + 3] & 0xff) << 24 |\n                ((long) bytes[offset + 4] & 0xff) << 32 |\n                ((long) bytes[offset + 5] & 0xff) << 40 |\n                ((long) bytes[offset + 6] & 0xff) << 48 |\n                (long) bytes[offset + 7] << 56;\n    }\n\n    private static int getIntSafe(byte[] bytes, int offset) {\n        if (BIG_ENDIAN_NATIVE_ORDER) {\n            return bytes[offset] << 24 |\n                    (bytes[offset + 1] & 0xff) << 16 |\n                    (bytes[offset + 2] & 0xff) << 8 |\n                    bytes[offset + 3] & 0xff;\n        }\n        return bytes[offset] & 0xff |\n                (bytes[offset + 1] & 0xff) << 8 |\n                (bytes[offset + 2] & 0xff) << 16 |\n                bytes[offset + 3] << 24;\n    }\n\n    private static short getShortSafe(byte[] bytes, int offset) {\n        if (BIG_ENDIAN_NATIVE_ORDER) {\n            return (short) (bytes[offset] << 8 | (bytes[offset + 1] & 0xff));\n        }\n        return (short) (bytes[offset] & 0xff | (bytes[offset + 1] << 8));\n    }\n\n    /**\n     * Identical to {@link PlatformDependent0#hashCodeAsciiCompute(long, int)} but for {@link CharSequence}.\n     */\n    private static int hashCodeAsciiCompute(CharSequence value, int offset, int hash) {\n        if (BIG_ENDIAN_NATIVE_ORDER) {\n            return hash * HASH_CODE_C1 +\n                    // Low order int\n                    hashCodeAsciiSanitizeInt(value, offset + 4) * HASH_CODE_C2 +\n                    // High order int\n                    hashCodeAsciiSanitizeInt(value, offset);\n        }\n        return hash * HASH_CODE_C1 +\n                // Low order int\n                hashCodeAsciiSanitizeInt(value, offset) * HASH_CODE_C2 +\n                // High order int\n                hashCodeAsciiSanitizeInt(value, offset + 4);\n    }\n\n    /**\n     * Identical to {@link PlatformDependent0#hashCodeAsciiSanitize(int)} but for {@link CharSequence}.\n     */\n    private static int hashCodeAsciiSanitizeInt(CharSequence value, int offset) {\n        if (BIG_ENDIAN_NATIVE_ORDER) {\n            // mimic a unsafe.getInt call on a big endian machine\n            return (value.charAt(offset + 3) & 0x1f) |\n                   (value.charAt(offset + 2) & 0x1f) << 8 |\n                   (value.charAt(offset + 1) & 0x1f) << 16 |\n                   (value.charAt(offset) & 0x1f) << 24;\n        }\n        return (value.charAt(offset + 3) & 0x1f) << 24 |\n               (value.charAt(offset + 2) & 0x1f) << 16 |\n               (value.charAt(offset + 1) & 0x1f) << 8 |\n               (value.charAt(offset) & 0x1f);\n    }\n\n    /**\n     * Identical to {@link PlatformDependent0#hashCodeAsciiSanitize(short)} but for {@link CharSequence}.\n     */\n    private static int hashCodeAsciiSanitizeShort(CharSequence value, int offset) {\n        if (BIG_ENDIAN_NATIVE_ORDER) {\n            // mimic a unsafe.getShort call on a big endian machine\n            return (value.charAt(offset + 1) & 0x1f) |\n                    (value.charAt(offset) & 0x1f) << 8;\n        }\n        return (value.charAt(offset + 1) & 0x1f) << 8 |\n                (value.charAt(offset) & 0x1f);\n    }\n\n    /**\n     * Identical to {@link PlatformDependent0#hashCodeAsciiSanitize(byte)} but for {@link CharSequence}.\n     */\n    private static int hashCodeAsciiSanitizeByte(char value) {\n        return value & 0x1f;\n    }\n\n    public static void putByte(long address, byte value) {\n        PlatformDependent0.putByte(address, value);\n    }\n\n    public static void putShort(long address, short value) {\n        PlatformDependent0.putShort(address, value);\n    }\n\n    public static void putInt(long address, int value) {\n        PlatformDependent0.putInt(address, value);\n    }\n\n    public static void putLong(long address, long value) {\n        PlatformDependent0.putLong(address, value);\n    }\n\n    public static void putByte(byte[] data, int index, byte value) {\n        PlatformDependent0.putByte(data, index, value);\n    }\n\n    public static void putByte(Object data, long offset, byte value) {\n        PlatformDependent0.putByte(data, offset, value);\n    }\n\n    public static void putShort(byte[] data, int index, short value) {\n        PlatformDependent0.putShort(data, index, value);\n    }\n\n    public static void putInt(byte[] data, int index, int value) {\n        PlatformDependent0.putInt(data, index, value);\n    }\n\n    public static void putLong(byte[] data, int index, long value) {\n        PlatformDependent0.putLong(data, index, value);\n    }\n\n    public static void putObject(Object o, long offset, Object x) {\n        PlatformDependent0.putObject(o, offset, x);\n    }\n\n    public static long objectFieldOffset(Field field) {\n        return PlatformDependent0.objectFieldOffset(field);\n    }\n\n    public static void copyMemory(long srcAddr, long dstAddr, long length) {\n        PlatformDependent0.copyMemory(srcAddr, dstAddr, length);\n    }\n\n    public static void copyMemory(byte[] src, int srcIndex, long dstAddr, long length) {\n        PlatformDependent0.copyMemory(src, BYTE_ARRAY_BASE_OFFSET + srcIndex, null, dstAddr, length);\n    }\n\n    public static void copyMemory(byte[] src, int srcIndex, byte[] dst, int dstIndex, long length) {\n        PlatformDependent0.copyMemory(src, BYTE_ARRAY_BASE_OFFSET + srcIndex,\n                                      dst, BYTE_ARRAY_BASE_OFFSET + dstIndex, length);\n    }\n\n    public static void copyMemory(long srcAddr, byte[] dst, int dstIndex, long length) {\n        PlatformDependent0.copyMemory(null, srcAddr, dst, BYTE_ARRAY_BASE_OFFSET + dstIndex, length);\n    }\n\n    public static void setMemory(byte[] dst, int dstIndex, long bytes, byte value) {\n        PlatformDependent0.setMemory(dst, BYTE_ARRAY_BASE_OFFSET + dstIndex, bytes, value);\n    }\n\n    public static void setMemory(long address, long bytes, byte value) {\n        PlatformDependent0.setMemory(address, bytes, value);\n    }\n\n    /**\n     * Allocate a new {@link ByteBuffer} with the given {@code capacity}. {@link ByteBuffer}s allocated with\n     * this method <strong>MUST</strong> be deallocated via {@link #freeDirectNoCleaner(ByteBuffer)}.\n     */\n    public static ByteBuffer allocateDirectNoCleaner(int capacity) {\n        assert USE_DIRECT_BUFFER_NO_CLEANER;\n\n        incrementMemoryCounter(capacity);\n        try {\n            return PlatformDependent0.allocateDirectNoCleaner(capacity);\n        } catch (Throwable e) {\n            decrementMemoryCounter(capacity);\n            throwException(e);\n            return null;\n        }\n    }\n\n    /**\n     * Reallocate a new {@link ByteBuffer} with the given {@code capacity}. {@link ByteBuffer}s reallocated with\n     * this method <strong>MUST</strong> be deallocated via {@link #freeDirectNoCleaner(ByteBuffer)}.\n     */\n    public static ByteBuffer reallocateDirectNoCleaner(ByteBuffer buffer, int capacity) {\n        assert USE_DIRECT_BUFFER_NO_CLEANER;\n\n        int len = capacity - buffer.capacity();\n        incrementMemoryCounter(len);\n        try {\n            return PlatformDependent0.reallocateDirectNoCleaner(buffer, capacity);\n        } catch (Throwable e) {\n            decrementMemoryCounter(len);\n            throwException(e);\n            return null;\n        }\n    }\n\n    /**\n     * This method <strong>MUST</strong> only be called for {@link ByteBuffer}s that were allocated via\n     * {@link #allocateDirectNoCleaner(int)}.\n     */\n    public static void freeDirectNoCleaner(ByteBuffer buffer) {\n        assert USE_DIRECT_BUFFER_NO_CLEANER;\n\n        int capacity = buffer.capacity();\n        PlatformDependent0.freeMemory(PlatformDependent0.directBufferAddress(buffer));\n        decrementMemoryCounter(capacity);\n    }\n\n    private static void incrementMemoryCounter(int capacity) {\n        if (DIRECT_MEMORY_COUNTER != null) {\n            long newUsedMemory = DIRECT_MEMORY_COUNTER.addAndGet(capacity);\n            if (newUsedMemory > DIRECT_MEMORY_LIMIT) {\n                DIRECT_MEMORY_COUNTER.addAndGet(-capacity);\n                throw new OutOfDirectMemoryError(\"failed to allocate \" + capacity\n                        + \" byte(s) of direct memory (used: \" + (newUsedMemory - capacity)\n                        + \", max: \" + DIRECT_MEMORY_LIMIT + ')');\n            }\n        }\n    }\n\n    private static void decrementMemoryCounter(int capacity) {\n        if (DIRECT_MEMORY_COUNTER != null) {\n            long usedMemory = DIRECT_MEMORY_COUNTER.addAndGet(-capacity);\n            assert usedMemory >= 0;\n        }\n    }\n\n    public static boolean useDirectBufferNoCleaner() {\n        return USE_DIRECT_BUFFER_NO_CLEANER;\n    }\n\n    /**\n     * Compare two {@code byte} arrays for equality. For performance reasons no bounds checking on the\n     * parameters is performed.\n     *\n     * @param bytes1 the first byte array.\n     * @param startPos1 the position (inclusive) to start comparing in {@code bytes1}.\n     * @param bytes2 the second byte array.\n     * @param startPos2 the position (inclusive) to start comparing in {@code bytes2}.\n     * @param length the amount of bytes to compare. This is assumed to be validated as not going out of bounds\n     * by the caller.\n     */\n    public static boolean equals(byte[] bytes1, int startPos1, byte[] bytes2, int startPos2, int length) {\n        return !hasUnsafe() || !unalignedAccess() ?\n                  equalsSafe(bytes1, startPos1, bytes2, startPos2, length) :\n                  PlatformDependent0.equals(bytes1, startPos1, bytes2, startPos2, length);\n    }\n\n    /**\n     * Determine if a subsection of an array is zero.\n     * @param bytes The byte array.\n     * @param startPos The starting index (inclusive) in {@code bytes}.\n     * @param length The amount of bytes to check for zero.\n     * @return {@code false} if {@code bytes[startPos:startsPos+length)} contains a value other than zero.\n     */\n    public static boolean isZero(byte[] bytes, int startPos, int length) {\n        return !hasUnsafe() || !unalignedAccess() ?\n                isZeroSafe(bytes, startPos, length) :\n                PlatformDependent0.isZero(bytes, startPos, length);\n    }\n\n    /**\n     * Compare two {@code byte} arrays for equality without leaking timing information.\n     * For performance reasons no bounds checking on the parameters is performed.\n     * <p>\n     * The {@code int} return type is intentional and is designed to allow cascading of constant time operations:\n     * <pre>\n     *     byte[] s1 = new {1, 2, 3};\n     *     byte[] s2 = new {1, 2, 3};\n     *     byte[] s3 = new {1, 2, 3};\n     *     byte[] s4 = new {4, 5, 6};\n     *     boolean equals = (equalsConstantTime(s1, 0, s2, 0, s1.length) &\n     *                       equalsConstantTime(s3, 0, s4, 0, s3.length)) != 0;\n     * </pre>\n     * @param bytes1 the first byte array.\n     * @param startPos1 the position (inclusive) to start comparing in {@code bytes1}.\n     * @param bytes2 the second byte array.\n     * @param startPos2 the position (inclusive) to start comparing in {@code bytes2}.\n     * @param length the amount of bytes to compare. This is assumed to be validated as not going out of bounds\n     * by the caller.\n     * @return {@code 0} if not equal. {@code 1} if equal.\n     */\n    public static int equalsConstantTime(byte[] bytes1, int startPos1, byte[] bytes2, int startPos2, int length) {\n        return !hasUnsafe() || !unalignedAccess() ?\n                  ConstantTimeUtils.equalsConstantTime(bytes1, startPos1, bytes2, startPos2, length) :\n                  PlatformDependent0.equalsConstantTime(bytes1, startPos1, bytes2, startPos2, length);\n    }\n\n    /**\n     * Calculate a hash code of a byte array assuming ASCII character encoding.\n     * The resulting hash code will be case insensitive.\n     * @param bytes The array which contains the data to hash.\n     * @param startPos What index to start generating a hash code in {@code bytes}\n     * @param length The amount of bytes that should be accounted for in the computation.\n     * @return The hash code of {@code bytes} assuming ASCII character encoding.\n     * The resulting hash code will be case insensitive.\n     */\n    public static int hashCodeAscii(byte[] bytes, int startPos, int length) {\n        return !hasUnsafe() || !unalignedAccess() ?\n                hashCodeAsciiSafe(bytes, startPos, length) :\n                PlatformDependent0.hashCodeAscii(bytes, startPos, length);\n    }\n\n    /**\n     * Calculate a hash code of a byte array assuming ASCII character encoding.\n     * The resulting hash code will be case insensitive.\n     * <p>\n     * This method assumes that {@code bytes} is equivalent to a {@code byte[]} but just using {@link CharSequence}\n     * for storage. The upper most byte of each {@code char} from {@code bytes} is ignored.\n     * @param bytes The array which contains the data to hash (assumed to be equivalent to a {@code byte[]}).\n     * @return The hash code of {@code bytes} assuming ASCII character encoding.\n     * The resulting hash code will be case insensitive.\n     */\n    public static int hashCodeAscii(CharSequence bytes) {\n        final int length = bytes.length();\n        final int remainingBytes = length & 7;\n        int hash = HASH_CODE_ASCII_SEED;\n        // Benchmarking shows that by just naively looping for inputs 8~31 bytes long we incur a relatively large\n        // performance penalty (only achieve about 60% performance of loop which iterates over each char). So because\n        // of this we take special provisions to unroll the looping for these conditions.\n        if (length >= 32) {\n            for (int i = length - 8; i >= remainingBytes; i -= 8) {\n                hash = hashCodeAsciiCompute(bytes, i, hash);\n            }\n        } else if (length >= 8) {\n            hash = hashCodeAsciiCompute(bytes, length - 8, hash);\n            if (length >= 16) {\n                hash = hashCodeAsciiCompute(bytes, length - 16, hash);\n                if (length >= 24) {\n                    hash = hashCodeAsciiCompute(bytes, length - 24, hash);\n                }\n            }\n        }\n        if (remainingBytes == 0) {\n            return hash;\n        }\n        int offset = 0;\n        if (remainingBytes != 2 & remainingBytes != 4 & remainingBytes != 6) { // 1, 3, 5, 7\n            hash = hash * HASH_CODE_C1 + hashCodeAsciiSanitizeByte(bytes.charAt(0));\n            offset = 1;\n        }\n        if (remainingBytes != 1 & remainingBytes != 4 & remainingBytes != 5) { // 2, 3, 6, 7\n            hash = hash * (offset == 0 ? HASH_CODE_C1 : HASH_CODE_C2)\n                    + hashCodeAsciiSanitize(hashCodeAsciiSanitizeShort(bytes, offset));\n            offset += 2;\n        }\n        if (remainingBytes >= 4) { // 4, 5, 6, 7\n            return hash * ((offset == 0 | offset == 3) ? HASH_CODE_C1 : HASH_CODE_C2)\n                    + hashCodeAsciiSanitizeInt(bytes, offset);\n        }\n        return hash;\n    }\n\n    private static final class Mpsc {\n        private static final boolean USE_MPSC_CHUNKED_ARRAY_QUEUE;\n\n        private Mpsc() {\n        }\n\n        static {\n            Object unsafe = null;\n            if (hasUnsafe()) {\n                // jctools goes through its own process of initializing unsafe; of\n                // course, this requires permissions which might not be granted to calling code, so we\n                // must mark this block as privileged too\n                unsafe = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n                    @Override\n                    public Object run() {\n                        // force JCTools to initialize unsafe\n                        return UnsafeAccess.UNSAFE;\n                    }\n                });\n            }\n\n            if (unsafe == null) {\n                logger.debug(\"org.jctools-core.MpscChunkedArrayQueue: unavailable\");\n                USE_MPSC_CHUNKED_ARRAY_QUEUE = false;\n            } else {\n                logger.debug(\"org.jctools-core.MpscChunkedArrayQueue: available\");\n                USE_MPSC_CHUNKED_ARRAY_QUEUE = true;\n            }\n        }\n\n        static <T> Queue<T> newMpscQueue(final int maxCapacity) {\n            // Calculate the max capacity which can not be bigger than MAX_ALLOWED_MPSC_CAPACITY.\n            // This is forced by the MpscChunkedArrayQueue implementation as will try to round it\n            // up to the next power of two and so will overflow otherwise.\n            final int capacity = max(min(maxCapacity, MAX_ALLOWED_MPSC_CAPACITY), MIN_MAX_MPSC_CAPACITY);\n            return USE_MPSC_CHUNKED_ARRAY_QUEUE ? new MpscChunkedArrayQueue<T>(MPSC_CHUNK_SIZE, capacity)\n                                                : new MpscChunkedAtomicArrayQueue<T>(MPSC_CHUNK_SIZE, capacity);\n        }\n\n        static <T> Queue<T> newMpscQueue() {\n            return USE_MPSC_CHUNKED_ARRAY_QUEUE ? new MpscUnboundedArrayQueue<T>(MPSC_CHUNK_SIZE)\n                                                : new MpscUnboundedAtomicArrayQueue<T>(MPSC_CHUNK_SIZE);\n        }\n    }\n\n    /**\n     * Create a new {@link Queue} which is safe to use for multiple producers (different threads) and a single\n     * consumer (one thread!).\n     * @return A MPSC queue which may be unbounded.\n     */\n    public static <T> Queue<T> newMpscQueue() {\n        return Mpsc.newMpscQueue();\n    }\n\n    /**\n     * Create a new {@link Queue} which is safe to use for multiple producers (different threads) and a single\n     * consumer (one thread!).\n     */\n    public static <T> Queue<T> newMpscQueue(final int maxCapacity) {\n        return Mpsc.newMpscQueue(maxCapacity);\n    }\n\n    /**\n     * Create a new {@link Queue} which is safe to use for single producer (one thread!) and a single\n     * consumer (one thread!).\n     */\n    public static <T> Queue<T> newSpscQueue() {\n        return hasUnsafe() ? new SpscLinkedQueue<T>() : new SpscLinkedAtomicQueue<T>();\n    }\n\n    /**\n     * Create a new {@link Queue} which is safe to use for multiple producers (different threads) and a single\n     * consumer (one thread!) with the given fixes {@code capacity}.\n     */\n    public static <T> Queue<T> newFixedMpscQueue(int capacity) {\n        return hasUnsafe() ? new MpscArrayQueue<T>(capacity) : new MpscAtomicArrayQueue<T>(capacity);\n    }\n\n    /**\n     * Return the {@link ClassLoader} for the given {@link Class}.\n     */\n    public static ClassLoader getClassLoader(final Class<?> clazz) {\n        return PlatformDependent0.getClassLoader(clazz);\n    }\n\n    /**\n     * Return the context {@link ClassLoader} for the current {@link Thread}.\n     */\n    public static ClassLoader getContextClassLoader() {\n        return PlatformDependent0.getContextClassLoader();\n    }\n\n    /**\n     * Return the system {@link ClassLoader}.\n     */\n    public static ClassLoader getSystemClassLoader() {\n        return PlatformDependent0.getSystemClassLoader();\n    }\n\n    /**\n     * Returns a new concurrent {@link Deque}.\n     */\n    @SuppressJava6Requirement(reason = \"Usage guarded by java version check\")\n    public static <C> Deque<C> newConcurrentDeque() {\n        if (javaVersion() < 7) {\n            return new LinkedBlockingDeque<C>();\n        } else {\n            return new ConcurrentLinkedDeque<C>();\n        }\n    }\n\n    /**\n     * Return a {@link Random} which is not-threadsafe and so can only be used from the same thread.\n     */\n    public static Random threadLocalRandom() {\n        return RANDOM_PROVIDER.current();\n    }\n\n    private static boolean isWindows0() {\n        boolean windows = SystemPropertyUtil.get(\"os.name\", \"\").toLowerCase(Locale.US).contains(\"win\");\n        if (windows) {\n            logger.debug(\"Platform: Windows\");\n        }\n        return windows;\n    }\n\n    private static boolean isOsx0() {\n        String osname = SystemPropertyUtil.get(\"os.name\", \"\").toLowerCase(Locale.US)\n                .replaceAll(\"[^a-z0-9]+\", \"\");\n        boolean osx = osname.startsWith(\"macosx\") || osname.startsWith(\"osx\");\n\n        if (osx) {\n            logger.debug(\"Platform: MacOS\");\n        }\n        return osx;\n    }\n\n    private static boolean maybeSuperUser0() {\n        String username = SystemPropertyUtil.get(\"user.name\");\n        if (isWindows()) {\n            return \"Administrator\".equals(username);\n        }\n        // Check for root and toor as some BSDs have a toor user that is basically the same as root.\n        return \"root\".equals(username) || \"toor\".equals(username);\n    }\n\n    private static Throwable unsafeUnavailabilityCause0() {\n        if (isAndroid()) {\n            logger.debug(\"sun.misc.Unsafe: unavailable (Android)\");\n            return new UnsupportedOperationException(\"sun.misc.Unsafe: unavailable (Android)\");\n        }\n\n        if (isIkvmDotNet()) {\n            logger.debug(\"sun.misc.Unsafe: unavailable (IKVM.NET)\");\n            return new UnsupportedOperationException(\"sun.misc.Unsafe: unavailable (IKVM.NET)\");\n        }\n\n        Throwable cause = PlatformDependent0.getUnsafeUnavailabilityCause();\n        if (cause != null) {\n            return cause;\n        }\n\n        try {\n            boolean hasUnsafe = PlatformDependent0.hasUnsafe();\n            logger.debug(\"sun.misc.Unsafe: {}\", hasUnsafe ? \"available\" : \"unavailable\");\n            return hasUnsafe ? null : PlatformDependent0.getUnsafeUnavailabilityCause();\n        } catch (Throwable t) {\n            logger.trace(\"Could not determine if Unsafe is available\", t);\n            // Probably failed to initialize PlatformDependent0.\n            return new UnsupportedOperationException(\"Could not determine if Unsafe is available\", t);\n        }\n    }\n\n    /**\n     * Returns {@code true} if the running JVM is either <a href=\"https://developer.ibm.com/javasdk/\">IBM J9</a> or\n     * <a href=\"https://www.eclipse.org/openj9/\">Eclipse OpenJ9</a>, {@code false} otherwise.\n     */\n    public static boolean isJ9Jvm() {\n        return IS_J9_JVM;\n    }\n\n    private static boolean isJ9Jvm0() {\n        String vmName = SystemPropertyUtil.get(\"java.vm.name\", \"\").toLowerCase();\n        return vmName.startsWith(\"ibm j9\") || vmName.startsWith(\"eclipse openj9\");\n    }\n\n    /**\n     * Returns {@code true} if the running JVM is <a href=\"https://www.ikvm.net\">IKVM.NET</a>, {@code false} otherwise.\n     */\n    public static boolean isIkvmDotNet() {\n        return IS_IVKVM_DOT_NET;\n    }\n\n    private static boolean isIkvmDotNet0() {\n        String vmName = SystemPropertyUtil.get(\"java.vm.name\", \"\").toUpperCase(Locale.US);\n        return vmName.equals(\"IKVM.NET\");\n    }\n\n    private static long maxDirectMemory0() {\n        long maxDirectMemory = 0;\n\n        ClassLoader systemClassLoader = null;\n        try {\n            systemClassLoader = getSystemClassLoader();\n\n            // When using IBM J9 / Eclipse OpenJ9 we should not use VM.maxDirectMemory() as it not reflects the\n            // correct value.\n            // See:\n            //  - https://github.com/netty/netty/issues/7654\n            String vmName = SystemPropertyUtil.get(\"java.vm.name\", \"\").toLowerCase();\n            if (!vmName.startsWith(\"ibm j9\") &&\n                    // https://github.com/eclipse/openj9/blob/openj9-0.8.0/runtime/include/vendor_version.h#L53\n                    !vmName.startsWith(\"eclipse openj9\")) {\n                // Try to get from sun.misc.VM.maxDirectMemory() which should be most accurate.\n                Class<?> vmClass = Class.forName(\"sun.misc.VM\", true, systemClassLoader);\n                Method m = vmClass.getDeclaredMethod(\"maxDirectMemory\");\n                maxDirectMemory = ((Number) m.invoke(null)).longValue();\n            }\n        } catch (Throwable ignored) {\n            // Ignore\n        }\n\n        if (maxDirectMemory > 0) {\n            return maxDirectMemory;\n        }\n\n        try {\n            // Now try to get the JVM option (-XX:MaxDirectMemorySize) and parse it.\n            // Note that we are using reflection because Android doesn't have these classes.\n            Class<?> mgmtFactoryClass = Class.forName(\n                    \"java.lang.management.ManagementFactory\", true, systemClassLoader);\n            Class<?> runtimeClass = Class.forName(\n                    \"java.lang.management.RuntimeMXBean\", true, systemClassLoader);\n\n            Object runtime = mgmtFactoryClass.getDeclaredMethod(\"getRuntimeMXBean\").invoke(null);\n\n            @SuppressWarnings(\"unchecked\")\n            List<String> vmArgs = (List<String>) runtimeClass.getDeclaredMethod(\"getInputArguments\").invoke(runtime);\n            for (int i = vmArgs.size() - 1; i >= 0; i --) {\n                Matcher m = MAX_DIRECT_MEMORY_SIZE_ARG_PATTERN.matcher(vmArgs.get(i));\n                if (!m.matches()) {\n                    continue;\n                }\n\n                maxDirectMemory = Long.parseLong(m.group(1));\n                switch (m.group(2).charAt(0)) {\n                    case 'k': case 'K':\n                        maxDirectMemory *= 1024;\n                        break;\n                    case 'm': case 'M':\n                        maxDirectMemory *= 1024 * 1024;\n                        break;\n                    case 'g': case 'G':\n                        maxDirectMemory *= 1024 * 1024 * 1024;\n                        break;\n                    default:\n                        break;\n                }\n                break;\n            }\n        } catch (Throwable ignored) {\n            // Ignore\n        }\n\n        if (maxDirectMemory <= 0) {\n            maxDirectMemory = Runtime.getRuntime().maxMemory();\n            logger.debug(\"maxDirectMemory: {} bytes (maybe)\", maxDirectMemory);\n        } else {\n            logger.debug(\"maxDirectMemory: {} bytes\", maxDirectMemory);\n        }\n\n        return maxDirectMemory;\n    }\n\n    private static File tmpdir0() {\n        File f;\n        try {\n            f = toDirectory(SystemPropertyUtil.get(\"io.netty.tmpdir\"));\n            if (f != null) {\n                logger.debug(\"-Dio.netty.tmpdir: {}\", f);\n                return f;\n            }\n\n            f = toDirectory(SystemPropertyUtil.get(\"java.io.tmpdir\"));\n            if (f != null) {\n                logger.debug(\"-Dio.netty.tmpdir: {} (java.io.tmpdir)\", f);\n                return f;\n            }\n\n            // This shouldn't happen, but just in case ..\n            if (isWindows()) {\n                f = toDirectory(System.getenv(\"TEMP\"));\n                if (f != null) {\n                    logger.debug(\"-Dio.netty.tmpdir: {} (%TEMP%)\", f);\n                    return f;\n                }\n\n                String userprofile = System.getenv(\"USERPROFILE\");\n                if (userprofile != null) {\n                    f = toDirectory(userprofile + \"\\\\AppData\\\\Local\\\\Temp\");\n                    if (f != null) {\n                        logger.debug(\"-Dio.netty.tmpdir: {} (%USERPROFILE%\\\\AppData\\\\Local\\\\Temp)\", f);\n                        return f;\n                    }\n\n                    f = toDirectory(userprofile + \"\\\\Local Settings\\\\Temp\");\n                    if (f != null) {\n                        logger.debug(\"-Dio.netty.tmpdir: {} (%USERPROFILE%\\\\Local Settings\\\\Temp)\", f);\n                        return f;\n                    }\n                }\n            } else {\n                f = toDirectory(System.getenv(\"TMPDIR\"));\n                if (f != null) {\n                    logger.debug(\"-Dio.netty.tmpdir: {} ($TMPDIR)\", f);\n                    return f;\n                }\n            }\n        } catch (Throwable ignored) {\n            // Environment variable inaccessible\n        }\n\n        // Last resort.\n        if (isWindows()) {\n            f = new File(\"C:\\\\Windows\\\\Temp\");\n        } else {\n            f = new File(\"/tmp\");\n        }\n\n        logger.warn(\"Failed to get the temporary directory; falling back to: {}\", f);\n        return f;\n    }\n\n    @SuppressWarnings(\"ResultOfMethodCallIgnored\")\n    private static File toDirectory(String path) {\n        if (path == null) {\n            return null;\n        }\n\n        File f = new File(path);\n        f.mkdirs();\n\n        if (!f.isDirectory()) {\n            return null;\n        }\n\n        try {\n            return f.getAbsoluteFile();\n        } catch (Exception ignored) {\n            return f;\n        }\n    }\n\n    private static int bitMode0() {\n        // Check user-specified bit mode first.\n        int bitMode = SystemPropertyUtil.getInt(\"io.netty.bitMode\", 0);\n        if (bitMode > 0) {\n            logger.debug(\"-Dio.netty.bitMode: {}\", bitMode);\n            return bitMode;\n        }\n\n        // And then the vendor specific ones which is probably most reliable.\n        bitMode = SystemPropertyUtil.getInt(\"sun.arch.data.model\", 0);\n        if (bitMode > 0) {\n            logger.debug(\"-Dio.netty.bitMode: {} (sun.arch.data.model)\", bitMode);\n            return bitMode;\n        }\n        bitMode = SystemPropertyUtil.getInt(\"com.ibm.vm.bitmode\", 0);\n        if (bitMode > 0) {\n            logger.debug(\"-Dio.netty.bitMode: {} (com.ibm.vm.bitmode)\", bitMode);\n            return bitMode;\n        }\n\n        // os.arch also gives us a good hint.\n        String arch = SystemPropertyUtil.get(\"os.arch\", \"\").toLowerCase(Locale.US).trim();\n        if (\"amd64\".equals(arch) || \"x86_64\".equals(arch)) {\n            bitMode = 64;\n        } else if (\"i386\".equals(arch) || \"i486\".equals(arch) || \"i586\".equals(arch) || \"i686\".equals(arch)) {\n            bitMode = 32;\n        }\n\n        if (bitMode > 0) {\n            logger.debug(\"-Dio.netty.bitMode: {} (os.arch: {})\", bitMode, arch);\n        }\n\n        // Last resort: guess from VM name and then fall back to most common 64-bit mode.\n        String vm = SystemPropertyUtil.get(\"java.vm.name\", \"\").toLowerCase(Locale.US);\n        Pattern bitPattern = Pattern.compile(\"([1-9][0-9]+)-?bit\");\n        Matcher m = bitPattern.matcher(vm);\n        if (m.find()) {\n            return Integer.parseInt(m.group(1));\n        } else {\n            return 64;\n        }\n    }\n\n    private static int addressSize0() {\n        if (!hasUnsafe()) {\n            return -1;\n        }\n        return PlatformDependent0.addressSize();\n    }\n\n    private static long byteArrayBaseOffset0() {\n        if (!hasUnsafe()) {\n            return -1;\n        }\n        return PlatformDependent0.byteArrayBaseOffset();\n    }\n\n    private static boolean equalsSafe(byte[] bytes1, int startPos1, byte[] bytes2, int startPos2, int length) {\n        final int end = startPos1 + length;\n        for (; startPos1 < end; ++startPos1, ++startPos2) {\n            if (bytes1[startPos1] != bytes2[startPos2]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static boolean isZeroSafe(byte[] bytes, int startPos, int length) {\n        final int end = startPos + length;\n        for (; startPos < end; ++startPos) {\n            if (bytes[startPos] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Package private for testing purposes only!\n     */\n    static int hashCodeAsciiSafe(byte[] bytes, int startPos, int length) {\n        int hash = HASH_CODE_ASCII_SEED;\n        final int remainingBytes = length & 7;\n        final int end = startPos + remainingBytes;\n        for (int i = startPos - 8 + length; i >= end; i -= 8) {\n            hash = PlatformDependent0.hashCodeAsciiCompute(getLongSafe(bytes, i), hash);\n        }\n        switch(remainingBytes) {\n        case 7:\n            return ((hash * HASH_CODE_C1 + hashCodeAsciiSanitize(bytes[startPos]))\n                          * HASH_CODE_C2 + hashCodeAsciiSanitize(getShortSafe(bytes, startPos + 1)))\n                          * HASH_CODE_C1 + hashCodeAsciiSanitize(getIntSafe(bytes, startPos + 3));\n        case 6:\n            return (hash * HASH_CODE_C1 + hashCodeAsciiSanitize(getShortSafe(bytes, startPos)))\n                         * HASH_CODE_C2 + hashCodeAsciiSanitize(getIntSafe(bytes, startPos + 2));\n        case 5:\n            return (hash * HASH_CODE_C1 + hashCodeAsciiSanitize(bytes[startPos]))\n                         * HASH_CODE_C2 + hashCodeAsciiSanitize(getIntSafe(bytes, startPos + 1));\n        case 4:\n            return hash * HASH_CODE_C1 + hashCodeAsciiSanitize(getIntSafe(bytes, startPos));\n        case 3:\n            return (hash * HASH_CODE_C1 + hashCodeAsciiSanitize(bytes[startPos]))\n                         * HASH_CODE_C2 + hashCodeAsciiSanitize(getShortSafe(bytes, startPos + 1));\n        case 2:\n            return hash * HASH_CODE_C1 + hashCodeAsciiSanitize(getShortSafe(bytes, startPos));\n        case 1:\n            return hash * HASH_CODE_C1 + hashCodeAsciiSanitize(bytes[startPos]);\n        default:\n            return hash;\n        }\n    }\n\n    public static String normalizedArch() {\n        return NORMALIZED_ARCH;\n    }\n\n    public static String normalizedOs() {\n        return NORMALIZED_OS;\n    }\n\n    public static Set<String> normalizedLinuxClassifiers() {\n        return LINUX_OS_CLASSIFIERS;\n    }\n\n    /**\n     * Adds only those classifier strings to <tt>dest</tt> which are present in <tt>allowed</tt>.\n     *\n     * @param allowed          allowed classifiers\n     * @param dest             destination set\n     * @param maybeClassifiers potential classifiers to add\n     */\n    private static void addClassifier(Set<String> allowed, Set<String> dest, String... maybeClassifiers) {\n        for (String id : maybeClassifiers) {\n            if (allowed.contains(id)) {\n                dest.add(id);\n            }\n        }\n    }\n\n    private static String normalizeOsReleaseVariableValue(String value) {\n        // Variable assignment values may be enclosed in double or single quotes.\n        return value.trim().replaceAll(\"[\\\"']\", \"\");\n    }\n\n    private static String normalize(String value) {\n        return value.toLowerCase(Locale.US).replaceAll(\"[^a-z0-9]+\", \"\");\n    }\n\n    private static String normalizeArch(String value) {\n        value = normalize(value);\n        if (value.matches(\"^(x8664|amd64|ia32e|em64t|x64)$\")) {\n            return \"x86_64\";\n        }\n        if (value.matches(\"^(x8632|x86|i[3-6]86|ia32|x32)$\")) {\n            return \"x86_32\";\n        }\n        if (value.matches(\"^(ia64|itanium64)$\")) {\n            return \"itanium_64\";\n        }\n        if (value.matches(\"^(sparc|sparc32)$\")) {\n            return \"sparc_32\";\n        }\n        if (value.matches(\"^(sparcv9|sparc64)$\")) {\n            return \"sparc_64\";\n        }\n        if (value.matches(\"^(arm|arm32)$\")) {\n            return \"arm_32\";\n        }\n        if (\"aarch64\".equals(value)) {\n            return \"aarch_64\";\n        }\n        if (value.matches(\"^(ppc|ppc32)$\")) {\n            return \"ppc_32\";\n        }\n        if (\"ppc64\".equals(value)) {\n            return \"ppc_64\";\n        }\n        if (\"ppc64le\".equals(value)) {\n            return \"ppcle_64\";\n        }\n        if (\"s390\".equals(value)) {\n            return \"s390_32\";\n        }\n        if (\"s390x\".equals(value)) {\n            return \"s390_64\";\n        }\n\n        return \"unknown\";\n    }\n\n    private static String normalizeOs(String value) {\n        value = normalize(value);\n        if (value.startsWith(\"aix\")) {\n            return \"aix\";\n        }\n        if (value.startsWith(\"hpux\")) {\n            return \"hpux\";\n        }\n        if (value.startsWith(\"os400\")) {\n            // Avoid the names such as os4000\n            if (value.length() <= 5 || !Character.isDigit(value.charAt(5))) {\n                return \"os400\";\n            }\n        }\n        if (value.startsWith(\"linux\")) {\n            return \"linux\";\n        }\n        if (value.startsWith(\"macosx\") || value.startsWith(\"osx\")) {\n            return \"osx\";\n        }\n        if (value.startsWith(\"freebsd\")) {\n            return \"freebsd\";\n        }\n        if (value.startsWith(\"openbsd\")) {\n            return \"openbsd\";\n        }\n        if (value.startsWith(\"netbsd\")) {\n            return \"netbsd\";\n        }\n        if (value.startsWith(\"solaris\") || value.startsWith(\"sunos\")) {\n            return \"sunos\";\n        }\n        if (value.startsWith(\"windows\")) {\n            return \"windows\";\n        }\n\n        return \"unknown\";\n    }\n\n    private static final class AtomicLongCounter extends AtomicLong implements LongCounter {\n        private static final long serialVersionUID = 4074772784610639305L;\n\n        @Override\n        public void add(long delta) {\n            addAndGet(delta);\n        }\n\n        @Override\n        public void increment() {\n            incrementAndGet();\n        }\n\n        @Override\n        public void decrement() {\n            decrementAndGet();\n        }\n\n        @Override\n        public long value() {\n            return get();\n        }\n    }\n\n    private interface ThreadLocalRandomProvider {\n        Random current();\n    }\n\n    private PlatformDependent() {\n        // only static method supported\n    }\n}\n", "/*\n * Copyright 2014 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\npackage io.netty.handler.ssl.util;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.handler.codec.base64.Base64;\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.internal.SystemPropertyUtil;\nimport io.netty.util.internal.ThrowableUtil;\nimport io.netty.util.internal.logging.InternalLogger;\nimport io.netty.util.internal.logging.InternalLoggerFactory;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.SecureRandom;\nimport java.security.cert.CertificateEncodingException;\nimport java.security.cert.CertificateException;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.X509Certificate;\nimport java.util.Date;\n\n/**\n * Generates a temporary self-signed certificate for testing purposes.\n * <p>\n * <strong>NOTE:</strong>\n * Never use the certificate and private key generated by this class in production.\n * It is purely for testing purposes, and thus it is very insecure.\n * It even uses an insecure pseudo-random generator for faster generation internally.\n * </p><p>\n * An X.509 certificate file and a EC/RSA private key file are generated in a system's temporary directory using\n * {@link java.io.File#createTempFile(String, String)}, and they are deleted when the JVM exits using\n * {@link java.io.File#deleteOnExit()}.\n * </p><p>\n * At first, this method tries to use OpenJDK's X.509 implementation (the {@code sun.security.x509} package).\n * If it fails, it tries to use <a href=\"https://www.bouncycastle.org/\">Bouncy Castle</a> as a fallback.\n * </p>\n */\npublic final class SelfSignedCertificate {\n\n    private static final InternalLogger logger = InternalLoggerFactory.getInstance(SelfSignedCertificate.class);\n\n    /** Current time minus 1 year, just in case software clock goes back due to time synchronization */\n    private static final Date DEFAULT_NOT_BEFORE = new Date(SystemPropertyUtil.getLong(\n            \"io.netty.selfSignedCertificate.defaultNotBefore\", System.currentTimeMillis() - 86400000L * 365));\n    /** The maximum possible value in X.509 specification: 9999-12-31 23:59:59 */\n    private static final Date DEFAULT_NOT_AFTER = new Date(SystemPropertyUtil.getLong(\n            \"io.netty.selfSignedCertificate.defaultNotAfter\", 253402300799000L));\n\n    /**\n     * FIPS 140-2 encryption requires the RSA key length to be 2048 bits or greater.\n     * Let's use that as a sane default but allow the default to be set dynamically\n     * for those that need more stringent security requirements.\n     */\n    private static final int DEFAULT_KEY_LENGTH_BITS =\n            SystemPropertyUtil.getInt(\"io.netty.handler.ssl.util.selfSignedKeyStrength\", 2048);\n\n    private final File certificate;\n    private final File privateKey;\n    private final X509Certificate cert;\n    private final PrivateKey key;\n\n    /**\n     * Creates a new instance.\n     * <p> Algorithm: RSA </p>\n     */\n    public SelfSignedCertificate() throws CertificateException {\n        this(DEFAULT_NOT_BEFORE, DEFAULT_NOT_AFTER, \"RSA\", DEFAULT_KEY_LENGTH_BITS);\n    }\n\n    /**\n     * Creates a new instance.\n     * <p> Algorithm: RSA </p>\n     *\n     * @param notBefore Certificate is not valid before this time\n     * @param notAfter  Certificate is not valid after this time\n     */\n    public SelfSignedCertificate(Date notBefore, Date notAfter)\n            throws CertificateException {\n        this(\"localhost\", notBefore, notAfter, \"RSA\", DEFAULT_KEY_LENGTH_BITS);\n    }\n\n    /**\n     * Creates a new instance.\n     *\n     * @param notBefore Certificate is not valid before this time\n     * @param notAfter  Certificate is not valid after this time\n     * @param algorithm Key pair algorithm\n     * @param bits      the number of bits of the generated private key\n     */\n    public SelfSignedCertificate(Date notBefore, Date notAfter, String algorithm, int bits)\n            throws CertificateException {\n        this(\"localhost\", notBefore, notAfter, algorithm, bits);\n    }\n\n    /**\n     * Creates a new instance.\n     * <p> Algorithm: RSA </p>\n     *\n     * @param fqdn a fully qualified domain name\n     */\n    public SelfSignedCertificate(String fqdn) throws CertificateException {\n        this(fqdn, DEFAULT_NOT_BEFORE, DEFAULT_NOT_AFTER, \"RSA\", DEFAULT_KEY_LENGTH_BITS);\n    }\n\n    /**\n     * Creates a new instance.\n     *\n     * @param fqdn      a fully qualified domain name\n     * @param algorithm Key pair algorithm\n     * @param bits      the number of bits of the generated private key\n     */\n    public SelfSignedCertificate(String fqdn, String algorithm, int bits) throws CertificateException {\n        this(fqdn, DEFAULT_NOT_BEFORE, DEFAULT_NOT_AFTER, algorithm, bits);\n    }\n\n    /**\n     * Creates a new instance.\n     * <p> Algorithm: RSA </p>\n     *\n     * @param fqdn      a fully qualified domain name\n     * @param notBefore Certificate is not valid before this time\n     * @param notAfter  Certificate is not valid after this time\n     */\n    public SelfSignedCertificate(String fqdn, Date notBefore, Date notAfter) throws CertificateException {\n        // Bypass entropy collection by using insecure random generator.\n        // We just want to generate it without any delay because it's for testing purposes only.\n        this(fqdn, ThreadLocalInsecureRandom.current(), DEFAULT_KEY_LENGTH_BITS, notBefore, notAfter, \"RSA\");\n    }\n\n    /**\n     * Creates a new instance.\n     *\n     * @param fqdn      a fully qualified domain name\n     * @param notBefore Certificate is not valid before this time\n     * @param notAfter  Certificate is not valid after this time\n     * @param algorithm Key pair algorithm\n     * @param bits      the number of bits of the generated private key\n     */\n    public SelfSignedCertificate(String fqdn, Date notBefore, Date notAfter, String algorithm, int bits)\n            throws CertificateException {\n        // Bypass entropy collection by using insecure random generator.\n        // We just want to generate it without any delay because it's for testing purposes only.\n        this(fqdn, ThreadLocalInsecureRandom.current(), bits, notBefore, notAfter, algorithm);\n    }\n\n    /**\n     * Creates a new instance.\n     * <p> Algorithm: RSA </p>\n     *\n     * @param fqdn      a fully qualified domain name\n     * @param random    the {@link SecureRandom} to use\n     * @param bits      the number of bits of the generated private key\n     */\n    public SelfSignedCertificate(String fqdn, SecureRandom random, int bits)\n            throws CertificateException {\n        this(fqdn, random, bits, DEFAULT_NOT_BEFORE, DEFAULT_NOT_AFTER, \"RSA\");\n    }\n\n    /**\n     * Creates a new instance.\n     *\n     * @param fqdn      a fully qualified domain name\n     * @param random    the {@link SecureRandom} to use\n     * @param algorithm Key pair algorithm\n     * @param bits      the number of bits of the generated private key\n     */\n    public SelfSignedCertificate(String fqdn, SecureRandom random, String algorithm, int bits)\n            throws CertificateException {\n        this(fqdn, random, bits, DEFAULT_NOT_BEFORE, DEFAULT_NOT_AFTER, algorithm);\n    }\n\n    /**\n     * Creates a new instance.\n     * <p> Algorithm: RSA </p>\n     *\n     * @param fqdn      a fully qualified domain name\n     * @param random    the {@link SecureRandom} to use\n     * @param bits      the number of bits of the generated private key\n     * @param notBefore Certificate is not valid before this time\n     * @param notAfter  Certificate is not valid after this time\n     */\n    public SelfSignedCertificate(String fqdn, SecureRandom random, int bits, Date notBefore, Date notAfter)\n            throws CertificateException {\n        this(fqdn, random, bits, notBefore, notAfter, \"RSA\");\n    }\n\n    /**\n     * Creates a new instance.\n     *\n     * @param fqdn      a fully qualified domain name\n     * @param random    the {@link SecureRandom} to use\n     * @param bits      the number of bits of the generated private key\n     * @param notBefore Certificate is not valid before this time\n     * @param notAfter  Certificate is not valid after this time\n     * @param algorithm Key pair algorithm\n     */\n    public SelfSignedCertificate(String fqdn, SecureRandom random, int bits, Date notBefore, Date notAfter,\n                                 String algorithm) throws CertificateException {\n\n        if (!algorithm.equalsIgnoreCase(\"EC\") && !algorithm.equalsIgnoreCase(\"RSA\")) {\n            throw new IllegalArgumentException(\"Algorithm not valid: \" + algorithm);\n        }\n\n        final KeyPair keypair;\n        try {\n            KeyPairGenerator keyGen = KeyPairGenerator.getInstance(algorithm);\n            keyGen.initialize(bits, random);\n            keypair = keyGen.generateKeyPair();\n        } catch (NoSuchAlgorithmException e) {\n            // Should not reach here because every Java implementation must have RSA and EC key pair generator.\n            throw new Error(e);\n        }\n\n        String[] paths;\n        try {\n            // Try the OpenJDK's proprietary implementation.\n            paths = OpenJdkSelfSignedCertGenerator.generate(fqdn, keypair, random, notBefore, notAfter, algorithm);\n        } catch (Throwable t) {\n            logger.debug(\"Failed to generate a self-signed X.509 certificate using sun.security.x509:\", t);\n            try {\n                // Try Bouncy Castle if the current JVM didn't have sun.security.x509.\n                paths = BouncyCastleSelfSignedCertGenerator.generate(\n                        fqdn, keypair, random, notBefore, notAfter, algorithm);\n            } catch (Throwable t2) {\n                logger.debug(\"Failed to generate a self-signed X.509 certificate using Bouncy Castle:\", t2);\n                final CertificateException certificateException = new CertificateException(\n                        \"No provider succeeded to generate a self-signed certificate. \" +\n                                \"See debug log for the root cause.\", t2);\n                ThrowableUtil.addSuppressed(certificateException, t);\n                throw certificateException;\n            }\n        }\n\n        certificate = new File(paths[0]);\n        privateKey = new File(paths[1]);\n        key = keypair.getPrivate();\n        FileInputStream certificateInput = null;\n        try {\n            certificateInput = new FileInputStream(certificate);\n            cert = (X509Certificate) CertificateFactory.getInstance(\"X509\").generateCertificate(certificateInput);\n        } catch (Exception e) {\n            throw new CertificateEncodingException(e);\n        } finally {\n            if (certificateInput != null) {\n                try {\n                    certificateInput.close();\n                } catch (IOException e) {\n                    if (logger.isWarnEnabled()) {\n                        logger.warn(\"Failed to close a file: \" + certificate, e);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns the generated X.509 certificate file in PEM format.\n     */\n    public File certificate() {\n        return certificate;\n    }\n\n    /**\n     * Returns the generated RSA private key file in PEM format.\n     */\n    public File privateKey() {\n        return privateKey;\n    }\n\n    /**\n     *  Returns the generated X.509 certificate.\n     */\n    public X509Certificate cert() {\n        return cert;\n    }\n\n    /**\n     * Returns the generated RSA private key.\n     */\n    public PrivateKey key() {\n        return key;\n    }\n\n    /**\n     * Deletes the generated X.509 certificate file and RSA private key file.\n     */\n    public void delete() {\n        safeDelete(certificate);\n        safeDelete(privateKey);\n    }\n\n    static String[] newSelfSignedCertificate(\n            String fqdn, PrivateKey key, X509Certificate cert) throws IOException, CertificateEncodingException {\n        // Encode the private key into a file.\n        ByteBuf wrappedBuf = Unpooled.wrappedBuffer(key.getEncoded());\n        ByteBuf encodedBuf;\n        final String keyText;\n        try {\n            encodedBuf = Base64.encode(wrappedBuf, true);\n            try {\n                keyText = \"-----BEGIN PRIVATE KEY-----\\n\" +\n                        encodedBuf.toString(CharsetUtil.US_ASCII) +\n                        \"\\n-----END PRIVATE KEY-----\\n\";\n            } finally {\n                encodedBuf.release();\n            }\n        } finally {\n            wrappedBuf.release();\n        }\n\n        File keyFile = File.createTempFile(\"keyutil_\" + fqdn + '_', \".key\");\n        keyFile.deleteOnExit();\n\n        OutputStream keyOut = new FileOutputStream(keyFile);\n        try {\n            keyOut.write(keyText.getBytes(CharsetUtil.US_ASCII));\n            keyOut.close();\n            keyOut = null;\n        } finally {\n            if (keyOut != null) {\n                safeClose(keyFile, keyOut);\n                safeDelete(keyFile);\n            }\n        }\n\n        wrappedBuf = Unpooled.wrappedBuffer(cert.getEncoded());\n        final String certText;\n        try {\n            encodedBuf = Base64.encode(wrappedBuf, true);\n            try {\n                // Encode the certificate into a CRT file.\n                certText = \"-----BEGIN CERTIFICATE-----\\n\" +\n                        encodedBuf.toString(CharsetUtil.US_ASCII) +\n                        \"\\n-----END CERTIFICATE-----\\n\";\n            } finally {\n                encodedBuf.release();\n            }\n        } finally {\n            wrappedBuf.release();\n        }\n\n        File certFile = File.createTempFile(\"keyutil_\" + fqdn + '_', \".crt\");\n        certFile.deleteOnExit();\n\n        OutputStream certOut = new FileOutputStream(certFile);\n        try {\n            certOut.write(certText.getBytes(CharsetUtil.US_ASCII));\n            certOut.close();\n            certOut = null;\n        } finally {\n            if (certOut != null) {\n                safeClose(certFile, certOut);\n                safeDelete(certFile);\n                safeDelete(keyFile);\n            }\n        }\n\n        return new String[] { certFile.getPath(), keyFile.getPath() };\n    }\n\n    private static void safeDelete(File certFile) {\n        if (!certFile.delete()) {\n            if (logger.isWarnEnabled()) {\n                logger.warn(\"Failed to delete a file: \" + certFile);\n            }\n        }\n    }\n\n    private static void safeClose(File keyFile, OutputStream keyOut) {\n        try {\n            keyOut.close();\n        } catch (IOException e) {\n            if (logger.isWarnEnabled()) {\n                logger.warn(\"Failed to close a file: \" + keyFile, e);\n            }\n        }\n    }\n}\n", "/*\n * Copyright 2012 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.stream;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufAllocator;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelOutboundHandlerAdapter;\nimport io.netty.channel.ChannelPromise;\nimport io.netty.channel.embedded.EmbeddedChannel;\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.ReferenceCountUtil;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.channels.Channels;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.FileChannel;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport static java.util.concurrent.TimeUnit.*;\nimport static org.junit.Assert.*;\n\npublic class ChunkedWriteHandlerTest {\n    private static final byte[] BYTES = new byte[1024 * 64];\n    private static final File TMP;\n\n    static {\n        for (int i = 0; i < BYTES.length; i++) {\n            BYTES[i] = (byte) i;\n        }\n\n        FileOutputStream out = null;\n        try {\n            TMP = File.createTempFile(\"netty-chunk-\", \".tmp\");\n            TMP.deleteOnExit();\n            out = new FileOutputStream(TMP);\n            out.write(BYTES);\n            out.flush();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            if (out != null) {\n                try {\n                    out.close();\n                } catch (IOException e) {\n                    // ignore\n                }\n            }\n        }\n    }\n\n    // See #310\n    @Test\n    public void testChunkedStream() {\n        check(new ChunkedStream(new ByteArrayInputStream(BYTES)));\n\n        check(new ChunkedStream(new ByteArrayInputStream(BYTES)),\n                new ChunkedStream(new ByteArrayInputStream(BYTES)),\n                new ChunkedStream(new ByteArrayInputStream(BYTES)));\n    }\n\n    @Test\n    public void testChunkedNioStream() {\n        check(new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))));\n\n        check(new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))),\n                new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))),\n                new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))));\n    }\n\n    @Test\n    public void testChunkedFile() throws IOException {\n        check(new ChunkedFile(TMP));\n\n        check(new ChunkedFile(TMP), new ChunkedFile(TMP), new ChunkedFile(TMP));\n    }\n\n    @Test\n    public void testChunkedNioFile() throws IOException {\n        check(new ChunkedNioFile(TMP));\n\n        check(new ChunkedNioFile(TMP), new ChunkedNioFile(TMP), new ChunkedNioFile(TMP));\n    }\n\n    @Test\n    public void testChunkedNioFileLeftPositionUnchanged() throws IOException {\n        FileChannel in = null;\n        final long expectedPosition = 10;\n        try {\n            in = new RandomAccessFile(TMP, \"r\").getChannel();\n            in.position(expectedPosition);\n            check(new ChunkedNioFile(in) {\n                @Override\n                public void close() throws Exception {\n                    //no op\n                }\n            });\n            Assert.assertTrue(in.isOpen());\n            Assert.assertEquals(expectedPosition, in.position());\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n\n    @Test(expected = ClosedChannelException.class)\n    public void testChunkedNioFileFailOnClosedFileChannel() throws IOException {\n        final FileChannel in = new RandomAccessFile(TMP, \"r\").getChannel();\n        in.close();\n        check(new ChunkedNioFile(in) {\n            @Override\n            public void close() throws Exception {\n                //no op\n            }\n        });\n        Assert.fail();\n    }\n\n    @Test\n    public void testUnchunkedData() throws IOException {\n        check(Unpooled.wrappedBuffer(BYTES));\n\n        check(Unpooled.wrappedBuffer(BYTES), Unpooled.wrappedBuffer(BYTES), Unpooled.wrappedBuffer(BYTES));\n    }\n\n    // Test case which shows that there is not a bug like stated here:\n    // https://stackoverflow.com/a/10426305\n    @Test\n    public void testListenerNotifiedWhenIsEnd() {\n        ByteBuf buffer = Unpooled.copiedBuffer(\"Test\", CharsetUtil.ISO_8859_1);\n\n        ChunkedInput<ByteBuf> input = new ChunkedInput<ByteBuf>() {\n            private boolean done;\n            private final ByteBuf buffer = Unpooled.copiedBuffer(\"Test\", CharsetUtil.ISO_8859_1);\n\n            @Override\n            public boolean isEndOfInput() throws Exception {\n                return done;\n            }\n\n            @Override\n            public void close() throws Exception {\n                buffer.release();\n            }\n\n            @Deprecated\n            @Override\n            public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {\n                return readChunk(ctx.alloc());\n            }\n\n            @Override\n            public ByteBuf readChunk(ByteBufAllocator allocator) throws Exception {\n                if (done) {\n                    return null;\n                }\n                done = true;\n                return buffer.retainedDuplicate();\n            }\n\n            @Override\n            public long length() {\n                return -1;\n            }\n\n            @Override\n            public long progress() {\n                return 1;\n            }\n        };\n\n        final AtomicBoolean listenerNotified = new AtomicBoolean(false);\n        final ChannelFutureListener listener = new ChannelFutureListener() {\n\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                listenerNotified.set(true);\n            }\n        };\n\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n        ch.writeAndFlush(input).addListener(listener).syncUninterruptibly();\n        assertTrue(ch.finish());\n\n        // the listener should have been notified\n        assertTrue(listenerNotified.get());\n\n        ByteBuf buffer2 = ch.readOutbound();\n        assertEquals(buffer, buffer2);\n        assertNull(ch.readOutbound());\n\n        buffer.release();\n        buffer2.release();\n    }\n\n    @Test\n    public void testChunkedMessageInput() {\n\n        ChunkedInput<Object> input = new ChunkedInput<Object>() {\n            private boolean done;\n\n            @Override\n            public boolean isEndOfInput() throws Exception {\n                return done;\n            }\n\n            @Override\n            public void close() throws Exception {\n                // NOOP\n            }\n\n            @Deprecated\n            @Override\n            public Object readChunk(ChannelHandlerContext ctx) throws Exception {\n                return readChunk(ctx.alloc());\n            }\n\n            @Override\n            public Object readChunk(ByteBufAllocator ctx) throws Exception {\n                if (done) {\n                    return false;\n                }\n                done = true;\n                return 0;\n            }\n\n            @Override\n            public long length() {\n                return -1;\n            }\n\n            @Override\n            public long progress() {\n                return 1;\n            }\n        };\n\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n        ch.writeAndFlush(input).syncUninterruptibly();\n        assertTrue(ch.finish());\n\n        assertEquals(0, ch.readOutbound());\n        assertNull(ch.readOutbound());\n    }\n\n    @Test\n    public void testWriteFailureChunkedStream() throws IOException {\n        checkFirstFailed(new ChunkedStream(new ByteArrayInputStream(BYTES)));\n    }\n\n    @Test\n    public void testWriteFailureChunkedNioStream() throws IOException {\n        checkFirstFailed(new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))));\n    }\n\n    @Test\n    public void testWriteFailureChunkedFile() throws IOException {\n        checkFirstFailed(new ChunkedFile(TMP));\n    }\n\n    @Test\n    public void testWriteFailureChunkedNioFile() throws IOException {\n        checkFirstFailed(new ChunkedNioFile(TMP));\n    }\n\n    @Test\n    public void testWriteFailureUnchunkedData() throws IOException {\n        checkFirstFailed(Unpooled.wrappedBuffer(BYTES));\n    }\n\n    @Test\n    public void testSkipAfterFailedChunkedStream() throws IOException {\n        checkSkipFailed(new ChunkedStream(new ByteArrayInputStream(BYTES)),\n                        new ChunkedStream(new ByteArrayInputStream(BYTES)));\n    }\n\n    @Test\n    public void testSkipAfterFailedChunkedNioStream() throws IOException {\n        checkSkipFailed(new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))),\n                        new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))));\n    }\n\n    @Test\n    public void testSkipAfterFailedChunkedFile() throws IOException {\n        checkSkipFailed(new ChunkedFile(TMP), new ChunkedFile(TMP));\n    }\n\n    @Test\n    public void testSkipAfterFailedChunkedNioFile() throws IOException {\n        checkSkipFailed(new ChunkedNioFile(TMP), new ChunkedFile(TMP));\n    }\n\n    // See https://github.com/netty/netty/issues/8700.\n    @Test\n    public void testFailureWhenLastChunkFailed() throws IOException {\n        ChannelOutboundHandlerAdapter failLast = new ChannelOutboundHandlerAdapter() {\n            private int passedWrites;\n\n            @Override\n            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n                if (++this.passedWrites < 4) {\n                    ctx.write(msg, promise);\n                } else {\n                    ReferenceCountUtil.release(msg);\n                    promise.tryFailure(new RuntimeException());\n                }\n            }\n        };\n\n        EmbeddedChannel ch = new EmbeddedChannel(failLast, new ChunkedWriteHandler());\n        ChannelFuture r = ch.writeAndFlush(new ChunkedFile(TMP, 1024 * 16)); // 4 chunks\n        assertTrue(ch.finish());\n\n        assertFalse(r.isSuccess());\n        assertTrue(r.cause() instanceof RuntimeException);\n\n        // 3 out of 4 chunks were already written\n        int read = 0;\n        for (;;) {\n            ByteBuf buffer = ch.readOutbound();\n            if (buffer == null) {\n                break;\n            }\n            read += buffer.readableBytes();\n            buffer.release();\n        }\n\n        assertEquals(1024 * 16 * 3, read);\n    }\n\n    @Test\n    public void testDiscardPendingWritesOnInactive() throws IOException {\n\n        final AtomicBoolean closeWasCalled = new AtomicBoolean(false);\n\n        ChunkedInput<ByteBuf> notifiableInput = new ChunkedInput<ByteBuf>() {\n            private boolean done;\n            private final ByteBuf buffer = Unpooled.copiedBuffer(\"Test\", CharsetUtil.ISO_8859_1);\n\n            @Override\n            public boolean isEndOfInput() throws Exception {\n                return done;\n            }\n\n            @Override\n            public void close() throws Exception {\n                buffer.release();\n                closeWasCalled.set(true);\n            }\n\n            @Deprecated\n            @Override\n            public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {\n                return readChunk(ctx.alloc());\n            }\n\n            @Override\n            public ByteBuf readChunk(ByteBufAllocator allocator) throws Exception {\n                if (done) {\n                    return null;\n                }\n                done = true;\n                return buffer.retainedDuplicate();\n            }\n\n            @Override\n            public long length() {\n                return -1;\n            }\n\n            @Override\n            public long progress() {\n                return 1;\n            }\n        };\n\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n\n        // Write 3 messages and close channel before flushing\n        ChannelFuture r1 = ch.write(new ChunkedFile(TMP));\n        ChannelFuture r2 = ch.write(new ChunkedNioFile(TMP));\n        ch.write(notifiableInput);\n\n        // Should be `false` as we do not expect any messages to be written\n        assertFalse(ch.finish());\n\n        assertFalse(r1.isSuccess());\n        assertFalse(r2.isSuccess());\n        assertTrue(closeWasCalled.get());\n    }\n\n    // See https://github.com/netty/netty/issues/8700.\n    @Test\n    public void testStopConsumingChunksWhenFailed() {\n        final ByteBuf buffer = Unpooled.copiedBuffer(\"Test\", CharsetUtil.ISO_8859_1);\n        final AtomicInteger chunks = new AtomicInteger(0);\n\n        ChunkedInput<ByteBuf> nonClosableInput = new ChunkedInput<ByteBuf>() {\n            @Override\n            public boolean isEndOfInput() throws Exception {\n                return chunks.get() >= 5;\n            }\n\n            @Override\n            public void close() throws Exception {\n                // no-op\n            }\n\n            @Deprecated\n            @Override\n            public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {\n                return readChunk(ctx.alloc());\n            }\n\n            @Override\n            public ByteBuf readChunk(ByteBufAllocator allocator) throws Exception {\n                chunks.incrementAndGet();\n                return buffer.retainedDuplicate();\n            }\n\n            @Override\n            public long length() {\n                return -1;\n            }\n\n            @Override\n            public long progress() {\n                return 1;\n            }\n        };\n\n        ChannelOutboundHandlerAdapter noOpWrites = new ChannelOutboundHandlerAdapter() {\n            @Override\n            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n                ReferenceCountUtil.release(msg);\n                promise.tryFailure(new RuntimeException());\n            }\n        };\n\n        EmbeddedChannel ch = new EmbeddedChannel(noOpWrites, new ChunkedWriteHandler());\n        ch.writeAndFlush(nonClosableInput).awaitUninterruptibly();\n        // Should be `false` as we do not expect any messages to be written\n        assertFalse(ch.finish());\n        buffer.release();\n\n        // We should expect only single chunked being read from the input.\n        // It's possible to get a race condition here between resolving a promise and\n        // allocating a new chunk, but should be fine when working with embedded channels.\n        assertEquals(1, chunks.get());\n    }\n\n    @Test\n    public void testCloseSuccessfulChunkedInput() {\n        int chunks = 10;\n        TestChunkedInput input = new TestChunkedInput(chunks);\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n\n        assertTrue(ch.writeOutbound(input));\n\n        for (int i = 0; i < chunks; i++) {\n            ByteBuf buf = ch.readOutbound();\n            assertEquals(i, buf.readInt());\n            buf.release();\n        }\n\n        assertTrue(input.isClosed());\n        assertFalse(ch.finish());\n    }\n\n    @Test\n    public void testCloseFailedChunkedInput() {\n        Exception error = new Exception(\"Unable to produce a chunk\");\n        ThrowingChunkedInput input = new ThrowingChunkedInput(error);\n\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n\n        try {\n            ch.writeOutbound(input);\n            fail(\"Exception expected\");\n        } catch (Exception e) {\n            assertEquals(error, e);\n        }\n\n        assertTrue(input.isClosed());\n        assertFalse(ch.finish());\n    }\n\n    @Test\n    public void testWriteListenerInvokedAfterSuccessfulChunkedInputClosed() throws Exception {\n        final TestChunkedInput input = new TestChunkedInput(2);\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n\n        final AtomicBoolean inputClosedWhenListenerInvoked = new AtomicBoolean();\n        final CountDownLatch listenerInvoked = new CountDownLatch(1);\n\n        ChannelFuture writeFuture = ch.write(input);\n        writeFuture.addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) {\n                inputClosedWhenListenerInvoked.set(input.isClosed());\n                listenerInvoked.countDown();\n            }\n        });\n        ch.flush();\n\n        assertTrue(listenerInvoked.await(10, SECONDS));\n        assertTrue(writeFuture.isSuccess());\n        assertTrue(inputClosedWhenListenerInvoked.get());\n        assertTrue(ch.finishAndReleaseAll());\n    }\n\n    @Test\n    public void testWriteListenerInvokedAfterFailedChunkedInputClosed() throws Exception {\n        final ThrowingChunkedInput input = new ThrowingChunkedInput(new RuntimeException());\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n\n        final AtomicBoolean inputClosedWhenListenerInvoked = new AtomicBoolean();\n        final CountDownLatch listenerInvoked = new CountDownLatch(1);\n\n        ChannelFuture writeFuture = ch.write(input);\n        writeFuture.addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) {\n                inputClosedWhenListenerInvoked.set(input.isClosed());\n                listenerInvoked.countDown();\n            }\n        });\n        ch.flush();\n\n        assertTrue(listenerInvoked.await(10, SECONDS));\n        assertFalse(writeFuture.isSuccess());\n        assertTrue(inputClosedWhenListenerInvoked.get());\n        assertFalse(ch.finish());\n    }\n\n    @Test\n    public void testWriteListenerInvokedAfterChannelClosedAndInputFullyConsumed() throws Exception {\n        // use empty input which has endOfInput = true\n        final TestChunkedInput input = new TestChunkedInput(0);\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n\n        final AtomicBoolean inputClosedWhenListenerInvoked = new AtomicBoolean();\n        final CountDownLatch listenerInvoked = new CountDownLatch(1);\n\n        ChannelFuture writeFuture = ch.write(input);\n        writeFuture.addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) {\n                inputClosedWhenListenerInvoked.set(input.isClosed());\n                listenerInvoked.countDown();\n            }\n        });\n        ch.close(); // close channel to make handler discard the input on subsequent flush\n        ch.flush();\n\n        assertTrue(listenerInvoked.await(10, SECONDS));\n        assertTrue(writeFuture.isSuccess());\n        assertTrue(inputClosedWhenListenerInvoked.get());\n        assertFalse(ch.finish());\n    }\n\n    @Test\n    public void testWriteListenerInvokedAfterChannelClosedAndInputNotFullyConsumed() throws Exception {\n        // use non-empty input which has endOfInput = false\n        final TestChunkedInput input = new TestChunkedInput(42);\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n\n        final AtomicBoolean inputClosedWhenListenerInvoked = new AtomicBoolean();\n        final CountDownLatch listenerInvoked = new CountDownLatch(1);\n\n        ChannelFuture writeFuture = ch.write(input);\n        writeFuture.addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) {\n                inputClosedWhenListenerInvoked.set(input.isClosed());\n                listenerInvoked.countDown();\n            }\n        });\n        ch.close(); // close channel to make handler discard the input on subsequent flush\n        ch.flush();\n\n        assertTrue(listenerInvoked.await(10, SECONDS));\n        assertFalse(writeFuture.isSuccess());\n        assertTrue(inputClosedWhenListenerInvoked.get());\n        assertFalse(ch.finish());\n    }\n\n    private static void check(Object... inputs) {\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n\n        for (Object input: inputs) {\n            ch.writeOutbound(input);\n        }\n\n        assertTrue(ch.finish());\n\n        int i = 0;\n        int read = 0;\n        for (;;) {\n            ByteBuf buffer = ch.readOutbound();\n            if (buffer == null) {\n                break;\n            }\n            while (buffer.isReadable()) {\n                assertEquals(BYTES[i++], buffer.readByte());\n                read++;\n                if (i == BYTES.length) {\n                    i = 0;\n                }\n            }\n            buffer.release();\n        }\n\n        assertEquals(BYTES.length * inputs.length, read);\n    }\n\n    private static void checkFirstFailed(Object input) {\n        ChannelOutboundHandlerAdapter noOpWrites = new ChannelOutboundHandlerAdapter() {\n            @Override\n            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n                ReferenceCountUtil.release(msg);\n                promise.tryFailure(new RuntimeException());\n            }\n        };\n\n        EmbeddedChannel ch = new EmbeddedChannel(noOpWrites, new ChunkedWriteHandler());\n        ChannelFuture r = ch.writeAndFlush(input);\n\n        // Should be `false` as we do not expect any messages to be written\n        assertFalse(ch.finish());\n        assertTrue(r.cause() instanceof RuntimeException);\n    }\n\n    private static void checkSkipFailed(Object input1, Object input2) {\n        ChannelOutboundHandlerAdapter failFirst = new ChannelOutboundHandlerAdapter() {\n            private boolean alreadyFailed;\n\n            @Override\n            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n                if (alreadyFailed) {\n                    ctx.write(msg, promise);\n                } else {\n                    this.alreadyFailed = true;\n                    ReferenceCountUtil.release(msg);\n                    promise.tryFailure(new RuntimeException());\n                }\n            }\n        };\n\n        EmbeddedChannel ch = new EmbeddedChannel(failFirst, new ChunkedWriteHandler());\n        ChannelFuture r1 = ch.write(input1);\n        ChannelFuture r2 = ch.writeAndFlush(input2).awaitUninterruptibly();\n        assertTrue(ch.finish());\n\n        assertTrue(r1.cause() instanceof RuntimeException);\n        assertTrue(r2.isSuccess());\n\n        // note, that after we've \"skipped\" the first write,\n        // we expect to see the second message, chunk by chunk\n        int i = 0;\n        int read = 0;\n        for (;;) {\n            ByteBuf buffer = ch.readOutbound();\n            if (buffer == null) {\n                break;\n            }\n            while (buffer.isReadable()) {\n                assertEquals(BYTES[i++], buffer.readByte());\n                read++;\n                if (i == BYTES.length) {\n                    i = 0;\n                }\n            }\n            buffer.release();\n        }\n\n        assertEquals(BYTES.length, read);\n    }\n\n    private static final class TestChunkedInput implements ChunkedInput<ByteBuf> {\n        private final int chunksToProduce;\n\n        private int chunksProduced;\n        private volatile boolean closed;\n\n        TestChunkedInput(int chunksToProduce) {\n            this.chunksToProduce = chunksToProduce;\n        }\n\n        @Override\n        public boolean isEndOfInput() {\n            return chunksProduced >= chunksToProduce;\n        }\n\n        @Override\n        public void close() {\n            closed = true;\n        }\n\n        @Override\n        public ByteBuf readChunk(ChannelHandlerContext ctx) {\n            return readChunk(ctx.alloc());\n        }\n\n        @Override\n        public ByteBuf readChunk(ByteBufAllocator allocator) {\n            ByteBuf buf = allocator.buffer();\n            buf.writeInt(chunksProduced);\n            chunksProduced++;\n            return buf;\n        }\n\n        @Override\n        public long length() {\n            return chunksToProduce;\n        }\n\n        @Override\n        public long progress() {\n            return chunksProduced;\n        }\n\n        boolean isClosed() {\n            return closed;\n        }\n    }\n\n    private static final class ThrowingChunkedInput implements ChunkedInput<ByteBuf> {\n        private final Exception error;\n\n        private volatile boolean closed;\n\n        ThrowingChunkedInput(Exception error) {\n            this.error = error;\n        }\n\n        @Override\n        public boolean isEndOfInput() {\n            return false;\n        }\n\n        @Override\n        public void close() {\n            closed = true;\n        }\n\n        @Override\n        public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {\n            return readChunk(ctx.alloc());\n        }\n\n        @Override\n        public ByteBuf readChunk(ByteBufAllocator allocator) throws Exception {\n            throw error;\n        }\n\n        @Override\n        public long length() {\n            return -1;\n        }\n\n        @Override\n        public long progress() {\n            return -1;\n        }\n\n        boolean isClosed() {\n            return closed;\n        }\n    }\n}\n", "/*\n * Copyright 2020 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License, version\n * 2.0 (the \"License\"); you may not use this file except in compliance with the\n * License. You may obtain a copy of the License at:\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage io.netty.handler.traffic;\n\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.DefaultFileRegion;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.LineBasedFrameDecoder;\nimport io.netty.util.CharsetUtil;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.net.SocketAddress;\nimport java.nio.charset.Charset;\nimport java.util.Random;\nimport java.util.concurrent.CountDownLatch;\n\nimport static org.junit.Assert.assertTrue;\n\npublic class FileRegionThrottleTest {\n    private static final byte[] BYTES = new byte[64 * 1024 * 4];\n    private static final long WRITE_LIMIT = 64 * 1024;\n    private static File tmp;\n    private EventLoopGroup group;\n\n    @BeforeClass\n    public static void beforeClass() throws IOException {\n        final Random r = new Random();\n        for (int i = 0; i < BYTES.length; i++) {\n            BYTES[i] = (byte) r.nextInt(255);\n        }\n\n        tmp = File.createTempFile(\"netty-traffic\", \".tmp\");\n        tmp.deleteOnExit();\n        FileOutputStream out = null;\n        try {\n            out = new FileOutputStream(tmp);\n            out.write(BYTES);\n            out.flush();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            if (out != null) {\n                try {\n                    out.close();\n                } catch (IOException e) {\n                    // ignore\n                }\n            }\n        }\n    }\n\n    @Before\n    public void setUp() {\n        group = new NioEventLoopGroup();\n    }\n\n    @After\n    public void tearDown() {\n        group.shutdownGracefully();\n    }\n\n    @Test\n    public void testGlobalWriteThrottle() throws Exception {\n        final CountDownLatch latch = new CountDownLatch(1);\n        final GlobalTrafficShapingHandler gtsh = new GlobalTrafficShapingHandler(group, WRITE_LIMIT, 0);\n        ServerBootstrap bs = new ServerBootstrap();\n        bs.group(group).channel(NioServerSocketChannel.class).childHandler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) {\n                ch.pipeline().addLast(new LineBasedFrameDecoder(Integer.MAX_VALUE));\n                ch.pipeline().addLast(new MessageDecoder());\n                ch.pipeline().addLast(gtsh);\n            }\n        });\n        Channel sc = bs.bind(0).sync().channel();\n        Channel cc = clientConnect(sc.localAddress(), new ReadHandler(latch)).channel();\n\n        long start = TrafficCounter.milliSecondFromNano();\n        cc.writeAndFlush(Unpooled.copiedBuffer(\"send-file\\n\", CharsetUtil.US_ASCII)).sync();\n        latch.await();\n        long timeTaken = TrafficCounter.milliSecondFromNano() - start;\n        assertTrue(\"Data streamed faster than expected\", timeTaken > 3000);\n        sc.close().sync();\n        cc.close().sync();\n    }\n\n    private ChannelFuture clientConnect(final SocketAddress server, final ReadHandler readHandler) throws Exception {\n        Bootstrap bc = new Bootstrap();\n        bc.group(group).channel(NioSocketChannel.class).handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) {\n                ch.pipeline().addLast(readHandler);\n            }\n        });\n        return bc.connect(server).sync();\n    }\n\n    private static final class MessageDecoder extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n            if (msg instanceof ByteBuf) {\n                ByteBuf buf = (ByteBuf) msg;\n                String message = buf.toString(Charset.defaultCharset());\n                buf.release();\n                if (message.equals(\"send-file\")) {\n                    RandomAccessFile raf = new RandomAccessFile(tmp, \"r\");\n                    ctx.channel().writeAndFlush(new DefaultFileRegion(raf.getChannel(), 0, tmp.length()));\n                }\n            }\n        }\n    }\n\n    private static final class ReadHandler extends ChannelInboundHandlerAdapter {\n        private long bytesTransferred;\n        private CountDownLatch latch;\n\n        ReadHandler(CountDownLatch latch) {\n            this.latch = latch;\n        }\n\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            if (msg instanceof ByteBuf) {\n                ByteBuf buf = (ByteBuf) msg;\n                bytesTransferred += buf.readableBytes();\n                buf.release();\n                if (bytesTransferred == tmp.length()) {\n                    latch.countDown();\n                }\n            }\n        }\n    }\n}\n", "/*\n * Copyright 2012 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.testsuite.transport.socket;\n\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandler;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.DefaultFileRegion;\nimport io.netty.channel.FileRegion;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.util.internal.PlatformDependent;\nimport org.hamcrest.CoreMatchers;\nimport org.junit.Test;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.channels.WritableByteChannel;\nimport java.util.Random;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.Assert.*;\n\npublic class SocketFileRegionTest extends AbstractSocketTest {\n\n    static final byte[] data = new byte[1048576 * 10];\n\n    static {\n        PlatformDependent.threadLocalRandom().nextBytes(data);\n    }\n\n    @Test\n    public void testFileRegion() throws Throwable {\n        run();\n    }\n\n    @Test\n    public void testCustomFileRegion() throws Throwable {\n        run();\n    }\n\n    @Test\n    public void testFileRegionNotAutoRead() throws Throwable {\n        run();\n    }\n\n    @Test\n    public void testFileRegionVoidPromise() throws Throwable {\n        run();\n    }\n\n    @Test\n    public void testFileRegionVoidPromiseNotAutoRead() throws Throwable {\n        run();\n    }\n\n    @Test\n    public void testFileRegionCountLargerThenFile() throws Throwable {\n        run();\n    }\n\n    public void testFileRegion(ServerBootstrap sb, Bootstrap cb) throws Throwable {\n        testFileRegion0(sb, cb, false, true, true);\n    }\n\n    public void testCustomFileRegion(ServerBootstrap sb, Bootstrap cb) throws Throwable {\n        testFileRegion0(sb, cb, false, true, false);\n    }\n\n    public void testFileRegionVoidPromise(ServerBootstrap sb, Bootstrap cb) throws Throwable {\n        testFileRegion0(sb, cb, true, true, true);\n    }\n\n    public void testFileRegionNotAutoRead(ServerBootstrap sb, Bootstrap cb) throws Throwable {\n        testFileRegion0(sb, cb, false, false, true);\n    }\n\n    public void testFileRegionVoidPromiseNotAutoRead(ServerBootstrap sb, Bootstrap cb) throws Throwable {\n        testFileRegion0(sb, cb, true, false, true);\n    }\n\n    public void testFileRegionCountLargerThenFile(ServerBootstrap sb, Bootstrap cb) throws Throwable {\n        File file = File.createTempFile(\"netty-\", \".tmp\");\n        file.deleteOnExit();\n\n        final FileOutputStream out = new FileOutputStream(file);\n        out.write(data);\n        out.close();\n\n        sb.childHandler(new SimpleChannelInboundHandler<ByteBuf>() {\n            @Override\n            protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) {\n                // Just drop the message.\n            }\n        });\n        cb.handler(new ChannelInboundHandlerAdapter());\n\n        Channel sc = sb.bind().sync().channel();\n        Channel cc = cb.connect(sc.localAddress()).sync().channel();\n\n        // Request file region which is bigger then the underlying file.\n        FileRegion region = new DefaultFileRegion(\n                new RandomAccessFile(file, \"r\").getChannel(), 0, data.length + 1024);\n\n        assertThat(cc.writeAndFlush(region).await().cause(), CoreMatchers.<Throwable>instanceOf(IOException.class));\n        cc.close().sync();\n        sc.close().sync();\n    }\n\n    private static void testFileRegion0(\n            ServerBootstrap sb, Bootstrap cb, boolean voidPromise, final boolean autoRead, boolean defaultFileRegion)\n            throws Throwable {\n        sb.childOption(ChannelOption.AUTO_READ, autoRead);\n        cb.option(ChannelOption.AUTO_READ, autoRead);\n\n        final int bufferSize = 1024;\n        final File file = File.createTempFile(\"netty-\", \".tmp\");\n        file.deleteOnExit();\n\n        final FileOutputStream out = new FileOutputStream(file);\n        final Random random = PlatformDependent.threadLocalRandom();\n\n        // Prepend random data which will not be transferred, so that we can test non-zero start offset\n        final int startOffset = random.nextInt(8192);\n        for (int i = 0; i < startOffset; i ++) {\n            out.write(random.nextInt());\n        }\n\n        // .. and here comes the real data to transfer.\n        out.write(data, bufferSize, data.length - bufferSize);\n\n        // .. and then some extra data which is not supposed to be transferred.\n        for (int i = random.nextInt(8192); i > 0; i --) {\n            out.write(random.nextInt());\n        }\n\n        out.close();\n\n        ChannelInboundHandler ch = new SimpleChannelInboundHandler<Object>() {\n            @Override\n            public void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n            }\n\n            @Override\n            public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n                if (!autoRead) {\n                    ctx.read();\n                }\n            }\n\n            @Override\n            public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n                ctx.close();\n            }\n        };\n        TestHandler sh = new TestHandler(autoRead);\n\n        sb.childHandler(sh);\n        cb.handler(ch);\n\n        Channel sc = sb.bind().sync().channel();\n\n        Channel cc = cb.connect(sc.localAddress()).sync().channel();\n        FileRegion region = new DefaultFileRegion(\n                new RandomAccessFile(file, \"r\").getChannel(), startOffset, data.length - bufferSize);\n        FileRegion emptyRegion = new DefaultFileRegion(new RandomAccessFile(file, \"r\").getChannel(), 0, 0);\n\n        if (!defaultFileRegion) {\n            region = new FileRegionWrapper(region);\n            emptyRegion = new FileRegionWrapper(emptyRegion);\n        }\n        // Do write ByteBuf and then FileRegion to ensure that mixed writes work\n        // Also, write an empty FileRegion to test if writing an empty FileRegion does not cause any issues.\n        //\n        // See https://github.com/netty/netty/issues/2769\n        //     https://github.com/netty/netty/issues/2964\n        if (voidPromise) {\n            assertEquals(cc.voidPromise(), cc.write(Unpooled.wrappedBuffer(data, 0, bufferSize), cc.voidPromise()));\n            assertEquals(cc.voidPromise(), cc.write(emptyRegion, cc.voidPromise()));\n            assertEquals(cc.voidPromise(), cc.writeAndFlush(region, cc.voidPromise()));\n        } else {\n            assertNotEquals(cc.voidPromise(), cc.write(Unpooled.wrappedBuffer(data, 0, bufferSize)));\n            assertNotEquals(cc.voidPromise(), cc.write(emptyRegion));\n            assertNotEquals(cc.voidPromise(), cc.writeAndFlush(region));\n        }\n\n        while (sh.counter < data.length) {\n            if (sh.exception.get() != null) {\n                break;\n            }\n\n            try {\n                Thread.sleep(50);\n            } catch (InterruptedException e) {\n                // Ignore.\n            }\n        }\n\n        sh.channel.close().sync();\n        cc.close().sync();\n        sc.close().sync();\n\n        if (sh.exception.get() != null && !(sh.exception.get() instanceof IOException)) {\n            throw sh.exception.get();\n        }\n\n        if (sh.exception.get() != null) {\n            throw sh.exception.get();\n        }\n\n        // Make sure we did not receive more than we expected.\n        assertThat(sh.counter, is(data.length));\n    }\n\n    private static class TestHandler extends SimpleChannelInboundHandler<ByteBuf> {\n        private final boolean autoRead;\n        volatile Channel channel;\n        final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();\n        volatile int counter;\n\n        TestHandler(boolean autoRead) {\n            this.autoRead = autoRead;\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx)\n                throws Exception {\n            channel = ctx.channel();\n            if (!autoRead) {\n                ctx.read();\n            }\n        }\n\n        @Override\n        public void channelRead0(ChannelHandlerContext ctx, ByteBuf in) throws Exception {\n            byte[] actual = new byte[in.readableBytes()];\n            in.readBytes(actual);\n\n            int lastIdx = counter;\n            for (int i = 0; i < actual.length; i ++) {\n                assertEquals(data[i + lastIdx], actual[i]);\n            }\n            counter += actual.length;\n        }\n\n        @Override\n        public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n            if (!autoRead) {\n                ctx.read();\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx,\n                Throwable cause) throws Exception {\n            if (exception.compareAndSet(null, cause)) {\n                ctx.close();\n            }\n        }\n    }\n\n    private static final class FileRegionWrapper implements FileRegion {\n        private final FileRegion region;\n\n        FileRegionWrapper(FileRegion region) {\n            this.region = region;\n        }\n\n        @Override\n        public int refCnt() {\n            return region.refCnt();\n        }\n\n        @Override\n        public long position() {\n            return region.position();\n        }\n\n        @Override\n        @Deprecated\n        public long transfered() {\n            return region.transferred();\n        }\n\n        @Override\n        public boolean release() {\n            return region.release();\n        }\n\n        @Override\n        public long transferred() {\n            return region.transferred();\n        }\n\n        @Override\n        public long count() {\n            return region.count();\n        }\n\n        @Override\n        public boolean release(int decrement) {\n            return region.release(decrement);\n        }\n\n        @Override\n        public long transferTo(WritableByteChannel target, long position) throws IOException {\n            return region.transferTo(target, position);\n        }\n\n        @Override\n        public FileRegion retain() {\n            region.retain();\n            return this;\n        }\n\n        @Override\n        public FileRegion retain(int increment) {\n            region.retain(increment);\n            return this;\n        }\n\n        @Override\n        public FileRegion touch() {\n            region.touch();\n            return this;\n        }\n\n        @Override\n        public FileRegion touch(Object hint) {\n            region.touch(hint);\n            return this;\n        }\n    }\n}\n", "/*\n * Copyright 2015 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.channel.epoll;\n\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.unix.FileDescriptor;\nimport io.netty.util.NetUtil;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class EpollSpliceTest {\n\n    private static final int SPLICE_LEN = 32 * 1024;\n    private static final Random random = new Random();\n    private static final byte[] data = new byte[1048576];\n\n    static {\n        random.nextBytes(data);\n    }\n\n    @Test\n    public void spliceToSocket() throws Throwable {\n        final EchoHandler sh = new EchoHandler();\n        final EchoHandler ch = new EchoHandler();\n\n        EventLoopGroup group = new EpollEventLoopGroup(1);\n        ServerBootstrap bs = new ServerBootstrap();\n        bs.channel(EpollServerSocketChannel.class);\n        bs.group(group).childHandler(sh);\n        final Channel sc = bs.bind(NetUtil.LOCALHOST, 0).syncUninterruptibly().channel();\n\n        ServerBootstrap bs2 = new ServerBootstrap();\n        bs2.channel(EpollServerSocketChannel.class);\n        bs2.childOption(EpollChannelOption.EPOLL_MODE, EpollMode.LEVEL_TRIGGERED);\n        bs2.group(group).childHandler(new ChannelInboundHandlerAdapter() {\n            @Override\n            public void channelActive(final ChannelHandlerContext ctx) throws Exception {\n                ctx.channel().config().setAutoRead(false);\n                Bootstrap bs = new Bootstrap();\n                bs.option(EpollChannelOption.EPOLL_MODE, EpollMode.LEVEL_TRIGGERED);\n\n                bs.channel(EpollSocketChannel.class);\n                bs.group(ctx.channel().eventLoop()).handler(new ChannelInboundHandlerAdapter() {\n                    @Override\n                    public void channelActive(ChannelHandlerContext context) throws Exception {\n                        final EpollSocketChannel ch = (EpollSocketChannel) ctx.channel();\n                        final EpollSocketChannel ch2 = (EpollSocketChannel) context.channel();\n                        // We are splicing two channels together, at this point we have a tcp proxy which handles all\n                        // the data transfer only in kernel space!\n\n                        // Integer.MAX_VALUE will splice infinitly.\n                        ch.spliceTo(ch2, Integer.MAX_VALUE).addListener(new ChannelFutureListener() {\n                            @Override\n                            public void operationComplete(ChannelFuture future) throws Exception {\n                                if (!future.isSuccess()) {\n                                    future.channel().close();\n                                }\n                            }\n                        });\n                        // Trigger multiple splices to see if partial splicing works as well.\n                        ch2.spliceTo(ch, SPLICE_LEN).addListener(new ChannelFutureListener() {\n                            @Override\n                            public void operationComplete(ChannelFuture future) throws Exception {\n                                if (!future.isSuccess()) {\n                                    future.channel().close();\n                                } else {\n                                    ch2.spliceTo(ch, SPLICE_LEN).addListener(this);\n                                }\n                            }\n                        });\n                        ctx.channel().config().setAutoRead(true);\n                    }\n\n                    @Override\n                    public void channelInactive(ChannelHandlerContext context) throws Exception {\n                        context.close();\n                    }\n                });\n                bs.connect(sc.localAddress()).addListener(new ChannelFutureListener() {\n                    @Override\n                    public void operationComplete(ChannelFuture future) throws Exception {\n                        if (!future.isSuccess()) {\n                            ctx.close();\n                        } else {\n                            future.channel().closeFuture().addListener(new ChannelFutureListener() {\n                                @Override\n                                public void operationComplete(ChannelFuture future) throws Exception {\n                                    ctx.close();\n                                }\n                            });\n                        }\n                    }\n                });\n            }\n        });\n        Channel pc = bs2.bind(NetUtil.LOCALHOST, 0).syncUninterruptibly().channel();\n\n        Bootstrap cb = new Bootstrap();\n        cb.group(group);\n        cb.channel(EpollSocketChannel.class);\n        cb.handler(ch);\n        Channel cc = cb.connect(pc.localAddress()).syncUninterruptibly().channel();\n\n        for (int i = 0; i < data.length;) {\n            int length = Math.min(random.nextInt(1024 * 64), data.length - i);\n            ByteBuf buf = Unpooled.wrappedBuffer(data, i, length);\n            cc.writeAndFlush(buf);\n            i += length;\n        }\n\n        while (ch.counter < data.length) {\n            if (sh.exception.get() != null) {\n                break;\n            }\n            if (ch.exception.get() != null) {\n                break;\n            }\n\n            try {\n                Thread.sleep(50);\n            } catch (InterruptedException e) {\n                // Ignore.\n            }\n        }\n\n        while (sh.counter < data.length) {\n            if (sh.exception.get() != null) {\n                break;\n            }\n            if (ch.exception.get() != null) {\n                break;\n            }\n\n            try {\n                Thread.sleep(50);\n            } catch (InterruptedException e) {\n                // Ignore.\n            }\n        }\n\n        sh.channel.close().sync();\n        ch.channel.close().sync();\n        sc.close().sync();\n        pc.close().sync();\n        group.shutdownGracefully();\n\n        if (sh.exception.get() != null && !(sh.exception.get() instanceof IOException)) {\n            throw sh.exception.get();\n        }\n        if (ch.exception.get() != null && !(ch.exception.get() instanceof IOException)) {\n            throw ch.exception.get();\n        }\n        if (sh.exception.get() != null) {\n            throw sh.exception.get();\n        }\n        if (ch.exception.get() != null) {\n            throw ch.exception.get();\n        }\n    }\n\n    @Test(timeout = 10000)\n    public void spliceToFile() throws Throwable {\n        EventLoopGroup group = new EpollEventLoopGroup(1);\n        File file = File.createTempFile(\"netty-splice\", null);\n        file.deleteOnExit();\n\n        SpliceHandler sh = new SpliceHandler(file);\n        ServerBootstrap bs = new ServerBootstrap();\n        bs.channel(EpollServerSocketChannel.class);\n        bs.group(group).childHandler(sh);\n        bs.childOption(EpollChannelOption.EPOLL_MODE, EpollMode.LEVEL_TRIGGERED);\n        Channel sc = bs.bind(NetUtil.LOCALHOST, 0).syncUninterruptibly().channel();\n\n        Bootstrap cb = new Bootstrap();\n        cb.group(group);\n        cb.channel(EpollSocketChannel.class);\n        cb.handler(new ChannelInboundHandlerAdapter());\n        Channel cc = cb.connect(sc.localAddress()).syncUninterruptibly().channel();\n\n        for (int i = 0; i < data.length;) {\n            int length = Math.min(random.nextInt(1024 * 64), data.length - i);\n            ByteBuf buf = Unpooled.wrappedBuffer(data, i, length);\n            cc.writeAndFlush(buf);\n            i += length;\n        }\n\n        while (sh.future2 == null || !sh.future2.isDone() || !sh.future.isDone()) {\n            if (sh.exception.get() != null) {\n                break;\n            }\n            try {\n                Thread.sleep(50);\n            } catch (InterruptedException e) {\n                // Ignore.\n            }\n        }\n\n        sc.close().sync();\n        cc.close().sync();\n\n        if (sh.exception.get() != null && !(sh.exception.get() instanceof IOException)) {\n            throw sh.exception.get();\n        }\n\n        byte[] written = new byte[data.length];\n        FileInputStream in = new FileInputStream(file);\n\n        try {\n            Assert.assertEquals(written.length, in.read(written));\n            Assert.assertArrayEquals(data, written);\n        } finally {\n            in.close();\n            group.shutdownGracefully();\n        }\n    }\n\n    private static class EchoHandler extends SimpleChannelInboundHandler<ByteBuf> {\n        volatile Channel channel;\n        final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();\n        volatile int counter;\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx)\n                throws Exception {\n            channel = ctx.channel();\n        }\n\n        @Override\n        public void channelRead0(ChannelHandlerContext ctx, ByteBuf in) throws Exception {\n            byte[] actual = new byte[in.readableBytes()];\n            in.readBytes(actual);\n\n            int lastIdx = counter;\n            for (int i = 0; i < actual.length; i ++) {\n                assertEquals(data[i + lastIdx], actual[i]);\n            }\n\n            if (channel.parent() != null) {\n                channel.write(Unpooled.wrappedBuffer(actual));\n            }\n\n            counter += actual.length;\n        }\n\n        @Override\n        public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n            ctx.flush();\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx,\n                                    Throwable cause) throws Exception {\n            if (exception.compareAndSet(null, cause)) {\n                cause.printStackTrace();\n                ctx.close();\n            }\n        }\n    }\n\n    private static class SpliceHandler extends ChannelInboundHandlerAdapter {\n        private final File file;\n\n        volatile ChannelFuture future;\n        volatile ChannelFuture future2;\n        final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();\n\n        SpliceHandler(File file) {\n            this.file = file;\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n            final EpollSocketChannel ch = (EpollSocketChannel) ctx.channel();\n            final FileDescriptor fd = FileDescriptor.from(file);\n\n            // splice two halves separately to test starting offset\n            future = ch.spliceTo(fd, 0, data.length / 2);\n            future2 = ch.spliceTo(fd, data.length / 2, data.length / 2);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx,\n                                    Throwable cause) throws Exception {\n            if (exception.compareAndSet(null, cause)) {\n                cause.printStackTrace();\n                ctx.close();\n            }\n        }\n    }\n}\n", "/*\n * Copyright 2016 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.channel.unix.tests;\n\nimport io.netty.channel.unix.DomainSocketAddress;\nimport io.netty.channel.unix.Socket;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic final class UnixTestUtils {\n    public static DomainSocketAddress newSocketAddress() {\n        try {\n            File file;\n            do {\n                file = File.createTempFile(\"NETTY\", \"UDS\");\n                if (!file.delete()) {\n                    throw new IOException(\"failed to delete: \" + file);\n                }\n            } while (file.getAbsolutePath().length() > 128);\n            return new DomainSocketAddress(file);\n        } catch (IOException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    private UnixTestUtils() { }\n}\n", "/*\n * Copyright 2019 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.channel;\n\nimport io.netty.util.internal.PlatformDependent;\nimport org.junit.Test;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.channels.Channels;\nimport java.nio.channels.WritableByteChannel;\n\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.fail;\n\npublic class DefaultFileRegionTest {\n\n    private static final byte[] data = new byte[1048576 * 10];\n\n    static {\n        PlatformDependent.threadLocalRandom().nextBytes(data);\n    }\n\n    private static File newFile() throws IOException {\n        File file = File.createTempFile(\"netty-\", \".tmp\");\n        file.deleteOnExit();\n\n        final FileOutputStream out = new FileOutputStream(file);\n        out.write(data);\n        out.close();\n        return file;\n    }\n\n    @Test\n    public void testCreateFromFile() throws IOException  {\n        File file = newFile();\n        try {\n            testFileRegion(new DefaultFileRegion(file, 0, data.length));\n        } finally {\n            file.delete();\n        }\n    }\n\n    @Test\n    public void testCreateFromFileChannel() throws IOException  {\n        File file = newFile();\n        RandomAccessFile randomAccessFile = new RandomAccessFile(file, \"r\");\n        try {\n            testFileRegion(new DefaultFileRegion(randomAccessFile.getChannel(), 0, data.length));\n        } finally {\n            randomAccessFile.close();\n            file.delete();\n        }\n    }\n\n    private static void testFileRegion(FileRegion region) throws IOException  {\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        WritableByteChannel channel = Channels.newChannel(outputStream);\n\n        try {\n            assertEquals(data.length, region.count());\n            assertEquals(0, region.transferred());\n            assertEquals(data.length, region.transferTo(channel, 0));\n            assertEquals(data.length, region.count());\n            assertEquals(data.length, region.transferred());\n            assertArrayEquals(data, outputStream.toByteArray());\n        } finally {\n            channel.close();\n        }\n    }\n\n    @Test\n    public void testTruncated() throws IOException  {\n        File file = newFile();\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        WritableByteChannel channel = Channels.newChannel(outputStream);\n        RandomAccessFile randomAccessFile = new RandomAccessFile(file, \"rw\");\n\n        try {\n            FileRegion region = new DefaultFileRegion(randomAccessFile.getChannel(), 0, data.length);\n\n            randomAccessFile.getChannel().truncate(data.length - 1024);\n\n            assertEquals(data.length, region.count());\n            assertEquals(0, region.transferred());\n\n            assertEquals(data.length - 1024, region.transferTo(channel, 0));\n            assertEquals(data.length, region.count());\n            assertEquals(data.length - 1024, region.transferred());\n            try {\n                region.transferTo(channel, data.length - 1024);\n                fail();\n            } catch (IOException expected) {\n                // expected\n            }\n        } finally {\n            channel.close();\n\n            randomAccessFile.close();\n            file.delete();\n        }\n    }\n}\n"], "fixing_code": ["/*\n * Copyright 2012 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.buffer;\n\nimport io.netty.util.ByteProcessor;\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.IllegalReferenceCountException;\nimport io.netty.util.internal.PlatformDependent;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.nio.CharBuffer;\nimport java.nio.ReadOnlyBufferException;\nimport java.nio.channels.Channels;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.GatheringByteChannel;\nimport java.nio.channels.ScatteringByteChannel;\nimport java.nio.channels.WritableByteChannel;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.CyclicBarrier;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport static io.netty.buffer.Unpooled.LITTLE_ENDIAN;\nimport static io.netty.buffer.Unpooled.buffer;\nimport static io.netty.buffer.Unpooled.copiedBuffer;\nimport static io.netty.buffer.Unpooled.directBuffer;\nimport static io.netty.buffer.Unpooled.unreleasableBuffer;\nimport static io.netty.buffer.Unpooled.wrappedBuffer;\nimport static io.netty.util.internal.EmptyArrays.EMPTY_BYTES;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertSame;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\nimport static org.junit.Assume.assumeFalse;\nimport static org.junit.Assume.assumeTrue;\n\n/**\n * An abstract test class for channel buffers\n */\npublic abstract class AbstractByteBufTest {\n\n    private static final int CAPACITY = 4096; // Must be even\n    private static final int BLOCK_SIZE = 128;\n    private static final int JAVA_BYTEBUFFER_CONSISTENCY_ITERATIONS = 100;\n\n    private long seed;\n    private Random random;\n    private ByteBuf buffer;\n\n    protected final ByteBuf newBuffer(int capacity) {\n        return newBuffer(capacity, Integer.MAX_VALUE);\n    }\n\n    protected abstract ByteBuf newBuffer(int capacity, int maxCapacity);\n\n    protected boolean discardReadBytesDoesNotMoveWritableBytes() {\n        return true;\n    }\n\n    @Before\n    public void init() {\n        buffer = newBuffer(CAPACITY);\n        seed = System.currentTimeMillis();\n        random = new Random(seed);\n    }\n\n    @After\n    public void dispose() {\n        if (buffer != null) {\n            assertThat(buffer.release(), is(true));\n            assertThat(buffer.refCnt(), is(0));\n\n            try {\n                buffer.release();\n            } catch (Exception e) {\n                // Ignore.\n            }\n            buffer = null;\n        }\n    }\n\n    @Test\n    public void comparableInterfaceNotViolated() {\n        assumeFalse(buffer.isReadOnly());\n        buffer.writerIndex(buffer.readerIndex());\n        assumeTrue(buffer.writableBytes() >= 4);\n\n        buffer.writeLong(0);\n        ByteBuf buffer2 = newBuffer(CAPACITY);\n        assumeFalse(buffer2.isReadOnly());\n        buffer2.writerIndex(buffer2.readerIndex());\n        // Write an unsigned integer that will cause buffer.getUnsignedInt() - buffer2.getUnsignedInt() to underflow the\n        // int type and wrap around on the negative side.\n        buffer2.writeLong(0xF0000000L);\n        assertTrue(buffer.compareTo(buffer2) < 0);\n        assertTrue(buffer2.compareTo(buffer) > 0);\n        buffer2.release();\n    }\n\n    @Test\n    public void initialState() {\n        assertEquals(CAPACITY, buffer.capacity());\n        assertEquals(0, buffer.readerIndex());\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void readerIndexBoundaryCheck1() {\n        try {\n            buffer.writerIndex(0);\n        } catch (IndexOutOfBoundsException e) {\n            fail();\n        }\n        buffer.readerIndex(-1);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void readerIndexBoundaryCheck2() {\n        try {\n            buffer.writerIndex(buffer.capacity());\n        } catch (IndexOutOfBoundsException e) {\n            fail();\n        }\n        buffer.readerIndex(buffer.capacity() + 1);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void readerIndexBoundaryCheck3() {\n        try {\n            buffer.writerIndex(CAPACITY / 2);\n        } catch (IndexOutOfBoundsException e) {\n            fail();\n        }\n        buffer.readerIndex(CAPACITY * 3 / 2);\n    }\n\n    @Test\n    public void readerIndexBoundaryCheck4() {\n        buffer.writerIndex(0);\n        buffer.readerIndex(0);\n        buffer.writerIndex(buffer.capacity());\n        buffer.readerIndex(buffer.capacity());\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void writerIndexBoundaryCheck1() {\n        buffer.writerIndex(-1);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void writerIndexBoundaryCheck2() {\n        try {\n            buffer.writerIndex(CAPACITY);\n            buffer.readerIndex(CAPACITY);\n        } catch (IndexOutOfBoundsException e) {\n            fail();\n        }\n        buffer.writerIndex(buffer.capacity() + 1);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void writerIndexBoundaryCheck3() {\n        try {\n            buffer.writerIndex(CAPACITY);\n            buffer.readerIndex(CAPACITY / 2);\n        } catch (IndexOutOfBoundsException e) {\n            fail();\n        }\n        buffer.writerIndex(CAPACITY / 4);\n    }\n\n    @Test\n    public void writerIndexBoundaryCheck4() {\n        buffer.writerIndex(0);\n        buffer.readerIndex(0);\n        buffer.writerIndex(CAPACITY);\n\n        buffer.writeBytes(ByteBuffer.wrap(EMPTY_BYTES));\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getBooleanBoundaryCheck1() {\n        buffer.getBoolean(-1);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getBooleanBoundaryCheck2() {\n        buffer.getBoolean(buffer.capacity());\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getByteBoundaryCheck1() {\n        buffer.getByte(-1);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getByteBoundaryCheck2() {\n        buffer.getByte(buffer.capacity());\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getShortBoundaryCheck1() {\n        buffer.getShort(-1);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getShortBoundaryCheck2() {\n        buffer.getShort(buffer.capacity() - 1);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getMediumBoundaryCheck1() {\n        buffer.getMedium(-1);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getMediumBoundaryCheck2() {\n        buffer.getMedium(buffer.capacity() - 2);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getIntBoundaryCheck1() {\n        buffer.getInt(-1);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getIntBoundaryCheck2() {\n        buffer.getInt(buffer.capacity() - 3);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getLongBoundaryCheck1() {\n        buffer.getLong(-1);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getLongBoundaryCheck2() {\n        buffer.getLong(buffer.capacity() - 7);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getByteArrayBoundaryCheck1() {\n        buffer.getBytes(-1, EMPTY_BYTES);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getByteArrayBoundaryCheck2() {\n        buffer.getBytes(-1, EMPTY_BYTES, 0, 0);\n    }\n\n    @Test\n    public void getByteArrayBoundaryCheck3() {\n        byte[] dst = new byte[4];\n        buffer.setInt(0, 0x01020304);\n        try {\n            buffer.getBytes(0, dst, -1, 4);\n            fail();\n        } catch (IndexOutOfBoundsException e) {\n            // Success\n        }\n\n        // No partial copy is expected.\n        assertEquals(0, dst[0]);\n        assertEquals(0, dst[1]);\n        assertEquals(0, dst[2]);\n        assertEquals(0, dst[3]);\n    }\n\n    @Test\n    public void getByteArrayBoundaryCheck4() {\n        byte[] dst = new byte[4];\n        buffer.setInt(0, 0x01020304);\n        try {\n            buffer.getBytes(0, dst, 1, 4);\n            fail();\n        } catch (IndexOutOfBoundsException e) {\n            // Success\n        }\n\n        // No partial copy is expected.\n        assertEquals(0, dst[0]);\n        assertEquals(0, dst[1]);\n        assertEquals(0, dst[2]);\n        assertEquals(0, dst[3]);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getByteBufferBoundaryCheck() {\n        buffer.getBytes(-1, ByteBuffer.allocate(0));\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void copyBoundaryCheck1() {\n        buffer.copy(-1, 0);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void copyBoundaryCheck2() {\n        buffer.copy(0, buffer.capacity() + 1);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void copyBoundaryCheck3() {\n        buffer.copy(buffer.capacity() + 1, 0);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void copyBoundaryCheck4() {\n        buffer.copy(buffer.capacity(), 1);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void setIndexBoundaryCheck1() {\n        buffer.setIndex(-1, CAPACITY);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void setIndexBoundaryCheck2() {\n        buffer.setIndex(CAPACITY / 2, CAPACITY / 4);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void setIndexBoundaryCheck3() {\n        buffer.setIndex(0, CAPACITY + 1);\n    }\n\n    @Test\n    public void getByteBufferState() {\n        ByteBuffer dst = ByteBuffer.allocate(4);\n        dst.position(1);\n        dst.limit(3);\n\n        buffer.setByte(0, (byte) 1);\n        buffer.setByte(1, (byte) 2);\n        buffer.setByte(2, (byte) 3);\n        buffer.setByte(3, (byte) 4);\n        buffer.getBytes(1, dst);\n\n        assertEquals(3, dst.position());\n        assertEquals(3, dst.limit());\n\n        dst.clear();\n        assertEquals(0, dst.get(0));\n        assertEquals(2, dst.get(1));\n        assertEquals(3, dst.get(2));\n        assertEquals(0, dst.get(3));\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void getDirectByteBufferBoundaryCheck() {\n        buffer.getBytes(-1, ByteBuffer.allocateDirect(0));\n    }\n\n    @Test\n    public void getDirectByteBufferState() {\n        ByteBuffer dst = ByteBuffer.allocateDirect(4);\n        dst.position(1);\n        dst.limit(3);\n\n        buffer.setByte(0, (byte) 1);\n        buffer.setByte(1, (byte) 2);\n        buffer.setByte(2, (byte) 3);\n        buffer.setByte(3, (byte) 4);\n        buffer.getBytes(1, dst);\n\n        assertEquals(3, dst.position());\n        assertEquals(3, dst.limit());\n\n        dst.clear();\n        assertEquals(0, dst.get(0));\n        assertEquals(2, dst.get(1));\n        assertEquals(3, dst.get(2));\n        assertEquals(0, dst.get(3));\n    }\n\n    @Test\n    public void testRandomByteAccess() {\n        for (int i = 0; i < buffer.capacity(); i ++) {\n            byte value = (byte) random.nextInt();\n            buffer.setByte(i, value);\n        }\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity(); i ++) {\n            byte value = (byte) random.nextInt();\n            assertEquals(value, buffer.getByte(i));\n        }\n    }\n\n    @Test\n    public void testRandomUnsignedByteAccess() {\n        for (int i = 0; i < buffer.capacity(); i ++) {\n            byte value = (byte) random.nextInt();\n            buffer.setByte(i, value);\n        }\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity(); i ++) {\n            int value = random.nextInt() & 0xFF;\n            assertEquals(value, buffer.getUnsignedByte(i));\n        }\n    }\n\n    @Test\n    public void testRandomShortAccess() {\n        testRandomShortAccess(true);\n    }\n    @Test\n    public void testRandomShortLEAccess() {\n        testRandomShortAccess(false);\n    }\n\n    private void testRandomShortAccess(boolean testBigEndian) {\n        for (int i = 0; i < buffer.capacity() - 1; i += 2) {\n            short value = (short) random.nextInt();\n            if (testBigEndian) {\n                buffer.setShort(i, value);\n            } else {\n                buffer.setShortLE(i, value);\n            }\n        }\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity() - 1; i += 2) {\n            short value = (short) random.nextInt();\n            if (testBigEndian) {\n                assertEquals(value, buffer.getShort(i));\n            } else {\n                assertEquals(value, buffer.getShortLE(i));\n            }\n        }\n    }\n\n    @Test\n    public void testShortConsistentWithByteBuffer() {\n        testShortConsistentWithByteBuffer(true, true);\n        testShortConsistentWithByteBuffer(true, false);\n        testShortConsistentWithByteBuffer(false, true);\n        testShortConsistentWithByteBuffer(false, false);\n    }\n\n    private void testShortConsistentWithByteBuffer(boolean direct, boolean testBigEndian) {\n        for (int i = 0; i < JAVA_BYTEBUFFER_CONSISTENCY_ITERATIONS; ++i) {\n            ByteBuffer javaBuffer = direct ? ByteBuffer.allocateDirect(buffer.capacity())\n                                           : ByteBuffer.allocate(buffer.capacity());\n            if (!testBigEndian) {\n                javaBuffer = javaBuffer.order(ByteOrder.LITTLE_ENDIAN);\n            }\n\n            short expected = (short) (random.nextInt() & 0xFFFF);\n            javaBuffer.putShort(expected);\n\n            final int bufferIndex = buffer.capacity() - 2;\n            if (testBigEndian) {\n                buffer.setShort(bufferIndex, expected);\n            } else {\n                buffer.setShortLE(bufferIndex, expected);\n            }\n            javaBuffer.flip();\n\n            short javaActual = javaBuffer.getShort();\n            assertEquals(expected, javaActual);\n            assertEquals(javaActual, testBigEndian ? buffer.getShort(bufferIndex)\n                                                   : buffer.getShortLE(bufferIndex));\n        }\n    }\n\n    @Test\n    public void testRandomUnsignedShortAccess() {\n        testRandomUnsignedShortAccess(true);\n    }\n\n    @Test\n    public void testRandomUnsignedShortLEAccess() {\n        testRandomUnsignedShortAccess(false);\n    }\n\n    private void testRandomUnsignedShortAccess(boolean testBigEndian) {\n        for (int i = 0; i < buffer.capacity() - 1; i += 2) {\n            short value = (short) random.nextInt();\n            if (testBigEndian) {\n                buffer.setShort(i, value);\n            } else {\n                buffer.setShortLE(i, value);\n            }\n        }\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity() - 1; i += 2) {\n            int value = random.nextInt() & 0xFFFF;\n            if (testBigEndian) {\n                assertEquals(value, buffer.getUnsignedShort(i));\n            } else {\n                assertEquals(value, buffer.getUnsignedShortLE(i));\n            }\n        }\n    }\n\n    @Test\n    public void testRandomMediumAccess() {\n        testRandomMediumAccess(true);\n    }\n\n    @Test\n    public void testRandomMediumLEAccess() {\n        testRandomMediumAccess(false);\n    }\n\n    private void testRandomMediumAccess(boolean testBigEndian) {\n        for (int i = 0; i < buffer.capacity() - 2; i += 3) {\n            int value = random.nextInt();\n            if (testBigEndian) {\n                buffer.setMedium(i, value);\n            } else {\n                buffer.setMediumLE(i, value);\n            }\n        }\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity() - 2; i += 3) {\n            int value = random.nextInt() << 8 >> 8;\n            if (testBigEndian) {\n                assertEquals(value, buffer.getMedium(i));\n            } else {\n                assertEquals(value, buffer.getMediumLE(i));\n            }\n        }\n    }\n\n    @Test\n    public void testRandomUnsignedMediumAccess() {\n        testRandomUnsignedMediumAccess(true);\n    }\n\n    @Test\n    public void testRandomUnsignedMediumLEAccess() {\n        testRandomUnsignedMediumAccess(false);\n    }\n\n    private void testRandomUnsignedMediumAccess(boolean testBigEndian) {\n        for (int i = 0; i < buffer.capacity() - 2; i += 3) {\n            int value = random.nextInt();\n            if (testBigEndian) {\n                buffer.setMedium(i, value);\n            } else {\n                buffer.setMediumLE(i, value);\n            }\n        }\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity() - 2; i += 3) {\n            int value = random.nextInt() & 0x00FFFFFF;\n            if (testBigEndian) {\n                assertEquals(value, buffer.getUnsignedMedium(i));\n            } else {\n                assertEquals(value, buffer.getUnsignedMediumLE(i));\n            }\n        }\n    }\n\n    @Test\n    public void testMediumConsistentWithByteBuffer() {\n        testMediumConsistentWithByteBuffer(true, true);\n        testMediumConsistentWithByteBuffer(true, false);\n        testMediumConsistentWithByteBuffer(false, true);\n        testMediumConsistentWithByteBuffer(false, false);\n    }\n\n    private void testMediumConsistentWithByteBuffer(boolean direct, boolean testBigEndian) {\n        for (int i = 0; i < JAVA_BYTEBUFFER_CONSISTENCY_ITERATIONS; ++i) {\n            ByteBuffer javaBuffer = direct ? ByteBuffer.allocateDirect(buffer.capacity())\n                                           : ByteBuffer.allocate(buffer.capacity());\n            if (!testBigEndian) {\n                javaBuffer = javaBuffer.order(ByteOrder.LITTLE_ENDIAN);\n            }\n\n            int expected = random.nextInt() & 0x00FFFFFF;\n            javaBuffer.putInt(expected);\n\n            final int bufferIndex = buffer.capacity() - 3;\n            if (testBigEndian) {\n                buffer.setMedium(bufferIndex, expected);\n            } else {\n                buffer.setMediumLE(bufferIndex, expected);\n            }\n            javaBuffer.flip();\n\n            int javaActual = javaBuffer.getInt();\n            assertEquals(expected, javaActual);\n            assertEquals(javaActual, testBigEndian ? buffer.getUnsignedMedium(bufferIndex)\n                                                   : buffer.getUnsignedMediumLE(bufferIndex));\n        }\n    }\n\n    @Test\n    public void testRandomIntAccess() {\n        testRandomIntAccess(true);\n    }\n\n    @Test\n    public void testRandomIntLEAccess() {\n        testRandomIntAccess(false);\n    }\n\n    private void testRandomIntAccess(boolean testBigEndian) {\n        for (int i = 0; i < buffer.capacity() - 3; i += 4) {\n            int value = random.nextInt();\n            if (testBigEndian) {\n                buffer.setInt(i, value);\n            } else {\n                buffer.setIntLE(i, value);\n            }\n        }\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity() - 3; i += 4) {\n            int value = random.nextInt();\n            if (testBigEndian) {\n                assertEquals(value, buffer.getInt(i));\n            } else {\n                assertEquals(value, buffer.getIntLE(i));\n            }\n        }\n    }\n\n    @Test\n    public void testIntConsistentWithByteBuffer() {\n        testIntConsistentWithByteBuffer(true, true);\n        testIntConsistentWithByteBuffer(true, false);\n        testIntConsistentWithByteBuffer(false, true);\n        testIntConsistentWithByteBuffer(false, false);\n    }\n\n    private void testIntConsistentWithByteBuffer(boolean direct, boolean testBigEndian) {\n        for (int i = 0; i < JAVA_BYTEBUFFER_CONSISTENCY_ITERATIONS; ++i) {\n            ByteBuffer javaBuffer = direct ? ByteBuffer.allocateDirect(buffer.capacity())\n                                           : ByteBuffer.allocate(buffer.capacity());\n            if (!testBigEndian) {\n                javaBuffer = javaBuffer.order(ByteOrder.LITTLE_ENDIAN);\n            }\n\n            int expected = random.nextInt();\n            javaBuffer.putInt(expected);\n\n            final int bufferIndex = buffer.capacity() - 4;\n            if (testBigEndian) {\n                buffer.setInt(bufferIndex, expected);\n            } else {\n                buffer.setIntLE(bufferIndex, expected);\n            }\n            javaBuffer.flip();\n\n            int javaActual = javaBuffer.getInt();\n            assertEquals(expected, javaActual);\n            assertEquals(javaActual, testBigEndian ? buffer.getInt(bufferIndex)\n                                                   : buffer.getIntLE(bufferIndex));\n        }\n    }\n\n    @Test\n    public void testRandomUnsignedIntAccess() {\n        testRandomUnsignedIntAccess(true);\n    }\n\n    @Test\n    public void testRandomUnsignedIntLEAccess() {\n        testRandomUnsignedIntAccess(false);\n    }\n\n    private void testRandomUnsignedIntAccess(boolean testBigEndian) {\n        for (int i = 0; i < buffer.capacity() - 3; i += 4) {\n            int value = random.nextInt();\n            if (testBigEndian) {\n                buffer.setInt(i, value);\n            } else {\n                buffer.setIntLE(i, value);\n            }\n        }\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity() - 3; i += 4) {\n            long value = random.nextInt() & 0xFFFFFFFFL;\n            if (testBigEndian) {\n                assertEquals(value, buffer.getUnsignedInt(i));\n            } else {\n                assertEquals(value, buffer.getUnsignedIntLE(i));\n            }\n        }\n    }\n\n    @Test\n    public void testRandomLongAccess() {\n        testRandomLongAccess(true);\n    }\n\n    @Test\n    public void testRandomLongLEAccess() {\n        testRandomLongAccess(false);\n    }\n\n    private void testRandomLongAccess(boolean testBigEndian) {\n        for (int i = 0; i < buffer.capacity() - 7; i += 8) {\n            long value = random.nextLong();\n            if (testBigEndian) {\n                buffer.setLong(i, value);\n            } else {\n                buffer.setLongLE(i, value);\n            }\n        }\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity() - 7; i += 8) {\n            long value = random.nextLong();\n            if (testBigEndian) {\n                assertEquals(value, buffer.getLong(i));\n            } else {\n                assertEquals(value, buffer.getLongLE(i));\n            }\n        }\n    }\n\n    @Test\n    public void testLongConsistentWithByteBuffer() {\n        testLongConsistentWithByteBuffer(true, true);\n        testLongConsistentWithByteBuffer(true, false);\n        testLongConsistentWithByteBuffer(false, true);\n        testLongConsistentWithByteBuffer(false, false);\n    }\n\n    private void testLongConsistentWithByteBuffer(boolean direct, boolean testBigEndian) {\n        for (int i = 0; i < JAVA_BYTEBUFFER_CONSISTENCY_ITERATIONS; ++i) {\n            ByteBuffer javaBuffer = direct ? ByteBuffer.allocateDirect(buffer.capacity())\n                                           : ByteBuffer.allocate(buffer.capacity());\n            if (!testBigEndian) {\n                javaBuffer = javaBuffer.order(ByteOrder.LITTLE_ENDIAN);\n            }\n\n            long expected = random.nextLong();\n            javaBuffer.putLong(expected);\n\n            final int bufferIndex = buffer.capacity() - 8;\n            if (testBigEndian) {\n                buffer.setLong(bufferIndex, expected);\n            } else {\n                buffer.setLongLE(bufferIndex, expected);\n            }\n            javaBuffer.flip();\n\n            long javaActual = javaBuffer.getLong();\n            assertEquals(expected, javaActual);\n            assertEquals(javaActual, testBigEndian ? buffer.getLong(bufferIndex)\n                                                   : buffer.getLongLE(bufferIndex));\n        }\n    }\n\n    @Test\n    public void testRandomFloatAccess() {\n        testRandomFloatAccess(true);\n    }\n\n    @Test\n    public void testRandomFloatLEAccess() {\n        testRandomFloatAccess(false);\n    }\n\n    private void testRandomFloatAccess(boolean testBigEndian) {\n        for (int i = 0; i < buffer.capacity() - 7; i += 8) {\n            float value = random.nextFloat();\n            if (testBigEndian) {\n                buffer.setFloat(i, value);\n            } else {\n                buffer.setFloatLE(i, value);\n            }\n        }\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity() - 7; i += 8) {\n            float expected = random.nextFloat();\n            float actual = testBigEndian? buffer.getFloat(i) : buffer.getFloatLE(i);\n            assertEquals(expected, actual, 0.01);\n        }\n    }\n\n    @Test\n    public void testRandomDoubleAccess() {\n        testRandomDoubleAccess(true);\n    }\n\n    @Test\n    public void testRandomDoubleLEAccess() {\n        testRandomDoubleAccess(false);\n    }\n\n    private void testRandomDoubleAccess(boolean testBigEndian) {\n        for (int i = 0; i < buffer.capacity() - 7; i += 8) {\n            double value = random.nextDouble();\n            if (testBigEndian) {\n                buffer.setDouble(i, value);\n            } else {\n                buffer.setDoubleLE(i, value);\n            }\n        }\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity() - 7; i += 8) {\n            double expected = random.nextDouble();\n            double actual = testBigEndian? buffer.getDouble(i) : buffer.getDoubleLE(i);\n            assertEquals(expected, actual, 0.01);\n        }\n    }\n\n    @Test\n    public void testSetZero() {\n        buffer.clear();\n        while (buffer.isWritable()) {\n            buffer.writeByte((byte) 0xFF);\n        }\n\n        for (int i = 0; i < buffer.capacity();) {\n            int length = Math.min(buffer.capacity() - i, random.nextInt(32));\n            buffer.setZero(i, length);\n            i += length;\n        }\n\n        for (int i = 0; i < buffer.capacity(); i ++) {\n            assertEquals(0, buffer.getByte(i));\n        }\n    }\n\n    @Test\n    public void testSequentialByteAccess() {\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity(); i ++) {\n            byte value = (byte) random.nextInt();\n            assertEquals(i, buffer.writerIndex());\n            assertTrue(buffer.isWritable());\n            buffer.writeByte(value);\n        }\n\n        assertEquals(0, buffer.readerIndex());\n        assertEquals(buffer.capacity(), buffer.writerIndex());\n        assertFalse(buffer.isWritable());\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity(); i ++) {\n            byte value = (byte) random.nextInt();\n            assertEquals(i, buffer.readerIndex());\n            assertTrue(buffer.isReadable());\n            assertEquals(value, buffer.readByte());\n        }\n\n        assertEquals(buffer.capacity(), buffer.readerIndex());\n        assertEquals(buffer.capacity(), buffer.writerIndex());\n        assertFalse(buffer.isReadable());\n        assertFalse(buffer.isWritable());\n    }\n\n    @Test\n    public void testSequentialUnsignedByteAccess() {\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity(); i ++) {\n            byte value = (byte) random.nextInt();\n            assertEquals(i, buffer.writerIndex());\n            assertTrue(buffer.isWritable());\n            buffer.writeByte(value);\n        }\n\n        assertEquals(0, buffer.readerIndex());\n        assertEquals(buffer.capacity(), buffer.writerIndex());\n        assertFalse(buffer.isWritable());\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity(); i ++) {\n            int value = random.nextInt() & 0xFF;\n            assertEquals(i, buffer.readerIndex());\n            assertTrue(buffer.isReadable());\n            assertEquals(value, buffer.readUnsignedByte());\n        }\n\n        assertEquals(buffer.capacity(), buffer.readerIndex());\n        assertEquals(buffer.capacity(), buffer.writerIndex());\n        assertFalse(buffer.isReadable());\n        assertFalse(buffer.isWritable());\n    }\n\n    @Test\n    public void testSequentialShortAccess() {\n        testSequentialShortAccess(true);\n    }\n\n    @Test\n    public void testSequentialShortLEAccess() {\n        testSequentialShortAccess(false);\n    }\n\n    private void testSequentialShortAccess(boolean testBigEndian) {\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity(); i += 2) {\n            short value = (short) random.nextInt();\n            assertEquals(i, buffer.writerIndex());\n            assertTrue(buffer.isWritable());\n            if (testBigEndian) {\n                buffer.writeShort(value);\n            } else {\n                buffer.writeShortLE(value);\n            }\n        }\n\n        assertEquals(0, buffer.readerIndex());\n        assertEquals(buffer.capacity(), buffer.writerIndex());\n        assertFalse(buffer.isWritable());\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity(); i += 2) {\n            short value = (short) random.nextInt();\n            assertEquals(i, buffer.readerIndex());\n            assertTrue(buffer.isReadable());\n            if (testBigEndian) {\n                assertEquals(value, buffer.readShort());\n            } else {\n                assertEquals(value, buffer.readShortLE());\n            }\n        }\n\n        assertEquals(buffer.capacity(), buffer.readerIndex());\n        assertEquals(buffer.capacity(), buffer.writerIndex());\n        assertFalse(buffer.isReadable());\n        assertFalse(buffer.isWritable());\n    }\n\n    @Test\n    public void testSequentialUnsignedShortAccess() {\n        testSequentialUnsignedShortAccess(true);\n    }\n\n    @Test\n    public void testSequentialUnsignedShortLEAccess() {\n        testSequentialUnsignedShortAccess(true);\n    }\n\n    private void testSequentialUnsignedShortAccess(boolean testBigEndian) {\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity(); i += 2) {\n            short value = (short) random.nextInt();\n            assertEquals(i, buffer.writerIndex());\n            assertTrue(buffer.isWritable());\n            if (testBigEndian) {\n                buffer.writeShort(value);\n            } else {\n                buffer.writeShortLE(value);\n            }\n        }\n\n        assertEquals(0, buffer.readerIndex());\n        assertEquals(buffer.capacity(), buffer.writerIndex());\n        assertFalse(buffer.isWritable());\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity(); i += 2) {\n            int value = random.nextInt() & 0xFFFF;\n            assertEquals(i, buffer.readerIndex());\n            assertTrue(buffer.isReadable());\n            if (testBigEndian) {\n                assertEquals(value, buffer.readUnsignedShort());\n            } else {\n                assertEquals(value, buffer.readUnsignedShortLE());\n            }\n        }\n\n        assertEquals(buffer.capacity(), buffer.readerIndex());\n        assertEquals(buffer.capacity(), buffer.writerIndex());\n        assertFalse(buffer.isReadable());\n        assertFalse(buffer.isWritable());\n    }\n\n    @Test\n    public void testSequentialMediumAccess() {\n        testSequentialMediumAccess(true);\n    }\n    @Test\n    public void testSequentialMediumLEAccess() {\n        testSequentialMediumAccess(false);\n    }\n\n    private void testSequentialMediumAccess(boolean testBigEndian) {\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity() / 3 * 3; i += 3) {\n            int value = random.nextInt();\n            assertEquals(i, buffer.writerIndex());\n            assertTrue(buffer.isWritable());\n            if (testBigEndian) {\n                buffer.writeMedium(value);\n            } else {\n                buffer.writeMediumLE(value);\n            }\n        }\n\n        assertEquals(0, buffer.readerIndex());\n        assertEquals(buffer.capacity() / 3 * 3, buffer.writerIndex());\n        assertEquals(buffer.capacity() % 3, buffer.writableBytes());\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity() / 3 * 3; i += 3) {\n            int value = random.nextInt() << 8 >> 8;\n            assertEquals(i, buffer.readerIndex());\n            assertTrue(buffer.isReadable());\n            if (testBigEndian) {\n                assertEquals(value, buffer.readMedium());\n            } else {\n                assertEquals(value, buffer.readMediumLE());\n            }\n        }\n\n        assertEquals(buffer.capacity() / 3 * 3, buffer.readerIndex());\n        assertEquals(buffer.capacity() / 3 * 3, buffer.writerIndex());\n        assertEquals(0, buffer.readableBytes());\n        assertEquals(buffer.capacity() % 3, buffer.writableBytes());\n    }\n\n    @Test\n    public void testSequentialUnsignedMediumAccess() {\n        testSequentialUnsignedMediumAccess(true);\n    }\n\n    @Test\n    public void testSequentialUnsignedMediumLEAccess() {\n        testSequentialUnsignedMediumAccess(false);\n    }\n\n    private void testSequentialUnsignedMediumAccess(boolean testBigEndian) {\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity() / 3 * 3; i += 3) {\n            int value = random.nextInt() & 0x00FFFFFF;\n            assertEquals(i, buffer.writerIndex());\n            assertTrue(buffer.isWritable());\n            if (testBigEndian) {\n                buffer.writeMedium(value);\n            } else {\n                buffer.writeMediumLE(value);\n            }\n        }\n\n        assertEquals(0, buffer.readerIndex());\n        assertEquals(buffer.capacity() / 3 * 3, buffer.writerIndex());\n        assertEquals(buffer.capacity() % 3, buffer.writableBytes());\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity() / 3 * 3; i += 3) {\n            int value = random.nextInt() & 0x00FFFFFF;\n            assertEquals(i, buffer.readerIndex());\n            assertTrue(buffer.isReadable());\n            if (testBigEndian) {\n                assertEquals(value, buffer.readUnsignedMedium());\n            } else {\n                assertEquals(value, buffer.readUnsignedMediumLE());\n            }\n        }\n\n        assertEquals(buffer.capacity() / 3 * 3, buffer.readerIndex());\n        assertEquals(buffer.capacity() / 3 * 3, buffer.writerIndex());\n        assertEquals(0, buffer.readableBytes());\n        assertEquals(buffer.capacity() % 3, buffer.writableBytes());\n    }\n\n    @Test\n    public void testSequentialIntAccess() {\n        testSequentialIntAccess(true);\n    }\n\n    @Test\n    public void testSequentialIntLEAccess() {\n        testSequentialIntAccess(false);\n    }\n\n    private void testSequentialIntAccess(boolean testBigEndian) {\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity(); i += 4) {\n            int value = random.nextInt();\n            assertEquals(i, buffer.writerIndex());\n            assertTrue(buffer.isWritable());\n            if (testBigEndian) {\n                buffer.writeInt(value);\n            } else {\n                buffer.writeIntLE(value);\n            }\n        }\n\n        assertEquals(0, buffer.readerIndex());\n        assertEquals(buffer.capacity(), buffer.writerIndex());\n        assertFalse(buffer.isWritable());\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity(); i += 4) {\n            int value = random.nextInt();\n            assertEquals(i, buffer.readerIndex());\n            assertTrue(buffer.isReadable());\n            if (testBigEndian) {\n                assertEquals(value, buffer.readInt());\n            } else {\n                assertEquals(value, buffer.readIntLE());\n            }\n        }\n\n        assertEquals(buffer.capacity(), buffer.readerIndex());\n        assertEquals(buffer.capacity(), buffer.writerIndex());\n        assertFalse(buffer.isReadable());\n        assertFalse(buffer.isWritable());\n    }\n\n    @Test\n    public void testSequentialUnsignedIntAccess() {\n        testSequentialUnsignedIntAccess(true);\n    }\n\n    @Test\n    public void testSequentialUnsignedIntLEAccess() {\n        testSequentialUnsignedIntAccess(false);\n    }\n\n    private void testSequentialUnsignedIntAccess(boolean testBigEndian) {\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity(); i += 4) {\n            int value = random.nextInt();\n            assertEquals(i, buffer.writerIndex());\n            assertTrue(buffer.isWritable());\n            if (testBigEndian) {\n                buffer.writeInt(value);\n            } else {\n                buffer.writeIntLE(value);\n            }\n        }\n\n        assertEquals(0, buffer.readerIndex());\n        assertEquals(buffer.capacity(), buffer.writerIndex());\n        assertFalse(buffer.isWritable());\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity(); i += 4) {\n            long value = random.nextInt() & 0xFFFFFFFFL;\n            assertEquals(i, buffer.readerIndex());\n            assertTrue(buffer.isReadable());\n            if (testBigEndian) {\n                assertEquals(value, buffer.readUnsignedInt());\n            } else {\n                assertEquals(value, buffer.readUnsignedIntLE());\n            }\n        }\n\n        assertEquals(buffer.capacity(), buffer.readerIndex());\n        assertEquals(buffer.capacity(), buffer.writerIndex());\n        assertFalse(buffer.isReadable());\n        assertFalse(buffer.isWritable());\n    }\n\n    @Test\n    public void testSequentialLongAccess() {\n        testSequentialLongAccess(true);\n    }\n\n    @Test\n    public void testSequentialLongLEAccess() {\n        testSequentialLongAccess(false);\n    }\n\n    private void testSequentialLongAccess(boolean testBigEndian) {\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity(); i += 8) {\n            long value = random.nextLong();\n            assertEquals(i, buffer.writerIndex());\n            assertTrue(buffer.isWritable());\n            if (testBigEndian) {\n                buffer.writeLong(value);\n            } else {\n                buffer.writeLongLE(value);\n            }\n        }\n\n        assertEquals(0, buffer.readerIndex());\n        assertEquals(buffer.capacity(), buffer.writerIndex());\n        assertFalse(buffer.isWritable());\n\n        random.setSeed(seed);\n        for (int i = 0; i < buffer.capacity(); i += 8) {\n            long value = random.nextLong();\n            assertEquals(i, buffer.readerIndex());\n            assertTrue(buffer.isReadable());\n            if (testBigEndian) {\n                assertEquals(value, buffer.readLong());\n            } else {\n                assertEquals(value, buffer.readLongLE());\n            }\n        }\n\n        assertEquals(buffer.capacity(), buffer.readerIndex());\n        assertEquals(buffer.capacity(), buffer.writerIndex());\n        assertFalse(buffer.isReadable());\n        assertFalse(buffer.isWritable());\n    }\n\n    @Test\n    public void testByteArrayTransfer() {\n        byte[] value = new byte[BLOCK_SIZE * 2];\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(value);\n            buffer.setBytes(i, value, random.nextInt(BLOCK_SIZE), BLOCK_SIZE);\n        }\n\n        random.setSeed(seed);\n        byte[] expectedValue = new byte[BLOCK_SIZE * 2];\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValue);\n            int valueOffset = random.nextInt(BLOCK_SIZE);\n            buffer.getBytes(i, value, valueOffset, BLOCK_SIZE);\n            for (int j = valueOffset; j < valueOffset + BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue[j], value[j]);\n            }\n        }\n    }\n\n    @Test\n    public void testRandomByteArrayTransfer1() {\n        byte[] value = new byte[BLOCK_SIZE];\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(value);\n            buffer.setBytes(i, value);\n        }\n\n        random.setSeed(seed);\n        byte[] expectedValueContent = new byte[BLOCK_SIZE];\n        ByteBuf expectedValue = wrappedBuffer(expectedValueContent);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValueContent);\n            buffer.getBytes(i, value);\n            for (int j = 0; j < BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue.getByte(j), value[j]);\n            }\n        }\n    }\n\n    @Test\n    public void testRandomByteArrayTransfer2() {\n        byte[] value = new byte[BLOCK_SIZE * 2];\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(value);\n            buffer.setBytes(i, value, random.nextInt(BLOCK_SIZE), BLOCK_SIZE);\n        }\n\n        random.setSeed(seed);\n        byte[] expectedValueContent = new byte[BLOCK_SIZE * 2];\n        ByteBuf expectedValue = wrappedBuffer(expectedValueContent);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValueContent);\n            int valueOffset = random.nextInt(BLOCK_SIZE);\n            buffer.getBytes(i, value, valueOffset, BLOCK_SIZE);\n            for (int j = valueOffset; j < valueOffset + BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue.getByte(j), value[j]);\n            }\n        }\n    }\n\n    @Test\n    public void testRandomHeapBufferTransfer1() {\n        byte[] valueContent = new byte[BLOCK_SIZE];\n        ByteBuf value = wrappedBuffer(valueContent);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(valueContent);\n            value.setIndex(0, BLOCK_SIZE);\n            buffer.setBytes(i, value);\n            assertEquals(BLOCK_SIZE, value.readerIndex());\n            assertEquals(BLOCK_SIZE, value.writerIndex());\n        }\n\n        random.setSeed(seed);\n        byte[] expectedValueContent = new byte[BLOCK_SIZE];\n        ByteBuf expectedValue = wrappedBuffer(expectedValueContent);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValueContent);\n            value.clear();\n            buffer.getBytes(i, value);\n            assertEquals(0, value.readerIndex());\n            assertEquals(BLOCK_SIZE, value.writerIndex());\n            for (int j = 0; j < BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue.getByte(j), value.getByte(j));\n            }\n        }\n    }\n\n    @Test\n    public void testRandomHeapBufferTransfer2() {\n        byte[] valueContent = new byte[BLOCK_SIZE * 2];\n        ByteBuf value = wrappedBuffer(valueContent);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(valueContent);\n            buffer.setBytes(i, value, random.nextInt(BLOCK_SIZE), BLOCK_SIZE);\n        }\n\n        random.setSeed(seed);\n        byte[] expectedValueContent = new byte[BLOCK_SIZE * 2];\n        ByteBuf expectedValue = wrappedBuffer(expectedValueContent);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValueContent);\n            int valueOffset = random.nextInt(BLOCK_SIZE);\n            buffer.getBytes(i, value, valueOffset, BLOCK_SIZE);\n            for (int j = valueOffset; j < valueOffset + BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue.getByte(j), value.getByte(j));\n            }\n        }\n    }\n\n    @Test\n    public void testRandomDirectBufferTransfer() {\n        byte[] tmp = new byte[BLOCK_SIZE * 2];\n        ByteBuf value = directBuffer(BLOCK_SIZE * 2);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(tmp);\n            value.setBytes(0, tmp, 0, value.capacity());\n            buffer.setBytes(i, value, random.nextInt(BLOCK_SIZE), BLOCK_SIZE);\n        }\n\n        random.setSeed(seed);\n        ByteBuf expectedValue = directBuffer(BLOCK_SIZE * 2);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(tmp);\n            expectedValue.setBytes(0, tmp, 0, expectedValue.capacity());\n            int valueOffset = random.nextInt(BLOCK_SIZE);\n            buffer.getBytes(i, value, valueOffset, BLOCK_SIZE);\n            for (int j = valueOffset; j < valueOffset + BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue.getByte(j), value.getByte(j));\n            }\n        }\n        value.release();\n        expectedValue.release();\n    }\n\n    @Test\n    public void testRandomByteBufferTransfer() {\n        ByteBuffer value = ByteBuffer.allocate(BLOCK_SIZE * 2);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(value.array());\n            value.clear().position(random.nextInt(BLOCK_SIZE));\n            value.limit(value.position() + BLOCK_SIZE);\n            buffer.setBytes(i, value);\n        }\n\n        random.setSeed(seed);\n        ByteBuffer expectedValue = ByteBuffer.allocate(BLOCK_SIZE * 2);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValue.array());\n            int valueOffset = random.nextInt(BLOCK_SIZE);\n            value.clear().position(valueOffset).limit(valueOffset + BLOCK_SIZE);\n            buffer.getBytes(i, value);\n            assertEquals(valueOffset + BLOCK_SIZE, value.position());\n            for (int j = valueOffset; j < valueOffset + BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue.get(j), value.get(j));\n            }\n        }\n    }\n\n    @Test\n    public void testSequentialByteArrayTransfer1() {\n        byte[] value = new byte[BLOCK_SIZE];\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(value);\n            assertEquals(0, buffer.readerIndex());\n            assertEquals(i, buffer.writerIndex());\n            buffer.writeBytes(value);\n        }\n\n        random.setSeed(seed);\n        byte[] expectedValue = new byte[BLOCK_SIZE];\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValue);\n            assertEquals(i, buffer.readerIndex());\n            assertEquals(CAPACITY, buffer.writerIndex());\n            buffer.readBytes(value);\n            for (int j = 0; j < BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue[j], value[j]);\n            }\n        }\n    }\n\n    @Test\n    public void testSequentialByteArrayTransfer2() {\n        byte[] value = new byte[BLOCK_SIZE * 2];\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(value);\n            assertEquals(0, buffer.readerIndex());\n            assertEquals(i, buffer.writerIndex());\n            int readerIndex = random.nextInt(BLOCK_SIZE);\n            buffer.writeBytes(value, readerIndex, BLOCK_SIZE);\n        }\n\n        random.setSeed(seed);\n        byte[] expectedValue = new byte[BLOCK_SIZE * 2];\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValue);\n            int valueOffset = random.nextInt(BLOCK_SIZE);\n            assertEquals(i, buffer.readerIndex());\n            assertEquals(CAPACITY, buffer.writerIndex());\n            buffer.readBytes(value, valueOffset, BLOCK_SIZE);\n            for (int j = valueOffset; j < valueOffset + BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue[j], value[j]);\n            }\n        }\n    }\n\n    @Test\n    public void testSequentialHeapBufferTransfer1() {\n        byte[] valueContent = new byte[BLOCK_SIZE * 2];\n        ByteBuf value = wrappedBuffer(valueContent);\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(valueContent);\n            assertEquals(0, buffer.readerIndex());\n            assertEquals(i, buffer.writerIndex());\n            buffer.writeBytes(value, random.nextInt(BLOCK_SIZE), BLOCK_SIZE);\n            assertEquals(0, value.readerIndex());\n            assertEquals(valueContent.length, value.writerIndex());\n        }\n\n        random.setSeed(seed);\n        byte[] expectedValueContent = new byte[BLOCK_SIZE * 2];\n        ByteBuf expectedValue = wrappedBuffer(expectedValueContent);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValueContent);\n            int valueOffset = random.nextInt(BLOCK_SIZE);\n            assertEquals(i, buffer.readerIndex());\n            assertEquals(CAPACITY, buffer.writerIndex());\n            buffer.readBytes(value, valueOffset, BLOCK_SIZE);\n            for (int j = valueOffset; j < valueOffset + BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue.getByte(j), value.getByte(j));\n            }\n            assertEquals(0, value.readerIndex());\n            assertEquals(valueContent.length, value.writerIndex());\n        }\n    }\n\n    @Test\n    public void testSequentialHeapBufferTransfer2() {\n        byte[] valueContent = new byte[BLOCK_SIZE * 2];\n        ByteBuf value = wrappedBuffer(valueContent);\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(valueContent);\n            assertEquals(0, buffer.readerIndex());\n            assertEquals(i, buffer.writerIndex());\n            int readerIndex = random.nextInt(BLOCK_SIZE);\n            value.readerIndex(readerIndex);\n            value.writerIndex(readerIndex + BLOCK_SIZE);\n            buffer.writeBytes(value);\n            assertEquals(readerIndex + BLOCK_SIZE, value.writerIndex());\n            assertEquals(value.writerIndex(), value.readerIndex());\n        }\n\n        random.setSeed(seed);\n        byte[] expectedValueContent = new byte[BLOCK_SIZE * 2];\n        ByteBuf expectedValue = wrappedBuffer(expectedValueContent);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValueContent);\n            int valueOffset = random.nextInt(BLOCK_SIZE);\n            assertEquals(i, buffer.readerIndex());\n            assertEquals(CAPACITY, buffer.writerIndex());\n            value.readerIndex(valueOffset);\n            value.writerIndex(valueOffset);\n            buffer.readBytes(value, BLOCK_SIZE);\n            for (int j = valueOffset; j < valueOffset + BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue.getByte(j), value.getByte(j));\n            }\n            assertEquals(valueOffset, value.readerIndex());\n            assertEquals(valueOffset + BLOCK_SIZE, value.writerIndex());\n        }\n    }\n\n    @Test\n    public void testSequentialDirectBufferTransfer1() {\n        byte[] valueContent = new byte[BLOCK_SIZE * 2];\n        ByteBuf value = directBuffer(BLOCK_SIZE * 2);\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(valueContent);\n            value.setBytes(0, valueContent);\n            assertEquals(0, buffer.readerIndex());\n            assertEquals(i, buffer.writerIndex());\n            buffer.writeBytes(value, random.nextInt(BLOCK_SIZE), BLOCK_SIZE);\n            assertEquals(0, value.readerIndex());\n            assertEquals(0, value.writerIndex());\n        }\n\n        random.setSeed(seed);\n        byte[] expectedValueContent = new byte[BLOCK_SIZE * 2];\n        ByteBuf expectedValue = wrappedBuffer(expectedValueContent);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValueContent);\n            int valueOffset = random.nextInt(BLOCK_SIZE);\n            value.setBytes(0, valueContent);\n            assertEquals(i, buffer.readerIndex());\n            assertEquals(CAPACITY, buffer.writerIndex());\n            buffer.readBytes(value, valueOffset, BLOCK_SIZE);\n            for (int j = valueOffset; j < valueOffset + BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue.getByte(j), value.getByte(j));\n            }\n            assertEquals(0, value.readerIndex());\n            assertEquals(0, value.writerIndex());\n        }\n        value.release();\n        expectedValue.release();\n    }\n\n    @Test\n    public void testSequentialDirectBufferTransfer2() {\n        byte[] valueContent = new byte[BLOCK_SIZE * 2];\n        ByteBuf value = directBuffer(BLOCK_SIZE * 2);\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(valueContent);\n            value.setBytes(0, valueContent);\n            assertEquals(0, buffer.readerIndex());\n            assertEquals(i, buffer.writerIndex());\n            int readerIndex = random.nextInt(BLOCK_SIZE);\n            value.readerIndex(0);\n            value.writerIndex(readerIndex + BLOCK_SIZE);\n            value.readerIndex(readerIndex);\n            buffer.writeBytes(value);\n            assertEquals(readerIndex + BLOCK_SIZE, value.writerIndex());\n            assertEquals(value.writerIndex(), value.readerIndex());\n        }\n\n        random.setSeed(seed);\n        byte[] expectedValueContent = new byte[BLOCK_SIZE * 2];\n        ByteBuf expectedValue = wrappedBuffer(expectedValueContent);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValueContent);\n            value.setBytes(0, valueContent);\n            int valueOffset = random.nextInt(BLOCK_SIZE);\n            assertEquals(i, buffer.readerIndex());\n            assertEquals(CAPACITY, buffer.writerIndex());\n            value.readerIndex(valueOffset);\n            value.writerIndex(valueOffset);\n            buffer.readBytes(value, BLOCK_SIZE);\n            for (int j = valueOffset; j < valueOffset + BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue.getByte(j), value.getByte(j));\n            }\n            assertEquals(valueOffset, value.readerIndex());\n            assertEquals(valueOffset + BLOCK_SIZE, value.writerIndex());\n        }\n        value.release();\n        expectedValue.release();\n    }\n\n    @Test\n    public void testSequentialByteBufferBackedHeapBufferTransfer1() {\n        byte[] valueContent = new byte[BLOCK_SIZE * 2];\n        ByteBuf value = wrappedBuffer(ByteBuffer.allocate(BLOCK_SIZE * 2));\n        value.writerIndex(0);\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(valueContent);\n            value.setBytes(0, valueContent);\n            assertEquals(0, buffer.readerIndex());\n            assertEquals(i, buffer.writerIndex());\n            buffer.writeBytes(value, random.nextInt(BLOCK_SIZE), BLOCK_SIZE);\n            assertEquals(0, value.readerIndex());\n            assertEquals(0, value.writerIndex());\n        }\n\n        random.setSeed(seed);\n        byte[] expectedValueContent = new byte[BLOCK_SIZE * 2];\n        ByteBuf expectedValue = wrappedBuffer(expectedValueContent);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValueContent);\n            int valueOffset = random.nextInt(BLOCK_SIZE);\n            value.setBytes(0, valueContent);\n            assertEquals(i, buffer.readerIndex());\n            assertEquals(CAPACITY, buffer.writerIndex());\n            buffer.readBytes(value, valueOffset, BLOCK_SIZE);\n            for (int j = valueOffset; j < valueOffset + BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue.getByte(j), value.getByte(j));\n            }\n            assertEquals(0, value.readerIndex());\n            assertEquals(0, value.writerIndex());\n        }\n    }\n\n    @Test\n    public void testSequentialByteBufferBackedHeapBufferTransfer2() {\n        byte[] valueContent = new byte[BLOCK_SIZE * 2];\n        ByteBuf value = wrappedBuffer(ByteBuffer.allocate(BLOCK_SIZE * 2));\n        value.writerIndex(0);\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(valueContent);\n            value.setBytes(0, valueContent);\n            assertEquals(0, buffer.readerIndex());\n            assertEquals(i, buffer.writerIndex());\n            int readerIndex = random.nextInt(BLOCK_SIZE);\n            value.readerIndex(0);\n            value.writerIndex(readerIndex + BLOCK_SIZE);\n            value.readerIndex(readerIndex);\n            buffer.writeBytes(value);\n            assertEquals(readerIndex + BLOCK_SIZE, value.writerIndex());\n            assertEquals(value.writerIndex(), value.readerIndex());\n        }\n\n        random.setSeed(seed);\n        byte[] expectedValueContent = new byte[BLOCK_SIZE * 2];\n        ByteBuf expectedValue = wrappedBuffer(expectedValueContent);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValueContent);\n            value.setBytes(0, valueContent);\n            int valueOffset = random.nextInt(BLOCK_SIZE);\n            assertEquals(i, buffer.readerIndex());\n            assertEquals(CAPACITY, buffer.writerIndex());\n            value.readerIndex(valueOffset);\n            value.writerIndex(valueOffset);\n            buffer.readBytes(value, BLOCK_SIZE);\n            for (int j = valueOffset; j < valueOffset + BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue.getByte(j), value.getByte(j));\n            }\n            assertEquals(valueOffset, value.readerIndex());\n            assertEquals(valueOffset + BLOCK_SIZE, value.writerIndex());\n        }\n    }\n\n    @Test\n    public void testSequentialByteBufferTransfer() {\n        buffer.writerIndex(0);\n        ByteBuffer value = ByteBuffer.allocate(BLOCK_SIZE * 2);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(value.array());\n            value.clear().position(random.nextInt(BLOCK_SIZE));\n            value.limit(value.position() + BLOCK_SIZE);\n            buffer.writeBytes(value);\n        }\n\n        random.setSeed(seed);\n        ByteBuffer expectedValue = ByteBuffer.allocate(BLOCK_SIZE * 2);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValue.array());\n            int valueOffset = random.nextInt(BLOCK_SIZE);\n            value.clear().position(valueOffset).limit(valueOffset + BLOCK_SIZE);\n            buffer.readBytes(value);\n            assertEquals(valueOffset + BLOCK_SIZE, value.position());\n            for (int j = valueOffset; j < valueOffset + BLOCK_SIZE; j ++) {\n                assertEquals(expectedValue.get(j), value.get(j));\n            }\n        }\n    }\n\n    @Test\n    public void testSequentialCopiedBufferTransfer1() {\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            byte[] value = new byte[BLOCK_SIZE];\n            random.nextBytes(value);\n            assertEquals(0, buffer.readerIndex());\n            assertEquals(i, buffer.writerIndex());\n            buffer.writeBytes(value);\n        }\n\n        random.setSeed(seed);\n        byte[] expectedValue = new byte[BLOCK_SIZE];\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValue);\n            assertEquals(i, buffer.readerIndex());\n            assertEquals(CAPACITY, buffer.writerIndex());\n            ByteBuf actualValue = buffer.readBytes(BLOCK_SIZE);\n            assertEquals(wrappedBuffer(expectedValue), actualValue);\n\n            // Make sure if it is a copied buffer.\n            actualValue.setByte(0, (byte) (actualValue.getByte(0) + 1));\n            assertFalse(buffer.getByte(i) == actualValue.getByte(0));\n            actualValue.release();\n        }\n    }\n\n    @Test\n    public void testSequentialSlice1() {\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            byte[] value = new byte[BLOCK_SIZE];\n            random.nextBytes(value);\n            assertEquals(0, buffer.readerIndex());\n            assertEquals(i, buffer.writerIndex());\n            buffer.writeBytes(value);\n        }\n\n        random.setSeed(seed);\n        byte[] expectedValue = new byte[BLOCK_SIZE];\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            random.nextBytes(expectedValue);\n            assertEquals(i, buffer.readerIndex());\n            assertEquals(CAPACITY, buffer.writerIndex());\n            ByteBuf actualValue = buffer.readSlice(BLOCK_SIZE);\n            assertEquals(buffer.order(), actualValue.order());\n            assertEquals(wrappedBuffer(expectedValue), actualValue);\n\n            // Make sure if it is a sliced buffer.\n            actualValue.setByte(0, (byte) (actualValue.getByte(0) + 1));\n            assertEquals(buffer.getByte(i), actualValue.getByte(0));\n        }\n    }\n\n    @Test\n    public void testWriteZero() {\n        try {\n            buffer.writeZero(-1);\n            fail();\n        } catch (IllegalArgumentException e) {\n            // Expected\n        }\n\n        buffer.clear();\n        while (buffer.isWritable()) {\n            buffer.writeByte((byte) 0xFF);\n        }\n\n        buffer.clear();\n        for (int i = 0; i < buffer.capacity();) {\n            int length = Math.min(buffer.capacity() - i, random.nextInt(32));\n            buffer.writeZero(length);\n            i += length;\n        }\n\n        assertEquals(0, buffer.readerIndex());\n        assertEquals(buffer.capacity(), buffer.writerIndex());\n\n        for (int i = 0; i < buffer.capacity(); i ++) {\n            assertEquals(0, buffer.getByte(i));\n        }\n    }\n\n    @Test\n    public void testDiscardReadBytes() {\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity(); i += 4) {\n            buffer.writeInt(i);\n        }\n        ByteBuf copy = copiedBuffer(buffer);\n\n        // Make sure there's no effect if called when readerIndex is 0.\n        buffer.readerIndex(CAPACITY / 4);\n        buffer.markReaderIndex();\n        buffer.writerIndex(CAPACITY / 3);\n        buffer.markWriterIndex();\n        buffer.readerIndex(0);\n        buffer.writerIndex(CAPACITY / 2);\n        buffer.discardReadBytes();\n\n        assertEquals(0, buffer.readerIndex());\n        assertEquals(CAPACITY / 2, buffer.writerIndex());\n        assertEquals(copy.slice(0, CAPACITY / 2), buffer.slice(0, CAPACITY / 2));\n        buffer.resetReaderIndex();\n        assertEquals(CAPACITY / 4, buffer.readerIndex());\n        buffer.resetWriterIndex();\n        assertEquals(CAPACITY / 3, buffer.writerIndex());\n\n        // Make sure bytes after writerIndex is not copied.\n        buffer.readerIndex(1);\n        buffer.writerIndex(CAPACITY / 2);\n        buffer.discardReadBytes();\n\n        assertEquals(0, buffer.readerIndex());\n        assertEquals(CAPACITY / 2 - 1, buffer.writerIndex());\n        assertEquals(copy.slice(1, CAPACITY / 2 - 1), buffer.slice(0, CAPACITY / 2 - 1));\n\n        if (discardReadBytesDoesNotMoveWritableBytes()) {\n            // If writable bytes were copied, the test should fail to avoid unnecessary memory bandwidth consumption.\n            assertFalse(copy.slice(CAPACITY / 2, CAPACITY / 2).equals(buffer.slice(CAPACITY / 2 - 1, CAPACITY / 2)));\n        } else {\n            assertEquals(copy.slice(CAPACITY / 2, CAPACITY / 2), buffer.slice(CAPACITY / 2 - 1, CAPACITY / 2));\n        }\n\n        // Marks also should be relocated.\n        buffer.resetReaderIndex();\n        assertEquals(CAPACITY / 4 - 1, buffer.readerIndex());\n        buffer.resetWriterIndex();\n        assertEquals(CAPACITY / 3 - 1, buffer.writerIndex());\n        copy.release();\n    }\n\n    /**\n     * The similar test case with {@link #testDiscardReadBytes()} but this one\n     * discards a large chunk at once.\n     */\n    @Test\n    public void testDiscardReadBytes2() {\n        buffer.writerIndex(0);\n        for (int i = 0; i < buffer.capacity(); i ++) {\n            buffer.writeByte((byte) i);\n        }\n        ByteBuf copy = copiedBuffer(buffer);\n\n        // Discard the first (CAPACITY / 2 - 1) bytes.\n        buffer.setIndex(CAPACITY / 2 - 1, CAPACITY - 1);\n        buffer.discardReadBytes();\n        assertEquals(0, buffer.readerIndex());\n        assertEquals(CAPACITY / 2, buffer.writerIndex());\n        for (int i = 0; i < CAPACITY / 2; i ++) {\n            assertEquals(copy.slice(CAPACITY / 2 - 1 + i, CAPACITY / 2 - i), buffer.slice(i, CAPACITY / 2 - i));\n        }\n        copy.release();\n    }\n\n    @Test\n    public void testStreamTransfer1() throws Exception {\n        byte[] expected = new byte[buffer.capacity()];\n        random.nextBytes(expected);\n\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            ByteArrayInputStream in = new ByteArrayInputStream(expected, i, BLOCK_SIZE);\n            assertEquals(BLOCK_SIZE, buffer.setBytes(i, in, BLOCK_SIZE));\n            assertEquals(-1, buffer.setBytes(i, in, 0));\n        }\n\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            buffer.getBytes(i, out, BLOCK_SIZE);\n        }\n\n        assertTrue(Arrays.equals(expected, out.toByteArray()));\n    }\n\n    @Test\n    public void testStreamTransfer2() throws Exception {\n        byte[] expected = new byte[buffer.capacity()];\n        random.nextBytes(expected);\n        buffer.clear();\n\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            ByteArrayInputStream in = new ByteArrayInputStream(expected, i, BLOCK_SIZE);\n            assertEquals(i, buffer.writerIndex());\n            buffer.writeBytes(in, BLOCK_SIZE);\n            assertEquals(i + BLOCK_SIZE, buffer.writerIndex());\n        }\n\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            assertEquals(i, buffer.readerIndex());\n            buffer.readBytes(out, BLOCK_SIZE);\n            assertEquals(i + BLOCK_SIZE, buffer.readerIndex());\n        }\n\n        assertTrue(Arrays.equals(expected, out.toByteArray()));\n    }\n\n    @Test\n    public void testCopy() {\n        for (int i = 0; i < buffer.capacity(); i ++) {\n            byte value = (byte) random.nextInt();\n            buffer.setByte(i, value);\n        }\n\n        final int readerIndex = CAPACITY / 3;\n        final int writerIndex = CAPACITY * 2 / 3;\n        buffer.setIndex(readerIndex, writerIndex);\n\n        // Make sure all properties are copied.\n        ByteBuf copy = buffer.copy();\n        assertEquals(0, copy.readerIndex());\n        assertEquals(buffer.readableBytes(), copy.writerIndex());\n        assertEquals(buffer.readableBytes(), copy.capacity());\n        assertSame(buffer.order(), copy.order());\n        for (int i = 0; i < copy.capacity(); i ++) {\n            assertEquals(buffer.getByte(i + readerIndex), copy.getByte(i));\n        }\n\n        // Make sure the buffer content is independent from each other.\n        buffer.setByte(readerIndex, (byte) (buffer.getByte(readerIndex) + 1));\n        assertTrue(buffer.getByte(readerIndex) != copy.getByte(0));\n        copy.setByte(1, (byte) (copy.getByte(1) + 1));\n        assertTrue(buffer.getByte(readerIndex + 1) != copy.getByte(1));\n        copy.release();\n    }\n\n    @Test\n    public void testDuplicate() {\n        for (int i = 0; i < buffer.capacity(); i ++) {\n            byte value = (byte) random.nextInt();\n            buffer.setByte(i, value);\n        }\n\n        final int readerIndex = CAPACITY / 3;\n        final int writerIndex = CAPACITY * 2 / 3;\n        buffer.setIndex(readerIndex, writerIndex);\n\n        // Make sure all properties are copied.\n        ByteBuf duplicate = buffer.duplicate();\n        assertSame(buffer.order(), duplicate.order());\n        assertEquals(buffer.readableBytes(), duplicate.readableBytes());\n        assertEquals(0, buffer.compareTo(duplicate));\n\n        // Make sure the buffer content is shared.\n        buffer.setByte(readerIndex, (byte) (buffer.getByte(readerIndex) + 1));\n        assertEquals(buffer.getByte(readerIndex), duplicate.getByte(duplicate.readerIndex()));\n        duplicate.setByte(duplicate.readerIndex(), (byte) (duplicate.getByte(duplicate.readerIndex()) + 1));\n        assertEquals(buffer.getByte(readerIndex), duplicate.getByte(duplicate.readerIndex()));\n    }\n\n    @Test\n    public void testSliceEndianness() throws Exception {\n        assertEquals(buffer.order(), buffer.slice(0, buffer.capacity()).order());\n        assertEquals(buffer.order(), buffer.slice(0, buffer.capacity() - 1).order());\n        assertEquals(buffer.order(), buffer.slice(1, buffer.capacity() - 1).order());\n        assertEquals(buffer.order(), buffer.slice(1, buffer.capacity() - 2).order());\n    }\n\n    @Test\n    public void testSliceIndex() throws Exception {\n        assertEquals(0, buffer.slice(0, buffer.capacity()).readerIndex());\n        assertEquals(0, buffer.slice(0, buffer.capacity() - 1).readerIndex());\n        assertEquals(0, buffer.slice(1, buffer.capacity() - 1).readerIndex());\n        assertEquals(0, buffer.slice(1, buffer.capacity() - 2).readerIndex());\n\n        assertEquals(buffer.capacity(), buffer.slice(0, buffer.capacity()).writerIndex());\n        assertEquals(buffer.capacity() - 1, buffer.slice(0, buffer.capacity() - 1).writerIndex());\n        assertEquals(buffer.capacity() - 1, buffer.slice(1, buffer.capacity() - 1).writerIndex());\n        assertEquals(buffer.capacity() - 2, buffer.slice(1, buffer.capacity() - 2).writerIndex());\n    }\n\n    @Test\n    public void testRetainedSliceIndex() throws Exception {\n        ByteBuf retainedSlice = buffer.retainedSlice(0, buffer.capacity());\n        assertEquals(0, retainedSlice.readerIndex());\n        retainedSlice.release();\n\n        retainedSlice = buffer.retainedSlice(0, buffer.capacity() - 1);\n        assertEquals(0, retainedSlice.readerIndex());\n        retainedSlice.release();\n\n        retainedSlice = buffer.retainedSlice(1, buffer.capacity() - 1);\n        assertEquals(0, retainedSlice.readerIndex());\n        retainedSlice.release();\n\n        retainedSlice = buffer.retainedSlice(1, buffer.capacity() - 2);\n        assertEquals(0, retainedSlice.readerIndex());\n        retainedSlice.release();\n\n        retainedSlice = buffer.retainedSlice(0, buffer.capacity());\n        assertEquals(buffer.capacity(), retainedSlice.writerIndex());\n        retainedSlice.release();\n\n        retainedSlice = buffer.retainedSlice(0, buffer.capacity() - 1);\n        assertEquals(buffer.capacity() - 1, retainedSlice.writerIndex());\n        retainedSlice.release();\n\n        retainedSlice = buffer.retainedSlice(1, buffer.capacity() - 1);\n        assertEquals(buffer.capacity() - 1, retainedSlice.writerIndex());\n        retainedSlice.release();\n\n        retainedSlice = buffer.retainedSlice(1, buffer.capacity() - 2);\n        assertEquals(buffer.capacity() - 2, retainedSlice.writerIndex());\n        retainedSlice.release();\n    }\n\n    @Test\n    @SuppressWarnings(\"ObjectEqualsNull\")\n    public void testEquals() {\n        assertFalse(buffer.equals(null));\n        assertFalse(buffer.equals(new Object()));\n\n        byte[] value = new byte[32];\n        buffer.setIndex(0, value.length);\n        random.nextBytes(value);\n        buffer.setBytes(0, value);\n\n        assertEquals(buffer, wrappedBuffer(value));\n        assertEquals(buffer, wrappedBuffer(value).order(LITTLE_ENDIAN));\n\n        value[0] ++;\n        assertFalse(buffer.equals(wrappedBuffer(value)));\n        assertFalse(buffer.equals(wrappedBuffer(value).order(LITTLE_ENDIAN)));\n    }\n\n    @Test\n    public void testCompareTo() {\n        try {\n            buffer.compareTo(null);\n            fail();\n        } catch (NullPointerException e) {\n            // Expected\n        }\n\n        // Fill the random stuff\n        byte[] value = new byte[32];\n        random.nextBytes(value);\n        // Prevent overflow / underflow\n        if (value[0] == 0) {\n            value[0] ++;\n        } else if (value[0] == -1) {\n            value[0] --;\n        }\n\n        buffer.setIndex(0, value.length);\n        buffer.setBytes(0, value);\n\n        assertEquals(0, buffer.compareTo(wrappedBuffer(value)));\n        assertEquals(0, buffer.compareTo(wrappedBuffer(value).order(LITTLE_ENDIAN)));\n\n        value[0] ++;\n        assertTrue(buffer.compareTo(wrappedBuffer(value)) < 0);\n        assertTrue(buffer.compareTo(wrappedBuffer(value).order(LITTLE_ENDIAN)) < 0);\n        value[0] -= 2;\n        assertTrue(buffer.compareTo(wrappedBuffer(value)) > 0);\n        assertTrue(buffer.compareTo(wrappedBuffer(value).order(LITTLE_ENDIAN)) > 0);\n        value[0] ++;\n\n        assertTrue(buffer.compareTo(wrappedBuffer(value, 0, 31)) > 0);\n        assertTrue(buffer.compareTo(wrappedBuffer(value, 0, 31).order(LITTLE_ENDIAN)) > 0);\n        assertTrue(buffer.slice(0, 31).compareTo(wrappedBuffer(value)) < 0);\n        assertTrue(buffer.slice(0, 31).compareTo(wrappedBuffer(value).order(LITTLE_ENDIAN)) < 0);\n\n        ByteBuf retainedSlice = buffer.retainedSlice(0, 31);\n        assertTrue(retainedSlice.compareTo(wrappedBuffer(value)) < 0);\n        retainedSlice.release();\n\n        retainedSlice = buffer.retainedSlice(0, 31);\n        assertTrue(retainedSlice.compareTo(wrappedBuffer(value).order(LITTLE_ENDIAN)) < 0);\n        retainedSlice.release();\n    }\n\n    @Test\n    public void testCompareTo2() {\n        byte[] bytes = {1, 2, 3, 4};\n        byte[] bytesReversed = {4, 3, 2, 1};\n\n        ByteBuf buf1 = newBuffer(4).clear().writeBytes(bytes).order(ByteOrder.LITTLE_ENDIAN);\n        ByteBuf buf2 = newBuffer(4).clear().writeBytes(bytesReversed).order(ByteOrder.LITTLE_ENDIAN);\n        ByteBuf buf3 = newBuffer(4).clear().writeBytes(bytes).order(ByteOrder.BIG_ENDIAN);\n        ByteBuf buf4 = newBuffer(4).clear().writeBytes(bytesReversed).order(ByteOrder.BIG_ENDIAN);\n        try {\n            assertEquals(buf1.compareTo(buf2), buf3.compareTo(buf4));\n            assertEquals(buf2.compareTo(buf1), buf4.compareTo(buf3));\n            assertEquals(buf1.compareTo(buf3), buf2.compareTo(buf4));\n            assertEquals(buf3.compareTo(buf1), buf4.compareTo(buf2));\n        } finally {\n            buf1.release();\n            buf2.release();\n            buf3.release();\n            buf4.release();\n        }\n    }\n\n    @Test\n    public void testToString() {\n        ByteBuf copied = copiedBuffer(\"Hello, World!\", CharsetUtil.ISO_8859_1);\n        buffer.clear();\n        buffer.writeBytes(copied);\n        assertEquals(\"Hello, World!\", buffer.toString(CharsetUtil.ISO_8859_1));\n        copied.release();\n    }\n\n    @Test(timeout = 10000)\n    public void testToStringMultipleThreads() throws Throwable {\n        buffer.clear();\n        buffer.writeBytes(\"Hello, World!\".getBytes(CharsetUtil.ISO_8859_1));\n\n        final AtomicInteger counter = new AtomicInteger(30000);\n        final AtomicReference<Throwable> errorRef = new AtomicReference<Throwable>();\n        List<Thread> threads = new ArrayList<Thread>();\n        for (int i = 0; i < 10; i++) {\n            Thread thread = new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        while (errorRef.get() == null && counter.decrementAndGet() > 0) {\n                            assertEquals(\"Hello, World!\", buffer.toString(CharsetUtil.ISO_8859_1));\n                        }\n                    } catch (Throwable cause) {\n                        errorRef.compareAndSet(null, cause);\n                    }\n                }\n            });\n            threads.add(thread);\n        }\n        for (Thread thread : threads) {\n            thread.start();\n        }\n\n        for (Thread thread : threads) {\n            thread.join();\n        }\n\n        Throwable error = errorRef.get();\n        if (error != null) {\n            throw error;\n        }\n    }\n\n    @Test\n    public void testSWARIndexOf() {\n        ByteBuf buffer = newBuffer(16);\n        buffer.clear();\n        // Ensure the buffer is completely zero'ed.\n        buffer.setZero(0, buffer.capacity());\n        buffer.writeByte((byte) 0); // 0\n        buffer.writeByte((byte) 0);\n        buffer.writeByte((byte) 0);\n        buffer.writeByte((byte) 0);\n        buffer.writeByte((byte) 0);\n        buffer.writeByte((byte) 0);\n        buffer.writeByte((byte) 0);\n        buffer.writeByte((byte) 0); // 7\n\n        buffer.writeByte((byte) 0);\n        buffer.writeByte((byte) 0);\n        buffer.writeByte((byte) 0);\n        buffer.writeByte((byte) 1); // 11\n        buffer.writeByte((byte) 2);\n        buffer.writeByte((byte) 3);\n        buffer.writeByte((byte) 4);\n        buffer.writeByte((byte) 1);\n        assertEquals(11, buffer.indexOf(0, 12, (byte) 1));\n        assertEquals(12, buffer.indexOf(0, 16, (byte) 2));\n        assertEquals(-1, buffer.indexOf(0, 11, (byte) 1));\n        assertEquals(11, buffer.indexOf(0, 16, (byte) 1));\n        buffer.release();\n    }\n\n    @Test\n    public void testIndexOf() {\n        buffer.clear();\n        // Ensure the buffer is completely zero'ed.\n        buffer.setZero(0, buffer.capacity());\n\n        buffer.writeByte((byte) 1);\n        buffer.writeByte((byte) 2);\n        buffer.writeByte((byte) 3);\n        buffer.writeByte((byte) 2);\n        buffer.writeByte((byte) 1);\n\n        assertEquals(-1, buffer.indexOf(1, 4, (byte) 1));\n        assertEquals(-1, buffer.indexOf(4, 1, (byte) 1));\n        assertEquals(1, buffer.indexOf(1, 4, (byte) 2));\n        assertEquals(3, buffer.indexOf(4, 1, (byte) 2));\n\n        try {\n            buffer.indexOf(0, buffer.capacity() + 1, (byte) 0);\n            fail();\n        } catch (IndexOutOfBoundsException expected) {\n            // expected\n        }\n\n        try {\n            buffer.indexOf(buffer.capacity(), -1, (byte) 0);\n            fail();\n        } catch (IndexOutOfBoundsException expected) {\n            // expected\n        }\n\n        assertEquals(4, buffer.indexOf(buffer.capacity() + 1, 0, (byte) 1));\n        assertEquals(0, buffer.indexOf(-1, buffer.capacity(), (byte) 1));\n    }\n\n    @Test\n    public void testIndexOfReleaseBuffer() {\n        ByteBuf buffer = releasedBuffer();\n        if (buffer.capacity() != 0) {\n            try {\n                buffer.indexOf(0, 1, (byte) 1);\n                fail();\n            } catch (IllegalReferenceCountException expected) {\n                // expected\n            }\n        } else {\n            assertEquals(-1, buffer.indexOf(0, 1, (byte) 1));\n        }\n    }\n\n    @Test\n    public void testNioBuffer1() {\n        assumeTrue(buffer.nioBufferCount() == 1);\n\n        byte[] value = new byte[buffer.capacity()];\n        random.nextBytes(value);\n        buffer.clear();\n        buffer.writeBytes(value);\n\n        assertRemainingEquals(ByteBuffer.wrap(value), buffer.nioBuffer());\n    }\n\n    @Test\n    public void testToByteBuffer2() {\n        assumeTrue(buffer.nioBufferCount() == 1);\n\n        byte[] value = new byte[buffer.capacity()];\n        random.nextBytes(value);\n        buffer.clear();\n        buffer.writeBytes(value);\n\n        for (int i = 0; i < buffer.capacity() - BLOCK_SIZE + 1; i += BLOCK_SIZE) {\n            assertRemainingEquals(ByteBuffer.wrap(value, i, BLOCK_SIZE), buffer.nioBuffer(i, BLOCK_SIZE));\n        }\n    }\n\n    private static void assertRemainingEquals(ByteBuffer expected, ByteBuffer actual) {\n        int remaining = expected.remaining();\n        int remaining2 = actual.remaining();\n\n        assertEquals(remaining, remaining2);\n        byte[] array1 = new byte[remaining];\n        byte[] array2 = new byte[remaining2];\n        expected.get(array1);\n        actual.get(array2);\n        assertArrayEquals(array1, array2);\n    }\n\n    @Test\n    public void testToByteBuffer3() {\n        assumeTrue(buffer.nioBufferCount() == 1);\n\n        assertEquals(buffer.order(), buffer.nioBuffer().order());\n    }\n\n    @Test\n    public void testSkipBytes1() {\n        buffer.setIndex(CAPACITY / 4, CAPACITY / 2);\n\n        buffer.skipBytes(CAPACITY / 4);\n        assertEquals(CAPACITY / 4 * 2, buffer.readerIndex());\n\n        try {\n            buffer.skipBytes(CAPACITY / 4 + 1);\n            fail();\n        } catch (IndexOutOfBoundsException e) {\n            // Expected\n        }\n\n        // Should remain unchanged.\n        assertEquals(CAPACITY / 4 * 2, buffer.readerIndex());\n    }\n\n    @Test\n    public void testHashCode() {\n        ByteBuf elemA = buffer(15);\n        ByteBuf elemB = directBuffer(15);\n        elemA.writeBytes(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5 });\n        elemB.writeBytes(new byte[] { 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 9 });\n\n        Set<ByteBuf> set = new HashSet<ByteBuf>();\n        set.add(elemA);\n        set.add(elemB);\n\n        assertEquals(2, set.size());\n        ByteBuf elemACopy = elemA.copy();\n        assertTrue(set.contains(elemACopy));\n\n        ByteBuf elemBCopy = elemB.copy();\n        assertTrue(set.contains(elemBCopy));\n\n        buffer.clear();\n        buffer.writeBytes(elemA.duplicate());\n\n        assertTrue(set.remove(buffer));\n        assertFalse(set.contains(elemA));\n        assertEquals(1, set.size());\n\n        buffer.clear();\n        buffer.writeBytes(elemB.duplicate());\n        assertTrue(set.remove(buffer));\n        assertFalse(set.contains(elemB));\n        assertEquals(0, set.size());\n        elemA.release();\n        elemB.release();\n        elemACopy.release();\n        elemBCopy.release();\n    }\n\n    // Test case for https://github.com/netty/netty/issues/325\n    @Test\n    public void testDiscardAllReadBytes() {\n        buffer.writerIndex(buffer.capacity());\n        buffer.readerIndex(buffer.writerIndex());\n        buffer.discardReadBytes();\n    }\n\n    @Test\n    public void testForEachByte() {\n        buffer.clear();\n        for (int i = 0; i < CAPACITY; i ++) {\n            buffer.writeByte(i + 1);\n        }\n\n        final AtomicInteger lastIndex = new AtomicInteger();\n        buffer.setIndex(CAPACITY / 4, CAPACITY * 3 / 4);\n        assertThat(buffer.forEachByte(new ByteProcessor() {\n            int i = CAPACITY / 4;\n\n            @Override\n            public boolean process(byte value) throws Exception {\n                assertThat(value, is((byte) (i + 1)));\n                lastIndex.set(i);\n                i ++;\n                return true;\n            }\n        }), is(-1));\n\n        assertThat(lastIndex.get(), is(CAPACITY * 3 / 4 - 1));\n    }\n\n    @Test\n    public void testForEachByteAbort() {\n        buffer.clear();\n        for (int i = 0; i < CAPACITY; i ++) {\n            buffer.writeByte(i + 1);\n        }\n\n        final int stop = CAPACITY / 2;\n        assertThat(buffer.forEachByte(CAPACITY / 3, CAPACITY / 3, new ByteProcessor() {\n            int i = CAPACITY / 3;\n\n            @Override\n            public boolean process(byte value) throws Exception {\n                assertThat(value, is((byte) (i + 1)));\n                if (i == stop) {\n                    return false;\n                }\n\n                i++;\n                return true;\n            }\n        }), is(stop));\n    }\n\n    @Test\n    public void testForEachByteDesc() {\n        buffer.clear();\n        for (int i = 0; i < CAPACITY; i ++) {\n            buffer.writeByte(i + 1);\n        }\n\n        final AtomicInteger lastIndex = new AtomicInteger();\n        assertThat(buffer.forEachByteDesc(CAPACITY / 4, CAPACITY * 2 / 4, new ByteProcessor() {\n            int i = CAPACITY * 3 / 4 - 1;\n\n            @Override\n            public boolean process(byte value) throws Exception {\n                assertThat(value, is((byte) (i + 1)));\n                lastIndex.set(i);\n                i --;\n                return true;\n            }\n        }), is(-1));\n\n        assertThat(lastIndex.get(), is(CAPACITY / 4));\n    }\n\n    @Test\n    public void testInternalNioBuffer() {\n        testInternalNioBuffer(128);\n        testInternalNioBuffer(1024);\n        testInternalNioBuffer(4 * 1024);\n        testInternalNioBuffer(64 * 1024);\n        testInternalNioBuffer(32 * 1024 * 1024);\n        testInternalNioBuffer(64 * 1024 * 1024);\n    }\n\n    private void testInternalNioBuffer(int a) {\n        ByteBuf buffer = newBuffer(2);\n        ByteBuffer buf = buffer.internalNioBuffer(buffer.readerIndex(), 1);\n        assertEquals(1, buf.remaining());\n\n        byte[] data = new byte[a];\n        PlatformDependent.threadLocalRandom().nextBytes(data);\n        buffer.writeBytes(data);\n\n        buf = buffer.internalNioBuffer(buffer.readerIndex(), a);\n        assertEquals(a, buf.remaining());\n\n        for (int i = 0; i < a; i++) {\n            assertEquals(data[i], buf.get());\n        }\n        assertFalse(buf.hasRemaining());\n        buffer.release();\n    }\n\n    @Test\n    public void testDuplicateReadGatheringByteChannelMultipleThreads() throws Exception {\n        testReadGatheringByteChannelMultipleThreads(false);\n    }\n\n    @Test\n    public void testSliceReadGatheringByteChannelMultipleThreads() throws Exception {\n        testReadGatheringByteChannelMultipleThreads(true);\n    }\n\n    private void testReadGatheringByteChannelMultipleThreads(final boolean slice) throws Exception {\n        final byte[] bytes = new byte[8];\n        random.nextBytes(bytes);\n\n        final ByteBuf buffer = newBuffer(8);\n        buffer.writeBytes(bytes);\n        final CountDownLatch latch = new CountDownLatch(60000);\n        final CyclicBarrier barrier = new CyclicBarrier(11);\n        for (int i = 0; i < 10; i++) {\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    while (latch.getCount() > 0) {\n                        ByteBuf buf;\n                        if (slice) {\n                           buf = buffer.slice();\n                        } else {\n                           buf = buffer.duplicate();\n                        }\n                        TestGatheringByteChannel channel = new TestGatheringByteChannel();\n\n                        while (buf.isReadable()) {\n                            try {\n                                buf.readBytes(channel, buf.readableBytes());\n                            } catch (IOException e) {\n                                // Never happens\n                                return;\n                            }\n                        }\n                        assertArrayEquals(bytes, channel.writtenBytes());\n                        latch.countDown();\n                    }\n                    try {\n                        barrier.await();\n                    } catch (Exception e) {\n                        // ignore\n                    }\n                }\n            }).start();\n        }\n        latch.await(10, TimeUnit.SECONDS);\n        barrier.await(5, TimeUnit.SECONDS);\n        buffer.release();\n    }\n\n    @Test\n    public void testDuplicateReadOutputStreamMultipleThreads() throws Exception {\n        testReadOutputStreamMultipleThreads(false);\n    }\n\n    @Test\n    public void testSliceReadOutputStreamMultipleThreads() throws Exception {\n        testReadOutputStreamMultipleThreads(true);\n    }\n\n    private void testReadOutputStreamMultipleThreads(final boolean slice) throws Exception {\n        final byte[] bytes = new byte[8];\n        random.nextBytes(bytes);\n\n        final ByteBuf buffer = newBuffer(8);\n        buffer.writeBytes(bytes);\n        final CountDownLatch latch = new CountDownLatch(60000);\n        final CyclicBarrier barrier = new CyclicBarrier(11);\n        for (int i = 0; i < 10; i++) {\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    while (latch.getCount() > 0) {\n                        ByteBuf buf;\n                        if (slice) {\n                            buf = buffer.slice();\n                        } else {\n                            buf = buffer.duplicate();\n                        }\n                        ByteArrayOutputStream out = new ByteArrayOutputStream();\n\n                        while (buf.isReadable()) {\n                            try {\n                                buf.readBytes(out, buf.readableBytes());\n                            } catch (IOException e) {\n                                // Never happens\n                                return;\n                            }\n                        }\n                        assertArrayEquals(bytes, out.toByteArray());\n                        latch.countDown();\n                    }\n                    try {\n                        barrier.await();\n                    } catch (Exception e) {\n                        // ignore\n                    }\n                }\n            }).start();\n        }\n        latch.await(10, TimeUnit.SECONDS);\n        barrier.await(5, TimeUnit.SECONDS);\n        buffer.release();\n    }\n\n    @Test\n    public void testDuplicateBytesInArrayMultipleThreads() throws Exception {\n        testBytesInArrayMultipleThreads(false);\n    }\n\n    @Test\n    public void testSliceBytesInArrayMultipleThreads() throws Exception {\n        testBytesInArrayMultipleThreads(true);\n    }\n\n    private void testBytesInArrayMultipleThreads(final boolean slice) throws Exception {\n        final byte[] bytes = new byte[8];\n        random.nextBytes(bytes);\n\n        final ByteBuf buffer = newBuffer(8);\n        buffer.writeBytes(bytes);\n        final AtomicReference<Throwable> cause = new AtomicReference<Throwable>();\n        final CountDownLatch latch = new CountDownLatch(60000);\n        final CyclicBarrier barrier = new CyclicBarrier(11);\n        for (int i = 0; i < 10; i++) {\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    while (cause.get() == null && latch.getCount() > 0) {\n                        ByteBuf buf;\n                        if (slice) {\n                            buf = buffer.slice();\n                        } else {\n                            buf = buffer.duplicate();\n                        }\n\n                        byte[] array = new byte[8];\n                        buf.readBytes(array);\n\n                        assertArrayEquals(bytes, array);\n\n                        Arrays.fill(array, (byte) 0);\n                        buf.getBytes(0, array);\n                        assertArrayEquals(bytes, array);\n\n                        latch.countDown();\n                    }\n                    try {\n                        barrier.await();\n                    } catch (Exception e) {\n                        // ignore\n                    }\n                }\n            }).start();\n        }\n        latch.await(10, TimeUnit.SECONDS);\n        barrier.await(5, TimeUnit.SECONDS);\n        assertNull(cause.get());\n        buffer.release();\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void readByteThrowsIndexOutOfBoundsException() {\n        final ByteBuf buffer = newBuffer(8);\n        try {\n            buffer.writeByte(0);\n            assertEquals((byte) 0, buffer.readByte());\n            buffer.readByte();\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test\n    @SuppressWarnings(\"ForLoopThatDoesntUseLoopVariable\")\n    public void testNioBufferExposeOnlyRegion() {\n        final ByteBuf buffer = newBuffer(8);\n        byte[] data = new byte[8];\n        random.nextBytes(data);\n        buffer.writeBytes(data);\n\n        ByteBuffer nioBuf = buffer.nioBuffer(1, data.length - 2);\n        assertEquals(0, nioBuf.position());\n        assertEquals(6, nioBuf.remaining());\n\n        for (int i = 1; nioBuf.hasRemaining(); i++) {\n            assertEquals(data[i], nioBuf.get());\n        }\n        buffer.release();\n    }\n\n    @Test\n    public void ensureWritableWithForceDoesNotThrow() {\n        ensureWritableDoesNotThrow(true);\n    }\n\n    @Test\n    public void ensureWritableWithOutForceDoesNotThrow() {\n        ensureWritableDoesNotThrow(false);\n    }\n\n    private void ensureWritableDoesNotThrow(boolean force) {\n        final ByteBuf buffer = newBuffer(8);\n        buffer.writerIndex(buffer.capacity());\n        buffer.ensureWritable(8, force);\n        buffer.release();\n    }\n\n    // See:\n    // - https://github.com/netty/netty/issues/2587\n    // - https://github.com/netty/netty/issues/2580\n    @Test\n    public void testLittleEndianWithExpand() {\n        ByteBuf buffer = newBuffer(0).order(LITTLE_ENDIAN);\n        buffer.writeInt(0x12345678);\n        assertEquals(\"78563412\", ByteBufUtil.hexDump(buffer));\n        buffer.release();\n    }\n\n    private ByteBuf releasedBuffer() {\n        ByteBuf buffer = newBuffer(8);\n        // Clear the buffer so we are sure the reader and writer indices are 0.\n        // This is important as we may return a slice from newBuffer(...).\n        buffer.clear();\n        assertTrue(buffer.release());\n        return buffer;\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testDiscardReadBytesAfterRelease() {\n        releasedBuffer().discardReadBytes();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testDiscardSomeReadBytesAfterRelease() {\n        releasedBuffer().discardSomeReadBytes();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testEnsureWritableAfterRelease() {\n        releasedBuffer().ensureWritable(16);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetBooleanAfterRelease() {\n        releasedBuffer().getBoolean(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetByteAfterRelease() {\n        releasedBuffer().getByte(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetUnsignedByteAfterRelease() {\n        releasedBuffer().getUnsignedByte(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetShortAfterRelease() {\n        releasedBuffer().getShort(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetShortLEAfterRelease() {\n        releasedBuffer().getShortLE(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetUnsignedShortAfterRelease() {\n        releasedBuffer().getUnsignedShort(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetUnsignedShortLEAfterRelease() {\n        releasedBuffer().getUnsignedShortLE(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetMediumAfterRelease() {\n        releasedBuffer().getMedium(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetMediumLEAfterRelease() {\n        releasedBuffer().getMediumLE(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetUnsignedMediumAfterRelease() {\n        releasedBuffer().getUnsignedMedium(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetIntAfterRelease() {\n        releasedBuffer().getInt(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetIntLEAfterRelease() {\n        releasedBuffer().getIntLE(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetUnsignedIntAfterRelease() {\n        releasedBuffer().getUnsignedInt(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetUnsignedIntLEAfterRelease() {\n        releasedBuffer().getUnsignedIntLE(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetLongAfterRelease() {\n        releasedBuffer().getLong(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetLongLEAfterRelease() {\n        releasedBuffer().getLongLE(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetCharAfterRelease() {\n        releasedBuffer().getChar(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetFloatAfterRelease() {\n        releasedBuffer().getFloat(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetFloatLEAfterRelease() {\n        releasedBuffer().getFloatLE(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetDoubleAfterRelease() {\n        releasedBuffer().getDouble(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetDoubleLEAfterRelease() {\n        releasedBuffer().getDoubleLE(0);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetBytesAfterRelease() {\n        ByteBuf buffer = buffer(8);\n        try {\n            releasedBuffer().getBytes(0, buffer);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetBytesAfterRelease2() {\n        ByteBuf buffer = buffer();\n        try {\n            releasedBuffer().getBytes(0, buffer, 1);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetBytesAfterRelease3() {\n        ByteBuf buffer = buffer();\n        try {\n            releasedBuffer().getBytes(0, buffer, 0, 1);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetBytesAfterRelease4() {\n        releasedBuffer().getBytes(0, new byte[8]);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetBytesAfterRelease5() {\n        releasedBuffer().getBytes(0, new byte[8], 0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetBytesAfterRelease6() {\n        releasedBuffer().getBytes(0, ByteBuffer.allocate(8));\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetBytesAfterRelease7() throws IOException {\n        releasedBuffer().getBytes(0, new ByteArrayOutputStream(), 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testGetBytesAfterRelease8() throws IOException {\n        releasedBuffer().getBytes(0, new DevNullGatheringByteChannel(), 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetBooleanAfterRelease() {\n        releasedBuffer().setBoolean(0, true);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetByteAfterRelease() {\n        releasedBuffer().setByte(0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetShortAfterRelease() {\n        releasedBuffer().setShort(0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetShortLEAfterRelease() {\n        releasedBuffer().setShortLE(0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetMediumAfterRelease() {\n        releasedBuffer().setMedium(0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetMediumLEAfterRelease() {\n        releasedBuffer().setMediumLE(0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetIntAfterRelease() {\n        releasedBuffer().setInt(0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetIntLEAfterRelease() {\n        releasedBuffer().setIntLE(0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetLongAfterRelease() {\n        releasedBuffer().setLong(0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetLongLEAfterRelease() {\n        releasedBuffer().setLongLE(0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetCharAfterRelease() {\n        releasedBuffer().setChar(0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetFloatAfterRelease() {\n        releasedBuffer().setFloat(0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetDoubleAfterRelease() {\n        releasedBuffer().setDouble(0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetBytesAfterRelease() {\n        ByteBuf buffer = buffer();\n        try {\n            releasedBuffer().setBytes(0, buffer);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetBytesAfterRelease2() {\n        ByteBuf buffer = buffer();\n        try {\n            releasedBuffer().setBytes(0, buffer, 1);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetBytesAfterRelease3() {\n        ByteBuf buffer = buffer();\n        try {\n            releasedBuffer().setBytes(0, buffer, 0, 1);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetUsAsciiCharSequenceAfterRelease() {\n        testSetCharSequenceAfterRelease0(CharsetUtil.US_ASCII);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetIso88591CharSequenceAfterRelease() {\n        testSetCharSequenceAfterRelease0(CharsetUtil.ISO_8859_1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetUtf8CharSequenceAfterRelease() {\n        testSetCharSequenceAfterRelease0(CharsetUtil.UTF_8);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetUtf16CharSequenceAfterRelease() {\n        testSetCharSequenceAfterRelease0(CharsetUtil.UTF_16);\n    }\n\n    private void testSetCharSequenceAfterRelease0(Charset charset) {\n        releasedBuffer().setCharSequence(0, \"x\", charset);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetBytesAfterRelease4() {\n        releasedBuffer().setBytes(0, new byte[8]);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetBytesAfterRelease5() {\n        releasedBuffer().setBytes(0, new byte[8], 0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetBytesAfterRelease6() {\n        releasedBuffer().setBytes(0, ByteBuffer.allocate(8));\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetBytesAfterRelease7() throws IOException {\n        releasedBuffer().setBytes(0, new ByteArrayInputStream(new byte[8]), 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetBytesAfterRelease8() throws IOException {\n        releasedBuffer().setBytes(0, new TestScatteringByteChannel(), 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSetZeroAfterRelease() {\n        releasedBuffer().setZero(0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadBooleanAfterRelease() {\n        releasedBuffer().readBoolean();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadByteAfterRelease() {\n        releasedBuffer().readByte();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadUnsignedByteAfterRelease() {\n        releasedBuffer().readUnsignedByte();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadShortAfterRelease() {\n        releasedBuffer().readShort();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadShortLEAfterRelease() {\n        releasedBuffer().readShortLE();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadUnsignedShortAfterRelease() {\n        releasedBuffer().readUnsignedShort();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadUnsignedShortLEAfterRelease() {\n        releasedBuffer().readUnsignedShortLE();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadMediumAfterRelease() {\n        releasedBuffer().readMedium();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadMediumLEAfterRelease() {\n        releasedBuffer().readMediumLE();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadUnsignedMediumAfterRelease() {\n        releasedBuffer().readUnsignedMedium();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadUnsignedMediumLEAfterRelease() {\n        releasedBuffer().readUnsignedMediumLE();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadIntAfterRelease() {\n        releasedBuffer().readInt();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadIntLEAfterRelease() {\n        releasedBuffer().readIntLE();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadUnsignedIntAfterRelease() {\n        releasedBuffer().readUnsignedInt();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadUnsignedIntLEAfterRelease() {\n        releasedBuffer().readUnsignedIntLE();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadLongAfterRelease() {\n        releasedBuffer().readLong();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadLongLEAfterRelease() {\n        releasedBuffer().readLongLE();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadCharAfterRelease() {\n        releasedBuffer().readChar();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadFloatAfterRelease() {\n        releasedBuffer().readFloat();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadFloatLEAfterRelease() {\n        releasedBuffer().readFloatLE();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadDoubleAfterRelease() {\n        releasedBuffer().readDouble();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadDoubleLEAfterRelease() {\n        releasedBuffer().readDoubleLE();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadBytesAfterRelease() {\n        releasedBuffer().readBytes(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadBytesAfterRelease2() {\n        ByteBuf buffer = buffer(8);\n        try {\n            releasedBuffer().readBytes(buffer);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadBytesAfterRelease3() {\n        ByteBuf buffer = buffer(8);\n        try {\n            releasedBuffer().readBytes(buffer);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadBytesAfterRelease4() {\n        ByteBuf buffer = buffer(8);\n        try {\n            releasedBuffer().readBytes(buffer, 0, 1);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadBytesAfterRelease5() {\n        releasedBuffer().readBytes(new byte[8]);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadBytesAfterRelease6() {\n        releasedBuffer().readBytes(new byte[8], 0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadBytesAfterRelease7() {\n        releasedBuffer().readBytes(ByteBuffer.allocate(8));\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadBytesAfterRelease8() throws IOException {\n        releasedBuffer().readBytes(new ByteArrayOutputStream(), 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadBytesAfterRelease9() throws IOException {\n        releasedBuffer().readBytes(new ByteArrayOutputStream(), 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testReadBytesAfterRelease10() throws IOException {\n        releasedBuffer().readBytes(new DevNullGatheringByteChannel(), 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteBooleanAfterRelease() {\n        releasedBuffer().writeBoolean(true);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteByteAfterRelease() {\n        releasedBuffer().writeByte(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteShortAfterRelease() {\n        releasedBuffer().writeShort(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteShortLEAfterRelease() {\n        releasedBuffer().writeShortLE(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteMediumAfterRelease() {\n        releasedBuffer().writeMedium(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteMediumLEAfterRelease() {\n        releasedBuffer().writeMediumLE(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteIntAfterRelease() {\n        releasedBuffer().writeInt(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteIntLEAfterRelease() {\n        releasedBuffer().writeIntLE(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteLongAfterRelease() {\n        releasedBuffer().writeLong(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteLongLEAfterRelease() {\n        releasedBuffer().writeLongLE(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteCharAfterRelease() {\n        releasedBuffer().writeChar(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteFloatAfterRelease() {\n        releasedBuffer().writeFloat(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteFloatLEAfterRelease() {\n        releasedBuffer().writeFloatLE(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteDoubleAfterRelease() {\n        releasedBuffer().writeDouble(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteDoubleLEAfterRelease() {\n        releasedBuffer().writeDoubleLE(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteBytesAfterRelease() {\n        ByteBuf buffer = buffer(8);\n        try {\n            releasedBuffer().writeBytes(buffer);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteBytesAfterRelease2() {\n        ByteBuf buffer = copiedBuffer(new byte[8]);\n        try {\n            releasedBuffer().writeBytes(buffer, 1);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteBytesAfterRelease3() {\n        ByteBuf buffer = buffer(8);\n        try {\n            releasedBuffer().writeBytes(buffer, 0, 1);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteBytesAfterRelease4() {\n        releasedBuffer().writeBytes(new byte[8]);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteBytesAfterRelease5() {\n        releasedBuffer().writeBytes(new byte[8], 0 , 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteBytesAfterRelease6() {\n        releasedBuffer().writeBytes(ByteBuffer.allocate(8));\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteBytesAfterRelease7() throws IOException {\n        releasedBuffer().writeBytes(new ByteArrayInputStream(new byte[8]), 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteBytesAfterRelease8() throws IOException {\n        releasedBuffer().writeBytes(new TestScatteringByteChannel(), 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteZeroAfterRelease() throws IOException {\n        releasedBuffer().writeZero(1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteUsAsciiCharSequenceAfterRelease() {\n        testWriteCharSequenceAfterRelease0(CharsetUtil.US_ASCII);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteIso88591CharSequenceAfterRelease() {\n        testWriteCharSequenceAfterRelease0(CharsetUtil.ISO_8859_1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteUtf8CharSequenceAfterRelease() {\n        testWriteCharSequenceAfterRelease0(CharsetUtil.UTF_8);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testWriteUtf16CharSequenceAfterRelease() {\n        testWriteCharSequenceAfterRelease0(CharsetUtil.UTF_16);\n    }\n\n    private void testWriteCharSequenceAfterRelease0(Charset charset) {\n        releasedBuffer().writeCharSequence(\"x\", charset);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testForEachByteAfterRelease() {\n        releasedBuffer().forEachByte(new TestByteProcessor());\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testForEachByteAfterRelease1() {\n        releasedBuffer().forEachByte(0, 1, new TestByteProcessor());\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testForEachByteDescAfterRelease() {\n        releasedBuffer().forEachByteDesc(new TestByteProcessor());\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testForEachByteDescAfterRelease1() {\n        releasedBuffer().forEachByteDesc(0, 1, new TestByteProcessor());\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testCopyAfterRelease() {\n        releasedBuffer().copy();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testCopyAfterRelease1() {\n        releasedBuffer().copy();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testNioBufferAfterRelease() {\n        releasedBuffer().nioBuffer();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testNioBufferAfterRelease1() {\n        releasedBuffer().nioBuffer(0, 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testInternalNioBufferAfterRelease() {\n        ByteBuf releasedBuffer = releasedBuffer();\n        releasedBuffer.internalNioBuffer(releasedBuffer.readerIndex(), 1);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testNioBuffersAfterRelease() {\n        releasedBuffer().nioBuffers();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testNioBuffersAfterRelease2() {\n        releasedBuffer().nioBuffers(0, 1);\n    }\n\n    @Test\n    public void testArrayAfterRelease() {\n        ByteBuf buf = releasedBuffer();\n        if (buf.hasArray()) {\n            try {\n                buf.array();\n                fail();\n            } catch (IllegalReferenceCountException e) {\n                // expected\n            }\n        }\n    }\n\n    @Test\n    public void testMemoryAddressAfterRelease() {\n        ByteBuf buf = releasedBuffer();\n        if (buf.hasMemoryAddress()) {\n            try {\n                buf.memoryAddress();\n                fail();\n            } catch (IllegalReferenceCountException e) {\n                // expected\n            }\n        }\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSliceAfterRelease() {\n        releasedBuffer().slice();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testSliceAfterRelease2() {\n        releasedBuffer().slice(0, 1);\n    }\n\n    private static void assertSliceFailAfterRelease(ByteBuf... bufs) {\n        for (ByteBuf buf : bufs) {\n            if (buf.refCnt() > 0) {\n                buf.release();\n            }\n        }\n        for (ByteBuf buf : bufs) {\n            try {\n                assertEquals(0, buf.refCnt());\n                buf.slice();\n                fail();\n            } catch (IllegalReferenceCountException ignored) {\n                // as expected\n            }\n        }\n    }\n\n    @Test\n    public void testSliceAfterReleaseRetainedSlice() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.retainedSlice(0, 1);\n        assertSliceFailAfterRelease(buf, buf2);\n    }\n\n    @Test\n    public void testSliceAfterReleaseRetainedSliceDuplicate() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.retainedSlice(0, 1);\n        ByteBuf buf3 = buf2.duplicate();\n        assertSliceFailAfterRelease(buf, buf2, buf3);\n    }\n\n    @Test\n    public void testSliceAfterReleaseRetainedSliceRetainedDuplicate() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.retainedSlice(0, 1);\n        ByteBuf buf3 = buf2.retainedDuplicate();\n        assertSliceFailAfterRelease(buf, buf2, buf3);\n    }\n\n    @Test\n    public void testSliceAfterReleaseRetainedDuplicate() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.retainedDuplicate();\n        assertSliceFailAfterRelease(buf, buf2);\n    }\n\n    @Test\n    public void testSliceAfterReleaseRetainedDuplicateSlice() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.retainedDuplicate();\n        ByteBuf buf3 = buf2.slice(0, 1);\n        assertSliceFailAfterRelease(buf, buf2, buf3);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testRetainedSliceAfterRelease() {\n        releasedBuffer().retainedSlice();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testRetainedSliceAfterRelease2() {\n        releasedBuffer().retainedSlice(0, 1);\n    }\n\n    private static void assertRetainedSliceFailAfterRelease(ByteBuf... bufs) {\n        for (ByteBuf buf : bufs) {\n            if (buf.refCnt() > 0) {\n                buf.release();\n            }\n        }\n        for (ByteBuf buf : bufs) {\n            try {\n                assertEquals(0, buf.refCnt());\n                buf.retainedSlice();\n                fail();\n            } catch (IllegalReferenceCountException ignored) {\n                // as expected\n            }\n        }\n    }\n\n    @Test\n    public void testRetainedSliceAfterReleaseRetainedSlice() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.retainedSlice(0, 1);\n        assertRetainedSliceFailAfterRelease(buf, buf2);\n    }\n\n    @Test\n    public void testRetainedSliceAfterReleaseRetainedSliceDuplicate() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.retainedSlice(0, 1);\n        ByteBuf buf3 = buf2.duplicate();\n        assertRetainedSliceFailAfterRelease(buf, buf2, buf3);\n    }\n\n    @Test\n    public void testRetainedSliceAfterReleaseRetainedSliceRetainedDuplicate() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.retainedSlice(0, 1);\n        ByteBuf buf3 = buf2.retainedDuplicate();\n        assertRetainedSliceFailAfterRelease(buf, buf2, buf3);\n    }\n\n    @Test\n    public void testRetainedSliceAfterReleaseRetainedDuplicate() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.retainedDuplicate();\n        assertRetainedSliceFailAfterRelease(buf, buf2);\n    }\n\n    @Test\n    public void testRetainedSliceAfterReleaseRetainedDuplicateSlice() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.retainedDuplicate();\n        ByteBuf buf3 = buf2.slice(0, 1);\n        assertRetainedSliceFailAfterRelease(buf, buf2, buf3);\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testDuplicateAfterRelease() {\n        releasedBuffer().duplicate();\n    }\n\n    @Test(expected = IllegalReferenceCountException.class)\n    public void testRetainedDuplicateAfterRelease() {\n        releasedBuffer().retainedDuplicate();\n    }\n\n    private static void assertDuplicateFailAfterRelease(ByteBuf... bufs) {\n        for (ByteBuf buf : bufs) {\n            if (buf.refCnt() > 0) {\n                buf.release();\n            }\n        }\n        for (ByteBuf buf : bufs) {\n            try {\n                assertEquals(0, buf.refCnt());\n                buf.duplicate();\n                fail();\n            } catch (IllegalReferenceCountException ignored) {\n                // as expected\n            }\n        }\n    }\n\n    @Test\n    public void testDuplicateAfterReleaseRetainedSliceDuplicate() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.retainedSlice(0, 1);\n        ByteBuf buf3 = buf2.duplicate();\n        assertDuplicateFailAfterRelease(buf, buf2, buf3);\n    }\n\n    @Test\n    public void testDuplicateAfterReleaseRetainedDuplicate() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.retainedDuplicate();\n        assertDuplicateFailAfterRelease(buf, buf2);\n    }\n\n    @Test\n    public void testDuplicateAfterReleaseRetainedDuplicateSlice() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.retainedDuplicate();\n        ByteBuf buf3 = buf2.slice(0, 1);\n        assertDuplicateFailAfterRelease(buf, buf2, buf3);\n    }\n\n    private static void assertRetainedDuplicateFailAfterRelease(ByteBuf... bufs) {\n        for (ByteBuf buf : bufs) {\n            if (buf.refCnt() > 0) {\n                buf.release();\n            }\n        }\n        for (ByteBuf buf : bufs) {\n            try {\n                assertEquals(0, buf.refCnt());\n                buf.retainedDuplicate();\n                fail();\n            } catch (IllegalReferenceCountException ignored) {\n                // as expected\n            }\n        }\n    }\n\n    @Test\n    public void testRetainedDuplicateAfterReleaseRetainedDuplicate() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.retainedDuplicate();\n        assertRetainedDuplicateFailAfterRelease(buf, buf2);\n    }\n\n    @Test\n    public void testRetainedDuplicateAfterReleaseDuplicate() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.duplicate();\n        assertRetainedDuplicateFailAfterRelease(buf, buf2);\n    }\n\n    @Test\n    public void testRetainedDuplicateAfterReleaseRetainedSlice() {\n        ByteBuf buf = newBuffer(1);\n        ByteBuf buf2 = buf.retainedSlice(0, 1);\n        assertRetainedDuplicateFailAfterRelease(buf, buf2);\n    }\n\n    @Test\n    public void testSliceRelease() {\n        ByteBuf buf = newBuffer(8);\n        assertEquals(1, buf.refCnt());\n        assertTrue(buf.slice().release());\n        assertEquals(0, buf.refCnt());\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testReadSliceOutOfBounds() {\n        testReadSliceOutOfBounds(false);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testReadRetainedSliceOutOfBounds() {\n        testReadSliceOutOfBounds(true);\n    }\n\n    private void testReadSliceOutOfBounds(boolean retainedSlice) {\n        ByteBuf buf = newBuffer(100);\n        try {\n            buf.writeZero(50);\n            if (retainedSlice) {\n                buf.readRetainedSlice(51);\n            } else {\n                buf.readSlice(51);\n            }\n            fail();\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test\n    public void testWriteUsAsciiCharSequenceExpand() {\n        testWriteCharSequenceExpand(CharsetUtil.US_ASCII);\n    }\n\n    @Test\n    public void testWriteUtf8CharSequenceExpand() {\n        testWriteCharSequenceExpand(CharsetUtil.UTF_8);\n    }\n\n    @Test\n    public void testWriteIso88591CharSequenceExpand() {\n        testWriteCharSequenceExpand(CharsetUtil.ISO_8859_1);\n    }\n    @Test\n    public void testWriteUtf16CharSequenceExpand() {\n        testWriteCharSequenceExpand(CharsetUtil.UTF_16);\n    }\n\n    private void testWriteCharSequenceExpand(Charset charset) {\n        ByteBuf buf = newBuffer(1);\n        try {\n            int writerIndex = buf.capacity() - 1;\n            buf.writerIndex(writerIndex);\n            int written = buf.writeCharSequence(\"AB\", charset);\n            assertEquals(writerIndex, buf.writerIndex() - written);\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testSetUsAsciiCharSequenceNoExpand() {\n        testSetCharSequenceNoExpand(CharsetUtil.US_ASCII);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testSetUtf8CharSequenceNoExpand() {\n        testSetCharSequenceNoExpand(CharsetUtil.UTF_8);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testSetIso88591CharSequenceNoExpand() {\n        testSetCharSequenceNoExpand(CharsetUtil.ISO_8859_1);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testSetUtf16CharSequenceNoExpand() {\n        testSetCharSequenceNoExpand(CharsetUtil.UTF_16);\n    }\n\n    private void testSetCharSequenceNoExpand(Charset charset) {\n        ByteBuf buf = newBuffer(1);\n        try {\n            buf.setCharSequence(0, \"AB\", charset);\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test\n    public void testSetUsAsciiCharSequence() {\n        testSetGetCharSequence(CharsetUtil.US_ASCII);\n    }\n\n    @Test\n    public void testSetUtf8CharSequence() {\n        testSetGetCharSequence(CharsetUtil.UTF_8);\n    }\n\n    @Test\n    public void testSetIso88591CharSequence() {\n        testSetGetCharSequence(CharsetUtil.ISO_8859_1);\n    }\n\n    @Test\n    public void testSetUtf16CharSequence() {\n        testSetGetCharSequence(CharsetUtil.UTF_16);\n    }\n\n    private static final CharBuffer EXTENDED_ASCII_CHARS, ASCII_CHARS;\n\n    static {\n        char[] chars = new char[256];\n        for (char c = 0; c < chars.length; c++) {\n            chars[c] = c;\n        }\n        EXTENDED_ASCII_CHARS = CharBuffer.wrap(chars);\n        ASCII_CHARS = CharBuffer.wrap(chars, 0, 128);\n    }\n\n    private void testSetGetCharSequence(Charset charset) {\n        ByteBuf buf = newBuffer(1024);\n        CharBuffer sequence = CharsetUtil.US_ASCII.equals(charset)\n                ? ASCII_CHARS : EXTENDED_ASCII_CHARS;\n        int bytes = buf.setCharSequence(1, sequence, charset);\n        assertEquals(sequence, CharBuffer.wrap(buf.getCharSequence(1, bytes, charset)));\n        buf.release();\n    }\n\n    @Test\n    public void testWriteReadUsAsciiCharSequence() {\n        testWriteReadCharSequence(CharsetUtil.US_ASCII);\n    }\n\n    @Test\n    public void testWriteReadUtf8CharSequence() {\n        testWriteReadCharSequence(CharsetUtil.UTF_8);\n    }\n\n    @Test\n    public void testWriteReadIso88591CharSequence() {\n        testWriteReadCharSequence(CharsetUtil.ISO_8859_1);\n    }\n\n    @Test\n    public void testWriteReadUtf16CharSequence() {\n        testWriteReadCharSequence(CharsetUtil.UTF_16);\n    }\n\n    private void testWriteReadCharSequence(Charset charset) {\n        ByteBuf buf = newBuffer(1024);\n        CharBuffer sequence = CharsetUtil.US_ASCII.equals(charset)\n                ? ASCII_CHARS : EXTENDED_ASCII_CHARS;\n        buf.writerIndex(1);\n        int bytes = buf.writeCharSequence(sequence, charset);\n        buf.readerIndex(1);\n        assertEquals(sequence, CharBuffer.wrap(buf.readCharSequence(bytes, charset)));\n        buf.release();\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testRetainedSliceIndexOutOfBounds() {\n        testSliceOutOfBounds(true, true, true);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testRetainedSliceLengthOutOfBounds() {\n        testSliceOutOfBounds(true, true, false);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testMixedSliceAIndexOutOfBounds() {\n        testSliceOutOfBounds(true, false, true);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testMixedSliceALengthOutOfBounds() {\n        testSliceOutOfBounds(true, false, false);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testMixedSliceBIndexOutOfBounds() {\n        testSliceOutOfBounds(false, true, true);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testMixedSliceBLengthOutOfBounds() {\n        testSliceOutOfBounds(false, true, false);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testSliceIndexOutOfBounds() {\n        testSliceOutOfBounds(false, false, true);\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testSliceLengthOutOfBounds() {\n        testSliceOutOfBounds(false, false, false);\n    }\n\n    @Test\n    public void testRetainedSliceAndRetainedDuplicateContentIsExpected() {\n        ByteBuf buf = newBuffer(8).resetWriterIndex();\n        ByteBuf expected1 = newBuffer(6).resetWriterIndex();\n        ByteBuf expected2 = newBuffer(5).resetWriterIndex();\n        ByteBuf expected3 = newBuffer(4).resetWriterIndex();\n        ByteBuf expected4 = newBuffer(3).resetWriterIndex();\n        buf.writeBytes(new byte[] {1, 2, 3, 4, 5, 6, 7, 8});\n        expected1.writeBytes(new byte[] {2, 3, 4, 5, 6, 7});\n        expected2.writeBytes(new byte[] {3, 4, 5, 6, 7});\n        expected3.writeBytes(new byte[] {4, 5, 6, 7});\n        expected4.writeBytes(new byte[] {5, 6, 7});\n\n        ByteBuf slice1 = buf.retainedSlice(buf.readerIndex() + 1, 6);\n        assertEquals(0, slice1.compareTo(expected1));\n        assertEquals(0, slice1.compareTo(buf.slice(buf.readerIndex() + 1, 6)));\n        // Simulate a handler that releases the original buffer, and propagates a slice.\n        buf.release();\n\n        // Advance the reader index on the slice.\n        slice1.readByte();\n\n        ByteBuf dup1 = slice1.retainedDuplicate();\n        assertEquals(0, dup1.compareTo(expected2));\n        assertEquals(0, dup1.compareTo(slice1.duplicate()));\n\n        // Advance the reader index on dup1.\n        dup1.readByte();\n\n        ByteBuf dup2 = dup1.duplicate();\n        assertEquals(0, dup2.compareTo(expected3));\n\n        // Advance the reader index on dup2.\n        dup2.readByte();\n\n        ByteBuf slice2 = dup2.retainedSlice(dup2.readerIndex(), 3);\n        assertEquals(0, slice2.compareTo(expected4));\n        assertEquals(0, slice2.compareTo(dup2.slice(dup2.readerIndex(), 3)));\n\n        // Cleanup the expected buffers used for testing.\n        assertTrue(expected1.release());\n        assertTrue(expected2.release());\n        assertTrue(expected3.release());\n        assertTrue(expected4.release());\n\n        slice2.release();\n        dup2.release();\n\n        assertEquals(slice2.refCnt(), dup2.refCnt());\n        assertEquals(dup2.refCnt(), dup1.refCnt());\n\n        // The handler is now done with the original slice\n        assertTrue(slice1.release());\n\n        // Reference counting may be shared, or may be independently tracked, but at this point all buffers should\n        // be deallocated and have a reference count of 0.\n        assertEquals(0, buf.refCnt());\n        assertEquals(0, slice1.refCnt());\n        assertEquals(0, slice2.refCnt());\n        assertEquals(0, dup1.refCnt());\n        assertEquals(0, dup2.refCnt());\n    }\n\n    @Test\n    public void testRetainedDuplicateAndRetainedSliceContentIsExpected() {\n        ByteBuf buf = newBuffer(8).resetWriterIndex();\n        ByteBuf expected1 = newBuffer(6).resetWriterIndex();\n        ByteBuf expected2 = newBuffer(5).resetWriterIndex();\n        ByteBuf expected3 = newBuffer(4).resetWriterIndex();\n        buf.writeBytes(new byte[] {1, 2, 3, 4, 5, 6, 7, 8});\n        expected1.writeBytes(new byte[] {2, 3, 4, 5, 6, 7});\n        expected2.writeBytes(new byte[] {3, 4, 5, 6, 7});\n        expected3.writeBytes(new byte[] {5, 6, 7});\n\n        ByteBuf dup1 = buf.retainedDuplicate();\n        assertEquals(0, dup1.compareTo(buf));\n        assertEquals(0, dup1.compareTo(buf.slice()));\n        // Simulate a handler that releases the original buffer, and propagates a slice.\n        buf.release();\n\n        // Advance the reader index on the dup.\n        dup1.readByte();\n\n        ByteBuf slice1 = dup1.retainedSlice(dup1.readerIndex(), 6);\n        assertEquals(0, slice1.compareTo(expected1));\n        assertEquals(0, slice1.compareTo(slice1.duplicate()));\n\n        // Advance the reader index on slice1.\n        slice1.readByte();\n\n        ByteBuf dup2 = slice1.duplicate();\n        assertEquals(0, dup2.compareTo(slice1));\n\n        // Advance the reader index on dup2.\n        dup2.readByte();\n\n        ByteBuf slice2 = dup2.retainedSlice(dup2.readerIndex() + 1, 3);\n        assertEquals(0, slice2.compareTo(expected3));\n        assertEquals(0, slice2.compareTo(dup2.slice(dup2.readerIndex() + 1, 3)));\n\n        // Cleanup the expected buffers used for testing.\n        assertTrue(expected1.release());\n        assertTrue(expected2.release());\n        assertTrue(expected3.release());\n\n        slice2.release();\n        slice1.release();\n\n        assertEquals(slice2.refCnt(), dup2.refCnt());\n        assertEquals(dup2.refCnt(), slice1.refCnt());\n\n        // The handler is now done with the original slice\n        assertTrue(dup1.release());\n\n        // Reference counting may be shared, or may be independently tracked, but at this point all buffers should\n        // be deallocated and have a reference count of 0.\n        assertEquals(0, buf.refCnt());\n        assertEquals(0, slice1.refCnt());\n        assertEquals(0, slice2.refCnt());\n        assertEquals(0, dup1.refCnt());\n        assertEquals(0, dup2.refCnt());\n    }\n\n    @Test\n    public void testRetainedSliceContents() {\n        testSliceContents(true);\n    }\n\n    @Test\n    public void testMultipleLevelRetainedSlice1() {\n        testMultipleLevelRetainedSliceWithNonRetained(true, true);\n    }\n\n    @Test\n    public void testMultipleLevelRetainedSlice2() {\n        testMultipleLevelRetainedSliceWithNonRetained(true, false);\n    }\n\n    @Test\n    public void testMultipleLevelRetainedSlice3() {\n        testMultipleLevelRetainedSliceWithNonRetained(false, true);\n    }\n\n    @Test\n    public void testMultipleLevelRetainedSlice4() {\n        testMultipleLevelRetainedSliceWithNonRetained(false, false);\n    }\n\n    @Test\n    public void testRetainedSliceReleaseOriginal1() {\n        testSliceReleaseOriginal(true, true);\n    }\n\n    @Test\n    public void testRetainedSliceReleaseOriginal2() {\n        testSliceReleaseOriginal(true, false);\n    }\n\n    @Test\n    public void testRetainedSliceReleaseOriginal3() {\n        testSliceReleaseOriginal(false, true);\n    }\n\n    @Test\n    public void testRetainedSliceReleaseOriginal4() {\n        testSliceReleaseOriginal(false, false);\n    }\n\n    @Test\n    public void testRetainedDuplicateReleaseOriginal1() {\n        testDuplicateReleaseOriginal(true, true);\n    }\n\n    @Test\n    public void testRetainedDuplicateReleaseOriginal2() {\n        testDuplicateReleaseOriginal(true, false);\n    }\n\n    @Test\n    public void testRetainedDuplicateReleaseOriginal3() {\n        testDuplicateReleaseOriginal(false, true);\n    }\n\n    @Test\n    public void testRetainedDuplicateReleaseOriginal4() {\n        testDuplicateReleaseOriginal(false, false);\n    }\n\n    @Test\n    public void testMultipleRetainedSliceReleaseOriginal1() {\n        testMultipleRetainedSliceReleaseOriginal(true, true);\n    }\n\n    @Test\n    public void testMultipleRetainedSliceReleaseOriginal2() {\n        testMultipleRetainedSliceReleaseOriginal(true, false);\n    }\n\n    @Test\n    public void testMultipleRetainedSliceReleaseOriginal3() {\n        testMultipleRetainedSliceReleaseOriginal(false, true);\n    }\n\n    @Test\n    public void testMultipleRetainedSliceReleaseOriginal4() {\n        testMultipleRetainedSliceReleaseOriginal(false, false);\n    }\n\n    @Test\n    public void testMultipleRetainedDuplicateReleaseOriginal1() {\n        testMultipleRetainedDuplicateReleaseOriginal(true, true);\n    }\n\n    @Test\n    public void testMultipleRetainedDuplicateReleaseOriginal2() {\n        testMultipleRetainedDuplicateReleaseOriginal(true, false);\n    }\n\n    @Test\n    public void testMultipleRetainedDuplicateReleaseOriginal3() {\n        testMultipleRetainedDuplicateReleaseOriginal(false, true);\n    }\n\n    @Test\n    public void testMultipleRetainedDuplicateReleaseOriginal4() {\n        testMultipleRetainedDuplicateReleaseOriginal(false, false);\n    }\n\n    @Test\n    public void testSliceContents() {\n        testSliceContents(false);\n    }\n\n    @Test\n    public void testRetainedDuplicateContents() {\n        testDuplicateContents(true);\n    }\n\n    @Test\n    public void testDuplicateContents() {\n        testDuplicateContents(false);\n    }\n\n    @Test\n    public void testDuplicateCapacityChange() {\n        testDuplicateCapacityChange(false);\n    }\n\n    @Test\n    public void testRetainedDuplicateCapacityChange() {\n        testDuplicateCapacityChange(true);\n    }\n\n    @Test(expected = UnsupportedOperationException.class)\n    public void testSliceCapacityChange() {\n        testSliceCapacityChange(false);\n    }\n\n    @Test(expected = UnsupportedOperationException.class)\n    public void testRetainedSliceCapacityChange() {\n        testSliceCapacityChange(true);\n    }\n\n    @Test\n    public void testRetainedSliceUnreleasable1() {\n        testRetainedSliceUnreleasable(true, true);\n    }\n\n    @Test\n    public void testRetainedSliceUnreleasable2() {\n        testRetainedSliceUnreleasable(true, false);\n    }\n\n    @Test\n    public void testRetainedSliceUnreleasable3() {\n        testRetainedSliceUnreleasable(false, true);\n    }\n\n    @Test\n    public void testRetainedSliceUnreleasable4() {\n        testRetainedSliceUnreleasable(false, false);\n    }\n\n    @Test\n    public void testReadRetainedSliceUnreleasable1() {\n        testReadRetainedSliceUnreleasable(true, true);\n    }\n\n    @Test\n    public void testReadRetainedSliceUnreleasable2() {\n        testReadRetainedSliceUnreleasable(true, false);\n    }\n\n    @Test\n    public void testReadRetainedSliceUnreleasable3() {\n        testReadRetainedSliceUnreleasable(false, true);\n    }\n\n    @Test\n    public void testReadRetainedSliceUnreleasable4() {\n        testReadRetainedSliceUnreleasable(false, false);\n    }\n\n    @Test\n    public void testRetainedDuplicateUnreleasable1() {\n        testRetainedDuplicateUnreleasable(true, true);\n    }\n\n    @Test\n    public void testRetainedDuplicateUnreleasable2() {\n        testRetainedDuplicateUnreleasable(true, false);\n    }\n\n    @Test\n    public void testRetainedDuplicateUnreleasable3() {\n        testRetainedDuplicateUnreleasable(false, true);\n    }\n\n    @Test\n    public void testRetainedDuplicateUnreleasable4() {\n        testRetainedDuplicateUnreleasable(false, false);\n    }\n\n    private void testRetainedSliceUnreleasable(boolean initRetainedSlice, boolean finalRetainedSlice) {\n        ByteBuf buf = newBuffer(8);\n        ByteBuf buf1 = initRetainedSlice ? buf.retainedSlice() : buf.slice().retain();\n        ByteBuf buf2 = unreleasableBuffer(buf1);\n        ByteBuf buf3 = finalRetainedSlice ? buf2.retainedSlice() : buf2.slice().retain();\n        assertFalse(buf3.release());\n        assertFalse(buf2.release());\n        buf1.release();\n        assertTrue(buf.release());\n        assertEquals(0, buf1.refCnt());\n        assertEquals(0, buf.refCnt());\n    }\n\n    private void testReadRetainedSliceUnreleasable(boolean initRetainedSlice, boolean finalRetainedSlice) {\n        ByteBuf buf = newBuffer(8);\n        ByteBuf buf1 = initRetainedSlice ? buf.retainedSlice() : buf.slice().retain();\n        ByteBuf buf2 = unreleasableBuffer(buf1);\n        ByteBuf buf3 = finalRetainedSlice ? buf2.readRetainedSlice(buf2.readableBytes())\n                                          : buf2.readSlice(buf2.readableBytes()).retain();\n        assertFalse(buf3.release());\n        assertFalse(buf2.release());\n        buf1.release();\n        assertTrue(buf.release());\n        assertEquals(0, buf1.refCnt());\n        assertEquals(0, buf.refCnt());\n    }\n\n    private void testRetainedDuplicateUnreleasable(boolean initRetainedDuplicate, boolean finalRetainedDuplicate) {\n        ByteBuf buf = newBuffer(8);\n        ByteBuf buf1 = initRetainedDuplicate ? buf.retainedDuplicate() : buf.duplicate().retain();\n        ByteBuf buf2 = unreleasableBuffer(buf1);\n        ByteBuf buf3 = finalRetainedDuplicate ? buf2.retainedDuplicate() : buf2.duplicate().retain();\n        assertFalse(buf3.release());\n        assertFalse(buf2.release());\n        buf1.release();\n        assertTrue(buf.release());\n        assertEquals(0, buf1.refCnt());\n        assertEquals(0, buf.refCnt());\n    }\n\n    private void testDuplicateCapacityChange(boolean retainedDuplicate) {\n        ByteBuf buf = newBuffer(8);\n        ByteBuf dup = retainedDuplicate ? buf.retainedDuplicate() : buf.duplicate();\n        try {\n            dup.capacity(10);\n            assertEquals(buf.capacity(), dup.capacity());\n            dup.capacity(5);\n            assertEquals(buf.capacity(), dup.capacity());\n        } finally {\n            if (retainedDuplicate) {\n                dup.release();\n            }\n            buf.release();\n        }\n    }\n\n    private void testSliceCapacityChange(boolean retainedSlice) {\n        ByteBuf buf = newBuffer(8);\n        ByteBuf slice = retainedSlice ? buf.retainedSlice(buf.readerIndex() + 1, 3)\n                                      : buf.slice(buf.readerIndex() + 1, 3);\n        try {\n            slice.capacity(10);\n        } finally {\n            if (retainedSlice) {\n                slice.release();\n            }\n            buf.release();\n        }\n    }\n\n    private void testSliceOutOfBounds(boolean initRetainedSlice, boolean finalRetainedSlice, boolean indexOutOfBounds) {\n        ByteBuf buf = newBuffer(8);\n        ByteBuf slice = initRetainedSlice ? buf.retainedSlice(buf.readerIndex() + 1, 2)\n                                          : buf.slice(buf.readerIndex() + 1, 2);\n        try {\n            assertEquals(2, slice.capacity());\n            assertEquals(2, slice.maxCapacity());\n            final int index = indexOutOfBounds ? 3 : 0;\n            final int length = indexOutOfBounds ? 0 : 3;\n            if (finalRetainedSlice) {\n                // This is expected to fail ... so no need to release.\n                slice.retainedSlice(index, length);\n            } else {\n                slice.slice(index, length);\n            }\n        } finally {\n            if (initRetainedSlice) {\n                slice.release();\n            }\n            buf.release();\n        }\n    }\n\n    private void testSliceContents(boolean retainedSlice) {\n        ByteBuf buf = newBuffer(8).resetWriterIndex();\n        ByteBuf expected = newBuffer(3).resetWriterIndex();\n        buf.writeBytes(new byte[] {1, 2, 3, 4, 5, 6, 7, 8});\n        expected.writeBytes(new byte[] {4, 5, 6});\n        ByteBuf slice = retainedSlice ? buf.retainedSlice(buf.readerIndex() + 3, 3)\n                                      : buf.slice(buf.readerIndex() + 3, 3);\n        try {\n            assertEquals(0, slice.compareTo(expected));\n            assertEquals(0, slice.compareTo(slice.duplicate()));\n            ByteBuf b = slice.retainedDuplicate();\n            assertEquals(0, slice.compareTo(b));\n            b.release();\n            assertEquals(0, slice.compareTo(slice.slice(0, slice.capacity())));\n        } finally {\n            if (retainedSlice) {\n                slice.release();\n            }\n            buf.release();\n            expected.release();\n        }\n    }\n\n    private void testSliceReleaseOriginal(boolean retainedSlice1, boolean retainedSlice2) {\n        ByteBuf buf = newBuffer(8).resetWriterIndex();\n        ByteBuf expected1 = newBuffer(3).resetWriterIndex();\n        ByteBuf expected2 = newBuffer(2).resetWriterIndex();\n        buf.writeBytes(new byte[] {1, 2, 3, 4, 5, 6, 7, 8});\n        expected1.writeBytes(new byte[] {6, 7, 8});\n        expected2.writeBytes(new byte[] {7, 8});\n        ByteBuf slice1 = retainedSlice1 ? buf.retainedSlice(buf.readerIndex() + 5, 3)\n                                        : buf.slice(buf.readerIndex() + 5, 3).retain();\n        assertEquals(0, slice1.compareTo(expected1));\n        // Simulate a handler that releases the original buffer, and propagates a slice.\n        buf.release();\n\n        ByteBuf slice2 = retainedSlice2 ? slice1.retainedSlice(slice1.readerIndex() + 1, 2)\n                                        : slice1.slice(slice1.readerIndex() + 1, 2).retain();\n        assertEquals(0, slice2.compareTo(expected2));\n\n        // Cleanup the expected buffers used for testing.\n        assertTrue(expected1.release());\n        assertTrue(expected2.release());\n\n        // The handler created a slice of the slice and is now done with it.\n        slice2.release();\n\n        // The handler is now done with the original slice\n        assertTrue(slice1.release());\n\n        // Reference counting may be shared, or may be independently tracked, but at this point all buffers should\n        // be deallocated and have a reference count of 0.\n        assertEquals(0, buf.refCnt());\n        assertEquals(0, slice1.refCnt());\n        assertEquals(0, slice2.refCnt());\n    }\n\n    private void testMultipleLevelRetainedSliceWithNonRetained(boolean doSlice1, boolean doSlice2) {\n        ByteBuf buf = newBuffer(8).resetWriterIndex();\n        ByteBuf expected1 = newBuffer(6).resetWriterIndex();\n        ByteBuf expected2 = newBuffer(4).resetWriterIndex();\n        ByteBuf expected3 = newBuffer(2).resetWriterIndex();\n        ByteBuf expected4SliceSlice = newBuffer(1).resetWriterIndex();\n        ByteBuf expected4DupSlice = newBuffer(1).resetWriterIndex();\n        buf.writeBytes(new byte[] {1, 2, 3, 4, 5, 6, 7, 8});\n        expected1.writeBytes(new byte[] {2, 3, 4, 5, 6, 7});\n        expected2.writeBytes(new byte[] {3, 4, 5, 6});\n        expected3.writeBytes(new byte[] {4, 5});\n        expected4SliceSlice.writeBytes(new byte[] {5});\n        expected4DupSlice.writeBytes(new byte[] {4});\n\n        ByteBuf slice1 = buf.retainedSlice(buf.readerIndex() + 1, 6);\n        assertEquals(0, slice1.compareTo(expected1));\n        // Simulate a handler that releases the original buffer, and propagates a slice.\n        buf.release();\n\n        ByteBuf slice2 = slice1.retainedSlice(slice1.readerIndex() + 1, 4);\n        assertEquals(0, slice2.compareTo(expected2));\n        assertEquals(0, slice2.compareTo(slice2.duplicate()));\n        assertEquals(0, slice2.compareTo(slice2.slice()));\n\n        ByteBuf tmpBuf = slice2.retainedDuplicate();\n        assertEquals(0, slice2.compareTo(tmpBuf));\n        tmpBuf.release();\n        tmpBuf = slice2.retainedSlice();\n        assertEquals(0, slice2.compareTo(tmpBuf));\n        tmpBuf.release();\n\n        ByteBuf slice3 = doSlice1 ? slice2.slice(slice2.readerIndex() + 1, 2) : slice2.duplicate();\n        if (doSlice1) {\n            assertEquals(0, slice3.compareTo(expected3));\n        } else {\n            assertEquals(0, slice3.compareTo(expected2));\n        }\n\n        ByteBuf slice4 = doSlice2 ? slice3.slice(slice3.readerIndex() + 1, 1) : slice3.duplicate();\n        if (doSlice1 && doSlice2) {\n            assertEquals(0, slice4.compareTo(expected4SliceSlice));\n        } else if (doSlice2) {\n            assertEquals(0, slice4.compareTo(expected4DupSlice));\n        } else {\n            assertEquals(0, slice3.compareTo(slice4));\n        }\n\n        // Cleanup the expected buffers used for testing.\n        assertTrue(expected1.release());\n        assertTrue(expected2.release());\n        assertTrue(expected3.release());\n        assertTrue(expected4SliceSlice.release());\n        assertTrue(expected4DupSlice.release());\n\n        // Slice 4, 3, and 2 should effectively \"share\" a reference count.\n        slice4.release();\n        assertEquals(slice3.refCnt(), slice2.refCnt());\n        assertEquals(slice3.refCnt(), slice4.refCnt());\n\n        // Slice 1 should also release the original underlying buffer without throwing exceptions\n        assertTrue(slice1.release());\n\n        // Reference counting may be shared, or may be independently tracked, but at this point all buffers should\n        // be deallocated and have a reference count of 0.\n        assertEquals(0, buf.refCnt());\n        assertEquals(0, slice1.refCnt());\n        assertEquals(0, slice2.refCnt());\n        assertEquals(0, slice3.refCnt());\n    }\n\n    private void testDuplicateReleaseOriginal(boolean retainedDuplicate1, boolean retainedDuplicate2) {\n        ByteBuf buf = newBuffer(8).resetWriterIndex();\n        ByteBuf expected = newBuffer(8).resetWriterIndex();\n        buf.writeBytes(new byte[] {1, 2, 3, 4, 5, 6, 7, 8});\n        expected.writeBytes(buf, buf.readerIndex(), buf.readableBytes());\n        ByteBuf dup1 = retainedDuplicate1 ? buf.retainedDuplicate()\n                                          : buf.duplicate().retain();\n        assertEquals(0, dup1.compareTo(expected));\n        // Simulate a handler that releases the original buffer, and propagates a slice.\n        buf.release();\n\n        ByteBuf dup2 = retainedDuplicate2 ? dup1.retainedDuplicate()\n                                          : dup1.duplicate().retain();\n        assertEquals(0, dup2.compareTo(expected));\n\n        // Cleanup the expected buffers used for testing.\n        assertTrue(expected.release());\n\n        // The handler created a slice of the slice and is now done with it.\n        dup2.release();\n\n        // The handler is now done with the original slice\n        assertTrue(dup1.release());\n\n        // Reference counting may be shared, or may be independently tracked, but at this point all buffers should\n        // be deallocated and have a reference count of 0.\n        assertEquals(0, buf.refCnt());\n        assertEquals(0, dup1.refCnt());\n        assertEquals(0, dup2.refCnt());\n    }\n\n    private void testMultipleRetainedSliceReleaseOriginal(boolean retainedSlice1, boolean retainedSlice2) {\n        ByteBuf buf = newBuffer(8).resetWriterIndex();\n        ByteBuf expected1 = newBuffer(3).resetWriterIndex();\n        ByteBuf expected2 = newBuffer(2).resetWriterIndex();\n        ByteBuf expected3 = newBuffer(2).resetWriterIndex();\n        buf.writeBytes(new byte[] {1, 2, 3, 4, 5, 6, 7, 8});\n        expected1.writeBytes(new byte[] {6, 7, 8});\n        expected2.writeBytes(new byte[] {7, 8});\n        expected3.writeBytes(new byte[] {6, 7});\n        ByteBuf slice1 = retainedSlice1 ? buf.retainedSlice(buf.readerIndex() + 5, 3)\n                                        : buf.slice(buf.readerIndex() + 5, 3).retain();\n        assertEquals(0, slice1.compareTo(expected1));\n        // Simulate a handler that releases the original buffer, and propagates a slice.\n        buf.release();\n\n        ByteBuf slice2 = retainedSlice2 ? slice1.retainedSlice(slice1.readerIndex() + 1, 2)\n                                        : slice1.slice(slice1.readerIndex() + 1, 2).retain();\n        assertEquals(0, slice2.compareTo(expected2));\n\n        // The handler created a slice of the slice and is now done with it.\n        slice2.release();\n\n        ByteBuf slice3 = slice1.retainedSlice(slice1.readerIndex(), 2);\n        assertEquals(0, slice3.compareTo(expected3));\n\n        // The handler created another slice of the slice and is now done with it.\n        slice3.release();\n\n        // The handler is now done with the original slice\n        assertTrue(slice1.release());\n\n        // Cleanup the expected buffers used for testing.\n        assertTrue(expected1.release());\n        assertTrue(expected2.release());\n        assertTrue(expected3.release());\n\n        // Reference counting may be shared, or may be independently tracked, but at this point all buffers should\n        // be deallocated and have a reference count of 0.\n        assertEquals(0, buf.refCnt());\n        assertEquals(0, slice1.refCnt());\n        assertEquals(0, slice2.refCnt());\n        assertEquals(0, slice3.refCnt());\n    }\n\n    private void testMultipleRetainedDuplicateReleaseOriginal(boolean retainedDuplicate1, boolean retainedDuplicate2) {\n        ByteBuf buf = newBuffer(8).resetWriterIndex();\n        ByteBuf expected = newBuffer(8).resetWriterIndex();\n        buf.writeBytes(new byte[] {1, 2, 3, 4, 5, 6, 7, 8});\n        expected.writeBytes(buf, buf.readerIndex(), buf.readableBytes());\n        ByteBuf dup1 = retainedDuplicate1 ? buf.retainedDuplicate()\n                                          : buf.duplicate().retain();\n        assertEquals(0, dup1.compareTo(expected));\n        // Simulate a handler that releases the original buffer, and propagates a slice.\n        buf.release();\n\n        ByteBuf dup2 = retainedDuplicate2 ? dup1.retainedDuplicate()\n                                          : dup1.duplicate().retain();\n        assertEquals(0, dup2.compareTo(expected));\n        assertEquals(0, dup2.compareTo(dup2.duplicate()));\n        assertEquals(0, dup2.compareTo(dup2.slice()));\n\n        ByteBuf tmpBuf = dup2.retainedDuplicate();\n        assertEquals(0, dup2.compareTo(tmpBuf));\n        tmpBuf.release();\n        tmpBuf = dup2.retainedSlice();\n        assertEquals(0, dup2.compareTo(tmpBuf));\n        tmpBuf.release();\n\n        // The handler created a slice of the slice and is now done with it.\n        dup2.release();\n\n        ByteBuf dup3 = dup1.retainedDuplicate();\n        assertEquals(0, dup3.compareTo(expected));\n\n        // The handler created another slice of the slice and is now done with it.\n        dup3.release();\n\n        // The handler is now done with the original slice\n        assertTrue(dup1.release());\n\n        // Cleanup the expected buffers used for testing.\n        assertTrue(expected.release());\n\n        // Reference counting may be shared, or may be independently tracked, but at this point all buffers should\n        // be deallocated and have a reference count of 0.\n        assertEquals(0, buf.refCnt());\n        assertEquals(0, dup1.refCnt());\n        assertEquals(0, dup2.refCnt());\n        assertEquals(0, dup3.refCnt());\n    }\n\n    private void testDuplicateContents(boolean retainedDuplicate) {\n        ByteBuf buf = newBuffer(8).resetWriterIndex();\n        buf.writeBytes(new byte[] {1, 2, 3, 4, 5, 6, 7, 8});\n        ByteBuf dup = retainedDuplicate ? buf.retainedDuplicate() : buf.duplicate();\n        try {\n            assertEquals(0, dup.compareTo(buf));\n            assertEquals(0, dup.compareTo(dup.duplicate()));\n            ByteBuf b = dup.retainedDuplicate();\n            assertEquals(0, dup.compareTo(b));\n            b.release();\n            assertEquals(0, dup.compareTo(dup.slice(dup.readerIndex(), dup.readableBytes())));\n        } finally {\n            if (retainedDuplicate) {\n                dup.release();\n            }\n            buf.release();\n        }\n    }\n\n    @Test\n    public void testDuplicateRelease() {\n        ByteBuf buf = newBuffer(8);\n        assertEquals(1, buf.refCnt());\n        assertTrue(buf.duplicate().release());\n        assertEquals(0, buf.refCnt());\n    }\n\n    // Test-case trying to reproduce:\n    // https://github.com/netty/netty/issues/2843\n    @Test\n    public void testRefCnt() throws Exception {\n        testRefCnt0(false);\n    }\n\n    // Test-case trying to reproduce:\n    // https://github.com/netty/netty/issues/2843\n    @Test\n    public void testRefCnt2() throws Exception {\n        testRefCnt0(true);\n    }\n\n    @Test\n    public void testEmptyNioBuffers() throws Exception {\n        ByteBuf buffer = newBuffer(8);\n        buffer.clear();\n        assertFalse(buffer.isReadable());\n        ByteBuffer[] nioBuffers = buffer.nioBuffers();\n        assertEquals(1, nioBuffers.length);\n        assertFalse(nioBuffers[0].hasRemaining());\n        buffer.release();\n    }\n\n    @Test\n    public void testGetReadOnlyDirectDst() {\n        testGetReadOnlyDst(true);\n    }\n\n    @Test\n    public void testGetReadOnlyHeapDst() {\n        testGetReadOnlyDst(false);\n    }\n\n    private void testGetReadOnlyDst(boolean direct) {\n        byte[] bytes = { 'a', 'b', 'c', 'd' };\n\n        ByteBuf buffer = newBuffer(bytes.length);\n        buffer.writeBytes(bytes);\n\n        ByteBuffer dst = direct ? ByteBuffer.allocateDirect(bytes.length) : ByteBuffer.allocate(bytes.length);\n        ByteBuffer readOnlyDst = dst.asReadOnlyBuffer();\n        try {\n            buffer.getBytes(0, readOnlyDst);\n            fail();\n        } catch (ReadOnlyBufferException e) {\n            // expected\n        }\n        assertEquals(0, readOnlyDst.position());\n        buffer.release();\n    }\n\n    @Test\n    public void testReadBytesAndWriteBytesWithFileChannel() throws IOException {\n        File file = PlatformDependent.createTempFile(\"file-channel\", \".tmp\", null);\n        RandomAccessFile randomAccessFile = null;\n        try {\n            randomAccessFile = new RandomAccessFile(file, \"rw\");\n            FileChannel channel = randomAccessFile.getChannel();\n            // channelPosition should never be changed\n            long channelPosition = channel.position();\n\n            byte[] bytes = {'a', 'b', 'c', 'd'};\n            int len = bytes.length;\n            ByteBuf buffer = newBuffer(len);\n            buffer.resetReaderIndex();\n            buffer.resetWriterIndex();\n            buffer.writeBytes(bytes);\n\n            int oldReaderIndex = buffer.readerIndex();\n            assertEquals(len, buffer.readBytes(channel, 10, len));\n            assertEquals(oldReaderIndex + len, buffer.readerIndex());\n            assertEquals(channelPosition, channel.position());\n\n            ByteBuf buffer2 = newBuffer(len);\n            buffer2.resetReaderIndex();\n            buffer2.resetWriterIndex();\n            int oldWriterIndex = buffer2.writerIndex();\n            assertEquals(len, buffer2.writeBytes(channel, 10, len));\n            assertEquals(channelPosition, channel.position());\n            assertEquals(oldWriterIndex + len, buffer2.writerIndex());\n            assertEquals('a', buffer2.getByte(0));\n            assertEquals('b', buffer2.getByte(1));\n            assertEquals('c', buffer2.getByte(2));\n            assertEquals('d', buffer2.getByte(3));\n            buffer.release();\n            buffer2.release();\n        } finally {\n            if (randomAccessFile != null) {\n                randomAccessFile.close();\n            }\n            file.delete();\n        }\n    }\n\n    @Test\n    public void testGetBytesAndSetBytesWithFileChannel() throws IOException {\n        File file = PlatformDependent.createTempFile(\"file-channel\", \".tmp\", null);\n        RandomAccessFile randomAccessFile = null;\n        try {\n            randomAccessFile = new RandomAccessFile(file, \"rw\");\n            FileChannel channel = randomAccessFile.getChannel();\n            // channelPosition should never be changed\n            long channelPosition = channel.position();\n\n            byte[] bytes = {'a', 'b', 'c', 'd'};\n            int len = bytes.length;\n            ByteBuf buffer = newBuffer(len);\n            buffer.resetReaderIndex();\n            buffer.resetWriterIndex();\n            buffer.writeBytes(bytes);\n\n            int oldReaderIndex = buffer.readerIndex();\n            assertEquals(len, buffer.getBytes(oldReaderIndex, channel, 10, len));\n            assertEquals(oldReaderIndex, buffer.readerIndex());\n            assertEquals(channelPosition, channel.position());\n\n            ByteBuf buffer2 = newBuffer(len);\n            buffer2.resetReaderIndex();\n            buffer2.resetWriterIndex();\n            int oldWriterIndex = buffer2.writerIndex();\n            assertEquals(buffer2.setBytes(oldWriterIndex, channel, 10, len), len);\n            assertEquals(channelPosition, channel.position());\n\n            assertEquals(oldWriterIndex, buffer2.writerIndex());\n            assertEquals('a', buffer2.getByte(oldWriterIndex));\n            assertEquals('b', buffer2.getByte(oldWriterIndex + 1));\n            assertEquals('c', buffer2.getByte(oldWriterIndex + 2));\n            assertEquals('d', buffer2.getByte(oldWriterIndex + 3));\n\n            buffer.release();\n            buffer2.release();\n        } finally {\n            if (randomAccessFile != null) {\n                randomAccessFile.close();\n            }\n            file.delete();\n        }\n    }\n\n    @Test\n    public void testReadBytes() {\n        ByteBuf buffer = newBuffer(8);\n        byte[] bytes = new byte[8];\n        buffer.writeBytes(bytes);\n\n        ByteBuf buffer2 = buffer.readBytes(4);\n        assertSame(buffer.alloc(), buffer2.alloc());\n        assertEquals(4, buffer.readerIndex());\n        assertTrue(buffer.release());\n        assertEquals(0, buffer.refCnt());\n        assertTrue(buffer2.release());\n        assertEquals(0, buffer2.refCnt());\n    }\n\n    @Test\n    public void testForEachByteDesc2() {\n        byte[] expected = {1, 2, 3, 4};\n        ByteBuf buf = newBuffer(expected.length);\n        try {\n            buf.writeBytes(expected);\n            final byte[] bytes = new byte[expected.length];\n            int i = buf.forEachByteDesc(new ByteProcessor() {\n                private int index = bytes.length - 1;\n\n                @Override\n                public boolean process(byte value) throws Exception {\n                    bytes[index--] = value;\n                    return true;\n                }\n            });\n            assertEquals(-1, i);\n            assertArrayEquals(expected, bytes);\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test\n    public void testForEachByte2() {\n        byte[] expected = {1, 2, 3, 4};\n        ByteBuf buf = newBuffer(expected.length);\n        try {\n            buf.writeBytes(expected);\n            final byte[] bytes = new byte[expected.length];\n            int i = buf.forEachByte(new ByteProcessor() {\n                private int index;\n\n                @Override\n                public boolean process(byte value) throws Exception {\n                    bytes[index++] = value;\n                    return true;\n                }\n            });\n            assertEquals(-1, i);\n            assertArrayEquals(expected, bytes);\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testGetBytesByteBuffer() {\n        byte[] bytes = {'a', 'b', 'c', 'd', 'e', 'f', 'g'};\n        // Ensure destination buffer is bigger then what is in the ByteBuf.\n        ByteBuffer nioBuffer = ByteBuffer.allocate(bytes.length + 1);\n        ByteBuf buffer = newBuffer(bytes.length);\n        try {\n            buffer.writeBytes(bytes);\n            buffer.getBytes(buffer.readerIndex(), nioBuffer);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    private void testRefCnt0(final boolean parameter) throws Exception {\n        for (int i = 0; i < 10; i++) {\n            final CountDownLatch latch = new CountDownLatch(1);\n            final CountDownLatch innerLatch = new CountDownLatch(1);\n\n            final ByteBuf buffer = newBuffer(4);\n            assertEquals(1, buffer.refCnt());\n            final AtomicInteger cnt = new AtomicInteger(Integer.MAX_VALUE);\n            Thread t1 = new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    boolean released;\n                    if (parameter) {\n                        released = buffer.release(buffer.refCnt());\n                    } else {\n                        released = buffer.release();\n                    }\n                    assertTrue(released);\n                    Thread t2 = new Thread(new Runnable() {\n                        @Override\n                        public void run() {\n                            cnt.set(buffer.refCnt());\n                            latch.countDown();\n                        }\n                    });\n                    t2.start();\n                    try {\n                        // Keep Thread alive a bit so the ThreadLocal caches are not freed\n                        innerLatch.await();\n                    } catch (InterruptedException ignore) {\n                        // ignore\n                    }\n                }\n            });\n            t1.start();\n\n            latch.await();\n            assertEquals(0, cnt.get());\n            innerLatch.countDown();\n        }\n    }\n\n    static final class TestGatheringByteChannel implements GatheringByteChannel {\n        private final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        private final WritableByteChannel channel = Channels.newChannel(out);\n        private final int limit;\n        TestGatheringByteChannel(int limit) {\n            this.limit = limit;\n        }\n\n        TestGatheringByteChannel() {\n            this(Integer.MAX_VALUE);\n        }\n\n        @Override\n        public long write(ByteBuffer[] srcs, int offset, int length) throws IOException {\n            long written = 0;\n            for (; offset < length; offset++) {\n                written += write(srcs[offset]);\n                if (written >= limit) {\n                    break;\n                }\n            }\n            return written;\n        }\n\n        @Override\n        public long write(ByteBuffer[] srcs) throws IOException {\n            return write(srcs, 0, srcs.length);\n        }\n\n        @Override\n        public int write(ByteBuffer src) throws IOException {\n            int oldLimit = src.limit();\n            if (limit < src.remaining()) {\n                src.limit(src.position() + limit);\n            }\n            int w = channel.write(src);\n            src.limit(oldLimit);\n            return w;\n        }\n\n        @Override\n        public boolean isOpen() {\n            return channel.isOpen();\n        }\n\n        @Override\n        public void close() throws IOException {\n            channel.close();\n        }\n\n        public byte[] writtenBytes() {\n            return out.toByteArray();\n        }\n    }\n\n    private static final class DevNullGatheringByteChannel implements GatheringByteChannel {\n        @Override\n        public long write(ByteBuffer[] srcs, int offset, int length) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public long write(ByteBuffer[] srcs) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public int write(ByteBuffer src) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean isOpen() {\n            return false;\n        }\n\n        @Override\n        public void close() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    private static final class TestScatteringByteChannel implements ScatteringByteChannel {\n        @Override\n        public long read(ByteBuffer[] dsts, int offset, int length) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public long read(ByteBuffer[] dsts) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public int read(ByteBuffer dst) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean isOpen() {\n            return false;\n        }\n\n        @Override\n        public void close() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    private static final class TestByteProcessor implements ByteProcessor {\n        @Override\n        public boolean process(byte value) throws Exception {\n            return true;\n        }\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testCapacityEnforceMaxCapacity() {\n        ByteBuf buffer = newBuffer(3, 13);\n        assertEquals(13, buffer.maxCapacity());\n        assertEquals(3, buffer.capacity());\n        try {\n            buffer.capacity(14);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testCapacityNegative() {\n        ByteBuf buffer = newBuffer(3, 13);\n        assertEquals(13, buffer.maxCapacity());\n        assertEquals(3, buffer.capacity());\n        try {\n            buffer.capacity(-1);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test\n    public void testCapacityDecrease() {\n        ByteBuf buffer = newBuffer(3, 13);\n        assertEquals(13, buffer.maxCapacity());\n        assertEquals(3, buffer.capacity());\n        try {\n            buffer.capacity(2);\n            assertEquals(2, buffer.capacity());\n            assertEquals(13, buffer.maxCapacity());\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test\n    public void testCapacityIncrease() {\n        ByteBuf buffer = newBuffer(3, 13);\n        assertEquals(13, buffer.maxCapacity());\n        assertEquals(3, buffer.capacity());\n        try {\n            buffer.capacity(4);\n            assertEquals(4, buffer.capacity());\n            assertEquals(13, buffer.maxCapacity());\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testReaderIndexLargerThanWriterIndex() {\n        String content1 = \"hello\";\n        String content2 = \"world\";\n        int length = content1.length() + content2.length();\n        ByteBuf buffer = newBuffer(length);\n        buffer.setIndex(0, 0);\n        buffer.writeCharSequence(content1, CharsetUtil.US_ASCII);\n        buffer.markWriterIndex();\n        buffer.skipBytes(content1.length());\n        buffer.writeCharSequence(content2, CharsetUtil.US_ASCII);\n        buffer.skipBytes(content2.length());\n        assertTrue(buffer.readerIndex() <= buffer.writerIndex());\n\n        try {\n            buffer.resetWriterIndex();\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test\n    public void testMaxFastWritableBytes() {\n        ByteBuf buffer = newBuffer(150, 500).writerIndex(100);\n        assertEquals(50, buffer.writableBytes());\n        assertEquals(150, buffer.capacity());\n        assertEquals(500, buffer.maxCapacity());\n        assertEquals(400, buffer.maxWritableBytes());\n        // Default implementation has fast writable == writable\n        assertEquals(50, buffer.maxFastWritableBytes());\n        buffer.release();\n    }\n\n    @Test\n    public void testEnsureWritableIntegerOverflow() {\n        ByteBuf buffer = newBuffer(CAPACITY);\n        buffer.writerIndex(buffer.readerIndex());\n        buffer.writeByte(1);\n        try {\n            buffer.ensureWritable(Integer.MAX_VALUE);\n            fail();\n        } catch (IndexOutOfBoundsException e) {\n            // expected\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test\n    public void testEndiannessIndexOf() {\n        buffer.clear();\n        final int v = 0x02030201;\n        buffer.writeIntLE(v);\n        buffer.writeByte(0x01);\n\n        assertEquals(-1, buffer.indexOf(1, 4, (byte) 1));\n        assertEquals(-1, buffer.indexOf(4, 1, (byte) 1));\n        assertEquals(1, buffer.indexOf(1, 4, (byte) 2));\n        assertEquals(3, buffer.indexOf(4, 1, (byte) 2));\n    }\n\n    @Test\n    public void explicitLittleEndianReadMethodsMustAlwaysUseLittleEndianByteOrder() {\n        buffer.clear();\n        buffer.writeBytes(new byte[] {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08});\n        assertEquals(0x0201, buffer.readShortLE());\n        buffer.readerIndex(0);\n        assertEquals(0x0201, buffer.readUnsignedShortLE());\n        buffer.readerIndex(0);\n        assertEquals(0x030201, buffer.readMediumLE());\n        buffer.readerIndex(0);\n        assertEquals(0x030201, buffer.readUnsignedMediumLE());\n        buffer.readerIndex(0);\n        assertEquals(0x04030201, buffer.readIntLE());\n        buffer.readerIndex(0);\n        assertEquals(0x04030201, buffer.readUnsignedIntLE());\n        buffer.readerIndex(0);\n        assertEquals(0x04030201, Float.floatToRawIntBits(buffer.readFloatLE()));\n        buffer.readerIndex(0);\n        assertEquals(0x0807060504030201L, buffer.readLongLE());\n        buffer.readerIndex(0);\n        assertEquals(0x0807060504030201L, Double.doubleToRawLongBits(buffer.readDoubleLE()));\n        buffer.readerIndex(0);\n    }\n\n    @Test\n    public void explicitLittleEndianWriteMethodsMustAlwaysUseLittleEndianByteOrder() {\n        buffer.clear();\n        buffer.writeShortLE(0x0102);\n        assertEquals(0x0102, buffer.readShortLE());\n        buffer.clear();\n        buffer.writeMediumLE(0x010203);\n        assertEquals(0x010203, buffer.readMediumLE());\n        buffer.clear();\n        buffer.writeIntLE(0x01020304);\n        assertEquals(0x01020304, buffer.readIntLE());\n        buffer.clear();\n        buffer.writeFloatLE(Float.intBitsToFloat(0x01020304));\n        assertEquals(0x01020304, Float.floatToRawIntBits(buffer.readFloatLE()));\n        buffer.clear();\n        buffer.writeLongLE(0x0102030405060708L);\n        assertEquals(0x0102030405060708L, buffer.readLongLE());\n        buffer.clear();\n        buffer.writeDoubleLE(Double.longBitsToDouble(0x0102030405060708L));\n        assertEquals(0x0102030405060708L, Double.doubleToRawLongBits(buffer.readDoubleLE()));\n    }\n}\n", "/*\n * Copyright 2013 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.buffer;\n\nimport io.netty.util.internal.PlatformDependent;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.ByteBuffer;\nimport java.nio.ReadOnlyBufferException;\nimport java.nio.channels.FileChannel;\n\npublic class ReadOnlyDirectByteBufferBufTest {\n\n    protected ByteBuf buffer(ByteBuffer buffer) {\n        return new ReadOnlyByteBufferBuf(UnpooledByteBufAllocator.DEFAULT, buffer);\n    }\n\n    protected ByteBuffer allocate(int size) {\n        return ByteBuffer.allocateDirect(size);\n    }\n\n    @Test\n    public void testIsContiguous() {\n        ByteBuf buf = buffer(allocate(4).asReadOnlyBuffer());\n        Assert.assertTrue(buf.isContiguous());\n        buf.release();\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testConstructWithWritable() {\n        buffer(allocate(1));\n    }\n\n    @Test\n    public void shouldIndicateNotWritable() {\n        ByteBuf buf = buffer(allocate(8).asReadOnlyBuffer()).clear();\n        try {\n            Assert.assertFalse(buf.isWritable());\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test\n    public void shouldIndicateNotWritableAnyNumber() {\n        ByteBuf buf = buffer(allocate(8).asReadOnlyBuffer()).clear();\n        try {\n            Assert.assertFalse(buf.isWritable(1));\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test\n    public void ensureWritableIntStatusShouldFailButNotThrow() {\n        ByteBuf buf = buffer(allocate(8).asReadOnlyBuffer()).clear();\n        try {\n            int result = buf.ensureWritable(1, false);\n            Assert.assertEquals(1, result);\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test\n    public void ensureWritableForceIntStatusShouldFailButNotThrow() {\n        ByteBuf buf = buffer(allocate(8).asReadOnlyBuffer()).clear();\n        try {\n            int result = buf.ensureWritable(1, true);\n            Assert.assertEquals(1, result);\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test(expected = ReadOnlyBufferException.class)\n    public void ensureWritableShouldThrow() {\n        ByteBuf buf = buffer(allocate(8).asReadOnlyBuffer()).clear();\n        try {\n            buf.ensureWritable(1);\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test(expected = ReadOnlyBufferException.class)\n    public void testSetByte() {\n        ByteBuf buf = buffer(allocate(8).asReadOnlyBuffer());\n        try {\n            buf.setByte(0, 1);\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test(expected = ReadOnlyBufferException.class)\n    public void testSetInt() {\n        ByteBuf buf = buffer(allocate(8).asReadOnlyBuffer());\n        try {\n            buf.setInt(0, 1);\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test(expected = ReadOnlyBufferException.class)\n    public void testSetShort() {\n        ByteBuf buf = buffer(allocate(8).asReadOnlyBuffer());\n        try {\n            buf.setShort(0, 1);\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test(expected = ReadOnlyBufferException.class)\n    public void testSetMedium() {\n        ByteBuf buf = buffer(allocate(8).asReadOnlyBuffer());\n        try {\n            buf.setMedium(0, 1);\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test(expected = ReadOnlyBufferException.class)\n    public void testSetLong() {\n        ByteBuf buf = buffer(allocate(8).asReadOnlyBuffer());\n        try {\n            buf.setLong(0, 1);\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test(expected = ReadOnlyBufferException.class)\n    public void testSetBytesViaArray() {\n        ByteBuf buf = buffer(allocate(8).asReadOnlyBuffer());\n        try {\n            buf.setBytes(0, \"test\".getBytes());\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test(expected = ReadOnlyBufferException.class)\n    public void testSetBytesViaBuffer() {\n        ByteBuf buf = buffer(allocate(8).asReadOnlyBuffer());\n        ByteBuf copy = Unpooled.copyInt(1);\n        try {\n            buf.setBytes(0, copy);\n        } finally {\n            buf.release();\n            copy.release();\n        }\n    }\n\n    @Test(expected = ReadOnlyBufferException.class)\n    public void testSetBytesViaStream() throws IOException {\n        ByteBuf buf = buffer(ByteBuffer.allocateDirect(8).asReadOnlyBuffer());\n        try {\n            buf.setBytes(0, new ByteArrayInputStream(\"test\".getBytes()), 2);\n        } finally {\n            buf.release();\n        }\n    }\n\n    @Test\n    public void testGetReadByte() {\n        ByteBuf buf = buffer(\n                ((ByteBuffer) allocate(2).put(new byte[] { (byte) 1, (byte) 2 }).flip()).asReadOnlyBuffer());\n\n        Assert.assertEquals(1, buf.getByte(0));\n        Assert.assertEquals(2, buf.getByte(1));\n\n        Assert.assertEquals(1, buf.readByte());\n        Assert.assertEquals(2, buf.readByte());\n        Assert.assertFalse(buf.isReadable());\n\n        buf.release();\n    }\n\n    @Test\n    public void testGetReadInt() {\n        ByteBuf buf = buffer(((ByteBuffer) allocate(8).putInt(1).putInt(2).flip()).asReadOnlyBuffer());\n\n        Assert.assertEquals(1, buf.getInt(0));\n        Assert.assertEquals(2, buf.getInt(4));\n\n        Assert.assertEquals(1, buf.readInt());\n        Assert.assertEquals(2, buf.readInt());\n        Assert.assertFalse(buf.isReadable());\n\n        buf.release();\n    }\n\n    @Test\n    public void testGetReadShort() {\n        ByteBuf buf = buffer(((ByteBuffer) allocate(8)\n                .putShort((short) 1).putShort((short) 2).flip()).asReadOnlyBuffer());\n\n        Assert.assertEquals(1, buf.getShort(0));\n        Assert.assertEquals(2, buf.getShort(2));\n\n        Assert.assertEquals(1, buf.readShort());\n        Assert.assertEquals(2, buf.readShort());\n        Assert.assertFalse(buf.isReadable());\n\n        buf.release();\n    }\n\n    @Test\n    public void testGetReadLong() {\n        ByteBuf buf = buffer(((ByteBuffer) allocate(16)\n                .putLong(1).putLong(2).flip()).asReadOnlyBuffer());\n\n        Assert.assertEquals(1, buf.getLong(0));\n        Assert.assertEquals(2, buf.getLong(8));\n\n        Assert.assertEquals(1, buf.readLong());\n        Assert.assertEquals(2, buf.readLong());\n        Assert.assertFalse(buf.isReadable());\n\n        buf.release();\n    }\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void testGetBytesByteBuffer() {\n        byte[] bytes = {'a', 'b', 'c', 'd', 'e', 'f', 'g'};\n        // Ensure destination buffer is bigger then what is in the ByteBuf.\n        ByteBuffer nioBuffer = ByteBuffer.allocate(bytes.length + 1);\n        ByteBuf buffer = buffer(((ByteBuffer) allocate(bytes.length)\n                .put(bytes).flip()).asReadOnlyBuffer());\n        try {\n            buffer.getBytes(buffer.readerIndex(), nioBuffer);\n        } finally {\n            buffer.release();\n        }\n    }\n\n    @Test\n    public void testCopy() {\n        ByteBuf buf = buffer(((ByteBuffer) allocate(16).putLong(1).putLong(2).flip()).asReadOnlyBuffer());\n        ByteBuf copy = buf.copy();\n\n        Assert.assertEquals(buf, copy);\n\n        buf.release();\n        copy.release();\n    }\n\n    @Test\n    public void testCopyWithOffset() {\n        ByteBuf buf = buffer(((ByteBuffer) allocate(16).putLong(1).putLong(2).flip()).asReadOnlyBuffer());\n        ByteBuf copy = buf.copy(1, 9);\n\n        Assert.assertEquals(buf.slice(1, 9), copy);\n\n        buf.release();\n        copy.release();\n    }\n\n    // Test for https://github.com/netty/netty/issues/1708\n    @Test\n    public void testWrapBufferWithNonZeroPosition() {\n        ByteBuf buf = buffer(((ByteBuffer) allocate(16)\n                .putLong(1).flip().position(1)).asReadOnlyBuffer());\n\n        ByteBuf slice = buf.slice();\n        Assert.assertEquals(buf, slice);\n\n        buf.release();\n    }\n\n    @Test\n    public void testWrapBufferRoundTrip() {\n        ByteBuf buf = buffer(((ByteBuffer) allocate(16).putInt(1).putInt(2).flip()).asReadOnlyBuffer());\n\n        Assert.assertEquals(1, buf.readInt());\n\n        ByteBuffer nioBuffer = buf.nioBuffer();\n\n        // Ensure this can be accessed without throwing a BufferUnderflowException\n        Assert.assertEquals(2, nioBuffer.getInt());\n\n        buf.release();\n    }\n\n    @Test\n    public void testWrapMemoryMapped() throws Exception {\n        File file = PlatformDependent.createTempFile(\"netty-test\", \"tmp\", null);\n        FileChannel output = null;\n        FileChannel input = null;\n        ByteBuf b1 = null;\n        ByteBuf b2 = null;\n\n        try {\n            output = new RandomAccessFile(file, \"rw\").getChannel();\n            byte[] bytes = new byte[1024];\n            PlatformDependent.threadLocalRandom().nextBytes(bytes);\n            output.write(ByteBuffer.wrap(bytes));\n\n            input = new RandomAccessFile(file, \"r\").getChannel();\n            ByteBuffer m = input.map(FileChannel.MapMode.READ_ONLY, 0, input.size());\n\n            b1 = buffer(m);\n\n            ByteBuffer dup = m.duplicate();\n            dup.position(2);\n            dup.limit(4);\n\n            b2 = buffer(dup);\n\n            Assert.assertEquals(b2, b1.slice(2, 2));\n        } finally {\n            if (b1 != null) {\n                b1.release();\n            }\n            if (b2 != null) {\n                b2.release();\n            }\n            if (output != null) {\n                output.close();\n            }\n            if (input != null) {\n                input.close();\n            }\n            file.delete();\n        }\n    }\n\n    @Test\n    public void testMemoryAddress() {\n        ByteBuf buf = buffer(allocate(8).asReadOnlyBuffer());\n        try {\n            Assert.assertFalse(buf.hasMemoryAddress());\n            try {\n                buf.memoryAddress();\n                Assert.fail();\n            } catch (UnsupportedOperationException expected) {\n                // expected\n            }\n        } finally {\n            buf.release();\n        }\n    }\n}\n", "/*\n * Copyright 2012 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.codec.http.multipart;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.handler.codec.http.HttpConstants;\nimport io.netty.util.internal.EmptyArrays;\nimport io.netty.util.internal.ObjectUtil;\nimport io.netty.util.internal.PlatformDependent;\nimport io.netty.util.internal.logging.InternalLogger;\nimport io.netty.util.internal.logging.InternalLoggerFactory;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.RandomAccessFile;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.charset.Charset;\n\nimport static io.netty.buffer.Unpooled.EMPTY_BUFFER;\nimport static io.netty.buffer.Unpooled.wrappedBuffer;\n\n/**\n * Abstract Disk HttpData implementation\n */\npublic abstract class AbstractDiskHttpData extends AbstractHttpData {\n\n    private static final InternalLogger logger = InternalLoggerFactory.getInstance(AbstractDiskHttpData.class);\n\n    private File file;\n    private boolean isRenamed;\n    private FileChannel fileChannel;\n\n    protected AbstractDiskHttpData(String name, Charset charset, long size) {\n        super(name, charset, size);\n    }\n\n    /**\n     *\n     * @return the real DiskFilename (basename)\n     */\n    protected abstract String getDiskFilename();\n    /**\n     *\n     * @return the default prefix\n     */\n    protected abstract String getPrefix();\n    /**\n     *\n     * @return the default base Directory\n     */\n    protected abstract String getBaseDirectory();\n    /**\n     *\n     * @return the default postfix\n     */\n    protected abstract String getPostfix();\n    /**\n     *\n     * @return True if the file should be deleted on Exit by default\n     */\n    protected abstract boolean deleteOnExit();\n\n    /**\n     * @return a new Temp File from getDiskFilename(), default prefix, postfix and baseDirectory\n     */\n    private File tempFile() throws IOException {\n        String newpostfix;\n        String diskFilename = getDiskFilename();\n        if (diskFilename != null) {\n            newpostfix = '_' + diskFilename;\n        } else {\n            newpostfix = getPostfix();\n        }\n        File tmpFile;\n        if (getBaseDirectory() == null) {\n            // create a temporary file\n            tmpFile = PlatformDependent.createTempFile(getPrefix(), newpostfix, null);\n        } else {\n            tmpFile = PlatformDependent.createTempFile(getPrefix(), newpostfix, new File(\n                    getBaseDirectory()));\n        }\n        if (deleteOnExit()) {\n            // See https://github.com/netty/netty/issues/10351\n            DeleteFileOnExitHook.add(tmpFile.getPath());\n        }\n        return tmpFile;\n    }\n\n    @Override\n    public void setContent(ByteBuf buffer) throws IOException {\n        ObjectUtil.checkNotNull(buffer, \"buffer\");\n        try {\n            size = buffer.readableBytes();\n            checkSize(size);\n            if (definedSize > 0 && definedSize < size) {\n                throw new IOException(\"Out of size: \" + size + \" > \" + definedSize);\n            }\n            if (file == null) {\n                file = tempFile();\n            }\n            if (buffer.readableBytes() == 0) {\n                // empty file\n                if (!file.createNewFile()) {\n                    if (file.length() == 0) {\n                        return;\n                    } else {\n                        if (!file.delete() || !file.createNewFile()) {\n                            throw new IOException(\"file exists already: \" + file);\n                        }\n                    }\n                }\n                return;\n            }\n            RandomAccessFile accessFile = new RandomAccessFile(file, \"rw\");\n            try {\n                accessFile.setLength(0);\n                FileChannel localfileChannel = accessFile.getChannel();\n                ByteBuffer byteBuffer = buffer.nioBuffer();\n                int written = 0;\n                while (written < size) {\n                    written += localfileChannel.write(byteBuffer);\n                }\n                buffer.readerIndex(buffer.readerIndex() + written);\n                localfileChannel.force(false);\n            } finally {\n                accessFile.close();\n            }\n            setCompleted();\n        } finally {\n            // Release the buffer as it was retained before and we not need a reference to it at all\n            // See https://github.com/netty/netty/issues/1516\n            buffer.release();\n        }\n    }\n\n    @Override\n    public void addContent(ByteBuf buffer, boolean last)\n            throws IOException {\n        if (buffer != null) {\n            try {\n                int localsize = buffer.readableBytes();\n                checkSize(size + localsize);\n                if (definedSize > 0 && definedSize < size + localsize) {\n                    throw new IOException(\"Out of size: \" + (size + localsize) +\n                            \" > \" + definedSize);\n                }\n                if (file == null) {\n                    file = tempFile();\n                }\n                if (fileChannel == null) {\n                    RandomAccessFile accessFile = new RandomAccessFile(file, \"rw\");\n                    fileChannel = accessFile.getChannel();\n                }\n                int remaining = localsize;\n                long position = fileChannel.position();\n                int index = buffer.readerIndex();\n                while (remaining > 0) {\n                    int written = buffer.getBytes(index, fileChannel, position, remaining);\n                    if (written < 0) {\n                        break;\n                    }\n                    remaining -= written;\n                    position += written;\n                    index += written;\n                }\n                fileChannel.position(position);\n                buffer.readerIndex(index);\n                size += localsize - remaining;\n            } finally {\n                // Release the buffer as it was retained before and we not need a reference to it at all\n                // See https://github.com/netty/netty/issues/1516\n                buffer.release();\n            }\n        }\n        if (last) {\n            if (file == null) {\n                file = tempFile();\n            }\n            if (fileChannel == null) {\n                RandomAccessFile accessFile = new RandomAccessFile(file, \"rw\");\n                fileChannel = accessFile.getChannel();\n            }\n            try {\n                fileChannel.force(false);\n            } finally {\n                fileChannel.close();\n            }\n            fileChannel = null;\n            setCompleted();\n        } else {\n            ObjectUtil.checkNotNull(buffer, \"buffer\");\n        }\n    }\n\n    @Override\n    public void setContent(File file) throws IOException {\n        long size = file.length();\n        checkSize(size);\n        this.size = size;\n        if (this.file != null) {\n            delete();\n        }\n        this.file = file;\n        isRenamed = true;\n        setCompleted();\n    }\n\n    @Override\n    public void setContent(InputStream inputStream) throws IOException {\n        ObjectUtil.checkNotNull(inputStream, \"inputStream\");\n        if (file != null) {\n            delete();\n        }\n        file = tempFile();\n        RandomAccessFile accessFile = new RandomAccessFile(file, \"rw\");\n        int written = 0;\n        try {\n            accessFile.setLength(0);\n            FileChannel localfileChannel = accessFile.getChannel();\n            byte[] bytes = new byte[4096 * 4];\n            ByteBuffer byteBuffer = ByteBuffer.wrap(bytes);\n            int read = inputStream.read(bytes);\n            while (read > 0) {\n                byteBuffer.position(read).flip();\n                written += localfileChannel.write(byteBuffer);\n                checkSize(written);\n                read = inputStream.read(bytes);\n            }\n            localfileChannel.force(false);\n        } finally {\n            accessFile.close();\n        }\n        size = written;\n        if (definedSize > 0 && definedSize < size) {\n            if (!file.delete()) {\n                logger.warn(\"Failed to delete: {}\", file);\n            }\n            file = null;\n            throw new IOException(\"Out of size: \" + size + \" > \" + definedSize);\n        }\n        isRenamed = true;\n        setCompleted();\n    }\n\n    @Override\n    public void delete() {\n        if (fileChannel != null) {\n            try {\n                fileChannel.force(false);\n            } catch (IOException e) {\n                logger.warn(\"Failed to force.\", e);\n            } finally {\n                try {\n                    fileChannel.close();\n                } catch (IOException e) {\n                    logger.warn(\"Failed to close a file.\", e);\n                }\n            }\n            fileChannel = null;\n        }\n        if (!isRenamed) {\n            String filePath = null;\n\n            if (file != null && file.exists()) {\n                filePath = file.getPath();\n                if (!file.delete()) {\n                    filePath = null;\n                    logger.warn(\"Failed to delete: {}\", file);\n                }\n            }\n\n            // If you turn on deleteOnExit make sure it is executed.\n            if (deleteOnExit() && filePath != null) {\n                DeleteFileOnExitHook.remove(filePath);\n            }\n            file = null;\n        }\n    }\n\n    @Override\n    public byte[] get() throws IOException {\n        if (file == null) {\n            return EmptyArrays.EMPTY_BYTES;\n        }\n        return readFrom(file);\n    }\n\n    @Override\n    public ByteBuf getByteBuf() throws IOException {\n        if (file == null) {\n            return EMPTY_BUFFER;\n        }\n        byte[] array = readFrom(file);\n        return wrappedBuffer(array);\n    }\n\n    @Override\n    public ByteBuf getChunk(int length) throws IOException {\n        if (file == null || length == 0) {\n            return EMPTY_BUFFER;\n        }\n        if (fileChannel == null) {\n            RandomAccessFile accessFile = new RandomAccessFile(file, \"r\");\n            fileChannel = accessFile.getChannel();\n        }\n        int read = 0;\n        ByteBuffer byteBuffer = ByteBuffer.allocate(length);\n        try {\n            while (read < length) {\n                int readnow = fileChannel.read(byteBuffer);\n                if (readnow == -1) {\n                    fileChannel.close();\n                    fileChannel = null;\n                    break;\n                }\n                read += readnow;\n            }\n        } catch (IOException e) {\n            fileChannel.close();\n            fileChannel = null;\n            throw e;\n        }\n        if (read == 0) {\n            return EMPTY_BUFFER;\n        }\n        byteBuffer.flip();\n        ByteBuf buffer = wrappedBuffer(byteBuffer);\n        buffer.readerIndex(0);\n        buffer.writerIndex(read);\n        return buffer;\n    }\n\n    @Override\n    public String getString() throws IOException {\n        return getString(HttpConstants.DEFAULT_CHARSET);\n    }\n\n    @Override\n    public String getString(Charset encoding) throws IOException {\n        if (file == null) {\n            return \"\";\n        }\n        if (encoding == null) {\n            byte[] array = readFrom(file);\n            return new String(array, HttpConstants.DEFAULT_CHARSET.name());\n        }\n        byte[] array = readFrom(file);\n        return new String(array, encoding.name());\n    }\n\n    @Override\n    public boolean isInMemory() {\n        return false;\n    }\n\n    @Override\n    public boolean renameTo(File dest) throws IOException {\n        ObjectUtil.checkNotNull(dest, \"dest\");\n        if (file == null) {\n            throw new IOException(\"No file defined so cannot be renamed\");\n        }\n        if (!file.renameTo(dest)) {\n            // must copy\n            IOException exception = null;\n            RandomAccessFile inputAccessFile = null;\n            RandomAccessFile outputAccessFile = null;\n            long chunkSize = 8196;\n            long position = 0;\n            try {\n                inputAccessFile = new RandomAccessFile(file, \"r\");\n                outputAccessFile = new RandomAccessFile(dest, \"rw\");\n                FileChannel in = inputAccessFile.getChannel();\n                FileChannel out = outputAccessFile.getChannel();\n                while (position < size) {\n                    if (chunkSize < size - position) {\n                        chunkSize = size - position;\n                    }\n                    position += in.transferTo(position, chunkSize, out);\n                }\n            } catch (IOException e) {\n                exception = e;\n            } finally {\n                if (inputAccessFile != null) {\n                    try {\n                        inputAccessFile.close();\n                    } catch (IOException e) {\n                        if (exception == null) { // Choose to report the first exception\n                            exception = e;\n                        } else {\n                            logger.warn(\"Multiple exceptions detected, the following will be suppressed {}\", e);\n                        }\n                    }\n                }\n                if (outputAccessFile != null) {\n                    try {\n                        outputAccessFile.close();\n                    } catch (IOException e) {\n                        if (exception == null) { // Choose to report the first exception\n                            exception = e;\n                        } else {\n                            logger.warn(\"Multiple exceptions detected, the following will be suppressed {}\", e);\n                        }\n                    }\n                }\n            }\n            if (exception != null) {\n                throw exception;\n            }\n            if (position == size) {\n                if (!file.delete()) {\n                    logger.warn(\"Failed to delete: {}\", file);\n                }\n                file = dest;\n                isRenamed = true;\n                return true;\n            } else {\n                if (!dest.delete()) {\n                    logger.warn(\"Failed to delete: {}\", dest);\n                }\n                return false;\n            }\n        }\n        file = dest;\n        isRenamed = true;\n        return true;\n    }\n\n    /**\n     * Utility function\n     *\n     * @return the array of bytes\n     */\n    private static byte[] readFrom(File src) throws IOException {\n        long srcsize = src.length();\n        if (srcsize > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"File too big to be loaded in memory\");\n        }\n        RandomAccessFile accessFile = new RandomAccessFile(src, \"r\");\n        byte[] array = new byte[(int) srcsize];\n        try {\n            FileChannel fileChannel = accessFile.getChannel();\n            ByteBuffer byteBuffer = ByteBuffer.wrap(array);\n            int read = 0;\n            while (read < srcsize) {\n                read += fileChannel.read(byteBuffer);\n            }\n        } finally {\n            accessFile.close();\n        }\n        return array;\n    }\n\n    @Override\n    public File getFile() throws IOException {\n        return file;\n    }\n\n    @Override\n    public HttpData touch() {\n        return this;\n    }\n\n    @Override\n    public HttpData touch(Object hint) {\n        return this;\n    }\n}\n", "/*\n * Copyright 2014 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.codec.http;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufAllocator;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.embedded.EmbeddedChannel;\nimport io.netty.handler.stream.ChunkedFile;\nimport io.netty.handler.stream.ChunkedInput;\nimport io.netty.handler.stream.ChunkedNioFile;\nimport io.netty.handler.stream.ChunkedNioStream;\nimport io.netty.handler.stream.ChunkedStream;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport io.netty.util.internal.PlatformDependent;\nimport org.junit.Test;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.channels.Channels;\n\nimport static org.junit.Assert.*;\n\npublic class HttpChunkedInputTest {\n    private static final byte[] BYTES = new byte[1024 * 64];\n    private static final File TMP;\n\n    static {\n        for (int i = 0; i < BYTES.length; i++) {\n            BYTES[i] = (byte) i;\n        }\n\n        FileOutputStream out = null;\n        try {\n            TMP = PlatformDependent.createTempFile(\"netty-chunk-\", \".tmp\", null);\n            TMP.deleteOnExit();\n            out = new FileOutputStream(TMP);\n            out.write(BYTES);\n            out.flush();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            if (out != null) {\n                try {\n                    out.close();\n                } catch (IOException e) {\n                    // ignore\n                }\n            }\n        }\n    }\n\n    @Test\n    public void testChunkedStream() {\n        check(new HttpChunkedInput(new ChunkedStream(new ByteArrayInputStream(BYTES))));\n    }\n\n    @Test\n    public void testChunkedNioStream() {\n        check(new HttpChunkedInput(new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES)))));\n    }\n\n    @Test\n    public void testChunkedFile() throws IOException {\n        check(new HttpChunkedInput(new ChunkedFile(TMP)));\n    }\n\n    @Test\n    public void testChunkedNioFile() throws IOException {\n        check(new HttpChunkedInput(new ChunkedNioFile(TMP)));\n    }\n\n    @Test\n    public void testWrappedReturnNull() throws Exception {\n        HttpChunkedInput input = new HttpChunkedInput(new ChunkedInput<ByteBuf>() {\n            @Override\n            public boolean isEndOfInput() throws Exception {\n                return false;\n            }\n\n            @Override\n            public void close() throws Exception {\n                // NOOP\n            }\n\n            @Override\n            public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {\n                return null;\n            }\n\n            @Override\n            public ByteBuf readChunk(ByteBufAllocator allocator) throws Exception {\n                return null;\n            }\n\n            @Override\n            public long length() {\n                return 0;\n            }\n\n            @Override\n            public long progress() {\n                return 0;\n            }\n        });\n        assertNull(input.readChunk(ByteBufAllocator.DEFAULT));\n    }\n\n    private static void check(ChunkedInput<?>... inputs) {\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n\n        for (ChunkedInput<?> input : inputs) {\n            ch.writeOutbound(input);\n        }\n\n        assertTrue(ch.finish());\n\n        int i = 0;\n        int read = 0;\n        HttpContent lastHttpContent = null;\n        for (;;) {\n            HttpContent httpContent = ch.readOutbound();\n            if (httpContent == null) {\n                break;\n            }\n            if (lastHttpContent != null) {\n                assertTrue(\"Chunk must be DefaultHttpContent\", lastHttpContent instanceof DefaultHttpContent);\n            }\n\n            ByteBuf buffer = httpContent.content();\n            while (buffer.isReadable()) {\n                assertEquals(BYTES[i++], buffer.readByte());\n                read++;\n                if (i == BYTES.length) {\n                    i = 0;\n                }\n            }\n            buffer.release();\n\n            // Save last chunk\n            lastHttpContent = httpContent;\n        }\n\n        assertEquals(BYTES.length * inputs.length, read);\n        assertSame(\"Last chunk must be LastHttpContent.EMPTY_LAST_CONTENT\",\n                LastHttpContent.EMPTY_LAST_CONTENT, lastHttpContent);\n    }\n}\n", "/*\n * Copyright 2020 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.codec.http.multipart;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufUtil;\nimport io.netty.util.internal.PlatformDependent;\nimport org.junit.Test;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.nio.charset.Charset;\nimport java.util.Arrays;\nimport java.util.UUID;\n\nimport static io.netty.util.CharsetUtil.UTF_8;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\n\n/**\n * {@link AbstractDiskHttpData} test cases\n */\npublic class AbstractDiskHttpDataTest {\n\n    @Test\n    public void testGetChunk() throws Exception {\n        TestHttpData test = new TestHttpData(\"test\", UTF_8, 0);\n        try {\n            File tmpFile = PlatformDependent.createTempFile(UUID.randomUUID().toString(), \".tmp\", null);\n            tmpFile.deleteOnExit();\n            FileOutputStream fos = new FileOutputStream(tmpFile);\n            byte[] bytes = new byte[4096];\n            PlatformDependent.threadLocalRandom().nextBytes(bytes);\n            try {\n                fos.write(bytes);\n                fos.flush();\n            } finally {\n                fos.close();\n            }\n            test.setContent(tmpFile);\n            ByteBuf buf1 = test.getChunk(1024);\n            assertEquals(buf1.readerIndex(), 0);\n            assertEquals(buf1.writerIndex(), 1024);\n            ByteBuf buf2 = test.getChunk(1024);\n            assertEquals(buf2.readerIndex(), 0);\n            assertEquals(buf2.writerIndex(), 1024);\n            assertFalse(\"Arrays should not be equal\",\n                    Arrays.equals(ByteBufUtil.getBytes(buf1), ByteBufUtil.getBytes(buf2)));\n        } finally {\n            test.delete();\n        }\n    }\n\n    private static final class TestHttpData extends AbstractDiskHttpData {\n\n        private TestHttpData(String name, Charset charset, long size) {\n            super(name, charset, size);\n        }\n\n        @Override\n        protected String getDiskFilename() {\n            return null;\n        }\n\n        @Override\n        protected String getPrefix() {\n            return null;\n        }\n\n        @Override\n        protected String getBaseDirectory() {\n            return null;\n        }\n\n        @Override\n        protected String getPostfix() {\n            return null;\n        }\n\n        @Override\n        protected boolean deleteOnExit() {\n            return false;\n        }\n\n        @Override\n        public HttpData copy() {\n            return null;\n        }\n\n        @Override\n        public HttpData duplicate() {\n            return null;\n        }\n\n        @Override\n        public HttpData retainedDuplicate() {\n            return null;\n        }\n\n        @Override\n        public HttpData replace(ByteBuf content) {\n            return null;\n        }\n\n        @Override\n        public HttpDataType getHttpDataType() {\n            return null;\n        }\n\n        @Override\n        public int compareTo(InterfaceHttpData o) {\n            return 0;\n        }\n    }\n}\n", "/*\n * Copyright 2012 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.codec.http.multipart;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufInputStream;\nimport io.netty.buffer.ByteBufUtil;\nimport io.netty.buffer.Unpooled;\nimport io.netty.util.internal.PlatformDependent;\n\nimport org.junit.Test;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.nio.charset.Charset;\nimport java.security.SecureRandom;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.UUID;\n\nimport static io.netty.util.CharsetUtil.*;\nimport static org.junit.Assert.*;\n\n/** {@link AbstractMemoryHttpData} test cases. */\npublic class AbstractMemoryHttpDataTest {\n\n    @Test\n    public void testSetContentFromFile() throws Exception {\n        TestHttpData test = new TestHttpData(\"test\", UTF_8, 0);\n        try {\n            File tmpFile = PlatformDependent.createTempFile(UUID.randomUUID().toString(), \".tmp\", null);\n            tmpFile.deleteOnExit();\n            FileOutputStream fos = new FileOutputStream(tmpFile);\n            byte[] bytes = new byte[4096];\n            PlatformDependent.threadLocalRandom().nextBytes(bytes);\n            try {\n                fos.write(bytes);\n                fos.flush();\n            } finally {\n                fos.close();\n            }\n            test.setContent(tmpFile);\n            ByteBuf buf = test.getByteBuf();\n            assertEquals(buf.readerIndex(), 0);\n            assertEquals(buf.writerIndex(), bytes.length);\n            assertArrayEquals(bytes, test.get());\n            assertArrayEquals(bytes, ByteBufUtil.getBytes(buf));\n        } finally {\n            //release the ByteBuf\n            test.delete();\n        }\n    }\n\n    @Test\n    public void testRenameTo() throws Exception {\n        TestHttpData test = new TestHttpData(\"test\", UTF_8, 0);\n        try {\n            File tmpFile = PlatformDependent.createTempFile(UUID.randomUUID().toString(), \".tmp\", null);\n            tmpFile.deleteOnExit();\n            final int totalByteCount = 4096;\n            byte[] bytes = new byte[totalByteCount];\n            PlatformDependent.threadLocalRandom().nextBytes(bytes);\n            ByteBuf content = Unpooled.wrappedBuffer(bytes);\n            test.setContent(content);\n            boolean succ = test.renameTo(tmpFile);\n            assertTrue(succ);\n            FileInputStream fis = new FileInputStream(tmpFile);\n            try {\n                byte[] buf = new byte[totalByteCount];\n                int count = 0;\n                int offset = 0;\n                int size = totalByteCount;\n                while ((count = fis.read(buf, offset, size)) > 0) {\n                    offset += count;\n                    size -= count;\n                    if (offset >= totalByteCount || size <= 0) {\n                        break;\n                    }\n                }\n                assertArrayEquals(bytes, buf);\n                assertEquals(0, fis.available());\n            } finally {\n                fis.close();\n            }\n        } finally {\n            //release the ByteBuf in AbstractMemoryHttpData\n            test.delete();\n        }\n    }\n    /**\n     * Provide content into HTTP data with input stream.\n     *\n     * @throws Exception In case of any exception.\n     */\n    @Test\n    public void testSetContentFromStream() throws Exception {\n        // definedSize=0\n        TestHttpData test = new TestHttpData(\"test\", UTF_8, 0);\n        String contentStr = \"foo_test\";\n        ByteBuf buf = Unpooled.wrappedBuffer(contentStr.getBytes(UTF_8));\n        buf.markReaderIndex();\n        ByteBufInputStream is = new ByteBufInputStream(buf);\n        try {\n            test.setContent(is);\n            assertFalse(buf.isReadable());\n            assertEquals(test.getString(UTF_8), contentStr);\n            buf.resetReaderIndex();\n            assertTrue(ByteBufUtil.equals(buf, test.getByteBuf()));\n        } finally {\n            is.close();\n        }\n\n        Random random = new SecureRandom();\n\n        for (int i = 0; i < 20; i++) {\n            // Generate input data bytes.\n            int size = random.nextInt(Short.MAX_VALUE);\n            byte[] bytes = new byte[size];\n\n            random.nextBytes(bytes);\n\n            // Generate parsed HTTP data block.\n            TestHttpData data = new TestHttpData(\"name\", UTF_8, 0);\n\n            data.setContent(new ByteArrayInputStream(bytes));\n\n            // Validate stored data.\n            ByteBuf buffer = data.getByteBuf();\n\n            assertEquals(0, buffer.readerIndex());\n            assertEquals(bytes.length, buffer.writerIndex());\n            assertArrayEquals(bytes, Arrays.copyOf(buffer.array(), bytes.length));\n            assertArrayEquals(bytes, data.get());\n        }\n    }\n\n    /** Memory-based HTTP data implementation for test purposes. */\n    private static final class TestHttpData extends AbstractMemoryHttpData {\n        /**\n         * Constructs HTTP data for tests.\n         *\n         * @param name    Name of parsed data block.\n         * @param charset Used charset for data decoding.\n         * @param size    Expected data block size.\n         */\n        private TestHttpData(String name, Charset charset, long size) {\n            super(name, charset, size);\n        }\n\n        @Override\n        public InterfaceHttpData.HttpDataType getHttpDataType() {\n            throw reject();\n        }\n\n        @Override\n        public HttpData copy() {\n            throw reject();\n        }\n\n        @Override\n        public HttpData duplicate() {\n            throw reject();\n        }\n\n        @Override\n        public HttpData retainedDuplicate() {\n            throw reject();\n        }\n\n        @Override\n        public HttpData replace(ByteBuf content) {\n            return null;\n        }\n\n        @Override\n        public int compareTo(InterfaceHttpData o) {\n            throw reject();\n        }\n\n        @Override\n        public int hashCode() {\n            return super.hashCode();\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            return super.equals(obj);\n        }\n\n        private static UnsupportedOperationException reject() {\n            throw new UnsupportedOperationException(\"Should never be called.\");\n        }\n    }\n}\n", "/*\n * Copyright 2016 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.codec.http.multipart;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufInputStream;\nimport io.netty.buffer.ByteBufUtil;\nimport io.netty.buffer.Unpooled;\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.internal.PlatformDependent;\n\nimport org.junit.Test;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.UUID;\n\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\npublic class DiskFileUploadTest {\n    @Test\n    public void testSpecificCustomBaseDir() throws IOException {\n        File baseDir = new File(\"target/DiskFileUploadTest/testSpecificCustomBaseDir\");\n        baseDir.mkdirs(); // we don't need to clean it since it is in volatile files anyway\n        DiskFileUpload f =\n                new DiskFileUpload(\"d1\", \"d1\", \"application/json\", null, null, 100,\n                        baseDir.getAbsolutePath(), false);\n\n        f.setContent(Unpooled.EMPTY_BUFFER);\n\n        assertTrue(f.getFile().getAbsolutePath().startsWith(baseDir.getAbsolutePath()));\n        assertTrue(f.getFile().exists());\n        assertEquals(0, f.getFile().length());\n        f.delete();\n    }\n\n    @Test\n    public final void testDiskFileUploadEquals() {\n        DiskFileUpload f2 =\n                new DiskFileUpload(\"d1\", \"d1\", \"application/json\", null, null, 100);\n        assertEquals(f2, f2);\n        f2.delete();\n    }\n\n     @Test\n     public void testEmptyBufferSetMultipleTimes() throws IOException {\n         DiskFileUpload f =\n                 new DiskFileUpload(\"d1\", \"d1\", \"application/json\", null, null, 100);\n\n         f.setContent(Unpooled.EMPTY_BUFFER);\n\n         assertTrue(f.getFile().exists());\n         assertEquals(0, f.getFile().length());\n         f.setContent(Unpooled.EMPTY_BUFFER);\n         assertTrue(f.getFile().exists());\n         assertEquals(0, f.getFile().length());\n         f.delete();\n     }\n\n    @Test\n    public void testEmptyBufferSetAfterNonEmptyBuffer() throws IOException {\n        DiskFileUpload f =\n                new DiskFileUpload(\"d1\", \"d1\", \"application/json\", null, null, 100);\n\n        f.setContent(Unpooled.wrappedBuffer(new byte[] { 1, 2, 3, 4 }));\n\n        assertTrue(f.getFile().exists());\n        assertEquals(4, f.getFile().length());\n        f.setContent(Unpooled.EMPTY_BUFFER);\n        assertTrue(f.getFile().exists());\n        assertEquals(0, f.getFile().length());\n        f.delete();\n    }\n\n    @Test\n    public void testNonEmptyBufferSetMultipleTimes() throws IOException {\n        DiskFileUpload f =\n                new DiskFileUpload(\"d1\", \"d1\", \"application/json\", null, null, 100);\n\n        f.setContent(Unpooled.wrappedBuffer(new byte[] { 1, 2, 3, 4 }));\n\n        assertTrue(f.getFile().exists());\n        assertEquals(4, f.getFile().length());\n        f.setContent(Unpooled.wrappedBuffer(new byte[] { 1, 2}));\n        assertTrue(f.getFile().exists());\n        assertEquals(2, f.getFile().length());\n        f.delete();\n    }\n\n    @Test\n    public void testAddContents() throws Exception {\n        DiskFileUpload f1 = new DiskFileUpload(\"file1\", \"file1\", \"application/json\", null, null, 0);\n        try {\n            byte[] jsonBytes = new byte[4096];\n            PlatformDependent.threadLocalRandom().nextBytes(jsonBytes);\n\n            f1.addContent(Unpooled.wrappedBuffer(jsonBytes, 0, 1024), false);\n            f1.addContent(Unpooled.wrappedBuffer(jsonBytes, 1024, jsonBytes.length - 1024), true);\n            assertArrayEquals(jsonBytes, f1.get());\n\n            File file = f1.getFile();\n            assertEquals(jsonBytes.length, file.length());\n\n            FileInputStream fis = new FileInputStream(file);\n            try {\n                byte[] buf = new byte[jsonBytes.length];\n                int offset = 0;\n                int read = 0;\n                int len = buf.length;\n                while ((read = fis.read(buf, offset, len)) > 0) {\n                    len -= read;\n                    offset += read;\n                    if (len <= 0 || offset >= buf.length) {\n                        break;\n                    }\n                }\n                assertArrayEquals(jsonBytes, buf);\n            } finally {\n                fis.close();\n            }\n        } finally {\n            f1.delete();\n        }\n    }\n\n    @Test\n    public void testSetContentFromByteBuf() throws Exception {\n        DiskFileUpload f1 = new DiskFileUpload(\"file2\", \"file2\", \"application/json\", null, null, 0);\n        try {\n            String json = \"{\\\"hello\\\":\\\"world\\\"}\";\n            byte[] bytes = json.getBytes(CharsetUtil.UTF_8);\n            f1.setContent(Unpooled.wrappedBuffer(bytes));\n            assertEquals(json, f1.getString());\n            assertArrayEquals(bytes, f1.get());\n            File file = f1.getFile();\n            assertEquals((long) bytes.length, file.length());\n            assertArrayEquals(bytes, doReadFile(file, bytes.length));\n        } finally {\n            f1.delete();\n        }\n    }\n\n    @Test\n    public void testSetContentFromInputStream() throws Exception {\n        String json = \"{\\\"hello\\\":\\\"world\\\",\\\"foo\\\":\\\"bar\\\"}\";\n        DiskFileUpload f1 = new DiskFileUpload(\"file3\", \"file3\", \"application/json\", null, null, 0);\n        try {\n            byte[] bytes = json.getBytes(CharsetUtil.UTF_8);\n            ByteBuf buf = Unpooled.wrappedBuffer(bytes);\n            InputStream is = new ByteBufInputStream(buf);\n            try {\n                f1.setContent(is);\n                assertEquals(json, f1.getString());\n                assertArrayEquals(bytes, f1.get());\n                File file = f1.getFile();\n                assertEquals((long) bytes.length, file.length());\n                assertArrayEquals(bytes, doReadFile(file, bytes.length));\n            } finally {\n                buf.release();\n                is.close();\n            }\n        } finally {\n            f1.delete();\n        }\n    }\n\n    @Test\n    public void testAddContentFromByteBuf() throws Exception {\n        testAddContentFromByteBuf0(false);\n    }\n\n    @Test\n    public void testAddContentFromCompositeByteBuf() throws Exception {\n        testAddContentFromByteBuf0(true);\n    }\n\n    private static void testAddContentFromByteBuf0(boolean composite) throws Exception {\n        DiskFileUpload f1 = new DiskFileUpload(\"file3\", \"file3\", \"application/json\", null, null, 0);\n        try {\n            byte[] bytes = new byte[4096];\n            PlatformDependent.threadLocalRandom().nextBytes(bytes);\n\n            final ByteBuf buffer;\n\n            if (composite) {\n                buffer = Unpooled.compositeBuffer()\n                        .addComponent(true, Unpooled.wrappedBuffer(bytes, 0 , bytes.length / 2))\n                        .addComponent(true, Unpooled.wrappedBuffer(bytes, bytes.length / 2, bytes.length / 2));\n            } else {\n                buffer = Unpooled.wrappedBuffer(bytes);\n            }\n            f1.addContent(buffer, true);\n            ByteBuf buf = f1.getByteBuf();\n            assertEquals(buf.readerIndex(), 0);\n            assertEquals(buf.writerIndex(), bytes.length);\n            assertArrayEquals(bytes, ByteBufUtil.getBytes(buf));\n        } finally {\n            //release the ByteBuf\n            f1.delete();\n        }\n    }\n\n    private static byte[] doReadFile(File file, int maxRead) throws Exception {\n        FileInputStream fis = new FileInputStream(file);\n        try {\n            byte[] buf = new byte[maxRead];\n            int offset = 0;\n            int read = 0;\n            int len = buf.length;\n            while ((read = fis.read(buf, offset, len)) > 0) {\n                len -= read;\n                offset += read;\n                if (len <= 0 || offset >= buf.length) {\n                    break;\n                }\n            }\n            return buf;\n        } finally {\n            fis.close();\n        }\n    }\n\n    @Test\n    public void testDelete() throws Exception {\n        String json = \"{\\\"foo\\\":\\\"bar\\\"}\";\n        byte[] bytes = json.getBytes(CharsetUtil.UTF_8);\n        File tmpFile = null;\n        DiskFileUpload f1 = new DiskFileUpload(\"file4\", \"file4\", \"application/json\", null, null, 0);\n        try {\n            assertNull(f1.getFile());\n            f1.setContent(Unpooled.wrappedBuffer(bytes));\n            assertNotNull(tmpFile = f1.getFile());\n        } finally {\n            f1.delete();\n            assertNull(f1.getFile());\n            assertNotNull(tmpFile);\n            assertFalse(tmpFile.exists());\n        }\n    }\n\n    @Test\n    public void setSetContentFromFileExceptionally() throws Exception {\n        final long maxSize = 4;\n        DiskFileUpload f1 = new DiskFileUpload(\"file5\", \"file5\", \"application/json\", null, null, 0);\n        f1.setMaxSize(maxSize);\n        try {\n            f1.setContent(Unpooled.wrappedBuffer(new byte[(int) maxSize]));\n            File originalFile = f1.getFile();\n            assertNotNull(originalFile);\n            assertEquals(maxSize, originalFile.length());\n            assertEquals(maxSize, f1.length());\n            byte[] bytes = new byte[8];\n            PlatformDependent.threadLocalRandom().nextBytes(bytes);\n            File tmpFile = PlatformDependent.createTempFile(UUID.randomUUID().toString(), \".tmp\", null);\n            tmpFile.deleteOnExit();\n            FileOutputStream fos = new FileOutputStream(tmpFile);\n            try {\n                fos.write(bytes);\n                fos.flush();\n            } finally {\n                fos.close();\n            }\n            try {\n                f1.setContent(tmpFile);\n                fail(\"should not reach here!\");\n            } catch (IOException e) {\n                assertNotNull(f1.getFile());\n                assertEquals(originalFile, f1.getFile());\n                assertEquals(maxSize, f1.length());\n            }\n        } finally {\n            f1.delete();\n        }\n    }\n}\n", "/*\n * Copyright 2014 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.util.internal;\n\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.internal.logging.InternalLogger;\nimport io.netty.util.internal.logging.InternalLoggerFactory;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.Method;\nimport java.net.URL;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Helper class to load JNI resources.\n *\n */\npublic final class NativeLibraryLoader {\n\n    private static final InternalLogger logger = InternalLoggerFactory.getInstance(NativeLibraryLoader.class);\n\n    private static final String NATIVE_RESOURCE_HOME = \"META-INF/native/\";\n    private static final File WORKDIR;\n    private static final boolean DELETE_NATIVE_LIB_AFTER_LOADING;\n    private static final boolean TRY_TO_PATCH_SHADED_ID;\n\n    // Just use a-Z and numbers as valid ID bytes.\n    private static final byte[] UNIQUE_ID_BYTES =\n            \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".getBytes(CharsetUtil.US_ASCII);\n\n    static {\n        String workdir = SystemPropertyUtil.get(\"io.netty.native.workdir\");\n        if (workdir != null) {\n            File f = new File(workdir);\n            f.mkdirs();\n\n            try {\n                f = f.getAbsoluteFile();\n            } catch (Exception ignored) {\n                // Good to have an absolute path, but it's OK.\n            }\n\n            WORKDIR = f;\n            logger.debug(\"-Dio.netty.native.workdir: \" + WORKDIR);\n        } else {\n            WORKDIR = PlatformDependent.tmpdir();\n            logger.debug(\"-Dio.netty.native.workdir: \" + WORKDIR + \" (io.netty.tmpdir)\");\n        }\n\n        DELETE_NATIVE_LIB_AFTER_LOADING = SystemPropertyUtil.getBoolean(\n                \"io.netty.native.deleteLibAfterLoading\", true);\n        logger.debug(\"-Dio.netty.native.deleteLibAfterLoading: {}\", DELETE_NATIVE_LIB_AFTER_LOADING);\n\n        TRY_TO_PATCH_SHADED_ID = SystemPropertyUtil.getBoolean(\n                \"io.netty.native.tryPatchShadedId\", true);\n        logger.debug(\"-Dio.netty.native.tryPatchShadedId: {}\", TRY_TO_PATCH_SHADED_ID);\n    }\n\n    /**\n     * Loads the first available library in the collection with the specified\n     * {@link ClassLoader}.\n     *\n     * @throws IllegalArgumentException\n     *         if none of the given libraries load successfully.\n     */\n    public static void loadFirstAvailable(ClassLoader loader, String... names) {\n        List<Throwable> suppressed = new ArrayList<Throwable>();\n        for (String name : names) {\n            try {\n                load(name, loader);\n                return;\n            } catch (Throwable t) {\n                suppressed.add(t);\n            }\n        }\n\n        IllegalArgumentException iae =\n                new IllegalArgumentException(\"Failed to load any of the given libraries: \" + Arrays.toString(names));\n        ThrowableUtil.addSuppressedAndClear(iae, suppressed);\n        throw iae;\n    }\n\n    /**\n     * The shading prefix added to this class's full name.\n     *\n     * @throws UnsatisfiedLinkError if the shader used something other than a prefix\n     */\n    private static String calculatePackagePrefix() {\n        String maybeShaded = NativeLibraryLoader.class.getName();\n        // Use ! instead of . to avoid shading utilities from modifying the string\n        String expected = \"io!netty!util!internal!NativeLibraryLoader\".replace('!', '.');\n        if (!maybeShaded.endsWith(expected)) {\n            throw new UnsatisfiedLinkError(String.format(\n                    \"Could not find prefix added to %s to get %s. When shading, only adding a \"\n                    + \"package prefix is supported\", expected, maybeShaded));\n        }\n        return maybeShaded.substring(0, maybeShaded.length() - expected.length());\n    }\n\n    /**\n     * Load the given library with the specified {@link ClassLoader}\n     */\n    public static void load(String originalName, ClassLoader loader) {\n        // Adjust expected name to support shading of native libraries.\n        String packagePrefix = calculatePackagePrefix().replace('.', '_');\n        String name = packagePrefix + originalName;\n        List<Throwable> suppressed = new ArrayList<Throwable>();\n        try {\n            // first try to load from java.library.path\n            loadLibrary(loader, name, false);\n            return;\n        } catch (Throwable ex) {\n            suppressed.add(ex);\n        }\n\n        String libname = System.mapLibraryName(name);\n        String path = NATIVE_RESOURCE_HOME + libname;\n\n        InputStream in = null;\n        OutputStream out = null;\n        File tmpFile = null;\n        URL url;\n        if (loader == null) {\n            url = ClassLoader.getSystemResource(path);\n        } else {\n            url = loader.getResource(path);\n        }\n        try {\n            if (url == null) {\n                if (PlatformDependent.isOsx()) {\n                    String fileName = path.endsWith(\".jnilib\") ? NATIVE_RESOURCE_HOME + \"lib\" + name + \".dynlib\" :\n                            NATIVE_RESOURCE_HOME + \"lib\" + name + \".jnilib\";\n                    if (loader == null) {\n                        url = ClassLoader.getSystemResource(fileName);\n                    } else {\n                        url = loader.getResource(fileName);\n                    }\n                    if (url == null) {\n                        FileNotFoundException fnf = new FileNotFoundException(fileName);\n                        ThrowableUtil.addSuppressedAndClear(fnf, suppressed);\n                        throw fnf;\n                    }\n                } else {\n                    FileNotFoundException fnf = new FileNotFoundException(path);\n                    ThrowableUtil.addSuppressedAndClear(fnf, suppressed);\n                    throw fnf;\n                }\n            }\n\n            int index = libname.lastIndexOf('.');\n            String prefix = libname.substring(0, index);\n            String suffix = libname.substring(index);\n\n            tmpFile = PlatformDependent.createTempFile(prefix, suffix, WORKDIR);\n            in = url.openStream();\n            out = new FileOutputStream(tmpFile);\n\n            if (shouldShadedLibraryIdBePatched(packagePrefix)) {\n                patchShadedLibraryId(in, out, originalName, name);\n            } else {\n                byte[] buffer = new byte[8192];\n                int length;\n                while ((length = in.read(buffer)) > 0) {\n                    out.write(buffer, 0, length);\n                }\n            }\n\n            out.flush();\n\n            // Close the output stream before loading the unpacked library,\n            // because otherwise Windows will refuse to load it when it's in use by other process.\n            closeQuietly(out);\n            out = null;\n            loadLibrary(loader, tmpFile.getPath(), true);\n        } catch (UnsatisfiedLinkError e) {\n            try {\n                if (tmpFile != null && tmpFile.isFile() && tmpFile.canRead() &&\n                    !NoexecVolumeDetector.canExecuteExecutable(tmpFile)) {\n                    // Pass \"io.netty.native.workdir\" as an argument to allow shading tools to see\n                    // the string. Since this is printed out to users to tell them what to do next,\n                    // we want the value to be correct even when shading.\n                    logger.info(\"{} exists but cannot be executed even when execute permissions set; \" +\n                                \"check volume for \\\"noexec\\\" flag; use -D{}=[path] \" +\n                                \"to set native working directory separately.\",\n                                tmpFile.getPath(), \"io.netty.native.workdir\");\n                }\n            } catch (Throwable t) {\n                suppressed.add(t);\n                logger.debug(\"Error checking if {} is on a file store mounted with noexec\", tmpFile, t);\n            }\n            // Re-throw to fail the load\n            ThrowableUtil.addSuppressedAndClear(e, suppressed);\n            throw e;\n        } catch (Exception e) {\n            UnsatisfiedLinkError ule = new UnsatisfiedLinkError(\"could not load a native library: \" + name);\n            ule.initCause(e);\n            ThrowableUtil.addSuppressedAndClear(ule, suppressed);\n            throw ule;\n        } finally {\n            closeQuietly(in);\n            closeQuietly(out);\n            // After we load the library it is safe to delete the file.\n            // We delete the file immediately to free up resources as soon as possible,\n            // and if this fails fallback to deleting on JVM exit.\n            if (tmpFile != null && (!DELETE_NATIVE_LIB_AFTER_LOADING || !tmpFile.delete())) {\n                tmpFile.deleteOnExit();\n            }\n        }\n    }\n\n    // Package-private for testing.\n    static boolean patchShadedLibraryId(InputStream in, OutputStream out, String originalName, String name)\n            throws IOException {\n        byte[] buffer = new byte[8192];\n        int length;\n        // We read the whole native lib into memory to make it easier to monkey-patch the id.\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(in.available());\n\n        while ((length = in.read(buffer)) > 0) {\n            byteArrayOutputStream.write(buffer, 0, length);\n        }\n        byteArrayOutputStream.flush();\n        byte[] bytes = byteArrayOutputStream.toByteArray();\n        byteArrayOutputStream.close();\n\n        final boolean patched;\n        // Try to patch the library id.\n        if (!patchShadedLibraryId(bytes, originalName, name)) {\n            // We did not find the Id, check if we used a originalName that has the os and arch as suffix.\n            // If this is the case we should also try to patch with the os and arch suffix removed.\n            String os = PlatformDependent.normalizedOs();\n            String arch = PlatformDependent.normalizedArch();\n            String osArch = \"_\" + os + \"_\" + arch;\n            if (originalName.endsWith(osArch)) {\n                patched = patchShadedLibraryId(bytes,\n                        originalName.substring(0, originalName.length() - osArch.length()), name);\n            } else {\n                patched = false;\n            }\n        } else {\n            patched = true;\n        }\n        out.write(bytes, 0, bytes.length);\n        return patched;\n    }\n\n    private static boolean shouldShadedLibraryIdBePatched(String packagePrefix) {\n        return TRY_TO_PATCH_SHADED_ID && PlatformDependent.isOsx() && !packagePrefix.isEmpty();\n    }\n\n    /**\n     * Try to patch shaded library to ensure it uses a unique ID.\n     */\n    private static boolean patchShadedLibraryId(byte[] bytes, String originalName, String name) {\n        // Our native libs always have the name as part of their id so we can search for it and replace it\n        // to make the ID unique if shading is used.\n        byte[] nameBytes = originalName.getBytes(CharsetUtil.UTF_8);\n        int idIdx = -1;\n\n        // Be aware this is a really raw way of patching a dylib but it does all we need without implementing\n        // a full mach-o parser and writer. Basically we just replace the the original bytes with some\n        // random bytes as part of the ID regeneration. The important thing here is that we need to use the same\n        // length to not corrupt the mach-o header.\n        outerLoop: for (int i = 0; i < bytes.length && bytes.length - i >= nameBytes.length; i++) {\n            int idx = i;\n            for (int j = 0; j < nameBytes.length;) {\n                if (bytes[idx++] != nameBytes[j++]) {\n                    // Did not match the name, increase the index and try again.\n                    break;\n                } else if (j == nameBytes.length) {\n                    // We found the index within the id.\n                    idIdx = i;\n                    break outerLoop;\n                }\n            }\n        }\n\n        if (idIdx == -1) {\n            logger.debug(\"Was not able to find the ID of the shaded native library {}, can't adjust it.\", name);\n            return false;\n        } else {\n            // We found our ID... now monkey-patch it!\n            for (int i = 0; i < nameBytes.length; i++) {\n                // We should only use bytes as replacement that are in our UNIQUE_ID_BYTES array.\n                bytes[idIdx + i] = UNIQUE_ID_BYTES[PlatformDependent.threadLocalRandom()\n                                                                    .nextInt(UNIQUE_ID_BYTES.length)];\n            }\n\n            if (logger.isDebugEnabled()) {\n                logger.debug(\n                        \"Found the ID of the shaded native library {}. Replacing ID part {} with {}\",\n                        name, originalName, new String(bytes, idIdx, nameBytes.length, CharsetUtil.UTF_8));\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Loading the native library into the specified {@link ClassLoader}.\n     * @param loader - The {@link ClassLoader} where the native library will be loaded into\n     * @param name - The native library path or name\n     * @param absolute - Whether the native library will be loaded by path or by name\n     */\n    private static void loadLibrary(final ClassLoader loader, final String name, final boolean absolute) {\n        Throwable suppressed = null;\n        try {\n            try {\n                // Make sure the helper is belong to the target ClassLoader.\n                final Class<?> newHelper = tryToLoadClass(loader, NativeLibraryUtil.class);\n                loadLibraryByHelper(newHelper, name, absolute);\n                logger.debug(\"Successfully loaded the library {}\", name);\n                return;\n            } catch (UnsatisfiedLinkError e) { // Should by pass the UnsatisfiedLinkError here!\n                suppressed = e;\n            } catch (Exception e) {\n                suppressed = e;\n            }\n            NativeLibraryUtil.loadLibrary(name, absolute);  // Fallback to local helper class.\n            logger.debug(\"Successfully loaded the library {}\", name);\n        } catch (NoSuchMethodError nsme) {\n            if (suppressed != null) {\n                ThrowableUtil.addSuppressed(nsme, suppressed);\n            }\n            rethrowWithMoreDetailsIfPossible(name, nsme);\n        } catch (UnsatisfiedLinkError ule) {\n            if (suppressed != null) {\n                ThrowableUtil.addSuppressed(ule, suppressed);\n            }\n            throw ule;\n        }\n    }\n\n    @SuppressJava6Requirement(reason = \"Guarded by version check\")\n    private static void rethrowWithMoreDetailsIfPossible(String name, NoSuchMethodError error) {\n        if (PlatformDependent.javaVersion() >= 7) {\n            throw new LinkageError(\n                    \"Possible multiple incompatible native libraries on the classpath for '\" + name + \"'?\", error);\n        }\n        throw error;\n    }\n\n    private static void loadLibraryByHelper(final Class<?> helper, final String name, final boolean absolute)\n            throws UnsatisfiedLinkError {\n        Object ret = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n            @Override\n            public Object run() {\n                try {\n                    // Invoke the helper to load the native library, if succeed, then the native\n                    // library belong to the specified ClassLoader.\n                    Method method = helper.getMethod(\"loadLibrary\", String.class, boolean.class);\n                    method.setAccessible(true);\n                    return method.invoke(null, name, absolute);\n                } catch (Exception e) {\n                    return e;\n                }\n            }\n        });\n        if (ret instanceof Throwable) {\n            Throwable t = (Throwable) ret;\n            assert !(t instanceof UnsatisfiedLinkError) : t + \" should be a wrapper throwable\";\n            Throwable cause = t.getCause();\n            if (cause instanceof UnsatisfiedLinkError) {\n                throw (UnsatisfiedLinkError) cause;\n            }\n            UnsatisfiedLinkError ule = new UnsatisfiedLinkError(t.getMessage());\n            ule.initCause(t);\n            throw ule;\n        }\n    }\n\n    /**\n     * Try to load the helper {@link Class} into specified {@link ClassLoader}.\n     * @param loader - The {@link ClassLoader} where to load the helper {@link Class}\n     * @param helper - The helper {@link Class}\n     * @return A new helper Class defined in the specified ClassLoader.\n     * @throws ClassNotFoundException Helper class not found or loading failed\n     */\n    private static Class<?> tryToLoadClass(final ClassLoader loader, final Class<?> helper)\n            throws ClassNotFoundException {\n        try {\n            return Class.forName(helper.getName(), false, loader);\n        } catch (ClassNotFoundException e1) {\n            if (loader == null) {\n                // cannot defineClass inside bootstrap class loader\n                throw e1;\n            }\n            try {\n                // The helper class is NOT found in target ClassLoader, we have to define the helper class.\n                final byte[] classBinary = classToByteArray(helper);\n                return AccessController.doPrivileged(new PrivilegedAction<Class<?>>() {\n                    @Override\n                    public Class<?> run() {\n                        try {\n                            // Define the helper class in the target ClassLoader,\n                            //  then we can call the helper to load the native library.\n                            Method defineClass = ClassLoader.class.getDeclaredMethod(\"defineClass\", String.class,\n                                    byte[].class, int.class, int.class);\n                            defineClass.setAccessible(true);\n                            return (Class<?>) defineClass.invoke(loader, helper.getName(), classBinary, 0,\n                                    classBinary.length);\n                        } catch (Exception e) {\n                            throw new IllegalStateException(\"Define class failed!\", e);\n                        }\n                    }\n                });\n            } catch (ClassNotFoundException e2) {\n                ThrowableUtil.addSuppressed(e2, e1);\n                throw e2;\n            } catch (RuntimeException e2) {\n                ThrowableUtil.addSuppressed(e2, e1);\n                throw e2;\n            } catch (Error e2) {\n                ThrowableUtil.addSuppressed(e2, e1);\n                throw e2;\n            }\n        }\n    }\n\n    /**\n     * Load the helper {@link Class} as a byte array, to be redefined in specified {@link ClassLoader}.\n     * @param clazz - The helper {@link Class} provided by this bundle\n     * @return The binary content of helper {@link Class}.\n     * @throws ClassNotFoundException Helper class not found or loading failed\n     */\n    private static byte[] classToByteArray(Class<?> clazz) throws ClassNotFoundException {\n        String fileName = clazz.getName();\n        int lastDot = fileName.lastIndexOf('.');\n        if (lastDot > 0) {\n            fileName = fileName.substring(lastDot + 1);\n        }\n        URL classUrl = clazz.getResource(fileName + \".class\");\n        if (classUrl == null) {\n            throw new ClassNotFoundException(clazz.getName());\n        }\n        byte[] buf = new byte[1024];\n        ByteArrayOutputStream out = new ByteArrayOutputStream(4096);\n        InputStream in = null;\n        try {\n            in = classUrl.openStream();\n            for (int r; (r = in.read(buf)) != -1;) {\n                out.write(buf, 0, r);\n            }\n            return out.toByteArray();\n        } catch (IOException ex) {\n            throw new ClassNotFoundException(clazz.getName(), ex);\n        } finally {\n            closeQuietly(in);\n            closeQuietly(out);\n        }\n    }\n\n    private static void closeQuietly(Closeable c) {\n        if (c != null) {\n            try {\n                c.close();\n            } catch (IOException ignore) {\n                // ignore\n            }\n        }\n    }\n\n    private NativeLibraryLoader() {\n        // Utility\n    }\n\n    private static final class NoexecVolumeDetector {\n\n        @SuppressJava6Requirement(reason = \"Usage guarded by java version check\")\n        private static boolean canExecuteExecutable(File file) throws IOException {\n            if (PlatformDependent.javaVersion() < 7) {\n                // Pre-JDK7, the Java API did not directly support POSIX permissions; instead of implementing a custom\n                // work-around, assume true, which disables the check.\n                return true;\n            }\n\n            // If we can already execute, there is nothing to do.\n            if (file.canExecute()) {\n                return true;\n            }\n\n            // On volumes, with noexec set, even files with the executable POSIX permissions will fail to execute.\n            // The File#canExecute() method honors this behavior, probaby via parsing the noexec flag when initializing\n            // the UnixFileStore, though the flag is not exposed via a public API.  To find out if library is being\n            // loaded off a volume with noexec, confirm or add executalbe permissions, then check File#canExecute().\n\n            // Note: We use FQCN to not break when netty is used in java6\n            Set<java.nio.file.attribute.PosixFilePermission> existingFilePermissions =\n                    java.nio.file.Files.getPosixFilePermissions(file.toPath());\n            Set<java.nio.file.attribute.PosixFilePermission> executePermissions =\n                    EnumSet.of(java.nio.file.attribute.PosixFilePermission.OWNER_EXECUTE,\n                            java.nio.file.attribute.PosixFilePermission.GROUP_EXECUTE,\n                            java.nio.file.attribute.PosixFilePermission.OTHERS_EXECUTE);\n            if (existingFilePermissions.containsAll(executePermissions)) {\n                return false;\n            }\n\n            Set<java.nio.file.attribute.PosixFilePermission> newPermissions = EnumSet.copyOf(existingFilePermissions);\n            newPermissions.addAll(executePermissions);\n            java.nio.file.Files.setPosixFilePermissions(file.toPath(), newPermissions);\n            return file.canExecute();\n        }\n\n        private NoexecVolumeDetector() {\n            // Utility\n        }\n    }\n}\n", "/*\n * Copyright 2012 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.util.internal;\n\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.internal.logging.InternalLogger;\nimport io.netty.util.internal.logging.InternalLoggerFactory;\nimport org.jctools.queues.MpscArrayQueue;\nimport org.jctools.queues.MpscChunkedArrayQueue;\nimport org.jctools.queues.MpscUnboundedArrayQueue;\nimport org.jctools.queues.SpscLinkedQueue;\nimport org.jctools.queues.atomic.MpscAtomicArrayQueue;\nimport org.jctools.queues.atomic.MpscChunkedAtomicArrayQueue;\nimport org.jctools.queues.atomic.MpscUnboundedAtomicArrayQueue;\nimport org.jctools.queues.atomic.SpscLinkedAtomicQueue;\nimport org.jctools.util.Pow2;\nimport org.jctools.util.UnsafeAccess;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.nio.file.Files;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Deque;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedDeque;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport static io.netty.util.internal.PlatformDependent0.HASH_CODE_ASCII_SEED;\nimport static io.netty.util.internal.PlatformDependent0.HASH_CODE_C1;\nimport static io.netty.util.internal.PlatformDependent0.HASH_CODE_C2;\nimport static io.netty.util.internal.PlatformDependent0.hashCodeAsciiSanitize;\nimport static io.netty.util.internal.PlatformDependent0.unalignedAccess;\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\n\n/**\n * Utility that detects various properties specific to the current runtime\n * environment, such as Java version and the availability of the\n * {@code sun.misc.Unsafe} object.\n * <p>\n * You can disable the use of {@code sun.misc.Unsafe} if you specify\n * the system property <strong>io.netty.noUnsafe</strong>.\n */\npublic final class PlatformDependent {\n\n    private static final InternalLogger logger = InternalLoggerFactory.getInstance(PlatformDependent.class);\n\n    private static final Pattern MAX_DIRECT_MEMORY_SIZE_ARG_PATTERN = Pattern.compile(\n            \"\\\\s*-XX:MaxDirectMemorySize\\\\s*=\\\\s*([0-9]+)\\\\s*([kKmMgG]?)\\\\s*$\");\n\n    private static final boolean IS_WINDOWS = isWindows0();\n    private static final boolean IS_OSX = isOsx0();\n    private static final boolean IS_J9_JVM = isJ9Jvm0();\n    private static final boolean IS_IVKVM_DOT_NET = isIkvmDotNet0();\n\n    private static final boolean MAYBE_SUPER_USER;\n\n    private static final boolean CAN_ENABLE_TCP_NODELAY_BY_DEFAULT = !isAndroid();\n\n    private static final Throwable UNSAFE_UNAVAILABILITY_CAUSE = unsafeUnavailabilityCause0();\n    private static final boolean DIRECT_BUFFER_PREFERRED;\n    private static final long MAX_DIRECT_MEMORY = maxDirectMemory0();\n\n    private static final int MPSC_CHUNK_SIZE =  1024;\n    private static final int MIN_MAX_MPSC_CAPACITY =  MPSC_CHUNK_SIZE * 2;\n    private static final int MAX_ALLOWED_MPSC_CAPACITY = Pow2.MAX_POW2;\n\n    private static final long BYTE_ARRAY_BASE_OFFSET = byteArrayBaseOffset0();\n\n    private static final File TMPDIR = tmpdir0();\n\n    private static final int BIT_MODE = bitMode0();\n    private static final String NORMALIZED_ARCH = normalizeArch(SystemPropertyUtil.get(\"os.arch\", \"\"));\n    private static final String NORMALIZED_OS = normalizeOs(SystemPropertyUtil.get(\"os.name\", \"\"));\n\n    // keep in sync with maven's pom.xml via os.detection.classifierWithLikes!\n    private static final String[] ALLOWED_LINUX_OS_CLASSIFIERS = {\"fedora\", \"suse\", \"arch\"};\n    private static final Set<String> LINUX_OS_CLASSIFIERS;\n\n    private static final int ADDRESS_SIZE = addressSize0();\n    private static final boolean USE_DIRECT_BUFFER_NO_CLEANER;\n    private static final AtomicLong DIRECT_MEMORY_COUNTER;\n    private static final long DIRECT_MEMORY_LIMIT;\n    private static final ThreadLocalRandomProvider RANDOM_PROVIDER;\n    private static final Cleaner CLEANER;\n    private static final int UNINITIALIZED_ARRAY_ALLOCATION_THRESHOLD;\n    // For specifications, see https://www.freedesktop.org/software/systemd/man/os-release.html\n    private static final String[] OS_RELEASE_FILES = {\"/etc/os-release\", \"/usr/lib/os-release\"};\n    private static final String LINUX_ID_PREFIX = \"ID=\";\n    private static final String LINUX_ID_LIKE_PREFIX = \"ID_LIKE=\";\n    public static final boolean BIG_ENDIAN_NATIVE_ORDER = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN;\n\n    private static final Cleaner NOOP = new Cleaner() {\n        @Override\n        public void freeDirectBuffer(ByteBuffer buffer) {\n            // NOOP\n        }\n    };\n\n    static {\n        if (javaVersion() >= 7) {\n            RANDOM_PROVIDER = new ThreadLocalRandomProvider() {\n                @Override\n                @SuppressJava6Requirement(reason = \"Usage guarded by java version check\")\n                public Random current() {\n                    return java.util.concurrent.ThreadLocalRandom.current();\n                }\n            };\n        } else {\n            RANDOM_PROVIDER = new ThreadLocalRandomProvider() {\n                @Override\n                public Random current() {\n                    return ThreadLocalRandom.current();\n                }\n            };\n        }\n\n        // Here is how the system property is used:\n        //\n        // * <  0  - Don't use cleaner, and inherit max direct memory from java. In this case the\n        //           \"practical max direct memory\" would be 2 * max memory as defined by the JDK.\n        // * == 0  - Use cleaner, Netty will not enforce max memory, and instead will defer to JDK.\n        // * >  0  - Don't use cleaner. This will limit Netty's total direct memory\n        //           (note: that JDK's direct memory limit is independent of this).\n        long maxDirectMemory = SystemPropertyUtil.getLong(\"io.netty.maxDirectMemory\", -1);\n\n        if (maxDirectMemory == 0 || !hasUnsafe() || !PlatformDependent0.hasDirectBufferNoCleanerConstructor()) {\n            USE_DIRECT_BUFFER_NO_CLEANER = false;\n            DIRECT_MEMORY_COUNTER = null;\n        } else {\n            USE_DIRECT_BUFFER_NO_CLEANER = true;\n            if (maxDirectMemory < 0) {\n                maxDirectMemory = MAX_DIRECT_MEMORY;\n                if (maxDirectMemory <= 0) {\n                    DIRECT_MEMORY_COUNTER = null;\n                } else {\n                    DIRECT_MEMORY_COUNTER = new AtomicLong();\n                }\n            } else {\n                DIRECT_MEMORY_COUNTER = new AtomicLong();\n            }\n        }\n        logger.debug(\"-Dio.netty.maxDirectMemory: {} bytes\", maxDirectMemory);\n        DIRECT_MEMORY_LIMIT = maxDirectMemory >= 1 ? maxDirectMemory : MAX_DIRECT_MEMORY;\n\n        int tryAllocateUninitializedArray =\n                SystemPropertyUtil.getInt(\"io.netty.uninitializedArrayAllocationThreshold\", 1024);\n        UNINITIALIZED_ARRAY_ALLOCATION_THRESHOLD = javaVersion() >= 9 && PlatformDependent0.hasAllocateArrayMethod() ?\n                tryAllocateUninitializedArray : -1;\n        logger.debug(\"-Dio.netty.uninitializedArrayAllocationThreshold: {}\", UNINITIALIZED_ARRAY_ALLOCATION_THRESHOLD);\n\n        MAYBE_SUPER_USER = maybeSuperUser0();\n\n        if (!isAndroid()) {\n            // only direct to method if we are not running on android.\n            // See https://github.com/netty/netty/issues/2604\n            if (javaVersion() >= 9) {\n                CLEANER = CleanerJava9.isSupported() ? new CleanerJava9() : NOOP;\n            } else {\n                CLEANER = CleanerJava6.isSupported() ? new CleanerJava6() : NOOP;\n            }\n        } else {\n            CLEANER = NOOP;\n        }\n\n        // We should always prefer direct buffers by default if we can use a Cleaner to release direct buffers.\n        DIRECT_BUFFER_PREFERRED = CLEANER != NOOP\n                                  && !SystemPropertyUtil.getBoolean(\"io.netty.noPreferDirect\", false);\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"-Dio.netty.noPreferDirect: {}\", !DIRECT_BUFFER_PREFERRED);\n        }\n\n        /*\n         * We do not want to log this message if unsafe is explicitly disabled. Do not remove the explicit no unsafe\n         * guard.\n         */\n        if (CLEANER == NOOP && !PlatformDependent0.isExplicitNoUnsafe()) {\n            logger.info(\n                    \"Your platform does not provide complete low-level API for accessing direct buffers reliably. \" +\n                    \"Unless explicitly requested, heap buffer will always be preferred to avoid potential system \" +\n                    \"instability.\");\n        }\n\n        final Set<String> allowedClassifiers = Collections.unmodifiableSet(\n                new HashSet<String>(Arrays.asList(ALLOWED_LINUX_OS_CLASSIFIERS)));\n        final Set<String> availableClassifiers = new LinkedHashSet<String>();\n        for (final String osReleaseFileName : OS_RELEASE_FILES) {\n            final File file = new File(osReleaseFileName);\n            boolean found = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {\n                @Override\n                public Boolean run() {\n                    try {\n                        if (file.exists()) {\n                            BufferedReader reader = null;\n                            try {\n                                reader = new BufferedReader(\n                                        new InputStreamReader(\n                                                new FileInputStream(file), CharsetUtil.UTF_8));\n\n                                String line;\n                                while ((line = reader.readLine()) != null) {\n                                    if (line.startsWith(LINUX_ID_PREFIX)) {\n                                        String id = normalizeOsReleaseVariableValue(\n                                                line.substring(LINUX_ID_PREFIX.length()));\n                                        addClassifier(allowedClassifiers, availableClassifiers, id);\n                                    } else if (line.startsWith(LINUX_ID_LIKE_PREFIX)) {\n                                        line = normalizeOsReleaseVariableValue(\n                                                line.substring(LINUX_ID_LIKE_PREFIX.length()));\n                                        addClassifier(allowedClassifiers, availableClassifiers, line.split(\"[ ]+\"));\n                                    }\n                                }\n                            } catch (SecurityException e) {\n                                logger.debug(\"Unable to read {}\", osReleaseFileName, e);\n                            } catch (IOException e) {\n                                logger.debug(\"Error while reading content of {}\", osReleaseFileName, e);\n                            } finally {\n                                if (reader != null) {\n                                    try {\n                                        reader.close();\n                                    } catch (IOException ignored) {\n                                        // Ignore\n                                    }\n                                }\n                            }\n                            // specification states we should only fall back if /etc/os-release does not exist\n                            return true;\n                        }\n                    } catch (SecurityException e) {\n                        logger.debug(\"Unable to check if {} exists\", osReleaseFileName, e);\n                    }\n                    return false;\n                }\n            });\n\n            if (found) {\n                break;\n            }\n        }\n        LINUX_OS_CLASSIFIERS = Collections.unmodifiableSet(availableClassifiers);\n    }\n\n    public static long byteArrayBaseOffset() {\n        return BYTE_ARRAY_BASE_OFFSET;\n    }\n\n    public static boolean hasDirectBufferNoCleanerConstructor() {\n        return PlatformDependent0.hasDirectBufferNoCleanerConstructor();\n    }\n\n    public static byte[] allocateUninitializedArray(int size) {\n        return UNINITIALIZED_ARRAY_ALLOCATION_THRESHOLD < 0 || UNINITIALIZED_ARRAY_ALLOCATION_THRESHOLD > size ?\n                new byte[size] : PlatformDependent0.allocateUninitializedArray(size);\n    }\n\n    /**\n     * Returns {@code true} if and only if the current platform is Android\n     */\n    public static boolean isAndroid() {\n        return PlatformDependent0.isAndroid();\n    }\n\n    /**\n     * Return {@code true} if the JVM is running on Windows\n     */\n    public static boolean isWindows() {\n        return IS_WINDOWS;\n    }\n\n    /**\n     * Return {@code true} if the JVM is running on OSX / MacOS\n     */\n    public static boolean isOsx() {\n        return IS_OSX;\n    }\n\n    /**\n     * Return {@code true} if the current user may be a super-user. Be aware that this is just an hint and so it may\n     * return false-positives.\n     */\n    public static boolean maybeSuperUser() {\n        return MAYBE_SUPER_USER;\n    }\n\n    /**\n     * Return the version of Java under which this library is used.\n     */\n    public static int javaVersion() {\n        return PlatformDependent0.javaVersion();\n    }\n\n    /**\n     * Returns {@code true} if and only if it is fine to enable TCP_NODELAY socket option by default.\n     */\n    public static boolean canEnableTcpNoDelayByDefault() {\n        return CAN_ENABLE_TCP_NODELAY_BY_DEFAULT;\n    }\n\n    /**\n     * Return {@code true} if {@code sun.misc.Unsafe} was found on the classpath and can be used for accelerated\n     * direct memory access.\n     */\n    public static boolean hasUnsafe() {\n        return UNSAFE_UNAVAILABILITY_CAUSE == null;\n    }\n\n    /**\n     * Return the reason (if any) why {@code sun.misc.Unsafe} was not available.\n     */\n    public static Throwable getUnsafeUnavailabilityCause() {\n        return UNSAFE_UNAVAILABILITY_CAUSE;\n    }\n\n    /**\n     * {@code true} if and only if the platform supports unaligned access.\n     *\n     * @see <a href=\"https://en.wikipedia.org/wiki/Segmentation_fault#Bus_error\">Wikipedia on segfault</a>\n     */\n    public static boolean isUnaligned() {\n        return PlatformDependent0.isUnaligned();\n    }\n\n    /**\n     * Returns {@code true} if the platform has reliable low-level direct buffer access API and a user has not specified\n     * {@code -Dio.netty.noPreferDirect} option.\n     */\n    public static boolean directBufferPreferred() {\n        return DIRECT_BUFFER_PREFERRED;\n    }\n\n    /**\n     * Returns the maximum memory reserved for direct buffer allocation.\n     */\n    public static long maxDirectMemory() {\n        return DIRECT_MEMORY_LIMIT;\n    }\n\n    /**\n     * Returns the current memory reserved for direct buffer allocation.\n     * This method returns -1 in case that a value is not available.\n     *\n     * @see #maxDirectMemory()\n     */\n    public static long usedDirectMemory() {\n        return DIRECT_MEMORY_COUNTER != null ? DIRECT_MEMORY_COUNTER.get() : -1;\n    }\n\n    /**\n     * Returns the temporary directory.\n     */\n    public static File tmpdir() {\n        return TMPDIR;\n    }\n\n    /**\n     * Returns the bit mode of the current VM (usually 32 or 64.)\n     */\n    public static int bitMode() {\n        return BIT_MODE;\n    }\n\n    /**\n     * Return the address size of the OS.\n     * 4 (for 32 bits systems ) and 8 (for 64 bits systems).\n     */\n    public static int addressSize() {\n        return ADDRESS_SIZE;\n    }\n\n    public static long allocateMemory(long size) {\n        return PlatformDependent0.allocateMemory(size);\n    }\n\n    public static void freeMemory(long address) {\n        PlatformDependent0.freeMemory(address);\n    }\n\n    public static long reallocateMemory(long address, long newSize) {\n        return PlatformDependent0.reallocateMemory(address, newSize);\n    }\n\n    /**\n     * Raises an exception bypassing compiler checks for checked exceptions.\n     */\n    public static void throwException(Throwable t) {\n        if (hasUnsafe()) {\n            PlatformDependent0.throwException(t);\n        } else {\n            PlatformDependent.<RuntimeException>throwException0(t);\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static <E extends Throwable> void throwException0(Throwable t) throws E {\n        throw (E) t;\n    }\n\n    /**\n     * Creates a new fastest {@link ConcurrentMap} implementation for the current platform.\n     */\n    public static <K, V> ConcurrentMap<K, V> newConcurrentHashMap() {\n        return new ConcurrentHashMap<K, V>();\n    }\n\n    /**\n     * Creates a new fastest {@link LongCounter} implementation for the current platform.\n     */\n    public static LongCounter newLongCounter() {\n        if (javaVersion() >= 8) {\n            return new LongAdderCounter();\n        } else {\n            return new AtomicLongCounter();\n        }\n    }\n\n    /**\n     * Creates a new fastest {@link ConcurrentMap} implementation for the current platform.\n     */\n    public static <K, V> ConcurrentMap<K, V> newConcurrentHashMap(int initialCapacity) {\n        return new ConcurrentHashMap<K, V>(initialCapacity);\n    }\n\n    /**\n     * Creates a new fastest {@link ConcurrentMap} implementation for the current platform.\n     */\n    public static <K, V> ConcurrentMap<K, V> newConcurrentHashMap(int initialCapacity, float loadFactor) {\n        return new ConcurrentHashMap<K, V>(initialCapacity, loadFactor);\n    }\n\n    /**\n     * Creates a new fastest {@link ConcurrentMap} implementation for the current platform.\n     */\n    public static <K, V> ConcurrentMap<K, V> newConcurrentHashMap(\n            int initialCapacity, float loadFactor, int concurrencyLevel) {\n        return new ConcurrentHashMap<K, V>(initialCapacity, loadFactor, concurrencyLevel);\n    }\n\n    /**\n     * Creates a new fastest {@link ConcurrentMap} implementation for the current platform.\n     */\n    public static <K, V> ConcurrentMap<K, V> newConcurrentHashMap(Map<? extends K, ? extends V> map) {\n        return new ConcurrentHashMap<K, V>(map);\n    }\n\n    /**\n     * Try to deallocate the specified direct {@link ByteBuffer}. Please note this method does nothing if\n     * the current platform does not support this operation or the specified buffer is not a direct buffer.\n     */\n    public static void freeDirectBuffer(ByteBuffer buffer) {\n        CLEANER.freeDirectBuffer(buffer);\n    }\n\n    public static long directBufferAddress(ByteBuffer buffer) {\n        return PlatformDependent0.directBufferAddress(buffer);\n    }\n\n    public static ByteBuffer directBuffer(long memoryAddress, int size) {\n        if (PlatformDependent0.hasDirectBufferNoCleanerConstructor()) {\n            return PlatformDependent0.newDirectBuffer(memoryAddress, size);\n        }\n        throw new UnsupportedOperationException(\n                \"sun.misc.Unsafe or java.nio.DirectByteBuffer.<init>(long, int) not available\");\n    }\n\n    public static Object getObject(Object object, long fieldOffset) {\n        return PlatformDependent0.getObject(object, fieldOffset);\n    }\n\n    public static int getInt(Object object, long fieldOffset) {\n        return PlatformDependent0.getInt(object, fieldOffset);\n    }\n\n    public static int getIntVolatile(long address) {\n        return PlatformDependent0.getIntVolatile(address);\n    }\n\n    public static void putIntOrdered(long adddress, int newValue) {\n        PlatformDependent0.putIntOrdered(adddress, newValue);\n    }\n\n    public static byte getByte(long address) {\n        return PlatformDependent0.getByte(address);\n    }\n\n    public static short getShort(long address) {\n        return PlatformDependent0.getShort(address);\n    }\n\n    public static int getInt(long address) {\n        return PlatformDependent0.getInt(address);\n    }\n\n    public static long getLong(long address) {\n        return PlatformDependent0.getLong(address);\n    }\n\n    public static byte getByte(byte[] data, int index) {\n        return PlatformDependent0.getByte(data, index);\n    }\n\n    public static byte getByte(byte[] data, long index) {\n        return PlatformDependent0.getByte(data, index);\n    }\n\n    public static short getShort(byte[] data, int index) {\n        return PlatformDependent0.getShort(data, index);\n    }\n\n    public static int getInt(byte[] data, int index) {\n        return PlatformDependent0.getInt(data, index);\n    }\n\n    public static int getInt(int[] data, long index) {\n        return PlatformDependent0.getInt(data, index);\n    }\n\n    public static long getLong(byte[] data, int index) {\n        return PlatformDependent0.getLong(data, index);\n    }\n\n    public static long getLong(long[] data, long index) {\n        return PlatformDependent0.getLong(data, index);\n    }\n\n    private static long getLongSafe(byte[] bytes, int offset) {\n        if (BIG_ENDIAN_NATIVE_ORDER) {\n            return (long) bytes[offset] << 56 |\n                    ((long) bytes[offset + 1] & 0xff) << 48 |\n                    ((long) bytes[offset + 2] & 0xff) << 40 |\n                    ((long) bytes[offset + 3] & 0xff) << 32 |\n                    ((long) bytes[offset + 4] & 0xff) << 24 |\n                    ((long) bytes[offset + 5] & 0xff) << 16 |\n                    ((long) bytes[offset + 6] & 0xff) <<  8 |\n                    (long) bytes[offset + 7] & 0xff;\n        }\n        return (long) bytes[offset] & 0xff |\n                ((long) bytes[offset + 1] & 0xff) << 8 |\n                ((long) bytes[offset + 2] & 0xff) << 16 |\n                ((long) bytes[offset + 3] & 0xff) << 24 |\n                ((long) bytes[offset + 4] & 0xff) << 32 |\n                ((long) bytes[offset + 5] & 0xff) << 40 |\n                ((long) bytes[offset + 6] & 0xff) << 48 |\n                (long) bytes[offset + 7] << 56;\n    }\n\n    private static int getIntSafe(byte[] bytes, int offset) {\n        if (BIG_ENDIAN_NATIVE_ORDER) {\n            return bytes[offset] << 24 |\n                    (bytes[offset + 1] & 0xff) << 16 |\n                    (bytes[offset + 2] & 0xff) << 8 |\n                    bytes[offset + 3] & 0xff;\n        }\n        return bytes[offset] & 0xff |\n                (bytes[offset + 1] & 0xff) << 8 |\n                (bytes[offset + 2] & 0xff) << 16 |\n                bytes[offset + 3] << 24;\n    }\n\n    private static short getShortSafe(byte[] bytes, int offset) {\n        if (BIG_ENDIAN_NATIVE_ORDER) {\n            return (short) (bytes[offset] << 8 | (bytes[offset + 1] & 0xff));\n        }\n        return (short) (bytes[offset] & 0xff | (bytes[offset + 1] << 8));\n    }\n\n    /**\n     * Identical to {@link PlatformDependent0#hashCodeAsciiCompute(long, int)} but for {@link CharSequence}.\n     */\n    private static int hashCodeAsciiCompute(CharSequence value, int offset, int hash) {\n        if (BIG_ENDIAN_NATIVE_ORDER) {\n            return hash * HASH_CODE_C1 +\n                    // Low order int\n                    hashCodeAsciiSanitizeInt(value, offset + 4) * HASH_CODE_C2 +\n                    // High order int\n                    hashCodeAsciiSanitizeInt(value, offset);\n        }\n        return hash * HASH_CODE_C1 +\n                // Low order int\n                hashCodeAsciiSanitizeInt(value, offset) * HASH_CODE_C2 +\n                // High order int\n                hashCodeAsciiSanitizeInt(value, offset + 4);\n    }\n\n    /**\n     * Identical to {@link PlatformDependent0#hashCodeAsciiSanitize(int)} but for {@link CharSequence}.\n     */\n    private static int hashCodeAsciiSanitizeInt(CharSequence value, int offset) {\n        if (BIG_ENDIAN_NATIVE_ORDER) {\n            // mimic a unsafe.getInt call on a big endian machine\n            return (value.charAt(offset + 3) & 0x1f) |\n                   (value.charAt(offset + 2) & 0x1f) << 8 |\n                   (value.charAt(offset + 1) & 0x1f) << 16 |\n                   (value.charAt(offset) & 0x1f) << 24;\n        }\n        return (value.charAt(offset + 3) & 0x1f) << 24 |\n               (value.charAt(offset + 2) & 0x1f) << 16 |\n               (value.charAt(offset + 1) & 0x1f) << 8 |\n               (value.charAt(offset) & 0x1f);\n    }\n\n    /**\n     * Identical to {@link PlatformDependent0#hashCodeAsciiSanitize(short)} but for {@link CharSequence}.\n     */\n    private static int hashCodeAsciiSanitizeShort(CharSequence value, int offset) {\n        if (BIG_ENDIAN_NATIVE_ORDER) {\n            // mimic a unsafe.getShort call on a big endian machine\n            return (value.charAt(offset + 1) & 0x1f) |\n                    (value.charAt(offset) & 0x1f) << 8;\n        }\n        return (value.charAt(offset + 1) & 0x1f) << 8 |\n                (value.charAt(offset) & 0x1f);\n    }\n\n    /**\n     * Identical to {@link PlatformDependent0#hashCodeAsciiSanitize(byte)} but for {@link CharSequence}.\n     */\n    private static int hashCodeAsciiSanitizeByte(char value) {\n        return value & 0x1f;\n    }\n\n    public static void putByte(long address, byte value) {\n        PlatformDependent0.putByte(address, value);\n    }\n\n    public static void putShort(long address, short value) {\n        PlatformDependent0.putShort(address, value);\n    }\n\n    public static void putInt(long address, int value) {\n        PlatformDependent0.putInt(address, value);\n    }\n\n    public static void putLong(long address, long value) {\n        PlatformDependent0.putLong(address, value);\n    }\n\n    public static void putByte(byte[] data, int index, byte value) {\n        PlatformDependent0.putByte(data, index, value);\n    }\n\n    public static void putByte(Object data, long offset, byte value) {\n        PlatformDependent0.putByte(data, offset, value);\n    }\n\n    public static void putShort(byte[] data, int index, short value) {\n        PlatformDependent0.putShort(data, index, value);\n    }\n\n    public static void putInt(byte[] data, int index, int value) {\n        PlatformDependent0.putInt(data, index, value);\n    }\n\n    public static void putLong(byte[] data, int index, long value) {\n        PlatformDependent0.putLong(data, index, value);\n    }\n\n    public static void putObject(Object o, long offset, Object x) {\n        PlatformDependent0.putObject(o, offset, x);\n    }\n\n    public static long objectFieldOffset(Field field) {\n        return PlatformDependent0.objectFieldOffset(field);\n    }\n\n    public static void copyMemory(long srcAddr, long dstAddr, long length) {\n        PlatformDependent0.copyMemory(srcAddr, dstAddr, length);\n    }\n\n    public static void copyMemory(byte[] src, int srcIndex, long dstAddr, long length) {\n        PlatformDependent0.copyMemory(src, BYTE_ARRAY_BASE_OFFSET + srcIndex, null, dstAddr, length);\n    }\n\n    public static void copyMemory(byte[] src, int srcIndex, byte[] dst, int dstIndex, long length) {\n        PlatformDependent0.copyMemory(src, BYTE_ARRAY_BASE_OFFSET + srcIndex,\n                                      dst, BYTE_ARRAY_BASE_OFFSET + dstIndex, length);\n    }\n\n    public static void copyMemory(long srcAddr, byte[] dst, int dstIndex, long length) {\n        PlatformDependent0.copyMemory(null, srcAddr, dst, BYTE_ARRAY_BASE_OFFSET + dstIndex, length);\n    }\n\n    public static void setMemory(byte[] dst, int dstIndex, long bytes, byte value) {\n        PlatformDependent0.setMemory(dst, BYTE_ARRAY_BASE_OFFSET + dstIndex, bytes, value);\n    }\n\n    public static void setMemory(long address, long bytes, byte value) {\n        PlatformDependent0.setMemory(address, bytes, value);\n    }\n\n    /**\n     * Allocate a new {@link ByteBuffer} with the given {@code capacity}. {@link ByteBuffer}s allocated with\n     * this method <strong>MUST</strong> be deallocated via {@link #freeDirectNoCleaner(ByteBuffer)}.\n     */\n    public static ByteBuffer allocateDirectNoCleaner(int capacity) {\n        assert USE_DIRECT_BUFFER_NO_CLEANER;\n\n        incrementMemoryCounter(capacity);\n        try {\n            return PlatformDependent0.allocateDirectNoCleaner(capacity);\n        } catch (Throwable e) {\n            decrementMemoryCounter(capacity);\n            throwException(e);\n            return null;\n        }\n    }\n\n    /**\n     * Reallocate a new {@link ByteBuffer} with the given {@code capacity}. {@link ByteBuffer}s reallocated with\n     * this method <strong>MUST</strong> be deallocated via {@link #freeDirectNoCleaner(ByteBuffer)}.\n     */\n    public static ByteBuffer reallocateDirectNoCleaner(ByteBuffer buffer, int capacity) {\n        assert USE_DIRECT_BUFFER_NO_CLEANER;\n\n        int len = capacity - buffer.capacity();\n        incrementMemoryCounter(len);\n        try {\n            return PlatformDependent0.reallocateDirectNoCleaner(buffer, capacity);\n        } catch (Throwable e) {\n            decrementMemoryCounter(len);\n            throwException(e);\n            return null;\n        }\n    }\n\n    /**\n     * This method <strong>MUST</strong> only be called for {@link ByteBuffer}s that were allocated via\n     * {@link #allocateDirectNoCleaner(int)}.\n     */\n    public static void freeDirectNoCleaner(ByteBuffer buffer) {\n        assert USE_DIRECT_BUFFER_NO_CLEANER;\n\n        int capacity = buffer.capacity();\n        PlatformDependent0.freeMemory(PlatformDependent0.directBufferAddress(buffer));\n        decrementMemoryCounter(capacity);\n    }\n\n    private static void incrementMemoryCounter(int capacity) {\n        if (DIRECT_MEMORY_COUNTER != null) {\n            long newUsedMemory = DIRECT_MEMORY_COUNTER.addAndGet(capacity);\n            if (newUsedMemory > DIRECT_MEMORY_LIMIT) {\n                DIRECT_MEMORY_COUNTER.addAndGet(-capacity);\n                throw new OutOfDirectMemoryError(\"failed to allocate \" + capacity\n                        + \" byte(s) of direct memory (used: \" + (newUsedMemory - capacity)\n                        + \", max: \" + DIRECT_MEMORY_LIMIT + ')');\n            }\n        }\n    }\n\n    private static void decrementMemoryCounter(int capacity) {\n        if (DIRECT_MEMORY_COUNTER != null) {\n            long usedMemory = DIRECT_MEMORY_COUNTER.addAndGet(-capacity);\n            assert usedMemory >= 0;\n        }\n    }\n\n    public static boolean useDirectBufferNoCleaner() {\n        return USE_DIRECT_BUFFER_NO_CLEANER;\n    }\n\n    /**\n     * Compare two {@code byte} arrays for equality. For performance reasons no bounds checking on the\n     * parameters is performed.\n     *\n     * @param bytes1 the first byte array.\n     * @param startPos1 the position (inclusive) to start comparing in {@code bytes1}.\n     * @param bytes2 the second byte array.\n     * @param startPos2 the position (inclusive) to start comparing in {@code bytes2}.\n     * @param length the amount of bytes to compare. This is assumed to be validated as not going out of bounds\n     * by the caller.\n     */\n    public static boolean equals(byte[] bytes1, int startPos1, byte[] bytes2, int startPos2, int length) {\n        return !hasUnsafe() || !unalignedAccess() ?\n                  equalsSafe(bytes1, startPos1, bytes2, startPos2, length) :\n                  PlatformDependent0.equals(bytes1, startPos1, bytes2, startPos2, length);\n    }\n\n    /**\n     * Determine if a subsection of an array is zero.\n     * @param bytes The byte array.\n     * @param startPos The starting index (inclusive) in {@code bytes}.\n     * @param length The amount of bytes to check for zero.\n     * @return {@code false} if {@code bytes[startPos:startsPos+length)} contains a value other than zero.\n     */\n    public static boolean isZero(byte[] bytes, int startPos, int length) {\n        return !hasUnsafe() || !unalignedAccess() ?\n                isZeroSafe(bytes, startPos, length) :\n                PlatformDependent0.isZero(bytes, startPos, length);\n    }\n\n    /**\n     * Compare two {@code byte} arrays for equality without leaking timing information.\n     * For performance reasons no bounds checking on the parameters is performed.\n     * <p>\n     * The {@code int} return type is intentional and is designed to allow cascading of constant time operations:\n     * <pre>\n     *     byte[] s1 = new {1, 2, 3};\n     *     byte[] s2 = new {1, 2, 3};\n     *     byte[] s3 = new {1, 2, 3};\n     *     byte[] s4 = new {4, 5, 6};\n     *     boolean equals = (equalsConstantTime(s1, 0, s2, 0, s1.length) &\n     *                       equalsConstantTime(s3, 0, s4, 0, s3.length)) != 0;\n     * </pre>\n     * @param bytes1 the first byte array.\n     * @param startPos1 the position (inclusive) to start comparing in {@code bytes1}.\n     * @param bytes2 the second byte array.\n     * @param startPos2 the position (inclusive) to start comparing in {@code bytes2}.\n     * @param length the amount of bytes to compare. This is assumed to be validated as not going out of bounds\n     * by the caller.\n     * @return {@code 0} if not equal. {@code 1} if equal.\n     */\n    public static int equalsConstantTime(byte[] bytes1, int startPos1, byte[] bytes2, int startPos2, int length) {\n        return !hasUnsafe() || !unalignedAccess() ?\n                  ConstantTimeUtils.equalsConstantTime(bytes1, startPos1, bytes2, startPos2, length) :\n                  PlatformDependent0.equalsConstantTime(bytes1, startPos1, bytes2, startPos2, length);\n    }\n\n    /**\n     * Calculate a hash code of a byte array assuming ASCII character encoding.\n     * The resulting hash code will be case insensitive.\n     * @param bytes The array which contains the data to hash.\n     * @param startPos What index to start generating a hash code in {@code bytes}\n     * @param length The amount of bytes that should be accounted for in the computation.\n     * @return The hash code of {@code bytes} assuming ASCII character encoding.\n     * The resulting hash code will be case insensitive.\n     */\n    public static int hashCodeAscii(byte[] bytes, int startPos, int length) {\n        return !hasUnsafe() || !unalignedAccess() ?\n                hashCodeAsciiSafe(bytes, startPos, length) :\n                PlatformDependent0.hashCodeAscii(bytes, startPos, length);\n    }\n\n    /**\n     * Calculate a hash code of a byte array assuming ASCII character encoding.\n     * The resulting hash code will be case insensitive.\n     * <p>\n     * This method assumes that {@code bytes} is equivalent to a {@code byte[]} but just using {@link CharSequence}\n     * for storage. The upper most byte of each {@code char} from {@code bytes} is ignored.\n     * @param bytes The array which contains the data to hash (assumed to be equivalent to a {@code byte[]}).\n     * @return The hash code of {@code bytes} assuming ASCII character encoding.\n     * The resulting hash code will be case insensitive.\n     */\n    public static int hashCodeAscii(CharSequence bytes) {\n        final int length = bytes.length();\n        final int remainingBytes = length & 7;\n        int hash = HASH_CODE_ASCII_SEED;\n        // Benchmarking shows that by just naively looping for inputs 8~31 bytes long we incur a relatively large\n        // performance penalty (only achieve about 60% performance of loop which iterates over each char). So because\n        // of this we take special provisions to unroll the looping for these conditions.\n        if (length >= 32) {\n            for (int i = length - 8; i >= remainingBytes; i -= 8) {\n                hash = hashCodeAsciiCompute(bytes, i, hash);\n            }\n        } else if (length >= 8) {\n            hash = hashCodeAsciiCompute(bytes, length - 8, hash);\n            if (length >= 16) {\n                hash = hashCodeAsciiCompute(bytes, length - 16, hash);\n                if (length >= 24) {\n                    hash = hashCodeAsciiCompute(bytes, length - 24, hash);\n                }\n            }\n        }\n        if (remainingBytes == 0) {\n            return hash;\n        }\n        int offset = 0;\n        if (remainingBytes != 2 & remainingBytes != 4 & remainingBytes != 6) { // 1, 3, 5, 7\n            hash = hash * HASH_CODE_C1 + hashCodeAsciiSanitizeByte(bytes.charAt(0));\n            offset = 1;\n        }\n        if (remainingBytes != 1 & remainingBytes != 4 & remainingBytes != 5) { // 2, 3, 6, 7\n            hash = hash * (offset == 0 ? HASH_CODE_C1 : HASH_CODE_C2)\n                    + hashCodeAsciiSanitize(hashCodeAsciiSanitizeShort(bytes, offset));\n            offset += 2;\n        }\n        if (remainingBytes >= 4) { // 4, 5, 6, 7\n            return hash * ((offset == 0 | offset == 3) ? HASH_CODE_C1 : HASH_CODE_C2)\n                    + hashCodeAsciiSanitizeInt(bytes, offset);\n        }\n        return hash;\n    }\n\n    private static final class Mpsc {\n        private static final boolean USE_MPSC_CHUNKED_ARRAY_QUEUE;\n\n        private Mpsc() {\n        }\n\n        static {\n            Object unsafe = null;\n            if (hasUnsafe()) {\n                // jctools goes through its own process of initializing unsafe; of\n                // course, this requires permissions which might not be granted to calling code, so we\n                // must mark this block as privileged too\n                unsafe = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n                    @Override\n                    public Object run() {\n                        // force JCTools to initialize unsafe\n                        return UnsafeAccess.UNSAFE;\n                    }\n                });\n            }\n\n            if (unsafe == null) {\n                logger.debug(\"org.jctools-core.MpscChunkedArrayQueue: unavailable\");\n                USE_MPSC_CHUNKED_ARRAY_QUEUE = false;\n            } else {\n                logger.debug(\"org.jctools-core.MpscChunkedArrayQueue: available\");\n                USE_MPSC_CHUNKED_ARRAY_QUEUE = true;\n            }\n        }\n\n        static <T> Queue<T> newMpscQueue(final int maxCapacity) {\n            // Calculate the max capacity which can not be bigger than MAX_ALLOWED_MPSC_CAPACITY.\n            // This is forced by the MpscChunkedArrayQueue implementation as will try to round it\n            // up to the next power of two and so will overflow otherwise.\n            final int capacity = max(min(maxCapacity, MAX_ALLOWED_MPSC_CAPACITY), MIN_MAX_MPSC_CAPACITY);\n            return USE_MPSC_CHUNKED_ARRAY_QUEUE ? new MpscChunkedArrayQueue<T>(MPSC_CHUNK_SIZE, capacity)\n                                                : new MpscChunkedAtomicArrayQueue<T>(MPSC_CHUNK_SIZE, capacity);\n        }\n\n        static <T> Queue<T> newMpscQueue() {\n            return USE_MPSC_CHUNKED_ARRAY_QUEUE ? new MpscUnboundedArrayQueue<T>(MPSC_CHUNK_SIZE)\n                                                : new MpscUnboundedAtomicArrayQueue<T>(MPSC_CHUNK_SIZE);\n        }\n    }\n\n    /**\n     * Create a new {@link Queue} which is safe to use for multiple producers (different threads) and a single\n     * consumer (one thread!).\n     * @return A MPSC queue which may be unbounded.\n     */\n    public static <T> Queue<T> newMpscQueue() {\n        return Mpsc.newMpscQueue();\n    }\n\n    /**\n     * Create a new {@link Queue} which is safe to use for multiple producers (different threads) and a single\n     * consumer (one thread!).\n     */\n    public static <T> Queue<T> newMpscQueue(final int maxCapacity) {\n        return Mpsc.newMpscQueue(maxCapacity);\n    }\n\n    /**\n     * Create a new {@link Queue} which is safe to use for single producer (one thread!) and a single\n     * consumer (one thread!).\n     */\n    public static <T> Queue<T> newSpscQueue() {\n        return hasUnsafe() ? new SpscLinkedQueue<T>() : new SpscLinkedAtomicQueue<T>();\n    }\n\n    /**\n     * Create a new {@link Queue} which is safe to use for multiple producers (different threads) and a single\n     * consumer (one thread!) with the given fixes {@code capacity}.\n     */\n    public static <T> Queue<T> newFixedMpscQueue(int capacity) {\n        return hasUnsafe() ? new MpscArrayQueue<T>(capacity) : new MpscAtomicArrayQueue<T>(capacity);\n    }\n\n    /**\n     * Return the {@link ClassLoader} for the given {@link Class}.\n     */\n    public static ClassLoader getClassLoader(final Class<?> clazz) {\n        return PlatformDependent0.getClassLoader(clazz);\n    }\n\n    /**\n     * Return the context {@link ClassLoader} for the current {@link Thread}.\n     */\n    public static ClassLoader getContextClassLoader() {\n        return PlatformDependent0.getContextClassLoader();\n    }\n\n    /**\n     * Return the system {@link ClassLoader}.\n     */\n    public static ClassLoader getSystemClassLoader() {\n        return PlatformDependent0.getSystemClassLoader();\n    }\n\n    /**\n     * Returns a new concurrent {@link Deque}.\n     */\n    @SuppressJava6Requirement(reason = \"Usage guarded by java version check\")\n    public static <C> Deque<C> newConcurrentDeque() {\n        if (javaVersion() < 7) {\n            return new LinkedBlockingDeque<C>();\n        } else {\n            return new ConcurrentLinkedDeque<C>();\n        }\n    }\n\n    /**\n     * Return a {@link Random} which is not-threadsafe and so can only be used from the same thread.\n     */\n    public static Random threadLocalRandom() {\n        return RANDOM_PROVIDER.current();\n    }\n\n    private static boolean isWindows0() {\n        boolean windows = SystemPropertyUtil.get(\"os.name\", \"\").toLowerCase(Locale.US).contains(\"win\");\n        if (windows) {\n            logger.debug(\"Platform: Windows\");\n        }\n        return windows;\n    }\n\n    private static boolean isOsx0() {\n        String osname = SystemPropertyUtil.get(\"os.name\", \"\").toLowerCase(Locale.US)\n                .replaceAll(\"[^a-z0-9]+\", \"\");\n        boolean osx = osname.startsWith(\"macosx\") || osname.startsWith(\"osx\");\n\n        if (osx) {\n            logger.debug(\"Platform: MacOS\");\n        }\n        return osx;\n    }\n\n    private static boolean maybeSuperUser0() {\n        String username = SystemPropertyUtil.get(\"user.name\");\n        if (isWindows()) {\n            return \"Administrator\".equals(username);\n        }\n        // Check for root and toor as some BSDs have a toor user that is basically the same as root.\n        return \"root\".equals(username) || \"toor\".equals(username);\n    }\n\n    private static Throwable unsafeUnavailabilityCause0() {\n        if (isAndroid()) {\n            logger.debug(\"sun.misc.Unsafe: unavailable (Android)\");\n            return new UnsupportedOperationException(\"sun.misc.Unsafe: unavailable (Android)\");\n        }\n\n        if (isIkvmDotNet()) {\n            logger.debug(\"sun.misc.Unsafe: unavailable (IKVM.NET)\");\n            return new UnsupportedOperationException(\"sun.misc.Unsafe: unavailable (IKVM.NET)\");\n        }\n\n        Throwable cause = PlatformDependent0.getUnsafeUnavailabilityCause();\n        if (cause != null) {\n            return cause;\n        }\n\n        try {\n            boolean hasUnsafe = PlatformDependent0.hasUnsafe();\n            logger.debug(\"sun.misc.Unsafe: {}\", hasUnsafe ? \"available\" : \"unavailable\");\n            return hasUnsafe ? null : PlatformDependent0.getUnsafeUnavailabilityCause();\n        } catch (Throwable t) {\n            logger.trace(\"Could not determine if Unsafe is available\", t);\n            // Probably failed to initialize PlatformDependent0.\n            return new UnsupportedOperationException(\"Could not determine if Unsafe is available\", t);\n        }\n    }\n\n    /**\n     * Returns {@code true} if the running JVM is either <a href=\"https://developer.ibm.com/javasdk/\">IBM J9</a> or\n     * <a href=\"https://www.eclipse.org/openj9/\">Eclipse OpenJ9</a>, {@code false} otherwise.\n     */\n    public static boolean isJ9Jvm() {\n        return IS_J9_JVM;\n    }\n\n    private static boolean isJ9Jvm0() {\n        String vmName = SystemPropertyUtil.get(\"java.vm.name\", \"\").toLowerCase();\n        return vmName.startsWith(\"ibm j9\") || vmName.startsWith(\"eclipse openj9\");\n    }\n\n    /**\n     * Returns {@code true} if the running JVM is <a href=\"https://www.ikvm.net\">IKVM.NET</a>, {@code false} otherwise.\n     */\n    public static boolean isIkvmDotNet() {\n        return IS_IVKVM_DOT_NET;\n    }\n\n    private static boolean isIkvmDotNet0() {\n        String vmName = SystemPropertyUtil.get(\"java.vm.name\", \"\").toUpperCase(Locale.US);\n        return vmName.equals(\"IKVM.NET\");\n    }\n\n    private static long maxDirectMemory0() {\n        long maxDirectMemory = 0;\n\n        ClassLoader systemClassLoader = null;\n        try {\n            systemClassLoader = getSystemClassLoader();\n\n            // When using IBM J9 / Eclipse OpenJ9 we should not use VM.maxDirectMemory() as it not reflects the\n            // correct value.\n            // See:\n            //  - https://github.com/netty/netty/issues/7654\n            String vmName = SystemPropertyUtil.get(\"java.vm.name\", \"\").toLowerCase();\n            if (!vmName.startsWith(\"ibm j9\") &&\n                    // https://github.com/eclipse/openj9/blob/openj9-0.8.0/runtime/include/vendor_version.h#L53\n                    !vmName.startsWith(\"eclipse openj9\")) {\n                // Try to get from sun.misc.VM.maxDirectMemory() which should be most accurate.\n                Class<?> vmClass = Class.forName(\"sun.misc.VM\", true, systemClassLoader);\n                Method m = vmClass.getDeclaredMethod(\"maxDirectMemory\");\n                maxDirectMemory = ((Number) m.invoke(null)).longValue();\n            }\n        } catch (Throwable ignored) {\n            // Ignore\n        }\n\n        if (maxDirectMemory > 0) {\n            return maxDirectMemory;\n        }\n\n        try {\n            // Now try to get the JVM option (-XX:MaxDirectMemorySize) and parse it.\n            // Note that we are using reflection because Android doesn't have these classes.\n            Class<?> mgmtFactoryClass = Class.forName(\n                    \"java.lang.management.ManagementFactory\", true, systemClassLoader);\n            Class<?> runtimeClass = Class.forName(\n                    \"java.lang.management.RuntimeMXBean\", true, systemClassLoader);\n\n            Object runtime = mgmtFactoryClass.getDeclaredMethod(\"getRuntimeMXBean\").invoke(null);\n\n            @SuppressWarnings(\"unchecked\")\n            List<String> vmArgs = (List<String>) runtimeClass.getDeclaredMethod(\"getInputArguments\").invoke(runtime);\n            for (int i = vmArgs.size() - 1; i >= 0; i --) {\n                Matcher m = MAX_DIRECT_MEMORY_SIZE_ARG_PATTERN.matcher(vmArgs.get(i));\n                if (!m.matches()) {\n                    continue;\n                }\n\n                maxDirectMemory = Long.parseLong(m.group(1));\n                switch (m.group(2).charAt(0)) {\n                    case 'k': case 'K':\n                        maxDirectMemory *= 1024;\n                        break;\n                    case 'm': case 'M':\n                        maxDirectMemory *= 1024 * 1024;\n                        break;\n                    case 'g': case 'G':\n                        maxDirectMemory *= 1024 * 1024 * 1024;\n                        break;\n                    default:\n                        break;\n                }\n                break;\n            }\n        } catch (Throwable ignored) {\n            // Ignore\n        }\n\n        if (maxDirectMemory <= 0) {\n            maxDirectMemory = Runtime.getRuntime().maxMemory();\n            logger.debug(\"maxDirectMemory: {} bytes (maybe)\", maxDirectMemory);\n        } else {\n            logger.debug(\"maxDirectMemory: {} bytes\", maxDirectMemory);\n        }\n\n        return maxDirectMemory;\n    }\n\n    private static File tmpdir0() {\n        File f;\n        try {\n            f = toDirectory(SystemPropertyUtil.get(\"io.netty.tmpdir\"));\n            if (f != null) {\n                logger.debug(\"-Dio.netty.tmpdir: {}\", f);\n                return f;\n            }\n\n            f = toDirectory(SystemPropertyUtil.get(\"java.io.tmpdir\"));\n            if (f != null) {\n                logger.debug(\"-Dio.netty.tmpdir: {} (java.io.tmpdir)\", f);\n                return f;\n            }\n\n            // This shouldn't happen, but just in case ..\n            if (isWindows()) {\n                f = toDirectory(System.getenv(\"TEMP\"));\n                if (f != null) {\n                    logger.debug(\"-Dio.netty.tmpdir: {} (%TEMP%)\", f);\n                    return f;\n                }\n\n                String userprofile = System.getenv(\"USERPROFILE\");\n                if (userprofile != null) {\n                    f = toDirectory(userprofile + \"\\\\AppData\\\\Local\\\\Temp\");\n                    if (f != null) {\n                        logger.debug(\"-Dio.netty.tmpdir: {} (%USERPROFILE%\\\\AppData\\\\Local\\\\Temp)\", f);\n                        return f;\n                    }\n\n                    f = toDirectory(userprofile + \"\\\\Local Settings\\\\Temp\");\n                    if (f != null) {\n                        logger.debug(\"-Dio.netty.tmpdir: {} (%USERPROFILE%\\\\Local Settings\\\\Temp)\", f);\n                        return f;\n                    }\n                }\n            } else {\n                f = toDirectory(System.getenv(\"TMPDIR\"));\n                if (f != null) {\n                    logger.debug(\"-Dio.netty.tmpdir: {} ($TMPDIR)\", f);\n                    return f;\n                }\n            }\n        } catch (Throwable ignored) {\n            // Environment variable inaccessible\n        }\n\n        // Last resort.\n        if (isWindows()) {\n            f = new File(\"C:\\\\Windows\\\\Temp\");\n        } else {\n            f = new File(\"/tmp\");\n        }\n\n        logger.warn(\"Failed to get the temporary directory; falling back to: {}\", f);\n        return f;\n    }\n\n    @SuppressWarnings(\"ResultOfMethodCallIgnored\")\n    private static File toDirectory(String path) {\n        if (path == null) {\n            return null;\n        }\n\n        File f = new File(path);\n        f.mkdirs();\n\n        if (!f.isDirectory()) {\n            return null;\n        }\n\n        try {\n            return f.getAbsoluteFile();\n        } catch (Exception ignored) {\n            return f;\n        }\n    }\n\n    private static int bitMode0() {\n        // Check user-specified bit mode first.\n        int bitMode = SystemPropertyUtil.getInt(\"io.netty.bitMode\", 0);\n        if (bitMode > 0) {\n            logger.debug(\"-Dio.netty.bitMode: {}\", bitMode);\n            return bitMode;\n        }\n\n        // And then the vendor specific ones which is probably most reliable.\n        bitMode = SystemPropertyUtil.getInt(\"sun.arch.data.model\", 0);\n        if (bitMode > 0) {\n            logger.debug(\"-Dio.netty.bitMode: {} (sun.arch.data.model)\", bitMode);\n            return bitMode;\n        }\n        bitMode = SystemPropertyUtil.getInt(\"com.ibm.vm.bitmode\", 0);\n        if (bitMode > 0) {\n            logger.debug(\"-Dio.netty.bitMode: {} (com.ibm.vm.bitmode)\", bitMode);\n            return bitMode;\n        }\n\n        // os.arch also gives us a good hint.\n        String arch = SystemPropertyUtil.get(\"os.arch\", \"\").toLowerCase(Locale.US).trim();\n        if (\"amd64\".equals(arch) || \"x86_64\".equals(arch)) {\n            bitMode = 64;\n        } else if (\"i386\".equals(arch) || \"i486\".equals(arch) || \"i586\".equals(arch) || \"i686\".equals(arch)) {\n            bitMode = 32;\n        }\n\n        if (bitMode > 0) {\n            logger.debug(\"-Dio.netty.bitMode: {} (os.arch: {})\", bitMode, arch);\n        }\n\n        // Last resort: guess from VM name and then fall back to most common 64-bit mode.\n        String vm = SystemPropertyUtil.get(\"java.vm.name\", \"\").toLowerCase(Locale.US);\n        Pattern bitPattern = Pattern.compile(\"([1-9][0-9]+)-?bit\");\n        Matcher m = bitPattern.matcher(vm);\n        if (m.find()) {\n            return Integer.parseInt(m.group(1));\n        } else {\n            return 64;\n        }\n    }\n\n    private static int addressSize0() {\n        if (!hasUnsafe()) {\n            return -1;\n        }\n        return PlatformDependent0.addressSize();\n    }\n\n    private static long byteArrayBaseOffset0() {\n        if (!hasUnsafe()) {\n            return -1;\n        }\n        return PlatformDependent0.byteArrayBaseOffset();\n    }\n\n    private static boolean equalsSafe(byte[] bytes1, int startPos1, byte[] bytes2, int startPos2, int length) {\n        final int end = startPos1 + length;\n        for (; startPos1 < end; ++startPos1, ++startPos2) {\n            if (bytes1[startPos1] != bytes2[startPos2]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static boolean isZeroSafe(byte[] bytes, int startPos, int length) {\n        final int end = startPos + length;\n        for (; startPos < end; ++startPos) {\n            if (bytes[startPos] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Package private for testing purposes only!\n     */\n    static int hashCodeAsciiSafe(byte[] bytes, int startPos, int length) {\n        int hash = HASH_CODE_ASCII_SEED;\n        final int remainingBytes = length & 7;\n        final int end = startPos + remainingBytes;\n        for (int i = startPos - 8 + length; i >= end; i -= 8) {\n            hash = PlatformDependent0.hashCodeAsciiCompute(getLongSafe(bytes, i), hash);\n        }\n        switch(remainingBytes) {\n        case 7:\n            return ((hash * HASH_CODE_C1 + hashCodeAsciiSanitize(bytes[startPos]))\n                          * HASH_CODE_C2 + hashCodeAsciiSanitize(getShortSafe(bytes, startPos + 1)))\n                          * HASH_CODE_C1 + hashCodeAsciiSanitize(getIntSafe(bytes, startPos + 3));\n        case 6:\n            return (hash * HASH_CODE_C1 + hashCodeAsciiSanitize(getShortSafe(bytes, startPos)))\n                         * HASH_CODE_C2 + hashCodeAsciiSanitize(getIntSafe(bytes, startPos + 2));\n        case 5:\n            return (hash * HASH_CODE_C1 + hashCodeAsciiSanitize(bytes[startPos]))\n                         * HASH_CODE_C2 + hashCodeAsciiSanitize(getIntSafe(bytes, startPos + 1));\n        case 4:\n            return hash * HASH_CODE_C1 + hashCodeAsciiSanitize(getIntSafe(bytes, startPos));\n        case 3:\n            return (hash * HASH_CODE_C1 + hashCodeAsciiSanitize(bytes[startPos]))\n                         * HASH_CODE_C2 + hashCodeAsciiSanitize(getShortSafe(bytes, startPos + 1));\n        case 2:\n            return hash * HASH_CODE_C1 + hashCodeAsciiSanitize(getShortSafe(bytes, startPos));\n        case 1:\n            return hash * HASH_CODE_C1 + hashCodeAsciiSanitize(bytes[startPos]);\n        default:\n            return hash;\n        }\n    }\n\n    public static String normalizedArch() {\n        return NORMALIZED_ARCH;\n    }\n\n    public static String normalizedOs() {\n        return NORMALIZED_OS;\n    }\n\n    public static Set<String> normalizedLinuxClassifiers() {\n        return LINUX_OS_CLASSIFIERS;\n    }\n\n    @SuppressJava6Requirement(reason = \"Guarded by version check\")\n    public static File createTempFile(String prefix, String suffix, File directory) throws IOException {\n        if (javaVersion() >= 7) {\n            if (directory == null) {\n                return Files.createTempFile(prefix, suffix).toFile();\n            }\n            return Files.createTempFile(directory.toPath(), prefix, suffix).toFile();\n        }\n        if (directory == null) {\n            return File.createTempFile(prefix, suffix);\n        }\n        File file = File.createTempFile(prefix, suffix, directory);\n        // Try to adjust the perms, if this fails there is not much else we can do...\n        file.setReadable(false, false);\n        file.setReadable(true, true);\n        return file;\n    }\n\n    /**\n     * Adds only those classifier strings to <tt>dest</tt> which are present in <tt>allowed</tt>.\n     *\n     * @param allowed          allowed classifiers\n     * @param dest             destination set\n     * @param maybeClassifiers potential classifiers to add\n     */\n    private static void addClassifier(Set<String> allowed, Set<String> dest, String... maybeClassifiers) {\n        for (String id : maybeClassifiers) {\n            if (allowed.contains(id)) {\n                dest.add(id);\n            }\n        }\n    }\n\n    private static String normalizeOsReleaseVariableValue(String value) {\n        // Variable assignment values may be enclosed in double or single quotes.\n        return value.trim().replaceAll(\"[\\\"']\", \"\");\n    }\n\n    private static String normalize(String value) {\n        return value.toLowerCase(Locale.US).replaceAll(\"[^a-z0-9]+\", \"\");\n    }\n\n    private static String normalizeArch(String value) {\n        value = normalize(value);\n        if (value.matches(\"^(x8664|amd64|ia32e|em64t|x64)$\")) {\n            return \"x86_64\";\n        }\n        if (value.matches(\"^(x8632|x86|i[3-6]86|ia32|x32)$\")) {\n            return \"x86_32\";\n        }\n        if (value.matches(\"^(ia64|itanium64)$\")) {\n            return \"itanium_64\";\n        }\n        if (value.matches(\"^(sparc|sparc32)$\")) {\n            return \"sparc_32\";\n        }\n        if (value.matches(\"^(sparcv9|sparc64)$\")) {\n            return \"sparc_64\";\n        }\n        if (value.matches(\"^(arm|arm32)$\")) {\n            return \"arm_32\";\n        }\n        if (\"aarch64\".equals(value)) {\n            return \"aarch_64\";\n        }\n        if (value.matches(\"^(ppc|ppc32)$\")) {\n            return \"ppc_32\";\n        }\n        if (\"ppc64\".equals(value)) {\n            return \"ppc_64\";\n        }\n        if (\"ppc64le\".equals(value)) {\n            return \"ppcle_64\";\n        }\n        if (\"s390\".equals(value)) {\n            return \"s390_32\";\n        }\n        if (\"s390x\".equals(value)) {\n            return \"s390_64\";\n        }\n\n        return \"unknown\";\n    }\n\n    private static String normalizeOs(String value) {\n        value = normalize(value);\n        if (value.startsWith(\"aix\")) {\n            return \"aix\";\n        }\n        if (value.startsWith(\"hpux\")) {\n            return \"hpux\";\n        }\n        if (value.startsWith(\"os400\")) {\n            // Avoid the names such as os4000\n            if (value.length() <= 5 || !Character.isDigit(value.charAt(5))) {\n                return \"os400\";\n            }\n        }\n        if (value.startsWith(\"linux\")) {\n            return \"linux\";\n        }\n        if (value.startsWith(\"macosx\") || value.startsWith(\"osx\")) {\n            return \"osx\";\n        }\n        if (value.startsWith(\"freebsd\")) {\n            return \"freebsd\";\n        }\n        if (value.startsWith(\"openbsd\")) {\n            return \"openbsd\";\n        }\n        if (value.startsWith(\"netbsd\")) {\n            return \"netbsd\";\n        }\n        if (value.startsWith(\"solaris\") || value.startsWith(\"sunos\")) {\n            return \"sunos\";\n        }\n        if (value.startsWith(\"windows\")) {\n            return \"windows\";\n        }\n\n        return \"unknown\";\n    }\n\n    private static final class AtomicLongCounter extends AtomicLong implements LongCounter {\n        private static final long serialVersionUID = 4074772784610639305L;\n\n        @Override\n        public void add(long delta) {\n            addAndGet(delta);\n        }\n\n        @Override\n        public void increment() {\n            incrementAndGet();\n        }\n\n        @Override\n        public void decrement() {\n            decrementAndGet();\n        }\n\n        @Override\n        public long value() {\n            return get();\n        }\n    }\n\n    private interface ThreadLocalRandomProvider {\n        Random current();\n    }\n\n    private PlatformDependent() {\n        // only static method supported\n    }\n}\n", "/*\n * Copyright 2014 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\npackage io.netty.handler.ssl.util;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.handler.codec.base64.Base64;\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.internal.PlatformDependent;\nimport io.netty.util.internal.SystemPropertyUtil;\nimport io.netty.util.internal.ThrowableUtil;\nimport io.netty.util.internal.logging.InternalLogger;\nimport io.netty.util.internal.logging.InternalLoggerFactory;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.file.Files;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.SecureRandom;\nimport java.security.cert.CertificateEncodingException;\nimport java.security.cert.CertificateException;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.X509Certificate;\nimport java.util.Date;\n\n/**\n * Generates a temporary self-signed certificate for testing purposes.\n * <p>\n * <strong>NOTE:</strong>\n * Never use the certificate and private key generated by this class in production.\n * It is purely for testing purposes, and thus it is very insecure.\n * It even uses an insecure pseudo-random generator for faster generation internally.\n * </p><p>\n * An X.509 certificate file and a EC/RSA private key file are generated in a system's temporary directory using\n * {@link java.io.File#createTempFile(String, String)}, and they are deleted when the JVM exits using\n * {@link java.io.File#deleteOnExit()}.\n * </p><p>\n * At first, this method tries to use OpenJDK's X.509 implementation (the {@code sun.security.x509} package).\n * If it fails, it tries to use <a href=\"https://www.bouncycastle.org/\">Bouncy Castle</a> as a fallback.\n * </p>\n */\npublic final class SelfSignedCertificate {\n\n    private static final InternalLogger logger = InternalLoggerFactory.getInstance(SelfSignedCertificate.class);\n\n    /** Current time minus 1 year, just in case software clock goes back due to time synchronization */\n    private static final Date DEFAULT_NOT_BEFORE = new Date(SystemPropertyUtil.getLong(\n            \"io.netty.selfSignedCertificate.defaultNotBefore\", System.currentTimeMillis() - 86400000L * 365));\n    /** The maximum possible value in X.509 specification: 9999-12-31 23:59:59 */\n    private static final Date DEFAULT_NOT_AFTER = new Date(SystemPropertyUtil.getLong(\n            \"io.netty.selfSignedCertificate.defaultNotAfter\", 253402300799000L));\n\n    /**\n     * FIPS 140-2 encryption requires the RSA key length to be 2048 bits or greater.\n     * Let's use that as a sane default but allow the default to be set dynamically\n     * for those that need more stringent security requirements.\n     */\n    private static final int DEFAULT_KEY_LENGTH_BITS =\n            SystemPropertyUtil.getInt(\"io.netty.handler.ssl.util.selfSignedKeyStrength\", 2048);\n\n    private final File certificate;\n    private final File privateKey;\n    private final X509Certificate cert;\n    private final PrivateKey key;\n\n    /**\n     * Creates a new instance.\n     * <p> Algorithm: RSA </p>\n     */\n    public SelfSignedCertificate() throws CertificateException {\n        this(DEFAULT_NOT_BEFORE, DEFAULT_NOT_AFTER, \"RSA\", DEFAULT_KEY_LENGTH_BITS);\n    }\n\n    /**\n     * Creates a new instance.\n     * <p> Algorithm: RSA </p>\n     *\n     * @param notBefore Certificate is not valid before this time\n     * @param notAfter  Certificate is not valid after this time\n     */\n    public SelfSignedCertificate(Date notBefore, Date notAfter)\n            throws CertificateException {\n        this(\"localhost\", notBefore, notAfter, \"RSA\", DEFAULT_KEY_LENGTH_BITS);\n    }\n\n    /**\n     * Creates a new instance.\n     *\n     * @param notBefore Certificate is not valid before this time\n     * @param notAfter  Certificate is not valid after this time\n     * @param algorithm Key pair algorithm\n     * @param bits      the number of bits of the generated private key\n     */\n    public SelfSignedCertificate(Date notBefore, Date notAfter, String algorithm, int bits)\n            throws CertificateException {\n        this(\"localhost\", notBefore, notAfter, algorithm, bits);\n    }\n\n    /**\n     * Creates a new instance.\n     * <p> Algorithm: RSA </p>\n     *\n     * @param fqdn a fully qualified domain name\n     */\n    public SelfSignedCertificate(String fqdn) throws CertificateException {\n        this(fqdn, DEFAULT_NOT_BEFORE, DEFAULT_NOT_AFTER, \"RSA\", DEFAULT_KEY_LENGTH_BITS);\n    }\n\n    /**\n     * Creates a new instance.\n     *\n     * @param fqdn      a fully qualified domain name\n     * @param algorithm Key pair algorithm\n     * @param bits      the number of bits of the generated private key\n     */\n    public SelfSignedCertificate(String fqdn, String algorithm, int bits) throws CertificateException {\n        this(fqdn, DEFAULT_NOT_BEFORE, DEFAULT_NOT_AFTER, algorithm, bits);\n    }\n\n    /**\n     * Creates a new instance.\n     * <p> Algorithm: RSA </p>\n     *\n     * @param fqdn      a fully qualified domain name\n     * @param notBefore Certificate is not valid before this time\n     * @param notAfter  Certificate is not valid after this time\n     */\n    public SelfSignedCertificate(String fqdn, Date notBefore, Date notAfter) throws CertificateException {\n        // Bypass entropy collection by using insecure random generator.\n        // We just want to generate it without any delay because it's for testing purposes only.\n        this(fqdn, ThreadLocalInsecureRandom.current(), DEFAULT_KEY_LENGTH_BITS, notBefore, notAfter, \"RSA\");\n    }\n\n    /**\n     * Creates a new instance.\n     *\n     * @param fqdn      a fully qualified domain name\n     * @param notBefore Certificate is not valid before this time\n     * @param notAfter  Certificate is not valid after this time\n     * @param algorithm Key pair algorithm\n     * @param bits      the number of bits of the generated private key\n     */\n    public SelfSignedCertificate(String fqdn, Date notBefore, Date notAfter, String algorithm, int bits)\n            throws CertificateException {\n        // Bypass entropy collection by using insecure random generator.\n        // We just want to generate it without any delay because it's for testing purposes only.\n        this(fqdn, ThreadLocalInsecureRandom.current(), bits, notBefore, notAfter, algorithm);\n    }\n\n    /**\n     * Creates a new instance.\n     * <p> Algorithm: RSA </p>\n     *\n     * @param fqdn      a fully qualified domain name\n     * @param random    the {@link SecureRandom} to use\n     * @param bits      the number of bits of the generated private key\n     */\n    public SelfSignedCertificate(String fqdn, SecureRandom random, int bits)\n            throws CertificateException {\n        this(fqdn, random, bits, DEFAULT_NOT_BEFORE, DEFAULT_NOT_AFTER, \"RSA\");\n    }\n\n    /**\n     * Creates a new instance.\n     *\n     * @param fqdn      a fully qualified domain name\n     * @param random    the {@link SecureRandom} to use\n     * @param algorithm Key pair algorithm\n     * @param bits      the number of bits of the generated private key\n     */\n    public SelfSignedCertificate(String fqdn, SecureRandom random, String algorithm, int bits)\n            throws CertificateException {\n        this(fqdn, random, bits, DEFAULT_NOT_BEFORE, DEFAULT_NOT_AFTER, algorithm);\n    }\n\n    /**\n     * Creates a new instance.\n     * <p> Algorithm: RSA </p>\n     *\n     * @param fqdn      a fully qualified domain name\n     * @param random    the {@link SecureRandom} to use\n     * @param bits      the number of bits of the generated private key\n     * @param notBefore Certificate is not valid before this time\n     * @param notAfter  Certificate is not valid after this time\n     */\n    public SelfSignedCertificate(String fqdn, SecureRandom random, int bits, Date notBefore, Date notAfter)\n            throws CertificateException {\n        this(fqdn, random, bits, notBefore, notAfter, \"RSA\");\n    }\n\n    /**\n     * Creates a new instance.\n     *\n     * @param fqdn      a fully qualified domain name\n     * @param random    the {@link SecureRandom} to use\n     * @param bits      the number of bits of the generated private key\n     * @param notBefore Certificate is not valid before this time\n     * @param notAfter  Certificate is not valid after this time\n     * @param algorithm Key pair algorithm\n     */\n    public SelfSignedCertificate(String fqdn, SecureRandom random, int bits, Date notBefore, Date notAfter,\n                                 String algorithm) throws CertificateException {\n\n        if (!algorithm.equalsIgnoreCase(\"EC\") && !algorithm.equalsIgnoreCase(\"RSA\")) {\n            throw new IllegalArgumentException(\"Algorithm not valid: \" + algorithm);\n        }\n\n        final KeyPair keypair;\n        try {\n            KeyPairGenerator keyGen = KeyPairGenerator.getInstance(algorithm);\n            keyGen.initialize(bits, random);\n            keypair = keyGen.generateKeyPair();\n        } catch (NoSuchAlgorithmException e) {\n            // Should not reach here because every Java implementation must have RSA and EC key pair generator.\n            throw new Error(e);\n        }\n\n        String[] paths;\n        try {\n            // Try the OpenJDK's proprietary implementation.\n            paths = OpenJdkSelfSignedCertGenerator.generate(fqdn, keypair, random, notBefore, notAfter, algorithm);\n        } catch (Throwable t) {\n            logger.debug(\"Failed to generate a self-signed X.509 certificate using sun.security.x509:\", t);\n            try {\n                // Try Bouncy Castle if the current JVM didn't have sun.security.x509.\n                paths = BouncyCastleSelfSignedCertGenerator.generate(\n                        fqdn, keypair, random, notBefore, notAfter, algorithm);\n            } catch (Throwable t2) {\n                logger.debug(\"Failed to generate a self-signed X.509 certificate using Bouncy Castle:\", t2);\n                final CertificateException certificateException = new CertificateException(\n                        \"No provider succeeded to generate a self-signed certificate. \" +\n                                \"See debug log for the root cause.\", t2);\n                ThrowableUtil.addSuppressed(certificateException, t);\n                throw certificateException;\n            }\n        }\n\n        certificate = new File(paths[0]);\n        privateKey = new File(paths[1]);\n        key = keypair.getPrivate();\n        FileInputStream certificateInput = null;\n        try {\n            certificateInput = new FileInputStream(certificate);\n            cert = (X509Certificate) CertificateFactory.getInstance(\"X509\").generateCertificate(certificateInput);\n        } catch (Exception e) {\n            throw new CertificateEncodingException(e);\n        } finally {\n            if (certificateInput != null) {\n                try {\n                    certificateInput.close();\n                } catch (IOException e) {\n                    if (logger.isWarnEnabled()) {\n                        logger.warn(\"Failed to close a file: \" + certificate, e);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns the generated X.509 certificate file in PEM format.\n     */\n    public File certificate() {\n        return certificate;\n    }\n\n    /**\n     * Returns the generated RSA private key file in PEM format.\n     */\n    public File privateKey() {\n        return privateKey;\n    }\n\n    /**\n     *  Returns the generated X.509 certificate.\n     */\n    public X509Certificate cert() {\n        return cert;\n    }\n\n    /**\n     * Returns the generated RSA private key.\n     */\n    public PrivateKey key() {\n        return key;\n    }\n\n    /**\n     * Deletes the generated X.509 certificate file and RSA private key file.\n     */\n    public void delete() {\n        safeDelete(certificate);\n        safeDelete(privateKey);\n    }\n\n    static String[] newSelfSignedCertificate(\n            String fqdn, PrivateKey key, X509Certificate cert) throws IOException, CertificateEncodingException {\n        // Encode the private key into a file.\n        ByteBuf wrappedBuf = Unpooled.wrappedBuffer(key.getEncoded());\n        ByteBuf encodedBuf;\n        final String keyText;\n        try {\n            encodedBuf = Base64.encode(wrappedBuf, true);\n            try {\n                keyText = \"-----BEGIN PRIVATE KEY-----\\n\" +\n                        encodedBuf.toString(CharsetUtil.US_ASCII) +\n                        \"\\n-----END PRIVATE KEY-----\\n\";\n            } finally {\n                encodedBuf.release();\n            }\n        } finally {\n            wrappedBuf.release();\n        }\n\n        File keyFile = PlatformDependent.createTempFile(\"keyutil_\" + fqdn + '_', \".key\", null);\n        keyFile.deleteOnExit();\n\n        OutputStream keyOut = new FileOutputStream(keyFile);\n        try {\n            keyOut.write(keyText.getBytes(CharsetUtil.US_ASCII));\n            keyOut.close();\n            keyOut = null;\n        } finally {\n            if (keyOut != null) {\n                safeClose(keyFile, keyOut);\n                safeDelete(keyFile);\n            }\n        }\n\n        wrappedBuf = Unpooled.wrappedBuffer(cert.getEncoded());\n        final String certText;\n        try {\n            encodedBuf = Base64.encode(wrappedBuf, true);\n            try {\n                // Encode the certificate into a CRT file.\n                certText = \"-----BEGIN CERTIFICATE-----\\n\" +\n                        encodedBuf.toString(CharsetUtil.US_ASCII) +\n                        \"\\n-----END CERTIFICATE-----\\n\";\n            } finally {\n                encodedBuf.release();\n            }\n        } finally {\n            wrappedBuf.release();\n        }\n\n        File certFile = PlatformDependent.createTempFile(\"keyutil_\" + fqdn + '_', \".crt\", null);\n        certFile.deleteOnExit();\n\n        OutputStream certOut = new FileOutputStream(certFile);\n        try {\n            certOut.write(certText.getBytes(CharsetUtil.US_ASCII));\n            certOut.close();\n            certOut = null;\n        } finally {\n            if (certOut != null) {\n                safeClose(certFile, certOut);\n                safeDelete(certFile);\n                safeDelete(keyFile);\n            }\n        }\n\n        return new String[] { certFile.getPath(), keyFile.getPath() };\n    }\n\n    private static void safeDelete(File certFile) {\n        if (!certFile.delete()) {\n            if (logger.isWarnEnabled()) {\n                logger.warn(\"Failed to delete a file: \" + certFile);\n            }\n        }\n    }\n\n    private static void safeClose(File keyFile, OutputStream keyOut) {\n        try {\n            keyOut.close();\n        } catch (IOException e) {\n            if (logger.isWarnEnabled()) {\n                logger.warn(\"Failed to close a file: \" + keyFile, e);\n            }\n        }\n    }\n}\n", "/*\n * Copyright 2012 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.stream;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufAllocator;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelOutboundHandlerAdapter;\nimport io.netty.channel.ChannelPromise;\nimport io.netty.channel.embedded.EmbeddedChannel;\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.ReferenceCountUtil;\nimport io.netty.util.internal.PlatformDependent;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.channels.Channels;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.FileChannel;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport static java.util.concurrent.TimeUnit.*;\nimport static org.junit.Assert.*;\n\npublic class ChunkedWriteHandlerTest {\n    private static final byte[] BYTES = new byte[1024 * 64];\n    private static final File TMP;\n\n    static {\n        for (int i = 0; i < BYTES.length; i++) {\n            BYTES[i] = (byte) i;\n        }\n\n        FileOutputStream out = null;\n        try {\n            TMP = PlatformDependent.createTempFile(\"netty-chunk-\", \".tmp\", null);\n            TMP.deleteOnExit();\n            out = new FileOutputStream(TMP);\n            out.write(BYTES);\n            out.flush();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            if (out != null) {\n                try {\n                    out.close();\n                } catch (IOException e) {\n                    // ignore\n                }\n            }\n        }\n    }\n\n    // See #310\n    @Test\n    public void testChunkedStream() {\n        check(new ChunkedStream(new ByteArrayInputStream(BYTES)));\n\n        check(new ChunkedStream(new ByteArrayInputStream(BYTES)),\n                new ChunkedStream(new ByteArrayInputStream(BYTES)),\n                new ChunkedStream(new ByteArrayInputStream(BYTES)));\n    }\n\n    @Test\n    public void testChunkedNioStream() {\n        check(new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))));\n\n        check(new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))),\n                new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))),\n                new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))));\n    }\n\n    @Test\n    public void testChunkedFile() throws IOException {\n        check(new ChunkedFile(TMP));\n\n        check(new ChunkedFile(TMP), new ChunkedFile(TMP), new ChunkedFile(TMP));\n    }\n\n    @Test\n    public void testChunkedNioFile() throws IOException {\n        check(new ChunkedNioFile(TMP));\n\n        check(new ChunkedNioFile(TMP), new ChunkedNioFile(TMP), new ChunkedNioFile(TMP));\n    }\n\n    @Test\n    public void testChunkedNioFileLeftPositionUnchanged() throws IOException {\n        FileChannel in = null;\n        final long expectedPosition = 10;\n        try {\n            in = new RandomAccessFile(TMP, \"r\").getChannel();\n            in.position(expectedPosition);\n            check(new ChunkedNioFile(in) {\n                @Override\n                public void close() throws Exception {\n                    //no op\n                }\n            });\n            Assert.assertTrue(in.isOpen());\n            Assert.assertEquals(expectedPosition, in.position());\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n\n    @Test(expected = ClosedChannelException.class)\n    public void testChunkedNioFileFailOnClosedFileChannel() throws IOException {\n        final FileChannel in = new RandomAccessFile(TMP, \"r\").getChannel();\n        in.close();\n        check(new ChunkedNioFile(in) {\n            @Override\n            public void close() throws Exception {\n                //no op\n            }\n        });\n        Assert.fail();\n    }\n\n    @Test\n    public void testUnchunkedData() throws IOException {\n        check(Unpooled.wrappedBuffer(BYTES));\n\n        check(Unpooled.wrappedBuffer(BYTES), Unpooled.wrappedBuffer(BYTES), Unpooled.wrappedBuffer(BYTES));\n    }\n\n    // Test case which shows that there is not a bug like stated here:\n    // https://stackoverflow.com/a/10426305\n    @Test\n    public void testListenerNotifiedWhenIsEnd() {\n        ByteBuf buffer = Unpooled.copiedBuffer(\"Test\", CharsetUtil.ISO_8859_1);\n\n        ChunkedInput<ByteBuf> input = new ChunkedInput<ByteBuf>() {\n            private boolean done;\n            private final ByteBuf buffer = Unpooled.copiedBuffer(\"Test\", CharsetUtil.ISO_8859_1);\n\n            @Override\n            public boolean isEndOfInput() throws Exception {\n                return done;\n            }\n\n            @Override\n            public void close() throws Exception {\n                buffer.release();\n            }\n\n            @Deprecated\n            @Override\n            public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {\n                return readChunk(ctx.alloc());\n            }\n\n            @Override\n            public ByteBuf readChunk(ByteBufAllocator allocator) throws Exception {\n                if (done) {\n                    return null;\n                }\n                done = true;\n                return buffer.retainedDuplicate();\n            }\n\n            @Override\n            public long length() {\n                return -1;\n            }\n\n            @Override\n            public long progress() {\n                return 1;\n            }\n        };\n\n        final AtomicBoolean listenerNotified = new AtomicBoolean(false);\n        final ChannelFutureListener listener = new ChannelFutureListener() {\n\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                listenerNotified.set(true);\n            }\n        };\n\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n        ch.writeAndFlush(input).addListener(listener).syncUninterruptibly();\n        assertTrue(ch.finish());\n\n        // the listener should have been notified\n        assertTrue(listenerNotified.get());\n\n        ByteBuf buffer2 = ch.readOutbound();\n        assertEquals(buffer, buffer2);\n        assertNull(ch.readOutbound());\n\n        buffer.release();\n        buffer2.release();\n    }\n\n    @Test\n    public void testChunkedMessageInput() {\n\n        ChunkedInput<Object> input = new ChunkedInput<Object>() {\n            private boolean done;\n\n            @Override\n            public boolean isEndOfInput() throws Exception {\n                return done;\n            }\n\n            @Override\n            public void close() throws Exception {\n                // NOOP\n            }\n\n            @Deprecated\n            @Override\n            public Object readChunk(ChannelHandlerContext ctx) throws Exception {\n                return readChunk(ctx.alloc());\n            }\n\n            @Override\n            public Object readChunk(ByteBufAllocator ctx) throws Exception {\n                if (done) {\n                    return false;\n                }\n                done = true;\n                return 0;\n            }\n\n            @Override\n            public long length() {\n                return -1;\n            }\n\n            @Override\n            public long progress() {\n                return 1;\n            }\n        };\n\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n        ch.writeAndFlush(input).syncUninterruptibly();\n        assertTrue(ch.finish());\n\n        assertEquals(0, ch.readOutbound());\n        assertNull(ch.readOutbound());\n    }\n\n    @Test\n    public void testWriteFailureChunkedStream() throws IOException {\n        checkFirstFailed(new ChunkedStream(new ByteArrayInputStream(BYTES)));\n    }\n\n    @Test\n    public void testWriteFailureChunkedNioStream() throws IOException {\n        checkFirstFailed(new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))));\n    }\n\n    @Test\n    public void testWriteFailureChunkedFile() throws IOException {\n        checkFirstFailed(new ChunkedFile(TMP));\n    }\n\n    @Test\n    public void testWriteFailureChunkedNioFile() throws IOException {\n        checkFirstFailed(new ChunkedNioFile(TMP));\n    }\n\n    @Test\n    public void testWriteFailureUnchunkedData() throws IOException {\n        checkFirstFailed(Unpooled.wrappedBuffer(BYTES));\n    }\n\n    @Test\n    public void testSkipAfterFailedChunkedStream() throws IOException {\n        checkSkipFailed(new ChunkedStream(new ByteArrayInputStream(BYTES)),\n                        new ChunkedStream(new ByteArrayInputStream(BYTES)));\n    }\n\n    @Test\n    public void testSkipAfterFailedChunkedNioStream() throws IOException {\n        checkSkipFailed(new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))),\n                        new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))));\n    }\n\n    @Test\n    public void testSkipAfterFailedChunkedFile() throws IOException {\n        checkSkipFailed(new ChunkedFile(TMP), new ChunkedFile(TMP));\n    }\n\n    @Test\n    public void testSkipAfterFailedChunkedNioFile() throws IOException {\n        checkSkipFailed(new ChunkedNioFile(TMP), new ChunkedFile(TMP));\n    }\n\n    // See https://github.com/netty/netty/issues/8700.\n    @Test\n    public void testFailureWhenLastChunkFailed() throws IOException {\n        ChannelOutboundHandlerAdapter failLast = new ChannelOutboundHandlerAdapter() {\n            private int passedWrites;\n\n            @Override\n            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n                if (++this.passedWrites < 4) {\n                    ctx.write(msg, promise);\n                } else {\n                    ReferenceCountUtil.release(msg);\n                    promise.tryFailure(new RuntimeException());\n                }\n            }\n        };\n\n        EmbeddedChannel ch = new EmbeddedChannel(failLast, new ChunkedWriteHandler());\n        ChannelFuture r = ch.writeAndFlush(new ChunkedFile(TMP, 1024 * 16)); // 4 chunks\n        assertTrue(ch.finish());\n\n        assertFalse(r.isSuccess());\n        assertTrue(r.cause() instanceof RuntimeException);\n\n        // 3 out of 4 chunks were already written\n        int read = 0;\n        for (;;) {\n            ByteBuf buffer = ch.readOutbound();\n            if (buffer == null) {\n                break;\n            }\n            read += buffer.readableBytes();\n            buffer.release();\n        }\n\n        assertEquals(1024 * 16 * 3, read);\n    }\n\n    @Test\n    public void testDiscardPendingWritesOnInactive() throws IOException {\n\n        final AtomicBoolean closeWasCalled = new AtomicBoolean(false);\n\n        ChunkedInput<ByteBuf> notifiableInput = new ChunkedInput<ByteBuf>() {\n            private boolean done;\n            private final ByteBuf buffer = Unpooled.copiedBuffer(\"Test\", CharsetUtil.ISO_8859_1);\n\n            @Override\n            public boolean isEndOfInput() throws Exception {\n                return done;\n            }\n\n            @Override\n            public void close() throws Exception {\n                buffer.release();\n                closeWasCalled.set(true);\n            }\n\n            @Deprecated\n            @Override\n            public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {\n                return readChunk(ctx.alloc());\n            }\n\n            @Override\n            public ByteBuf readChunk(ByteBufAllocator allocator) throws Exception {\n                if (done) {\n                    return null;\n                }\n                done = true;\n                return buffer.retainedDuplicate();\n            }\n\n            @Override\n            public long length() {\n                return -1;\n            }\n\n            @Override\n            public long progress() {\n                return 1;\n            }\n        };\n\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n\n        // Write 3 messages and close channel before flushing\n        ChannelFuture r1 = ch.write(new ChunkedFile(TMP));\n        ChannelFuture r2 = ch.write(new ChunkedNioFile(TMP));\n        ch.write(notifiableInput);\n\n        // Should be `false` as we do not expect any messages to be written\n        assertFalse(ch.finish());\n\n        assertFalse(r1.isSuccess());\n        assertFalse(r2.isSuccess());\n        assertTrue(closeWasCalled.get());\n    }\n\n    // See https://github.com/netty/netty/issues/8700.\n    @Test\n    public void testStopConsumingChunksWhenFailed() {\n        final ByteBuf buffer = Unpooled.copiedBuffer(\"Test\", CharsetUtil.ISO_8859_1);\n        final AtomicInteger chunks = new AtomicInteger(0);\n\n        ChunkedInput<ByteBuf> nonClosableInput = new ChunkedInput<ByteBuf>() {\n            @Override\n            public boolean isEndOfInput() throws Exception {\n                return chunks.get() >= 5;\n            }\n\n            @Override\n            public void close() throws Exception {\n                // no-op\n            }\n\n            @Deprecated\n            @Override\n            public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {\n                return readChunk(ctx.alloc());\n            }\n\n            @Override\n            public ByteBuf readChunk(ByteBufAllocator allocator) throws Exception {\n                chunks.incrementAndGet();\n                return buffer.retainedDuplicate();\n            }\n\n            @Override\n            public long length() {\n                return -1;\n            }\n\n            @Override\n            public long progress() {\n                return 1;\n            }\n        };\n\n        ChannelOutboundHandlerAdapter noOpWrites = new ChannelOutboundHandlerAdapter() {\n            @Override\n            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n                ReferenceCountUtil.release(msg);\n                promise.tryFailure(new RuntimeException());\n            }\n        };\n\n        EmbeddedChannel ch = new EmbeddedChannel(noOpWrites, new ChunkedWriteHandler());\n        ch.writeAndFlush(nonClosableInput).awaitUninterruptibly();\n        // Should be `false` as we do not expect any messages to be written\n        assertFalse(ch.finish());\n        buffer.release();\n\n        // We should expect only single chunked being read from the input.\n        // It's possible to get a race condition here between resolving a promise and\n        // allocating a new chunk, but should be fine when working with embedded channels.\n        assertEquals(1, chunks.get());\n    }\n\n    @Test\n    public void testCloseSuccessfulChunkedInput() {\n        int chunks = 10;\n        TestChunkedInput input = new TestChunkedInput(chunks);\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n\n        assertTrue(ch.writeOutbound(input));\n\n        for (int i = 0; i < chunks; i++) {\n            ByteBuf buf = ch.readOutbound();\n            assertEquals(i, buf.readInt());\n            buf.release();\n        }\n\n        assertTrue(input.isClosed());\n        assertFalse(ch.finish());\n    }\n\n    @Test\n    public void testCloseFailedChunkedInput() {\n        Exception error = new Exception(\"Unable to produce a chunk\");\n        ThrowingChunkedInput input = new ThrowingChunkedInput(error);\n\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n\n        try {\n            ch.writeOutbound(input);\n            fail(\"Exception expected\");\n        } catch (Exception e) {\n            assertEquals(error, e);\n        }\n\n        assertTrue(input.isClosed());\n        assertFalse(ch.finish());\n    }\n\n    @Test\n    public void testWriteListenerInvokedAfterSuccessfulChunkedInputClosed() throws Exception {\n        final TestChunkedInput input = new TestChunkedInput(2);\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n\n        final AtomicBoolean inputClosedWhenListenerInvoked = new AtomicBoolean();\n        final CountDownLatch listenerInvoked = new CountDownLatch(1);\n\n        ChannelFuture writeFuture = ch.write(input);\n        writeFuture.addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) {\n                inputClosedWhenListenerInvoked.set(input.isClosed());\n                listenerInvoked.countDown();\n            }\n        });\n        ch.flush();\n\n        assertTrue(listenerInvoked.await(10, SECONDS));\n        assertTrue(writeFuture.isSuccess());\n        assertTrue(inputClosedWhenListenerInvoked.get());\n        assertTrue(ch.finishAndReleaseAll());\n    }\n\n    @Test\n    public void testWriteListenerInvokedAfterFailedChunkedInputClosed() throws Exception {\n        final ThrowingChunkedInput input = new ThrowingChunkedInput(new RuntimeException());\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n\n        final AtomicBoolean inputClosedWhenListenerInvoked = new AtomicBoolean();\n        final CountDownLatch listenerInvoked = new CountDownLatch(1);\n\n        ChannelFuture writeFuture = ch.write(input);\n        writeFuture.addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) {\n                inputClosedWhenListenerInvoked.set(input.isClosed());\n                listenerInvoked.countDown();\n            }\n        });\n        ch.flush();\n\n        assertTrue(listenerInvoked.await(10, SECONDS));\n        assertFalse(writeFuture.isSuccess());\n        assertTrue(inputClosedWhenListenerInvoked.get());\n        assertFalse(ch.finish());\n    }\n\n    @Test\n    public void testWriteListenerInvokedAfterChannelClosedAndInputFullyConsumed() throws Exception {\n        // use empty input which has endOfInput = true\n        final TestChunkedInput input = new TestChunkedInput(0);\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n\n        final AtomicBoolean inputClosedWhenListenerInvoked = new AtomicBoolean();\n        final CountDownLatch listenerInvoked = new CountDownLatch(1);\n\n        ChannelFuture writeFuture = ch.write(input);\n        writeFuture.addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) {\n                inputClosedWhenListenerInvoked.set(input.isClosed());\n                listenerInvoked.countDown();\n            }\n        });\n        ch.close(); // close channel to make handler discard the input on subsequent flush\n        ch.flush();\n\n        assertTrue(listenerInvoked.await(10, SECONDS));\n        assertTrue(writeFuture.isSuccess());\n        assertTrue(inputClosedWhenListenerInvoked.get());\n        assertFalse(ch.finish());\n    }\n\n    @Test\n    public void testWriteListenerInvokedAfterChannelClosedAndInputNotFullyConsumed() throws Exception {\n        // use non-empty input which has endOfInput = false\n        final TestChunkedInput input = new TestChunkedInput(42);\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n\n        final AtomicBoolean inputClosedWhenListenerInvoked = new AtomicBoolean();\n        final CountDownLatch listenerInvoked = new CountDownLatch(1);\n\n        ChannelFuture writeFuture = ch.write(input);\n        writeFuture.addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) {\n                inputClosedWhenListenerInvoked.set(input.isClosed());\n                listenerInvoked.countDown();\n            }\n        });\n        ch.close(); // close channel to make handler discard the input on subsequent flush\n        ch.flush();\n\n        assertTrue(listenerInvoked.await(10, SECONDS));\n        assertFalse(writeFuture.isSuccess());\n        assertTrue(inputClosedWhenListenerInvoked.get());\n        assertFalse(ch.finish());\n    }\n\n    private static void check(Object... inputs) {\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n\n        for (Object input: inputs) {\n            ch.writeOutbound(input);\n        }\n\n        assertTrue(ch.finish());\n\n        int i = 0;\n        int read = 0;\n        for (;;) {\n            ByteBuf buffer = ch.readOutbound();\n            if (buffer == null) {\n                break;\n            }\n            while (buffer.isReadable()) {\n                assertEquals(BYTES[i++], buffer.readByte());\n                read++;\n                if (i == BYTES.length) {\n                    i = 0;\n                }\n            }\n            buffer.release();\n        }\n\n        assertEquals(BYTES.length * inputs.length, read);\n    }\n\n    private static void checkFirstFailed(Object input) {\n        ChannelOutboundHandlerAdapter noOpWrites = new ChannelOutboundHandlerAdapter() {\n            @Override\n            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n                ReferenceCountUtil.release(msg);\n                promise.tryFailure(new RuntimeException());\n            }\n        };\n\n        EmbeddedChannel ch = new EmbeddedChannel(noOpWrites, new ChunkedWriteHandler());\n        ChannelFuture r = ch.writeAndFlush(input);\n\n        // Should be `false` as we do not expect any messages to be written\n        assertFalse(ch.finish());\n        assertTrue(r.cause() instanceof RuntimeException);\n    }\n\n    private static void checkSkipFailed(Object input1, Object input2) {\n        ChannelOutboundHandlerAdapter failFirst = new ChannelOutboundHandlerAdapter() {\n            private boolean alreadyFailed;\n\n            @Override\n            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n                if (alreadyFailed) {\n                    ctx.write(msg, promise);\n                } else {\n                    this.alreadyFailed = true;\n                    ReferenceCountUtil.release(msg);\n                    promise.tryFailure(new RuntimeException());\n                }\n            }\n        };\n\n        EmbeddedChannel ch = new EmbeddedChannel(failFirst, new ChunkedWriteHandler());\n        ChannelFuture r1 = ch.write(input1);\n        ChannelFuture r2 = ch.writeAndFlush(input2).awaitUninterruptibly();\n        assertTrue(ch.finish());\n\n        assertTrue(r1.cause() instanceof RuntimeException);\n        assertTrue(r2.isSuccess());\n\n        // note, that after we've \"skipped\" the first write,\n        // we expect to see the second message, chunk by chunk\n        int i = 0;\n        int read = 0;\n        for (;;) {\n            ByteBuf buffer = ch.readOutbound();\n            if (buffer == null) {\n                break;\n            }\n            while (buffer.isReadable()) {\n                assertEquals(BYTES[i++], buffer.readByte());\n                read++;\n                if (i == BYTES.length) {\n                    i = 0;\n                }\n            }\n            buffer.release();\n        }\n\n        assertEquals(BYTES.length, read);\n    }\n\n    private static final class TestChunkedInput implements ChunkedInput<ByteBuf> {\n        private final int chunksToProduce;\n\n        private int chunksProduced;\n        private volatile boolean closed;\n\n        TestChunkedInput(int chunksToProduce) {\n            this.chunksToProduce = chunksToProduce;\n        }\n\n        @Override\n        public boolean isEndOfInput() {\n            return chunksProduced >= chunksToProduce;\n        }\n\n        @Override\n        public void close() {\n            closed = true;\n        }\n\n        @Override\n        public ByteBuf readChunk(ChannelHandlerContext ctx) {\n            return readChunk(ctx.alloc());\n        }\n\n        @Override\n        public ByteBuf readChunk(ByteBufAllocator allocator) {\n            ByteBuf buf = allocator.buffer();\n            buf.writeInt(chunksProduced);\n            chunksProduced++;\n            return buf;\n        }\n\n        @Override\n        public long length() {\n            return chunksToProduce;\n        }\n\n        @Override\n        public long progress() {\n            return chunksProduced;\n        }\n\n        boolean isClosed() {\n            return closed;\n        }\n    }\n\n    private static final class ThrowingChunkedInput implements ChunkedInput<ByteBuf> {\n        private final Exception error;\n\n        private volatile boolean closed;\n\n        ThrowingChunkedInput(Exception error) {\n            this.error = error;\n        }\n\n        @Override\n        public boolean isEndOfInput() {\n            return false;\n        }\n\n        @Override\n        public void close() {\n            closed = true;\n        }\n\n        @Override\n        public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {\n            return readChunk(ctx.alloc());\n        }\n\n        @Override\n        public ByteBuf readChunk(ByteBufAllocator allocator) throws Exception {\n            throw error;\n        }\n\n        @Override\n        public long length() {\n            return -1;\n        }\n\n        @Override\n        public long progress() {\n            return -1;\n        }\n\n        boolean isClosed() {\n            return closed;\n        }\n    }\n}\n", "/*\n * Copyright 2020 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License, version\n * 2.0 (the \"License\"); you may not use this file except in compliance with the\n * License. You may obtain a copy of the License at:\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage io.netty.handler.traffic;\n\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.DefaultFileRegion;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.LineBasedFrameDecoder;\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.internal.PlatformDependent;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.net.SocketAddress;\nimport java.nio.charset.Charset;\nimport java.util.Random;\nimport java.util.concurrent.CountDownLatch;\n\nimport static org.junit.Assert.assertTrue;\n\npublic class FileRegionThrottleTest {\n    private static final byte[] BYTES = new byte[64 * 1024 * 4];\n    private static final long WRITE_LIMIT = 64 * 1024;\n    private static File tmp;\n    private EventLoopGroup group;\n\n    @BeforeClass\n    public static void beforeClass() throws IOException {\n        final Random r = new Random();\n        for (int i = 0; i < BYTES.length; i++) {\n            BYTES[i] = (byte) r.nextInt(255);\n        }\n\n        tmp = PlatformDependent.createTempFile(\"netty-traffic\", \".tmp\", null);\n        tmp.deleteOnExit();\n        FileOutputStream out = null;\n        try {\n            out = new FileOutputStream(tmp);\n            out.write(BYTES);\n            out.flush();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            if (out != null) {\n                try {\n                    out.close();\n                } catch (IOException e) {\n                    // ignore\n                }\n            }\n        }\n    }\n\n    @Before\n    public void setUp() {\n        group = new NioEventLoopGroup();\n    }\n\n    @After\n    public void tearDown() {\n        group.shutdownGracefully();\n    }\n\n    @Test\n    public void testGlobalWriteThrottle() throws Exception {\n        final CountDownLatch latch = new CountDownLatch(1);\n        final GlobalTrafficShapingHandler gtsh = new GlobalTrafficShapingHandler(group, WRITE_LIMIT, 0);\n        ServerBootstrap bs = new ServerBootstrap();\n        bs.group(group).channel(NioServerSocketChannel.class).childHandler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) {\n                ch.pipeline().addLast(new LineBasedFrameDecoder(Integer.MAX_VALUE));\n                ch.pipeline().addLast(new MessageDecoder());\n                ch.pipeline().addLast(gtsh);\n            }\n        });\n        Channel sc = bs.bind(0).sync().channel();\n        Channel cc = clientConnect(sc.localAddress(), new ReadHandler(latch)).channel();\n\n        long start = TrafficCounter.milliSecondFromNano();\n        cc.writeAndFlush(Unpooled.copiedBuffer(\"send-file\\n\", CharsetUtil.US_ASCII)).sync();\n        latch.await();\n        long timeTaken = TrafficCounter.milliSecondFromNano() - start;\n        assertTrue(\"Data streamed faster than expected\", timeTaken > 3000);\n        sc.close().sync();\n        cc.close().sync();\n    }\n\n    private ChannelFuture clientConnect(final SocketAddress server, final ReadHandler readHandler) throws Exception {\n        Bootstrap bc = new Bootstrap();\n        bc.group(group).channel(NioSocketChannel.class).handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) {\n                ch.pipeline().addLast(readHandler);\n            }\n        });\n        return bc.connect(server).sync();\n    }\n\n    private static final class MessageDecoder extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n            if (msg instanceof ByteBuf) {\n                ByteBuf buf = (ByteBuf) msg;\n                String message = buf.toString(Charset.defaultCharset());\n                buf.release();\n                if (message.equals(\"send-file\")) {\n                    RandomAccessFile raf = new RandomAccessFile(tmp, \"r\");\n                    ctx.channel().writeAndFlush(new DefaultFileRegion(raf.getChannel(), 0, tmp.length()));\n                }\n            }\n        }\n    }\n\n    private static final class ReadHandler extends ChannelInboundHandlerAdapter {\n        private long bytesTransferred;\n        private CountDownLatch latch;\n\n        ReadHandler(CountDownLatch latch) {\n            this.latch = latch;\n        }\n\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            if (msg instanceof ByteBuf) {\n                ByteBuf buf = (ByteBuf) msg;\n                bytesTransferred += buf.readableBytes();\n                buf.release();\n                if (bytesTransferred == tmp.length()) {\n                    latch.countDown();\n                }\n            }\n        }\n    }\n}\n", "/*\n * Copyright 2012 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.testsuite.transport.socket;\n\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandler;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.DefaultFileRegion;\nimport io.netty.channel.FileRegion;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.util.internal.PlatformDependent;\nimport org.hamcrest.CoreMatchers;\nimport org.junit.Test;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.channels.WritableByteChannel;\nimport java.util.Random;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.Assert.*;\n\npublic class SocketFileRegionTest extends AbstractSocketTest {\n\n    static final byte[] data = new byte[1048576 * 10];\n\n    static {\n        PlatformDependent.threadLocalRandom().nextBytes(data);\n    }\n\n    @Test\n    public void testFileRegion() throws Throwable {\n        run();\n    }\n\n    @Test\n    public void testCustomFileRegion() throws Throwable {\n        run();\n    }\n\n    @Test\n    public void testFileRegionNotAutoRead() throws Throwable {\n        run();\n    }\n\n    @Test\n    public void testFileRegionVoidPromise() throws Throwable {\n        run();\n    }\n\n    @Test\n    public void testFileRegionVoidPromiseNotAutoRead() throws Throwable {\n        run();\n    }\n\n    @Test\n    public void testFileRegionCountLargerThenFile() throws Throwable {\n        run();\n    }\n\n    public void testFileRegion(ServerBootstrap sb, Bootstrap cb) throws Throwable {\n        testFileRegion0(sb, cb, false, true, true);\n    }\n\n    public void testCustomFileRegion(ServerBootstrap sb, Bootstrap cb) throws Throwable {\n        testFileRegion0(sb, cb, false, true, false);\n    }\n\n    public void testFileRegionVoidPromise(ServerBootstrap sb, Bootstrap cb) throws Throwable {\n        testFileRegion0(sb, cb, true, true, true);\n    }\n\n    public void testFileRegionNotAutoRead(ServerBootstrap sb, Bootstrap cb) throws Throwable {\n        testFileRegion0(sb, cb, false, false, true);\n    }\n\n    public void testFileRegionVoidPromiseNotAutoRead(ServerBootstrap sb, Bootstrap cb) throws Throwable {\n        testFileRegion0(sb, cb, true, false, true);\n    }\n\n    public void testFileRegionCountLargerThenFile(ServerBootstrap sb, Bootstrap cb) throws Throwable {\n        File file = PlatformDependent.createTempFile(\"netty-\", \".tmp\", null);\n        file.deleteOnExit();\n\n        final FileOutputStream out = new FileOutputStream(file);\n        out.write(data);\n        out.close();\n\n        sb.childHandler(new SimpleChannelInboundHandler<ByteBuf>() {\n            @Override\n            protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) {\n                // Just drop the message.\n            }\n        });\n        cb.handler(new ChannelInboundHandlerAdapter());\n\n        Channel sc = sb.bind().sync().channel();\n        Channel cc = cb.connect(sc.localAddress()).sync().channel();\n\n        // Request file region which is bigger then the underlying file.\n        FileRegion region = new DefaultFileRegion(\n                new RandomAccessFile(file, \"r\").getChannel(), 0, data.length + 1024);\n\n        assertThat(cc.writeAndFlush(region).await().cause(), CoreMatchers.<Throwable>instanceOf(IOException.class));\n        cc.close().sync();\n        sc.close().sync();\n    }\n\n    private static void testFileRegion0(\n            ServerBootstrap sb, Bootstrap cb, boolean voidPromise, final boolean autoRead, boolean defaultFileRegion)\n            throws Throwable {\n        sb.childOption(ChannelOption.AUTO_READ, autoRead);\n        cb.option(ChannelOption.AUTO_READ, autoRead);\n\n        final int bufferSize = 1024;\n        final File file = PlatformDependent.createTempFile(\"netty-\", \".tmp\", null);\n        file.deleteOnExit();\n\n        final FileOutputStream out = new FileOutputStream(file);\n        final Random random = PlatformDependent.threadLocalRandom();\n\n        // Prepend random data which will not be transferred, so that we can test non-zero start offset\n        final int startOffset = random.nextInt(8192);\n        for (int i = 0; i < startOffset; i ++) {\n            out.write(random.nextInt());\n        }\n\n        // .. and here comes the real data to transfer.\n        out.write(data, bufferSize, data.length - bufferSize);\n\n        // .. and then some extra data which is not supposed to be transferred.\n        for (int i = random.nextInt(8192); i > 0; i --) {\n            out.write(random.nextInt());\n        }\n\n        out.close();\n\n        ChannelInboundHandler ch = new SimpleChannelInboundHandler<Object>() {\n            @Override\n            public void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n            }\n\n            @Override\n            public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n                if (!autoRead) {\n                    ctx.read();\n                }\n            }\n\n            @Override\n            public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n                ctx.close();\n            }\n        };\n        TestHandler sh = new TestHandler(autoRead);\n\n        sb.childHandler(sh);\n        cb.handler(ch);\n\n        Channel sc = sb.bind().sync().channel();\n\n        Channel cc = cb.connect(sc.localAddress()).sync().channel();\n        FileRegion region = new DefaultFileRegion(\n                new RandomAccessFile(file, \"r\").getChannel(), startOffset, data.length - bufferSize);\n        FileRegion emptyRegion = new DefaultFileRegion(new RandomAccessFile(file, \"r\").getChannel(), 0, 0);\n\n        if (!defaultFileRegion) {\n            region = new FileRegionWrapper(region);\n            emptyRegion = new FileRegionWrapper(emptyRegion);\n        }\n        // Do write ByteBuf and then FileRegion to ensure that mixed writes work\n        // Also, write an empty FileRegion to test if writing an empty FileRegion does not cause any issues.\n        //\n        // See https://github.com/netty/netty/issues/2769\n        //     https://github.com/netty/netty/issues/2964\n        if (voidPromise) {\n            assertEquals(cc.voidPromise(), cc.write(Unpooled.wrappedBuffer(data, 0, bufferSize), cc.voidPromise()));\n            assertEquals(cc.voidPromise(), cc.write(emptyRegion, cc.voidPromise()));\n            assertEquals(cc.voidPromise(), cc.writeAndFlush(region, cc.voidPromise()));\n        } else {\n            assertNotEquals(cc.voidPromise(), cc.write(Unpooled.wrappedBuffer(data, 0, bufferSize)));\n            assertNotEquals(cc.voidPromise(), cc.write(emptyRegion));\n            assertNotEquals(cc.voidPromise(), cc.writeAndFlush(region));\n        }\n\n        while (sh.counter < data.length) {\n            if (sh.exception.get() != null) {\n                break;\n            }\n\n            try {\n                Thread.sleep(50);\n            } catch (InterruptedException e) {\n                // Ignore.\n            }\n        }\n\n        sh.channel.close().sync();\n        cc.close().sync();\n        sc.close().sync();\n\n        if (sh.exception.get() != null && !(sh.exception.get() instanceof IOException)) {\n            throw sh.exception.get();\n        }\n\n        if (sh.exception.get() != null) {\n            throw sh.exception.get();\n        }\n\n        // Make sure we did not receive more than we expected.\n        assertThat(sh.counter, is(data.length));\n    }\n\n    private static class TestHandler extends SimpleChannelInboundHandler<ByteBuf> {\n        private final boolean autoRead;\n        volatile Channel channel;\n        final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();\n        volatile int counter;\n\n        TestHandler(boolean autoRead) {\n            this.autoRead = autoRead;\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx)\n                throws Exception {\n            channel = ctx.channel();\n            if (!autoRead) {\n                ctx.read();\n            }\n        }\n\n        @Override\n        public void channelRead0(ChannelHandlerContext ctx, ByteBuf in) throws Exception {\n            byte[] actual = new byte[in.readableBytes()];\n            in.readBytes(actual);\n\n            int lastIdx = counter;\n            for (int i = 0; i < actual.length; i ++) {\n                assertEquals(data[i + lastIdx], actual[i]);\n            }\n            counter += actual.length;\n        }\n\n        @Override\n        public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n            if (!autoRead) {\n                ctx.read();\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx,\n                Throwable cause) throws Exception {\n            if (exception.compareAndSet(null, cause)) {\n                ctx.close();\n            }\n        }\n    }\n\n    private static final class FileRegionWrapper implements FileRegion {\n        private final FileRegion region;\n\n        FileRegionWrapper(FileRegion region) {\n            this.region = region;\n        }\n\n        @Override\n        public int refCnt() {\n            return region.refCnt();\n        }\n\n        @Override\n        public long position() {\n            return region.position();\n        }\n\n        @Override\n        @Deprecated\n        public long transfered() {\n            return region.transferred();\n        }\n\n        @Override\n        public boolean release() {\n            return region.release();\n        }\n\n        @Override\n        public long transferred() {\n            return region.transferred();\n        }\n\n        @Override\n        public long count() {\n            return region.count();\n        }\n\n        @Override\n        public boolean release(int decrement) {\n            return region.release(decrement);\n        }\n\n        @Override\n        public long transferTo(WritableByteChannel target, long position) throws IOException {\n            return region.transferTo(target, position);\n        }\n\n        @Override\n        public FileRegion retain() {\n            region.retain();\n            return this;\n        }\n\n        @Override\n        public FileRegion retain(int increment) {\n            region.retain(increment);\n            return this;\n        }\n\n        @Override\n        public FileRegion touch() {\n            region.touch();\n            return this;\n        }\n\n        @Override\n        public FileRegion touch(Object hint) {\n            region.touch(hint);\n            return this;\n        }\n    }\n}\n", "/*\n * Copyright 2015 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.channel.epoll;\n\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.unix.FileDescriptor;\nimport io.netty.util.NetUtil;\nimport io.netty.util.internal.PlatformDependent;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class EpollSpliceTest {\n\n    private static final int SPLICE_LEN = 32 * 1024;\n    private static final Random random = new Random();\n    private static final byte[] data = new byte[1048576];\n\n    static {\n        random.nextBytes(data);\n    }\n\n    @Test\n    public void spliceToSocket() throws Throwable {\n        final EchoHandler sh = new EchoHandler();\n        final EchoHandler ch = new EchoHandler();\n\n        EventLoopGroup group = new EpollEventLoopGroup(1);\n        ServerBootstrap bs = new ServerBootstrap();\n        bs.channel(EpollServerSocketChannel.class);\n        bs.group(group).childHandler(sh);\n        final Channel sc = bs.bind(NetUtil.LOCALHOST, 0).syncUninterruptibly().channel();\n\n        ServerBootstrap bs2 = new ServerBootstrap();\n        bs2.channel(EpollServerSocketChannel.class);\n        bs2.childOption(EpollChannelOption.EPOLL_MODE, EpollMode.LEVEL_TRIGGERED);\n        bs2.group(group).childHandler(new ChannelInboundHandlerAdapter() {\n            @Override\n            public void channelActive(final ChannelHandlerContext ctx) throws Exception {\n                ctx.channel().config().setAutoRead(false);\n                Bootstrap bs = new Bootstrap();\n                bs.option(EpollChannelOption.EPOLL_MODE, EpollMode.LEVEL_TRIGGERED);\n\n                bs.channel(EpollSocketChannel.class);\n                bs.group(ctx.channel().eventLoop()).handler(new ChannelInboundHandlerAdapter() {\n                    @Override\n                    public void channelActive(ChannelHandlerContext context) throws Exception {\n                        final EpollSocketChannel ch = (EpollSocketChannel) ctx.channel();\n                        final EpollSocketChannel ch2 = (EpollSocketChannel) context.channel();\n                        // We are splicing two channels together, at this point we have a tcp proxy which handles all\n                        // the data transfer only in kernel space!\n\n                        // Integer.MAX_VALUE will splice infinitly.\n                        ch.spliceTo(ch2, Integer.MAX_VALUE).addListener(new ChannelFutureListener() {\n                            @Override\n                            public void operationComplete(ChannelFuture future) throws Exception {\n                                if (!future.isSuccess()) {\n                                    future.channel().close();\n                                }\n                            }\n                        });\n                        // Trigger multiple splices to see if partial splicing works as well.\n                        ch2.spliceTo(ch, SPLICE_LEN).addListener(new ChannelFutureListener() {\n                            @Override\n                            public void operationComplete(ChannelFuture future) throws Exception {\n                                if (!future.isSuccess()) {\n                                    future.channel().close();\n                                } else {\n                                    ch2.spliceTo(ch, SPLICE_LEN).addListener(this);\n                                }\n                            }\n                        });\n                        ctx.channel().config().setAutoRead(true);\n                    }\n\n                    @Override\n                    public void channelInactive(ChannelHandlerContext context) throws Exception {\n                        context.close();\n                    }\n                });\n                bs.connect(sc.localAddress()).addListener(new ChannelFutureListener() {\n                    @Override\n                    public void operationComplete(ChannelFuture future) throws Exception {\n                        if (!future.isSuccess()) {\n                            ctx.close();\n                        } else {\n                            future.channel().closeFuture().addListener(new ChannelFutureListener() {\n                                @Override\n                                public void operationComplete(ChannelFuture future) throws Exception {\n                                    ctx.close();\n                                }\n                            });\n                        }\n                    }\n                });\n            }\n        });\n        Channel pc = bs2.bind(NetUtil.LOCALHOST, 0).syncUninterruptibly().channel();\n\n        Bootstrap cb = new Bootstrap();\n        cb.group(group);\n        cb.channel(EpollSocketChannel.class);\n        cb.handler(ch);\n        Channel cc = cb.connect(pc.localAddress()).syncUninterruptibly().channel();\n\n        for (int i = 0; i < data.length;) {\n            int length = Math.min(random.nextInt(1024 * 64), data.length - i);\n            ByteBuf buf = Unpooled.wrappedBuffer(data, i, length);\n            cc.writeAndFlush(buf);\n            i += length;\n        }\n\n        while (ch.counter < data.length) {\n            if (sh.exception.get() != null) {\n                break;\n            }\n            if (ch.exception.get() != null) {\n                break;\n            }\n\n            try {\n                Thread.sleep(50);\n            } catch (InterruptedException e) {\n                // Ignore.\n            }\n        }\n\n        while (sh.counter < data.length) {\n            if (sh.exception.get() != null) {\n                break;\n            }\n            if (ch.exception.get() != null) {\n                break;\n            }\n\n            try {\n                Thread.sleep(50);\n            } catch (InterruptedException e) {\n                // Ignore.\n            }\n        }\n\n        sh.channel.close().sync();\n        ch.channel.close().sync();\n        sc.close().sync();\n        pc.close().sync();\n        group.shutdownGracefully();\n\n        if (sh.exception.get() != null && !(sh.exception.get() instanceof IOException)) {\n            throw sh.exception.get();\n        }\n        if (ch.exception.get() != null && !(ch.exception.get() instanceof IOException)) {\n            throw ch.exception.get();\n        }\n        if (sh.exception.get() != null) {\n            throw sh.exception.get();\n        }\n        if (ch.exception.get() != null) {\n            throw ch.exception.get();\n        }\n    }\n\n    @Test(timeout = 10000)\n    public void spliceToFile() throws Throwable {\n        EventLoopGroup group = new EpollEventLoopGroup(1);\n        File file = PlatformDependent.createTempFile(\"netty-splice\", null, null);\n        file.deleteOnExit();\n\n        SpliceHandler sh = new SpliceHandler(file);\n        ServerBootstrap bs = new ServerBootstrap();\n        bs.channel(EpollServerSocketChannel.class);\n        bs.group(group).childHandler(sh);\n        bs.childOption(EpollChannelOption.EPOLL_MODE, EpollMode.LEVEL_TRIGGERED);\n        Channel sc = bs.bind(NetUtil.LOCALHOST, 0).syncUninterruptibly().channel();\n\n        Bootstrap cb = new Bootstrap();\n        cb.group(group);\n        cb.channel(EpollSocketChannel.class);\n        cb.handler(new ChannelInboundHandlerAdapter());\n        Channel cc = cb.connect(sc.localAddress()).syncUninterruptibly().channel();\n\n        for (int i = 0; i < data.length;) {\n            int length = Math.min(random.nextInt(1024 * 64), data.length - i);\n            ByteBuf buf = Unpooled.wrappedBuffer(data, i, length);\n            cc.writeAndFlush(buf);\n            i += length;\n        }\n\n        while (sh.future2 == null || !sh.future2.isDone() || !sh.future.isDone()) {\n            if (sh.exception.get() != null) {\n                break;\n            }\n            try {\n                Thread.sleep(50);\n            } catch (InterruptedException e) {\n                // Ignore.\n            }\n        }\n\n        sc.close().sync();\n        cc.close().sync();\n\n        if (sh.exception.get() != null && !(sh.exception.get() instanceof IOException)) {\n            throw sh.exception.get();\n        }\n\n        byte[] written = new byte[data.length];\n        FileInputStream in = new FileInputStream(file);\n\n        try {\n            Assert.assertEquals(written.length, in.read(written));\n            Assert.assertArrayEquals(data, written);\n        } finally {\n            in.close();\n            group.shutdownGracefully();\n        }\n    }\n\n    private static class EchoHandler extends SimpleChannelInboundHandler<ByteBuf> {\n        volatile Channel channel;\n        final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();\n        volatile int counter;\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx)\n                throws Exception {\n            channel = ctx.channel();\n        }\n\n        @Override\n        public void channelRead0(ChannelHandlerContext ctx, ByteBuf in) throws Exception {\n            byte[] actual = new byte[in.readableBytes()];\n            in.readBytes(actual);\n\n            int lastIdx = counter;\n            for (int i = 0; i < actual.length; i ++) {\n                assertEquals(data[i + lastIdx], actual[i]);\n            }\n\n            if (channel.parent() != null) {\n                channel.write(Unpooled.wrappedBuffer(actual));\n            }\n\n            counter += actual.length;\n        }\n\n        @Override\n        public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n            ctx.flush();\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx,\n                                    Throwable cause) throws Exception {\n            if (exception.compareAndSet(null, cause)) {\n                cause.printStackTrace();\n                ctx.close();\n            }\n        }\n    }\n\n    private static class SpliceHandler extends ChannelInboundHandlerAdapter {\n        private final File file;\n\n        volatile ChannelFuture future;\n        volatile ChannelFuture future2;\n        final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();\n\n        SpliceHandler(File file) {\n            this.file = file;\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n            final EpollSocketChannel ch = (EpollSocketChannel) ctx.channel();\n            final FileDescriptor fd = FileDescriptor.from(file);\n\n            // splice two halves separately to test starting offset\n            future = ch.spliceTo(fd, 0, data.length / 2);\n            future2 = ch.spliceTo(fd, data.length / 2, data.length / 2);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx,\n                                    Throwable cause) throws Exception {\n            if (exception.compareAndSet(null, cause)) {\n                cause.printStackTrace();\n                ctx.close();\n            }\n        }\n    }\n}\n", "/*\n * Copyright 2016 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.channel.unix.tests;\n\nimport io.netty.channel.unix.DomainSocketAddress;\nimport io.netty.channel.unix.Socket;\nimport io.netty.util.internal.PlatformDependent;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic final class UnixTestUtils {\n    public static DomainSocketAddress newSocketAddress() {\n        try {\n            File file;\n            do {\n                file = PlatformDependent.createTempFile(\"NETTY\", \"UDS\", null);\n                if (!file.delete()) {\n                    throw new IOException(\"failed to delete: \" + file);\n                }\n            } while (file.getAbsolutePath().length() > 128);\n            return new DomainSocketAddress(file);\n        } catch (IOException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    private UnixTestUtils() { }\n}\n", "/*\n * Copyright 2019 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.channel;\n\nimport io.netty.util.internal.PlatformDependent;\nimport org.junit.Test;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.channels.Channels;\nimport java.nio.channels.WritableByteChannel;\n\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.fail;\n\npublic class DefaultFileRegionTest {\n\n    private static final byte[] data = new byte[1048576 * 10];\n\n    static {\n        PlatformDependent.threadLocalRandom().nextBytes(data);\n    }\n\n    private static File newFile() throws IOException {\n        File file = PlatformDependent.createTempFile(\"netty-\", \".tmp\", null);\n        file.deleteOnExit();\n\n        final FileOutputStream out = new FileOutputStream(file);\n        out.write(data);\n        out.close();\n        return file;\n    }\n\n    @Test\n    public void testCreateFromFile() throws IOException  {\n        File file = newFile();\n        try {\n            testFileRegion(new DefaultFileRegion(file, 0, data.length));\n        } finally {\n            file.delete();\n        }\n    }\n\n    @Test\n    public void testCreateFromFileChannel() throws IOException  {\n        File file = newFile();\n        RandomAccessFile randomAccessFile = new RandomAccessFile(file, \"r\");\n        try {\n            testFileRegion(new DefaultFileRegion(randomAccessFile.getChannel(), 0, data.length));\n        } finally {\n            randomAccessFile.close();\n            file.delete();\n        }\n    }\n\n    private static void testFileRegion(FileRegion region) throws IOException  {\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        WritableByteChannel channel = Channels.newChannel(outputStream);\n\n        try {\n            assertEquals(data.length, region.count());\n            assertEquals(0, region.transferred());\n            assertEquals(data.length, region.transferTo(channel, 0));\n            assertEquals(data.length, region.count());\n            assertEquals(data.length, region.transferred());\n            assertArrayEquals(data, outputStream.toByteArray());\n        } finally {\n            channel.close();\n        }\n    }\n\n    @Test\n    public void testTruncated() throws IOException  {\n        File file = newFile();\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        WritableByteChannel channel = Channels.newChannel(outputStream);\n        RandomAccessFile randomAccessFile = new RandomAccessFile(file, \"rw\");\n\n        try {\n            FileRegion region = new DefaultFileRegion(randomAccessFile.getChannel(), 0, data.length);\n\n            randomAccessFile.getChannel().truncate(data.length - 1024);\n\n            assertEquals(data.length, region.count());\n            assertEquals(0, region.transferred());\n\n            assertEquals(data.length - 1024, region.transferTo(channel, 0));\n            assertEquals(data.length, region.count());\n            assertEquals(data.length - 1024, region.transferred());\n            try {\n                region.transferTo(channel, data.length - 1024);\n                fail();\n            } catch (IOException expected) {\n                // expected\n            }\n        } finally {\n            channel.close();\n\n            randomAccessFile.close();\n            file.delete();\n        }\n    }\n}\n"], "filenames": ["buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java", "buffer/src/test/java/io/netty/buffer/ReadOnlyDirectByteBufferBufTest.java", "codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java", "codec-http/src/test/java/io/netty/handler/codec/http/HttpChunkedInputTest.java", "codec-http/src/test/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpDataTest.java", "codec-http/src/test/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpDataTest.java", "codec-http/src/test/java/io/netty/handler/codec/http/multipart/DiskFileUploadTest.java", "common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java", "common/src/main/java/io/netty/util/internal/PlatformDependent.java", "handler/src/main/java/io/netty/handler/ssl/util/SelfSignedCertificate.java", "handler/src/test/java/io/netty/handler/stream/ChunkedWriteHandlerTest.java", "handler/src/test/java/io/netty/handler/traffic/FileRegionThrottleTest.java", "testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketFileRegionTest.java", "transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSpliceTest.java", "transport-native-unix-common-tests/src/main/java/io/netty/channel/unix/tests/UnixTestUtils.java", "transport/src/test/java/io/netty/channel/DefaultFileRegionTest.java"], "buggy_code_start_loc": [4554, 309, 21, 27, 42, 46, 276, 180, 40, 22, 28, 34, 105, 30, 19, 42], "buggy_code_end_loc": [4598, 310, 94, 50, 43, 74, 277, 181, 1391, 365, 59, 65, 140, 196, 30, 43], "fixing_code_start_loc": [4554, 309, 22, 28, 42, 46, 276, 180, 41, 23, 29, 35, 105, 31, 20, 42], "fixing_code_end_loc": [4598, 310, 95, 51, 43, 74, 277, 181, 1411, 367, 60, 66, 140, 197, 31, 43], "type": "CWE-378", "message": "Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers & clients. In Netty before version 4.1.59.Final there is a vulnerability on Unix-like systems involving an insecure temp file. When netty's multipart decoders are used local information disclosure can occur via the local system temporary directory if temporary storing uploads on the disk is enabled. On unix-like systems, the temporary directory is shared between all user. As such, writing to this directory using APIs that do not explicitly set the file/directory permissions can lead to information disclosure. Of note, this does not impact modern MacOS Operating Systems. The method \"File.createTempFile\" on unix-like systems creates a random file, but, by default will create this file with the permissions \"-rw-r--r--\". Thus, if sensitive information is written to this file, other local users can read this information. This is the case in netty's \"AbstractDiskHttpData\" is vulnerable. This has been fixed in version 4.1.59.Final. As a workaround, one may specify your own \"java.io.tmpdir\" when you start the JVM or use \"DefaultHttpDataFactory.setBaseDir(...)\" to set the directory to something that is only readable by the current user.", "other": {"cve": {"id": "CVE-2021-21290", "sourceIdentifier": "security-advisories@github.com", "published": "2021-02-08T20:15:12.433", "lastModified": "2022-05-12T14:33:36.633", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers & clients. In Netty before version 4.1.59.Final there is a vulnerability on Unix-like systems involving an insecure temp file. When netty's multipart decoders are used local information disclosure can occur via the local system temporary directory if temporary storing uploads on the disk is enabled. On unix-like systems, the temporary directory is shared between all user. As such, writing to this directory using APIs that do not explicitly set the file/directory permissions can lead to information disclosure. Of note, this does not impact modern MacOS Operating Systems. The method \"File.createTempFile\" on unix-like systems creates a random file, but, by default will create this file with the permissions \"-rw-r--r--\". Thus, if sensitive information is written to this file, other local users can read this information. This is the case in netty's \"AbstractDiskHttpData\" is vulnerable. This has been fixed in version 4.1.59.Final. As a workaround, one may specify your own \"java.io.tmpdir\" when you start the JVM or use \"DefaultHttpDataFactory.setBaseDir(...)\" to set the directory to something that is only readable by the current user."}, {"lang": "es", "value": "Netty es un framework de aplicaci\u00f3n de red de c\u00f3digo abierto y as\u00edncrono controlado por eventos para el desarrollo r\u00e1pido de servidores y clientes de protocolo de alto rendimiento mantenibles.&#xa0;En Netty anterior a la versi\u00f3n 4.1.59.Final, se presenta una vulnerabilidad en sistemas similares a Unix que involucra un archivo temporal no seguro.&#xa0;Cuando se usan los decodificadores multiparte de netty, la divulgaci\u00f3n de informaci\u00f3n local puede ocurrir por medio del directorio temporal del sistema local si el almacenamiento temporal de cargas en el disco est\u00e1 habilitado.&#xa0;En sistemas tipo Unix, el directorio temporal se comparte entre todos los usuarios.&#xa0;Tal y como, escribir en este directorio utilizando las API que no establezcan expl\u00edcitamente los permisos de archivo/directorio puede conducir a una divulgaci\u00f3n de informaci\u00f3n.&#xa0;Cabe se\u00f1alar que esto no afecta a los sistemas operativos MacOS modernos.&#xa0;El m\u00e9todo \"File.createTempFile\" en sistemas similares a Unix crea un archivo aleatorio, pero,&#xa0;por defecto crear\u00e1 este archivo con los permisos \"-rw-r - r--\".&#xa0;Por lo tanto, si se escribe informaci\u00f3n confidencial en este archivo, otros usuarios locales pueden leer esta informaci\u00f3n.&#xa0;Este es el caso en el que \"AbstractDiskHttpData\" de netty es vulnerable.&#xa0;Esto ha sido corregido en la versi\u00f3n 4.1.59.Final.&#xa0;Como soluci\u00f3n alternativa, se puede especificar su propio \"java.io.tmpdir\" al iniciar la JVM o utilizar \"DefaultHttpDataFactory.setBaseDir(...)\" para establecer el directorio en algo que solo el usuario actual pueda leer"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.2, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 1.9}, "baseSeverity": "LOW", "exploitabilityScore": 3.4, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-378"}, {"lang": "en", "value": "CWE-379"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-668"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netty:netty:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.1.59", "matchCriteriaId": "5E687331-EF1E-42A3-8CCD-8F231E48F79C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:quarkus:quarkus:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.13.7", "matchCriteriaId": "64839EBF-078E-492A-897C-9AFFB7678ED8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_corporate_lending_process_management:14.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "0CF9A061-2421-426D-9854-0A4E55B2961D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_corporate_lending_process_management:14.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "F95EDC3D-54BB-48F9-82F2-7CCF335FCA78"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_corporate_lending_process_management:14.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "B72B735F-4E52-484A-9C2C-23E6E2070385"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_credit_facilities_process_management:14.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "8B36A1D4-F391-4EE3-9A65-0A10568795BA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_credit_facilities_process_management:14.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "55116032-AAD1-4FEA-9DA8-2C4CBD3D3F61"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_credit_facilities_process_management:14.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "0275F820-40BE-47B8-B167-815A55DF578E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_trade_finance_process_management:14.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "9E14324D-B9EE-4C06-ACC7-255189ED6300"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_trade_finance_process_management:14.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "CBEBB60F-6EAB-4AE5-B777-5044C657FBA8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_trade_finance_process_management:14.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "B185C1EA-71E6-4972-8637-08A33CC00841"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_brm_-_elastic_charging_engine:12.0.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "06594847-96ED-4541-B2F4-C7331B603603"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_design_studio:7.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "A67AA54B-258D-4D09-9ACB-4085E0B3E585"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_messaging_server:8.1:*:*:*:*:*:*:*", "matchCriteriaId": "E1214FDF-357A-4BB9-BADE-50FB2BD16D10"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:nosql_database:*:*:*:*:*:*:*:*", "versionEndExcluding": "20.3", "matchCriteriaId": "D04565AE-D092-4AE0-8FEE-0E8114662A1B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:linux:*:*", "matchCriteriaId": "F3E0B672-3E06-4422-B2A4-0BD073AEC2A1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:windows:*:*", "matchCriteriaId": "B55E8D50-99B4-47EC-86F9-699B67D473CE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:cloud_secure_agent:-:*:*:*:*:*:*:*", "matchCriteriaId": "F0F202E8-97E6-4BBB-A0B6-4CA3F5803C08"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:snapcenter:-:*:*:*:*:*:*:*", "matchCriteriaId": "BDFB1169-41A0-4A86-8E4F-FDA9730B1E94"}]}]}], "references": [{"url": "https://github.com/netty/netty/commit/c735357bf29d07856ad171c6611a2e1a0e0000ec", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/netty/netty/security/advisories/GHSA-5mcr-gq6c-3hq2", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r0053443ce19ff125981559f8c51cf66e3ab4350f47812b8cf0733a05@%3Cdev.kafka.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r02e467123d45006a1dda20a38349e9c74c3a4b53e2e07be0939ecb3f@%3Cdev.ranger.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r0857b613604c696bf9743f0af047360baaded48b1c75cf6945a083c5@%3Cjira.kafka.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r10308b625e49d4e9491d7e079606ca0df2f0a4d828f1ad1da64ba47b@%3Cjira.kafka.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r1908a34b9cc7120e5c19968a116ddbcffea5e9deb76c2be4fa461904@%3Cdev.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r2748097ea4b774292539cf3de6e3b267fc7a88d6c8ec40f4e2e87bd4@%3Cdev.kafka.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r2936730ef0a06e724b96539bc7eacfcd3628987c16b1b99c790e7b87@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r2fda4dab73097051977f2ab818f75e04fbcb15bb1003c8530eac1059@%3Cjira.kafka.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r326ec431f06eab7cb7113a7a338e59731b8d556d05258457f12bac1b@%3Cdev.kafka.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r4efed2c501681cb2e8d629da16e48d9eac429624fd4c9a8c6b8e7020@%3Cdev.tinkerpop.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r584cf871f188c406d8bd447ff4e2fd9817fca862436c064d0951a071@%3Ccommits.pulsar.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r59bac5c09f7a4179b9e2460e8f41c278aaf3b9a21cc23678eb893e41@%3Cjira.kafka.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r5bf303d7c04da78f276765da08559fdc62420f1df539b277ca31f63b@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r5c701840aa2845191721e39821445e1e8c59711e71942b7796a6ec29@%3Cusers.activemq.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r5e4a540089760c8ecc2c411309d74264f1dad634ad93ad583ca16214@%3Ccommits.kafka.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r5e66e286afb5506cdfe9bbf68a323e8d09614f6d1ddc806ed0224700@%3Cjira.kafka.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r71dbb66747ff537640bb91eb0b2b24edef21ac07728097016f58b01f@%3Ccommits.kafka.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r743149dcc8db1de473e6bff0b3ddf10140a7357bc2add75f7d1fbb12@%3Cdev.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r790c2926efcd062067eb18fde2486527596d7275381cfaff2f7b3890@%3Cissues.bookkeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r7bb3cdc192e9a6f863d3ea05422f09fa1ae2b88d4663e63696ee7ef5@%3Cdev.ranger.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r9924ef9357537722b28d04c98a189750b80694a19754e5057c34ca48@%3Ccommits.pulsar.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/ra0fc2b4553dd7aaf75febb61052b7f1243ac3a180a71c01f29093013@%3Cjira.kafka.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/ra503756ced78fdc2136bd33e87cb7553028645b261b1f5c6186a121e@%3Cjira.kafka.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rb06c1e766aa45ee422e8261a8249b561784186483e8f742ea627bda4@%3Cdev.kafka.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rb51d6202ff1a773f96eaa694b7da4ad3f44922c40b3d4e1a19c2f325@%3Ccommits.pulsar.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rb592033a2462548d061a83ac9449c5ff66098751748fcd1e2d008233@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rc0087125cb15b4b78e44000f841cd37fefedfda942fd7ddf3ad1b528@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rc488f80094872ad925f0c73d283d4c00d32def81977438e27a3dc2bb@%3Cjira.kafka.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rcd163e421273e8dca1c71ea298dce3dd11b41d51c3a812e0394e6a5d@%3Ccommits.pulsar.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rdba4f78ac55f803893a1a2265181595e79e3aa027e2e651dfba98c18@%3Cjira.kafka.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/02/msg00016.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20220210-0011/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2021/dsa-4885", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com//security-alerts/cpujul2021.html", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuApr2021.html", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2022.html", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuoct2021.html", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/netty/netty/commit/c735357bf29d07856ad171c6611a2e1a0e0000ec"}}