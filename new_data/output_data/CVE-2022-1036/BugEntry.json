{"buggy_code": ["<?php\n\nnamespace MicroweberPackages\\User\\Http\\Controllers;\n\nuse Carbon\\Carbon;\nuse Illuminate\\Auth\\Events\\PasswordReset;\nuse Illuminate\\Routing\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Hash;\nuse Illuminate\\Support\\Facades\\Password;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Str;\nuse MicroweberPackages\\User\\Models\\User;\nuse Auth;\n\n\nclass UserForgotPasswordController extends Controller\n{\n    /**\n     * Create a new controller instance.\n     * @return void\n     */\n    public function __construct()\n    {\n        event_trigger('mw.init');\n    }\n    public function showForgotForm()\n    {\n        return app()->parser->process(view('user::auth.forgot-password'));\n    }\n\n    public function send(Request $request)\n    {\n        $rules = [];\n        if (get_option('captcha_disabled', 'users') !== 'y') {\n            $rules['captcha'] = 'captcha';\n        }\n        $inputs = $request->only(['captcha','email']);\n        if (is_admin()) {\n            unset($rules['captcha']);\n        }\n        $user_id = false;\n\n        if (!$user_id and isset($inputs['email']) and $inputs['email'] != '') {\n            $email_user = User::where('email',$inputs['email'])->first();\n            if($email_user){\n                $user_id = $email_user->id;\n            }\n\n        }\n\n         $rules['email'] = 'required|email';\n\n        $request->validate($rules);\n\n        if(!$user_id){\n            return response()->json(['error'=>true,'message' => __('passwords.user')], 422);\n        }\n\n        $user = User::where('id',$user_id)->first();\n\n//        $status = Password::sendResetLink(\n//            $request->only('email')\n//        );\n\n\n        // from https://laracasts.com/discuss/channels/laravel/reset-password-token-in-email-link-does-not-match-in-database-table?page=1&replyId=732755\n        $status = Password::sendResetLink(\n            $request->only('email'),\n            function ($user, $token) {\n                (\\DB::table('password_resets')\n                    ->updateOrInsert(\n                        ['email' => $user->email],\n                        [\n                            'token' => md5($token)\n                        ]\n                    ))\n                    ? $user->sendPasswordResetNotification(md5($token))\n                    : null;\n            }\n\n        );\n\n        if ($request->expectsJson()) {\n            if ($status === Password::RESET_LINK_SENT) {\n                return response()->json(['message' => __($status)], 200);\n            } else {\n                return response()->json(['message' => __($status)], 422);\n            }\n        }\n\n        return $status === Password::RESET_LINK_SENT\n            ? back()->with(['status' => __($status)])\n            : back()->withErrors(['email' => __($status)]);\n    }\n\n    public function showResetForm(Request $request)\n    {\n        $expiredText = \"Password reset link is expired\";\n\n        $check = DB::table('password_resets')\n            ->where('email', '=', $request->email)\n            ->first();\n        if (!$check) {\n            return abort(response($expiredText, 401));\n        }\n\n        $abort = false;\n\n        $createdAt = Carbon::parse($check->created_at);\n        $now = Carbon::now();\n\n        $diffInHours = $createdAt->diffInHours($now);\n\n\n        if (!$check) {\n            $abort = true;\n        }\n\n        if ($check) {\n            if ($diffInHours > 1) {\n                $abort = true;\n            }\n        }\n\n        if($abort){\n               DB::table('password_resets')\n                ->where('email', '=', $request->email)\n                ->delete();\n\n            return abort(response($expiredText, 401));\n        }\n\n        return view('user::auth.reset-password', [\n            'email' => $request->email,\n            'token' => $request->token,\n        ]);\n    }\n\n    public function update(Request $request)\n    {\n        $request->validate([\n            'token' => 'required',\n            'email' => 'required|email',\n            'password' => 'required|min:1|confirmed',\n        ]);\n\n        $tokenMd5 = \\MicroweberPackages\\User\\Models\\PasswordReset::where('email', $request->get('email'))\n            //->where(\\DB::raw('md5(token)'), $request->get('token'))\n            ->where('token', $request->get('token'))\n            ->first();\n\n\n        if (!empty($tokenMd5)) {\n\n            $createdAt = Carbon::parse($tokenMd5->created_at);\n            $diffInHours = $createdAt->diffInHours(Carbon::now());\n            if ($diffInHours > 1) {\n                DB::table('password_resets')\n                    ->where('email', '=', $request->get('email'))\n                    ->delete();\n                return abort(response(\"Password reset link is expired\", 401));\n            }\n\n            $user = User::where('email', $request->get('email'))->first();\n            if ($user != null) {\n\n               tap($user->forceFill([\n                    'password' => Hash::make($request->get('password')),\n                ]))->save();\n\n               //Auth::logoutOtherDevices($request->get('password'));\n\n                event(new PasswordReset($request->get('email')));\n\n                Auth::loginUsingId($user->id);\n                $user->setRememberToken(Str::random(60));\n\n                \\MicroweberPackages\\User\\Models\\PasswordReset::where('email', $tokenMd5->email)->where('token', $tokenMd5->token)->delete();\n\n                Session::flash('status', __('Password has been reset'));\n\n                if ($request->expectsJson()) {\n                    return response()->json(['message' => __('Password has been reset')], 200);\n                }\n\n                if ($user->is_admin) {\n                    return redirect(admin_url());\n                } else {\n                    return redirect(site_url());\n                }\n            }\n\n        } else {\n\n            Session::flash('status', __('Expired or token is invalid'));\n\n            if ($request->expectsJson()) {\n                return response()->json(['message' => __('Expired or token is invalid')], 422);\n            }\n        }\n\n        return back();\n    }\n}\n", "<?php\nnamespace MicroweberPackages\\User\\Http\\Requests;\n\nuse Illuminate\\Foundation\\Http\\FormRequest;\n\nuse Illuminate\\Auth\\Access\\AuthorizationException;\nuse Illuminate\\Contracts\\Container\\Container;\nuse Illuminate\\Contracts\\Validation\\Factory as ValidationFactory;\nuse Illuminate\\Contracts\\Validation\\ValidatesWhenResolved;\nuse Illuminate\\Contracts\\Validation\\Validator;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Routing\\Redirector;\nuse Illuminate\\Validation\\ValidatesWhenResolvedTrait;\nuse Illuminate\\Validation\\ValidationException;\nuse Auth;\n\nclass RegisterRequest extends FormRequest\n{\n\n    /**\n     * @return bool\n     */\n    public function authorize()\n    {\n        $enable_user_gesitration = get_option('enable_user_registration', 'users');\n        if ($enable_user_gesitration === 'n') {\n            return false;\n        }\n        if(user_id()){\n            //user is logged in so we will not allow him to register\n            return false;\n        }\n        return true;\n    }\n\n\n    public function rules()\n    {\n        $rules = [];\n        $inputs = $this->all();\n\n        $validateEmail = false;\n        $validateUsername = false;\n\n\n\n        if (!isset($inputs['username']) || !isset($inputs['email'])) {\n            $validateUsername = true;\n        }\n\n        if (isset($inputs['email']) && !isset($inputs['username'])) {\n            $validateUsername = false;\n            $validateEmail = true;\n        }\n\n        if (isset($inputs['email']) && isset($inputs['username'])) {\n            $validateUsername = true;\n            $validateEmail = true;\n        }\n\n        if ($validateEmail) {\n            $rules['email'] = 'email|string|min:3|required|string|max:255|unique:users';\n        }\n\n        if ($validateUsername) {\n            $rules['username'] = 'alpha_dash|string|min:1|required|string|max:255|unique:users';\n        }\n        if (isset($inputs['confirm_password'])) {\n            $rules['confirm_password'] = 'required|min:1|same:password';\n        }\n\n        if (get_option('captcha_disabled', 'users') !== 'y') {\n            $rules['captcha'] = 'captcha';\n        }\n\n        if (isset($inputs['email']) && $inputs['email'] != false && ((get_option('disable_registration_with_temporary_email', 'users') == 'y'))) {\n            $rules['email'] = $rules['email'] . '|temporary_email_check';\n        }\n\n        if (get_option('require_terms', 'users') == 'y') {\n            $rules['terms'] = 'terms:terms_user';\n            if (isset($inputs['newsletter_subscribe']) and $inputs['newsletter_subscribe']) {\n                $rules['terms'] = $rules['terms'] . ', terms_newsletter';\n            }\n        }\n        $rules['password'] = 'required|min:1';\n\n\n        return $rules;\n    }\n}\n", "<?php\nnamespace MicroweberPackages\\User\\Http\\Requests;\n\nuse Illuminate\\Foundation\\Http\\FormRequest;\n\nclass UserCreateRequest extends FormRequest\n{\n\n    /**\n     * Get the validation rules that apply to the request.s\n     *\n     * @return array\n     */\n    public function rules()\n    {\n        $rules = [\n             'first_name'=>'max:500',\n             'last_name'=>'max:500',\n             'phone'=>'max:500',\n             'username' => 'required|unique:users,username|max:500',\n             'email' => 'unique:users,email|max:500',\n        ];\n\n        return $rules;\n    }\n}\n", "<?php\n\nnamespace MicroweberPackages\\User\\Http\\Requests;\n\nuse Illuminate\\Foundation\\Http\\FormRequest;\nuse Illuminate\\Validation\\Rule;\n\nclass UserUpdateRequest extends FormRequest\n{\n\n    /**\n     * Get the validation rules that apply to the request.s\n     *\n     * @return array\n     */\n    public function rules()\n    {\n\n        $ignore = Rule::unique('users')->ignore($this->id ?? 0, 'id');\n\n        return [\n            'first_name'=>'max:500',\n            'last_name'=>'max:500',\n            'phone'=>'max:500',\n            'email' => [\n                $ignore,\n                'max:500'\n            ],\n            'username' => [\n                $ignore,\n                'max:500'\n            ],\n        ];\n\n    }\n}\n"], "fixing_code": ["<?php\n\nnamespace MicroweberPackages\\User\\Http\\Controllers;\n\nuse Carbon\\Carbon;\nuse Illuminate\\Auth\\Events\\PasswordReset;\nuse Illuminate\\Routing\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Hash;\nuse Illuminate\\Support\\Facades\\Password;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Str;\nuse MicroweberPackages\\User\\Models\\User;\nuse Auth;\n\n\nclass UserForgotPasswordController extends Controller\n{\n    /**\n     * Create a new controller instance.\n     * @return void\n     */\n    public function __construct()\n    {\n        event_trigger('mw.init');\n    }\n    public function showForgotForm()\n    {\n        return app()->parser->process(view('user::auth.forgot-password'));\n    }\n\n    public function send(Request $request)\n    {\n        $rules = [];\n        if (get_option('captcha_disabled', 'users') !== 'y') {\n            $rules['captcha'] = 'captcha';\n        }\n        $inputs = $request->only(['captcha','email']);\n        if (is_admin()) {\n            unset($rules['captcha']);\n        }\n        $user_id = false;\n\n        if (!$user_id and isset($inputs['email']) and $inputs['email'] != '') {\n            $email_user = User::where('email',$inputs['email'])->first();\n            if($email_user){\n                $user_id = $email_user->id;\n            }\n\n        }\n\n         $rules['email'] = 'required|email';\n\n        $request->validate($rules);\n\n        if(!$user_id){\n            return response()->json(['error'=>true,'message' => __('passwords.user')], 422);\n        }\n\n        $user = User::where('id',$user_id)->first();\n\n//        $status = Password::sendResetLink(\n//            $request->only('email')\n//        );\n\n\n        // from https://laracasts.com/discuss/channels/laravel/reset-password-token-in-email-link-does-not-match-in-database-table?page=1&replyId=732755\n        $status = Password::sendResetLink(\n            $request->only('email'),\n            function ($user, $token) {\n                (\\DB::table('password_resets')\n                    ->updateOrInsert(\n                        ['email' => $user->email],\n                        [\n                            'token' => md5($token)\n                        ]\n                    ))\n                    ? $user->sendPasswordResetNotification(md5($token))\n                    : null;\n            }\n\n        );\n\n        if ($request->expectsJson()) {\n            if ($status === Password::RESET_LINK_SENT) {\n                return response()->json(['message' => __($status)], 200);\n            } else {\n                return response()->json(['message' => __($status)], 422);\n            }\n        }\n\n        return $status === Password::RESET_LINK_SENT\n            ? back()->with(['status' => __($status)])\n            : back()->withErrors(['email' => __($status)]);\n    }\n\n    public function showResetForm(Request $request)\n    {\n        $expiredText = \"Password reset link is expired\";\n\n        $check = DB::table('password_resets')\n            ->where('email', '=', $request->email)\n            ->first();\n        if (!$check) {\n            return abort(response($expiredText, 401));\n        }\n\n        $abort = false;\n\n        $createdAt = Carbon::parse($check->created_at);\n        $now = Carbon::now();\n\n        $diffInHours = $createdAt->diffInHours($now);\n\n\n        if (!$check) {\n            $abort = true;\n        }\n\n        if ($check) {\n            if ($diffInHours > 1) {\n                $abort = true;\n            }\n        }\n\n        if($abort){\n               DB::table('password_resets')\n                ->where('email', '=', $request->email)\n                ->delete();\n\n            return abort(response($expiredText, 401));\n        }\n\n        return view('user::auth.reset-password', [\n            'email' => $request->email,\n            'token' => $request->token,\n        ]);\n    }\n\n    public function update(Request $request)\n    {\n        $request->validate([\n            'token' => 'required',\n            'email' => 'required|email',\n            'password' => 'required|min:1|confirmed|max:500',\n        ]);\n\n        $tokenMd5 = \\MicroweberPackages\\User\\Models\\PasswordReset::where('email', $request->get('email'))\n            //->where(\\DB::raw('md5(token)'), $request->get('token'))\n            ->where('token', $request->get('token'))\n            ->first();\n\n\n        if (!empty($tokenMd5)) {\n\n            $createdAt = Carbon::parse($tokenMd5->created_at);\n            $diffInHours = $createdAt->diffInHours(Carbon::now());\n            if ($diffInHours > 1) {\n                DB::table('password_resets')\n                    ->where('email', '=', $request->get('email'))\n                    ->delete();\n                return abort(response(\"Password reset link is expired\", 401));\n            }\n\n            $user = User::where('email', $request->get('email'))->first();\n            if ($user != null) {\n\n               tap($user->forceFill([\n                    'password' => Hash::make($request->get('password')),\n                ]))->save();\n\n               //Auth::logoutOtherDevices($request->get('password'));\n\n                event(new PasswordReset($request->get('email')));\n\n                Auth::loginUsingId($user->id);\n                $user->setRememberToken(Str::random(60));\n\n                \\MicroweberPackages\\User\\Models\\PasswordReset::where('email', $tokenMd5->email)->where('token', $tokenMd5->token)->delete();\n\n                Session::flash('status', __('Password has been reset'));\n\n                if ($request->expectsJson()) {\n                    return response()->json(['message' => __('Password has been reset')], 200);\n                }\n\n                if ($user->is_admin) {\n                    return redirect(admin_url());\n                } else {\n                    return redirect(site_url());\n                }\n            }\n\n        } else {\n\n            Session::flash('status', __('Expired or token is invalid'));\n\n            if ($request->expectsJson()) {\n                return response()->json(['message' => __('Expired or token is invalid')], 422);\n            }\n        }\n\n        return back();\n    }\n}\n", "<?php\nnamespace MicroweberPackages\\User\\Http\\Requests;\n\nuse Illuminate\\Foundation\\Http\\FormRequest;\n\nuse Illuminate\\Auth\\Access\\AuthorizationException;\nuse Illuminate\\Contracts\\Container\\Container;\nuse Illuminate\\Contracts\\Validation\\Factory as ValidationFactory;\nuse Illuminate\\Contracts\\Validation\\ValidatesWhenResolved;\nuse Illuminate\\Contracts\\Validation\\Validator;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Routing\\Redirector;\nuse Illuminate\\Validation\\ValidatesWhenResolvedTrait;\nuse Illuminate\\Validation\\ValidationException;\nuse Auth;\n\nclass RegisterRequest extends FormRequest\n{\n\n    /**\n     * @return bool\n     */\n    public function authorize()\n    {\n        $enable_user_gesitration = get_option('enable_user_registration', 'users');\n        if ($enable_user_gesitration === 'n') {\n            return false;\n        }\n        if(user_id()){\n            //user is logged in so we will not allow him to register\n            return false;\n        }\n        return true;\n    }\n\n\n    public function rules()\n    {\n        $rules = [];\n        $inputs = $this->all();\n\n        $validateEmail = false;\n        $validateUsername = false;\n\n\n\n        if (!isset($inputs['username']) || !isset($inputs['email'])) {\n            $validateUsername = true;\n        }\n\n        if (isset($inputs['email']) && !isset($inputs['username'])) {\n            $validateUsername = false;\n            $validateEmail = true;\n        }\n\n        if (isset($inputs['email']) && isset($inputs['username'])) {\n            $validateUsername = true;\n            $validateEmail = true;\n        }\n\n        if ($validateEmail) {\n            $rules['email'] = 'email|string|min:3|required|string|max:255|unique:users';\n        }\n\n        if ($validateUsername) {\n            $rules['username'] = 'alpha_dash|string|min:1|required|string|max:255|unique:users';\n        }\n        if (isset($inputs['confirm_password'])) {\n            $rules['confirm_password'] = 'required|min:1|same:password';\n        }\n\n        if (get_option('captcha_disabled', 'users') !== 'y') {\n            $rules['captcha'] = 'captcha';\n        }\n\n        if (isset($inputs['email']) && $inputs['email'] != false && ((get_option('disable_registration_with_temporary_email', 'users') == 'y'))) {\n            $rules['email'] = $rules['email'] . '|temporary_email_check';\n        }\n\n        if (get_option('require_terms', 'users') == 'y') {\n            $rules['terms'] = 'terms:terms_user';\n            if (isset($inputs['newsletter_subscribe']) and $inputs['newsletter_subscribe']) {\n                $rules['terms'] = $rules['terms'] . ', terms_newsletter';\n            }\n        }\n        $rules['password'] = 'required|min:1|max:500';\n\n\n        return $rules;\n    }\n}\n", "<?php\nnamespace MicroweberPackages\\User\\Http\\Requests;\n\nuse Illuminate\\Foundation\\Http\\FormRequest;\n\nclass UserCreateRequest extends FormRequest\n{\n\n    /**\n     * Get the validation rules that apply to the request.s\n     *\n     * @return array\n     */\n    public function rules()\n    {\n        $rules = [\n             'password'=>'max:500',\n             'first_name'=>'max:500',\n             'last_name'=>'max:500',\n             'phone'=>'max:500',\n             'username' => 'required|unique:users,username|max:500',\n             'email' => 'unique:users,email|max:500',\n        ];\n\n        return $rules;\n    }\n}\n", "<?php\n\nnamespace MicroweberPackages\\User\\Http\\Requests;\n\nuse Illuminate\\Foundation\\Http\\FormRequest;\nuse Illuminate\\Validation\\Rule;\n\nclass UserUpdateRequest extends FormRequest\n{\n\n    /**\n     * Get the validation rules that apply to the request.s\n     *\n     * @return array\n     */\n    public function rules()\n    {\n\n        $ignore = Rule::unique('users')->ignore($this->id ?? 0, 'id');\n\n        return [\n            'password'=>'max:500',\n            'first_name'=>'max:500',\n            'last_name'=>'max:500',\n            'phone'=>'max:500',\n            'email' => [\n                $ignore,\n                'max:500'\n            ],\n            'username' => [\n                $ignore,\n                'max:500'\n            ],\n        ];\n\n    }\n}\n"], "filenames": ["src/MicroweberPackages/User/Http/Controllers/UserForgotPasswordController.php", "src/MicroweberPackages/User/Http/Requests/RegisterRequest.php", "src/MicroweberPackages/User/Http/Requests/UserCreateRequest.php", "src/MicroweberPackages/User/Http/Requests/UserUpdateRequest.php"], "buggy_code_start_loc": [146, 86, 16, 21], "buggy_code_end_loc": [147, 87, 16, 21], "fixing_code_start_loc": [146, 86, 17, 22], "fixing_code_end_loc": [147, 87, 18, 23], "type": "CWE-190", "message": "Able to create an account with long password leads to memory corruption / Integer Overflow in GitHub repository microweber/microweber prior to 1.2.12.", "other": {"cve": {"id": "CVE-2022-1036", "sourceIdentifier": "security@huntr.dev", "published": "2022-03-22T13:15:08.147", "lastModified": "2022-03-28T21:01:38.983", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Able to create an account with long password leads to memory corruption / Integer Overflow in GitHub repository microweber/microweber prior to 1.2.12."}, {"lang": "es", "value": "La posibilidad de crear una cuenta con una contrase\u00f1a larga conlleva una corrupci\u00f3n de memoria / Desbordamiento de B\u00fafer, en el repositorio GitHub microweber/microweber versiones anteriores a 1.2.12"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:H/UI:R/S:U/C:L/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.5, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:microweber:microweber:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.12", "matchCriteriaId": "D2D0BDAC-476F-4A5C-98AE-71B23E086168"}]}]}], "references": [{"url": "https://github.com/microweber/microweber/commit/82be4f0b4729be870ccefdae99a04833f134aa6a", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/db615581-d5a9-4ca5-a3e9-7a39eceaa424", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/microweber/microweber/commit/82be4f0b4729be870ccefdae99a04833f134aa6a"}}