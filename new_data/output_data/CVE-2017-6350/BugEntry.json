{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * undo.c: multi level undo facility\n *\n * The saved lines are stored in a list of lists (one for each buffer):\n *\n * b_u_oldhead------------------------------------------------+\n *\t\t\t\t\t\t\t      |\n *\t\t\t\t\t\t\t      V\n *\t\t  +--------------+    +--------------+\t  +--------------+\n * b_u_newhead--->| u_header\t |    | u_header     |\t  | u_header\t |\n *\t\t  |\tuh_next------>|     uh_next------>|\tuh_next---->NULL\n *\t   NULL<--------uh_prev  |<---------uh_prev  |<---------uh_prev  |\n *\t\t  |\tuh_entry |    |     uh_entry |\t  |\tuh_entry |\n *\t\t  +--------|-----+    +--------|-----+\t  +--------|-----+\n *\t\t\t   |\t\t       |\t\t   |\n *\t\t\t   V\t\t       V\t\t   V\n *\t\t  +--------------+    +--------------+\t  +--------------+\n *\t\t  | u_entry\t |    | u_entry      |\t  | u_entry\t |\n *\t\t  |\tue_next  |    |     ue_next  |\t  |\tue_next  |\n *\t\t  +--------|-----+    +--------|-----+\t  +--------|-----+\n *\t\t\t   |\t\t       |\t\t   |\n *\t\t\t   V\t\t       V\t\t   V\n *\t\t  +--------------+\t      NULL\t\t  NULL\n *\t\t  | u_entry\t |\n *\t\t  |\tue_next  |\n *\t\t  +--------|-----+\n *\t\t\t   |\n *\t\t\t   V\n *\t\t\t  etc.\n *\n * Each u_entry list contains the information for one undo or redo.\n * curbuf->b_u_curhead points to the header of the last undo (the next redo),\n * or is NULL if nothing has been undone (end of the branch).\n *\n * For keeping alternate undo/redo branches the uh_alt field is used.  Thus at\n * each point in the list a branch may appear for an alternate to redo.  The\n * uh_seq field is numbered sequentially to be able to find a newer or older\n * branch.\n *\n *\t\t   +---------------+\t+---------------+\n * b_u_oldhead --->| u_header\t   |\t| u_header\t|\n *\t\t   |   uh_alt_next ---->|   uh_alt_next ----> NULL\n *\t   NULL <----- uh_alt_prev |<------ uh_alt_prev |\n *\t\t   |   uh_prev\t   |\t|   uh_prev\t|\n *\t\t   +-----|---------+\t+-----|---------+\n *\t\t\t |\t\t      |\n *\t\t\t V\t\t      V\n *\t\t   +---------------+\t+---------------+\n *\t\t   | u_header\t   |\t| u_header\t|\n *\t\t   |   uh_alt_next |\t|   uh_alt_next |\n * b_u_newhead --->|   uh_alt_prev |\t|   uh_alt_prev |\n *\t\t   |   uh_prev\t   |\t|   uh_prev\t|\n *\t\t   +-----|---------+\t+-----|---------+\n *\t\t\t |\t\t      |\n *\t\t\t V\t\t      V\n *\t\t       NULL\t\t+---------------+    +---------------+\n *\t\t\t\t\t| u_header\t|    | u_header      |\n *\t\t\t\t\t|   uh_alt_next ---->|\t uh_alt_next |\n *\t\t\t\t\t|   uh_alt_prev |<------ uh_alt_prev |\n *\t\t\t\t\t|   uh_prev\t|    |\t uh_prev     |\n *\t\t\t\t\t+-----|---------+    +-----|---------+\n *\t\t\t\t\t      |\t\t\t   |\n *\t\t\t\t\t     etc.\t\t  etc.\n *\n *\n * All data is allocated and will all be freed when the buffer is unloaded.\n */\n\n/* Uncomment the next line for including the u_check() function.  This warns\n * for errors in the debug information. */\n/* #define U_DEBUG 1 */\n#define UH_MAGIC 0x18dade\t/* value for uh_magic when in use */\n#define UE_MAGIC 0xabc123\t/* value for ue_magic when in use */\n\n/* Size of buffer used for encryption. */\n#define CRYPT_BUF_SIZE 8192\n\n#include \"vim.h\"\n\n/* Structure passed around between functions.\n * Avoids passing cryptstate_T when encryption not available. */\ntypedef struct {\n    buf_T\t*bi_buf;\n    FILE\t*bi_fp;\n#ifdef FEAT_CRYPT\n    cryptstate_T *bi_state;\n    char_u\t*bi_buffer; /* CRYPT_BUF_SIZE, NULL when not buffering */\n    size_t\tbi_used;    /* bytes written to/read from bi_buffer */\n    size_t\tbi_avail;   /* bytes available in bi_buffer */\n#endif\n} bufinfo_T;\n\n\nstatic long get_undolevel(void);\nstatic void u_unch_branch(u_header_T *uhp);\nstatic u_entry_T *u_get_headentry(void);\nstatic void u_getbot(void);\nstatic void u_doit(int count);\nstatic void u_undoredo(int undo);\nstatic void u_undo_end(int did_undo, int absolute);\nstatic void u_add_time(char_u *buf, size_t buflen, time_t tt);\nstatic void u_freeheader(buf_T *buf, u_header_T *uhp, u_header_T **uhpp);\nstatic void u_freebranch(buf_T *buf, u_header_T *uhp, u_header_T **uhpp);\nstatic void u_freeentries(buf_T *buf, u_header_T *uhp, u_header_T **uhpp);\nstatic void u_freeentry(u_entry_T *, long);\n#ifdef FEAT_PERSISTENT_UNDO\nstatic void corruption_error(char *mesg, char_u *file_name);\nstatic void u_free_uhp(u_header_T *uhp);\nstatic int undo_write(bufinfo_T *bi, char_u *ptr, size_t len);\n# ifdef FEAT_CRYPT\nstatic int undo_flush(bufinfo_T *bi);\n# endif\nstatic int fwrite_crypt(bufinfo_T *bi, char_u *ptr, size_t len);\nstatic int undo_write_bytes(bufinfo_T *bi, long_u nr, int len);\nstatic void put_header_ptr(bufinfo_T *bi, u_header_T *uhp);\nstatic int undo_read_4c(bufinfo_T *bi);\nstatic int undo_read_2c(bufinfo_T *bi);\nstatic int undo_read_byte(bufinfo_T *bi);\nstatic time_t undo_read_time(bufinfo_T *bi);\nstatic int undo_read(bufinfo_T *bi, char_u *buffer, size_t size);\nstatic char_u *read_string_decrypt(bufinfo_T *bi, int len);\nstatic int serialize_header(bufinfo_T *bi, char_u *hash);\nstatic int serialize_uhp(bufinfo_T *bi, u_header_T *uhp);\nstatic u_header_T *unserialize_uhp(bufinfo_T *bi, char_u *file_name);\nstatic int serialize_uep(bufinfo_T *bi, u_entry_T *uep);\nstatic u_entry_T *unserialize_uep(bufinfo_T *bi, int *error, char_u *file_name);\nstatic void serialize_pos(bufinfo_T *bi, pos_T pos);\nstatic void unserialize_pos(bufinfo_T *bi, pos_T *pos);\nstatic void serialize_visualinfo(bufinfo_T *bi, visualinfo_T *info);\nstatic void unserialize_visualinfo(bufinfo_T *bi, visualinfo_T *info);\n#endif\n\n#define U_ALLOC_LINE(size) lalloc((long_u)(size), FALSE)\nstatic char_u *u_save_line(linenr_T);\n\n/* used in undo_end() to report number of added and deleted lines */\nstatic long\tu_newcount, u_oldcount;\n\n/*\n * When 'u' flag included in 'cpoptions', we behave like vi.  Need to remember\n * the action that \"u\" should do.\n */\nstatic int\tundo_undoes = FALSE;\n\nstatic int\tlastmark = 0;\n\n#if defined(U_DEBUG) || defined(PROTO)\n/*\n * Check the undo structures for being valid.  Print a warning when something\n * looks wrong.\n */\nstatic int seen_b_u_curhead;\nstatic int seen_b_u_newhead;\nstatic int header_count;\n\n    static void\nu_check_tree(u_header_T *uhp,\n\tu_header_T *exp_uh_next,\n\tu_header_T *exp_uh_alt_prev)\n{\n    u_entry_T *uep;\n\n    if (uhp == NULL)\n\treturn;\n    ++header_count;\n    if (uhp == curbuf->b_u_curhead && ++seen_b_u_curhead > 1)\n    {\n\tEMSG(\"b_u_curhead found twice (looping?)\");\n\treturn;\n    }\n    if (uhp == curbuf->b_u_newhead && ++seen_b_u_newhead > 1)\n    {\n\tEMSG(\"b_u_newhead found twice (looping?)\");\n\treturn;\n    }\n\n    if (uhp->uh_magic != UH_MAGIC)\n\tEMSG(\"uh_magic wrong (may be using freed memory)\");\n    else\n    {\n\t/* Check pointers back are correct. */\n\tif (uhp->uh_next.ptr != exp_uh_next)\n\t{\n\t    EMSG(\"uh_next wrong\");\n\t    smsg((char_u *)\"expected: 0x%x, actual: 0x%x\",\n\t\t\t\t\t       exp_uh_next, uhp->uh_next.ptr);\n\t}\n\tif (uhp->uh_alt_prev.ptr != exp_uh_alt_prev)\n\t{\n\t    EMSG(\"uh_alt_prev wrong\");\n\t    smsg((char_u *)\"expected: 0x%x, actual: 0x%x\",\n\t\t\t\t       exp_uh_alt_prev, uhp->uh_alt_prev.ptr);\n\t}\n\n\t/* Check the undo tree at this header. */\n\tfor (uep = uhp->uh_entry; uep != NULL; uep = uep->ue_next)\n\t{\n\t    if (uep->ue_magic != UE_MAGIC)\n\t    {\n\t\tEMSG(\"ue_magic wrong (may be using freed memory)\");\n\t\tbreak;\n\t    }\n\t}\n\n\t/* Check the next alt tree. */\n\tu_check_tree(uhp->uh_alt_next.ptr, uhp->uh_next.ptr, uhp);\n\n\t/* Check the next header in this branch. */\n\tu_check_tree(uhp->uh_prev.ptr, uhp, NULL);\n    }\n}\n\n    static void\nu_check(int newhead_may_be_NULL)\n{\n    seen_b_u_newhead = 0;\n    seen_b_u_curhead = 0;\n    header_count = 0;\n\n    u_check_tree(curbuf->b_u_oldhead, NULL, NULL);\n\n    if (seen_b_u_newhead == 0 && curbuf->b_u_oldhead != NULL\n\t    && !(newhead_may_be_NULL && curbuf->b_u_newhead == NULL))\n\tEMSGN(\"b_u_newhead invalid: 0x%x\", curbuf->b_u_newhead);\n    if (curbuf->b_u_curhead != NULL && seen_b_u_curhead == 0)\n\tEMSGN(\"b_u_curhead invalid: 0x%x\", curbuf->b_u_curhead);\n    if (header_count != curbuf->b_u_numhead)\n    {\n\tEMSG(\"b_u_numhead invalid\");\n\tsmsg((char_u *)\"expected: %ld, actual: %ld\",\n\t\t\t       (long)header_count, (long)curbuf->b_u_numhead);\n    }\n}\n#endif\n\n/*\n * Save the current line for both the \"u\" and \"U\" command.\n * Careful: may trigger autocommands that reload the buffer.\n * Returns OK or FAIL.\n */\n    int\nu_save_cursor(void)\n{\n    return (u_save((linenr_T)(curwin->w_cursor.lnum - 1),\n\t\t\t\t      (linenr_T)(curwin->w_cursor.lnum + 1)));\n}\n\n/*\n * Save the lines between \"top\" and \"bot\" for both the \"u\" and \"U\" command.\n * \"top\" may be 0 and bot may be curbuf->b_ml.ml_line_count + 1.\n * Careful: may trigger autocommands that reload the buffer.\n * Returns FAIL when lines could not be saved, OK otherwise.\n */\n    int\nu_save(linenr_T top, linenr_T bot)\n{\n    if (undo_off)\n\treturn OK;\n\n    if (top > curbuf->b_ml.ml_line_count\n\t    || top >= bot\n\t    || bot > curbuf->b_ml.ml_line_count + 1)\n\treturn FALSE;\t/* rely on caller to do error messages */\n\n    if (top + 2 == bot)\n\tu_saveline((linenr_T)(top + 1));\n\n    return (u_savecommon(top, bot, (linenr_T)0, FALSE));\n}\n\n/*\n * Save the line \"lnum\" (used by \":s\" and \"~\" command).\n * The line is replaced, so the new bottom line is lnum + 1.\n * Careful: may trigger autocommands that reload the buffer.\n * Returns FAIL when lines could not be saved, OK otherwise.\n */\n    int\nu_savesub(linenr_T lnum)\n{\n    if (undo_off)\n\treturn OK;\n\n    return (u_savecommon(lnum - 1, lnum + 1, lnum + 1, FALSE));\n}\n\n/*\n * A new line is inserted before line \"lnum\" (used by :s command).\n * The line is inserted, so the new bottom line is lnum + 1.\n * Careful: may trigger autocommands that reload the buffer.\n * Returns FAIL when lines could not be saved, OK otherwise.\n */\n    int\nu_inssub(linenr_T lnum)\n{\n    if (undo_off)\n\treturn OK;\n\n    return (u_savecommon(lnum - 1, lnum, lnum + 1, FALSE));\n}\n\n/*\n * Save the lines \"lnum\" - \"lnum\" + nlines (used by delete command).\n * The lines are deleted, so the new bottom line is lnum, unless the buffer\n * becomes empty.\n * Careful: may trigger autocommands that reload the buffer.\n * Returns FAIL when lines could not be saved, OK otherwise.\n */\n    int\nu_savedel(linenr_T lnum, long nlines)\n{\n    if (undo_off)\n\treturn OK;\n\n    return (u_savecommon(lnum - 1, lnum + nlines,\n\t\t     nlines == curbuf->b_ml.ml_line_count ? 2 : lnum, FALSE));\n}\n\n/*\n * Return TRUE when undo is allowed.  Otherwise give an error message and\n * return FALSE.\n */\n    int\nundo_allowed(void)\n{\n    /* Don't allow changes when 'modifiable' is off.  */\n    if (!curbuf->b_p_ma)\n    {\n\tEMSG(_(e_modifiable));\n\treturn FALSE;\n    }\n\n#ifdef HAVE_SANDBOX\n    /* In the sandbox it's not allowed to change the text. */\n    if (sandbox != 0)\n    {\n\tEMSG(_(e_sandbox));\n\treturn FALSE;\n    }\n#endif\n\n    /* Don't allow changes in the buffer while editing the cmdline.  The\n     * caller of getcmdline() may get confused. */\n    if (textlock != 0)\n    {\n\tEMSG(_(e_secure));\n\treturn FALSE;\n    }\n\n    return TRUE;\n}\n\n/*\n * Get the undolevle value for the current buffer.\n */\n    static long\nget_undolevel(void)\n{\n    if (curbuf->b_p_ul == NO_LOCAL_UNDOLEVEL)\n\treturn p_ul;\n    return curbuf->b_p_ul;\n}\n\n/*\n * Common code for various ways to save text before a change.\n * \"top\" is the line above the first changed line.\n * \"bot\" is the line below the last changed line.\n * \"newbot\" is the new bottom line.  Use zero when not known.\n * \"reload\" is TRUE when saving for a buffer reload.\n * Careful: may trigger autocommands that reload the buffer.\n * Returns FAIL when lines could not be saved, OK otherwise.\n */\n    int\nu_savecommon(\n    linenr_T\ttop,\n    linenr_T\tbot,\n    linenr_T\tnewbot,\n    int\t\treload)\n{\n    linenr_T\tlnum;\n    long\ti;\n    u_header_T\t*uhp;\n    u_header_T\t*old_curhead;\n    u_entry_T\t*uep;\n    u_entry_T\t*prev_uep;\n    long\tsize;\n\n    if (!reload)\n    {\n\t/* When making changes is not allowed return FAIL.  It's a crude way\n\t * to make all change commands fail. */\n\tif (!undo_allowed())\n\t    return FAIL;\n\n#ifdef FEAT_NETBEANS_INTG\n\t/*\n\t * Netbeans defines areas that cannot be modified.  Bail out here when\n\t * trying to change text in a guarded area.\n\t */\n\tif (netbeans_active())\n\t{\n\t    if (netbeans_is_guarded(top, bot))\n\t    {\n\t\tEMSG(_(e_guarded));\n\t\treturn FAIL;\n\t    }\n\t    if (curbuf->b_p_ro)\n\t    {\n\t\tEMSG(_(e_nbreadonly));\n\t\treturn FAIL;\n\t    }\n\t}\n#endif\n\n#ifdef FEAT_AUTOCMD\n\t/*\n\t * Saving text for undo means we are going to make a change.  Give a\n\t * warning for a read-only file before making the change, so that the\n\t * FileChangedRO event can replace the buffer with a read-write version\n\t * (e.g., obtained from a source control system).\n\t */\n\tchange_warning(0);\n\tif (bot > curbuf->b_ml.ml_line_count + 1)\n\t{\n\t    /* This happens when the FileChangedRO autocommand changes the\n\t     * file in a way it becomes shorter. */\n\t    EMSG(_(\"E881: Line count changed unexpectedly\"));\n\t    return FAIL;\n\t}\n#endif\n    }\n\n#ifdef U_DEBUG\n    u_check(FALSE);\n#endif\n\n    size = bot - top - 1;\n\n    /*\n     * If curbuf->b_u_synced == TRUE make a new header.\n     */\n    if (curbuf->b_u_synced)\n    {\n#ifdef FEAT_JUMPLIST\n\t/* Need to create new entry in b_changelist. */\n\tcurbuf->b_new_change = TRUE;\n#endif\n\n\tif (get_undolevel() >= 0)\n\t{\n\t    /*\n\t     * Make a new header entry.  Do this first so that we don't mess\n\t     * up the undo info when out of memory.\n\t     */\n\t    uhp = (u_header_T *)U_ALLOC_LINE(sizeof(u_header_T));\n\t    if (uhp == NULL)\n\t\tgoto nomem;\n#ifdef U_DEBUG\n\t    uhp->uh_magic = UH_MAGIC;\n#endif\n\t}\n\telse\n\t    uhp = NULL;\n\n\t/*\n\t * If we undid more than we redid, move the entry lists before and\n\t * including curbuf->b_u_curhead to an alternate branch.\n\t */\n\told_curhead = curbuf->b_u_curhead;\n\tif (old_curhead != NULL)\n\t{\n\t    curbuf->b_u_newhead = old_curhead->uh_next.ptr;\n\t    curbuf->b_u_curhead = NULL;\n\t}\n\n\t/*\n\t * free headers to keep the size right\n\t */\n\twhile (curbuf->b_u_numhead > get_undolevel()\n\t\t\t\t\t       && curbuf->b_u_oldhead != NULL)\n\t{\n\t    u_header_T\t    *uhfree = curbuf->b_u_oldhead;\n\n\t    if (uhfree == old_curhead)\n\t\t/* Can't reconnect the branch, delete all of it. */\n\t\tu_freebranch(curbuf, uhfree, &old_curhead);\n\t    else if (uhfree->uh_alt_next.ptr == NULL)\n\t\t/* There is no branch, only free one header. */\n\t\tu_freeheader(curbuf, uhfree, &old_curhead);\n\t    else\n\t    {\n\t\t/* Free the oldest alternate branch as a whole. */\n\t\twhile (uhfree->uh_alt_next.ptr != NULL)\n\t\t    uhfree = uhfree->uh_alt_next.ptr;\n\t\tu_freebranch(curbuf, uhfree, &old_curhead);\n\t    }\n#ifdef U_DEBUG\n\t    u_check(TRUE);\n#endif\n\t}\n\n\tif (uhp == NULL)\t\t/* no undo at all */\n\t{\n\t    if (old_curhead != NULL)\n\t\tu_freebranch(curbuf, old_curhead, NULL);\n\t    curbuf->b_u_synced = FALSE;\n\t    return OK;\n\t}\n\n\tuhp->uh_prev.ptr = NULL;\n\tuhp->uh_next.ptr = curbuf->b_u_newhead;\n\tuhp->uh_alt_next.ptr = old_curhead;\n\tif (old_curhead != NULL)\n\t{\n\t    uhp->uh_alt_prev.ptr = old_curhead->uh_alt_prev.ptr;\n\t    if (uhp->uh_alt_prev.ptr != NULL)\n\t\tuhp->uh_alt_prev.ptr->uh_alt_next.ptr = uhp;\n\t    old_curhead->uh_alt_prev.ptr = uhp;\n\t    if (curbuf->b_u_oldhead == old_curhead)\n\t\tcurbuf->b_u_oldhead = uhp;\n\t}\n\telse\n\t    uhp->uh_alt_prev.ptr = NULL;\n\tif (curbuf->b_u_newhead != NULL)\n\t    curbuf->b_u_newhead->uh_prev.ptr = uhp;\n\n\tuhp->uh_seq = ++curbuf->b_u_seq_last;\n\tcurbuf->b_u_seq_cur = uhp->uh_seq;\n\tuhp->uh_time = vim_time();\n\tuhp->uh_save_nr = 0;\n\tcurbuf->b_u_time_cur = uhp->uh_time + 1;\n\n\tuhp->uh_walk = 0;\n\tuhp->uh_entry = NULL;\n\tuhp->uh_getbot_entry = NULL;\n\tuhp->uh_cursor = curwin->w_cursor;\t/* save cursor pos. for undo */\n#ifdef FEAT_VIRTUALEDIT\n\tif (virtual_active() && curwin->w_cursor.coladd > 0)\n\t    uhp->uh_cursor_vcol = getviscol();\n\telse\n\t    uhp->uh_cursor_vcol = -1;\n#endif\n\n\t/* save changed and buffer empty flag for undo */\n\tuhp->uh_flags = (curbuf->b_changed ? UH_CHANGED : 0) +\n\t\t       ((curbuf->b_ml.ml_flags & ML_EMPTY) ? UH_EMPTYBUF : 0);\n\n\t/* save named marks and Visual marks for undo */\n\tmch_memmove(uhp->uh_namedm, curbuf->b_namedm, sizeof(pos_T) * NMARKS);\n\tuhp->uh_visual = curbuf->b_visual;\n\n\tcurbuf->b_u_newhead = uhp;\n\tif (curbuf->b_u_oldhead == NULL)\n\t    curbuf->b_u_oldhead = uhp;\n\t++curbuf->b_u_numhead;\n    }\n    else\n    {\n\tif (get_undolevel() < 0)\t/* no undo at all */\n\t    return OK;\n\n\t/*\n\t * When saving a single line, and it has been saved just before, it\n\t * doesn't make sense saving it again.  Saves a lot of memory when\n\t * making lots of changes inside the same line.\n\t * This is only possible if the previous change didn't increase or\n\t * decrease the number of lines.\n\t * Check the ten last changes.  More doesn't make sense and takes too\n\t * long.\n\t */\n\tif (size == 1)\n\t{\n\t    uep = u_get_headentry();\n\t    prev_uep = NULL;\n\t    for (i = 0; i < 10; ++i)\n\t    {\n\t\tif (uep == NULL)\n\t\t    break;\n\n\t\t/* If lines have been inserted/deleted we give up.\n\t\t * Also when the line was included in a multi-line save. */\n\t\tif ((curbuf->b_u_newhead->uh_getbot_entry != uep\n\t\t\t    ? (uep->ue_top + uep->ue_size + 1\n\t\t\t\t!= (uep->ue_bot == 0\n\t\t\t\t    ? curbuf->b_ml.ml_line_count + 1\n\t\t\t\t    : uep->ue_bot))\n\t\t\t    : uep->ue_lcount != curbuf->b_ml.ml_line_count)\n\t\t\t|| (uep->ue_size > 1\n\t\t\t    && top >= uep->ue_top\n\t\t\t    && top + 2 <= uep->ue_top + uep->ue_size + 1))\n\t\t    break;\n\n\t\t/* If it's the same line we can skip saving it again. */\n\t\tif (uep->ue_size == 1 && uep->ue_top == top)\n\t\t{\n\t\t    if (i > 0)\n\t\t    {\n\t\t\t/* It's not the last entry: get ue_bot for the last\n\t\t\t * entry now.  Following deleted/inserted lines go to\n\t\t\t * the re-used entry. */\n\t\t\tu_getbot();\n\t\t\tcurbuf->b_u_synced = FALSE;\n\n\t\t\t/* Move the found entry to become the last entry.  The\n\t\t\t * order of undo/redo doesn't matter for the entries\n\t\t\t * we move it over, since they don't change the line\n\t\t\t * count and don't include this line.  It does matter\n\t\t\t * for the found entry if the line count is changed by\n\t\t\t * the executed command. */\n\t\t\tprev_uep->ue_next = uep->ue_next;\n\t\t\tuep->ue_next = curbuf->b_u_newhead->uh_entry;\n\t\t\tcurbuf->b_u_newhead->uh_entry = uep;\n\t\t    }\n\n\t\t    /* The executed command may change the line count. */\n\t\t    if (newbot != 0)\n\t\t\tuep->ue_bot = newbot;\n\t\t    else if (bot > curbuf->b_ml.ml_line_count)\n\t\t\tuep->ue_bot = 0;\n\t\t    else\n\t\t    {\n\t\t\tuep->ue_lcount = curbuf->b_ml.ml_line_count;\n\t\t\tcurbuf->b_u_newhead->uh_getbot_entry = uep;\n\t\t    }\n\t\t    return OK;\n\t\t}\n\t\tprev_uep = uep;\n\t\tuep = uep->ue_next;\n\t    }\n\t}\n\n\t/* find line number for ue_bot for previous u_save() */\n\tu_getbot();\n    }\n\n#if !defined(UNIX) && !defined(WIN32)\n\t/*\n\t * With Amiga we can't handle big undo's, because\n\t * then u_alloc_line would have to allocate a block larger than 32K\n\t */\n    if (size >= 8000)\n\tgoto nomem;\n#endif\n\n    /*\n     * add lines in front of entry list\n     */\n    uep = (u_entry_T *)U_ALLOC_LINE(sizeof(u_entry_T));\n    if (uep == NULL)\n\tgoto nomem;\n    vim_memset(uep, 0, sizeof(u_entry_T));\n#ifdef U_DEBUG\n    uep->ue_magic = UE_MAGIC;\n#endif\n\n    uep->ue_size = size;\n    uep->ue_top = top;\n    if (newbot != 0)\n\tuep->ue_bot = newbot;\n    /*\n     * Use 0 for ue_bot if bot is below last line.\n     * Otherwise we have to compute ue_bot later.\n     */\n    else if (bot > curbuf->b_ml.ml_line_count)\n\tuep->ue_bot = 0;\n    else\n    {\n\tuep->ue_lcount = curbuf->b_ml.ml_line_count;\n\tcurbuf->b_u_newhead->uh_getbot_entry = uep;\n    }\n\n    if (size > 0)\n    {\n\tif ((uep->ue_array = (char_u **)U_ALLOC_LINE(\n\t\t\t\t\t    sizeof(char_u *) * size)) == NULL)\n\t{\n\t    u_freeentry(uep, 0L);\n\t    goto nomem;\n\t}\n\tfor (i = 0, lnum = top + 1; i < size; ++i)\n\t{\n\t    fast_breakcheck();\n\t    if (got_int)\n\t    {\n\t\tu_freeentry(uep, i);\n\t\treturn FAIL;\n\t    }\n\t    if ((uep->ue_array[i] = u_save_line(lnum++)) == NULL)\n\t    {\n\t\tu_freeentry(uep, i);\n\t\tgoto nomem;\n\t    }\n\t}\n    }\n    else\n\tuep->ue_array = NULL;\n    uep->ue_next = curbuf->b_u_newhead->uh_entry;\n    curbuf->b_u_newhead->uh_entry = uep;\n    curbuf->b_u_synced = FALSE;\n    undo_undoes = FALSE;\n\n#ifdef U_DEBUG\n    u_check(FALSE);\n#endif\n    return OK;\n\nnomem:\n    msg_silent = 0;\t/* must display the prompt */\n    if (ask_yesno((char_u *)_(\"No undo possible; continue anyway\"), TRUE)\n\t\t\t\t\t\t\t\t       == 'y')\n    {\n\tundo_off = TRUE;\t    /* will be reset when character typed */\n\treturn OK;\n    }\n    do_outofmem_msg((long_u)0);\n    return FAIL;\n}\n\n#if defined(FEAT_PERSISTENT_UNDO) || defined(PROTO)\n\n# define UF_START_MAGIC\t    \"Vim\\237UnDo\\345\"  /* magic at start of undofile */\n# define UF_START_MAGIC_LEN\t9\n# define UF_HEADER_MAGIC\t0x5fd0\t/* magic at start of header */\n# define UF_HEADER_END_MAGIC\t0xe7aa\t/* magic after last header */\n# define UF_ENTRY_MAGIC\t\t0xf518\t/* magic at start of entry */\n# define UF_ENTRY_END_MAGIC\t0x3581\t/* magic after last entry */\n# define UF_VERSION\t\t2\t/* 2-byte undofile version number */\n# define UF_VERSION_CRYPT\t0x8002\t/* idem, encrypted */\n\n/* extra fields for header */\n# define UF_LAST_SAVE_NR\t1\n\n/* extra fields for uhp */\n# define UHP_SAVE_NR\t\t1\n\nstatic char_u e_not_open[] = N_(\"E828: Cannot open undo file for writing: %s\");\n\n/*\n * Compute the hash for the current buffer text into hash[UNDO_HASH_SIZE].\n */\n    void\nu_compute_hash(char_u *hash)\n{\n    context_sha256_T\tctx;\n    linenr_T\t\tlnum;\n    char_u\t\t*p;\n\n    sha256_start(&ctx);\n    for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum)\n    {\n\tp = ml_get(lnum);\n\tsha256_update(&ctx, p, (UINT32_T)(STRLEN(p) + 1));\n    }\n    sha256_finish(&ctx, hash);\n}\n\n/*\n * Return an allocated string of the full path of the target undofile.\n * When \"reading\" is TRUE find the file to read, go over all directories in\n * 'undodir'.\n * When \"reading\" is FALSE use the first name where the directory exists.\n * Returns NULL when there is no place to write or no file to read.\n */\n    char_u *\nu_get_undo_file_name(char_u *buf_ffname, int reading)\n{\n    char_u\t*dirp;\n    char_u\tdir_name[IOSIZE + 1];\n    char_u\t*munged_name = NULL;\n    char_u\t*undo_file_name = NULL;\n    int\t\tdir_len;\n    char_u\t*p;\n    stat_T\tst;\n    char_u\t*ffname = buf_ffname;\n#ifdef HAVE_READLINK\n    char_u\tfname_buf[MAXPATHL];\n#endif\n\n    if (ffname == NULL)\n\treturn NULL;\n\n#ifdef HAVE_READLINK\n    /* Expand symlink in the file name, so that we put the undo file with the\n     * actual file instead of with the symlink. */\n    if (resolve_symlink(ffname, fname_buf) == OK)\n\tffname = fname_buf;\n#endif\n\n    /* Loop over 'undodir'.  When reading find the first file that exists.\n     * When not reading use the first directory that exists or \".\". */\n    dirp = p_udir;\n    while (*dirp != NUL)\n    {\n\tdir_len = copy_option_part(&dirp, dir_name, IOSIZE, \",\");\n\tif (dir_len == 1 && dir_name[0] == '.')\n\t{\n\t    /* Use same directory as the ffname,\n\t     * \"dir/name\" -> \"dir/.name.un~\" */\n\t    undo_file_name = vim_strnsave(ffname, (int)(STRLEN(ffname) + 5));\n\t    if (undo_file_name == NULL)\n\t\tbreak;\n\t    p = gettail(undo_file_name);\n#ifdef VMS\n\t    /* VMS can not handle more than one dot in the filenames\n\t     * use \"dir/name\" -> \"dir/_un_name\" - add _un_\n\t     * at the beginning to keep the extension */\n\t    mch_memmove(p + 4,  p, STRLEN(p) + 1);\n\t    mch_memmove(p, \"_un_\", 4);\n\n#else\n\t    /* Use same directory as the ffname,\n\t     * \"dir/name\" -> \"dir/.name.un~\" */\n\t    mch_memmove(p + 1, p, STRLEN(p) + 1);\n\t    *p = '.';\n\t    STRCAT(p, \".un~\");\n#endif\n\t}\n\telse\n\t{\n\t    dir_name[dir_len] = NUL;\n\t    if (mch_isdir(dir_name))\n\t    {\n\t\tif (munged_name == NULL)\n\t\t{\n\t\t    munged_name = vim_strsave(ffname);\n\t\t    if (munged_name == NULL)\n\t\t\treturn NULL;\n\t\t    for (p = munged_name; *p != NUL; mb_ptr_adv(p))\n\t\t\tif (vim_ispathsep(*p))\n\t\t\t    *p = '%';\n\t\t}\n\t\tundo_file_name = concat_fnames(dir_name, munged_name, TRUE);\n\t    }\n\t}\n\n\t/* When reading check if the file exists. */\n\tif (undo_file_name != NULL && (!reading\n\t\t\t       || mch_stat((char *)undo_file_name, &st) >= 0))\n\t    break;\n\tvim_free(undo_file_name);\n\tundo_file_name = NULL;\n    }\n\n    vim_free(munged_name);\n    return undo_file_name;\n}\n\n    static void\ncorruption_error(char *mesg, char_u *file_name)\n{\n    EMSG3(_(\"E825: Corrupted undo file (%s): %s\"), mesg, file_name);\n}\n\n    static void\nu_free_uhp(u_header_T *uhp)\n{\n    u_entry_T\t*nuep;\n    u_entry_T\t*uep;\n\n    uep = uhp->uh_entry;\n    while (uep != NULL)\n    {\n\tnuep = uep->ue_next;\n\tu_freeentry(uep, uep->ue_size);\n\tuep = nuep;\n    }\n    vim_free(uhp);\n}\n\n/*\n * Write a sequence of bytes to the undo file.\n * Buffers and encrypts as needed.\n * Returns OK or FAIL.\n */\n    static int\nundo_write(bufinfo_T *bi, char_u *ptr, size_t len)\n{\n#ifdef FEAT_CRYPT\n    if (bi->bi_buffer != NULL)\n    {\n\tsize_t\tlen_todo = len;\n\tchar_u  *p = ptr;\n\n\twhile (bi->bi_used + len_todo >= CRYPT_BUF_SIZE)\n\t{\n\t    size_t\tn = CRYPT_BUF_SIZE - bi->bi_used;\n\n\t    mch_memmove(bi->bi_buffer + bi->bi_used, p, n);\n\t    len_todo -= n;\n\t    p += n;\n\t    bi->bi_used = CRYPT_BUF_SIZE;\n\t    if (undo_flush(bi) == FAIL)\n\t\treturn FAIL;\n\t}\n\tif (len_todo > 0)\n\t{\n\t    mch_memmove(bi->bi_buffer + bi->bi_used, p, len_todo);\n\t    bi->bi_used += len_todo;\n\t}\n\treturn OK;\n    }\n#endif\n    if (fwrite(ptr, len, (size_t)1, bi->bi_fp) != 1)\n\treturn FAIL;\n    return OK;\n}\n\n#ifdef FEAT_CRYPT\n    static int\nundo_flush(bufinfo_T *bi)\n{\n    if (bi->bi_buffer != NULL && bi->bi_used > 0)\n    {\n\tcrypt_encode_inplace(bi->bi_state, bi->bi_buffer, bi->bi_used);\n\tif (fwrite(bi->bi_buffer, bi->bi_used, (size_t)1, bi->bi_fp) != 1)\n\t    return FAIL;\n\tbi->bi_used = 0;\n    }\n    return OK;\n}\n#endif\n\n/*\n * Write \"ptr[len]\" and crypt the bytes when needed.\n * Returns OK or FAIL.\n */\n    static int\nfwrite_crypt(bufinfo_T *bi, char_u *ptr, size_t len)\n{\n#ifdef FEAT_CRYPT\n    char_u  *copy;\n    char_u  small_buf[100];\n    size_t  i;\n\n    if (bi->bi_state != NULL && bi->bi_buffer == NULL)\n    {\n\t/* crypting every piece of text separately */\n\tif (len < 100)\n\t    copy = small_buf;  /* no malloc()/free() for short strings */\n\telse\n\t{\n\t    copy = lalloc(len, FALSE);\n\t    if (copy == NULL)\n\t\treturn 0;\n\t}\n\tcrypt_encode(bi->bi_state, ptr, len, copy);\n\ti = fwrite(copy, len, (size_t)1, bi->bi_fp);\n\tif (copy != small_buf)\n\t    vim_free(copy);\n\treturn i == 1 ? OK : FAIL;\n    }\n#endif\n    return undo_write(bi, ptr, len);\n}\n\n/*\n * Write a number, MSB first, in \"len\" bytes.\n * Must match with undo_read_?c() functions.\n * Returns OK or FAIL.\n */\n    static int\nundo_write_bytes(bufinfo_T *bi, long_u nr, int len)\n{\n    char_u  buf[8];\n    int\t    i;\n    int\t    bufi = 0;\n\n    for (i = len - 1; i >= 0; --i)\n\tbuf[bufi++] = (char_u)(nr >> (i * 8));\n    return undo_write(bi, buf, (size_t)len);\n}\n\n/*\n * Write the pointer to an undo header.  Instead of writing the pointer itself\n * we use the sequence number of the header.  This is converted back to\n * pointers when reading. */\n    static void\nput_header_ptr(bufinfo_T *bi, u_header_T *uhp)\n{\n    undo_write_bytes(bi, (long_u)(uhp != NULL ? uhp->uh_seq : 0), 4);\n}\n\n    static int\nundo_read_4c(bufinfo_T *bi)\n{\n#ifdef FEAT_CRYPT\n    if (bi->bi_buffer != NULL)\n    {\n\tchar_u  buf[4];\n\tint\tn;\n\n\tundo_read(bi, buf, (size_t)4);\n\tn = ((unsigned)buf[0] << 24) + (buf[1] << 16) + (buf[2] << 8) + buf[3];\n\treturn n;\n    }\n#endif\n    return get4c(bi->bi_fp);\n}\n\n    static int\nundo_read_2c(bufinfo_T *bi)\n{\n#ifdef FEAT_CRYPT\n    if (bi->bi_buffer != NULL)\n    {\n\tchar_u  buf[2];\n\tint\tn;\n\n\tundo_read(bi, buf, (size_t)2);\n\tn = (buf[0] << 8) + buf[1];\n\treturn n;\n    }\n#endif\n    return get2c(bi->bi_fp);\n}\n\n    static int\nundo_read_byte(bufinfo_T *bi)\n{\n#ifdef FEAT_CRYPT\n    if (bi->bi_buffer != NULL)\n    {\n\tchar_u  buf[1];\n\n\tundo_read(bi, buf, (size_t)1);\n\treturn buf[0];\n    }\n#endif\n    return getc(bi->bi_fp);\n}\n\n    static time_t\nundo_read_time(bufinfo_T *bi)\n{\n#ifdef FEAT_CRYPT\n    if (bi->bi_buffer != NULL)\n    {\n\tchar_u  buf[8];\n\ttime_t\tn = 0;\n\tint\ti;\n\n\tundo_read(bi, buf, (size_t)8);\n\tfor (i = 0; i < 8; ++i)\n\t    n = (n << 8) + buf[i];\n\treturn n;\n    }\n#endif\n    return get8ctime(bi->bi_fp);\n}\n\n/*\n * Read \"buffer[size]\" from the undo file.\n * Return OK or FAIL.\n */\n    static int\nundo_read(bufinfo_T *bi, char_u *buffer, size_t size)\n{\n#ifdef FEAT_CRYPT\n    if (bi->bi_buffer != NULL)\n    {\n\tint\tsize_todo = (int)size;\n\tchar_u\t*p = buffer;\n\n\twhile (size_todo > 0)\n\t{\n\t    size_t n;\n\n\t    if (bi->bi_used >= bi->bi_avail)\n\t    {\n\t\tn = fread(bi->bi_buffer, 1, (size_t)CRYPT_BUF_SIZE, bi->bi_fp);\n\t\tif (n == 0)\n\t\t{\n\t\t    /* Error may be checked for only later.  Fill with zeros,\n\t\t     * so that the reader won't use garbage. */\n\t\t    vim_memset(p, 0, size_todo);\n\t\t    return FAIL;\n\t\t}\n\t\tbi->bi_avail = n;\n\t\tbi->bi_used = 0;\n\t\tcrypt_decode_inplace(bi->bi_state, bi->bi_buffer, bi->bi_avail);\n\t    }\n\t    n = size_todo;\n\t    if (n > bi->bi_avail - bi->bi_used)\n\t\tn = bi->bi_avail - bi->bi_used;\n\t    mch_memmove(p, bi->bi_buffer + bi->bi_used, n);\n\t    bi->bi_used += n;\n\t    size_todo -= (int)n;\n\t    p += n;\n\t}\n\treturn OK;\n    }\n#endif\n    if (fread(buffer, (size_t)size, 1, bi->bi_fp) != 1)\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Read a string of length \"len\" from \"bi->bi_fd\".\n * \"len\" can be zero to allocate an empty line.\n * Decrypt the bytes if needed.\n * Append a NUL.\n * Returns a pointer to allocated memory or NULL for failure.\n */\n    static char_u *\nread_string_decrypt(bufinfo_T *bi, int len)\n{\n    char_u  *ptr = alloc((unsigned)len + 1);\n\n    if (ptr != NULL)\n    {\n\tif (len > 0 && undo_read(bi, ptr, len) == FAIL)\n\t{\n\t    vim_free(ptr);\n\t    return NULL;\n\t}\n\tptr[len] = NUL;\n#ifdef FEAT_CRYPT\n\tif (bi->bi_state != NULL && bi->bi_buffer == NULL)\n\t    crypt_decode_inplace(bi->bi_state, ptr, len);\n#endif\n    }\n    return ptr;\n}\n\n/*\n * Writes the (not encrypted) header and initializes encryption if needed.\n */\n    static int\nserialize_header(bufinfo_T *bi, char_u *hash)\n{\n    int\t\tlen;\n    buf_T\t*buf = bi->bi_buf;\n    FILE\t*fp = bi->bi_fp;\n    char_u\ttime_buf[8];\n\n    /* Start writing, first the magic marker and undo info version. */\n    if (fwrite(UF_START_MAGIC, (size_t)UF_START_MAGIC_LEN, (size_t)1, fp) != 1)\n\treturn FAIL;\n\n    /* If the buffer is encrypted then all text bytes following will be\n     * encrypted.  Numbers and other info is not crypted. */\n#ifdef FEAT_CRYPT\n    if (*buf->b_p_key != NUL)\n    {\n\tchar_u *header;\n\tint    header_len;\n\n\tundo_write_bytes(bi, (long_u)UF_VERSION_CRYPT, 2);\n\tbi->bi_state = crypt_create_for_writing(crypt_get_method_nr(buf),\n\t\t\t\t\t  buf->b_p_key, &header, &header_len);\n\tif (bi->bi_state == NULL)\n\t    return FAIL;\n\tlen = (int)fwrite(header, (size_t)header_len, (size_t)1, fp);\n\tvim_free(header);\n\tif (len != 1)\n\t{\n\t    crypt_free_state(bi->bi_state);\n\t    bi->bi_state = NULL;\n\t    return FAIL;\n\t}\n\n\tif (crypt_whole_undofile(crypt_get_method_nr(buf)))\n\t{\n\t    bi->bi_buffer = alloc(CRYPT_BUF_SIZE);\n\t    if (bi->bi_buffer == NULL)\n\t    {\n\t\tcrypt_free_state(bi->bi_state);\n\t\tbi->bi_state = NULL;\n\t\treturn FAIL;\n\t    }\n\t    bi->bi_used = 0;\n\t}\n    }\n    else\n#endif\n\tundo_write_bytes(bi, (long_u)UF_VERSION, 2);\n\n\n    /* Write a hash of the buffer text, so that we can verify it is still the\n     * same when reading the buffer text. */\n    if (undo_write(bi, hash, (size_t)UNDO_HASH_SIZE) == FAIL)\n\treturn FAIL;\n\n    /* buffer-specific data */\n    undo_write_bytes(bi, (long_u)buf->b_ml.ml_line_count, 4);\n    len = buf->b_u_line_ptr != NULL ? (int)STRLEN(buf->b_u_line_ptr) : 0;\n    undo_write_bytes(bi, (long_u)len, 4);\n    if (len > 0 && fwrite_crypt(bi, buf->b_u_line_ptr, (size_t)len) == FAIL)\n\treturn FAIL;\n    undo_write_bytes(bi, (long_u)buf->b_u_line_lnum, 4);\n    undo_write_bytes(bi, (long_u)buf->b_u_line_colnr, 4);\n\n    /* Undo structures header data */\n    put_header_ptr(bi, buf->b_u_oldhead);\n    put_header_ptr(bi, buf->b_u_newhead);\n    put_header_ptr(bi, buf->b_u_curhead);\n\n    undo_write_bytes(bi, (long_u)buf->b_u_numhead, 4);\n    undo_write_bytes(bi, (long_u)buf->b_u_seq_last, 4);\n    undo_write_bytes(bi, (long_u)buf->b_u_seq_cur, 4);\n    time_to_bytes(buf->b_u_time_cur, time_buf);\n    undo_write(bi, time_buf, 8);\n\n    /* Optional fields. */\n    undo_write_bytes(bi, 4, 1);\n    undo_write_bytes(bi, UF_LAST_SAVE_NR, 1);\n    undo_write_bytes(bi, (long_u)buf->b_u_save_nr_last, 4);\n\n    undo_write_bytes(bi, 0, 1);  /* end marker */\n\n    return OK;\n}\n\n    static int\nserialize_uhp(bufinfo_T *bi, u_header_T *uhp)\n{\n    int\t\ti;\n    u_entry_T\t*uep;\n    char_u\ttime_buf[8];\n\n    if (undo_write_bytes(bi, (long_u)UF_HEADER_MAGIC, 2) == FAIL)\n\treturn FAIL;\n\n    put_header_ptr(bi, uhp->uh_next.ptr);\n    put_header_ptr(bi, uhp->uh_prev.ptr);\n    put_header_ptr(bi, uhp->uh_alt_next.ptr);\n    put_header_ptr(bi, uhp->uh_alt_prev.ptr);\n    undo_write_bytes(bi, uhp->uh_seq, 4);\n    serialize_pos(bi, uhp->uh_cursor);\n#ifdef FEAT_VIRTUALEDIT\n    undo_write_bytes(bi, (long_u)uhp->uh_cursor_vcol, 4);\n#else\n    undo_write_bytes(bi, (long_u)0, 4);\n#endif\n    undo_write_bytes(bi, (long_u)uhp->uh_flags, 2);\n    /* Assume NMARKS will stay the same. */\n    for (i = 0; i < NMARKS; ++i)\n\tserialize_pos(bi, uhp->uh_namedm[i]);\n    serialize_visualinfo(bi, &uhp->uh_visual);\n    time_to_bytes(uhp->uh_time, time_buf);\n    undo_write(bi, time_buf, 8);\n\n    /* Optional fields. */\n    undo_write_bytes(bi, 4, 1);\n    undo_write_bytes(bi, UHP_SAVE_NR, 1);\n    undo_write_bytes(bi, (long_u)uhp->uh_save_nr, 4);\n\n    undo_write_bytes(bi, 0, 1);  /* end marker */\n\n    /* Write all the entries. */\n    for (uep = uhp->uh_entry; uep != NULL; uep = uep->ue_next)\n    {\n\tundo_write_bytes(bi, (long_u)UF_ENTRY_MAGIC, 2);\n\tif (serialize_uep(bi, uep) == FAIL)\n\t    return FAIL;\n    }\n    undo_write_bytes(bi, (long_u)UF_ENTRY_END_MAGIC, 2);\n    return OK;\n}\n\n    static u_header_T *\nunserialize_uhp(bufinfo_T *bi, char_u *file_name)\n{\n    u_header_T\t*uhp;\n    int\t\ti;\n    u_entry_T\t*uep, *last_uep;\n    int\t\tc;\n    int\t\terror;\n\n    uhp = (u_header_T *)U_ALLOC_LINE(sizeof(u_header_T));\n    if (uhp == NULL)\n\treturn NULL;\n    vim_memset(uhp, 0, sizeof(u_header_T));\n#ifdef U_DEBUG\n    uhp->uh_magic = UH_MAGIC;\n#endif\n    uhp->uh_next.seq = undo_read_4c(bi);\n    uhp->uh_prev.seq = undo_read_4c(bi);\n    uhp->uh_alt_next.seq = undo_read_4c(bi);\n    uhp->uh_alt_prev.seq = undo_read_4c(bi);\n    uhp->uh_seq = undo_read_4c(bi);\n    if (uhp->uh_seq <= 0)\n    {\n\tcorruption_error(\"uh_seq\", file_name);\n\tvim_free(uhp);\n\treturn NULL;\n    }\n    unserialize_pos(bi, &uhp->uh_cursor);\n#ifdef FEAT_VIRTUALEDIT\n    uhp->uh_cursor_vcol = undo_read_4c(bi);\n#else\n    (void)undo_read_4c(bi);\n#endif\n    uhp->uh_flags = undo_read_2c(bi);\n    for (i = 0; i < NMARKS; ++i)\n\tunserialize_pos(bi, &uhp->uh_namedm[i]);\n    unserialize_visualinfo(bi, &uhp->uh_visual);\n    uhp->uh_time = undo_read_time(bi);\n\n    /* Optional fields. */\n    for (;;)\n    {\n\tint len = undo_read_byte(bi);\n\tint what;\n\n\tif (len == 0)\n\t    break;\n\twhat = undo_read_byte(bi);\n\tswitch (what)\n\t{\n\t    case UHP_SAVE_NR:\n\t\tuhp->uh_save_nr = undo_read_4c(bi);\n\t\tbreak;\n\t    default:\n\t\t/* field not supported, skip */\n\t\twhile (--len >= 0)\n\t\t    (void)undo_read_byte(bi);\n\t}\n    }\n\n    /* Unserialize the uep list. */\n    last_uep = NULL;\n    while ((c = undo_read_2c(bi)) == UF_ENTRY_MAGIC)\n    {\n\terror = FALSE;\n\tuep = unserialize_uep(bi, &error, file_name);\n\tif (last_uep == NULL)\n\t    uhp->uh_entry = uep;\n\telse\n\t    last_uep->ue_next = uep;\n\tlast_uep = uep;\n\tif (uep == NULL || error)\n\t{\n\t    u_free_uhp(uhp);\n\t    return NULL;\n\t}\n    }\n    if (c != UF_ENTRY_END_MAGIC)\n    {\n\tcorruption_error(\"entry end\", file_name);\n\tu_free_uhp(uhp);\n\treturn NULL;\n    }\n\n    return uhp;\n}\n\n/*\n * Serialize \"uep\".\n */\n    static int\nserialize_uep(\n    bufinfo_T\t*bi,\n    u_entry_T\t*uep)\n{\n    int\t\ti;\n    size_t\tlen;\n\n    undo_write_bytes(bi, (long_u)uep->ue_top, 4);\n    undo_write_bytes(bi, (long_u)uep->ue_bot, 4);\n    undo_write_bytes(bi, (long_u)uep->ue_lcount, 4);\n    undo_write_bytes(bi, (long_u)uep->ue_size, 4);\n    for (i = 0; i < uep->ue_size; ++i)\n    {\n\tlen = STRLEN(uep->ue_array[i]);\n\tif (undo_write_bytes(bi, (long_u)len, 4) == FAIL)\n\t    return FAIL;\n\tif (len > 0 && fwrite_crypt(bi, uep->ue_array[i], len) == FAIL)\n\t    return FAIL;\n    }\n    return OK;\n}\n\n    static u_entry_T *\nunserialize_uep(bufinfo_T *bi, int *error, char_u *file_name)\n{\n    int\t\ti;\n    u_entry_T\t*uep;\n    char_u\t**array;\n    char_u\t*line;\n    int\t\tline_len;\n\n    uep = (u_entry_T *)U_ALLOC_LINE(sizeof(u_entry_T));\n    if (uep == NULL)\n\treturn NULL;\n    vim_memset(uep, 0, sizeof(u_entry_T));\n#ifdef U_DEBUG\n    uep->ue_magic = UE_MAGIC;\n#endif\n    uep->ue_top = undo_read_4c(bi);\n    uep->ue_bot = undo_read_4c(bi);\n    uep->ue_lcount = undo_read_4c(bi);\n    uep->ue_size = undo_read_4c(bi);\n    if (uep->ue_size > 0)\n    {\n\tarray = (char_u **)U_ALLOC_LINE(sizeof(char_u *) * uep->ue_size);\n\tif (array == NULL)\n\t{\n\t    *error = TRUE;\n\t    return uep;\n\t}\n\tvim_memset(array, 0, sizeof(char_u *) * uep->ue_size);\n    }\n    else\n\tarray = NULL;\n    uep->ue_array = array;\n\n    for (i = 0; i < uep->ue_size; ++i)\n    {\n\tline_len = undo_read_4c(bi);\n\tif (line_len >= 0)\n\t    line = read_string_decrypt(bi, line_len);\n\telse\n\t{\n\t    line = NULL;\n\t    corruption_error(\"line length\", file_name);\n\t}\n\tif (line == NULL)\n\t{\n\t    *error = TRUE;\n\t    return uep;\n\t}\n\tarray[i] = line;\n    }\n    return uep;\n}\n\n/*\n * Serialize \"pos\".\n */\n    static void\nserialize_pos(bufinfo_T *bi, pos_T pos)\n{\n    undo_write_bytes(bi, (long_u)pos.lnum, 4);\n    undo_write_bytes(bi, (long_u)pos.col, 4);\n#ifdef FEAT_VIRTUALEDIT\n    undo_write_bytes(bi, (long_u)pos.coladd, 4);\n#else\n    undo_write_bytes(bi, (long_u)0, 4);\n#endif\n}\n\n/*\n * Unserialize the pos_T at the current position.\n */\n    static void\nunserialize_pos(bufinfo_T *bi, pos_T *pos)\n{\n    pos->lnum = undo_read_4c(bi);\n    if (pos->lnum < 0)\n\tpos->lnum = 0;\n    pos->col = undo_read_4c(bi);\n    if (pos->col < 0)\n\tpos->col = 0;\n#ifdef FEAT_VIRTUALEDIT\n    pos->coladd = undo_read_4c(bi);\n    if (pos->coladd < 0)\n\tpos->coladd = 0;\n#else\n    (void)undo_read_4c(bi);\n#endif\n}\n\n/*\n * Serialize \"info\".\n */\n    static void\nserialize_visualinfo(bufinfo_T *bi, visualinfo_T *info)\n{\n    serialize_pos(bi, info->vi_start);\n    serialize_pos(bi, info->vi_end);\n    undo_write_bytes(bi, (long_u)info->vi_mode, 4);\n    undo_write_bytes(bi, (long_u)info->vi_curswant, 4);\n}\n\n/*\n * Unserialize the visualinfo_T at the current position.\n */\n    static void\nunserialize_visualinfo(bufinfo_T *bi, visualinfo_T *info)\n{\n    unserialize_pos(bi, &info->vi_start);\n    unserialize_pos(bi, &info->vi_end);\n    info->vi_mode = undo_read_4c(bi);\n    info->vi_curswant = undo_read_4c(bi);\n}\n\n/*\n * Write the undo tree in an undo file.\n * When \"name\" is not NULL, use it as the name of the undo file.\n * Otherwise use buf->b_ffname to generate the undo file name.\n * \"buf\" must never be null, buf->b_ffname is used to obtain the original file\n * permissions.\n * \"forceit\" is TRUE for \":wundo!\", FALSE otherwise.\n * \"hash[UNDO_HASH_SIZE]\" must be the hash value of the buffer text.\n */\n    void\nu_write_undo(\n    char_u\t*name,\n    int\t\tforceit,\n    buf_T\t*buf,\n    char_u\t*hash)\n{\n    u_header_T\t*uhp;\n    char_u\t*file_name;\n    int\t\tmark;\n#ifdef U_DEBUG\n    int\t\theaders_written = 0;\n#endif\n    int\t\tfd;\n    FILE\t*fp = NULL;\n    int\t\tperm;\n    int\t\twrite_ok = FALSE;\n#ifdef UNIX\n    int\t\tst_old_valid = FALSE;\n    stat_T\tst_old;\n    stat_T\tst_new;\n#endif\n    bufinfo_T\tbi;\n\n    vim_memset(&bi, 0, sizeof(bi));\n\n    if (name == NULL)\n    {\n\tfile_name = u_get_undo_file_name(buf->b_ffname, FALSE);\n\tif (file_name == NULL)\n\t{\n\t    if (p_verbose > 0)\n\t    {\n\t\tverbose_enter();\n\t\tsmsg((char_u *)\n\t\t   _(\"Cannot write undo file in any directory in 'undodir'\"));\n\t\tverbose_leave();\n\t    }\n\t    return;\n\t}\n    }\n    else\n\tfile_name = name;\n\n    /*\n     * Decide about the permission to use for the undo file.  If the buffer\n     * has a name use the permission of the original file.  Otherwise only\n     * allow the user to access the undo file.\n     */\n    perm = 0600;\n    if (buf->b_ffname != NULL)\n    {\n#ifdef UNIX\n\tif (mch_stat((char *)buf->b_ffname, &st_old) >= 0)\n\t{\n\t    perm = st_old.st_mode;\n\t    st_old_valid = TRUE;\n\t}\n#else\n\tperm = mch_getperm(buf->b_ffname);\n\tif (perm < 0)\n\t    perm = 0600;\n#endif\n    }\n\n    /* strip any s-bit and executable bit */\n    perm = perm & 0666;\n\n    /* If the undo file already exists, verify that it actually is an undo\n     * file, and delete it. */\n    if (mch_getperm(file_name) >= 0)\n    {\n\tif (name == NULL || !forceit)\n\t{\n\t    /* Check we can read it and it's an undo file. */\n\t    fd = mch_open((char *)file_name, O_RDONLY|O_EXTRA, 0);\n\t    if (fd < 0)\n\t    {\n\t\tif (name != NULL || p_verbose > 0)\n\t\t{\n\t\t    if (name == NULL)\n\t\t\tverbose_enter();\n\t\t    smsg((char_u *)\n\t\t      _(\"Will not overwrite with undo file, cannot read: %s\"),\n\t\t\t\t\t\t\t\t   file_name);\n\t\t    if (name == NULL)\n\t\t\tverbose_leave();\n\t\t}\n\t\tgoto theend;\n\t    }\n\t    else\n\t    {\n\t\tchar_u\tmbuf[UF_START_MAGIC_LEN];\n\t\tint\tlen;\n\n\t\tlen = read_eintr(fd, mbuf, UF_START_MAGIC_LEN);\n\t\tclose(fd);\n\t\tif (len < UF_START_MAGIC_LEN\n\t\t      || memcmp(mbuf, UF_START_MAGIC, UF_START_MAGIC_LEN) != 0)\n\t\t{\n\t\t    if (name != NULL || p_verbose > 0)\n\t\t    {\n\t\t\tif (name == NULL)\n\t\t\t    verbose_enter();\n\t\t\tsmsg((char_u *)\n\t\t\t_(\"Will not overwrite, this is not an undo file: %s\"),\n\t\t\t\t\t\t\t\t   file_name);\n\t\t\tif (name == NULL)\n\t\t\t    verbose_leave();\n\t\t    }\n\t\t    goto theend;\n\t\t}\n\t    }\n\t}\n\tmch_remove(file_name);\n    }\n\n    /* If there is no undo information at all, quit here after deleting any\n     * existing undo file. */\n    if (buf->b_u_numhead == 0 && buf->b_u_line_ptr == NULL)\n    {\n\tif (p_verbose > 0)\n\t    verb_msg((char_u *)_(\"Skipping undo file write, nothing to undo\"));\n\tgoto theend;\n    }\n\n    fd = mch_open((char *)file_name,\n\t\t\t    O_CREAT|O_EXTRA|O_WRONLY|O_EXCL|O_NOFOLLOW, perm);\n    if (fd < 0)\n    {\n\tEMSG2(_(e_not_open), file_name);\n\tgoto theend;\n    }\n    (void)mch_setperm(file_name, perm);\n    if (p_verbose > 0)\n    {\n\tverbose_enter();\n\tsmsg((char_u *)_(\"Writing undo file: %s\"), file_name);\n\tverbose_leave();\n    }\n\n#ifdef U_DEBUG\n    /* Check there is no problem in undo info before writing. */\n    u_check(FALSE);\n#endif\n\n#ifdef UNIX\n    /*\n     * Try to set the group of the undo file same as the original file. If\n     * this fails, set the protection bits for the group same as the\n     * protection bits for others.\n     */\n    if (st_old_valid\n\t    && mch_stat((char *)file_name, &st_new) >= 0\n\t    && st_new.st_gid != st_old.st_gid\n# ifdef HAVE_FCHOWN  /* sequent-ptx lacks fchown() */\n\t    && fchown(fd, (uid_t)-1, st_old.st_gid) != 0\n# endif\n       )\n\tmch_setperm(file_name, (perm & 0707) | ((perm & 07) << 3));\n# if defined(HAVE_SELINUX) || defined(HAVE_SMACK)\n    if (buf->b_ffname != NULL)\n\tmch_copy_sec(buf->b_ffname, file_name);\n# endif\n#endif\n\n    fp = fdopen(fd, \"w\");\n    if (fp == NULL)\n    {\n\tEMSG2(_(e_not_open), file_name);\n\tclose(fd);\n\tmch_remove(file_name);\n\tgoto theend;\n    }\n\n    /* Undo must be synced. */\n    u_sync(TRUE);\n\n    /*\n     * Write the header.  Initializes encryption, if enabled.\n     */\n    bi.bi_buf = buf;\n    bi.bi_fp = fp;\n    if (serialize_header(&bi, hash) == FAIL)\n\tgoto write_error;\n\n    /*\n     * Iteratively serialize UHPs and their UEPs from the top down.\n     */\n    mark = ++lastmark;\n    uhp = buf->b_u_oldhead;\n    while (uhp != NULL)\n    {\n\t/* Serialize current UHP if we haven't seen it */\n\tif (uhp->uh_walk != mark)\n\t{\n\t    uhp->uh_walk = mark;\n#ifdef U_DEBUG\n\t    ++headers_written;\n#endif\n\t    if (serialize_uhp(&bi, uhp) == FAIL)\n\t\tgoto write_error;\n\t}\n\n\t/* Now walk through the tree - algorithm from undo_time(). */\n\tif (uhp->uh_prev.ptr != NULL && uhp->uh_prev.ptr->uh_walk != mark)\n\t    uhp = uhp->uh_prev.ptr;\n\telse if (uhp->uh_alt_next.ptr != NULL\n\t\t\t\t     && uhp->uh_alt_next.ptr->uh_walk != mark)\n\t    uhp = uhp->uh_alt_next.ptr;\n\telse if (uhp->uh_next.ptr != NULL && uhp->uh_alt_prev.ptr == NULL\n\t\t\t\t\t && uhp->uh_next.ptr->uh_walk != mark)\n\t    uhp = uhp->uh_next.ptr;\n\telse if (uhp->uh_alt_prev.ptr != NULL)\n\t    uhp = uhp->uh_alt_prev.ptr;\n\telse\n\t    uhp = uhp->uh_next.ptr;\n    }\n\n    if (undo_write_bytes(&bi, (long_u)UF_HEADER_END_MAGIC, 2) == OK)\n\twrite_ok = TRUE;\n#ifdef U_DEBUG\n    if (headers_written != buf->b_u_numhead)\n    {\n\tEMSGN(\"Written %ld headers, ...\", headers_written);\n\tEMSGN(\"... but numhead is %ld\", buf->b_u_numhead);\n    }\n#endif\n\n#ifdef FEAT_CRYPT\n    if (bi.bi_state != NULL && undo_flush(&bi) == FAIL)\n\twrite_ok = FALSE;\n#endif\n\nwrite_error:\n    fclose(fp);\n    if (!write_ok)\n\tEMSG2(_(\"E829: write error in undo file: %s\"), file_name);\n\n#if defined(MACOS_CLASSIC) || defined(WIN3264)\n    /* Copy file attributes; for systems where this can only be done after\n     * closing the file. */\n    if (buf->b_ffname != NULL)\n\t(void)mch_copy_file_attribute(buf->b_ffname, file_name);\n#endif\n#ifdef HAVE_ACL\n    if (buf->b_ffname != NULL)\n    {\n\tvim_acl_T\t    acl;\n\n\t/* For systems that support ACL: get the ACL from the original file. */\n\tacl = mch_get_acl(buf->b_ffname);\n\tmch_set_acl(file_name, acl);\n\tmch_free_acl(acl);\n    }\n#endif\n\ntheend:\n#ifdef FEAT_CRYPT\n    if (bi.bi_state != NULL)\n\tcrypt_free_state(bi.bi_state);\n    vim_free(bi.bi_buffer);\n#endif\n    if (file_name != name)\n\tvim_free(file_name);\n}\n\n/*\n * Load the undo tree from an undo file.\n * If \"name\" is not NULL use it as the undo file name.  This also means being\n * a bit more verbose.\n * Otherwise use curbuf->b_ffname to generate the undo file name.\n * \"hash[UNDO_HASH_SIZE]\" must be the hash value of the buffer text.\n */\n    void\nu_read_undo(char_u *name, char_u *hash, char_u *orig_name)\n{\n    char_u\t*file_name;\n    FILE\t*fp;\n    long\tversion, str_len;\n    char_u\t*line_ptr = NULL;\n    linenr_T\tline_lnum;\n    colnr_T\tline_colnr;\n    linenr_T\tline_count;\n    long\tnum_head = 0;\n    long\told_header_seq, new_header_seq, cur_header_seq;\n    long\tseq_last, seq_cur;\n    long\tlast_save_nr = 0;\n    short\told_idx = -1, new_idx = -1, cur_idx = -1;\n    long\tnum_read_uhps = 0;\n    time_t\tseq_time;\n    int\t\ti, j;\n    int\t\tc;\n    u_header_T\t*uhp;\n    u_header_T\t**uhp_table = NULL;\n    char_u\tread_hash[UNDO_HASH_SIZE];\n    char_u\tmagic_buf[UF_START_MAGIC_LEN];\n#ifdef U_DEBUG\n    int\t\t*uhp_table_used;\n#endif\n#ifdef UNIX\n    stat_T\tst_orig;\n    stat_T\tst_undo;\n#endif\n    bufinfo_T\tbi;\n\n    vim_memset(&bi, 0, sizeof(bi));\n    if (name == NULL)\n    {\n\tfile_name = u_get_undo_file_name(curbuf->b_ffname, TRUE);\n\tif (file_name == NULL)\n\t    return;\n\n#ifdef UNIX\n\t/* For safety we only read an undo file if the owner is equal to the\n\t * owner of the text file or equal to the current user. */\n\tif (mch_stat((char *)orig_name, &st_orig) >= 0\n\t\t&& mch_stat((char *)file_name, &st_undo) >= 0\n\t\t&& st_orig.st_uid != st_undo.st_uid\n\t\t&& st_undo.st_uid != getuid())\n\t{\n\t    if (p_verbose > 0)\n\t    {\n\t\tverbose_enter();\n\t\tsmsg((char_u *)_(\"Not reading undo file, owner differs: %s\"),\n\t\t\t\t\t\t\t\t   file_name);\n\t\tverbose_leave();\n\t    }\n\t    return;\n\t}\n#endif\n    }\n    else\n\tfile_name = name;\n\n    if (p_verbose > 0)\n    {\n\tverbose_enter();\n\tsmsg((char_u *)_(\"Reading undo file: %s\"), file_name);\n\tverbose_leave();\n    }\n\n    fp = mch_fopen((char *)file_name, \"r\");\n    if (fp == NULL)\n    {\n\tif (name != NULL || p_verbose > 0)\n\t    EMSG2(_(\"E822: Cannot open undo file for reading: %s\"), file_name);\n\tgoto error;\n    }\n    bi.bi_buf = curbuf;\n    bi.bi_fp = fp;\n\n    /*\n     * Read the undo file header.\n     */\n    if (fread(magic_buf, UF_START_MAGIC_LEN, 1, fp) != 1\n\t\t|| memcmp(magic_buf, UF_START_MAGIC, UF_START_MAGIC_LEN) != 0)\n    {\n\tEMSG2(_(\"E823: Not an undo file: %s\"), file_name);\n\tgoto error;\n    }\n    version = get2c(fp);\n    if (version == UF_VERSION_CRYPT)\n    {\n#ifdef FEAT_CRYPT\n\tif (*curbuf->b_p_key == NUL)\n\t{\n\t    EMSG2(_(\"E832: Non-encrypted file has encrypted undo file: %s\"),\n\t\t\t\t\t\t\t\t   file_name);\n\t    goto error;\n\t}\n\tbi.bi_state = crypt_create_from_file(fp, curbuf->b_p_key);\n\tif (bi.bi_state == NULL)\n\t{\n\t    EMSG2(_(\"E826: Undo file decryption failed: %s\"), file_name);\n\t    goto error;\n\t}\n\tif (crypt_whole_undofile(bi.bi_state->method_nr))\n\t{\n\t    bi.bi_buffer = alloc(CRYPT_BUF_SIZE);\n\t    if (bi.bi_buffer == NULL)\n\t    {\n\t\tcrypt_free_state(bi.bi_state);\n\t\tbi.bi_state = NULL;\n\t\tgoto error;\n\t    }\n\t    bi.bi_avail = 0;\n\t    bi.bi_used = 0;\n\t}\n#else\n\tEMSG2(_(\"E827: Undo file is encrypted: %s\"), file_name);\n\tgoto error;\n#endif\n    }\n    else if (version != UF_VERSION)\n    {\n\tEMSG2(_(\"E824: Incompatible undo file: %s\"), file_name);\n\tgoto error;\n    }\n\n    if (undo_read(&bi, read_hash, (size_t)UNDO_HASH_SIZE) == FAIL)\n    {\n\tcorruption_error(\"hash\", file_name);\n\tgoto error;\n    }\n    line_count = (linenr_T)undo_read_4c(&bi);\n    if (memcmp(hash, read_hash, UNDO_HASH_SIZE) != 0\n\t\t\t\t  || line_count != curbuf->b_ml.ml_line_count)\n    {\n\tif (p_verbose > 0 || name != NULL)\n\t{\n\t    if (name == NULL)\n\t\tverbose_enter();\n\t    give_warning((char_u *)\n\t\t      _(\"File contents changed, cannot use undo info\"), TRUE);\n\t    if (name == NULL)\n\t\tverbose_leave();\n\t}\n\tgoto error;\n    }\n\n    /* Read undo data for \"U\" command. */\n    str_len = undo_read_4c(&bi);\n    if (str_len < 0)\n\tgoto error;\n    if (str_len > 0)\n\tline_ptr = read_string_decrypt(&bi, str_len);\n    line_lnum = (linenr_T)undo_read_4c(&bi);\n    line_colnr = (colnr_T)undo_read_4c(&bi);\n    if (line_lnum < 0 || line_colnr < 0)\n    {\n\tcorruption_error(\"line lnum/col\", file_name);\n\tgoto error;\n    }\n\n    /* Begin general undo data */\n    old_header_seq = undo_read_4c(&bi);\n    new_header_seq = undo_read_4c(&bi);\n    cur_header_seq = undo_read_4c(&bi);\n    num_head = undo_read_4c(&bi);\n    seq_last = undo_read_4c(&bi);\n    seq_cur = undo_read_4c(&bi);\n    seq_time = undo_read_time(&bi);\n\n    /* Optional header fields. */\n    for (;;)\n    {\n\tint len = undo_read_byte(&bi);\n\tint what;\n\n\tif (len == 0 || len == EOF)\n\t    break;\n\twhat = undo_read_byte(&bi);\n\tswitch (what)\n\t{\n\t    case UF_LAST_SAVE_NR:\n\t\tlast_save_nr = undo_read_4c(&bi);\n\t\tbreak;\n\t    default:\n\t\t/* field not supported, skip */\n\t\twhile (--len >= 0)\n\t\t    (void)undo_read_byte(&bi);\n\t}\n    }\n\n    /* uhp_table will store the freshly created undo headers we allocate\n     * until we insert them into curbuf. The table remains sorted by the\n     * sequence numbers of the headers.\n     * When there are no headers uhp_table is NULL. */\n    if (num_head > 0)\n    {\n\tif (num_head < LONG_MAX / (long)sizeof(u_header_T *))\n\t    uhp_table = (u_header_T **)U_ALLOC_LINE(\n\t\t\t\t\t     num_head * sizeof(u_header_T *));\n\tif (uhp_table == NULL)\n\t    goto error;\n    }\n\n    while ((c = undo_read_2c(&bi)) == UF_HEADER_MAGIC)\n    {\n\tif (num_read_uhps >= num_head)\n\t{\n\t    corruption_error(\"num_head too small\", file_name);\n\t    goto error;\n\t}\n\n\tuhp = unserialize_uhp(&bi, file_name);\n\tif (uhp == NULL)\n\t    goto error;\n\tuhp_table[num_read_uhps++] = uhp;\n    }\n\n    if (num_read_uhps != num_head)\n    {\n\tcorruption_error(\"num_head\", file_name);\n\tgoto error;\n    }\n    if (c != UF_HEADER_END_MAGIC)\n    {\n\tcorruption_error(\"end marker\", file_name);\n\tgoto error;\n    }\n\n#ifdef U_DEBUG\n    uhp_table_used = (int *)alloc_clear(\n\t\t\t\t     (unsigned)(sizeof(int) * num_head + 1));\n# define SET_FLAG(j) ++uhp_table_used[j]\n#else\n# define SET_FLAG(j)\n#endif\n\n    /* We have put all of the headers into a table. Now we iterate through the\n     * table and swizzle each sequence number we have stored in uh_*_seq into\n     * a pointer corresponding to the header with that sequence number. */\n    for (i = 0; i < num_head; i++)\n    {\n\tuhp = uhp_table[i];\n\tif (uhp == NULL)\n\t    continue;\n\tfor (j = 0; j < num_head; j++)\n\t    if (uhp_table[j] != NULL && i != j\n\t\t\t      && uhp_table[i]->uh_seq == uhp_table[j]->uh_seq)\n\t    {\n\t\tcorruption_error(\"duplicate uh_seq\", file_name);\n\t\tgoto error;\n\t    }\n\tfor (j = 0; j < num_head; j++)\n\t    if (uhp_table[j] != NULL\n\t\t\t\t  && uhp_table[j]->uh_seq == uhp->uh_next.seq)\n\t    {\n\t\tuhp->uh_next.ptr = uhp_table[j];\n\t\tSET_FLAG(j);\n\t\tbreak;\n\t    }\n\tfor (j = 0; j < num_head; j++)\n\t    if (uhp_table[j] != NULL\n\t\t\t\t  && uhp_table[j]->uh_seq == uhp->uh_prev.seq)\n\t    {\n\t\tuhp->uh_prev.ptr = uhp_table[j];\n\t\tSET_FLAG(j);\n\t\tbreak;\n\t    }\n\tfor (j = 0; j < num_head; j++)\n\t    if (uhp_table[j] != NULL\n\t\t\t      && uhp_table[j]->uh_seq == uhp->uh_alt_next.seq)\n\t    {\n\t\tuhp->uh_alt_next.ptr = uhp_table[j];\n\t\tSET_FLAG(j);\n\t\tbreak;\n\t    }\n\tfor (j = 0; j < num_head; j++)\n\t    if (uhp_table[j] != NULL\n\t\t\t      && uhp_table[j]->uh_seq == uhp->uh_alt_prev.seq)\n\t    {\n\t\tuhp->uh_alt_prev.ptr = uhp_table[j];\n\t\tSET_FLAG(j);\n\t\tbreak;\n\t    }\n\tif (old_header_seq > 0 && old_idx < 0 && uhp->uh_seq == old_header_seq)\n\t{\n\t    old_idx = i;\n\t    SET_FLAG(i);\n\t}\n\tif (new_header_seq > 0 && new_idx < 0 && uhp->uh_seq == new_header_seq)\n\t{\n\t    new_idx = i;\n\t    SET_FLAG(i);\n\t}\n\tif (cur_header_seq > 0 && cur_idx < 0 && uhp->uh_seq == cur_header_seq)\n\t{\n\t    cur_idx = i;\n\t    SET_FLAG(i);\n\t}\n    }\n\n    /* Now that we have read the undo info successfully, free the current undo\n     * info and use the info from the file. */\n    u_blockfree(curbuf);\n    curbuf->b_u_oldhead = old_idx < 0 ? NULL : uhp_table[old_idx];\n    curbuf->b_u_newhead = new_idx < 0 ? NULL : uhp_table[new_idx];\n    curbuf->b_u_curhead = cur_idx < 0 ? NULL : uhp_table[cur_idx];\n    curbuf->b_u_line_ptr = line_ptr;\n    curbuf->b_u_line_lnum = line_lnum;\n    curbuf->b_u_line_colnr = line_colnr;\n    curbuf->b_u_numhead = num_head;\n    curbuf->b_u_seq_last = seq_last;\n    curbuf->b_u_seq_cur = seq_cur;\n    curbuf->b_u_time_cur = seq_time;\n    curbuf->b_u_save_nr_last = last_save_nr;\n    curbuf->b_u_save_nr_cur = last_save_nr;\n\n    curbuf->b_u_synced = TRUE;\n    vim_free(uhp_table);\n\n#ifdef U_DEBUG\n    for (i = 0; i < num_head; ++i)\n\tif (uhp_table_used[i] == 0)\n\t    EMSGN(\"uhp_table entry %ld not used, leaking memory\", i);\n    vim_free(uhp_table_used);\n    u_check(TRUE);\n#endif\n\n    if (name != NULL)\n\tsmsg((char_u *)_(\"Finished reading undo file %s\"), file_name);\n    goto theend;\n\nerror:\n    vim_free(line_ptr);\n    if (uhp_table != NULL)\n    {\n\tfor (i = 0; i < num_read_uhps; i++)\n\t    if (uhp_table[i] != NULL)\n\t\tu_free_uhp(uhp_table[i]);\n\tvim_free(uhp_table);\n    }\n\ntheend:\n#ifdef FEAT_CRYPT\n    if (bi.bi_state != NULL)\n\tcrypt_free_state(bi.bi_state);\n    vim_free(bi.bi_buffer);\n#endif\n    if (fp != NULL)\n\tfclose(fp);\n    if (file_name != name)\n\tvim_free(file_name);\n    return;\n}\n\n#endif /* FEAT_PERSISTENT_UNDO */\n\n\n/*\n * If 'cpoptions' contains 'u': Undo the previous undo or redo (vi compatible).\n * If 'cpoptions' does not contain 'u': Always undo.\n */\n    void\nu_undo(int count)\n{\n    /*\n     * If we get an undo command while executing a macro, we behave like the\n     * original vi. If this happens twice in one macro the result will not\n     * be compatible.\n     */\n    if (curbuf->b_u_synced == FALSE)\n    {\n\tu_sync(TRUE);\n\tcount = 1;\n    }\n\n    if (vim_strchr(p_cpo, CPO_UNDO) == NULL)\n\tundo_undoes = TRUE;\n    else\n\tundo_undoes = !undo_undoes;\n    u_doit(count);\n}\n\n/*\n * If 'cpoptions' contains 'u': Repeat the previous undo or redo.\n * If 'cpoptions' does not contain 'u': Always redo.\n */\n    void\nu_redo(int count)\n{\n    if (vim_strchr(p_cpo, CPO_UNDO) == NULL)\n\tundo_undoes = FALSE;\n    u_doit(count);\n}\n\n/*\n * Undo or redo, depending on 'undo_undoes', 'count' times.\n */\n    static void\nu_doit(int startcount)\n{\n    int count = startcount;\n\n    if (!undo_allowed())\n\treturn;\n\n    u_newcount = 0;\n    u_oldcount = 0;\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\tu_oldcount = -1;\n    while (count--)\n    {\n\t/* Do the change warning now, so that it triggers FileChangedRO when\n\t * needed.  This may cause the file to be reloaded, that must happen\n\t * before we do anything, because it may change curbuf->b_u_curhead\n\t * and more. */\n\tchange_warning(0);\n\n\tif (undo_undoes)\n\t{\n\t    if (curbuf->b_u_curhead == NULL)\t\t/* first undo */\n\t\tcurbuf->b_u_curhead = curbuf->b_u_newhead;\n\t    else if (get_undolevel() > 0)\t\t/* multi level undo */\n\t\t/* get next undo */\n\t\tcurbuf->b_u_curhead = curbuf->b_u_curhead->uh_next.ptr;\n\t    /* nothing to undo */\n\t    if (curbuf->b_u_numhead == 0 || curbuf->b_u_curhead == NULL)\n\t    {\n\t\t/* stick curbuf->b_u_curhead at end */\n\t\tcurbuf->b_u_curhead = curbuf->b_u_oldhead;\n\t\tbeep_flush();\n\t\tif (count == startcount - 1)\n\t\t{\n\t\t    MSG(_(\"Already at oldest change\"));\n\t\t    return;\n\t\t}\n\t\tbreak;\n\t    }\n\n\t    u_undoredo(TRUE);\n\t}\n\telse\n\t{\n\t    if (curbuf->b_u_curhead == NULL || get_undolevel() <= 0)\n\t    {\n\t\tbeep_flush();\t/* nothing to redo */\n\t\tif (count == startcount - 1)\n\t\t{\n\t\t    MSG(_(\"Already at newest change\"));\n\t\t    return;\n\t\t}\n\t\tbreak;\n\t    }\n\n\t    u_undoredo(FALSE);\n\n\t    /* Advance for next redo.  Set \"newhead\" when at the end of the\n\t     * redoable changes. */\n\t    if (curbuf->b_u_curhead->uh_prev.ptr == NULL)\n\t\tcurbuf->b_u_newhead = curbuf->b_u_curhead;\n\t    curbuf->b_u_curhead = curbuf->b_u_curhead->uh_prev.ptr;\n\t}\n    }\n    u_undo_end(undo_undoes, FALSE);\n}\n\n/*\n * Undo or redo over the timeline.\n * When \"step\" is negative go back in time, otherwise goes forward in time.\n * When \"sec\" is FALSE make \"step\" steps, when \"sec\" is TRUE use \"step\" as\n * seconds.\n * When \"file\" is TRUE use \"step\" as a number of file writes.\n * When \"absolute\" is TRUE use \"step\" as the sequence number to jump to.\n * \"sec\" must be FALSE then.\n */\n    void\nundo_time(\n    long\tstep,\n    int\t\tsec,\n    int\t\tfile,\n    int\t\tabsolute)\n{\n    long\t    target;\n    long\t    closest;\n    long\t    closest_start;\n    long\t    closest_seq = 0;\n    long\t    val;\n    u_header_T\t    *uhp;\n    u_header_T\t    *last;\n    int\t\t    mark;\n    int\t\t    nomark;\n    int\t\t    round;\n    int\t\t    dosec = sec;\n    int\t\t    dofile = file;\n    int\t\t    above = FALSE;\n    int\t\t    did_undo = TRUE;\n\n    /* First make sure the current undoable change is synced. */\n    if (curbuf->b_u_synced == FALSE)\n\tu_sync(TRUE);\n\n    u_newcount = 0;\n    u_oldcount = 0;\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\tu_oldcount = -1;\n\n    /* \"target\" is the node below which we want to be.\n     * Init \"closest\" to a value we can't reach. */\n    if (absolute)\n    {\n\tif (step == 0)\n\t{\n\t    /* target 0 does not exist, got to 1 and above it. */\n\t    target = 1;\n\t    above = TRUE;\n\t}\n\telse\n\t    target = step;\n\tclosest = -1;\n    }\n    else\n    {\n\tif (dosec)\n\t    target = (long)(curbuf->b_u_time_cur) + step;\n\telse if (dofile)\n\t{\n\t    if (step < 0)\n\t    {\n\t\t/* Going back to a previous write. If there were changes after\n\t\t * the last write, count that as moving one file-write, so\n\t\t * that \":earlier 1f\" undoes all changes since the last save. */\n\t\tuhp = curbuf->b_u_curhead;\n\t\tif (uhp != NULL)\n\t\t    uhp = uhp->uh_next.ptr;\n\t\telse\n\t\t    uhp = curbuf->b_u_newhead;\n\t\tif (uhp != NULL && uhp->uh_save_nr != 0)\n\t\t    /* \"uh_save_nr\" was set in the last block, that means\n\t\t     * there were no changes since the last write */\n\t\t    target = curbuf->b_u_save_nr_cur + step;\n\t\telse\n\t\t    /* count the changes since the last write as one step */\n\t\t    target = curbuf->b_u_save_nr_cur + step + 1;\n\t\tif (target <= 0)\n\t\t    /* Go to before first write: before the oldest change. Use\n\t\t     * the sequence number for that. */\n\t\t    dofile = FALSE;\n\t    }\n\t    else\n\t    {\n\t\t/* Moving forward to a newer write. */\n\t\ttarget = curbuf->b_u_save_nr_cur + step;\n\t\tif (target > curbuf->b_u_save_nr_last)\n\t\t{\n\t\t    /* Go to after last write: after the latest change. Use\n\t\t     * the sequence number for that. */\n\t\t    target = curbuf->b_u_seq_last + 1;\n\t\t    dofile = FALSE;\n\t\t}\n\t    }\n\t}\n\telse\n\t    target = curbuf->b_u_seq_cur + step;\n\tif (step < 0)\n\t{\n\t    if (target < 0)\n\t\ttarget = 0;\n\t    closest = -1;\n\t}\n\telse\n\t{\n\t    if (dosec)\n\t\tclosest = (long)(vim_time() + 1);\n\t    else if (dofile)\n\t\tclosest = curbuf->b_u_save_nr_last + 2;\n\t    else\n\t\tclosest = curbuf->b_u_seq_last + 2;\n\t    if (target >= closest)\n\t\ttarget = closest - 1;\n\t}\n    }\n    closest_start = closest;\n    closest_seq = curbuf->b_u_seq_cur;\n\n    /*\n     * May do this twice:\n     * 1. Search for \"target\", update \"closest\" to the best match found.\n     * 2. If \"target\" not found search for \"closest\".\n     *\n     * When using the closest time we use the sequence number in the second\n     * round, because there may be several entries with the same time.\n     */\n    for (round = 1; round <= 2; ++round)\n    {\n\t/* Find the path from the current state to where we want to go.  The\n\t * desired state can be anywhere in the undo tree, need to go all over\n\t * it.  We put \"nomark\" in uh_walk where we have been without success,\n\t * \"mark\" where it could possibly be. */\n\tmark = ++lastmark;\n\tnomark = ++lastmark;\n\n\tif (curbuf->b_u_curhead == NULL)\t/* at leaf of the tree */\n\t    uhp = curbuf->b_u_newhead;\n\telse\n\t    uhp = curbuf->b_u_curhead;\n\n\twhile (uhp != NULL)\n\t{\n\t    uhp->uh_walk = mark;\n\t    if (dosec)\n\t\tval = (long)(uhp->uh_time);\n\t    else if (dofile)\n\t\tval = uhp->uh_save_nr;\n\t    else\n\t\tval = uhp->uh_seq;\n\n\t    if (round == 1 && !(dofile && val == 0))\n\t    {\n\t\t/* Remember the header that is closest to the target.\n\t\t * It must be at least in the right direction (checked with\n\t\t * \"b_u_seq_cur\").  When the timestamp is equal find the\n\t\t * highest/lowest sequence number. */\n\t\tif ((step < 0 ? uhp->uh_seq <= curbuf->b_u_seq_cur\n\t\t\t      : uhp->uh_seq > curbuf->b_u_seq_cur)\n\t\t\t&& ((dosec && val == closest)\n\t\t\t    ? (step < 0\n\t\t\t\t? uhp->uh_seq < closest_seq\n\t\t\t\t: uhp->uh_seq > closest_seq)\n\t\t\t    : closest == closest_start\n\t\t\t\t|| (val > target\n\t\t\t\t    ? (closest > target\n\t\t\t\t\t? val - target <= closest - target\n\t\t\t\t\t: val - target <= target - closest)\n\t\t\t\t    : (closest > target\n\t\t\t\t\t? target - val <= closest - target\n\t\t\t\t\t: target - val <= target - closest))))\n\t\t{\n\t\t    closest = val;\n\t\t    closest_seq = uhp->uh_seq;\n\t\t}\n\t    }\n\n\t    /* Quit searching when we found a match.  But when searching for a\n\t     * time we need to continue looking for the best uh_seq. */\n\t    if (target == val && !dosec)\n\t    {\n\t\ttarget = uhp->uh_seq;\n\t\tbreak;\n\t    }\n\n\t    /* go down in the tree if we haven't been there */\n\t    if (uhp->uh_prev.ptr != NULL && uhp->uh_prev.ptr->uh_walk != nomark\n\t\t\t\t\t && uhp->uh_prev.ptr->uh_walk != mark)\n\t\tuhp = uhp->uh_prev.ptr;\n\n\t    /* go to alternate branch if we haven't been there */\n\t    else if (uhp->uh_alt_next.ptr != NULL\n\t\t    && uhp->uh_alt_next.ptr->uh_walk != nomark\n\t\t    && uhp->uh_alt_next.ptr->uh_walk != mark)\n\t\tuhp = uhp->uh_alt_next.ptr;\n\n\t    /* go up in the tree if we haven't been there and we are at the\n\t     * start of alternate branches */\n\t    else if (uhp->uh_next.ptr != NULL && uhp->uh_alt_prev.ptr == NULL\n\t\t    && uhp->uh_next.ptr->uh_walk != nomark\n\t\t    && uhp->uh_next.ptr->uh_walk != mark)\n\t    {\n\t\t/* If still at the start we don't go through this change. */\n\t\tif (uhp == curbuf->b_u_curhead)\n\t\t    uhp->uh_walk = nomark;\n\t\tuhp = uhp->uh_next.ptr;\n\t    }\n\n\t    else\n\t    {\n\t\t/* need to backtrack; mark this node as useless */\n\t\tuhp->uh_walk = nomark;\n\t\tif (uhp->uh_alt_prev.ptr != NULL)\n\t\t    uhp = uhp->uh_alt_prev.ptr;\n\t\telse\n\t\t    uhp = uhp->uh_next.ptr;\n\t    }\n\t}\n\n\tif (uhp != NULL)    /* found it */\n\t    break;\n\n\tif (absolute)\n\t{\n\t    EMSGN(_(\"E830: Undo number %ld not found\"), step);\n\t    return;\n\t}\n\n\tif (closest == closest_start)\n\t{\n\t    if (step < 0)\n\t\tMSG(_(\"Already at oldest change\"));\n\t    else\n\t\tMSG(_(\"Already at newest change\"));\n\t    return;\n\t}\n\n\ttarget = closest_seq;\n\tdosec = FALSE;\n\tdofile = FALSE;\n\tif (step < 0)\n\t    above = TRUE;\t/* stop above the header */\n    }\n\n    /* If we found it: Follow the path to go to where we want to be. */\n    if (uhp != NULL)\n    {\n\t/*\n\t * First go up the tree as much as needed.\n\t */\n\twhile (!got_int)\n\t{\n\t    /* Do the change warning now, for the same reason as above. */\n\t    change_warning(0);\n\n\t    uhp = curbuf->b_u_curhead;\n\t    if (uhp == NULL)\n\t\tuhp = curbuf->b_u_newhead;\n\t    else\n\t\tuhp = uhp->uh_next.ptr;\n\t    if (uhp == NULL || uhp->uh_walk != mark\n\t\t\t\t\t || (uhp->uh_seq == target && !above))\n\t\tbreak;\n\t    curbuf->b_u_curhead = uhp;\n\t    u_undoredo(TRUE);\n\t    uhp->uh_walk = nomark;\t/* don't go back down here */\n\t}\n\n\t/*\n\t * And now go down the tree (redo), branching off where needed.\n\t */\n\twhile (!got_int)\n\t{\n\t    /* Do the change warning now, for the same reason as above. */\n\t    change_warning(0);\n\n\t    uhp = curbuf->b_u_curhead;\n\t    if (uhp == NULL)\n\t\tbreak;\n\n\t    /* Go back to the first branch with a mark. */\n\t    while (uhp->uh_alt_prev.ptr != NULL\n\t\t\t\t     && uhp->uh_alt_prev.ptr->uh_walk == mark)\n\t\tuhp = uhp->uh_alt_prev.ptr;\n\n\t    /* Find the last branch with a mark, that's the one. */\n\t    last = uhp;\n\t    while (last->uh_alt_next.ptr != NULL\n\t\t\t\t    && last->uh_alt_next.ptr->uh_walk == mark)\n\t\tlast = last->uh_alt_next.ptr;\n\t    if (last != uhp)\n\t    {\n\t\t/* Make the used branch the first entry in the list of\n\t\t * alternatives to make \"u\" and CTRL-R take this branch. */\n\t\twhile (uhp->uh_alt_prev.ptr != NULL)\n\t\t    uhp = uhp->uh_alt_prev.ptr;\n\t\tif (last->uh_alt_next.ptr != NULL)\n\t\t    last->uh_alt_next.ptr->uh_alt_prev.ptr =\n\t\t\t\t\t\t\tlast->uh_alt_prev.ptr;\n\t\tlast->uh_alt_prev.ptr->uh_alt_next.ptr = last->uh_alt_next.ptr;\n\t\tlast->uh_alt_prev.ptr = NULL;\n\t\tlast->uh_alt_next.ptr = uhp;\n\t\tuhp->uh_alt_prev.ptr = last;\n\n\t\tif (curbuf->b_u_oldhead == uhp)\n\t\t    curbuf->b_u_oldhead = last;\n\t\tuhp = last;\n\t\tif (uhp->uh_next.ptr != NULL)\n\t\t    uhp->uh_next.ptr->uh_prev.ptr = uhp;\n\t    }\n\t    curbuf->b_u_curhead = uhp;\n\n\t    if (uhp->uh_walk != mark)\n\t\tbreak;\t    /* must have reached the target */\n\n\t    /* Stop when going backwards in time and didn't find the exact\n\t     * header we were looking for. */\n\t    if (uhp->uh_seq == target && above)\n\t    {\n\t\tcurbuf->b_u_seq_cur = target - 1;\n\t\tbreak;\n\t    }\n\n\t    u_undoredo(FALSE);\n\n\t    /* Advance \"curhead\" to below the header we last used.  If it\n\t     * becomes NULL then we need to set \"newhead\" to this leaf. */\n\t    if (uhp->uh_prev.ptr == NULL)\n\t\tcurbuf->b_u_newhead = uhp;\n\t    curbuf->b_u_curhead = uhp->uh_prev.ptr;\n\t    did_undo = FALSE;\n\n\t    if (uhp->uh_seq == target)\t/* found it! */\n\t\tbreak;\n\n\t    uhp = uhp->uh_prev.ptr;\n\t    if (uhp == NULL || uhp->uh_walk != mark)\n\t    {\n\t\t/* Need to redo more but can't find it... */\n\t\tinternal_error(\"undo_time()\");\n\t\tbreak;\n\t    }\n\t}\n    }\n    u_undo_end(did_undo, absolute);\n}\n\n/*\n * u_undoredo: common code for undo and redo\n *\n * The lines in the file are replaced by the lines in the entry list at\n * curbuf->b_u_curhead. The replaced lines in the file are saved in the entry\n * list for the next undo/redo.\n *\n * When \"undo\" is TRUE we go up in the tree, when FALSE we go down.\n */\n    static void\nu_undoredo(int undo)\n{\n    char_u\t**newarray = NULL;\n    linenr_T\toldsize;\n    linenr_T\tnewsize;\n    linenr_T\ttop, bot;\n    linenr_T\tlnum;\n    linenr_T\tnewlnum = MAXLNUM;\n    long\ti;\n    u_entry_T\t*uep, *nuep;\n    u_entry_T\t*newlist = NULL;\n    int\t\told_flags;\n    int\t\tnew_flags;\n    pos_T\tnamedm[NMARKS];\n    visualinfo_T visualinfo;\n    int\t\tempty_buffer;\t\t    /* buffer became empty */\n    u_header_T\t*curhead = curbuf->b_u_curhead;\n\n#ifdef FEAT_AUTOCMD\n    /* Don't want autocommands using the undo structures here, they are\n     * invalid till the end. */\n    block_autocmds();\n#endif\n\n#ifdef U_DEBUG\n    u_check(FALSE);\n#endif\n    old_flags = curhead->uh_flags;\n    new_flags = (curbuf->b_changed ? UH_CHANGED : 0) +\n\t       ((curbuf->b_ml.ml_flags & ML_EMPTY) ? UH_EMPTYBUF : 0);\n    setpcmark();\n\n    /*\n     * save marks before undo/redo\n     */\n    mch_memmove(namedm, curbuf->b_namedm, sizeof(pos_T) * NMARKS);\n    visualinfo = curbuf->b_visual;\n    curbuf->b_op_start.lnum = curbuf->b_ml.ml_line_count;\n    curbuf->b_op_start.col = 0;\n    curbuf->b_op_end.lnum = 0;\n    curbuf->b_op_end.col = 0;\n\n    for (uep = curhead->uh_entry; uep != NULL; uep = nuep)\n    {\n\ttop = uep->ue_top;\n\tbot = uep->ue_bot;\n\tif (bot == 0)\n\t    bot = curbuf->b_ml.ml_line_count + 1;\n\tif (top > curbuf->b_ml.ml_line_count || top >= bot\n\t\t\t\t      || bot > curbuf->b_ml.ml_line_count + 1)\n\t{\n#ifdef FEAT_AUTOCMD\n\t    unblock_autocmds();\n#endif\n\t    IEMSG(_(\"E438: u_undo: line numbers wrong\"));\n\t    changed();\t\t/* don't want UNCHANGED now */\n\t    return;\n\t}\n\n\toldsize = bot - top - 1;    /* number of lines before undo */\n\tnewsize = uep->ue_size;\t    /* number of lines after undo */\n\n\tif (top < newlnum)\n\t{\n\t    /* If the saved cursor is somewhere in this undo block, move it to\n\t     * the remembered position.  Makes \"gwap\" put the cursor back\n\t     * where it was. */\n\t    lnum = curhead->uh_cursor.lnum;\n\t    if (lnum >= top && lnum <= top + newsize + 1)\n\t    {\n\t\tcurwin->w_cursor = curhead->uh_cursor;\n\t\tnewlnum = curwin->w_cursor.lnum - 1;\n\t    }\n\t    else\n\t    {\n\t\t/* Use the first line that actually changed.  Avoids that\n\t\t * undoing auto-formatting puts the cursor in the previous\n\t\t * line. */\n\t\tfor (i = 0; i < newsize && i < oldsize; ++i)\n\t\t    if (STRCMP(uep->ue_array[i], ml_get(top + 1 + i)) != 0)\n\t\t\tbreak;\n\t\tif (i == newsize && newlnum == MAXLNUM && uep->ue_next == NULL)\n\t\t{\n\t\t    newlnum = top;\n\t\t    curwin->w_cursor.lnum = newlnum + 1;\n\t\t}\n\t\telse if (i < newsize)\n\t\t{\n\t\t    newlnum = top + i;\n\t\t    curwin->w_cursor.lnum = newlnum + 1;\n\t\t}\n\t    }\n\t}\n\n\tempty_buffer = FALSE;\n\n\t/* delete the lines between top and bot and save them in newarray */\n\tif (oldsize > 0)\n\t{\n\t    if ((newarray = (char_u **)U_ALLOC_LINE(\n\t\t\t\t\t sizeof(char_u *) * oldsize)) == NULL)\n\t    {\n\t\tdo_outofmem_msg((long_u)(sizeof(char_u *) * oldsize));\n\t\t/*\n\t\t * We have messed up the entry list, repair is impossible.\n\t\t * we have to free the rest of the list.\n\t\t */\n\t\twhile (uep != NULL)\n\t\t{\n\t\t    nuep = uep->ue_next;\n\t\t    u_freeentry(uep, uep->ue_size);\n\t\t    uep = nuep;\n\t\t}\n\t\tbreak;\n\t    }\n\t    /* delete backwards, it goes faster in most cases */\n\t    for (lnum = bot - 1, i = oldsize; --i >= 0; --lnum)\n\t    {\n\t\t/* what can we do when we run out of memory? */\n\t\tif ((newarray[i] = u_save_line(lnum)) == NULL)\n\t\t    do_outofmem_msg((long_u)0);\n\t\t/* remember we deleted the last line in the buffer, and a\n\t\t * dummy empty line will be inserted */\n\t\tif (curbuf->b_ml.ml_line_count == 1)\n\t\t    empty_buffer = TRUE;\n\t\tml_delete(lnum, FALSE);\n\t    }\n\t}\n\telse\n\t    newarray = NULL;\n\n\t/* insert the lines in u_array between top and bot */\n\tif (newsize)\n\t{\n\t    for (lnum = top, i = 0; i < newsize; ++i, ++lnum)\n\t    {\n\t\t/*\n\t\t * If the file is empty, there is an empty line 1 that we\n\t\t * should get rid of, by replacing it with the new line\n\t\t */\n\t\tif (empty_buffer && lnum == 0)\n\t\t    ml_replace((linenr_T)1, uep->ue_array[i], TRUE);\n\t\telse\n\t\t    ml_append(lnum, uep->ue_array[i], (colnr_T)0, FALSE);\n\t\tvim_free(uep->ue_array[i]);\n\t    }\n\t    vim_free((char_u *)uep->ue_array);\n\t}\n\n\t/* adjust marks */\n\tif (oldsize != newsize)\n\t{\n\t    mark_adjust(top + 1, top + oldsize, (long)MAXLNUM,\n\t\t\t\t\t       (long)newsize - (long)oldsize);\n\t    if (curbuf->b_op_start.lnum > top + oldsize)\n\t\tcurbuf->b_op_start.lnum += newsize - oldsize;\n\t    if (curbuf->b_op_end.lnum > top + oldsize)\n\t\tcurbuf->b_op_end.lnum += newsize - oldsize;\n\t}\n\n\tchanged_lines(top + 1, 0, bot, newsize - oldsize);\n\n\t/* set '[ and '] mark */\n\tif (top + 1 < curbuf->b_op_start.lnum)\n\t    curbuf->b_op_start.lnum = top + 1;\n\tif (newsize == 0 && top + 1 > curbuf->b_op_end.lnum)\n\t    curbuf->b_op_end.lnum = top + 1;\n\telse if (top + newsize > curbuf->b_op_end.lnum)\n\t    curbuf->b_op_end.lnum = top + newsize;\n\n\tu_newcount += newsize;\n\tu_oldcount += oldsize;\n\tuep->ue_size = oldsize;\n\tuep->ue_array = newarray;\n\tuep->ue_bot = top + newsize + 1;\n\n\t/*\n\t * insert this entry in front of the new entry list\n\t */\n\tnuep = uep->ue_next;\n\tuep->ue_next = newlist;\n\tnewlist = uep;\n    }\n\n    curhead->uh_entry = newlist;\n    curhead->uh_flags = new_flags;\n    if ((old_flags & UH_EMPTYBUF) && bufempty())\n\tcurbuf->b_ml.ml_flags |= ML_EMPTY;\n    if (old_flags & UH_CHANGED)\n\tchanged();\n    else\n#ifdef FEAT_NETBEANS_INTG\n\t/* per netbeans undo rules, keep it as modified */\n\tif (!isNetbeansModified(curbuf))\n#endif\n\tunchanged(curbuf, FALSE);\n\n    /*\n     * restore marks from before undo/redo\n     */\n    for (i = 0; i < NMARKS; ++i)\n    {\n\tif (curhead->uh_namedm[i].lnum != 0)\n\t    curbuf->b_namedm[i] = curhead->uh_namedm[i];\n\tif (namedm[i].lnum != 0)\n\t    curhead->uh_namedm[i] = namedm[i];\n\telse\n\t    curhead->uh_namedm[i].lnum = 0;\n    }\n    if (curhead->uh_visual.vi_start.lnum != 0)\n    {\n\tcurbuf->b_visual = curhead->uh_visual;\n\tcurhead->uh_visual = visualinfo;\n    }\n\n    /*\n     * If the cursor is only off by one line, put it at the same position as\n     * before starting the change (for the \"o\" command).\n     * Otherwise the cursor should go to the first undone line.\n     */\n    if (curhead->uh_cursor.lnum + 1 == curwin->w_cursor.lnum\n\t\t\t\t\t\t && curwin->w_cursor.lnum > 1)\n\t--curwin->w_cursor.lnum;\n    if (curwin->w_cursor.lnum <= curbuf->b_ml.ml_line_count)\n    {\n\tif (curhead->uh_cursor.lnum == curwin->w_cursor.lnum)\n\t{\n\t    curwin->w_cursor.col = curhead->uh_cursor.col;\n#ifdef FEAT_VIRTUALEDIT\n\t    if (virtual_active() && curhead->uh_cursor_vcol >= 0)\n\t\tcoladvance((colnr_T)curhead->uh_cursor_vcol);\n\t    else\n\t\tcurwin->w_cursor.coladd = 0;\n#endif\n\t}\n\telse\n\t    beginline(BL_SOL | BL_FIX);\n    }\n    else\n    {\n\t/* We get here with the current cursor line being past the end (eg\n\t * after adding lines at the end of the file, and then undoing it).\n\t * check_cursor() will move the cursor to the last line.  Move it to\n\t * the first column here. */\n\tcurwin->w_cursor.col = 0;\n#ifdef FEAT_VIRTUALEDIT\n\tcurwin->w_cursor.coladd = 0;\n#endif\n    }\n\n    /* Make sure the cursor is on an existing line and column. */\n    check_cursor();\n\n    /* Remember where we are for \"g-\" and \":earlier 10s\". */\n    curbuf->b_u_seq_cur = curhead->uh_seq;\n    if (undo)\n\t/* We are below the previous undo.  However, to make \":earlier 1s\"\n\t * work we compute this as being just above the just undone change. */\n\t--curbuf->b_u_seq_cur;\n\n    /* Remember where we are for \":earlier 1f\" and \":later 1f\". */\n    if (curhead->uh_save_nr != 0)\n    {\n\tif (undo)\n\t    curbuf->b_u_save_nr_cur = curhead->uh_save_nr - 1;\n\telse\n\t    curbuf->b_u_save_nr_cur = curhead->uh_save_nr;\n    }\n\n    /* The timestamp can be the same for multiple changes, just use the one of\n     * the undone/redone change. */\n    curbuf->b_u_time_cur = curhead->uh_time;\n\n#ifdef FEAT_AUTOCMD\n    unblock_autocmds();\n#endif\n#ifdef U_DEBUG\n    u_check(FALSE);\n#endif\n}\n\n/*\n * If we deleted or added lines, report the number of less/more lines.\n * Otherwise, report the number of changes (this may be incorrect\n * in some cases, but it's better than nothing).\n */\n    static void\nu_undo_end(\n    int\t\tdid_undo,\t/* just did an undo */\n    int\t\tabsolute)\t/* used \":undo N\" */\n{\n    char\t*msgstr;\n    u_header_T\t*uhp;\n    char_u\tmsgbuf[80];\n\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_UNDO) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n\n    if (global_busy\t    /* no messages now, wait until global is finished */\n\t    || !messaging())  /* 'lazyredraw' set, don't do messages now */\n\treturn;\n\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\t--u_newcount;\n\n    u_oldcount -= u_newcount;\n    if (u_oldcount == -1)\n\tmsgstr = N_(\"more line\");\n    else if (u_oldcount < 0)\n\tmsgstr = N_(\"more lines\");\n    else if (u_oldcount == 1)\n\tmsgstr = N_(\"line less\");\n    else if (u_oldcount > 1)\n\tmsgstr = N_(\"fewer lines\");\n    else\n    {\n\tu_oldcount = u_newcount;\n\tif (u_newcount == 1)\n\t    msgstr = N_(\"change\");\n\telse\n\t    msgstr = N_(\"changes\");\n    }\n\n    if (curbuf->b_u_curhead != NULL)\n    {\n\t/* For \":undo N\" we prefer a \"after #N\" message. */\n\tif (absolute && curbuf->b_u_curhead->uh_next.ptr != NULL)\n\t{\n\t    uhp = curbuf->b_u_curhead->uh_next.ptr;\n\t    did_undo = FALSE;\n\t}\n\telse if (did_undo)\n\t    uhp = curbuf->b_u_curhead;\n\telse\n\t    uhp = curbuf->b_u_curhead->uh_next.ptr;\n    }\n    else\n\tuhp = curbuf->b_u_newhead;\n\n    if (uhp == NULL)\n\t*msgbuf = NUL;\n    else\n\tu_add_time(msgbuf, sizeof(msgbuf), uhp->uh_time);\n\n#ifdef FEAT_CONCEAL\n    {\n\twin_T\t*wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    if (wp->w_buffer == curbuf && wp->w_p_cole > 0)\n\t\tredraw_win_later(wp, NOT_VALID);\n\t}\n    }\n#endif\n\n    smsg((char_u *)_(\"%ld %s; %s #%ld  %s\"),\n\t    u_oldcount < 0 ? -u_oldcount : u_oldcount,\n\t    _(msgstr),\n\t    did_undo ? _(\"before\") : _(\"after\"),\n\t    uhp == NULL ? 0L : uhp->uh_seq,\n\t    msgbuf);\n}\n\n/*\n * u_sync: stop adding to the current entry list\n */\n    void\nu_sync(\n    int\t    force)\t/* Also sync when no_u_sync is set. */\n{\n    /* Skip it when already synced or syncing is disabled. */\n    if (curbuf->b_u_synced || (!force && no_u_sync > 0))\n\treturn;\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n    if (im_is_preediting())\n\treturn;\t\t    /* XIM is busy, don't break an undo sequence */\n#endif\n    if (get_undolevel() < 0)\n\tcurbuf->b_u_synced = TRUE;  /* no entries, nothing to do */\n    else\n    {\n\tu_getbot();\t\t    /* compute ue_bot of previous u_save */\n\tcurbuf->b_u_curhead = NULL;\n    }\n}\n\n/*\n * \":undolist\": List the leafs of the undo tree\n */\n    void\nex_undolist(exarg_T *eap UNUSED)\n{\n    garray_T\tga;\n    u_header_T\t*uhp;\n    int\t\tmark;\n    int\t\tnomark;\n    int\t\tchanges = 1;\n    int\t\ti;\n\n    /*\n     * 1: walk the tree to find all leafs, put the info in \"ga\".\n     * 2: sort the lines\n     * 3: display the list\n     */\n    mark = ++lastmark;\n    nomark = ++lastmark;\n    ga_init2(&ga, (int)sizeof(char *), 20);\n\n    uhp = curbuf->b_u_oldhead;\n    while (uhp != NULL)\n    {\n\tif (uhp->uh_prev.ptr == NULL && uhp->uh_walk != nomark\n\t\t\t\t\t\t      && uhp->uh_walk != mark)\n\t{\n\t    if (ga_grow(&ga, 1) == FAIL)\n\t\tbreak;\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%6ld %7ld  \",\n\t\t\t\t\t\t\tuhp->uh_seq, changes);\n\t    u_add_time(IObuff + STRLEN(IObuff), IOSIZE - STRLEN(IObuff),\n\t\t\t\t\t\t\t\tuhp->uh_time);\n\t    if (uhp->uh_save_nr > 0)\n\t    {\n\t\twhile (STRLEN(IObuff) < 33)\n\t\t    STRCAT(IObuff, \" \");\n\t\tvim_snprintf_add((char *)IObuff, IOSIZE,\n\t\t\t\t\t\t   \"  %3ld\", uhp->uh_save_nr);\n\t    }\n\t    ((char_u **)(ga.ga_data))[ga.ga_len++] = vim_strsave(IObuff);\n\t}\n\n\tuhp->uh_walk = mark;\n\n\t/* go down in the tree if we haven't been there */\n\tif (uhp->uh_prev.ptr != NULL && uhp->uh_prev.ptr->uh_walk != nomark\n\t\t\t\t\t && uhp->uh_prev.ptr->uh_walk != mark)\n\t{\n\t    uhp = uhp->uh_prev.ptr;\n\t    ++changes;\n\t}\n\n\t/* go to alternate branch if we haven't been there */\n\telse if (uhp->uh_alt_next.ptr != NULL\n\t\t&& uhp->uh_alt_next.ptr->uh_walk != nomark\n\t\t&& uhp->uh_alt_next.ptr->uh_walk != mark)\n\t    uhp = uhp->uh_alt_next.ptr;\n\n\t/* go up in the tree if we haven't been there and we are at the\n\t * start of alternate branches */\n\telse if (uhp->uh_next.ptr != NULL && uhp->uh_alt_prev.ptr == NULL\n\t\t&& uhp->uh_next.ptr->uh_walk != nomark\n\t\t&& uhp->uh_next.ptr->uh_walk != mark)\n\t{\n\t    uhp = uhp->uh_next.ptr;\n\t    --changes;\n\t}\n\n\telse\n\t{\n\t    /* need to backtrack; mark this node as done */\n\t    uhp->uh_walk = nomark;\n\t    if (uhp->uh_alt_prev.ptr != NULL)\n\t\tuhp = uhp->uh_alt_prev.ptr;\n\t    else\n\t    {\n\t\tuhp = uhp->uh_next.ptr;\n\t\t--changes;\n\t    }\n\t}\n    }\n\n    if (ga.ga_len == 0)\n\tMSG(_(\"Nothing to undo\"));\n    else\n    {\n\tsort_strings((char_u **)ga.ga_data, ga.ga_len);\n\n\tmsg_start();\n\tmsg_puts_attr((char_u *)_(\"number changes  when               saved\"),\n\t\t\t\t\t\t\t      hl_attr(HLF_T));\n\tfor (i = 0; i < ga.ga_len && !got_int; ++i)\n\t{\n\t    msg_putchar('\\n');\n\t    if (got_int)\n\t\tbreak;\n\t    msg_puts(((char_u **)ga.ga_data)[i]);\n\t}\n\tmsg_end();\n\n\tga_clear_strings(&ga);\n    }\n}\n\n/*\n * Put the timestamp of an undo header in \"buf[buflen]\" in a nice format.\n */\n    static void\nu_add_time(char_u *buf, size_t buflen, time_t tt)\n{\n#ifdef HAVE_STRFTIME\n    struct tm\t*curtime;\n\n    if (vim_time() - tt >= 100)\n    {\n\tcurtime = localtime(&tt);\n\tif (vim_time() - tt < (60L * 60L * 12L))\n\t    /* within 12 hours */\n\t    (void)strftime((char *)buf, buflen, \"%H:%M:%S\", curtime);\n\telse\n\t    /* longer ago */\n\t    (void)strftime((char *)buf, buflen, \"%Y/%m/%d %H:%M:%S\", curtime);\n    }\n    else\n#endif\n\tvim_snprintf((char *)buf, buflen, _(\"%ld seconds ago\"),\n\t\t\t\t\t\t      (long)(vim_time() - tt));\n}\n\n/*\n * \":undojoin\": continue adding to the last entry list\n */\n    void\nex_undojoin(exarg_T *eap UNUSED)\n{\n    if (curbuf->b_u_newhead == NULL)\n\treturn;\t\t    /* nothing changed before */\n    if (curbuf->b_u_curhead != NULL)\n    {\n\tEMSG(_(\"E790: undojoin is not allowed after undo\"));\n\treturn;\n    }\n    if (!curbuf->b_u_synced)\n\treturn;\t\t    /* already unsynced */\n    if (get_undolevel() < 0)\n\treturn;\t\t    /* no entries, nothing to do */\n    else\n\t/* Append next change to the last entry */\n\tcurbuf->b_u_synced = FALSE;\n}\n\n/*\n * Called after writing or reloading the file and setting b_changed to FALSE.\n * Now an undo means that the buffer is modified.\n */\n    void\nu_unchanged(buf_T *buf)\n{\n    u_unch_branch(buf->b_u_oldhead);\n    buf->b_did_warn = FALSE;\n}\n\n/*\n * After reloading a buffer which was saved for 'undoreload': Find the first\n * line that was changed and set the cursor there.\n */\n    void\nu_find_first_changed(void)\n{\n    u_header_T\t*uhp = curbuf->b_u_newhead;\n    u_entry_T   *uep;\n    linenr_T\tlnum;\n\n    if (curbuf->b_u_curhead != NULL || uhp == NULL)\n\treturn;  /* undid something in an autocmd? */\n\n    /* Check that the last undo block was for the whole file. */\n    uep = uhp->uh_entry;\n    if (uep->ue_top != 0 || uep->ue_bot != 0)\n\treturn;\n\n    for (lnum = 1; lnum < curbuf->b_ml.ml_line_count\n\t\t\t\t\t      && lnum <= uep->ue_size; ++lnum)\n\tif (STRCMP(ml_get_buf(curbuf, lnum, FALSE),\n\t\t\t\t\t\tuep->ue_array[lnum - 1]) != 0)\n\t{\n\t    clearpos(&(uhp->uh_cursor));\n\t    uhp->uh_cursor.lnum = lnum;\n\t    return;\n\t}\n    if (curbuf->b_ml.ml_line_count != uep->ue_size)\n    {\n\t/* lines added or deleted at the end, put the cursor there */\n\tclearpos(&(uhp->uh_cursor));\n\tuhp->uh_cursor.lnum = lnum;\n    }\n}\n\n/*\n * Increase the write count, store it in the last undo header, what would be\n * used for \"u\".\n */\n    void\nu_update_save_nr(buf_T *buf)\n{\n    u_header_T\t*uhp;\n\n    ++buf->b_u_save_nr_last;\n    buf->b_u_save_nr_cur = buf->b_u_save_nr_last;\n    uhp = buf->b_u_curhead;\n    if (uhp != NULL)\n\tuhp = uhp->uh_next.ptr;\n    else\n\tuhp = buf->b_u_newhead;\n    if (uhp != NULL)\n\tuhp->uh_save_nr = buf->b_u_save_nr_last;\n}\n\n    static void\nu_unch_branch(u_header_T *uhp)\n{\n    u_header_T\t*uh;\n\n    for (uh = uhp; uh != NULL; uh = uh->uh_prev.ptr)\n    {\n\tuh->uh_flags |= UH_CHANGED;\n\tif (uh->uh_alt_next.ptr != NULL)\n\t    u_unch_branch(uh->uh_alt_next.ptr);\t    /* recursive */\n    }\n}\n\n/*\n * Get pointer to last added entry.\n * If it's not valid, give an error message and return NULL.\n */\n    static u_entry_T *\nu_get_headentry(void)\n{\n    if (curbuf->b_u_newhead == NULL || curbuf->b_u_newhead->uh_entry == NULL)\n    {\n\tIEMSG(_(\"E439: undo list corrupt\"));\n\treturn NULL;\n    }\n    return curbuf->b_u_newhead->uh_entry;\n}\n\n/*\n * u_getbot(): compute the line number of the previous u_save\n *\t\tIt is called only when b_u_synced is FALSE.\n */\n    static void\nu_getbot(void)\n{\n    u_entry_T\t*uep;\n    linenr_T\textra;\n\n    uep = u_get_headentry();\t/* check for corrupt undo list */\n    if (uep == NULL)\n\treturn;\n\n    uep = curbuf->b_u_newhead->uh_getbot_entry;\n    if (uep != NULL)\n    {\n\t/*\n\t * the new ue_bot is computed from the number of lines that has been\n\t * inserted (0 - deleted) since calling u_save. This is equal to the\n\t * old line count subtracted from the current line count.\n\t */\n\textra = curbuf->b_ml.ml_line_count - uep->ue_lcount;\n\tuep->ue_bot = uep->ue_top + uep->ue_size + 1 + extra;\n\tif (uep->ue_bot < 1 || uep->ue_bot > curbuf->b_ml.ml_line_count)\n\t{\n\t    IEMSG(_(\"E440: undo line missing\"));\n\t    uep->ue_bot = uep->ue_top + 1;  /* assume all lines deleted, will\n\t\t\t\t\t     * get all the old lines back\n\t\t\t\t\t     * without deleting the current\n\t\t\t\t\t     * ones */\n\t}\n\n\tcurbuf->b_u_newhead->uh_getbot_entry = NULL;\n    }\n\n    curbuf->b_u_synced = TRUE;\n}\n\n/*\n * Free one header \"uhp\" and its entry list and adjust the pointers.\n */\n    static void\nu_freeheader(\n    buf_T\t    *buf,\n    u_header_T\t    *uhp,\n    u_header_T\t    **uhpp)\t/* if not NULL reset when freeing this header */\n{\n    u_header_T\t    *uhap;\n\n    /* When there is an alternate redo list free that branch completely,\n     * because we can never go there. */\n    if (uhp->uh_alt_next.ptr != NULL)\n\tu_freebranch(buf, uhp->uh_alt_next.ptr, uhpp);\n\n    if (uhp->uh_alt_prev.ptr != NULL)\n\tuhp->uh_alt_prev.ptr->uh_alt_next.ptr = NULL;\n\n    /* Update the links in the list to remove the header. */\n    if (uhp->uh_next.ptr == NULL)\n\tbuf->b_u_oldhead = uhp->uh_prev.ptr;\n    else\n\tuhp->uh_next.ptr->uh_prev.ptr = uhp->uh_prev.ptr;\n\n    if (uhp->uh_prev.ptr == NULL)\n\tbuf->b_u_newhead = uhp->uh_next.ptr;\n    else\n\tfor (uhap = uhp->uh_prev.ptr; uhap != NULL;\n\t\t\t\t\t\t uhap = uhap->uh_alt_next.ptr)\n\t    uhap->uh_next.ptr = uhp->uh_next.ptr;\n\n    u_freeentries(buf, uhp, uhpp);\n}\n\n/*\n * Free an alternate branch and any following alternate branches.\n */\n    static void\nu_freebranch(\n    buf_T\t    *buf,\n    u_header_T\t    *uhp,\n    u_header_T\t    **uhpp)\t/* if not NULL reset when freeing this header */\n{\n    u_header_T\t    *tofree, *next;\n\n    /* If this is the top branch we may need to use u_freeheader() to update\n     * all the pointers. */\n    if (uhp == buf->b_u_oldhead)\n    {\n\twhile (buf->b_u_oldhead != NULL)\n\t    u_freeheader(buf, buf->b_u_oldhead, uhpp);\n\treturn;\n    }\n\n    if (uhp->uh_alt_prev.ptr != NULL)\n\tuhp->uh_alt_prev.ptr->uh_alt_next.ptr = NULL;\n\n    next = uhp;\n    while (next != NULL)\n    {\n\ttofree = next;\n\tif (tofree->uh_alt_next.ptr != NULL)\n\t    u_freebranch(buf, tofree->uh_alt_next.ptr, uhpp);   /* recursive */\n\tnext = tofree->uh_prev.ptr;\n\tu_freeentries(buf, tofree, uhpp);\n    }\n}\n\n/*\n * Free all the undo entries for one header and the header itself.\n * This means that \"uhp\" is invalid when returning.\n */\n    static void\nu_freeentries(\n    buf_T\t    *buf,\n    u_header_T\t    *uhp,\n    u_header_T\t    **uhpp)\t/* if not NULL reset when freeing this header */\n{\n    u_entry_T\t    *uep, *nuep;\n\n    /* Check for pointers to the header that become invalid now. */\n    if (buf->b_u_curhead == uhp)\n\tbuf->b_u_curhead = NULL;\n    if (buf->b_u_newhead == uhp)\n\tbuf->b_u_newhead = NULL;  /* freeing the newest entry */\n    if (uhpp != NULL && uhp == *uhpp)\n\t*uhpp = NULL;\n\n    for (uep = uhp->uh_entry; uep != NULL; uep = nuep)\n    {\n\tnuep = uep->ue_next;\n\tu_freeentry(uep, uep->ue_size);\n    }\n\n#ifdef U_DEBUG\n    uhp->uh_magic = 0;\n#endif\n    vim_free((char_u *)uhp);\n    --buf->b_u_numhead;\n}\n\n/*\n * free entry 'uep' and 'n' lines in uep->ue_array[]\n */\n    static void\nu_freeentry(u_entry_T *uep, long n)\n{\n    while (n > 0)\n\tvim_free(uep->ue_array[--n]);\n    vim_free((char_u *)uep->ue_array);\n#ifdef U_DEBUG\n    uep->ue_magic = 0;\n#endif\n    vim_free((char_u *)uep);\n}\n\n/*\n * invalidate the undo buffer; called when storage has already been released\n */\n    void\nu_clearall(buf_T *buf)\n{\n    buf->b_u_newhead = buf->b_u_oldhead = buf->b_u_curhead = NULL;\n    buf->b_u_synced = TRUE;\n    buf->b_u_numhead = 0;\n    buf->b_u_line_ptr = NULL;\n    buf->b_u_line_lnum = 0;\n}\n\n/*\n * save the line \"lnum\" for the \"U\" command\n */\n    void\nu_saveline(linenr_T lnum)\n{\n    if (lnum == curbuf->b_u_line_lnum)\t    /* line is already saved */\n\treturn;\n    if (lnum < 1 || lnum > curbuf->b_ml.ml_line_count) /* should never happen */\n\treturn;\n    u_clearline();\n    curbuf->b_u_line_lnum = lnum;\n    if (curwin->w_cursor.lnum == lnum)\n\tcurbuf->b_u_line_colnr = curwin->w_cursor.col;\n    else\n\tcurbuf->b_u_line_colnr = 0;\n    if ((curbuf->b_u_line_ptr = u_save_line(lnum)) == NULL)\n\tdo_outofmem_msg((long_u)0);\n}\n\n/*\n * clear the line saved for the \"U\" command\n * (this is used externally for crossing a line while in insert mode)\n */\n    void\nu_clearline(void)\n{\n    if (curbuf->b_u_line_ptr != NULL)\n    {\n\tvim_free(curbuf->b_u_line_ptr);\n\tcurbuf->b_u_line_ptr = NULL;\n\tcurbuf->b_u_line_lnum = 0;\n    }\n}\n\n/*\n * Implementation of the \"U\" command.\n * Differentiation from vi: \"U\" can be undone with the next \"U\".\n * We also allow the cursor to be in another line.\n * Careful: may trigger autocommands that reload the buffer.\n */\n    void\nu_undoline(void)\n{\n    colnr_T t;\n    char_u  *oldp;\n\n    if (undo_off)\n\treturn;\n\n    if (curbuf->b_u_line_ptr == NULL\n\t\t\t|| curbuf->b_u_line_lnum > curbuf->b_ml.ml_line_count)\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n    /* first save the line for the 'u' command */\n    if (u_savecommon(curbuf->b_u_line_lnum - 1,\n\t\t       curbuf->b_u_line_lnum + 1, (linenr_T)0, FALSE) == FAIL)\n\treturn;\n    oldp = u_save_line(curbuf->b_u_line_lnum);\n    if (oldp == NULL)\n    {\n\tdo_outofmem_msg((long_u)0);\n\treturn;\n    }\n    ml_replace(curbuf->b_u_line_lnum, curbuf->b_u_line_ptr, TRUE);\n    changed_bytes(curbuf->b_u_line_lnum, 0);\n    vim_free(curbuf->b_u_line_ptr);\n    curbuf->b_u_line_ptr = oldp;\n\n    t = curbuf->b_u_line_colnr;\n    if (curwin->w_cursor.lnum == curbuf->b_u_line_lnum)\n\tcurbuf->b_u_line_colnr = curwin->w_cursor.col;\n    curwin->w_cursor.col = t;\n    curwin->w_cursor.lnum = curbuf->b_u_line_lnum;\n    check_cursor_col();\n}\n\n/*\n * Free all allocated memory blocks for the buffer 'buf'.\n */\n    void\nu_blockfree(buf_T *buf)\n{\n    while (buf->b_u_oldhead != NULL)\n\tu_freeheader(buf, buf->b_u_oldhead, NULL);\n    vim_free(buf->b_u_line_ptr);\n}\n\n/*\n * u_save_line(): allocate memory and copy line 'lnum' into it.\n * Returns NULL when out of memory.\n */\n    static char_u *\nu_save_line(linenr_T lnum)\n{\n    return vim_strsave(ml_get(lnum));\n}\n\n/*\n * Check if the 'modified' flag is set, or 'ff' has changed (only need to\n * check the first character, because it can only be \"dos\", \"unix\" or \"mac\").\n * \"nofile\" and \"scratch\" type buffers are considered to always be unchanged.\n */\n    int\nbufIsChanged(buf_T *buf)\n{\n    return\n#ifdef FEAT_QUICKFIX\n\t    !bt_dontwrite(buf) &&\n#endif\n\t    (buf->b_changed || file_ff_differs(buf, TRUE));\n}\n\n    int\ncurbufIsChanged(void)\n{\n    return\n#ifdef FEAT_QUICKFIX\n\t!bt_dontwrite(curbuf) &&\n#endif\n\t(curbuf->b_changed || file_ff_differs(curbuf, TRUE));\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * For undotree(): Append the list of undo blocks at \"first_uhp\" to \"list\".\n * Recursive.\n */\n    void\nu_eval_tree(u_header_T *first_uhp, list_T *list)\n{\n    u_header_T  *uhp = first_uhp;\n    dict_T\t*dict;\n\n    while (uhp != NULL)\n    {\n\tdict = dict_alloc();\n\tif (dict == NULL)\n\t    return;\n\tdict_add_nr_str(dict, \"seq\", uhp->uh_seq, NULL);\n\tdict_add_nr_str(dict, \"time\", (long)uhp->uh_time, NULL);\n\tif (uhp == curbuf->b_u_newhead)\n\t    dict_add_nr_str(dict, \"newhead\", 1, NULL);\n\tif (uhp == curbuf->b_u_curhead)\n\t    dict_add_nr_str(dict, \"curhead\", 1, NULL);\n\tif (uhp->uh_save_nr > 0)\n\t    dict_add_nr_str(dict, \"save\", uhp->uh_save_nr, NULL);\n\n\tif (uhp->uh_alt_next.ptr != NULL)\n\t{\n\t    list_T\t*alt_list = list_alloc();\n\n\t    if (alt_list != NULL)\n\t    {\n\t\t/* Recursive call to add alternate undo tree. */\n\t\tu_eval_tree(uhp->uh_alt_next.ptr, alt_list);\n\t\tdict_add_list(dict, \"alt\", alt_list);\n\t    }\n\t}\n\n\tlist_append_dict(list, dict);\n\tuhp = uhp->uh_prev.ptr;\n    }\n}\n#endif\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n#ifdef AMIGA\n# include <time.h>\t/* for time() */\n#endif\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\nmake_version(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't catenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n    strcat(longVersion, \")\");\n}\n# else\nchar\t*longVersion = VIM_VERSION_LONG_DATE __DATE__ \" \" __TIME__ \")\";\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n#endif\n\nstatic void list_features(void);\nstatic void version_msg(char *s);\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t/* only for Amiga systems */\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n#ifdef FEAT_AUTOCMD\n\t\"+autocmd\",\n#else\n\t\"-autocmd\",\n#endif\n#ifdef FEAT_BEVAL\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n#ifdef FEAT_CMDL_COMPL\n\t\"+cmdline_compl\",\n#else\n\t\"-cmdline_compl\",\n#endif\n#ifdef FEAT_CMDHIST\n\t\"+cmdline_hist\",\n#else\n\t\"-cmdline_hist\",\n#endif\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n#ifdef FEAT_COMMENTS\n\t\"+comments\",\n#else\n\t\"-comments\",\n#endif\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n#ifdef FEAT_CURSORBIND\n\t\"+cursorbind\",\n#else\n\t\"-cursorbind\",\n#endif\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_W32\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n#ifdef FEAT_FKMAP\n\t\"+farsi\",\n#else\n\t\"-farsi\",\n#endif\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    /* only interesting on Unix systems */\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n#ifdef FEAT_HANGULIN\n\t\"+hangul_input\",\n#else\n\t\"-hangul_input\",\n#endif\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n#ifdef FEAT_INS_EXPAND\n\t\"+insert_expand\",\n#else\n\t\"-insert_expand\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n#ifdef FEAT_JUMPLIST\n\t\"+jumplist\",\n#else\n\t\"-jumplist\",\n#endif\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n#ifdef FEAT_LISTCMDS\n\t\"+listcmds\",\n#else\n\t\"-listcmds\",\n#endif\n#ifdef FEAT_LOCALMAP\n\t\"+localmap\",\n#else\n\t\"-localmap\",\n#endif\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n#ifdef FEAT_MODIFY_FNAME\n\t\"+modify_fname\",\n#else\n\t\"-modify_fname\",\n#endif\n#ifdef FEAT_MOUSE\n\t\"+mouse\",\n#  ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#  else\n\t\"-mouseshape\",\n#  endif\n# else\n\t\"-mouse\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_SGR\n\t\"+mouse_sgr\",\n# else\n\t\"-mouse_sgr\",\n# endif\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n# ifdef FEAT_MOUSE_XTERM\n\t\"+mouse_xterm\",\n# else\n\t\"-mouse_xterm\",\n# endif\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n# ifdef FEAT_MBYTE\n\t\"+multi_byte\",\n# else\n\t\"-multi_byte\",\n# endif\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n#ifdef FEAT_NUM64\n\t\"+num64\",\n#else\n\t\"-num64\",\n#endif\n#ifdef FEAT_GUI_W32\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n\t\"+packages\",\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n#ifdef FEAT_SCROLLBIND\n\t\"+scrollbind\",\n#else\n\t\"-scrollbind\",\n#endif\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n#ifdef FEAT_SUN_WORKSHOP\n\t\"+sun_workshop\",\n#else\n\t\"-sun_workshop\",\n#endif\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    /* only interesting on Unix systems */\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n#ifdef FEAT_TAG_OLDSTATIC\n\t\"+tag_old_static\",\n#else\n\t\"-tag_old_static\",\n#endif\n#ifdef FEAT_TAG_ANYWHITE\n\t\"+tag_any_white\",\n#else\n\t\"-tag_any_white\",\n#endif\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#if defined(UNIX)\n/* only Unix can have terminfo instead of termcap */\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#else\t\t    /* unix always includes termcap support */\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n#ifdef FEAT_TITLE\n\t\"+title\",\n#else\n\t\"-title\",\n#endif\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n#ifdef FEAT_USR_CMDS\n\t\"+user_commands\",\n#else\n\t\"-user_commands\",\n#endif\n#ifdef FEAT_WINDOWS\n\t\"+vertsplit\",\n#else\n\t\"-vertsplit\",\n#endif\n#ifdef FEAT_VIRTUALEDIT\n\t\"+virtualedit\",\n#else\n\t\"-virtualedit\",\n#endif\n\t\"+visual\",\n#ifdef FEAT_VISUALEXTRA\n\t\"+visualextra\",\n#else\n\t\"-visualextra\",\n#endif\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n#ifdef FEAT_VREPLACE\n\t\"+vreplace\",\n#else\n\t\"-vreplace\",\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n#ifdef FEAT_WINDOWS\n\t\"+windows\",\n#else\n\t\"-windows\",\n#endif\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef WIN3264\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    int\t\ti;\n    int\t\th = 0;\n\n    for (i = 0; included_patches[i] != 0; ++i)\n\tif (included_patches[i] > h)\n\t    h = included_patches[i];\n    return h;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\ti;\n\n    for (i = 0; included_patches[i] != 0; ++i)\n\tif (included_patches[i] == n)\n\t    return TRUE;\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tnfeat = 0;\n    int\t\twidth = 0;\n\n    /* Find the length of the longest feature name, use that + 1 as the column\n     * width */\n    for (i = 0; features[i] != NULL; ++i)\n    {\n\tint l = (int)STRLEN(features[i]);\n\n\tif (l > width)\n\t    width = l;\n\t++nfeat;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t/* Not enough screen columns - show one per line */\n\tfor (i = 0; features[i] != NULL; ++i)\n\t{\n\t    version_msg(features[i]);\n\t    if (msg_col > 0)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    /* The rightmost column doesn't need a separator.\n     * Sacrifice it to fit in one more column if possible. */\n    ncol = (int) (Columns + 1) / width;\n    nrow = nfeat / ncol + (nfeat % ncol ? 1 : 0);\n\n    /* i counts columns then rows.  idx counts rows then columns. */\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < nfeat)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    msg_puts((char_u *)features[idx]);\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0)\n\t\t    msg_putchar('\\n');\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    if (msg_col > 0)\n\t\tmsg_putchar('\\n');\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    MSG(longVersion);\n#ifdef WIN3264\n# ifdef FEAT_GUI_W32\n#  ifdef _WIN64\n    MSG_PUTS(_(\"\\nMS-Windows 64-bit GUI version\"));\n#  else\n    MSG_PUTS(_(\"\\nMS-Windows 32-bit GUI version\"));\n#  endif\n# ifdef FEAT_OLE\n    MSG_PUTS(_(\" with OLE support\"));\n# endif\n# else\n#  ifdef _WIN64\n    MSG_PUTS(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    MSG_PUTS(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#ifdef MACOS\n# ifdef MACOS_X\n#  ifdef MACOS_X_UNIX\n    MSG_PUTS(_(\"\\nMacOS X (unix) version\"));\n#  else\n    MSG_PUTS(_(\"\\nMacOS X version\"));\n#  endif\n#else\n    MSG_PUTS(_(\"\\nMacOS version\"));\n# endif\n#endif\n\n#ifdef VMS\n    MSG_PUTS(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tMSG_PUTS(\" - \");\n\tMSG_PUTS(compiled_arch);\n    }\n# endif\n\n#endif\n\n    /* Print the list of patch numbers if there is at least one. */\n    /* Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\" */\n    if (included_patches[0] != 0)\n    {\n\tMSG_PUTS(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\t/* find last one */\n\tfor (i = 0; included_patches[i] != 0; ++i)\n\t    ;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tMSG_PUTS(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    MSG_PUTS(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    /* Print the list of extra patch descriptions if there is at least one. */\n    if (extra_patches[0] != NULL)\n    {\n\tMSG_PUTS(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    MSG_PUTS(s);\n\t    s = \", \";\n\t    MSG_PUTS(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    MSG_PUTS(\"\\n\");\n    MSG_PUTS(_(\"Modified by \"));\n    MSG_PUTS(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tMSG_PUTS(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    MSG_PUTS(_(\"by \"));\n\t    MSG_PUTS(compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    MSG_PUTS(\"@\");\n\t    MSG_PUTS(compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    MSG_PUTS(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    MSG_PUTS(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    MSG_PUTS(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    MSG_PUTS(_(\"\\nSmall version \"));\n#   else\n    MSG_PUTS(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    MSG_PUTS(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    MSG_PUTS(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     MSG_PUTS(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     MSG_PUTS(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    MSG_PUTS(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    MSG_PUTS(_(\"with X11-neXtaw GUI.\"));\n#    else\n    MSG_PUTS(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#     ifdef FEAT_GUI_PHOTON\n    MSG_PUTS(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    MSG_PUTS(_(\"with GUI.\"));\n#      else\n#\tif defined(TARGET_API_MAC_CARBON) && TARGET_API_MAC_CARBON\n    MSG_PUTS(_(\"with Carbon GUI.\"));\n#\telse\n#\t if defined(TARGET_API_MAC_OSX) && TARGET_API_MAC_OSX\n    MSG_PUTS(_(\"with Cocoa GUI.\"));\n#\t else\n#\t  if defined(MACOS)\n    MSG_PUTS(_(\"with (classic) GUI.\"));\n#\t  endif\n#\t endif\n#\tendif\n#      endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n */\n    static void\nversion_msg(char *s)\n{\n    int\t\tlen = (int)STRLEN(s);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n\tMSG_PUTS(s);\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (bufempty()\n\t    && curbuf->b_fname == NULL\n#ifdef FEAT_WINDOWS\n\t    && firstwin->w_next == NULL\n#endif\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    void\nintro_message(\n    int\t\tcolon)\t\t/* TRUE for \":intro\" */\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    /* blanklines = screen height - # message lines */\n    blanklines = (int)Rows - ((sizeof(lines) / sizeof(char *)) - 1);\n    if (!p_cp)\n\tblanklines += 4;  /* add 4 for not showing \"Vi compatible\" message */\n\n#ifdef FEAT_WINDOWS\n    /* Don't overwrite a statusline.  Depends on 'cmdheight'. */\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n#endif\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    /* Show the sponsor and register message one out of four times, the Uganda\n     * message two out of four times. */\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    /* start displaying the message lines after half of the blank lines */\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)(sizeof(lines) / sizeof(char *)); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    /* Make the wait-return message appear just below the text. */\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    /* Center the message horizontally. */\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    /* Check for 9.9x or 9.9xx, alpha/beta version */\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    /* Split up in parts to highlight <> items differently. */\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n#ifdef FEAT_MBYTE\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n#endif\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? hl_attr(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    /* Add the version number to the version line. */\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * undo.c: multi level undo facility\n *\n * The saved lines are stored in a list of lists (one for each buffer):\n *\n * b_u_oldhead------------------------------------------------+\n *\t\t\t\t\t\t\t      |\n *\t\t\t\t\t\t\t      V\n *\t\t  +--------------+    +--------------+\t  +--------------+\n * b_u_newhead--->| u_header\t |    | u_header     |\t  | u_header\t |\n *\t\t  |\tuh_next------>|     uh_next------>|\tuh_next---->NULL\n *\t   NULL<--------uh_prev  |<---------uh_prev  |<---------uh_prev  |\n *\t\t  |\tuh_entry |    |     uh_entry |\t  |\tuh_entry |\n *\t\t  +--------|-----+    +--------|-----+\t  +--------|-----+\n *\t\t\t   |\t\t       |\t\t   |\n *\t\t\t   V\t\t       V\t\t   V\n *\t\t  +--------------+    +--------------+\t  +--------------+\n *\t\t  | u_entry\t |    | u_entry      |\t  | u_entry\t |\n *\t\t  |\tue_next  |    |     ue_next  |\t  |\tue_next  |\n *\t\t  +--------|-----+    +--------|-----+\t  +--------|-----+\n *\t\t\t   |\t\t       |\t\t   |\n *\t\t\t   V\t\t       V\t\t   V\n *\t\t  +--------------+\t      NULL\t\t  NULL\n *\t\t  | u_entry\t |\n *\t\t  |\tue_next  |\n *\t\t  +--------|-----+\n *\t\t\t   |\n *\t\t\t   V\n *\t\t\t  etc.\n *\n * Each u_entry list contains the information for one undo or redo.\n * curbuf->b_u_curhead points to the header of the last undo (the next redo),\n * or is NULL if nothing has been undone (end of the branch).\n *\n * For keeping alternate undo/redo branches the uh_alt field is used.  Thus at\n * each point in the list a branch may appear for an alternate to redo.  The\n * uh_seq field is numbered sequentially to be able to find a newer or older\n * branch.\n *\n *\t\t   +---------------+\t+---------------+\n * b_u_oldhead --->| u_header\t   |\t| u_header\t|\n *\t\t   |   uh_alt_next ---->|   uh_alt_next ----> NULL\n *\t   NULL <----- uh_alt_prev |<------ uh_alt_prev |\n *\t\t   |   uh_prev\t   |\t|   uh_prev\t|\n *\t\t   +-----|---------+\t+-----|---------+\n *\t\t\t |\t\t      |\n *\t\t\t V\t\t      V\n *\t\t   +---------------+\t+---------------+\n *\t\t   | u_header\t   |\t| u_header\t|\n *\t\t   |   uh_alt_next |\t|   uh_alt_next |\n * b_u_newhead --->|   uh_alt_prev |\t|   uh_alt_prev |\n *\t\t   |   uh_prev\t   |\t|   uh_prev\t|\n *\t\t   +-----|---------+\t+-----|---------+\n *\t\t\t |\t\t      |\n *\t\t\t V\t\t      V\n *\t\t       NULL\t\t+---------------+    +---------------+\n *\t\t\t\t\t| u_header\t|    | u_header      |\n *\t\t\t\t\t|   uh_alt_next ---->|\t uh_alt_next |\n *\t\t\t\t\t|   uh_alt_prev |<------ uh_alt_prev |\n *\t\t\t\t\t|   uh_prev\t|    |\t uh_prev     |\n *\t\t\t\t\t+-----|---------+    +-----|---------+\n *\t\t\t\t\t      |\t\t\t   |\n *\t\t\t\t\t     etc.\t\t  etc.\n *\n *\n * All data is allocated and will all be freed when the buffer is unloaded.\n */\n\n/* Uncomment the next line for including the u_check() function.  This warns\n * for errors in the debug information. */\n/* #define U_DEBUG 1 */\n#define UH_MAGIC 0x18dade\t/* value for uh_magic when in use */\n#define UE_MAGIC 0xabc123\t/* value for ue_magic when in use */\n\n/* Size of buffer used for encryption. */\n#define CRYPT_BUF_SIZE 8192\n\n#include \"vim.h\"\n\n/* Structure passed around between functions.\n * Avoids passing cryptstate_T when encryption not available. */\ntypedef struct {\n    buf_T\t*bi_buf;\n    FILE\t*bi_fp;\n#ifdef FEAT_CRYPT\n    cryptstate_T *bi_state;\n    char_u\t*bi_buffer; /* CRYPT_BUF_SIZE, NULL when not buffering */\n    size_t\tbi_used;    /* bytes written to/read from bi_buffer */\n    size_t\tbi_avail;   /* bytes available in bi_buffer */\n#endif\n} bufinfo_T;\n\n\nstatic long get_undolevel(void);\nstatic void u_unch_branch(u_header_T *uhp);\nstatic u_entry_T *u_get_headentry(void);\nstatic void u_getbot(void);\nstatic void u_doit(int count);\nstatic void u_undoredo(int undo);\nstatic void u_undo_end(int did_undo, int absolute);\nstatic void u_add_time(char_u *buf, size_t buflen, time_t tt);\nstatic void u_freeheader(buf_T *buf, u_header_T *uhp, u_header_T **uhpp);\nstatic void u_freebranch(buf_T *buf, u_header_T *uhp, u_header_T **uhpp);\nstatic void u_freeentries(buf_T *buf, u_header_T *uhp, u_header_T **uhpp);\nstatic void u_freeentry(u_entry_T *, long);\n#ifdef FEAT_PERSISTENT_UNDO\nstatic void corruption_error(char *mesg, char_u *file_name);\nstatic void u_free_uhp(u_header_T *uhp);\nstatic int undo_write(bufinfo_T *bi, char_u *ptr, size_t len);\n# ifdef FEAT_CRYPT\nstatic int undo_flush(bufinfo_T *bi);\n# endif\nstatic int fwrite_crypt(bufinfo_T *bi, char_u *ptr, size_t len);\nstatic int undo_write_bytes(bufinfo_T *bi, long_u nr, int len);\nstatic void put_header_ptr(bufinfo_T *bi, u_header_T *uhp);\nstatic int undo_read_4c(bufinfo_T *bi);\nstatic int undo_read_2c(bufinfo_T *bi);\nstatic int undo_read_byte(bufinfo_T *bi);\nstatic time_t undo_read_time(bufinfo_T *bi);\nstatic int undo_read(bufinfo_T *bi, char_u *buffer, size_t size);\nstatic char_u *read_string_decrypt(bufinfo_T *bi, int len);\nstatic int serialize_header(bufinfo_T *bi, char_u *hash);\nstatic int serialize_uhp(bufinfo_T *bi, u_header_T *uhp);\nstatic u_header_T *unserialize_uhp(bufinfo_T *bi, char_u *file_name);\nstatic int serialize_uep(bufinfo_T *bi, u_entry_T *uep);\nstatic u_entry_T *unserialize_uep(bufinfo_T *bi, int *error, char_u *file_name);\nstatic void serialize_pos(bufinfo_T *bi, pos_T pos);\nstatic void unserialize_pos(bufinfo_T *bi, pos_T *pos);\nstatic void serialize_visualinfo(bufinfo_T *bi, visualinfo_T *info);\nstatic void unserialize_visualinfo(bufinfo_T *bi, visualinfo_T *info);\n#endif\n\n#define U_ALLOC_LINE(size) lalloc((long_u)(size), FALSE)\nstatic char_u *u_save_line(linenr_T);\n\n/* used in undo_end() to report number of added and deleted lines */\nstatic long\tu_newcount, u_oldcount;\n\n/*\n * When 'u' flag included in 'cpoptions', we behave like vi.  Need to remember\n * the action that \"u\" should do.\n */\nstatic int\tundo_undoes = FALSE;\n\nstatic int\tlastmark = 0;\n\n#if defined(U_DEBUG) || defined(PROTO)\n/*\n * Check the undo structures for being valid.  Print a warning when something\n * looks wrong.\n */\nstatic int seen_b_u_curhead;\nstatic int seen_b_u_newhead;\nstatic int header_count;\n\n    static void\nu_check_tree(u_header_T *uhp,\n\tu_header_T *exp_uh_next,\n\tu_header_T *exp_uh_alt_prev)\n{\n    u_entry_T *uep;\n\n    if (uhp == NULL)\n\treturn;\n    ++header_count;\n    if (uhp == curbuf->b_u_curhead && ++seen_b_u_curhead > 1)\n    {\n\tEMSG(\"b_u_curhead found twice (looping?)\");\n\treturn;\n    }\n    if (uhp == curbuf->b_u_newhead && ++seen_b_u_newhead > 1)\n    {\n\tEMSG(\"b_u_newhead found twice (looping?)\");\n\treturn;\n    }\n\n    if (uhp->uh_magic != UH_MAGIC)\n\tEMSG(\"uh_magic wrong (may be using freed memory)\");\n    else\n    {\n\t/* Check pointers back are correct. */\n\tif (uhp->uh_next.ptr != exp_uh_next)\n\t{\n\t    EMSG(\"uh_next wrong\");\n\t    smsg((char_u *)\"expected: 0x%x, actual: 0x%x\",\n\t\t\t\t\t       exp_uh_next, uhp->uh_next.ptr);\n\t}\n\tif (uhp->uh_alt_prev.ptr != exp_uh_alt_prev)\n\t{\n\t    EMSG(\"uh_alt_prev wrong\");\n\t    smsg((char_u *)\"expected: 0x%x, actual: 0x%x\",\n\t\t\t\t       exp_uh_alt_prev, uhp->uh_alt_prev.ptr);\n\t}\n\n\t/* Check the undo tree at this header. */\n\tfor (uep = uhp->uh_entry; uep != NULL; uep = uep->ue_next)\n\t{\n\t    if (uep->ue_magic != UE_MAGIC)\n\t    {\n\t\tEMSG(\"ue_magic wrong (may be using freed memory)\");\n\t\tbreak;\n\t    }\n\t}\n\n\t/* Check the next alt tree. */\n\tu_check_tree(uhp->uh_alt_next.ptr, uhp->uh_next.ptr, uhp);\n\n\t/* Check the next header in this branch. */\n\tu_check_tree(uhp->uh_prev.ptr, uhp, NULL);\n    }\n}\n\n    static void\nu_check(int newhead_may_be_NULL)\n{\n    seen_b_u_newhead = 0;\n    seen_b_u_curhead = 0;\n    header_count = 0;\n\n    u_check_tree(curbuf->b_u_oldhead, NULL, NULL);\n\n    if (seen_b_u_newhead == 0 && curbuf->b_u_oldhead != NULL\n\t    && !(newhead_may_be_NULL && curbuf->b_u_newhead == NULL))\n\tEMSGN(\"b_u_newhead invalid: 0x%x\", curbuf->b_u_newhead);\n    if (curbuf->b_u_curhead != NULL && seen_b_u_curhead == 0)\n\tEMSGN(\"b_u_curhead invalid: 0x%x\", curbuf->b_u_curhead);\n    if (header_count != curbuf->b_u_numhead)\n    {\n\tEMSG(\"b_u_numhead invalid\");\n\tsmsg((char_u *)\"expected: %ld, actual: %ld\",\n\t\t\t       (long)header_count, (long)curbuf->b_u_numhead);\n    }\n}\n#endif\n\n/*\n * Save the current line for both the \"u\" and \"U\" command.\n * Careful: may trigger autocommands that reload the buffer.\n * Returns OK or FAIL.\n */\n    int\nu_save_cursor(void)\n{\n    return (u_save((linenr_T)(curwin->w_cursor.lnum - 1),\n\t\t\t\t      (linenr_T)(curwin->w_cursor.lnum + 1)));\n}\n\n/*\n * Save the lines between \"top\" and \"bot\" for both the \"u\" and \"U\" command.\n * \"top\" may be 0 and bot may be curbuf->b_ml.ml_line_count + 1.\n * Careful: may trigger autocommands that reload the buffer.\n * Returns FAIL when lines could not be saved, OK otherwise.\n */\n    int\nu_save(linenr_T top, linenr_T bot)\n{\n    if (undo_off)\n\treturn OK;\n\n    if (top > curbuf->b_ml.ml_line_count\n\t    || top >= bot\n\t    || bot > curbuf->b_ml.ml_line_count + 1)\n\treturn FALSE;\t/* rely on caller to do error messages */\n\n    if (top + 2 == bot)\n\tu_saveline((linenr_T)(top + 1));\n\n    return (u_savecommon(top, bot, (linenr_T)0, FALSE));\n}\n\n/*\n * Save the line \"lnum\" (used by \":s\" and \"~\" command).\n * The line is replaced, so the new bottom line is lnum + 1.\n * Careful: may trigger autocommands that reload the buffer.\n * Returns FAIL when lines could not be saved, OK otherwise.\n */\n    int\nu_savesub(linenr_T lnum)\n{\n    if (undo_off)\n\treturn OK;\n\n    return (u_savecommon(lnum - 1, lnum + 1, lnum + 1, FALSE));\n}\n\n/*\n * A new line is inserted before line \"lnum\" (used by :s command).\n * The line is inserted, so the new bottom line is lnum + 1.\n * Careful: may trigger autocommands that reload the buffer.\n * Returns FAIL when lines could not be saved, OK otherwise.\n */\n    int\nu_inssub(linenr_T lnum)\n{\n    if (undo_off)\n\treturn OK;\n\n    return (u_savecommon(lnum - 1, lnum, lnum + 1, FALSE));\n}\n\n/*\n * Save the lines \"lnum\" - \"lnum\" + nlines (used by delete command).\n * The lines are deleted, so the new bottom line is lnum, unless the buffer\n * becomes empty.\n * Careful: may trigger autocommands that reload the buffer.\n * Returns FAIL when lines could not be saved, OK otherwise.\n */\n    int\nu_savedel(linenr_T lnum, long nlines)\n{\n    if (undo_off)\n\treturn OK;\n\n    return (u_savecommon(lnum - 1, lnum + nlines,\n\t\t     nlines == curbuf->b_ml.ml_line_count ? 2 : lnum, FALSE));\n}\n\n/*\n * Return TRUE when undo is allowed.  Otherwise give an error message and\n * return FALSE.\n */\n    int\nundo_allowed(void)\n{\n    /* Don't allow changes when 'modifiable' is off.  */\n    if (!curbuf->b_p_ma)\n    {\n\tEMSG(_(e_modifiable));\n\treturn FALSE;\n    }\n\n#ifdef HAVE_SANDBOX\n    /* In the sandbox it's not allowed to change the text. */\n    if (sandbox != 0)\n    {\n\tEMSG(_(e_sandbox));\n\treturn FALSE;\n    }\n#endif\n\n    /* Don't allow changes in the buffer while editing the cmdline.  The\n     * caller of getcmdline() may get confused. */\n    if (textlock != 0)\n    {\n\tEMSG(_(e_secure));\n\treturn FALSE;\n    }\n\n    return TRUE;\n}\n\n/*\n * Get the undolevle value for the current buffer.\n */\n    static long\nget_undolevel(void)\n{\n    if (curbuf->b_p_ul == NO_LOCAL_UNDOLEVEL)\n\treturn p_ul;\n    return curbuf->b_p_ul;\n}\n\n/*\n * Common code for various ways to save text before a change.\n * \"top\" is the line above the first changed line.\n * \"bot\" is the line below the last changed line.\n * \"newbot\" is the new bottom line.  Use zero when not known.\n * \"reload\" is TRUE when saving for a buffer reload.\n * Careful: may trigger autocommands that reload the buffer.\n * Returns FAIL when lines could not be saved, OK otherwise.\n */\n    int\nu_savecommon(\n    linenr_T\ttop,\n    linenr_T\tbot,\n    linenr_T\tnewbot,\n    int\t\treload)\n{\n    linenr_T\tlnum;\n    long\ti;\n    u_header_T\t*uhp;\n    u_header_T\t*old_curhead;\n    u_entry_T\t*uep;\n    u_entry_T\t*prev_uep;\n    long\tsize;\n\n    if (!reload)\n    {\n\t/* When making changes is not allowed return FAIL.  It's a crude way\n\t * to make all change commands fail. */\n\tif (!undo_allowed())\n\t    return FAIL;\n\n#ifdef FEAT_NETBEANS_INTG\n\t/*\n\t * Netbeans defines areas that cannot be modified.  Bail out here when\n\t * trying to change text in a guarded area.\n\t */\n\tif (netbeans_active())\n\t{\n\t    if (netbeans_is_guarded(top, bot))\n\t    {\n\t\tEMSG(_(e_guarded));\n\t\treturn FAIL;\n\t    }\n\t    if (curbuf->b_p_ro)\n\t    {\n\t\tEMSG(_(e_nbreadonly));\n\t\treturn FAIL;\n\t    }\n\t}\n#endif\n\n#ifdef FEAT_AUTOCMD\n\t/*\n\t * Saving text for undo means we are going to make a change.  Give a\n\t * warning for a read-only file before making the change, so that the\n\t * FileChangedRO event can replace the buffer with a read-write version\n\t * (e.g., obtained from a source control system).\n\t */\n\tchange_warning(0);\n\tif (bot > curbuf->b_ml.ml_line_count + 1)\n\t{\n\t    /* This happens when the FileChangedRO autocommand changes the\n\t     * file in a way it becomes shorter. */\n\t    EMSG(_(\"E881: Line count changed unexpectedly\"));\n\t    return FAIL;\n\t}\n#endif\n    }\n\n#ifdef U_DEBUG\n    u_check(FALSE);\n#endif\n\n    size = bot - top - 1;\n\n    /*\n     * If curbuf->b_u_synced == TRUE make a new header.\n     */\n    if (curbuf->b_u_synced)\n    {\n#ifdef FEAT_JUMPLIST\n\t/* Need to create new entry in b_changelist. */\n\tcurbuf->b_new_change = TRUE;\n#endif\n\n\tif (get_undolevel() >= 0)\n\t{\n\t    /*\n\t     * Make a new header entry.  Do this first so that we don't mess\n\t     * up the undo info when out of memory.\n\t     */\n\t    uhp = (u_header_T *)U_ALLOC_LINE(sizeof(u_header_T));\n\t    if (uhp == NULL)\n\t\tgoto nomem;\n#ifdef U_DEBUG\n\t    uhp->uh_magic = UH_MAGIC;\n#endif\n\t}\n\telse\n\t    uhp = NULL;\n\n\t/*\n\t * If we undid more than we redid, move the entry lists before and\n\t * including curbuf->b_u_curhead to an alternate branch.\n\t */\n\told_curhead = curbuf->b_u_curhead;\n\tif (old_curhead != NULL)\n\t{\n\t    curbuf->b_u_newhead = old_curhead->uh_next.ptr;\n\t    curbuf->b_u_curhead = NULL;\n\t}\n\n\t/*\n\t * free headers to keep the size right\n\t */\n\twhile (curbuf->b_u_numhead > get_undolevel()\n\t\t\t\t\t       && curbuf->b_u_oldhead != NULL)\n\t{\n\t    u_header_T\t    *uhfree = curbuf->b_u_oldhead;\n\n\t    if (uhfree == old_curhead)\n\t\t/* Can't reconnect the branch, delete all of it. */\n\t\tu_freebranch(curbuf, uhfree, &old_curhead);\n\t    else if (uhfree->uh_alt_next.ptr == NULL)\n\t\t/* There is no branch, only free one header. */\n\t\tu_freeheader(curbuf, uhfree, &old_curhead);\n\t    else\n\t    {\n\t\t/* Free the oldest alternate branch as a whole. */\n\t\twhile (uhfree->uh_alt_next.ptr != NULL)\n\t\t    uhfree = uhfree->uh_alt_next.ptr;\n\t\tu_freebranch(curbuf, uhfree, &old_curhead);\n\t    }\n#ifdef U_DEBUG\n\t    u_check(TRUE);\n#endif\n\t}\n\n\tif (uhp == NULL)\t\t/* no undo at all */\n\t{\n\t    if (old_curhead != NULL)\n\t\tu_freebranch(curbuf, old_curhead, NULL);\n\t    curbuf->b_u_synced = FALSE;\n\t    return OK;\n\t}\n\n\tuhp->uh_prev.ptr = NULL;\n\tuhp->uh_next.ptr = curbuf->b_u_newhead;\n\tuhp->uh_alt_next.ptr = old_curhead;\n\tif (old_curhead != NULL)\n\t{\n\t    uhp->uh_alt_prev.ptr = old_curhead->uh_alt_prev.ptr;\n\t    if (uhp->uh_alt_prev.ptr != NULL)\n\t\tuhp->uh_alt_prev.ptr->uh_alt_next.ptr = uhp;\n\t    old_curhead->uh_alt_prev.ptr = uhp;\n\t    if (curbuf->b_u_oldhead == old_curhead)\n\t\tcurbuf->b_u_oldhead = uhp;\n\t}\n\telse\n\t    uhp->uh_alt_prev.ptr = NULL;\n\tif (curbuf->b_u_newhead != NULL)\n\t    curbuf->b_u_newhead->uh_prev.ptr = uhp;\n\n\tuhp->uh_seq = ++curbuf->b_u_seq_last;\n\tcurbuf->b_u_seq_cur = uhp->uh_seq;\n\tuhp->uh_time = vim_time();\n\tuhp->uh_save_nr = 0;\n\tcurbuf->b_u_time_cur = uhp->uh_time + 1;\n\n\tuhp->uh_walk = 0;\n\tuhp->uh_entry = NULL;\n\tuhp->uh_getbot_entry = NULL;\n\tuhp->uh_cursor = curwin->w_cursor;\t/* save cursor pos. for undo */\n#ifdef FEAT_VIRTUALEDIT\n\tif (virtual_active() && curwin->w_cursor.coladd > 0)\n\t    uhp->uh_cursor_vcol = getviscol();\n\telse\n\t    uhp->uh_cursor_vcol = -1;\n#endif\n\n\t/* save changed and buffer empty flag for undo */\n\tuhp->uh_flags = (curbuf->b_changed ? UH_CHANGED : 0) +\n\t\t       ((curbuf->b_ml.ml_flags & ML_EMPTY) ? UH_EMPTYBUF : 0);\n\n\t/* save named marks and Visual marks for undo */\n\tmch_memmove(uhp->uh_namedm, curbuf->b_namedm, sizeof(pos_T) * NMARKS);\n\tuhp->uh_visual = curbuf->b_visual;\n\n\tcurbuf->b_u_newhead = uhp;\n\tif (curbuf->b_u_oldhead == NULL)\n\t    curbuf->b_u_oldhead = uhp;\n\t++curbuf->b_u_numhead;\n    }\n    else\n    {\n\tif (get_undolevel() < 0)\t/* no undo at all */\n\t    return OK;\n\n\t/*\n\t * When saving a single line, and it has been saved just before, it\n\t * doesn't make sense saving it again.  Saves a lot of memory when\n\t * making lots of changes inside the same line.\n\t * This is only possible if the previous change didn't increase or\n\t * decrease the number of lines.\n\t * Check the ten last changes.  More doesn't make sense and takes too\n\t * long.\n\t */\n\tif (size == 1)\n\t{\n\t    uep = u_get_headentry();\n\t    prev_uep = NULL;\n\t    for (i = 0; i < 10; ++i)\n\t    {\n\t\tif (uep == NULL)\n\t\t    break;\n\n\t\t/* If lines have been inserted/deleted we give up.\n\t\t * Also when the line was included in a multi-line save. */\n\t\tif ((curbuf->b_u_newhead->uh_getbot_entry != uep\n\t\t\t    ? (uep->ue_top + uep->ue_size + 1\n\t\t\t\t!= (uep->ue_bot == 0\n\t\t\t\t    ? curbuf->b_ml.ml_line_count + 1\n\t\t\t\t    : uep->ue_bot))\n\t\t\t    : uep->ue_lcount != curbuf->b_ml.ml_line_count)\n\t\t\t|| (uep->ue_size > 1\n\t\t\t    && top >= uep->ue_top\n\t\t\t    && top + 2 <= uep->ue_top + uep->ue_size + 1))\n\t\t    break;\n\n\t\t/* If it's the same line we can skip saving it again. */\n\t\tif (uep->ue_size == 1 && uep->ue_top == top)\n\t\t{\n\t\t    if (i > 0)\n\t\t    {\n\t\t\t/* It's not the last entry: get ue_bot for the last\n\t\t\t * entry now.  Following deleted/inserted lines go to\n\t\t\t * the re-used entry. */\n\t\t\tu_getbot();\n\t\t\tcurbuf->b_u_synced = FALSE;\n\n\t\t\t/* Move the found entry to become the last entry.  The\n\t\t\t * order of undo/redo doesn't matter for the entries\n\t\t\t * we move it over, since they don't change the line\n\t\t\t * count and don't include this line.  It does matter\n\t\t\t * for the found entry if the line count is changed by\n\t\t\t * the executed command. */\n\t\t\tprev_uep->ue_next = uep->ue_next;\n\t\t\tuep->ue_next = curbuf->b_u_newhead->uh_entry;\n\t\t\tcurbuf->b_u_newhead->uh_entry = uep;\n\t\t    }\n\n\t\t    /* The executed command may change the line count. */\n\t\t    if (newbot != 0)\n\t\t\tuep->ue_bot = newbot;\n\t\t    else if (bot > curbuf->b_ml.ml_line_count)\n\t\t\tuep->ue_bot = 0;\n\t\t    else\n\t\t    {\n\t\t\tuep->ue_lcount = curbuf->b_ml.ml_line_count;\n\t\t\tcurbuf->b_u_newhead->uh_getbot_entry = uep;\n\t\t    }\n\t\t    return OK;\n\t\t}\n\t\tprev_uep = uep;\n\t\tuep = uep->ue_next;\n\t    }\n\t}\n\n\t/* find line number for ue_bot for previous u_save() */\n\tu_getbot();\n    }\n\n#if !defined(UNIX) && !defined(WIN32)\n\t/*\n\t * With Amiga we can't handle big undo's, because\n\t * then u_alloc_line would have to allocate a block larger than 32K\n\t */\n    if (size >= 8000)\n\tgoto nomem;\n#endif\n\n    /*\n     * add lines in front of entry list\n     */\n    uep = (u_entry_T *)U_ALLOC_LINE(sizeof(u_entry_T));\n    if (uep == NULL)\n\tgoto nomem;\n    vim_memset(uep, 0, sizeof(u_entry_T));\n#ifdef U_DEBUG\n    uep->ue_magic = UE_MAGIC;\n#endif\n\n    uep->ue_size = size;\n    uep->ue_top = top;\n    if (newbot != 0)\n\tuep->ue_bot = newbot;\n    /*\n     * Use 0 for ue_bot if bot is below last line.\n     * Otherwise we have to compute ue_bot later.\n     */\n    else if (bot > curbuf->b_ml.ml_line_count)\n\tuep->ue_bot = 0;\n    else\n    {\n\tuep->ue_lcount = curbuf->b_ml.ml_line_count;\n\tcurbuf->b_u_newhead->uh_getbot_entry = uep;\n    }\n\n    if (size > 0)\n    {\n\tif ((uep->ue_array = (char_u **)U_ALLOC_LINE(\n\t\t\t\t\t    sizeof(char_u *) * size)) == NULL)\n\t{\n\t    u_freeentry(uep, 0L);\n\t    goto nomem;\n\t}\n\tfor (i = 0, lnum = top + 1; i < size; ++i)\n\t{\n\t    fast_breakcheck();\n\t    if (got_int)\n\t    {\n\t\tu_freeentry(uep, i);\n\t\treturn FAIL;\n\t    }\n\t    if ((uep->ue_array[i] = u_save_line(lnum++)) == NULL)\n\t    {\n\t\tu_freeentry(uep, i);\n\t\tgoto nomem;\n\t    }\n\t}\n    }\n    else\n\tuep->ue_array = NULL;\n    uep->ue_next = curbuf->b_u_newhead->uh_entry;\n    curbuf->b_u_newhead->uh_entry = uep;\n    curbuf->b_u_synced = FALSE;\n    undo_undoes = FALSE;\n\n#ifdef U_DEBUG\n    u_check(FALSE);\n#endif\n    return OK;\n\nnomem:\n    msg_silent = 0;\t/* must display the prompt */\n    if (ask_yesno((char_u *)_(\"No undo possible; continue anyway\"), TRUE)\n\t\t\t\t\t\t\t\t       == 'y')\n    {\n\tundo_off = TRUE;\t    /* will be reset when character typed */\n\treturn OK;\n    }\n    do_outofmem_msg((long_u)0);\n    return FAIL;\n}\n\n#if defined(FEAT_PERSISTENT_UNDO) || defined(PROTO)\n\n# define UF_START_MAGIC\t    \"Vim\\237UnDo\\345\"  /* magic at start of undofile */\n# define UF_START_MAGIC_LEN\t9\n# define UF_HEADER_MAGIC\t0x5fd0\t/* magic at start of header */\n# define UF_HEADER_END_MAGIC\t0xe7aa\t/* magic after last header */\n# define UF_ENTRY_MAGIC\t\t0xf518\t/* magic at start of entry */\n# define UF_ENTRY_END_MAGIC\t0x3581\t/* magic after last entry */\n# define UF_VERSION\t\t2\t/* 2-byte undofile version number */\n# define UF_VERSION_CRYPT\t0x8002\t/* idem, encrypted */\n\n/* extra fields for header */\n# define UF_LAST_SAVE_NR\t1\n\n/* extra fields for uhp */\n# define UHP_SAVE_NR\t\t1\n\nstatic char_u e_not_open[] = N_(\"E828: Cannot open undo file for writing: %s\");\n\n/*\n * Compute the hash for the current buffer text into hash[UNDO_HASH_SIZE].\n */\n    void\nu_compute_hash(char_u *hash)\n{\n    context_sha256_T\tctx;\n    linenr_T\t\tlnum;\n    char_u\t\t*p;\n\n    sha256_start(&ctx);\n    for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum)\n    {\n\tp = ml_get(lnum);\n\tsha256_update(&ctx, p, (UINT32_T)(STRLEN(p) + 1));\n    }\n    sha256_finish(&ctx, hash);\n}\n\n/*\n * Return an allocated string of the full path of the target undofile.\n * When \"reading\" is TRUE find the file to read, go over all directories in\n * 'undodir'.\n * When \"reading\" is FALSE use the first name where the directory exists.\n * Returns NULL when there is no place to write or no file to read.\n */\n    char_u *\nu_get_undo_file_name(char_u *buf_ffname, int reading)\n{\n    char_u\t*dirp;\n    char_u\tdir_name[IOSIZE + 1];\n    char_u\t*munged_name = NULL;\n    char_u\t*undo_file_name = NULL;\n    int\t\tdir_len;\n    char_u\t*p;\n    stat_T\tst;\n    char_u\t*ffname = buf_ffname;\n#ifdef HAVE_READLINK\n    char_u\tfname_buf[MAXPATHL];\n#endif\n\n    if (ffname == NULL)\n\treturn NULL;\n\n#ifdef HAVE_READLINK\n    /* Expand symlink in the file name, so that we put the undo file with the\n     * actual file instead of with the symlink. */\n    if (resolve_symlink(ffname, fname_buf) == OK)\n\tffname = fname_buf;\n#endif\n\n    /* Loop over 'undodir'.  When reading find the first file that exists.\n     * When not reading use the first directory that exists or \".\". */\n    dirp = p_udir;\n    while (*dirp != NUL)\n    {\n\tdir_len = copy_option_part(&dirp, dir_name, IOSIZE, \",\");\n\tif (dir_len == 1 && dir_name[0] == '.')\n\t{\n\t    /* Use same directory as the ffname,\n\t     * \"dir/name\" -> \"dir/.name.un~\" */\n\t    undo_file_name = vim_strnsave(ffname, (int)(STRLEN(ffname) + 5));\n\t    if (undo_file_name == NULL)\n\t\tbreak;\n\t    p = gettail(undo_file_name);\n#ifdef VMS\n\t    /* VMS can not handle more than one dot in the filenames\n\t     * use \"dir/name\" -> \"dir/_un_name\" - add _un_\n\t     * at the beginning to keep the extension */\n\t    mch_memmove(p + 4,  p, STRLEN(p) + 1);\n\t    mch_memmove(p, \"_un_\", 4);\n\n#else\n\t    /* Use same directory as the ffname,\n\t     * \"dir/name\" -> \"dir/.name.un~\" */\n\t    mch_memmove(p + 1, p, STRLEN(p) + 1);\n\t    *p = '.';\n\t    STRCAT(p, \".un~\");\n#endif\n\t}\n\telse\n\t{\n\t    dir_name[dir_len] = NUL;\n\t    if (mch_isdir(dir_name))\n\t    {\n\t\tif (munged_name == NULL)\n\t\t{\n\t\t    munged_name = vim_strsave(ffname);\n\t\t    if (munged_name == NULL)\n\t\t\treturn NULL;\n\t\t    for (p = munged_name; *p != NUL; mb_ptr_adv(p))\n\t\t\tif (vim_ispathsep(*p))\n\t\t\t    *p = '%';\n\t\t}\n\t\tundo_file_name = concat_fnames(dir_name, munged_name, TRUE);\n\t    }\n\t}\n\n\t/* When reading check if the file exists. */\n\tif (undo_file_name != NULL && (!reading\n\t\t\t       || mch_stat((char *)undo_file_name, &st) >= 0))\n\t    break;\n\tvim_free(undo_file_name);\n\tundo_file_name = NULL;\n    }\n\n    vim_free(munged_name);\n    return undo_file_name;\n}\n\n    static void\ncorruption_error(char *mesg, char_u *file_name)\n{\n    EMSG3(_(\"E825: Corrupted undo file (%s): %s\"), mesg, file_name);\n}\n\n    static void\nu_free_uhp(u_header_T *uhp)\n{\n    u_entry_T\t*nuep;\n    u_entry_T\t*uep;\n\n    uep = uhp->uh_entry;\n    while (uep != NULL)\n    {\n\tnuep = uep->ue_next;\n\tu_freeentry(uep, uep->ue_size);\n\tuep = nuep;\n    }\n    vim_free(uhp);\n}\n\n/*\n * Write a sequence of bytes to the undo file.\n * Buffers and encrypts as needed.\n * Returns OK or FAIL.\n */\n    static int\nundo_write(bufinfo_T *bi, char_u *ptr, size_t len)\n{\n#ifdef FEAT_CRYPT\n    if (bi->bi_buffer != NULL)\n    {\n\tsize_t\tlen_todo = len;\n\tchar_u  *p = ptr;\n\n\twhile (bi->bi_used + len_todo >= CRYPT_BUF_SIZE)\n\t{\n\t    size_t\tn = CRYPT_BUF_SIZE - bi->bi_used;\n\n\t    mch_memmove(bi->bi_buffer + bi->bi_used, p, n);\n\t    len_todo -= n;\n\t    p += n;\n\t    bi->bi_used = CRYPT_BUF_SIZE;\n\t    if (undo_flush(bi) == FAIL)\n\t\treturn FAIL;\n\t}\n\tif (len_todo > 0)\n\t{\n\t    mch_memmove(bi->bi_buffer + bi->bi_used, p, len_todo);\n\t    bi->bi_used += len_todo;\n\t}\n\treturn OK;\n    }\n#endif\n    if (fwrite(ptr, len, (size_t)1, bi->bi_fp) != 1)\n\treturn FAIL;\n    return OK;\n}\n\n#ifdef FEAT_CRYPT\n    static int\nundo_flush(bufinfo_T *bi)\n{\n    if (bi->bi_buffer != NULL && bi->bi_used > 0)\n    {\n\tcrypt_encode_inplace(bi->bi_state, bi->bi_buffer, bi->bi_used);\n\tif (fwrite(bi->bi_buffer, bi->bi_used, (size_t)1, bi->bi_fp) != 1)\n\t    return FAIL;\n\tbi->bi_used = 0;\n    }\n    return OK;\n}\n#endif\n\n/*\n * Write \"ptr[len]\" and crypt the bytes when needed.\n * Returns OK or FAIL.\n */\n    static int\nfwrite_crypt(bufinfo_T *bi, char_u *ptr, size_t len)\n{\n#ifdef FEAT_CRYPT\n    char_u  *copy;\n    char_u  small_buf[100];\n    size_t  i;\n\n    if (bi->bi_state != NULL && bi->bi_buffer == NULL)\n    {\n\t/* crypting every piece of text separately */\n\tif (len < 100)\n\t    copy = small_buf;  /* no malloc()/free() for short strings */\n\telse\n\t{\n\t    copy = lalloc(len, FALSE);\n\t    if (copy == NULL)\n\t\treturn 0;\n\t}\n\tcrypt_encode(bi->bi_state, ptr, len, copy);\n\ti = fwrite(copy, len, (size_t)1, bi->bi_fp);\n\tif (copy != small_buf)\n\t    vim_free(copy);\n\treturn i == 1 ? OK : FAIL;\n    }\n#endif\n    return undo_write(bi, ptr, len);\n}\n\n/*\n * Write a number, MSB first, in \"len\" bytes.\n * Must match with undo_read_?c() functions.\n * Returns OK or FAIL.\n */\n    static int\nundo_write_bytes(bufinfo_T *bi, long_u nr, int len)\n{\n    char_u  buf[8];\n    int\t    i;\n    int\t    bufi = 0;\n\n    for (i = len - 1; i >= 0; --i)\n\tbuf[bufi++] = (char_u)(nr >> (i * 8));\n    return undo_write(bi, buf, (size_t)len);\n}\n\n/*\n * Write the pointer to an undo header.  Instead of writing the pointer itself\n * we use the sequence number of the header.  This is converted back to\n * pointers when reading. */\n    static void\nput_header_ptr(bufinfo_T *bi, u_header_T *uhp)\n{\n    undo_write_bytes(bi, (long_u)(uhp != NULL ? uhp->uh_seq : 0), 4);\n}\n\n    static int\nundo_read_4c(bufinfo_T *bi)\n{\n#ifdef FEAT_CRYPT\n    if (bi->bi_buffer != NULL)\n    {\n\tchar_u  buf[4];\n\tint\tn;\n\n\tundo_read(bi, buf, (size_t)4);\n\tn = ((unsigned)buf[0] << 24) + (buf[1] << 16) + (buf[2] << 8) + buf[3];\n\treturn n;\n    }\n#endif\n    return get4c(bi->bi_fp);\n}\n\n    static int\nundo_read_2c(bufinfo_T *bi)\n{\n#ifdef FEAT_CRYPT\n    if (bi->bi_buffer != NULL)\n    {\n\tchar_u  buf[2];\n\tint\tn;\n\n\tundo_read(bi, buf, (size_t)2);\n\tn = (buf[0] << 8) + buf[1];\n\treturn n;\n    }\n#endif\n    return get2c(bi->bi_fp);\n}\n\n    static int\nundo_read_byte(bufinfo_T *bi)\n{\n#ifdef FEAT_CRYPT\n    if (bi->bi_buffer != NULL)\n    {\n\tchar_u  buf[1];\n\n\tundo_read(bi, buf, (size_t)1);\n\treturn buf[0];\n    }\n#endif\n    return getc(bi->bi_fp);\n}\n\n    static time_t\nundo_read_time(bufinfo_T *bi)\n{\n#ifdef FEAT_CRYPT\n    if (bi->bi_buffer != NULL)\n    {\n\tchar_u  buf[8];\n\ttime_t\tn = 0;\n\tint\ti;\n\n\tundo_read(bi, buf, (size_t)8);\n\tfor (i = 0; i < 8; ++i)\n\t    n = (n << 8) + buf[i];\n\treturn n;\n    }\n#endif\n    return get8ctime(bi->bi_fp);\n}\n\n/*\n * Read \"buffer[size]\" from the undo file.\n * Return OK or FAIL.\n */\n    static int\nundo_read(bufinfo_T *bi, char_u *buffer, size_t size)\n{\n#ifdef FEAT_CRYPT\n    if (bi->bi_buffer != NULL)\n    {\n\tint\tsize_todo = (int)size;\n\tchar_u\t*p = buffer;\n\n\twhile (size_todo > 0)\n\t{\n\t    size_t n;\n\n\t    if (bi->bi_used >= bi->bi_avail)\n\t    {\n\t\tn = fread(bi->bi_buffer, 1, (size_t)CRYPT_BUF_SIZE, bi->bi_fp);\n\t\tif (n == 0)\n\t\t{\n\t\t    /* Error may be checked for only later.  Fill with zeros,\n\t\t     * so that the reader won't use garbage. */\n\t\t    vim_memset(p, 0, size_todo);\n\t\t    return FAIL;\n\t\t}\n\t\tbi->bi_avail = n;\n\t\tbi->bi_used = 0;\n\t\tcrypt_decode_inplace(bi->bi_state, bi->bi_buffer, bi->bi_avail);\n\t    }\n\t    n = size_todo;\n\t    if (n > bi->bi_avail - bi->bi_used)\n\t\tn = bi->bi_avail - bi->bi_used;\n\t    mch_memmove(p, bi->bi_buffer + bi->bi_used, n);\n\t    bi->bi_used += n;\n\t    size_todo -= (int)n;\n\t    p += n;\n\t}\n\treturn OK;\n    }\n#endif\n    if (fread(buffer, (size_t)size, 1, bi->bi_fp) != 1)\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Read a string of length \"len\" from \"bi->bi_fd\".\n * \"len\" can be zero to allocate an empty line.\n * Decrypt the bytes if needed.\n * Append a NUL.\n * Returns a pointer to allocated memory or NULL for failure.\n */\n    static char_u *\nread_string_decrypt(bufinfo_T *bi, int len)\n{\n    char_u  *ptr = alloc((unsigned)len + 1);\n\n    if (ptr != NULL)\n    {\n\tif (len > 0 && undo_read(bi, ptr, len) == FAIL)\n\t{\n\t    vim_free(ptr);\n\t    return NULL;\n\t}\n\tptr[len] = NUL;\n#ifdef FEAT_CRYPT\n\tif (bi->bi_state != NULL && bi->bi_buffer == NULL)\n\t    crypt_decode_inplace(bi->bi_state, ptr, len);\n#endif\n    }\n    return ptr;\n}\n\n/*\n * Writes the (not encrypted) header and initializes encryption if needed.\n */\n    static int\nserialize_header(bufinfo_T *bi, char_u *hash)\n{\n    int\t\tlen;\n    buf_T\t*buf = bi->bi_buf;\n    FILE\t*fp = bi->bi_fp;\n    char_u\ttime_buf[8];\n\n    /* Start writing, first the magic marker and undo info version. */\n    if (fwrite(UF_START_MAGIC, (size_t)UF_START_MAGIC_LEN, (size_t)1, fp) != 1)\n\treturn FAIL;\n\n    /* If the buffer is encrypted then all text bytes following will be\n     * encrypted.  Numbers and other info is not crypted. */\n#ifdef FEAT_CRYPT\n    if (*buf->b_p_key != NUL)\n    {\n\tchar_u *header;\n\tint    header_len;\n\n\tundo_write_bytes(bi, (long_u)UF_VERSION_CRYPT, 2);\n\tbi->bi_state = crypt_create_for_writing(crypt_get_method_nr(buf),\n\t\t\t\t\t  buf->b_p_key, &header, &header_len);\n\tif (bi->bi_state == NULL)\n\t    return FAIL;\n\tlen = (int)fwrite(header, (size_t)header_len, (size_t)1, fp);\n\tvim_free(header);\n\tif (len != 1)\n\t{\n\t    crypt_free_state(bi->bi_state);\n\t    bi->bi_state = NULL;\n\t    return FAIL;\n\t}\n\n\tif (crypt_whole_undofile(crypt_get_method_nr(buf)))\n\t{\n\t    bi->bi_buffer = alloc(CRYPT_BUF_SIZE);\n\t    if (bi->bi_buffer == NULL)\n\t    {\n\t\tcrypt_free_state(bi->bi_state);\n\t\tbi->bi_state = NULL;\n\t\treturn FAIL;\n\t    }\n\t    bi->bi_used = 0;\n\t}\n    }\n    else\n#endif\n\tundo_write_bytes(bi, (long_u)UF_VERSION, 2);\n\n\n    /* Write a hash of the buffer text, so that we can verify it is still the\n     * same when reading the buffer text. */\n    if (undo_write(bi, hash, (size_t)UNDO_HASH_SIZE) == FAIL)\n\treturn FAIL;\n\n    /* buffer-specific data */\n    undo_write_bytes(bi, (long_u)buf->b_ml.ml_line_count, 4);\n    len = buf->b_u_line_ptr != NULL ? (int)STRLEN(buf->b_u_line_ptr) : 0;\n    undo_write_bytes(bi, (long_u)len, 4);\n    if (len > 0 && fwrite_crypt(bi, buf->b_u_line_ptr, (size_t)len) == FAIL)\n\treturn FAIL;\n    undo_write_bytes(bi, (long_u)buf->b_u_line_lnum, 4);\n    undo_write_bytes(bi, (long_u)buf->b_u_line_colnr, 4);\n\n    /* Undo structures header data */\n    put_header_ptr(bi, buf->b_u_oldhead);\n    put_header_ptr(bi, buf->b_u_newhead);\n    put_header_ptr(bi, buf->b_u_curhead);\n\n    undo_write_bytes(bi, (long_u)buf->b_u_numhead, 4);\n    undo_write_bytes(bi, (long_u)buf->b_u_seq_last, 4);\n    undo_write_bytes(bi, (long_u)buf->b_u_seq_cur, 4);\n    time_to_bytes(buf->b_u_time_cur, time_buf);\n    undo_write(bi, time_buf, 8);\n\n    /* Optional fields. */\n    undo_write_bytes(bi, 4, 1);\n    undo_write_bytes(bi, UF_LAST_SAVE_NR, 1);\n    undo_write_bytes(bi, (long_u)buf->b_u_save_nr_last, 4);\n\n    undo_write_bytes(bi, 0, 1);  /* end marker */\n\n    return OK;\n}\n\n    static int\nserialize_uhp(bufinfo_T *bi, u_header_T *uhp)\n{\n    int\t\ti;\n    u_entry_T\t*uep;\n    char_u\ttime_buf[8];\n\n    if (undo_write_bytes(bi, (long_u)UF_HEADER_MAGIC, 2) == FAIL)\n\treturn FAIL;\n\n    put_header_ptr(bi, uhp->uh_next.ptr);\n    put_header_ptr(bi, uhp->uh_prev.ptr);\n    put_header_ptr(bi, uhp->uh_alt_next.ptr);\n    put_header_ptr(bi, uhp->uh_alt_prev.ptr);\n    undo_write_bytes(bi, uhp->uh_seq, 4);\n    serialize_pos(bi, uhp->uh_cursor);\n#ifdef FEAT_VIRTUALEDIT\n    undo_write_bytes(bi, (long_u)uhp->uh_cursor_vcol, 4);\n#else\n    undo_write_bytes(bi, (long_u)0, 4);\n#endif\n    undo_write_bytes(bi, (long_u)uhp->uh_flags, 2);\n    /* Assume NMARKS will stay the same. */\n    for (i = 0; i < NMARKS; ++i)\n\tserialize_pos(bi, uhp->uh_namedm[i]);\n    serialize_visualinfo(bi, &uhp->uh_visual);\n    time_to_bytes(uhp->uh_time, time_buf);\n    undo_write(bi, time_buf, 8);\n\n    /* Optional fields. */\n    undo_write_bytes(bi, 4, 1);\n    undo_write_bytes(bi, UHP_SAVE_NR, 1);\n    undo_write_bytes(bi, (long_u)uhp->uh_save_nr, 4);\n\n    undo_write_bytes(bi, 0, 1);  /* end marker */\n\n    /* Write all the entries. */\n    for (uep = uhp->uh_entry; uep != NULL; uep = uep->ue_next)\n    {\n\tundo_write_bytes(bi, (long_u)UF_ENTRY_MAGIC, 2);\n\tif (serialize_uep(bi, uep) == FAIL)\n\t    return FAIL;\n    }\n    undo_write_bytes(bi, (long_u)UF_ENTRY_END_MAGIC, 2);\n    return OK;\n}\n\n    static u_header_T *\nunserialize_uhp(bufinfo_T *bi, char_u *file_name)\n{\n    u_header_T\t*uhp;\n    int\t\ti;\n    u_entry_T\t*uep, *last_uep;\n    int\t\tc;\n    int\t\terror;\n\n    uhp = (u_header_T *)U_ALLOC_LINE(sizeof(u_header_T));\n    if (uhp == NULL)\n\treturn NULL;\n    vim_memset(uhp, 0, sizeof(u_header_T));\n#ifdef U_DEBUG\n    uhp->uh_magic = UH_MAGIC;\n#endif\n    uhp->uh_next.seq = undo_read_4c(bi);\n    uhp->uh_prev.seq = undo_read_4c(bi);\n    uhp->uh_alt_next.seq = undo_read_4c(bi);\n    uhp->uh_alt_prev.seq = undo_read_4c(bi);\n    uhp->uh_seq = undo_read_4c(bi);\n    if (uhp->uh_seq <= 0)\n    {\n\tcorruption_error(\"uh_seq\", file_name);\n\tvim_free(uhp);\n\treturn NULL;\n    }\n    unserialize_pos(bi, &uhp->uh_cursor);\n#ifdef FEAT_VIRTUALEDIT\n    uhp->uh_cursor_vcol = undo_read_4c(bi);\n#else\n    (void)undo_read_4c(bi);\n#endif\n    uhp->uh_flags = undo_read_2c(bi);\n    for (i = 0; i < NMARKS; ++i)\n\tunserialize_pos(bi, &uhp->uh_namedm[i]);\n    unserialize_visualinfo(bi, &uhp->uh_visual);\n    uhp->uh_time = undo_read_time(bi);\n\n    /* Optional fields. */\n    for (;;)\n    {\n\tint len = undo_read_byte(bi);\n\tint what;\n\n\tif (len == 0)\n\t    break;\n\twhat = undo_read_byte(bi);\n\tswitch (what)\n\t{\n\t    case UHP_SAVE_NR:\n\t\tuhp->uh_save_nr = undo_read_4c(bi);\n\t\tbreak;\n\t    default:\n\t\t/* field not supported, skip */\n\t\twhile (--len >= 0)\n\t\t    (void)undo_read_byte(bi);\n\t}\n    }\n\n    /* Unserialize the uep list. */\n    last_uep = NULL;\n    while ((c = undo_read_2c(bi)) == UF_ENTRY_MAGIC)\n    {\n\terror = FALSE;\n\tuep = unserialize_uep(bi, &error, file_name);\n\tif (last_uep == NULL)\n\t    uhp->uh_entry = uep;\n\telse\n\t    last_uep->ue_next = uep;\n\tlast_uep = uep;\n\tif (uep == NULL || error)\n\t{\n\t    u_free_uhp(uhp);\n\t    return NULL;\n\t}\n    }\n    if (c != UF_ENTRY_END_MAGIC)\n    {\n\tcorruption_error(\"entry end\", file_name);\n\tu_free_uhp(uhp);\n\treturn NULL;\n    }\n\n    return uhp;\n}\n\n/*\n * Serialize \"uep\".\n */\n    static int\nserialize_uep(\n    bufinfo_T\t*bi,\n    u_entry_T\t*uep)\n{\n    int\t\ti;\n    size_t\tlen;\n\n    undo_write_bytes(bi, (long_u)uep->ue_top, 4);\n    undo_write_bytes(bi, (long_u)uep->ue_bot, 4);\n    undo_write_bytes(bi, (long_u)uep->ue_lcount, 4);\n    undo_write_bytes(bi, (long_u)uep->ue_size, 4);\n    for (i = 0; i < uep->ue_size; ++i)\n    {\n\tlen = STRLEN(uep->ue_array[i]);\n\tif (undo_write_bytes(bi, (long_u)len, 4) == FAIL)\n\t    return FAIL;\n\tif (len > 0 && fwrite_crypt(bi, uep->ue_array[i], len) == FAIL)\n\t    return FAIL;\n    }\n    return OK;\n}\n\n    static u_entry_T *\nunserialize_uep(bufinfo_T *bi, int *error, char_u *file_name)\n{\n    int\t\ti;\n    u_entry_T\t*uep;\n    char_u\t**array = NULL;\n    char_u\t*line;\n    int\t\tline_len;\n\n    uep = (u_entry_T *)U_ALLOC_LINE(sizeof(u_entry_T));\n    if (uep == NULL)\n\treturn NULL;\n    vim_memset(uep, 0, sizeof(u_entry_T));\n#ifdef U_DEBUG\n    uep->ue_magic = UE_MAGIC;\n#endif\n    uep->ue_top = undo_read_4c(bi);\n    uep->ue_bot = undo_read_4c(bi);\n    uep->ue_lcount = undo_read_4c(bi);\n    uep->ue_size = undo_read_4c(bi);\n    if (uep->ue_size > 0)\n    {\n\tif (uep->ue_size < LONG_MAX / (int)sizeof(char_u *))\n\t    array = (char_u **)U_ALLOC_LINE(sizeof(char_u *) * uep->ue_size);\n\tif (array == NULL)\n\t{\n\t    *error = TRUE;\n\t    return uep;\n\t}\n\tvim_memset(array, 0, sizeof(char_u *) * uep->ue_size);\n    }\n    uep->ue_array = array;\n\n    for (i = 0; i < uep->ue_size; ++i)\n    {\n\tline_len = undo_read_4c(bi);\n\tif (line_len >= 0)\n\t    line = read_string_decrypt(bi, line_len);\n\telse\n\t{\n\t    line = NULL;\n\t    corruption_error(\"line length\", file_name);\n\t}\n\tif (line == NULL)\n\t{\n\t    *error = TRUE;\n\t    return uep;\n\t}\n\tarray[i] = line;\n    }\n    return uep;\n}\n\n/*\n * Serialize \"pos\".\n */\n    static void\nserialize_pos(bufinfo_T *bi, pos_T pos)\n{\n    undo_write_bytes(bi, (long_u)pos.lnum, 4);\n    undo_write_bytes(bi, (long_u)pos.col, 4);\n#ifdef FEAT_VIRTUALEDIT\n    undo_write_bytes(bi, (long_u)pos.coladd, 4);\n#else\n    undo_write_bytes(bi, (long_u)0, 4);\n#endif\n}\n\n/*\n * Unserialize the pos_T at the current position.\n */\n    static void\nunserialize_pos(bufinfo_T *bi, pos_T *pos)\n{\n    pos->lnum = undo_read_4c(bi);\n    if (pos->lnum < 0)\n\tpos->lnum = 0;\n    pos->col = undo_read_4c(bi);\n    if (pos->col < 0)\n\tpos->col = 0;\n#ifdef FEAT_VIRTUALEDIT\n    pos->coladd = undo_read_4c(bi);\n    if (pos->coladd < 0)\n\tpos->coladd = 0;\n#else\n    (void)undo_read_4c(bi);\n#endif\n}\n\n/*\n * Serialize \"info\".\n */\n    static void\nserialize_visualinfo(bufinfo_T *bi, visualinfo_T *info)\n{\n    serialize_pos(bi, info->vi_start);\n    serialize_pos(bi, info->vi_end);\n    undo_write_bytes(bi, (long_u)info->vi_mode, 4);\n    undo_write_bytes(bi, (long_u)info->vi_curswant, 4);\n}\n\n/*\n * Unserialize the visualinfo_T at the current position.\n */\n    static void\nunserialize_visualinfo(bufinfo_T *bi, visualinfo_T *info)\n{\n    unserialize_pos(bi, &info->vi_start);\n    unserialize_pos(bi, &info->vi_end);\n    info->vi_mode = undo_read_4c(bi);\n    info->vi_curswant = undo_read_4c(bi);\n}\n\n/*\n * Write the undo tree in an undo file.\n * When \"name\" is not NULL, use it as the name of the undo file.\n * Otherwise use buf->b_ffname to generate the undo file name.\n * \"buf\" must never be null, buf->b_ffname is used to obtain the original file\n * permissions.\n * \"forceit\" is TRUE for \":wundo!\", FALSE otherwise.\n * \"hash[UNDO_HASH_SIZE]\" must be the hash value of the buffer text.\n */\n    void\nu_write_undo(\n    char_u\t*name,\n    int\t\tforceit,\n    buf_T\t*buf,\n    char_u\t*hash)\n{\n    u_header_T\t*uhp;\n    char_u\t*file_name;\n    int\t\tmark;\n#ifdef U_DEBUG\n    int\t\theaders_written = 0;\n#endif\n    int\t\tfd;\n    FILE\t*fp = NULL;\n    int\t\tperm;\n    int\t\twrite_ok = FALSE;\n#ifdef UNIX\n    int\t\tst_old_valid = FALSE;\n    stat_T\tst_old;\n    stat_T\tst_new;\n#endif\n    bufinfo_T\tbi;\n\n    vim_memset(&bi, 0, sizeof(bi));\n\n    if (name == NULL)\n    {\n\tfile_name = u_get_undo_file_name(buf->b_ffname, FALSE);\n\tif (file_name == NULL)\n\t{\n\t    if (p_verbose > 0)\n\t    {\n\t\tverbose_enter();\n\t\tsmsg((char_u *)\n\t\t   _(\"Cannot write undo file in any directory in 'undodir'\"));\n\t\tverbose_leave();\n\t    }\n\t    return;\n\t}\n    }\n    else\n\tfile_name = name;\n\n    /*\n     * Decide about the permission to use for the undo file.  If the buffer\n     * has a name use the permission of the original file.  Otherwise only\n     * allow the user to access the undo file.\n     */\n    perm = 0600;\n    if (buf->b_ffname != NULL)\n    {\n#ifdef UNIX\n\tif (mch_stat((char *)buf->b_ffname, &st_old) >= 0)\n\t{\n\t    perm = st_old.st_mode;\n\t    st_old_valid = TRUE;\n\t}\n#else\n\tperm = mch_getperm(buf->b_ffname);\n\tif (perm < 0)\n\t    perm = 0600;\n#endif\n    }\n\n    /* strip any s-bit and executable bit */\n    perm = perm & 0666;\n\n    /* If the undo file already exists, verify that it actually is an undo\n     * file, and delete it. */\n    if (mch_getperm(file_name) >= 0)\n    {\n\tif (name == NULL || !forceit)\n\t{\n\t    /* Check we can read it and it's an undo file. */\n\t    fd = mch_open((char *)file_name, O_RDONLY|O_EXTRA, 0);\n\t    if (fd < 0)\n\t    {\n\t\tif (name != NULL || p_verbose > 0)\n\t\t{\n\t\t    if (name == NULL)\n\t\t\tverbose_enter();\n\t\t    smsg((char_u *)\n\t\t      _(\"Will not overwrite with undo file, cannot read: %s\"),\n\t\t\t\t\t\t\t\t   file_name);\n\t\t    if (name == NULL)\n\t\t\tverbose_leave();\n\t\t}\n\t\tgoto theend;\n\t    }\n\t    else\n\t    {\n\t\tchar_u\tmbuf[UF_START_MAGIC_LEN];\n\t\tint\tlen;\n\n\t\tlen = read_eintr(fd, mbuf, UF_START_MAGIC_LEN);\n\t\tclose(fd);\n\t\tif (len < UF_START_MAGIC_LEN\n\t\t      || memcmp(mbuf, UF_START_MAGIC, UF_START_MAGIC_LEN) != 0)\n\t\t{\n\t\t    if (name != NULL || p_verbose > 0)\n\t\t    {\n\t\t\tif (name == NULL)\n\t\t\t    verbose_enter();\n\t\t\tsmsg((char_u *)\n\t\t\t_(\"Will not overwrite, this is not an undo file: %s\"),\n\t\t\t\t\t\t\t\t   file_name);\n\t\t\tif (name == NULL)\n\t\t\t    verbose_leave();\n\t\t    }\n\t\t    goto theend;\n\t\t}\n\t    }\n\t}\n\tmch_remove(file_name);\n    }\n\n    /* If there is no undo information at all, quit here after deleting any\n     * existing undo file. */\n    if (buf->b_u_numhead == 0 && buf->b_u_line_ptr == NULL)\n    {\n\tif (p_verbose > 0)\n\t    verb_msg((char_u *)_(\"Skipping undo file write, nothing to undo\"));\n\tgoto theend;\n    }\n\n    fd = mch_open((char *)file_name,\n\t\t\t    O_CREAT|O_EXTRA|O_WRONLY|O_EXCL|O_NOFOLLOW, perm);\n    if (fd < 0)\n    {\n\tEMSG2(_(e_not_open), file_name);\n\tgoto theend;\n    }\n    (void)mch_setperm(file_name, perm);\n    if (p_verbose > 0)\n    {\n\tverbose_enter();\n\tsmsg((char_u *)_(\"Writing undo file: %s\"), file_name);\n\tverbose_leave();\n    }\n\n#ifdef U_DEBUG\n    /* Check there is no problem in undo info before writing. */\n    u_check(FALSE);\n#endif\n\n#ifdef UNIX\n    /*\n     * Try to set the group of the undo file same as the original file. If\n     * this fails, set the protection bits for the group same as the\n     * protection bits for others.\n     */\n    if (st_old_valid\n\t    && mch_stat((char *)file_name, &st_new) >= 0\n\t    && st_new.st_gid != st_old.st_gid\n# ifdef HAVE_FCHOWN  /* sequent-ptx lacks fchown() */\n\t    && fchown(fd, (uid_t)-1, st_old.st_gid) != 0\n# endif\n       )\n\tmch_setperm(file_name, (perm & 0707) | ((perm & 07) << 3));\n# if defined(HAVE_SELINUX) || defined(HAVE_SMACK)\n    if (buf->b_ffname != NULL)\n\tmch_copy_sec(buf->b_ffname, file_name);\n# endif\n#endif\n\n    fp = fdopen(fd, \"w\");\n    if (fp == NULL)\n    {\n\tEMSG2(_(e_not_open), file_name);\n\tclose(fd);\n\tmch_remove(file_name);\n\tgoto theend;\n    }\n\n    /* Undo must be synced. */\n    u_sync(TRUE);\n\n    /*\n     * Write the header.  Initializes encryption, if enabled.\n     */\n    bi.bi_buf = buf;\n    bi.bi_fp = fp;\n    if (serialize_header(&bi, hash) == FAIL)\n\tgoto write_error;\n\n    /*\n     * Iteratively serialize UHPs and their UEPs from the top down.\n     */\n    mark = ++lastmark;\n    uhp = buf->b_u_oldhead;\n    while (uhp != NULL)\n    {\n\t/* Serialize current UHP if we haven't seen it */\n\tif (uhp->uh_walk != mark)\n\t{\n\t    uhp->uh_walk = mark;\n#ifdef U_DEBUG\n\t    ++headers_written;\n#endif\n\t    if (serialize_uhp(&bi, uhp) == FAIL)\n\t\tgoto write_error;\n\t}\n\n\t/* Now walk through the tree - algorithm from undo_time(). */\n\tif (uhp->uh_prev.ptr != NULL && uhp->uh_prev.ptr->uh_walk != mark)\n\t    uhp = uhp->uh_prev.ptr;\n\telse if (uhp->uh_alt_next.ptr != NULL\n\t\t\t\t     && uhp->uh_alt_next.ptr->uh_walk != mark)\n\t    uhp = uhp->uh_alt_next.ptr;\n\telse if (uhp->uh_next.ptr != NULL && uhp->uh_alt_prev.ptr == NULL\n\t\t\t\t\t && uhp->uh_next.ptr->uh_walk != mark)\n\t    uhp = uhp->uh_next.ptr;\n\telse if (uhp->uh_alt_prev.ptr != NULL)\n\t    uhp = uhp->uh_alt_prev.ptr;\n\telse\n\t    uhp = uhp->uh_next.ptr;\n    }\n\n    if (undo_write_bytes(&bi, (long_u)UF_HEADER_END_MAGIC, 2) == OK)\n\twrite_ok = TRUE;\n#ifdef U_DEBUG\n    if (headers_written != buf->b_u_numhead)\n    {\n\tEMSGN(\"Written %ld headers, ...\", headers_written);\n\tEMSGN(\"... but numhead is %ld\", buf->b_u_numhead);\n    }\n#endif\n\n#ifdef FEAT_CRYPT\n    if (bi.bi_state != NULL && undo_flush(&bi) == FAIL)\n\twrite_ok = FALSE;\n#endif\n\nwrite_error:\n    fclose(fp);\n    if (!write_ok)\n\tEMSG2(_(\"E829: write error in undo file: %s\"), file_name);\n\n#if defined(MACOS_CLASSIC) || defined(WIN3264)\n    /* Copy file attributes; for systems where this can only be done after\n     * closing the file. */\n    if (buf->b_ffname != NULL)\n\t(void)mch_copy_file_attribute(buf->b_ffname, file_name);\n#endif\n#ifdef HAVE_ACL\n    if (buf->b_ffname != NULL)\n    {\n\tvim_acl_T\t    acl;\n\n\t/* For systems that support ACL: get the ACL from the original file. */\n\tacl = mch_get_acl(buf->b_ffname);\n\tmch_set_acl(file_name, acl);\n\tmch_free_acl(acl);\n    }\n#endif\n\ntheend:\n#ifdef FEAT_CRYPT\n    if (bi.bi_state != NULL)\n\tcrypt_free_state(bi.bi_state);\n    vim_free(bi.bi_buffer);\n#endif\n    if (file_name != name)\n\tvim_free(file_name);\n}\n\n/*\n * Load the undo tree from an undo file.\n * If \"name\" is not NULL use it as the undo file name.  This also means being\n * a bit more verbose.\n * Otherwise use curbuf->b_ffname to generate the undo file name.\n * \"hash[UNDO_HASH_SIZE]\" must be the hash value of the buffer text.\n */\n    void\nu_read_undo(char_u *name, char_u *hash, char_u *orig_name)\n{\n    char_u\t*file_name;\n    FILE\t*fp;\n    long\tversion, str_len;\n    char_u\t*line_ptr = NULL;\n    linenr_T\tline_lnum;\n    colnr_T\tline_colnr;\n    linenr_T\tline_count;\n    long\tnum_head = 0;\n    long\told_header_seq, new_header_seq, cur_header_seq;\n    long\tseq_last, seq_cur;\n    long\tlast_save_nr = 0;\n    short\told_idx = -1, new_idx = -1, cur_idx = -1;\n    long\tnum_read_uhps = 0;\n    time_t\tseq_time;\n    int\t\ti, j;\n    int\t\tc;\n    u_header_T\t*uhp;\n    u_header_T\t**uhp_table = NULL;\n    char_u\tread_hash[UNDO_HASH_SIZE];\n    char_u\tmagic_buf[UF_START_MAGIC_LEN];\n#ifdef U_DEBUG\n    int\t\t*uhp_table_used;\n#endif\n#ifdef UNIX\n    stat_T\tst_orig;\n    stat_T\tst_undo;\n#endif\n    bufinfo_T\tbi;\n\n    vim_memset(&bi, 0, sizeof(bi));\n    if (name == NULL)\n    {\n\tfile_name = u_get_undo_file_name(curbuf->b_ffname, TRUE);\n\tif (file_name == NULL)\n\t    return;\n\n#ifdef UNIX\n\t/* For safety we only read an undo file if the owner is equal to the\n\t * owner of the text file or equal to the current user. */\n\tif (mch_stat((char *)orig_name, &st_orig) >= 0\n\t\t&& mch_stat((char *)file_name, &st_undo) >= 0\n\t\t&& st_orig.st_uid != st_undo.st_uid\n\t\t&& st_undo.st_uid != getuid())\n\t{\n\t    if (p_verbose > 0)\n\t    {\n\t\tverbose_enter();\n\t\tsmsg((char_u *)_(\"Not reading undo file, owner differs: %s\"),\n\t\t\t\t\t\t\t\t   file_name);\n\t\tverbose_leave();\n\t    }\n\t    return;\n\t}\n#endif\n    }\n    else\n\tfile_name = name;\n\n    if (p_verbose > 0)\n    {\n\tverbose_enter();\n\tsmsg((char_u *)_(\"Reading undo file: %s\"), file_name);\n\tverbose_leave();\n    }\n\n    fp = mch_fopen((char *)file_name, \"r\");\n    if (fp == NULL)\n    {\n\tif (name != NULL || p_verbose > 0)\n\t    EMSG2(_(\"E822: Cannot open undo file for reading: %s\"), file_name);\n\tgoto error;\n    }\n    bi.bi_buf = curbuf;\n    bi.bi_fp = fp;\n\n    /*\n     * Read the undo file header.\n     */\n    if (fread(magic_buf, UF_START_MAGIC_LEN, 1, fp) != 1\n\t\t|| memcmp(magic_buf, UF_START_MAGIC, UF_START_MAGIC_LEN) != 0)\n    {\n\tEMSG2(_(\"E823: Not an undo file: %s\"), file_name);\n\tgoto error;\n    }\n    version = get2c(fp);\n    if (version == UF_VERSION_CRYPT)\n    {\n#ifdef FEAT_CRYPT\n\tif (*curbuf->b_p_key == NUL)\n\t{\n\t    EMSG2(_(\"E832: Non-encrypted file has encrypted undo file: %s\"),\n\t\t\t\t\t\t\t\t   file_name);\n\t    goto error;\n\t}\n\tbi.bi_state = crypt_create_from_file(fp, curbuf->b_p_key);\n\tif (bi.bi_state == NULL)\n\t{\n\t    EMSG2(_(\"E826: Undo file decryption failed: %s\"), file_name);\n\t    goto error;\n\t}\n\tif (crypt_whole_undofile(bi.bi_state->method_nr))\n\t{\n\t    bi.bi_buffer = alloc(CRYPT_BUF_SIZE);\n\t    if (bi.bi_buffer == NULL)\n\t    {\n\t\tcrypt_free_state(bi.bi_state);\n\t\tbi.bi_state = NULL;\n\t\tgoto error;\n\t    }\n\t    bi.bi_avail = 0;\n\t    bi.bi_used = 0;\n\t}\n#else\n\tEMSG2(_(\"E827: Undo file is encrypted: %s\"), file_name);\n\tgoto error;\n#endif\n    }\n    else if (version != UF_VERSION)\n    {\n\tEMSG2(_(\"E824: Incompatible undo file: %s\"), file_name);\n\tgoto error;\n    }\n\n    if (undo_read(&bi, read_hash, (size_t)UNDO_HASH_SIZE) == FAIL)\n    {\n\tcorruption_error(\"hash\", file_name);\n\tgoto error;\n    }\n    line_count = (linenr_T)undo_read_4c(&bi);\n    if (memcmp(hash, read_hash, UNDO_HASH_SIZE) != 0\n\t\t\t\t  || line_count != curbuf->b_ml.ml_line_count)\n    {\n\tif (p_verbose > 0 || name != NULL)\n\t{\n\t    if (name == NULL)\n\t\tverbose_enter();\n\t    give_warning((char_u *)\n\t\t      _(\"File contents changed, cannot use undo info\"), TRUE);\n\t    if (name == NULL)\n\t\tverbose_leave();\n\t}\n\tgoto error;\n    }\n\n    /* Read undo data for \"U\" command. */\n    str_len = undo_read_4c(&bi);\n    if (str_len < 0)\n\tgoto error;\n    if (str_len > 0)\n\tline_ptr = read_string_decrypt(&bi, str_len);\n    line_lnum = (linenr_T)undo_read_4c(&bi);\n    line_colnr = (colnr_T)undo_read_4c(&bi);\n    if (line_lnum < 0 || line_colnr < 0)\n    {\n\tcorruption_error(\"line lnum/col\", file_name);\n\tgoto error;\n    }\n\n    /* Begin general undo data */\n    old_header_seq = undo_read_4c(&bi);\n    new_header_seq = undo_read_4c(&bi);\n    cur_header_seq = undo_read_4c(&bi);\n    num_head = undo_read_4c(&bi);\n    seq_last = undo_read_4c(&bi);\n    seq_cur = undo_read_4c(&bi);\n    seq_time = undo_read_time(&bi);\n\n    /* Optional header fields. */\n    for (;;)\n    {\n\tint len = undo_read_byte(&bi);\n\tint what;\n\n\tif (len == 0 || len == EOF)\n\t    break;\n\twhat = undo_read_byte(&bi);\n\tswitch (what)\n\t{\n\t    case UF_LAST_SAVE_NR:\n\t\tlast_save_nr = undo_read_4c(&bi);\n\t\tbreak;\n\t    default:\n\t\t/* field not supported, skip */\n\t\twhile (--len >= 0)\n\t\t    (void)undo_read_byte(&bi);\n\t}\n    }\n\n    /* uhp_table will store the freshly created undo headers we allocate\n     * until we insert them into curbuf. The table remains sorted by the\n     * sequence numbers of the headers.\n     * When there are no headers uhp_table is NULL. */\n    if (num_head > 0)\n    {\n\tif (num_head < LONG_MAX / (long)sizeof(u_header_T *))\n\t    uhp_table = (u_header_T **)U_ALLOC_LINE(\n\t\t\t\t\t     num_head * sizeof(u_header_T *));\n\tif (uhp_table == NULL)\n\t    goto error;\n    }\n\n    while ((c = undo_read_2c(&bi)) == UF_HEADER_MAGIC)\n    {\n\tif (num_read_uhps >= num_head)\n\t{\n\t    corruption_error(\"num_head too small\", file_name);\n\t    goto error;\n\t}\n\n\tuhp = unserialize_uhp(&bi, file_name);\n\tif (uhp == NULL)\n\t    goto error;\n\tuhp_table[num_read_uhps++] = uhp;\n    }\n\n    if (num_read_uhps != num_head)\n    {\n\tcorruption_error(\"num_head\", file_name);\n\tgoto error;\n    }\n    if (c != UF_HEADER_END_MAGIC)\n    {\n\tcorruption_error(\"end marker\", file_name);\n\tgoto error;\n    }\n\n#ifdef U_DEBUG\n    uhp_table_used = (int *)alloc_clear(\n\t\t\t\t     (unsigned)(sizeof(int) * num_head + 1));\n# define SET_FLAG(j) ++uhp_table_used[j]\n#else\n# define SET_FLAG(j)\n#endif\n\n    /* We have put all of the headers into a table. Now we iterate through the\n     * table and swizzle each sequence number we have stored in uh_*_seq into\n     * a pointer corresponding to the header with that sequence number. */\n    for (i = 0; i < num_head; i++)\n    {\n\tuhp = uhp_table[i];\n\tif (uhp == NULL)\n\t    continue;\n\tfor (j = 0; j < num_head; j++)\n\t    if (uhp_table[j] != NULL && i != j\n\t\t\t      && uhp_table[i]->uh_seq == uhp_table[j]->uh_seq)\n\t    {\n\t\tcorruption_error(\"duplicate uh_seq\", file_name);\n\t\tgoto error;\n\t    }\n\tfor (j = 0; j < num_head; j++)\n\t    if (uhp_table[j] != NULL\n\t\t\t\t  && uhp_table[j]->uh_seq == uhp->uh_next.seq)\n\t    {\n\t\tuhp->uh_next.ptr = uhp_table[j];\n\t\tSET_FLAG(j);\n\t\tbreak;\n\t    }\n\tfor (j = 0; j < num_head; j++)\n\t    if (uhp_table[j] != NULL\n\t\t\t\t  && uhp_table[j]->uh_seq == uhp->uh_prev.seq)\n\t    {\n\t\tuhp->uh_prev.ptr = uhp_table[j];\n\t\tSET_FLAG(j);\n\t\tbreak;\n\t    }\n\tfor (j = 0; j < num_head; j++)\n\t    if (uhp_table[j] != NULL\n\t\t\t      && uhp_table[j]->uh_seq == uhp->uh_alt_next.seq)\n\t    {\n\t\tuhp->uh_alt_next.ptr = uhp_table[j];\n\t\tSET_FLAG(j);\n\t\tbreak;\n\t    }\n\tfor (j = 0; j < num_head; j++)\n\t    if (uhp_table[j] != NULL\n\t\t\t      && uhp_table[j]->uh_seq == uhp->uh_alt_prev.seq)\n\t    {\n\t\tuhp->uh_alt_prev.ptr = uhp_table[j];\n\t\tSET_FLAG(j);\n\t\tbreak;\n\t    }\n\tif (old_header_seq > 0 && old_idx < 0 && uhp->uh_seq == old_header_seq)\n\t{\n\t    old_idx = i;\n\t    SET_FLAG(i);\n\t}\n\tif (new_header_seq > 0 && new_idx < 0 && uhp->uh_seq == new_header_seq)\n\t{\n\t    new_idx = i;\n\t    SET_FLAG(i);\n\t}\n\tif (cur_header_seq > 0 && cur_idx < 0 && uhp->uh_seq == cur_header_seq)\n\t{\n\t    cur_idx = i;\n\t    SET_FLAG(i);\n\t}\n    }\n\n    /* Now that we have read the undo info successfully, free the current undo\n     * info and use the info from the file. */\n    u_blockfree(curbuf);\n    curbuf->b_u_oldhead = old_idx < 0 ? NULL : uhp_table[old_idx];\n    curbuf->b_u_newhead = new_idx < 0 ? NULL : uhp_table[new_idx];\n    curbuf->b_u_curhead = cur_idx < 0 ? NULL : uhp_table[cur_idx];\n    curbuf->b_u_line_ptr = line_ptr;\n    curbuf->b_u_line_lnum = line_lnum;\n    curbuf->b_u_line_colnr = line_colnr;\n    curbuf->b_u_numhead = num_head;\n    curbuf->b_u_seq_last = seq_last;\n    curbuf->b_u_seq_cur = seq_cur;\n    curbuf->b_u_time_cur = seq_time;\n    curbuf->b_u_save_nr_last = last_save_nr;\n    curbuf->b_u_save_nr_cur = last_save_nr;\n\n    curbuf->b_u_synced = TRUE;\n    vim_free(uhp_table);\n\n#ifdef U_DEBUG\n    for (i = 0; i < num_head; ++i)\n\tif (uhp_table_used[i] == 0)\n\t    EMSGN(\"uhp_table entry %ld not used, leaking memory\", i);\n    vim_free(uhp_table_used);\n    u_check(TRUE);\n#endif\n\n    if (name != NULL)\n\tsmsg((char_u *)_(\"Finished reading undo file %s\"), file_name);\n    goto theend;\n\nerror:\n    vim_free(line_ptr);\n    if (uhp_table != NULL)\n    {\n\tfor (i = 0; i < num_read_uhps; i++)\n\t    if (uhp_table[i] != NULL)\n\t\tu_free_uhp(uhp_table[i]);\n\tvim_free(uhp_table);\n    }\n\ntheend:\n#ifdef FEAT_CRYPT\n    if (bi.bi_state != NULL)\n\tcrypt_free_state(bi.bi_state);\n    vim_free(bi.bi_buffer);\n#endif\n    if (fp != NULL)\n\tfclose(fp);\n    if (file_name != name)\n\tvim_free(file_name);\n    return;\n}\n\n#endif /* FEAT_PERSISTENT_UNDO */\n\n\n/*\n * If 'cpoptions' contains 'u': Undo the previous undo or redo (vi compatible).\n * If 'cpoptions' does not contain 'u': Always undo.\n */\n    void\nu_undo(int count)\n{\n    /*\n     * If we get an undo command while executing a macro, we behave like the\n     * original vi. If this happens twice in one macro the result will not\n     * be compatible.\n     */\n    if (curbuf->b_u_synced == FALSE)\n    {\n\tu_sync(TRUE);\n\tcount = 1;\n    }\n\n    if (vim_strchr(p_cpo, CPO_UNDO) == NULL)\n\tundo_undoes = TRUE;\n    else\n\tundo_undoes = !undo_undoes;\n    u_doit(count);\n}\n\n/*\n * If 'cpoptions' contains 'u': Repeat the previous undo or redo.\n * If 'cpoptions' does not contain 'u': Always redo.\n */\n    void\nu_redo(int count)\n{\n    if (vim_strchr(p_cpo, CPO_UNDO) == NULL)\n\tundo_undoes = FALSE;\n    u_doit(count);\n}\n\n/*\n * Undo or redo, depending on 'undo_undoes', 'count' times.\n */\n    static void\nu_doit(int startcount)\n{\n    int count = startcount;\n\n    if (!undo_allowed())\n\treturn;\n\n    u_newcount = 0;\n    u_oldcount = 0;\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\tu_oldcount = -1;\n    while (count--)\n    {\n\t/* Do the change warning now, so that it triggers FileChangedRO when\n\t * needed.  This may cause the file to be reloaded, that must happen\n\t * before we do anything, because it may change curbuf->b_u_curhead\n\t * and more. */\n\tchange_warning(0);\n\n\tif (undo_undoes)\n\t{\n\t    if (curbuf->b_u_curhead == NULL)\t\t/* first undo */\n\t\tcurbuf->b_u_curhead = curbuf->b_u_newhead;\n\t    else if (get_undolevel() > 0)\t\t/* multi level undo */\n\t\t/* get next undo */\n\t\tcurbuf->b_u_curhead = curbuf->b_u_curhead->uh_next.ptr;\n\t    /* nothing to undo */\n\t    if (curbuf->b_u_numhead == 0 || curbuf->b_u_curhead == NULL)\n\t    {\n\t\t/* stick curbuf->b_u_curhead at end */\n\t\tcurbuf->b_u_curhead = curbuf->b_u_oldhead;\n\t\tbeep_flush();\n\t\tif (count == startcount - 1)\n\t\t{\n\t\t    MSG(_(\"Already at oldest change\"));\n\t\t    return;\n\t\t}\n\t\tbreak;\n\t    }\n\n\t    u_undoredo(TRUE);\n\t}\n\telse\n\t{\n\t    if (curbuf->b_u_curhead == NULL || get_undolevel() <= 0)\n\t    {\n\t\tbeep_flush();\t/* nothing to redo */\n\t\tif (count == startcount - 1)\n\t\t{\n\t\t    MSG(_(\"Already at newest change\"));\n\t\t    return;\n\t\t}\n\t\tbreak;\n\t    }\n\n\t    u_undoredo(FALSE);\n\n\t    /* Advance for next redo.  Set \"newhead\" when at the end of the\n\t     * redoable changes. */\n\t    if (curbuf->b_u_curhead->uh_prev.ptr == NULL)\n\t\tcurbuf->b_u_newhead = curbuf->b_u_curhead;\n\t    curbuf->b_u_curhead = curbuf->b_u_curhead->uh_prev.ptr;\n\t}\n    }\n    u_undo_end(undo_undoes, FALSE);\n}\n\n/*\n * Undo or redo over the timeline.\n * When \"step\" is negative go back in time, otherwise goes forward in time.\n * When \"sec\" is FALSE make \"step\" steps, when \"sec\" is TRUE use \"step\" as\n * seconds.\n * When \"file\" is TRUE use \"step\" as a number of file writes.\n * When \"absolute\" is TRUE use \"step\" as the sequence number to jump to.\n * \"sec\" must be FALSE then.\n */\n    void\nundo_time(\n    long\tstep,\n    int\t\tsec,\n    int\t\tfile,\n    int\t\tabsolute)\n{\n    long\t    target;\n    long\t    closest;\n    long\t    closest_start;\n    long\t    closest_seq = 0;\n    long\t    val;\n    u_header_T\t    *uhp;\n    u_header_T\t    *last;\n    int\t\t    mark;\n    int\t\t    nomark;\n    int\t\t    round;\n    int\t\t    dosec = sec;\n    int\t\t    dofile = file;\n    int\t\t    above = FALSE;\n    int\t\t    did_undo = TRUE;\n\n    /* First make sure the current undoable change is synced. */\n    if (curbuf->b_u_synced == FALSE)\n\tu_sync(TRUE);\n\n    u_newcount = 0;\n    u_oldcount = 0;\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\tu_oldcount = -1;\n\n    /* \"target\" is the node below which we want to be.\n     * Init \"closest\" to a value we can't reach. */\n    if (absolute)\n    {\n\tif (step == 0)\n\t{\n\t    /* target 0 does not exist, got to 1 and above it. */\n\t    target = 1;\n\t    above = TRUE;\n\t}\n\telse\n\t    target = step;\n\tclosest = -1;\n    }\n    else\n    {\n\tif (dosec)\n\t    target = (long)(curbuf->b_u_time_cur) + step;\n\telse if (dofile)\n\t{\n\t    if (step < 0)\n\t    {\n\t\t/* Going back to a previous write. If there were changes after\n\t\t * the last write, count that as moving one file-write, so\n\t\t * that \":earlier 1f\" undoes all changes since the last save. */\n\t\tuhp = curbuf->b_u_curhead;\n\t\tif (uhp != NULL)\n\t\t    uhp = uhp->uh_next.ptr;\n\t\telse\n\t\t    uhp = curbuf->b_u_newhead;\n\t\tif (uhp != NULL && uhp->uh_save_nr != 0)\n\t\t    /* \"uh_save_nr\" was set in the last block, that means\n\t\t     * there were no changes since the last write */\n\t\t    target = curbuf->b_u_save_nr_cur + step;\n\t\telse\n\t\t    /* count the changes since the last write as one step */\n\t\t    target = curbuf->b_u_save_nr_cur + step + 1;\n\t\tif (target <= 0)\n\t\t    /* Go to before first write: before the oldest change. Use\n\t\t     * the sequence number for that. */\n\t\t    dofile = FALSE;\n\t    }\n\t    else\n\t    {\n\t\t/* Moving forward to a newer write. */\n\t\ttarget = curbuf->b_u_save_nr_cur + step;\n\t\tif (target > curbuf->b_u_save_nr_last)\n\t\t{\n\t\t    /* Go to after last write: after the latest change. Use\n\t\t     * the sequence number for that. */\n\t\t    target = curbuf->b_u_seq_last + 1;\n\t\t    dofile = FALSE;\n\t\t}\n\t    }\n\t}\n\telse\n\t    target = curbuf->b_u_seq_cur + step;\n\tif (step < 0)\n\t{\n\t    if (target < 0)\n\t\ttarget = 0;\n\t    closest = -1;\n\t}\n\telse\n\t{\n\t    if (dosec)\n\t\tclosest = (long)(vim_time() + 1);\n\t    else if (dofile)\n\t\tclosest = curbuf->b_u_save_nr_last + 2;\n\t    else\n\t\tclosest = curbuf->b_u_seq_last + 2;\n\t    if (target >= closest)\n\t\ttarget = closest - 1;\n\t}\n    }\n    closest_start = closest;\n    closest_seq = curbuf->b_u_seq_cur;\n\n    /*\n     * May do this twice:\n     * 1. Search for \"target\", update \"closest\" to the best match found.\n     * 2. If \"target\" not found search for \"closest\".\n     *\n     * When using the closest time we use the sequence number in the second\n     * round, because there may be several entries with the same time.\n     */\n    for (round = 1; round <= 2; ++round)\n    {\n\t/* Find the path from the current state to where we want to go.  The\n\t * desired state can be anywhere in the undo tree, need to go all over\n\t * it.  We put \"nomark\" in uh_walk where we have been without success,\n\t * \"mark\" where it could possibly be. */\n\tmark = ++lastmark;\n\tnomark = ++lastmark;\n\n\tif (curbuf->b_u_curhead == NULL)\t/* at leaf of the tree */\n\t    uhp = curbuf->b_u_newhead;\n\telse\n\t    uhp = curbuf->b_u_curhead;\n\n\twhile (uhp != NULL)\n\t{\n\t    uhp->uh_walk = mark;\n\t    if (dosec)\n\t\tval = (long)(uhp->uh_time);\n\t    else if (dofile)\n\t\tval = uhp->uh_save_nr;\n\t    else\n\t\tval = uhp->uh_seq;\n\n\t    if (round == 1 && !(dofile && val == 0))\n\t    {\n\t\t/* Remember the header that is closest to the target.\n\t\t * It must be at least in the right direction (checked with\n\t\t * \"b_u_seq_cur\").  When the timestamp is equal find the\n\t\t * highest/lowest sequence number. */\n\t\tif ((step < 0 ? uhp->uh_seq <= curbuf->b_u_seq_cur\n\t\t\t      : uhp->uh_seq > curbuf->b_u_seq_cur)\n\t\t\t&& ((dosec && val == closest)\n\t\t\t    ? (step < 0\n\t\t\t\t? uhp->uh_seq < closest_seq\n\t\t\t\t: uhp->uh_seq > closest_seq)\n\t\t\t    : closest == closest_start\n\t\t\t\t|| (val > target\n\t\t\t\t    ? (closest > target\n\t\t\t\t\t? val - target <= closest - target\n\t\t\t\t\t: val - target <= target - closest)\n\t\t\t\t    : (closest > target\n\t\t\t\t\t? target - val <= closest - target\n\t\t\t\t\t: target - val <= target - closest))))\n\t\t{\n\t\t    closest = val;\n\t\t    closest_seq = uhp->uh_seq;\n\t\t}\n\t    }\n\n\t    /* Quit searching when we found a match.  But when searching for a\n\t     * time we need to continue looking for the best uh_seq. */\n\t    if (target == val && !dosec)\n\t    {\n\t\ttarget = uhp->uh_seq;\n\t\tbreak;\n\t    }\n\n\t    /* go down in the tree if we haven't been there */\n\t    if (uhp->uh_prev.ptr != NULL && uhp->uh_prev.ptr->uh_walk != nomark\n\t\t\t\t\t && uhp->uh_prev.ptr->uh_walk != mark)\n\t\tuhp = uhp->uh_prev.ptr;\n\n\t    /* go to alternate branch if we haven't been there */\n\t    else if (uhp->uh_alt_next.ptr != NULL\n\t\t    && uhp->uh_alt_next.ptr->uh_walk != nomark\n\t\t    && uhp->uh_alt_next.ptr->uh_walk != mark)\n\t\tuhp = uhp->uh_alt_next.ptr;\n\n\t    /* go up in the tree if we haven't been there and we are at the\n\t     * start of alternate branches */\n\t    else if (uhp->uh_next.ptr != NULL && uhp->uh_alt_prev.ptr == NULL\n\t\t    && uhp->uh_next.ptr->uh_walk != nomark\n\t\t    && uhp->uh_next.ptr->uh_walk != mark)\n\t    {\n\t\t/* If still at the start we don't go through this change. */\n\t\tif (uhp == curbuf->b_u_curhead)\n\t\t    uhp->uh_walk = nomark;\n\t\tuhp = uhp->uh_next.ptr;\n\t    }\n\n\t    else\n\t    {\n\t\t/* need to backtrack; mark this node as useless */\n\t\tuhp->uh_walk = nomark;\n\t\tif (uhp->uh_alt_prev.ptr != NULL)\n\t\t    uhp = uhp->uh_alt_prev.ptr;\n\t\telse\n\t\t    uhp = uhp->uh_next.ptr;\n\t    }\n\t}\n\n\tif (uhp != NULL)    /* found it */\n\t    break;\n\n\tif (absolute)\n\t{\n\t    EMSGN(_(\"E830: Undo number %ld not found\"), step);\n\t    return;\n\t}\n\n\tif (closest == closest_start)\n\t{\n\t    if (step < 0)\n\t\tMSG(_(\"Already at oldest change\"));\n\t    else\n\t\tMSG(_(\"Already at newest change\"));\n\t    return;\n\t}\n\n\ttarget = closest_seq;\n\tdosec = FALSE;\n\tdofile = FALSE;\n\tif (step < 0)\n\t    above = TRUE;\t/* stop above the header */\n    }\n\n    /* If we found it: Follow the path to go to where we want to be. */\n    if (uhp != NULL)\n    {\n\t/*\n\t * First go up the tree as much as needed.\n\t */\n\twhile (!got_int)\n\t{\n\t    /* Do the change warning now, for the same reason as above. */\n\t    change_warning(0);\n\n\t    uhp = curbuf->b_u_curhead;\n\t    if (uhp == NULL)\n\t\tuhp = curbuf->b_u_newhead;\n\t    else\n\t\tuhp = uhp->uh_next.ptr;\n\t    if (uhp == NULL || uhp->uh_walk != mark\n\t\t\t\t\t || (uhp->uh_seq == target && !above))\n\t\tbreak;\n\t    curbuf->b_u_curhead = uhp;\n\t    u_undoredo(TRUE);\n\t    uhp->uh_walk = nomark;\t/* don't go back down here */\n\t}\n\n\t/*\n\t * And now go down the tree (redo), branching off where needed.\n\t */\n\twhile (!got_int)\n\t{\n\t    /* Do the change warning now, for the same reason as above. */\n\t    change_warning(0);\n\n\t    uhp = curbuf->b_u_curhead;\n\t    if (uhp == NULL)\n\t\tbreak;\n\n\t    /* Go back to the first branch with a mark. */\n\t    while (uhp->uh_alt_prev.ptr != NULL\n\t\t\t\t     && uhp->uh_alt_prev.ptr->uh_walk == mark)\n\t\tuhp = uhp->uh_alt_prev.ptr;\n\n\t    /* Find the last branch with a mark, that's the one. */\n\t    last = uhp;\n\t    while (last->uh_alt_next.ptr != NULL\n\t\t\t\t    && last->uh_alt_next.ptr->uh_walk == mark)\n\t\tlast = last->uh_alt_next.ptr;\n\t    if (last != uhp)\n\t    {\n\t\t/* Make the used branch the first entry in the list of\n\t\t * alternatives to make \"u\" and CTRL-R take this branch. */\n\t\twhile (uhp->uh_alt_prev.ptr != NULL)\n\t\t    uhp = uhp->uh_alt_prev.ptr;\n\t\tif (last->uh_alt_next.ptr != NULL)\n\t\t    last->uh_alt_next.ptr->uh_alt_prev.ptr =\n\t\t\t\t\t\t\tlast->uh_alt_prev.ptr;\n\t\tlast->uh_alt_prev.ptr->uh_alt_next.ptr = last->uh_alt_next.ptr;\n\t\tlast->uh_alt_prev.ptr = NULL;\n\t\tlast->uh_alt_next.ptr = uhp;\n\t\tuhp->uh_alt_prev.ptr = last;\n\n\t\tif (curbuf->b_u_oldhead == uhp)\n\t\t    curbuf->b_u_oldhead = last;\n\t\tuhp = last;\n\t\tif (uhp->uh_next.ptr != NULL)\n\t\t    uhp->uh_next.ptr->uh_prev.ptr = uhp;\n\t    }\n\t    curbuf->b_u_curhead = uhp;\n\n\t    if (uhp->uh_walk != mark)\n\t\tbreak;\t    /* must have reached the target */\n\n\t    /* Stop when going backwards in time and didn't find the exact\n\t     * header we were looking for. */\n\t    if (uhp->uh_seq == target && above)\n\t    {\n\t\tcurbuf->b_u_seq_cur = target - 1;\n\t\tbreak;\n\t    }\n\n\t    u_undoredo(FALSE);\n\n\t    /* Advance \"curhead\" to below the header we last used.  If it\n\t     * becomes NULL then we need to set \"newhead\" to this leaf. */\n\t    if (uhp->uh_prev.ptr == NULL)\n\t\tcurbuf->b_u_newhead = uhp;\n\t    curbuf->b_u_curhead = uhp->uh_prev.ptr;\n\t    did_undo = FALSE;\n\n\t    if (uhp->uh_seq == target)\t/* found it! */\n\t\tbreak;\n\n\t    uhp = uhp->uh_prev.ptr;\n\t    if (uhp == NULL || uhp->uh_walk != mark)\n\t    {\n\t\t/* Need to redo more but can't find it... */\n\t\tinternal_error(\"undo_time()\");\n\t\tbreak;\n\t    }\n\t}\n    }\n    u_undo_end(did_undo, absolute);\n}\n\n/*\n * u_undoredo: common code for undo and redo\n *\n * The lines in the file are replaced by the lines in the entry list at\n * curbuf->b_u_curhead. The replaced lines in the file are saved in the entry\n * list for the next undo/redo.\n *\n * When \"undo\" is TRUE we go up in the tree, when FALSE we go down.\n */\n    static void\nu_undoredo(int undo)\n{\n    char_u\t**newarray = NULL;\n    linenr_T\toldsize;\n    linenr_T\tnewsize;\n    linenr_T\ttop, bot;\n    linenr_T\tlnum;\n    linenr_T\tnewlnum = MAXLNUM;\n    long\ti;\n    u_entry_T\t*uep, *nuep;\n    u_entry_T\t*newlist = NULL;\n    int\t\told_flags;\n    int\t\tnew_flags;\n    pos_T\tnamedm[NMARKS];\n    visualinfo_T visualinfo;\n    int\t\tempty_buffer;\t\t    /* buffer became empty */\n    u_header_T\t*curhead = curbuf->b_u_curhead;\n\n#ifdef FEAT_AUTOCMD\n    /* Don't want autocommands using the undo structures here, they are\n     * invalid till the end. */\n    block_autocmds();\n#endif\n\n#ifdef U_DEBUG\n    u_check(FALSE);\n#endif\n    old_flags = curhead->uh_flags;\n    new_flags = (curbuf->b_changed ? UH_CHANGED : 0) +\n\t       ((curbuf->b_ml.ml_flags & ML_EMPTY) ? UH_EMPTYBUF : 0);\n    setpcmark();\n\n    /*\n     * save marks before undo/redo\n     */\n    mch_memmove(namedm, curbuf->b_namedm, sizeof(pos_T) * NMARKS);\n    visualinfo = curbuf->b_visual;\n    curbuf->b_op_start.lnum = curbuf->b_ml.ml_line_count;\n    curbuf->b_op_start.col = 0;\n    curbuf->b_op_end.lnum = 0;\n    curbuf->b_op_end.col = 0;\n\n    for (uep = curhead->uh_entry; uep != NULL; uep = nuep)\n    {\n\ttop = uep->ue_top;\n\tbot = uep->ue_bot;\n\tif (bot == 0)\n\t    bot = curbuf->b_ml.ml_line_count + 1;\n\tif (top > curbuf->b_ml.ml_line_count || top >= bot\n\t\t\t\t      || bot > curbuf->b_ml.ml_line_count + 1)\n\t{\n#ifdef FEAT_AUTOCMD\n\t    unblock_autocmds();\n#endif\n\t    IEMSG(_(\"E438: u_undo: line numbers wrong\"));\n\t    changed();\t\t/* don't want UNCHANGED now */\n\t    return;\n\t}\n\n\toldsize = bot - top - 1;    /* number of lines before undo */\n\tnewsize = uep->ue_size;\t    /* number of lines after undo */\n\n\tif (top < newlnum)\n\t{\n\t    /* If the saved cursor is somewhere in this undo block, move it to\n\t     * the remembered position.  Makes \"gwap\" put the cursor back\n\t     * where it was. */\n\t    lnum = curhead->uh_cursor.lnum;\n\t    if (lnum >= top && lnum <= top + newsize + 1)\n\t    {\n\t\tcurwin->w_cursor = curhead->uh_cursor;\n\t\tnewlnum = curwin->w_cursor.lnum - 1;\n\t    }\n\t    else\n\t    {\n\t\t/* Use the first line that actually changed.  Avoids that\n\t\t * undoing auto-formatting puts the cursor in the previous\n\t\t * line. */\n\t\tfor (i = 0; i < newsize && i < oldsize; ++i)\n\t\t    if (STRCMP(uep->ue_array[i], ml_get(top + 1 + i)) != 0)\n\t\t\tbreak;\n\t\tif (i == newsize && newlnum == MAXLNUM && uep->ue_next == NULL)\n\t\t{\n\t\t    newlnum = top;\n\t\t    curwin->w_cursor.lnum = newlnum + 1;\n\t\t}\n\t\telse if (i < newsize)\n\t\t{\n\t\t    newlnum = top + i;\n\t\t    curwin->w_cursor.lnum = newlnum + 1;\n\t\t}\n\t    }\n\t}\n\n\tempty_buffer = FALSE;\n\n\t/* delete the lines between top and bot and save them in newarray */\n\tif (oldsize > 0)\n\t{\n\t    if ((newarray = (char_u **)U_ALLOC_LINE(\n\t\t\t\t\t sizeof(char_u *) * oldsize)) == NULL)\n\t    {\n\t\tdo_outofmem_msg((long_u)(sizeof(char_u *) * oldsize));\n\t\t/*\n\t\t * We have messed up the entry list, repair is impossible.\n\t\t * we have to free the rest of the list.\n\t\t */\n\t\twhile (uep != NULL)\n\t\t{\n\t\t    nuep = uep->ue_next;\n\t\t    u_freeentry(uep, uep->ue_size);\n\t\t    uep = nuep;\n\t\t}\n\t\tbreak;\n\t    }\n\t    /* delete backwards, it goes faster in most cases */\n\t    for (lnum = bot - 1, i = oldsize; --i >= 0; --lnum)\n\t    {\n\t\t/* what can we do when we run out of memory? */\n\t\tif ((newarray[i] = u_save_line(lnum)) == NULL)\n\t\t    do_outofmem_msg((long_u)0);\n\t\t/* remember we deleted the last line in the buffer, and a\n\t\t * dummy empty line will be inserted */\n\t\tif (curbuf->b_ml.ml_line_count == 1)\n\t\t    empty_buffer = TRUE;\n\t\tml_delete(lnum, FALSE);\n\t    }\n\t}\n\telse\n\t    newarray = NULL;\n\n\t/* insert the lines in u_array between top and bot */\n\tif (newsize)\n\t{\n\t    for (lnum = top, i = 0; i < newsize; ++i, ++lnum)\n\t    {\n\t\t/*\n\t\t * If the file is empty, there is an empty line 1 that we\n\t\t * should get rid of, by replacing it with the new line\n\t\t */\n\t\tif (empty_buffer && lnum == 0)\n\t\t    ml_replace((linenr_T)1, uep->ue_array[i], TRUE);\n\t\telse\n\t\t    ml_append(lnum, uep->ue_array[i], (colnr_T)0, FALSE);\n\t\tvim_free(uep->ue_array[i]);\n\t    }\n\t    vim_free((char_u *)uep->ue_array);\n\t}\n\n\t/* adjust marks */\n\tif (oldsize != newsize)\n\t{\n\t    mark_adjust(top + 1, top + oldsize, (long)MAXLNUM,\n\t\t\t\t\t       (long)newsize - (long)oldsize);\n\t    if (curbuf->b_op_start.lnum > top + oldsize)\n\t\tcurbuf->b_op_start.lnum += newsize - oldsize;\n\t    if (curbuf->b_op_end.lnum > top + oldsize)\n\t\tcurbuf->b_op_end.lnum += newsize - oldsize;\n\t}\n\n\tchanged_lines(top + 1, 0, bot, newsize - oldsize);\n\n\t/* set '[ and '] mark */\n\tif (top + 1 < curbuf->b_op_start.lnum)\n\t    curbuf->b_op_start.lnum = top + 1;\n\tif (newsize == 0 && top + 1 > curbuf->b_op_end.lnum)\n\t    curbuf->b_op_end.lnum = top + 1;\n\telse if (top + newsize > curbuf->b_op_end.lnum)\n\t    curbuf->b_op_end.lnum = top + newsize;\n\n\tu_newcount += newsize;\n\tu_oldcount += oldsize;\n\tuep->ue_size = oldsize;\n\tuep->ue_array = newarray;\n\tuep->ue_bot = top + newsize + 1;\n\n\t/*\n\t * insert this entry in front of the new entry list\n\t */\n\tnuep = uep->ue_next;\n\tuep->ue_next = newlist;\n\tnewlist = uep;\n    }\n\n    curhead->uh_entry = newlist;\n    curhead->uh_flags = new_flags;\n    if ((old_flags & UH_EMPTYBUF) && bufempty())\n\tcurbuf->b_ml.ml_flags |= ML_EMPTY;\n    if (old_flags & UH_CHANGED)\n\tchanged();\n    else\n#ifdef FEAT_NETBEANS_INTG\n\t/* per netbeans undo rules, keep it as modified */\n\tif (!isNetbeansModified(curbuf))\n#endif\n\tunchanged(curbuf, FALSE);\n\n    /*\n     * restore marks from before undo/redo\n     */\n    for (i = 0; i < NMARKS; ++i)\n    {\n\tif (curhead->uh_namedm[i].lnum != 0)\n\t    curbuf->b_namedm[i] = curhead->uh_namedm[i];\n\tif (namedm[i].lnum != 0)\n\t    curhead->uh_namedm[i] = namedm[i];\n\telse\n\t    curhead->uh_namedm[i].lnum = 0;\n    }\n    if (curhead->uh_visual.vi_start.lnum != 0)\n    {\n\tcurbuf->b_visual = curhead->uh_visual;\n\tcurhead->uh_visual = visualinfo;\n    }\n\n    /*\n     * If the cursor is only off by one line, put it at the same position as\n     * before starting the change (for the \"o\" command).\n     * Otherwise the cursor should go to the first undone line.\n     */\n    if (curhead->uh_cursor.lnum + 1 == curwin->w_cursor.lnum\n\t\t\t\t\t\t && curwin->w_cursor.lnum > 1)\n\t--curwin->w_cursor.lnum;\n    if (curwin->w_cursor.lnum <= curbuf->b_ml.ml_line_count)\n    {\n\tif (curhead->uh_cursor.lnum == curwin->w_cursor.lnum)\n\t{\n\t    curwin->w_cursor.col = curhead->uh_cursor.col;\n#ifdef FEAT_VIRTUALEDIT\n\t    if (virtual_active() && curhead->uh_cursor_vcol >= 0)\n\t\tcoladvance((colnr_T)curhead->uh_cursor_vcol);\n\t    else\n\t\tcurwin->w_cursor.coladd = 0;\n#endif\n\t}\n\telse\n\t    beginline(BL_SOL | BL_FIX);\n    }\n    else\n    {\n\t/* We get here with the current cursor line being past the end (eg\n\t * after adding lines at the end of the file, and then undoing it).\n\t * check_cursor() will move the cursor to the last line.  Move it to\n\t * the first column here. */\n\tcurwin->w_cursor.col = 0;\n#ifdef FEAT_VIRTUALEDIT\n\tcurwin->w_cursor.coladd = 0;\n#endif\n    }\n\n    /* Make sure the cursor is on an existing line and column. */\n    check_cursor();\n\n    /* Remember where we are for \"g-\" and \":earlier 10s\". */\n    curbuf->b_u_seq_cur = curhead->uh_seq;\n    if (undo)\n\t/* We are below the previous undo.  However, to make \":earlier 1s\"\n\t * work we compute this as being just above the just undone change. */\n\t--curbuf->b_u_seq_cur;\n\n    /* Remember where we are for \":earlier 1f\" and \":later 1f\". */\n    if (curhead->uh_save_nr != 0)\n    {\n\tif (undo)\n\t    curbuf->b_u_save_nr_cur = curhead->uh_save_nr - 1;\n\telse\n\t    curbuf->b_u_save_nr_cur = curhead->uh_save_nr;\n    }\n\n    /* The timestamp can be the same for multiple changes, just use the one of\n     * the undone/redone change. */\n    curbuf->b_u_time_cur = curhead->uh_time;\n\n#ifdef FEAT_AUTOCMD\n    unblock_autocmds();\n#endif\n#ifdef U_DEBUG\n    u_check(FALSE);\n#endif\n}\n\n/*\n * If we deleted or added lines, report the number of less/more lines.\n * Otherwise, report the number of changes (this may be incorrect\n * in some cases, but it's better than nothing).\n */\n    static void\nu_undo_end(\n    int\t\tdid_undo,\t/* just did an undo */\n    int\t\tabsolute)\t/* used \":undo N\" */\n{\n    char\t*msgstr;\n    u_header_T\t*uhp;\n    char_u\tmsgbuf[80];\n\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_UNDO) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n\n    if (global_busy\t    /* no messages now, wait until global is finished */\n\t    || !messaging())  /* 'lazyredraw' set, don't do messages now */\n\treturn;\n\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\t--u_newcount;\n\n    u_oldcount -= u_newcount;\n    if (u_oldcount == -1)\n\tmsgstr = N_(\"more line\");\n    else if (u_oldcount < 0)\n\tmsgstr = N_(\"more lines\");\n    else if (u_oldcount == 1)\n\tmsgstr = N_(\"line less\");\n    else if (u_oldcount > 1)\n\tmsgstr = N_(\"fewer lines\");\n    else\n    {\n\tu_oldcount = u_newcount;\n\tif (u_newcount == 1)\n\t    msgstr = N_(\"change\");\n\telse\n\t    msgstr = N_(\"changes\");\n    }\n\n    if (curbuf->b_u_curhead != NULL)\n    {\n\t/* For \":undo N\" we prefer a \"after #N\" message. */\n\tif (absolute && curbuf->b_u_curhead->uh_next.ptr != NULL)\n\t{\n\t    uhp = curbuf->b_u_curhead->uh_next.ptr;\n\t    did_undo = FALSE;\n\t}\n\telse if (did_undo)\n\t    uhp = curbuf->b_u_curhead;\n\telse\n\t    uhp = curbuf->b_u_curhead->uh_next.ptr;\n    }\n    else\n\tuhp = curbuf->b_u_newhead;\n\n    if (uhp == NULL)\n\t*msgbuf = NUL;\n    else\n\tu_add_time(msgbuf, sizeof(msgbuf), uhp->uh_time);\n\n#ifdef FEAT_CONCEAL\n    {\n\twin_T\t*wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    if (wp->w_buffer == curbuf && wp->w_p_cole > 0)\n\t\tredraw_win_later(wp, NOT_VALID);\n\t}\n    }\n#endif\n\n    smsg((char_u *)_(\"%ld %s; %s #%ld  %s\"),\n\t    u_oldcount < 0 ? -u_oldcount : u_oldcount,\n\t    _(msgstr),\n\t    did_undo ? _(\"before\") : _(\"after\"),\n\t    uhp == NULL ? 0L : uhp->uh_seq,\n\t    msgbuf);\n}\n\n/*\n * u_sync: stop adding to the current entry list\n */\n    void\nu_sync(\n    int\t    force)\t/* Also sync when no_u_sync is set. */\n{\n    /* Skip it when already synced or syncing is disabled. */\n    if (curbuf->b_u_synced || (!force && no_u_sync > 0))\n\treturn;\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n    if (im_is_preediting())\n\treturn;\t\t    /* XIM is busy, don't break an undo sequence */\n#endif\n    if (get_undolevel() < 0)\n\tcurbuf->b_u_synced = TRUE;  /* no entries, nothing to do */\n    else\n    {\n\tu_getbot();\t\t    /* compute ue_bot of previous u_save */\n\tcurbuf->b_u_curhead = NULL;\n    }\n}\n\n/*\n * \":undolist\": List the leafs of the undo tree\n */\n    void\nex_undolist(exarg_T *eap UNUSED)\n{\n    garray_T\tga;\n    u_header_T\t*uhp;\n    int\t\tmark;\n    int\t\tnomark;\n    int\t\tchanges = 1;\n    int\t\ti;\n\n    /*\n     * 1: walk the tree to find all leafs, put the info in \"ga\".\n     * 2: sort the lines\n     * 3: display the list\n     */\n    mark = ++lastmark;\n    nomark = ++lastmark;\n    ga_init2(&ga, (int)sizeof(char *), 20);\n\n    uhp = curbuf->b_u_oldhead;\n    while (uhp != NULL)\n    {\n\tif (uhp->uh_prev.ptr == NULL && uhp->uh_walk != nomark\n\t\t\t\t\t\t      && uhp->uh_walk != mark)\n\t{\n\t    if (ga_grow(&ga, 1) == FAIL)\n\t\tbreak;\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%6ld %7ld  \",\n\t\t\t\t\t\t\tuhp->uh_seq, changes);\n\t    u_add_time(IObuff + STRLEN(IObuff), IOSIZE - STRLEN(IObuff),\n\t\t\t\t\t\t\t\tuhp->uh_time);\n\t    if (uhp->uh_save_nr > 0)\n\t    {\n\t\twhile (STRLEN(IObuff) < 33)\n\t\t    STRCAT(IObuff, \" \");\n\t\tvim_snprintf_add((char *)IObuff, IOSIZE,\n\t\t\t\t\t\t   \"  %3ld\", uhp->uh_save_nr);\n\t    }\n\t    ((char_u **)(ga.ga_data))[ga.ga_len++] = vim_strsave(IObuff);\n\t}\n\n\tuhp->uh_walk = mark;\n\n\t/* go down in the tree if we haven't been there */\n\tif (uhp->uh_prev.ptr != NULL && uhp->uh_prev.ptr->uh_walk != nomark\n\t\t\t\t\t && uhp->uh_prev.ptr->uh_walk != mark)\n\t{\n\t    uhp = uhp->uh_prev.ptr;\n\t    ++changes;\n\t}\n\n\t/* go to alternate branch if we haven't been there */\n\telse if (uhp->uh_alt_next.ptr != NULL\n\t\t&& uhp->uh_alt_next.ptr->uh_walk != nomark\n\t\t&& uhp->uh_alt_next.ptr->uh_walk != mark)\n\t    uhp = uhp->uh_alt_next.ptr;\n\n\t/* go up in the tree if we haven't been there and we are at the\n\t * start of alternate branches */\n\telse if (uhp->uh_next.ptr != NULL && uhp->uh_alt_prev.ptr == NULL\n\t\t&& uhp->uh_next.ptr->uh_walk != nomark\n\t\t&& uhp->uh_next.ptr->uh_walk != mark)\n\t{\n\t    uhp = uhp->uh_next.ptr;\n\t    --changes;\n\t}\n\n\telse\n\t{\n\t    /* need to backtrack; mark this node as done */\n\t    uhp->uh_walk = nomark;\n\t    if (uhp->uh_alt_prev.ptr != NULL)\n\t\tuhp = uhp->uh_alt_prev.ptr;\n\t    else\n\t    {\n\t\tuhp = uhp->uh_next.ptr;\n\t\t--changes;\n\t    }\n\t}\n    }\n\n    if (ga.ga_len == 0)\n\tMSG(_(\"Nothing to undo\"));\n    else\n    {\n\tsort_strings((char_u **)ga.ga_data, ga.ga_len);\n\n\tmsg_start();\n\tmsg_puts_attr((char_u *)_(\"number changes  when               saved\"),\n\t\t\t\t\t\t\t      hl_attr(HLF_T));\n\tfor (i = 0; i < ga.ga_len && !got_int; ++i)\n\t{\n\t    msg_putchar('\\n');\n\t    if (got_int)\n\t\tbreak;\n\t    msg_puts(((char_u **)ga.ga_data)[i]);\n\t}\n\tmsg_end();\n\n\tga_clear_strings(&ga);\n    }\n}\n\n/*\n * Put the timestamp of an undo header in \"buf[buflen]\" in a nice format.\n */\n    static void\nu_add_time(char_u *buf, size_t buflen, time_t tt)\n{\n#ifdef HAVE_STRFTIME\n    struct tm\t*curtime;\n\n    if (vim_time() - tt >= 100)\n    {\n\tcurtime = localtime(&tt);\n\tif (vim_time() - tt < (60L * 60L * 12L))\n\t    /* within 12 hours */\n\t    (void)strftime((char *)buf, buflen, \"%H:%M:%S\", curtime);\n\telse\n\t    /* longer ago */\n\t    (void)strftime((char *)buf, buflen, \"%Y/%m/%d %H:%M:%S\", curtime);\n    }\n    else\n#endif\n\tvim_snprintf((char *)buf, buflen, _(\"%ld seconds ago\"),\n\t\t\t\t\t\t      (long)(vim_time() - tt));\n}\n\n/*\n * \":undojoin\": continue adding to the last entry list\n */\n    void\nex_undojoin(exarg_T *eap UNUSED)\n{\n    if (curbuf->b_u_newhead == NULL)\n\treturn;\t\t    /* nothing changed before */\n    if (curbuf->b_u_curhead != NULL)\n    {\n\tEMSG(_(\"E790: undojoin is not allowed after undo\"));\n\treturn;\n    }\n    if (!curbuf->b_u_synced)\n\treturn;\t\t    /* already unsynced */\n    if (get_undolevel() < 0)\n\treturn;\t\t    /* no entries, nothing to do */\n    else\n\t/* Append next change to the last entry */\n\tcurbuf->b_u_synced = FALSE;\n}\n\n/*\n * Called after writing or reloading the file and setting b_changed to FALSE.\n * Now an undo means that the buffer is modified.\n */\n    void\nu_unchanged(buf_T *buf)\n{\n    u_unch_branch(buf->b_u_oldhead);\n    buf->b_did_warn = FALSE;\n}\n\n/*\n * After reloading a buffer which was saved for 'undoreload': Find the first\n * line that was changed and set the cursor there.\n */\n    void\nu_find_first_changed(void)\n{\n    u_header_T\t*uhp = curbuf->b_u_newhead;\n    u_entry_T   *uep;\n    linenr_T\tlnum;\n\n    if (curbuf->b_u_curhead != NULL || uhp == NULL)\n\treturn;  /* undid something in an autocmd? */\n\n    /* Check that the last undo block was for the whole file. */\n    uep = uhp->uh_entry;\n    if (uep->ue_top != 0 || uep->ue_bot != 0)\n\treturn;\n\n    for (lnum = 1; lnum < curbuf->b_ml.ml_line_count\n\t\t\t\t\t      && lnum <= uep->ue_size; ++lnum)\n\tif (STRCMP(ml_get_buf(curbuf, lnum, FALSE),\n\t\t\t\t\t\tuep->ue_array[lnum - 1]) != 0)\n\t{\n\t    clearpos(&(uhp->uh_cursor));\n\t    uhp->uh_cursor.lnum = lnum;\n\t    return;\n\t}\n    if (curbuf->b_ml.ml_line_count != uep->ue_size)\n    {\n\t/* lines added or deleted at the end, put the cursor there */\n\tclearpos(&(uhp->uh_cursor));\n\tuhp->uh_cursor.lnum = lnum;\n    }\n}\n\n/*\n * Increase the write count, store it in the last undo header, what would be\n * used for \"u\".\n */\n    void\nu_update_save_nr(buf_T *buf)\n{\n    u_header_T\t*uhp;\n\n    ++buf->b_u_save_nr_last;\n    buf->b_u_save_nr_cur = buf->b_u_save_nr_last;\n    uhp = buf->b_u_curhead;\n    if (uhp != NULL)\n\tuhp = uhp->uh_next.ptr;\n    else\n\tuhp = buf->b_u_newhead;\n    if (uhp != NULL)\n\tuhp->uh_save_nr = buf->b_u_save_nr_last;\n}\n\n    static void\nu_unch_branch(u_header_T *uhp)\n{\n    u_header_T\t*uh;\n\n    for (uh = uhp; uh != NULL; uh = uh->uh_prev.ptr)\n    {\n\tuh->uh_flags |= UH_CHANGED;\n\tif (uh->uh_alt_next.ptr != NULL)\n\t    u_unch_branch(uh->uh_alt_next.ptr);\t    /* recursive */\n    }\n}\n\n/*\n * Get pointer to last added entry.\n * If it's not valid, give an error message and return NULL.\n */\n    static u_entry_T *\nu_get_headentry(void)\n{\n    if (curbuf->b_u_newhead == NULL || curbuf->b_u_newhead->uh_entry == NULL)\n    {\n\tIEMSG(_(\"E439: undo list corrupt\"));\n\treturn NULL;\n    }\n    return curbuf->b_u_newhead->uh_entry;\n}\n\n/*\n * u_getbot(): compute the line number of the previous u_save\n *\t\tIt is called only when b_u_synced is FALSE.\n */\n    static void\nu_getbot(void)\n{\n    u_entry_T\t*uep;\n    linenr_T\textra;\n\n    uep = u_get_headentry();\t/* check for corrupt undo list */\n    if (uep == NULL)\n\treturn;\n\n    uep = curbuf->b_u_newhead->uh_getbot_entry;\n    if (uep != NULL)\n    {\n\t/*\n\t * the new ue_bot is computed from the number of lines that has been\n\t * inserted (0 - deleted) since calling u_save. This is equal to the\n\t * old line count subtracted from the current line count.\n\t */\n\textra = curbuf->b_ml.ml_line_count - uep->ue_lcount;\n\tuep->ue_bot = uep->ue_top + uep->ue_size + 1 + extra;\n\tif (uep->ue_bot < 1 || uep->ue_bot > curbuf->b_ml.ml_line_count)\n\t{\n\t    IEMSG(_(\"E440: undo line missing\"));\n\t    uep->ue_bot = uep->ue_top + 1;  /* assume all lines deleted, will\n\t\t\t\t\t     * get all the old lines back\n\t\t\t\t\t     * without deleting the current\n\t\t\t\t\t     * ones */\n\t}\n\n\tcurbuf->b_u_newhead->uh_getbot_entry = NULL;\n    }\n\n    curbuf->b_u_synced = TRUE;\n}\n\n/*\n * Free one header \"uhp\" and its entry list and adjust the pointers.\n */\n    static void\nu_freeheader(\n    buf_T\t    *buf,\n    u_header_T\t    *uhp,\n    u_header_T\t    **uhpp)\t/* if not NULL reset when freeing this header */\n{\n    u_header_T\t    *uhap;\n\n    /* When there is an alternate redo list free that branch completely,\n     * because we can never go there. */\n    if (uhp->uh_alt_next.ptr != NULL)\n\tu_freebranch(buf, uhp->uh_alt_next.ptr, uhpp);\n\n    if (uhp->uh_alt_prev.ptr != NULL)\n\tuhp->uh_alt_prev.ptr->uh_alt_next.ptr = NULL;\n\n    /* Update the links in the list to remove the header. */\n    if (uhp->uh_next.ptr == NULL)\n\tbuf->b_u_oldhead = uhp->uh_prev.ptr;\n    else\n\tuhp->uh_next.ptr->uh_prev.ptr = uhp->uh_prev.ptr;\n\n    if (uhp->uh_prev.ptr == NULL)\n\tbuf->b_u_newhead = uhp->uh_next.ptr;\n    else\n\tfor (uhap = uhp->uh_prev.ptr; uhap != NULL;\n\t\t\t\t\t\t uhap = uhap->uh_alt_next.ptr)\n\t    uhap->uh_next.ptr = uhp->uh_next.ptr;\n\n    u_freeentries(buf, uhp, uhpp);\n}\n\n/*\n * Free an alternate branch and any following alternate branches.\n */\n    static void\nu_freebranch(\n    buf_T\t    *buf,\n    u_header_T\t    *uhp,\n    u_header_T\t    **uhpp)\t/* if not NULL reset when freeing this header */\n{\n    u_header_T\t    *tofree, *next;\n\n    /* If this is the top branch we may need to use u_freeheader() to update\n     * all the pointers. */\n    if (uhp == buf->b_u_oldhead)\n    {\n\twhile (buf->b_u_oldhead != NULL)\n\t    u_freeheader(buf, buf->b_u_oldhead, uhpp);\n\treturn;\n    }\n\n    if (uhp->uh_alt_prev.ptr != NULL)\n\tuhp->uh_alt_prev.ptr->uh_alt_next.ptr = NULL;\n\n    next = uhp;\n    while (next != NULL)\n    {\n\ttofree = next;\n\tif (tofree->uh_alt_next.ptr != NULL)\n\t    u_freebranch(buf, tofree->uh_alt_next.ptr, uhpp);   /* recursive */\n\tnext = tofree->uh_prev.ptr;\n\tu_freeentries(buf, tofree, uhpp);\n    }\n}\n\n/*\n * Free all the undo entries for one header and the header itself.\n * This means that \"uhp\" is invalid when returning.\n */\n    static void\nu_freeentries(\n    buf_T\t    *buf,\n    u_header_T\t    *uhp,\n    u_header_T\t    **uhpp)\t/* if not NULL reset when freeing this header */\n{\n    u_entry_T\t    *uep, *nuep;\n\n    /* Check for pointers to the header that become invalid now. */\n    if (buf->b_u_curhead == uhp)\n\tbuf->b_u_curhead = NULL;\n    if (buf->b_u_newhead == uhp)\n\tbuf->b_u_newhead = NULL;  /* freeing the newest entry */\n    if (uhpp != NULL && uhp == *uhpp)\n\t*uhpp = NULL;\n\n    for (uep = uhp->uh_entry; uep != NULL; uep = nuep)\n    {\n\tnuep = uep->ue_next;\n\tu_freeentry(uep, uep->ue_size);\n    }\n\n#ifdef U_DEBUG\n    uhp->uh_magic = 0;\n#endif\n    vim_free((char_u *)uhp);\n    --buf->b_u_numhead;\n}\n\n/*\n * free entry 'uep' and 'n' lines in uep->ue_array[]\n */\n    static void\nu_freeentry(u_entry_T *uep, long n)\n{\n    while (n > 0)\n\tvim_free(uep->ue_array[--n]);\n    vim_free((char_u *)uep->ue_array);\n#ifdef U_DEBUG\n    uep->ue_magic = 0;\n#endif\n    vim_free((char_u *)uep);\n}\n\n/*\n * invalidate the undo buffer; called when storage has already been released\n */\n    void\nu_clearall(buf_T *buf)\n{\n    buf->b_u_newhead = buf->b_u_oldhead = buf->b_u_curhead = NULL;\n    buf->b_u_synced = TRUE;\n    buf->b_u_numhead = 0;\n    buf->b_u_line_ptr = NULL;\n    buf->b_u_line_lnum = 0;\n}\n\n/*\n * save the line \"lnum\" for the \"U\" command\n */\n    void\nu_saveline(linenr_T lnum)\n{\n    if (lnum == curbuf->b_u_line_lnum)\t    /* line is already saved */\n\treturn;\n    if (lnum < 1 || lnum > curbuf->b_ml.ml_line_count) /* should never happen */\n\treturn;\n    u_clearline();\n    curbuf->b_u_line_lnum = lnum;\n    if (curwin->w_cursor.lnum == lnum)\n\tcurbuf->b_u_line_colnr = curwin->w_cursor.col;\n    else\n\tcurbuf->b_u_line_colnr = 0;\n    if ((curbuf->b_u_line_ptr = u_save_line(lnum)) == NULL)\n\tdo_outofmem_msg((long_u)0);\n}\n\n/*\n * clear the line saved for the \"U\" command\n * (this is used externally for crossing a line while in insert mode)\n */\n    void\nu_clearline(void)\n{\n    if (curbuf->b_u_line_ptr != NULL)\n    {\n\tvim_free(curbuf->b_u_line_ptr);\n\tcurbuf->b_u_line_ptr = NULL;\n\tcurbuf->b_u_line_lnum = 0;\n    }\n}\n\n/*\n * Implementation of the \"U\" command.\n * Differentiation from vi: \"U\" can be undone with the next \"U\".\n * We also allow the cursor to be in another line.\n * Careful: may trigger autocommands that reload the buffer.\n */\n    void\nu_undoline(void)\n{\n    colnr_T t;\n    char_u  *oldp;\n\n    if (undo_off)\n\treturn;\n\n    if (curbuf->b_u_line_ptr == NULL\n\t\t\t|| curbuf->b_u_line_lnum > curbuf->b_ml.ml_line_count)\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n    /* first save the line for the 'u' command */\n    if (u_savecommon(curbuf->b_u_line_lnum - 1,\n\t\t       curbuf->b_u_line_lnum + 1, (linenr_T)0, FALSE) == FAIL)\n\treturn;\n    oldp = u_save_line(curbuf->b_u_line_lnum);\n    if (oldp == NULL)\n    {\n\tdo_outofmem_msg((long_u)0);\n\treturn;\n    }\n    ml_replace(curbuf->b_u_line_lnum, curbuf->b_u_line_ptr, TRUE);\n    changed_bytes(curbuf->b_u_line_lnum, 0);\n    vim_free(curbuf->b_u_line_ptr);\n    curbuf->b_u_line_ptr = oldp;\n\n    t = curbuf->b_u_line_colnr;\n    if (curwin->w_cursor.lnum == curbuf->b_u_line_lnum)\n\tcurbuf->b_u_line_colnr = curwin->w_cursor.col;\n    curwin->w_cursor.col = t;\n    curwin->w_cursor.lnum = curbuf->b_u_line_lnum;\n    check_cursor_col();\n}\n\n/*\n * Free all allocated memory blocks for the buffer 'buf'.\n */\n    void\nu_blockfree(buf_T *buf)\n{\n    while (buf->b_u_oldhead != NULL)\n\tu_freeheader(buf, buf->b_u_oldhead, NULL);\n    vim_free(buf->b_u_line_ptr);\n}\n\n/*\n * u_save_line(): allocate memory and copy line 'lnum' into it.\n * Returns NULL when out of memory.\n */\n    static char_u *\nu_save_line(linenr_T lnum)\n{\n    return vim_strsave(ml_get(lnum));\n}\n\n/*\n * Check if the 'modified' flag is set, or 'ff' has changed (only need to\n * check the first character, because it can only be \"dos\", \"unix\" or \"mac\").\n * \"nofile\" and \"scratch\" type buffers are considered to always be unchanged.\n */\n    int\nbufIsChanged(buf_T *buf)\n{\n    return\n#ifdef FEAT_QUICKFIX\n\t    !bt_dontwrite(buf) &&\n#endif\n\t    (buf->b_changed || file_ff_differs(buf, TRUE));\n}\n\n    int\ncurbufIsChanged(void)\n{\n    return\n#ifdef FEAT_QUICKFIX\n\t!bt_dontwrite(curbuf) &&\n#endif\n\t(curbuf->b_changed || file_ff_differs(curbuf, TRUE));\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * For undotree(): Append the list of undo blocks at \"first_uhp\" to \"list\".\n * Recursive.\n */\n    void\nu_eval_tree(u_header_T *first_uhp, list_T *list)\n{\n    u_header_T  *uhp = first_uhp;\n    dict_T\t*dict;\n\n    while (uhp != NULL)\n    {\n\tdict = dict_alloc();\n\tif (dict == NULL)\n\t    return;\n\tdict_add_nr_str(dict, \"seq\", uhp->uh_seq, NULL);\n\tdict_add_nr_str(dict, \"time\", (long)uhp->uh_time, NULL);\n\tif (uhp == curbuf->b_u_newhead)\n\t    dict_add_nr_str(dict, \"newhead\", 1, NULL);\n\tif (uhp == curbuf->b_u_curhead)\n\t    dict_add_nr_str(dict, \"curhead\", 1, NULL);\n\tif (uhp->uh_save_nr > 0)\n\t    dict_add_nr_str(dict, \"save\", uhp->uh_save_nr, NULL);\n\n\tif (uhp->uh_alt_next.ptr != NULL)\n\t{\n\t    list_T\t*alt_list = list_alloc();\n\n\t    if (alt_list != NULL)\n\t    {\n\t\t/* Recursive call to add alternate undo tree. */\n\t\tu_eval_tree(uhp->uh_alt_next.ptr, alt_list);\n\t\tdict_add_list(dict, \"alt\", alt_list);\n\t    }\n\t}\n\n\tlist_append_dict(list, dict);\n\tuhp = uhp->uh_prev.ptr;\n    }\n}\n#endif\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n#ifdef AMIGA\n# include <time.h>\t/* for time() */\n#endif\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\nmake_version(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't catenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n    strcat(longVersion, \")\");\n}\n# else\nchar\t*longVersion = VIM_VERSION_LONG_DATE __DATE__ \" \" __TIME__ \")\";\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n#endif\n\nstatic void list_features(void);\nstatic void version_msg(char *s);\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t/* only for Amiga systems */\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n#ifdef FEAT_AUTOCMD\n\t\"+autocmd\",\n#else\n\t\"-autocmd\",\n#endif\n#ifdef FEAT_BEVAL\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n#ifdef FEAT_CMDL_COMPL\n\t\"+cmdline_compl\",\n#else\n\t\"-cmdline_compl\",\n#endif\n#ifdef FEAT_CMDHIST\n\t\"+cmdline_hist\",\n#else\n\t\"-cmdline_hist\",\n#endif\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n#ifdef FEAT_COMMENTS\n\t\"+comments\",\n#else\n\t\"-comments\",\n#endif\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n#ifdef FEAT_CURSORBIND\n\t\"+cursorbind\",\n#else\n\t\"-cursorbind\",\n#endif\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_W32\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n#ifdef FEAT_FKMAP\n\t\"+farsi\",\n#else\n\t\"-farsi\",\n#endif\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    /* only interesting on Unix systems */\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n#ifdef FEAT_HANGULIN\n\t\"+hangul_input\",\n#else\n\t\"-hangul_input\",\n#endif\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n#ifdef FEAT_INS_EXPAND\n\t\"+insert_expand\",\n#else\n\t\"-insert_expand\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n#ifdef FEAT_JUMPLIST\n\t\"+jumplist\",\n#else\n\t\"-jumplist\",\n#endif\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n#ifdef FEAT_LISTCMDS\n\t\"+listcmds\",\n#else\n\t\"-listcmds\",\n#endif\n#ifdef FEAT_LOCALMAP\n\t\"+localmap\",\n#else\n\t\"-localmap\",\n#endif\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n#ifdef FEAT_MODIFY_FNAME\n\t\"+modify_fname\",\n#else\n\t\"-modify_fname\",\n#endif\n#ifdef FEAT_MOUSE\n\t\"+mouse\",\n#  ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#  else\n\t\"-mouseshape\",\n#  endif\n# else\n\t\"-mouse\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_SGR\n\t\"+mouse_sgr\",\n# else\n\t\"-mouse_sgr\",\n# endif\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n# ifdef FEAT_MOUSE_XTERM\n\t\"+mouse_xterm\",\n# else\n\t\"-mouse_xterm\",\n# endif\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n# ifdef FEAT_MBYTE\n\t\"+multi_byte\",\n# else\n\t\"-multi_byte\",\n# endif\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n#ifdef FEAT_NUM64\n\t\"+num64\",\n#else\n\t\"-num64\",\n#endif\n#ifdef FEAT_GUI_W32\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n\t\"+packages\",\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n#ifdef FEAT_SCROLLBIND\n\t\"+scrollbind\",\n#else\n\t\"-scrollbind\",\n#endif\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n#ifdef FEAT_SUN_WORKSHOP\n\t\"+sun_workshop\",\n#else\n\t\"-sun_workshop\",\n#endif\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    /* only interesting on Unix systems */\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n#ifdef FEAT_TAG_OLDSTATIC\n\t\"+tag_old_static\",\n#else\n\t\"-tag_old_static\",\n#endif\n#ifdef FEAT_TAG_ANYWHITE\n\t\"+tag_any_white\",\n#else\n\t\"-tag_any_white\",\n#endif\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#if defined(UNIX)\n/* only Unix can have terminfo instead of termcap */\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#else\t\t    /* unix always includes termcap support */\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n#ifdef FEAT_TITLE\n\t\"+title\",\n#else\n\t\"-title\",\n#endif\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n#ifdef FEAT_USR_CMDS\n\t\"+user_commands\",\n#else\n\t\"-user_commands\",\n#endif\n#ifdef FEAT_WINDOWS\n\t\"+vertsplit\",\n#else\n\t\"-vertsplit\",\n#endif\n#ifdef FEAT_VIRTUALEDIT\n\t\"+virtualedit\",\n#else\n\t\"-virtualedit\",\n#endif\n\t\"+visual\",\n#ifdef FEAT_VISUALEXTRA\n\t\"+visualextra\",\n#else\n\t\"-visualextra\",\n#endif\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n#ifdef FEAT_VREPLACE\n\t\"+vreplace\",\n#else\n\t\"-vreplace\",\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n#ifdef FEAT_WINDOWS\n\t\"+windows\",\n#else\n\t\"-windows\",\n#endif\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef WIN3264\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    int\t\ti;\n    int\t\th = 0;\n\n    for (i = 0; included_patches[i] != 0; ++i)\n\tif (included_patches[i] > h)\n\t    h = included_patches[i];\n    return h;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\ti;\n\n    for (i = 0; included_patches[i] != 0; ++i)\n\tif (included_patches[i] == n)\n\t    return TRUE;\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tnfeat = 0;\n    int\t\twidth = 0;\n\n    /* Find the length of the longest feature name, use that + 1 as the column\n     * width */\n    for (i = 0; features[i] != NULL; ++i)\n    {\n\tint l = (int)STRLEN(features[i]);\n\n\tif (l > width)\n\t    width = l;\n\t++nfeat;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t/* Not enough screen columns - show one per line */\n\tfor (i = 0; features[i] != NULL; ++i)\n\t{\n\t    version_msg(features[i]);\n\t    if (msg_col > 0)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    /* The rightmost column doesn't need a separator.\n     * Sacrifice it to fit in one more column if possible. */\n    ncol = (int) (Columns + 1) / width;\n    nrow = nfeat / ncol + (nfeat % ncol ? 1 : 0);\n\n    /* i counts columns then rows.  idx counts rows then columns. */\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < nfeat)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    msg_puts((char_u *)features[idx]);\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0)\n\t\t    msg_putchar('\\n');\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    if (msg_col > 0)\n\t\tmsg_putchar('\\n');\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    MSG(longVersion);\n#ifdef WIN3264\n# ifdef FEAT_GUI_W32\n#  ifdef _WIN64\n    MSG_PUTS(_(\"\\nMS-Windows 64-bit GUI version\"));\n#  else\n    MSG_PUTS(_(\"\\nMS-Windows 32-bit GUI version\"));\n#  endif\n# ifdef FEAT_OLE\n    MSG_PUTS(_(\" with OLE support\"));\n# endif\n# else\n#  ifdef _WIN64\n    MSG_PUTS(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    MSG_PUTS(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#ifdef MACOS\n# ifdef MACOS_X\n#  ifdef MACOS_X_UNIX\n    MSG_PUTS(_(\"\\nMacOS X (unix) version\"));\n#  else\n    MSG_PUTS(_(\"\\nMacOS X version\"));\n#  endif\n#else\n    MSG_PUTS(_(\"\\nMacOS version\"));\n# endif\n#endif\n\n#ifdef VMS\n    MSG_PUTS(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tMSG_PUTS(\" - \");\n\tMSG_PUTS(compiled_arch);\n    }\n# endif\n\n#endif\n\n    /* Print the list of patch numbers if there is at least one. */\n    /* Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\" */\n    if (included_patches[0] != 0)\n    {\n\tMSG_PUTS(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\t/* find last one */\n\tfor (i = 0; included_patches[i] != 0; ++i)\n\t    ;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tMSG_PUTS(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    MSG_PUTS(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    /* Print the list of extra patch descriptions if there is at least one. */\n    if (extra_patches[0] != NULL)\n    {\n\tMSG_PUTS(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    MSG_PUTS(s);\n\t    s = \", \";\n\t    MSG_PUTS(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    MSG_PUTS(\"\\n\");\n    MSG_PUTS(_(\"Modified by \"));\n    MSG_PUTS(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tMSG_PUTS(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    MSG_PUTS(_(\"by \"));\n\t    MSG_PUTS(compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    MSG_PUTS(\"@\");\n\t    MSG_PUTS(compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    MSG_PUTS(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    MSG_PUTS(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    MSG_PUTS(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    MSG_PUTS(_(\"\\nSmall version \"));\n#   else\n    MSG_PUTS(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    MSG_PUTS(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    MSG_PUTS(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     MSG_PUTS(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     MSG_PUTS(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    MSG_PUTS(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    MSG_PUTS(_(\"with X11-neXtaw GUI.\"));\n#    else\n    MSG_PUTS(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#     ifdef FEAT_GUI_PHOTON\n    MSG_PUTS(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    MSG_PUTS(_(\"with GUI.\"));\n#      else\n#\tif defined(TARGET_API_MAC_CARBON) && TARGET_API_MAC_CARBON\n    MSG_PUTS(_(\"with Carbon GUI.\"));\n#\telse\n#\t if defined(TARGET_API_MAC_OSX) && TARGET_API_MAC_OSX\n    MSG_PUTS(_(\"with Cocoa GUI.\"));\n#\t else\n#\t  if defined(MACOS)\n    MSG_PUTS(_(\"with (classic) GUI.\"));\n#\t  endif\n#\t endif\n#\tendif\n#      endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n */\n    static void\nversion_msg(char *s)\n{\n    int\t\tlen = (int)STRLEN(s);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n\tMSG_PUTS(s);\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (bufempty()\n\t    && curbuf->b_fname == NULL\n#ifdef FEAT_WINDOWS\n\t    && firstwin->w_next == NULL\n#endif\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    void\nintro_message(\n    int\t\tcolon)\t\t/* TRUE for \":intro\" */\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    /* blanklines = screen height - # message lines */\n    blanklines = (int)Rows - ((sizeof(lines) / sizeof(char *)) - 1);\n    if (!p_cp)\n\tblanklines += 4;  /* add 4 for not showing \"Vi compatible\" message */\n\n#ifdef FEAT_WINDOWS\n    /* Don't overwrite a statusline.  Depends on 'cmdheight'. */\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n#endif\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    /* Show the sponsor and register message one out of four times, the Uganda\n     * message two out of four times. */\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    /* start displaying the message lines after half of the blank lines */\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)(sizeof(lines) / sizeof(char *)); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    /* Make the wait-return message appear just below the text. */\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    /* Center the message horizontally. */\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    /* Check for 9.9x or 9.9xx, alpha/beta version */\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    /* Split up in parts to highlight <> items differently. */\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n#ifdef FEAT_MBYTE\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n#endif\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? hl_attr(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    /* Add the version number to the version line. */\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/undo.c", "src/version.c"], "buggy_code_start_loc": [1388, 766], "buggy_code_end_loc": [1415, 766], "fixing_code_start_loc": [1388, 767], "fixing_code_end_loc": [1413, 769], "type": "CWE-190", "message": "An integer overflow at an unserialize_uep memory allocation site would occur for vim before patch 8.0.0378, if it does not properly validate values for tree length when reading a corrupted undo file, which may lead to resultant buffer overflows.", "other": {"cve": {"id": "CVE-2017-6350", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-27T07:59:00.537", "lastModified": "2018-08-13T21:47:57.570", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An integer overflow at an unserialize_uep memory allocation site would occur for vim before patch 8.0.0378, if it does not properly validate values for tree length when reading a corrupted undo file, which may lead to resultant buffer overflows."}, {"lang": "es", "value": "Un desbordamiento de entero en un sitio de asignaci\u00f3n de memoria unserialize_uep ocurrir\u00eda para vim en versiones anteriores al parche 8.0.0378, si no valida correctamente los valores de longitud del arb\u00f3l de decisi\u00f3n, al leer un archivo desecho corrompido, lo que puede resultar en un desbordamiento de b\u00fafer."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndIncluding": "8.0.0377", "matchCriteriaId": "0A066C34-AF73-49F8-B14B-F34813E36107"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/96448", "source": "cve@mitre.org"}, {"url": "http://www.securitytracker.com/id/1037949", "source": "cve@mitre.org"}, {"url": "https://github.com/vim/vim/commit/0c8485f0e4931463c0f7986e1ea84a7d79f10c75", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://groups.google.com/forum/#!topic/vim_dev/L_dOHOOiQ5Q", "source": "cve@mitre.org"}, {"url": "https://groups.google.com/forum/#!topic/vim_dev/QPZc0CY9j3Y", "source": "cve@mitre.org"}, {"url": "https://security.gentoo.org/glsa/201706-26", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4309-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/vim/vim/commit/0c8485f0e4931463c0f7986e1ea84a7d79f10c75"}}