{"buggy_code": ["", "# pylint: disable=invalid-name\nfrom http import HTTPStatus\n\nfrom django.conf import settings\nfrom django.contrib.auth import get_user_model\nfrom django.http import HttpResponseForbidden\nfrom django.urls import reverse\nfrom django.utils.translation import gettext_lazy as _\n\nfrom tcms.kiwi_auth.admin import Group\nfrom tcms.tests import LoggedInTestCase, user_should_have_perm\nfrom tcms.tests.factories import GroupFactory, UserFactory\n\n\nclass TestUserAdmin(LoggedInTestCase):  # pylint: disable=too-many-public-methods\n    @classmethod\n    def setUpTestData(cls):\n        # Note: by default the logged-in user is self.tester\n        # who is not given any permissions\n        super().setUpTestData()\n\n        cls.admin = UserFactory(username=\"admin\")\n        cls.admin.is_superuser = True\n        cls.admin.set_password(\"admin-password\")\n        cls.admin.save()\n\n        # moderator is a non-superuser who is granted specific permissions\n        cls.moderator = UserFactory(username=\"moderator\")\n        cls.moderator.is_superuser = False\n        cls.moderator.set_password(\"admin-password\")\n        cls.moderator.save()\n\n    def setUp(self):\n        super().setUp()\n        # self.tester doesn't have any permissions\n        self.assertEqual(0, self.tester.user_permissions.count())\n\n    def test_superuser_can_view_list_of_all_users(self):\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.admin.username, password=\"admin-password\"\n        )\n        response = self.client.get(\"/admin/auth/user/\")\n        self.assertEqual(HTTPStatus.OK, response.status_code)\n        self.assertContains(response, self.admin.username)\n        self.assertContains(response, self.tester.username)\n        self.assertContains(response, self.moderator.username)\n\n    def test_superuser_can_view_user_profile(self):\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.admin.username, password=\"admin-password\"\n        )\n\n        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/change/\")\n        self.assertContains(response, self.tester.username)\n\n    def test_superuser_can_add_users(self):\n        # test for https://github.com/kiwitcms/Kiwi/issues/642\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.admin.username, password=\"admin-password\"\n        )\n        response = self.client.get(\"/admin/auth/user/add/\")\n        self.assertEqual(HTTPStatus.OK, response.status_code)\n\n        response = self.client.post(\n            \"/admin/auth/user/add/\",\n            {\n                \"username\": \"added-by-admin\",\n                \"password1\": \"xo-xo-xo\",\n                \"password2\": \"xo-xo-xo\",\n            },\n            follow=True,\n        )\n        self.assertEqual(HTTPStatus.OK, response.status_code)\n        self.assertTrue(\n            get_user_model().objects.filter(username=\"added-by-admin\").exists()\n        )\n\n    def test_superuser_can_change_other_users(self):\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.admin.username, password=\"admin-password\"\n        )\n\n        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/change/\")\n        response_str = str(response.content, encoding=settings.DEFAULT_CHARSET)\n\n        # 3 readonly fields\n        self.assertEqual(response_str.count(\"grp-readonly\"), 3)\n\n        # these fields can be edited\n        self.assertContains(response, \"id_first_name\")\n        self.assertContains(response, \"id_last_name\")\n        self.assertContains(response, \"id_email\")\n        self.assertContains(response, \"id_is_active\")\n        self.assertContains(response, \"id_is_staff\")\n        self.assertContains(response, \"id_is_superuser\")\n        self.assertContains(response, \"id_groups\")\n        self.assertContains(response, \"id_user_permissions\")\n\n        response = self.client.post(\n            f\"/admin/auth/user/{self.tester.pk}/change/\",\n            {\n                \"first_name\": \"Changed by admin\",\n                # required fields below\n                \"username\": self.tester.username,\n                \"email\": self.tester.email,\n                \"date_joined_0\": \"2018-09-03\",\n                \"date_joined_1\": \"13:16:25\",\n            },\n            follow=True,\n        )\n\n        self.assertEqual(HTTPStatus.OK, response.status_code)\n\n        self.tester.refresh_from_db()\n        self.assertEqual(self.tester.first_name, \"Changed by admin\")\n\n    def test_superuser_can_delete_itself(self):\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.admin.username, password=\"admin-password\"\n        )\n        response = self.client.get(\n            reverse(\"admin:auth_user_delete\", args=[self.admin.pk])\n        )\n        self.assertContains(response, _(\"Yes, I'm sure\"))\n\n        response = self.client.post(\n            reverse(\"admin:auth_user_delete\", args=[self.admin.pk]),\n            {\"post\": \"yes\"},\n            follow=True,\n        )\n        self.assertRedirects(response, \"/accounts/login/\")\n        self.assertFalse(get_user_model().objects.filter(pk=self.admin.pk).exists())\n\n    def test_superuser_can_delete_other_user(self):\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.admin.username, password=\"admin-password\"\n        )\n        response = self.client.get(\n            reverse(\"admin:auth_user_delete\", args=[self.tester.pk])\n        )\n        self.assertContains(response, _(\"Yes, I'm sure\"))\n\n        response = self.client.post(\n            reverse(\"admin:auth_user_delete\", args=[self.tester.pk]),\n            {\"post\": \"yes\"},\n            follow=True,\n        )\n        self.assertEqual(HTTPStatus.OK, response.status_code)\n        self.assertRedirects(response, \"/admin/auth/user/\")\n        self.assertFalse(get_user_model().objects.filter(pk=self.tester.pk).exists())\n\n    def test_superuser_can_change_their_password(self):\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.admin.username, password=\"admin-password\"\n        )\n\n        response = self.client.get(f\"/admin/auth/user/{self.admin.pk}/password/\")\n        # redirects to change password for themselves\n        self.assertRedirects(response, \"/admin/password_change/\")\n\n    def test_superuser_cant_change_password_for_others(self):\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.admin.username, password=\"admin-password\"\n        )\n\n        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/password/\")\n        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)\n\n    def test_moderator_can_view_list_of_all_users(self):\n        user_should_have_perm(self.moderator, \"auth.view_user\")\n\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.moderator.username, password=\"admin-password\"\n        )\n        response = self.client.get(\"/admin/auth/user/\")\n        self.assertEqual(HTTPStatus.OK, response.status_code)\n        self.assertContains(response, self.admin.username)\n        self.assertContains(response, self.tester.username)\n        self.assertContains(response, self.moderator.username)\n\n    def test_moderator_can_view_user_profile(self):\n        user_should_have_perm(self.moderator, \"auth.view_user\")\n\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.moderator.username, password=\"admin-password\"\n        )\n        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/change/\")\n        self.assertContains(response, self.tester.username)\n\n        # some fields are read-only\n        response_str = str(response.content, encoding=settings.DEFAULT_CHARSET)\n\n        # only 1 hidden field for csrf\n        self.assertEqual(response_str.count(\"<input\"), 1)\n        self.assertContains(response, '<input type=\"hidden\" name=\"csrfmiddlewaretoken\"')\n\n        # 9 readonly fields\n        self.assertEqual(response_str.count(\"grp-readonly\"), 9)\n\n        # no delete button\n        self.assertNotContains(response, f\"/admin/auth/user/{self.tester.pk}/delete/\")\n\n        # no save buttons\n        self.assertNotContains(response, \"_save\")\n        self.assertNotContains(response, \"_addanother\")\n        self.assertNotContains(response, \"_continue\")\n\n    def test_moderator_can_add_users(self):\n        user_should_have_perm(self.moderator, \"auth.add_user\")\n        user_should_have_perm(self.moderator, \"auth.change_user\")\n\n        # test for https://github.com/kiwitcms/Kiwi/issues/642\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.moderator.username, password=\"admin-password\"\n        )\n        response = self.client.get(\"/admin/auth/user/add/\")\n        self.assertEqual(HTTPStatus.OK, response.status_code)\n\n        # only these fields can be edited\n        self.assertContains(response, \"id_username\")\n        self.assertContains(response, \"id_password1\")\n        self.assertContains(response, \"id_password2\")\n\n        response = self.client.post(\n            \"/admin/auth/user/add/\",\n            {\n                \"username\": \"added-by-moderator\",\n                \"password1\": \"xo-xo-xo\",\n                \"password2\": \"xo-xo-xo\",\n            },\n            follow=True,\n        )\n        self.assertEqual(HTTPStatus.OK, response.status_code)\n        self.assertTrue(\n            get_user_model().objects.filter(username=\"added-by-moderator\").exists()\n        )\n\n    def test_moderator_can_change_other_users(self):\n        user_should_have_perm(self.moderator, \"auth.view_user\")\n        user_should_have_perm(self.moderator, \"auth.change_user\")\n\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.moderator.username, password=\"admin-password\"\n        )\n\n        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/change/\")\n        response_str = str(response.content, encoding=settings.DEFAULT_CHARSET)\n\n        # 2 readonly fields\n        self.assertEqual(response_str.count(\"grp-readonly\"), 2)\n\n        # these fields can be edited\n        self.assertContains(response, \"id_first_name\")\n        self.assertContains(response, \"id_last_name\")\n        self.assertContains(response, \"id_email\")\n        self.assertContains(response, \"id_is_active\")\n        self.assertContains(response, \"id_is_staff\")\n        self.assertContains(response, \"id_groups\")\n        self.assertContains(response, \"id_user_permissions\")\n\n        response = self.client.post(\n            f\"/admin/auth/user/{self.tester.pk}/change/\",\n            {\n                \"first_name\": \"Changed by moderator\",\n                # required fields below\n                \"username\": self.tester.username,\n                \"email\": self.tester.email,\n                \"date_joined_0\": \"2018-09-03\",\n                \"date_joined_1\": \"13:16:25\",\n            },\n            follow=True,\n        )\n\n        self.assertEqual(HTTPStatus.OK, response.status_code)\n\n        self.tester.refresh_from_db()\n        self.assertEqual(self.tester.first_name, \"Changed by moderator\")\n\n    def test_moderator_can_delete_itself(self):\n        user_should_have_perm(self.moderator, \"auth.delete_user\")\n\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.moderator.username, password=\"admin-password\"\n        )\n        response = self.client.get(\n            reverse(\"admin:auth_user_delete\", args=[self.moderator.pk])\n        )\n        self.assertContains(response, _(\"Yes, I'm sure\"))\n\n        response = self.client.post(\n            reverse(\"admin:auth_user_delete\", args=[self.moderator.pk]),\n            {\"post\": \"yes\"},\n            follow=True,\n        )\n        self.assertRedirects(response, \"/accounts/login/\")\n        self.assertFalse(get_user_model().objects.filter(pk=self.moderator.pk).exists())\n\n    def test_moderator_can_delete_other_user(self):\n        user_should_have_perm(self.moderator, \"auth.view_user\")\n        user_should_have_perm(self.moderator, \"auth.delete_user\")\n\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.moderator.username, password=\"admin-password\"\n        )\n        response = self.client.get(\n            reverse(\"admin:auth_user_delete\", args=[self.tester.pk])\n        )\n        self.assertContains(response, _(\"Yes, I'm sure\"))\n\n        response = self.client.post(\n            reverse(\"admin:auth_user_delete\", args=[self.tester.pk]),\n            {\"post\": \"yes\"},\n            follow=True,\n        )\n        self.assertEqual(HTTPStatus.OK, response.status_code)\n        # b/c our test has only view & delete perms\n        self.assertRedirects(response, \"/admin/\")\n        self.assertFalse(get_user_model().objects.filter(pk=self.tester.pk).exists())\n\n    def test_moderator_can_change_their_password(self):\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.moderator.username, password=\"admin-password\"\n        )\n\n        response = self.client.get(f\"/admin/auth/user/{self.moderator.pk}/password/\")\n        # redirects to change password for themselves\n        self.assertRedirects(response, \"/admin/password_change/\")\n\n    def test_moderator_cant_change_password_for_others(self):\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.moderator.username, password=\"admin-password\"\n        )\n\n        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/password/\")\n        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)\n\n    def test_regular_user_cant_view_list_of_all_users(self):\n        response = self.client.get(\"/admin/auth/user/\")\n        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)\n\n    def test_regular_user_cant_view_single_profile_without_permission(self):\n        response = self.client.get(f\"/admin/auth/user/{self.admin.pk}/change/\")\n        self.assertIsInstance(response, HttpResponseForbidden)\n\n    def test_regular_user_can_view_themselves(self):\n        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/change/\")\n        response_str = str(response.content, encoding=settings.DEFAULT_CHARSET)\n\n        # only 1 hidden field for csrf\n        self.assertContains(response, '<input type=\"hidden\" name=\"csrfmiddlewaretoken\"')\n\n        # 6 readonly fields\n        self.assertEqual(response_str.count(\"grp-readonly\"), 6)\n\n        # only these fields can be edited\n        self.assertContains(response, \"id_first_name\")\n        self.assertContains(response, \"id_last_name\")\n        self.assertContains(response, \"id_email\")\n\n        # Has Delete button\n        self.assertContains(response, f\"/admin/auth/user/{self.tester.pk}/delete/\")\n\n        # Has Save buttons\n        self.assertContains(response, \"_save\")\n        self.assertContains(response, \"_continue\")\n        self.assertNotContains(response, \"_addanother\")\n\n    def test_regular_user_cant_add_users(self):\n        response = self.client.get(\"/admin/auth/user/add/\")\n        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)\n\n        response = self.client.post(\n            \"/admin/auth/user/add/\",\n            {\n                \"username\": \"added-by-regular-user\",\n                \"password1\": \"xo-xo-xo\",\n                \"password2\": \"xo-xo-xo\",\n            },\n            follow=True,\n        )\n        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)\n        self.assertFalse(\n            get_user_model().objects.filter(username=\"added-by-regular-user\").exists()\n        )\n\n    def test_regular_user_cant_change_other_users(self):\n        response = self.client.get(f\"/admin/auth/user/{self.admin.pk}/change/\")\n        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)\n\n        response = self.client.post(\n            f\"/admin/auth/user/{self.admin.pk}/change/\",\n            {\n                \"first_name\": \"Changed by regular user\",\n                # required fields below\n                \"username\": self.admin.username,\n                \"email\": self.admin.email,\n                \"date_joined_0\": \"2018-09-03\",\n                \"date_joined_1\": \"13:16:25\",\n            },\n            follow=True,\n        )\n        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)\n\n        self.admin.refresh_from_db()\n        self.assertNotEqual(self.admin.first_name, \"Changed by regular user\")\n\n    def test_regular_user_can_change_themselves(self):\n        response = self.client.post(\n            f\"/admin/auth/user/{self.tester.pk}/change/\",\n            {\n                \"first_name\": \"Changed by myself\",\n                # required fields below\n                \"username\": self.tester.username,\n                \"email\": self.tester.email,\n                \"date_joined_0\": \"2018-09-03\",\n                \"date_joined_1\": \"13:16:25\",\n            },\n            follow=True,\n        )\n        self.assertEqual(HTTPStatus.OK, response.status_code)\n\n        self.tester.refresh_from_db()\n        self.assertEqual(self.tester.first_name, \"Changed by myself\")\n\n    def test_regular_user_cant_delete_others(self):\n        response = self.client.get(f\"/admin/auth/user/{self.admin.pk}/delete/\")\n        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)\n\n    def test_regular_user_can_delete_myself(self):\n        response = self.client.get(\n            reverse(\"admin:auth_user_delete\", args=[self.tester.pk])\n        )\n        self.assertContains(response, _(\"Yes, I'm sure\"))\n\n        response = self.client.post(\n            reverse(\"admin:auth_user_delete\", args=[self.tester.pk]),\n            {\"post\": \"yes\"},\n            follow=True,\n        )\n        self.assertRedirects(response, \"/accounts/login/\")\n        self.assertFalse(get_user_model().objects.filter(pk=self.tester.pk).exists())\n\n    def test_regular_user_can_change_their_password(self):\n        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/password/\")\n        # redirects to change password for themselves\n        self.assertRedirects(response, \"/admin/password_change/\")\n\n    def test_regular_user_cant_change_password_for_others(self):\n        response = self.client.get(f\"/admin/auth/user/{self.moderator.pk}/password/\")\n        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)\n\n\nclass TestGroupAdmin(LoggedInTestCase):\n    @classmethod\n    def setUpTestData(cls):\n        super().setUpTestData()\n\n        cls.tester.is_superuser = True\n        cls.tester.save()\n\n        cls.group = GroupFactory(name=\"NewGroupName\")\n        cls.group.save()\n        cls.defaultGroups = Group.objects.filter(name__in=[\"Administrator\", \"Tester\"])\n\n    def test_should_not_be_allowed_to_change_groups_with_default_names(self):\n        for group in self.defaultGroups:\n            response = self.client.get(\n                reverse(\"admin:auth_group_change\", args=[group.id])\n            )\n            self.assertNotContains(\n                response,\n                f'<input type=\"text\" name=\"name\" value=\"{group.name}\" class=\"vTextField\"'\n                ' maxlength=\"150\" required=\"\" id=\"id_name\">',\n            )\n            self.assertContains(\n                response, f'<div class=\"grp-readonly\">{group.name}</div>'\n            )\n\n    def test_should_not_be_allowed_to_delete_default_groups(self):\n        for group in self.defaultGroups:\n            response = self.client.get(\n                reverse(\"admin:auth_group_change\", args=[group.id])\n            )\n            _expected_url = reverse(\"admin:auth_group_delete\", args=[self.group.id])\n            _delete = _(\"Delete\")\n            self.assertNotContains(\n                response,\n                f'<a href=\"{_expected_url}\" class=\"grp-button grp-delete-link\">{_delete}</a>',\n            )\n\n    def test_should_be_allowed_to_create_new_group(self):\n        response = self.client.get(reverse(\"admin:auth_group_add\"))\n        _add_group = _(\"Add %s\") % _(\"group\")\n        self.assertContains(response, f\"<h1>{_add_group}</h1>\")\n        self.assertContains(\n            response,\n            '<input type=\"text\" name=\"name\" class=\"vTextField\" '\n            'maxlength=\"150\" required id=\"id_name\">',\n        )\n\n        # check for the user widget\n        self.assertContains(\n            response,\n            '<select name=\"users\" id=\"id_users\" multiple '\n            'class=\"selectfilter\" data-field-name=\"users\" data-is-stacked=\"0\">',\n        )\n        _label = _(\"Users\")\n        self.assertContains(response, f'<label for=\"id_users\">{_label}')\n\n    def test_should_be_able_to_delete_a_non_default_group(self):\n        response = self.client.get(\n            reverse(\"admin:auth_group_delete\", args=[self.group.id]), follow=True\n        )\n        _are_you_sure = _(\"Are you sure?\")\n        self.assertContains(response, f\"<h1>{_are_you_sure}</h1>\")\n\n    def test_should_be_able_to_edit_a_non_default_group(self):\n        response = self.client.get(\n            reverse(\"admin:auth_group_change\", args=[self.group.id])\n        )\n        self.assertContains(\n            response,\n            f'<input type=\"text\" name=\"name\" value=\"{self.group.name}\" class=\"vTextField\"'\n            ' maxlength=\"150\" required id=\"id_name\">',\n        )\n\n    def test_should_be_allowed_to_create_new_group_with_added_user(self):\n        self.assertFalse(self.tester.groups.filter(name=self.group.name).exists())\n\n        group_name = \"TestGroupName\"\n        response = self.client.post(\n            reverse(\"admin:auth_group_add\"),\n            {\"name\": group_name, \"users\": [self.tester.id]},\n            follow=True,\n        )\n\n        group = self.tester.groups.get(name=group_name)\n\n        self.assertIsNotNone(group)\n        self.assertContains(response, group_name)\n        group_url = reverse(\"admin:auth_group_change\", args=[group.pk])\n        self.assertContains(\n            response,\n            f'<a href=\"{group_url}\">{group_name}</a>',\n        )\n\n    def test_should_be_able_to_add_user_while_editing_a_group(self):\n        self.assertFalse(self.tester.groups.filter(name=self.group.name).exists())\n        response = self.client.post(\n            reverse(\"admin:auth_group_change\", args=[self.group.id]),\n            {\"name\": self.group.name, \"users\": [self.tester.id], \"_continue\": True},\n            follow=True,\n        )\n\n        self.assertContains(\n            response,\n            f'<option value=\"{self.tester.pk}\" selected>{self.tester.username}</option>',\n        )\n        self.assertTrue(self.tester.groups.filter(name=self.group.name).exists())\n", "import importlib\n\nfrom django.test import TestCase, override_settings\nfrom django.utils.translation import gettext_lazy as _\n\nfrom tcms.kiwi_auth import forms\n\n\nclass TestCaptchaField(TestCase):\n    def setUp(self):\n        self.data = {\n            \"username\": \"test_user\",\n            \"password1\": \"password\",\n            \"password2\": \"password\",\n            \"email\": \"new-tester@example.com\",\n        }\n\n    def test_captcha_required_when_enabled(self):\n        importlib.reload(forms)\n        form = forms.RegistrationForm(data=self.data)\n\n        self.assertFalse(form.is_valid())\n        self.assertIn(\"captcha\", form.errors.keys())\n        self.assertIn(_(\"This field is required.\"), form.errors[\"captcha\"])\n\n    def test_captcha_fails_when_wrong(self):\n        data = self.data.copy()\n        data[\"captcha_0\"] = \"correct\"\n        data[\"captcha_1\"] = \"WRONG\"\n\n        importlib.reload(forms)\n        form = forms.RegistrationForm(data=data)\n\n        self.assertFalse(form.is_valid())\n        self.assertIn(\"captcha\", form.errors.keys())\n        self.assertIn(_(\"Invalid CAPTCHA\"), form.errors[\"captcha\"])\n\n    @override_settings(USE_CAPTCHA=False)\n    def test_captcha_not_required_when_disabled(self):\n        importlib.reload(forms)\n        form = forms.RegistrationForm(data=self.data)\n\n        self.assertTrue(form.is_valid())\n        self.assertNotIn(\"captcha\", form.errors.keys())\n\n\n@override_settings(USE_CAPTCHA=False)\nclass TestRegistrationForm(TestCase):\n    def setUp(self):\n        self.data = {\n            \"username\": \"test_user\",\n            \"password1\": \"password\",\n            \"password2\": \"password\",\n            \"email\": \"new-tester@example.com\",\n        }\n\n    def test_user_not_created_when_commit(self):\n        importlib.reload(forms)\n        form = forms.RegistrationForm(data=self.data)\n\n        user = form.save(commit=False)\n        self.assertIsNone(user.pk)\n\n    def test_user_created_when_commit(self):\n        importlib.reload(forms)\n        form = forms.RegistrationForm(data=self.data)\n\n        user = form.save()\n        self.assertIsNotNone(user.pk)\n", "# -*- coding: utf-8 -*-\n# pylint: disable=invalid-name\n\nimport datetime\n\nfrom django.conf import settings\nfrom django.contrib.auth import get_user_model\nfrom django.contrib.sites.models import Site\nfrom django.test import TestCase, override_settings\nfrom django.urls import reverse\nfrom django.utils import timezone\nfrom django.utils.translation import gettext_lazy as _\nfrom mock import patch\n\nfrom tcms import signals\nfrom tcms.kiwi_auth import forms\nfrom tcms.kiwi_auth.models import UserActivationKey\nfrom tcms.tests.factories import UserFactory\n\nUser = get_user_model()  # pylint: disable=invalid-name\n\n\nclass TestSetRandomKey(TestCase):\n    \"\"\"Test case for UserActivationKey.set_random_key_for_user\"\"\"\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.new_user = UserFactory()\n\n    @patch(\"tcms.kiwi_auth.models.datetime\")\n    def test_set_random_key(self, mock_datetime):\n        now = timezone.now()\n        in_7_days = datetime.timedelta(7)\n\n        mock_datetime.datetime.today.return_value = now\n        mock_datetime.timedelta.return_value = in_7_days\n\n        activation_key = UserActivationKey.set_random_key_for_user(self.new_user)\n        self.assertEqual(self.new_user, activation_key.user)\n        self.assertNotEqual(\"\", activation_key.activation_key)\n        self.assertEqual(now + in_7_days, activation_key.key_expires)\n\n\nclass TestForceToSetRandomKey(TestCase):\n    \"\"\"Test case for UserActivationKey.set_random_key_for_user forcely\"\"\"\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.new_user = UserFactory()\n        cls.origin_activation_key = UserActivationKey.set_random_key_for_user(\n            cls.new_user\n        )\n\n    def test_set_random_key_forcely(self):\n        new_activation_key = UserActivationKey.set_random_key_for_user(\n            self.new_user, force=True\n        )\n        self.assertEqual(self.origin_activation_key.user, new_activation_key.user)\n        self.assertNotEqual(\n            self.origin_activation_key.activation_key, new_activation_key.activation_key\n        )\n\n\n# ### Test cases for view methods ###\n\n\nclass TestLogout(TestCase):\n    \"\"\"Test for logout view method\"\"\"\n\n    @classmethod\n    def setUpTestData(cls):\n        super(TestLogout, cls).setUpTestData()\n\n        cls.tester = UserFactory()\n        cls.tester.set_password(\"password\")\n        cls.tester.save()\n        cls.logout_url = reverse(\"tcms-logout\")\n\n    def test_logout_redirects_to_login_page(self):\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.tester.username, password=\"password\"\n        )\n        response = self.client.get(self.logout_url, follow=True)\n        self.assertRedirects(response, reverse(\"tcms-login\"))\n\n    def test_logout_then_goto_next(self):\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.tester.username, password=\"password\"\n        )\n        next_url = reverse(\"tcms-login\") + \"?next=\" + reverse(\"plans-search\")\n        response = self.client.get(self.logout_url, {\"next\": next_url}, follow=True)\n        self.assertRedirects(response, next_url)\n\n\nclass TestRegistration(TestCase):\n    def setUp(self):\n        self.register_url = reverse(\"tcms-register\")\n        self.fake_activate_key = \"secret-activate-key\"\n\n    def test_open_registration_page(self):\n        response = self.client.get(self.register_url)\n        _register = _(\"Register\")\n        self.assertContains(response, f\">{_register}</button>\")\n\n    def assert_user_registration(self, username, follow=False):\n        with patch(\"tcms.kiwi_auth.models.secrets\") as _secrets:\n            _secrets.token_hex.return_value = self.fake_activate_key\n\n            try:\n                # https://github.com/mbi/django-simple-captcha/issues/84\n                # pylint: disable=import-outside-toplevel\n                from captcha.conf import settings as captcha_settings\n\n                captcha_settings.CAPTCHA_TEST_MODE = True\n\n                response = self.client.post(\n                    self.register_url,\n                    {\n                        \"username\": username,\n                        \"password1\": \"password\",\n                        \"password2\": \"password\",\n                        \"email\": \"new-tester@example.com\",\n                        \"captcha_0\": \"PASSED\",\n                        \"captcha_1\": \"PASSED\",\n                    },\n                    follow=follow,\n                )\n            finally:\n                captcha_settings.CAPTCHA_TEST_MODE = False\n\n        user = User.objects.get(username=username)\n        self.assertEqual(\"new-tester@example.com\", user.email)\n        if User.objects.filter(is_superuser=True).count() == 1 and user.is_superuser:\n            self.assertTrue(user.is_active)\n        else:\n            self.assertFalse(user.is_active)\n\n        key = UserActivationKey.objects.get(user=user)\n        self.assertEqual(self.fake_activate_key, key.activation_key)\n\n        return response, user\n\n    @patch(\"tcms.signals.USER_REGISTERED_SIGNAL.send\")\n    def test_register_user_sends_signal(self, signal_mock):\n        self.assert_user_registration(\"new-signal-tester\")\n        self.assertTrue(signal_mock.called)\n        self.assertEqual(1, signal_mock.call_count)\n\n    @override_settings(ADMINS=[(\"Test Admin\", \"admin@kiwitcms.org\")])\n    @patch(\"tcms.core.utils.mailto.send_mail\")\n    def test_signal_handler_notifies_admins(self, send_mail):\n        # connect the handler b/c it is not connected by default\n        signals.USER_REGISTERED_SIGNAL.connect(signals.notify_admins)\n\n        try:\n            response, user = self.assert_user_registration(\"signal-handler\")\n            self.assertRedirects(\n                response, reverse(\"core-views-index\"), target_status_code=302\n            )\n\n            # 1 - verification mail, 2 - email to admin\n            self.assertTrue(send_mail.called)\n            self.assertEqual(2, send_mail.call_count)\n\n            # verify we've actually sent the admin email\n            self.assertIn(\n                str(_(\"New user awaiting approval\")), send_mail.call_args_list[0][0][0]\n            )\n            values = {\n                \"username\": \"signal-handler\",\n                \"user_url\": f\"http://testserver/admin/auth/user/{user.pk}/change/\",\n            }\n            expected = (\n                _(\n                    \"\"\"Dear Administrator,\nsomebody just registered an account with username %(username)s at your\nKiwi TCMS instance and is awaiting your approval!\n\nGo to %(user_url)s to activate the account!\"\"\"\n                )\n                % values\n            )\n            self.assertEqual(\n                expected.strip(), send_mail.call_args_list[0][0][1].strip()\n            )\n            self.assertIn(\"admin@kiwitcms.org\", send_mail.call_args_list[0][0][-1])\n        finally:\n            signals.USER_REGISTERED_SIGNAL.disconnect(signals.notify_admins)\n\n    @patch(\"tcms.core.utils.mailto.send_mail\")\n    def test_register_user_by_email_confirmation(self, send_mail):\n        response, user = self.assert_user_registration(\"new-tester\", follow=True)\n        self.assertContains(\n            response,\n            _(\n                \"Your account has been created, please check your mailbox for confirmation\"\n            ),\n        )\n\n        site = Site.objects.get(pk=settings.SITE_ID)\n        _confirm_url = reverse(\"tcms-confirm\", args=[self.fake_activate_key])\n        confirm_url = f\"http://{site.domain}{_confirm_url}\"\n\n        # Verify notification mail\n        values = {\n            \"user\": user.username,\n            \"site_domain\": site.domain,\n            \"confirm_url\": confirm_url,\n        }\n        expected_subject = (\n            settings.EMAIL_SUBJECT_PREFIX\n            + _(\"Your new %s account confirmation\") % site.domain\n        )\n        expected_body = (\n            _(\n                \"\"\"Welcome %(user)s,\nthank you for signing up for an %(site_domain)s account!\n\nTo activate your account, click this link:\n%(confirm_url)s\"\"\"\n            )\n            % values\n            + \"\\n\"\n        )\n        send_mail.assert_called_once_with(\n            expected_subject,\n            expected_body,\n            settings.DEFAULT_FROM_EMAIL,\n            [\"new-tester@example.com\"],\n            fail_silently=False,\n        )\n\n    @override_settings(\n        AUTO_APPROVE_NEW_USERS=False,\n        ADMINS=[(\"admin1\", \"admin1@example.com\"), (\"admin2\", \"admin2@example.com\")],\n    )\n    def test_register_user_and_activate_by_admin(self):\n        response, _user = self.assert_user_registration(\"plan-tester\", follow=True)\n\n        self.assertContains(\n            response,\n            _(\n                \"Your account has been created, but you need an administrator to activate it\"\n            ),\n        )\n\n        for (name, email) in settings.ADMINS:\n            self.assertContains(\n                response, f'<a href=\"mailto:{email}\">{name}</a>', html=True\n            )\n\n    def test_invalid_form(self):\n        response = self.client.post(\n            self.register_url,\n            {\n                \"username\": \"kiwi-tester\",\n                \"password1\": \"password-1\",\n                \"password2\": \"password-2\",\n                \"email\": \"new-tester@example.com\",\n            },\n            follow=False,\n        )\n\n        self.assertContains(response, _(\"The two password fields didn\u2019t match.\"))\n        self.assertEqual(response.status_code, 200)\n        self.assertTemplateUsed(response, \"registration/registration_form.html\")\n\n    def test_register_user_already_registered(self):\n        User.objects.create_user(\"kiwi-tester\", \"new-tester@example.com\", \"password\")\n\n        response = self.client.post(\n            self.register_url,\n            {\n                \"username\": \"test_user\",\n                \"password1\": \"password\",\n                \"password2\": \"password\",\n                \"email\": \"new-tester@example.com\",\n            },\n            follow=False,\n        )\n        self.assertContains(response, _(\"A user with that email already exists.\"))\n\n        user = User.objects.filter(username=\"test_user\")\n        self.assertEqual(user.count(), 0)\n\n    def test_first_user_is_superuser(self):\n        _response, user = self.assert_user_registration(\"tester_1\")\n\n        self.assertTrue(user.is_superuser)\n        self.assertTrue(user.is_active)\n\n    def test_only_one_superuser(self):\n        user1 = User.objects.create_user(\n            \"kiwi-tester\", \"tester@example.com\", \"password\"\n        )\n        user1.is_superuser = True\n        user1.save()\n\n        self.assertTrue(user1.is_superuser)\n\n        _response, user2 = self.assert_user_registration(\"plan-tester\")\n        self.assertFalse(user2.is_superuser)\n\n\nclass TestConfirm(TestCase):\n    \"\"\"Test for activation key confirmation\"\"\"\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.new_user = UserFactory()\n\n    def setUp(self):\n        self.new_user.is_active = False\n        self.new_user.save()\n\n    def test_fail_if_activation_key_does_not_exist(self):\n        confirm_url = reverse(\"tcms-confirm\", args=[\"nonexisting-activation-key\"])\n        response = self.client.get(confirm_url, follow=True)\n\n        self.assertContains(\n            response, _(\"This activation key no longer exists in the database\")\n        )\n\n        # user account not activated\n        user = User.objects.get(username=self.new_user.username)\n        self.assertFalse(user.is_active)\n\n    def test_fail_if_activation_key_expired(self):\n        fake_activation_key = \"secret-activation-key\"\n\n        with patch(\"tcms.kiwi_auth.models.secrets\") as _secrets:\n            _secrets.token_hex.return_value = fake_activation_key\n            key = UserActivationKey.set_random_key_for_user(self.new_user)\n            key.key_expires = timezone.now() - datetime.timedelta(days=10)\n            key.save()\n\n        confirm_url = reverse(\"tcms-confirm\", args=[fake_activation_key])\n        response = self.client.get(confirm_url, follow=True)\n\n        self.assertContains(response, _(\"This activation key has expired\"))\n\n        # user account not activated\n        user = User.objects.get(username=self.new_user.username)\n        self.assertFalse(user.is_active)\n\n    def test_confirm(self):\n        fake_activate_key = \"secret-activate-key\"\n\n        with patch(\"tcms.kiwi_auth.models.secrets\") as _secrets:\n            _secrets.token_hex.return_value = fake_activate_key\n            UserActivationKey.set_random_key_for_user(self.new_user)\n\n        confirm_url = reverse(\"tcms-confirm\", args=[fake_activate_key])\n        response = self.client.get(confirm_url, follow=True)\n\n        self.assertContains(response, _(\"Your account has been activated successfully\"))\n\n        # user account activated\n        user = User.objects.get(username=self.new_user.username)\n        self.assertTrue(user.is_active)\n        activate_key_deleted = not UserActivationKey.objects.filter(user=user).exists()\n        self.assertTrue(activate_key_deleted)\n\n\nclass TestLoginViewWithCustomTemplate(TestCase):\n    \"\"\"Test for login view with custom template\"\"\"\n\n    def test_get_template_names(self):\n        response = self.client.get(reverse(\"tcms-login\"))\n        self.assertIsNotNone(response.template_name)\n        self.assertEqual(\n            response.template_name,\n            [\"registration/custom_login.html\", \"registration/login.html\"],\n        )\n\n\nclass TestPasswordResetView(TestCase):\n    \"\"\"Test for password reset view\"\"\"\n\n    def setUp(self):\n        self.password_reset_url = reverse(\"tcms-password_reset\")\n\n    def test_form_class(self):\n        response = self.client.get(self.password_reset_url)\n        self.assertEqual(\n            str(type(response.context[\"form\"])),\n            str(forms.PasswordResetForm),\n        )\n\n    def test_open_password_reset_page(self):\n        response = self.client.get(self.password_reset_url)\n\n        _password_reset = _(\"Password reset\")\n        self.assertContains(response, f\">{_password_reset}</button>\")\n\n    @patch(\"tcms.kiwi_auth.forms.DjangoPasswordResetForm.send_mail\")\n    def test_send_mail_for_password_reset(self, mail_sent):\n        user = User.objects.create_user(\"kiwi-tester\", \"tester@example.com\", \"password\")\n        user.is_active = True\n        user.save()\n        data = {\"email\": \"tester@example.com\"}\n        response = self.client.post(self.password_reset_url, data, follow=True)\n\n        self.assertContains(response, _(\"Password reset email was sent\"))\n\n        # Verify mail is sent\n        mail_sent.assert_called_once()\n"], "fixing_code": ["__FOR_TESTING__ = \"5a5b6e17f9c34025a75b052fc06c50ab\"\n", "# pylint: disable=invalid-name\nfrom http import HTTPStatus\n\nfrom django.conf import settings\nfrom django.contrib.auth import get_user_model\nfrom django.http import HttpResponseForbidden\nfrom django.urls import reverse\nfrom django.utils.translation import gettext_lazy as _\n\nfrom tcms.kiwi_auth.admin import Group\nfrom tcms.tests import LoggedInTestCase, user_should_have_perm\nfrom tcms.tests.factories import GroupFactory, UserFactory\n\nfrom . import __FOR_TESTING__\n\n\nclass TestUserAdmin(LoggedInTestCase):  # pylint: disable=too-many-public-methods\n    @classmethod\n    def setUpTestData(cls):\n        # Note: by default the logged-in user is self.tester\n        # who is not given any permissions\n        super().setUpTestData()\n\n        cls.admin = UserFactory(username=\"admin\")\n        cls.admin.is_superuser = True\n        cls.admin.set_password(\"admin-password\")\n        cls.admin.save()\n\n        # moderator is a non-superuser who is granted specific permissions\n        cls.moderator = UserFactory(username=\"moderator\")\n        cls.moderator.is_superuser = False\n        cls.moderator.set_password(\"admin-password\")\n        cls.moderator.save()\n\n    def setUp(self):\n        super().setUp()\n        # self.tester doesn't have any permissions\n        self.assertEqual(0, self.tester.user_permissions.count())\n\n    def test_superuser_can_view_list_of_all_users(self):\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.admin.username, password=\"admin-password\"\n        )\n        response = self.client.get(\"/admin/auth/user/\")\n        self.assertEqual(HTTPStatus.OK, response.status_code)\n        self.assertContains(response, self.admin.username)\n        self.assertContains(response, self.tester.username)\n        self.assertContains(response, self.moderator.username)\n\n    def test_superuser_can_view_user_profile(self):\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.admin.username, password=\"admin-password\"\n        )\n\n        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/change/\")\n        self.assertContains(response, self.tester.username)\n\n    def test_superuser_can_add_users(self):\n        # test for https://github.com/kiwitcms/Kiwi/issues/642\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.admin.username, password=\"admin-password\"\n        )\n        response = self.client.get(\"/admin/auth/user/add/\")\n        self.assertEqual(HTTPStatus.OK, response.status_code)\n\n        response = self.client.post(\n            \"/admin/auth/user/add/\",\n            {\n                \"username\": \"added-by-admin\",\n                \"password1\": __FOR_TESTING__,\n                \"password2\": __FOR_TESTING__,\n            },\n            follow=True,\n        )\n        self.assertEqual(HTTPStatus.OK, response.status_code)\n        self.assertTrue(\n            get_user_model().objects.filter(username=\"added-by-admin\").exists()\n        )\n\n    def test_superuser_can_change_other_users(self):\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.admin.username, password=\"admin-password\"\n        )\n\n        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/change/\")\n        response_str = str(response.content, encoding=settings.DEFAULT_CHARSET)\n\n        # 3 readonly fields\n        self.assertEqual(response_str.count(\"grp-readonly\"), 3)\n\n        # these fields can be edited\n        self.assertContains(response, \"id_first_name\")\n        self.assertContains(response, \"id_last_name\")\n        self.assertContains(response, \"id_email\")\n        self.assertContains(response, \"id_is_active\")\n        self.assertContains(response, \"id_is_staff\")\n        self.assertContains(response, \"id_is_superuser\")\n        self.assertContains(response, \"id_groups\")\n        self.assertContains(response, \"id_user_permissions\")\n\n        response = self.client.post(\n            f\"/admin/auth/user/{self.tester.pk}/change/\",\n            {\n                \"first_name\": \"Changed by admin\",\n                # required fields below\n                \"username\": self.tester.username,\n                \"email\": self.tester.email,\n                \"date_joined_0\": \"2018-09-03\",\n                \"date_joined_1\": \"13:16:25\",\n            },\n            follow=True,\n        )\n\n        self.assertEqual(HTTPStatus.OK, response.status_code)\n\n        self.tester.refresh_from_db()\n        self.assertEqual(self.tester.first_name, \"Changed by admin\")\n\n    def test_superuser_can_delete_itself(self):\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.admin.username, password=\"admin-password\"\n        )\n        response = self.client.get(\n            reverse(\"admin:auth_user_delete\", args=[self.admin.pk])\n        )\n        self.assertContains(response, _(\"Yes, I'm sure\"))\n\n        response = self.client.post(\n            reverse(\"admin:auth_user_delete\", args=[self.admin.pk]),\n            {\"post\": \"yes\"},\n            follow=True,\n        )\n        self.assertRedirects(response, \"/accounts/login/\")\n        self.assertFalse(get_user_model().objects.filter(pk=self.admin.pk).exists())\n\n    def test_superuser_can_delete_other_user(self):\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.admin.username, password=\"admin-password\"\n        )\n        response = self.client.get(\n            reverse(\"admin:auth_user_delete\", args=[self.tester.pk])\n        )\n        self.assertContains(response, _(\"Yes, I'm sure\"))\n\n        response = self.client.post(\n            reverse(\"admin:auth_user_delete\", args=[self.tester.pk]),\n            {\"post\": \"yes\"},\n            follow=True,\n        )\n        self.assertEqual(HTTPStatus.OK, response.status_code)\n        self.assertRedirects(response, \"/admin/auth/user/\")\n        self.assertFalse(get_user_model().objects.filter(pk=self.tester.pk).exists())\n\n    def test_superuser_can_change_their_password(self):\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.admin.username, password=\"admin-password\"\n        )\n\n        response = self.client.get(f\"/admin/auth/user/{self.admin.pk}/password/\")\n        # redirects to change password for themselves\n        self.assertRedirects(response, \"/admin/password_change/\")\n\n    def test_superuser_cant_change_password_for_others(self):\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.admin.username, password=\"admin-password\"\n        )\n\n        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/password/\")\n        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)\n\n    def test_moderator_can_view_list_of_all_users(self):\n        user_should_have_perm(self.moderator, \"auth.view_user\")\n\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.moderator.username, password=\"admin-password\"\n        )\n        response = self.client.get(\"/admin/auth/user/\")\n        self.assertEqual(HTTPStatus.OK, response.status_code)\n        self.assertContains(response, self.admin.username)\n        self.assertContains(response, self.tester.username)\n        self.assertContains(response, self.moderator.username)\n\n    def test_moderator_can_view_user_profile(self):\n        user_should_have_perm(self.moderator, \"auth.view_user\")\n\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.moderator.username, password=\"admin-password\"\n        )\n        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/change/\")\n        self.assertContains(response, self.tester.username)\n\n        # some fields are read-only\n        response_str = str(response.content, encoding=settings.DEFAULT_CHARSET)\n\n        # only 1 hidden field for csrf\n        self.assertEqual(response_str.count(\"<input\"), 1)\n        self.assertContains(response, '<input type=\"hidden\" name=\"csrfmiddlewaretoken\"')\n\n        # 9 readonly fields\n        self.assertEqual(response_str.count(\"grp-readonly\"), 9)\n\n        # no delete button\n        self.assertNotContains(response, f\"/admin/auth/user/{self.tester.pk}/delete/\")\n\n        # no save buttons\n        self.assertNotContains(response, \"_save\")\n        self.assertNotContains(response, \"_addanother\")\n        self.assertNotContains(response, \"_continue\")\n\n    def test_moderator_can_add_users(self):\n        user_should_have_perm(self.moderator, \"auth.add_user\")\n        user_should_have_perm(self.moderator, \"auth.change_user\")\n\n        # test for https://github.com/kiwitcms/Kiwi/issues/642\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.moderator.username, password=\"admin-password\"\n        )\n        response = self.client.get(\"/admin/auth/user/add/\")\n        self.assertEqual(HTTPStatus.OK, response.status_code)\n\n        # only these fields can be edited\n        self.assertContains(response, \"id_username\")\n        self.assertContains(response, \"id_password1\")\n        self.assertContains(response, \"id_password2\")\n\n        response = self.client.post(\n            \"/admin/auth/user/add/\",\n            {\n                \"username\": \"added-by-moderator\",\n                \"password1\": __FOR_TESTING__,\n                \"password2\": __FOR_TESTING__,\n            },\n            follow=True,\n        )\n        self.assertEqual(HTTPStatus.OK, response.status_code)\n        self.assertTrue(\n            get_user_model().objects.filter(username=\"added-by-moderator\").exists()\n        )\n\n    def test_moderator_can_change_other_users(self):\n        user_should_have_perm(self.moderator, \"auth.view_user\")\n        user_should_have_perm(self.moderator, \"auth.change_user\")\n\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.moderator.username, password=\"admin-password\"\n        )\n\n        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/change/\")\n        response_str = str(response.content, encoding=settings.DEFAULT_CHARSET)\n\n        # 2 readonly fields\n        self.assertEqual(response_str.count(\"grp-readonly\"), 2)\n\n        # these fields can be edited\n        self.assertContains(response, \"id_first_name\")\n        self.assertContains(response, \"id_last_name\")\n        self.assertContains(response, \"id_email\")\n        self.assertContains(response, \"id_is_active\")\n        self.assertContains(response, \"id_is_staff\")\n        self.assertContains(response, \"id_groups\")\n        self.assertContains(response, \"id_user_permissions\")\n\n        response = self.client.post(\n            f\"/admin/auth/user/{self.tester.pk}/change/\",\n            {\n                \"first_name\": \"Changed by moderator\",\n                # required fields below\n                \"username\": self.tester.username,\n                \"email\": self.tester.email,\n                \"date_joined_0\": \"2018-09-03\",\n                \"date_joined_1\": \"13:16:25\",\n            },\n            follow=True,\n        )\n\n        self.assertEqual(HTTPStatus.OK, response.status_code)\n\n        self.tester.refresh_from_db()\n        self.assertEqual(self.tester.first_name, \"Changed by moderator\")\n\n    def test_moderator_can_delete_itself(self):\n        user_should_have_perm(self.moderator, \"auth.delete_user\")\n\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.moderator.username, password=\"admin-password\"\n        )\n        response = self.client.get(\n            reverse(\"admin:auth_user_delete\", args=[self.moderator.pk])\n        )\n        self.assertContains(response, _(\"Yes, I'm sure\"))\n\n        response = self.client.post(\n            reverse(\"admin:auth_user_delete\", args=[self.moderator.pk]),\n            {\"post\": \"yes\"},\n            follow=True,\n        )\n        self.assertRedirects(response, \"/accounts/login/\")\n        self.assertFalse(get_user_model().objects.filter(pk=self.moderator.pk).exists())\n\n    def test_moderator_can_delete_other_user(self):\n        user_should_have_perm(self.moderator, \"auth.view_user\")\n        user_should_have_perm(self.moderator, \"auth.delete_user\")\n\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.moderator.username, password=\"admin-password\"\n        )\n        response = self.client.get(\n            reverse(\"admin:auth_user_delete\", args=[self.tester.pk])\n        )\n        self.assertContains(response, _(\"Yes, I'm sure\"))\n\n        response = self.client.post(\n            reverse(\"admin:auth_user_delete\", args=[self.tester.pk]),\n            {\"post\": \"yes\"},\n            follow=True,\n        )\n        self.assertEqual(HTTPStatus.OK, response.status_code)\n        # b/c our test has only view & delete perms\n        self.assertRedirects(response, \"/admin/\")\n        self.assertFalse(get_user_model().objects.filter(pk=self.tester.pk).exists())\n\n    def test_moderator_can_change_their_password(self):\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.moderator.username, password=\"admin-password\"\n        )\n\n        response = self.client.get(f\"/admin/auth/user/{self.moderator.pk}/password/\")\n        # redirects to change password for themselves\n        self.assertRedirects(response, \"/admin/password_change/\")\n\n    def test_moderator_cant_change_password_for_others(self):\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.moderator.username, password=\"admin-password\"\n        )\n\n        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/password/\")\n        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)\n\n    def test_regular_user_cant_view_list_of_all_users(self):\n        response = self.client.get(\"/admin/auth/user/\")\n        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)\n\n    def test_regular_user_cant_view_single_profile_without_permission(self):\n        response = self.client.get(f\"/admin/auth/user/{self.admin.pk}/change/\")\n        self.assertIsInstance(response, HttpResponseForbidden)\n\n    def test_regular_user_can_view_themselves(self):\n        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/change/\")\n        response_str = str(response.content, encoding=settings.DEFAULT_CHARSET)\n\n        # only 1 hidden field for csrf\n        self.assertContains(response, '<input type=\"hidden\" name=\"csrfmiddlewaretoken\"')\n\n        # 6 readonly fields\n        self.assertEqual(response_str.count(\"grp-readonly\"), 6)\n\n        # only these fields can be edited\n        self.assertContains(response, \"id_first_name\")\n        self.assertContains(response, \"id_last_name\")\n        self.assertContains(response, \"id_email\")\n\n        # Has Delete button\n        self.assertContains(response, f\"/admin/auth/user/{self.tester.pk}/delete/\")\n\n        # Has Save buttons\n        self.assertContains(response, \"_save\")\n        self.assertContains(response, \"_continue\")\n        self.assertNotContains(response, \"_addanother\")\n\n    def test_regular_user_cant_add_users(self):\n        response = self.client.get(\"/admin/auth/user/add/\")\n        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)\n\n        response = self.client.post(\n            \"/admin/auth/user/add/\",\n            {\n                \"username\": \"added-by-regular-user\",\n                \"password1\": __FOR_TESTING__,\n                \"password2\": __FOR_TESTING__,\n            },\n            follow=True,\n        )\n        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)\n        self.assertFalse(\n            get_user_model().objects.filter(username=\"added-by-regular-user\").exists()\n        )\n\n    def test_regular_user_cant_change_other_users(self):\n        response = self.client.get(f\"/admin/auth/user/{self.admin.pk}/change/\")\n        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)\n\n        response = self.client.post(\n            f\"/admin/auth/user/{self.admin.pk}/change/\",\n            {\n                \"first_name\": \"Changed by regular user\",\n                # required fields below\n                \"username\": self.admin.username,\n                \"email\": self.admin.email,\n                \"date_joined_0\": \"2018-09-03\",\n                \"date_joined_1\": \"13:16:25\",\n            },\n            follow=True,\n        )\n        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)\n\n        self.admin.refresh_from_db()\n        self.assertNotEqual(self.admin.first_name, \"Changed by regular user\")\n\n    def test_regular_user_can_change_themselves(self):\n        response = self.client.post(\n            f\"/admin/auth/user/{self.tester.pk}/change/\",\n            {\n                \"first_name\": \"Changed by myself\",\n                # required fields below\n                \"username\": self.tester.username,\n                \"email\": self.tester.email,\n                \"date_joined_0\": \"2018-09-03\",\n                \"date_joined_1\": \"13:16:25\",\n            },\n            follow=True,\n        )\n        self.assertEqual(HTTPStatus.OK, response.status_code)\n\n        self.tester.refresh_from_db()\n        self.assertEqual(self.tester.first_name, \"Changed by myself\")\n\n    def test_regular_user_cant_delete_others(self):\n        response = self.client.get(f\"/admin/auth/user/{self.admin.pk}/delete/\")\n        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)\n\n    def test_regular_user_can_delete_myself(self):\n        response = self.client.get(\n            reverse(\"admin:auth_user_delete\", args=[self.tester.pk])\n        )\n        self.assertContains(response, _(\"Yes, I'm sure\"))\n\n        response = self.client.post(\n            reverse(\"admin:auth_user_delete\", args=[self.tester.pk]),\n            {\"post\": \"yes\"},\n            follow=True,\n        )\n        self.assertRedirects(response, \"/accounts/login/\")\n        self.assertFalse(get_user_model().objects.filter(pk=self.tester.pk).exists())\n\n    def test_regular_user_can_change_their_password(self):\n        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/password/\")\n        # redirects to change password for themselves\n        self.assertRedirects(response, \"/admin/password_change/\")\n\n    def test_regular_user_cant_change_password_for_others(self):\n        response = self.client.get(f\"/admin/auth/user/{self.moderator.pk}/password/\")\n        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)\n\n\nclass TestGroupAdmin(LoggedInTestCase):\n    @classmethod\n    def setUpTestData(cls):\n        super().setUpTestData()\n\n        cls.tester.is_superuser = True\n        cls.tester.save()\n\n        cls.group = GroupFactory(name=\"NewGroupName\")\n        cls.group.save()\n        cls.defaultGroups = Group.objects.filter(name__in=[\"Administrator\", \"Tester\"])\n\n    def test_should_not_be_allowed_to_change_groups_with_default_names(self):\n        for group in self.defaultGroups:\n            response = self.client.get(\n                reverse(\"admin:auth_group_change\", args=[group.id])\n            )\n            self.assertNotContains(\n                response,\n                f'<input type=\"text\" name=\"name\" value=\"{group.name}\" class=\"vTextField\"'\n                ' maxlength=\"150\" required=\"\" id=\"id_name\">',\n            )\n            self.assertContains(\n                response, f'<div class=\"grp-readonly\">{group.name}</div>'\n            )\n\n    def test_should_not_be_allowed_to_delete_default_groups(self):\n        for group in self.defaultGroups:\n            response = self.client.get(\n                reverse(\"admin:auth_group_change\", args=[group.id])\n            )\n            _expected_url = reverse(\"admin:auth_group_delete\", args=[self.group.id])\n            _delete = _(\"Delete\")\n            self.assertNotContains(\n                response,\n                f'<a href=\"{_expected_url}\" class=\"grp-button grp-delete-link\">{_delete}</a>',\n            )\n\n    def test_should_be_allowed_to_create_new_group(self):\n        response = self.client.get(reverse(\"admin:auth_group_add\"))\n        _add_group = _(\"Add %s\") % _(\"group\")\n        self.assertContains(response, f\"<h1>{_add_group}</h1>\")\n        self.assertContains(\n            response,\n            '<input type=\"text\" name=\"name\" class=\"vTextField\" '\n            'maxlength=\"150\" required id=\"id_name\">',\n        )\n\n        # check for the user widget\n        self.assertContains(\n            response,\n            '<select name=\"users\" id=\"id_users\" multiple '\n            'class=\"selectfilter\" data-field-name=\"users\" data-is-stacked=\"0\">',\n        )\n        _label = _(\"Users\")\n        self.assertContains(response, f'<label for=\"id_users\">{_label}')\n\n    def test_should_be_able_to_delete_a_non_default_group(self):\n        response = self.client.get(\n            reverse(\"admin:auth_group_delete\", args=[self.group.id]), follow=True\n        )\n        _are_you_sure = _(\"Are you sure?\")\n        self.assertContains(response, f\"<h1>{_are_you_sure}</h1>\")\n\n    def test_should_be_able_to_edit_a_non_default_group(self):\n        response = self.client.get(\n            reverse(\"admin:auth_group_change\", args=[self.group.id])\n        )\n        self.assertContains(\n            response,\n            f'<input type=\"text\" name=\"name\" value=\"{self.group.name}\" class=\"vTextField\"'\n            ' maxlength=\"150\" required id=\"id_name\">',\n        )\n\n    def test_should_be_allowed_to_create_new_group_with_added_user(self):\n        self.assertFalse(self.tester.groups.filter(name=self.group.name).exists())\n\n        group_name = \"TestGroupName\"\n        response = self.client.post(\n            reverse(\"admin:auth_group_add\"),\n            {\"name\": group_name, \"users\": [self.tester.id]},\n            follow=True,\n        )\n\n        group = self.tester.groups.get(name=group_name)\n\n        self.assertIsNotNone(group)\n        self.assertContains(response, group_name)\n        group_url = reverse(\"admin:auth_group_change\", args=[group.pk])\n        self.assertContains(\n            response,\n            f'<a href=\"{group_url}\">{group_name}</a>',\n        )\n\n    def test_should_be_able_to_add_user_while_editing_a_group(self):\n        self.assertFalse(self.tester.groups.filter(name=self.group.name).exists())\n        response = self.client.post(\n            reverse(\"admin:auth_group_change\", args=[self.group.id]),\n            {\"name\": self.group.name, \"users\": [self.tester.id], \"_continue\": True},\n            follow=True,\n        )\n\n        self.assertContains(\n            response,\n            f'<option value=\"{self.tester.pk}\" selected>{self.tester.username}</option>',\n        )\n        self.assertTrue(self.tester.groups.filter(name=self.group.name).exists())\n", "import importlib\n\nfrom django.test import TestCase, override_settings\nfrom django.utils.translation import gettext_lazy as _\n\nfrom tcms.kiwi_auth import forms\n\nfrom . import __FOR_TESTING__\n\n\nclass TestCaptchaField(TestCase):\n    def setUp(self):\n        self.data = {\n            \"username\": \"test_user\",\n            \"password1\": __FOR_TESTING__,\n            \"password2\": __FOR_TESTING__,\n            \"email\": \"new-tester@example.com\",\n        }\n\n    def test_captcha_required_when_enabled(self):\n        importlib.reload(forms)\n        form = forms.RegistrationForm(data=self.data)\n\n        self.assertFalse(form.is_valid())\n        self.assertIn(\"captcha\", form.errors.keys())\n        self.assertIn(_(\"This field is required.\"), form.errors[\"captcha\"])\n\n    def test_captcha_fails_when_wrong(self):\n        data = self.data.copy()\n        data[\"captcha_0\"] = \"correct\"\n        data[\"captcha_1\"] = \"WRONG\"\n\n        importlib.reload(forms)\n        form = forms.RegistrationForm(data=data)\n\n        self.assertFalse(form.is_valid())\n        self.assertIn(\"captcha\", form.errors.keys())\n        self.assertIn(_(\"Invalid CAPTCHA\"), form.errors[\"captcha\"])\n\n    @override_settings(USE_CAPTCHA=False)\n    def test_captcha_not_required_when_disabled(self):\n        importlib.reload(forms)\n        form = forms.RegistrationForm(data=self.data)\n\n        self.assertTrue(form.is_valid())\n        self.assertNotIn(\"captcha\", form.errors.keys())\n\n\n@override_settings(USE_CAPTCHA=False)\nclass TestRegistrationForm(TestCase):\n    def setUp(self):\n        self.data = {\n            \"username\": \"test_user\",\n            \"password1\": __FOR_TESTING__,\n            \"password2\": __FOR_TESTING__,\n            \"email\": \"new-tester@example.com\",\n        }\n\n    def test_user_not_created_when_commit(self):\n        importlib.reload(forms)\n        form = forms.RegistrationForm(data=self.data)\n\n        user = form.save(commit=False)\n        self.assertIsNone(user.pk)\n\n    def test_user_created_when_commit(self):\n        importlib.reload(forms)\n        form = forms.RegistrationForm(data=self.data)\n\n        user = form.save()\n        self.assertIsNotNone(user.pk)\n", "# -*- coding: utf-8 -*-\n# pylint: disable=invalid-name\n\nimport datetime\n\nfrom django.conf import settings\nfrom django.contrib.auth import get_user_model\nfrom django.contrib.sites.models import Site\nfrom django.test import TestCase, override_settings\nfrom django.urls import reverse\nfrom django.utils import timezone\nfrom django.utils.translation import gettext_lazy as _\nfrom mock import patch\n\nfrom tcms import signals\nfrom tcms.kiwi_auth import forms\nfrom tcms.kiwi_auth.models import UserActivationKey\nfrom tcms.tests.factories import UserFactory\n\nfrom . import __FOR_TESTING__\n\nUser = get_user_model()  # pylint: disable=invalid-name\n\n\nclass TestSetRandomKey(TestCase):\n    \"\"\"Test case for UserActivationKey.set_random_key_for_user\"\"\"\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.new_user = UserFactory()\n\n    @patch(\"tcms.kiwi_auth.models.datetime\")\n    def test_set_random_key(self, mock_datetime):\n        now = timezone.now()\n        in_7_days = datetime.timedelta(7)\n\n        mock_datetime.datetime.today.return_value = now\n        mock_datetime.timedelta.return_value = in_7_days\n\n        activation_key = UserActivationKey.set_random_key_for_user(self.new_user)\n        self.assertEqual(self.new_user, activation_key.user)\n        self.assertNotEqual(\"\", activation_key.activation_key)\n        self.assertEqual(now + in_7_days, activation_key.key_expires)\n\n\nclass TestForceToSetRandomKey(TestCase):\n    \"\"\"Test case for UserActivationKey.set_random_key_for_user forcely\"\"\"\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.new_user = UserFactory()\n        cls.origin_activation_key = UserActivationKey.set_random_key_for_user(\n            cls.new_user\n        )\n\n    def test_set_random_key_forcely(self):\n        new_activation_key = UserActivationKey.set_random_key_for_user(\n            self.new_user, force=True\n        )\n        self.assertEqual(self.origin_activation_key.user, new_activation_key.user)\n        self.assertNotEqual(\n            self.origin_activation_key.activation_key, new_activation_key.activation_key\n        )\n\n\n# ### Test cases for view methods ###\n\n\nclass TestLogout(TestCase):\n    \"\"\"Test for logout view method\"\"\"\n\n    @classmethod\n    def setUpTestData(cls):\n        super(TestLogout, cls).setUpTestData()\n\n        cls.tester = UserFactory()\n        cls.tester.set_password(\"password\")\n        cls.tester.save()\n        cls.logout_url = reverse(\"tcms-logout\")\n\n    def test_logout_redirects_to_login_page(self):\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.tester.username, password=\"password\"\n        )\n        response = self.client.get(self.logout_url, follow=True)\n        self.assertRedirects(response, reverse(\"tcms-login\"))\n\n    def test_logout_then_goto_next(self):\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.tester.username, password=\"password\"\n        )\n        next_url = reverse(\"tcms-login\") + \"?next=\" + reverse(\"plans-search\")\n        response = self.client.get(self.logout_url, {\"next\": next_url}, follow=True)\n        self.assertRedirects(response, next_url)\n\n\nclass TestRegistration(TestCase):\n    def setUp(self):\n        self.register_url = reverse(\"tcms-register\")\n        self.fake_activate_key = \"secret-activate-key\"\n\n    def test_open_registration_page(self):\n        response = self.client.get(self.register_url)\n        _register = _(\"Register\")\n        self.assertContains(response, f\">{_register}</button>\")\n\n    def assert_user_registration(self, username, follow=False):\n        with patch(\"tcms.kiwi_auth.models.secrets\") as _secrets:\n            _secrets.token_hex.return_value = self.fake_activate_key\n\n            try:\n                # https://github.com/mbi/django-simple-captcha/issues/84\n                # pylint: disable=import-outside-toplevel\n                from captcha.conf import settings as captcha_settings\n\n                captcha_settings.CAPTCHA_TEST_MODE = True\n\n                response = self.client.post(\n                    self.register_url,\n                    {\n                        \"username\": username,\n                        \"password1\": __FOR_TESTING__,\n                        \"password2\": __FOR_TESTING__,\n                        \"email\": \"new-tester@example.com\",\n                        \"captcha_0\": \"PASSED\",\n                        \"captcha_1\": \"PASSED\",\n                    },\n                    follow=follow,\n                )\n            finally:\n                captcha_settings.CAPTCHA_TEST_MODE = False\n\n        user = User.objects.get(username=username)\n        self.assertEqual(\"new-tester@example.com\", user.email)\n        if User.objects.filter(is_superuser=True).count() == 1 and user.is_superuser:\n            self.assertTrue(user.is_active)\n        else:\n            self.assertFalse(user.is_active)\n\n        key = UserActivationKey.objects.get(user=user)\n        self.assertEqual(self.fake_activate_key, key.activation_key)\n\n        return response, user\n\n    @patch(\"tcms.signals.USER_REGISTERED_SIGNAL.send\")\n    def test_register_user_sends_signal(self, signal_mock):\n        self.assert_user_registration(\"new-signal-tester\")\n        self.assertTrue(signal_mock.called)\n        self.assertEqual(1, signal_mock.call_count)\n\n    @override_settings(ADMINS=[(\"Test Admin\", \"admin@kiwitcms.org\")])\n    @patch(\"tcms.core.utils.mailto.send_mail\")\n    def test_signal_handler_notifies_admins(self, send_mail):\n        # connect the handler b/c it is not connected by default\n        signals.USER_REGISTERED_SIGNAL.connect(signals.notify_admins)\n\n        try:\n            response, user = self.assert_user_registration(\"signal-handler\")\n            self.assertRedirects(\n                response, reverse(\"core-views-index\"), target_status_code=302\n            )\n\n            # 1 - verification mail, 2 - email to admin\n            self.assertTrue(send_mail.called)\n            self.assertEqual(2, send_mail.call_count)\n\n            # verify we've actually sent the admin email\n            self.assertIn(\n                str(_(\"New user awaiting approval\")), send_mail.call_args_list[0][0][0]\n            )\n            values = {\n                \"username\": \"signal-handler\",\n                \"user_url\": f\"http://testserver/admin/auth/user/{user.pk}/change/\",\n            }\n            expected = (\n                _(\n                    \"\"\"Dear Administrator,\nsomebody just registered an account with username %(username)s at your\nKiwi TCMS instance and is awaiting your approval!\n\nGo to %(user_url)s to activate the account!\"\"\"\n                )\n                % values\n            )\n            self.assertEqual(\n                expected.strip(), send_mail.call_args_list[0][0][1].strip()\n            )\n            self.assertIn(\"admin@kiwitcms.org\", send_mail.call_args_list[0][0][-1])\n        finally:\n            signals.USER_REGISTERED_SIGNAL.disconnect(signals.notify_admins)\n\n    @patch(\"tcms.core.utils.mailto.send_mail\")\n    def test_register_user_by_email_confirmation(self, send_mail):\n        response, user = self.assert_user_registration(\"new-tester\", follow=True)\n        self.assertContains(\n            response,\n            _(\n                \"Your account has been created, please check your mailbox for confirmation\"\n            ),\n        )\n\n        site = Site.objects.get(pk=settings.SITE_ID)\n        _confirm_url = reverse(\"tcms-confirm\", args=[self.fake_activate_key])\n        confirm_url = f\"http://{site.domain}{_confirm_url}\"\n\n        # Verify notification mail\n        values = {\n            \"user\": user.username,\n            \"site_domain\": site.domain,\n            \"confirm_url\": confirm_url,\n        }\n        expected_subject = (\n            settings.EMAIL_SUBJECT_PREFIX\n            + _(\"Your new %s account confirmation\") % site.domain\n        )\n        expected_body = (\n            _(\n                \"\"\"Welcome %(user)s,\nthank you for signing up for an %(site_domain)s account!\n\nTo activate your account, click this link:\n%(confirm_url)s\"\"\"\n            )\n            % values\n            + \"\\n\"\n        )\n        send_mail.assert_called_once_with(\n            expected_subject,\n            expected_body,\n            settings.DEFAULT_FROM_EMAIL,\n            [\"new-tester@example.com\"],\n            fail_silently=False,\n        )\n\n    @override_settings(\n        AUTO_APPROVE_NEW_USERS=False,\n        ADMINS=[(\"admin1\", \"admin1@example.com\"), (\"admin2\", \"admin2@example.com\")],\n    )\n    def test_register_user_and_activate_by_admin(self):\n        response, _user = self.assert_user_registration(\"plan-tester\", follow=True)\n\n        self.assertContains(\n            response,\n            _(\n                \"Your account has been created, but you need an administrator to activate it\"\n            ),\n        )\n\n        for (name, email) in settings.ADMINS:\n            self.assertContains(\n                response, f'<a href=\"mailto:{email}\">{name}</a>', html=True\n            )\n\n    def test_invalid_form(self):\n        response = self.client.post(\n            self.register_url,\n            {\n                \"username\": \"kiwi-tester\",\n                \"password1\": __FOR_TESTING__,\n                \"password2\": f\"000-{__FOR_TESTING__}\",\n                \"email\": \"new-tester@example.com\",\n            },\n            follow=False,\n        )\n\n        self.assertContains(response, _(\"The two password fields didn\u2019t match.\"))\n        self.assertEqual(response.status_code, 200)\n        self.assertTemplateUsed(response, \"registration/registration_form.html\")\n\n    def test_register_user_already_registered(self):\n        User.objects.create_user(\"kiwi-tester\", \"new-tester@example.com\", \"password\")\n\n        response = self.client.post(\n            self.register_url,\n            {\n                \"username\": \"test_user\",\n                \"password1\": __FOR_TESTING__,\n                \"password2\": __FOR_TESTING__,\n                \"email\": \"new-tester@example.com\",\n            },\n            follow=False,\n        )\n        self.assertContains(response, _(\"A user with that email already exists.\"))\n\n        user = User.objects.filter(username=\"test_user\")\n        self.assertEqual(user.count(), 0)\n\n    def test_first_user_is_superuser(self):\n        _response, user = self.assert_user_registration(\"tester_1\")\n\n        self.assertTrue(user.is_superuser)\n        self.assertTrue(user.is_active)\n\n    def test_only_one_superuser(self):\n        user1 = User.objects.create_user(\n            \"kiwi-tester\", \"tester@example.com\", \"password\"\n        )\n        user1.is_superuser = True\n        user1.save()\n\n        self.assertTrue(user1.is_superuser)\n\n        _response, user2 = self.assert_user_registration(\"plan-tester\")\n        self.assertFalse(user2.is_superuser)\n\n\nclass TestConfirm(TestCase):\n    \"\"\"Test for activation key confirmation\"\"\"\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.new_user = UserFactory()\n\n    def setUp(self):\n        self.new_user.is_active = False\n        self.new_user.save()\n\n    def test_fail_if_activation_key_does_not_exist(self):\n        confirm_url = reverse(\"tcms-confirm\", args=[\"nonexisting-activation-key\"])\n        response = self.client.get(confirm_url, follow=True)\n\n        self.assertContains(\n            response, _(\"This activation key no longer exists in the database\")\n        )\n\n        # user account not activated\n        user = User.objects.get(username=self.new_user.username)\n        self.assertFalse(user.is_active)\n\n    def test_fail_if_activation_key_expired(self):\n        fake_activation_key = \"secret-activation-key\"\n\n        with patch(\"tcms.kiwi_auth.models.secrets\") as _secrets:\n            _secrets.token_hex.return_value = fake_activation_key\n            key = UserActivationKey.set_random_key_for_user(self.new_user)\n            key.key_expires = timezone.now() - datetime.timedelta(days=10)\n            key.save()\n\n        confirm_url = reverse(\"tcms-confirm\", args=[fake_activation_key])\n        response = self.client.get(confirm_url, follow=True)\n\n        self.assertContains(response, _(\"This activation key has expired\"))\n\n        # user account not activated\n        user = User.objects.get(username=self.new_user.username)\n        self.assertFalse(user.is_active)\n\n    def test_confirm(self):\n        fake_activate_key = \"secret-activate-key\"\n\n        with patch(\"tcms.kiwi_auth.models.secrets\") as _secrets:\n            _secrets.token_hex.return_value = fake_activate_key\n            UserActivationKey.set_random_key_for_user(self.new_user)\n\n        confirm_url = reverse(\"tcms-confirm\", args=[fake_activate_key])\n        response = self.client.get(confirm_url, follow=True)\n\n        self.assertContains(response, _(\"Your account has been activated successfully\"))\n\n        # user account activated\n        user = User.objects.get(username=self.new_user.username)\n        self.assertTrue(user.is_active)\n        activate_key_deleted = not UserActivationKey.objects.filter(user=user).exists()\n        self.assertTrue(activate_key_deleted)\n\n\nclass TestLoginViewWithCustomTemplate(TestCase):\n    \"\"\"Test for login view with custom template\"\"\"\n\n    def test_get_template_names(self):\n        response = self.client.get(reverse(\"tcms-login\"))\n        self.assertIsNotNone(response.template_name)\n        self.assertEqual(\n            response.template_name,\n            [\"registration/custom_login.html\", \"registration/login.html\"],\n        )\n\n\nclass TestPasswordResetView(TestCase):\n    \"\"\"Test for password reset view\"\"\"\n\n    def setUp(self):\n        self.password_reset_url = reverse(\"tcms-password_reset\")\n\n    def test_form_class(self):\n        response = self.client.get(self.password_reset_url)\n        self.assertEqual(\n            str(type(response.context[\"form\"])),\n            str(forms.PasswordResetForm),\n        )\n\n    def test_open_password_reset_page(self):\n        response = self.client.get(self.password_reset_url)\n\n        _password_reset = _(\"Password reset\")\n        self.assertContains(response, f\">{_password_reset}</button>\")\n\n    @patch(\"tcms.kiwi_auth.forms.DjangoPasswordResetForm.send_mail\")\n    def test_send_mail_for_password_reset(self, mail_sent):\n        user = User.objects.create_user(\"kiwi-tester\", \"tester@example.com\", \"password\")\n        user.is_active = True\n        user.save()\n        data = {\"email\": \"tester@example.com\"}\n        response = self.client.post(self.password_reset_url, data, follow=True)\n\n        self.assertContains(response, _(\"Password reset email was sent\"))\n\n        # Verify mail is sent\n        mail_sent.assert_called_once()\n"], "filenames": ["tcms/kiwi_auth/tests/__init__.py", "tcms/kiwi_auth/tests/test_admin.py", "tcms/kiwi_auth/tests/test_forms.py", "tcms/kiwi_auth/tests/test_views.py"], "buggy_code_start_loc": [0, 12, 7, 19], "buggy_code_end_loc": [0, 378, 54, 277], "fixing_code_start_loc": [1, 13, 8, 20], "fixing_code_end_loc": [2, 380, 56, 279], "type": "CWE-521", "message": "Kiwi TCMS is an open source test management system. In version 11.6 and prior, when users register new accounts and/or change passwords, there is no validation in place which would prevent them from picking an easy to guess password. This issue is resolved by providing defaults for the `AUTH_PASSWORD_VALIDATORS` configuration setting. As of version 11.7, the password can\u2019t be too similar to other personal information, must contain at least 10 characters, can\u2019t be a commonly used password, and can\u2019t be entirely numeric. As a workaround, an administrator may reset all passwords in Kiwi TCMS if they think a weak password may have been chosen.", "other": {"cve": {"id": "CVE-2023-22451", "sourceIdentifier": "security-advisories@github.com", "published": "2023-01-02T16:15:11.063", "lastModified": "2023-01-09T18:56:41.887", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Kiwi TCMS is an open source test management system. In version 11.6 and prior, when users register new accounts and/or change passwords, there is no validation in place which would prevent them from picking an easy to guess password. This issue is resolved by providing defaults for the `AUTH_PASSWORD_VALIDATORS` configuration setting. As of version 11.7, the password can\u2019t be too similar to other personal information, must contain at least 10 characters, can\u2019t be a commonly used password, and can\u2019t be entirely numeric. As a workaround, an administrator may reset all passwords in Kiwi TCMS if they think a weak password may have been chosen."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-521"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-521"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:kiwitcms:kiwi_tcms:*:*:*:*:*:*:*:*", "versionEndExcluding": "11.7", "matchCriteriaId": "9D4D9099-B528-4D0B-81ED-F66A74604B2F"}]}]}], "references": [{"url": "https://github.com/kiwitcms/Kiwi/commit/3759fb68aed36315cdde9fc573b2fe7c11544985", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/kiwitcms/Kiwi/security/advisories/GHSA-496x-2jqf-hp7g", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/32a873c8-f605-4aae-9272-d80985ef2b73", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/kiwitcms/Kiwi/commit/3759fb68aed36315cdde9fc573b2fe7c11544985"}}