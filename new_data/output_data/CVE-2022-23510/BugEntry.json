{"buggy_code": ["/* eslint-disable no-restricted-syntax */\nimport jwt, { Algorithm as JWTAlgorithm } from 'jsonwebtoken';\nimport R from 'ramda';\nimport bodyParser from 'body-parser';\nimport { graphqlHTTP } from 'express-graphql';\nimport structuredClone from '@ungap/structured-clone';\nimport {\n  getEnv,\n  getRealType,\n  QueryAlias,\n} from '@cubejs-backend/shared';\nimport type {\n  Application as ExpressApplication,\n  ErrorRequestHandler,\n  NextFunction,\n  RequestHandler,\n  Response,\n} from 'express';\nimport {\n  QueryType\n} from './types/strings';\nimport {\n  QueryType as QueryTypeEnum, ResultType\n} from './types/enums';\nimport {\n  RequestContext,\n  ExtendedRequestContext,\n  Request,\n  QueryRewriteFn,\n  SecurityContextExtractorFn,\n  ExtendContextFn,\n  ResponseResultFn,\n  QueryRequest,\n  PreAggsJobsRequest,\n  PreAggsSelector,\n  PreAggJob,\n  PreAggJobStatusItem,\n  PreAggJobStatusObject,\n  PreAggJobStatusResponse,\n} from './types/request';\nimport {\n  CheckAuthInternalOptions,\n  JWTOptions,\n  CheckAuthFn,\n} from './types/auth';\nimport {\n  Query,\n  NormalizedQuery,\n} from './types/query';\nimport {\n  UserBackgroundContext,\n  ApiGatewayOptions,\n} from './types/gateway';\nimport {\n  CheckAuthMiddlewareFn,\n  RequestLoggerMiddlewareFn,\n} from './interfaces';\nimport { getRequestIdFromRequest, requestParser } from './requestParser';\nimport { UserError } from './UserError';\nimport { CubejsHandlerError } from './CubejsHandlerError';\nimport { SubscriptionServer, WebSocketSendMessageFn } from './SubscriptionServer';\nimport { LocalSubscriptionStore } from './LocalSubscriptionStore';\nimport {\n  getPivotQuery,\n  getQueryGranularity,\n  normalizeQuery,\n  normalizeQueryCancelPreAggregations,\n  normalizeQueryPreAggregationPreview,\n  normalizeQueryPreAggregations,\n  validatePostRewrite,\n} from './query';\nimport { cachedHandler } from './cached-handler';\nimport { createJWKsFetcher } from './jwk';\nimport { SQLServer } from './sql-server';\nimport { makeSchema } from './graphql';\nimport { ConfigItem, prepareAnnotation } from './helpers/prepareAnnotation';\nimport transformData from './helpers/transformData';\nimport {\n  transformCube,\n  transformMeasure,\n  transformDimension,\n  transformSegment,\n  transformJoins,\n  transformPreAggregations,\n} from './helpers/transformMetaExtended';\n\n// const timeoutPromise = (timeout) => (\n//   new Promise((resolve) => (\n//     setTimeout(\n//       () => resolve(null),\n//       timeout,\n//     )\n//   ))\n// );\n\n/**\n * API gateway server class.\n */\nclass ApiGateway {\n  protected readonly refreshScheduler: any;\n\n  protected readonly scheduledRefreshContexts: ApiGatewayOptions['scheduledRefreshContexts'];\n\n  protected readonly scheduledRefreshTimeZones: ApiGatewayOptions['scheduledRefreshTimeZones'];\n\n  protected readonly basePath: string;\n\n  protected readonly queryRewrite: QueryRewriteFn;\n\n  protected readonly subscriptionStore: any;\n\n  protected readonly enforceSecurityChecks: boolean;\n\n  protected readonly standalone: boolean;\n\n  protected readonly extendContext?: ExtendContextFn;\n\n  protected readonly dataSourceStorage: any;\n\n  public readonly checkAuthFn: CheckAuthFn;\n\n  public readonly checkAuthSystemFn: CheckAuthFn;\n\n  protected readonly checkAuthMiddleware: CheckAuthMiddlewareFn;\n\n  protected readonly requestLoggerMiddleware: RequestLoggerMiddlewareFn;\n\n  protected readonly securityContextExtractor: SecurityContextExtractorFn;\n\n  protected readonly releaseListeners: (() => any)[] = [];\n\n  protected readonly playgroundAuthSecret?: string;\n\n  public constructor(\n    protected readonly apiSecret: string,\n    protected readonly compilerApi: any,\n    protected readonly adapterApi: any,\n    protected readonly logger: any,\n    protected readonly options: ApiGatewayOptions,\n  ) {\n    this.dataSourceStorage = options.dataSourceStorage;\n    this.refreshScheduler = options.refreshScheduler;\n    this.scheduledRefreshContexts = options.scheduledRefreshContexts;\n    this.scheduledRefreshTimeZones = options.scheduledRefreshTimeZones;\n    this.standalone = options.standalone;\n    this.basePath = options.basePath;\n    this.playgroundAuthSecret = options.playgroundAuthSecret;\n\n    this.queryRewrite = options.queryRewrite || (async (query) => query);\n    this.subscriptionStore = options.subscriptionStore || new LocalSubscriptionStore();\n    this.enforceSecurityChecks = options.enforceSecurityChecks || (process.env.NODE_ENV === 'production');\n    this.extendContext = options.extendContext;\n\n    this.checkAuthFn = this.createCheckAuthFn(options);\n    this.checkAuthSystemFn = this.createCheckAuthSystemFn();\n    this.checkAuthMiddleware = options.checkAuthMiddleware\n      ? this.wrapCheckAuthMiddleware(options.checkAuthMiddleware)\n      : this.checkAuth;\n    this.securityContextExtractor = this.createSecurityContextExtractor(options.jwt);\n    this.requestLoggerMiddleware = options.requestLoggerMiddleware || this.requestLogger;\n  }\n\n  public initApp(app: ExpressApplication) {\n    const userMiddlewares: RequestHandler[] = [\n      this.checkAuthMiddleware,\n      this.requestContextMiddleware,\n      this.logNetworkUsage,\n      this.requestLoggerMiddleware\n    ];\n\n    // @todo Should we pass requestLoggerMiddleware?\n    const guestMiddlewares = [];\n\n    app.use(`${this.basePath}/graphql`, userMiddlewares, async (req, res) => {\n      const compilerApi = this.getCompilerApi(req.context);\n      let schema = compilerApi.getGraphQLSchema();\n      if (!schema) {\n        let metaConfig = await compilerApi.metaConfig({\n          requestId: req.context.requestId,\n        });\n        metaConfig = this.filterVisibleItemsInMeta(req.context, metaConfig);\n        schema = makeSchema(metaConfig);\n        compilerApi.setGraphQLSchema(schema);\n      }\n\n      return graphqlHTTP({\n        schema,\n        context: {\n          req,\n          apiGateway: this\n        },\n        graphiql: getEnv('nodeEnv') !== 'production' ? { headerEditorEnabled: true } : false,\n      })(req, res);\n    });\n\n    app.get(`${this.basePath}/v1/load`, userMiddlewares, (async (req, res) => {\n      await this.load({\n        query: req.query.query,\n        context: req.context,\n        res: this.resToResultFn(res),\n        queryType: req.query.queryType,\n      });\n    }));\n\n    const jsonParser = bodyParser.json({ limit: '1mb' });\n    app.post(`${this.basePath}/v1/load`, jsonParser, userMiddlewares, (async (req, res) => {\n      await this.load({\n        query: req.body.query,\n        context: req.context,\n        res: this.resToResultFn(res),\n        queryType: req.body.queryType\n      });\n    }));\n\n    app.get(`${this.basePath}/v1/subscribe`, userMiddlewares, (async (req, res) => {\n      await this.load({\n        query: req.query.query,\n        context: req.context,\n        res: this.resToResultFn(res),\n        queryType: req.query.queryType\n      });\n    }));\n\n    app.get(`${this.basePath}/v1/sql`, userMiddlewares, (async (req, res) => {\n      await this.sql({\n        query: req.query.query,\n        context: req.context,\n        res: this.resToResultFn(res)\n      });\n    }));\n\n    app.post(`${this.basePath}/v1/sql`, userMiddlewares, (async (req, res) => {\n      await this.sql({\n        query: req.body.query,\n        context: req.context,\n        res: this.resToResultFn(res)\n      });\n    }));\n\n    app.get(`${this.basePath}/v1/meta`, userMiddlewares, (async (req, res) => {\n      if (req.query.hasOwnProperty('extended')) {\n        await this.metaExtended({\n          context: req.context,\n          res: this.resToResultFn(res),\n        });\n      } else {\n        await this.meta({\n          context: req.context,\n          res: this.resToResultFn(res),\n        });\n      }\n    }));\n\n    app.get(`${this.basePath}/v1/run-scheduled-refresh`, userMiddlewares, (async (req, res) => {\n      await this.runScheduledRefresh({\n        queryingOptions: req.query.queryingOptions,\n        context: req.context,\n        res: this.resToResultFn(res)\n      });\n    }));\n\n    app.get(`${this.basePath}/v1/dry-run`, userMiddlewares, (async (req, res) => {\n      await this.dryRun({\n        query: req.query.query,\n        context: req.context,\n        res: this.resToResultFn(res)\n      });\n    }));\n\n    app.post(`${this.basePath}/v1/dry-run`, jsonParser, userMiddlewares, (async (req, res) => {\n      await this.dryRun({\n        query: req.body.query,\n        context: req.context,\n        res: this.resToResultFn(res)\n      });\n    }));\n\n    if (this.playgroundAuthSecret) {\n      const systemMiddlewares: RequestHandler[] = [\n        this.checkAuthSystemMiddleware,\n        this.requestContextMiddleware,\n        this.requestLoggerMiddleware\n      ];\n\n      app.get('/cubejs-system/v1/context', systemMiddlewares, this.createSystemContextHandler(this.basePath));\n\n      app.get('/cubejs-system/v1/pre-aggregations', systemMiddlewares, (async (req, res) => {\n        await this.getPreAggregations({\n          cacheOnly: req.query.cacheOnly,\n          context: req.context,\n          res: this.resToResultFn(res)\n        });\n      }));\n\n      app.get('/cubejs-system/v1/pre-aggregations/security-contexts', systemMiddlewares, (async (req, res) => {\n        const contexts = this.scheduledRefreshContexts ? await this.scheduledRefreshContexts() : [];\n        this.resToResultFn(res)({\n          securityContexts: contexts\n            .map(ctx => ctx && (ctx.securityContext || ctx.authInfo))\n            .filter(ctx => ctx)\n        });\n      }));\n\n      app.get('/cubejs-system/v1/pre-aggregations/timezones', systemMiddlewares, (async (req, res) => {\n        this.resToResultFn(res)({\n          timezones: this.scheduledRefreshTimeZones || []\n        });\n      }));\n\n      app.post('/cubejs-system/v1/pre-aggregations/partitions', jsonParser, systemMiddlewares, (async (req, res) => {\n        await this.getPreAggregationPartitions({\n          query: req.body.query,\n          context: req.context,\n          res: this.resToResultFn(res)\n        });\n      }));\n\n      app.post('/cubejs-system/v1/pre-aggregations/preview', jsonParser, systemMiddlewares, (async (req, res) => {\n        await this.getPreAggregationPreview({\n          query: req.body.query,\n          context: req.context,\n          res: this.resToResultFn(res)\n        });\n      }));\n\n      app.post('/cubejs-system/v1/pre-aggregations/build', jsonParser, systemMiddlewares, (async (req, res) => {\n        await this.buildPreAggregations({\n          query: req.body.query,\n          context: req.context,\n          res: this.resToResultFn(res)\n        });\n      }));\n\n      app.post('/cubejs-system/v1/pre-aggregations/queue', jsonParser, systemMiddlewares, (async (req, res) => {\n        await this.getPreAggregationsInQueue({\n          context: req.context,\n          res: this.resToResultFn(res)\n        });\n      }));\n\n      app.post('/cubejs-system/v1/pre-aggregations/cancel', jsonParser, systemMiddlewares, (async (req, res) => {\n        await this.cancelPreAggregationsFromQueue({\n          query: req.body.query,\n          context: req.context,\n          res: this.resToResultFn(res)\n        });\n      }));\n\n      app.post(\n        '/cubejs-system/v1/pre-aggregations/jobs',\n        userMiddlewares,\n        this.preAggregationsJobs.bind(this),\n      );\n    }\n\n    app.get('/readyz', guestMiddlewares, cachedHandler(this.readiness));\n    app.get('/livez', guestMiddlewares, cachedHandler(this.liveness));\n\n    app.post(`${this.basePath}/v1/pre-aggregations/can-use`, userMiddlewares, (req: Request, res: Response) => {\n      const { transformedQuery, references } = req.body;\n\n      const canUsePreAggregationForTransformedQuery = this.compilerApi(req.context)\n        .canUsePreAggregationForTransformedQuery(transformedQuery, references);\n\n      res.json({ canUsePreAggregationForTransformedQuery });\n    });\n\n    app.use(this.handleErrorMiddleware);\n  }\n\n  public initSQLServer() {\n    return new SQLServer(this);\n  }\n\n  public initSubscriptionServer(sendMessage: WebSocketSendMessageFn) {\n    return new SubscriptionServer(this, sendMessage, this.subscriptionStore);\n  }\n\n  protected duration(requestStarted) {\n    return requestStarted && (new Date().getTime() - requestStarted.getTime());\n  }\n\n  public async runScheduledRefresh({ context, res, queryingOptions }: {\n    context: RequestContext,\n    res: ResponseResultFn,\n    queryingOptions: any\n  }) {\n    const requestStarted = new Date();\n    try {\n      const refreshScheduler = this.refreshScheduler();\n      res(await refreshScheduler.runScheduledRefresh(context, {\n        ...this.parseQueryParam(queryingOptions || {}),\n        throwErrors: true\n      }));\n    } catch (e) {\n      this.handleError({\n        e, context, res, requestStarted\n      });\n    }\n  }\n\n  private filterVisibleItemsInMeta(_context: RequestContext, metaConfig: any) {\n    function visibilityFilter(item) {\n      // Hidden items shouldn't be accessible through API everywhere for consistency.\n      return item.isVisible;\n    }\n\n    return metaConfig\n      .map((cube) => ({\n        config: {\n          ...cube.config,\n          measures: cube.config.measures?.filter(visibilityFilter),\n          dimensions: cube.config.dimensions?.filter(visibilityFilter),\n          segments: cube.config.segments?.filter(visibilityFilter),\n        },\n      })).filter(cube => cube.config.measures?.length || cube.config.dimensions?.length || cube.config.segments?.length);\n  }\n\n  public async meta({ context, res }: { context: RequestContext, res: ResponseResultFn }) {\n    const requestStarted = new Date();\n\n    try {\n      const metaConfig = await this.getCompilerApi(context).metaConfig({\n        requestId: context.requestId,\n      });\n      const cubes = this.filterVisibleItemsInMeta(context, metaConfig).map(cube => cube.config);\n      res({ cubes });\n    } catch (e) {\n      this.handleError({\n        e,\n        context,\n        res,\n        requestStarted,\n      });\n    }\n  }\n\n  public async metaExtended({ context, res }: { context: RequestContext, res: ResponseResultFn }) {\n    const requestStarted = new Date();\n\n    // TODO: test and remove this function.\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    function visibilityFilter(item) {\n      return getEnv('devMode') || context.signedWithPlaygroundAuthSecret || item.isVisible;\n    }\n\n    try {\n      const metaConfigExtended = await this.getCompilerApi(context).metaConfigExtended({\n        requestId: context.requestId,\n      });\n      const { metaConfig, cubeDefinitions, dataSources } = metaConfigExtended;\n\n      const cubes = this.filterVisibleItemsInMeta(context, metaConfig)\n        .map((meta) => meta.config)\n        .map((cube) => ({\n          ...transformCube(cube, cubeDefinitions),\n          measures: cube.measures?.map((measure) => ({\n            ...transformMeasure(measure, cubeDefinitions),\n          })),\n          dimensions: cube.dimensions?.map((dimension) => ({\n            ...transformDimension(dimension, cubeDefinitions),\n          })),\n          segments: cube.segments?.map((segment) => ({\n            ...transformSegment(segment, cubeDefinitions),\n          })),\n          joins: transformJoins(cubeDefinitions[cube.name]?.joins),\n          preAggregations: transformPreAggregations(cubeDefinitions[cube.name]?.preAggregations),\n        }));\n      res({ cubes, dataSources });\n    } catch (e) {\n      this.handleError({\n        e,\n        context,\n        res,\n        requestStarted,\n      });\n    }\n  }\n\n  public async getPreAggregations({ cacheOnly, context, res }: { cacheOnly?: boolean, context: RequestContext, res: ResponseResultFn }) {\n    const requestStarted = new Date();\n    try {\n      const compilerApi = this.getCompilerApi(context);\n      const preAggregations = await compilerApi.preAggregations();\n\n      const preAggregationPartitions = await this.refreshScheduler()\n        .preAggregationPartitions(\n          context,\n          normalizeQueryPreAggregations(\n            {\n              timezones: this.scheduledRefreshTimeZones,\n              preAggregations: preAggregations.map(p => ({\n                id: p.id,\n                cacheOnly,\n              }))\n            },\n          )\n        );\n\n      res({ preAggregations: preAggregationPartitions.map(({ preAggregation }) => preAggregation) });\n    } catch (e) {\n      this.handleError({\n        e, context, res, requestStarted\n      });\n    }\n  }\n\n  public async getPreAggregationPartitions(\n    { query, context, res }: { query: any, context: RequestContext, res: ResponseResultFn }\n  ) {\n    const requestStarted = new Date();\n    try {\n      query = normalizeQueryPreAggregations(\n        this.parseQueryParam(query),\n        { timezones: this.scheduledRefreshTimeZones }\n      );\n      const orchestratorApi = this.getAdapterApi(context);\n      const compilerApi = this.getCompilerApi(context);\n\n      const preAggregationPartitions = await this.refreshScheduler()\n        .preAggregationPartitions(\n          context,\n          query\n        );\n\n      const preAggregationPartitionsWithoutError = preAggregationPartitions.filter(p => !p?.errors?.length);\n\n      const versionEntriesResult = preAggregationPartitions &&\n        await orchestratorApi.getPreAggregationVersionEntries(\n          context,\n          preAggregationPartitionsWithoutError,\n          compilerApi.preAggregationsSchema\n        );\n\n      const mergePartitionsAndVersionEntries = () => ({ preAggregation, partitions, ...props }) => ({\n        ...props,\n        preAggregation,\n        partitions: partitions.map(partition => {\n          partition.versionEntries = versionEntriesResult?.versionEntriesByTableName[partition?.tableName] || [];\n          partition.structureVersion = versionEntriesResult?.structureVersionsByTableName[partition?.tableName];\n          return partition;\n        }),\n      });\n\n      res({\n        preAggregationPartitions: preAggregationPartitions.map(mergePartitionsAndVersionEntries())\n      });\n    } catch (e) {\n      this.handleError({\n        e, context, res, requestStarted\n      });\n    }\n  }\n\n  public async getPreAggregationPreview(\n    { query, context, res }: { query: any, context: RequestContext, res: ResponseResultFn }\n  ) {\n    const requestStarted = new Date();\n    try {\n      query = normalizeQueryPreAggregationPreview(this.parseQueryParam(query));\n      const { preAggregationId, versionEntry, timezone } = query;\n\n      const orchestratorApi = this.getAdapterApi(context);\n\n      const preAggregationPartitions = await this.refreshScheduler()\n        .preAggregationPartitions(\n          context,\n          {\n            timezones: [timezone],\n            preAggregations: [{ id: preAggregationId }]\n          }\n        );\n      const { partitions } = (preAggregationPartitions && preAggregationPartitions[0] || {});\n      const preAggregationPartition = partitions && partitions.find(p => p?.tableName === versionEntry.table_name);\n\n      res({\n        preview: preAggregationPartition && await orchestratorApi.getPreAggregationPreview(\n          context,\n          preAggregationPartition\n        )\n      });\n    } catch (e) {\n      this.handleError({\n        e, context, res, requestStarted\n      });\n    }\n  }\n\n  public async buildPreAggregations(\n    { query, context, res }: { query: any, context: RequestContext, res: ResponseResultFn }\n  ) {\n    const requestStarted = new Date();\n    try {\n      query = normalizeQueryPreAggregations(this.parseQueryParam(query));\n      const result = await this.refreshScheduler()\n        .buildPreAggregations(\n          context,\n          query\n        );\n\n      res({ result });\n    } catch (e) {\n      this.handleError({\n        e, context, res, requestStarted\n      });\n    }\n  }\n\n  /**\n   * Entry point for the `/cubejs-system/v1/pre-aggregations/jobs` endpoint.\n   * Post object example:\n   * ```\n   * {\n   *   \"action\": \"post\",\n   *   \"selector\": {\n   *     \"contexts\": [\n   *       {\"securityContext\": {\"tenant\": \"t1\"}},\n   *       {\"securityContext\": {\"tenant\": \"t2\"}}\n   *     ],\n   *     \"timezones\": [\"UTC\"],\n   *     \"dataSources\": [\"default\"],\n   *     \"cubes\": [\"Events\"],\n   *     \"preAggregations\": [\"Events.TemporaryData\"]\n   *   }\n   * }\n   * // or\n   * {\n   *   \"action\": \"get\",\n   *   \"tokens\": [\n   *     \"ec1232ea3356f04f8be313fecf3deb4d\",\n   *     \"48b75d5c466fa579c936dc451f498f69\",\n   *     \"76509837091396dc204abb1016c48e75\",\n   *     \"52264769f81f6ff62062a93d6f6fbdb2\"\n   *   ]\n   * }\n   * // or\n   * {\n   *   \"action\": \"get\",\n   *   \"resType\": \"object\",\n   *   \"tokens\": [\n   *     \"ec1232ea3356f04f8be313fecf3deb4d\",\n   *     \"48b75d5c466fa579c936dc451f498f69\",\n   *     \"76509837091396dc204abb1016c48e75\",\n   *     \"52264769f81f6ff62062a93d6f6fbdb2\"\n   *   ]\n   * }\n   * ```\n   * TODO (buntarb): selector object validator.\n   */\n  private async preAggregationsJobs(req: Request, res: Response) {\n    const response = this.resToResultFn(res);\n    const started = new Date();\n    const context = <RequestContext>req.context;\n    const query = <PreAggsJobsRequest>req.body;\n    try {\n      let result;\n      switch (query.action) {\n        case 'post':\n          if (\n            !(<PreAggsSelector>query.selector).timezones ||\n            (<PreAggsSelector>query.selector).timezones.length === 0\n          ) {\n            throw new UserError(\n              'A user\\'s selector must contain at least one time zone.'\n            );\n          }\n          if (\n            !(<PreAggsSelector>query.selector).contexts ||\n            (\n              <{securityContext: any}[]>(\n                <PreAggsSelector>query.selector\n              ).contexts\n            ).length === 0\n          ) {\n            throw new UserError(\n              'A user\\'s selector must contain at least one context element.'\n            );\n          } else {\n            let e = false;\n            (<{securityContext: any}[]>(\n              <PreAggsSelector>query.selector\n            ).contexts).forEach((c) => {\n              if (!c.securityContext) e = true;\n            });\n            if (e) {\n              throw new UserError(\n                'Every context element must contain the ' +\n                '\\'securityContext\\' property.'\n              );\n            }\n          }\n          result = await this.preAggregationsJobsPOST(\n            context,\n            <PreAggsSelector>query.selector\n          );\n          if (result.length === 0) {\n            throw new UserError(\n              'A user\\'s selector doesn\\'t match any of the ' +\n              'pre-aggregations described by the Cube schemas.'\n            );\n          }\n          break;\n        case 'get':\n          result = await this.preAggregationsJobsGET(\n            context,\n            <string[]>query.tokens,\n            query.resType,\n          );\n          break;\n        default:\n          throw new Error(`The '${query.action}' action type doesn't supported.`);\n      }\n      response(result, { status: 200 });\n    } catch (e) {\n      this.handleError({ e, context, query, res: response, started });\n    }\n  }\n\n  /**\n   * Post pre-aggregations build jobs entry point.\n   */\n  private async preAggregationsJobsPOST(\n    context: RequestContext,\n    selector: PreAggsSelector,\n  ): Promise<string[]> {\n    let jobs: string[] = [];\n    if (!selector.contexts?.length) {\n      jobs = await this.postPreAggregationsBuildJobs(\n        context,\n        selector,\n      );\n    } else {\n      const promise = Promise.all(\n        selector.contexts.map(async (config) => {\n          const ctx = <RequestContext>{\n            ...context,\n            ...config,\n          };\n          const _jobs = await this.postPreAggregationsBuildJobs(\n            ctx,\n            selector,\n          );\n          return _jobs;\n        })\n      );\n      const resolve = await promise;\n      resolve.forEach((_jobs) => {\n        jobs = jobs.concat(_jobs);\n      });\n    }\n    return jobs;\n  }\n\n  /**\n   * Add pre-aggregations build job. Returns added jobs ids.\n   */\n  private async postPreAggregationsBuildJobs(\n    context: RequestContext,\n    selector: PreAggsSelector\n  ): Promise<string[]> {\n    const compiler = this.getCompilerApi(context);\n    const { timezones } = selector;\n    const preaggs = await compiler.preAggregations({\n      dataSources: selector.dataSources,\n      cubes: selector.cubes,\n      preAggregationIds: selector.preAggregations,\n    });\n    if (preaggs.length === 0) {\n      return [];\n    } else {\n      const jobs: string[] = await this\n        .refreshScheduler()\n        .postBuildJobs(\n          context,\n          {\n            metadata: undefined,\n            timezones,\n            preAggregations: preaggs.map(p => ({\n              id: p.id,\n              cacheOnly: undefined, // boolean\n              partitions: undefined, // string[]\n            })),\n            forceBuildPreAggregations: undefined,\n            throwErrors: false,\n          }\n        );\n      return jobs;\n    }\n  }\n\n  /**\n   * Get pre-aggregations build jobs entry point.\n   */\n  private async preAggregationsJobsGET(\n    context: RequestContext,\n    tokens: string[],\n    resType = 'array',\n  ): Promise<PreAggJobStatusResponse> {\n    const objResponse: PreAggJobStatusObject = {};\n    const selector: PreAggJob[] = await this\n      .refreshScheduler()\n      .getCachedBuildJobs(context, tokens);\n    const metaCache: Map<string, any> = new Map();\n    const promise: Promise<(PreAggJobStatusItem | undefined)[]> = Promise.all(\n      selector.map(async (selected, i) => {\n        const ctx = { ...context, ...selected.context };\n        const orchestrator = this.getAdapterApi(ctx);\n        const compiler = this.getCompilerApi(ctx);\n        const sel: PreAggsSelector = {\n          cubes: [selected.preagg.split('.')[0]],\n          preAggregations: [selected.preagg],\n          contexts: [selected.context],\n          timezones: [selected.timezone],\n          dataSources: [selected.dataSource],\n        };\n        if (\n          selected.status.indexOf('done') === 0 ||\n          selected.status.indexOf('failure') === 0\n        ) {\n          // returning from the cache\n          if (resType === 'object') {\n            objResponse[tokens[i]] = {\n              table: selected.target,\n              status: selected.status,\n              selector: sel,\n            };\n          } else {\n            return {\n              token: tokens[i],\n              table: selected.target,\n              status: selected.status,\n              selector: sel,\n            };\n          }\n        } else {\n          // checking the queue\n          const status = await this.getPreAggJobQueueStatus(\n            orchestrator,\n            selected,\n          );\n          if (status) {\n            // returning queued status\n            if (resType === 'object') {\n              objResponse[tokens[i]] = {\n                table: selected.target,\n                status,\n                selector: sel,\n              };\n            } else {\n              return {\n                token: tokens[i],\n                table: selected.target,\n                status,\n                selector: sel,\n              };\n            }\n          } else {\n            const key = JSON.stringify(ctx);\n            if (!metaCache.has(key)) {\n              metaCache.set(key, await compiler.metaConfigExtended(ctx));\n            }\n            // checking and fetching result status\n            const s = await this.getPreAggJobResultStatus(\n              ctx.requestId,\n              orchestrator,\n              compiler,\n              metaCache.get(key),\n              selected,\n              tokens[i],\n            );\n            if (resType === 'object') {\n              objResponse[tokens[i]] = {\n                table: selected.target,\n                status: s,\n                selector: sel,\n              };\n            } else {\n              return {\n                token: tokens[i],\n                table: selected.target,\n                status: s,\n                selector: sel,\n              };\n            }\n          }\n        }\n        return undefined;\n      })\n    );\n    const arrResponse: (PreAggJobStatusItem | undefined)[] = await promise;\n    return resType === 'object'\n      ? objResponse\n      : <PreAggJobStatusItem[]>arrResponse;\n  }\n\n  /**\n   * Returns PreAggJob status if it still in queue, false otherwose.\n   */\n  private async getPreAggJobQueueStatus(\n    orchestrator: any,\n    job: PreAggJob,\n  ): Promise<false | string> {\n    let inQueue = false;\n    let status: string = 'n/a';\n    const queuedList = await orchestrator.getPreAggregationQueueStates();\n    queuedList.forEach((item) => {\n      if (\n        item.queryHandler &&\n        item.queryHandler === 'query' &&\n        item.query &&\n        item.query.requestId === job.request &&\n        item.query.newVersionEntry.table_name === job.table &&\n        item.query.newVersionEntry.structure_version === job.structure &&\n        item.query.newVersionEntry.content_version === job.content &&\n        item.query.newVersionEntry.last_updated_at === job.updated\n      ) {\n        inQueue = true;\n        switch (<string>item.status[0]) {\n          case 'toProcess':\n            status = 'scheduled';\n            break;\n          case 'active':\n            status = 'processing';\n            break;\n          default:\n            status = <string>item.status[0];\n            break;\n        }\n      }\n    });\n    return inQueue ? status : false;\n  }\n\n  /**\n   * Returns PreAggJob execution status.\n   */\n  private async getPreAggJobResultStatus(\n    requestId: string,\n    orchestrator: any,\n    compiler: any,\n    metadata: any,\n    job: PreAggJob,\n    token: string,\n  ): Promise<string> {\n    const preaggs = await compiler.preAggregations();\n    const preagg = preaggs.filter(pa => pa.id === job.preagg)[0];\n    const cube = metadata.cubeDefinitions[preagg.cube];\n    const [, status]: [boolean, string] =\n      await orchestrator.isPartitionExist(\n        requestId,\n        preagg.preAggregation.external,\n        cube.dataSource,\n        compiler.preAggregationsSchema,\n        job.target,\n        job.key,\n        token,\n      );\n    return status;\n  }\n\n  public async getPreAggregationsInQueue(\n    { context, res }: { context: RequestContext, res: ResponseResultFn }\n  ) {\n    const requestStarted = new Date();\n    try {\n      const orchestratorApi = this.getAdapterApi(context);\n      res({\n        result: await orchestratorApi.getPreAggregationQueueStates()\n      });\n    } catch (e) {\n      this.handleError({\n        e, context, res, requestStarted\n      });\n    }\n  }\n\n  public async cancelPreAggregationsFromQueue(\n    { query, context, res }: { query: any, context: RequestContext, res: ResponseResultFn }\n  ) {\n    const requestStarted = new Date();\n    try {\n      const { queryKeys, dataSource } = normalizeQueryCancelPreAggregations(this.parseQueryParam(query));\n      const orchestratorApi = this.getAdapterApi(context);\n      res({\n        result: await orchestratorApi.cancelPreAggregationQueriesFromQueue(queryKeys, dataSource)\n      });\n    } catch (e) {\n      this.handleError({\n        e, context, res, requestStarted\n      });\n    }\n  }\n\n  /**\n   * Convert incoming query parameter (JSON fetched from the HTTP) to\n   * an array of query type and array of normalized queries.\n   */\n  protected async getNormalizedQueries(\n    query: Record<string, any> | Record<string, any>[],\n    context: RequestContext,\n  ): Promise<[QueryType, NormalizedQuery[]]> {\n    query = this.parseQueryParam(query);\n    let queryType: QueryType = QueryTypeEnum.REGULAR_QUERY;\n\n    if (!Array.isArray(query)) {\n      query = this.compareDateRangeTransformer(query);\n      if (Array.isArray(query)) {\n        queryType = QueryTypeEnum.COMPARE_DATE_RANGE_QUERY;\n      }\n    } else {\n      queryType = QueryTypeEnum.BLENDING_QUERY;\n    }\n\n    const queries = Array.isArray(query) ? query : [query];\n    const normalizedQueries: NormalizedQuery[] = await Promise.all(\n      queries.map(\n        async (currentQuery) => validatePostRewrite(\n          await this.queryRewrite(\n            normalizeQuery(currentQuery),\n            context\n          )\n        )\n      )\n    );\n\n    if (normalizedQueries.find((currentQuery) => !currentQuery)) {\n      throw new Error('queryTransformer returned null query. Please check your queryTransformer implementation');\n    }\n\n    if (queryType === QueryTypeEnum.BLENDING_QUERY) {\n      const queryGranularity = getQueryGranularity(normalizedQueries);\n\n      if (queryGranularity.length > 1) {\n        throw new UserError('Data blending query granularities must match');\n      }\n      if (queryGranularity.filter(Boolean).length === 0) {\n        throw new UserError('Data blending query without granularity is not supported');\n      }\n    }\n\n    return [queryType, normalizedQueries];\n  }\n\n  public async sql({ query, context, res }: QueryRequest) {\n    const requestStarted = new Date();\n\n    try {\n      query = this.parseQueryParam(query);\n      const [queryType, normalizedQueries] = await this.getNormalizedQueries(query, context);\n\n      const sqlQueries = await Promise.all<any>(\n        normalizedQueries.map((normalizedQuery) => this.getCompilerApi(context).getSql(\n          this.coerceForSqlQuery(normalizedQuery, context),\n          { includeDebugInfo: getEnv('devMode') || context.signedWithPlaygroundAuthSecret }\n        ))\n      );\n\n      const toQuery = (sqlQuery) => ({\n        ...sqlQuery,\n        order: R.fromPairs(sqlQuery.order.map(({ id: key, desc }) => [key, desc ? 'desc' : 'asc']))\n      });\n\n      res(queryType === QueryTypeEnum.REGULAR_QUERY ?\n        { sql: toQuery(sqlQueries[0]) } :\n        sqlQueries.map((sqlQuery) => ({ sql: toQuery(sqlQuery) })));\n    } catch (e) {\n      this.handleError({\n        e, context, query, res, requestStarted\n      });\n    }\n  }\n\n  protected createSecurityContextExtractor(options?: JWTOptions): SecurityContextExtractorFn {\n    if (options?.claimsNamespace) {\n      return (ctx: Readonly<RequestContext>) => {\n        if (typeof ctx.securityContext === 'object' && ctx.securityContext !== null) {\n          if (<string>options.claimsNamespace in ctx.securityContext) {\n            return ctx.securityContext[<string>options.claimsNamespace];\n          }\n        }\n\n        return {};\n      };\n    }\n\n    let checkAuthDeprecationShown: boolean = false;\n\n    return (ctx: Readonly<RequestContext>) => {\n      let securityContext: any = {};\n\n      if (typeof ctx.securityContext === 'object' && ctx.securityContext !== null) {\n        if (ctx.securityContext.u) {\n          if (!checkAuthDeprecationShown) {\n            this.logger('JWT U Property Deprecation', {\n              warning: (\n                'Storing security context in the u property within the payload is now deprecated, please migrate: ' +\n                'https://github.com/cube-js/cube.js/blob/master/DEPRECATION.md#authinfo'\n              )\n            });\n\n            checkAuthDeprecationShown = true;\n          }\n\n          securityContext = {\n            ...ctx.securityContext,\n            ...ctx.securityContext.u,\n          };\n\n          delete securityContext.u;\n        } else {\n          securityContext = ctx.securityContext;\n        }\n      }\n\n      return securityContext;\n    };\n  }\n\n  protected coerceForSqlQuery(query, context: Readonly<RequestContext>) {\n    return {\n      ...query,\n      timeDimensions: query.timeDimensions || [],\n      contextSymbols: {\n        securityContext: this.securityContextExtractor(context),\n      },\n      requestId: context.requestId\n    };\n  }\n\n  protected async dryRun({ query, context, res }: QueryRequest) {\n    const requestStarted = new Date();\n\n    try {\n      const [queryType, normalizedQueries] = await this.getNormalizedQueries(query, context);\n\n      const sqlQueries = await Promise.all<any>(\n        normalizedQueries.map((normalizedQuery) => this.getCompilerApi(context).getSql(\n          this.coerceForSqlQuery(normalizedQuery, context),\n          {\n            includeDebugInfo: getEnv('devMode') || context.signedWithPlaygroundAuthSecret\n          }\n        ))\n      );\n\n      res({\n        queryType,\n        normalizedQueries,\n        queryOrder: sqlQueries.map((sqlQuery) => R.fromPairs(\n          sqlQuery.order.map(({ id: member, desc }) => [member, desc ? 'desc' : 'asc'])\n        )),\n        transformedQueries: sqlQueries.map((sqlQuery) => sqlQuery.canUseTransformedQuery),\n        pivotQuery: getPivotQuery(queryType, normalizedQueries)\n      });\n    } catch (e) {\n      this.handleError({\n        e, context, query, res, requestStarted\n      });\n    }\n  }\n\n  /**\n   * Returns an array of sqlQuery objects for specified normalized\n   * queries.\n   * @internal\n   */\n  private async getSqlQueriesInternal(\n    context: RequestContext,\n    normalizedQueries: (NormalizedQuery)[],\n  ): Promise<Array<any>> {\n    const sqlQueries = await Promise.all(\n      normalizedQueries.map(\n        async (normalizedQuery, index) => {\n          const loadRequestSQLStarted = new Date();\n          const sqlQuery = await this.getCompilerApi(context)\n            .getSql(\n              this.coerceForSqlQuery(normalizedQuery, context)\n            );\n\n          this.log({\n            type: 'Load Request SQL',\n            duration: this.duration(loadRequestSQLStarted),\n            query: normalizedQueries[index],\n            sqlQuery\n          }, context);\n\n          return sqlQuery;\n        }\n      )\n    );\n    return sqlQueries;\n  }\n\n  /**\n   * Execute query and return adapter's result.\n   * @internal\n   */\n  private async getSqlResponseInternal(\n    context: RequestContext,\n    normalizedQuery: NormalizedQuery,\n    sqlQuery: any,\n    apiType: string,\n  ) {\n    const queries = [{\n      ...sqlQuery,\n      query: sqlQuery.sql[0],\n      values: sqlQuery.sql[1],\n      continueWait: true,\n      renewQuery: normalizedQuery.renewQuery,\n      requestId: context.requestId,\n      context,\n      persistent: apiType === 'sql',\n    }];\n    if (normalizedQuery.total) {\n      const normalizedTotal = structuredClone(normalizedQuery);\n      normalizedTotal.totalQuery = true;\n      normalizedTotal.limit = null;\n      normalizedTotal.rowLimit = null;\n      normalizedTotal.offset = null;\n      const [totalQuery] = await this.getSqlQueriesInternal(\n        context,\n        [normalizedTotal],\n      );\n      queries.push({\n        ...totalQuery,\n        query: totalQuery.sql[0],\n        values: totalQuery.sql[1],\n        continueWait: true,\n        renewQuery: normalizedTotal.renewQuery,\n        requestId: context.requestId,\n        context\n      });\n    }\n    const [response, total] = await Promise.all(\n      queries.map(async (query) => {\n        const res = await this\n          .getAdapterApi(context)\n          .executeQuery(query);\n        return res;\n      })\n    );\n    response.total = normalizedQuery.total\n      ? Number(total.data[0][QueryAlias.TOTAL_COUNT])\n      : undefined;\n    return response;\n  }\n\n  /**\n   * Convert adapter's result and other request paramters to a final\n   * result object.\n   * @internal\n   */\n  private getResultInternal(\n    context: RequestContext,\n    queryType: QueryType,\n    normalizedQuery: NormalizedQuery,\n    sqlQuery: any,\n    annotation: {\n      measures: {\n        [index: string]: unknown;\n      };\n      dimensions: {\n        [index: string]: unknown;\n      };\n      segments: {\n        [index: string]: unknown;\n      };\n      timeDimensions: {\n        [index: string]: unknown;\n      };\n    },\n    response: any,\n    responseType?: ResultType,\n  ) {\n    return {\n      query: normalizedQuery,\n      data: transformData(\n        sqlQuery.aliasNameToMember,\n        {\n          ...annotation.measures,\n          ...annotation.dimensions,\n          ...annotation.timeDimensions\n        } as { [member: string]: ConfigItem },\n        response.data,\n        normalizedQuery,\n        queryType,\n        responseType,\n      ),\n      lastRefreshTime: response.lastRefreshTime?.toISOString(),\n      ...(\n        getEnv('devMode') ||\n          context.signedWithPlaygroundAuthSecret\n          ? {\n            refreshKeyValues: response.refreshKeyValues,\n            usedPreAggregations: response.usedPreAggregations,\n            transformedQuery: sqlQuery.canUseTransformedQuery,\n            requestId: context.requestId,\n          }\n          : null\n      ),\n      annotation,\n      dataSource: response.dataSource,\n      dbType: response.dbType,\n      extDbType: response.extDbType,\n      external: response.external,\n      slowQuery: Boolean(response.slowQuery),\n      total: normalizedQuery.total ? response.total : null,\n    };\n  }\n\n  /**\n   * Data queries APIs (`/load`, `/subscribe`) entry point. Used by\n   * `CubejsApi#load` and `CubejsApi#subscribe` methods to fetch the\n   * data.\n   */\n  public async load(request: QueryRequest) {\n    let query: Query | Query[] | undefined;\n    const {\n      context,\n      res,\n      apiType = 'rest',\n      ...props\n    } = request;\n    const requestStarted = new Date();\n\n    try {\n      query = this.parseQueryParam(request.query);\n      let resType: ResultType = ResultType.DEFAULT;\n\n      if (!Array.isArray(query) && query.responseFormat) {\n        resType = query.responseFormat;\n      }\n\n      this.log({\n        type: 'Load Request',\n        query\n      }, context);\n\n      const [queryType, normalizedQueries] =\n        await this.getNormalizedQueries(query, context);\n\n      let metaConfigResult = await this\n        .getCompilerApi(context).metaConfig({\n          requestId: context.requestId\n        });\n\n      metaConfigResult = this.filterVisibleItemsInMeta(context, metaConfigResult);\n\n      const sqlQueries = await this\n        .getSqlQueriesInternal(context, normalizedQueries);\n\n      let slowQuery = false;\n\n      const results = await Promise.all(\n        normalizedQueries.map(async (normalizedQuery, index) => {\n          slowQuery = slowQuery ||\n            Boolean(sqlQueries[index].slowQuery);\n\n          const annotation = prepareAnnotation(\n            metaConfigResult, normalizedQuery\n          );\n\n          const response = await this.getSqlResponseInternal(\n            context,\n            normalizedQuery,\n            sqlQueries[index],\n            apiType,\n          );\n\n          return this.getResultInternal(\n            context,\n            queryType,\n            normalizedQuery,\n            sqlQueries[index],\n            annotation,\n            response,\n            resType,\n          );\n        })\n      );\n\n      this.log(\n        {\n          type: 'Load Request Success',\n          query,\n          duration: this.duration(requestStarted),\n          apiType,\n          isPlayground: Boolean(\n            context.signedWithPlaygroundAuthSecret\n          ),\n          queries: results.length,\n          queriesWithPreAggregations:\n            results.filter(\n              (r: any) => Object.keys(\n                r.usedPreAggregations || {}\n              ).length\n            ).length,\n          queriesWithData:\n            results.filter((r: any) => r.data?.length).length,\n          dbType: results.map(r => r.dbType),\n        },\n        context,\n      );\n\n      if (\n        queryType !== QueryTypeEnum.REGULAR_QUERY &&\n        props.queryType == null\n      ) {\n        throw new UserError(\n          `'${queryType\n          }' query type is not supported by the client.` +\n          'Please update the client.'\n        );\n      }\n\n      if (props.queryType === 'multi') {\n        res({\n          queryType,\n          results,\n          pivotQuery: getPivotQuery(queryType, normalizedQueries),\n          slowQuery\n        });\n      } else {\n        res(results[0]);\n      }\n    } catch (e) {\n      this.handleError({\n        e, context, query, res, requestStarted\n      });\n    }\n  }\n\n  public subscribeQueueEvents({ context, signedWithPlaygroundAuthSecret, connectionId, res }) {\n    if (this.enforceSecurityChecks && !signedWithPlaygroundAuthSecret) {\n      throw new CubejsHandlerError(\n        403,\n        'Forbidden',\n        'Only for signed with playground auth secret'\n      );\n    }\n    return this.getAdapterApi(context).subscribeQueueEvents(connectionId, res);\n  }\n\n  public unSubscribeQueueEvents({ context, connectionId }) {\n    return this.getAdapterApi(context).unSubscribeQueueEvents(connectionId);\n  }\n\n  public async subscribe({\n    query, context, res, subscribe, subscriptionState, queryType, apiType\n  }) {\n    const requestStarted = new Date();\n    try {\n      this.log({\n        type: 'Subscribe',\n        query\n      }, context);\n\n      let result: any = null;\n      let error: any = null;\n\n      if (!subscribe) {\n        await this.load({ query, context, res, queryType, apiType });\n        return;\n      }\n\n      // TODO subscribe to refreshKeys instead of constantly firing load\n      await this.load({\n        query,\n        context,\n        res: (message, opts) => {\n          if (!Array.isArray(message) && message.error) {\n            error = { message, opts };\n          } else {\n            result = { message, opts };\n          }\n        },\n        queryType,\n        apiType,\n      });\n      const state = await subscriptionState();\n      if (result && (!state || JSON.stringify(state.result) !== JSON.stringify(result))) {\n        res(result.message, result.opts);\n      } else if (error) {\n        res(error.message, error.opts);\n      }\n      await subscribe({ error, result });\n    } catch (e) {\n      this.handleError({\n        e, context, query, res, requestStarted\n      });\n    }\n  }\n\n  protected resToResultFn(res: Response) {\n    return (message, { status }: { status?: number } = {}) => (status ? res.status(status).json(message) : res.json(message));\n  }\n\n  protected parseQueryParam(query): Query | Query[] {\n    if (!query || query === 'undefined') {\n      throw new UserError('query param is required');\n    }\n    if (typeof query === 'string') {\n      query = JSON.parse(query);\n    }\n    return query as Query | Query[];\n  }\n\n  protected getCompilerApi(context) {\n    if (typeof this.compilerApi === 'function') {\n      return this.compilerApi(context);\n    }\n\n    return this.compilerApi;\n  }\n\n  protected getAdapterApi(context) {\n    if (typeof this.adapterApi === 'function') {\n      return this.adapterApi(context);\n    }\n\n    return this.adapterApi;\n  }\n\n  public async contextByReq(req: Request, securityContext, requestId: string): Promise<ExtendedRequestContext> {\n    const extensions = typeof this.extendContext === 'function' ? await this.extendContext(req) : {};\n\n    return {\n      securityContext,\n      // Deprecated, but let's allow it for now.\n      authInfo: securityContext,\n      signedWithPlaygroundAuthSecret: Boolean(req.signedWithPlaygroundAuthSecret),\n      requestId,\n      ...extensions,\n    };\n  }\n\n  protected handleErrorMiddleware: ErrorRequestHandler = async (e, req, res, next) => {\n    this.handleError({\n      e,\n      context: (<any>req).context,\n      res: this.resToResultFn(res),\n      requestStarted: new Date(),\n    });\n\n    next(e);\n  };\n\n  public handleError({\n    e, context, query, res, requestStarted\n  }: any) {\n    const requestId = getEnv('devMode') || context?.signedWithPlaygroundAuthSecret ? context?.requestId : undefined;\n    \n    const plainError = e.plainMessages;\n    \n    if (e instanceof CubejsHandlerError) {\n      this.log({\n        type: e.type,\n        query,\n        error: e.message,\n        duration: this.duration(requestStarted)\n      }, context);\n      res({ error: e.message, stack: e.stack, requestId, plainError }, { status: e.status });\n    } else if (e.error === 'Continue wait') {\n      this.log({\n        type: 'Continue wait',\n        query,\n        error: e.message,\n        duration: this.duration(requestStarted),\n      }, context);\n      res({ error: e.message || e.error.message || e.error.toString(), requestId }, { status: 200 });\n    } else if (e.error) {\n      this.log({\n        type: 'Orchestrator error',\n        query,\n        error: e.error,\n        duration: this.duration(requestStarted),\n      }, context);\n      res({ error: e.message || e.error.message || e.error.toString(), requestId }, { status: 400 });\n    } else if (e.type === 'UserError') {\n      this.log({\n        type: e.type,\n        query,\n        error: e.message,\n        duration: this.duration(requestStarted)\n      }, context);\n      res(\n        {\n          type: e.type,\n          error: e.message,\n          plainError,\n          stack: e.stack,\n          requestId\n        },\n        { status: 400 }\n      );\n    } else {\n      this.log({\n        type: 'Internal Server Error',\n        query,\n        error: e.stack || e.toString(),\n        duration: this.duration(requestStarted)\n      }, context);\n      res({ error: e.toString(), stack: e.stack, requestId, plainError, }, { status: 500 });\n    }\n  }\n\n  protected wrapCheckAuthMiddleware(fn: CheckAuthMiddlewareFn): CheckAuthMiddlewareFn {\n    this.logger('CheckAuthMiddleware Middleware Deprecation', {\n      warning: (\n        'Option checkAuthMiddleware is now deprecated in favor of checkAuth, please migrate: ' +\n        'https://github.com/cube-js/cube.js/blob/master/DEPRECATION.md#checkauthmiddleware'\n      )\n    });\n\n    let showWarningAboutNotObject = false;\n\n    return (req, res, next) => {\n      fn(req, res, (e) => {\n        // We renamed authInfo to securityContext, but users can continue to use both ways\n        if (req.securityContext && !req.authInfo) {\n          req.authInfo = req.securityContext;\n        } else if (req.authInfo) {\n          req.securityContext = req.authInfo;\n        }\n\n        if ((typeof req.securityContext !== 'object' || req.securityContext === null) && !showWarningAboutNotObject) {\n          this.logger('Security Context Should Be Object', {\n            warning: (\n              `Value of securityContext (previously authInfo) expected to be object, actual: ${getRealType(req.securityContext)}`\n            )\n          });\n\n          showWarningAboutNotObject = true;\n        }\n\n        next(e);\n      });\n    };\n  }\n\n  protected wrapCheckAuth(fn: CheckAuthFn): CheckAuthFn {\n    // We dont need to span all logs with deprecation message\n    let warningShowed = false;\n    // securityContext should be object\n    let showWarningAboutNotObject = false;\n\n    return async (req, auth) => {\n      await fn(req, auth);\n\n      // We renamed authInfo to securityContext, but users can continue to use both ways\n      if (req.securityContext && !req.authInfo) {\n        req.authInfo = req.securityContext;\n      } else if (req.authInfo) {\n        if (!warningShowed) {\n          this.logger('AuthInfo Deprecation', {\n            warning: (\n              'authInfo was renamed to securityContext, please migrate: ' +\n              'https://github.com/cube-js/cube.js/blob/master/DEPRECATION.md#checkauthmiddleware'\n            )\n          });\n\n          warningShowed = true;\n        }\n\n        req.securityContext = req.authInfo;\n      }\n\n      if ((typeof req.securityContext !== 'object' || req.securityContext === null) && !showWarningAboutNotObject) {\n        this.logger('Security Context Should Be Object', {\n          warning: (\n            `Value of securityContext (previously authInfo) expected to be object, actual: ${getRealType(req.securityContext)}`\n          )\n        });\n\n        showWarningAboutNotObject = true;\n      }\n    };\n  }\n\n  protected createDefaultCheckAuth(options?: JWTOptions, internalOptions?: CheckAuthInternalOptions): CheckAuthFn {\n    type VerifyTokenFn = (auth: string, secret: string) => Promise<object | string> | object | string;\n\n    const verifyToken = (auth, secret) => jwt.verify(auth, secret, {\n      algorithms: <JWTAlgorithm[] | undefined>options?.algorithms,\n      issuer: options?.issuer,\n      audience: options?.audience,\n      subject: options?.subject,\n    });\n\n    let checkAuthFn: VerifyTokenFn = verifyToken;\n\n    if (options?.jwkUrl) {\n      const jwks = createJWKsFetcher(options, {\n        onBackgroundException: (e) => {\n          this.logger('JWKs Background Fetching Error', {\n            error: e.message,\n          });\n        },\n      });\n\n      this.releaseListeners.push(jwks.release);\n\n      // Precache JWKs response to speedup first auth\n      if (options.jwkUrl && typeof options.jwkUrl === 'string') {\n        jwks.fetchOnly(options.jwkUrl).catch((e) => this.logger('JWKs Prefetching Error', {\n          error: e.message,\n        }));\n      }\n\n      checkAuthFn = async (auth) => {\n        const decoded = <Record<string, any> | null>jwt.decode(auth, { complete: true });\n        if (!decoded) {\n          throw new CubejsHandlerError(\n            403,\n            'Forbidden',\n            'Unable to decode JWT key'\n          );\n        }\n\n        if (!decoded.header || !decoded.header.kid) {\n          throw new CubejsHandlerError(\n            403,\n            'Forbidden',\n            'JWT without kid inside headers'\n          );\n        }\n\n        const jwk = await jwks.getJWKbyKid(\n          typeof options.jwkUrl === 'function' ? options.jwkUrl(decoded) : <string>options.jwkUrl,\n          decoded.header.kid\n        );\n        if (!jwk) {\n          throw new CubejsHandlerError(\n            403,\n            'Forbidden',\n            `Unable to verify, JWK with kid: \"${decoded.header.kid}\" not found`\n          );\n        }\n\n        return verifyToken(auth, jwk);\n      };\n    }\n\n    const secret = options?.key || this.apiSecret;\n\n    return async (req, auth) => {\n      if (auth) {\n        try {\n          req.securityContext = await checkAuthFn(auth, secret);\n          req.signedWithPlaygroundAuthSecret = Boolean(internalOptions?.isPlaygroundCheckAuth);\n        } catch (e) {\n          if (this.enforceSecurityChecks) {\n            throw new CubejsHandlerError(403, 'Forbidden', 'Invalid token');\n          } else {\n            this.log({\n              type: (e as Error).message,\n              token: auth,\n              error: (e as Error).stack || (e as Error).toString()\n            }, <any>req);\n          }\n        }\n      } else if (this.enforceSecurityChecks) {\n        // @todo Move it to 401 or 400\n        throw new CubejsHandlerError(403, 'Forbidden', 'Authorization header isn\\'t set');\n      }\n    };\n  }\n\n  protected createCheckAuthFn(options: ApiGatewayOptions): CheckAuthFn {\n    const mainCheckAuthFn = options.checkAuth\n      ? this.wrapCheckAuth(options.checkAuth)\n      : this.createDefaultCheckAuth(options.jwt);\n\n    if (this.playgroundAuthSecret) {\n      const systemCheckAuthFn = this.createCheckAuthSystemFn();\n      return async (ctx, authorization) => {\n        try {\n          await mainCheckAuthFn(ctx, authorization);\n        } catch (error) {\n          await systemCheckAuthFn(ctx, authorization);\n        }\n      };\n    }\n\n    return (ctx, authorization) => mainCheckAuthFn(ctx, authorization);\n  }\n\n  protected createCheckAuthSystemFn(): CheckAuthFn {\n    const systemCheckAuthFn = this.createDefaultCheckAuth(\n      {\n        key: this.playgroundAuthSecret,\n        algorithms: ['HS256']\n      },\n      { isPlaygroundCheckAuth: true }\n    );\n\n    return async (ctx, authorization) => {\n      await systemCheckAuthFn(ctx, authorization);\n    };\n  }\n\n  protected extractAuthorizationHeaderWithSchema(req: Request) {\n    if (typeof req.headers.authorization === 'string') {\n      const parts = req.headers.authorization.split(' ', 2);\n      if (parts.length === 1) {\n        return parts[0];\n      }\n\n      return parts[1];\n    }\n\n    return undefined;\n  }\n\n  protected async checkAuthWrapper(checkAuthFn: CheckAuthFn, req: Request, res: Response, next) {\n    const token = this.extractAuthorizationHeaderWithSchema(req);\n\n    try {\n      await checkAuthFn(req, token);\n      if (next) {\n        next();\n      }\n    } catch (e: unknown) {\n      if (e instanceof CubejsHandlerError) {\n        res.status(e.status).json({ error: e.message });\n      } else if (e instanceof Error) {\n        this.log({\n          type: 'Auth Error',\n          token,\n          error: e.stack || e.toString()\n        }, <any>req);\n\n        res.status(500).json({\n          error: e.toString(),\n          stack: e.stack\n        });\n      }\n    }\n  }\n\n  protected checkAuth: RequestHandler = async (req, res, next) => {\n    await this.checkAuthWrapper(this.checkAuthFn, req, res, next);\n  };\n\n  protected checkAuthSystemMiddleware: RequestHandler = async (req, res, next) => {\n    await this.checkAuthWrapper(this.checkAuthSystemFn, req, res, next);\n  };\n\n  protected requestContextMiddleware: RequestHandler = async (req: Request, res: Response, next: NextFunction) => {\n    req.context = await this.contextByReq(req, req.securityContext, getRequestIdFromRequest(req));\n    if (next) {\n      next();\n    }\n  };\n\n  protected requestLogger: RequestHandler = async (req: Request, res: Response, next: NextFunction) => {\n    const details = requestParser(req, res);\n\n    this.log({ type: 'REST API Request', ...details }, req.context);\n\n    if (next) {\n      next();\n    }\n  };\n\n  protected logNetworkUsage: RequestHandler = async (req: Request, res: Response, next: NextFunction) => {\n    this.log({\n      type: 'Incoming network usage',\n      service: 'api-http',\n      bytes: Buffer.byteLength(req.url + req.rawHeaders.join('\\n')) + (Number(req.get('content-length')) || 0),\n      path: req.path,\n    }, req.context);\n    res.on('finish', () => {\n      this.log({\n        type: 'Outgoing network usage',\n        service: 'api-http',\n        bytes: Number(res.get('content-length')) || 0,\n        path: req.path,\n      }, req.context);\n    });\n    if (next) {\n      next();\n    }\n  };\n\n  protected compareDateRangeTransformer(query) {\n    let queryCompareDateRange;\n    let compareDateRangeTDIndex;\n\n    (query.timeDimensions || []).forEach((td, index) => {\n      if (td.compareDateRange != null) {\n        if (queryCompareDateRange != null) {\n          throw new UserError('compareDateRange can only exist for one timeDimension');\n        }\n\n        queryCompareDateRange = td.compareDateRange;\n        compareDateRangeTDIndex = index;\n      }\n    });\n\n    if (queryCompareDateRange == null) {\n      return query;\n    }\n\n    return queryCompareDateRange.map((dateRange) => ({\n      ...R.clone(query),\n      timeDimensions: query.timeDimensions.map((td, index) => {\n        if (compareDateRangeTDIndex === index) {\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          const { compareDateRange, ...timeDimension } = td;\n          return {\n            ...timeDimension,\n            dateRange\n          };\n        }\n\n        return td;\n      })\n    }));\n  }\n\n  public log(event: { type: string, [key: string]: any }, context?: Partial<RequestContext>) {\n    const { type, ...restParams } = event;\n\n    this.logger(type, {\n      ...restParams,\n      ...(!context ? undefined : {\n        securityContext: context.securityContext,\n        requestId: context.requestId,\n        ...(!context.appName ? undefined : { appName: context.appName }),\n        ...(!context.protocol ? undefined : { protocol: context.protocol }),\n        ...(!context.apiType ? undefined : { apiType: context.apiType }),\n      })\n    });\n  }\n\n  protected healthResponse(res: Response, health: 'HEALTH' | 'DOWN') {\n    res.status(health === 'HEALTH' ? 200 : 500).json({\n      health,\n    });\n  }\n\n  protected createSystemContextHandler = (basePath: string): RequestHandler => {\n    const body: Readonly<Record<string, any>> = {\n      basePath,\n      dockerVersion: getEnv('dockerImageVersion') || null,\n      serverCoreVersion: this.options.serverCoreVersion || null\n    };\n\n    return (req, res) => {\n      res.status(200).json(body);\n    };\n  };\n\n  private logProbeError(e: any, type: string): void {\n    this.log({\n      type,\n      driverType: e.driverType,\n      error: (e as Error).stack || (e as Error).toString(),\n    });\n  }\n\n  protected readiness: RequestHandler = async (req, res) => {\n    let health: 'HEALTH' | 'DOWN' = 'HEALTH';\n\n    if (this.standalone) {\n      const orchestratorApi = await this.adapterApi({});\n\n      try {\n        // todo: test other data sources\n        orchestratorApi.addDataSeenSource('default');\n        await orchestratorApi.testConnection();\n        await orchestratorApi.testOrchestratorConnections();\n      } catch (e: any) {\n        this.logProbeError(e, 'Internal Server Error on readiness probe');\n        health = 'DOWN';\n      }\n    }\n\n    return this.healthResponse(res, health);\n  };\n\n  protected liveness: RequestHandler = async (req, res) => {\n    let health: 'HEALTH' | 'DOWN' = 'HEALTH';\n\n    try {\n      await this.dataSourceStorage.testConnections();\n      // @todo Optimize this moment?\n      await this.dataSourceStorage.testOrchestratorConnections();\n    } catch (e: any) {\n      this.logProbeError(e, 'Internal Server Error on liveness probe');\n      health = 'DOWN';\n    }\n\n    return this.healthResponse(res, health);\n  };\n\n  public release() {\n    for (const releaseListener of this.releaseListeners) {\n      releaseListener();\n    }\n  }\n}\nexport {\n  UserBackgroundContext,\n  ApiGatewayOptions,\n  ApiGateway,\n};\n", "import crypto from 'crypto';\nimport R from 'ramda';\nimport { createQuery, compile, queryClass, PreAggregations, QueryFactory } from '@cubejs-backend/schema-compiler';\n\nexport class CompilerApi {\n  /**\n   * Class constructor.\n   * @param {SchemaFileRepository} repository\n   * @param {DbTypeAsyncFn} dbType\n   * @param {*} options\n   */\n  constructor(repository, dbType, options) {\n    this.repository = repository;\n    this.dbType = dbType;\n    this.dialectClass = options.dialectClass;\n    this.options = options || {};\n    this.allowNodeRequire = options.allowNodeRequire == null ? true : options.allowNodeRequire;\n    this.logger = this.options.logger;\n    this.preAggregationsSchema = this.options.preAggregationsSchema;\n    this.allowUngroupedWithoutPrimaryKey = this.options.allowUngroupedWithoutPrimaryKey;\n    this.schemaVersion = this.options.schemaVersion;\n    this.compileContext = options.compileContext;\n    this.allowJsDuplicatePropsInSchema = options.allowJsDuplicatePropsInSchema;\n    this.sqlCache = options.sqlCache;\n    this.standalone = options.standalone;\n  }\n\n  setGraphQLSchema(schema) {\n    this.graphqlSchema = schema;\n  }\n\n  getGraphQLSchema() {\n    return this.graphqlSchema;\n  }\n\n  async getCompilers({ requestId } = {}) {\n    let compilerVersion = (\n      this.schemaVersion && await this.schemaVersion() ||\n      'default_schema_version'\n    );\n\n    if (typeof compilerVersion === 'object') {\n      compilerVersion = JSON.stringify(compilerVersion);\n    }\n\n    if (this.options.devServer) {\n      const files = await this.repository.dataSchemaFiles();\n      compilerVersion += `_${crypto.createHash('md5').update(JSON.stringify(files)).digest('hex')}`;\n    }\n\n    if (!this.compilers || this.compilerVersion !== compilerVersion) {\n      this.logger(this.compilers ? 'Recompiling schema' : 'Compiling schema', {\n        version: compilerVersion,\n        requestId\n      });\n      this.compilers = await compile(this.repository, {\n        allowNodeRequire: this.allowNodeRequire,\n        compileContext: this.compileContext,\n        allowJsDuplicatePropsInSchema: this.allowJsDuplicatePropsInSchema,\n        standalone: this.standalone,\n      });\n      this.compilerVersion = compilerVersion;\n      this.queryFactory = await this.createQueryFactory(this.compilers);\n    }\n\n    return this.compilers;\n  }\n\n  async getDataSources(cubeEvaluator) {\n    return Promise.all(cubeEvaluator.cubeNames().map(async cube => cubeEvaluator.cubeFromPath(cube).dataSource ?? 'default'));\n  }\n\n  async createQueryFactory(compilers) {\n    const { cubeEvaluator } = compilers;\n\n    const cubeToQueryClass = R.fromPairs(\n      await Promise.all(\n        cubeEvaluator.cubeNames().map(async cube => {\n          const dataSource = cubeEvaluator.cubeFromPath(cube).dataSource ?? 'default';\n          const dbType = await this.getDbType(dataSource);\n          const dialectClass = this.getDialectClass(dataSource, dbType);\n          return [cube, queryClass(dbType, dialectClass)];\n        })\n      )\n    );\n    return new QueryFactory(cubeToQueryClass);\n  }\n\n  async getDbType(dataSource = 'default') {\n    const res = await this.dbType({ dataSource, });\n    return res;\n  }\n\n  getDialectClass(dataSource = 'default', dbType) {\n    return this.dialectClass && this.dialectClass({ dataSource, dbType });\n  }\n\n  async getSql(query, options = {}) {\n    const { includeDebugInfo } = options;\n\n    const dbType = await this.getDbType();\n    const compilers = await this.getCompilers({ requestId: query.requestId });\n    let sqlGenerator = await this.createQueryByDataSource(compilers, query);\n\n    if (!sqlGenerator) {\n      throw new Error(`Unknown dbType: ${dbType}`);\n    }\n\n    const dataSource = compilers.compiler.withQuery(sqlGenerator, () => sqlGenerator.dataSource);\n    const _dbType = await this.getDbType(dataSource);\n    if (dataSource !== 'default' && dbType !== _dbType) {\n      // TODO consider more efficient way than instantiating query\n      sqlGenerator = await this.createQueryByDataSource(\n        compilers,\n        query,\n        dataSource\n      );\n\n      if (!sqlGenerator) {\n        throw new Error(`Can't find dialect for '${dataSource}' data source: ${_dbType}`);\n      }\n    }\n\n    const getSqlFn = () => compilers.compiler.withQuery(sqlGenerator, () => ({\n      external: sqlGenerator.externalPreAggregationQuery(),\n      sql: sqlGenerator.buildSqlAndParams(),\n      lambdaQueries: sqlGenerator.buildLambdaQuery(),\n      timeDimensionAlias: sqlGenerator.timeDimensions[0] && sqlGenerator.timeDimensions[0].unescapedAliasName(),\n      timeDimensionField: sqlGenerator.timeDimensions[0] && sqlGenerator.timeDimensions[0].dimension,\n      order: sqlGenerator.order,\n      cacheKeyQueries: sqlGenerator.cacheKeyQueries(),\n      preAggregations: sqlGenerator.preAggregations.preAggregationsDescription(),\n      dataSource: sqlGenerator.dataSource,\n      aliasNameToMember: sqlGenerator.aliasNameToMember,\n      rollupMatchResults: includeDebugInfo ?\n        sqlGenerator.preAggregations.rollupMatchResultDescriptions() : undefined,\n      canUseTransformedQuery: sqlGenerator.preAggregations.canUseTransformedQuery()\n    }));\n\n    if (this.sqlCache) {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const { requestId, ...keyOptions } = query;\n      const key = { query: keyOptions, options };\n      return compilers.compilerCache.getQueryCache(key).cache(['sql'], getSqlFn);\n    } else {\n      return getSqlFn();\n    }\n  }\n\n  async preAggregations(filter) {\n    const { cubeEvaluator } = await this.getCompilers();\n    return cubeEvaluator.preAggregations(filter);\n  }\n\n  async scheduledPreAggregations() {\n    const { cubeEvaluator } = await this.getCompilers();\n    return cubeEvaluator.scheduledPreAggregations();\n  }\n\n  async createQueryByDataSource(compilers, query, dataSource) {\n    const dbType = await this.getDbType(dataSource);\n\n    return this.createQuery(compilers, dbType, this.getDialectClass(dataSource, dbType), query);\n  }\n\n  createQuery(compilers, dbType, dialectClass, query) {\n    return createQuery(\n      compilers,\n      dbType,\n      {\n        ...query,\n        dialectClass,\n        externalDialectClass: this.options.externalDialectClass,\n        externalDbType: this.options.externalDbType,\n        preAggregationsSchema: this.preAggregationsSchema,\n        allowUngroupedWithoutPrimaryKey: this.allowUngroupedWithoutPrimaryKey,\n        queryFactory: this.queryFactory,\n      }\n    );\n  }\n\n  async metaConfig(options) {\n    return (await this.getCompilers(options)).metaTransformer.cubes;\n  }\n\n  async metaConfigExtended(options) {\n    const { metaTransformer, cubeEvaluator } = await this.getCompilers(options);\n    return {\n      metaConfig: metaTransformer?.cubes,\n      dataSources: await this.getDataSources(cubeEvaluator),\n      cubeDefinitions: metaTransformer?.cubeEvaluator?.cubeDefinitions,\n    };\n  }\n\n  canUsePreAggregationForTransformedQuery(transformedQuery, refs) {\n    return PreAggregations.canUsePreAggregationForTransformedQueryFn(transformedQuery, refs);\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-empty-function */\n\nimport { withTimeout } from '@cubejs-backend/shared';\n\nimport {\n  CreateOptions,\n  CubejsServerCore,\n  SchemaFileRepository,\n  ServerCoreInitializedOptions\n} from '../../src';\nimport { OptsHandler } from '../../src/core/OptsHandler';\nimport { DatabaseType } from '../../src/core/types';\nimport { CompilerApi } from '../../src/core/CompilerApi';\nimport { OrchestratorApiOptions } from '../../src/core/OrchestratorApi';\n\n// It's just a mock to open protected methods\nclass CubejsServerCoreOpen extends CubejsServerCore {\n  public readonly optsHandler: OptsHandler;\n\n  public readonly options: ServerCoreInitializedOptions;\n\n  public getRefreshScheduler = super.getRefreshScheduler;\n\n  public isReadyForQueryProcessing = super.isReadyForQueryProcessing;\n\n  public createOrchestratorApi = super.createOrchestratorApi;\n}\n\nconst repositoryWithoutPreAggregations: SchemaFileRepository = {\n  localPath: () => __dirname,\n  dataSchemaFiles: () => Promise.resolve([\n    {\n      fileName: 'main.js', content: `\ncube('Bar', {\n  sql: 'select * from bar',\n  \n  measures: {\n    count: {\n      type: 'count'\n    }\n  },\n  \n  dimensions: {\n    time: {\n      sql: 'timestamp',\n      type: 'time'\n    }\n  }\n});\n`,\n    },\n  ]),\n};\n\nconst repositoryWithDataSource: SchemaFileRepository = {\n  localPath: () => __dirname,\n  dataSchemaFiles: () => Promise.resolve([\n    {\n      fileName: 'main.js', content: `\ncube('Bar', {\n  sql: 'select * from bar',\n  \n  measures: {\n    count: {\n      type: 'count'\n    }\n  },\n\n  dataSource: 'dataSource',\n\n  dimensions: {\n    time: {\n      sql: 'timestamp',\n      type: 'time'\n    }\n  }\n});\n`,\n    },\n  ]),\n};\n\nconst repositoryWithoutContent: SchemaFileRepository = {\n  localPath: () => __dirname,\n  dataSchemaFiles: () => Promise.resolve([{ fileName: 'main.js', content: '' }]),\n};\n\ndescribe('index.test', () => {\n  beforeEach(() => {\n    delete process.env.CUBEJS_EXT_DB_TYPE;\n    delete process.env.CUBEJS_DEV_MODE;\n    delete process.env.CUBEJS_DB_TYPE;\n    delete process.env.CUBEJS_REFRESH_WORKER;\n    delete process.env.CUBEJS_ROLLUP_ONLY;\n    delete process.env.CUBEJS_SCHEDULED_REFRESH;\n    delete process.env.CUBEJS_SCHEDULED_REFRESH_TIMER;\n\n    process.env.NODE_ENV = 'development';\n    process.env.CUBEJS_API_SECRET = 'api-secret';\n  });\n\n  test('Should create instance of CubejsServerCore, dbType as string', () => {\n    expect(new CubejsServerCore({\n      dbType: 'mysql'\n    })).toBeInstanceOf(CubejsServerCore);\n  });\n\n  test('Should create instance of CubejsServerCore, dbType as func', () => {\n    const options = { dbType: () => <DatabaseType>'postgres' };\n\n    expect(new CubejsServerCore(options))\n      .toBeInstanceOf(CubejsServerCore);\n  });\n\n  test('Should throw error, unknown dbType', () => {\n    const options = { dbType: <any>'unknown-db' };\n\n    expect(() => new CubejsServerCore(options))\n      .toThrowError(/\"dbType\" must be one of/);\n  });\n\n  test('Should throw error, invalid options', () => {\n    const options = {\n      dbType: <DatabaseType>'mysql',\n      externalDbType: <DatabaseType>'mysql',\n      schemaPath: '/test/path/test/',\n      basePath: '/basePath',\n      webSocketsBasePath: '/webSocketsBasePath',\n      devServer: true,\n      compilerCacheSize: -10,\n    };\n\n    expect(() => new CubejsServerCore(options))\n      .toThrowError(/\"compilerCacheSize\" must be larger than or equal to 0/);\n  });\n\n  test('Should create instance of CubejsServerCore, orchestratorOptions as func', () => {\n    const options = { dbType: <DatabaseType>'mysql', orchestratorOptions: () => <any>{} };\n\n    expect(new CubejsServerCore(options))\n      .toBeInstanceOf(CubejsServerCore);\n  });\n\n  const getCreateOrchestratorOptionsFromServer = (options: CreateOptions) => {\n    const cubejsServerCore = new CubejsServerCoreOpen(<any>options);\n    expect(cubejsServerCore).toBeInstanceOf(CubejsServerCore);\n\n    const createOrchestratorApiSpy = jest.spyOn(cubejsServerCore, 'createOrchestratorApi');\n    cubejsServerCore.getOrchestratorApi({\n      requestId: 'XXX',\n      authInfo: null,\n      securityContext: null,\n    });\n\n    expect(createOrchestratorApiSpy.mock.calls.length).toEqual(1);\n    return createOrchestratorApiSpy.mock.calls[0];\n  };\n\n  test('dbType should return string, failure', async () => {\n    const options: CreateOptions = { dbType: () => <any>null };\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const [driverFactory, orchestratorOptions] = getCreateOrchestratorOptionsFromServer(options);\n\n    try {\n      await driverFactory('mongo');\n\n      throw new Error('driverFactory will call dbType and dbType must throw an exception');\n    } catch (e: any) {\n      expect(e.message).toEqual('Unexpected CreateOptions.dbType result type: <object>null');\n    }\n  });\n\n  test('driverFactory should return driver, failure', async () => {\n    const options: CreateOptions = { dbType: () => <any>'mongo', driverFactory: () => <any>null, };\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const [driverFactory, orchestratorOptions] = getCreateOrchestratorOptionsFromServer(options);\n\n    try {\n      await driverFactory('default');\n\n      throw new Error('driverFactory will call dbType and dbType must throw an exception');\n    } catch (e: any) {\n      expect(e.message).toEqual('Unexpected CreateOptions.driverFactory result value. Must be either DriverConfig or driver instance: <object>null');\n    }\n  });\n\n  test('externalDriverFactory should return driver, failure', async () => {\n    const options: CreateOptions = { dbType: () => <any>'mongo', externalDriverFactory: () => <any>null, };\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const [driverFactory, orchestratorOptions] = getCreateOrchestratorOptionsFromServer(options);\n\n    try {\n      await orchestratorOptions.externalDriverFactory();\n\n      throw new Error('driverFactory will call dbType and dbType must throw an exception');\n    } catch (e: any) {\n      expect(e.message).toEqual('Unexpected return type, externalDriverFactory must return driver, actual: null');\n    }\n  });\n\n  test('Should create instance of CubejsServerCore, pass all options', async () => {\n    const queueOptions = {\n      concurrency: 3,\n      continueWaitTimeout: 5,\n      executionTimeout: 600,\n      orphanedTimeout: 120,\n      heartBeatInterval: 500,\n      sendProcessMessageFn: () => {},\n      sendCancelMessageFn: () => {}\n    };\n\n    const options = {\n      dbType: <any>'mysql',\n      externalDbType: 'cubestore',\n      schemaPath: '/test/path/test/',\n      basePath: '/basePath',\n      webSocketsBasePath: '/webSocketsBasePath',\n      initApp: () => {},\n      processSubscriptionsInterval: 5000,\n      devServer: false,\n      apiSecret: 'randomstring',\n      logger: () => {},\n      driverFactory: () => <any>{\n        setLogger: () => {},\n        testConnection: async () => {},\n        release: () => {}\n      },\n      dialectFactory: () => {},\n      externalDriverFactory: () => <any>{\n        setLogger: () => {},\n        testConnection: async () => {},\n        release: () => {}\n      },\n      externalDialectFactory: () => {},\n      cacheAndQueueDriver: 'redis',\n      contextToAppId: () => 'STANDALONE',\n      contextToOrchestratorId: () => 'EMPTY',\n      repositoryFactory: () => {},\n      checkAuth: () => {},\n      checkAuthMiddleware: () => {},\n      queryTransformer: () => {},\n      preAggregationsSchema: () => {},\n      schemaVersion: () => {},\n      extendContext: () => {},\n      compilerCacheSize: 1000,\n      maxCompilerCacheKeepAlive: 10,\n      updateCompilerCacheKeepAlive: true,\n      telemetry: false,\n      allowUngroupedWithoutPrimaryKey: true,\n      // scheduled\n      scheduledRefreshTimeZones: ['Europe/Moscow'],\n      scheduledRefreshConcurrency: 4,\n      scheduledRefreshTimer: true,\n      scheduledRefreshContexts: () => [{\n        securityContext: {\n          appid: 'test1',\n          u: {\n            prop1: 'value1'\n          }\n        }\n      }],\n      orchestratorOptions: {\n        continueWaitTimeout: 10,\n        redisPrefix: 'some-prefix',\n        queryCacheOptions: {\n          refreshKeyRenewalThreshold: 1000,\n          backgroundRenew: true,\n          queueOptions,\n          externalQueueOptions: {\n            ...queueOptions\n          }\n        },\n        preAggregationsOptions: {\n          queueOptions\n        },\n        rollupOnlyMode: true\n      },\n      allowJsDuplicatePropsInSchema: true,\n      jwt: {\n        // JWK options\n        jwkRetry: 5,\n        jwkDefaultExpire: 5 * 60,\n        jwkUrl: () => '',\n        jwkRefetchWindow: 5 * 60,\n        // JWT options\n        key: 'string',\n        algorithms: ['RS256'],\n        issuer: ['http://localhost:4000'],\n        audience: 'http://localhost:4000/v1',\n        subject: 'http://localhost:4000',\n        claimsNamespace: 'http://localhost:4000',\n      },\n      dashboardAppPath: 'string',\n      dashboardAppPort: 4444,\n      livePreview: true,\n      allowNodeRequire: false,\n    };\n\n    const cubejsServerCore = new CubejsServerCoreOpen(<any>options);\n    expect(cubejsServerCore).toBeInstanceOf(CubejsServerCore);\n\n    const createOrchestratorApiSpy = jest.spyOn(cubejsServerCore, 'createOrchestratorApi');\n\n    cubejsServerCore.getOrchestratorApi({\n      requestId: 'XXX',\n      authInfo: null,\n      securityContext: null,\n    });\n    expect(createOrchestratorApiSpy.mock.calls.length).toEqual(1);\n    expect(createOrchestratorApiSpy.mock.calls[0]).toEqual([\n      expect.any(Function),\n      {\n        cacheAndQueueDriver: 'redis',\n        contextToDbType: expect.any(Function),\n        contextToExternalDbType: expect.any(Function),\n        continueWaitTimeout: 10,\n        externalDriverFactory: expect.any(Function),\n        redisPrefix: 'some-prefix',\n        rollupOnlyMode: true,\n        // from orchestratorOptions\n        preAggregationsOptions: expect.any(Object),\n        queryCacheOptions: expect.any(Object),\n        // enabled for cubestore\n        skipExternalCacheAndQueue: true,\n      }\n    ]);\n    createOrchestratorApiSpy.mockRestore();\n\n    const compilerApi = cubejsServerCore.getCompilerApi({\n      authInfo: null,\n      securityContext: null,\n      requestId: 'XXX'\n    });\n    expect(compilerApi.options.allowNodeRequire).toStrictEqual(false);\n\n    await cubejsServerCore.releaseConnections();\n  });\n\n  describe('CompilerApi', () => {\n    const logger = jest.fn(() => {});\n    const compilerApi = new CompilerApi(\n      repositoryWithoutPreAggregations,\n      async () => 'mysql',\n      { logger }\n    );\n    const metaConfigSpy = jest.spyOn(compilerApi, 'metaConfig');\n    const metaConfigExtendedSpy = jest.spyOn(compilerApi, 'metaConfigExtended');\n\n    test('CompilerApi metaConfig', async () => {\n      const metaConfig = await compilerApi.metaConfig({ requestId: 'XXX' });\n      expect(metaConfig?.length).toBeGreaterThan(0);\n      expect(metaConfig[0]).toHaveProperty('config');\n      expect(metaConfig[0].config.hasOwnProperty('sql')).toBe(false);\n      expect(metaConfigSpy).toHaveBeenCalled();\n      metaConfigSpy.mockClear();\n    });\n\n    test('CompilerApi metaConfigExtended', async () => {\n      const metaConfigExtended = await compilerApi.metaConfigExtended({ requestId: 'XXX' });\n      expect(metaConfigExtended).toHaveProperty('metaConfig');\n      expect(metaConfigExtended.metaConfig.length).toBeGreaterThan(0);\n      expect(metaConfigExtended).toHaveProperty('cubeDefinitions');\n      expect(metaConfigExtended).toHaveProperty('dataSources');\n      expect(metaConfigExtended.dataSources).toEqual(['default']);\n      expect(metaConfigExtendedSpy).toHaveBeenCalled();\n      metaConfigExtendedSpy.mockClear();\n    });\n  });\n  \n  describe('CompilerApi with dataSource', () => {\n    const logger = jest.fn(() => {});\n    const compilerApi = new CompilerApi(\n      repositoryWithDataSource,\n      async () => 'mysql',\n      { logger }\n    );\n    const metaConfigExtendedSpy = jest.spyOn(compilerApi, 'metaConfigExtended');\n\n    test('CompilerApi metaConfigExtended', async () => {\n      const metaConfigExtended = await compilerApi.metaConfigExtended({ requestId: 'XXX' });\n      expect(metaConfigExtended).toHaveProperty('metaConfig');\n      expect(metaConfigExtended.metaConfig.length).toBeGreaterThan(0);\n      expect(metaConfigExtended).toHaveProperty('cubeDefinitions');\n      expect(metaConfigExtended).toHaveProperty('dataSources');\n      expect(metaConfigExtended.dataSources).toEqual(['dataSource']);\n      expect(metaConfigExtendedSpy).toHaveBeenCalled();\n      metaConfigExtendedSpy.mockClear();\n    });\n  });\n\n  describe('CompilerApi with empty cube on input', () => {\n    const logger = jest.fn(() => {});\n    const compilerApi = new CompilerApi(\n      repositoryWithoutContent,\n      async () => 'mysql',\n      { logger }\n    );\n    const metaConfigSpy = jest.spyOn(compilerApi, 'metaConfig');\n    const metaConfigExtendedSpy = jest.spyOn(compilerApi, 'metaConfigExtended');\n\n    test('CompilerApi metaConfig', async () => {\n      const metaConfig = await compilerApi.metaConfig({ requestId: 'XXX' });\n      expect(metaConfig).toEqual([]);\n      expect(metaConfigSpy).toHaveBeenCalled();\n      metaConfigSpy.mockClear();\n    });\n\n    test('CompilerApi metaConfigExtended', async () => {\n      const metaConfigExtended = await compilerApi.metaConfigExtended({ requestId: 'XXX' });\n      expect(metaConfigExtended).toHaveProperty('metaConfig');\n      expect(metaConfigExtended.metaConfig).toEqual([]);\n      expect(metaConfigExtended).toHaveProperty('cubeDefinitions');\n      expect(metaConfigExtended.cubeDefinitions).toEqual({});\n      expect(metaConfigExtendedSpy).toHaveBeenCalled();\n      metaConfigExtendedSpy.mockClear();\n    });\n  });\n\n  test('Should create instance of CubejsServerCore, dbType from process.env.CUBEJS_DB_TYPE', () => {\n    process.env.CUBEJS_DB_TYPE = 'mysql';\n\n    expect(new CubejsServerCore({}))\n      .toBeInstanceOf(CubejsServerCore);\n  });\n\n  test('Should create instance of CubejsServerCore, on unsupported platform for Cube Store', async () => {\n    const originalPlatform = process.platform;\n\n    const logger = jest.fn(() => {\n      //\n    });\n\n    try {\n      process.env.CUBEJS_DB_TYPE = 'mysql';\n      process.env.CUBEJS_DEV_MODE = 'true';\n\n      Object.defineProperty(process, 'platform', {\n        value: 'MockOS'\n      });\n\n      const cubejsServerCore = new CubejsServerCoreOpen({ logger });\n      await cubejsServerCore.beforeShutdown();\n      await cubejsServerCore.shutdown();\n    } finally {\n      jest.restoreAllMocks();\n\n      Object.defineProperty(process, 'platform', {\n        value: originalPlatform\n      });\n    }\n\n    expect(logger.mock.calls).toEqual([\n      [\n        'Cube Store is not supported on your system',\n        {\n          warning: 'You are using MockOS platform with x64 architecture, which is not supported by Cube Store.'\n        }\n      ]\n    ]);\n  });\n\n  // TODO (buntarb): This test doesn't have any sense anymore, because dbType\n  // property is deprecated and doesn't required in any mode. Need to be removed\n  test.skip('Should throw error, options are required (dev mode)', () => {\n    delete process.env.CUBEJS_API_SECRET;\n    process.env.CUBEJS_DEV_MODE = 'true';\n\n    expect(() => {\n      jest.spyOn(CubejsServerCoreOpen.prototype, 'isReadyForQueryProcessing').mockImplementation(() => true);\n      // eslint-disable-next-line\n      new CubejsServerCoreOpen({});\n      jest.restoreAllMocks();\n    })\n      .toThrowError(/dbType is required/);\n  });\n\n  test('Pass all required (dev mode) without apiSecret (should be autogenerated)', () => {\n    delete process.env.CUBEJS_API_SECRET;\n\n    process.env.CUBEJS_DEV_MODE = 'true';\n    process.env.CUBEJS_DB_TYPE = 'mysql';\n\n    expect(new CubejsServerCore({ jwt: { jwkUrl: 'https://test.com/j.json' } })).toBeInstanceOf(CubejsServerCore);\n  });\n\n  test('Should throw error, options are required (production mode)', () => {\n    delete process.env.CUBEJS_API_SECRET;\n    process.env.NODE_ENV = 'production';\n\n    expect(() => {\n      jest.spyOn(CubejsServerCoreOpen.prototype, 'isReadyForQueryProcessing').mockImplementation(() => true);\n      // eslint-disable-next-line\n      new CubejsServerCoreOpen({});\n      jest.restoreAllMocks();\n    })\n      .toThrowError('Either CUBEJS_DB_TYPE, CreateOptions.dbType or CreateOptions.driverFactory must be specified');\n  });\n\n  test('Should throw error, options are required (production mode with jwkUrl)', () => {\n    process.env.NODE_ENV = 'production';\n\n    expect(() => {\n      jest.spyOn(CubejsServerCoreOpen.prototype, 'isReadyForQueryProcessing').mockImplementation(() => true);\n      // eslint-disable-next-line\n      new CubejsServerCoreOpen({ jwt: { jwkUrl: 'https://test.com/j.json' } });\n      jest.restoreAllMocks();\n    })\n      .toThrowError('Either CUBEJS_DB_TYPE, CreateOptions.dbType or CreateOptions.driverFactory must be specified');\n  });\n\n  test('Pass all required props (production mode with JWK URL)', () => {\n    delete process.env.CUBEJS_API_SECRET;\n\n    process.env.NODE_ENV = 'production';\n    process.env.CUBEJS_DB_TYPE = 'mysql';\n\n    expect(new CubejsServerCore({ jwt: { jwkUrl: 'https://test.com/j.json' } })).toBeInstanceOf(CubejsServerCore);\n  });\n\n  test('Should not throw when the required options are missing in dev mode and no config file exists', () => {\n    expect(() => {\n      jest.spyOn(CubejsServerCoreOpen.prototype, 'isReadyForQueryProcessing').mockImplementation(() => false);\n      // eslint-disable-next-line\n      new CubejsServerCoreOpen({});\n      jest.restoreAllMocks();\n    })\n      .not.toThrow();\n  });\n\n  const expectRefreshTimerOption = (input, output, setProduction: boolean = false) => {\n    test(`scheduledRefreshTimer option ${input}`, async () => {\n      if (setProduction) {\n        process.env.NODE_ENV = 'production';\n      }\n\n      const cubejsServerCore = new CubejsServerCoreOpen({\n        dbType: 'mysql',\n        apiSecret: 'secret',\n        scheduledRefreshTimer: input\n      });\n      expect(cubejsServerCore).toBeInstanceOf(CubejsServerCore);\n      if (!cubejsServerCore.optsHandler.configuredForScheduledRefresh()) {\n        expect(output).toBeFalsy();\n      } else {\n        expect(\n          cubejsServerCore.optsHandler.getScheduledRefreshInterval()\n        ).toEqual(output);\n      }\n\n      await cubejsServerCore.beforeShutdown();\n      await cubejsServerCore.shutdown();\n    });\n  };\n\n  expectRefreshTimerOption(undefined, false);\n  expectRefreshTimerOption(false, false);\n  expectRefreshTimerOption(0, false);\n  expectRefreshTimerOption(1, 1000);\n  expectRefreshTimerOption(10, 10000);\n  expectRefreshTimerOption(true, 30000);\n\n  test('scheduledRefreshTimer is disabled with CUBEJS_REFRESH_WORKER', async () => {\n    process.env.CUBEJS_REFRESH_WORKER = 'false';\n\n    const cubejsServerCore = new CubejsServerCoreOpen({\n      dbType: 'mysql',\n      apiSecret: 'secret',\n    });\n    expect(cubejsServerCore).toBeInstanceOf(CubejsServerCore);\n    expect(cubejsServerCore.options.scheduledRefreshTimer).toBe(false);\n\n    await cubejsServerCore.beforeShutdown();\n    await cubejsServerCore.shutdown();\n  });\n\n  const testRefreshWorkerAndRollupModes = (\n    { setRefreshWorker, setScheduledRefresh, setScheduledRefreshTimer, testName, options }: {\n      setRefreshWorker?: boolean,\n      setScheduledRefresh?: boolean,\n      setScheduledRefreshTimer?: boolean | number,\n      testName?: string,\n      options?: CreateOptions\n    },\n    rollupOnlyMode: boolean,\n    assertFn: (options: OrchestratorApiOptions) => void,\n  ) => {\n    const paramsToName = JSON.stringify({\n      setRefreshWorker,\n      setScheduledRefresh,\n      setScheduledRefreshTimer,\n      rollupOnlyMode\n    });\n\n    test(testName || `scheduledRefreshTimer option setRefreshWorker: ${paramsToName})}`, async () => {\n      if (setRefreshWorker !== undefined) {\n        process.env.CUBEJS_REFRESH_WORKER = setRefreshWorker.toString();\n      }\n\n      if (setScheduledRefresh !== undefined) {\n        process.env.CUBEJS_SCHEDULED_REFRESH = setScheduledRefresh.toString();\n      }\n\n      if (setScheduledRefreshTimer !== undefined) {\n        process.env.CUBEJS_SCHEDULED_REFRESH_TIMER = setScheduledRefreshTimer.toString();\n      }\n\n      process.env.CUBEJS_ROLLUP_ONLY = rollupOnlyMode.toString();\n\n      const cubejsServerCore = new CubejsServerCoreOpen({\n        dbType: 'mysql',\n        apiSecret: 'secret',\n        ...options,\n      });\n      expect(cubejsServerCore).toBeInstanceOf(CubejsServerCore);\n\n      const createOrchestratorApiSpy = jest.spyOn(cubejsServerCore, 'createOrchestratorApi');\n\n      cubejsServerCore.getOrchestratorApi({\n        requestId: 'XXX',\n        authInfo: null,\n        securityContext: null,\n      });\n      expect(createOrchestratorApiSpy.mock.calls.length).toEqual(1);\n      assertFn(createOrchestratorApiSpy.mock.calls[0][1]);\n\n      createOrchestratorApiSpy.mockRestore();\n\n      await cubejsServerCore.beforeShutdown();\n      await cubejsServerCore.shutdown();\n    });\n  };\n\n  testRefreshWorkerAndRollupModes({ setRefreshWorker: true }, false, (options) => {\n    expect(options.preAggregationsOptions.externalRefresh).toEqual(false);\n    expect(options.rollupOnlyMode).toEqual(false);\n  });\n\n  testRefreshWorkerAndRollupModes({ setRefreshWorker: false }, true, (options) => {\n    expect(options.preAggregationsOptions.externalRefresh).toEqual(true);\n    expect(options.rollupOnlyMode).toEqual(true);\n  });\n\n  testRefreshWorkerAndRollupModes({ setRefreshWorker: true }, true, (options) => {\n    expect(options.rollupOnlyMode).toEqual(true);\n    // External refresh is enabled for rollupOnlyMode, but it's disabled\n    // when it's both refreshWorkerMode & rollupOnlyMode\n    expect(options.preAggregationsOptions.externalRefresh).toEqual(false);\n  });\n\n  // Old env, but anyway we should handle it\n  testRefreshWorkerAndRollupModes({ setScheduledRefresh: true }, true, (options) => {\n    expect(options.rollupOnlyMode).toEqual(true);\n    // External refresh is enabled for rollupOnlyMode, but it's disabled\n    // when it's both refreshWorkerMode & rollupOnlyMode\n    expect(options.preAggregationsOptions.externalRefresh).toEqual(false);\n  });\n\n  // Old env, but anyway we should handle it\n  testRefreshWorkerAndRollupModes({ setScheduledRefreshTimer: false }, true, (options) => {\n    expect(options.rollupOnlyMode).toEqual(true);\n    expect(options.preAggregationsOptions.externalRefresh).toEqual(true);\n  });\n\n  // Old env, but anyway we should handle it\n  testRefreshWorkerAndRollupModes({ setScheduledRefreshTimer: true }, true, (options) => {\n    expect(options.rollupOnlyMode).toEqual(true);\n    // External refresh is enabled for rollupOnlyMode, but it's disabled\n    // when it's both refreshWorkerMode & rollupOnlyMode\n    expect(options.preAggregationsOptions.externalRefresh).toEqual(false);\n  });\n\n  // Old env, but anyway we should handle it\n  testRefreshWorkerAndRollupModes({ setScheduledRefreshTimer: 30 }, true, (options) => {\n    expect(options.rollupOnlyMode).toEqual(true);\n    // External refresh is enabled for rollupOnlyMode, but it's disabled\n    // when it's both refreshWorkerMode & rollupOnlyMode\n    expect(options.preAggregationsOptions.externalRefresh).toEqual(false);\n  });\n\n  // Cube.js can override env\n  testRefreshWorkerAndRollupModes(\n    {\n      testName: 'Override scheduledRefreshTimer (true) & rollupOnlyMode from cube.js',\n      // cube.js\n      options: {\n        scheduledRefreshTimer: true,\n        orchestratorOptions: {\n          rollupOnlyMode: true,\n        }\n      }\n    },\n    false,\n    (options) => {\n      expect(options.rollupOnlyMode).toEqual(true);\n      // External refresh is enabled for rollupOnlyMode, but it's disabled\n      // when it's both refreshWorkerMode & rollupOnlyMode\n      expect(options.preAggregationsOptions.externalRefresh).toEqual(false);\n    }\n  );\n\n  // Cube.js can override env\n  testRefreshWorkerAndRollupModes(\n    {\n      testName: 'Override scheduledRefreshTimer (false) & rollupOnlyMode from cube.js',\n      // cube.js\n      options: {\n        scheduledRefreshTimer: false,\n        orchestratorOptions: {\n          rollupOnlyMode: true,\n        }\n      }\n    },\n    false,\n    (options) => {\n      expect(options.rollupOnlyMode).toEqual(true);\n      expect(options.preAggregationsOptions.externalRefresh).toEqual(true);\n    }\n  );\n\n  test('scheduledRefreshContexts option', async () => {\n    jest.spyOn(\n      CubejsServerCoreOpen.prototype,\n      'isReadyForQueryProcessing',\n    ).mockImplementation(\n      () => true,\n    );\n\n    const cubejsServerCore = new CubejsServerCoreOpen({\n      dbType: 'mysql',\n      apiSecret: 'secret',\n      // 250ms\n      scheduledRefreshTimer: 1,\n      scheduledRefreshConcurrency: 2,\n      scheduledRefreshContexts: async () => [\n        {\n          securityContext: {\n            appid: 'test1',\n            u: {\n              prop1: 'value1'\n            }\n          }\n        },\n        // securityContext is required in typings, but can be empty in user-space\n        <any>{\n          // Renamed to securityContext, let's test that it migrate automatically\n          authInfo: {\n            appid: 'test2',\n            u: {\n              prop2: 'value2'\n            }\n          },\n        },\n        // Null is a default placeholder\n        null\n      ],\n    });\n\n    const timeoutKiller = withTimeout(\n      () => {\n        throw new Error('runScheduledRefresh was not called');\n      },\n      2 * 1000,\n    );\n\n    const refreshSchedulerMock = {\n      runScheduledRefresh: jest.fn(async () => {\n        await timeoutKiller.cancel();\n        return {\n          finished: true,\n        };\n      })\n    };\n\n    jest.spyOn(cubejsServerCore, 'getRefreshScheduler').mockImplementation(() => <any>refreshSchedulerMock);\n\n    await timeoutKiller;\n\n    expect(cubejsServerCore).toBeInstanceOf(CubejsServerCoreOpen);\n    expect(refreshSchedulerMock.runScheduledRefresh.mock.calls.length).toEqual(3);\n    expect(refreshSchedulerMock.runScheduledRefresh.mock.calls[0]).toEqual([\n      {\n        authInfo: { appid: 'test1', u: { prop1: 'value1' } },\n        securityContext: { appid: 'test1', u: { prop1: 'value1' } },\n      },\n      { concurrency: 2 },\n    ]);\n    expect(refreshSchedulerMock.runScheduledRefresh.mock.calls[1]).toEqual([\n      {\n        authInfo: { appid: 'test2', u: { prop2: 'value2' } },\n        securityContext: { appid: 'test2', u: { prop2: 'value2' } },\n      },\n      { concurrency: 2 },\n    ]);\n    expect(refreshSchedulerMock.runScheduledRefresh.mock.calls[2]).toEqual([\n      // RefreshScheduler will populate it\n      null,\n      { concurrency: 2 },\n    ]);\n\n    await cubejsServerCore.beforeShutdown();\n    await cubejsServerCore.shutdown();\n\n    jest.restoreAllMocks();\n  });\n});\n"], "fixing_code": ["/* eslint-disable no-restricted-syntax */\nimport jwt, { Algorithm as JWTAlgorithm } from 'jsonwebtoken';\nimport R from 'ramda';\nimport bodyParser from 'body-parser';\nimport { graphqlHTTP } from 'express-graphql';\nimport structuredClone from '@ungap/structured-clone';\nimport {\n  getEnv,\n  getRealType,\n  QueryAlias,\n} from '@cubejs-backend/shared';\nimport type {\n  Application as ExpressApplication,\n  ErrorRequestHandler,\n  NextFunction,\n  RequestHandler,\n  Response,\n} from 'express';\nimport {\n  QueryType\n} from './types/strings';\nimport {\n  QueryType as QueryTypeEnum, ResultType\n} from './types/enums';\nimport {\n  RequestContext,\n  ExtendedRequestContext,\n  Request,\n  QueryRewriteFn,\n  SecurityContextExtractorFn,\n  ExtendContextFn,\n  ResponseResultFn,\n  QueryRequest,\n  PreAggsJobsRequest,\n  PreAggsSelector,\n  PreAggJob,\n  PreAggJobStatusItem,\n  PreAggJobStatusObject,\n  PreAggJobStatusResponse,\n} from './types/request';\nimport {\n  CheckAuthInternalOptions,\n  JWTOptions,\n  CheckAuthFn,\n} from './types/auth';\nimport {\n  Query,\n  NormalizedQuery,\n} from './types/query';\nimport {\n  UserBackgroundContext,\n  ApiGatewayOptions,\n} from './types/gateway';\nimport {\n  CheckAuthMiddlewareFn,\n  RequestLoggerMiddlewareFn,\n} from './interfaces';\nimport { getRequestIdFromRequest, requestParser } from './requestParser';\nimport { UserError } from './UserError';\nimport { CubejsHandlerError } from './CubejsHandlerError';\nimport { SubscriptionServer, WebSocketSendMessageFn } from './SubscriptionServer';\nimport { LocalSubscriptionStore } from './LocalSubscriptionStore';\nimport {\n  getPivotQuery,\n  getQueryGranularity,\n  normalizeQuery,\n  normalizeQueryCancelPreAggregations,\n  normalizeQueryPreAggregationPreview,\n  normalizeQueryPreAggregations,\n  validatePostRewrite,\n} from './query';\nimport { cachedHandler } from './cached-handler';\nimport { createJWKsFetcher } from './jwk';\nimport { SQLServer } from './sql-server';\nimport { makeSchema } from './graphql';\nimport { ConfigItem, prepareAnnotation } from './helpers/prepareAnnotation';\nimport transformData from './helpers/transformData';\nimport {\n  transformCube,\n  transformMeasure,\n  transformDimension,\n  transformSegment,\n  transformJoins,\n  transformPreAggregations,\n} from './helpers/transformMetaExtended';\n\n// const timeoutPromise = (timeout) => (\n//   new Promise((resolve) => (\n//     setTimeout(\n//       () => resolve(null),\n//       timeout,\n//     )\n//   ))\n// );\n\n/**\n * API gateway server class.\n */\nclass ApiGateway {\n  protected readonly refreshScheduler: any;\n\n  protected readonly scheduledRefreshContexts: ApiGatewayOptions['scheduledRefreshContexts'];\n\n  protected readonly scheduledRefreshTimeZones: ApiGatewayOptions['scheduledRefreshTimeZones'];\n\n  protected readonly basePath: string;\n\n  protected readonly queryRewrite: QueryRewriteFn;\n\n  protected readonly subscriptionStore: any;\n\n  protected readonly enforceSecurityChecks: boolean;\n\n  protected readonly standalone: boolean;\n\n  protected readonly extendContext?: ExtendContextFn;\n\n  protected readonly dataSourceStorage: any;\n\n  public readonly checkAuthFn: CheckAuthFn;\n\n  public readonly checkAuthSystemFn: CheckAuthFn;\n\n  protected readonly checkAuthMiddleware: CheckAuthMiddlewareFn;\n\n  protected readonly requestLoggerMiddleware: RequestLoggerMiddlewareFn;\n\n  protected readonly securityContextExtractor: SecurityContextExtractorFn;\n\n  protected readonly releaseListeners: (() => any)[] = [];\n\n  protected readonly playgroundAuthSecret?: string;\n\n  public constructor(\n    protected readonly apiSecret: string,\n    protected readonly compilerApi: any,\n    protected readonly adapterApi: any,\n    protected readonly logger: any,\n    protected readonly options: ApiGatewayOptions,\n  ) {\n    this.dataSourceStorage = options.dataSourceStorage;\n    this.refreshScheduler = options.refreshScheduler;\n    this.scheduledRefreshContexts = options.scheduledRefreshContexts;\n    this.scheduledRefreshTimeZones = options.scheduledRefreshTimeZones;\n    this.standalone = options.standalone;\n    this.basePath = options.basePath;\n    this.playgroundAuthSecret = options.playgroundAuthSecret;\n\n    this.queryRewrite = options.queryRewrite || (async (query) => query);\n    this.subscriptionStore = options.subscriptionStore || new LocalSubscriptionStore();\n    this.enforceSecurityChecks = options.enforceSecurityChecks || (process.env.NODE_ENV === 'production');\n    this.extendContext = options.extendContext;\n\n    this.checkAuthFn = this.createCheckAuthFn(options);\n    this.checkAuthSystemFn = this.createCheckAuthSystemFn();\n    this.checkAuthMiddleware = options.checkAuthMiddleware\n      ? this.wrapCheckAuthMiddleware(options.checkAuthMiddleware)\n      : this.checkAuth;\n    this.securityContextExtractor = this.createSecurityContextExtractor(options.jwt);\n    this.requestLoggerMiddleware = options.requestLoggerMiddleware || this.requestLogger;\n  }\n\n  public initApp(app: ExpressApplication) {\n    const userMiddlewares: RequestHandler[] = [\n      this.checkAuthMiddleware,\n      this.requestContextMiddleware,\n      this.logNetworkUsage,\n      this.requestLoggerMiddleware\n    ];\n\n    // @todo Should we pass requestLoggerMiddleware?\n    const guestMiddlewares = [];\n\n    app.use(`${this.basePath}/graphql`, userMiddlewares, async (req, res) => {\n      const compilerApi = this.getCompilerApi(req.context);\n      let schema = compilerApi.getGraphQLSchema();\n      if (!schema) {\n        let metaConfig = await compilerApi.metaConfig({\n          requestId: req.context.requestId,\n        });\n        metaConfig = this.filterVisibleItemsInMeta(req.context, metaConfig);\n        schema = makeSchema(metaConfig);\n        compilerApi.setGraphQLSchema(schema);\n      }\n\n      return graphqlHTTP({\n        schema,\n        context: {\n          req,\n          apiGateway: this\n        },\n        graphiql: getEnv('nodeEnv') !== 'production' ? { headerEditorEnabled: true } : false,\n      })(req, res);\n    });\n\n    app.get(`${this.basePath}/v1/load`, userMiddlewares, (async (req, res) => {\n      await this.load({\n        query: req.query.query,\n        context: req.context,\n        res: this.resToResultFn(res),\n        queryType: req.query.queryType,\n      });\n    }));\n\n    const jsonParser = bodyParser.json({ limit: '1mb' });\n    app.post(`${this.basePath}/v1/load`, jsonParser, userMiddlewares, (async (req, res) => {\n      await this.load({\n        query: req.body.query,\n        context: req.context,\n        res: this.resToResultFn(res),\n        queryType: req.body.queryType\n      });\n    }));\n\n    app.get(`${this.basePath}/v1/subscribe`, userMiddlewares, (async (req, res) => {\n      await this.load({\n        query: req.query.query,\n        context: req.context,\n        res: this.resToResultFn(res),\n        queryType: req.query.queryType\n      });\n    }));\n\n    app.get(`${this.basePath}/v1/sql`, userMiddlewares, (async (req, res) => {\n      await this.sql({\n        query: req.query.query,\n        context: req.context,\n        res: this.resToResultFn(res)\n      });\n    }));\n\n    app.post(`${this.basePath}/v1/sql`, userMiddlewares, (async (req, res) => {\n      await this.sql({\n        query: req.body.query,\n        context: req.context,\n        res: this.resToResultFn(res)\n      });\n    }));\n\n    app.get(`${this.basePath}/v1/meta`, userMiddlewares, (async (req, res) => {\n      if (req.query.hasOwnProperty('extended')) {\n        await this.metaExtended({\n          context: req.context,\n          res: this.resToResultFn(res),\n        });\n      } else {\n        await this.meta({\n          context: req.context,\n          res: this.resToResultFn(res),\n        });\n      }\n    }));\n\n    app.get(`${this.basePath}/v1/run-scheduled-refresh`, userMiddlewares, (async (req, res) => {\n      await this.runScheduledRefresh({\n        queryingOptions: req.query.queryingOptions,\n        context: req.context,\n        res: this.resToResultFn(res)\n      });\n    }));\n\n    app.get(`${this.basePath}/v1/dry-run`, userMiddlewares, (async (req, res) => {\n      await this.dryRun({\n        query: req.query.query,\n        context: req.context,\n        res: this.resToResultFn(res)\n      });\n    }));\n\n    app.post(`${this.basePath}/v1/dry-run`, jsonParser, userMiddlewares, (async (req, res) => {\n      await this.dryRun({\n        query: req.body.query,\n        context: req.context,\n        res: this.resToResultFn(res)\n      });\n    }));\n\n    if (this.playgroundAuthSecret) {\n      const systemMiddlewares: RequestHandler[] = [\n        this.checkAuthSystemMiddleware,\n        this.requestContextMiddleware,\n        this.requestLoggerMiddleware\n      ];\n\n      app.get('/cubejs-system/v1/context', systemMiddlewares, this.createSystemContextHandler(this.basePath));\n\n      app.get('/cubejs-system/v1/pre-aggregations', systemMiddlewares, (async (req, res) => {\n        await this.getPreAggregations({\n          cacheOnly: req.query.cacheOnly,\n          context: req.context,\n          res: this.resToResultFn(res)\n        });\n      }));\n\n      app.get('/cubejs-system/v1/pre-aggregations/security-contexts', systemMiddlewares, (async (req, res) => {\n        const contexts = this.scheduledRefreshContexts ? await this.scheduledRefreshContexts() : [];\n        this.resToResultFn(res)({\n          securityContexts: contexts\n            .map(ctx => ctx && (ctx.securityContext || ctx.authInfo))\n            .filter(ctx => ctx)\n        });\n      }));\n\n      app.get('/cubejs-system/v1/pre-aggregations/timezones', systemMiddlewares, (async (req, res) => {\n        this.resToResultFn(res)({\n          timezones: this.scheduledRefreshTimeZones || []\n        });\n      }));\n\n      app.post('/cubejs-system/v1/pre-aggregations/partitions', jsonParser, systemMiddlewares, (async (req, res) => {\n        await this.getPreAggregationPartitions({\n          query: req.body.query,\n          context: req.context,\n          res: this.resToResultFn(res)\n        });\n      }));\n\n      app.post('/cubejs-system/v1/pre-aggregations/preview', jsonParser, systemMiddlewares, (async (req, res) => {\n        await this.getPreAggregationPreview({\n          query: req.body.query,\n          context: req.context,\n          res: this.resToResultFn(res)\n        });\n      }));\n\n      app.post('/cubejs-system/v1/pre-aggregations/build', jsonParser, systemMiddlewares, (async (req, res) => {\n        await this.buildPreAggregations({\n          query: req.body.query,\n          context: req.context,\n          res: this.resToResultFn(res)\n        });\n      }));\n\n      app.post('/cubejs-system/v1/pre-aggregations/queue', jsonParser, systemMiddlewares, (async (req, res) => {\n        await this.getPreAggregationsInQueue({\n          context: req.context,\n          res: this.resToResultFn(res)\n        });\n      }));\n\n      app.post('/cubejs-system/v1/pre-aggregations/cancel', jsonParser, systemMiddlewares, (async (req, res) => {\n        await this.cancelPreAggregationsFromQueue({\n          query: req.body.query,\n          context: req.context,\n          res: this.resToResultFn(res)\n        });\n      }));\n\n      app.post(\n        '/cubejs-system/v1/pre-aggregations/jobs',\n        userMiddlewares,\n        this.preAggregationsJobs.bind(this),\n      );\n    }\n\n    app.get('/readyz', guestMiddlewares, cachedHandler(this.readiness));\n    app.get('/livez', guestMiddlewares, cachedHandler(this.liveness));\n\n    app.post(`${this.basePath}/v1/pre-aggregations/can-use`, userMiddlewares, (req: Request, res: Response) => {\n      const { transformedQuery, references } = req.body;\n\n      const canUsePreAggregationForTransformedQuery = this.compilerApi(req.context)\n        .canUsePreAggregationForTransformedQuery(transformedQuery, references);\n\n      res.json({ canUsePreAggregationForTransformedQuery });\n    });\n\n    app.use(this.handleErrorMiddleware);\n  }\n\n  public initSQLServer() {\n    return new SQLServer(this);\n  }\n\n  public initSubscriptionServer(sendMessage: WebSocketSendMessageFn) {\n    return new SubscriptionServer(this, sendMessage, this.subscriptionStore);\n  }\n\n  protected duration(requestStarted) {\n    return requestStarted && (new Date().getTime() - requestStarted.getTime());\n  }\n\n  public async runScheduledRefresh({ context, res, queryingOptions }: {\n    context: RequestContext,\n    res: ResponseResultFn,\n    queryingOptions: any\n  }) {\n    const requestStarted = new Date();\n    try {\n      const refreshScheduler = this.refreshScheduler();\n      res(await refreshScheduler.runScheduledRefresh(context, {\n        ...this.parseQueryParam(queryingOptions || {}),\n        throwErrors: true\n      }));\n    } catch (e) {\n      this.handleError({\n        e, context, res, requestStarted\n      });\n    }\n  }\n\n  private filterVisibleItemsInMeta(_context: RequestContext, metaConfig: any) {\n    function visibilityFilter(item) {\n      // Hidden items shouldn't be accessible through API everywhere for consistency.\n      return item.isVisible;\n    }\n\n    return metaConfig\n      .map((cube) => ({\n        config: {\n          ...cube.config,\n          measures: cube.config.measures?.filter(visibilityFilter),\n          dimensions: cube.config.dimensions?.filter(visibilityFilter),\n          segments: cube.config.segments?.filter(visibilityFilter),\n        },\n      })).filter(cube => cube.config.measures?.length || cube.config.dimensions?.length || cube.config.segments?.length);\n  }\n\n  public async meta({ context, res }: { context: RequestContext, res: ResponseResultFn }) {\n    const requestStarted = new Date();\n\n    try {\n      const metaConfig = await this.getCompilerApi(context).metaConfig({\n        requestId: context.requestId,\n      });\n      const cubes = this.filterVisibleItemsInMeta(context, metaConfig).map(cube => cube.config);\n      res({ cubes });\n    } catch (e) {\n      this.handleError({\n        e,\n        context,\n        res,\n        requestStarted,\n      });\n    }\n  }\n\n  public async metaExtended({ context, res }: { context: RequestContext, res: ResponseResultFn }) {\n    const requestStarted = new Date();\n\n    // TODO: test and remove this function.\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    function visibilityFilter(item) {\n      return getEnv('devMode') || context.signedWithPlaygroundAuthSecret || item.isVisible;\n    }\n\n    try {\n      const metaConfigExtended = await this.getCompilerApi(context).metaConfigExtended({\n        requestId: context.requestId,\n      });\n      const { metaConfig, cubeDefinitions } = metaConfigExtended;\n\n      const cubes = this.filterVisibleItemsInMeta(context, metaConfig)\n        .map((meta) => meta.config)\n        .map((cube) => ({\n          ...transformCube(cube, cubeDefinitions),\n          measures: cube.measures?.map((measure) => ({\n            ...transformMeasure(measure, cubeDefinitions),\n          })),\n          dimensions: cube.dimensions?.map((dimension) => ({\n            ...transformDimension(dimension, cubeDefinitions),\n          })),\n          segments: cube.segments?.map((segment) => ({\n            ...transformSegment(segment, cubeDefinitions),\n          })),\n          joins: transformJoins(cubeDefinitions[cube.name]?.joins),\n          preAggregations: transformPreAggregations(cubeDefinitions[cube.name]?.preAggregations),\n        }));\n      res({ cubes });\n    } catch (e) {\n      this.handleError({\n        e,\n        context,\n        res,\n        requestStarted,\n      });\n    }\n  }\n\n  public async getPreAggregations({ cacheOnly, context, res }: { cacheOnly?: boolean, context: RequestContext, res: ResponseResultFn }) {\n    const requestStarted = new Date();\n    try {\n      const compilerApi = this.getCompilerApi(context);\n      const preAggregations = await compilerApi.preAggregations();\n\n      const preAggregationPartitions = await this.refreshScheduler()\n        .preAggregationPartitions(\n          context,\n          normalizeQueryPreAggregations(\n            {\n              timezones: this.scheduledRefreshTimeZones,\n              preAggregations: preAggregations.map(p => ({\n                id: p.id,\n                cacheOnly,\n              }))\n            },\n          )\n        );\n\n      res({ preAggregations: preAggregationPartitions.map(({ preAggregation }) => preAggregation) });\n    } catch (e) {\n      this.handleError({\n        e, context, res, requestStarted\n      });\n    }\n  }\n\n  public async getPreAggregationPartitions(\n    { query, context, res }: { query: any, context: RequestContext, res: ResponseResultFn }\n  ) {\n    const requestStarted = new Date();\n    try {\n      query = normalizeQueryPreAggregations(\n        this.parseQueryParam(query),\n        { timezones: this.scheduledRefreshTimeZones }\n      );\n      const orchestratorApi = this.getAdapterApi(context);\n      const compilerApi = this.getCompilerApi(context);\n\n      const preAggregationPartitions = await this.refreshScheduler()\n        .preAggregationPartitions(\n          context,\n          query\n        );\n\n      const preAggregationPartitionsWithoutError = preAggregationPartitions.filter(p => !p?.errors?.length);\n\n      const versionEntriesResult = preAggregationPartitions &&\n        await orchestratorApi.getPreAggregationVersionEntries(\n          context,\n          preAggregationPartitionsWithoutError,\n          compilerApi.preAggregationsSchema\n        );\n\n      const mergePartitionsAndVersionEntries = () => ({ preAggregation, partitions, ...props }) => ({\n        ...props,\n        preAggregation,\n        partitions: partitions.map(partition => {\n          partition.versionEntries = versionEntriesResult?.versionEntriesByTableName[partition?.tableName] || [];\n          partition.structureVersion = versionEntriesResult?.structureVersionsByTableName[partition?.tableName];\n          return partition;\n        }),\n      });\n\n      res({\n        preAggregationPartitions: preAggregationPartitions.map(mergePartitionsAndVersionEntries())\n      });\n    } catch (e) {\n      this.handleError({\n        e, context, res, requestStarted\n      });\n    }\n  }\n\n  public async getPreAggregationPreview(\n    { query, context, res }: { query: any, context: RequestContext, res: ResponseResultFn }\n  ) {\n    const requestStarted = new Date();\n    try {\n      query = normalizeQueryPreAggregationPreview(this.parseQueryParam(query));\n      const { preAggregationId, versionEntry, timezone } = query;\n\n      const orchestratorApi = this.getAdapterApi(context);\n\n      const preAggregationPartitions = await this.refreshScheduler()\n        .preAggregationPartitions(\n          context,\n          {\n            timezones: [timezone],\n            preAggregations: [{ id: preAggregationId }]\n          }\n        );\n      const { partitions } = (preAggregationPartitions && preAggregationPartitions[0] || {});\n      const preAggregationPartition = partitions && partitions.find(p => p?.tableName === versionEntry.table_name);\n\n      res({\n        preview: preAggregationPartition && await orchestratorApi.getPreAggregationPreview(\n          context,\n          preAggregationPartition\n        )\n      });\n    } catch (e) {\n      this.handleError({\n        e, context, res, requestStarted\n      });\n    }\n  }\n\n  public async buildPreAggregations(\n    { query, context, res }: { query: any, context: RequestContext, res: ResponseResultFn }\n  ) {\n    const requestStarted = new Date();\n    try {\n      query = normalizeQueryPreAggregations(this.parseQueryParam(query));\n      const result = await this.refreshScheduler()\n        .buildPreAggregations(\n          context,\n          query\n        );\n\n      res({ result });\n    } catch (e) {\n      this.handleError({\n        e, context, res, requestStarted\n      });\n    }\n  }\n\n  /**\n   * Entry point for the `/cubejs-system/v1/pre-aggregations/jobs` endpoint.\n   * Post object example:\n   * ```\n   * {\n   *   \"action\": \"post\",\n   *   \"selector\": {\n   *     \"contexts\": [\n   *       {\"securityContext\": {\"tenant\": \"t1\"}},\n   *       {\"securityContext\": {\"tenant\": \"t2\"}}\n   *     ],\n   *     \"timezones\": [\"UTC\"],\n   *     \"dataSources\": [\"default\"],\n   *     \"cubes\": [\"Events\"],\n   *     \"preAggregations\": [\"Events.TemporaryData\"]\n   *   }\n   * }\n   * // or\n   * {\n   *   \"action\": \"get\",\n   *   \"tokens\": [\n   *     \"ec1232ea3356f04f8be313fecf3deb4d\",\n   *     \"48b75d5c466fa579c936dc451f498f69\",\n   *     \"76509837091396dc204abb1016c48e75\",\n   *     \"52264769f81f6ff62062a93d6f6fbdb2\"\n   *   ]\n   * }\n   * // or\n   * {\n   *   \"action\": \"get\",\n   *   \"resType\": \"object\",\n   *   \"tokens\": [\n   *     \"ec1232ea3356f04f8be313fecf3deb4d\",\n   *     \"48b75d5c466fa579c936dc451f498f69\",\n   *     \"76509837091396dc204abb1016c48e75\",\n   *     \"52264769f81f6ff62062a93d6f6fbdb2\"\n   *   ]\n   * }\n   * ```\n   * TODO (buntarb): selector object validator.\n   */\n  private async preAggregationsJobs(req: Request, res: Response) {\n    const response = this.resToResultFn(res);\n    const started = new Date();\n    const context = <RequestContext>req.context;\n    const query = <PreAggsJobsRequest>req.body;\n    try {\n      let result;\n      switch (query.action) {\n        case 'post':\n          if (\n            !(<PreAggsSelector>query.selector).timezones ||\n            (<PreAggsSelector>query.selector).timezones.length === 0\n          ) {\n            throw new UserError(\n              'A user\\'s selector must contain at least one time zone.'\n            );\n          }\n          if (\n            !(<PreAggsSelector>query.selector).contexts ||\n            (\n              <{securityContext: any}[]>(\n                <PreAggsSelector>query.selector\n              ).contexts\n            ).length === 0\n          ) {\n            throw new UserError(\n              'A user\\'s selector must contain at least one context element.'\n            );\n          } else {\n            let e = false;\n            (<{securityContext: any}[]>(\n              <PreAggsSelector>query.selector\n            ).contexts).forEach((c) => {\n              if (!c.securityContext) e = true;\n            });\n            if (e) {\n              throw new UserError(\n                'Every context element must contain the ' +\n                '\\'securityContext\\' property.'\n              );\n            }\n          }\n          result = await this.preAggregationsJobsPOST(\n            context,\n            <PreAggsSelector>query.selector\n          );\n          if (result.length === 0) {\n            throw new UserError(\n              'A user\\'s selector doesn\\'t match any of the ' +\n              'pre-aggregations described by the Cube schemas.'\n            );\n          }\n          break;\n        case 'get':\n          result = await this.preAggregationsJobsGET(\n            context,\n            <string[]>query.tokens,\n            query.resType,\n          );\n          break;\n        default:\n          throw new Error(`The '${query.action}' action type doesn't supported.`);\n      }\n      response(result, { status: 200 });\n    } catch (e) {\n      this.handleError({ e, context, query, res: response, started });\n    }\n  }\n\n  /**\n   * Post pre-aggregations build jobs entry point.\n   */\n  private async preAggregationsJobsPOST(\n    context: RequestContext,\n    selector: PreAggsSelector,\n  ): Promise<string[]> {\n    let jobs: string[] = [];\n    if (!selector.contexts?.length) {\n      jobs = await this.postPreAggregationsBuildJobs(\n        context,\n        selector,\n      );\n    } else {\n      const promise = Promise.all(\n        selector.contexts.map(async (config) => {\n          const ctx = <RequestContext>{\n            ...context,\n            ...config,\n          };\n          const _jobs = await this.postPreAggregationsBuildJobs(\n            ctx,\n            selector,\n          );\n          return _jobs;\n        })\n      );\n      const resolve = await promise;\n      resolve.forEach((_jobs) => {\n        jobs = jobs.concat(_jobs);\n      });\n    }\n    return jobs;\n  }\n\n  /**\n   * Add pre-aggregations build job. Returns added jobs ids.\n   */\n  private async postPreAggregationsBuildJobs(\n    context: RequestContext,\n    selector: PreAggsSelector\n  ): Promise<string[]> {\n    const compiler = this.getCompilerApi(context);\n    const { timezones } = selector;\n    const preaggs = await compiler.preAggregations({\n      dataSources: selector.dataSources,\n      cubes: selector.cubes,\n      preAggregationIds: selector.preAggregations,\n    });\n    if (preaggs.length === 0) {\n      return [];\n    } else {\n      const jobs: string[] = await this\n        .refreshScheduler()\n        .postBuildJobs(\n          context,\n          {\n            metadata: undefined,\n            timezones,\n            preAggregations: preaggs.map(p => ({\n              id: p.id,\n              cacheOnly: undefined, // boolean\n              partitions: undefined, // string[]\n            })),\n            forceBuildPreAggregations: undefined,\n            throwErrors: false,\n          }\n        );\n      return jobs;\n    }\n  }\n\n  /**\n   * Get pre-aggregations build jobs entry point.\n   */\n  private async preAggregationsJobsGET(\n    context: RequestContext,\n    tokens: string[],\n    resType = 'array',\n  ): Promise<PreAggJobStatusResponse> {\n    const objResponse: PreAggJobStatusObject = {};\n    const selector: PreAggJob[] = await this\n      .refreshScheduler()\n      .getCachedBuildJobs(context, tokens);\n    const metaCache: Map<string, any> = new Map();\n    const promise: Promise<(PreAggJobStatusItem | undefined)[]> = Promise.all(\n      selector.map(async (selected, i) => {\n        const ctx = { ...context, ...selected.context };\n        const orchestrator = this.getAdapterApi(ctx);\n        const compiler = this.getCompilerApi(ctx);\n        const sel: PreAggsSelector = {\n          cubes: [selected.preagg.split('.')[0]],\n          preAggregations: [selected.preagg],\n          contexts: [selected.context],\n          timezones: [selected.timezone],\n          dataSources: [selected.dataSource],\n        };\n        if (\n          selected.status.indexOf('done') === 0 ||\n          selected.status.indexOf('failure') === 0\n        ) {\n          // returning from the cache\n          if (resType === 'object') {\n            objResponse[tokens[i]] = {\n              table: selected.target,\n              status: selected.status,\n              selector: sel,\n            };\n          } else {\n            return {\n              token: tokens[i],\n              table: selected.target,\n              status: selected.status,\n              selector: sel,\n            };\n          }\n        } else {\n          // checking the queue\n          const status = await this.getPreAggJobQueueStatus(\n            orchestrator,\n            selected,\n          );\n          if (status) {\n            // returning queued status\n            if (resType === 'object') {\n              objResponse[tokens[i]] = {\n                table: selected.target,\n                status,\n                selector: sel,\n              };\n            } else {\n              return {\n                token: tokens[i],\n                table: selected.target,\n                status,\n                selector: sel,\n              };\n            }\n          } else {\n            const key = JSON.stringify(ctx);\n            if (!metaCache.has(key)) {\n              metaCache.set(key, await compiler.metaConfigExtended(ctx));\n            }\n            // checking and fetching result status\n            const s = await this.getPreAggJobResultStatus(\n              ctx.requestId,\n              orchestrator,\n              compiler,\n              metaCache.get(key),\n              selected,\n              tokens[i],\n            );\n            if (resType === 'object') {\n              objResponse[tokens[i]] = {\n                table: selected.target,\n                status: s,\n                selector: sel,\n              };\n            } else {\n              return {\n                token: tokens[i],\n                table: selected.target,\n                status: s,\n                selector: sel,\n              };\n            }\n          }\n        }\n        return undefined;\n      })\n    );\n    const arrResponse: (PreAggJobStatusItem | undefined)[] = await promise;\n    return resType === 'object'\n      ? objResponse\n      : <PreAggJobStatusItem[]>arrResponse;\n  }\n\n  /**\n   * Returns PreAggJob status if it still in queue, false otherwose.\n   */\n  private async getPreAggJobQueueStatus(\n    orchestrator: any,\n    job: PreAggJob,\n  ): Promise<false | string> {\n    let inQueue = false;\n    let status: string = 'n/a';\n    const queuedList = await orchestrator.getPreAggregationQueueStates();\n    queuedList.forEach((item) => {\n      if (\n        item.queryHandler &&\n        item.queryHandler === 'query' &&\n        item.query &&\n        item.query.requestId === job.request &&\n        item.query.newVersionEntry.table_name === job.table &&\n        item.query.newVersionEntry.structure_version === job.structure &&\n        item.query.newVersionEntry.content_version === job.content &&\n        item.query.newVersionEntry.last_updated_at === job.updated\n      ) {\n        inQueue = true;\n        switch (<string>item.status[0]) {\n          case 'toProcess':\n            status = 'scheduled';\n            break;\n          case 'active':\n            status = 'processing';\n            break;\n          default:\n            status = <string>item.status[0];\n            break;\n        }\n      }\n    });\n    return inQueue ? status : false;\n  }\n\n  /**\n   * Returns PreAggJob execution status.\n   */\n  private async getPreAggJobResultStatus(\n    requestId: string,\n    orchestrator: any,\n    compiler: any,\n    metadata: any,\n    job: PreAggJob,\n    token: string,\n  ): Promise<string> {\n    const preaggs = await compiler.preAggregations();\n    const preagg = preaggs.filter(pa => pa.id === job.preagg)[0];\n    const cube = metadata.cubeDefinitions[preagg.cube];\n    const [, status]: [boolean, string] =\n      await orchestrator.isPartitionExist(\n        requestId,\n        preagg.preAggregation.external,\n        cube.dataSource,\n        compiler.preAggregationsSchema,\n        job.target,\n        job.key,\n        token,\n      );\n    return status;\n  }\n\n  public async getPreAggregationsInQueue(\n    { context, res }: { context: RequestContext, res: ResponseResultFn }\n  ) {\n    const requestStarted = new Date();\n    try {\n      const orchestratorApi = this.getAdapterApi(context);\n      res({\n        result: await orchestratorApi.getPreAggregationQueueStates()\n      });\n    } catch (e) {\n      this.handleError({\n        e, context, res, requestStarted\n      });\n    }\n  }\n\n  public async cancelPreAggregationsFromQueue(\n    { query, context, res }: { query: any, context: RequestContext, res: ResponseResultFn }\n  ) {\n    const requestStarted = new Date();\n    try {\n      const { queryKeys, dataSource } = normalizeQueryCancelPreAggregations(this.parseQueryParam(query));\n      const orchestratorApi = this.getAdapterApi(context);\n      res({\n        result: await orchestratorApi.cancelPreAggregationQueriesFromQueue(queryKeys, dataSource)\n      });\n    } catch (e) {\n      this.handleError({\n        e, context, res, requestStarted\n      });\n    }\n  }\n\n  /**\n   * Convert incoming query parameter (JSON fetched from the HTTP) to\n   * an array of query type and array of normalized queries.\n   */\n  protected async getNormalizedQueries(\n    query: Record<string, any> | Record<string, any>[],\n    context: RequestContext,\n  ): Promise<[QueryType, NormalizedQuery[]]> {\n    query = this.parseQueryParam(query);\n    let queryType: QueryType = QueryTypeEnum.REGULAR_QUERY;\n\n    if (!Array.isArray(query)) {\n      query = this.compareDateRangeTransformer(query);\n      if (Array.isArray(query)) {\n        queryType = QueryTypeEnum.COMPARE_DATE_RANGE_QUERY;\n      }\n    } else {\n      queryType = QueryTypeEnum.BLENDING_QUERY;\n    }\n\n    const queries = Array.isArray(query) ? query : [query];\n    const normalizedQueries: NormalizedQuery[] = await Promise.all(\n      queries.map(\n        async (currentQuery) => validatePostRewrite(\n          await this.queryRewrite(\n            normalizeQuery(currentQuery),\n            context\n          )\n        )\n      )\n    );\n\n    if (normalizedQueries.find((currentQuery) => !currentQuery)) {\n      throw new Error('queryTransformer returned null query. Please check your queryTransformer implementation');\n    }\n\n    if (queryType === QueryTypeEnum.BLENDING_QUERY) {\n      const queryGranularity = getQueryGranularity(normalizedQueries);\n\n      if (queryGranularity.length > 1) {\n        throw new UserError('Data blending query granularities must match');\n      }\n      if (queryGranularity.filter(Boolean).length === 0) {\n        throw new UserError('Data blending query without granularity is not supported');\n      }\n    }\n\n    return [queryType, normalizedQueries];\n  }\n\n  public async sql({ query, context, res }: QueryRequest) {\n    const requestStarted = new Date();\n\n    try {\n      query = this.parseQueryParam(query);\n      const [queryType, normalizedQueries] = await this.getNormalizedQueries(query, context);\n\n      const sqlQueries = await Promise.all<any>(\n        normalizedQueries.map((normalizedQuery) => this.getCompilerApi(context).getSql(\n          this.coerceForSqlQuery(normalizedQuery, context),\n          { includeDebugInfo: getEnv('devMode') || context.signedWithPlaygroundAuthSecret }\n        ))\n      );\n\n      const toQuery = (sqlQuery) => ({\n        ...sqlQuery,\n        order: R.fromPairs(sqlQuery.order.map(({ id: key, desc }) => [key, desc ? 'desc' : 'asc']))\n      });\n\n      res(queryType === QueryTypeEnum.REGULAR_QUERY ?\n        { sql: toQuery(sqlQueries[0]) } :\n        sqlQueries.map((sqlQuery) => ({ sql: toQuery(sqlQuery) })));\n    } catch (e) {\n      this.handleError({\n        e, context, query, res, requestStarted\n      });\n    }\n  }\n\n  protected createSecurityContextExtractor(options?: JWTOptions): SecurityContextExtractorFn {\n    if (options?.claimsNamespace) {\n      return (ctx: Readonly<RequestContext>) => {\n        if (typeof ctx.securityContext === 'object' && ctx.securityContext !== null) {\n          if (<string>options.claimsNamespace in ctx.securityContext) {\n            return ctx.securityContext[<string>options.claimsNamespace];\n          }\n        }\n\n        return {};\n      };\n    }\n\n    let checkAuthDeprecationShown: boolean = false;\n\n    return (ctx: Readonly<RequestContext>) => {\n      let securityContext: any = {};\n\n      if (typeof ctx.securityContext === 'object' && ctx.securityContext !== null) {\n        if (ctx.securityContext.u) {\n          if (!checkAuthDeprecationShown) {\n            this.logger('JWT U Property Deprecation', {\n              warning: (\n                'Storing security context in the u property within the payload is now deprecated, please migrate: ' +\n                'https://github.com/cube-js/cube.js/blob/master/DEPRECATION.md#authinfo'\n              )\n            });\n\n            checkAuthDeprecationShown = true;\n          }\n\n          securityContext = {\n            ...ctx.securityContext,\n            ...ctx.securityContext.u,\n          };\n\n          delete securityContext.u;\n        } else {\n          securityContext = ctx.securityContext;\n        }\n      }\n\n      return securityContext;\n    };\n  }\n\n  protected coerceForSqlQuery(query, context: Readonly<RequestContext>) {\n    return {\n      ...query,\n      timeDimensions: query.timeDimensions || [],\n      contextSymbols: {\n        securityContext: this.securityContextExtractor(context),\n      },\n      requestId: context.requestId\n    };\n  }\n\n  protected async dryRun({ query, context, res }: QueryRequest) {\n    const requestStarted = new Date();\n\n    try {\n      const [queryType, normalizedQueries] = await this.getNormalizedQueries(query, context);\n\n      const sqlQueries = await Promise.all<any>(\n        normalizedQueries.map((normalizedQuery) => this.getCompilerApi(context).getSql(\n          this.coerceForSqlQuery(normalizedQuery, context),\n          {\n            includeDebugInfo: getEnv('devMode') || context.signedWithPlaygroundAuthSecret\n          }\n        ))\n      );\n\n      res({\n        queryType,\n        normalizedQueries,\n        queryOrder: sqlQueries.map((sqlQuery) => R.fromPairs(\n          sqlQuery.order.map(({ id: member, desc }) => [member, desc ? 'desc' : 'asc'])\n        )),\n        transformedQueries: sqlQueries.map((sqlQuery) => sqlQuery.canUseTransformedQuery),\n        pivotQuery: getPivotQuery(queryType, normalizedQueries)\n      });\n    } catch (e) {\n      this.handleError({\n        e, context, query, res, requestStarted\n      });\n    }\n  }\n\n  /**\n   * Returns an array of sqlQuery objects for specified normalized\n   * queries.\n   * @internal\n   */\n  private async getSqlQueriesInternal(\n    context: RequestContext,\n    normalizedQueries: (NormalizedQuery)[],\n  ): Promise<Array<any>> {\n    const sqlQueries = await Promise.all(\n      normalizedQueries.map(\n        async (normalizedQuery, index) => {\n          const loadRequestSQLStarted = new Date();\n          const sqlQuery = await this.getCompilerApi(context)\n            .getSql(\n              this.coerceForSqlQuery(normalizedQuery, context)\n            );\n\n          this.log({\n            type: 'Load Request SQL',\n            duration: this.duration(loadRequestSQLStarted),\n            query: normalizedQueries[index],\n            sqlQuery\n          }, context);\n\n          return sqlQuery;\n        }\n      )\n    );\n    return sqlQueries;\n  }\n\n  /**\n   * Execute query and return adapter's result.\n   * @internal\n   */\n  private async getSqlResponseInternal(\n    context: RequestContext,\n    normalizedQuery: NormalizedQuery,\n    sqlQuery: any,\n    apiType: string,\n  ) {\n    const queries = [{\n      ...sqlQuery,\n      query: sqlQuery.sql[0],\n      values: sqlQuery.sql[1],\n      continueWait: true,\n      renewQuery: normalizedQuery.renewQuery,\n      requestId: context.requestId,\n      context,\n      persistent: apiType === 'sql',\n    }];\n    if (normalizedQuery.total) {\n      const normalizedTotal = structuredClone(normalizedQuery);\n      normalizedTotal.totalQuery = true;\n      normalizedTotal.limit = null;\n      normalizedTotal.rowLimit = null;\n      normalizedTotal.offset = null;\n      const [totalQuery] = await this.getSqlQueriesInternal(\n        context,\n        [normalizedTotal],\n      );\n      queries.push({\n        ...totalQuery,\n        query: totalQuery.sql[0],\n        values: totalQuery.sql[1],\n        continueWait: true,\n        renewQuery: normalizedTotal.renewQuery,\n        requestId: context.requestId,\n        context\n      });\n    }\n    const [response, total] = await Promise.all(\n      queries.map(async (query) => {\n        const res = await this\n          .getAdapterApi(context)\n          .executeQuery(query);\n        return res;\n      })\n    );\n    response.total = normalizedQuery.total\n      ? Number(total.data[0][QueryAlias.TOTAL_COUNT])\n      : undefined;\n    return response;\n  }\n\n  /**\n   * Convert adapter's result and other request paramters to a final\n   * result object.\n   * @internal\n   */\n  private getResultInternal(\n    context: RequestContext,\n    queryType: QueryType,\n    normalizedQuery: NormalizedQuery,\n    sqlQuery: any,\n    annotation: {\n      measures: {\n        [index: string]: unknown;\n      };\n      dimensions: {\n        [index: string]: unknown;\n      };\n      segments: {\n        [index: string]: unknown;\n      };\n      timeDimensions: {\n        [index: string]: unknown;\n      };\n    },\n    response: any,\n    responseType?: ResultType,\n  ) {\n    return {\n      query: normalizedQuery,\n      data: transformData(\n        sqlQuery.aliasNameToMember,\n        {\n          ...annotation.measures,\n          ...annotation.dimensions,\n          ...annotation.timeDimensions\n        } as { [member: string]: ConfigItem },\n        response.data,\n        normalizedQuery,\n        queryType,\n        responseType,\n      ),\n      lastRefreshTime: response.lastRefreshTime?.toISOString(),\n      ...(\n        getEnv('devMode') ||\n          context.signedWithPlaygroundAuthSecret\n          ? {\n            refreshKeyValues: response.refreshKeyValues,\n            usedPreAggregations: response.usedPreAggregations,\n            transformedQuery: sqlQuery.canUseTransformedQuery,\n            requestId: context.requestId,\n          }\n          : null\n      ),\n      annotation,\n      dataSource: response.dataSource,\n      dbType: response.dbType,\n      extDbType: response.extDbType,\n      external: response.external,\n      slowQuery: Boolean(response.slowQuery),\n      total: normalizedQuery.total ? response.total : null,\n    };\n  }\n\n  /**\n   * Data queries APIs (`/load`, `/subscribe`) entry point. Used by\n   * `CubejsApi#load` and `CubejsApi#subscribe` methods to fetch the\n   * data.\n   */\n  public async load(request: QueryRequest) {\n    let query: Query | Query[] | undefined;\n    const {\n      context,\n      res,\n      apiType = 'rest',\n      ...props\n    } = request;\n    const requestStarted = new Date();\n\n    try {\n      query = this.parseQueryParam(request.query);\n      let resType: ResultType = ResultType.DEFAULT;\n\n      if (!Array.isArray(query) && query.responseFormat) {\n        resType = query.responseFormat;\n      }\n\n      this.log({\n        type: 'Load Request',\n        query\n      }, context);\n\n      const [queryType, normalizedQueries] =\n        await this.getNormalizedQueries(query, context);\n\n      let metaConfigResult = await this\n        .getCompilerApi(context).metaConfig({\n          requestId: context.requestId\n        });\n\n      metaConfigResult = this.filterVisibleItemsInMeta(context, metaConfigResult);\n\n      const sqlQueries = await this\n        .getSqlQueriesInternal(context, normalizedQueries);\n\n      let slowQuery = false;\n\n      const results = await Promise.all(\n        normalizedQueries.map(async (normalizedQuery, index) => {\n          slowQuery = slowQuery ||\n            Boolean(sqlQueries[index].slowQuery);\n\n          const annotation = prepareAnnotation(\n            metaConfigResult, normalizedQuery\n          );\n\n          const response = await this.getSqlResponseInternal(\n            context,\n            normalizedQuery,\n            sqlQueries[index],\n            apiType,\n          );\n\n          return this.getResultInternal(\n            context,\n            queryType,\n            normalizedQuery,\n            sqlQueries[index],\n            annotation,\n            response,\n            resType,\n          );\n        })\n      );\n\n      this.log(\n        {\n          type: 'Load Request Success',\n          query,\n          duration: this.duration(requestStarted),\n          apiType,\n          isPlayground: Boolean(\n            context.signedWithPlaygroundAuthSecret\n          ),\n          queries: results.length,\n          queriesWithPreAggregations:\n            results.filter(\n              (r: any) => Object.keys(\n                r.usedPreAggregations || {}\n              ).length\n            ).length,\n          queriesWithData:\n            results.filter((r: any) => r.data?.length).length,\n          dbType: results.map(r => r.dbType),\n        },\n        context,\n      );\n\n      if (\n        queryType !== QueryTypeEnum.REGULAR_QUERY &&\n        props.queryType == null\n      ) {\n        throw new UserError(\n          `'${queryType\n          }' query type is not supported by the client.` +\n          'Please update the client.'\n        );\n      }\n\n      if (props.queryType === 'multi') {\n        res({\n          queryType,\n          results,\n          pivotQuery: getPivotQuery(queryType, normalizedQueries),\n          slowQuery\n        });\n      } else {\n        res(results[0]);\n      }\n    } catch (e) {\n      this.handleError({\n        e, context, query, res, requestStarted\n      });\n    }\n  }\n\n  public subscribeQueueEvents({ context, signedWithPlaygroundAuthSecret, connectionId, res }) {\n    if (this.enforceSecurityChecks && !signedWithPlaygroundAuthSecret) {\n      throw new CubejsHandlerError(\n        403,\n        'Forbidden',\n        'Only for signed with playground auth secret'\n      );\n    }\n    return this.getAdapterApi(context).subscribeQueueEvents(connectionId, res);\n  }\n\n  public unSubscribeQueueEvents({ context, connectionId }) {\n    return this.getAdapterApi(context).unSubscribeQueueEvents(connectionId);\n  }\n\n  public async subscribe({\n    query, context, res, subscribe, subscriptionState, queryType, apiType\n  }) {\n    const requestStarted = new Date();\n    try {\n      this.log({\n        type: 'Subscribe',\n        query\n      }, context);\n\n      let result: any = null;\n      let error: any = null;\n\n      if (!subscribe) {\n        await this.load({ query, context, res, queryType, apiType });\n        return;\n      }\n\n      // TODO subscribe to refreshKeys instead of constantly firing load\n      await this.load({\n        query,\n        context,\n        res: (message, opts) => {\n          if (!Array.isArray(message) && message.error) {\n            error = { message, opts };\n          } else {\n            result = { message, opts };\n          }\n        },\n        queryType,\n        apiType,\n      });\n      const state = await subscriptionState();\n      if (result && (!state || JSON.stringify(state.result) !== JSON.stringify(result))) {\n        res(result.message, result.opts);\n      } else if (error) {\n        res(error.message, error.opts);\n      }\n      await subscribe({ error, result });\n    } catch (e) {\n      this.handleError({\n        e, context, query, res, requestStarted\n      });\n    }\n  }\n\n  protected resToResultFn(res: Response) {\n    return (message, { status }: { status?: number } = {}) => (status ? res.status(status).json(message) : res.json(message));\n  }\n\n  protected parseQueryParam(query): Query | Query[] {\n    if (!query || query === 'undefined') {\n      throw new UserError('query param is required');\n    }\n    if (typeof query === 'string') {\n      query = JSON.parse(query);\n    }\n    return query as Query | Query[];\n  }\n\n  protected getCompilerApi(context) {\n    if (typeof this.compilerApi === 'function') {\n      return this.compilerApi(context);\n    }\n\n    return this.compilerApi;\n  }\n\n  protected getAdapterApi(context) {\n    if (typeof this.adapterApi === 'function') {\n      return this.adapterApi(context);\n    }\n\n    return this.adapterApi;\n  }\n\n  public async contextByReq(req: Request, securityContext, requestId: string): Promise<ExtendedRequestContext> {\n    const extensions = typeof this.extendContext === 'function' ? await this.extendContext(req) : {};\n\n    return {\n      securityContext,\n      // Deprecated, but let's allow it for now.\n      authInfo: securityContext,\n      signedWithPlaygroundAuthSecret: Boolean(req.signedWithPlaygroundAuthSecret),\n      requestId,\n      ...extensions,\n    };\n  }\n\n  protected handleErrorMiddleware: ErrorRequestHandler = async (e, req, res, next) => {\n    this.handleError({\n      e,\n      context: (<any>req).context,\n      res: this.resToResultFn(res),\n      requestStarted: new Date(),\n    });\n\n    next(e);\n  };\n\n  public handleError({\n    e, context, query, res, requestStarted\n  }: any) {\n    const requestId = getEnv('devMode') || context?.signedWithPlaygroundAuthSecret ? context?.requestId : undefined;\n    \n    const plainError = e.plainMessages;\n    \n    if (e instanceof CubejsHandlerError) {\n      this.log({\n        type: e.type,\n        query,\n        error: e.message,\n        duration: this.duration(requestStarted)\n      }, context);\n      res({ error: e.message, stack: e.stack, requestId, plainError }, { status: e.status });\n    } else if (e.error === 'Continue wait') {\n      this.log({\n        type: 'Continue wait',\n        query,\n        error: e.message,\n        duration: this.duration(requestStarted),\n      }, context);\n      res({ error: e.message || e.error.message || e.error.toString(), requestId }, { status: 200 });\n    } else if (e.error) {\n      this.log({\n        type: 'Orchestrator error',\n        query,\n        error: e.error,\n        duration: this.duration(requestStarted),\n      }, context);\n      res({ error: e.message || e.error.message || e.error.toString(), requestId }, { status: 400 });\n    } else if (e.type === 'UserError') {\n      this.log({\n        type: e.type,\n        query,\n        error: e.message,\n        duration: this.duration(requestStarted)\n      }, context);\n      res(\n        {\n          type: e.type,\n          error: e.message,\n          plainError,\n          stack: e.stack,\n          requestId\n        },\n        { status: 400 }\n      );\n    } else {\n      this.log({\n        type: 'Internal Server Error',\n        query,\n        error: e.stack || e.toString(),\n        duration: this.duration(requestStarted)\n      }, context);\n      res({ error: e.toString(), stack: e.stack, requestId, plainError, }, { status: 500 });\n    }\n  }\n\n  protected wrapCheckAuthMiddleware(fn: CheckAuthMiddlewareFn): CheckAuthMiddlewareFn {\n    this.logger('CheckAuthMiddleware Middleware Deprecation', {\n      warning: (\n        'Option checkAuthMiddleware is now deprecated in favor of checkAuth, please migrate: ' +\n        'https://github.com/cube-js/cube.js/blob/master/DEPRECATION.md#checkauthmiddleware'\n      )\n    });\n\n    let showWarningAboutNotObject = false;\n\n    return (req, res, next) => {\n      fn(req, res, (e) => {\n        // We renamed authInfo to securityContext, but users can continue to use both ways\n        if (req.securityContext && !req.authInfo) {\n          req.authInfo = req.securityContext;\n        } else if (req.authInfo) {\n          req.securityContext = req.authInfo;\n        }\n\n        if ((typeof req.securityContext !== 'object' || req.securityContext === null) && !showWarningAboutNotObject) {\n          this.logger('Security Context Should Be Object', {\n            warning: (\n              `Value of securityContext (previously authInfo) expected to be object, actual: ${getRealType(req.securityContext)}`\n            )\n          });\n\n          showWarningAboutNotObject = true;\n        }\n\n        next(e);\n      });\n    };\n  }\n\n  protected wrapCheckAuth(fn: CheckAuthFn): CheckAuthFn {\n    // We dont need to span all logs with deprecation message\n    let warningShowed = false;\n    // securityContext should be object\n    let showWarningAboutNotObject = false;\n\n    return async (req, auth) => {\n      await fn(req, auth);\n\n      // We renamed authInfo to securityContext, but users can continue to use both ways\n      if (req.securityContext && !req.authInfo) {\n        req.authInfo = req.securityContext;\n      } else if (req.authInfo) {\n        if (!warningShowed) {\n          this.logger('AuthInfo Deprecation', {\n            warning: (\n              'authInfo was renamed to securityContext, please migrate: ' +\n              'https://github.com/cube-js/cube.js/blob/master/DEPRECATION.md#checkauthmiddleware'\n            )\n          });\n\n          warningShowed = true;\n        }\n\n        req.securityContext = req.authInfo;\n      }\n\n      if ((typeof req.securityContext !== 'object' || req.securityContext === null) && !showWarningAboutNotObject) {\n        this.logger('Security Context Should Be Object', {\n          warning: (\n            `Value of securityContext (previously authInfo) expected to be object, actual: ${getRealType(req.securityContext)}`\n          )\n        });\n\n        showWarningAboutNotObject = true;\n      }\n    };\n  }\n\n  protected createDefaultCheckAuth(options?: JWTOptions, internalOptions?: CheckAuthInternalOptions): CheckAuthFn {\n    type VerifyTokenFn = (auth: string, secret: string) => Promise<object | string> | object | string;\n\n    const verifyToken = (auth, secret) => jwt.verify(auth, secret, {\n      algorithms: <JWTAlgorithm[] | undefined>options?.algorithms,\n      issuer: options?.issuer,\n      audience: options?.audience,\n      subject: options?.subject,\n    });\n\n    let checkAuthFn: VerifyTokenFn = verifyToken;\n\n    if (options?.jwkUrl) {\n      const jwks = createJWKsFetcher(options, {\n        onBackgroundException: (e) => {\n          this.logger('JWKs Background Fetching Error', {\n            error: e.message,\n          });\n        },\n      });\n\n      this.releaseListeners.push(jwks.release);\n\n      // Precache JWKs response to speedup first auth\n      if (options.jwkUrl && typeof options.jwkUrl === 'string') {\n        jwks.fetchOnly(options.jwkUrl).catch((e) => this.logger('JWKs Prefetching Error', {\n          error: e.message,\n        }));\n      }\n\n      checkAuthFn = async (auth) => {\n        const decoded = <Record<string, any> | null>jwt.decode(auth, { complete: true });\n        if (!decoded) {\n          throw new CubejsHandlerError(\n            403,\n            'Forbidden',\n            'Unable to decode JWT key'\n          );\n        }\n\n        if (!decoded.header || !decoded.header.kid) {\n          throw new CubejsHandlerError(\n            403,\n            'Forbidden',\n            'JWT without kid inside headers'\n          );\n        }\n\n        const jwk = await jwks.getJWKbyKid(\n          typeof options.jwkUrl === 'function' ? options.jwkUrl(decoded) : <string>options.jwkUrl,\n          decoded.header.kid\n        );\n        if (!jwk) {\n          throw new CubejsHandlerError(\n            403,\n            'Forbidden',\n            `Unable to verify, JWK with kid: \"${decoded.header.kid}\" not found`\n          );\n        }\n\n        return verifyToken(auth, jwk);\n      };\n    }\n\n    const secret = options?.key || this.apiSecret;\n\n    return async (req, auth) => {\n      if (auth) {\n        try {\n          req.securityContext = await checkAuthFn(auth, secret);\n          req.signedWithPlaygroundAuthSecret = Boolean(internalOptions?.isPlaygroundCheckAuth);\n        } catch (e) {\n          if (this.enforceSecurityChecks) {\n            throw new CubejsHandlerError(403, 'Forbidden', 'Invalid token');\n          } else {\n            this.log({\n              type: (e as Error).message,\n              token: auth,\n              error: (e as Error).stack || (e as Error).toString()\n            }, <any>req);\n          }\n        }\n      } else if (this.enforceSecurityChecks) {\n        // @todo Move it to 401 or 400\n        throw new CubejsHandlerError(403, 'Forbidden', 'Authorization header isn\\'t set');\n      }\n    };\n  }\n\n  protected createCheckAuthFn(options: ApiGatewayOptions): CheckAuthFn {\n    const mainCheckAuthFn = options.checkAuth\n      ? this.wrapCheckAuth(options.checkAuth)\n      : this.createDefaultCheckAuth(options.jwt);\n\n    if (this.playgroundAuthSecret) {\n      const systemCheckAuthFn = this.createCheckAuthSystemFn();\n      return async (ctx, authorization) => {\n        try {\n          await mainCheckAuthFn(ctx, authorization);\n        } catch (error) {\n          await systemCheckAuthFn(ctx, authorization);\n        }\n      };\n    }\n\n    return (ctx, authorization) => mainCheckAuthFn(ctx, authorization);\n  }\n\n  protected createCheckAuthSystemFn(): CheckAuthFn {\n    const systemCheckAuthFn = this.createDefaultCheckAuth(\n      {\n        key: this.playgroundAuthSecret,\n        algorithms: ['HS256']\n      },\n      { isPlaygroundCheckAuth: true }\n    );\n\n    return async (ctx, authorization) => {\n      await systemCheckAuthFn(ctx, authorization);\n    };\n  }\n\n  protected extractAuthorizationHeaderWithSchema(req: Request) {\n    if (typeof req.headers.authorization === 'string') {\n      const parts = req.headers.authorization.split(' ', 2);\n      if (parts.length === 1) {\n        return parts[0];\n      }\n\n      return parts[1];\n    }\n\n    return undefined;\n  }\n\n  protected async checkAuthWrapper(checkAuthFn: CheckAuthFn, req: Request, res: Response, next) {\n    const token = this.extractAuthorizationHeaderWithSchema(req);\n\n    try {\n      await checkAuthFn(req, token);\n      if (next) {\n        next();\n      }\n    } catch (e: unknown) {\n      if (e instanceof CubejsHandlerError) {\n        res.status(e.status).json({ error: e.message });\n      } else if (e instanceof Error) {\n        this.log({\n          type: 'Auth Error',\n          token,\n          error: e.stack || e.toString()\n        }, <any>req);\n\n        res.status(500).json({\n          error: e.toString(),\n          stack: e.stack\n        });\n      }\n    }\n  }\n\n  protected checkAuth: RequestHandler = async (req, res, next) => {\n    await this.checkAuthWrapper(this.checkAuthFn, req, res, next);\n  };\n\n  protected checkAuthSystemMiddleware: RequestHandler = async (req, res, next) => {\n    await this.checkAuthWrapper(this.checkAuthSystemFn, req, res, next);\n  };\n\n  protected requestContextMiddleware: RequestHandler = async (req: Request, res: Response, next: NextFunction) => {\n    req.context = await this.contextByReq(req, req.securityContext, getRequestIdFromRequest(req));\n    if (next) {\n      next();\n    }\n  };\n\n  protected requestLogger: RequestHandler = async (req: Request, res: Response, next: NextFunction) => {\n    const details = requestParser(req, res);\n\n    this.log({ type: 'REST API Request', ...details }, req.context);\n\n    if (next) {\n      next();\n    }\n  };\n\n  protected logNetworkUsage: RequestHandler = async (req: Request, res: Response, next: NextFunction) => {\n    this.log({\n      type: 'Incoming network usage',\n      service: 'api-http',\n      bytes: Buffer.byteLength(req.url + req.rawHeaders.join('\\n')) + (Number(req.get('content-length')) || 0),\n      path: req.path,\n    }, req.context);\n    res.on('finish', () => {\n      this.log({\n        type: 'Outgoing network usage',\n        service: 'api-http',\n        bytes: Number(res.get('content-length')) || 0,\n        path: req.path,\n      }, req.context);\n    });\n    if (next) {\n      next();\n    }\n  };\n\n  protected compareDateRangeTransformer(query) {\n    let queryCompareDateRange;\n    let compareDateRangeTDIndex;\n\n    (query.timeDimensions || []).forEach((td, index) => {\n      if (td.compareDateRange != null) {\n        if (queryCompareDateRange != null) {\n          throw new UserError('compareDateRange can only exist for one timeDimension');\n        }\n\n        queryCompareDateRange = td.compareDateRange;\n        compareDateRangeTDIndex = index;\n      }\n    });\n\n    if (queryCompareDateRange == null) {\n      return query;\n    }\n\n    return queryCompareDateRange.map((dateRange) => ({\n      ...R.clone(query),\n      timeDimensions: query.timeDimensions.map((td, index) => {\n        if (compareDateRangeTDIndex === index) {\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          const { compareDateRange, ...timeDimension } = td;\n          return {\n            ...timeDimension,\n            dateRange\n          };\n        }\n\n        return td;\n      })\n    }));\n  }\n\n  public log(event: { type: string, [key: string]: any }, context?: Partial<RequestContext>) {\n    const { type, ...restParams } = event;\n\n    this.logger(type, {\n      ...restParams,\n      ...(!context ? undefined : {\n        securityContext: context.securityContext,\n        requestId: context.requestId,\n        ...(!context.appName ? undefined : { appName: context.appName }),\n        ...(!context.protocol ? undefined : { protocol: context.protocol }),\n        ...(!context.apiType ? undefined : { apiType: context.apiType }),\n      })\n    });\n  }\n\n  protected healthResponse(res: Response, health: 'HEALTH' | 'DOWN') {\n    res.status(health === 'HEALTH' ? 200 : 500).json({\n      health,\n    });\n  }\n\n  protected createSystemContextHandler = (basePath: string): RequestHandler => {\n    const body: Readonly<Record<string, any>> = {\n      basePath,\n      dockerVersion: getEnv('dockerImageVersion') || null,\n      serverCoreVersion: this.options.serverCoreVersion || null\n    };\n\n    return (req, res) => {\n      res.status(200).json(body);\n    };\n  };\n\n  private logProbeError(e: any, type: string): void {\n    this.log({\n      type,\n      driverType: e.driverType,\n      error: (e as Error).stack || (e as Error).toString(),\n    });\n  }\n\n  protected readiness: RequestHandler = async (req, res) => {\n    let health: 'HEALTH' | 'DOWN' = 'HEALTH';\n\n    if (this.standalone) {\n      const orchestratorApi = await this.adapterApi({});\n\n      try {\n        // todo: test other data sources\n        orchestratorApi.addDataSeenSource('default');\n        await orchestratorApi.testConnection();\n        await orchestratorApi.testOrchestratorConnections();\n      } catch (e: any) {\n        this.logProbeError(e, 'Internal Server Error on readiness probe');\n        health = 'DOWN';\n      }\n    }\n\n    return this.healthResponse(res, health);\n  };\n\n  protected liveness: RequestHandler = async (req, res) => {\n    let health: 'HEALTH' | 'DOWN' = 'HEALTH';\n\n    try {\n      await this.dataSourceStorage.testConnections();\n      // @todo Optimize this moment?\n      await this.dataSourceStorage.testOrchestratorConnections();\n    } catch (e: any) {\n      this.logProbeError(e, 'Internal Server Error on liveness probe');\n      health = 'DOWN';\n    }\n\n    return this.healthResponse(res, health);\n  };\n\n  public release() {\n    for (const releaseListener of this.releaseListeners) {\n      releaseListener();\n    }\n  }\n}\nexport {\n  UserBackgroundContext,\n  ApiGatewayOptions,\n  ApiGateway,\n};\n", "import crypto from 'crypto';\nimport R from 'ramda';\nimport { createQuery, compile, queryClass, PreAggregations, QueryFactory } from '@cubejs-backend/schema-compiler';\n\nexport class CompilerApi {\n  /**\n   * Class constructor.\n   * @param {SchemaFileRepository} repository\n   * @param {DbTypeAsyncFn} dbType\n   * @param {*} options\n   */\n  constructor(repository, dbType, options) {\n    this.repository = repository;\n    this.dbType = dbType;\n    this.dialectClass = options.dialectClass;\n    this.options = options || {};\n    this.allowNodeRequire = options.allowNodeRequire == null ? true : options.allowNodeRequire;\n    this.logger = this.options.logger;\n    this.preAggregationsSchema = this.options.preAggregationsSchema;\n    this.allowUngroupedWithoutPrimaryKey = this.options.allowUngroupedWithoutPrimaryKey;\n    this.schemaVersion = this.options.schemaVersion;\n    this.compileContext = options.compileContext;\n    this.allowJsDuplicatePropsInSchema = options.allowJsDuplicatePropsInSchema;\n    this.sqlCache = options.sqlCache;\n    this.standalone = options.standalone;\n  }\n\n  setGraphQLSchema(schema) {\n    this.graphqlSchema = schema;\n  }\n\n  getGraphQLSchema() {\n    return this.graphqlSchema;\n  }\n\n  async getCompilers({ requestId } = {}) {\n    let compilerVersion = (\n      this.schemaVersion && await this.schemaVersion() ||\n      'default_schema_version'\n    );\n\n    if (typeof compilerVersion === 'object') {\n      compilerVersion = JSON.stringify(compilerVersion);\n    }\n\n    if (this.options.devServer) {\n      const files = await this.repository.dataSchemaFiles();\n      compilerVersion += `_${crypto.createHash('md5').update(JSON.stringify(files)).digest('hex')}`;\n    }\n\n    if (!this.compilers || this.compilerVersion !== compilerVersion) {\n      this.logger(this.compilers ? 'Recompiling schema' : 'Compiling schema', {\n        version: compilerVersion,\n        requestId\n      });\n      this.compilers = await compile(this.repository, {\n        allowNodeRequire: this.allowNodeRequire,\n        compileContext: this.compileContext,\n        allowJsDuplicatePropsInSchema: this.allowJsDuplicatePropsInSchema,\n        standalone: this.standalone,\n      });\n      this.compilerVersion = compilerVersion;\n      this.queryFactory = await this.createQueryFactory(this.compilers);\n    }\n\n    return this.compilers;\n  }\n\n  async createQueryFactory(compilers) {\n    const { cubeEvaluator } = compilers;\n\n    const cubeToQueryClass = R.fromPairs(\n      await Promise.all(\n        cubeEvaluator.cubeNames().map(async cube => {\n          const dataSource = cubeEvaluator.cubeFromPath(cube).dataSource ?? 'default';\n          const dbType = await this.getDbType(dataSource);\n          const dialectClass = this.getDialectClass(dataSource, dbType);\n          return [cube, queryClass(dbType, dialectClass)];\n        })\n      )\n    );\n    return new QueryFactory(cubeToQueryClass);\n  }\n\n  async getDbType(dataSource = 'default') {\n    const res = await this.dbType({ dataSource, });\n    return res;\n  }\n\n  getDialectClass(dataSource = 'default', dbType) {\n    return this.dialectClass && this.dialectClass({ dataSource, dbType });\n  }\n\n  async getSql(query, options = {}) {\n    const { includeDebugInfo } = options;\n\n    const dbType = await this.getDbType();\n    const compilers = await this.getCompilers({ requestId: query.requestId });\n    let sqlGenerator = await this.createQueryByDataSource(compilers, query);\n\n    if (!sqlGenerator) {\n      throw new Error(`Unknown dbType: ${dbType}`);\n    }\n\n    const dataSource = compilers.compiler.withQuery(sqlGenerator, () => sqlGenerator.dataSource);\n    const _dbType = await this.getDbType(dataSource);\n    if (dataSource !== 'default' && dbType !== _dbType) {\n      // TODO consider more efficient way than instantiating query\n      sqlGenerator = await this.createQueryByDataSource(\n        compilers,\n        query,\n        dataSource\n      );\n\n      if (!sqlGenerator) {\n        throw new Error(`Can't find dialect for '${dataSource}' data source: ${_dbType}`);\n      }\n    }\n\n    const getSqlFn = () => compilers.compiler.withQuery(sqlGenerator, () => ({\n      external: sqlGenerator.externalPreAggregationQuery(),\n      sql: sqlGenerator.buildSqlAndParams(),\n      lambdaQueries: sqlGenerator.buildLambdaQuery(),\n      timeDimensionAlias: sqlGenerator.timeDimensions[0] && sqlGenerator.timeDimensions[0].unescapedAliasName(),\n      timeDimensionField: sqlGenerator.timeDimensions[0] && sqlGenerator.timeDimensions[0].dimension,\n      order: sqlGenerator.order,\n      cacheKeyQueries: sqlGenerator.cacheKeyQueries(),\n      preAggregations: sqlGenerator.preAggregations.preAggregationsDescription(),\n      dataSource: sqlGenerator.dataSource,\n      aliasNameToMember: sqlGenerator.aliasNameToMember,\n      rollupMatchResults: includeDebugInfo ?\n        sqlGenerator.preAggregations.rollupMatchResultDescriptions() : undefined,\n      canUseTransformedQuery: sqlGenerator.preAggregations.canUseTransformedQuery()\n    }));\n\n    if (this.sqlCache) {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const { requestId, ...keyOptions } = query;\n      const key = { query: keyOptions, options };\n      return compilers.compilerCache.getQueryCache(key).cache(['sql'], getSqlFn);\n    } else {\n      return getSqlFn();\n    }\n  }\n\n  async preAggregations(filter) {\n    const { cubeEvaluator } = await this.getCompilers();\n    return cubeEvaluator.preAggregations(filter);\n  }\n\n  async scheduledPreAggregations() {\n    const { cubeEvaluator } = await this.getCompilers();\n    return cubeEvaluator.scheduledPreAggregations();\n  }\n\n  async createQueryByDataSource(compilers, query, dataSource) {\n    const dbType = await this.getDbType(dataSource);\n\n    return this.createQuery(compilers, dbType, this.getDialectClass(dataSource, dbType), query);\n  }\n\n  createQuery(compilers, dbType, dialectClass, query) {\n    return createQuery(\n      compilers,\n      dbType,\n      {\n        ...query,\n        dialectClass,\n        externalDialectClass: this.options.externalDialectClass,\n        externalDbType: this.options.externalDbType,\n        preAggregationsSchema: this.preAggregationsSchema,\n        allowUngroupedWithoutPrimaryKey: this.allowUngroupedWithoutPrimaryKey,\n        queryFactory: this.queryFactory,\n      }\n    );\n  }\n\n  async metaConfig(options) {\n    return (await this.getCompilers(options)).metaTransformer.cubes;\n  }\n\n  async metaConfigExtended(options) {\n    const { metaTransformer } = await this.getCompilers(options);\n    return {\n      metaConfig: metaTransformer?.cubes,\n      cubeDefinitions: metaTransformer?.cubeEvaluator?.cubeDefinitions,\n    };\n  }\n\n  canUsePreAggregationForTransformedQuery(transformedQuery, refs) {\n    return PreAggregations.canUsePreAggregationForTransformedQueryFn(transformedQuery, refs);\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-empty-function */\n\nimport { withTimeout } from '@cubejs-backend/shared';\n\nimport {\n  CreateOptions,\n  CubejsServerCore,\n  SchemaFileRepository,\n  ServerCoreInitializedOptions\n} from '../../src';\nimport { OptsHandler } from '../../src/core/OptsHandler';\nimport { DatabaseType } from '../../src/core/types';\nimport { CompilerApi } from '../../src/core/CompilerApi';\nimport { OrchestratorApiOptions } from '../../src/core/OrchestratorApi';\n\n// It's just a mock to open protected methods\nclass CubejsServerCoreOpen extends CubejsServerCore {\n  public readonly optsHandler: OptsHandler;\n\n  public readonly options: ServerCoreInitializedOptions;\n\n  public getRefreshScheduler = super.getRefreshScheduler;\n\n  public isReadyForQueryProcessing = super.isReadyForQueryProcessing;\n\n  public createOrchestratorApi = super.createOrchestratorApi;\n}\n\nconst repositoryWithoutPreAggregations: SchemaFileRepository = {\n  localPath: () => __dirname,\n  dataSchemaFiles: () => Promise.resolve([\n    {\n      fileName: 'main.js', content: `\ncube('Bar', {\n  sql: 'select * from bar',\n  \n  measures: {\n    count: {\n      type: 'count'\n    }\n  },\n  \n  dimensions: {\n    time: {\n      sql: 'timestamp',\n      type: 'time'\n    }\n  }\n});\n`,\n    },\n  ]),\n};\n\nconst repositoryWithoutContent: SchemaFileRepository = {\n  localPath: () => __dirname,\n  dataSchemaFiles: () => Promise.resolve([{ fileName: 'main.js', content: '' }]),\n};\n\ndescribe('index.test', () => {\n  beforeEach(() => {\n    delete process.env.CUBEJS_EXT_DB_TYPE;\n    delete process.env.CUBEJS_DEV_MODE;\n    delete process.env.CUBEJS_DB_TYPE;\n    delete process.env.CUBEJS_REFRESH_WORKER;\n    delete process.env.CUBEJS_ROLLUP_ONLY;\n    delete process.env.CUBEJS_SCHEDULED_REFRESH;\n    delete process.env.CUBEJS_SCHEDULED_REFRESH_TIMER;\n\n    process.env.NODE_ENV = 'development';\n    process.env.CUBEJS_API_SECRET = 'api-secret';\n  });\n\n  test('Should create instance of CubejsServerCore, dbType as string', () => {\n    expect(new CubejsServerCore({\n      dbType: 'mysql'\n    })).toBeInstanceOf(CubejsServerCore);\n  });\n\n  test('Should create instance of CubejsServerCore, dbType as func', () => {\n    const options = { dbType: () => <DatabaseType>'postgres' };\n\n    expect(new CubejsServerCore(options))\n      .toBeInstanceOf(CubejsServerCore);\n  });\n\n  test('Should throw error, unknown dbType', () => {\n    const options = { dbType: <any>'unknown-db' };\n\n    expect(() => new CubejsServerCore(options))\n      .toThrowError(/\"dbType\" must be one of/);\n  });\n\n  test('Should throw error, invalid options', () => {\n    const options = {\n      dbType: <DatabaseType>'mysql',\n      externalDbType: <DatabaseType>'mysql',\n      schemaPath: '/test/path/test/',\n      basePath: '/basePath',\n      webSocketsBasePath: '/webSocketsBasePath',\n      devServer: true,\n      compilerCacheSize: -10,\n    };\n\n    expect(() => new CubejsServerCore(options))\n      .toThrowError(/\"compilerCacheSize\" must be larger than or equal to 0/);\n  });\n\n  test('Should create instance of CubejsServerCore, orchestratorOptions as func', () => {\n    const options = { dbType: <DatabaseType>'mysql', orchestratorOptions: () => <any>{} };\n\n    expect(new CubejsServerCore(options))\n      .toBeInstanceOf(CubejsServerCore);\n  });\n\n  const getCreateOrchestratorOptionsFromServer = (options: CreateOptions) => {\n    const cubejsServerCore = new CubejsServerCoreOpen(<any>options);\n    expect(cubejsServerCore).toBeInstanceOf(CubejsServerCore);\n\n    const createOrchestratorApiSpy = jest.spyOn(cubejsServerCore, 'createOrchestratorApi');\n    cubejsServerCore.getOrchestratorApi({\n      requestId: 'XXX',\n      authInfo: null,\n      securityContext: null,\n    });\n\n    expect(createOrchestratorApiSpy.mock.calls.length).toEqual(1);\n    return createOrchestratorApiSpy.mock.calls[0];\n  };\n\n  test('dbType should return string, failure', async () => {\n    const options: CreateOptions = { dbType: () => <any>null };\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const [driverFactory, orchestratorOptions] = getCreateOrchestratorOptionsFromServer(options);\n\n    try {\n      await driverFactory('mongo');\n\n      throw new Error('driverFactory will call dbType and dbType must throw an exception');\n    } catch (e: any) {\n      expect(e.message).toEqual('Unexpected CreateOptions.dbType result type: <object>null');\n    }\n  });\n\n  test('driverFactory should return driver, failure', async () => {\n    const options: CreateOptions = { dbType: () => <any>'mongo', driverFactory: () => <any>null, };\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const [driverFactory, orchestratorOptions] = getCreateOrchestratorOptionsFromServer(options);\n\n    try {\n      await driverFactory('default');\n\n      throw new Error('driverFactory will call dbType and dbType must throw an exception');\n    } catch (e: any) {\n      expect(e.message).toEqual('Unexpected CreateOptions.driverFactory result value. Must be either DriverConfig or driver instance: <object>null');\n    }\n  });\n\n  test('externalDriverFactory should return driver, failure', async () => {\n    const options: CreateOptions = { dbType: () => <any>'mongo', externalDriverFactory: () => <any>null, };\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const [driverFactory, orchestratorOptions] = getCreateOrchestratorOptionsFromServer(options);\n\n    try {\n      await orchestratorOptions.externalDriverFactory();\n\n      throw new Error('driverFactory will call dbType and dbType must throw an exception');\n    } catch (e: any) {\n      expect(e.message).toEqual('Unexpected return type, externalDriverFactory must return driver, actual: null');\n    }\n  });\n\n  test('Should create instance of CubejsServerCore, pass all options', async () => {\n    const queueOptions = {\n      concurrency: 3,\n      continueWaitTimeout: 5,\n      executionTimeout: 600,\n      orphanedTimeout: 120,\n      heartBeatInterval: 500,\n      sendProcessMessageFn: () => {},\n      sendCancelMessageFn: () => {}\n    };\n\n    const options = {\n      dbType: <any>'mysql',\n      externalDbType: 'cubestore',\n      schemaPath: '/test/path/test/',\n      basePath: '/basePath',\n      webSocketsBasePath: '/webSocketsBasePath',\n      initApp: () => {},\n      processSubscriptionsInterval: 5000,\n      devServer: false,\n      apiSecret: 'randomstring',\n      logger: () => {},\n      driverFactory: () => <any>{\n        setLogger: () => {},\n        testConnection: async () => {},\n        release: () => {}\n      },\n      dialectFactory: () => {},\n      externalDriverFactory: () => <any>{\n        setLogger: () => {},\n        testConnection: async () => {},\n        release: () => {}\n      },\n      externalDialectFactory: () => {},\n      cacheAndQueueDriver: 'redis',\n      contextToAppId: () => 'STANDALONE',\n      contextToOrchestratorId: () => 'EMPTY',\n      repositoryFactory: () => {},\n      checkAuth: () => {},\n      checkAuthMiddleware: () => {},\n      queryTransformer: () => {},\n      preAggregationsSchema: () => {},\n      schemaVersion: () => {},\n      extendContext: () => {},\n      compilerCacheSize: 1000,\n      maxCompilerCacheKeepAlive: 10,\n      updateCompilerCacheKeepAlive: true,\n      telemetry: false,\n      allowUngroupedWithoutPrimaryKey: true,\n      // scheduled\n      scheduledRefreshTimeZones: ['Europe/Moscow'],\n      scheduledRefreshConcurrency: 4,\n      scheduledRefreshTimer: true,\n      scheduledRefreshContexts: () => [{\n        securityContext: {\n          appid: 'test1',\n          u: {\n            prop1: 'value1'\n          }\n        }\n      }],\n      orchestratorOptions: {\n        continueWaitTimeout: 10,\n        redisPrefix: 'some-prefix',\n        queryCacheOptions: {\n          refreshKeyRenewalThreshold: 1000,\n          backgroundRenew: true,\n          queueOptions,\n          externalQueueOptions: {\n            ...queueOptions\n          }\n        },\n        preAggregationsOptions: {\n          queueOptions\n        },\n        rollupOnlyMode: true\n      },\n      allowJsDuplicatePropsInSchema: true,\n      jwt: {\n        // JWK options\n        jwkRetry: 5,\n        jwkDefaultExpire: 5 * 60,\n        jwkUrl: () => '',\n        jwkRefetchWindow: 5 * 60,\n        // JWT options\n        key: 'string',\n        algorithms: ['RS256'],\n        issuer: ['http://localhost:4000'],\n        audience: 'http://localhost:4000/v1',\n        subject: 'http://localhost:4000',\n        claimsNamespace: 'http://localhost:4000',\n      },\n      dashboardAppPath: 'string',\n      dashboardAppPort: 4444,\n      livePreview: true,\n      allowNodeRequire: false,\n    };\n\n    const cubejsServerCore = new CubejsServerCoreOpen(<any>options);\n    expect(cubejsServerCore).toBeInstanceOf(CubejsServerCore);\n\n    const createOrchestratorApiSpy = jest.spyOn(cubejsServerCore, 'createOrchestratorApi');\n\n    cubejsServerCore.getOrchestratorApi({\n      requestId: 'XXX',\n      authInfo: null,\n      securityContext: null,\n    });\n    expect(createOrchestratorApiSpy.mock.calls.length).toEqual(1);\n    expect(createOrchestratorApiSpy.mock.calls[0]).toEqual([\n      expect.any(Function),\n      {\n        cacheAndQueueDriver: 'redis',\n        contextToDbType: expect.any(Function),\n        contextToExternalDbType: expect.any(Function),\n        continueWaitTimeout: 10,\n        externalDriverFactory: expect.any(Function),\n        redisPrefix: 'some-prefix',\n        rollupOnlyMode: true,\n        // from orchestratorOptions\n        preAggregationsOptions: expect.any(Object),\n        queryCacheOptions: expect.any(Object),\n        // enabled for cubestore\n        skipExternalCacheAndQueue: true,\n      }\n    ]);\n    createOrchestratorApiSpy.mockRestore();\n\n    const compilerApi = cubejsServerCore.getCompilerApi({\n      authInfo: null,\n      securityContext: null,\n      requestId: 'XXX'\n    });\n    expect(compilerApi.options.allowNodeRequire).toStrictEqual(false);\n\n    await cubejsServerCore.releaseConnections();\n  });\n\n  describe('CompilerApi', () => {\n    const logger = jest.fn(() => {});\n    const compilerApi = new CompilerApi(\n      repositoryWithoutPreAggregations,\n      async () => 'mysql',\n      { logger }\n    );\n    const metaConfigSpy = jest.spyOn(compilerApi, 'metaConfig');\n    const metaConfigExtendedSpy = jest.spyOn(compilerApi, 'metaConfigExtended');\n\n    test('CompilerApi metaConfig', async () => {\n      const metaConfig = await compilerApi.metaConfig({ requestId: 'XXX' });\n      expect(metaConfig?.length).toBeGreaterThan(0);\n      expect(metaConfig[0]).toHaveProperty('config');\n      expect(metaConfig[0].config.hasOwnProperty('sql')).toBe(false);\n      expect(metaConfigSpy).toHaveBeenCalled();\n      metaConfigSpy.mockClear();\n    });\n\n    test('CompilerApi metaConfigExtended', async () => {\n      const metaConfigExtended = await compilerApi.metaConfigExtended({ requestId: 'XXX' });\n      expect(metaConfigExtended).toHaveProperty('metaConfig');\n      expect(metaConfigExtended.metaConfig.length).toBeGreaterThan(0);\n      expect(metaConfigExtended).toHaveProperty('cubeDefinitions');\n      expect(metaConfigExtendedSpy).toHaveBeenCalled();\n      metaConfigExtendedSpy.mockClear();\n    });\n  });\n\n  describe('CompilerApi with empty cube on input', () => {\n    const logger = jest.fn(() => {});\n    const compilerApi = new CompilerApi(\n      repositoryWithoutContent,\n      async () => 'mysql',\n      { logger }\n    );\n    const metaConfigSpy = jest.spyOn(compilerApi, 'metaConfig');\n    const metaConfigExtendedSpy = jest.spyOn(compilerApi, 'metaConfigExtended');\n\n    test('CompilerApi metaConfig', async () => {\n      const metaConfig = await compilerApi.metaConfig({ requestId: 'XXX' });\n      expect(metaConfig).toEqual([]);\n      expect(metaConfigSpy).toHaveBeenCalled();\n      metaConfigSpy.mockClear();\n    });\n\n    test('CompilerApi metaConfigExtended', async () => {\n      const metaConfigExtended = await compilerApi.metaConfigExtended({ requestId: 'XXX' });\n      expect(metaConfigExtended).toHaveProperty('metaConfig');\n      expect(metaConfigExtended.metaConfig).toEqual([]);\n      expect(metaConfigExtended).toHaveProperty('cubeDefinitions');\n      expect(metaConfigExtended.cubeDefinitions).toEqual({});\n      expect(metaConfigExtendedSpy).toHaveBeenCalled();\n      metaConfigExtendedSpy.mockClear();\n    });\n  });\n\n  test('Should create instance of CubejsServerCore, dbType from process.env.CUBEJS_DB_TYPE', () => {\n    process.env.CUBEJS_DB_TYPE = 'mysql';\n\n    expect(new CubejsServerCore({}))\n      .toBeInstanceOf(CubejsServerCore);\n  });\n\n  test('Should create instance of CubejsServerCore, on unsupported platform for Cube Store', async () => {\n    const originalPlatform = process.platform;\n\n    const logger = jest.fn(() => {\n      //\n    });\n\n    try {\n      process.env.CUBEJS_DB_TYPE = 'mysql';\n      process.env.CUBEJS_DEV_MODE = 'true';\n\n      Object.defineProperty(process, 'platform', {\n        value: 'MockOS'\n      });\n\n      const cubejsServerCore = new CubejsServerCoreOpen({ logger });\n      await cubejsServerCore.beforeShutdown();\n      await cubejsServerCore.shutdown();\n    } finally {\n      jest.restoreAllMocks();\n\n      Object.defineProperty(process, 'platform', {\n        value: originalPlatform\n      });\n    }\n\n    expect(logger.mock.calls).toEqual([\n      [\n        'Cube Store is not supported on your system',\n        {\n          warning: 'You are using MockOS platform with x64 architecture, which is not supported by Cube Store.'\n        }\n      ]\n    ]);\n  });\n\n  // TODO (buntarb): This test doesn't have any sense anymore, because dbType\n  // property is deprecated and doesn't required in any mode. Need to be removed\n  test.skip('Should throw error, options are required (dev mode)', () => {\n    delete process.env.CUBEJS_API_SECRET;\n    process.env.CUBEJS_DEV_MODE = 'true';\n\n    expect(() => {\n      jest.spyOn(CubejsServerCoreOpen.prototype, 'isReadyForQueryProcessing').mockImplementation(() => true);\n      // eslint-disable-next-line\n      new CubejsServerCoreOpen({});\n      jest.restoreAllMocks();\n    })\n      .toThrowError(/dbType is required/);\n  });\n\n  test('Pass all required (dev mode) without apiSecret (should be autogenerated)', () => {\n    delete process.env.CUBEJS_API_SECRET;\n\n    process.env.CUBEJS_DEV_MODE = 'true';\n    process.env.CUBEJS_DB_TYPE = 'mysql';\n\n    expect(new CubejsServerCore({ jwt: { jwkUrl: 'https://test.com/j.json' } })).toBeInstanceOf(CubejsServerCore);\n  });\n\n  test('Should throw error, options are required (production mode)', () => {\n    delete process.env.CUBEJS_API_SECRET;\n    process.env.NODE_ENV = 'production';\n\n    expect(() => {\n      jest.spyOn(CubejsServerCoreOpen.prototype, 'isReadyForQueryProcessing').mockImplementation(() => true);\n      // eslint-disable-next-line\n      new CubejsServerCoreOpen({});\n      jest.restoreAllMocks();\n    })\n      .toThrowError('Either CUBEJS_DB_TYPE, CreateOptions.dbType or CreateOptions.driverFactory must be specified');\n  });\n\n  test('Should throw error, options are required (production mode with jwkUrl)', () => {\n    process.env.NODE_ENV = 'production';\n\n    expect(() => {\n      jest.spyOn(CubejsServerCoreOpen.prototype, 'isReadyForQueryProcessing').mockImplementation(() => true);\n      // eslint-disable-next-line\n      new CubejsServerCoreOpen({ jwt: { jwkUrl: 'https://test.com/j.json' } });\n      jest.restoreAllMocks();\n    })\n      .toThrowError('Either CUBEJS_DB_TYPE, CreateOptions.dbType or CreateOptions.driverFactory must be specified');\n  });\n\n  test('Pass all required props (production mode with JWK URL)', () => {\n    delete process.env.CUBEJS_API_SECRET;\n\n    process.env.NODE_ENV = 'production';\n    process.env.CUBEJS_DB_TYPE = 'mysql';\n\n    expect(new CubejsServerCore({ jwt: { jwkUrl: 'https://test.com/j.json' } })).toBeInstanceOf(CubejsServerCore);\n  });\n\n  test('Should not throw when the required options are missing in dev mode and no config file exists', () => {\n    expect(() => {\n      jest.spyOn(CubejsServerCoreOpen.prototype, 'isReadyForQueryProcessing').mockImplementation(() => false);\n      // eslint-disable-next-line\n      new CubejsServerCoreOpen({});\n      jest.restoreAllMocks();\n    })\n      .not.toThrow();\n  });\n\n  const expectRefreshTimerOption = (input, output, setProduction: boolean = false) => {\n    test(`scheduledRefreshTimer option ${input}`, async () => {\n      if (setProduction) {\n        process.env.NODE_ENV = 'production';\n      }\n\n      const cubejsServerCore = new CubejsServerCoreOpen({\n        dbType: 'mysql',\n        apiSecret: 'secret',\n        scheduledRefreshTimer: input\n      });\n      expect(cubejsServerCore).toBeInstanceOf(CubejsServerCore);\n      if (!cubejsServerCore.optsHandler.configuredForScheduledRefresh()) {\n        expect(output).toBeFalsy();\n      } else {\n        expect(\n          cubejsServerCore.optsHandler.getScheduledRefreshInterval()\n        ).toEqual(output);\n      }\n\n      await cubejsServerCore.beforeShutdown();\n      await cubejsServerCore.shutdown();\n    });\n  };\n\n  expectRefreshTimerOption(undefined, false);\n  expectRefreshTimerOption(false, false);\n  expectRefreshTimerOption(0, false);\n  expectRefreshTimerOption(1, 1000);\n  expectRefreshTimerOption(10, 10000);\n  expectRefreshTimerOption(true, 30000);\n\n  test('scheduledRefreshTimer is disabled with CUBEJS_REFRESH_WORKER', async () => {\n    process.env.CUBEJS_REFRESH_WORKER = 'false';\n\n    const cubejsServerCore = new CubejsServerCoreOpen({\n      dbType: 'mysql',\n      apiSecret: 'secret',\n    });\n    expect(cubejsServerCore).toBeInstanceOf(CubejsServerCore);\n    expect(cubejsServerCore.options.scheduledRefreshTimer).toBe(false);\n\n    await cubejsServerCore.beforeShutdown();\n    await cubejsServerCore.shutdown();\n  });\n\n  const testRefreshWorkerAndRollupModes = (\n    { setRefreshWorker, setScheduledRefresh, setScheduledRefreshTimer, testName, options }: {\n      setRefreshWorker?: boolean,\n      setScheduledRefresh?: boolean,\n      setScheduledRefreshTimer?: boolean | number,\n      testName?: string,\n      options?: CreateOptions\n    },\n    rollupOnlyMode: boolean,\n    assertFn: (options: OrchestratorApiOptions) => void,\n  ) => {\n    const paramsToName = JSON.stringify({\n      setRefreshWorker,\n      setScheduledRefresh,\n      setScheduledRefreshTimer,\n      rollupOnlyMode\n    });\n\n    test(testName || `scheduledRefreshTimer option setRefreshWorker: ${paramsToName})}`, async () => {\n      if (setRefreshWorker !== undefined) {\n        process.env.CUBEJS_REFRESH_WORKER = setRefreshWorker.toString();\n      }\n\n      if (setScheduledRefresh !== undefined) {\n        process.env.CUBEJS_SCHEDULED_REFRESH = setScheduledRefresh.toString();\n      }\n\n      if (setScheduledRefreshTimer !== undefined) {\n        process.env.CUBEJS_SCHEDULED_REFRESH_TIMER = setScheduledRefreshTimer.toString();\n      }\n\n      process.env.CUBEJS_ROLLUP_ONLY = rollupOnlyMode.toString();\n\n      const cubejsServerCore = new CubejsServerCoreOpen({\n        dbType: 'mysql',\n        apiSecret: 'secret',\n        ...options,\n      });\n      expect(cubejsServerCore).toBeInstanceOf(CubejsServerCore);\n\n      const createOrchestratorApiSpy = jest.spyOn(cubejsServerCore, 'createOrchestratorApi');\n\n      cubejsServerCore.getOrchestratorApi({\n        requestId: 'XXX',\n        authInfo: null,\n        securityContext: null,\n      });\n      expect(createOrchestratorApiSpy.mock.calls.length).toEqual(1);\n      assertFn(createOrchestratorApiSpy.mock.calls[0][1]);\n\n      createOrchestratorApiSpy.mockRestore();\n\n      await cubejsServerCore.beforeShutdown();\n      await cubejsServerCore.shutdown();\n    });\n  };\n\n  testRefreshWorkerAndRollupModes({ setRefreshWorker: true }, false, (options) => {\n    expect(options.preAggregationsOptions.externalRefresh).toEqual(false);\n    expect(options.rollupOnlyMode).toEqual(false);\n  });\n\n  testRefreshWorkerAndRollupModes({ setRefreshWorker: false }, true, (options) => {\n    expect(options.preAggregationsOptions.externalRefresh).toEqual(true);\n    expect(options.rollupOnlyMode).toEqual(true);\n  });\n\n  testRefreshWorkerAndRollupModes({ setRefreshWorker: true }, true, (options) => {\n    expect(options.rollupOnlyMode).toEqual(true);\n    // External refresh is enabled for rollupOnlyMode, but it's disabled\n    // when it's both refreshWorkerMode & rollupOnlyMode\n    expect(options.preAggregationsOptions.externalRefresh).toEqual(false);\n  });\n\n  // Old env, but anyway we should handle it\n  testRefreshWorkerAndRollupModes({ setScheduledRefresh: true }, true, (options) => {\n    expect(options.rollupOnlyMode).toEqual(true);\n    // External refresh is enabled for rollupOnlyMode, but it's disabled\n    // when it's both refreshWorkerMode & rollupOnlyMode\n    expect(options.preAggregationsOptions.externalRefresh).toEqual(false);\n  });\n\n  // Old env, but anyway we should handle it\n  testRefreshWorkerAndRollupModes({ setScheduledRefreshTimer: false }, true, (options) => {\n    expect(options.rollupOnlyMode).toEqual(true);\n    expect(options.preAggregationsOptions.externalRefresh).toEqual(true);\n  });\n\n  // Old env, but anyway we should handle it\n  testRefreshWorkerAndRollupModes({ setScheduledRefreshTimer: true }, true, (options) => {\n    expect(options.rollupOnlyMode).toEqual(true);\n    // External refresh is enabled for rollupOnlyMode, but it's disabled\n    // when it's both refreshWorkerMode & rollupOnlyMode\n    expect(options.preAggregationsOptions.externalRefresh).toEqual(false);\n  });\n\n  // Old env, but anyway we should handle it\n  testRefreshWorkerAndRollupModes({ setScheduledRefreshTimer: 30 }, true, (options) => {\n    expect(options.rollupOnlyMode).toEqual(true);\n    // External refresh is enabled for rollupOnlyMode, but it's disabled\n    // when it's both refreshWorkerMode & rollupOnlyMode\n    expect(options.preAggregationsOptions.externalRefresh).toEqual(false);\n  });\n\n  // Cube.js can override env\n  testRefreshWorkerAndRollupModes(\n    {\n      testName: 'Override scheduledRefreshTimer (true) & rollupOnlyMode from cube.js',\n      // cube.js\n      options: {\n        scheduledRefreshTimer: true,\n        orchestratorOptions: {\n          rollupOnlyMode: true,\n        }\n      }\n    },\n    false,\n    (options) => {\n      expect(options.rollupOnlyMode).toEqual(true);\n      // External refresh is enabled for rollupOnlyMode, but it's disabled\n      // when it's both refreshWorkerMode & rollupOnlyMode\n      expect(options.preAggregationsOptions.externalRefresh).toEqual(false);\n    }\n  );\n\n  // Cube.js can override env\n  testRefreshWorkerAndRollupModes(\n    {\n      testName: 'Override scheduledRefreshTimer (false) & rollupOnlyMode from cube.js',\n      // cube.js\n      options: {\n        scheduledRefreshTimer: false,\n        orchestratorOptions: {\n          rollupOnlyMode: true,\n        }\n      }\n    },\n    false,\n    (options) => {\n      expect(options.rollupOnlyMode).toEqual(true);\n      expect(options.preAggregationsOptions.externalRefresh).toEqual(true);\n    }\n  );\n\n  test('scheduledRefreshContexts option', async () => {\n    jest.spyOn(\n      CubejsServerCoreOpen.prototype,\n      'isReadyForQueryProcessing',\n    ).mockImplementation(\n      () => true,\n    );\n\n    const cubejsServerCore = new CubejsServerCoreOpen({\n      dbType: 'mysql',\n      apiSecret: 'secret',\n      // 250ms\n      scheduledRefreshTimer: 1,\n      scheduledRefreshConcurrency: 2,\n      scheduledRefreshContexts: async () => [\n        {\n          securityContext: {\n            appid: 'test1',\n            u: {\n              prop1: 'value1'\n            }\n          }\n        },\n        // securityContext is required in typings, but can be empty in user-space\n        <any>{\n          // Renamed to securityContext, let's test that it migrate automatically\n          authInfo: {\n            appid: 'test2',\n            u: {\n              prop2: 'value2'\n            }\n          },\n        },\n        // Null is a default placeholder\n        null\n      ],\n    });\n\n    const timeoutKiller = withTimeout(\n      () => {\n        throw new Error('runScheduledRefresh was not called');\n      },\n      2 * 1000,\n    );\n\n    const refreshSchedulerMock = {\n      runScheduledRefresh: jest.fn(async () => {\n        await timeoutKiller.cancel();\n        return {\n          finished: true,\n        };\n      })\n    };\n\n    jest.spyOn(cubejsServerCore, 'getRefreshScheduler').mockImplementation(() => <any>refreshSchedulerMock);\n\n    await timeoutKiller;\n\n    expect(cubejsServerCore).toBeInstanceOf(CubejsServerCoreOpen);\n    expect(refreshSchedulerMock.runScheduledRefresh.mock.calls.length).toEqual(3);\n    expect(refreshSchedulerMock.runScheduledRefresh.mock.calls[0]).toEqual([\n      {\n        authInfo: { appid: 'test1', u: { prop1: 'value1' } },\n        securityContext: { appid: 'test1', u: { prop1: 'value1' } },\n      },\n      { concurrency: 2 },\n    ]);\n    expect(refreshSchedulerMock.runScheduledRefresh.mock.calls[1]).toEqual([\n      {\n        authInfo: { appid: 'test2', u: { prop2: 'value2' } },\n        securityContext: { appid: 'test2', u: { prop2: 'value2' } },\n      },\n      { concurrency: 2 },\n    ]);\n    expect(refreshSchedulerMock.runScheduledRefresh.mock.calls[2]).toEqual([\n      // RefreshScheduler will populate it\n      null,\n      { concurrency: 2 },\n    ]);\n\n    await cubejsServerCore.beforeShutdown();\n    await cubejsServerCore.shutdown();\n\n    jest.restoreAllMocks();\n  });\n});\n"], "filenames": ["packages/cubejs-api-gateway/src/gateway.ts", "packages/cubejs-server-core/src/core/CompilerApi.js", "packages/cubejs-server-core/test/unit/index.test.ts"], "buggy_code_start_loc": [451, 67, 43], "buggy_code_end_loc": [470, 191, 389], "fixing_code_start_loc": [451, 66, 42], "fixing_code_end_loc": [470, 185, 337], "type": "CWE-89", "message": "cube-js is a headless business intelligence platform. In version 0.31.23 all authenticated Cube clients could bypass SQL row-level security and run arbitrary SQL via the newly introduced /v1/sql-runner endpoint. This issue has been resolved in version 0.31.24. Users are advised to either upgrade to 0.31.24 or to downgrade to 0.31.22. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2022-23510", "sourceIdentifier": "security-advisories@github.com", "published": "2022-12-09T23:15:22.227", "lastModified": "2022-12-13T15:07:13.027", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "cube-js is a headless business intelligence platform. In version 0.31.23 all authenticated Cube clients could bypass SQL row-level security and run arbitrary SQL via the newly introduced /v1/sql-runner endpoint. This issue has been resolved in version 0.31.24. Users are advised to either upgrade to 0.31.24 or to downgrade to 0.31.22. There are no known workarounds for this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.6, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 5.8}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cube:cube.js:0.31.23:*:*:*:*:node.js:*:*", "matchCriteriaId": "DE64AB39-926F-4408-807E-86F1E6C917FC"}]}]}], "references": [{"url": "https://github.com/cube-js/cube.js/commit/3c614674fed6ca17df08bbba8c835ef110167570", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/cube-js/cube.js/commit/f1140de508e359970ac82b50bae1c4bf152f6041", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/cube-js/cube.js/security/advisories/GHSA-6jqm-3c9g-pch7", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/cube-js/cube.js/commit/3c614674fed6ca17df08bbba8c835ef110167570"}}