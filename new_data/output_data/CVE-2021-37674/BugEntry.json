{"buggy_code": ["/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/nn_ops.cc.\n\n#define EIGEN_USE_THREADS\n\n#include \"tensorflow/core/kernels/maxpooling_op.h\"\n\n#include <type_traits>\n#include <vector>\n\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/common_runtime/device.h\"\n#include \"tensorflow/core/framework/bounds_check.h\"\n#include \"tensorflow/core/framework/numeric_op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/tensor_slice.h\"\n#include \"tensorflow/core/kernels/conv_2d.h\"\n#include \"tensorflow/core/kernels/eigen_pooling.h\"\n#include \"tensorflow/core/kernels/ops_util.h\"\n#include \"tensorflow/core/kernels/pooling_ops_common.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/gtl/array_slice.h\"\n#include \"tensorflow/core/util/env_var.h\"\n#include \"tensorflow/core/util/padding.h\"\n#include \"tensorflow/core/util/tensor_format.h\"\n#include \"tensorflow/core/util/use_cudnn.h\"\n\n#if GOOGLE_CUDA\n#include \"third_party/gpus/cudnn/cudnn.h\"\n#endif  // GOOGLE_CUDA\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#include \"tensorflow/core/kernels/maxpooling_op_gpu.h\"\n#include \"tensorflow/core/kernels/pooling_ops_common_gpu.h\"\n#include \"tensorflow/core/platform/stream_executor.h\"\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\nnamespace tensorflow {\n\ntypedef Eigen::ThreadPoolDevice CPUDevice;\ntypedef Eigen::GpuDevice GPUDevice;\n\nconst int kInvalidMaxPoolingIndex = -1;\n\ntemplate <typename Device, typename T, typename Targmax>\nstatic void SpatialMaxPoolWithArgMaxHelper(\n    OpKernelContext* context, Tensor* output, Tensor* output_arg_max,\n    Tensor* input_backprop, const Tensor& tensor_in, const Tensor& out_backprop,\n    const PoolParameters& params, const bool include_batch_in_index) {\n  if (input_backprop != nullptr) {\n    OP_REQUIRES(\n        context, include_batch_in_index,\n        errors::Internal(\n            \"SpatialMaxPoolWithArgMaxHelper requires include_batch_in_index \"\n            \"to be True when input_backprop != nullptr\"));\n    OP_REQUIRES(\n        context, (std::is_same<Targmax, int64>::value),\n        errors::Internal(\"SpatialMaxPoolWithArgMaxHelper requires Targmax \"\n                         \"to be int64 when input_backprop != nullptr\"));\n  }\n\n  typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n      ConstEigenMatrixMap;\n  typedef Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n      EigenMatrixMap;\n  typedef Eigen::Map<Eigen::Matrix<Targmax, Eigen::Dynamic, Eigen::Dynamic>>\n      EigenIndexMatrixMap;\n\n  ConstEigenMatrixMap in_mat(\n      tensor_in.flat<T>().data(), params.depth,\n      params.tensor_in_cols * params.tensor_in_rows * params.tensor_in_batch);\n  EigenMatrixMap out_mat(\n      output->flat<T>().data(), params.depth,\n      params.out_width * params.out_height * params.tensor_in_batch);\n  EigenIndexMatrixMap out_arg_max_mat(\n      output_arg_max->flat<Targmax>().data(), params.depth,\n      params.out_width * params.out_height * params.tensor_in_batch);\n\n  const DeviceBase::CpuWorkerThreads& worker_threads =\n      *(context->device()->tensorflow_cpu_worker_threads());\n\n  // The following code basically does the following:\n  // 1. Flattens the input and output tensors into two dimensional arrays.\n  //    tensor_in_as_matrix:\n  //      depth by (tensor_in_cols * tensor_in_rows * tensor_in_batch)\n  //    output_as_matrix:\n  //      depth by (out_width * out_height * tensor_in_batch)\n  //\n  // 2. Walks through the set of columns in the flattened tensor_in_as_matrix,\n  //    and updates the corresponding column(s) in output_as_matrix with the\n  //    max value.\n  auto shard = [&params, &in_mat, &out_mat, &out_arg_max_mat, &input_backprop,\n                &output_arg_max, &out_backprop,\n                include_batch_in_index](int64_t start, int64_t limit) {\n    const int32_t depth = params.depth;\n    const int32_t in_rows = params.tensor_in_rows;\n    const int32_t in_cols = params.tensor_in_cols;\n    const int32_t pad_top = params.pad_top;\n    const int32_t pad_left = params.pad_left;\n    const int32_t window_rows = params.window_rows;\n    const int32_t window_cols = params.window_cols;\n    const int32_t row_stride = params.row_stride;\n    const int32_t col_stride = params.col_stride;\n    const int32_t out_height = params.out_height;\n    const int32_t out_width = params.out_width;\n\n    {\n      // Initializes the output tensor with MIN<T>.\n      const int32_t output_image_size = out_height * out_width * depth;\n      EigenMatrixMap out_shard(out_mat.data() + start * output_image_size, 1,\n                               (limit - start) * output_image_size);\n      out_shard.setConstant(Eigen::NumTraits<T>::lowest());\n      EigenIndexMatrixMap out_arg_max_shard(\n          out_arg_max_mat.data() + start * output_image_size, 1,\n          (limit - start) * output_image_size);\n      out_arg_max_shard.setConstant(kInvalidMaxPoolingIndex);\n    }\n\n    for (int64_t b = start; b < limit; ++b) {\n      for (int h = 0; h < in_rows; ++h) {\n        for (int w = 0; w < in_cols; ++w) {\n          // (h_start, h_end) * (w_start, w_end) is the range that the input\n          // vector projects to.\n          const int hpad = h + pad_top;\n          const int wpad = w + pad_left;\n          const int h_start =\n              (hpad < window_rows) ? 0 : (hpad - window_rows) / row_stride + 1;\n          const int h_end = std::min(hpad / row_stride + 1, out_height);\n          const int w_start =\n              (wpad < window_cols) ? 0 : (wpad - window_cols) / col_stride + 1;\n          const int w_end = std::min(wpad / col_stride + 1, out_width);\n          // compute elementwise max\n          const int64_t in_index = (b * in_rows + h) * in_cols + w;\n          for (int ph = h_start; ph < h_end; ++ph) {\n            const int64_t out_index_base = (b * out_height + ph) * out_width;\n            for (int pw = w_start; pw < w_end; ++pw) {\n              const int64_t out_index = out_index_base + pw;\n              /// NOTES(zhengxq): not using the eigen matrix operation for\n              /// now.\n              for (int d = 0; d < depth; ++d) {\n                const T& input_ref = in_mat.coeffRef(d, in_index);\n                T& output_ref = out_mat.coeffRef(d, out_index);\n                Targmax& out_arg_max_ref =\n                    out_arg_max_mat.coeffRef(d, out_index);\n                if (output_ref < input_ref ||\n                    out_arg_max_ref == kInvalidMaxPoolingIndex) {\n                  output_ref = input_ref;\n                  if (include_batch_in_index) {\n                    out_arg_max_ref = in_index * depth + d;\n                  } else {\n                    out_arg_max_ref = (h * in_cols + w) * depth + d;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (input_backprop != nullptr) {\n      auto input_backprop_flat = input_backprop->flat<T>();\n      auto out_arg_max_flat = output_arg_max->flat<int64>();\n      auto out_backprop_flat = out_backprop.flat<T>();\n\n      // Initialize output to 0.\n      const int64_t in_size = in_rows * in_cols * depth;\n      const int64_t in_start = start * in_size;\n      const int64_t in_end = limit * in_size;\n      EigenMatrixMap in_shard(input_backprop_flat.data() + in_start, 1,\n                              in_end - in_start);\n      in_shard.setConstant(T(0));\n\n      // Backpropagate.\n      const int out_size = out_height * out_width * depth;\n      const int out_start = start * out_size;\n      const int out_end = limit * out_size;\n      for (int index = out_start; index < out_end; ++index) {\n        int input_backprop_index = out_arg_max_flat(index);\n        // Although this check is in the inner loop, it is worth its value\n        // so we don't end up with memory corruptions. Our benchmark shows that\n        // the performance impact is quite small\n        // CHECK(input_backprop_index >= in_start && input_backprop_index <\n        // in_end)\n        FastBoundsCheck(input_backprop_index - in_start, in_end - in_start);\n        if (index < out_backprop.NumElements()) {\n          input_backprop_flat(input_backprop_index) += out_backprop_flat(index);\n        }\n      }\n    }\n  };\n\n  const int64_t shard_cost = params.tensor_in_rows * params.tensor_in_cols *\n                             params.depth * params.window_rows *\n                             params.window_cols;\n  Shard(worker_threads.num_threads, worker_threads.workers,\n        params.tensor_in_batch, shard_cost, shard);\n}\n\n// The operation to compute MaxPool gradients.\n// It takes three inputs:\n//   - The original input tensor\n//   - The original output tensor\n//   - Backprop tensor for output\n// It produces one output: backprop tensor for input.\ntemplate <class Device, class T>\nclass MaxPoolingGradOp : public OpKernel {\n public:\n  explicit MaxPoolingGradOp(OpKernelConstruction* context) : OpKernel(context) {\n    string data_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n    OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                errors::InvalidArgument(\"Invalid data format\"));\n    OP_REQUIRES(\n        context, data_format_ == FORMAT_NHWC,\n        errors::InvalidArgument(\"Default MaxPoolingGradOp only supports NHWC \",\n                                \"on device type \",\n                                DeviceTypeString(context->device_type())));\n\n    if (context->num_inputs() == 3) {\n      OP_REQUIRES_OK(context, context->GetAttr(\"ksize\", &ksize_));\n      OP_REQUIRES(context, ksize_.size() == 4,\n                  errors::InvalidArgument(\"Sliding window ksize field must \"\n                                          \"specify 4 dimensions\"));\n      OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n      OP_REQUIRES(context, stride_.size() == 4,\n                  errors::InvalidArgument(\"Sliding window strides field must \"\n                                          \"specify 4 dimensions\"));\n      OP_REQUIRES(context, ksize_[0] == 1 && stride_[0] == 1,\n                  errors::Unimplemented(\n                      \"Pooling is not yet supported on the batch dimension.\"));\n      OP_REQUIRES(\n          context, ksize_[3] == 1 && stride_[3] == 1,\n          errors::Unimplemented(\n              \"MaxPoolingGrad is not yet supported on the depth dimension.\"));\n    }\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n\n    if (padding_ == Padding::EXPLICIT) {\n      OP_REQUIRES_OK(\n          context, context->GetAttr(\"explicit_paddings\", &explicit_paddings_));\n      OP_REQUIRES_OK(context, CheckValidPadding(padding_, explicit_paddings_,\n                                                /*num_dims=*/4, data_format_));\n    }\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& tensor_out = context->input(1);\n    const Tensor& out_backprop = context->input(2);\n\n    // For maxpooling, tensor_in should have 4 dimensions.\n    OP_REQUIRES(context, tensor_in.dims() == 4,\n                errors::InvalidArgument(\"tensor_in must be 4-dimensional\"));\n    OP_REQUIRES(context, tensor_out.dims() == 4,\n                errors::InvalidArgument(\"tensor_out must be 4-dimensional\"));\n    // For maxpooling, out_backprop should have 4 dimensions.\n    OP_REQUIRES(context, out_backprop.dims() == 4,\n                errors::InvalidArgument(\"out_backprop must be 4-dimensional\"));\n\n    const TensorShape& output_shape = tensor_in.shape();\n\n    Tensor tensor_out_dup;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_temp(\n                                {1}, DataTypeToEnum<T>::v(), tensor_out.shape(),\n                                &tensor_out_dup));\n    Tensor tensor_out_arg_max;\n    OP_REQUIRES_OK(context, context->allocate_temp(DataTypeToEnum<int64>::v(),\n                                                   tensor_out.shape(),\n                                                   &tensor_out_arg_max));\n    std::vector<int32> ksize = ksize_;\n    std::vector<int32> stride = stride_;\n    if (context->num_inputs() == 5) {\n      const Tensor& tensor_ksize = context->input(3);\n      auto value_ksize = tensor_ksize.flat<int32>();\n      ksize.resize(tensor_ksize.shape().num_elements());\n      std::copy_n(&value_ksize(0), ksize.size(), ksize.begin());\n\n      const Tensor& tensor_stride = context->input(4);\n      auto value_stride = tensor_stride.flat<int32>();\n      stride.resize(tensor_stride.shape().num_elements());\n      std::copy_n(&value_stride(0), stride.size(), stride.begin());\n    }\n\n    OP_REQUIRES(context, ksize.size() == 4,\n                errors::InvalidArgument(\"Sliding window ksize field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES(context, stride.size() == 4,\n                errors::InvalidArgument(\"Sliding window strides field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES(context, ksize[0] == 1 && stride[0] == 1,\n                errors::Unimplemented(\n                    \"Pooling is not yet supported on the batch dimension.\"));\n    OP_REQUIRES(\n        context, ksize[3] == 1 && stride[3] == 1,\n        errors::Unimplemented(\n            \"MaxPoolingGrad is not yet supported on the depth dimension.\"));\n\n    PoolParameters params{context,\n                          ksize,\n                          stride,\n                          padding_,\n                          explicit_paddings_,\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, output_shape, &output));\n\n    SpatialMaxPoolWithArgMaxHelper<CPUDevice, T, int64>(\n        context, &tensor_out_dup, &tensor_out_arg_max, output, tensor_in,\n        out_backprop, params, true);\n  }\n\n private:\n  std::vector<int32> ksize_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  std::vector<int64> explicit_paddings_;\n  TensorFormat data_format_;\n};\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\ntemplate <class T>\nclass MaxPoolingGradOp<Eigen::GpuDevice, T> : public OpKernel {\n public:\n  typedef Eigen::GpuDevice Device;\n\n  explicit MaxPoolingGradOp(OpKernelConstruction* context) : OpKernel(context) {\n    string data_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n    OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                errors::InvalidArgument(\"Invalid data format\"));\n    if (context->num_inputs() == 3) {\n      OP_REQUIRES_OK(context, context->GetAttr(\"ksize\", &ksize_));\n      OP_REQUIRES(context, ksize_.size() == 4,\n                  errors::InvalidArgument(\"Sliding window ksize field must \"\n                                          \"specify 4 dimensions\"));\n      OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n      OP_REQUIRES(context, stride_.size() == 4,\n                  errors::InvalidArgument(\"Sliding window strides field must \"\n                                          \"specify 4 dimensions\"));\n      const int32_t ksize_n = GetTensorDim(ksize_, data_format_, 'N');\n      const int32_t stride_n = GetTensorDim(stride_, data_format_, 'N');\n      OP_REQUIRES(context, ksize_n == 1 && stride_n == 1,\n                  errors::Unimplemented(\n                      \"Pooling is not yet supported on the batch dimension.\"));\n    }\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n    if (padding_ == Padding::EXPLICIT) {\n      OP_REQUIRES_OK(\n          context, context->GetAttr(\"explicit_paddings\", &explicit_paddings_));\n      OP_REQUIRES_OK(context, CheckValidPadding(padding_, explicit_paddings_,\n                                                /*num_dims=*/4, data_format_));\n    }\n    TF_CHECK_OK(ReadBoolFromEnvVar(\"TF_ENABLE_MAXPOOL_NANPROP\", false,\n                                   &propagate_nans_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& tensor_out = context->input(1);\n    const Tensor& out_backprop = context->input(2);\n\n    // For maxpooling, tensor_in should have 4 dimensions.\n    OP_REQUIRES(context, tensor_in.dims() == 4,\n                errors::InvalidArgument(\"tensor_in must be 4-dimensional 4\"));\n    OP_REQUIRES(context, tensor_out.dims() == 4,\n                errors::InvalidArgument(\"tensor_out must be 4-dimensional\"));\n    // For maxpooling, out_backprop should have 4 dimensions.\n    OP_REQUIRES(context, out_backprop.dims() == 4,\n                errors::InvalidArgument(\"out_backprop must be 4-dimensional\"));\n\n    TensorShape output_shape = tensor_in.shape();\n\n    std::vector<int32> ksize = ksize_;\n    std::vector<int32> stride = stride_;\n    if (context->num_inputs() == 5) {\n      const Tensor& tensor_ksize = context->input(3);\n      auto value_ksize = tensor_ksize.flat<int32>();\n      ksize.resize(tensor_ksize.shape().num_elements());\n      std::copy_n(&value_ksize(0), ksize.size(), ksize.begin());\n\n      const Tensor& tensor_stride = context->input(4);\n      auto value_stride = tensor_stride.flat<int32>();\n      stride.resize(tensor_stride.shape().num_elements());\n      std::copy_n(&value_stride(0), stride.size(), stride.begin());\n    }\n    OP_REQUIRES(context, ksize.size() == 4,\n                errors::InvalidArgument(\"Sliding window ksize field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES(context, stride.size() == 4,\n                errors::InvalidArgument(\"Sliding window strides field must \"\n                                        \"specify 4 dimensions\"));\n    const int32_t ksize_n = GetTensorDim(ksize, data_format_, 'N');\n    const int32_t stride_n = GetTensorDim(stride, data_format_, 'N');\n    OP_REQUIRES(context, ksize_n == 1 && stride_n == 1,\n                errors::Unimplemented(\n                    \"Pooling is not yet supported on the batch dimension.\"));\n    int64_t pad_top, pad_bottom, pad_left, pad_right;\n    if (padding_ == Padding::EXPLICIT) {\n      GetExplicitPaddingForDim(explicit_paddings_, data_format_, 'H',\n                               /*pad_top=*/&pad_top,\n                               /*pad_bottom=*/&pad_bottom);\n      GetExplicitPaddingForDim(explicit_paddings_, data_format_, 'W',\n                               /*pad_left=*/&pad_left,\n                               /*pad_right=*/&pad_right);\n    }\n    DnnPoolingGradOp<T>::Compute(context, se::dnn::PoolingMode::kMaximum, ksize,\n                                 stride, padding_, explicit_paddings_,\n                                 data_format_, &tensor_in, &tensor_out,\n                                 out_backprop, output_shape, propagate_nans_);\n  }\n\n private:\n  std::vector<int32> ksize_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  std::vector<int64> explicit_paddings_;\n  TensorFormat data_format_;\n  bool propagate_nans_;\n};\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n// The operation to compute gradient of MaxPool gradients.\n// It takes three inputs:\n//   - The original input tensor\n//   - The original output tensor\n//   - Backprop tensor for output gradients\n// It produces one output: backprop tensor for output gradient.\ntemplate <class Device, class T>\nclass MaxPoolingGradGradOp : public OpKernel {\n public:\n  explicit MaxPoolingGradGradOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string data_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n    OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                errors::InvalidArgument(\"Invalid data format\"));\n    OP_REQUIRES(\n        context, data_format_ == FORMAT_NHWC,\n        errors::InvalidArgument(\n            \"Default MaxPoolingGradGradOp only supports NHWC \",\n            \"on device type \", DeviceTypeString(context->device_type())));\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n\n    if (context->num_inputs() == 3) {\n      OP_REQUIRES_OK(context, context->GetAttr(\"ksize\", &ksize_));\n      OP_REQUIRES(context, ksize_.size() == 4,\n                  errors::InvalidArgument(\"Sliding window ksize field must \"\n                                          \"specify 4 dimensions\"));\n      OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n      OP_REQUIRES(context, stride_.size() == 4,\n                  errors::InvalidArgument(\"Sliding window strides field must \"\n                                          \"specify 4 dimensions\"));\n      OP_REQUIRES(context, ksize_[0] == 1 && stride_[0] == 1,\n                  errors::Unimplemented(\n                      \"Pooling is not yet supported on the batch dimension.\"));\n      OP_REQUIRES(context, ksize_[3] == 1 && stride_[3] == 1,\n                  errors::Unimplemented(\"MaxPoolingGradGrad is not yet \"\n                                        \"supported on the depth dimension.\"));\n    }\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& tensor_out = context->input(1);\n    const Tensor& out_grad_backprop = context->input(2);\n\n    // For maxpooling, tensor_in should have 4 dimensions.\n    OP_REQUIRES(context, tensor_in.dims() == 4,\n                errors::InvalidArgument(\"tensor_in must be 4-dimensional\"));\n    OP_REQUIRES(context, tensor_out.dims() == 4,\n                errors::InvalidArgument(\"tensor_out must be 4-dimensional\"));\n    // For maxpooling, out_grad_backprop should have 4 dimensions.\n    OP_REQUIRES(\n        context, out_grad_backprop.dims() == 4,\n        errors::InvalidArgument(\"out_grad_backprop must be 4-dimensional\"));\n\n    std::vector<int32> ksize = ksize_;\n    std::vector<int32> stride = stride_;\n    if (context->num_inputs() == 5) {\n      const Tensor& tensor_ksize = context->input(3);\n      auto value_ksize = tensor_ksize.flat<int32>();\n      ksize.resize(tensor_ksize.shape().num_elements());\n      std::copy_n(&value_ksize(0), ksize.size(), ksize.begin());\n\n      const Tensor& tensor_stride = context->input(4);\n      auto value_stride = tensor_stride.flat<int32>();\n      stride.resize(tensor_stride.shape().num_elements());\n      std::copy_n(&value_stride(0), stride.size(), stride.begin());\n    }\n\n    OP_REQUIRES(context, ksize.size() == 4,\n                errors::InvalidArgument(\"Sliding window ksize field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES(context, stride.size() == 4,\n                errors::InvalidArgument(\"Sliding window strides field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES(context, ksize[0] == 1 && stride[0] == 1,\n                errors::Unimplemented(\n                    \"Pooling is not yet supported on the batch dimension.\"));\n    OP_REQUIRES(\n        context, ksize[3] == 1 && stride[3] == 1,\n        errors::Unimplemented(\n            \"MaxPoolingGrad is not yet supported on the depth dimension.\"));\n\n    PoolParameters params{context,\n                          ksize,\n                          stride,\n                          padding_,\n                          /*explicit_paddings=*/{},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {2}, 0, tensor_out.shape(), &output));\n\n    SpatialMaxPoolGradGrad(context, output, tensor_in, tensor_out,\n                           out_grad_backprop, params, padding_);\n  }\n\n private:\n  void SpatialMaxPoolGradGrad(OpKernelContext* context, Tensor* bottom_diff,\n                              const Tensor& tensor_in, const Tensor& tensor_out,\n                              const Tensor& top_diff,\n                              const PoolParameters& params,\n                              const Padding& padding) {\n    typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n        ConstEigenMatrixMap;\n    typedef Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n        EigenMatrixMap;\n\n    ConstEigenMatrixMap in_mat(\n        tensor_in.flat<T>().data(), params.depth,\n        params.tensor_in_cols * params.tensor_in_rows * params.tensor_in_batch);\n    ConstEigenMatrixMap out_mat(\n        tensor_out.flat<T>().data(), params.depth,\n        params.out_width * params.out_height * params.tensor_in_batch);\n    ConstEigenMatrixMap top_diff_mat(\n        top_diff.flat<T>().data(), params.depth,\n        params.tensor_in_cols * params.tensor_in_rows * params.tensor_in_batch);\n    EigenMatrixMap bottom_diff_mat(\n        bottom_diff->flat<T>().data(), params.depth,\n        params.out_width * params.out_height * params.tensor_in_batch);\n\n    const DeviceBase::CpuWorkerThreads& worker_threads =\n        *(context->device()->tensorflow_cpu_worker_threads());\n\n    // The following code basically does the following:\n    // 1. Flattens the input, output, top_diff and bottom_diff tensors into\n    //    two dimensional arrays.\n    //    tensor_in_as_matrix:\n    //      depth by (tensor_in_cols * tensor_in_rows * tensor_in_batch)\n    //    tensor_out_as_matrix:\n    //      depth by (out_width * out_height * tensor_in_batch)\n    //    top_diff_as_matrix:\n    //      depth by (tensor_in_cols * tensor_in_rows * tensor_in_batch)\n    //    bottom_diff_as_matrix:\n    //      depth by (out_width * out_height * tensor_in_batch)\n    //\n    // 2. Walks through the set of columns in the flattened\n    //    tensor_in_as_matrix, tensor_out_as_matrix, top_diff_as_matrix\n    //    and updates the column(s) corresponding to the maximum values in\n    //    tensor_out_as_matrix with the corresponding values in\n    //    top_diff_as_matrix.\n    auto shard = [&params, &in_mat, &out_mat, &top_diff_mat, &bottom_diff_mat](\n                     int64_t start, int64_t limit) {\n      const int32_t depth = params.depth;\n      const int32_t in_rows = params.tensor_in_rows;\n      const int32_t in_cols = params.tensor_in_cols;\n      const int32_t pad_top = params.pad_top;\n      const int32_t pad_left = params.pad_left;\n      const int32_t window_rows = params.window_rows;\n      const int32_t window_cols = params.window_cols;\n      const int32_t row_stride = params.row_stride;\n      const int32_t col_stride = params.col_stride;\n      const int32_t out_height = params.out_height;\n      const int32_t out_width = params.out_width;\n\n      {\n        // Initializes the output grad backprop tensor with 0.\n        const int32_t output_image_size = out_height * out_width * params.depth;\n        EigenMatrixMap bottom_diff_shard(\n            bottom_diff_mat.data() + start * output_image_size, 1,\n            (limit - start) * output_image_size);\n        bottom_diff_shard.setZero();\n      }\n\n      for (int b = start; b < limit; ++b) {\n        for (int ph = 0; ph < out_height; ++ph) {\n          for (int pw = 0; pw < out_width; ++pw) {\n            // (h_start, h_end) * (w_start, w_end) is the range that the input\n            // vector projects to.\n            int h_start = ph * row_stride - pad_top;\n            const int h_end = std::min(h_start + window_rows, in_rows);\n            int w_start = pw * col_stride - pad_left;\n            const int w_end = std::min(w_start + window_cols, in_cols);\n            h_start = std::max(h_start, 0);\n            w_start = std::max(w_start, 0);\n            const int out_index = (b * out_height + ph) * out_width + pw;\n            // Find value corresponding to the input maximum in top_diff.\n            for (int d = 0; d < depth; ++d) {\n              const T& output_ref = out_mat.coeffRef(d, out_index);\n              bool should_stop = false;\n              for (int h = h_start; h < h_end && !should_stop; ++h) {\n                for (int w = w_start; w < w_end && !should_stop; ++w) {\n                  const int in_index = (b * in_rows + h) * in_cols + w;\n                  const T& input_ref = in_mat.coeffRef(d, in_index);\n                  if (output_ref == input_ref) {\n                    T& bottom_diff_ref = bottom_diff_mat.coeffRef(d, out_index);\n                    bottom_diff_ref = top_diff_mat.coeffRef(d, in_index);\n                    should_stop = true;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    };\n\n    const int64_t shard_cost = params.out_width * params.out_height *\n                               params.depth * params.window_rows *\n                               params.window_cols;\n    Shard(worker_threads.num_threads, worker_threads.workers,\n          params.tensor_in_batch, shard_cost, shard);\n  }\n\n  std::vector<int32> ksize_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  TensorFormat data_format_;\n};\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\ntemplate <class T>\nclass MaxPoolingGradGradOp<Eigen::GpuDevice, T> : public OpKernel {\n public:\n  typedef Eigen::GpuDevice Device;\n\n  explicit MaxPoolingGradGradOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string data_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n    OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                errors::InvalidArgument(\"Invalid data format\"));\n    if (context->num_inputs() == 3) {\n      OP_REQUIRES_OK(context, context->GetAttr(\"ksize\", &ksize_));\n      OP_REQUIRES(context, ksize_.size() == 4,\n                  errors::InvalidArgument(\"Sliding window ksize field must \"\n                                          \"specify 4 dimensions\"));\n      OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n      OP_REQUIRES(context, stride_.size() == 4,\n                  errors::InvalidArgument(\"Sliding window strides field must \"\n                                          \"specify 4 dimensions\"));\n      const int32_t ksize_n = GetTensorDim(ksize_, data_format_, 'N');\n      const int32_t stride_n = GetTensorDim(stride_, data_format_, 'N');\n      OP_REQUIRES(context, ksize_n == 1 && stride_n == 1,\n                  errors::Unimplemented(\n                      \"Pooling is not yet supported on the batch dimension.\"));\n    }\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& tensor_out = context->input(1);\n    const Tensor& out_grad_backprop = context->input(2);\n\n    // For maxpooling, tensor_in should have 4 dimensions.\n    OP_REQUIRES(context, tensor_in.dims() == 4,\n                errors::InvalidArgument(\"tensor_in must be 4-dimensional 4\"));\n    OP_REQUIRES(context, tensor_out.dims() == 4,\n                errors::InvalidArgument(\"tensor_out must be 4-dimensional\"));\n    // For maxpooling, out_grad_backprop should have 4 dimensions.\n    OP_REQUIRES(\n        context, out_grad_backprop.dims() == 4,\n        errors::InvalidArgument(\"out_grad_backprop must be 4-dimensional\"));\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, tensor_out.shape(), &output));\n\n    std::vector<int32> ksize = ksize_;\n    std::vector<int32> stride = stride_;\n    if (context->num_inputs() == 5) {\n      const Tensor& tensor_ksize = context->input(3);\n      auto value_ksize = tensor_ksize.flat<int32>();\n      ksize.resize(tensor_ksize.shape().num_elements());\n      std::copy_n(&value_ksize(0), ksize.size(), ksize.begin());\n\n      const Tensor& tensor_stride = context->input(4);\n      auto value_stride = tensor_stride.flat<int32>();\n      stride.resize(tensor_stride.shape().num_elements());\n      std::copy_n(&value_stride(0), stride.size(), stride.begin());\n    }\n\n    OP_REQUIRES(context, ksize.size() == 4,\n                errors::InvalidArgument(\"Sliding window ksize field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES(context, stride.size() == 4,\n                errors::InvalidArgument(\"Sliding window strides field must \"\n                                        \"specify 4 dimensions\"));\n    const int32_t ksize_n = GetTensorDim(ksize, data_format_, 'N');\n    const int32_t stride_n = GetTensorDim(stride, data_format_, 'N');\n    OP_REQUIRES(context, ksize_n == 1 && stride_n == 1,\n                errors::Unimplemented(\n                    \"Pooling is not yet supported on the batch dimension.\"));\n\n    PoolParameters params{context,\n                          ksize,\n                          stride,\n                          padding_,\n                          /*explicit_paddings=*/{},\n                          data_format_,\n                          tensor_in.shape()};\n\n    functor::MaxPoolGradBackwardNoMask<T>()(\n        data_format_, tensor_in.flat<T>().data(), tensor_out.flat<T>().data(),\n        params.tensor_in_batch, params.out_height, params.out_width,\n        params.depth, params.tensor_in_rows, params.tensor_in_cols,\n        params.window_rows, params.window_cols, params.row_stride,\n        params.col_stride, params.pad_top, params.pad_left,\n        out_grad_backprop.flat<T>().data(), output->flat<T>().data(),\n        context->eigen_device<Eigen::GpuDevice>());\n  }\n\n private:\n  std::vector<int32> ksize_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  TensorFormat data_format_;\n  bool use_dnn_;\n};\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\ntemplate <typename Device, typename T>\nstruct LaunchMaxPoolingNoMask;\n\ntemplate <typename Device, typename T>\nclass MaxPoolingNoMaskOp : public OpKernel {\n public:\n  explicit MaxPoolingNoMaskOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string data_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n    OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                errors::InvalidArgument(\"Invalid data format\"));\n    OP_REQUIRES(\n        context, data_format_ == FORMAT_NHWC,\n        errors::InvalidArgument(\n            \"Default MaxPoolingNoMaskOp only supports NHWC on device type \",\n            DeviceTypeString(context->device_type())));\n    OP_REQUIRES_OK(context, context->GetAttr(\"ksize\", &ksize_));\n    OP_REQUIRES(context, ksize_.size() == 4,\n                errors::InvalidArgument(\"Sliding window ksize field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n    OP_REQUIRES(context, stride_.size() == 4,\n                errors::InvalidArgument(\"Sliding window stride field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n    OP_REQUIRES(context, ksize_[0] == 1 && stride_[0] == 1,\n                errors::Unimplemented(\n                    \"Pooling is not yet supported on the batch dimension.\"));\n    OP_REQUIRES(\n        context, padding_ != EXPLICIT,\n        errors::Unimplemented(\n            \"Explicit padding is not supported for MaxPoolingNoMaskOp.\"));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          /*explicit_paddings=*/{},\n                          data_format_,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n\n    TensorShape out_shape({params.tensor_in_batch, params.out_height,\n                           params.out_width, params.depth});\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));\n\n    LaunchMaxPoolingNoMask<Device, T>::launch(context, params, tensor_in,\n                                              output);\n  }\n\n private:\n  std::vector<int32> ksize_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  TensorFormat data_format_;\n};\n\ntemplate <typename Device, typename T>\nclass MaxPoolingNoMaskV2Op : public OpKernel {\n public:\n  explicit MaxPoolingNoMaskV2Op(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string data_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n    OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                errors::InvalidArgument(\"Invalid data format\"));\n    OP_REQUIRES(\n        context, data_format_ == FORMAT_NHWC,\n        errors::InvalidArgument(\n            \"Default MaxPoolingNoMaskOp only supports NHWC on device type \",\n            DeviceTypeString(context->device_type())));\n    if (context->num_inputs() == 1) {\n      OP_REQUIRES_OK(context, context->GetAttr(\"ksize\", &ksize_));\n      OP_REQUIRES(context, ksize_.size() == 4,\n                  errors::InvalidArgument(\"Sliding window ksize field must \"\n                                          \"specify 4 dimensions\"));\n      OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n      OP_REQUIRES(context, stride_.size() == 4,\n                  errors::InvalidArgument(\"Sliding window stride field must \"\n                                          \"specify 4 dimensions\"));\n      OP_REQUIRES(context, ksize_[0] == 1 && stride_[0] == 1,\n                  errors::Unimplemented(\n                      \"Pooling is not yet supported on the batch dimension.\"));\n    }\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n\n    std::vector<int32> ksize = ksize_;\n    std::vector<int32> stride = stride_;\n\n    if (context->num_inputs() != 1) {\n      const Tensor& tensor_ksize = context->input(1);\n      auto value_ksize = tensor_ksize.flat<int32>();\n      ksize.resize(tensor_ksize.shape().num_elements());\n      std::copy_n(&value_ksize(0), ksize.size(), ksize.begin());\n\n      const Tensor& tensor_stride = context->input(2);\n      auto value_stride = tensor_stride.flat<int32>();\n      stride.resize(tensor_stride.shape().num_elements());\n      std::copy_n(&value_stride(0), stride.size(), stride.begin());\n    }\n    OP_REQUIRES(context, ksize.size() == 4,\n                errors::InvalidArgument(\"Sliding window ksize field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES(context, stride.size() == 4,\n                errors::InvalidArgument(\"Sliding window stride field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES(context, ksize[0] == 1 && stride[0] == 1,\n                errors::Unimplemented(\n                    \"Pooling is not yet supported on the batch dimension.\"));\n    PoolParameters params{context,\n                          ksize,\n                          stride,\n                          padding_,\n                          /*explicit_paddings=*/{},\n                          data_format_,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n\n    TensorShape out_shape({params.tensor_in_batch, params.out_height,\n                           params.out_width, params.depth});\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));\n\n    LaunchMaxPoolingNoMask<Device, T>::launch(context, params, tensor_in,\n                                              output);\n  }\n\n private:\n  std::vector<int32> ksize_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  TensorFormat data_format_;\n};\n\ntemplate <typename Device, typename T, typename Targmax>\nstruct LaunchMaxPoolingWithArgmax;\n\ntemplate <typename T, typename Targmax>\nstruct LaunchMaxPoolingWithArgmax<CPUDevice, T, Targmax> {\n  static void launch(OpKernelContext* context, const PoolParameters& params,\n                     const Tensor& input, Tensor* output, Tensor* argmax,\n                     bool propagate_nans, bool include_batch_in_index) {\n    Tensor unused;\n    SpatialMaxPoolWithArgMaxHelper<CPUDevice, T, Targmax>(\n        context, output, argmax, /*input_backprop=*/nullptr, input, unused,\n        params, include_batch_in_index);\n  }\n};\n\ntemplate <typename Device, typename T, typename Targmax>\nclass MaxPoolingWithArgmaxOp : public OpKernel {\n public:\n  explicit MaxPoolingWithArgmaxOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"ksize\", &ksize_));\n    OP_REQUIRES(context, ksize_.size() == 4,\n                errors::InvalidArgument(\"Sliding window ksize field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n    OP_REQUIRES(context, stride_.size() == 4,\n                errors::InvalidArgument(\"Sliding window stride field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n    OP_REQUIRES(context, ksize_[0] == 1 && stride_[0] == 1,\n                errors::Unimplemented(\n                    \"Pooling is not yet supported on the batch dimension.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"include_batch_in_index\",\n                                             &include_batch_in_index_));\n    TF_CHECK_OK(ReadBoolFromEnvVar(\"TF_ENABLE_MAXPOOL_NANPROP\", false,\n                                   &propagate_nans_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          /*explicit_paddings=*/{},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n\n    TensorShape out_shape({params.tensor_in_batch, params.out_height,\n                           params.out_width, params.depth});\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));\n    Tensor* argmax = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, out_shape, &argmax));\n\n    LaunchMaxPoolingWithArgmax<Device, T, Targmax>::launch(\n        context, params, tensor_in, output, argmax, propagate_nans_,\n        include_batch_in_index_);\n  }\n\n private:\n  std::vector<int32> ksize_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  bool propagate_nans_;\n  bool include_batch_in_index_;\n};\n\ntemplate <typename Device, typename T>\nstruct LaunchMaxPoolingGradWithArgmax;\n\ntemplate <typename T>\nstruct LaunchMaxPoolingGradWithArgmax<CPUDevice, T> {\n  typedef Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n      EigenMatrixMap;\n\n  static void launch(OpKernelContext* context, const PoolParameters& params,\n                     const Tensor& grad_in, const Tensor& argmax,\n                     Tensor* grad_out, const bool include_batch_in_index) {\n    const DeviceBase::CpuWorkerThreads& worker_threads =\n        *(context->device()->tensorflow_cpu_worker_threads());\n\n    auto shard = [&grad_in, &argmax, &grad_out, include_batch_in_index](\n                     int64_t start, int64_t limit) {\n      const int64_t batch_size =\n          GetTensorDim(grad_out->shape(), FORMAT_NHWC, 'N');\n      const int64_t output_size_per_batch =\n          grad_out->NumElements() / batch_size;\n      const int64_t input_size_per_batch = grad_in.NumElements() / batch_size;\n\n      {\n        auto grad_out_flat = grad_out->flat<T>();\n        auto argmax_flat = argmax.flat<int64>();\n        auto grad_in_flat = grad_in.flat<T>();\n\n        const int64_t output_start = start * output_size_per_batch;\n        const int64_t output_end = limit * output_size_per_batch;\n        EigenMatrixMap inputShard(grad_out_flat.data() + output_start, 1,\n                                  output_end - output_start);\n        inputShard.setConstant(T(0));\n\n        const int input_start = start * input_size_per_batch;\n        const int input_end = limit * input_size_per_batch;\n        for (int64_t index = input_start; index < input_end; index++) {\n          if (index >= argmax.NumElements()) {\n            break;\n          }\n          int64_t grad_out_index = argmax_flat(index);\n          if (!include_batch_in_index) {\n            const int64_t cur_batch = index / input_size_per_batch;\n            grad_out_index += cur_batch * output_size_per_batch;\n          }\n          CHECK(grad_out_index >= output_start && grad_out_index < output_end)\n              << \"Invalid output gradient index: \" << grad_out_index << \", \"\n              << output_start << \", \" << output_end;\n          grad_out_flat(grad_out_index) += grad_in_flat(index);\n        }\n      }\n    };\n\n    const int64_t batch_size =\n        GetTensorDim(grad_out->shape(), FORMAT_NHWC, 'N');\n    const int64_t shard_cost = grad_out->NumElements() / batch_size;\n    Shard(worker_threads.num_threads, worker_threads.workers, batch_size,\n          shard_cost, shard);\n  }\n};\n\n// TODO(b/175733711): Support int32 argmax type in MaxPoolGradWithArgmax op.\ntemplate <typename Device, typename T>\nclass MaxPoolingGradWithArgmaxOp : public OpKernel {\n public:\n  explicit MaxPoolingGradWithArgmaxOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string data_format_str;\n    auto status = context->GetAttr(\"data_format\", &data_format_str);\n    if (status.ok()) {\n      OP_REQUIRES(context, FormatFromString(data_format_str, &data_format_),\n                  errors::InvalidArgument(\"Invalid data format\"));\n    }\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"ksize\", &ksize_));\n    OP_REQUIRES(context, ksize_.size() == 4,\n                errors::InvalidArgument(\"Sliding window ksize field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n    OP_REQUIRES(context, stride_.size() == 4,\n                errors::InvalidArgument(\"Sliding window stride field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n    OP_REQUIRES(context, ksize_[0] == 1 && stride_[0] == 1,\n                errors::Unimplemented(\n                    \"Pooling is not yet supported on the batch dimension.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"include_batch_in_index\",\n                                             &include_batch_in_index_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& grad_in = context->input(1);\n    const Tensor& argmax = context->input(2);\n\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          /*explicit_paddings=*/{},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n\n    TensorShape out_shape({params.tensor_in_batch, params.tensor_in_rows,\n                           params.tensor_in_cols, params.depth});\n    Tensor* grad_out = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, out_shape, &grad_out));\n\n    if (out_shape.num_elements() == 0) return;  // nothing to be done\n\n    LaunchMaxPoolingGradWithArgmax<Device, T>::launch(\n        context, params, grad_in, argmax, grad_out, include_batch_in_index_);\n  }\n\n private:\n  std::vector<int32> ksize_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  TensorFormat data_format_;\n  bool include_batch_in_index_;\n};\n\ntemplate <typename Device, typename T>\nstruct LaunchMaxPoolingGradGradWithArgmax;\n\ntemplate <typename Device, typename T>\nclass MaxPoolingGradGradWithArgmaxOp : public OpKernel {\n public:\n  explicit MaxPoolingGradGradWithArgmaxOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"ksize\", &ksize_));\n    OP_REQUIRES(context, ksize_.size() == 4,\n                errors::InvalidArgument(\"Sliding window ksize field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n    OP_REQUIRES(context, stride_.size() == 4,\n                errors::InvalidArgument(\"Sliding window stride field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n    OP_REQUIRES(context, ksize_[0] == 1 && stride_[0] == 1,\n                errors::Unimplemented(\n                    \"Pooling is not yet supported on the batch dimension.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"include_batch_in_index\",\n                                             &include_batch_in_index_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& grad_in = context->input(1);\n    const Tensor& argmax = context->input(2);\n\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          /*explicit_paddings=*/{},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n\n    TensorShape out_shape({params.tensor_in_batch, params.out_height,\n                           params.out_width, params.depth});\n\n    Tensor* grad_out = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, out_shape, &grad_out));\n\n    LaunchMaxPoolingGradGradWithArgmax<Device, T>::launch(\n        context, params, grad_in, argmax, grad_out, include_batch_in_index_);\n  }\n\n private:\n  std::vector<int32> ksize_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  bool include_batch_in_index_;\n};\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\ntemplate <typename T>\nclass MaxPoolingNoMaskOp<GPUDevice, T> : public OpKernel {\n public:\n  typedef GPUDevice Device;\n  explicit MaxPoolingNoMaskOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string data_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n    OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                errors::InvalidArgument(\"Invalid data format\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"ksize\", &ksize_));\n    OP_REQUIRES(context, ksize_.size() == 4,\n                errors::InvalidArgument(\"Sliding window ksize field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n    OP_REQUIRES(context, stride_.size() == 4,\n                errors::InvalidArgument(\"Sliding window stride field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n    OP_REQUIRES_OK(context,\n                   context->GetAttr(\"explicit_paddings\", &explicit_paddings_));\n    const int32_t ksize_n = GetTensorDim(ksize_, data_format_, 'N');\n    const int32_t stride_n = GetTensorDim(stride_, data_format_, 'N');\n    OP_REQUIRES(context, ksize_n == 1 && stride_n == 1,\n                errors::Unimplemented(\n                    \"Pooling is not yet supported on the batch dimension.\"));\n\n    TF_CHECK_OK(ReadBoolFromEnvVar(\"TF_ENABLE_MAXPOOL_NANPROP\", false,\n                                   &propagate_nans_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n\n    PoolParameters params{\n        context,      ksize_,           stride_, padding_, explicit_paddings_,\n        data_format_, tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n\n    TensorShape out_shape =\n        ShapeFromFormat(data_format_, params.tensor_in_batch, params.out_height,\n                        params.out_width, params.depth);\n\n    // Assuming qint8 <--> NCHW_VECT_C (int8x4) here.\n    constexpr bool is_int8x4 = std::is_same<T, qint8>::value;\n    OP_REQUIRES(context, (is_int8x4 == (data_format_ == FORMAT_NCHW_VECT_C)),\n                errors::InvalidArgument(\n                    \"qint8 should be used with data_format NCHW_VECT_C.\"));\n\n#if CUDNN_VERSION >= 7300\n    DnnPoolingOp<T>::Compute(context, se::dnn::PoolingMode::kMaximum, ksize_,\n                             stride_, padding_, explicit_paddings_,\n                             data_format_, tensor_in, out_shape,\n                             propagate_nans_);\n#else\n    // These is_int8x4 checks avoid linker errors for missing qint8 kernels.\n    if (!is_int8x4 && data_format_ == FORMAT_NCHW) {\n      DnnPoolingOp<T>::Compute(context, se::dnn::PoolingMode::kMaximum, ksize_,\n                               stride_, padding_, explicit_paddings_,\n                               data_format_, tensor_in, out_shape,\n                               propagate_nans_);\n    } else {\n#if !defined(TENSORFLOW_USE_ROCM)\n      OP_REQUIRES(context, padding_ != EXPLICIT,\n                  errors::Unimplemented(\"Explicit padding is not supported \",\n                                        \"when CUDNN is not enabled.\"));\n#endif\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));\n      if (is_int8x4) {\n        LaunchMaxPoolingNoMask_NCHW_VECT_C<Device>::launch(context, params,\n                                                           tensor_in, output);\n      } else if (data_format_ == FORMAT_NHWC) {\n        LaunchMaxPoolingNoMask<Device, T>::launch(context, params, tensor_in,\n                                                  output, propagate_nans_);\n      } else {\n        LOG(FATAL) << \"MaxPool currently only supports the following (layout, \"\n                      \"type) combinations: (NHWC, non-qint8), \"\n                      \"(NCHW, non-qint8) or (NCHW_VECT_C, qint8). The \"\n                      \"requested combination (\"\n                   << ToString(data_format_) << \", \"\n                   << DataTypeString(DataTypeToEnum<T>::v())\n                   << \") is not supported.\";\n      }\n    }\n#endif\n  }\n\n private:\n  std::vector<int32> ksize_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  std::vector<int64> explicit_paddings_;\n  TensorFormat data_format_;\n  bool propagate_nans_;\n};\n\ntemplate <typename T>\nclass MaxPoolingNoMaskV2Op<GPUDevice, T> : public OpKernel {\n public:\n  typedef GPUDevice Device;\n  explicit MaxPoolingNoMaskV2Op(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string data_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n    OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                errors::InvalidArgument(\"Invalid data format\"));\n    if (context->num_inputs() == 1) {\n      OP_REQUIRES_OK(context, context->GetAttr(\"ksize\", &ksize_));\n      OP_REQUIRES(context, ksize_.size() == 4,\n                  errors::InvalidArgument(\"Sliding window ksize field must \"\n                                          \"specify 4 dimensions\"));\n      OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n      OP_REQUIRES(context, stride_.size() == 4,\n                  errors::InvalidArgument(\"Sliding window stride field must \"\n                                          \"specify 4 dimensions\"));\n      const int32_t ksize_n = GetTensorDim(ksize_, data_format_, 'N');\n      const int32_t stride_n = GetTensorDim(stride_, data_format_, 'N');\n      OP_REQUIRES(context, ksize_n == 1 && stride_n == 1,\n                  errors::Unimplemented(\n                      \"Pooling is not yet supported on the batch dimension.\"));\n    }\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n    TF_CHECK_OK(ReadBoolFromEnvVar(\"TF_ENABLE_MAXPOOL_NANPROP\", false,\n                                   &propagate_nans_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n\n    std::vector<int32> ksize = ksize_;\n    std::vector<int32> stride = stride_;\n\n    if (context->num_inputs() != 1) {\n      const Tensor& tensor_ksize = context->input(1);\n      auto value_ksize = tensor_ksize.flat<int32>();\n      ksize.resize(tensor_ksize.shape().num_elements());\n      std::copy_n(&value_ksize(0), ksize.size(), ksize.begin());\n\n      const Tensor& tensor_stride = context->input(2);\n      auto value_stride = tensor_stride.flat<int32>();\n      stride.resize(tensor_stride.shape().num_elements());\n      std::copy_n(&value_stride(0), stride.size(), stride.begin());\n    }\n    OP_REQUIRES(context, ksize.size() == 4,\n                errors::InvalidArgument(\"Sliding window ksize field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES(context, stride.size() == 4,\n                errors::InvalidArgument(\"Sliding window stride field must \"\n                                        \"specify 4 dimensions\"));\n    const int32_t ksize_n = GetTensorDim(ksize, data_format_, 'N');\n    const int32_t stride_n = GetTensorDim(stride, data_format_, 'N');\n    OP_REQUIRES(context, ksize_n == 1 && stride_n == 1,\n                errors::Unimplemented(\n                    \"Pooling is not yet supported on the batch dimension.\"));\n\n    PoolParameters params{context,\n                          ksize,\n                          stride,\n                          padding_,\n                          /*explicit_paddings=*/{},\n                          data_format_,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n\n    TensorShape out_shape =\n        ShapeFromFormat(data_format_, params.tensor_in_batch, params.out_height,\n                        params.out_width, params.depth);\n    if (data_format_ == FORMAT_NCHW) {\n      DnnPoolingOp<T>::Compute(context, se::dnn::PoolingMode::kMaximum, ksize,\n                               stride, padding_, explicit_paddings_,\n                               data_format_, tensor_in, out_shape,\n                               propagate_nans_);\n    } else {\n      CHECK(data_format_ == FORMAT_NHWC)\n          << \"MaxPool only supports NCHW or NHWC format\";\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));\n      LaunchMaxPoolingNoMask<Device, T>::launch(context, params, tensor_in,\n                                                output, propagate_nans_);\n    }\n  }\n\n private:\n  std::vector<int32> ksize_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  std::vector<int64> explicit_paddings_;\n  TensorFormat data_format_;\n  bool propagate_nans_;\n};\n\ntemplate <typename T>\nstruct LaunchMaxPoolingNoMask<Eigen::GpuDevice, T> {\n  static void launch(OpKernelContext* context, const PoolParameters& params,\n                     const Tensor& input, Tensor* output, bool propagate_nans) {\n    bool status = functor::MaxPoolForwardWithOptionalArgmax<T>()(\n        input.flat<T>().data(), params.tensor_in_batch, params.tensor_in_rows,\n        params.tensor_in_cols, params.depth, params.out_height,\n        params.out_width, params.window_rows, params.window_cols,\n        params.row_stride, params.col_stride, params.pad_top, params.pad_left,\n        output->flat<T>().data(), nullptr, context->eigen_gpu_device(),\n        propagate_nans, false);\n    if (!status) {\n      context->SetStatus(\n          errors::Internal(\"Failed launching MaxPoolForwardNoMask\"));\n    }\n  }\n};\n\ntemplate <typename T>\nstruct LaunchMaxPoolingWithArgmax<Eigen::GpuDevice, T, int64> {\n  static void launch(OpKernelContext* context, const PoolParameters& params,\n                     const Tensor& input, Tensor* output, Tensor* argmax,\n                     bool propagate_nans, bool include_batch_in_index) {\n    bool status = functor::MaxPoolForwardWithOptionalArgmax<T>()(\n        input.flat<T>().data(), params.tensor_in_batch, params.tensor_in_rows,\n        params.tensor_in_cols, params.depth, params.out_height,\n        params.out_width, params.window_rows, params.window_cols,\n        params.row_stride, params.col_stride, params.pad_top, params.pad_left,\n        output->flat<T>().data(),\n        reinterpret_cast<int64*>(argmax->flat<int64>().data()),\n        context->eigen_gpu_device(), propagate_nans, include_batch_in_index);\n    if (!status) {\n      context->SetStatus(\n          errors::Internal(\"Failed launching MaxPoolForwardWithArgmax\"));\n    }\n  }\n};\n\ntemplate <typename T>\nstruct LaunchMaxPoolingGradWithArgmax<Eigen::GpuDevice, T> {\n  static void launch(OpKernelContext* context, const PoolParameters& params,\n                     const Tensor& grad_in, const Tensor& argmax,\n                     Tensor* grad_out, const bool include_batch_in_index) {\n    const int input_size = params.tensor_in_batch * params.tensor_in_rows *\n                           params.tensor_in_cols * params.depth;\n    const int output_size = params.tensor_in_batch * params.out_height *\n                            params.out_width * params.depth;\n    const int top_offset = params.out_height * params.out_width * params.depth;\n    const int bottom_offset =\n        params.tensor_in_rows * params.tensor_in_cols * params.depth;\n    bool status = functor::MaxPoolBackwardWithArgmax<T>()(\n        output_size, input_size, grad_in.flat<T>().data(),\n        reinterpret_cast<const int64*>(argmax.flat<int64>().data()), top_offset,\n        bottom_offset, grad_out->flat<T>().data(), context->eigen_gpu_device(),\n        include_batch_in_index);\n    if (!status) {\n      context->SetStatus(\n          errors::Internal(\"Failed launching MaxPoolBackwardWithArgmax\"));\n    }\n  }\n};\n\ntemplate <typename T>\nstruct LaunchMaxPoolingGradGradWithArgmax<Eigen::GpuDevice, T> {\n  static void launch(OpKernelContext* context, const PoolParameters& params,\n                     const Tensor& grad_in, const Tensor& argmax,\n                     Tensor* grad_out, const bool include_batch_in_index) {\n    const int input_size = params.tensor_in_batch * params.tensor_in_rows *\n                           params.tensor_in_cols * params.depth;\n    const int output_size = params.tensor_in_batch * params.out_height *\n                            params.out_width * params.depth;\n    const int top_offset =\n        params.tensor_in_rows * params.tensor_in_cols * params.depth;\n    const int bottom_offset =\n        params.out_width * params.out_height * params.depth;\n    bool status = functor::MaxPoolGradBackwardWithArgmax<T>()(\n        output_size, input_size, grad_in.flat<T>().data(),\n        reinterpret_cast<const int64*>(argmax.flat<int64>().data()), top_offset,\n        bottom_offset, grad_out->flat<T>().data(), context->eigen_gpu_device(),\n        include_batch_in_index);\n    if (!status) {\n      context->SetStatus(\n          errors::Internal(\"Failed launching MaxPoolGradBackwardWithArgmax\"));\n    }\n  }\n};\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n#define REGISTER_MAX_POOL_KERNELS(D, T)                                  \\\n  REGISTER_KERNEL_BUILDER(                                               \\\n      Name(\"MaxPoolGrad\").Device(DEVICE_##D).TypeConstraint<T>(\"T\"),     \\\n      MaxPoolingGradOp<D##Device, T>);                                   \\\n  REGISTER_KERNEL_BUILDER(                                               \\\n      Name(\"MaxPoolGradGrad\").Device(DEVICE_##D).TypeConstraint<T>(\"T\"), \\\n      MaxPoolingGradGradOp<D##Device, T>);                               \\\n  REGISTER_KERNEL_BUILDER(Name(\"MaxPoolGradV2\")                          \\\n                              .Device(DEVICE_##D)                        \\\n                              .HostMemory(\"ksize\")                       \\\n                              .HostMemory(\"strides\")                     \\\n                              .TypeConstraint<T>(\"T\"),                   \\\n                          MaxPoolingGradOp<D##Device, T>);               \\\n  REGISTER_KERNEL_BUILDER(Name(\"MaxPoolGradGradV2\")                      \\\n                              .Device(DEVICE_##D)                        \\\n                              .HostMemory(\"ksize\")                       \\\n                              .HostMemory(\"strides\")                     \\\n                              .TypeConstraint<T>(\"T\"),                   \\\n                          MaxPoolingGradGradOp<D##Device, T>)            \\\n  REGISTER_KERNEL_BUILDER(Name(\"MaxPoolWithArgmax\")                      \\\n                              .Device(DEVICE_##D)                        \\\n                              .TypeConstraint<int64>(\"Targmax\")          \\\n                              .TypeConstraint<T>(\"T\"),                   \\\n                          MaxPoolingWithArgmaxOp<D##Device, T, int64>);  \\\n  REGISTER_KERNEL_BUILDER(Name(\"MaxPoolGradWithArgmax\")                  \\\n                              .Device(DEVICE_##D)                        \\\n                              .TypeConstraint<T>(\"T\")                    \\\n                              .TypeConstraint<int64>(\"Targmax\"),         \\\n                          MaxPoolingGradWithArgmaxOp<D##Device, T>);\n\n// Below kernels implemented only for CPU device.\n#define REGISTER_CPU_ONLY_POOL_KERNELS(T)                          \\\n  REGISTER_KERNEL_BUILDER(                                         \\\n      Name(\"MaxPool\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"),   \\\n      MaxPoolingOp<CPUDevice, T>);                                 \\\n  REGISTER_KERNEL_BUILDER(                                         \\\n      Name(\"MaxPoolV2\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      MaxPoolingV2Op<CPUDevice, T>);                               \\\n  REGISTER_KERNEL_BUILDER(Name(\"MaxPoolWithArgmax\")                \\\n                              .Device(DEVICE_CPU)                  \\\n                              .TypeConstraint<int32>(\"Targmax\")    \\\n                              .TypeConstraint<T>(\"T\"),             \\\n                          MaxPoolingWithArgmaxOp<CPUDevice, T, int32>);\nTF_CALL_REAL_NUMBER_TYPES(REGISTER_CPU_ONLY_POOL_KERNELS);\n#undef REGISTER_CPU_ONLY_POOL_KERNELS\n\n#define REGISTER_CPU_MAX_POOL_KERNELS(T) REGISTER_MAX_POOL_KERNELS(CPU, T);\nTF_CALL_REAL_NUMBER_TYPES(REGISTER_CPU_MAX_POOL_KERNELS);\n#undef REGISTER_CPU_KERNELS\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n// Forward declarations for the functor specializations for GPU.\nnamespace functor {\n#define DECLARE_GPU_SPEC(T)                                            \\\n  template <>                                                          \\\n  void SpatialMaxPooling<Eigen::GpuDevice, T>::operator()(             \\\n      const Eigen::GpuDevice& d, typename TTypes<T, 4>::Tensor output, \\\n      typename TTypes<T, 4>::ConstTensor input, int window_rows,       \\\n      int window_cols, int row_stride, int col_stride,                 \\\n      const Eigen::PaddingType& padding);                              \\\n  extern template struct SpatialMaxPooling<Eigen::GpuDevice, T>;\n\nTF_CALL_GPU_NUMBER_TYPES(DECLARE_GPU_SPEC);\n#undef DECLARE_GPU_SPEC\n}  // namespace functor\n\n#define REGISTER_GPU_MAX_POOL_KERNELS(T) REGISTER_MAX_POOL_KERNELS(GPU, T)\nTF_CALL_GPU_NUMBER_TYPES(REGISTER_GPU_MAX_POOL_KERNELS);\n#undef REGISTER_GPU_MAX_POOL_KERNELS\n\n// Below kernels currently implemented only for GPU device.\n// Note(jiayq): Currently, the Caffe custom implementation is faster than the\n// default Eigen implementation so we are using the custom kernel as the\n// default. However, you can explicitly invoke the eigen version using\n// kernel_label_map.\n#define REGISTER_GPU_ONLY_POOL_KERNELS(T)                        \\\n  REGISTER_KERNEL_BUILDER(Name(\"MaxPool\")                        \\\n                              .Device(DEVICE_GPU)                \\\n                              .TypeConstraint<T>(\"T\")            \\\n                              .Label(\"eigen_tensor\"),            \\\n                          MaxPoolingOp<GPUDevice, T>);           \\\n  REGISTER_KERNEL_BUILDER(Name(\"MaxPoolV2\")                      \\\n                              .Device(DEVICE_GPU)                \\\n                              .HostMemory(\"ksize\")               \\\n                              .HostMemory(\"strides\")             \\\n                              .TypeConstraint<T>(\"T\")            \\\n                              .Label(\"eigen_tensor\"),            \\\n                          MaxPoolingV2Op<GPUDevice, T>);         \\\n  REGISTER_KERNEL_BUILDER(                                       \\\n      Name(\"MaxPool\").Device(DEVICE_GPU).TypeConstraint<T>(\"T\"), \\\n      MaxPoolingNoMaskOp<GPUDevice, T>);                         \\\n  REGISTER_KERNEL_BUILDER(Name(\"MaxPoolV2\")                      \\\n                              .Device(DEVICE_GPU)                \\\n                              .HostMemory(\"ksize\")               \\\n                              .HostMemory(\"strides\")             \\\n                              .TypeConstraint<T>(\"T\"),           \\\n                          MaxPoolingNoMaskV2Op<GPUDevice, T>);   \\\n  REGISTER_KERNEL_BUILDER(Name(\"MaxPoolGradGradWithArgmax\")      \\\n                              .Device(DEVICE_GPU)                \\\n                              .TypeConstraint<T>(\"T\")            \\\n                              .TypeConstraint<int64>(\"Targmax\"), \\\n                          MaxPoolingGradGradWithArgmaxOp<GPUDevice, T>);\nTF_CALL_GPU_NUMBER_TYPES(REGISTER_GPU_ONLY_POOL_KERNELS);\n\n// TODO(b/65847473): Re-enable once the underlying build error is fixed.\n#if !defined(PLATFORM_WINDOWS)\nREGISTER_KERNEL_BUILDER(\n    Name(\"MaxPool\").Device(DEVICE_GPU).TypeConstraint<qint8>(\"T\"),\n    MaxPoolingNoMaskOp<GPUDevice, qint8>);\n\nREGISTER_KERNEL_BUILDER(Name(\"MaxPoolV2\")\n                            .Device(DEVICE_GPU)\n                            .HostMemory(\"ksize\")\n                            .HostMemory(\"strides\")\n                            .TypeConstraint<qint8>(\"T\"),\n                        MaxPoolingV2Op<GPUDevice, qint8>);\n\nREGISTER_KERNEL_BUILDER(Name(\"MaxPoolV2\")\n                            .Device(DEVICE_GPU)\n                            .HostMemory(\"ksize\")\n                            .HostMemory(\"strides\")\n                            .TypeConstraint<qint8>(\"T\")\n                            .Label(\"eigen_tensor\"),\n                        MaxPoolingV2Op<GPUDevice, qint8>);\n#endif  // !defined(PLATFORM_WINDOWS)\n\n#undef REGISTER_GPU_ONLY_POOL_KERNELS\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n#undef REGISTER_MAX_POOL_KERNELS\n\n}  // namespace tensorflow\n", "/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/kernels/pooling_ops_common.h\"\n\n#include <vector>\n\n#include \"tensorflow/core/common_runtime/device.h\"\n#include \"tensorflow/core/framework/bounds_check.h\"\n#include \"tensorflow/core/framework/kernel_shape_util.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n\n#if GOOGLE_CUDA\n#include \"third_party/gpus/cudnn/cudnn.h\"\n#endif  // GOOGLE_CUDA\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#include \"tensorflow/core/kernels/conv_2d.h\"\n#include \"tensorflow/core/kernels/gpu_utils.h\"\n#if TENSORFLOW_USE_ROCM\n#include \"tensorflow/core/kernels/conv_ops_gpu.h\"\n#endif\n#include \"tensorflow/core/kernels/pooling_ops_common_gpu.h\"\n#include \"tensorflow/core/platform/stream_executor.h\"\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\nnamespace tensorflow {\n\nnamespace {\n\ntemplate <typename T>\nstruct RawType {\n  using type = T;\n};\n\ntemplate <>\nstruct RawType<qint8> {\n  using type = int8;\n};\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\ntemplate <typename T>\nstruct PadInputWithNegativeInf {\n  Status operator()(const GPUDevice& d,\n                    typename TTypes<T, 4, int>::ConstTensor in,\n                    int input_pad_top, int input_pad_bottom, int input_pad_left,\n                    int input_pad_right, typename TTypes<T, 4, int>::Tensor out,\n                    TensorFormat format) {\n    T padding_value = -std::numeric_limits<T>::infinity();\n    functor::PadInput<GPUDevice, T, int, 4>()(\n        d, in, {{input_pad_top, input_pad_left}},\n        {{input_pad_bottom, input_pad_right}}, out, format, padding_value);\n    return Status::OK();\n  }\n};\n\ntemplate <>\nstruct PadInputWithNegativeInf<qint8> {\n  Status operator()(const GPUDevice& d,\n                    typename TTypes<qint8, 4, int>::ConstTensor in,\n                    int input_pad_top, int input_pad_bottom, int input_pad_left,\n                    int input_pad_right,\n                    typename TTypes<qint8, 4, int>::Tensor out,\n                    TensorFormat format) {\n    return errors::InvalidArgument(\n        \"Explicit padding not yet supported with qint8\");\n  }\n};\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n}  // namespace\n\nStatus CheckPaddingSize(int64_t window_rows, int64_t window_cols,\n                        int64_t pad_top, int64_t pad_bottom, int64_t pad_left,\n                        int64_t pad_right) {\n  if (!FastBoundsCheck(pad_top, window_rows)) {\n    return errors::InvalidArgument(\"Top padding \", pad_top,\n                                   \" needs to be smaller than the \"\n                                   \"window size \",\n                                   window_rows);\n  }\n  if (!FastBoundsCheck(pad_bottom, window_rows)) {\n    return errors::InvalidArgument(\"Bottom padding \", pad_bottom,\n                                   \" needs to be smaller than the \"\n                                   \"window size \",\n                                   window_rows);\n  }\n  if (!FastBoundsCheck(pad_left, window_cols)) {\n    return errors::InvalidArgument(\"Left padding \", pad_left,\n                                   \" needs to be smaller than the \"\n                                   \"window size \",\n                                   window_cols);\n  }\n  if (!FastBoundsCheck(pad_right, window_cols)) {\n    return errors::InvalidArgument(\"Right padding \", pad_right,\n                                   \" needs to be smaller than the \"\n                                   \"window size \",\n                                   window_cols);\n  }\n  return Status::OK();\n}\n\nPoolParameters::PoolParameters(OpKernelContext* context,\n                               const std::vector<int32>& ksize,\n                               const std::vector<int32>& stride,\n                               Padding padding,\n                               std::vector<int64> explicit_paddings,\n                               TensorFormat data_format,\n                               const TensorShape& tensor_in_shape) {\n  // For maxpooling, tensor_in should have 2 spatial dimensions.\n  // Note: the total number of dimensions could be 4 for NHWC, NCHW,\n  // or 5 for NCHW_VECT_C.\n  OP_REQUIRES(context,\n              GetTensorSpatialDims(tensor_in_shape.dims(), data_format) == 2,\n              errors::InvalidArgument(\n                  \"tensor_in_shape must have 2 spatial dimensions. \",\n                  tensor_in_shape.dims(), \" \", data_format));\n\n  this->data_format = data_format;\n  depth = GetTensorDim(tensor_in_shape, data_format, 'C') *\n          (data_format == FORMAT_NCHW_VECT_C ? 4 : 1);\n  tensor_in_cols = GetTensorDim(tensor_in_shape, data_format, 'W');\n  tensor_in_rows = GetTensorDim(tensor_in_shape, data_format, 'H');\n  tensor_in_batch = GetTensorDim(tensor_in_shape, data_format, 'N');\n  window_rows = GetTensorDim(ksize, data_format, 'H');\n  window_cols = GetTensorDim(ksize, data_format, 'W');\n  depth_window = GetTensorDim(ksize, data_format, 'C');\n  row_stride = GetTensorDim(stride, data_format, 'H');\n  col_stride = GetTensorDim(stride, data_format, 'W');\n  depth_stride = GetTensorDim(stride, data_format, 'C');\n\n  // We only support 2D pooling across width/height and depthwise\n  // pooling, not a combination.\n  OP_REQUIRES(context,\n              (depth_window == 1 || (window_rows == 1 && window_cols == 1)),\n              errors::Unimplemented(\n                  \"MaxPooling supports exactly one of pooling across depth \"\n                  \"or pooling across width/height.\"));\n  if (padding == Padding::EXPLICIT) {\n    OP_REQUIRES_OK(context, CheckValidPadding(padding, explicit_paddings,\n                                              /*num_dims=*/4, data_format));\n    GetExplicitPaddingForDim(explicit_paddings, data_format, 'H', &pad_top,\n                             &pad_bottom);\n    GetExplicitPaddingForDim(explicit_paddings, data_format, 'W', &pad_left,\n                             &pad_right);\n    OP_REQUIRES_OK(context, CheckPaddingSize(window_rows, window_cols, pad_top,\n                                             pad_bottom, pad_left, pad_right));\n  }\n\n  if (depth_window == 1) {\n    OP_REQUIRES_OK(context, GetWindowedOutputSizeVerbose(\n                                tensor_in_rows, window_rows, row_stride,\n                                padding, &out_height, &pad_top, &pad_bottom));\n    OP_REQUIRES_OK(context, GetWindowedOutputSizeVerbose(\n                                tensor_in_cols, window_cols, col_stride,\n                                padding, &out_width, &pad_left, &pad_right));\n    pad_depth = 0;\n    out_depth = depth;\n  } else {\n    // Our current version of depthwise max pooling does not support\n    // any padding, and expects the depth_window to equal the\n    // depth_stride (no overlapping).\n    OP_REQUIRES(\n        context, depth % depth_window == 0,\n        errors::Unimplemented(\"Depthwise max pooling requires the depth \"\n                              \"window to evenly divide the input depth\"));\n    OP_REQUIRES(\n        context, depth_stride == depth_window,\n        errors::Unimplemented(\"Depthwise max pooling requires the depth \"\n                              \"window to equal the depth stride\"));\n\n    // The current version of depthwise max is only implemented on CPU.\n    OP_REQUIRES(context,\n                (DeviceType(static_cast<Device*>(context->device())\n                                ->attributes()\n                                .device_type()) == DeviceType(DEVICE_CPU)),\n                errors::Unimplemented(\"Depthwise max pooling is currently \"\n                                      \"only implemented for CPU devices.\"));\n\n    pad_depth = 0;\n    out_depth = depth / depth_window;\n  }\n}\n\nTensorShape PoolParameters::forward_output_shape() {\n  if (depth_window == 1) {\n    // Spatial pooling\n    return ShapeFromFormat(data_format, tensor_in_batch, out_height, out_width,\n                           depth);\n  } else {\n    // Depthwise pooling\n    return TensorShape(\n        {tensor_in_batch, tensor_in_rows, tensor_in_cols, out_depth});\n  }\n}\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\ntemplate <typename T>\nvoid DnnPoolingOp<T>::Compute(OpKernelContext* context,\n                              se::dnn::PoolingMode pooling_mode,\n                              const std::vector<int32>& size,\n                              const std::vector<int32>& stride, Padding padding,\n                              std::vector<int64> explicit_paddings,\n                              TensorFormat data_format, const Tensor& tensor_in,\n                              const TensorShape& tensor_out_shape,\n                              bool propagate_nans) {\n  Tensor* tensor_out = nullptr;\n  OP_REQUIRES_OK(context,\n                 context->allocate_output(0, tensor_out_shape, &tensor_out));\n  if (tensor_in.shape().num_elements() == 0) {\n    return;\n  }\n\n  PoolParameters params{\n      context,           size,        stride,           padding,\n      explicit_paddings, data_format, tensor_in.shape()};\n  if (!context->status().ok()) {\n    return;\n  }\n\n  int batch_size = params.tensor_in_batch;\n  int depth = params.depth;\n  int tensor_in_cols = params.tensor_in_cols;\n  int tensor_in_rows = params.tensor_in_rows;\n\n#if CUDNN_VERSION < 7300\n  /// Earlier versions do not support NHWC format, so we need to convert it\n  /// to NCHW before calling cudnn. We need to get rid of this once it is done\n  Tensor transformed_input;\n  if (data_format == FORMAT_NHWC) {\n    OP_REQUIRES_OK(context, context->allocate_temp(\n                                DataTypeToEnum<T>::value,\n                                ShapeFromFormat(FORMAT_NCHW, tensor_in.shape(),\n                                                data_format),\n                                &transformed_input));\n    functor::NHWCToNCHW<GPUDevice, T, 4>()(context->eigen_device<Device>(),\n                                           tensor_in.tensor<T, 4>(),\n                                           transformed_input.tensor<T, 4>());\n  } else {\n    transformed_input = tensor_in;\n  }\n  Tensor transformed_output;\n  if (data_format == FORMAT_NHWC) {\n    OP_REQUIRES_OK(context, context->allocate_temp(\n                                DataTypeToEnum<T>::value,\n                                ShapeFromFormat(FORMAT_NCHW, tensor_out_shape,\n                                                data_format),\n                                &transformed_output));\n  } else {\n    transformed_output = *tensor_out;\n  }\n  se::dnn::DataLayout data_layout = se::dnn::DataLayout::kBatchDepthYX;\n#else\n  Tensor transformed_input = tensor_in;\n  auto& transformed_output = *tensor_out;\n  se::dnn::DataLayout data_layout;\n  switch (data_format) {\n    case FORMAT_NHWC:\n      data_layout = se::dnn::DataLayout::kBatchYXDepth;\n      break;\n    case FORMAT_NCHW:\n      data_layout = se::dnn::DataLayout::kBatchDepthYX;\n      break;\n    case FORMAT_NCHW_VECT_C:\n      // NCHW_VECT_C is not supported by cudnnPoolingForward(), but can be\n      // emulated via NHWC.\n      data_layout = se::dnn::DataLayout::kBatchYXDepth;\n      batch_size *= depth / 4;\n      depth = 4;\n      break;\n    default:\n      OP_REQUIRES(context, false,\n                  errors::InvalidArgument(\"Unsupported format: \",\n                                          ToString(data_format)));\n  }\n#endif\n\n  int64_t vertical_padding = params.pad_top;\n  int64_t horizontal_padding = params.pad_left;\n\n  if (padding == EXPLICIT && (params.pad_top != params.pad_bottom ||\n                              params.pad_left != params.pad_right)) {\n    // cuDNN only supports padding the same amount on the left and right sides,\n    // and on the top and bottom sides. So we manually create a new padded\n    // input tensor such that we can pass it to cuDNN.\n    const int64_t common_padding_rows =\n        std::min(params.pad_top, params.pad_bottom);\n    const int64_t common_padding_cols =\n        std::min(params.pad_left, params.pad_right);\n\n    Tensor padded_input;\n    const int64_t padding_rows_diff =\n        std::abs(params.pad_top - params.pad_bottom);\n    const int64_t padding_cols_diff =\n        std::abs(params.pad_left - params.pad_right);\n\n    const int64_t new_in_rows = tensor_in_rows + padding_rows_diff;\n    const int64_t new_in_cols = tensor_in_cols + padding_cols_diff;\n\n    OP_REQUIRES_OK(\n        context,\n        context->allocate_temp(DataTypeToEnum<T>::value,\n                               ShapeFromFormat(data_format, batch_size,\n                                               new_in_rows, new_in_cols, depth),\n                               &padded_input));\n    const int64_t input_pad_top = params.pad_top - common_padding_rows;\n    const int64_t input_pad_bottom = params.pad_bottom - common_padding_rows;\n    const int64_t input_pad_left = params.pad_left - common_padding_cols;\n    const int64_t input_pad_right = params.pad_right - common_padding_cols;\n\n    bool in_bounds =\n        FastBoundsCheck(input_pad_top, std::numeric_limits<int>::max()) &&\n        FastBoundsCheck(input_pad_bottom, std::numeric_limits<int>::max()) &&\n        FastBoundsCheck(input_pad_left, std::numeric_limits<int>::max()) &&\n        FastBoundsCheck(input_pad_right, std::numeric_limits<int>::max());\n    if (!in_bounds) {\n      context->SetStatus(errors::InvalidArgument(\"Padding is too large.\"));\n      return;\n    }\n\n    // We need to call the const version of transformed_input.tensor()\n    const Tensor& const_transformed_input = transformed_input;\n    OP_REQUIRES_OK(\n        context,\n        PadInputWithNegativeInf<T>()(\n            context->eigen_device<GPUDevice>(),\n            To32Bit(const_transformed_input.tensor<T, 4>()),\n            static_cast<int>(input_pad_top), static_cast<int>(input_pad_bottom),\n            static_cast<int>(input_pad_left), static_cast<int>(input_pad_right),\n            To32Bit(padded_input.tensor<T, 4>()), data_format));\n    transformed_input = padded_input;\n    vertical_padding = common_padding_rows;\n    horizontal_padding = common_padding_cols;\n    tensor_in_rows = new_in_rows;\n    tensor_in_cols = new_in_cols;\n  }\n\n  se::dnn::PoolingDescriptor pooling_desc;\n  pooling_desc.set_pooling_mode(pooling_mode)\n      .set_window_height(params.window_rows)\n      .set_window_width(params.window_cols)\n      .set_vertical_stride(params.row_stride)\n      .set_horizontal_stride(params.col_stride)\n      .set_vertical_padding(vertical_padding)\n      .set_horizontal_padding(horizontal_padding)\n      .set_propagate_nans(propagate_nans);\n\n  se::dnn::BatchDescriptor input_desc;\n  input_desc.set_count(batch_size)\n      .set_height(tensor_in_rows)\n      .set_width(tensor_in_cols)\n      .set_feature_map_count(depth)\n      .set_layout(data_layout);\n\n  se::dnn::BatchDescriptor output_desc;\n  output_desc.set_count(batch_size)\n      .set_height(params.out_height)\n      .set_width(params.out_width)\n      .set_feature_map_count(depth)\n      .set_layout(data_layout);\n\n  auto input_data =\n      AsDeviceMemory(reinterpret_cast<const typename RawType<T>::type*>(\n                         transformed_input.template flat<T>().data()),\n                     transformed_input.template flat<T>().size());\n\n  auto output_data =\n      AsDeviceMemory(reinterpret_cast<const typename RawType<T>::type*>(\n                         transformed_output.template flat<T>().data()),\n                     transformed_output.template flat<T>().size());\n\n  auto* stream = context->op_device_context()->stream();\n  OP_REQUIRES(context, stream, errors::Internal(\"No GPU stream available.\"));\n\n#if TENSORFLOW_USE_ROCM\n  static int64 PoolingScratchSize = GetDnnWorkspaceLimit(\n      // default value is in bytes despite the name of the environment variable\n      \"TF_CUDNN_WORKSPACE_LIMIT_IN_MB\", 1LL << 32  // 4GB\n  );\n\n  DnnScratchAllocator scratch_allocator(PoolingScratchSize, context);\n  bool status =\n      stream\n          ->ThenPoolForward(pooling_desc, input_desc, input_data, output_desc,\n                            &output_data, &scratch_allocator)\n          .ok();\n#else\n  bool status = stream\n                    ->ThenPoolForward(pooling_desc, input_desc, input_data,\n                                      output_desc, &output_data)\n                    .ok();\n#endif\n  OP_REQUIRES(context, status,\n              errors::Internal(\"dnn PoolForward launch failed\"));\n#if CUDNN_VERSION < 7300\n  if (data_format == FORMAT_NHWC) {\n    /// Transform the output data from NCHW back to NHWC\n    auto toConstTensor = [](const Tensor& x) -> const Tensor { return x; };\n    using RT = typename RawType<T>::type;\n    functor::NCHWToNHWC<GPUDevice, RT, 4>()(\n        context->eigen_device<Device>(),\n        toConstTensor(transformed_output).template tensor<RT, 4>(),\n        tensor_out->tensor<RT, 4>());\n  }\n#endif\n}\n\n// Forward declarations of the functor specializations for GPU.\nnamespace functor {\n#define DECLARE_GPU_SPEC(T)                                             \\\n  template <>                                                           \\\n  void PadInput<GPUDevice, T, int, 4>::operator()(                      \\\n      const GPUDevice& d, typename TTypes<T, 4, int>::ConstTensor in,   \\\n      const std::array<int, 2>& padding_left,                           \\\n      const std::array<int, 2>& padding_right,                          \\\n      typename TTypes<T, 4, int>::Tensor out, TensorFormat data_format, \\\n      const T& padding_value);                                          \\\n  extern template struct PadInput<GPUDevice, T, int, 4>;\n\nDECLARE_GPU_SPEC(float);\nDECLARE_GPU_SPEC(Eigen::half);\nDECLARE_GPU_SPEC(double);\nDECLARE_GPU_SPEC(int32);\n}  // namespace functor\n\ntemplate <typename T>\nvoid DnnPoolingGradOp<T>::Compute(\n    OpKernelContext* context, se::dnn::PoolingMode pooling_mode,\n    const std::vector<int32>& size, const std::vector<int32>& stride,\n    Padding padding, std::vector<int64> explicit_paddings,\n    TensorFormat data_format, const Tensor* tensor_in, const Tensor* tensor_out,\n    const Tensor& out_backprop, const TensorShape& tensor_in_shape,\n    bool propagate_nans) {\n  CHECK((pooling_mode != se::dnn::PoolingMode::kMaximum) ||\n        (tensor_in && tensor_out))\n      << \"For MaxPoolGrad, both tensor_in and tensor_out needs to be \"\n         \"specified\";\n\n  Tensor* input_backprop = nullptr;\n  OP_REQUIRES_OK(context,\n                 context->allocate_output(0, tensor_in_shape, &input_backprop));\n  if (tensor_in_shape.num_elements() == 0) {\n    return;\n  }\n\n  PoolParameters params{context,           size,        stride,         padding,\n                        explicit_paddings, data_format, tensor_in_shape};\n  if (!context->status().ok()) {\n    return;\n  }\n\n  TensorFormat transformed_input_data_format = data_format;\n\n#if CUDNN_VERSION < 7300\n  /// For now, cudnn does not support NHWC format, so we need to convert it\n  /// to NCHW before calling cudnn. We need to get rid of this once it is done\n  Tensor transformed_input;\n  TensorShape transformed_input_shape;\n  if (data_format == FORMAT_NHWC || !tensor_in) {\n    transformed_input_shape =\n        ShapeFromFormat(FORMAT_NCHW, tensor_in_shape, data_format);\n    OP_REQUIRES_OK(context, context->allocate_temp(DataTypeToEnum<T>::value,\n                                                   transformed_input_shape,\n                                                   &transformed_input));\n  } else {\n    transformed_input = *tensor_in;\n  }\n  Tensor transformed_output;\n  TensorShape transformed_output_shape;\n  if (data_format == FORMAT_NHWC || !tensor_out) {\n    transformed_output_shape =\n        ShapeFromFormat(FORMAT_NCHW, out_backprop.shape(), data_format);\n    OP_REQUIRES_OK(context, context->allocate_temp(DataTypeToEnum<T>::value,\n                                                   transformed_output_shape,\n                                                   &transformed_output));\n  } else {\n    transformed_output = *tensor_out;\n  }\n  Tensor transformed_input_backprop;\n  if (data_format == FORMAT_NHWC) {\n    OP_REQUIRES_OK(context,\n                   context->allocate_temp(DataTypeToEnum<T>::value,\n                                          transformed_input_shape,\n                                          &transformed_input_backprop));\n  } else {\n    transformed_input_backprop = *input_backprop;\n  }\n  Tensor transformed_output_backprop;\n  if (data_format == FORMAT_NHWC) {\n    OP_REQUIRES_OK(context,\n                   context->allocate_temp(DataTypeToEnum<T>::value,\n                                          transformed_output_shape,\n                                          &transformed_output_backprop));\n  } else {\n    transformed_output_backprop = out_backprop;\n  }\n\n  if (data_format == FORMAT_NHWC) {\n    /// Convert the data from NHWC to NCHW if necessary.\n    if (tensor_in) {\n      // For AvgPoolGrad, the original input tensor is not necessary. However,\n      // cudnn still requires them to run, although they do not affect the\n      // results.\n      functor::NHWCToNCHW<GPUDevice, T, 4>()(context->eigen_device<Device>(),\n                                             tensor_in->tensor<T, 4>(),\n                                             transformed_input.tensor<T, 4>());\n      transformed_input_data_format = FORMAT_NCHW;\n    }\n    if (tensor_out) {\n      // For AvgPoolGrad, the original output tensor is not necessary. However,\n      // cudnn still requires them to run, although they do not affect the\n      // results.\n      functor::NHWCToNCHW<GPUDevice, T, 4>()(context->eigen_device<Device>(),\n                                             tensor_out->tensor<T, 4>(),\n                                             transformed_output.tensor<T, 4>());\n    }\n    functor::NHWCToNCHW<GPUDevice, T, 4>()(\n        context->eigen_device<Device>(), out_backprop.tensor<T, 4>(),\n        transformed_output_backprop.tensor<T, 4>());\n  }\n  se::dnn::DataLayout data_layout = se::dnn::DataLayout::kBatchDepthYX;\n#else\n  Tensor transformed_input;\n  if (!tensor_in) {\n    OP_REQUIRES_OK(context,\n                   context->allocate_temp(DataTypeToEnum<T>::value,\n                                          tensor_in_shape, &transformed_input));\n  } else {\n    transformed_input = *tensor_in;\n  }\n  Tensor transformed_output;\n  if (!tensor_out) {\n    OP_REQUIRES_OK(context, context->allocate_temp(DataTypeToEnum<T>::value,\n                                                   out_backprop.shape(),\n                                                   &transformed_output));\n  } else {\n    transformed_output = *tensor_out;\n  }\n  Tensor transformed_input_backprop = *input_backprop;\n  Tensor transformed_output_backprop = out_backprop;\n  se::dnn::DataLayout data_layout;\n  switch (data_format) {\n    case FORMAT_NHWC:\n      data_layout = se::dnn::DataLayout::kBatchYXDepth;\n      break;\n    case FORMAT_NCHW:\n      data_layout = se::dnn::DataLayout::kBatchDepthYX;\n      break;\n    default:\n      OP_REQUIRES(context, false,\n                  errors::InvalidArgument(\"Unsupported format: \",\n                                          ToString(data_format)));\n  }\n#endif  // CUDNN_VERSION < 7300\n\n  int64_t vertical_padding = params.pad_top;\n  int64_t horizontal_padding = params.pad_left;\n\n  int batch_size = params.tensor_in_batch;\n  int depth = params.depth;\n  int tensor_in_cols = params.tensor_in_cols;\n  int tensor_in_rows = params.tensor_in_rows;\n\n  int64_t input_pad_top = 0;\n  int64_t input_pad_bottom = 0;\n  int64_t input_pad_left = 0;\n  int64_t input_pad_right = 0;\n\n  Tensor transformed_and_padded_input_backprop;\n\n  if (padding == EXPLICIT && (params.pad_top != params.pad_bottom ||\n                              params.pad_left != params.pad_right)) {\n    // Pad the input in the same way we did during the forward pass, so that\n    // cuDNN or MIOpen receives the same input during the backward pass function\n    // as it did during the forward pass function.\n    const int64_t common_padding_rows =\n        std::min(params.pad_top, params.pad_bottom);\n    const int64_t common_padding_cols =\n        std::min(params.pad_left, params.pad_right);\n\n    Tensor padded_input;\n    const int64_t padding_rows_diff =\n        std::abs(params.pad_top - params.pad_bottom);\n    const int64_t padding_cols_diff =\n        std::abs(params.pad_left - params.pad_right);\n\n    const int64_t new_in_rows = tensor_in_rows + padding_rows_diff;\n    const int64_t new_in_cols = tensor_in_cols + padding_cols_diff;\n\n    VLOG(2) << \"Create new tensor: \"\n            << \" original rows=\" << tensor_in_rows\n            << \" original cols=\" << tensor_in_cols\n            << \" padding_rows=\" << new_in_rows\n            << \" padding_cols=\" << new_in_cols << \" depth= \" << depth\n            << \" batch_size=\" << batch_size << \" kernel_rows\"\n            << params.window_rows << \" kernel_col\" << params.window_cols\n            << \" stride_rows\" << params.row_stride;\n\n    OP_REQUIRES_OK(\n        context, context->allocate_temp(\n                     DataTypeToEnum<T>::value,\n                     ShapeFromFormat(transformed_input_data_format, batch_size,\n                                     new_in_rows, new_in_cols, depth),\n                     &padded_input));\n\n    OP_REQUIRES_OK(\n        context, context->allocate_temp(\n                     DataTypeToEnum<T>::value,\n                     ShapeFromFormat(transformed_input_data_format, batch_size,\n                                     new_in_rows, new_in_cols, depth),\n                     &transformed_and_padded_input_backprop));\n\n    input_pad_top = params.pad_top - common_padding_rows;\n    input_pad_bottom = params.pad_bottom - common_padding_rows;\n    input_pad_left = params.pad_left - common_padding_cols;\n    input_pad_right = params.pad_right - common_padding_cols;\n\n    bool in_bounds =\n        FastBoundsCheck(input_pad_top, std::numeric_limits<int>::max()) &&\n        FastBoundsCheck(input_pad_bottom, std::numeric_limits<int>::max()) &&\n        FastBoundsCheck(input_pad_left, std::numeric_limits<int>::max()) &&\n        FastBoundsCheck(input_pad_right, std::numeric_limits<int>::max());\n    if (!in_bounds) {\n      context->SetStatus(errors::InvalidArgument(\"Padding is too large.\"));\n      return;\n    }\n\n    // PadInputWithNegativeInf functor requires input to be a const.\n    const Tensor& const_transformed_input = transformed_input;\n    OP_REQUIRES_OK(\n        context,\n        PadInputWithNegativeInf<T>()(\n            context->eigen_device<GPUDevice>(),\n            To32Bit(const_transformed_input.tensor<T, 4>()),\n            static_cast<int>(input_pad_top), static_cast<int>(input_pad_bottom),\n            static_cast<int>(input_pad_left), static_cast<int>(input_pad_right),\n            To32Bit(padded_input.tensor<T, 4>()),\n            transformed_input_data_format));\n\n    transformed_input = padded_input;\n\n    vertical_padding = common_padding_rows;\n    horizontal_padding = common_padding_cols;\n    VLOG(2) << \"vertical padding set to: \" << vertical_padding\n            << \" horizontal padding set to: \" << horizontal_padding;\n    tensor_in_rows = new_in_rows;\n    tensor_in_cols = new_in_cols;\n  } else {\n    transformed_and_padded_input_backprop = transformed_input_backprop;\n  }\n\n  /// Get ready to call cudnn\n  se::dnn::PoolingDescriptor pooling_desc;\n  pooling_desc.set_pooling_mode(pooling_mode)\n      .set_window_height(params.window_rows)\n      .set_window_width(params.window_cols)\n      .set_vertical_stride(params.row_stride)\n      .set_horizontal_stride(params.col_stride)\n      .set_vertical_padding(vertical_padding)\n      .set_horizontal_padding(horizontal_padding)\n      .set_propagate_nans(propagate_nans);\n\n  se::dnn::BatchDescriptor orig_output_desc;\n  orig_output_desc.set_count(params.tensor_in_batch)\n      .set_height(params.out_height)\n      .set_width(params.out_width)\n      .set_feature_map_count(params.depth)\n      .set_layout(data_layout);\n\n  se::dnn::BatchDescriptor orig_input_desc;\n  orig_input_desc.set_count(params.tensor_in_batch)\n      .set_height(tensor_in_rows)\n      .set_width(tensor_in_cols)\n      .set_feature_map_count(params.depth)\n      .set_layout(data_layout);\n\n  auto orig_output_data =\n      AsDeviceMemory(transformed_output.template flat<T>().data(),\n                     transformed_output.template flat<T>().size());\n  auto orig_input_data =\n      AsDeviceMemory(transformed_input.template flat<T>().data(),\n                     transformed_input.template flat<T>().size());\n  auto output_backprop_data =\n      AsDeviceMemory(transformed_output_backprop.template flat<T>().data(),\n                     transformed_output_backprop.template flat<T>().size());\n  auto input_backprop_data = AsDeviceMemory(\n      transformed_and_padded_input_backprop.template flat<T>().data(),\n      transformed_and_padded_input_backprop.template flat<T>().size());\n\n  auto* stream = context->op_device_context()->stream();\n  OP_REQUIRES(context, stream, errors::Internal(\"No GPU stream available.\"));\n\n#if TENSORFLOW_USE_ROCM\n  static int64 PoolingScratchSize = GetDnnWorkspaceLimit(\n      // default value is in bytes despite the name of the environment variable\n      \"TF_CUDNN_WORKSPACE_LIMIT_IN_MB\", 1LL << 32  // 4GB\n  );\n\n  DnnScratchAllocator scratch_allocator(PoolingScratchSize, context);\n  bool status = stream\n                    ->ThenPoolBackward(pooling_desc, orig_input_desc,\n                                       orig_input_data, orig_output_desc,\n                                       orig_output_data, output_backprop_data,\n                                       &input_backprop_data, &scratch_allocator)\n                    .ok();\n#else\n  bool status =\n      stream\n          ->ThenPoolBackward(pooling_desc, orig_input_desc, orig_input_data,\n                             orig_output_desc, orig_output_data,\n                             output_backprop_data, &input_backprop_data)\n          .ok();\n#endif\n\n  OP_REQUIRES(context, status,\n              errors::Internal(\"dnn PoolBackward launch failed\"));\n\n  if (padding == EXPLICIT && (params.pad_top != params.pad_bottom ||\n                              params.pad_left != params.pad_right)) {\n    // Remove the padding that was added to the input shape above.\n    functor::PadInput<GPUDevice, T, int, 4>()(\n        context->eigen_device<GPUDevice>(),\n        To32Bit(const_cast<const Tensor&>(transformed_and_padded_input_backprop)\n                    .tensor<T, 4>()),\n        {{static_cast<int>(-input_pad_top), static_cast<int>(-input_pad_left)}},\n        {{static_cast<int>(-input_pad_bottom),\n          static_cast<int>(-input_pad_right)}},\n        To32Bit(transformed_input_backprop.template tensor<T, 4>()),\n        transformed_input_data_format, T{});\n  }\n\n#if CUDNN_VERSION < 7300\n  if (data_format == FORMAT_NHWC) {\n    /// Transform the output data from NCHW back to NHWC.\n    auto toConstTensor = [](const Tensor& x) -> const Tensor { return x; };\n    functor::NCHWToNHWC<GPUDevice, T, 4>()(\n        context->eigen_device<Device>(),\n        toConstTensor(transformed_input_backprop).template tensor<T, 4>(),\n        input_backprop->tensor<T, 4>());\n  }\n#endif  // CUDNN_VERSION < 7300\n}\n\n#define DEFINE_DNN_OPS(T)         \\\n  template class DnnPoolingOp<T>; \\\n  template class DnnPoolingGradOp<T>;\nTF_CALL_GPU_NUMBER_TYPES(DEFINE_DNN_OPS)\n\n#if CUDNN_VERSION >= 7300\ntemplate class DnnPoolingOp<qint8>;\n#endif\n\n#undef DEFINE_DNN_OPS\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n}  // namespace tensorflow\n"], "fixing_code": ["/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/nn_ops.cc.\n\n#define EIGEN_USE_THREADS\n\n#include \"tensorflow/core/kernels/maxpooling_op.h\"\n\n#include <type_traits>\n#include <vector>\n\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/common_runtime/device.h\"\n#include \"tensorflow/core/framework/bounds_check.h\"\n#include \"tensorflow/core/framework/numeric_op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/tensor_slice.h\"\n#include \"tensorflow/core/kernels/conv_2d.h\"\n#include \"tensorflow/core/kernels/eigen_pooling.h\"\n#include \"tensorflow/core/kernels/ops_util.h\"\n#include \"tensorflow/core/kernels/pooling_ops_common.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/gtl/array_slice.h\"\n#include \"tensorflow/core/util/env_var.h\"\n#include \"tensorflow/core/util/padding.h\"\n#include \"tensorflow/core/util/tensor_format.h\"\n#include \"tensorflow/core/util/use_cudnn.h\"\n\n#if GOOGLE_CUDA\n#include \"third_party/gpus/cudnn/cudnn.h\"\n#endif  // GOOGLE_CUDA\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#include \"tensorflow/core/kernels/maxpooling_op_gpu.h\"\n#include \"tensorflow/core/kernels/pooling_ops_common_gpu.h\"\n#include \"tensorflow/core/platform/stream_executor.h\"\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\nnamespace tensorflow {\n\ntypedef Eigen::ThreadPoolDevice CPUDevice;\ntypedef Eigen::GpuDevice GPUDevice;\n\nconst int kInvalidMaxPoolingIndex = -1;\n\ntemplate <typename Device, typename T, typename Targmax>\nstatic void SpatialMaxPoolWithArgMaxHelper(\n    OpKernelContext* context, Tensor* output, Tensor* output_arg_max,\n    Tensor* input_backprop, const Tensor& tensor_in, const Tensor& out_backprop,\n    const PoolParameters& params, const bool include_batch_in_index) {\n  if (input_backprop != nullptr) {\n    OP_REQUIRES(\n        context, include_batch_in_index,\n        errors::Internal(\n            \"SpatialMaxPoolWithArgMaxHelper requires include_batch_in_index \"\n            \"to be True when input_backprop != nullptr\"));\n    OP_REQUIRES(\n        context, (std::is_same<Targmax, int64>::value),\n        errors::Internal(\"SpatialMaxPoolWithArgMaxHelper requires Targmax \"\n                         \"to be int64 when input_backprop != nullptr\"));\n  }\n  if (tensor_in.NumElements() == 0 || output->NumElements() == 0) return;\n\n  typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n      ConstEigenMatrixMap;\n  typedef Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n      EigenMatrixMap;\n  typedef Eigen::Map<Eigen::Matrix<Targmax, Eigen::Dynamic, Eigen::Dynamic>>\n      EigenIndexMatrixMap;\n\n  ConstEigenMatrixMap in_mat(\n      tensor_in.flat<T>().data(), params.depth,\n      params.tensor_in_cols * params.tensor_in_rows * params.tensor_in_batch);\n  EigenMatrixMap out_mat(\n      output->flat<T>().data(), params.depth,\n      params.out_width * params.out_height * params.tensor_in_batch);\n  EigenIndexMatrixMap out_arg_max_mat(\n      output_arg_max->flat<Targmax>().data(), params.depth,\n      params.out_width * params.out_height * params.tensor_in_batch);\n\n  const DeviceBase::CpuWorkerThreads& worker_threads =\n      *(context->device()->tensorflow_cpu_worker_threads());\n\n  // The following code basically does the following:\n  // 1. Flattens the input and output tensors into two dimensional arrays.\n  //    tensor_in_as_matrix:\n  //      depth by (tensor_in_cols * tensor_in_rows * tensor_in_batch)\n  //    output_as_matrix:\n  //      depth by (out_width * out_height * tensor_in_batch)\n  //\n  // 2. Walks through the set of columns in the flattened tensor_in_as_matrix,\n  //    and updates the corresponding column(s) in output_as_matrix with the\n  //    max value.\n  auto shard = [&params, &in_mat, &out_mat, &out_arg_max_mat, &input_backprop,\n                &output_arg_max, &out_backprop,\n                include_batch_in_index](int64_t start, int64_t limit) {\n    const int32_t depth = params.depth;\n    const int32_t in_rows = params.tensor_in_rows;\n    const int32_t in_cols = params.tensor_in_cols;\n    const int32_t pad_top = params.pad_top;\n    const int32_t pad_left = params.pad_left;\n    const int32_t window_rows = params.window_rows;\n    const int32_t window_cols = params.window_cols;\n    const int32_t row_stride = params.row_stride;\n    const int32_t col_stride = params.col_stride;\n    const int32_t out_height = params.out_height;\n    const int32_t out_width = params.out_width;\n\n    {\n      // Initializes the output tensor with MIN<T>.\n      const int32_t output_image_size = out_height * out_width * depth;\n      EigenMatrixMap out_shard(out_mat.data() + start * output_image_size, 1,\n                               (limit - start) * output_image_size);\n      out_shard.setConstant(Eigen::NumTraits<T>::lowest());\n      EigenIndexMatrixMap out_arg_max_shard(\n          out_arg_max_mat.data() + start * output_image_size, 1,\n          (limit - start) * output_image_size);\n      out_arg_max_shard.setConstant(kInvalidMaxPoolingIndex);\n    }\n\n    for (int64_t b = start; b < limit; ++b) {\n      for (int h = 0; h < in_rows; ++h) {\n        for (int w = 0; w < in_cols; ++w) {\n          // (h_start, h_end) * (w_start, w_end) is the range that the input\n          // vector projects to.\n          const int hpad = h + pad_top;\n          const int wpad = w + pad_left;\n          const int h_start =\n              (hpad < window_rows) ? 0 : (hpad - window_rows) / row_stride + 1;\n          const int h_end = std::min(hpad / row_stride + 1, out_height);\n          const int w_start =\n              (wpad < window_cols) ? 0 : (wpad - window_cols) / col_stride + 1;\n          const int w_end = std::min(wpad / col_stride + 1, out_width);\n          // compute elementwise max\n          const int64_t in_index = (b * in_rows + h) * in_cols + w;\n          for (int ph = h_start; ph < h_end; ++ph) {\n            const int64_t out_index_base = (b * out_height + ph) * out_width;\n            for (int pw = w_start; pw < w_end; ++pw) {\n              const int64_t out_index = out_index_base + pw;\n              /// NOTES(zhengxq): not using the eigen matrix operation for\n              /// now.\n              for (int d = 0; d < depth; ++d) {\n                const T& input_ref = in_mat.coeffRef(d, in_index);\n                T& output_ref = out_mat.coeffRef(d, out_index);\n                Targmax& out_arg_max_ref =\n                    out_arg_max_mat.coeffRef(d, out_index);\n                if (output_ref < input_ref ||\n                    out_arg_max_ref == kInvalidMaxPoolingIndex) {\n                  output_ref = input_ref;\n                  if (include_batch_in_index) {\n                    out_arg_max_ref = in_index * depth + d;\n                  } else {\n                    out_arg_max_ref = (h * in_cols + w) * depth + d;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (input_backprop != nullptr) {\n      auto input_backprop_flat = input_backprop->flat<T>();\n      auto out_arg_max_flat = output_arg_max->flat<int64>();\n      auto out_backprop_flat = out_backprop.flat<T>();\n\n      // Initialize output to 0.\n      const int64_t in_size = in_rows * in_cols * depth;\n      const int64_t in_start = start * in_size;\n      const int64_t in_end = limit * in_size;\n      EigenMatrixMap in_shard(input_backprop_flat.data() + in_start, 1,\n                              in_end - in_start);\n      in_shard.setConstant(T(0));\n\n      // Backpropagate.\n      const int out_size = out_height * out_width * depth;\n      const int out_start = start * out_size;\n      const int out_end = limit * out_size;\n      for (int index = out_start; index < out_end; ++index) {\n        int input_backprop_index = out_arg_max_flat(index);\n        // Although this check is in the inner loop, it is worth its value\n        // so we don't end up with memory corruptions. Our benchmark shows that\n        // the performance impact is quite small\n        // CHECK(input_backprop_index >= in_start && input_backprop_index <\n        // in_end)\n        FastBoundsCheck(input_backprop_index - in_start, in_end - in_start);\n        if (index < out_backprop.NumElements()) {\n          input_backprop_flat(input_backprop_index) += out_backprop_flat(index);\n        }\n      }\n    }\n  };\n\n  const int64_t shard_cost = params.tensor_in_rows * params.tensor_in_cols *\n                             params.depth * params.window_rows *\n                             params.window_cols;\n  Shard(worker_threads.num_threads, worker_threads.workers,\n        params.tensor_in_batch, shard_cost, shard);\n}\n\n// The operation to compute MaxPool gradients.\n// It takes three inputs:\n//   - The original input tensor\n//   - The original output tensor\n//   - Backprop tensor for output\n// It produces one output: backprop tensor for input.\ntemplate <class Device, class T>\nclass MaxPoolingGradOp : public OpKernel {\n public:\n  explicit MaxPoolingGradOp(OpKernelConstruction* context) : OpKernel(context) {\n    string data_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n    OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                errors::InvalidArgument(\"Invalid data format\"));\n    OP_REQUIRES(\n        context, data_format_ == FORMAT_NHWC,\n        errors::InvalidArgument(\"Default MaxPoolingGradOp only supports NHWC \",\n                                \"on device type \",\n                                DeviceTypeString(context->device_type())));\n\n    if (context->num_inputs() == 3) {\n      OP_REQUIRES_OK(context, context->GetAttr(\"ksize\", &ksize_));\n      OP_REQUIRES(context, ksize_.size() == 4,\n                  errors::InvalidArgument(\"Sliding window ksize field must \"\n                                          \"specify 4 dimensions\"));\n      OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n      OP_REQUIRES(context, stride_.size() == 4,\n                  errors::InvalidArgument(\"Sliding window strides field must \"\n                                          \"specify 4 dimensions\"));\n      OP_REQUIRES(context, ksize_[0] == 1 && stride_[0] == 1,\n                  errors::Unimplemented(\n                      \"Pooling is not yet supported on the batch dimension.\"));\n      OP_REQUIRES(\n          context, ksize_[3] == 1 && stride_[3] == 1,\n          errors::Unimplemented(\n              \"MaxPoolingGrad is not yet supported on the depth dimension.\"));\n    }\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n\n    if (padding_ == Padding::EXPLICIT) {\n      OP_REQUIRES_OK(\n          context, context->GetAttr(\"explicit_paddings\", &explicit_paddings_));\n      OP_REQUIRES_OK(context, CheckValidPadding(padding_, explicit_paddings_,\n                                                /*num_dims=*/4, data_format_));\n    }\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& tensor_out = context->input(1);\n    const Tensor& out_backprop = context->input(2);\n\n    // For maxpooling, tensor_in should have 4 dimensions.\n    OP_REQUIRES(context, tensor_in.dims() == 4,\n                errors::InvalidArgument(\"tensor_in must be 4-dimensional\"));\n    OP_REQUIRES(context, tensor_out.dims() == 4,\n                errors::InvalidArgument(\"tensor_out must be 4-dimensional\"));\n    // For maxpooling, out_backprop should have 4 dimensions.\n    OP_REQUIRES(context, out_backprop.dims() == 4,\n                errors::InvalidArgument(\"out_backprop must be 4-dimensional\"));\n\n    const TensorShape& output_shape = tensor_in.shape();\n\n    Tensor tensor_out_dup;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_temp(\n                                {1}, DataTypeToEnum<T>::v(), tensor_out.shape(),\n                                &tensor_out_dup));\n    Tensor tensor_out_arg_max;\n    OP_REQUIRES_OK(context, context->allocate_temp(DataTypeToEnum<int64>::v(),\n                                                   tensor_out.shape(),\n                                                   &tensor_out_arg_max));\n    std::vector<int32> ksize = ksize_;\n    std::vector<int32> stride = stride_;\n    if (context->num_inputs() == 5) {\n      const Tensor& tensor_ksize = context->input(3);\n      auto value_ksize = tensor_ksize.flat<int32>();\n      ksize.resize(tensor_ksize.shape().num_elements());\n      std::copy_n(&value_ksize(0), ksize.size(), ksize.begin());\n\n      const Tensor& tensor_stride = context->input(4);\n      auto value_stride = tensor_stride.flat<int32>();\n      stride.resize(tensor_stride.shape().num_elements());\n      std::copy_n(&value_stride(0), stride.size(), stride.begin());\n    }\n\n    OP_REQUIRES(context, ksize.size() == 4,\n                errors::InvalidArgument(\"Sliding window ksize field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES(context, stride.size() == 4,\n                errors::InvalidArgument(\"Sliding window strides field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES(context, ksize[0] == 1 && stride[0] == 1,\n                errors::Unimplemented(\n                    \"Pooling is not yet supported on the batch dimension.\"));\n    OP_REQUIRES(\n        context, ksize[3] == 1 && stride[3] == 1,\n        errors::Unimplemented(\n            \"MaxPoolingGrad is not yet supported on the depth dimension.\"));\n\n    PoolParameters params{context,\n                          ksize,\n                          stride,\n                          padding_,\n                          explicit_paddings_,\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, output_shape, &output));\n\n    SpatialMaxPoolWithArgMaxHelper<CPUDevice, T, int64>(\n        context, &tensor_out_dup, &tensor_out_arg_max, output, tensor_in,\n        out_backprop, params, true);\n  }\n\n private:\n  std::vector<int32> ksize_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  std::vector<int64> explicit_paddings_;\n  TensorFormat data_format_;\n};\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\ntemplate <class T>\nclass MaxPoolingGradOp<Eigen::GpuDevice, T> : public OpKernel {\n public:\n  typedef Eigen::GpuDevice Device;\n\n  explicit MaxPoolingGradOp(OpKernelConstruction* context) : OpKernel(context) {\n    string data_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n    OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                errors::InvalidArgument(\"Invalid data format\"));\n    if (context->num_inputs() == 3) {\n      OP_REQUIRES_OK(context, context->GetAttr(\"ksize\", &ksize_));\n      OP_REQUIRES(context, ksize_.size() == 4,\n                  errors::InvalidArgument(\"Sliding window ksize field must \"\n                                          \"specify 4 dimensions\"));\n      OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n      OP_REQUIRES(context, stride_.size() == 4,\n                  errors::InvalidArgument(\"Sliding window strides field must \"\n                                          \"specify 4 dimensions\"));\n      const int32_t ksize_n = GetTensorDim(ksize_, data_format_, 'N');\n      const int32_t stride_n = GetTensorDim(stride_, data_format_, 'N');\n      OP_REQUIRES(context, ksize_n == 1 && stride_n == 1,\n                  errors::Unimplemented(\n                      \"Pooling is not yet supported on the batch dimension.\"));\n    }\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n    if (padding_ == Padding::EXPLICIT) {\n      OP_REQUIRES_OK(\n          context, context->GetAttr(\"explicit_paddings\", &explicit_paddings_));\n      OP_REQUIRES_OK(context, CheckValidPadding(padding_, explicit_paddings_,\n                                                /*num_dims=*/4, data_format_));\n    }\n    TF_CHECK_OK(ReadBoolFromEnvVar(\"TF_ENABLE_MAXPOOL_NANPROP\", false,\n                                   &propagate_nans_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& tensor_out = context->input(1);\n    const Tensor& out_backprop = context->input(2);\n\n    // For maxpooling, tensor_in should have 4 dimensions.\n    OP_REQUIRES(context, tensor_in.dims() == 4,\n                errors::InvalidArgument(\"tensor_in must be 4-dimensional 4\"));\n    OP_REQUIRES(context, tensor_out.dims() == 4,\n                errors::InvalidArgument(\"tensor_out must be 4-dimensional\"));\n    // For maxpooling, out_backprop should have 4 dimensions.\n    OP_REQUIRES(context, out_backprop.dims() == 4,\n                errors::InvalidArgument(\"out_backprop must be 4-dimensional\"));\n\n    TensorShape output_shape = tensor_in.shape();\n\n    std::vector<int32> ksize = ksize_;\n    std::vector<int32> stride = stride_;\n    if (context->num_inputs() == 5) {\n      const Tensor& tensor_ksize = context->input(3);\n      auto value_ksize = tensor_ksize.flat<int32>();\n      ksize.resize(tensor_ksize.shape().num_elements());\n      std::copy_n(&value_ksize(0), ksize.size(), ksize.begin());\n\n      const Tensor& tensor_stride = context->input(4);\n      auto value_stride = tensor_stride.flat<int32>();\n      stride.resize(tensor_stride.shape().num_elements());\n      std::copy_n(&value_stride(0), stride.size(), stride.begin());\n    }\n    OP_REQUIRES(context, ksize.size() == 4,\n                errors::InvalidArgument(\"Sliding window ksize field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES(context, stride.size() == 4,\n                errors::InvalidArgument(\"Sliding window strides field must \"\n                                        \"specify 4 dimensions\"));\n    const int32_t ksize_n = GetTensorDim(ksize, data_format_, 'N');\n    const int32_t stride_n = GetTensorDim(stride, data_format_, 'N');\n    OP_REQUIRES(context, ksize_n == 1 && stride_n == 1,\n                errors::Unimplemented(\n                    \"Pooling is not yet supported on the batch dimension.\"));\n    int64_t pad_top, pad_bottom, pad_left, pad_right;\n    if (padding_ == Padding::EXPLICIT) {\n      GetExplicitPaddingForDim(explicit_paddings_, data_format_, 'H',\n                               /*pad_top=*/&pad_top,\n                               /*pad_bottom=*/&pad_bottom);\n      GetExplicitPaddingForDim(explicit_paddings_, data_format_, 'W',\n                               /*pad_left=*/&pad_left,\n                               /*pad_right=*/&pad_right);\n    }\n    DnnPoolingGradOp<T>::Compute(context, se::dnn::PoolingMode::kMaximum, ksize,\n                                 stride, padding_, explicit_paddings_,\n                                 data_format_, &tensor_in, &tensor_out,\n                                 out_backprop, output_shape, propagate_nans_);\n  }\n\n private:\n  std::vector<int32> ksize_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  std::vector<int64> explicit_paddings_;\n  TensorFormat data_format_;\n  bool propagate_nans_;\n};\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n// The operation to compute gradient of MaxPool gradients.\n// It takes three inputs:\n//   - The original input tensor\n//   - The original output tensor\n//   - Backprop tensor for output gradients\n// It produces one output: backprop tensor for output gradient.\ntemplate <class Device, class T>\nclass MaxPoolingGradGradOp : public OpKernel {\n public:\n  explicit MaxPoolingGradGradOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string data_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n    OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                errors::InvalidArgument(\"Invalid data format\"));\n    OP_REQUIRES(\n        context, data_format_ == FORMAT_NHWC,\n        errors::InvalidArgument(\n            \"Default MaxPoolingGradGradOp only supports NHWC \",\n            \"on device type \", DeviceTypeString(context->device_type())));\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n\n    if (context->num_inputs() == 3) {\n      OP_REQUIRES_OK(context, context->GetAttr(\"ksize\", &ksize_));\n      OP_REQUIRES(context, ksize_.size() == 4,\n                  errors::InvalidArgument(\"Sliding window ksize field must \"\n                                          \"specify 4 dimensions\"));\n      OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n      OP_REQUIRES(context, stride_.size() == 4,\n                  errors::InvalidArgument(\"Sliding window strides field must \"\n                                          \"specify 4 dimensions\"));\n      OP_REQUIRES(context, ksize_[0] == 1 && stride_[0] == 1,\n                  errors::Unimplemented(\n                      \"Pooling is not yet supported on the batch dimension.\"));\n      OP_REQUIRES(context, ksize_[3] == 1 && stride_[3] == 1,\n                  errors::Unimplemented(\"MaxPoolingGradGrad is not yet \"\n                                        \"supported on the depth dimension.\"));\n    }\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& tensor_out = context->input(1);\n    const Tensor& out_grad_backprop = context->input(2);\n\n    // For maxpooling, tensor_in should have 4 dimensions.\n    OP_REQUIRES(context, tensor_in.dims() == 4,\n                errors::InvalidArgument(\"tensor_in must be 4-dimensional\"));\n    OP_REQUIRES(context, tensor_out.dims() == 4,\n                errors::InvalidArgument(\"tensor_out must be 4-dimensional\"));\n    // For maxpooling, out_grad_backprop should have 4 dimensions.\n    OP_REQUIRES(\n        context, out_grad_backprop.dims() == 4,\n        errors::InvalidArgument(\"out_grad_backprop must be 4-dimensional\"));\n\n    std::vector<int32> ksize = ksize_;\n    std::vector<int32> stride = stride_;\n    if (context->num_inputs() == 5) {\n      const Tensor& tensor_ksize = context->input(3);\n      auto value_ksize = tensor_ksize.flat<int32>();\n      ksize.resize(tensor_ksize.shape().num_elements());\n      std::copy_n(&value_ksize(0), ksize.size(), ksize.begin());\n\n      const Tensor& tensor_stride = context->input(4);\n      auto value_stride = tensor_stride.flat<int32>();\n      stride.resize(tensor_stride.shape().num_elements());\n      std::copy_n(&value_stride(0), stride.size(), stride.begin());\n    }\n\n    OP_REQUIRES(context, ksize.size() == 4,\n                errors::InvalidArgument(\"Sliding window ksize field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES(context, stride.size() == 4,\n                errors::InvalidArgument(\"Sliding window strides field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES(context, ksize[0] == 1 && stride[0] == 1,\n                errors::Unimplemented(\n                    \"Pooling is not yet supported on the batch dimension.\"));\n    OP_REQUIRES(\n        context, ksize[3] == 1 && stride[3] == 1,\n        errors::Unimplemented(\n            \"MaxPoolingGrad is not yet supported on the depth dimension.\"));\n\n    PoolParameters params{context,\n                          ksize,\n                          stride,\n                          padding_,\n                          /*explicit_paddings=*/{},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {2}, 0, tensor_out.shape(), &output));\n\n    SpatialMaxPoolGradGrad(context, output, tensor_in, tensor_out,\n                           out_grad_backprop, params, padding_);\n  }\n\n private:\n  void SpatialMaxPoolGradGrad(OpKernelContext* context, Tensor* bottom_diff,\n                              const Tensor& tensor_in, const Tensor& tensor_out,\n                              const Tensor& top_diff,\n                              const PoolParameters& params,\n                              const Padding& padding) {\n    typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n        ConstEigenMatrixMap;\n    typedef Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n        EigenMatrixMap;\n\n    ConstEigenMatrixMap in_mat(\n        tensor_in.flat<T>().data(), params.depth,\n        params.tensor_in_cols * params.tensor_in_rows * params.tensor_in_batch);\n    ConstEigenMatrixMap out_mat(\n        tensor_out.flat<T>().data(), params.depth,\n        params.out_width * params.out_height * params.tensor_in_batch);\n    ConstEigenMatrixMap top_diff_mat(\n        top_diff.flat<T>().data(), params.depth,\n        params.tensor_in_cols * params.tensor_in_rows * params.tensor_in_batch);\n    EigenMatrixMap bottom_diff_mat(\n        bottom_diff->flat<T>().data(), params.depth,\n        params.out_width * params.out_height * params.tensor_in_batch);\n\n    const DeviceBase::CpuWorkerThreads& worker_threads =\n        *(context->device()->tensorflow_cpu_worker_threads());\n\n    // The following code basically does the following:\n    // 1. Flattens the input, output, top_diff and bottom_diff tensors into\n    //    two dimensional arrays.\n    //    tensor_in_as_matrix:\n    //      depth by (tensor_in_cols * tensor_in_rows * tensor_in_batch)\n    //    tensor_out_as_matrix:\n    //      depth by (out_width * out_height * tensor_in_batch)\n    //    top_diff_as_matrix:\n    //      depth by (tensor_in_cols * tensor_in_rows * tensor_in_batch)\n    //    bottom_diff_as_matrix:\n    //      depth by (out_width * out_height * tensor_in_batch)\n    //\n    // 2. Walks through the set of columns in the flattened\n    //    tensor_in_as_matrix, tensor_out_as_matrix, top_diff_as_matrix\n    //    and updates the column(s) corresponding to the maximum values in\n    //    tensor_out_as_matrix with the corresponding values in\n    //    top_diff_as_matrix.\n    auto shard = [&params, &in_mat, &out_mat, &top_diff_mat, &bottom_diff_mat](\n                     int64_t start, int64_t limit) {\n      const int32_t depth = params.depth;\n      const int32_t in_rows = params.tensor_in_rows;\n      const int32_t in_cols = params.tensor_in_cols;\n      const int32_t pad_top = params.pad_top;\n      const int32_t pad_left = params.pad_left;\n      const int32_t window_rows = params.window_rows;\n      const int32_t window_cols = params.window_cols;\n      const int32_t row_stride = params.row_stride;\n      const int32_t col_stride = params.col_stride;\n      const int32_t out_height = params.out_height;\n      const int32_t out_width = params.out_width;\n\n      {\n        // Initializes the output grad backprop tensor with 0.\n        const int32_t output_image_size = out_height * out_width * params.depth;\n        EigenMatrixMap bottom_diff_shard(\n            bottom_diff_mat.data() + start * output_image_size, 1,\n            (limit - start) * output_image_size);\n        bottom_diff_shard.setZero();\n      }\n\n      for (int b = start; b < limit; ++b) {\n        for (int ph = 0; ph < out_height; ++ph) {\n          for (int pw = 0; pw < out_width; ++pw) {\n            // (h_start, h_end) * (w_start, w_end) is the range that the input\n            // vector projects to.\n            int h_start = ph * row_stride - pad_top;\n            const int h_end = std::min(h_start + window_rows, in_rows);\n            int w_start = pw * col_stride - pad_left;\n            const int w_end = std::min(w_start + window_cols, in_cols);\n            h_start = std::max(h_start, 0);\n            w_start = std::max(w_start, 0);\n            const int out_index = (b * out_height + ph) * out_width + pw;\n            // Find value corresponding to the input maximum in top_diff.\n            for (int d = 0; d < depth; ++d) {\n              const T& output_ref = out_mat.coeffRef(d, out_index);\n              bool should_stop = false;\n              for (int h = h_start; h < h_end && !should_stop; ++h) {\n                for (int w = w_start; w < w_end && !should_stop; ++w) {\n                  const int in_index = (b * in_rows + h) * in_cols + w;\n                  const T& input_ref = in_mat.coeffRef(d, in_index);\n                  if (output_ref == input_ref) {\n                    T& bottom_diff_ref = bottom_diff_mat.coeffRef(d, out_index);\n                    bottom_diff_ref = top_diff_mat.coeffRef(d, in_index);\n                    should_stop = true;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    };\n\n    const int64_t shard_cost = params.out_width * params.out_height *\n                               params.depth * params.window_rows *\n                               params.window_cols;\n    Shard(worker_threads.num_threads, worker_threads.workers,\n          params.tensor_in_batch, shard_cost, shard);\n  }\n\n  std::vector<int32> ksize_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  TensorFormat data_format_;\n};\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\ntemplate <class T>\nclass MaxPoolingGradGradOp<Eigen::GpuDevice, T> : public OpKernel {\n public:\n  typedef Eigen::GpuDevice Device;\n\n  explicit MaxPoolingGradGradOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string data_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n    OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                errors::InvalidArgument(\"Invalid data format\"));\n    if (context->num_inputs() == 3) {\n      OP_REQUIRES_OK(context, context->GetAttr(\"ksize\", &ksize_));\n      OP_REQUIRES(context, ksize_.size() == 4,\n                  errors::InvalidArgument(\"Sliding window ksize field must \"\n                                          \"specify 4 dimensions\"));\n      OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n      OP_REQUIRES(context, stride_.size() == 4,\n                  errors::InvalidArgument(\"Sliding window strides field must \"\n                                          \"specify 4 dimensions\"));\n      const int32_t ksize_n = GetTensorDim(ksize_, data_format_, 'N');\n      const int32_t stride_n = GetTensorDim(stride_, data_format_, 'N');\n      OP_REQUIRES(context, ksize_n == 1 && stride_n == 1,\n                  errors::Unimplemented(\n                      \"Pooling is not yet supported on the batch dimension.\"));\n    }\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& tensor_out = context->input(1);\n    const Tensor& out_grad_backprop = context->input(2);\n\n    // For maxpooling, tensor_in should have 4 dimensions.\n    OP_REQUIRES(context, tensor_in.dims() == 4,\n                errors::InvalidArgument(\"tensor_in must be 4-dimensional 4\"));\n    OP_REQUIRES(context, tensor_out.dims() == 4,\n                errors::InvalidArgument(\"tensor_out must be 4-dimensional\"));\n    // For maxpooling, out_grad_backprop should have 4 dimensions.\n    OP_REQUIRES(\n        context, out_grad_backprop.dims() == 4,\n        errors::InvalidArgument(\"out_grad_backprop must be 4-dimensional\"));\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, tensor_out.shape(), &output));\n\n    std::vector<int32> ksize = ksize_;\n    std::vector<int32> stride = stride_;\n    if (context->num_inputs() == 5) {\n      const Tensor& tensor_ksize = context->input(3);\n      auto value_ksize = tensor_ksize.flat<int32>();\n      ksize.resize(tensor_ksize.shape().num_elements());\n      std::copy_n(&value_ksize(0), ksize.size(), ksize.begin());\n\n      const Tensor& tensor_stride = context->input(4);\n      auto value_stride = tensor_stride.flat<int32>();\n      stride.resize(tensor_stride.shape().num_elements());\n      std::copy_n(&value_stride(0), stride.size(), stride.begin());\n    }\n\n    OP_REQUIRES(context, ksize.size() == 4,\n                errors::InvalidArgument(\"Sliding window ksize field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES(context, stride.size() == 4,\n                errors::InvalidArgument(\"Sliding window strides field must \"\n                                        \"specify 4 dimensions\"));\n    const int32_t ksize_n = GetTensorDim(ksize, data_format_, 'N');\n    const int32_t stride_n = GetTensorDim(stride, data_format_, 'N');\n    OP_REQUIRES(context, ksize_n == 1 && stride_n == 1,\n                errors::Unimplemented(\n                    \"Pooling is not yet supported on the batch dimension.\"));\n\n    PoolParameters params{context,\n                          ksize,\n                          stride,\n                          padding_,\n                          /*explicit_paddings=*/{},\n                          data_format_,\n                          tensor_in.shape()};\n\n    functor::MaxPoolGradBackwardNoMask<T>()(\n        data_format_, tensor_in.flat<T>().data(), tensor_out.flat<T>().data(),\n        params.tensor_in_batch, params.out_height, params.out_width,\n        params.depth, params.tensor_in_rows, params.tensor_in_cols,\n        params.window_rows, params.window_cols, params.row_stride,\n        params.col_stride, params.pad_top, params.pad_left,\n        out_grad_backprop.flat<T>().data(), output->flat<T>().data(),\n        context->eigen_device<Eigen::GpuDevice>());\n  }\n\n private:\n  std::vector<int32> ksize_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  TensorFormat data_format_;\n  bool use_dnn_;\n};\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\ntemplate <typename Device, typename T>\nstruct LaunchMaxPoolingNoMask;\n\ntemplate <typename Device, typename T>\nclass MaxPoolingNoMaskOp : public OpKernel {\n public:\n  explicit MaxPoolingNoMaskOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string data_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n    OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                errors::InvalidArgument(\"Invalid data format\"));\n    OP_REQUIRES(\n        context, data_format_ == FORMAT_NHWC,\n        errors::InvalidArgument(\n            \"Default MaxPoolingNoMaskOp only supports NHWC on device type \",\n            DeviceTypeString(context->device_type())));\n    OP_REQUIRES_OK(context, context->GetAttr(\"ksize\", &ksize_));\n    OP_REQUIRES(context, ksize_.size() == 4,\n                errors::InvalidArgument(\"Sliding window ksize field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n    OP_REQUIRES(context, stride_.size() == 4,\n                errors::InvalidArgument(\"Sliding window stride field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n    OP_REQUIRES(context, ksize_[0] == 1 && stride_[0] == 1,\n                errors::Unimplemented(\n                    \"Pooling is not yet supported on the batch dimension.\"));\n    OP_REQUIRES(\n        context, padding_ != EXPLICIT,\n        errors::Unimplemented(\n            \"Explicit padding is not supported for MaxPoolingNoMaskOp.\"));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          /*explicit_paddings=*/{},\n                          data_format_,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n\n    TensorShape out_shape({params.tensor_in_batch, params.out_height,\n                           params.out_width, params.depth});\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));\n\n    LaunchMaxPoolingNoMask<Device, T>::launch(context, params, tensor_in,\n                                              output);\n  }\n\n private:\n  std::vector<int32> ksize_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  TensorFormat data_format_;\n};\n\ntemplate <typename Device, typename T>\nclass MaxPoolingNoMaskV2Op : public OpKernel {\n public:\n  explicit MaxPoolingNoMaskV2Op(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string data_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n    OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                errors::InvalidArgument(\"Invalid data format\"));\n    OP_REQUIRES(\n        context, data_format_ == FORMAT_NHWC,\n        errors::InvalidArgument(\n            \"Default MaxPoolingNoMaskOp only supports NHWC on device type \",\n            DeviceTypeString(context->device_type())));\n    if (context->num_inputs() == 1) {\n      OP_REQUIRES_OK(context, context->GetAttr(\"ksize\", &ksize_));\n      OP_REQUIRES(context, ksize_.size() == 4,\n                  errors::InvalidArgument(\"Sliding window ksize field must \"\n                                          \"specify 4 dimensions\"));\n      OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n      OP_REQUIRES(context, stride_.size() == 4,\n                  errors::InvalidArgument(\"Sliding window stride field must \"\n                                          \"specify 4 dimensions\"));\n      OP_REQUIRES(context, ksize_[0] == 1 && stride_[0] == 1,\n                  errors::Unimplemented(\n                      \"Pooling is not yet supported on the batch dimension.\"));\n    }\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n\n    std::vector<int32> ksize = ksize_;\n    std::vector<int32> stride = stride_;\n\n    if (context->num_inputs() != 1) {\n      const Tensor& tensor_ksize = context->input(1);\n      auto value_ksize = tensor_ksize.flat<int32>();\n      ksize.resize(tensor_ksize.shape().num_elements());\n      std::copy_n(&value_ksize(0), ksize.size(), ksize.begin());\n\n      const Tensor& tensor_stride = context->input(2);\n      auto value_stride = tensor_stride.flat<int32>();\n      stride.resize(tensor_stride.shape().num_elements());\n      std::copy_n(&value_stride(0), stride.size(), stride.begin());\n    }\n    OP_REQUIRES(context, ksize.size() == 4,\n                errors::InvalidArgument(\"Sliding window ksize field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES(context, stride.size() == 4,\n                errors::InvalidArgument(\"Sliding window stride field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES(context, ksize[0] == 1 && stride[0] == 1,\n                errors::Unimplemented(\n                    \"Pooling is not yet supported on the batch dimension.\"));\n    PoolParameters params{context,\n                          ksize,\n                          stride,\n                          padding_,\n                          /*explicit_paddings=*/{},\n                          data_format_,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n\n    TensorShape out_shape({params.tensor_in_batch, params.out_height,\n                           params.out_width, params.depth});\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));\n\n    LaunchMaxPoolingNoMask<Device, T>::launch(context, params, tensor_in,\n                                              output);\n  }\n\n private:\n  std::vector<int32> ksize_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  TensorFormat data_format_;\n};\n\ntemplate <typename Device, typename T, typename Targmax>\nstruct LaunchMaxPoolingWithArgmax;\n\ntemplate <typename T, typename Targmax>\nstruct LaunchMaxPoolingWithArgmax<CPUDevice, T, Targmax> {\n  static void launch(OpKernelContext* context, const PoolParameters& params,\n                     const Tensor& input, Tensor* output, Tensor* argmax,\n                     bool propagate_nans, bool include_batch_in_index) {\n    Tensor unused;\n    SpatialMaxPoolWithArgMaxHelper<CPUDevice, T, Targmax>(\n        context, output, argmax, /*input_backprop=*/nullptr, input, unused,\n        params, include_batch_in_index);\n  }\n};\n\ntemplate <typename Device, typename T, typename Targmax>\nclass MaxPoolingWithArgmaxOp : public OpKernel {\n public:\n  explicit MaxPoolingWithArgmaxOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"ksize\", &ksize_));\n    OP_REQUIRES(context, ksize_.size() == 4,\n                errors::InvalidArgument(\"Sliding window ksize field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n    OP_REQUIRES(context, stride_.size() == 4,\n                errors::InvalidArgument(\"Sliding window stride field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n    OP_REQUIRES(context, ksize_[0] == 1 && stride_[0] == 1,\n                errors::Unimplemented(\n                    \"Pooling is not yet supported on the batch dimension.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"include_batch_in_index\",\n                                             &include_batch_in_index_));\n    TF_CHECK_OK(ReadBoolFromEnvVar(\"TF_ENABLE_MAXPOOL_NANPROP\", false,\n                                   &propagate_nans_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    OP_REQUIRES(context, tensor_in.dims() == 4,\n                errors::InvalidArgument(\"tensor_in must be 4-dimensional (2)\"));\n    OP_REQUIRES(context, tensor_in.NumElements() > 0,\n                errors::InvalidArgument(\"tensor_in must not be empty (2)\"));\n\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          /*explicit_paddings=*/{},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n\n    TensorShape out_shape({params.tensor_in_batch, params.out_height,\n                           params.out_width, params.depth});\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));\n    Tensor* argmax = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, out_shape, &argmax));\n\n    LaunchMaxPoolingWithArgmax<Device, T, Targmax>::launch(\n        context, params, tensor_in, output, argmax, propagate_nans_,\n        include_batch_in_index_);\n  }\n\n private:\n  std::vector<int32> ksize_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  bool propagate_nans_;\n  bool include_batch_in_index_;\n};\n\ntemplate <typename Device, typename T>\nstruct LaunchMaxPoolingGradWithArgmax;\n\ntemplate <typename T>\nstruct LaunchMaxPoolingGradWithArgmax<CPUDevice, T> {\n  typedef Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n      EigenMatrixMap;\n\n  static void launch(OpKernelContext* context, const PoolParameters& params,\n                     const Tensor& grad_in, const Tensor& argmax,\n                     Tensor* grad_out, const bool include_batch_in_index) {\n    const DeviceBase::CpuWorkerThreads& worker_threads =\n        *(context->device()->tensorflow_cpu_worker_threads());\n\n    auto shard = [&grad_in, &argmax, &grad_out, include_batch_in_index](\n                     int64_t start, int64_t limit) {\n      const int64_t batch_size =\n          GetTensorDim(grad_out->shape(), FORMAT_NHWC, 'N');\n      const int64_t output_size_per_batch =\n          grad_out->NumElements() / batch_size;\n      const int64_t input_size_per_batch = grad_in.NumElements() / batch_size;\n\n      {\n        auto grad_out_flat = grad_out->flat<T>();\n        auto argmax_flat = argmax.flat<int64>();\n        auto grad_in_flat = grad_in.flat<T>();\n\n        const int64_t output_start = start * output_size_per_batch;\n        const int64_t output_end = limit * output_size_per_batch;\n        EigenMatrixMap inputShard(grad_out_flat.data() + output_start, 1,\n                                  output_end - output_start);\n        inputShard.setConstant(T(0));\n\n        const int input_start = start * input_size_per_batch;\n        const int input_end = limit * input_size_per_batch;\n        for (int64_t index = input_start; index < input_end; index++) {\n          if (index >= argmax.NumElements()) {\n            break;\n          }\n          int64_t grad_out_index = argmax_flat(index);\n          if (!include_batch_in_index) {\n            const int64_t cur_batch = index / input_size_per_batch;\n            grad_out_index += cur_batch * output_size_per_batch;\n          }\n          CHECK(grad_out_index >= output_start && grad_out_index < output_end)\n              << \"Invalid output gradient index: \" << grad_out_index << \", \"\n              << output_start << \", \" << output_end;\n          grad_out_flat(grad_out_index) += grad_in_flat(index);\n        }\n      }\n    };\n\n    const int64_t batch_size =\n        GetTensorDim(grad_out->shape(), FORMAT_NHWC, 'N');\n    const int64_t shard_cost = grad_out->NumElements() / batch_size;\n    Shard(worker_threads.num_threads, worker_threads.workers, batch_size,\n          shard_cost, shard);\n  }\n};\n\n// TODO(b/175733711): Support int32 argmax type in MaxPoolGradWithArgmax op.\ntemplate <typename Device, typename T>\nclass MaxPoolingGradWithArgmaxOp : public OpKernel {\n public:\n  explicit MaxPoolingGradWithArgmaxOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string data_format_str;\n    auto status = context->GetAttr(\"data_format\", &data_format_str);\n    if (status.ok()) {\n      OP_REQUIRES(context, FormatFromString(data_format_str, &data_format_),\n                  errors::InvalidArgument(\"Invalid data format\"));\n    }\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"ksize\", &ksize_));\n    OP_REQUIRES(context, ksize_.size() == 4,\n                errors::InvalidArgument(\"Sliding window ksize field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n    OP_REQUIRES(context, stride_.size() == 4,\n                errors::InvalidArgument(\"Sliding window stride field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n    OP_REQUIRES(context, ksize_[0] == 1 && stride_[0] == 1,\n                errors::Unimplemented(\n                    \"Pooling is not yet supported on the batch dimension.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"include_batch_in_index\",\n                                             &include_batch_in_index_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& grad_in = context->input(1);\n    const Tensor& argmax = context->input(2);\n\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          /*explicit_paddings=*/{},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n\n    TensorShape out_shape({params.tensor_in_batch, params.tensor_in_rows,\n                           params.tensor_in_cols, params.depth});\n    Tensor* grad_out = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, out_shape, &grad_out));\n\n    if (out_shape.num_elements() == 0) return;  // nothing to be done\n\n    LaunchMaxPoolingGradWithArgmax<Device, T>::launch(\n        context, params, grad_in, argmax, grad_out, include_batch_in_index_);\n  }\n\n private:\n  std::vector<int32> ksize_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  TensorFormat data_format_;\n  bool include_batch_in_index_;\n};\n\ntemplate <typename Device, typename T>\nstruct LaunchMaxPoolingGradGradWithArgmax;\n\ntemplate <typename Device, typename T>\nclass MaxPoolingGradGradWithArgmaxOp : public OpKernel {\n public:\n  explicit MaxPoolingGradGradWithArgmaxOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"ksize\", &ksize_));\n    OP_REQUIRES(context, ksize_.size() == 4,\n                errors::InvalidArgument(\"Sliding window ksize field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n    OP_REQUIRES(context, stride_.size() == 4,\n                errors::InvalidArgument(\"Sliding window stride field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n    OP_REQUIRES(context, ksize_[0] == 1 && stride_[0] == 1,\n                errors::Unimplemented(\n                    \"Pooling is not yet supported on the batch dimension.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"include_batch_in_index\",\n                                             &include_batch_in_index_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& grad_in = context->input(1);\n    const Tensor& argmax = context->input(2);\n\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          /*explicit_paddings=*/{},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n\n    TensorShape out_shape({params.tensor_in_batch, params.out_height,\n                           params.out_width, params.depth});\n\n    Tensor* grad_out = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, out_shape, &grad_out));\n\n    LaunchMaxPoolingGradGradWithArgmax<Device, T>::launch(\n        context, params, grad_in, argmax, grad_out, include_batch_in_index_);\n  }\n\n private:\n  std::vector<int32> ksize_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  bool include_batch_in_index_;\n};\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\ntemplate <typename T>\nclass MaxPoolingNoMaskOp<GPUDevice, T> : public OpKernel {\n public:\n  typedef GPUDevice Device;\n  explicit MaxPoolingNoMaskOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string data_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n    OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                errors::InvalidArgument(\"Invalid data format\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"ksize\", &ksize_));\n    OP_REQUIRES(context, ksize_.size() == 4,\n                errors::InvalidArgument(\"Sliding window ksize field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n    OP_REQUIRES(context, stride_.size() == 4,\n                errors::InvalidArgument(\"Sliding window stride field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n    OP_REQUIRES_OK(context,\n                   context->GetAttr(\"explicit_paddings\", &explicit_paddings_));\n    const int32_t ksize_n = GetTensorDim(ksize_, data_format_, 'N');\n    const int32_t stride_n = GetTensorDim(stride_, data_format_, 'N');\n    OP_REQUIRES(context, ksize_n == 1 && stride_n == 1,\n                errors::Unimplemented(\n                    \"Pooling is not yet supported on the batch dimension.\"));\n\n    TF_CHECK_OK(ReadBoolFromEnvVar(\"TF_ENABLE_MAXPOOL_NANPROP\", false,\n                                   &propagate_nans_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n\n    PoolParameters params{\n        context,      ksize_,           stride_, padding_, explicit_paddings_,\n        data_format_, tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n\n    TensorShape out_shape =\n        ShapeFromFormat(data_format_, params.tensor_in_batch, params.out_height,\n                        params.out_width, params.depth);\n\n    // Assuming qint8 <--> NCHW_VECT_C (int8x4) here.\n    constexpr bool is_int8x4 = std::is_same<T, qint8>::value;\n    OP_REQUIRES(context, (is_int8x4 == (data_format_ == FORMAT_NCHW_VECT_C)),\n                errors::InvalidArgument(\n                    \"qint8 should be used with data_format NCHW_VECT_C.\"));\n\n#if CUDNN_VERSION >= 7300\n    DnnPoolingOp<T>::Compute(context, se::dnn::PoolingMode::kMaximum, ksize_,\n                             stride_, padding_, explicit_paddings_,\n                             data_format_, tensor_in, out_shape,\n                             propagate_nans_);\n#else\n    // These is_int8x4 checks avoid linker errors for missing qint8 kernels.\n    if (!is_int8x4 && data_format_ == FORMAT_NCHW) {\n      DnnPoolingOp<T>::Compute(context, se::dnn::PoolingMode::kMaximum, ksize_,\n                               stride_, padding_, explicit_paddings_,\n                               data_format_, tensor_in, out_shape,\n                               propagate_nans_);\n    } else {\n#if !defined(TENSORFLOW_USE_ROCM)\n      OP_REQUIRES(context, padding_ != EXPLICIT,\n                  errors::Unimplemented(\"Explicit padding is not supported \",\n                                        \"when CUDNN is not enabled.\"));\n#endif\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));\n      if (is_int8x4) {\n        LaunchMaxPoolingNoMask_NCHW_VECT_C<Device>::launch(context, params,\n                                                           tensor_in, output);\n      } else if (data_format_ == FORMAT_NHWC) {\n        LaunchMaxPoolingNoMask<Device, T>::launch(context, params, tensor_in,\n                                                  output, propagate_nans_);\n      } else {\n        LOG(FATAL) << \"MaxPool currently only supports the following (layout, \"\n                      \"type) combinations: (NHWC, non-qint8), \"\n                      \"(NCHW, non-qint8) or (NCHW_VECT_C, qint8). The \"\n                      \"requested combination (\"\n                   << ToString(data_format_) << \", \"\n                   << DataTypeString(DataTypeToEnum<T>::v())\n                   << \") is not supported.\";\n      }\n    }\n#endif\n  }\n\n private:\n  std::vector<int32> ksize_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  std::vector<int64> explicit_paddings_;\n  TensorFormat data_format_;\n  bool propagate_nans_;\n};\n\ntemplate <typename T>\nclass MaxPoolingNoMaskV2Op<GPUDevice, T> : public OpKernel {\n public:\n  typedef GPUDevice Device;\n  explicit MaxPoolingNoMaskV2Op(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string data_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"data_format\", &data_format));\n    OP_REQUIRES(context, FormatFromString(data_format, &data_format_),\n                errors::InvalidArgument(\"Invalid data format\"));\n    if (context->num_inputs() == 1) {\n      OP_REQUIRES_OK(context, context->GetAttr(\"ksize\", &ksize_));\n      OP_REQUIRES(context, ksize_.size() == 4,\n                  errors::InvalidArgument(\"Sliding window ksize field must \"\n                                          \"specify 4 dimensions\"));\n      OP_REQUIRES_OK(context, context->GetAttr(\"strides\", &stride_));\n      OP_REQUIRES(context, stride_.size() == 4,\n                  errors::InvalidArgument(\"Sliding window stride field must \"\n                                          \"specify 4 dimensions\"));\n      const int32_t ksize_n = GetTensorDim(ksize_, data_format_, 'N');\n      const int32_t stride_n = GetTensorDim(stride_, data_format_, 'N');\n      OP_REQUIRES(context, ksize_n == 1 && stride_n == 1,\n                  errors::Unimplemented(\n                      \"Pooling is not yet supported on the batch dimension.\"));\n    }\n    OP_REQUIRES_OK(context, context->GetAttr(\"padding\", &padding_));\n    TF_CHECK_OK(ReadBoolFromEnvVar(\"TF_ENABLE_MAXPOOL_NANPROP\", false,\n                                   &propagate_nans_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n\n    std::vector<int32> ksize = ksize_;\n    std::vector<int32> stride = stride_;\n\n    if (context->num_inputs() != 1) {\n      const Tensor& tensor_ksize = context->input(1);\n      auto value_ksize = tensor_ksize.flat<int32>();\n      ksize.resize(tensor_ksize.shape().num_elements());\n      std::copy_n(&value_ksize(0), ksize.size(), ksize.begin());\n\n      const Tensor& tensor_stride = context->input(2);\n      auto value_stride = tensor_stride.flat<int32>();\n      stride.resize(tensor_stride.shape().num_elements());\n      std::copy_n(&value_stride(0), stride.size(), stride.begin());\n    }\n    OP_REQUIRES(context, ksize.size() == 4,\n                errors::InvalidArgument(\"Sliding window ksize field must \"\n                                        \"specify 4 dimensions\"));\n    OP_REQUIRES(context, stride.size() == 4,\n                errors::InvalidArgument(\"Sliding window stride field must \"\n                                        \"specify 4 dimensions\"));\n    const int32_t ksize_n = GetTensorDim(ksize, data_format_, 'N');\n    const int32_t stride_n = GetTensorDim(stride, data_format_, 'N');\n    OP_REQUIRES(context, ksize_n == 1 && stride_n == 1,\n                errors::Unimplemented(\n                    \"Pooling is not yet supported on the batch dimension.\"));\n\n    PoolParameters params{context,\n                          ksize,\n                          stride,\n                          padding_,\n                          /*explicit_paddings=*/{},\n                          data_format_,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n\n    TensorShape out_shape =\n        ShapeFromFormat(data_format_, params.tensor_in_batch, params.out_height,\n                        params.out_width, params.depth);\n    if (data_format_ == FORMAT_NCHW) {\n      DnnPoolingOp<T>::Compute(context, se::dnn::PoolingMode::kMaximum, ksize,\n                               stride, padding_, explicit_paddings_,\n                               data_format_, tensor_in, out_shape,\n                               propagate_nans_);\n    } else {\n      CHECK(data_format_ == FORMAT_NHWC)\n          << \"MaxPool only supports NCHW or NHWC format\";\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));\n      LaunchMaxPoolingNoMask<Device, T>::launch(context, params, tensor_in,\n                                                output, propagate_nans_);\n    }\n  }\n\n private:\n  std::vector<int32> ksize_;\n  std::vector<int32> stride_;\n  Padding padding_;\n  std::vector<int64> explicit_paddings_;\n  TensorFormat data_format_;\n  bool propagate_nans_;\n};\n\ntemplate <typename T>\nstruct LaunchMaxPoolingNoMask<Eigen::GpuDevice, T> {\n  static void launch(OpKernelContext* context, const PoolParameters& params,\n                     const Tensor& input, Tensor* output, bool propagate_nans) {\n    bool status = functor::MaxPoolForwardWithOptionalArgmax<T>()(\n        input.flat<T>().data(), params.tensor_in_batch, params.tensor_in_rows,\n        params.tensor_in_cols, params.depth, params.out_height,\n        params.out_width, params.window_rows, params.window_cols,\n        params.row_stride, params.col_stride, params.pad_top, params.pad_left,\n        output->flat<T>().data(), nullptr, context->eigen_gpu_device(),\n        propagate_nans, false);\n    if (!status) {\n      context->SetStatus(\n          errors::Internal(\"Failed launching MaxPoolForwardNoMask\"));\n    }\n  }\n};\n\ntemplate <typename T>\nstruct LaunchMaxPoolingWithArgmax<Eigen::GpuDevice, T, int64> {\n  static void launch(OpKernelContext* context, const PoolParameters& params,\n                     const Tensor& input, Tensor* output, Tensor* argmax,\n                     bool propagate_nans, bool include_batch_in_index) {\n    bool status = functor::MaxPoolForwardWithOptionalArgmax<T>()(\n        input.flat<T>().data(), params.tensor_in_batch, params.tensor_in_rows,\n        params.tensor_in_cols, params.depth, params.out_height,\n        params.out_width, params.window_rows, params.window_cols,\n        params.row_stride, params.col_stride, params.pad_top, params.pad_left,\n        output->flat<T>().data(),\n        reinterpret_cast<int64*>(argmax->flat<int64>().data()),\n        context->eigen_gpu_device(), propagate_nans, include_batch_in_index);\n    if (!status) {\n      context->SetStatus(\n          errors::Internal(\"Failed launching MaxPoolForwardWithArgmax\"));\n    }\n  }\n};\n\ntemplate <typename T>\nstruct LaunchMaxPoolingGradWithArgmax<Eigen::GpuDevice, T> {\n  static void launch(OpKernelContext* context, const PoolParameters& params,\n                     const Tensor& grad_in, const Tensor& argmax,\n                     Tensor* grad_out, const bool include_batch_in_index) {\n    const int input_size = params.tensor_in_batch * params.tensor_in_rows *\n                           params.tensor_in_cols * params.depth;\n    const int output_size = params.tensor_in_batch * params.out_height *\n                            params.out_width * params.depth;\n    const int top_offset = params.out_height * params.out_width * params.depth;\n    const int bottom_offset =\n        params.tensor_in_rows * params.tensor_in_cols * params.depth;\n    bool status = functor::MaxPoolBackwardWithArgmax<T>()(\n        output_size, input_size, grad_in.flat<T>().data(),\n        reinterpret_cast<const int64*>(argmax.flat<int64>().data()), top_offset,\n        bottom_offset, grad_out->flat<T>().data(), context->eigen_gpu_device(),\n        include_batch_in_index);\n    if (!status) {\n      context->SetStatus(\n          errors::Internal(\"Failed launching MaxPoolBackwardWithArgmax\"));\n    }\n  }\n};\n\ntemplate <typename T>\nstruct LaunchMaxPoolingGradGradWithArgmax<Eigen::GpuDevice, T> {\n  static void launch(OpKernelContext* context, const PoolParameters& params,\n                     const Tensor& grad_in, const Tensor& argmax,\n                     Tensor* grad_out, const bool include_batch_in_index) {\n    const int input_size = params.tensor_in_batch * params.tensor_in_rows *\n                           params.tensor_in_cols * params.depth;\n    const int output_size = params.tensor_in_batch * params.out_height *\n                            params.out_width * params.depth;\n    const int top_offset =\n        params.tensor_in_rows * params.tensor_in_cols * params.depth;\n    const int bottom_offset =\n        params.out_width * params.out_height * params.depth;\n    bool status = functor::MaxPoolGradBackwardWithArgmax<T>()(\n        output_size, input_size, grad_in.flat<T>().data(),\n        reinterpret_cast<const int64*>(argmax.flat<int64>().data()), top_offset,\n        bottom_offset, grad_out->flat<T>().data(), context->eigen_gpu_device(),\n        include_batch_in_index);\n    if (!status) {\n      context->SetStatus(\n          errors::Internal(\"Failed launching MaxPoolGradBackwardWithArgmax\"));\n    }\n  }\n};\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n#define REGISTER_MAX_POOL_KERNELS(D, T)                                  \\\n  REGISTER_KERNEL_BUILDER(                                               \\\n      Name(\"MaxPoolGrad\").Device(DEVICE_##D).TypeConstraint<T>(\"T\"),     \\\n      MaxPoolingGradOp<D##Device, T>);                                   \\\n  REGISTER_KERNEL_BUILDER(                                               \\\n      Name(\"MaxPoolGradGrad\").Device(DEVICE_##D).TypeConstraint<T>(\"T\"), \\\n      MaxPoolingGradGradOp<D##Device, T>);                               \\\n  REGISTER_KERNEL_BUILDER(Name(\"MaxPoolGradV2\")                          \\\n                              .Device(DEVICE_##D)                        \\\n                              .HostMemory(\"ksize\")                       \\\n                              .HostMemory(\"strides\")                     \\\n                              .TypeConstraint<T>(\"T\"),                   \\\n                          MaxPoolingGradOp<D##Device, T>);               \\\n  REGISTER_KERNEL_BUILDER(Name(\"MaxPoolGradGradV2\")                      \\\n                              .Device(DEVICE_##D)                        \\\n                              .HostMemory(\"ksize\")                       \\\n                              .HostMemory(\"strides\")                     \\\n                              .TypeConstraint<T>(\"T\"),                   \\\n                          MaxPoolingGradGradOp<D##Device, T>)            \\\n  REGISTER_KERNEL_BUILDER(Name(\"MaxPoolWithArgmax\")                      \\\n                              .Device(DEVICE_##D)                        \\\n                              .TypeConstraint<int64>(\"Targmax\")          \\\n                              .TypeConstraint<T>(\"T\"),                   \\\n                          MaxPoolingWithArgmaxOp<D##Device, T, int64>);  \\\n  REGISTER_KERNEL_BUILDER(Name(\"MaxPoolGradWithArgmax\")                  \\\n                              .Device(DEVICE_##D)                        \\\n                              .TypeConstraint<T>(\"T\")                    \\\n                              .TypeConstraint<int64>(\"Targmax\"),         \\\n                          MaxPoolingGradWithArgmaxOp<D##Device, T>);\n\n// Below kernels implemented only for CPU device.\n#define REGISTER_CPU_ONLY_POOL_KERNELS(T)                          \\\n  REGISTER_KERNEL_BUILDER(                                         \\\n      Name(\"MaxPool\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"),   \\\n      MaxPoolingOp<CPUDevice, T>);                                 \\\n  REGISTER_KERNEL_BUILDER(                                         \\\n      Name(\"MaxPoolV2\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      MaxPoolingV2Op<CPUDevice, T>);                               \\\n  REGISTER_KERNEL_BUILDER(Name(\"MaxPoolWithArgmax\")                \\\n                              .Device(DEVICE_CPU)                  \\\n                              .TypeConstraint<int32>(\"Targmax\")    \\\n                              .TypeConstraint<T>(\"T\"),             \\\n                          MaxPoolingWithArgmaxOp<CPUDevice, T, int32>);\nTF_CALL_REAL_NUMBER_TYPES(REGISTER_CPU_ONLY_POOL_KERNELS);\n#undef REGISTER_CPU_ONLY_POOL_KERNELS\n\n#define REGISTER_CPU_MAX_POOL_KERNELS(T) REGISTER_MAX_POOL_KERNELS(CPU, T);\nTF_CALL_REAL_NUMBER_TYPES(REGISTER_CPU_MAX_POOL_KERNELS);\n#undef REGISTER_CPU_KERNELS\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n// Forward declarations for the functor specializations for GPU.\nnamespace functor {\n#define DECLARE_GPU_SPEC(T)                                            \\\n  template <>                                                          \\\n  void SpatialMaxPooling<Eigen::GpuDevice, T>::operator()(             \\\n      const Eigen::GpuDevice& d, typename TTypes<T, 4>::Tensor output, \\\n      typename TTypes<T, 4>::ConstTensor input, int window_rows,       \\\n      int window_cols, int row_stride, int col_stride,                 \\\n      const Eigen::PaddingType& padding);                              \\\n  extern template struct SpatialMaxPooling<Eigen::GpuDevice, T>;\n\nTF_CALL_GPU_NUMBER_TYPES(DECLARE_GPU_SPEC);\n#undef DECLARE_GPU_SPEC\n}  // namespace functor\n\n#define REGISTER_GPU_MAX_POOL_KERNELS(T) REGISTER_MAX_POOL_KERNELS(GPU, T)\nTF_CALL_GPU_NUMBER_TYPES(REGISTER_GPU_MAX_POOL_KERNELS);\n#undef REGISTER_GPU_MAX_POOL_KERNELS\n\n// Below kernels currently implemented only for GPU device.\n// Note(jiayq): Currently, the Caffe custom implementation is faster than the\n// default Eigen implementation so we are using the custom kernel as the\n// default. However, you can explicitly invoke the eigen version using\n// kernel_label_map.\n#define REGISTER_GPU_ONLY_POOL_KERNELS(T)                        \\\n  REGISTER_KERNEL_BUILDER(Name(\"MaxPool\")                        \\\n                              .Device(DEVICE_GPU)                \\\n                              .TypeConstraint<T>(\"T\")            \\\n                              .Label(\"eigen_tensor\"),            \\\n                          MaxPoolingOp<GPUDevice, T>);           \\\n  REGISTER_KERNEL_BUILDER(Name(\"MaxPoolV2\")                      \\\n                              .Device(DEVICE_GPU)                \\\n                              .HostMemory(\"ksize\")               \\\n                              .HostMemory(\"strides\")             \\\n                              .TypeConstraint<T>(\"T\")            \\\n                              .Label(\"eigen_tensor\"),            \\\n                          MaxPoolingV2Op<GPUDevice, T>);         \\\n  REGISTER_KERNEL_BUILDER(                                       \\\n      Name(\"MaxPool\").Device(DEVICE_GPU).TypeConstraint<T>(\"T\"), \\\n      MaxPoolingNoMaskOp<GPUDevice, T>);                         \\\n  REGISTER_KERNEL_BUILDER(Name(\"MaxPoolV2\")                      \\\n                              .Device(DEVICE_GPU)                \\\n                              .HostMemory(\"ksize\")               \\\n                              .HostMemory(\"strides\")             \\\n                              .TypeConstraint<T>(\"T\"),           \\\n                          MaxPoolingNoMaskV2Op<GPUDevice, T>);   \\\n  REGISTER_KERNEL_BUILDER(Name(\"MaxPoolGradGradWithArgmax\")      \\\n                              .Device(DEVICE_GPU)                \\\n                              .TypeConstraint<T>(\"T\")            \\\n                              .TypeConstraint<int64>(\"Targmax\"), \\\n                          MaxPoolingGradGradWithArgmaxOp<GPUDevice, T>);\nTF_CALL_GPU_NUMBER_TYPES(REGISTER_GPU_ONLY_POOL_KERNELS);\n\n// TODO(b/65847473): Re-enable once the underlying build error is fixed.\n#if !defined(PLATFORM_WINDOWS)\nREGISTER_KERNEL_BUILDER(\n    Name(\"MaxPool\").Device(DEVICE_GPU).TypeConstraint<qint8>(\"T\"),\n    MaxPoolingNoMaskOp<GPUDevice, qint8>);\n\nREGISTER_KERNEL_BUILDER(Name(\"MaxPoolV2\")\n                            .Device(DEVICE_GPU)\n                            .HostMemory(\"ksize\")\n                            .HostMemory(\"strides\")\n                            .TypeConstraint<qint8>(\"T\"),\n                        MaxPoolingV2Op<GPUDevice, qint8>);\n\nREGISTER_KERNEL_BUILDER(Name(\"MaxPoolV2\")\n                            .Device(DEVICE_GPU)\n                            .HostMemory(\"ksize\")\n                            .HostMemory(\"strides\")\n                            .TypeConstraint<qint8>(\"T\")\n                            .Label(\"eigen_tensor\"),\n                        MaxPoolingV2Op<GPUDevice, qint8>);\n#endif  // !defined(PLATFORM_WINDOWS)\n\n#undef REGISTER_GPU_ONLY_POOL_KERNELS\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n#undef REGISTER_MAX_POOL_KERNELS\n\n}  // namespace tensorflow\n", "/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/kernels/pooling_ops_common.h\"\n\n#include <vector>\n\n#include \"tensorflow/core/common_runtime/device.h\"\n#include \"tensorflow/core/framework/bounds_check.h\"\n#include \"tensorflow/core/framework/kernel_shape_util.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n\n#if GOOGLE_CUDA\n#include \"third_party/gpus/cudnn/cudnn.h\"\n#endif  // GOOGLE_CUDA\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#include \"tensorflow/core/kernels/conv_2d.h\"\n#include \"tensorflow/core/kernels/gpu_utils.h\"\n#if TENSORFLOW_USE_ROCM\n#include \"tensorflow/core/kernels/conv_ops_gpu.h\"\n#endif\n#include \"tensorflow/core/kernels/pooling_ops_common_gpu.h\"\n#include \"tensorflow/core/platform/stream_executor.h\"\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\nnamespace tensorflow {\n\nnamespace {\n\ntemplate <typename T>\nstruct RawType {\n  using type = T;\n};\n\ntemplate <>\nstruct RawType<qint8> {\n  using type = int8;\n};\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\ntemplate <typename T>\nstruct PadInputWithNegativeInf {\n  Status operator()(const GPUDevice& d,\n                    typename TTypes<T, 4, int>::ConstTensor in,\n                    int input_pad_top, int input_pad_bottom, int input_pad_left,\n                    int input_pad_right, typename TTypes<T, 4, int>::Tensor out,\n                    TensorFormat format) {\n    T padding_value = -std::numeric_limits<T>::infinity();\n    functor::PadInput<GPUDevice, T, int, 4>()(\n        d, in, {{input_pad_top, input_pad_left}},\n        {{input_pad_bottom, input_pad_right}}, out, format, padding_value);\n    return Status::OK();\n  }\n};\n\ntemplate <>\nstruct PadInputWithNegativeInf<qint8> {\n  Status operator()(const GPUDevice& d,\n                    typename TTypes<qint8, 4, int>::ConstTensor in,\n                    int input_pad_top, int input_pad_bottom, int input_pad_left,\n                    int input_pad_right,\n                    typename TTypes<qint8, 4, int>::Tensor out,\n                    TensorFormat format) {\n    return errors::InvalidArgument(\n        \"Explicit padding not yet supported with qint8\");\n  }\n};\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n}  // namespace\n\nStatus CheckPaddingSize(int64_t window_rows, int64_t window_cols,\n                        int64_t pad_top, int64_t pad_bottom, int64_t pad_left,\n                        int64_t pad_right) {\n  if (!FastBoundsCheck(pad_top, window_rows)) {\n    return errors::InvalidArgument(\"Top padding \", pad_top,\n                                   \" needs to be smaller than the \"\n                                   \"window size \",\n                                   window_rows);\n  }\n  if (!FastBoundsCheck(pad_bottom, window_rows)) {\n    return errors::InvalidArgument(\"Bottom padding \", pad_bottom,\n                                   \" needs to be smaller than the \"\n                                   \"window size \",\n                                   window_rows);\n  }\n  if (!FastBoundsCheck(pad_left, window_cols)) {\n    return errors::InvalidArgument(\"Left padding \", pad_left,\n                                   \" needs to be smaller than the \"\n                                   \"window size \",\n                                   window_cols);\n  }\n  if (!FastBoundsCheck(pad_right, window_cols)) {\n    return errors::InvalidArgument(\"Right padding \", pad_right,\n                                   \" needs to be smaller than the \"\n                                   \"window size \",\n                                   window_cols);\n  }\n  return Status::OK();\n}\n\nPoolParameters::PoolParameters(OpKernelContext* context,\n                               const std::vector<int32>& ksize,\n                               const std::vector<int32>& stride,\n                               Padding padding,\n                               std::vector<int64> explicit_paddings,\n                               TensorFormat data_format,\n                               const TensorShape& tensor_in_shape) {\n  // For maxpooling, tensor_in should have 2 spatial dimensions.\n  // Note: the total number of dimensions could be 4 for NHWC, NCHW,\n  // or 5 for NCHW_VECT_C.\n  OP_REQUIRES(context,\n              GetTensorSpatialDims(tensor_in_shape.dims(), data_format) == 2,\n              errors::InvalidArgument(\n                  \"tensor_in_shape must have 2 spatial dimensions. \",\n                  tensor_in_shape.dims(), \" \", data_format));\n\n  this->data_format = data_format;\n  depth = GetTensorDim(tensor_in_shape, data_format, 'C') *\n          (data_format == FORMAT_NCHW_VECT_C ? 4 : 1);\n  tensor_in_cols = GetTensorDim(tensor_in_shape, data_format, 'W');\n  tensor_in_rows = GetTensorDim(tensor_in_shape, data_format, 'H');\n  tensor_in_batch = GetTensorDim(tensor_in_shape, data_format, 'N');\n  window_rows = GetTensorDim(ksize, data_format, 'H');\n  window_cols = GetTensorDim(ksize, data_format, 'W');\n  depth_window = GetTensorDim(ksize, data_format, 'C');\n  row_stride = GetTensorDim(stride, data_format, 'H');\n  col_stride = GetTensorDim(stride, data_format, 'W');\n  depth_stride = GetTensorDim(stride, data_format, 'C');\n\n  // We only support 2D pooling across width/height and depthwise\n  // pooling, not a combination.\n  OP_REQUIRES(context,\n              (depth_window == 1 || (window_rows == 1 && window_cols == 1)),\n              errors::Unimplemented(\n                  \"MaxPooling supports exactly one of pooling across depth \"\n                  \"or pooling across width/height.\"));\n  if (padding == Padding::EXPLICIT) {\n    OP_REQUIRES_OK(context, CheckValidPadding(padding, explicit_paddings,\n                                              /*num_dims=*/4, data_format));\n    GetExplicitPaddingForDim(explicit_paddings, data_format, 'H', &pad_top,\n                             &pad_bottom);\n    GetExplicitPaddingForDim(explicit_paddings, data_format, 'W', &pad_left,\n                             &pad_right);\n    OP_REQUIRES_OK(context, CheckPaddingSize(window_rows, window_cols, pad_top,\n                                             pad_bottom, pad_left, pad_right));\n  }\n\n  if (depth_window == 1) {\n    OP_REQUIRES_OK(context, GetWindowedOutputSizeVerbose(\n                                tensor_in_rows, window_rows, row_stride,\n                                padding, &out_height, &pad_top, &pad_bottom));\n    OP_REQUIRES_OK(context, GetWindowedOutputSizeVerbose(\n                                tensor_in_cols, window_cols, col_stride,\n                                padding, &out_width, &pad_left, &pad_right));\n    pad_depth = 0;\n    out_depth = depth;\n  } else {\n    OP_REQUIRES(context, depth_window > 0,\n                errors::InvalidArgument(\"depth_window must not be 0\"));\n    // Our current version of depthwise max pooling does not support\n    // any padding, and expects the depth_window to equal the\n    // depth_stride (no overlapping).\n    OP_REQUIRES(\n        context, depth % depth_window == 0,\n        errors::Unimplemented(\"Depthwise max pooling requires the depth \"\n                              \"window to evenly divide the input depth\"));\n    OP_REQUIRES(\n        context, depth_stride == depth_window,\n        errors::Unimplemented(\"Depthwise max pooling requires the depth \"\n                              \"window to equal the depth stride\"));\n\n    // The current version of depthwise max is only implemented on CPU.\n    OP_REQUIRES(context,\n                (DeviceType(static_cast<Device*>(context->device())\n                                ->attributes()\n                                .device_type()) == DeviceType(DEVICE_CPU)),\n                errors::Unimplemented(\"Depthwise max pooling is currently \"\n                                      \"only implemented for CPU devices.\"));\n\n    pad_depth = 0;\n    out_depth = depth / depth_window;\n  }\n}\n\nTensorShape PoolParameters::forward_output_shape() {\n  if (depth_window == 1) {\n    // Spatial pooling\n    return ShapeFromFormat(data_format, tensor_in_batch, out_height, out_width,\n                           depth);\n  } else {\n    // Depthwise pooling\n    return TensorShape(\n        {tensor_in_batch, tensor_in_rows, tensor_in_cols, out_depth});\n  }\n}\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\ntemplate <typename T>\nvoid DnnPoolingOp<T>::Compute(OpKernelContext* context,\n                              se::dnn::PoolingMode pooling_mode,\n                              const std::vector<int32>& size,\n                              const std::vector<int32>& stride, Padding padding,\n                              std::vector<int64> explicit_paddings,\n                              TensorFormat data_format, const Tensor& tensor_in,\n                              const TensorShape& tensor_out_shape,\n                              bool propagate_nans) {\n  Tensor* tensor_out = nullptr;\n  OP_REQUIRES_OK(context,\n                 context->allocate_output(0, tensor_out_shape, &tensor_out));\n  if (tensor_in.shape().num_elements() == 0) {\n    return;\n  }\n\n  PoolParameters params{\n      context,           size,        stride,           padding,\n      explicit_paddings, data_format, tensor_in.shape()};\n  if (!context->status().ok()) {\n    return;\n  }\n\n  int batch_size = params.tensor_in_batch;\n  int depth = params.depth;\n  int tensor_in_cols = params.tensor_in_cols;\n  int tensor_in_rows = params.tensor_in_rows;\n\n#if CUDNN_VERSION < 7300\n  /// Earlier versions do not support NHWC format, so we need to convert it\n  /// to NCHW before calling cudnn. We need to get rid of this once it is done\n  Tensor transformed_input;\n  if (data_format == FORMAT_NHWC) {\n    OP_REQUIRES_OK(context, context->allocate_temp(\n                                DataTypeToEnum<T>::value,\n                                ShapeFromFormat(FORMAT_NCHW, tensor_in.shape(),\n                                                data_format),\n                                &transformed_input));\n    functor::NHWCToNCHW<GPUDevice, T, 4>()(context->eigen_device<Device>(),\n                                           tensor_in.tensor<T, 4>(),\n                                           transformed_input.tensor<T, 4>());\n  } else {\n    transformed_input = tensor_in;\n  }\n  Tensor transformed_output;\n  if (data_format == FORMAT_NHWC) {\n    OP_REQUIRES_OK(context, context->allocate_temp(\n                                DataTypeToEnum<T>::value,\n                                ShapeFromFormat(FORMAT_NCHW, tensor_out_shape,\n                                                data_format),\n                                &transformed_output));\n  } else {\n    transformed_output = *tensor_out;\n  }\n  se::dnn::DataLayout data_layout = se::dnn::DataLayout::kBatchDepthYX;\n#else\n  Tensor transformed_input = tensor_in;\n  auto& transformed_output = *tensor_out;\n  se::dnn::DataLayout data_layout;\n  switch (data_format) {\n    case FORMAT_NHWC:\n      data_layout = se::dnn::DataLayout::kBatchYXDepth;\n      break;\n    case FORMAT_NCHW:\n      data_layout = se::dnn::DataLayout::kBatchDepthYX;\n      break;\n    case FORMAT_NCHW_VECT_C:\n      // NCHW_VECT_C is not supported by cudnnPoolingForward(), but can be\n      // emulated via NHWC.\n      data_layout = se::dnn::DataLayout::kBatchYXDepth;\n      batch_size *= depth / 4;\n      depth = 4;\n      break;\n    default:\n      OP_REQUIRES(context, false,\n                  errors::InvalidArgument(\"Unsupported format: \",\n                                          ToString(data_format)));\n  }\n#endif\n\n  int64_t vertical_padding = params.pad_top;\n  int64_t horizontal_padding = params.pad_left;\n\n  if (padding == EXPLICIT && (params.pad_top != params.pad_bottom ||\n                              params.pad_left != params.pad_right)) {\n    // cuDNN only supports padding the same amount on the left and right sides,\n    // and on the top and bottom sides. So we manually create a new padded\n    // input tensor such that we can pass it to cuDNN.\n    const int64_t common_padding_rows =\n        std::min(params.pad_top, params.pad_bottom);\n    const int64_t common_padding_cols =\n        std::min(params.pad_left, params.pad_right);\n\n    Tensor padded_input;\n    const int64_t padding_rows_diff =\n        std::abs(params.pad_top - params.pad_bottom);\n    const int64_t padding_cols_diff =\n        std::abs(params.pad_left - params.pad_right);\n\n    const int64_t new_in_rows = tensor_in_rows + padding_rows_diff;\n    const int64_t new_in_cols = tensor_in_cols + padding_cols_diff;\n\n    OP_REQUIRES_OK(\n        context,\n        context->allocate_temp(DataTypeToEnum<T>::value,\n                               ShapeFromFormat(data_format, batch_size,\n                                               new_in_rows, new_in_cols, depth),\n                               &padded_input));\n    const int64_t input_pad_top = params.pad_top - common_padding_rows;\n    const int64_t input_pad_bottom = params.pad_bottom - common_padding_rows;\n    const int64_t input_pad_left = params.pad_left - common_padding_cols;\n    const int64_t input_pad_right = params.pad_right - common_padding_cols;\n\n    bool in_bounds =\n        FastBoundsCheck(input_pad_top, std::numeric_limits<int>::max()) &&\n        FastBoundsCheck(input_pad_bottom, std::numeric_limits<int>::max()) &&\n        FastBoundsCheck(input_pad_left, std::numeric_limits<int>::max()) &&\n        FastBoundsCheck(input_pad_right, std::numeric_limits<int>::max());\n    if (!in_bounds) {\n      context->SetStatus(errors::InvalidArgument(\"Padding is too large.\"));\n      return;\n    }\n\n    // We need to call the const version of transformed_input.tensor()\n    const Tensor& const_transformed_input = transformed_input;\n    OP_REQUIRES_OK(\n        context,\n        PadInputWithNegativeInf<T>()(\n            context->eigen_device<GPUDevice>(),\n            To32Bit(const_transformed_input.tensor<T, 4>()),\n            static_cast<int>(input_pad_top), static_cast<int>(input_pad_bottom),\n            static_cast<int>(input_pad_left), static_cast<int>(input_pad_right),\n            To32Bit(padded_input.tensor<T, 4>()), data_format));\n    transformed_input = padded_input;\n    vertical_padding = common_padding_rows;\n    horizontal_padding = common_padding_cols;\n    tensor_in_rows = new_in_rows;\n    tensor_in_cols = new_in_cols;\n  }\n\n  se::dnn::PoolingDescriptor pooling_desc;\n  pooling_desc.set_pooling_mode(pooling_mode)\n      .set_window_height(params.window_rows)\n      .set_window_width(params.window_cols)\n      .set_vertical_stride(params.row_stride)\n      .set_horizontal_stride(params.col_stride)\n      .set_vertical_padding(vertical_padding)\n      .set_horizontal_padding(horizontal_padding)\n      .set_propagate_nans(propagate_nans);\n\n  se::dnn::BatchDescriptor input_desc;\n  input_desc.set_count(batch_size)\n      .set_height(tensor_in_rows)\n      .set_width(tensor_in_cols)\n      .set_feature_map_count(depth)\n      .set_layout(data_layout);\n\n  se::dnn::BatchDescriptor output_desc;\n  output_desc.set_count(batch_size)\n      .set_height(params.out_height)\n      .set_width(params.out_width)\n      .set_feature_map_count(depth)\n      .set_layout(data_layout);\n\n  auto input_data =\n      AsDeviceMemory(reinterpret_cast<const typename RawType<T>::type*>(\n                         transformed_input.template flat<T>().data()),\n                     transformed_input.template flat<T>().size());\n\n  auto output_data =\n      AsDeviceMemory(reinterpret_cast<const typename RawType<T>::type*>(\n                         transformed_output.template flat<T>().data()),\n                     transformed_output.template flat<T>().size());\n\n  auto* stream = context->op_device_context()->stream();\n  OP_REQUIRES(context, stream, errors::Internal(\"No GPU stream available.\"));\n\n#if TENSORFLOW_USE_ROCM\n  static int64 PoolingScratchSize = GetDnnWorkspaceLimit(\n      // default value is in bytes despite the name of the environment variable\n      \"TF_CUDNN_WORKSPACE_LIMIT_IN_MB\", 1LL << 32  // 4GB\n  );\n\n  DnnScratchAllocator scratch_allocator(PoolingScratchSize, context);\n  bool status =\n      stream\n          ->ThenPoolForward(pooling_desc, input_desc, input_data, output_desc,\n                            &output_data, &scratch_allocator)\n          .ok();\n#else\n  bool status = stream\n                    ->ThenPoolForward(pooling_desc, input_desc, input_data,\n                                      output_desc, &output_data)\n                    .ok();\n#endif\n  OP_REQUIRES(context, status,\n              errors::Internal(\"dnn PoolForward launch failed\"));\n#if CUDNN_VERSION < 7300\n  if (data_format == FORMAT_NHWC) {\n    /// Transform the output data from NCHW back to NHWC\n    auto toConstTensor = [](const Tensor& x) -> const Tensor { return x; };\n    using RT = typename RawType<T>::type;\n    functor::NCHWToNHWC<GPUDevice, RT, 4>()(\n        context->eigen_device<Device>(),\n        toConstTensor(transformed_output).template tensor<RT, 4>(),\n        tensor_out->tensor<RT, 4>());\n  }\n#endif\n}\n\n// Forward declarations of the functor specializations for GPU.\nnamespace functor {\n#define DECLARE_GPU_SPEC(T)                                             \\\n  template <>                                                           \\\n  void PadInput<GPUDevice, T, int, 4>::operator()(                      \\\n      const GPUDevice& d, typename TTypes<T, 4, int>::ConstTensor in,   \\\n      const std::array<int, 2>& padding_left,                           \\\n      const std::array<int, 2>& padding_right,                          \\\n      typename TTypes<T, 4, int>::Tensor out, TensorFormat data_format, \\\n      const T& padding_value);                                          \\\n  extern template struct PadInput<GPUDevice, T, int, 4>;\n\nDECLARE_GPU_SPEC(float);\nDECLARE_GPU_SPEC(Eigen::half);\nDECLARE_GPU_SPEC(double);\nDECLARE_GPU_SPEC(int32);\n}  // namespace functor\n\ntemplate <typename T>\nvoid DnnPoolingGradOp<T>::Compute(\n    OpKernelContext* context, se::dnn::PoolingMode pooling_mode,\n    const std::vector<int32>& size, const std::vector<int32>& stride,\n    Padding padding, std::vector<int64> explicit_paddings,\n    TensorFormat data_format, const Tensor* tensor_in, const Tensor* tensor_out,\n    const Tensor& out_backprop, const TensorShape& tensor_in_shape,\n    bool propagate_nans) {\n  CHECK((pooling_mode != se::dnn::PoolingMode::kMaximum) ||\n        (tensor_in && tensor_out))\n      << \"For MaxPoolGrad, both tensor_in and tensor_out needs to be \"\n         \"specified\";\n\n  Tensor* input_backprop = nullptr;\n  OP_REQUIRES_OK(context,\n                 context->allocate_output(0, tensor_in_shape, &input_backprop));\n  if (tensor_in_shape.num_elements() == 0) {\n    return;\n  }\n\n  PoolParameters params{context,           size,        stride,         padding,\n                        explicit_paddings, data_format, tensor_in_shape};\n  if (!context->status().ok()) {\n    return;\n  }\n\n  TensorFormat transformed_input_data_format = data_format;\n\n#if CUDNN_VERSION < 7300\n  /// For now, cudnn does not support NHWC format, so we need to convert it\n  /// to NCHW before calling cudnn. We need to get rid of this once it is done\n  Tensor transformed_input;\n  TensorShape transformed_input_shape;\n  if (data_format == FORMAT_NHWC || !tensor_in) {\n    transformed_input_shape =\n        ShapeFromFormat(FORMAT_NCHW, tensor_in_shape, data_format);\n    OP_REQUIRES_OK(context, context->allocate_temp(DataTypeToEnum<T>::value,\n                                                   transformed_input_shape,\n                                                   &transformed_input));\n  } else {\n    transformed_input = *tensor_in;\n  }\n  Tensor transformed_output;\n  TensorShape transformed_output_shape;\n  if (data_format == FORMAT_NHWC || !tensor_out) {\n    transformed_output_shape =\n        ShapeFromFormat(FORMAT_NCHW, out_backprop.shape(), data_format);\n    OP_REQUIRES_OK(context, context->allocate_temp(DataTypeToEnum<T>::value,\n                                                   transformed_output_shape,\n                                                   &transformed_output));\n  } else {\n    transformed_output = *tensor_out;\n  }\n  Tensor transformed_input_backprop;\n  if (data_format == FORMAT_NHWC) {\n    OP_REQUIRES_OK(context,\n                   context->allocate_temp(DataTypeToEnum<T>::value,\n                                          transformed_input_shape,\n                                          &transformed_input_backprop));\n  } else {\n    transformed_input_backprop = *input_backprop;\n  }\n  Tensor transformed_output_backprop;\n  if (data_format == FORMAT_NHWC) {\n    OP_REQUIRES_OK(context,\n                   context->allocate_temp(DataTypeToEnum<T>::value,\n                                          transformed_output_shape,\n                                          &transformed_output_backprop));\n  } else {\n    transformed_output_backprop = out_backprop;\n  }\n\n  if (data_format == FORMAT_NHWC) {\n    /// Convert the data from NHWC to NCHW if necessary.\n    if (tensor_in) {\n      // For AvgPoolGrad, the original input tensor is not necessary. However,\n      // cudnn still requires them to run, although they do not affect the\n      // results.\n      functor::NHWCToNCHW<GPUDevice, T, 4>()(context->eigen_device<Device>(),\n                                             tensor_in->tensor<T, 4>(),\n                                             transformed_input.tensor<T, 4>());\n      transformed_input_data_format = FORMAT_NCHW;\n    }\n    if (tensor_out) {\n      // For AvgPoolGrad, the original output tensor is not necessary. However,\n      // cudnn still requires them to run, although they do not affect the\n      // results.\n      functor::NHWCToNCHW<GPUDevice, T, 4>()(context->eigen_device<Device>(),\n                                             tensor_out->tensor<T, 4>(),\n                                             transformed_output.tensor<T, 4>());\n    }\n    functor::NHWCToNCHW<GPUDevice, T, 4>()(\n        context->eigen_device<Device>(), out_backprop.tensor<T, 4>(),\n        transformed_output_backprop.tensor<T, 4>());\n  }\n  se::dnn::DataLayout data_layout = se::dnn::DataLayout::kBatchDepthYX;\n#else\n  Tensor transformed_input;\n  if (!tensor_in) {\n    OP_REQUIRES_OK(context,\n                   context->allocate_temp(DataTypeToEnum<T>::value,\n                                          tensor_in_shape, &transformed_input));\n  } else {\n    transformed_input = *tensor_in;\n  }\n  Tensor transformed_output;\n  if (!tensor_out) {\n    OP_REQUIRES_OK(context, context->allocate_temp(DataTypeToEnum<T>::value,\n                                                   out_backprop.shape(),\n                                                   &transformed_output));\n  } else {\n    transformed_output = *tensor_out;\n  }\n  Tensor transformed_input_backprop = *input_backprop;\n  Tensor transformed_output_backprop = out_backprop;\n  se::dnn::DataLayout data_layout;\n  switch (data_format) {\n    case FORMAT_NHWC:\n      data_layout = se::dnn::DataLayout::kBatchYXDepth;\n      break;\n    case FORMAT_NCHW:\n      data_layout = se::dnn::DataLayout::kBatchDepthYX;\n      break;\n    default:\n      OP_REQUIRES(context, false,\n                  errors::InvalidArgument(\"Unsupported format: \",\n                                          ToString(data_format)));\n  }\n#endif  // CUDNN_VERSION < 7300\n\n  int64_t vertical_padding = params.pad_top;\n  int64_t horizontal_padding = params.pad_left;\n\n  int batch_size = params.tensor_in_batch;\n  int depth = params.depth;\n  int tensor_in_cols = params.tensor_in_cols;\n  int tensor_in_rows = params.tensor_in_rows;\n\n  int64_t input_pad_top = 0;\n  int64_t input_pad_bottom = 0;\n  int64_t input_pad_left = 0;\n  int64_t input_pad_right = 0;\n\n  Tensor transformed_and_padded_input_backprop;\n\n  if (padding == EXPLICIT && (params.pad_top != params.pad_bottom ||\n                              params.pad_left != params.pad_right)) {\n    // Pad the input in the same way we did during the forward pass, so that\n    // cuDNN or MIOpen receives the same input during the backward pass function\n    // as it did during the forward pass function.\n    const int64_t common_padding_rows =\n        std::min(params.pad_top, params.pad_bottom);\n    const int64_t common_padding_cols =\n        std::min(params.pad_left, params.pad_right);\n\n    Tensor padded_input;\n    const int64_t padding_rows_diff =\n        std::abs(params.pad_top - params.pad_bottom);\n    const int64_t padding_cols_diff =\n        std::abs(params.pad_left - params.pad_right);\n\n    const int64_t new_in_rows = tensor_in_rows + padding_rows_diff;\n    const int64_t new_in_cols = tensor_in_cols + padding_cols_diff;\n\n    VLOG(2) << \"Create new tensor: \"\n            << \" original rows=\" << tensor_in_rows\n            << \" original cols=\" << tensor_in_cols\n            << \" padding_rows=\" << new_in_rows\n            << \" padding_cols=\" << new_in_cols << \" depth= \" << depth\n            << \" batch_size=\" << batch_size << \" kernel_rows\"\n            << params.window_rows << \" kernel_col\" << params.window_cols\n            << \" stride_rows\" << params.row_stride;\n\n    OP_REQUIRES_OK(\n        context, context->allocate_temp(\n                     DataTypeToEnum<T>::value,\n                     ShapeFromFormat(transformed_input_data_format, batch_size,\n                                     new_in_rows, new_in_cols, depth),\n                     &padded_input));\n\n    OP_REQUIRES_OK(\n        context, context->allocate_temp(\n                     DataTypeToEnum<T>::value,\n                     ShapeFromFormat(transformed_input_data_format, batch_size,\n                                     new_in_rows, new_in_cols, depth),\n                     &transformed_and_padded_input_backprop));\n\n    input_pad_top = params.pad_top - common_padding_rows;\n    input_pad_bottom = params.pad_bottom - common_padding_rows;\n    input_pad_left = params.pad_left - common_padding_cols;\n    input_pad_right = params.pad_right - common_padding_cols;\n\n    bool in_bounds =\n        FastBoundsCheck(input_pad_top, std::numeric_limits<int>::max()) &&\n        FastBoundsCheck(input_pad_bottom, std::numeric_limits<int>::max()) &&\n        FastBoundsCheck(input_pad_left, std::numeric_limits<int>::max()) &&\n        FastBoundsCheck(input_pad_right, std::numeric_limits<int>::max());\n    if (!in_bounds) {\n      context->SetStatus(errors::InvalidArgument(\"Padding is too large.\"));\n      return;\n    }\n\n    // PadInputWithNegativeInf functor requires input to be a const.\n    const Tensor& const_transformed_input = transformed_input;\n    OP_REQUIRES_OK(\n        context,\n        PadInputWithNegativeInf<T>()(\n            context->eigen_device<GPUDevice>(),\n            To32Bit(const_transformed_input.tensor<T, 4>()),\n            static_cast<int>(input_pad_top), static_cast<int>(input_pad_bottom),\n            static_cast<int>(input_pad_left), static_cast<int>(input_pad_right),\n            To32Bit(padded_input.tensor<T, 4>()),\n            transformed_input_data_format));\n\n    transformed_input = padded_input;\n\n    vertical_padding = common_padding_rows;\n    horizontal_padding = common_padding_cols;\n    VLOG(2) << \"vertical padding set to: \" << vertical_padding\n            << \" horizontal padding set to: \" << horizontal_padding;\n    tensor_in_rows = new_in_rows;\n    tensor_in_cols = new_in_cols;\n  } else {\n    transformed_and_padded_input_backprop = transformed_input_backprop;\n  }\n\n  /// Get ready to call cudnn\n  se::dnn::PoolingDescriptor pooling_desc;\n  pooling_desc.set_pooling_mode(pooling_mode)\n      .set_window_height(params.window_rows)\n      .set_window_width(params.window_cols)\n      .set_vertical_stride(params.row_stride)\n      .set_horizontal_stride(params.col_stride)\n      .set_vertical_padding(vertical_padding)\n      .set_horizontal_padding(horizontal_padding)\n      .set_propagate_nans(propagate_nans);\n\n  se::dnn::BatchDescriptor orig_output_desc;\n  orig_output_desc.set_count(params.tensor_in_batch)\n      .set_height(params.out_height)\n      .set_width(params.out_width)\n      .set_feature_map_count(params.depth)\n      .set_layout(data_layout);\n\n  se::dnn::BatchDescriptor orig_input_desc;\n  orig_input_desc.set_count(params.tensor_in_batch)\n      .set_height(tensor_in_rows)\n      .set_width(tensor_in_cols)\n      .set_feature_map_count(params.depth)\n      .set_layout(data_layout);\n\n  auto orig_output_data =\n      AsDeviceMemory(transformed_output.template flat<T>().data(),\n                     transformed_output.template flat<T>().size());\n  auto orig_input_data =\n      AsDeviceMemory(transformed_input.template flat<T>().data(),\n                     transformed_input.template flat<T>().size());\n  auto output_backprop_data =\n      AsDeviceMemory(transformed_output_backprop.template flat<T>().data(),\n                     transformed_output_backprop.template flat<T>().size());\n  auto input_backprop_data = AsDeviceMemory(\n      transformed_and_padded_input_backprop.template flat<T>().data(),\n      transformed_and_padded_input_backprop.template flat<T>().size());\n\n  auto* stream = context->op_device_context()->stream();\n  OP_REQUIRES(context, stream, errors::Internal(\"No GPU stream available.\"));\n\n#if TENSORFLOW_USE_ROCM\n  static int64 PoolingScratchSize = GetDnnWorkspaceLimit(\n      // default value is in bytes despite the name of the environment variable\n      \"TF_CUDNN_WORKSPACE_LIMIT_IN_MB\", 1LL << 32  // 4GB\n  );\n\n  DnnScratchAllocator scratch_allocator(PoolingScratchSize, context);\n  bool status = stream\n                    ->ThenPoolBackward(pooling_desc, orig_input_desc,\n                                       orig_input_data, orig_output_desc,\n                                       orig_output_data, output_backprop_data,\n                                       &input_backprop_data, &scratch_allocator)\n                    .ok();\n#else\n  bool status =\n      stream\n          ->ThenPoolBackward(pooling_desc, orig_input_desc, orig_input_data,\n                             orig_output_desc, orig_output_data,\n                             output_backprop_data, &input_backprop_data)\n          .ok();\n#endif\n\n  OP_REQUIRES(context, status,\n              errors::Internal(\"dnn PoolBackward launch failed\"));\n\n  if (padding == EXPLICIT && (params.pad_top != params.pad_bottom ||\n                              params.pad_left != params.pad_right)) {\n    // Remove the padding that was added to the input shape above.\n    functor::PadInput<GPUDevice, T, int, 4>()(\n        context->eigen_device<GPUDevice>(),\n        To32Bit(const_cast<const Tensor&>(transformed_and_padded_input_backprop)\n                    .tensor<T, 4>()),\n        {{static_cast<int>(-input_pad_top), static_cast<int>(-input_pad_left)}},\n        {{static_cast<int>(-input_pad_bottom),\n          static_cast<int>(-input_pad_right)}},\n        To32Bit(transformed_input_backprop.template tensor<T, 4>()),\n        transformed_input_data_format, T{});\n  }\n\n#if CUDNN_VERSION < 7300\n  if (data_format == FORMAT_NHWC) {\n    /// Transform the output data from NCHW back to NHWC.\n    auto toConstTensor = [](const Tensor& x) -> const Tensor { return x; };\n    functor::NCHWToNHWC<GPUDevice, T, 4>()(\n        context->eigen_device<Device>(),\n        toConstTensor(transformed_input_backprop).template tensor<T, 4>(),\n        input_backprop->tensor<T, 4>());\n  }\n#endif  // CUDNN_VERSION < 7300\n}\n\n#define DEFINE_DNN_OPS(T)         \\\n  template class DnnPoolingOp<T>; \\\n  template class DnnPoolingGradOp<T>;\nTF_CALL_GPU_NUMBER_TYPES(DEFINE_DNN_OPS)\n\n#if CUDNN_VERSION >= 7300\ntemplate class DnnPoolingOp<qint8>;\n#endif\n\n#undef DEFINE_DNN_OPS\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n}  // namespace tensorflow\n"], "filenames": ["tensorflow/core/kernels/maxpooling_op.cc", "tensorflow/core/kernels/pooling_ops_common.cc"], "buggy_code_start_loc": [76, 173], "buggy_code_end_loc": [951, 173], "fixing_code_start_loc": [77, 174], "fixing_code_end_loc": [957, 176], "type": "CWE-20", "message": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a denial of service via a segmentation fault in `tf.raw_ops.MaxPoolGrad` caused by missing validation. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/maxpooling_op.cc) misses some validation for the `orig_input` and `orig_output` tensors. The fixes for CVE-2021-29579 were incomplete. We have patched the issue in GitHub commit 136b51f10903e044308cf77117c0ed9871350475. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "other": {"cve": {"id": "CVE-2021-37674", "sourceIdentifier": "security-advisories@github.com", "published": "2021-08-12T23:15:07.970", "lastModified": "2021-08-19T14:02:57.147", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a denial of service via a segmentation fault in `tf.raw_ops.MaxPoolGrad` caused by missing validation. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/maxpooling_op.cc) misses some validation for the `orig_input` and `orig_output` tensors. The fixes for CVE-2021-29579 were incomplete. We have patched the issue in GitHub commit 136b51f10903e044308cf77117c0ed9871350475. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto de extremo a extremo para el aprendizaje autom\u00e1tico.&#xa0;En las versiones afectadas, un atacante puede desencadenar una denegaci\u00f3n de servicio por medio de un fallo de segmentaci\u00f3n en \"tf.raw_ops.MaxPoolGrad\" causada por una falta de comprobaci\u00f3n.&#xa0;La [implementaci\u00f3n] (https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/maxpooling_op.cc) pierde alguna comprobaci\u00f3n para los tensores \"orig_input\" y\" orig_output\".&#xa0;Las correcciones para CVE-2021-29579 estaban incompletas.&#xa0;Hemos solucionado el problema en el commit de GitHub 136b51f10903e044308cf77117c0ed9871350475.&#xa0;La correcci\u00f3n ser\u00e1 incluida en TensorFlow versi\u00f3n 2.6.0.&#xa0;Tambi\u00e9n seleccionaremos este commit en TensorFlow versi\u00f3n 2.5.1, TensorFlow versi\u00f3n 2.4.3 y TensorFlow versi\u00f3n 2.3.4, ya que estos tambi\u00e9n est\u00e1n afectados y a\u00fan se encuentran en el rango admitido."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.3.0", "versionEndExcluding": "2.3.4", "matchCriteriaId": "0F83C081-51CC-415F-A8C0-0A44C75E2CD6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.0", "versionEndExcluding": "2.4.3", "matchCriteriaId": "BD3F2BF8-EBA9-42BF-8F9B-D918B880B15A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "D03E99A7-4E3D-427D-A156-C0713E9FB02A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.6.0:rc0:*:*:*:*:*:*", "matchCriteriaId": "70FA6E48-6C57-40CA-809F-4E3D07CBF348"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.6.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "42187561-E491-434D-828C-F36701446634"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.6.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "C66B61C8-450A-4C5E-9174-F970D6DEE778"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/blob/master/tensorflow/security/advisory/tfsa-2021-068.md", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/commit/136b51f10903e044308cf77117c0ed9871350475", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-7ghq-fvr3-pj2x", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/136b51f10903e044308cf77117c0ed9871350475"}}