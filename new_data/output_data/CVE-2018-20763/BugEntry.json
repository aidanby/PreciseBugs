{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2005-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / command-line client\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n/*includes both terminal and od browser*/\n#include <gpac/terminal.h>\n#include <gpac/term_info.h>\n#include <gpac/constants.h>\n#include <gpac/events.h>\n#include <gpac/media_tools.h>\n#include <gpac/options.h>\n#include <gpac/modules/service.h>\n#include <gpac/avparse.h>\n#include <gpac/network.h>\n#include <gpac/utf.h>\n#include <time.h>\n\n/*ISO 639 languages*/\n#include <gpac/iso639.h>\n\n//FIXME we need a plugin for playlists\n#include <gpac/internal/terminal_dev.h>\n\n\n#ifndef WIN32\n#include <dlfcn.h>\n#include <pwd.h>\n#include <unistd.h>\n#if defined(__DARWIN__) || defined(__APPLE__)\n#include <sys/types.h>\n#include <sys/stat.h>\n\nvoid carbon_init();\nvoid carbon_uninit();\n\n#endif\n\n#else\n#include <windows.h> /*for GetModuleFileName*/\n#endif\t//WIN32\n\n/*local prototypes*/\nvoid PrintWorldInfo(GF_Terminal *term);\nvoid ViewOD(GF_Terminal *term, u32 OD_ID, u32 number, const char *URL);\nvoid PrintODList(GF_Terminal *term, GF_ObjectManager *root_odm, u32 num, u32 indent, char *root_name);\n\nvoid ViewODs(GF_Terminal *term, Bool show_timing);\nvoid PrintGPACConfig();\n\nstatic u32 gui_mode = 0;\n\nstatic Bool restart = GF_FALSE;\nstatic Bool reload = GF_FALSE;\n\nBool no_prog = 0;\n\n#if defined(__DARWIN__) || defined(__APPLE__)\n//we keep no decoder thread because of JS_GC deadlocks between threads ...\nstatic u32 threading_flags = GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_DECODER_THREAD;\n#define VK_MOD  GF_KEY_MOD_ALT\n#else\nstatic u32 threading_flags = 0;\n#define VK_MOD  GF_KEY_MOD_CTRL\n#endif\nstatic Bool no_audio = GF_FALSE;\nstatic Bool term_step = GF_FALSE;\nstatic Bool no_regulation = GF_FALSE;\nstatic u32 bench_mode = 0;\nstatic u32 bench_mode_start = 0;\nstatic u32 bench_buffer = 0;\nstatic Bool eos_seen = GF_FALSE;\nstatic Bool addon_visible = GF_TRUE;\nBool is_connected = GF_FALSE;\nBool startup_file = GF_FALSE;\nGF_User user;\nGF_Terminal *term;\nu64 Duration;\nGF_Err last_error = GF_OK;\nstatic Bool enable_add_ons = GF_TRUE;\nstatic Fixed playback_speed = FIX_ONE;\n\nstatic s32 request_next_playlist_item = GF_FALSE;\nFILE *playlist = NULL;\nstatic Bool readonly_playlist = GF_FALSE;\n\nstatic GF_Config *cfg_file;\nstatic u32 display_rti = 0;\nstatic Bool Run;\nstatic Bool CanSeek = GF_FALSE;\nstatic char the_url[GF_MAX_PATH];\nstatic char pl_path[GF_MAX_PATH];\nstatic Bool no_mime_check = GF_TRUE;\nstatic Bool be_quiet = GF_FALSE;\nstatic u64 log_time_start = 0;\nstatic Bool log_utc_time = GF_FALSE;\nstatic Bool loop_at_end = GF_FALSE;\nstatic u32 forced_width=0;\nstatic u32 forced_height=0;\n\n/*windowless options*/\nu32 align_mode = 0;\nu32 init_w = 0;\nu32 init_h = 0;\nu32 last_x, last_y;\nBool right_down = GF_FALSE;\n\nvoid dump_frame(GF_Terminal *term, char *rad_path, u32 dump_type, u32 frameNum);\n\nenum\n{\n\tDUMP_NONE = 0,\n\tDUMP_AVI = 1,\n\tDUMP_BMP = 2,\n\tDUMP_PNG = 3,\n\tDUMP_RAW = 4,\n\tDUMP_SHA1 = 5,\n\n\t//DuMP flags\n\tDUMP_DEPTH_ONLY = 1<<16,\n\tDUMP_RGB_DEPTH = 1<<17,\n\tDUMP_RGB_DEPTH_SHAPE = 1<<18\n};\n\nBool dump_file(char *the_url, char *out_url, u32 dump_mode, Double fps, u32 width, u32 height, Float scale, u32 *times, u32 nb_times);\n\n\nstatic Bool shell_visible = GF_TRUE;\nvoid hide_shell(u32 cmd_type)\n{\n#if defined(WIN32) && !defined(_WIN32_WCE)\n\ttypedef HWND (WINAPI *GetConsoleWindowT)(void);\n\tHMODULE hk32 = GetModuleHandle(\"kernel32.dll\");\n\tGetConsoleWindowT GetConsoleWindow = (GetConsoleWindowT ) GetProcAddress(hk32,\"GetConsoleWindow\");\n\tif (cmd_type==0) {\n\t\tShowWindow( GetConsoleWindow(), SW_SHOW);\n\t\tshell_visible = GF_TRUE;\n\t}\n\telse if (cmd_type==1) {\n\t\tShowWindow( GetConsoleWindow(), SW_HIDE);\n\t\tshell_visible = GF_FALSE;\n\t}\n\telse if (cmd_type==2) PostMessage(GetConsoleWindow(), WM_CLOSE, 0, 0);\n\n#endif\n}\n\n\nvoid send_open_url(const char *url)\n{\n\tGF_Event evt;\n\tmemset(&evt, 0, sizeof(GF_Event));\n\tevt.type = GF_EVENT_NAVIGATE;\n\tevt.navigate.to_url = url;\n\tgf_term_send_event(term, &evt);\n}\n\nvoid PrintUsage()\n{\n\tfprintf(stderr, \"Usage MP4Client [options] [filename]\\n\"\n\t        \"\\t-c fileName:    user-defined configuration file. Also works with -cfg\\n\"\n#ifdef GPAC_MEMORY_TRACKING\n            \"\\t-mem-track:  enables memory tracker\\n\"\n            \"\\t-mem-track-stack:  enables memory tracker with stack dumping\\n\"\n#endif\n\t        \"\\t-rti fileName:  logs run-time info (FPS, CPU, Mem usage) to file\\n\"\n\t        \"\\t-rtix fileName: same as -rti but driven by GPAC logs\\n\"\n\t        \"\\t-quiet:         removes script message, buffering and downloading status\\n\"\n\t        \"\\t-strict-error:  exit when the player reports its first error\\n\"\n\t        \"\\t-opt option:    Overrides an option in the configuration file. String format is section:key=value. \\n\"\n\t        \"\\t                  \\\"section:key=null\\\" removes the key\\n\"\n\t        \"\\t                  \\\"section:*=null\\\" removes the section\\n\"\n\t        \"\\t-conf option:   Same as -opt but does not start player.\\n\"\n\t        \"\\t-log-file file: sets output log file. Also works with -lf\\n\"\n\t        \"\\t-logs log_args: sets log tools and levels, formatted as a ':'-separated list of toolX[:toolZ]@levelX\\n\"\n\t        \"\\t                 levelX can be one of:\\n\"\n\t        \"\\t        \\\"quiet\\\"      : skip logs\\n\"\n\t        \"\\t        \\\"error\\\"      : logs only error messages\\n\"\n\t        \"\\t        \\\"warning\\\"    : logs error+warning messages\\n\"\n\t        \"\\t        \\\"info\\\"       : logs error+warning+info messages\\n\"\n\t        \"\\t        \\\"debug\\\"      : logs all messages\\n\"\n\t        \"\\t                 toolX can be one of:\\n\"\n\t        \"\\t        \\\"core\\\"       : libgpac core\\n\"\n\t        \"\\t        \\\"coding\\\"     : bitstream formats (audio, video, scene)\\n\"\n\t        \"\\t        \\\"container\\\"  : container formats (ISO File, MPEG-2 TS, AVI, ...)\\n\"\n\t        \"\\t        \\\"network\\\"    : network data exept RTP trafic\\n\"\n\t        \"\\t        \\\"rtp\\\"        : rtp trafic\\n\"\n\t        \"\\t        \\\"author\\\"     : authoring tools (hint, import, export)\\n\"\n\t        \"\\t        \\\"sync\\\"       : terminal sync layer\\n\"\n\t        \"\\t        \\\"codec\\\"      : terminal codec messages\\n\"\n\t        \"\\t        \\\"parser\\\"     : scene parsers (svg, xmt, bt) and other\\n\"\n\t        \"\\t        \\\"media\\\"      : terminal media object management\\n\"\n\t        \"\\t        \\\"scene\\\"      : scene graph and scene manager\\n\"\n\t        \"\\t        \\\"script\\\"     : scripting engine messages\\n\"\n\t        \"\\t        \\\"interact\\\"   : interaction engine (events, scripts, etc)\\n\"\n\t        \"\\t        \\\"smil\\\"       : SMIL timing engine\\n\"\n\t        \"\\t        \\\"compose\\\"    : composition engine (2D, 3D, etc)\\n\"\n\t        \"\\t        \\\"mmio\\\"       : Audio/Video HW I/O management\\n\"\n\t        \"\\t        \\\"rti\\\"        : various run-time stats\\n\"\n\t        \"\\t        \\\"cache\\\"      : HTTP cache subsystem\\n\"\n\t        \"\\t        \\\"audio\\\"      : Audio renderer and mixers\\n\"\n#ifdef GPAC_MEMORY_TRACKING\n\t        \"\\t        \\\"mem\\\"        : GPAC memory tracker\\n\"\n#endif\n#ifndef GPAC_DISABLE_DASH_CLIENT\n\t        \"\\t        \\\"dash\\\"       : HTTP streaming logs\\n\"\n#endif\n\t        \"\\t        \\\"module\\\"     : GPAC modules debugging\\n\"\n\t        \"\\t        \\\"mutex\\\"      : mutex\\n\"\n\t        \"\\t        \\\"all\\\"        : all tools logged - other tools can be specified afterwards.\\n\"\n\t        \"\\tThe special value \\\"ncl\\\" disables color logs.\\n\"\n\t        \"\\n\"\n\t        \"\\t-log-clock or -lc      : logs time in micro sec since start time of GPAC before each log line.\\n\"\n\t        \"\\t-log-utc or -lu        : logs UTC time in ms before each log line.\\n\"\n\t        \"\\t-ifce IPIFCE           : Sets default Multicast interface\\n\"\n\t        \"\\t-size WxH:      specifies visual size (default: scene size)\\n\"\n#if defined(__DARWIN__) || defined(__APPLE__)\n\t        \"\\t-thread:        enables thread usage for terminal and compositor \\n\"\n#else\n\t        \"\\t-no-thread:     disables thread usage (except for audio)\\n\"\n#endif\n\t        \"\\t-no-cthread:    disables compositor thread (iOS and Android mode)\\n\"\n\t        \"\\t-no-audio:      disables audio \\n\"\n\t        \"\\t-no-wnd:        uses windowless mode (Win32 only)\\n\"\n\t        \"\\t-no-back:       uses transparent background for output window when no background is specified (Win32 only)\\n\"\n\t        \"\\t-align vh:      specifies v and h alignment for windowless mode\\n\"\n\t        \"\\t                 possible v values: t(op), m(iddle), b(ottom)\\n\"\n\t        \"\\t                 possible h values: l(eft), m(iddle), r(ight)\\n\"\n\t        \"\\t                 default alignment is top-left\\n\"\n\t        \"\\t                 default alignment is top-left\\n\"\n\t        \"\\t-pause:         pauses at first frame\\n\"\n\t        \"\\t-play-from T:   starts from T seconds in media\\n\"\n\t        \"\\t-speed S:       starts with speed S\\n\"\n\t        \"\\t-loop:          loops presentation\\n\"\n\t        \"\\t-no-regulation: disables framerate regulation\\n\"\n\t        \"\\t-bench:         disable a/v output and bench source decoding (as fast as possible)\\n\"\n\t        \"\\t-vbench:        disable audio output, video sync bench source decoding/display (as fast as possible)\\n\"\n\t        \"\\t-sbench:        disable all decoders and bench systems layer (as fast as possible)\\n\"\n\t        \"\\t-fs:            starts in fullscreen mode\\n\"\n\t        \"\\t-views v1:.:vN: creates an auto-stereo scene of N views. vN can be any type of URL supported by GPAC.\\n\"\n\t        \"\\t                 in this mode, URL argument of GPAC is ignored, GUI as well.\\n\"\n\t        \"\\t                 this is equivalent as using views://v1:.:N as an URL.\\n\"\n\t        \"\\t-mosaic v1:.:vN: creates a mosaic of N views. vN can be any type of URL supported by GPAC.\\n\"\n\t        \"\\t                 in this mode, URL argument of GPAC is ignored.\\n\"\n\t        \"\\t                 this is equivalent as using mosaic://v1:.:N as an URL.\\n\"\n\t        \"\\n\"\n\t        \"\\t-exit:          automatically exits when presentation is over\\n\"\n\t        \"\\t-run-for TIME:  runs for TIME seconds and exits\\n\"\n\t        \"\\t-service ID:    auto-tune to given service ID in a multiplex\\n\"\n\t        \"\\t-noprog:        disable progress report\\n\"\n\t        \"\\t-no-save:       disable saving config file on exit\\n\"\n\t        \"\\t-no-addon:      disable automatic loading of media addons declared in source URL\\n\"\n\t        \"\\t-gui:           starts in GUI mode. The GUI is indicated in GPAC config, section General, by the key [StartupFile]\\n\"\n\t        \"\\t-ntp-shift T:   shifts NTP clock of T (signed int) milliseconds\\n\"\n\t        \"\\n\"\n\t        \"Dumper Options (times is a formated as start-end, with start being sec, h:m:s:f/fps or h:m:s:ms):\\n\"\n\t        \"\\t-bmp [times]:   dumps given frames to bmp\\n\"\n\t        \"\\t-png [times]:   dumps given frames to png\\n\"\n\t        \"\\t-raw [times]:   dumps given frames to raw\\n\"\n\t        \"\\t-avi [times]:   dumps given file to raw avi\\n\"\n\t        \"\\t-sha [times]:   dumps given file to raw SHA-1 (1 hash per frame)\\n\"\n\t        \"\\r-out filename:  name of the output file\\n\"\n\t        \"\\t-rgbds:         dumps the RGBDS pixel format texture\\n\"\n\t        \"\\t                 with -avi [times]: dumps an rgbds-format .avi\\n\"\n\t        \"\\t-rgbd:          dumps the RGBD pixel format texture\\n\"\n\t        \"\\t                 with -avi [times]: dumps an rgbd-format .avi\\n\"\n\t        \"\\t-depth:         dumps depthmap (z-buffer) frames\\n\"\n\t        \"\\t                 with -avi [times]: dumps depthmap in grayscale .avi\\n\"\n\t        \"\\t                 with -bmp: dumps depthmap in grayscale .bmp\\n\"\n\t        \"\\t                 with -png: dumps depthmap in grayscale .png\\n\"\n\t        \"\\t-fps FPS:       specifies frame rate for AVI dumping (default: %f)\\n\"\n\t        \"\\t-scale s:       scales the visual size (default: 1)\\n\"\n\t        \"\\t-fill:          uses fill aspect ratio for dumping (default: none)\\n\"\n\t        \"\\t-show:          shows window while dumping (default: no)\\n\"\n\t        \"\\n\"\n\t        \"\\t-uncache:       Revert all cached items to their original name and location. Does not start player.\\n\"\n\t        \"\\n\"\n\t        \"\\t-help:          shows this screen\\n\"\n\t        \"\\n\"\n\t        \"MP4Client - GPAC command line player and dumper - version \"GPAC_FULL_VERSION\"\\n\"\n\t        \"(c) Telecom ParisTech 2000-2018 - Licence LGPL v2\\n\"\n\t        \"GPAC Configuration: \" GPAC_CONFIGURATION \"\\n\"\n\t        \"Features: %s\\n\",\n\t        GF_IMPORT_DEFAULT_FPS,\n\t        gpac_features()\n\t       );\n}\n\nvoid PrintHelp()\n{\n\tfprintf(stderr, \"MP4Client command keys:\\n\"\n\t        \"\\tq: quit\\n\"\n\t        \"\\tX: kill\\n\"\n\t        \"\\to: connect to the specified URL\\n\"\n\t        \"\\tO: connect to the specified playlist\\n\"\n\t        \"\\tN: switch to the next URL in the playlist. Also works with \\\\n\\n\"\n\t        \"\\tP: jumps to a given number ahead in the playlist\\n\"\n\t        \"\\tr: reload current presentation\\n\"\n\t        \"\\tD: disconnects the current presentation\\n\"\n\t        \"\\tG: selects object or service ID\\n\"\n\t        \"\\n\"\n\t        \"\\tp: play/pause the presentation\\n\"\n\t        \"\\ts: step one frame ahead\\n\"\n\t        \"\\tz: seek into presentation by percentage\\n\"\n\t        \"\\tT: seek into presentation by time\\n\"\n\t        \"\\tt: print current timing\\n\"\n\t        \"\\n\"\n\t        \"\\tu: sends a command (BIFS or LASeR) to the main scene\\n\"\n\t        \"\\te: evaluates JavaScript code\\n\"\n\t        \"\\tZ: dumps output video to PNG\\n\"\n\t        \"\\n\"\n\t        \"\\tw: view world info\\n\"\n\t        \"\\tv: view Object Descriptor list\\n\"\n\t        \"\\ti: view Object Descriptor info (by ID)\\n\"\n\t        \"\\tj: view Object Descriptor info (by number)\\n\"\n\t        \"\\tb: view media objects timing and buffering info\\n\"\n\t        \"\\tm: view media objects buffering and memory info\\n\"\n\t        \"\\td: dumps scene graph\\n\"\n\t        \"\\n\"\n\t        \"\\tk: turns stress mode on/off\\n\"\n\t        \"\\tn: changes navigation mode\\n\"\n\t        \"\\tx: reset to last active viewpoint\\n\"\n\t        \"\\n\"\n\t        \"\\t3: switch OpenGL on or off for 2D scenes\\n\"\n\t        \"\\n\"\n\t        \"\\t4: forces 4/3 Aspect Ratio\\n\"\n\t        \"\\t5: forces 16/9 Aspect Ratio\\n\"\n\t        \"\\t6: forces no Aspect Ratio (always fill screen)\\n\"\n\t        \"\\t7: forces original Aspect Ratio (default)\\n\"\n\t        \"\\n\"\n\t        \"\\tL: changes to new log level. CF MP4Client usage for possible values\\n\"\n\t        \"\\tT: select new tools to log. CF MP4Client usage for possible values\\n\"\n\t        \"\\n\"\n\t        \"\\tl: list available modules\\n\"\n\t        \"\\tc: prints some GPAC configuration info\\n\"\n\t        \"\\tE: forces reload of GPAC configuration\\n\"\n\t        \"\\n\"\n\t        \"\\tR: toggles run-time info display in window title bar on/off\\n\"\n\t        \"\\tF: toggle displaying of FPS in stderr on/off\\n\"\n\t        \"\\tg: print GPAC allocated memory\\n\"\n\t        \"\\th: print this message\\n\"\n\t        \"\\n\"\n\t        \"\\tEXPERIMENTAL/UNSTABLE OPTIONS\\n\"\n\t        \"\\tC: Enable Streaming Cache\\n\"\n\t        \"\\tS: Stops Streaming Cache and save to file\\n\"\n\t        \"\\tA: Aborts Streaming Cache\\n\"\n\t        \"\\tM: specifies video cache memory for 2D objects\\n\"\n\t        \"\\n\"\n\t        \"MP4Client - GPAC command line player - version %s\\n\"\n\t        \"GPAC Written by Jean Le Feuvre (c) 2001-2005 - ENST (c) 2005-200X\\n\",\n\n\t        GPAC_FULL_VERSION\n\t       );\n}\n\n\nstatic void PrintTime(u64 time)\n{\n\tu32 ms, h, m, s;\n\th = (u32) (time / 1000 / 3600);\n\tm = (u32) (time / 1000 / 60 - h*60);\n\ts = (u32) (time / 1000 - h*3600 - m*60);\n\tms = (u32) (time - (h*3600 + m*60 + s) * 1000);\n\tfprintf(stderr, \"%02d:%02d:%02d.%03d\", h, m, s, ms);\n}\n\nvoid PrintAVInfo(Bool final);\n\n\nstatic u32 rti_update_time_ms = 200;\nstatic FILE *rti_logs = NULL;\n\nstatic void UpdateRTInfo(const char *legend)\n{\n\tGF_SystemRTInfo rti;\n\n\t/*refresh every second*/\n\tif (!display_rti && !rti_logs) return;\n\tif (!gf_sys_get_rti(rti_update_time_ms, &rti, 0) && !legend)\n\t\treturn;\n\n\tif (display_rti) {\n\t\tchar szMsg[1024];\n\n\t\tif (rti.total_cpu_usage && (bench_mode<2) ) {\n\t\t\tsprintf(szMsg, \"FPS %02.02f CPU %2d (%02d) Mem %d kB\",\n\t\t\t        gf_term_get_framerate(term, 0), rti.total_cpu_usage, rti.process_cpu_usage, (u32) (rti.gpac_memory / 1024));\n\t\t} else {\n\t\t\tsprintf(szMsg, \"FPS %02.02f CPU %02d Mem %d kB\",\n\t\t\t        gf_term_get_framerate(term, 0), rti.process_cpu_usage, (u32) (rti.gpac_memory / 1024) );\n\t\t}\n\n\t\tif (display_rti==2) {\n\t\t\tif (bench_mode>=2) {\n\t\t\t\tPrintAVInfo(GF_FALSE);\n\t\t\t}\n\t\t\tfprintf(stderr, \"%s\\r\", szMsg);\n\t\t} else {\n\t\t\tGF_Event evt;\n\t\t\tevt.type = GF_EVENT_SET_CAPTION;\n\t\t\tevt.caption.caption = szMsg;\n\t\t\tgf_term_user_event(term, &evt);\n\t\t}\n\t}\n\tif (rti_logs) {\n\t\tfprintf(rti_logs, \"% 8d\\t% 8d\\t% 8d\\t% 4d\\t% 8d\\t%s\",\n\t\t        gf_sys_clock(),\n\t\t        gf_term_get_time_in_ms(term),\n\t\t        rti.total_cpu_usage,\n\t\t        (u32) gf_term_get_framerate(term, 0),\n\t\t        (u32) (rti.gpac_memory / 1024),\n\t\t        legend ? legend : \"\"\n\t\t       );\n\t\tif (!legend) fprintf(rti_logs, \"\\n\");\n\t}\n}\n\nstatic void ResetCaption()\n{\n\tGF_Event event;\n\tif (display_rti) return;\n\tevent.type = GF_EVENT_SET_CAPTION;\n\tif (is_connected) {\n\t\tchar szName[1024];\n\t\tNetInfoCommand com;\n\n\t\tevent.caption.caption = NULL;\n\t\t/*get any service info*/\n\t\tif (!startup_file && gf_term_get_service_info(term, gf_term_get_root_object(term), &com) == GF_OK) {\n\t\t\tstrcpy(szName, \"\");\n\t\t\tif (com.track_info) {\n\t\t\t\tchar szBuf[10];\n\t\t\t\tsprintf(szBuf, \"%02d \", (u32) (com.track_info>>16) );\n\t\t\t\tstrcat(szName, szBuf);\n\t\t\t}\n\t\t\tif (com.artist) {\n\t\t\t\tstrcat(szName, com.artist);\n\t\t\t\tstrcat(szName, \" \");\n\t\t\t}\n\t\t\tif (com.name) {\n\t\t\t\tstrcat(szName, com.name);\n\t\t\t\tstrcat(szName, \" \");\n\t\t\t}\n\t\t\tif (com.album) {\n\t\t\t\tstrcat(szName, \"(\");\n\t\t\t\tstrcat(szName, com.album);\n\t\t\t\tstrcat(szName, \")\");\n\t\t\t}\n\t\t\tif (com.provider) {\n\t\t\t\tstrcat(szName, \"(\");\n\t\t\t\tstrcat(szName, com.provider);\n\t\t\t\tstrcat(szName, \")\");\n\t\t\t}\n\n\t\t\tif (strlen(szName)) event.caption.caption = szName;\n\t\t}\n\t\tif (!event.caption.caption) {\n\t\t\tchar *str = strrchr(the_url, '\\\\');\n\t\t\tif (!str) str = strrchr(the_url, '/');\n\t\t\tevent.caption.caption = str ? str+1 : the_url;\n\t\t}\n\t} else {\n\t\tevent.caption.caption = \"GPAC MP4Client \" GPAC_FULL_VERSION;\n\t}\n\tgf_term_user_event(term, &event);\n}\n\n#ifdef WIN32\nu32 get_sys_col(int idx)\n{\n\tu32 res;\n\tDWORD val = GetSysColor(idx);\n\tres = (val)&0xFF;\n\tres<<=8;\n\tres |= (val>>8)&0xFF;\n\tres<<=8;\n\tres |= (val>>16)&0xFF;\n\treturn res;\n}\n#endif\n\nvoid switch_bench(u32 is_on)\n{\n\tbench_mode = is_on;\n\tdisplay_rti = is_on ? 2 : 0;\n\tResetCaption();\n\tgf_term_set_option(term, GF_OPT_VIDEO_BENCH, is_on);\n}\n\n#ifndef WIN32\n#include <termios.h>\nint getch() {\n\tstruct termios old;\n\tstruct termios new;\n\tint rc;\n\tif (tcgetattr(0, &old) == -1) {\n\t\treturn -1;\n\t}\n\tnew = old;\n\tnew.c_lflag &= ~(ICANON | ECHO);\n\tnew.c_cc[VMIN] = 1;\n\tnew.c_cc[VTIME] = 0;\n\tif (tcsetattr(0, TCSANOW, &new) == -1) {\n\t\treturn -1;\n\t}\n\trc = getchar();\n\t(void) tcsetattr(0, TCSANOW, &old);\n\treturn rc;\n}\n#else\nint getch() {\n\treturn getchar();\n}\n#endif\n\n/**\n * Reads a line of input from stdin\n * @param line the buffer to fill\n * @param maxSize the maximum size of the line to read\n * @param showContent boolean indicating if the line read should be printed on stderr or not\n */\nstatic const char * read_line_input(char * line, int maxSize, Bool showContent) {\n\tchar read;\n\tint i = 0;\n\tif (fflush( stderr ))\n\t\tperror(\"Failed to flush buffer %s\");\n\tdo {\n\t\tline[i] = '\\0';\n\t\tif (i >= maxSize - 1)\n\t\t\treturn line;\n\t\tread = getch();\n\t\tif (read == 8 || read == 127) {\n\t\t\tif (i > 0) {\n\t\t\t\tfprintf(stderr, \"\\b \\b\");\n\t\t\t\ti--;\n\t\t\t}\n\t\t} else if (read > 32) {\n\t\t\tfputc(showContent ? read : '*', stderr);\n\t\t\tline[i++] = read;\n\t\t}\n\t\tfflush(stderr);\n\t} while (read != '\\n');\n\tif (!read)\n\t\treturn 0;\n\treturn line;\n}\n\nstatic void do_set_speed(Fixed desired_speed)\n{\n\tif (gf_term_set_speed(term, desired_speed) == GF_OK) {\n\t\tplayback_speed = desired_speed;\n\t\tfprintf(stderr, \"Playing at %g speed\\n\", FIX2FLT(playback_speed));\n\t} else {\n\t\tfprintf(stderr, \"Adjusting speed to %g not supported for this content\\n\", FIX2FLT(desired_speed));\n\t}\n}\n\nBool GPAC_EventProc(void *ptr, GF_Event *evt)\n{\n\tif (!term) return 0;\n\n\tif (gui_mode==1) {\n\t\tif (evt->type==GF_EVENT_QUIT) {\n\t\t\tRun = 0;\n\t\t} else if (evt->type==GF_EVENT_KEYDOWN) {\n\t\t\tswitch (evt->key.key_code) {\n\t\t\tcase GF_KEY_C:\n\t\t\t\tif (evt->key.flags & (GF_KEY_MOD_CTRL|GF_KEY_MOD_ALT)) {\n\t\t\t\t\thide_shell(shell_visible ? 1 : 0);\n\t\t\t\t\tif (shell_visible) gui_mode=2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tswitch (evt->type) {\n\tcase GF_EVENT_DURATION:\n\t\tDuration = (u64) ( 1000 * (s64) evt->duration.duration);\n\t\tCanSeek = evt->duration.can_seek;\n\t\tbreak;\n\tcase GF_EVENT_MESSAGE:\n\t{\n\t\tconst char *servName;\n\t\tif (!evt->message.service || !strcmp(evt->message.service, the_url)) {\n\t\t\tservName = \"\";\n\t\t} else if (!strnicmp(evt->message.service, \"data:\", 5)) {\n\t\t\tservName = \"(embedded data)\";\n\t\t} else {\n\t\t\tservName = evt->message.service;\n\t\t}\n\n\n\t\tif (!evt->message.message) return 0;\n\n\t\tif (evt->message.error) {\n\t\t\tif (!is_connected) last_error = evt->message.error;\n\t\t\tif (evt->message.error==GF_SCRIPT_INFO) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONSOLE, (\"%s\\n\", evt->message.message));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONSOLE, (\"%s %s: %s\\n\", servName, evt->message.message, gf_error_to_string(evt->message.error)));\n\t\t\t}\n\t\t} else if (!be_quiet)\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONSOLE, (\"%s %s\\n\", servName, evt->message.message));\n\t}\n\tbreak;\n\tcase GF_EVENT_PROGRESS:\n\t{\n\t\tchar *szTitle = \"\";\n\t\tif (evt->progress.progress_type==0) {\n\t\t\tszTitle = \"Buffer \";\n\t\t\tif (bench_mode && (bench_mode!=3) ) {\n\t\t\t\tif (evt->progress.done >= evt->progress.total) bench_buffer = 0;\n\t\t\t\telse bench_buffer = 1 + 100*evt->progress.done / evt->progress.total;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (evt->progress.progress_type==1) {\n\t\t\tif (bench_mode) break;\n\t\t\tszTitle = \"Download \";\n\t\t}\n\t\telse if (evt->progress.progress_type==2) szTitle = \"Import \";\n\t\tgf_set_progress(szTitle, evt->progress.done, evt->progress.total);\n\t}\n\tbreak;\n\n\n\tcase GF_EVENT_DBLCLICK:\n\t\tgf_term_set_option(term, GF_OPT_FULLSCREEN, !gf_term_get_option(term, GF_OPT_FULLSCREEN));\n\t\treturn 0;\n\n\tcase GF_EVENT_MOUSEDOWN:\n\t\tif (evt->mouse.button==GF_MOUSE_RIGHT) {\n\t\t\tright_down = 1;\n\t\t\tlast_x = evt->mouse.x;\n\t\t\tlast_y = evt->mouse.y;\n\t\t}\n\t\treturn 0;\n\tcase GF_EVENT_MOUSEUP:\n\t\tif (evt->mouse.button==GF_MOUSE_RIGHT) {\n\t\t\tright_down = 0;\n\t\t\tlast_x = evt->mouse.x;\n\t\t\tlast_y = evt->mouse.y;\n\t\t}\n\t\treturn 0;\n\tcase GF_EVENT_MOUSEMOVE:\n\t\tif (right_down && (user.init_flags & GF_TERM_WINDOWLESS) ) {\n\t\t\tGF_Event move;\n\t\t\tmove.move.x = evt->mouse.x - last_x;\n\t\t\tmove.move.y = last_y-evt->mouse.y;\n\t\t\tmove.type = GF_EVENT_MOVE;\n\t\t\tmove.move.relative = 1;\n\t\t\tgf_term_user_event(term, &move);\n\t\t}\n\t\treturn 0;\n\n\tcase GF_EVENT_KEYUP:\n\t\tswitch (evt->key.key_code) {\n\t\tcase GF_KEY_SPACE:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) switch_bench(!bench_mode);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_KEYDOWN:\n\t\tgf_term_process_shortcut(term, evt);\n\t\tswitch (evt->key.key_code) {\n\t\tcase GF_KEY_SPACE:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) {\n\t\t\t\t/*ignore key repeat*/\n\t\t\t\tif (!bench_mode) switch_bench(!bench_mode);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_PAGEDOWN:\n\t\tcase GF_KEY_MEDIANEXTTRACK:\n\t\t\trequest_next_playlist_item = 1;\n\t\t\tbreak;\n\t\tcase GF_KEY_MEDIAPREVIOUSTRACK:\n\t\t\tbreak;\n\t\tcase GF_KEY_ESCAPE:\n\t\t\tgf_term_set_option(term, GF_OPT_FULLSCREEN, !gf_term_get_option(term, GF_OPT_FULLSCREEN));\n\t\t\tbreak;\n\t\tcase GF_KEY_C:\n\t\t\tif (evt->key.flags & (GF_KEY_MOD_CTRL|GF_KEY_MOD_ALT)) {\n\t\t\t\thide_shell(shell_visible ? 1 : 0);\n\t\t\t\tif (!shell_visible) gui_mode=1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_F:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) fprintf(stderr, \"Rendering rate: %f FPS\\n\", gf_term_get_framerate(term, 0));\n\t\t\tbreak;\n\t\tcase GF_KEY_T:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) fprintf(stderr, \"Scene Time: %f \\n\", gf_term_get_time_in_ms(term)/1000.0);\n\t\t\tbreak;\n\t\tcase GF_KEY_D:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) gf_term_set_option(term, GF_OPT_DRAW_MODE, (gf_term_get_option(term, GF_OPT_DRAW_MODE)==GF_DRAW_MODE_DEFER) ? GF_DRAW_MODE_IMMEDIATE : GF_DRAW_MODE_DEFER );\n\t\t\tbreak;\n\t\tcase GF_KEY_4:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);\n\t\t\tbreak;\n\t\tcase GF_KEY_5:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);\n\t\t\tbreak;\n\t\tcase GF_KEY_6:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t\t\tbreak;\n\t\tcase GF_KEY_7:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);\n\t\t\tbreak;\n\t\tcase GF_KEY_O:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tif (gf_term_get_option(term, GF_OPT_MAIN_ADDON)) {\n\t\t\t\t\tfprintf(stderr, \"Resuming to main content\\n\");\n\t\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_PLAY_LIVE);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Main addon not enabled\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_P:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tu32 pause_state = gf_term_get_option(term, GF_OPT_PLAY_STATE) ;\n\t\t\t\tfprintf(stderr, \"[Status: %s]\\n\", pause_state ? \"Playing\" : \"Paused\");\n\t\t\t\tif ((pause_state == GF_STATE_PAUSED) && (evt->key.flags & GF_KEY_MOD_SHIFT)) {\n\t\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_PLAY_LIVE);\n\t\t\t\t} else {\n\t\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, (pause_state==GF_STATE_PAUSED) ? GF_STATE_PLAYING : GF_STATE_PAUSED);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_S:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);\n\t\t\t\tfprintf(stderr, \"Step time: \");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_B:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected)\n\t\t\t\tViewODs(term, 1);\n\t\t\tbreak;\n\t\tcase GF_KEY_M:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected)\n\t\t\t\tViewODs(term, 0);\n\t\t\tbreak;\n\t\tcase GF_KEY_H:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tgf_term_switch_quality(term, 1);\n\t\t\t//\tgf_term_set_option(term, GF_OPT_MULTIVIEW_MODE, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_L:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tgf_term_switch_quality(term, 0);\n\t\t\t//\tgf_term_set_option(term, GF_OPT_MULTIVIEW_MODE, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_F5:\n\t\t\tif (is_connected)\n\t\t\t\treload = 1;\n\t\t\tbreak;\n\t\tcase GF_KEY_A:\n\t\t\taddon_visible = !addon_visible;\n\t\t\tgf_term_toggle_addons(term, addon_visible);\n\t\t\tbreak;\n\t\tcase GF_KEY_UP:\n\t\t\tif ((evt->key.flags & VK_MOD) && is_connected) {\n\t\t\t\tdo_set_speed(playback_speed * 2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_DOWN:\n\t\t\tif ((evt->key.flags & VK_MOD) && is_connected) {\n\t\t\t\tdo_set_speed(playback_speed / 2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_LEFT:\n\t\t\tif ((evt->key.flags & VK_MOD) && is_connected) {\n\t\t\t\tdo_set_speed(-1 * playback_speed );\n\t\t\t}\n\t\t\tbreak;\n\n\t\t}\n\t\tbreak;\n\n\tcase GF_EVENT_CONNECT:\n\t\tif (evt->connect.is_connected) {\n\t\t\tis_connected = 1;\n\t\t\tfprintf(stderr, \"Service Connected\\n\");\n\t\t\teos_seen = GF_FALSE;\n\t\t\tif (playback_speed != FIX_ONE)\n\t\t\t\tgf_term_set_speed(term, playback_speed);\n\n\t\t} else if (is_connected) {\n\t\t\tfprintf(stderr, \"Service %s\\n\", is_connected ? \"Disconnected\" : \"Connection Failed\");\n\t\t\tis_connected = 0;\n\t\t\tDuration = 0;\n\t\t}\n\t\tif (init_w && init_h) {\n\t\t\tgf_term_set_size(term, init_w, init_h);\n\t\t}\n\t\tResetCaption();\n\t\tbreak;\n\tcase GF_EVENT_EOS:\n\t\teos_seen = GF_TRUE;\n\t\tif (playlist) {\n\t\t\tif (Duration>1500)\n\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t}\n\t\telse if (loop_at_end) {\n\t\t\trestart = 1;\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_SIZE:\n\t\tif (user.init_flags & GF_TERM_WINDOWLESS) {\n\t\t\tGF_Event move;\n\t\t\tmove.type = GF_EVENT_MOVE;\n\t\t\tmove.move.align_x = align_mode & 0xFF;\n\t\t\tmove.move.align_y = (align_mode>>8) & 0xFF;\n\t\t\tmove.move.relative = 2;\n\t\t\tgf_term_user_event(term, &move);\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_SCENE_SIZE:\n\t\tif (forced_width && forced_height) {\n\t\t\tGF_Event size;\n\t\t\tsize.type = GF_EVENT_SIZE;\n\t\t\tsize.size.width = forced_width;\n\t\t\tsize.size.height = forced_height;\n\t\t\tgf_term_user_event(term, &size);\n\t\t}\n\t\tbreak;\n\n\tcase GF_EVENT_METADATA:\n\t\tResetCaption();\n\t\tbreak;\n\n\tcase GF_EVENT_RELOAD:\n\t\tif (is_connected)\n\t\t\treload = 1;\n\t\tbreak;\n\tcase GF_EVENT_DROPFILE:\n\t{\n\t\tu32 i, pos;\n\t\t/*todo - force playlist mode*/\n\t\tif (readonly_playlist) {\n\t\t\tgf_fclose(playlist);\n\t\t\tplaylist = NULL;\n\t\t}\n\t\treadonly_playlist = 0;\n\t\tif (!playlist) {\n\t\t\treadonly_playlist = 0;\n\t\t\tplaylist = gf_temp_file_new(NULL);\n\t\t}\n\t\tpos = ftell(playlist);\n\t\ti=0;\n\t\twhile (i<evt->open_file.nb_files) {\n\t\t\tif (evt->open_file.files[i] != NULL) {\n\t\t\t\tfprintf(playlist, \"%s\\n\", evt->open_file.files[i]);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tfseek(playlist, pos, SEEK_SET);\n\t\trequest_next_playlist_item = 1;\n\t}\n\treturn 1;\n\n\tcase GF_EVENT_QUIT:\n\t\tif (evt->message.error)  {\n\t\t\tfprintf(stderr, \"A fatal error was encoutered: %s (%s) - exiting ...\\n\", evt->message.message ? evt->message.message : \"no details\", gf_error_to_string(evt->message.error) );\n\t\t}\n\t\tRun = 0;\n\t\tbreak;\n\tcase GF_EVENT_DISCONNECT:\n\t\tgf_term_disconnect(term);\n\t\tbreak;\n\tcase GF_EVENT_MIGRATE:\n\t{\n\t}\n\tbreak;\n\tcase GF_EVENT_NAVIGATE_INFO:\n\t\tif (evt->navigate.to_url) fprintf(stderr, \"Go to URL: \\\"%s\\\"\\r\", evt->navigate.to_url);\n\t\tbreak;\n\tcase GF_EVENT_NAVIGATE:\n\t\tif (gf_term_is_supported_url(term, evt->navigate.to_url, 1, no_mime_check)) {\n\t\t\tstrncpy(the_url, evt->navigate.to_url, sizeof(the_url)-1);\n\t\t\tthe_url[sizeof(the_url) - 1] = 0;\n\t\t\tfprintf(stderr, \"Navigating to URL %s\\n\", the_url);\n\t\t\tgf_term_navigate_to(term, evt->navigate.to_url);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tfprintf(stderr, \"Navigation destination not supported\\nGo to URL: %s\\n\", evt->navigate.to_url);\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_SET_CAPTION:\n\t\tgf_term_user_event(term, evt);\n\t\tbreak;\n\tcase GF_EVENT_AUTHORIZATION:\n\t{\n\t\tint maxTries = 1;\n\t\tassert( evt->type == GF_EVENT_AUTHORIZATION);\n\t\tassert( evt->auth.user);\n\t\tassert( evt->auth.password);\n\t\tassert( evt->auth.site_url);\n\t\twhile ((!strlen(evt->auth.user) || !strlen(evt->auth.password)) && (maxTries--) >= 0) {\n\t\t\tfprintf(stderr, \"**** Authorization required for site %s ****\\n\", evt->auth.site_url);\n\t\t\tfprintf(stderr, \"login   : \");\n\t\t\tread_line_input(evt->auth.user, 50, 1);\n\t\t\tfprintf(stderr, \"\\npassword: \");\n\t\t\tread_line_input(evt->auth.password, 50, 0);\n\t\t\tfprintf(stderr, \"*********\\n\");\n\t\t}\n\t\tif (maxTries < 0) {\n\t\t\tfprintf(stderr, \"**** No User or password has been filled, aborting ***\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\tcase GF_EVENT_ADDON_DETECTED:\n\t\tif (enable_add_ons) {\n\t\t\tfprintf(stderr, \"Media Addon %s detected - enabling it\\n\", evt->addon_connect.addon_url);\n\t\t\taddon_visible = 1;\n\t\t}\n\t\treturn enable_add_ons;\n\t}\n\treturn 0;\n}\n\n\nvoid list_modules(GF_ModuleManager *modules)\n{\n\tu32 i;\n\tfprintf(stderr, \"\\rAvailable modules:\\n\");\n\tfor (i=0; i<gf_modules_get_count(modules); i++) {\n\t\tchar *str = (char *) gf_modules_get_file_name(modules, i);\n\t\tif (str) fprintf(stderr, \"\\t%s\\n\", str);\n\t}\n\tfprintf(stderr, \"\\n\");\n}\n\nvoid set_navigation()\n{\n\tGF_Err e;\n\tchar nav;\n\tu32 type = gf_term_get_option(term, GF_OPT_NAVIGATION_TYPE);\n\te = GF_OK;\n\tfflush(stdin);\n\n\tif (!type) {\n\t\tfprintf(stderr, \"Content/compositor doesn't allow user-selectable navigation\\n\");\n\t} else if (type==1) {\n\t\tfprintf(stderr, \"Select Navigation (\\'N\\'one, \\'E\\'xamine, \\'S\\'lide): \");\n\t\tnav = getch();\n\t\tif (nav=='N') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_NONE);\n\t\telse if (nav=='E') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_EXAMINE);\n\t\telse if (nav=='S') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_SLIDE);\n\t\telse fprintf(stderr, \"Unknown selector \\'%c\\' - only \\'N\\',\\'E\\',\\'S\\' allowed\\n\", nav);\n\t} else if (type==2) {\n\t\tfprintf(stderr, \"Select Navigation (\\'N\\'one, \\'W\\'alk, \\'F\\'ly, \\'E\\'xamine, \\'P\\'an, \\'S\\'lide, \\'G\\'ame, \\'V\\'R, \\'O\\'rbit): \");\n\t\tnav = getch();\n\t\tif (nav=='N') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_NONE);\n\t\telse if (nav=='W') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_WALK);\n\t\telse if (nav=='F') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_FLY);\n\t\telse if (nav=='E') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_EXAMINE);\n\t\telse if (nav=='P') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_PAN);\n\t\telse if (nav=='S') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_SLIDE);\n\t\telse if (nav=='G') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_GAME);\n\t\telse if (nav=='O') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_ORBIT);\n\t\telse if (nav=='V') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_VR);\n\t\telse fprintf(stderr, \"Unknown selector %c - only \\'N\\',\\'W\\',\\'F\\',\\'E\\',\\'P\\',\\'S\\',\\'G\\', \\'V\\', \\'O\\' allowed\\n\", nav);\n\t}\n\tif (e) fprintf(stderr, \"Error setting mode: %s\\n\", gf_error_to_string(e));\n}\n\n\nstatic Bool get_time_list(char *arg, u32 *times, u32 *nb_times)\n{\n\tchar *str;\n\tFloat var;\n\tDouble sec;\n\tu32 h, m, s, ms, f, fps;\n\tif (!arg || (arg[0]=='-') || !isdigit(arg[0])) return 0;\n\n\t/*SMPTE time code*/\n\tif (strchr(arg, ':') && strchr(arg, ';') && strchr(arg, '/')) {\n\t\tif (sscanf(arg, \"%02ud:%02ud:%02ud;%02ud/%02ud\", &h, &m, &s, &f, &fps)==5) {\n\t\t\tsec = 0;\n\t\t\tif (fps) sec = ((Double)f) / fps;\n\t\t\tsec += 3600*h + 60*m + s;\n\t\t\ttimes[*nb_times] = (u32) (1000*sec);\n\t\t\t(*nb_times) ++;\n\t\t\treturn 1;\n\t\t}\n\t}\n\twhile (arg) {\n\t\tstr = strchr(arg, '-');\n\t\tif (str) str[0] = 0;\n\t\t/*HH:MM:SS:MS time code*/\n\t\tif (strchr(arg, ':') && (sscanf(arg, \"%u:%u:%u:%u\", &h, &m, &s, &ms)==4)) {\n\t\t\tsec = ms;\n\t\t\tsec /= 1000;\n\t\t\tsec += 3600*h + 60*m + s;\n\t\t\ttimes[*nb_times] = (u32) (1000*sec);\n\t\t\t(*nb_times) ++;\n\t\t} else if (sscanf(arg, \"%f\", &var)==1) {\n\t\t\tsec = atof(arg);\n\t\t\ttimes[*nb_times] = (u32) (1000*sec);\n\t\t\t(*nb_times) ++;\n\t\t}\n\t\tif (!str) break;\n\t\tstr[0] = '-';\n\t\targ = str+1;\n\t}\n\treturn 1;\n}\n\nstatic u64 last_log_time=0;\nstatic void on_gpac_log(void *cbk, GF_LOG_Level ll, GF_LOG_Tool lm, const char *fmt, va_list list)\n{\n\tFILE *logs = cbk ? cbk : stderr;\n\n\tif (rti_logs && (lm & GF_LOG_RTI)) {\n\t\tchar szMsg[2048];\n\t\tvsprintf(szMsg, fmt, list);\n\t\tUpdateRTInfo(szMsg + 6 /*\"[RTI] \"*/);\n\t} else {\n\t\tif (log_time_start) {\n\t\t\tu64 now = gf_sys_clock_high_res();\n\t\t\tfprintf(logs, \"At \"LLD\" (diff %d) - \", now - log_time_start, (u32) (now - last_log_time) );\n\t\t\tlast_log_time = now;\n\t\t}\n\t\tif (log_utc_time) {\n\t\t\tu64 utc_clock = gf_net_get_utc() ;\n\t\t\ttime_t secs = utc_clock/1000;\n\t\t\tstruct tm t;\n\t\t\tt = *gmtime(&secs);\n\t\t\tfprintf(logs, \"UTC %d-%02d-%02dT%02d:%02d:%02dZ (TS \"LLU\") - \", 1900+t.tm_year, t.tm_mon+1, t.tm_mday, t.tm_hour, t.tm_min, t.tm_sec, utc_clock);\n\t\t}\n\t\tvfprintf(logs, fmt, list);\n\t\tfflush(logs);\n\t}\n}\n\nstatic void init_rti_logs(char *rti_file, char *url, Bool use_rtix)\n{\n\tif (rti_logs) gf_fclose(rti_logs);\n\trti_logs = gf_fopen(rti_file, \"wt\");\n\tif (rti_logs) {\n\t\tfprintf(rti_logs, \"!! GPAC RunTime Info \");\n\t\tif (url) fprintf(rti_logs, \"for file %s\", url);\n\t\tfprintf(rti_logs, \" !!\\n\");\n\t\tfprintf(rti_logs, \"SysTime(ms)\\tSceneTime(ms)\\tCPU\\tFPS\\tMemory(kB)\\tObservation\\n\");\n\n\t\t/*turn on RTI loging*/\n\t\tif (use_rtix) {\n\t\t\tgf_log_set_callback(NULL, on_gpac_log);\n\t\t\tgf_log_set_tool_level(GF_LOG_RTI, GF_LOG_DEBUG);\n\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_RTI, (\"[RTI] System state when enabling log\\n\"));\n\t\t} else if (log_time_start) {\n\t\t\tlog_time_start = gf_sys_clock_high_res();\n\t\t}\n\t}\n}\n\nvoid set_cfg_option(char *opt_string)\n{\n\tchar *sep, *sep2, szSec[1024], szKey[1024], szVal[1024];\n\tsep = strchr(opt_string, ':');\n\tif (!sep) {\n\t\tfprintf(stderr, \"Badly formatted option %s - expected Section:Name=Value\\n\", opt_string);\n\t\treturn;\n\t}\n\t{\n\t\tconst size_t sepIdx = sep - opt_string;\n\t\tif (sepIdx >= sizeof(szSec)) {\n\t\t\tfprintf(stderr, \"Badly formatted option %s - Section name is too long\\n\", opt_string);\n\t\t\treturn;\n\t\t}\n\n\t\tstrncpy(szSec, opt_string, sepIdx);\n\t\tszSec[sepIdx] = 0;\n\t}\n\tsep ++;\n\tsep2 = strchr(sep, '=');\n\tif (!sep2) {\n\t\tfprintf(stderr, \"Badly formatted option %s - expected Section:Name=Value\\n\", opt_string);\n\t\treturn;\n\t}\n\t{\n\t\tconst size_t sepIdx = sep2 - sep;\n\t\tif (sepIdx >= sizeof(szKey)) {\n\t\t\tfprintf(stderr, \"Badly formatted option %s - key name is too long\\n\", opt_string);\n\t\t\treturn;\n\t\t}\n\t\tstrncpy(szKey, sep, sepIdx);\n\t\tszKey[sepIdx] = 0;\n\t\tif (strlen(sep2 + 1) >= sizeof(szVal)) {\n\t\t\tfprintf(stderr, \"Badly formatted option %s - value is too long\\n\", opt_string);\n\t\t\treturn;\n\t\t}\n\t\tstrcpy(szVal, sep2+1);\n\t}\n\n\tif (!stricmp(szKey, \"*\")) {\n\t\tif (stricmp(szVal, \"null\")) {\n\t\t\tfprintf(stderr, \"Badly formatted option %s - expected Section:*=null\\n\", opt_string);\n\t\t\treturn;\n\t\t}\n\t\tgf_cfg_del_section(cfg_file, szSec);\n\t\treturn;\n\t}\n\n\tif (!stricmp(szVal, \"null\")) {\n\t\tszVal[0]=0;\n\t}\n\tgf_cfg_set_key(cfg_file, szSec, szKey, szVal[0] ? szVal : NULL);\n}\n\nBool revert_cache_file(void *cbck, char *item_name, char *item_path, GF_FileEnumInfo *file_info)\n{\n\tconst char *url;\n\tchar *sep;\n\tGF_Config *cached;\n\tif (strncmp(item_name, \"gpac_cache_\", 11)) return GF_FALSE;\n\tcached = gf_cfg_new(NULL, item_path);\n\turl = gf_cfg_get_key(cached, \"cache\", \"url\");\n\tif (url) url = strstr(url, \"://\");\n\tif (url) {\n\t\tu32 i, len, dir_len=0, k=0;\n\t\tchar *dst_name;\n\t\tsep = strstr(item_path, \"gpac_cache_\");\n\t\tif (sep) {\n\t\t\tsep[0] = 0;\n\t\t\tdir_len = (u32) strlen(item_path);\n\t\t\tsep[0] = 'g';\n\t\t}\n\t\turl+=3;\n\t\tlen = (u32) strlen(url);\n\t\tdst_name = gf_malloc(len+dir_len+1);\n\t\tmemset(dst_name, 0, len+dir_len+1);\n\n\t\tstrncpy(dst_name, item_path, dir_len);\n\t\tk=dir_len;\n\t\tfor (i=0; i<len; i++) {\n\t\t\tdst_name[k] = url[i];\n\t\t\tif (dst_name[k]==':') dst_name[k]='_';\n\t\t\telse if (dst_name[k]=='/') {\n\t\t\t\tif (!gf_dir_exists(dst_name))\n\t\t\t\t\tgf_mkdir(dst_name);\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\t\tsep = strrchr(item_path, '.');\n\t\tif (sep) {\n\t\t\tsep[0]=0;\n\t\t\tif (gf_file_exists(item_path)) {\n\t\t\t\tgf_move_file(item_path, dst_name);\n\t\t\t}\n\t\t\tsep[0]='.';\n\t\t}\n\t\tgf_free(dst_name);\n\t}\n\tgf_cfg_del(cached);\n\tgf_delete_file(item_path);\n\treturn GF_FALSE;\n}\nvoid do_flatten_cache(const char *cache_dir)\n{\n\tgf_enum_directory(cache_dir, GF_FALSE, revert_cache_file, NULL, \"*.txt\");\n}\n\n\n#ifdef WIN32\n#include <wincon.h>\n#endif\n\nstatic void progress_quiet(const void *cbck, const char *title, u64 done, u64 total) { }\n\nint mp4client_main(int argc, char **argv)\n{\n\tchar c;\n\tconst char *str;\n\tint ret_val = 0;\n\tu32 i, times[100], nb_times, dump_mode;\n\tu32 simulation_time_in_ms = 0;\n\tu32 initial_service_id = 0;\n\tBool auto_exit = GF_FALSE;\n\tBool logs_set = GF_FALSE;\n\tBool start_fs = GF_FALSE;\n\tBool use_rtix = GF_FALSE;\n\tBool pause_at_first = GF_FALSE;\n\tBool no_cfg_save = GF_FALSE;\n\tBool is_cfg_only = GF_FALSE;\n\n\tDouble play_from = 0;\n#ifdef GPAC_MEMORY_TRACKING\n    GF_MemTrackerType mem_track = GF_MemTrackerNone;\n#endif\n\tDouble fps = GF_IMPORT_DEFAULT_FPS;\n\tBool fill_ar, visible, do_uncache, has_command;\n\tchar *url_arg, *out_arg, *the_cfg, *rti_file, *views, *mosaic;\n\tFILE *logfile = NULL;\n\tFloat scale = 1;\n#ifndef WIN32\n\tdlopen(NULL, RTLD_NOW|RTLD_GLOBAL);\n#endif\n\n\t/*by default use current dir*/\n\tstrcpy(the_url, \".\");\n\n\tmemset(&user, 0, sizeof(GF_User));\n\n\tdump_mode = DUMP_NONE;\n\tfill_ar = visible = do_uncache = has_command = GF_FALSE;\n\turl_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL;\n\tnb_times = 0;\n\ttimes[0] = 0;\n\n\t/*first locate config file if specified*/\n\tfor (i=1; i<(u32) argc; i++) {\n\t\tchar *arg = argv[i];\n\t\tif (!strcmp(arg, \"-c\") || !strcmp(arg, \"-cfg\")) {\n\t\t\tthe_cfg = argv[i+1];\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, \"-mem-track\") || !strcmp(arg, \"-mem-track-stack\")) {\n#ifdef GPAC_MEMORY_TRACKING\n            mem_track = !strcmp(arg, \"-mem-track-stack\") ? GF_MemTrackerBackTrace : GF_MemTrackerSimple;\n#else\n\t\t\tfprintf(stderr, \"WARNING - GPAC not compiled with Memory Tracker - ignoring \\\"%s\\\"\\n\", arg);\n#endif\n\t\t} else if (!strcmp(arg, \"-gui\")) {\n\t\t\tgui_mode = 1;\n\t\t} else if (!strcmp(arg, \"-guid\")) {\n\t\t\tgui_mode = 2;\n\t\t} else if (!strcmp(arg, \"-h\") || !strcmp(arg, \"-help\")) {\n\t\t\tPrintUsage();\n\t\t\treturn 0;\n\t\t}\n\t}\n\n#ifdef GPAC_MEMORY_TRACKING\n\tgf_sys_init(mem_track);\n#else\n\tgf_sys_init(GF_MemTrackerNone);\n#endif\n\tgf_sys_set_args(argc, (const char **) argv);\n\n\tcfg_file = gf_cfg_init(the_cfg, NULL);\n\tif (!cfg_file) {\n\t\tfprintf(stderr, \"Error: Configuration File not found\\n\");\n\t\treturn 1;\n\t}\n\t/*if logs are specified, use them*/\n\tif (gf_log_set_tools_levels( gf_cfg_get_key(cfg_file, \"General\", \"Logs\") ) != GF_OK) {\n\t\treturn 1;\n\t}\n\n\tif( gf_cfg_get_key(cfg_file, \"General\", \"Logs\") != NULL ) {\n\t\tlogs_set = GF_TRUE;\n\t}\n\n\tif (!gui_mode) {\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"ForceGUI\");\n\t\tif (str && !strcmp(str, \"yes\")) gui_mode = 1;\n\t}\n\n\tfor (i=1; i<(u32) argc; i++) {\n\t\tchar *arg = argv[i];\n\n\t\tif (!strcmp(arg, \"-rti\")) {\n\t\t\trti_file = argv[i+1];\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-rtix\")) {\n\t\t\trti_file = argv[i+1];\n\t\t\ti++;\n\t\t\tuse_rtix = GF_TRUE;\n\t\t} else if (!stricmp(arg, \"-size\")) {\n\t\t\t/*usage of %ud breaks sscanf on MSVC*/\n\t\t\tif (sscanf(argv[i+1], \"%dx%d\", &forced_width, &forced_height) != 2) {\n\t\t\t\tforced_width = forced_height = 0;\n\t\t\t}\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-quiet\")) {\n\t\t\tbe_quiet = 1;\n\t\t} else if (!strcmp(arg, \"-strict-error\")) {\n\t\t\tgf_log_set_strict_error(1);\n\t\t} else if (!strcmp(arg, \"-log-file\") || !strcmp(arg, \"-lf\")) {\n\t\t\tlogfile = gf_fopen(argv[i+1], \"wt\");\n\t\t\tgf_log_set_callback(logfile, on_gpac_log);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-logs\") ) {\n\t\t\tif (gf_log_set_tools_levels(argv[i+1]) != GF_OK) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tlogs_set = GF_TRUE;\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-log-clock\") || !strcmp(arg, \"-lc\")) {\n\t\t\tlog_time_start = 1;\n\t\t} else if (!strcmp(arg, \"-log-utc\") || !strcmp(arg, \"-lu\")) {\n\t\t\tlog_utc_time = 1;\n\t\t}\n#if defined(__DARWIN__) || defined(__APPLE__)\n\t\telse if (!strcmp(arg, \"-thread\")) threading_flags = 0;\n#else\n\t\telse if (!strcmp(arg, \"-no-thread\")) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD;\n#endif\n\t\telse if (!strcmp(arg, \"-no-cthread\") || !strcmp(arg, \"-no-compositor-thread\")) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD;\n\t\telse if (!strcmp(arg, \"-no-audio\")) no_audio = 1;\n\t\telse if (!strcmp(arg, \"-no-regulation\")) no_regulation = 1;\n\t\telse if (!strcmp(arg, \"-fs\")) start_fs = 1;\n\n\t\telse if (!strcmp(arg, \"-opt\")) {\n\t\t\tset_cfg_option(argv[i+1]);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-conf\")) {\n\t\t\tset_cfg_option(argv[i+1]);\n\t\t\tis_cfg_only=GF_TRUE;\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, \"-ifce\")) {\n\t\t\tgf_cfg_set_key(cfg_file, \"Network\", \"DefaultMCastInterface\", argv[i+1]);\n\t\t\ti++;\n\t\t}\n\t\telse if (!stricmp(arg, \"-help\")) {\n\t\t\tPrintUsage();\n\t\t\treturn 1;\n\t\t}\n\t\telse if (!stricmp(arg, \"-noprog\")) {\n\t\t\tno_prog=1;\n\t\t\tgf_set_progress_callback(NULL, progress_quiet);\n\t\t}\n\t\telse if (!stricmp(arg, \"-no-save\") || !stricmp(arg, \"--no-save\") /*old versions used --n-save ...*/) {\n\t\t\tno_cfg_save=1;\n\t\t}\n\t\telse if (!stricmp(arg, \"-ntp-shift\")) {\n\t\t\ts32 shift = atoi(argv[i+1]);\n\t\t\ti++;\n\t\t\tgf_net_set_ntp_shift(shift);\n\t\t}\n\t\telse if (!stricmp(arg, \"-run-for\")) {\n\t\t\tsimulation_time_in_ms = atoi(argv[i+1]) * 1000;\n\t\t\tif (!simulation_time_in_ms)\n\t\t\t\tsimulation_time_in_ms = 1; /*1ms*/\n\t\t\ti++;\n\t\t}\n\n\t\telse if (!strcmp(arg, \"-out\")) {\n\t\t\tout_arg = argv[i+1];\n\t\t\ti++;\n\t\t}\n\t\telse if (!stricmp(arg, \"-fps\")) {\n\t\t\tfps = atof(argv[i+1]);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-avi\") || !strcmp(arg, \"-sha\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\n\t\t\tif (!strcmp(arg, \"-sha\")) dump_mode |= DUMP_SHA1;\n\t\t\telse dump_mode |= DUMP_AVI;\n\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) {\n\t\t\t\tif (!strcmp(arg, \"-avi\") && (nb_times!=2) ) {\n\t\t\t\t\tfprintf(stderr, \"Only one time arg found for -avi - check usage\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t} else if (!strcmp(arg, \"-rgbds\")) { /*get dump in rgbds pixel format*/\n\t\t\t\tdump_mode |= DUMP_RGB_DEPTH_SHAPE;\n\t\t} else if (!strcmp(arg, \"-rgbd\")) { /*get dump in rgbd pixel format*/\n\t\t\t\tdump_mode |= DUMP_RGB_DEPTH;\n\t\t} else if (!strcmp(arg, \"-depth\")) {\n\t\t\t\tdump_mode |= DUMP_DEPTH_ONLY;\n\t\t} else if (!strcmp(arg, \"-bmp\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_BMP;\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;\n\t\t} else if (!strcmp(arg, \"-png\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_PNG;\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;\n\t\t} else if (!strcmp(arg, \"-raw\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_RAW;\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;\n\t\t} else if (!stricmp(arg, \"-scale\")) {\n\t\t\tsscanf(argv[i+1], \"%f\", &scale);\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, \"-c\") || !strcmp(arg, \"-cfg\")) {\n\t\t\t/* already parsed */\n\t\t\ti++;\n\t\t}\n\n\t\t/*arguments only used in non-gui mode*/\n\t\tif (!gui_mode) {\n\t\t\tif (arg[0] != '-') {\n\t\t\t\tif (url_arg) {\n\t\t\t\t\tfprintf(stderr, \"Several input URLs provided (\\\"%s\\\", \\\"%s\\\"). Check your command-line.\\n\", url_arg, arg);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\turl_arg = arg;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-loop\")) loop_at_end = 1;\n\t\t\telse if (!strcmp(arg, \"-bench\")) bench_mode = 1;\n\t\t\telse if (!strcmp(arg, \"-vbench\")) bench_mode = 2;\n\t\t\telse if (!strcmp(arg, \"-sbench\")) bench_mode = 3;\n\t\t\telse if (!strcmp(arg, \"-no-addon\")) enable_add_ons = GF_FALSE;\n\n\t\t\telse if (!strcmp(arg, \"-pause\")) pause_at_first = 1;\n\t\t\telse if (!strcmp(arg, \"-play-from\")) {\n\t\t\t\tplay_from = atof((const char *) argv[i+1]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-speed\")) {\n\t\t\t\tplayback_speed = FLT2FIX( atof((const char *) argv[i+1]) );\n\t\t\t\tif (playback_speed <= 0) playback_speed = FIX_ONE;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-no-wnd\")) user.init_flags |= GF_TERM_WINDOWLESS;\n\t\t\telse if (!strcmp(arg, \"-no-back\")) user.init_flags |= GF_TERM_WINDOW_TRANSPARENT;\n\t\t\telse if (!strcmp(arg, \"-align\")) {\n\t\t\t\tif (argv[i+1][0]=='m') align_mode = 1;\n\t\t\t\telse if (argv[i+1][0]=='b') align_mode = 2;\n\t\t\t\talign_mode <<= 8;\n\t\t\t\tif (argv[i+1][1]=='m') align_mode |= 1;\n\t\t\t\telse if (argv[i+1][1]=='r') align_mode |= 2;\n\t\t\t\ti++;\n\t\t\t} else if (!strcmp(arg, \"-fill\")) {\n\t\t\t\tfill_ar = GF_TRUE;\n\t\t\t} else if (!strcmp(arg, \"-show\")) {\n\t\t\t\tvisible = 1;\n\t\t\t} else if (!strcmp(arg, \"-uncache\")) {\n\t\t\t\tdo_uncache = GF_TRUE;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-exit\")) auto_exit = GF_TRUE;\n\t\t\telse if (!stricmp(arg, \"-views\")) {\n\t\t\t\tviews = argv[i+1];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, \"-mosaic\")) {\n\t\t\t\tmosaic = argv[i+1];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, \"-com\")) {\n\t\t\t\thas_command = GF_TRUE;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, \"-service\")) {\n\t\t\t\tinitial_service_id = atoi(argv[i+1]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\tif (is_cfg_only) {\n\t\tgf_cfg_del(cfg_file);\n\t\tfprintf(stderr, \"GPAC Config updated\\n\");\n\t\treturn 0;\n\t}\n\tif (do_uncache) {\n\t\tconst char *cache_dir = gf_cfg_get_key(cfg_file, \"General\", \"CacheDirectory\");\n\t\tdo_flatten_cache(cache_dir);\n\t\tfprintf(stderr, \"GPAC Cache dir %s flattened\\n\", cache_dir);\n\t\tgf_cfg_del(cfg_file);\n\t\treturn 0;\n\t}\n\n\tif (dump_mode && !url_arg ) {\n\t\tFILE *test;\n\t\turl_arg = (char *)gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\");\n\t\ttest = url_arg ? gf_fopen(url_arg, \"rt\") : NULL;\n\t\tif (!test) url_arg = NULL;\n\t\telse gf_fclose(test);\n\t\t\n\t\tif (!url_arg) {\n\t\t\tfprintf(stderr, \"Missing argument for dump\\n\");\n\t\t\tPrintUsage();\n\t\t\tif (logfile) gf_fclose(logfile);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (!gui_mode && !url_arg && (gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\") != NULL)) {\n\t\tgui_mode=1;\n\t}\n\n#ifdef WIN32\n\tif (gui_mode==1) {\n\t\tconst char *opt;\n\t\tTCHAR buffer[1024];\n\t\tDWORD res = GetCurrentDirectory(1024, buffer);\n\t\tbuffer[res] = 0;\n\t\topt = gf_cfg_get_key(cfg_file, \"General\", \"ModulesDirectory\");\n\t\tif (strstr(opt, buffer)) {\n\t\t\tgui_mode=1;\n\t\t} else {\n\t\t\tgui_mode=2;\n\t\t}\n\t}\n#endif\n\n\tif (gui_mode==1) {\n\t\thide_shell(1);\n\t}\n\tif (gui_mode) {\n\t\tno_prog=1;\n\t\tgf_set_progress_callback(NULL, progress_quiet);\n\t}\n\n\tif (!url_arg && simulation_time_in_ms)\n\t\tsimulation_time_in_ms += gf_sys_clock();\n\n#if defined(__DARWIN__) || defined(__APPLE__)\n\tcarbon_init();\n#endif\n\n\n\tif (dump_mode) rti_file = NULL;\n\n\tif (!logs_set) {\n\t\tgf_log_set_tool_level(GF_LOG_ALL, GF_LOG_WARNING);\n\t}\n\t//only override default log callback when needed\n\tif (rti_file || logfile || log_utc_time || log_time_start)\n\t\tgf_log_set_callback(NULL, on_gpac_log);\n\n\tif (rti_file) init_rti_logs(rti_file, url_arg, use_rtix);\n\n\t{\n\t\tGF_SystemRTInfo rti;\n\t\tif (gf_sys_get_rti(0, &rti, 0))\n\t\t\tfprintf(stderr, \"System info: %d MB RAM - %d cores\\n\", (u32) (rti.physical_memory/1024/1024), rti.nb_cores);\n\t}\n\n\n\t/*setup dumping options*/\n\tif (dump_mode) {\n\t\tuser.init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION;\n\t\tif (!visible)\n\t\t\tuser.init_flags |= GF_TERM_INIT_HIDE;\n\n\t\tgf_cfg_set_key(cfg_file, \"Audio\", \"DriverName\", \"Raw Audio Output\");\n\t\tno_cfg_save=GF_TRUE;\n\t} else {\n\t\tinit_w = forced_width;\n\t\tinit_h = forced_height;\n\t}\n\n\tuser.modules = gf_modules_new(NULL, cfg_file);\n\tif (user.modules) i = gf_modules_get_count(user.modules);\n\tif (!i || !user.modules) {\n\t\tfprintf(stderr, \"Error: no modules found - exiting\\n\");\n\t\tif (user.modules) gf_modules_del(user.modules);\n\t\tgf_cfg_del(cfg_file);\n\t\tgf_sys_close();\n\t\tif (logfile) gf_fclose(logfile);\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"Modules Found : %d \\n\", i);\n\n\tstr = gf_cfg_get_key(cfg_file, \"General\", \"GPACVersion\");\n\tif (!str || strcmp(str, GPAC_FULL_VERSION)) {\n\t\tgf_cfg_del_section(cfg_file, \"PluginsCache\");\n\t\tgf_cfg_set_key(cfg_file, \"General\", \"GPACVersion\", GPAC_FULL_VERSION);\n\t}\n\n\tuser.config = cfg_file;\n\tuser.EventProc = GPAC_EventProc;\n\t/*dummy in this case (global vars) but MUST be non-NULL*/\n\tuser.opaque = user.modules;\n\tif (threading_flags) user.init_flags |= threading_flags;\n\tif (no_audio) user.init_flags |= GF_TERM_NO_AUDIO;\n\tif (no_regulation) user.init_flags |= GF_TERM_NO_REGULATION;\n\n\tif (threading_flags & (GF_TERM_NO_DECODER_THREAD|GF_TERM_NO_COMPOSITOR_THREAD) ) term_step = GF_TRUE;\n\n\t//in dump mode we don't want to rely on system clock but on the number of samples being consumed\n\tif (dump_mode) user.init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK;\n\n\tif (bench_mode) {\n\t\tgf_cfg_discard_changes(user.config);\n\t\tauto_exit = GF_TRUE;\n\t\tgf_cfg_set_key(user.config, \"Audio\", \"DriverName\", \"Raw Audio Output\");\n\t\tif (bench_mode!=2) {\n\t\t\tgf_cfg_set_key(user.config, \"Video\", \"DriverName\", \"Raw Video Output\");\n\t\t\tgf_cfg_set_key(user.config, \"RAWVideo\", \"RawOutput\", \"null\");\n\t\t\tgf_cfg_set_key(user.config, \"Compositor\", \"OpenGLMode\", \"disable\");\n\t\t} else {\n\t\t\tgf_cfg_set_key(user.config, \"Video\", \"DisableVSync\", \"yes\");\n\t\t}\n\t}\n\n\t{\n\t\tchar dim[50];\n\t\tsprintf(dim, \"%d\", forced_width);\n\t\tgf_cfg_set_key(user.config, \"Compositor\", \"DefaultWidth\", forced_width ? dim : NULL);\n\t\tsprintf(dim, \"%d\", forced_height);\n\t\tgf_cfg_set_key(user.config, \"Compositor\", \"DefaultHeight\", forced_height ? dim : NULL);\n\t}\n\n\tfprintf(stderr, \"Loading GPAC Terminal\\n\");\n\ti = gf_sys_clock();\n\tterm = gf_term_new(&user);\n\tif (!term) {\n\t\tfprintf(stderr, \"\\nInit error - check you have at least one video out and one rasterizer...\\nFound modules:\\n\");\n\t\tlist_modules(user.modules);\n\t\tgf_modules_del(user.modules);\n\t\tgf_cfg_discard_changes(cfg_file);\n\t\tgf_cfg_del(cfg_file);\n\t\tgf_sys_close();\n\t\tif (logfile) gf_fclose(logfile);\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"Terminal Loaded in %d ms\\n\", gf_sys_clock()-i);\n\n\tif (bench_mode) {\n\t\tdisplay_rti = 2;\n\t\tgf_term_set_option(term, GF_OPT_VIDEO_BENCH, (bench_mode==3) ? 2 : 1);\n\t\tif (bench_mode==1) bench_mode=2;\n\t}\n\n\tif (dump_mode) {\n//\t\tgf_term_set_option(term, GF_OPT_VISIBLE, 0);\n\t\tif (fill_ar) gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t} else {\n\t\t/*check video output*/\n\t\tstr = gf_cfg_get_key(cfg_file, \"Video\", \"DriverName\");\n\t\tif (!bench_mode && !strcmp(str, \"Raw Video Output\")) fprintf(stderr, \"WARNING: using raw output video (memory only) - no display used\\n\");\n\t\t/*check audio output*/\n\t\tstr = gf_cfg_get_key(cfg_file, \"Audio\", \"DriverName\");\n\t\tif (!str || !strcmp(str, \"No Audio Output Available\")) fprintf(stderr, \"WARNING: no audio output available - make sure no other program is locking the sound card\\n\");\n\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"NoMIMETypeFetch\");\n\t\tno_mime_check = (str && !stricmp(str, \"yes\")) ? 1 : 0;\n\t}\n\n\tstr = gf_cfg_get_key(cfg_file, \"HTTPProxy\", \"Enabled\");\n\tif (str && !strcmp(str, \"yes\")) {\n\t\tstr = gf_cfg_get_key(cfg_file, \"HTTPProxy\", \"Name\");\n\t\tif (str) fprintf(stderr, \"HTTP Proxy %s enabled\\n\", str);\n\t}\n\n\tif (rti_file) {\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"RTIRefreshPeriod\");\n\t\tif (str) {\n\t\t\trti_update_time_ms = atoi(str);\n\t\t} else {\n\t\t\tgf_cfg_set_key(cfg_file, \"General\", \"RTIRefreshPeriod\", \"200\");\n\t\t}\n\t\tUpdateRTInfo(\"At GPAC load time\\n\");\n\t}\n\n\tRun = 1;\n\n\tif (dump_mode) {\n\t\tif (!nb_times) {\n\t\t\ttimes[0] = 0;\n\t\t\tnb_times++;\n\t\t}\n\t\tret_val = dump_file(url_arg, out_arg, dump_mode, fps, forced_width, forced_height, scale, times, nb_times);\n\t\tRun = 0;\n\t}\n\telse if (views) {\n\t}\n\t/*connect if requested*/\n\telse if (!gui_mode && url_arg) {\n\t\tchar *ext;\n\n\t\tif (strlen(url_arg) >= sizeof(the_url)) {\n\t\t\tfprintf(stderr, \"Input url %s is too long, truncating to %d chars.\\n\", url_arg, (int)(sizeof(the_url) - 1));\n\t\t\tstrncpy(the_url, url_arg, sizeof(the_url)-1);\n\t\t\tthe_url[sizeof(the_url) - 1] = 0;\n\t\t}\n\t\telse {\n\t\t\tstrcpy(the_url, url_arg);\n\t\t}\n\t\text = strrchr(the_url, '.');\n\t\tif (ext && (!stricmp(ext, \".m3u\") || !stricmp(ext, \".pls\"))) {\n\t\t\tGF_Err e = GF_OK;\n\t\t\tfprintf(stderr, \"Opening Playlist %s\\n\", the_url);\n\n\t\t\tstrcpy(pl_path, the_url);\n\t\t\t/*this is not clean, we need to have a plugin handle playlist for ourselves*/\n\t\t\tif (!strncmp(\"http:\", the_url, 5)) {\n\t\t\t\tGF_DownloadSession *sess = gf_dm_sess_new(term->downloader, the_url, GF_NETIO_SESSION_NOT_THREADED, NULL, NULL, &e);\n\t\t\t\tif (sess) {\n\t\t\t\t\te = gf_dm_sess_process(sess);\n\t\t\t\t\tif (!e) {\n\t\t\t\t\t\tstrncpy(the_url, gf_dm_sess_get_cache_name(sess), sizeof(the_url) - 1);\n\t\t\t\t\t\tthe_url[sizeof(the_cfg) - 1] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tgf_dm_sess_del(sess);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplaylist = e ? NULL : gf_fopen(the_url, \"rt\");\n\t\t\treadonly_playlist = 1;\n\t\t\tif (playlist) {\n\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tif (e)\n\t\t\t\t\tfprintf(stderr, \"Failed to open playlist %s: %s\\n\", the_url, gf_error_to_string(e) );\n\t\t\t\tfprintf(stderr, \"Hit 'h' for help\\n\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\tif (pause_at_first) fprintf(stderr, \"[Status: Paused]\\n\");\n\t\t\tgf_term_connect_from_time(term, the_url, (u64) (play_from*1000), pause_at_first);\n\t\t}\n\t} else {\n\t\tfprintf(stderr, \"Hit 'h' for help\\n\\n\");\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\");\n\t\tif (str) {\n\t\t\tstrncpy(the_url, \"MP4Client \"GPAC_FULL_VERSION , sizeof(the_url)-1);\n\t\t\tthe_url[sizeof(the_url) - 1] = 0;\n\t\t\tgf_term_connect(term, str);\n\t\t\tstartup_file = 1;\n\t\t\tis_connected = 1;\n\t\t}\n\t}\n\tif (gui_mode==2) gui_mode=0;\n\n\tif (start_fs) gf_term_set_option(term, GF_OPT_FULLSCREEN, 1);\n\n\tif (views) {\n\t\tchar szTemp[4046];\n\t\tsprintf(szTemp, \"views://%s\", views);\n\t\tgf_term_connect(term, szTemp);\n\t}\n\tif (mosaic) {\n\t\tchar szTemp[4046];\n\t\tsprintf(szTemp, \"mosaic://%s\", mosaic);\n\t\tgf_term_connect(term, szTemp);\n\t}\n\tif (bench_mode) {\n\t\trti_update_time_ms = 500;\n\t\tbench_mode_start = gf_sys_clock();\n\t}\n\n\n\twhile (Run) {\n\n\t\t/*we don't want getchar to block*/\n\t\tif ((gui_mode==1) || !gf_prompt_has_input()) {\n\t\t\tif (reload) {\n\t\t\t\treload = 0;\n\t\t\t\tgf_term_disconnect(term);\n\t\t\t\tgf_term_connect(term, startup_file ? gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\") : the_url);\n\t\t\t}\n\t\t\tif (restart && gf_term_get_option(term, GF_OPT_IS_OVER)) {\n\t\t\t\trestart = 0;\n\t\t\t\tgf_term_play_from_time(term, 0, 0);\n\t\t\t}\n\t\t\tif (request_next_playlist_item) {\n\t\t\t\tc = '\\n';\n\t\t\t\trequest_next_playlist_item = 0;\n\t\t\t\tgoto force_input;\n\t\t\t}\n\n\t\t\tif (has_command && is_connected) {\n\t\t\t\thas_command = GF_FALSE;\n\t\t\t\tfor (i=0; i<(u32)argc; i++) {\n\t\t\t\t\tif (!strcmp(argv[i], \"-com\")) {\n\t\t\t\t\t\tgf_term_scene_update(term, NULL, argv[i+1]);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (initial_service_id && is_connected) {\n\t\t\t\tGF_ObjectManager *root_od = gf_term_get_root_object(term);\n\t\t\t\tif (root_od) {\n\t\t\t\t\tgf_term_select_service(term, root_od, initial_service_id);\n\t\t\t\t\tinitial_service_id = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!use_rtix || display_rti) UpdateRTInfo(NULL);\n\t\t\tif (term_step) {\n\t\t\t\tgf_term_process_step(term);\n\t\t\t} else {\n\t\t\t\tgf_sleep(rti_update_time_ms);\n\t\t\t}\n\t\t\tif (auto_exit && eos_seen && gf_term_get_option(term, GF_OPT_IS_OVER)) {\n\t\t\t\tRun = GF_FALSE;\n\t\t\t}\n\n\t\t\t/*sim time*/\n\t\t\tif (simulation_time_in_ms\n\t\t\t        && ( (gf_term_get_elapsed_time_in_ms(term)>simulation_time_in_ms) || (!url_arg && gf_sys_clock()>simulation_time_in_ms))\n\t\t\t   ) {\n\t\t\t\tRun = GF_FALSE;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tc = gf_prompt_get_char();\n\nforce_input:\n\t\tswitch (c) {\n\t\tcase 'q':\n\t\t{\n\t\t\tGF_Event evt;\n\t\t\tmemset(&evt, 0, sizeof(GF_Event));\n\t\t\tevt.type = GF_EVENT_QUIT;\n\t\t\tgf_term_send_event(term, &evt);\n\t\t}\n//\t\t\tRun = 0;\n\t\tbreak;\n\t\tcase 'X':\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tstartup_file = 0;\n\t\t\tgf_term_disconnect(term);\n\t\t\tfprintf(stderr, \"Enter the absolute URL\\n\");\n\t\t\tif (1 > scanf(\"%s\", the_url)) {\n\t\t\t\tfprintf(stderr, \"Cannot read absolute URL, aborting\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (rti_file) init_rti_logs(rti_file, the_url, use_rtix);\n\t\t\tgf_term_connect(term, the_url);\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tgf_term_disconnect(term);\n\t\t\tfprintf(stderr, \"Enter the absolute URL to the playlist\\n\");\n\t\t\tif (1 > scanf(\"%s\", the_url)) {\n\t\t\t\tfprintf(stderr, \"Cannot read the absolute URL, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tplaylist = gf_fopen(the_url, \"rt\");\n\t\t\tif (playlist) {\n\t\t\t\tif (1 >\tfscanf(playlist, \"%s\", the_url)) {\n\t\t\t\t\tfprintf(stderr, \"Cannot read any URL from playlist, aborting.\\n\");\n\t\t\t\t\tgf_fclose( playlist);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\t\tgf_term_connect(term, the_url);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\n':\n\t\tcase 'N':\n\t\t\tif (playlist) {\n\t\t\t\tint res;\n\t\t\t\tgf_term_disconnect(term);\n\n\t\t\t\tres = fscanf(playlist, \"%s\", the_url);\n\t\t\t\tif ((res == EOF) && loop_at_end) {\n\t\t\t\t\tfseek(playlist, 0, SEEK_SET);\n\t\t\t\t\tres = fscanf(playlist, \"%s\", the_url);\n\t\t\t\t}\n\t\t\t\tif (res == EOF) {\n\t\t\t\t\tfprintf(stderr, \"No more items - exiting\\n\");\n\t\t\t\t\tRun = 0;\n\t\t\t\t} else if (the_url[0] == '#') {\n\t\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\t\t\tgf_term_connect_with_path(term, the_url, pl_path);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tif (playlist) {\n\t\t\t\tu32 count;\n\t\t\t\tgf_term_disconnect(term);\n\t\t\t\tif (1 > scanf(\"%u\", &count)) {\n\t\t\t\t\tfprintf(stderr, \"Cannot read number, aborting.\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twhile (count) {\n\t\t\t\t\tif (fscanf(playlist, \"%s\", the_url)) {\n\t\t\t\t\t\tfprintf(stderr, \"Failed to read line, aborting\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcount--;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\t\tgf_term_connect(term, the_url);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (is_connected)\n\t\t\t\treload = 1;\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tif (is_connected) gf_term_disconnect(term);\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\t\tif (is_connected) {\n\t\t\t\tBool is_pause = gf_term_get_option(term, GF_OPT_PLAY_STATE);\n\t\t\t\tfprintf(stderr, \"[Status: %s]\\n\", is_pause ? \"Playing\" : \"Paused\");\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (is_connected) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);\n\t\t\t\tfprintf(stderr, \"Step time: \");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'z':\n\t\tcase 'T':\n\t\t\tif (!CanSeek || (Duration<=2000)) {\n\t\t\t\tfprintf(stderr, \"scene not seekable\\n\");\n\t\t\t} else {\n\t\t\t\tDouble res;\n\t\t\t\ts32 seekTo;\n\t\t\t\tfprintf(stderr, \"Duration: \");\n\t\t\t\tPrintTime(Duration);\n\t\t\t\tres = gf_term_get_time_in_ms(term);\n\t\t\t\tif (c=='z') {\n\t\t\t\t\tres *= 100;\n\t\t\t\t\tres /= (s64)Duration;\n\t\t\t\t\tfprintf(stderr, \" (current %.2f %%)\\nEnter Seek percentage:\\n\", res);\n\t\t\t\t\tif (scanf(\"%d\", &seekTo) == 1) {\n\t\t\t\t\t\tif (seekTo > 100) seekTo = 100;\n\t\t\t\t\t\tres = (Double)(s64)Duration;\n\t\t\t\t\t\tres /= 100;\n\t\t\t\t\t\tres *= seekTo;\n\t\t\t\t\t\tgf_term_play_from_time(term, (u64) (s64) res, 0);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tu32 r, h, m, s;\n\t\t\t\t\tfprintf(stderr, \" - Current Time: \");\n\t\t\t\t\tPrintTime((u64) res);\n\t\t\t\t\tfprintf(stderr, \"\\nEnter seek time (Format: s, m:s or h:m:s):\\n\");\n\t\t\t\t\th = m = s = 0;\n\t\t\t\t\tr =scanf(\"%d:%d:%d\", &h, &m, &s);\n\t\t\t\t\tif (r==2) {\n\t\t\t\t\t\ts = m;\n\t\t\t\t\t\tm = h;\n\t\t\t\t\t\th = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (r==1) {\n\t\t\t\t\t\ts = h;\n\t\t\t\t\t\tm = h = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (r && (r<=3)) {\n\t\t\t\t\t\tu64 time = h*3600 + m*60 + s;\n\t\t\t\t\t\tgf_term_play_from_time(term, time*1000, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t{\n\t\t\tif (is_connected) {\n\t\t\t\tfprintf(stderr, \"Current Time: \");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, \" - Duration: \");\n\t\t\t\tPrintTime(Duration);\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase 'w':\n\t\t\tif (is_connected) PrintWorldInfo(term);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tif (is_connected) PrintODList(term, NULL, 0, 0, \"Root\");\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tif (is_connected) {\n\t\t\t\tu32 ID;\n\t\t\t\tfprintf(stderr, \"Enter OD ID (0 for main OD): \");\n\t\t\t\tfflush(stderr);\n\t\t\t\tif (scanf(\"%ud\", &ID) == 1) {\n\t\t\t\t\tViewOD(term, ID, (u32)-1, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tchar str_url[GF_MAX_PATH];\n\t\t\t\t\tif (scanf(\"%s\", str_url) == 1)\n\t\t\t\t\t\tViewOD(term, 0, (u32)-1, str_url);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'j':\n\t\t\tif (is_connected) {\n\t\t\t\tu32 num;\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, \"Enter OD number (0 for main OD): \");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 > scanf(\"%ud\", &num));\n\t\t\t\tViewOD(term, (u32)-1, num, NULL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tif (is_connected) ViewODs(term, 1);\n\t\t\tbreak;\n\n\t\tcase 'm':\n\t\t\tif (is_connected) ViewODs(term, 0);\n\t\t\tbreak;\n\n\t\tcase 'l':\n\t\t\tlist_modules(user.modules);\n\t\t\tbreak;\n\n\t\tcase 'n':\n\t\t\tif (is_connected) set_navigation();\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tif (is_connected) gf_term_set_option(term, GF_OPT_NAVIGATION_TYPE, 0);\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\tif (is_connected) {\n\t\t\t\tGF_ObjectManager *odm = NULL;\n\t\t\t\tchar radname[GF_MAX_PATH], *sExt;\n\t\t\t\tGF_Err e;\n\t\t\t\tu32 i, count, odid;\n\t\t\t\tBool xml_dump, std_out;\n\t\t\t\tradname[0] = 0;\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, \"Enter Inline OD ID if any or 0 : \");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 >  scanf(\"%ud\", &odid));\n\t\t\t\tif (odid) {\n\t\t\t\t\tGF_ObjectManager *root_odm = gf_term_get_root_object(term);\n\t\t\t\t\tif (!root_odm) break;\n\t\t\t\t\tcount = gf_term_get_object_count(term, root_odm);\n\t\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\t\tGF_MediaInfo info;\n\t\t\t\t\t\todm = gf_term_get_object(term, root_odm, i);\n\t\t\t\t\t\tif (gf_term_get_object_info(term, odm, &info) == GF_OK) {\n\t\t\t\t\t\t\tif (info.od->objectDescriptorID==odid) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\todm = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, \"Enter file radical name (+\\'.x\\' for XML dumping) - \\\"std\\\" for stderr: \");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 > scanf(\"%s\", radname));\n\t\t\t\tsExt = strrchr(radname, '.');\n\t\t\t\txml_dump = 0;\n\t\t\t\tif (sExt) {\n\t\t\t\t\tif (!stricmp(sExt, \".x\")) xml_dump = 1;\n\t\t\t\t\tsExt[0] = 0;\n\t\t\t\t}\n\t\t\t\tstd_out = strnicmp(radname, \"std\", 3) ? 0 : 1;\n\t\t\t\te = gf_term_dump_scene(term, std_out ? NULL : radname, NULL, xml_dump, 0, odm);\n\t\t\t\tfprintf(stderr, \"Dump done (%s)\\n\", gf_error_to_string(e));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'c':\n\t\t\tPrintGPACConfig();\n\t\t\tbreak;\n\t\tcase '3':\n\t\t{\n\t\t\tBool use_3d = !gf_term_get_option(term, GF_OPT_USE_OPENGL);\n\t\t\tif (gf_term_set_option(term, GF_OPT_USE_OPENGL, use_3d)==GF_OK) {\n\t\t\t\tfprintf(stderr, \"Using %s for 2D drawing\\n\", use_3d ? \"OpenGL\" : \"2D rasterizer\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase 'k':\n\t\t{\n\t\t\tBool opt = gf_term_get_option(term, GF_OPT_STRESS_MODE);\n\t\t\topt = !opt;\n\t\t\tfprintf(stderr, \"Turning stress mode %s\\n\", opt ? \"on\" : \"off\");\n\t\t\tgf_term_set_option(term, GF_OPT_STRESS_MODE, opt);\n\t\t}\n\t\tbreak;\n\t\tcase '4':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);\n\t\t\tbreak;\n\t\tcase '5':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t\t\tbreak;\n\t\tcase '7':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);\n\t\t\tbreak;\n\n\t\tcase 'C':\n\t\t\tswitch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {\n\t\t\tcase GF_MEDIA_CACHE_DISABLED:\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_ENABLED);\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_ENABLED:\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_DISABLED);\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_RUNNING:\n\t\t\t\tfprintf(stderr, \"Streaming Cache is running - please stop it first\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {\n\t\t\tcase GF_MEDIA_CACHE_ENABLED:\n\t\t\t\tfprintf(stderr, \"Streaming Cache Enabled\\n\");\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_DISABLED:\n\t\t\t\tfprintf(stderr, \"Streaming Cache Disabled\\n\");\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_RUNNING:\n\t\t\t\tfprintf(stderr, \"Streaming Cache Running\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'S':\n\t\tcase 'A':\n\t\t\tif (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)==GF_MEDIA_CACHE_RUNNING) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, (c=='S') ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD);\n\t\t\t\tfprintf(stderr, \"Streaming Cache stopped\\n\");\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Streaming Cache not running\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tdisplay_rti = !display_rti;\n\t\t\tResetCaption();\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tif (display_rti) display_rti = 0;\n\t\t\telse display_rti = 2;\n\t\t\tResetCaption();\n\t\t\tbreak;\n\n\t\tcase 'u':\n\t\t{\n\t\t\tGF_Err e;\n\t\t\tchar szCom[8192];\n\t\t\tfprintf(stderr, \"Enter command to send:\\n\");\n\t\t\tfflush(stdin);\n\t\t\tszCom[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", szCom)) {\n\t\t\t\tfprintf(stderr, \"Cannot read command to send, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\te = gf_term_scene_update(term, NULL, szCom);\n\t\t\tif (e) fprintf(stderr, \"Processing command failed: %s\\n\", gf_error_to_string(e));\n\t\t}\n\t\tbreak;\n\t\tcase 'e':\n\t\t{\n\t\t\tGF_Err e;\n\t\t\tchar jsCode[8192];\n\t\t\tfprintf(stderr, \"Enter JavaScript code to evaluate:\\n\");\n\t\t\tfflush(stdin);\n\t\t\tjsCode[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", jsCode)) {\n\t\t\t\tfprintf(stderr, \"Cannot read code to evaluate, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\te = gf_term_scene_update(term, \"application/ecmascript\", jsCode);\n\t\t\tif (e) fprintf(stderr, \"Processing JS code failed: %s\\n\", gf_error_to_string(e));\n\t\t}\n\t\tbreak;\n\n\t\tcase 'L':\n\t\t{\n\t\t\tchar szLog[1024], *cur_logs;\n\t\t\tcur_logs = gf_log_get_tools_levels();\n\t\t\tfprintf(stderr, \"Enter new log level (current tools %s):\\n\", cur_logs);\n\t\t\tgf_free(cur_logs);\n\t\t\tif (scanf(\"%s\", szLog) < 1) {\n\t\t\t\tfprintf(stderr, \"Cannot read new log level, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgf_log_modify_tools_levels(szLog);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'g':\n\t\t{\n\t\t\tGF_SystemRTInfo rti;\n\t\t\tgf_sys_get_rti(rti_update_time_ms, &rti, 0);\n\t\t\tfprintf(stderr, \"GPAC allocated memory \"LLD\"\\n\", rti.gpac_memory);\n\t\t}\n\t\tbreak;\n\t\tcase 'M':\n\t\t{\n\t\t\tu32 size;\n\t\t\tdo {\n\t\t\t\tfprintf(stderr, \"Enter new video cache memory in kBytes (current %ud):\\n\", gf_term_get_option(term, GF_OPT_VIDEO_CACHE_SIZE));\n\t\t\t} while (1 > scanf(\"%ud\", &size));\n\t\t\tgf_term_set_option(term, GF_OPT_VIDEO_CACHE_SIZE, size);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'H':\n\t\t{\n\t\t\tu32 http_bitrate = gf_term_get_option(term, GF_OPT_HTTP_MAX_RATE);\n\t\t\tdo {\n\t\t\t\tfprintf(stderr, \"Enter new http bitrate in bps (0 for none) - current limit: %d\\n\", http_bitrate);\n\t\t\t} while (1 > scanf(\"%ud\", &http_bitrate));\n\n\t\t\tgf_term_set_option(term, GF_OPT_HTTP_MAX_RATE, http_bitrate);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'E':\n\t\t\tgf_term_set_option(term, GF_OPT_RELOAD_CONFIG, 1);\n\t\t\tbreak;\n\n\t\tcase 'B':\n\t\t\tswitch_bench(!bench_mode);\n\t\t\tbreak;\n\n\t\tcase 'Y':\n\t\t{\n\t\t\tchar szOpt[8192];\n\t\t\tfprintf(stderr, \"Enter option to set (Section:Name=Value):\\n\");\n\t\t\tfflush(stdin);\n\t\t\tszOpt[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", szOpt)) {\n\t\t\t\tfprintf(stderr, \"Cannot read option\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_cfg_option(szOpt);\n\t\t}\n\t\tbreak;\n\n\t\t/*extract to PNG*/\n\t\tcase 'Z':\n\t\t{\n\t\t\tchar szFileName[100];\n\t\t\tu32 nb_pass, nb_views, offscreen_view = 0;\n\t\t\tGF_VideoSurface fb;\n\t\t\tGF_Err e;\n\t\t\tnb_pass = 1;\n\t\t\tnb_views = gf_term_get_option(term, GF_OPT_NUM_STEREO_VIEWS);\n\t\t\tif (nb_views>1) {\n\t\t\t\tfprintf(stderr, \"Auto-stereo mode detected - type number of view to dump (0 is main output, 1 to %d offscreen view, %d for all offscreen, %d for all offscreen and main)\\n\", nb_views, nb_views+1, nb_views+2);\n\t\t\t\tif (scanf(\"%d\", &offscreen_view) != 1) {\n\t\t\t\t\toffscreen_view = 0;\n\t\t\t\t}\n\t\t\t\tif (offscreen_view==nb_views+1) {\n\t\t\t\t\toffscreen_view = 1;\n\t\t\t\t\tnb_pass = nb_views;\n\t\t\t\t}\n\t\t\t\telse if (offscreen_view==nb_views+2) {\n\t\t\t\t\toffscreen_view = 0;\n\t\t\t\t\tnb_pass = nb_views+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (nb_pass) {\n\t\t\t\tnb_pass--;\n\t\t\t\tif (offscreen_view) {\n\t\t\t\t\tsprintf(szFileName, \"view%d_dump.png\", offscreen_view);\n\t\t\t\t\te = gf_term_get_offscreen_buffer(term, &fb, offscreen_view-1, 0);\n\t\t\t\t} else {\n\t\t\t\t\tsprintf(szFileName, \"gpac_video_dump_\"LLU\".png\", gf_net_get_utc() );\n\t\t\t\t\te = gf_term_get_screen_buffer(term, &fb);\n\t\t\t\t}\n\t\t\t\toffscreen_view++;\n\t\t\t\tif (e) {\n\t\t\t\t\tfprintf(stderr, \"Error dumping screen buffer %s\\n\", gf_error_to_string(e) );\n\t\t\t\t\tnb_pass = 0;\n\t\t\t\t} else {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tu32 dst_size = fb.width*fb.height*4;\n\t\t\t\t\tchar *dst = (char*)gf_malloc(sizeof(char)*dst_size);\n\n\t\t\t\t\te = gf_img_png_enc(fb.video_buffer, fb.width, fb.height, fb.pitch_y, fb.pixel_format, dst, &dst_size);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tfprintf(stderr, \"Error encoding PNG %s\\n\", gf_error_to_string(e) );\n\t\t\t\t\t\tnb_pass = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tFILE *png = gf_fopen(szFileName, \"wb\");\n\t\t\t\t\t\tif (!png) {\n\t\t\t\t\t\t\tfprintf(stderr, \"Error writing file %s\\n\", szFileName);\n\t\t\t\t\t\t\tnb_pass = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_fwrite(dst, dst_size, 1, png);\n\t\t\t\t\t\t\tgf_fclose(png);\n\t\t\t\t\t\t\tfprintf(stderr, \"Dump to %s\\n\", szFileName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (dst) gf_free(dst);\n\t\t\t\t\tgf_term_release_screen_buffer(term, &fb);\n#endif //GPAC_DISABLE_AV_PARSERS\n\t\t\t\t}\n\t\t\t}\n\t\t\tfprintf(stderr, \"Done: %s\\n\", szFileName);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'G':\n\t\t{\n\t\t\tGF_ObjectManager *root_od, *odm;\n\t\t\tu32 index;\n\t\t\tchar szOpt[8192];\n\t\t\tfprintf(stderr, \"Enter 0-based index of object to select or service ID:\\n\");\n\t\t\tfflush(stdin);\n\t\t\tszOpt[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", szOpt)) {\n\t\t\t\tfprintf(stderr, \"Cannot read OD ID\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex = atoi(szOpt);\n\t\t\todm = NULL;\n\t\t\troot_od = gf_term_get_root_object(term);\n\t\t\tif (root_od) {\n\t\t\t\tif ( gf_term_find_service(term, root_od, index)) {\n\t\t\t\t\tgf_term_select_service(term, root_od, index);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Cannot find service %d - trying with object index\\n\", index);\n\t\t\t\t\todm = gf_term_get_object(term, root_od, index);\n\t\t\t\t\tif (odm) {\n\t\t\t\t\t\tgf_term_select_object(term, odm);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfprintf(stderr, \"Cannot find object at index %d\\n\", index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase 'h':\n\t\t\tPrintHelp();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (bench_mode) {\n\t\tPrintAVInfo(GF_TRUE);\n\t}\n\n\t/*FIXME: we have an issue in cleaning up after playing in bench mode and run-for 0 (buildbot tests). We for now disable error checks after run-for is done*/\n\tif (simulation_time_in_ms) {\n\t\tgf_log_set_strict_error(0);\n\t}\n\n\n\ti = gf_sys_clock();\n\tgf_term_disconnect(term);\n\tif (rti_file) UpdateRTInfo(\"Disconnected\\n\");\n\n\tfprintf(stderr, \"Deleting terminal... \");\n\tif (playlist) gf_fclose(playlist);\n\n#if defined(__DARWIN__) || defined(__APPLE__)\n\tcarbon_uninit();\n#endif\n\n\tgf_term_del(term);\n\tfprintf(stderr, \"done (in %d ms) - ran for %d ms\\n\", gf_sys_clock() - i, gf_sys_clock());\n\n\tfprintf(stderr, \"GPAC cleanup ...\\n\");\n\tgf_modules_del(user.modules);\n\n\tif (no_cfg_save)\n\t\tgf_cfg_discard_changes(cfg_file);\n\n\tgf_cfg_del(cfg_file);\n\n\tgf_sys_close();\n\n\tif (rti_logs) gf_fclose(rti_logs);\n\tif (logfile) gf_fclose(logfile);\n\n\tif (gui_mode) {\n\t\thide_shell(2);\n\t}\n\n#ifdef GPAC_MEMORY_TRACKING\n\tif (mem_track && (gf_memory_size() || gf_file_handles_count() )) {\n\t        gf_log_set_tool_level(GF_LOG_MEMORY, GF_LOG_INFO);\n\t\tgf_memory_print();\n\t\treturn 2;\n\t}\n#endif\n\n\treturn ret_val;\n}\n\n#if defined(WIN32) && !defined(NO_WMAIN)\nint wmain(int argc, wchar_t** wargv)\n{\n\tint i;\n\tint res;\n\tsize_t len;\n\tsize_t res_len;\n\tchar **argv;\n\targv = (char **)malloc(argc*sizeof(wchar_t *));\n\tfor (i = 0; i < argc; i++) {\n\t\twchar_t *src_str = wargv[i];\n\t\tlen = UTF8_MAX_BYTES_PER_CHAR * gf_utf8_wcslen(wargv[i]);\n\t\targv[i] = (char *)malloc(len + 1);\n\t\tres_len = gf_utf8_wcstombs(argv[i], len, &src_str);\n\t\targv[i][res_len] = 0;\n\t\tif (res_len > len) {\n\t\t\tfprintf(stderr, \"Length allocated for conversion of wide char to UTF-8 not sufficient\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tres = mp4client_main(argc, argv);\n\tfor (i = 0; i < argc; i++) {\n\t\tfree(argv[i]);\n\t}\n\tfree(argv);\n\treturn res;\n}\n#else\nint main(int argc, char** argv)\n{\n\treturn mp4client_main(argc, argv);\n}\n#endif //win32\nstatic GF_ObjectManager *video_odm = NULL;\nstatic GF_ObjectManager *audio_odm = NULL;\nstatic GF_ObjectManager *scene_odm = NULL;\nstatic u32 last_odm_count = 0;\nvoid PrintAVInfo(Bool final)\n{\n\tGF_MediaInfo a_odi, v_odi, s_odi;\n\tDouble avg_dec_time=0;\n\tu32 tot_time=0;\n\tBool print_codecs = final;\n\n\tif (scene_odm) {\n\t\tGF_ObjectManager *root_odm = gf_term_get_root_object(term);\n\t\tu32 count = gf_term_get_object_count(term, root_odm);\n\t\tif (last_odm_count != count) {\n\t\t\tlast_odm_count = count;\n\t\t\tscene_odm = NULL;\n\t\t}\n\t}\n\tif (!video_odm && !audio_odm && !scene_odm) {\n\t\tu32 count, i;\n\t\tGF_ObjectManager *root_odm = root_odm = gf_term_get_root_object(term);\n\t\tif (!root_odm) return;\n\n\t\tif (gf_term_get_object_info(term, root_odm, &v_odi)==GF_OK) {\n\t\t\tif (!scene_odm  && (v_odi.generated_scene== 0)) {\n\t\t\t\tscene_odm = root_odm;\n\t\t\t}\n\t\t}\n\n\t\tcount = gf_term_get_object_count(term, root_odm);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_ObjectManager *odm = gf_term_get_object(term, root_odm, i);\n\t\t\tif (!odm) break;\n\t\t\tif (gf_term_get_object_info(term, odm, &v_odi) == GF_OK) {\n\t\t\t\tif (!video_odm && (v_odi.od_type == GF_STREAM_VISUAL) && (v_odi.raw_media || (v_odi.cb_max_count>1) || v_odi.direct_video_memory || (bench_mode == 3) )) {\n\t\t\t\t\tvideo_odm = odm;\n\t\t\t\t}\n\t\t\t\telse if (!audio_odm && (v_odi.od_type == GF_STREAM_AUDIO)) {\n\t\t\t\t\taudio_odm = odm;\n\t\t\t\t}\n\t\t\t\telse if (!scene_odm && (v_odi.od_type == GF_STREAM_SCENE)) {\n\t\t\t\t\tscene_odm = odm;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0 && bench_buffer) {\n\t\tfprintf(stderr, \"Buffering %d %% \", bench_buffer-1);\n\t\treturn;\n\t}\n\n\tif (video_odm) {\n\t\tif (gf_term_get_object_info(term, video_odm, &v_odi)!= GF_OK) {\n\t\t\tvideo_odm = NULL;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tmemset(&v_odi, 0, sizeof(v_odi));\n\t}\n\tif (print_codecs && audio_odm) {\n\t\tgf_term_get_object_info(term, audio_odm, &a_odi);\n\t} else {\n\t\tmemset(&a_odi, 0, sizeof(a_odi));\n\t}\n\tif ((print_codecs || !video_odm) && scene_odm) {\n\t\tgf_term_get_object_info(term, scene_odm, &s_odi);\n\t} else {\n\t\tmemset(&s_odi, 0, sizeof(s_odi));\n\t}\n\n\tif (final) {\n\t\ttot_time = gf_sys_clock() - bench_mode_start;\n\t\tfprintf(stderr, \"                                                                                     \\r\");\n\t\tfprintf(stderr, \"************** Bench Mode Done in %d ms ********************\\n\", tot_time);\n\t\tif (bench_mode==3) fprintf(stderr, \"** Systems layer only (no decoding) **\\n\");\n\n\t\tif (!video_odm) {\n\t\t\tu32 nb_frames_drawn;\n\t\t\tDouble FPS = gf_term_get_simulation_frame_rate(term, &nb_frames_drawn);\n\t\t\tfprintf(stderr, \"Drawn %d frames FPS %.2f (simulation FPS %.2f) - duration %d ms\\n\", nb_frames_drawn, ((Float)nb_frames_drawn*1000)/tot_time,(Float) FPS, gf_term_get_time_in_ms(term)  );\n\t\t}\n\t}\n\tif (print_codecs) {\n\t\tif (video_odm) {\n\t\t\tfprintf(stderr, \"%s %dx%d sar=%d:%d duration %.2fs\\n\", v_odi.codec_name, v_odi.width, v_odi.height, v_odi.par ? (v_odi.par>>16)&0xFF : 1, v_odi.par ? (v_odi.par)&0xFF : 1, v_odi.duration);\n\t\t\tif (final) {\n\t\t\t\tu32 dec_run_time = v_odi.last_frame_time - v_odi.first_frame_time;\n\t\t\t\tif (!dec_run_time) dec_run_time = 1;\n\t\t\t\tif (v_odi.duration) fprintf(stderr, \"%d%% \", (u32) (100*v_odi.current_time / v_odi.duration ) );\n\t\t\t\tfprintf(stderr, \"%d frames FPS %.2f (max %d us/f) rate avg %d max %d\", v_odi.nb_dec_frames, ((Float)v_odi.nb_dec_frames*1000) / dec_run_time, v_odi.max_dec_time, (u32) v_odi.avg_bitrate/1000, (u32) v_odi.max_bitrate/1000);\n\t\t\t\tif (v_odi.nb_dropped) {\n\t\t\t\t\tfprintf(stderr, \" (Error during bench: %d frames drop)\", v_odi.nb_dropped);\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t}\n\t\tif (audio_odm) {\n\t\t\tfprintf(stderr, \"%s SR %d num channels %d bpp %d duration %.2fs\\n\", a_odi.codec_name, a_odi.sample_rate, a_odi.num_channels, a_odi.bits_per_sample, a_odi.duration);\n\t\t\tif (final) {\n\t\t\t\tu32 dec_run_time = a_odi.last_frame_time - a_odi.first_frame_time;\n\t\t\t\tif (!dec_run_time) dec_run_time = 1;\n\t\t\t\tif (a_odi.duration) fprintf(stderr, \"%d%% \", (u32) (100*a_odi.current_time / a_odi.duration ) );\n\t\t\t\tfprintf(stderr, \"%d frames (ms/f %.2f avg %.2f max) rate avg %d max %d\", a_odi.nb_dec_frames, ((Float)dec_run_time)/a_odi.nb_dec_frames, a_odi.max_dec_time/1000.0, (u32) a_odi.avg_bitrate/1000, (u32) a_odi.max_bitrate/1000);\n\t\t\t\tif (a_odi.nb_dropped) {\n\t\t\t\t\tfprintf(stderr, \" (Error during bench: %d frames drop)\", a_odi.nb_dropped);\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t}\n\t\tif (scene_odm) {\n\t\t\tu32 w, h;\n\t\t\tgf_term_get_visual_output_size(term, &w, &h);\n\t\t\tfprintf(stderr, \"%s scene size %dx%d rastered to %dx%d duration %.2fs\\n\", s_odi.codec_name ? s_odi.codec_name : \"\", s_odi.width, s_odi.height, w, h, s_odi.duration);\n\t\t\tif (final) {\n\t\t\t\tif (s_odi.nb_dec_frames>2 && s_odi.total_dec_time) {\n\t\t\t\t\tu32 dec_run_time = s_odi.last_frame_time - s_odi.first_frame_time;\n\t\t\t\t\tif (!dec_run_time) dec_run_time = 1;\n\t\t\t\t\tfprintf(stderr, \"%d frames FPS %.2f (max %d us/f) rate avg %d max %d\", s_odi.nb_dec_frames, ((Float)s_odi.nb_dec_frames*1000) / dec_run_time, s_odi.max_dec_time, (u32) s_odi.avg_bitrate/1000, (u32) s_odi.max_bitrate/1000);\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tu32 nb_frames_drawn;\n\t\t\t\t\tDouble FPS;\n\t\t\t\t\tgf_term_get_simulation_frame_rate(term, &nb_frames_drawn);\n\t\t\t\t\ttot_time = gf_sys_clock() - bench_mode_start;\n\t\t\t\t\tFPS = gf_term_get_framerate(term, 0);\n\t\t\t\t\tfprintf(stderr, \"%d frames FPS %.2f (abs %.2f)\\n\", nb_frames_drawn, (1000.0*nb_frames_drawn / tot_time), FPS);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (final) {\n\t\t\tfprintf(stderr, \"**********************************************************\\n\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (video_odm) {\n\t\ttot_time = v_odi.last_frame_time - v_odi.first_frame_time;\n\t\tif (!tot_time) tot_time=1;\n\t\tif (v_odi.duration) fprintf(stderr, \"%d%% \", (u32) (100*v_odi.current_time / v_odi.duration ) );\n\t\tfprintf(stderr, \"%d f FPS %.2f (%.2f ms max) rate %d \", v_odi.nb_dec_frames, ((Float)v_odi.nb_dec_frames*1000) / tot_time, v_odi.max_dec_time/1000.0, (u32) v_odi.instant_bitrate/1000);\n\t}\n\telse if (scene_odm) {\n\n\t\tif (s_odi.nb_dec_frames>2 && s_odi.total_dec_time) {\n\t\t\tavg_dec_time = (Float) 1000000 * s_odi.nb_dec_frames;\n\t\t\tavg_dec_time /= s_odi.total_dec_time;\n\t\t\tif (s_odi.duration) fprintf(stderr, \"%d%% \", (u32) (100*s_odi.current_time / s_odi.duration ) );\n\t\t\tfprintf(stderr, \"%d f %.2f (%d us max) - rate %d \", s_odi.nb_dec_frames, avg_dec_time, s_odi.max_dec_time, (u32) s_odi.instant_bitrate/1000);\n\t\t} else {\n\t\t\tu32 nb_frames_drawn;\n\t\t\tDouble FPS;\n\t\t\tgf_term_get_simulation_frame_rate(term, &nb_frames_drawn);\n\t\t\ttot_time = gf_sys_clock() - bench_mode_start;\n\t\t\tFPS = gf_term_get_framerate(term, 1);\n\t\t\tfprintf(stderr, \"%d f FPS %.2f (abs %.2f) \", nb_frames_drawn, (1000.0*nb_frames_drawn / tot_time), FPS);\n\t\t}\n\t}\n\telse if (audio_odm) {\n\t\tif (!print_codecs) {\n\t\t\tgf_term_get_object_info(term, audio_odm, &a_odi);\n\t\t}\n\t\ttot_time = a_odi.last_frame_time - a_odi.first_frame_time;\n\t\tif (!tot_time) tot_time=1;\n\t\tif (a_odi.duration) fprintf(stderr, \"%d%% \", (u32) (100*a_odi.current_time / a_odi.duration ) );\n\t\tfprintf(stderr, \"%d frames (ms/f %.2f avg %.2f max)\", a_odi.nb_dec_frames, ((Float)tot_time)/a_odi.nb_dec_frames, a_odi.max_dec_time/1000.0);\n\t}\n}\n\nvoid PrintWorldInfo(GF_Terminal *term)\n{\n\tu32 i;\n\tconst char *title;\n\tGF_List *descs;\n\tdescs = gf_list_new();\n\ttitle = gf_term_get_world_info(term, NULL, descs);\n\tif (!title && !gf_list_count(descs)) {\n\t\tfprintf(stderr, \"No World Info available\\n\");\n\t} else {\n\t\tfprintf(stderr, \"\\t%s\\n\", title ? title : \"No title available\");\n\t\tfor (i=0; i<gf_list_count(descs); i++) {\n\t\t\tchar *str = gf_list_get(descs, i);\n\t\t\tfprintf(stderr, \"%s\\n\", str);\n\t\t}\n\t}\n\tgf_list_del(descs);\n}\n\nvoid PrintODList(GF_Terminal *term, GF_ObjectManager *root_odm, u32 num, u32 indent, char *root_name)\n{\n\tGF_MediaInfo odi;\n\tu32 i, count;\n\tchar szIndent[50];\n\tGF_ObjectManager *odm;\n\n\tif (!root_odm) {\n\t\tfprintf(stderr, \"Currently loaded objects:\\n\");\n\t\troot_odm = gf_term_get_root_object(term);\n\t}\n\tif (!root_odm) return;\n\n\tcount = gf_term_get_current_service_id(term);\n\tif (count)\n\t\tfprintf(stderr, \"Current service ID %d\\n\", count);\n\n\tif (gf_term_get_object_info(term, root_odm, &odi) != GF_OK) return;\n\tif (!odi.od) {\n\t\tfprintf(stderr, \"Service not attached\\n\");\n\t\treturn;\n\t}\n\n\tfor (i=0; i<indent; i++) szIndent[i]=' ';\n\tszIndent[indent]=0;\n\n\tfprintf(stderr, \"%s\", szIndent);\n\tfprintf(stderr, \"#%d %s - \", num, root_name);\n\tif (odi.od->ServiceID) fprintf(stderr, \"Service ID %d \", odi.od->ServiceID);\n\tif (odi.media_url) {\n\t\tfprintf(stderr, \"%s\\n\", odi.media_url);\n\t} else {\n\t\tfprintf(stderr, \"OD ID %d\\n\", odi.od->objectDescriptorID);\n\t}\n\n\tszIndent[indent]=' ';\n\tszIndent[indent+1]=0;\n\tindent++;\n\n\tcount = gf_term_get_object_count(term, root_odm);\n\tfor (i=0; i<count; i++) {\n\t\todm = gf_term_get_object(term, root_odm, i);\n\t\tif (!odm) break;\n\t\tnum++;\n\t\tif (gf_term_get_object_info(term, odm, &odi) == GF_OK) {\n\t\t\tswitch (gf_term_object_subscene_type(term, odm)) {\n\t\t\tcase 1:\n\t\t\t\tPrintODList(term, odm, num, indent, \"Root\");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tPrintODList(term, odm, num, indent, \"Inline Scene\");\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tPrintODList(term, odm, num, indent, \"EXTERNPROTO Library\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, \"%s\", szIndent);\n\t\t\t\tfprintf(stderr, \"#%d - \", num);\n\t\t\t\tif (odi.media_url) {\n\t\t\t\t\tfprintf(stderr, \"%s\", odi.media_url);\n\t\t\t\t} else if (odi.od) {\n\t\t\t\t \tif (odi.od->URLString) {\n\t\t\t\t\t\tfprintf(stderr, \"%s\", odi.od->URLString);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfprintf(stderr, \"ID %d\", odi.od->objectDescriptorID);\n\t\t\t\t\t}\n\t\t\t\t} else if (odi.service_url) {\n\t\t\t\t\tfprintf(stderr, \"%s\", odi.service_url);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"unknown\");\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \" - %s\", (odi.od_type==GF_STREAM_VISUAL) ? \"Video\" : (odi.od_type==GF_STREAM_AUDIO) ? \"Audio\" : \"Systems\");\n\t\t\t\tif (odi.od && odi.od->ServiceID) fprintf(stderr, \" - Service ID %d\", odi.od->ServiceID);\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid ViewOD(GF_Terminal *term, u32 OD_ID, u32 number, const char *szURL)\n{\n\tGF_MediaInfo odi;\n\tu32 i, j, count, d_enum,id;\n\tGF_Err e;\n\tNetStatCommand com;\n\tGF_ObjectManager *odm, *root_odm = gf_term_get_root_object(term);\n\tif (!root_odm) return;\n\n\todm = NULL;\n\tif (!szURL && ((!OD_ID && (number == (u32)-1)) || ((OD_ID == (u32)(-1)) && !number))) {\n\t\todm = root_odm;\n\t\tif ((gf_term_get_object_info(term, odm, &odi) != GF_OK)) odm=NULL;\n\t} else {\n\t\tcount = gf_term_get_object_count(term, root_odm);\n\t\tfor (i=0; i<count; i++) {\n\t\t\todm = gf_term_get_object(term, root_odm, i);\n\t\t\tif (!odm) break;\n\t\t\tif (gf_term_get_object_info(term, odm, &odi) == GF_OK) {\n\t\t\t\tif (szURL && strstr(odi.service_url, szURL)) break;\n\t\t\t\tif ((number == (u32)(-1)) && odi.od && (odi.od->objectDescriptorID == OD_ID)) break;\n\t\t\t\telse if (i == (u32)(number-1)) break;\n\t\t\t}\n\t\t\todm = NULL;\n\t\t}\n\t}\n\tif (!odm) {\n\t\tif (szURL) fprintf(stderr, \"cannot find OD for URL %s\\n\", szURL);\n\t\tif (number == (u32)-1) fprintf(stderr, \"cannot find OD with ID %d\\n\", OD_ID);\n\t\telse fprintf(stderr, \"cannot find OD with number %d\\n\", number);\n\t\treturn;\n\t}\n\tif (!odi.od) {\n\t\tif (number == (u32)-1) fprintf(stderr, \"Object %d not attached yet\\n\", OD_ID);\n\t\telse fprintf(stderr, \"Object #%d not attached yet\\n\", number);\n\t\treturn;\n\t}\n\n\tif (!odi.od) {\n\t\tfprintf(stderr, \"Service not attached\\n\");\n\t\treturn;\n\t}\n\n\tif (odi.od->tag==GF_ODF_IOD_TAG) {\n\t\tfprintf(stderr, \"InitialObjectDescriptor %d\\n\", odi.od->objectDescriptorID);\n\t\tfprintf(stderr, \"Profiles and Levels: Scene %x - Graphics %x - Visual %x - Audio %x - OD %x\\n\",\n\t\t        odi.scene_pl, odi.graphics_pl, odi.visual_pl, odi.audio_pl, odi.OD_pl);\n\t\tfprintf(stderr, \"Inline Profile Flag %d\\n\", odi.inline_pl);\n\t} else {\n\t\tfprintf(stderr, \"ObjectDescriptor %d\\n\", odi.od->objectDescriptorID);\n\t}\n\n\tfprintf(stderr, \"Object Duration: \");\n\tif (odi.duration) {\n\t\tPrintTime((u32) (odi.duration*1000));\n\t} else {\n\t\tfprintf(stderr, \"unknown\");\n\t}\n\tfprintf(stderr, \"\\n\");\n\n\tfprintf(stderr, \"Service Handler: %s\\n\", odi.service_handler);\n\tfprintf(stderr, \"Service URL: %s\\n\", odi.service_url);\n\n\tif (odi.codec_name) {\n\t\tFloat avg_dec_time;\n\t\tswitch (odi.od_type) {\n\t\tcase GF_STREAM_VISUAL:\n\t\t\tfprintf(stderr, \"Video Object: Width %d - Height %d\\r\\n\", odi.width, odi.height);\n\t\t\tfprintf(stderr, \"Media Codec: %s\\n\", odi.codec_name);\n\t\t\tif (odi.par) fprintf(stderr, \"Pixel Aspect Ratio: %d:%d\\n\", (odi.par>>16)&0xFF, (odi.par)&0xFF);\n\t\t\tbreak;\n\t\tcase GF_STREAM_AUDIO:\n\t\t\tfprintf(stderr, \"Audio Object: Sample Rate %d - %d channels\\r\\n\", odi.sample_rate, odi.num_channels);\n\t\t\tfprintf(stderr, \"Media Codec: %s\\n\", odi.codec_name);\n\t\t\tbreak;\n\t\tcase GF_STREAM_SCENE:\n\t\tcase GF_STREAM_PRIVATE_SCENE:\n\t\t\tif (odi.width && odi.height) {\n\t\t\t\tfprintf(stderr, \"Scene Description - Width %d - Height %d\\n\", odi.width, odi.height);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Scene Description - no size specified\\n\");\n\t\t\t}\n\t\t\tfprintf(stderr, \"Scene Codec: %s\\n\", odi.codec_name);\n\t\t\tbreak;\n\t\tcase GF_STREAM_TEXT:\n\t\t\tif (odi.width && odi.height) {\n\t\t\t\tfprintf(stderr, \"Text Object: Width %d - Height %d\\n\", odi.width, odi.height);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Text Object: No size specified\\n\");\n\t\t\t}\n\t\t\tfprintf(stderr, \"Text Codec %s\\n\", odi.codec_name);\n\t\t\tbreak;\n\t\t}\n\n\t\tavg_dec_time = 0;\n\t\tif (odi.nb_dec_frames) {\n\t\t\tavg_dec_time = (Float) odi.total_dec_time;\n\t\t\tavg_dec_time /= odi.nb_dec_frames;\n\t\t}\n\t\tfprintf(stderr, \"\\tBitrate over last second: %d kbps\\n\\tMax bitrate over one second: %d kbps\\n\\tAverage Decoding Time %.2f us %d max)\\n\\tTotal decoded frames %d\\n\",\n\t\t        (u32) odi.avg_bitrate/1024, odi.max_bitrate/1024, avg_dec_time, odi.max_dec_time, odi.nb_dec_frames);\n\t}\n\tif (odi.protection) fprintf(stderr, \"Encrypted Media%s\\n\", (odi.protection==2) ? \" NOT UNLOCKED\" : \"\");\n\n\tcount = gf_list_count(odi.od->ESDescriptors);\n\tfprintf(stderr, \"%d streams in OD\\n\", count);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ESD *esd = (GF_ESD *) gf_list_get(odi.od->ESDescriptors, i);\n\n\t\tfprintf(stderr, \"\\nStream ID %d - Clock ID %d\\n\", esd->ESID, esd->OCRESID);\n\t\tif (esd->dependsOnESID) fprintf(stderr, \"\\tDepends on Stream ID %d for decoding\\n\", esd->dependsOnESID);\n\n\t\tswitch (esd->decoderConfig->streamType) {\n\t\tcase GF_STREAM_OD:\n\t\t\tfprintf(stderr, \"\\tOD Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tcase GF_STREAM_OCR:\n\t\t\tfprintf(stderr, \"\\tOCR Stream\\n\");\n\t\t\tbreak;\n\t\tcase GF_STREAM_SCENE:\n\t\t\tfprintf(stderr, \"\\tScene Description Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tcase GF_STREAM_VISUAL:\n\t\t\tfprintf(stderr, \"\\tVisual Stream - media type: %s\", gf_esd_get_textual_description(esd));\n\t\t\tbreak;\n\t\tcase GF_STREAM_AUDIO:\n\t\t\tfprintf(stderr, \"\\tAudio Stream - media type: %s\", gf_esd_get_textual_description(esd));\n\t\t\tbreak;\n\t\tcase GF_STREAM_MPEG7:\n\t\t\tfprintf(stderr, \"\\tMPEG-7 Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tcase GF_STREAM_IPMP:\n\t\t\tfprintf(stderr, \"\\tIPMP Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tcase GF_STREAM_OCI:\n\t\t\tfprintf(stderr, \"\\tOCI Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tcase GF_STREAM_MPEGJ:\n\t\t\tfprintf(stderr, \"\\tMPEGJ Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tcase GF_STREAM_INTERACT:\n\t\t\tfprintf(stderr, \"\\tUser Interaction Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tcase GF_STREAM_TEXT:\n\t\t\tfprintf(stderr, \"\\tStreaming Text Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"\\tUnknown Stream\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tfprintf(stderr, \"\\tBuffer Size %d\\n\\tAverage Bitrate %d bps\\n\\tMaximum Bitrate %d bps\\n\", esd->decoderConfig->bufferSizeDB, esd->decoderConfig->avgBitrate, esd->decoderConfig->maxBitrate);\n\t\tif (esd->slConfig->predefined==SLPredef_SkipSL) {\n\t\t\tfprintf(stderr, \"\\tNot using MPEG-4 Synchronization Layer\\n\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"\\tStream Clock Resolution %d\\n\", esd->slConfig->timestampResolution);\n\t\t}\n\t\tif (esd->URLString) fprintf(stderr, \"\\tStream Location: %s\\n\", esd->URLString);\n\n\t\t/*check language*/\n\t\tif (esd->langDesc) {\n\t\t\ts32 lang_idx;\n\t\t\tchar lan[4];\n\t\t\tlan[0] = esd->langDesc->langCode>>16;\n\t\t\tlan[1] = (esd->langDesc->langCode>>8)&0xFF;\n\t\t\tlan[2] = (esd->langDesc->langCode)&0xFF;\n\t\t\tlan[3] = 0;\n\n\t\t\tlang_idx = gf_lang_find(lan);\n\t\t\tif (lang_idx>=0) {\n\t\t\t\tfprintf(stderr, \"\\tStream Language: %s\\n\", gf_lang_get_name(lang_idx));\n\t\t\t}\n\t\t}\n\t}\n\tfprintf(stderr, \"\\n\");\n\t/*check OCI (not everything interests us) - FIXME: support for unicode*/\n\tcount = gf_list_count(odi.od->OCIDescriptors);\n\tif (count) {\n\t\tfprintf(stderr, \"%d Object Content Information descriptors in OD\\n\", count);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_Descriptor *desc = (GF_Descriptor *) gf_list_get(odi.od->OCIDescriptors, i);\n\t\t\tswitch (desc->tag) {\n\t\t\tcase GF_ODF_SEGMENT_TAG:\n\t\t\t{\n\t\t\t\tGF_Segment *sd = (GF_Segment *) desc;\n\t\t\t\tfprintf(stderr, \"Segment Descriptor: Name: %s - start time %g sec - duration %g sec\\n\", sd->SegmentName, sd->startTime, sd->Duration);\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase GF_ODF_CC_NAME_TAG:\n\t\t\t{\n\t\t\t\tGF_CC_Name *ccn = (GF_CC_Name *)desc;\n\t\t\t\tfprintf(stderr, \"Content Creators:\\n\");\n\t\t\t\tfor (j=0; j<gf_list_count(ccn->ContentCreators); j++) {\n\t\t\t\t\tGF_ContentCreatorInfo *ci = (GF_ContentCreatorInfo *) gf_list_get(ccn->ContentCreators, j);\n\t\t\t\t\tif (!ci->isUTF8) continue;\n\t\t\t\t\tfprintf(stderr, \"\\t%s\\n\", ci->contentCreatorName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\tcase GF_ODF_SHORT_TEXT_TAG:\n\t\t\t{\n\t\t\t\tGF_ShortTextual *std = (GF_ShortTextual *)desc;\n\t\t\t\tfprintf(stderr, \"Description:\\n\\tEvent: %s\\n\\t%s\\n\", std->eventName, std->eventText);\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\n\tswitch (odi.status) {\n\tcase 0:\n\t\tfprintf(stderr, \"Stopped - \");\n\t\tbreak;\n\tcase 1:\n\t\tfprintf(stderr, \"Playing - \");\n\t\tbreak;\n\tcase 2:\n\t\tfprintf(stderr, \"Paused - \");\n\t\tbreak;\n\tcase 3:\n\t\tfprintf(stderr, \"Not setup yet\\n\");\n\t\treturn;\n\tdefault:\n\t\tfprintf(stderr, \"Setup Failed\\n\");\n\t\treturn;\n\t}\n\tif (odi.buffer>=0) fprintf(stderr, \"Buffer: %d ms - \", odi.buffer);\n\telse fprintf(stderr, \"Not buffering - \");\n\tfprintf(stderr, \"Clock drift: %d ms\\n\", odi.clock_drift);\n\tif (odi.db_unit_count) fprintf(stderr, \"%d AU in DB\\n\", odi.db_unit_count);\n\tif (odi.cb_max_count) fprintf(stderr, \"Composition Buffer: %d CU (%d max)\\n\", odi.cb_unit_count, odi.cb_max_count);\n\tfprintf(stderr, \"\\n\");\n\n\tif (odi.owns_service) {\n\t\tconst char *url;\n\t\tu32 done, total, bps;\n\t\td_enum = 0;\n\t\twhile (gf_term_get_download_info(term, odm, &d_enum, &url, NULL, &done, &total, &bps)) {\n\t\t\tif (d_enum==1) fprintf(stderr, \"Current Downloads in service:\\n\");\n\t\t\tif (done && total) {\n\t\t\t\tfprintf(stderr, \"%s: %d / %d bytes (%.2f %%) - %.2f kBps\\n\", url, done, total, (100.0f*done)/total, ((Float)bps)/1024.0f);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"%s: %.2f kbps\\n\", url, ((Float)8*bps)/1024.0f);\n\t\t\t}\n\t\t}\n\t\tif (!d_enum) fprintf(stderr, \"No Downloads in service\\n\");\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\td_enum = 0;\n\twhile (gf_term_get_channel_net_info(term, odm, &d_enum, &id, &com, &e)) {\n\t\tif (e) continue;\n\t\tif (!com.bw_down && !com.bw_up) continue;\n\n\t\tfprintf(stderr, \"Stream ID %d statistics:\\n\", id);\n\t\tif (com.multiplex_port) {\n\t\t\tfprintf(stderr, \"\\tMultiplex Port %d - multiplex ID %d\\n\", com.multiplex_port, com.port);\n\t\t} else {\n\t\t\tfprintf(stderr, \"\\tPort %d\\n\", com.port);\n\t\t}\n\t\tfprintf(stderr, \"\\tPacket Loss Percentage: %.4f\\n\", com.pck_loss_percentage);\n\t\tfprintf(stderr, \"\\tDown Bandwidth: %d bps\\n\", com.bw_down);\n\t\tif (com.bw_up) fprintf(stderr, \"\\tUp Bandwidth: %d bps\\n\", com.bw_up);\n\t\tif (com.ctrl_port) {\n\t\t\tif (com.multiplex_port) {\n\t\t\t\tfprintf(stderr, \"\\tControl Multiplex Port: %d - Control Multiplex ID %d\\n\", com.multiplex_port, com.ctrl_port);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"\\tControl Port: %d\\n\", com.ctrl_port);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\tDown Bandwidth: %d bps\\n\", com.ctrl_bw_down);\n\t\t\tfprintf(stderr, \"\\tUp Bandwidth: %d bps\\n\", com.ctrl_bw_up);\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}\n\nvoid PrintODTiming(GF_Terminal *term, GF_ObjectManager *odm, u32 indent)\n{\n\tGF_MediaInfo odi;\n\tu32 ind = indent;\n\tu32 i, count;\n\tif (!odm) return;\n\n\tif (gf_term_get_object_info(term, odm, &odi) != GF_OK) return;\n\tif (!odi.od) {\n\t\tfprintf(stderr, \"Service not attached\\n\");\n\t\treturn;\n\t}\n\twhile (ind) {\n\t\tfprintf(stderr, \" \");\n\t\tind--;\n\t}\n\n\tif (! odi.generated_scene) {\n\n\t\tfprintf(stderr, \"- OD %d: \", odi.od->objectDescriptorID);\n\t\tswitch (odi.status) {\n\t\tcase 1:\n\t\t\tfprintf(stderr, \"Playing - \");\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tfprintf(stderr, \"Paused - \");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Stopped - \");\n\t\t\tbreak;\n\t\t}\n\t\tif (odi.buffer>=0) fprintf(stderr, \"Buffer: %d ms - \", odi.buffer);\n\t\telse fprintf(stderr, \"Not buffering - \");\n\t\tfprintf(stderr, \"Clock drift: %d ms\", odi.clock_drift);\n\t\tfprintf(stderr, \" - time: \");\n\t\tPrintTime((u32) (odi.current_time*1000));\n\t\tfprintf(stderr, \"\\n\");\n\n\t} else {\n\t\tfprintf(stderr, \"+ Service %s:\\n\", odi.service_url);\n\t}\n\n\tcount = gf_term_get_object_count(term, odm);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ObjectManager *an_odm = gf_term_get_object(term, odm, i);\n\t\tPrintODTiming(term, an_odm, indent+1);\n\t}\n\treturn;\n\n}\n\nvoid PrintODBuffer(GF_Terminal *term, GF_ObjectManager *odm, u32 indent)\n{\n\tFloat avg_dec_time;\n\tGF_MediaInfo odi;\n\tu32 ind, i, count;\n\tif (!odm) return;\n\n\tif (gf_term_get_object_info(term, odm, &odi) != GF_OK) return;\n\tif (!odi.od) {\n\t\tfprintf(stderr, \"Service not attached\\n\");\n\t\treturn;\n\t}\n\n\tind = indent;\n\twhile (ind) {\n\t\tfprintf(stderr, \" \");\n\t\tind--;\n\t}\n\n\tif (odi.generated_scene) {\n\t\tfprintf(stderr, \"+ Service %s:\\n\", odi.service_url);\n\t} else {\n\t\tfprintf(stderr, \"- OD %d: \", odi.od->objectDescriptorID);\n\t\tswitch (odi.status) {\n\t\tcase 1:\n\t\t\tfprintf(stderr, \"Playing\");\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tfprintf(stderr, \"Paused\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Stopped\");\n\t\t\tbreak;\n\t\t}\n\t\tif (odi.buffer>=0) fprintf(stderr, \" - Buffer: %d ms\", odi.buffer);\n\t\tif (odi.db_unit_count) fprintf(stderr, \" - DB: %d AU\", odi.db_unit_count);\n\t\tif (odi.cb_max_count) fprintf(stderr, \" - CB: %d/%d CUs\", odi.cb_unit_count, odi.cb_max_count);\n\n\t\tfprintf(stderr, \"\\n\");\n\t\tind = indent;\n\t\twhile (ind) {\n\t\t\tfprintf(stderr, \" \");\n\t\t\tind--;\n\t\t}\n\n\t\tfprintf(stderr, \" %d decoded frames - %d dropped frames\\n\", odi.nb_dec_frames, odi.nb_dropped);\n\n\t\tind = indent;\n\t\twhile (ind) {\n\t\t\tfprintf(stderr, \" \");\n\t\t\tind--;\n\t\t}\n\n\t\tavg_dec_time = 0;\n\t\tif (odi.nb_dec_frames) {\n\t\t\tavg_dec_time = (Float) odi.total_dec_time;\n\t\t\tavg_dec_time /= odi.nb_dec_frames;\n\t\t}\n\t\tfprintf(stderr, \" Avg Bitrate %d kbps (%d max) - Avg Decoding Time %.2f us (%d max)\\n\",\n\t\t        (u32) odi.avg_bitrate/1024, odi.max_bitrate/1024, avg_dec_time, odi.max_dec_time);\n\t}\n\n\tcount = gf_term_get_object_count(term, odm);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ObjectManager *an_odm = gf_term_get_object(term, odm, i);\n\t\tPrintODBuffer(term, an_odm, indent+1);\n\t}\n\n}\n\nvoid ViewODs(GF_Terminal *term, Bool show_timing)\n{\n\tGF_ObjectManager *root_odm = gf_term_get_root_object(term);\n\tif (!root_odm) return;\n\n\tif (show_timing) {\n\t\tPrintODTiming(term, root_odm, 0);\n\t} else {\n\t\tPrintODBuffer(term, root_odm, 0);\n\t}\n\tfprintf(stderr, \"\\n\");\n}\n\n\nvoid PrintGPACConfig()\n{\n\tu32 i, j, cfg_count, key_count;\n\tchar szName[200];\n\tchar *secName = NULL;\n\n\tfprintf(stderr, \"Enter section name (\\\"*\\\" for complete dump):\\n\");\n\tif (1 > scanf(\"%s\", szName)) {\n\t\tfprintf(stderr, \"No section name, aborting.\\n\");\n\t\treturn;\n\t}\n\tif (strcmp(szName, \"*\")) secName = szName;\n\n\tfprintf(stderr, \"\\n\\n*** GPAC Configuration ***\\n\\n\");\n\n\tcfg_count = gf_cfg_get_section_count(cfg_file);\n\tfor (i=0; i<cfg_count; i++) {\n\t\tconst char *sec = gf_cfg_get_section_name(cfg_file, i);\n\t\tif (secName) {\n\t\t\tif (stricmp(sec, secName)) continue;\n\t\t} else {\n\t\t\tif (!stricmp(sec, \"General\")) continue;\n\t\t\tif (!stricmp(sec, \"MimeTypes\")) continue;\n\t\t\tif (!stricmp(sec, \"RecentFiles\")) continue;\n\t\t}\n\t\tfprintf(stderr, \"[%s]\\n\", sec);\n\t\tkey_count = gf_cfg_get_key_count(cfg_file, sec);\n\t\tfor (j=0; j<key_count; j++) {\n\t\t\tconst char *key = gf_cfg_get_key_name(cfg_file, sec, j);\n\t\t\tconst char *val = gf_cfg_get_key(cfg_file, sec, key);\n\t\t\tfprintf(stderr, \"%s=%s\\n\", key, val);\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}\n\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / Media Tools sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n\n#include <gpac/constants.h>\n#include <gpac/utf.h>\n#include <gpac/xml.h>\n#include <gpac/token.h>\n#include <gpac/color.h>\n#include <gpac/internal/media_dev.h>\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nvoid gf_media_update_bitrate(GF_ISOFile *file, u32 track);\n\nenum\n{\n\tGF_TEXT_IMPORT_NONE = 0,\n\tGF_TEXT_IMPORT_SRT,\n\tGF_TEXT_IMPORT_SUB,\n\tGF_TEXT_IMPORT_TTXT,\n\tGF_TEXT_IMPORT_TEXML,\n\tGF_TEXT_IMPORT_WEBVTT,\n\tGF_TEXT_IMPORT_TTML,\n\tGF_TEXT_IMPORT_SWF_SVG,\n};\n\n#define REM_TRAIL_MARKS(__str, __sep) while (1) {\t\\\n\t\tu32 _len = (u32) strlen(__str);\t\t\\\n\t\tif (!_len) break;\t\\\n\t\t_len--;\t\t\t\t\\\n\t\tif (strchr(__sep, __str[_len])) __str[_len] = 0;\t\\\n\t\telse break;\t\\\n\t}\t\\\n \n\ns32 gf_text_get_utf_type(FILE *in_src)\n{\n\tu32 read;\n\tunsigned char BOM[5];\n\tread = (u32) fread(BOM, sizeof(char), 5, in_src);\n\tif ((s32) read < 1)\n\t\treturn -1;\n\n\tif ((BOM[0]==0xFF) && (BOM[1]==0xFE)) {\n\t\t/*UTF32 not supported*/\n\t\tif (!BOM[2] && !BOM[3]) return -1;\n\t\tgf_fseek(in_src, 2, SEEK_SET);\n\t\treturn 3;\n\t}\n\tif ((BOM[0]==0xFE) && (BOM[1]==0xFF)) {\n\t\t/*UTF32 not supported*/\n\t\tif (!BOM[2] && !BOM[3]) return -1;\n\t\tgf_fseek(in_src, 2, SEEK_SET);\n\t\treturn 2;\n\t} else if ((BOM[0]==0xEF) && (BOM[1]==0xBB) && (BOM[2]==0xBF)) {\n\t\tgf_fseek(in_src, 3, SEEK_SET);\n\t\treturn 1;\n\t}\n\tif (BOM[0]<0x80) {\n\t\tgf_fseek(in_src, 0, SEEK_SET);\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nstatic GF_Err gf_text_guess_format(char *filename, u32 *fmt)\n{\n\tchar szLine[2048];\n\tu32 val;\n\ts32 uni_type;\n\tFILE *test = gf_fopen(filename, \"rb\");\n\tif (!test) return GF_URL_ERROR;\n\tuni_type = gf_text_get_utf_type(test);\n\n\tif (uni_type>1) {\n\t\tconst u16 *sptr;\n\t\tchar szUTF[1024];\n\t\tu32 read = (u32) fread(szUTF, 1, 1023, test);\n\t\tif ((s32) read < 0) {\n\t\t\tgf_fclose(test);\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\tszUTF[read]=0;\n\t\tsptr = (u16*)szUTF;\n\t\t/*read = (u32) */gf_utf8_wcstombs(szLine, read, &sptr);\n\t} else {\n\t\tval = (u32) fread(szLine, 1, 1024, test);\n\t\tif ((s32) val<0) return GF_IO_ERR;\n\t\t\n\t\tszLine[val]=0;\n\t}\n\tREM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\n\t*fmt = GF_TEXT_IMPORT_NONE;\n\tif ((szLine[0]=='{') && strstr(szLine, \"}{\")) *fmt = GF_TEXT_IMPORT_SUB;\n\telse if (szLine[0] == '<') {\n\t\tchar *ext = strrchr(filename, '.');\n\t\tif (!strnicmp(ext, \".ttxt\", 5)) *fmt = GF_TEXT_IMPORT_TTXT;\n\t\telse if (!strnicmp(ext, \".ttml\", 5)) *fmt = GF_TEXT_IMPORT_TTML;\n\t\text = strstr(szLine, \"?>\");\n\t\tif (ext) ext += 2;\n\t\tif (ext && !ext[0]) {\n\t\t\tif (!fgets(szLine, 2048, test))\n\t\t\t\tszLine[0] = '\\0';\n\t\t}\n\t\tif (strstr(szLine, \"x-quicktime-tx3g\") || strstr(szLine, \"text3GTrack\")) *fmt = GF_TEXT_IMPORT_TEXML;\n\t\telse if (strstr(szLine, \"TextStream\")) *fmt = GF_TEXT_IMPORT_TTXT;\n\t\telse if (strstr(szLine, \"tt\")) *fmt = GF_TEXT_IMPORT_TTML;\n\t}\n\telse if (strstr(szLine, \"WEBVTT\") )\n\t\t*fmt = GF_TEXT_IMPORT_WEBVTT;\n\telse if (strstr(szLine, \" --> \") )\n\t\t*fmt = GF_TEXT_IMPORT_SRT; /* might want to change the default to WebVTT */\n\n\tgf_fclose(test);\n\treturn GF_OK;\n}\n\n\n#define TTXT_DEFAULT_WIDTH\t400\n#define TTXT_DEFAULT_HEIGHT\t60\n#define TTXT_DEFAULT_FONT_SIZE\t18\n\n#ifndef GPAC_DISABLE_MEDIA_IMPORT\nvoid gf_text_get_video_size(GF_MediaImporter *import, u32 *width, u32 *height)\n{\n\tu32 w, h, f_w, f_h, i;\n\tGF_ISOFile *dest = import->dest;\n\n\tif (import->text_track_width && import->text_track_height) {\n\t\t(*width) = import->text_track_width;\n\t\t(*height) = import->text_track_height;\n\t\treturn;\n\t}\n\n\tf_w = f_h = 0;\n\tfor (i=0; i<gf_isom_get_track_count(dest); i++) {\n\t\tswitch (gf_isom_get_media_type(dest, i+1)) {\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n        case GF_ISOM_MEDIA_AUXV:\n        case GF_ISOM_MEDIA_PICT:\n\t\t\tgf_isom_get_visual_info(dest, i+1, 1, &w, &h);\n\t\t\tif (w > f_w) f_w = w;\n\t\t\tif (h > f_h) f_h = h;\n\t\t\tgf_isom_get_track_layout_info(dest, i+1, &w, &h, NULL, NULL, NULL);\n\t\t\tif (w > f_w) f_w = w;\n\t\t\tif (h > f_h) f_h = h;\n\t\t\tbreak;\n\t\t}\n\t}\n\t(*width) = f_w ? f_w : TTXT_DEFAULT_WIDTH;\n\t(*height) = f_h ? f_h : TTXT_DEFAULT_HEIGHT;\n}\n\n\nvoid gf_text_import_set_language(GF_MediaImporter *import, u32 track)\n{\n\tif (import->esd && import->esd->langDesc) {\n\t\tchar lang[4];\n\t\tlang[0] = (import->esd->langDesc->langCode>>16) & 0xFF;\n\t\tlang[1] = (import->esd->langDesc->langCode>>8) & 0xFF;\n\t\tlang[2] = (import->esd->langDesc->langCode) & 0xFF;\n\t\tlang[3] = 0;\n\t\tgf_isom_set_media_language(import->dest, track, lang);\n\t}\n}\n#endif\n\nchar *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicode_type)\n{\n\tu32 i, j, len;\n\tchar *sOK;\n\tchar szLineConv[1024];\n\tunsigned short *sptr;\n\n\tmemset(szLine, 0, sizeof(char)*lineSize);\n\tsOK = fgets(szLine, lineSize, txt_in);\n\tif (!sOK) return NULL;\n\tif (unicode_type<=1) {\n\t\tj=0;\n\t\tlen = (u32) strlen(szLine);\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif (!unicode_type && (szLine[i] & 0x80)) {\n\t\t\t\t/*non UTF8 (likely some win-CP)*/\n\t\t\t\tif ((szLine[i+1] & 0xc0) != 0x80) {\n\t\t\t\t\tszLineConv[j] = 0xc0 | ( (szLine[i] >> 6) & 0x3 );\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[i] &= 0xbf;\n\t\t\t\t}\n\t\t\t\t/*UTF8 2 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xe0) == 0xc0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 3 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf0) == 0xe0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 4 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf8) == 0xf0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t} else {\n\t\t\t\t\ti+=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tszLineConv[j] = szLine[i];\n\t\t\tj++;\n\t\t}\n\t\tszLineConv[j] = 0;\n\t\tstrcpy(szLine, szLineConv);\n\t\treturn sOK;\n\t}\n\n#ifdef GPAC_BIG_ENDIAN\n\tif (unicode_type==3) {\n#else\n\tif (unicode_type==2) {\n#endif\n\t\ti=0;\n\t\twhile (1) {\n\t\t\tchar c;\n\t\t\tif (!szLine[i] && !szLine[i+1]) break;\n\t\t\tc = szLine[i+1];\n\t\t\tszLine[i+1] = szLine[i];\n\t\t\tszLine[i] = c;\n\t\t\ti+=2;\n\t\t}\n\t}\n\tsptr = (u16 *)szLine;\n\ti = (u32) gf_utf8_wcstombs(szLineConv, 1024, (const unsigned short **) &sptr);\n\tif (i >= (u32)ARRAY_LENGTH(szLineConv))\n\t\treturn NULL;\n\tszLineConv[i] = 0;\n\tstrcpy(szLine, szLineConv);\n\t/*this is ugly indeed: since input is UTF16-LE, there are many chances the fgets never reads the \\0 after a \\n*/\n\tif (unicode_type==3) fgetc(txt_in);\n\treturn sOK;\n}\n\n\n#ifndef GPAC_DISABLE_MEDIA_IMPORT\n\nstatic GF_Err gf_text_import_srt(GF_MediaImporter *import)\n{\n\tFILE *srt_in;\n\tu32 track, timescale, i, count;\n\tGF_TextConfig*cfg;\n\tGF_Err e;\n\tGF_StyleRecord rec;\n\tGF_TextSample * samp;\n\tGF_ISOSample *s;\n\tu32 sh, sm, ss, sms, eh, em, es, ems, txt_line, char_len, char_line, nb_samp, j, duration, rem_styles;\n\tBool set_start_char, set_end_char, first_samp, rem_color;\n\tu64 start, end, prev_end, file_size;\n\tu32 state, curLine, line, len, ID, OCR_ES_ID, default_color;\n\ts32 unicode_type;\n\tchar szLine[2048], szText[2048], *ptr;\n\tunsigned short uniLine[5000], uniText[5000], *sptr;\n\n\tsrt_in = gf_fopen(import->in_name, \"rt\");\n\tgf_fseek(srt_in, 0, SEEK_END);\n\tfile_size = gf_ftell(srt_in);\n\tgf_fseek(srt_in, 0, SEEK_SET);\n\n\tunicode_type = gf_text_get_utf_type(srt_in);\n\tif (unicode_type<0) {\n\t\tgf_fclose(srt_in);\n\t\treturn gf_import_message(import, GF_NOT_SUPPORTED, \"Unsupported SRT UTF encoding\");\n\t}\n\n\tcfg = NULL;\n\tif (import->esd) {\n\t\tif (!import->esd->slConfig) {\n\t\t\timport->esd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\t\timport->esd->slConfig->predefined = 2;\n\t\t\timport->esd->slConfig->timestampResolution = 1000;\n\t\t}\n\t\ttimescale = import->esd->slConfig->timestampResolution;\n\t\tif (!timescale) timescale = 1000;\n\n\t\t/*explicit text config*/\n\t\tif (import->esd->decoderConfig && import->esd->decoderConfig->decoderSpecificInfo->tag == GF_ODF_TEXT_CFG_TAG) {\n\t\t\tcfg = (GF_TextConfig *) import->esd->decoderConfig->decoderSpecificInfo;\n\t\t\timport->esd->decoderConfig->decoderSpecificInfo = NULL;\n\t\t}\n\t\tID = import->esd->ESID;\n\t\tOCR_ES_ID = import->esd->OCRESID;\n\t} else {\n\t\ttimescale = 1000;\n\t\tOCR_ES_ID = ID = 0;\n\t}\n\n\tif (cfg && cfg->timescale) timescale = cfg->timescale;\n\ttrack = gf_isom_new_track(import->dest, ID, GF_ISOM_MEDIA_TEXT, timescale);\n\tif (!track) {\n\t\tgf_fclose(srt_in);\n\t\treturn gf_import_message(import, gf_isom_last_error(import->dest), \"Error creating text track\");\n\t}\n\tgf_isom_set_track_enabled(import->dest, track, 1);\n\timport->final_trackID = gf_isom_get_track_id(import->dest, track);\n\tif (import->esd && !import->esd->ESID) import->esd->ESID = import->final_trackID;\n\n\tif (OCR_ES_ID) gf_isom_set_track_reference(import->dest, track, GF_ISOM_REF_OCR, OCR_ES_ID);\n\n\t/*setup track*/\n\tif (cfg) {\n\t\tchar *firstFont = NULL;\n\t\t/*set track info*/\n\t\tgf_isom_set_track_layout_info(import->dest, track, cfg->text_width<<16, cfg->text_height<<16, 0, 0, cfg->layer);\n\n\t\t/*and set sample descriptions*/\n\t\tcount = gf_list_count(cfg->sample_descriptions);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_TextSampleDescriptor *sd= (GF_TextSampleDescriptor *)gf_list_get(cfg->sample_descriptions, i);\n\t\t\tif (!sd->font_count) {\n\t\t\t\tsd->fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\t\t\tsd->font_count = 1;\n\t\t\t\tsd->fonts[0].fontID = 1;\n\t\t\t\tsd->fonts[0].fontName = gf_strdup(\"Serif\");\n\t\t\t}\n\t\t\tif (!sd->default_style.fontID) sd->default_style.fontID = sd->fonts[0].fontID;\n\t\t\tif (!sd->default_style.font_size) sd->default_style.font_size = 16;\n\t\t\tif (!sd->default_style.text_color) sd->default_style.text_color = 0xFF000000;\n\t\t\t/*store attribs*/\n\t\t\tif (!i) rec = sd->default_style;\n\n\t\t\tgf_isom_new_text_description(import->dest, track, sd, NULL, NULL, &state);\n\t\t\tif (!firstFont) firstFont = sd->fonts[0].fontName;\n\t\t}\n\t\tgf_import_message(import, GF_OK, \"Timed Text (SRT) import - text track %d x %d, font %s (size %d)\", cfg->text_width, cfg->text_height, firstFont, rec.font_size);\n\n\t\tgf_odf_desc_del((GF_Descriptor *)cfg);\n\t} else {\n\t\tu32 w, h;\n\t\tGF_TextSampleDescriptor *sd;\n\t\tgf_text_get_video_size(import, &w, &h);\n\n\t\t/*have to work with default - use max size (if only one video, this means the text region is the\n\t\tentire display, and with bottom alignment things should be fine...*/\n\t\tgf_isom_set_track_layout_info(import->dest, track, w<<16, h<<16, 0, 0, 0);\n\t\tsd = (GF_TextSampleDescriptor*)gf_odf_desc_new(GF_ODF_TX3G_TAG);\n\t\tsd->fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\tsd->font_count = 1;\n\t\tsd->fonts[0].fontID = 1;\n\t\tsd->fonts[0].fontName = gf_strdup(import->fontName ? import->fontName : \"Serif\");\n\t\tsd->back_color = 0x00000000;\t/*transparent*/\n\t\tsd->default_style.fontID = 1;\n\t\tsd->default_style.font_size = import->fontSize ? import->fontSize : TTXT_DEFAULT_FONT_SIZE;\n\t\tsd->default_style.text_color = 0xFFFFFFFF;\t/*white*/\n\t\tsd->default_style.style_flags = 0;\n\t\tsd->horiz_justif = 1; /*center of scene*/\n\t\tsd->vert_justif = (s8) -1;\t/*bottom of scene*/\n\n\t\tif (import->flags & GF_IMPORT_SKIP_TXT_BOX) {\n\t\t\tsd->default_pos.top = sd->default_pos.left = sd->default_pos.right = sd->default_pos.bottom = 0;\n\t\t} else {\n\t\t\tif ((sd->default_pos.bottom==sd->default_pos.top) || (sd->default_pos.right==sd->default_pos.left)) {\n\t\t\t\tsd->default_pos.left = import->text_x;\n\t\t\t\tsd->default_pos.top = import->text_y;\n\t\t\t\tsd->default_pos.right = (import->text_width ? import->text_width : w) + sd->default_pos.left;\n\t\t\t\tsd->default_pos.bottom = (import->text_height ? import->text_height : h) + sd->default_pos.top;\n\t\t\t}\n\t\t}\n\n\t\t/*store attribs*/\n\t\trec = sd->default_style;\n\t\tgf_isom_new_text_description(import->dest, track, sd, NULL, NULL, &state);\n\n\t\tgf_import_message(import, GF_OK, \"Timed Text (SRT) import - text track %d x %d, font %s (size %d)\", w, h, sd->fonts[0].fontName, rec.font_size);\n\t\tgf_odf_desc_del((GF_Descriptor *)sd);\n\t}\n\tgf_text_import_set_language(import, track);\n\tduration = (u32) (((Double) import->duration)*timescale/1000.0);\n\n\tdefault_color = rec.text_color;\n\n\te = GF_OK;\n\tstate = 0;\n\tend = prev_end = 0;\n\tcurLine = 0;\n\ttxt_line = 0;\n\tset_start_char = set_end_char = GF_FALSE;\n\tchar_len = 0;\n\tstart = 0;\n\tnb_samp = 0;\n\tsamp = gf_isom_new_text_sample();\n\n\tfirst_samp = GF_TRUE;\n\twhile (1) {\n\t\tchar *sOK = gf_text_get_utf8_line(szLine, 2048, srt_in, unicode_type);\n\n\t\tif (sOK) REM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\t\t\tif (!sOK || !strlen(szLine)) {\n\t\t\t\trec.style_flags = 0;\n\t\t\t\trec.startCharOffset = rec.endCharOffset = 0;\n\t\t\t\tif (txt_line) {\n\t\t\t\t\tif (prev_end && (start != prev_end)) {\n\t\t\t\t\t\tGF_TextSample * empty_samp = gf_isom_new_text_sample();\n\t\t\t\t\t\ts = gf_isom_text_to_sample(empty_samp);\n\t\t\t\t\t\tgf_isom_delete_text_sample(empty_samp);\n\t\t\t\t\t\tif (state<=2) {\n\t\t\t\t\t\t\ts->DTS = (u64) ((timescale*prev_end)/1000);\n\t\t\t\t\t\t\ts->IsRAP = RAP;\n\t\t\t\t\t\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\t\t\t\t\t\tnb_samp++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_sample_del(&s);\n\t\t\t\t\t}\n\n\t\t\t\t\ts = gf_isom_text_to_sample(samp);\n\t\t\t\t\tif (state<=2) {\n\t\t\t\t\t\ts->DTS = (u64) ((timescale*start)/1000);\n\t\t\t\t\t\ts->IsRAP = RAP;\n\t\t\t\t\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\t\t\t\t\tgf_isom_sample_del(&s);\n\t\t\t\t\t\tnb_samp++;\n\t\t\t\t\t\tprev_end = end;\n\t\t\t\t\t}\n\t\t\t\t\ttxt_line = 0;\n\t\t\t\t\tchar_len = 0;\n\t\t\t\t\tset_start_char = set_end_char = GF_FALSE;\n\t\t\t\t\trec.startCharOffset = rec.endCharOffset = 0;\n\t\t\t\t\tgf_isom_text_reset(samp);\n\n\t\t\t\t\t//gf_import_progress(import, nb_samp, nb_samp+1);\n\t\t\t\t\tgf_set_progress(\"Importing SRT\", gf_ftell(srt_in), file_size);\n\t\t\t\t\tif (duration && (end >= duration)) break;\n\t\t\t\t}\n\t\t\t\tstate = 0;\n\t\t\t\tif (!sOK) break;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\tswitch (state) {\n\t\tcase 0:\n\t\t\tif (sscanf(szLine, \"%u\", &line) != 1) {\n\t\t\t\te = gf_import_message(import, GF_CORRUPTED_DATA, \"Bad SRT formatting - expecting number got \\\"%s\\\"\", szLine);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tif (line != curLine + 1) gf_import_message(import, GF_OK, \"WARNING: corrupted SRT frame %d after frame %d\", line, curLine);\n\t\t\tcurLine = line;\n\t\t\tstate = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (sscanf(szLine, \"%u:%u:%u,%u --> %u:%u:%u,%u\", &sh, &sm, &ss, &sms, &eh, &em, &es, &ems) != 8) {\n\t\t\t\tsh = eh = 0;\n\t\t\t\tif (sscanf(szLine, \"%u:%u,%u --> %u:%u,%u\", &sm, &ss, &sms, &em, &es, &ems) != 6) {\n\t\t\t\t\te = gf_import_message(import, GF_CORRUPTED_DATA, \"Error scanning SRT frame %d timing\", curLine);\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstart = (3600*sh + 60*sm + ss)*1000 + sms;\n\t\t\tif (start<end) {\n\t\t\t\tgf_import_message(import, GF_OK, \"WARNING: overlapping SRT frame %d - starts \"LLD\" ms is before end of previous one \"LLD\" ms - adjusting time stamps\", curLine, start, end);\n\t\t\t\tstart = end;\n\t\t\t}\n\n\t\t\tend = (3600*eh + 60*em + es)*1000 + ems;\n\t\t\t/*make stream start at 0 by inserting a fake AU*/\n\t\t\tif (first_samp && (start>0)) {\n\t\t\t\ts = gf_isom_text_to_sample(samp);\n\t\t\t\ts->DTS = 0;\n\t\t\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\t\t\tgf_isom_sample_del(&s);\n\t\t\t\tnb_samp++;\n\t\t\t}\n\t\t\trec.style_flags = 0;\n\t\t\tstate = 2;\n\t\t\tif (end<=prev_end) {\n\t\t\t\tgf_import_message(import, GF_OK, \"WARNING: overlapping SRT frame %d end \"LLD\" is at or before previous end \"LLD\" - removing\", curLine, end, prev_end);\n\t\t\t\tstart = end;\n\t\t\t\tstate = 3;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/*reset only when text is present*/\n\t\t\tfirst_samp = GF_FALSE;\n\n\t\t\t/*go to line*/\n\t\t\tif (txt_line) {\n\t\t\t\tgf_isom_text_add_text(samp, \"\\n\", 1);\n\t\t\t\tchar_len += 1;\n\t\t\t}\n\n\t\t\tptr = (char *) szLine;\n\t\t\t{\n\t\t\t\tsize_t _len = gf_utf8_mbstowcs(uniLine, 5000, (const char **) &ptr);\n\t\t\t\tif (_len == (size_t) -1) {\n\t\t\t\t\te = gf_import_message(import, GF_CORRUPTED_DATA, \"Invalid UTF data (line %d)\", curLine);\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tlen = (u32) _len;\n\t\t\t}\n\t\t\ti=j=0;\n\t\t\trem_styles = 0;\n\t\t\trem_color = 0;\n\t\t\twhile (i<len) {\n\t\t\t\tu32 font_style = 0;\n\t\t\t\tu32 style_nb_chars = 0;\n\t\t\t\tu32 style_def_type = 0;\n\n\t\t\t\tif ( (uniLine[i]=='<') && (uniLine[i+2]=='>')) {\n\t\t\t\t\tstyle_nb_chars = 3;\n\t\t\t\t\tstyle_def_type = 1;\n\t\t\t\t}\n\t\t\t\telse if ( (uniLine[i]=='<') && (uniLine[i+1]=='/') && (uniLine[i+3]=='>')) {\n\t\t\t\t\tstyle_def_type = 2;\n\t\t\t\t\tstyle_nb_chars = 4;\n\t\t\t\t}\n\t\t\t\telse if (uniLine[i]=='<')  {\n\t\t\t\t\tconst unsigned short* src = uniLine + i;\n\t\t\t\t\tsize_t alen = gf_utf8_wcstombs(szLine, 2048, (const unsigned short**) & src);\n\t\t\t\t\tszLine[alen] = 0;\n\t\t\t\t\tstrlwr(szLine);\n\t\t\t\t\tif (!strncmp(szLine, \"<font \", 6) ) {\n\t\t\t\t\t\tchar *a_sep = strstr(szLine, \"color\");\n\t\t\t\t\t\tif (a_sep) a_sep = strchr(a_sep, '\"');\n\t\t\t\t\t\tif (a_sep) {\n\t\t\t\t\t\t\tchar *e_sep = strchr(a_sep+1, '\"');\n\t\t\t\t\t\t\tif (e_sep) {\n\t\t\t\t\t\t\t\te_sep[0] = 0;\n\t\t\t\t\t\t\t\tfont_style = gf_color_parse(a_sep+1);\n\t\t\t\t\t\t\t\te_sep[0] = '\"';\n\t\t\t\t\t\t\t\te_sep = strchr(e_sep+1, '>');\n\t\t\t\t\t\t\t\tif (e_sep) {\n\t\t\t\t\t\t\t\t\tstyle_nb_chars = (u32) (1 + e_sep - szLine);\n\t\t\t\t\t\t\t\t\tstyle_def_type = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strncmp(szLine, \"</font>\", 7) ) {\n\t\t\t\t\t\tstyle_nb_chars = 7;\n\t\t\t\t\t\tstyle_def_type = 2;\n\t\t\t\t\t\tfont_style = 0xFFFFFFFF;\n\t\t\t\t\t}\n\t\t\t\t\t//skip unknown\n\t\t\t\t\telse {\n\t\t\t\t\t\tchar *a_sep = strstr(szLine, \">\");\n\t\t\t\t\t\tif (a_sep) {\n\t\t\t\t\t\t\tstyle_nb_chars = (u32) (a_sep - szLine);\n\t\t\t\t\t\t\ti += style_nb_chars;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t/*start of new style*/\n\t\t\t\tif (style_def_type==1)  {\n\t\t\t\t\t/*store prev style*/\n\t\t\t\t\tif (set_end_char) {\n\t\t\t\t\t\tassert(set_start_char);\n\t\t\t\t\t\tgf_isom_text_add_style(samp, &rec);\n\t\t\t\t\t\tset_end_char = set_start_char = GF_FALSE;\n\t\t\t\t\t\trec.style_flags &= ~rem_styles;\n\t\t\t\t\t\trem_styles = 0;\n\t\t\t\t\t\tif (rem_color) {\n\t\t\t\t\t\t\trec.text_color = default_color;\n\t\t\t\t\t\t\trem_color = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (set_start_char && (rec.startCharOffset != j)) {\n\t\t\t\t\t\trec.endCharOffset = char_len + j;\n\t\t\t\t\t\tif (rec.style_flags) gf_isom_text_add_style(samp, &rec);\n\t\t\t\t\t}\n\t\t\t\t\tswitch (uniLine[i+1]) {\n\t\t\t\t\tcase 'b':\n\t\t\t\t\tcase 'B':\n\t\t\t\t\t\trec.style_flags |= GF_TXT_STYLE_BOLD;\n\t\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\t\trec.startCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'i':\n\t\t\t\t\tcase 'I':\n\t\t\t\t\t\trec.style_flags |= GF_TXT_STYLE_ITALIC;\n\t\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\t\trec.startCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\tcase 'U':\n\t\t\t\t\t\trec.style_flags |= GF_TXT_STYLE_UNDERLINED;\n\t\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\t\trec.startCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'f':\n\t\t\t\t\tcase 'F':\n\t\t\t\t\t\tif (font_style) {\n\t\t\t\t\t\t\trec.text_color = font_style;\n\t\t\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\t\t\trec.startCharOffset = char_len + j;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ti += style_nb_chars;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/*end of prev style*/\n\t\t\t\tif (style_def_type==2)  {\n\t\t\t\t\tswitch (uniLine[i+2]) {\n\t\t\t\t\tcase 'b':\n\t\t\t\t\tcase 'B':\n\t\t\t\t\t\trem_styles |= GF_TXT_STYLE_BOLD;\n\t\t\t\t\t\tset_end_char = GF_TRUE;\n\t\t\t\t\t\trec.endCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'i':\n\t\t\t\t\tcase 'I':\n\t\t\t\t\t\trem_styles |= GF_TXT_STYLE_ITALIC;\n\t\t\t\t\t\tset_end_char = GF_TRUE;\n\t\t\t\t\t\trec.endCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\tcase 'U':\n\t\t\t\t\t\trem_styles |= GF_TXT_STYLE_UNDERLINED;\n\t\t\t\t\t\tset_end_char = GF_TRUE;\n\t\t\t\t\t\trec.endCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'f':\n\t\t\t\t\tcase 'F':\n\t\t\t\t\t\tif (font_style) {\n\t\t\t\t\t\t\trem_color = 1;\n\t\t\t\t\t\t\tset_end_char = GF_TRUE;\n\t\t\t\t\t\t\trec.endCharOffset = char_len + j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti+=style_nb_chars;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*store style*/\n\t\t\t\tif (set_end_char) {\n\t\t\t\t\tgf_isom_text_add_style(samp, &rec);\n\t\t\t\t\tset_end_char = GF_FALSE;\n\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\trec.startCharOffset = char_len + j;\n\t\t\t\t\trec.style_flags &= ~rem_styles;\n\t\t\t\t\trem_styles = 0;\n\t\t\t\t\trec.text_color = default_color;\n\t\t\t\t\trem_color = 0;\n\t\t\t\t}\n\n\t\t\t\tuniText[j] = uniLine[i];\n\t\t\t\tj++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t/*store last style*/\n\t\t\tif (set_end_char) {\n\t\t\t\tgf_isom_text_add_style(samp, &rec);\n\t\t\t\tset_end_char = GF_FALSE;\n\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\trec.startCharOffset = char_len + j;\n\t\t\t\trec.style_flags &= ~rem_styles;\n\t\t\t}\n\n\t\t\tchar_line = j;\n\t\t\tuniText[j] = 0;\n\n\t\t\tsptr = (u16 *) uniText;\n\t\t\tlen = (u32) gf_utf8_wcstombs(szText, 5000, (const u16 **) &sptr);\n\n\t\t\tgf_isom_text_add_text(samp, szText, len);\n\t\t\tchar_len += char_line;\n\t\t\ttxt_line ++;\n\t\t\tbreak;\n\t\t}\n\t\tif (duration && (start >= duration)) {\n\t\t\tend = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*final flush*/\t\n\tif (end && !(import->flags & GF_IMPORT_NO_TEXT_FLUSH ) ) {\n\t\tgf_isom_text_reset(samp);\n\t\ts = gf_isom_text_to_sample(samp);\n\t\ts->DTS = (u64) ((timescale*end)/1000);\n\t\ts->IsRAP = RAP;\n\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\tgf_isom_sample_del(&s);\n\t\tnb_samp++;\n\t\tgf_isom_set_last_sample_duration(import->dest, track, 0);\n\t} else {\n\t\tif (duration && (start >= duration)) {\n\t\t\tgf_isom_set_last_sample_duration(import->dest, track, (timescale*duration)/1000);\n\t\t} else {\n\t\t\tgf_isom_set_last_sample_duration(import->dest, track, 0);\n\t\t}\n\t}\n\tgf_isom_delete_text_sample(samp);\n\tgf_set_progress(\"Importing SRT\", nb_samp, nb_samp);\n\nexit:\n\tif (e) gf_isom_remove_track(import->dest, track);\n\tgf_fclose(srt_in);\n\treturn e;\n}\n\n/* Structure used to pass importer and track data to the parsers without exposing the GF_MediaImporter structure\n   used by WebVTT and Flash->SVG */\ntypedef struct {\n\tGF_MediaImporter *import;\n\tu32 timescale;\n\tu32 track;\n\tu32 descriptionIndex;\n} GF_ISOFlusher;\n\n#ifndef GPAC_DISABLE_VTT\n\nstatic GF_Err gf_webvtt_import_report(void *user, GF_Err e, char *message, const char *line)\n{\n\tGF_ISOFlusher     *flusher = (GF_ISOFlusher *)user;\n\treturn gf_import_message(flusher->import, e, message, line);\n}\n\nstatic void gf_webvtt_import_header(void *user, const char *config)\n{\n\tGF_ISOFlusher     *flusher = (GF_ISOFlusher *)user;\n\tgf_isom_update_webvtt_description(flusher->import->dest, flusher->track, flusher->descriptionIndex, config);\n}\n\nstatic void gf_webvtt_flush_sample_to_iso(void *user, GF_WebVTTSample *samp)\n{\n\tGF_ISOSample            *s;\n\tGF_ISOFlusher     *flusher = (GF_ISOFlusher *)user;\n\t//gf_webvtt_dump_sample(stdout, samp);\n\ts = gf_isom_webvtt_to_sample(samp);\n\tif (s) {\n\t\ts->DTS = (u64) (flusher->timescale*gf_webvtt_sample_get_start(samp)/1000);\n\t\ts->IsRAP = RAP;\n\t\tgf_isom_add_sample(flusher->import->dest, flusher->track, flusher->descriptionIndex, s);\n\t\tgf_isom_sample_del(&s);\n\t}\n\tgf_webvtt_sample_del(samp);\n}\n\nstatic GF_Err gf_text_import_webvtt(GF_MediaImporter *import)\n{\n\tGF_Err\t\t\t\t\t\te;\n\tu32\t\t\t\t\t\t\ttrack;\n\tu32\t\t\t\t\t\t\ttimescale;\n\tu32\t\t\t\t\t\t\tduration;\n\tu32\t\t\t\t\t\t\tdescIndex=1;\n\tu32\t\t\t\t\t\t\tID;\n\tu32\t\t\t\t\t\t\tOCR_ES_ID;\n\tGF_GenericSubtitleConfig\t*cfg;\n\tGF_WebVTTParser\t\t\t\t*vttparser;\n\tGF_ISOFlusher\t\t\t\tflusher;\n\n\tcfg\t= NULL;\n\tif (import->esd) {\n\t\tif (!import->esd->slConfig)\t{\n\t\t\timport->esd->slConfig =\t(GF_SLConfig *)\tgf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\t\timport->esd->slConfig->predefined =\t2;\n\t\t\timport->esd->slConfig->timestampResolution = 1000;\n\t\t}\n\t\ttimescale =\timport->esd->slConfig->timestampResolution;\n\t\tif (!timescale)\ttimescale =\t1000;\n\n\t\t/*explicit text\tconfig*/\n\t\tif (import->esd->decoderConfig && import->esd->decoderConfig->decoderSpecificInfo->tag == GF_ODF_GEN_SUB_CFG_TAG) {\n\t\t\tcfg\t= (GF_GenericSubtitleConfig\t*) import->esd->decoderConfig->decoderSpecificInfo;\n\t\t\timport->esd->decoderConfig->decoderSpecificInfo\t= NULL;\n\t\t}\n\t\tID = import->esd->ESID;\n\t\tOCR_ES_ID =\timport->esd->OCRESID;\n\t} else {\n\t\ttimescale =\t1000;\n\t\tOCR_ES_ID =\tID = 0;\n\t}\n\n\tif (cfg\t&& cfg->timescale) timescale = cfg->timescale;\n\ttrack =\tgf_isom_new_track(import->dest,\tID,\tGF_ISOM_MEDIA_TEXT,\ttimescale);\n\tif (!track)\t{\n\t\treturn gf_import_message(import, gf_isom_last_error(import->dest), \"Error creating WebVTT track\");\n\t}\n\tgf_isom_set_track_enabled(import->dest, track, 1);\n\timport->final_trackID = gf_isom_get_track_id(import->dest, track);\n\tif (import->esd && !import->esd->ESID) import->esd->ESID = import->final_trackID;\n\n\tif (OCR_ES_ID) gf_isom_set_track_reference(import->dest, track,\tGF_ISOM_REF_OCR, OCR_ES_ID);\n\n\t/*setup\ttrack*/\n\tif (cfg) {\n\t\tu32\ti;\n\t\tu32\tcount;\n\t\t/*set track\tinfo*/\n\t\tgf_isom_set_track_layout_info(import->dest,\ttrack, cfg->text_width<<16,\tcfg->text_height<<16, 0, 0,\tcfg->layer);\n\n\t\t/*and set sample descriptions*/\n\t\tcount =\tgf_list_count(cfg->sample_descriptions);\n\t\tfor\t(i=0; i<count; i++)\t{\n\t\t\tgf_isom_new_webvtt_description(import->dest, track, NULL, NULL, NULL, &descIndex);\n\t\t}\n\t\tgf_import_message(import, GF_OK, \"WebVTT import\t- text track %d\tx %d\", cfg->text_width,\tcfg->text_height);\n\t\tgf_odf_desc_del((GF_Descriptor *)cfg);\n\t} else {\n\t\tu32\tw;\n\t\tu32\th;\n\n\t\tgf_text_get_video_size(import, &w, &h);\n\t\tgf_isom_set_track_layout_info(import->dest,\ttrack, w<<16, h<<16, 0,\t0, 0);\n\n\t\tgf_isom_new_webvtt_description(import->dest, track,\tNULL, NULL,\tNULL, &descIndex);\n\n\t\tgf_import_message(import, GF_OK, \"WebVTT import\");\n\t}\n\tgf_text_import_set_language(import, track);\n\tduration = (u32) (((Double) import->duration)*timescale/1000.0);\n\n\tvttparser = gf_webvtt_parser_new();\n\tflusher.import = import;\n\tflusher.timescale = timescale;\n\tflusher.track = track;\n\tflusher.descriptionIndex = descIndex;\n\te = gf_webvtt_parser_init(vttparser, import->in_name, &flusher, gf_webvtt_import_report, gf_webvtt_flush_sample_to_iso, gf_webvtt_import_header);\n\tif (e != GF_OK) {\n\t\tgf_webvtt_parser_del(vttparser);\n\t\treturn gf_import_message(import, GF_NOT_SUPPORTED, \"Unsupported WebVTT UTF encoding\");\n\t}\n\te = gf_webvtt_parser_parse(vttparser, duration);\n\tif (e != GF_OK) {\n\t\tgf_isom_remove_track(import->dest, track);\n\t}\n\n\t/*do not add any empty sample at the end since it modifies track duration and is not needed - it is the player job\n\tto figure out when to stop displaying the last text sample\n\tHowever update the last sample duration*/\n\tgf_isom_set_last_sample_duration(import->dest, track, (u32) gf_webvtt_parser_last_duration(vttparser));\n\t\n\tgf_webvtt_parser_del(vttparser);\n\treturn e;\n}\n\n#endif /*GPAC_DISABLE_VTT*/\n\nstatic char *ttxt_parse_string(GF_MediaImporter *import, char *str, Bool strip_lines)\n{\n\tu32 i=0;\n\tu32 k=0;\n\tu32 len = (u32) strlen(str);\n\tu32 state = 0;\n\n\tif (!strip_lines) {\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif ((str[i] == '\\r') && (str[i+1] == '\\n')) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tstr[k] = str[i];\n\t\t\tk++;\n\t\t}\n\t\tstr[k]=0;\n\t\treturn str;\n\t}\n\n\tif (str[0]!='\\'') return str;\n\tfor (i=0; i<len; i++) {\n\t\tif (str[i] == '\\'') {\n\n\t\t\tif (!state) {\n\t\t\t\tif (k) {\n\t\t\t\t\tstr[k]='\\n';\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\tstate = !state;\n\t\t\t} else if (state) {\n\t\t\t\tif ( (i+1==len) ||\n\t\t\t\t        ((str[i+1]==' ') || (str[i+1]=='\\n') || (str[i+1]=='\\r') || (str[i+1]=='\\t') || (str[i+1]=='\\''))\n\t\t\t\t   ) {\n\t\t\t\t\tstate = !state;\n\t\t\t\t} else {\n\t\t\t\t\tstr[k] = str[i];\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (state) {\n\t\t\tstr[k] = str[i];\n\t\t\tk++;\n\t\t}\n\t}\n\tstr[k]=0;\n\treturn str;\n}\n\nstatic void ttml_import_progress(void *cbk, u64 cur_samp, u64 count)\n{\n\tgf_set_progress(\"TTML Loading\", cur_samp, count);\n}\n\nstatic void gf_text_import_ebu_ttd_remove_samples(GF_XMLNode *root, GF_XMLNode **sample_list_node)\n{\n\tu32 idx = 0, body_num = 0;\n\tGF_XMLNode *node = NULL;\n\t*sample_list_node = NULL;\n\twhile ( (node = (GF_XMLNode*)gf_list_enum(root->content, &idx))) {\n\t\tif (!strcmp(node->name, \"body\")) {\n\t\t\tGF_XMLNode *body_node;\n\t\t\tu32 body_idx = 0;\n\t\t\twhile ( (body_node = (GF_XMLNode*)gf_list_enum(node->content, &body_idx))) {\n\t\t\t\tif (!strcmp(body_node->name, \"div\")) {\n\t\t\t\t\t*sample_list_node = body_node;\n\t\t\t\t\tbody_num = gf_list_count(body_node->content);\n\t\t\t\t\twhile (body_num--) {\n\t\t\t\t\t\tGF_XMLNode *content_node = (GF_XMLNode*)gf_list_get(body_node->content, 0);\n\t\t\t\t\t\tassert(gf_list_find(body_node->content, content_node) == 0);\n\t\t\t\t\t\tgf_list_rem(body_node->content, 0);\n\t\t\t\t\t\tgf_xml_dom_node_del(content_node);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n#define TTML_NAMESPACE \"http://www.w3.org/ns/ttml\"\nstatic GF_Err gf_text_import_ebu_ttd(GF_MediaImporter *import, GF_DOMParser *parser, GF_XMLNode *root)\n{\n\tGF_Err e, e_opt;\n\tu32 i, track, ID, desc_idx, nb_samples, nb_children;\n\tu64 last_sample_duration, last_sample_end;\n\tGF_XMLAttribute *att;\n\tGF_XMLNode *node, *root_working_copy, *sample_list_node;\n\tGF_DOMParser *parser_working_copy;\n\tchar *samp_text;\n\tBool has_body;\n\n\tsamp_text = NULL;\n\troot_working_copy = NULL;\n\tparser_working_copy = NULL;\n\n\t/*setup track in 3GP format directly (no ES desc)*/\n\tID = (import->esd) ? import->esd->ESID : 0;\n\ttrack = gf_isom_new_track(import->dest, ID, GF_ISOM_MEDIA_MPEG_SUBT, 1000);\n\tif (!track) {\n\t\te = gf_isom_last_error(import->dest);\n\t\tgoto exit;\n\t}\n\tgf_isom_set_track_enabled(import->dest, track, 1);\n\n\t/*some MPEG-4 setup*/\n\tif (import->esd) {\n\t\tif (!import->esd->ESID) import->esd->ESID = gf_isom_get_track_id(import->dest, track);\n\t\tif (!import->esd->decoderConfig) import->esd->decoderConfig = (GF_DecoderConfig *) gf_odf_desc_new(GF_ODF_DCD_TAG);\n\t\tif (!import->esd->slConfig) import->esd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\timport->esd->slConfig->timestampResolution = 1000;\n\t\timport->esd->decoderConfig->streamType = GF_STREAM_TEXT;\n\t\timport->esd->decoderConfig->objectTypeIndication = GPAC_OTI_TEXT_MPEG4;\n\t\tif (import->esd->OCRESID) gf_isom_set_track_reference(import->dest, track, GF_ISOM_REF_OCR, import->esd->OCRESID);\n\t}\n\n\tgf_import_message(import, GF_OK, \"TTML EBU-TTD Import\");\n\n\t/*** root (including language) ***/\n\ti=0;\n\twhile ( (att = (GF_XMLAttribute *)gf_list_enum(root->attributes, &i))) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"Found root attribute name %s, value %s\\n\", att->name, att->value));\n\n\t\tif (!strcmp(att->name, \"xmlns\")) {\n\t\t\tif (strcmp(att->value, TTML_NAMESPACE)) {\n\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"Found invalid EBU-TTD root attribute name %s, value %s (shall be \\\"%s\\\")\\n\", att->name, att->value, TTML_NAMESPACE);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else if (!strcmp(att->name, \"xml:lang\")) {\n\t\t\tif (import->esd && !import->esd->langDesc) {\n\t\t\t\tchar *lang;\n\t\t\t\tlang = gf_strdup(att->value);\n\t\t\t\timport->esd->langDesc = (GF_Language *) gf_odf_desc_new(GF_ODF_LANG_TAG);\n\t\t\t\tgf_isom_set_media_language(import->dest, track, lang);\n\t\t\t} else {\n\t\t\t\tgf_isom_set_media_language(import->dest, track, att->value);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*** style ***/\n#if 0\n\t{\n\t\tBool has_styling, has_style;\n\t\tGF_TextSampleDescriptor *sd;\n\t\thas_styling = GF_FALSE;\n\t\thas_style = GF_FALSE;\n\t\tsd = (GF_TextSampleDescriptor*)gf_odf_desc_new(GF_ODF_TX3G_TAG);\n\t\ti=0;\n\t\twhile ( (node = (GF_XMLNode*)gf_list_enum(root->content, &i))) {\n\t\t\tif (node->type) {\n\t\t\t\tcontinue;\n\t\t\t} else if (gf_xml_get_element_check_namespace(node, \"head\", root->ns) == GF_OK) {\n\t\t\t\tGF_XMLNode *head_node;\n\t\t\t\tu32 head_idx = 0;\n\t\t\t\twhile ( (head_node = (GF_XMLNode*)gf_list_enum(node->content, &head_idx))) {\n\t\t\t\t\tif (gf_xml_get_element_check_namespace(head_node, \"styling\", root->ns) == GF_OK) {\n\t\t\t\t\t\tGF_XMLNode *styling_node;\n\t\t\t\t\t\tu32 styling_idx;\n\t\t\t\t\t\tif (has_styling) {\n\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML EBU-TTD] duplicated \\\"styling\\\" element. Abort.\\n\");\n\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\thas_styling = GF_TRUE;\n\n\t\t\t\t\t\tstyling_idx = 0;\n\t\t\t\t\t\twhile ( (styling_node = (GF_XMLNode*)gf_list_enum(head_node->content, &styling_idx))) {\n\t\t\t\t\t\t\tif (gf_xml_get_element_check_namespace(styling_node, \"style\", root->ns) == GF_OK) {\n\t\t\t\t\t\t\t\tGF_XMLAttribute *p_att;\n\t\t\t\t\t\t\t\tu32 style_idx = 0;\n\t\t\t\t\t\t\t\twhile ( (p_att = (GF_XMLAttribute*)gf_list_enum(styling_node->attributes, &style_idx))) {\n\t\t\t\t\t\t\t\t\tif (!strcmp(p_att->name, \"tts:direction\")) {\n\t\t\t\t\t\t\t\t\t} else if (!strcmp(p_att->name, \"tts:fontFamily\")) {\n\t\t\t\t\t\t\t\t\t\tsd->fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\t\t\t\t\t\t\t\t\tsd->font_count = 1;\n\t\t\t\t\t\t\t\t\t\tsd->fonts[0].fontID = 1;\n\t\t\t\t\t\t\t\t\t\tsd->fonts[0].fontName = gf_strdup(p_att->value);\n\t\t\t\t\t\t\t\t\t} else if (!strcmp(p_att->name, \"tts:backgroundColor\")) {\n\t\t\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"EBU-TTD style attribute \\\"%s\\\" ignored.\\n\", p_att->name));\n\t\t\t\t\t\t\t\t\t\t//sd->back_color = ;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tif ( !strcmp(p_att->name, \"tts:fontSize\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:lineHeight\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:textAlign\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:color\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:fontStyle\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:fontWeight\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:textDecoration\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:unicodeBidi\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:wrapOption\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:multiRowAlign\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:linePadding\")) {\n\t\t\t\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"EBU-TTD style attribute \\\"%s\\\" ignored.\\n\", p_att->name));\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"EBU-TTD unknown style attribute: \\\"%s\\\". Ignoring.\\n\", p_att->name));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak; //TODO: we only take care of the first style\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!has_styling) {\n\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML EBU-TTD] missing \\\"styling\\\" element. Abort.\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\tif (!has_style) {\n\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML EBU-TTD] missing \\\"style\\\" element. Abort.\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\te = gf_isom_new_text_description(import->dest, track, sd, NULL, NULL, &desc_idx);\n\t\tgf_odf_desc_del((GF_Descriptor*)sd);\n\t}\n#else\n\te = gf_isom_new_xml_subtitle_description(import->dest, track, TTML_NAMESPACE, NULL, NULL, &desc_idx);\n#endif\n\tif (e != GF_OK) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] incorrect sample description. Abort.\\n\"));\n\t\te = gf_isom_last_error(import->dest);\n\t\tgoto exit;\n\t}\n\n\t/*** body ***/\n\tparser_working_copy = gf_xml_dom_new();\n\te = gf_xml_dom_parse(parser_working_copy, import->in_name, NULL, NULL);\n\tassert (e == GF_OK);\n\troot_working_copy = gf_xml_dom_get_root(parser_working_copy);\n\tassert(root_working_copy);\n\tlast_sample_duration = 0;\n\tlast_sample_end = 0;\n\tnb_samples = 0;\n\tnb_children = gf_list_count(root->content);\n\thas_body = GF_FALSE;\n\ti=0;\n\twhile ( (node = (GF_XMLNode*)gf_list_enum(root->content, &i))) {\n\t\tif (node->type) {\n\t\t\tnb_children--;\n\t\t\tcontinue;\n\t\t}\n\n\t\te_opt = gf_xml_get_element_check_namespace(node, \"body\", root->ns);\n\t\tif (e_opt == GF_BAD_PARAM) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] ignored \\\"%s\\\" node, check your namespaces\\n\", node->name));\n\t\t} else if (e_opt == GF_OK) {\n\t\t\tGF_XMLNode *body_node;\n\t\t\tu32 body_idx = 0;\n\n\t\t\tif (has_body) {\n\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML EBU-TTD] duplicated \\\"body\\\" element. Abort.\\n\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\thas_body = GF_TRUE;\n\n\t\t\t/*remove all the entries from the working copy, we'll add samples one to one to create full XML samples*/\n\t\t\tgf_text_import_ebu_ttd_remove_samples(root_working_copy, &sample_list_node);\n\n\t\t\twhile ( (body_node = (GF_XMLNode*)gf_list_enum(node->content, &body_idx))) {\n\t\t\t\te_opt = gf_xml_get_element_check_namespace(body_node, \"div\", root->ns);\n\t\t\t\tif (e_opt == GF_BAD_PARAM) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] ignored \\\"%s\\\" node, check your namespaces\\n\", node->name));\n\t\t\t\t} else if (e_opt == GF_OK) {\n\t\t\t\t\tGF_XMLNode *div_node;\n\t\t\t\t\tu32 div_idx = 0, nb_p_found = 0;\n\t\t\t\t\twhile ( (div_node = (GF_XMLNode*)gf_list_enum(body_node->content, &div_idx))) {\n\t\t\t\t\t\te_opt = gf_xml_get_element_check_namespace(div_node, \"p\", root->ns);\n\t\t\t\t\t\tif (e_opt != GF_OK) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML] ignored \\\"%s\\\" node, check your namespaces\\n\", node->name));\n\t\t\t\t\t\t} else if (e_opt == GF_OK) {\n\t\t\t\t\t\t\tGF_XMLNode *p_node;\n\t\t\t\t\t\t\tGF_XMLAttribute *p_att;\n\t\t\t\t\t\t\tu32 p_idx = 0, h, m, s, f, ms;\n\t\t\t\t\t\t\ts64 ts_begin = -1, ts_end = -1;\n\n\t\t\t\t\t\t\t//sample is either in the <p> ...\n\t\t\t\t\t\t\twhile ( (p_att = (GF_XMLAttribute*)gf_list_enum(div_node->attributes, &p_idx))) {\n\t\t\t\t\t\t\t\tif (!p_att) continue;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (!strcmp(p_att->name, \"begin\")) {\n\t\t\t\t\t\t\t\t\tif (ts_begin != -1) {\n\t\t\t\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML] duplicated \\\"begin\\\" attribute. Abort.\\n\");\n\t\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (sscanf(p_att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\t\t\t\t\tts_begin = (h*3600 + m*60+s)*1000+ms;\n\t\t\t\t\t\t\t\t\t} else if (sscanf(p_att->value, \"%u:%u:%u:%u\", &h, &m, &s, &f) == 4) {\n\t\t\t\t\t\t\t\t\t\tts_begin = (h*3600 + m*60+s)*1000+f*40;\n\t\t\t\t\t\t\t\t\t} else if (sscanf(p_att->value, \"%u:%u:%u\", &h, &m, &s) == 3) {\n\t\t\t\t\t\t\t\t\t\tts_begin = (h*3600 + m*60+s)*1000;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (!strcmp(p_att->name, \"end\")) {\n\t\t\t\t\t\t\t\t\tif (ts_end != -1) {\n\t\t\t\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML] duplicated \\\"end\\\" attribute. Abort.\\n\");\n\t\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (sscanf(p_att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000+ms;\n\t\t\t\t\t\t\t\t\t} else if (sscanf(p_att->value, \"%u:%u:%u:%u\", &h, &m, &s, &f) == 4) {\n\t\t\t\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000+f*40;\n\t\t\t\t\t\t\t\t\t} else if (sscanf(p_att->value, \"%u:%u:%u\", &h, &m, &s) == 3) {\n\t\t\t\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ((ts_begin != -1) && (ts_end != -1) && !samp_text && sample_list_node) {\n\t\t\t\t\t\t\t\t\te = gf_xml_dom_append_child(sample_list_node, div_node);\n\t\t\t\t\t\t\t\t\tassert(e == GF_OK);\n\t\t\t\t\t\t\t\t\tassert(!samp_text);\n\t\t\t\t\t\t\t\t\tsamp_text = gf_xml_dom_serialize((GF_XMLNode*)root_working_copy, GF_FALSE);\n\t\t\t\t\t\t\t\t\te = gf_xml_dom_rem_child(sample_list_node, div_node);\n\t\t\t\t\t\t\t\t\tassert(e == GF_OK);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t//or under a <span>\n\t\t\t\t\t\t\tp_idx = 0;\n\t\t\t\t\t\t\twhile ( (p_node = (GF_XMLNode*)gf_list_enum(div_node->content, &p_idx))) {\n\t\t\t\t\t\t\t\te_opt = gf_xml_get_element_check_namespace(p_node, \"span\", root->ns);\n\t\t\t\t\t\t\t\tif (e_opt == GF_BAD_PARAM) {\n\t\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML] ignored \\\"%s\\\" node, check your namespaces\\n\", node->name));\n\t\t\t\t\t\t\t\t} else if (e_opt == GF_OK) {\n\t\t\t\t\t\t\t\t\tu32 span_idx = 0;\n\t\t\t\t\t\t\t\t\tGF_XMLAttribute *span_att;\n\t\t\t\t\t\t\t\t\twhile ( (span_att = (GF_XMLAttribute*)gf_list_enum(p_node->attributes, &span_idx))) {\n\t\t\t\t\t\t\t\t\t\tif (!span_att) continue;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tif (!strcmp(span_att->name, \"begin\")) {\n\t\t\t\t\t\t\t\t\t\t\tif (ts_begin != -1) {\n\t\t\t\t\t\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML] duplicated \\\"begin\\\" attribute under <span>. Abort.\\n\");\n\t\t\t\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif (sscanf(span_att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\t\t\t\t\t\t\tts_begin = (h*3600 + m*60+s)*1000+ms;\n\t\t\t\t\t\t\t\t\t\t\t} else if (sscanf(p_att->value, \"%u:%u:%u:%u\", &h, &m, &s, &f) == 4) {\n\t\t\t\t\t\t\t\t\t\t\t\tts_begin = (h*3600 + m*60+s)*1000+f*40;\n\t\t\t\t\t\t\t\t\t\t\t} else if (sscanf(span_att->value, \"%u:%u:%u\", &h, &m, &s) == 3) {\n\t\t\t\t\t\t\t\t\t\t\t\tts_begin = (h*3600 + m*60+s)*1000;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else if (!strcmp(span_att->name, \"end\")) {\n\t\t\t\t\t\t\t\t\t\t\tif (ts_end != -1) {\n\t\t\t\t\t\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML] duplicated \\\"end\\\" attribute under <span>. Abort.\\n\");\n\t\t\t\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif (sscanf(span_att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000+ms;\n\t\t\t\t\t\t\t\t\t\t\t} else if (sscanf(p_att->value, \"%u:%u:%u:%u\", &h, &m, &s, &f) == 4) {\n\t\t\t\t\t\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000+f*40;\n\t\t\t\t\t\t\t\t\t\t\t} else if (sscanf(span_att->value, \"%u:%u:%u\", &h, &m, &s) == 3) {\n\t\t\t\t\t\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif ((ts_begin != -1) && (ts_end != -1) && !samp_text && sample_list_node) {\n\t\t\t\t\t\t\t\t\t\t\tif (samp_text) {\n\t\t\t\t\t\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML] duplicated sample text under <span>. Abort.\\n\");\n\t\t\t\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t/*append the sample*/\n\t\t\t\t\t\t\t\t\t\t\te = gf_xml_dom_append_child(sample_list_node, div_node);\n\t\t\t\t\t\t\t\t\t\t\tassert(e == GF_OK);\n\t\t\t\t\t\t\t\t\t\t\tassert(!samp_text);\n\t\t\t\t\t\t\t\t\t\t\tsamp_text = gf_xml_dom_serialize((GF_XMLNode*)root_working_copy, GF_FALSE);\n\t\t\t\t\t\t\t\t\t\t\te = gf_xml_dom_rem_child(sample_list_node, div_node);\n\t\t\t\t\t\t\t\t\t\t\tassert(e == GF_OK);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ((ts_begin != -1) && (ts_end != -1) && samp_text) {\n\t\t\t\t\t\t\t\tGF_ISOSample *s;\n\t\t\t\t\t\t\t\tGF_GenericSubtitleSample *samp;\n\t\t\t\t\t\t\t\tu32 len;\n\t\t\t\t\t\t\t\tchar *str;\n\n\t\t\t\t\t\t\t\tif (ts_end < ts_begin) {\n\t\t\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML] invalid timings: \\\"begin\\\"=\"LLD\" , \\\"end\\\"=\"LLD\". Abort.\\n\", ts_begin, ts_end);\n\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (ts_begin < (s64)last_sample_end) {\n\t\t\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML] timing overlapping not supported: \\\"begin\\\" is \"LLD\" , last \\\"end\\\" was \"LLD\". Abort.\\n\", ts_begin, last_sample_end);\n\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tstr = ttxt_parse_string(import, samp_text, GF_TRUE);\n\t\t\t\t\t\t\t\tlen = (u32) strlen(str);\n\t\t\t\t\t\t\t\tsamp = gf_isom_new_xml_subtitle_sample();\n\t\t\t\t\t\t\t\t/*each sample consists of a full valid XML file*/\n\t\t\t\t\t\t\t\te = gf_isom_xml_subtitle_sample_add_text(samp, str, len);\n\t\t\t\t\t\t\t\tif (e) {\n\t\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML] ISOM - sample add text: %s\", gf_error_to_string(e)));\n\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tgf_free(samp_text);\n\t\t\t\t\t\t\t\tsamp_text = NULL;\n\n\t\t\t\t\t\t\t\ts = gf_isom_xml_subtitle_to_sample(samp);\n\t\t\t\t\t\t\t\tgf_isom_delete_xml_subtitle_sample(samp);\n\t\t\t\t\t\t\t\tif (!nb_samples) {\n\t\t\t\t\t\t\t\t\ts->DTS = 0; /*in MP4 we must start at T=0*/\n\t\t\t\t\t\t\t\t\tlast_sample_duration = ts_end;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts->DTS = ts_begin;\n\t\t\t\t\t\t\t\t\tlast_sample_duration = ts_end - ts_begin;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlast_sample_end = ts_end;\n\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"ts_begin=\"LLD\", ts_end=\"LLD\", last_sample_duration=\"LLU\" (real duration: \"LLU\"), last_sample_end=\"LLU\"\\n\", ts_begin, ts_end, ts_end - last_sample_end, last_sample_duration, last_sample_end));\n\n\t\t\t\t\t\t\t\te = gf_isom_add_sample(import->dest, track, desc_idx, s);\n\t\t\t\t\t\t\t\tif (e) {\n\t\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML] ISOM - Add Sample: %s\", gf_error_to_string(e)));\n\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tgf_isom_sample_del(&s);\n\t\t\t\t\t\t\t\tnb_samples++;\n\n\t\t\t\t\t\t\t\tnb_p_found++;\n\t\t\t\t\t\t\t\tgf_set_progress(\"Importing TTML\", nb_samples, nb_children);\n\t\t\t\t\t\t\t\tif (import->duration && (ts_end > import->duration))\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML] incomplete sample (begin=\"LLD\", end=\"LLD\", text=\\\"%s\\\"). Skip.\\n\", ts_begin, ts_end, samp_text ? samp_text : \"NULL\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!nb_p_found) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] \\\"%s\\\" div node has no <p> elements. Aborting.\\n\", node->name));\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!has_body) {\n\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML EBU-TTD] missing \\\"body\\\" element. Abort.\\n\");\n\t\tgoto exit;\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"last_sample_duration=\"LLU\", last_sample_end=\"LLU\"\\n\", last_sample_duration, last_sample_end));\n\tgf_isom_set_last_sample_duration(import->dest, track, (u32) last_sample_duration);\n\tgf_media_update_bitrate(import->dest, track);\n\tgf_set_progress(\"Importing TTML EBU-TTD\", nb_samples, nb_samples);\n\nexit:\n\tgf_free(samp_text);\n\tgf_xml_dom_del(parser_working_copy);\n\tif (!gf_isom_get_sample_count(import->dest, track)) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] No sample imported. Might be an error. Check your content.\\n\"));\n\t}\n\treturn e;\n}\n\nstatic GF_Err gf_text_import_ttml(GF_MediaImporter *import)\n{\n\tGF_Err e;\n\tGF_DOMParser *parser;\n\tGF_XMLNode *root;\n\n\tif (import->flags == GF_IMPORT_PROBE_ONLY)\n\t\treturn GF_OK;\n\n\tparser = gf_xml_dom_new();\n\te = gf_xml_dom_parse(parser, import->in_name, ttml_import_progress, import);\n\tif (e) {\n\t\tgf_import_message(import, e, \"Error parsing TTML file: Line %d - %s. Abort.\", gf_xml_dom_get_line(parser), gf_xml_dom_get_error(parser));\n\t\tgf_xml_dom_del(parser);\n\t\treturn e;\n\t}\n\troot = gf_xml_dom_get_root(parser);\n\tif (!root) {\n\t\tgf_import_message(import, e, \"Error parsing TTML file: no \\\"root\\\" found. Abort.\");\n\t\tgf_xml_dom_del(parser);\n\t\treturn e;\n\t}\n\n\t/*look for TTML*/\n\tif (gf_xml_get_element_check_namespace(root, \"tt\", NULL) == GF_OK) {\n\t\te = gf_text_import_ebu_ttd(import, parser, root);\n\t\tif (e == GF_OK) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"Note: TTML import - EBU-TTD detected\\n\"));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"Parsing TTML file with error: %s\\n\", gf_error_to_string(e)));\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"Unsupported TTML file - only EBU-TTD is supported (root shall be \\\"tt\\\", got \\\"%s\\\")\\n\", root->name));\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"Importing as generic TTML\\n\"));\n\t\t\te = GF_OK;\n\t\t}\n\t} else {\n\t\tif (root->ns) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"TTML file not recognized: root element is \\\"%s:%s\\\" (check your namespaces)\\n\", root->ns, root->name));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"TTML file not recognized: root element is \\\"%s\\\"\\n\", root->name));\n\t\t}\n\t\te = GF_BAD_PARAM;\n\t}\n\n\tgf_xml_dom_del(parser);\n\treturn e;\n}\n\n/* SimpleText Text tracks -related functions */\nGF_Box *boxstring_new_with_data(u32 type, const char *string);\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\n/* SWF Importer */\n#include <gpac/internal/swf_dev.h>\n\nstatic GF_Err swf_svg_add_iso_sample(void *user, const char *data, u32 length, u64 timestamp, Bool isRap)\n{\n\tGF_Err\t\t\t\te = GF_OK;\n\tGF_ISOFlusher\t\t*flusher = (GF_ISOFlusher *)user;\n\tGF_ISOSample\t\t*s;\n\tGF_BitStream\t\t*bs;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (!bs) return GF_BAD_PARAM;\n\tgf_bs_write_data(bs, data, length);\n\ts = gf_isom_sample_new();\n\tif (s) {\n\t\tgf_bs_get_content(bs, &s->data, &s->dataLength);\n\t\ts->DTS = (u64) (flusher->timescale*timestamp/1000);\n\t\ts->IsRAP = isRap ? RAP : RAP_NO;\n\t\tgf_isom_add_sample(flusher->import->dest, flusher->track, flusher->descriptionIndex, s);\n\t\tgf_isom_sample_del(&s);\n\t} else {\n\t\te = GF_BAD_PARAM;\n\t}\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nstatic GF_Err swf_svg_add_iso_header(void *user, const char *data, u32 length, Bool isHeader)\n{\n\tGF_ISOFlusher\t\t*flusher = (GF_ISOFlusher *)user;\n\tif (!flusher) return GF_BAD_PARAM;\n\tif (isHeader) {\n\t\treturn gf_isom_update_stxt_description(flusher->import->dest, flusher->track, NULL, data, flusher->descriptionIndex);\n\t} else {\n\t\treturn gf_isom_append_sample_data(flusher->import->dest, flusher->track, (char *)data, length);\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_text_import_swf(GF_MediaImporter *import)\n{\n\tGF_Err\t\t\t\t\t\te = GF_OK;\n\tu32\t\t\t\t\t\t\ttrack;\n\tu32\t\t\t\t\t\t\ttimescale;\n\t//u32\t\t\t\t\t\t\tduration;\n\tu32\t\t\t\t\t\t\tdescIndex;\n\tu32\t\t\t\t\t\t\tID;\n\tu32\t\t\t\t\t\t\tOCR_ES_ID;\n\tGF_GenericSubtitleConfig\t*cfg;\n\tSWFReader\t\t\t\t\t*read;\n\tGF_ISOFlusher\t\t\t\tflusher;\n\tchar\t\t\t\t\t\t*mime;\n\n\tif (import->flags & GF_IMPORT_PROBE_ONLY) {\n\t\timport->nb_tracks = 1;\n\t\treturn GF_OK;\n\t}\n\n\tcfg\t= NULL;\n\tif (import->esd) {\n\t\tif (!import->esd->slConfig)\t{\n\t\t\timport->esd->slConfig =\t(GF_SLConfig *)\tgf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\t\timport->esd->slConfig->predefined =\t2;\n\t\t\timport->esd->slConfig->timestampResolution = 1000;\n\t\t}\n\t\ttimescale =\timport->esd->slConfig->timestampResolution;\n\t\tif (!timescale)\ttimescale =\t1000;\n\n\t\t/*explicit text\tconfig*/\n\t\tif (import->esd->decoderConfig && import->esd->decoderConfig->decoderSpecificInfo->tag == GF_ODF_GEN_SUB_CFG_TAG) {\n\t\t\tcfg\t= (GF_GenericSubtitleConfig\t*) import->esd->decoderConfig->decoderSpecificInfo;\n\t\t\timport->esd->decoderConfig->decoderSpecificInfo\t= NULL;\n\t\t}\n\t\tID = import->esd->ESID;\n\t\tOCR_ES_ID =\timport->esd->OCRESID;\n\t} else {\n\t\ttimescale =\t1000;\n\t\tOCR_ES_ID =\tID = 0;\n\t}\n\n\tif (cfg\t&& cfg->timescale) timescale = cfg->timescale;\n\ttrack =\tgf_isom_new_track(import->dest,\tID,\tGF_ISOM_MEDIA_TEXT,\ttimescale);\n\tif (!track)\t{\n\t\treturn gf_import_message(import, gf_isom_last_error(import->dest), \"Error creating text track\");\n\t}\n\tgf_isom_set_track_enabled(import->dest,\ttrack, 1);\n\tif (import->esd\t&& !import->esd->ESID) import->esd->ESID = gf_isom_get_track_id(import->dest, track);\n\n\tif (OCR_ES_ID) gf_isom_set_track_reference(import->dest, track,\tGF_ISOM_REF_OCR, OCR_ES_ID);\n\n\tif (!stricmp(import->streamFormat, \"SVG\")) {\n\t\tmime = \"image/svg+xml\";\n\t} else {\n\t\tmime = \"application/octet-stream\";\n\t}\n\n\tread = gf_swf_reader_new(NULL, import->in_name);\n\tgf_swf_read_header(read);\n\n\t/*setup\ttrack*/\n\tif (cfg) {\n\t\tu32\ti;\n\t\tu32\tcount;\n\t\t/*set track\tinfo*/\n\t\tgf_isom_set_track_layout_info(import->dest,\ttrack, cfg->text_width<<16,\tcfg->text_height<<16, 0, 0,\tcfg->layer);\n\n\t\t/*and set sample descriptions*/\n\t\tcount =\tgf_list_count(cfg->sample_descriptions);\n\t\tfor\t(i=0; i<count; i++)\t{\n\t\t\tgf_isom_new_stxt_description(import->dest, track, GF_ISOM_SUBTYPE_STXT, mime, NULL, NULL, &descIndex);\n\t\t}\n\t\tgf_import_message(import, GF_OK, \"SWF import - text track %d\tx %d\", cfg->text_width,\tcfg->text_height);\n\t\tgf_odf_desc_del((GF_Descriptor *)cfg);\n\t} else {\n\t\tu32\tw = (u32)read->width;\n\t\tu32\th = (u32)read->height;\n\n\t\tif (!w || !h)\n\t\t\tgf_text_get_video_size(import, &w, &h);\n\n\t\tgf_isom_set_track_layout_info(import->dest,\ttrack, w<<16, h<<16, 0,\t0, 0);\n\n\t\tgf_isom_new_stxt_description(import->dest, track, GF_ISOM_SUBTYPE_STXT, mime, NULL,\tNULL, &descIndex);\n\n\t\tgf_import_message(import, GF_OK, \"SWF import (as text - type: %s)\", import->streamFormat);\n\t}\n\tgf_text_import_set_language(import, track);\n\t//duration = (u32) (((Double) import->duration)*timescale/1000.0);\n\n\tflusher.import = import;\n\tflusher.track = track;\n\tflusher.timescale = timescale;\n\tflusher.descriptionIndex = descIndex;\n\tgf_swf_reader_set_user_mode(read, &flusher, swf_svg_add_iso_sample, swf_svg_add_iso_header);\n\n\tif (!import->streamFormat || (import->streamFormat && !stricmp(import->streamFormat, \"SVG\"))) {\n#ifndef GPAC_DISABLE_SVG\n\t\te = swf_to_svg_init(read, import->swf_flags, import->swf_flatten_angle);\n#endif\n\t} else { /*if (import->streamFormat && !strcmp(import->streamFormat, \"BIFS\"))*/\n#ifndef GPAC_DISABLE_VRML\n\t\te = swf_to_bifs_init(read);\n#endif\n\t}\n\tif (e) {\n\t\tgoto exit;\n\t}\n\t/*parse all tags*/\n\twhile (e == GF_OK) {\n\t\te = swf_parse_tag(read);\n\t}\n\tif (e==GF_EOS) e = GF_OK;\nexit:\n\tgf_swf_reader_del(read);\n\tgf_media_update_bitrate(import->dest, track);\n\treturn e;\n}\n/* end of SWF Importer */\n\n#else\n\nGF_EXPORT\nGF_Err gf_text_import_swf(GF_MediaImporter *import)\n{\n\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"Warning: GPAC was compiled without SWF import support, can't import track.\\n\"));\n\treturn GF_NOT_SUPPORTED;\n}\n\n#endif /*GPAC_DISABLE_SWF_IMPORT*/\n\nstatic GF_Err gf_text_import_sub(GF_MediaImporter *import)\n{\n\tFILE *sub_in;\n\tu32 track, ID, timescale, i, j, desc_idx, start, end, prev_end, nb_samp, duration, len, line;\n\tu64 file_size;\n\tGF_TextConfig*cfg;\n\tGF_Err e;\n\tDouble FPS;\n\tGF_TextSample * samp;\n\tBool first_samp;\n\ts32 unicode_type;\n\tchar szLine[2048], szTime[20], szText[2048];\n\tGF_ISOSample *s;\n\n\tsub_in = gf_fopen(import->in_name, \"rt\");\n\tunicode_type = gf_text_get_utf_type(sub_in);\n\tif (unicode_type<0) {\n\t\tgf_fclose(sub_in);\n\t\treturn gf_import_message(import, GF_NOT_SUPPORTED, \"Unsupported SUB UTF encoding\");\n\t}\n\n\tFPS = GF_IMPORT_DEFAULT_FPS;\n\tif (import->video_fps) FPS = import->video_fps;\n\n\tcfg = NULL;\n\tif (import->esd) {\n\t\tif (!import->esd->slConfig) {\n\t\t\timport->esd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\t\timport->esd->slConfig->predefined = 2;\n\t\t\timport->esd->slConfig->timestampResolution = 1000;\n\t\t}\n\t\ttimescale = import->esd->slConfig->timestampResolution;\n\t\tif (!timescale) timescale = 1000;\n\n\t\t/*explicit text config*/\n\t\tif (import->esd->decoderConfig && import->esd->decoderConfig->decoderSpecificInfo->tag == GF_ODF_TEXT_CFG_TAG) {\n\t\t\tcfg = (GF_TextConfig *) import->esd->decoderConfig->decoderSpecificInfo;\n\t\t\timport->esd->decoderConfig->decoderSpecificInfo = NULL;\n\t\t}\n\t\tID = import->esd->ESID;\n\t} else {\n\t\ttimescale = 1000;\n\t\tID = 0;\n\t}\n\n\tif (cfg && cfg->timescale) timescale = cfg->timescale;\n\ttrack = gf_isom_new_track(import->dest, ID, GF_ISOM_MEDIA_TEXT, timescale);\n\tif (!track) {\n\t\tgf_fclose(sub_in);\n\t\treturn gf_import_message(import, gf_isom_last_error(import->dest), \"Error creating text track\");\n\t}\n\tgf_isom_set_track_enabled(import->dest, track, 1);\n\tif (import->esd && !import->esd->ESID) import->esd->ESID = gf_isom_get_track_id(import->dest, track);\n\n\tgf_text_import_set_language(import, track);\n\n\tfile_size = 0;\n\t/*setup track*/\n\tif (cfg) {\n\t\tu32 count;\n\t\tchar *firstFont = NULL;\n\t\t/*set track info*/\n\t\tgf_isom_set_track_layout_info(import->dest, track, cfg->text_width<<16, cfg->text_height<<16, 0, 0, cfg->layer);\n\n\t\t/*and set sample descriptions*/\n\t\tcount = gf_list_count(cfg->sample_descriptions);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_TextSampleDescriptor *sd= (GF_TextSampleDescriptor *)gf_list_get(cfg->sample_descriptions, i);\n\t\t\tif (!sd->font_count) {\n\t\t\t\tsd->fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\t\t\tsd->font_count = 1;\n\t\t\t\tsd->fonts[0].fontID = 1;\n\t\t\t\tsd->fonts[0].fontName = gf_strdup(\"Serif\");\n\t\t\t}\n\t\t\tif (!sd->default_style.fontID) sd->default_style.fontID = sd->fonts[0].fontID;\n\t\t\tif (!sd->default_style.font_size) sd->default_style.font_size = 16;\n\t\t\tif (!sd->default_style.text_color) sd->default_style.text_color = 0xFF000000;\n\t\t\tfile_size = sd->default_style.font_size;\n\t\t\tgf_isom_new_text_description(import->dest, track, sd, NULL, NULL, &desc_idx);\n\t\t\tif (!firstFont) firstFont = sd->fonts[0].fontName;\n\t\t}\n\t\tgf_import_message(import, GF_OK, \"Timed Text (SUB @ %02.2f) import - text track %d x %d, font %s (size %d)\", FPS, cfg->text_width, cfg->text_height, firstFont, file_size);\n\n\t\tgf_odf_desc_del((GF_Descriptor *)cfg);\n\t} else {\n\t\tu32 w, h;\n\t\tGF_TextSampleDescriptor *sd;\n\t\tgf_text_get_video_size(import, &w, &h);\n\n\t\t/*have to work with default - use max size (if only one video, this means the text region is the\n\t\tentire display, and with bottom alignment things should be fine...*/\n\t\tgf_isom_set_track_layout_info(import->dest, track, w<<16, h<<16, 0, 0, 0);\n\t\tsd = (GF_TextSampleDescriptor*)gf_odf_desc_new(GF_ODF_TX3G_TAG);\n\t\tsd->fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\tsd->font_count = 1;\n\t\tsd->fonts[0].fontID = 1;\n\t\tsd->fonts[0].fontName = gf_strdup(\"Serif\");\n\t\tsd->back_color = 0x00000000;\t/*transparent*/\n\t\tsd->default_style.fontID = 1;\n\t\tsd->default_style.font_size = TTXT_DEFAULT_FONT_SIZE;\n\t\tsd->default_style.text_color = 0xFFFFFFFF;\t/*white*/\n\t\tsd->default_style.style_flags = 0;\n\t\tsd->horiz_justif = 1; /*center of scene*/\n\t\tsd->vert_justif = (s8) -1;\t/*bottom of scene*/\n\n\t\tif (import->flags & GF_IMPORT_SKIP_TXT_BOX) {\n\t\t\tsd->default_pos.top = sd->default_pos.left = sd->default_pos.right = sd->default_pos.bottom = 0;\n\t\t} else {\n\t\t\tif ((sd->default_pos.bottom==sd->default_pos.top) || (sd->default_pos.right==sd->default_pos.left)) {\n\t\t\t\tsd->default_pos.left = import->text_x;\n\t\t\t\tsd->default_pos.top = import->text_y;\n\t\t\t\tsd->default_pos.right = (import->text_width ? import->text_width : w) + sd->default_pos.left;\n\t\t\t\tsd->default_pos.bottom = (import->text_height ? import->text_height : h) + sd->default_pos.top;\n\t\t\t}\n\t\t}\n\n\t\tgf_isom_new_text_description(import->dest, track, sd, NULL, NULL, &desc_idx);\n\t\tgf_import_message(import, GF_OK, \"Timed Text (SUB @ %02.2f) import - text track %d x %d, font %s (size %d)\", FPS, w, h, sd->fonts[0].fontName, TTXT_DEFAULT_FONT_SIZE);\n\t\tgf_odf_desc_del((GF_Descriptor *)sd);\n\t}\n\n\tduration = (u32) (((Double) import->duration)*timescale/1000.0);\n\n\te = GF_OK;\n\tnb_samp = 0;\n\tsamp = gf_isom_new_text_sample();\n\n\tFPS = ((Double) timescale ) / FPS;\n\tend = prev_end = 0;\n\n\tline = 0;\n\tfirst_samp = GF_TRUE;\n\twhile (1) {\n\t\tchar *sOK = gf_text_get_utf8_line(szLine, 2048, sub_in, unicode_type);\n\t\tif (!sOK) break;\n\n\t\tREM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\n\t\tline++;\n\t\tlen = (u32) strlen(szLine);\n\t\tif (!len) continue;\n\n\t\ti=0;\n\t\tif (szLine[i] != '{') {\n\t\t\te = gf_import_message(import, GF_NON_COMPLIANT_BITSTREAM, \"Bad SUB file (line %d): expecting \\\"{\\\" got \\\"%c\\\"\", line, szLine[i]);\n\t\t\tgoto exit;\n\t\t}\n\t\twhile (szLine[i+1] && szLine[i+1]!='}') {\n\t\t\tszTime[i] = szLine[i+1];\n\t\t\ti++;\n\t\t}\n\t\tszTime[i] = 0;\n\t\tstart = atoi(szTime);\n\t\tif (start<end) {\n\t\t\tgf_import_message(import, GF_OK, \"WARNING: corrupted SUB frame (line %d) - starts (at %d ms) before end of previous one (%d ms) - adjusting time stamps\", line, start, end);\n\t\t\tstart = end;\n\t\t}\n\t\tj=i+2;\n\t\ti=0;\n\t\tif (szLine[i+j] != '{') {\n\t\t\te = gf_import_message(import, GF_NON_COMPLIANT_BITSTREAM, \"Bad SUB file - expecting \\\"{\\\" got \\\"%c\\\"\", szLine[i]);\n\t\t\tgoto exit;\n\t\t}\n\t\twhile (szLine[i+1+j] && szLine[i+1+j]!='}') {\n\t\t\tszTime[i] = szLine[i+1+j];\n\t\t\ti++;\n\t\t}\n\t\tszTime[i] = 0;\n\t\tend = atoi(szTime);\n\t\tj+=i+2;\n\n\t\tif (start>end) {\n\t\t\tgf_import_message(import, GF_OK, \"WARNING: corrupted SUB frame (line %d) - ends (at %d ms) before start of current frame (%d ms) - skipping\", line, end, start);\n\t\t\tcontinue;\n\t\t}\n\n\t\tgf_isom_text_reset(samp);\n\n\t\tif (start && first_samp) {\n\t\t\ts = gf_isom_text_to_sample(samp);\n\t\t\ts->DTS = 0;\n\t\t\ts->IsRAP = RAP;\n\t\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\t\tgf_isom_sample_del(&s);\n\t\t\tfirst_samp = GF_FALSE;\n\t\t\tnb_samp++;\n\t\t}\n\n\t\tfor (i=j; i<len; i++) {\n\t\t\tif (szLine[i]=='|') {\n\t\t\t\tszText[i-j] = '\\n';\n\t\t\t} else {\n\t\t\t\tszText[i-j] = szLine[i];\n\t\t\t}\n\t\t}\n\t\tszText[i-j] = 0;\n\t\tgf_isom_text_add_text(samp, szText, (u32) strlen(szText) );\n\n\t\tif (prev_end) {\n\t\t\tGF_TextSample * empty_samp = gf_isom_new_text_sample();\n\t\t\ts = gf_isom_text_to_sample(empty_samp);\n\t\t\ts->DTS = (u64) (FPS*(s64)prev_end);\n\t\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\t\tgf_isom_sample_del(&s);\n\t\t\tnb_samp++;\n\t\t\tgf_isom_delete_text_sample(empty_samp);\n\t\t}\n\n\t\ts = gf_isom_text_to_sample(samp);\n\t\ts->DTS = (u64) (FPS*(s64)start);\n\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\tgf_isom_sample_del(&s);\n\t\tnb_samp++;\n\t\tgf_isom_text_reset(samp);\n\t\tprev_end = end;\n\t\tgf_set_progress(\"Importing SUB\", gf_ftell(sub_in), file_size);\n\t\tif (duration && (end >= duration)) break;\n\t}\n\t/*final flush*/\n\tif (end && !(import->flags & GF_IMPORT_NO_TEXT_FLUSH ) ) {\n\t\tgf_isom_text_reset(samp);\n\t\ts = gf_isom_text_to_sample(samp);\n\t\ts->DTS = (u64)(FPS*(s64)end);\n\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\tgf_isom_sample_del(&s);\n\t\tnb_samp++;\n\t}\n\tgf_isom_delete_text_sample(samp);\n\t\n\tgf_isom_set_last_sample_duration(import->dest, track, 0);\n\tgf_set_progress(\"Importing SUB\", nb_samp, nb_samp);\n\nexit:\n\tif (e) gf_isom_remove_track(import->dest, track);\n\tgf_fclose(sub_in);\n\treturn e;\n}\n\n\n#define CHECK_STR(__str)\t\\\n\tif (!__str) { \\\n\t\te = gf_import_message(import, GF_BAD_PARAM, \"Invalid XML formatting (line %d)\", parser.line);\t\\\n\t\tgoto exit;\t\\\n\t}\t\\\n \n\nu32 ttxt_get_color(GF_MediaImporter *import, char *val)\n{\n\tu32 r, g, b, a, res;\n\tr = g = b = a = 0;\n\tif (sscanf(val, \"%x %x %x %x\", &r, &g, &b, &a) != 4) {\n\t\tgf_import_message(import, GF_OK, \"Warning: color badly formatted\");\n\t}\n\tres = (a&0xFF);\n\tres<<=8;\n\tres |= (r&0xFF);\n\tres<<=8;\n\tres |= (g&0xFF);\n\tres<<=8;\n\tres |= (b&0xFF);\n\treturn res;\n}\n\nvoid ttxt_parse_text_box(GF_MediaImporter *import, GF_XMLNode *n, GF_BoxRecord *box)\n{\n\tu32 i=0;\n\tGF_XMLAttribute *att;\n\tmemset(box, 0, sizeof(GF_BoxRecord));\n\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(n->attributes, &i))) {\n\t\tif (!stricmp(att->name, \"top\")) box->top = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"bottom\")) box->bottom = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"left\")) box->left = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"right\")) box->right = atoi(att->value);\n\t}\n}\n\nvoid ttxt_parse_text_style(GF_MediaImporter *import, GF_XMLNode *n, GF_StyleRecord *style)\n{\n\tu32 i=0;\n\tGF_XMLAttribute *att;\n\tmemset(style, 0, sizeof(GF_StyleRecord));\n\tstyle->fontID = 1;\n\tstyle->font_size = TTXT_DEFAULT_FONT_SIZE;\n\tstyle->text_color = 0xFFFFFFFF;\n\n\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(n->attributes, &i))) {\n\t\tif (!stricmp(att->name, \"fromChar\")) style->startCharOffset = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"toChar\")) style->endCharOffset = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"fontID\")) style->fontID = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"fontSize\")) style->font_size = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"color\")) style->text_color = ttxt_get_color(import, att->value);\n\t\telse if (!stricmp(att->name, \"styles\")) {\n\t\t\tif (strstr(att->value, \"Bold\")) style->style_flags |= GF_TXT_STYLE_BOLD;\n\t\t\tif (strstr(att->value, \"Italic\")) style->style_flags |= GF_TXT_STYLE_ITALIC;\n\t\t\tif (strstr(att->value, \"Underlined\")) style->style_flags |= GF_TXT_STYLE_UNDERLINED;\n\t\t}\n\t}\n}\n\nstatic void ttxt_import_progress(void *cbk, u64 cur_samp, u64 count)\n{\n\tgf_set_progress(\"TTXT Loading\", cur_samp, count);\n}\n\nstatic GF_Err gf_text_import_ttxt(GF_MediaImporter *import)\n{\n\tGF_Err e;\n\tBool last_sample_empty;\n\tu32 i, j, k, track, ID, nb_samples, nb_descs, nb_children;\n\tu64 last_sample_duration;\n\tGF_XMLAttribute *att;\n\tGF_DOMParser *parser;\n\tGF_XMLNode *root, *node, *ext;\n\n\tif (import->flags==GF_IMPORT_PROBE_ONLY) return GF_OK;\n\n\tparser = gf_xml_dom_new();\n\te = gf_xml_dom_parse(parser, import->in_name, ttxt_import_progress, import);\n\tif (e) {\n\t\tgf_import_message(import, e, \"Error parsing TTXT file: Line %d - %s\", gf_xml_dom_get_line(parser), gf_xml_dom_get_error(parser));\n\t\tgf_xml_dom_del(parser);\n\t\treturn e;\n\t}\n\troot = gf_xml_dom_get_root(parser);\n\n\te = GF_OK;\n\tif (strcmp(root->name, \"TextStream\")) {\n\t\te = gf_import_message(import, GF_BAD_PARAM, \"Invalid Timed Text file - expecting \\\"TextStream\\\" got %s\", \"TextStream\", root->name);\n\t\tgoto exit;\n\t}\n\n\t/*setup track in 3GP format directly (no ES desc)*/\n\tID = (import->esd) ? import->esd->ESID : 0;\n\ttrack = gf_isom_new_track(import->dest, ID, GF_ISOM_MEDIA_TEXT, 1000);\n\tif (!track) {\n\t\te = gf_isom_last_error(import->dest);\n\t\tgoto exit;\n\t}\n\tgf_isom_set_track_enabled(import->dest, track, 1);\n\t/*some MPEG-4 setup*/\n\tif (import->esd) {\n\t\tif (!import->esd->ESID) import->esd->ESID = gf_isom_get_track_id(import->dest, track);\n\t\tif (!import->esd->decoderConfig) import->esd->decoderConfig = (GF_DecoderConfig *) gf_odf_desc_new(GF_ODF_DCD_TAG);\n\t\tif (!import->esd->slConfig) import->esd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\timport->esd->slConfig->timestampResolution = 1000;\n\t\timport->esd->decoderConfig->streamType = GF_STREAM_TEXT;\n\t\timport->esd->decoderConfig->objectTypeIndication = GPAC_OTI_TEXT_MPEG4;\n\t\tif (import->esd->OCRESID) gf_isom_set_track_reference(import->dest, track, GF_ISOM_REF_OCR, import->esd->OCRESID);\n\t}\n\tgf_text_import_set_language(import, track);\n\n\tgf_import_message(import, GF_OK, \"Timed Text (GPAC TTXT) Import\");\n\n\tlast_sample_empty = GF_FALSE;\n\tlast_sample_duration = 0;\n\tnb_descs = 0;\n\tnb_samples = 0;\n\tnb_children = gf_list_count(root->content);\n\n\ti=0;\n\twhile ( (node = (GF_XMLNode*)gf_list_enum(root->content, &i))) {\n\t\tif (node->type) {\n\t\t\tnb_children--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(node->name, \"TextStreamHeader\")) {\n\t\t\tGF_XMLNode *sdesc;\n\t\t\ts32 w, h, tx, ty, layer;\n\t\t\tu32 tref_id;\n\t\t\tw = TTXT_DEFAULT_WIDTH;\n\t\t\th = TTXT_DEFAULT_HEIGHT;\n\t\t\ttx = ty = layer = 0;\n\t\t\tnb_children--;\n\t\t\ttref_id = 0;\n\n\t\t\tj=0;\n\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(node->attributes, &j))) {\n\t\t\t\tif (!strcmp(att->name, \"width\")) w = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"height\")) h = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"layer\")) layer = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"translation_x\")) tx = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"translation_y\")) ty = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"trefID\")) tref_id = atoi(att->value);\n\t\t\t}\n\n\t\t\tif (tref_id)\n\t\t\t\tgf_isom_set_track_reference(import->dest, track, GF_ISOM_BOX_TYPE_CHAP, tref_id);\n\n\t\t\tgf_isom_set_track_layout_info(import->dest, track, w<<16, h<<16, tx<<16, ty<<16, (s16) layer);\n\n\t\t\tj=0;\n\t\t\twhile ( (sdesc=(GF_XMLNode*)gf_list_enum(node->content, &j))) {\n\t\t\t\tif (sdesc->type) continue;\n\n\t\t\t\tif (!strcmp(sdesc->name, \"TextSampleDescription\")) {\n\t\t\t\t\tGF_TextSampleDescriptor td;\n\t\t\t\t\tu32 idx;\n\t\t\t\t\tmemset(&td, 0, sizeof(GF_TextSampleDescriptor));\n\t\t\t\t\ttd.tag = GF_ODF_TEXT_CFG_TAG;\n\t\t\t\t\ttd.vert_justif = (s8) -1;\n\t\t\t\t\ttd.default_style.fontID = 1;\n\t\t\t\t\ttd.default_style.font_size = TTXT_DEFAULT_FONT_SIZE;\n\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(sdesc->attributes, &k))) {\n\t\t\t\t\t\tif (!strcmp(att->name, \"horizontalJustification\")) {\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.horiz_justif = 1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"right\")) td.horiz_justif = (s8) -1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"left\")) td.horiz_justif = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!strcmp(att->name, \"verticalJustification\")) {\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.vert_justif = 1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"bottom\")) td.vert_justif = (s8) -1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"top\")) td.vert_justif = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!strcmp(att->name, \"backColor\")) td.back_color = ttxt_get_color(import, att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"verticalText\") && !stricmp(att->value, \"yes\") ) td.displayFlags |= GF_TXT_VERTICAL;\n\t\t\t\t\t\telse if (!strcmp(att->name, \"fillTextRegion\") && !stricmp(att->value, \"yes\") ) td.displayFlags |= GF_TXT_FILL_REGION;\n\t\t\t\t\t\telse if (!strcmp(att->name, \"continuousKaraoke\") && !stricmp(att->value, \"yes\") ) td.displayFlags |= GF_TXT_KARAOKE;\n\t\t\t\t\t\telse if (!strcmp(att->name, \"scroll\")) {\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"inout\")) td.displayFlags |= GF_TXT_SCROLL_IN | GF_TXT_SCROLL_OUT;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"in\")) td.displayFlags |= GF_TXT_SCROLL_IN;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"out\")) td.displayFlags |= GF_TXT_SCROLL_OUT;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!strcmp(att->name, \"scrollMode\")) {\n\t\t\t\t\t\t\tu32 scroll_mode = GF_TXT_SCROLL_CREDITS;\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"Credits\")) scroll_mode = GF_TXT_SCROLL_CREDITS;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"Marquee\")) scroll_mode = GF_TXT_SCROLL_MARQUEE;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"Right\")) scroll_mode = GF_TXT_SCROLL_RIGHT;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"Down\")) scroll_mode = GF_TXT_SCROLL_DOWN;\n\t\t\t\t\t\t\ttd.displayFlags |= ((scroll_mode<<7) & GF_TXT_SCROLL_DIRECTION);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (ext=(GF_XMLNode*)gf_list_enum(sdesc->content, &k))) {\n\t\t\t\t\t\tif (ext->type) continue;\n\t\t\t\t\t\tif (!strcmp(ext->name, \"TextBox\")) ttxt_parse_text_box(import, ext, &td.default_pos);\n\t\t\t\t\t\telse if (!strcmp(ext->name, \"Style\")) ttxt_parse_text_style(import, ext, &td.default_style);\n\t\t\t\t\t\telse if (!strcmp(ext->name, \"FontTable\")) {\n\t\t\t\t\t\t\tGF_XMLNode *ftable;\n\t\t\t\t\t\t\tu32 z=0;\n\t\t\t\t\t\t\twhile ( (ftable=(GF_XMLNode*)gf_list_enum(ext->content, &z))) {\n\t\t\t\t\t\t\t\tu32 m;\n\t\t\t\t\t\t\t\tif (ftable->type || strcmp(ftable->name, \"FontTableEntry\")) continue;\n\t\t\t\t\t\t\t\ttd.font_count += 1;\n\t\t\t\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_realloc(td.fonts, sizeof(GF_FontRecord)*td.font_count);\n\t\t\t\t\t\t\t\tm=0;\n\t\t\t\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ftable->attributes, &m))) {\n\t\t\t\t\t\t\t\t\tif (!stricmp(att->name, \"fontID\")) td.fonts[td.font_count-1].fontID = atoi(att->value);\n\t\t\t\t\t\t\t\t\telse if (!stricmp(att->name, \"fontName\")) td.fonts[td.font_count-1].fontName = gf_strdup(att->value);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (import->flags & GF_IMPORT_SKIP_TXT_BOX) {\n\t\t\t\t\t\ttd.default_pos.top = td.default_pos.left = td.default_pos.right = td.default_pos.bottom = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ((td.default_pos.bottom==td.default_pos.top) || (td.default_pos.right==td.default_pos.left)) {\n\t\t\t\t\t\t\ttd.default_pos.top = td.default_pos.left = 0;\n\t\t\t\t\t\t\ttd.default_pos.right = w;\n\t\t\t\t\t\t\ttd.default_pos.bottom = h;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!td.fonts) {\n\t\t\t\t\t\ttd.font_count = 1;\n\t\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\t\t\t\t\ttd.fonts[0].fontID = 1;\n\t\t\t\t\t\ttd.fonts[0].fontName = gf_strdup(\"Serif\");\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_new_text_description(import->dest, track, &td, NULL, NULL, &idx);\n\t\t\t\t\tfor (k=0; k<td.font_count; k++) gf_free(td.fonts[k].fontName);\n\t\t\t\t\tgf_free(td.fonts);\n\t\t\t\t\tnb_descs ++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*sample text*/\n\t\telse if (!strcmp(node->name, \"TextSample\")) {\n\t\t\tGF_ISOSample *s;\n\t\t\tGF_TextSample * samp;\n\t\t\tu32 ts, descIndex;\n\t\t\tBool has_text = GF_FALSE;\n\t\t\tif (!nb_descs) {\n\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"Invalid Timed Text file - text stream header not found or empty\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tsamp = gf_isom_new_text_sample();\n\t\t\tts = 0;\n\t\t\tdescIndex = 1;\n\t\t\tlast_sample_empty = GF_TRUE;\n\n\t\t\tj=0;\n\t\t\twhile ( (att=(GF_XMLAttribute*)gf_list_enum(node->attributes, &j))) {\n\t\t\t\tif (!strcmp(att->name, \"sampleTime\")) {\n\t\t\t\t\tu32 h, m, s, ms;\n\t\t\t\t\tif (sscanf(att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\tts = (h*3600 + m*60 + s)*1000 + ms;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tts = (u32) (atof(att->value) * 1000);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(att->name, \"sampleDescriptionIndex\")) descIndex = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"text\")) {\n\t\t\t\t\tu32 len;\n\t\t\t\t\tchar *str = ttxt_parse_string(import, att->value, GF_TRUE);\n\t\t\t\t\tlen = (u32) strlen(str);\n\t\t\t\t\tgf_isom_text_add_text(samp, str, len);\n\t\t\t\t\tlast_sample_empty = len ? GF_FALSE : GF_TRUE;\n\t\t\t\t\thas_text = GF_TRUE;\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(att->name, \"scrollDelay\")) gf_isom_text_set_scroll_delay(samp, (u32) (1000*atoi(att->value)));\n\t\t\t\telse if (!strcmp(att->name, \"highlightColor\")) gf_isom_text_set_highlight_color_argb(samp, ttxt_get_color(import, att->value));\n\t\t\t\telse if (!strcmp(att->name, \"wrap\") && !strcmp(att->value, \"Automatic\")) gf_isom_text_set_wrap(samp, 0x01);\n\t\t\t}\n\n\t\t\t/*get all modifiers*/\n\t\t\tj=0;\n\t\t\twhile ( (ext=(GF_XMLNode*)gf_list_enum(node->content, &j))) {\n\t\t\t\tif (!has_text && (ext->type==GF_XML_TEXT_TYPE)) {\n\t\t\t\t\tu32 len;\n\t\t\t\t\tchar *str = ttxt_parse_string(import, ext->name, GF_FALSE);\n\t\t\t\t\tlen = (u32) strlen(str);\n\t\t\t\t\tgf_isom_text_add_text(samp, str, len);\n\t\t\t\t\tlast_sample_empty = len ? GF_FALSE : GF_TRUE;\n\t\t\t\t\thas_text = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tif (ext->type) continue;\n\n\t\t\t\tif (!stricmp(ext->name, \"Style\")) {\n\t\t\t\t\tGF_StyleRecord r;\n\t\t\t\t\tttxt_parse_text_style(import, ext, &r);\n\t\t\t\t\tgf_isom_text_add_style(samp, &r);\n\t\t\t\t}\n\t\t\t\telse if (!stricmp(ext->name, \"TextBox\")) {\n\t\t\t\t\tGF_BoxRecord r;\n\t\t\t\t\tttxt_parse_text_box(import, ext, &r);\n\t\t\t\t\tgf_isom_text_set_box(samp, r.top, r.left, r.bottom, r.right);\n\t\t\t\t}\n\t\t\t\telse if (!stricmp(ext->name, \"Highlight\")) {\n\t\t\t\t\tu16 start, end;\n\t\t\t\t\tstart = end = 0;\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_text_add_highlight(samp, start, end);\n\t\t\t\t}\n\t\t\t\telse if (!stricmp(ext->name, \"Blinking\")) {\n\t\t\t\t\tu16 start, end;\n\t\t\t\t\tstart = end = 0;\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_text_add_blink(samp, start, end);\n\t\t\t\t}\n\t\t\t\telse if (!stricmp(ext->name, \"HyperLink\")) {\n\t\t\t\t\tu16 start, end;\n\t\t\t\t\tchar *url, *url_tt;\n\t\t\t\t\tstart = end = 0;\n\t\t\t\t\turl = url_tt = NULL;\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"URL\")) url = gf_strdup(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"URLToolTip\")) url_tt = gf_strdup(att->value);\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_text_add_hyperlink(samp, url, url_tt, start, end);\n\t\t\t\t\tif (url) gf_free(url);\n\t\t\t\t\tif (url_tt) gf_free(url_tt);\n\t\t\t\t}\n\t\t\t\telse if (!stricmp(ext->name, \"Karaoke\")) {\n\t\t\t\t\tu32 startTime;\n\t\t\t\t\tGF_XMLNode *krok;\n\t\t\t\t\tstartTime = 0;\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\t\tif (!strcmp(att->name, \"startTime\")) startTime = (u32) (1000*atof(att->value));\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_text_add_karaoke(samp, startTime);\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (krok=(GF_XMLNode*)gf_list_enum(ext->content, &k))) {\n\t\t\t\t\t\tu16 start, end;\n\t\t\t\t\t\tu32 endTime, m;\n\t\t\t\t\t\tif (krok->type) continue;\n\t\t\t\t\t\tif (strcmp(krok->name, \"KaraokeRange\")) continue;\n\t\t\t\t\t\tstart = end = 0;\n\t\t\t\t\t\tendTime = 0;\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(krok->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endTime\")) endTime = (u32) (1000*atof(att->value));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_set_karaoke_segment(samp, endTime, start, end);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*in MP4 we must start at T=0, so add an empty sample*/\n\t\t\tif (ts && !nb_samples) {\n\t\t\t\tGF_TextSample * firstsamp = gf_isom_new_text_sample();\n\t\t\t\ts = gf_isom_text_to_sample(firstsamp);\n\t\t\t\ts->DTS = 0;\n\t\t\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\t\t\tnb_samples++;\n\t\t\t\tgf_isom_delete_text_sample(firstsamp);\n\t\t\t\tgf_isom_sample_del(&s);\n\t\t\t}\n\n\t\t\ts = gf_isom_text_to_sample(samp);\n\t\t\tgf_isom_delete_text_sample(samp);\n\t\t\ts->DTS = ts;\n\t\t\tif (last_sample_empty) {\n\t\t\t\tlast_sample_duration = s->DTS - last_sample_duration;\n\t\t\t} else {\n\t\t\t\tlast_sample_duration = s->DTS;\n\t\t\t}\n\n\t\t\te = gf_isom_add_sample(import->dest, track, descIndex, s);\n\t\t\tif (e) goto exit;\n\t\t\tgf_isom_sample_del(&s);\n\t\t\tnb_samples++;\n\n\t\t\tgf_set_progress(\"Importing TTXT\", nb_samples, nb_children);\n\t\t\tif (import->duration && (ts>import->duration)) break;\n\t\t}\n\t}\n\tif (last_sample_empty) {\n\t\tgf_isom_remove_sample(import->dest, track, nb_samples);\n\t\tgf_isom_set_last_sample_duration(import->dest, track, (u32) last_sample_duration);\n\t}\n\tgf_set_progress(\"Importing TTXT\", nb_samples, nb_samples);\n\nexit:\n\tgf_xml_dom_del(parser);\n\treturn e;\n}\n\n\nu32 tx3g_get_color(GF_MediaImporter *import, char *value)\n{\n\tu32 r, g, b, a;\n\tu32 res, v;\n\tr = g = b = a = 0;\n\tif (sscanf(value, \"%u%%, %u%%, %u%%, %u%%\", &r, &g, &b, &a) != 4) {\n\t\tgf_import_message(import, GF_OK, \"Warning: color badly formatted\");\n\t}\n\tv = (u32) (a*255/100);\n\tres = (v&0xFF);\n\tres<<=8;\n\tv = (u32) (r*255/100);\n\tres |= (v&0xFF);\n\tres<<=8;\n\tv = (u32) (g*255/100);\n\tres |= (v&0xFF);\n\tres<<=8;\n\tv = (u32) (b*255/100);\n\tres |= (v&0xFF);\n\treturn res;\n}\n\nvoid tx3g_parse_text_box(GF_MediaImporter *import, GF_XMLNode *n, GF_BoxRecord *box)\n{\n\tu32 i=0;\n\tGF_XMLAttribute *att;\n\tmemset(box, 0, sizeof(GF_BoxRecord));\n\twhile ((att=(GF_XMLAttribute *)gf_list_enum(n->attributes, &i))) {\n\t\tif (!stricmp(att->name, \"x\")) box->left = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"y\")) box->top = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"height\")) box->bottom = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"width\")) box->right = atoi(att->value);\n\t}\n}\n\ntypedef struct\n{\n\tu32 id;\n\tu32 pos;\n} Marker;\n\n#define GET_MARKER_POS(_val, __isend) \\\n\t{\t\\\n\t\tu32 i, __m = atoi(att->value);\t\\\n\t\t_val = 0;\t\\\n\t\tfor (i=0; i<nb_marks; i++) { if (__m==marks[i].id) { _val = marks[i].pos; /*if (__isend) _val--; */break; } }\t \\\n\t}\n\n\nstatic void texml_import_progress(void *cbk, u64 cur_samp, u64 count)\n{\n\tgf_set_progress(\"TeXML Loading\", cur_samp, count);\n}\n\nstatic GF_Err gf_text_import_texml(GF_MediaImporter *import)\n{\n\tGF_Err e;\n\tu32 track, ID, nb_samples, nb_children, nb_descs, timescale, w, h, i, j, k;\n\tu64 DTS;\n\ts32 tx, ty, layer;\n\tGF_StyleRecord styles[50];\n\tMarker marks[50];\n\tGF_XMLAttribute *att;\n\tGF_DOMParser *parser;\n\tGF_XMLNode *root, *node;\n\n\tif (import->flags==GF_IMPORT_PROBE_ONLY) return GF_OK;\n\n\tparser = gf_xml_dom_new();\n\te = gf_xml_dom_parse(parser, import->in_name, texml_import_progress, import);\n\tif (e) {\n\t\tgf_import_message(import, e, \"Error parsing TeXML file: Line %d - %s\", gf_xml_dom_get_line(parser), gf_xml_dom_get_error(parser));\n\t\tgf_xml_dom_del(parser);\n\t\treturn e;\n\t}\n\troot = gf_xml_dom_get_root(parser);\n\n\tif (strcmp(root->name, \"text3GTrack\")) {\n\t\te = gf_import_message(import, GF_BAD_PARAM, \"Invalid QT TeXML file - expecting root \\\"text3GTrack\\\" got \\\"%s\\\"\", root->name);\n\t\tgoto exit;\n\t}\n\tw = TTXT_DEFAULT_WIDTH;\n\th = TTXT_DEFAULT_HEIGHT;\n\ttx = ty = 0;\n\tlayer = 0;\n\ttimescale = 1000;\n\ti=0;\n\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(root->attributes, &i))) {\n\t\tif (!strcmp(att->name, \"trackWidth\")) w = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"trackHeight\")) h = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"layer\")) layer = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"timescale\")) timescale = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"transform\")) {\n\t\t\tFloat fx, fy;\n\t\t\tsscanf(att->value, \"translate(%f,%f)\", &fx, &fy);\n\t\t\ttx = (u32) fx;\n\t\t\tty = (u32) fy;\n\t\t}\n\t}\n\n\t/*setup track in 3GP format directly (no ES desc)*/\n\tID = (import->esd) ? import->esd->ESID : 0;\n\ttrack = gf_isom_new_track(import->dest, ID, GF_ISOM_MEDIA_TEXT, timescale);\n\tif (!track) {\n\t\te = gf_isom_last_error(import->dest);\n\t\tgoto exit;\n\t}\n\tgf_isom_set_track_enabled(import->dest, track, 1);\n\t/*some MPEG-4 setup*/\n\tif (import->esd) {\n\t\tif (!import->esd->ESID) import->esd->ESID = gf_isom_get_track_id(import->dest, track);\n\t\tif (!import->esd->decoderConfig) import->esd->decoderConfig = (GF_DecoderConfig *) gf_odf_desc_new(GF_ODF_DCD_TAG);\n\t\tif (!import->esd->slConfig) import->esd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\timport->esd->slConfig->timestampResolution = timescale;\n\t\timport->esd->decoderConfig->streamType = GF_STREAM_TEXT;\n\t\timport->esd->decoderConfig->objectTypeIndication = GPAC_OTI_TEXT_MPEG4;\n\t\tif (import->esd->OCRESID) gf_isom_set_track_reference(import->dest, track, GF_ISOM_REF_OCR, import->esd->OCRESID);\n\t}\n\tDTS = 0;\n\tgf_isom_set_track_layout_info(import->dest, track, w<<16, h<<16, tx<<16, ty<<16, (s16) layer);\n\n\tgf_text_import_set_language(import, track);\n\te = GF_OK;\n\n\tgf_import_message(import, GF_OK, \"Timed Text (QT TeXML) Import - Track Size %d x %d\", w, h);\n\n\tnb_children = gf_list_count(root->content);\n\tnb_descs = 0;\n\tnb_samples = 0;\n\ti=0;\n\twhile ( (node=(GF_XMLNode*)gf_list_enum(root->content, &i))) {\n\t\tGF_XMLNode *desc;\n\t\tGF_TextSampleDescriptor td;\n\t\tGF_TextSample * samp = NULL;\n\t\tGF_ISOSample *s;\n\t\tu32 duration, descIndex, nb_styles, nb_marks;\n\t\tBool isRAP, same_style, same_box;\n\n\t\tif (node->type) continue;\n\t\tif (strcmp(node->name, \"sample\")) continue;\n\n\t\tisRAP = GF_FALSE;\n\t\tduration = 1000;\n\t\tj=0;\n\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(node->attributes, &j))) {\n\t\t\tif (!strcmp(att->name, \"duration\")) duration = atoi(att->value);\n\t\t\telse if (!strcmp(att->name, \"keyframe\")) isRAP = (!stricmp(att->value, \"true\") ? GF_TRUE : GF_FALSE);\n\t\t}\n\t\tnb_styles = 0;\n\t\tnb_marks = 0;\n\t\tsame_style = same_box = GF_FALSE;\n\t\tdescIndex = 1;\n\t\tj=0;\n\t\twhile ((desc=(GF_XMLNode*)gf_list_enum(node->content, &j))) {\n\t\t\tif (desc->type) continue;\n\n\t\t\tif (!strcmp(desc->name, \"description\")) {\n\t\t\t\tGF_XMLNode *sub;\n\t\t\t\tmemset(&td, 0, sizeof(GF_TextSampleDescriptor));\n\t\t\t\ttd.tag = GF_ODF_TEXT_CFG_TAG;\n\t\t\t\ttd.vert_justif = (s8) -1;\n\t\t\t\ttd.default_style.fontID = 1;\n\t\t\t\ttd.default_style.font_size = TTXT_DEFAULT_FONT_SIZE;\n\n\t\t\t\tk=0;\n\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(desc->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"horizontalJustification\")) {\n\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.horiz_justif = 1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"right\")) td.horiz_justif = (s8) -1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"left\")) td.horiz_justif = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strcmp(att->name, \"verticalJustification\")) {\n\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.vert_justif = 1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"bottom\")) td.vert_justif = (s8) -1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"top\")) td.vert_justif = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strcmp(att->name, \"backgroundColor\")) td.back_color = tx3g_get_color(import, att->value);\n\t\t\t\t\telse if (!strcmp(att->name, \"displayFlags\")) {\n\t\t\t\t\t\tBool rev_scroll = GF_FALSE;\n\t\t\t\t\t\tif (strstr(att->value, \"scroll\")) {\n\t\t\t\t\t\t\tu32 scroll_mode = 0;\n\t\t\t\t\t\t\tif (strstr(att->value, \"scrollIn\")) td.displayFlags |= GF_TXT_SCROLL_IN;\n\t\t\t\t\t\t\tif (strstr(att->value, \"scrollOut\")) td.displayFlags |= GF_TXT_SCROLL_OUT;\n\t\t\t\t\t\t\tif (strstr(att->value, \"reverse\")) rev_scroll = GF_TRUE;\n\t\t\t\t\t\t\tif (strstr(att->value, \"horizontal\")) scroll_mode = rev_scroll ? GF_TXT_SCROLL_RIGHT : GF_TXT_SCROLL_MARQUEE;\n\t\t\t\t\t\t\telse scroll_mode = (rev_scroll ? GF_TXT_SCROLL_DOWN : GF_TXT_SCROLL_CREDITS);\n\t\t\t\t\t\t\ttd.displayFlags |= (scroll_mode<<7) & GF_TXT_SCROLL_DIRECTION;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*TODO FIXME: check in QT doc !!*/\n\t\t\t\t\t\tif (strstr(att->value, \"writeTextVertically\")) td.displayFlags |= GF_TXT_VERTICAL;\n\t\t\t\t\t\tif (!strcmp(att->name, \"continuousKaraoke\")) td.displayFlags |= GF_TXT_KARAOKE;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tk=0;\n\t\t\t\twhile ((sub=(GF_XMLNode*)gf_list_enum(desc->content, &k))) {\n\t\t\t\t\tif (sub->type) continue;\n\t\t\t\t\tif (!strcmp(sub->name, \"defaultTextBox\")) tx3g_parse_text_box(import, sub, &td.default_pos);\n\t\t\t\t\telse if (!strcmp(sub->name, \"fontTable\")) {\n\t\t\t\t\t\tGF_XMLNode *ftable;\n\t\t\t\t\t\tu32 m=0;\n\t\t\t\t\t\twhile ((ftable=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tif (ftable->type) continue;\n\t\t\t\t\t\t\tif (!strcmp(ftable->name, \"font\")) {\n\t\t\t\t\t\t\t\tu32 n=0;\n\t\t\t\t\t\t\t\ttd.font_count += 1;\n\t\t\t\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_realloc(td.fonts, sizeof(GF_FontRecord)*td.font_count);\n\t\t\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(ftable->attributes, &n))) {\n\t\t\t\t\t\t\t\t\tif (!stricmp(att->name, \"id\")) td.fonts[td.font_count-1].fontID = atoi(att->value);\n\t\t\t\t\t\t\t\t\telse if (!stricmp(att->name, \"name\")) td.fonts[td.font_count-1].fontName = gf_strdup(att->value);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strcmp(sub->name, \"sharedStyles\")) {\n\t\t\t\t\t\tGF_XMLNode *style, *ftable;\n\t\t\t\t\t\tu32 m=0;\n\t\t\t\t\t\twhile ((style=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tif (style->type) continue;\n\t\t\t\t\t\t\tif (!strcmp(style->name, \"style\")) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (style) {\n\t\t\t\t\t\t\tchar *cur;\n\t\t\t\t\t\t\ts32 start=0;\n\t\t\t\t\t\t\tchar css_style[1024], css_val[1024];\n\t\t\t\t\t\t\tmemset(&styles[nb_styles], 0, sizeof(GF_StyleRecord));\n\t\t\t\t\t\t\tm=0;\n\t\t\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(style->attributes, &m))) {\n\t\t\t\t\t\t\t\tif (!strcmp(att->name, \"id\")) styles[nb_styles].startCharOffset = atoi(att->value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tm=0;\n\t\t\t\t\t\t\twhile ( (ftable=(GF_XMLNode*)gf_list_enum(style->content, &m))) {\n\t\t\t\t\t\t\t\tif (ftable->type) break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcur = ftable->name;\n\t\t\t\t\t\t\twhile (cur) {\n\t\t\t\t\t\t\t\tstart = gf_token_get_strip(cur, 0, \"{:\", \" \", css_style, 1024);\n\t\t\t\t\t\t\t\tif (start <0) break;\n\t\t\t\t\t\t\t\tstart = gf_token_get_strip(cur, start, \":}\", \" \", css_val, 1024);\n\t\t\t\t\t\t\t\tif (start <0) break;\n\t\t\t\t\t\t\t\tcur = strchr(cur+start, '{');\n\n\t\t\t\t\t\t\t\tif (!strcmp(css_style, \"font-table\")) {\n\t\t\t\t\t\t\t\t\tu32 z;\n\t\t\t\t\t\t\t\t\tstyles[nb_styles].fontID = atoi(css_val);\n\t\t\t\t\t\t\t\t\tfor (z=0; z<td.font_count; z++) {\n\t\t\t\t\t\t\t\t\t\tif (td.fonts[z].fontID == styles[nb_styles].fontID)\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"font-size\")) styles[nb_styles].font_size = atoi(css_val);\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"font-style\") && !strcmp(css_val, \"italic\")) styles[nb_styles].style_flags |= GF_TXT_STYLE_ITALIC;\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"font-weight\") && !strcmp(css_val, \"bold\")) styles[nb_styles].style_flags |= GF_TXT_STYLE_BOLD;\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"text-decoration\") && !strcmp(css_val, \"underline\")) styles[nb_styles].style_flags |= GF_TXT_STYLE_UNDERLINED;\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"color\")) styles[nb_styles].text_color = tx3g_get_color(import, css_val);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!nb_styles) td.default_style = styles[0];\n\t\t\t\t\t\t\tnb_styles++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif ((td.default_pos.bottom==td.default_pos.top) || (td.default_pos.right==td.default_pos.left)) {\n\t\t\t\t\ttd.default_pos.top = td.default_pos.left = 0;\n\t\t\t\t\ttd.default_pos.right = w;\n\t\t\t\t\ttd.default_pos.bottom = h;\n\t\t\t\t}\n\t\t\t\tif (!td.fonts) {\n\t\t\t\t\ttd.font_count = 1;\n\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\t\t\t\ttd.fonts[0].fontID = 1;\n\t\t\t\t\ttd.fonts[0].fontName = gf_strdup(\"Serif\");\n\t\t\t\t}\n\t\t\t\tgf_isom_text_has_similar_description(import->dest, track, &td, &descIndex, &same_box, &same_style);\n\t\t\t\tif (!descIndex) {\n\t\t\t\t\tgf_isom_new_text_description(import->dest, track, &td, NULL, NULL, &descIndex);\n\t\t\t\t\tsame_style = same_box = GF_TRUE;\n\t\t\t\t}\n\n\t\t\t\tfor (k=0; k<td.font_count; k++) gf_free(td.fonts[k].fontName);\n\t\t\t\tgf_free(td.fonts);\n\t\t\t\tnb_descs ++;\n\t\t\t}\n\t\t\telse if (!strcmp(desc->name, \"sampleData\")) {\n\t\t\t\tGF_XMLNode *sub;\n\t\t\t\tu16 start, end;\n\t\t\t\tu32 styleID;\n\t\t\t\tu32 nb_chars, txt_len, m;\n\t\t\t\tnb_chars = 0;\n\n\t\t\t\tsamp = gf_isom_new_text_sample();\n\n\t\t\t\tk=0;\n\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(desc->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"targetEncoding\") && !strcmp(att->value, \"utf16\")) ;//is_utf16 = 1;\n\t\t\t\t\telse if (!strcmp(att->name, \"scrollDelay\")) gf_isom_text_set_scroll_delay(samp, atoi(att->value) );\n\t\t\t\t\telse if (!strcmp(att->name, \"highlightColor\")) gf_isom_text_set_highlight_color_argb(samp, tx3g_get_color(import, att->value));\n\t\t\t\t}\n\t\t\t\tstart = end = 0;\n\t\t\t\tk=0;\n\t\t\t\twhile ((sub=(GF_XMLNode*)gf_list_enum(desc->content, &k))) {\n\t\t\t\t\tif (sub->type) continue;\n\t\t\t\t\tif (!strcmp(sub->name, \"text\")) {\n\t\t\t\t\t\tGF_XMLNode *text;\n\t\t\t\t\t\tstyleID = 0;\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"styleID\")) styleID = atoi(att->value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttxt_len = 0;\n\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((text=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tif (!text->type) {\n\t\t\t\t\t\t\t\tif (!strcmp(text->name, \"marker\")) {\n\t\t\t\t\t\t\t\t\tu32 z;\n\t\t\t\t\t\t\t\t\tmemset(&marks[nb_marks], 0, sizeof(Marker));\n\t\t\t\t\t\t\t\t\tmarks[nb_marks].pos = nb_chars+txt_len;\n\n\t\t\t\t\t\t\t\t\tz = 0;\n\t\t\t\t\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(text->attributes, &z))) {\n\t\t\t\t\t\t\t\t\t\tif (!strcmp(att->name, \"id\")) marks[nb_marks].id = atoi(att->value);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tnb_marks++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (text->type==GF_XML_TEXT_TYPE) {\n\t\t\t\t\t\t\t\ttxt_len += (u32) strlen(text->name);\n\t\t\t\t\t\t\t\tgf_isom_text_add_text(samp, text->name, (u32) strlen(text->name));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (styleID && (!same_style || (td.default_style.startCharOffset != styleID))) {\n\t\t\t\t\t\t\tGF_StyleRecord st = td.default_style;\n\t\t\t\t\t\t\tfor (m=0; m<nb_styles; m++) {\n\t\t\t\t\t\t\t\tif (styles[m].startCharOffset==styleID) {\n\t\t\t\t\t\t\t\t\tst = styles[m];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tst.startCharOffset = nb_chars;\n\t\t\t\t\t\t\tst.endCharOffset = nb_chars + txt_len;\n\t\t\t\t\t\t\tgf_isom_text_add_style(samp, &st);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnb_chars += txt_len;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"highlight\")) {\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_highlight(samp, start, end);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"blink\")) {\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_blink(samp, start, end);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"link\")) {\n\t\t\t\t\t\tchar *url, *url_tt;\n\t\t\t\t\t\turl = url_tt = NULL;\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"URL\") || !strcmp(att->name, \"href\")) url = gf_strdup(att->value);\n\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"URLToolTip\") || !strcmp(att->name, \"altString\")) url_tt = gf_strdup(att->value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_hyperlink(samp, url, url_tt, start, end);\n\t\t\t\t\t\tif (url) gf_free(url);\n\t\t\t\t\t\tif (url_tt) gf_free(url_tt);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"karaoke\")) {\n\t\t\t\t\t\tu32 time = 0;\n\t\t\t\t\t\tGF_XMLNode *krok;\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startTime\")) time = atoi(att->value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_karaoke(samp, time);\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((krok=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tu32 u=0;\n\t\t\t\t\t\t\tif (krok->type) continue;\n\t\t\t\t\t\t\tif (strcmp(krok->name, \"run\")) continue;\n\t\t\t\t\t\t\tstart = end = 0;\n\t\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(krok->attributes, &u))) {\n\t\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"duration\")) time += atoi(att->value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgf_isom_text_set_karaoke_segment(samp, time, start, end);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*OK, let's add the sample*/\n\t\tif (samp) {\n\t\t\tif (!same_box) gf_isom_text_set_box(samp, td.default_pos.top, td.default_pos.left, td.default_pos.bottom, td.default_pos.right);\n//\t\t\tif (!same_style) gf_isom_text_add_style(samp, &td.default_style);\n\n\t\t\ts = gf_isom_text_to_sample(samp);\n\t\t\tgf_isom_delete_text_sample(samp);\n\t\t\ts->IsRAP = isRAP ? RAP : RAP_NO;\n\t\t\ts->DTS = DTS;\n\t\t\tgf_isom_add_sample(import->dest, track, descIndex, s);\n\t\t\tgf_isom_sample_del(&s);\n\t\t\tnb_samples++;\n\t\t\tDTS += duration;\n\t\t\tgf_set_progress(\"Importing TeXML\", nb_samples, nb_children);\n\t\t\tif (import->duration && (DTS*1000> timescale*import->duration)) break;\n\t\t}\n\t}\n\tgf_isom_set_last_sample_duration(import->dest, track, 0);\n\tgf_set_progress(\"Importing TeXML\", nb_samples, nb_samples);\n\nexit:\n\tgf_xml_dom_del(parser);\n\treturn e;\n}\n\n\nGF_Err gf_import_timed_text(GF_MediaImporter *import)\n{\n\tGF_Err e;\n\tu32 fmt;\n\te = gf_text_guess_format(import->in_name, &fmt);\n\tif (e) return e;\n\tif (import->streamFormat) {\n\t\tif (!strcmp(import->streamFormat, \"VTT\")) fmt = GF_TEXT_IMPORT_WEBVTT;\n\t\telse if (!strcmp(import->streamFormat, \"TTML\")) fmt = GF_TEXT_IMPORT_TTML;\n\t\tif ((strstr(import->in_name, \".swf\") || strstr(import->in_name, \".SWF\")) && !stricmp(import->streamFormat, \"SVG\")) fmt = GF_TEXT_IMPORT_SWF_SVG;\n\t}\n\tif (!fmt) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTXT Import] Input %s does not look like a supported text format - ignoring\\n\", import->in_name));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tif (import->flags & GF_IMPORT_PROBE_ONLY) {\n\t\tif (fmt==GF_TEXT_IMPORT_SUB) import->flags |= GF_IMPORT_OVERRIDE_FPS;\n\t\treturn GF_OK;\n\t}\n\tswitch (fmt) {\n\tcase GF_TEXT_IMPORT_SRT:\n\t\treturn gf_text_import_srt(import);\n\tcase GF_TEXT_IMPORT_SUB:\n\t\treturn gf_text_import_sub(import);\n\tcase GF_TEXT_IMPORT_TTXT:\n\t\treturn gf_text_import_ttxt(import);\n\tcase GF_TEXT_IMPORT_TEXML:\n\t\treturn gf_text_import_texml(import);\n#ifndef GPAC_DISABLE_VTT\n\tcase GF_TEXT_IMPORT_WEBVTT:\n\t\treturn gf_text_import_webvtt(import);\n#endif\n\tcase GF_TEXT_IMPORT_SWF_SVG:\n\t\treturn gf_text_import_swf(import);\n\tcase GF_TEXT_IMPORT_TTML:\n\t\treturn gf_text_import_ttml(import);\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n}\n\n#endif /*GPAC_DISABLE_MEDIA_IMPORT*/\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2005-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / command-line client\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n/*includes both terminal and od browser*/\n#include <gpac/terminal.h>\n#include <gpac/term_info.h>\n#include <gpac/constants.h>\n#include <gpac/events.h>\n#include <gpac/media_tools.h>\n#include <gpac/options.h>\n#include <gpac/modules/service.h>\n#include <gpac/avparse.h>\n#include <gpac/network.h>\n#include <gpac/utf.h>\n#include <time.h>\n\n/*ISO 639 languages*/\n#include <gpac/iso639.h>\n\n//FIXME we need a plugin for playlists\n#include <gpac/internal/terminal_dev.h>\n\n\n#ifndef WIN32\n#include <dlfcn.h>\n#include <pwd.h>\n#include <unistd.h>\n#if defined(__DARWIN__) || defined(__APPLE__)\n#include <sys/types.h>\n#include <sys/stat.h>\n\nvoid carbon_init();\nvoid carbon_uninit();\n\n#endif\n\n#else\n#include <windows.h> /*for GetModuleFileName*/\n#endif\t//WIN32\n\n/*local prototypes*/\nvoid PrintWorldInfo(GF_Terminal *term);\nvoid ViewOD(GF_Terminal *term, u32 OD_ID, u32 number, const char *URL);\nvoid PrintODList(GF_Terminal *term, GF_ObjectManager *root_odm, u32 num, u32 indent, char *root_name);\n\nvoid ViewODs(GF_Terminal *term, Bool show_timing);\nvoid PrintGPACConfig();\n\nstatic u32 gui_mode = 0;\n\nstatic Bool restart = GF_FALSE;\nstatic Bool reload = GF_FALSE;\n\nBool no_prog = 0;\n\n#if defined(__DARWIN__) || defined(__APPLE__)\n//we keep no decoder thread because of JS_GC deadlocks between threads ...\nstatic u32 threading_flags = GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_DECODER_THREAD;\n#define VK_MOD  GF_KEY_MOD_ALT\n#else\nstatic u32 threading_flags = 0;\n#define VK_MOD  GF_KEY_MOD_CTRL\n#endif\nstatic Bool no_audio = GF_FALSE;\nstatic Bool term_step = GF_FALSE;\nstatic Bool no_regulation = GF_FALSE;\nstatic u32 bench_mode = 0;\nstatic u32 bench_mode_start = 0;\nstatic u32 bench_buffer = 0;\nstatic Bool eos_seen = GF_FALSE;\nstatic Bool addon_visible = GF_TRUE;\nBool is_connected = GF_FALSE;\nBool startup_file = GF_FALSE;\nGF_User user;\nGF_Terminal *term;\nu64 Duration;\nGF_Err last_error = GF_OK;\nstatic Bool enable_add_ons = GF_TRUE;\nstatic Fixed playback_speed = FIX_ONE;\n\nstatic s32 request_next_playlist_item = GF_FALSE;\nFILE *playlist = NULL;\nstatic Bool readonly_playlist = GF_FALSE;\n\nstatic GF_Config *cfg_file;\nstatic u32 display_rti = 0;\nstatic Bool Run;\nstatic Bool CanSeek = GF_FALSE;\nstatic char the_url[GF_MAX_PATH];\nstatic char pl_path[GF_MAX_PATH];\nstatic Bool no_mime_check = GF_TRUE;\nstatic Bool be_quiet = GF_FALSE;\nstatic u64 log_time_start = 0;\nstatic Bool log_utc_time = GF_FALSE;\nstatic Bool loop_at_end = GF_FALSE;\nstatic u32 forced_width=0;\nstatic u32 forced_height=0;\n\n/*windowless options*/\nu32 align_mode = 0;\nu32 init_w = 0;\nu32 init_h = 0;\nu32 last_x, last_y;\nBool right_down = GF_FALSE;\n\nvoid dump_frame(GF_Terminal *term, char *rad_path, u32 dump_type, u32 frameNum);\n\nenum\n{\n\tDUMP_NONE = 0,\n\tDUMP_AVI = 1,\n\tDUMP_BMP = 2,\n\tDUMP_PNG = 3,\n\tDUMP_RAW = 4,\n\tDUMP_SHA1 = 5,\n\n\t//DuMP flags\n\tDUMP_DEPTH_ONLY = 1<<16,\n\tDUMP_RGB_DEPTH = 1<<17,\n\tDUMP_RGB_DEPTH_SHAPE = 1<<18\n};\n\nBool dump_file(char *the_url, char *out_url, u32 dump_mode, Double fps, u32 width, u32 height, Float scale, u32 *times, u32 nb_times);\n\n\nstatic Bool shell_visible = GF_TRUE;\nvoid hide_shell(u32 cmd_type)\n{\n#if defined(WIN32) && !defined(_WIN32_WCE)\n\ttypedef HWND (WINAPI *GetConsoleWindowT)(void);\n\tHMODULE hk32 = GetModuleHandle(\"kernel32.dll\");\n\tGetConsoleWindowT GetConsoleWindow = (GetConsoleWindowT ) GetProcAddress(hk32,\"GetConsoleWindow\");\n\tif (cmd_type==0) {\n\t\tShowWindow( GetConsoleWindow(), SW_SHOW);\n\t\tshell_visible = GF_TRUE;\n\t}\n\telse if (cmd_type==1) {\n\t\tShowWindow( GetConsoleWindow(), SW_HIDE);\n\t\tshell_visible = GF_FALSE;\n\t}\n\telse if (cmd_type==2) PostMessage(GetConsoleWindow(), WM_CLOSE, 0, 0);\n\n#endif\n}\n\n\nvoid send_open_url(const char *url)\n{\n\tGF_Event evt;\n\tmemset(&evt, 0, sizeof(GF_Event));\n\tevt.type = GF_EVENT_NAVIGATE;\n\tevt.navigate.to_url = url;\n\tgf_term_send_event(term, &evt);\n}\n\nvoid PrintUsage()\n{\n\tfprintf(stderr, \"Usage MP4Client [options] [filename]\\n\"\n\t        \"\\t-c fileName:    user-defined configuration file. Also works with -cfg\\n\"\n#ifdef GPAC_MEMORY_TRACKING\n            \"\\t-mem-track:  enables memory tracker\\n\"\n            \"\\t-mem-track-stack:  enables memory tracker with stack dumping\\n\"\n#endif\n\t        \"\\t-rti fileName:  logs run-time info (FPS, CPU, Mem usage) to file\\n\"\n\t        \"\\t-rtix fileName: same as -rti but driven by GPAC logs\\n\"\n\t        \"\\t-quiet:         removes script message, buffering and downloading status\\n\"\n\t        \"\\t-strict-error:  exit when the player reports its first error\\n\"\n\t        \"\\t-opt option:    Overrides an option in the configuration file. String format is section:key=value. \\n\"\n\t        \"\\t                  \\\"section:key=null\\\" removes the key\\n\"\n\t        \"\\t                  \\\"section:*=null\\\" removes the section\\n\"\n\t        \"\\t-conf option:   Same as -opt but does not start player.\\n\"\n\t        \"\\t-log-file file: sets output log file. Also works with -lf\\n\"\n\t        \"\\t-logs log_args: sets log tools and levels, formatted as a ':'-separated list of toolX[:toolZ]@levelX\\n\"\n\t        \"\\t                 levelX can be one of:\\n\"\n\t        \"\\t        \\\"quiet\\\"      : skip logs\\n\"\n\t        \"\\t        \\\"error\\\"      : logs only error messages\\n\"\n\t        \"\\t        \\\"warning\\\"    : logs error+warning messages\\n\"\n\t        \"\\t        \\\"info\\\"       : logs error+warning+info messages\\n\"\n\t        \"\\t        \\\"debug\\\"      : logs all messages\\n\"\n\t        \"\\t                 toolX can be one of:\\n\"\n\t        \"\\t        \\\"core\\\"       : libgpac core\\n\"\n\t        \"\\t        \\\"coding\\\"     : bitstream formats (audio, video, scene)\\n\"\n\t        \"\\t        \\\"container\\\"  : container formats (ISO File, MPEG-2 TS, AVI, ...)\\n\"\n\t        \"\\t        \\\"network\\\"    : network data exept RTP trafic\\n\"\n\t        \"\\t        \\\"rtp\\\"        : rtp trafic\\n\"\n\t        \"\\t        \\\"author\\\"     : authoring tools (hint, import, export)\\n\"\n\t        \"\\t        \\\"sync\\\"       : terminal sync layer\\n\"\n\t        \"\\t        \\\"codec\\\"      : terminal codec messages\\n\"\n\t        \"\\t        \\\"parser\\\"     : scene parsers (svg, xmt, bt) and other\\n\"\n\t        \"\\t        \\\"media\\\"      : terminal media object management\\n\"\n\t        \"\\t        \\\"scene\\\"      : scene graph and scene manager\\n\"\n\t        \"\\t        \\\"script\\\"     : scripting engine messages\\n\"\n\t        \"\\t        \\\"interact\\\"   : interaction engine (events, scripts, etc)\\n\"\n\t        \"\\t        \\\"smil\\\"       : SMIL timing engine\\n\"\n\t        \"\\t        \\\"compose\\\"    : composition engine (2D, 3D, etc)\\n\"\n\t        \"\\t        \\\"mmio\\\"       : Audio/Video HW I/O management\\n\"\n\t        \"\\t        \\\"rti\\\"        : various run-time stats\\n\"\n\t        \"\\t        \\\"cache\\\"      : HTTP cache subsystem\\n\"\n\t        \"\\t        \\\"audio\\\"      : Audio renderer and mixers\\n\"\n#ifdef GPAC_MEMORY_TRACKING\n\t        \"\\t        \\\"mem\\\"        : GPAC memory tracker\\n\"\n#endif\n#ifndef GPAC_DISABLE_DASH_CLIENT\n\t        \"\\t        \\\"dash\\\"       : HTTP streaming logs\\n\"\n#endif\n\t        \"\\t        \\\"module\\\"     : GPAC modules debugging\\n\"\n\t        \"\\t        \\\"mutex\\\"      : mutex\\n\"\n\t        \"\\t        \\\"all\\\"        : all tools logged - other tools can be specified afterwards.\\n\"\n\t        \"\\tThe special value \\\"ncl\\\" disables color logs.\\n\"\n\t        \"\\n\"\n\t        \"\\t-log-clock or -lc      : logs time in micro sec since start time of GPAC before each log line.\\n\"\n\t        \"\\t-log-utc or -lu        : logs UTC time in ms before each log line.\\n\"\n\t        \"\\t-ifce IPIFCE           : Sets default Multicast interface\\n\"\n\t        \"\\t-size WxH:      specifies visual size (default: scene size)\\n\"\n#if defined(__DARWIN__) || defined(__APPLE__)\n\t        \"\\t-thread:        enables thread usage for terminal and compositor \\n\"\n#else\n\t        \"\\t-no-thread:     disables thread usage (except for audio)\\n\"\n#endif\n\t        \"\\t-no-cthread:    disables compositor thread (iOS and Android mode)\\n\"\n\t        \"\\t-no-audio:      disables audio \\n\"\n\t        \"\\t-no-wnd:        uses windowless mode (Win32 only)\\n\"\n\t        \"\\t-no-back:       uses transparent background for output window when no background is specified (Win32 only)\\n\"\n\t        \"\\t-align vh:      specifies v and h alignment for windowless mode\\n\"\n\t        \"\\t                 possible v values: t(op), m(iddle), b(ottom)\\n\"\n\t        \"\\t                 possible h values: l(eft), m(iddle), r(ight)\\n\"\n\t        \"\\t                 default alignment is top-left\\n\"\n\t        \"\\t                 default alignment is top-left\\n\"\n\t        \"\\t-pause:         pauses at first frame\\n\"\n\t        \"\\t-play-from T:   starts from T seconds in media\\n\"\n\t        \"\\t-speed S:       starts with speed S\\n\"\n\t        \"\\t-loop:          loops presentation\\n\"\n\t        \"\\t-no-regulation: disables framerate regulation\\n\"\n\t        \"\\t-bench:         disable a/v output and bench source decoding (as fast as possible)\\n\"\n\t        \"\\t-vbench:        disable audio output, video sync bench source decoding/display (as fast as possible)\\n\"\n\t        \"\\t-sbench:        disable all decoders and bench systems layer (as fast as possible)\\n\"\n\t        \"\\t-fs:            starts in fullscreen mode\\n\"\n\t        \"\\t-views v1:.:vN: creates an auto-stereo scene of N views. vN can be any type of URL supported by GPAC.\\n\"\n\t        \"\\t                 in this mode, URL argument of GPAC is ignored, GUI as well.\\n\"\n\t        \"\\t                 this is equivalent as using views://v1:.:N as an URL.\\n\"\n\t        \"\\t-mosaic v1:.:vN: creates a mosaic of N views. vN can be any type of URL supported by GPAC.\\n\"\n\t        \"\\t                 in this mode, URL argument of GPAC is ignored.\\n\"\n\t        \"\\t                 this is equivalent as using mosaic://v1:.:N as an URL.\\n\"\n\t        \"\\n\"\n\t        \"\\t-exit:          automatically exits when presentation is over\\n\"\n\t        \"\\t-run-for TIME:  runs for TIME seconds and exits\\n\"\n\t        \"\\t-service ID:    auto-tune to given service ID in a multiplex\\n\"\n\t        \"\\t-noprog:        disable progress report\\n\"\n\t        \"\\t-no-save:       disable saving config file on exit\\n\"\n\t        \"\\t-no-addon:      disable automatic loading of media addons declared in source URL\\n\"\n\t        \"\\t-gui:           starts in GUI mode. The GUI is indicated in GPAC config, section General, by the key [StartupFile]\\n\"\n\t        \"\\t-ntp-shift T:   shifts NTP clock of T (signed int) milliseconds\\n\"\n\t        \"\\n\"\n\t        \"Dumper Options (times is a formated as start-end, with start being sec, h:m:s:f/fps or h:m:s:ms):\\n\"\n\t        \"\\t-bmp [times]:   dumps given frames to bmp\\n\"\n\t        \"\\t-png [times]:   dumps given frames to png\\n\"\n\t        \"\\t-raw [times]:   dumps given frames to raw\\n\"\n\t        \"\\t-avi [times]:   dumps given file to raw avi\\n\"\n\t        \"\\t-sha [times]:   dumps given file to raw SHA-1 (1 hash per frame)\\n\"\n\t        \"\\r-out filename:  name of the output file\\n\"\n\t        \"\\t-rgbds:         dumps the RGBDS pixel format texture\\n\"\n\t        \"\\t                 with -avi [times]: dumps an rgbds-format .avi\\n\"\n\t        \"\\t-rgbd:          dumps the RGBD pixel format texture\\n\"\n\t        \"\\t                 with -avi [times]: dumps an rgbd-format .avi\\n\"\n\t        \"\\t-depth:         dumps depthmap (z-buffer) frames\\n\"\n\t        \"\\t                 with -avi [times]: dumps depthmap in grayscale .avi\\n\"\n\t        \"\\t                 with -bmp: dumps depthmap in grayscale .bmp\\n\"\n\t        \"\\t                 with -png: dumps depthmap in grayscale .png\\n\"\n\t        \"\\t-fps FPS:       specifies frame rate for AVI dumping (default: %f)\\n\"\n\t        \"\\t-scale s:       scales the visual size (default: 1)\\n\"\n\t        \"\\t-fill:          uses fill aspect ratio for dumping (default: none)\\n\"\n\t        \"\\t-show:          shows window while dumping (default: no)\\n\"\n\t        \"\\n\"\n\t        \"\\t-uncache:       Revert all cached items to their original name and location. Does not start player.\\n\"\n\t        \"\\n\"\n\t        \"\\t-help:          shows this screen\\n\"\n\t        \"\\n\"\n\t        \"MP4Client - GPAC command line player and dumper - version \"GPAC_FULL_VERSION\"\\n\"\n\t        \"(c) Telecom ParisTech 2000-2018 - Licence LGPL v2\\n\"\n\t        \"GPAC Configuration: \" GPAC_CONFIGURATION \"\\n\"\n\t        \"Features: %s\\n\",\n\t        GF_IMPORT_DEFAULT_FPS,\n\t        gpac_features()\n\t       );\n}\n\nvoid PrintHelp()\n{\n\tfprintf(stderr, \"MP4Client command keys:\\n\"\n\t        \"\\tq: quit\\n\"\n\t        \"\\tX: kill\\n\"\n\t        \"\\to: connect to the specified URL\\n\"\n\t        \"\\tO: connect to the specified playlist\\n\"\n\t        \"\\tN: switch to the next URL in the playlist. Also works with \\\\n\\n\"\n\t        \"\\tP: jumps to a given number ahead in the playlist\\n\"\n\t        \"\\tr: reload current presentation\\n\"\n\t        \"\\tD: disconnects the current presentation\\n\"\n\t        \"\\tG: selects object or service ID\\n\"\n\t        \"\\n\"\n\t        \"\\tp: play/pause the presentation\\n\"\n\t        \"\\ts: step one frame ahead\\n\"\n\t        \"\\tz: seek into presentation by percentage\\n\"\n\t        \"\\tT: seek into presentation by time\\n\"\n\t        \"\\tt: print current timing\\n\"\n\t        \"\\n\"\n\t        \"\\tu: sends a command (BIFS or LASeR) to the main scene\\n\"\n\t        \"\\te: evaluates JavaScript code\\n\"\n\t        \"\\tZ: dumps output video to PNG\\n\"\n\t        \"\\n\"\n\t        \"\\tw: view world info\\n\"\n\t        \"\\tv: view Object Descriptor list\\n\"\n\t        \"\\ti: view Object Descriptor info (by ID)\\n\"\n\t        \"\\tj: view Object Descriptor info (by number)\\n\"\n\t        \"\\tb: view media objects timing and buffering info\\n\"\n\t        \"\\tm: view media objects buffering and memory info\\n\"\n\t        \"\\td: dumps scene graph\\n\"\n\t        \"\\n\"\n\t        \"\\tk: turns stress mode on/off\\n\"\n\t        \"\\tn: changes navigation mode\\n\"\n\t        \"\\tx: reset to last active viewpoint\\n\"\n\t        \"\\n\"\n\t        \"\\t3: switch OpenGL on or off for 2D scenes\\n\"\n\t        \"\\n\"\n\t        \"\\t4: forces 4/3 Aspect Ratio\\n\"\n\t        \"\\t5: forces 16/9 Aspect Ratio\\n\"\n\t        \"\\t6: forces no Aspect Ratio (always fill screen)\\n\"\n\t        \"\\t7: forces original Aspect Ratio (default)\\n\"\n\t        \"\\n\"\n\t        \"\\tL: changes to new log level. CF MP4Client usage for possible values\\n\"\n\t        \"\\tT: select new tools to log. CF MP4Client usage for possible values\\n\"\n\t        \"\\n\"\n\t        \"\\tl: list available modules\\n\"\n\t        \"\\tc: prints some GPAC configuration info\\n\"\n\t        \"\\tE: forces reload of GPAC configuration\\n\"\n\t        \"\\n\"\n\t        \"\\tR: toggles run-time info display in window title bar on/off\\n\"\n\t        \"\\tF: toggle displaying of FPS in stderr on/off\\n\"\n\t        \"\\tg: print GPAC allocated memory\\n\"\n\t        \"\\th: print this message\\n\"\n\t        \"\\n\"\n\t        \"\\tEXPERIMENTAL/UNSTABLE OPTIONS\\n\"\n\t        \"\\tC: Enable Streaming Cache\\n\"\n\t        \"\\tS: Stops Streaming Cache and save to file\\n\"\n\t        \"\\tA: Aborts Streaming Cache\\n\"\n\t        \"\\tM: specifies video cache memory for 2D objects\\n\"\n\t        \"\\n\"\n\t        \"MP4Client - GPAC command line player - version %s\\n\"\n\t        \"GPAC Written by Jean Le Feuvre (c) 2001-2005 - ENST (c) 2005-200X\\n\",\n\n\t        GPAC_FULL_VERSION\n\t       );\n}\n\n\nstatic void PrintTime(u64 time)\n{\n\tu32 ms, h, m, s;\n\th = (u32) (time / 1000 / 3600);\n\tm = (u32) (time / 1000 / 60 - h*60);\n\ts = (u32) (time / 1000 - h*3600 - m*60);\n\tms = (u32) (time - (h*3600 + m*60 + s) * 1000);\n\tfprintf(stderr, \"%02d:%02d:%02d.%03d\", h, m, s, ms);\n}\n\nvoid PrintAVInfo(Bool final);\n\n\nstatic u32 rti_update_time_ms = 200;\nstatic FILE *rti_logs = NULL;\n\nstatic void UpdateRTInfo(const char *legend)\n{\n\tGF_SystemRTInfo rti;\n\n\t/*refresh every second*/\n\tif (!display_rti && !rti_logs) return;\n\tif (!gf_sys_get_rti(rti_update_time_ms, &rti, 0) && !legend)\n\t\treturn;\n\n\tif (display_rti) {\n\t\tchar szMsg[1024];\n\n\t\tif (rti.total_cpu_usage && (bench_mode<2) ) {\n\t\t\tsprintf(szMsg, \"FPS %02.02f CPU %2d (%02d) Mem %d kB\",\n\t\t\t        gf_term_get_framerate(term, 0), rti.total_cpu_usage, rti.process_cpu_usage, (u32) (rti.gpac_memory / 1024));\n\t\t} else {\n\t\t\tsprintf(szMsg, \"FPS %02.02f CPU %02d Mem %d kB\",\n\t\t\t        gf_term_get_framerate(term, 0), rti.process_cpu_usage, (u32) (rti.gpac_memory / 1024) );\n\t\t}\n\n\t\tif (display_rti==2) {\n\t\t\tif (bench_mode>=2) {\n\t\t\t\tPrintAVInfo(GF_FALSE);\n\t\t\t}\n\t\t\tfprintf(stderr, \"%s\\r\", szMsg);\n\t\t} else {\n\t\t\tGF_Event evt;\n\t\t\tevt.type = GF_EVENT_SET_CAPTION;\n\t\t\tevt.caption.caption = szMsg;\n\t\t\tgf_term_user_event(term, &evt);\n\t\t}\n\t}\n\tif (rti_logs) {\n\t\tfprintf(rti_logs, \"% 8d\\t% 8d\\t% 8d\\t% 4d\\t% 8d\\t%s\",\n\t\t        gf_sys_clock(),\n\t\t        gf_term_get_time_in_ms(term),\n\t\t        rti.total_cpu_usage,\n\t\t        (u32) gf_term_get_framerate(term, 0),\n\t\t        (u32) (rti.gpac_memory / 1024),\n\t\t        legend ? legend : \"\"\n\t\t       );\n\t\tif (!legend) fprintf(rti_logs, \"\\n\");\n\t}\n}\n\nstatic void ResetCaption()\n{\n\tGF_Event event;\n\tif (display_rti) return;\n\tevent.type = GF_EVENT_SET_CAPTION;\n\tif (is_connected) {\n\t\tchar szName[1024];\n\t\tNetInfoCommand com;\n\n\t\tevent.caption.caption = NULL;\n\t\t/*get any service info*/\n\t\tif (!startup_file && gf_term_get_service_info(term, gf_term_get_root_object(term), &com) == GF_OK) {\n\t\t\tstrcpy(szName, \"\");\n\t\t\tif (com.track_info) {\n\t\t\t\tchar szBuf[10];\n\t\t\t\tsprintf(szBuf, \"%02d \", (u32) (com.track_info>>16) );\n\t\t\t\tstrcat(szName, szBuf);\n\t\t\t}\n\t\t\tif (com.artist) {\n\t\t\t\tstrcat(szName, com.artist);\n\t\t\t\tstrcat(szName, \" \");\n\t\t\t}\n\t\t\tif (com.name) {\n\t\t\t\tstrcat(szName, com.name);\n\t\t\t\tstrcat(szName, \" \");\n\t\t\t}\n\t\t\tif (com.album) {\n\t\t\t\tstrcat(szName, \"(\");\n\t\t\t\tstrcat(szName, com.album);\n\t\t\t\tstrcat(szName, \")\");\n\t\t\t}\n\t\t\tif (com.provider) {\n\t\t\t\tstrcat(szName, \"(\");\n\t\t\t\tstrcat(szName, com.provider);\n\t\t\t\tstrcat(szName, \")\");\n\t\t\t}\n\n\t\t\tif (strlen(szName)) event.caption.caption = szName;\n\t\t}\n\t\tif (!event.caption.caption) {\n\t\t\tchar *str = strrchr(the_url, '\\\\');\n\t\t\tif (!str) str = strrchr(the_url, '/');\n\t\t\tevent.caption.caption = str ? str+1 : the_url;\n\t\t}\n\t} else {\n\t\tevent.caption.caption = \"GPAC MP4Client \" GPAC_FULL_VERSION;\n\t}\n\tgf_term_user_event(term, &event);\n}\n\n#ifdef WIN32\nu32 get_sys_col(int idx)\n{\n\tu32 res;\n\tDWORD val = GetSysColor(idx);\n\tres = (val)&0xFF;\n\tres<<=8;\n\tres |= (val>>8)&0xFF;\n\tres<<=8;\n\tres |= (val>>16)&0xFF;\n\treturn res;\n}\n#endif\n\nvoid switch_bench(u32 is_on)\n{\n\tbench_mode = is_on;\n\tdisplay_rti = is_on ? 2 : 0;\n\tResetCaption();\n\tgf_term_set_option(term, GF_OPT_VIDEO_BENCH, is_on);\n}\n\n#ifndef WIN32\n#include <termios.h>\nint getch() {\n\tstruct termios old;\n\tstruct termios new;\n\tint rc;\n\tif (tcgetattr(0, &old) == -1) {\n\t\treturn -1;\n\t}\n\tnew = old;\n\tnew.c_lflag &= ~(ICANON | ECHO);\n\tnew.c_cc[VMIN] = 1;\n\tnew.c_cc[VTIME] = 0;\n\tif (tcsetattr(0, TCSANOW, &new) == -1) {\n\t\treturn -1;\n\t}\n\trc = getchar();\n\t(void) tcsetattr(0, TCSANOW, &old);\n\treturn rc;\n}\n#else\nint getch() {\n\treturn getchar();\n}\n#endif\n\n/**\n * Reads a line of input from stdin\n * @param line the buffer to fill\n * @param maxSize the maximum size of the line to read\n * @param showContent boolean indicating if the line read should be printed on stderr or not\n */\nstatic const char * read_line_input(char * line, int maxSize, Bool showContent) {\n\tchar read;\n\tint i = 0;\n\tif (fflush( stderr ))\n\t\tperror(\"Failed to flush buffer %s\");\n\tdo {\n\t\tline[i] = '\\0';\n\t\tif (i >= maxSize - 1)\n\t\t\treturn line;\n\t\tread = getch();\n\t\tif (read == 8 || read == 127) {\n\t\t\tif (i > 0) {\n\t\t\t\tfprintf(stderr, \"\\b \\b\");\n\t\t\t\ti--;\n\t\t\t}\n\t\t} else if (read > 32) {\n\t\t\tfputc(showContent ? read : '*', stderr);\n\t\t\tline[i++] = read;\n\t\t}\n\t\tfflush(stderr);\n\t} while (read != '\\n');\n\tif (!read)\n\t\treturn 0;\n\treturn line;\n}\n\nstatic void do_set_speed(Fixed desired_speed)\n{\n\tif (gf_term_set_speed(term, desired_speed) == GF_OK) {\n\t\tplayback_speed = desired_speed;\n\t\tfprintf(stderr, \"Playing at %g speed\\n\", FIX2FLT(playback_speed));\n\t} else {\n\t\tfprintf(stderr, \"Adjusting speed to %g not supported for this content\\n\", FIX2FLT(desired_speed));\n\t}\n}\n\nBool GPAC_EventProc(void *ptr, GF_Event *evt)\n{\n\tif (!term) return 0;\n\n\tif (gui_mode==1) {\n\t\tif (evt->type==GF_EVENT_QUIT) {\n\t\t\tRun = 0;\n\t\t} else if (evt->type==GF_EVENT_KEYDOWN) {\n\t\t\tswitch (evt->key.key_code) {\n\t\t\tcase GF_KEY_C:\n\t\t\t\tif (evt->key.flags & (GF_KEY_MOD_CTRL|GF_KEY_MOD_ALT)) {\n\t\t\t\t\thide_shell(shell_visible ? 1 : 0);\n\t\t\t\t\tif (shell_visible) gui_mode=2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tswitch (evt->type) {\n\tcase GF_EVENT_DURATION:\n\t\tDuration = (u64) ( 1000 * (s64) evt->duration.duration);\n\t\tCanSeek = evt->duration.can_seek;\n\t\tbreak;\n\tcase GF_EVENT_MESSAGE:\n\t{\n\t\tconst char *servName;\n\t\tif (!evt->message.service || !strcmp(evt->message.service, the_url)) {\n\t\t\tservName = \"\";\n\t\t} else if (!strnicmp(evt->message.service, \"data:\", 5)) {\n\t\t\tservName = \"(embedded data)\";\n\t\t} else {\n\t\t\tservName = evt->message.service;\n\t\t}\n\n\n\t\tif (!evt->message.message) return 0;\n\n\t\tif (evt->message.error) {\n\t\t\tif (!is_connected) last_error = evt->message.error;\n\t\t\tif (evt->message.error==GF_SCRIPT_INFO) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONSOLE, (\"%s\\n\", evt->message.message));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONSOLE, (\"%s %s: %s\\n\", servName, evt->message.message, gf_error_to_string(evt->message.error)));\n\t\t\t}\n\t\t} else if (!be_quiet)\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONSOLE, (\"%s %s\\n\", servName, evt->message.message));\n\t}\n\tbreak;\n\tcase GF_EVENT_PROGRESS:\n\t{\n\t\tchar *szTitle = \"\";\n\t\tif (evt->progress.progress_type==0) {\n\t\t\tszTitle = \"Buffer \";\n\t\t\tif (bench_mode && (bench_mode!=3) ) {\n\t\t\t\tif (evt->progress.done >= evt->progress.total) bench_buffer = 0;\n\t\t\t\telse bench_buffer = 1 + 100*evt->progress.done / evt->progress.total;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (evt->progress.progress_type==1) {\n\t\t\tif (bench_mode) break;\n\t\t\tszTitle = \"Download \";\n\t\t}\n\t\telse if (evt->progress.progress_type==2) szTitle = \"Import \";\n\t\tgf_set_progress(szTitle, evt->progress.done, evt->progress.total);\n\t}\n\tbreak;\n\n\n\tcase GF_EVENT_DBLCLICK:\n\t\tgf_term_set_option(term, GF_OPT_FULLSCREEN, !gf_term_get_option(term, GF_OPT_FULLSCREEN));\n\t\treturn 0;\n\n\tcase GF_EVENT_MOUSEDOWN:\n\t\tif (evt->mouse.button==GF_MOUSE_RIGHT) {\n\t\t\tright_down = 1;\n\t\t\tlast_x = evt->mouse.x;\n\t\t\tlast_y = evt->mouse.y;\n\t\t}\n\t\treturn 0;\n\tcase GF_EVENT_MOUSEUP:\n\t\tif (evt->mouse.button==GF_MOUSE_RIGHT) {\n\t\t\tright_down = 0;\n\t\t\tlast_x = evt->mouse.x;\n\t\t\tlast_y = evt->mouse.y;\n\t\t}\n\t\treturn 0;\n\tcase GF_EVENT_MOUSEMOVE:\n\t\tif (right_down && (user.init_flags & GF_TERM_WINDOWLESS) ) {\n\t\t\tGF_Event move;\n\t\t\tmove.move.x = evt->mouse.x - last_x;\n\t\t\tmove.move.y = last_y-evt->mouse.y;\n\t\t\tmove.type = GF_EVENT_MOVE;\n\t\t\tmove.move.relative = 1;\n\t\t\tgf_term_user_event(term, &move);\n\t\t}\n\t\treturn 0;\n\n\tcase GF_EVENT_KEYUP:\n\t\tswitch (evt->key.key_code) {\n\t\tcase GF_KEY_SPACE:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) switch_bench(!bench_mode);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_KEYDOWN:\n\t\tgf_term_process_shortcut(term, evt);\n\t\tswitch (evt->key.key_code) {\n\t\tcase GF_KEY_SPACE:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) {\n\t\t\t\t/*ignore key repeat*/\n\t\t\t\tif (!bench_mode) switch_bench(!bench_mode);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_PAGEDOWN:\n\t\tcase GF_KEY_MEDIANEXTTRACK:\n\t\t\trequest_next_playlist_item = 1;\n\t\t\tbreak;\n\t\tcase GF_KEY_MEDIAPREVIOUSTRACK:\n\t\t\tbreak;\n\t\tcase GF_KEY_ESCAPE:\n\t\t\tgf_term_set_option(term, GF_OPT_FULLSCREEN, !gf_term_get_option(term, GF_OPT_FULLSCREEN));\n\t\t\tbreak;\n\t\tcase GF_KEY_C:\n\t\t\tif (evt->key.flags & (GF_KEY_MOD_CTRL|GF_KEY_MOD_ALT)) {\n\t\t\t\thide_shell(shell_visible ? 1 : 0);\n\t\t\t\tif (!shell_visible) gui_mode=1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_F:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) fprintf(stderr, \"Rendering rate: %f FPS\\n\", gf_term_get_framerate(term, 0));\n\t\t\tbreak;\n\t\tcase GF_KEY_T:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) fprintf(stderr, \"Scene Time: %f \\n\", gf_term_get_time_in_ms(term)/1000.0);\n\t\t\tbreak;\n\t\tcase GF_KEY_D:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) gf_term_set_option(term, GF_OPT_DRAW_MODE, (gf_term_get_option(term, GF_OPT_DRAW_MODE)==GF_DRAW_MODE_DEFER) ? GF_DRAW_MODE_IMMEDIATE : GF_DRAW_MODE_DEFER );\n\t\t\tbreak;\n\t\tcase GF_KEY_4:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);\n\t\t\tbreak;\n\t\tcase GF_KEY_5:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);\n\t\t\tbreak;\n\t\tcase GF_KEY_6:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t\t\tbreak;\n\t\tcase GF_KEY_7:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);\n\t\t\tbreak;\n\t\tcase GF_KEY_O:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tif (gf_term_get_option(term, GF_OPT_MAIN_ADDON)) {\n\t\t\t\t\tfprintf(stderr, \"Resuming to main content\\n\");\n\t\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_PLAY_LIVE);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Main addon not enabled\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_P:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tu32 pause_state = gf_term_get_option(term, GF_OPT_PLAY_STATE) ;\n\t\t\t\tfprintf(stderr, \"[Status: %s]\\n\", pause_state ? \"Playing\" : \"Paused\");\n\t\t\t\tif ((pause_state == GF_STATE_PAUSED) && (evt->key.flags & GF_KEY_MOD_SHIFT)) {\n\t\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_PLAY_LIVE);\n\t\t\t\t} else {\n\t\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, (pause_state==GF_STATE_PAUSED) ? GF_STATE_PLAYING : GF_STATE_PAUSED);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_S:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);\n\t\t\t\tfprintf(stderr, \"Step time: \");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_B:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected)\n\t\t\t\tViewODs(term, 1);\n\t\t\tbreak;\n\t\tcase GF_KEY_M:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected)\n\t\t\t\tViewODs(term, 0);\n\t\t\tbreak;\n\t\tcase GF_KEY_H:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tgf_term_switch_quality(term, 1);\n\t\t\t//\tgf_term_set_option(term, GF_OPT_MULTIVIEW_MODE, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_L:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tgf_term_switch_quality(term, 0);\n\t\t\t//\tgf_term_set_option(term, GF_OPT_MULTIVIEW_MODE, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_F5:\n\t\t\tif (is_connected)\n\t\t\t\treload = 1;\n\t\t\tbreak;\n\t\tcase GF_KEY_A:\n\t\t\taddon_visible = !addon_visible;\n\t\t\tgf_term_toggle_addons(term, addon_visible);\n\t\t\tbreak;\n\t\tcase GF_KEY_UP:\n\t\t\tif ((evt->key.flags & VK_MOD) && is_connected) {\n\t\t\t\tdo_set_speed(playback_speed * 2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_DOWN:\n\t\t\tif ((evt->key.flags & VK_MOD) && is_connected) {\n\t\t\t\tdo_set_speed(playback_speed / 2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_LEFT:\n\t\t\tif ((evt->key.flags & VK_MOD) && is_connected) {\n\t\t\t\tdo_set_speed(-1 * playback_speed );\n\t\t\t}\n\t\t\tbreak;\n\n\t\t}\n\t\tbreak;\n\n\tcase GF_EVENT_CONNECT:\n\t\tif (evt->connect.is_connected) {\n\t\t\tis_connected = 1;\n\t\t\tfprintf(stderr, \"Service Connected\\n\");\n\t\t\teos_seen = GF_FALSE;\n\t\t\tif (playback_speed != FIX_ONE)\n\t\t\t\tgf_term_set_speed(term, playback_speed);\n\n\t\t} else if (is_connected) {\n\t\t\tfprintf(stderr, \"Service %s\\n\", is_connected ? \"Disconnected\" : \"Connection Failed\");\n\t\t\tis_connected = 0;\n\t\t\tDuration = 0;\n\t\t}\n\t\tif (init_w && init_h) {\n\t\t\tgf_term_set_size(term, init_w, init_h);\n\t\t}\n\t\tResetCaption();\n\t\tbreak;\n\tcase GF_EVENT_EOS:\n\t\teos_seen = GF_TRUE;\n\t\tif (playlist) {\n\t\t\tif (Duration>1500)\n\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t}\n\t\telse if (loop_at_end) {\n\t\t\trestart = 1;\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_SIZE:\n\t\tif (user.init_flags & GF_TERM_WINDOWLESS) {\n\t\t\tGF_Event move;\n\t\t\tmove.type = GF_EVENT_MOVE;\n\t\t\tmove.move.align_x = align_mode & 0xFF;\n\t\t\tmove.move.align_y = (align_mode>>8) & 0xFF;\n\t\t\tmove.move.relative = 2;\n\t\t\tgf_term_user_event(term, &move);\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_SCENE_SIZE:\n\t\tif (forced_width && forced_height) {\n\t\t\tGF_Event size;\n\t\t\tsize.type = GF_EVENT_SIZE;\n\t\t\tsize.size.width = forced_width;\n\t\t\tsize.size.height = forced_height;\n\t\t\tgf_term_user_event(term, &size);\n\t\t}\n\t\tbreak;\n\n\tcase GF_EVENT_METADATA:\n\t\tResetCaption();\n\t\tbreak;\n\n\tcase GF_EVENT_RELOAD:\n\t\tif (is_connected)\n\t\t\treload = 1;\n\t\tbreak;\n\tcase GF_EVENT_DROPFILE:\n\t{\n\t\tu32 i, pos;\n\t\t/*todo - force playlist mode*/\n\t\tif (readonly_playlist) {\n\t\t\tgf_fclose(playlist);\n\t\t\tplaylist = NULL;\n\t\t}\n\t\treadonly_playlist = 0;\n\t\tif (!playlist) {\n\t\t\treadonly_playlist = 0;\n\t\t\tplaylist = gf_temp_file_new(NULL);\n\t\t}\n\t\tpos = ftell(playlist);\n\t\ti=0;\n\t\twhile (i<evt->open_file.nb_files) {\n\t\t\tif (evt->open_file.files[i] != NULL) {\n\t\t\t\tfprintf(playlist, \"%s\\n\", evt->open_file.files[i]);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tfseek(playlist, pos, SEEK_SET);\n\t\trequest_next_playlist_item = 1;\n\t}\n\treturn 1;\n\n\tcase GF_EVENT_QUIT:\n\t\tif (evt->message.error)  {\n\t\t\tfprintf(stderr, \"A fatal error was encoutered: %s (%s) - exiting ...\\n\", evt->message.message ? evt->message.message : \"no details\", gf_error_to_string(evt->message.error) );\n\t\t}\n\t\tRun = 0;\n\t\tbreak;\n\tcase GF_EVENT_DISCONNECT:\n\t\tgf_term_disconnect(term);\n\t\tbreak;\n\tcase GF_EVENT_MIGRATE:\n\t{\n\t}\n\tbreak;\n\tcase GF_EVENT_NAVIGATE_INFO:\n\t\tif (evt->navigate.to_url) fprintf(stderr, \"Go to URL: \\\"%s\\\"\\r\", evt->navigate.to_url);\n\t\tbreak;\n\tcase GF_EVENT_NAVIGATE:\n\t\tif (gf_term_is_supported_url(term, evt->navigate.to_url, 1, no_mime_check)) {\n\t\t\tstrncpy(the_url, evt->navigate.to_url, sizeof(the_url)-1);\n\t\t\tthe_url[sizeof(the_url) - 1] = 0;\n\t\t\tfprintf(stderr, \"Navigating to URL %s\\n\", the_url);\n\t\t\tgf_term_navigate_to(term, evt->navigate.to_url);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tfprintf(stderr, \"Navigation destination not supported\\nGo to URL: %s\\n\", evt->navigate.to_url);\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_SET_CAPTION:\n\t\tgf_term_user_event(term, evt);\n\t\tbreak;\n\tcase GF_EVENT_AUTHORIZATION:\n\t{\n\t\tint maxTries = 1;\n\t\tassert( evt->type == GF_EVENT_AUTHORIZATION);\n\t\tassert( evt->auth.user);\n\t\tassert( evt->auth.password);\n\t\tassert( evt->auth.site_url);\n\t\twhile ((!strlen(evt->auth.user) || !strlen(evt->auth.password)) && (maxTries--) >= 0) {\n\t\t\tfprintf(stderr, \"**** Authorization required for site %s ****\\n\", evt->auth.site_url);\n\t\t\tfprintf(stderr, \"login   : \");\n\t\t\tread_line_input(evt->auth.user, 50, 1);\n\t\t\tfprintf(stderr, \"\\npassword: \");\n\t\t\tread_line_input(evt->auth.password, 50, 0);\n\t\t\tfprintf(stderr, \"*********\\n\");\n\t\t}\n\t\tif (maxTries < 0) {\n\t\t\tfprintf(stderr, \"**** No User or password has been filled, aborting ***\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\tcase GF_EVENT_ADDON_DETECTED:\n\t\tif (enable_add_ons) {\n\t\t\tfprintf(stderr, \"Media Addon %s detected - enabling it\\n\", evt->addon_connect.addon_url);\n\t\t\taddon_visible = 1;\n\t\t}\n\t\treturn enable_add_ons;\n\t}\n\treturn 0;\n}\n\n\nvoid list_modules(GF_ModuleManager *modules)\n{\n\tu32 i;\n\tfprintf(stderr, \"\\rAvailable modules:\\n\");\n\tfor (i=0; i<gf_modules_get_count(modules); i++) {\n\t\tchar *str = (char *) gf_modules_get_file_name(modules, i);\n\t\tif (str) fprintf(stderr, \"\\t%s\\n\", str);\n\t}\n\tfprintf(stderr, \"\\n\");\n}\n\nvoid set_navigation()\n{\n\tGF_Err e;\n\tchar nav;\n\tu32 type = gf_term_get_option(term, GF_OPT_NAVIGATION_TYPE);\n\te = GF_OK;\n\tfflush(stdin);\n\n\tif (!type) {\n\t\tfprintf(stderr, \"Content/compositor doesn't allow user-selectable navigation\\n\");\n\t} else if (type==1) {\n\t\tfprintf(stderr, \"Select Navigation (\\'N\\'one, \\'E\\'xamine, \\'S\\'lide): \");\n\t\tnav = getch();\n\t\tif (nav=='N') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_NONE);\n\t\telse if (nav=='E') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_EXAMINE);\n\t\telse if (nav=='S') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_SLIDE);\n\t\telse fprintf(stderr, \"Unknown selector \\'%c\\' - only \\'N\\',\\'E\\',\\'S\\' allowed\\n\", nav);\n\t} else if (type==2) {\n\t\tfprintf(stderr, \"Select Navigation (\\'N\\'one, \\'W\\'alk, \\'F\\'ly, \\'E\\'xamine, \\'P\\'an, \\'S\\'lide, \\'G\\'ame, \\'V\\'R, \\'O\\'rbit): \");\n\t\tnav = getch();\n\t\tif (nav=='N') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_NONE);\n\t\telse if (nav=='W') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_WALK);\n\t\telse if (nav=='F') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_FLY);\n\t\telse if (nav=='E') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_EXAMINE);\n\t\telse if (nav=='P') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_PAN);\n\t\telse if (nav=='S') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_SLIDE);\n\t\telse if (nav=='G') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_GAME);\n\t\telse if (nav=='O') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_ORBIT);\n\t\telse if (nav=='V') e = gf_term_set_option(term, GF_OPT_NAVIGATION, GF_NAVIGATE_VR);\n\t\telse fprintf(stderr, \"Unknown selector %c - only \\'N\\',\\'W\\',\\'F\\',\\'E\\',\\'P\\',\\'S\\',\\'G\\', \\'V\\', \\'O\\' allowed\\n\", nav);\n\t}\n\tif (e) fprintf(stderr, \"Error setting mode: %s\\n\", gf_error_to_string(e));\n}\n\n\nstatic Bool get_time_list(char *arg, u32 *times, u32 *nb_times)\n{\n\tchar *str;\n\tFloat var;\n\tDouble sec;\n\tu32 h, m, s, ms, f, fps;\n\tif (!arg || (arg[0]=='-') || !isdigit(arg[0])) return 0;\n\n\t/*SMPTE time code*/\n\tif (strchr(arg, ':') && strchr(arg, ';') && strchr(arg, '/')) {\n\t\tif (sscanf(arg, \"%02ud:%02ud:%02ud;%02ud/%02ud\", &h, &m, &s, &f, &fps)==5) {\n\t\t\tsec = 0;\n\t\t\tif (fps) sec = ((Double)f) / fps;\n\t\t\tsec += 3600*h + 60*m + s;\n\t\t\ttimes[*nb_times] = (u32) (1000*sec);\n\t\t\t(*nb_times) ++;\n\t\t\treturn 1;\n\t\t}\n\t}\n\twhile (arg) {\n\t\tstr = strchr(arg, '-');\n\t\tif (str) str[0] = 0;\n\t\t/*HH:MM:SS:MS time code*/\n\t\tif (strchr(arg, ':') && (sscanf(arg, \"%u:%u:%u:%u\", &h, &m, &s, &ms)==4)) {\n\t\t\tsec = ms;\n\t\t\tsec /= 1000;\n\t\t\tsec += 3600*h + 60*m + s;\n\t\t\ttimes[*nb_times] = (u32) (1000*sec);\n\t\t\t(*nb_times) ++;\n\t\t} else if (sscanf(arg, \"%f\", &var)==1) {\n\t\t\tsec = atof(arg);\n\t\t\ttimes[*nb_times] = (u32) (1000*sec);\n\t\t\t(*nb_times) ++;\n\t\t}\n\t\tif (!str) break;\n\t\tstr[0] = '-';\n\t\targ = str+1;\n\t}\n\treturn 1;\n}\n\nstatic u64 last_log_time=0;\nstatic void on_gpac_log(void *cbk, GF_LOG_Level ll, GF_LOG_Tool lm, const char *fmt, va_list list)\n{\n\tFILE *logs = cbk ? cbk : stderr;\n\n\tif (rti_logs && (lm & GF_LOG_RTI)) {\n\t\tchar szMsg[2048];\n\t\tvsprintf(szMsg, fmt, list);\n\t\tUpdateRTInfo(szMsg + 6 /*\"[RTI] \"*/);\n\t} else {\n\t\tif (log_time_start) {\n\t\t\tu64 now = gf_sys_clock_high_res();\n\t\t\tfprintf(logs, \"At \"LLD\" (diff %d) - \", now - log_time_start, (u32) (now - last_log_time) );\n\t\t\tlast_log_time = now;\n\t\t}\n\t\tif (log_utc_time) {\n\t\t\tu64 utc_clock = gf_net_get_utc() ;\n\t\t\ttime_t secs = utc_clock/1000;\n\t\t\tstruct tm t;\n\t\t\tt = *gmtime(&secs);\n\t\t\tfprintf(logs, \"UTC %d-%02d-%02dT%02d:%02d:%02dZ (TS \"LLU\") - \", 1900+t.tm_year, t.tm_mon+1, t.tm_mday, t.tm_hour, t.tm_min, t.tm_sec, utc_clock);\n\t\t}\n\t\tvfprintf(logs, fmt, list);\n\t\tfflush(logs);\n\t}\n}\n\nstatic void init_rti_logs(char *rti_file, char *url, Bool use_rtix)\n{\n\tif (rti_logs) gf_fclose(rti_logs);\n\trti_logs = gf_fopen(rti_file, \"wt\");\n\tif (rti_logs) {\n\t\tfprintf(rti_logs, \"!! GPAC RunTime Info \");\n\t\tif (url) fprintf(rti_logs, \"for file %s\", url);\n\t\tfprintf(rti_logs, \" !!\\n\");\n\t\tfprintf(rti_logs, \"SysTime(ms)\\tSceneTime(ms)\\tCPU\\tFPS\\tMemory(kB)\\tObservation\\n\");\n\n\t\t/*turn on RTI loging*/\n\t\tif (use_rtix) {\n\t\t\tgf_log_set_callback(NULL, on_gpac_log);\n\t\t\tgf_log_set_tool_level(GF_LOG_RTI, GF_LOG_DEBUG);\n\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_RTI, (\"[RTI] System state when enabling log\\n\"));\n\t\t} else if (log_time_start) {\n\t\t\tlog_time_start = gf_sys_clock_high_res();\n\t\t}\n\t}\n}\n\nvoid set_cfg_option(char *opt_string)\n{\n\tchar *sep, *sep2, szSec[1024], szKey[1024], szVal[1024];\n\tsep = strchr(opt_string, ':');\n\tif (!sep) {\n\t\tfprintf(stderr, \"Badly formatted option %s - expected Section:Name=Value\\n\", opt_string);\n\t\treturn;\n\t}\n\t{\n\t\tconst size_t sepIdx = sep - opt_string;\n\t\tif (sepIdx >= sizeof(szSec)) {\n\t\t\tfprintf(stderr, \"Badly formatted option %s - Section name is too long\\n\", opt_string);\n\t\t\treturn;\n\t\t}\n\n\t\tstrncpy(szSec, opt_string, sepIdx);\n\t\tszSec[sepIdx] = 0;\n\t}\n\tsep ++;\n\tsep2 = strchr(sep, '=');\n\tif (!sep2) {\n\t\tfprintf(stderr, \"Badly formatted option %s - expected Section:Name=Value\\n\", opt_string);\n\t\treturn;\n\t}\n\t{\n\t\tconst size_t sepIdx = sep2 - sep;\n\t\tif (sepIdx >= sizeof(szKey)) {\n\t\t\tfprintf(stderr, \"Badly formatted option %s - key name is too long\\n\", opt_string);\n\t\t\treturn;\n\t\t}\n\t\tstrncpy(szKey, sep, sepIdx);\n\t\tszKey[sepIdx] = 0;\n\t\tif (strlen(sep2 + 1) >= sizeof(szVal)) {\n\t\t\tfprintf(stderr, \"Badly formatted option %s - value is too long\\n\", opt_string);\n\t\t\treturn;\n\t\t}\n\t\tstrcpy(szVal, sep2+1);\n\t}\n\n\tif (!stricmp(szKey, \"*\")) {\n\t\tif (stricmp(szVal, \"null\")) {\n\t\t\tfprintf(stderr, \"Badly formatted option %s - expected Section:*=null\\n\", opt_string);\n\t\t\treturn;\n\t\t}\n\t\tgf_cfg_del_section(cfg_file, szSec);\n\t\treturn;\n\t}\n\n\tif (!stricmp(szVal, \"null\")) {\n\t\tszVal[0]=0;\n\t}\n\tgf_cfg_set_key(cfg_file, szSec, szKey, szVal[0] ? szVal : NULL);\n}\n\nBool revert_cache_file(void *cbck, char *item_name, char *item_path, GF_FileEnumInfo *file_info)\n{\n\tconst char *url;\n\tchar *sep;\n\tGF_Config *cached;\n\tif (strncmp(item_name, \"gpac_cache_\", 11)) return GF_FALSE;\n\tcached = gf_cfg_new(NULL, item_path);\n\turl = gf_cfg_get_key(cached, \"cache\", \"url\");\n\tif (url) url = strstr(url, \"://\");\n\tif (url) {\n\t\tu32 i, len, dir_len=0, k=0;\n\t\tchar *dst_name;\n\t\tsep = strstr(item_path, \"gpac_cache_\");\n\t\tif (sep) {\n\t\t\tsep[0] = 0;\n\t\t\tdir_len = (u32) strlen(item_path);\n\t\t\tsep[0] = 'g';\n\t\t}\n\t\turl+=3;\n\t\tlen = (u32) strlen(url);\n\t\tdst_name = gf_malloc(len+dir_len+1);\n\t\tmemset(dst_name, 0, len+dir_len+1);\n\n\t\tstrncpy(dst_name, item_path, dir_len);\n\t\tk=dir_len;\n\t\tfor (i=0; i<len; i++) {\n\t\t\tdst_name[k] = url[i];\n\t\t\tif (dst_name[k]==':') dst_name[k]='_';\n\t\t\telse if (dst_name[k]=='/') {\n\t\t\t\tif (!gf_dir_exists(dst_name))\n\t\t\t\t\tgf_mkdir(dst_name);\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\t\tsep = strrchr(item_path, '.');\n\t\tif (sep) {\n\t\t\tsep[0]=0;\n\t\t\tif (gf_file_exists(item_path)) {\n\t\t\t\tgf_move_file(item_path, dst_name);\n\t\t\t}\n\t\t\tsep[0]='.';\n\t\t}\n\t\tgf_free(dst_name);\n\t}\n\tgf_cfg_del(cached);\n\tgf_delete_file(item_path);\n\treturn GF_FALSE;\n}\nvoid do_flatten_cache(const char *cache_dir)\n{\n\tgf_enum_directory(cache_dir, GF_FALSE, revert_cache_file, NULL, \"*.txt\");\n}\n\n\n#ifdef WIN32\n#include <wincon.h>\n#endif\n\nstatic void progress_quiet(const void *cbck, const char *title, u64 done, u64 total) { }\n\nint mp4client_main(int argc, char **argv)\n{\n\tchar c;\n\tconst char *str;\n\tint ret_val = 0;\n\tu32 i, times[100], nb_times, dump_mode;\n\tu32 simulation_time_in_ms = 0;\n\tu32 initial_service_id = 0;\n\tBool auto_exit = GF_FALSE;\n\tBool logs_set = GF_FALSE;\n\tBool start_fs = GF_FALSE;\n\tBool use_rtix = GF_FALSE;\n\tBool pause_at_first = GF_FALSE;\n\tBool no_cfg_save = GF_FALSE;\n\tBool is_cfg_only = GF_FALSE;\n\n\tDouble play_from = 0;\n#ifdef GPAC_MEMORY_TRACKING\n    GF_MemTrackerType mem_track = GF_MemTrackerNone;\n#endif\n\tDouble fps = GF_IMPORT_DEFAULT_FPS;\n\tBool fill_ar, visible, do_uncache, has_command;\n\tchar *url_arg, *out_arg, *the_cfg, *rti_file, *views, *mosaic;\n\tFILE *logfile = NULL;\n\tFloat scale = 1;\n#ifndef WIN32\n\tdlopen(NULL, RTLD_NOW|RTLD_GLOBAL);\n#endif\n\n\t/*by default use current dir*/\n\tstrcpy(the_url, \".\");\n\n\tmemset(&user, 0, sizeof(GF_User));\n\n\tdump_mode = DUMP_NONE;\n\tfill_ar = visible = do_uncache = has_command = GF_FALSE;\n\turl_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL;\n\tnb_times = 0;\n\ttimes[0] = 0;\n\n\t/*first locate config file if specified*/\n\tfor (i=1; i<(u32) argc; i++) {\n\t\tchar *arg = argv[i];\n\t\tif (!strcmp(arg, \"-c\") || !strcmp(arg, \"-cfg\")) {\n\t\t\tthe_cfg = argv[i+1];\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, \"-mem-track\") || !strcmp(arg, \"-mem-track-stack\")) {\n#ifdef GPAC_MEMORY_TRACKING\n            mem_track = !strcmp(arg, \"-mem-track-stack\") ? GF_MemTrackerBackTrace : GF_MemTrackerSimple;\n#else\n\t\t\tfprintf(stderr, \"WARNING - GPAC not compiled with Memory Tracker - ignoring \\\"%s\\\"\\n\", arg);\n#endif\n\t\t} else if (!strcmp(arg, \"-gui\")) {\n\t\t\tgui_mode = 1;\n\t\t} else if (!strcmp(arg, \"-guid\")) {\n\t\t\tgui_mode = 2;\n\t\t} else if (!strcmp(arg, \"-h\") || !strcmp(arg, \"-help\")) {\n\t\t\tPrintUsage();\n\t\t\treturn 0;\n\t\t}\n\t}\n\n#ifdef GPAC_MEMORY_TRACKING\n\tgf_sys_init(mem_track);\n#else\n\tgf_sys_init(GF_MemTrackerNone);\n#endif\n\tgf_sys_set_args(argc, (const char **) argv);\n\n\tcfg_file = gf_cfg_init(the_cfg, NULL);\n\tif (!cfg_file) {\n\t\tfprintf(stderr, \"Error: Configuration File not found\\n\");\n\t\treturn 1;\n\t}\n\t/*if logs are specified, use them*/\n\tif (gf_log_set_tools_levels( gf_cfg_get_key(cfg_file, \"General\", \"Logs\") ) != GF_OK) {\n\t\treturn 1;\n\t}\n\n\tif( gf_cfg_get_key(cfg_file, \"General\", \"Logs\") != NULL ) {\n\t\tlogs_set = GF_TRUE;\n\t}\n\n\tif (!gui_mode) {\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"ForceGUI\");\n\t\tif (str && !strcmp(str, \"yes\")) gui_mode = 1;\n\t}\n\n\tfor (i=1; i<(u32) argc; i++) {\n\t\tchar *arg = argv[i];\n\n\t\tif (!strcmp(arg, \"-rti\")) {\n\t\t\trti_file = argv[i+1];\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-rtix\")) {\n\t\t\trti_file = argv[i+1];\n\t\t\ti++;\n\t\t\tuse_rtix = GF_TRUE;\n\t\t} else if (!stricmp(arg, \"-size\")) {\n\t\t\t/*usage of %ud breaks sscanf on MSVC*/\n\t\t\tif (sscanf(argv[i+1], \"%dx%d\", &forced_width, &forced_height) != 2) {\n\t\t\t\tforced_width = forced_height = 0;\n\t\t\t}\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-quiet\")) {\n\t\t\tbe_quiet = 1;\n\t\t} else if (!strcmp(arg, \"-strict-error\")) {\n\t\t\tgf_log_set_strict_error(1);\n\t\t} else if (!strcmp(arg, \"-log-file\") || !strcmp(arg, \"-lf\")) {\n\t\t\tlogfile = gf_fopen(argv[i+1], \"wt\");\n\t\t\tgf_log_set_callback(logfile, on_gpac_log);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-logs\") ) {\n\t\t\tif (gf_log_set_tools_levels(argv[i+1]) != GF_OK) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tlogs_set = GF_TRUE;\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-log-clock\") || !strcmp(arg, \"-lc\")) {\n\t\t\tlog_time_start = 1;\n\t\t} else if (!strcmp(arg, \"-log-utc\") || !strcmp(arg, \"-lu\")) {\n\t\t\tlog_utc_time = 1;\n\t\t}\n#if defined(__DARWIN__) || defined(__APPLE__)\n\t\telse if (!strcmp(arg, \"-thread\")) threading_flags = 0;\n#else\n\t\telse if (!strcmp(arg, \"-no-thread\")) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD;\n#endif\n\t\telse if (!strcmp(arg, \"-no-cthread\") || !strcmp(arg, \"-no-compositor-thread\")) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD;\n\t\telse if (!strcmp(arg, \"-no-audio\")) no_audio = 1;\n\t\telse if (!strcmp(arg, \"-no-regulation\")) no_regulation = 1;\n\t\telse if (!strcmp(arg, \"-fs\")) start_fs = 1;\n\n\t\telse if (!strcmp(arg, \"-opt\")) {\n\t\t\tset_cfg_option(argv[i+1]);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-conf\")) {\n\t\t\tset_cfg_option(argv[i+1]);\n\t\t\tis_cfg_only=GF_TRUE;\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, \"-ifce\")) {\n\t\t\tgf_cfg_set_key(cfg_file, \"Network\", \"DefaultMCastInterface\", argv[i+1]);\n\t\t\ti++;\n\t\t}\n\t\telse if (!stricmp(arg, \"-help\")) {\n\t\t\tPrintUsage();\n\t\t\treturn 1;\n\t\t}\n\t\telse if (!stricmp(arg, \"-noprog\")) {\n\t\t\tno_prog=1;\n\t\t\tgf_set_progress_callback(NULL, progress_quiet);\n\t\t}\n\t\telse if (!stricmp(arg, \"-no-save\") || !stricmp(arg, \"--no-save\") /*old versions used --n-save ...*/) {\n\t\t\tno_cfg_save=1;\n\t\t}\n\t\telse if (!stricmp(arg, \"-ntp-shift\")) {\n\t\t\ts32 shift = atoi(argv[i+1]);\n\t\t\ti++;\n\t\t\tgf_net_set_ntp_shift(shift);\n\t\t}\n\t\telse if (!stricmp(arg, \"-run-for\")) {\n\t\t\tsimulation_time_in_ms = atoi(argv[i+1]) * 1000;\n\t\t\tif (!simulation_time_in_ms)\n\t\t\t\tsimulation_time_in_ms = 1; /*1ms*/\n\t\t\ti++;\n\t\t}\n\n\t\telse if (!strcmp(arg, \"-out\")) {\n\t\t\tout_arg = argv[i+1];\n\t\t\ti++;\n\t\t}\n\t\telse if (!stricmp(arg, \"-fps\")) {\n\t\t\tfps = atof(argv[i+1]);\n\t\t\ti++;\n\t\t} else if (!strcmp(arg, \"-avi\") || !strcmp(arg, \"-sha\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\n\t\t\tif (!strcmp(arg, \"-sha\")) dump_mode |= DUMP_SHA1;\n\t\t\telse dump_mode |= DUMP_AVI;\n\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) {\n\t\t\t\tif (!strcmp(arg, \"-avi\") && (nb_times!=2) ) {\n\t\t\t\t\tfprintf(stderr, \"Only one time arg found for -avi - check usage\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t} else if (!strcmp(arg, \"-rgbds\")) { /*get dump in rgbds pixel format*/\n\t\t\t\tdump_mode |= DUMP_RGB_DEPTH_SHAPE;\n\t\t} else if (!strcmp(arg, \"-rgbd\")) { /*get dump in rgbd pixel format*/\n\t\t\t\tdump_mode |= DUMP_RGB_DEPTH;\n\t\t} else if (!strcmp(arg, \"-depth\")) {\n\t\t\t\tdump_mode |= DUMP_DEPTH_ONLY;\n\t\t} else if (!strcmp(arg, \"-bmp\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_BMP;\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;\n\t\t} else if (!strcmp(arg, \"-png\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_PNG;\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;\n\t\t} else if (!strcmp(arg, \"-raw\")) {\n\t\t\tdump_mode &= 0xFFFF0000;\n\t\t\tdump_mode |= DUMP_RAW;\n\t\t\tif ((url_arg || (i+2<(u32)argc)) && get_time_list(argv[i+1], times, &nb_times)) i++;\n\t\t} else if (!stricmp(arg, \"-scale\")) {\n\t\t\tsscanf(argv[i+1], \"%f\", &scale);\n\t\t\ti++;\n\t\t}\n\t\telse if (!strcmp(arg, \"-c\") || !strcmp(arg, \"-cfg\")) {\n\t\t\t/* already parsed */\n\t\t\ti++;\n\t\t}\n\n\t\t/*arguments only used in non-gui mode*/\n\t\tif (!gui_mode) {\n\t\t\tif (arg[0] != '-') {\n\t\t\t\tif (url_arg) {\n\t\t\t\t\tfprintf(stderr, \"Several input URLs provided (\\\"%s\\\", \\\"%s\\\"). Check your command-line.\\n\", url_arg, arg);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\turl_arg = arg;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-loop\")) loop_at_end = 1;\n\t\t\telse if (!strcmp(arg, \"-bench\")) bench_mode = 1;\n\t\t\telse if (!strcmp(arg, \"-vbench\")) bench_mode = 2;\n\t\t\telse if (!strcmp(arg, \"-sbench\")) bench_mode = 3;\n\t\t\telse if (!strcmp(arg, \"-no-addon\")) enable_add_ons = GF_FALSE;\n\n\t\t\telse if (!strcmp(arg, \"-pause\")) pause_at_first = 1;\n\t\t\telse if (!strcmp(arg, \"-play-from\")) {\n\t\t\t\tplay_from = atof((const char *) argv[i+1]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-speed\")) {\n\t\t\t\tplayback_speed = FLT2FIX( atof((const char *) argv[i+1]) );\n\t\t\t\tif (playback_speed <= 0) playback_speed = FIX_ONE;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-no-wnd\")) user.init_flags |= GF_TERM_WINDOWLESS;\n\t\t\telse if (!strcmp(arg, \"-no-back\")) user.init_flags |= GF_TERM_WINDOW_TRANSPARENT;\n\t\t\telse if (!strcmp(arg, \"-align\")) {\n\t\t\t\tif (argv[i+1][0]=='m') align_mode = 1;\n\t\t\t\telse if (argv[i+1][0]=='b') align_mode = 2;\n\t\t\t\talign_mode <<= 8;\n\t\t\t\tif (argv[i+1][1]=='m') align_mode |= 1;\n\t\t\t\telse if (argv[i+1][1]=='r') align_mode |= 2;\n\t\t\t\ti++;\n\t\t\t} else if (!strcmp(arg, \"-fill\")) {\n\t\t\t\tfill_ar = GF_TRUE;\n\t\t\t} else if (!strcmp(arg, \"-show\")) {\n\t\t\t\tvisible = 1;\n\t\t\t} else if (!strcmp(arg, \"-uncache\")) {\n\t\t\t\tdo_uncache = GF_TRUE;\n\t\t\t}\n\t\t\telse if (!strcmp(arg, \"-exit\")) auto_exit = GF_TRUE;\n\t\t\telse if (!stricmp(arg, \"-views\")) {\n\t\t\t\tviews = argv[i+1];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, \"-mosaic\")) {\n\t\t\t\tmosaic = argv[i+1];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, \"-com\")) {\n\t\t\t\thas_command = GF_TRUE;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!stricmp(arg, \"-service\")) {\n\t\t\t\tinitial_service_id = atoi(argv[i+1]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\tif (is_cfg_only) {\n\t\tgf_cfg_del(cfg_file);\n\t\tfprintf(stderr, \"GPAC Config updated\\n\");\n\t\treturn 0;\n\t}\n\tif (do_uncache) {\n\t\tconst char *cache_dir = gf_cfg_get_key(cfg_file, \"General\", \"CacheDirectory\");\n\t\tdo_flatten_cache(cache_dir);\n\t\tfprintf(stderr, \"GPAC Cache dir %s flattened\\n\", cache_dir);\n\t\tgf_cfg_del(cfg_file);\n\t\treturn 0;\n\t}\n\n\tif (dump_mode && !url_arg ) {\n\t\tFILE *test;\n\t\turl_arg = (char *)gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\");\n\t\ttest = url_arg ? gf_fopen(url_arg, \"rt\") : NULL;\n\t\tif (!test) url_arg = NULL;\n\t\telse gf_fclose(test);\n\t\t\n\t\tif (!url_arg) {\n\t\t\tfprintf(stderr, \"Missing argument for dump\\n\");\n\t\t\tPrintUsage();\n\t\t\tif (logfile) gf_fclose(logfile);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (!gui_mode && !url_arg && (gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\") != NULL)) {\n\t\tgui_mode=1;\n\t}\n\n#ifdef WIN32\n\tif (gui_mode==1) {\n\t\tconst char *opt;\n\t\tTCHAR buffer[1024];\n\t\tDWORD res = GetCurrentDirectory(1024, buffer);\n\t\tbuffer[res] = 0;\n\t\topt = gf_cfg_get_key(cfg_file, \"General\", \"ModulesDirectory\");\n\t\tif (strstr(opt, buffer)) {\n\t\t\tgui_mode=1;\n\t\t} else {\n\t\t\tgui_mode=2;\n\t\t}\n\t}\n#endif\n\n\tif (gui_mode==1) {\n\t\thide_shell(1);\n\t}\n\tif (gui_mode) {\n\t\tno_prog=1;\n\t\tgf_set_progress_callback(NULL, progress_quiet);\n\t}\n\n\tif (!url_arg && simulation_time_in_ms)\n\t\tsimulation_time_in_ms += gf_sys_clock();\n\n#if defined(__DARWIN__) || defined(__APPLE__)\n\tcarbon_init();\n#endif\n\n\n\tif (dump_mode) rti_file = NULL;\n\n\tif (!logs_set) {\n\t\tgf_log_set_tool_level(GF_LOG_ALL, GF_LOG_WARNING);\n\t}\n\t//only override default log callback when needed\n\tif (rti_file || logfile || log_utc_time || log_time_start)\n\t\tgf_log_set_callback(NULL, on_gpac_log);\n\n\tif (rti_file) init_rti_logs(rti_file, url_arg, use_rtix);\n\n\t{\n\t\tGF_SystemRTInfo rti;\n\t\tif (gf_sys_get_rti(0, &rti, 0))\n\t\t\tfprintf(stderr, \"System info: %d MB RAM - %d cores\\n\", (u32) (rti.physical_memory/1024/1024), rti.nb_cores);\n\t}\n\n\n\t/*setup dumping options*/\n\tif (dump_mode) {\n\t\tuser.init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION;\n\t\tif (!visible)\n\t\t\tuser.init_flags |= GF_TERM_INIT_HIDE;\n\n\t\tgf_cfg_set_key(cfg_file, \"Audio\", \"DriverName\", \"Raw Audio Output\");\n\t\tno_cfg_save=GF_TRUE;\n\t} else {\n\t\tinit_w = forced_width;\n\t\tinit_h = forced_height;\n\t}\n\n\tuser.modules = gf_modules_new(NULL, cfg_file);\n\tif (user.modules) i = gf_modules_get_count(user.modules);\n\tif (!i || !user.modules) {\n\t\tfprintf(stderr, \"Error: no modules found - exiting\\n\");\n\t\tif (user.modules) gf_modules_del(user.modules);\n\t\tgf_cfg_del(cfg_file);\n\t\tgf_sys_close();\n\t\tif (logfile) gf_fclose(logfile);\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"Modules Found : %d \\n\", i);\n\n\tstr = gf_cfg_get_key(cfg_file, \"General\", \"GPACVersion\");\n\tif (!str || strcmp(str, GPAC_FULL_VERSION)) {\n\t\tgf_cfg_del_section(cfg_file, \"PluginsCache\");\n\t\tgf_cfg_set_key(cfg_file, \"General\", \"GPACVersion\", GPAC_FULL_VERSION);\n\t}\n\n\tuser.config = cfg_file;\n\tuser.EventProc = GPAC_EventProc;\n\t/*dummy in this case (global vars) but MUST be non-NULL*/\n\tuser.opaque = user.modules;\n\tif (threading_flags) user.init_flags |= threading_flags;\n\tif (no_audio) user.init_flags |= GF_TERM_NO_AUDIO;\n\tif (no_regulation) user.init_flags |= GF_TERM_NO_REGULATION;\n\n\tif (threading_flags & (GF_TERM_NO_DECODER_THREAD|GF_TERM_NO_COMPOSITOR_THREAD) ) term_step = GF_TRUE;\n\n\t//in dump mode we don't want to rely on system clock but on the number of samples being consumed\n\tif (dump_mode) user.init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK;\n\n\tif (bench_mode) {\n\t\tgf_cfg_discard_changes(user.config);\n\t\tauto_exit = GF_TRUE;\n\t\tgf_cfg_set_key(user.config, \"Audio\", \"DriverName\", \"Raw Audio Output\");\n\t\tif (bench_mode!=2) {\n\t\t\tgf_cfg_set_key(user.config, \"Video\", \"DriverName\", \"Raw Video Output\");\n\t\t\tgf_cfg_set_key(user.config, \"RAWVideo\", \"RawOutput\", \"null\");\n\t\t\tgf_cfg_set_key(user.config, \"Compositor\", \"OpenGLMode\", \"disable\");\n\t\t} else {\n\t\t\tgf_cfg_set_key(user.config, \"Video\", \"DisableVSync\", \"yes\");\n\t\t}\n\t}\n\n\t{\n\t\tchar dim[50];\n\t\tsprintf(dim, \"%d\", forced_width);\n\t\tgf_cfg_set_key(user.config, \"Compositor\", \"DefaultWidth\", forced_width ? dim : NULL);\n\t\tsprintf(dim, \"%d\", forced_height);\n\t\tgf_cfg_set_key(user.config, \"Compositor\", \"DefaultHeight\", forced_height ? dim : NULL);\n\t}\n\n\tfprintf(stderr, \"Loading GPAC Terminal\\n\");\n\ti = gf_sys_clock();\n\tterm = gf_term_new(&user);\n\tif (!term) {\n\t\tfprintf(stderr, \"\\nInit error - check you have at least one video out and one rasterizer...\\nFound modules:\\n\");\n\t\tlist_modules(user.modules);\n\t\tgf_modules_del(user.modules);\n\t\tgf_cfg_discard_changes(cfg_file);\n\t\tgf_cfg_del(cfg_file);\n\t\tgf_sys_close();\n\t\tif (logfile) gf_fclose(logfile);\n\t\treturn 1;\n\t}\n\tfprintf(stderr, \"Terminal Loaded in %d ms\\n\", gf_sys_clock()-i);\n\n\tif (bench_mode) {\n\t\tdisplay_rti = 2;\n\t\tgf_term_set_option(term, GF_OPT_VIDEO_BENCH, (bench_mode==3) ? 2 : 1);\n\t\tif (bench_mode==1) bench_mode=2;\n\t}\n\n\tif (dump_mode) {\n//\t\tgf_term_set_option(term, GF_OPT_VISIBLE, 0);\n\t\tif (fill_ar) gf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t} else {\n\t\t/*check video output*/\n\t\tstr = gf_cfg_get_key(cfg_file, \"Video\", \"DriverName\");\n\t\tif (!bench_mode && !strcmp(str, \"Raw Video Output\")) fprintf(stderr, \"WARNING: using raw output video (memory only) - no display used\\n\");\n\t\t/*check audio output*/\n\t\tstr = gf_cfg_get_key(cfg_file, \"Audio\", \"DriverName\");\n\t\tif (!str || !strcmp(str, \"No Audio Output Available\")) fprintf(stderr, \"WARNING: no audio output available - make sure no other program is locking the sound card\\n\");\n\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"NoMIMETypeFetch\");\n\t\tno_mime_check = (str && !stricmp(str, \"yes\")) ? 1 : 0;\n\t}\n\n\tstr = gf_cfg_get_key(cfg_file, \"HTTPProxy\", \"Enabled\");\n\tif (str && !strcmp(str, \"yes\")) {\n\t\tstr = gf_cfg_get_key(cfg_file, \"HTTPProxy\", \"Name\");\n\t\tif (str) fprintf(stderr, \"HTTP Proxy %s enabled\\n\", str);\n\t}\n\n\tif (rti_file) {\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"RTIRefreshPeriod\");\n\t\tif (str) {\n\t\t\trti_update_time_ms = atoi(str);\n\t\t} else {\n\t\t\tgf_cfg_set_key(cfg_file, \"General\", \"RTIRefreshPeriod\", \"200\");\n\t\t}\n\t\tUpdateRTInfo(\"At GPAC load time\\n\");\n\t}\n\n\tRun = 1;\n\n\tif (dump_mode) {\n\t\tif (!nb_times) {\n\t\t\ttimes[0] = 0;\n\t\t\tnb_times++;\n\t\t}\n\t\tret_val = dump_file(url_arg, out_arg, dump_mode, fps, forced_width, forced_height, scale, times, nb_times);\n\t\tRun = 0;\n\t}\n\telse if (views) {\n\t}\n\t/*connect if requested*/\n\telse if (!gui_mode && url_arg) {\n\t\tchar *ext;\n\n\t\tif (strlen(url_arg) >= sizeof(the_url)) {\n\t\t\tfprintf(stderr, \"Input url %s is too long, truncating to %d chars.\\n\", url_arg, (int)(sizeof(the_url) - 1));\n\t\t\tstrncpy(the_url, url_arg, sizeof(the_url)-1);\n\t\t\tthe_url[sizeof(the_url) - 1] = 0;\n\t\t}\n\t\telse {\n\t\t\tstrcpy(the_url, url_arg);\n\t\t}\n\t\text = strrchr(the_url, '.');\n\t\tif (ext && (!stricmp(ext, \".m3u\") || !stricmp(ext, \".pls\"))) {\n\t\t\tGF_Err e = GF_OK;\n\t\t\tfprintf(stderr, \"Opening Playlist %s\\n\", the_url);\n\n\t\t\tstrcpy(pl_path, the_url);\n\t\t\t/*this is not clean, we need to have a plugin handle playlist for ourselves*/\n\t\t\tif (!strncmp(\"http:\", the_url, 5)) {\n\t\t\t\tGF_DownloadSession *sess = gf_dm_sess_new(term->downloader, the_url, GF_NETIO_SESSION_NOT_THREADED, NULL, NULL, &e);\n\t\t\t\tif (sess) {\n\t\t\t\t\te = gf_dm_sess_process(sess);\n\t\t\t\t\tif (!e) {\n\t\t\t\t\t\tstrncpy(the_url, gf_dm_sess_get_cache_name(sess), sizeof(the_url) - 1);\n\t\t\t\t\t\tthe_url[sizeof(the_url) - 1] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tgf_dm_sess_del(sess);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplaylist = e ? NULL : gf_fopen(the_url, \"rt\");\n\t\t\treadonly_playlist = 1;\n\t\t\tif (playlist) {\n\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tif (e)\n\t\t\t\t\tfprintf(stderr, \"Failed to open playlist %s: %s\\n\", the_url, gf_error_to_string(e) );\n\t\t\t\tfprintf(stderr, \"Hit 'h' for help\\n\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\tif (pause_at_first) fprintf(stderr, \"[Status: Paused]\\n\");\n\t\t\tgf_term_connect_from_time(term, the_url, (u64) (play_from*1000), pause_at_first);\n\t\t}\n\t} else {\n\t\tfprintf(stderr, \"Hit 'h' for help\\n\\n\");\n\t\tstr = gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\");\n\t\tif (str) {\n\t\t\tstrncpy(the_url, \"MP4Client \"GPAC_FULL_VERSION , sizeof(the_url)-1);\n\t\t\tthe_url[sizeof(the_url) - 1] = 0;\n\t\t\tgf_term_connect(term, str);\n\t\t\tstartup_file = 1;\n\t\t\tis_connected = 1;\n\t\t}\n\t}\n\tif (gui_mode==2) gui_mode=0;\n\n\tif (start_fs) gf_term_set_option(term, GF_OPT_FULLSCREEN, 1);\n\n\tif (views) {\n\t\tchar szTemp[4046];\n\t\tsprintf(szTemp, \"views://%s\", views);\n\t\tgf_term_connect(term, szTemp);\n\t}\n\tif (mosaic) {\n\t\tchar szTemp[4046];\n\t\tsprintf(szTemp, \"mosaic://%s\", mosaic);\n\t\tgf_term_connect(term, szTemp);\n\t}\n\tif (bench_mode) {\n\t\trti_update_time_ms = 500;\n\t\tbench_mode_start = gf_sys_clock();\n\t}\n\n\n\twhile (Run) {\n\n\t\t/*we don't want getchar to block*/\n\t\tif ((gui_mode==1) || !gf_prompt_has_input()) {\n\t\t\tif (reload) {\n\t\t\t\treload = 0;\n\t\t\t\tgf_term_disconnect(term);\n\t\t\t\tgf_term_connect(term, startup_file ? gf_cfg_get_key(cfg_file, \"General\", \"StartupFile\") : the_url);\n\t\t\t}\n\t\t\tif (restart && gf_term_get_option(term, GF_OPT_IS_OVER)) {\n\t\t\t\trestart = 0;\n\t\t\t\tgf_term_play_from_time(term, 0, 0);\n\t\t\t}\n\t\t\tif (request_next_playlist_item) {\n\t\t\t\tc = '\\n';\n\t\t\t\trequest_next_playlist_item = 0;\n\t\t\t\tgoto force_input;\n\t\t\t}\n\n\t\t\tif (has_command && is_connected) {\n\t\t\t\thas_command = GF_FALSE;\n\t\t\t\tfor (i=0; i<(u32)argc; i++) {\n\t\t\t\t\tif (!strcmp(argv[i], \"-com\")) {\n\t\t\t\t\t\tgf_term_scene_update(term, NULL, argv[i+1]);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (initial_service_id && is_connected) {\n\t\t\t\tGF_ObjectManager *root_od = gf_term_get_root_object(term);\n\t\t\t\tif (root_od) {\n\t\t\t\t\tgf_term_select_service(term, root_od, initial_service_id);\n\t\t\t\t\tinitial_service_id = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!use_rtix || display_rti) UpdateRTInfo(NULL);\n\t\t\tif (term_step) {\n\t\t\t\tgf_term_process_step(term);\n\t\t\t} else {\n\t\t\t\tgf_sleep(rti_update_time_ms);\n\t\t\t}\n\t\t\tif (auto_exit && eos_seen && gf_term_get_option(term, GF_OPT_IS_OVER)) {\n\t\t\t\tRun = GF_FALSE;\n\t\t\t}\n\n\t\t\t/*sim time*/\n\t\t\tif (simulation_time_in_ms\n\t\t\t        && ( (gf_term_get_elapsed_time_in_ms(term)>simulation_time_in_ms) || (!url_arg && gf_sys_clock()>simulation_time_in_ms))\n\t\t\t   ) {\n\t\t\t\tRun = GF_FALSE;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tc = gf_prompt_get_char();\n\nforce_input:\n\t\tswitch (c) {\n\t\tcase 'q':\n\t\t{\n\t\t\tGF_Event evt;\n\t\t\tmemset(&evt, 0, sizeof(GF_Event));\n\t\t\tevt.type = GF_EVENT_QUIT;\n\t\t\tgf_term_send_event(term, &evt);\n\t\t}\n//\t\t\tRun = 0;\n\t\tbreak;\n\t\tcase 'X':\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tstartup_file = 0;\n\t\t\tgf_term_disconnect(term);\n\t\t\tfprintf(stderr, \"Enter the absolute URL\\n\");\n\t\t\tif (1 > scanf(\"%s\", the_url)) {\n\t\t\t\tfprintf(stderr, \"Cannot read absolute URL, aborting\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (rti_file) init_rti_logs(rti_file, the_url, use_rtix);\n\t\t\tgf_term_connect(term, the_url);\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tgf_term_disconnect(term);\n\t\t\tfprintf(stderr, \"Enter the absolute URL to the playlist\\n\");\n\t\t\tif (1 > scanf(\"%s\", the_url)) {\n\t\t\t\tfprintf(stderr, \"Cannot read the absolute URL, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tplaylist = gf_fopen(the_url, \"rt\");\n\t\t\tif (playlist) {\n\t\t\t\tif (1 >\tfscanf(playlist, \"%s\", the_url)) {\n\t\t\t\t\tfprintf(stderr, \"Cannot read any URL from playlist, aborting.\\n\");\n\t\t\t\t\tgf_fclose( playlist);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\t\tgf_term_connect(term, the_url);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\n':\n\t\tcase 'N':\n\t\t\tif (playlist) {\n\t\t\t\tint res;\n\t\t\t\tgf_term_disconnect(term);\n\n\t\t\t\tres = fscanf(playlist, \"%s\", the_url);\n\t\t\t\tif ((res == EOF) && loop_at_end) {\n\t\t\t\t\tfseek(playlist, 0, SEEK_SET);\n\t\t\t\t\tres = fscanf(playlist, \"%s\", the_url);\n\t\t\t\t}\n\t\t\t\tif (res == EOF) {\n\t\t\t\t\tfprintf(stderr, \"No more items - exiting\\n\");\n\t\t\t\t\tRun = 0;\n\t\t\t\t} else if (the_url[0] == '#') {\n\t\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\t\t\tgf_term_connect_with_path(term, the_url, pl_path);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tif (playlist) {\n\t\t\t\tu32 count;\n\t\t\t\tgf_term_disconnect(term);\n\t\t\t\tif (1 > scanf(\"%u\", &count)) {\n\t\t\t\t\tfprintf(stderr, \"Cannot read number, aborting.\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twhile (count) {\n\t\t\t\t\tif (fscanf(playlist, \"%s\", the_url)) {\n\t\t\t\t\t\tfprintf(stderr, \"Failed to read line, aborting\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcount--;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"Opening URL %s\\n\", the_url);\n\t\t\t\tgf_term_connect(term, the_url);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (is_connected)\n\t\t\t\treload = 1;\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tif (is_connected) gf_term_disconnect(term);\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\t\tif (is_connected) {\n\t\t\t\tBool is_pause = gf_term_get_option(term, GF_OPT_PLAY_STATE);\n\t\t\t\tfprintf(stderr, \"[Status: %s]\\n\", is_pause ? \"Playing\" : \"Paused\");\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (is_connected) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);\n\t\t\t\tfprintf(stderr, \"Step time: \");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'z':\n\t\tcase 'T':\n\t\t\tif (!CanSeek || (Duration<=2000)) {\n\t\t\t\tfprintf(stderr, \"scene not seekable\\n\");\n\t\t\t} else {\n\t\t\t\tDouble res;\n\t\t\t\ts32 seekTo;\n\t\t\t\tfprintf(stderr, \"Duration: \");\n\t\t\t\tPrintTime(Duration);\n\t\t\t\tres = gf_term_get_time_in_ms(term);\n\t\t\t\tif (c=='z') {\n\t\t\t\t\tres *= 100;\n\t\t\t\t\tres /= (s64)Duration;\n\t\t\t\t\tfprintf(stderr, \" (current %.2f %%)\\nEnter Seek percentage:\\n\", res);\n\t\t\t\t\tif (scanf(\"%d\", &seekTo) == 1) {\n\t\t\t\t\t\tif (seekTo > 100) seekTo = 100;\n\t\t\t\t\t\tres = (Double)(s64)Duration;\n\t\t\t\t\t\tres /= 100;\n\t\t\t\t\t\tres *= seekTo;\n\t\t\t\t\t\tgf_term_play_from_time(term, (u64) (s64) res, 0);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tu32 r, h, m, s;\n\t\t\t\t\tfprintf(stderr, \" - Current Time: \");\n\t\t\t\t\tPrintTime((u64) res);\n\t\t\t\t\tfprintf(stderr, \"\\nEnter seek time (Format: s, m:s or h:m:s):\\n\");\n\t\t\t\t\th = m = s = 0;\n\t\t\t\t\tr =scanf(\"%d:%d:%d\", &h, &m, &s);\n\t\t\t\t\tif (r==2) {\n\t\t\t\t\t\ts = m;\n\t\t\t\t\t\tm = h;\n\t\t\t\t\t\th = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (r==1) {\n\t\t\t\t\t\ts = h;\n\t\t\t\t\t\tm = h = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (r && (r<=3)) {\n\t\t\t\t\t\tu64 time = h*3600 + m*60 + s;\n\t\t\t\t\t\tgf_term_play_from_time(term, time*1000, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t{\n\t\t\tif (is_connected) {\n\t\t\t\tfprintf(stderr, \"Current Time: \");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, \" - Duration: \");\n\t\t\t\tPrintTime(Duration);\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase 'w':\n\t\t\tif (is_connected) PrintWorldInfo(term);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tif (is_connected) PrintODList(term, NULL, 0, 0, \"Root\");\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tif (is_connected) {\n\t\t\t\tu32 ID;\n\t\t\t\tfprintf(stderr, \"Enter OD ID (0 for main OD): \");\n\t\t\t\tfflush(stderr);\n\t\t\t\tif (scanf(\"%ud\", &ID) == 1) {\n\t\t\t\t\tViewOD(term, ID, (u32)-1, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tchar str_url[GF_MAX_PATH];\n\t\t\t\t\tif (scanf(\"%s\", str_url) == 1)\n\t\t\t\t\t\tViewOD(term, 0, (u32)-1, str_url);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'j':\n\t\t\tif (is_connected) {\n\t\t\t\tu32 num;\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, \"Enter OD number (0 for main OD): \");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 > scanf(\"%ud\", &num));\n\t\t\t\tViewOD(term, (u32)-1, num, NULL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tif (is_connected) ViewODs(term, 1);\n\t\t\tbreak;\n\n\t\tcase 'm':\n\t\t\tif (is_connected) ViewODs(term, 0);\n\t\t\tbreak;\n\n\t\tcase 'l':\n\t\t\tlist_modules(user.modules);\n\t\t\tbreak;\n\n\t\tcase 'n':\n\t\t\tif (is_connected) set_navigation();\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tif (is_connected) gf_term_set_option(term, GF_OPT_NAVIGATION_TYPE, 0);\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\tif (is_connected) {\n\t\t\t\tGF_ObjectManager *odm = NULL;\n\t\t\t\tchar radname[GF_MAX_PATH], *sExt;\n\t\t\t\tGF_Err e;\n\t\t\t\tu32 i, count, odid;\n\t\t\t\tBool xml_dump, std_out;\n\t\t\t\tradname[0] = 0;\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, \"Enter Inline OD ID if any or 0 : \");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 >  scanf(\"%ud\", &odid));\n\t\t\t\tif (odid) {\n\t\t\t\t\tGF_ObjectManager *root_odm = gf_term_get_root_object(term);\n\t\t\t\t\tif (!root_odm) break;\n\t\t\t\t\tcount = gf_term_get_object_count(term, root_odm);\n\t\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\t\tGF_MediaInfo info;\n\t\t\t\t\t\todm = gf_term_get_object(term, root_odm, i);\n\t\t\t\t\t\tif (gf_term_get_object_info(term, odm, &info) == GF_OK) {\n\t\t\t\t\t\t\tif (info.od->objectDescriptorID==odid) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\todm = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\tfprintf(stderr, \"Enter file radical name (+\\'.x\\' for XML dumping) - \\\"std\\\" for stderr: \");\n\t\t\t\t\tfflush(stderr);\n\t\t\t\t} while( 1 > scanf(\"%s\", radname));\n\t\t\t\tsExt = strrchr(radname, '.');\n\t\t\t\txml_dump = 0;\n\t\t\t\tif (sExt) {\n\t\t\t\t\tif (!stricmp(sExt, \".x\")) xml_dump = 1;\n\t\t\t\t\tsExt[0] = 0;\n\t\t\t\t}\n\t\t\t\tstd_out = strnicmp(radname, \"std\", 3) ? 0 : 1;\n\t\t\t\te = gf_term_dump_scene(term, std_out ? NULL : radname, NULL, xml_dump, 0, odm);\n\t\t\t\tfprintf(stderr, \"Dump done (%s)\\n\", gf_error_to_string(e));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'c':\n\t\t\tPrintGPACConfig();\n\t\t\tbreak;\n\t\tcase '3':\n\t\t{\n\t\t\tBool use_3d = !gf_term_get_option(term, GF_OPT_USE_OPENGL);\n\t\t\tif (gf_term_set_option(term, GF_OPT_USE_OPENGL, use_3d)==GF_OK) {\n\t\t\t\tfprintf(stderr, \"Using %s for 2D drawing\\n\", use_3d ? \"OpenGL\" : \"2D rasterizer\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase 'k':\n\t\t{\n\t\t\tBool opt = gf_term_get_option(term, GF_OPT_STRESS_MODE);\n\t\t\topt = !opt;\n\t\t\tfprintf(stderr, \"Turning stress mode %s\\n\", opt ? \"on\" : \"off\");\n\t\t\tgf_term_set_option(term, GF_OPT_STRESS_MODE, opt);\n\t\t}\n\t\tbreak;\n\t\tcase '4':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);\n\t\t\tbreak;\n\t\tcase '5':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t\t\tbreak;\n\t\tcase '7':\n\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);\n\t\t\tbreak;\n\n\t\tcase 'C':\n\t\t\tswitch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {\n\t\t\tcase GF_MEDIA_CACHE_DISABLED:\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_ENABLED);\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_ENABLED:\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, GF_MEDIA_CACHE_DISABLED);\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_RUNNING:\n\t\t\t\tfprintf(stderr, \"Streaming Cache is running - please stop it first\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)) {\n\t\t\tcase GF_MEDIA_CACHE_ENABLED:\n\t\t\t\tfprintf(stderr, \"Streaming Cache Enabled\\n\");\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_DISABLED:\n\t\t\t\tfprintf(stderr, \"Streaming Cache Disabled\\n\");\n\t\t\t\tbreak;\n\t\t\tcase GF_MEDIA_CACHE_RUNNING:\n\t\t\t\tfprintf(stderr, \"Streaming Cache Running\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'S':\n\t\tcase 'A':\n\t\t\tif (gf_term_get_option(term, GF_OPT_MEDIA_CACHE)==GF_MEDIA_CACHE_RUNNING) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_MEDIA_CACHE, (c=='S') ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD);\n\t\t\t\tfprintf(stderr, \"Streaming Cache stopped\\n\");\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Streaming Cache not running\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tdisplay_rti = !display_rti;\n\t\t\tResetCaption();\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tif (display_rti) display_rti = 0;\n\t\t\telse display_rti = 2;\n\t\t\tResetCaption();\n\t\t\tbreak;\n\n\t\tcase 'u':\n\t\t{\n\t\t\tGF_Err e;\n\t\t\tchar szCom[8192];\n\t\t\tfprintf(stderr, \"Enter command to send:\\n\");\n\t\t\tfflush(stdin);\n\t\t\tszCom[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", szCom)) {\n\t\t\t\tfprintf(stderr, \"Cannot read command to send, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\te = gf_term_scene_update(term, NULL, szCom);\n\t\t\tif (e) fprintf(stderr, \"Processing command failed: %s\\n\", gf_error_to_string(e));\n\t\t}\n\t\tbreak;\n\t\tcase 'e':\n\t\t{\n\t\t\tGF_Err e;\n\t\t\tchar jsCode[8192];\n\t\t\tfprintf(stderr, \"Enter JavaScript code to evaluate:\\n\");\n\t\t\tfflush(stdin);\n\t\t\tjsCode[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", jsCode)) {\n\t\t\t\tfprintf(stderr, \"Cannot read code to evaluate, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\te = gf_term_scene_update(term, \"application/ecmascript\", jsCode);\n\t\t\tif (e) fprintf(stderr, \"Processing JS code failed: %s\\n\", gf_error_to_string(e));\n\t\t}\n\t\tbreak;\n\n\t\tcase 'L':\n\t\t{\n\t\t\tchar szLog[1024], *cur_logs;\n\t\t\tcur_logs = gf_log_get_tools_levels();\n\t\t\tfprintf(stderr, \"Enter new log level (current tools %s):\\n\", cur_logs);\n\t\t\tgf_free(cur_logs);\n\t\t\tif (scanf(\"%s\", szLog) < 1) {\n\t\t\t\tfprintf(stderr, \"Cannot read new log level, aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgf_log_modify_tools_levels(szLog);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'g':\n\t\t{\n\t\t\tGF_SystemRTInfo rti;\n\t\t\tgf_sys_get_rti(rti_update_time_ms, &rti, 0);\n\t\t\tfprintf(stderr, \"GPAC allocated memory \"LLD\"\\n\", rti.gpac_memory);\n\t\t}\n\t\tbreak;\n\t\tcase 'M':\n\t\t{\n\t\t\tu32 size;\n\t\t\tdo {\n\t\t\t\tfprintf(stderr, \"Enter new video cache memory in kBytes (current %ud):\\n\", gf_term_get_option(term, GF_OPT_VIDEO_CACHE_SIZE));\n\t\t\t} while (1 > scanf(\"%ud\", &size));\n\t\t\tgf_term_set_option(term, GF_OPT_VIDEO_CACHE_SIZE, size);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'H':\n\t\t{\n\t\t\tu32 http_bitrate = gf_term_get_option(term, GF_OPT_HTTP_MAX_RATE);\n\t\t\tdo {\n\t\t\t\tfprintf(stderr, \"Enter new http bitrate in bps (0 for none) - current limit: %d\\n\", http_bitrate);\n\t\t\t} while (1 > scanf(\"%ud\", &http_bitrate));\n\n\t\t\tgf_term_set_option(term, GF_OPT_HTTP_MAX_RATE, http_bitrate);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'E':\n\t\t\tgf_term_set_option(term, GF_OPT_RELOAD_CONFIG, 1);\n\t\t\tbreak;\n\n\t\tcase 'B':\n\t\t\tswitch_bench(!bench_mode);\n\t\t\tbreak;\n\n\t\tcase 'Y':\n\t\t{\n\t\t\tchar szOpt[8192];\n\t\t\tfprintf(stderr, \"Enter option to set (Section:Name=Value):\\n\");\n\t\t\tfflush(stdin);\n\t\t\tszOpt[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", szOpt)) {\n\t\t\t\tfprintf(stderr, \"Cannot read option\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_cfg_option(szOpt);\n\t\t}\n\t\tbreak;\n\n\t\t/*extract to PNG*/\n\t\tcase 'Z':\n\t\t{\n\t\t\tchar szFileName[100];\n\t\t\tu32 nb_pass, nb_views, offscreen_view = 0;\n\t\t\tGF_VideoSurface fb;\n\t\t\tGF_Err e;\n\t\t\tnb_pass = 1;\n\t\t\tnb_views = gf_term_get_option(term, GF_OPT_NUM_STEREO_VIEWS);\n\t\t\tif (nb_views>1) {\n\t\t\t\tfprintf(stderr, \"Auto-stereo mode detected - type number of view to dump (0 is main output, 1 to %d offscreen view, %d for all offscreen, %d for all offscreen and main)\\n\", nb_views, nb_views+1, nb_views+2);\n\t\t\t\tif (scanf(\"%d\", &offscreen_view) != 1) {\n\t\t\t\t\toffscreen_view = 0;\n\t\t\t\t}\n\t\t\t\tif (offscreen_view==nb_views+1) {\n\t\t\t\t\toffscreen_view = 1;\n\t\t\t\t\tnb_pass = nb_views;\n\t\t\t\t}\n\t\t\t\telse if (offscreen_view==nb_views+2) {\n\t\t\t\t\toffscreen_view = 0;\n\t\t\t\t\tnb_pass = nb_views+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (nb_pass) {\n\t\t\t\tnb_pass--;\n\t\t\t\tif (offscreen_view) {\n\t\t\t\t\tsprintf(szFileName, \"view%d_dump.png\", offscreen_view);\n\t\t\t\t\te = gf_term_get_offscreen_buffer(term, &fb, offscreen_view-1, 0);\n\t\t\t\t} else {\n\t\t\t\t\tsprintf(szFileName, \"gpac_video_dump_\"LLU\".png\", gf_net_get_utc() );\n\t\t\t\t\te = gf_term_get_screen_buffer(term, &fb);\n\t\t\t\t}\n\t\t\t\toffscreen_view++;\n\t\t\t\tif (e) {\n\t\t\t\t\tfprintf(stderr, \"Error dumping screen buffer %s\\n\", gf_error_to_string(e) );\n\t\t\t\t\tnb_pass = 0;\n\t\t\t\t} else {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tu32 dst_size = fb.width*fb.height*4;\n\t\t\t\t\tchar *dst = (char*)gf_malloc(sizeof(char)*dst_size);\n\n\t\t\t\t\te = gf_img_png_enc(fb.video_buffer, fb.width, fb.height, fb.pitch_y, fb.pixel_format, dst, &dst_size);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tfprintf(stderr, \"Error encoding PNG %s\\n\", gf_error_to_string(e) );\n\t\t\t\t\t\tnb_pass = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tFILE *png = gf_fopen(szFileName, \"wb\");\n\t\t\t\t\t\tif (!png) {\n\t\t\t\t\t\t\tfprintf(stderr, \"Error writing file %s\\n\", szFileName);\n\t\t\t\t\t\t\tnb_pass = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_fwrite(dst, dst_size, 1, png);\n\t\t\t\t\t\t\tgf_fclose(png);\n\t\t\t\t\t\t\tfprintf(stderr, \"Dump to %s\\n\", szFileName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (dst) gf_free(dst);\n\t\t\t\t\tgf_term_release_screen_buffer(term, &fb);\n#endif //GPAC_DISABLE_AV_PARSERS\n\t\t\t\t}\n\t\t\t}\n\t\t\tfprintf(stderr, \"Done: %s\\n\", szFileName);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'G':\n\t\t{\n\t\t\tGF_ObjectManager *root_od, *odm;\n\t\t\tu32 index;\n\t\t\tchar szOpt[8192];\n\t\t\tfprintf(stderr, \"Enter 0-based index of object to select or service ID:\\n\");\n\t\t\tfflush(stdin);\n\t\t\tszOpt[0] = 0;\n\t\t\tif (1 > scanf(\"%[^\\t\\n]\", szOpt)) {\n\t\t\t\tfprintf(stderr, \"Cannot read OD ID\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex = atoi(szOpt);\n\t\t\todm = NULL;\n\t\t\troot_od = gf_term_get_root_object(term);\n\t\t\tif (root_od) {\n\t\t\t\tif ( gf_term_find_service(term, root_od, index)) {\n\t\t\t\t\tgf_term_select_service(term, root_od, index);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Cannot find service %d - trying with object index\\n\", index);\n\t\t\t\t\todm = gf_term_get_object(term, root_od, index);\n\t\t\t\t\tif (odm) {\n\t\t\t\t\t\tgf_term_select_object(term, odm);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfprintf(stderr, \"Cannot find object at index %d\\n\", index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase 'h':\n\t\t\tPrintHelp();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (bench_mode) {\n\t\tPrintAVInfo(GF_TRUE);\n\t}\n\n\t/*FIXME: we have an issue in cleaning up after playing in bench mode and run-for 0 (buildbot tests). We for now disable error checks after run-for is done*/\n\tif (simulation_time_in_ms) {\n\t\tgf_log_set_strict_error(0);\n\t}\n\n\n\ti = gf_sys_clock();\n\tgf_term_disconnect(term);\n\tif (rti_file) UpdateRTInfo(\"Disconnected\\n\");\n\n\tfprintf(stderr, \"Deleting terminal... \");\n\tif (playlist) gf_fclose(playlist);\n\n#if defined(__DARWIN__) || defined(__APPLE__)\n\tcarbon_uninit();\n#endif\n\n\tgf_term_del(term);\n\tfprintf(stderr, \"done (in %d ms) - ran for %d ms\\n\", gf_sys_clock() - i, gf_sys_clock());\n\n\tfprintf(stderr, \"GPAC cleanup ...\\n\");\n\tgf_modules_del(user.modules);\n\n\tif (no_cfg_save)\n\t\tgf_cfg_discard_changes(cfg_file);\n\n\tgf_cfg_del(cfg_file);\n\n\tgf_sys_close();\n\n\tif (rti_logs) gf_fclose(rti_logs);\n\tif (logfile) gf_fclose(logfile);\n\n\tif (gui_mode) {\n\t\thide_shell(2);\n\t}\n\n#ifdef GPAC_MEMORY_TRACKING\n\tif (mem_track && (gf_memory_size() || gf_file_handles_count() )) {\n\t        gf_log_set_tool_level(GF_LOG_MEMORY, GF_LOG_INFO);\n\t\tgf_memory_print();\n\t\treturn 2;\n\t}\n#endif\n\n\treturn ret_val;\n}\n\n#if defined(WIN32) && !defined(NO_WMAIN)\nint wmain(int argc, wchar_t** wargv)\n{\n\tint i;\n\tint res;\n\tsize_t len;\n\tsize_t res_len;\n\tchar **argv;\n\targv = (char **)malloc(argc*sizeof(wchar_t *));\n\tfor (i = 0; i < argc; i++) {\n\t\twchar_t *src_str = wargv[i];\n\t\tlen = UTF8_MAX_BYTES_PER_CHAR * gf_utf8_wcslen(wargv[i]);\n\t\targv[i] = (char *)malloc(len + 1);\n\t\tres_len = gf_utf8_wcstombs(argv[i], len, &src_str);\n\t\targv[i][res_len] = 0;\n\t\tif (res_len > len) {\n\t\t\tfprintf(stderr, \"Length allocated for conversion of wide char to UTF-8 not sufficient\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tres = mp4client_main(argc, argv);\n\tfor (i = 0; i < argc; i++) {\n\t\tfree(argv[i]);\n\t}\n\tfree(argv);\n\treturn res;\n}\n#else\nint main(int argc, char** argv)\n{\n\treturn mp4client_main(argc, argv);\n}\n#endif //win32\nstatic GF_ObjectManager *video_odm = NULL;\nstatic GF_ObjectManager *audio_odm = NULL;\nstatic GF_ObjectManager *scene_odm = NULL;\nstatic u32 last_odm_count = 0;\nvoid PrintAVInfo(Bool final)\n{\n\tGF_MediaInfo a_odi, v_odi, s_odi;\n\tDouble avg_dec_time=0;\n\tu32 tot_time=0;\n\tBool print_codecs = final;\n\n\tif (scene_odm) {\n\t\tGF_ObjectManager *root_odm = gf_term_get_root_object(term);\n\t\tu32 count = gf_term_get_object_count(term, root_odm);\n\t\tif (last_odm_count != count) {\n\t\t\tlast_odm_count = count;\n\t\t\tscene_odm = NULL;\n\t\t}\n\t}\n\tif (!video_odm && !audio_odm && !scene_odm) {\n\t\tu32 count, i;\n\t\tGF_ObjectManager *root_odm = root_odm = gf_term_get_root_object(term);\n\t\tif (!root_odm) return;\n\n\t\tif (gf_term_get_object_info(term, root_odm, &v_odi)==GF_OK) {\n\t\t\tif (!scene_odm  && (v_odi.generated_scene== 0)) {\n\t\t\t\tscene_odm = root_odm;\n\t\t\t}\n\t\t}\n\n\t\tcount = gf_term_get_object_count(term, root_odm);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_ObjectManager *odm = gf_term_get_object(term, root_odm, i);\n\t\t\tif (!odm) break;\n\t\t\tif (gf_term_get_object_info(term, odm, &v_odi) == GF_OK) {\n\t\t\t\tif (!video_odm && (v_odi.od_type == GF_STREAM_VISUAL) && (v_odi.raw_media || (v_odi.cb_max_count>1) || v_odi.direct_video_memory || (bench_mode == 3) )) {\n\t\t\t\t\tvideo_odm = odm;\n\t\t\t\t}\n\t\t\t\telse if (!audio_odm && (v_odi.od_type == GF_STREAM_AUDIO)) {\n\t\t\t\t\taudio_odm = odm;\n\t\t\t\t}\n\t\t\t\telse if (!scene_odm && (v_odi.od_type == GF_STREAM_SCENE)) {\n\t\t\t\t\tscene_odm = odm;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0 && bench_buffer) {\n\t\tfprintf(stderr, \"Buffering %d %% \", bench_buffer-1);\n\t\treturn;\n\t}\n\n\tif (video_odm) {\n\t\tif (gf_term_get_object_info(term, video_odm, &v_odi)!= GF_OK) {\n\t\t\tvideo_odm = NULL;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tmemset(&v_odi, 0, sizeof(v_odi));\n\t}\n\tif (print_codecs && audio_odm) {\n\t\tgf_term_get_object_info(term, audio_odm, &a_odi);\n\t} else {\n\t\tmemset(&a_odi, 0, sizeof(a_odi));\n\t}\n\tif ((print_codecs || !video_odm) && scene_odm) {\n\t\tgf_term_get_object_info(term, scene_odm, &s_odi);\n\t} else {\n\t\tmemset(&s_odi, 0, sizeof(s_odi));\n\t}\n\n\tif (final) {\n\t\ttot_time = gf_sys_clock() - bench_mode_start;\n\t\tfprintf(stderr, \"                                                                                     \\r\");\n\t\tfprintf(stderr, \"************** Bench Mode Done in %d ms ********************\\n\", tot_time);\n\t\tif (bench_mode==3) fprintf(stderr, \"** Systems layer only (no decoding) **\\n\");\n\n\t\tif (!video_odm) {\n\t\t\tu32 nb_frames_drawn;\n\t\t\tDouble FPS = gf_term_get_simulation_frame_rate(term, &nb_frames_drawn);\n\t\t\tfprintf(stderr, \"Drawn %d frames FPS %.2f (simulation FPS %.2f) - duration %d ms\\n\", nb_frames_drawn, ((Float)nb_frames_drawn*1000)/tot_time,(Float) FPS, gf_term_get_time_in_ms(term)  );\n\t\t}\n\t}\n\tif (print_codecs) {\n\t\tif (video_odm) {\n\t\t\tfprintf(stderr, \"%s %dx%d sar=%d:%d duration %.2fs\\n\", v_odi.codec_name, v_odi.width, v_odi.height, v_odi.par ? (v_odi.par>>16)&0xFF : 1, v_odi.par ? (v_odi.par)&0xFF : 1, v_odi.duration);\n\t\t\tif (final) {\n\t\t\t\tu32 dec_run_time = v_odi.last_frame_time - v_odi.first_frame_time;\n\t\t\t\tif (!dec_run_time) dec_run_time = 1;\n\t\t\t\tif (v_odi.duration) fprintf(stderr, \"%d%% \", (u32) (100*v_odi.current_time / v_odi.duration ) );\n\t\t\t\tfprintf(stderr, \"%d frames FPS %.2f (max %d us/f) rate avg %d max %d\", v_odi.nb_dec_frames, ((Float)v_odi.nb_dec_frames*1000) / dec_run_time, v_odi.max_dec_time, (u32) v_odi.avg_bitrate/1000, (u32) v_odi.max_bitrate/1000);\n\t\t\t\tif (v_odi.nb_dropped) {\n\t\t\t\t\tfprintf(stderr, \" (Error during bench: %d frames drop)\", v_odi.nb_dropped);\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t}\n\t\tif (audio_odm) {\n\t\t\tfprintf(stderr, \"%s SR %d num channels %d bpp %d duration %.2fs\\n\", a_odi.codec_name, a_odi.sample_rate, a_odi.num_channels, a_odi.bits_per_sample, a_odi.duration);\n\t\t\tif (final) {\n\t\t\t\tu32 dec_run_time = a_odi.last_frame_time - a_odi.first_frame_time;\n\t\t\t\tif (!dec_run_time) dec_run_time = 1;\n\t\t\t\tif (a_odi.duration) fprintf(stderr, \"%d%% \", (u32) (100*a_odi.current_time / a_odi.duration ) );\n\t\t\t\tfprintf(stderr, \"%d frames (ms/f %.2f avg %.2f max) rate avg %d max %d\", a_odi.nb_dec_frames, ((Float)dec_run_time)/a_odi.nb_dec_frames, a_odi.max_dec_time/1000.0, (u32) a_odi.avg_bitrate/1000, (u32) a_odi.max_bitrate/1000);\n\t\t\t\tif (a_odi.nb_dropped) {\n\t\t\t\t\tfprintf(stderr, \" (Error during bench: %d frames drop)\", a_odi.nb_dropped);\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t}\n\t\tif (scene_odm) {\n\t\t\tu32 w, h;\n\t\t\tgf_term_get_visual_output_size(term, &w, &h);\n\t\t\tfprintf(stderr, \"%s scene size %dx%d rastered to %dx%d duration %.2fs\\n\", s_odi.codec_name ? s_odi.codec_name : \"\", s_odi.width, s_odi.height, w, h, s_odi.duration);\n\t\t\tif (final) {\n\t\t\t\tif (s_odi.nb_dec_frames>2 && s_odi.total_dec_time) {\n\t\t\t\t\tu32 dec_run_time = s_odi.last_frame_time - s_odi.first_frame_time;\n\t\t\t\t\tif (!dec_run_time) dec_run_time = 1;\n\t\t\t\t\tfprintf(stderr, \"%d frames FPS %.2f (max %d us/f) rate avg %d max %d\", s_odi.nb_dec_frames, ((Float)s_odi.nb_dec_frames*1000) / dec_run_time, s_odi.max_dec_time, (u32) s_odi.avg_bitrate/1000, (u32) s_odi.max_bitrate/1000);\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tu32 nb_frames_drawn;\n\t\t\t\t\tDouble FPS;\n\t\t\t\t\tgf_term_get_simulation_frame_rate(term, &nb_frames_drawn);\n\t\t\t\t\ttot_time = gf_sys_clock() - bench_mode_start;\n\t\t\t\t\tFPS = gf_term_get_framerate(term, 0);\n\t\t\t\t\tfprintf(stderr, \"%d frames FPS %.2f (abs %.2f)\\n\", nb_frames_drawn, (1000.0*nb_frames_drawn / tot_time), FPS);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (final) {\n\t\t\tfprintf(stderr, \"**********************************************************\\n\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (video_odm) {\n\t\ttot_time = v_odi.last_frame_time - v_odi.first_frame_time;\n\t\tif (!tot_time) tot_time=1;\n\t\tif (v_odi.duration) fprintf(stderr, \"%d%% \", (u32) (100*v_odi.current_time / v_odi.duration ) );\n\t\tfprintf(stderr, \"%d f FPS %.2f (%.2f ms max) rate %d \", v_odi.nb_dec_frames, ((Float)v_odi.nb_dec_frames*1000) / tot_time, v_odi.max_dec_time/1000.0, (u32) v_odi.instant_bitrate/1000);\n\t}\n\telse if (scene_odm) {\n\n\t\tif (s_odi.nb_dec_frames>2 && s_odi.total_dec_time) {\n\t\t\tavg_dec_time = (Float) 1000000 * s_odi.nb_dec_frames;\n\t\t\tavg_dec_time /= s_odi.total_dec_time;\n\t\t\tif (s_odi.duration) fprintf(stderr, \"%d%% \", (u32) (100*s_odi.current_time / s_odi.duration ) );\n\t\t\tfprintf(stderr, \"%d f %.2f (%d us max) - rate %d \", s_odi.nb_dec_frames, avg_dec_time, s_odi.max_dec_time, (u32) s_odi.instant_bitrate/1000);\n\t\t} else {\n\t\t\tu32 nb_frames_drawn;\n\t\t\tDouble FPS;\n\t\t\tgf_term_get_simulation_frame_rate(term, &nb_frames_drawn);\n\t\t\ttot_time = gf_sys_clock() - bench_mode_start;\n\t\t\tFPS = gf_term_get_framerate(term, 1);\n\t\t\tfprintf(stderr, \"%d f FPS %.2f (abs %.2f) \", nb_frames_drawn, (1000.0*nb_frames_drawn / tot_time), FPS);\n\t\t}\n\t}\n\telse if (audio_odm) {\n\t\tif (!print_codecs) {\n\t\t\tgf_term_get_object_info(term, audio_odm, &a_odi);\n\t\t}\n\t\ttot_time = a_odi.last_frame_time - a_odi.first_frame_time;\n\t\tif (!tot_time) tot_time=1;\n\t\tif (a_odi.duration) fprintf(stderr, \"%d%% \", (u32) (100*a_odi.current_time / a_odi.duration ) );\n\t\tfprintf(stderr, \"%d frames (ms/f %.2f avg %.2f max)\", a_odi.nb_dec_frames, ((Float)tot_time)/a_odi.nb_dec_frames, a_odi.max_dec_time/1000.0);\n\t}\n}\n\nvoid PrintWorldInfo(GF_Terminal *term)\n{\n\tu32 i;\n\tconst char *title;\n\tGF_List *descs;\n\tdescs = gf_list_new();\n\ttitle = gf_term_get_world_info(term, NULL, descs);\n\tif (!title && !gf_list_count(descs)) {\n\t\tfprintf(stderr, \"No World Info available\\n\");\n\t} else {\n\t\tfprintf(stderr, \"\\t%s\\n\", title ? title : \"No title available\");\n\t\tfor (i=0; i<gf_list_count(descs); i++) {\n\t\t\tchar *str = gf_list_get(descs, i);\n\t\t\tfprintf(stderr, \"%s\\n\", str);\n\t\t}\n\t}\n\tgf_list_del(descs);\n}\n\nvoid PrintODList(GF_Terminal *term, GF_ObjectManager *root_odm, u32 num, u32 indent, char *root_name)\n{\n\tGF_MediaInfo odi;\n\tu32 i, count;\n\tchar szIndent[50];\n\tGF_ObjectManager *odm;\n\n\tif (!root_odm) {\n\t\tfprintf(stderr, \"Currently loaded objects:\\n\");\n\t\troot_odm = gf_term_get_root_object(term);\n\t}\n\tif (!root_odm) return;\n\n\tcount = gf_term_get_current_service_id(term);\n\tif (count)\n\t\tfprintf(stderr, \"Current service ID %d\\n\", count);\n\n\tif (gf_term_get_object_info(term, root_odm, &odi) != GF_OK) return;\n\tif (!odi.od) {\n\t\tfprintf(stderr, \"Service not attached\\n\");\n\t\treturn;\n\t}\n\n\tfor (i=0; i<indent; i++) szIndent[i]=' ';\n\tszIndent[indent]=0;\n\n\tfprintf(stderr, \"%s\", szIndent);\n\tfprintf(stderr, \"#%d %s - \", num, root_name);\n\tif (odi.od->ServiceID) fprintf(stderr, \"Service ID %d \", odi.od->ServiceID);\n\tif (odi.media_url) {\n\t\tfprintf(stderr, \"%s\\n\", odi.media_url);\n\t} else {\n\t\tfprintf(stderr, \"OD ID %d\\n\", odi.od->objectDescriptorID);\n\t}\n\n\tszIndent[indent]=' ';\n\tszIndent[indent+1]=0;\n\tindent++;\n\n\tcount = gf_term_get_object_count(term, root_odm);\n\tfor (i=0; i<count; i++) {\n\t\todm = gf_term_get_object(term, root_odm, i);\n\t\tif (!odm) break;\n\t\tnum++;\n\t\tif (gf_term_get_object_info(term, odm, &odi) == GF_OK) {\n\t\t\tswitch (gf_term_object_subscene_type(term, odm)) {\n\t\t\tcase 1:\n\t\t\t\tPrintODList(term, odm, num, indent, \"Root\");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tPrintODList(term, odm, num, indent, \"Inline Scene\");\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tPrintODList(term, odm, num, indent, \"EXTERNPROTO Library\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, \"%s\", szIndent);\n\t\t\t\tfprintf(stderr, \"#%d - \", num);\n\t\t\t\tif (odi.media_url) {\n\t\t\t\t\tfprintf(stderr, \"%s\", odi.media_url);\n\t\t\t\t} else if (odi.od) {\n\t\t\t\t \tif (odi.od->URLString) {\n\t\t\t\t\t\tfprintf(stderr, \"%s\", odi.od->URLString);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfprintf(stderr, \"ID %d\", odi.od->objectDescriptorID);\n\t\t\t\t\t}\n\t\t\t\t} else if (odi.service_url) {\n\t\t\t\t\tfprintf(stderr, \"%s\", odi.service_url);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"unknown\");\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \" - %s\", (odi.od_type==GF_STREAM_VISUAL) ? \"Video\" : (odi.od_type==GF_STREAM_AUDIO) ? \"Audio\" : \"Systems\");\n\t\t\t\tif (odi.od && odi.od->ServiceID) fprintf(stderr, \" - Service ID %d\", odi.od->ServiceID);\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid ViewOD(GF_Terminal *term, u32 OD_ID, u32 number, const char *szURL)\n{\n\tGF_MediaInfo odi;\n\tu32 i, j, count, d_enum,id;\n\tGF_Err e;\n\tNetStatCommand com;\n\tGF_ObjectManager *odm, *root_odm = gf_term_get_root_object(term);\n\tif (!root_odm) return;\n\n\todm = NULL;\n\tif (!szURL && ((!OD_ID && (number == (u32)-1)) || ((OD_ID == (u32)(-1)) && !number))) {\n\t\todm = root_odm;\n\t\tif ((gf_term_get_object_info(term, odm, &odi) != GF_OK)) odm=NULL;\n\t} else {\n\t\tcount = gf_term_get_object_count(term, root_odm);\n\t\tfor (i=0; i<count; i++) {\n\t\t\todm = gf_term_get_object(term, root_odm, i);\n\t\t\tif (!odm) break;\n\t\t\tif (gf_term_get_object_info(term, odm, &odi) == GF_OK) {\n\t\t\t\tif (szURL && strstr(odi.service_url, szURL)) break;\n\t\t\t\tif ((number == (u32)(-1)) && odi.od && (odi.od->objectDescriptorID == OD_ID)) break;\n\t\t\t\telse if (i == (u32)(number-1)) break;\n\t\t\t}\n\t\t\todm = NULL;\n\t\t}\n\t}\n\tif (!odm) {\n\t\tif (szURL) fprintf(stderr, \"cannot find OD for URL %s\\n\", szURL);\n\t\tif (number == (u32)-1) fprintf(stderr, \"cannot find OD with ID %d\\n\", OD_ID);\n\t\telse fprintf(stderr, \"cannot find OD with number %d\\n\", number);\n\t\treturn;\n\t}\n\tif (!odi.od) {\n\t\tif (number == (u32)-1) fprintf(stderr, \"Object %d not attached yet\\n\", OD_ID);\n\t\telse fprintf(stderr, \"Object #%d not attached yet\\n\", number);\n\t\treturn;\n\t}\n\n\tif (!odi.od) {\n\t\tfprintf(stderr, \"Service not attached\\n\");\n\t\treturn;\n\t}\n\n\tif (odi.od->tag==GF_ODF_IOD_TAG) {\n\t\tfprintf(stderr, \"InitialObjectDescriptor %d\\n\", odi.od->objectDescriptorID);\n\t\tfprintf(stderr, \"Profiles and Levels: Scene %x - Graphics %x - Visual %x - Audio %x - OD %x\\n\",\n\t\t        odi.scene_pl, odi.graphics_pl, odi.visual_pl, odi.audio_pl, odi.OD_pl);\n\t\tfprintf(stderr, \"Inline Profile Flag %d\\n\", odi.inline_pl);\n\t} else {\n\t\tfprintf(stderr, \"ObjectDescriptor %d\\n\", odi.od->objectDescriptorID);\n\t}\n\n\tfprintf(stderr, \"Object Duration: \");\n\tif (odi.duration) {\n\t\tPrintTime((u32) (odi.duration*1000));\n\t} else {\n\t\tfprintf(stderr, \"unknown\");\n\t}\n\tfprintf(stderr, \"\\n\");\n\n\tfprintf(stderr, \"Service Handler: %s\\n\", odi.service_handler);\n\tfprintf(stderr, \"Service URL: %s\\n\", odi.service_url);\n\n\tif (odi.codec_name) {\n\t\tFloat avg_dec_time;\n\t\tswitch (odi.od_type) {\n\t\tcase GF_STREAM_VISUAL:\n\t\t\tfprintf(stderr, \"Video Object: Width %d - Height %d\\r\\n\", odi.width, odi.height);\n\t\t\tfprintf(stderr, \"Media Codec: %s\\n\", odi.codec_name);\n\t\t\tif (odi.par) fprintf(stderr, \"Pixel Aspect Ratio: %d:%d\\n\", (odi.par>>16)&0xFF, (odi.par)&0xFF);\n\t\t\tbreak;\n\t\tcase GF_STREAM_AUDIO:\n\t\t\tfprintf(stderr, \"Audio Object: Sample Rate %d - %d channels\\r\\n\", odi.sample_rate, odi.num_channels);\n\t\t\tfprintf(stderr, \"Media Codec: %s\\n\", odi.codec_name);\n\t\t\tbreak;\n\t\tcase GF_STREAM_SCENE:\n\t\tcase GF_STREAM_PRIVATE_SCENE:\n\t\t\tif (odi.width && odi.height) {\n\t\t\t\tfprintf(stderr, \"Scene Description - Width %d - Height %d\\n\", odi.width, odi.height);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Scene Description - no size specified\\n\");\n\t\t\t}\n\t\t\tfprintf(stderr, \"Scene Codec: %s\\n\", odi.codec_name);\n\t\t\tbreak;\n\t\tcase GF_STREAM_TEXT:\n\t\t\tif (odi.width && odi.height) {\n\t\t\t\tfprintf(stderr, \"Text Object: Width %d - Height %d\\n\", odi.width, odi.height);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Text Object: No size specified\\n\");\n\t\t\t}\n\t\t\tfprintf(stderr, \"Text Codec %s\\n\", odi.codec_name);\n\t\t\tbreak;\n\t\t}\n\n\t\tavg_dec_time = 0;\n\t\tif (odi.nb_dec_frames) {\n\t\t\tavg_dec_time = (Float) odi.total_dec_time;\n\t\t\tavg_dec_time /= odi.nb_dec_frames;\n\t\t}\n\t\tfprintf(stderr, \"\\tBitrate over last second: %d kbps\\n\\tMax bitrate over one second: %d kbps\\n\\tAverage Decoding Time %.2f us %d max)\\n\\tTotal decoded frames %d\\n\",\n\t\t        (u32) odi.avg_bitrate/1024, odi.max_bitrate/1024, avg_dec_time, odi.max_dec_time, odi.nb_dec_frames);\n\t}\n\tif (odi.protection) fprintf(stderr, \"Encrypted Media%s\\n\", (odi.protection==2) ? \" NOT UNLOCKED\" : \"\");\n\n\tcount = gf_list_count(odi.od->ESDescriptors);\n\tfprintf(stderr, \"%d streams in OD\\n\", count);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ESD *esd = (GF_ESD *) gf_list_get(odi.od->ESDescriptors, i);\n\n\t\tfprintf(stderr, \"\\nStream ID %d - Clock ID %d\\n\", esd->ESID, esd->OCRESID);\n\t\tif (esd->dependsOnESID) fprintf(stderr, \"\\tDepends on Stream ID %d for decoding\\n\", esd->dependsOnESID);\n\n\t\tswitch (esd->decoderConfig->streamType) {\n\t\tcase GF_STREAM_OD:\n\t\t\tfprintf(stderr, \"\\tOD Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tcase GF_STREAM_OCR:\n\t\t\tfprintf(stderr, \"\\tOCR Stream\\n\");\n\t\t\tbreak;\n\t\tcase GF_STREAM_SCENE:\n\t\t\tfprintf(stderr, \"\\tScene Description Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tcase GF_STREAM_VISUAL:\n\t\t\tfprintf(stderr, \"\\tVisual Stream - media type: %s\", gf_esd_get_textual_description(esd));\n\t\t\tbreak;\n\t\tcase GF_STREAM_AUDIO:\n\t\t\tfprintf(stderr, \"\\tAudio Stream - media type: %s\", gf_esd_get_textual_description(esd));\n\t\t\tbreak;\n\t\tcase GF_STREAM_MPEG7:\n\t\t\tfprintf(stderr, \"\\tMPEG-7 Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tcase GF_STREAM_IPMP:\n\t\t\tfprintf(stderr, \"\\tIPMP Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tcase GF_STREAM_OCI:\n\t\t\tfprintf(stderr, \"\\tOCI Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tcase GF_STREAM_MPEGJ:\n\t\t\tfprintf(stderr, \"\\tMPEGJ Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tcase GF_STREAM_INTERACT:\n\t\t\tfprintf(stderr, \"\\tUser Interaction Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tcase GF_STREAM_TEXT:\n\t\t\tfprintf(stderr, \"\\tStreaming Text Stream - version %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"\\tUnknown Stream\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tfprintf(stderr, \"\\tBuffer Size %d\\n\\tAverage Bitrate %d bps\\n\\tMaximum Bitrate %d bps\\n\", esd->decoderConfig->bufferSizeDB, esd->decoderConfig->avgBitrate, esd->decoderConfig->maxBitrate);\n\t\tif (esd->slConfig->predefined==SLPredef_SkipSL) {\n\t\t\tfprintf(stderr, \"\\tNot using MPEG-4 Synchronization Layer\\n\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"\\tStream Clock Resolution %d\\n\", esd->slConfig->timestampResolution);\n\t\t}\n\t\tif (esd->URLString) fprintf(stderr, \"\\tStream Location: %s\\n\", esd->URLString);\n\n\t\t/*check language*/\n\t\tif (esd->langDesc) {\n\t\t\ts32 lang_idx;\n\t\t\tchar lan[4];\n\t\t\tlan[0] = esd->langDesc->langCode>>16;\n\t\t\tlan[1] = (esd->langDesc->langCode>>8)&0xFF;\n\t\t\tlan[2] = (esd->langDesc->langCode)&0xFF;\n\t\t\tlan[3] = 0;\n\n\t\t\tlang_idx = gf_lang_find(lan);\n\t\t\tif (lang_idx>=0) {\n\t\t\t\tfprintf(stderr, \"\\tStream Language: %s\\n\", gf_lang_get_name(lang_idx));\n\t\t\t}\n\t\t}\n\t}\n\tfprintf(stderr, \"\\n\");\n\t/*check OCI (not everything interests us) - FIXME: support for unicode*/\n\tcount = gf_list_count(odi.od->OCIDescriptors);\n\tif (count) {\n\t\tfprintf(stderr, \"%d Object Content Information descriptors in OD\\n\", count);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_Descriptor *desc = (GF_Descriptor *) gf_list_get(odi.od->OCIDescriptors, i);\n\t\t\tswitch (desc->tag) {\n\t\t\tcase GF_ODF_SEGMENT_TAG:\n\t\t\t{\n\t\t\t\tGF_Segment *sd = (GF_Segment *) desc;\n\t\t\t\tfprintf(stderr, \"Segment Descriptor: Name: %s - start time %g sec - duration %g sec\\n\", sd->SegmentName, sd->startTime, sd->Duration);\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase GF_ODF_CC_NAME_TAG:\n\t\t\t{\n\t\t\t\tGF_CC_Name *ccn = (GF_CC_Name *)desc;\n\t\t\t\tfprintf(stderr, \"Content Creators:\\n\");\n\t\t\t\tfor (j=0; j<gf_list_count(ccn->ContentCreators); j++) {\n\t\t\t\t\tGF_ContentCreatorInfo *ci = (GF_ContentCreatorInfo *) gf_list_get(ccn->ContentCreators, j);\n\t\t\t\t\tif (!ci->isUTF8) continue;\n\t\t\t\t\tfprintf(stderr, \"\\t%s\\n\", ci->contentCreatorName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\tcase GF_ODF_SHORT_TEXT_TAG:\n\t\t\t{\n\t\t\t\tGF_ShortTextual *std = (GF_ShortTextual *)desc;\n\t\t\t\tfprintf(stderr, \"Description:\\n\\tEvent: %s\\n\\t%s\\n\", std->eventName, std->eventText);\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\n\tswitch (odi.status) {\n\tcase 0:\n\t\tfprintf(stderr, \"Stopped - \");\n\t\tbreak;\n\tcase 1:\n\t\tfprintf(stderr, \"Playing - \");\n\t\tbreak;\n\tcase 2:\n\t\tfprintf(stderr, \"Paused - \");\n\t\tbreak;\n\tcase 3:\n\t\tfprintf(stderr, \"Not setup yet\\n\");\n\t\treturn;\n\tdefault:\n\t\tfprintf(stderr, \"Setup Failed\\n\");\n\t\treturn;\n\t}\n\tif (odi.buffer>=0) fprintf(stderr, \"Buffer: %d ms - \", odi.buffer);\n\telse fprintf(stderr, \"Not buffering - \");\n\tfprintf(stderr, \"Clock drift: %d ms\\n\", odi.clock_drift);\n\tif (odi.db_unit_count) fprintf(stderr, \"%d AU in DB\\n\", odi.db_unit_count);\n\tif (odi.cb_max_count) fprintf(stderr, \"Composition Buffer: %d CU (%d max)\\n\", odi.cb_unit_count, odi.cb_max_count);\n\tfprintf(stderr, \"\\n\");\n\n\tif (odi.owns_service) {\n\t\tconst char *url;\n\t\tu32 done, total, bps;\n\t\td_enum = 0;\n\t\twhile (gf_term_get_download_info(term, odm, &d_enum, &url, NULL, &done, &total, &bps)) {\n\t\t\tif (d_enum==1) fprintf(stderr, \"Current Downloads in service:\\n\");\n\t\t\tif (done && total) {\n\t\t\t\tfprintf(stderr, \"%s: %d / %d bytes (%.2f %%) - %.2f kBps\\n\", url, done, total, (100.0f*done)/total, ((Float)bps)/1024.0f);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"%s: %.2f kbps\\n\", url, ((Float)8*bps)/1024.0f);\n\t\t\t}\n\t\t}\n\t\tif (!d_enum) fprintf(stderr, \"No Downloads in service\\n\");\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\td_enum = 0;\n\twhile (gf_term_get_channel_net_info(term, odm, &d_enum, &id, &com, &e)) {\n\t\tif (e) continue;\n\t\tif (!com.bw_down && !com.bw_up) continue;\n\n\t\tfprintf(stderr, \"Stream ID %d statistics:\\n\", id);\n\t\tif (com.multiplex_port) {\n\t\t\tfprintf(stderr, \"\\tMultiplex Port %d - multiplex ID %d\\n\", com.multiplex_port, com.port);\n\t\t} else {\n\t\t\tfprintf(stderr, \"\\tPort %d\\n\", com.port);\n\t\t}\n\t\tfprintf(stderr, \"\\tPacket Loss Percentage: %.4f\\n\", com.pck_loss_percentage);\n\t\tfprintf(stderr, \"\\tDown Bandwidth: %d bps\\n\", com.bw_down);\n\t\tif (com.bw_up) fprintf(stderr, \"\\tUp Bandwidth: %d bps\\n\", com.bw_up);\n\t\tif (com.ctrl_port) {\n\t\t\tif (com.multiplex_port) {\n\t\t\t\tfprintf(stderr, \"\\tControl Multiplex Port: %d - Control Multiplex ID %d\\n\", com.multiplex_port, com.ctrl_port);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"\\tControl Port: %d\\n\", com.ctrl_port);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\tDown Bandwidth: %d bps\\n\", com.ctrl_bw_down);\n\t\t\tfprintf(stderr, \"\\tUp Bandwidth: %d bps\\n\", com.ctrl_bw_up);\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}\n\nvoid PrintODTiming(GF_Terminal *term, GF_ObjectManager *odm, u32 indent)\n{\n\tGF_MediaInfo odi;\n\tu32 ind = indent;\n\tu32 i, count;\n\tif (!odm) return;\n\n\tif (gf_term_get_object_info(term, odm, &odi) != GF_OK) return;\n\tif (!odi.od) {\n\t\tfprintf(stderr, \"Service not attached\\n\");\n\t\treturn;\n\t}\n\twhile (ind) {\n\t\tfprintf(stderr, \" \");\n\t\tind--;\n\t}\n\n\tif (! odi.generated_scene) {\n\n\t\tfprintf(stderr, \"- OD %d: \", odi.od->objectDescriptorID);\n\t\tswitch (odi.status) {\n\t\tcase 1:\n\t\t\tfprintf(stderr, \"Playing - \");\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tfprintf(stderr, \"Paused - \");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Stopped - \");\n\t\t\tbreak;\n\t\t}\n\t\tif (odi.buffer>=0) fprintf(stderr, \"Buffer: %d ms - \", odi.buffer);\n\t\telse fprintf(stderr, \"Not buffering - \");\n\t\tfprintf(stderr, \"Clock drift: %d ms\", odi.clock_drift);\n\t\tfprintf(stderr, \" - time: \");\n\t\tPrintTime((u32) (odi.current_time*1000));\n\t\tfprintf(stderr, \"\\n\");\n\n\t} else {\n\t\tfprintf(stderr, \"+ Service %s:\\n\", odi.service_url);\n\t}\n\n\tcount = gf_term_get_object_count(term, odm);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ObjectManager *an_odm = gf_term_get_object(term, odm, i);\n\t\tPrintODTiming(term, an_odm, indent+1);\n\t}\n\treturn;\n\n}\n\nvoid PrintODBuffer(GF_Terminal *term, GF_ObjectManager *odm, u32 indent)\n{\n\tFloat avg_dec_time;\n\tGF_MediaInfo odi;\n\tu32 ind, i, count;\n\tif (!odm) return;\n\n\tif (gf_term_get_object_info(term, odm, &odi) != GF_OK) return;\n\tif (!odi.od) {\n\t\tfprintf(stderr, \"Service not attached\\n\");\n\t\treturn;\n\t}\n\n\tind = indent;\n\twhile (ind) {\n\t\tfprintf(stderr, \" \");\n\t\tind--;\n\t}\n\n\tif (odi.generated_scene) {\n\t\tfprintf(stderr, \"+ Service %s:\\n\", odi.service_url);\n\t} else {\n\t\tfprintf(stderr, \"- OD %d: \", odi.od->objectDescriptorID);\n\t\tswitch (odi.status) {\n\t\tcase 1:\n\t\t\tfprintf(stderr, \"Playing\");\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tfprintf(stderr, \"Paused\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Stopped\");\n\t\t\tbreak;\n\t\t}\n\t\tif (odi.buffer>=0) fprintf(stderr, \" - Buffer: %d ms\", odi.buffer);\n\t\tif (odi.db_unit_count) fprintf(stderr, \" - DB: %d AU\", odi.db_unit_count);\n\t\tif (odi.cb_max_count) fprintf(stderr, \" - CB: %d/%d CUs\", odi.cb_unit_count, odi.cb_max_count);\n\n\t\tfprintf(stderr, \"\\n\");\n\t\tind = indent;\n\t\twhile (ind) {\n\t\t\tfprintf(stderr, \" \");\n\t\t\tind--;\n\t\t}\n\n\t\tfprintf(stderr, \" %d decoded frames - %d dropped frames\\n\", odi.nb_dec_frames, odi.nb_dropped);\n\n\t\tind = indent;\n\t\twhile (ind) {\n\t\t\tfprintf(stderr, \" \");\n\t\t\tind--;\n\t\t}\n\n\t\tavg_dec_time = 0;\n\t\tif (odi.nb_dec_frames) {\n\t\t\tavg_dec_time = (Float) odi.total_dec_time;\n\t\t\tavg_dec_time /= odi.nb_dec_frames;\n\t\t}\n\t\tfprintf(stderr, \" Avg Bitrate %d kbps (%d max) - Avg Decoding Time %.2f us (%d max)\\n\",\n\t\t        (u32) odi.avg_bitrate/1024, odi.max_bitrate/1024, avg_dec_time, odi.max_dec_time);\n\t}\n\n\tcount = gf_term_get_object_count(term, odm);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ObjectManager *an_odm = gf_term_get_object(term, odm, i);\n\t\tPrintODBuffer(term, an_odm, indent+1);\n\t}\n\n}\n\nvoid ViewODs(GF_Terminal *term, Bool show_timing)\n{\n\tGF_ObjectManager *root_odm = gf_term_get_root_object(term);\n\tif (!root_odm) return;\n\n\tif (show_timing) {\n\t\tPrintODTiming(term, root_odm, 0);\n\t} else {\n\t\tPrintODBuffer(term, root_odm, 0);\n\t}\n\tfprintf(stderr, \"\\n\");\n}\n\n\nvoid PrintGPACConfig()\n{\n\tu32 i, j, cfg_count, key_count;\n\tchar szName[200];\n\tchar *secName = NULL;\n\n\tfprintf(stderr, \"Enter section name (\\\"*\\\" for complete dump):\\n\");\n\tif (1 > scanf(\"%s\", szName)) {\n\t\tfprintf(stderr, \"No section name, aborting.\\n\");\n\t\treturn;\n\t}\n\tif (strcmp(szName, \"*\")) secName = szName;\n\n\tfprintf(stderr, \"\\n\\n*** GPAC Configuration ***\\n\\n\");\n\n\tcfg_count = gf_cfg_get_section_count(cfg_file);\n\tfor (i=0; i<cfg_count; i++) {\n\t\tconst char *sec = gf_cfg_get_section_name(cfg_file, i);\n\t\tif (secName) {\n\t\t\tif (stricmp(sec, secName)) continue;\n\t\t} else {\n\t\t\tif (!stricmp(sec, \"General\")) continue;\n\t\t\tif (!stricmp(sec, \"MimeTypes\")) continue;\n\t\t\tif (!stricmp(sec, \"RecentFiles\")) continue;\n\t\t}\n\t\tfprintf(stderr, \"[%s]\\n\", sec);\n\t\tkey_count = gf_cfg_get_key_count(cfg_file, sec);\n\t\tfor (j=0; j<key_count; j++) {\n\t\t\tconst char *key = gf_cfg_get_key_name(cfg_file, sec, j);\n\t\t\tconst char *val = gf_cfg_get_key(cfg_file, sec, key);\n\t\t\tfprintf(stderr, \"%s=%s\\n\", key, val);\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}\n\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / Media Tools sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n\n#include <gpac/constants.h>\n#include <gpac/utf.h>\n#include <gpac/xml.h>\n#include <gpac/token.h>\n#include <gpac/color.h>\n#include <gpac/internal/media_dev.h>\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nvoid gf_media_update_bitrate(GF_ISOFile *file, u32 track);\n\nenum\n{\n\tGF_TEXT_IMPORT_NONE = 0,\n\tGF_TEXT_IMPORT_SRT,\n\tGF_TEXT_IMPORT_SUB,\n\tGF_TEXT_IMPORT_TTXT,\n\tGF_TEXT_IMPORT_TEXML,\n\tGF_TEXT_IMPORT_WEBVTT,\n\tGF_TEXT_IMPORT_TTML,\n\tGF_TEXT_IMPORT_SWF_SVG,\n};\n\n#define REM_TRAIL_MARKS(__str, __sep) while (1) {\t\\\n\t\tu32 _len = (u32) strlen(__str);\t\t\\\n\t\tif (!_len) break;\t\\\n\t\t_len--;\t\t\t\t\\\n\t\tif (strchr(__sep, __str[_len])) __str[_len] = 0;\t\\\n\t\telse break;\t\\\n\t}\t\\\n \n\ns32 gf_text_get_utf_type(FILE *in_src)\n{\n\tu32 read;\n\tunsigned char BOM[5];\n\tread = (u32) fread(BOM, sizeof(char), 5, in_src);\n\tif ((s32) read < 1)\n\t\treturn -1;\n\n\tif ((BOM[0]==0xFF) && (BOM[1]==0xFE)) {\n\t\t/*UTF32 not supported*/\n\t\tif (!BOM[2] && !BOM[3]) return -1;\n\t\tgf_fseek(in_src, 2, SEEK_SET);\n\t\treturn 3;\n\t}\n\tif ((BOM[0]==0xFE) && (BOM[1]==0xFF)) {\n\t\t/*UTF32 not supported*/\n\t\tif (!BOM[2] && !BOM[3]) return -1;\n\t\tgf_fseek(in_src, 2, SEEK_SET);\n\t\treturn 2;\n\t} else if ((BOM[0]==0xEF) && (BOM[1]==0xBB) && (BOM[2]==0xBF)) {\n\t\tgf_fseek(in_src, 3, SEEK_SET);\n\t\treturn 1;\n\t}\n\tif (BOM[0]<0x80) {\n\t\tgf_fseek(in_src, 0, SEEK_SET);\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nstatic GF_Err gf_text_guess_format(char *filename, u32 *fmt)\n{\n\tchar szLine[2048];\n\tu32 val;\n\ts32 uni_type;\n\tFILE *test = gf_fopen(filename, \"rb\");\n\tif (!test) return GF_URL_ERROR;\n\tuni_type = gf_text_get_utf_type(test);\n\n\tif (uni_type>1) {\n\t\tconst u16 *sptr;\n\t\tchar szUTF[1024];\n\t\tu32 read = (u32) fread(szUTF, 1, 1023, test);\n\t\tif ((s32) read < 0) {\n\t\t\tgf_fclose(test);\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\tszUTF[read]=0;\n\t\tsptr = (u16*)szUTF;\n\t\t/*read = (u32) */gf_utf8_wcstombs(szLine, read, &sptr);\n\t} else {\n\t\tval = (u32) fread(szLine, 1, 1024, test);\n\t\tif ((s32) val<0) return GF_IO_ERR;\n\t\t\n\t\tszLine[val]=0;\n\t}\n\tREM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\n\t*fmt = GF_TEXT_IMPORT_NONE;\n\tif ((szLine[0]=='{') && strstr(szLine, \"}{\")) *fmt = GF_TEXT_IMPORT_SUB;\n\telse if (szLine[0] == '<') {\n\t\tchar *ext = strrchr(filename, '.');\n\t\tif (!strnicmp(ext, \".ttxt\", 5)) *fmt = GF_TEXT_IMPORT_TTXT;\n\t\telse if (!strnicmp(ext, \".ttml\", 5)) *fmt = GF_TEXT_IMPORT_TTML;\n\t\text = strstr(szLine, \"?>\");\n\t\tif (ext) ext += 2;\n\t\tif (ext && !ext[0]) {\n\t\t\tif (!fgets(szLine, 2048, test))\n\t\t\t\tszLine[0] = '\\0';\n\t\t}\n\t\tif (strstr(szLine, \"x-quicktime-tx3g\") || strstr(szLine, \"text3GTrack\")) *fmt = GF_TEXT_IMPORT_TEXML;\n\t\telse if (strstr(szLine, \"TextStream\")) *fmt = GF_TEXT_IMPORT_TTXT;\n\t\telse if (strstr(szLine, \"tt\")) *fmt = GF_TEXT_IMPORT_TTML;\n\t}\n\telse if (strstr(szLine, \"WEBVTT\") )\n\t\t*fmt = GF_TEXT_IMPORT_WEBVTT;\n\telse if (strstr(szLine, \" --> \") )\n\t\t*fmt = GF_TEXT_IMPORT_SRT; /* might want to change the default to WebVTT */\n\n\tgf_fclose(test);\n\treturn GF_OK;\n}\n\n\n#define TTXT_DEFAULT_WIDTH\t400\n#define TTXT_DEFAULT_HEIGHT\t60\n#define TTXT_DEFAULT_FONT_SIZE\t18\n\n#ifndef GPAC_DISABLE_MEDIA_IMPORT\nvoid gf_text_get_video_size(GF_MediaImporter *import, u32 *width, u32 *height)\n{\n\tu32 w, h, f_w, f_h, i;\n\tGF_ISOFile *dest = import->dest;\n\n\tif (import->text_track_width && import->text_track_height) {\n\t\t(*width) = import->text_track_width;\n\t\t(*height) = import->text_track_height;\n\t\treturn;\n\t}\n\n\tf_w = f_h = 0;\n\tfor (i=0; i<gf_isom_get_track_count(dest); i++) {\n\t\tswitch (gf_isom_get_media_type(dest, i+1)) {\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n        case GF_ISOM_MEDIA_AUXV:\n        case GF_ISOM_MEDIA_PICT:\n\t\t\tgf_isom_get_visual_info(dest, i+1, 1, &w, &h);\n\t\t\tif (w > f_w) f_w = w;\n\t\t\tif (h > f_h) f_h = h;\n\t\t\tgf_isom_get_track_layout_info(dest, i+1, &w, &h, NULL, NULL, NULL);\n\t\t\tif (w > f_w) f_w = w;\n\t\t\tif (h > f_h) f_h = h;\n\t\t\tbreak;\n\t\t}\n\t}\n\t(*width) = f_w ? f_w : TTXT_DEFAULT_WIDTH;\n\t(*height) = f_h ? f_h : TTXT_DEFAULT_HEIGHT;\n}\n\n\nvoid gf_text_import_set_language(GF_MediaImporter *import, u32 track)\n{\n\tif (import->esd && import->esd->langDesc) {\n\t\tchar lang[4];\n\t\tlang[0] = (import->esd->langDesc->langCode>>16) & 0xFF;\n\t\tlang[1] = (import->esd->langDesc->langCode>>8) & 0xFF;\n\t\tlang[2] = (import->esd->langDesc->langCode) & 0xFF;\n\t\tlang[3] = 0;\n\t\tgf_isom_set_media_language(import->dest, track, lang);\n\t}\n}\n#endif\n\nchar *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicode_type)\n{\n\tu32 i, j, len;\n\tchar *sOK;\n\tchar szLineConv[1024];\n\tunsigned short *sptr;\n\n\tmemset(szLine, 0, sizeof(char)*lineSize);\n\tsOK = fgets(szLine, lineSize, txt_in);\n\tif (!sOK) return NULL;\n\tif (unicode_type<=1) {\n\t\tj=0;\n\t\tlen = (u32) strlen(szLine);\n\t\tfor (i=0; i<len && j < sizeof(szLineConv) - 1; i++, j++) {\n\n\t\t\tif (!unicode_type && (szLine[i] & 0x80)) {\n\t\t\t\t/*non UTF8 (likely some win-CP)*/\n\t\t\t\tif ((szLine[i+1] & 0xc0) != 0x80) {\n\t\t\t\t\tif (j + 1 < sizeof(szLineConv) - 1) {\n\t\t\t\t\t\tszLineConv[j] = 0xc0 | ((szLine[i] >> 6) & 0x3);\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tszLine[i] &= 0xbf;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/*UTF8 2 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xe0) == 0xc0) {\n\n\t\t\t\t\t// don't cut multibyte in the middle in there is no more room in dest\n\t\t\t\t\tif (j + 1 < sizeof(szLineConv) - 1 && i + 1 < len) {\n\t\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*UTF8 3 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf0) == 0xe0) {\n\t\t\t\t\tif (j + 2 < sizeof(szLineConv) - 1 && i + 2 < len) {\n\t\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*UTF8 4 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf8) == 0xf0) {\n\t\t\t\t\tif (j + 3 < sizeof(szLineConv) - 1 && i + 3 < len) {\n\t\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ti+=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j < sizeof(szLineConv)-1 && i<len)\n\t\t\t\tszLineConv[j] = szLine[i];\n\n\t\t}\n\t\tif (j >= sizeof(szLineConv))\n\t\t\tszLineConv[sizeof(szLineConv) - 1] = 0;\n\t\telse\n\t\t\tszLineConv[j] = 0;\n\n\t\tstrcpy(szLine, szLineConv);\n\t\treturn sOK;\n\t}\n\n#ifdef GPAC_BIG_ENDIAN\n\tif (unicode_type==3) {\n#else\n\tif (unicode_type==2) {\n#endif\n\t\ti=0;\n\t\twhile (1) {\n\t\t\tchar c;\n\t\t\tif (!szLine[i] && !szLine[i+1]) break;\n\t\t\tc = szLine[i+1];\n\t\t\tszLine[i+1] = szLine[i];\n\t\t\tszLine[i] = c;\n\t\t\ti+=2;\n\t\t}\n\t}\n\tsptr = (u16 *)szLine;\n\ti = (u32) gf_utf8_wcstombs(szLineConv, 1024, (const unsigned short **) &sptr);\n\tif (i >= (u32)ARRAY_LENGTH(szLineConv))\n\t\treturn NULL;\n\tszLineConv[i] = 0;\n\tstrcpy(szLine, szLineConv);\n\t/*this is ugly indeed: since input is UTF16-LE, there are many chances the fgets never reads the \\0 after a \\n*/\n\tif (unicode_type==3) fgetc(txt_in);\n\treturn sOK;\n}\n\n\n#ifndef GPAC_DISABLE_MEDIA_IMPORT\n\nstatic GF_Err gf_text_import_srt(GF_MediaImporter *import)\n{\n\tFILE *srt_in;\n\tu32 track, timescale, i, count;\n\tGF_TextConfig*cfg;\n\tGF_Err e;\n\tGF_StyleRecord rec;\n\tGF_TextSample * samp;\n\tGF_ISOSample *s;\n\tu32 sh, sm, ss, sms, eh, em, es, ems, txt_line, char_len, char_line, nb_samp, j, duration, rem_styles;\n\tBool set_start_char, set_end_char, first_samp, rem_color;\n\tu64 start, end, prev_end, file_size;\n\tu32 state, curLine, line, len, ID, OCR_ES_ID, default_color;\n\ts32 unicode_type;\n\tchar szLine[2048], szText[2048], *ptr;\n\tunsigned short uniLine[5000], uniText[5000], *sptr;\n\n\tsrt_in = gf_fopen(import->in_name, \"rt\");\n\tgf_fseek(srt_in, 0, SEEK_END);\n\tfile_size = gf_ftell(srt_in);\n\tgf_fseek(srt_in, 0, SEEK_SET);\n\n\tunicode_type = gf_text_get_utf_type(srt_in);\n\tif (unicode_type<0) {\n\t\tgf_fclose(srt_in);\n\t\treturn gf_import_message(import, GF_NOT_SUPPORTED, \"Unsupported SRT UTF encoding\");\n\t}\n\n\tcfg = NULL;\n\tif (import->esd) {\n\t\tif (!import->esd->slConfig) {\n\t\t\timport->esd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\t\timport->esd->slConfig->predefined = 2;\n\t\t\timport->esd->slConfig->timestampResolution = 1000;\n\t\t}\n\t\ttimescale = import->esd->slConfig->timestampResolution;\n\t\tif (!timescale) timescale = 1000;\n\n\t\t/*explicit text config*/\n\t\tif (import->esd->decoderConfig && import->esd->decoderConfig->decoderSpecificInfo->tag == GF_ODF_TEXT_CFG_TAG) {\n\t\t\tcfg = (GF_TextConfig *) import->esd->decoderConfig->decoderSpecificInfo;\n\t\t\timport->esd->decoderConfig->decoderSpecificInfo = NULL;\n\t\t}\n\t\tID = import->esd->ESID;\n\t\tOCR_ES_ID = import->esd->OCRESID;\n\t} else {\n\t\ttimescale = 1000;\n\t\tOCR_ES_ID = ID = 0;\n\t}\n\n\tif (cfg && cfg->timescale) timescale = cfg->timescale;\n\ttrack = gf_isom_new_track(import->dest, ID, GF_ISOM_MEDIA_TEXT, timescale);\n\tif (!track) {\n\t\tgf_fclose(srt_in);\n\t\treturn gf_import_message(import, gf_isom_last_error(import->dest), \"Error creating text track\");\n\t}\n\tgf_isom_set_track_enabled(import->dest, track, 1);\n\timport->final_trackID = gf_isom_get_track_id(import->dest, track);\n\tif (import->esd && !import->esd->ESID) import->esd->ESID = import->final_trackID;\n\n\tif (OCR_ES_ID) gf_isom_set_track_reference(import->dest, track, GF_ISOM_REF_OCR, OCR_ES_ID);\n\n\t/*setup track*/\n\tif (cfg) {\n\t\tchar *firstFont = NULL;\n\t\t/*set track info*/\n\t\tgf_isom_set_track_layout_info(import->dest, track, cfg->text_width<<16, cfg->text_height<<16, 0, 0, cfg->layer);\n\n\t\t/*and set sample descriptions*/\n\t\tcount = gf_list_count(cfg->sample_descriptions);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_TextSampleDescriptor *sd= (GF_TextSampleDescriptor *)gf_list_get(cfg->sample_descriptions, i);\n\t\t\tif (!sd->font_count) {\n\t\t\t\tsd->fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\t\t\tsd->font_count = 1;\n\t\t\t\tsd->fonts[0].fontID = 1;\n\t\t\t\tsd->fonts[0].fontName = gf_strdup(\"Serif\");\n\t\t\t}\n\t\t\tif (!sd->default_style.fontID) sd->default_style.fontID = sd->fonts[0].fontID;\n\t\t\tif (!sd->default_style.font_size) sd->default_style.font_size = 16;\n\t\t\tif (!sd->default_style.text_color) sd->default_style.text_color = 0xFF000000;\n\t\t\t/*store attribs*/\n\t\t\tif (!i) rec = sd->default_style;\n\n\t\t\tgf_isom_new_text_description(import->dest, track, sd, NULL, NULL, &state);\n\t\t\tif (!firstFont) firstFont = sd->fonts[0].fontName;\n\t\t}\n\t\tgf_import_message(import, GF_OK, \"Timed Text (SRT) import - text track %d x %d, font %s (size %d)\", cfg->text_width, cfg->text_height, firstFont, rec.font_size);\n\n\t\tgf_odf_desc_del((GF_Descriptor *)cfg);\n\t} else {\n\t\tu32 w, h;\n\t\tGF_TextSampleDescriptor *sd;\n\t\tgf_text_get_video_size(import, &w, &h);\n\n\t\t/*have to work with default - use max size (if only one video, this means the text region is the\n\t\tentire display, and with bottom alignment things should be fine...*/\n\t\tgf_isom_set_track_layout_info(import->dest, track, w<<16, h<<16, 0, 0, 0);\n\t\tsd = (GF_TextSampleDescriptor*)gf_odf_desc_new(GF_ODF_TX3G_TAG);\n\t\tsd->fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\tsd->font_count = 1;\n\t\tsd->fonts[0].fontID = 1;\n\t\tsd->fonts[0].fontName = gf_strdup(import->fontName ? import->fontName : \"Serif\");\n\t\tsd->back_color = 0x00000000;\t/*transparent*/\n\t\tsd->default_style.fontID = 1;\n\t\tsd->default_style.font_size = import->fontSize ? import->fontSize : TTXT_DEFAULT_FONT_SIZE;\n\t\tsd->default_style.text_color = 0xFFFFFFFF;\t/*white*/\n\t\tsd->default_style.style_flags = 0;\n\t\tsd->horiz_justif = 1; /*center of scene*/\n\t\tsd->vert_justif = (s8) -1;\t/*bottom of scene*/\n\n\t\tif (import->flags & GF_IMPORT_SKIP_TXT_BOX) {\n\t\t\tsd->default_pos.top = sd->default_pos.left = sd->default_pos.right = sd->default_pos.bottom = 0;\n\t\t} else {\n\t\t\tif ((sd->default_pos.bottom==sd->default_pos.top) || (sd->default_pos.right==sd->default_pos.left)) {\n\t\t\t\tsd->default_pos.left = import->text_x;\n\t\t\t\tsd->default_pos.top = import->text_y;\n\t\t\t\tsd->default_pos.right = (import->text_width ? import->text_width : w) + sd->default_pos.left;\n\t\t\t\tsd->default_pos.bottom = (import->text_height ? import->text_height : h) + sd->default_pos.top;\n\t\t\t}\n\t\t}\n\n\t\t/*store attribs*/\n\t\trec = sd->default_style;\n\t\tgf_isom_new_text_description(import->dest, track, sd, NULL, NULL, &state);\n\n\t\tgf_import_message(import, GF_OK, \"Timed Text (SRT) import - text track %d x %d, font %s (size %d)\", w, h, sd->fonts[0].fontName, rec.font_size);\n\t\tgf_odf_desc_del((GF_Descriptor *)sd);\n\t}\n\tgf_text_import_set_language(import, track);\n\tduration = (u32) (((Double) import->duration)*timescale/1000.0);\n\n\tdefault_color = rec.text_color;\n\n\te = GF_OK;\n\tstate = 0;\n\tend = prev_end = 0;\n\tcurLine = 0;\n\ttxt_line = 0;\n\tset_start_char = set_end_char = GF_FALSE;\n\tchar_len = 0;\n\tstart = 0;\n\tnb_samp = 0;\n\tsamp = gf_isom_new_text_sample();\n\n\tfirst_samp = GF_TRUE;\n\twhile (1) {\n\t\tchar *sOK = gf_text_get_utf8_line(szLine, 2048, srt_in, unicode_type);\n\n\t\tif (sOK) REM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\t\t\tif (!sOK || !strlen(szLine)) {\n\t\t\t\trec.style_flags = 0;\n\t\t\t\trec.startCharOffset = rec.endCharOffset = 0;\n\t\t\t\tif (txt_line) {\n\t\t\t\t\tif (prev_end && (start != prev_end)) {\n\t\t\t\t\t\tGF_TextSample * empty_samp = gf_isom_new_text_sample();\n\t\t\t\t\t\ts = gf_isom_text_to_sample(empty_samp);\n\t\t\t\t\t\tgf_isom_delete_text_sample(empty_samp);\n\t\t\t\t\t\tif (state<=2) {\n\t\t\t\t\t\t\ts->DTS = (u64) ((timescale*prev_end)/1000);\n\t\t\t\t\t\t\ts->IsRAP = RAP;\n\t\t\t\t\t\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\t\t\t\t\t\tnb_samp++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_sample_del(&s);\n\t\t\t\t\t}\n\n\t\t\t\t\ts = gf_isom_text_to_sample(samp);\n\t\t\t\t\tif (state<=2) {\n\t\t\t\t\t\ts->DTS = (u64) ((timescale*start)/1000);\n\t\t\t\t\t\ts->IsRAP = RAP;\n\t\t\t\t\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\t\t\t\t\tgf_isom_sample_del(&s);\n\t\t\t\t\t\tnb_samp++;\n\t\t\t\t\t\tprev_end = end;\n\t\t\t\t\t}\n\t\t\t\t\ttxt_line = 0;\n\t\t\t\t\tchar_len = 0;\n\t\t\t\t\tset_start_char = set_end_char = GF_FALSE;\n\t\t\t\t\trec.startCharOffset = rec.endCharOffset = 0;\n\t\t\t\t\tgf_isom_text_reset(samp);\n\n\t\t\t\t\t//gf_import_progress(import, nb_samp, nb_samp+1);\n\t\t\t\t\tgf_set_progress(\"Importing SRT\", gf_ftell(srt_in), file_size);\n\t\t\t\t\tif (duration && (end >= duration)) break;\n\t\t\t\t}\n\t\t\t\tstate = 0;\n\t\t\t\tif (!sOK) break;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\tswitch (state) {\n\t\tcase 0:\n\t\t\tif (sscanf(szLine, \"%u\", &line) != 1) {\n\t\t\t\te = gf_import_message(import, GF_CORRUPTED_DATA, \"Bad SRT formatting - expecting number got \\\"%s\\\"\", szLine);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tif (line != curLine + 1) gf_import_message(import, GF_OK, \"WARNING: corrupted SRT frame %d after frame %d\", line, curLine);\n\t\t\tcurLine = line;\n\t\t\tstate = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (sscanf(szLine, \"%u:%u:%u,%u --> %u:%u:%u,%u\", &sh, &sm, &ss, &sms, &eh, &em, &es, &ems) != 8) {\n\t\t\t\tsh = eh = 0;\n\t\t\t\tif (sscanf(szLine, \"%u:%u,%u --> %u:%u,%u\", &sm, &ss, &sms, &em, &es, &ems) != 6) {\n\t\t\t\t\te = gf_import_message(import, GF_CORRUPTED_DATA, \"Error scanning SRT frame %d timing\", curLine);\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstart = (3600*sh + 60*sm + ss)*1000 + sms;\n\t\t\tif (start<end) {\n\t\t\t\tgf_import_message(import, GF_OK, \"WARNING: overlapping SRT frame %d - starts \"LLD\" ms is before end of previous one \"LLD\" ms - adjusting time stamps\", curLine, start, end);\n\t\t\t\tstart = end;\n\t\t\t}\n\n\t\t\tend = (3600*eh + 60*em + es)*1000 + ems;\n\t\t\t/*make stream start at 0 by inserting a fake AU*/\n\t\t\tif (first_samp && (start>0)) {\n\t\t\t\ts = gf_isom_text_to_sample(samp);\n\t\t\t\ts->DTS = 0;\n\t\t\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\t\t\tgf_isom_sample_del(&s);\n\t\t\t\tnb_samp++;\n\t\t\t}\n\t\t\trec.style_flags = 0;\n\t\t\tstate = 2;\n\t\t\tif (end<=prev_end) {\n\t\t\t\tgf_import_message(import, GF_OK, \"WARNING: overlapping SRT frame %d end \"LLD\" is at or before previous end \"LLD\" - removing\", curLine, end, prev_end);\n\t\t\t\tstart = end;\n\t\t\t\tstate = 3;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/*reset only when text is present*/\n\t\t\tfirst_samp = GF_FALSE;\n\n\t\t\t/*go to line*/\n\t\t\tif (txt_line) {\n\t\t\t\tgf_isom_text_add_text(samp, \"\\n\", 1);\n\t\t\t\tchar_len += 1;\n\t\t\t}\n\n\t\t\tptr = (char *) szLine;\n\t\t\t{\n\t\t\t\tsize_t _len = gf_utf8_mbstowcs(uniLine, 5000, (const char **) &ptr);\n\t\t\t\tif (_len == (size_t) -1) {\n\t\t\t\t\te = gf_import_message(import, GF_CORRUPTED_DATA, \"Invalid UTF data (line %d)\", curLine);\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tlen = (u32) _len;\n\t\t\t}\n\t\t\ti=j=0;\n\t\t\trem_styles = 0;\n\t\t\trem_color = 0;\n\t\t\twhile (i<len) {\n\t\t\t\tu32 font_style = 0;\n\t\t\t\tu32 style_nb_chars = 0;\n\t\t\t\tu32 style_def_type = 0;\n\n\t\t\t\tif ( (uniLine[i]=='<') && (uniLine[i+2]=='>')) {\n\t\t\t\t\tstyle_nb_chars = 3;\n\t\t\t\t\tstyle_def_type = 1;\n\t\t\t\t}\n\t\t\t\telse if ( (uniLine[i]=='<') && (uniLine[i+1]=='/') && (uniLine[i+3]=='>')) {\n\t\t\t\t\tstyle_def_type = 2;\n\t\t\t\t\tstyle_nb_chars = 4;\n\t\t\t\t}\n\t\t\t\telse if (uniLine[i]=='<')  {\n\t\t\t\t\tconst unsigned short* src = uniLine + i;\n\t\t\t\t\tsize_t alen = gf_utf8_wcstombs(szLine, 2048, (const unsigned short**) & src);\n\t\t\t\t\tszLine[alen] = 0;\n\t\t\t\t\tstrlwr(szLine);\n\t\t\t\t\tif (!strncmp(szLine, \"<font \", 6) ) {\n\t\t\t\t\t\tchar *a_sep = strstr(szLine, \"color\");\n\t\t\t\t\t\tif (a_sep) a_sep = strchr(a_sep, '\"');\n\t\t\t\t\t\tif (a_sep) {\n\t\t\t\t\t\t\tchar *e_sep = strchr(a_sep+1, '\"');\n\t\t\t\t\t\t\tif (e_sep) {\n\t\t\t\t\t\t\t\te_sep[0] = 0;\n\t\t\t\t\t\t\t\tfont_style = gf_color_parse(a_sep+1);\n\t\t\t\t\t\t\t\te_sep[0] = '\"';\n\t\t\t\t\t\t\t\te_sep = strchr(e_sep+1, '>');\n\t\t\t\t\t\t\t\tif (e_sep) {\n\t\t\t\t\t\t\t\t\tstyle_nb_chars = (u32) (1 + e_sep - szLine);\n\t\t\t\t\t\t\t\t\tstyle_def_type = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strncmp(szLine, \"</font>\", 7) ) {\n\t\t\t\t\t\tstyle_nb_chars = 7;\n\t\t\t\t\t\tstyle_def_type = 2;\n\t\t\t\t\t\tfont_style = 0xFFFFFFFF;\n\t\t\t\t\t}\n\t\t\t\t\t//skip unknown\n\t\t\t\t\telse {\n\t\t\t\t\t\tchar *a_sep = strstr(szLine, \">\");\n\t\t\t\t\t\tif (a_sep) {\n\t\t\t\t\t\t\tstyle_nb_chars = (u32) (a_sep - szLine);\n\t\t\t\t\t\t\ti += style_nb_chars;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t/*start of new style*/\n\t\t\t\tif (style_def_type==1)  {\n\t\t\t\t\t/*store prev style*/\n\t\t\t\t\tif (set_end_char) {\n\t\t\t\t\t\tassert(set_start_char);\n\t\t\t\t\t\tgf_isom_text_add_style(samp, &rec);\n\t\t\t\t\t\tset_end_char = set_start_char = GF_FALSE;\n\t\t\t\t\t\trec.style_flags &= ~rem_styles;\n\t\t\t\t\t\trem_styles = 0;\n\t\t\t\t\t\tif (rem_color) {\n\t\t\t\t\t\t\trec.text_color = default_color;\n\t\t\t\t\t\t\trem_color = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (set_start_char && (rec.startCharOffset != j)) {\n\t\t\t\t\t\trec.endCharOffset = char_len + j;\n\t\t\t\t\t\tif (rec.style_flags) gf_isom_text_add_style(samp, &rec);\n\t\t\t\t\t}\n\t\t\t\t\tswitch (uniLine[i+1]) {\n\t\t\t\t\tcase 'b':\n\t\t\t\t\tcase 'B':\n\t\t\t\t\t\trec.style_flags |= GF_TXT_STYLE_BOLD;\n\t\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\t\trec.startCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'i':\n\t\t\t\t\tcase 'I':\n\t\t\t\t\t\trec.style_flags |= GF_TXT_STYLE_ITALIC;\n\t\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\t\trec.startCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\tcase 'U':\n\t\t\t\t\t\trec.style_flags |= GF_TXT_STYLE_UNDERLINED;\n\t\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\t\trec.startCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'f':\n\t\t\t\t\tcase 'F':\n\t\t\t\t\t\tif (font_style) {\n\t\t\t\t\t\t\trec.text_color = font_style;\n\t\t\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\t\t\trec.startCharOffset = char_len + j;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ti += style_nb_chars;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/*end of prev style*/\n\t\t\t\tif (style_def_type==2)  {\n\t\t\t\t\tswitch (uniLine[i+2]) {\n\t\t\t\t\tcase 'b':\n\t\t\t\t\tcase 'B':\n\t\t\t\t\t\trem_styles |= GF_TXT_STYLE_BOLD;\n\t\t\t\t\t\tset_end_char = GF_TRUE;\n\t\t\t\t\t\trec.endCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'i':\n\t\t\t\t\tcase 'I':\n\t\t\t\t\t\trem_styles |= GF_TXT_STYLE_ITALIC;\n\t\t\t\t\t\tset_end_char = GF_TRUE;\n\t\t\t\t\t\trec.endCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\tcase 'U':\n\t\t\t\t\t\trem_styles |= GF_TXT_STYLE_UNDERLINED;\n\t\t\t\t\t\tset_end_char = GF_TRUE;\n\t\t\t\t\t\trec.endCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'f':\n\t\t\t\t\tcase 'F':\n\t\t\t\t\t\tif (font_style) {\n\t\t\t\t\t\t\trem_color = 1;\n\t\t\t\t\t\t\tset_end_char = GF_TRUE;\n\t\t\t\t\t\t\trec.endCharOffset = char_len + j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti+=style_nb_chars;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*store style*/\n\t\t\t\tif (set_end_char) {\n\t\t\t\t\tgf_isom_text_add_style(samp, &rec);\n\t\t\t\t\tset_end_char = GF_FALSE;\n\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\trec.startCharOffset = char_len + j;\n\t\t\t\t\trec.style_flags &= ~rem_styles;\n\t\t\t\t\trem_styles = 0;\n\t\t\t\t\trec.text_color = default_color;\n\t\t\t\t\trem_color = 0;\n\t\t\t\t}\n\n\t\t\t\tuniText[j] = uniLine[i];\n\t\t\t\tj++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t/*store last style*/\n\t\t\tif (set_end_char) {\n\t\t\t\tgf_isom_text_add_style(samp, &rec);\n\t\t\t\tset_end_char = GF_FALSE;\n\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\trec.startCharOffset = char_len + j;\n\t\t\t\trec.style_flags &= ~rem_styles;\n\t\t\t}\n\n\t\t\tchar_line = j;\n\t\t\tuniText[j] = 0;\n\n\t\t\tsptr = (u16 *) uniText;\n\t\t\tlen = (u32) gf_utf8_wcstombs(szText, 5000, (const u16 **) &sptr);\n\n\t\t\tgf_isom_text_add_text(samp, szText, len);\n\t\t\tchar_len += char_line;\n\t\t\ttxt_line ++;\n\t\t\tbreak;\n\t\t}\n\t\tif (duration && (start >= duration)) {\n\t\t\tend = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*final flush*/\t\n\tif (end && !(import->flags & GF_IMPORT_NO_TEXT_FLUSH ) ) {\n\t\tgf_isom_text_reset(samp);\n\t\ts = gf_isom_text_to_sample(samp);\n\t\ts->DTS = (u64) ((timescale*end)/1000);\n\t\ts->IsRAP = RAP;\n\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\tgf_isom_sample_del(&s);\n\t\tnb_samp++;\n\t\tgf_isom_set_last_sample_duration(import->dest, track, 0);\n\t} else {\n\t\tif (duration && (start >= duration)) {\n\t\t\tgf_isom_set_last_sample_duration(import->dest, track, (timescale*duration)/1000);\n\t\t} else {\n\t\t\tgf_isom_set_last_sample_duration(import->dest, track, 0);\n\t\t}\n\t}\n\tgf_isom_delete_text_sample(samp);\n\tgf_set_progress(\"Importing SRT\", nb_samp, nb_samp);\n\nexit:\n\tif (e) gf_isom_remove_track(import->dest, track);\n\tgf_fclose(srt_in);\n\treturn e;\n}\n\n/* Structure used to pass importer and track data to the parsers without exposing the GF_MediaImporter structure\n   used by WebVTT and Flash->SVG */\ntypedef struct {\n\tGF_MediaImporter *import;\n\tu32 timescale;\n\tu32 track;\n\tu32 descriptionIndex;\n} GF_ISOFlusher;\n\n#ifndef GPAC_DISABLE_VTT\n\nstatic GF_Err gf_webvtt_import_report(void *user, GF_Err e, char *message, const char *line)\n{\n\tGF_ISOFlusher     *flusher = (GF_ISOFlusher *)user;\n\treturn gf_import_message(flusher->import, e, message, line);\n}\n\nstatic void gf_webvtt_import_header(void *user, const char *config)\n{\n\tGF_ISOFlusher     *flusher = (GF_ISOFlusher *)user;\n\tgf_isom_update_webvtt_description(flusher->import->dest, flusher->track, flusher->descriptionIndex, config);\n}\n\nstatic void gf_webvtt_flush_sample_to_iso(void *user, GF_WebVTTSample *samp)\n{\n\tGF_ISOSample            *s;\n\tGF_ISOFlusher     *flusher = (GF_ISOFlusher *)user;\n\t//gf_webvtt_dump_sample(stdout, samp);\n\ts = gf_isom_webvtt_to_sample(samp);\n\tif (s) {\n\t\ts->DTS = (u64) (flusher->timescale*gf_webvtt_sample_get_start(samp)/1000);\n\t\ts->IsRAP = RAP;\n\t\tgf_isom_add_sample(flusher->import->dest, flusher->track, flusher->descriptionIndex, s);\n\t\tgf_isom_sample_del(&s);\n\t}\n\tgf_webvtt_sample_del(samp);\n}\n\nstatic GF_Err gf_text_import_webvtt(GF_MediaImporter *import)\n{\n\tGF_Err\t\t\t\t\t\te;\n\tu32\t\t\t\t\t\t\ttrack;\n\tu32\t\t\t\t\t\t\ttimescale;\n\tu32\t\t\t\t\t\t\tduration;\n\tu32\t\t\t\t\t\t\tdescIndex=1;\n\tu32\t\t\t\t\t\t\tID;\n\tu32\t\t\t\t\t\t\tOCR_ES_ID;\n\tGF_GenericSubtitleConfig\t*cfg;\n\tGF_WebVTTParser\t\t\t\t*vttparser;\n\tGF_ISOFlusher\t\t\t\tflusher;\n\n\tcfg\t= NULL;\n\tif (import->esd) {\n\t\tif (!import->esd->slConfig)\t{\n\t\t\timport->esd->slConfig =\t(GF_SLConfig *)\tgf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\t\timport->esd->slConfig->predefined =\t2;\n\t\t\timport->esd->slConfig->timestampResolution = 1000;\n\t\t}\n\t\ttimescale =\timport->esd->slConfig->timestampResolution;\n\t\tif (!timescale)\ttimescale =\t1000;\n\n\t\t/*explicit text\tconfig*/\n\t\tif (import->esd->decoderConfig && import->esd->decoderConfig->decoderSpecificInfo->tag == GF_ODF_GEN_SUB_CFG_TAG) {\n\t\t\tcfg\t= (GF_GenericSubtitleConfig\t*) import->esd->decoderConfig->decoderSpecificInfo;\n\t\t\timport->esd->decoderConfig->decoderSpecificInfo\t= NULL;\n\t\t}\n\t\tID = import->esd->ESID;\n\t\tOCR_ES_ID =\timport->esd->OCRESID;\n\t} else {\n\t\ttimescale =\t1000;\n\t\tOCR_ES_ID =\tID = 0;\n\t}\n\n\tif (cfg\t&& cfg->timescale) timescale = cfg->timescale;\n\ttrack =\tgf_isom_new_track(import->dest,\tID,\tGF_ISOM_MEDIA_TEXT,\ttimescale);\n\tif (!track)\t{\n\t\treturn gf_import_message(import, gf_isom_last_error(import->dest), \"Error creating WebVTT track\");\n\t}\n\tgf_isom_set_track_enabled(import->dest, track, 1);\n\timport->final_trackID = gf_isom_get_track_id(import->dest, track);\n\tif (import->esd && !import->esd->ESID) import->esd->ESID = import->final_trackID;\n\n\tif (OCR_ES_ID) gf_isom_set_track_reference(import->dest, track,\tGF_ISOM_REF_OCR, OCR_ES_ID);\n\n\t/*setup\ttrack*/\n\tif (cfg) {\n\t\tu32\ti;\n\t\tu32\tcount;\n\t\t/*set track\tinfo*/\n\t\tgf_isom_set_track_layout_info(import->dest,\ttrack, cfg->text_width<<16,\tcfg->text_height<<16, 0, 0,\tcfg->layer);\n\n\t\t/*and set sample descriptions*/\n\t\tcount =\tgf_list_count(cfg->sample_descriptions);\n\t\tfor\t(i=0; i<count; i++)\t{\n\t\t\tgf_isom_new_webvtt_description(import->dest, track, NULL, NULL, NULL, &descIndex);\n\t\t}\n\t\tgf_import_message(import, GF_OK, \"WebVTT import\t- text track %d\tx %d\", cfg->text_width,\tcfg->text_height);\n\t\tgf_odf_desc_del((GF_Descriptor *)cfg);\n\t} else {\n\t\tu32\tw;\n\t\tu32\th;\n\n\t\tgf_text_get_video_size(import, &w, &h);\n\t\tgf_isom_set_track_layout_info(import->dest,\ttrack, w<<16, h<<16, 0,\t0, 0);\n\n\t\tgf_isom_new_webvtt_description(import->dest, track,\tNULL, NULL,\tNULL, &descIndex);\n\n\t\tgf_import_message(import, GF_OK, \"WebVTT import\");\n\t}\n\tgf_text_import_set_language(import, track);\n\tduration = (u32) (((Double) import->duration)*timescale/1000.0);\n\n\tvttparser = gf_webvtt_parser_new();\n\tflusher.import = import;\n\tflusher.timescale = timescale;\n\tflusher.track = track;\n\tflusher.descriptionIndex = descIndex;\n\te = gf_webvtt_parser_init(vttparser, import->in_name, &flusher, gf_webvtt_import_report, gf_webvtt_flush_sample_to_iso, gf_webvtt_import_header);\n\tif (e != GF_OK) {\n\t\tgf_webvtt_parser_del(vttparser);\n\t\treturn gf_import_message(import, GF_NOT_SUPPORTED, \"Unsupported WebVTT UTF encoding\");\n\t}\n\te = gf_webvtt_parser_parse(vttparser, duration);\n\tif (e != GF_OK) {\n\t\tgf_isom_remove_track(import->dest, track);\n\t}\n\n\t/*do not add any empty sample at the end since it modifies track duration and is not needed - it is the player job\n\tto figure out when to stop displaying the last text sample\n\tHowever update the last sample duration*/\n\tgf_isom_set_last_sample_duration(import->dest, track, (u32) gf_webvtt_parser_last_duration(vttparser));\n\t\n\tgf_webvtt_parser_del(vttparser);\n\treturn e;\n}\n\n#endif /*GPAC_DISABLE_VTT*/\n\nstatic char *ttxt_parse_string(GF_MediaImporter *import, char *str, Bool strip_lines)\n{\n\tu32 i=0;\n\tu32 k=0;\n\tu32 len = (u32) strlen(str);\n\tu32 state = 0;\n\n\tif (!strip_lines) {\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif ((str[i] == '\\r') && (str[i+1] == '\\n')) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tstr[k] = str[i];\n\t\t\tk++;\n\t\t}\n\t\tstr[k]=0;\n\t\treturn str;\n\t}\n\n\tif (str[0]!='\\'') return str;\n\tfor (i=0; i<len; i++) {\n\t\tif (str[i] == '\\'') {\n\n\t\t\tif (!state) {\n\t\t\t\tif (k) {\n\t\t\t\t\tstr[k]='\\n';\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\tstate = !state;\n\t\t\t} else if (state) {\n\t\t\t\tif ( (i+1==len) ||\n\t\t\t\t        ((str[i+1]==' ') || (str[i+1]=='\\n') || (str[i+1]=='\\r') || (str[i+1]=='\\t') || (str[i+1]=='\\''))\n\t\t\t\t   ) {\n\t\t\t\t\tstate = !state;\n\t\t\t\t} else {\n\t\t\t\t\tstr[k] = str[i];\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (state) {\n\t\t\tstr[k] = str[i];\n\t\t\tk++;\n\t\t}\n\t}\n\tstr[k]=0;\n\treturn str;\n}\n\nstatic void ttml_import_progress(void *cbk, u64 cur_samp, u64 count)\n{\n\tgf_set_progress(\"TTML Loading\", cur_samp, count);\n}\n\nstatic void gf_text_import_ebu_ttd_remove_samples(GF_XMLNode *root, GF_XMLNode **sample_list_node)\n{\n\tu32 idx = 0, body_num = 0;\n\tGF_XMLNode *node = NULL;\n\t*sample_list_node = NULL;\n\twhile ( (node = (GF_XMLNode*)gf_list_enum(root->content, &idx))) {\n\t\tif (!strcmp(node->name, \"body\")) {\n\t\t\tGF_XMLNode *body_node;\n\t\t\tu32 body_idx = 0;\n\t\t\twhile ( (body_node = (GF_XMLNode*)gf_list_enum(node->content, &body_idx))) {\n\t\t\t\tif (!strcmp(body_node->name, \"div\")) {\n\t\t\t\t\t*sample_list_node = body_node;\n\t\t\t\t\tbody_num = gf_list_count(body_node->content);\n\t\t\t\t\twhile (body_num--) {\n\t\t\t\t\t\tGF_XMLNode *content_node = (GF_XMLNode*)gf_list_get(body_node->content, 0);\n\t\t\t\t\t\tassert(gf_list_find(body_node->content, content_node) == 0);\n\t\t\t\t\t\tgf_list_rem(body_node->content, 0);\n\t\t\t\t\t\tgf_xml_dom_node_del(content_node);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n#define TTML_NAMESPACE \"http://www.w3.org/ns/ttml\"\nstatic GF_Err gf_text_import_ebu_ttd(GF_MediaImporter *import, GF_DOMParser *parser, GF_XMLNode *root)\n{\n\tGF_Err e, e_opt;\n\tu32 i, track, ID, desc_idx, nb_samples, nb_children;\n\tu64 last_sample_duration, last_sample_end;\n\tGF_XMLAttribute *att;\n\tGF_XMLNode *node, *root_working_copy, *sample_list_node;\n\tGF_DOMParser *parser_working_copy;\n\tchar *samp_text;\n\tBool has_body;\n\n\tsamp_text = NULL;\n\troot_working_copy = NULL;\n\tparser_working_copy = NULL;\n\n\t/*setup track in 3GP format directly (no ES desc)*/\n\tID = (import->esd) ? import->esd->ESID : 0;\n\ttrack = gf_isom_new_track(import->dest, ID, GF_ISOM_MEDIA_MPEG_SUBT, 1000);\n\tif (!track) {\n\t\te = gf_isom_last_error(import->dest);\n\t\tgoto exit;\n\t}\n\tgf_isom_set_track_enabled(import->dest, track, 1);\n\n\t/*some MPEG-4 setup*/\n\tif (import->esd) {\n\t\tif (!import->esd->ESID) import->esd->ESID = gf_isom_get_track_id(import->dest, track);\n\t\tif (!import->esd->decoderConfig) import->esd->decoderConfig = (GF_DecoderConfig *) gf_odf_desc_new(GF_ODF_DCD_TAG);\n\t\tif (!import->esd->slConfig) import->esd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\timport->esd->slConfig->timestampResolution = 1000;\n\t\timport->esd->decoderConfig->streamType = GF_STREAM_TEXT;\n\t\timport->esd->decoderConfig->objectTypeIndication = GPAC_OTI_TEXT_MPEG4;\n\t\tif (import->esd->OCRESID) gf_isom_set_track_reference(import->dest, track, GF_ISOM_REF_OCR, import->esd->OCRESID);\n\t}\n\n\tgf_import_message(import, GF_OK, \"TTML EBU-TTD Import\");\n\n\t/*** root (including language) ***/\n\ti=0;\n\twhile ( (att = (GF_XMLAttribute *)gf_list_enum(root->attributes, &i))) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"Found root attribute name %s, value %s\\n\", att->name, att->value));\n\n\t\tif (!strcmp(att->name, \"xmlns\")) {\n\t\t\tif (strcmp(att->value, TTML_NAMESPACE)) {\n\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"Found invalid EBU-TTD root attribute name %s, value %s (shall be \\\"%s\\\")\\n\", att->name, att->value, TTML_NAMESPACE);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else if (!strcmp(att->name, \"xml:lang\")) {\n\t\t\tif (import->esd && !import->esd->langDesc) {\n\t\t\t\tchar *lang;\n\t\t\t\tlang = gf_strdup(att->value);\n\t\t\t\timport->esd->langDesc = (GF_Language *) gf_odf_desc_new(GF_ODF_LANG_TAG);\n\t\t\t\tgf_isom_set_media_language(import->dest, track, lang);\n\t\t\t} else {\n\t\t\t\tgf_isom_set_media_language(import->dest, track, att->value);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*** style ***/\n#if 0\n\t{\n\t\tBool has_styling, has_style;\n\t\tGF_TextSampleDescriptor *sd;\n\t\thas_styling = GF_FALSE;\n\t\thas_style = GF_FALSE;\n\t\tsd = (GF_TextSampleDescriptor*)gf_odf_desc_new(GF_ODF_TX3G_TAG);\n\t\ti=0;\n\t\twhile ( (node = (GF_XMLNode*)gf_list_enum(root->content, &i))) {\n\t\t\tif (node->type) {\n\t\t\t\tcontinue;\n\t\t\t} else if (gf_xml_get_element_check_namespace(node, \"head\", root->ns) == GF_OK) {\n\t\t\t\tGF_XMLNode *head_node;\n\t\t\t\tu32 head_idx = 0;\n\t\t\t\twhile ( (head_node = (GF_XMLNode*)gf_list_enum(node->content, &head_idx))) {\n\t\t\t\t\tif (gf_xml_get_element_check_namespace(head_node, \"styling\", root->ns) == GF_OK) {\n\t\t\t\t\t\tGF_XMLNode *styling_node;\n\t\t\t\t\t\tu32 styling_idx;\n\t\t\t\t\t\tif (has_styling) {\n\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML EBU-TTD] duplicated \\\"styling\\\" element. Abort.\\n\");\n\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\thas_styling = GF_TRUE;\n\n\t\t\t\t\t\tstyling_idx = 0;\n\t\t\t\t\t\twhile ( (styling_node = (GF_XMLNode*)gf_list_enum(head_node->content, &styling_idx))) {\n\t\t\t\t\t\t\tif (gf_xml_get_element_check_namespace(styling_node, \"style\", root->ns) == GF_OK) {\n\t\t\t\t\t\t\t\tGF_XMLAttribute *p_att;\n\t\t\t\t\t\t\t\tu32 style_idx = 0;\n\t\t\t\t\t\t\t\twhile ( (p_att = (GF_XMLAttribute*)gf_list_enum(styling_node->attributes, &style_idx))) {\n\t\t\t\t\t\t\t\t\tif (!strcmp(p_att->name, \"tts:direction\")) {\n\t\t\t\t\t\t\t\t\t} else if (!strcmp(p_att->name, \"tts:fontFamily\")) {\n\t\t\t\t\t\t\t\t\t\tsd->fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\t\t\t\t\t\t\t\t\tsd->font_count = 1;\n\t\t\t\t\t\t\t\t\t\tsd->fonts[0].fontID = 1;\n\t\t\t\t\t\t\t\t\t\tsd->fonts[0].fontName = gf_strdup(p_att->value);\n\t\t\t\t\t\t\t\t\t} else if (!strcmp(p_att->name, \"tts:backgroundColor\")) {\n\t\t\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"EBU-TTD style attribute \\\"%s\\\" ignored.\\n\", p_att->name));\n\t\t\t\t\t\t\t\t\t\t//sd->back_color = ;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tif ( !strcmp(p_att->name, \"tts:fontSize\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:lineHeight\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:textAlign\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:color\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:fontStyle\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:fontWeight\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:textDecoration\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:unicodeBidi\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:wrapOption\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:multiRowAlign\")\n\t\t\t\t\t\t\t\t\t\t        || !strcmp(p_att->name, \"tts:linePadding\")) {\n\t\t\t\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"EBU-TTD style attribute \\\"%s\\\" ignored.\\n\", p_att->name));\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"EBU-TTD unknown style attribute: \\\"%s\\\". Ignoring.\\n\", p_att->name));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak; //TODO: we only take care of the first style\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!has_styling) {\n\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML EBU-TTD] missing \\\"styling\\\" element. Abort.\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\tif (!has_style) {\n\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML EBU-TTD] missing \\\"style\\\" element. Abort.\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\te = gf_isom_new_text_description(import->dest, track, sd, NULL, NULL, &desc_idx);\n\t\tgf_odf_desc_del((GF_Descriptor*)sd);\n\t}\n#else\n\te = gf_isom_new_xml_subtitle_description(import->dest, track, TTML_NAMESPACE, NULL, NULL, &desc_idx);\n#endif\n\tif (e != GF_OK) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] incorrect sample description. Abort.\\n\"));\n\t\te = gf_isom_last_error(import->dest);\n\t\tgoto exit;\n\t}\n\n\t/*** body ***/\n\tparser_working_copy = gf_xml_dom_new();\n\te = gf_xml_dom_parse(parser_working_copy, import->in_name, NULL, NULL);\n\tassert (e == GF_OK);\n\troot_working_copy = gf_xml_dom_get_root(parser_working_copy);\n\tassert(root_working_copy);\n\tlast_sample_duration = 0;\n\tlast_sample_end = 0;\n\tnb_samples = 0;\n\tnb_children = gf_list_count(root->content);\n\thas_body = GF_FALSE;\n\ti=0;\n\twhile ( (node = (GF_XMLNode*)gf_list_enum(root->content, &i))) {\n\t\tif (node->type) {\n\t\t\tnb_children--;\n\t\t\tcontinue;\n\t\t}\n\n\t\te_opt = gf_xml_get_element_check_namespace(node, \"body\", root->ns);\n\t\tif (e_opt == GF_BAD_PARAM) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] ignored \\\"%s\\\" node, check your namespaces\\n\", node->name));\n\t\t} else if (e_opt == GF_OK) {\n\t\t\tGF_XMLNode *body_node;\n\t\t\tu32 body_idx = 0;\n\n\t\t\tif (has_body) {\n\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML EBU-TTD] duplicated \\\"body\\\" element. Abort.\\n\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\thas_body = GF_TRUE;\n\n\t\t\t/*remove all the entries from the working copy, we'll add samples one to one to create full XML samples*/\n\t\t\tgf_text_import_ebu_ttd_remove_samples(root_working_copy, &sample_list_node);\n\n\t\t\twhile ( (body_node = (GF_XMLNode*)gf_list_enum(node->content, &body_idx))) {\n\t\t\t\te_opt = gf_xml_get_element_check_namespace(body_node, \"div\", root->ns);\n\t\t\t\tif (e_opt == GF_BAD_PARAM) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] ignored \\\"%s\\\" node, check your namespaces\\n\", node->name));\n\t\t\t\t} else if (e_opt == GF_OK) {\n\t\t\t\t\tGF_XMLNode *div_node;\n\t\t\t\t\tu32 div_idx = 0, nb_p_found = 0;\n\t\t\t\t\twhile ( (div_node = (GF_XMLNode*)gf_list_enum(body_node->content, &div_idx))) {\n\t\t\t\t\t\te_opt = gf_xml_get_element_check_namespace(div_node, \"p\", root->ns);\n\t\t\t\t\t\tif (e_opt != GF_OK) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML] ignored \\\"%s\\\" node, check your namespaces\\n\", node->name));\n\t\t\t\t\t\t} else if (e_opt == GF_OK) {\n\t\t\t\t\t\t\tGF_XMLNode *p_node;\n\t\t\t\t\t\t\tGF_XMLAttribute *p_att;\n\t\t\t\t\t\t\tu32 p_idx = 0, h, m, s, f, ms;\n\t\t\t\t\t\t\ts64 ts_begin = -1, ts_end = -1;\n\n\t\t\t\t\t\t\t//sample is either in the <p> ...\n\t\t\t\t\t\t\twhile ( (p_att = (GF_XMLAttribute*)gf_list_enum(div_node->attributes, &p_idx))) {\n\t\t\t\t\t\t\t\tif (!p_att) continue;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (!strcmp(p_att->name, \"begin\")) {\n\t\t\t\t\t\t\t\t\tif (ts_begin != -1) {\n\t\t\t\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML] duplicated \\\"begin\\\" attribute. Abort.\\n\");\n\t\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (sscanf(p_att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\t\t\t\t\tts_begin = (h*3600 + m*60+s)*1000+ms;\n\t\t\t\t\t\t\t\t\t} else if (sscanf(p_att->value, \"%u:%u:%u:%u\", &h, &m, &s, &f) == 4) {\n\t\t\t\t\t\t\t\t\t\tts_begin = (h*3600 + m*60+s)*1000+f*40;\n\t\t\t\t\t\t\t\t\t} else if (sscanf(p_att->value, \"%u:%u:%u\", &h, &m, &s) == 3) {\n\t\t\t\t\t\t\t\t\t\tts_begin = (h*3600 + m*60+s)*1000;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (!strcmp(p_att->name, \"end\")) {\n\t\t\t\t\t\t\t\t\tif (ts_end != -1) {\n\t\t\t\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML] duplicated \\\"end\\\" attribute. Abort.\\n\");\n\t\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (sscanf(p_att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000+ms;\n\t\t\t\t\t\t\t\t\t} else if (sscanf(p_att->value, \"%u:%u:%u:%u\", &h, &m, &s, &f) == 4) {\n\t\t\t\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000+f*40;\n\t\t\t\t\t\t\t\t\t} else if (sscanf(p_att->value, \"%u:%u:%u\", &h, &m, &s) == 3) {\n\t\t\t\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ((ts_begin != -1) && (ts_end != -1) && !samp_text && sample_list_node) {\n\t\t\t\t\t\t\t\t\te = gf_xml_dom_append_child(sample_list_node, div_node);\n\t\t\t\t\t\t\t\t\tassert(e == GF_OK);\n\t\t\t\t\t\t\t\t\tassert(!samp_text);\n\t\t\t\t\t\t\t\t\tsamp_text = gf_xml_dom_serialize((GF_XMLNode*)root_working_copy, GF_FALSE);\n\t\t\t\t\t\t\t\t\te = gf_xml_dom_rem_child(sample_list_node, div_node);\n\t\t\t\t\t\t\t\t\tassert(e == GF_OK);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t//or under a <span>\n\t\t\t\t\t\t\tp_idx = 0;\n\t\t\t\t\t\t\twhile ( (p_node = (GF_XMLNode*)gf_list_enum(div_node->content, &p_idx))) {\n\t\t\t\t\t\t\t\te_opt = gf_xml_get_element_check_namespace(p_node, \"span\", root->ns);\n\t\t\t\t\t\t\t\tif (e_opt == GF_BAD_PARAM) {\n\t\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML] ignored \\\"%s\\\" node, check your namespaces\\n\", node->name));\n\t\t\t\t\t\t\t\t} else if (e_opt == GF_OK) {\n\t\t\t\t\t\t\t\t\tu32 span_idx = 0;\n\t\t\t\t\t\t\t\t\tGF_XMLAttribute *span_att;\n\t\t\t\t\t\t\t\t\twhile ( (span_att = (GF_XMLAttribute*)gf_list_enum(p_node->attributes, &span_idx))) {\n\t\t\t\t\t\t\t\t\t\tif (!span_att) continue;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tif (!strcmp(span_att->name, \"begin\")) {\n\t\t\t\t\t\t\t\t\t\t\tif (ts_begin != -1) {\n\t\t\t\t\t\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML] duplicated \\\"begin\\\" attribute under <span>. Abort.\\n\");\n\t\t\t\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif (sscanf(span_att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\t\t\t\t\t\t\tts_begin = (h*3600 + m*60+s)*1000+ms;\n\t\t\t\t\t\t\t\t\t\t\t} else if (sscanf(p_att->value, \"%u:%u:%u:%u\", &h, &m, &s, &f) == 4) {\n\t\t\t\t\t\t\t\t\t\t\t\tts_begin = (h*3600 + m*60+s)*1000+f*40;\n\t\t\t\t\t\t\t\t\t\t\t} else if (sscanf(span_att->value, \"%u:%u:%u\", &h, &m, &s) == 3) {\n\t\t\t\t\t\t\t\t\t\t\t\tts_begin = (h*3600 + m*60+s)*1000;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else if (!strcmp(span_att->name, \"end\")) {\n\t\t\t\t\t\t\t\t\t\t\tif (ts_end != -1) {\n\t\t\t\t\t\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML] duplicated \\\"end\\\" attribute under <span>. Abort.\\n\");\n\t\t\t\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif (sscanf(span_att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000+ms;\n\t\t\t\t\t\t\t\t\t\t\t} else if (sscanf(p_att->value, \"%u:%u:%u:%u\", &h, &m, &s, &f) == 4) {\n\t\t\t\t\t\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000+f*40;\n\t\t\t\t\t\t\t\t\t\t\t} else if (sscanf(span_att->value, \"%u:%u:%u\", &h, &m, &s) == 3) {\n\t\t\t\t\t\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif ((ts_begin != -1) && (ts_end != -1) && !samp_text && sample_list_node) {\n\t\t\t\t\t\t\t\t\t\t\tif (samp_text) {\n\t\t\t\t\t\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML] duplicated sample text under <span>. Abort.\\n\");\n\t\t\t\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t/*append the sample*/\n\t\t\t\t\t\t\t\t\t\t\te = gf_xml_dom_append_child(sample_list_node, div_node);\n\t\t\t\t\t\t\t\t\t\t\tassert(e == GF_OK);\n\t\t\t\t\t\t\t\t\t\t\tassert(!samp_text);\n\t\t\t\t\t\t\t\t\t\t\tsamp_text = gf_xml_dom_serialize((GF_XMLNode*)root_working_copy, GF_FALSE);\n\t\t\t\t\t\t\t\t\t\t\te = gf_xml_dom_rem_child(sample_list_node, div_node);\n\t\t\t\t\t\t\t\t\t\t\tassert(e == GF_OK);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ((ts_begin != -1) && (ts_end != -1) && samp_text) {\n\t\t\t\t\t\t\t\tGF_ISOSample *s;\n\t\t\t\t\t\t\t\tGF_GenericSubtitleSample *samp;\n\t\t\t\t\t\t\t\tu32 len;\n\t\t\t\t\t\t\t\tchar *str;\n\n\t\t\t\t\t\t\t\tif (ts_end < ts_begin) {\n\t\t\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML] invalid timings: \\\"begin\\\"=\"LLD\" , \\\"end\\\"=\"LLD\". Abort.\\n\", ts_begin, ts_end);\n\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (ts_begin < (s64)last_sample_end) {\n\t\t\t\t\t\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML] timing overlapping not supported: \\\"begin\\\" is \"LLD\" , last \\\"end\\\" was \"LLD\". Abort.\\n\", ts_begin, last_sample_end);\n\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tstr = ttxt_parse_string(import, samp_text, GF_TRUE);\n\t\t\t\t\t\t\t\tlen = (u32) strlen(str);\n\t\t\t\t\t\t\t\tsamp = gf_isom_new_xml_subtitle_sample();\n\t\t\t\t\t\t\t\t/*each sample consists of a full valid XML file*/\n\t\t\t\t\t\t\t\te = gf_isom_xml_subtitle_sample_add_text(samp, str, len);\n\t\t\t\t\t\t\t\tif (e) {\n\t\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML] ISOM - sample add text: %s\", gf_error_to_string(e)));\n\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tgf_free(samp_text);\n\t\t\t\t\t\t\t\tsamp_text = NULL;\n\n\t\t\t\t\t\t\t\ts = gf_isom_xml_subtitle_to_sample(samp);\n\t\t\t\t\t\t\t\tgf_isom_delete_xml_subtitle_sample(samp);\n\t\t\t\t\t\t\t\tif (!nb_samples) {\n\t\t\t\t\t\t\t\t\ts->DTS = 0; /*in MP4 we must start at T=0*/\n\t\t\t\t\t\t\t\t\tlast_sample_duration = ts_end;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts->DTS = ts_begin;\n\t\t\t\t\t\t\t\t\tlast_sample_duration = ts_end - ts_begin;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlast_sample_end = ts_end;\n\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"ts_begin=\"LLD\", ts_end=\"LLD\", last_sample_duration=\"LLU\" (real duration: \"LLU\"), last_sample_end=\"LLU\"\\n\", ts_begin, ts_end, ts_end - last_sample_end, last_sample_duration, last_sample_end));\n\n\t\t\t\t\t\t\t\te = gf_isom_add_sample(import->dest, track, desc_idx, s);\n\t\t\t\t\t\t\t\tif (e) {\n\t\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML] ISOM - Add Sample: %s\", gf_error_to_string(e)));\n\t\t\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tgf_isom_sample_del(&s);\n\t\t\t\t\t\t\t\tnb_samples++;\n\n\t\t\t\t\t\t\t\tnb_p_found++;\n\t\t\t\t\t\t\t\tgf_set_progress(\"Importing TTML\", nb_samples, nb_children);\n\t\t\t\t\t\t\t\tif (import->duration && (ts_end > import->duration))\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML] incomplete sample (begin=\"LLD\", end=\"LLD\", text=\\\"%s\\\"). Skip.\\n\", ts_begin, ts_end, samp_text ? samp_text : \"NULL\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!nb_p_found) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] \\\"%s\\\" div node has no <p> elements. Aborting.\\n\", node->name));\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!has_body) {\n\t\te = gf_import_message(import, GF_BAD_PARAM, \"[TTML EBU-TTD] missing \\\"body\\\" element. Abort.\\n\");\n\t\tgoto exit;\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"last_sample_duration=\"LLU\", last_sample_end=\"LLU\"\\n\", last_sample_duration, last_sample_end));\n\tgf_isom_set_last_sample_duration(import->dest, track, (u32) last_sample_duration);\n\tgf_media_update_bitrate(import->dest, track);\n\tgf_set_progress(\"Importing TTML EBU-TTD\", nb_samples, nb_samples);\n\nexit:\n\tgf_free(samp_text);\n\tgf_xml_dom_del(parser_working_copy);\n\tif (!gf_isom_get_sample_count(import->dest, track)) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] No sample imported. Might be an error. Check your content.\\n\"));\n\t}\n\treturn e;\n}\n\nstatic GF_Err gf_text_import_ttml(GF_MediaImporter *import)\n{\n\tGF_Err e;\n\tGF_DOMParser *parser;\n\tGF_XMLNode *root;\n\n\tif (import->flags == GF_IMPORT_PROBE_ONLY)\n\t\treturn GF_OK;\n\n\tparser = gf_xml_dom_new();\n\te = gf_xml_dom_parse(parser, import->in_name, ttml_import_progress, import);\n\tif (e) {\n\t\tgf_import_message(import, e, \"Error parsing TTML file: Line %d - %s. Abort.\", gf_xml_dom_get_line(parser), gf_xml_dom_get_error(parser));\n\t\tgf_xml_dom_del(parser);\n\t\treturn e;\n\t}\n\troot = gf_xml_dom_get_root(parser);\n\tif (!root) {\n\t\tgf_import_message(import, e, \"Error parsing TTML file: no \\\"root\\\" found. Abort.\");\n\t\tgf_xml_dom_del(parser);\n\t\treturn e;\n\t}\n\n\t/*look for TTML*/\n\tif (gf_xml_get_element_check_namespace(root, \"tt\", NULL) == GF_OK) {\n\t\te = gf_text_import_ebu_ttd(import, parser, root);\n\t\tif (e == GF_OK) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"Note: TTML import - EBU-TTD detected\\n\"));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"Parsing TTML file with error: %s\\n\", gf_error_to_string(e)));\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"Unsupported TTML file - only EBU-TTD is supported (root shall be \\\"tt\\\", got \\\"%s\\\")\\n\", root->name));\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"Importing as generic TTML\\n\"));\n\t\t\te = GF_OK;\n\t\t}\n\t} else {\n\t\tif (root->ns) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"TTML file not recognized: root element is \\\"%s:%s\\\" (check your namespaces)\\n\", root->ns, root->name));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"TTML file not recognized: root element is \\\"%s\\\"\\n\", root->name));\n\t\t}\n\t\te = GF_BAD_PARAM;\n\t}\n\n\tgf_xml_dom_del(parser);\n\treturn e;\n}\n\n/* SimpleText Text tracks -related functions */\nGF_Box *boxstring_new_with_data(u32 type, const char *string);\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\n/* SWF Importer */\n#include <gpac/internal/swf_dev.h>\n\nstatic GF_Err swf_svg_add_iso_sample(void *user, const char *data, u32 length, u64 timestamp, Bool isRap)\n{\n\tGF_Err\t\t\t\te = GF_OK;\n\tGF_ISOFlusher\t\t*flusher = (GF_ISOFlusher *)user;\n\tGF_ISOSample\t\t*s;\n\tGF_BitStream\t\t*bs;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (!bs) return GF_BAD_PARAM;\n\tgf_bs_write_data(bs, data, length);\n\ts = gf_isom_sample_new();\n\tif (s) {\n\t\tgf_bs_get_content(bs, &s->data, &s->dataLength);\n\t\ts->DTS = (u64) (flusher->timescale*timestamp/1000);\n\t\ts->IsRAP = isRap ? RAP : RAP_NO;\n\t\tgf_isom_add_sample(flusher->import->dest, flusher->track, flusher->descriptionIndex, s);\n\t\tgf_isom_sample_del(&s);\n\t} else {\n\t\te = GF_BAD_PARAM;\n\t}\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nstatic GF_Err swf_svg_add_iso_header(void *user, const char *data, u32 length, Bool isHeader)\n{\n\tGF_ISOFlusher\t\t*flusher = (GF_ISOFlusher *)user;\n\tif (!flusher) return GF_BAD_PARAM;\n\tif (isHeader) {\n\t\treturn gf_isom_update_stxt_description(flusher->import->dest, flusher->track, NULL, data, flusher->descriptionIndex);\n\t} else {\n\t\treturn gf_isom_append_sample_data(flusher->import->dest, flusher->track, (char *)data, length);\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_text_import_swf(GF_MediaImporter *import)\n{\n\tGF_Err\t\t\t\t\t\te = GF_OK;\n\tu32\t\t\t\t\t\t\ttrack;\n\tu32\t\t\t\t\t\t\ttimescale;\n\t//u32\t\t\t\t\t\t\tduration;\n\tu32\t\t\t\t\t\t\tdescIndex;\n\tu32\t\t\t\t\t\t\tID;\n\tu32\t\t\t\t\t\t\tOCR_ES_ID;\n\tGF_GenericSubtitleConfig\t*cfg;\n\tSWFReader\t\t\t\t\t*read;\n\tGF_ISOFlusher\t\t\t\tflusher;\n\tchar\t\t\t\t\t\t*mime;\n\n\tif (import->flags & GF_IMPORT_PROBE_ONLY) {\n\t\timport->nb_tracks = 1;\n\t\treturn GF_OK;\n\t}\n\n\tcfg\t= NULL;\n\tif (import->esd) {\n\t\tif (!import->esd->slConfig)\t{\n\t\t\timport->esd->slConfig =\t(GF_SLConfig *)\tgf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\t\timport->esd->slConfig->predefined =\t2;\n\t\t\timport->esd->slConfig->timestampResolution = 1000;\n\t\t}\n\t\ttimescale =\timport->esd->slConfig->timestampResolution;\n\t\tif (!timescale)\ttimescale =\t1000;\n\n\t\t/*explicit text\tconfig*/\n\t\tif (import->esd->decoderConfig && import->esd->decoderConfig->decoderSpecificInfo->tag == GF_ODF_GEN_SUB_CFG_TAG) {\n\t\t\tcfg\t= (GF_GenericSubtitleConfig\t*) import->esd->decoderConfig->decoderSpecificInfo;\n\t\t\timport->esd->decoderConfig->decoderSpecificInfo\t= NULL;\n\t\t}\n\t\tID = import->esd->ESID;\n\t\tOCR_ES_ID =\timport->esd->OCRESID;\n\t} else {\n\t\ttimescale =\t1000;\n\t\tOCR_ES_ID =\tID = 0;\n\t}\n\n\tif (cfg\t&& cfg->timescale) timescale = cfg->timescale;\n\ttrack =\tgf_isom_new_track(import->dest,\tID,\tGF_ISOM_MEDIA_TEXT,\ttimescale);\n\tif (!track)\t{\n\t\treturn gf_import_message(import, gf_isom_last_error(import->dest), \"Error creating text track\");\n\t}\n\tgf_isom_set_track_enabled(import->dest,\ttrack, 1);\n\tif (import->esd\t&& !import->esd->ESID) import->esd->ESID = gf_isom_get_track_id(import->dest, track);\n\n\tif (OCR_ES_ID) gf_isom_set_track_reference(import->dest, track,\tGF_ISOM_REF_OCR, OCR_ES_ID);\n\n\tif (!stricmp(import->streamFormat, \"SVG\")) {\n\t\tmime = \"image/svg+xml\";\n\t} else {\n\t\tmime = \"application/octet-stream\";\n\t}\n\n\tread = gf_swf_reader_new(NULL, import->in_name);\n\tgf_swf_read_header(read);\n\n\t/*setup\ttrack*/\n\tif (cfg) {\n\t\tu32\ti;\n\t\tu32\tcount;\n\t\t/*set track\tinfo*/\n\t\tgf_isom_set_track_layout_info(import->dest,\ttrack, cfg->text_width<<16,\tcfg->text_height<<16, 0, 0,\tcfg->layer);\n\n\t\t/*and set sample descriptions*/\n\t\tcount =\tgf_list_count(cfg->sample_descriptions);\n\t\tfor\t(i=0; i<count; i++)\t{\n\t\t\tgf_isom_new_stxt_description(import->dest, track, GF_ISOM_SUBTYPE_STXT, mime, NULL, NULL, &descIndex);\n\t\t}\n\t\tgf_import_message(import, GF_OK, \"SWF import - text track %d\tx %d\", cfg->text_width,\tcfg->text_height);\n\t\tgf_odf_desc_del((GF_Descriptor *)cfg);\n\t} else {\n\t\tu32\tw = (u32)read->width;\n\t\tu32\th = (u32)read->height;\n\n\t\tif (!w || !h)\n\t\t\tgf_text_get_video_size(import, &w, &h);\n\n\t\tgf_isom_set_track_layout_info(import->dest,\ttrack, w<<16, h<<16, 0,\t0, 0);\n\n\t\tgf_isom_new_stxt_description(import->dest, track, GF_ISOM_SUBTYPE_STXT, mime, NULL,\tNULL, &descIndex);\n\n\t\tgf_import_message(import, GF_OK, \"SWF import (as text - type: %s)\", import->streamFormat);\n\t}\n\tgf_text_import_set_language(import, track);\n\t//duration = (u32) (((Double) import->duration)*timescale/1000.0);\n\n\tflusher.import = import;\n\tflusher.track = track;\n\tflusher.timescale = timescale;\n\tflusher.descriptionIndex = descIndex;\n\tgf_swf_reader_set_user_mode(read, &flusher, swf_svg_add_iso_sample, swf_svg_add_iso_header);\n\n\tif (!import->streamFormat || (import->streamFormat && !stricmp(import->streamFormat, \"SVG\"))) {\n#ifndef GPAC_DISABLE_SVG\n\t\te = swf_to_svg_init(read, import->swf_flags, import->swf_flatten_angle);\n#endif\n\t} else { /*if (import->streamFormat && !strcmp(import->streamFormat, \"BIFS\"))*/\n#ifndef GPAC_DISABLE_VRML\n\t\te = swf_to_bifs_init(read);\n#endif\n\t}\n\tif (e) {\n\t\tgoto exit;\n\t}\n\t/*parse all tags*/\n\twhile (e == GF_OK) {\n\t\te = swf_parse_tag(read);\n\t}\n\tif (e==GF_EOS) e = GF_OK;\nexit:\n\tgf_swf_reader_del(read);\n\tgf_media_update_bitrate(import->dest, track);\n\treturn e;\n}\n/* end of SWF Importer */\n\n#else\n\nGF_EXPORT\nGF_Err gf_text_import_swf(GF_MediaImporter *import)\n{\n\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"Warning: GPAC was compiled without SWF import support, can't import track.\\n\"));\n\treturn GF_NOT_SUPPORTED;\n}\n\n#endif /*GPAC_DISABLE_SWF_IMPORT*/\n\nstatic GF_Err gf_text_import_sub(GF_MediaImporter *import)\n{\n\tFILE *sub_in;\n\tu32 track, ID, timescale, i, j, desc_idx, start, end, prev_end, nb_samp, duration, len, line;\n\tu64 file_size;\n\tGF_TextConfig*cfg;\n\tGF_Err e;\n\tDouble FPS;\n\tGF_TextSample * samp;\n\tBool first_samp;\n\ts32 unicode_type;\n\tchar szLine[2048], szTime[20], szText[2048];\n\tGF_ISOSample *s;\n\n\tsub_in = gf_fopen(import->in_name, \"rt\");\n\tunicode_type = gf_text_get_utf_type(sub_in);\n\tif (unicode_type<0) {\n\t\tgf_fclose(sub_in);\n\t\treturn gf_import_message(import, GF_NOT_SUPPORTED, \"Unsupported SUB UTF encoding\");\n\t}\n\n\tFPS = GF_IMPORT_DEFAULT_FPS;\n\tif (import->video_fps) FPS = import->video_fps;\n\n\tcfg = NULL;\n\tif (import->esd) {\n\t\tif (!import->esd->slConfig) {\n\t\t\timport->esd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\t\timport->esd->slConfig->predefined = 2;\n\t\t\timport->esd->slConfig->timestampResolution = 1000;\n\t\t}\n\t\ttimescale = import->esd->slConfig->timestampResolution;\n\t\tif (!timescale) timescale = 1000;\n\n\t\t/*explicit text config*/\n\t\tif (import->esd->decoderConfig && import->esd->decoderConfig->decoderSpecificInfo->tag == GF_ODF_TEXT_CFG_TAG) {\n\t\t\tcfg = (GF_TextConfig *) import->esd->decoderConfig->decoderSpecificInfo;\n\t\t\timport->esd->decoderConfig->decoderSpecificInfo = NULL;\n\t\t}\n\t\tID = import->esd->ESID;\n\t} else {\n\t\ttimescale = 1000;\n\t\tID = 0;\n\t}\n\n\tif (cfg && cfg->timescale) timescale = cfg->timescale;\n\ttrack = gf_isom_new_track(import->dest, ID, GF_ISOM_MEDIA_TEXT, timescale);\n\tif (!track) {\n\t\tgf_fclose(sub_in);\n\t\treturn gf_import_message(import, gf_isom_last_error(import->dest), \"Error creating text track\");\n\t}\n\tgf_isom_set_track_enabled(import->dest, track, 1);\n\tif (import->esd && !import->esd->ESID) import->esd->ESID = gf_isom_get_track_id(import->dest, track);\n\n\tgf_text_import_set_language(import, track);\n\n\tfile_size = 0;\n\t/*setup track*/\n\tif (cfg) {\n\t\tu32 count;\n\t\tchar *firstFont = NULL;\n\t\t/*set track info*/\n\t\tgf_isom_set_track_layout_info(import->dest, track, cfg->text_width<<16, cfg->text_height<<16, 0, 0, cfg->layer);\n\n\t\t/*and set sample descriptions*/\n\t\tcount = gf_list_count(cfg->sample_descriptions);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_TextSampleDescriptor *sd= (GF_TextSampleDescriptor *)gf_list_get(cfg->sample_descriptions, i);\n\t\t\tif (!sd->font_count) {\n\t\t\t\tsd->fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\t\t\tsd->font_count = 1;\n\t\t\t\tsd->fonts[0].fontID = 1;\n\t\t\t\tsd->fonts[0].fontName = gf_strdup(\"Serif\");\n\t\t\t}\n\t\t\tif (!sd->default_style.fontID) sd->default_style.fontID = sd->fonts[0].fontID;\n\t\t\tif (!sd->default_style.font_size) sd->default_style.font_size = 16;\n\t\t\tif (!sd->default_style.text_color) sd->default_style.text_color = 0xFF000000;\n\t\t\tfile_size = sd->default_style.font_size;\n\t\t\tgf_isom_new_text_description(import->dest, track, sd, NULL, NULL, &desc_idx);\n\t\t\tif (!firstFont) firstFont = sd->fonts[0].fontName;\n\t\t}\n\t\tgf_import_message(import, GF_OK, \"Timed Text (SUB @ %02.2f) import - text track %d x %d, font %s (size %d)\", FPS, cfg->text_width, cfg->text_height, firstFont, file_size);\n\n\t\tgf_odf_desc_del((GF_Descriptor *)cfg);\n\t} else {\n\t\tu32 w, h;\n\t\tGF_TextSampleDescriptor *sd;\n\t\tgf_text_get_video_size(import, &w, &h);\n\n\t\t/*have to work with default - use max size (if only one video, this means the text region is the\n\t\tentire display, and with bottom alignment things should be fine...*/\n\t\tgf_isom_set_track_layout_info(import->dest, track, w<<16, h<<16, 0, 0, 0);\n\t\tsd = (GF_TextSampleDescriptor*)gf_odf_desc_new(GF_ODF_TX3G_TAG);\n\t\tsd->fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\tsd->font_count = 1;\n\t\tsd->fonts[0].fontID = 1;\n\t\tsd->fonts[0].fontName = gf_strdup(\"Serif\");\n\t\tsd->back_color = 0x00000000;\t/*transparent*/\n\t\tsd->default_style.fontID = 1;\n\t\tsd->default_style.font_size = TTXT_DEFAULT_FONT_SIZE;\n\t\tsd->default_style.text_color = 0xFFFFFFFF;\t/*white*/\n\t\tsd->default_style.style_flags = 0;\n\t\tsd->horiz_justif = 1; /*center of scene*/\n\t\tsd->vert_justif = (s8) -1;\t/*bottom of scene*/\n\n\t\tif (import->flags & GF_IMPORT_SKIP_TXT_BOX) {\n\t\t\tsd->default_pos.top = sd->default_pos.left = sd->default_pos.right = sd->default_pos.bottom = 0;\n\t\t} else {\n\t\t\tif ((sd->default_pos.bottom==sd->default_pos.top) || (sd->default_pos.right==sd->default_pos.left)) {\n\t\t\t\tsd->default_pos.left = import->text_x;\n\t\t\t\tsd->default_pos.top = import->text_y;\n\t\t\t\tsd->default_pos.right = (import->text_width ? import->text_width : w) + sd->default_pos.left;\n\t\t\t\tsd->default_pos.bottom = (import->text_height ? import->text_height : h) + sd->default_pos.top;\n\t\t\t}\n\t\t}\n\n\t\tgf_isom_new_text_description(import->dest, track, sd, NULL, NULL, &desc_idx);\n\t\tgf_import_message(import, GF_OK, \"Timed Text (SUB @ %02.2f) import - text track %d x %d, font %s (size %d)\", FPS, w, h, sd->fonts[0].fontName, TTXT_DEFAULT_FONT_SIZE);\n\t\tgf_odf_desc_del((GF_Descriptor *)sd);\n\t}\n\n\tduration = (u32) (((Double) import->duration)*timescale/1000.0);\n\n\te = GF_OK;\n\tnb_samp = 0;\n\tsamp = gf_isom_new_text_sample();\n\n\tFPS = ((Double) timescale ) / FPS;\n\tend = prev_end = 0;\n\n\tline = 0;\n\tfirst_samp = GF_TRUE;\n\twhile (1) {\n\t\tchar *sOK = gf_text_get_utf8_line(szLine, 2048, sub_in, unicode_type);\n\t\tif (!sOK) break;\n\n\t\tREM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\n\t\tline++;\n\t\tlen = (u32) strlen(szLine);\n\t\tif (!len) continue;\n\n\t\ti=0;\n\t\tif (szLine[i] != '{') {\n\t\t\te = gf_import_message(import, GF_NON_COMPLIANT_BITSTREAM, \"Bad SUB file (line %d): expecting \\\"{\\\" got \\\"%c\\\"\", line, szLine[i]);\n\t\t\tgoto exit;\n\t\t}\n\t\twhile (szLine[i+1] && szLine[i+1]!='}') {\n\t\t\tszTime[i] = szLine[i+1];\n\t\t\ti++;\n\t\t}\n\t\tszTime[i] = 0;\n\t\tstart = atoi(szTime);\n\t\tif (start<end) {\n\t\t\tgf_import_message(import, GF_OK, \"WARNING: corrupted SUB frame (line %d) - starts (at %d ms) before end of previous one (%d ms) - adjusting time stamps\", line, start, end);\n\t\t\tstart = end;\n\t\t}\n\t\tj=i+2;\n\t\ti=0;\n\t\tif (szLine[i+j] != '{') {\n\t\t\te = gf_import_message(import, GF_NON_COMPLIANT_BITSTREAM, \"Bad SUB file - expecting \\\"{\\\" got \\\"%c\\\"\", szLine[i]);\n\t\t\tgoto exit;\n\t\t}\n\t\twhile (szLine[i+1+j] && szLine[i+1+j]!='}') {\n\t\t\tszTime[i] = szLine[i+1+j];\n\t\t\ti++;\n\t\t}\n\t\tszTime[i] = 0;\n\t\tend = atoi(szTime);\n\t\tj+=i+2;\n\n\t\tif (start>end) {\n\t\t\tgf_import_message(import, GF_OK, \"WARNING: corrupted SUB frame (line %d) - ends (at %d ms) before start of current frame (%d ms) - skipping\", line, end, start);\n\t\t\tcontinue;\n\t\t}\n\n\t\tgf_isom_text_reset(samp);\n\n\t\tif (start && first_samp) {\n\t\t\ts = gf_isom_text_to_sample(samp);\n\t\t\ts->DTS = 0;\n\t\t\ts->IsRAP = RAP;\n\t\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\t\tgf_isom_sample_del(&s);\n\t\t\tfirst_samp = GF_FALSE;\n\t\t\tnb_samp++;\n\t\t}\n\n\t\tfor (i=j; i<len; i++) {\n\t\t\tif (szLine[i]=='|') {\n\t\t\t\tszText[i-j] = '\\n';\n\t\t\t} else {\n\t\t\t\tszText[i-j] = szLine[i];\n\t\t\t}\n\t\t}\n\t\tszText[i-j] = 0;\n\t\tgf_isom_text_add_text(samp, szText, (u32) strlen(szText) );\n\n\t\tif (prev_end) {\n\t\t\tGF_TextSample * empty_samp = gf_isom_new_text_sample();\n\t\t\ts = gf_isom_text_to_sample(empty_samp);\n\t\t\ts->DTS = (u64) (FPS*(s64)prev_end);\n\t\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\t\tgf_isom_sample_del(&s);\n\t\t\tnb_samp++;\n\t\t\tgf_isom_delete_text_sample(empty_samp);\n\t\t}\n\n\t\ts = gf_isom_text_to_sample(samp);\n\t\ts->DTS = (u64) (FPS*(s64)start);\n\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\tgf_isom_sample_del(&s);\n\t\tnb_samp++;\n\t\tgf_isom_text_reset(samp);\n\t\tprev_end = end;\n\t\tgf_set_progress(\"Importing SUB\", gf_ftell(sub_in), file_size);\n\t\tif (duration && (end >= duration)) break;\n\t}\n\t/*final flush*/\n\tif (end && !(import->flags & GF_IMPORT_NO_TEXT_FLUSH ) ) {\n\t\tgf_isom_text_reset(samp);\n\t\ts = gf_isom_text_to_sample(samp);\n\t\ts->DTS = (u64)(FPS*(s64)end);\n\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\tgf_isom_sample_del(&s);\n\t\tnb_samp++;\n\t}\n\tgf_isom_delete_text_sample(samp);\n\t\n\tgf_isom_set_last_sample_duration(import->dest, track, 0);\n\tgf_set_progress(\"Importing SUB\", nb_samp, nb_samp);\n\nexit:\n\tif (e) gf_isom_remove_track(import->dest, track);\n\tgf_fclose(sub_in);\n\treturn e;\n}\n\n\n#define CHECK_STR(__str)\t\\\n\tif (!__str) { \\\n\t\te = gf_import_message(import, GF_BAD_PARAM, \"Invalid XML formatting (line %d)\", parser.line);\t\\\n\t\tgoto exit;\t\\\n\t}\t\\\n \n\nu32 ttxt_get_color(GF_MediaImporter *import, char *val)\n{\n\tu32 r, g, b, a, res;\n\tr = g = b = a = 0;\n\tif (sscanf(val, \"%x %x %x %x\", &r, &g, &b, &a) != 4) {\n\t\tgf_import_message(import, GF_OK, \"Warning: color badly formatted\");\n\t}\n\tres = (a&0xFF);\n\tres<<=8;\n\tres |= (r&0xFF);\n\tres<<=8;\n\tres |= (g&0xFF);\n\tres<<=8;\n\tres |= (b&0xFF);\n\treturn res;\n}\n\nvoid ttxt_parse_text_box(GF_MediaImporter *import, GF_XMLNode *n, GF_BoxRecord *box)\n{\n\tu32 i=0;\n\tGF_XMLAttribute *att;\n\tmemset(box, 0, sizeof(GF_BoxRecord));\n\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(n->attributes, &i))) {\n\t\tif (!stricmp(att->name, \"top\")) box->top = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"bottom\")) box->bottom = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"left\")) box->left = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"right\")) box->right = atoi(att->value);\n\t}\n}\n\nvoid ttxt_parse_text_style(GF_MediaImporter *import, GF_XMLNode *n, GF_StyleRecord *style)\n{\n\tu32 i=0;\n\tGF_XMLAttribute *att;\n\tmemset(style, 0, sizeof(GF_StyleRecord));\n\tstyle->fontID = 1;\n\tstyle->font_size = TTXT_DEFAULT_FONT_SIZE;\n\tstyle->text_color = 0xFFFFFFFF;\n\n\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(n->attributes, &i))) {\n\t\tif (!stricmp(att->name, \"fromChar\")) style->startCharOffset = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"toChar\")) style->endCharOffset = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"fontID\")) style->fontID = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"fontSize\")) style->font_size = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"color\")) style->text_color = ttxt_get_color(import, att->value);\n\t\telse if (!stricmp(att->name, \"styles\")) {\n\t\t\tif (strstr(att->value, \"Bold\")) style->style_flags |= GF_TXT_STYLE_BOLD;\n\t\t\tif (strstr(att->value, \"Italic\")) style->style_flags |= GF_TXT_STYLE_ITALIC;\n\t\t\tif (strstr(att->value, \"Underlined\")) style->style_flags |= GF_TXT_STYLE_UNDERLINED;\n\t\t}\n\t}\n}\n\nstatic void ttxt_import_progress(void *cbk, u64 cur_samp, u64 count)\n{\n\tgf_set_progress(\"TTXT Loading\", cur_samp, count);\n}\n\nstatic GF_Err gf_text_import_ttxt(GF_MediaImporter *import)\n{\n\tGF_Err e;\n\tBool last_sample_empty;\n\tu32 i, j, k, track, ID, nb_samples, nb_descs, nb_children;\n\tu64 last_sample_duration;\n\tGF_XMLAttribute *att;\n\tGF_DOMParser *parser;\n\tGF_XMLNode *root, *node, *ext;\n\n\tif (import->flags==GF_IMPORT_PROBE_ONLY) return GF_OK;\n\n\tparser = gf_xml_dom_new();\n\te = gf_xml_dom_parse(parser, import->in_name, ttxt_import_progress, import);\n\tif (e) {\n\t\tgf_import_message(import, e, \"Error parsing TTXT file: Line %d - %s\", gf_xml_dom_get_line(parser), gf_xml_dom_get_error(parser));\n\t\tgf_xml_dom_del(parser);\n\t\treturn e;\n\t}\n\troot = gf_xml_dom_get_root(parser);\n\n\te = GF_OK;\n\tif (strcmp(root->name, \"TextStream\")) {\n\t\te = gf_import_message(import, GF_BAD_PARAM, \"Invalid Timed Text file - expecting \\\"TextStream\\\" got %s\", \"TextStream\", root->name);\n\t\tgoto exit;\n\t}\n\n\t/*setup track in 3GP format directly (no ES desc)*/\n\tID = (import->esd) ? import->esd->ESID : 0;\n\ttrack = gf_isom_new_track(import->dest, ID, GF_ISOM_MEDIA_TEXT, 1000);\n\tif (!track) {\n\t\te = gf_isom_last_error(import->dest);\n\t\tgoto exit;\n\t}\n\tgf_isom_set_track_enabled(import->dest, track, 1);\n\t/*some MPEG-4 setup*/\n\tif (import->esd) {\n\t\tif (!import->esd->ESID) import->esd->ESID = gf_isom_get_track_id(import->dest, track);\n\t\tif (!import->esd->decoderConfig) import->esd->decoderConfig = (GF_DecoderConfig *) gf_odf_desc_new(GF_ODF_DCD_TAG);\n\t\tif (!import->esd->slConfig) import->esd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\timport->esd->slConfig->timestampResolution = 1000;\n\t\timport->esd->decoderConfig->streamType = GF_STREAM_TEXT;\n\t\timport->esd->decoderConfig->objectTypeIndication = GPAC_OTI_TEXT_MPEG4;\n\t\tif (import->esd->OCRESID) gf_isom_set_track_reference(import->dest, track, GF_ISOM_REF_OCR, import->esd->OCRESID);\n\t}\n\tgf_text_import_set_language(import, track);\n\n\tgf_import_message(import, GF_OK, \"Timed Text (GPAC TTXT) Import\");\n\n\tlast_sample_empty = GF_FALSE;\n\tlast_sample_duration = 0;\n\tnb_descs = 0;\n\tnb_samples = 0;\n\tnb_children = gf_list_count(root->content);\n\n\ti=0;\n\twhile ( (node = (GF_XMLNode*)gf_list_enum(root->content, &i))) {\n\t\tif (node->type) {\n\t\t\tnb_children--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(node->name, \"TextStreamHeader\")) {\n\t\t\tGF_XMLNode *sdesc;\n\t\t\ts32 w, h, tx, ty, layer;\n\t\t\tu32 tref_id;\n\t\t\tw = TTXT_DEFAULT_WIDTH;\n\t\t\th = TTXT_DEFAULT_HEIGHT;\n\t\t\ttx = ty = layer = 0;\n\t\t\tnb_children--;\n\t\t\ttref_id = 0;\n\n\t\t\tj=0;\n\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(node->attributes, &j))) {\n\t\t\t\tif (!strcmp(att->name, \"width\")) w = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"height\")) h = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"layer\")) layer = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"translation_x\")) tx = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"translation_y\")) ty = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"trefID\")) tref_id = atoi(att->value);\n\t\t\t}\n\n\t\t\tif (tref_id)\n\t\t\t\tgf_isom_set_track_reference(import->dest, track, GF_ISOM_BOX_TYPE_CHAP, tref_id);\n\n\t\t\tgf_isom_set_track_layout_info(import->dest, track, w<<16, h<<16, tx<<16, ty<<16, (s16) layer);\n\n\t\t\tj=0;\n\t\t\twhile ( (sdesc=(GF_XMLNode*)gf_list_enum(node->content, &j))) {\n\t\t\t\tif (sdesc->type) continue;\n\n\t\t\t\tif (!strcmp(sdesc->name, \"TextSampleDescription\")) {\n\t\t\t\t\tGF_TextSampleDescriptor td;\n\t\t\t\t\tu32 idx;\n\t\t\t\t\tmemset(&td, 0, sizeof(GF_TextSampleDescriptor));\n\t\t\t\t\ttd.tag = GF_ODF_TEXT_CFG_TAG;\n\t\t\t\t\ttd.vert_justif = (s8) -1;\n\t\t\t\t\ttd.default_style.fontID = 1;\n\t\t\t\t\ttd.default_style.font_size = TTXT_DEFAULT_FONT_SIZE;\n\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(sdesc->attributes, &k))) {\n\t\t\t\t\t\tif (!strcmp(att->name, \"horizontalJustification\")) {\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.horiz_justif = 1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"right\")) td.horiz_justif = (s8) -1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"left\")) td.horiz_justif = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!strcmp(att->name, \"verticalJustification\")) {\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.vert_justif = 1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"bottom\")) td.vert_justif = (s8) -1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"top\")) td.vert_justif = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!strcmp(att->name, \"backColor\")) td.back_color = ttxt_get_color(import, att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"verticalText\") && !stricmp(att->value, \"yes\") ) td.displayFlags |= GF_TXT_VERTICAL;\n\t\t\t\t\t\telse if (!strcmp(att->name, \"fillTextRegion\") && !stricmp(att->value, \"yes\") ) td.displayFlags |= GF_TXT_FILL_REGION;\n\t\t\t\t\t\telse if (!strcmp(att->name, \"continuousKaraoke\") && !stricmp(att->value, \"yes\") ) td.displayFlags |= GF_TXT_KARAOKE;\n\t\t\t\t\t\telse if (!strcmp(att->name, \"scroll\")) {\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"inout\")) td.displayFlags |= GF_TXT_SCROLL_IN | GF_TXT_SCROLL_OUT;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"in\")) td.displayFlags |= GF_TXT_SCROLL_IN;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"out\")) td.displayFlags |= GF_TXT_SCROLL_OUT;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!strcmp(att->name, \"scrollMode\")) {\n\t\t\t\t\t\t\tu32 scroll_mode = GF_TXT_SCROLL_CREDITS;\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"Credits\")) scroll_mode = GF_TXT_SCROLL_CREDITS;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"Marquee\")) scroll_mode = GF_TXT_SCROLL_MARQUEE;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"Right\")) scroll_mode = GF_TXT_SCROLL_RIGHT;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"Down\")) scroll_mode = GF_TXT_SCROLL_DOWN;\n\t\t\t\t\t\t\ttd.displayFlags |= ((scroll_mode<<7) & GF_TXT_SCROLL_DIRECTION);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (ext=(GF_XMLNode*)gf_list_enum(sdesc->content, &k))) {\n\t\t\t\t\t\tif (ext->type) continue;\n\t\t\t\t\t\tif (!strcmp(ext->name, \"TextBox\")) ttxt_parse_text_box(import, ext, &td.default_pos);\n\t\t\t\t\t\telse if (!strcmp(ext->name, \"Style\")) ttxt_parse_text_style(import, ext, &td.default_style);\n\t\t\t\t\t\telse if (!strcmp(ext->name, \"FontTable\")) {\n\t\t\t\t\t\t\tGF_XMLNode *ftable;\n\t\t\t\t\t\t\tu32 z=0;\n\t\t\t\t\t\t\twhile ( (ftable=(GF_XMLNode*)gf_list_enum(ext->content, &z))) {\n\t\t\t\t\t\t\t\tu32 m;\n\t\t\t\t\t\t\t\tif (ftable->type || strcmp(ftable->name, \"FontTableEntry\")) continue;\n\t\t\t\t\t\t\t\ttd.font_count += 1;\n\t\t\t\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_realloc(td.fonts, sizeof(GF_FontRecord)*td.font_count);\n\t\t\t\t\t\t\t\tm=0;\n\t\t\t\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ftable->attributes, &m))) {\n\t\t\t\t\t\t\t\t\tif (!stricmp(att->name, \"fontID\")) td.fonts[td.font_count-1].fontID = atoi(att->value);\n\t\t\t\t\t\t\t\t\telse if (!stricmp(att->name, \"fontName\")) td.fonts[td.font_count-1].fontName = gf_strdup(att->value);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (import->flags & GF_IMPORT_SKIP_TXT_BOX) {\n\t\t\t\t\t\ttd.default_pos.top = td.default_pos.left = td.default_pos.right = td.default_pos.bottom = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ((td.default_pos.bottom==td.default_pos.top) || (td.default_pos.right==td.default_pos.left)) {\n\t\t\t\t\t\t\ttd.default_pos.top = td.default_pos.left = 0;\n\t\t\t\t\t\t\ttd.default_pos.right = w;\n\t\t\t\t\t\t\ttd.default_pos.bottom = h;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!td.fonts) {\n\t\t\t\t\t\ttd.font_count = 1;\n\t\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\t\t\t\t\ttd.fonts[0].fontID = 1;\n\t\t\t\t\t\ttd.fonts[0].fontName = gf_strdup(\"Serif\");\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_new_text_description(import->dest, track, &td, NULL, NULL, &idx);\n\t\t\t\t\tfor (k=0; k<td.font_count; k++) gf_free(td.fonts[k].fontName);\n\t\t\t\t\tgf_free(td.fonts);\n\t\t\t\t\tnb_descs ++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*sample text*/\n\t\telse if (!strcmp(node->name, \"TextSample\")) {\n\t\t\tGF_ISOSample *s;\n\t\t\tGF_TextSample * samp;\n\t\t\tu32 ts, descIndex;\n\t\t\tBool has_text = GF_FALSE;\n\t\t\tif (!nb_descs) {\n\t\t\t\te = gf_import_message(import, GF_BAD_PARAM, \"Invalid Timed Text file - text stream header not found or empty\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tsamp = gf_isom_new_text_sample();\n\t\t\tts = 0;\n\t\t\tdescIndex = 1;\n\t\t\tlast_sample_empty = GF_TRUE;\n\n\t\t\tj=0;\n\t\t\twhile ( (att=(GF_XMLAttribute*)gf_list_enum(node->attributes, &j))) {\n\t\t\t\tif (!strcmp(att->name, \"sampleTime\")) {\n\t\t\t\t\tu32 h, m, s, ms;\n\t\t\t\t\tif (sscanf(att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\tts = (h*3600 + m*60 + s)*1000 + ms;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tts = (u32) (atof(att->value) * 1000);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(att->name, \"sampleDescriptionIndex\")) descIndex = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"text\")) {\n\t\t\t\t\tu32 len;\n\t\t\t\t\tchar *str = ttxt_parse_string(import, att->value, GF_TRUE);\n\t\t\t\t\tlen = (u32) strlen(str);\n\t\t\t\t\tgf_isom_text_add_text(samp, str, len);\n\t\t\t\t\tlast_sample_empty = len ? GF_FALSE : GF_TRUE;\n\t\t\t\t\thas_text = GF_TRUE;\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(att->name, \"scrollDelay\")) gf_isom_text_set_scroll_delay(samp, (u32) (1000*atoi(att->value)));\n\t\t\t\telse if (!strcmp(att->name, \"highlightColor\")) gf_isom_text_set_highlight_color_argb(samp, ttxt_get_color(import, att->value));\n\t\t\t\telse if (!strcmp(att->name, \"wrap\") && !strcmp(att->value, \"Automatic\")) gf_isom_text_set_wrap(samp, 0x01);\n\t\t\t}\n\n\t\t\t/*get all modifiers*/\n\t\t\tj=0;\n\t\t\twhile ( (ext=(GF_XMLNode*)gf_list_enum(node->content, &j))) {\n\t\t\t\tif (!has_text && (ext->type==GF_XML_TEXT_TYPE)) {\n\t\t\t\t\tu32 len;\n\t\t\t\t\tchar *str = ttxt_parse_string(import, ext->name, GF_FALSE);\n\t\t\t\t\tlen = (u32) strlen(str);\n\t\t\t\t\tgf_isom_text_add_text(samp, str, len);\n\t\t\t\t\tlast_sample_empty = len ? GF_FALSE : GF_TRUE;\n\t\t\t\t\thas_text = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tif (ext->type) continue;\n\n\t\t\t\tif (!stricmp(ext->name, \"Style\")) {\n\t\t\t\t\tGF_StyleRecord r;\n\t\t\t\t\tttxt_parse_text_style(import, ext, &r);\n\t\t\t\t\tgf_isom_text_add_style(samp, &r);\n\t\t\t\t}\n\t\t\t\telse if (!stricmp(ext->name, \"TextBox\")) {\n\t\t\t\t\tGF_BoxRecord r;\n\t\t\t\t\tttxt_parse_text_box(import, ext, &r);\n\t\t\t\t\tgf_isom_text_set_box(samp, r.top, r.left, r.bottom, r.right);\n\t\t\t\t}\n\t\t\t\telse if (!stricmp(ext->name, \"Highlight\")) {\n\t\t\t\t\tu16 start, end;\n\t\t\t\t\tstart = end = 0;\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_text_add_highlight(samp, start, end);\n\t\t\t\t}\n\t\t\t\telse if (!stricmp(ext->name, \"Blinking\")) {\n\t\t\t\t\tu16 start, end;\n\t\t\t\t\tstart = end = 0;\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_text_add_blink(samp, start, end);\n\t\t\t\t}\n\t\t\t\telse if (!stricmp(ext->name, \"HyperLink\")) {\n\t\t\t\t\tu16 start, end;\n\t\t\t\t\tchar *url, *url_tt;\n\t\t\t\t\tstart = end = 0;\n\t\t\t\t\turl = url_tt = NULL;\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"URL\")) url = gf_strdup(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"URLToolTip\")) url_tt = gf_strdup(att->value);\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_text_add_hyperlink(samp, url, url_tt, start, end);\n\t\t\t\t\tif (url) gf_free(url);\n\t\t\t\t\tif (url_tt) gf_free(url_tt);\n\t\t\t\t}\n\t\t\t\telse if (!stricmp(ext->name, \"Karaoke\")) {\n\t\t\t\t\tu32 startTime;\n\t\t\t\t\tGF_XMLNode *krok;\n\t\t\t\t\tstartTime = 0;\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\t\tif (!strcmp(att->name, \"startTime\")) startTime = (u32) (1000*atof(att->value));\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_text_add_karaoke(samp, startTime);\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (krok=(GF_XMLNode*)gf_list_enum(ext->content, &k))) {\n\t\t\t\t\t\tu16 start, end;\n\t\t\t\t\t\tu32 endTime, m;\n\t\t\t\t\t\tif (krok->type) continue;\n\t\t\t\t\t\tif (strcmp(krok->name, \"KaraokeRange\")) continue;\n\t\t\t\t\t\tstart = end = 0;\n\t\t\t\t\t\tendTime = 0;\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(krok->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endTime\")) endTime = (u32) (1000*atof(att->value));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_set_karaoke_segment(samp, endTime, start, end);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*in MP4 we must start at T=0, so add an empty sample*/\n\t\t\tif (ts && !nb_samples) {\n\t\t\t\tGF_TextSample * firstsamp = gf_isom_new_text_sample();\n\t\t\t\ts = gf_isom_text_to_sample(firstsamp);\n\t\t\t\ts->DTS = 0;\n\t\t\t\tgf_isom_add_sample(import->dest, track, 1, s);\n\t\t\t\tnb_samples++;\n\t\t\t\tgf_isom_delete_text_sample(firstsamp);\n\t\t\t\tgf_isom_sample_del(&s);\n\t\t\t}\n\n\t\t\ts = gf_isom_text_to_sample(samp);\n\t\t\tgf_isom_delete_text_sample(samp);\n\t\t\ts->DTS = ts;\n\t\t\tif (last_sample_empty) {\n\t\t\t\tlast_sample_duration = s->DTS - last_sample_duration;\n\t\t\t} else {\n\t\t\t\tlast_sample_duration = s->DTS;\n\t\t\t}\n\n\t\t\te = gf_isom_add_sample(import->dest, track, descIndex, s);\n\t\t\tif (e) goto exit;\n\t\t\tgf_isom_sample_del(&s);\n\t\t\tnb_samples++;\n\n\t\t\tgf_set_progress(\"Importing TTXT\", nb_samples, nb_children);\n\t\t\tif (import->duration && (ts>import->duration)) break;\n\t\t}\n\t}\n\tif (last_sample_empty) {\n\t\tgf_isom_remove_sample(import->dest, track, nb_samples);\n\t\tgf_isom_set_last_sample_duration(import->dest, track, (u32) last_sample_duration);\n\t}\n\tgf_set_progress(\"Importing TTXT\", nb_samples, nb_samples);\n\nexit:\n\tgf_xml_dom_del(parser);\n\treturn e;\n}\n\n\nu32 tx3g_get_color(GF_MediaImporter *import, char *value)\n{\n\tu32 r, g, b, a;\n\tu32 res, v;\n\tr = g = b = a = 0;\n\tif (sscanf(value, \"%u%%, %u%%, %u%%, %u%%\", &r, &g, &b, &a) != 4) {\n\t\tgf_import_message(import, GF_OK, \"Warning: color badly formatted\");\n\t}\n\tv = (u32) (a*255/100);\n\tres = (v&0xFF);\n\tres<<=8;\n\tv = (u32) (r*255/100);\n\tres |= (v&0xFF);\n\tres<<=8;\n\tv = (u32) (g*255/100);\n\tres |= (v&0xFF);\n\tres<<=8;\n\tv = (u32) (b*255/100);\n\tres |= (v&0xFF);\n\treturn res;\n}\n\nvoid tx3g_parse_text_box(GF_MediaImporter *import, GF_XMLNode *n, GF_BoxRecord *box)\n{\n\tu32 i=0;\n\tGF_XMLAttribute *att;\n\tmemset(box, 0, sizeof(GF_BoxRecord));\n\twhile ((att=(GF_XMLAttribute *)gf_list_enum(n->attributes, &i))) {\n\t\tif (!stricmp(att->name, \"x\")) box->left = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"y\")) box->top = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"height\")) box->bottom = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"width\")) box->right = atoi(att->value);\n\t}\n}\n\ntypedef struct\n{\n\tu32 id;\n\tu32 pos;\n} Marker;\n\n#define GET_MARKER_POS(_val, __isend) \\\n\t{\t\\\n\t\tu32 i, __m = atoi(att->value);\t\\\n\t\t_val = 0;\t\\\n\t\tfor (i=0; i<nb_marks; i++) { if (__m==marks[i].id) { _val = marks[i].pos; /*if (__isend) _val--; */break; } }\t \\\n\t}\n\n\nstatic void texml_import_progress(void *cbk, u64 cur_samp, u64 count)\n{\n\tgf_set_progress(\"TeXML Loading\", cur_samp, count);\n}\n\nstatic GF_Err gf_text_import_texml(GF_MediaImporter *import)\n{\n\tGF_Err e;\n\tu32 track, ID, nb_samples, nb_children, nb_descs, timescale, w, h, i, j, k;\n\tu64 DTS;\n\ts32 tx, ty, layer;\n\tGF_StyleRecord styles[50];\n\tMarker marks[50];\n\tGF_XMLAttribute *att;\n\tGF_DOMParser *parser;\n\tGF_XMLNode *root, *node;\n\n\tif (import->flags==GF_IMPORT_PROBE_ONLY) return GF_OK;\n\n\tparser = gf_xml_dom_new();\n\te = gf_xml_dom_parse(parser, import->in_name, texml_import_progress, import);\n\tif (e) {\n\t\tgf_import_message(import, e, \"Error parsing TeXML file: Line %d - %s\", gf_xml_dom_get_line(parser), gf_xml_dom_get_error(parser));\n\t\tgf_xml_dom_del(parser);\n\t\treturn e;\n\t}\n\troot = gf_xml_dom_get_root(parser);\n\n\tif (strcmp(root->name, \"text3GTrack\")) {\n\t\te = gf_import_message(import, GF_BAD_PARAM, \"Invalid QT TeXML file - expecting root \\\"text3GTrack\\\" got \\\"%s\\\"\", root->name);\n\t\tgoto exit;\n\t}\n\tw = TTXT_DEFAULT_WIDTH;\n\th = TTXT_DEFAULT_HEIGHT;\n\ttx = ty = 0;\n\tlayer = 0;\n\ttimescale = 1000;\n\ti=0;\n\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(root->attributes, &i))) {\n\t\tif (!strcmp(att->name, \"trackWidth\")) w = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"trackHeight\")) h = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"layer\")) layer = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"timescale\")) timescale = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"transform\")) {\n\t\t\tFloat fx, fy;\n\t\t\tsscanf(att->value, \"translate(%f,%f)\", &fx, &fy);\n\t\t\ttx = (u32) fx;\n\t\t\tty = (u32) fy;\n\t\t}\n\t}\n\n\t/*setup track in 3GP format directly (no ES desc)*/\n\tID = (import->esd) ? import->esd->ESID : 0;\n\ttrack = gf_isom_new_track(import->dest, ID, GF_ISOM_MEDIA_TEXT, timescale);\n\tif (!track) {\n\t\te = gf_isom_last_error(import->dest);\n\t\tgoto exit;\n\t}\n\tgf_isom_set_track_enabled(import->dest, track, 1);\n\t/*some MPEG-4 setup*/\n\tif (import->esd) {\n\t\tif (!import->esd->ESID) import->esd->ESID = gf_isom_get_track_id(import->dest, track);\n\t\tif (!import->esd->decoderConfig) import->esd->decoderConfig = (GF_DecoderConfig *) gf_odf_desc_new(GF_ODF_DCD_TAG);\n\t\tif (!import->esd->slConfig) import->esd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);\n\t\timport->esd->slConfig->timestampResolution = timescale;\n\t\timport->esd->decoderConfig->streamType = GF_STREAM_TEXT;\n\t\timport->esd->decoderConfig->objectTypeIndication = GPAC_OTI_TEXT_MPEG4;\n\t\tif (import->esd->OCRESID) gf_isom_set_track_reference(import->dest, track, GF_ISOM_REF_OCR, import->esd->OCRESID);\n\t}\n\tDTS = 0;\n\tgf_isom_set_track_layout_info(import->dest, track, w<<16, h<<16, tx<<16, ty<<16, (s16) layer);\n\n\tgf_text_import_set_language(import, track);\n\te = GF_OK;\n\n\tgf_import_message(import, GF_OK, \"Timed Text (QT TeXML) Import - Track Size %d x %d\", w, h);\n\n\tnb_children = gf_list_count(root->content);\n\tnb_descs = 0;\n\tnb_samples = 0;\n\ti=0;\n\twhile ( (node=(GF_XMLNode*)gf_list_enum(root->content, &i))) {\n\t\tGF_XMLNode *desc;\n\t\tGF_TextSampleDescriptor td;\n\t\tGF_TextSample * samp = NULL;\n\t\tGF_ISOSample *s;\n\t\tu32 duration, descIndex, nb_styles, nb_marks;\n\t\tBool isRAP, same_style, same_box;\n\n\t\tif (node->type) continue;\n\t\tif (strcmp(node->name, \"sample\")) continue;\n\n\t\tisRAP = GF_FALSE;\n\t\tduration = 1000;\n\t\tj=0;\n\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(node->attributes, &j))) {\n\t\t\tif (!strcmp(att->name, \"duration\")) duration = atoi(att->value);\n\t\t\telse if (!strcmp(att->name, \"keyframe\")) isRAP = (!stricmp(att->value, \"true\") ? GF_TRUE : GF_FALSE);\n\t\t}\n\t\tnb_styles = 0;\n\t\tnb_marks = 0;\n\t\tsame_style = same_box = GF_FALSE;\n\t\tdescIndex = 1;\n\t\tj=0;\n\t\twhile ((desc=(GF_XMLNode*)gf_list_enum(node->content, &j))) {\n\t\t\tif (desc->type) continue;\n\n\t\t\tif (!strcmp(desc->name, \"description\")) {\n\t\t\t\tGF_XMLNode *sub;\n\t\t\t\tmemset(&td, 0, sizeof(GF_TextSampleDescriptor));\n\t\t\t\ttd.tag = GF_ODF_TEXT_CFG_TAG;\n\t\t\t\ttd.vert_justif = (s8) -1;\n\t\t\t\ttd.default_style.fontID = 1;\n\t\t\t\ttd.default_style.font_size = TTXT_DEFAULT_FONT_SIZE;\n\n\t\t\t\tk=0;\n\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(desc->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"horizontalJustification\")) {\n\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.horiz_justif = 1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"right\")) td.horiz_justif = (s8) -1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"left\")) td.horiz_justif = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strcmp(att->name, \"verticalJustification\")) {\n\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.vert_justif = 1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"bottom\")) td.vert_justif = (s8) -1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"top\")) td.vert_justif = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strcmp(att->name, \"backgroundColor\")) td.back_color = tx3g_get_color(import, att->value);\n\t\t\t\t\telse if (!strcmp(att->name, \"displayFlags\")) {\n\t\t\t\t\t\tBool rev_scroll = GF_FALSE;\n\t\t\t\t\t\tif (strstr(att->value, \"scroll\")) {\n\t\t\t\t\t\t\tu32 scroll_mode = 0;\n\t\t\t\t\t\t\tif (strstr(att->value, \"scrollIn\")) td.displayFlags |= GF_TXT_SCROLL_IN;\n\t\t\t\t\t\t\tif (strstr(att->value, \"scrollOut\")) td.displayFlags |= GF_TXT_SCROLL_OUT;\n\t\t\t\t\t\t\tif (strstr(att->value, \"reverse\")) rev_scroll = GF_TRUE;\n\t\t\t\t\t\t\tif (strstr(att->value, \"horizontal\")) scroll_mode = rev_scroll ? GF_TXT_SCROLL_RIGHT : GF_TXT_SCROLL_MARQUEE;\n\t\t\t\t\t\t\telse scroll_mode = (rev_scroll ? GF_TXT_SCROLL_DOWN : GF_TXT_SCROLL_CREDITS);\n\t\t\t\t\t\t\ttd.displayFlags |= (scroll_mode<<7) & GF_TXT_SCROLL_DIRECTION;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*TODO FIXME: check in QT doc !!*/\n\t\t\t\t\t\tif (strstr(att->value, \"writeTextVertically\")) td.displayFlags |= GF_TXT_VERTICAL;\n\t\t\t\t\t\tif (!strcmp(att->name, \"continuousKaraoke\")) td.displayFlags |= GF_TXT_KARAOKE;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tk=0;\n\t\t\t\twhile ((sub=(GF_XMLNode*)gf_list_enum(desc->content, &k))) {\n\t\t\t\t\tif (sub->type) continue;\n\t\t\t\t\tif (!strcmp(sub->name, \"defaultTextBox\")) tx3g_parse_text_box(import, sub, &td.default_pos);\n\t\t\t\t\telse if (!strcmp(sub->name, \"fontTable\")) {\n\t\t\t\t\t\tGF_XMLNode *ftable;\n\t\t\t\t\t\tu32 m=0;\n\t\t\t\t\t\twhile ((ftable=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tif (ftable->type) continue;\n\t\t\t\t\t\t\tif (!strcmp(ftable->name, \"font\")) {\n\t\t\t\t\t\t\t\tu32 n=0;\n\t\t\t\t\t\t\t\ttd.font_count += 1;\n\t\t\t\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_realloc(td.fonts, sizeof(GF_FontRecord)*td.font_count);\n\t\t\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(ftable->attributes, &n))) {\n\t\t\t\t\t\t\t\t\tif (!stricmp(att->name, \"id\")) td.fonts[td.font_count-1].fontID = atoi(att->value);\n\t\t\t\t\t\t\t\t\telse if (!stricmp(att->name, \"name\")) td.fonts[td.font_count-1].fontName = gf_strdup(att->value);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strcmp(sub->name, \"sharedStyles\")) {\n\t\t\t\t\t\tGF_XMLNode *style, *ftable;\n\t\t\t\t\t\tu32 m=0;\n\t\t\t\t\t\twhile ((style=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tif (style->type) continue;\n\t\t\t\t\t\t\tif (!strcmp(style->name, \"style\")) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (style) {\n\t\t\t\t\t\t\tchar *cur;\n\t\t\t\t\t\t\ts32 start=0;\n\t\t\t\t\t\t\tchar css_style[1024], css_val[1024];\n\t\t\t\t\t\t\tmemset(&styles[nb_styles], 0, sizeof(GF_StyleRecord));\n\t\t\t\t\t\t\tm=0;\n\t\t\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(style->attributes, &m))) {\n\t\t\t\t\t\t\t\tif (!strcmp(att->name, \"id\")) styles[nb_styles].startCharOffset = atoi(att->value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tm=0;\n\t\t\t\t\t\t\twhile ( (ftable=(GF_XMLNode*)gf_list_enum(style->content, &m))) {\n\t\t\t\t\t\t\t\tif (ftable->type) break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcur = ftable->name;\n\t\t\t\t\t\t\twhile (cur) {\n\t\t\t\t\t\t\t\tstart = gf_token_get_strip(cur, 0, \"{:\", \" \", css_style, 1024);\n\t\t\t\t\t\t\t\tif (start <0) break;\n\t\t\t\t\t\t\t\tstart = gf_token_get_strip(cur, start, \":}\", \" \", css_val, 1024);\n\t\t\t\t\t\t\t\tif (start <0) break;\n\t\t\t\t\t\t\t\tcur = strchr(cur+start, '{');\n\n\t\t\t\t\t\t\t\tif (!strcmp(css_style, \"font-table\")) {\n\t\t\t\t\t\t\t\t\tu32 z;\n\t\t\t\t\t\t\t\t\tstyles[nb_styles].fontID = atoi(css_val);\n\t\t\t\t\t\t\t\t\tfor (z=0; z<td.font_count; z++) {\n\t\t\t\t\t\t\t\t\t\tif (td.fonts[z].fontID == styles[nb_styles].fontID)\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"font-size\")) styles[nb_styles].font_size = atoi(css_val);\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"font-style\") && !strcmp(css_val, \"italic\")) styles[nb_styles].style_flags |= GF_TXT_STYLE_ITALIC;\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"font-weight\") && !strcmp(css_val, \"bold\")) styles[nb_styles].style_flags |= GF_TXT_STYLE_BOLD;\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"text-decoration\") && !strcmp(css_val, \"underline\")) styles[nb_styles].style_flags |= GF_TXT_STYLE_UNDERLINED;\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"color\")) styles[nb_styles].text_color = tx3g_get_color(import, css_val);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!nb_styles) td.default_style = styles[0];\n\t\t\t\t\t\t\tnb_styles++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif ((td.default_pos.bottom==td.default_pos.top) || (td.default_pos.right==td.default_pos.left)) {\n\t\t\t\t\ttd.default_pos.top = td.default_pos.left = 0;\n\t\t\t\t\ttd.default_pos.right = w;\n\t\t\t\t\ttd.default_pos.bottom = h;\n\t\t\t\t}\n\t\t\t\tif (!td.fonts) {\n\t\t\t\t\ttd.font_count = 1;\n\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\t\t\t\ttd.fonts[0].fontID = 1;\n\t\t\t\t\ttd.fonts[0].fontName = gf_strdup(\"Serif\");\n\t\t\t\t}\n\t\t\t\tgf_isom_text_has_similar_description(import->dest, track, &td, &descIndex, &same_box, &same_style);\n\t\t\t\tif (!descIndex) {\n\t\t\t\t\tgf_isom_new_text_description(import->dest, track, &td, NULL, NULL, &descIndex);\n\t\t\t\t\tsame_style = same_box = GF_TRUE;\n\t\t\t\t}\n\n\t\t\t\tfor (k=0; k<td.font_count; k++) gf_free(td.fonts[k].fontName);\n\t\t\t\tgf_free(td.fonts);\n\t\t\t\tnb_descs ++;\n\t\t\t}\n\t\t\telse if (!strcmp(desc->name, \"sampleData\")) {\n\t\t\t\tGF_XMLNode *sub;\n\t\t\t\tu16 start, end;\n\t\t\t\tu32 styleID;\n\t\t\t\tu32 nb_chars, txt_len, m;\n\t\t\t\tnb_chars = 0;\n\n\t\t\t\tsamp = gf_isom_new_text_sample();\n\n\t\t\t\tk=0;\n\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(desc->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"targetEncoding\") && !strcmp(att->value, \"utf16\")) ;//is_utf16 = 1;\n\t\t\t\t\telse if (!strcmp(att->name, \"scrollDelay\")) gf_isom_text_set_scroll_delay(samp, atoi(att->value) );\n\t\t\t\t\telse if (!strcmp(att->name, \"highlightColor\")) gf_isom_text_set_highlight_color_argb(samp, tx3g_get_color(import, att->value));\n\t\t\t\t}\n\t\t\t\tstart = end = 0;\n\t\t\t\tk=0;\n\t\t\t\twhile ((sub=(GF_XMLNode*)gf_list_enum(desc->content, &k))) {\n\t\t\t\t\tif (sub->type) continue;\n\t\t\t\t\tif (!strcmp(sub->name, \"text\")) {\n\t\t\t\t\t\tGF_XMLNode *text;\n\t\t\t\t\t\tstyleID = 0;\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"styleID\")) styleID = atoi(att->value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttxt_len = 0;\n\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((text=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tif (!text->type) {\n\t\t\t\t\t\t\t\tif (!strcmp(text->name, \"marker\")) {\n\t\t\t\t\t\t\t\t\tu32 z;\n\t\t\t\t\t\t\t\t\tmemset(&marks[nb_marks], 0, sizeof(Marker));\n\t\t\t\t\t\t\t\t\tmarks[nb_marks].pos = nb_chars+txt_len;\n\n\t\t\t\t\t\t\t\t\tz = 0;\n\t\t\t\t\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(text->attributes, &z))) {\n\t\t\t\t\t\t\t\t\t\tif (!strcmp(att->name, \"id\")) marks[nb_marks].id = atoi(att->value);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tnb_marks++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (text->type==GF_XML_TEXT_TYPE) {\n\t\t\t\t\t\t\t\ttxt_len += (u32) strlen(text->name);\n\t\t\t\t\t\t\t\tgf_isom_text_add_text(samp, text->name, (u32) strlen(text->name));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (styleID && (!same_style || (td.default_style.startCharOffset != styleID))) {\n\t\t\t\t\t\t\tGF_StyleRecord st = td.default_style;\n\t\t\t\t\t\t\tfor (m=0; m<nb_styles; m++) {\n\t\t\t\t\t\t\t\tif (styles[m].startCharOffset==styleID) {\n\t\t\t\t\t\t\t\t\tst = styles[m];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tst.startCharOffset = nb_chars;\n\t\t\t\t\t\t\tst.endCharOffset = nb_chars + txt_len;\n\t\t\t\t\t\t\tgf_isom_text_add_style(samp, &st);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnb_chars += txt_len;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"highlight\")) {\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_highlight(samp, start, end);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"blink\")) {\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_blink(samp, start, end);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"link\")) {\n\t\t\t\t\t\tchar *url, *url_tt;\n\t\t\t\t\t\turl = url_tt = NULL;\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"URL\") || !strcmp(att->name, \"href\")) url = gf_strdup(att->value);\n\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"URLToolTip\") || !strcmp(att->name, \"altString\")) url_tt = gf_strdup(att->value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_hyperlink(samp, url, url_tt, start, end);\n\t\t\t\t\t\tif (url) gf_free(url);\n\t\t\t\t\t\tif (url_tt) gf_free(url_tt);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"karaoke\")) {\n\t\t\t\t\t\tu32 time = 0;\n\t\t\t\t\t\tGF_XMLNode *krok;\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startTime\")) time = atoi(att->value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_karaoke(samp, time);\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((krok=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tu32 u=0;\n\t\t\t\t\t\t\tif (krok->type) continue;\n\t\t\t\t\t\t\tif (strcmp(krok->name, \"run\")) continue;\n\t\t\t\t\t\t\tstart = end = 0;\n\t\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(krok->attributes, &u))) {\n\t\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"duration\")) time += atoi(att->value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgf_isom_text_set_karaoke_segment(samp, time, start, end);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*OK, let's add the sample*/\n\t\tif (samp) {\n\t\t\tif (!same_box) gf_isom_text_set_box(samp, td.default_pos.top, td.default_pos.left, td.default_pos.bottom, td.default_pos.right);\n//\t\t\tif (!same_style) gf_isom_text_add_style(samp, &td.default_style);\n\n\t\t\ts = gf_isom_text_to_sample(samp);\n\t\t\tgf_isom_delete_text_sample(samp);\n\t\t\ts->IsRAP = isRAP ? RAP : RAP_NO;\n\t\t\ts->DTS = DTS;\n\t\t\tgf_isom_add_sample(import->dest, track, descIndex, s);\n\t\t\tgf_isom_sample_del(&s);\n\t\t\tnb_samples++;\n\t\t\tDTS += duration;\n\t\t\tgf_set_progress(\"Importing TeXML\", nb_samples, nb_children);\n\t\t\tif (import->duration && (DTS*1000> timescale*import->duration)) break;\n\t\t}\n\t}\n\tgf_isom_set_last_sample_duration(import->dest, track, 0);\n\tgf_set_progress(\"Importing TeXML\", nb_samples, nb_samples);\n\nexit:\n\tgf_xml_dom_del(parser);\n\treturn e;\n}\n\n\nGF_Err gf_import_timed_text(GF_MediaImporter *import)\n{\n\tGF_Err e;\n\tu32 fmt;\n\te = gf_text_guess_format(import->in_name, &fmt);\n\tif (e) return e;\n\tif (import->streamFormat) {\n\t\tif (!strcmp(import->streamFormat, \"VTT\")) fmt = GF_TEXT_IMPORT_WEBVTT;\n\t\telse if (!strcmp(import->streamFormat, \"TTML\")) fmt = GF_TEXT_IMPORT_TTML;\n\t\tif ((strstr(import->in_name, \".swf\") || strstr(import->in_name, \".SWF\")) && !stricmp(import->streamFormat, \"SVG\")) fmt = GF_TEXT_IMPORT_SWF_SVG;\n\t}\n\tif (!fmt) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTXT Import] Input %s does not look like a supported text format - ignoring\\n\", import->in_name));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tif (import->flags & GF_IMPORT_PROBE_ONLY) {\n\t\tif (fmt==GF_TEXT_IMPORT_SUB) import->flags |= GF_IMPORT_OVERRIDE_FPS;\n\t\treturn GF_OK;\n\t}\n\tswitch (fmt) {\n\tcase GF_TEXT_IMPORT_SRT:\n\t\treturn gf_text_import_srt(import);\n\tcase GF_TEXT_IMPORT_SUB:\n\t\treturn gf_text_import_sub(import);\n\tcase GF_TEXT_IMPORT_TTXT:\n\t\treturn gf_text_import_ttxt(import);\n\tcase GF_TEXT_IMPORT_TEXML:\n\t\treturn gf_text_import_texml(import);\n#ifndef GPAC_DISABLE_VTT\n\tcase GF_TEXT_IMPORT_WEBVTT:\n\t\treturn gf_text_import_webvtt(import);\n#endif\n\tcase GF_TEXT_IMPORT_SWF_SVG:\n\t\treturn gf_text_import_swf(import);\n\tcase GF_TEXT_IMPORT_TTML:\n\t\treturn gf_text_import_ttml(import);\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n}\n\n#endif /*GPAC_DISABLE_MEDIA_IMPORT*/\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n"], "filenames": ["applications/mp4client/main.c", "src/media_tools/text_import.c"], "buggy_code_start_loc": [1718, 208], "buggy_code_end_loc": [1719, 251], "fixing_code_start_loc": [1718, 208], "fixing_code_end_loc": [1719, 278], "type": "CWE-787", "message": "In GPAC 0.7.1 and earlier, gf_text_get_utf8_line in media_tools/text_import.c in libgpac_static.a allows an out-of-bounds write because of missing szLineConv bounds checking.", "other": {"cve": {"id": "CVE-2018-20763", "sourceIdentifier": "cve@mitre.org", "published": "2019-02-06T23:29:00.417", "lastModified": "2019-04-15T18:59:32.810", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In GPAC 0.7.1 and earlier, gf_text_get_utf8_line in media_tools/text_import.c in libgpac_static.a allows an out-of-bounds write because of missing szLineConv bounds checking."}, {"lang": "es", "value": "GPAC versi\u00f3n 0.7.1 y anteriores, gf_text_get_utf8_line en media_tools/text_import.c en libgpac_static.a permite una escritura fuera de l\u00edmites debido a la falta de comprobaci\u00f3n de l\u00edmites szLineConv."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac_project:gpac:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.7.1", "matchCriteriaId": "B4ED3B4A-F8B8-4E70-BDF7-811129A50B0F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/1c449a34fe0b50aaffb881bfb9d7c5ab0bb18cdd", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1188", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/02/msg00040.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3926-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/1c449a34fe0b50aaffb881bfb9d7c5ab0bb18cdd"}}