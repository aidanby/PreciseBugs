{"buggy_code": ["/*\n * Copyright 2011-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <folly/Random.h>\n\n#include <array>\n#include <atomic>\n#include <mutex>\n#include <random>\n\n#include <folly/File.h>\n#include <folly/FileUtil.h>\n#include <folly/SingletonThreadLocal.h>\n#include <folly/ThreadLocal.h>\n#include <folly/portability/SysTime.h>\n#include <folly/portability/Unistd.h>\n#include <folly/synchronization/CallOnce.h>\n#include <glog/logging.h>\n\n#ifdef _MSC_VER\n#include <wincrypt.h> // @manual\n#endif\n\nnamespace folly {\n\nnamespace {\n\nvoid readRandomDevice(void* data, size_t size) {\n#ifdef _MSC_VER\n  static folly::once_flag flag;\n  static HCRYPTPROV cryptoProv;\n  folly::call_once(flag, [&] {\n    if (!CryptAcquireContext(\n            &cryptoProv,\n            nullptr,\n            nullptr,\n            PROV_RSA_FULL,\n            CRYPT_VERIFYCONTEXT)) {\n      if (GetLastError() == NTE_BAD_KEYSET) {\n        // Mostly likely cause of this is that no key container\n        // exists yet, so try to create one.\n        PCHECK(CryptAcquireContext(\n            &cryptoProv, nullptr, nullptr, PROV_RSA_FULL, CRYPT_NEWKEYSET));\n      } else {\n        LOG(FATAL) << \"Failed to acquire the default crypto context.\";\n      }\n    }\n  });\n  CHECK(size <= std::numeric_limits<DWORD>::max());\n  PCHECK(CryptGenRandom(cryptoProv, (DWORD)size, (BYTE*)data));\n#else\n  // Keep the random device open for the duration of the program.\n  static int randomFd = ::open(\"/dev/urandom\", O_RDONLY);\n  PCHECK(randomFd >= 0);\n  auto bytesRead = readFull(randomFd, data, size);\n  PCHECK(bytesRead >= 0 && size_t(bytesRead) == size);\n#endif\n}\n\nclass BufferedRandomDevice {\n public:\n  static constexpr size_t kDefaultBufferSize = 128;\n\n  explicit BufferedRandomDevice(size_t bufferSize = kDefaultBufferSize);\n\n  void get(void* data, size_t size) {\n    if (LIKELY(size <= remaining())) {\n      memcpy(data, ptr_, size);\n      ptr_ += size;\n    } else {\n      getSlow(static_cast<unsigned char*>(data), size);\n    }\n  }\n\n private:\n  void getSlow(unsigned char* data, size_t size);\n\n  inline size_t remaining() const {\n    return size_t(buffer_.get() + bufferSize_ - ptr_);\n  }\n\n  const size_t bufferSize_;\n  std::unique_ptr<unsigned char[]> buffer_;\n  unsigned char* ptr_;\n};\n\nBufferedRandomDevice::BufferedRandomDevice(size_t bufferSize)\n  : bufferSize_(bufferSize),\n    buffer_(new unsigned char[bufferSize]),\n    ptr_(buffer_.get() + bufferSize) {  // refill on first use\n}\n\nvoid BufferedRandomDevice::getSlow(unsigned char* data, size_t size) {\n  DCHECK_GT(size, remaining());\n  if (size >= bufferSize_) {\n    // Just read directly.\n    readRandomDevice(data, size);\n    return;\n  }\n\n  size_t copied = remaining();\n  memcpy(data, ptr_, copied);\n  data += copied;\n  size -= copied;\n\n  // refill\n  readRandomDevice(buffer_.get(), bufferSize_);\n  ptr_ = buffer_.get();\n\n  memcpy(data, ptr_, size);\n  ptr_ += size;\n}\n\nstruct RandomTag {};\n\n} // namespace\n\nvoid Random::secureRandom(void* data, size_t size) {\n  using Single = SingletonThreadLocal<BufferedRandomDevice, RandomTag>;\n  Single::get().get(data, size);\n}\n\nThreadLocalPRNG::result_type ThreadLocalPRNG::operator()() {\n  struct Wrapper {\n    Random::DefaultGenerator object{Random::create()};\n  };\n  using Single = SingletonThreadLocal<Wrapper, RandomTag>;\n  return Single::get().object();\n}\n} // namespace folly\n", "/*\n * Copyright 2012-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <folly/Random.h>\n\n#include <algorithm>\n#include <random>\n#include <thread>\n#include <unordered_set>\n#include <vector>\n\n#include <glog/logging.h>\n\n#include <folly/portability/GTest.h>\n\nusing namespace folly;\n\nTEST(Random, StateSize) {\n  using namespace folly::detail;\n\n  // uint_fast32_t is uint64_t on x86_64, w00t\n  EXPECT_EQ(\n      sizeof(uint_fast32_t) / 4 + 3, StateSizeT<std::minstd_rand0>::value);\n  EXPECT_EQ(624, StateSizeT<std::mt19937>::value);\n#if FOLLY_HAVE_EXTRANDOM_SFMT19937\n  EXPECT_EQ(624, StateSizeT<__gnu_cxx::sfmt19937>::value);\n#endif\n  EXPECT_EQ(24, StateSizeT<std::ranlux24_base>::value);\n}\n\nTEST(Random, Simple) {\n  uint32_t prev = 0, seed = 0;\n  for (int i = 0; i < 1024; ++i) {\n    EXPECT_NE(seed = randomNumberSeed(), prev);\n    prev = seed;\n  }\n}\n\nTEST(Random, FixedSeed) {\n  // clang-format off\n  struct ConstantRNG {\n    typedef uint32_t result_type;\n    result_type operator()() {\n      return 4; // chosen by fair dice roll.\n                // guaranteed to be random.\n    }\n    static constexpr result_type min() {\n      return std::numeric_limits<result_type>::min();\n    }\n    static constexpr result_type max() {\n      return std::numeric_limits<result_type>::max();\n    }\n  };\n  // clang-format on\n\n  ConstantRNG gen;\n\n  // Pick a constant random number...\n  auto value = Random::rand32(10, gen);\n\n  // Loop to make sure it really is constant.\n  for (int i = 0; i < 1024; ++i) {\n    auto result = Random::rand32(10, gen);\n    EXPECT_EQ(value, result);\n  }\n}\n\nTEST(Random, MultiThreaded) {\n  const int n = 100;\n  std::vector<uint32_t> seeds(n);\n  std::vector<std::thread> threads;\n  for (int i = 0; i < n; ++i) {\n    threads.push_back(std::thread([i, &seeds] {\n      seeds[i] = randomNumberSeed();\n    }));\n  }\n  for (auto& t : threads) {\n    t.join();\n  }\n  std::sort(seeds.begin(), seeds.end());\n  for (int i = 0; i < n-1; ++i) {\n    EXPECT_LT(seeds[i], seeds[i+1]);\n  }\n}\n\nTEST(Random, sanity) {\n  // edge cases\n  EXPECT_EQ(folly::Random::rand32(0), 0);\n  EXPECT_EQ(folly::Random::rand32(12, 12), 0);\n  EXPECT_EQ(folly::Random::rand64(0), 0);\n  EXPECT_EQ(folly::Random::rand64(12, 12), 0);\n\n  // 32-bit repeatability, uniqueness\n  constexpr int kTestSize = 1000;\n  {\n    std::vector<uint32_t> vals;\n    folly::Random::DefaultGenerator rng;\n    rng.seed(0xdeadbeef);\n    for (int i = 0; i < kTestSize; ++i) {\n      vals.push_back(folly::Random::rand32(rng));\n    }\n    rng.seed(0xdeadbeef);\n    for (int i = 0; i < kTestSize; ++i) {\n      EXPECT_EQ(vals[i], folly::Random::rand32(rng));\n    }\n    EXPECT_EQ(\n        vals.size(),\n        std::unordered_set<uint32_t>(vals.begin(), vals.end()).size());\n  }\n\n  // 64-bit repeatability, uniqueness\n  {\n    std::vector<uint64_t> vals;\n    folly::Random::DefaultGenerator rng;\n    rng.seed(0xdeadbeef);\n    for (int i = 0; i < kTestSize; ++i) {\n      vals.push_back(folly::Random::rand64(rng));\n    }\n    rng.seed(0xdeadbeef);\n    for (int i = 0; i < kTestSize; ++i) {\n      EXPECT_EQ(vals[i], folly::Random::rand64(rng));\n    }\n    EXPECT_EQ(\n        vals.size(),\n        std::unordered_set<uint64_t>(vals.begin(), vals.end()).size());\n  }\n}\n"], "fixing_code": ["/*\n * Copyright 2011-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <folly/Random.h>\n\n#include <array>\n#include <atomic>\n#include <mutex>\n#include <random>\n\n#include <folly/File.h>\n#include <folly/FileUtil.h>\n#include <folly/SingletonThreadLocal.h>\n#include <folly/ThreadLocal.h>\n#include <folly/portability/SysTime.h>\n#include <folly/portability/Unistd.h>\n#include <folly/synchronization/CallOnce.h>\n#include <glog/logging.h>\n\n#ifdef _MSC_VER\n#include <wincrypt.h> // @manual\n#endif\n\nnamespace folly {\n\nnamespace {\n\nvoid readRandomDevice(void* data, size_t size) {\n#ifdef _MSC_VER\n  static folly::once_flag flag;\n  static HCRYPTPROV cryptoProv;\n  folly::call_once(flag, [&] {\n    if (!CryptAcquireContext(\n            &cryptoProv,\n            nullptr,\n            nullptr,\n            PROV_RSA_FULL,\n            CRYPT_VERIFYCONTEXT)) {\n      if (GetLastError() == NTE_BAD_KEYSET) {\n        // Mostly likely cause of this is that no key container\n        // exists yet, so try to create one.\n        PCHECK(CryptAcquireContext(\n            &cryptoProv, nullptr, nullptr, PROV_RSA_FULL, CRYPT_NEWKEYSET));\n      } else {\n        LOG(FATAL) << \"Failed to acquire the default crypto context.\";\n      }\n    }\n  });\n  CHECK(size <= std::numeric_limits<DWORD>::max());\n  PCHECK(CryptGenRandom(cryptoProv, (DWORD)size, (BYTE*)data));\n#else\n  // Keep the random device open for the duration of the program.\n  static int randomFd = ::open(\"/dev/urandom\", O_RDONLY);\n  PCHECK(randomFd >= 0);\n  auto bytesRead = readFull(randomFd, data, size);\n  PCHECK(bytesRead >= 0 && size_t(bytesRead) == size);\n#endif\n}\n\nclass BufferedRandomDevice {\n public:\n  static once_flag flag;\n  static constexpr size_t kDefaultBufferSize = 128;\n\n  explicit BufferedRandomDevice(size_t bufferSize = kDefaultBufferSize);\n\n  void get(void* data, size_t size) {\n    if (LIKELY(size <= remaining())) {\n      memcpy(data, ptr_, size);\n      ptr_ += size;\n    } else {\n      getSlow(static_cast<unsigned char*>(data), size);\n    }\n  }\n\n private:\n  void getSlow(unsigned char* data, size_t size);\n\n  inline size_t remaining() const {\n    return size_t(buffer_.get() + bufferSize_ - ptr_);\n  }\n\n  const size_t bufferSize_;\n  std::unique_ptr<unsigned char[]> buffer_;\n  unsigned char* ptr_;\n};\n\nonce_flag BufferedRandomDevice::flag;\nstruct RandomTag {};\n\nBufferedRandomDevice::BufferedRandomDevice(size_t bufferSize)\n  : bufferSize_(bufferSize),\n    buffer_(new unsigned char[bufferSize]),\n    ptr_(buffer_.get() + bufferSize) {  // refill on first use\n  call_once(flag, [this]() {\n    detail::AtFork::registerHandler(\n        this,\n        /*prepare*/ []() { return true; },\n        /*parent*/ []() {},\n        /*child*/\n        []() {\n          using Single = SingletonThreadLocal<BufferedRandomDevice, RandomTag>;\n          auto& t = Single::get();\n          // Clear out buffered data on fork.\n          //\n          // Ensure child and parent do not share same entropy pool.\n          t.ptr_ = t.buffer_.get() + t.bufferSize_;\n        });\n  });\n}\n\nvoid BufferedRandomDevice::getSlow(unsigned char* data, size_t size) {\n  DCHECK_GT(size, remaining());\n  if (size >= bufferSize_) {\n    // Just read directly.\n    readRandomDevice(data, size);\n    return;\n  }\n\n  size_t copied = remaining();\n  memcpy(data, ptr_, copied);\n  data += copied;\n  size -= copied;\n\n  // refill\n  readRandomDevice(buffer_.get(), bufferSize_);\n  ptr_ = buffer_.get();\n\n  memcpy(data, ptr_, size);\n  ptr_ += size;\n}\n\n} // namespace\n\nvoid Random::secureRandom(void* data, size_t size) {\n  using Single = SingletonThreadLocal<BufferedRandomDevice, RandomTag>;\n  Single::get().get(data, size);\n}\n\nThreadLocalPRNG::result_type ThreadLocalPRNG::operator()() {\n  struct Wrapper {\n    Random::DefaultGenerator object{Random::create()};\n  };\n  using Single = SingletonThreadLocal<Wrapper, RandomTag>;\n  return Single::get().object();\n}\n} // namespace folly\n", "/*\n * Copyright 2012-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <folly/Random.h>\n\n#include <algorithm>\n#include <random>\n#include <thread>\n#include <unordered_set>\n#include <vector>\n\n#include <glog/logging.h>\n\n#include <folly/portability/GTest.h>\n\nusing namespace folly;\n\nTEST(Random, StateSize) {\n  using namespace folly::detail;\n\n  // uint_fast32_t is uint64_t on x86_64, w00t\n  EXPECT_EQ(\n      sizeof(uint_fast32_t) / 4 + 3, StateSizeT<std::minstd_rand0>::value);\n  EXPECT_EQ(624, StateSizeT<std::mt19937>::value);\n#if FOLLY_HAVE_EXTRANDOM_SFMT19937\n  EXPECT_EQ(624, StateSizeT<__gnu_cxx::sfmt19937>::value);\n#endif\n  EXPECT_EQ(24, StateSizeT<std::ranlux24_base>::value);\n}\n\nTEST(Random, Simple) {\n  uint32_t prev = 0, seed = 0;\n  for (int i = 0; i < 1024; ++i) {\n    EXPECT_NE(seed = randomNumberSeed(), prev);\n    prev = seed;\n  }\n}\n\nTEST(Random, FixedSeed) {\n  // clang-format off\n  struct ConstantRNG {\n    typedef uint32_t result_type;\n    result_type operator()() {\n      return 4; // chosen by fair dice roll.\n                // guaranteed to be random.\n    }\n    static constexpr result_type min() {\n      return std::numeric_limits<result_type>::min();\n    }\n    static constexpr result_type max() {\n      return std::numeric_limits<result_type>::max();\n    }\n  };\n  // clang-format on\n\n  ConstantRNG gen;\n\n  // Pick a constant random number...\n  auto value = Random::rand32(10, gen);\n\n  // Loop to make sure it really is constant.\n  for (int i = 0; i < 1024; ++i) {\n    auto result = Random::rand32(10, gen);\n    EXPECT_EQ(value, result);\n  }\n}\n\nTEST(Random, MultiThreaded) {\n  const int n = 100;\n  std::vector<uint32_t> seeds(n);\n  std::vector<std::thread> threads;\n  for (int i = 0; i < n; ++i) {\n    threads.push_back(std::thread([i, &seeds] {\n      seeds[i] = randomNumberSeed();\n    }));\n  }\n  for (auto& t : threads) {\n    t.join();\n  }\n  std::sort(seeds.begin(), seeds.end());\n  for (int i = 0; i < n-1; ++i) {\n    EXPECT_LT(seeds[i], seeds[i+1]);\n  }\n}\n\nTEST(Random, sanity) {\n  // edge cases\n  EXPECT_EQ(folly::Random::rand32(0), 0);\n  EXPECT_EQ(folly::Random::rand32(12, 12), 0);\n  EXPECT_EQ(folly::Random::rand64(0), 0);\n  EXPECT_EQ(folly::Random::rand64(12, 12), 0);\n\n  // 32-bit repeatability, uniqueness\n  constexpr int kTestSize = 1000;\n  {\n    std::vector<uint32_t> vals;\n    folly::Random::DefaultGenerator rng;\n    rng.seed(0xdeadbeef);\n    for (int i = 0; i < kTestSize; ++i) {\n      vals.push_back(folly::Random::rand32(rng));\n    }\n    rng.seed(0xdeadbeef);\n    for (int i = 0; i < kTestSize; ++i) {\n      EXPECT_EQ(vals[i], folly::Random::rand32(rng));\n    }\n    EXPECT_EQ(\n        vals.size(),\n        std::unordered_set<uint32_t>(vals.begin(), vals.end()).size());\n  }\n\n  // 64-bit repeatability, uniqueness\n  {\n    std::vector<uint64_t> vals;\n    folly::Random::DefaultGenerator rng;\n    rng.seed(0xdeadbeef);\n    for (int i = 0; i < kTestSize; ++i) {\n      vals.push_back(folly::Random::rand64(rng));\n    }\n    rng.seed(0xdeadbeef);\n    for (int i = 0; i < kTestSize; ++i) {\n      EXPECT_EQ(vals[i], folly::Random::rand64(rng));\n    }\n    EXPECT_EQ(\n        vals.size(),\n        std::unordered_set<uint64_t>(vals.begin(), vals.end()).size());\n  }\n}\n\nTEST(Random, SecureFork) {\n  unsigned char buffer = 0;\n  // Init random buffer\n  folly::Random::secureRandom(&buffer, 1);\n\n  auto pid = fork();\n  EXPECT_NE(pid, -1);\n  if (pid) {\n    // parent\n    int status = 0;\n    folly::Random::secureRandom(&buffer, 1);\n    auto pid2 = wait(&status);\n    EXPECT_NE(WEXITSTATUS(status), buffer);\n    EXPECT_EQ(pid, pid2);\n  } else {\n    // child\n    folly::Random::secureRandom(&buffer, 1);\n    exit(buffer); // Do not print gtest results\n  }\n}\n"], "filenames": ["folly/Random.cpp", "folly/test/RandomTest.cpp"], "buggy_code_start_loc": [74, 140], "buggy_code_end_loc": [129, 140], "fixing_code_start_loc": [75, 141], "fixing_code_end_loc": [145, 162], "type": "CWE-119", "message": "folly::secureRandom will re-use a buffer between parent and child processes when fork() is called. That will result in multiple forked children producing repeat (or similar) results. This affects HHVM 3.26 prior to 3.26.3 and the folly library between v2017.12.11.00 and v2018.08.09.00.", "other": {"cve": {"id": "CVE-2018-6337", "sourceIdentifier": "cve-assign@fb.com", "published": "2018-12-31T22:29:00.247", "lastModified": "2019-10-09T23:41:46.690", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "folly::secureRandom will re-use a buffer between parent and child processes when fork() is called. That will result in multiple forked children producing repeat (or similar) results. This affects HHVM 3.26 prior to 3.26.3 and the folly library between v2017.12.11.00 and v2018.08.09.00."}, {"lang": "es", "value": "folly::secureRandom reutilizar\u00e1 un b\u00fafer entre los procesos padre e hijo cuando una bifurcaci\u00f3n() es llamada. Esto resultar\u00e1 en m\u00faltiples hijos bifurcados, produciendo resultados repetidos o similares. Esto afecta a las versiones de HHVM 3.26 anteriores a la 3.26.3 y a la librer\u00eda folly entre las versiones v2017.12.11.00 y v2018.08.09.00."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}, {"source": "cve-assign@fb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-212"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:folly:*:*:*:*:*:*:*:*", "versionStartIncluding": "2017.12.11.00", "versionEndIncluding": "2018.08.09.00", "matchCriteriaId": "C5CE5C5F-6B35-4243-BE99-CFB558D74996"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.26", "versionEndExcluding": "3.26.3", "matchCriteriaId": "1797EA50-9525-49CC-86B0-70DD9C573732"}]}]}], "references": [{"url": "https://github.com/facebook/folly/commit/8e927ee48b114c8a2f90d0cbd5ac753795a6761f", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/facebook/hhvm/commit/e2d10a1e32d01f71aaadd81169bcb9ae86c5d6b8", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://hhvm.com/blog/2018/05/24/hhvm-3.26.3.html", "source": "cve-assign@fb.com", "tags": ["Release Notes", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/facebook/folly/commit/8e927ee48b114c8a2f90d0cbd5ac753795a6761f"}}