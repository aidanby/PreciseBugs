{"buggy_code": ["package logic\n\nimport (\n\t\"errors\"\n\t\"time\"\n\n\t\"github.com/golang-jwt/jwt/v4\"\n\t\"github.com/gravitl/netmaker/models\"\n\t\"github.com/gravitl/netmaker/servercfg\"\n)\n\nvar jwtSecretKey = []byte(\"(BytesOverTheWire)\")\n\n// CreateJWT func will used to create the JWT while signing in and signing out\nfunc CreateJWT(uuid string, macAddress string, network string) (response string, err error) {\n\texpirationTime := time.Now().Add(5 * time.Minute)\n\tclaims := &models.Claims{\n\t\tID:         uuid,\n\t\tNetwork:    network,\n\t\tMacAddress: macAddress,\n\t\tStandardClaims: jwt.StandardClaims{\n\t\t\tExpiresAt: expirationTime.Unix(),\n\t\t},\n\t}\n\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\ttokenString, err := token.SignedString(jwtSecretKey)\n\tif err == nil {\n\t\treturn tokenString, nil\n\t}\n\treturn \"\", err\n}\n\n// CreateUserJWT - creates a user jwt token\nfunc CreateUserJWT(username string, networks []string, isadmin bool) (response string, err error) {\n\texpirationTime := time.Now().Add(60 * 12 * time.Minute)\n\tclaims := &models.UserClaims{\n\t\tUserName: username,\n\t\tNetworks: networks,\n\t\tIsAdmin:  isadmin,\n\t\tStandardClaims: jwt.StandardClaims{\n\t\t\tExpiresAt: expirationTime.Unix(),\n\t\t},\n\t}\n\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\ttokenString, err := token.SignedString(jwtSecretKey)\n\tif err == nil {\n\t\treturn tokenString, nil\n\t}\n\treturn \"\", err\n}\n\n// VerifyToken func will used to Verify the JWT Token while using APIS\nfunc VerifyUserToken(tokenString string) (username string, networks []string, isadmin bool, err error) {\n\tclaims := &models.UserClaims{}\n\n\tif tokenString == servercfg.GetMasterKey() {\n\t\treturn \"masteradministrator\", nil, true, nil\n\t}\n\n\ttoken, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {\n\t\treturn jwtSecretKey, nil\n\t})\n\n\tif token != nil && token.Valid {\n\t\t// check that user exists\n\t\tif user, err := GetUser(claims.UserName); user.UserName != \"\" && err == nil {\n\t\t\treturn claims.UserName, claims.Networks, claims.IsAdmin, nil\n\t\t}\n\t\terr = errors.New(\"user does not exist\")\n\t}\n\treturn \"\", nil, false, err\n}\n\n// VerifyToken - gRPC [nodes] Only\nfunc VerifyToken(tokenString string) (nodeID string, mac string, network string, err error) {\n\tclaims := &models.Claims{}\n\n\t//this may be a stupid way of serving up a master key\n\t//TODO: look into a different method. Encryption?\n\tif tokenString == servercfg.GetMasterKey() {\n\t\treturn \"mastermac\", \"\", \"\", nil\n\t}\n\n\ttoken, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {\n\t\treturn jwtSecretKey, nil\n\t})\n\n\tif token != nil {\n\t\treturn claims.ID, claims.MacAddress, claims.Network, nil\n\t}\n\treturn \"\", \"\", \"\", err\n}\n", "package logic\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/gravitl/netmaker/database\"\n)\n\ntype serverData struct {\n\tPrivateKey string `json:\"privatekey,omitempty\" bson:\"privatekey,omitempty\"`\n}\n\n// StorePrivKey - stores server client WireGuard privatekey if needed\nfunc StorePrivKey(serverID string, privateKey string) error {\n\tvar newData = serverData{}\n\tvar err error\n\tvar data []byte\n\tnewData.PrivateKey = privateKey\n\tdata, err = json.Marshal(&newData)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn database.Insert(serverID, string(data), database.SERVERCONF_TABLE_NAME)\n}\n\n// FetchPrivKey - fetches private key\nfunc FetchPrivKey(serverID string) (string, error) {\n\tvar dbData string\n\tvar err error\n\tvar fetchedData = serverData{}\n\tdbData, err = database.FetchRecord(database.SERVERCONF_TABLE_NAME, serverID)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\terr = json.Unmarshal([]byte(dbData), &fetchedData)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn fetchedData.PrivateKey, nil\n}\n\n// RemovePrivKey - removes a private key\nfunc RemovePrivKey(serverID string) error {\n\treturn database.DeleteRecord(database.SERVERCONF_TABLE_NAME, serverID)\n}\n", "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"os/signal\"\n\t\"runtime/debug\"\n\t\"strconv\"\n\t\"sync\"\n\t\"syscall\"\n\n\t\"github.com/gravitl/netmaker/auth\"\n\tcontroller \"github.com/gravitl/netmaker/controllers\"\n\t\"github.com/gravitl/netmaker/database\"\n\t\"github.com/gravitl/netmaker/functions\"\n\tnodepb \"github.com/gravitl/netmaker/grpc\"\n\t\"github.com/gravitl/netmaker/logger\"\n\t\"github.com/gravitl/netmaker/logic\"\n\t\"github.com/gravitl/netmaker/models\"\n\t\"github.com/gravitl/netmaker/mq\"\n\t\"github.com/gravitl/netmaker/netclient/ncutils\"\n\t\"github.com/gravitl/netmaker/servercfg\"\n\t\"github.com/gravitl/netmaker/serverctl\"\n\t\"google.golang.org/grpc\"\n)\n\nvar version = \"dev\"\n\n// Start DB Connection and start API Request Handler\nfunc main() {\n\tservercfg.SetVersion(version)\n\tfmt.Println(models.RetrieveLogo()) // print the logo\n\tinitialize()                       // initial db and grpc server\n\tsetGarbageCollection()\n\tdefer database.CloseDB()\n\tstartControllers() // start the grpc or rest endpoints\n}\n\nfunc initialize() { // Client Mode Prereq Check\n\tvar err error\n\n\tif servercfg.GetNodeID() == \"\" {\n\t\tlogger.FatalLog(\"error: must set NODE_ID, currently blank\")\n\t}\n\n\tif err = database.InitializeDatabase(); err != nil {\n\t\tlogger.FatalLog(\"Error connecting to database\")\n\t}\n\tlogger.Log(0, \"database successfully connected\")\n\n\terr = logic.TimerCheckpoint()\n\tif err != nil {\n\t\tlogger.Log(1, \"Timer error occurred: \", err.Error())\n\t}\n\tvar authProvider = auth.InitializeAuthProvider()\n\tif authProvider != \"\" {\n\t\tlogger.Log(0, \"OAuth provider,\", authProvider+\",\", \"initialized\")\n\t} else {\n\t\tlogger.Log(0, \"no OAuth provider found or not configured, continuing without OAuth\")\n\t}\n\n\tif servercfg.IsClientMode() != \"off\" {\n\t\toutput, err := ncutils.RunCmd(\"id -u\", true)\n\t\tif err != nil {\n\t\t\tlogger.FatalLog(\"Error running 'id -u' for prereq check. Please investigate or disable client mode.\", output, err.Error())\n\t\t}\n\t\tuid, err := strconv.Atoi(string(output[:len(output)-1]))\n\t\tif err != nil {\n\t\t\tlogger.FatalLog(\"Error retrieving uid from 'id -u' for prereq check. Please investigate or disable client mode.\", err.Error())\n\t\t}\n\t\tif uid != 0 {\n\t\t\tlogger.FatalLog(\"To run in client mode requires root privileges. Either disable client mode or run with sudo.\")\n\t\t}\n\t\tif err := serverctl.InitServerNetclient(); err != nil {\n\t\t\tlogger.FatalLog(\"Did not find netclient to use CLIENT_MODE\")\n\t\t}\n\t}\n\t// initialize iptables to ensure gateways work correctly and mq is forwarded if containerized\n\tif servercfg.ManageIPTables() != \"off\" {\n\t\tif err = serverctl.InitIPTables(); err != nil {\n\t\t\tlogger.FatalLog(\"Unable to initialize iptables on host:\", err.Error())\n\n\t\t}\n\t}\n\n\tif servercfg.IsDNSMode() {\n\t\terr := functions.SetDNSDir()\n\t\tif err != nil {\n\t\t\tlogger.FatalLog(err.Error())\n\t\t}\n\t}\n}\n\nfunc startControllers() {\n\tvar waitnetwork sync.WaitGroup\n\t//Run Agent Server\n\tif servercfg.IsAgentBackend() {\n\t\tif !(servercfg.DisableRemoteIPCheck()) && servercfg.GetGRPCHost() == \"127.0.0.1\" {\n\t\t\terr := servercfg.SetHost()\n\t\t\tif err != nil {\n\t\t\t\tlogger.FatalLog(\"Unable to Set host. Exiting...\", err.Error())\n\t\t\t}\n\t\t}\n\t\twaitnetwork.Add(1)\n\t\tgo runGRPC(&waitnetwork)\n\t}\n\n\tif servercfg.IsDNSMode() {\n\t\terr := logic.SetDNS()\n\t\tif err != nil {\n\t\t\tlogger.Log(0, \"error occurred initializing DNS: \", err.Error())\n\t\t}\n\t}\n\t//Run Rest Server\n\tif servercfg.IsRestBackend() {\n\t\tif !servercfg.DisableRemoteIPCheck() && servercfg.GetAPIHost() == \"127.0.0.1\" {\n\t\t\terr := servercfg.SetHost()\n\t\t\tif err != nil {\n\t\t\t\tlogger.FatalLog(\"Unable to Set host. Exiting...\", err.Error())\n\t\t\t}\n\t\t}\n\t\twaitnetwork.Add(1)\n\t\tgo controller.HandleRESTRequests(&waitnetwork)\n\t}\n\n\t//Run MessageQueue\n\tif servercfg.IsMessageQueueBackend() {\n\t\twaitnetwork.Add(1)\n\t\tgo runMessageQueue(&waitnetwork)\n\t}\n\n\tif !servercfg.IsAgentBackend() && !servercfg.IsRestBackend() && !servercfg.IsMessageQueueBackend() {\n\t\tlogger.Log(0, \"No Server Mode selected, so nothing is being served! Set Agent mode (AGENT_BACKEND) or Rest mode (REST_BACKEND) or MessageQueue (MESSAGEQUEUE_BACKEND) to 'true'.\")\n\t}\n\n\twaitnetwork.Wait()\n}\n\nfunc runGRPC(wg *sync.WaitGroup) {\n\n\tdefer wg.Done()\n\n\tgrpcport := servercfg.GetGRPCPort()\n\n\tlistener, err := net.Listen(\"tcp\", \":\"+grpcport)\n\t// Handle errors if any\n\tif err != nil {\n\t\tlogger.FatalLog(\"[netmaker] Unable to listen on port\", grpcport, \": error:\", err.Error())\n\t}\n\n\ts := grpc.NewServer(\n\t\tauthServerUnaryInterceptor(),\n\t)\n\t// Create NodeService type\n\tsrv := &controller.NodeServiceServer{}\n\n\t// Register the service with the server\n\tnodepb.RegisterNodeServiceServer(s, srv)\n\n\t// Start the server in a child routine\n\tgo func() {\n\t\tif err := s.Serve(listener); err != nil {\n\t\t\tlogger.FatalLog(\"Failed to serve:\", err.Error())\n\t\t}\n\t}()\n\tlogger.Log(0, \"Agent Server successfully started on port \", grpcport, \"(gRPC)\")\n\n\t// Relay os.Interrupt to our channel (os.Interrupt = CTRL+C)\n\t// Ignore other incoming signals\n\tctx, stop := signal.NotifyContext(context.TODO(), os.Interrupt)\n\tdefer stop()\n\n\t// Block main routine until a signal is received\n\t// As long as user doesn't press CTRL+C a message is not passed and our main routine keeps running\n\t<-ctx.Done()\n\n\t// After receiving CTRL+C Properly stop the server\n\tlogger.Log(0, \"Stopping the Agent server...\")\n\ts.GracefulStop()\n\tlistener.Close()\n\tlogger.Log(0, \"Agent server closed..\")\n\tlogger.Log(0, \"Closed DB connection.\")\n}\n\n// Should we be using a context vice a waitgroup????????????\nfunc runMessageQueue(wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tlogger.Log(0, fmt.Sprintf(\"connecting to mq broker at %s\", servercfg.GetMessageQueueEndpoint()))\n\tvar client = mq.SetupMQTT(false) // Set up the subscription listener\n\tctx, cancel := context.WithCancel(context.Background())\n\tgo mq.Keepalive(ctx)\n\tquit := make(chan os.Signal, 1)\n\tsignal.Notify(quit, syscall.SIGTERM, os.Interrupt)\n\t<-quit\n\tcancel()\n\tlogger.Log(0, \"Message Queue shutting down\")\n\tclient.Disconnect(250)\n}\n\nfunc authServerUnaryInterceptor() grpc.ServerOption {\n\treturn grpc.UnaryInterceptor(controller.AuthServerUnaryInterceptor)\n}\n\nfunc setGarbageCollection() {\n\t_, gcset := os.LookupEnv(\"GOGC\")\n\tif !gcset {\n\t\tdebug.SetGCPercent(ncutils.DEFAULT_GC_PERCENT)\n\t}\n}\n"], "fixing_code": ["package logic\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/golang-jwt/jwt/v4\"\n\t\"github.com/gravitl/netmaker/logger\"\n\t\"github.com/gravitl/netmaker/models\"\n\t\"github.com/gravitl/netmaker/servercfg\"\n)\n\nvar jwtSecretKey []byte\n\n// SetJWTSecret - sets the jwt secret on server startup\nfunc SetJWTSecret() {\n\tcurrentSecret, jwtErr := FetchJWTSecret()\n\tif jwtErr != nil {\n\t\tjwtSecretKey = []byte(RandomString(64)) // 512 bit random password\n\t\tif err := StoreJWTSecret(string(jwtSecretKey)); err != nil {\n\t\t\tlogger.FatalLog(\"something went wrong when configuring JWT authentication\")\n\t\t}\n\t} else {\n\t\tjwtSecretKey = []byte(currentSecret)\n\t}\n}\n\n// CreateJWT func will used to create the JWT while signing in and signing out\nfunc CreateJWT(uuid string, macAddress string, network string) (response string, err error) {\n\texpirationTime := time.Now().Add(5 * time.Minute)\n\tclaims := &models.Claims{\n\t\tID:         uuid,\n\t\tNetwork:    network,\n\t\tMacAddress: macAddress,\n\t\tStandardClaims: jwt.StandardClaims{\n\t\t\tIssuer:    \"Netmaker\",\n\t\t\tSubject:   fmt.Sprintf(\"node|%s\", uuid),\n\t\t\tIssuedAt:  time.Now().Unix(),\n\t\t\tExpiresAt: expirationTime.Unix(),\n\t\t},\n\t}\n\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\ttokenString, err := token.SignedString(jwtSecretKey)\n\tif err == nil {\n\t\treturn tokenString, nil\n\t}\n\treturn \"\", err\n}\n\n// CreateUserJWT - creates a user jwt token\nfunc CreateUserJWT(username string, networks []string, isadmin bool) (response string, err error) {\n\texpirationTime := time.Now().Add(60 * 12 * time.Minute)\n\tclaims := &models.UserClaims{\n\t\tUserName: username,\n\t\tNetworks: networks,\n\t\tIsAdmin:  isadmin,\n\t\tStandardClaims: jwt.StandardClaims{\n\t\t\tIssuer:    \"Netmaker\",\n\t\t\tIssuedAt:  time.Now().Unix(),\n\t\t\tSubject:   fmt.Sprintf(\"user|%s\", username),\n\t\t\tExpiresAt: expirationTime.Unix(),\n\t\t},\n\t}\n\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\ttokenString, err := token.SignedString(jwtSecretKey)\n\tif err == nil {\n\t\treturn tokenString, nil\n\t}\n\treturn \"\", err\n}\n\n// VerifyToken func will used to Verify the JWT Token while using APIS\nfunc VerifyUserToken(tokenString string) (username string, networks []string, isadmin bool, err error) {\n\tclaims := &models.UserClaims{}\n\n\tif tokenString == servercfg.GetMasterKey() {\n\t\treturn \"masteradministrator\", nil, true, nil\n\t}\n\n\ttoken, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {\n\t\treturn jwtSecretKey, nil\n\t})\n\n\tif token != nil && token.Valid {\n\t\t// check that user exists\n\t\tif user, err := GetUser(claims.UserName); user.UserName != \"\" && err == nil {\n\t\t\treturn claims.UserName, claims.Networks, claims.IsAdmin, nil\n\t\t}\n\t\terr = errors.New(\"user does not exist\")\n\t}\n\treturn \"\", nil, false, err\n}\n\n// VerifyToken - gRPC [nodes] Only\nfunc VerifyToken(tokenString string) (nodeID string, mac string, network string, err error) {\n\tclaims := &models.Claims{}\n\n\t//this may be a stupid way of serving up a master key\n\t//TODO: look into a different method. Encryption?\n\tif tokenString == servercfg.GetMasterKey() {\n\t\treturn \"mastermac\", \"\", \"\", nil\n\t}\n\n\ttoken, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {\n\t\treturn jwtSecretKey, nil\n\t})\n\n\tif token != nil {\n\t\treturn claims.ID, claims.MacAddress, claims.Network, nil\n\t}\n\treturn \"\", \"\", \"\", err\n}\n", "package logic\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/gravitl/netmaker/database\"\n)\n\ntype serverData struct {\n\tPrivateKey string `json:\"privatekey,omitempty\" bson:\"privatekey,omitempty\"`\n}\n\n// StorePrivKey - stores server client WireGuard privatekey if needed\nfunc StorePrivKey(serverID string, privateKey string) error {\n\tvar newData = serverData{}\n\tvar err error\n\tvar data []byte\n\tnewData.PrivateKey = privateKey\n\tdata, err = json.Marshal(&newData)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn database.Insert(serverID, string(data), database.SERVERCONF_TABLE_NAME)\n}\n\n// FetchPrivKey - fetches private key\nfunc FetchPrivKey(serverID string) (string, error) {\n\tvar dbData string\n\tvar err error\n\tvar fetchedData = serverData{}\n\tdbData, err = database.FetchRecord(database.SERVERCONF_TABLE_NAME, serverID)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\terr = json.Unmarshal([]byte(dbData), &fetchedData)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn fetchedData.PrivateKey, nil\n}\n\n// RemovePrivKey - removes a private key\nfunc RemovePrivKey(serverID string) error {\n\treturn database.DeleteRecord(database.SERVERCONF_TABLE_NAME, serverID)\n}\n\n// FetchJWTSecret - fetches jwt secret from db\nfunc FetchJWTSecret() (string, error) {\n\tvar dbData string\n\tvar err error\n\tvar fetchedData = serverData{}\n\tdbData, err = database.FetchRecord(database.SERVERCONF_TABLE_NAME, \"nm-jwt-secret\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\terr = json.Unmarshal([]byte(dbData), &fetchedData)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn fetchedData.PrivateKey, nil\n}\n\n// StoreJWTSecret - stores server jwt secret if needed\nfunc StoreJWTSecret(privateKey string) error {\n\tvar newData = serverData{}\n\tvar err error\n\tvar data []byte\n\tnewData.PrivateKey = privateKey\n\tdata, err = json.Marshal(&newData)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn database.Insert(\"nm-jwt-secret\", string(data), database.SERVERCONF_TABLE_NAME)\n}\n", "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"os/signal\"\n\t\"runtime/debug\"\n\t\"strconv\"\n\t\"sync\"\n\t\"syscall\"\n\n\t\"github.com/gravitl/netmaker/auth\"\n\tcontroller \"github.com/gravitl/netmaker/controllers\"\n\t\"github.com/gravitl/netmaker/database\"\n\t\"github.com/gravitl/netmaker/functions\"\n\tnodepb \"github.com/gravitl/netmaker/grpc\"\n\t\"github.com/gravitl/netmaker/logger\"\n\t\"github.com/gravitl/netmaker/logic\"\n\t\"github.com/gravitl/netmaker/models\"\n\t\"github.com/gravitl/netmaker/mq\"\n\t\"github.com/gravitl/netmaker/netclient/ncutils\"\n\t\"github.com/gravitl/netmaker/servercfg\"\n\t\"github.com/gravitl/netmaker/serverctl\"\n\t\"google.golang.org/grpc\"\n)\n\nvar version = \"dev\"\n\n// Start DB Connection and start API Request Handler\nfunc main() {\n\tservercfg.SetVersion(version)\n\tfmt.Println(models.RetrieveLogo()) // print the logo\n\tinitialize()                       // initial db and grpc server\n\tsetGarbageCollection()\n\tdefer database.CloseDB()\n\tstartControllers() // start the grpc or rest endpoints\n}\n\nfunc initialize() { // Client Mode Prereq Check\n\tvar err error\n\tif servercfg.GetNodeID() == \"\" {\n\t\tlogger.FatalLog(\"error: must set NODE_ID, currently blank\")\n\t}\n\n\tif err = database.InitializeDatabase(); err != nil {\n\t\tlogger.FatalLog(\"Error connecting to database\")\n\t}\n\tlogger.Log(0, \"database successfully connected\")\n\tlogic.SetJWTSecret()\n\n\terr = logic.TimerCheckpoint()\n\tif err != nil {\n\t\tlogger.Log(1, \"Timer error occurred: \", err.Error())\n\t}\n\tvar authProvider = auth.InitializeAuthProvider()\n\tif authProvider != \"\" {\n\t\tlogger.Log(0, \"OAuth provider,\", authProvider+\",\", \"initialized\")\n\t} else {\n\t\tlogger.Log(0, \"no OAuth provider found or not configured, continuing without OAuth\")\n\t}\n\n\tif servercfg.IsClientMode() != \"off\" {\n\t\toutput, err := ncutils.RunCmd(\"id -u\", true)\n\t\tif err != nil {\n\t\t\tlogger.FatalLog(\"Error running 'id -u' for prereq check. Please investigate or disable client mode.\", output, err.Error())\n\t\t}\n\t\tuid, err := strconv.Atoi(string(output[:len(output)-1]))\n\t\tif err != nil {\n\t\t\tlogger.FatalLog(\"Error retrieving uid from 'id -u' for prereq check. Please investigate or disable client mode.\", err.Error())\n\t\t}\n\t\tif uid != 0 {\n\t\t\tlogger.FatalLog(\"To run in client mode requires root privileges. Either disable client mode or run with sudo.\")\n\t\t}\n\t\tif err := serverctl.InitServerNetclient(); err != nil {\n\t\t\tlogger.FatalLog(\"Did not find netclient to use CLIENT_MODE\")\n\t\t}\n\t}\n\t// initialize iptables to ensure gateways work correctly and mq is forwarded if containerized\n\tif servercfg.ManageIPTables() != \"off\" {\n\t\tif err = serverctl.InitIPTables(); err != nil {\n\t\t\tlogger.FatalLog(\"Unable to initialize iptables on host:\", err.Error())\n\n\t\t}\n\t}\n\n\tif servercfg.IsDNSMode() {\n\t\terr := functions.SetDNSDir()\n\t\tif err != nil {\n\t\t\tlogger.FatalLog(err.Error())\n\t\t}\n\t}\n}\n\nfunc startControllers() {\n\tvar waitnetwork sync.WaitGroup\n\t//Run Agent Server\n\tif servercfg.IsAgentBackend() {\n\t\tif !(servercfg.DisableRemoteIPCheck()) && servercfg.GetGRPCHost() == \"127.0.0.1\" {\n\t\t\terr := servercfg.SetHost()\n\t\t\tif err != nil {\n\t\t\t\tlogger.FatalLog(\"Unable to Set host. Exiting...\", err.Error())\n\t\t\t}\n\t\t}\n\t\twaitnetwork.Add(1)\n\t\tgo runGRPC(&waitnetwork)\n\t}\n\n\tif servercfg.IsDNSMode() {\n\t\terr := logic.SetDNS()\n\t\tif err != nil {\n\t\t\tlogger.Log(0, \"error occurred initializing DNS: \", err.Error())\n\t\t}\n\t}\n\t//Run Rest Server\n\tif servercfg.IsRestBackend() {\n\t\tif !servercfg.DisableRemoteIPCheck() && servercfg.GetAPIHost() == \"127.0.0.1\" {\n\t\t\terr := servercfg.SetHost()\n\t\t\tif err != nil {\n\t\t\t\tlogger.FatalLog(\"Unable to Set host. Exiting...\", err.Error())\n\t\t\t}\n\t\t}\n\t\twaitnetwork.Add(1)\n\t\tgo controller.HandleRESTRequests(&waitnetwork)\n\t}\n\n\t//Run MessageQueue\n\tif servercfg.IsMessageQueueBackend() {\n\t\twaitnetwork.Add(1)\n\t\tgo runMessageQueue(&waitnetwork)\n\t}\n\n\tif !servercfg.IsAgentBackend() && !servercfg.IsRestBackend() && !servercfg.IsMessageQueueBackend() {\n\t\tlogger.Log(0, \"No Server Mode selected, so nothing is being served! Set Agent mode (AGENT_BACKEND) or Rest mode (REST_BACKEND) or MessageQueue (MESSAGEQUEUE_BACKEND) to 'true'.\")\n\t}\n\n\twaitnetwork.Wait()\n}\n\nfunc runGRPC(wg *sync.WaitGroup) {\n\n\tdefer wg.Done()\n\n\tgrpcport := servercfg.GetGRPCPort()\n\n\tlistener, err := net.Listen(\"tcp\", \":\"+grpcport)\n\t// Handle errors if any\n\tif err != nil {\n\t\tlogger.FatalLog(\"[netmaker] Unable to listen on port\", grpcport, \": error:\", err.Error())\n\t}\n\n\ts := grpc.NewServer(\n\t\tauthServerUnaryInterceptor(),\n\t)\n\t// Create NodeService type\n\tsrv := &controller.NodeServiceServer{}\n\n\t// Register the service with the server\n\tnodepb.RegisterNodeServiceServer(s, srv)\n\n\t// Start the server in a child routine\n\tgo func() {\n\t\tif err := s.Serve(listener); err != nil {\n\t\t\tlogger.FatalLog(\"Failed to serve:\", err.Error())\n\t\t}\n\t}()\n\tlogger.Log(0, \"Agent Server successfully started on port \", grpcport, \"(gRPC)\")\n\n\t// Relay os.Interrupt to our channel (os.Interrupt = CTRL+C)\n\t// Ignore other incoming signals\n\tctx, stop := signal.NotifyContext(context.TODO(), os.Interrupt)\n\tdefer stop()\n\n\t// Block main routine until a signal is received\n\t// As long as user doesn't press CTRL+C a message is not passed and our main routine keeps running\n\t<-ctx.Done()\n\n\t// After receiving CTRL+C Properly stop the server\n\tlogger.Log(0, \"Stopping the Agent server...\")\n\ts.GracefulStop()\n\tlistener.Close()\n\tlogger.Log(0, \"Agent server closed..\")\n\tlogger.Log(0, \"Closed DB connection.\")\n}\n\n// Should we be using a context vice a waitgroup????????????\nfunc runMessageQueue(wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tlogger.Log(0, fmt.Sprintf(\"connecting to mq broker at %s\", servercfg.GetMessageQueueEndpoint()))\n\tvar client = mq.SetupMQTT(false) // Set up the subscription listener\n\tctx, cancel := context.WithCancel(context.Background())\n\tgo mq.Keepalive(ctx)\n\tquit := make(chan os.Signal, 1)\n\tsignal.Notify(quit, syscall.SIGTERM, os.Interrupt)\n\t<-quit\n\tcancel()\n\tlogger.Log(0, \"Message Queue shutting down\")\n\tclient.Disconnect(250)\n}\n\nfunc authServerUnaryInterceptor() grpc.ServerOption {\n\treturn grpc.UnaryInterceptor(controller.AuthServerUnaryInterceptor)\n}\n\nfunc setGarbageCollection() {\n\t_, gcset := os.LookupEnv(\"GOGC\")\n\tif !gcset {\n\t\tdebug.SetGCPercent(ncutils.DEFAULT_GC_PERCENT)\n\t}\n}\n"], "filenames": ["logic/jwts.go", "logic/serverconf.go", "main.go"], "buggy_code_start_loc": [4, 45, 43], "buggy_code_end_loc": [41, 45, 51], "fixing_code_start_loc": [5, 46, 42], "fixing_code_end_loc": [63, 75, 52], "type": "CWE-798", "message": "Netmaker is a platform for creating and managing virtual overlay networks using WireGuard. Prior to versions 0.8.5, 0.9.4, and 010.0, there is a hard-coded cryptographic key in the code base which can be exploited to run admin commands on a remote server if the exploiter know the address and username of the admin. This effects the server (netmaker) component, and not clients. This has been patched in Netmaker v0.8.5, v0.9.4, and v0.10.0. There are currently no known workarounds.", "other": {"cve": {"id": "CVE-2022-23650", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-18T22:15:13.283", "lastModified": "2022-03-08T16:30:41.890", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Netmaker is a platform for creating and managing virtual overlay networks using WireGuard. Prior to versions 0.8.5, 0.9.4, and 010.0, there is a hard-coded cryptographic key in the code base which can be exploited to run admin commands on a remote server if the exploiter know the address and username of the admin. This effects the server (netmaker) component, and not clients. This has been patched in Netmaker v0.8.5, v0.9.4, and v0.10.0. There are currently no known workarounds."}, {"lang": "es", "value": "Netmaker es una plataforma para crear y administrara redes virtuales superpuestas usando WireGuard. En versiones anteriores a 0.8.5, 0.9.4 y 010.0, se presenta clave criptogr\u00e1fica embebida en el c\u00f3digo base que puede ser explotada para ejecutar comandos de administrador en un servidor remoto si el explotador conoce la direcci\u00f3n y el nombre de usuario del administrador. Esto afecta al componente del servidor (netmaker), y no a los clientes. Esto ha sido parcheado en Netmaker v0.8.5, v0.9.4 y v0.10.0. Actualmente no se presentan medidas de mitigaci\u00f3n conocidas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 9.0}, "baseSeverity": "HIGH", "exploitabilityScore": 8.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-798"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gravitl:netmaker:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.8.5", "matchCriteriaId": "4F28A807-C8DF-4096-BB3D-0BF59F58349B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gravitl:netmaker:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.9.0", "versionEndExcluding": "0.9.4", "matchCriteriaId": "5657BA6A-3F11-4BB7-B187-EFBAF3ECEBD0"}]}]}], "references": [{"url": "https://github.com/gravitl/netmaker/commit/3d4f44ecfe8be4ca38920556ba3b90502ffb4fee", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gravitl/netmaker/commit/e9bce264719f88c30e252ecc754d08f422f4c080", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gravitl/netmaker/pull/781/commits/1bec97c662670dfdab804343fc42ae4b1d050a87", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gravitl/netmaker/security/advisories/GHSA-86f3-hf24-76q4", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gravitl/netmaker/commit/3d4f44ecfe8be4ca38920556ba3b90502ffb4fee"}}