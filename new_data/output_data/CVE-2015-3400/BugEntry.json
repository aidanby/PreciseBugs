{"buggy_code": ["/*\n * CDDL HEADER START\n *\n * The contents of this file are subject to the terms of the\n * Common Development and Distribution License (the \"License\").\n * You may not use this file except in compliance with the License.\n *\n * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE\n * or http://www.opensolaris.org/os/licensing.\n * See the License for the specific language governing permissions\n * and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL HEADER in each\n * file and include the License file at usr/src/OPENSOLARIS.LICENSE.\n * If applicable, add the following below this CDDL HEADER, with the\n * fields enclosed by brackets \"[]\" replaced with your own identifying\n * information: Portions Copyright [yyyy] [name of copyright owner]\n *\n * CDDL HEADER END\n */\n\n/*\n * Copyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.\n * Copyright (c) 2011 Gunnar Beutner\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <strings.h>\n#include <libintl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <libzfs.h>\n#include <libshare.h>\n#include \"libshare_impl.h\"\n#include \"nfs.h\"\n#include \"smb.h\"\n\nstatic sa_share_impl_t find_share(sa_handle_impl_t handle,\n    const char *sharepath);\nstatic sa_share_impl_t alloc_share(const char *sharepath);\nstatic void free_share(sa_share_impl_t share);\n\nstatic void parse_sharetab(sa_handle_impl_t impl_handle);\nstatic int process_share(sa_handle_impl_t impl_handle,\n    sa_share_impl_t impl_share, char *pathname, char *resource,\n    char *fstype, char *options, char *description,\n    char *dataset, boolean_t from_sharetab);\nstatic void update_sharetab(sa_handle_impl_t impl_handle);\n\nstatic int update_zfs_share(sa_share_impl_t impl_handle, const char *proto);\nstatic int update_zfs_shares(sa_handle_impl_t impl_handle, const char *proto);\n\nstatic int fstypes_count;\nstatic sa_fstype_t *fstypes;\n\nsa_fstype_t *\nregister_fstype(const char *name, const sa_share_ops_t *ops)\n{\n\tsa_fstype_t *fstype;\n\n\tfstype = calloc(sizeof (sa_fstype_t), 1);\n\n\tif (fstype == NULL)\n\t\treturn (NULL);\n\n\tfstype->name = name;\n\tfstype->ops = ops;\n\tfstype->fsinfo_index = fstypes_count;\n\n\tfstypes_count++;\n\n\tfstype->next = fstypes;\n\tfstypes = fstype;\n\n\treturn (fstype);\n}\n\nsa_handle_t\nsa_init(int init_service)\n{\n\tsa_handle_impl_t impl_handle;\n\n\timpl_handle = calloc(sizeof (struct sa_handle_impl), 1);\n\n\tif (impl_handle == NULL)\n\t\treturn (NULL);\n\n\timpl_handle->zfs_libhandle = libzfs_init();\n\n\tif (impl_handle->zfs_libhandle != NULL) {\n\t\tlibzfs_print_on_error(impl_handle->zfs_libhandle, B_TRUE);\n\t}\n\n\tparse_sharetab(impl_handle);\n\tupdate_zfs_shares(impl_handle, NULL);\n\n\treturn ((sa_handle_t)impl_handle);\n}\n\n__attribute__((constructor)) static void\nlibshare_init(void)\n{\n\tlibshare_nfs_init();\n\tlibshare_smb_init();\n}\n\nstatic void\nparse_sharetab(sa_handle_impl_t impl_handle) {\n\tFILE *fp;\n\tchar line[512];\n\tchar *eol, *pathname, *resource, *fstype, *options, *description;\n\n\tfp = fopen(\"/etc/dfs/sharetab\", \"r\");\n\n\tif (fp == NULL)\n\t\treturn;\n\n\twhile (fgets(line, sizeof (line), fp) != NULL) {\n\t\teol = line + strlen(line) - 1;\n\n\t\twhile (eol >= line) {\n\t\t\tif (*eol != '\\r' && *eol != '\\n')\n\t\t\t\tbreak;\n\n\t\t\t*eol = '\\0';\n\t\t\teol--;\n\t\t}\n\n\t\tpathname = line;\n\n\t\tif ((resource = strchr(pathname, '\\t')) == NULL)\n\t\t\tcontinue;\n\n\t\t*resource = '\\0';\n\t\tresource++;\n\n\t\tif ((fstype = strchr(resource, '\\t')) == NULL)\n\t\t\tcontinue;\n\n\t\t*fstype = '\\0';\n\t\tfstype++;\n\n\t\tif ((options = strchr(fstype, '\\t')) == NULL)\n\t\t\tcontinue;\n\n\t\t*options = '\\0';\n\t\toptions++;\n\n\t\tif ((description = strchr(fstype, '\\t')) != NULL) {\n\t\t\t*description = '\\0';\n\t\t\tdescription++;\n\t\t}\n\n\t\tif (strcmp(resource, \"-\") == 0)\n\t\t\tresource = NULL;\n\n\t\t(void) process_share(impl_handle, NULL, pathname, resource,\n\t\t    fstype, options, description, NULL, B_TRUE);\n\t}\n\n\tfclose(fp);\n}\n\nstatic void\nupdate_sharetab(sa_handle_impl_t impl_handle)\n{\n\tsa_share_impl_t impl_share;\n\tint temp_fd;\n\tFILE *temp_fp;\n\tchar tempfile[] = \"/etc/dfs/sharetab.XXXXXX\";\n\tsa_fstype_t *fstype;\n\tconst char *resource;\n\n\tif (mkdir(\"/etc/dfs\", 0755) < 0 && errno != EEXIST) {\n\t\treturn;\n\t}\n\n\ttemp_fd = mkstemp(tempfile);\n\n\tif (temp_fd < 0)\n\t\treturn;\n\n\ttemp_fp = fdopen(temp_fd, \"w\");\n\n\tif (temp_fp == NULL)\n\t\treturn;\n\n\timpl_share = impl_handle->shares;\n\twhile (impl_share != NULL) {\n\t\tfstype = fstypes;\n\t\twhile (fstype != NULL) {\n\t\t\tif (FSINFO(impl_share, fstype)->active &&\n\t\t\t    FSINFO(impl_share, fstype)->shareopts != NULL) {\n\t\t\t\tresource = FSINFO(impl_share, fstype)->resource;\n\n\t\t\t\tif (resource == NULL)\n\t\t\t\t\tresource = \"-\";\n\n\t\t\t\tfprintf(temp_fp, \"%s\\t%s\\t%s\\t%s\\n\",\n\t\t\t\t    impl_share->sharepath, resource,\n\t\t\t\t    fstype->name,\n\t\t\t\t    FSINFO(impl_share, fstype)->shareopts);\n\t\t\t}\n\n\t\t\tfstype = fstype->next;\n\t\t}\n\n\t\timpl_share = impl_share->next;\n\t}\n\n\tfflush(temp_fp);\n\tfsync(temp_fd);\n\tfclose(temp_fp);\n\n\trename(tempfile, \"/etc/dfs/sharetab\");\n}\n\ntypedef struct update_cookie_s {\n\tsa_handle_impl_t handle;\n\tconst char *proto;\n} update_cookie_t;\n\nstatic int\nupdate_zfs_shares_cb(zfs_handle_t *zhp, void *pcookie)\n{\n\tupdate_cookie_t *udata = (update_cookie_t *)pcookie;\n\tchar mountpoint[ZFS_MAXPROPLEN];\n\tchar shareopts[ZFS_MAXPROPLEN];\n\tchar *dataset;\n\tzfs_type_t type = zfs_get_type(zhp);\n\n\tif (type == ZFS_TYPE_FILESYSTEM &&\n\t    zfs_iter_filesystems(zhp, update_zfs_shares_cb, pcookie) != 0) {\n\t\tzfs_close(zhp);\n\t\treturn (1);\n\t}\n\n\tif (type != ZFS_TYPE_FILESYSTEM) {\n\t\tzfs_close(zhp);\n\t\treturn (0);\n\t}\n\n\tif (zfs_prop_get(zhp, ZFS_PROP_MOUNTPOINT, mountpoint,\n\t    sizeof (mountpoint), NULL, NULL, 0, B_FALSE) != 0) {\n\t\tzfs_close(zhp);\n\t\treturn (0);\n\t}\n\n\tdataset = (char *)zfs_get_name(zhp);\n\n\tif (dataset == NULL) {\n\t\tzfs_close(zhp);\n\t\treturn (0);\n\t}\n\n\tif (!zfs_is_mounted(zhp, NULL)) {\n\t\tzfs_close(zhp);\n\t\treturn (0);\n\t}\n\n\tif ((udata->proto == NULL || strcmp(udata->proto, \"nfs\") == 0) &&\n\t    zfs_prop_get(zhp, ZFS_PROP_SHARENFS, shareopts,\n\t    sizeof (shareopts), NULL, NULL, 0, B_FALSE) == 0 &&\n\t    strcmp(shareopts, \"off\") != 0) {\n\t\t(void) process_share(udata->handle, NULL, mountpoint, NULL,\n\t\t    \"nfs\", shareopts, NULL, dataset, B_FALSE);\n\t}\n\n\tif ((udata->proto == NULL || strcmp(udata->proto, \"smb\") == 0) &&\n\t    zfs_prop_get(zhp, ZFS_PROP_SHARESMB, shareopts,\n\t    sizeof (shareopts), NULL, NULL, 0, B_FALSE) == 0 &&\n\t    strcmp(shareopts, \"off\") != 0) {\n\t\t(void) process_share(udata->handle, NULL, mountpoint, NULL,\n\t\t    \"smb\", shareopts, NULL, dataset, B_FALSE);\n\t}\n\n\tzfs_close(zhp);\n\n\treturn (0);\n}\n\nstatic int\nupdate_zfs_share(sa_share_impl_t impl_share, const char *proto)\n{\n\tsa_handle_impl_t impl_handle = impl_share->handle;\n\tzfs_handle_t *zhp;\n\tupdate_cookie_t udata;\n\n\tif (impl_handle->zfs_libhandle == NULL)\n\t\t\treturn (SA_SYSTEM_ERR);\n\n\tassert(impl_share->dataset != NULL);\n\n\tzhp = zfs_open(impl_share->handle->zfs_libhandle, impl_share->dataset,\n\t    ZFS_TYPE_FILESYSTEM);\n\n\tif (zhp == NULL)\n\t\treturn (SA_SYSTEM_ERR);\n\n\tudata.handle = impl_handle;\n\tudata.proto = proto;\n\t(void) update_zfs_shares_cb(zhp, &udata);\n\n\treturn (SA_OK);\n}\n\nstatic int\nupdate_zfs_shares(sa_handle_impl_t impl_handle, const char *proto)\n{\n\tupdate_cookie_t udata;\n\n\tif (impl_handle->zfs_libhandle == NULL)\n\t\treturn (SA_SYSTEM_ERR);\n\n\tudata.handle = impl_handle;\n\tudata.proto = proto;\n\t(void) zfs_iter_root(impl_handle->zfs_libhandle, update_zfs_shares_cb,\n\t    &udata);\n\n\treturn (SA_OK);\n}\n\nstatic int\nprocess_share(sa_handle_impl_t impl_handle, sa_share_impl_t impl_share,\n    char *pathname, char *resource, char *proto,\n    char *options, char *description, char *dataset,\n    boolean_t from_sharetab)\n{\n\tstruct stat statbuf;\n\tint rc;\n\tchar *resource_dup = NULL, *dataset_dup = NULL;\n\tboolean_t new_share;\n\tsa_fstype_t *fstype;\n\n\tnew_share = B_FALSE;\n\n\tif (impl_share == NULL)\n\t\timpl_share = find_share(impl_handle, pathname);\n\n\tif (impl_share == NULL) {\n\t\tif (lstat(pathname, &statbuf) != 0 ||\n\t\t    !S_ISDIR(statbuf.st_mode))\n\t\t\treturn (SA_BAD_PATH);\n\n\t\timpl_share = alloc_share(pathname);\n\n\t\tif (impl_share == NULL) {\n\t\t\trc = SA_NO_MEMORY;\n\t\t\tgoto err;\n\t\t}\n\n\t\tnew_share = B_TRUE;\n\t}\n\n\tif (dataset != NULL) {\n\t\tdataset_dup = strdup(dataset);\n\n\t\tif (dataset_dup == NULL) {\n\t\t\trc = SA_NO_MEMORY;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tfree(impl_share->dataset);\n\timpl_share->dataset = dataset_dup;\n\n\trc = SA_INVALID_PROTOCOL;\n\n\tfstype = fstypes;\n\twhile (fstype != NULL) {\n\t\tif (strcmp(fstype->name, proto) == 0) {\n\t\t\tif (resource != NULL) {\n\t\t\t\tresource_dup = strdup(resource);\n\n\t\t\t\tif (resource_dup == NULL) {\n\t\t\t\t\trc = SA_NO_MEMORY;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfree(FSINFO(impl_share, fstype)->resource);\n\t\t\tFSINFO(impl_share, fstype)->resource = resource_dup;\n\n\t\t\trc = fstype->ops->update_shareopts(impl_share,\n\t\t\t    resource, options);\n\n\t\t\tif (rc == SA_OK && from_sharetab)\n\t\t\t\tFSINFO(impl_share, fstype)->active = B_TRUE;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tfstype = fstype->next;\n\t}\n\n\tif (rc != SA_OK)\n\t\tgoto err;\n\n\tif (new_share) {\n\t\timpl_share->handle = impl_handle;\n\n\t\timpl_share->next = impl_handle->shares;\n\t\timpl_handle->shares = impl_share;\n\n\t}\n\nerr:\n\tif (rc != SA_OK) {\n\t\tif (new_share)\n\t\t\tfree_share(impl_share);\n\t}\n\n\treturn (rc);\n}\n\nvoid\nsa_fini(sa_handle_t handle)\n{\n\tsa_handle_impl_t impl_handle = (sa_handle_impl_t)handle;\n\tsa_share_impl_t impl_share, next;\n\tsa_share_impl_t *pcurr;\n\n\tif (impl_handle == NULL)\n\t\treturn;\n\n\t/*\n\t * clean up shares which don't have a non-NULL dataset property,\n\t * which means they're in sharetab but we couldn't find their\n\t * ZFS dataset.\n\t */\n\tpcurr = &(impl_handle->shares);\n\timpl_share = *pcurr;\n\twhile (impl_share != NULL) {\n\t\tnext = impl_share->next;\n\n\t\tif (impl_share->dataset == NULL) {\n\t\t\t/* remove item from the linked list */\n\t\t\t*pcurr = next;\n\n\t\t\tsa_disable_share(impl_share, NULL);\n\n\t\t\tfree_share(impl_share);\n\t\t} else {\n\t\t\tpcurr = &(impl_share->next);\n\t\t}\n\n\t\timpl_share = next;\n\t}\n\n\tupdate_sharetab(impl_handle);\n\n\tif (impl_handle->zfs_libhandle != NULL)\n\t\tlibzfs_fini(impl_handle->zfs_libhandle);\n\n\timpl_share = impl_handle->shares;\n\twhile (impl_share != NULL) {\n\t\tnext = impl_share->next;\n\t\tfree_share(impl_share);\n\t\timpl_share = next;\n\t}\n\n\tfree(impl_handle);\n}\n\nstatic sa_share_impl_t\nfind_share(sa_handle_impl_t impl_handle, const char *sharepath)\n{\n\tsa_share_impl_t impl_share;\n\n\timpl_share = impl_handle->shares;\n\twhile (impl_share != NULL) {\n\t\tif (strcmp(impl_share->sharepath, sharepath) == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\timpl_share = impl_share->next;\n\t}\n\n\treturn (impl_share);\n}\n\nsa_share_t\nsa_find_share(sa_handle_t handle, char *sharepath)\n{\n\treturn ((sa_share_t)find_share((sa_handle_impl_t)handle, sharepath));\n}\n\nint\nsa_enable_share(sa_share_t share, char *protocol)\n{\n\tsa_share_impl_t impl_share = (sa_share_impl_t)share;\n\tint rc, ret;\n\tboolean_t found_protocol;\n\tsa_fstype_t *fstype;\n\n#ifdef DEBUG\n\tfprintf(stderr, \"sa_enable_share: share->sharepath=%s, protocol=%s\\n\",\n\t\timpl_share->sharepath, protocol);\n#endif\n\n\tassert(impl_share->handle != NULL);\n\n\tret = SA_OK;\n\tfound_protocol = B_FALSE;\n\n\tfstype = fstypes;\n\twhile (fstype != NULL) {\n\t\tif (protocol == NULL || strcmp(fstype->name, protocol) == 0) {\n\t\t\tupdate_zfs_share(impl_share, fstype->name);\n\n\t\t\trc = fstype->ops->enable_share(impl_share);\n\n\t\t\tif (rc != SA_OK)\n\t\t\t\tret = rc;\n\t\t\telse\n\t\t\t\tFSINFO(impl_share, fstype)->active = B_TRUE;\n\n\t\t\tfound_protocol = B_TRUE;\n\t\t}\n\n\t\tfstype = fstype->next;\n\t}\n\n\tupdate_sharetab(impl_share->handle);\n\n\treturn (found_protocol ? ret : SA_INVALID_PROTOCOL);\n}\n\nint\nsa_disable_share(sa_share_t share, char *protocol)\n{\n\tsa_share_impl_t impl_share = (sa_share_impl_t)share;\n\tint rc, ret;\n\tboolean_t found_protocol;\n\tsa_fstype_t *fstype;\n\n#ifdef DEBUG\n\tfprintf(stderr, \"sa_disable_share: share->sharepath=%s, protocol=%s\\n\",\n\t\timpl_share->sharepath, protocol);\n#endif\n\n\tret = SA_OK;\n\tfound_protocol = B_FALSE;\n\n\tfstype = fstypes;\n\twhile (fstype != NULL) {\n\t\tif (protocol == NULL || strcmp(fstype->name, protocol) == 0) {\n\t\t\trc = fstype->ops->disable_share(impl_share);\n\n\t\t\tif (rc == SA_OK) {\n\t\t\t\tfstype->ops->clear_shareopts(impl_share);\n\n\t\t\t\tFSINFO(impl_share, fstype)->active = B_FALSE;\n\t\t\t} else\n\t\t\t\tret = rc;\n\n\t\t\tfound_protocol = B_TRUE;\n\t\t}\n\n\t\tfstype = fstype->next;\n\t}\n\n\tupdate_sharetab(impl_share->handle);\n\n\treturn (found_protocol ? ret : SA_INVALID_PROTOCOL);\n}\n\n/*\n * sa_errorstr(err)\n *\n * convert an error value to an error string\n */\nchar *\nsa_errorstr(int err)\n{\n\tstatic char errstr[32];\n\tchar *ret = NULL;\n\n\tswitch (err) {\n\tcase SA_OK:\n\t\tret = dgettext(TEXT_DOMAIN, \"ok\");\n\t\tbreak;\n\tcase SA_NO_SUCH_PATH:\n\t\tret = dgettext(TEXT_DOMAIN, \"path doesn't exist\");\n\t\tbreak;\n\tcase SA_NO_MEMORY:\n\t\tret = dgettext(TEXT_DOMAIN, \"no memory\");\n\t\tbreak;\n\tcase SA_DUPLICATE_NAME:\n\t\tret = dgettext(TEXT_DOMAIN, \"name in use\");\n\t\tbreak;\n\tcase SA_BAD_PATH:\n\t\tret = dgettext(TEXT_DOMAIN, \"bad path\");\n\t\tbreak;\n\tcase SA_NO_SUCH_GROUP:\n\t\tret = dgettext(TEXT_DOMAIN, \"no such group\");\n\t\tbreak;\n\tcase SA_CONFIG_ERR:\n\t\tret = dgettext(TEXT_DOMAIN, \"configuration error\");\n\t\tbreak;\n\tcase SA_SYSTEM_ERR:\n\t\tret = dgettext(TEXT_DOMAIN, \"system error\");\n\t\tbreak;\n\tcase SA_SYNTAX_ERR:\n\t\tret = dgettext(TEXT_DOMAIN, \"syntax error\");\n\t\tbreak;\n\tcase SA_NO_PERMISSION:\n\t\tret = dgettext(TEXT_DOMAIN, \"no permission\");\n\t\tbreak;\n\tcase SA_BUSY:\n\t\tret = dgettext(TEXT_DOMAIN, \"busy\");\n\t\tbreak;\n\tcase SA_NO_SUCH_PROP:\n\t\tret = dgettext(TEXT_DOMAIN, \"no such property\");\n\t\tbreak;\n\tcase SA_INVALID_NAME:\n\t\tret = dgettext(TEXT_DOMAIN, \"invalid name\");\n\t\tbreak;\n\tcase SA_INVALID_PROTOCOL:\n\t\tret = dgettext(TEXT_DOMAIN, \"invalid protocol\");\n\t\tbreak;\n\tcase SA_NOT_ALLOWED:\n\t\tret = dgettext(TEXT_DOMAIN, \"operation not allowed\");\n\t\tbreak;\n\tcase SA_BAD_VALUE:\n\t\tret = dgettext(TEXT_DOMAIN, \"bad property value\");\n\t\tbreak;\n\tcase SA_INVALID_SECURITY:\n\t\tret = dgettext(TEXT_DOMAIN, \"invalid security type\");\n\t\tbreak;\n\tcase SA_NO_SUCH_SECURITY:\n\t\tret = dgettext(TEXT_DOMAIN, \"security type not found\");\n\t\tbreak;\n\tcase SA_VALUE_CONFLICT:\n\t\tret = dgettext(TEXT_DOMAIN, \"property value conflict\");\n\t\tbreak;\n\tcase SA_NOT_IMPLEMENTED:\n\t\tret = dgettext(TEXT_DOMAIN, \"not implemented\");\n\t\tbreak;\n\tcase SA_INVALID_PATH:\n\t\tret = dgettext(TEXT_DOMAIN, \"invalid path\");\n\t\tbreak;\n\tcase SA_NOT_SUPPORTED:\n\t\tret = dgettext(TEXT_DOMAIN, \"operation not supported\");\n\t\tbreak;\n\tcase SA_PROP_SHARE_ONLY:\n\t\tret = dgettext(TEXT_DOMAIN, \"property not valid for group\");\n\t\tbreak;\n\tcase SA_NOT_SHARED:\n\t\tret = dgettext(TEXT_DOMAIN, \"not shared\");\n\t\tbreak;\n\tcase SA_NO_SUCH_RESOURCE:\n\t\tret = dgettext(TEXT_DOMAIN, \"no such resource\");\n\t\tbreak;\n\tcase SA_RESOURCE_REQUIRED:\n\t\tret = dgettext(TEXT_DOMAIN, \"resource name required\");\n\t\tbreak;\n\tcase SA_MULTIPLE_ERROR:\n\t\tret = dgettext(TEXT_DOMAIN, \"errors from multiple protocols\");\n\t\tbreak;\n\tcase SA_PATH_IS_SUBDIR:\n\t\tret = dgettext(TEXT_DOMAIN, \"path is a subpath of share\");\n\t\tbreak;\n\tcase SA_PATH_IS_PARENTDIR:\n\t\tret = dgettext(TEXT_DOMAIN, \"path is parent of a share\");\n\t\tbreak;\n\tcase SA_NO_SECTION:\n\t\tret = dgettext(TEXT_DOMAIN, \"protocol requires a section\");\n\t\tbreak;\n\tcase SA_NO_PROPERTIES:\n\t\tret = dgettext(TEXT_DOMAIN, \"properties not found\");\n\t\tbreak;\n\tcase SA_NO_SUCH_SECTION:\n\t\tret = dgettext(TEXT_DOMAIN, \"section not found\");\n\t\tbreak;\n\tcase SA_PASSWORD_ENC:\n\t\tret = dgettext(TEXT_DOMAIN, \"passwords must be encrypted\");\n\t\tbreak;\n\tcase SA_SHARE_EXISTS:\n\t\tret = dgettext(TEXT_DOMAIN, \"path or file is already shared\");\n\t\tbreak;\n\tdefault:\n\t\t(void) snprintf(errstr, sizeof (errstr),\n\t\t    dgettext(TEXT_DOMAIN, \"unknown %d\"), err);\n\t\tret = errstr;\n\t}\n\treturn (ret);\n}\n\nint\nsa_parse_legacy_options(sa_group_t group, char *options, char *proto)\n{\n\tsa_fstype_t *fstype;\n\n#ifdef DEBUG\n\tfprintf(stderr, \"sa_parse_legacy_options: options=%s, proto=%s\\n\",\n\t\toptions, proto);\n#endif\n\n\tfstype = fstypes;\n\twhile (fstype != NULL) {\n\t\tif (strcmp(fstype->name, proto) != 0) {\n\t\t\tfstype = fstype->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\treturn (fstype->ops->validate_shareopts(options));\n\t}\n\n\treturn (SA_INVALID_PROTOCOL);\n}\n\nboolean_t\nsa_needs_refresh(sa_handle_t handle)\n{\n\treturn (B_TRUE);\n}\n\nlibzfs_handle_t *\nsa_get_zfs_handle(sa_handle_t handle)\n{\n\tsa_handle_impl_t impl_handle = (sa_handle_impl_t)handle;\n\n\tif (impl_handle == NULL)\n\t\treturn (NULL);\n\n\treturn (impl_handle->zfs_libhandle);\n}\n\nstatic sa_share_impl_t\nalloc_share(const char *sharepath)\n{\n\tsa_share_impl_t impl_share;\n\n\timpl_share = calloc(sizeof (struct sa_share_impl), 1);\n\n\tif (impl_share == NULL)\n\t\treturn (NULL);\n\n\timpl_share->sharepath = strdup(sharepath);\n\n\tif (impl_share->sharepath == NULL) {\n\t\tfree(impl_share);\n\t\treturn (NULL);\n\t}\n\n\timpl_share->fsinfo = calloc(sizeof (sa_share_fsinfo_t), fstypes_count);\n\n\tif (impl_share->fsinfo == NULL) {\n\t\tfree(impl_share->sharepath);\n\t\tfree(impl_share);\n\t\treturn (NULL);\n\t}\n\n\treturn (impl_share);\n}\n\nstatic void\nfree_share(sa_share_impl_t impl_share) {\n\tsa_fstype_t *fstype;\n\n\tfstype = fstypes;\n\twhile (fstype != NULL) {\n\t\tfstype->ops->clear_shareopts(impl_share);\n\n\t\tfree(FSINFO(impl_share, fstype)->resource);\n\n\t\tfstype = fstype->next;\n\t}\n\n\tfree(impl_share->sharepath);\n\tfree(impl_share->dataset);\n\tfree(impl_share->fsinfo);\n\tfree(impl_share);\n}\n\nint\nsa_zfs_process_share(sa_handle_t handle, sa_group_t group, sa_share_t share,\n    char *mountpoint, char *proto, zprop_source_t source, char *shareopts,\n    char *sourcestr, char *dataset)\n{\n\tsa_handle_impl_t impl_handle = (sa_handle_impl_t)handle;\n\tsa_share_impl_t impl_share = (sa_share_impl_t)share;\n\n#ifdef DEBUG\n\tfprintf(stderr, \"sa_zfs_process_share: mountpoint=%s, proto=%s, \"\n\t    \"shareopts=%s, sourcestr=%s, dataset=%s\\n\", mountpoint, proto,\n\t    shareopts, sourcestr, dataset);\n#endif\n\n\treturn (process_share(impl_handle, impl_share, mountpoint, NULL,\n\t    proto, shareopts, NULL, dataset, B_FALSE));\n}\n\nvoid\nsa_update_sharetab_ts(sa_handle_t handle)\n{\n\tsa_handle_impl_t impl_handle = (sa_handle_impl_t)handle;\n\n\tupdate_sharetab(impl_handle);\n}\n", "/*\n * CDDL HEADER START\n *\n * The contents of this file are subject to the terms of the\n * Common Development and Distribution License (the \"License\").\n * You may not use this file except in compliance with the License.\n *\n * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE\n * or http://www.opensolaris.org/os/licensing.\n * See the License for the specific language governing permissions\n * and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL HEADER in each\n * file and include the License file at usr/src/OPENSOLARIS.LICENSE.\n * If applicable, add the following below this CDDL HEADER, with the\n * fields enclosed by brackets \"[]\" replaced with your own identifying\n * information: Portions Copyright [yyyy] [name of copyright owner]\n *\n * CDDL HEADER END\n */\n\n/*\n * Copyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.\n * Copyright (c) 2011 Gunnar Beutner\n */\n\nstruct sa_handle_impl;\n\ntypedef struct sa_share_fsinfo {\n\tboolean_t active;\n\tchar *resource;\n\tchar *shareopts;\n} sa_share_fsinfo_t;\n\ntypedef struct sa_share_impl {\n\tstruct sa_share_impl *next;\n\n\tstruct sa_handle_impl *handle;\n\n\tchar *sharepath;\n\tchar *dataset;\n\n\tsa_share_fsinfo_t *fsinfo; /* per-fstype information */\n} *sa_share_impl_t;\n\n#define\tFSINFO(impl_share, fstype) (&(impl_share->fsinfo[fstype->fsinfo_index]))\n\ntypedef struct sa_share_ops {\n\tint (*enable_share)(sa_share_impl_t share);\n\tint (*disable_share)(sa_share_impl_t share);\n\tint (*validate_shareopts)(const char *shareopts);\n\tint (*update_shareopts)(sa_share_impl_t impl_share,\n\t    const char *resource, const char *shareopts);\n\tvoid (*clear_shareopts)(sa_share_impl_t impl_share);\n} sa_share_ops_t;\n\ntypedef struct sa_fstype {\n\tstruct sa_fstype *next;\n\n\tconst char *name;\n\tconst sa_share_ops_t *ops;\n\tint fsinfo_index;\n} sa_fstype_t;\n\ntypedef struct sa_handle_impl {\n\tlibzfs_handle_t *zfs_libhandle;\n\tsa_share_impl_t shares;\n} *sa_handle_impl_t;\n\nsa_fstype_t *register_fstype(const char *name, const sa_share_ops_t *ops);\n", "/*\n * CDDL HEADER START\n *\n * The contents of this file are subject to the terms of the\n * Common Development and Distribution License (the \"License\").\n * You may not use this file except in compliance with the License.\n *\n * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE\n * or http://www.opensolaris.org/os/licensing.\n * See the License for the specific language governing permissions\n * and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL HEADER in each\n * file and include the License file at usr/src/OPENSOLARIS.LICENSE.\n * If applicable, add the following below this CDDL HEADER, with the\n * fields enclosed by brackets \"[]\" replaced with your own identifying\n * information: Portions Copyright [yyyy] [name of copyright owner]\n *\n * CDDL HEADER END\n */\n\n/*\n * Copyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.\n * Copyright (c) 2011 Gunnar Beutner\n * Copyright (c) 2012 Cyril Plisko. All rights reserved.\n */\n\n#include <stdio.h>\n#include <strings.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <libzfs.h>\n#include <libshare.h>\n#include \"libshare_impl.h\"\n\nstatic boolean_t nfs_available(void);\n\nstatic sa_fstype_t *nfs_fstype;\n\n/*\n * nfs_exportfs_temp_fd refers to a temporary copy of the output\n * from exportfs -v.\n */\nstatic int nfs_exportfs_temp_fd = -1;\n\ntypedef int (*nfs_shareopt_callback_t)(const char *opt, const char *value,\n    void *cookie);\n\ntypedef int (*nfs_host_callback_t)(const char *sharepath, const char *host,\n    const char *security, const char *access, void *cookie);\n\n/*\n * Invokes the specified callback function for each Solaris share option\n * listed in the specified string.\n */\nstatic int\nforeach_nfs_shareopt(const char *shareopts,\n    nfs_shareopt_callback_t callback, void *cookie)\n{\n\tchar *shareopts_dup, *opt, *cur, *value;\n\tint was_nul, rc;\n\n\tif (shareopts == NULL)\n\t\treturn (SA_OK);\n\n\tshareopts_dup = strdup(shareopts);\n\n\tif (shareopts_dup == NULL)\n\t\treturn (SA_NO_MEMORY);\n\n\topt = shareopts_dup;\n\twas_nul = 0;\n\n\twhile (1) {\n\t\tcur = opt;\n\n\t\twhile (*cur != ',' && *cur != '\\0')\n\t\t\tcur++;\n\n\t\tif (*cur == '\\0')\n\t\t\twas_nul = 1;\n\n\t\t*cur = '\\0';\n\n\t\tif (cur > opt) {\n\t\t\tvalue = strchr(opt, '=');\n\n\t\t\tif (value != NULL) {\n\t\t\t\t*value = '\\0';\n\t\t\t\tvalue++;\n\t\t\t}\n\n\t\t\trc = callback(opt, value, cookie);\n\n\t\t\tif (rc != SA_OK) {\n\t\t\t\tfree(shareopts_dup);\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t}\n\n\t\topt = cur + 1;\n\n\t\tif (was_nul)\n\t\t\tbreak;\n\t}\n\n\tfree(shareopts_dup);\n\n\treturn (0);\n}\n\ntypedef struct nfs_host_cookie_s {\n\tnfs_host_callback_t callback;\n\tconst char *sharepath;\n\tvoid *cookie;\n\tconst char *security;\n} nfs_host_cookie_t;\n\n/*\n * Helper function for foreach_nfs_host. This function checks whether the\n * current share option is a host specification and invokes a callback\n * function with information about the host.\n */\nstatic int\nforeach_nfs_host_cb(const char *opt, const char *value, void *pcookie)\n{\n\tint rc;\n\tconst char *access;\n\tchar *host_dup, *host, *next;\n\tnfs_host_cookie_t *udata = (nfs_host_cookie_t *)pcookie;\n\n#ifdef DEBUG\n\tfprintf(stderr, \"foreach_nfs_host_cb: key=%s, value=%s\\n\", opt, value);\n#endif\n\n\tif (strcmp(opt, \"sec\") == 0)\n\t\tudata->security = value;\n\n\tif (strcmp(opt, \"rw\") == 0 || strcmp(opt, \"ro\") == 0) {\n\t\tif (value == NULL)\n\t\t\tvalue = \"*\";\n\n\t\taccess = opt;\n\n\t\thost_dup = strdup(value);\n\n\t\tif (host_dup == NULL)\n\t\t\treturn (SA_NO_MEMORY);\n\n\t\thost = host_dup;\n\n\t\tdo {\n\t\t\tnext = strchr(host, ':');\n\t\t\tif (next != NULL) {\n\t\t\t\t*next = '\\0';\n\t\t\t\tnext++;\n\t\t\t}\n\n\t\t\trc = udata->callback(udata->sharepath, host,\n\t\t\t    udata->security, access, udata->cookie);\n\n\t\t\tif (rc != SA_OK) {\n\t\t\t\tfree(host_dup);\n\n\t\t\t\treturn (rc);\n\t\t\t}\n\n\t\t\thost = next;\n\t\t} while (host != NULL);\n\n\t\tfree(host_dup);\n\t}\n\n\treturn (SA_OK);\n}\n\n/*\n * Invokes a callback function for all NFS hosts that are set for a share.\n */\nstatic int\nforeach_nfs_host(sa_share_impl_t impl_share, nfs_host_callback_t callback,\n    void *cookie)\n{\n\tnfs_host_cookie_t udata;\n\tchar *shareopts;\n\n\tudata.callback = callback;\n\tudata.sharepath = impl_share->sharepath;\n\tudata.cookie = cookie;\n\tudata.security = \"sys\";\n\n\tshareopts = FSINFO(impl_share, nfs_fstype)->shareopts;\n\n\treturn foreach_nfs_shareopt(shareopts, foreach_nfs_host_cb,\n\t    &udata);\n}\n\n/*\n * Converts a Solaris NFS host specification to its Linux equivalent.\n */\nstatic int\nget_linux_hostspec(const char *solaris_hostspec, char **plinux_hostspec)\n{\n\t/*\n\t * For now we just support CIDR masks (e.g. @192.168.0.0/16) and host\n\t * wildcards (e.g. *.example.org).\n\t */\n\tif (solaris_hostspec[0] == '@') {\n\t\t/*\n\t\t * Solaris host specifier, e.g. @192.168.0.0/16; we just need\n\t\t * to skip the @ in this case\n\t\t */\n\t\t*plinux_hostspec = strdup(solaris_hostspec + 1);\n\t} else {\n\t\t*plinux_hostspec = strdup(solaris_hostspec);\n\t}\n\n\tif (*plinux_hostspec == NULL) {\n\t\treturn (SA_NO_MEMORY);\n\t}\n\n\treturn (SA_OK);\n}\n\n/*\n * Used internally by nfs_enable_share to enable sharing for a single host.\n */\nstatic int\nnfs_enable_share_one(const char *sharepath, const char *host,\n    const char *security, const char *access, void *pcookie)\n{\n\tint rc;\n\tchar *linuxhost, *hostpath, *opts;\n\tconst char *linux_opts = (const char *)pcookie;\n\tchar *argv[6];\n\n\t/* exportfs -i -o sec=XX,rX,<opts> <host>:<sharepath> */\n\n\trc = get_linux_hostspec(host, &linuxhost);\n\n\tif (rc < 0)\n\t\texit(1);\n\n\thostpath = malloc(strlen(linuxhost) + 1 + strlen(sharepath) + 1);\n\n\tif (hostpath == NULL) {\n\t\tfree(linuxhost);\n\n\t\texit(1);\n\t}\n\n\tsprintf(hostpath, \"%s:%s\", linuxhost, sharepath);\n\n\tfree(linuxhost);\n\n\tif (linux_opts == NULL)\n\t\tlinux_opts = \"\";\n\n\topts = malloc(4 + strlen(security) + 4 + strlen(linux_opts) + 1);\n\n\tif (opts == NULL)\n\t\texit(1);\n\n\tsprintf(opts, \"sec=%s,%s,%s\", security, access, linux_opts);\n\n#ifdef DEBUG\n\tfprintf(stderr, \"sharing %s with opts %s\\n\", hostpath, opts);\n#endif\n\n\targv[0] = \"/usr/sbin/exportfs\";\n\targv[1] = \"-i\";\n\targv[2] = \"-o\";\n\targv[3] = opts;\n\targv[4] = hostpath;\n\targv[5] = NULL;\n\n\trc = libzfs_run_process(argv[0], argv, 0);\n\n\tfree(hostpath);\n\tfree(opts);\n\n\tif (rc < 0)\n\t\treturn (SA_SYSTEM_ERR);\n\telse\n\t\treturn (SA_OK);\n}\n\n/*\n * Adds a Linux share option to an array of NFS options.\n */\nstatic int\nadd_linux_shareopt(char **plinux_opts, const char *key, const char *value)\n{\n\tsize_t len = 0;\n\tchar *new_linux_opts;\n\n\tif (*plinux_opts != NULL)\n\t\tlen = strlen(*plinux_opts);\n\n\tnew_linux_opts = realloc(*plinux_opts, len + 1 + strlen(key) +\n\t    (value ? 1 + strlen(value) : 0) + 1);\n\n\tif (new_linux_opts == NULL)\n\t\treturn (SA_NO_MEMORY);\n\n\tnew_linux_opts[len] = '\\0';\n\n\tif (len > 0)\n\t\tstrcat(new_linux_opts, \",\");\n\n\tstrcat(new_linux_opts, key);\n\n\tif (value != NULL) {\n\t\tstrcat(new_linux_opts, \"=\");\n\t\tstrcat(new_linux_opts, value);\n\t}\n\n\t*plinux_opts = new_linux_opts;\n\n\treturn (SA_OK);\n}\n\n/*\n * Validates and converts a single Solaris share option to its Linux\n * equivalent.\n */\nstatic int\nget_linux_shareopts_cb(const char *key, const char *value, void *cookie)\n{\n\tchar **plinux_opts = (char **)cookie;\n\n\t/* host-specific options, these are taken care of elsewhere */\n\tif (strcmp(key, \"ro\") == 0 || strcmp(key, \"rw\") == 0 ||\n\t    strcmp(key, \"sec\") == 0)\n\t\treturn (SA_OK);\n\n\tif (strcmp(key, \"anon\") == 0)\n\t\tkey = \"anonuid\";\n\n\tif (strcmp(key, \"root_mapping\") == 0) {\n\t\t(void) add_linux_shareopt(plinux_opts, \"root_squash\", NULL);\n\t\tkey = \"anonuid\";\n\t}\n\n\tif (strcmp(key, \"nosub\") == 0)\n\t\tkey = \"subtree_check\";\n\n\tif (strcmp(key, \"insecure\") != 0 && strcmp(key, \"secure\") != 0 &&\n\t    strcmp(key, \"async\") != 0 && strcmp(key, \"sync\") != 0 &&\n\t    strcmp(key, \"no_wdelay\") != 0 && strcmp(key, \"wdelay\") != 0 &&\n\t    strcmp(key, \"nohide\") != 0 && strcmp(key, \"hide\") != 0 &&\n\t    strcmp(key, \"crossmnt\") != 0 &&\n\t    strcmp(key, \"no_subtree_check\") != 0 &&\n\t    strcmp(key, \"subtree_check\") != 0 &&\n\t    strcmp(key, \"insecure_locks\") != 0 &&\n\t    strcmp(key, \"secure_locks\") != 0 &&\n\t    strcmp(key, \"no_auth_nlm\") != 0 && strcmp(key, \"auth_nlm\") != 0 &&\n\t    strcmp(key, \"no_acl\") != 0 && strcmp(key, \"mountpoint\") != 0 &&\n\t    strcmp(key, \"mp\") != 0 && strcmp(key, \"fsuid\") != 0 &&\n\t    strcmp(key, \"refer\") != 0 && strcmp(key, \"replicas\") != 0 &&\n\t    strcmp(key, \"root_squash\") != 0 &&\n\t    strcmp(key, \"no_root_squash\") != 0 &&\n\t    strcmp(key, \"all_squash\") != 0 &&\n\t    strcmp(key, \"no_all_squash\") != 0 && strcmp(key, \"fsid\") != 0 &&\n\t    strcmp(key, \"anonuid\") != 0 && strcmp(key, \"anongid\") != 0) {\n\t\treturn (SA_SYNTAX_ERR);\n\t}\n\n\t(void) add_linux_shareopt(plinux_opts, key, value);\n\n\treturn (SA_OK);\n}\n\n/*\n * Takes a string containing Solaris share options (e.g. \"sync,no_acl\") and\n * converts them to a NULL-terminated array of Linux NFS options.\n */\nstatic int\nget_linux_shareopts(const char *shareopts, char **plinux_opts)\n{\n\tint rc;\n\n\tassert(plinux_opts != NULL);\n\n\t*plinux_opts = NULL;\n\n\t/* default options for Solaris shares */\n\t(void) add_linux_shareopt(plinux_opts, \"no_subtree_check\", NULL);\n\t(void) add_linux_shareopt(plinux_opts, \"no_root_squash\", NULL);\n\t(void) add_linux_shareopt(plinux_opts, \"mountpoint\", NULL);\n\n\trc = foreach_nfs_shareopt(shareopts, get_linux_shareopts_cb,\n\t    plinux_opts);\n\n\tif (rc != SA_OK) {\n\t\tfree(*plinux_opts);\n\t\t*plinux_opts = NULL;\n\t}\n\n\treturn (rc);\n}\n\n/*\n * Enables NFS sharing for the specified share.\n */\nstatic int\nnfs_enable_share(sa_share_impl_t impl_share)\n{\n\tchar *shareopts, *linux_opts;\n\tint rc;\n\n\tif (!nfs_available()) {\n\t\treturn (SA_SYSTEM_ERR);\n\t}\n\n\tshareopts = FSINFO(impl_share, nfs_fstype)->shareopts;\n\n\tif (shareopts == NULL)\n\t\treturn (SA_OK);\n\n\trc = get_linux_shareopts(shareopts, &linux_opts);\n\n\tif (rc != SA_OK)\n\t\treturn (rc);\n\n\trc = foreach_nfs_host(impl_share, nfs_enable_share_one, linux_opts);\n\n\tfree(linux_opts);\n\n\treturn (rc);\n}\n\n/*\n * Used internally by nfs_disable_share to disable sharing for a single host.\n */\nstatic int\nnfs_disable_share_one(const char *sharepath, const char *host,\n    const char *security, const char *access, void *cookie)\n{\n\tint rc;\n\tchar *linuxhost, *hostpath;\n\tchar *argv[4];\n\n\trc = get_linux_hostspec(host, &linuxhost);\n\n\tif (rc < 0)\n\t\texit(1);\n\n\thostpath = malloc(strlen(linuxhost) + 1 + strlen(sharepath) + 1);\n\n\tif (hostpath == NULL) {\n\t\tfree(linuxhost);\n\t\texit(1);\n\t}\n\n\tsprintf(hostpath, \"%s:%s\", linuxhost, sharepath);\n\n\tfree(linuxhost);\n\n#ifdef DEBUG\n\tfprintf(stderr, \"unsharing %s\\n\", hostpath);\n#endif\n\n\targv[0] = \"/usr/sbin/exportfs\";\n\targv[1] = \"-u\";\n\targv[2] = hostpath;\n\targv[3] = NULL;\n\n\trc = libzfs_run_process(argv[0], argv, 0);\n\n\tfree(hostpath);\n\n\tif (rc < 0)\n\t\treturn (SA_SYSTEM_ERR);\n\telse\n\t\treturn (SA_OK);\n}\n\n/*\n * Disables NFS sharing for the specified share.\n */\nstatic int\nnfs_disable_share(sa_share_impl_t impl_share)\n{\n\tif (!nfs_available()) {\n\t\t/*\n\t\t * The share can't possibly be active, so nothing\n\t\t * needs to be done to disable it.\n\t\t */\n\t\treturn (SA_OK);\n\t}\n\n\treturn (foreach_nfs_host(impl_share, nfs_disable_share_one, NULL));\n}\n\n/*\n * Checks whether the specified NFS share options are syntactically correct.\n */\nstatic int\nnfs_validate_shareopts(const char *shareopts)\n{\n\tchar *linux_opts;\n\tint rc;\n\n\trc = get_linux_shareopts(shareopts, &linux_opts);\n\n\tif (rc != SA_OK)\n\t\treturn (rc);\n\n\tfree(linux_opts);\n\n\treturn (SA_OK);\n}\n\n/*\n * Checks whether a share is currently active.\n */\nstatic boolean_t\nnfs_is_share_active(sa_share_impl_t impl_share)\n{\n\tchar line[512];\n\tchar *tab, *cur;\n\tFILE *nfs_exportfs_temp_fp;\n\n\tif (!nfs_available())\n\t\treturn (B_FALSE);\n\n\tnfs_exportfs_temp_fp = fdopen(dup(nfs_exportfs_temp_fd), \"r\");\n\n\tif (nfs_exportfs_temp_fp == NULL ||\n\t    fseek(nfs_exportfs_temp_fp, 0, SEEK_SET) < 0) {\n\t\tfclose(nfs_exportfs_temp_fp);\n\t\treturn (B_FALSE);\n\t}\n\n\twhile (fgets(line, sizeof (line), nfs_exportfs_temp_fp) != NULL) {\n\t\t/*\n\t\t * exportfs uses separate lines for the share path\n\t\t * and the export options when the share path is longer\n\t\t * than a certain amount of characters; this ignores\n\t\t * the option lines\n\t\t */\n\t\tif (line[0] == '\\t')\n\t\t\tcontinue;\n\n\t\ttab = strchr(line, '\\t');\n\n\t\tif (tab != NULL) {\n\t\t\t*tab = '\\0';\n\t\t\tcur = tab - 1;\n\t\t} else {\n\t\t\t/*\n\t\t\t * there's no tab character, which means the\n\t\t\t * NFS options are on a separate line; we just\n\t\t\t * need to remove the new-line character\n\t\t\t * at the end of the line\n\t\t\t */\n\t\t\tcur = line + strlen(line) - 1;\n\t\t}\n\n\t\t/* remove trailing spaces and new-line characters */\n\t\twhile (cur >= line && (*cur == ' ' || *cur == '\\n'))\n\t\t\t*cur-- = '\\0';\n\n\t\tif (strcmp(line, impl_share->sharepath) == 0) {\n\t\t\tfclose(nfs_exportfs_temp_fp);\n\t\t\treturn (B_TRUE);\n\t\t}\n\t}\n\n\tfclose(nfs_exportfs_temp_fp);\n\n\treturn (B_FALSE);\n}\n\n/*\n * Called to update a share's options. A share's options might be out of\n * date if the share was loaded from disk (i.e. /etc/dfs/sharetab) and the\n * \"sharenfs\" dataset property has changed in the meantime. This function\n * also takes care of re-enabling the share if necessary.\n */\nstatic int\nnfs_update_shareopts(sa_share_impl_t impl_share, const char *resource,\n    const char *shareopts)\n{\n\tchar *shareopts_dup;\n\tboolean_t needs_reshare = B_FALSE;\n\tchar *old_shareopts;\n\n\tFSINFO(impl_share, nfs_fstype)->active =\n\t    nfs_is_share_active(impl_share);\n\n\told_shareopts = FSINFO(impl_share, nfs_fstype)->shareopts;\n\n\tif (strcmp(shareopts, \"on\") == 0)\n\t\tshareopts = \"rw\";\n\n\tif (FSINFO(impl_share, nfs_fstype)->active && old_shareopts != NULL &&\n\t    strcmp(old_shareopts, shareopts) != 0) {\n\t\tneeds_reshare = B_TRUE;\n\t\tnfs_disable_share(impl_share);\n\t}\n\n\tshareopts_dup = strdup(shareopts);\n\n\tif (shareopts_dup == NULL)\n\t\treturn (SA_NO_MEMORY);\n\n\tif (old_shareopts != NULL)\n\t\tfree(old_shareopts);\n\n\tFSINFO(impl_share, nfs_fstype)->shareopts = shareopts_dup;\n\n\tif (needs_reshare)\n\t\tnfs_enable_share(impl_share);\n\n\treturn (SA_OK);\n}\n\n/*\n * Clears a share's NFS options. Used by libshare to\n * clean up shares that are about to be free()'d.\n */\nstatic void\nnfs_clear_shareopts(sa_share_impl_t impl_share)\n{\n\tfree(FSINFO(impl_share, nfs_fstype)->shareopts);\n\tFSINFO(impl_share, nfs_fstype)->shareopts = NULL;\n}\n\nstatic const sa_share_ops_t nfs_shareops = {\n\t.enable_share = nfs_enable_share,\n\t.disable_share = nfs_disable_share,\n\n\t.validate_shareopts = nfs_validate_shareopts,\n\t.update_shareopts = nfs_update_shareopts,\n\t.clear_shareopts = nfs_clear_shareopts,\n};\n\n/*\n * nfs_check_exportfs() checks that the exportfs command runs\n * and also maintains a temporary copy of the output from\n * exportfs -v.\n * To update this temporary copy simply call this function again.\n *\n * TODO : Use /var/lib/nfs/etab instead of our private copy.\n *        But must implement locking to prevent concurrent access.\n *\n * TODO : The temporary file descriptor is never closed since\n *        there is no libshare_nfs_fini() function.\n */\nstatic int\nnfs_check_exportfs(void)\n{\n\tpid_t pid;\n\tint rc, status;\n\tstatic char nfs_exportfs_tempfile[] = \"/tmp/exportfs.XXXXXX\";\n\n\t/*\n\t * Close any existing temporary copies of output from exportfs.\n\t * We have already called unlink() so file will be deleted.\n\t */\n\tif (nfs_exportfs_temp_fd >= 0)\n\t\tclose(nfs_exportfs_temp_fd);\n\n\tnfs_exportfs_temp_fd = mkstemp(nfs_exportfs_tempfile);\n\n\tif (nfs_exportfs_temp_fd < 0)\n\t\treturn (SA_SYSTEM_ERR);\n\n\tunlink(nfs_exportfs_tempfile);\n\n\tfcntl(nfs_exportfs_temp_fd, F_SETFD, FD_CLOEXEC);\n\n\tpid = fork();\n\n\tif (pid < 0) {\n\t\t(void) close(nfs_exportfs_temp_fd);\n\t\tnfs_exportfs_temp_fd = -1;\n\t\treturn (SA_SYSTEM_ERR);\n\t}\n\n\tif (pid > 0) {\n\t\twhile ((rc = waitpid(pid, &status, 0)) <= 0 && errno == EINTR);\n\n\t\tif (rc <= 0) {\n\t\t\t(void) close(nfs_exportfs_temp_fd);\n\t\t\tnfs_exportfs_temp_fd = -1;\n\t\t\treturn (SA_SYSTEM_ERR);\n\t\t}\n\n\t\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {\n\t\t\t(void) close(nfs_exportfs_temp_fd);\n\t\t\tnfs_exportfs_temp_fd = -1;\n\t\t\treturn (SA_CONFIG_ERR);\n\t\t}\n\n\t\treturn (SA_OK);\n\t}\n\n\t/* child */\n\n\t/* exportfs -v */\n\n\tif (dup2(nfs_exportfs_temp_fd, STDOUT_FILENO) < 0)\n\t\texit(1);\n\n\trc = execlp(\"/usr/sbin/exportfs\", \"exportfs\", \"-v\", NULL);\n\n\tif (rc < 0) {\n\t\texit(1);\n\t}\n\n\texit(0);\n}\n\n/*\n * Provides a convenient wrapper for determing nfs availability\n */\nstatic boolean_t\nnfs_available(void)\n{\n\tif (nfs_exportfs_temp_fd == -1)\n\t\t(void) nfs_check_exportfs();\n\n\treturn ((nfs_exportfs_temp_fd != -1) ? B_TRUE : B_FALSE);\n}\n\n/*\n * Initializes the NFS functionality of libshare.\n */\nvoid\nlibshare_nfs_init(void)\n{\n\tnfs_fstype = register_fstype(\"nfs\", &nfs_shareops);\n}\n"], "fixing_code": ["/*\n * CDDL HEADER START\n *\n * The contents of this file are subject to the terms of the\n * Common Development and Distribution License (the \"License\").\n * You may not use this file except in compliance with the License.\n *\n * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE\n * or http://www.opensolaris.org/os/licensing.\n * See the License for the specific language governing permissions\n * and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL HEADER in each\n * file and include the License file at usr/src/OPENSOLARIS.LICENSE.\n * If applicable, add the following below this CDDL HEADER, with the\n * fields enclosed by brackets \"[]\" replaced with your own identifying\n * information: Portions Copyright [yyyy] [name of copyright owner]\n *\n * CDDL HEADER END\n */\n\n/*\n * Copyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.\n * Copyright (c) 2011 Gunnar Beutner\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <strings.h>\n#include <libintl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <libzfs.h>\n#include <libshare.h>\n#include \"libshare_impl.h\"\n#include \"nfs.h\"\n#include \"smb.h\"\n\nstatic sa_share_impl_t find_share(sa_handle_impl_t handle,\n    const char *sharepath);\nstatic sa_share_impl_t alloc_share(const char *sharepath);\nstatic void free_share(sa_share_impl_t share);\n\nstatic void parse_sharetab(sa_handle_impl_t impl_handle);\nstatic int process_share(sa_handle_impl_t impl_handle,\n    sa_share_impl_t impl_share, char *pathname, char *resource,\n    char *fstype, char *options, char *description,\n    char *dataset, boolean_t from_sharetab);\nstatic void update_sharetab(sa_handle_impl_t impl_handle);\n\nstatic int update_zfs_share(sa_share_impl_t impl_handle, const char *proto);\nstatic int update_zfs_shares(sa_handle_impl_t impl_handle, const char *proto);\n\nstatic int fstypes_count;\nstatic sa_fstype_t *fstypes;\n\n/*\n * Invokes the specified callback function for each Solaris share option\n * listed in the specified string.\n */\nint\nforeach_shareopt(const char *shareopts,\n    nfs_shareopt_callback_t callback, void *cookie)\n{\n\tchar *shareopts_dup, *opt, *cur, *value;\n\tint was_nul, rc;\n\n\tif (shareopts == NULL)\n\t\treturn (SA_OK);\n\n\tshareopts_dup = strdup(shareopts);\n\tif (shareopts_dup == NULL)\n\t\treturn (SA_NO_MEMORY);\n\n\topt = shareopts_dup;\n\twas_nul = 0;\n\n\twhile (1) {\n\t\tcur = opt;\n\n\t\twhile (*cur != ',' && *cur != '\\0')\n\t\t\tcur++;\n\n\t\tif (*cur == '\\0')\n\t\t\twas_nul = 1;\n\n\t\t*cur = '\\0';\n\n\t\tif (cur > opt) {\n\t\t\tvalue = strchr(opt, '=');\n\n\t\t\tif (value != NULL) {\n\t\t\t\t*value = '\\0';\n\t\t\t\tvalue++;\n\t\t\t}\n\n\t\t\trc = callback(opt, value, cookie);\n\n\t\t\tif (rc != SA_OK) {\n\t\t\t\tfree(shareopts_dup);\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t}\n\n\t\topt = cur + 1;\n\n\t\tif (was_nul)\n\t\t\tbreak;\n\t}\n\n\tfree(shareopts_dup);\n\n\treturn (SA_OK);\n}\n\nsa_fstype_t *\nregister_fstype(const char *name, const sa_share_ops_t *ops)\n{\n\tsa_fstype_t *fstype;\n\n\tfstype = calloc(sizeof (sa_fstype_t), 1);\n\n\tif (fstype == NULL)\n\t\treturn (NULL);\n\n\tfstype->name = name;\n\tfstype->ops = ops;\n\tfstype->fsinfo_index = fstypes_count;\n\n\tfstypes_count++;\n\n\tfstype->next = fstypes;\n\tfstypes = fstype;\n\n\treturn (fstype);\n}\n\nsa_handle_t\nsa_init(int init_service)\n{\n\tsa_handle_impl_t impl_handle;\n\n\timpl_handle = calloc(sizeof (struct sa_handle_impl), 1);\n\n\tif (impl_handle == NULL)\n\t\treturn (NULL);\n\n\timpl_handle->zfs_libhandle = libzfs_init();\n\n\tif (impl_handle->zfs_libhandle != NULL) {\n\t\tlibzfs_print_on_error(impl_handle->zfs_libhandle, B_TRUE);\n\t}\n\n\tparse_sharetab(impl_handle);\n\tupdate_zfs_shares(impl_handle, NULL);\n\n\treturn ((sa_handle_t)impl_handle);\n}\n\n__attribute__((constructor)) static void\nlibshare_init(void)\n{\n\tlibshare_nfs_init();\n\tlibshare_smb_init();\n}\n\nstatic void\nparse_sharetab(sa_handle_impl_t impl_handle) {\n\tFILE *fp;\n\tchar line[512];\n\tchar *eol, *pathname, *resource, *fstype, *options, *description;\n\n\tfp = fopen(\"/etc/dfs/sharetab\", \"r\");\n\n\tif (fp == NULL)\n\t\treturn;\n\n\twhile (fgets(line, sizeof (line), fp) != NULL) {\n\t\teol = line + strlen(line) - 1;\n\n\t\twhile (eol >= line) {\n\t\t\tif (*eol != '\\r' && *eol != '\\n')\n\t\t\t\tbreak;\n\n\t\t\t*eol = '\\0';\n\t\t\teol--;\n\t\t}\n\n\t\tpathname = line;\n\n\t\tif ((resource = strchr(pathname, '\\t')) == NULL)\n\t\t\tcontinue;\n\n\t\t*resource = '\\0';\n\t\tresource++;\n\n\t\tif ((fstype = strchr(resource, '\\t')) == NULL)\n\t\t\tcontinue;\n\n\t\t*fstype = '\\0';\n\t\tfstype++;\n\n\t\tif ((options = strchr(fstype, '\\t')) == NULL)\n\t\t\tcontinue;\n\n\t\t*options = '\\0';\n\t\toptions++;\n\n\t\tif ((description = strchr(fstype, '\\t')) != NULL) {\n\t\t\t*description = '\\0';\n\t\t\tdescription++;\n\t\t}\n\n\t\tif (strcmp(resource, \"-\") == 0)\n\t\t\tresource = NULL;\n\n\t\t(void) process_share(impl_handle, NULL, pathname, resource,\n\t\t    fstype, options, description, NULL, B_TRUE);\n\t}\n\n\tfclose(fp);\n}\n\nstatic void\nupdate_sharetab(sa_handle_impl_t impl_handle)\n{\n\tsa_share_impl_t impl_share;\n\tint temp_fd;\n\tFILE *temp_fp;\n\tchar tempfile[] = \"/etc/dfs/sharetab.XXXXXX\";\n\tsa_fstype_t *fstype;\n\tconst char *resource;\n\n\tif (mkdir(\"/etc/dfs\", 0755) < 0 && errno != EEXIST) {\n\t\treturn;\n\t}\n\n\ttemp_fd = mkstemp(tempfile);\n\n\tif (temp_fd < 0)\n\t\treturn;\n\n\ttemp_fp = fdopen(temp_fd, \"w\");\n\n\tif (temp_fp == NULL)\n\t\treturn;\n\n\timpl_share = impl_handle->shares;\n\twhile (impl_share != NULL) {\n\t\tfstype = fstypes;\n\t\twhile (fstype != NULL) {\n\t\t\tif (FSINFO(impl_share, fstype)->active &&\n\t\t\t    FSINFO(impl_share, fstype)->shareopts != NULL) {\n\t\t\t\tresource = FSINFO(impl_share, fstype)->resource;\n\n\t\t\t\tif (resource == NULL)\n\t\t\t\t\tresource = \"-\";\n\n\t\t\t\tfprintf(temp_fp, \"%s\\t%s\\t%s\\t%s\\n\",\n\t\t\t\t    impl_share->sharepath, resource,\n\t\t\t\t    fstype->name,\n\t\t\t\t    FSINFO(impl_share, fstype)->shareopts);\n\t\t\t}\n\n\t\t\tfstype = fstype->next;\n\t\t}\n\n\t\timpl_share = impl_share->next;\n\t}\n\n\tfflush(temp_fp);\n\tfsync(temp_fd);\n\tfclose(temp_fp);\n\n\trename(tempfile, \"/etc/dfs/sharetab\");\n}\n\ntypedef struct update_cookie_s {\n\tsa_handle_impl_t handle;\n\tconst char *proto;\n} update_cookie_t;\n\nstatic int\nupdate_zfs_shares_cb(zfs_handle_t *zhp, void *pcookie)\n{\n\tupdate_cookie_t *udata = (update_cookie_t *)pcookie;\n\tchar mountpoint[ZFS_MAXPROPLEN];\n\tchar shareopts[ZFS_MAXPROPLEN];\n\tchar *dataset;\n\tzfs_type_t type = zfs_get_type(zhp);\n\n\tif (type == ZFS_TYPE_FILESYSTEM &&\n\t    zfs_iter_filesystems(zhp, update_zfs_shares_cb, pcookie) != 0) {\n\t\tzfs_close(zhp);\n\t\treturn (1);\n\t}\n\n\tif (type != ZFS_TYPE_FILESYSTEM) {\n\t\tzfs_close(zhp);\n\t\treturn (0);\n\t}\n\n\tif (zfs_prop_get(zhp, ZFS_PROP_MOUNTPOINT, mountpoint,\n\t    sizeof (mountpoint), NULL, NULL, 0, B_FALSE) != 0) {\n\t\tzfs_close(zhp);\n\t\treturn (0);\n\t}\n\n\tdataset = (char *)zfs_get_name(zhp);\n\n\tif (dataset == NULL) {\n\t\tzfs_close(zhp);\n\t\treturn (0);\n\t}\n\n\tif (!zfs_is_mounted(zhp, NULL)) {\n\t\tzfs_close(zhp);\n\t\treturn (0);\n\t}\n\n\tif ((udata->proto == NULL || strcmp(udata->proto, \"nfs\") == 0) &&\n\t    zfs_prop_get(zhp, ZFS_PROP_SHARENFS, shareopts,\n\t    sizeof (shareopts), NULL, NULL, 0, B_FALSE) == 0 &&\n\t    strcmp(shareopts, \"off\") != 0) {\n\t\t(void) process_share(udata->handle, NULL, mountpoint, NULL,\n\t\t    \"nfs\", shareopts, NULL, dataset, B_FALSE);\n\t}\n\n\tif ((udata->proto == NULL || strcmp(udata->proto, \"smb\") == 0) &&\n\t    zfs_prop_get(zhp, ZFS_PROP_SHARESMB, shareopts,\n\t    sizeof (shareopts), NULL, NULL, 0, B_FALSE) == 0 &&\n\t    strcmp(shareopts, \"off\") != 0) {\n\t\t(void) process_share(udata->handle, NULL, mountpoint, NULL,\n\t\t    \"smb\", shareopts, NULL, dataset, B_FALSE);\n\t}\n\n\tzfs_close(zhp);\n\n\treturn (0);\n}\n\nstatic int\nupdate_zfs_share(sa_share_impl_t impl_share, const char *proto)\n{\n\tsa_handle_impl_t impl_handle = impl_share->handle;\n\tzfs_handle_t *zhp;\n\tupdate_cookie_t udata;\n\n\tif (impl_handle->zfs_libhandle == NULL)\n\t\t\treturn (SA_SYSTEM_ERR);\n\n\tassert(impl_share->dataset != NULL);\n\n\tzhp = zfs_open(impl_share->handle->zfs_libhandle, impl_share->dataset,\n\t    ZFS_TYPE_FILESYSTEM);\n\n\tif (zhp == NULL)\n\t\treturn (SA_SYSTEM_ERR);\n\n\tudata.handle = impl_handle;\n\tudata.proto = proto;\n\t(void) update_zfs_shares_cb(zhp, &udata);\n\n\treturn (SA_OK);\n}\n\nstatic int\nupdate_zfs_shares(sa_handle_impl_t impl_handle, const char *proto)\n{\n\tupdate_cookie_t udata;\n\n\tif (impl_handle->zfs_libhandle == NULL)\n\t\treturn (SA_SYSTEM_ERR);\n\n\tudata.handle = impl_handle;\n\tudata.proto = proto;\n\t(void) zfs_iter_root(impl_handle->zfs_libhandle, update_zfs_shares_cb,\n\t    &udata);\n\n\treturn (SA_OK);\n}\n\nstatic int\nprocess_share(sa_handle_impl_t impl_handle, sa_share_impl_t impl_share,\n    char *pathname, char *resource, char *proto,\n    char *options, char *description, char *dataset,\n    boolean_t from_sharetab)\n{\n\tstruct stat statbuf;\n\tint rc;\n\tchar *resource_dup = NULL, *dataset_dup = NULL;\n\tboolean_t new_share;\n\tsa_fstype_t *fstype;\n\n\tnew_share = B_FALSE;\n\n\tif (impl_share == NULL)\n\t\timpl_share = find_share(impl_handle, pathname);\n\n\tif (impl_share == NULL) {\n\t\tif (lstat(pathname, &statbuf) != 0 ||\n\t\t    !S_ISDIR(statbuf.st_mode))\n\t\t\treturn (SA_BAD_PATH);\n\n\t\timpl_share = alloc_share(pathname);\n\n\t\tif (impl_share == NULL) {\n\t\t\trc = SA_NO_MEMORY;\n\t\t\tgoto err;\n\t\t}\n\n\t\tnew_share = B_TRUE;\n\t}\n\n\tif (dataset != NULL) {\n\t\tdataset_dup = strdup(dataset);\n\n\t\tif (dataset_dup == NULL) {\n\t\t\trc = SA_NO_MEMORY;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tfree(impl_share->dataset);\n\timpl_share->dataset = dataset_dup;\n\n\trc = SA_INVALID_PROTOCOL;\n\n\tfstype = fstypes;\n\twhile (fstype != NULL) {\n\t\tif (strcmp(fstype->name, proto) == 0) {\n\t\t\tif (resource != NULL) {\n\t\t\t\tresource_dup = strdup(resource);\n\n\t\t\t\tif (resource_dup == NULL) {\n\t\t\t\t\trc = SA_NO_MEMORY;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfree(FSINFO(impl_share, fstype)->resource);\n\t\t\tFSINFO(impl_share, fstype)->resource = resource_dup;\n\n\t\t\trc = fstype->ops->update_shareopts(impl_share,\n\t\t\t    resource, options);\n\n\t\t\tif (rc == SA_OK && from_sharetab)\n\t\t\t\tFSINFO(impl_share, fstype)->active = B_TRUE;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tfstype = fstype->next;\n\t}\n\n\tif (rc != SA_OK)\n\t\tgoto err;\n\n\tif (new_share) {\n\t\timpl_share->handle = impl_handle;\n\n\t\timpl_share->next = impl_handle->shares;\n\t\timpl_handle->shares = impl_share;\n\n\t}\n\nerr:\n\tif (rc != SA_OK) {\n\t\tif (new_share)\n\t\t\tfree_share(impl_share);\n\t}\n\n\treturn (rc);\n}\n\nvoid\nsa_fini(sa_handle_t handle)\n{\n\tsa_handle_impl_t impl_handle = (sa_handle_impl_t)handle;\n\tsa_share_impl_t impl_share, next;\n\tsa_share_impl_t *pcurr;\n\n\tif (impl_handle == NULL)\n\t\treturn;\n\n\t/*\n\t * clean up shares which don't have a non-NULL dataset property,\n\t * which means they're in sharetab but we couldn't find their\n\t * ZFS dataset.\n\t */\n\tpcurr = &(impl_handle->shares);\n\timpl_share = *pcurr;\n\twhile (impl_share != NULL) {\n\t\tnext = impl_share->next;\n\n\t\tif (impl_share->dataset == NULL) {\n\t\t\t/* remove item from the linked list */\n\t\t\t*pcurr = next;\n\n\t\t\tsa_disable_share(impl_share, NULL);\n\n\t\t\tfree_share(impl_share);\n\t\t} else {\n\t\t\tpcurr = &(impl_share->next);\n\t\t}\n\n\t\timpl_share = next;\n\t}\n\n\tupdate_sharetab(impl_handle);\n\n\tif (impl_handle->zfs_libhandle != NULL)\n\t\tlibzfs_fini(impl_handle->zfs_libhandle);\n\n\timpl_share = impl_handle->shares;\n\twhile (impl_share != NULL) {\n\t\tnext = impl_share->next;\n\t\tfree_share(impl_share);\n\t\timpl_share = next;\n\t}\n\n\tfree(impl_handle);\n}\n\nstatic sa_share_impl_t\nfind_share(sa_handle_impl_t impl_handle, const char *sharepath)\n{\n\tsa_share_impl_t impl_share;\n\n\timpl_share = impl_handle->shares;\n\twhile (impl_share != NULL) {\n\t\tif (strcmp(impl_share->sharepath, sharepath) == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\timpl_share = impl_share->next;\n\t}\n\n\treturn (impl_share);\n}\n\nsa_share_t\nsa_find_share(sa_handle_t handle, char *sharepath)\n{\n\treturn ((sa_share_t)find_share((sa_handle_impl_t)handle, sharepath));\n}\n\nint\nsa_enable_share(sa_share_t share, char *protocol)\n{\n\tsa_share_impl_t impl_share = (sa_share_impl_t)share;\n\tint rc, ret;\n\tboolean_t found_protocol;\n\tsa_fstype_t *fstype;\n\n#ifdef DEBUG\n\tfprintf(stderr, \"sa_enable_share: share->sharepath=%s, protocol=%s\\n\",\n\t\timpl_share->sharepath, protocol);\n#endif\n\n\tassert(impl_share->handle != NULL);\n\n\tret = SA_OK;\n\tfound_protocol = B_FALSE;\n\n\tfstype = fstypes;\n\twhile (fstype != NULL) {\n\t\tif (protocol == NULL || strcmp(fstype->name, protocol) == 0) {\n\t\t\tupdate_zfs_share(impl_share, fstype->name);\n\n\t\t\trc = fstype->ops->enable_share(impl_share);\n\n\t\t\tif (rc != SA_OK)\n\t\t\t\tret = rc;\n\t\t\telse\n\t\t\t\tFSINFO(impl_share, fstype)->active = B_TRUE;\n\n\t\t\tfound_protocol = B_TRUE;\n\t\t}\n\n\t\tfstype = fstype->next;\n\t}\n\n\tupdate_sharetab(impl_share->handle);\n\n\treturn (found_protocol ? ret : SA_INVALID_PROTOCOL);\n}\n\nint\nsa_disable_share(sa_share_t share, char *protocol)\n{\n\tsa_share_impl_t impl_share = (sa_share_impl_t)share;\n\tint rc, ret;\n\tboolean_t found_protocol;\n\tsa_fstype_t *fstype;\n\n#ifdef DEBUG\n\tfprintf(stderr, \"sa_disable_share: share->sharepath=%s, protocol=%s\\n\",\n\t\timpl_share->sharepath, protocol);\n#endif\n\n\tret = SA_OK;\n\tfound_protocol = B_FALSE;\n\n\tfstype = fstypes;\n\twhile (fstype != NULL) {\n\t\tif (protocol == NULL || strcmp(fstype->name, protocol) == 0) {\n\t\t\trc = fstype->ops->disable_share(impl_share);\n\n\t\t\tif (rc == SA_OK) {\n\t\t\t\tfstype->ops->clear_shareopts(impl_share);\n\n\t\t\t\tFSINFO(impl_share, fstype)->active = B_FALSE;\n\t\t\t} else\n\t\t\t\tret = rc;\n\n\t\t\tfound_protocol = B_TRUE;\n\t\t}\n\n\t\tfstype = fstype->next;\n\t}\n\n\tupdate_sharetab(impl_share->handle);\n\n\treturn (found_protocol ? ret : SA_INVALID_PROTOCOL);\n}\n\n/*\n * sa_errorstr(err)\n *\n * convert an error value to an error string\n */\nchar *\nsa_errorstr(int err)\n{\n\tstatic char errstr[32];\n\tchar *ret = NULL;\n\n\tswitch (err) {\n\tcase SA_OK:\n\t\tret = dgettext(TEXT_DOMAIN, \"ok\");\n\t\tbreak;\n\tcase SA_NO_SUCH_PATH:\n\t\tret = dgettext(TEXT_DOMAIN, \"path doesn't exist\");\n\t\tbreak;\n\tcase SA_NO_MEMORY:\n\t\tret = dgettext(TEXT_DOMAIN, \"no memory\");\n\t\tbreak;\n\tcase SA_DUPLICATE_NAME:\n\t\tret = dgettext(TEXT_DOMAIN, \"name in use\");\n\t\tbreak;\n\tcase SA_BAD_PATH:\n\t\tret = dgettext(TEXT_DOMAIN, \"bad path\");\n\t\tbreak;\n\tcase SA_NO_SUCH_GROUP:\n\t\tret = dgettext(TEXT_DOMAIN, \"no such group\");\n\t\tbreak;\n\tcase SA_CONFIG_ERR:\n\t\tret = dgettext(TEXT_DOMAIN, \"configuration error\");\n\t\tbreak;\n\tcase SA_SYSTEM_ERR:\n\t\tret = dgettext(TEXT_DOMAIN, \"system error\");\n\t\tbreak;\n\tcase SA_SYNTAX_ERR:\n\t\tret = dgettext(TEXT_DOMAIN, \"syntax error\");\n\t\tbreak;\n\tcase SA_NO_PERMISSION:\n\t\tret = dgettext(TEXT_DOMAIN, \"no permission\");\n\t\tbreak;\n\tcase SA_BUSY:\n\t\tret = dgettext(TEXT_DOMAIN, \"busy\");\n\t\tbreak;\n\tcase SA_NO_SUCH_PROP:\n\t\tret = dgettext(TEXT_DOMAIN, \"no such property\");\n\t\tbreak;\n\tcase SA_INVALID_NAME:\n\t\tret = dgettext(TEXT_DOMAIN, \"invalid name\");\n\t\tbreak;\n\tcase SA_INVALID_PROTOCOL:\n\t\tret = dgettext(TEXT_DOMAIN, \"invalid protocol\");\n\t\tbreak;\n\tcase SA_NOT_ALLOWED:\n\t\tret = dgettext(TEXT_DOMAIN, \"operation not allowed\");\n\t\tbreak;\n\tcase SA_BAD_VALUE:\n\t\tret = dgettext(TEXT_DOMAIN, \"bad property value\");\n\t\tbreak;\n\tcase SA_INVALID_SECURITY:\n\t\tret = dgettext(TEXT_DOMAIN, \"invalid security type\");\n\t\tbreak;\n\tcase SA_NO_SUCH_SECURITY:\n\t\tret = dgettext(TEXT_DOMAIN, \"security type not found\");\n\t\tbreak;\n\tcase SA_VALUE_CONFLICT:\n\t\tret = dgettext(TEXT_DOMAIN, \"property value conflict\");\n\t\tbreak;\n\tcase SA_NOT_IMPLEMENTED:\n\t\tret = dgettext(TEXT_DOMAIN, \"not implemented\");\n\t\tbreak;\n\tcase SA_INVALID_PATH:\n\t\tret = dgettext(TEXT_DOMAIN, \"invalid path\");\n\t\tbreak;\n\tcase SA_NOT_SUPPORTED:\n\t\tret = dgettext(TEXT_DOMAIN, \"operation not supported\");\n\t\tbreak;\n\tcase SA_PROP_SHARE_ONLY:\n\t\tret = dgettext(TEXT_DOMAIN, \"property not valid for group\");\n\t\tbreak;\n\tcase SA_NOT_SHARED:\n\t\tret = dgettext(TEXT_DOMAIN, \"not shared\");\n\t\tbreak;\n\tcase SA_NO_SUCH_RESOURCE:\n\t\tret = dgettext(TEXT_DOMAIN, \"no such resource\");\n\t\tbreak;\n\tcase SA_RESOURCE_REQUIRED:\n\t\tret = dgettext(TEXT_DOMAIN, \"resource name required\");\n\t\tbreak;\n\tcase SA_MULTIPLE_ERROR:\n\t\tret = dgettext(TEXT_DOMAIN, \"errors from multiple protocols\");\n\t\tbreak;\n\tcase SA_PATH_IS_SUBDIR:\n\t\tret = dgettext(TEXT_DOMAIN, \"path is a subpath of share\");\n\t\tbreak;\n\tcase SA_PATH_IS_PARENTDIR:\n\t\tret = dgettext(TEXT_DOMAIN, \"path is parent of a share\");\n\t\tbreak;\n\tcase SA_NO_SECTION:\n\t\tret = dgettext(TEXT_DOMAIN, \"protocol requires a section\");\n\t\tbreak;\n\tcase SA_NO_PROPERTIES:\n\t\tret = dgettext(TEXT_DOMAIN, \"properties not found\");\n\t\tbreak;\n\tcase SA_NO_SUCH_SECTION:\n\t\tret = dgettext(TEXT_DOMAIN, \"section not found\");\n\t\tbreak;\n\tcase SA_PASSWORD_ENC:\n\t\tret = dgettext(TEXT_DOMAIN, \"passwords must be encrypted\");\n\t\tbreak;\n\tcase SA_SHARE_EXISTS:\n\t\tret = dgettext(TEXT_DOMAIN, \"path or file is already shared\");\n\t\tbreak;\n\tdefault:\n\t\t(void) snprintf(errstr, sizeof (errstr),\n\t\t    dgettext(TEXT_DOMAIN, \"unknown %d\"), err);\n\t\tret = errstr;\n\t}\n\treturn (ret);\n}\n\nint\nsa_parse_legacy_options(sa_group_t group, char *options, char *proto)\n{\n\tsa_fstype_t *fstype;\n\n#ifdef DEBUG\n\tfprintf(stderr, \"sa_parse_legacy_options: options=%s, proto=%s\\n\",\n\t\toptions, proto);\n#endif\n\n\tfstype = fstypes;\n\twhile (fstype != NULL) {\n\t\tif (strcmp(fstype->name, proto) != 0) {\n\t\t\tfstype = fstype->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\treturn (fstype->ops->validate_shareopts(options));\n\t}\n\n\treturn (SA_INVALID_PROTOCOL);\n}\n\nboolean_t\nsa_needs_refresh(sa_handle_t handle)\n{\n\treturn (B_TRUE);\n}\n\nlibzfs_handle_t *\nsa_get_zfs_handle(sa_handle_t handle)\n{\n\tsa_handle_impl_t impl_handle = (sa_handle_impl_t)handle;\n\n\tif (impl_handle == NULL)\n\t\treturn (NULL);\n\n\treturn (impl_handle->zfs_libhandle);\n}\n\nstatic sa_share_impl_t\nalloc_share(const char *sharepath)\n{\n\tsa_share_impl_t impl_share;\n\n\timpl_share = calloc(sizeof (struct sa_share_impl), 1);\n\n\tif (impl_share == NULL)\n\t\treturn (NULL);\n\n\timpl_share->sharepath = strdup(sharepath);\n\n\tif (impl_share->sharepath == NULL) {\n\t\tfree(impl_share);\n\t\treturn (NULL);\n\t}\n\n\timpl_share->fsinfo = calloc(sizeof (sa_share_fsinfo_t), fstypes_count);\n\n\tif (impl_share->fsinfo == NULL) {\n\t\tfree(impl_share->sharepath);\n\t\tfree(impl_share);\n\t\treturn (NULL);\n\t}\n\n\treturn (impl_share);\n}\n\nstatic void\nfree_share(sa_share_impl_t impl_share) {\n\tsa_fstype_t *fstype;\n\n\tfstype = fstypes;\n\twhile (fstype != NULL) {\n\t\tfstype->ops->clear_shareopts(impl_share);\n\n\t\tfree(FSINFO(impl_share, fstype)->resource);\n\n\t\tfstype = fstype->next;\n\t}\n\n\tfree(impl_share->sharepath);\n\tfree(impl_share->dataset);\n\tfree(impl_share->fsinfo);\n\tfree(impl_share);\n}\n\nint\nsa_zfs_process_share(sa_handle_t handle, sa_group_t group, sa_share_t share,\n    char *mountpoint, char *proto, zprop_source_t source, char *shareopts,\n    char *sourcestr, char *dataset)\n{\n\tsa_handle_impl_t impl_handle = (sa_handle_impl_t)handle;\n\tsa_share_impl_t impl_share = (sa_share_impl_t)share;\n\n#ifdef DEBUG\n\tfprintf(stderr, \"sa_zfs_process_share: mountpoint=%s, proto=%s, \"\n\t    \"shareopts=%s, sourcestr=%s, dataset=%s\\n\", mountpoint, proto,\n\t    shareopts, sourcestr, dataset);\n#endif\n\n\treturn (process_share(impl_handle, impl_share, mountpoint, NULL,\n\t    proto, shareopts, NULL, dataset, B_FALSE));\n}\n\nvoid\nsa_update_sharetab_ts(sa_handle_t handle)\n{\n\tsa_handle_impl_t impl_handle = (sa_handle_impl_t)handle;\n\n\tupdate_sharetab(impl_handle);\n}\n", "/*\n * CDDL HEADER START\n *\n * The contents of this file are subject to the terms of the\n * Common Development and Distribution License (the \"License\").\n * You may not use this file except in compliance with the License.\n *\n * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE\n * or http://www.opensolaris.org/os/licensing.\n * See the License for the specific language governing permissions\n * and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL HEADER in each\n * file and include the License file at usr/src/OPENSOLARIS.LICENSE.\n * If applicable, add the following below this CDDL HEADER, with the\n * fields enclosed by brackets \"[]\" replaced with your own identifying\n * information: Portions Copyright [yyyy] [name of copyright owner]\n *\n * CDDL HEADER END\n */\n\n/*\n * Copyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.\n * Copyright (c) 2011 Gunnar Beutner\n */\n\nstruct sa_handle_impl;\n\ntypedef struct sa_share_fsinfo {\n\tboolean_t active;\n\tchar *resource;\n\tchar *shareopts;\n} sa_share_fsinfo_t;\n\ntypedef struct sa_share_impl {\n\tstruct sa_share_impl *next;\n\n\tstruct sa_handle_impl *handle;\n\n\tchar *sharepath;\n\tchar *dataset;\n\n\tsa_share_fsinfo_t *fsinfo; /* per-fstype information */\n} *sa_share_impl_t;\n\n#define\tFSINFO(impl_share, fstype) (&(impl_share->fsinfo[fstype->fsinfo_index]))\n\ntypedef struct sa_share_ops {\n\tint (*enable_share)(sa_share_impl_t share);\n\tint (*disable_share)(sa_share_impl_t share);\n\tint (*validate_shareopts)(const char *shareopts);\n\tint (*update_shareopts)(sa_share_impl_t impl_share,\n\t    const char *resource, const char *shareopts);\n\tvoid (*clear_shareopts)(sa_share_impl_t impl_share);\n} sa_share_ops_t;\n\ntypedef struct sa_fstype {\n\tstruct sa_fstype *next;\n\n\tconst char *name;\n\tconst sa_share_ops_t *ops;\n\tint fsinfo_index;\n} sa_fstype_t;\n\ntypedef struct sa_handle_impl {\n\tlibzfs_handle_t *zfs_libhandle;\n\tsa_share_impl_t shares;\n} *sa_handle_impl_t;\n\ntypedef int (*nfs_shareopt_callback_t)(const char *, const char *, void *);\n\nsa_fstype_t *register_fstype(const char *name, const sa_share_ops_t *ops);\nint foreach_shareopt(const char *, nfs_shareopt_callback_t, void *);\n", "/*\n * CDDL HEADER START\n *\n * The contents of this file are subject to the terms of the\n * Common Development and Distribution License (the \"License\").\n * You may not use this file except in compliance with the License.\n *\n * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE\n * or http://www.opensolaris.org/os/licensing.\n * See the License for the specific language governing permissions\n * and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL HEADER in each\n * file and include the License file at usr/src/OPENSOLARIS.LICENSE.\n * If applicable, add the following below this CDDL HEADER, with the\n * fields enclosed by brackets \"[]\" replaced with your own identifying\n * information: Portions Copyright [yyyy] [name of copyright owner]\n *\n * CDDL HEADER END\n */\n\n/*\n * Copyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.\n * Copyright (c) 2011 Gunnar Beutner\n * Copyright (c) 2012 Cyril Plisko. All rights reserved.\n */\n\n#include <stdio.h>\n#include <strings.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <libzfs.h>\n#include <libshare.h>\n#include \"libshare_impl.h\"\n\nstatic boolean_t nfs_available(void);\n\nstatic sa_fstype_t *nfs_fstype;\n\n/*\n * nfs_exportfs_temp_fd refers to a temporary copy of the output\n * from exportfs -v.\n */\nstatic int nfs_exportfs_temp_fd = -1;\n\ntypedef int (*nfs_host_callback_t)(const char *sharepath, const char *host,\n    const char *security, const char *access, void *cookie);\n\ntypedef struct nfs_host_cookie_s {\n\tnfs_host_callback_t callback;\n\tconst char *sharepath;\n\tvoid *cookie;\n\tconst char *security;\n} nfs_host_cookie_t;\n\n/*\n * Helper function for foreach_host. This function checks whether the\n * current share option is a host specification and invokes a callback\n * function with information about the host.\n */\nstatic int\nforeach_nfs_host_cb(const char *opt, const char *value, void *pcookie)\n{\n\tint rc;\n\tconst char *access;\n\tchar *host_dup, *host, *next;\n\tnfs_host_cookie_t *udata = (nfs_host_cookie_t *)pcookie;\n\n#ifdef DEBUG\n\tfprintf(stderr, \"foreach_nfs_host_cb: key=%s, value=%s\\n\", opt, value);\n#endif\n\n\tif (strcmp(opt, \"sec\") == 0)\n\t\tudata->security = value;\n\n\tif (strcmp(opt, \"rw\") == 0 || strcmp(opt, \"ro\") == 0) {\n\t\tif (value == NULL)\n\t\t\tvalue = \"*\";\n\n\t\taccess = opt;\n\n\t\thost_dup = strdup(value);\n\n\t\tif (host_dup == NULL)\n\t\t\treturn (SA_NO_MEMORY);\n\n\t\thost = host_dup;\n\n\t\tdo {\n\t\t\tnext = strchr(host, ':');\n\t\t\tif (next != NULL) {\n\t\t\t\t*next = '\\0';\n\t\t\t\tnext++;\n\t\t\t}\n\n\t\t\trc = udata->callback(udata->sharepath, host,\n\t\t\t    udata->security, access, udata->cookie);\n\n\t\t\tif (rc != SA_OK) {\n\t\t\t\tfree(host_dup);\n\n\t\t\t\treturn (rc);\n\t\t\t}\n\n\t\t\thost = next;\n\t\t} while (host != NULL);\n\n\t\tfree(host_dup);\n\t}\n\n\treturn (SA_OK);\n}\n\n/*\n * Invokes a callback function for all NFS hosts that are set for a share.\n */\nstatic int\nforeach_nfs_host(sa_share_impl_t impl_share, nfs_host_callback_t callback,\n    void *cookie)\n{\n\tnfs_host_cookie_t udata;\n\tchar *shareopts;\n\n\tudata.callback = callback;\n\tudata.sharepath = impl_share->sharepath;\n\tudata.cookie = cookie;\n\tudata.security = \"sys\";\n\n\tshareopts = FSINFO(impl_share, nfs_fstype)->shareopts;\n\n\treturn foreach_nfs_shareopt(shareopts, foreach_nfs_host_cb,\n\t    &udata);\n}\n\n/*\n * Converts a Solaris NFS host specification to its Linux equivalent.\n */\nstatic int\nget_linux_hostspec(const char *solaris_hostspec, char **plinux_hostspec)\n{\n\t/*\n\t * For now we just support CIDR masks (e.g. @192.168.0.0/16) and host\n\t * wildcards (e.g. *.example.org).\n\t */\n\tif (solaris_hostspec[0] == '@') {\n\t\t/*\n\t\t * Solaris host specifier, e.g. @192.168.0.0/16; we just need\n\t\t * to skip the @ in this case\n\t\t */\n\t\t*plinux_hostspec = strdup(solaris_hostspec + 1);\n\t} else {\n\t\t*plinux_hostspec = strdup(solaris_hostspec);\n\t}\n\n\tif (*plinux_hostspec == NULL) {\n\t\treturn (SA_NO_MEMORY);\n\t}\n\n\treturn (SA_OK);\n}\n\n/*\n * Used internally by nfs_enable_share to enable sharing for a single host.\n */\nstatic int\nnfs_enable_share_one(const char *sharepath, const char *host,\n    const char *security, const char *access, void *pcookie)\n{\n\tint rc;\n\tchar *linuxhost, *hostpath, *opts;\n\tconst char *linux_opts = (const char *)pcookie;\n\tchar *argv[6];\n\n\t/* exportfs -i -o sec=XX,rX,<opts> <host>:<sharepath> */\n\n\trc = get_linux_hostspec(host, &linuxhost);\n\n\tif (rc < 0)\n\t\texit(1);\n\n\thostpath = malloc(strlen(linuxhost) + 1 + strlen(sharepath) + 1);\n\n\tif (hostpath == NULL) {\n\t\tfree(linuxhost);\n\n\t\texit(1);\n\t}\n\n\tsprintf(hostpath, \"%s:%s\", linuxhost, sharepath);\n\n\tfree(linuxhost);\n\n\tif (linux_opts == NULL)\n\t\tlinux_opts = \"\";\n\n\topts = malloc(4 + strlen(security) + 4 + strlen(linux_opts) + 1);\n\n\tif (opts == NULL)\n\t\texit(1);\n\n\tsprintf(opts, \"sec=%s,%s,%s\", security, access, linux_opts);\n\n#ifdef DEBUG\n\tfprintf(stderr, \"sharing %s with opts %s\\n\", hostpath, opts);\n#endif\n\n\targv[0] = \"/usr/sbin/exportfs\";\n\targv[1] = \"-i\";\n\targv[2] = \"-o\";\n\targv[3] = opts;\n\targv[4] = hostpath;\n\targv[5] = NULL;\n\n\trc = libzfs_run_process(argv[0], argv, 0);\n\n\tfree(hostpath);\n\tfree(opts);\n\n\tif (rc < 0)\n\t\treturn (SA_SYSTEM_ERR);\n\telse\n\t\treturn (SA_OK);\n}\n\n/*\n * Adds a Linux share option to an array of NFS options.\n */\nstatic int\nadd_linux_shareopt(char **plinux_opts, const char *key, const char *value)\n{\n\tsize_t len = 0;\n\tchar *new_linux_opts;\n\n\tif (*plinux_opts != NULL)\n\t\tlen = strlen(*plinux_opts);\n\n\tnew_linux_opts = realloc(*plinux_opts, len + 1 + strlen(key) +\n\t    (value ? 1 + strlen(value) : 0) + 1);\n\n\tif (new_linux_opts == NULL)\n\t\treturn (SA_NO_MEMORY);\n\n\tnew_linux_opts[len] = '\\0';\n\n\tif (len > 0)\n\t\tstrcat(new_linux_opts, \",\");\n\n\tstrcat(new_linux_opts, key);\n\n\tif (value != NULL) {\n\t\tstrcat(new_linux_opts, \"=\");\n\t\tstrcat(new_linux_opts, value);\n\t}\n\n\t*plinux_opts = new_linux_opts;\n\n\treturn (SA_OK);\n}\n\n/*\n * Validates and converts a single Solaris share option to its Linux\n * equivalent.\n */\nstatic int\nget_linux_shareopts_cb(const char *key, const char *value, void *cookie)\n{\n\tchar **plinux_opts = (char **)cookie;\n\n\t/* host-specific options, these are taken care of elsewhere */\n\tif (strcmp(key, \"ro\") == 0 || strcmp(key, \"rw\") == 0 ||\n\t    strcmp(key, \"sec\") == 0)\n\t\treturn (SA_OK);\n\n\tif (strcmp(key, \"anon\") == 0)\n\t\tkey = \"anonuid\";\n\n\tif (strcmp(key, \"root_mapping\") == 0) {\n\t\t(void) add_linux_shareopt(plinux_opts, \"root_squash\", NULL);\n\t\tkey = \"anonuid\";\n\t}\n\n\tif (strcmp(key, \"nosub\") == 0)\n\t\tkey = \"subtree_check\";\n\n\tif (strcmp(key, \"insecure\") != 0 && strcmp(key, \"secure\") != 0 &&\n\t    strcmp(key, \"async\") != 0 && strcmp(key, \"sync\") != 0 &&\n\t    strcmp(key, \"no_wdelay\") != 0 && strcmp(key, \"wdelay\") != 0 &&\n\t    strcmp(key, \"nohide\") != 0 && strcmp(key, \"hide\") != 0 &&\n\t    strcmp(key, \"crossmnt\") != 0 &&\n\t    strcmp(key, \"no_subtree_check\") != 0 &&\n\t    strcmp(key, \"subtree_check\") != 0 &&\n\t    strcmp(key, \"insecure_locks\") != 0 &&\n\t    strcmp(key, \"secure_locks\") != 0 &&\n\t    strcmp(key, \"no_auth_nlm\") != 0 && strcmp(key, \"auth_nlm\") != 0 &&\n\t    strcmp(key, \"no_acl\") != 0 && strcmp(key, \"mountpoint\") != 0 &&\n\t    strcmp(key, \"mp\") != 0 && strcmp(key, \"fsuid\") != 0 &&\n\t    strcmp(key, \"refer\") != 0 && strcmp(key, \"replicas\") != 0 &&\n\t    strcmp(key, \"root_squash\") != 0 &&\n\t    strcmp(key, \"no_root_squash\") != 0 &&\n\t    strcmp(key, \"all_squash\") != 0 &&\n\t    strcmp(key, \"no_all_squash\") != 0 && strcmp(key, \"fsid\") != 0 &&\n\t    strcmp(key, \"anonuid\") != 0 && strcmp(key, \"anongid\") != 0) {\n\t\treturn (SA_SYNTAX_ERR);\n\t}\n\n\t(void) add_linux_shareopt(plinux_opts, key, value);\n\n\treturn (SA_OK);\n}\n\n/*\n * Takes a string containing Solaris share options (e.g. \"sync,no_acl\") and\n * converts them to a NULL-terminated array of Linux NFS options.\n */\nstatic int\nget_linux_shareopts(const char *shareopts, char **plinux_opts)\n{\n\tint rc;\n\n\tassert(plinux_opts != NULL);\n\n\t*plinux_opts = NULL;\n\n\t/* default options for Solaris shares */\n\t(void) add_linux_shareopt(plinux_opts, \"no_subtree_check\", NULL);\n\t(void) add_linux_shareopt(plinux_opts, \"no_root_squash\", NULL);\n\t(void) add_linux_shareopt(plinux_opts, \"mountpoint\", NULL);\n\n\trc = foreach_shareopt(shareopts, get_linux_shareopts_cb,\n\t    plinux_opts);\n\n\tif (rc != SA_OK) {\n\t\tfree(*plinux_opts);\n\t\t*plinux_opts = NULL;\n\t}\n\n\treturn (rc);\n}\n\n/*\n * Enables NFS sharing for the specified share.\n */\nstatic int\nnfs_enable_share(sa_share_impl_t impl_share)\n{\n\tchar *shareopts, *linux_opts;\n\tint rc;\n\n\tif (!nfs_available()) {\n\t\treturn (SA_SYSTEM_ERR);\n\t}\n\n\tshareopts = FSINFO(impl_share, nfs_fstype)->shareopts;\n\n\tif (shareopts == NULL)\n\t\treturn (SA_OK);\n\n\trc = get_linux_shareopts(shareopts, &linux_opts);\n\n\tif (rc != SA_OK)\n\t\treturn (rc);\n\n\trc = foreach_nfs_host(impl_share, nfs_enable_share_one, linux_opts);\n\n\tfree(linux_opts);\n\n\treturn (rc);\n}\n\n/*\n * Used internally by nfs_disable_share to disable sharing for a single host.\n */\nstatic int\nnfs_disable_share_one(const char *sharepath, const char *host,\n    const char *security, const char *access, void *cookie)\n{\n\tint rc;\n\tchar *linuxhost, *hostpath;\n\tchar *argv[4];\n\n\trc = get_linux_hostspec(host, &linuxhost);\n\n\tif (rc < 0)\n\t\texit(1);\n\n\thostpath = malloc(strlen(linuxhost) + 1 + strlen(sharepath) + 1);\n\n\tif (hostpath == NULL) {\n\t\tfree(linuxhost);\n\t\texit(1);\n\t}\n\n\tsprintf(hostpath, \"%s:%s\", linuxhost, sharepath);\n\n\tfree(linuxhost);\n\n#ifdef DEBUG\n\tfprintf(stderr, \"unsharing %s\\n\", hostpath);\n#endif\n\n\targv[0] = \"/usr/sbin/exportfs\";\n\targv[1] = \"-u\";\n\targv[2] = hostpath;\n\targv[3] = NULL;\n\n\trc = libzfs_run_process(argv[0], argv, 0);\n\n\tfree(hostpath);\n\n\tif (rc < 0)\n\t\treturn (SA_SYSTEM_ERR);\n\telse\n\t\treturn (SA_OK);\n}\n\n/*\n * Disables NFS sharing for the specified share.\n */\nstatic int\nnfs_disable_share(sa_share_impl_t impl_share)\n{\n\tif (!nfs_available()) {\n\t\t/*\n\t\t * The share can't possibly be active, so nothing\n\t\t * needs to be done to disable it.\n\t\t */\n\t\treturn (SA_OK);\n\t}\n\n\treturn (foreach_nfs_host(impl_share, nfs_disable_share_one, NULL));\n}\n\n/*\n * Checks whether the specified NFS share options are syntactically correct.\n */\nstatic int\nnfs_validate_shareopts(const char *shareopts)\n{\n\tchar *linux_opts;\n\tint rc;\n\n\trc = get_linux_shareopts(shareopts, &linux_opts);\n\n\tif (rc != SA_OK)\n\t\treturn (rc);\n\n\tfree(linux_opts);\n\n\treturn (SA_OK);\n}\n\n/*\n * Checks whether a share is currently active.\n */\nstatic boolean_t\nnfs_is_share_active(sa_share_impl_t impl_share)\n{\n\tchar line[512];\n\tchar *tab, *cur;\n\tFILE *nfs_exportfs_temp_fp;\n\n\tif (!nfs_available())\n\t\treturn (B_FALSE);\n\n\tnfs_exportfs_temp_fp = fdopen(dup(nfs_exportfs_temp_fd), \"r\");\n\n\tif (nfs_exportfs_temp_fp == NULL ||\n\t    fseek(nfs_exportfs_temp_fp, 0, SEEK_SET) < 0) {\n\t\tfclose(nfs_exportfs_temp_fp);\n\t\treturn (B_FALSE);\n\t}\n\n\twhile (fgets(line, sizeof (line), nfs_exportfs_temp_fp) != NULL) {\n\t\t/*\n\t\t * exportfs uses separate lines for the share path\n\t\t * and the export options when the share path is longer\n\t\t * than a certain amount of characters; this ignores\n\t\t * the option lines\n\t\t */\n\t\tif (line[0] == '\\t')\n\t\t\tcontinue;\n\n\t\ttab = strchr(line, '\\t');\n\n\t\tif (tab != NULL) {\n\t\t\t*tab = '\\0';\n\t\t\tcur = tab - 1;\n\t\t} else {\n\t\t\t/*\n\t\t\t * there's no tab character, which means the\n\t\t\t * NFS options are on a separate line; we just\n\t\t\t * need to remove the new-line character\n\t\t\t * at the end of the line\n\t\t\t */\n\t\t\tcur = line + strlen(line) - 1;\n\t\t}\n\n\t\t/* remove trailing spaces and new-line characters */\n\t\twhile (cur >= line && (*cur == ' ' || *cur == '\\n'))\n\t\t\t*cur-- = '\\0';\n\n\t\tif (strcmp(line, impl_share->sharepath) == 0) {\n\t\t\tfclose(nfs_exportfs_temp_fp);\n\t\t\treturn (B_TRUE);\n\t\t}\n\t}\n\n\tfclose(nfs_exportfs_temp_fp);\n\n\treturn (B_FALSE);\n}\n\n/*\n * Called to update a share's options. A share's options might be out of\n * date if the share was loaded from disk (i.e. /etc/dfs/sharetab) and the\n * \"sharenfs\" dataset property has changed in the meantime. This function\n * also takes care of re-enabling the share if necessary.\n */\nstatic int\nnfs_update_shareopts(sa_share_impl_t impl_share, const char *resource,\n    const char *shareopts)\n{\n\tchar *shareopts_dup;\n\tboolean_t needs_reshare = B_FALSE;\n\tchar *old_shareopts;\n\n\tFSINFO(impl_share, nfs_fstype)->active =\n\t    nfs_is_share_active(impl_share);\n\n\told_shareopts = FSINFO(impl_share, nfs_fstype)->shareopts;\n\n\tif (strcmp(shareopts, \"on\") == 0)\n\t\tshareopts = \"rw\";\n\n\tif (FSINFO(impl_share, nfs_fstype)->active && old_shareopts != NULL &&\n\t    strcmp(old_shareopts, shareopts) != 0) {\n\t\tneeds_reshare = B_TRUE;\n\t\tnfs_disable_share(impl_share);\n\t}\n\n\tshareopts_dup = strdup(shareopts);\n\n\tif (shareopts_dup == NULL)\n\t\treturn (SA_NO_MEMORY);\n\n\tif (old_shareopts != NULL)\n\t\tfree(old_shareopts);\n\n\tFSINFO(impl_share, nfs_fstype)->shareopts = shareopts_dup;\n\n\tif (needs_reshare)\n\t\tnfs_enable_share(impl_share);\n\n\treturn (SA_OK);\n}\n\n/*\n * Clears a share's NFS options. Used by libshare to\n * clean up shares that are about to be free()'d.\n */\nstatic void\nnfs_clear_shareopts(sa_share_impl_t impl_share)\n{\n\tfree(FSINFO(impl_share, nfs_fstype)->shareopts);\n\tFSINFO(impl_share, nfs_fstype)->shareopts = NULL;\n}\n\nstatic const sa_share_ops_t nfs_shareops = {\n\t.enable_share = nfs_enable_share,\n\t.disable_share = nfs_disable_share,\n\n\t.validate_shareopts = nfs_validate_shareopts,\n\t.update_shareopts = nfs_update_shareopts,\n\t.clear_shareopts = nfs_clear_shareopts,\n};\n\n/*\n * nfs_check_exportfs() checks that the exportfs command runs\n * and also maintains a temporary copy of the output from\n * exportfs -v.\n * To update this temporary copy simply call this function again.\n *\n * TODO : Use /var/lib/nfs/etab instead of our private copy.\n *        But must implement locking to prevent concurrent access.\n *\n * TODO : The temporary file descriptor is never closed since\n *        there is no libshare_nfs_fini() function.\n */\nstatic int\nnfs_check_exportfs(void)\n{\n\tpid_t pid;\n\tint rc, status;\n\tstatic char nfs_exportfs_tempfile[] = \"/tmp/exportfs.XXXXXX\";\n\n\t/*\n\t * Close any existing temporary copies of output from exportfs.\n\t * We have already called unlink() so file will be deleted.\n\t */\n\tif (nfs_exportfs_temp_fd >= 0)\n\t\tclose(nfs_exportfs_temp_fd);\n\n\tnfs_exportfs_temp_fd = mkstemp(nfs_exportfs_tempfile);\n\n\tif (nfs_exportfs_temp_fd < 0)\n\t\treturn (SA_SYSTEM_ERR);\n\n\tunlink(nfs_exportfs_tempfile);\n\n\tfcntl(nfs_exportfs_temp_fd, F_SETFD, FD_CLOEXEC);\n\n\tpid = fork();\n\n\tif (pid < 0) {\n\t\t(void) close(nfs_exportfs_temp_fd);\n\t\tnfs_exportfs_temp_fd = -1;\n\t\treturn (SA_SYSTEM_ERR);\n\t}\n\n\tif (pid > 0) {\n\t\twhile ((rc = waitpid(pid, &status, 0)) <= 0 && errno == EINTR);\n\n\t\tif (rc <= 0) {\n\t\t\t(void) close(nfs_exportfs_temp_fd);\n\t\t\tnfs_exportfs_temp_fd = -1;\n\t\t\treturn (SA_SYSTEM_ERR);\n\t\t}\n\n\t\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {\n\t\t\t(void) close(nfs_exportfs_temp_fd);\n\t\t\tnfs_exportfs_temp_fd = -1;\n\t\t\treturn (SA_CONFIG_ERR);\n\t\t}\n\n\t\treturn (SA_OK);\n\t}\n\n\t/* child */\n\n\t/* exportfs -v */\n\n\tif (dup2(nfs_exportfs_temp_fd, STDOUT_FILENO) < 0)\n\t\texit(1);\n\n\trc = execlp(\"/usr/sbin/exportfs\", \"exportfs\", \"-v\", NULL);\n\n\tif (rc < 0) {\n\t\texit(1);\n\t}\n\n\texit(0);\n}\n\n/*\n * Provides a convenient wrapper for determing nfs availability\n */\nstatic boolean_t\nnfs_available(void)\n{\n\tif (nfs_exportfs_temp_fd == -1)\n\t\t(void) nfs_check_exportfs();\n\n\treturn ((nfs_exportfs_temp_fd != -1) ? B_TRUE : B_FALSE);\n}\n\n/*\n * Initializes the NFS functionality of libshare.\n */\nvoid\nlibshare_nfs_init(void)\n{\n\tnfs_fstype = register_fstype(\"nfs\", &nfs_shareops);\n}\n"], "filenames": ["lib/libshare/libshare.c", "lib/libshare/libshare_impl.h", "lib/libshare/nfs.c"], "buggy_code_start_loc": [58, 69, 47], "buggy_code_end_loc": [58, 70, 394], "fixing_code_start_loc": [59, 70, 46], "fixing_code_end_loc": [118, 74, 331], "type": "CWE-200", "message": "sharenfs 0.6.4, when built with commits bcdd594 and 7d08880 from the zfs repository, provides world readable access to the shared zfs file system, which might allow remote authenticated users to obtain sensitive information by reading shared files.", "other": {"cve": {"id": "CVE-2015-3400", "sourceIdentifier": "cve@mitre.org", "published": "2017-10-18T15:29:00.423", "lastModified": "2017-11-08T13:03:08.917", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "sharenfs 0.6.4, when built with commits bcdd594 and 7d08880 from the zfs repository, provides world readable access to the shared zfs file system, which might allow remote authenticated users to obtain sensitive information by reading shared files."}, {"lang": "es", "value": "sharenfs 0.6.4, cuando se integra con los commits bcdd594 y 7d08880 del repositorio zfs, proporciona acceso de lectura global al sistema de archivos zfs compartido, lo que podr\u00eda permitir que usuarios autenticados remotos obtengan informaci\u00f3n sensible mediante la lectura de archivos compartidos."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:zfsonlinux:zfs:0.6.4:*:*:*:*:*:*:*", "matchCriteriaId": "DB2FE587-3D13-40F6-938D-715B75D13906"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2015/04/22/4", "source": "cve@mitre.org", "tags": ["Mailing List", "VDB Entry"]}, {"url": "http://www.securityfocus.com/bid/74272", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/FransUrbo/zfs/commit/99aa4d2b4fd12c6bef62d02ffd1b375ddd42fcf4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/zfsonlinux/zfs/issues/3319", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/zfsonlinux/zfs/pull/2790/commits", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FransUrbo/zfs/commit/99aa4d2b4fd12c6bef62d02ffd1b375ddd42fcf4"}}