{"buggy_code": ["/*\n * The MIT License\n * \n * Copyright (c) 2004-2012, Sun Microsystems, Inc., Kohsuke Kawaguchi, Fulvio Cavarretta,\n * Jean-Baptiste Quenot, Luca Domenico Milanesio, Renaud Bruyeron, Stephen Connolly,\n * Tom Huybrechts, Yahoo! Inc., Manufacture Francaise des Pneumatiques Michelin,\n * Romain Seguy, OHTAKE Tomohiro\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.scm;\n\nimport static hudson.Util.fixEmptyAndTrim;\nimport static hudson.scm.PollingResult.BUILD_NOW;\nimport static hudson.scm.PollingResult.NO_CHANGES;\nimport static java.util.logging.Level.FINE;\nimport static java.util.logging.Level.WARNING;\nimport hudson.EnvVars;\nimport hudson.Extension;\nimport hudson.FilePath;\nimport hudson.FilePath.FileCallable;\nimport hudson.Functions;\nimport hudson.Launcher;\nimport hudson.Util;\nimport hudson.XmlFile;\nimport hudson.model.BuildListener;\nimport hudson.model.Item;\nimport hudson.model.TaskListener;\nimport hudson.model.AbstractBuild;\nimport hudson.model.AbstractProject;\nimport hudson.model.Computer;\nimport hudson.model.Hudson;\nimport java.util.Arrays;\nimport java.util.WeakHashMap;\nimport jenkins.model.Jenkins.MasterComputer;\nimport hudson.model.Node;\nimport hudson.model.ParametersAction;\nimport hudson.model.Run;\nimport hudson.remoting.Callable;\nimport hudson.remoting.Channel;\nimport hudson.remoting.VirtualChannel;\nimport hudson.scm.UserProvidedCredential.AuthenticationManagerImpl;\nimport hudson.scm.subversion.CheckoutUpdater;\nimport hudson.scm.subversion.Messages;\nimport hudson.scm.subversion.SvnHelper;\nimport hudson.scm.subversion.UpdateUpdater;\nimport hudson.scm.subversion.UpdateWithRevertUpdater;\nimport hudson.scm.subversion.UpdaterException;\nimport hudson.scm.subversion.WorkspaceUpdater;\nimport hudson.scm.subversion.WorkspaceUpdater.UpdateTask;\nimport hudson.scm.subversion.WorkspaceUpdaterDescriptor;\nimport hudson.util.EditDistance;\nimport hudson.util.FormValidation;\nimport hudson.util.LogTaskListener;\nimport hudson.util.MultipartFormDataParser;\nimport hudson.util.Scrambler;\nimport hudson.util.Secret;\nimport hudson.util.TimeUnit2;\nimport hudson.util.XStream2;\n\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InterruptedIOException;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.UUID;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\n\nimport javax.servlet.ServletException;\nimport javax.xml.transform.stream.StreamResult;\n\nimport net.sf.json.JSONObject;\n\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.taskdefs.Chmod;\nimport org.kohsuke.stapler.AncestorInPath;\nimport org.kohsuke.stapler.DataBoundConstructor;\nimport org.kohsuke.stapler.QueryParameter;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.kohsuke.stapler.export.Exported;\nimport org.kohsuke.stapler.export.ExportedBean;\nimport org.tmatesoft.svn.core.ISVNLogEntryHandler;\nimport org.tmatesoft.svn.core.SVNAuthenticationException;\nimport org.tmatesoft.svn.core.SVNDepth;\nimport org.tmatesoft.svn.core.SVNDirEntry;\nimport org.tmatesoft.svn.core.SVNErrorCode;\nimport org.tmatesoft.svn.core.SVNErrorMessage;\nimport org.tmatesoft.svn.core.SVNException;\nimport org.tmatesoft.svn.core.SVNLogEntry;\nimport org.tmatesoft.svn.core.SVNNodeKind;\nimport org.tmatesoft.svn.core.SVNURL;\nimport org.tmatesoft.svn.core.auth.ISVNAuthenticationManager;\nimport org.tmatesoft.svn.core.auth.ISVNAuthenticationOutcomeListener;\nimport org.tmatesoft.svn.core.auth.ISVNAuthenticationProvider;\nimport org.tmatesoft.svn.core.auth.SVNAuthentication;\nimport org.tmatesoft.svn.core.auth.SVNPasswordAuthentication;\nimport org.tmatesoft.svn.core.auth.SVNSSHAuthentication;\nimport org.tmatesoft.svn.core.auth.SVNSSLAuthentication;\nimport org.tmatesoft.svn.core.auth.SVNUserNameAuthentication;\nimport org.tmatesoft.svn.core.internal.io.dav.DAVRepositoryFactory;\nimport org.tmatesoft.svn.core.internal.io.dav.http.DefaultHTTPConnectionFactory;\nimport org.tmatesoft.svn.core.internal.io.fs.FSRepositoryFactory;\nimport org.tmatesoft.svn.core.internal.io.svn.SVNRepositoryFactoryImpl;\nimport org.tmatesoft.svn.core.internal.util.SVNPathUtil;\nimport org.tmatesoft.svn.core.internal.wc.DefaultSVNOptions;\nimport org.tmatesoft.svn.core.internal.wc.admin.SVNAdminAreaFactory;\nimport org.tmatesoft.svn.core.io.SVNCapability;\nimport org.tmatesoft.svn.core.io.SVNRepository;\nimport org.tmatesoft.svn.core.io.SVNRepositoryFactory;\nimport org.tmatesoft.svn.core.wc.SVNClientManager;\nimport org.tmatesoft.svn.core.wc.SVNInfo;\nimport org.tmatesoft.svn.core.wc.SVNRevision;\nimport org.tmatesoft.svn.core.wc.SVNWCClient;\nimport org.tmatesoft.svn.core.wc.SVNWCUtil;\n\nimport com.thoughtworks.xstream.XStream;\nimport com.trilead.ssh2.DebugLogger;\nimport com.trilead.ssh2.SCPClient;\nimport com.trilead.ssh2.crypto.Base64;\n\n/**\n * Subversion SCM.\n *\n * <h2>Plugin Developer Notes</h2>\n * <p>\n * Plugins that interact with Subversion can use {@link DescriptorImpl#createAuthenticationProvider(AbstractProject)}\n * so that it can use the credentials (username, password, etc.) that the user entered for Hudson.\n * See the javadoc of this method for the precautions you need to take if you run Subversion operations\n * remotely on slaves.\n * \n * <h2>Implementation Notes</h2>\n * <p>\n * Because this instance refers to some other classes that are not necessarily\n * Java serializable (like {@link #browser}), remotable {@link FileCallable}s all\n * need to be declared as static inner classes.\n *\n * @author Kohsuke Kawaguchi\n */\n@SuppressWarnings(\"rawtypes\")\npublic class SubversionSCM extends SCM implements Serializable {\n    /**\n     * the locations field is used to store all configured SVN locations (with\n     * their local and remote part). Direct access to this field should be\n     * avoided and the getLocations() method should be used instead. This is\n     * needed to make importing of old hudson-configurations possible as\n     * getLocations() will check if the modules field has been set and import\n     * the data.\n     *\n     * @since 1.91\n     */\n    private ModuleLocation[] locations = new ModuleLocation[0];\n\n    private final SubversionRepositoryBrowser browser;\n    private String excludedRegions;\n    private String includedRegions;\n    private String excludedUsers;\n    /**\n     * Revision property names that are ignored for the sake of polling. Whitespace separated, possibly null. \n     */\n    private String excludedRevprop;\n    private String excludedCommitMessages;\n\n    private WorkspaceUpdater workspaceUpdater;\n\n    // No longer in use but left for serialization compatibility.\n    @Deprecated\n    private String modules;\n\n    // No longer used but left for serialization compatibility\n    @Deprecated\n    private Boolean useUpdate;\n    @Deprecated\n    private Boolean doRevert;\n\n    private boolean ignoreDirPropChanges;\n    private boolean filterChangelog;\n\n    /**\n     * A cache of the svn:externals (keyed by project).\n     */\n    private transient Map<AbstractProject, List<External>> projectExternalsCache;\n\n    private transient boolean pollFromMaster = POLL_FROM_MASTER;\n    \n    /**\n     * @deprecated as of 1.286\n     */\n    public SubversionSCM(String[] remoteLocations, String[] localLocations,\n                         boolean useUpdate, SubversionRepositoryBrowser browser) {\n        this(remoteLocations,localLocations, useUpdate, browser, null, null, null);\n    }\n\n    /**\n     * @deprecated as of 1.311\n     */\n    public SubversionSCM(String[] remoteLocations, String[] localLocations,\n                         boolean useUpdate, SubversionRepositoryBrowser browser, String excludedRegions) {\n        this(ModuleLocation.parse(remoteLocations,localLocations,null,null), useUpdate, false, browser, excludedRegions, null, null, null);\n    }\n\n    /**\n     * @deprecated as of 1.315\n     */\n     public SubversionSCM(String[] remoteLocations, String[] localLocations,\n                         boolean useUpdate, SubversionRepositoryBrowser browser, String excludedRegions, String excludedUsers, String excludedRevprop) {\n        this(ModuleLocation.parse(remoteLocations,localLocations,null,null), useUpdate, false, browser, excludedRegions, excludedUsers, excludedRevprop, null);\n    }\n\n   /**\n     * @deprecated as of 1.315\n     */\n    public SubversionSCM(List<ModuleLocation> locations,\n                         boolean useUpdate, SubversionRepositoryBrowser browser, String excludedRegions) {\n        this(locations, useUpdate, false, browser, excludedRegions, null, null, null);\n    }\n    \n    /**\n     * @deprecated as of 1.324\n     */\n    public SubversionSCM(List<ModuleLocation> locations,\n            boolean useUpdate, SubversionRepositoryBrowser browser, String excludedRegions, String excludedUsers, String excludedRevprop) {\n        this(locations, useUpdate, false, browser, excludedRegions, excludedUsers, excludedRevprop, null);\n    }\n\n    /**\n     * @deprecated as of 1.328\n     */\n    public SubversionSCM(List<ModuleLocation> locations,\n            boolean useUpdate, SubversionRepositoryBrowser browser, String excludedRegions, String excludedUsers, String excludedRevprop, String excludedCommitMessages) {\n    \tthis(locations, useUpdate, false, browser, excludedRegions, excludedUsers, excludedRevprop, excludedCommitMessages);\n    }\n\n    /**\n     * @deprecated as of 1.xxx\n     */\n    public SubversionSCM(List<ModuleLocation> locations,\n                         boolean useUpdate, boolean doRevert, SubversionRepositoryBrowser browser, String excludedRegions, String excludedUsers, String excludedRevprop, String excludedCommitMessages) {\n        this(locations, useUpdate, doRevert, browser, excludedRegions, excludedUsers, excludedRevprop, excludedCommitMessages, null);\n    }\n\n    /**\n     * @deprecated  as of 1.23\n     */\n    public SubversionSCM(List<ModuleLocation> locations,\n                         boolean useUpdate, boolean doRevert, SubversionRepositoryBrowser browser, String excludedRegions, String excludedUsers, String excludedRevprop, String excludedCommitMessages,\n                         String includedRegions) {\n        this(locations, useUpdate?(doRevert?new UpdateWithRevertUpdater():new UpdateUpdater()):new CheckoutUpdater(),\n                browser, excludedRegions, excludedUsers, excludedRevprop, excludedCommitMessages, includedRegions);\n    }\n\n    /**\n     * \n     * @deprecated as of ...\n     */\n    public SubversionSCM(List<ModuleLocation> locations, WorkspaceUpdater workspaceUpdater,\n                         SubversionRepositoryBrowser browser, String excludedRegions, String excludedUsers, String excludedRevprop, String excludedCommitMessages,\n                         String includedRegions) {\n      this(locations, workspaceUpdater, browser, excludedRegions, excludedUsers, excludedRevprop, excludedCommitMessages, includedRegions, false);\n    }\n\n    /**\n     *  @deprecated\n     */\n    public SubversionSCM(List<ModuleLocation> locations, WorkspaceUpdater workspaceUpdater,\n            SubversionRepositoryBrowser browser, String excludedRegions, String excludedUsers, String excludedRevprop, String excludedCommitMessages,\n            String includedRegions, boolean ignoreDirPropChanges) {\n        this(locations, workspaceUpdater, browser, excludedRegions, excludedUsers, excludedRevprop, excludedCommitMessages, includedRegions, ignoreDirPropChanges, false);\n    }\n\n    @DataBoundConstructor\n    public SubversionSCM(List<ModuleLocation> locations, WorkspaceUpdater workspaceUpdater,\n                         SubversionRepositoryBrowser browser, String excludedRegions, String excludedUsers, String excludedRevprop, String excludedCommitMessages,\n                         String includedRegions, boolean ignoreDirPropChanges, boolean filterChangelog) {\n        for (Iterator<ModuleLocation> itr = locations.iterator(); itr.hasNext();) {\n            ModuleLocation ml = itr.next();\n            String remote = Util.fixEmptyAndTrim(ml.remote);\n            if(remote==null) itr.remove();\n        }\n        this.locations = locations.toArray(new ModuleLocation[locations.size()]);\n\n        this.workspaceUpdater = workspaceUpdater;\n        this.browser = browser;\n        this.excludedRegions = excludedRegions;\n        this.excludedUsers = excludedUsers;\n        this.excludedRevprop = excludedRevprop;\n        this.excludedCommitMessages = excludedCommitMessages;\n        this.includedRegions = includedRegions;\n        this.ignoreDirPropChanges = ignoreDirPropChanges;\n        this.filterChangelog = filterChangelog;\n    }\n\n    /**\n     * Convenience constructor, especially during testing.\n     */\n    public SubversionSCM(String svnUrl) {\n        this(svnUrl,\".\");\n    }\n\n    /**\n     * Convenience constructor, especially during testing.\n     */\n    public SubversionSCM(String svnUrl, String local) {\n        this(new String[]{svnUrl},new String[]{local},true,null,null,null,null);\n    }\n    \n    /**\n     * Convenience constructor, especially during testing.\n     */\n    public SubversionSCM(String[] svnUrls, String[] locals) {\n        this(svnUrls,locals,true,null,null,null,null);\n    }\n\n    /**\n     * @deprecated\n     *      as of 1.91. Use {@link #getLocations()} instead.\n     */\n    public String getModules() {\n        return null;\n    }\n\n    /**\n     * list of all configured svn locations\n     *\n     * @since 1.91\n     */\n    @Exported\n    public ModuleLocation[] getLocations() {\n    \treturn getLocations(null, null);\n    }\n\n    @Exported\n    public WorkspaceUpdater getWorkspaceUpdater() {\n        if (workspaceUpdater!=null)\n            return workspaceUpdater;\n\n        // data must have been read from old configuration.\n        if (useUpdate!=null && !useUpdate)\n            return new CheckoutUpdater();\n        if (doRevert!=null && doRevert)\n            return new UpdateWithRevertUpdater();\n        return new UpdateUpdater();\n    }\n\n    public void setWorkspaceUpdater(WorkspaceUpdater workspaceUpdater) {\n        this.workspaceUpdater = workspaceUpdater;\n    }\n\n    /**\n     * @since 1.252\n     * @deprecated Use {@link #getLocations(EnvVars, AbstractBuild)} for vars\n     *             expansion to be performed on all env vars rather than just\n     *             build parameters.\n     */\n    public ModuleLocation[] getLocations(AbstractBuild<?,?> build) {\n        return getLocations(null, build);\n    }\n\n    /**\n     * List of all configured svn locations, expanded according to all env vars\n     * or, if none defined, according to only build parameters values.\n     * Both may be defined, in which case the variables are combined.\n     * @param env If non-null, variable expansions are performed against these vars\n     * @param build If non-null, variable expansions are\n     *              performed against the build parameters\n     */\n    public ModuleLocation[] getLocations(EnvVars env, AbstractBuild<?,?> build) {\n        // check if we've got a old location\n        if (modules != null) {\n            // import the old configuration\n            List<ModuleLocation> oldLocations = new ArrayList<ModuleLocation>();\n            StringTokenizer tokens = new StringTokenizer(modules);\n            while (tokens.hasMoreTokens()) {\n                // the remote (repository location)\n                // the normalized name is always without the trailing '/'\n                String remoteLoc = Util.removeTrailingSlash(tokens.nextToken());\n\n                oldLocations.add(new ModuleLocation(remoteLoc, null));\n            }\n\n            locations = oldLocations.toArray(new ModuleLocation[oldLocations.size()]);\n            modules = null;\n        }\n\n        if(env == null && build == null)\n            return locations;\n\n        ModuleLocation[] outLocations = new ModuleLocation[locations.length];\n        EnvVars env2 = env != null ? new EnvVars(env) : new EnvVars();\n        if (build != null) {\n            env2.putAll(build.getBuildVariables());\n        }\n        EnvVars.resolve(env2);\n        for (int i = 0; i < outLocations.length; i++) {\n            outLocations[i] = locations[i].getExpandedLocation(env2);\n        }\n\n        return outLocations;\n    }\n\n    /**\n     * Get the list of every checked-out location. This differs from {@link #getLocations()}\n     * which returns only the configured locations whereas this method returns the configured\n     * locations + any svn:externals locations.\n     */\n    public ModuleLocation[] getProjectLocations(AbstractProject project) throws IOException {\n        List<External> projectExternals = getExternals(project);\n\n        ModuleLocation[] configuredLocations = getLocations();\n        if (projectExternals.isEmpty()) {\n            return configuredLocations;\n        }\n\n        List<ModuleLocation> allLocations = new ArrayList<ModuleLocation>(configuredLocations.length + projectExternals.size());\n        allLocations.addAll(Arrays.asList(configuredLocations));\n\n        for (External external : projectExternals) {\n            allLocations.add(new ModuleLocation(external.url, external.path));\n        }\n\n        return allLocations.toArray(new ModuleLocation[allLocations.size()]);\n    }\n\n    private List<External> getExternals(AbstractProject context) throws IOException {\n        Map<AbstractProject, List<External>> projectExternalsCache = getProjectExternalsCache();\n        List<External> projectExternals;\n        synchronized (projectExternalsCache) {\n            projectExternals = projectExternalsCache.get(context);\n        }\n\n        if (projectExternals == null) {\n            projectExternals = parseExternalsFile(context);\n\n            synchronized (projectExternalsCache) {\n                if (!projectExternalsCache.containsKey(context)) {\n                    projectExternalsCache.put(context, projectExternals);\n                }\n            }\n        }\n        return projectExternals;\n    }\n\n    @Override\n    @Exported\n    public SubversionRepositoryBrowser getBrowser() {\n        return browser;\n    }\n\n    @Exported\n    public String getExcludedRegions() {\n        return excludedRegions;\n    }\n\n    public String[] getExcludedRegionsNormalized() {\n        return (excludedRegions == null || excludedRegions.trim().equals(\"\"))\n                ? null : excludedRegions.split(\"[\\\\r\\\\n]+\");\n    }\n\n    private Pattern[] getExcludedRegionsPatterns() {\n        String[] excluded = getExcludedRegionsNormalized();\n        if (excluded != null) {\n            Pattern[] patterns = new Pattern[excluded.length];\n\n            int i = 0;\n            for (String excludedRegion : excluded) {\n                patterns[i++] = Pattern.compile(excludedRegion);\n            }\n\n            return patterns;\n        }\n\n        return new Pattern[0];\n    }\n\n    @Exported\n    public String getIncludedRegions() {\n        return includedRegions;\n    }\n\n    public String[] getIncludedRegionsNormalized() {\n        return (includedRegions == null || includedRegions.trim().equals(\"\"))\n                ? null : includedRegions.split(\"[\\\\r\\\\n]+\");\n    }\n\n    private Pattern[] getIncludedRegionsPatterns() {\n        String[] included = getIncludedRegionsNormalized();\n        if (included != null) {\n            Pattern[] patterns = new Pattern[included.length];\n\n            int i = 0;\n            for (String includedRegion : included) {\n                patterns[i++] = Pattern.compile(includedRegion);\n            }\n\n            return patterns;\n        }\n\n        return new Pattern[0];\n    }\n\n    @Exported\n    public String getExcludedUsers() {\n        return excludedUsers;\n    }\n\n    public Set<String> getExcludedUsersNormalized() {\n        String s = fixEmptyAndTrim(excludedUsers);\n        if (s==null)\n            return Collections.emptySet();\n\n        Set<String> users = new HashSet<String>();\n        for (String user : s.split(\"[\\\\r\\\\n]+\"))\n            users.add(user.trim());\n        return users;\n    }\n\n    @Exported\n    public String getExcludedRevprop() {\n        return excludedRevprop;\n    }\n\n    @Exported\n    public String getExcludedCommitMessages() {\n        return excludedCommitMessages;\n    }\n\n    public String[] getExcludedCommitMessagesNormalized() {\n        String s = fixEmptyAndTrim(excludedCommitMessages);\n        return s == null ? new String[0] : s.split(\"[\\\\r\\\\n]+\");\n    }\n\n    private Pattern[] getExcludedCommitMessagesPatterns() {\n        String[] excluded = getExcludedCommitMessagesNormalized();\n        Pattern[] patterns = new Pattern[excluded.length];\n\n        int i = 0;\n        for (String excludedCommitMessage : excluded) {\n            patterns[i++] = Pattern.compile(excludedCommitMessage);\n        }\n\n        return patterns;\n    }\n\n    @Exported\n    public boolean isIgnoreDirPropChanges() {\n      return ignoreDirPropChanges;\n    }\n    \n    @Exported\n    public boolean isFilterChangelog() {\n      return filterChangelog;\n    }\n\n    /**\n     * Sets the <tt>SVN_REVISION_n</tt> and <tt>SVN_URL_n</tt> environment variables during the build.\n     */\n    @Override\n    public void buildEnvVars(AbstractBuild<?, ?> build, Map<String, String> env) {\n        super.buildEnvVars(build, env);\n        \n        ModuleLocation[] svnLocations = getLocations(new EnvVars(env), build);\n\n        try {\n            Map<String,Long> revisions = parseSvnRevisionFile(build);\n            Set<String> knownURLs = revisions.keySet();\n            if(svnLocations.length==1) {\n                // for backwards compatibility if there's only a single modulelocation, we also set\n                // SVN_REVISION and SVN_URL without '_n'\n                String url = svnLocations[0].getURL();\n                Long rev = revisions.get(url);\n                if(rev!=null) {\n                    env.put(\"SVN_REVISION\",rev.toString());\n                    env.put(\"SVN_URL\",url);\n                } else if (!knownURLs.isEmpty()) {\n                    LOGGER.log(WARNING, \"no revision found corresponding to {0}; known: {1}\", new Object[] {url, knownURLs});\n                }\n            }\n            \n            for(int i=0;i<svnLocations.length;i++) {\n                String url = svnLocations[i].getURL();\n                Long rev = revisions.get(url);\n                if(rev!=null) {\n                    env.put(\"SVN_REVISION_\"+(i+1),rev.toString());\n                    env.put(\"SVN_URL_\"+(i+1),url);\n                } else if (!knownURLs.isEmpty()) {\n                    LOGGER.log(WARNING, \"no revision found corresponding to {0}; known: {1}\", new Object[] {url, knownURLs});\n                }\n            }\n\n        } catch (IOException e) {\n            LOGGER.log(WARNING, \"error building environment variables\", e);\n        }\n    }\n\n    /**\n     * Called after checkout/update has finished to compute the changelog.\n     */\n    private boolean calcChangeLog(AbstractBuild<?,?> build, File changelogFile, BuildListener listener, List<External> externals, EnvVars env) throws IOException, InterruptedException {\n        if(build.getPreviousBuild()==null) {\n            // nothing to compare against\n            return createEmptyChangeLog(changelogFile, listener, \"log\");\n        }\n\n        // some users reported that the file gets created with size 0. I suspect\n        // maybe some XSLT engine doesn't close the stream properly.\n        // so let's do it by ourselves to be really sure that the stream gets closed.\n        OutputStream os = new BufferedOutputStream(new FileOutputStream(changelogFile));\n        boolean created;\n        try {\n            created = new SubversionChangeLogBuilder(build, env, listener, this).run(externals, new StreamResult(os));\n        } finally {\n            os.close();\n        }\n        if(!created)\n            createEmptyChangeLog(changelogFile, listener, \"log\");\n\n        return true;\n    }\n\n    /**\n     * Please consider using the non-static version {@link #parseSvnRevisionFile(AbstractBuild)}!\n     */\n    /*package*/ static Map<String,Long> parseRevisionFile(AbstractBuild<?,?> build) throws IOException {\n        return parseRevisionFile(build,true,false);\n    }\n    \n    /*package*/ Map<String,Long> parseSvnRevisionFile(AbstractBuild<?,?> build) throws IOException {\n        return parseRevisionFile(build);\n    }\n\n    /**\n     * Reads the revision file of the specified build (or the closest, if the flag is so specified.)\n     *\n     * @param findClosest\n     *      If true, this method will go back the build history until it finds a revision file.\n     *      A build may not have a revision file for any number of reasons (such as failure, interruption, etc.)\n     * @return\n     *      map from {@link SvnInfo#url Subversion URL} to its revision.  If there is more than one, choose\n     *      the one with the smallest revision number\n     */\n    /*package*/ static Map<String,Long> parseRevisionFile(AbstractBuild<?,?> build, boolean findClosest, boolean prunePinnedExternals) throws IOException {\n        Map<String,Long> revisions = new HashMap<String,Long>(); // module -> revision\n\n        if (findClosest) {\n            for (AbstractBuild<?,?> b=build; b!=null; b=b.getPreviousBuild()) {\n                if(getRevisionFile(b).exists()) {\n                    build = b;\n                    break;\n                }\n            }\n        }\n\n        {// read the revision file of the build\n            File file = getRevisionFile(build);\n            if(!file.exists())\n                // nothing to compare against\n                return revisions;\n\n            BufferedReader br = new BufferedReader(new FileReader(file));\n            try {\n                String line;\n                while((line=br.readLine())!=null) {\n                \tboolean isPinned = false;\n                \tint indexLast = line.length();\n                \tif (line.lastIndexOf(\"::p\") == indexLast-3) {\n                \t\tisPinned = true;\n                \t\tindexLast -= 3;\n                \t}\n                \tint index = line.lastIndexOf('/');\n                    if(index<0) {\n                        continue;   // invalid line?\n                    }\n                    try {\n                    \tString url = line.substring(0, index);\n                    \tlong revision = Long.parseLong(line.substring(index+1,indexLast));\n                    \tLong oldRevision = revisions.get(url);\n                    \tif (isPinned) {\n                    \t\tif (!prunePinnedExternals) {\n                    \t\t\tif (oldRevision == null)\n                    \t\t\t\t// If we're writing pinned, only write if there are no unpinned\n                    \t\t\t\trevisions.put(url, revision);\n                    \t\t}\n                    \t} else {\n                    \t\t// unpinned\n                        \tif (oldRevision == null || oldRevision > revision)\n                        \t\t// For unpinned, take minimum\n                        \t\trevisions.put(url, revision);\n                    \t}\n                \t} catch (NumberFormatException e) {\n                \t    // perhaps a corrupted line.\n                \t    LOGGER.log(WARNING, \"Error parsing line \" + line, e);\n                \t}\n                }\n            } finally {\n                br.close();\n            }\n        }\n\n        return revisions;\n    }\n\n    /**\n     * Parses the file that stores the locations in the workspace where modules loaded by svn:external\n     * is placed.\n     *\n     * <p>\n     * Note that the format of the file has changed in 1.180 from simple text file to XML.\n     *\n     * @return\n     *      immutable list. Can be empty but never null.\n     */\n    /*package*/ @SuppressWarnings(\"unchecked\")\n    static List<External> parseExternalsFile(AbstractProject project) throws IOException {\n        File file = getExternalsFile(project);\n        if(file.exists()) {\n            try {\n                return (List<External>)new XmlFile(External.XSTREAM,file).read();\n            } catch (IOException e) {\n                // in < 1.180 this file was a text file, so it may fail to parse as XML,\n                // in which case let's just fall back\n            }\n        }\n\n        return Collections.emptyList();\n    }\n\n    /**\n     * Polling can happen on the master and does not require a workspace.\n     */\n    @Override\n    public boolean requiresWorkspaceForPolling() {\n        return false;\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    public boolean checkout(AbstractBuild build, Launcher launcher, FilePath workspace, final BuildListener listener, File changelogFile) throws IOException, InterruptedException {\n        EnvVars env = build.getEnvironment(listener);\n        EnvVarsUtils.overrideAll(env, build.getBuildVariables());\n\n        List<External> externals = null;\n        try {\n            externals = checkout(build,workspace,listener,env);\n        } catch (UpdaterException e) {\n            return false;\n        }\n\n        // write out the revision file\n        PrintWriter w = new PrintWriter(new FileOutputStream(getRevisionFile(build)));\n        try {\n            List<SvnInfoP> pList = workspace.act(new BuildRevisionMapTask(build, this, listener, externals, env));\n            List<SvnInfo> revList= new ArrayList<SvnInfo>(pList.size());\n            for (SvnInfoP p: pList) {\n                if (p.pinned) \n                    w.println( p.info.url +'/'+ p.info.revision + \"::p\");\n                else\n                    w.println( p.info.url +'/'+ p.info.revision);\n                revList.add(p.info);\n            }\n            build.addAction(new SubversionTagAction(build,revList));\n        } finally {\n            w.close();\n        }\n\n        // write out the externals info\n        new XmlFile(External.XSTREAM,getExternalsFile(build.getProject())).write(externals);\n        Map<AbstractProject, List<External>> projectExternalsCache = getProjectExternalsCache();\n        synchronized (projectExternalsCache) {\n            projectExternalsCache.put(build.getProject(), externals);\n        }\n\n        return calcChangeLog(build, changelogFile, listener, externals, env);\n    }\n\n    /**\n     * Performs the checkout or update, depending on the configuration and workspace state.\n     *\n     * <p>\n     * Use canonical path to avoid SVNKit/symlink problem as described in\n     * https://wiki.svnkit.com/SVNKit_FAQ\n     *\n     * @return null\n     *      if the operation failed. Otherwise the set of local workspace paths\n     *      (relative to the workspace root) that has loaded due to svn:external.\n     */\n    private List<External> checkout(AbstractBuild build, FilePath workspace, TaskListener listener, EnvVars env) throws IOException, InterruptedException {\n        if (repositoryLocationsNoLongerExist(build, listener, env)) {\n            Run lsb = build.getProject().getLastSuccessfulBuild();\n            if (lsb != null && build.getNumber()-lsb.getNumber()>10\n            && build.getTimestamp().getTimeInMillis()-lsb.getTimestamp().getTimeInMillis() > TimeUnit2.DAYS.toMillis(1)) {\n                // Disable this project if the location doesn't exist any more, see issue #763\n                // but only do so if there was at least some successful build,\n                // to make sure that initial configuration error won't disable the build. see issue #1567\n                // finally, only disable a build if the failure persists for some time.\n                // see http://www.nabble.com/Should-Hudson-have-an-option-for-a-content-fingerprint--td24022683.html\n\n                listener.getLogger().println(\"One or more repository locations do not exist anymore for \" + build.getProject().getName() + \", project will be disabled.\");\n                build.getProject().makeDisabled(true);\n                return null;\n            }\n        }\n        \n        List<External> externals = new ArrayList<External>();\n        for (ModuleLocation location : getLocations(env, build)) {\n            externals.addAll( workspace.act(new CheckOutTask(build, this, location, build.getTimestamp().getTime(), listener, env)));\n            // olamy: remove null check at it cause test failure\n            // see https://github.com/jenkinsci/subversion-plugin/commit/de23a2b781b7b86f41319977ce4c11faee75179b#commitcomment-1551273\n            /*if ( externalsFound != null ){\n                externals.addAll(externalsFound);\n            } else {\n                externals.addAll( new ArrayList<External>( 0 ) );\n            }*/\n        }\n\n        return externals;\n    }\n\n    private synchronized Map<AbstractProject, List<External>> getProjectExternalsCache() {\n        if (projectExternalsCache == null) {\n            projectExternalsCache = new WeakHashMap<AbstractProject, List<External>>();\n        }\n\n        return projectExternalsCache;\n    }\n\n    /**\n     * Either run \"svn co\" or \"svn up\" equivalent.\n     */\n    private static class CheckOutTask extends UpdateTask implements FileCallable<List<External>> {\n        private final UpdateTask task;\n\n         public CheckOutTask(AbstractBuild<?, ?> build, SubversionSCM parent, ModuleLocation location, Date timestamp, TaskListener listener, EnvVars env) {\n            this.authProvider = parent.getDescriptor().createAuthenticationProvider(build.getParent());\n            this.timestamp = timestamp;\n            this.listener = listener;\n            this.location = location;\n            this.revisions = build.getAction(RevisionParameterAction.class);\n            this.task = parent.getWorkspaceUpdater().createTask();\n        }\n        \n        public List<External> invoke(File ws, VirtualChannel channel) throws IOException {\n            clientManager = createClientManager(authProvider);\n            manager = clientManager.getCore();\n            this.ws = ws;\n            try {\n                List<External> externals = perform();\n\n                checkClockOutOfSync();\n\n                return externals;\n\n            } catch (InterruptedException e) {\n                throw (InterruptedIOException)new InterruptedIOException().initCause(e);\n            } finally {\n                clientManager.dispose();\n            }\n        }\n\n        /**\n         * This round-about way of executing the task ensures that the error-prone {@link #delegateTo(UpdateTask)} method\n         * correctly copies everything.\n         */\n        @Override\n        public List<External> perform() throws IOException, InterruptedException {\n            return delegateTo(task);\n        }\n\n        private void checkClockOutOfSync() {\n            try {\n                SVNDirEntry dir = clientManager.createRepository(location.getSVNURL(), true).info(\"/\", -1);\n                if (dir != null) {// I don't think this can ever be null, but be defensive\n                    if (dir.getDate() != null && dir.getDate().after(new Date())) // see http://www.nabble.com/NullPointerException-in-SVN-Checkout-Update-td21609781.html that reported this being null.\n                    {\n                        listener.getLogger().println(Messages.SubversionSCM_ClockOutOfSync());\n                    }\n                }\n            } catch (SVNAuthenticationException e) {\n                // if we don't have access to '/', ignore. error\n                LOGGER.log(Level.FINE,\"Failed to estimate the remote time stamp\",e);\n            } catch (SVNException e) {\n                LOGGER.log(Level.INFO,\"Failed to estimate the remote time stamp\",e);\n            }\n        }\n\n        private static final long serialVersionUID = 1L;\n    }\n\n    /**\n     *\n     * @deprecated as of 1.40\n     *      Use {@link #createClientManager(ISVNAuthenticationProvider)}\n     */\n    public static SVNClientManager createSvnClientManager(ISVNAuthenticationProvider authProvider) {\n        return createClientManager(authProvider).getCore();\n    }\n\n    /**\n     * Creates {@link SVNClientManager}.\n     *\n     * <p>\n     * This method must be executed on the slave where svn operations are performed.\n     *\n     * @param authProvider\n     *      The value obtained from {@link DescriptorImpl#createAuthenticationProvider(AbstractProject)}.\n     *      If the operation runs on slaves,\n     *      (and properly remoted, if the svn operations run on slaves.)\n     */\n    public static SvnClientManager createClientManager(ISVNAuthenticationProvider authProvider) {\n        ISVNAuthenticationManager sam = createSvnAuthenticationManager(authProvider);\n        return new SvnClientManager(SVNClientManager.newInstance(createDefaultSVNOptions(), sam));\n    }\n\n    /**\n     * Creates the {@link DefaultSVNOptions}.\n     *\n     * @return the {@link DefaultSVNOptions}.\n     */\n    public static DefaultSVNOptions createDefaultSVNOptions() {\n        DefaultSVNOptions defaultOptions = SVNWCUtil.createDefaultOptions(true);\n        DescriptorImpl descriptor = Hudson.getInstance() == null ? null : Hudson.getInstance().getDescriptorByType(DescriptorImpl.class);\n        if (defaultOptions != null && descriptor != null) {\n            defaultOptions.setAuthStorageEnabled(descriptor.isStoreAuthToDisk());\n        }\n        return defaultOptions;\n    }\n\n    public static ISVNAuthenticationManager createSvnAuthenticationManager(ISVNAuthenticationProvider authProvider) {\n        File configDir;\n        if (CONFIG_DIR!=null)\n            configDir = new File(CONFIG_DIR);\n        else\n            configDir = SVNWCUtil.getDefaultConfigurationDirectory();\n        \n        ISVNAuthenticationManager sam = SVNWCUtil.createDefaultAuthenticationManager(configDir, null, null);\n        sam.setAuthenticationProvider(authProvider);\n        SVNAuthStoreHandlerImpl.install(sam);\n        return sam;\n    }\n\n    /**\n     * @deprecated as of 2.0\n     *      Use {@link #createClientManager(AbstractProject)}\n     *\n     */\n    public static SVNClientManager createSvnClientManager(AbstractProject context) {\n        return createClientManager(context).getCore();\n    }\n\n    /**\n     * Creates {@link SVNClientManager} for code running on the master.\n     * <p>\n     * CAUTION: this code only works when invoked on master. On slaves, use\n     * {@link #createSvnClientManager(ISVNAuthenticationProvider)} and get {@link ISVNAuthenticationProvider}\n     * from the master via remoting.\n     */\n    public static SvnClientManager createClientManager(AbstractProject context) {\n        return new SvnClientManager(createSvnClientManager(Hudson.getInstance().getDescriptorByType(DescriptorImpl.class).createAuthenticationProvider(context)));\n    }\n\n    public static final class SvnInfo implements Serializable, Comparable<SvnInfo> {\n        /**\n         * Decoded repository URL.\n         */\n        public final String url;\n        public final long revision;\n\n        public SvnInfo(String url, long revision) {\n            this.url = url;\n            this.revision = revision;\n        }\n\n        public SvnInfo(SVNInfo info) {\n            this( info.getURL().toDecodedString(), info.getCommittedRevision().getNumber() );\n        }\n\n        public SVNURL getSVNURL() throws SVNException {\n            return SVNURL.parseURIDecoded(url);\n        }\n\n        public int compareTo(SvnInfo that) {\n            int r = this.url.compareTo(that.url);\n            if(r!=0)    return r;\n\n            if(this.revision<that.revision) return -1;\n            if(this.revision>that.revision) return +1;\n            return 0;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            SvnInfo svnInfo = (SvnInfo) o;\n            return revision==svnInfo.revision && url.equals(svnInfo.url);\n\n        }\n\n        @Override\n        public int hashCode() {\n            int result;\n            result = url.hashCode();\n            result = 31 * result + (int) (revision ^ (revision >>> 32));\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s (rev.%s)\",url,revision);\n        }\n\n        private static final long serialVersionUID = 1L;\n    }\n\n    /**\n     * {@link SvnInfo} plus a flag if the revision is fixed.\n     */\n    private static final class SvnInfoP implements Serializable {\n        /**\n         * SvnInfo with an indicator boolean indicating whether this is a pinned external\n         */\n        public final SvnInfo info;\n        public final boolean pinned;\n\n        public SvnInfoP(SvnInfo info, boolean pinned) {\n            this.info = info;\n            this.pinned = pinned;\n        }\n        private static final long serialVersionUID = 1L;\n    }\n\n    /**\n     * Information about svn:external\n     */\n    public static final class External implements Serializable {\n        /**\n         * Relative path within the workspace where this <tt>svn:exteranls</tt> exist. \n         */\n        public final String path;\n\n        /**\n         * External SVN URL to be fetched.\n         */\n        public final String url;\n\n        /**\n         * If the svn:external link is with the -r option, its number.\n         * Otherwise -1 to indicate that the head revision of the external repository should be fetched.\n         */\n        public final long revision;\n\n        public External(String path, SVNURL url, long revision) {\n            this.path = path;\n            this.url = url.toDecodedString();\n            this.revision = revision;\n        }\n\n        /**\n         * Returns true if this reference is to a fixed revision.\n         */\n        public boolean isRevisionFixed() {\n            return revision!=-1;\n        }\n\n        private static final long serialVersionUID = 1L;\n\n        private static final XStream XSTREAM = new XStream2();\n        static {\n            XSTREAM.alias(\"external\",External.class);\n        }\n    }\n\n\n    /**\n     * Gets the SVN metadata for the remote repository.\n     *\n     * @param remoteUrl\n     *      The target to run \"svn info\".\n     */\n    static SVNInfo parseSvnInfo(SVNURL remoteUrl, ISVNAuthenticationProvider authProvider) throws SVNException {\n        final SvnClientManager manager = createClientManager(authProvider);\n        try {\n            final SVNWCClient svnWc = manager.getWCClient();\n            return svnWc.doInfo(remoteUrl, SVNRevision.HEAD, SVNRevision.HEAD);\n        } finally {\n            manager.dispose();\n        }\n    }\n\n    /**\n     * Checks .svn files in the workspace and finds out revisions of the modules\n     * that the workspace has.\n     *\n     * @return\n     *      null if the parsing somehow fails. Otherwise a map from the repository URL to revisions.\n     */\n    private static class BuildRevisionMapTask implements FileCallable<List<SvnInfoP>> {\n        private final ISVNAuthenticationProvider authProvider;\n        private final TaskListener listener;\n        private final List<External> externals;\n        private final ModuleLocation[] locations;\n\n        public BuildRevisionMapTask(AbstractBuild<?, ?> build, SubversionSCM parent, TaskListener listener, List<External> externals, EnvVars env) {\n            this.authProvider = parent.getDescriptor().createAuthenticationProvider(build.getParent());\n            this.listener = listener;\n            this.externals = externals;\n            this.locations = parent.getLocations(env, build);\n        }\n\n        public List<SvnInfoP> invoke(File ws, VirtualChannel channel) throws IOException {\n            List<SvnInfoP> revisions = new ArrayList<SvnInfoP>();\n\n            final SvnClientManager manager = createClientManager(authProvider);\n            try {\n                final SVNWCClient svnWc = manager.getWCClient();\n                // invoke the \"svn info\"\n                for( ModuleLocation module : locations ) {\n                    try {\n                        SvnInfo info = new SvnInfo(svnWc.doInfo(new File(ws,module.getLocalDir()), SVNRevision.WORKING));\n                        revisions.add(new SvnInfoP(info, false));\n                    } catch (SVNException e) {\n                        e.printStackTrace(listener.error(\"Failed to parse svn info for \"+module.remote));\n                    }\n                }\n                for(External ext : externals){\n                    try {\n                        SvnInfo info = new SvnInfo(svnWc.doInfo(new File(ws,ext.path),SVNRevision.WORKING));\n                        revisions.add(new SvnInfoP(info, ext.isRevisionFixed()));\n                    } catch (SVNException e) {\n                        e.printStackTrace(listener.error(\"Failed to parse svn info for external \"+ext.url+\" at \"+ext.path));\n                    }\n                }\n\n                return revisions;\n            } finally {\n                manager.dispose();\n            }\n        }\n        private static final long serialVersionUID = 1L;\n    }\n\n    /**\n     * Gets the file that stores the revision.\n     */\n    public static File getRevisionFile(AbstractBuild build) {\n        return new File(build.getRootDir(),\"revision.txt\");\n    }\n\n    /**\n     * Gets the file that stores the externals.\n     */\n    private static File getExternalsFile(AbstractProject project) {\n        return new File(project.getRootDir(),\"svnexternals.txt\");\n    }\n\n    @Override\n    public SCMRevisionState calcRevisionsFromBuild(AbstractBuild<?, ?> build, Launcher launcher, TaskListener listener) throws IOException, InterruptedException {\n        // exclude locations that are svn:external-ed with a fixed revision.\n        Map<String,Long> wsRev = parseRevisionFile(build,true,true);\n        return new SVNRevisionState(wsRev);\n    }\n    \n    private boolean isPollFromMaster() {\n        return pollFromMaster;\n    }\n    \n    void setPollFromMaster(boolean pollFromMaster) {\n        this.pollFromMaster = pollFromMaster;\n    }\n\n    @Override\n    protected PollingResult compareRemoteRevisionWith(AbstractProject<?,?> project, Launcher launcher, FilePath workspace, final TaskListener listener, SCMRevisionState _baseline) throws IOException, InterruptedException {\n        final SVNRevisionState baseline;\n        if (_baseline instanceof SVNRevisionState) {\n            baseline = (SVNRevisionState)_baseline;\n        }\n        else if (project.getLastBuild()!=null) {\n            baseline = (SVNRevisionState)calcRevisionsFromBuild(project.getLastBuild(), launcher, listener);\n        }\n        else {\n            baseline = new SVNRevisionState(null);\n        }\n        \n        if (project.getLastBuild() == null) {\n            listener.getLogger().println(Messages.SubversionSCM_pollChanges_noBuilds());\n            return BUILD_NOW;\n        }\n\n        AbstractBuild<?,?> lastCompletedBuild = project.getLastCompletedBuild();\n\n        if (lastCompletedBuild!=null) {\n            EnvVars env = lastCompletedBuild.getEnvironment(listener);\n            EnvVarsUtils.overrideAll(env, lastCompletedBuild.getBuildVariables());\n            if (repositoryLocationsNoLongerExist(lastCompletedBuild, listener, env)) {\n                // Disable this project, see HUDSON-763\n                listener.getLogger().println(\n                        Messages.SubversionSCM_pollChanges_locationsNoLongerExist(project));\n                project.makeDisabled(true);\n                return NO_CHANGES;\n            }\n\n            // are the locations checked out in the workspace consistent with the current configuration?\n            for (ModuleLocation loc : getLocations(env, lastCompletedBuild)) {\n                // baseline.revisions has URIdecoded URL\n                String url;\n                try { \n                    url = loc.getSVNURL().toDecodedString();\n                } catch (SVNException ex) {\n                    ex.printStackTrace(listener.error(Messages.SubversionSCM_pollChanges_exception(loc.getURL())));\n                    return BUILD_NOW;\n                }\n                if (!baseline.revisions.containsKey(url)) {\n                    listener.getLogger().println(\n                            Messages.SubversionSCM_pollChanges_locationNotInWorkspace(url));\n                    return BUILD_NOW;\n                }\n            }\n        }\n\n        // determine where to perform polling. prefer the node where the build happened,\n        // in case a cluster is non-uniform. see http://www.nabble.com/svn-connection-from-slave-only-td24970587.html\n        VirtualChannel ch=null;\n        Node n = null;\n        if (!isPollFromMaster()) {\n            n = lastCompletedBuild!=null ? lastCompletedBuild.getBuiltOn() : null;\n            if (n!=null) {\n                Computer c = n.toComputer();\n                if (c!=null)    ch = c.getChannel();\n            }\n        }\n        if (ch==null)   ch= MasterComputer.localChannel;\n \n        final String nodeName = n!=null ? n.getNodeName() : \"master\";\n\n        final SVNLogHandler logHandler = new SVNLogHandler(createSVNLogFilter(), listener);\n\n        final ISVNAuthenticationProvider authProvider = getDescriptor().createAuthenticationProvider(project);\n\n        // figure out the remote revisions\n        return ch.call(new CompareAgainstBaselineCallable(baseline, logHandler, project.getName(), listener, authProvider, nodeName));\n    }\n\n    public SVNLogFilter createSVNLogFilter() {\n        return new DefaultSVNLogFilter(getExcludedRegionsPatterns(), getIncludedRegionsPatterns(),\n                getExcludedUsersNormalized(), getExcludedRevprop(), getExcludedCommitMessagesPatterns(), isIgnoreDirPropChanges());\n    }\n\n    /**\n     * Goes through the changes between two revisions and see if all the changes\n     * are excluded.\n     */\n    static final class SVNLogHandler implements ISVNLogEntryHandler, Serializable {\n\n        private boolean changesFound = false;\n        private SVNLogFilter filter;\n\n        SVNLogHandler(SVNLogFilter svnLogFilter, TaskListener listener) {\n            this.filter = svnLogFilter;;\n            this.filter.setTaskListener(listener);\n        }\n\n        public boolean isChangesFound() {\n            return changesFound;\n        }\n\n        /**\n         * Checks it the revision range [from,to] has any changes that are not excluded via exclusions.\n         */\n        public boolean findNonExcludedChanges(SVNURL url, long from, long to, ISVNAuthenticationProvider authProvider) throws SVNException {\n            if (from>to)        return false; // empty revision range, meaning no change\n\n            // if no exclusion rules are defined, don't waste time going through \"svn log\".\n            if (!filter.hasExclusionRule())    return true;\n\n            final SvnClientManager manager = createClientManager(authProvider);\n            try {\n                manager.getLogClient().doLog(url, null, SVNRevision.UNDEFINED,\n                        SVNRevision.create(from), // get log entries from the local revision + 1\n                        SVNRevision.create(to), // to the remote revision\n                        false, // Don't stop on copy.\n                        true, // Report paths.\n                        false, // Don't included merged revisions\n                        0, // Retrieve log entries for unlimited number of revisions.\n                        null, // Retrieve all revprops\n                        this);\n            } finally {\n                manager.dispose();\n            }\n\n            return isChangesFound();\n        }\n\n        /**\n         * Handles a log entry passed.\n         * Check for log entries that should be excluded from triggering a build.\n         * If an entry is not an entry that should be excluded, set changesFound to true\n         *\n         * @param logEntry an {@link org.tmatesoft.svn.core.SVNLogEntry} object\n         *                 that represents per revision information\n         *                 (committed paths, log message, etc.)\n         * @throws org.tmatesoft.svn.core.SVNException\n         */\n        public void handleLogEntry(SVNLogEntry logEntry) throws SVNException {\n            if (filter.isIncluded(logEntry)) {\n                changesFound = true;\n            }\n        }\n\n        private static final long serialVersionUID = 1L;\n    }\n\n    public ChangeLogParser createChangeLogParser() {\n        return new SubversionChangeLogParser(ignoreDirPropChanges);\n    }\n\n\n    @Override\n    public DescriptorImpl getDescriptor() {\n        return (DescriptorImpl)super.getDescriptor();\n    }\n\n    /**\n     * @deprecated\n     */\n    @Override\n    @Deprecated\n    public FilePath getModuleRoot(FilePath workspace) {\n        if (getLocations().length > 0)\n            return workspace.child(getLocations()[0].getLocalDir());\n        return workspace;\n    }\n\n    @Override\n    public FilePath getModuleRoot(FilePath workspace, AbstractBuild build) {\n        if (build == null) {\n            return getModuleRoot(workspace);\n        }\n\n        // TODO: can't I get the build listener here?\n        TaskListener listener = new LogTaskListener(LOGGER, WARNING);\n        final EnvVars env;\n        try {\n            env = build.getEnvironment(listener);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(e);\n        }\n\n        if (getLocations().length > 0)\n            return _getModuleRoot(workspace, getLocations()[0].getLocalDir(), env);\n        return workspace;\n    }\n\n    @Deprecated\n    @Override\n    public FilePath[] getModuleRoots(FilePath workspace) {\n        final ModuleLocation[] moduleLocations = getLocations();\n        if (moduleLocations.length > 0) {\n            FilePath[] moduleRoots = new FilePath[moduleLocations.length];\n            for (int i = 0; i < moduleLocations.length; i++) {\n                moduleRoots[i] = workspace.child(moduleLocations[i].getLocalDir());\n            }\n            return moduleRoots;\n        }\n        return new FilePath[] { getModuleRoot(workspace) };\n    }\n    \n    @Override\n    public FilePath[] getModuleRoots(FilePath workspace, AbstractBuild build) {\n        if (build == null) {\n            return getModuleRoots(workspace);\n        }\n        \n        // TODO: can't I get the build listener here?\n        TaskListener listener = new LogTaskListener(LOGGER, WARNING);\n        final EnvVars env;\n        try {\n            env = build.getEnvironment(listener);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(e);\n        }\n        \n        final ModuleLocation[] moduleLocations = getLocations();\n        if (moduleLocations.length > 0) {\n            FilePath[] moduleRoots = new FilePath[moduleLocations.length];\n            for (int i = 0; i < moduleLocations.length; i++) {\n                moduleRoots[i] = _getModuleRoot(workspace, moduleLocations[i].getLocalDir(), env);\n            }\n            return moduleRoots;\n        }\n        return new FilePath[] { getModuleRoot(workspace, build) };\n\n    }\n\n    FilePath _getModuleRoot(FilePath workspace, String localDir, EnvVars env) {\n        return workspace.child(\n                env.expand(localDir));\n    }\n\n    private static String getLastPathComponent(String s) {\n        String[] tokens = s.split(\"/\");\n        return tokens[tokens.length-1]; // return the last token\n    }\n\n    @Extension\n    public static class DescriptorImpl extends SCMDescriptor<SubversionSCM> implements hudson.model.ModelObject {\n        /**\n         * SVN authentication realm to its associated credentials.\n         * This is the global credential repository.\n         */\n        private final Map<String,Credential> credentials = new Hashtable<String,Credential>();\n\n        /**\n         * Stores name of Subversion revision property to globally exclude\n         */\n        private String globalExcludedRevprop = null;\n\n        private int workspaceFormat = SVNAdminAreaFactory.WC_FORMAT_14;\n\n        /**\n         * When set to true, repository URLs will be validated up to the first\n         * dollar sign which is encountered.\n         */\n        private boolean validateRemoteUpToVar = false;\n\n        /**\n         * When set to {@code false}, then auth details will never be stored on disk.\n         * @since 1.27\n         */\n        private boolean storeAuthToDisk = true;\n\n        /**\n         * Stores {@link SVNAuthentication} for a single realm.\n         *\n         * <p>\n         * {@link Credential} holds data in a persistence-friendly way,\n         * and it's capable of creating {@link SVNAuthentication} object,\n         * to be passed to SVNKit.\n         */\n        public static abstract class Credential implements Serializable {\n            /**\n             * \n             */\n            private static final long serialVersionUID = -3707951427730113110L;\n\n            /**\n             * @param kind\n             *      One of the constants defined in {@link ISVNAuthenticationManager},\n             *      indicating what subtype of {@link SVNAuthentication} is expected.\n             */\n            public abstract SVNAuthentication createSVNAuthentication(String kind) throws SVNException;\n        }\n\n        /**\n         * Username/password based authentication.\n         */\n        public static final class PasswordCredential extends Credential {\n            /**\n             * \n             */\n            private static final long serialVersionUID = -1676145651108866745L;\n            private final String userName;\n            private final String password; // scrambled by base64\n\n            public PasswordCredential(String userName, String password) {\n                this.userName = userName;\n                this.password = Scrambler.scramble(password);\n            }\n\n            @Override\n            public SVNAuthentication createSVNAuthentication(String kind) {\n                if(kind.equals(ISVNAuthenticationManager.SSH))\n                    return new SVNSSHAuthentication(userName,Scrambler.descramble(password),-1,false);\n                else\n                    return new SVNPasswordAuthentication(userName,Scrambler.descramble(password),false);\n            }\n        }\n\n        /**\n         * Public key authentication for Subversion over SSH.\n         */\n        public static final class SshPublicKeyCredential extends Credential {\n            /**\n             * \n             */\n            private static final long serialVersionUID = -4649332611621900514L;\n            private final String userName;\n            private final String passphrase; // scrambled by base64\n            private final String id;\n\n            /**\n             * @param keyFile\n             *      stores SSH private key. The file will be copied.\n             */\n            public SshPublicKeyCredential(String userName, String passphrase, File keyFile) throws SVNException {\n                this.userName = userName;\n                this.passphrase = Scrambler.scramble(passphrase);\n\n                Random r = new Random();\n                StringBuilder buf = new StringBuilder();\n                for(int i=0;i<16;i++)\n                    buf.append(Integer.toHexString(r.nextInt(16)));\n                this.id = buf.toString();\n\n                try {\n                    File savedKeyFile = getKeyFile();\n                    FileUtils.copyFile(keyFile,savedKeyFile);\n                    setFilePermissions(savedKeyFile, \"600\");\n                } catch (IOException e) {\n                    throw new SVNException(\n                            SVNErrorMessage.create(SVNErrorCode.AUTHN_CREDS_UNAVAILABLE,\"Unable to save private key\").initCause(e));\n                }\n            }\n\n            /**\n             * Gets the location where the private key will be permanently stored.\n             */\n            private File getKeyFile() {\n                File dir = new File(Hudson.getInstance().getRootDir(),\"subversion-credentials\");\n                if(dir.mkdirs()) {\n                    // make sure the directory exists. if we created it, try to set the permission to 600\n                    // since this is sensitive information\n                    setFilePermissions(dir, \"600\");\n                }\n                return new File(dir,id);\n            }\n\n            /**\n             * Set the file permissions\n             */\n            private boolean setFilePermissions(File file, String perms) {\n                try {\n                    Chmod chmod = new Chmod();\n                    chmod.setProject(new Project());\n                    chmod.setFile(file);\n                    chmod.setPerm(perms);\n                    chmod.execute();\n                } catch (BuildException e) {\n                    // if we failed to set the permission, that's fine.\n                    LOGGER.log(Level.WARNING, \"Failed to set permission of \"+file,e);\n                    return false;\n                }\n\n                return true;\n            }\n\n            @Override\n            public SVNSSHAuthentication createSVNAuthentication(String kind) throws SVNException {\n                if(kind.equals(ISVNAuthenticationManager.SSH)) {\n                    try {\n                        Channel channel = Channel.current();\n                        String privateKey;\n                        if(channel!=null) {\n                            // remote\n                            privateKey = channel.call(new Callable<String,IOException>() {\n                                /**\n                                 * \n                                 */\n                                private static final long serialVersionUID = -3088632649290496373L;\n\n                                public String call() throws IOException {\n                                    return FileUtils.readFileToString(getKeyFile(),\"iso-8859-1\");\n                                }\n                            });\n                        } else {\n                            privateKey = FileUtils.readFileToString(getKeyFile(),\"iso-8859-1\");\n                        }\n                        return new SVNSSHAuthentication(userName, privateKey.toCharArray(), Scrambler.descramble(passphrase),-1,false);\n                    } catch (IOException e) {\n                        throw new SVNException(\n                                SVNErrorMessage.create(SVNErrorCode.AUTHN_CREDS_UNAVAILABLE,\"Unable to load private key\").initCause(e));\n                    } catch (InterruptedException e) {\n                        throw new SVNException(\n                                SVNErrorMessage.create(SVNErrorCode.AUTHN_CREDS_UNAVAILABLE,\"Unable to load private key\").initCause(e));\n                    }\n                } else\n                    return null; // unknown\n            }\n        }\n\n        /**\n         * SSL client certificate based authentication.\n         */\n        public static final class SslClientCertificateCredential extends Credential {\n            /**\n             * \n             */\n            private static final long serialVersionUID = 5455755079546887446L;\n            private final Secret certificate;\n            private final String password; // scrambled by base64\n\n            public SslClientCertificateCredential(File certificate, String password) throws IOException {\n                this.password = Scrambler.scramble(password);\n                this.certificate = Secret.fromString(new String(Base64.encode(FileUtils.readFileToByteArray(certificate))));\n            }\n\n            @Override\n            public SVNAuthentication createSVNAuthentication(String kind) {\n                if(kind.equals(ISVNAuthenticationManager.SSL))\n                    try {\n                        SVNSSLAuthentication authentication = new SVNSSLAuthentication(\n                                Base64.decode(certificate.getPlainText().toCharArray()),\n                                Scrambler.descramble(password), false);\n                        authentication.setCertificatePath(\"dummy\"); // TODO: remove this JENKINS-19175 workaround\n                        return authentication;\n                    } catch (IOException e) {\n                        throw new Error(e); // can't happen\n                    }\n                else\n                    return null; // unexpected authentication type\n            }\n        }\n\n        /**\n         * Remoting interface that allows remote {@link ISVNAuthenticationProvider}\n         * to read from local {@link DescriptorImpl#credentials}.\n         */\n        interface RemotableSVNAuthenticationProvider extends Serializable {\n            Credential getCredential(SVNURL url, String realm);\n\n            /**\n             * Indicates that the specified credential worked.\n             */\n            void acknowledgeAuthentication(String realm, Credential credential);\n        }\n\n        /**\n         * There's no point in exporting multiple {@link RemotableSVNAuthenticationProviderImpl} instances,\n         * so let's just use one instance.\n         */\n        private transient final RemotableSVNAuthenticationProviderImpl remotableProvider = new RemotableSVNAuthenticationProviderImpl();\n\n        private final class RemotableSVNAuthenticationProviderImpl implements RemotableSVNAuthenticationProvider {\n            /**\n             * \n             */\n            private static final long serialVersionUID = 1243451839093253666L;\n\n            public Credential getCredential(SVNURL url, String realm) {\n                for (SubversionCredentialProvider p : SubversionCredentialProvider.all()) {\n                    Credential c = p.getCredential(url,realm);\n                    if(c!=null) {\n                        LOGGER.fine(String.format(\"getCredential(%s)=>%s by %s\",realm,c,p));\n                        return c;\n                    }\n                }\n                LOGGER.fine(String.format(\"getCredential(%s)=>%s\",realm,credentials.get(realm)));\n                return credentials.get(realm);\n            }\n\n            public void acknowledgeAuthentication(String realm, Credential credential) {\n                // this notification is only used on the project-local store.\n            }\n\n            /**\n             * When sent to the remote node, send a proxy.\n             */\n            private Object writeReplace() {\n                return Channel.current().export(RemotableSVNAuthenticationProvider.class, this);\n            }\n        }\n\n        /**\n         * See {@link DescriptorImpl#createAuthenticationProvider(AbstractProject)}.\n         */\n        static final class SVNAuthenticationProviderImpl implements ISVNAuthenticationProvider, ISVNAuthenticationOutcomeListener, Serializable {\n            /**\n             * Project-scoped authentication source. For historical reasons, can be null.\n             */\n            private final RemotableSVNAuthenticationProvider local;\n\n            /**\n             * System-wide authentication source. Used as a fallback.\n             */\n            private final RemotableSVNAuthenticationProvider global;\n\n            /**\n             * The {@link Credential} used to create the last {@link SVNAuthentication} that we've tried.\n             */\n            private Credential lastCredential;\n\n            public SVNAuthenticationProviderImpl(RemotableSVNAuthenticationProvider local, RemotableSVNAuthenticationProvider global) {\n                this.global = global;\n                this.local = local;\n            }\n\n            private SVNAuthentication fromProvider(SVNURL url, String realm, String kind, RemotableSVNAuthenticationProvider src, String debugName) throws SVNException {\n                if (src==null)  return null;\n                \n                Credential cred = src.getCredential(url,realm);\n                LOGGER.fine(String.format(\"%s.requestClientAuthentication(%s,%s,%s)=>%s\",debugName,kind,url,realm,cred));\n                this.lastCredential = cred;\n                if(cred!=null)  return cred.createSVNAuthentication(kind);\n                return null;\n            }\n\n            public SVNAuthentication requestClientAuthentication(String kind, SVNURL url, String realm, SVNErrorMessage errorMessage, SVNAuthentication previousAuth, boolean authMayBeStored) {\n\n                try {\n                    SVNAuthentication auth=fromProvider(url,realm,kind,local,\"local\");\n\n                    // first try the local credential, then the global credential.\n                    if (auth==null || compareSVNAuthentications(auth,previousAuth))\n                        auth = fromProvider(url,realm,kind,global,\"global\");\n\n                    if(previousAuth!=null && compareSVNAuthentications(auth,previousAuth)) {\n                        // See HUDSON-2909\n                        // this comparison is necessary, unlike the original fix of HUDSON-2909, since SVNKit may use\n                        // other ISVNAuthenticationProviders and their failed auth might be passed to us.\n                        // see HUDSON-3936\n                        LOGGER.log(FINE, \"Previous authentication attempt failed, so aborting: {0}\", previousAuth);\n                        return null;\n                    }\n\n                    if(auth==null && ISVNAuthenticationManager.USERNAME.equals(kind)) {\n                        // this happens with file:// URL and svn+ssh (in this case this method gets invoked twice.)\n                        // The base class does this, too.\n                        // user auth shouldn't be null.\n                        return new SVNUserNameAuthentication(\"\",false);\n                    }\n\n                    return auth;\n                } catch (SVNException e) {\n                    LOGGER.log(Level.SEVERE, \"Failed to authorize\",e);\n                    throw new RuntimeException(\"Failed to authorize\",e);\n                }\n            }\n\n            public void acknowledgeAuthentication(boolean accepted, String kind, String realm, SVNErrorMessage errorMessage, SVNAuthentication authentication) throws SVNException {\n                if (accepted && local!=null && lastCredential!=null)\n                    local.acknowledgeAuthentication(realm,lastCredential);\n            }\n\n            public int acceptServerAuthentication(SVNURL url, String realm, Object certificate, boolean resultMayBeStored) {\n                return ACCEPTED_TEMPORARY;\n            }\n\n            private static final long serialVersionUID = 1L;\n        }\n\n        @Override\n        public SCM newInstance(StaplerRequest staplerRequest, JSONObject jsonObject) throws FormException {\n            return super.newInstance(staplerRequest, jsonObject);\n        }\n\n        public DescriptorImpl() {\n            super(SubversionRepositoryBrowser.class);\n            load();\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        protected DescriptorImpl(Class clazz, Class<? extends RepositoryBrowser> repositoryBrowser) {\n            super(clazz,repositoryBrowser);\n        }\n\n        public String getDisplayName() {\n            return \"Subversion\";\n        }\n\n        public String getGlobalExcludedRevprop() {\n            return globalExcludedRevprop;\n        }\n\n        public int getWorkspaceFormat() {\n            if (workspaceFormat==0)\n                return SVNAdminAreaFactory.WC_FORMAT_14; // default\n            return workspaceFormat;\n        }\n\n        public boolean isValidateRemoteUpToVar() {\n            return validateRemoteUpToVar;\n        }\n\n        public boolean isStoreAuthToDisk() {\n            return storeAuthToDisk;\n        }\n\n        @Override\n        public boolean configure(StaplerRequest req, JSONObject formData) throws FormException {\n            globalExcludedRevprop = fixEmptyAndTrim(\n                    req.getParameter(\"svn.global_excluded_revprop\"));\n            workspaceFormat = Integer.parseInt(req.getParameter(\"svn.workspaceFormat\"));\n            validateRemoteUpToVar = formData.containsKey(\"validateRemoteUpToVar\");\n            storeAuthToDisk = formData.containsKey(\"storeAuthToDisk\");\n\n            // Save configuration\n            save();\n\n            return super.configure(req, formData);\n        }\n\n        @Override\n        public boolean isBrowserReusable(SubversionSCM x, SubversionSCM y) {\n            ModuleLocation[] xl = x.getLocations(), yl = y.getLocations();\n            if (xl.length != yl.length) return false;\n            for (int i = 0; i < xl.length; i++)\n                if (!xl[i].getURL().equals(yl[i].getURL())) return false;\n            return true;\n        }\n\n        /**\n         * Creates {@link ISVNAuthenticationProvider} backed by {@link #credentials}.\n         * This method must be invoked on the master, but the returned object is remotable.\n         *\n         * <p>\n         * Therefore, to access {@link ISVNAuthenticationProvider}, you need to call this method\n         * on the master, then pass the object to the slave side, then call\n         * {@link SubversionSCM#createSvnClientManager(ISVNAuthenticationProvider)} on the slave.\n         *\n         * @see SubversionSCM#createSvnClientManager(ISVNAuthenticationProvider)\n         */\n        public ISVNAuthenticationProvider createAuthenticationProvider(AbstractProject<?,?> inContextOf) {\n            return new SVNAuthenticationProviderImpl(\n                    inContextOf==null ? null : new PerJobCredentialStore(inContextOf),remotableProvider);\n        }\n\n        /**\n         * @deprecated as of 1.18\n         *      Now that Hudson allows different credentials to be given in different jobs,\n         *      The caller should use {@link #createAuthenticationProvider(AbstractProject)} to indicate\n         *      the project in which the subversion operation is performed.\n         */\n        public ISVNAuthenticationProvider createAuthenticationProvider() {\n            return new SVNAuthenticationProviderImpl(null,remotableProvider);\n        }\n\n        /**\n         * Submits the authentication info.\n         */\n        // TODO: stapler should do multipart/form-data handling \n        public void doPostCredential(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n            Hudson.getInstance().checkPermission(Item.CONFIGURE);\n            \n            MultipartFormDataParser parser = new MultipartFormDataParser(req);\n\n            // we'll record what credential we are trying here.\n            StringWriter log = new StringWriter();\n            PrintWriter logWriter = new PrintWriter(log);\n\n            UserProvidedCredential upc = UserProvidedCredential.fromForm(req,parser);\n\n            try {\n                postCredential(parser.get(\"url\"), upc, logWriter);\n                rsp.sendRedirect(\"credentialOK\");\n            } catch (SVNException e) {\n                logWriter.println(\"FAILED: \"+e.getErrorMessage());\n                req.setAttribute(\"message\",log.toString());\n                req.setAttribute(\"pre\",true);\n                req.setAttribute(\"exception\",e);\n                rsp.forward(Hudson.getInstance(),\"error\",req);\n            } finally {\n                upc.close();\n            }\n        }\n\n        /**\n         * @deprecated as of 1.18\n         *      Use {@link #postCredential(AbstractProject, String, String, String, File, PrintWriter)}\n         */\n        public void postCredential(String url, String username, String password, File keyFile, PrintWriter logWriter) throws SVNException, IOException {\n            postCredential(null,url,username,password,keyFile,logWriter);\n        }\n\n        public void postCredential(AbstractProject inContextOf, String url, String username, String password, File keyFile, PrintWriter logWriter) throws SVNException, IOException {\n            postCredential(url,new UserProvidedCredential(username,password,keyFile,inContextOf),logWriter);\n        }\n\n        /**\n         * Submits the authentication info.\n         *\n         * This code is fairly ugly because of the way SVNKit handles credentials.\n         */\n        public void postCredential(String url, final UserProvidedCredential upc, PrintWriter logWriter) throws SVNException, IOException {\n            SVNRepository repository = null;\n\n            try {\n                // the way it works with SVNKit is that\n                // 1) svnkit calls AuthenticationManager asking for a credential.\n                //    this is when we can see the 'realm', which identifies the user domain.\n                // 2) DefaultSVNAuthenticationManager returns the username and password we set below\n                // 3) if the authentication is successful, svnkit calls back acknowledgeAuthentication\n                //    (so we store the password info here)\n                repository = SVNRepositoryFactory.create(SVNURL.parseURIDecoded(url));\n                repository.setTunnelProvider( createDefaultSVNOptions() );\n                AuthenticationManagerImpl authManager = upc.new AuthenticationManagerImpl(logWriter) {\n                    @Override\n                    protected void onSuccess(String realm, Credential cred) {\n                        LOGGER.info(\"Persisted \"+cred+\" for \"+realm);\n                        credentials.put(realm, cred);\n                        save();\n                        if (upc.inContextOf!=null)\n                            new PerJobCredentialStore(upc.inContextOf).acknowledgeAuthentication(realm,cred);\n\n                    }\n                };\n                authManager.setAuthenticationForced(true);\n                repository.setAuthenticationManager(authManager);\n                repository.testConnection();\n                authManager.checkIfProtocolCompleted();\n            } finally {\n                if (repository != null)\n                    repository.closeSession();\n            }\n        }\n\n        /**\n         * validate the value for a remote (repository) location.\n         */\n        public FormValidation doCheckRemote(StaplerRequest req, @AncestorInPath AbstractProject context, @QueryParameter String value) {\n            // syntax check first\n            String url = Util.fixEmptyAndTrim(value);\n            if (url == null)\n                return FormValidation.error(Messages.SubversionSCM_doCheckRemote_required()); \n\n            if(isValidateRemoteUpToVar()) {\n                url = (url.indexOf('$') != -1) ? url.substring(0, url.indexOf('$')) : url;\n            } else {\n                url = new EnvVars(EnvVars.masterEnvVars).expand(url);\n            }\n\n            if(!URL_PATTERN.matcher(url).matches())\n                return FormValidation.errorWithMarkup(\n                    Messages.SubversionSCM_doCheckRemote_invalidUrl());\n\n            // Test the connection only if we have job cuonfigure permission\n            if (!Hudson.getInstance().hasPermission(Item.CONFIGURE))\n                return FormValidation.ok();\n\n            try {\n                String urlWithoutRevision = SvnHelper.getUrlWithoutRevision(url);\n            \t\n                SVNURL repoURL = SVNURL.parseURIDecoded(urlWithoutRevision);\n                if (checkRepositoryPath(context,repoURL)!=SVNNodeKind.NONE) {\n                    // something exists; now check revision if any\n                    \n                    SVNRevision revision = getRevisionFromRemoteUrl(url);\n                    if (revision != null && !revision.isValid()) {\n                        return FormValidation.errorWithMarkup(Messages.SubversionSCM_doCheckRemote_invalidRevision());\n                    }\n                    \n                    return FormValidation.ok();\n                }\n                \n                SVNRepository repository = null;\n                try {\n                    repository = getRepository(context,repoURL);\n                    long rev = repository.getLatestRevision();\n                    // now go back the tree and find if there's anything that exists\n                    String repoPath = getRelativePath(repoURL, repository);\n                    String p = repoPath;\n                    while(p.length()>0) {\n                        p = SVNPathUtil.removeTail(p);\n                        if(repository.checkPath(p,rev)==SVNNodeKind.DIR) {\n                            // found a matching path\n                            List<SVNDirEntry> entries = new ArrayList<SVNDirEntry>();\n                            repository.getDir(p,rev,false,entries);\n\n                            // build up the name list\n                            List<String> paths = new ArrayList<String>();\n                            for (SVNDirEntry e : entries)\n                                if(e.getKind()==SVNNodeKind.DIR)\n                                    paths.add(e.getName());\n\n                            String head = SVNPathUtil.head(repoPath.substring(p.length() + 1));\n                            String candidate = EditDistance.findNearest(head,paths);\n\n                            return FormValidation.error(\n                                Messages.SubversionSCM_doCheckRemote_badPathSuggest(p, head,\n                                    candidate != null ? \"/\" + candidate : \"\"));\n                        }\n                    }\n\n                    return FormValidation.error(\n                        Messages.SubversionSCM_doCheckRemote_badPath(repoPath));\n                } finally {\n                    if (repository != null)\n                        repository.closeSession();\n                }\n            } catch (SVNException e) {\n                LOGGER.log(Level.INFO, \"Failed to access subversion repository \"+url,e);\n                String message = Messages.SubversionSCM_doCheckRemote_exceptionMsg1(\n                    Util.escape(url), Util.escape(e.getErrorMessage().getFullMessage()),\n                    \"javascript:document.getElementById('svnerror').style.display='block';\"\n                      + \"document.getElementById('svnerrorlink').style.display='none';\"\n                      + \"return false;\")\n                  + \"<br/><pre id=\\\"svnerror\\\" style=\\\"display:none\\\">\"\n                  + Functions.printThrowable(e) + \"</pre>\"\n                  + Messages.SubversionSCM_doCheckRemote_exceptionMsg2(\n                      \"descriptorByName/\"+SubversionSCM.class.getName()+\"/enterCredential?\" + url);\n                return FormValidation.errorWithMarkup(message);\n            }\n        }\n\n        public SVNNodeKind checkRepositoryPath(AbstractProject context, SVNURL repoURL) throws SVNException {\n            SVNRepository repository = null;\n\n            try {\n                repository = getRepository(context,repoURL);\n                repository.testConnection();\n\n                long rev = repository.getLatestRevision();\n                String repoPath = getRelativePath(repoURL, repository);\n                return repository.checkPath(repoPath, rev);\n            } finally {\n                if (repository != null)\n                    repository.closeSession();\n            }\n        }\n\n        protected SVNRepository getRepository(AbstractProject context, SVNURL repoURL) throws SVNException {\n            SVNRepository repository = SVNRepositoryFactory.create(repoURL);\n\n            ISVNAuthenticationManager sam = createSvnAuthenticationManager(createAuthenticationProvider(context));\n            sam = new FilterSVNAuthenticationManager(sam) {\n                // If there's no time out, the blocking read operation may hang forever, because TCP itself\n                // has no timeout. So always use some time out. If the underlying implementation gives us some\n                // value (which may come from ~/.subversion), honor that, as long as it sets some timeout value.\n                @Override\n                public int getReadTimeout(SVNRepository repository) {\n                    int r = super.getReadTimeout(repository);\n                    if(r<=0)    r = DEFAULT_TIMEOUT;\n                    return r;\n                }\n            };\n            repository.setTunnelProvider(createDefaultSVNOptions());\n            repository.setAuthenticationManager(sam);\n\n            return repository;\n        }\n        \n        public static String getRelativePath(SVNURL repoURL, SVNRepository repository) throws SVNException {\n            String repoPath = repoURL.getPath().substring(repository.getRepositoryRoot(false).getPath().length());\n            if(!repoPath.startsWith(\"/\"))    repoPath=\"/\"+repoPath;\n            return repoPath;\n        }\n\n        /**\n         * validate the value for a local location (local checkout directory).\n         */\n        public FormValidation doCheckLocal(@QueryParameter String value) throws IOException, ServletException {\n            String v = Util.nullify(value);\n            if (v == null)\n                // local directory is optional so this is ok\n                return FormValidation.ok();\n\n            v = v.trim();\n\n            // check if a absolute path has been supplied\n            // (the last check with the regex will match windows drives)\n            if (v.startsWith(\"/\") || v.startsWith(\"\\\\\") || v.startsWith(\"..\") || v.matches(\"^[A-Za-z]:.*\"))\n                return FormValidation.error(\"absolute path is not allowed\");\n\n            // all tests passed so far\n            return FormValidation.ok();\n        }\n\n        /**\n         * Validates the excludeRegions Regex\n         */\n        public FormValidation doCheckExcludedRegions(@QueryParameter String value) throws IOException, ServletException {\n            for (String region : Util.fixNull(value).trim().split(\"[\\\\r\\\\n]+\"))\n                try {\n                    Pattern.compile(region);\n                } catch (PatternSyntaxException e) {\n                    return FormValidation.error(\"Invalid regular expression. \" + e.getMessage());\n                }\n            return FormValidation.ok();\n        }\n\n        /**\n         * Validates the includedRegions Regex\n         */\n        public FormValidation doCheckIncludedRegions(@QueryParameter String value) throws IOException, ServletException {\n            return  doCheckExcludedRegions(value);\n        }\n\n        /**\n         * Regular expression for matching one username. Matches 'windows' names ('DOMAIN&#92;user') and\n         * 'normal' names ('user'). Where user (and DOMAIN) has one or more characters in 'a-zA-Z_0-9')\n         */\n        private static final Pattern USERNAME_PATTERN = Pattern.compile(\"(\\\\w+\\\\\\\\)?+(\\\\w+)\");\n\n        /**\n         * Validates the excludeUsers field\n         */\n        public FormValidation doCheckExcludedUsers(@QueryParameter String value) throws IOException, ServletException {\n            for (String user : Util.fixNull(value).trim().split(\"[\\\\r\\\\n]+\")) {\n                user = user.trim();\n\n                if (\"\".equals(user)) {\n                    continue;\n                }\n\n                if (!USERNAME_PATTERN.matcher(user).matches()) {\n                    return FormValidation.error(\"Invalid username: \" + user);\n                }\n            }\n\n            return FormValidation.ok();\n        }\n\n        public List<WorkspaceUpdaterDescriptor> getWorkspaceUpdaterDescriptors() {\n            return WorkspaceUpdaterDescriptor.all();\n        }\n\n        /**\n         * Validates the excludeCommitMessages field\n         */\n        public FormValidation doCheckExcludedCommitMessages(@QueryParameter String value) throws IOException, ServletException {\n            for (String message : Util.fixNull(value).trim().split(\"[\\\\r\\\\n]+\")) {\n                try {\n                    Pattern.compile(message);\n                } catch (PatternSyntaxException e) {\n                    return FormValidation.error(\"Invalid regular expression. \" + e.getMessage());\n                }\n            }\n            return FormValidation.ok();\n        }\n\n        /**\n         * Validates the remote server supports custom revision properties\n         */\n        public FormValidation doCheckRevisionPropertiesSupported(@AncestorInPath AbstractProject context, @QueryParameter String value) throws IOException, ServletException {\n            String v = Util.fixNull(value).trim();\n            if (v.length() == 0)\n                return FormValidation.ok();\n\n            // Test the connection only if we have admin permission\n            if (!Hudson.getInstance().hasPermission(Hudson.ADMINISTER))\n                return FormValidation.ok();\n\n            try {\n                SVNURL repoURL = SVNURL.parseURIDecoded(new EnvVars(EnvVars.masterEnvVars).expand(v));\n                if (checkRepositoryPath(context,repoURL)!=SVNNodeKind.NONE)\n                    // something exists\n                    return FormValidation.ok();\n\n                SVNRepository repository = null;\n                try {\n                    repository = getRepository(context,repoURL);\n                    if (repository.hasCapability(SVNCapability.LOG_REVPROPS))\n                        return FormValidation.ok();\n                } finally {\n                    if (repository != null)\n                        repository.closeSession();\n                }\n            } catch (SVNException e) {\n                String message=\"\";\n                message += \"Unable to access \"+Util.escape(v)+\" : \"+Util.escape( e.getErrorMessage().getFullMessage());\n                LOGGER.log(Level.INFO, \"Failed to access subversion repository \"+v,e);\n                return FormValidation.errorWithMarkup(message);\n            }\n\n            return FormValidation.warning(Messages.SubversionSCM_excludedRevprop_notSupported(v));\n        }\n        \n        static {\n            new Initializer();\n        }\n\n    }\n\n    /**\n     * @deprecated 1.34\n     */\n    public boolean repositoryLocationsNoLongerExist(AbstractBuild<?,?> build, TaskListener listener) {\n        return repositoryLocationsNoLongerExist(build, listener, null);\n    }\n    \n    /**\n     * @since 1.34\n     */\n    public boolean repositoryLocationsNoLongerExist(AbstractBuild<?,?> build, TaskListener listener, EnvVars env) {\n        PrintStream out = listener.getLogger();\n\n        for (ModuleLocation l : getLocations(env, build))\n            try {\n                if (getDescriptor().checkRepositoryPath(build.getProject(), l.getSVNURL()) == SVNNodeKind.NONE) {\n                    out.println(\"Location '\" + l.remote + \"' does not exist\");\n\n                    ParametersAction params = build.getAction(ParametersAction.class);\n                    if (params != null) {\n                        // since this is used to disable projects, be conservative\n                        LOGGER.fine(\"Location could be expanded on build '\" + build\n                                + \"' parameters values:\");\n                        return false;\n                    }\n                    return true;\n                }\n            } catch (SVNException e) {\n                // be conservative, since we are just trying to be helpful in detecting\n                // non existent locations. If we can't detect that, we'll do nothing\n                LOGGER.log(FINE, \"Location check failed\",e);\n            }\n        return false;\n    }\n\n    static final Pattern URL_PATTERN = Pattern.compile(\"(https?|svn(\\\\+[a-z0-9]+)?|file)://.+\");\n\n    private static final long serialVersionUID = 1L;\n\n    // noop, but this forces the initializer to run.\n    public static void init() {}\n\n    static {\n        new Initializer();\n    }\n\n    private static final class Initializer {\n        static {\n            if(Boolean.getBoolean(\"hudson.spool-svn\"))\n                DAVRepositoryFactory.setup(new DefaultHTTPConnectionFactory(null,true,null));\n            else\n                DAVRepositoryFactory.setup();   // http, https\n            SVNRepositoryFactoryImpl.setup();   // svn, svn+xxx\n            FSRepositoryFactory.setup();    // file\n\n            // disable the connection pooling, which causes problems like\n            // http://www.nabble.com/SSH-connection-problems-p12028339.html\n            if(System.getProperty(\"svnkit.ssh2.persistent\")==null)\n                System.setProperty(\"svnkit.ssh2.persistent\",\"false\");\n\n            // push Negotiate to the end because it requires a valid Kerberos configuration.\n            // see HUDSON-8153\n            if(System.getProperty(\"svnkit.http.methods\")==null)\n                System.setProperty(\"svnkit.http.methods\",\"Digest,Basic,NTLM,Negotiate\");\n\n            // use SVN1.4 compatible workspace by default.\n            SVNAdminAreaFactory.setSelector(new SubversionWorkspaceSelector());\n        }\n    }\n\n    /**\n     * small structure to store local and remote (repository) location\n     * information of the repository. As a addition it holds the invalid field\n     * to make failure messages when doing a checkout possible\n     */\n    @ExportedBean\n    public static final class ModuleLocation implements Serializable {\n        /**\n         * Subversion URL to check out.\n         *\n         * This may include \"@NNN\" at the end to indicate a fixed revision.\n         */\n        @Exported\n        public final String remote;\n\n        /**\n         * Remembers the user-given value.\n         * Can be null.\n         *\n         * @deprecated\n         *      Code should use {@link #getLocalDir()}. This field is only intended for form binding.\n         */\n        @Exported\n        public final String local;\n\n        /**\n         * Subversion remote depth. Used as \"--depth\" option for checkout and update commands.\n         * Default value is \"infinity\".\n         */\n        @Exported\n        public final String depthOption;\n\n        /**\n         * Flag to ignore subversion externals definitions.\n         */\n        @Exported\n        public boolean ignoreExternalsOption;\n\n        /**\n         * Cache of the repository UUID.\n         */\n        private transient volatile UUID repositoryUUID;\n        private transient volatile SVNURL repositoryRoot;\n\n        /**\n         * Constructor to support backwards compatibility.\n         */\n        public ModuleLocation(String remote, String local) {\n            this(remote, local, null, false);\n        }\n\n        @DataBoundConstructor\n        public ModuleLocation(String remote, String local, String depthOption, boolean ignoreExternalsOption) {\n            this.remote = Util.removeTrailingSlash(Util.fixNull(remote).trim());\n            this.local = fixEmptyAndTrim(local);\n            this.depthOption = StringUtils.isEmpty(depthOption) ? SVNDepth.INFINITY.getName() : depthOption;\n            this.ignoreExternalsOption = ignoreExternalsOption;\n        }\n\n        /**\n         * Local directory to place the file to.\n         * Relative to the workspace root.\n         */\n        public String getLocalDir() {\n            if(local==null) \n                return getLastPathComponent(getURL());\n            return local;\n        }\n\n        /**\n         * Returns the pure URL portion of {@link #remote} by removing\n         * possible \"@NNN\" suffix.\n         */\n        public String getURL() {\n        \treturn SvnHelper.getUrlWithoutRevision(remote);\n        }\n\n        /**\n         * Gets {@link #remote} as {@link SVNURL}.\n         */\n        public SVNURL getSVNURL() throws SVNException {\n            return SVNURL.parseURIEncoded(getURL());\n        }\n\n        /**\n         * Repository UUID. Lazy computed and cached.\n         */\n        public UUID getUUID(AbstractProject context) throws SVNException {\n            if(repositoryUUID==null || repositoryRoot==null) {\n                synchronized (this) {\n                    SVNRepository r = openRepository(context);\n                    r.testConnection(); // make sure values are fetched\n                    repositoryUUID = UUID.fromString(r.getRepositoryUUID(false));\n                    repositoryRoot = r.getRepositoryRoot(false);\n                }\n            }\n            return repositoryUUID;\n        }\n\n        public SVNRepository openRepository(AbstractProject context) throws SVNException {\n            return Hudson.getInstance().getDescriptorByType(DescriptorImpl.class).getRepository(context,getSVNURL());\n        }\n\n        public SVNURL getRepositoryRoot(AbstractProject context) throws SVNException {\n            getUUID(context);\n            return repositoryRoot;\n        }\n\n        /**\n         * Figures out which revision to check out.\n         *\n         * If {@link #remote} is {@code url@rev}, then this method\n         * returns that specific revision.\n         *\n         * @param defaultValue\n         *      If \"@NNN\" portion is not in the URL, this value will be returned.\n         *      Normally, this is the SVN revision timestamped at the build date.\n         */\n        public SVNRevision getRevision(SVNRevision defaultValue) {\n            SVNRevision revision = getRevisionFromRemoteUrl(remote);\n            return revision != null ? revision : defaultValue;\n        }\n\n        /**\n         * Returns the value of remote depth option.\n         *\n         * @return the value of remote depth option.\n         */\n        public String getDepthOption() {\n            return depthOption;\n        }\n\n        /**\n         * Determines if subversion externals definitions should be ignored.\n         *\n         * @return true if subversion externals definitions should be ignored.\n         */\n        public boolean isIgnoreExternalsOption() {\n            return ignoreExternalsOption;\n        }\n\n        /**\n         * Expand location value based on Build parametric execution.\n         *\n         * @param build Build instance for expanding parameters into their values\n         * @return Output ModuleLocation expanded according to Build parameters values.\n         * @deprecated Use {@link #getExpandedLocation(EnvVars)} for vars expansion\n         *             to be performed on all env vars rather than just build parameters.\n         */\n        public ModuleLocation getExpandedLocation(AbstractBuild<?, ?> build) {\n            EnvVars env = new EnvVars(EnvVars.masterEnvVars);\n            env.putAll(build.getBuildVariables());\n            return getExpandedLocation(env);\n        }\n        \n        /**\n         * Expand location value based on environment variables.\n         *\n         * @return Output ModuleLocation expanded according to specified env vars.\n         */\n        public ModuleLocation getExpandedLocation(EnvVars env) {\n            return new ModuleLocation(env.expand(remote), env.expand(getLocalDir()), getDepthOption(), isIgnoreExternalsOption());\n        }\n\n        @Override\n        public String toString() {\n            return remote;\n        }\n\n        private static final long serialVersionUID = 1L;\n\n        public static List<ModuleLocation> parse(String[] remoteLocations, String[] localLocations, String[] depthOptions, boolean[] isIgnoreExternals) {\n            List<ModuleLocation> modules = new ArrayList<ModuleLocation>();\n            if (remoteLocations != null && localLocations != null) {\n                int entries = Math.min(remoteLocations.length, localLocations.length);\n\n                for (int i = 0; i < entries; i++) {\n                    // the remote (repository) location\n                    String remoteLoc = Util.nullify(remoteLocations[i]);\n\n                    if (remoteLoc != null) {// null if skipped\n                        remoteLoc = Util.removeTrailingSlash(remoteLoc.trim());\n                        modules.add(new ModuleLocation(remoteLoc, Util.nullify(localLocations[i]),\n                            depthOptions != null ? depthOptions[i] : null,\n                            isIgnoreExternals != null && isIgnoreExternals[i]));\n                    }\n                }\n            }\n            return modules;\n        }\n    }\n\n    private static final Logger LOGGER = Logger.getLogger(SubversionSCM.class.getName());\n\n    /**\n     * Network timeout in milliseconds.\n     * The main point of this is to prevent infinite hang, so it should be a rather long value to avoid\n     * accidental time out problem.\n     */\n    public static int DEFAULT_TIMEOUT = Integer.getInteger(SubversionSCM.class.getName()+\".timeout\",3600*1000);\n\n    /**\n     * Property to control whether SCM polling happens from the slave or master\n     */\n    private static boolean POLL_FROM_MASTER = Boolean.getBoolean(SubversionSCM.class.getName()+\".pollFromMaster\");\n\n    /**\n     * If set to non-null, read configuration from this directory instead of \"~/.subversion\".\n     */\n    public static String CONFIG_DIR = System.getProperty(SubversionSCM.class.getName()+\".configDir\");\n    \n    /**\n     * Enables trace logging of Ganymed SSH library.\n     * <p>\n     * Intended to be invoked from Groovy console.\n     */\n    public static void enableSshDebug(Level level) {\n        if(level==null)     level= Level.FINEST; // default\n\n        final Level lv = level;\n\n        com.trilead.ssh2.log.Logger.enabled=true;\n        com.trilead.ssh2.log.Logger.logger = new DebugLogger() {\n            private final Logger LOGGER = Logger.getLogger(SCPClient.class.getPackage().getName());\n            public void log(int level, String className, String message) {\n                LOGGER.log(lv,className+' '+message);\n            }\n        };\n    }\n\n    /*package*/ static boolean compareSVNAuthentications(SVNAuthentication a1, SVNAuthentication a2) {\n        if (a1==null && a2==null)       return true;\n        if (a1==null || a2==null)       return false;\n        if (a1.getClass()!=a2.getClass())    return false;\n\n        try {\n            return describeBean(a1).equals(describeBean(a2));\n        } catch (IllegalAccessException e) {\n            return false;\n        } catch (InvocationTargetException e) {\n            return false;\n        } catch (NoSuchMethodException e) {\n            return false;\n        }\n    }\n\n    /**\n     * In preparation for a comparison, char[] needs to be converted that supports value equality.\n     */\n    @SuppressWarnings(\"unchecked\")\n    private static Map describeBean(Object o) throws InvocationTargetException, NoSuchMethodException, IllegalAccessException {\n        Map<?,?> m = PropertyUtils.describe(o);\n        for (Entry e : m.entrySet()) {\n            Object v = e.getValue();\n            if (v instanceof char[]) {\n                char[] chars = (char[]) v;\n                e.setValue(new String(chars));\n            }\n        }\n        return m;\n    }\n\n    /**\n     * Gets the revision from a remote URL - i.e. the part after '@' if any\n     * \n     * @return the revision or null\n     */\n    private static SVNRevision getRevisionFromRemoteUrl(\n            String remoteUrlPossiblyWithRevision) {\n        int idx = remoteUrlPossiblyWithRevision.lastIndexOf('@');\n        int slashIdx = remoteUrlPossiblyWithRevision.lastIndexOf('/');\n        if (idx > 0 && idx > slashIdx) {\n            String n = remoteUrlPossiblyWithRevision.substring(idx + 1);\n            return SVNRevision.parse(n);\n        }\n\n        return null;\n    }\n\n}\n"], "fixing_code": ["/*\n * The MIT License\n * \n * Copyright (c) 2004-2012, Sun Microsystems, Inc., Kohsuke Kawaguchi, Fulvio Cavarretta,\n * Jean-Baptiste Quenot, Luca Domenico Milanesio, Renaud Bruyeron, Stephen Connolly,\n * Tom Huybrechts, Yahoo! Inc., Manufacture Francaise des Pneumatiques Michelin,\n * Romain Seguy, OHTAKE Tomohiro\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.scm;\n\nimport static hudson.Util.fixEmptyAndTrim;\nimport static hudson.scm.PollingResult.BUILD_NOW;\nimport static hudson.scm.PollingResult.NO_CHANGES;\nimport static java.util.logging.Level.FINE;\nimport static java.util.logging.Level.WARNING;\nimport hudson.EnvVars;\nimport hudson.Extension;\nimport hudson.FilePath;\nimport hudson.FilePath.FileCallable;\nimport hudson.Functions;\nimport hudson.Launcher;\nimport hudson.Util;\nimport hudson.XmlFile;\nimport hudson.model.BuildListener;\nimport hudson.model.Item;\nimport hudson.model.TaskListener;\nimport hudson.model.AbstractBuild;\nimport hudson.model.AbstractProject;\nimport hudson.model.Computer;\nimport hudson.model.Hudson;\nimport java.util.Arrays;\nimport java.util.WeakHashMap;\nimport jenkins.model.Jenkins.MasterComputer;\nimport hudson.model.Node;\nimport hudson.model.ParametersAction;\nimport hudson.model.Run;\nimport hudson.remoting.Callable;\nimport hudson.remoting.Channel;\nimport hudson.remoting.VirtualChannel;\nimport hudson.scm.UserProvidedCredential.AuthenticationManagerImpl;\nimport hudson.scm.subversion.CheckoutUpdater;\nimport hudson.scm.subversion.Messages;\nimport hudson.scm.subversion.SvnHelper;\nimport hudson.scm.subversion.UpdateUpdater;\nimport hudson.scm.subversion.UpdateWithRevertUpdater;\nimport hudson.scm.subversion.UpdaterException;\nimport hudson.scm.subversion.WorkspaceUpdater;\nimport hudson.scm.subversion.WorkspaceUpdater.UpdateTask;\nimport hudson.scm.subversion.WorkspaceUpdaterDescriptor;\nimport hudson.util.EditDistance;\nimport hudson.util.FormValidation;\nimport hudson.util.LogTaskListener;\nimport hudson.util.MultipartFormDataParser;\nimport hudson.util.Scrambler;\nimport hudson.util.Secret;\nimport hudson.util.TimeUnit2;\nimport hudson.util.XStream2;\n\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InterruptedIOException;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.UUID;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\n\nimport javax.servlet.ServletException;\nimport javax.xml.transform.stream.StreamResult;\n\nimport net.sf.json.JSONObject;\n\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.taskdefs.Chmod;\nimport org.kohsuke.stapler.AncestorInPath;\nimport org.kohsuke.stapler.DataBoundConstructor;\nimport org.kohsuke.stapler.QueryParameter;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.kohsuke.stapler.export.Exported;\nimport org.kohsuke.stapler.export.ExportedBean;\nimport org.tmatesoft.svn.core.ISVNLogEntryHandler;\nimport org.tmatesoft.svn.core.SVNAuthenticationException;\nimport org.tmatesoft.svn.core.SVNDepth;\nimport org.tmatesoft.svn.core.SVNDirEntry;\nimport org.tmatesoft.svn.core.SVNErrorCode;\nimport org.tmatesoft.svn.core.SVNErrorMessage;\nimport org.tmatesoft.svn.core.SVNException;\nimport org.tmatesoft.svn.core.SVNLogEntry;\nimport org.tmatesoft.svn.core.SVNNodeKind;\nimport org.tmatesoft.svn.core.SVNURL;\nimport org.tmatesoft.svn.core.auth.ISVNAuthenticationManager;\nimport org.tmatesoft.svn.core.auth.ISVNAuthenticationOutcomeListener;\nimport org.tmatesoft.svn.core.auth.ISVNAuthenticationProvider;\nimport org.tmatesoft.svn.core.auth.SVNAuthentication;\nimport org.tmatesoft.svn.core.auth.SVNPasswordAuthentication;\nimport org.tmatesoft.svn.core.auth.SVNSSHAuthentication;\nimport org.tmatesoft.svn.core.auth.SVNSSLAuthentication;\nimport org.tmatesoft.svn.core.auth.SVNUserNameAuthentication;\nimport org.tmatesoft.svn.core.internal.io.dav.DAVRepositoryFactory;\nimport org.tmatesoft.svn.core.internal.io.dav.http.DefaultHTTPConnectionFactory;\nimport org.tmatesoft.svn.core.internal.io.fs.FSRepositoryFactory;\nimport org.tmatesoft.svn.core.internal.io.svn.SVNRepositoryFactoryImpl;\nimport org.tmatesoft.svn.core.internal.util.SVNPathUtil;\nimport org.tmatesoft.svn.core.internal.wc.DefaultSVNOptions;\nimport org.tmatesoft.svn.core.internal.wc.admin.SVNAdminAreaFactory;\nimport org.tmatesoft.svn.core.io.SVNCapability;\nimport org.tmatesoft.svn.core.io.SVNRepository;\nimport org.tmatesoft.svn.core.io.SVNRepositoryFactory;\nimport org.tmatesoft.svn.core.wc.SVNClientManager;\nimport org.tmatesoft.svn.core.wc.SVNInfo;\nimport org.tmatesoft.svn.core.wc.SVNRevision;\nimport org.tmatesoft.svn.core.wc.SVNWCClient;\nimport org.tmatesoft.svn.core.wc.SVNWCUtil;\n\nimport com.thoughtworks.xstream.XStream;\nimport com.trilead.ssh2.DebugLogger;\nimport com.trilead.ssh2.SCPClient;\nimport com.trilead.ssh2.crypto.Base64;\n\n/**\n * Subversion SCM.\n *\n * <h2>Plugin Developer Notes</h2>\n * <p>\n * Plugins that interact with Subversion can use {@link DescriptorImpl#createAuthenticationProvider(AbstractProject)}\n * so that it can use the credentials (username, password, etc.) that the user entered for Hudson.\n * See the javadoc of this method for the precautions you need to take if you run Subversion operations\n * remotely on slaves.\n * \n * <h2>Implementation Notes</h2>\n * <p>\n * Because this instance refers to some other classes that are not necessarily\n * Java serializable (like {@link #browser}), remotable {@link FileCallable}s all\n * need to be declared as static inner classes.\n *\n * @author Kohsuke Kawaguchi\n */\n@SuppressWarnings(\"rawtypes\")\npublic class SubversionSCM extends SCM implements Serializable {\n    /**\n     * the locations field is used to store all configured SVN locations (with\n     * their local and remote part). Direct access to this field should be\n     * avoided and the getLocations() method should be used instead. This is\n     * needed to make importing of old hudson-configurations possible as\n     * getLocations() will check if the modules field has been set and import\n     * the data.\n     *\n     * @since 1.91\n     */\n    private ModuleLocation[] locations = new ModuleLocation[0];\n\n    private final SubversionRepositoryBrowser browser;\n    private String excludedRegions;\n    private String includedRegions;\n    private String excludedUsers;\n    /**\n     * Revision property names that are ignored for the sake of polling. Whitespace separated, possibly null. \n     */\n    private String excludedRevprop;\n    private String excludedCommitMessages;\n\n    private WorkspaceUpdater workspaceUpdater;\n\n    // No longer in use but left for serialization compatibility.\n    @Deprecated\n    private String modules;\n\n    // No longer used but left for serialization compatibility\n    @Deprecated\n    private Boolean useUpdate;\n    @Deprecated\n    private Boolean doRevert;\n\n    private boolean ignoreDirPropChanges;\n    private boolean filterChangelog;\n\n    /**\n     * A cache of the svn:externals (keyed by project).\n     */\n    private transient Map<AbstractProject, List<External>> projectExternalsCache;\n\n    private transient boolean pollFromMaster = POLL_FROM_MASTER;\n    \n    /**\n     * @deprecated as of 1.286\n     */\n    public SubversionSCM(String[] remoteLocations, String[] localLocations,\n                         boolean useUpdate, SubversionRepositoryBrowser browser) {\n        this(remoteLocations,localLocations, useUpdate, browser, null, null, null);\n    }\n\n    /**\n     * @deprecated as of 1.311\n     */\n    public SubversionSCM(String[] remoteLocations, String[] localLocations,\n                         boolean useUpdate, SubversionRepositoryBrowser browser, String excludedRegions) {\n        this(ModuleLocation.parse(remoteLocations,localLocations,null,null), useUpdate, false, browser, excludedRegions, null, null, null);\n    }\n\n    /**\n     * @deprecated as of 1.315\n     */\n     public SubversionSCM(String[] remoteLocations, String[] localLocations,\n                         boolean useUpdate, SubversionRepositoryBrowser browser, String excludedRegions, String excludedUsers, String excludedRevprop) {\n        this(ModuleLocation.parse(remoteLocations,localLocations,null,null), useUpdate, false, browser, excludedRegions, excludedUsers, excludedRevprop, null);\n    }\n\n   /**\n     * @deprecated as of 1.315\n     */\n    public SubversionSCM(List<ModuleLocation> locations,\n                         boolean useUpdate, SubversionRepositoryBrowser browser, String excludedRegions) {\n        this(locations, useUpdate, false, browser, excludedRegions, null, null, null);\n    }\n    \n    /**\n     * @deprecated as of 1.324\n     */\n    public SubversionSCM(List<ModuleLocation> locations,\n            boolean useUpdate, SubversionRepositoryBrowser browser, String excludedRegions, String excludedUsers, String excludedRevprop) {\n        this(locations, useUpdate, false, browser, excludedRegions, excludedUsers, excludedRevprop, null);\n    }\n\n    /**\n     * @deprecated as of 1.328\n     */\n    public SubversionSCM(List<ModuleLocation> locations,\n            boolean useUpdate, SubversionRepositoryBrowser browser, String excludedRegions, String excludedUsers, String excludedRevprop, String excludedCommitMessages) {\n    \tthis(locations, useUpdate, false, browser, excludedRegions, excludedUsers, excludedRevprop, excludedCommitMessages);\n    }\n\n    /**\n     * @deprecated as of 1.xxx\n     */\n    public SubversionSCM(List<ModuleLocation> locations,\n                         boolean useUpdate, boolean doRevert, SubversionRepositoryBrowser browser, String excludedRegions, String excludedUsers, String excludedRevprop, String excludedCommitMessages) {\n        this(locations, useUpdate, doRevert, browser, excludedRegions, excludedUsers, excludedRevprop, excludedCommitMessages, null);\n    }\n\n    /**\n     * @deprecated  as of 1.23\n     */\n    public SubversionSCM(List<ModuleLocation> locations,\n                         boolean useUpdate, boolean doRevert, SubversionRepositoryBrowser browser, String excludedRegions, String excludedUsers, String excludedRevprop, String excludedCommitMessages,\n                         String includedRegions) {\n        this(locations, useUpdate?(doRevert?new UpdateWithRevertUpdater():new UpdateUpdater()):new CheckoutUpdater(),\n                browser, excludedRegions, excludedUsers, excludedRevprop, excludedCommitMessages, includedRegions);\n    }\n\n    /**\n     * \n     * @deprecated as of ...\n     */\n    public SubversionSCM(List<ModuleLocation> locations, WorkspaceUpdater workspaceUpdater,\n                         SubversionRepositoryBrowser browser, String excludedRegions, String excludedUsers, String excludedRevprop, String excludedCommitMessages,\n                         String includedRegions) {\n      this(locations, workspaceUpdater, browser, excludedRegions, excludedUsers, excludedRevprop, excludedCommitMessages, includedRegions, false);\n    }\n\n    /**\n     *  @deprecated\n     */\n    public SubversionSCM(List<ModuleLocation> locations, WorkspaceUpdater workspaceUpdater,\n            SubversionRepositoryBrowser browser, String excludedRegions, String excludedUsers, String excludedRevprop, String excludedCommitMessages,\n            String includedRegions, boolean ignoreDirPropChanges) {\n        this(locations, workspaceUpdater, browser, excludedRegions, excludedUsers, excludedRevprop, excludedCommitMessages, includedRegions, ignoreDirPropChanges, false);\n    }\n\n    @DataBoundConstructor\n    public SubversionSCM(List<ModuleLocation> locations, WorkspaceUpdater workspaceUpdater,\n                         SubversionRepositoryBrowser browser, String excludedRegions, String excludedUsers, String excludedRevprop, String excludedCommitMessages,\n                         String includedRegions, boolean ignoreDirPropChanges, boolean filterChangelog) {\n        for (Iterator<ModuleLocation> itr = locations.iterator(); itr.hasNext();) {\n            ModuleLocation ml = itr.next();\n            String remote = Util.fixEmptyAndTrim(ml.remote);\n            if(remote==null) itr.remove();\n        }\n        this.locations = locations.toArray(new ModuleLocation[locations.size()]);\n\n        this.workspaceUpdater = workspaceUpdater;\n        this.browser = browser;\n        this.excludedRegions = excludedRegions;\n        this.excludedUsers = excludedUsers;\n        this.excludedRevprop = excludedRevprop;\n        this.excludedCommitMessages = excludedCommitMessages;\n        this.includedRegions = includedRegions;\n        this.ignoreDirPropChanges = ignoreDirPropChanges;\n        this.filterChangelog = filterChangelog;\n    }\n\n    /**\n     * Convenience constructor, especially during testing.\n     */\n    public SubversionSCM(String svnUrl) {\n        this(svnUrl,\".\");\n    }\n\n    /**\n     * Convenience constructor, especially during testing.\n     */\n    public SubversionSCM(String svnUrl, String local) {\n        this(new String[]{svnUrl},new String[]{local},true,null,null,null,null);\n    }\n    \n    /**\n     * Convenience constructor, especially during testing.\n     */\n    public SubversionSCM(String[] svnUrls, String[] locals) {\n        this(svnUrls,locals,true,null,null,null,null);\n    }\n\n    /**\n     * @deprecated\n     *      as of 1.91. Use {@link #getLocations()} instead.\n     */\n    public String getModules() {\n        return null;\n    }\n\n    /**\n     * list of all configured svn locations\n     *\n     * @since 1.91\n     */\n    @Exported\n    public ModuleLocation[] getLocations() {\n    \treturn getLocations(null, null);\n    }\n\n    @Exported\n    public WorkspaceUpdater getWorkspaceUpdater() {\n        if (workspaceUpdater!=null)\n            return workspaceUpdater;\n\n        // data must have been read from old configuration.\n        if (useUpdate!=null && !useUpdate)\n            return new CheckoutUpdater();\n        if (doRevert!=null && doRevert)\n            return new UpdateWithRevertUpdater();\n        return new UpdateUpdater();\n    }\n\n    public void setWorkspaceUpdater(WorkspaceUpdater workspaceUpdater) {\n        this.workspaceUpdater = workspaceUpdater;\n    }\n\n    /**\n     * @since 1.252\n     * @deprecated Use {@link #getLocations(EnvVars, AbstractBuild)} for vars\n     *             expansion to be performed on all env vars rather than just\n     *             build parameters.\n     */\n    public ModuleLocation[] getLocations(AbstractBuild<?,?> build) {\n        return getLocations(null, build);\n    }\n\n    /**\n     * List of all configured svn locations, expanded according to all env vars\n     * or, if none defined, according to only build parameters values.\n     * Both may be defined, in which case the variables are combined.\n     * @param env If non-null, variable expansions are performed against these vars\n     * @param build If non-null, variable expansions are\n     *              performed against the build parameters\n     */\n    public ModuleLocation[] getLocations(EnvVars env, AbstractBuild<?,?> build) {\n        // check if we've got a old location\n        if (modules != null) {\n            // import the old configuration\n            List<ModuleLocation> oldLocations = new ArrayList<ModuleLocation>();\n            StringTokenizer tokens = new StringTokenizer(modules);\n            while (tokens.hasMoreTokens()) {\n                // the remote (repository location)\n                // the normalized name is always without the trailing '/'\n                String remoteLoc = Util.removeTrailingSlash(tokens.nextToken());\n\n                oldLocations.add(new ModuleLocation(remoteLoc, null));\n            }\n\n            locations = oldLocations.toArray(new ModuleLocation[oldLocations.size()]);\n            modules = null;\n        }\n\n        if(env == null && build == null)\n            return locations;\n\n        ModuleLocation[] outLocations = new ModuleLocation[locations.length];\n        EnvVars env2 = env != null ? new EnvVars(env) : new EnvVars();\n        if (build != null) {\n            env2.putAll(build.getBuildVariables());\n        }\n        EnvVars.resolve(env2);\n        for (int i = 0; i < outLocations.length; i++) {\n            outLocations[i] = locations[i].getExpandedLocation(env2);\n        }\n\n        return outLocations;\n    }\n\n    /**\n     * Get the list of every checked-out location. This differs from {@link #getLocations()}\n     * which returns only the configured locations whereas this method returns the configured\n     * locations + any svn:externals locations.\n     */\n    public ModuleLocation[] getProjectLocations(AbstractProject project) throws IOException {\n        List<External> projectExternals = getExternals(project);\n\n        ModuleLocation[] configuredLocations = getLocations();\n        if (projectExternals.isEmpty()) {\n            return configuredLocations;\n        }\n\n        List<ModuleLocation> allLocations = new ArrayList<ModuleLocation>(configuredLocations.length + projectExternals.size());\n        allLocations.addAll(Arrays.asList(configuredLocations));\n\n        for (External external : projectExternals) {\n            allLocations.add(new ModuleLocation(external.url, external.path));\n        }\n\n        return allLocations.toArray(new ModuleLocation[allLocations.size()]);\n    }\n\n    private List<External> getExternals(AbstractProject context) throws IOException {\n        Map<AbstractProject, List<External>> projectExternalsCache = getProjectExternalsCache();\n        List<External> projectExternals;\n        synchronized (projectExternalsCache) {\n            projectExternals = projectExternalsCache.get(context);\n        }\n\n        if (projectExternals == null) {\n            projectExternals = parseExternalsFile(context);\n\n            synchronized (projectExternalsCache) {\n                if (!projectExternalsCache.containsKey(context)) {\n                    projectExternalsCache.put(context, projectExternals);\n                }\n            }\n        }\n        return projectExternals;\n    }\n\n    @Override\n    @Exported\n    public SubversionRepositoryBrowser getBrowser() {\n        return browser;\n    }\n\n    @Exported\n    public String getExcludedRegions() {\n        return excludedRegions;\n    }\n\n    public String[] getExcludedRegionsNormalized() {\n        return (excludedRegions == null || excludedRegions.trim().equals(\"\"))\n                ? null : excludedRegions.split(\"[\\\\r\\\\n]+\");\n    }\n\n    private Pattern[] getExcludedRegionsPatterns() {\n        String[] excluded = getExcludedRegionsNormalized();\n        if (excluded != null) {\n            Pattern[] patterns = new Pattern[excluded.length];\n\n            int i = 0;\n            for (String excludedRegion : excluded) {\n                patterns[i++] = Pattern.compile(excludedRegion);\n            }\n\n            return patterns;\n        }\n\n        return new Pattern[0];\n    }\n\n    @Exported\n    public String getIncludedRegions() {\n        return includedRegions;\n    }\n\n    public String[] getIncludedRegionsNormalized() {\n        return (includedRegions == null || includedRegions.trim().equals(\"\"))\n                ? null : includedRegions.split(\"[\\\\r\\\\n]+\");\n    }\n\n    private Pattern[] getIncludedRegionsPatterns() {\n        String[] included = getIncludedRegionsNormalized();\n        if (included != null) {\n            Pattern[] patterns = new Pattern[included.length];\n\n            int i = 0;\n            for (String includedRegion : included) {\n                patterns[i++] = Pattern.compile(includedRegion);\n            }\n\n            return patterns;\n        }\n\n        return new Pattern[0];\n    }\n\n    @Exported\n    public String getExcludedUsers() {\n        return excludedUsers;\n    }\n\n    public Set<String> getExcludedUsersNormalized() {\n        String s = fixEmptyAndTrim(excludedUsers);\n        if (s==null)\n            return Collections.emptySet();\n\n        Set<String> users = new HashSet<String>();\n        for (String user : s.split(\"[\\\\r\\\\n]+\"))\n            users.add(user.trim());\n        return users;\n    }\n\n    @Exported\n    public String getExcludedRevprop() {\n        return excludedRevprop;\n    }\n\n    @Exported\n    public String getExcludedCommitMessages() {\n        return excludedCommitMessages;\n    }\n\n    public String[] getExcludedCommitMessagesNormalized() {\n        String s = fixEmptyAndTrim(excludedCommitMessages);\n        return s == null ? new String[0] : s.split(\"[\\\\r\\\\n]+\");\n    }\n\n    private Pattern[] getExcludedCommitMessagesPatterns() {\n        String[] excluded = getExcludedCommitMessagesNormalized();\n        Pattern[] patterns = new Pattern[excluded.length];\n\n        int i = 0;\n        for (String excludedCommitMessage : excluded) {\n            patterns[i++] = Pattern.compile(excludedCommitMessage);\n        }\n\n        return patterns;\n    }\n\n    @Exported\n    public boolean isIgnoreDirPropChanges() {\n      return ignoreDirPropChanges;\n    }\n    \n    @Exported\n    public boolean isFilterChangelog() {\n      return filterChangelog;\n    }\n\n    /**\n     * Sets the <tt>SVN_REVISION_n</tt> and <tt>SVN_URL_n</tt> environment variables during the build.\n     */\n    @Override\n    public void buildEnvVars(AbstractBuild<?, ?> build, Map<String, String> env) {\n        super.buildEnvVars(build, env);\n        \n        ModuleLocation[] svnLocations = getLocations(new EnvVars(env), build);\n\n        try {\n            Map<String,Long> revisions = parseSvnRevisionFile(build);\n            Set<String> knownURLs = revisions.keySet();\n            if(svnLocations.length==1) {\n                // for backwards compatibility if there's only a single modulelocation, we also set\n                // SVN_REVISION and SVN_URL without '_n'\n                String url = svnLocations[0].getURL();\n                Long rev = revisions.get(url);\n                if(rev!=null) {\n                    env.put(\"SVN_REVISION\",rev.toString());\n                    env.put(\"SVN_URL\",url);\n                } else if (!knownURLs.isEmpty()) {\n                    LOGGER.log(WARNING, \"no revision found corresponding to {0}; known: {1}\", new Object[] {url, knownURLs});\n                }\n            }\n            \n            for(int i=0;i<svnLocations.length;i++) {\n                String url = svnLocations[i].getURL();\n                Long rev = revisions.get(url);\n                if(rev!=null) {\n                    env.put(\"SVN_REVISION_\"+(i+1),rev.toString());\n                    env.put(\"SVN_URL_\"+(i+1),url);\n                } else if (!knownURLs.isEmpty()) {\n                    LOGGER.log(WARNING, \"no revision found corresponding to {0}; known: {1}\", new Object[] {url, knownURLs});\n                }\n            }\n\n        } catch (IOException e) {\n            LOGGER.log(WARNING, \"error building environment variables\", e);\n        }\n    }\n\n    /**\n     * Called after checkout/update has finished to compute the changelog.\n     */\n    private boolean calcChangeLog(AbstractBuild<?,?> build, File changelogFile, BuildListener listener, List<External> externals, EnvVars env) throws IOException, InterruptedException {\n        if(build.getPreviousBuild()==null) {\n            // nothing to compare against\n            return createEmptyChangeLog(changelogFile, listener, \"log\");\n        }\n\n        // some users reported that the file gets created with size 0. I suspect\n        // maybe some XSLT engine doesn't close the stream properly.\n        // so let's do it by ourselves to be really sure that the stream gets closed.\n        OutputStream os = new BufferedOutputStream(new FileOutputStream(changelogFile));\n        boolean created;\n        try {\n            created = new SubversionChangeLogBuilder(build, env, listener, this).run(externals, new StreamResult(os));\n        } finally {\n            os.close();\n        }\n        if(!created)\n            createEmptyChangeLog(changelogFile, listener, \"log\");\n\n        return true;\n    }\n\n    /**\n     * Please consider using the non-static version {@link #parseSvnRevisionFile(AbstractBuild)}!\n     */\n    /*package*/ static Map<String,Long> parseRevisionFile(AbstractBuild<?,?> build) throws IOException {\n        return parseRevisionFile(build,true,false);\n    }\n    \n    /*package*/ Map<String,Long> parseSvnRevisionFile(AbstractBuild<?,?> build) throws IOException {\n        return parseRevisionFile(build);\n    }\n\n    /**\n     * Reads the revision file of the specified build (or the closest, if the flag is so specified.)\n     *\n     * @param findClosest\n     *      If true, this method will go back the build history until it finds a revision file.\n     *      A build may not have a revision file for any number of reasons (such as failure, interruption, etc.)\n     * @return\n     *      map from {@link SvnInfo#url Subversion URL} to its revision.  If there is more than one, choose\n     *      the one with the smallest revision number\n     */\n    /*package*/ static Map<String,Long> parseRevisionFile(AbstractBuild<?,?> build, boolean findClosest, boolean prunePinnedExternals) throws IOException {\n        Map<String,Long> revisions = new HashMap<String,Long>(); // module -> revision\n\n        if (findClosest) {\n            for (AbstractBuild<?,?> b=build; b!=null; b=b.getPreviousBuild()) {\n                if(getRevisionFile(b).exists()) {\n                    build = b;\n                    break;\n                }\n            }\n        }\n\n        {// read the revision file of the build\n            File file = getRevisionFile(build);\n            if(!file.exists())\n                // nothing to compare against\n                return revisions;\n\n            BufferedReader br = new BufferedReader(new FileReader(file));\n            try {\n                String line;\n                while((line=br.readLine())!=null) {\n                \tboolean isPinned = false;\n                \tint indexLast = line.length();\n                \tif (line.lastIndexOf(\"::p\") == indexLast-3) {\n                \t\tisPinned = true;\n                \t\tindexLast -= 3;\n                \t}\n                \tint index = line.lastIndexOf('/');\n                    if(index<0) {\n                        continue;   // invalid line?\n                    }\n                    try {\n                    \tString url = line.substring(0, index);\n                    \tlong revision = Long.parseLong(line.substring(index+1,indexLast));\n                    \tLong oldRevision = revisions.get(url);\n                    \tif (isPinned) {\n                    \t\tif (!prunePinnedExternals) {\n                    \t\t\tif (oldRevision == null)\n                    \t\t\t\t// If we're writing pinned, only write if there are no unpinned\n                    \t\t\t\trevisions.put(url, revision);\n                    \t\t}\n                    \t} else {\n                    \t\t// unpinned\n                        \tif (oldRevision == null || oldRevision > revision)\n                        \t\t// For unpinned, take minimum\n                        \t\trevisions.put(url, revision);\n                    \t}\n                \t} catch (NumberFormatException e) {\n                \t    // perhaps a corrupted line.\n                \t    LOGGER.log(WARNING, \"Error parsing line \" + line, e);\n                \t}\n                }\n            } finally {\n                br.close();\n            }\n        }\n\n        return revisions;\n    }\n\n    /**\n     * Parses the file that stores the locations in the workspace where modules loaded by svn:external\n     * is placed.\n     *\n     * <p>\n     * Note that the format of the file has changed in 1.180 from simple text file to XML.\n     *\n     * @return\n     *      immutable list. Can be empty but never null.\n     */\n    /*package*/ @SuppressWarnings(\"unchecked\")\n    static List<External> parseExternalsFile(AbstractProject project) throws IOException {\n        File file = getExternalsFile(project);\n        if(file.exists()) {\n            try {\n                return (List<External>)new XmlFile(External.XSTREAM,file).read();\n            } catch (IOException e) {\n                // in < 1.180 this file was a text file, so it may fail to parse as XML,\n                // in which case let's just fall back\n            }\n        }\n\n        return Collections.emptyList();\n    }\n\n    /**\n     * Polling can happen on the master and does not require a workspace.\n     */\n    @Override\n    public boolean requiresWorkspaceForPolling() {\n        return false;\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    public boolean checkout(AbstractBuild build, Launcher launcher, FilePath workspace, final BuildListener listener, File changelogFile) throws IOException, InterruptedException {\n        EnvVars env = build.getEnvironment(listener);\n        EnvVarsUtils.overrideAll(env, build.getBuildVariables());\n\n        List<External> externals = null;\n        try {\n            externals = checkout(build,workspace,listener,env);\n        } catch (UpdaterException e) {\n            return false;\n        }\n\n        // write out the revision file\n        PrintWriter w = new PrintWriter(new FileOutputStream(getRevisionFile(build)));\n        try {\n            List<SvnInfoP> pList = workspace.act(new BuildRevisionMapTask(build, this, listener, externals, env));\n            List<SvnInfo> revList= new ArrayList<SvnInfo>(pList.size());\n            for (SvnInfoP p: pList) {\n                if (p.pinned) \n                    w.println( p.info.url +'/'+ p.info.revision + \"::p\");\n                else\n                    w.println( p.info.url +'/'+ p.info.revision);\n                revList.add(p.info);\n            }\n            build.addAction(new SubversionTagAction(build,revList));\n        } finally {\n            w.close();\n        }\n\n        // write out the externals info\n        new XmlFile(External.XSTREAM,getExternalsFile(build.getProject())).write(externals);\n        Map<AbstractProject, List<External>> projectExternalsCache = getProjectExternalsCache();\n        synchronized (projectExternalsCache) {\n            projectExternalsCache.put(build.getProject(), externals);\n        }\n\n        return calcChangeLog(build, changelogFile, listener, externals, env);\n    }\n\n    /**\n     * Performs the checkout or update, depending on the configuration and workspace state.\n     *\n     * <p>\n     * Use canonical path to avoid SVNKit/symlink problem as described in\n     * https://wiki.svnkit.com/SVNKit_FAQ\n     *\n     * @return null\n     *      if the operation failed. Otherwise the set of local workspace paths\n     *      (relative to the workspace root) that has loaded due to svn:external.\n     */\n    private List<External> checkout(AbstractBuild build, FilePath workspace, TaskListener listener, EnvVars env) throws IOException, InterruptedException {\n        if (repositoryLocationsNoLongerExist(build, listener, env)) {\n            Run lsb = build.getProject().getLastSuccessfulBuild();\n            if (lsb != null && build.getNumber()-lsb.getNumber()>10\n            && build.getTimestamp().getTimeInMillis()-lsb.getTimestamp().getTimeInMillis() > TimeUnit2.DAYS.toMillis(1)) {\n                // Disable this project if the location doesn't exist any more, see issue #763\n                // but only do so if there was at least some successful build,\n                // to make sure that initial configuration error won't disable the build. see issue #1567\n                // finally, only disable a build if the failure persists for some time.\n                // see http://www.nabble.com/Should-Hudson-have-an-option-for-a-content-fingerprint--td24022683.html\n\n                listener.getLogger().println(\"One or more repository locations do not exist anymore for \" + build.getProject().getName() + \", project will be disabled.\");\n                build.getProject().makeDisabled(true);\n                return null;\n            }\n        }\n        \n        List<External> externals = new ArrayList<External>();\n        for (ModuleLocation location : getLocations(env, build)) {\n            externals.addAll( workspace.act(new CheckOutTask(build, this, location, build.getTimestamp().getTime(), listener, env)));\n            // olamy: remove null check at it cause test failure\n            // see https://github.com/jenkinsci/subversion-plugin/commit/de23a2b781b7b86f41319977ce4c11faee75179b#commitcomment-1551273\n            /*if ( externalsFound != null ){\n                externals.addAll(externalsFound);\n            } else {\n                externals.addAll( new ArrayList<External>( 0 ) );\n            }*/\n        }\n\n        return externals;\n    }\n\n    private synchronized Map<AbstractProject, List<External>> getProjectExternalsCache() {\n        if (projectExternalsCache == null) {\n            projectExternalsCache = new WeakHashMap<AbstractProject, List<External>>();\n        }\n\n        return projectExternalsCache;\n    }\n\n    /**\n     * Either run \"svn co\" or \"svn up\" equivalent.\n     */\n    private static class CheckOutTask extends UpdateTask implements FileCallable<List<External>> {\n        private final UpdateTask task;\n\n         public CheckOutTask(AbstractBuild<?, ?> build, SubversionSCM parent, ModuleLocation location, Date timestamp, TaskListener listener, EnvVars env) {\n            this.authProvider = parent.getDescriptor().createAuthenticationProvider(build.getParent());\n            this.timestamp = timestamp;\n            this.listener = listener;\n            this.location = location;\n            this.revisions = build.getAction(RevisionParameterAction.class);\n            this.task = parent.getWorkspaceUpdater().createTask();\n        }\n        \n        public List<External> invoke(File ws, VirtualChannel channel) throws IOException {\n            clientManager = createClientManager(authProvider);\n            manager = clientManager.getCore();\n            this.ws = ws;\n            try {\n                List<External> externals = perform();\n\n                checkClockOutOfSync();\n\n                return externals;\n\n            } catch (InterruptedException e) {\n                throw (InterruptedIOException)new InterruptedIOException().initCause(e);\n            } finally {\n                clientManager.dispose();\n            }\n        }\n\n        /**\n         * This round-about way of executing the task ensures that the error-prone {@link #delegateTo(UpdateTask)} method\n         * correctly copies everything.\n         */\n        @Override\n        public List<External> perform() throws IOException, InterruptedException {\n            return delegateTo(task);\n        }\n\n        private void checkClockOutOfSync() {\n            try {\n                SVNDirEntry dir = clientManager.createRepository(location.getSVNURL(), true).info(\"/\", -1);\n                if (dir != null) {// I don't think this can ever be null, but be defensive\n                    if (dir.getDate() != null && dir.getDate().after(new Date())) // see http://www.nabble.com/NullPointerException-in-SVN-Checkout-Update-td21609781.html that reported this being null.\n                    {\n                        listener.getLogger().println(Messages.SubversionSCM_ClockOutOfSync());\n                    }\n                }\n            } catch (SVNAuthenticationException e) {\n                // if we don't have access to '/', ignore. error\n                LOGGER.log(Level.FINE,\"Failed to estimate the remote time stamp\",e);\n            } catch (SVNException e) {\n                LOGGER.log(Level.INFO,\"Failed to estimate the remote time stamp\",e);\n            }\n        }\n\n        private static final long serialVersionUID = 1L;\n    }\n\n    /**\n     *\n     * @deprecated as of 1.40\n     *      Use {@link #createClientManager(ISVNAuthenticationProvider)}\n     */\n    public static SVNClientManager createSvnClientManager(ISVNAuthenticationProvider authProvider) {\n        return createClientManager(authProvider).getCore();\n    }\n\n    /**\n     * Creates {@link SVNClientManager}.\n     *\n     * <p>\n     * This method must be executed on the slave where svn operations are performed.\n     *\n     * @param authProvider\n     *      The value obtained from {@link DescriptorImpl#createAuthenticationProvider(AbstractProject)}.\n     *      If the operation runs on slaves,\n     *      (and properly remoted, if the svn operations run on slaves.)\n     */\n    public static SvnClientManager createClientManager(ISVNAuthenticationProvider authProvider) {\n        ISVNAuthenticationManager sam = createSvnAuthenticationManager(authProvider);\n        return new SvnClientManager(SVNClientManager.newInstance(createDefaultSVNOptions(), sam));\n    }\n\n    /**\n     * Creates the {@link DefaultSVNOptions}.\n     *\n     * @return the {@link DefaultSVNOptions}.\n     */\n    public static DefaultSVNOptions createDefaultSVNOptions() {\n        DefaultSVNOptions defaultOptions = SVNWCUtil.createDefaultOptions(true);\n        DescriptorImpl descriptor = Hudson.getInstance() == null ? null : Hudson.getInstance().getDescriptorByType(DescriptorImpl.class);\n        if (defaultOptions != null && descriptor != null) {\n            defaultOptions.setAuthStorageEnabled(descriptor.isStoreAuthToDisk());\n        }\n        return defaultOptions;\n    }\n\n    public static ISVNAuthenticationManager createSvnAuthenticationManager(ISVNAuthenticationProvider authProvider) {\n        File configDir;\n        if (CONFIG_DIR!=null)\n            configDir = new File(CONFIG_DIR);\n        else\n            configDir = SVNWCUtil.getDefaultConfigurationDirectory();\n        \n        ISVNAuthenticationManager sam = SVNWCUtil.createDefaultAuthenticationManager(configDir, null, null);\n        sam.setAuthenticationProvider(authProvider);\n        SVNAuthStoreHandlerImpl.install(sam);\n        return sam;\n    }\n\n    /**\n     * @deprecated as of 2.0\n     *      Use {@link #createClientManager(AbstractProject)}\n     *\n     */\n    public static SVNClientManager createSvnClientManager(AbstractProject context) {\n        return createClientManager(context).getCore();\n    }\n\n    /**\n     * Creates {@link SVNClientManager} for code running on the master.\n     * <p>\n     * CAUTION: this code only works when invoked on master. On slaves, use\n     * {@link #createSvnClientManager(ISVNAuthenticationProvider)} and get {@link ISVNAuthenticationProvider}\n     * from the master via remoting.\n     */\n    public static SvnClientManager createClientManager(AbstractProject context) {\n        return new SvnClientManager(createSvnClientManager(Hudson.getInstance().getDescriptorByType(DescriptorImpl.class).createAuthenticationProvider(context)));\n    }\n\n    public static final class SvnInfo implements Serializable, Comparable<SvnInfo> {\n        /**\n         * Decoded repository URL.\n         */\n        public final String url;\n        public final long revision;\n\n        public SvnInfo(String url, long revision) {\n            this.url = url;\n            this.revision = revision;\n        }\n\n        public SvnInfo(SVNInfo info) {\n            this( info.getURL().toDecodedString(), info.getCommittedRevision().getNumber() );\n        }\n\n        public SVNURL getSVNURL() throws SVNException {\n            return SVNURL.parseURIDecoded(url);\n        }\n\n        public int compareTo(SvnInfo that) {\n            int r = this.url.compareTo(that.url);\n            if(r!=0)    return r;\n\n            if(this.revision<that.revision) return -1;\n            if(this.revision>that.revision) return +1;\n            return 0;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            SvnInfo svnInfo = (SvnInfo) o;\n            return revision==svnInfo.revision && url.equals(svnInfo.url);\n\n        }\n\n        @Override\n        public int hashCode() {\n            int result;\n            result = url.hashCode();\n            result = 31 * result + (int) (revision ^ (revision >>> 32));\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s (rev.%s)\",url,revision);\n        }\n\n        private static final long serialVersionUID = 1L;\n    }\n\n    /**\n     * {@link SvnInfo} plus a flag if the revision is fixed.\n     */\n    private static final class SvnInfoP implements Serializable {\n        /**\n         * SvnInfo with an indicator boolean indicating whether this is a pinned external\n         */\n        public final SvnInfo info;\n        public final boolean pinned;\n\n        public SvnInfoP(SvnInfo info, boolean pinned) {\n            this.info = info;\n            this.pinned = pinned;\n        }\n        private static final long serialVersionUID = 1L;\n    }\n\n    /**\n     * Information about svn:external\n     */\n    public static final class External implements Serializable {\n        /**\n         * Relative path within the workspace where this <tt>svn:exteranls</tt> exist. \n         */\n        public final String path;\n\n        /**\n         * External SVN URL to be fetched.\n         */\n        public final String url;\n\n        /**\n         * If the svn:external link is with the -r option, its number.\n         * Otherwise -1 to indicate that the head revision of the external repository should be fetched.\n         */\n        public final long revision;\n\n        public External(String path, SVNURL url, long revision) {\n            this.path = path;\n            this.url = url.toDecodedString();\n            this.revision = revision;\n        }\n\n        /**\n         * Returns true if this reference is to a fixed revision.\n         */\n        public boolean isRevisionFixed() {\n            return revision!=-1;\n        }\n\n        private static final long serialVersionUID = 1L;\n\n        private static final XStream XSTREAM = new XStream2();\n        static {\n            XSTREAM.alias(\"external\",External.class);\n        }\n    }\n\n\n    /**\n     * Gets the SVN metadata for the remote repository.\n     *\n     * @param remoteUrl\n     *      The target to run \"svn info\".\n     */\n    static SVNInfo parseSvnInfo(SVNURL remoteUrl, ISVNAuthenticationProvider authProvider) throws SVNException {\n        final SvnClientManager manager = createClientManager(authProvider);\n        try {\n            final SVNWCClient svnWc = manager.getWCClient();\n            return svnWc.doInfo(remoteUrl, SVNRevision.HEAD, SVNRevision.HEAD);\n        } finally {\n            manager.dispose();\n        }\n    }\n\n    /**\n     * Checks .svn files in the workspace and finds out revisions of the modules\n     * that the workspace has.\n     *\n     * @return\n     *      null if the parsing somehow fails. Otherwise a map from the repository URL to revisions.\n     */\n    private static class BuildRevisionMapTask implements FileCallable<List<SvnInfoP>> {\n        private final ISVNAuthenticationProvider authProvider;\n        private final TaskListener listener;\n        private final List<External> externals;\n        private final ModuleLocation[] locations;\n\n        public BuildRevisionMapTask(AbstractBuild<?, ?> build, SubversionSCM parent, TaskListener listener, List<External> externals, EnvVars env) {\n            this.authProvider = parent.getDescriptor().createAuthenticationProvider(build.getParent());\n            this.listener = listener;\n            this.externals = externals;\n            this.locations = parent.getLocations(env, build);\n        }\n\n        public List<SvnInfoP> invoke(File ws, VirtualChannel channel) throws IOException {\n            List<SvnInfoP> revisions = new ArrayList<SvnInfoP>();\n\n            final SvnClientManager manager = createClientManager(authProvider);\n            try {\n                final SVNWCClient svnWc = manager.getWCClient();\n                // invoke the \"svn info\"\n                for( ModuleLocation module : locations ) {\n                    try {\n                        SvnInfo info = new SvnInfo(svnWc.doInfo(new File(ws,module.getLocalDir()), SVNRevision.WORKING));\n                        revisions.add(new SvnInfoP(info, false));\n                    } catch (SVNException e) {\n                        e.printStackTrace(listener.error(\"Failed to parse svn info for \"+module.remote));\n                    }\n                }\n                for(External ext : externals){\n                    try {\n                        SvnInfo info = new SvnInfo(svnWc.doInfo(new File(ws,ext.path),SVNRevision.WORKING));\n                        revisions.add(new SvnInfoP(info, ext.isRevisionFixed()));\n                    } catch (SVNException e) {\n                        e.printStackTrace(listener.error(\"Failed to parse svn info for external \"+ext.url+\" at \"+ext.path));\n                    }\n                }\n\n                return revisions;\n            } finally {\n                manager.dispose();\n            }\n        }\n        private static final long serialVersionUID = 1L;\n    }\n\n    /**\n     * Gets the file that stores the revision.\n     */\n    public static File getRevisionFile(AbstractBuild build) {\n        return new File(build.getRootDir(),\"revision.txt\");\n    }\n\n    /**\n     * Gets the file that stores the externals.\n     */\n    private static File getExternalsFile(AbstractProject project) {\n        return new File(project.getRootDir(),\"svnexternals.txt\");\n    }\n\n    @Override\n    public SCMRevisionState calcRevisionsFromBuild(AbstractBuild<?, ?> build, Launcher launcher, TaskListener listener) throws IOException, InterruptedException {\n        // exclude locations that are svn:external-ed with a fixed revision.\n        Map<String,Long> wsRev = parseRevisionFile(build,true,true);\n        return new SVNRevisionState(wsRev);\n    }\n    \n    private boolean isPollFromMaster() {\n        return pollFromMaster;\n    }\n    \n    void setPollFromMaster(boolean pollFromMaster) {\n        this.pollFromMaster = pollFromMaster;\n    }\n\n    @Override\n    protected PollingResult compareRemoteRevisionWith(AbstractProject<?,?> project, Launcher launcher, FilePath workspace, final TaskListener listener, SCMRevisionState _baseline) throws IOException, InterruptedException {\n        final SVNRevisionState baseline;\n        if (_baseline instanceof SVNRevisionState) {\n            baseline = (SVNRevisionState)_baseline;\n        }\n        else if (project.getLastBuild()!=null) {\n            baseline = (SVNRevisionState)calcRevisionsFromBuild(project.getLastBuild(), launcher, listener);\n        }\n        else {\n            baseline = new SVNRevisionState(null);\n        }\n        \n        if (project.getLastBuild() == null) {\n            listener.getLogger().println(Messages.SubversionSCM_pollChanges_noBuilds());\n            return BUILD_NOW;\n        }\n\n        AbstractBuild<?,?> lastCompletedBuild = project.getLastCompletedBuild();\n\n        if (lastCompletedBuild!=null) {\n            EnvVars env = lastCompletedBuild.getEnvironment(listener);\n            EnvVarsUtils.overrideAll(env, lastCompletedBuild.getBuildVariables());\n            if (repositoryLocationsNoLongerExist(lastCompletedBuild, listener, env)) {\n                // Disable this project, see HUDSON-763\n                listener.getLogger().println(\n                        Messages.SubversionSCM_pollChanges_locationsNoLongerExist(project));\n                project.makeDisabled(true);\n                return NO_CHANGES;\n            }\n\n            // are the locations checked out in the workspace consistent with the current configuration?\n            for (ModuleLocation loc : getLocations(env, lastCompletedBuild)) {\n                // baseline.revisions has URIdecoded URL\n                String url;\n                try { \n                    url = loc.getSVNURL().toDecodedString();\n                } catch (SVNException ex) {\n                    ex.printStackTrace(listener.error(Messages.SubversionSCM_pollChanges_exception(loc.getURL())));\n                    return BUILD_NOW;\n                }\n                if (!baseline.revisions.containsKey(url)) {\n                    listener.getLogger().println(\n                            Messages.SubversionSCM_pollChanges_locationNotInWorkspace(url));\n                    return BUILD_NOW;\n                }\n            }\n        }\n\n        // determine where to perform polling. prefer the node where the build happened,\n        // in case a cluster is non-uniform. see http://www.nabble.com/svn-connection-from-slave-only-td24970587.html\n        VirtualChannel ch=null;\n        Node n = null;\n        if (!isPollFromMaster()) {\n            n = lastCompletedBuild!=null ? lastCompletedBuild.getBuiltOn() : null;\n            if (n!=null) {\n                Computer c = n.toComputer();\n                if (c!=null)    ch = c.getChannel();\n            }\n        }\n        if (ch==null)   ch= MasterComputer.localChannel;\n \n        final String nodeName = n!=null ? n.getNodeName() : \"master\";\n\n        final SVNLogHandler logHandler = new SVNLogHandler(createSVNLogFilter(), listener);\n\n        final ISVNAuthenticationProvider authProvider = getDescriptor().createAuthenticationProvider(project);\n\n        // figure out the remote revisions\n        return ch.call(new CompareAgainstBaselineCallable(baseline, logHandler, project.getName(), listener, authProvider, nodeName));\n    }\n\n    public SVNLogFilter createSVNLogFilter() {\n        return new DefaultSVNLogFilter(getExcludedRegionsPatterns(), getIncludedRegionsPatterns(),\n                getExcludedUsersNormalized(), getExcludedRevprop(), getExcludedCommitMessagesPatterns(), isIgnoreDirPropChanges());\n    }\n\n    /**\n     * Goes through the changes between two revisions and see if all the changes\n     * are excluded.\n     */\n    static final class SVNLogHandler implements ISVNLogEntryHandler, Serializable {\n\n        private boolean changesFound = false;\n        private SVNLogFilter filter;\n\n        SVNLogHandler(SVNLogFilter svnLogFilter, TaskListener listener) {\n            this.filter = svnLogFilter;;\n            this.filter.setTaskListener(listener);\n        }\n\n        public boolean isChangesFound() {\n            return changesFound;\n        }\n\n        /**\n         * Checks it the revision range [from,to] has any changes that are not excluded via exclusions.\n         */\n        public boolean findNonExcludedChanges(SVNURL url, long from, long to, ISVNAuthenticationProvider authProvider) throws SVNException {\n            if (from>to)        return false; // empty revision range, meaning no change\n\n            // if no exclusion rules are defined, don't waste time going through \"svn log\".\n            if (!filter.hasExclusionRule())    return true;\n\n            final SvnClientManager manager = createClientManager(authProvider);\n            try {\n                manager.getLogClient().doLog(url, null, SVNRevision.UNDEFINED,\n                        SVNRevision.create(from), // get log entries from the local revision + 1\n                        SVNRevision.create(to), // to the remote revision\n                        false, // Don't stop on copy.\n                        true, // Report paths.\n                        false, // Don't included merged revisions\n                        0, // Retrieve log entries for unlimited number of revisions.\n                        null, // Retrieve all revprops\n                        this);\n            } finally {\n                manager.dispose();\n            }\n\n            return isChangesFound();\n        }\n\n        /**\n         * Handles a log entry passed.\n         * Check for log entries that should be excluded from triggering a build.\n         * If an entry is not an entry that should be excluded, set changesFound to true\n         *\n         * @param logEntry an {@link org.tmatesoft.svn.core.SVNLogEntry} object\n         *                 that represents per revision information\n         *                 (committed paths, log message, etc.)\n         * @throws org.tmatesoft.svn.core.SVNException\n         */\n        public void handleLogEntry(SVNLogEntry logEntry) throws SVNException {\n            if (filter.isIncluded(logEntry)) {\n                changesFound = true;\n            }\n        }\n\n        private static final long serialVersionUID = 1L;\n    }\n\n    public ChangeLogParser createChangeLogParser() {\n        return new SubversionChangeLogParser(ignoreDirPropChanges);\n    }\n\n\n    @Override\n    public DescriptorImpl getDescriptor() {\n        return (DescriptorImpl)super.getDescriptor();\n    }\n\n    /**\n     * @deprecated\n     */\n    @Override\n    @Deprecated\n    public FilePath getModuleRoot(FilePath workspace) {\n        if (getLocations().length > 0)\n            return workspace.child(getLocations()[0].getLocalDir());\n        return workspace;\n    }\n\n    @Override\n    public FilePath getModuleRoot(FilePath workspace, AbstractBuild build) {\n        if (build == null) {\n            return getModuleRoot(workspace);\n        }\n\n        // TODO: can't I get the build listener here?\n        TaskListener listener = new LogTaskListener(LOGGER, WARNING);\n        final EnvVars env;\n        try {\n            env = build.getEnvironment(listener);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(e);\n        }\n\n        if (getLocations().length > 0)\n            return _getModuleRoot(workspace, getLocations()[0].getLocalDir(), env);\n        return workspace;\n    }\n\n    @Deprecated\n    @Override\n    public FilePath[] getModuleRoots(FilePath workspace) {\n        final ModuleLocation[] moduleLocations = getLocations();\n        if (moduleLocations.length > 0) {\n            FilePath[] moduleRoots = new FilePath[moduleLocations.length];\n            for (int i = 0; i < moduleLocations.length; i++) {\n                moduleRoots[i] = workspace.child(moduleLocations[i].getLocalDir());\n            }\n            return moduleRoots;\n        }\n        return new FilePath[] { getModuleRoot(workspace) };\n    }\n    \n    @Override\n    public FilePath[] getModuleRoots(FilePath workspace, AbstractBuild build) {\n        if (build == null) {\n            return getModuleRoots(workspace);\n        }\n        \n        // TODO: can't I get the build listener here?\n        TaskListener listener = new LogTaskListener(LOGGER, WARNING);\n        final EnvVars env;\n        try {\n            env = build.getEnvironment(listener);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(e);\n        }\n        \n        final ModuleLocation[] moduleLocations = getLocations();\n        if (moduleLocations.length > 0) {\n            FilePath[] moduleRoots = new FilePath[moduleLocations.length];\n            for (int i = 0; i < moduleLocations.length; i++) {\n                moduleRoots[i] = _getModuleRoot(workspace, moduleLocations[i].getLocalDir(), env);\n            }\n            return moduleRoots;\n        }\n        return new FilePath[] { getModuleRoot(workspace, build) };\n\n    }\n\n    FilePath _getModuleRoot(FilePath workspace, String localDir, EnvVars env) {\n        return workspace.child(\n                env.expand(localDir));\n    }\n\n    private static String getLastPathComponent(String s) {\n        String[] tokens = s.split(\"/\");\n        return tokens[tokens.length-1]; // return the last token\n    }\n\n    @Extension\n    public static class DescriptorImpl extends SCMDescriptor<SubversionSCM> implements hudson.model.ModelObject {\n        /**\n         * SVN authentication realm to its associated credentials.\n         * This is the global credential repository.\n         */\n        private final Map<String,Credential> credentials = new Hashtable<String,Credential>();\n\n        /**\n         * Stores name of Subversion revision property to globally exclude\n         */\n        private String globalExcludedRevprop = null;\n\n        private int workspaceFormat = SVNAdminAreaFactory.WC_FORMAT_14;\n\n        /**\n         * When set to true, repository URLs will be validated up to the first\n         * dollar sign which is encountered.\n         */\n        private boolean validateRemoteUpToVar = false;\n\n        /**\n         * When set to {@code false}, then auth details will never be stored on disk.\n         * @since 1.27\n         */\n        private boolean storeAuthToDisk = true;\n\n        /**\n         * Stores {@link SVNAuthentication} for a single realm.\n         *\n         * <p>\n         * {@link Credential} holds data in a persistence-friendly way,\n         * and it's capable of creating {@link SVNAuthentication} object,\n         * to be passed to SVNKit.\n         */\n        public static abstract class Credential implements Serializable {\n            /**\n             * \n             */\n            private static final long serialVersionUID = -3707951427730113110L;\n\n            /**\n             * @param kind\n             *      One of the constants defined in {@link ISVNAuthenticationManager},\n             *      indicating what subtype of {@link SVNAuthentication} is expected.\n             */\n            public abstract SVNAuthentication createSVNAuthentication(String kind) throws SVNException;\n        }\n\n        /**\n         * Username/password based authentication.\n         */\n        public static final class PasswordCredential extends Credential {\n            /**\n             * \n             */\n            private static final long serialVersionUID = -1676145651108866745L;\n            private final String userName;\n            private final Secret password; // for historical reasons, scrambled by base64 in addition to using 'Secret'\n\n            public PasswordCredential(String userName, String password) {\n                this.userName = userName;\n                this.password = Secret.fromString(Scrambler.scramble(password));\n            }\n\n            @Override\n            public SVNAuthentication createSVNAuthentication(String kind) {\n                if(kind.equals(ISVNAuthenticationManager.SSH))\n                    return new SVNSSHAuthentication(userName, getPassword(),-1,false);\n                else\n                    return new SVNPasswordAuthentication(userName, getPassword(),false);\n            }\n\n            private String getPassword() {\n                return Scrambler.descramble(Secret.toString(password));\n            }\n        }\n\n        /**\n         * Public key authentication for Subversion over SSH.\n         */\n        public static final class SshPublicKeyCredential extends Credential {\n            /**\n             * \n             */\n            private static final long serialVersionUID = -4649332611621900514L;\n            private final String userName;\n            private final Secret passphrase; // for historical reasons, scrambled by base64 in addition to using 'Secret'\n            private final String id;\n\n            /**\n             * @param keyFile\n             *      stores SSH private key. The file will be copied.\n             */\n            public SshPublicKeyCredential(String userName, String passphrase, File keyFile) throws SVNException {\n                this.userName = userName;\n                this.passphrase = Secret.fromString(Scrambler.scramble(passphrase));\n\n                Random r = new Random();\n                StringBuilder buf = new StringBuilder();\n                for(int i=0;i<16;i++)\n                    buf.append(Integer.toHexString(r.nextInt(16)));\n                this.id = buf.toString();\n\n                try {\n                    File savedKeyFile = getKeyFile();\n                    FileUtils.copyFile(keyFile,savedKeyFile);\n                    setFilePermissions(savedKeyFile, \"600\");\n                } catch (IOException e) {\n                    throw new SVNException(\n                            SVNErrorMessage.create(SVNErrorCode.AUTHN_CREDS_UNAVAILABLE,\"Unable to save private key\").initCause(e));\n                }\n            }\n\n            /**\n             * Gets the location where the private key will be permanently stored.\n             */\n            private File getKeyFile() {\n                File dir = new File(Hudson.getInstance().getRootDir(),\"subversion-credentials\");\n                if(dir.mkdirs()) {\n                    // make sure the directory exists. if we created it, try to set the permission to 600\n                    // since this is sensitive information\n                    setFilePermissions(dir, \"600\");\n                }\n                return new File(dir,id);\n            }\n\n            /**\n             * Set the file permissions\n             */\n            private boolean setFilePermissions(File file, String perms) {\n                try {\n                    Chmod chmod = new Chmod();\n                    chmod.setProject(new Project());\n                    chmod.setFile(file);\n                    chmod.setPerm(perms);\n                    chmod.execute();\n                } catch (BuildException e) {\n                    // if we failed to set the permission, that's fine.\n                    LOGGER.log(Level.WARNING, \"Failed to set permission of \"+file,e);\n                    return false;\n                }\n\n                return true;\n            }\n\n            @Override\n            public SVNSSHAuthentication createSVNAuthentication(String kind) throws SVNException {\n                if(kind.equals(ISVNAuthenticationManager.SSH)) {\n                    try {\n                        Channel channel = Channel.current();\n                        String privateKey;\n                        if(channel!=null) {\n                            // remote\n                            privateKey = channel.call(new Callable<String,IOException>() {\n                                /**\n                                 * \n                                 */\n                                private static final long serialVersionUID = -3088632649290496373L;\n\n                                public String call() throws IOException {\n                                    return FileUtils.readFileToString(getKeyFile(),\"iso-8859-1\");\n                                }\n                            });\n                        } else {\n                            privateKey = FileUtils.readFileToString(getKeyFile(),\"iso-8859-1\");\n                        }\n                        return new SVNSSHAuthentication(userName, privateKey.toCharArray(), Scrambler.descramble(Secret.toString(passphrase)),-1,false);\n                    } catch (IOException e) {\n                        throw new SVNException(\n                                SVNErrorMessage.create(SVNErrorCode.AUTHN_CREDS_UNAVAILABLE,\"Unable to load private key\").initCause(e));\n                    } catch (InterruptedException e) {\n                        throw new SVNException(\n                                SVNErrorMessage.create(SVNErrorCode.AUTHN_CREDS_UNAVAILABLE,\"Unable to load private key\").initCause(e));\n                    }\n                } else\n                    return null; // unknown\n            }\n        }\n\n        /**\n         * SSL client certificate based authentication.\n         */\n        public static final class SslClientCertificateCredential extends Credential {\n            /**\n             * \n             */\n            private static final long serialVersionUID = 5455755079546887446L;\n            private final Secret certificate;\n            private final Secret password; // for historical reasons, scrambled by base64 in addition to using 'Secret'\n\n            public SslClientCertificateCredential(File certificate, String password) throws IOException {\n                this.password = Secret.fromString(Scrambler.scramble(password));\n                this.certificate = Secret.fromString(new String(Base64.encode(FileUtils.readFileToByteArray(certificate))));\n            }\n\n            @Override\n            public SVNAuthentication createSVNAuthentication(String kind) {\n                if(kind.equals(ISVNAuthenticationManager.SSL))\n                    try {\n                        SVNSSLAuthentication authentication = new SVNSSLAuthentication(\n                                Base64.decode(certificate.getPlainText().toCharArray()),\n                                Scrambler.descramble(Secret.toString(password)), false);\n                        authentication.setCertificatePath(\"dummy\"); // TODO: remove this JENKINS-19175 workaround\n                        return authentication;\n                    } catch (IOException e) {\n                        throw new Error(e); // can't happen\n                    }\n                else\n                    return null; // unexpected authentication type\n            }\n        }\n\n        /**\n         * Remoting interface that allows remote {@link ISVNAuthenticationProvider}\n         * to read from local {@link DescriptorImpl#credentials}.\n         */\n        interface RemotableSVNAuthenticationProvider extends Serializable {\n            Credential getCredential(SVNURL url, String realm);\n\n            /**\n             * Indicates that the specified credential worked.\n             */\n            void acknowledgeAuthentication(String realm, Credential credential);\n        }\n\n        /**\n         * There's no point in exporting multiple {@link RemotableSVNAuthenticationProviderImpl} instances,\n         * so let's just use one instance.\n         */\n        private transient final RemotableSVNAuthenticationProviderImpl remotableProvider = new RemotableSVNAuthenticationProviderImpl();\n\n        private final class RemotableSVNAuthenticationProviderImpl implements RemotableSVNAuthenticationProvider {\n            /**\n             * \n             */\n            private static final long serialVersionUID = 1243451839093253666L;\n\n            public Credential getCredential(SVNURL url, String realm) {\n                for (SubversionCredentialProvider p : SubversionCredentialProvider.all()) {\n                    Credential c = p.getCredential(url,realm);\n                    if(c!=null) {\n                        LOGGER.fine(String.format(\"getCredential(%s)=>%s by %s\",realm,c,p));\n                        return c;\n                    }\n                }\n                LOGGER.fine(String.format(\"getCredential(%s)=>%s\",realm,credentials.get(realm)));\n                return credentials.get(realm);\n            }\n\n            public void acknowledgeAuthentication(String realm, Credential credential) {\n                // this notification is only used on the project-local store.\n            }\n\n            /**\n             * When sent to the remote node, send a proxy.\n             */\n            private Object writeReplace() {\n                return Channel.current().export(RemotableSVNAuthenticationProvider.class, this);\n            }\n        }\n\n        /**\n         * See {@link DescriptorImpl#createAuthenticationProvider(AbstractProject)}.\n         */\n        static final class SVNAuthenticationProviderImpl implements ISVNAuthenticationProvider, ISVNAuthenticationOutcomeListener, Serializable {\n            /**\n             * Project-scoped authentication source. For historical reasons, can be null.\n             */\n            private final RemotableSVNAuthenticationProvider local;\n\n            /**\n             * System-wide authentication source. Used as a fallback.\n             */\n            private final RemotableSVNAuthenticationProvider global;\n\n            /**\n             * The {@link Credential} used to create the last {@link SVNAuthentication} that we've tried.\n             */\n            private Credential lastCredential;\n\n            public SVNAuthenticationProviderImpl(RemotableSVNAuthenticationProvider local, RemotableSVNAuthenticationProvider global) {\n                this.global = global;\n                this.local = local;\n            }\n\n            private SVNAuthentication fromProvider(SVNURL url, String realm, String kind, RemotableSVNAuthenticationProvider src, String debugName) throws SVNException {\n                if (src==null)  return null;\n                \n                Credential cred = src.getCredential(url,realm);\n                LOGGER.fine(String.format(\"%s.requestClientAuthentication(%s,%s,%s)=>%s\",debugName,kind,url,realm,cred));\n                this.lastCredential = cred;\n                if(cred!=null)  return cred.createSVNAuthentication(kind);\n                return null;\n            }\n\n            public SVNAuthentication requestClientAuthentication(String kind, SVNURL url, String realm, SVNErrorMessage errorMessage, SVNAuthentication previousAuth, boolean authMayBeStored) {\n\n                try {\n                    SVNAuthentication auth=fromProvider(url,realm,kind,local,\"local\");\n\n                    // first try the local credential, then the global credential.\n                    if (auth==null || compareSVNAuthentications(auth,previousAuth))\n                        auth = fromProvider(url,realm,kind,global,\"global\");\n\n                    if(previousAuth!=null && compareSVNAuthentications(auth,previousAuth)) {\n                        // See HUDSON-2909\n                        // this comparison is necessary, unlike the original fix of HUDSON-2909, since SVNKit may use\n                        // other ISVNAuthenticationProviders and their failed auth might be passed to us.\n                        // see HUDSON-3936\n                        LOGGER.log(FINE, \"Previous authentication attempt failed, so aborting: {0}\", previousAuth);\n                        return null;\n                    }\n\n                    if(auth==null && ISVNAuthenticationManager.USERNAME.equals(kind)) {\n                        // this happens with file:// URL and svn+ssh (in this case this method gets invoked twice.)\n                        // The base class does this, too.\n                        // user auth shouldn't be null.\n                        return new SVNUserNameAuthentication(\"\",false);\n                    }\n\n                    return auth;\n                } catch (SVNException e) {\n                    LOGGER.log(Level.SEVERE, \"Failed to authorize\",e);\n                    throw new RuntimeException(\"Failed to authorize\",e);\n                }\n            }\n\n            public void acknowledgeAuthentication(boolean accepted, String kind, String realm, SVNErrorMessage errorMessage, SVNAuthentication authentication) throws SVNException {\n                if (accepted && local!=null && lastCredential!=null)\n                    local.acknowledgeAuthentication(realm,lastCredential);\n            }\n\n            public int acceptServerAuthentication(SVNURL url, String realm, Object certificate, boolean resultMayBeStored) {\n                return ACCEPTED_TEMPORARY;\n            }\n\n            private static final long serialVersionUID = 1L;\n        }\n\n        @Override\n        public SCM newInstance(StaplerRequest staplerRequest, JSONObject jsonObject) throws FormException {\n            return super.newInstance(staplerRequest, jsonObject);\n        }\n\n        public DescriptorImpl() {\n            super(SubversionRepositoryBrowser.class);\n            load();\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        protected DescriptorImpl(Class clazz, Class<? extends RepositoryBrowser> repositoryBrowser) {\n            super(clazz,repositoryBrowser);\n        }\n\n        public String getDisplayName() {\n            return \"Subversion\";\n        }\n\n        public String getGlobalExcludedRevprop() {\n            return globalExcludedRevprop;\n        }\n\n        public int getWorkspaceFormat() {\n            if (workspaceFormat==0)\n                return SVNAdminAreaFactory.WC_FORMAT_14; // default\n            return workspaceFormat;\n        }\n\n        public boolean isValidateRemoteUpToVar() {\n            return validateRemoteUpToVar;\n        }\n\n        public boolean isStoreAuthToDisk() {\n            return storeAuthToDisk;\n        }\n\n        @Override\n        public boolean configure(StaplerRequest req, JSONObject formData) throws FormException {\n            globalExcludedRevprop = fixEmptyAndTrim(\n                    req.getParameter(\"svn.global_excluded_revprop\"));\n            workspaceFormat = Integer.parseInt(req.getParameter(\"svn.workspaceFormat\"));\n            validateRemoteUpToVar = formData.containsKey(\"validateRemoteUpToVar\");\n            storeAuthToDisk = formData.containsKey(\"storeAuthToDisk\");\n\n            // Save configuration\n            save();\n\n            return super.configure(req, formData);\n        }\n\n        @Override\n        public boolean isBrowserReusable(SubversionSCM x, SubversionSCM y) {\n            ModuleLocation[] xl = x.getLocations(), yl = y.getLocations();\n            if (xl.length != yl.length) return false;\n            for (int i = 0; i < xl.length; i++)\n                if (!xl[i].getURL().equals(yl[i].getURL())) return false;\n            return true;\n        }\n\n        /**\n         * Creates {@link ISVNAuthenticationProvider} backed by {@link #credentials}.\n         * This method must be invoked on the master, but the returned object is remotable.\n         *\n         * <p>\n         * Therefore, to access {@link ISVNAuthenticationProvider}, you need to call this method\n         * on the master, then pass the object to the slave side, then call\n         * {@link SubversionSCM#createSvnClientManager(ISVNAuthenticationProvider)} on the slave.\n         *\n         * @see SubversionSCM#createSvnClientManager(ISVNAuthenticationProvider)\n         */\n        public ISVNAuthenticationProvider createAuthenticationProvider(AbstractProject<?,?> inContextOf) {\n            return new SVNAuthenticationProviderImpl(\n                    inContextOf==null ? null : new PerJobCredentialStore(inContextOf),remotableProvider);\n        }\n\n        /**\n         * @deprecated as of 1.18\n         *      Now that Hudson allows different credentials to be given in different jobs,\n         *      The caller should use {@link #createAuthenticationProvider(AbstractProject)} to indicate\n         *      the project in which the subversion operation is performed.\n         */\n        public ISVNAuthenticationProvider createAuthenticationProvider() {\n            return new SVNAuthenticationProviderImpl(null,remotableProvider);\n        }\n\n        /**\n         * Submits the authentication info.\n         */\n        // TODO: stapler should do multipart/form-data handling \n        public void doPostCredential(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n            Hudson.getInstance().checkPermission(Item.CONFIGURE);\n            \n            MultipartFormDataParser parser = new MultipartFormDataParser(req);\n\n            // we'll record what credential we are trying here.\n            StringWriter log = new StringWriter();\n            PrintWriter logWriter = new PrintWriter(log);\n\n            UserProvidedCredential upc = UserProvidedCredential.fromForm(req,parser);\n\n            try {\n                postCredential(parser.get(\"url\"), upc, logWriter);\n                rsp.sendRedirect(\"credentialOK\");\n            } catch (SVNException e) {\n                logWriter.println(\"FAILED: \"+e.getErrorMessage());\n                req.setAttribute(\"message\",log.toString());\n                req.setAttribute(\"pre\",true);\n                req.setAttribute(\"exception\",e);\n                rsp.forward(Hudson.getInstance(),\"error\",req);\n            } finally {\n                upc.close();\n            }\n        }\n\n        /**\n         * @deprecated as of 1.18\n         *      Use {@link #postCredential(AbstractProject, String, String, String, File, PrintWriter)}\n         */\n        public void postCredential(String url, String username, String password, File keyFile, PrintWriter logWriter) throws SVNException, IOException {\n            postCredential(null,url,username,password,keyFile,logWriter);\n        }\n\n        public void postCredential(AbstractProject inContextOf, String url, String username, String password, File keyFile, PrintWriter logWriter) throws SVNException, IOException {\n            postCredential(url,new UserProvidedCredential(username,password,keyFile,inContextOf),logWriter);\n        }\n\n        /**\n         * Submits the authentication info.\n         *\n         * This code is fairly ugly because of the way SVNKit handles credentials.\n         */\n        public void postCredential(String url, final UserProvidedCredential upc, PrintWriter logWriter) throws SVNException, IOException {\n            SVNRepository repository = null;\n\n            try {\n                // the way it works with SVNKit is that\n                // 1) svnkit calls AuthenticationManager asking for a credential.\n                //    this is when we can see the 'realm', which identifies the user domain.\n                // 2) DefaultSVNAuthenticationManager returns the username and password we set below\n                // 3) if the authentication is successful, svnkit calls back acknowledgeAuthentication\n                //    (so we store the password info here)\n                repository = SVNRepositoryFactory.create(SVNURL.parseURIDecoded(url));\n                repository.setTunnelProvider( createDefaultSVNOptions() );\n                AuthenticationManagerImpl authManager = upc.new AuthenticationManagerImpl(logWriter) {\n                    @Override\n                    protected void onSuccess(String realm, Credential cred) {\n                        LOGGER.info(\"Persisted \"+cred+\" for \"+realm);\n                        credentials.put(realm, cred);\n                        save();\n                        if (upc.inContextOf!=null)\n                            new PerJobCredentialStore(upc.inContextOf).acknowledgeAuthentication(realm,cred);\n\n                    }\n                };\n                authManager.setAuthenticationForced(true);\n                repository.setAuthenticationManager(authManager);\n                repository.testConnection();\n                authManager.checkIfProtocolCompleted();\n            } finally {\n                if (repository != null)\n                    repository.closeSession();\n            }\n        }\n\n        /**\n         * validate the value for a remote (repository) location.\n         */\n        public FormValidation doCheckRemote(StaplerRequest req, @AncestorInPath AbstractProject context, @QueryParameter String value) {\n            // syntax check first\n            String url = Util.fixEmptyAndTrim(value);\n            if (url == null)\n                return FormValidation.error(Messages.SubversionSCM_doCheckRemote_required()); \n\n            if(isValidateRemoteUpToVar()) {\n                url = (url.indexOf('$') != -1) ? url.substring(0, url.indexOf('$')) : url;\n            } else {\n                url = new EnvVars(EnvVars.masterEnvVars).expand(url);\n            }\n\n            if(!URL_PATTERN.matcher(url).matches())\n                return FormValidation.errorWithMarkup(\n                    Messages.SubversionSCM_doCheckRemote_invalidUrl());\n\n            // Test the connection only if we have job cuonfigure permission\n            if (!Hudson.getInstance().hasPermission(Item.CONFIGURE))\n                return FormValidation.ok();\n\n            try {\n                String urlWithoutRevision = SvnHelper.getUrlWithoutRevision(url);\n            \t\n                SVNURL repoURL = SVNURL.parseURIDecoded(urlWithoutRevision);\n                if (checkRepositoryPath(context,repoURL)!=SVNNodeKind.NONE) {\n                    // something exists; now check revision if any\n                    \n                    SVNRevision revision = getRevisionFromRemoteUrl(url);\n                    if (revision != null && !revision.isValid()) {\n                        return FormValidation.errorWithMarkup(Messages.SubversionSCM_doCheckRemote_invalidRevision());\n                    }\n                    \n                    return FormValidation.ok();\n                }\n                \n                SVNRepository repository = null;\n                try {\n                    repository = getRepository(context,repoURL);\n                    long rev = repository.getLatestRevision();\n                    // now go back the tree and find if there's anything that exists\n                    String repoPath = getRelativePath(repoURL, repository);\n                    String p = repoPath;\n                    while(p.length()>0) {\n                        p = SVNPathUtil.removeTail(p);\n                        if(repository.checkPath(p,rev)==SVNNodeKind.DIR) {\n                            // found a matching path\n                            List<SVNDirEntry> entries = new ArrayList<SVNDirEntry>();\n                            repository.getDir(p,rev,false,entries);\n\n                            // build up the name list\n                            List<String> paths = new ArrayList<String>();\n                            for (SVNDirEntry e : entries)\n                                if(e.getKind()==SVNNodeKind.DIR)\n                                    paths.add(e.getName());\n\n                            String head = SVNPathUtil.head(repoPath.substring(p.length() + 1));\n                            String candidate = EditDistance.findNearest(head,paths);\n\n                            return FormValidation.error(\n                                Messages.SubversionSCM_doCheckRemote_badPathSuggest(p, head,\n                                    candidate != null ? \"/\" + candidate : \"\"));\n                        }\n                    }\n\n                    return FormValidation.error(\n                        Messages.SubversionSCM_doCheckRemote_badPath(repoPath));\n                } finally {\n                    if (repository != null)\n                        repository.closeSession();\n                }\n            } catch (SVNException e) {\n                LOGGER.log(Level.INFO, \"Failed to access subversion repository \"+url,e);\n                String message = Messages.SubversionSCM_doCheckRemote_exceptionMsg1(\n                    Util.escape(url), Util.escape(e.getErrorMessage().getFullMessage()),\n                    \"javascript:document.getElementById('svnerror').style.display='block';\"\n                      + \"document.getElementById('svnerrorlink').style.display='none';\"\n                      + \"return false;\")\n                  + \"<br/><pre id=\\\"svnerror\\\" style=\\\"display:none\\\">\"\n                  + Functions.printThrowable(e) + \"</pre>\"\n                  + Messages.SubversionSCM_doCheckRemote_exceptionMsg2(\n                      \"descriptorByName/\"+SubversionSCM.class.getName()+\"/enterCredential?\" + url);\n                return FormValidation.errorWithMarkup(message);\n            }\n        }\n\n        public SVNNodeKind checkRepositoryPath(AbstractProject context, SVNURL repoURL) throws SVNException {\n            SVNRepository repository = null;\n\n            try {\n                repository = getRepository(context,repoURL);\n                repository.testConnection();\n\n                long rev = repository.getLatestRevision();\n                String repoPath = getRelativePath(repoURL, repository);\n                return repository.checkPath(repoPath, rev);\n            } finally {\n                if (repository != null)\n                    repository.closeSession();\n            }\n        }\n\n        protected SVNRepository getRepository(AbstractProject context, SVNURL repoURL) throws SVNException {\n            SVNRepository repository = SVNRepositoryFactory.create(repoURL);\n\n            ISVNAuthenticationManager sam = createSvnAuthenticationManager(createAuthenticationProvider(context));\n            sam = new FilterSVNAuthenticationManager(sam) {\n                // If there's no time out, the blocking read operation may hang forever, because TCP itself\n                // has no timeout. So always use some time out. If the underlying implementation gives us some\n                // value (which may come from ~/.subversion), honor that, as long as it sets some timeout value.\n                @Override\n                public int getReadTimeout(SVNRepository repository) {\n                    int r = super.getReadTimeout(repository);\n                    if(r<=0)    r = DEFAULT_TIMEOUT;\n                    return r;\n                }\n            };\n            repository.setTunnelProvider(createDefaultSVNOptions());\n            repository.setAuthenticationManager(sam);\n\n            return repository;\n        }\n        \n        public static String getRelativePath(SVNURL repoURL, SVNRepository repository) throws SVNException {\n            String repoPath = repoURL.getPath().substring(repository.getRepositoryRoot(false).getPath().length());\n            if(!repoPath.startsWith(\"/\"))    repoPath=\"/\"+repoPath;\n            return repoPath;\n        }\n\n        /**\n         * validate the value for a local location (local checkout directory).\n         */\n        public FormValidation doCheckLocal(@QueryParameter String value) throws IOException, ServletException {\n            String v = Util.nullify(value);\n            if (v == null)\n                // local directory is optional so this is ok\n                return FormValidation.ok();\n\n            v = v.trim();\n\n            // check if a absolute path has been supplied\n            // (the last check with the regex will match windows drives)\n            if (v.startsWith(\"/\") || v.startsWith(\"\\\\\") || v.startsWith(\"..\") || v.matches(\"^[A-Za-z]:.*\"))\n                return FormValidation.error(\"absolute path is not allowed\");\n\n            // all tests passed so far\n            return FormValidation.ok();\n        }\n\n        /**\n         * Validates the excludeRegions Regex\n         */\n        public FormValidation doCheckExcludedRegions(@QueryParameter String value) throws IOException, ServletException {\n            for (String region : Util.fixNull(value).trim().split(\"[\\\\r\\\\n]+\"))\n                try {\n                    Pattern.compile(region);\n                } catch (PatternSyntaxException e) {\n                    return FormValidation.error(\"Invalid regular expression. \" + e.getMessage());\n                }\n            return FormValidation.ok();\n        }\n\n        /**\n         * Validates the includedRegions Regex\n         */\n        public FormValidation doCheckIncludedRegions(@QueryParameter String value) throws IOException, ServletException {\n            return  doCheckExcludedRegions(value);\n        }\n\n        /**\n         * Regular expression for matching one username. Matches 'windows' names ('DOMAIN&#92;user') and\n         * 'normal' names ('user'). Where user (and DOMAIN) has one or more characters in 'a-zA-Z_0-9')\n         */\n        private static final Pattern USERNAME_PATTERN = Pattern.compile(\"(\\\\w+\\\\\\\\)?+(\\\\w+)\");\n\n        /**\n         * Validates the excludeUsers field\n         */\n        public FormValidation doCheckExcludedUsers(@QueryParameter String value) throws IOException, ServletException {\n            for (String user : Util.fixNull(value).trim().split(\"[\\\\r\\\\n]+\")) {\n                user = user.trim();\n\n                if (\"\".equals(user)) {\n                    continue;\n                }\n\n                if (!USERNAME_PATTERN.matcher(user).matches()) {\n                    return FormValidation.error(\"Invalid username: \" + user);\n                }\n            }\n\n            return FormValidation.ok();\n        }\n\n        public List<WorkspaceUpdaterDescriptor> getWorkspaceUpdaterDescriptors() {\n            return WorkspaceUpdaterDescriptor.all();\n        }\n\n        /**\n         * Validates the excludeCommitMessages field\n         */\n        public FormValidation doCheckExcludedCommitMessages(@QueryParameter String value) throws IOException, ServletException {\n            for (String message : Util.fixNull(value).trim().split(\"[\\\\r\\\\n]+\")) {\n                try {\n                    Pattern.compile(message);\n                } catch (PatternSyntaxException e) {\n                    return FormValidation.error(\"Invalid regular expression. \" + e.getMessage());\n                }\n            }\n            return FormValidation.ok();\n        }\n\n        /**\n         * Validates the remote server supports custom revision properties\n         */\n        public FormValidation doCheckRevisionPropertiesSupported(@AncestorInPath AbstractProject context, @QueryParameter String value) throws IOException, ServletException {\n            String v = Util.fixNull(value).trim();\n            if (v.length() == 0)\n                return FormValidation.ok();\n\n            // Test the connection only if we have admin permission\n            if (!Hudson.getInstance().hasPermission(Hudson.ADMINISTER))\n                return FormValidation.ok();\n\n            try {\n                SVNURL repoURL = SVNURL.parseURIDecoded(new EnvVars(EnvVars.masterEnvVars).expand(v));\n                if (checkRepositoryPath(context,repoURL)!=SVNNodeKind.NONE)\n                    // something exists\n                    return FormValidation.ok();\n\n                SVNRepository repository = null;\n                try {\n                    repository = getRepository(context,repoURL);\n                    if (repository.hasCapability(SVNCapability.LOG_REVPROPS))\n                        return FormValidation.ok();\n                } finally {\n                    if (repository != null)\n                        repository.closeSession();\n                }\n            } catch (SVNException e) {\n                String message=\"\";\n                message += \"Unable to access \"+Util.escape(v)+\" : \"+Util.escape( e.getErrorMessage().getFullMessage());\n                LOGGER.log(Level.INFO, \"Failed to access subversion repository \"+v,e);\n                return FormValidation.errorWithMarkup(message);\n            }\n\n            return FormValidation.warning(Messages.SubversionSCM_excludedRevprop_notSupported(v));\n        }\n        \n        static {\n            new Initializer();\n        }\n\n    }\n\n    /**\n     * @deprecated 1.34\n     */\n    public boolean repositoryLocationsNoLongerExist(AbstractBuild<?,?> build, TaskListener listener) {\n        return repositoryLocationsNoLongerExist(build, listener, null);\n    }\n    \n    /**\n     * @since 1.34\n     */\n    public boolean repositoryLocationsNoLongerExist(AbstractBuild<?,?> build, TaskListener listener, EnvVars env) {\n        PrintStream out = listener.getLogger();\n\n        for (ModuleLocation l : getLocations(env, build))\n            try {\n                if (getDescriptor().checkRepositoryPath(build.getProject(), l.getSVNURL()) == SVNNodeKind.NONE) {\n                    out.println(\"Location '\" + l.remote + \"' does not exist\");\n\n                    ParametersAction params = build.getAction(ParametersAction.class);\n                    if (params != null) {\n                        // since this is used to disable projects, be conservative\n                        LOGGER.fine(\"Location could be expanded on build '\" + build\n                                + \"' parameters values:\");\n                        return false;\n                    }\n                    return true;\n                }\n            } catch (SVNException e) {\n                // be conservative, since we are just trying to be helpful in detecting\n                // non existent locations. If we can't detect that, we'll do nothing\n                LOGGER.log(FINE, \"Location check failed\",e);\n            }\n        return false;\n    }\n\n    static final Pattern URL_PATTERN = Pattern.compile(\"(https?|svn(\\\\+[a-z0-9]+)?|file)://.+\");\n\n    private static final long serialVersionUID = 1L;\n\n    // noop, but this forces the initializer to run.\n    public static void init() {}\n\n    static {\n        new Initializer();\n    }\n\n    private static final class Initializer {\n        static {\n            if(Boolean.getBoolean(\"hudson.spool-svn\"))\n                DAVRepositoryFactory.setup(new DefaultHTTPConnectionFactory(null,true,null));\n            else\n                DAVRepositoryFactory.setup();   // http, https\n            SVNRepositoryFactoryImpl.setup();   // svn, svn+xxx\n            FSRepositoryFactory.setup();    // file\n\n            // disable the connection pooling, which causes problems like\n            // http://www.nabble.com/SSH-connection-problems-p12028339.html\n            if(System.getProperty(\"svnkit.ssh2.persistent\")==null)\n                System.setProperty(\"svnkit.ssh2.persistent\",\"false\");\n\n            // push Negotiate to the end because it requires a valid Kerberos configuration.\n            // see HUDSON-8153\n            if(System.getProperty(\"svnkit.http.methods\")==null)\n                System.setProperty(\"svnkit.http.methods\",\"Digest,Basic,NTLM,Negotiate\");\n\n            // use SVN1.4 compatible workspace by default.\n            SVNAdminAreaFactory.setSelector(new SubversionWorkspaceSelector());\n        }\n    }\n\n    /**\n     * small structure to store local and remote (repository) location\n     * information of the repository. As a addition it holds the invalid field\n     * to make failure messages when doing a checkout possible\n     */\n    @ExportedBean\n    public static final class ModuleLocation implements Serializable {\n        /**\n         * Subversion URL to check out.\n         *\n         * This may include \"@NNN\" at the end to indicate a fixed revision.\n         */\n        @Exported\n        public final String remote;\n\n        /**\n         * Remembers the user-given value.\n         * Can be null.\n         *\n         * @deprecated\n         *      Code should use {@link #getLocalDir()}. This field is only intended for form binding.\n         */\n        @Exported\n        public final String local;\n\n        /**\n         * Subversion remote depth. Used as \"--depth\" option for checkout and update commands.\n         * Default value is \"infinity\".\n         */\n        @Exported\n        public final String depthOption;\n\n        /**\n         * Flag to ignore subversion externals definitions.\n         */\n        @Exported\n        public boolean ignoreExternalsOption;\n\n        /**\n         * Cache of the repository UUID.\n         */\n        private transient volatile UUID repositoryUUID;\n        private transient volatile SVNURL repositoryRoot;\n\n        /**\n         * Constructor to support backwards compatibility.\n         */\n        public ModuleLocation(String remote, String local) {\n            this(remote, local, null, false);\n        }\n\n        @DataBoundConstructor\n        public ModuleLocation(String remote, String local, String depthOption, boolean ignoreExternalsOption) {\n            this.remote = Util.removeTrailingSlash(Util.fixNull(remote).trim());\n            this.local = fixEmptyAndTrim(local);\n            this.depthOption = StringUtils.isEmpty(depthOption) ? SVNDepth.INFINITY.getName() : depthOption;\n            this.ignoreExternalsOption = ignoreExternalsOption;\n        }\n\n        /**\n         * Local directory to place the file to.\n         * Relative to the workspace root.\n         */\n        public String getLocalDir() {\n            if(local==null) \n                return getLastPathComponent(getURL());\n            return local;\n        }\n\n        /**\n         * Returns the pure URL portion of {@link #remote} by removing\n         * possible \"@NNN\" suffix.\n         */\n        public String getURL() {\n        \treturn SvnHelper.getUrlWithoutRevision(remote);\n        }\n\n        /**\n         * Gets {@link #remote} as {@link SVNURL}.\n         */\n        public SVNURL getSVNURL() throws SVNException {\n            return SVNURL.parseURIEncoded(getURL());\n        }\n\n        /**\n         * Repository UUID. Lazy computed and cached.\n         */\n        public UUID getUUID(AbstractProject context) throws SVNException {\n            if(repositoryUUID==null || repositoryRoot==null) {\n                synchronized (this) {\n                    SVNRepository r = openRepository(context);\n                    r.testConnection(); // make sure values are fetched\n                    repositoryUUID = UUID.fromString(r.getRepositoryUUID(false));\n                    repositoryRoot = r.getRepositoryRoot(false);\n                }\n            }\n            return repositoryUUID;\n        }\n\n        public SVNRepository openRepository(AbstractProject context) throws SVNException {\n            return Hudson.getInstance().getDescriptorByType(DescriptorImpl.class).getRepository(context,getSVNURL());\n        }\n\n        public SVNURL getRepositoryRoot(AbstractProject context) throws SVNException {\n            getUUID(context);\n            return repositoryRoot;\n        }\n\n        /**\n         * Figures out which revision to check out.\n         *\n         * If {@link #remote} is {@code url@rev}, then this method\n         * returns that specific revision.\n         *\n         * @param defaultValue\n         *      If \"@NNN\" portion is not in the URL, this value will be returned.\n         *      Normally, this is the SVN revision timestamped at the build date.\n         */\n        public SVNRevision getRevision(SVNRevision defaultValue) {\n            SVNRevision revision = getRevisionFromRemoteUrl(remote);\n            return revision != null ? revision : defaultValue;\n        }\n\n        /**\n         * Returns the value of remote depth option.\n         *\n         * @return the value of remote depth option.\n         */\n        public String getDepthOption() {\n            return depthOption;\n        }\n\n        /**\n         * Determines if subversion externals definitions should be ignored.\n         *\n         * @return true if subversion externals definitions should be ignored.\n         */\n        public boolean isIgnoreExternalsOption() {\n            return ignoreExternalsOption;\n        }\n\n        /**\n         * Expand location value based on Build parametric execution.\n         *\n         * @param build Build instance for expanding parameters into their values\n         * @return Output ModuleLocation expanded according to Build parameters values.\n         * @deprecated Use {@link #getExpandedLocation(EnvVars)} for vars expansion\n         *             to be performed on all env vars rather than just build parameters.\n         */\n        public ModuleLocation getExpandedLocation(AbstractBuild<?, ?> build) {\n            EnvVars env = new EnvVars(EnvVars.masterEnvVars);\n            env.putAll(build.getBuildVariables());\n            return getExpandedLocation(env);\n        }\n        \n        /**\n         * Expand location value based on environment variables.\n         *\n         * @return Output ModuleLocation expanded according to specified env vars.\n         */\n        public ModuleLocation getExpandedLocation(EnvVars env) {\n            return new ModuleLocation(env.expand(remote), env.expand(getLocalDir()), getDepthOption(), isIgnoreExternalsOption());\n        }\n\n        @Override\n        public String toString() {\n            return remote;\n        }\n\n        private static final long serialVersionUID = 1L;\n\n        public static List<ModuleLocation> parse(String[] remoteLocations, String[] localLocations, String[] depthOptions, boolean[] isIgnoreExternals) {\n            List<ModuleLocation> modules = new ArrayList<ModuleLocation>();\n            if (remoteLocations != null && localLocations != null) {\n                int entries = Math.min(remoteLocations.length, localLocations.length);\n\n                for (int i = 0; i < entries; i++) {\n                    // the remote (repository) location\n                    String remoteLoc = Util.nullify(remoteLocations[i]);\n\n                    if (remoteLoc != null) {// null if skipped\n                        remoteLoc = Util.removeTrailingSlash(remoteLoc.trim());\n                        modules.add(new ModuleLocation(remoteLoc, Util.nullify(localLocations[i]),\n                            depthOptions != null ? depthOptions[i] : null,\n                            isIgnoreExternals != null && isIgnoreExternals[i]));\n                    }\n                }\n            }\n            return modules;\n        }\n    }\n\n    private static final Logger LOGGER = Logger.getLogger(SubversionSCM.class.getName());\n\n    /**\n     * Network timeout in milliseconds.\n     * The main point of this is to prevent infinite hang, so it should be a rather long value to avoid\n     * accidental time out problem.\n     */\n    public static int DEFAULT_TIMEOUT = Integer.getInteger(SubversionSCM.class.getName()+\".timeout\",3600*1000);\n\n    /**\n     * Property to control whether SCM polling happens from the slave or master\n     */\n    private static boolean POLL_FROM_MASTER = Boolean.getBoolean(SubversionSCM.class.getName()+\".pollFromMaster\");\n\n    /**\n     * If set to non-null, read configuration from this directory instead of \"~/.subversion\".\n     */\n    public static String CONFIG_DIR = System.getProperty(SubversionSCM.class.getName()+\".configDir\");\n    \n    /**\n     * Enables trace logging of Ganymed SSH library.\n     * <p>\n     * Intended to be invoked from Groovy console.\n     */\n    public static void enableSshDebug(Level level) {\n        if(level==null)     level= Level.FINEST; // default\n\n        final Level lv = level;\n\n        com.trilead.ssh2.log.Logger.enabled=true;\n        com.trilead.ssh2.log.Logger.logger = new DebugLogger() {\n            private final Logger LOGGER = Logger.getLogger(SCPClient.class.getPackage().getName());\n            public void log(int level, String className, String message) {\n                LOGGER.log(lv,className+' '+message);\n            }\n        };\n    }\n\n    /*package*/ static boolean compareSVNAuthentications(SVNAuthentication a1, SVNAuthentication a2) {\n        if (a1==null && a2==null)       return true;\n        if (a1==null || a2==null)       return false;\n        if (a1.getClass()!=a2.getClass())    return false;\n\n        try {\n            return describeBean(a1).equals(describeBean(a2));\n        } catch (IllegalAccessException e) {\n            return false;\n        } catch (InvocationTargetException e) {\n            return false;\n        } catch (NoSuchMethodException e) {\n            return false;\n        }\n    }\n\n    /**\n     * In preparation for a comparison, char[] needs to be converted that supports value equality.\n     */\n    @SuppressWarnings(\"unchecked\")\n    private static Map describeBean(Object o) throws InvocationTargetException, NoSuchMethodException, IllegalAccessException {\n        Map<?,?> m = PropertyUtils.describe(o);\n        for (Entry e : m.entrySet()) {\n            Object v = e.getValue();\n            if (v instanceof char[]) {\n                char[] chars = (char[]) v;\n                e.setValue(new String(chars));\n            }\n        }\n        return m;\n    }\n\n    /**\n     * Gets the revision from a remote URL - i.e. the part after '@' if any\n     * \n     * @return the revision or null\n     */\n    private static SVNRevision getRevisionFromRemoteUrl(\n            String remoteUrlPossiblyWithRevision) {\n        int idx = remoteUrlPossiblyWithRevision.lastIndexOf('@');\n        int slashIdx = remoteUrlPossiblyWithRevision.lastIndexOf('/');\n        if (idx > 0 && idx > slashIdx) {\n            String n = remoteUrlPossiblyWithRevision.substring(idx + 1);\n            return SVNRevision.parse(n);\n        }\n\n        return null;\n    }\n\n}\n"], "filenames": ["src/main/java/hudson/scm/SubversionSCM.java"], "buggy_code_start_loc": [1511], "buggy_code_end_loc": [1652], "fixing_code_start_loc": [1511], "fixing_code_end_loc": [1656], "type": "CWE-255", "message": "The Subversion plugin before 1.54 for Jenkins stores credentials using base64 encoding, which allows local users to obtain passwords and SSH private keys by reading a subversion.credentials file.", "other": {"cve": {"id": "CVE-2013-6372", "sourceIdentifier": "secalert@redhat.com", "published": "2014-05-08T14:29:11.940", "lastModified": "2023-02-13T04:49:31.833", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The Subversion plugin before 1.54 for Jenkins stores credentials using base64 encoding, which allows local users to obtain passwords and SSH private keys by reading a subversion.credentials file."}, {"lang": "es", "value": "El plugin Subversion anterior a 1.54 para Jenkins almacena credenciales utilizando codificaci\u00f3n base64, lo que permite a usuarios locales obtener contrase\u00f1as y claves privadas SSH mediante la lectura de un archivo subversion.credentials."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-255"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.53", "matchCriteriaId": "3A0C3967-1BE4-4EC0-802A-B98BAB066CAF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "DFC1BA0A-4F44-41CB-BE3D-86585343A996"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.1:*:*:*:*:*:*:*", "matchCriteriaId": "42130246-75B1-47A2-B712-1896519E0615"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.2:*:*:*:*:*:*:*", "matchCriteriaId": "ADB4F6BB-5C75-43FB-AAD6-948A499BE9D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.3:*:*:*:*:*:*:*", "matchCriteriaId": "93379312-B9F0-4CD6-8E75-6D21EDBA1494"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.4:*:*:*:*:*:*:*", "matchCriteriaId": "17A34AB1-C2CC-46B4-BD0A-847341D38412"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.5:*:*:*:*:*:*:*", "matchCriteriaId": "6C80B65A-FA53-4ACA-A1F6-61FAABA803F0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.6:*:*:*:*:*:*:*", "matchCriteriaId": "A28330AB-CC93-460D-B984-1D0F77BB2545"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.7:*:*:*:*:*:*:*", "matchCriteriaId": "C68E121B-9509-46D8-A6B1-B38AA5BADA58"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.8:*:*:*:*:*:*:*", "matchCriteriaId": "F2BDADED-2AE4-4833-8B72-033C2C09783E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.9:*:*:*:*:*:*:*", "matchCriteriaId": "2D7FF31F-0A0F-4925-9633-90E3E96EEC00"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.10:*:*:*:*:*:*:*", "matchCriteriaId": "6BC0D710-CDBF-45C3-AE8D-48E360A3B03E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.11:*:*:*:*:*:*:*", "matchCriteriaId": "B62C0E6E-F258-4E78-A37B-0AF45B73D239"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.12:*:*:*:*:*:*:*", "matchCriteriaId": "D6792C3D-80B6-40D4-B004-BF79A306BFBC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.13:*:*:*:*:*:*:*", "matchCriteriaId": "636C17AE-0147-4E82-843C-2974A0EF39C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.14:*:*:*:*:*:*:*", "matchCriteriaId": "C0FC4FDC-92DE-45C9-8027-B6C69A02DEB9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.15:*:*:*:*:*:*:*", "matchCriteriaId": "E470E8EB-A2D7-4986-8F68-D35FD4545BAC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.16:*:*:*:*:*:*:*", "matchCriteriaId": "C7AD55CE-BE53-40B8-B3D9-31767D4B336E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.17:*:*:*:*:*:*:*", "matchCriteriaId": "E91FAD18-0CA2-4B57-A879-870BBFD07A03"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.18:*:*:*:*:*:*:*", "matchCriteriaId": "07CB2DDF-2FD1-4715-8AEB-4E909012E193"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.19:*:*:*:*:*:*:*", "matchCriteriaId": "118D6413-7BDE-496A-8161-79C5A65288E8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.20:*:*:*:*:*:*:*", "matchCriteriaId": "03A6F19E-0825-43B4-B890-550EED3FB115"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.21:*:*:*:*:*:*:*", "matchCriteriaId": "B73C5933-58A7-4671-B134-DCFAFBA77AEC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.22:*:*:*:*:*:*:*", "matchCriteriaId": "12EC1524-3A67-4154-AAB6-49EC725F132F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.23:*:*:*:*:*:*:*", "matchCriteriaId": "33D3CC94-8466-497F-AEC2-039D4381D1B0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.24:*:*:*:*:*:*:*", "matchCriteriaId": "A56D5604-CBC6-4861-9254-25FC48947EAD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.25:*:*:*:*:*:*:*", "matchCriteriaId": "9F200895-2A69-44E4-9B74-63E1412FDD4D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.26:*:*:*:*:*:*:*", "matchCriteriaId": "8E2EE14E-147B-4FB2-904B-D0A68DE6F977"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.27:*:*:*:*:*:*:*", "matchCriteriaId": "83B2328A-AB2D-488C-957E-49E44C844F2D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.28:*:*:*:*:*:*:*", "matchCriteriaId": "A550AEFB-C037-4E81-B2B4-1439D25A3C35"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.29:*:*:*:*:*:*:*", "matchCriteriaId": "C503ABFA-363E-4A9A-B972-5FB343A99BD6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.30:*:*:*:*:*:*:*", "matchCriteriaId": "F5409FB8-67F2-4D4E-AEA3-C73063076F20"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.31:*:*:*:*:*:*:*", "matchCriteriaId": "CB9F89E5-5979-4E33-BD77-96E86CA7FE6B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.32:*:*:*:*:*:*:*", "matchCriteriaId": "76273F68-0A17-408E-92AF-E7314697A6C3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.33:*:*:*:*:*:*:*", "matchCriteriaId": "AD2EE5D6-2941-46CA-880B-AD0BA83F7D74"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.34:*:*:*:*:*:*:*", "matchCriteriaId": "3B7E6CDD-4D4F-465B-867A-D8B39D2785FB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.35:*:*:*:*:*:*:*", "matchCriteriaId": "200DD105-C201-4FCA-BA53-4206A1A4832D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.36:*:*:*:*:*:*:*", "matchCriteriaId": "49FE2921-48B3-4542-8103-9C33FADFEB22"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.37:*:*:*:*:*:*:*", "matchCriteriaId": "E4921E1A-FC86-47EC-BDDC-60E502C03B01"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.38:*:*:*:*:*:*:*", "matchCriteriaId": "A3739D57-F82D-4A91-8FE6-266ADBF1DE97"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.39:*:*:*:*:*:*:*", "matchCriteriaId": "796A7271-9C54-4E42-B447-29E4E16D21C2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.40:*:*:*:*:*:*:*", "matchCriteriaId": "D3D5A37E-CD16-4247-9312-54B6431869CA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.41:*:*:*:*:*:*:*", "matchCriteriaId": "EB8D20BE-9728-4683-A139-B731BEB58CAB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.42:*:*:*:*:*:*:*", "matchCriteriaId": "06787176-AF45-41D8-B6A6-B38DCCAD223C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.43:*:*:*:*:*:*:*", "matchCriteriaId": "8D5C620E-D15E-4E90-B8D5-C88105676DEA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.44:*:*:*:*:*:*:*", "matchCriteriaId": "D66176AA-0758-425E-AE20-BCBB6EDD5E27"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.45:*:*:*:*:*:*:*", "matchCriteriaId": "900F382D-20B0-4346-90AE-CFA44CBC9571"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.46:*:*:*:*:*:*:*", "matchCriteriaId": "63FEEF4B-BE5E-4C82-998A-D3CC50B903A7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.47:*:*:*:*:*:*:*", "matchCriteriaId": "C3DAA19C-49C9-45F8-8341-90FA703B154F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.48:*:*:*:*:*:*:*", "matchCriteriaId": "74879497-35C7-49C1-A6ED-8A9B759A2FC8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.49:*:*:*:*:*:*:*", "matchCriteriaId": "CBDC2FC4-A7E0-4843-A5E2-E266E66A1F64"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.50:*:*:*:*:*:*:*", "matchCriteriaId": "0E8C4807-C0A5-437E-A0E2-10A6768918E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.51:*:*:*:*:*:*:*", "matchCriteriaId": "074EB173-1F65-4203-90AA-0164C2C32E56"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins-ci:subversion-plugin:1.52:*:*:*:*:*:*:*", "matchCriteriaId": "60F81CAB-203F-4625-833A-46302CBCE2F5"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1032391", "source": "secalert@redhat.com"}, {"url": "https://github.com/jenkinsci/subversion-plugin/commit/7d4562d6f7e40de04bbe29577b51c79f07d05ba6", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}, {"url": "https://wiki.jenkins-ci.org/display/SECURITY/Jenkins+Security+Advisory+2013-11-20", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/jenkinsci/subversion-plugin/commit/7d4562d6f7e40de04bbe29577b51c79f07d05ba6"}}