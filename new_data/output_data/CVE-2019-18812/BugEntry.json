{"buggy_code": ["// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)\n//\n// This file is provided under a dual BSD/GPLv2 license.  When using or\n// redistributing this file, you may do so under either license.\n//\n// Copyright(c) 2018 Intel Corporation. All rights reserved.\n//\n// Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>\n//\n// Generic debug routines used to export DSP MMIO and memories to userspace\n// for firmware debugging.\n//\n\n#include <linux/debugfs.h>\n#include <linux/io.h>\n#include <linux/pm_runtime.h>\n#include \"sof-priv.h\"\n#include \"ops.h\"\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST)\n#define MAX_IPC_FLOOD_DURATION_MS 1000\n#define MAX_IPC_FLOOD_COUNT 10000\n#define IPC_FLOOD_TEST_RESULT_LEN 512\n\nstatic int sof_debug_ipc_flood_test(struct snd_sof_dev *sdev,\n\t\t\t\t    struct snd_sof_dfsentry *dfse,\n\t\t\t\t    bool flood_duration_test,\n\t\t\t\t    unsigned long ipc_duration_ms,\n\t\t\t\t    unsigned long ipc_count)\n{\n\tstruct sof_ipc_cmd_hdr hdr;\n\tstruct sof_ipc_reply reply;\n\tu64 min_response_time = U64_MAX;\n\tktime_t start, end, test_end;\n\tu64 avg_response_time = 0;\n\tu64 max_response_time = 0;\n\tu64 ipc_response_time;\n\tint i = 0;\n\tint ret;\n\n\t/* configure test IPC */\n\thdr.cmd = SOF_IPC_GLB_TEST_MSG | SOF_IPC_TEST_IPC_FLOOD;\n\thdr.size = sizeof(hdr);\n\n\t/* set test end time for duration flood test */\n\tif (flood_duration_test)\n\t\ttest_end = ktime_get_ns() + ipc_duration_ms * NSEC_PER_MSEC;\n\n\t/* send test IPC's */\n\twhile (1) {\n\t\tstart = ktime_get();\n\t\tret = sof_ipc_tx_message(sdev->ipc, hdr.cmd, &hdr, hdr.size,\n\t\t\t\t\t &reply, sizeof(reply));\n\t\tend = ktime_get();\n\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\t/* compute min and max response times */\n\t\tipc_response_time = ktime_to_ns(ktime_sub(end, start));\n\t\tmin_response_time = min(min_response_time, ipc_response_time);\n\t\tmax_response_time = max(max_response_time, ipc_response_time);\n\n\t\t/* sum up response times */\n\t\tavg_response_time += ipc_response_time;\n\t\ti++;\n\n\t\t/* test complete? */\n\t\tif (flood_duration_test) {\n\t\t\tif (ktime_to_ns(end) >= test_end)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (i == ipc_count)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret < 0)\n\t\tdev_err(sdev->dev,\n\t\t\t\"error: ipc flood test failed at %d iterations\\n\", i);\n\n\t/* return if the first IPC fails */\n\tif (!i)\n\t\treturn ret;\n\n\t/* compute average response time */\n\tdo_div(avg_response_time, i);\n\n\t/* clear previous test output */\n\tmemset(dfse->cache_buf, 0, IPC_FLOOD_TEST_RESULT_LEN);\n\n\tif (flood_duration_test) {\n\t\tdev_dbg(sdev->dev, \"IPC Flood test duration: %lums\\n\",\n\t\t\tipc_duration_ms);\n\t\tsnprintf(dfse->cache_buf, IPC_FLOOD_TEST_RESULT_LEN,\n\t\t\t \"IPC Flood test duration: %lums\\n\", ipc_duration_ms);\n\t}\n\n\tdev_dbg(sdev->dev,\n\t\t\"IPC Flood count: %d, Avg response time: %lluns\\n\",\n\t\ti, avg_response_time);\n\tdev_dbg(sdev->dev, \"Max response time: %lluns\\n\",\n\t\tmax_response_time);\n\tdev_dbg(sdev->dev, \"Min response time: %lluns\\n\",\n\t\tmin_response_time);\n\n\t/* format output string */\n\tsnprintf(dfse->cache_buf + strlen(dfse->cache_buf),\n\t\t IPC_FLOOD_TEST_RESULT_LEN - strlen(dfse->cache_buf),\n\t\t \"IPC Flood count: %d\\nAvg response time: %lluns\\n\",\n\t\t i, avg_response_time);\n\n\tsnprintf(dfse->cache_buf + strlen(dfse->cache_buf),\n\t\t IPC_FLOOD_TEST_RESULT_LEN - strlen(dfse->cache_buf),\n\t\t \"Max response time: %lluns\\nMin response time: %lluns\\n\",\n\t\t max_response_time, min_response_time);\n\n\treturn ret;\n}\n#endif\n\nstatic ssize_t sof_dfsentry_write(struct file *file, const char __user *buffer,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST)\n\tstruct snd_sof_dfsentry *dfse = file->private_data;\n\tstruct snd_sof_dev *sdev = dfse->sdev;\n\tunsigned long ipc_duration_ms = 0;\n\tbool flood_duration_test = false;\n\tunsigned long ipc_count = 0;\n\tstruct dentry *dentry;\n\tint err;\n#endif\n\tsize_t size;\n\tchar *string;\n\tint ret;\n\n\tstring = kzalloc(count, GFP_KERNEL);\n\tif (!string)\n\t\treturn -ENOMEM;\n\n\tsize = simple_write_to_buffer(string, count, ppos, buffer, count);\n\tret = size;\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST)\n\t/*\n\t * write op is only supported for ipc_flood_count or\n\t * ipc_flood_duration_ms debugfs entries atm.\n\t * ipc_flood_count floods the DSP with the number of IPC's specified.\n\t * ipc_duration_ms test floods the DSP for the time specified\n\t * in the debugfs entry.\n\t */\n\tdentry = file->f_path.dentry;\n\tif (strcmp(dentry->d_name.name, \"ipc_flood_count\") &&\n\t    strcmp(dentry->d_name.name, \"ipc_flood_duration_ms\"))\n\t\treturn -EINVAL;\n\n\tif (!strcmp(dentry->d_name.name, \"ipc_flood_duration_ms\"))\n\t\tflood_duration_test = true;\n\n\t/* test completion criterion */\n\tif (flood_duration_test)\n\t\tret = kstrtoul(string, 0, &ipc_duration_ms);\n\telse\n\t\tret = kstrtoul(string, 0, &ipc_count);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* limit max duration/ipc count for flood test */\n\tif (flood_duration_test) {\n\t\tif (!ipc_duration_ms) {\n\t\t\tret = size;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* find the minimum. min() is not used to avoid warnings */\n\t\tif (ipc_duration_ms > MAX_IPC_FLOOD_DURATION_MS)\n\t\t\tipc_duration_ms = MAX_IPC_FLOOD_DURATION_MS;\n\t} else {\n\t\tif (!ipc_count) {\n\t\t\tret = size;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* find the minimum. min() is not used to avoid warnings */\n\t\tif (ipc_count > MAX_IPC_FLOOD_COUNT)\n\t\t\tipc_count = MAX_IPC_FLOOD_COUNT;\n\t}\n\n\tret = pm_runtime_get_sync(sdev->dev);\n\tif (ret < 0) {\n\t\tdev_err_ratelimited(sdev->dev,\n\t\t\t\t    \"error: debugfs write failed to resume %d\\n\",\n\t\t\t\t    ret);\n\t\tpm_runtime_put_noidle(sdev->dev);\n\t\tgoto out;\n\t}\n\n\t/* flood test */\n\tret = sof_debug_ipc_flood_test(sdev, dfse, flood_duration_test,\n\t\t\t\t       ipc_duration_ms, ipc_count);\n\n\tpm_runtime_mark_last_busy(sdev->dev);\n\terr = pm_runtime_put_autosuspend(sdev->dev);\n\tif (err < 0)\n\t\tdev_err_ratelimited(sdev->dev,\n\t\t\t\t    \"error: debugfs write failed to idle %d\\n\",\n\t\t\t\t    err);\n\n\t/* return size if test is successful */\n\tif (ret >= 0)\n\t\tret = size;\nout:\n#endif\n\tkfree(string);\n\treturn ret;\n}\n\nstatic ssize_t sof_dfsentry_read(struct file *file, char __user *buffer,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct snd_sof_dfsentry *dfse = file->private_data;\n\tstruct snd_sof_dev *sdev = dfse->sdev;\n\tloff_t pos = *ppos;\n\tsize_t size_ret;\n\tint skip = 0;\n\tint size;\n\tu8 *buf;\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST)\n\tstruct dentry *dentry;\n\n\tdentry = file->f_path.dentry;\n\tif ((!strcmp(dentry->d_name.name, \"ipc_flood_count\") ||\n\t     !strcmp(dentry->d_name.name, \"ipc_flood_duration_ms\")) &&\n\t    dfse->cache_buf) {\n\t\tif (*ppos)\n\t\t\treturn 0;\n\n\t\tcount = strlen(dfse->cache_buf);\n\t\tsize_ret = copy_to_user(buffer, dfse->cache_buf, count);\n\t\tif (size_ret)\n\t\t\treturn -EFAULT;\n\n\t\t*ppos += count;\n\t\treturn count;\n\t}\n#endif\n\tsize = dfse->size;\n\n\t/* validate position & count */\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= size || !count)\n\t\treturn 0;\n\t/* find the minimum. min() is not used since it adds sparse warnings */\n\tif (count > size - pos)\n\t\tcount = size - pos;\n\n\t/* align io read start to u32 multiple */\n\tpos = ALIGN_DOWN(pos, 4);\n\n\t/* intermediate buffer size must be u32 multiple */\n\tsize = ALIGN(count, 4);\n\n\t/* if start position is unaligned, read extra u32 */\n\tif (unlikely(pos != *ppos)) {\n\t\tskip = *ppos - pos;\n\t\tif (pos + size + 4 < dfse->size)\n\t\t\tsize += 4;\n\t}\n\n\tbuf = kzalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (dfse->type == SOF_DFSENTRY_TYPE_IOMEM) {\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_ENABLE_DEBUGFS_CACHE)\n\t\t/*\n\t\t * If the DSP is active: copy from IO.\n\t\t * If the DSP is suspended:\n\t\t *\t- Copy from IO if the memory is always accessible.\n\t\t *\t- Otherwise, copy from cached buffer.\n\t\t */\n\t\tif (pm_runtime_active(sdev->dev) ||\n\t\t    dfse->access_type == SOF_DEBUGFS_ACCESS_ALWAYS) {\n\t\t\tmemcpy_fromio(buf, dfse->io_mem + pos, size);\n\t\t} else {\n\t\t\tdev_info(sdev->dev,\n\t\t\t\t \"Copying cached debugfs data\\n\");\n\t\t\tmemcpy(buf, dfse->cache_buf + pos, size);\n\t\t}\n#else\n\t\t/* if the DSP is in D3 */\n\t\tif (!pm_runtime_active(sdev->dev) &&\n\t\t    dfse->access_type == SOF_DEBUGFS_ACCESS_D0_ONLY) {\n\t\t\tdev_err(sdev->dev,\n\t\t\t\t\"error: debugfs entry cannot be read in DSP D3\\n\");\n\t\t\tkfree(buf);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmemcpy_fromio(buf, dfse->io_mem + pos, size);\n#endif\n\t} else {\n\t\tmemcpy(buf, ((u8 *)(dfse->buf) + pos), size);\n\t}\n\n\t/* copy to userspace */\n\tsize_ret = copy_to_user(buffer, buf + skip, count);\n\n\tkfree(buf);\n\n\t/* update count & position if copy succeeded */\n\tif (size_ret)\n\t\treturn -EFAULT;\n\n\t*ppos = pos + count;\n\n\treturn count;\n}\n\nstatic const struct file_operations sof_dfs_fops = {\n\t.open = simple_open,\n\t.read = sof_dfsentry_read,\n\t.llseek = default_llseek,\n\t.write = sof_dfsentry_write,\n};\n\n/* create FS entry for debug files that can expose DSP memories, registers */\nint snd_sof_debugfs_io_item(struct snd_sof_dev *sdev,\n\t\t\t    void __iomem *base, size_t size,\n\t\t\t    const char *name,\n\t\t\t    enum sof_debugfs_access_type access_type)\n{\n\tstruct snd_sof_dfsentry *dfse;\n\n\tif (!sdev)\n\t\treturn -EINVAL;\n\n\tdfse = devm_kzalloc(sdev->dev, sizeof(*dfse), GFP_KERNEL);\n\tif (!dfse)\n\t\treturn -ENOMEM;\n\n\tdfse->type = SOF_DFSENTRY_TYPE_IOMEM;\n\tdfse->io_mem = base;\n\tdfse->size = size;\n\tdfse->sdev = sdev;\n\tdfse->access_type = access_type;\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_ENABLE_DEBUGFS_CACHE)\n\t/*\n\t * allocate cache buffer that will be used to save the mem window\n\t * contents prior to suspend\n\t */\n\tif (access_type == SOF_DEBUGFS_ACCESS_D0_ONLY) {\n\t\tdfse->cache_buf = devm_kzalloc(sdev->dev, size, GFP_KERNEL);\n\t\tif (!dfse->cache_buf)\n\t\t\treturn -ENOMEM;\n\t}\n#endif\n\n\tdebugfs_create_file(name, 0444, sdev->debugfs_root, dfse,\n\t\t\t    &sof_dfs_fops);\n\n\t/* add to dfsentry list */\n\tlist_add(&dfse->list, &sdev->dfsentry_list);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_sof_debugfs_io_item);\n\n/* create FS entry for debug files to expose kernel memory */\nint snd_sof_debugfs_buf_item(struct snd_sof_dev *sdev,\n\t\t\t     void *base, size_t size,\n\t\t\t     const char *name, mode_t mode)\n{\n\tstruct snd_sof_dfsentry *dfse;\n\n\tif (!sdev)\n\t\treturn -EINVAL;\n\n\tdfse = devm_kzalloc(sdev->dev, sizeof(*dfse), GFP_KERNEL);\n\tif (!dfse)\n\t\treturn -ENOMEM;\n\n\tdfse->type = SOF_DFSENTRY_TYPE_BUF;\n\tdfse->buf = base;\n\tdfse->size = size;\n\tdfse->sdev = sdev;\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST)\n\t/*\n\t * cache_buf is unused for SOF_DFSENTRY_TYPE_BUF debugfs entries.\n\t * So, use it to save the results of the last IPC flood test.\n\t */\n\tdfse->cache_buf = devm_kzalloc(sdev->dev, IPC_FLOOD_TEST_RESULT_LEN,\n\t\t\t\t       GFP_KERNEL);\n\tif (!dfse->cache_buf)\n\t\treturn -ENOMEM;\n#endif\n\n\tdebugfs_create_file(name, mode, sdev->debugfs_root, dfse,\n\t\t\t    &sof_dfs_fops);\n\t/* add to dfsentry list */\n\tlist_add(&dfse->list, &sdev->dfsentry_list);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_sof_debugfs_buf_item);\n\nint snd_sof_dbg_init(struct snd_sof_dev *sdev)\n{\n\tconst struct snd_sof_dsp_ops *ops = sof_ops(sdev);\n\tconst struct snd_sof_debugfs_map *map;\n\tint i;\n\tint err;\n\n\t/* use \"sof\" as top level debugFS dir */\n\tsdev->debugfs_root = debugfs_create_dir(\"sof\", NULL);\n\n\t/* init dfsentry list */\n\tINIT_LIST_HEAD(&sdev->dfsentry_list);\n\n\t/* create debugFS files for platform specific MMIO/DSP memories */\n\tfor (i = 0; i < ops->debug_map_count; i++) {\n\t\tmap = &ops->debug_map[i];\n\n\t\terr = snd_sof_debugfs_io_item(sdev, sdev->bar[map->bar] +\n\t\t\t\t\t      map->offset, map->size,\n\t\t\t\t\t      map->name, map->access_type);\n\t\t/* errors are only due to memory allocation, not debugfs */\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST)\n\t/* create read-write ipc_flood_count debugfs entry */\n\terr = snd_sof_debugfs_buf_item(sdev, NULL, 0,\n\t\t\t\t       \"ipc_flood_count\", 0666);\n\n\t/* errors are only due to memory allocation, not debugfs */\n\tif (err < 0)\n\t\treturn err;\n\n\t/* create read-write ipc_flood_duration_ms debugfs entry */\n\terr = snd_sof_debugfs_buf_item(sdev, NULL, 0,\n\t\t\t\t       \"ipc_flood_duration_ms\", 0666);\n\n\t/* errors are only due to memory allocation, not debugfs */\n\tif (err < 0)\n\t\treturn err;\n#endif\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_sof_dbg_init);\n\nvoid snd_sof_free_debug(struct snd_sof_dev *sdev)\n{\n\tdebugfs_remove_recursive(sdev->debugfs_root);\n}\nEXPORT_SYMBOL_GPL(snd_sof_free_debug);\n"], "fixing_code": ["// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)\n//\n// This file is provided under a dual BSD/GPLv2 license.  When using or\n// redistributing this file, you may do so under either license.\n//\n// Copyright(c) 2018 Intel Corporation. All rights reserved.\n//\n// Author: Liam Girdwood <liam.r.girdwood@linux.intel.com>\n//\n// Generic debug routines used to export DSP MMIO and memories to userspace\n// for firmware debugging.\n//\n\n#include <linux/debugfs.h>\n#include <linux/io.h>\n#include <linux/pm_runtime.h>\n#include \"sof-priv.h\"\n#include \"ops.h\"\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST)\n#define MAX_IPC_FLOOD_DURATION_MS 1000\n#define MAX_IPC_FLOOD_COUNT 10000\n#define IPC_FLOOD_TEST_RESULT_LEN 512\n\nstatic int sof_debug_ipc_flood_test(struct snd_sof_dev *sdev,\n\t\t\t\t    struct snd_sof_dfsentry *dfse,\n\t\t\t\t    bool flood_duration_test,\n\t\t\t\t    unsigned long ipc_duration_ms,\n\t\t\t\t    unsigned long ipc_count)\n{\n\tstruct sof_ipc_cmd_hdr hdr;\n\tstruct sof_ipc_reply reply;\n\tu64 min_response_time = U64_MAX;\n\tktime_t start, end, test_end;\n\tu64 avg_response_time = 0;\n\tu64 max_response_time = 0;\n\tu64 ipc_response_time;\n\tint i = 0;\n\tint ret;\n\n\t/* configure test IPC */\n\thdr.cmd = SOF_IPC_GLB_TEST_MSG | SOF_IPC_TEST_IPC_FLOOD;\n\thdr.size = sizeof(hdr);\n\n\t/* set test end time for duration flood test */\n\tif (flood_duration_test)\n\t\ttest_end = ktime_get_ns() + ipc_duration_ms * NSEC_PER_MSEC;\n\n\t/* send test IPC's */\n\twhile (1) {\n\t\tstart = ktime_get();\n\t\tret = sof_ipc_tx_message(sdev->ipc, hdr.cmd, &hdr, hdr.size,\n\t\t\t\t\t &reply, sizeof(reply));\n\t\tend = ktime_get();\n\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\t/* compute min and max response times */\n\t\tipc_response_time = ktime_to_ns(ktime_sub(end, start));\n\t\tmin_response_time = min(min_response_time, ipc_response_time);\n\t\tmax_response_time = max(max_response_time, ipc_response_time);\n\n\t\t/* sum up response times */\n\t\tavg_response_time += ipc_response_time;\n\t\ti++;\n\n\t\t/* test complete? */\n\t\tif (flood_duration_test) {\n\t\t\tif (ktime_to_ns(end) >= test_end)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (i == ipc_count)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret < 0)\n\t\tdev_err(sdev->dev,\n\t\t\t\"error: ipc flood test failed at %d iterations\\n\", i);\n\n\t/* return if the first IPC fails */\n\tif (!i)\n\t\treturn ret;\n\n\t/* compute average response time */\n\tdo_div(avg_response_time, i);\n\n\t/* clear previous test output */\n\tmemset(dfse->cache_buf, 0, IPC_FLOOD_TEST_RESULT_LEN);\n\n\tif (flood_duration_test) {\n\t\tdev_dbg(sdev->dev, \"IPC Flood test duration: %lums\\n\",\n\t\t\tipc_duration_ms);\n\t\tsnprintf(dfse->cache_buf, IPC_FLOOD_TEST_RESULT_LEN,\n\t\t\t \"IPC Flood test duration: %lums\\n\", ipc_duration_ms);\n\t}\n\n\tdev_dbg(sdev->dev,\n\t\t\"IPC Flood count: %d, Avg response time: %lluns\\n\",\n\t\ti, avg_response_time);\n\tdev_dbg(sdev->dev, \"Max response time: %lluns\\n\",\n\t\tmax_response_time);\n\tdev_dbg(sdev->dev, \"Min response time: %lluns\\n\",\n\t\tmin_response_time);\n\n\t/* format output string */\n\tsnprintf(dfse->cache_buf + strlen(dfse->cache_buf),\n\t\t IPC_FLOOD_TEST_RESULT_LEN - strlen(dfse->cache_buf),\n\t\t \"IPC Flood count: %d\\nAvg response time: %lluns\\n\",\n\t\t i, avg_response_time);\n\n\tsnprintf(dfse->cache_buf + strlen(dfse->cache_buf),\n\t\t IPC_FLOOD_TEST_RESULT_LEN - strlen(dfse->cache_buf),\n\t\t \"Max response time: %lluns\\nMin response time: %lluns\\n\",\n\t\t max_response_time, min_response_time);\n\n\treturn ret;\n}\n#endif\n\nstatic ssize_t sof_dfsentry_write(struct file *file, const char __user *buffer,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST)\n\tstruct snd_sof_dfsentry *dfse = file->private_data;\n\tstruct snd_sof_dev *sdev = dfse->sdev;\n\tunsigned long ipc_duration_ms = 0;\n\tbool flood_duration_test = false;\n\tunsigned long ipc_count = 0;\n\tstruct dentry *dentry;\n\tint err;\n#endif\n\tsize_t size;\n\tchar *string;\n\tint ret;\n\n\tstring = kzalloc(count, GFP_KERNEL);\n\tif (!string)\n\t\treturn -ENOMEM;\n\n\tsize = simple_write_to_buffer(string, count, ppos, buffer, count);\n\tret = size;\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST)\n\t/*\n\t * write op is only supported for ipc_flood_count or\n\t * ipc_flood_duration_ms debugfs entries atm.\n\t * ipc_flood_count floods the DSP with the number of IPC's specified.\n\t * ipc_duration_ms test floods the DSP for the time specified\n\t * in the debugfs entry.\n\t */\n\tdentry = file->f_path.dentry;\n\tif (strcmp(dentry->d_name.name, \"ipc_flood_count\") &&\n\t    strcmp(dentry->d_name.name, \"ipc_flood_duration_ms\")) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!strcmp(dentry->d_name.name, \"ipc_flood_duration_ms\"))\n\t\tflood_duration_test = true;\n\n\t/* test completion criterion */\n\tif (flood_duration_test)\n\t\tret = kstrtoul(string, 0, &ipc_duration_ms);\n\telse\n\t\tret = kstrtoul(string, 0, &ipc_count);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* limit max duration/ipc count for flood test */\n\tif (flood_duration_test) {\n\t\tif (!ipc_duration_ms) {\n\t\t\tret = size;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* find the minimum. min() is not used to avoid warnings */\n\t\tif (ipc_duration_ms > MAX_IPC_FLOOD_DURATION_MS)\n\t\t\tipc_duration_ms = MAX_IPC_FLOOD_DURATION_MS;\n\t} else {\n\t\tif (!ipc_count) {\n\t\t\tret = size;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* find the minimum. min() is not used to avoid warnings */\n\t\tif (ipc_count > MAX_IPC_FLOOD_COUNT)\n\t\t\tipc_count = MAX_IPC_FLOOD_COUNT;\n\t}\n\n\tret = pm_runtime_get_sync(sdev->dev);\n\tif (ret < 0) {\n\t\tdev_err_ratelimited(sdev->dev,\n\t\t\t\t    \"error: debugfs write failed to resume %d\\n\",\n\t\t\t\t    ret);\n\t\tpm_runtime_put_noidle(sdev->dev);\n\t\tgoto out;\n\t}\n\n\t/* flood test */\n\tret = sof_debug_ipc_flood_test(sdev, dfse, flood_duration_test,\n\t\t\t\t       ipc_duration_ms, ipc_count);\n\n\tpm_runtime_mark_last_busy(sdev->dev);\n\terr = pm_runtime_put_autosuspend(sdev->dev);\n\tif (err < 0)\n\t\tdev_err_ratelimited(sdev->dev,\n\t\t\t\t    \"error: debugfs write failed to idle %d\\n\",\n\t\t\t\t    err);\n\n\t/* return size if test is successful */\n\tif (ret >= 0)\n\t\tret = size;\nout:\n#endif\n\tkfree(string);\n\treturn ret;\n}\n\nstatic ssize_t sof_dfsentry_read(struct file *file, char __user *buffer,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct snd_sof_dfsentry *dfse = file->private_data;\n\tstruct snd_sof_dev *sdev = dfse->sdev;\n\tloff_t pos = *ppos;\n\tsize_t size_ret;\n\tint skip = 0;\n\tint size;\n\tu8 *buf;\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST)\n\tstruct dentry *dentry;\n\n\tdentry = file->f_path.dentry;\n\tif ((!strcmp(dentry->d_name.name, \"ipc_flood_count\") ||\n\t     !strcmp(dentry->d_name.name, \"ipc_flood_duration_ms\")) &&\n\t    dfse->cache_buf) {\n\t\tif (*ppos)\n\t\t\treturn 0;\n\n\t\tcount = strlen(dfse->cache_buf);\n\t\tsize_ret = copy_to_user(buffer, dfse->cache_buf, count);\n\t\tif (size_ret)\n\t\t\treturn -EFAULT;\n\n\t\t*ppos += count;\n\t\treturn count;\n\t}\n#endif\n\tsize = dfse->size;\n\n\t/* validate position & count */\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= size || !count)\n\t\treturn 0;\n\t/* find the minimum. min() is not used since it adds sparse warnings */\n\tif (count > size - pos)\n\t\tcount = size - pos;\n\n\t/* align io read start to u32 multiple */\n\tpos = ALIGN_DOWN(pos, 4);\n\n\t/* intermediate buffer size must be u32 multiple */\n\tsize = ALIGN(count, 4);\n\n\t/* if start position is unaligned, read extra u32 */\n\tif (unlikely(pos != *ppos)) {\n\t\tskip = *ppos - pos;\n\t\tif (pos + size + 4 < dfse->size)\n\t\t\tsize += 4;\n\t}\n\n\tbuf = kzalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (dfse->type == SOF_DFSENTRY_TYPE_IOMEM) {\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_ENABLE_DEBUGFS_CACHE)\n\t\t/*\n\t\t * If the DSP is active: copy from IO.\n\t\t * If the DSP is suspended:\n\t\t *\t- Copy from IO if the memory is always accessible.\n\t\t *\t- Otherwise, copy from cached buffer.\n\t\t */\n\t\tif (pm_runtime_active(sdev->dev) ||\n\t\t    dfse->access_type == SOF_DEBUGFS_ACCESS_ALWAYS) {\n\t\t\tmemcpy_fromio(buf, dfse->io_mem + pos, size);\n\t\t} else {\n\t\t\tdev_info(sdev->dev,\n\t\t\t\t \"Copying cached debugfs data\\n\");\n\t\t\tmemcpy(buf, dfse->cache_buf + pos, size);\n\t\t}\n#else\n\t\t/* if the DSP is in D3 */\n\t\tif (!pm_runtime_active(sdev->dev) &&\n\t\t    dfse->access_type == SOF_DEBUGFS_ACCESS_D0_ONLY) {\n\t\t\tdev_err(sdev->dev,\n\t\t\t\t\"error: debugfs entry cannot be read in DSP D3\\n\");\n\t\t\tkfree(buf);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmemcpy_fromio(buf, dfse->io_mem + pos, size);\n#endif\n\t} else {\n\t\tmemcpy(buf, ((u8 *)(dfse->buf) + pos), size);\n\t}\n\n\t/* copy to userspace */\n\tsize_ret = copy_to_user(buffer, buf + skip, count);\n\n\tkfree(buf);\n\n\t/* update count & position if copy succeeded */\n\tif (size_ret)\n\t\treturn -EFAULT;\n\n\t*ppos = pos + count;\n\n\treturn count;\n}\n\nstatic const struct file_operations sof_dfs_fops = {\n\t.open = simple_open,\n\t.read = sof_dfsentry_read,\n\t.llseek = default_llseek,\n\t.write = sof_dfsentry_write,\n};\n\n/* create FS entry for debug files that can expose DSP memories, registers */\nint snd_sof_debugfs_io_item(struct snd_sof_dev *sdev,\n\t\t\t    void __iomem *base, size_t size,\n\t\t\t    const char *name,\n\t\t\t    enum sof_debugfs_access_type access_type)\n{\n\tstruct snd_sof_dfsentry *dfse;\n\n\tif (!sdev)\n\t\treturn -EINVAL;\n\n\tdfse = devm_kzalloc(sdev->dev, sizeof(*dfse), GFP_KERNEL);\n\tif (!dfse)\n\t\treturn -ENOMEM;\n\n\tdfse->type = SOF_DFSENTRY_TYPE_IOMEM;\n\tdfse->io_mem = base;\n\tdfse->size = size;\n\tdfse->sdev = sdev;\n\tdfse->access_type = access_type;\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_ENABLE_DEBUGFS_CACHE)\n\t/*\n\t * allocate cache buffer that will be used to save the mem window\n\t * contents prior to suspend\n\t */\n\tif (access_type == SOF_DEBUGFS_ACCESS_D0_ONLY) {\n\t\tdfse->cache_buf = devm_kzalloc(sdev->dev, size, GFP_KERNEL);\n\t\tif (!dfse->cache_buf)\n\t\t\treturn -ENOMEM;\n\t}\n#endif\n\n\tdebugfs_create_file(name, 0444, sdev->debugfs_root, dfse,\n\t\t\t    &sof_dfs_fops);\n\n\t/* add to dfsentry list */\n\tlist_add(&dfse->list, &sdev->dfsentry_list);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_sof_debugfs_io_item);\n\n/* create FS entry for debug files to expose kernel memory */\nint snd_sof_debugfs_buf_item(struct snd_sof_dev *sdev,\n\t\t\t     void *base, size_t size,\n\t\t\t     const char *name, mode_t mode)\n{\n\tstruct snd_sof_dfsentry *dfse;\n\n\tif (!sdev)\n\t\treturn -EINVAL;\n\n\tdfse = devm_kzalloc(sdev->dev, sizeof(*dfse), GFP_KERNEL);\n\tif (!dfse)\n\t\treturn -ENOMEM;\n\n\tdfse->type = SOF_DFSENTRY_TYPE_BUF;\n\tdfse->buf = base;\n\tdfse->size = size;\n\tdfse->sdev = sdev;\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST)\n\t/*\n\t * cache_buf is unused for SOF_DFSENTRY_TYPE_BUF debugfs entries.\n\t * So, use it to save the results of the last IPC flood test.\n\t */\n\tdfse->cache_buf = devm_kzalloc(sdev->dev, IPC_FLOOD_TEST_RESULT_LEN,\n\t\t\t\t       GFP_KERNEL);\n\tif (!dfse->cache_buf)\n\t\treturn -ENOMEM;\n#endif\n\n\tdebugfs_create_file(name, mode, sdev->debugfs_root, dfse,\n\t\t\t    &sof_dfs_fops);\n\t/* add to dfsentry list */\n\tlist_add(&dfse->list, &sdev->dfsentry_list);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_sof_debugfs_buf_item);\n\nint snd_sof_dbg_init(struct snd_sof_dev *sdev)\n{\n\tconst struct snd_sof_dsp_ops *ops = sof_ops(sdev);\n\tconst struct snd_sof_debugfs_map *map;\n\tint i;\n\tint err;\n\n\t/* use \"sof\" as top level debugFS dir */\n\tsdev->debugfs_root = debugfs_create_dir(\"sof\", NULL);\n\n\t/* init dfsentry list */\n\tINIT_LIST_HEAD(&sdev->dfsentry_list);\n\n\t/* create debugFS files for platform specific MMIO/DSP memories */\n\tfor (i = 0; i < ops->debug_map_count; i++) {\n\t\tmap = &ops->debug_map[i];\n\n\t\terr = snd_sof_debugfs_io_item(sdev, sdev->bar[map->bar] +\n\t\t\t\t\t      map->offset, map->size,\n\t\t\t\t\t      map->name, map->access_type);\n\t\t/* errors are only due to memory allocation, not debugfs */\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST)\n\t/* create read-write ipc_flood_count debugfs entry */\n\terr = snd_sof_debugfs_buf_item(sdev, NULL, 0,\n\t\t\t\t       \"ipc_flood_count\", 0666);\n\n\t/* errors are only due to memory allocation, not debugfs */\n\tif (err < 0)\n\t\treturn err;\n\n\t/* create read-write ipc_flood_duration_ms debugfs entry */\n\terr = snd_sof_debugfs_buf_item(sdev, NULL, 0,\n\t\t\t\t       \"ipc_flood_duration_ms\", 0666);\n\n\t/* errors are only due to memory allocation, not debugfs */\n\tif (err < 0)\n\t\treturn err;\n#endif\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_sof_dbg_init);\n\nvoid snd_sof_free_debug(struct snd_sof_dev *sdev)\n{\n\tdebugfs_remove_recursive(sdev->debugfs_root);\n}\nEXPORT_SYMBOL_GPL(snd_sof_free_debug);\n"], "filenames": ["sound/soc/sof/debug.c"], "buggy_code_start_loc": [155], "buggy_code_end_loc": [157], "fixing_code_start_loc": [155], "fixing_code_end_loc": [159], "type": "CWE-401", "message": "A memory leak in the sof_dfsentry_write() function in sound/soc/sof/debug.c in the Linux kernel through 5.3.9 allows attackers to cause a denial of service (memory consumption), aka CID-c0a333d842ef.", "other": {"cve": {"id": "CVE-2019-18812", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-07T16:15:11.623", "lastModified": "2023-01-17T21:31:41.300", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A memory leak in the sof_dfsentry_write() function in sound/soc/sof/debug.c in the Linux kernel through 5.3.9 allows attackers to cause a denial of service (memory consumption), aka CID-c0a333d842ef."}, {"lang": "es", "value": "Una p\u00e9rdida de memoria en la funci\u00f3n sof_dfsentry_write() en el archivo sound/soc/sof/debug.c en el kernel de Linux versiones hasta de 5.3.9, permite a atacantes causar una denegaci\u00f3n de servicio (consumo de memoria), tambi\u00e9n se conoce como CID-c0a333d842ef."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.3", "versionEndExcluding": "5.4", "matchCriteriaId": "11D6AE2D-C914-4EF5-9939-C5B9340F0EA0"}]}]}], "references": [{"url": "https://github.com/torvalds/linux/commit/c0a333d842ef67ac04adc72ff79dc1ccc3dca4ed", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LYIFGYEDQXP5DVJQQUARQRK2PXKBKQGY/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YWWOOJKZ4NQYN4RMFIVJ3ZIXKJJI3MKP/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191205-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/c0a333d842ef67ac04adc72ff79dc1ccc3dca4ed"}}