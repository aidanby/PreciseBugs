{"buggy_code": ["// ***************************************************************** -*- C++ -*-\n/*\n * Copyright (C) 2004-2021 Exiv2 authors\n * This program is part of the Exiv2 distribution.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, 5th Floor, Boston, MA 02110-1301 USA.\n */\n/*\n  Google's WEBP container spec can be found at the link below:\n  https://developers.google.com/speed/webp/docs/riff_container\n*/\n\n// *****************************************************************************\n// included header files\n#include \"config.h\"\n\n#include \"webpimage.hpp\"\n#include \"image_int.hpp\"\n#include \"enforce.hpp\"\n#include \"futils.hpp\"\n#include \"basicio.hpp\"\n#include \"tags.hpp\"\n#include \"tags_int.hpp\"\n#include \"types.hpp\"\n#include \"tiffimage.hpp\"\n#include \"tiffimage_int.hpp\"\n#include \"convert.hpp\"\n#include \"safe_op.hpp\"\n\n#include <cmath>\n#include <iomanip>\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <sstream>\n#include <cassert>\n#include <cstdio>\n\n#define CHECK_BIT(var,pos) ((var) & (1<<(pos)))\n\n// *****************************************************************************\n// class member definitions\nnamespace Exiv2 {\n    namespace Internal {\n\n    }}                                      // namespace Internal, Exiv2\n\nnamespace Exiv2 {\n    using namespace Exiv2::Internal;\n\n    // This static function is a temporary fix in v0.27. In the next version,\n    // it will be added as a method of BasicIo.\n    static void readOrThrow(BasicIo& iIo, byte* buf, long rcount, ErrorCode err) {\n      const long nread = iIo.read(buf, rcount);\n      enforce(nread == rcount, err);\n      enforce(!iIo.error(), err);\n    }\n\n    WebPImage::WebPImage(BasicIo::UniquePtr io)\n    : Image(ImageType::webp, mdNone, std::move(io))\n    {\n    } // WebPImage::WebPImage\n\n    std::string WebPImage::mimeType() const\n    {\n        return \"image/webp\";\n    }\n\n    /* =========================================== */\n\n    /* Misc. */\n    const byte WebPImage::WEBP_PAD_ODD = 0;\n    const int WebPImage::WEBP_TAG_SIZE = 0x4;\n\n    /* VP8X feature flags */\n    const int WebPImage::WEBP_VP8X_ICC_BIT = 0x20;\n    const int WebPImage::WEBP_VP8X_ALPHA_BIT = 0x10;\n    const int WebPImage::WEBP_VP8X_EXIF_BIT = 0x8;\n    const int WebPImage::WEBP_VP8X_XMP_BIT = 0x4;\n\n    /* Chunk header names */\n    const char* WebPImage::WEBP_CHUNK_HEADER_VP8X = \"VP8X\";\n    const char* WebPImage::WEBP_CHUNK_HEADER_VP8L = \"VP8L\";\n    const char* WebPImage::WEBP_CHUNK_HEADER_VP8  = \"VP8 \";\n    const char* WebPImage::WEBP_CHUNK_HEADER_ANMF = \"ANMF\";\n    const char* WebPImage::WEBP_CHUNK_HEADER_ANIM = \"ANIM\";\n    const char* WebPImage::WEBP_CHUNK_HEADER_ICCP = \"ICCP\";\n    const char* WebPImage::WEBP_CHUNK_HEADER_EXIF = \"EXIF\";\n    const char* WebPImage::WEBP_CHUNK_HEADER_XMP  = \"XMP \";\n\n    /* =========================================== */\n\n    void WebPImage::setIptcData(const IptcData& /*iptcData*/)\n    {\n        // not supported\n        // just quietly ignore the request\n        // throw(Error(kerInvalidSettingForImage, \"IPTC metadata\", \"WebP\"));\n    }\n\n    void WebPImage::setComment(const std::string& /*comment*/)\n    {\n        // not supported\n        throw(Error(kerInvalidSettingForImage, \"Image comment\", \"WebP\"));\n    }\n\n    /* =========================================== */\n\n    void WebPImage::writeMetadata()\n    {\n        if (io_->open() != 0) {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        BasicIo::UniquePtr tempIo(new MemIo);\n        assert (tempIo.get() != 0);\n\n        doWriteMetadata(*tempIo); // may throw\n        io_->close();\n        io_->transfer(*tempIo); // may throw\n    } // WebPImage::writeMetadata\n\n\n    void WebPImage::doWriteMetadata(BasicIo& outIo)\n    {\n        if (!io_->isopen()) throw Error(kerInputDataReadFailed);\n        if (!outIo.isopen()) throw Error(kerImageWriteFailed);\n\n#ifdef EXIV2_DEBUG_MESSAGES\n        std::cout << \"Writing metadata\" << std::endl;\n#endif\n\n        byte    data   [WEBP_TAG_SIZE*3];\n        DataBuf chunkId(WEBP_TAG_SIZE+1);\n        chunkId.pData_ [WEBP_TAG_SIZE] = '\\0';\n\n        io_->read(data, WEBP_TAG_SIZE * 3);\n        uint64_t filesize = Exiv2::getULong(data + WEBP_TAG_SIZE, littleEndian);\n\n        /* Set up header */\n        if (outIo.write(data, WEBP_TAG_SIZE * 3) != WEBP_TAG_SIZE * 3)\n            throw Error(kerImageWriteFailed);\n\n        /* Parse Chunks */\n        bool has_size  = false;\n        bool has_xmp   = false;\n        bool has_exif  = false;\n        bool has_vp8x  = false;\n        bool has_alpha = false;\n        bool has_icc   = iccProfileDefined();\n\n        int width      = 0;\n        int height     = 0;\n\n        byte       size_buff[WEBP_TAG_SIZE];\n        Blob       blob;\n\n        if (exifData_.count() > 0) {\n            ExifParser::encode(blob, littleEndian, exifData_);\n            if (blob.size() > 0) {\n                has_exif = true;\n            }\n        }\n\n        if (xmpData_.count() > 0 && !writeXmpFromPacket()) {\n            XmpParser::encode(xmpPacket_, xmpData_,\n                              XmpParser::useCompactFormat |\n                              XmpParser::omitAllFormatting);\n        }\n        has_xmp = xmpPacket_.size() > 0;\n        std::string xmp(xmpPacket_);\n\n        /* Verify for a VP8X Chunk First before writing in\n         case we have any exif or xmp data, also check\n         for any chunks with alpha frame/layer set */\n        while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {\n            io_->read(chunkId.pData_, WEBP_TAG_SIZE);\n            io_->read(size_buff, WEBP_TAG_SIZE);\n            long size = Exiv2::getULong(size_buff, littleEndian);\n            DataBuf payload(size);\n            io_->read(payload.pData_, payload.size_);\n            byte c;\n            if ( payload.size_ % 2 ) io_->read(&c,1);\n\n            /* Chunk with information about features\n             used in the file. */\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X) && !has_vp8x) {\n                has_vp8x = true;\n            }\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X) && !has_size) {\n                has_size = true;\n                byte size_buf[WEBP_TAG_SIZE];\n\n                // Fetch width - stored in 24bits\n                memcpy(&size_buf, &payload.pData_[4], 3);\n                size_buf[3] = 0;\n                width = Exiv2::getULong(size_buf, littleEndian) + 1;\n\n                // Fetch height - stored in 24bits\n                memcpy(&size_buf, &payload.pData_[7], 3);\n                size_buf[3] = 0;\n                height = Exiv2::getULong(size_buf, littleEndian) + 1;\n            }\n\n            /* Chunk with with animation control data. */\n#ifdef __CHECK_FOR_ALPHA__  // Maybe in the future\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANIM) && !has_alpha) {\n                has_alpha = true;\n            }\n#endif\n\n            /* Chunk with with lossy image data. */\n#ifdef __CHECK_FOR_ALPHA__ // Maybe in the future\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8) && !has_alpha) {\n                has_alpha = true;\n            }\n#endif\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8) && !has_size) {\n                has_size = true;\n                byte size_buf[2];\n\n                /* Refer to this https://tools.ietf.org/html/rfc6386\n                   for height and width reference for VP8 chunks */\n\n                // Fetch width - stored in 16bits\n                memcpy(&size_buf, &payload.pData_[6], 2);\n                width = Exiv2::getUShort(size_buf, littleEndian) & 0x3fff;\n\n                // Fetch height - stored in 16bits\n                memcpy(&size_buf, &payload.pData_[8], 2);\n                height = Exiv2::getUShort(size_buf, littleEndian) & 0x3fff;\n            }\n\n            /* Chunk with with lossless image data. */\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8L) && !has_alpha) {\n                if ((payload.pData_[4] & WEBP_VP8X_ALPHA_BIT) == WEBP_VP8X_ALPHA_BIT) {\n                    has_alpha = true;\n                }\n            }\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8L) && !has_size) {\n                has_size = true;\n                byte size_buf_w[2];\n                byte size_buf_h[3];\n\n                /* For VP8L chunks width & height are stored in 28 bits\n                   of a 32 bit field requires bitshifting to get actual\n                   sizes. Width and height are split even into 14 bits\n                   each. Refer to this https://goo.gl/bpgMJf */\n\n                // Fetch width - 14 bits wide\n                memcpy(&size_buf_w, &payload.pData_[1], 2);\n                size_buf_w[1] &= 0x3F;\n                width = Exiv2::getUShort(size_buf_w, littleEndian) + 1;\n\n                // Fetch height - 14 bits wide\n                memcpy(&size_buf_h, &payload.pData_[2], 3);\n                size_buf_h[0] =\n                  ((size_buf_h[0] >> 6) & 0x3) |\n                    ((size_buf_h[1] & 0x3F) << 0x2);\n                size_buf_h[1] =\n                  ((size_buf_h[1] >> 6) & 0x3) |\n                    ((size_buf_h[2] & 0xF) << 0x2);\n                height = Exiv2::getUShort(size_buf_h, littleEndian) + 1;\n            }\n\n            /* Chunk with animation frame. */\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANMF) && !has_alpha) {\n                if ((payload.pData_[5] & 0x2) == 0x2) {\n                    has_alpha = true;\n                }\n            }\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANMF) && !has_size) {\n                has_size = true;\n                byte size_buf[WEBP_TAG_SIZE];\n\n                // Fetch width - stored in 24bits\n                memcpy(&size_buf, &payload.pData_[6], 3);\n                size_buf[3] = 0;\n                width = Exiv2::getULong(size_buf, littleEndian) + 1;\n\n                // Fetch height - stored in 24bits\n                memcpy(&size_buf, &payload.pData_[9], 3);\n                size_buf[3] = 0;\n                height = Exiv2::getULong(size_buf, littleEndian) + 1;\n            }\n\n            /* Chunk with alpha data. */\n            if (equalsWebPTag(chunkId, \"ALPH\") && !has_alpha) {\n                has_alpha = true;\n            }\n        }\n\n        /* Inject a VP8X chunk if one isn't available. */\n        if (!has_vp8x) {\n            inject_VP8X(outIo, has_xmp, has_exif, has_alpha,\n                        has_icc, width, height);\n        }\n\n        io_->seek(12, BasicIo::beg);\n        while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {\n            io_->read(chunkId.pData_, 4);\n            io_->read(size_buff, 4);\n\n            long size = Exiv2::getULong(size_buff, littleEndian);\n\n            DataBuf payload(size);\n            io_->read(payload.pData_, size);\n            if ( io_->tell() % 2 ) io_->seek(+1,BasicIo::cur); // skip pad\n\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X)) {\n                if (has_icc){\n                    payload.pData_[0] |= WEBP_VP8X_ICC_BIT;\n                } else {\n                    payload.pData_[0] &= ~WEBP_VP8X_ICC_BIT;\n                }\n\n                if (has_xmp){\n                    payload.pData_[0] |= WEBP_VP8X_XMP_BIT;\n                } else {\n                    payload.pData_[0] &= ~WEBP_VP8X_XMP_BIT;\n                }\n\n                if (has_exif) {\n                    payload.pData_[0] |= WEBP_VP8X_EXIF_BIT;\n                } else {\n                    payload.pData_[0] &= ~WEBP_VP8X_EXIF_BIT;\n                }\n\n                if (outIo.write(chunkId.pData_, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)\n                    throw Error(kerImageWriteFailed);\n                if (outIo.write(size_buff, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)\n                    throw Error(kerImageWriteFailed);\n                if (outIo.write(payload.pData_, payload.size_) != payload.size_)\n                    throw Error(kerImageWriteFailed);\n                if (outIo.tell() % 2) {\n                    if (outIo.write(&WEBP_PAD_ODD, 1) != 1) throw Error(kerImageWriteFailed);\n                }\n\n                if (has_icc) {\n                    if (outIo.write((const byte*)WEBP_CHUNK_HEADER_ICCP, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n                    ul2Data(data, (uint32_t) iccProfile_.size_, littleEndian);\n                    if (outIo.write(data, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n                    if (outIo.write(iccProfile_.pData_, iccProfile_.size_) != iccProfile_.size_) {\n                        throw Error(kerImageWriteFailed);\n                    }\n                    has_icc = false;\n                }\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ICCP)) {\n                // Skip it altogether handle it prior to here :)\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_EXIF)) {\n                // Skip and add new data afterwards\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_XMP)) {\n                // Skip and add new data afterwards\n            } else {\n                if (outIo.write(chunkId.pData_, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)\n                    throw Error(kerImageWriteFailed);\n                if (outIo.write(size_buff, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)\n                    throw Error(kerImageWriteFailed);\n                if (outIo.write(payload.pData_, payload.size_) != payload.size_)\n                    throw Error(kerImageWriteFailed);\n            }\n\n            // Encoder required to pad odd sized data with a null byte\n            if (outIo.tell() % 2) {\n                if (outIo.write(&WEBP_PAD_ODD, 1) != 1) throw Error(kerImageWriteFailed);\n            }\n        }\n\n        if (has_exif) {\n            if (outIo.write((const byte*)WEBP_CHUNK_HEADER_EXIF, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n            us2Data(data, (uint16_t) blob.size()+8, bigEndian);\n            ul2Data(data, (uint32_t) blob.size(), littleEndian);\n            if (outIo.write(data, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n            if (outIo.write((const byte*)&blob[0], static_cast<long>(blob.size())) != (long)blob.size())\n            {\n                throw Error(kerImageWriteFailed);\n            }\n            if (outIo.tell() % 2) {\n                if (outIo.write(&WEBP_PAD_ODD, 1) != 1) throw Error(kerImageWriteFailed);\n            }\n        }\n\n        if (has_xmp) {\n            if (outIo.write((const byte*)WEBP_CHUNK_HEADER_XMP, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n            ul2Data(data, (uint32_t) xmpPacket().size(), littleEndian);\n            if (outIo.write(data, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n            if (outIo.write((const byte*)xmp.data(), static_cast<long>(xmp.size())) != (long)xmp.size()) {\n                throw Error(kerImageWriteFailed);\n            }\n            if (outIo.tell() % 2) {\n                if (outIo.write(&WEBP_PAD_ODD, 1) != 1) throw Error(kerImageWriteFailed);\n            }\n        }\n\n        // Fix File Size Payload Data\n        outIo.seek(0, BasicIo::beg);\n        filesize = outIo.size() - 8;\n        outIo.seek(4, BasicIo::beg);\n        ul2Data(data, (uint32_t) filesize, littleEndian);\n        if (outIo.write(data, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n\n    } // WebPImage::writeMetadata\n\n    /* =========================================== */\n\n    void WebPImage::printStructure(std::ostream& out, PrintStructureOption option,int depth)\n    {\n        if (io_->open() != 0) {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        // Ensure this is the correct image type\n        if (!isWebPType(*io_, true)) {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \"WEBP\");\n        }\n\n        bool bPrint  = option==kpsBasic || option==kpsRecursive;\n        if ( bPrint || option == kpsXMP || option == kpsIccProfile || option == kpsIptcErase ) {\n            byte      data [WEBP_TAG_SIZE * 2];\n            io_->read(data, WEBP_TAG_SIZE * 2);\n            uint64_t filesize = Exiv2::getULong(data + WEBP_TAG_SIZE, littleEndian);\n            DataBuf  chunkId(5)      ;\n            chunkId.pData_[4] = '\\0' ;\n\n            if ( bPrint ) {\n                out << Internal::indent(depth)\n                << \"STRUCTURE OF WEBP FILE: \"\n                << io().path()\n                << std::endl;\n                out << Internal::indent(depth)\n                << Internal::stringFormat(\" Chunk |   Length |   Offset | Payload\")\n                << std::endl;\n            }\n\n            io_->seek(0,BasicIo::beg); // rewind\n            while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {\n                uint64_t offset = (uint64_t) io_->tell();\n                byte     size_buff[WEBP_TAG_SIZE];\n                io_->read(chunkId.pData_, WEBP_TAG_SIZE);\n                io_->read(size_buff, WEBP_TAG_SIZE);\n                long size = Exiv2::getULong(size_buff, littleEndian);\n                DataBuf payload(offset?size:WEBP_TAG_SIZE); // header is different from chunks\n                io_->read(payload.pData_, payload.size_);\n\n                if ( bPrint ) {\n                    out << Internal::indent(depth)\n                    << Internal::stringFormat(\"  %s | %8u | %8u | \", (const char*)chunkId.pData_,(uint32_t)size,(uint32_t)offset)\n                    << Internal::binaryToString(makeSlice(payload, 0, payload.size_ > 32 ? 32 : payload.size_))\n                    << std::endl;\n                }\n\n                if ( equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_EXIF) && option==kpsRecursive ) {\n                    // create memio object with the payload, then print the structure\n                    BasicIo::UniquePtr p = BasicIo::UniquePtr(new MemIo(payload.pData_,payload.size_));\n                    printTiffStructure(*p,out,option,depth);\n                }\n\n                bool bPrintPayload = (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_XMP) && option==kpsXMP)\n                                  || (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ICCP) && option==kpsIccProfile)\n                                   ;\n                if ( bPrintPayload ) {\n                    out.write((const char*) payload.pData_,payload.size_);\n                }\n\n                if ( offset && io_->tell() % 2 ) io_->seek(+1, BasicIo::cur); // skip padding byte on sub-chunks\n            }\n        }\n    }\n\n    /* =========================================== */\n\n    void WebPImage::readMetadata()\n    {\n        if (io_->open() != 0) throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        IoCloser closer(*io_);\n        // Ensure that this is the correct image type\n        if (!isWebPType(*io_, true)) {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAJpeg);\n        }\n        clearMetadata();\n\n        byte data[12];\n        DataBuf chunkId(5);\n        chunkId.pData_[4] = '\\0' ;\n\n        readOrThrow(*io_, data, WEBP_TAG_SIZE * 3, Exiv2::kerCorruptedMetadata);\n\n        const uint32_t filesize_u32 =\n            Safe::add(Exiv2::getULong(data + WEBP_TAG_SIZE, littleEndian), 8U);\n        enforce(filesize_u32 <= io_->size(), Exiv2::kerCorruptedMetadata);\n\n        // Check that `filesize_u32` is safe to cast to `long`.\n        enforce(filesize_u32 <= static_cast<size_t>(std::numeric_limits<unsigned int>::max()),\n                Exiv2::kerCorruptedMetadata);\n\n        WebPImage::decodeChunks(static_cast<long>(filesize_u32));\n\n    } // WebPImage::readMetadata\n\n    void WebPImage::decodeChunks(long filesize)\n    {\n        DataBuf   chunkId(5);\n        byte      size_buff[WEBP_TAG_SIZE];\n        bool      has_canvas_data = false;\n\n#ifdef EXIV2_DEBUG_MESSAGES\n        std::cout << \"Reading metadata\" << std::endl;\n#endif\n\n        chunkId.pData_[4] = '\\0' ;\n        while (!io_->eof() && io_->tell() < filesize) {\n            readOrThrow(*io_, chunkId.pData_, WEBP_TAG_SIZE, Exiv2::kerCorruptedMetadata);\n            readOrThrow(*io_, size_buff, WEBP_TAG_SIZE, Exiv2::kerCorruptedMetadata);\n\n            const uint32_t size_u32 = Exiv2::getULong(size_buff, littleEndian);\n\n            // Check that `size_u32` is safe to cast to `long`.\n            enforce(size_u32 <= static_cast<size_t>(std::numeric_limits<unsigned int>::max()),\n                    Exiv2::kerCorruptedMetadata);\n            const long size = static_cast<long>(size_u32);\n\n            // Check that `size` is within bounds.\n            enforce(io_->tell() <= filesize, Exiv2::kerCorruptedMetadata);\n            enforce(size <= (filesize - io_->tell()), Exiv2::kerCorruptedMetadata);\n\n            DataBuf payload(size);\n\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X) && !has_canvas_data) {\n                enforce(size >= 10, Exiv2::kerCorruptedMetadata);\n\n                has_canvas_data = true;\n                byte size_buf[WEBP_TAG_SIZE];\n\n                readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n\n                // Fetch width\n                memcpy(&size_buf, &payload.pData_[4], 3);\n                size_buf[3] = 0;\n                pixelWidth_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n\n                // Fetch height\n                memcpy(&size_buf, &payload.pData_[7], 3);\n                size_buf[3] = 0;\n                pixelHeight_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8) && !has_canvas_data) {\n                enforce(size >= 10, Exiv2::kerCorruptedMetadata);\n\n                has_canvas_data = true;\n                readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n                byte size_buf[WEBP_TAG_SIZE];\n\n                // Fetch width\"\"\n                memcpy(&size_buf, &payload.pData_[6], 2);\n                size_buf[2] = 0;\n                size_buf[3] = 0;\n                pixelWidth_ = Exiv2::getULong(size_buf, littleEndian) & 0x3fff;\n\n                // Fetch height\n                memcpy(&size_buf, &payload.pData_[8], 2);\n                size_buf[2] = 0;\n                size_buf[3] = 0;\n                pixelHeight_ = Exiv2::getULong(size_buf, littleEndian) & 0x3fff;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8L) && !has_canvas_data) {\n                enforce(size >= 5, Exiv2::kerCorruptedMetadata);\n\n                has_canvas_data = true;\n                byte size_buf_w[2];\n                byte size_buf_h[3];\n\n                readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n\n                // Fetch width\n                memcpy(&size_buf_w, &payload.pData_[1], 2);\n                size_buf_w[1] &= 0x3F;\n                pixelWidth_ = Exiv2::getUShort(size_buf_w, littleEndian) + 1;\n\n                // Fetch height\n                memcpy(&size_buf_h, &payload.pData_[2], 3);\n                size_buf_h[0] = ((size_buf_h[0] >> 6) & 0x3) | ((size_buf_h[1]  & 0x3F) << 0x2);\n                size_buf_h[1] = ((size_buf_h[1] >> 6) & 0x3) | ((size_buf_h[2] & 0xF) << 0x2);\n                pixelHeight_ = Exiv2::getUShort(size_buf_h, littleEndian) + 1;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANMF) && !has_canvas_data) {\n                enforce(size >= 12, Exiv2::kerCorruptedMetadata);\n\n                has_canvas_data = true;\n                byte size_buf[WEBP_TAG_SIZE];\n\n                readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n\n                // Fetch width\n                memcpy(&size_buf, &payload.pData_[6], 3);\n                size_buf[3] = 0;\n                pixelWidth_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n\n                // Fetch height\n                memcpy(&size_buf, &payload.pData_[9], 3);\n                size_buf[3] = 0;\n                pixelHeight_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ICCP)) {\n                readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n                this->setIccProfile(payload);\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_EXIF)) {\n                readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n\n                byte  size_buff2[2];\n                // 4 meaningful bytes + 2 padding bytes\n                byte  exifLongHeader[]   = { 0xFF, 0x01, 0xFF, 0xE1, 0x00, 0x00 };\n                byte  exifShortHeader[]  = { 0x45, 0x78, 0x69, 0x66, 0x00, 0x00 };\n                byte  exifTiffLEHeader[] = { 0x49, 0x49, 0x2A };       // \"MM*\"\n                byte  exifTiffBEHeader[] = { 0x4D, 0x4D, 0x00, 0x2A }; // \"II\\0*\"\n                byte* rawExifData = NULL;\n                long  offset = 0;\n                bool  s_header = false;\n                bool  le_header = false;\n                bool  be_header = false;\n                long  pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifLongHeader, 4);\n\n                if (pos == -1) {\n                    pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifLongHeader, 6);\n                    if (pos != -1) {\n                        s_header = true;\n                    }\n                }\n                if (pos == -1) {\n                    pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifTiffLEHeader, 3);\n                    if (pos != -1) {\n                        le_header = true;\n                    }\n                }\n                if (pos == -1) {\n                    pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifTiffBEHeader, 4);\n                    if (pos != -1) {\n                        be_header = true;\n                    }\n                }\n\n                if (s_header) {\n                    offset += 6;\n                }\n                if (be_header || le_header) {\n                    offset += 12;\n                }\n\n                const long sizePayload = payload.size_ + offset;\n                rawExifData = (byte*)malloc(sizePayload);\n\n                if (s_header) {\n                    us2Data(size_buff2, (uint16_t) (sizePayload - 6), bigEndian);\n                    memcpy(rawExifData, (char*)&exifLongHeader, 4);\n                    memcpy(rawExifData + 4, (char*)&size_buff2, 2);\n                }\n\n                if (be_header || le_header) {\n                    us2Data(size_buff2, (uint16_t) (sizePayload - 6), bigEndian);\n                    memcpy(rawExifData, (char*)&exifLongHeader, 4);\n                    memcpy(rawExifData + 4, (char*)&size_buff2, 2);\n                    memcpy(rawExifData + 6, (char*)&exifShortHeader, 6);\n                }\n\n                memcpy(rawExifData + offset, payload.pData_, payload.size_);\n\n#ifdef EXIV2_DEBUG_MESSAGES\n                std::cout << \"Display Hex Dump [size:\" << (unsigned long)sizePayload << \"]\" << std::endl;\n                std::cout << Internal::binaryToHex(rawExifData, sizePayload);\n#endif\n\n                if (pos != -1) {\n                    XmpData  xmpData;\n                    ByteOrder bo = ExifParser::decode(exifData_,\n                                                      payload.pData_ + pos,\n                                                      payload.size_ - pos);\n                    setByteOrder(bo);\n                }\n                else\n                {\n#ifndef SUPPRESS_WARNINGS\n                    EXV_WARNING << \"Failed to decode Exif metadata.\" << std::endl;\n#endif\n                    exifData_.clear();\n                }\n\n                if (rawExifData) free(rawExifData);\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_XMP)) {\n                readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n                xmpPacket_.assign(reinterpret_cast<char*>(payload.pData_), payload.size_);\n                if (xmpPacket_.size() > 0 && XmpParser::decode(xmpData_, xmpPacket_)) {\n#ifndef SUPPRESS_WARNINGS\n                    EXV_WARNING << \"Failed to decode XMP metadata.\" << std::endl;\n#endif\n                } else {\n#ifdef EXIV2_DEBUG_MESSAGES\n                    std::cout << \"Display Hex Dump [size:\" << (unsigned long)payload.size_ << \"]\" << std::endl;\n                    std::cout << Internal::binaryToHex(payload.pData_, payload.size_);\n#endif\n                }\n            } else {\n                io_->seek(size, BasicIo::cur);\n            }\n\n            if ( io_->tell() % 2 ) io_->seek(+1, BasicIo::cur);\n        }\n    }\n\n    /* =========================================== */\n\n    Image::UniquePtr newWebPInstance(BasicIo::UniquePtr io, bool /*create*/)\n    {\n        Image::UniquePtr image(new WebPImage(std::move(io)));\n        if (!image->good()) {\n            image.reset();\n        }\n        return image;\n    }\n\n    bool isWebPType(BasicIo& iIo, bool /*advance*/)\n    {\n        if (iIo.size() < 12) {\n          return false;\n        }\n        const int32_t len = 4;\n        const unsigned char RiffImageId[4] = { 'R', 'I', 'F' ,'F'};\n        const unsigned char WebPImageId[4] = { 'W', 'E', 'B' ,'P'};\n        byte webp[len];\n        byte data[len];\n        byte riff[len];\n        iIo.read(riff, len);\n        iIo.read(data, len);\n        iIo.read(webp, len);\n        bool matched_riff = (memcmp(riff, RiffImageId, len) == 0);\n        bool matched_webp = (memcmp(webp, WebPImageId, len) == 0);\n        iIo.seek(-12, BasicIo::cur);\n        return matched_riff && matched_webp;\n    }\n\n    /*!\n     @brief Function used to check equality of a Tags with a\n     particular string (ignores case while comparing).\n     @param buf Data buffer that will contain Tag to compare\n     @param str char* Pointer to string\n     @return Returns true if the buffer value is equal to string.\n     */\n    bool WebPImage::equalsWebPTag(Exiv2::DataBuf& buf, const char* str) {\n        for(int i = 0; i < 4; i++ )\n            if(toupper(buf.pData_[i]) != str[i])\n                return false;\n        return true;\n    }\n\n\n    /*!\n     @brief Function used to add missing EXIF & XMP flags\n     to the feature section.\n     @param  iIo get BasicIo pointer to inject data\n     @param has_xmp Verify if we have xmp data and set required flag\n     @param has_exif Verify if we have exif data and set required flag\n     @return Returns void\n     */\n    void WebPImage::inject_VP8X(BasicIo& iIo, bool has_xmp,\n                                bool has_exif, bool has_alpha,\n                                bool has_icc, int width, int height) {\n        byte size[4]  = { 0x0A, 0x00, 0x00, 0x00 };\n        byte data[10] = { 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00 };\n        iIo.write((const byte*)WEBP_CHUNK_HEADER_VP8X, WEBP_TAG_SIZE);\n        iIo.write(size, WEBP_TAG_SIZE);\n\n        if (has_alpha) {\n            data[0] |= WEBP_VP8X_ALPHA_BIT;\n        }\n\n        if (has_icc) {\n            data[0] |= WEBP_VP8X_ICC_BIT;\n        }\n\n        if (has_xmp) {\n            data[0] |= WEBP_VP8X_XMP_BIT;\n        }\n\n        if (has_exif) {\n            data[0] |= WEBP_VP8X_EXIF_BIT;\n        }\n\n        /* set width - stored in 24bits*/\n        int w = width - 1;\n        data[4] = w & 0xFF;\n        data[5] = (w >> 8) & 0xFF;\n        data[6] = (w >> 16) & 0xFF;\n\n        /* set height - stored in 24bits */\n        int h = height - 1;\n        data[7] = h & 0xFF;\n        data[8] = (h >> 8) & 0xFF;\n        data[9] = (h >> 16) & 0xFF;\n\n        iIo.write(data, 10);\n\n        /* Handle inject an icc profile right after VP8X chunk */\n        if (has_icc) {\n            byte size_buff[WEBP_TAG_SIZE];\n            ul2Data(size_buff, iccProfile_.size_, littleEndian);\n            if (iIo.write((const byte*)WEBP_CHUNK_HEADER_VP8X, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)\n                throw Error(kerImageWriteFailed);\n            if (iIo.write(size_buff, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)\n                throw Error(kerImageWriteFailed);\n            if (iIo.write(iccProfile_.pData_, iccProfile_.size_) != iccProfile_.size_)\n                throw Error(kerImageWriteFailed);\n            if (iIo.tell() % 2) {\n                if (iIo.write(&WEBP_PAD_ODD, 1) != 1) throw Error(kerImageWriteFailed);\n            }\n\n            has_icc = false;\n        }\n    }\n\n    long WebPImage::getHeaderOffset(byte* data, long data_size, byte* header, long header_size)\n    {\n        if (data_size < header_size) { return -1; }\n        long pos = -1;\n        for (long i=0; i < data_size - header_size; i++) {\n            if (memcmp(header, &data[i], header_size) == 0) {\n                pos = i;\n                break;\n            }\n        }\n        return pos;\n    }\n\n} // namespace Exiv2\n"], "fixing_code": ["// ***************************************************************** -*- C++ -*-\n/*\n * Copyright (C) 2004-2021 Exiv2 authors\n * This program is part of the Exiv2 distribution.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, 5th Floor, Boston, MA 02110-1301 USA.\n */\n/*\n  Google's WEBP container spec can be found at the link below:\n  https://developers.google.com/speed/webp/docs/riff_container\n*/\n\n// *****************************************************************************\n// included header files\n#include \"config.h\"\n\n#include \"webpimage.hpp\"\n#include \"image_int.hpp\"\n#include \"enforce.hpp\"\n#include \"futils.hpp\"\n#include \"basicio.hpp\"\n#include \"tags.hpp\"\n#include \"tags_int.hpp\"\n#include \"types.hpp\"\n#include \"tiffimage.hpp\"\n#include \"tiffimage_int.hpp\"\n#include \"convert.hpp\"\n#include \"safe_op.hpp\"\n\n#include <cmath>\n#include <iomanip>\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <sstream>\n#include <cassert>\n#include <cstdio>\n\n#define CHECK_BIT(var,pos) ((var) & (1<<(pos)))\n\n// *****************************************************************************\n// class member definitions\nnamespace Exiv2 {\n    namespace Internal {\n\n    }}                                      // namespace Internal, Exiv2\n\nnamespace Exiv2 {\n    using namespace Exiv2::Internal;\n\n    // This static function is a temporary fix in v0.27. In the next version,\n    // it will be added as a method of BasicIo.\n    static void readOrThrow(BasicIo& iIo, byte* buf, long rcount, ErrorCode err) {\n      const long nread = iIo.read(buf, rcount);\n      enforce(nread == rcount, err);\n      enforce(!iIo.error(), err);\n    }\n\n    WebPImage::WebPImage(BasicIo::UniquePtr io)\n    : Image(ImageType::webp, mdNone, std::move(io))\n    {\n    } // WebPImage::WebPImage\n\n    std::string WebPImage::mimeType() const\n    {\n        return \"image/webp\";\n    }\n\n    /* =========================================== */\n\n    /* Misc. */\n    const byte WebPImage::WEBP_PAD_ODD = 0;\n    const int WebPImage::WEBP_TAG_SIZE = 0x4;\n\n    /* VP8X feature flags */\n    const int WebPImage::WEBP_VP8X_ICC_BIT = 0x20;\n    const int WebPImage::WEBP_VP8X_ALPHA_BIT = 0x10;\n    const int WebPImage::WEBP_VP8X_EXIF_BIT = 0x8;\n    const int WebPImage::WEBP_VP8X_XMP_BIT = 0x4;\n\n    /* Chunk header names */\n    const char* WebPImage::WEBP_CHUNK_HEADER_VP8X = \"VP8X\";\n    const char* WebPImage::WEBP_CHUNK_HEADER_VP8L = \"VP8L\";\n    const char* WebPImage::WEBP_CHUNK_HEADER_VP8  = \"VP8 \";\n    const char* WebPImage::WEBP_CHUNK_HEADER_ANMF = \"ANMF\";\n    const char* WebPImage::WEBP_CHUNK_HEADER_ANIM = \"ANIM\";\n    const char* WebPImage::WEBP_CHUNK_HEADER_ICCP = \"ICCP\";\n    const char* WebPImage::WEBP_CHUNK_HEADER_EXIF = \"EXIF\";\n    const char* WebPImage::WEBP_CHUNK_HEADER_XMP  = \"XMP \";\n\n    /* =========================================== */\n\n    void WebPImage::setIptcData(const IptcData& /*iptcData*/)\n    {\n        // not supported\n        // just quietly ignore the request\n        // throw(Error(kerInvalidSettingForImage, \"IPTC metadata\", \"WebP\"));\n    }\n\n    void WebPImage::setComment(const std::string& /*comment*/)\n    {\n        // not supported\n        throw(Error(kerInvalidSettingForImage, \"Image comment\", \"WebP\"));\n    }\n\n    /* =========================================== */\n\n    void WebPImage::writeMetadata()\n    {\n        if (io_->open() != 0) {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        BasicIo::UniquePtr tempIo(new MemIo);\n        assert (tempIo.get() != 0);\n\n        doWriteMetadata(*tempIo); // may throw\n        io_->close();\n        io_->transfer(*tempIo); // may throw\n    } // WebPImage::writeMetadata\n\n\n    void WebPImage::doWriteMetadata(BasicIo& outIo)\n    {\n        if (!io_->isopen()) throw Error(kerInputDataReadFailed);\n        if (!outIo.isopen()) throw Error(kerImageWriteFailed);\n\n#ifdef EXIV2_DEBUG_MESSAGES\n        std::cout << \"Writing metadata\" << std::endl;\n#endif\n\n        byte    data   [WEBP_TAG_SIZE*3];\n        DataBuf chunkId(WEBP_TAG_SIZE+1);\n        chunkId.pData_ [WEBP_TAG_SIZE] = '\\0';\n\n        readOrThrow(*io_, data, WEBP_TAG_SIZE * 3, Exiv2::kerCorruptedMetadata);\n        uint64_t filesize = Exiv2::getULong(data + WEBP_TAG_SIZE, littleEndian);\n\n        /* Set up header */\n        if (outIo.write(data, WEBP_TAG_SIZE * 3) != WEBP_TAG_SIZE * 3)\n            throw Error(kerImageWriteFailed);\n\n        /* Parse Chunks */\n        bool has_size  = false;\n        bool has_xmp   = false;\n        bool has_exif  = false;\n        bool has_vp8x  = false;\n        bool has_alpha = false;\n        bool has_icc   = iccProfileDefined();\n\n        int width      = 0;\n        int height     = 0;\n\n        byte       size_buff[WEBP_TAG_SIZE];\n        Blob       blob;\n\n        if (exifData_.count() > 0) {\n            ExifParser::encode(blob, littleEndian, exifData_);\n            if (blob.size() > 0) {\n                has_exif = true;\n            }\n        }\n\n        if (xmpData_.count() > 0 && !writeXmpFromPacket()) {\n            XmpParser::encode(xmpPacket_, xmpData_,\n                              XmpParser::useCompactFormat |\n                              XmpParser::omitAllFormatting);\n        }\n        has_xmp = xmpPacket_.size() > 0;\n        std::string xmp(xmpPacket_);\n\n        /* Verify for a VP8X Chunk First before writing in\n         case we have any exif or xmp data, also check\n         for any chunks with alpha frame/layer set */\n        while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {\n            readOrThrow(*io_, chunkId.pData_, WEBP_TAG_SIZE, Exiv2::kerCorruptedMetadata);\n            readOrThrow(*io_, size_buff, WEBP_TAG_SIZE, Exiv2::kerCorruptedMetadata);\n            const uint32_t size_u32 = Exiv2::getULong(size_buff, littleEndian);\n\n            // Check that `size_u32` is safe to cast to `long`.\n            enforce(size_u32 <= static_cast<size_t>(std::numeric_limits<unsigned int>::max()),\n                    Exiv2::kerCorruptedMetadata);\n            const long size = static_cast<long>(size_u32);\n            DataBuf payload(size);\n            readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n            if ( payload.size_ % 2 ) {\n              byte c;\n              readOrThrow(*io_, &c, 1, Exiv2::kerCorruptedMetadata);\n            }\n\n            /* Chunk with information about features\n             used in the file. */\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X) && !has_vp8x) {\n                has_vp8x = true;\n            }\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X) && !has_size) {\n                enforce(size >= 10, Exiv2::kerCorruptedMetadata);\n                has_size = true;\n                byte size_buf[WEBP_TAG_SIZE];\n\n                // Fetch width - stored in 24bits\n                memcpy(&size_buf, &payload.pData_[4], 3);\n                size_buf[3] = 0;\n                width = Exiv2::getULong(size_buf, littleEndian) + 1;\n\n                // Fetch height - stored in 24bits\n                memcpy(&size_buf, &payload.pData_[7], 3);\n                size_buf[3] = 0;\n                height = Exiv2::getULong(size_buf, littleEndian) + 1;\n            }\n\n            /* Chunk with with animation control data. */\n#ifdef __CHECK_FOR_ALPHA__  // Maybe in the future\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANIM) && !has_alpha) {\n                has_alpha = true;\n            }\n#endif\n\n            /* Chunk with with lossy image data. */\n#ifdef __CHECK_FOR_ALPHA__ // Maybe in the future\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8) && !has_alpha) {\n                has_alpha = true;\n            }\n#endif\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8) && !has_size) {\n                enforce(size >= 10, Exiv2::kerCorruptedMetadata);\n                has_size = true;\n                byte size_buf[2];\n\n                /* Refer to this https://tools.ietf.org/html/rfc6386\n                   for height and width reference for VP8 chunks */\n\n                // Fetch width - stored in 16bits\n                memcpy(&size_buf, &payload.pData_[6], 2);\n                width = Exiv2::getUShort(size_buf, littleEndian) & 0x3fff;\n\n                // Fetch height - stored in 16bits\n                memcpy(&size_buf, &payload.pData_[8], 2);\n                height = Exiv2::getUShort(size_buf, littleEndian) & 0x3fff;\n            }\n\n            /* Chunk with with lossless image data. */\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8L) && !has_alpha) {\n                enforce(size >= 5, Exiv2::kerCorruptedMetadata);\n                if ((payload.pData_[4] & WEBP_VP8X_ALPHA_BIT) == WEBP_VP8X_ALPHA_BIT) {\n                    has_alpha = true;\n                }\n            }\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8L) && !has_size) {\n                enforce(size >= 5, Exiv2::kerCorruptedMetadata);\n                has_size = true;\n                byte size_buf_w[2];\n                byte size_buf_h[3];\n\n                /* For VP8L chunks width & height are stored in 28 bits\n                   of a 32 bit field requires bitshifting to get actual\n                   sizes. Width and height are split even into 14 bits\n                   each. Refer to this https://goo.gl/bpgMJf */\n\n                // Fetch width - 14 bits wide\n                memcpy(&size_buf_w, &payload.pData_[1], 2);\n                size_buf_w[1] &= 0x3F;\n                width = Exiv2::getUShort(size_buf_w, littleEndian) + 1;\n\n                // Fetch height - 14 bits wide\n                memcpy(&size_buf_h, &payload.pData_[2], 3);\n                size_buf_h[0] =\n                  ((size_buf_h[0] >> 6) & 0x3) |\n                    ((size_buf_h[1] & 0x3F) << 0x2);\n                size_buf_h[1] =\n                  ((size_buf_h[1] >> 6) & 0x3) |\n                    ((size_buf_h[2] & 0xF) << 0x2);\n                height = Exiv2::getUShort(size_buf_h, littleEndian) + 1;\n            }\n\n            /* Chunk with animation frame. */\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANMF) && !has_alpha) {\n                enforce(size >= 6, Exiv2::kerCorruptedMetadata);\n                if ((payload.pData_[5] & 0x2) == 0x2) {\n                    has_alpha = true;\n                }\n            }\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANMF) && !has_size) {\n                enforce(size >= 12, Exiv2::kerCorruptedMetadata);\n                has_size = true;\n                byte size_buf[WEBP_TAG_SIZE];\n\n                // Fetch width - stored in 24bits\n                memcpy(&size_buf, &payload.pData_[6], 3);\n                size_buf[3] = 0;\n                width = Exiv2::getULong(size_buf, littleEndian) + 1;\n\n                // Fetch height - stored in 24bits\n                memcpy(&size_buf, &payload.pData_[9], 3);\n                size_buf[3] = 0;\n                height = Exiv2::getULong(size_buf, littleEndian) + 1;\n            }\n\n            /* Chunk with alpha data. */\n            if (equalsWebPTag(chunkId, \"ALPH\") && !has_alpha) {\n                has_alpha = true;\n            }\n        }\n\n        /* Inject a VP8X chunk if one isn't available. */\n        if (!has_vp8x) {\n            inject_VP8X(outIo, has_xmp, has_exif, has_alpha,\n                        has_icc, width, height);\n        }\n\n        io_->seek(12, BasicIo::beg);\n        while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {\n            readOrThrow(*io_, chunkId.pData_, 4, Exiv2::kerCorruptedMetadata);\n            readOrThrow(*io_, size_buff, 4, Exiv2::kerCorruptedMetadata);\n\n            const uint32_t size_u32 = Exiv2::getULong(size_buff, littleEndian);\n\n            // Check that `size_u32` is safe to cast to `long`.\n            enforce(size_u32 <= static_cast<size_t>(std::numeric_limits<unsigned int>::max()),\n                    Exiv2::kerCorruptedMetadata);\n            const long size = static_cast<long>(size_u32);\n\n            DataBuf payload(size);\n            readOrThrow(*io_, payload.pData_, size, Exiv2::kerCorruptedMetadata);\n            if ( io_->tell() % 2 ) io_->seek(+1,BasicIo::cur); // skip pad\n\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X)) {\n                enforce(size >= 1, Exiv2::kerCorruptedMetadata);\n                if (has_icc){\n                    payload.pData_[0] |= WEBP_VP8X_ICC_BIT;\n                } else {\n                    payload.pData_[0] &= ~WEBP_VP8X_ICC_BIT;\n                }\n\n                if (has_xmp){\n                    payload.pData_[0] |= WEBP_VP8X_XMP_BIT;\n                } else {\n                    payload.pData_[0] &= ~WEBP_VP8X_XMP_BIT;\n                }\n\n                if (has_exif) {\n                    payload.pData_[0] |= WEBP_VP8X_EXIF_BIT;\n                } else {\n                    payload.pData_[0] &= ~WEBP_VP8X_EXIF_BIT;\n                }\n\n                if (outIo.write(chunkId.pData_, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)\n                    throw Error(kerImageWriteFailed);\n                if (outIo.write(size_buff, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)\n                    throw Error(kerImageWriteFailed);\n                if (outIo.write(payload.pData_, payload.size_) != payload.size_)\n                    throw Error(kerImageWriteFailed);\n                if (outIo.tell() % 2) {\n                    if (outIo.write(&WEBP_PAD_ODD, 1) != 1) throw Error(kerImageWriteFailed);\n                }\n\n                if (has_icc) {\n                    if (outIo.write((const byte*)WEBP_CHUNK_HEADER_ICCP, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n                    ul2Data(data, (uint32_t) iccProfile_.size_, littleEndian);\n                    if (outIo.write(data, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n                    if (outIo.write(iccProfile_.pData_, iccProfile_.size_) != iccProfile_.size_) {\n                        throw Error(kerImageWriteFailed);\n                    }\n                    has_icc = false;\n                }\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ICCP)) {\n                // Skip it altogether handle it prior to here :)\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_EXIF)) {\n                // Skip and add new data afterwards\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_XMP)) {\n                // Skip and add new data afterwards\n            } else {\n                if (outIo.write(chunkId.pData_, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)\n                    throw Error(kerImageWriteFailed);\n                if (outIo.write(size_buff, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)\n                    throw Error(kerImageWriteFailed);\n                if (outIo.write(payload.pData_, payload.size_) != payload.size_)\n                    throw Error(kerImageWriteFailed);\n            }\n\n            // Encoder required to pad odd sized data with a null byte\n            if (outIo.tell() % 2) {\n                if (outIo.write(&WEBP_PAD_ODD, 1) != 1) throw Error(kerImageWriteFailed);\n            }\n        }\n\n        if (has_exif) {\n            if (outIo.write((const byte*)WEBP_CHUNK_HEADER_EXIF, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n            us2Data(data, (uint16_t) blob.size()+8, bigEndian);\n            ul2Data(data, (uint32_t) blob.size(), littleEndian);\n            if (outIo.write(data, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n            if (outIo.write((const byte*)&blob[0], static_cast<long>(blob.size())) != (long)blob.size())\n            {\n                throw Error(kerImageWriteFailed);\n            }\n            if (outIo.tell() % 2) {\n                if (outIo.write(&WEBP_PAD_ODD, 1) != 1) throw Error(kerImageWriteFailed);\n            }\n        }\n\n        if (has_xmp) {\n            if (outIo.write((const byte*)WEBP_CHUNK_HEADER_XMP, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n            ul2Data(data, (uint32_t) xmpPacket().size(), littleEndian);\n            if (outIo.write(data, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n            if (outIo.write((const byte*)xmp.data(), static_cast<long>(xmp.size())) != (long)xmp.size()) {\n                throw Error(kerImageWriteFailed);\n            }\n            if (outIo.tell() % 2) {\n                if (outIo.write(&WEBP_PAD_ODD, 1) != 1) throw Error(kerImageWriteFailed);\n            }\n        }\n\n        // Fix File Size Payload Data\n        outIo.seek(0, BasicIo::beg);\n        filesize = outIo.size() - 8;\n        outIo.seek(4, BasicIo::beg);\n        ul2Data(data, (uint32_t) filesize, littleEndian);\n        if (outIo.write(data, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n\n    } // WebPImage::writeMetadata\n\n    /* =========================================== */\n\n    void WebPImage::printStructure(std::ostream& out, PrintStructureOption option,int depth)\n    {\n        if (io_->open() != 0) {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        // Ensure this is the correct image type\n        if (!isWebPType(*io_, true)) {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \"WEBP\");\n        }\n\n        bool bPrint  = option==kpsBasic || option==kpsRecursive;\n        if ( bPrint || option == kpsXMP || option == kpsIccProfile || option == kpsIptcErase ) {\n            byte      data [WEBP_TAG_SIZE * 2];\n            io_->read(data, WEBP_TAG_SIZE * 2);\n            uint64_t filesize = Exiv2::getULong(data + WEBP_TAG_SIZE, littleEndian);\n            DataBuf  chunkId(5)      ;\n            chunkId.pData_[4] = '\\0' ;\n\n            if ( bPrint ) {\n                out << Internal::indent(depth)\n                << \"STRUCTURE OF WEBP FILE: \"\n                << io().path()\n                << std::endl;\n                out << Internal::indent(depth)\n                << Internal::stringFormat(\" Chunk |   Length |   Offset | Payload\")\n                << std::endl;\n            }\n\n            io_->seek(0,BasicIo::beg); // rewind\n            while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {\n                uint64_t offset = (uint64_t) io_->tell();\n                byte     size_buff[WEBP_TAG_SIZE];\n                io_->read(chunkId.pData_, WEBP_TAG_SIZE);\n                io_->read(size_buff, WEBP_TAG_SIZE);\n                long size = Exiv2::getULong(size_buff, littleEndian);\n                DataBuf payload(offset?size:WEBP_TAG_SIZE); // header is different from chunks\n                io_->read(payload.pData_, payload.size_);\n\n                if ( bPrint ) {\n                    out << Internal::indent(depth)\n                    << Internal::stringFormat(\"  %s | %8u | %8u | \", (const char*)chunkId.pData_,(uint32_t)size,(uint32_t)offset)\n                    << Internal::binaryToString(makeSlice(payload, 0, payload.size_ > 32 ? 32 : payload.size_))\n                    << std::endl;\n                }\n\n                if ( equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_EXIF) && option==kpsRecursive ) {\n                    // create memio object with the payload, then print the structure\n                    BasicIo::UniquePtr p = BasicIo::UniquePtr(new MemIo(payload.pData_,payload.size_));\n                    printTiffStructure(*p,out,option,depth);\n                }\n\n                bool bPrintPayload = (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_XMP) && option==kpsXMP)\n                                  || (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ICCP) && option==kpsIccProfile)\n                                   ;\n                if ( bPrintPayload ) {\n                    out.write((const char*) payload.pData_,payload.size_);\n                }\n\n                if ( offset && io_->tell() % 2 ) io_->seek(+1, BasicIo::cur); // skip padding byte on sub-chunks\n            }\n        }\n    }\n\n    /* =========================================== */\n\n    void WebPImage::readMetadata()\n    {\n        if (io_->open() != 0) throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        IoCloser closer(*io_);\n        // Ensure that this is the correct image type\n        if (!isWebPType(*io_, true)) {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAJpeg);\n        }\n        clearMetadata();\n\n        byte data[12];\n        DataBuf chunkId(5);\n        chunkId.pData_[4] = '\\0' ;\n\n        readOrThrow(*io_, data, WEBP_TAG_SIZE * 3, Exiv2::kerCorruptedMetadata);\n\n        const uint32_t filesize_u32 =\n            Safe::add(Exiv2::getULong(data + WEBP_TAG_SIZE, littleEndian), 8U);\n        enforce(filesize_u32 <= io_->size(), Exiv2::kerCorruptedMetadata);\n\n        // Check that `filesize_u32` is safe to cast to `long`.\n        enforce(filesize_u32 <= static_cast<size_t>(std::numeric_limits<unsigned int>::max()),\n                Exiv2::kerCorruptedMetadata);\n\n        WebPImage::decodeChunks(static_cast<long>(filesize_u32));\n\n    } // WebPImage::readMetadata\n\n    void WebPImage::decodeChunks(long filesize)\n    {\n        DataBuf   chunkId(5);\n        byte      size_buff[WEBP_TAG_SIZE];\n        bool      has_canvas_data = false;\n\n#ifdef EXIV2_DEBUG_MESSAGES\n        std::cout << \"Reading metadata\" << std::endl;\n#endif\n\n        chunkId.pData_[4] = '\\0' ;\n        while (!io_->eof() && io_->tell() < filesize) {\n            readOrThrow(*io_, chunkId.pData_, WEBP_TAG_SIZE, Exiv2::kerCorruptedMetadata);\n            readOrThrow(*io_, size_buff, WEBP_TAG_SIZE, Exiv2::kerCorruptedMetadata);\n\n            const uint32_t size_u32 = Exiv2::getULong(size_buff, littleEndian);\n\n            // Check that `size_u32` is safe to cast to `long`.\n            enforce(size_u32 <= static_cast<size_t>(std::numeric_limits<unsigned int>::max()),\n                    Exiv2::kerCorruptedMetadata);\n            const long size = static_cast<long>(size_u32);\n\n            // Check that `size` is within bounds.\n            enforce(io_->tell() <= filesize, Exiv2::kerCorruptedMetadata);\n            enforce(size <= (filesize - io_->tell()), Exiv2::kerCorruptedMetadata);\n\n            DataBuf payload(size);\n\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X) && !has_canvas_data) {\n                enforce(size >= 10, Exiv2::kerCorruptedMetadata);\n\n                has_canvas_data = true;\n                byte size_buf[WEBP_TAG_SIZE];\n\n                readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n\n                // Fetch width\n                memcpy(&size_buf, &payload.pData_[4], 3);\n                size_buf[3] = 0;\n                pixelWidth_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n\n                // Fetch height\n                memcpy(&size_buf, &payload.pData_[7], 3);\n                size_buf[3] = 0;\n                pixelHeight_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8) && !has_canvas_data) {\n                enforce(size >= 10, Exiv2::kerCorruptedMetadata);\n\n                has_canvas_data = true;\n                readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n                byte size_buf[WEBP_TAG_SIZE];\n\n                // Fetch width\"\"\n                memcpy(&size_buf, &payload.pData_[6], 2);\n                size_buf[2] = 0;\n                size_buf[3] = 0;\n                pixelWidth_ = Exiv2::getULong(size_buf, littleEndian) & 0x3fff;\n\n                // Fetch height\n                memcpy(&size_buf, &payload.pData_[8], 2);\n                size_buf[2] = 0;\n                size_buf[3] = 0;\n                pixelHeight_ = Exiv2::getULong(size_buf, littleEndian) & 0x3fff;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8L) && !has_canvas_data) {\n                enforce(size >= 5, Exiv2::kerCorruptedMetadata);\n\n                has_canvas_data = true;\n                byte size_buf_w[2];\n                byte size_buf_h[3];\n\n                readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n\n                // Fetch width\n                memcpy(&size_buf_w, &payload.pData_[1], 2);\n                size_buf_w[1] &= 0x3F;\n                pixelWidth_ = Exiv2::getUShort(size_buf_w, littleEndian) + 1;\n\n                // Fetch height\n                memcpy(&size_buf_h, &payload.pData_[2], 3);\n                size_buf_h[0] = ((size_buf_h[0] >> 6) & 0x3) | ((size_buf_h[1]  & 0x3F) << 0x2);\n                size_buf_h[1] = ((size_buf_h[1] >> 6) & 0x3) | ((size_buf_h[2] & 0xF) << 0x2);\n                pixelHeight_ = Exiv2::getUShort(size_buf_h, littleEndian) + 1;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANMF) && !has_canvas_data) {\n                enforce(size >= 12, Exiv2::kerCorruptedMetadata);\n\n                has_canvas_data = true;\n                byte size_buf[WEBP_TAG_SIZE];\n\n                readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n\n                // Fetch width\n                memcpy(&size_buf, &payload.pData_[6], 3);\n                size_buf[3] = 0;\n                pixelWidth_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n\n                // Fetch height\n                memcpy(&size_buf, &payload.pData_[9], 3);\n                size_buf[3] = 0;\n                pixelHeight_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ICCP)) {\n                readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n                this->setIccProfile(payload);\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_EXIF)) {\n                readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n\n                byte  size_buff2[2];\n                // 4 meaningful bytes + 2 padding bytes\n                byte  exifLongHeader[]   = { 0xFF, 0x01, 0xFF, 0xE1, 0x00, 0x00 };\n                byte  exifShortHeader[]  = { 0x45, 0x78, 0x69, 0x66, 0x00, 0x00 };\n                byte  exifTiffLEHeader[] = { 0x49, 0x49, 0x2A };       // \"MM*\"\n                byte  exifTiffBEHeader[] = { 0x4D, 0x4D, 0x00, 0x2A }; // \"II\\0*\"\n                byte* rawExifData = NULL;\n                long  offset = 0;\n                bool  s_header = false;\n                bool  le_header = false;\n                bool  be_header = false;\n                long  pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifLongHeader, 4);\n\n                if (pos == -1) {\n                    pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifLongHeader, 6);\n                    if (pos != -1) {\n                        s_header = true;\n                    }\n                }\n                if (pos == -1) {\n                    pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifTiffLEHeader, 3);\n                    if (pos != -1) {\n                        le_header = true;\n                    }\n                }\n                if (pos == -1) {\n                    pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifTiffBEHeader, 4);\n                    if (pos != -1) {\n                        be_header = true;\n                    }\n                }\n\n                if (s_header) {\n                    offset += 6;\n                }\n                if (be_header || le_header) {\n                    offset += 12;\n                }\n\n                const long sizePayload = payload.size_ + offset;\n                rawExifData = (byte*)malloc(sizePayload);\n\n                if (s_header) {\n                    us2Data(size_buff2, (uint16_t) (sizePayload - 6), bigEndian);\n                    memcpy(rawExifData, (char*)&exifLongHeader, 4);\n                    memcpy(rawExifData + 4, (char*)&size_buff2, 2);\n                }\n\n                if (be_header || le_header) {\n                    us2Data(size_buff2, (uint16_t) (sizePayload - 6), bigEndian);\n                    memcpy(rawExifData, (char*)&exifLongHeader, 4);\n                    memcpy(rawExifData + 4, (char*)&size_buff2, 2);\n                    memcpy(rawExifData + 6, (char*)&exifShortHeader, 6);\n                }\n\n                memcpy(rawExifData + offset, payload.pData_, payload.size_);\n\n#ifdef EXIV2_DEBUG_MESSAGES\n                std::cout << \"Display Hex Dump [size:\" << (unsigned long)sizePayload << \"]\" << std::endl;\n                std::cout << Internal::binaryToHex(rawExifData, sizePayload);\n#endif\n\n                if (pos != -1) {\n                    XmpData  xmpData;\n                    ByteOrder bo = ExifParser::decode(exifData_,\n                                                      payload.pData_ + pos,\n                                                      payload.size_ - pos);\n                    setByteOrder(bo);\n                }\n                else\n                {\n#ifndef SUPPRESS_WARNINGS\n                    EXV_WARNING << \"Failed to decode Exif metadata.\" << std::endl;\n#endif\n                    exifData_.clear();\n                }\n\n                if (rawExifData) free(rawExifData);\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_XMP)) {\n                readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n                xmpPacket_.assign(reinterpret_cast<char*>(payload.pData_), payload.size_);\n                if (xmpPacket_.size() > 0 && XmpParser::decode(xmpData_, xmpPacket_)) {\n#ifndef SUPPRESS_WARNINGS\n                    EXV_WARNING << \"Failed to decode XMP metadata.\" << std::endl;\n#endif\n                } else {\n#ifdef EXIV2_DEBUG_MESSAGES\n                    std::cout << \"Display Hex Dump [size:\" << (unsigned long)payload.size_ << \"]\" << std::endl;\n                    std::cout << Internal::binaryToHex(payload.pData_, payload.size_);\n#endif\n                }\n            } else {\n                io_->seek(size, BasicIo::cur);\n            }\n\n            if ( io_->tell() % 2 ) io_->seek(+1, BasicIo::cur);\n        }\n    }\n\n    /* =========================================== */\n\n    Image::UniquePtr newWebPInstance(BasicIo::UniquePtr io, bool /*create*/)\n    {\n        Image::UniquePtr image(new WebPImage(std::move(io)));\n        if (!image->good()) {\n            image.reset();\n        }\n        return image;\n    }\n\n    bool isWebPType(BasicIo& iIo, bool /*advance*/)\n    {\n        if (iIo.size() < 12) {\n          return false;\n        }\n        const int32_t len = 4;\n        const unsigned char RiffImageId[4] = { 'R', 'I', 'F' ,'F'};\n        const unsigned char WebPImageId[4] = { 'W', 'E', 'B' ,'P'};\n        byte webp[len];\n        byte data[len];\n        byte riff[len];\n        iIo.read(riff, len);\n        iIo.read(data, len);\n        iIo.read(webp, len);\n        bool matched_riff = (memcmp(riff, RiffImageId, len) == 0);\n        bool matched_webp = (memcmp(webp, WebPImageId, len) == 0);\n        iIo.seek(-12, BasicIo::cur);\n        return matched_riff && matched_webp;\n    }\n\n    /*!\n     @brief Function used to check equality of a Tags with a\n     particular string (ignores case while comparing).\n     @param buf Data buffer that will contain Tag to compare\n     @param str char* Pointer to string\n     @return Returns true if the buffer value is equal to string.\n     */\n    bool WebPImage::equalsWebPTag(Exiv2::DataBuf& buf, const char* str) {\n        for(int i = 0; i < 4; i++ )\n            if(toupper(buf.pData_[i]) != str[i])\n                return false;\n        return true;\n    }\n\n\n    /*!\n     @brief Function used to add missing EXIF & XMP flags\n     to the feature section.\n     @param  iIo get BasicIo pointer to inject data\n     @param has_xmp Verify if we have xmp data and set required flag\n     @param has_exif Verify if we have exif data and set required flag\n     @return Returns void\n     */\n    void WebPImage::inject_VP8X(BasicIo& iIo, bool has_xmp,\n                                bool has_exif, bool has_alpha,\n                                bool has_icc, int width, int height) {\n        byte size[4]  = { 0x0A, 0x00, 0x00, 0x00 };\n        byte data[10] = { 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00 };\n        iIo.write((const byte*)WEBP_CHUNK_HEADER_VP8X, WEBP_TAG_SIZE);\n        iIo.write(size, WEBP_TAG_SIZE);\n\n        if (has_alpha) {\n            data[0] |= WEBP_VP8X_ALPHA_BIT;\n        }\n\n        if (has_icc) {\n            data[0] |= WEBP_VP8X_ICC_BIT;\n        }\n\n        if (has_xmp) {\n            data[0] |= WEBP_VP8X_XMP_BIT;\n        }\n\n        if (has_exif) {\n            data[0] |= WEBP_VP8X_EXIF_BIT;\n        }\n\n        /* set width - stored in 24bits*/\n        int w = width - 1;\n        data[4] = w & 0xFF;\n        data[5] = (w >> 8) & 0xFF;\n        data[6] = (w >> 16) & 0xFF;\n\n        /* set height - stored in 24bits */\n        int h = height - 1;\n        data[7] = h & 0xFF;\n        data[8] = (h >> 8) & 0xFF;\n        data[9] = (h >> 16) & 0xFF;\n\n        iIo.write(data, 10);\n\n        /* Handle inject an icc profile right after VP8X chunk */\n        if (has_icc) {\n            byte size_buff[WEBP_TAG_SIZE];\n            ul2Data(size_buff, iccProfile_.size_, littleEndian);\n            if (iIo.write((const byte*)WEBP_CHUNK_HEADER_VP8X, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)\n                throw Error(kerImageWriteFailed);\n            if (iIo.write(size_buff, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)\n                throw Error(kerImageWriteFailed);\n            if (iIo.write(iccProfile_.pData_, iccProfile_.size_) != iccProfile_.size_)\n                throw Error(kerImageWriteFailed);\n            if (iIo.tell() % 2) {\n                if (iIo.write(&WEBP_PAD_ODD, 1) != 1) throw Error(kerImageWriteFailed);\n            }\n\n            has_icc = false;\n        }\n    }\n\n    long WebPImage::getHeaderOffset(byte* data, long data_size, byte* header, long header_size)\n    {\n        if (data_size < header_size) { return -1; }\n        long pos = -1;\n        for (long i=0; i < data_size - header_size; i++) {\n            if (memcmp(header, &data[i], header_size) == 0) {\n                pos = i;\n                break;\n            }\n        }\n        return pos;\n    }\n\n} // namespace Exiv2\n"], "filenames": ["src/webpimage.cpp"], "buggy_code_start_loc": [148], "buggy_code_end_loc": [321], "fixing_code_start_loc": [148], "fixing_code_end_loc": [341], "type": "CWE-125", "message": "Exiv2 is a command-line utility and C++ library for reading, writing, deleting, and modifying the metadata of image files. An out-of-bounds read was found in Exiv2 versions v0.27.3 and earlier. The out-of-bounds read is triggered when Exiv2 is used to write metadata into a crafted image file. An attacker could potentially exploit the vulnerability to cause a denial of service by crashing Exiv2, if they can trick the victim into running Exiv2 on a crafted image file. Note that this bug is only triggered when writing the metadata, which is a less frequently used Exiv2 operation than reading the metadata. For example, to trigger the bug in the Exiv2 command-line application, you need to add an extra command-line argument such as `insert`. The bug is fixed in version v0.27.4.", "other": {"cve": {"id": "CVE-2021-29463", "sourceIdentifier": "security-advisories@github.com", "published": "2021-04-30T19:15:07.143", "lastModified": "2022-04-05T18:02:03.357", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Exiv2 is a command-line utility and C++ library for reading, writing, deleting, and modifying the metadata of image files. An out-of-bounds read was found in Exiv2 versions v0.27.3 and earlier. The out-of-bounds read is triggered when Exiv2 is used to write metadata into a crafted image file. An attacker could potentially exploit the vulnerability to cause a denial of service by crashing Exiv2, if they can trick the victim into running Exiv2 on a crafted image file. Note that this bug is only triggered when writing the metadata, which is a less frequently used Exiv2 operation than reading the metadata. For example, to trigger the bug in the Exiv2 command-line application, you need to add an extra command-line argument such as `insert`. The bug is fixed in version v0.27.4."}, {"lang": "es", "value": "Exiv2 es una utilidad de l\u00ednea de comandos y una biblioteca C++ para leer, escribir, eliminar y modificar los metadatos de archivos de imagen.&#xa0;Se encontr\u00f3 una lectura fuera de l\u00edmites en Exiv2 versiones v0.27.3 y anteriores.&#xa0;La lectura fuera de l\u00edmites es activada cuando se usa Exiv2 para escribir metadatos en un archivo de imagen dise\u00f1ado.&#xa0;Un atacante podr\u00eda explotar potencialmente la vulnerabilidad para causar una denegaci\u00f3n de servicio al bloquear Exiv2, si puede enga\u00f1ar a la v\u00edctima para que ejecute Exiv2 en un archivo de imagen dise\u00f1ado.&#xa0;Tome en cuenta que este bug solo es activado al escribir los metadatos, que es una operaci\u00f3n Exiv2 que es usado con menos frecuencia que leer los metadatos.&#xa0;Por ejemplo, para desencadenar el bug en la aplicaci\u00f3n de l\u00ednea de comandos Exiv2, es necesario agregar un argumento de l\u00ednea de comando adicional como \"insert\".&#xa0;El bug se corrigi\u00f3 en la versi\u00f3n v0.27.4."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:exiv2:exiv2:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.27.4", "matchCriteriaId": "0A049EBD-7A7E-458F-9ABD-F6626DDEABB9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}], "references": [{"url": "https://github.com/Exiv2/exiv2/commit/783b3a6ff15ed6f82a8f8e6c8a6f3b84a9b04d4b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Exiv2/exiv2/security/advisories/GHSA-5p8g-9xf3-gfrr", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/K3HKXR6JOVKMBE4HY4FDXNVZGNCQG6T3/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/NDMZTVQAZSMLPTDVDYLBHAAF7I5QXVYQ/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Exiv2/exiv2/commit/783b3a6ff15ed6f82a8f8e6c8a6f3b84a9b04d4b"}}