{"buggy_code": ["#! /usr/bin/python -Es\n#\n# Authors: John Dennis <jdennis@redhat.com>\n# Authors: Dan Walsh <dwalsh@redhat.com>\n#\n# Copyright (C) 2006-2010 Red Hat, Inc.\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n#\n\nimport syslog\nimport setroubleshoot.default_encoding_utf8\nimport gobject\ngobject.set_prgname('setroubleshoot') \nimport dbus\nimport dbus.glib\nimport dbus.service\nimport errno as Errno\nimport gettext\nimport os\nimport Queue\nimport re\nimport signal\nimport selinux\nimport socket as Socket\nimport fcntl\nimport sys\nimport slip.dbus.service\n\nfrom setroubleshoot.config import parse_config_setting, get_config\ndomain = get_config('general', 'i18n_text_domain')\ngettext.install(domain    = domain,\n                unicode = True,\n                localedir = get_config('general', 'i18n_locale_dir'))\n\nsyslog.openlog(sys.argv[0])\nfrom setroubleshoot.errcode import *\nfrom setroubleshoot.util import get_identity, load_plugins, log_debug\nfrom setroubleshoot.rpc import *\n\n#------------------------------------------------------------------------------\ninvocation_style = None\nstatus_icon = None\ndbus_system_bus_name = get_config('system_dbus','bus_name')\ndbus_system_object_path = get_config('system_dbus','object_path')\ndbus_system_interface = get_config('system_dbus','interface')\n\ndbus_session_bus_name = get_config('session_dbus','bus_name')\ndbus_session_object_path = get_config('session_dbus','object_path')\ndbus_session_interface = get_config('session_dbus','interface')\napp = None\ndefault_status_icon_tooltip = _(\"SELinux AVC denial, click to view\")\n#------------------------------------------------------------------------------\ndef sighandler(signum, frame):\n    log_debug(\"exiting on signal %s\" % signum)\n    sys.exit()\n\ndef get_server_socket_address():\n    addr_list = get_socket_list_from_config('client_connect_to')\n    if len(addr_list) == 0: return None\n    return addr_list[0]\n\ndef setup_sighandlers():\n    signal.signal(signal.SIGHUP,  sighandler)\n    signal.signal(signal.SIGQUIT, sighandler)\n    signal.signal(signal.SIGTERM, sighandler)\n\ndef run_app(user):\n    global app\n\n    from setroubleshoot.serverconnection import ServerConnectionHandler\n    gobject.type_register(ServerConnectionHandler)\n\n    app = SEAlert(user)\n    return app.main()    \n\ndef error(message):\n    dlg = gtk.MessageDialog(None, 0, gtk.MESSAGE_ERROR,\n                            gtk.BUTTONS_CLOSE,\n                            message)\n    dlg.set_position(gtk.WIN_POS_MOUSE)\n    dlg.show_all()\n    dlg.run()\n    dlg.destroy()\n\ndef run_as_dbus_service(user):\n    global app\n#-----------------------------------------------------------------------------\n    if not selinux.is_selinux_enabled():\n        log_debug(\"SELinux not enabled, sealert will not run on non SELinux systems\")\n        error(_(\"SELinux not enabled, sealert will not run on non SELinux systems\"))\n        sys.exit(3)\n\n    try:\n        log_debug('starting service')\n        dbus_service = DBusSessionService(dbus_session_bus_name)\n        app = SEAlert(user, dbus_service.presentation_manager, watch_setroubleshootd=True)\n        return app.main()    \n    except dbus.DBusException, e:\n        syslog.syslog(syslog.LOG_ERR, 'could not start dbus: %s' % str(e))\n        return False\n\ndef ask_dbus_to_show_browser():\n    try:\n        bus = dbus.SessionBus()\n        proxy_obj = bus.get_object(dbus_session_bus_name, dbus_session_object_path)\n        iface = dbus.Interface(proxy_obj, dbus_session_interface)\n        return True\n    except dbus.DBusException, e:\n        syslog.syslog(syslog.LOG_ERR, 'could not start dbus: %s' % str(e))\n        return False\n\ndef ask_dbus_to_quit_app():\n    try:\n        bus = dbus.SessionBus()\n        proxy_obj = bus.get_object(dbus_session_bus_name, dbus_session_object_path)\n        iface = dbus.Interface(proxy_obj, dbus_session_interface)\n        iface.quit_app()    \n        return True\n    except dbus.DBusException, e:\n        syslog.syslog(syslog.LOG_ERR, 'could not start dbus: %s' % str(e))\n        return False\n\ndef fix_lookup_id(local_id, analysis_id):\n    def lookup_local_id():\n        log_debug(\"calling server to lookup id (%s)\" % local_id)\n        async_rpc = cl.alert_client.query_alerts(local_id)\n        async_rpc.add_callback(query_alerts_callback)\n        async_rpc.add_errback(query_alerts_error)\n\n    def query_alerts_callback(sigs):\n        import commands\n        for siginfo in sigs.signature_list:\n            for plugin  in siginfo.plugin_list:\n                if analysis_id == plugin.analysis_id:\n                    p = load_plugins(analysis_id)[0]\n                    if p.fixable == False:\n                        print _(\"Not fixable.\")\n                        cl.main_loop.quit()\n                        return\n                    siginfo.update_derived_template_substitutions()\n                    command = siginfo.substitute(p.get_fix_cmd(siginfo.audit_event, plugin.args))\n                    rc, output = commands.getstatusoutput(command)\n                    if rc == 0:\n                        print _(\"Successfully ran %s\" % command)\n                    else:\n                        print output\n                    cl.main_loop.quit()\n                    return\n        print _(\"Plugin %s not valid for %s id\") % (analysis_id, local_id)\n        cl.main_loop.quit()\n\n    def query_alerts_error(method, errno, strerror):\n        print >> sys.stderr, \"%s error (%d): %s\" % (method, errno, strerror)\n        cl.main_loop.quit()\n\n    cl = SECommandLine(lookup_local_id)\n    cl.run()\n\n\ndef command_line_lookup_id(local_id, html=False):\n    global err;\n    err=None\n    def lookup_local_id():\n        log_debug(\"calling server to lookup id (%s)\" % local_id)\n        async_rpc = cl.alert_client.query_alerts(local_id)\n        async_rpc.add_callback(query_alerts_callback)\n        async_rpc.add_errback(query_alerts_error)\n\n    def query_alerts_callback(sigs):\n        for siginfo in sigs.signature_list:\n            print siginfo.format_text()\n            print siginfo.format_details()\n        cl.main_loop.quit()\n\n    def query_alerts_error(method, errno, strerror):\n        global err\n        cl.main_loop.quit()\n        err = \"%s error (%d): %s\" % (method, errno, strerror)\n\n    cl = SECommandLine(lookup_local_id)\n    cl.run()\n    if err:\n        print \"Error\"\n        raise ValueError(err)\n\n#-----------------------------------------------------------------------------\n\nclass PresentationManager(gobject.GObject):\n    __gsignals__ = {\n        'show_browser':\n        (gobject.SIGNAL_RUN_LAST, gobject.TYPE_NONE, (gobject.TYPE_PYOBJECT,)),\n        'quit_app':\n        (gobject.SIGNAL_RUN_LAST, gobject.TYPE_NONE, ()),\n        }\n\n    def __init__(self):\n        gobject.GObject.__init__(self)\n\n    def show_browser(self, data_name = None):\n        self.emit('show_browser', data_name)\n\n    def quit_app(self):\n        self.emit('quit_app')\n\ngobject.type_register(PresentationManager)\n\n#-----------------------------------------------------------------------------\n\nclass SETroubleshootdDBus(gobject.GObject):\n    __gsignals__ = {\n        'state_change':\n        (gobject.SIGNAL_RUN_LAST, gobject.TYPE_NONE, (gobject.TYPE_PYOBJECT,)),\n        'restart_request':\n        (gobject.SIGNAL_RUN_LAST, gobject.TYPE_NONE, (gobject.TYPE_PYOBJECT,)),\n        }\n\n    def __init__(self):\n        gobject.GObject.__init__(self)\n\n        self.bus = dbus.SystemBus()\n\n        proxy_obj = self.bus.get_object(dbus_system_bus_name, dbus_system_object_path)\n        self.iface = dbus.Interface(proxy_obj, dbus_system_interface)\n        s = self.iface.start()\n        log_debug(\"starting setroubleshootd service\")\n\n        self.bus.add_signal_receiver(self.on_dbus_name_owner_change, 'NameOwnerChanged',\n                                     'org.freedesktop.DBus', 'org.freedesktop.DBus', '/org/freedesktop/DBus',\n                                     arg0=dbus_system_bus_name)\n\n\n        # Note: this signal can be emitted from the command line via\n        # dbus-send --system $dbus_system_object_path $dbus_system_interface.restart string:\"reason\"\n        self.bus.add_signal_receiver(self.do_restart, 'restart', dbus_system_interface, None, dbus_system_object_path)\n\n    def finish(self):\n        log_debug(\"exiting dbus\")\n        s = self.iface.finish()\n\n    def __del__(self):\n        log_debug(\"exiting dbus\")\n        s = self.iface.finish()\n\n    def on_dbus_name_owner_change(self, name, old_owner, new_owner):\n        log_debug(\"on_dbus_name_owner_change: name=%s old_owner=%s new_owner=%s\" % (name, old_owner, new_owner))\n        if not old_owner and new_owner:\n            log_debug(\"setroubleshootd: came on line\")\n            self.emit('state_change', 'run')\n        elif old_owner and not new_owner:\n            log_debug(\"setroubleshootd: went off line\")\n            self.emit('state_change', 'stop')\n        elif not old_owner and not new_owner:\n            log_debug(\"setroubleshootd: no connection\")\n            self.emit('state_change', 'stop')\n        elif old_owner and new_owner:\n            log_debug(\"setroubleshootd: owner change\")\n        else:\n            log_debug(\"don't know how to parse old_owner(%s) new_owner(%s)\" % (old_owner, new_owner))\n\n    def do_restart(self, reason):\n        log_debug(\"do_restart(%s)\" % reason)\n        self.emit('restart_request', reason)\n\ngobject.type_register(SETroubleshootdDBus)\n\n#-----------------------------------------------------------------------------\n\nclass DBusSessionService(dbus.service.Object):\n    def __init__(self, bus_name):\n        bus = dbus.SessionBus()\n        bus_name = dbus.service.BusName(dbus_session_bus_name, bus = bus)\n        dbus.service.Object.__init__(self, bus_name, dbus_session_object_path)\n\n        self.presentation_manager = PresentationManager()\n\n    @dbus.service.method(dbus_session_interface)\n    def start(self):\n        return _(\"Started\")\n\n    @dbus.service.method(dbus_session_interface)\n    def show_browser(self):\n        log_debug('dbus iface show_browser() called',)\n        self.presentation_manager.show_browser()\n        return \"\"\n\n    @dbus.service.method(dbus_session_interface)\n    def quit_app(self):\n        log_debug('quit_app() called')\n        self.presentation_manager.quit_app()\n\n#-----------------------------------------------------------------------------\n\nclass SEAlert(object):\n    \"\"\"\n    The SEAlert object represents a gui client for setroubleshoot. It\n    processes alerts and presents the user with an appropriate user\n    interface for handling the alert. Most of the interface code\n    is in BrowserApplet and StatusIcon. This class is mainly a central\n    hub for processing the alerts.\n    \"\"\"\n    def __init__(self, username, presentation_manager = None, watch_setroubleshootd = False):\n        from setroubleshoot.serverconnection import ServerConnectionHandler\n        gobject.type_register(ServerConnectionHandler)\n\n        try:\n            self.username = username\n            from setroubleshoot.browser import BrowserApplet\n\n            if presentation_manager is None:\n                self.presentation_manager = PresentationManager()\n                gobject.idle_add(self.show_browser_at_startup)\n            else:\n                self.presentation_manager = presentation_manager\n\n            self.browser = None\n\n            self.alert_siginfo = None\n\n            if watch_setroubleshootd:\n                self.setroubleshootd_dbus = SETroubleshootdDBus()\n                self.setroubleshootd_dbus.connect('state_change', self.on_setroubleshootd_state_change)\n            else:\n                self.setroubleshootd_dbus = None\n\n            self.alert_client = ServerConnectionHandler(self.username)\n            self.alert_client.open(get_server_socket_address())\n            self.browser = BrowserApplet(self.username, self.alert_client, domain=domain)\n            self.presentation_manager.connect('show_browser', self.on_show_browser)\n            self.presentation_manager.connect('quit_app', self.on_quit)\n\n            self.alert_client.connect('alert', self.alert)\n\n            # If there is no presentation mananger make sure when the\n            # user closes the window the whole application exits. When running\n            # in \"alert\" mode we want the application to persist in the background\n            self.browser.window_delete_hides = False\n\n        except ProgramError, e:\n            syslog.syslog(syslog.LOG_ERR, e.strerror)\n            sys.exit(1)\n\n    def finish(self):\n        if  self.setroubleshootd_dbus != None:\n            self.setroubleshootd_dbus.finish()\n\n    def main(self):\n        log_debug('creating main GUI application')\n        try:\n            gtk.main()\n            self.finish()\n        except IOError, e:\n            syslog.syslog(syslog.LOG_ERR, str(e))\n            print >>sys.stderr, e\n            sys.exit(1)\n            \n        except KeyboardInterrupt, e:\n            log_debug(\"got KeyboardInterrupt, exiting ...\")\n            self.alert_client.close_connection(ConnectionState.HUP)\n            self.finish()\n            sys.exit()\n\n    def alert(self, alert_client, siginfo):\n        log_debug(\"evaluating alert\")\n\n        def alert_filter_result(result):\n            pass\n\n        self.alert_siginfo = siginfo\n        async_rpc = self.browser.server.evaluate_alert_filter(siginfo.sig, self.username)\n        async_rpc.add_callback(alert_filter_result)\n\n    def show_browser_at_startup(self):\n        self.presentation_manager.show_browser()\n        return False\n\n    def show_browser(self, data_name):\n        if data_name is not None:\n            self.browser.do_visit(data_name)\n\n        log_debug(\"SEAlert.show_browser(): data_name=%s\" % data_name)\n        self.browser.show()\n        return True\n\n    def on_quit(self, widget):\n        if self.alert_client is not None:\n            self.alert_client.close_connection(ConnectionState.HUP)\n        gtk.main_quit()\n\n    def on_show_browser(self, widget, data_name):\n        self.show_browser(data_name)\n\n    def on_setroubleshootd_state_change(self, setroubleshootd_dbus, state):\n        log_debug('setroubleshootd state change (%s)' % state)\n        if state == 'run':\n            self.alert_client.open()\n\n    def on_restart_request(self, setroubleshootd_dbus, reason):\n        log_debug('restart request: reason = %s' % reason)\n        do_restart()\n        return False\n        \n\ndef do_restart():\n    log_debug(\"restarting application...)\")\n    window_state = None\n    geometry = None\n    if app is not None:\n        if app.browser is not None:\n            window_state, visibility_state = app.browser.get_window_state()\n            geometry = app.browser.get_geometry()\n            os.environ['SEALERT_WINDOW_STATE'] = window_state\n            os.environ['SEALERT_WINDOW_GEOMETRY'] = geometry\n    log_debug(\"restarting %s: args=%s window_state=%s geometry=%s\" % (sys.argv[0], sys.argv[1:], window_state, geometry))\n    os.execv(sys.argv[0], sys.argv)\n\n#-----------------------------------------------------------------------------\n\nclass SECommandLine(object):\n    def __init__(self, func):\n        from setroubleshoot.serverconnection import ServerConnectionHandler\n        self.username = get_identity()\n        self.func = func\n\n        self.alert_client = ServerConnectionHandler(self.username)\n        self.alert_client.connect('connection_state_changed', self.on_connection_state_change)\n        self.main_loop = gobject.MainLoop()\n\n\n    def async_error_callback(self, method, errno, strerror):\n        print >> sys.stderr, \"%s error (%d): %s\" % (method, errno, strerror)\n        sys.exit(1)\n\n    def do_logon(self):\n        def logon_callback(pkg_version, rpc_version):\n            log_debug(\"logon_callback(): pkg_version=%s rpc_version=%s\" % (pkg_version, rpc_version))\n            self.alert_client.connection_state.update(ConnectionState.AUTHENTICATED)\n\n        log_debug(\"logon: %s\" % self.username)\n\n        self.alert_client.channel_name = self.username\n        async_rpc = self.alert_client.logon(self.alert_client.channel_type, self.username, 'passwd')\n        async_rpc.add_callback(logon_callback)\n        async_rpc.add_errback(self.async_error_callback)\n\n    def on_connection_state_change(self, connection, connection_state, flags, flags_added, flags_removed):\n        log_debug(\"%s.on_connection_state_change: connection_state=%s flags_added=%s flags_removed=%s address=%s\" % (self.__class__.__name__, connection_state, connection_state.flags_to_string(flags_added), connection_state.flags_to_string(flags_removed), connection.socket_address))\n\n        if flags_added & ConnectionState.ERROR:\n            errno, strerror = connection_state.get_result()\n            print >> sys.stderr, \"failed to connect to server: %s\" % (strerror)\n            sys.exit(1)\n\n        if flags_added & ConnectionState.OPEN:\n            self.do_logon()\n\n        if flags_added & ConnectionState.AUTHENTICATED:\n            self.func()\n\n    def run(self):\n        log_debug('executing command line application')\n        self.alert_client.open(get_server_socket_address())\n        try:\n            self.main_loop.run()\n        except KeyboardInterrupt, e:\n            sys.exit()\n\n#-----------------------------------------------------------------------------\n\nclass ScanLogfile:\n    def __init__(self, logfile_path):\n        from setroubleshoot.analyze import LogfileAnalyzer\n        self.analyzer = LogfileAnalyzer(logfile_path)\n        self.main_loop = gobject.MainLoop()\n        if sys.stdout.isatty():\n            self.analyzer.connect('progress', self.on_progress)\n        self.analyzer.connect('state-changed', self.on_analyzer_state_change)\n        \n    def on_progress(self, analyzer, progress):\n        output = \"\\r%3d%% done\" % (progress*100)\n        sys.stdout.write(output)\n        sys.stdout.flush()\n\n    def on_analyzer_state_change(self, analyzer, state):\n        if state == 'stopped':\n            if analyzer.strerror:\n                print >> sys.stderr, \"ERROR: %s\" % analyzer.strerror\n            log_debug(\"analyzer stopped\")\n            self.main_loop.quit()\n            self.output_results()\n\n    def scan_file(self):\n        self.analyzer.cancelled = False\n        self.analyzer.open()\n        self.analyzer.run()\n        self.main_loop.run()\n\n    def output_results(self):\n        sigs = self.analyzer.database.query_alerts('*')\n        seperator = '-'*80 + '\\n'\n        print \"\\nfound %d alerts in %s\" % (len(sigs.signature_list), self.analyzer.logfile_path)\n        for siginfo in sigs.signature_list:\n            print seperator\n            print siginfo.format_text()\n            print siginfo.format_details()\n\ndef do_analyze_logfile(logfile_path):\n    import selinux.audit2why as audit2why\n    audit2why.init()\n    scanner = ScanLogfile(logfile_path)\n    scanner.scan_file()\n    audit2why.finish()\n        \n#-----------------------------------------------------------------------------\n\ndef display_terminal_traceback(who):\n    import traceback\n    stacktrace = traceback.format_exc()\n    print _(\"Opps, %s hit an error!\" % who) + '\\n\\n' +stacktrace\n\ntry:\n    from setroubleshoot.gui_utils import display_traceback\nexcept:\n    def display_traceback(who):\n        display_terminal_traceback(who)\n\n# -- Main --\nif __name__ == '__main__':\n    use_terminal = False\n    setup_sighandlers()\n    log_debug(\"main() args=%s\" % sys.argv)\n\n    def validate_invocation_style(opt, opts_instance, conflict_opts):\n        global invocation_style\n        conflict_opts.remove(opt)\n        invocation_style = opt\n        for i in conflict_opts:\n            if (getattr(opts_instance,i)):\n                    print >> sys.stderr, \"cannot run as %s with other option\" % (opt)\n                    sys.exit(3)\t\t\t\t\t\n\n    try:\n        from optparse import OptionParser\n        parser = OptionParser()\n\n        parser.add_option(\"-b\", \"--browser\", action=\"store_true\", dest=\"browser\", default=False,\n                            help=\"Launch the browser\")\n        parser.add_option(\"-s\", \"--service\", action=\"store_true\", dest=\"service\", default=False,\n                            help=\"Start sealert as a dbus service\")\n        parser.add_option(\"-S\", \"--noservice\", action=\"store_true\", dest=\"noservice\", default=False,\n                            help=\"Start sealert without dbus service as stand alone app\")\n        parser.add_option(\"-l\", \"--lookupid\", dest=\"lookupid\", default=False,\n                            help=\"Lookup alert by id, id may be wildcard * to lookup all alerts\")\n        parser.add_option(\"-a\", \"--analyze\", dest=\"analyze\",  default=False,\n                            help=\"Scan a log file, analyze it's AVC's\", metavar=\"FILE\")\n        parser.add_option(\"-u\", \"--user\",  dest=\"user\", default=False,\n                            help=\"logon user name\")\n        parser.add_option(\"-p\", \"--password\", dest=\"password\", default=False,\n                            help=\"logon user password\")\n        parser.add_option(\"-P\", \"--plugin\", dest=\"plugin\", default=False,\n                            help=\"Plugin Name Required for -f\")\n        parser.add_option(\"-f\", \"--fix\", dest=\"fix\", default=False,\n                            help=\"fix avc with the given uuid, requires plugin\")\n\n        conflict_opts = [\"analyze\", \"browser\", \"fix\", \"lookupid\", \"noservice\", \"service\"]\n        username = None\n        password = None\n        plugin_name = None\n\n        (options, args) = parser.parse_args()\n\n        if options.user:\n            username = options.user\n        else:\n            username = get_identity()\n\n        if options.password:\n            password = options.password    \n        else:\n            password = 'passwd'\n\n        if options.browser:\n            validate_invocation_style(\"browser\", options, conflict_opts)\n      \n        if options.service:\n            validate_invocation_style(\"service\", options, conflict_opts)\n\n        if options.noservice:\n            validate_invocation_style(\"noservice\", options, conflict_opts)\n\n        if options.lookupid:\n            validate_invocation_style(\"lookupid\", options, conflict_opts)\n            local_id = options.lookupid\n\n        if options.analyze:\n            validate_invocation_style(\"analyze\", options, conflict_opts)\n            use_terminal = True\n            logfile = options.analyze\n\n        if options.plugin:\n            plugin_name = options.plugin\n\n        if options.fix:\n            validate_invocation_style(\"fix\", options, conflict_opts)\n            local_id = options.fix\n            if options.plugin:\n                plugin_name = options.plugin\n            else:\n                print >> sys.stderr, \"-P plugin_name required for fix\"\n                sys.exit(3)\n\n        # Attempt to communicate with the service.  DBus should start it if it is not\n        # running, otherwise we will become the service\n        if invocation_style is None:\n            log_debug(\"invocation style not set, asking dbus to start us\")\n            try:\n                bus = dbus.SessionBus()\n                proxy_obj = bus.get_object(dbus_session_bus_name, dbus_session_object_path)\n                iface = dbus.Interface(proxy_obj, dbus_session_interface)\n                s = iface.start()\n            except dbus.DBusException:\n                print >> sys.stderr, \"could not attach to desktop process\"\n                sys.exit(1)\n            sys.exit()\n\n            log_debug(\"invocation style = '%s'\" % invocation_style)\n\n        if invocation_style == 'browser':\n            ask_dbus_to_show_browser()\n            sys.exit()\n        elif invocation_style == 'service':\n            try:\n                # This import must come before importing gtk to silence warnings\n                import gtk\n                run_as_dbus_service(username)\n            except RuntimeError, e:\n                print e\n                sys.exit(3)\n            sys.exit()\n        elif invocation_style == 'noservice':\n            # This import must come before importing gtk to silence warnings\n            import gtk\n            run_app(username)\n            sys.exit()\n        elif invocation_style == 'lookupid':\n            use_terminal = True\n\n            from setroubleshoot.signature import *\n            try:\n                # make sure setroubleshoot is running\n                bus = dbus.SystemBus()\n                proxy_obj = bus.get_object(dbus_system_bus_name, dbus_system_object_path)\n                iface = dbus.Interface(proxy_obj, dbus_system_interface)\n                iface.start()\n                command_line_lookup_id(local_id)\n                iface.finish()\n            except ValueError, e:\n                print >> sys.stderr, e\n                sys.exit(3)\n\n            sys.exit()\n        elif invocation_style == 'analyze':\n            use_terminal = True\n\n            try:\n                do_analyze_logfile(logfile)\n            except OSError, e:\n                print e\n                sys.exit(3)\n            except ProgramError, e:\n                print >> sys.stderr, e.strerror\n                sys.exit(3)\n                \n        elif invocation_style == 'fix':\n            use_terminal = True\n\n            from setroubleshoot.signature import *\n            try:\n                bus = dbus.SystemBus()\n                proxy_obj = bus.get_object(dbus_system_bus_name, dbus_system_object_path)\n                iface = dbus.Interface(proxy_obj, dbus_system_interface)\n                iface.start()\n\n                fix_lookup_id(local_id, plugin_name)\n                iface.finish()\n            except dbus.DBusException, e:\n                print >> sys.stderr, \"could not attach to desktop process\"\n                sys.exit(3)\n                \n            sys.exit()\n        else:\n            print >> sys.stderr, \"unknown invocation style (%s)\" % invocation_style\n            sys.exit(3)\n    except Exception, e:\t\n        syslog.syslog(syslog.LOG_ERR, \"exception %s: %s\" % (e.__class__.__name__, str(e)))\n        if use_terminal:\n            display_terminal_traceback('sealert')\n        else:\n            display_traceback('sealert')\n\n        sys.exit(3)\n", "# Authors: John Dennis <jdennis@redhat.com>\n#          Thomas Liu <tliu@redhat.com>\n#          Dan Walsh <dwalsh@redhat.com>\n#\n# Copyright (C) 2006-2010 Red Hat, Inc.\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n#\nimport syslog\nfrom subprocess import *\nimport setroubleshoot.default_encoding_utf8\nimport gettext\ntranslation=gettext.translation('setroubleshoot-plugins', fallback=True)\n_=translation.ugettext\n\n__all__ = [\n           'SignatureMatch',\n           'SEFilter',\n           'SEFaultSignature',\n           'SEFaultSignatureInfo',\n           'SEFaultSignatureSet',\n           'SEFaultSignatureUser',\n           'SEEnvironment',\n           'SEDatabaseProperties',\n           'SEFaultUserInfo',\n           'SEFaultUserSet',\n           'SEPlugin',\n           'SEEmailRecipient',\n           'SEEmailRecipientSet',\n\n           'FILTER_NEVER',\n           'FILTER_ALWAYS',\n           'FILTER_AFTER_FIRST',\n           'filter_text'\n           ]\n\nif __name__ == \"__main__\":\n    import gettext\n    from setroubleshoot.config import parse_config_setting, get_config\n    gettext.install(domain    = get_config('general', 'i18n_text_domain'),\n\t\t    localedir = get_config('general', 'i18n_locale_dir'))\n\nfrom gettext import ngettext as P_\nfrom setroubleshoot.config import get_config\nfrom setroubleshoot.errcode import *\nfrom setroubleshoot.util import *\nfrom setroubleshoot.xml_serialize import *\nfrom setroubleshoot.html_util import *\nimport setroubleshoot.uuid as uuid\nfrom setroubleshoot.audit_data import *\nimport hashlib\nfrom types import *\nfrom string import Template\nimport re, os\n\n# Don't reuse the numeric values!\nFILTER_NEVER              = 0\nFILTER_ALWAYS             = 4\nFILTER_AFTER_FIRST        = 8\n\nfilter_text = {\n    FILTER_NEVER              : _(\"Never Ignore\"),\n    FILTER_ALWAYS             : _(\"Ignore Always\"),\n    FILTER_AFTER_FIRST        : _(\"Ignore After First Alert\"),\n    }\n\nmap_filter_value_to_name = {\n    FILTER_NEVER              : 'never',\n    FILTER_ALWAYS             : 'always',\n    FILTER_AFTER_FIRST        : 'after_first',\n    }\n\nmap_filter_name_to_value = {\n    'never'                   : FILTER_NEVER,\n    'always'                  : FILTER_ALWAYS,\n    'after_first'             : FILTER_AFTER_FIRST,\n    }\n\n#------------------------------------------------------------------------\n\nclass SignatureMatch(object):\n    def __init__(self, siginfo, score):\n        self.siginfo = siginfo\n        self.score = score\n\n\nclass SEEnvironment(XmlSerialize):\n    _xml_info = {\n    'version'             : {'XMLForm':'attribute','default':lambda: '1.0' },\n    'platform'            : {'XMLForm':'element' },\n    'kernel'              : {'XMLForm':'element' },\n    'policy_type'         : {'XMLForm':'element' },\n    'policy_rpm'          : {'XMLForm':'element' },\n    'enforce'             : {'XMLForm':'element' },\n    'selinux_enabled'     : {'XMLForm':'element', 'import_typecast':boolean, },\n    'selinux_mls_enabled' : {'XMLForm':'element', 'import_typecast':boolean, },\n    'policyvers'          : {'XMLForm':'element' },\n    'hostname'            : {'XMLForm':'element' },\n    'uname'               : {'XMLForm':'element' },\n    }\n\n    def __init__(self):\n        super(SEEnvironment, self).__init__()\n        self.update()\n\n    def update(self):\n        import platform\n        import selinux\n        # security_getenforce is the same as the getenforce command.\n        # selinux_getenforcemode tells you what is set in /etc/selinux/config\n\n        self.platform, self.kernel = get_os_environment()\n        self.policy_type = selinux.selinux_getpolicytype()[1]\n        self.policy_rpm = get_rpm_nvr_by_name(\"selinux-policy\")\n        self.policyvers = str(selinux.security_policyvers())\n        enforce = selinux.security_getenforce()\n        if enforce == 0:\n            self.enforce = \"Permissive\"\n        else:\n            self.enforce = \"Enforcing\"\n\n        self.selinux_enabled = bool(selinux.is_selinux_enabled())\n        self.selinux_mls_enabled = bool(selinux.is_selinux_mls_enabled())\n        self.hostname = platform.node()\n        self.uname = \" \".join(platform.uname())\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __eq__(self, other):\n        for name in self._xml_info.keys():\n            if getattr(self, name) != getattr(other, name):\n                return False\n        return True\n\n\n\nclass SEFilter(XmlSerialize):\n    _xml_info = {\n    'filter_type'      : {'XMLForm':'element', 'import_typecast':int, 'default':lambda: FILTER_NEVER },\n    'count'            : {'XMLForm':'element', 'import_typecast':int, 'default':lambda: 0 },\n    }\n    def __init__(self, filter_type=FILTER_NEVER):\n        super(SEFilter, self).__init__()\n        self.filter_type = filter_type\n        \n\nclass SEFaultSignatureUser(XmlSerialize):\n    _xml_info = {\n    'username'         : {'XMLForm':'attribute' },\n    'seen_flag'        : {'XMLForm':'attribute', 'import_typecast':boolean, 'default': lambda: False },\n    'delete_flag'      : {'XMLForm':'attribute', 'import_typecast':boolean, 'default': lambda: False },\n    'filter'           : {'XMLForm':'element', 'import_typecast':SEFilter, 'default': lambda: SEFilter() },\n    }\n    def __init__(self, username):\n        super(SEFaultSignatureUser, self).__init__()\n        self.username = username\n        \n    def update_item(self, item, data):\n        if not item in self._names:\n            raise ProgramError(ERR_NOT_MEMBER, 'item (%s) is not a defined member' % item)\n\n        if item == 'username':\n            raise ProgramError(ERR_ILLEGAL_USER_CHANGE, 'changing the username is illegal')\n            \n        setattr(self, item, data)\n\n    def update_filter(self, filter_type, data=None):\n        log_debug(\"update_filter: filter_type=%s data=%s\" % (map_filter_value_to_name.get(filter_type, 'unknown'), data))\n        if filter_type == FILTER_NEVER or \\\n           filter_type == FILTER_AFTER_FIRST or \\\n           filter_type == FILTER_ALWAYS:\n            log_debug(\"update_filter: !!!\")\n            self.filter = SEFilter(filter_type=filter_type)\n            return True\n        else:\n            raise ValueError(\"Bad filter_type (%s)\" % filter_type)\n\n\nclass_dict = {}\nclass_dict['dir']     = _(\"directory\")\nclass_dict['sem']     = _(\"semaphore\")\nclass_dict['shm']     = _(\"shared memory\")\nclass_dict['msgq']    = _(\"message queue\")\nclass_dict['msg']     = _(\"message\")\nclass_dict['file']    = _(\"file\")\nclass_dict['socket']  = _(\"socket\")\nclass_dict['process'] = _(\"process\")\nclass_dict['filesystem'] = _(\"filesystem\")\nclass_dict['node'] = _(\"node\")\nclass_dict['capability'] = _(\"capability\")\n\ndef translate_class(tclass):\n    if tclass in class_dict.keys():\n        return class_dict[tclass]\n    return tclass\n\n# --\n\nclass AttributeValueDictionary(XmlSerialize):\n    _xml_info = 'unstructured'\n    def __init__(self):\n        super(AttributeValueDictionary, self).__init__()\n\nclass SEFaultSignature(XmlSerialize):\n    _xml_info = {\n    'version'          : {'XMLForm':'attribute','default':lambda: '4.0', },\n    'host'             : {'XMLForm':'element', },\n    'access'           : {'XMLForm':'element', 'list':'operation', },\n    'scontext'         : {'XMLForm':'element', 'import_typecast':AvcContext },\n    'tcontext'         : {'XMLForm':'element', 'import_typecast':AvcContext },\n    'tclass'           : {'XMLForm':'element', },\n    'port'             : {'XMLForm':'element', 'import_typecast':int, },\n    }\n    def __init__(self, **kwds):\n        super(SEFaultSignature, self).__init__()\n        for k,v in kwds.items():\n            setattr(self, k, v)\n        \nclass SEPlugin(XmlSerialize):\n    _xml_info = {\n    'analysis_id'          : {'XMLForm':'element'},\n    'args'                 : {'XMLForm':'element', 'list':'arg', },\n    }\n\n    def __init__(self, analysis_id, args):\n        super(SEPlugin, self).__init__()\n        self.analysis_id = analysis_id;\n        self.args = args;\n\n    def __str__(self):\n        return str((self.analysis_id, self.args))\n\nclass SEFaultSignatureInfo(XmlSerialize):\n    _xml_info = {\n        'plugin_list'       : {'XMLForm':'element', 'list':'plugin', 'import_typecast':SEPlugin },\n        'audit_event'      : {'XMLForm':'element', 'import_typecast':AuditEvent },\n        'source'           : {'XMLForm':'element' },\n        'spath'            : {'XMLForm':'element' },\n        'tpath'            : {'XMLForm':'element' },\n        'src_rpm_list'     : {'XMLForm':'element', 'list':'rpm', },\n        'tgt_rpm_list'     : {'XMLForm':'element', 'list':'rpm', },\n        'scontext'         : {'XMLForm':'element', 'import_typecast':AvcContext },\n        'tcontext'         : {'XMLForm':'element', 'import_typecast':AvcContext },\n        'tclass'           : {'XMLForm':'element', },\n        'port'             : {'XMLForm':'element', 'import_typecast':int, },\n\n        'sig'              : {'XMLForm':'element', 'import_typecast':SEFaultSignature },\n        'if_text'          : {'XMLForm':'element' },\n        'then_text'        : {'XMLForm':'element' },\n        'do_text'          : {'XMLForm':'element' },\n        'environment'      : {'XMLForm':'element',  'import_typecast':SEEnvironment },\n\n        'first_seen_date'  : {'XMLForm':'element', 'import_typecast':TimeStamp },\n        'last_seen_date'   : {'XMLForm':'element', 'import_typecast':TimeStamp },\n        'report_count'     : {'XMLForm':'element', 'import_typecast':int, 'default':lambda: 0 },\n        'local_id'         : {'XMLForm':'element' },\n        'users'            : {'XMLForm':'element', 'list':'user', 'import_typecast':SEFaultSignatureUser, },\n        'level'         : {'XMLForm':'element' },\n        'fixable'       : {'XMLForm':'element' },\n        'button_text'   : {'XMLForm':'element' },\n        }\n\n    merge_include = ['audit_event', 'tpath', 'src_rpm_list', 'tgt_rpm_list',\n                     'scontext', 'tcontext', 'tclass', 'port',\n                     'environment',\n                     'last_seen_date'\n                     ]\n\n\n    def __init__(self, **kwds):\n        super(SEFaultSignatureInfo, self).__init__()\n        for k,v in kwds.items():\n            setattr(self, k, v)\n        self.report_count = 1\n        self.plugin_list = []\n\n    def update_merge(self, siginfo):\n        if siginfo.last_seen_date != self.last_seen_date:\n            self.last_seen_date = siginfo.last_seen_date\n            self.report_count += 1\n\n        for name in self.merge_include:\n            setattr(self, name, getattr(siginfo, name))\n\n    def get_policy_rpm(self):\n        return self.environment.policy_rpm;\n\n    def get_hash_str(self):\n        return  \"%s,%s,%s,%s,%s\" % (self.source, self.scontext.type, self.tcontext.type, self.tclass, \",\".join(self.sig.access))\n\n    def get_hash(self):\n        hash = hashlib.sha256(self.get_hash_str())\n        return hash.hexdigest()\n        \n    def get_user_data(self, username):\n        for user in self.users:\n            if user.username == username:\n                return user\n        log_debug(\"new SEFaultSignatureUser for %s\" % username)\n        user = SEFaultSignatureUser(username)\n        self.users.append(user)\n        return user\n\n    def find_filter_by_username(self, username):\n        log_debug(\"find_filter_by_username %s\" % username)\n        \n        filter = None\n        user_data = self.get_user_data(username)\n        if user_data is not None:\n            filter = user_data.filter\n        return filter\n\n    def update_user_filter(self, username, filter_type, data=None):\n        user_data = self.get_user_data(username)\n        user_data.update_filter(filter_type, data)\n\n    def evaluate_filter_for_user(self, username, filter_type=None):\n        action = 'display'\n        f = self.find_filter_by_username(username)\n        log_debug(\"evaluate_filter_for_user: found %s user's filter = %s\" % (username, f))\n        if f is not None:\n            if filter_type is not None:\n                f.filter_type = filter_type\n            action = self.evaluate_filter(f)\n            log_debug(\"evaluate_filter_for_user: found filter for %s: %s\\n%s\" % (username, action, f))\n        return action\n        \n    def evaluate_filter(self, filter):\n        filter_type = filter.filter_type\n        \n        action = 'display'\n\n        if filter_type == FILTER_NEVER:\n            action = 'display'\n        elif filter_type == FILTER_AFTER_FIRST:\n            if filter.count == 0:\n                action = 'display'\n            else:\n                action = 'ignore'\n        elif filter_type == FILTER_ALWAYS:\n            action = 'ignore'\n        else:\n            raise ValueError(\"unknown filter_type (%s)\" % (filter_type))\n        filter.count += 1\n        return action\n\n    def format_rpm_list(self, rpm_list):\n        if isinstance(rpm_list, list):\n            if  len(rpm_list) > 0:\n                return \" \".join(rpm_list)\n            else:\n                return \"\"\n        else:\n            return default_text(None)\n\n    def format_target_object(self):\n        return \"%s [ %s ]\" % (self.tpath, self.tclass)\n\n    def description_adjusted_for_permissive(self):\n        permissive_msg = None\n        syscall_record = self.audit_event.get_record_of_type('SYSCALL')\n        if syscall_record != None and syscall_record.get_field('success') == 'yes':\n            permissive_msg = _(\"%s has a permissive type (%s). This access was not denied.\") % (self.source, self.scontext.type)\n\n        if self.environment.enforce == \"Permissive\":\n            permissive_msg = _(\"SELinux is in permissive mode. This access was not denied.\")\n\n    def update_derived_template_substitutions(self):\n        self.template_substitutions = {} \n        self.template_substitutions[\"SOURCE_TYPE\"] = self.scontext.type\n        self.template_substitutions[\"TARGET_TYPE\"] = self.tcontext.type\n        self.template_substitutions[\"SOURCE\"]      = self.source\n        self.template_substitutions[\"SOURCE_PATH\"] = self.spath\n        self.template_substitutions[\"SOURCE_BASE_PATH\"] = os.path.basename(self.spath)\n        if self.spath:\n            self.template_substitutions[\"FIX_SOURCE_PATH\"] = re.sub(\" \",\".\",self.spath)\n        else:\n            self.spath = _(\"N/A\")\n\n        self.template_substitutions[\"TARGET_PATH\"] = self.tpath\n        self.template_substitutions[\"TARGET_BASE_PATH\"] = os.path.basename(self.tpath)\n        if self.tpath:\n            self.template_substitutions[\"FIX_TARGET_PATH\"] = re.sub(\" \",\".\",self.tpath)\n\n        if self.tpath is None:\n            self.template_substitutions[\"TARGET_DIR\"] = None\n        else:\n            if self.tclass == 'dir':\n                self.template_substitutions[\"TARGET_DIR\"] = self.tpath\n            elif self.tclass == 'file':\n                self.template_substitutions[\"TARGET_DIR\"] = os.path.dirname(self.tpath)\n            else:\n                self.template_substitutions[\"TARGET_DIR\"] = None\n\n        if self.tclass == \"dir\":\n            self.template_substitutions[\"TARGET_CLASS\"] = \"directory\"\n        else:\n            self.template_substitutions[\"TARGET_CLASS\"] = self.tclass\n\n        if self.sig.access is None:\n            self.template_substitutions[\"ACCESS\"] = None\n        else:\n            self.template_substitutions[\"ACCESS\"] = ' '.join(self.sig.access)\n\n        if len(self.src_rpm_list) > 0:\n            self.template_substitutions[\"SOURCE_PACKAGE\"] = self.src_rpm_list[0]\n        self.template_substitutions[\"PORT_NUMBER\"] = self.port\n\n        # validate, replace any None values with friendly string\n        for key, value in self.template_substitutions.items():\n            if value is None:\n                self.template_substitutions[key] = default_text(value)\n\n    def priority_sort(self, x, y):\n        return cmp(y[0].priority,x[0].priority)\n\n    def summary(self):\n        if self.tclass == \"process\":\n            return P_(_(\"SELinux is preventing %s from using the %s access on a process.\"), _(\"SELinux is preventing %s from using the '%s' accesses on a process.\"), len(self.sig.access)) % (self.spath, \", \".join(self.sig.access))\n\n        if self.tclass == \"capability\":\n            return P_(_(\"SELinux is preventing %s from using the %s capability.\"), _(\"SELinux is preventing %s from using the '%s' capabilities.\"), len(self.sig.access)) % (self.spath, \", \".join(self.sig.access))\n        if self.tpath == \"(null)\":\n            return P_(_(\"SELinux is preventing %s from %s access on the %s labeled %s.\"), _(\"SELinux is preventing %s from '%s' accesses on the %s labeled %s.\"), len(self.sig.access)) % (self.spath, \", \".join(self.sig.access), translate_class(self.tclass), self.tcontext.type)\n        return P_(_(\"SELinux is preventing %s from %s access on the %s %s.\"), _(\"SELinux is preventing %s from '%s' accesses on the %s %s.\"), len(self.sig.access)) % (self.spath, \", \".join(self.sig.access), translate_class(self.tclass), self.tpath)\n\n    def get_plugins(self, all = False):\n        self.plugins = load_plugins()\n        plugins = []\n        total_priority = 0\n        if all:\n            for p  in self.plugins:\n                total_priority += p.priority\n                plugins.append((p, (\"allow_ypbind\", \"1\")))\n        else:\n            for solution in self.plugin_list:\n                for p  in self.plugins:\n                    if solution.analysis_id == p.analysis_id:\n                        total_priority += p.priority\n                        plugins.append((p, tuple(solution.args)))\n                        break\n\n        plugins.sort(self.priority_sort)\n\n        return total_priority, plugins\n\n    def substitute(self, txt):\n        return Template(txt).safe_substitute(self.template_substitutions)\n\n    def format_details(self, replace=False):\n        env = self.environment\n\n        text = _(\"Additional Information:\\n\")\n        text += format_2_column_name_value(_(\"Source Context\"),        self.scontext.format())\n        text += format_2_column_name_value(_(\"Target Context\"),        self.tcontext.format())\n        text += format_2_column_name_value(_(\"Target Objects\"),        self.format_target_object())\n        text += format_2_column_name_value(_(\"Source\"),                default_text(self.source))\n        text += format_2_column_name_value(_(\"Source Path\"),           default_text(self.spath))\n        text += format_2_column_name_value(_(\"Port\"),                  default_text(self.port))\n        if (replace):\n            text += format_2_column_name_value(_(\"Host\"),              \"(removed)\")\n        else:\n            text += format_2_column_name_value(_(\"Host\"),                  default_text(self.sig.host))\n        text += format_2_column_name_value(_(\"Source RPM Packages\"),   default_text(self.format_rpm_list(self.src_rpm_list)))\n        text += format_2_column_name_value(_(\"Target RPM Packages\"),   default_text(self.format_rpm_list(self.tgt_rpm_list)))\n        text += format_2_column_name_value(_(\"Policy RPM\"),            default_text(env.policy_rpm))\n        text += format_2_column_name_value(_(\"Selinux Enabled\"),       default_text(env.selinux_enabled))\n        text += format_2_column_name_value(_(\"Policy Type\"),           default_text(env.policy_type))\n        text += format_2_column_name_value(_(\"Enforcing Mode\"),        default_text(env.enforce))\n        if replace:\n            text += format_2_column_name_value(_(\"Host Name\"),\"(removed)\")\n        else:\n            text += format_2_column_name_value(_(\"Host Name\"),         default_text(env.hostname))\n\n        if replace:\n            uname = env.uname.split()\n            uname[1] = \"(removed)\"\n            text += format_2_column_name_value(_(\"Platform\"),          default_text(\" \".join(uname)))\n        else:\n            text += format_2_column_name_value(_(\"Platform\"),              default_text(env.uname))\n        text += format_2_column_name_value(_(\"Alert Count\"),           default_text(self.report_count))\n        date_format = \"%Y-%m-%d %H:%M:%S %Z\"\n        text += format_2_column_name_value(_(\"First Seen\"),            self.first_seen_date.format(date_format))\n        text += format_2_column_name_value(_(\"Last Seen\"),             self.last_seen_date.format(date_format))\n        text += format_2_column_name_value(_(\"Local ID\"),              default_text(self.local_id))\n\n        text += '\\n' + _(\"Raw Audit Messages\")\n        avcbuf = \"\"\n        for audit_record in self.audit_event.records:\n            if audit_record.record_type == 'AVC':\n                avcbuf += \"\\n\" + audit_record.to_text() + \"\\n\"\n            else:\n                avcbuf += \"\\ntype=%s msg=%s: \" % (audit_record.record_type, audit_record.event_id)\n                avcbuf += ' '.join([\"%s=%s\" % (k, audit_record.fields[k]) for k in audit_record.fields_ord]) +\"\\n\"\n\n        avcbuf += \"\\nHash: \" + self.get_hash_str() \n\n        try:\n            audit2allow = \"/usr/bin/audit2allow\"\n            if os.path.exist(audit2allow):\n                newbuf = \"\\n\\naudit2allow\"\n                p =  Popen([audit2allow], shell=True,stdin=PIPE, stdout=PIPE)\n                newbuf += p.communicate(avcbuf)[0]\n                if os.path.exists(\"/var/lib/sepolgen/interface_info\"):\n                    newbuf += \"\\naudit2allow -R\"\n                    p =  Popen([\"%s -R\" % audit2allow ], shell=True,stdin=PIPE, stdout=PIPE)\n                    newbuf += p.communicate(avcbuf)[0]\n                avcbuf += newbuf\n        except:\n            pass\n\n        text += avcbuf + '\\n'\n\n        return text\n\n    def untranslated(self, func, *args, **kwargs):\n        r'define.*untranslated\\(.*\\n'\n        # Call the parameter function with the translations turned off\n        # This function is not thread safe, since it manipulates globals\n\n        global P_, _\n        saved_translateP_ = P_\n        saved_translate_ = _\n\n        try:\n            P_ = lambda x,y,z: x if z > 1 else y\n            _ = lambda x:x\n            return func(*args, **kwargs)\n        finally:\n            P_ = saved_translateP_ \n            _ = saved_translate_\n\n    def format_text(self, all = False, replace = False):\n        self.update_derived_template_substitutions()\n\n        text = self.summary()\n\n        total_priority, plugins = self.get_plugins(all)\n\n        for p, args in plugins:\n            title = _(\"\\n\\n*****  Plugin %s (%.4s confidence) suggests   \") % (p.analysis_id, ((float(p.priority) / float(total_priority)) * 100 + .5))\n            text +=  title\n            for i in range(len(title),80):\n                text +=  _(\"*\")\n            text +=  _(\"\\n\")\n            txt = self.substitute(p.get_if_text(self.audit_event.records, args)).decode('utf-8')\n            text +=  _(\"\\nIf \") + txt[0].lower() + txt[1:]\n            txt = self.substitute(p.get_then_text(self.audit_event.records, args)).decode('utf-8')\n            text +=  _(\"\\nThen \") + txt[0].lower() + txt[1:]\n\n            txt = self.substitute(p.get_do_text(self.audit_event.records, args)).decode('utf-8')\n            text +=  _(\"\\nDo\\n\") + txt[0].lower() + txt[1:]\n\n        text += _('\\n\\n')\n        return text\n\nclass SEFaultUserInfo(XmlSerialize):\n    _xml_info = {\n    'version'            : {'XMLForm':'attribute','default':lambda: '1.0' },\n    'username'           : {'XMLForm':'attribute' },\n    'email_alert'        : {'XMLForm':'element', 'import_typecast':boolean, 'default': lambda: False },\n    'email_address_list' : {'XMLForm':'element', 'list':'email_address', },\n    }\n    def __init__(self, username):\n        super(SEFaultUserInfo, self).__init__()\n        self.username = username\n\n    def add_email_address(self, email_address):\n        if not email_address in self.email_address_list:\n            self.email_address_list.append(email_address)\n\n\n\nclass SEFaultUserSet(XmlSerialize):\n    _xml_info = {\n    'version'      : {'XMLForm':'attribute','default':lambda: '1.0' },\n    'user_list'    : {'XMLForm':'element', 'list':'user', 'import_typecast':SEFaultUserInfo, },\n    }\n    def __init__(self):\n        super(SEFaultUserSet, self).__init__()\n\n    def get_user(self, username):\n        for user in self.user_list:\n            if username == user.username:\n                return user\n        return None\n\n    def add_user(self, username):\n        if self.get_user(username) is not None:\n            return\n        user = SEFaultUserInfo(username)\n        self.user_list.append(user)\n        return user\n\n\n\nclass SEFaultSignatureSet(XmlSerialize):\n    _xml_info = {\n    'version'          : {'XMLForm':'attribute','default':lambda: '%d.%d' %  (DATABASE_MAJOR_VERSION, DATABASE_MINOR_VERSION)},\n    'users'            : {'XMLForm':'element', 'import_typecast':SEFaultUserSet, 'default': lambda: SEFaultUserSet() },\n    'signature_list'   : {'XMLForm':'element', 'list':'siginfo', 'import_typecast':SEFaultSignatureInfo, },\n    }\n    def __init__(self):\n        super(SEFaultSignatureSet, self).__init__()\n\n    def siginfos(self):\n        for siginfo in self.signature_list:\n            yield siginfo\n\n    def add_siginfo(self, siginfo):\n        self.signature_list.append(siginfo)\n        return siginfo\n\n    def remove_siginfo(self, siginfo):\n        self.signature_list.remove(siginfo)\n\n    def clear(self):\n        self.signature_list = []\n        \n\n    def generate_local_id(self):\n        return str(uuid.uuid4())\n\n    def lookup_local_id(self, local_id):\n        if local_id is None:\n            return None\n\n        for siginfo in self.signature_list:\n            if siginfo.local_id == local_id:\n                return siginfo\n\n        return None\n\n    def match_signatures(self, pat, criteria='exact', xml_info=SEFaultSignature._xml_info):\n        match_targets = xml_info.keys()\n        exact = False\n        if criteria == 'exact':\n            exact = True\n        elif type(criteria) is FloatType:\n            num_match_targets = len(match_targets)\n            score_per_match_target = 1.0 / num_match_targets\n        else:\n            raise ValueError(\"unknown criteria = %s\" % criteria)\n        \n        matches = []\n        for siginfo in self.signature_list:\n            score = 0.0\n            sig = siginfo.sig\n            for name in match_targets:\n                if getattr(pat, name) == getattr(sig, name):\n                    if exact:\n                        score = 1.0\n                    else:\n                        score += score_per_match_target\n                else:\n                    if exact:\n                        score = 0.0\n                        break\n            if exact:\n                if score == 1.0:\n                    matches.append(SignatureMatch(siginfo, score))\n            else:\n                if score >= criteria:\n                    matches.append(SignatureMatch(siginfo, score))\n        matches.sort((lambda a,b: cmp(b.score, a.score)))\n        return matches\n\n\n\n\nclass SEDatabaseProperties(XmlSerialize):\n    _xml_info = {\n    'name'          : {'XMLForm':'element' },\n    'friendly_name' : {'XMLForm':'element' },\n    'filepath'      : {'XMLForm':'element' },\n    }\n    def __init__(self, name=None, friendly_name=None, filepath=None):\n        super(SEDatabaseProperties, self).__init__()\n        if name is not None:\n            self.name = name\n        if friendly_name is not None:\n            self.friendly_name = friendly_name\n        if filepath is not None:\n            self.filepath = filepath\n\nclass SEEmailRecipient(XmlSerialize):\n    _xml_info = {\n    'address'          : {'XMLForm':'element' },\n    'filter_type'      : {'XMLForm':'element', 'import_typecast':int, 'default':lambda: FILTER_AFTER_FIRST },\n    }\n    def __init__(self, address, filter_type=None):\n        super(SEEmailRecipient, self).__init__()\n        self.address = address\n        if filter_type is not None:\n            self.filter_type = filter_type\n\n    def __str__(self):\n        return \"%s:%s\" % (self.address, map_filter_value_to_name.get(self.filter_type, 'unknown'))\n\n\nclass SEEmailRecipientSet(XmlSerialize):\n    _xml_info = {\n    'version'         : {'XMLForm':'attribute','default':lambda: '1' },\n    'recipient_list'  : {'XMLForm':'element', 'list':'recipient', 'import_typecast':SEEmailRecipient, },\n    }\n    def __init__(self, recipient_list=None):\n        super(SEEmailRecipientSet, self).__init__()\n        if recipient_list is not None:\n            self.recipient_list = recipient_list\n\n    def __str__(self):\n        return ','.join([str(x) for x in self.recipient_list])\n\n    def find_address(self, address):\n        address = address.strip()\n        for recipient in self.recipient_list:\n            if address == recipient.address:\n                return recipient\n        return None\n\n    def add_address(self, address, filter_type=FILTER_AFTER_FIRST):\n        address = address.strip()\n        if not valid_email_address(address):\n            raise ProgramError(ERR_INVALID_EMAIL_ADDR, detail=\"address='%s'\" % address)\n            return\n\n        recipient = self.find_address(address)\n        if recipient is not None:\n            return\n        self.recipient_list.append(SEEmailRecipient(address, filter_type))\n\n    def clear_recipient_list(self):\n        self.recipient_list = []\n\n    def parse_recipient_file(self, filepath):\n        import re\n        comment_re = re.compile('#.*')\n        entry_re = re.compile('(\\S+)(\\s+(.+))?')\n        key_value_re = re.compile(\"(\\w+)\\s*=\\s*(\\S+)\")\n\n        map_boolean = {'enabled'  : True,\n                       'true'     : True,\n                       'yes'      : True,\n                       'on'       : True,\n                       'disabled' : False,\n                       'false'    : False,\n                       'no'       : False,\n                       'off'      : False,\n                       }\n\n\n        try:\n            f = open(filepath)\n        except IOError, e:\n            raise ProgramError(ERR_FILE_OPEN, detail=\"%s, %s\" % (filepath, e.strerror))\n\n        self.clear_recipient_list()\n\n        for line in f.readlines():\n            line = comment_re.sub('', line)\n            line = line.strip()\n            if line:\n                match = entry_re.search(line)\n                if match:\n                    address = match.group(1)\n                    options = match.group(3)\n                    filter_type = None\n\n                    if options:\n                        for match in key_value_re.finditer(options):\n                            option = match.group(1)\n                            value  = match.group(2)\n\n\n                            if option == 'filter_type':\n                                filter_type = map_filter_name_to_value.get(value.lower(), None)\n                                if filter_type is None:\n                                    log_debug(\"unknown email filter (%s) for address %s\" % (option, address))\n                                    \n                            else:\n                                log_debug(\"unknown email option (%s) for address %s\" % (option, address))\n                                \n                    try:\n                        self.add_address(address, filter_type)\n                    except ProgramError, e:\n                        if e.errno == ERR_INVALID_EMAIL_ADDR:\n                            log_debug(e.strerror)\n                        else:\n                            raise e\n\n\n        f.close()\n\n    def write_recipient_file(self, filepath):\n        try:\n            f = open(filepath, 'w')\n        except IOError, e:\n            raise ProgramError(ERR_FILE_OPEN, detail=\"%s, %s\" % (filepath, e.strerror))\n\n        for recipient in self.recipient_list:\n            filter_type = map_filter_value_to_name[recipient.filter_type]\n            f.write(\"%-40s filter_type=%s\\n\" % (recipient.address, filter_type))\n        \n        f.close()\n\n\n#------------------------------------------------------------------------\n\n\nif __name__ == '__main__':\n    import libxml2\n    #memory debug specific\n    libxml2.debugMemory(1)\n\n    xml_file = 'audit_listener_database.xml'\n\n    sigs = SEFaultSignatureSet()\n    sigs.read_xml_file(xml_file, 'sigs')\n    siginfo = sigs.signature_list[0]\n    record = siginfo.audit_event.records[0]\n    print record.record_type\n    print \"siginfo.audit_event=%s\" % siginfo.audit_event\n    print sigs\n\n    #memory debug specific\n    libxml2.cleanupParser()\n    if libxml2.debugMemory(1) == 0:\n        print \"Memory OK\"\n    else:\n        print \"Memory leak %d bytes\" % (libxml2.debugMemory(1))\n        libxml2.dumpMemory()\n"], "fixing_code": ["#! /usr/bin/python -Es\n#\n# Authors: John Dennis <jdennis@redhat.com>\n# Authors: Dan Walsh <dwalsh@redhat.com>\n#\n# Copyright (C) 2006-2010 Red Hat, Inc.\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n#\n\nimport syslog\nimport setroubleshoot.default_encoding_utf8\nimport gobject\ngobject.set_prgname('setroubleshoot') \nimport dbus\nimport dbus.glib\nimport dbus.service\nimport errno as Errno\nimport gettext\nimport os\nimport Queue\nimport re\nimport signal\nimport selinux\nimport socket as Socket\nimport fcntl\nimport sys\nimport slip.dbus.service\n\nfrom setroubleshoot.config import parse_config_setting, get_config\ndomain = get_config('general', 'i18n_text_domain')\ngettext.install(domain    = domain,\n                unicode = True,\n                localedir = get_config('general', 'i18n_locale_dir'))\n\nsyslog.openlog(sys.argv[0])\nfrom setroubleshoot.errcode import *\nfrom setroubleshoot.util import get_identity, load_plugins, log_debug\nfrom setroubleshoot.rpc import *\n\n#------------------------------------------------------------------------------\ninvocation_style = None\nstatus_icon = None\ndbus_system_bus_name = get_config('system_dbus','bus_name')\ndbus_system_object_path = get_config('system_dbus','object_path')\ndbus_system_interface = get_config('system_dbus','interface')\n\ndbus_session_bus_name = get_config('session_dbus','bus_name')\ndbus_session_object_path = get_config('session_dbus','object_path')\ndbus_session_interface = get_config('session_dbus','interface')\napp = None\ndefault_status_icon_tooltip = _(\"SELinux AVC denial, click to view\")\n#------------------------------------------------------------------------------\ndef sighandler(signum, frame):\n    log_debug(\"exiting on signal %s\" % signum)\n    sys.exit()\n\ndef get_server_socket_address():\n    addr_list = get_socket_list_from_config('client_connect_to')\n    if len(addr_list) == 0: return None\n    return addr_list[0]\n\ndef setup_sighandlers():\n    signal.signal(signal.SIGHUP,  sighandler)\n    signal.signal(signal.SIGQUIT, sighandler)\n    signal.signal(signal.SIGTERM, sighandler)\n\ndef run_app(user):\n    global app\n\n    from setroubleshoot.serverconnection import ServerConnectionHandler\n    gobject.type_register(ServerConnectionHandler)\n\n    app = SEAlert(user)\n    return app.main()    \n\ndef error(message):\n    dlg = gtk.MessageDialog(None, 0, gtk.MESSAGE_ERROR,\n                            gtk.BUTTONS_CLOSE,\n                            message)\n    dlg.set_position(gtk.WIN_POS_MOUSE)\n    dlg.show_all()\n    dlg.run()\n    dlg.destroy()\n\ndef run_as_dbus_service(user):\n    global app\n#-----------------------------------------------------------------------------\n    if not selinux.is_selinux_enabled():\n        log_debug(\"SELinux not enabled, sealert will not run on non SELinux systems\")\n        error(_(\"SELinux not enabled, sealert will not run on non SELinux systems\"))\n        sys.exit(3)\n\n    try:\n        log_debug('starting service')\n        dbus_service = DBusSessionService(dbus_session_bus_name)\n        app = SEAlert(user, dbus_service.presentation_manager, watch_setroubleshootd=True)\n        return app.main()    \n    except dbus.DBusException, e:\n        syslog.syslog(syslog.LOG_ERR, 'could not start dbus: %s' % str(e))\n        return False\n\ndef ask_dbus_to_show_browser():\n    try:\n        bus = dbus.SessionBus()\n        proxy_obj = bus.get_object(dbus_session_bus_name, dbus_session_object_path)\n        iface = dbus.Interface(proxy_obj, dbus_session_interface)\n        return True\n    except dbus.DBusException, e:\n        syslog.syslog(syslog.LOG_ERR, 'could not start dbus: %s' % str(e))\n        return False\n\ndef ask_dbus_to_quit_app():\n    try:\n        bus = dbus.SessionBus()\n        proxy_obj = bus.get_object(dbus_session_bus_name, dbus_session_object_path)\n        iface = dbus.Interface(proxy_obj, dbus_session_interface)\n        iface.quit_app()    \n        return True\n    except dbus.DBusException, e:\n        syslog.syslog(syslog.LOG_ERR, 'could not start dbus: %s' % str(e))\n        return False\n\ndef fix_lookup_id(local_id, analysis_id):\n    def lookup_local_id():\n        log_debug(\"calling server to lookup id (%s)\" % local_id)\n        async_rpc = cl.alert_client.query_alerts(local_id)\n        async_rpc.add_callback(query_alerts_callback)\n        async_rpc.add_errback(query_alerts_error)\n\n    def query_alerts_callback(sigs):\n        import subprocess\n        for siginfo in sigs.signature_list:\n            for plugin  in siginfo.plugin_list:\n                if analysis_id == plugin.analysis_id:\n                    p = load_plugins(analysis_id)[0]\n                    if p.fixable == False:\n                        print _(\"Not fixable.\")\n                        cl.main_loop.quit()\n                        return\n                    siginfo.update_derived_template_substitutions()\n                    command = siginfo.substitute_array(p.get_fix_cmd(siginfo.audit_event, plugin.args).split())\n                    try:\n                        output = subprocess.check_output(command)\n                        print _(\"Successfully ran %s\" % ' '.join(command))\n                    except subprocess.CalledProcessError as e:\n                        print(e.output)\n                    cl.main_loop.quit()\n                    return\n        print _(\"Plugin %s not valid for %s id\") % (analysis_id, local_id)\n        cl.main_loop.quit()\n\n    def query_alerts_error(method, errno, strerror):\n        print >> sys.stderr, \"%s error (%d): %s\" % (method, errno, strerror)\n        cl.main_loop.quit()\n\n    cl = SECommandLine(lookup_local_id)\n    cl.run()\n\n\ndef command_line_lookup_id(local_id, html=False):\n    global err;\n    err=None\n    def lookup_local_id():\n        log_debug(\"calling server to lookup id (%s)\" % local_id)\n        async_rpc = cl.alert_client.query_alerts(local_id)\n        async_rpc.add_callback(query_alerts_callback)\n        async_rpc.add_errback(query_alerts_error)\n\n    def query_alerts_callback(sigs):\n        for siginfo in sigs.signature_list:\n            print siginfo.format_text()\n            print siginfo.format_details()\n        cl.main_loop.quit()\n\n    def query_alerts_error(method, errno, strerror):\n        global err\n        cl.main_loop.quit()\n        err = \"%s error (%d): %s\" % (method, errno, strerror)\n\n    cl = SECommandLine(lookup_local_id)\n    cl.run()\n    if err:\n        print \"Error\"\n        raise ValueError(err)\n\n#-----------------------------------------------------------------------------\n\nclass PresentationManager(gobject.GObject):\n    __gsignals__ = {\n        'show_browser':\n        (gobject.SIGNAL_RUN_LAST, gobject.TYPE_NONE, (gobject.TYPE_PYOBJECT,)),\n        'quit_app':\n        (gobject.SIGNAL_RUN_LAST, gobject.TYPE_NONE, ()),\n        }\n\n    def __init__(self):\n        gobject.GObject.__init__(self)\n\n    def show_browser(self, data_name = None):\n        self.emit('show_browser', data_name)\n\n    def quit_app(self):\n        self.emit('quit_app')\n\ngobject.type_register(PresentationManager)\n\n#-----------------------------------------------------------------------------\n\nclass SETroubleshootdDBus(gobject.GObject):\n    __gsignals__ = {\n        'state_change':\n        (gobject.SIGNAL_RUN_LAST, gobject.TYPE_NONE, (gobject.TYPE_PYOBJECT,)),\n        'restart_request':\n        (gobject.SIGNAL_RUN_LAST, gobject.TYPE_NONE, (gobject.TYPE_PYOBJECT,)),\n        }\n\n    def __init__(self):\n        gobject.GObject.__init__(self)\n\n        self.bus = dbus.SystemBus()\n\n        proxy_obj = self.bus.get_object(dbus_system_bus_name, dbus_system_object_path)\n        self.iface = dbus.Interface(proxy_obj, dbus_system_interface)\n        s = self.iface.start()\n        log_debug(\"starting setroubleshootd service\")\n\n        self.bus.add_signal_receiver(self.on_dbus_name_owner_change, 'NameOwnerChanged',\n                                     'org.freedesktop.DBus', 'org.freedesktop.DBus', '/org/freedesktop/DBus',\n                                     arg0=dbus_system_bus_name)\n\n\n        # Note: this signal can be emitted from the command line via\n        # dbus-send --system $dbus_system_object_path $dbus_system_interface.restart string:\"reason\"\n        self.bus.add_signal_receiver(self.do_restart, 'restart', dbus_system_interface, None, dbus_system_object_path)\n\n    def finish(self):\n        log_debug(\"exiting dbus\")\n        s = self.iface.finish()\n\n    def __del__(self):\n        log_debug(\"exiting dbus\")\n        s = self.iface.finish()\n\n    def on_dbus_name_owner_change(self, name, old_owner, new_owner):\n        log_debug(\"on_dbus_name_owner_change: name=%s old_owner=%s new_owner=%s\" % (name, old_owner, new_owner))\n        if not old_owner and new_owner:\n            log_debug(\"setroubleshootd: came on line\")\n            self.emit('state_change', 'run')\n        elif old_owner and not new_owner:\n            log_debug(\"setroubleshootd: went off line\")\n            self.emit('state_change', 'stop')\n        elif not old_owner and not new_owner:\n            log_debug(\"setroubleshootd: no connection\")\n            self.emit('state_change', 'stop')\n        elif old_owner and new_owner:\n            log_debug(\"setroubleshootd: owner change\")\n        else:\n            log_debug(\"don't know how to parse old_owner(%s) new_owner(%s)\" % (old_owner, new_owner))\n\n    def do_restart(self, reason):\n        log_debug(\"do_restart(%s)\" % reason)\n        self.emit('restart_request', reason)\n\ngobject.type_register(SETroubleshootdDBus)\n\n#-----------------------------------------------------------------------------\n\nclass DBusSessionService(dbus.service.Object):\n    def __init__(self, bus_name):\n        bus = dbus.SessionBus()\n        bus_name = dbus.service.BusName(dbus_session_bus_name, bus = bus)\n        dbus.service.Object.__init__(self, bus_name, dbus_session_object_path)\n\n        self.presentation_manager = PresentationManager()\n\n    @dbus.service.method(dbus_session_interface)\n    def start(self):\n        return _(\"Started\")\n\n    @dbus.service.method(dbus_session_interface)\n    def show_browser(self):\n        log_debug('dbus iface show_browser() called',)\n        self.presentation_manager.show_browser()\n        return \"\"\n\n    @dbus.service.method(dbus_session_interface)\n    def quit_app(self):\n        log_debug('quit_app() called')\n        self.presentation_manager.quit_app()\n\n#-----------------------------------------------------------------------------\n\nclass SEAlert(object):\n    \"\"\"\n    The SEAlert object represents a gui client for setroubleshoot. It\n    processes alerts and presents the user with an appropriate user\n    interface for handling the alert. Most of the interface code\n    is in BrowserApplet and StatusIcon. This class is mainly a central\n    hub for processing the alerts.\n    \"\"\"\n    def __init__(self, username, presentation_manager = None, watch_setroubleshootd = False):\n        from setroubleshoot.serverconnection import ServerConnectionHandler\n        gobject.type_register(ServerConnectionHandler)\n\n        try:\n            self.username = username\n            from setroubleshoot.browser import BrowserApplet\n\n            if presentation_manager is None:\n                self.presentation_manager = PresentationManager()\n                gobject.idle_add(self.show_browser_at_startup)\n            else:\n                self.presentation_manager = presentation_manager\n\n            self.browser = None\n\n            self.alert_siginfo = None\n\n            if watch_setroubleshootd:\n                self.setroubleshootd_dbus = SETroubleshootdDBus()\n                self.setroubleshootd_dbus.connect('state_change', self.on_setroubleshootd_state_change)\n            else:\n                self.setroubleshootd_dbus = None\n\n            self.alert_client = ServerConnectionHandler(self.username)\n            self.alert_client.open(get_server_socket_address())\n            self.browser = BrowserApplet(self.username, self.alert_client, domain=domain)\n            self.presentation_manager.connect('show_browser', self.on_show_browser)\n            self.presentation_manager.connect('quit_app', self.on_quit)\n\n            self.alert_client.connect('alert', self.alert)\n\n            # If there is no presentation mananger make sure when the\n            # user closes the window the whole application exits. When running\n            # in \"alert\" mode we want the application to persist in the background\n            self.browser.window_delete_hides = False\n\n        except ProgramError, e:\n            syslog.syslog(syslog.LOG_ERR, e.strerror)\n            sys.exit(1)\n\n    def finish(self):\n        if  self.setroubleshootd_dbus != None:\n            self.setroubleshootd_dbus.finish()\n\n    def main(self):\n        log_debug('creating main GUI application')\n        try:\n            gtk.main()\n            self.finish()\n        except IOError, e:\n            syslog.syslog(syslog.LOG_ERR, str(e))\n            print >>sys.stderr, e\n            sys.exit(1)\n            \n        except KeyboardInterrupt, e:\n            log_debug(\"got KeyboardInterrupt, exiting ...\")\n            self.alert_client.close_connection(ConnectionState.HUP)\n            self.finish()\n            sys.exit()\n\n    def alert(self, alert_client, siginfo):\n        log_debug(\"evaluating alert\")\n\n        def alert_filter_result(result):\n            pass\n\n        self.alert_siginfo = siginfo\n        async_rpc = self.browser.server.evaluate_alert_filter(siginfo.sig, self.username)\n        async_rpc.add_callback(alert_filter_result)\n\n    def show_browser_at_startup(self):\n        self.presentation_manager.show_browser()\n        return False\n\n    def show_browser(self, data_name):\n        if data_name is not None:\n            self.browser.do_visit(data_name)\n\n        log_debug(\"SEAlert.show_browser(): data_name=%s\" % data_name)\n        self.browser.show()\n        return True\n\n    def on_quit(self, widget):\n        if self.alert_client is not None:\n            self.alert_client.close_connection(ConnectionState.HUP)\n        gtk.main_quit()\n\n    def on_show_browser(self, widget, data_name):\n        self.show_browser(data_name)\n\n    def on_setroubleshootd_state_change(self, setroubleshootd_dbus, state):\n        log_debug('setroubleshootd state change (%s)' % state)\n        if state == 'run':\n            self.alert_client.open()\n\n    def on_restart_request(self, setroubleshootd_dbus, reason):\n        log_debug('restart request: reason = %s' % reason)\n        do_restart()\n        return False\n        \n\ndef do_restart():\n    log_debug(\"restarting application...)\")\n    window_state = None\n    geometry = None\n    if app is not None:\n        if app.browser is not None:\n            window_state, visibility_state = app.browser.get_window_state()\n            geometry = app.browser.get_geometry()\n            os.environ['SEALERT_WINDOW_STATE'] = window_state\n            os.environ['SEALERT_WINDOW_GEOMETRY'] = geometry\n    log_debug(\"restarting %s: args=%s window_state=%s geometry=%s\" % (sys.argv[0], sys.argv[1:], window_state, geometry))\n    os.execv(sys.argv[0], sys.argv)\n\n#-----------------------------------------------------------------------------\n\nclass SECommandLine(object):\n    def __init__(self, func):\n        from setroubleshoot.serverconnection import ServerConnectionHandler\n        self.username = get_identity()\n        self.func = func\n\n        self.alert_client = ServerConnectionHandler(self.username)\n        self.alert_client.connect('connection_state_changed', self.on_connection_state_change)\n        self.main_loop = gobject.MainLoop()\n\n\n    def async_error_callback(self, method, errno, strerror):\n        print >> sys.stderr, \"%s error (%d): %s\" % (method, errno, strerror)\n        sys.exit(1)\n\n    def do_logon(self):\n        def logon_callback(pkg_version, rpc_version):\n            log_debug(\"logon_callback(): pkg_version=%s rpc_version=%s\" % (pkg_version, rpc_version))\n            self.alert_client.connection_state.update(ConnectionState.AUTHENTICATED)\n\n        log_debug(\"logon: %s\" % self.username)\n\n        self.alert_client.channel_name = self.username\n        async_rpc = self.alert_client.logon(self.alert_client.channel_type, self.username, 'passwd')\n        async_rpc.add_callback(logon_callback)\n        async_rpc.add_errback(self.async_error_callback)\n\n    def on_connection_state_change(self, connection, connection_state, flags, flags_added, flags_removed):\n        log_debug(\"%s.on_connection_state_change: connection_state=%s flags_added=%s flags_removed=%s address=%s\" % (self.__class__.__name__, connection_state, connection_state.flags_to_string(flags_added), connection_state.flags_to_string(flags_removed), connection.socket_address))\n\n        if flags_added & ConnectionState.ERROR:\n            errno, strerror = connection_state.get_result()\n            print >> sys.stderr, \"failed to connect to server: %s\" % (strerror)\n            sys.exit(1)\n\n        if flags_added & ConnectionState.OPEN:\n            self.do_logon()\n\n        if flags_added & ConnectionState.AUTHENTICATED:\n            self.func()\n\n    def run(self):\n        log_debug('executing command line application')\n        self.alert_client.open(get_server_socket_address())\n        try:\n            self.main_loop.run()\n        except KeyboardInterrupt, e:\n            sys.exit()\n\n#-----------------------------------------------------------------------------\n\nclass ScanLogfile:\n    def __init__(self, logfile_path):\n        from setroubleshoot.analyze import LogfileAnalyzer\n        self.analyzer = LogfileAnalyzer(logfile_path)\n        self.main_loop = gobject.MainLoop()\n        if sys.stdout.isatty():\n            self.analyzer.connect('progress', self.on_progress)\n        self.analyzer.connect('state-changed', self.on_analyzer_state_change)\n        \n    def on_progress(self, analyzer, progress):\n        output = \"\\r%3d%% done\" % (progress*100)\n        sys.stdout.write(output)\n        sys.stdout.flush()\n\n    def on_analyzer_state_change(self, analyzer, state):\n        if state == 'stopped':\n            if analyzer.strerror:\n                print >> sys.stderr, \"ERROR: %s\" % analyzer.strerror\n            log_debug(\"analyzer stopped\")\n            self.main_loop.quit()\n            self.output_results()\n\n    def scan_file(self):\n        self.analyzer.cancelled = False\n        self.analyzer.open()\n        self.analyzer.run()\n        self.main_loop.run()\n\n    def output_results(self):\n        sigs = self.analyzer.database.query_alerts('*')\n        seperator = '-'*80 + '\\n'\n        print \"\\nfound %d alerts in %s\" % (len(sigs.signature_list), self.analyzer.logfile_path)\n        for siginfo in sigs.signature_list:\n            print seperator\n            print siginfo.format_text()\n            print siginfo.format_details()\n\ndef do_analyze_logfile(logfile_path):\n    import selinux.audit2why as audit2why\n    audit2why.init()\n    scanner = ScanLogfile(logfile_path)\n    scanner.scan_file()\n    audit2why.finish()\n        \n#-----------------------------------------------------------------------------\n\ndef display_terminal_traceback(who):\n    import traceback\n    stacktrace = traceback.format_exc()\n    print _(\"Opps, %s hit an error!\" % who) + '\\n\\n' +stacktrace\n\ntry:\n    from setroubleshoot.gui_utils import display_traceback\nexcept:\n    def display_traceback(who):\n        display_terminal_traceback(who)\n\n# -- Main --\nif __name__ == '__main__':\n    use_terminal = False\n    setup_sighandlers()\n    log_debug(\"main() args=%s\" % sys.argv)\n\n    def validate_invocation_style(opt, opts_instance, conflict_opts):\n        global invocation_style\n        conflict_opts.remove(opt)\n        invocation_style = opt\n        for i in conflict_opts:\n            if (getattr(opts_instance,i)):\n                    print >> sys.stderr, \"cannot run as %s with other option\" % (opt)\n                    sys.exit(3)\t\t\t\t\t\n\n    try:\n        from optparse import OptionParser\n        parser = OptionParser()\n\n        parser.add_option(\"-b\", \"--browser\", action=\"store_true\", dest=\"browser\", default=False,\n                            help=\"Launch the browser\")\n        parser.add_option(\"-s\", \"--service\", action=\"store_true\", dest=\"service\", default=False,\n                            help=\"Start sealert as a dbus service\")\n        parser.add_option(\"-S\", \"--noservice\", action=\"store_true\", dest=\"noservice\", default=False,\n                            help=\"Start sealert without dbus service as stand alone app\")\n        parser.add_option(\"-l\", \"--lookupid\", dest=\"lookupid\", default=False,\n                            help=\"Lookup alert by id, id may be wildcard * to lookup all alerts\")\n        parser.add_option(\"-a\", \"--analyze\", dest=\"analyze\",  default=False,\n                            help=\"Scan a log file, analyze it's AVC's\", metavar=\"FILE\")\n        parser.add_option(\"-u\", \"--user\",  dest=\"user\", default=False,\n                            help=\"logon user name\")\n        parser.add_option(\"-p\", \"--password\", dest=\"password\", default=False,\n                            help=\"logon user password\")\n        parser.add_option(\"-P\", \"--plugin\", dest=\"plugin\", default=False,\n                            help=\"Plugin Name Required for -f\")\n        parser.add_option(\"-f\", \"--fix\", dest=\"fix\", default=False,\n                            help=\"fix avc with the given uuid, requires plugin\")\n\n        conflict_opts = [\"analyze\", \"browser\", \"fix\", \"lookupid\", \"noservice\", \"service\"]\n        username = None\n        password = None\n        plugin_name = None\n\n        (options, args) = parser.parse_args()\n\n        if options.user:\n            username = options.user\n        else:\n            username = get_identity()\n\n        if options.password:\n            password = options.password    \n        else:\n            password = 'passwd'\n\n        if options.browser:\n            validate_invocation_style(\"browser\", options, conflict_opts)\n      \n        if options.service:\n            validate_invocation_style(\"service\", options, conflict_opts)\n\n        if options.noservice:\n            validate_invocation_style(\"noservice\", options, conflict_opts)\n\n        if options.lookupid:\n            validate_invocation_style(\"lookupid\", options, conflict_opts)\n            local_id = options.lookupid\n\n        if options.analyze:\n            validate_invocation_style(\"analyze\", options, conflict_opts)\n            use_terminal = True\n            logfile = options.analyze\n\n        if options.plugin:\n            plugin_name = options.plugin\n\n        if options.fix:\n            validate_invocation_style(\"fix\", options, conflict_opts)\n            local_id = options.fix\n            if options.plugin:\n                plugin_name = options.plugin\n            else:\n                print >> sys.stderr, \"-P plugin_name required for fix\"\n                sys.exit(3)\n\n        # Attempt to communicate with the service.  DBus should start it if it is not\n        # running, otherwise we will become the service\n        if invocation_style is None:\n            log_debug(\"invocation style not set, asking dbus to start us\")\n            try:\n                bus = dbus.SessionBus()\n                proxy_obj = bus.get_object(dbus_session_bus_name, dbus_session_object_path)\n                iface = dbus.Interface(proxy_obj, dbus_session_interface)\n                s = iface.start()\n            except dbus.DBusException:\n                print >> sys.stderr, \"could not attach to desktop process\"\n                sys.exit(1)\n            sys.exit()\n\n            log_debug(\"invocation style = '%s'\" % invocation_style)\n\n        if invocation_style == 'browser':\n            ask_dbus_to_show_browser()\n            sys.exit()\n        elif invocation_style == 'service':\n            try:\n                # This import must come before importing gtk to silence warnings\n                import gtk\n                run_as_dbus_service(username)\n            except RuntimeError, e:\n                print e\n                sys.exit(3)\n            sys.exit()\n        elif invocation_style == 'noservice':\n            # This import must come before importing gtk to silence warnings\n            import gtk\n            run_app(username)\n            sys.exit()\n        elif invocation_style == 'lookupid':\n            use_terminal = True\n\n            from setroubleshoot.signature import *\n            try:\n                # make sure setroubleshoot is running\n                bus = dbus.SystemBus()\n                proxy_obj = bus.get_object(dbus_system_bus_name, dbus_system_object_path)\n                iface = dbus.Interface(proxy_obj, dbus_system_interface)\n                iface.start()\n                command_line_lookup_id(local_id)\n                iface.finish()\n            except ValueError, e:\n                print >> sys.stderr, e\n                sys.exit(3)\n\n            sys.exit()\n        elif invocation_style == 'analyze':\n            use_terminal = True\n\n            try:\n                do_analyze_logfile(logfile)\n            except OSError, e:\n                print e\n                sys.exit(3)\n            except ProgramError, e:\n                print >> sys.stderr, e.strerror\n                sys.exit(3)\n                \n        elif invocation_style == 'fix':\n            use_terminal = True\n\n            from setroubleshoot.signature import *\n            try:\n                bus = dbus.SystemBus()\n                proxy_obj = bus.get_object(dbus_system_bus_name, dbus_system_object_path)\n                iface = dbus.Interface(proxy_obj, dbus_system_interface)\n                iface.start()\n\n                fix_lookup_id(local_id, plugin_name)\n                iface.finish()\n            except dbus.DBusException, e:\n                print >> sys.stderr, \"could not attach to desktop process\"\n                sys.exit(3)\n                \n            sys.exit()\n        else:\n            print >> sys.stderr, \"unknown invocation style (%s)\" % invocation_style\n            sys.exit(3)\n    except Exception, e:\t\n        syslog.syslog(syslog.LOG_ERR, \"exception %s: %s\" % (e.__class__.__name__, str(e)))\n        if use_terminal:\n            display_terminal_traceback('sealert')\n        else:\n            display_traceback('sealert')\n\n        sys.exit(3)\n", "# Authors: John Dennis <jdennis@redhat.com>\n#          Thomas Liu <tliu@redhat.com>\n#          Dan Walsh <dwalsh@redhat.com>\n#\n# Copyright (C) 2006-2010 Red Hat, Inc.\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n#\nimport syslog\nfrom subprocess import *\nimport setroubleshoot.default_encoding_utf8\nimport gettext\ntranslation=gettext.translation('setroubleshoot-plugins', fallback=True)\n_=translation.ugettext\n\n__all__ = [\n           'SignatureMatch',\n           'SEFilter',\n           'SEFaultSignature',\n           'SEFaultSignatureInfo',\n           'SEFaultSignatureSet',\n           'SEFaultSignatureUser',\n           'SEEnvironment',\n           'SEDatabaseProperties',\n           'SEFaultUserInfo',\n           'SEFaultUserSet',\n           'SEPlugin',\n           'SEEmailRecipient',\n           'SEEmailRecipientSet',\n\n           'FILTER_NEVER',\n           'FILTER_ALWAYS',\n           'FILTER_AFTER_FIRST',\n           'filter_text'\n           ]\n\nif __name__ == \"__main__\":\n    import gettext\n    from setroubleshoot.config import parse_config_setting, get_config\n    gettext.install(domain    = get_config('general', 'i18n_text_domain'),\n\t\t    localedir = get_config('general', 'i18n_locale_dir'))\n\nfrom gettext import ngettext as P_\nfrom setroubleshoot.config import get_config\nfrom setroubleshoot.errcode import *\nfrom setroubleshoot.util import *\nfrom setroubleshoot.xml_serialize import *\nfrom setroubleshoot.html_util import *\nimport setroubleshoot.uuid as uuid\nfrom setroubleshoot.audit_data import *\nimport hashlib\nfrom types import *\nfrom string import Template\nimport re, os\n\n# Don't reuse the numeric values!\nFILTER_NEVER              = 0\nFILTER_ALWAYS             = 4\nFILTER_AFTER_FIRST        = 8\n\nfilter_text = {\n    FILTER_NEVER              : _(\"Never Ignore\"),\n    FILTER_ALWAYS             : _(\"Ignore Always\"),\n    FILTER_AFTER_FIRST        : _(\"Ignore After First Alert\"),\n    }\n\nmap_filter_value_to_name = {\n    FILTER_NEVER              : 'never',\n    FILTER_ALWAYS             : 'always',\n    FILTER_AFTER_FIRST        : 'after_first',\n    }\n\nmap_filter_name_to_value = {\n    'never'                   : FILTER_NEVER,\n    'always'                  : FILTER_ALWAYS,\n    'after_first'             : FILTER_AFTER_FIRST,\n    }\n\n#------------------------------------------------------------------------\n\nclass SignatureMatch(object):\n    def __init__(self, siginfo, score):\n        self.siginfo = siginfo\n        self.score = score\n\n\nclass SEEnvironment(XmlSerialize):\n    _xml_info = {\n    'version'             : {'XMLForm':'attribute','default':lambda: '1.0' },\n    'platform'            : {'XMLForm':'element' },\n    'kernel'              : {'XMLForm':'element' },\n    'policy_type'         : {'XMLForm':'element' },\n    'policy_rpm'          : {'XMLForm':'element' },\n    'enforce'             : {'XMLForm':'element' },\n    'selinux_enabled'     : {'XMLForm':'element', 'import_typecast':boolean, },\n    'selinux_mls_enabled' : {'XMLForm':'element', 'import_typecast':boolean, },\n    'policyvers'          : {'XMLForm':'element' },\n    'hostname'            : {'XMLForm':'element' },\n    'uname'               : {'XMLForm':'element' },\n    }\n\n    def __init__(self):\n        super(SEEnvironment, self).__init__()\n        self.update()\n\n    def update(self):\n        import platform\n        import selinux\n        # security_getenforce is the same as the getenforce command.\n        # selinux_getenforcemode tells you what is set in /etc/selinux/config\n\n        self.platform, self.kernel = get_os_environment()\n        self.policy_type = selinux.selinux_getpolicytype()[1]\n        self.policy_rpm = get_rpm_nvr_by_name(\"selinux-policy\")\n        self.policyvers = str(selinux.security_policyvers())\n        enforce = selinux.security_getenforce()\n        if enforce == 0:\n            self.enforce = \"Permissive\"\n        else:\n            self.enforce = \"Enforcing\"\n\n        self.selinux_enabled = bool(selinux.is_selinux_enabled())\n        self.selinux_mls_enabled = bool(selinux.is_selinux_mls_enabled())\n        self.hostname = platform.node()\n        self.uname = \" \".join(platform.uname())\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __eq__(self, other):\n        for name in self._xml_info.keys():\n            if getattr(self, name) != getattr(other, name):\n                return False\n        return True\n\n\n\nclass SEFilter(XmlSerialize):\n    _xml_info = {\n    'filter_type'      : {'XMLForm':'element', 'import_typecast':int, 'default':lambda: FILTER_NEVER },\n    'count'            : {'XMLForm':'element', 'import_typecast':int, 'default':lambda: 0 },\n    }\n    def __init__(self, filter_type=FILTER_NEVER):\n        super(SEFilter, self).__init__()\n        self.filter_type = filter_type\n        \n\nclass SEFaultSignatureUser(XmlSerialize):\n    _xml_info = {\n    'username'         : {'XMLForm':'attribute' },\n    'seen_flag'        : {'XMLForm':'attribute', 'import_typecast':boolean, 'default': lambda: False },\n    'delete_flag'      : {'XMLForm':'attribute', 'import_typecast':boolean, 'default': lambda: False },\n    'filter'           : {'XMLForm':'element', 'import_typecast':SEFilter, 'default': lambda: SEFilter() },\n    }\n    def __init__(self, username):\n        super(SEFaultSignatureUser, self).__init__()\n        self.username = username\n        \n    def update_item(self, item, data):\n        if not item in self._names:\n            raise ProgramError(ERR_NOT_MEMBER, 'item (%s) is not a defined member' % item)\n\n        if item == 'username':\n            raise ProgramError(ERR_ILLEGAL_USER_CHANGE, 'changing the username is illegal')\n            \n        setattr(self, item, data)\n\n    def update_filter(self, filter_type, data=None):\n        log_debug(\"update_filter: filter_type=%s data=%s\" % (map_filter_value_to_name.get(filter_type, 'unknown'), data))\n        if filter_type == FILTER_NEVER or \\\n           filter_type == FILTER_AFTER_FIRST or \\\n           filter_type == FILTER_ALWAYS:\n            log_debug(\"update_filter: !!!\")\n            self.filter = SEFilter(filter_type=filter_type)\n            return True\n        else:\n            raise ValueError(\"Bad filter_type (%s)\" % filter_type)\n\n\nclass_dict = {}\nclass_dict['dir']     = _(\"directory\")\nclass_dict['sem']     = _(\"semaphore\")\nclass_dict['shm']     = _(\"shared memory\")\nclass_dict['msgq']    = _(\"message queue\")\nclass_dict['msg']     = _(\"message\")\nclass_dict['file']    = _(\"file\")\nclass_dict['socket']  = _(\"socket\")\nclass_dict['process'] = _(\"process\")\nclass_dict['filesystem'] = _(\"filesystem\")\nclass_dict['node'] = _(\"node\")\nclass_dict['capability'] = _(\"capability\")\n\ndef translate_class(tclass):\n    if tclass in class_dict.keys():\n        return class_dict[tclass]\n    return tclass\n\n# --\n\nclass AttributeValueDictionary(XmlSerialize):\n    _xml_info = 'unstructured'\n    def __init__(self):\n        super(AttributeValueDictionary, self).__init__()\n\nclass SEFaultSignature(XmlSerialize):\n    _xml_info = {\n    'version'          : {'XMLForm':'attribute','default':lambda: '4.0', },\n    'host'             : {'XMLForm':'element', },\n    'access'           : {'XMLForm':'element', 'list':'operation', },\n    'scontext'         : {'XMLForm':'element', 'import_typecast':AvcContext },\n    'tcontext'         : {'XMLForm':'element', 'import_typecast':AvcContext },\n    'tclass'           : {'XMLForm':'element', },\n    'port'             : {'XMLForm':'element', 'import_typecast':int, },\n    }\n    def __init__(self, **kwds):\n        super(SEFaultSignature, self).__init__()\n        for k,v in kwds.items():\n            setattr(self, k, v)\n        \nclass SEPlugin(XmlSerialize):\n    _xml_info = {\n    'analysis_id'          : {'XMLForm':'element'},\n    'args'                 : {'XMLForm':'element', 'list':'arg', },\n    }\n\n    def __init__(self, analysis_id, args):\n        super(SEPlugin, self).__init__()\n        self.analysis_id = analysis_id;\n        self.args = args;\n\n    def __str__(self):\n        return str((self.analysis_id, self.args))\n\nclass SEFaultSignatureInfo(XmlSerialize):\n    _xml_info = {\n        'plugin_list'       : {'XMLForm':'element', 'list':'plugin', 'import_typecast':SEPlugin },\n        'audit_event'      : {'XMLForm':'element', 'import_typecast':AuditEvent },\n        'source'           : {'XMLForm':'element' },\n        'spath'            : {'XMLForm':'element' },\n        'tpath'            : {'XMLForm':'element' },\n        'src_rpm_list'     : {'XMLForm':'element', 'list':'rpm', },\n        'tgt_rpm_list'     : {'XMLForm':'element', 'list':'rpm', },\n        'scontext'         : {'XMLForm':'element', 'import_typecast':AvcContext },\n        'tcontext'         : {'XMLForm':'element', 'import_typecast':AvcContext },\n        'tclass'           : {'XMLForm':'element', },\n        'port'             : {'XMLForm':'element', 'import_typecast':int, },\n\n        'sig'              : {'XMLForm':'element', 'import_typecast':SEFaultSignature },\n        'if_text'          : {'XMLForm':'element' },\n        'then_text'        : {'XMLForm':'element' },\n        'do_text'          : {'XMLForm':'element' },\n        'environment'      : {'XMLForm':'element',  'import_typecast':SEEnvironment },\n\n        'first_seen_date'  : {'XMLForm':'element', 'import_typecast':TimeStamp },\n        'last_seen_date'   : {'XMLForm':'element', 'import_typecast':TimeStamp },\n        'report_count'     : {'XMLForm':'element', 'import_typecast':int, 'default':lambda: 0 },\n        'local_id'         : {'XMLForm':'element' },\n        'users'            : {'XMLForm':'element', 'list':'user', 'import_typecast':SEFaultSignatureUser, },\n        'level'         : {'XMLForm':'element' },\n        'fixable'       : {'XMLForm':'element' },\n        'button_text'   : {'XMLForm':'element' },\n        }\n\n    merge_include = ['audit_event', 'tpath', 'src_rpm_list', 'tgt_rpm_list',\n                     'scontext', 'tcontext', 'tclass', 'port',\n                     'environment',\n                     'last_seen_date'\n                     ]\n\n\n    def __init__(self, **kwds):\n        super(SEFaultSignatureInfo, self).__init__()\n        for k,v in kwds.items():\n            setattr(self, k, v)\n        self.report_count = 1\n        self.plugin_list = []\n\n    def update_merge(self, siginfo):\n        if siginfo.last_seen_date != self.last_seen_date:\n            self.last_seen_date = siginfo.last_seen_date\n            self.report_count += 1\n\n        for name in self.merge_include:\n            setattr(self, name, getattr(siginfo, name))\n\n    def get_policy_rpm(self):\n        return self.environment.policy_rpm;\n\n    def get_hash_str(self):\n        return  \"%s,%s,%s,%s,%s\" % (self.source, self.scontext.type, self.tcontext.type, self.tclass, \",\".join(self.sig.access))\n\n    def get_hash(self):\n        hash = hashlib.sha256(self.get_hash_str())\n        return hash.hexdigest()\n        \n    def get_user_data(self, username):\n        for user in self.users:\n            if user.username == username:\n                return user\n        log_debug(\"new SEFaultSignatureUser for %s\" % username)\n        user = SEFaultSignatureUser(username)\n        self.users.append(user)\n        return user\n\n    def find_filter_by_username(self, username):\n        log_debug(\"find_filter_by_username %s\" % username)\n        \n        filter = None\n        user_data = self.get_user_data(username)\n        if user_data is not None:\n            filter = user_data.filter\n        return filter\n\n    def update_user_filter(self, username, filter_type, data=None):\n        user_data = self.get_user_data(username)\n        user_data.update_filter(filter_type, data)\n\n    def evaluate_filter_for_user(self, username, filter_type=None):\n        action = 'display'\n        f = self.find_filter_by_username(username)\n        log_debug(\"evaluate_filter_for_user: found %s user's filter = %s\" % (username, f))\n        if f is not None:\n            if filter_type is not None:\n                f.filter_type = filter_type\n            action = self.evaluate_filter(f)\n            log_debug(\"evaluate_filter_for_user: found filter for %s: %s\\n%s\" % (username, action, f))\n        return action\n        \n    def evaluate_filter(self, filter):\n        filter_type = filter.filter_type\n        \n        action = 'display'\n\n        if filter_type == FILTER_NEVER:\n            action = 'display'\n        elif filter_type == FILTER_AFTER_FIRST:\n            if filter.count == 0:\n                action = 'display'\n            else:\n                action = 'ignore'\n        elif filter_type == FILTER_ALWAYS:\n            action = 'ignore'\n        else:\n            raise ValueError(\"unknown filter_type (%s)\" % (filter_type))\n        filter.count += 1\n        return action\n\n    def format_rpm_list(self, rpm_list):\n        if isinstance(rpm_list, list):\n            if  len(rpm_list) > 0:\n                return \" \".join(rpm_list)\n            else:\n                return \"\"\n        else:\n            return default_text(None)\n\n    def format_target_object(self):\n        return \"%s [ %s ]\" % (self.tpath, self.tclass)\n\n    def description_adjusted_for_permissive(self):\n        permissive_msg = None\n        syscall_record = self.audit_event.get_record_of_type('SYSCALL')\n        if syscall_record != None and syscall_record.get_field('success') == 'yes':\n            permissive_msg = _(\"%s has a permissive type (%s). This access was not denied.\") % (self.source, self.scontext.type)\n\n        if self.environment.enforce == \"Permissive\":\n            permissive_msg = _(\"SELinux is in permissive mode. This access was not denied.\")\n\n    def update_derived_template_substitutions(self):\n        self.template_substitutions = {} \n        self.template_substitutions[\"SOURCE_TYPE\"] = self.scontext.type\n        self.template_substitutions[\"TARGET_TYPE\"] = self.tcontext.type\n        self.template_substitutions[\"SOURCE\"]      = self.source\n        self.template_substitutions[\"SOURCE_PATH\"] = self.spath\n        self.template_substitutions[\"SOURCE_BASE_PATH\"] = os.path.basename(self.spath)\n        if self.spath:\n            self.template_substitutions[\"FIX_SOURCE_PATH\"] = re.sub(\" \",\".\",self.spath)\n        else:\n            self.spath = _(\"N/A\")\n\n        self.template_substitutions[\"TARGET_PATH\"] = self.tpath\n        self.template_substitutions[\"TARGET_BASE_PATH\"] = os.path.basename(self.tpath)\n        if self.tpath:\n            self.template_substitutions[\"FIX_TARGET_PATH\"] = re.sub(\" \",\".\",self.tpath)\n\n        if self.tpath is None:\n            self.template_substitutions[\"TARGET_DIR\"] = None\n        else:\n            if self.tclass == 'dir':\n                self.template_substitutions[\"TARGET_DIR\"] = self.tpath\n            elif self.tclass == 'file':\n                self.template_substitutions[\"TARGET_DIR\"] = os.path.dirname(self.tpath)\n            else:\n                self.template_substitutions[\"TARGET_DIR\"] = None\n\n        if self.tclass == \"dir\":\n            self.template_substitutions[\"TARGET_CLASS\"] = \"directory\"\n        else:\n            self.template_substitutions[\"TARGET_CLASS\"] = self.tclass\n\n        if self.sig.access is None:\n            self.template_substitutions[\"ACCESS\"] = None\n        else:\n            self.template_substitutions[\"ACCESS\"] = ' '.join(self.sig.access)\n\n        if len(self.src_rpm_list) > 0:\n            self.template_substitutions[\"SOURCE_PACKAGE\"] = self.src_rpm_list[0]\n        self.template_substitutions[\"PORT_NUMBER\"] = self.port\n\n        # validate, replace any None values with friendly string\n        for key, value in self.template_substitutions.items():\n            if value is None:\n                self.template_substitutions[key] = default_text(value)\n\n    def priority_sort(self, x, y):\n        return cmp(y[0].priority,x[0].priority)\n\n    def summary(self):\n        if self.tclass == \"process\":\n            return P_(_(\"SELinux is preventing %s from using the %s access on a process.\"), _(\"SELinux is preventing %s from using the '%s' accesses on a process.\"), len(self.sig.access)) % (self.spath, \", \".join(self.sig.access))\n\n        if self.tclass == \"capability\":\n            return P_(_(\"SELinux is preventing %s from using the %s capability.\"), _(\"SELinux is preventing %s from using the '%s' capabilities.\"), len(self.sig.access)) % (self.spath, \", \".join(self.sig.access))\n        if self.tpath == \"(null)\":\n            return P_(_(\"SELinux is preventing %s from %s access on the %s labeled %s.\"), _(\"SELinux is preventing %s from '%s' accesses on the %s labeled %s.\"), len(self.sig.access)) % (self.spath, \", \".join(self.sig.access), translate_class(self.tclass), self.tcontext.type)\n        return P_(_(\"SELinux is preventing %s from %s access on the %s %s.\"), _(\"SELinux is preventing %s from '%s' accesses on the %s %s.\"), len(self.sig.access)) % (self.spath, \", \".join(self.sig.access), translate_class(self.tclass), self.tpath)\n\n    def get_plugins(self, all = False):\n        self.plugins = load_plugins()\n        plugins = []\n        total_priority = 0\n        if all:\n            for p  in self.plugins:\n                total_priority += p.priority\n                plugins.append((p, (\"allow_ypbind\", \"1\")))\n        else:\n            for solution in self.plugin_list:\n                for p  in self.plugins:\n                    if solution.analysis_id == p.analysis_id:\n                        total_priority += p.priority\n                        plugins.append((p, tuple(solution.args)))\n                        break\n\n        plugins.sort(self.priority_sort)\n\n        return total_priority, plugins\n\n    def substitute(self, txt):\n        return Template(txt).safe_substitute(self.template_substitutions)\n\n    def substitute_array(self, args):\n        return [self.substitute(txt) for txt in args]\n\n    def format_details(self, replace=False):\n        env = self.environment\n\n        text = _(\"Additional Information:\\n\")\n        text += format_2_column_name_value(_(\"Source Context\"),        self.scontext.format())\n        text += format_2_column_name_value(_(\"Target Context\"),        self.tcontext.format())\n        text += format_2_column_name_value(_(\"Target Objects\"),        self.format_target_object())\n        text += format_2_column_name_value(_(\"Source\"),                default_text(self.source))\n        text += format_2_column_name_value(_(\"Source Path\"),           default_text(self.spath))\n        text += format_2_column_name_value(_(\"Port\"),                  default_text(self.port))\n        if (replace):\n            text += format_2_column_name_value(_(\"Host\"),              \"(removed)\")\n        else:\n            text += format_2_column_name_value(_(\"Host\"),                  default_text(self.sig.host))\n        text += format_2_column_name_value(_(\"Source RPM Packages\"),   default_text(self.format_rpm_list(self.src_rpm_list)))\n        text += format_2_column_name_value(_(\"Target RPM Packages\"),   default_text(self.format_rpm_list(self.tgt_rpm_list)))\n        text += format_2_column_name_value(_(\"Policy RPM\"),            default_text(env.policy_rpm))\n        text += format_2_column_name_value(_(\"Selinux Enabled\"),       default_text(env.selinux_enabled))\n        text += format_2_column_name_value(_(\"Policy Type\"),           default_text(env.policy_type))\n        text += format_2_column_name_value(_(\"Enforcing Mode\"),        default_text(env.enforce))\n        if replace:\n            text += format_2_column_name_value(_(\"Host Name\"),\"(removed)\")\n        else:\n            text += format_2_column_name_value(_(\"Host Name\"),         default_text(env.hostname))\n\n        if replace:\n            uname = env.uname.split()\n            uname[1] = \"(removed)\"\n            text += format_2_column_name_value(_(\"Platform\"),          default_text(\" \".join(uname)))\n        else:\n            text += format_2_column_name_value(_(\"Platform\"),              default_text(env.uname))\n        text += format_2_column_name_value(_(\"Alert Count\"),           default_text(self.report_count))\n        date_format = \"%Y-%m-%d %H:%M:%S %Z\"\n        text += format_2_column_name_value(_(\"First Seen\"),            self.first_seen_date.format(date_format))\n        text += format_2_column_name_value(_(\"Last Seen\"),             self.last_seen_date.format(date_format))\n        text += format_2_column_name_value(_(\"Local ID\"),              default_text(self.local_id))\n\n        text += '\\n' + _(\"Raw Audit Messages\")\n        avcbuf = \"\"\n        for audit_record in self.audit_event.records:\n            if audit_record.record_type == 'AVC':\n                avcbuf += \"\\n\" + audit_record.to_text() + \"\\n\"\n            else:\n                avcbuf += \"\\ntype=%s msg=%s: \" % (audit_record.record_type, audit_record.event_id)\n                avcbuf += ' '.join([\"%s=%s\" % (k, audit_record.fields[k]) for k in audit_record.fields_ord]) +\"\\n\"\n\n        avcbuf += \"\\nHash: \" + self.get_hash_str() \n\n        try:\n            audit2allow = \"/usr/bin/audit2allow\"\n            if os.path.exist(audit2allow):\n                newbuf = \"\\n\\naudit2allow\"\n                p =  Popen([audit2allow], shell=True,stdin=PIPE, stdout=PIPE)\n                newbuf += p.communicate(avcbuf)[0]\n                if os.path.exists(\"/var/lib/sepolgen/interface_info\"):\n                    newbuf += \"\\naudit2allow -R\"\n                    p =  Popen([\"%s -R\" % audit2allow ], shell=True,stdin=PIPE, stdout=PIPE)\n                    newbuf += p.communicate(avcbuf)[0]\n                avcbuf += newbuf\n        except:\n            pass\n\n        text += avcbuf + '\\n'\n\n        return text\n\n    def untranslated(self, func, *args, **kwargs):\n        r'define.*untranslated\\(.*\\n'\n        # Call the parameter function with the translations turned off\n        # This function is not thread safe, since it manipulates globals\n\n        global P_, _\n        saved_translateP_ = P_\n        saved_translate_ = _\n\n        try:\n            P_ = lambda x,y,z: x if z > 1 else y\n            _ = lambda x:x\n            return func(*args, **kwargs)\n        finally:\n            P_ = saved_translateP_ \n            _ = saved_translate_\n\n    def format_text(self, all = False, replace = False):\n        self.update_derived_template_substitutions()\n\n        text = self.summary()\n\n        total_priority, plugins = self.get_plugins(all)\n\n        for p, args in plugins:\n            title = _(\"\\n\\n*****  Plugin %s (%.4s confidence) suggests   \") % (p.analysis_id, ((float(p.priority) / float(total_priority)) * 100 + .5))\n            text +=  title\n            for i in range(len(title),80):\n                text +=  _(\"*\")\n            text +=  _(\"\\n\")\n            txt = self.substitute(p.get_if_text(self.audit_event.records, args)).decode('utf-8')\n            text +=  _(\"\\nIf \") + txt[0].lower() + txt[1:]\n            txt = self.substitute(p.get_then_text(self.audit_event.records, args)).decode('utf-8')\n            text +=  _(\"\\nThen \") + txt[0].lower() + txt[1:]\n\n            txt = self.substitute(p.get_do_text(self.audit_event.records, args)).decode('utf-8')\n            text +=  _(\"\\nDo\\n\") + txt[0].lower() + txt[1:]\n\n        text += _('\\n\\n')\n        return text\n\nclass SEFaultUserInfo(XmlSerialize):\n    _xml_info = {\n    'version'            : {'XMLForm':'attribute','default':lambda: '1.0' },\n    'username'           : {'XMLForm':'attribute' },\n    'email_alert'        : {'XMLForm':'element', 'import_typecast':boolean, 'default': lambda: False },\n    'email_address_list' : {'XMLForm':'element', 'list':'email_address', },\n    }\n    def __init__(self, username):\n        super(SEFaultUserInfo, self).__init__()\n        self.username = username\n\n    def add_email_address(self, email_address):\n        if not email_address in self.email_address_list:\n            self.email_address_list.append(email_address)\n\n\n\nclass SEFaultUserSet(XmlSerialize):\n    _xml_info = {\n    'version'      : {'XMLForm':'attribute','default':lambda: '1.0' },\n    'user_list'    : {'XMLForm':'element', 'list':'user', 'import_typecast':SEFaultUserInfo, },\n    }\n    def __init__(self):\n        super(SEFaultUserSet, self).__init__()\n\n    def get_user(self, username):\n        for user in self.user_list:\n            if username == user.username:\n                return user\n        return None\n\n    def add_user(self, username):\n        if self.get_user(username) is not None:\n            return\n        user = SEFaultUserInfo(username)\n        self.user_list.append(user)\n        return user\n\n\n\nclass SEFaultSignatureSet(XmlSerialize):\n    _xml_info = {\n    'version'          : {'XMLForm':'attribute','default':lambda: '%d.%d' %  (DATABASE_MAJOR_VERSION, DATABASE_MINOR_VERSION)},\n    'users'            : {'XMLForm':'element', 'import_typecast':SEFaultUserSet, 'default': lambda: SEFaultUserSet() },\n    'signature_list'   : {'XMLForm':'element', 'list':'siginfo', 'import_typecast':SEFaultSignatureInfo, },\n    }\n    def __init__(self):\n        super(SEFaultSignatureSet, self).__init__()\n\n    def siginfos(self):\n        for siginfo in self.signature_list:\n            yield siginfo\n\n    def add_siginfo(self, siginfo):\n        self.signature_list.append(siginfo)\n        return siginfo\n\n    def remove_siginfo(self, siginfo):\n        self.signature_list.remove(siginfo)\n\n    def clear(self):\n        self.signature_list = []\n        \n\n    def generate_local_id(self):\n        return str(uuid.uuid4())\n\n    def lookup_local_id(self, local_id):\n        if local_id is None:\n            return None\n\n        for siginfo in self.signature_list:\n            if siginfo.local_id == local_id:\n                return siginfo\n\n        return None\n\n    def match_signatures(self, pat, criteria='exact', xml_info=SEFaultSignature._xml_info):\n        match_targets = xml_info.keys()\n        exact = False\n        if criteria == 'exact':\n            exact = True\n        elif type(criteria) is FloatType:\n            num_match_targets = len(match_targets)\n            score_per_match_target = 1.0 / num_match_targets\n        else:\n            raise ValueError(\"unknown criteria = %s\" % criteria)\n        \n        matches = []\n        for siginfo in self.signature_list:\n            score = 0.0\n            sig = siginfo.sig\n            for name in match_targets:\n                if getattr(pat, name) == getattr(sig, name):\n                    if exact:\n                        score = 1.0\n                    else:\n                        score += score_per_match_target\n                else:\n                    if exact:\n                        score = 0.0\n                        break\n            if exact:\n                if score == 1.0:\n                    matches.append(SignatureMatch(siginfo, score))\n            else:\n                if score >= criteria:\n                    matches.append(SignatureMatch(siginfo, score))\n        matches.sort((lambda a,b: cmp(b.score, a.score)))\n        return matches\n\n\n\n\nclass SEDatabaseProperties(XmlSerialize):\n    _xml_info = {\n    'name'          : {'XMLForm':'element' },\n    'friendly_name' : {'XMLForm':'element' },\n    'filepath'      : {'XMLForm':'element' },\n    }\n    def __init__(self, name=None, friendly_name=None, filepath=None):\n        super(SEDatabaseProperties, self).__init__()\n        if name is not None:\n            self.name = name\n        if friendly_name is not None:\n            self.friendly_name = friendly_name\n        if filepath is not None:\n            self.filepath = filepath\n\nclass SEEmailRecipient(XmlSerialize):\n    _xml_info = {\n    'address'          : {'XMLForm':'element' },\n    'filter_type'      : {'XMLForm':'element', 'import_typecast':int, 'default':lambda: FILTER_AFTER_FIRST },\n    }\n    def __init__(self, address, filter_type=None):\n        super(SEEmailRecipient, self).__init__()\n        self.address = address\n        if filter_type is not None:\n            self.filter_type = filter_type\n\n    def __str__(self):\n        return \"%s:%s\" % (self.address, map_filter_value_to_name.get(self.filter_type, 'unknown'))\n\n\nclass SEEmailRecipientSet(XmlSerialize):\n    _xml_info = {\n    'version'         : {'XMLForm':'attribute','default':lambda: '1' },\n    'recipient_list'  : {'XMLForm':'element', 'list':'recipient', 'import_typecast':SEEmailRecipient, },\n    }\n    def __init__(self, recipient_list=None):\n        super(SEEmailRecipientSet, self).__init__()\n        if recipient_list is not None:\n            self.recipient_list = recipient_list\n\n    def __str__(self):\n        return ','.join([str(x) for x in self.recipient_list])\n\n    def find_address(self, address):\n        address = address.strip()\n        for recipient in self.recipient_list:\n            if address == recipient.address:\n                return recipient\n        return None\n\n    def add_address(self, address, filter_type=FILTER_AFTER_FIRST):\n        address = address.strip()\n        if not valid_email_address(address):\n            raise ProgramError(ERR_INVALID_EMAIL_ADDR, detail=\"address='%s'\" % address)\n            return\n\n        recipient = self.find_address(address)\n        if recipient is not None:\n            return\n        self.recipient_list.append(SEEmailRecipient(address, filter_type))\n\n    def clear_recipient_list(self):\n        self.recipient_list = []\n\n    def parse_recipient_file(self, filepath):\n        import re\n        comment_re = re.compile('#.*')\n        entry_re = re.compile('(\\S+)(\\s+(.+))?')\n        key_value_re = re.compile(\"(\\w+)\\s*=\\s*(\\S+)\")\n\n        map_boolean = {'enabled'  : True,\n                       'true'     : True,\n                       'yes'      : True,\n                       'on'       : True,\n                       'disabled' : False,\n                       'false'    : False,\n                       'no'       : False,\n                       'off'      : False,\n                       }\n\n\n        try:\n            f = open(filepath)\n        except IOError, e:\n            raise ProgramError(ERR_FILE_OPEN, detail=\"%s, %s\" % (filepath, e.strerror))\n\n        self.clear_recipient_list()\n\n        for line in f.readlines():\n            line = comment_re.sub('', line)\n            line = line.strip()\n            if line:\n                match = entry_re.search(line)\n                if match:\n                    address = match.group(1)\n                    options = match.group(3)\n                    filter_type = None\n\n                    if options:\n                        for match in key_value_re.finditer(options):\n                            option = match.group(1)\n                            value  = match.group(2)\n\n\n                            if option == 'filter_type':\n                                filter_type = map_filter_name_to_value.get(value.lower(), None)\n                                if filter_type is None:\n                                    log_debug(\"unknown email filter (%s) for address %s\" % (option, address))\n                                    \n                            else:\n                                log_debug(\"unknown email option (%s) for address %s\" % (option, address))\n                                \n                    try:\n                        self.add_address(address, filter_type)\n                    except ProgramError, e:\n                        if e.errno == ERR_INVALID_EMAIL_ADDR:\n                            log_debug(e.strerror)\n                        else:\n                            raise e\n\n\n        f.close()\n\n    def write_recipient_file(self, filepath):\n        try:\n            f = open(filepath, 'w')\n        except IOError, e:\n            raise ProgramError(ERR_FILE_OPEN, detail=\"%s, %s\" % (filepath, e.strerror))\n\n        for recipient in self.recipient_list:\n            filter_type = map_filter_value_to_name[recipient.filter_type]\n            f.write(\"%-40s filter_type=%s\\n\" % (recipient.address, filter_type))\n        \n        f.close()\n\n\n#------------------------------------------------------------------------\n\n\nif __name__ == '__main__':\n    import libxml2\n    #memory debug specific\n    libxml2.debugMemory(1)\n\n    xml_file = 'audit_listener_database.xml'\n\n    sigs = SEFaultSignatureSet()\n    sigs.read_xml_file(xml_file, 'sigs')\n    siginfo = sigs.signature_list[0]\n    record = siginfo.audit_event.records[0]\n    print record.record_type\n    print \"siginfo.audit_event=%s\" % siginfo.audit_event\n    print sigs\n\n    #memory debug specific\n    libxml2.cleanupParser()\n    if libxml2.debugMemory(1) == 0:\n        print \"Memory OK\"\n    else:\n        print \"Memory leak %d bytes\" % (libxml2.debugMemory(1))\n        libxml2.dumpMemory()\n"], "filenames": ["framework/src/sealert", "framework/src/setroubleshoot/signature.py"], "buggy_code_start_loc": [144, 462], "buggy_code_end_loc": [160, 462], "fixing_code_start_loc": [144, 463], "fixing_code_end_loc": [160, 466], "type": "CWE-77", "message": "The fix_lookup_id function in sealert in setroubleshoot before 3.2.23 allows local users to execute arbitrary commands as root by triggering an SELinux denial with a crafted file name, related to executing external commands with the commands.getstatusoutput function.", "other": {"cve": {"id": "CVE-2016-4445", "sourceIdentifier": "secalert@redhat.com", "published": "2017-04-11T18:59:00.260", "lastModified": "2017-04-17T13:16:04.173", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The fix_lookup_id function in sealert in setroubleshoot before 3.2.23 allows local users to execute arbitrary commands as root by triggering an SELinux denial with a crafted file name, related to executing external commands with the commands.getstatusoutput function."}, {"lang": "es", "value": "La funci\u00f3n fix_lookup_id en sealert en setroubleshoot en versiones anteriores a 3.2.23 permite a los usuarios locales ejecutar comandos arbitrarios como root activando una denegaci\u00f3n de SELinux con un nombre de archivo manipulado, relacionado con la ejecuci\u00f3n de comandos externos con la funci\u00f3n commands.getstatusoutput."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-77"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:setroubleshoot_project:setroubleshoot:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.2.22", "matchCriteriaId": "5C62A645-0382-4719-99D0-2247C4EAA2A0"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_hpc_node:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "3C84489B-B08C-4854-8A12-D01B6E45CF79"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}], "references": [{"url": "http://seclists.org/oss-sec/2016/q2/575", "source": "secalert@redhat.com", "tags": ["Exploit", "Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/91430", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1036144", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1339183", "source": "secalert@redhat.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/fedora-selinux/setroubleshoot/commit/2d12677629ca319310f6263688bb1b7f676c01b7", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://rhn.redhat.com/errata/RHSA-2016-1267.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/fedora-selinux/setroubleshoot/commit/2d12677629ca319310f6263688bb1b7f676c01b7"}}