{"buggy_code": ["lldpd (1.0.16)\n * Fix:\n   + Do not use 00:00:00:00:00:00 as chassis ID.\n   + Do not busy loop when an interface with a neighbor disappears.\n\nlldpd (1.0.15)\n * Changes\n   + Add configure command to override system capabilities. Contributed by\n     Ignacio Sanchez Navarro. (#526)\n   + An unrecognized ORG TLV is now considered as a custom one. (#536)\n * Fix:\n   + Really don't send VLANs when there are too many (#520)\n   + Ignore temporary IPv6 addresses (#521)\n\nlldpd (1.0.14)\n * Changes\n   + Add configure commands to alter inventory TLVs (#508)\n * Fix:\n   + Update seccomp rules for newer kernel/libc (#488)\n   + Correctly handle an interface whose index has changed (#490)\n   + Don't send VLANs when there are too many (#501)\n\nlldpd (1.0.13)\n * Fix:\n   + Add support for 2.5G, 5G, 25G and 50G based Ethernet (#475)\n   + Fix link-down detection on OpenBSD (#476)\n   + Fix LLDP packets encapsuled in VLAN 0 in some conditions\n   + Fix heap overflow when reading SONMP. CVE-2021-43612.\n     Thanks to Jeremy Galindo for discovering this one.\n\nlldpd (1.0.12)\n  * Fix:\n    + Use a dedicated file lock to prevent concurrent changes from lldpcli.\n    + Require/display powerpairs for Dot3 power even when device type is PD.\n  * Changes:\n    + Provide a Docker image and make it available on GitHub.\n\nlldpd (1.0.11)\n  * Changes:\n    + Disable LLDP in firmware for Intel X7xx cards.\n  * Fix:\n    + Ensure Intel E8xx cards can transmit LLDP packets.\n\nlldpd (1.0.10)\n  * Fix:\n    + Fix chroot directory creation.\n\nlldpd (1.0.9)\n  * Fix:\n    + Do not use interface alias if we set it ourselves.\n    + More memory leak fixes on duplicate TLVs in LLDP, CDP and EDP\n      (related to CVE-2020-27827).\n    + On OSX, handle empty groups correctly when looking for a free UID/GID.\n  * Changes:\n    + Display port status with \"show interfaces\".\n    + Do not display \"age\" and \"via\" when using \"show interfaces\".\n\nlldpd (1.0.8)\n  * Fix:\n    + Out-of-bound read access when parsing LLDP-MED civic address in\n      liblldpctl for malformed fields.\n    + Fix memory leak when receiving LLDPU with duplicate fields.\n      CVE-2020-27827.\n  * Changes:\n    + Enable \"router\" capability bit when IPv6 routing is enabled.\n\nlldpd (1.0.7)\n  * Fix:\n    + Do not listen only to LLDP packets on Linux. When an interface\n      is enslaved to an Open vSwitch, incoming packets are missed.\n\nlldpd (1.0.6)\n  * Fix:\n    + Do not loose chassis local information when interface status changes.\n    + Fix SNMP walk on lldpRemTable when missing remote system\n      name or description.\n    + Remove length limitation on system description and platform.\n  * Changes:\n    + Deprecate use of lldpctl_watch_callback(). Use\n      lldpctl_watch_callback2() instead.\n    + Upgrade embedded libevent to 2.1.11-stable\n    + Add support of sending LLDP frames on a configured VLAN\n\nlldpd (1.0.5)\n  * Changes:\n    + Interface names are also matched for management addresses.\n    + On Linux, only register protocol handler for LLDP when only LLDP\n      is enabled.\n    + Stricter on LLDP incoming frames validation.\n    + Add support for VLAN-aware bridges for Linux (no range support).\n    + Add support for 802.3BT (no SNMP support).\n    + Add support for millisecond-grained tx-interval (Jean-Pierre Tosoni).\n    + Use generic names for VLAN names, instead of interface names (eg\n      vlan100 instead of eth1.100).\n  * Fix:\n    + Don't clear chassis TLV on shutdown LLDPDU.\n    + Don't require/display powerpairs for Dot3 power when device type\n      is PD.\n\nlldpd (1.0.4)\n  * Changes:\n    + Add \"configure system max-neighbors XX\" command to modify maximum\n      of neighbors accepted per port.\n    + Implement lldpRemOrgDefInfoTable table for custom TLVs.\n  * Fix:\n    + Better compliance for statsTLVsUnrecognizedTotal and\n      statsAgeoutsTotal counters.\n    + On Linux, handle rare blocking case in Netlink code.\n\nlldpd (1.0.3)\n  * Fix:\n    + Fix creation of chroot directory.\n\nlldpd (1.0.2)\n  * Changes:\n    + On Linux, the monitor process will now drop its privileges\n      instead of running as root. It will keep CAP_NET_RAW,\n      CAP_NET_ADMIN and CAP_DAC_OVERRIDE capabilities.\n    + Support for CDP PD PoE (with negotiation). Thanks to Gustav\n      Wiklander.\n    + Move support for bonded devices on Linux < 2.6.27 into the\n      `--enable-oldies` option. This avoids duplicate packets\n      starting from Linux 4.19.\n\nlldpd (1.0.1)\n  * Fix:\n    + Use \"mkdir -p\" instead of \"mkdir\" in systemd unit.\n\nlldpd (1.0.0)\n  * Changes:\n    + Chassis ID can be set to an arbitrary value with \"configure system\n      chassisid\".\n    + Port description can be overriden directly with \"configure lldp\n      portdescription\".\n    + Command \"configure system interface permanent\" enables one to\n      specify a pattern for interfaces to be kept in memory even when\n      they are removed from the system.\n  * Fix:\n    + Ensure chassis-related changes are propagated immediately.\n    + Ensure management address change is correctly detected.\n\nlldpd (0.9.9)\n  * Changes:\n    + lldpcli can now display local interfaces with LLDP data sent on\n      each of them (\"show interfaces\").\n    + As Dot3 PD device, echo back allocated value from PSE device.\n  * Fix:\n    + Don't remove interfaces when they are released from a bridge.\n    + Don't use \"expect stop\" with Upstart. It's buggy.\n\nlldpd (0.9.8)\n  * Changes:\n    + \"Station\" capability is only set if no other bit is set.\n    + Use ethtool to get permanent address for bonds and teams. This\n      might provide different results than the previous method. Some\n      devices may still use the previous method.\n    + Don't run ethtool as root. Kernels older than 2.6.19 won't get\n      link information anymore.\n    + Add \"configure system hostname .\" option to not use a FQDN\n      for system name.\n    + Add \"-f json0\" to provide a more regular/machine-parsable output\n      to JSON output, even when not compiled with --enable-json0.\n  * Fixes:\n    + Handle team interfaces like a bond. Real MAC address cannot be\n      retrieved yet.\n\nlldpd (0.9.7)\n  * Changes:\n    + Attach remote TTL to port instead of chassis.\n    + JSON support is now built-in and unconditionally enabled. Use\n      --enable-json0 to keep the pre-0.9.2 json-c format.\n    + When logging to syslog and daemonizing, don't log to stderr.\n    + vxlan interfaces are now ignored as they are multi-point interfaces.\n    + Maximum number of neighbors for an interface is increased from 4 to 32.\n\nlldpd (0.9.6)\n  * Changes:\n    + Add a compile-time option to restore pre-0.9.2 JSON format (when\n      using json-c). Use `--enable-json0` to enable this option.\n    + Support for newer ethtool interface on Linux\n      (ETHTOOL_GLINKSETTINGS) and additional speed settings.\n    + Current MAU type is displayed even when autoneg is off.\n    + Increase netlink receive buffer by default. Can be changed at\n      compile-time through ./configure.\n  * Fixes:\n    + Correctly parse LLDP-MED civic address when the length of the\n      TLV exceeds the length of the address.\n    + Fix 100% CPU on some rare error condition.\n    + Fix lost timer when an interface is enslaved on Linux.\n\nlldpd (0.9.5)\n  * Changes:\n    + More Ethernet media supported. However, RFC4836 is quite\n      out-of-date with respected to 10G+ speeds, bringing some\n      inaccuracies.\n    + Directly get media information for an interface without using\n      the privileged process.\n    + LLDP-MED capability TLV is not sent when LLDP-MED is not enabled,\n      even if other LLDP-MED TLV are present.\n  * Fixes:\n    + Compilation fix with older versions of GCC.\n    + Don't use ethtool at all to get real MAC address for enslaved\n      devices (always use /proc).\n\nlldpd (0.9.4)\n  * Changes:\n    + Make lldpd accepts a `-p` option to specify the PID file.\n    + Ability to change multicast MAC address to two additional values\n      to reach customer bridges.\n    + lldpcli will now display chassis TTL when detailed view is enabled.\n  * Fixes:\n    + Fix setting of local value for port ID.\n    + Fix compilation with BSD make.\n    + Ensure lldpcli returns an error code on invalid commands.\n\nlldpd (0.9.3)\n  * Changes:\n    + Do not rely on support of constructors for liblldpctl.\n    + Always log to stderr (even in addition to syslog).\n    + `lldpcli watch` accepts a limit on the number of received events.\n  * Fixes:\n    + `lldpcli -f {xml,json} watch` should work now.\n    + Consider `veth` interfaces as physical interfaces.\n\nlldpd (0.9.2)\n  * Changes:\n    + Ability to add/remove/replace custom TLV from lldpcli.\n    + LLDP-MED capabilities are displayed differently in lldpcli.\n    + Limit the maximum depth (5) when trying to apply a VLAN.\n    + Change JSON output format when using json-c to match Jansson\n      output.\n    + Integration tests for the major parts of lldpd, including use of\n      address and leak sanitizer.\n  * Fixes:\n    + LLDP-MED POE TLV are now displayed in lldpcli.\n    + Ignore lower link when it is in another namespace.\n    + Fix various problems with interfaces being enslaved.\n    + Fix a memory leak when modifying port-related settings.\n\nlldpd (0.9.1)\n  * Changes:\n    + Rework packaging for OS X to make it work with El Capitan. To\n      simplify a bit, it is not possible anymore to build fat\n      binaries. Latest version of OS X supporting 32bit was 10.6.\n  * Fixes:\n    + By default, when using port alias as description, use port name\n      as port ID.\n    + Miscellaneous fixes with netlink cache.\n    + Ensure large netlink messages can be received.\n\nlldpd (0.9.0)\n  * Changes:\n    + Don't rely on libnl3 for netlink. Reuse the previous code and\n      implement a lighweight cache.\n\nlldpd (0.8.0, never released)\n  * Changes:\n    + PIE is now disabled by default. It's too difficult to reliably\n      detect if it works. Use --enable-pie to enable it.\n    + Retrieve the permanent MAC address of an interface through\n      ethtool for Linux if /proc/net/bonding is not available.\n    + Running lldpd with \"-d\" will keep the process in foreground but\n      logs will still go to syslog. To log to the console, add at\n      least one \"-d\".\n    + Fix minimal kernel version to 2.6.39. Add a runtime warning when\n      this is not the case.\n    + Remove old bridge code (the one using ioctl).\n    + Don't discard down interfaces. Notably, this enables us to keep\n      their specific configuration if any.\n    + For Linux, switch to libnl3. Be aware of the licensing issues in\n      case of static linking.\n    + Introduce the notion of default local port. New interfaces will\n      use it as a base. This allows setting various MED stuff.\n    + Provide an apparmor profile (untested).\n  * Fixes:\n    + Fix a buffer overflow when receiving a too large management\n      address TLV. Unless hardening has been disabled, this overflow\n      cannot be used for arbitrary code execution.\n    + Update LLDP-MED policy L2 priority values to match\n      802.1Q-2005. This may be a breaking change.\n\nlldpd (0.7.17)\n  * Fixes:\n    + Fix the way libevent configure is called.\n    + Fix an infinite loop when using veth on Linux 4.1+ kernels.\n    + Make CDP advertise the appropriate kernel name as platform,\n      not just \"Linux\".\n\nlldpd (0.7.16)\n  * Changes:\n    + For Linux, 2.6.32 is now the minimal required kernel. When using\n      an older kernel, use `--enable-oldies`.\n    + For Linux, use netlink to retrieve information about bridges,\n      VLAN and bonds. The code was contributed by Cumulus Networks.\n    + Use symbol versioning for liblldpctl.so.\n    + Ability to get local chassis information with \"show\n      chassis\".\n    + The library also has the same ability with the\n      `lldpctl_get_local_chassis()` function. It is also possible to\n      get a chassis atom from a port with `lldpctl_k_port_chassis`\n      key. This is now the preferred way to retrieve chassis related\n      information.\n  * Fixes:\n    + Fix build on OS X.\n    + Accept \"language\" when configuring MED location as a civic address.\n\nlldpd (0.7.15)\n  * Changes:\n    + Optional features can be configured with \"auto\" to autodetect if\n      they are usable. This is the default value for JSON and XML support.\n    + Ability to send and decode custom/unknown TLV. Thanks to Alexandru\n      Ardelean.\n    + Modify checksum function. While this should be strictly\n      equivalent, if you notice CDP packets not accepted anymore, this\n      change is the first culprit.\n\nlldpd (0.7.14)\n  * Changes:\n    + Shutdown LLPDU are sent on MSAP change and when lldpd exits.\n    + When an exact IP is provided as a management pattern, use it\n      unconditionally.\n    + Ability to set port ID and description to an arbitrary value,\n      thanks to Alexandru Ardelean.\n  * Fixes:\n    + Incorrect boundary check when decoding management address and\n      protocol identity may lead to lldpd crash when processing\n      malformed LLDPDU.\n    + Many edge cases where lldpd was leaving hanging processes after\n      crashing.\n\nlldpd (0.7.13)\n  * Fixes:\n    + Unbreak customization of Unix socket path from command line.\n\nlldpd (0.7.12)\n  * Changes:\n    + Interface pattern, management pattern, system description,\n      system platform and system hostname can be unconfigured to their\n      default values.\n  * Fixes:\n    + Don't complain when parsing a commented line.\n    + Correctly persist configuration changes for \"system interface\n      promiscuous\", \"system interface description\" \"med fast-start\n      enable\", \"pause\" and \"resume\".\n    + Fix listening on bond devices for old kernels (< 2.6.27).\n\nlldpd (0.7.11)\n  * Changes:\n    + Ship bash and zsh completion.\n    + Abort when some command-line options are repeated.\n  * Fixes:\n    + Handle correctly read failures in liblldpctl.\n\nlldpd (0.7.10)\n  * Changes:\n    + Ability to set promiscuous mode to work around bugs of some\n      switches encapsulating LLDP frames inside 802.1Q frames.\n    + JSON support for lldpcli can use json-c instead of jansson,\n      thanks to Michel Stam.\n  * Fixes:\n    + Fix checksum computation for Cisco CDP.\n    + Fix ability to disable LLDP.\n    + Fix seccomp sandbox, thanks to Patrick McLean.\n\nlldpd (0.7.9)\n  * Changes:\n    + Default location for chroot, socket and PID are now configurable\n      in `./configure`. The default location is based on the value of\n      `runstatedir` which in turn may be based on the value of\n      `localstatedir` which defaults to `/usr/local/var`. Therefore,\n      to get the previous locations, lldpd should be configured with\n      `./configure --localstatedir=/var`.\n    + Add support for shutdown LLDPU.\n    + Ability to configure IP management pattern from lldpcli.\n    + Ability to choose what port ID should be (MAC or interface name).\n  * Fixes:\n    + Fix `configure system bond-slave-src-mac-type local`. Also use\n      it as default.\n\nlldpd (0.7.8)\n  * Changes:\n    + Android support\n    + Add the possibility to disable privilege separation (lower\n      memory consumption, lower security, don't do it).\n    + Interfaces can now be whitelisted. For example, *,!eth*,!!eth1\n      is a valid pattern for all interfaces except eth ones, except\n      eth1. Moreover, on exact match, an matching interface\n      circumvents most sanity checks (like VLAN handling).\n    + Ability to override the hostname.\n  * Fixes:\n    + Don't hard-code default values for system name, system\n      description and port description. When the field is not present,\n      just don't display it.\n    + Fix lldpcli behaviour when suid.\n    + On OSX, don't use p2p0 interfaces: it would break WLAN.\n    + Fix SNMP support on RHEL.\n\nlldpd (0.7.7)\n  * Changes:\n    + Use a locally administered MAC address or an arbitrary one\n      instead of null MAC address for bond devices on Linux. This is\n      configurable through `lldpcli`.\n    + Add support for \"team\" driver (alternative to bond devices).\n    + Preliminary support for DTrace/systemtap.\n    + Preliminary support for seccomp (for monitor process).\n    + Setup chroot inside lldpd instead of relying on init script.\n  * Fixes:\n    + Various bugs related to fixed point number handling (for\n      coordinates in LLDP-MED)\n    + Fix a regression in how MAC address of an enslaved device is\n      retrieved.\n\nlldpd (0.7.6)\n  * Changes:\n    + Provide a way to build packages for OSX.\n    + Add an option to update interface description with neighbor name.\n  * Fixes:\n    + Compilation fix for OSX 10.6.\n\nlldpd (0.7.5)\n  * Fixes:\n    + Segfault while tokenizing in lldpcli.\n\nlldpd (0.7.4)\n  * Fixes:\n    + Segfault in lldpcli.\n    + Memory leak in liblldpctl when using a custom log handler.\n    + Fix some unaligned memory accesses.\n    + Fix frame reception on OpenBSD.\n  * Changes:\n    + Allow to configure hold value from lldpcli (and hence the TTL).\n    + Allow to configure pattern for valid interfaces from lldpcli.\n    + Allow to override system description from lldpcli.\n    + Display the neighbor connected as the process title (or the\n      number of connected neighbors).\n\nlldpd (0.7.3)\n  * Changes:\n    + DragonFly BSD support.\n    + Solaris support (incomplete).\n    + LLDP-MED fast start support (thanks to Roopa Prabhu).\n    + Provide global statistics through \"show statistics summary\"\n      command (thanks to Roopa Prabhu).\n  * Fixes:\n    + Fix IPv4/IPv6 address discovery in Linux.\n\nlldpd (0.7.2)\n  * Changes:\n    + lldpd can be configured through /etc/lldpd.conf and\n      /etc/lldpd.d. All commands accepted by lldpcli are accepted.\n    + Lock BPF interfaces before handing them to chrooted process on\n      BSD.\n    + Limit the number of neighbors for each port to 4 (per protocol).\n    + Force CDPv2 protocol with argument `-ccc`.\n    + Provide port statistics through \"show statistics\" command\n      (thanks to Roopa Prabhu).\n  * Fixes:\n    + Driver whitelisting is done before checking if an interface has\n      a lower interface in Linux.\n    + Expire remote ports and chassis in a timely manner.\n\nlldpd (0.7.1)\n  * Changes:\n    + Mac OS X support, sponsored by Xcloud, Mac cloud server hosting\n      provider. http://xcloud.me/\n    + Upstart and systemd support.\n    + Remove Unix socket when there is no process listening.\n\nlldpd (0.7.0)\n  * Changes:\n    + FreeBSD support.\n    + OpenBSD support.\n    + NetBSD support.\n    + Detect interface changes.\n    + CLI for lldpctl: lldpcli.\n    + Allow to disable LLDP protocol (with `-ll`). In this case, the\n      first enabled protocol will be used when no neighbor is detected.\n    + Allow to filter debug logs using tokens. Add more debug logs.\n    + lldpctl can now output JSON.\n    + Use netlink to gather interface information on Linux.\n    + Don't use ioctl for bridges anymore on Linux. The configure\n      option `--enable-oldies` allow to reenable their uses for\n      systems not supporting sysfs.\n\nlldpd (0.6.1)\n  * Changes:\n    + Provide liblldpctl.so, a library to interface with lldpd. The\n      documentation is provided through Doxygen. See src/lib/lldpctl.h\n      which contains all the exported functions.\n    + Make lldpctl uses liblldpctl.so.\n    + Add a \"watch\" option to lldpctl to monitor neighbor changes.\n    + Add the possibility to display the current configuration of\n      lldpd with lldpctl. Also add the possibility to reset the\n      current transmit delay.\n\nlldpd (0.6)\n  * Changes:\n    + Allow lldpctl to display hidden ports.\n    + Add a switch to specify interfaces to use to get chassis ID.\n    + Support for multiple management addresses and IPv6 management\n      addresses. Contributed by Jo\u00e3o Valverde.\n    + Switch to libevent. See README.md for details.\n    + Partial rewrite of the SNMP part. Less code.\n    + Unit tests for SNMP.\n    + Major rewrite of the protocol between lldpd and lldpctl. Less\n      code.\n  * Fixes:\n    + Several small SNMP fixes (discovered by unit tests).\n\nlldpd (0.5.7)\n * Fixes:\n    + Configure issue with NetSNMP and some linkers\n    + Fix infinite loop for the receive part: on certain conditions,\n      lldpd will stop sending packets and stop updating local data.\n\nlldpd (0.5.6)\n  * Changes:\n    + Send and receive native VLAN TLV with CDP\n    + Add a whitelist for some drivers (currently: dsa and veth)\n  * Fixes:\n    + Compilation issues with NetSNMP 5.7 (and with earlier versions too)\n    + Small optimization of BPF filter\n\nlldpd (0.5.5)\n  * Changes:\n    + Support for PPVID and PI Dot1 TLV, thanks to Shuah Khan.\n    + Extend whitelist with possibility to blacklist.\n  * Fixes:\n    + Key/value output was incorrect when a dot was present in\n      interface names. This is fixed but it is preferable to use XML\n      output since the parsing is more difficult in this case.\n    + Only grab DMI information once. Only uses DMI for x86 platform.\n    + Padding issues with socket protocol. This introduces a change in\n      the socket protocol!\n    + Fix a segfault when neither /etc/os-release nor lsb_release\n      are available.\n\nlldpd (0.5.4)\n  * Changes:\n    + Get OS information from /etc/os-release if available. Patch from\n      Michael Tremer.\n    + Add a flag to specify which interfaces lldpd should listen to.\n\nlldpd (0.5.3)\n  * Changes:\n    + Handle Dot3 POE-MDI TLV (802.3af and 802.3at).\n    + Allow to set Dot3 POE-MDI from lldpctl.\n  * Fixes:\n    + Allow root to change configuration of lldpd when lldpctl has suid set.\n\nlldpd (0.5.2)\n  * Changes:\n    + More flexible smart mode and new default. Manual page has been updated.\n    + Add a \"receive-only\" mode with \"-r\" switch.\n\nlldpd (0.5.1)\n  * Changes:\n    + Allow to force a protocol even when no peer for this protocol is\n      detected.\n    + Add a smart mode that allows to discard bogus port information,\n      for example CDP packets that are flooded through a switch that\n      does not support CDP.\n    + Allow to set LLDP-MED network policy from lldpctl, thanks to a patch from\n      Philipp Kempgen.\n    + Allow to set LLDP-MED POE-MDI from lldpctl.\n    + Add a summary of available options in \"lldpd -h\" and \"lldpctl -h\",\n      thanks to a patch from Jorge Boncompte.\n    + Add a new output (keyvalue) for lldpctl.\n    + Listen on VLAN using an appropriate BPF filter, VLAN\n      decapsulation. Older \"listen on vlan\" feature is discarded. See\n      README for more information on the new feature.\n    + Use output of lsb_release if available for system description.\n  * Fixes:\n    + Ignore interface with no queue. It should filter out interfaces\n      like \"vnet0\" that would fail if we try to send something on them.\n    + Don't check CDP checksums (not really a fix but it appears that\n      Cisco checksum have some difficult corner cases).\n\nlldpd (0.5.0)\n  * Changes:\n    + lldpd can now handle several systems on the same port. This\n      modification also allows to speak to a switch using CDP and LLDP\n      for example.\n    + The way that lldpd gathers information for each port has been\n      abstracted. This should allow to support more systems (BSD for\n      examples) or switch cores in the future. Sending/receive support\n      is also abstracted.\n    + Add \"-k\" switch to avoid to emit too much information on running\n      kernel.\n    + Support of ifAlias with kernel >= 2.6.28\n    + Lot of portability stuff. lldpd can now be compiled on RHEL\n      2.1. Still Linux-only though.\n    + Add an option to specify AgentX socket (-X).\n    + Add some unit tests\n    + lldpctl has been reworked; it is now able to output data in XML\n      format for easier parsing. Patches were provided by Andreas\n      Hofmeister.\n  * Fixes:\n    + Fix EDP VLAN handling\n    + Silent warnings about bridge stuff.\n    + Copy /etc/localtime into chroot before starting lldpd daemon to\n      ensure correct timestamps for logs.\n\nlldpd (0.4.1)\n  * Fix EDP handling when there is no VLAN\n  * Fix CDP version to not always be 1\n  * Misc fix:\n     + incorrect number of arguments for a LLOG_INFO call\n     + fix SNMP last change in case this change occurs before start time\n\nlldpd (0.4)\n  * Rewrite of packet builder and parser to be able to cope with\n    architecture that cannot do unaligned read. For decoder, we don't\n    cast structures any more since they can be unaligned. For encoder,\n    we use memcpy through the use of macro that build packets step by\n    step.\n\nlldpd (0.3.2)\n  * Fix LLDP-MED support\n\nlldpd (0.3.1)\n  * Misc fixes, including memory leaks\n\nlldpd (0.3)\n  * Initial support of LLDP-MED\n  * Fix for bridge detection (don't send bridge ioctl on random interfaces)\n  * For bonded devices, get the real hardware address. For inactive\n    slaves, transmit using a random MAC address.\n\nlldpd (0.2.1)\n  * Fix a syntax error in manual page\n  * Fix open() calls\n\nlldpd (0.2)\n  * Add privilege separation\n  * Add FDP support\n  * Support CDP encapsulated into native VLAN\n  * Various fixes\n\nlldpd (0.1)\n  * Initial release\n", "/* -*- mode: c; c-file-style: \"openbsd\" -*- */\n/*\n * Copyright (c) 2008 Vincent Bernat <bernat@luffy.cx>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n/* We also supports FDP which is very similar to CDPv1 */\n#include \"../lldpd.h\"\n#include \"../frame.h\"\n\n/*\n * CDP Requests Power at the switch output and therefore has to take into\n * account the loss in the PoE cable. This is done by the switch automatically\n * if lldp is used as the protocol.\n */\n#define CDP_CLASS_3_MAX_PSE_POE 154\t /* 15.4W Max PoE at PSE class 3 */\n#define CDP_SWTICH_DEFAULT_POE_PD 130\t /* 13.W default PoE at PD */\n#define CDP_SWTICH_DEFAULT_POE_PSE 154\t /* 15.4W default PoE at PSE */\n#define CDP_SWITCH_POE_CLASS_4_OFFSET 45 /* 4.5W  max loss from cable */\n#define CDP_SWITCH_POE_CLASS_3_OFFSET 24 /* 2.4W  max loss from cable */\n\n#if defined ENABLE_CDP || defined ENABLE_FDP\n\n#  include <stdio.h>\n#  include <unistd.h>\n#  include <errno.h>\n#  include <arpa/inet.h>\n\nstatic int\ncdp_send(struct lldpd *global, struct lldpd_hardware *hardware, int version)\n{\n\tconst char *platform = \"Unknown\";\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_mgmt *mgmt;\n\tstruct lldpd_port *port;\n\tu_int8_t mcastaddr[] = CDP_MULTICAST_ADDR;\n\tu_int8_t llcorg[] = LLC_ORG_CISCO;\n#  ifdef ENABLE_FDP\n\tchar *capstr;\n#  endif\n\tu_int16_t checksum;\n\tint length, i;\n\tu_int32_t cap;\n\tu_int8_t *packet;\n\tu_int8_t *pos, *pos_len_eh, *pos_llc, *pos_cdp, *pos_checksum, *tlv, *end;\n\n\tlog_debug(\"cdp\", \"send CDP frame on %s\", hardware->h_ifname);\n\n\tport = &(hardware->h_lport);\n\tchassis = port->p_chassis;\n\n#  ifdef ENABLE_FDP\n\tif (version == 0) {\n\t\t/* With FDP, change multicast address and LLC PID */\n\t\tconst u_int8_t fdpmcastaddr[] = FDP_MULTICAST_ADDR;\n\t\tconst u_int8_t fdpllcorg[] = LLC_ORG_FOUNDRY;\n\t\tmemcpy(mcastaddr, fdpmcastaddr, sizeof(mcastaddr));\n\t\tmemcpy(llcorg, fdpllcorg, sizeof(llcorg));\n\t}\n#  endif\n\n\tlength = hardware->h_mtu;\n\tif ((packet = (u_int8_t *)calloc(1, length)) == NULL) return ENOMEM;\n\tpos = packet;\n\n\t/* Ethernet header */\n\tif (!(POKE_BYTES(mcastaddr, sizeof(mcastaddr)) &&\n\t\tPOKE_BYTES(&hardware->h_lladdr, ETHER_ADDR_LEN) &&\n\t\tPOKE_SAVE(pos_len_eh) && /* We compute the len later */\n\t\tPOKE_UINT16(0)))\n\t\tgoto toobig;\n\n\t/* LLC */\n\tif (!(POKE_SAVE(pos_llc) && POKE_UINT8(0xaa) && /* SSAP */\n\t\tPOKE_UINT8(0xaa) &&\t\t\t/* DSAP */\n\t\tPOKE_UINT8(0x03) &&\t\t\t/* Control field */\n\t\tPOKE_BYTES(llcorg, sizeof(llcorg)) && POKE_UINT16(LLC_PID_CDP)))\n\t\tgoto toobig;\n\n\t/* CDP header */\n\tif (!(POKE_SAVE(pos_cdp) && POKE_UINT8((version == 0) ? 1 : version) &&\n\t\tPOKE_UINT8(global ? global->g_config.c_ttl : 180) &&\n\t\tPOKE_SAVE(pos_checksum) && /* Save checksum position */\n\t\tPOKE_UINT16(0)))\n\t\tgoto toobig;\n\n\t/* Chassis ID */\n\tconst char *chassis_name = chassis->c_name ? chassis->c_name : \"\";\n\tif (!(POKE_START_CDP_TLV(CDP_TLV_CHASSIS) &&\n\t\tPOKE_BYTES(chassis_name, strlen(chassis_name)) && POKE_END_CDP_TLV))\n\t\tgoto toobig;\n\n\t/* Adresses */\n\t/* See:\n\t *   http://www.cisco.com/univercd/cc/td/doc/product/lan/trsrb/frames.htm#xtocid12\n\t *\n\t * It seems that Cisco implies that CDP supports IPv6 using\n\t * 802.2 address format with 0xAAAA03 0x000000 0x0800, but\n\t * 0x0800 is the Ethernet protocol type for IPv4. Therefore,\n\t * we support only IPv4. */\n\ti = 0;\n\tTAILQ_FOREACH (mgmt, &chassis->c_mgmt, m_entries)\n\t\tif (mgmt->m_family == LLDPD_AF_IPV4) i++;\n\tif (i > 0) {\n\t\tif (!(POKE_START_CDP_TLV(CDP_TLV_ADDRESSES) && POKE_UINT32(i)))\n\t\t\tgoto toobig;\n\t\tTAILQ_FOREACH (mgmt, &chassis->c_mgmt, m_entries) {\n\t\t\tswitch (mgmt->m_family) {\n\t\t\tcase LLDPD_AF_IPV4:\n\t\t\t\tif (!(POKE_UINT8(1) &&\t /* Type: NLPID */\n\t\t\t\t\tPOKE_UINT8(1) && /* Length: 1 */\n\t\t\t\t\tPOKE_UINT8(CDP_ADDRESS_PROTO_IP) && /* IP */\n\t\t\t\t\tPOKE_UINT16(sizeof(\n\t\t\t\t\t    struct in_addr)) && /* Address length */\n\t\t\t\t\tPOKE_BYTES(&mgmt->m_addr,\n\t\t\t\t\t    sizeof(struct in_addr))))\n\t\t\t\t\tgoto toobig;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!(POKE_END_CDP_TLV)) goto toobig;\n\t}\n\n\t/* Port ID */\n\tconst char *port_descr =\n\t    hardware->h_lport.p_descr ? hardware->h_lport.p_descr : \"\";\n\tif (!(POKE_START_CDP_TLV(CDP_TLV_PORT) &&\n\t\tPOKE_BYTES(port_descr, strlen(port_descr)) && POKE_END_CDP_TLV))\n\t\tgoto toobig;\n\n\t/* Capabilities */\n\tif (version != 0) {\n\t\tcap = 0;\n\t\tif (chassis->c_cap_enabled & LLDP_CAP_ROUTER) cap |= CDP_CAP_ROUTER;\n\t\tif (chassis->c_cap_enabled & LLDP_CAP_BRIDGE) cap |= CDP_CAP_SWITCH;\n\t\tcap |= CDP_CAP_HOST;\n\t\tif (!(POKE_START_CDP_TLV(CDP_TLV_CAPABILITIES) && POKE_UINT32(cap) &&\n\t\t\tPOKE_END_CDP_TLV))\n\t\t\tgoto toobig;\n#  ifdef ENABLE_FDP\n\t} else {\n\t\t/* With FDP, it seems that a string is used in place of an int */\n\t\tif (chassis->c_cap_enabled & LLDP_CAP_ROUTER)\n\t\t\tcapstr = \"Router\";\n\t\telse if (chassis->c_cap_enabled & LLDP_CAP_BRIDGE)\n\t\t\tcapstr = \"Switch\";\n\t\telse if (chassis->c_cap_enabled & LLDP_CAP_REPEATER)\n\t\t\tcapstr = \"Bridge\";\n\t\telse\n\t\t\tcapstr = \"Host\";\n\t\tif (!(POKE_START_CDP_TLV(CDP_TLV_CAPABILITIES) &&\n\t\t\tPOKE_BYTES(capstr, strlen(capstr)) && POKE_END_CDP_TLV))\n\t\t\tgoto toobig;\n#  endif\n\t}\n\n\t/* Native VLAN */\n#  ifdef ENABLE_DOT1\n\tif (version >= 2 && hardware->h_lport.p_pvid != 0) {\n\t\tif (!(POKE_START_CDP_TLV(CDP_TLV_NATIVEVLAN) &&\n\t\t\tPOKE_UINT16(hardware->h_lport.p_pvid) && POKE_END_CDP_TLV))\n\t\t\tgoto toobig;\n\t}\n#  endif\n\n\t/* Software version */\n\tconst char *chassis_descr = chassis->c_descr ? chassis->c_descr : \"\";\n\tif (!(POKE_START_CDP_TLV(CDP_TLV_SOFTWARE) &&\n\t\tPOKE_BYTES(chassis_descr, strlen(chassis_descr)) && POKE_END_CDP_TLV))\n\t\tgoto toobig;\n\n\t/* Platform */\n\tif (global && global->g_config.c_platform)\n\t\tplatform = global->g_config.c_platform;\n\n\tif (!(POKE_START_CDP_TLV(CDP_TLV_PLATFORM) &&\n\t\tPOKE_BYTES(platform, strlen(platform)) && POKE_END_CDP_TLV))\n\t\tgoto toobig;\n\n#  ifdef ENABLE_DOT3\n\tif ((version >= 2) && (port->p_power.powertype != LLDP_DOT3_POWER_8023AT_OFF) &&\n\t    (port->p_power.devicetype == LLDP_DOT3_POWER_PD) &&\n\t    (port->p_power.requested > 0) && (port->p_power.requested <= 655)) {\n\t\tu_int16_t requested;\n\t\tu_int16_t consumption;\n\n\t\tif (port->p_power.requested != port->p_power.allocated) {\n\t\t\tport->p_cdp_power.request_id++;\n\t\t\tlog_debug(\"cdp\", \"requested: %d, allocated:%d\",\n\t\t\t    port->p_power.requested, port->p_power.allocated);\n\t\t}\n\t\tconsumption = port->p_power.allocated ? port->p_power.allocated :\n\t\t\t\t\t\t\tCDP_SWTICH_DEFAULT_POE_PD;\n\t\tif (consumption > 130) {\n\t\t\tconsumption += CDP_SWITCH_POE_CLASS_4_OFFSET;\n\t\t} else {\n\t\t\tconsumption += CDP_SWITCH_POE_CLASS_3_OFFSET;\n\t\t}\n\t\tif (port->p_power.requested > 130) { /* Class 4 */\n\t\t\trequested =\n\t\t\t    port->p_power.requested + CDP_SWITCH_POE_CLASS_4_OFFSET;\n\t\t} else { /* Class 3 */\n\t\t\trequested =\n\t\t\t    port->p_power.requested + CDP_SWITCH_POE_CLASS_3_OFFSET;\n\t\t}\n\t\tif (!(POKE_START_CDP_TLV(CDP_TLV_POWER_CONSUMPTION) &&\n\t\t\tPOKE_UINT16(consumption * 100) && POKE_END_CDP_TLV))\n\t\t\tgoto toobig;\n\t\t/* Avoid request id 0 from overflow */\n\t\tif (!port->p_cdp_power.request_id) {\n\t\t\tport->p_cdp_power.request_id = 1;\n\t\t}\n\t\tif (!port->p_cdp_power.management_id) {\n\t\t\tport->p_cdp_power.management_id = 1;\n\t\t}\n\t\tif (!(POKE_START_CDP_TLV(CDP_TLV_POWER_REQUESTED) &&\n\t\t\tPOKE_UINT16(port->p_cdp_power.request_id) &&\n\t\t\tPOKE_UINT16(port->p_cdp_power.management_id) &&\n\t\t\tPOKE_UINT32(requested * 100) && POKE_END_CDP_TLV))\n\t\t\tgoto toobig;\n\t}\n#  elif defined ENABLE_LLDPMED\n\t/* Power use */\n\tif ((version >= 2) && port->p_med_cap_enabled &&\n\t    (port->p_med_power.source != LLDP_MED_POW_SOURCE_LOCAL) &&\n\t    (port->p_med_power.val > 0) && (port->p_med_power.val <= 655)) {\n\t\tif (!(POKE_START_CDP_TLV(CDP_TLV_POWER_CONSUMPTION) &&\n\t\t\tPOKE_UINT16(port->p_med_power.val * 100) && POKE_END_CDP_TLV))\n\t\t\tgoto toobig;\n\t}\n#  endif\n\n\t(void)POKE_SAVE(end);\n\n\t/* Compute len and checksum */\n\tPOKE_RESTORE(pos_len_eh);\n\tif (!(POKE_UINT16(end - pos_llc))) goto toobig;\n\tchecksum = frame_checksum(pos_cdp, end - pos_cdp, (version != 0) ? 1 : 0);\n\tPOKE_RESTORE(pos_checksum);\n\tif (!(POKE_UINT16(checksum))) goto toobig;\n\n\tif (interfaces_send_helper(global, hardware, (char *)packet, end - packet) ==\n\t    -1) {\n\t\tlog_warn(\"cdp\", \"unable to send packet on real device for %s\",\n\t\t    hardware->h_ifname);\n\t\tfree(packet);\n\t\treturn ENETDOWN;\n\t}\n\n\thardware->h_tx_cnt++;\n\n\tfree(packet);\n\treturn 0;\ntoobig:\n\tfree(packet);\n\treturn -1;\n}\n\n#  define CHECK_TLV_SIZE(x, name)                                      \\\n    do {                                                               \\\n      if (tlv_len < (x)) {                                             \\\n\tlog_warnx(\"cdp\", name \" CDP/FDP TLV too short received on %s\", \\\n\t    hardware->h_ifname);                                       \\\n\tgoto malformed;                                                \\\n      }                                                                \\\n    } while (0)\n/* cdp_decode also decodes FDP */\nint\ncdp_decode(struct lldpd *cfg, char *frame, int s, struct lldpd_hardware *hardware,\n    struct lldpd_chassis **newchassis, struct lldpd_port **newport)\n{\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_port *port;\n\tstruct lldpd_mgmt *mgmt;\n\tstruct in_addr addr;\n#  if 0\n\tu_int16_t cksum;\n#  endif\n\tu_int8_t *software = NULL, *platform = NULL;\n\tint software_len = 0, platform_len = 0, proto, version, nb, caps;\n\tconst unsigned char cdpaddr[] = CDP_MULTICAST_ADDR;\n#  ifdef ENABLE_FDP\n\tconst unsigned char fdpaddr[] = CDP_MULTICAST_ADDR;\n\tint fdp = 0;\n#  endif\n\tu_int8_t *pos, *tlv, *pos_address, *pos_next_address;\n\tint length, len_eth, tlv_type, tlv_len, addresses_len, address_len;\n#  ifdef ENABLE_DOT1\n\tstruct lldpd_vlan *vlan;\n#  endif\n\n\tlog_debug(\"cdp\", \"decode CDP frame received on %s\", hardware->h_ifname);\n\n\tif ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {\n\t\tlog_warn(\"cdp\", \"failed to allocate remote chassis\");\n\t\treturn -1;\n\t}\n\tTAILQ_INIT(&chassis->c_mgmt);\n\tif ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) {\n\t\tlog_warn(\"cdp\", \"failed to allocate remote port\");\n\t\tfree(chassis);\n\t\treturn -1;\n\t}\n#  ifdef ENABLE_DOT1\n\tTAILQ_INIT(&port->p_vlans);\n#  endif\n\n\tlength = s;\n\tpos = (u_int8_t *)frame;\n\n\tif (length < 2 * ETHER_ADDR_LEN + sizeof(u_int16_t) /* Ethernet */ +\n\t\t8 /* LLC */ + 4 /* CDP header */) {\n\t\tlog_warn(\"cdp\", \"too short CDP/FDP frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\tif (PEEK_CMP(cdpaddr, sizeof(cdpaddr)) != 0) {\n#  ifdef ENABLE_FDP\n\t\tPEEK_RESTORE((u_int8_t *)frame);\n\t\tif (PEEK_CMP(fdpaddr, sizeof(fdpaddr)) != 0)\n\t\t\tfdp = 1;\n\t\telse {\n#  endif\n\t\t\tlog_info(\"cdp\",\n\t\t\t    \"frame not targeted at CDP/FDP multicast address received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n#  ifdef ENABLE_FDP\n\t\t}\n#  endif\n\t}\n\tPEEK_DISCARD(ETHER_ADDR_LEN); /* Don't care of source address */\n\tlen_eth = PEEK_UINT16;\n\tif (len_eth > length) {\n\t\tlog_warnx(\"cdp\", \"incorrect 802.3 frame size reported on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\t/* This is the correct length of the CDP + LLC packets */\n\tlength = len_eth;\n\n\tPEEK_DISCARD(6); /* Skip beginning of LLC */\n\tproto = PEEK_UINT16;\n\tif (proto != LLC_PID_CDP) {\n\t\tif ((proto != LLC_PID_DRIP) && (proto != LLC_PID_PAGP) &&\n\t\t    (proto != LLC_PID_PVSTP) && (proto != LLC_PID_UDLD) &&\n\t\t    (proto != LLC_PID_VTP) && (proto != LLC_PID_DTP) &&\n\t\t    (proto != LLC_PID_STP))\n\t\t\tlog_debug(\"cdp\", \"incorrect LLC protocol ID received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n#  if 0\n\t/* Check checksum */\n\tcksum = frame_checksum(pos, len_eth - 8,\n#    ifdef ENABLE_FDP\n\t    !fdp\t\t/* fdp = 0 -> cisco checksum */\n#    else\n\t    1\t\t\t/* cisco checksum */\n#    endif\n\t\t);\n\tif (cksum != 0) {\n\t\tlog_info(\"cdp\", \"incorrect CDP/FDP checksum for frame received on %s (%d)\",\n\t\t\t  hardware->h_ifname, cksum);\n\t\tgoto malformed;\n\t}\n#  endif\n\n\t/* Check version */\n\tversion = PEEK_UINT8;\n\tif ((version != 1) && (version != 2)) {\n\t\tlog_warnx(\"cdp\",\n\t\t    \"incorrect CDP/FDP version (%d) for frame received on %s\", version,\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tport->p_ttl = PEEK_UINT8; /* TTL */\n\tPEEK_DISCARD_UINT16;\t  /* Checksum, already checked */\n\n\twhile (length) {\n\t\tif (length < 4) {\n\t\t\tlog_warnx(\"cdp\",\n\t\t\t    \"CDP/FDP TLV header is too large for \"\n\t\t\t    \"frame received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\ttlv_type = PEEK_UINT16;\n\t\ttlv_len = PEEK_UINT16 - 4;\n\n\t\t(void)PEEK_SAVE(tlv);\n\t\tif ((tlv_len < 0) || (length < tlv_len)) {\n\t\t\tlog_warnx(\"cdp\",\n\t\t\t    \"incorrect size in CDP/FDP TLV header for frame \"\n\t\t\t    \"received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\tswitch (tlv_type) {\n\t\tcase CDP_TLV_CHASSIS:\n\t\t\tfree(chassis->c_name);\n\t\t\tif ((chassis->c_name = (char *)calloc(1, tlv_len + 1)) ==\n\t\t\t    NULL) {\n\t\t\t\tlog_warn(\"cdp\",\n\t\t\t\t    \"unable to allocate memory for chassis name\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_BYTES(chassis->c_name, tlv_len);\n\t\t\tchassis->c_id_subtype = LLDP_CHASSISID_SUBTYPE_LOCAL;\n\t\t\tfree(chassis->c_id);\n\t\t\tif ((chassis->c_id = (char *)malloc(tlv_len)) == NULL) {\n\t\t\t\tlog_warn(\"cdp\",\n\t\t\t\t    \"unable to allocate memory for chassis ID\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tmemcpy(chassis->c_id, chassis->c_name, tlv_len);\n\t\t\tchassis->c_id_len = tlv_len;\n\t\t\tbreak;\n\t\tcase CDP_TLV_ADDRESSES:\n\t\t\tCHECK_TLV_SIZE(4, \"Address\");\n\t\t\taddresses_len = tlv_len - 4;\n\t\t\tfor (nb = PEEK_UINT32; nb > 0; nb--) {\n\t\t\t\t(void)PEEK_SAVE(pos_address);\n\t\t\t\t/* We first try to get the real length of the packet */\n\t\t\t\tif (addresses_len < 2) {\n\t\t\t\t\tlog_warn(\"cdp\",\n\t\t\t\t\t    \"too short address subframe \"\n\t\t\t\t\t    \"received on %s\",\n\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tPEEK_DISCARD_UINT8;\n\t\t\t\taddresses_len--;\n\t\t\t\taddress_len = PEEK_UINT8;\n\t\t\t\taddresses_len--;\n\t\t\t\tif (addresses_len < address_len + 2) {\n\t\t\t\t\tlog_warn(\"cdp\",\n\t\t\t\t\t    \"too short address subframe \"\n\t\t\t\t\t    \"received on %s\",\n\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tPEEK_DISCARD(address_len);\n\t\t\t\taddresses_len -= address_len;\n\t\t\t\taddress_len = PEEK_UINT16;\n\t\t\t\taddresses_len -= 2;\n\t\t\t\tif (addresses_len < address_len) {\n\t\t\t\t\tlog_warn(\"cdp\",\n\t\t\t\t\t    \"too short address subframe \"\n\t\t\t\t\t    \"received on %s\",\n\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tPEEK_DISCARD(address_len);\n\t\t\t\t(void)PEEK_SAVE(pos_next_address);\n\t\t\t\t/* Next, we go back and try to extract\n\t\t\t\t   IPv4 address */\n\t\t\t\tPEEK_RESTORE(pos_address);\n\t\t\t\tif ((PEEK_UINT8 == 1) && (PEEK_UINT8 == 1) &&\n\t\t\t\t    (PEEK_UINT8 == CDP_ADDRESS_PROTO_IP) &&\n\t\t\t\t    (PEEK_UINT16 == sizeof(struct in_addr))) {\n\t\t\t\t\tPEEK_BYTES(&addr, sizeof(struct in_addr));\n\t\t\t\t\tmgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4, &addr,\n\t\t\t\t\t    sizeof(struct in_addr), 0);\n\t\t\t\t\tif (mgmt == NULL) {\n\t\t\t\t\t\tif (errno == ENOMEM)\n\t\t\t\t\t\t\tlog_warn(\"cdp\",\n\t\t\t\t\t\t\t    \"unable to allocate memory for management address\");\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tlog_warn(\"cdp\",\n\t\t\t\t\t\t\t    \"too large management address received on %s\",\n\t\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt,\n\t\t\t\t\t    m_entries);\n\t\t\t\t}\n\t\t\t\t/* Go to the end of the address */\n\t\t\t\tPEEK_RESTORE(pos_next_address);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CDP_TLV_PORT:\n\t\t\tif (tlv_len == 0) {\n\t\t\t\tlog_warn(\"cdp\", \"too short port description received\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tfree(port->p_descr);\n\t\t\tif ((port->p_descr = (char *)calloc(1, tlv_len + 1)) == NULL) {\n\t\t\t\tlog_warn(\"cdp\",\n\t\t\t\t    \"unable to allocate memory for port description\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_BYTES(port->p_descr, tlv_len);\n\t\t\tport->p_id_subtype = LLDP_PORTID_SUBTYPE_IFNAME;\n\t\t\tfree(port->p_id);\n\t\t\tif ((port->p_id = (char *)calloc(1, tlv_len)) == NULL) {\n\t\t\t\tlog_warn(\"cdp\",\n\t\t\t\t    \"unable to allocate memory for port ID\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tmemcpy(port->p_id, port->p_descr, tlv_len);\n\t\t\tport->p_id_len = tlv_len;\n\t\t\tbreak;\n\t\tcase CDP_TLV_CAPABILITIES:\n#  ifdef ENABLE_FDP\n\t\t\tif (fdp) {\n\t\t\t\t/* Capabilities are string with FDP */\n\t\t\t\tif (!strncmp(\"Router\", (char *)pos, tlv_len))\n\t\t\t\t\tchassis->c_cap_enabled = LLDP_CAP_ROUTER;\n\t\t\t\telse if (!strncmp(\"Switch\", (char *)pos, tlv_len))\n\t\t\t\t\tchassis->c_cap_enabled = LLDP_CAP_BRIDGE;\n\t\t\t\telse if (!strncmp(\"Bridge\", (char *)pos, tlv_len))\n\t\t\t\t\tchassis->c_cap_enabled = LLDP_CAP_REPEATER;\n\t\t\t\telse\n\t\t\t\t\tchassis->c_cap_enabled = LLDP_CAP_STATION;\n\t\t\t\tchassis->c_cap_available = chassis->c_cap_enabled;\n\t\t\t\tbreak;\n\t\t\t}\n#  endif\n\t\t\tCHECK_TLV_SIZE(4, \"Capabilities\");\n\t\t\tcaps = PEEK_UINT32;\n\t\t\tif (caps & CDP_CAP_ROUTER)\n\t\t\t\tchassis->c_cap_enabled |= LLDP_CAP_ROUTER;\n\t\t\tif (caps & 0x0e) chassis->c_cap_enabled |= LLDP_CAP_BRIDGE;\n\t\t\tif (chassis->c_cap_enabled == 0)\n\t\t\t\tchassis->c_cap_enabled = LLDP_CAP_STATION;\n\t\t\tchassis->c_cap_available = chassis->c_cap_enabled;\n\t\t\tbreak;\n\t\tcase CDP_TLV_SOFTWARE:\n\t\t\tsoftware_len = tlv_len;\n\t\t\t(void)PEEK_SAVE(software);\n\t\t\tbreak;\n\t\tcase CDP_TLV_PLATFORM:\n\t\t\tplatform_len = tlv_len;\n\t\t\t(void)PEEK_SAVE(platform);\n\t\t\tbreak;\n#  ifdef ENABLE_DOT1\n\t\tcase CDP_TLV_NATIVEVLAN:\n\t\t\tCHECK_TLV_SIZE(2, \"Native VLAN\");\n\t\t\tif ((vlan = (struct lldpd_vlan *)calloc(1,\n\t\t\t\t sizeof(struct lldpd_vlan))) == NULL) {\n\t\t\t\tlog_warn(\"cdp\",\n\t\t\t\t    \"unable to alloc vlan \"\n\t\t\t\t    \"structure for \"\n\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tvlan->v_vid = port->p_pvid = PEEK_UINT16;\n\t\t\tif (asprintf(&vlan->v_name, \"VLAN #%d\", vlan->v_vid) == -1) {\n\t\t\t\tlog_warn(\"cdp\",\n\t\t\t\t    \"unable to alloc VLAN name for \"\n\t\t\t\t    \"TLV received on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tfree(vlan);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tTAILQ_INSERT_TAIL(&port->p_vlans, vlan, v_entries);\n\t\t\tbreak;\n#  endif\n#  ifdef ENABLE_DOT3\n\t\tcase CDP_TLV_POWER_AVAILABLE:\n\t\t\tCHECK_TLV_SIZE(12, \"Power Available\");\n\t\t\t/* check if it is a respone to a request id */\n\t\t\tif (PEEK_UINT16 > 0) {\n\t\t\t\tport->p_cdp_power.management_id = PEEK_UINT16;\n\t\t\t\tport->p_power.allocated = PEEK_UINT32;\n\t\t\t\tport->p_power.allocated /= 100;\n\t\t\t\tport->p_power.supported = 1;\n\t\t\t\tport->p_power.enabled = 1;\n\t\t\t\tport->p_power.devicetype = LLDP_DOT3_POWER_PSE;\n\t\t\t\tport->p_power.powertype = LLDP_DOT3_POWER_8023AT_TYPE2;\n\t\t\t\tlog_debug(\"cdp\", \"Allocated power %d00\",\n\t\t\t\t    port->p_power.allocated);\n\t\t\t\tif (port->p_power.allocated > CDP_CLASS_3_MAX_PSE_POE) {\n\t\t\t\t\tport->p_power.allocated -=\n\t\t\t\t\t    CDP_SWITCH_POE_CLASS_4_OFFSET;\n\t\t\t\t} else if (port->p_power.allocated >\n\t\t\t\t    CDP_SWITCH_POE_CLASS_3_OFFSET) {\n\t\t\t\t\tport->p_power.allocated -=\n\t\t\t\t\t    CDP_SWITCH_POE_CLASS_3_OFFSET;\n\t\t\t\t} else {\n\t\t\t\t\tport->p_power.allocated = 0;\n\t\t\t\t}\n\t\t\t\tport->p_power.requested =\n\t\t\t\t    hardware->h_lport.p_power.requested;\n\t\t\t}\n\t\t\tbreak;\n#  endif\n\t\tdefault:\n\t\t\tlog_debug(\"cdp\", \"unknown CDP/FDP TLV type (%d) received on %s\",\n\t\t\t    ntohs(tlv_type), hardware->h_ifname);\n\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t}\n\t\tPEEK_DISCARD(tlv + tlv_len - pos);\n\t}\n\tif (!software && platform) {\n\t\tif ((chassis->c_descr = (char *)calloc(1, platform_len + 1)) == NULL) {\n\t\t\tlog_warn(\"cdp\",\n\t\t\t    \"unable to allocate memory for chassis description\");\n\t\t\tgoto malformed;\n\t\t}\n\t\tmemcpy(chassis->c_descr, platform, platform_len);\n\t} else if (software && !platform) {\n\t\tif ((chassis->c_descr = (char *)calloc(1, software_len + 1)) == NULL) {\n\t\t\tlog_warn(\"cdp\",\n\t\t\t    \"unable to allocate memory for chassis description\");\n\t\t\tgoto malformed;\n\t\t}\n\t\tmemcpy(chassis->c_descr, software, software_len);\n\t} else if (software && platform) {\n#  define CONCAT_PLATFORM \" running on\\n\"\n\t\tif ((chassis->c_descr = (char *)calloc(1,\n\t\t\t software_len + platform_len + strlen(CONCAT_PLATFORM) + 1)) ==\n\t\t    NULL) {\n\t\t\tlog_warn(\"cdp\",\n\t\t\t    \"unable to allocate memory for chassis description\");\n\t\t\tgoto malformed;\n\t\t}\n\t\tmemcpy(chassis->c_descr, platform, platform_len);\n\t\tmemcpy(chassis->c_descr + platform_len, CONCAT_PLATFORM,\n\t\t    strlen(CONCAT_PLATFORM));\n\t\tmemcpy(chassis->c_descr + platform_len + strlen(CONCAT_PLATFORM),\n\t\t    software, software_len);\n\t}\n\tif ((chassis->c_id == NULL) || (port->p_id == NULL) ||\n\t    (chassis->c_name == NULL) || (chassis->c_descr == NULL) ||\n\t    (port->p_descr == NULL) || (port->p_ttl == 0) ||\n\t    (chassis->c_cap_enabled == 0)) {\n\t\tlog_warnx(\"cdp\",\n\t\t    \"some mandatory CDP/FDP tlv are missing for frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\t*newchassis = chassis;\n\t*newport = port;\n\treturn 1;\n\nmalformed:\n\tlldpd_chassis_cleanup(chassis, 1);\n\tlldpd_port_cleanup(port, 1);\n\tfree(port);\n\treturn -1;\n}\n\n#  ifdef ENABLE_CDP\nint\ncdpv1_send(struct lldpd *global, struct lldpd_hardware *hardware)\n{\n\treturn cdp_send(global, hardware, 1);\n}\n\nint\ncdpv2_send(struct lldpd *global, struct lldpd_hardware *hardware)\n{\n\treturn cdp_send(global, hardware, 2);\n}\n#  endif\n\n#  ifdef ENABLE_FDP\nint\nfdp_send(struct lldpd *global, struct lldpd_hardware *hardware)\n{\n\treturn cdp_send(global, hardware, 0);\n}\n#  endif\n\n#  ifdef ENABLE_CDP\nstatic int\ncdp_guess(char *pos, int length, int version)\n{\n\tconst u_int8_t mcastaddr[] = CDP_MULTICAST_ADDR;\n\tif (length < 2 * ETHER_ADDR_LEN + sizeof(u_int16_t) /* Ethernet */ +\n\t\t8 /* LLC */ + 4 /* CDP header */)\n\t\treturn 0;\n\tif (PEEK_CMP(mcastaddr, ETHER_ADDR_LEN) != 0) return 0;\n\tPEEK_DISCARD(ETHER_ADDR_LEN);\n\tPEEK_DISCARD_UINT16; /* Ethernet */\n\tPEEK_DISCARD(8);     /* LLC */\n\treturn (PEEK_UINT8 == version);\n}\n\nint\ncdpv1_guess(char *frame, int len)\n{\n\treturn cdp_guess(frame, len, 1);\n}\n\nint\ncdpv2_guess(char *frame, int len)\n{\n\treturn cdp_guess(frame, len, 2);\n}\n#  endif\n\n#endif /* defined (ENABLE_CDP) || defined (ENABLE_FDP) */\n"], "fixing_code": ["lldpd (1.0.17)\n * Fix:\n   + Read overflow when parsing CDP addresses. Thanks to Matteo Memelli.\n\nlldpd (1.0.16)\n * Fix:\n   + Do not use 00:00:00:00:00:00 as chassis ID.\n   + Do not busy loop when an interface with a neighbor disappears.\n\nlldpd (1.0.15)\n * Changes\n   + Add configure command to override system capabilities. Contributed by\n     Ignacio Sanchez Navarro. (#526)\n   + An unrecognized ORG TLV is now considered as a custom one. (#536)\n * Fix:\n   + Really don't send VLANs when there are too many (#520)\n   + Ignore temporary IPv6 addresses (#521)\n\nlldpd (1.0.14)\n * Changes\n   + Add configure commands to alter inventory TLVs (#508)\n * Fix:\n   + Update seccomp rules for newer kernel/libc (#488)\n   + Correctly handle an interface whose index has changed (#490)\n   + Don't send VLANs when there are too many (#501)\n\nlldpd (1.0.13)\n * Fix:\n   + Add support for 2.5G, 5G, 25G and 50G based Ethernet (#475)\n   + Fix link-down detection on OpenBSD (#476)\n   + Fix LLDP packets encapsuled in VLAN 0 in some conditions\n   + Fix heap overflow when reading SONMP. CVE-2021-43612.\n     Thanks to Jeremy Galindo for discovering this one.\n\nlldpd (1.0.12)\n  * Fix:\n    + Use a dedicated file lock to prevent concurrent changes from lldpcli.\n    + Require/display powerpairs for Dot3 power even when device type is PD.\n  * Changes:\n    + Provide a Docker image and make it available on GitHub.\n\nlldpd (1.0.11)\n  * Changes:\n    + Disable LLDP in firmware for Intel X7xx cards.\n  * Fix:\n    + Ensure Intel E8xx cards can transmit LLDP packets.\n\nlldpd (1.0.10)\n  * Fix:\n    + Fix chroot directory creation.\n\nlldpd (1.0.9)\n  * Fix:\n    + Do not use interface alias if we set it ourselves.\n    + More memory leak fixes on duplicate TLVs in LLDP, CDP and EDP\n      (related to CVE-2020-27827).\n    + On OSX, handle empty groups correctly when looking for a free UID/GID.\n  * Changes:\n    + Display port status with \"show interfaces\".\n    + Do not display \"age\" and \"via\" when using \"show interfaces\".\n\nlldpd (1.0.8)\n  * Fix:\n    + Out-of-bound read access when parsing LLDP-MED civic address in\n      liblldpctl for malformed fields.\n    + Fix memory leak when receiving LLDPU with duplicate fields.\n      CVE-2020-27827.\n  * Changes:\n    + Enable \"router\" capability bit when IPv6 routing is enabled.\n\nlldpd (1.0.7)\n  * Fix:\n    + Do not listen only to LLDP packets on Linux. When an interface\n      is enslaved to an Open vSwitch, incoming packets are missed.\n\nlldpd (1.0.6)\n  * Fix:\n    + Do not loose chassis local information when interface status changes.\n    + Fix SNMP walk on lldpRemTable when missing remote system\n      name or description.\n    + Remove length limitation on system description and platform.\n  * Changes:\n    + Deprecate use of lldpctl_watch_callback(). Use\n      lldpctl_watch_callback2() instead.\n    + Upgrade embedded libevent to 2.1.11-stable\n    + Add support of sending LLDP frames on a configured VLAN\n\nlldpd (1.0.5)\n  * Changes:\n    + Interface names are also matched for management addresses.\n    + On Linux, only register protocol handler for LLDP when only LLDP\n      is enabled.\n    + Stricter on LLDP incoming frames validation.\n    + Add support for VLAN-aware bridges for Linux (no range support).\n    + Add support for 802.3BT (no SNMP support).\n    + Add support for millisecond-grained tx-interval (Jean-Pierre Tosoni).\n    + Use generic names for VLAN names, instead of interface names (eg\n      vlan100 instead of eth1.100).\n  * Fix:\n    + Don't clear chassis TLV on shutdown LLDPDU.\n    + Don't require/display powerpairs for Dot3 power when device type\n      is PD.\n\nlldpd (1.0.4)\n  * Changes:\n    + Add \"configure system max-neighbors XX\" command to modify maximum\n      of neighbors accepted per port.\n    + Implement lldpRemOrgDefInfoTable table for custom TLVs.\n  * Fix:\n    + Better compliance for statsTLVsUnrecognizedTotal and\n      statsAgeoutsTotal counters.\n    + On Linux, handle rare blocking case in Netlink code.\n\nlldpd (1.0.3)\n  * Fix:\n    + Fix creation of chroot directory.\n\nlldpd (1.0.2)\n  * Changes:\n    + On Linux, the monitor process will now drop its privileges\n      instead of running as root. It will keep CAP_NET_RAW,\n      CAP_NET_ADMIN and CAP_DAC_OVERRIDE capabilities.\n    + Support for CDP PD PoE (with negotiation). Thanks to Gustav\n      Wiklander.\n    + Move support for bonded devices on Linux < 2.6.27 into the\n      `--enable-oldies` option. This avoids duplicate packets\n      starting from Linux 4.19.\n\nlldpd (1.0.1)\n  * Fix:\n    + Use \"mkdir -p\" instead of \"mkdir\" in systemd unit.\n\nlldpd (1.0.0)\n  * Changes:\n    + Chassis ID can be set to an arbitrary value with \"configure system\n      chassisid\".\n    + Port description can be overriden directly with \"configure lldp\n      portdescription\".\n    + Command \"configure system interface permanent\" enables one to\n      specify a pattern for interfaces to be kept in memory even when\n      they are removed from the system.\n  * Fix:\n    + Ensure chassis-related changes are propagated immediately.\n    + Ensure management address change is correctly detected.\n\nlldpd (0.9.9)\n  * Changes:\n    + lldpcli can now display local interfaces with LLDP data sent on\n      each of them (\"show interfaces\").\n    + As Dot3 PD device, echo back allocated value from PSE device.\n  * Fix:\n    + Don't remove interfaces when they are released from a bridge.\n    + Don't use \"expect stop\" with Upstart. It's buggy.\n\nlldpd (0.9.8)\n  * Changes:\n    + \"Station\" capability is only set if no other bit is set.\n    + Use ethtool to get permanent address for bonds and teams. This\n      might provide different results than the previous method. Some\n      devices may still use the previous method.\n    + Don't run ethtool as root. Kernels older than 2.6.19 won't get\n      link information anymore.\n    + Add \"configure system hostname .\" option to not use a FQDN\n      for system name.\n    + Add \"-f json0\" to provide a more regular/machine-parsable output\n      to JSON output, even when not compiled with --enable-json0.\n  * Fixes:\n    + Handle team interfaces like a bond. Real MAC address cannot be\n      retrieved yet.\n\nlldpd (0.9.7)\n  * Changes:\n    + Attach remote TTL to port instead of chassis.\n    + JSON support is now built-in and unconditionally enabled. Use\n      --enable-json0 to keep the pre-0.9.2 json-c format.\n    + When logging to syslog and daemonizing, don't log to stderr.\n    + vxlan interfaces are now ignored as they are multi-point interfaces.\n    + Maximum number of neighbors for an interface is increased from 4 to 32.\n\nlldpd (0.9.6)\n  * Changes:\n    + Add a compile-time option to restore pre-0.9.2 JSON format (when\n      using json-c). Use `--enable-json0` to enable this option.\n    + Support for newer ethtool interface on Linux\n      (ETHTOOL_GLINKSETTINGS) and additional speed settings.\n    + Current MAU type is displayed even when autoneg is off.\n    + Increase netlink receive buffer by default. Can be changed at\n      compile-time through ./configure.\n  * Fixes:\n    + Correctly parse LLDP-MED civic address when the length of the\n      TLV exceeds the length of the address.\n    + Fix 100% CPU on some rare error condition.\n    + Fix lost timer when an interface is enslaved on Linux.\n\nlldpd (0.9.5)\n  * Changes:\n    + More Ethernet media supported. However, RFC4836 is quite\n      out-of-date with respected to 10G+ speeds, bringing some\n      inaccuracies.\n    + Directly get media information for an interface without using\n      the privileged process.\n    + LLDP-MED capability TLV is not sent when LLDP-MED is not enabled,\n      even if other LLDP-MED TLV are present.\n  * Fixes:\n    + Compilation fix with older versions of GCC.\n    + Don't use ethtool at all to get real MAC address for enslaved\n      devices (always use /proc).\n\nlldpd (0.9.4)\n  * Changes:\n    + Make lldpd accepts a `-p` option to specify the PID file.\n    + Ability to change multicast MAC address to two additional values\n      to reach customer bridges.\n    + lldpcli will now display chassis TTL when detailed view is enabled.\n  * Fixes:\n    + Fix setting of local value for port ID.\n    + Fix compilation with BSD make.\n    + Ensure lldpcli returns an error code on invalid commands.\n\nlldpd (0.9.3)\n  * Changes:\n    + Do not rely on support of constructors for liblldpctl.\n    + Always log to stderr (even in addition to syslog).\n    + `lldpcli watch` accepts a limit on the number of received events.\n  * Fixes:\n    + `lldpcli -f {xml,json} watch` should work now.\n    + Consider `veth` interfaces as physical interfaces.\n\nlldpd (0.9.2)\n  * Changes:\n    + Ability to add/remove/replace custom TLV from lldpcli.\n    + LLDP-MED capabilities are displayed differently in lldpcli.\n    + Limit the maximum depth (5) when trying to apply a VLAN.\n    + Change JSON output format when using json-c to match Jansson\n      output.\n    + Integration tests for the major parts of lldpd, including use of\n      address and leak sanitizer.\n  * Fixes:\n    + LLDP-MED POE TLV are now displayed in lldpcli.\n    + Ignore lower link when it is in another namespace.\n    + Fix various problems with interfaces being enslaved.\n    + Fix a memory leak when modifying port-related settings.\n\nlldpd (0.9.1)\n  * Changes:\n    + Rework packaging for OS X to make it work with El Capitan. To\n      simplify a bit, it is not possible anymore to build fat\n      binaries. Latest version of OS X supporting 32bit was 10.6.\n  * Fixes:\n    + By default, when using port alias as description, use port name\n      as port ID.\n    + Miscellaneous fixes with netlink cache.\n    + Ensure large netlink messages can be received.\n\nlldpd (0.9.0)\n  * Changes:\n    + Don't rely on libnl3 for netlink. Reuse the previous code and\n      implement a lighweight cache.\n\nlldpd (0.8.0, never released)\n  * Changes:\n    + PIE is now disabled by default. It's too difficult to reliably\n      detect if it works. Use --enable-pie to enable it.\n    + Retrieve the permanent MAC address of an interface through\n      ethtool for Linux if /proc/net/bonding is not available.\n    + Running lldpd with \"-d\" will keep the process in foreground but\n      logs will still go to syslog. To log to the console, add at\n      least one \"-d\".\n    + Fix minimal kernel version to 2.6.39. Add a runtime warning when\n      this is not the case.\n    + Remove old bridge code (the one using ioctl).\n    + Don't discard down interfaces. Notably, this enables us to keep\n      their specific configuration if any.\n    + For Linux, switch to libnl3. Be aware of the licensing issues in\n      case of static linking.\n    + Introduce the notion of default local port. New interfaces will\n      use it as a base. This allows setting various MED stuff.\n    + Provide an apparmor profile (untested).\n  * Fixes:\n    + Fix a buffer overflow when receiving a too large management\n      address TLV. Unless hardening has been disabled, this overflow\n      cannot be used for arbitrary code execution.\n    + Update LLDP-MED policy L2 priority values to match\n      802.1Q-2005. This may be a breaking change.\n\nlldpd (0.7.17)\n  * Fixes:\n    + Fix the way libevent configure is called.\n    + Fix an infinite loop when using veth on Linux 4.1+ kernels.\n    + Make CDP advertise the appropriate kernel name as platform,\n      not just \"Linux\".\n\nlldpd (0.7.16)\n  * Changes:\n    + For Linux, 2.6.32 is now the minimal required kernel. When using\n      an older kernel, use `--enable-oldies`.\n    + For Linux, use netlink to retrieve information about bridges,\n      VLAN and bonds. The code was contributed by Cumulus Networks.\n    + Use symbol versioning for liblldpctl.so.\n    + Ability to get local chassis information with \"show\n      chassis\".\n    + The library also has the same ability with the\n      `lldpctl_get_local_chassis()` function. It is also possible to\n      get a chassis atom from a port with `lldpctl_k_port_chassis`\n      key. This is now the preferred way to retrieve chassis related\n      information.\n  * Fixes:\n    + Fix build on OS X.\n    + Accept \"language\" when configuring MED location as a civic address.\n\nlldpd (0.7.15)\n  * Changes:\n    + Optional features can be configured with \"auto\" to autodetect if\n      they are usable. This is the default value for JSON and XML support.\n    + Ability to send and decode custom/unknown TLV. Thanks to Alexandru\n      Ardelean.\n    + Modify checksum function. While this should be strictly\n      equivalent, if you notice CDP packets not accepted anymore, this\n      change is the first culprit.\n\nlldpd (0.7.14)\n  * Changes:\n    + Shutdown LLPDU are sent on MSAP change and when lldpd exits.\n    + When an exact IP is provided as a management pattern, use it\n      unconditionally.\n    + Ability to set port ID and description to an arbitrary value,\n      thanks to Alexandru Ardelean.\n  * Fixes:\n    + Incorrect boundary check when decoding management address and\n      protocol identity may lead to lldpd crash when processing\n      malformed LLDPDU.\n    + Many edge cases where lldpd was leaving hanging processes after\n      crashing.\n\nlldpd (0.7.13)\n  * Fixes:\n    + Unbreak customization of Unix socket path from command line.\n\nlldpd (0.7.12)\n  * Changes:\n    + Interface pattern, management pattern, system description,\n      system platform and system hostname can be unconfigured to their\n      default values.\n  * Fixes:\n    + Don't complain when parsing a commented line.\n    + Correctly persist configuration changes for \"system interface\n      promiscuous\", \"system interface description\" \"med fast-start\n      enable\", \"pause\" and \"resume\".\n    + Fix listening on bond devices for old kernels (< 2.6.27).\n\nlldpd (0.7.11)\n  * Changes:\n    + Ship bash and zsh completion.\n    + Abort when some command-line options are repeated.\n  * Fixes:\n    + Handle correctly read failures in liblldpctl.\n\nlldpd (0.7.10)\n  * Changes:\n    + Ability to set promiscuous mode to work around bugs of some\n      switches encapsulating LLDP frames inside 802.1Q frames.\n    + JSON support for lldpcli can use json-c instead of jansson,\n      thanks to Michel Stam.\n  * Fixes:\n    + Fix checksum computation for Cisco CDP.\n    + Fix ability to disable LLDP.\n    + Fix seccomp sandbox, thanks to Patrick McLean.\n\nlldpd (0.7.9)\n  * Changes:\n    + Default location for chroot, socket and PID are now configurable\n      in `./configure`. The default location is based on the value of\n      `runstatedir` which in turn may be based on the value of\n      `localstatedir` which defaults to `/usr/local/var`. Therefore,\n      to get the previous locations, lldpd should be configured with\n      `./configure --localstatedir=/var`.\n    + Add support for shutdown LLDPU.\n    + Ability to configure IP management pattern from lldpcli.\n    + Ability to choose what port ID should be (MAC or interface name).\n  * Fixes:\n    + Fix `configure system bond-slave-src-mac-type local`. Also use\n      it as default.\n\nlldpd (0.7.8)\n  * Changes:\n    + Android support\n    + Add the possibility to disable privilege separation (lower\n      memory consumption, lower security, don't do it).\n    + Interfaces can now be whitelisted. For example, *,!eth*,!!eth1\n      is a valid pattern for all interfaces except eth ones, except\n      eth1. Moreover, on exact match, an matching interface\n      circumvents most sanity checks (like VLAN handling).\n    + Ability to override the hostname.\n  * Fixes:\n    + Don't hard-code default values for system name, system\n      description and port description. When the field is not present,\n      just don't display it.\n    + Fix lldpcli behaviour when suid.\n    + On OSX, don't use p2p0 interfaces: it would break WLAN.\n    + Fix SNMP support on RHEL.\n\nlldpd (0.7.7)\n  * Changes:\n    + Use a locally administered MAC address or an arbitrary one\n      instead of null MAC address for bond devices on Linux. This is\n      configurable through `lldpcli`.\n    + Add support for \"team\" driver (alternative to bond devices).\n    + Preliminary support for DTrace/systemtap.\n    + Preliminary support for seccomp (for monitor process).\n    + Setup chroot inside lldpd instead of relying on init script.\n  * Fixes:\n    + Various bugs related to fixed point number handling (for\n      coordinates in LLDP-MED)\n    + Fix a regression in how MAC address of an enslaved device is\n      retrieved.\n\nlldpd (0.7.6)\n  * Changes:\n    + Provide a way to build packages for OSX.\n    + Add an option to update interface description with neighbor name.\n  * Fixes:\n    + Compilation fix for OSX 10.6.\n\nlldpd (0.7.5)\n  * Fixes:\n    + Segfault while tokenizing in lldpcli.\n\nlldpd (0.7.4)\n  * Fixes:\n    + Segfault in lldpcli.\n    + Memory leak in liblldpctl when using a custom log handler.\n    + Fix some unaligned memory accesses.\n    + Fix frame reception on OpenBSD.\n  * Changes:\n    + Allow to configure hold value from lldpcli (and hence the TTL).\n    + Allow to configure pattern for valid interfaces from lldpcli.\n    + Allow to override system description from lldpcli.\n    + Display the neighbor connected as the process title (or the\n      number of connected neighbors).\n\nlldpd (0.7.3)\n  * Changes:\n    + DragonFly BSD support.\n    + Solaris support (incomplete).\n    + LLDP-MED fast start support (thanks to Roopa Prabhu).\n    + Provide global statistics through \"show statistics summary\"\n      command (thanks to Roopa Prabhu).\n  * Fixes:\n    + Fix IPv4/IPv6 address discovery in Linux.\n\nlldpd (0.7.2)\n  * Changes:\n    + lldpd can be configured through /etc/lldpd.conf and\n      /etc/lldpd.d. All commands accepted by lldpcli are accepted.\n    + Lock BPF interfaces before handing them to chrooted process on\n      BSD.\n    + Limit the number of neighbors for each port to 4 (per protocol).\n    + Force CDPv2 protocol with argument `-ccc`.\n    + Provide port statistics through \"show statistics\" command\n      (thanks to Roopa Prabhu).\n  * Fixes:\n    + Driver whitelisting is done before checking if an interface has\n      a lower interface in Linux.\n    + Expire remote ports and chassis in a timely manner.\n\nlldpd (0.7.1)\n  * Changes:\n    + Mac OS X support, sponsored by Xcloud, Mac cloud server hosting\n      provider. http://xcloud.me/\n    + Upstart and systemd support.\n    + Remove Unix socket when there is no process listening.\n\nlldpd (0.7.0)\n  * Changes:\n    + FreeBSD support.\n    + OpenBSD support.\n    + NetBSD support.\n    + Detect interface changes.\n    + CLI for lldpctl: lldpcli.\n    + Allow to disable LLDP protocol (with `-ll`). In this case, the\n      first enabled protocol will be used when no neighbor is detected.\n    + Allow to filter debug logs using tokens. Add more debug logs.\n    + lldpctl can now output JSON.\n    + Use netlink to gather interface information on Linux.\n    + Don't use ioctl for bridges anymore on Linux. The configure\n      option `--enable-oldies` allow to reenable their uses for\n      systems not supporting sysfs.\n\nlldpd (0.6.1)\n  * Changes:\n    + Provide liblldpctl.so, a library to interface with lldpd. The\n      documentation is provided through Doxygen. See src/lib/lldpctl.h\n      which contains all the exported functions.\n    + Make lldpctl uses liblldpctl.so.\n    + Add a \"watch\" option to lldpctl to monitor neighbor changes.\n    + Add the possibility to display the current configuration of\n      lldpd with lldpctl. Also add the possibility to reset the\n      current transmit delay.\n\nlldpd (0.6)\n  * Changes:\n    + Allow lldpctl to display hidden ports.\n    + Add a switch to specify interfaces to use to get chassis ID.\n    + Support for multiple management addresses and IPv6 management\n      addresses. Contributed by Jo\u00e3o Valverde.\n    + Switch to libevent. See README.md for details.\n    + Partial rewrite of the SNMP part. Less code.\n    + Unit tests for SNMP.\n    + Major rewrite of the protocol between lldpd and lldpctl. Less\n      code.\n  * Fixes:\n    + Several small SNMP fixes (discovered by unit tests).\n\nlldpd (0.5.7)\n * Fixes:\n    + Configure issue with NetSNMP and some linkers\n    + Fix infinite loop for the receive part: on certain conditions,\n      lldpd will stop sending packets and stop updating local data.\n\nlldpd (0.5.6)\n  * Changes:\n    + Send and receive native VLAN TLV with CDP\n    + Add a whitelist for some drivers (currently: dsa and veth)\n  * Fixes:\n    + Compilation issues with NetSNMP 5.7 (and with earlier versions too)\n    + Small optimization of BPF filter\n\nlldpd (0.5.5)\n  * Changes:\n    + Support for PPVID and PI Dot1 TLV, thanks to Shuah Khan.\n    + Extend whitelist with possibility to blacklist.\n  * Fixes:\n    + Key/value output was incorrect when a dot was present in\n      interface names. This is fixed but it is preferable to use XML\n      output since the parsing is more difficult in this case.\n    + Only grab DMI information once. Only uses DMI for x86 platform.\n    + Padding issues with socket protocol. This introduces a change in\n      the socket protocol!\n    + Fix a segfault when neither /etc/os-release nor lsb_release\n      are available.\n\nlldpd (0.5.4)\n  * Changes:\n    + Get OS information from /etc/os-release if available. Patch from\n      Michael Tremer.\n    + Add a flag to specify which interfaces lldpd should listen to.\n\nlldpd (0.5.3)\n  * Changes:\n    + Handle Dot3 POE-MDI TLV (802.3af and 802.3at).\n    + Allow to set Dot3 POE-MDI from lldpctl.\n  * Fixes:\n    + Allow root to change configuration of lldpd when lldpctl has suid set.\n\nlldpd (0.5.2)\n  * Changes:\n    + More flexible smart mode and new default. Manual page has been updated.\n    + Add a \"receive-only\" mode with \"-r\" switch.\n\nlldpd (0.5.1)\n  * Changes:\n    + Allow to force a protocol even when no peer for this protocol is\n      detected.\n    + Add a smart mode that allows to discard bogus port information,\n      for example CDP packets that are flooded through a switch that\n      does not support CDP.\n    + Allow to set LLDP-MED network policy from lldpctl, thanks to a patch from\n      Philipp Kempgen.\n    + Allow to set LLDP-MED POE-MDI from lldpctl.\n    + Add a summary of available options in \"lldpd -h\" and \"lldpctl -h\",\n      thanks to a patch from Jorge Boncompte.\n    + Add a new output (keyvalue) for lldpctl.\n    + Listen on VLAN using an appropriate BPF filter, VLAN\n      decapsulation. Older \"listen on vlan\" feature is discarded. See\n      README for more information on the new feature.\n    + Use output of lsb_release if available for system description.\n  * Fixes:\n    + Ignore interface with no queue. It should filter out interfaces\n      like \"vnet0\" that would fail if we try to send something on them.\n    + Don't check CDP checksums (not really a fix but it appears that\n      Cisco checksum have some difficult corner cases).\n\nlldpd (0.5.0)\n  * Changes:\n    + lldpd can now handle several systems on the same port. This\n      modification also allows to speak to a switch using CDP and LLDP\n      for example.\n    + The way that lldpd gathers information for each port has been\n      abstracted. This should allow to support more systems (BSD for\n      examples) or switch cores in the future. Sending/receive support\n      is also abstracted.\n    + Add \"-k\" switch to avoid to emit too much information on running\n      kernel.\n    + Support of ifAlias with kernel >= 2.6.28\n    + Lot of portability stuff. lldpd can now be compiled on RHEL\n      2.1. Still Linux-only though.\n    + Add an option to specify AgentX socket (-X).\n    + Add some unit tests\n    + lldpctl has been reworked; it is now able to output data in XML\n      format for easier parsing. Patches were provided by Andreas\n      Hofmeister.\n  * Fixes:\n    + Fix EDP VLAN handling\n    + Silent warnings about bridge stuff.\n    + Copy /etc/localtime into chroot before starting lldpd daemon to\n      ensure correct timestamps for logs.\n\nlldpd (0.4.1)\n  * Fix EDP handling when there is no VLAN\n  * Fix CDP version to not always be 1\n  * Misc fix:\n     + incorrect number of arguments for a LLOG_INFO call\n     + fix SNMP last change in case this change occurs before start time\n\nlldpd (0.4)\n  * Rewrite of packet builder and parser to be able to cope with\n    architecture that cannot do unaligned read. For decoder, we don't\n    cast structures any more since they can be unaligned. For encoder,\n    we use memcpy through the use of macro that build packets step by\n    step.\n\nlldpd (0.3.2)\n  * Fix LLDP-MED support\n\nlldpd (0.3.1)\n  * Misc fixes, including memory leaks\n\nlldpd (0.3)\n  * Initial support of LLDP-MED\n  * Fix for bridge detection (don't send bridge ioctl on random interfaces)\n  * For bonded devices, get the real hardware address. For inactive\n    slaves, transmit using a random MAC address.\n\nlldpd (0.2.1)\n  * Fix a syntax error in manual page\n  * Fix open() calls\n\nlldpd (0.2)\n  * Add privilege separation\n  * Add FDP support\n  * Support CDP encapsulated into native VLAN\n  * Various fixes\n\nlldpd (0.1)\n  * Initial release\n", "/* -*- mode: c; c-file-style: \"openbsd\" -*- */\n/*\n * Copyright (c) 2008 Vincent Bernat <bernat@luffy.cx>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n/* We also supports FDP which is very similar to CDPv1 */\n#include \"../lldpd.h\"\n#include \"../frame.h\"\n\n/*\n * CDP Requests Power at the switch output and therefore has to take into\n * account the loss in the PoE cable. This is done by the switch automatically\n * if lldp is used as the protocol.\n */\n#define CDP_CLASS_3_MAX_PSE_POE 154\t /* 15.4W Max PoE at PSE class 3 */\n#define CDP_SWTICH_DEFAULT_POE_PD 130\t /* 13.W default PoE at PD */\n#define CDP_SWTICH_DEFAULT_POE_PSE 154\t /* 15.4W default PoE at PSE */\n#define CDP_SWITCH_POE_CLASS_4_OFFSET 45 /* 4.5W  max loss from cable */\n#define CDP_SWITCH_POE_CLASS_3_OFFSET 24 /* 2.4W  max loss from cable */\n\n#if defined ENABLE_CDP || defined ENABLE_FDP\n\n#  include <stdio.h>\n#  include <unistd.h>\n#  include <errno.h>\n#  include <arpa/inet.h>\n\nstatic int\ncdp_send(struct lldpd *global, struct lldpd_hardware *hardware, int version)\n{\n\tconst char *platform = \"Unknown\";\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_mgmt *mgmt;\n\tstruct lldpd_port *port;\n\tu_int8_t mcastaddr[] = CDP_MULTICAST_ADDR;\n\tu_int8_t llcorg[] = LLC_ORG_CISCO;\n#  ifdef ENABLE_FDP\n\tchar *capstr;\n#  endif\n\tu_int16_t checksum;\n\tint length, i;\n\tu_int32_t cap;\n\tu_int8_t *packet;\n\tu_int8_t *pos, *pos_len_eh, *pos_llc, *pos_cdp, *pos_checksum, *tlv, *end;\n\n\tlog_debug(\"cdp\", \"send CDP frame on %s\", hardware->h_ifname);\n\n\tport = &(hardware->h_lport);\n\tchassis = port->p_chassis;\n\n#  ifdef ENABLE_FDP\n\tif (version == 0) {\n\t\t/* With FDP, change multicast address and LLC PID */\n\t\tconst u_int8_t fdpmcastaddr[] = FDP_MULTICAST_ADDR;\n\t\tconst u_int8_t fdpllcorg[] = LLC_ORG_FOUNDRY;\n\t\tmemcpy(mcastaddr, fdpmcastaddr, sizeof(mcastaddr));\n\t\tmemcpy(llcorg, fdpllcorg, sizeof(llcorg));\n\t}\n#  endif\n\n\tlength = hardware->h_mtu;\n\tif ((packet = (u_int8_t *)calloc(1, length)) == NULL) return ENOMEM;\n\tpos = packet;\n\n\t/* Ethernet header */\n\tif (!(POKE_BYTES(mcastaddr, sizeof(mcastaddr)) &&\n\t\tPOKE_BYTES(&hardware->h_lladdr, ETHER_ADDR_LEN) &&\n\t\tPOKE_SAVE(pos_len_eh) && /* We compute the len later */\n\t\tPOKE_UINT16(0)))\n\t\tgoto toobig;\n\n\t/* LLC */\n\tif (!(POKE_SAVE(pos_llc) && POKE_UINT8(0xaa) && /* SSAP */\n\t\tPOKE_UINT8(0xaa) &&\t\t\t/* DSAP */\n\t\tPOKE_UINT8(0x03) &&\t\t\t/* Control field */\n\t\tPOKE_BYTES(llcorg, sizeof(llcorg)) && POKE_UINT16(LLC_PID_CDP)))\n\t\tgoto toobig;\n\n\t/* CDP header */\n\tif (!(POKE_SAVE(pos_cdp) && POKE_UINT8((version == 0) ? 1 : version) &&\n\t\tPOKE_UINT8(global ? global->g_config.c_ttl : 180) &&\n\t\tPOKE_SAVE(pos_checksum) && /* Save checksum position */\n\t\tPOKE_UINT16(0)))\n\t\tgoto toobig;\n\n\t/* Chassis ID */\n\tconst char *chassis_name = chassis->c_name ? chassis->c_name : \"\";\n\tif (!(POKE_START_CDP_TLV(CDP_TLV_CHASSIS) &&\n\t\tPOKE_BYTES(chassis_name, strlen(chassis_name)) && POKE_END_CDP_TLV))\n\t\tgoto toobig;\n\n\t/* Adresses */\n\t/* See:\n\t *   http://www.cisco.com/univercd/cc/td/doc/product/lan/trsrb/frames.htm#xtocid12\n\t *\n\t * It seems that Cisco implies that CDP supports IPv6 using\n\t * 802.2 address format with 0xAAAA03 0x000000 0x0800, but\n\t * 0x0800 is the Ethernet protocol type for IPv4. Therefore,\n\t * we support only IPv4. */\n\ti = 0;\n\tTAILQ_FOREACH (mgmt, &chassis->c_mgmt, m_entries)\n\t\tif (mgmt->m_family == LLDPD_AF_IPV4) i++;\n\tif (i > 0) {\n\t\tif (!(POKE_START_CDP_TLV(CDP_TLV_ADDRESSES) && POKE_UINT32(i)))\n\t\t\tgoto toobig;\n\t\tTAILQ_FOREACH (mgmt, &chassis->c_mgmt, m_entries) {\n\t\t\tswitch (mgmt->m_family) {\n\t\t\tcase LLDPD_AF_IPV4:\n\t\t\t\tif (!(POKE_UINT8(1) &&\t /* Type: NLPID */\n\t\t\t\t\tPOKE_UINT8(1) && /* Length: 1 */\n\t\t\t\t\tPOKE_UINT8(CDP_ADDRESS_PROTO_IP) && /* IP */\n\t\t\t\t\tPOKE_UINT16(sizeof(\n\t\t\t\t\t    struct in_addr)) && /* Address length */\n\t\t\t\t\tPOKE_BYTES(&mgmt->m_addr,\n\t\t\t\t\t    sizeof(struct in_addr))))\n\t\t\t\t\tgoto toobig;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!(POKE_END_CDP_TLV)) goto toobig;\n\t}\n\n\t/* Port ID */\n\tconst char *port_descr =\n\t    hardware->h_lport.p_descr ? hardware->h_lport.p_descr : \"\";\n\tif (!(POKE_START_CDP_TLV(CDP_TLV_PORT) &&\n\t\tPOKE_BYTES(port_descr, strlen(port_descr)) && POKE_END_CDP_TLV))\n\t\tgoto toobig;\n\n\t/* Capabilities */\n\tif (version != 0) {\n\t\tcap = 0;\n\t\tif (chassis->c_cap_enabled & LLDP_CAP_ROUTER) cap |= CDP_CAP_ROUTER;\n\t\tif (chassis->c_cap_enabled & LLDP_CAP_BRIDGE) cap |= CDP_CAP_SWITCH;\n\t\tcap |= CDP_CAP_HOST;\n\t\tif (!(POKE_START_CDP_TLV(CDP_TLV_CAPABILITIES) && POKE_UINT32(cap) &&\n\t\t\tPOKE_END_CDP_TLV))\n\t\t\tgoto toobig;\n#  ifdef ENABLE_FDP\n\t} else {\n\t\t/* With FDP, it seems that a string is used in place of an int */\n\t\tif (chassis->c_cap_enabled & LLDP_CAP_ROUTER)\n\t\t\tcapstr = \"Router\";\n\t\telse if (chassis->c_cap_enabled & LLDP_CAP_BRIDGE)\n\t\t\tcapstr = \"Switch\";\n\t\telse if (chassis->c_cap_enabled & LLDP_CAP_REPEATER)\n\t\t\tcapstr = \"Bridge\";\n\t\telse\n\t\t\tcapstr = \"Host\";\n\t\tif (!(POKE_START_CDP_TLV(CDP_TLV_CAPABILITIES) &&\n\t\t\tPOKE_BYTES(capstr, strlen(capstr)) && POKE_END_CDP_TLV))\n\t\t\tgoto toobig;\n#  endif\n\t}\n\n\t/* Native VLAN */\n#  ifdef ENABLE_DOT1\n\tif (version >= 2 && hardware->h_lport.p_pvid != 0) {\n\t\tif (!(POKE_START_CDP_TLV(CDP_TLV_NATIVEVLAN) &&\n\t\t\tPOKE_UINT16(hardware->h_lport.p_pvid) && POKE_END_CDP_TLV))\n\t\t\tgoto toobig;\n\t}\n#  endif\n\n\t/* Software version */\n\tconst char *chassis_descr = chassis->c_descr ? chassis->c_descr : \"\";\n\tif (!(POKE_START_CDP_TLV(CDP_TLV_SOFTWARE) &&\n\t\tPOKE_BYTES(chassis_descr, strlen(chassis_descr)) && POKE_END_CDP_TLV))\n\t\tgoto toobig;\n\n\t/* Platform */\n\tif (global && global->g_config.c_platform)\n\t\tplatform = global->g_config.c_platform;\n\n\tif (!(POKE_START_CDP_TLV(CDP_TLV_PLATFORM) &&\n\t\tPOKE_BYTES(platform, strlen(platform)) && POKE_END_CDP_TLV))\n\t\tgoto toobig;\n\n#  ifdef ENABLE_DOT3\n\tif ((version >= 2) && (port->p_power.powertype != LLDP_DOT3_POWER_8023AT_OFF) &&\n\t    (port->p_power.devicetype == LLDP_DOT3_POWER_PD) &&\n\t    (port->p_power.requested > 0) && (port->p_power.requested <= 655)) {\n\t\tu_int16_t requested;\n\t\tu_int16_t consumption;\n\n\t\tif (port->p_power.requested != port->p_power.allocated) {\n\t\t\tport->p_cdp_power.request_id++;\n\t\t\tlog_debug(\"cdp\", \"requested: %d, allocated:%d\",\n\t\t\t    port->p_power.requested, port->p_power.allocated);\n\t\t}\n\t\tconsumption = port->p_power.allocated ? port->p_power.allocated :\n\t\t\t\t\t\t\tCDP_SWTICH_DEFAULT_POE_PD;\n\t\tif (consumption > 130) {\n\t\t\tconsumption += CDP_SWITCH_POE_CLASS_4_OFFSET;\n\t\t} else {\n\t\t\tconsumption += CDP_SWITCH_POE_CLASS_3_OFFSET;\n\t\t}\n\t\tif (port->p_power.requested > 130) { /* Class 4 */\n\t\t\trequested =\n\t\t\t    port->p_power.requested + CDP_SWITCH_POE_CLASS_4_OFFSET;\n\t\t} else { /* Class 3 */\n\t\t\trequested =\n\t\t\t    port->p_power.requested + CDP_SWITCH_POE_CLASS_3_OFFSET;\n\t\t}\n\t\tif (!(POKE_START_CDP_TLV(CDP_TLV_POWER_CONSUMPTION) &&\n\t\t\tPOKE_UINT16(consumption * 100) && POKE_END_CDP_TLV))\n\t\t\tgoto toobig;\n\t\t/* Avoid request id 0 from overflow */\n\t\tif (!port->p_cdp_power.request_id) {\n\t\t\tport->p_cdp_power.request_id = 1;\n\t\t}\n\t\tif (!port->p_cdp_power.management_id) {\n\t\t\tport->p_cdp_power.management_id = 1;\n\t\t}\n\t\tif (!(POKE_START_CDP_TLV(CDP_TLV_POWER_REQUESTED) &&\n\t\t\tPOKE_UINT16(port->p_cdp_power.request_id) &&\n\t\t\tPOKE_UINT16(port->p_cdp_power.management_id) &&\n\t\t\tPOKE_UINT32(requested * 100) && POKE_END_CDP_TLV))\n\t\t\tgoto toobig;\n\t}\n#  elif defined ENABLE_LLDPMED\n\t/* Power use */\n\tif ((version >= 2) && port->p_med_cap_enabled &&\n\t    (port->p_med_power.source != LLDP_MED_POW_SOURCE_LOCAL) &&\n\t    (port->p_med_power.val > 0) && (port->p_med_power.val <= 655)) {\n\t\tif (!(POKE_START_CDP_TLV(CDP_TLV_POWER_CONSUMPTION) &&\n\t\t\tPOKE_UINT16(port->p_med_power.val * 100) && POKE_END_CDP_TLV))\n\t\t\tgoto toobig;\n\t}\n#  endif\n\n\t(void)POKE_SAVE(end);\n\n\t/* Compute len and checksum */\n\tPOKE_RESTORE(pos_len_eh);\n\tif (!(POKE_UINT16(end - pos_llc))) goto toobig;\n\tchecksum = frame_checksum(pos_cdp, end - pos_cdp, (version != 0) ? 1 : 0);\n\tPOKE_RESTORE(pos_checksum);\n\tif (!(POKE_UINT16(checksum))) goto toobig;\n\n\tif (interfaces_send_helper(global, hardware, (char *)packet, end - packet) ==\n\t    -1) {\n\t\tlog_warn(\"cdp\", \"unable to send packet on real device for %s\",\n\t\t    hardware->h_ifname);\n\t\tfree(packet);\n\t\treturn ENETDOWN;\n\t}\n\n\thardware->h_tx_cnt++;\n\n\tfree(packet);\n\treturn 0;\ntoobig:\n\tfree(packet);\n\treturn -1;\n}\n\n#  define CHECK_TLV_SIZE(x, name)                                      \\\n    do {                                                               \\\n      if (tlv_len < (x)) {                                             \\\n\tlog_warnx(\"cdp\", name \" CDP/FDP TLV too short received on %s\", \\\n\t    hardware->h_ifname);                                       \\\n\tgoto malformed;                                                \\\n      }                                                                \\\n    } while (0)\n/* cdp_decode also decodes FDP */\nint\ncdp_decode(struct lldpd *cfg, char *frame, int s, struct lldpd_hardware *hardware,\n    struct lldpd_chassis **newchassis, struct lldpd_port **newport)\n{\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_port *port;\n\tstruct lldpd_mgmt *mgmt;\n\tstruct in_addr addr;\n#  if 0\n\tu_int16_t cksum;\n#  endif\n\tu_int8_t *software = NULL, *platform = NULL;\n\tint software_len = 0, platform_len = 0, proto, version, nb, caps;\n\tconst unsigned char cdpaddr[] = CDP_MULTICAST_ADDR;\n#  ifdef ENABLE_FDP\n\tconst unsigned char fdpaddr[] = CDP_MULTICAST_ADDR;\n\tint fdp = 0;\n#  endif\n\tu_int8_t *pos, *tlv, *pos_address, *pos_next_address;\n\tint length, len_eth, tlv_type, tlv_len, addresses_len, address_len;\n#  ifdef ENABLE_DOT1\n\tstruct lldpd_vlan *vlan;\n#  endif\n\n\tlog_debug(\"cdp\", \"decode CDP frame received on %s\", hardware->h_ifname);\n\n\tif ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {\n\t\tlog_warn(\"cdp\", \"failed to allocate remote chassis\");\n\t\treturn -1;\n\t}\n\tTAILQ_INIT(&chassis->c_mgmt);\n\tif ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) {\n\t\tlog_warn(\"cdp\", \"failed to allocate remote port\");\n\t\tfree(chassis);\n\t\treturn -1;\n\t}\n#  ifdef ENABLE_DOT1\n\tTAILQ_INIT(&port->p_vlans);\n#  endif\n\n\tlength = s;\n\tpos = (u_int8_t *)frame;\n\n\tif (length < 2 * ETHER_ADDR_LEN + sizeof(u_int16_t) /* Ethernet */ +\n\t\t8 /* LLC */ + 4 /* CDP header */) {\n\t\tlog_warn(\"cdp\", \"too short CDP/FDP frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\tif (PEEK_CMP(cdpaddr, sizeof(cdpaddr)) != 0) {\n#  ifdef ENABLE_FDP\n\t\tPEEK_RESTORE((u_int8_t *)frame);\n\t\tif (PEEK_CMP(fdpaddr, sizeof(fdpaddr)) != 0)\n\t\t\tfdp = 1;\n\t\telse {\n#  endif\n\t\t\tlog_info(\"cdp\",\n\t\t\t    \"frame not targeted at CDP/FDP multicast address received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n#  ifdef ENABLE_FDP\n\t\t}\n#  endif\n\t}\n\tPEEK_DISCARD(ETHER_ADDR_LEN); /* Don't care of source address */\n\tlen_eth = PEEK_UINT16;\n\tif (len_eth > length) {\n\t\tlog_warnx(\"cdp\", \"incorrect 802.3 frame size reported on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\t/* This is the correct length of the CDP + LLC packets */\n\tlength = len_eth;\n\n\tPEEK_DISCARD(6); /* Skip beginning of LLC */\n\tproto = PEEK_UINT16;\n\tif (proto != LLC_PID_CDP) {\n\t\tif ((proto != LLC_PID_DRIP) && (proto != LLC_PID_PAGP) &&\n\t\t    (proto != LLC_PID_PVSTP) && (proto != LLC_PID_UDLD) &&\n\t\t    (proto != LLC_PID_VTP) && (proto != LLC_PID_DTP) &&\n\t\t    (proto != LLC_PID_STP))\n\t\t\tlog_debug(\"cdp\", \"incorrect LLC protocol ID received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n#  if 0\n\t/* Check checksum */\n\tcksum = frame_checksum(pos, len_eth - 8,\n#    ifdef ENABLE_FDP\n\t    !fdp\t\t/* fdp = 0 -> cisco checksum */\n#    else\n\t    1\t\t\t/* cisco checksum */\n#    endif\n\t\t);\n\tif (cksum != 0) {\n\t\tlog_info(\"cdp\", \"incorrect CDP/FDP checksum for frame received on %s (%d)\",\n\t\t\t  hardware->h_ifname, cksum);\n\t\tgoto malformed;\n\t}\n#  endif\n\n\t/* Check version */\n\tversion = PEEK_UINT8;\n\tif ((version != 1) && (version != 2)) {\n\t\tlog_warnx(\"cdp\",\n\t\t    \"incorrect CDP/FDP version (%d) for frame received on %s\", version,\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tport->p_ttl = PEEK_UINT8; /* TTL */\n\tPEEK_DISCARD_UINT16;\t  /* Checksum, already checked */\n\n\twhile (length) {\n\t\tif (length < 4) {\n\t\t\tlog_warnx(\"cdp\",\n\t\t\t    \"CDP/FDP TLV header is too large for \"\n\t\t\t    \"frame received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\ttlv_type = PEEK_UINT16;\n\t\ttlv_len = PEEK_UINT16 - 4;\n\n\t\t(void)PEEK_SAVE(tlv);\n\t\tif ((tlv_len < 0) || (length < tlv_len)) {\n\t\t\tlog_warnx(\"cdp\",\n\t\t\t    \"incorrect size in CDP/FDP TLV header for frame \"\n\t\t\t    \"received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\tswitch (tlv_type) {\n\t\tcase CDP_TLV_CHASSIS:\n\t\t\tfree(chassis->c_name);\n\t\t\tif ((chassis->c_name = (char *)calloc(1, tlv_len + 1)) ==\n\t\t\t    NULL) {\n\t\t\t\tlog_warn(\"cdp\",\n\t\t\t\t    \"unable to allocate memory for chassis name\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_BYTES(chassis->c_name, tlv_len);\n\t\t\tchassis->c_id_subtype = LLDP_CHASSISID_SUBTYPE_LOCAL;\n\t\t\tfree(chassis->c_id);\n\t\t\tif ((chassis->c_id = (char *)malloc(tlv_len)) == NULL) {\n\t\t\t\tlog_warn(\"cdp\",\n\t\t\t\t    \"unable to allocate memory for chassis ID\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tmemcpy(chassis->c_id, chassis->c_name, tlv_len);\n\t\t\tchassis->c_id_len = tlv_len;\n\t\t\tbreak;\n\t\tcase CDP_TLV_ADDRESSES:\n\t\t\tCHECK_TLV_SIZE(4, \"Address\");\n\t\t\taddresses_len = tlv_len - 4;\n\t\t\tfor (nb = PEEK_UINT32; nb > 0; nb--) {\n\t\t\t\t(void)PEEK_SAVE(pos_address);\n\t\t\t\t/* We first try to get the real length of the packet */\n\t\t\t\tif (addresses_len < 2) {\n\t\t\t\t\tlog_warn(\"cdp\",\n\t\t\t\t\t    \"too short address subframe \"\n\t\t\t\t\t    \"received on %s\",\n\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tPEEK_DISCARD_UINT8;\n\t\t\t\taddresses_len--;\n\t\t\t\taddress_len = PEEK_UINT8;\n\t\t\t\taddresses_len--;\n\t\t\t\tif (addresses_len < address_len + 2) {\n\t\t\t\t\tlog_warn(\"cdp\",\n\t\t\t\t\t    \"too short address subframe \"\n\t\t\t\t\t    \"received on %s\",\n\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tPEEK_DISCARD(address_len);\n\t\t\t\taddresses_len -= address_len;\n\t\t\t\taddress_len = PEEK_UINT16;\n\t\t\t\taddresses_len -= 2;\n\t\t\t\tif (addresses_len < address_len) {\n\t\t\t\t\tlog_warn(\"cdp\",\n\t\t\t\t\t    \"too short address subframe \"\n\t\t\t\t\t    \"received on %s\",\n\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tPEEK_DISCARD(address_len);\n\t\t\t\taddresses_len -= address_len;\n\t\t\t\t(void)PEEK_SAVE(pos_next_address);\n\t\t\t\t/* Next, we go back and try to extract\n\t\t\t\t   IPv4 address */\n\t\t\t\tPEEK_RESTORE(pos_address);\n\t\t\t\tif ((PEEK_UINT8 == 1) && (PEEK_UINT8 == 1) &&\n\t\t\t\t    (PEEK_UINT8 == CDP_ADDRESS_PROTO_IP) &&\n\t\t\t\t    (PEEK_UINT16 == sizeof(struct in_addr))) {\n\t\t\t\t\tPEEK_BYTES(&addr, sizeof(struct in_addr));\n\t\t\t\t\tmgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4, &addr,\n\t\t\t\t\t    sizeof(struct in_addr), 0);\n\t\t\t\t\tif (mgmt == NULL) {\n\t\t\t\t\t\tif (errno == ENOMEM)\n\t\t\t\t\t\t\tlog_warn(\"cdp\",\n\t\t\t\t\t\t\t    \"unable to allocate memory for management address\");\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tlog_warn(\"cdp\",\n\t\t\t\t\t\t\t    \"too large management address received on %s\",\n\t\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt,\n\t\t\t\t\t    m_entries);\n\t\t\t\t}\n\t\t\t\t/* Go to the end of the address */\n\t\t\t\tPEEK_RESTORE(pos_next_address);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CDP_TLV_PORT:\n\t\t\tif (tlv_len == 0) {\n\t\t\t\tlog_warn(\"cdp\", \"too short port description received\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tfree(port->p_descr);\n\t\t\tif ((port->p_descr = (char *)calloc(1, tlv_len + 1)) == NULL) {\n\t\t\t\tlog_warn(\"cdp\",\n\t\t\t\t    \"unable to allocate memory for port description\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_BYTES(port->p_descr, tlv_len);\n\t\t\tport->p_id_subtype = LLDP_PORTID_SUBTYPE_IFNAME;\n\t\t\tfree(port->p_id);\n\t\t\tif ((port->p_id = (char *)calloc(1, tlv_len)) == NULL) {\n\t\t\t\tlog_warn(\"cdp\",\n\t\t\t\t    \"unable to allocate memory for port ID\");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tmemcpy(port->p_id, port->p_descr, tlv_len);\n\t\t\tport->p_id_len = tlv_len;\n\t\t\tbreak;\n\t\tcase CDP_TLV_CAPABILITIES:\n#  ifdef ENABLE_FDP\n\t\t\tif (fdp) {\n\t\t\t\t/* Capabilities are string with FDP */\n\t\t\t\tif (!strncmp(\"Router\", (char *)pos, tlv_len))\n\t\t\t\t\tchassis->c_cap_enabled = LLDP_CAP_ROUTER;\n\t\t\t\telse if (!strncmp(\"Switch\", (char *)pos, tlv_len))\n\t\t\t\t\tchassis->c_cap_enabled = LLDP_CAP_BRIDGE;\n\t\t\t\telse if (!strncmp(\"Bridge\", (char *)pos, tlv_len))\n\t\t\t\t\tchassis->c_cap_enabled = LLDP_CAP_REPEATER;\n\t\t\t\telse\n\t\t\t\t\tchassis->c_cap_enabled = LLDP_CAP_STATION;\n\t\t\t\tchassis->c_cap_available = chassis->c_cap_enabled;\n\t\t\t\tbreak;\n\t\t\t}\n#  endif\n\t\t\tCHECK_TLV_SIZE(4, \"Capabilities\");\n\t\t\tcaps = PEEK_UINT32;\n\t\t\tif (caps & CDP_CAP_ROUTER)\n\t\t\t\tchassis->c_cap_enabled |= LLDP_CAP_ROUTER;\n\t\t\tif (caps & 0x0e) chassis->c_cap_enabled |= LLDP_CAP_BRIDGE;\n\t\t\tif (chassis->c_cap_enabled == 0)\n\t\t\t\tchassis->c_cap_enabled = LLDP_CAP_STATION;\n\t\t\tchassis->c_cap_available = chassis->c_cap_enabled;\n\t\t\tbreak;\n\t\tcase CDP_TLV_SOFTWARE:\n\t\t\tsoftware_len = tlv_len;\n\t\t\t(void)PEEK_SAVE(software);\n\t\t\tbreak;\n\t\tcase CDP_TLV_PLATFORM:\n\t\t\tplatform_len = tlv_len;\n\t\t\t(void)PEEK_SAVE(platform);\n\t\t\tbreak;\n#  ifdef ENABLE_DOT1\n\t\tcase CDP_TLV_NATIVEVLAN:\n\t\t\tCHECK_TLV_SIZE(2, \"Native VLAN\");\n\t\t\tif ((vlan = (struct lldpd_vlan *)calloc(1,\n\t\t\t\t sizeof(struct lldpd_vlan))) == NULL) {\n\t\t\t\tlog_warn(\"cdp\",\n\t\t\t\t    \"unable to alloc vlan \"\n\t\t\t\t    \"structure for \"\n\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tvlan->v_vid = port->p_pvid = PEEK_UINT16;\n\t\t\tif (asprintf(&vlan->v_name, \"VLAN #%d\", vlan->v_vid) == -1) {\n\t\t\t\tlog_warn(\"cdp\",\n\t\t\t\t    \"unable to alloc VLAN name for \"\n\t\t\t\t    \"TLV received on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tfree(vlan);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tTAILQ_INSERT_TAIL(&port->p_vlans, vlan, v_entries);\n\t\t\tbreak;\n#  endif\n#  ifdef ENABLE_DOT3\n\t\tcase CDP_TLV_POWER_AVAILABLE:\n\t\t\tCHECK_TLV_SIZE(12, \"Power Available\");\n\t\t\t/* check if it is a respone to a request id */\n\t\t\tif (PEEK_UINT16 > 0) {\n\t\t\t\tport->p_cdp_power.management_id = PEEK_UINT16;\n\t\t\t\tport->p_power.allocated = PEEK_UINT32;\n\t\t\t\tport->p_power.allocated /= 100;\n\t\t\t\tport->p_power.supported = 1;\n\t\t\t\tport->p_power.enabled = 1;\n\t\t\t\tport->p_power.devicetype = LLDP_DOT3_POWER_PSE;\n\t\t\t\tport->p_power.powertype = LLDP_DOT3_POWER_8023AT_TYPE2;\n\t\t\t\tlog_debug(\"cdp\", \"Allocated power %d00\",\n\t\t\t\t    port->p_power.allocated);\n\t\t\t\tif (port->p_power.allocated > CDP_CLASS_3_MAX_PSE_POE) {\n\t\t\t\t\tport->p_power.allocated -=\n\t\t\t\t\t    CDP_SWITCH_POE_CLASS_4_OFFSET;\n\t\t\t\t} else if (port->p_power.allocated >\n\t\t\t\t    CDP_SWITCH_POE_CLASS_3_OFFSET) {\n\t\t\t\t\tport->p_power.allocated -=\n\t\t\t\t\t    CDP_SWITCH_POE_CLASS_3_OFFSET;\n\t\t\t\t} else {\n\t\t\t\t\tport->p_power.allocated = 0;\n\t\t\t\t}\n\t\t\t\tport->p_power.requested =\n\t\t\t\t    hardware->h_lport.p_power.requested;\n\t\t\t}\n\t\t\tbreak;\n#  endif\n\t\tdefault:\n\t\t\tlog_debug(\"cdp\", \"unknown CDP/FDP TLV type (%d) received on %s\",\n\t\t\t    ntohs(tlv_type), hardware->h_ifname);\n\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t}\n\t\tPEEK_DISCARD(tlv + tlv_len - pos);\n\t}\n\tif (!software && platform) {\n\t\tif ((chassis->c_descr = (char *)calloc(1, platform_len + 1)) == NULL) {\n\t\t\tlog_warn(\"cdp\",\n\t\t\t    \"unable to allocate memory for chassis description\");\n\t\t\tgoto malformed;\n\t\t}\n\t\tmemcpy(chassis->c_descr, platform, platform_len);\n\t} else if (software && !platform) {\n\t\tif ((chassis->c_descr = (char *)calloc(1, software_len + 1)) == NULL) {\n\t\t\tlog_warn(\"cdp\",\n\t\t\t    \"unable to allocate memory for chassis description\");\n\t\t\tgoto malformed;\n\t\t}\n\t\tmemcpy(chassis->c_descr, software, software_len);\n\t} else if (software && platform) {\n#  define CONCAT_PLATFORM \" running on\\n\"\n\t\tif ((chassis->c_descr = (char *)calloc(1,\n\t\t\t software_len + platform_len + strlen(CONCAT_PLATFORM) + 1)) ==\n\t\t    NULL) {\n\t\t\tlog_warn(\"cdp\",\n\t\t\t    \"unable to allocate memory for chassis description\");\n\t\t\tgoto malformed;\n\t\t}\n\t\tmemcpy(chassis->c_descr, platform, platform_len);\n\t\tmemcpy(chassis->c_descr + platform_len, CONCAT_PLATFORM,\n\t\t    strlen(CONCAT_PLATFORM));\n\t\tmemcpy(chassis->c_descr + platform_len + strlen(CONCAT_PLATFORM),\n\t\t    software, software_len);\n\t}\n\tif ((chassis->c_id == NULL) || (port->p_id == NULL) ||\n\t    (chassis->c_name == NULL) || (chassis->c_descr == NULL) ||\n\t    (port->p_descr == NULL) || (port->p_ttl == 0) ||\n\t    (chassis->c_cap_enabled == 0)) {\n\t\tlog_warnx(\"cdp\",\n\t\t    \"some mandatory CDP/FDP tlv are missing for frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\t*newchassis = chassis;\n\t*newport = port;\n\treturn 1;\n\nmalformed:\n\tlldpd_chassis_cleanup(chassis, 1);\n\tlldpd_port_cleanup(port, 1);\n\tfree(port);\n\treturn -1;\n}\n\n#  ifdef ENABLE_CDP\nint\ncdpv1_send(struct lldpd *global, struct lldpd_hardware *hardware)\n{\n\treturn cdp_send(global, hardware, 1);\n}\n\nint\ncdpv2_send(struct lldpd *global, struct lldpd_hardware *hardware)\n{\n\treturn cdp_send(global, hardware, 2);\n}\n#  endif\n\n#  ifdef ENABLE_FDP\nint\nfdp_send(struct lldpd *global, struct lldpd_hardware *hardware)\n{\n\treturn cdp_send(global, hardware, 0);\n}\n#  endif\n\n#  ifdef ENABLE_CDP\nstatic int\ncdp_guess(char *pos, int length, int version)\n{\n\tconst u_int8_t mcastaddr[] = CDP_MULTICAST_ADDR;\n\tif (length < 2 * ETHER_ADDR_LEN + sizeof(u_int16_t) /* Ethernet */ +\n\t\t8 /* LLC */ + 4 /* CDP header */)\n\t\treturn 0;\n\tif (PEEK_CMP(mcastaddr, ETHER_ADDR_LEN) != 0) return 0;\n\tPEEK_DISCARD(ETHER_ADDR_LEN);\n\tPEEK_DISCARD_UINT16; /* Ethernet */\n\tPEEK_DISCARD(8);     /* LLC */\n\treturn (PEEK_UINT8 == version);\n}\n\nint\ncdpv1_guess(char *frame, int len)\n{\n\treturn cdp_guess(frame, len, 1);\n}\n\nint\ncdpv2_guess(char *frame, int len)\n{\n\treturn cdp_guess(frame, len, 2);\n}\n#  endif\n\n#endif /* defined (ENABLE_CDP) || defined (ENABLE_FDP) */\n"], "filenames": ["NEWS", "src/daemon/protocols/cdp.c"], "buggy_code_start_loc": [0, 468], "buggy_code_end_loc": [0, 468], "fixing_code_start_loc": [1, 469], "fixing_code_end_loc": [5, 470], "type": "CWE-125", "message": "An issue was discovered in lldpd before 1.0.17. By crafting a CDP PDU packet with specific CDP_TLV_ADDRESSES TLVs, a malicious actor can remotely force the lldpd daemon to perform an out-of-bounds read on heap memory. This occurs in cdp_decode in daemon/protocols/cdp.c.", "other": {"cve": {"id": "CVE-2023-41910", "sourceIdentifier": "cve@mitre.org", "published": "2023-09-05T07:15:14.927", "lastModified": "2023-09-27T15:19:31.200", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in lldpd before 1.0.17. By crafting a CDP PDU packet with specific CDP_TLV_ADDRESSES TLVs, a malicious actor can remotely force the lldpd daemon to perform an out-of-bounds read on heap memory. This occurs in cdp_decode in daemon/protocols/cdp.c."}, {"lang": "es", "value": "Se descubri\u00f3 un problema en lldpd antes de la versi\u00f3n 1.0.17. Al manipular un paquete CDP PDU con TLVs CDP_TLV_ADDRESSES espec\u00edficos, un actor malicioso puede forzar remotamente al demonio lldpd a realizar una lecutra fuera de l\u00edmites en la memoria heap. Esto ocurre en cdp_decode in daemon/protocols/cdp.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lldpd_project:lldpd:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.17", "matchCriteriaId": "591FC9F7-7E51-49D8-97B9-513D515C0204"}]}]}], "references": [{"url": "https://github.com/lldpd/lldpd/commit/a9aeabdf879c25c584852a0bb5523837632f099b", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/lldpd/lldpd/releases/tag/1.0.17", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/09/msg00025.html", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2023/dsa-5505", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/lldpd/lldpd/commit/a9aeabdf879c25c584852a0bb5523837632f099b"}}