{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            DDDD   DDDD   SSSSS                              %\n%                            D   D  D   D  SS                                 %\n%                            D   D  D   D   SSS                               %\n%                            D   D  D   D     SS                              %\n%                            DDDD   DDDD   SSSSS                              %\n%                                                                             %\n%                                                                             %\n%           Read/Write Microsoft Direct Draw Surface Image Format             %\n%                                                                             %\n%                              Software Design                                %\n%                             Bianca van Schaik                               %\n%                                March 2008                                   %\n%                               Dirk Lemstra                                  %\n%                              September 2013                                 %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2015 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/attribute.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/cache.h\"\n#include \"magick/colorspace.h\"\n#include \"magick/colorspace-private.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/image.h\"\n#include \"magick/image-private.h\"\n#include \"magick/list.h\"\n#include \"magick/log.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/monitor.h\"\n#include \"magick/monitor-private.h\"\n#include \"magick/option.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/profile.h\"\n#include \"magick/quantum.h\"\n#include \"magick/quantum-private.h\"\n#include \"magick/resource_.h\"\n#include \"magick/static.h\"\n#include \"magick/string_.h\"\n#include \"magick/string-private.h\"\n#include \"magick/module.h\"\n#include \"magick/transform.h\"\n\n/*\n  Definitions\n*/\n#define DDSD_CAPS         0x00000001\n#define DDSD_HEIGHT       0x00000002\n#define DDSD_WIDTH        0x00000004\n#define DDSD_PITCH        0x00000008\n#define DDSD_PIXELFORMAT  0x00001000\n#define DDSD_MIPMAPCOUNT  0x00020000\n#define DDSD_LINEARSIZE   0x00080000\n#define DDSD_DEPTH        0x00800000\n\n#define DDPF_ALPHAPIXELS  0x00000001\n#define DDPF_FOURCC       0x00000004\n#define DDPF_RGB          0x00000040\n#define DDPF_LUMINANCE    0x00020000\n\n#define FOURCC_DXT1       0x31545844\n#define FOURCC_DXT3       0x33545844\n#define FOURCC_DXT5       0x35545844\n\n#define DDSCAPS_COMPLEX   0x00000008\n#define DDSCAPS_TEXTURE   0x00001000\n#define DDSCAPS_MIPMAP    0x00400000\n\n#define DDSCAPS2_CUBEMAP  0x00000200\n#define DDSCAPS2_CUBEMAP_POSITIVEX  0x00000400\n#define DDSCAPS2_CUBEMAP_NEGATIVEX  0x00000800\n#define DDSCAPS2_CUBEMAP_POSITIVEY  0x00001000\n#define DDSCAPS2_CUBEMAP_NEGATIVEY  0x00002000\n#define DDSCAPS2_CUBEMAP_POSITIVEZ  0x00004000\n#define DDSCAPS2_CUBEMAP_NEGATIVEZ  0x00008000\n#define DDSCAPS2_VOLUME   0x00200000\n\n#ifndef SIZE_MAX\n#define SIZE_MAX ((size_t) -1)\n#endif\n\n/*\n  Structure declarations.\n*/\ntypedef struct _DDSPixelFormat\n{\n  size_t\n    flags,\n    fourcc,\n    rgb_bitcount,\n    r_bitmask,\n    g_bitmask,\n    b_bitmask,\n    alpha_bitmask;\n} DDSPixelFormat;\n\ntypedef struct _DDSInfo\n{\n  size_t\n    flags,\n    height,\n    width,\n    pitchOrLinearSize,\n    depth,\n    mipmapcount,\n    ddscaps1,\n    ddscaps2;\n\n  DDSPixelFormat\n    pixelformat;\n} DDSInfo;\n\ntypedef struct _DDSColors\n{\n  unsigned char\n    r[4],\n    g[4],\n    b[4],\n    a[4];\n} DDSColors;\n\ntypedef struct _DDSVector4\n{\n  float\n    x,\n    y,\n    z,\n    w;\n} DDSVector4;\n\ntypedef struct _DDSVector3\n{\n  float\n    x,\n    y,\n    z;\n} DDSVector3;\n\ntypedef struct _DDSSourceBlock\n{\n  unsigned char\n    start,\n    end,\n    error;\n} DDSSourceBlock;\n\ntypedef struct _DDSSingleColourLookup\n{\n  DDSSourceBlock sources[2];\n} DDSSingleColourLookup;\n\ntypedef MagickBooleanType\n  DDSDecoder(Image *, DDSInfo *, ExceptionInfo *);\n\nstatic const DDSSingleColourLookup DDSLookup_5_4[] =\n{\n  { { { 0, 0, 0 }, { 0, 0, 0 } } },\n  { { { 0, 0, 1 }, { 0, 1, 1 } } },\n  { { { 0, 0, 2 }, { 0, 1, 0 } } },\n  { { { 0, 0, 3 }, { 0, 1, 1 } } },\n  { { { 0, 0, 4 }, { 0, 2, 1 } } },\n  { { { 1, 0, 3 }, { 0, 2, 0 } } },\n  { { { 1, 0, 2 }, { 0, 2, 1 } } },\n  { { { 1, 0, 1 }, { 0, 3, 1 } } },\n  { { { 1, 0, 0 }, { 0, 3, 0 } } },\n  { { { 1, 0, 1 }, { 1, 2, 1 } } },\n  { { { 1, 0, 2 }, { 1, 2, 0 } } },\n  { { { 1, 0, 3 }, { 0, 4, 0 } } },\n  { { { 1, 0, 4 }, { 0, 5, 1 } } },\n  { { { 2, 0, 3 }, { 0, 5, 0 } } },\n  { { { 2, 0, 2 }, { 0, 5, 1 } } },\n  { { { 2, 0, 1 }, { 0, 6, 1 } } },\n  { { { 2, 0, 0 }, { 0, 6, 0 } } },\n  { { { 2, 0, 1 }, { 2, 3, 1 } } },\n  { { { 2, 0, 2 }, { 2, 3, 0 } } },\n  { { { 2, 0, 3 }, { 0, 7, 0 } } },\n  { { { 2, 0, 4 }, { 1, 6, 1 } } },\n  { { { 3, 0, 3 }, { 1, 6, 0 } } },\n  { { { 3, 0, 2 }, { 0, 8, 0 } } },\n  { { { 3, 0, 1 }, { 0, 9, 1 } } },\n  { { { 3, 0, 0 }, { 0, 9, 0 } } },\n  { { { 3, 0, 1 }, { 0, 9, 1 } } },\n  { { { 3, 0, 2 }, { 0, 10, 1 } } },\n  { { { 3, 0, 3 }, { 0, 10, 0 } } },\n  { { { 3, 0, 4 }, { 2, 7, 1 } } },\n  { { { 4, 0, 4 }, { 2, 7, 0 } } },\n  { { { 4, 0, 3 }, { 0, 11, 0 } } },\n  { { { 4, 0, 2 }, { 1, 10, 1 } } },\n  { { { 4, 0, 1 }, { 1, 10, 0 } } },\n  { { { 4, 0, 0 }, { 0, 12, 0 } } },\n  { { { 4, 0, 1 }, { 0, 13, 1 } } },\n  { { { 4, 0, 2 }, { 0, 13, 0 } } },\n  { { { 4, 0, 3 }, { 0, 13, 1 } } },\n  { { { 4, 0, 4 }, { 0, 14, 1 } } },\n  { { { 5, 0, 3 }, { 0, 14, 0 } } },\n  { { { 5, 0, 2 }, { 2, 11, 1 } } },\n  { { { 5, 0, 1 }, { 2, 11, 0 } } },\n  { { { 5, 0, 0 }, { 0, 15, 0 } } },\n  { { { 5, 0, 1 }, { 1, 14, 1 } } },\n  { { { 5, 0, 2 }, { 1, 14, 0 } } },\n  { { { 5, 0, 3 }, { 0, 16, 0 } } },\n  { { { 5, 0, 4 }, { 0, 17, 1 } } },\n  { { { 6, 0, 3 }, { 0, 17, 0 } } },\n  { { { 6, 0, 2 }, { 0, 17, 1 } } },\n  { { { 6, 0, 1 }, { 0, 18, 1 } } },\n  { { { 6, 0, 0 }, { 0, 18, 0 } } },\n  { { { 6, 0, 1 }, { 2, 15, 1 } } },\n  { { { 6, 0, 2 }, { 2, 15, 0 } } },\n  { { { 6, 0, 3 }, { 0, 19, 0 } } },\n  { { { 6, 0, 4 }, { 1, 18, 1 } } },\n  { { { 7, 0, 3 }, { 1, 18, 0 } } },\n  { { { 7, 0, 2 }, { 0, 20, 0 } } },\n  { { { 7, 0, 1 }, { 0, 21, 1 } } },\n  { { { 7, 0, 0 }, { 0, 21, 0 } } },\n  { { { 7, 0, 1 }, { 0, 21, 1 } } },\n  { { { 7, 0, 2 }, { 0, 22, 1 } } },\n  { { { 7, 0, 3 }, { 0, 22, 0 } } },\n  { { { 7, 0, 4 }, { 2, 19, 1 } } },\n  { { { 8, 0, 4 }, { 2, 19, 0 } } },\n  { { { 8, 0, 3 }, { 0, 23, 0 } } },\n  { { { 8, 0, 2 }, { 1, 22, 1 } } },\n  { { { 8, 0, 1 }, { 1, 22, 0 } } },\n  { { { 8, 0, 0 }, { 0, 24, 0 } } },\n  { { { 8, 0, 1 }, { 0, 25, 1 } } },\n  { { { 8, 0, 2 }, { 0, 25, 0 } } },\n  { { { 8, 0, 3 }, { 0, 25, 1 } } },\n  { { { 8, 0, 4 }, { 0, 26, 1 } } },\n  { { { 9, 0, 3 }, { 0, 26, 0 } } },\n  { { { 9, 0, 2 }, { 2, 23, 1 } } },\n  { { { 9, 0, 1 }, { 2, 23, 0 } } },\n  { { { 9, 0, 0 }, { 0, 27, 0 } } },\n  { { { 9, 0, 1 }, { 1, 26, 1 } } },\n  { { { 9, 0, 2 }, { 1, 26, 0 } } },\n  { { { 9, 0, 3 }, { 0, 28, 0 } } },\n  { { { 9, 0, 4 }, { 0, 29, 1 } } },\n  { { { 10, 0, 3 }, { 0, 29, 0 } } },\n  { { { 10, 0, 2 }, { 0, 29, 1 } } },\n  { { { 10, 0, 1 }, { 0, 30, 1 } } },\n  { { { 10, 0, 0 }, { 0, 30, 0 } } },\n  { { { 10, 0, 1 }, { 2, 27, 1 } } },\n  { { { 10, 0, 2 }, { 2, 27, 0 } } },\n  { { { 10, 0, 3 }, { 0, 31, 0 } } },\n  { { { 10, 0, 4 }, { 1, 30, 1 } } },\n  { { { 11, 0, 3 }, { 1, 30, 0 } } },\n  { { { 11, 0, 2 }, { 4, 24, 0 } } },\n  { { { 11, 0, 1 }, { 1, 31, 1 } } },\n  { { { 11, 0, 0 }, { 1, 31, 0 } } },\n  { { { 11, 0, 1 }, { 1, 31, 1 } } },\n  { { { 11, 0, 2 }, { 2, 30, 1 } } },\n  { { { 11, 0, 3 }, { 2, 30, 0 } } },\n  { { { 11, 0, 4 }, { 2, 31, 1 } } },\n  { { { 12, 0, 4 }, { 2, 31, 0 } } },\n  { { { 12, 0, 3 }, { 4, 27, 0 } } },\n  { { { 12, 0, 2 }, { 3, 30, 1 } } },\n  { { { 12, 0, 1 }, { 3, 30, 0 } } },\n  { { { 12, 0, 0 }, { 4, 28, 0 } } },\n  { { { 12, 0, 1 }, { 3, 31, 1 } } },\n  { { { 12, 0, 2 }, { 3, 31, 0 } } },\n  { { { 12, 0, 3 }, { 3, 31, 1 } } },\n  { { { 12, 0, 4 }, { 4, 30, 1 } } },\n  { { { 13, 0, 3 }, { 4, 30, 0 } } },\n  { { { 13, 0, 2 }, { 6, 27, 1 } } },\n  { { { 13, 0, 1 }, { 6, 27, 0 } } },\n  { { { 13, 0, 0 }, { 4, 31, 0 } } },\n  { { { 13, 0, 1 }, { 5, 30, 1 } } },\n  { { { 13, 0, 2 }, { 5, 30, 0 } } },\n  { { { 13, 0, 3 }, { 8, 24, 0 } } },\n  { { { 13, 0, 4 }, { 5, 31, 1 } } },\n  { { { 14, 0, 3 }, { 5, 31, 0 } } },\n  { { { 14, 0, 2 }, { 5, 31, 1 } } },\n  { { { 14, 0, 1 }, { 6, 30, 1 } } },\n  { { { 14, 0, 0 }, { 6, 30, 0 } } },\n  { { { 14, 0, 1 }, { 6, 31, 1 } } },\n  { { { 14, 0, 2 }, { 6, 31, 0 } } },\n  { { { 14, 0, 3 }, { 8, 27, 0 } } },\n  { { { 14, 0, 4 }, { 7, 30, 1 } } },\n  { { { 15, 0, 3 }, { 7, 30, 0 } } },\n  { { { 15, 0, 2 }, { 8, 28, 0 } } },\n  { { { 15, 0, 1 }, { 7, 31, 1 } } },\n  { { { 15, 0, 0 }, { 7, 31, 0 } } },\n  { { { 15, 0, 1 }, { 7, 31, 1 } } },\n  { { { 15, 0, 2 }, { 8, 30, 1 } } },\n  { { { 15, 0, 3 }, { 8, 30, 0 } } },\n  { { { 15, 0, 4 }, { 10, 27, 1 } } },\n  { { { 16, 0, 4 }, { 10, 27, 0 } } },\n  { { { 16, 0, 3 }, { 8, 31, 0 } } },\n  { { { 16, 0, 2 }, { 9, 30, 1 } } },\n  { { { 16, 0, 1 }, { 9, 30, 0 } } },\n  { { { 16, 0, 0 }, { 12, 24, 0 } } },\n  { { { 16, 0, 1 }, { 9, 31, 1 } } },\n  { { { 16, 0, 2 }, { 9, 31, 0 } } },\n  { { { 16, 0, 3 }, { 9, 31, 1 } } },\n  { { { 16, 0, 4 }, { 10, 30, 1 } } },\n  { { { 17, 0, 3 }, { 10, 30, 0 } } },\n  { { { 17, 0, 2 }, { 10, 31, 1 } } },\n  { { { 17, 0, 1 }, { 10, 31, 0 } } },\n  { { { 17, 0, 0 }, { 12, 27, 0 } } },\n  { { { 17, 0, 1 }, { 11, 30, 1 } } },\n  { { { 17, 0, 2 }, { 11, 30, 0 } } },\n  { { { 17, 0, 3 }, { 12, 28, 0 } } },\n  { { { 17, 0, 4 }, { 11, 31, 1 } } },\n  { { { 18, 0, 3 }, { 11, 31, 0 } } },\n  { { { 18, 0, 2 }, { 11, 31, 1 } } },\n  { { { 18, 0, 1 }, { 12, 30, 1 } } },\n  { { { 18, 0, 0 }, { 12, 30, 0 } } },\n  { { { 18, 0, 1 }, { 14, 27, 1 } } },\n  { { { 18, 0, 2 }, { 14, 27, 0 } } },\n  { { { 18, 0, 3 }, { 12, 31, 0 } } },\n  { { { 18, 0, 4 }, { 13, 30, 1 } } },\n  { { { 19, 0, 3 }, { 13, 30, 0 } } },\n  { { { 19, 0, 2 }, { 16, 24, 0 } } },\n  { { { 19, 0, 1 }, { 13, 31, 1 } } },\n  { { { 19, 0, 0 }, { 13, 31, 0 } } },\n  { { { 19, 0, 1 }, { 13, 31, 1 } } },\n  { { { 19, 0, 2 }, { 14, 30, 1 } } },\n  { { { 19, 0, 3 }, { 14, 30, 0 } } },\n  { { { 19, 0, 4 }, { 14, 31, 1 } } },\n  { { { 20, 0, 4 }, { 14, 31, 0 } } },\n  { { { 20, 0, 3 }, { 16, 27, 0 } } },\n  { { { 20, 0, 2 }, { 15, 30, 1 } } },\n  { { { 20, 0, 1 }, { 15, 30, 0 } } },\n  { { { 20, 0, 0 }, { 16, 28, 0 } } },\n  { { { 20, 0, 1 }, { 15, 31, 1 } } },\n  { { { 20, 0, 2 }, { 15, 31, 0 } } },\n  { { { 20, 0, 3 }, { 15, 31, 1 } } },\n  { { { 20, 0, 4 }, { 16, 30, 1 } } },\n  { { { 21, 0, 3 }, { 16, 30, 0 } } },\n  { { { 21, 0, 2 }, { 18, 27, 1 } } },\n  { { { 21, 0, 1 }, { 18, 27, 0 } } },\n  { { { 21, 0, 0 }, { 16, 31, 0 } } },\n  { { { 21, 0, 1 }, { 17, 30, 1 } } },\n  { { { 21, 0, 2 }, { 17, 30, 0 } } },\n  { { { 21, 0, 3 }, { 20, 24, 0 } } },\n  { { { 21, 0, 4 }, { 17, 31, 1 } } },\n  { { { 22, 0, 3 }, { 17, 31, 0 } } },\n  { { { 22, 0, 2 }, { 17, 31, 1 } } },\n  { { { 22, 0, 1 }, { 18, 30, 1 } } },\n  { { { 22, 0, 0 }, { 18, 30, 0 } } },\n  { { { 22, 0, 1 }, { 18, 31, 1 } } },\n  { { { 22, 0, 2 }, { 18, 31, 0 } } },\n  { { { 22, 0, 3 }, { 20, 27, 0 } } },\n  { { { 22, 0, 4 }, { 19, 30, 1 } } },\n  { { { 23, 0, 3 }, { 19, 30, 0 } } },\n  { { { 23, 0, 2 }, { 20, 28, 0 } } },\n  { { { 23, 0, 1 }, { 19, 31, 1 } } },\n  { { { 23, 0, 0 }, { 19, 31, 0 } } },\n  { { { 23, 0, 1 }, { 19, 31, 1 } } },\n  { { { 23, 0, 2 }, { 20, 30, 1 } } },\n  { { { 23, 0, 3 }, { 20, 30, 0 } } },\n  { { { 23, 0, 4 }, { 22, 27, 1 } } },\n  { { { 24, 0, 4 }, { 22, 27, 0 } } },\n  { { { 24, 0, 3 }, { 20, 31, 0 } } },\n  { { { 24, 0, 2 }, { 21, 30, 1 } } },\n  { { { 24, 0, 1 }, { 21, 30, 0 } } },\n  { { { 24, 0, 0 }, { 24, 24, 0 } } },\n  { { { 24, 0, 1 }, { 21, 31, 1 } } },\n  { { { 24, 0, 2 }, { 21, 31, 0 } } },\n  { { { 24, 0, 3 }, { 21, 31, 1 } } },\n  { { { 24, 0, 4 }, { 22, 30, 1 } } },\n  { { { 25, 0, 3 }, { 22, 30, 0 } } },\n  { { { 25, 0, 2 }, { 22, 31, 1 } } },\n  { { { 25, 0, 1 }, { 22, 31, 0 } } },\n  { { { 25, 0, 0 }, { 24, 27, 0 } } },\n  { { { 25, 0, 1 }, { 23, 30, 1 } } },\n  { { { 25, 0, 2 }, { 23, 30, 0 } } },\n  { { { 25, 0, 3 }, { 24, 28, 0 } } },\n  { { { 25, 0, 4 }, { 23, 31, 1 } } },\n  { { { 26, 0, 3 }, { 23, 31, 0 } } },\n  { { { 26, 0, 2 }, { 23, 31, 1 } } },\n  { { { 26, 0, 1 }, { 24, 30, 1 } } },\n  { { { 26, 0, 0 }, { 24, 30, 0 } } },\n  { { { 26, 0, 1 }, { 26, 27, 1 } } },\n  { { { 26, 0, 2 }, { 26, 27, 0 } } },\n  { { { 26, 0, 3 }, { 24, 31, 0 } } },\n  { { { 26, 0, 4 }, { 25, 30, 1 } } },\n  { { { 27, 0, 3 }, { 25, 30, 0 } } },\n  { { { 27, 0, 2 }, { 28, 24, 0 } } },\n  { { { 27, 0, 1 }, { 25, 31, 1 } } },\n  { { { 27, 0, 0 }, { 25, 31, 0 } } },\n  { { { 27, 0, 1 }, { 25, 31, 1 } } },\n  { { { 27, 0, 2 }, { 26, 30, 1 } } },\n  { { { 27, 0, 3 }, { 26, 30, 0 } } },\n  { { { 27, 0, 4 }, { 26, 31, 1 } } },\n  { { { 28, 0, 4 }, { 26, 31, 0 } } },\n  { { { 28, 0, 3 }, { 28, 27, 0 } } },\n  { { { 28, 0, 2 }, { 27, 30, 1 } } },\n  { { { 28, 0, 1 }, { 27, 30, 0 } } },\n  { { { 28, 0, 0 }, { 28, 28, 0 } } },\n  { { { 28, 0, 1 }, { 27, 31, 1 } } },\n  { { { 28, 0, 2 }, { 27, 31, 0 } } },\n  { { { 28, 0, 3 }, { 27, 31, 1 } } },\n  { { { 28, 0, 4 }, { 28, 30, 1 } } },\n  { { { 29, 0, 3 }, { 28, 30, 0 } } },\n  { { { 29, 0, 2 }, { 30, 27, 1 } } },\n  { { { 29, 0, 1 }, { 30, 27, 0 } } },\n  { { { 29, 0, 0 }, { 28, 31, 0 } } },\n  { { { 29, 0, 1 }, { 29, 30, 1 } } },\n  { { { 29, 0, 2 }, { 29, 30, 0 } } },\n  { { { 29, 0, 3 }, { 29, 30, 1 } } },\n  { { { 29, 0, 4 }, { 29, 31, 1 } } },\n  { { { 30, 0, 3 }, { 29, 31, 0 } } },\n  { { { 30, 0, 2 }, { 29, 31, 1 } } },\n  { { { 30, 0, 1 }, { 30, 30, 1 } } },\n  { { { 30, 0, 0 }, { 30, 30, 0 } } },\n  { { { 30, 0, 1 }, { 30, 31, 1 } } },\n  { { { 30, 0, 2 }, { 30, 31, 0 } } },\n  { { { 30, 0, 3 }, { 30, 31, 1 } } },\n  { { { 30, 0, 4 }, { 31, 30, 1 } } },\n  { { { 31, 0, 3 }, { 31, 30, 0 } } },\n  { { { 31, 0, 2 }, { 31, 30, 1 } } },\n  { { { 31, 0, 1 }, { 31, 31, 1 } } },\n  { { { 31, 0, 0 }, { 31, 31, 0 } } }\n};\n\nstatic const DDSSingleColourLookup DDSLookup_6_4[] =\n{\n  { { { 0, 0, 0 }, { 0, 0, 0 } } },\n  { { { 0, 0, 1 }, { 0, 1, 0 } } },\n  { { { 0, 0, 2 }, { 0, 2, 0 } } },\n  { { { 1, 0, 1 }, { 0, 3, 1 } } },\n  { { { 1, 0, 0 }, { 0, 3, 0 } } },\n  { { { 1, 0, 1 }, { 0, 4, 0 } } },\n  { { { 1, 0, 2 }, { 0, 5, 0 } } },\n  { { { 2, 0, 1 }, { 0, 6, 1 } } },\n  { { { 2, 0, 0 }, { 0, 6, 0 } } },\n  { { { 2, 0, 1 }, { 0, 7, 0 } } },\n  { { { 2, 0, 2 }, { 0, 8, 0 } } },\n  { { { 3, 0, 1 }, { 0, 9, 1 } } },\n  { { { 3, 0, 0 }, { 0, 9, 0 } } },\n  { { { 3, 0, 1 }, { 0, 10, 0 } } },\n  { { { 3, 0, 2 }, { 0, 11, 0 } } },\n  { { { 4, 0, 1 }, { 0, 12, 1 } } },\n  { { { 4, 0, 0 }, { 0, 12, 0 } } },\n  { { { 4, 0, 1 }, { 0, 13, 0 } } },\n  { { { 4, 0, 2 }, { 0, 14, 0 } } },\n  { { { 5, 0, 1 }, { 0, 15, 1 } } },\n  { { { 5, 0, 0 }, { 0, 15, 0 } } },\n  { { { 5, 0, 1 }, { 0, 16, 0 } } },\n  { { { 5, 0, 2 }, { 1, 15, 0 } } },\n  { { { 6, 0, 1 }, { 0, 17, 0 } } },\n  { { { 6, 0, 0 }, { 0, 18, 0 } } },\n  { { { 6, 0, 1 }, { 0, 19, 0 } } },\n  { { { 6, 0, 2 }, { 3, 14, 0 } } },\n  { { { 7, 0, 1 }, { 0, 20, 0 } } },\n  { { { 7, 0, 0 }, { 0, 21, 0 } } },\n  { { { 7, 0, 1 }, { 0, 22, 0 } } },\n  { { { 7, 0, 2 }, { 4, 15, 0 } } },\n  { { { 8, 0, 1 }, { 0, 23, 0 } } },\n  { { { 8, 0, 0 }, { 0, 24, 0 } } },\n  { { { 8, 0, 1 }, { 0, 25, 0 } } },\n  { { { 8, 0, 2 }, { 6, 14, 0 } } },\n  { { { 9, 0, 1 }, { 0, 26, 0 } } },\n  { { { 9, 0, 0 }, { 0, 27, 0 } } },\n  { { { 9, 0, 1 }, { 0, 28, 0 } } },\n  { { { 9, 0, 2 }, { 7, 15, 0 } } },\n  { { { 10, 0, 1 }, { 0, 29, 0 } } },\n  { { { 10, 0, 0 }, { 0, 30, 0 } } },\n  { { { 10, 0, 1 }, { 0, 31, 0 } } },\n  { { { 10, 0, 2 }, { 9, 14, 0 } } },\n  { { { 11, 0, 1 }, { 0, 32, 0 } } },\n  { { { 11, 0, 0 }, { 0, 33, 0 } } },\n  { { { 11, 0, 1 }, { 2, 30, 0 } } },\n  { { { 11, 0, 2 }, { 0, 34, 0 } } },\n  { { { 12, 0, 1 }, { 0, 35, 0 } } },\n  { { { 12, 0, 0 }, { 0, 36, 0 } } },\n  { { { 12, 0, 1 }, { 3, 31, 0 } } },\n  { { { 12, 0, 2 }, { 0, 37, 0 } } },\n  { { { 13, 0, 1 }, { 0, 38, 0 } } },\n  { { { 13, 0, 0 }, { 0, 39, 0 } } },\n  { { { 13, 0, 1 }, { 5, 30, 0 } } },\n  { { { 13, 0, 2 }, { 0, 40, 0 } } },\n  { { { 14, 0, 1 }, { 0, 41, 0 } } },\n  { { { 14, 0, 0 }, { 0, 42, 0 } } },\n  { { { 14, 0, 1 }, { 6, 31, 0 } } },\n  { { { 14, 0, 2 }, { 0, 43, 0 } } },\n  { { { 15, 0, 1 }, { 0, 44, 0 } } },\n  { { { 15, 0, 0 }, { 0, 45, 0 } } },\n  { { { 15, 0, 1 }, { 8, 30, 0 } } },\n  { { { 15, 0, 2 }, { 0, 46, 0 } } },\n  { { { 16, 0, 2 }, { 0, 47, 0 } } },\n  { { { 16, 0, 1 }, { 1, 46, 0 } } },\n  { { { 16, 0, 0 }, { 0, 48, 0 } } },\n  { { { 16, 0, 1 }, { 0, 49, 0 } } },\n  { { { 16, 0, 2 }, { 0, 50, 0 } } },\n  { { { 17, 0, 1 }, { 2, 47, 0 } } },\n  { { { 17, 0, 0 }, { 0, 51, 0 } } },\n  { { { 17, 0, 1 }, { 0, 52, 0 } } },\n  { { { 17, 0, 2 }, { 0, 53, 0 } } },\n  { { { 18, 0, 1 }, { 4, 46, 0 } } },\n  { { { 18, 0, 0 }, { 0, 54, 0 } } },\n  { { { 18, 0, 1 }, { 0, 55, 0 } } },\n  { { { 18, 0, 2 }, { 0, 56, 0 } } },\n  { { { 19, 0, 1 }, { 5, 47, 0 } } },\n  { { { 19, 0, 0 }, { 0, 57, 0 } } },\n  { { { 19, 0, 1 }, { 0, 58, 0 } } },\n  { { { 19, 0, 2 }, { 0, 59, 0 } } },\n  { { { 20, 0, 1 }, { 7, 46, 0 } } },\n  { { { 20, 0, 0 }, { 0, 60, 0 } } },\n  { { { 20, 0, 1 }, { 0, 61, 0 } } },\n  { { { 20, 0, 2 }, { 0, 62, 0 } } },\n  { { { 21, 0, 1 }, { 8, 47, 0 } } },\n  { { { 21, 0, 0 }, { 0, 63, 0 } } },\n  { { { 21, 0, 1 }, { 1, 62, 0 } } },\n  { { { 21, 0, 2 }, { 1, 63, 0 } } },\n  { { { 22, 0, 1 }, { 10, 46, 0 } } },\n  { { { 22, 0, 0 }, { 2, 62, 0 } } },\n  { { { 22, 0, 1 }, { 2, 63, 0 } } },\n  { { { 22, 0, 2 }, { 3, 62, 0 } } },\n  { { { 23, 0, 1 }, { 11, 47, 0 } } },\n  { { { 23, 0, 0 }, { 3, 63, 0 } } },\n  { { { 23, 0, 1 }, { 4, 62, 0 } } },\n  { { { 23, 0, 2 }, { 4, 63, 0 } } },\n  { { { 24, 0, 1 }, { 13, 46, 0 } } },\n  { { { 24, 0, 0 }, { 5, 62, 0 } } },\n  { { { 24, 0, 1 }, { 5, 63, 0 } } },\n  { { { 24, 0, 2 }, { 6, 62, 0 } } },\n  { { { 25, 0, 1 }, { 14, 47, 0 } } },\n  { { { 25, 0, 0 }, { 6, 63, 0 } } },\n  { { { 25, 0, 1 }, { 7, 62, 0 } } },\n  { { { 25, 0, 2 }, { 7, 63, 0 } } },\n  { { { 26, 0, 1 }, { 16, 45, 0 } } },\n  { { { 26, 0, 0 }, { 8, 62, 0 } } },\n  { { { 26, 0, 1 }, { 8, 63, 0 } } },\n  { { { 26, 0, 2 }, { 9, 62, 0 } } },\n  { { { 27, 0, 1 }, { 16, 48, 0 } } },\n  { { { 27, 0, 0 }, { 9, 63, 0 } } },\n  { { { 27, 0, 1 }, { 10, 62, 0 } } },\n  { { { 27, 0, 2 }, { 10, 63, 0 } } },\n  { { { 28, 0, 1 }, { 16, 51, 0 } } },\n  { { { 28, 0, 0 }, { 11, 62, 0 } } },\n  { { { 28, 0, 1 }, { 11, 63, 0 } } },\n  { { { 28, 0, 2 }, { 12, 62, 0 } } },\n  { { { 29, 0, 1 }, { 16, 54, 0 } } },\n  { { { 29, 0, 0 }, { 12, 63, 0 } } },\n  { { { 29, 0, 1 }, { 13, 62, 0 } } },\n  { { { 29, 0, 2 }, { 13, 63, 0 } } },\n  { { { 30, 0, 1 }, { 16, 57, 0 } } },\n  { { { 30, 0, 0 }, { 14, 62, 0 } } },\n  { { { 30, 0, 1 }, { 14, 63, 0 } } },\n  { { { 30, 0, 2 }, { 15, 62, 0 } } },\n  { { { 31, 0, 1 }, { 16, 60, 0 } } },\n  { { { 31, 0, 0 }, { 15, 63, 0 } } },\n  { { { 31, 0, 1 }, { 24, 46, 0 } } },\n  { { { 31, 0, 2 }, { 16, 62, 0 } } },\n  { { { 32, 0, 2 }, { 16, 63, 0 } } },\n  { { { 32, 0, 1 }, { 17, 62, 0 } } },\n  { { { 32, 0, 0 }, { 25, 47, 0 } } },\n  { { { 32, 0, 1 }, { 17, 63, 0 } } },\n  { { { 32, 0, 2 }, { 18, 62, 0 } } },\n  { { { 33, 0, 1 }, { 18, 63, 0 } } },\n  { { { 33, 0, 0 }, { 27, 46, 0 } } },\n  { { { 33, 0, 1 }, { 19, 62, 0 } } },\n  { { { 33, 0, 2 }, { 19, 63, 0 } } },\n  { { { 34, 0, 1 }, { 20, 62, 0 } } },\n  { { { 34, 0, 0 }, { 28, 47, 0 } } },\n  { { { 34, 0, 1 }, { 20, 63, 0 } } },\n  { { { 34, 0, 2 }, { 21, 62, 0 } } },\n  { { { 35, 0, 1 }, { 21, 63, 0 } } },\n  { { { 35, 0, 0 }, { 30, 46, 0 } } },\n  { { { 35, 0, 1 }, { 22, 62, 0 } } },\n  { { { 35, 0, 2 }, { 22, 63, 0 } } },\n  { { { 36, 0, 1 }, { 23, 62, 0 } } },\n  { { { 36, 0, 0 }, { 31, 47, 0 } } },\n  { { { 36, 0, 1 }, { 23, 63, 0 } } },\n  { { { 36, 0, 2 }, { 24, 62, 0 } } },\n  { { { 37, 0, 1 }, { 24, 63, 0 } } },\n  { { { 37, 0, 0 }, { 32, 47, 0 } } },\n  { { { 37, 0, 1 }, { 25, 62, 0 } } },\n  { { { 37, 0, 2 }, { 25, 63, 0 } } },\n  { { { 38, 0, 1 }, { 26, 62, 0 } } },\n  { { { 38, 0, 0 }, { 32, 50, 0 } } },\n  { { { 38, 0, 1 }, { 26, 63, 0 } } },\n  { { { 38, 0, 2 }, { 27, 62, 0 } } },\n  { { { 39, 0, 1 }, { 27, 63, 0 } } },\n  { { { 39, 0, 0 }, { 32, 53, 0 } } },\n  { { { 39, 0, 1 }, { 28, 62, 0 } } },\n  { { { 39, 0, 2 }, { 28, 63, 0 } } },\n  { { { 40, 0, 1 }, { 29, 62, 0 } } },\n  { { { 40, 0, 0 }, { 32, 56, 0 } } },\n  { { { 40, 0, 1 }, { 29, 63, 0 } } },\n  { { { 40, 0, 2 }, { 30, 62, 0 } } },\n  { { { 41, 0, 1 }, { 30, 63, 0 } } },\n  { { { 41, 0, 0 }, { 32, 59, 0 } } },\n  { { { 41, 0, 1 }, { 31, 62, 0 } } },\n  { { { 41, 0, 2 }, { 31, 63, 0 } } },\n  { { { 42, 0, 1 }, { 32, 61, 0 } } },\n  { { { 42, 0, 0 }, { 32, 62, 0 } } },\n  { { { 42, 0, 1 }, { 32, 63, 0 } } },\n  { { { 42, 0, 2 }, { 41, 46, 0 } } },\n  { { { 43, 0, 1 }, { 33, 62, 0 } } },\n  { { { 43, 0, 0 }, { 33, 63, 0 } } },\n  { { { 43, 0, 1 }, { 34, 62, 0 } } },\n  { { { 43, 0, 2 }, { 42, 47, 0 } } },\n  { { { 44, 0, 1 }, { 34, 63, 0 } } },\n  { { { 44, 0, 0 }, { 35, 62, 0 } } },\n  { { { 44, 0, 1 }, { 35, 63, 0 } } },\n  { { { 44, 0, 2 }, { 44, 46, 0 } } },\n  { { { 45, 0, 1 }, { 36, 62, 0 } } },\n  { { { 45, 0, 0 }, { 36, 63, 0 } } },\n  { { { 45, 0, 1 }, { 37, 62, 0 } } },\n  { { { 45, 0, 2 }, { 45, 47, 0 } } },\n  { { { 46, 0, 1 }, { 37, 63, 0 } } },\n  { { { 46, 0, 0 }, { 38, 62, 0 } } },\n  { { { 46, 0, 1 }, { 38, 63, 0 } } },\n  { { { 46, 0, 2 }, { 47, 46, 0 } } },\n  { { { 47, 0, 1 }, { 39, 62, 0 } } },\n  { { { 47, 0, 0 }, { 39, 63, 0 } } },\n  { { { 47, 0, 1 }, { 40, 62, 0 } } },\n  { { { 47, 0, 2 }, { 48, 46, 0 } } },\n  { { { 48, 0, 2 }, { 40, 63, 0 } } },\n  { { { 48, 0, 1 }, { 41, 62, 0 } } },\n  { { { 48, 0, 0 }, { 41, 63, 0 } } },\n  { { { 48, 0, 1 }, { 48, 49, 0 } } },\n  { { { 48, 0, 2 }, { 42, 62, 0 } } },\n  { { { 49, 0, 1 }, { 42, 63, 0 } } },\n  { { { 49, 0, 0 }, { 43, 62, 0 } } },\n  { { { 49, 0, 1 }, { 48, 52, 0 } } },\n  { { { 49, 0, 2 }, { 43, 63, 0 } } },\n  { { { 50, 0, 1 }, { 44, 62, 0 } } },\n  { { { 50, 0, 0 }, { 44, 63, 0 } } },\n  { { { 50, 0, 1 }, { 48, 55, 0 } } },\n  { { { 50, 0, 2 }, { 45, 62, 0 } } },\n  { { { 51, 0, 1 }, { 45, 63, 0 } } },\n  { { { 51, 0, 0 }, { 46, 62, 0 } } },\n  { { { 51, 0, 1 }, { 48, 58, 0 } } },\n  { { { 51, 0, 2 }, { 46, 63, 0 } } },\n  { { { 52, 0, 1 }, { 47, 62, 0 } } },\n  { { { 52, 0, 0 }, { 47, 63, 0 } } },\n  { { { 52, 0, 1 }, { 48, 61, 0 } } },\n  { { { 52, 0, 2 }, { 48, 62, 0 } } },\n  { { { 53, 0, 1 }, { 56, 47, 0 } } },\n  { { { 53, 0, 0 }, { 48, 63, 0 } } },\n  { { { 53, 0, 1 }, { 49, 62, 0 } } },\n  { { { 53, 0, 2 }, { 49, 63, 0 } } },\n  { { { 54, 0, 1 }, { 58, 46, 0 } } },\n  { { { 54, 0, 0 }, { 50, 62, 0 } } },\n  { { { 54, 0, 1 }, { 50, 63, 0 } } },\n  { { { 54, 0, 2 }, { 51, 62, 0 } } },\n  { { { 55, 0, 1 }, { 59, 47, 0 } } },\n  { { { 55, 0, 0 }, { 51, 63, 0 } } },\n  { { { 55, 0, 1 }, { 52, 62, 0 } } },\n  { { { 55, 0, 2 }, { 52, 63, 0 } } },\n  { { { 56, 0, 1 }, { 61, 46, 0 } } },\n  { { { 56, 0, 0 }, { 53, 62, 0 } } },\n  { { { 56, 0, 1 }, { 53, 63, 0 } } },\n  { { { 56, 0, 2 }, { 54, 62, 0 } } },\n  { { { 57, 0, 1 }, { 62, 47, 0 } } },\n  { { { 57, 0, 0 }, { 54, 63, 0 } } },\n  { { { 57, 0, 1 }, { 55, 62, 0 } } },\n  { { { 57, 0, 2 }, { 55, 63, 0 } } },\n  { { { 58, 0, 1 }, { 56, 62, 1 } } },\n  { { { 58, 0, 0 }, { 56, 62, 0 } } },\n  { { { 58, 0, 1 }, { 56, 63, 0 } } },\n  { { { 58, 0, 2 }, { 57, 62, 0 } } },\n  { { { 59, 0, 1 }, { 57, 63, 1 } } },\n  { { { 59, 0, 0 }, { 57, 63, 0 } } },\n  { { { 59, 0, 1 }, { 58, 62, 0 } } },\n  { { { 59, 0, 2 }, { 58, 63, 0 } } },\n  { { { 60, 0, 1 }, { 59, 62, 1 } } },\n  { { { 60, 0, 0 }, { 59, 62, 0 } } },\n  { { { 60, 0, 1 }, { 59, 63, 0 } } },\n  { { { 60, 0, 2 }, { 60, 62, 0 } } },\n  { { { 61, 0, 1 }, { 60, 63, 1 } } },\n  { { { 61, 0, 0 }, { 60, 63, 0 } } },\n  { { { 61, 0, 1 }, { 61, 62, 0 } } },\n  { { { 61, 0, 2 }, { 61, 63, 0 } } },\n  { { { 62, 0, 1 }, { 62, 62, 1 } } },\n  { { { 62, 0, 0 }, { 62, 62, 0 } } },\n  { { { 62, 0, 1 }, { 62, 63, 0 } } },\n  { { { 62, 0, 2 }, { 63, 62, 0 } } },\n  { { { 63, 0, 1 }, { 63, 63, 1 } } },\n  { { { 63, 0, 0 }, { 63, 63, 0 } } }\n};\n\nstatic const DDSSingleColourLookup*\n  DDS_LOOKUP[] =\n{\n  DDSLookup_5_4,\n  DDSLookup_6_4,\n  DDSLookup_5_4\n};\n\n/*\n  Macros\n*/\n#define C565_r(x) (((x) & 0xF800) >> 11)\n#define C565_g(x) (((x) & 0x07E0) >> 5)\n#define C565_b(x)  ((x) & 0x001F)\n\n#define C565_red(x)   ( (C565_r(x) << 3 | C565_r(x) >> 2))\n#define C565_green(x) ( (C565_g(x) << 2 | C565_g(x) >> 4))\n#define C565_blue(x)  ( (C565_b(x) << 3 | C565_b(x) >> 2))\n\n#define DIV2(x)  ((x) > 1 ? ((x) >> 1) : 1)\n\n#define FixRange(min, max, steps) \\\nif (min > max) \\\n  min = max; \\\nif (max - min < steps) \\\n  max = MagickMin(min + steps, 255); \\\nif (max - min < steps) \\\n  min = MagickMax(min - steps, 0)\n\n#define Dot(left, right) (left.x*right.x) + (left.y*right.y) + (left.z*right.z)\n\n#define VectorInit(vector, value) vector.x = vector.y = vector.z = vector.w \\\n  = value\n#define VectorInit3(vector, value) vector.x = vector.y = vector.z = value\n\n#define IsBitMask(mask, r, g, b, a) (mask.r_bitmask == r && mask.g_bitmask == \\\n  g && mask.b_bitmask == b && mask.alpha_bitmask == a)\n\n/*\n  Forward declarations\n*/\nstatic MagickBooleanType\n  ConstructOrdering(const size_t,const DDSVector4 *,const DDSVector3,\n    DDSVector4 *,DDSVector4 *,unsigned char *,size_t),\n  ReadDDSInfo(Image *,DDSInfo *),\n  ReadDXT1(Image *,DDSInfo *,ExceptionInfo *),\n  ReadDXT3(Image *,DDSInfo *,ExceptionInfo *),\n  ReadDXT5(Image *,DDSInfo *,ExceptionInfo *),\n  ReadUncompressedRGB(Image *,DDSInfo *,ExceptionInfo *),\n  ReadUncompressedRGBA(Image *,DDSInfo *,ExceptionInfo *),\n  SkipDXTMipmaps(Image *,DDSInfo *,int,ExceptionInfo *),\n  SkipRGBMipmaps(Image *,DDSInfo *,int,ExceptionInfo *),\n  WriteDDSImage(const ImageInfo *,Image *),\n  WriteMipmaps(Image *,const size_t,const size_t,const size_t,\n    const MagickBooleanType,const MagickBooleanType,ExceptionInfo *);\n\nstatic void\n  RemapIndices(const ssize_t *,const unsigned char *,unsigned char *),\n  WriteDDSInfo(Image *,const size_t,const size_t,const size_t),\n  WriteFourCC(Image *,const size_t,const MagickBooleanType,\n    const MagickBooleanType,ExceptionInfo *),\n  WriteImageData(Image *,const size_t,const size_t,const MagickBooleanType,\n    const MagickBooleanType,ExceptionInfo *),\n  WriteIndices(Image *,const DDSVector3,const DDSVector3, unsigned char *),\n  WriteSingleColorFit(Image *,const DDSVector4 *,const ssize_t *),\n  WriteUncompressed(Image *,ExceptionInfo *);\n\nstatic inline void VectorAdd(const DDSVector4 left, const DDSVector4 right,\n  DDSVector4 *destination)\n{\n  destination->x = left.x + right.x;\n  destination->y = left.y + right.y;\n  destination->z = left.z + right.z;\n  destination->w = left.w + right.w;\n}\n\nstatic inline void VectorClamp(DDSVector4 *value)\n{\n  value->x = MagickMin(1.0f,MagickMax(0.0f,value->x));\n  value->y = MagickMin(1.0f,MagickMax(0.0f,value->y));\n  value->z = MagickMin(1.0f,MagickMax(0.0f,value->z));\n  value->w = MagickMin(1.0f,MagickMax(0.0f,value->w));\n}\n\nstatic inline void VectorClamp3(DDSVector3 *value)\n{\n  value->x = MagickMin(1.0f,MagickMax(0.0f,value->x));\n  value->y = MagickMin(1.0f,MagickMax(0.0f,value->y));\n  value->z = MagickMin(1.0f,MagickMax(0.0f,value->z));\n}\n\nstatic inline void VectorCopy43(const DDSVector4 source,\n  DDSVector3 *destination)\n{\n  destination->x = source.x;\n  destination->y = source.y;\n  destination->z = source.z;\n}\n\nstatic inline void VectorCopy44(const DDSVector4 source,\n  DDSVector4 *destination)\n{\n  destination->x = source.x;\n  destination->y = source.y;\n  destination->z = source.z;\n  destination->w = source.w;\n}\n\nstatic inline void VectorNegativeMultiplySubtract(const DDSVector4 a,\n  const DDSVector4 b, const DDSVector4 c, DDSVector4 *destination)\n{\n  destination->x = c.x - (a.x * b.x);\n  destination->y = c.y - (a.y * b.y);\n  destination->z = c.z - (a.z * b.z);\n  destination->w = c.w - (a.w * b.w);\n}\n\nstatic inline void VectorMultiply(const DDSVector4 left,\n  const DDSVector4 right, DDSVector4 *destination)\n{\n  destination->x = left.x * right.x;\n  destination->y = left.y * right.y;\n  destination->z = left.z * right.z;\n  destination->w = left.w * right.w;\n}\n\nstatic inline void VectorMultiply3(const DDSVector3 left,\n  const DDSVector3 right, DDSVector3 *destination)\n{\n  destination->x = left.x * right.x;\n  destination->y = left.y * right.y;\n  destination->z = left.z * right.z;\n}\n\nstatic inline void VectorMultiplyAdd(const DDSVector4 a, const DDSVector4 b,\n  const DDSVector4 c, DDSVector4 *destination)\n{\n  destination->x = (a.x * b.x) + c.x;\n  destination->y = (a.y * b.y) + c.y;\n  destination->z = (a.z * b.z) + c.z;\n  destination->w = (a.w * b.w) + c.w;\n}\n\nstatic inline void VectorMultiplyAdd3(const DDSVector3 a, const DDSVector3 b,\n  const DDSVector3 c, DDSVector3 *destination)\n{\n  destination->x = (a.x * b.x) + c.x;\n  destination->y = (a.y * b.y) + c.y;\n  destination->z = (a.z * b.z) + c.z;\n}\n\nstatic inline void VectorReciprocal(const DDSVector4 value,\n  DDSVector4 *destination)\n{\n  destination->x = 1.0f / value.x;\n  destination->y = 1.0f / value.y;\n  destination->z = 1.0f / value.z;\n  destination->w = 1.0f / value.w;\n}\n\nstatic inline void VectorSubtract(const DDSVector4 left,\n  const DDSVector4 right, DDSVector4 *destination)\n{\n  destination->x = left.x - right.x;\n  destination->y = left.y - right.y;\n  destination->z = left.z - right.z;\n  destination->w = left.w - right.w;\n}\n\nstatic inline void VectorSubtract3(const DDSVector3 left,\n  const DDSVector3 right, DDSVector3 *destination)\n{\n  destination->x = left.x - right.x;\n  destination->y = left.y - right.y;\n  destination->z = left.z - right.z;\n}\n\nstatic inline void VectorTruncate(DDSVector4 *value)\n{\n  value->x = value->x > 0.0f ? floor(value->x) : ceil(value->x);\n  value->y = value->y > 0.0f ? floor(value->y) : ceil(value->y);\n  value->z = value->z > 0.0f ? floor(value->z) : ceil(value->z);\n  value->w = value->w > 0.0f ? floor(value->w) : ceil(value->w);\n}\n\nstatic inline void VectorTruncate3(DDSVector3 *value)\n{\n  value->x = value->x > 0.0f ? floor(value->x) : ceil(value->x);\n  value->y = value->y > 0.0f ? floor(value->y) : ceil(value->y);\n  value->z = value->z > 0.0f ? floor(value->z) : ceil(value->z);\n}\n\nstatic void CalculateColors(unsigned short c0, unsigned short c1,\n  DDSColors *c, MagickBooleanType ignoreAlpha)\n{\n  c->a[0] = c->a[1] = c->a[2] = c->a[3] = 0;\n\n  c->r[0] = (unsigned char) C565_red(c0);\n  c->g[0] = (unsigned char) C565_green(c0);\n  c->b[0] = (unsigned char) C565_blue(c0);\n\n  c->r[1] = (unsigned char) C565_red(c1);\n  c->g[1] = (unsigned char) C565_green(c1);\n  c->b[1] = (unsigned char) C565_blue(c1);\n\n  if (ignoreAlpha != MagickFalse || c0 > c1)\n    {\n      c->r[2] = (unsigned char) ((2 * c->r[0] + c->r[1]) / 3);\n      c->g[2] = (unsigned char) ((2 * c->g[0] + c->g[1]) / 3);\n      c->b[2] = (unsigned char) ((2 * c->b[0] + c->b[1]) / 3);\n\n      c->r[3] = (unsigned char) ((c->r[0] + 2 * c->r[1]) / 3);\n      c->g[3] = (unsigned char) ((c->g[0] + 2 * c->g[1]) / 3);\n      c->b[3] = (unsigned char) ((c->b[0] + 2 * c->b[1]) / 3);\n    }\n  else\n    {\n      c->r[2] = (unsigned char) ((c->r[0] + c->r[1]) / 2);\n      c->g[2] = (unsigned char) ((c->g[0] + c->g[1]) / 2);\n      c->b[2] = (unsigned char) ((c->b[0] + c->b[1]) / 2);\n\n      c->r[3] = c->g[3] = c->b[3] = 0;\n      c->a[3] = 255;\n    }\n}\n\nstatic size_t CompressAlpha(const size_t min, const size_t max,\n  const size_t steps, const ssize_t *alphas, unsigned char* indices)\n{\n  unsigned char\n    codes[8];\n\n  register ssize_t\n    i;\n\n  size_t\n    error,\n    index,\n    j,\n    least,\n    value;\n\n  codes[0] = (unsigned char) min;\n  codes[1] = (unsigned char) max;\n  codes[6] = 0;\n  codes[7] = 255;\n\n  for (i=1; i < (ssize_t) steps; i++)\n    codes[i+1] = (unsigned char) (((steps-i)*min + i*max) / steps);\n\n  error = 0;\n  for (i=0; i<16; i++)\n  {\n    if (alphas[i] == -1)\n      {\n        indices[i] = 0;\n        continue;\n      }\n\n    value = alphas[i];\n    least = SIZE_MAX;\n    index = 0;\n    for (j=0; j<8; j++)\n    {\n      size_t\n        dist;\n\n      dist = value - (size_t)codes[j];\n      dist *= dist;\n\n      if (dist < least)\n        {\n          least = dist;\n          index = j;\n        }\n    }\n\n    indices[i] = (unsigned char)index;\n    error += least;\n  }\n\n  return error;\n}\n\nstatic void CompressClusterFit(const size_t count,\n  const DDSVector4 *points, const ssize_t *map, const DDSVector3 principle,\n  const DDSVector4 metric, DDSVector3 *start, DDSVector3 *end,\n  unsigned char *indices)\n{\n  DDSVector3\n    axis;\n\n  DDSVector4\n    grid,\n    gridrcp,\n    half,\n    onethird_onethird2,\n    pointsWeights[16],\n    two,\n    twonineths,\n    twothirds_twothirds2,\n    xSumwSum;\n\n  float\n    bestError = 1e+37f;\n\n  size_t\n    bestIteration = 0,\n    besti = 0,\n    bestj = 0,\n    bestk = 0,\n    iterationIndex;\n\n  ssize_t\n    i;\n\n  unsigned char\n    *o,\n    order[128],\n    unordered[16];\n\n  VectorInit(half,0.5f);\n  VectorInit(two,2.0f);\n\n  VectorInit(onethird_onethird2,1.0f/3.0f);\n  onethird_onethird2.w = 1.0f/9.0f;\n  VectorInit(twothirds_twothirds2,2.0f/3.0f);\n  twothirds_twothirds2.w = 4.0f/9.0f;\n  VectorInit(twonineths,2.0f/9.0f);\n\n  grid.x = 31.0f;\n  grid.y = 63.0f;\n  grid.z = 31.0f;\n  grid.w = 0.0f;\n\n  gridrcp.x = 1.0f/31.0f;\n  gridrcp.y = 1.0f/63.0f;\n  gridrcp.z = 1.0f/31.0f;\n  gridrcp.w = 0.0f;\n\n  xSumwSum.x = 0.0f;\n  xSumwSum.y = 0.0f;\n  xSumwSum.z = 0.0f;\n  xSumwSum.w = 0.0f;\n\n  ConstructOrdering(count,points,principle,pointsWeights,&xSumwSum,order,0);\n\n  for (iterationIndex = 0;;)\n  {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(dynamic,1) \\\n    num_threads(GetMagickResourceLimit(ThreadResource))\n#endif\n    for (i=0; i < (ssize_t) count; i++)\n    {\n      DDSVector4\n        part0,\n        part1,\n        part2;\n\n      size_t\n        ii,\n        j,\n        k,\n        kmin;\n\n      VectorInit(part0,0.0f);\n      for(ii=0; ii < (size_t) i; ii++)\n        VectorAdd(pointsWeights[ii],part0,&part0);\n\n      VectorInit(part1,0.0f);\n      for (j=(size_t) i;;)\n      {\n        if (j == 0)\n          {\n            VectorCopy44(pointsWeights[0],&part2);\n            kmin = 1;\n          }\n          else\n          {\n            VectorInit(part2,0.0f);\n            kmin = j;\n          }\n\n        for (k=kmin;;)\n        {\n          DDSVector4\n            a,\n            alpha2_sum,\n            alphax_sum,\n            alphabeta_sum,\n            b,\n            beta2_sum,\n            betax_sum,\n            e1,\n            e2,\n            factor,\n            part3;\n\n          float\n            error;\n\n          VectorSubtract(xSumwSum,part2,&part3);\n          VectorSubtract(part3,part1,&part3);\n          VectorSubtract(part3,part0,&part3);\n\n          VectorMultiplyAdd(part1,twothirds_twothirds2,part0,&alphax_sum);\n          VectorMultiplyAdd(part2,onethird_onethird2,alphax_sum,&alphax_sum);\n          VectorInit(alpha2_sum,alphax_sum.w);\n\n          VectorMultiplyAdd(part2,twothirds_twothirds2,part3,&betax_sum);\n          VectorMultiplyAdd(part1,onethird_onethird2,betax_sum,&betax_sum);\n          VectorInit(beta2_sum,betax_sum.w);\n\n          VectorAdd(part1,part2,&alphabeta_sum);\n          VectorInit(alphabeta_sum,alphabeta_sum.w);\n          VectorMultiply(twonineths,alphabeta_sum,&alphabeta_sum);\n\n          VectorMultiply(alpha2_sum,beta2_sum,&factor);\n          VectorNegativeMultiplySubtract(alphabeta_sum,alphabeta_sum,factor,\n            &factor);\n          VectorReciprocal(factor,&factor);\n\n          VectorMultiply(alphax_sum,beta2_sum,&a);\n          VectorNegativeMultiplySubtract(betax_sum,alphabeta_sum,a,&a);\n          VectorMultiply(a,factor,&a);\n\n          VectorMultiply(betax_sum,alpha2_sum,&b);\n          VectorNegativeMultiplySubtract(alphax_sum,alphabeta_sum,b,&b);\n          VectorMultiply(b,factor,&b);\n\n          VectorClamp(&a);\n          VectorMultiplyAdd(grid,a,half,&a);\n          VectorTruncate(&a);\n          VectorMultiply(a,gridrcp,&a);\n\n          VectorClamp(&b);\n          VectorMultiplyAdd(grid,b,half,&b);\n          VectorTruncate(&b);\n          VectorMultiply(b,gridrcp,&b);\n\n          VectorMultiply(b,b,&e1);\n          VectorMultiply(e1,beta2_sum,&e1);\n          VectorMultiply(a,a,&e2);\n          VectorMultiplyAdd(e2,alpha2_sum,e1,&e1);\n\n          VectorMultiply(a,b,&e2);\n          VectorMultiply(e2,alphabeta_sum,&e2);\n          VectorNegativeMultiplySubtract(a,alphax_sum,e2,&e2);\n          VectorNegativeMultiplySubtract(b,betax_sum,e2,&e2);\n          VectorMultiplyAdd(two,e2,e1,&e2);\n          VectorMultiply(e2,metric,&e2);\n\n          error = e2.x + e2.y + e2.z;\n\n          if (error < bestError)\n            {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp critical (DDS_CompressClusterFit)\n#endif\n              {\n                if (error < bestError)\n                  {\n                    VectorCopy43(a,start);\n                    VectorCopy43(b,end);\n                    bestError = error;\n                    besti = i;\n                    bestj = j;\n                    bestk = k;\n                    bestIteration = iterationIndex;\n                  }\n              }\n            }\n\n          if (k == count)\n            break;\n\n          VectorAdd(pointsWeights[k],part2,&part2);\n          k++;\n        }\n\n        if (j == count)\n          break;\n\n        VectorAdd(pointsWeights[j],part1,&part1);\n        j++;\n      }\n    }\n\n    if (bestIteration != iterationIndex)\n      break;\n\n    iterationIndex++;\n    if (iterationIndex == 8)\n      break;\n\n    VectorSubtract3(*end,*start,&axis);\n    if (ConstructOrdering(count,points,axis,pointsWeights,&xSumwSum,order,\n      iterationIndex) == MagickFalse)\n      break;\n  }\n\n  o = order + (16*bestIteration);\n\n  for (i=0; i < (ssize_t) besti; i++)\n    unordered[o[i]] = 0;\n  for (i=besti; i < (ssize_t) bestj; i++)\n    unordered[o[i]] = 2;\n  for (i=bestj; i < (ssize_t) bestk; i++)\n    unordered[o[i]] = 3;\n  for (i=bestk; i < (ssize_t) count; i++)\n    unordered[o[i]] = 1;\n\n  RemapIndices(map,unordered,indices);\n}\n\nstatic void CompressRangeFit(const size_t count,\n  const DDSVector4 *points, const ssize_t *map, const DDSVector3 principle,\n  const DDSVector4 metric, DDSVector3 *start, DDSVector3 *end,\n  unsigned char *indices)\n{\n  float\n    d,\n    bestDist,\n    max,\n    min,\n    val;\n\n  DDSVector3\n    codes[4],\n    grid,\n    gridrcp,\n    half,\n    dist;\n\n  register ssize_t\n    i;\n\n  size_t\n    bestj,\n    j;\n\n  unsigned char\n    closest[16];\n\n  VectorInit3(half,0.5f);\n\n  grid.x = 31.0f;\n  grid.y = 63.0f;\n  grid.z = 31.0f;\n\n  gridrcp.x = 1.0f/31.0f;\n  gridrcp.y = 1.0f/63.0f;\n  gridrcp.z = 1.0f/31.0f;\n\n  if (count > 0)\n    {\n      VectorCopy43(points[0],start);\n      VectorCopy43(points[0],end);\n\n      min = max = Dot(points[0],principle);\n      for (i=1; i < (ssize_t) count; i++)\n      {\n        val = Dot(points[i],principle);\n        if (val < min)\n        {\n          VectorCopy43(points[i],start);\n          min = val;\n        }\n        else if (val > max)\n        {\n          VectorCopy43(points[i],end);\n          max = val;\n        }\n      }\n    }\n\n  VectorClamp3(start);\n  VectorMultiplyAdd3(grid,*start,half,start);\n  VectorTruncate3(start);\n  VectorMultiply3(*start,gridrcp,start);\n\n  VectorClamp3(end);\n  VectorMultiplyAdd3(grid,*end,half,end);\n  VectorTruncate3(end);\n  VectorMultiply3(*end,gridrcp,end);\n\n  codes[0] = *start;\n  codes[1] = *end;\n  codes[2].x = (start->x * (2.0f/3.0f)) + (end->x * (1.0f/3.0f));\n  codes[2].y = (start->y * (2.0f/3.0f)) + (end->y * (1.0f/3.0f));\n  codes[2].z = (start->z * (2.0f/3.0f)) + (end->z * (1.0f/3.0f));\n  codes[3].x = (start->x * (1.0f/3.0f)) + (end->x * (2.0f/3.0f));\n  codes[3].y = (start->y * (1.0f/3.0f)) + (end->y * (2.0f/3.0f));\n  codes[3].z = (start->z * (1.0f/3.0f)) + (end->z * (2.0f/3.0f));\n\n  for (i=0; i < (ssize_t) count; i++)\n  {\n    bestDist = 1e+37f;\n    bestj = 0;\n    for (j=0; j < 4; j++)\n    {\n      dist.x = (points[i].x - codes[j].x) * metric.x;\n      dist.y = (points[i].y - codes[j].y) * metric.y;\n      dist.z = (points[i].z - codes[j].z) * metric.z;\n\n      d = Dot(dist,dist);\n      if (d < bestDist)\n        {\n          bestDist = d;\n          bestj = j;\n        }\n    }\n\n    closest[i] = (unsigned char) bestj;\n  }\n\n  RemapIndices(map, closest, indices);\n}\n\nstatic void ComputeEndPoints(const DDSSingleColourLookup *lookup[],\n  const unsigned char *color, DDSVector3 *start, DDSVector3 *end,\n  unsigned char *index)\n{\n  register ssize_t\n    i;\n\n  size_t\n    c,\n    maxError = SIZE_MAX;\n\n  for (i=0; i < 2; i++)\n  {\n    const DDSSourceBlock*\n      sources[3];\n\n      size_t\n        error = 0;\n\n    for (c=0; c < 3; c++)\n    {\n      sources[c] = &lookup[c][color[c]].sources[i];\n      error += ((size_t) sources[c]->error) * ((size_t) sources[c]->error);\n    }\n\n    if (error > maxError)\n      continue;\n\n    start->x = (float) sources[0]->start / 31.0f;\n    start->y = (float) sources[1]->start / 63.0f;\n    start->z = (float) sources[2]->start / 31.0f;\n\n    end->x = (float) sources[0]->end / 31.0f;\n    end->y = (float) sources[1]->end / 63.0f;\n    end->z = (float) sources[2]->end / 31.0f;\n\n    *index = (unsigned char) (2*i);\n    maxError = error;\n  }\n}\n\nstatic void ComputePrincipleComponent(const float *covariance,\n  DDSVector3 *principle)\n{\n  DDSVector4\n    row0,\n    row1,\n    row2,\n    v;\n\n  register ssize_t\n    i;\n\n  row0.x = covariance[0];\n  row0.y = covariance[1];\n  row0.z = covariance[2];\n  row0.w = 0.0f;\n\n  row1.x = covariance[1];\n  row1.y = covariance[3];\n  row1.z = covariance[4];\n  row1.w = 0.0f;\n\n  row2.x = covariance[2];\n  row2.y = covariance[4];\n  row2.z = covariance[5];\n  row2.w = 0.0f;\n\n  VectorInit(v,1.0f);\n\n  for (i=0; i < 8; i++)\n  {\n    DDSVector4\n      w;\n\n    float\n      a;\n\n    w.x = row0.x * v.x;\n    w.y = row0.y * v.x;\n    w.z = row0.z * v.x;\n    w.w = row0.w * v.x;\n\n    w.x = (row1.x * v.y) + w.x;\n    w.y = (row1.y * v.y) + w.y;\n    w.z = (row1.z * v.y) + w.z;\n    w.w = (row1.w * v.y) + w.w;\n\n    w.x = (row2.x * v.z) + w.x;\n    w.y = (row2.y * v.z) + w.y;\n    w.z = (row2.z * v.z) + w.z;\n    w.w = (row2.w * v.z) + w.w;\n\n    a = 1.0f / MagickMax(w.x,MagickMax(w.y,w.z));\n\n    v.x = w.x * a;\n    v.y = w.y * a;\n    v.z = w.z * a;\n    v.w = w.w * a;\n  }\n\n  VectorCopy43(v,principle);\n}\n\nstatic void ComputeWeightedCovariance(const size_t count,\n  const DDSVector4 *points, float *covariance)\n{\n  DDSVector3\n    centroid;\n\n  float\n    total;\n\n  size_t\n    i;\n\n  total = 0.0f;\n  VectorInit3(centroid,0.0f);\n\n  for (i=0; i < count; i++)\n  {\n    total += points[i].w;\n    centroid.x += (points[i].x * points[i].w);\n    centroid.y += (points[i].y * points[i].w);\n    centroid.z += (points[i].z * points[i].w);\n  }\n\n  if( total > 1.192092896e-07F)\n    {\n      centroid.x /= total;\n      centroid.y /= total;\n      centroid.z /= total;\n    }\n\n  for (i=0; i < 6; i++)\n    covariance[i] = 0.0f;\n\n  for (i = 0; i < count; i++)\n  {\n    DDSVector3\n      a,\n      b;\n\n    a.x = points[i].x - centroid.x;\n    a.y = points[i].y - centroid.y;\n    a.z = points[i].z - centroid.z;\n\n    b.x = points[i].w * a.x;\n    b.y = points[i].w * a.y;\n    b.z = points[i].w * a.z;\n\n    covariance[0] += a.x*b.x;\n    covariance[1] += a.x*b.y;\n    covariance[2] += a.x*b.z;\n    covariance[3] += a.y*b.y;\n    covariance[4] += a.y*b.z;\n    covariance[5] += a.z*b.z;\n  }\n}\n\nstatic MagickBooleanType ConstructOrdering(const size_t count,\n  const DDSVector4 *points, const DDSVector3 axis, DDSVector4 *pointsWeights,\n  DDSVector4 *xSumwSum, unsigned char *order, size_t iteration)\n{\n  float\n     dps[16],\n     f;\n\n  register ssize_t\n    i;\n\n  size_t\n    j;\n\n  unsigned char\n    c,\n    *o,\n    *p;\n\n  o = order + (16*iteration);\n\n  for (i=0; i < (ssize_t) count; i++)\n  {\n    dps[i] = Dot(points[i],axis);\n    o[i] = (unsigned char)i;\n  }\n\n  for (i=0; i < (ssize_t) count; i++)\n  {\n    for (j=i; j > 0 && dps[j] < dps[j - 1]; j--)\n    {\n      f = dps[j];\n      dps[j] = dps[j - 1];\n      dps[j - 1] = f;\n\n      c = o[j];\n      o[j] = o[j - 1];\n      o[j - 1] = c;\n    }\n  }\n\n  for (i=0; i < (ssize_t) iteration; i++)\n  {\n    MagickBooleanType\n      same;\n\n    p = order + (16*i);\n    same = MagickTrue;\n\n    for (j=0; j < count; j++)\n    {\n      if (o[j] != p[j])\n        {\n          same = MagickFalse;\n          break;\n        }\n    }\n\n    if (same != MagickFalse)\n      return MagickFalse;\n  }\n\n  xSumwSum->x = 0;\n  xSumwSum->y = 0;\n  xSumwSum->z = 0;\n  xSumwSum->w = 0;\n\n  for (i=0; i < (ssize_t) count; i++)\n  {\n    DDSVector4\n      v;\n\n    j = (size_t) o[i];\n\n    v.x = points[j].w * points[j].x;\n    v.y = points[j].w * points[j].y;\n    v.z = points[j].w * points[j].z;\n    v.w = points[j].w * 1.0f;\n\n    VectorCopy44(v,&pointsWeights[i]);\n    VectorAdd(*xSumwSum,v,xSumwSum);\n  }\n\n  return MagickTrue;\n}\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s D D S                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsDDS() returns MagickTrue if the image format type, identified by the\n%  magick string, is DDS.\n%\n%  The format of the IsDDS method is:\n%\n%      MagickBooleanType IsDDS(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsDDS(const unsigned char *magick, const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (LocaleNCompare((char *) magick,\"DDS \", 4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d D D S I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadDDSImage() reads a DirectDraw Surface image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadDDSImage method is:\n%\n%      Image *ReadDDSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: The image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic Image *ReadDDSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status,\n    cubemap = MagickFalse,\n    volume = MagickFalse,\n    matte;\n\n  CompressionType\n    compression;\n\n  DDSInfo\n    dds_info;\n\n  DDSDecoder\n    *decoder;\n\n  size_t\n    n,\n    num_images;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n\n  /*\n    Initialize image structure.\n  */\n  if (ReadDDSInfo(image, &dds_info) != MagickTrue) {\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n\n  if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP)\n    cubemap = MagickTrue;\n\n  if (dds_info.ddscaps2 & DDSCAPS2_VOLUME && dds_info.depth > 0)\n    volume = MagickTrue;\n\n  (void) SeekBlob(image, 128, SEEK_SET);\n\n  /*\n    Determine pixel format\n  */\n  if (dds_info.pixelformat.flags & DDPF_RGB)\n    {\n      compression = NoCompression;\n      if (dds_info.pixelformat.flags & DDPF_ALPHAPIXELS)\n        {\n          matte = MagickTrue;\n          decoder = ReadUncompressedRGBA;\n        }\n      else\n        {\n          matte = MagickTrue;\n          decoder = ReadUncompressedRGB;\n        }\n    }\n  else if (dds_info.pixelformat.flags & DDPF_LUMINANCE)\n   {\n      compression = NoCompression;\n      if (dds_info.pixelformat.flags & DDPF_ALPHAPIXELS)\n        {\n          /* Not sure how to handle this */\n          ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");\n        }\n      else\n        {\n          matte = MagickFalse;\n          decoder = ReadUncompressedRGB;\n        }\n    }\n  else if (dds_info.pixelformat.flags & DDPF_FOURCC)\n    {\n      switch (dds_info.pixelformat.fourcc)\n      {\n        case FOURCC_DXT1:\n        {\n          matte = MagickFalse;\n          compression = DXT1Compression;\n          decoder = ReadDXT1;\n          break;\n        }\n        case FOURCC_DXT3:\n        {\n          matte = MagickTrue;\n          compression = DXT3Compression;\n          decoder = ReadDXT3;\n          break;\n        }\n        case FOURCC_DXT5:\n        {\n          matte = MagickTrue;\n          compression = DXT5Compression;\n          decoder = ReadDXT5;\n          break;\n        }\n        default:\n        {\n          /* Unknown FOURCC */\n          ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");\n        }\n      }\n    }\n  else\n    {\n      /* Neither compressed nor uncompressed... thus unsupported */\n      ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");\n    }\n\n  num_images = 1;\n  if (cubemap)\n    {\n      /*\n        Determine number of faces defined in the cubemap\n      */\n      num_images = 0;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ) num_images++;\n    }\n\n  if (volume)\n    num_images = dds_info.depth;\n\n  for (n = 0; n < num_images; n++)\n  {\n    if (n != 0)\n      {\n        if (EOFBlob(image) != MagickFalse)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        /* Start a new image */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          return(DestroyImageList(image));\n        image=SyncNextImageInList(image);\n      }\n \n    image->matte = matte;\n    image->compression = compression;\n    image->columns = dds_info.width;\n    image->rows = dds_info.height;\n    image->storage_class = DirectClass;\n    image->endian = LSBEndian;\n    image->depth = 8;\n    if (image_info->ping != MagickFalse)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n\n    if ((decoder)(image, &dds_info, exception) != MagickTrue)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n  }\n\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\nstatic MagickBooleanType ReadDDSInfo(Image *image, DDSInfo *dds_info)\n{\n  size_t\n    hdr_size,\n    required;\n\n  /* Seek to start of header */\n  (void) SeekBlob(image, 4, SEEK_SET);\n\n  /* Check header field */\n  hdr_size = ReadBlobLSBLong(image);\n  if (hdr_size != 124)\n    return MagickFalse;\n\n  /* Fill in DDS info struct */\n  dds_info->flags = ReadBlobLSBLong(image);\n\n  /* Check required flags */\n  required=(size_t) (DDSD_WIDTH | DDSD_HEIGHT | DDSD_PIXELFORMAT);\n  if ((dds_info->flags & required) != required)\n    return MagickFalse;\n\n  dds_info->height = ReadBlobLSBLong(image);\n  dds_info->width = ReadBlobLSBLong(image);\n  dds_info->pitchOrLinearSize = ReadBlobLSBLong(image);\n  dds_info->depth = ReadBlobLSBLong(image);\n  dds_info->mipmapcount = ReadBlobLSBLong(image);\n\n  (void) SeekBlob(image, 44, SEEK_CUR);   /* reserved region of 11 DWORDs */\n\n  /* Read pixel format structure */\n  hdr_size = ReadBlobLSBLong(image);\n  if (hdr_size != 32)\n    return MagickFalse;\n\n  dds_info->pixelformat.flags = ReadBlobLSBLong(image);\n  dds_info->pixelformat.fourcc = ReadBlobLSBLong(image);\n  dds_info->pixelformat.rgb_bitcount = ReadBlobLSBLong(image);\n  dds_info->pixelformat.r_bitmask = ReadBlobLSBLong(image);\n  dds_info->pixelformat.g_bitmask = ReadBlobLSBLong(image);\n  dds_info->pixelformat.b_bitmask = ReadBlobLSBLong(image);\n  dds_info->pixelformat.alpha_bitmask = ReadBlobLSBLong(image);\n\n  dds_info->ddscaps1 = ReadBlobLSBLong(image);\n  dds_info->ddscaps2 = ReadBlobLSBLong(image);\n  (void) SeekBlob(image, 12, SEEK_CUR); /* 3 reserved DWORDs */\n\n  return MagickTrue;\n}\n\nstatic MagickBooleanType ReadDXT1(Image *image, DDSInfo *dds_info,\n  ExceptionInfo *exception)\n{\n  DDSColors\n    colors;\n\n  PixelPacket\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    bits;\n\n  ssize_t\n    j,\n    y;\n\n  unsigned char\n    code;\n\n  unsigned short\n    c0,\n    c1;\n\n  for (y = 0; y < (ssize_t) dds_info->height; y += 4)\n  {\n    for (x = 0; x < (ssize_t) dds_info->width; x += 4)\n    {\n      /* Get 4x4 patch of pixels to write on */\n      q = QueueAuthenticPixels(image, x, y, MagickMin(4, dds_info->width - x),\n        MagickMin(4, dds_info->height - y),exception);\n\n      if (q == (PixelPacket *) NULL)\n        return MagickFalse;\n\n      /* Read 8 bytes of data from the image */\n      c0 = ReadBlobLSBShort(image);\n      c1 = ReadBlobLSBShort(image);\n      bits = ReadBlobLSBLong(image);\n\n      CalculateColors(c0, c1, &colors, MagickFalse);\n\n      /* Write the pixels */\n      for (j = 0; j < 4; j++)\n      {\n        for (i = 0; i < 4; i++)\n        {\n          if ((x + i) < (ssize_t) dds_info->width && (y + j) < (ssize_t) dds_info->height)\n            {\n              code = (unsigned char) ((bits >> ((j*4+i)*2)) & 0x3);\n              SetPixelRed(q,ScaleCharToQuantum(colors.r[code]));\n              SetPixelGreen(q,ScaleCharToQuantum(colors.g[code]));\n              SetPixelBlue(q,ScaleCharToQuantum(colors.b[code]));\n              SetPixelOpacity(q,ScaleCharToQuantum(colors.a[code]));\n              if (colors.a[code] && image->matte == MagickFalse)\n                /* Correct matte */\n                image->matte = MagickTrue;\n              q++;\n            }\n        }\n      }\n\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        return MagickFalse;\n    }\n  }\n\n  return(SkipDXTMipmaps(image,dds_info,8,exception));\n}\n\nstatic MagickBooleanType ReadDXT3(Image *image, DDSInfo *dds_info,\n  ExceptionInfo *exception)\n{\n  DDSColors\n    colors;\n\n  ssize_t\n    j,\n    y;\n\n  PixelPacket\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  unsigned char\n    alpha;\n\n  size_t\n    a0,\n    a1,\n    bits,\n    code;\n\n  unsigned short\n    c0,\n    c1;\n\n  for (y = 0; y < (ssize_t) dds_info->height; y += 4)\n  {\n    for (x = 0; x < (ssize_t) dds_info->width; x += 4)\n    {\n      /* Get 4x4 patch of pixels to write on */\n      q = QueueAuthenticPixels(image, x, y, MagickMin(4, dds_info->width - x),\n                         MagickMin(4, dds_info->height - y),exception);\n\n      if (q == (PixelPacket *) NULL)\n        return MagickFalse;\n\n      /* Read alpha values (8 bytes) */\n      a0 = ReadBlobLSBLong(image);\n      a1 = ReadBlobLSBLong(image);\n\n      /* Read 8 bytes of data from the image */\n      c0 = ReadBlobLSBShort(image);\n      c1 = ReadBlobLSBShort(image);\n      bits = ReadBlobLSBLong(image);\n\n      CalculateColors(c0, c1, &colors, MagickTrue);\n\n      /* Write the pixels */\n      for (j = 0; j < 4; j++)\n      {\n        for (i = 0; i < 4; i++)\n        {\n          if ((x + i) < (ssize_t) dds_info->width && (y + j) < (ssize_t) dds_info->height)\n            {\n              code = (bits >> ((4*j+i)*2)) & 0x3;\n              SetPixelRed(q,ScaleCharToQuantum(colors.r[code]));\n              SetPixelGreen(q,ScaleCharToQuantum(colors.g[code]));\n              SetPixelBlue(q,ScaleCharToQuantum(colors.b[code]));\n              /*\n                Extract alpha value: multiply 0..15 by 17 to get range 0..255\n              */\n              if (j < 2)\n                alpha = 17U * (unsigned char) ((a0 >> (4*(4*j+i))) & 0xf);\n              else\n                alpha = 17U * (unsigned char) ((a1 >> (4*(4*(j-2)+i))) & 0xf);\n              SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n                alpha));\n              q++;\n            }\n        }\n      }\n\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        return MagickFalse;\n    }\n  }\n\n  return(SkipDXTMipmaps(image,dds_info,16,exception));\n}\n\nstatic MagickBooleanType ReadDXT5(Image *image, DDSInfo *dds_info,\n  ExceptionInfo *exception)\n{\n  DDSColors\n    colors;\n\n  ssize_t\n    j,\n    y;\n\n  MagickSizeType\n    alpha_bits;\n\n  PixelPacket\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  unsigned char\n    a0,\n    a1;\n\n  size_t\n    alpha,\n    bits,\n    code,\n    alpha_code;\n\n  unsigned short\n    c0,\n    c1;\n\n  for (y = 0; y < (ssize_t) dds_info->height; y += 4)\n  {\n    for (x = 0; x < (ssize_t) dds_info->width; x += 4)\n    {\n      /* Get 4x4 patch of pixels to write on */\n      q = QueueAuthenticPixels(image, x, y, MagickMin(4, dds_info->width - x),\n                         MagickMin(4, dds_info->height - y),exception);\n\n      if (q == (PixelPacket *) NULL)\n        return MagickFalse;\n\n      /* Read alpha values (8 bytes) */\n      a0 = (unsigned char) ReadBlobByte(image);\n      a1 = (unsigned char) ReadBlobByte(image);\n\n      alpha_bits = (MagickSizeType)ReadBlobLSBLong(image);\n      alpha_bits = alpha_bits | ((MagickSizeType)ReadBlobLSBShort(image) << 32);\n\n      /* Read 8 bytes of data from the image */\n      c0 = ReadBlobLSBShort(image);\n      c1 = ReadBlobLSBShort(image);\n      bits = ReadBlobLSBLong(image);\n\n      CalculateColors(c0, c1, &colors, MagickTrue);\n\n      /* Write the pixels */\n      for (j = 0; j < 4; j++)\n      {\n        for (i = 0; i < 4; i++)\n        {\n          if ((x + i) < (ssize_t) dds_info->width && (y + j) < (ssize_t) dds_info->height)\n            {\n              code = (bits >> ((4*j+i)*2)) & 0x3;\n              SetPixelRed(q,ScaleCharToQuantum(colors.r[code]));\n              SetPixelGreen(q,ScaleCharToQuantum(colors.g[code]));\n              SetPixelBlue(q,ScaleCharToQuantum(colors.b[code]));\n              /* Extract alpha value */\n              alpha_code = (size_t) (alpha_bits >> (3*(4*j+i))) & 0x7;\n              if (alpha_code == 0)\n                alpha = a0;\n              else if (alpha_code == 1)\n                alpha = a1;\n              else if (a0 > a1)\n                alpha = ((8-alpha_code) * a0 + (alpha_code-1) * a1) / 7;\n              else if (alpha_code == 6)\n                alpha = 0;\n              else if (alpha_code == 7)\n                alpha = 255;\n              else\n                alpha = (((6-alpha_code) * a0 + (alpha_code-1) * a1) / 5);\n              SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n                alpha));\n              q++;\n            }\n        }\n      }\n\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        return MagickFalse;\n    }\n  }\n\n  return(SkipDXTMipmaps(image,dds_info,16,exception));\n}\n\nstatic MagickBooleanType ReadUncompressedRGB(Image *image, DDSInfo *dds_info,\n  ExceptionInfo *exception)\n{\n  PixelPacket\n    *q;\n\n  ssize_t\n    x, y;\n\n  unsigned short\n    color;\n\n  if (dds_info->pixelformat.rgb_bitcount == 8)\n    (void) SetImageType(image,GrayscaleType);\n  else if (dds_info->pixelformat.rgb_bitcount == 16 && !IsBitMask(\n    dds_info->pixelformat,0xf800,0x07e0,0x001f,0x0000))\n    ThrowBinaryException(CorruptImageError,\"ImageTypeNotSupported\",\n      image->filename);\n\n  for (y = 0; y < (ssize_t) dds_info->height; y++)\n  {\n    q = QueueAuthenticPixels(image, 0, y, dds_info->width, 1,exception);\n\n    if (q == (PixelPacket *) NULL)\n      return MagickFalse;\n\n    for (x = 0; x < (ssize_t) dds_info->width; x++)\n    {\n      if (dds_info->pixelformat.rgb_bitcount == 8)\n        SetPixelGray(q,ScaleCharToQuantum(ReadBlobByte(image)));\n      else if (dds_info->pixelformat.rgb_bitcount == 16)\n        {\n           color=ReadBlobShort(image);\n           SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n             (((color >> 11)/31.0)*255)));\n           SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n             ((((unsigned short)(color << 5) >> 10)/63.0)*255)));\n           SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n             ((((unsigned short)(color << 11) >> 11)/31.0)*255)));\n        }\n      else\n        {\n          SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n            ReadBlobByte(image)));\n          SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n            ReadBlobByte(image)));\n          SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n            ReadBlobByte(image)));\n          if (dds_info->pixelformat.rgb_bitcount == 32)\n            (void) ReadBlobByte(image);\n        }\n      SetPixelAlpha(q,QuantumRange);\n      q++;\n    }\n \n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      return MagickFalse;\n  }\n\n  return(SkipRGBMipmaps(image,dds_info,3,exception));\n}\n\nstatic MagickBooleanType ReadUncompressedRGBA(Image *image, DDSInfo *dds_info,\n  ExceptionInfo *exception)\n{\n  PixelPacket\n    *q;\n\n  ssize_t\n    alphaBits,\n    x,\n    y;\n\n  unsigned short\n    color;\n\n  alphaBits=0;\n  if (dds_info->pixelformat.rgb_bitcount == 16)\n    {\n      if (IsBitMask(dds_info->pixelformat,0x7c00,0x03e0,0x001f,0x8000))\n        alphaBits=1;\n      else if (IsBitMask(dds_info->pixelformat,0x00ff,0x00ff,0x00ff,0xff00))\n        {\n          alphaBits=2;\n          (void) SetImageType(image,GrayscaleMatteType);\n        }\n      else if (IsBitMask(dds_info->pixelformat,0x0f00,0x00f0,0x000f,0xf000))\n        alphaBits=4;\n      else\n        ThrowBinaryException(CorruptImageError,\"ImageTypeNotSupported\",\n          image->filename);\n    }\n\n  for (y = 0; y < (ssize_t) dds_info->height; y++)\n  {\n    q = QueueAuthenticPixels(image, 0, y, dds_info->width, 1,exception);\n\n    if (q == (PixelPacket *) NULL)\n      return MagickFalse;\n\n    for (x = 0; x < (ssize_t) dds_info->width; x++)\n    {\n      if (dds_info->pixelformat.rgb_bitcount == 16)\n        {\n           color=ReadBlobShort(image);\n           if (alphaBits == 1)\n             {\n               SetPixelAlpha(q,(color & (1 << 15)) ? QuantumRange : 0);\n               SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n                 ((((unsigned short)(color << 1) >> 11)/31.0)*255)));\n               SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n                 ((((unsigned short)(color << 6) >> 11)/31.0)*255)));\n               SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n                 ((((unsigned short)(color << 11) >> 11)/31.0)*255)));\n             }\n          else if (alphaBits == 2)\n            {\n               SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n                 (color >> 8)));\n               SetPixelGray(q,ScaleCharToQuantum((unsigned char)color));\n            }\n          else\n            {\n               SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n                 (((color >> 12)/15.0)*255)));\n               SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n                 ((((unsigned short)(color << 4) >> 12)/15.0)*255)));\n               SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n                 ((((unsigned short)(color << 8) >> 12)/15.0)*255)));\n               SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n                 ((((unsigned short)(color << 12) >> 12)/15.0)*255)));\n            }\n        }\n      else\n        {\n          SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n            ReadBlobByte(image)));\n          SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n            ReadBlobByte(image)));\n          SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n            ReadBlobByte(image)));\n          SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n            ReadBlobByte(image)));\n        }\n      q++;\n    }\n\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      return MagickFalse;\n  }\n\n  return(SkipRGBMipmaps(image,dds_info,4,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r D D S I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterDDSImage() adds attributes for the DDS image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterDDSImage method is:\n%\n%      RegisterDDSImage(void)\n%\n*/\nModuleExport size_t RegisterDDSImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry = SetMagickInfo(\"DDS\");\n  entry->decoder = (DecodeImageHandler *) ReadDDSImage;\n  entry->encoder = (EncodeImageHandler *) WriteDDSImage;\n  entry->magick = (IsImageFormatHandler *) IsDDS;\n  entry->seekable_stream=MagickTrue;\n  entry->description = ConstantString(\"Microsoft DirectDraw Surface\");\n  entry->module = ConstantString(\"DDS\");\n  (void) RegisterMagickInfo(entry);\n  entry = SetMagickInfo(\"DXT1\");\n  entry->decoder = (DecodeImageHandler *) ReadDDSImage;\n  entry->encoder = (EncodeImageHandler *) WriteDDSImage;\n  entry->magick = (IsImageFormatHandler *) IsDDS;\n  entry->seekable_stream=MagickTrue;\n  entry->description = ConstantString(\"Microsoft DirectDraw Surface\");\n  entry->module = ConstantString(\"DDS\");\n  (void) RegisterMagickInfo(entry);\n  entry = SetMagickInfo(\"DXT5\");\n  entry->decoder = (DecodeImageHandler *) ReadDDSImage;\n  entry->encoder = (EncodeImageHandler *) WriteDDSImage;\n  entry->magick = (IsImageFormatHandler *) IsDDS;\n  entry->seekable_stream=MagickTrue;\n  entry->description = ConstantString(\"Microsoft DirectDraw Surface\");\n  entry->module = ConstantString(\"DDS\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\nstatic void RemapIndices(const ssize_t *map, const unsigned char *source,\n  unsigned char *target)\n{\n  register ssize_t\n    i;\n\n  for (i = 0; i < 16; i++)\n  {\n    if (map[i] == -1)\n      target[i] = 3;\n    else\n      target[i] = source[map[i]];\n  }\n}\n\n/*\n  Skip the mipmap images for compressed (DXTn) dds files\n*/\nstatic MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *dds_info,\n  int texel_size,ExceptionInfo *exception)\n{\n  register ssize_t\n    i;\n\n  MagickOffsetType\n    offset;\n\n  size_t\n    h,\n    w;\n\n  /*\n    Only skip mipmaps for textures and cube maps\n  */\n  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n    {\n      if (EOFBlob(image) != MagickFalse)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          return(MagickFalse);\n        }\n      w = DIV2(dds_info->width);\n      h = DIV2(dds_info->height);\n\n      /*\n        Mipmapcount includes the main image, so start from one\n      */\n      for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n      {\n        offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n\n        w = DIV2(w);\n        h = DIV2(h);\n      }\n    }\n  return(MagickTrue);\n}\n\n/*\n  Skip the mipmap images for uncompressed (RGB or RGBA) dds files\n*/\nstatic MagickBooleanType SkipRGBMipmaps(Image *image,DDSInfo *dds_info,\n  int pixel_size,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    offset;\n\n  register ssize_t\n    i;\n\n  size_t\n    h,\n    w;\n\n  /*\n    Only skip mipmaps for textures and cube maps\n  */\n  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n    {\n      if (EOFBlob(image) != MagickFalse)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          return(MagickFalse);\n        }\n      w = DIV2(dds_info->width);\n      h = DIV2(dds_info->height);\n\n      /*\n        Mipmapcount includes the main image, so start from one\n      */\n      for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n      {\n        offset = (MagickOffsetType) w * h * pixel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n\n        w = DIV2(w);\n        h = DIV2(h);\n      }\n    }\n  return(MagickTrue);\n}\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r D D S I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterDDSImage() removes format registrations made by the\n%  DDS module from the list of supported formats.\n%\n%  The format of the UnregisterDDSImage method is:\n%\n%      UnregisterDDSImage(void)\n%\n*/\nModuleExport void UnregisterDDSImage(void)\n{\n  (void) UnregisterMagickInfo(\"DDS\");\n  (void) UnregisterMagickInfo(\"DXT1\");\n  (void) UnregisterMagickInfo(\"DXT5\");\n}\n\nstatic void WriteAlphas(Image *image, const ssize_t* alphas, size_t min5,\n  size_t max5, size_t min7, size_t max7)\n{\n  register ssize_t\n    i;\n\n  size_t\n    err5,\n    err7,\n    j;\n\n  unsigned char\n    indices5[16],\n    indices7[16];\n\n  FixRange(min5,max5,5);\n  err5 = CompressAlpha(min5,max5,5,alphas,indices5);\n\n  FixRange(min7,max7,7);\n  err7 = CompressAlpha(min7,max7,7,alphas,indices7);\n\n  if (err7 < err5)\n  {\n    for (i=0; i < 16; i++)\n    {\n      unsigned char\n        index;\n\n      index = indices7[i];\n      if( index == 0 )\n        indices5[i] = 1;\n      else if (index == 1)\n        indices5[i] = 0;\n      else\n        indices5[i] = 9 - index;\n    }\n\n    min5 = max7;\n    max5 = min7;\n  }\n  \n  (void) WriteBlobByte(image,(unsigned char) min5);\n  (void) WriteBlobByte(image,(unsigned char) max5);\n  \n  for(i=0; i < 2; i++)\n  {\n    size_t\n      value = 0;\n\n    for (j=0; j < 8; j++)\n    {\n      size_t index = (size_t) indices5[j + i*8];\n      value |= ( index << 3*j );\n    }\n\n    for (j=0; j < 3; j++)\n    {\n      size_t byte = (value >> 8*j) & 0xff;\n      (void) WriteBlobByte(image,(unsigned char) byte);\n    }\n  }\n}\n\nstatic void WriteCompressed(Image *image, const size_t count,\n  DDSVector4* points, const ssize_t* map, const MagickBooleanType clusterFit)\n{\n  float\n    covariance[16];\n\n  DDSVector3\n    end,\n    principle,\n    start;\n\n  DDSVector4\n    metric;\n\n  unsigned char\n    indices[16];\n\n  VectorInit(metric,1.0f);\n  VectorInit3(start,0.0f);\n  VectorInit3(end,0.0f);\n\n  ComputeWeightedCovariance(count,points,covariance);\n  ComputePrincipleComponent(covariance,&principle);\n\n  if (clusterFit == MagickFalse || count == 0)\n    CompressRangeFit(count,points,map,principle,metric,&start,&end,indices);\n  else\n    CompressClusterFit(count,points,map,principle,metric,&start,&end,indices);\n\n  WriteIndices(image,start,end,indices);\n}\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e D D S I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteDDSImage() writes a DirectDraw Surface image file in the DXT5 format.\n%\n%  The format of the WriteBMPImage method is:\n%\n%     MagickBooleanType WriteDDSImage(const ImageInfo *image_info,Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n*/\nstatic MagickBooleanType WriteDDSImage(const ImageInfo *image_info,\n  Image *image)\n{\n  const char\n    *option;\n\n  size_t\n    compression,\n    columns,\n    maxMipmaps,\n    mipmaps,\n    pixelFormat,\n    rows;\n\n  MagickBooleanType\n    clusterFit,\n    status,\n    weightByAlpha;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  pixelFormat=DDPF_FOURCC;\n  compression=FOURCC_DXT5;\n\n  if (!image->matte)\n    compression=FOURCC_DXT1;\n\n  if (LocaleCompare(image_info->magick,\"dxt1\") == 0)\n    compression=FOURCC_DXT1;\n\n  option=GetImageOption(image_info,\"dds:compression\");\n  if (option != (char *) NULL)\n    {\n       if (LocaleCompare(option,\"dxt1\") == 0)\n         compression=FOURCC_DXT1;\n       if (LocaleCompare(option,\"none\") == 0)\n         pixelFormat=DDPF_RGB;\n    }\n\n  clusterFit=MagickFalse;\n  weightByAlpha=MagickFalse;\n\n  if (pixelFormat == DDPF_FOURCC)\n    {\n      option=GetImageOption(image_info,\"dds:cluster-fit\");\n      if (option != (char *) NULL && LocaleCompare(option,\"true\") == 0)\n        {\n          clusterFit=MagickTrue;\n          if (compression != FOURCC_DXT1)\n            {\n              option=GetImageOption(image_info,\"dds:weight-by-alpha\");\n              if (option != (char *) NULL && LocaleCompare(option,\"true\") == 0)\n                weightByAlpha=MagickTrue;\n            }\n        }\n    }\n\n  maxMipmaps=SIZE_MAX;\n  mipmaps=0;\n  if ((image->columns & (image->columns - 1)) == 0 &&\n      (image->rows & (image->rows - 1)) == 0)\n    {\n      option=GetImageOption(image_info,\"dds:mipmaps\");\n      if (option != (char *) NULL)\n        maxMipmaps=StringToUnsignedLong(option);\n\n      if (maxMipmaps != 0)\n        {\n          columns=image->columns;\n          rows=image->rows;\n          while (columns != 1 && rows != 1 && mipmaps != maxMipmaps)\n          {\n            columns=DIV2(columns);\n            rows=DIV2(rows);\n            mipmaps++;\n          }\n        }\n    }\n\n  WriteDDSInfo(image,pixelFormat,compression,mipmaps);\n\n  WriteImageData(image,pixelFormat,compression,clusterFit,weightByAlpha,\n    &image->exception);\n\n  if (mipmaps > 0 && WriteMipmaps(image,pixelFormat,compression,mipmaps,\n        clusterFit,weightByAlpha,&image->exception) == MagickFalse)\n    return(MagickFalse);\n\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n\nstatic void WriteDDSInfo(Image *image, const size_t pixelFormat,\n  const size_t compression, const size_t mipmaps)\n{\n  char\n    software[MaxTextExtent];\n\n  register ssize_t\n    i;\n\n  unsigned int\n    format,\n    caps,\n    flags;\n\n  flags=(unsigned int) (DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT |\n    DDSD_PIXELFORMAT | DDSD_LINEARSIZE);\n  caps=(unsigned int) DDSCAPS_TEXTURE;\n  format=(unsigned int) pixelFormat;\n\n  if (mipmaps > 0)\n    {\n      flags=flags | (unsigned int) DDSD_MIPMAPCOUNT;\n      caps=caps | (unsigned int) (DDSCAPS_MIPMAP | DDSCAPS_COMPLEX);\n    }\n\n  if (format != DDPF_FOURCC && image->matte)\n    format=format | DDPF_ALPHAPIXELS;\n\n  (void) WriteBlob(image,4,(unsigned char *) \"DDS \");\n  (void) WriteBlobLSBLong(image,124);\n  (void) WriteBlobLSBLong(image,flags);\n  (void) WriteBlobLSBLong(image,(unsigned int) image->rows);\n  (void) WriteBlobLSBLong(image,(unsigned int) image->columns);\n\n  if (compression == FOURCC_DXT1)\n    (void) WriteBlobLSBLong(image,\n             (unsigned int) (MagickMax(1,(image->columns+3)/4) * 8));\n  else\n    (void) WriteBlobLSBLong(image,\n             (unsigned int) (MagickMax(1,(image->columns+3)/4) * 16));\n\n  (void) WriteBlobLSBLong(image,0x00);\n  (void) WriteBlobLSBLong(image,(unsigned int) mipmaps+1);\n  (void) ResetMagickMemory(software,0,sizeof(software));\n  (void) strcpy(software,\"IMAGEMAGICK\");\n  (void) WriteBlob(image,44,(unsigned char *) software);\n\n  (void) WriteBlobLSBLong(image,32);\n  (void) WriteBlobLSBLong(image,format);\n\n  if (pixelFormat == DDPF_FOURCC)\n    {\n      (void) WriteBlobLSBLong(image,(unsigned int) compression);\n      for(i=0;i < 5;i++) // bitcount / masks\n        (void) WriteBlobLSBLong(image,0x00);\n    }\n  else\n    {\n      (void) WriteBlobLSBLong(image,0x00);\n      if (image->matte)\n        {\n          (void) WriteBlobLSBLong(image,32);\n          (void) WriteBlobLSBLong(image,0xff0000);\n          (void) WriteBlobLSBLong(image,0xff00);\n          (void) WriteBlobLSBLong(image,0xff);\n          (void) WriteBlobLSBLong(image,0xff000000);\n        }\n      else\n        {\n          (void) WriteBlobLSBLong(image,24);\n          (void) WriteBlobLSBLong(image,0xff);\n          (void) WriteBlobLSBLong(image,0x00);\n          (void) WriteBlobLSBLong(image,0x00);\n          (void) WriteBlobLSBLong(image,0x00);\n        }\n    }\n  \n  (void) WriteBlobLSBLong(image,caps);\n  for(i=0;i < 4;i++) // ddscaps2 + reserved region\n    (void) WriteBlobLSBLong(image,0x00);\n}\n\nstatic void WriteFourCC(Image *image, const size_t compression,\n  const MagickBooleanType clusterFit, const MagickBooleanType weightByAlpha,\n  ExceptionInfo *exception)\n{\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    i,\n    y,\n    bx,\n    by;\n\n  for (y=0; y < (ssize_t) image->rows; y+=4)\n  {\n    for (x=0; x < (ssize_t) image->columns; x+=4)\n    {\n      MagickBooleanType\n        match;\n\n      DDSVector4\n        point,\n        points[16];\n\n      size_t\n        count = 0,\n        max5 = 0,\n        max7 = 0,\n        min5 = 255,\n        min7 = 255,\n        columns = 4,\n        rows = 4;\n\n      ssize_t\n        alphas[16],\n        map[16];\n\n      unsigned char\n        alpha;\n\n      if (x + columns >= image->columns)\n        columns = image->columns - x;\n\n      if (y + rows >= image->rows)\n        rows = image->rows - y;\n\n      p=GetVirtualPixels(image,x,y,columns,rows,exception);\n      if (p == (const PixelPacket *) NULL)\n        break;\n\n      for (i=0; i<16; i++)\n      {\n        map[i] = -1;\n        alphas[i] = -1;\n      }\n\n      for (by=0; by < (ssize_t) rows; by++)\n      {\n        for (bx=0; bx < (ssize_t) columns; bx++)\n        {\n          if (compression == FOURCC_DXT5)\n            alpha = ScaleQuantumToChar(GetPixelAlpha(p));\n          else\n            alpha = 255;\n\n          alphas[4*by + bx] = (size_t)alpha;\n\n          point.x = (float)ScaleQuantumToChar(GetPixelRed(p)) / 255.0f;\n          point.y = (float)ScaleQuantumToChar(GetPixelGreen(p)) / 255.0f;\n          point.z = (float)ScaleQuantumToChar(GetPixelBlue(p)) / 255.0f;\n          point.w = weightByAlpha ? (float)(alpha + 1) / 256.0f : 1.0f;\n          p++;\n\n          match = MagickFalse;\n          for (i=0; i < (ssize_t) count; i++)\n          {\n            if ((points[i].x == point.x) &&\n                (points[i].y == point.y) &&\n                (points[i].z == point.z) &&\n                (alpha       >= 128 || compression == FOURCC_DXT5))\n              {\n                points[i].w += point.w;\n                map[4*by + bx] = i;\n                match = MagickTrue;\n                break;\n              }\n            }\n\n            if (match != MagickFalse)\n              continue;\n\n            points[count].x = point.x;\n            points[count].y = point.y;\n            points[count].z = point.z;\n            points[count].w = point.w;\n            map[4*by + bx] = count;\n            count++;\n\n            if (compression == FOURCC_DXT5)\n              {\n                if (alpha < min7)\n                  min7 = alpha;\n                if (alpha > max7)\n                  max7 = alpha;\n                if (alpha != 0 && alpha < min5)\n                  min5 = alpha;\n                if (alpha != 255 && alpha > max5)\n                  max5 = alpha;\n              }\n          }\n        }\n\n      for (i=0; i < (ssize_t) count; i++)\n        points[i].w = sqrt(points[i].w);\n\n      if (compression == FOURCC_DXT5)\n        WriteAlphas(image,alphas,min5,max5,min7,max7);\n\n      if (count == 1)\n        WriteSingleColorFit(image,points,map);\n      else\n        WriteCompressed(image,count,points,map,clusterFit);\n    }\n  }\n}\n\nstatic void WriteImageData(Image *image, const size_t pixelFormat,\n  const size_t compression, const MagickBooleanType clusterFit,\n  const MagickBooleanType weightByAlpha, ExceptionInfo *exception)\n{\n  if (pixelFormat == DDPF_FOURCC)\n    WriteFourCC(image,compression,clusterFit,weightByAlpha,exception);\n  else\n    WriteUncompressed(image,exception);\n}\n\nstatic inline size_t ClampToLimit(const float value,\n  const size_t limit)\n{\n  size_t\n    result = (int) (value + 0.5f);\n\n  if (result < 0.0f)\n    return(0);\n  if (result > limit)\n    return(limit);\n  return result;\n}\n\nstatic inline size_t ColorTo565(const DDSVector3 point)\n{\n  size_t r = ClampToLimit(31.0f*point.x,31);\n  size_t g = ClampToLimit(63.0f*point.y,63);\n  size_t b = ClampToLimit(31.0f*point.z,31);\n\n  return (r << 11) | (g << 5) | b;\n}\n\nstatic void WriteIndices(Image *image, const DDSVector3 start,\n  const DDSVector3 end, unsigned char* indices)\n{\n  register ssize_t\n    i;\n\n  size_t\n    a,\n    b;\n\n  unsigned char\n    remapped[16];\n\n  const unsigned char\n    *ind;\n\n  a = ColorTo565(start);\n  b = ColorTo565(end);\n\n  for (i=0; i<16; i++)\n  {\n    if( a < b )\n      remapped[i] = (indices[i] ^ 0x1) & 0x3;\n    else if( a == b )\n      remapped[i] = 0;\n    else\n      remapped[i] = indices[i];\n  }\n\n  if( a < b )\n    Swap(a,b);\n\n  (void) WriteBlobByte(image,(unsigned char) (a & 0xff));\n  (void) WriteBlobByte(image,(unsigned char) (a >> 8));\n  (void) WriteBlobByte(image,(unsigned char) (b & 0xff));\n  (void) WriteBlobByte(image,(unsigned char) (b >> 8));\n\n  for (i=0; i<4; i++)\n  {\n     ind = remapped + 4*i;\n     (void) WriteBlobByte(image,ind[0] | (ind[1] << 2) | (ind[2] << 4) |\n       (ind[3] << 6));\n  }\n}\n\nstatic MagickBooleanType WriteMipmaps(Image *image, const size_t pixelFormat,\n  const size_t compression, const size_t mipmaps,\n  const MagickBooleanType clusterFit, const MagickBooleanType weightByAlpha,\n  ExceptionInfo *exception)\n{\n  Image*\n    resize_image;\n\n  register ssize_t\n    i;\n\n  size_t\n    columns,\n    rows;\n\n  columns = image->columns;\n  rows = image->rows;\n\n  for (i=0; i< (ssize_t) mipmaps; i++)\n  {\n    resize_image = ResizeImage(image,columns/2,rows/2,TriangleFilter,1.0,\n      exception);\n\n    if (resize_image == (Image *) NULL)\n      return(MagickFalse);\n\n    DestroyBlob(resize_image);\n    resize_image->blob=ReferenceBlob(image->blob);\n\n    WriteImageData(resize_image,pixelFormat,compression,weightByAlpha,\n      clusterFit,exception);\n\n    resize_image=DestroyImage(resize_image);\n\n    columns = DIV2(columns);\n    rows = DIV2(rows);\n  }\n\n  return(MagickTrue);\n}\n\nstatic void WriteSingleColorFit(Image *image, const DDSVector4* points,\n  const ssize_t* map)\n{\n  DDSVector3\n    start,\n    end;\n\n  register ssize_t\n    i;\n\n  unsigned char\n    color[3],\n    index,\n    indexes[16],\n    indices[16];\n\n  color[0] = (unsigned char) ClampToLimit(255.0f*points->x,255);\n  color[1] = (unsigned char) ClampToLimit(255.0f*points->y,255);\n  color[2] = (unsigned char) ClampToLimit(255.0f*points->z,255);\n\n  index=0;\n  ComputeEndPoints(DDS_LOOKUP,color,&start,&end,&index);\n\n  for (i=0; i< 16; i++)\n    indexes[i]=index;\n  RemapIndices(map,indexes,indices);\n  WriteIndices(image,start,end,indices);\n}\n\nstatic void WriteUncompressed(Image *image, ExceptionInfo *exception)\n{\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    y;\n\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelBlue(p)));\n      (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelGreen(p)));\n      (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelRed(p)));\n      if (image->matte)\n        (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelAlpha(p)));\n      p++;\n    }\n  }\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            DDDD   DDDD   SSSSS                              %\n%                            D   D  D   D  SS                                 %\n%                            D   D  D   D   SSS                               %\n%                            D   D  D   D     SS                              %\n%                            DDDD   DDDD   SSSSS                              %\n%                                                                             %\n%                                                                             %\n%           Read/Write Microsoft Direct Draw Surface Image Format             %\n%                                                                             %\n%                              Software Design                                %\n%                             Bianca van Schaik                               %\n%                                March 2008                                   %\n%                               Dirk Lemstra                                  %\n%                              September 2013                                 %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2015 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/attribute.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/cache.h\"\n#include \"magick/colorspace.h\"\n#include \"magick/colorspace-private.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/image.h\"\n#include \"magick/image-private.h\"\n#include \"magick/list.h\"\n#include \"magick/log.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/monitor.h\"\n#include \"magick/monitor-private.h\"\n#include \"magick/option.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/profile.h\"\n#include \"magick/quantum.h\"\n#include \"magick/quantum-private.h\"\n#include \"magick/resource_.h\"\n#include \"magick/static.h\"\n#include \"magick/string_.h\"\n#include \"magick/string-private.h\"\n#include \"magick/module.h\"\n#include \"magick/transform.h\"\n\n/*\n  Definitions\n*/\n#define DDSD_CAPS         0x00000001\n#define DDSD_HEIGHT       0x00000002\n#define DDSD_WIDTH        0x00000004\n#define DDSD_PITCH        0x00000008\n#define DDSD_PIXELFORMAT  0x00001000\n#define DDSD_MIPMAPCOUNT  0x00020000\n#define DDSD_LINEARSIZE   0x00080000\n#define DDSD_DEPTH        0x00800000\n\n#define DDPF_ALPHAPIXELS  0x00000001\n#define DDPF_FOURCC       0x00000004\n#define DDPF_RGB          0x00000040\n#define DDPF_LUMINANCE    0x00020000\n\n#define FOURCC_DXT1       0x31545844\n#define FOURCC_DXT3       0x33545844\n#define FOURCC_DXT5       0x35545844\n\n#define DDSCAPS_COMPLEX   0x00000008\n#define DDSCAPS_TEXTURE   0x00001000\n#define DDSCAPS_MIPMAP    0x00400000\n\n#define DDSCAPS2_CUBEMAP  0x00000200\n#define DDSCAPS2_CUBEMAP_POSITIVEX  0x00000400\n#define DDSCAPS2_CUBEMAP_NEGATIVEX  0x00000800\n#define DDSCAPS2_CUBEMAP_POSITIVEY  0x00001000\n#define DDSCAPS2_CUBEMAP_NEGATIVEY  0x00002000\n#define DDSCAPS2_CUBEMAP_POSITIVEZ  0x00004000\n#define DDSCAPS2_CUBEMAP_NEGATIVEZ  0x00008000\n#define DDSCAPS2_VOLUME   0x00200000\n\n#ifndef SIZE_MAX\n#define SIZE_MAX ((size_t) -1)\n#endif\n\n/*\n  Structure declarations.\n*/\ntypedef struct _DDSPixelFormat\n{\n  size_t\n    flags,\n    fourcc,\n    rgb_bitcount,\n    r_bitmask,\n    g_bitmask,\n    b_bitmask,\n    alpha_bitmask;\n} DDSPixelFormat;\n\ntypedef struct _DDSInfo\n{\n  size_t\n    flags,\n    height,\n    width,\n    pitchOrLinearSize,\n    depth,\n    mipmapcount,\n    ddscaps1,\n    ddscaps2;\n\n  DDSPixelFormat\n    pixelformat;\n} DDSInfo;\n\ntypedef struct _DDSColors\n{\n  unsigned char\n    r[4],\n    g[4],\n    b[4],\n    a[4];\n} DDSColors;\n\ntypedef struct _DDSVector4\n{\n  float\n    x,\n    y,\n    z,\n    w;\n} DDSVector4;\n\ntypedef struct _DDSVector3\n{\n  float\n    x,\n    y,\n    z;\n} DDSVector3;\n\ntypedef struct _DDSSourceBlock\n{\n  unsigned char\n    start,\n    end,\n    error;\n} DDSSourceBlock;\n\ntypedef struct _DDSSingleColourLookup\n{\n  DDSSourceBlock sources[2];\n} DDSSingleColourLookup;\n\ntypedef MagickBooleanType\n  DDSDecoder(Image *, DDSInfo *, ExceptionInfo *);\n\nstatic const DDSSingleColourLookup DDSLookup_5_4[] =\n{\n  { { { 0, 0, 0 }, { 0, 0, 0 } } },\n  { { { 0, 0, 1 }, { 0, 1, 1 } } },\n  { { { 0, 0, 2 }, { 0, 1, 0 } } },\n  { { { 0, 0, 3 }, { 0, 1, 1 } } },\n  { { { 0, 0, 4 }, { 0, 2, 1 } } },\n  { { { 1, 0, 3 }, { 0, 2, 0 } } },\n  { { { 1, 0, 2 }, { 0, 2, 1 } } },\n  { { { 1, 0, 1 }, { 0, 3, 1 } } },\n  { { { 1, 0, 0 }, { 0, 3, 0 } } },\n  { { { 1, 0, 1 }, { 1, 2, 1 } } },\n  { { { 1, 0, 2 }, { 1, 2, 0 } } },\n  { { { 1, 0, 3 }, { 0, 4, 0 } } },\n  { { { 1, 0, 4 }, { 0, 5, 1 } } },\n  { { { 2, 0, 3 }, { 0, 5, 0 } } },\n  { { { 2, 0, 2 }, { 0, 5, 1 } } },\n  { { { 2, 0, 1 }, { 0, 6, 1 } } },\n  { { { 2, 0, 0 }, { 0, 6, 0 } } },\n  { { { 2, 0, 1 }, { 2, 3, 1 } } },\n  { { { 2, 0, 2 }, { 2, 3, 0 } } },\n  { { { 2, 0, 3 }, { 0, 7, 0 } } },\n  { { { 2, 0, 4 }, { 1, 6, 1 } } },\n  { { { 3, 0, 3 }, { 1, 6, 0 } } },\n  { { { 3, 0, 2 }, { 0, 8, 0 } } },\n  { { { 3, 0, 1 }, { 0, 9, 1 } } },\n  { { { 3, 0, 0 }, { 0, 9, 0 } } },\n  { { { 3, 0, 1 }, { 0, 9, 1 } } },\n  { { { 3, 0, 2 }, { 0, 10, 1 } } },\n  { { { 3, 0, 3 }, { 0, 10, 0 } } },\n  { { { 3, 0, 4 }, { 2, 7, 1 } } },\n  { { { 4, 0, 4 }, { 2, 7, 0 } } },\n  { { { 4, 0, 3 }, { 0, 11, 0 } } },\n  { { { 4, 0, 2 }, { 1, 10, 1 } } },\n  { { { 4, 0, 1 }, { 1, 10, 0 } } },\n  { { { 4, 0, 0 }, { 0, 12, 0 } } },\n  { { { 4, 0, 1 }, { 0, 13, 1 } } },\n  { { { 4, 0, 2 }, { 0, 13, 0 } } },\n  { { { 4, 0, 3 }, { 0, 13, 1 } } },\n  { { { 4, 0, 4 }, { 0, 14, 1 } } },\n  { { { 5, 0, 3 }, { 0, 14, 0 } } },\n  { { { 5, 0, 2 }, { 2, 11, 1 } } },\n  { { { 5, 0, 1 }, { 2, 11, 0 } } },\n  { { { 5, 0, 0 }, { 0, 15, 0 } } },\n  { { { 5, 0, 1 }, { 1, 14, 1 } } },\n  { { { 5, 0, 2 }, { 1, 14, 0 } } },\n  { { { 5, 0, 3 }, { 0, 16, 0 } } },\n  { { { 5, 0, 4 }, { 0, 17, 1 } } },\n  { { { 6, 0, 3 }, { 0, 17, 0 } } },\n  { { { 6, 0, 2 }, { 0, 17, 1 } } },\n  { { { 6, 0, 1 }, { 0, 18, 1 } } },\n  { { { 6, 0, 0 }, { 0, 18, 0 } } },\n  { { { 6, 0, 1 }, { 2, 15, 1 } } },\n  { { { 6, 0, 2 }, { 2, 15, 0 } } },\n  { { { 6, 0, 3 }, { 0, 19, 0 } } },\n  { { { 6, 0, 4 }, { 1, 18, 1 } } },\n  { { { 7, 0, 3 }, { 1, 18, 0 } } },\n  { { { 7, 0, 2 }, { 0, 20, 0 } } },\n  { { { 7, 0, 1 }, { 0, 21, 1 } } },\n  { { { 7, 0, 0 }, { 0, 21, 0 } } },\n  { { { 7, 0, 1 }, { 0, 21, 1 } } },\n  { { { 7, 0, 2 }, { 0, 22, 1 } } },\n  { { { 7, 0, 3 }, { 0, 22, 0 } } },\n  { { { 7, 0, 4 }, { 2, 19, 1 } } },\n  { { { 8, 0, 4 }, { 2, 19, 0 } } },\n  { { { 8, 0, 3 }, { 0, 23, 0 } } },\n  { { { 8, 0, 2 }, { 1, 22, 1 } } },\n  { { { 8, 0, 1 }, { 1, 22, 0 } } },\n  { { { 8, 0, 0 }, { 0, 24, 0 } } },\n  { { { 8, 0, 1 }, { 0, 25, 1 } } },\n  { { { 8, 0, 2 }, { 0, 25, 0 } } },\n  { { { 8, 0, 3 }, { 0, 25, 1 } } },\n  { { { 8, 0, 4 }, { 0, 26, 1 } } },\n  { { { 9, 0, 3 }, { 0, 26, 0 } } },\n  { { { 9, 0, 2 }, { 2, 23, 1 } } },\n  { { { 9, 0, 1 }, { 2, 23, 0 } } },\n  { { { 9, 0, 0 }, { 0, 27, 0 } } },\n  { { { 9, 0, 1 }, { 1, 26, 1 } } },\n  { { { 9, 0, 2 }, { 1, 26, 0 } } },\n  { { { 9, 0, 3 }, { 0, 28, 0 } } },\n  { { { 9, 0, 4 }, { 0, 29, 1 } } },\n  { { { 10, 0, 3 }, { 0, 29, 0 } } },\n  { { { 10, 0, 2 }, { 0, 29, 1 } } },\n  { { { 10, 0, 1 }, { 0, 30, 1 } } },\n  { { { 10, 0, 0 }, { 0, 30, 0 } } },\n  { { { 10, 0, 1 }, { 2, 27, 1 } } },\n  { { { 10, 0, 2 }, { 2, 27, 0 } } },\n  { { { 10, 0, 3 }, { 0, 31, 0 } } },\n  { { { 10, 0, 4 }, { 1, 30, 1 } } },\n  { { { 11, 0, 3 }, { 1, 30, 0 } } },\n  { { { 11, 0, 2 }, { 4, 24, 0 } } },\n  { { { 11, 0, 1 }, { 1, 31, 1 } } },\n  { { { 11, 0, 0 }, { 1, 31, 0 } } },\n  { { { 11, 0, 1 }, { 1, 31, 1 } } },\n  { { { 11, 0, 2 }, { 2, 30, 1 } } },\n  { { { 11, 0, 3 }, { 2, 30, 0 } } },\n  { { { 11, 0, 4 }, { 2, 31, 1 } } },\n  { { { 12, 0, 4 }, { 2, 31, 0 } } },\n  { { { 12, 0, 3 }, { 4, 27, 0 } } },\n  { { { 12, 0, 2 }, { 3, 30, 1 } } },\n  { { { 12, 0, 1 }, { 3, 30, 0 } } },\n  { { { 12, 0, 0 }, { 4, 28, 0 } } },\n  { { { 12, 0, 1 }, { 3, 31, 1 } } },\n  { { { 12, 0, 2 }, { 3, 31, 0 } } },\n  { { { 12, 0, 3 }, { 3, 31, 1 } } },\n  { { { 12, 0, 4 }, { 4, 30, 1 } } },\n  { { { 13, 0, 3 }, { 4, 30, 0 } } },\n  { { { 13, 0, 2 }, { 6, 27, 1 } } },\n  { { { 13, 0, 1 }, { 6, 27, 0 } } },\n  { { { 13, 0, 0 }, { 4, 31, 0 } } },\n  { { { 13, 0, 1 }, { 5, 30, 1 } } },\n  { { { 13, 0, 2 }, { 5, 30, 0 } } },\n  { { { 13, 0, 3 }, { 8, 24, 0 } } },\n  { { { 13, 0, 4 }, { 5, 31, 1 } } },\n  { { { 14, 0, 3 }, { 5, 31, 0 } } },\n  { { { 14, 0, 2 }, { 5, 31, 1 } } },\n  { { { 14, 0, 1 }, { 6, 30, 1 } } },\n  { { { 14, 0, 0 }, { 6, 30, 0 } } },\n  { { { 14, 0, 1 }, { 6, 31, 1 } } },\n  { { { 14, 0, 2 }, { 6, 31, 0 } } },\n  { { { 14, 0, 3 }, { 8, 27, 0 } } },\n  { { { 14, 0, 4 }, { 7, 30, 1 } } },\n  { { { 15, 0, 3 }, { 7, 30, 0 } } },\n  { { { 15, 0, 2 }, { 8, 28, 0 } } },\n  { { { 15, 0, 1 }, { 7, 31, 1 } } },\n  { { { 15, 0, 0 }, { 7, 31, 0 } } },\n  { { { 15, 0, 1 }, { 7, 31, 1 } } },\n  { { { 15, 0, 2 }, { 8, 30, 1 } } },\n  { { { 15, 0, 3 }, { 8, 30, 0 } } },\n  { { { 15, 0, 4 }, { 10, 27, 1 } } },\n  { { { 16, 0, 4 }, { 10, 27, 0 } } },\n  { { { 16, 0, 3 }, { 8, 31, 0 } } },\n  { { { 16, 0, 2 }, { 9, 30, 1 } } },\n  { { { 16, 0, 1 }, { 9, 30, 0 } } },\n  { { { 16, 0, 0 }, { 12, 24, 0 } } },\n  { { { 16, 0, 1 }, { 9, 31, 1 } } },\n  { { { 16, 0, 2 }, { 9, 31, 0 } } },\n  { { { 16, 0, 3 }, { 9, 31, 1 } } },\n  { { { 16, 0, 4 }, { 10, 30, 1 } } },\n  { { { 17, 0, 3 }, { 10, 30, 0 } } },\n  { { { 17, 0, 2 }, { 10, 31, 1 } } },\n  { { { 17, 0, 1 }, { 10, 31, 0 } } },\n  { { { 17, 0, 0 }, { 12, 27, 0 } } },\n  { { { 17, 0, 1 }, { 11, 30, 1 } } },\n  { { { 17, 0, 2 }, { 11, 30, 0 } } },\n  { { { 17, 0, 3 }, { 12, 28, 0 } } },\n  { { { 17, 0, 4 }, { 11, 31, 1 } } },\n  { { { 18, 0, 3 }, { 11, 31, 0 } } },\n  { { { 18, 0, 2 }, { 11, 31, 1 } } },\n  { { { 18, 0, 1 }, { 12, 30, 1 } } },\n  { { { 18, 0, 0 }, { 12, 30, 0 } } },\n  { { { 18, 0, 1 }, { 14, 27, 1 } } },\n  { { { 18, 0, 2 }, { 14, 27, 0 } } },\n  { { { 18, 0, 3 }, { 12, 31, 0 } } },\n  { { { 18, 0, 4 }, { 13, 30, 1 } } },\n  { { { 19, 0, 3 }, { 13, 30, 0 } } },\n  { { { 19, 0, 2 }, { 16, 24, 0 } } },\n  { { { 19, 0, 1 }, { 13, 31, 1 } } },\n  { { { 19, 0, 0 }, { 13, 31, 0 } } },\n  { { { 19, 0, 1 }, { 13, 31, 1 } } },\n  { { { 19, 0, 2 }, { 14, 30, 1 } } },\n  { { { 19, 0, 3 }, { 14, 30, 0 } } },\n  { { { 19, 0, 4 }, { 14, 31, 1 } } },\n  { { { 20, 0, 4 }, { 14, 31, 0 } } },\n  { { { 20, 0, 3 }, { 16, 27, 0 } } },\n  { { { 20, 0, 2 }, { 15, 30, 1 } } },\n  { { { 20, 0, 1 }, { 15, 30, 0 } } },\n  { { { 20, 0, 0 }, { 16, 28, 0 } } },\n  { { { 20, 0, 1 }, { 15, 31, 1 } } },\n  { { { 20, 0, 2 }, { 15, 31, 0 } } },\n  { { { 20, 0, 3 }, { 15, 31, 1 } } },\n  { { { 20, 0, 4 }, { 16, 30, 1 } } },\n  { { { 21, 0, 3 }, { 16, 30, 0 } } },\n  { { { 21, 0, 2 }, { 18, 27, 1 } } },\n  { { { 21, 0, 1 }, { 18, 27, 0 } } },\n  { { { 21, 0, 0 }, { 16, 31, 0 } } },\n  { { { 21, 0, 1 }, { 17, 30, 1 } } },\n  { { { 21, 0, 2 }, { 17, 30, 0 } } },\n  { { { 21, 0, 3 }, { 20, 24, 0 } } },\n  { { { 21, 0, 4 }, { 17, 31, 1 } } },\n  { { { 22, 0, 3 }, { 17, 31, 0 } } },\n  { { { 22, 0, 2 }, { 17, 31, 1 } } },\n  { { { 22, 0, 1 }, { 18, 30, 1 } } },\n  { { { 22, 0, 0 }, { 18, 30, 0 } } },\n  { { { 22, 0, 1 }, { 18, 31, 1 } } },\n  { { { 22, 0, 2 }, { 18, 31, 0 } } },\n  { { { 22, 0, 3 }, { 20, 27, 0 } } },\n  { { { 22, 0, 4 }, { 19, 30, 1 } } },\n  { { { 23, 0, 3 }, { 19, 30, 0 } } },\n  { { { 23, 0, 2 }, { 20, 28, 0 } } },\n  { { { 23, 0, 1 }, { 19, 31, 1 } } },\n  { { { 23, 0, 0 }, { 19, 31, 0 } } },\n  { { { 23, 0, 1 }, { 19, 31, 1 } } },\n  { { { 23, 0, 2 }, { 20, 30, 1 } } },\n  { { { 23, 0, 3 }, { 20, 30, 0 } } },\n  { { { 23, 0, 4 }, { 22, 27, 1 } } },\n  { { { 24, 0, 4 }, { 22, 27, 0 } } },\n  { { { 24, 0, 3 }, { 20, 31, 0 } } },\n  { { { 24, 0, 2 }, { 21, 30, 1 } } },\n  { { { 24, 0, 1 }, { 21, 30, 0 } } },\n  { { { 24, 0, 0 }, { 24, 24, 0 } } },\n  { { { 24, 0, 1 }, { 21, 31, 1 } } },\n  { { { 24, 0, 2 }, { 21, 31, 0 } } },\n  { { { 24, 0, 3 }, { 21, 31, 1 } } },\n  { { { 24, 0, 4 }, { 22, 30, 1 } } },\n  { { { 25, 0, 3 }, { 22, 30, 0 } } },\n  { { { 25, 0, 2 }, { 22, 31, 1 } } },\n  { { { 25, 0, 1 }, { 22, 31, 0 } } },\n  { { { 25, 0, 0 }, { 24, 27, 0 } } },\n  { { { 25, 0, 1 }, { 23, 30, 1 } } },\n  { { { 25, 0, 2 }, { 23, 30, 0 } } },\n  { { { 25, 0, 3 }, { 24, 28, 0 } } },\n  { { { 25, 0, 4 }, { 23, 31, 1 } } },\n  { { { 26, 0, 3 }, { 23, 31, 0 } } },\n  { { { 26, 0, 2 }, { 23, 31, 1 } } },\n  { { { 26, 0, 1 }, { 24, 30, 1 } } },\n  { { { 26, 0, 0 }, { 24, 30, 0 } } },\n  { { { 26, 0, 1 }, { 26, 27, 1 } } },\n  { { { 26, 0, 2 }, { 26, 27, 0 } } },\n  { { { 26, 0, 3 }, { 24, 31, 0 } } },\n  { { { 26, 0, 4 }, { 25, 30, 1 } } },\n  { { { 27, 0, 3 }, { 25, 30, 0 } } },\n  { { { 27, 0, 2 }, { 28, 24, 0 } } },\n  { { { 27, 0, 1 }, { 25, 31, 1 } } },\n  { { { 27, 0, 0 }, { 25, 31, 0 } } },\n  { { { 27, 0, 1 }, { 25, 31, 1 } } },\n  { { { 27, 0, 2 }, { 26, 30, 1 } } },\n  { { { 27, 0, 3 }, { 26, 30, 0 } } },\n  { { { 27, 0, 4 }, { 26, 31, 1 } } },\n  { { { 28, 0, 4 }, { 26, 31, 0 } } },\n  { { { 28, 0, 3 }, { 28, 27, 0 } } },\n  { { { 28, 0, 2 }, { 27, 30, 1 } } },\n  { { { 28, 0, 1 }, { 27, 30, 0 } } },\n  { { { 28, 0, 0 }, { 28, 28, 0 } } },\n  { { { 28, 0, 1 }, { 27, 31, 1 } } },\n  { { { 28, 0, 2 }, { 27, 31, 0 } } },\n  { { { 28, 0, 3 }, { 27, 31, 1 } } },\n  { { { 28, 0, 4 }, { 28, 30, 1 } } },\n  { { { 29, 0, 3 }, { 28, 30, 0 } } },\n  { { { 29, 0, 2 }, { 30, 27, 1 } } },\n  { { { 29, 0, 1 }, { 30, 27, 0 } } },\n  { { { 29, 0, 0 }, { 28, 31, 0 } } },\n  { { { 29, 0, 1 }, { 29, 30, 1 } } },\n  { { { 29, 0, 2 }, { 29, 30, 0 } } },\n  { { { 29, 0, 3 }, { 29, 30, 1 } } },\n  { { { 29, 0, 4 }, { 29, 31, 1 } } },\n  { { { 30, 0, 3 }, { 29, 31, 0 } } },\n  { { { 30, 0, 2 }, { 29, 31, 1 } } },\n  { { { 30, 0, 1 }, { 30, 30, 1 } } },\n  { { { 30, 0, 0 }, { 30, 30, 0 } } },\n  { { { 30, 0, 1 }, { 30, 31, 1 } } },\n  { { { 30, 0, 2 }, { 30, 31, 0 } } },\n  { { { 30, 0, 3 }, { 30, 31, 1 } } },\n  { { { 30, 0, 4 }, { 31, 30, 1 } } },\n  { { { 31, 0, 3 }, { 31, 30, 0 } } },\n  { { { 31, 0, 2 }, { 31, 30, 1 } } },\n  { { { 31, 0, 1 }, { 31, 31, 1 } } },\n  { { { 31, 0, 0 }, { 31, 31, 0 } } }\n};\n\nstatic const DDSSingleColourLookup DDSLookup_6_4[] =\n{\n  { { { 0, 0, 0 }, { 0, 0, 0 } } },\n  { { { 0, 0, 1 }, { 0, 1, 0 } } },\n  { { { 0, 0, 2 }, { 0, 2, 0 } } },\n  { { { 1, 0, 1 }, { 0, 3, 1 } } },\n  { { { 1, 0, 0 }, { 0, 3, 0 } } },\n  { { { 1, 0, 1 }, { 0, 4, 0 } } },\n  { { { 1, 0, 2 }, { 0, 5, 0 } } },\n  { { { 2, 0, 1 }, { 0, 6, 1 } } },\n  { { { 2, 0, 0 }, { 0, 6, 0 } } },\n  { { { 2, 0, 1 }, { 0, 7, 0 } } },\n  { { { 2, 0, 2 }, { 0, 8, 0 } } },\n  { { { 3, 0, 1 }, { 0, 9, 1 } } },\n  { { { 3, 0, 0 }, { 0, 9, 0 } } },\n  { { { 3, 0, 1 }, { 0, 10, 0 } } },\n  { { { 3, 0, 2 }, { 0, 11, 0 } } },\n  { { { 4, 0, 1 }, { 0, 12, 1 } } },\n  { { { 4, 0, 0 }, { 0, 12, 0 } } },\n  { { { 4, 0, 1 }, { 0, 13, 0 } } },\n  { { { 4, 0, 2 }, { 0, 14, 0 } } },\n  { { { 5, 0, 1 }, { 0, 15, 1 } } },\n  { { { 5, 0, 0 }, { 0, 15, 0 } } },\n  { { { 5, 0, 1 }, { 0, 16, 0 } } },\n  { { { 5, 0, 2 }, { 1, 15, 0 } } },\n  { { { 6, 0, 1 }, { 0, 17, 0 } } },\n  { { { 6, 0, 0 }, { 0, 18, 0 } } },\n  { { { 6, 0, 1 }, { 0, 19, 0 } } },\n  { { { 6, 0, 2 }, { 3, 14, 0 } } },\n  { { { 7, 0, 1 }, { 0, 20, 0 } } },\n  { { { 7, 0, 0 }, { 0, 21, 0 } } },\n  { { { 7, 0, 1 }, { 0, 22, 0 } } },\n  { { { 7, 0, 2 }, { 4, 15, 0 } } },\n  { { { 8, 0, 1 }, { 0, 23, 0 } } },\n  { { { 8, 0, 0 }, { 0, 24, 0 } } },\n  { { { 8, 0, 1 }, { 0, 25, 0 } } },\n  { { { 8, 0, 2 }, { 6, 14, 0 } } },\n  { { { 9, 0, 1 }, { 0, 26, 0 } } },\n  { { { 9, 0, 0 }, { 0, 27, 0 } } },\n  { { { 9, 0, 1 }, { 0, 28, 0 } } },\n  { { { 9, 0, 2 }, { 7, 15, 0 } } },\n  { { { 10, 0, 1 }, { 0, 29, 0 } } },\n  { { { 10, 0, 0 }, { 0, 30, 0 } } },\n  { { { 10, 0, 1 }, { 0, 31, 0 } } },\n  { { { 10, 0, 2 }, { 9, 14, 0 } } },\n  { { { 11, 0, 1 }, { 0, 32, 0 } } },\n  { { { 11, 0, 0 }, { 0, 33, 0 } } },\n  { { { 11, 0, 1 }, { 2, 30, 0 } } },\n  { { { 11, 0, 2 }, { 0, 34, 0 } } },\n  { { { 12, 0, 1 }, { 0, 35, 0 } } },\n  { { { 12, 0, 0 }, { 0, 36, 0 } } },\n  { { { 12, 0, 1 }, { 3, 31, 0 } } },\n  { { { 12, 0, 2 }, { 0, 37, 0 } } },\n  { { { 13, 0, 1 }, { 0, 38, 0 } } },\n  { { { 13, 0, 0 }, { 0, 39, 0 } } },\n  { { { 13, 0, 1 }, { 5, 30, 0 } } },\n  { { { 13, 0, 2 }, { 0, 40, 0 } } },\n  { { { 14, 0, 1 }, { 0, 41, 0 } } },\n  { { { 14, 0, 0 }, { 0, 42, 0 } } },\n  { { { 14, 0, 1 }, { 6, 31, 0 } } },\n  { { { 14, 0, 2 }, { 0, 43, 0 } } },\n  { { { 15, 0, 1 }, { 0, 44, 0 } } },\n  { { { 15, 0, 0 }, { 0, 45, 0 } } },\n  { { { 15, 0, 1 }, { 8, 30, 0 } } },\n  { { { 15, 0, 2 }, { 0, 46, 0 } } },\n  { { { 16, 0, 2 }, { 0, 47, 0 } } },\n  { { { 16, 0, 1 }, { 1, 46, 0 } } },\n  { { { 16, 0, 0 }, { 0, 48, 0 } } },\n  { { { 16, 0, 1 }, { 0, 49, 0 } } },\n  { { { 16, 0, 2 }, { 0, 50, 0 } } },\n  { { { 17, 0, 1 }, { 2, 47, 0 } } },\n  { { { 17, 0, 0 }, { 0, 51, 0 } } },\n  { { { 17, 0, 1 }, { 0, 52, 0 } } },\n  { { { 17, 0, 2 }, { 0, 53, 0 } } },\n  { { { 18, 0, 1 }, { 4, 46, 0 } } },\n  { { { 18, 0, 0 }, { 0, 54, 0 } } },\n  { { { 18, 0, 1 }, { 0, 55, 0 } } },\n  { { { 18, 0, 2 }, { 0, 56, 0 } } },\n  { { { 19, 0, 1 }, { 5, 47, 0 } } },\n  { { { 19, 0, 0 }, { 0, 57, 0 } } },\n  { { { 19, 0, 1 }, { 0, 58, 0 } } },\n  { { { 19, 0, 2 }, { 0, 59, 0 } } },\n  { { { 20, 0, 1 }, { 7, 46, 0 } } },\n  { { { 20, 0, 0 }, { 0, 60, 0 } } },\n  { { { 20, 0, 1 }, { 0, 61, 0 } } },\n  { { { 20, 0, 2 }, { 0, 62, 0 } } },\n  { { { 21, 0, 1 }, { 8, 47, 0 } } },\n  { { { 21, 0, 0 }, { 0, 63, 0 } } },\n  { { { 21, 0, 1 }, { 1, 62, 0 } } },\n  { { { 21, 0, 2 }, { 1, 63, 0 } } },\n  { { { 22, 0, 1 }, { 10, 46, 0 } } },\n  { { { 22, 0, 0 }, { 2, 62, 0 } } },\n  { { { 22, 0, 1 }, { 2, 63, 0 } } },\n  { { { 22, 0, 2 }, { 3, 62, 0 } } },\n  { { { 23, 0, 1 }, { 11, 47, 0 } } },\n  { { { 23, 0, 0 }, { 3, 63, 0 } } },\n  { { { 23, 0, 1 }, { 4, 62, 0 } } },\n  { { { 23, 0, 2 }, { 4, 63, 0 } } },\n  { { { 24, 0, 1 }, { 13, 46, 0 } } },\n  { { { 24, 0, 0 }, { 5, 62, 0 } } },\n  { { { 24, 0, 1 }, { 5, 63, 0 } } },\n  { { { 24, 0, 2 }, { 6, 62, 0 } } },\n  { { { 25, 0, 1 }, { 14, 47, 0 } } },\n  { { { 25, 0, 0 }, { 6, 63, 0 } } },\n  { { { 25, 0, 1 }, { 7, 62, 0 } } },\n  { { { 25, 0, 2 }, { 7, 63, 0 } } },\n  { { { 26, 0, 1 }, { 16, 45, 0 } } },\n  { { { 26, 0, 0 }, { 8, 62, 0 } } },\n  { { { 26, 0, 1 }, { 8, 63, 0 } } },\n  { { { 26, 0, 2 }, { 9, 62, 0 } } },\n  { { { 27, 0, 1 }, { 16, 48, 0 } } },\n  { { { 27, 0, 0 }, { 9, 63, 0 } } },\n  { { { 27, 0, 1 }, { 10, 62, 0 } } },\n  { { { 27, 0, 2 }, { 10, 63, 0 } } },\n  { { { 28, 0, 1 }, { 16, 51, 0 } } },\n  { { { 28, 0, 0 }, { 11, 62, 0 } } },\n  { { { 28, 0, 1 }, { 11, 63, 0 } } },\n  { { { 28, 0, 2 }, { 12, 62, 0 } } },\n  { { { 29, 0, 1 }, { 16, 54, 0 } } },\n  { { { 29, 0, 0 }, { 12, 63, 0 } } },\n  { { { 29, 0, 1 }, { 13, 62, 0 } } },\n  { { { 29, 0, 2 }, { 13, 63, 0 } } },\n  { { { 30, 0, 1 }, { 16, 57, 0 } } },\n  { { { 30, 0, 0 }, { 14, 62, 0 } } },\n  { { { 30, 0, 1 }, { 14, 63, 0 } } },\n  { { { 30, 0, 2 }, { 15, 62, 0 } } },\n  { { { 31, 0, 1 }, { 16, 60, 0 } } },\n  { { { 31, 0, 0 }, { 15, 63, 0 } } },\n  { { { 31, 0, 1 }, { 24, 46, 0 } } },\n  { { { 31, 0, 2 }, { 16, 62, 0 } } },\n  { { { 32, 0, 2 }, { 16, 63, 0 } } },\n  { { { 32, 0, 1 }, { 17, 62, 0 } } },\n  { { { 32, 0, 0 }, { 25, 47, 0 } } },\n  { { { 32, 0, 1 }, { 17, 63, 0 } } },\n  { { { 32, 0, 2 }, { 18, 62, 0 } } },\n  { { { 33, 0, 1 }, { 18, 63, 0 } } },\n  { { { 33, 0, 0 }, { 27, 46, 0 } } },\n  { { { 33, 0, 1 }, { 19, 62, 0 } } },\n  { { { 33, 0, 2 }, { 19, 63, 0 } } },\n  { { { 34, 0, 1 }, { 20, 62, 0 } } },\n  { { { 34, 0, 0 }, { 28, 47, 0 } } },\n  { { { 34, 0, 1 }, { 20, 63, 0 } } },\n  { { { 34, 0, 2 }, { 21, 62, 0 } } },\n  { { { 35, 0, 1 }, { 21, 63, 0 } } },\n  { { { 35, 0, 0 }, { 30, 46, 0 } } },\n  { { { 35, 0, 1 }, { 22, 62, 0 } } },\n  { { { 35, 0, 2 }, { 22, 63, 0 } } },\n  { { { 36, 0, 1 }, { 23, 62, 0 } } },\n  { { { 36, 0, 0 }, { 31, 47, 0 } } },\n  { { { 36, 0, 1 }, { 23, 63, 0 } } },\n  { { { 36, 0, 2 }, { 24, 62, 0 } } },\n  { { { 37, 0, 1 }, { 24, 63, 0 } } },\n  { { { 37, 0, 0 }, { 32, 47, 0 } } },\n  { { { 37, 0, 1 }, { 25, 62, 0 } } },\n  { { { 37, 0, 2 }, { 25, 63, 0 } } },\n  { { { 38, 0, 1 }, { 26, 62, 0 } } },\n  { { { 38, 0, 0 }, { 32, 50, 0 } } },\n  { { { 38, 0, 1 }, { 26, 63, 0 } } },\n  { { { 38, 0, 2 }, { 27, 62, 0 } } },\n  { { { 39, 0, 1 }, { 27, 63, 0 } } },\n  { { { 39, 0, 0 }, { 32, 53, 0 } } },\n  { { { 39, 0, 1 }, { 28, 62, 0 } } },\n  { { { 39, 0, 2 }, { 28, 63, 0 } } },\n  { { { 40, 0, 1 }, { 29, 62, 0 } } },\n  { { { 40, 0, 0 }, { 32, 56, 0 } } },\n  { { { 40, 0, 1 }, { 29, 63, 0 } } },\n  { { { 40, 0, 2 }, { 30, 62, 0 } } },\n  { { { 41, 0, 1 }, { 30, 63, 0 } } },\n  { { { 41, 0, 0 }, { 32, 59, 0 } } },\n  { { { 41, 0, 1 }, { 31, 62, 0 } } },\n  { { { 41, 0, 2 }, { 31, 63, 0 } } },\n  { { { 42, 0, 1 }, { 32, 61, 0 } } },\n  { { { 42, 0, 0 }, { 32, 62, 0 } } },\n  { { { 42, 0, 1 }, { 32, 63, 0 } } },\n  { { { 42, 0, 2 }, { 41, 46, 0 } } },\n  { { { 43, 0, 1 }, { 33, 62, 0 } } },\n  { { { 43, 0, 0 }, { 33, 63, 0 } } },\n  { { { 43, 0, 1 }, { 34, 62, 0 } } },\n  { { { 43, 0, 2 }, { 42, 47, 0 } } },\n  { { { 44, 0, 1 }, { 34, 63, 0 } } },\n  { { { 44, 0, 0 }, { 35, 62, 0 } } },\n  { { { 44, 0, 1 }, { 35, 63, 0 } } },\n  { { { 44, 0, 2 }, { 44, 46, 0 } } },\n  { { { 45, 0, 1 }, { 36, 62, 0 } } },\n  { { { 45, 0, 0 }, { 36, 63, 0 } } },\n  { { { 45, 0, 1 }, { 37, 62, 0 } } },\n  { { { 45, 0, 2 }, { 45, 47, 0 } } },\n  { { { 46, 0, 1 }, { 37, 63, 0 } } },\n  { { { 46, 0, 0 }, { 38, 62, 0 } } },\n  { { { 46, 0, 1 }, { 38, 63, 0 } } },\n  { { { 46, 0, 2 }, { 47, 46, 0 } } },\n  { { { 47, 0, 1 }, { 39, 62, 0 } } },\n  { { { 47, 0, 0 }, { 39, 63, 0 } } },\n  { { { 47, 0, 1 }, { 40, 62, 0 } } },\n  { { { 47, 0, 2 }, { 48, 46, 0 } } },\n  { { { 48, 0, 2 }, { 40, 63, 0 } } },\n  { { { 48, 0, 1 }, { 41, 62, 0 } } },\n  { { { 48, 0, 0 }, { 41, 63, 0 } } },\n  { { { 48, 0, 1 }, { 48, 49, 0 } } },\n  { { { 48, 0, 2 }, { 42, 62, 0 } } },\n  { { { 49, 0, 1 }, { 42, 63, 0 } } },\n  { { { 49, 0, 0 }, { 43, 62, 0 } } },\n  { { { 49, 0, 1 }, { 48, 52, 0 } } },\n  { { { 49, 0, 2 }, { 43, 63, 0 } } },\n  { { { 50, 0, 1 }, { 44, 62, 0 } } },\n  { { { 50, 0, 0 }, { 44, 63, 0 } } },\n  { { { 50, 0, 1 }, { 48, 55, 0 } } },\n  { { { 50, 0, 2 }, { 45, 62, 0 } } },\n  { { { 51, 0, 1 }, { 45, 63, 0 } } },\n  { { { 51, 0, 0 }, { 46, 62, 0 } } },\n  { { { 51, 0, 1 }, { 48, 58, 0 } } },\n  { { { 51, 0, 2 }, { 46, 63, 0 } } },\n  { { { 52, 0, 1 }, { 47, 62, 0 } } },\n  { { { 52, 0, 0 }, { 47, 63, 0 } } },\n  { { { 52, 0, 1 }, { 48, 61, 0 } } },\n  { { { 52, 0, 2 }, { 48, 62, 0 } } },\n  { { { 53, 0, 1 }, { 56, 47, 0 } } },\n  { { { 53, 0, 0 }, { 48, 63, 0 } } },\n  { { { 53, 0, 1 }, { 49, 62, 0 } } },\n  { { { 53, 0, 2 }, { 49, 63, 0 } } },\n  { { { 54, 0, 1 }, { 58, 46, 0 } } },\n  { { { 54, 0, 0 }, { 50, 62, 0 } } },\n  { { { 54, 0, 1 }, { 50, 63, 0 } } },\n  { { { 54, 0, 2 }, { 51, 62, 0 } } },\n  { { { 55, 0, 1 }, { 59, 47, 0 } } },\n  { { { 55, 0, 0 }, { 51, 63, 0 } } },\n  { { { 55, 0, 1 }, { 52, 62, 0 } } },\n  { { { 55, 0, 2 }, { 52, 63, 0 } } },\n  { { { 56, 0, 1 }, { 61, 46, 0 } } },\n  { { { 56, 0, 0 }, { 53, 62, 0 } } },\n  { { { 56, 0, 1 }, { 53, 63, 0 } } },\n  { { { 56, 0, 2 }, { 54, 62, 0 } } },\n  { { { 57, 0, 1 }, { 62, 47, 0 } } },\n  { { { 57, 0, 0 }, { 54, 63, 0 } } },\n  { { { 57, 0, 1 }, { 55, 62, 0 } } },\n  { { { 57, 0, 2 }, { 55, 63, 0 } } },\n  { { { 58, 0, 1 }, { 56, 62, 1 } } },\n  { { { 58, 0, 0 }, { 56, 62, 0 } } },\n  { { { 58, 0, 1 }, { 56, 63, 0 } } },\n  { { { 58, 0, 2 }, { 57, 62, 0 } } },\n  { { { 59, 0, 1 }, { 57, 63, 1 } } },\n  { { { 59, 0, 0 }, { 57, 63, 0 } } },\n  { { { 59, 0, 1 }, { 58, 62, 0 } } },\n  { { { 59, 0, 2 }, { 58, 63, 0 } } },\n  { { { 60, 0, 1 }, { 59, 62, 1 } } },\n  { { { 60, 0, 0 }, { 59, 62, 0 } } },\n  { { { 60, 0, 1 }, { 59, 63, 0 } } },\n  { { { 60, 0, 2 }, { 60, 62, 0 } } },\n  { { { 61, 0, 1 }, { 60, 63, 1 } } },\n  { { { 61, 0, 0 }, { 60, 63, 0 } } },\n  { { { 61, 0, 1 }, { 61, 62, 0 } } },\n  { { { 61, 0, 2 }, { 61, 63, 0 } } },\n  { { { 62, 0, 1 }, { 62, 62, 1 } } },\n  { { { 62, 0, 0 }, { 62, 62, 0 } } },\n  { { { 62, 0, 1 }, { 62, 63, 0 } } },\n  { { { 62, 0, 2 }, { 63, 62, 0 } } },\n  { { { 63, 0, 1 }, { 63, 63, 1 } } },\n  { { { 63, 0, 0 }, { 63, 63, 0 } } }\n};\n\nstatic const DDSSingleColourLookup*\n  DDS_LOOKUP[] =\n{\n  DDSLookup_5_4,\n  DDSLookup_6_4,\n  DDSLookup_5_4\n};\n\n/*\n  Macros\n*/\n#define C565_r(x) (((x) & 0xF800) >> 11)\n#define C565_g(x) (((x) & 0x07E0) >> 5)\n#define C565_b(x)  ((x) & 0x001F)\n\n#define C565_red(x)   ( (C565_r(x) << 3 | C565_r(x) >> 2))\n#define C565_green(x) ( (C565_g(x) << 2 | C565_g(x) >> 4))\n#define C565_blue(x)  ( (C565_b(x) << 3 | C565_b(x) >> 2))\n\n#define DIV2(x)  ((x) > 1 ? ((x) >> 1) : 1)\n\n#define FixRange(min, max, steps) \\\nif (min > max) \\\n  min = max; \\\nif (max - min < steps) \\\n  max = MagickMin(min + steps, 255); \\\nif (max - min < steps) \\\n  min = MagickMax(min - steps, 0)\n\n#define Dot(left, right) (left.x*right.x) + (left.y*right.y) + (left.z*right.z)\n\n#define VectorInit(vector, value) vector.x = vector.y = vector.z = vector.w \\\n  = value\n#define VectorInit3(vector, value) vector.x = vector.y = vector.z = value\n\n#define IsBitMask(mask, r, g, b, a) (mask.r_bitmask == r && mask.g_bitmask == \\\n  g && mask.b_bitmask == b && mask.alpha_bitmask == a)\n\n/*\n  Forward declarations\n*/\nstatic MagickBooleanType\n  ConstructOrdering(const size_t,const DDSVector4 *,const DDSVector3,\n    DDSVector4 *,DDSVector4 *,unsigned char *,size_t),\n  ReadDDSInfo(Image *,DDSInfo *),\n  ReadDXT1(Image *,DDSInfo *,ExceptionInfo *),\n  ReadDXT3(Image *,DDSInfo *,ExceptionInfo *),\n  ReadDXT5(Image *,DDSInfo *,ExceptionInfo *),\n  ReadUncompressedRGB(Image *,DDSInfo *,ExceptionInfo *),\n  ReadUncompressedRGBA(Image *,DDSInfo *,ExceptionInfo *),\n  SkipDXTMipmaps(Image *,DDSInfo *,int,ExceptionInfo *),\n  SkipRGBMipmaps(Image *,DDSInfo *,int,ExceptionInfo *),\n  WriteDDSImage(const ImageInfo *,Image *),\n  WriteMipmaps(Image *,const size_t,const size_t,const size_t,\n    const MagickBooleanType,const MagickBooleanType,ExceptionInfo *);\n\nstatic void\n  RemapIndices(const ssize_t *,const unsigned char *,unsigned char *),\n  WriteDDSInfo(Image *,const size_t,const size_t,const size_t),\n  WriteFourCC(Image *,const size_t,const MagickBooleanType,\n    const MagickBooleanType,ExceptionInfo *),\n  WriteImageData(Image *,const size_t,const size_t,const MagickBooleanType,\n    const MagickBooleanType,ExceptionInfo *),\n  WriteIndices(Image *,const DDSVector3,const DDSVector3, unsigned char *),\n  WriteSingleColorFit(Image *,const DDSVector4 *,const ssize_t *),\n  WriteUncompressed(Image *,ExceptionInfo *);\n\nstatic inline void VectorAdd(const DDSVector4 left, const DDSVector4 right,\n  DDSVector4 *destination)\n{\n  destination->x = left.x + right.x;\n  destination->y = left.y + right.y;\n  destination->z = left.z + right.z;\n  destination->w = left.w + right.w;\n}\n\nstatic inline void VectorClamp(DDSVector4 *value)\n{\n  value->x = MagickMin(1.0f,MagickMax(0.0f,value->x));\n  value->y = MagickMin(1.0f,MagickMax(0.0f,value->y));\n  value->z = MagickMin(1.0f,MagickMax(0.0f,value->z));\n  value->w = MagickMin(1.0f,MagickMax(0.0f,value->w));\n}\n\nstatic inline void VectorClamp3(DDSVector3 *value)\n{\n  value->x = MagickMin(1.0f,MagickMax(0.0f,value->x));\n  value->y = MagickMin(1.0f,MagickMax(0.0f,value->y));\n  value->z = MagickMin(1.0f,MagickMax(0.0f,value->z));\n}\n\nstatic inline void VectorCopy43(const DDSVector4 source,\n  DDSVector3 *destination)\n{\n  destination->x = source.x;\n  destination->y = source.y;\n  destination->z = source.z;\n}\n\nstatic inline void VectorCopy44(const DDSVector4 source,\n  DDSVector4 *destination)\n{\n  destination->x = source.x;\n  destination->y = source.y;\n  destination->z = source.z;\n  destination->w = source.w;\n}\n\nstatic inline void VectorNegativeMultiplySubtract(const DDSVector4 a,\n  const DDSVector4 b, const DDSVector4 c, DDSVector4 *destination)\n{\n  destination->x = c.x - (a.x * b.x);\n  destination->y = c.y - (a.y * b.y);\n  destination->z = c.z - (a.z * b.z);\n  destination->w = c.w - (a.w * b.w);\n}\n\nstatic inline void VectorMultiply(const DDSVector4 left,\n  const DDSVector4 right, DDSVector4 *destination)\n{\n  destination->x = left.x * right.x;\n  destination->y = left.y * right.y;\n  destination->z = left.z * right.z;\n  destination->w = left.w * right.w;\n}\n\nstatic inline void VectorMultiply3(const DDSVector3 left,\n  const DDSVector3 right, DDSVector3 *destination)\n{\n  destination->x = left.x * right.x;\n  destination->y = left.y * right.y;\n  destination->z = left.z * right.z;\n}\n\nstatic inline void VectorMultiplyAdd(const DDSVector4 a, const DDSVector4 b,\n  const DDSVector4 c, DDSVector4 *destination)\n{\n  destination->x = (a.x * b.x) + c.x;\n  destination->y = (a.y * b.y) + c.y;\n  destination->z = (a.z * b.z) + c.z;\n  destination->w = (a.w * b.w) + c.w;\n}\n\nstatic inline void VectorMultiplyAdd3(const DDSVector3 a, const DDSVector3 b,\n  const DDSVector3 c, DDSVector3 *destination)\n{\n  destination->x = (a.x * b.x) + c.x;\n  destination->y = (a.y * b.y) + c.y;\n  destination->z = (a.z * b.z) + c.z;\n}\n\nstatic inline void VectorReciprocal(const DDSVector4 value,\n  DDSVector4 *destination)\n{\n  destination->x = 1.0f / value.x;\n  destination->y = 1.0f / value.y;\n  destination->z = 1.0f / value.z;\n  destination->w = 1.0f / value.w;\n}\n\nstatic inline void VectorSubtract(const DDSVector4 left,\n  const DDSVector4 right, DDSVector4 *destination)\n{\n  destination->x = left.x - right.x;\n  destination->y = left.y - right.y;\n  destination->z = left.z - right.z;\n  destination->w = left.w - right.w;\n}\n\nstatic inline void VectorSubtract3(const DDSVector3 left,\n  const DDSVector3 right, DDSVector3 *destination)\n{\n  destination->x = left.x - right.x;\n  destination->y = left.y - right.y;\n  destination->z = left.z - right.z;\n}\n\nstatic inline void VectorTruncate(DDSVector4 *value)\n{\n  value->x = value->x > 0.0f ? floor(value->x) : ceil(value->x);\n  value->y = value->y > 0.0f ? floor(value->y) : ceil(value->y);\n  value->z = value->z > 0.0f ? floor(value->z) : ceil(value->z);\n  value->w = value->w > 0.0f ? floor(value->w) : ceil(value->w);\n}\n\nstatic inline void VectorTruncate3(DDSVector3 *value)\n{\n  value->x = value->x > 0.0f ? floor(value->x) : ceil(value->x);\n  value->y = value->y > 0.0f ? floor(value->y) : ceil(value->y);\n  value->z = value->z > 0.0f ? floor(value->z) : ceil(value->z);\n}\n\nstatic void CalculateColors(unsigned short c0, unsigned short c1,\n  DDSColors *c, MagickBooleanType ignoreAlpha)\n{\n  c->a[0] = c->a[1] = c->a[2] = c->a[3] = 0;\n\n  c->r[0] = (unsigned char) C565_red(c0);\n  c->g[0] = (unsigned char) C565_green(c0);\n  c->b[0] = (unsigned char) C565_blue(c0);\n\n  c->r[1] = (unsigned char) C565_red(c1);\n  c->g[1] = (unsigned char) C565_green(c1);\n  c->b[1] = (unsigned char) C565_blue(c1);\n\n  if (ignoreAlpha != MagickFalse || c0 > c1)\n    {\n      c->r[2] = (unsigned char) ((2 * c->r[0] + c->r[1]) / 3);\n      c->g[2] = (unsigned char) ((2 * c->g[0] + c->g[1]) / 3);\n      c->b[2] = (unsigned char) ((2 * c->b[0] + c->b[1]) / 3);\n\n      c->r[3] = (unsigned char) ((c->r[0] + 2 * c->r[1]) / 3);\n      c->g[3] = (unsigned char) ((c->g[0] + 2 * c->g[1]) / 3);\n      c->b[3] = (unsigned char) ((c->b[0] + 2 * c->b[1]) / 3);\n    }\n  else\n    {\n      c->r[2] = (unsigned char) ((c->r[0] + c->r[1]) / 2);\n      c->g[2] = (unsigned char) ((c->g[0] + c->g[1]) / 2);\n      c->b[2] = (unsigned char) ((c->b[0] + c->b[1]) / 2);\n\n      c->r[3] = c->g[3] = c->b[3] = 0;\n      c->a[3] = 255;\n    }\n}\n\nstatic size_t CompressAlpha(const size_t min, const size_t max,\n  const size_t steps, const ssize_t *alphas, unsigned char* indices)\n{\n  unsigned char\n    codes[8];\n\n  register ssize_t\n    i;\n\n  size_t\n    error,\n    index,\n    j,\n    least,\n    value;\n\n  codes[0] = (unsigned char) min;\n  codes[1] = (unsigned char) max;\n  codes[6] = 0;\n  codes[7] = 255;\n\n  for (i=1; i < (ssize_t) steps; i++)\n    codes[i+1] = (unsigned char) (((steps-i)*min + i*max) / steps);\n\n  error = 0;\n  for (i=0; i<16; i++)\n  {\n    if (alphas[i] == -1)\n      {\n        indices[i] = 0;\n        continue;\n      }\n\n    value = alphas[i];\n    least = SIZE_MAX;\n    index = 0;\n    for (j=0; j<8; j++)\n    {\n      size_t\n        dist;\n\n      dist = value - (size_t)codes[j];\n      dist *= dist;\n\n      if (dist < least)\n        {\n          least = dist;\n          index = j;\n        }\n    }\n\n    indices[i] = (unsigned char)index;\n    error += least;\n  }\n\n  return error;\n}\n\nstatic void CompressClusterFit(const size_t count,\n  const DDSVector4 *points, const ssize_t *map, const DDSVector3 principle,\n  const DDSVector4 metric, DDSVector3 *start, DDSVector3 *end,\n  unsigned char *indices)\n{\n  DDSVector3\n    axis;\n\n  DDSVector4\n    grid,\n    gridrcp,\n    half,\n    onethird_onethird2,\n    pointsWeights[16],\n    two,\n    twonineths,\n    twothirds_twothirds2,\n    xSumwSum;\n\n  float\n    bestError = 1e+37f;\n\n  size_t\n    bestIteration = 0,\n    besti = 0,\n    bestj = 0,\n    bestk = 0,\n    iterationIndex;\n\n  ssize_t\n    i;\n\n  unsigned char\n    *o,\n    order[128],\n    unordered[16];\n\n  VectorInit(half,0.5f);\n  VectorInit(two,2.0f);\n\n  VectorInit(onethird_onethird2,1.0f/3.0f);\n  onethird_onethird2.w = 1.0f/9.0f;\n  VectorInit(twothirds_twothirds2,2.0f/3.0f);\n  twothirds_twothirds2.w = 4.0f/9.0f;\n  VectorInit(twonineths,2.0f/9.0f);\n\n  grid.x = 31.0f;\n  grid.y = 63.0f;\n  grid.z = 31.0f;\n  grid.w = 0.0f;\n\n  gridrcp.x = 1.0f/31.0f;\n  gridrcp.y = 1.0f/63.0f;\n  gridrcp.z = 1.0f/31.0f;\n  gridrcp.w = 0.0f;\n\n  xSumwSum.x = 0.0f;\n  xSumwSum.y = 0.0f;\n  xSumwSum.z = 0.0f;\n  xSumwSum.w = 0.0f;\n\n  ConstructOrdering(count,points,principle,pointsWeights,&xSumwSum,order,0);\n\n  for (iterationIndex = 0;;)\n  {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(dynamic,1) \\\n    num_threads(GetMagickResourceLimit(ThreadResource))\n#endif\n    for (i=0; i < (ssize_t) count; i++)\n    {\n      DDSVector4\n        part0,\n        part1,\n        part2;\n\n      size_t\n        ii,\n        j,\n        k,\n        kmin;\n\n      VectorInit(part0,0.0f);\n      for(ii=0; ii < (size_t) i; ii++)\n        VectorAdd(pointsWeights[ii],part0,&part0);\n\n      VectorInit(part1,0.0f);\n      for (j=(size_t) i;;)\n      {\n        if (j == 0)\n          {\n            VectorCopy44(pointsWeights[0],&part2);\n            kmin = 1;\n          }\n          else\n          {\n            VectorInit(part2,0.0f);\n            kmin = j;\n          }\n\n        for (k=kmin;;)\n        {\n          DDSVector4\n            a,\n            alpha2_sum,\n            alphax_sum,\n            alphabeta_sum,\n            b,\n            beta2_sum,\n            betax_sum,\n            e1,\n            e2,\n            factor,\n            part3;\n\n          float\n            error;\n\n          VectorSubtract(xSumwSum,part2,&part3);\n          VectorSubtract(part3,part1,&part3);\n          VectorSubtract(part3,part0,&part3);\n\n          VectorMultiplyAdd(part1,twothirds_twothirds2,part0,&alphax_sum);\n          VectorMultiplyAdd(part2,onethird_onethird2,alphax_sum,&alphax_sum);\n          VectorInit(alpha2_sum,alphax_sum.w);\n\n          VectorMultiplyAdd(part2,twothirds_twothirds2,part3,&betax_sum);\n          VectorMultiplyAdd(part1,onethird_onethird2,betax_sum,&betax_sum);\n          VectorInit(beta2_sum,betax_sum.w);\n\n          VectorAdd(part1,part2,&alphabeta_sum);\n          VectorInit(alphabeta_sum,alphabeta_sum.w);\n          VectorMultiply(twonineths,alphabeta_sum,&alphabeta_sum);\n\n          VectorMultiply(alpha2_sum,beta2_sum,&factor);\n          VectorNegativeMultiplySubtract(alphabeta_sum,alphabeta_sum,factor,\n            &factor);\n          VectorReciprocal(factor,&factor);\n\n          VectorMultiply(alphax_sum,beta2_sum,&a);\n          VectorNegativeMultiplySubtract(betax_sum,alphabeta_sum,a,&a);\n          VectorMultiply(a,factor,&a);\n\n          VectorMultiply(betax_sum,alpha2_sum,&b);\n          VectorNegativeMultiplySubtract(alphax_sum,alphabeta_sum,b,&b);\n          VectorMultiply(b,factor,&b);\n\n          VectorClamp(&a);\n          VectorMultiplyAdd(grid,a,half,&a);\n          VectorTruncate(&a);\n          VectorMultiply(a,gridrcp,&a);\n\n          VectorClamp(&b);\n          VectorMultiplyAdd(grid,b,half,&b);\n          VectorTruncate(&b);\n          VectorMultiply(b,gridrcp,&b);\n\n          VectorMultiply(b,b,&e1);\n          VectorMultiply(e1,beta2_sum,&e1);\n          VectorMultiply(a,a,&e2);\n          VectorMultiplyAdd(e2,alpha2_sum,e1,&e1);\n\n          VectorMultiply(a,b,&e2);\n          VectorMultiply(e2,alphabeta_sum,&e2);\n          VectorNegativeMultiplySubtract(a,alphax_sum,e2,&e2);\n          VectorNegativeMultiplySubtract(b,betax_sum,e2,&e2);\n          VectorMultiplyAdd(two,e2,e1,&e2);\n          VectorMultiply(e2,metric,&e2);\n\n          error = e2.x + e2.y + e2.z;\n\n          if (error < bestError)\n            {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp critical (DDS_CompressClusterFit)\n#endif\n              {\n                if (error < bestError)\n                  {\n                    VectorCopy43(a,start);\n                    VectorCopy43(b,end);\n                    bestError = error;\n                    besti = i;\n                    bestj = j;\n                    bestk = k;\n                    bestIteration = iterationIndex;\n                  }\n              }\n            }\n\n          if (k == count)\n            break;\n\n          VectorAdd(pointsWeights[k],part2,&part2);\n          k++;\n        }\n\n        if (j == count)\n          break;\n\n        VectorAdd(pointsWeights[j],part1,&part1);\n        j++;\n      }\n    }\n\n    if (bestIteration != iterationIndex)\n      break;\n\n    iterationIndex++;\n    if (iterationIndex == 8)\n      break;\n\n    VectorSubtract3(*end,*start,&axis);\n    if (ConstructOrdering(count,points,axis,pointsWeights,&xSumwSum,order,\n      iterationIndex) == MagickFalse)\n      break;\n  }\n\n  o = order + (16*bestIteration);\n\n  for (i=0; i < (ssize_t) besti; i++)\n    unordered[o[i]] = 0;\n  for (i=besti; i < (ssize_t) bestj; i++)\n    unordered[o[i]] = 2;\n  for (i=bestj; i < (ssize_t) bestk; i++)\n    unordered[o[i]] = 3;\n  for (i=bestk; i < (ssize_t) count; i++)\n    unordered[o[i]] = 1;\n\n  RemapIndices(map,unordered,indices);\n}\n\nstatic void CompressRangeFit(const size_t count,\n  const DDSVector4 *points, const ssize_t *map, const DDSVector3 principle,\n  const DDSVector4 metric, DDSVector3 *start, DDSVector3 *end,\n  unsigned char *indices)\n{\n  float\n    d,\n    bestDist,\n    max,\n    min,\n    val;\n\n  DDSVector3\n    codes[4],\n    grid,\n    gridrcp,\n    half,\n    dist;\n\n  register ssize_t\n    i;\n\n  size_t\n    bestj,\n    j;\n\n  unsigned char\n    closest[16];\n\n  VectorInit3(half,0.5f);\n\n  grid.x = 31.0f;\n  grid.y = 63.0f;\n  grid.z = 31.0f;\n\n  gridrcp.x = 1.0f/31.0f;\n  gridrcp.y = 1.0f/63.0f;\n  gridrcp.z = 1.0f/31.0f;\n\n  if (count > 0)\n    {\n      VectorCopy43(points[0],start);\n      VectorCopy43(points[0],end);\n\n      min = max = Dot(points[0],principle);\n      for (i=1; i < (ssize_t) count; i++)\n      {\n        val = Dot(points[i],principle);\n        if (val < min)\n        {\n          VectorCopy43(points[i],start);\n          min = val;\n        }\n        else if (val > max)\n        {\n          VectorCopy43(points[i],end);\n          max = val;\n        }\n      }\n    }\n\n  VectorClamp3(start);\n  VectorMultiplyAdd3(grid,*start,half,start);\n  VectorTruncate3(start);\n  VectorMultiply3(*start,gridrcp,start);\n\n  VectorClamp3(end);\n  VectorMultiplyAdd3(grid,*end,half,end);\n  VectorTruncate3(end);\n  VectorMultiply3(*end,gridrcp,end);\n\n  codes[0] = *start;\n  codes[1] = *end;\n  codes[2].x = (start->x * (2.0f/3.0f)) + (end->x * (1.0f/3.0f));\n  codes[2].y = (start->y * (2.0f/3.0f)) + (end->y * (1.0f/3.0f));\n  codes[2].z = (start->z * (2.0f/3.0f)) + (end->z * (1.0f/3.0f));\n  codes[3].x = (start->x * (1.0f/3.0f)) + (end->x * (2.0f/3.0f));\n  codes[3].y = (start->y * (1.0f/3.0f)) + (end->y * (2.0f/3.0f));\n  codes[3].z = (start->z * (1.0f/3.0f)) + (end->z * (2.0f/3.0f));\n\n  for (i=0; i < (ssize_t) count; i++)\n  {\n    bestDist = 1e+37f;\n    bestj = 0;\n    for (j=0; j < 4; j++)\n    {\n      dist.x = (points[i].x - codes[j].x) * metric.x;\n      dist.y = (points[i].y - codes[j].y) * metric.y;\n      dist.z = (points[i].z - codes[j].z) * metric.z;\n\n      d = Dot(dist,dist);\n      if (d < bestDist)\n        {\n          bestDist = d;\n          bestj = j;\n        }\n    }\n\n    closest[i] = (unsigned char) bestj;\n  }\n\n  RemapIndices(map, closest, indices);\n}\n\nstatic void ComputeEndPoints(const DDSSingleColourLookup *lookup[],\n  const unsigned char *color, DDSVector3 *start, DDSVector3 *end,\n  unsigned char *index)\n{\n  register ssize_t\n    i;\n\n  size_t\n    c,\n    maxError = SIZE_MAX;\n\n  for (i=0; i < 2; i++)\n  {\n    const DDSSourceBlock*\n      sources[3];\n\n      size_t\n        error = 0;\n\n    for (c=0; c < 3; c++)\n    {\n      sources[c] = &lookup[c][color[c]].sources[i];\n      error += ((size_t) sources[c]->error) * ((size_t) sources[c]->error);\n    }\n\n    if (error > maxError)\n      continue;\n\n    start->x = (float) sources[0]->start / 31.0f;\n    start->y = (float) sources[1]->start / 63.0f;\n    start->z = (float) sources[2]->start / 31.0f;\n\n    end->x = (float) sources[0]->end / 31.0f;\n    end->y = (float) sources[1]->end / 63.0f;\n    end->z = (float) sources[2]->end / 31.0f;\n\n    *index = (unsigned char) (2*i);\n    maxError = error;\n  }\n}\n\nstatic void ComputePrincipleComponent(const float *covariance,\n  DDSVector3 *principle)\n{\n  DDSVector4\n    row0,\n    row1,\n    row2,\n    v;\n\n  register ssize_t\n    i;\n\n  row0.x = covariance[0];\n  row0.y = covariance[1];\n  row0.z = covariance[2];\n  row0.w = 0.0f;\n\n  row1.x = covariance[1];\n  row1.y = covariance[3];\n  row1.z = covariance[4];\n  row1.w = 0.0f;\n\n  row2.x = covariance[2];\n  row2.y = covariance[4];\n  row2.z = covariance[5];\n  row2.w = 0.0f;\n\n  VectorInit(v,1.0f);\n\n  for (i=0; i < 8; i++)\n  {\n    DDSVector4\n      w;\n\n    float\n      a;\n\n    w.x = row0.x * v.x;\n    w.y = row0.y * v.x;\n    w.z = row0.z * v.x;\n    w.w = row0.w * v.x;\n\n    w.x = (row1.x * v.y) + w.x;\n    w.y = (row1.y * v.y) + w.y;\n    w.z = (row1.z * v.y) + w.z;\n    w.w = (row1.w * v.y) + w.w;\n\n    w.x = (row2.x * v.z) + w.x;\n    w.y = (row2.y * v.z) + w.y;\n    w.z = (row2.z * v.z) + w.z;\n    w.w = (row2.w * v.z) + w.w;\n\n    a = 1.0f / MagickMax(w.x,MagickMax(w.y,w.z));\n\n    v.x = w.x * a;\n    v.y = w.y * a;\n    v.z = w.z * a;\n    v.w = w.w * a;\n  }\n\n  VectorCopy43(v,principle);\n}\n\nstatic void ComputeWeightedCovariance(const size_t count,\n  const DDSVector4 *points, float *covariance)\n{\n  DDSVector3\n    centroid;\n\n  float\n    total;\n\n  size_t\n    i;\n\n  total = 0.0f;\n  VectorInit3(centroid,0.0f);\n\n  for (i=0; i < count; i++)\n  {\n    total += points[i].w;\n    centroid.x += (points[i].x * points[i].w);\n    centroid.y += (points[i].y * points[i].w);\n    centroid.z += (points[i].z * points[i].w);\n  }\n\n  if( total > 1.192092896e-07F)\n    {\n      centroid.x /= total;\n      centroid.y /= total;\n      centroid.z /= total;\n    }\n\n  for (i=0; i < 6; i++)\n    covariance[i] = 0.0f;\n\n  for (i = 0; i < count; i++)\n  {\n    DDSVector3\n      a,\n      b;\n\n    a.x = points[i].x - centroid.x;\n    a.y = points[i].y - centroid.y;\n    a.z = points[i].z - centroid.z;\n\n    b.x = points[i].w * a.x;\n    b.y = points[i].w * a.y;\n    b.z = points[i].w * a.z;\n\n    covariance[0] += a.x*b.x;\n    covariance[1] += a.x*b.y;\n    covariance[2] += a.x*b.z;\n    covariance[3] += a.y*b.y;\n    covariance[4] += a.y*b.z;\n    covariance[5] += a.z*b.z;\n  }\n}\n\nstatic MagickBooleanType ConstructOrdering(const size_t count,\n  const DDSVector4 *points, const DDSVector3 axis, DDSVector4 *pointsWeights,\n  DDSVector4 *xSumwSum, unsigned char *order, size_t iteration)\n{\n  float\n     dps[16],\n     f;\n\n  register ssize_t\n    i;\n\n  size_t\n    j;\n\n  unsigned char\n    c,\n    *o,\n    *p;\n\n  o = order + (16*iteration);\n\n  for (i=0; i < (ssize_t) count; i++)\n  {\n    dps[i] = Dot(points[i],axis);\n    o[i] = (unsigned char)i;\n  }\n\n  for (i=0; i < (ssize_t) count; i++)\n  {\n    for (j=i; j > 0 && dps[j] < dps[j - 1]; j--)\n    {\n      f = dps[j];\n      dps[j] = dps[j - 1];\n      dps[j - 1] = f;\n\n      c = o[j];\n      o[j] = o[j - 1];\n      o[j - 1] = c;\n    }\n  }\n\n  for (i=0; i < (ssize_t) iteration; i++)\n  {\n    MagickBooleanType\n      same;\n\n    p = order + (16*i);\n    same = MagickTrue;\n\n    for (j=0; j < count; j++)\n    {\n      if (o[j] != p[j])\n        {\n          same = MagickFalse;\n          break;\n        }\n    }\n\n    if (same != MagickFalse)\n      return MagickFalse;\n  }\n\n  xSumwSum->x = 0;\n  xSumwSum->y = 0;\n  xSumwSum->z = 0;\n  xSumwSum->w = 0;\n\n  for (i=0; i < (ssize_t) count; i++)\n  {\n    DDSVector4\n      v;\n\n    j = (size_t) o[i];\n\n    v.x = points[j].w * points[j].x;\n    v.y = points[j].w * points[j].y;\n    v.z = points[j].w * points[j].z;\n    v.w = points[j].w * 1.0f;\n\n    VectorCopy44(v,&pointsWeights[i]);\n    VectorAdd(*xSumwSum,v,xSumwSum);\n  }\n\n  return MagickTrue;\n}\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s D D S                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsDDS() returns MagickTrue if the image format type, identified by the\n%  magick string, is DDS.\n%\n%  The format of the IsDDS method is:\n%\n%      MagickBooleanType IsDDS(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsDDS(const unsigned char *magick, const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (LocaleNCompare((char *) magick,\"DDS \", 4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d D D S I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadDDSImage() reads a DirectDraw Surface image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadDDSImage method is:\n%\n%      Image *ReadDDSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: The image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic Image *ReadDDSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status,\n    cubemap = MagickFalse,\n    volume = MagickFalse,\n    matte;\n\n  CompressionType\n    compression;\n\n  DDSInfo\n    dds_info;\n\n  DDSDecoder\n    *decoder;\n\n  size_t\n    n,\n    num_images;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n\n  /*\n    Initialize image structure.\n  */\n  if (ReadDDSInfo(image, &dds_info) != MagickTrue) {\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n\n  if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP)\n    cubemap = MagickTrue;\n\n  if (dds_info.ddscaps2 & DDSCAPS2_VOLUME && dds_info.depth > 0)\n    volume = MagickTrue;\n\n  (void) SeekBlob(image, 128, SEEK_SET);\n\n  /*\n    Determine pixel format\n  */\n  if (dds_info.pixelformat.flags & DDPF_RGB)\n    {\n      compression = NoCompression;\n      if (dds_info.pixelformat.flags & DDPF_ALPHAPIXELS)\n        {\n          matte = MagickTrue;\n          decoder = ReadUncompressedRGBA;\n        }\n      else\n        {\n          matte = MagickTrue;\n          decoder = ReadUncompressedRGB;\n        }\n    }\n  else if (dds_info.pixelformat.flags & DDPF_LUMINANCE)\n   {\n      compression = NoCompression;\n      if (dds_info.pixelformat.flags & DDPF_ALPHAPIXELS)\n        {\n          /* Not sure how to handle this */\n          ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");\n        }\n      else\n        {\n          matte = MagickFalse;\n          decoder = ReadUncompressedRGB;\n        }\n    }\n  else if (dds_info.pixelformat.flags & DDPF_FOURCC)\n    {\n      switch (dds_info.pixelformat.fourcc)\n      {\n        case FOURCC_DXT1:\n        {\n          matte = MagickFalse;\n          compression = DXT1Compression;\n          decoder = ReadDXT1;\n          break;\n        }\n        case FOURCC_DXT3:\n        {\n          matte = MagickTrue;\n          compression = DXT3Compression;\n          decoder = ReadDXT3;\n          break;\n        }\n        case FOURCC_DXT5:\n        {\n          matte = MagickTrue;\n          compression = DXT5Compression;\n          decoder = ReadDXT5;\n          break;\n        }\n        default:\n        {\n          /* Unknown FOURCC */\n          ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");\n        }\n      }\n    }\n  else\n    {\n      /* Neither compressed nor uncompressed... thus unsupported */\n      ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");\n    }\n\n  num_images = 1;\n  if (cubemap)\n    {\n      /*\n        Determine number of faces defined in the cubemap\n      */\n      num_images = 0;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ) num_images++;\n    }\n\n  if (volume)\n    num_images = dds_info.depth;\n\n  for (n = 0; n < num_images; n++)\n  {\n    if (n != 0)\n      {\n        if (EOFBlob(image) != MagickFalse)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        /* Start a new image */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          return(DestroyImageList(image));\n        image=SyncNextImageInList(image);\n      }\n \n    image->matte = matte;\n    image->compression = compression;\n    image->columns = dds_info.width;\n    image->rows = dds_info.height;\n    image->storage_class = DirectClass;\n    image->endian = LSBEndian;\n    image->depth = 8;\n    if (image_info->ping != MagickFalse)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n\n    if ((decoder)(image, &dds_info, exception) != MagickTrue)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n  }\n\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\nstatic MagickBooleanType ReadDDSInfo(Image *image, DDSInfo *dds_info)\n{\n  size_t\n    hdr_size,\n    required;\n\n  /* Seek to start of header */\n  (void) SeekBlob(image, 4, SEEK_SET);\n\n  /* Check header field */\n  hdr_size = ReadBlobLSBLong(image);\n  if (hdr_size != 124)\n    return MagickFalse;\n\n  /* Fill in DDS info struct */\n  dds_info->flags = ReadBlobLSBLong(image);\n\n  /* Check required flags */\n  required=(size_t) (DDSD_WIDTH | DDSD_HEIGHT | DDSD_PIXELFORMAT);\n  if ((dds_info->flags & required) != required)\n    return MagickFalse;\n\n  dds_info->height = ReadBlobLSBLong(image);\n  dds_info->width = ReadBlobLSBLong(image);\n  dds_info->pitchOrLinearSize = ReadBlobLSBLong(image);\n  dds_info->depth = ReadBlobLSBLong(image);\n  dds_info->mipmapcount = ReadBlobLSBLong(image);\n\n  (void) SeekBlob(image, 44, SEEK_CUR);   /* reserved region of 11 DWORDs */\n\n  /* Read pixel format structure */\n  hdr_size = ReadBlobLSBLong(image);\n  if (hdr_size != 32)\n    return MagickFalse;\n\n  dds_info->pixelformat.flags = ReadBlobLSBLong(image);\n  dds_info->pixelformat.fourcc = ReadBlobLSBLong(image);\n  dds_info->pixelformat.rgb_bitcount = ReadBlobLSBLong(image);\n  dds_info->pixelformat.r_bitmask = ReadBlobLSBLong(image);\n  dds_info->pixelformat.g_bitmask = ReadBlobLSBLong(image);\n  dds_info->pixelformat.b_bitmask = ReadBlobLSBLong(image);\n  dds_info->pixelformat.alpha_bitmask = ReadBlobLSBLong(image);\n\n  dds_info->ddscaps1 = ReadBlobLSBLong(image);\n  dds_info->ddscaps2 = ReadBlobLSBLong(image);\n  (void) SeekBlob(image, 12, SEEK_CUR); /* 3 reserved DWORDs */\n\n  return MagickTrue;\n}\n\nstatic MagickBooleanType ReadDXT1(Image *image, DDSInfo *dds_info,\n  ExceptionInfo *exception)\n{\n  DDSColors\n    colors;\n\n  PixelPacket\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    bits;\n\n  ssize_t\n    j,\n    y;\n\n  unsigned char\n    code;\n\n  unsigned short\n    c0,\n    c1;\n\n  for (y = 0; y < (ssize_t) dds_info->height; y += 4)\n  {\n    for (x = 0; x < (ssize_t) dds_info->width; x += 4)\n    {\n      /* Get 4x4 patch of pixels to write on */\n      q = QueueAuthenticPixels(image, x, y, MagickMin(4, dds_info->width - x),\n        MagickMin(4, dds_info->height - y),exception);\n\n      if (q == (PixelPacket *) NULL)\n        return MagickFalse;\n\n      /* Read 8 bytes of data from the image */\n      c0 = ReadBlobLSBShort(image);\n      c1 = ReadBlobLSBShort(image);\n      bits = ReadBlobLSBLong(image);\n\n      CalculateColors(c0, c1, &colors, MagickFalse);\n\n      /* Write the pixels */\n      for (j = 0; j < 4; j++)\n      {\n        for (i = 0; i < 4; i++)\n        {\n          if ((x + i) < (ssize_t) dds_info->width && (y + j) < (ssize_t) dds_info->height)\n            {\n              code = (unsigned char) ((bits >> ((j*4+i)*2)) & 0x3);\n              SetPixelRed(q,ScaleCharToQuantum(colors.r[code]));\n              SetPixelGreen(q,ScaleCharToQuantum(colors.g[code]));\n              SetPixelBlue(q,ScaleCharToQuantum(colors.b[code]));\n              SetPixelOpacity(q,ScaleCharToQuantum(colors.a[code]));\n              if (colors.a[code] && image->matte == MagickFalse)\n                /* Correct matte */\n                image->matte = MagickTrue;\n              q++;\n            }\n        }\n      }\n\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        return MagickFalse;\n    }\n  }\n\n  return(SkipDXTMipmaps(image,dds_info,8,exception));\n}\n\nstatic MagickBooleanType ReadDXT3(Image *image, DDSInfo *dds_info,\n  ExceptionInfo *exception)\n{\n  DDSColors\n    colors;\n\n  ssize_t\n    j,\n    y;\n\n  PixelPacket\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  unsigned char\n    alpha;\n\n  size_t\n    a0,\n    a1,\n    bits,\n    code;\n\n  unsigned short\n    c0,\n    c1;\n\n  for (y = 0; y < (ssize_t) dds_info->height; y += 4)\n  {\n    for (x = 0; x < (ssize_t) dds_info->width; x += 4)\n    {\n      /* Get 4x4 patch of pixels to write on */\n      q = QueueAuthenticPixels(image, x, y, MagickMin(4, dds_info->width - x),\n                         MagickMin(4, dds_info->height - y),exception);\n\n      if (q == (PixelPacket *) NULL)\n        return MagickFalse;\n\n      /* Read alpha values (8 bytes) */\n      a0 = ReadBlobLSBLong(image);\n      a1 = ReadBlobLSBLong(image);\n\n      /* Read 8 bytes of data from the image */\n      c0 = ReadBlobLSBShort(image);\n      c1 = ReadBlobLSBShort(image);\n      bits = ReadBlobLSBLong(image);\n\n      CalculateColors(c0, c1, &colors, MagickTrue);\n\n      /* Write the pixels */\n      for (j = 0; j < 4; j++)\n      {\n        for (i = 0; i < 4; i++)\n        {\n          if ((x + i) < (ssize_t) dds_info->width && (y + j) < (ssize_t) dds_info->height)\n            {\n              code = (bits >> ((4*j+i)*2)) & 0x3;\n              SetPixelRed(q,ScaleCharToQuantum(colors.r[code]));\n              SetPixelGreen(q,ScaleCharToQuantum(colors.g[code]));\n              SetPixelBlue(q,ScaleCharToQuantum(colors.b[code]));\n              /*\n                Extract alpha value: multiply 0..15 by 17 to get range 0..255\n              */\n              if (j < 2)\n                alpha = 17U * (unsigned char) ((a0 >> (4*(4*j+i))) & 0xf);\n              else\n                alpha = 17U * (unsigned char) ((a1 >> (4*(4*(j-2)+i))) & 0xf);\n              SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n                alpha));\n              q++;\n            }\n        }\n      }\n\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        return MagickFalse;\n    }\n  }\n\n  return(SkipDXTMipmaps(image,dds_info,16,exception));\n}\n\nstatic MagickBooleanType ReadDXT5(Image *image, DDSInfo *dds_info,\n  ExceptionInfo *exception)\n{\n  DDSColors\n    colors;\n\n  ssize_t\n    j,\n    y;\n\n  MagickSizeType\n    alpha_bits;\n\n  PixelPacket\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  unsigned char\n    a0,\n    a1;\n\n  size_t\n    alpha,\n    bits,\n    code,\n    alpha_code;\n\n  unsigned short\n    c0,\n    c1;\n\n  for (y = 0; y < (ssize_t) dds_info->height; y += 4)\n  {\n    for (x = 0; x < (ssize_t) dds_info->width; x += 4)\n    {\n      /* Get 4x4 patch of pixels to write on */\n      q = QueueAuthenticPixels(image, x, y, MagickMin(4, dds_info->width - x),\n                         MagickMin(4, dds_info->height - y),exception);\n\n      if (q == (PixelPacket *) NULL)\n        return MagickFalse;\n\n      /* Read alpha values (8 bytes) */\n      a0 = (unsigned char) ReadBlobByte(image);\n      a1 = (unsigned char) ReadBlobByte(image);\n\n      alpha_bits = (MagickSizeType)ReadBlobLSBLong(image);\n      alpha_bits = alpha_bits | ((MagickSizeType)ReadBlobLSBShort(image) << 32);\n\n      /* Read 8 bytes of data from the image */\n      c0 = ReadBlobLSBShort(image);\n      c1 = ReadBlobLSBShort(image);\n      bits = ReadBlobLSBLong(image);\n\n      CalculateColors(c0, c1, &colors, MagickTrue);\n\n      /* Write the pixels */\n      for (j = 0; j < 4; j++)\n      {\n        for (i = 0; i < 4; i++)\n        {\n          if ((x + i) < (ssize_t) dds_info->width && (y + j) < (ssize_t) dds_info->height)\n            {\n              code = (bits >> ((4*j+i)*2)) & 0x3;\n              SetPixelRed(q,ScaleCharToQuantum(colors.r[code]));\n              SetPixelGreen(q,ScaleCharToQuantum(colors.g[code]));\n              SetPixelBlue(q,ScaleCharToQuantum(colors.b[code]));\n              /* Extract alpha value */\n              alpha_code = (size_t) (alpha_bits >> (3*(4*j+i))) & 0x7;\n              if (alpha_code == 0)\n                alpha = a0;\n              else if (alpha_code == 1)\n                alpha = a1;\n              else if (a0 > a1)\n                alpha = ((8-alpha_code) * a0 + (alpha_code-1) * a1) / 7;\n              else if (alpha_code == 6)\n                alpha = 0;\n              else if (alpha_code == 7)\n                alpha = 255;\n              else\n                alpha = (((6-alpha_code) * a0 + (alpha_code-1) * a1) / 5);\n              SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n                alpha));\n              q++;\n            }\n        }\n      }\n\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        return MagickFalse;\n    }\n  }\n\n  return(SkipDXTMipmaps(image,dds_info,16,exception));\n}\n\nstatic MagickBooleanType ReadUncompressedRGB(Image *image, DDSInfo *dds_info,\n  ExceptionInfo *exception)\n{\n  PixelPacket\n    *q;\n\n  ssize_t\n    x, y;\n\n  unsigned short\n    color;\n\n  if (dds_info->pixelformat.rgb_bitcount == 8)\n    (void) SetImageType(image,GrayscaleType);\n  else if (dds_info->pixelformat.rgb_bitcount == 16 && !IsBitMask(\n    dds_info->pixelformat,0xf800,0x07e0,0x001f,0x0000))\n    ThrowBinaryException(CorruptImageError,\"ImageTypeNotSupported\",\n      image->filename);\n\n  for (y = 0; y < (ssize_t) dds_info->height; y++)\n  {\n    q = QueueAuthenticPixels(image, 0, y, dds_info->width, 1,exception);\n\n    if (q == (PixelPacket *) NULL)\n      return MagickFalse;\n\n    for (x = 0; x < (ssize_t) dds_info->width; x++)\n    {\n      if (dds_info->pixelformat.rgb_bitcount == 8)\n        SetPixelGray(q,ScaleCharToQuantum(ReadBlobByte(image)));\n      else if (dds_info->pixelformat.rgb_bitcount == 16)\n        {\n           color=ReadBlobShort(image);\n           SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n             (((color >> 11)/31.0)*255)));\n           SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n             ((((unsigned short)(color << 5) >> 10)/63.0)*255)));\n           SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n             ((((unsigned short)(color << 11) >> 11)/31.0)*255)));\n        }\n      else\n        {\n          SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n            ReadBlobByte(image)));\n          SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n            ReadBlobByte(image)));\n          SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n            ReadBlobByte(image)));\n          if (dds_info->pixelformat.rgb_bitcount == 32)\n            (void) ReadBlobByte(image);\n        }\n      SetPixelAlpha(q,QuantumRange);\n      q++;\n    }\n \n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      return MagickFalse;\n  }\n\n  return(SkipRGBMipmaps(image,dds_info,3,exception));\n}\n\nstatic MagickBooleanType ReadUncompressedRGBA(Image *image, DDSInfo *dds_info,\n  ExceptionInfo *exception)\n{\n  PixelPacket\n    *q;\n\n  ssize_t\n    alphaBits,\n    x,\n    y;\n\n  unsigned short\n    color;\n\n  alphaBits=0;\n  if (dds_info->pixelformat.rgb_bitcount == 16)\n    {\n      if (IsBitMask(dds_info->pixelformat,0x7c00,0x03e0,0x001f,0x8000))\n        alphaBits=1;\n      else if (IsBitMask(dds_info->pixelformat,0x00ff,0x00ff,0x00ff,0xff00))\n        {\n          alphaBits=2;\n          (void) SetImageType(image,GrayscaleMatteType);\n        }\n      else if (IsBitMask(dds_info->pixelformat,0x0f00,0x00f0,0x000f,0xf000))\n        alphaBits=4;\n      else\n        ThrowBinaryException(CorruptImageError,\"ImageTypeNotSupported\",\n          image->filename);\n    }\n\n  for (y = 0; y < (ssize_t) dds_info->height; y++)\n  {\n    q = QueueAuthenticPixels(image, 0, y, dds_info->width, 1,exception);\n\n    if (q == (PixelPacket *) NULL)\n      return MagickFalse;\n\n    for (x = 0; x < (ssize_t) dds_info->width; x++)\n    {\n      if (dds_info->pixelformat.rgb_bitcount == 16)\n        {\n           color=ReadBlobShort(image);\n           if (alphaBits == 1)\n             {\n               SetPixelAlpha(q,(color & (1 << 15)) ? QuantumRange : 0);\n               SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n                 ((((unsigned short)(color << 1) >> 11)/31.0)*255)));\n               SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n                 ((((unsigned short)(color << 6) >> 11)/31.0)*255)));\n               SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n                 ((((unsigned short)(color << 11) >> 11)/31.0)*255)));\n             }\n          else if (alphaBits == 2)\n            {\n               SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n                 (color >> 8)));\n               SetPixelGray(q,ScaleCharToQuantum((unsigned char)color));\n            }\n          else\n            {\n               SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n                 (((color >> 12)/15.0)*255)));\n               SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n                 ((((unsigned short)(color << 4) >> 12)/15.0)*255)));\n               SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n                 ((((unsigned short)(color << 8) >> 12)/15.0)*255)));\n               SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n                 ((((unsigned short)(color << 12) >> 12)/15.0)*255)));\n            }\n        }\n      else\n        {\n          SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n            ReadBlobByte(image)));\n          SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n            ReadBlobByte(image)));\n          SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n            ReadBlobByte(image)));\n          SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n            ReadBlobByte(image)));\n        }\n      q++;\n    }\n\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      return MagickFalse;\n  }\n\n  return(SkipRGBMipmaps(image,dds_info,4,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r D D S I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterDDSImage() adds attributes for the DDS image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterDDSImage method is:\n%\n%      RegisterDDSImage(void)\n%\n*/\nModuleExport size_t RegisterDDSImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry = SetMagickInfo(\"DDS\");\n  entry->decoder = (DecodeImageHandler *) ReadDDSImage;\n  entry->encoder = (EncodeImageHandler *) WriteDDSImage;\n  entry->magick = (IsImageFormatHandler *) IsDDS;\n  entry->seekable_stream=MagickTrue;\n  entry->description = ConstantString(\"Microsoft DirectDraw Surface\");\n  entry->module = ConstantString(\"DDS\");\n  (void) RegisterMagickInfo(entry);\n  entry = SetMagickInfo(\"DXT1\");\n  entry->decoder = (DecodeImageHandler *) ReadDDSImage;\n  entry->encoder = (EncodeImageHandler *) WriteDDSImage;\n  entry->magick = (IsImageFormatHandler *) IsDDS;\n  entry->seekable_stream=MagickTrue;\n  entry->description = ConstantString(\"Microsoft DirectDraw Surface\");\n  entry->module = ConstantString(\"DDS\");\n  (void) RegisterMagickInfo(entry);\n  entry = SetMagickInfo(\"DXT5\");\n  entry->decoder = (DecodeImageHandler *) ReadDDSImage;\n  entry->encoder = (EncodeImageHandler *) WriteDDSImage;\n  entry->magick = (IsImageFormatHandler *) IsDDS;\n  entry->seekable_stream=MagickTrue;\n  entry->description = ConstantString(\"Microsoft DirectDraw Surface\");\n  entry->module = ConstantString(\"DDS\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\nstatic void RemapIndices(const ssize_t *map, const unsigned char *source,\n  unsigned char *target)\n{\n  register ssize_t\n    i;\n\n  for (i = 0; i < 16; i++)\n  {\n    if (map[i] == -1)\n      target[i] = 3;\n    else\n      target[i] = source[map[i]];\n  }\n}\n\n/*\n  Skip the mipmap images for compressed (DXTn) dds files\n*/\nstatic MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *dds_info,\n  int texel_size,ExceptionInfo *exception)\n{\n  register ssize_t\n    i;\n\n  MagickOffsetType\n    offset;\n\n  size_t\n    h,\n    w;\n\n  /*\n    Only skip mipmaps for textures and cube maps\n  */\n  if (EOFBlob(image) != MagickFalse)\n    {\n      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n      return(MagickFalse);\n    }\n  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n    {\n      w = DIV2(dds_info->width);\n      h = DIV2(dds_info->height);\n\n      /*\n        Mipmapcount includes the main image, so start from one\n      */\n      for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n      {\n        offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n\n        w = DIV2(w);\n        h = DIV2(h);\n      }\n    }\n  return(MagickTrue);\n}\n\n/*\n  Skip the mipmap images for uncompressed (RGB or RGBA) dds files\n*/\nstatic MagickBooleanType SkipRGBMipmaps(Image *image,DDSInfo *dds_info,\n  int pixel_size,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    offset;\n\n  register ssize_t\n    i;\n\n  size_t\n    h,\n    w;\n\n  /*\n    Only skip mipmaps for textures and cube maps\n  */\n  if (EOFBlob(image) != MagickFalse)\n    {\n      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n      return(MagickFalse);\n    }\n  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n    {\n      w = DIV2(dds_info->width);\n      h = DIV2(dds_info->height);\n\n      /*\n        Mipmapcount includes the main image, so start from one\n      */\n      for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n      {\n        offset = (MagickOffsetType) w * h * pixel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n\n        w = DIV2(w);\n        h = DIV2(h);\n      }\n    }\n  return(MagickTrue);\n}\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r D D S I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterDDSImage() removes format registrations made by the\n%  DDS module from the list of supported formats.\n%\n%  The format of the UnregisterDDSImage method is:\n%\n%      UnregisterDDSImage(void)\n%\n*/\nModuleExport void UnregisterDDSImage(void)\n{\n  (void) UnregisterMagickInfo(\"DDS\");\n  (void) UnregisterMagickInfo(\"DXT1\");\n  (void) UnregisterMagickInfo(\"DXT5\");\n}\n\nstatic void WriteAlphas(Image *image, const ssize_t* alphas, size_t min5,\n  size_t max5, size_t min7, size_t max7)\n{\n  register ssize_t\n    i;\n\n  size_t\n    err5,\n    err7,\n    j;\n\n  unsigned char\n    indices5[16],\n    indices7[16];\n\n  FixRange(min5,max5,5);\n  err5 = CompressAlpha(min5,max5,5,alphas,indices5);\n\n  FixRange(min7,max7,7);\n  err7 = CompressAlpha(min7,max7,7,alphas,indices7);\n\n  if (err7 < err5)\n  {\n    for (i=0; i < 16; i++)\n    {\n      unsigned char\n        index;\n\n      index = indices7[i];\n      if( index == 0 )\n        indices5[i] = 1;\n      else if (index == 1)\n        indices5[i] = 0;\n      else\n        indices5[i] = 9 - index;\n    }\n\n    min5 = max7;\n    max5 = min7;\n  }\n  \n  (void) WriteBlobByte(image,(unsigned char) min5);\n  (void) WriteBlobByte(image,(unsigned char) max5);\n  \n  for(i=0; i < 2; i++)\n  {\n    size_t\n      value = 0;\n\n    for (j=0; j < 8; j++)\n    {\n      size_t index = (size_t) indices5[j + i*8];\n      value |= ( index << 3*j );\n    }\n\n    for (j=0; j < 3; j++)\n    {\n      size_t byte = (value >> 8*j) & 0xff;\n      (void) WriteBlobByte(image,(unsigned char) byte);\n    }\n  }\n}\n\nstatic void WriteCompressed(Image *image, const size_t count,\n  DDSVector4* points, const ssize_t* map, const MagickBooleanType clusterFit)\n{\n  float\n    covariance[16];\n\n  DDSVector3\n    end,\n    principle,\n    start;\n\n  DDSVector4\n    metric;\n\n  unsigned char\n    indices[16];\n\n  VectorInit(metric,1.0f);\n  VectorInit3(start,0.0f);\n  VectorInit3(end,0.0f);\n\n  ComputeWeightedCovariance(count,points,covariance);\n  ComputePrincipleComponent(covariance,&principle);\n\n  if (clusterFit == MagickFalse || count == 0)\n    CompressRangeFit(count,points,map,principle,metric,&start,&end,indices);\n  else\n    CompressClusterFit(count,points,map,principle,metric,&start,&end,indices);\n\n  WriteIndices(image,start,end,indices);\n}\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e D D S I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteDDSImage() writes a DirectDraw Surface image file in the DXT5 format.\n%\n%  The format of the WriteBMPImage method is:\n%\n%     MagickBooleanType WriteDDSImage(const ImageInfo *image_info,Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n*/\nstatic MagickBooleanType WriteDDSImage(const ImageInfo *image_info,\n  Image *image)\n{\n  const char\n    *option;\n\n  size_t\n    compression,\n    columns,\n    maxMipmaps,\n    mipmaps,\n    pixelFormat,\n    rows;\n\n  MagickBooleanType\n    clusterFit,\n    status,\n    weightByAlpha;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  pixelFormat=DDPF_FOURCC;\n  compression=FOURCC_DXT5;\n\n  if (!image->matte)\n    compression=FOURCC_DXT1;\n\n  if (LocaleCompare(image_info->magick,\"dxt1\") == 0)\n    compression=FOURCC_DXT1;\n\n  option=GetImageOption(image_info,\"dds:compression\");\n  if (option != (char *) NULL)\n    {\n       if (LocaleCompare(option,\"dxt1\") == 0)\n         compression=FOURCC_DXT1;\n       if (LocaleCompare(option,\"none\") == 0)\n         pixelFormat=DDPF_RGB;\n    }\n\n  clusterFit=MagickFalse;\n  weightByAlpha=MagickFalse;\n\n  if (pixelFormat == DDPF_FOURCC)\n    {\n      option=GetImageOption(image_info,\"dds:cluster-fit\");\n      if (option != (char *) NULL && LocaleCompare(option,\"true\") == 0)\n        {\n          clusterFit=MagickTrue;\n          if (compression != FOURCC_DXT1)\n            {\n              option=GetImageOption(image_info,\"dds:weight-by-alpha\");\n              if (option != (char *) NULL && LocaleCompare(option,\"true\") == 0)\n                weightByAlpha=MagickTrue;\n            }\n        }\n    }\n\n  maxMipmaps=SIZE_MAX;\n  mipmaps=0;\n  if ((image->columns & (image->columns - 1)) == 0 &&\n      (image->rows & (image->rows - 1)) == 0)\n    {\n      option=GetImageOption(image_info,\"dds:mipmaps\");\n      if (option != (char *) NULL)\n        maxMipmaps=StringToUnsignedLong(option);\n\n      if (maxMipmaps != 0)\n        {\n          columns=image->columns;\n          rows=image->rows;\n          while (columns != 1 && rows != 1 && mipmaps != maxMipmaps)\n          {\n            columns=DIV2(columns);\n            rows=DIV2(rows);\n            mipmaps++;\n          }\n        }\n    }\n\n  WriteDDSInfo(image,pixelFormat,compression,mipmaps);\n\n  WriteImageData(image,pixelFormat,compression,clusterFit,weightByAlpha,\n    &image->exception);\n\n  if (mipmaps > 0 && WriteMipmaps(image,pixelFormat,compression,mipmaps,\n        clusterFit,weightByAlpha,&image->exception) == MagickFalse)\n    return(MagickFalse);\n\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n\nstatic void WriteDDSInfo(Image *image, const size_t pixelFormat,\n  const size_t compression, const size_t mipmaps)\n{\n  char\n    software[MaxTextExtent];\n\n  register ssize_t\n    i;\n\n  unsigned int\n    format,\n    caps,\n    flags;\n\n  flags=(unsigned int) (DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT |\n    DDSD_PIXELFORMAT | DDSD_LINEARSIZE);\n  caps=(unsigned int) DDSCAPS_TEXTURE;\n  format=(unsigned int) pixelFormat;\n\n  if (mipmaps > 0)\n    {\n      flags=flags | (unsigned int) DDSD_MIPMAPCOUNT;\n      caps=caps | (unsigned int) (DDSCAPS_MIPMAP | DDSCAPS_COMPLEX);\n    }\n\n  if (format != DDPF_FOURCC && image->matte)\n    format=format | DDPF_ALPHAPIXELS;\n\n  (void) WriteBlob(image,4,(unsigned char *) \"DDS \");\n  (void) WriteBlobLSBLong(image,124);\n  (void) WriteBlobLSBLong(image,flags);\n  (void) WriteBlobLSBLong(image,(unsigned int) image->rows);\n  (void) WriteBlobLSBLong(image,(unsigned int) image->columns);\n\n  if (compression == FOURCC_DXT1)\n    (void) WriteBlobLSBLong(image,\n             (unsigned int) (MagickMax(1,(image->columns+3)/4) * 8));\n  else\n    (void) WriteBlobLSBLong(image,\n             (unsigned int) (MagickMax(1,(image->columns+3)/4) * 16));\n\n  (void) WriteBlobLSBLong(image,0x00);\n  (void) WriteBlobLSBLong(image,(unsigned int) mipmaps+1);\n  (void) ResetMagickMemory(software,0,sizeof(software));\n  (void) strcpy(software,\"IMAGEMAGICK\");\n  (void) WriteBlob(image,44,(unsigned char *) software);\n\n  (void) WriteBlobLSBLong(image,32);\n  (void) WriteBlobLSBLong(image,format);\n\n  if (pixelFormat == DDPF_FOURCC)\n    {\n      (void) WriteBlobLSBLong(image,(unsigned int) compression);\n      for(i=0;i < 5;i++) // bitcount / masks\n        (void) WriteBlobLSBLong(image,0x00);\n    }\n  else\n    {\n      (void) WriteBlobLSBLong(image,0x00);\n      if (image->matte)\n        {\n          (void) WriteBlobLSBLong(image,32);\n          (void) WriteBlobLSBLong(image,0xff0000);\n          (void) WriteBlobLSBLong(image,0xff00);\n          (void) WriteBlobLSBLong(image,0xff);\n          (void) WriteBlobLSBLong(image,0xff000000);\n        }\n      else\n        {\n          (void) WriteBlobLSBLong(image,24);\n          (void) WriteBlobLSBLong(image,0xff);\n          (void) WriteBlobLSBLong(image,0x00);\n          (void) WriteBlobLSBLong(image,0x00);\n          (void) WriteBlobLSBLong(image,0x00);\n        }\n    }\n  \n  (void) WriteBlobLSBLong(image,caps);\n  for(i=0;i < 4;i++) // ddscaps2 + reserved region\n    (void) WriteBlobLSBLong(image,0x00);\n}\n\nstatic void WriteFourCC(Image *image, const size_t compression,\n  const MagickBooleanType clusterFit, const MagickBooleanType weightByAlpha,\n  ExceptionInfo *exception)\n{\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    i,\n    y,\n    bx,\n    by;\n\n  for (y=0; y < (ssize_t) image->rows; y+=4)\n  {\n    for (x=0; x < (ssize_t) image->columns; x+=4)\n    {\n      MagickBooleanType\n        match;\n\n      DDSVector4\n        point,\n        points[16];\n\n      size_t\n        count = 0,\n        max5 = 0,\n        max7 = 0,\n        min5 = 255,\n        min7 = 255,\n        columns = 4,\n        rows = 4;\n\n      ssize_t\n        alphas[16],\n        map[16];\n\n      unsigned char\n        alpha;\n\n      if (x + columns >= image->columns)\n        columns = image->columns - x;\n\n      if (y + rows >= image->rows)\n        rows = image->rows - y;\n\n      p=GetVirtualPixels(image,x,y,columns,rows,exception);\n      if (p == (const PixelPacket *) NULL)\n        break;\n\n      for (i=0; i<16; i++)\n      {\n        map[i] = -1;\n        alphas[i] = -1;\n      }\n\n      for (by=0; by < (ssize_t) rows; by++)\n      {\n        for (bx=0; bx < (ssize_t) columns; bx++)\n        {\n          if (compression == FOURCC_DXT5)\n            alpha = ScaleQuantumToChar(GetPixelAlpha(p));\n          else\n            alpha = 255;\n\n          alphas[4*by + bx] = (size_t)alpha;\n\n          point.x = (float)ScaleQuantumToChar(GetPixelRed(p)) / 255.0f;\n          point.y = (float)ScaleQuantumToChar(GetPixelGreen(p)) / 255.0f;\n          point.z = (float)ScaleQuantumToChar(GetPixelBlue(p)) / 255.0f;\n          point.w = weightByAlpha ? (float)(alpha + 1) / 256.0f : 1.0f;\n          p++;\n\n          match = MagickFalse;\n          for (i=0; i < (ssize_t) count; i++)\n          {\n            if ((points[i].x == point.x) &&\n                (points[i].y == point.y) &&\n                (points[i].z == point.z) &&\n                (alpha       >= 128 || compression == FOURCC_DXT5))\n              {\n                points[i].w += point.w;\n                map[4*by + bx] = i;\n                match = MagickTrue;\n                break;\n              }\n            }\n\n            if (match != MagickFalse)\n              continue;\n\n            points[count].x = point.x;\n            points[count].y = point.y;\n            points[count].z = point.z;\n            points[count].w = point.w;\n            map[4*by + bx] = count;\n            count++;\n\n            if (compression == FOURCC_DXT5)\n              {\n                if (alpha < min7)\n                  min7 = alpha;\n                if (alpha > max7)\n                  max7 = alpha;\n                if (alpha != 0 && alpha < min5)\n                  min5 = alpha;\n                if (alpha != 255 && alpha > max5)\n                  max5 = alpha;\n              }\n          }\n        }\n\n      for (i=0; i < (ssize_t) count; i++)\n        points[i].w = sqrt(points[i].w);\n\n      if (compression == FOURCC_DXT5)\n        WriteAlphas(image,alphas,min5,max5,min7,max7);\n\n      if (count == 1)\n        WriteSingleColorFit(image,points,map);\n      else\n        WriteCompressed(image,count,points,map,clusterFit);\n    }\n  }\n}\n\nstatic void WriteImageData(Image *image, const size_t pixelFormat,\n  const size_t compression, const MagickBooleanType clusterFit,\n  const MagickBooleanType weightByAlpha, ExceptionInfo *exception)\n{\n  if (pixelFormat == DDPF_FOURCC)\n    WriteFourCC(image,compression,clusterFit,weightByAlpha,exception);\n  else\n    WriteUncompressed(image,exception);\n}\n\nstatic inline size_t ClampToLimit(const float value,\n  const size_t limit)\n{\n  size_t\n    result = (int) (value + 0.5f);\n\n  if (result < 0.0f)\n    return(0);\n  if (result > limit)\n    return(limit);\n  return result;\n}\n\nstatic inline size_t ColorTo565(const DDSVector3 point)\n{\n  size_t r = ClampToLimit(31.0f*point.x,31);\n  size_t g = ClampToLimit(63.0f*point.y,63);\n  size_t b = ClampToLimit(31.0f*point.z,31);\n\n  return (r << 11) | (g << 5) | b;\n}\n\nstatic void WriteIndices(Image *image, const DDSVector3 start,\n  const DDSVector3 end, unsigned char* indices)\n{\n  register ssize_t\n    i;\n\n  size_t\n    a,\n    b;\n\n  unsigned char\n    remapped[16];\n\n  const unsigned char\n    *ind;\n\n  a = ColorTo565(start);\n  b = ColorTo565(end);\n\n  for (i=0; i<16; i++)\n  {\n    if( a < b )\n      remapped[i] = (indices[i] ^ 0x1) & 0x3;\n    else if( a == b )\n      remapped[i] = 0;\n    else\n      remapped[i] = indices[i];\n  }\n\n  if( a < b )\n    Swap(a,b);\n\n  (void) WriteBlobByte(image,(unsigned char) (a & 0xff));\n  (void) WriteBlobByte(image,(unsigned char) (a >> 8));\n  (void) WriteBlobByte(image,(unsigned char) (b & 0xff));\n  (void) WriteBlobByte(image,(unsigned char) (b >> 8));\n\n  for (i=0; i<4; i++)\n  {\n     ind = remapped + 4*i;\n     (void) WriteBlobByte(image,ind[0] | (ind[1] << 2) | (ind[2] << 4) |\n       (ind[3] << 6));\n  }\n}\n\nstatic MagickBooleanType WriteMipmaps(Image *image, const size_t pixelFormat,\n  const size_t compression, const size_t mipmaps,\n  const MagickBooleanType clusterFit, const MagickBooleanType weightByAlpha,\n  ExceptionInfo *exception)\n{\n  Image*\n    resize_image;\n\n  register ssize_t\n    i;\n\n  size_t\n    columns,\n    rows;\n\n  columns = image->columns;\n  rows = image->rows;\n\n  for (i=0; i< (ssize_t) mipmaps; i++)\n  {\n    resize_image = ResizeImage(image,columns/2,rows/2,TriangleFilter,1.0,\n      exception);\n\n    if (resize_image == (Image *) NULL)\n      return(MagickFalse);\n\n    DestroyBlob(resize_image);\n    resize_image->blob=ReferenceBlob(image->blob);\n\n    WriteImageData(resize_image,pixelFormat,compression,weightByAlpha,\n      clusterFit,exception);\n\n    resize_image=DestroyImage(resize_image);\n\n    columns = DIV2(columns);\n    rows = DIV2(rows);\n  }\n\n  return(MagickTrue);\n}\n\nstatic void WriteSingleColorFit(Image *image, const DDSVector4* points,\n  const ssize_t* map)\n{\n  DDSVector3\n    start,\n    end;\n\n  register ssize_t\n    i;\n\n  unsigned char\n    color[3],\n    index,\n    indexes[16],\n    indices[16];\n\n  color[0] = (unsigned char) ClampToLimit(255.0f*points->x,255);\n  color[1] = (unsigned char) ClampToLimit(255.0f*points->y,255);\n  color[2] = (unsigned char) ClampToLimit(255.0f*points->z,255);\n\n  index=0;\n  ComputeEndPoints(DDS_LOOKUP,color,&start,&end,&index);\n\n  for (i=0; i< 16; i++)\n    indexes[i]=index;\n  RemapIndices(map,indexes,indices);\n  WriteIndices(image,start,end,indices);\n}\n\nstatic void WriteUncompressed(Image *image, ExceptionInfo *exception)\n{\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    y;\n\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelBlue(p)));\n      (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelGreen(p)));\n      (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelRed(p)));\n      if (image->matte)\n        (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelAlpha(p)));\n      p++;\n    }\n  }\n}\n"], "filenames": ["coders/dds.c"], "buggy_code_start_loc": [2373], "buggy_code_end_loc": [2431], "fixing_code_start_loc": [2374], "fixing_code_end_loc": [2430], "type": "CWE-20", "message": "coders/dds.c in ImageMagick allows remote attackers to cause a denial of service via a crafted DDS file.", "other": {"cve": {"id": "CVE-2014-9907", "sourceIdentifier": "security@debian.org", "published": "2017-04-19T14:59:00.147", "lastModified": "2017-05-09T12:40:25.760", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "coders/dds.c in ImageMagick allows remote attackers to cause a denial of service via a crafted DDS file."}, {"lang": "es", "value": "coders/dds.c en ImageMagick permite a atacantes remotos provocar una denegaci\u00f3n de servicio a trav\u00e9s de un archivo DDS manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "matchCriteriaId": "BE6EA542-A222-4E6A-869B-F3805CAFCDD0"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/09/22/2", "source": "security@debian.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/93231", "source": "security@debian.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1378734", "source": "security@debian.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/21eae25a8db5fdcd112dbcfcd9e5c37e32d32e2f", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/504ada82b6fa38a30c846c1c29116af7290decb2", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/d7325bac173492b358417a0ad49fabad44447d52", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/21eae25a8db5fdcd112dbcfcd9e5c37e32d32e2f"}}