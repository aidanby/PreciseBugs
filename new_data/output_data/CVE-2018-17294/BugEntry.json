{"buggy_code": ["/* liblouis Braille Translation and Back-Translation Library\n\n   Based on the Linux screenreader BRLTTY, copyright (C) 1999-2006 by The\n   BRLTTY Team\n\n   Copyright (C) 2004, 2005, 2006 ViewPlus Technologies, Inc. www.viewplus.com\n   Copyright (C) 2004, 2005, 2006 JJB Software, Inc. www.jjb-software.com\n   Copyright (C) 2016 Mike Gray, American Printing House for the Blind\n   Copyright (C) 2016 Davy Kager, Dedicon\n\n   This file is part of liblouis.\n\n   liblouis is free software: you can redistribute it and/or modify it\n   under the terms of the GNU Lesser General Public License as published\n   by the Free Software Foundation, either version 2.1 of the License, or\n   (at your option) any later version.\n\n   liblouis is distributed in the hope that it will be useful, but\n   WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with liblouis. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * @file\n * @brief Translate to braille\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"internal.h\"\n\n/* additional bits in typebuf */\n#define SYLLABLE_MARKER_1 0x2000\n#define SYLLABLE_MARKER_2 0x4000\n#define CAPSEMPH 0x8000\n\n#define EMPHASIS 0x3fff  // all typeform bits that can be used\n\n/* bits for wordBuffer */\n#define WORD_CHAR 0x00000001\n#define WORD_RESET 0x00000002\n#define WORD_STOP 0x00000004\n#define WORD_WHOLE 0x00000008\n\ntypedef struct {\n\tint size;\n\twidechar **buffers;\n\tint *inUse;\n\twidechar *(*alloc)(int index, int length);\n\tvoid (*free)(widechar *);\n} StringBufferPool;\n\nstatic widechar *\nallocStringBuffer(int index, int length) {\n\treturn _lou_allocMem(alloc_passbuf, index, 0, length);\n}\n\nstatic const StringBufferPool *stringBufferPool = NULL;\n\nstatic void\ninitStringBufferPool() {\n\tstatic widechar *stringBuffers[MAXPASSBUF] = { NULL };\n\tstatic int stringBuffersInUse[MAXPASSBUF] = { 0 };\n\tStringBufferPool *pool = malloc(sizeof(StringBufferPool));\n\tpool->size = MAXPASSBUF;\n\tpool->buffers = stringBuffers;\n\tpool->inUse = stringBuffersInUse;\n\tpool->alloc = &allocStringBuffer;\n\tpool->free = NULL;\n\tstringBufferPool = pool;\n}\n\nstatic int\ngetStringBuffer(int length) {\n\tint i;\n\tfor (i = 0; i < stringBufferPool->size; i++) {\n\t\tif (!stringBufferPool->inUse[i]) {\n\t\t\tstringBufferPool->buffers[i] = stringBufferPool->alloc(i, length);\n\t\t\tstringBufferPool->inUse[i] = 1;\n\t\t\treturn i;\n\t\t}\n\t}\n\t_lou_outOfMemory();\n\treturn -1;\n}\n\nstatic int\nreleaseStringBuffer(int idx) {\n\tif (idx >= 0 && idx < stringBufferPool->size) {\n\t\tint inUse = stringBufferPool->inUse[idx];\n\t\tif (inUse && stringBufferPool->free)\n\t\t\tstringBufferPool->free(stringBufferPool->buffers[idx]);\n\t\tstringBufferPool->inUse[idx] = 0;\n\t\treturn inUse;\n\t}\n\treturn 0;\n}\n\ntypedef struct {\n\tint bufferIndex;\n\tconst widechar *chars;\n\tint length;\n} InString;\n\ntypedef struct {\n\tint bufferIndex;\n\twidechar *chars;\n\tint maxlength;\n\tint length;\n} OutString;\n\ntypedef struct {\n\tint startMatch;\n\tint startReplace;\n\tint endReplace;\n\tint endMatch;\n} PassRuleMatch;\n\nstatic int\nputCharacter(widechar c, const TranslationTableHeader *table, int pos,\n\t\tconst InString *input, OutString *output, int *posMapping, int *cursorPosition,\n\t\tint *cursorStatus);\nstatic int\npassDoTest(const TranslationTableHeader *table, int pos, const InString *input,\n\t\tint transOpcode, const TranslationTableRule *transRule, int *passCharDots,\n\t\tconst widechar **passInstructions, int *passIC, PassRuleMatch *match,\n\t\tTranslationTableRule **groupingRule, widechar *groupingOp);\nstatic int\npassDoAction(const TranslationTableHeader *table, const InString **input,\n\t\tOutString *output, int *posMapping, int transOpcode,\n\t\tconst TranslationTableRule **transRule, int passCharDots,\n\t\tconst widechar *passInstructions, int passIC, int *pos, PassRuleMatch match,\n\t\tint *cursorPosition, int *cursorStatus, TranslationTableRule *groupingRule,\n\t\twidechar groupingOp);\n\nstatic const TranslationTableRule **appliedRules;\nstatic int maxAppliedRules;\nstatic int appliedRulesCount;\n\nstatic TranslationTableCharacter *\nfindCharOrDots(widechar c, int m, const TranslationTableHeader *table) {\n\t/* Look up character or dot pattern in the appropriate\n\t * table. */\n\tstatic TranslationTableCharacter noChar = { 0, 0, 0, CTC_Space, 32, 32, 32 };\n\tstatic TranslationTableCharacter noDots = { 0, 0, 0, CTC_Space, B16, B16, B16 };\n\tTranslationTableCharacter *notFound;\n\tTranslationTableCharacter *character;\n\tTranslationTableOffset bucket;\n\tunsigned long int makeHash = (unsigned long int)c % HASHNUM;\n\tif (m == 0) {\n\t\tbucket = table->characters[makeHash];\n\t\tnotFound = &noChar;\n\t} else {\n\t\tbucket = table->dots[makeHash];\n\t\tnotFound = &noDots;\n\t}\n\twhile (bucket) {\n\t\tcharacter = (TranslationTableCharacter *)&table->ruleArea[bucket];\n\t\tif (character->realchar == c) return character;\n\t\tbucket = character->next;\n\t}\n\tnotFound->realchar = notFound->uppercase = notFound->lowercase = c;\n\treturn notFound;\n}\n\nstatic int\ncheckAttr(const widechar c, const TranslationTableCharacterAttributes a, int m,\n\t\tconst TranslationTableHeader *table) {\n\tstatic widechar prevc = 0;\n\tstatic TranslationTableCharacterAttributes preva = 0;\n\tif (c != prevc) {\n\t\tpreva = (findCharOrDots(c, m, table))->attributes;\n\t\tprevc = c;\n\t}\n\treturn ((preva & a) ? 1 : 0);\n}\n\nstatic int\ncheckAttr_safe(const InString *input, int pos,\n\t\tconst TranslationTableCharacterAttributes a, int m,\n\t\tconst TranslationTableHeader *table) {\n\treturn ((pos < input->length) ? checkAttr(input->chars[pos], a, m, table) : 0);\n}\n\nstatic int\nfindForPassRule(const TranslationTableHeader *table, int pos, int currentPass,\n\t\tconst InString *input, int *transOpcode, const TranslationTableRule **transRule,\n\t\tint *transCharslen, int *passCharDots, widechar const **passInstructions,\n\t\tint *passIC, PassRuleMatch *match, TranslationTableRule **groupingRule,\n\t\twidechar *groupingOp) {\n\tint save_transCharslen = *transCharslen;\n\tconst TranslationTableRule *save_transRule = *transRule;\n\tTranslationTableOpcode save_transOpcode = *transOpcode;\n\tTranslationTableOffset ruleOffset;\n\truleOffset = table->forPassRules[currentPass];\n\t*transCharslen = 0;\n\twhile (ruleOffset) {\n\t\t*transRule = (TranslationTableRule *)&table->ruleArea[ruleOffset];\n\t\t*transOpcode = (*transRule)->opcode;\n\t\tif (passDoTest(table, pos, input, *transOpcode, *transRule, passCharDots,\n\t\t\t\t\tpassInstructions, passIC, match, groupingRule, groupingOp))\n\t\t\treturn 1;\n\t\truleOffset = (*transRule)->charsnext;\n\t}\n\t*transCharslen = save_transCharslen;\n\t*transRule = save_transRule;\n\t*transOpcode = save_transOpcode;\n\treturn 0;\n}\n\nstatic int\ncompareChars(const widechar *address1, const widechar *address2, int count, int m,\n\t\tconst TranslationTableHeader *table) {\n\tint k;\n\tif (!count) return 0;\n\tfor (k = 0; k < count; k++)\n\t\tif ((findCharOrDots(address1[k], m, table))->lowercase !=\n\t\t\t\t(findCharOrDots(address2[k], m, table))->lowercase)\n\t\t\treturn 0;\n\treturn 1;\n}\n\nstatic int\nmakeCorrections(const TranslationTableHeader *table, const InString *input,\n\t\tOutString *output, int *posMapping, formtype *typebuf, int *realInlen,\n\t\tint *posIncremented, int *cursorPosition, int *cursorStatus) {\n\tint pos;\n\tint transOpcode;\n\tconst TranslationTableRule *transRule;\n\tint transCharslen;\n\tint passCharDots;\n\tconst widechar *passInstructions;\n\tint passIC; /* Instruction counter */\n\tPassRuleMatch patternMatch;\n\tTranslationTableRule *groupingRule;\n\twidechar groupingOp;\n\tconst InString *origInput = input;\n\tif (!table->corrections) return 1;\n\tpos = 0;\n\toutput->length = 0;\n\t*posIncremented = 1;\n\t_lou_resetPassVariables();\n\twhile (pos < input->length) {\n\t\tint length = input->length - pos;\n\t\tconst TranslationTableCharacter *character =\n\t\t\t\tfindCharOrDots(input->chars[pos], 0, table);\n\t\tconst TranslationTableCharacter *character2;\n\t\tint tryThis = 0;\n\t\tif (!findForPassRule(table, pos, 0, input, &transOpcode, &transRule,\n\t\t\t\t\t&transCharslen, &passCharDots, &passInstructions, &passIC,\n\t\t\t\t\t&patternMatch, &groupingRule, &groupingOp))\n\t\t\twhile (tryThis < 3) {\n\t\t\t\tTranslationTableOffset ruleOffset = 0;\n\t\t\t\tunsigned long int makeHash = 0;\n\t\t\t\tswitch (tryThis) {\n\t\t\t\tcase 0:\n\t\t\t\t\tif (!(length >= 2)) break;\n\t\t\t\t\tmakeHash = (unsigned long int)character->lowercase << 8;\n\t\t\t\t\tcharacter2 = findCharOrDots(input->chars[pos + 1], 0, table);\n\t\t\t\t\tmakeHash += (unsigned long int)character2->lowercase;\n\t\t\t\t\tmakeHash %= HASHNUM;\n\t\t\t\t\truleOffset = table->forRules[makeHash];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tif (!(length >= 1)) break;\n\t\t\t\t\tlength = 1;\n\t\t\t\t\truleOffset = character->otherRules;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2: /* No rule found */\n\t\t\t\t\ttransOpcode = CTO_Always;\n\t\t\t\t\truleOffset = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twhile (ruleOffset) {\n\t\t\t\t\ttransRule = (TranslationTableRule *)&table->ruleArea[ruleOffset];\n\t\t\t\t\ttransOpcode = transRule->opcode;\n\t\t\t\t\ttransCharslen = transRule->charslen;\n\t\t\t\t\tif (tryThis == 1 || (transCharslen <= length &&\n\t\t\t\t\t\t\t\t\t\t\t\tcompareChars(&transRule->charsdots[0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t&input->chars[pos], transCharslen,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t0, table))) {\n\t\t\t\t\t\tif (*posIncremented && transOpcode == CTO_Correct &&\n\t\t\t\t\t\t\t\tpassDoTest(table, pos, input, transOpcode, transRule,\n\t\t\t\t\t\t\t\t\t\t&passCharDots, &passInstructions, &passIC,\n\t\t\t\t\t\t\t\t\t\t&patternMatch, &groupingRule, &groupingOp)) {\n\t\t\t\t\t\t\ttryThis = 4;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\truleOffset = transRule->charsnext;\n\t\t\t\t}\n\t\t\t\ttryThis++;\n\t\t\t}\n\t\t*posIncremented = 1;\n\n\t\tswitch (transOpcode) {\n\t\tcase CTO_Always:\n\t\t\tif (output->length >= output->maxlength) goto failure;\n\t\t\tposMapping[output->length] = pos;\n\t\t\toutput->chars[output->length++] = input->chars[pos++];\n\t\t\tbreak;\n\t\tcase CTO_Correct: {\n\t\t\tconst InString *inputBefore = input;\n\t\t\tint posBefore = pos;\n\t\t\tif (appliedRules != NULL && appliedRulesCount < maxAppliedRules)\n\t\t\t\tappliedRules[appliedRulesCount++] = transRule;\n\t\t\tif (!passDoAction(table, &input, output, posMapping, transOpcode, &transRule,\n\t\t\t\t\t\tpassCharDots, passInstructions, passIC, &pos, patternMatch,\n\t\t\t\t\t\tcursorPosition, cursorStatus, groupingRule, groupingOp))\n\t\t\t\tgoto failure;\n\t\t\tif (input->bufferIndex != inputBefore->bufferIndex &&\n\t\t\t\t\tinputBefore->bufferIndex != origInput->bufferIndex)\n\t\t\t\treleaseStringBuffer(inputBefore->bufferIndex);\n\t\t\tif (pos == posBefore) *posIncremented = 0;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t{  // We have to transform typebuf accordingly\n\t\tint k;\n\t\tformtype *typebuf_temp;\n\t\tif ((typebuf_temp = malloc(output->length * sizeof(formtype))) == NULL)\n\t\t\t_lou_outOfMemory();\n\t\tfor (k = 0; k < output->length; k++)\n\t\t\t// posMapping will never be < 0 but in theory it could\n\t\t\tif (posMapping[k] < 0)\n\t\t\t\ttypebuf_temp[k] = typebuf[0];  // prepend to next\n\t\t\telse if (posMapping[k] >= input->length)\n\t\t\t\ttypebuf_temp[k] = typebuf[input->length - 1];  // append to previous\n\t\t\telse\n\t\t\t\ttypebuf_temp[k] = typebuf[posMapping[k]];\n\t\tmemcpy(typebuf, typebuf_temp, output->length * sizeof(formtype));\n\t\tfree(typebuf_temp);\n\t}\n\nfailure:\n\t*realInlen = pos;\n\tif (input->bufferIndex != origInput->bufferIndex)\n\t\treleaseStringBuffer(input->bufferIndex);\n\treturn 1;\n}\n\nstatic int\nmatchCurrentInput(\n\t\tconst InString *input, int pos, const widechar *passInstructions, int passIC) {\n\tint k;\n\tint kk = pos;\n\tfor (k = passIC + 2; k < passIC + 2 + passInstructions[passIC + 1]; k++)\n\t\tif (input->chars[kk] == ENDSEGMENT || passInstructions[k] != input->chars[kk++])\n\t\t\treturn 0;\n\treturn 1;\n}\n\nstatic int\nswapTest(int swapIC, int *pos, const TranslationTableHeader *table, const InString *input,\n\t\tconst widechar *passInstructions) {\n\tint p = *pos;\n\tTranslationTableOffset swapRuleOffset;\n\tTranslationTableRule *swapRule;\n\tswapRuleOffset = (passInstructions[swapIC + 1] << 16) | passInstructions[swapIC + 2];\n\tswapRule = (TranslationTableRule *)&table->ruleArea[swapRuleOffset];\n\twhile (p - *pos < passInstructions[swapIC + 3]) {\n\t\tint test;\n\t\tif (swapRule->opcode == CTO_SwapDd) {\n\t\t\tfor (test = 1; test < swapRule->charslen; test += 2) {\n\t\t\t\tif (input->chars[p] == swapRule->charsdots[test]) break;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (test = 0; test < swapRule->charslen; test++) {\n\t\t\t\tif (input->chars[p] == swapRule->charsdots[test]) break;\n\t\t\t}\n\t\t}\n\t\tif (test >= swapRule->charslen) return 0;\n\t\tp++;\n\t}\n\tif (passInstructions[swapIC + 3] == passInstructions[swapIC + 4]) {\n\t\t*pos = p;\n\t\treturn 1;\n\t}\n\twhile (p - *pos < passInstructions[swapIC + 4]) {\n\t\tint test;\n\t\tif (swapRule->opcode == CTO_SwapDd) {\n\t\t\tfor (test = 1; test < swapRule->charslen; test += 2) {\n\t\t\t\tif (input->chars[p] == swapRule->charsdots[test]) break;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (test = 0; test < swapRule->charslen; test++) {\n\t\t\t\tif (input->chars[p] == swapRule->charsdots[test]) break;\n\t\t\t}\n\t\t}\n\t\tif (test >= swapRule->charslen) {\n\t\t\t*pos = p;\n\t\t\treturn 1;\n\t\t}\n\t\tp++;\n\t}\n\t*pos = p;\n\treturn 1;\n}\n\nstatic int\nswapReplace(int start, int end, const TranslationTableHeader *table,\n\t\tconst InString *input, OutString *output, int *posMapping,\n\t\tconst widechar *passInstructions, int passIC) {\n\tTranslationTableOffset swapRuleOffset;\n\tTranslationTableRule *swapRule;\n\twidechar *replacements;\n\tint p;\n\tswapRuleOffset = (passInstructions[passIC + 1] << 16) | passInstructions[passIC + 2];\n\tswapRule = (TranslationTableRule *)&table->ruleArea[swapRuleOffset];\n\treplacements = &swapRule->charsdots[swapRule->charslen];\n\tfor (p = start; p < end; p++) {\n\t\tint rep;\n\t\tint test;\n\t\tint k;\n\t\tif (swapRule->opcode == CTO_SwapDd) {\n\t\t\t// A sequence of dot patterns is encoded as the length of the first dot\n\t\t\t// pattern (single widechar) followed by the contents of the first dot pattern\n\t\t\t// (one widechar per cell) followed by the length of the second dot pattern,\n\t\t\t// etc. See the function `compileSwapDots'. Because the third operand of a\n\t\t\t// swapdd rule can only contain single-cell dot patterns, the elements at\n\t\t\t// index 0, 2, ... are \"1\" and the elements at index 1, 3, ... are the dot\n\t\t\t// patterns.\n\t\t\tfor (test = 0; test * 2 + 1 < swapRule->charslen; test++)\n\t\t\t\tif (input->chars[p] == swapRule->charsdots[test * 2 + 1]) break;\n\t\t\tif (test * 2 == swapRule->charslen) continue;\n\t\t} else {\n\t\t\tfor (test = 0; test < swapRule->charslen; test++)\n\t\t\t\tif (input->chars[p] == swapRule->charsdots[test]) break;\n\t\t\tif (test == swapRule->charslen) continue;\n\t\t}\n\t\tk = 0;\n\t\tfor (rep = 0; rep < test; rep++)\n\t\t\tif (swapRule->opcode == CTO_SwapCc)\n\t\t\t\tk++;\n\t\t\telse\n\t\t\t\tk += replacements[k];\n\t\tif (swapRule->opcode == CTO_SwapCc) {\n\t\t\tif ((output->length + 1) > output->maxlength) return 0;\n\t\t\tposMapping[output->length] = p;\n\t\t\toutput->chars[output->length++] = replacements[k];\n\t\t} else {\n\t\t\tint l = replacements[k] - 1;\n\t\t\tint d = output->length + l;\n\t\t\tif (d > output->maxlength) return 0;\n\t\t\twhile (--d >= output->length) posMapping[d] = p;\n\t\t\tmemcpy(&output->chars[output->length], &replacements[k + 1],\n\t\t\t\t\tl * sizeof(*output->chars));\n\t\t\toutput->length += l;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int\nreplaceGrouping(const TranslationTableHeader *table, const InString **input,\n\t\tOutString *output, int transOpcode, int passCharDots,\n\t\tconst widechar *passInstructions, int passIC, int startReplace,\n\t\tTranslationTableRule *groupingRule, widechar groupingOp) {\n\twidechar startCharDots = groupingRule->charsdots[2 * passCharDots];\n\twidechar endCharDots = groupingRule->charsdots[2 * passCharDots + 1];\n\tint p;\n\tint level = 0;\n\tTranslationTableOffset replaceOffset =\n\t\t\tpassInstructions[passIC + 1] << 16 | (passInstructions[passIC + 2] & 0xff);\n\tTranslationTableRule *replaceRule =\n\t\t\t(TranslationTableRule *)&table->ruleArea[replaceOffset];\n\twidechar replaceStart = replaceRule->charsdots[2 * passCharDots];\n\twidechar replaceEnd = replaceRule->charsdots[2 * passCharDots + 1];\n\tif (groupingOp == pass_groupstart) {\n\t\tfor (p = startReplace + 1; p < (*input)->length; p++) {\n\t\t\tif ((*input)->chars[p] == startCharDots) level--;\n\t\t\tif ((*input)->chars[p] == endCharDots) level++;\n\t\t\tif (level == 1) break;\n\t\t}\n\t\tif (p == (*input)->length)\n\t\t\treturn 0;\n\t\telse {\n\t\t\t// Create a new string instead of modifying it. This is slightly less\n\t\t\t// efficient, but makes the code more readable. Grouping is not a much used\n\t\t\t// feature anyway.\n\t\t\tint idx = getStringBuffer((*input)->length);\n\t\t\twidechar *chars = stringBufferPool->buffers[idx];\n\t\t\tmemcpy(chars, (*input)->chars, (*input)->length * sizeof(widechar));\n\t\t\tchars[startReplace] = replaceStart;\n\t\t\tchars[p] = replaceEnd;\n\t\t\t*input = &(InString){\n\t\t\t\t.chars = chars, .length = (*input)->length, .bufferIndex = idx\n\t\t\t};\n\t\t}\n\t} else {\n\t\tif (transOpcode == CTO_Context) {\n\t\t\tstartCharDots = groupingRule->charsdots[2];\n\t\t\tendCharDots = groupingRule->charsdots[3];\n\t\t\treplaceStart = replaceRule->charsdots[2];\n\t\t\treplaceEnd = replaceRule->charsdots[3];\n\t\t}\n\t\toutput->chars[output->length] = replaceEnd;\n\t\tfor (p = output->length - 1; p >= 0; p--) {\n\t\t\tif (output->chars[p] == endCharDots) level--;\n\t\t\tif (output->chars[p] == startCharDots) level++;\n\t\t\tif (level == 1) break;\n\t\t}\n\t\tif (p < 0) return 0;\n\t\toutput->chars[p] = replaceStart;\n\t\toutput->length++;\n\t}\n\treturn 1;\n}\n\nstatic int\nremoveGrouping(const InString **input, OutString *output, int passCharDots,\n\t\tint startReplace, TranslationTableRule *groupingRule, widechar groupingOp) {\n\twidechar startCharDots = groupingRule->charsdots[2 * passCharDots];\n\twidechar endCharDots = groupingRule->charsdots[2 * passCharDots + 1];\n\tint p;\n\tint level = 0;\n\tif (groupingOp == pass_groupstart) {\n\t\tfor (p = startReplace + 1; p < (*input)->length; p++) {\n\t\t\tif ((*input)->chars[p] == startCharDots) level--;\n\t\t\tif ((*input)->chars[p] == endCharDots) level++;\n\t\t\tif (level == 1) break;\n\t\t}\n\t\tif (p == (*input)->length)\n\t\t\treturn 0;\n\t\telse {\n\t\t\t// Create a new string instead of modifying it. This is slightly less\n\t\t\t// efficient, but makes the code more readable. Grouping is not a much used\n\t\t\t// feature anyway.\n\t\t\tint idx = getStringBuffer((*input)->length);\n\t\t\twidechar *chars = stringBufferPool->buffers[idx];\n\t\t\tint len = 0;\n\t\t\tint k;\n\t\t\tfor (k = 0; k < (*input)->length; k++) {\n\t\t\t\tif (k == p) continue;\n\t\t\t\tchars[len++] = (*input)->chars[k];\n\t\t\t}\n\t\t\t*input = &(InString){.chars = chars, .length = len, .bufferIndex = idx };\n\t\t}\n\t} else {\n\t\tfor (p = output->length - 1; p >= 0; p--) {\n\t\t\tif (output->chars[p] == endCharDots) level--;\n\t\t\tif (output->chars[p] == startCharDots) level++;\n\t\t\tif (level == 1) break;\n\t\t}\n\t\tif (p < 0) return 0;\n\t\tp++;\n\t\tfor (; p < output->length; p++) output->chars[p - 1] = output->chars[p];\n\t\toutput->length--;\n\t}\n\treturn 1;\n}\n\nstatic int\ndoPassSearch(const TranslationTableHeader *table, const InString *input,\n\t\tconst TranslationTableRule *transRule, int passCharDots, int pos,\n\t\tconst widechar *passInstructions, int passIC, int *searchIC, int *searchPos,\n\t\tTranslationTableRule *groupingRule, widechar groupingOp) {\n\tint level = 0;\n\tint k, kk;\n\tint not = 0;  // whether next operand should be reversed\n\tTranslationTableOffset ruleOffset;\n\tTranslationTableRule *rule;\n\tTranslationTableCharacterAttributes attributes;\n\twhile (pos < input->length) {\n\t\t*searchIC = passIC + 1;\n\t\t*searchPos = pos;\n\t\twhile (*searchIC < transRule->dotslen) {\n\t\t\tint itsTrue = 1;  // whether we have a match or not\n\t\t\tif (*searchPos > input->length) return 0;\n\t\t\tswitch (passInstructions[*searchIC]) {\n\t\t\tcase pass_lookback:\n\t\t\t\t*searchPos -= passInstructions[*searchIC + 1];\n\t\t\t\tif (*searchPos < 0) {\n\t\t\t\t\t*searchPos = 0;\n\t\t\t\t\titsTrue = 0;\n\t\t\t\t}\n\t\t\t\t*searchIC += 2;\n\t\t\t\tbreak;\n\t\t\tcase pass_not:\n\t\t\t\tnot = !not;\n\t\t\t\t(*searchIC)++;\n\t\t\t\tcontinue;\n\t\t\tcase pass_string:\n\t\t\tcase pass_dots:\n\t\t\t\tkk = *searchPos;\n\t\t\t\tfor (k = *searchIC + 2;\n\t\t\t\t\t\tk < *searchIC + 2 + passInstructions[*searchIC + 1]; k++)\n\t\t\t\t\tif (input->chars[kk] == ENDSEGMENT ||\n\t\t\t\t\t\t\tpassInstructions[k] != input->chars[kk++]) {\n\t\t\t\t\t\titsTrue = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t*searchPos += passInstructions[*searchIC + 1];\n\t\t\t\t*searchIC += passInstructions[*searchIC + 1] + 2;\n\t\t\t\tbreak;\n\t\t\tcase pass_startReplace:\n\t\t\t\t(*searchIC)++;\n\t\t\t\tbreak;\n\t\t\tcase pass_endReplace:\n\t\t\t\t(*searchIC)++;\n\t\t\t\tbreak;\n\t\t\tcase pass_attributes:\n\t\t\t\tattributes = (passInstructions[*searchIC + 1] << 16) |\n\t\t\t\t\t\tpassInstructions[*searchIC + 2];\n\t\t\t\tfor (k = 0; k < passInstructions[*searchIC + 3]; k++) {\n\t\t\t\t\tif (input->chars[*searchPos] == ENDSEGMENT)\n\t\t\t\t\t\titsTrue = 0;\n\t\t\t\t\telse {\n\t\t\t\t\t\titsTrue = ((findCharOrDots(input->chars[(*searchPos)++],\n\t\t\t\t\t\t\t\t\t\t\tpassCharDots,\n\t\t\t\t\t\t\t\t\t\t\ttable)->attributes &\n\t\t\t\t\t\t\t\t\t\t   attributes)\n\t\t\t\t\t\t\t\t\t\t? 1\n\t\t\t\t\t\t\t\t\t\t: 0);\n\t\t\t\t\t\tif (not) itsTrue = !itsTrue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!itsTrue) break;\n\t\t\t\t}\n\t\t\t\tif (itsTrue) {\n\t\t\t\t\tfor (k = passInstructions[*searchIC + 3];\n\t\t\t\t\t\t\tk < passInstructions[*searchIC + 4]; k++) {\n\t\t\t\t\t\tif (input->chars[*searchPos] == ENDSEGMENT) {\n\t\t\t\t\t\t\titsTrue = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!(findCharOrDots(input->chars[*searchPos], passCharDots,\n\t\t\t\t\t\t\t\t\t  table)->attributes &\n\t\t\t\t\t\t\t\t\tattributes)) {\n\t\t\t\t\t\t\tif (!not) break;\n\t\t\t\t\t\t} else if (not)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t(*searchPos)++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnot = 0;\n\t\t\t\t*searchIC += 5;\n\t\t\t\tbreak;\n\t\t\tcase pass_groupstart:\n\t\t\tcase pass_groupend:\n\t\t\t\truleOffset = (passInstructions[*searchIC + 1] << 16) |\n\t\t\t\t\t\tpassInstructions[*searchIC + 2];\n\t\t\t\trule = (TranslationTableRule *)&table->ruleArea[ruleOffset];\n\t\t\t\tif (passInstructions[*searchIC] == pass_groupstart)\n\t\t\t\t\titsTrue = (input->chars[*searchPos] ==\n\t\t\t\t\t\t\t\t\t  rule->charsdots[2 * passCharDots])\n\t\t\t\t\t\t\t? 1\n\t\t\t\t\t\t\t: 0;\n\t\t\t\telse\n\t\t\t\t\titsTrue = (input->chars[*searchPos] ==\n\t\t\t\t\t\t\t\t\t  rule->charsdots[2 * passCharDots + 1])\n\t\t\t\t\t\t\t? 1\n\t\t\t\t\t\t\t: 0;\n\t\t\t\tif (groupingRule != NULL && groupingOp == pass_groupstart &&\n\t\t\t\t\t\trule == groupingRule) {\n\t\t\t\t\tif (input->chars[*searchPos] == rule->charsdots[2 * passCharDots])\n\t\t\t\t\t\tlevel--;\n\t\t\t\t\telse if (input->chars[*searchPos] ==\n\t\t\t\t\t\t\trule->charsdots[2 * passCharDots + 1])\n\t\t\t\t\t\tlevel++;\n\t\t\t\t}\n\t\t\t\t(*searchPos)++;\n\t\t\t\t*searchIC += 3;\n\t\t\t\tbreak;\n\t\t\tcase pass_swap:\n\t\t\t\titsTrue = swapTest(*searchIC, searchPos, table, input, passInstructions);\n\t\t\t\t*searchIC += 5;\n\t\t\t\tbreak;\n\t\t\tcase pass_endTest:\n\t\t\t\tif (itsTrue) {\n\t\t\t\t\tif ((groupingRule && level == 1) || !groupingRule) return 1;\n\t\t\t\t}\n\t\t\t\t*searchIC = transRule->dotslen;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (_lou_handlePassVariableTest(passInstructions, searchIC, &itsTrue))\n\t\t\t\t\tbreak;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((!not&&!itsTrue) || (not&&itsTrue)) break;\n\t\t\tnot = 0;\n\t\t}\n\t\tpos++;\n\t}\n\treturn 0;\n}\n\nstatic int\npassDoTest(const TranslationTableHeader *table, int pos, const InString *input,\n\t\tint transOpcode, const TranslationTableRule *transRule, int *passCharDots,\n\t\twidechar const **passInstructions, int *passIC, PassRuleMatch *match,\n\t\tTranslationTableRule **groupingRule, widechar *groupingOp) {\n\tint searchIC, searchPos;\n\tint k;\n\tint not = 0;  // whether next operand should be reversed\n\tTranslationTableOffset ruleOffset = 0;\n\tTranslationTableRule *rule = NULL;\n\tTranslationTableCharacterAttributes attributes = 0;\n\tint startMatch = pos;\n\tint endMatch = pos;\n\tint startReplace = -1;\n\tint endReplace = -1;\n\t*groupingRule = NULL;\n\t*passInstructions = &transRule->charsdots[transRule->charslen];\n\t*passIC = 0;\n\tif (transOpcode == CTO_Context || transOpcode == CTO_Correct)\n\t\t*passCharDots = 0;\n\telse\n\t\t*passCharDots = 1;\n\twhile (*passIC < transRule->dotslen) {\n\t\tint itsTrue = 1;  // whether we have a match or not\n\t\tif (pos > input->length) return 0;\n\t\tswitch ((*passInstructions)[*passIC]) {\n\t\tcase pass_first:\n\t\t\tif (pos != 0) itsTrue = 0;\n\t\t\t(*passIC)++;\n\t\t\tbreak;\n\t\tcase pass_last:\n\t\t\tif (pos != input->length) itsTrue = 0;\n\t\t\t(*passIC)++;\n\t\t\tbreak;\n\t\tcase pass_lookback:\n\t\t\tpos -= (*passInstructions)[*passIC + 1];\n\t\t\tif (pos < 0) {\n\t\t\t\tsearchPos = 0;\n\t\t\t\titsTrue = 0;\n\t\t\t}\n\t\t\t*passIC += 2;\n\t\t\tbreak;\n\t\tcase pass_not:\n\t\t\tnot = !not;\n\t\t\t(*passIC)++;\n\t\t\tcontinue;\n\t\tcase pass_string:\n\t\tcase pass_dots:\n\t\t\titsTrue = matchCurrentInput(input, pos, *passInstructions, *passIC);\n\t\t\tpos += (*passInstructions)[*passIC + 1];\n\t\t\t*passIC += (*passInstructions)[*passIC + 1] + 2;\n\t\t\tbreak;\n\t\tcase pass_startReplace:\n\t\t\tstartReplace = pos;\n\t\t\t(*passIC)++;\n\t\t\tbreak;\n\t\tcase pass_endReplace:\n\t\t\tendReplace = pos;\n\t\t\t(*passIC)++;\n\t\t\tbreak;\n\t\tcase pass_attributes:\n\t\t\tattributes = ((*passInstructions)[*passIC + 1] << 16) |\n\t\t\t\t\t(*passInstructions)[*passIC + 2];\n\t\t\tfor (k = 0; k < (*passInstructions)[*passIC + 3]; k++) {\n\t\t\t\tif (pos >= input->length) {\n\t\t\t\t\titsTrue = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (input->chars[pos] == ENDSEGMENT) {\n\t\t\t\t\titsTrue = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!(findCharOrDots(input->chars[pos], *passCharDots,\n\t\t\t\t\t\t\t  table)->attributes &\n\t\t\t\t\t\t\tattributes)) {\n\t\t\t\t\tif (!not) {\n\t\t\t\t\t\titsTrue = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (not) {\n\t\t\t\t\titsTrue = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tif (itsTrue) {\n\t\t\t\tfor (k = (*passInstructions)[*passIC + 3];\n\t\t\t\t\t\tk < (*passInstructions)[*passIC + 4] && pos < input->length;\n\t\t\t\t\t\tk++) {\n\t\t\t\t\tif (input->chars[pos] == ENDSEGMENT) {\n\t\t\t\t\t\titsTrue = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (!(findCharOrDots(input->chars[pos], *passCharDots,\n\t\t\t\t\t\t\t\t  table)->attributes &\n\t\t\t\t\t\t\t\tattributes)) {\n\t\t\t\t\t\tif (!not) break;\n\t\t\t\t\t} else if (not)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnot = 0;\n\t\t\t*passIC += 5;\n\t\t\tbreak;\n\t\tcase pass_groupstart:\n\t\tcase pass_groupend:\n\t\t\truleOffset = ((*passInstructions)[*passIC + 1] << 16) |\n\t\t\t\t\t(*passInstructions)[*passIC + 2];\n\t\t\trule = (TranslationTableRule *)&table->ruleArea[ruleOffset];\n\t\t\tif (*passIC == 0 ||\n\t\t\t\t\t(*passIC > 0 &&\n\t\t\t\t\t\t\t(*passInstructions)[*passIC - 1] == pass_startReplace)) {\n\t\t\t\t*groupingRule = rule;\n\t\t\t\t*groupingOp = (*passInstructions)[*passIC];\n\t\t\t}\n\t\t\tif ((*passInstructions)[*passIC] == pass_groupstart)\n\t\t\t\titsTrue =\n\t\t\t\t\t\t(input->chars[pos] == rule->charsdots[2 * *passCharDots]) ? 1 : 0;\n\t\t\telse\n\t\t\t\titsTrue = (input->chars[pos] == rule->charsdots[2 * *passCharDots + 1])\n\t\t\t\t\t\t? 1\n\t\t\t\t\t\t: 0;\n\t\t\tpos++;\n\t\t\t*passIC += 3;\n\t\t\tbreak;\n\t\tcase pass_swap:\n\t\t\titsTrue = swapTest(*passIC, &pos, table, input, *passInstructions);\n\t\t\t*passIC += 5;\n\t\t\tbreak;\n\t\tcase pass_search:\n\t\t\titsTrue = doPassSearch(table, input, transRule, *passCharDots, pos,\n\t\t\t\t\t*passInstructions, *passIC, &searchIC, &searchPos, *groupingRule,\n\t\t\t\t\t*groupingOp);\n\t\t\tif ((!not&&!itsTrue) || (not&&itsTrue)) return 0;\n\t\t\t*passIC = searchIC;\n\t\t\tpos = searchPos;\n\t\tcase pass_endTest:\n\t\t\t(*passIC)++;\n\t\t\tendMatch = pos;\n\t\t\tif (startReplace == -1) {\n\t\t\t\tstartReplace = startMatch;\n\t\t\t\tendReplace = endMatch;\n\t\t\t}\n\t\t\t*match = (PassRuleMatch){.startMatch = startMatch,\n\t\t\t\t.startReplace = startReplace,\n\t\t\t\t.endReplace = endReplace,\n\t\t\t\t.endMatch = endMatch };\n\t\t\treturn 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (_lou_handlePassVariableTest(*passInstructions, passIC, &itsTrue)) break;\n\t\t\treturn 0;\n\t\t}\n\t\tif ((!not&&!itsTrue) || (not&&itsTrue)) return 0;\n\t\tnot = 0;\n\t}\n\treturn 0;\n}\n\nstatic int\ncopyCharacters(int from, int to, const TranslationTableHeader *table,\n\t\tconst InString *input, OutString *output, int *posMapping, int transOpcode,\n\t\tint *cursorPosition, int *cursorStatus) {\n\tif (transOpcode == CTO_Context) {\n\t\twhile (from < to) {\n\t\t\tif (!putCharacter(input->chars[from], table, from, input, output, posMapping,\n\t\t\t\t\t\tcursorPosition, cursorStatus))\n\t\t\t\treturn 0;\n\t\t\tfrom++;\n\t\t}\n\t} else {\n\t\tif (to > from) {\n\t\t\tif ((output->length + to - from) > output->maxlength) return 0;\n\t\t\twhile (to > from) {\n\t\t\t\tposMapping[output->length] = from;\n\t\t\t\toutput->chars[output->length] = input->chars[from];\n\t\t\t\toutput->length++;\n\t\t\t\tfrom++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic int\npassDoAction(const TranslationTableHeader *table, const InString **input,\n\t\tOutString *output, int *posMapping, int transOpcode,\n\t\tconst TranslationTableRule **transRule, int passCharDots,\n\t\tconst widechar *passInstructions, int passIC, int *pos, PassRuleMatch match,\n\t\tint *cursorPosition, int *cursorStatus, TranslationTableRule *groupingRule,\n\t\twidechar groupingOp) {\n\tint k;\n\tTranslationTableOffset ruleOffset = 0;\n\tTranslationTableRule *rule = NULL;\n\tint destStartMatch = output->length;\n\tint destStartReplace;\n\tint newPos = match.endReplace;\n\n\tif (!copyCharacters(match.startMatch, match.startReplace, table, *input, output,\n\t\t\t\tposMapping, transOpcode, cursorPosition, cursorStatus))\n\t\treturn 0;\n\tdestStartReplace = output->length;\n\n\twhile (passIC < (*transRule)->dotslen) switch (passInstructions[passIC]) {\n\t\tcase pass_string:\n\t\tcase pass_dots:\n\t\t\tif ((output->length + passInstructions[passIC + 1]) > output->maxlength)\n\t\t\t\treturn 0;\n\t\t\tfor (k = 0; k < passInstructions[passIC + 1]; ++k)\n\t\t\t\tposMapping[output->length + k] = match.startReplace;\n\t\t\tmemcpy(&output->chars[output->length], &passInstructions[passIC + 2],\n\t\t\t\t\tpassInstructions[passIC + 1] * CHARSIZE);\n\t\t\toutput->length += passInstructions[passIC + 1];\n\t\t\tpassIC += passInstructions[passIC + 1] + 2;\n\t\t\tbreak;\n\t\tcase pass_groupstart:\n\t\t\truleOffset =\n\t\t\t\t\t(passInstructions[passIC + 1] << 16) | passInstructions[passIC + 2];\n\t\t\trule = (TranslationTableRule *)&table->ruleArea[ruleOffset];\n\t\t\tposMapping[output->length] = match.startMatch;\n\t\t\toutput->chars[output->length++] = rule->charsdots[2 * passCharDots];\n\t\t\tpassIC += 3;\n\t\t\tbreak;\n\t\tcase pass_groupend:\n\t\t\truleOffset =\n\t\t\t\t\t(passInstructions[passIC + 1] << 16) | passInstructions[passIC + 2];\n\t\t\trule = (TranslationTableRule *)&table->ruleArea[ruleOffset];\n\t\t\tposMapping[output->length] = match.startMatch;\n\t\t\toutput->chars[output->length++] = rule->charsdots[2 * passCharDots + 1];\n\t\t\tpassIC += 3;\n\t\t\tbreak;\n\t\tcase pass_swap:\n\t\t\tif (!swapReplace(match.startReplace, match.endReplace, table, *input, output,\n\t\t\t\t\t\tposMapping, passInstructions, passIC))\n\t\t\t\treturn 0;\n\t\t\tpassIC += 3;\n\t\t\tbreak;\n\t\tcase pass_groupreplace:\n\t\t\tif (!groupingRule ||\n\t\t\t\t\t!replaceGrouping(table, input, output, transOpcode, passCharDots,\n\t\t\t\t\t\t\tpassInstructions, passIC, match.startReplace, groupingRule,\n\t\t\t\t\t\t\tgroupingOp))\n\t\t\t\treturn 0;\n\t\t\tpassIC += 3;\n\t\t\tbreak;\n\t\tcase pass_omit:\n\t\t\tif (groupingRule)\n\t\t\t\tremoveGrouping(input, output, passCharDots, match.startReplace,\n\t\t\t\t\t\tgroupingRule, groupingOp);\n\t\t\tpassIC++;\n\t\t\tbreak;\n\t\tcase pass_copy: {\n\t\t\tint count = destStartReplace - destStartMatch;\n\t\t\tif (count > 0) {\n\t\t\t\tmemmove(&output->chars[destStartMatch], &output->chars[destStartReplace],\n\t\t\t\t\t\tcount * sizeof(*output->chars));\n\t\t\t\toutput->length -= count;\n\t\t\t\tdestStartReplace = destStartMatch;\n\t\t\t}\n\t\t}\n\n\t\t\tif (!copyCharacters(match.startReplace, match.endReplace, table, *input,\n\t\t\t\t\t\toutput, posMapping, transOpcode, cursorPosition, cursorStatus))\n\t\t\t\treturn 0;\n\t\t\tnewPos = match.endMatch;\n\t\t\tpassIC++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (_lou_handlePassVariableAction(passInstructions, &passIC)) break;\n\t\t\treturn 0;\n\t\t}\n\t*pos = newPos;\n\treturn 1;\n}\n\nstatic void\npassSelectRule(const TranslationTableHeader *table, int pos, int currentPass,\n\t\tconst InString *input, int *transOpcode, const TranslationTableRule **transRule,\n\t\tint *transCharslen, int *passCharDots, widechar const **passInstructions,\n\t\tint *passIC, PassRuleMatch *match, TranslationTableRule **groupingRule,\n\t\twidechar *groupingOp) {\n\tif (!findForPassRule(table, pos, currentPass, input, transOpcode, transRule,\n\t\t\t\ttransCharslen, passCharDots, passInstructions, passIC, match,\n\t\t\t\tgroupingRule, groupingOp)) {\n\t\t*transOpcode = CTO_Always;\n\t}\n}\n\nstatic int\ntranslatePass(const TranslationTableHeader *table, int currentPass, const InString *input,\n\t\tOutString *output, int *posMapping, int *realInlen, int *posIncremented,\n\t\tint *cursorPosition, int *cursorStatus) {\n\tint pos;\n\tint transOpcode;\n\tconst TranslationTableRule *transRule;\n\tint transCharslen;\n\tint passCharDots;\n\tconst widechar *passInstructions;\n\tint passIC; /* Instruction counter */\n\tPassRuleMatch patternMatch;\n\tTranslationTableRule *groupingRule;\n\twidechar groupingOp;\n\tconst InString *origInput = input;\n\tpos = output->length = 0;\n\t*posIncremented = 1;\n\t_lou_resetPassVariables();\n\twhile (pos < input->length) { /* the main multipass translation loop */\n\t\tpassSelectRule(table, pos, currentPass, input, &transOpcode, &transRule,\n\t\t\t\t&transCharslen, &passCharDots, &passInstructions, &passIC, &patternMatch,\n\t\t\t\t&groupingRule, &groupingOp);\n\t\t*posIncremented = 1;\n\t\tswitch (transOpcode) {\n\t\tcase CTO_Context:\n\t\tcase CTO_Pass2:\n\t\tcase CTO_Pass3:\n\t\tcase CTO_Pass4: {\n\t\t\tconst InString *inputBefore = input;\n\t\t\tint posBefore = pos;\n\t\t\tif (appliedRules != NULL && appliedRulesCount < maxAppliedRules)\n\t\t\t\tappliedRules[appliedRulesCount++] = transRule;\n\t\t\tif (!passDoAction(table, &input, output, posMapping, transOpcode, &transRule,\n\t\t\t\t\t\tpassCharDots, passInstructions, passIC, &pos, patternMatch,\n\t\t\t\t\t\tcursorPosition, cursorStatus, groupingRule, groupingOp))\n\t\t\t\tgoto failure;\n\t\t\tif (input->bufferIndex != inputBefore->bufferIndex &&\n\t\t\t\t\tinputBefore->bufferIndex != origInput->bufferIndex)\n\t\t\t\treleaseStringBuffer(inputBefore->bufferIndex);\n\t\t\tif (pos == posBefore) *posIncremented = 0;\n\t\t\tbreak;\n\t\t}\n\t\tcase CTO_Always:\n\t\t\tif ((output->length + 1) > output->maxlength) goto failure;\n\t\t\tposMapping[output->length] = pos;\n\t\t\toutput->chars[output->length++] = input->chars[pos++];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto failure;\n\t\t}\n\t}\nfailure:\n\tif (pos < input->length) {\n\t\twhile (checkAttr(input->chars[pos], CTC_Space, 1, table))\n\t\t\tif (++pos == input->length) break;\n\t}\n\t*realInlen = pos;\n\tif (input->bufferIndex != origInput->bufferIndex)\n\t\treleaseStringBuffer(input->bufferIndex);\n\treturn 1;\n}\n\n#define MIN(a, b) (((a) < (b)) ? (a) : (b))\n\nstatic int\ntranslateString(const TranslationTableHeader *table, int mode, int currentPass,\n\t\tconst InString *input, OutString *output, int *posMapping, formtype *typebuf,\n\t\tunsigned char *srcSpacing, unsigned char *destSpacing, unsigned int *wordBuffer,\n\t\tEmphasisInfo *emphasisBuffer, int haveEmphasis, int *realInlen,\n\t\tint *posIncremented, int *cursorPosition, int *cursorStatus, int compbrlStart,\n\t\tint compbrlEnd);\n\nint EXPORT_CALL\nlou_translateString(const char *tableList, const widechar *inbufx, int *inlen,\n\t\twidechar *outbuf, int *outlen, formtype *typeform, char *spacing, int mode) {\n\treturn lou_translate(tableList, inbufx, inlen, outbuf, outlen, typeform, spacing,\n\t\t\tNULL, NULL, NULL, mode);\n}\n\nint EXPORT_CALL\nlou_translate(const char *tableList, const widechar *inbufx, int *inlen, widechar *outbuf,\n\t\tint *outlen, formtype *typeform, char *spacing, int *outputPos, int *inputPos,\n\t\tint *cursorPos, int mode) {\n\treturn _lou_translateWithTracing(tableList, inbufx, inlen, outbuf, outlen, typeform,\n\t\t\tspacing, outputPos, inputPos, cursorPos, mode, NULL, NULL);\n}\n\nint EXPORT_CALL\n_lou_translateWithTracing(const char *tableList, const widechar *inbufx, int *inlen,\n\t\twidechar *outbuf, int *outlen, formtype *typeform, char *spacing, int *outputPos,\n\t\tint *inputPos, int *cursorPos, int mode, const TranslationTableRule **rules,\n\t\tint *rulesLen) {\n\t// int i;\n\t// for(i = 0; i < *inlen; i++)\n\t// {\n\t// \toutbuf[i] = inbufx[i];\n\t// \tif(inputPos)\n\t// \t\tinputPos[i] = i;\n\t// \tif(outputPos)\n\t// \t\toutputPos[i] = i;\n\t// }\n\t// *inlen = i;\n\t// *outlen = i;\n\t// return 1;\n\tconst TranslationTableHeader *table;\n\tconst InString *input;\n\tOutString output;\n\t// posMapping contains position mapping info between the initial input and the output\n\t// of the current pass. It is 1 longer than the output. The values are monotonically\n\t// increasing and can range between -1 and the input length. At the end the position\n\t// info is passed to the user as an inputPos and outputPos array. inputPos has the\n\t// length of the final output and has values ranging from 0 to inlen-1. outputPos has\n\t// the length of the initial input and has values ranging from 0 to outlen-1.\n\tint *posMapping;\n\tint *posMapping1;\n\tint *posMapping2;\n\tint *posMapping3;\n\tformtype *typebuf;\n\tunsigned char *srcSpacing;\n\tunsigned char *destSpacing;\n\tunsigned int *wordBuffer;\n\tEmphasisInfo *emphasisBuffer;\n\tint cursorPosition;\n\tint cursorStatus;\n\tint haveEmphasis;\n\tint compbrlStart = -1;\n\tint compbrlEnd = -1;\n\tint k;\n\tint goodTrans = 1;\n\tint posIncremented;\n\tif (tableList == NULL || inbufx == NULL || inlen == NULL || outbuf == NULL ||\n\t\t\toutlen == NULL)\n\t\treturn 0;\n\t_lou_logMessage(\n\t\t\tLOG_ALL, \"Performing translation: tableList=%s, inlen=%d\", tableList, *inlen);\n\t_lou_logWidecharBuf(LOG_ALL, \"Inbuf=\", inbufx, *inlen);\n\n\tif (mode & pass1Only) {\n\t\t_lou_logMessage(LOG_WARN, \"warning: pass1Only mode is no longer supported.\");\n\t}\n\n\ttable = lou_getTable(tableList);\n\tif (table == NULL || *inlen < 0 || *outlen < 0) return 0;\n\tk = 0;\n\twhile (k < *inlen && inbufx[k]) k++;\n\tinput = &(InString){.chars = inbufx, .length = k, .bufferIndex = -1 };\n\thaveEmphasis = 0;\n\tif (!(typebuf = _lou_allocMem(alloc_typebuf, 0, input->length, *outlen))) return 0;\n\tif (typeform != NULL) {\n\t\tfor (k = 0; k < input->length; k++) {\n\t\t\ttypebuf[k] = typeform[k];\n\t\t\tif (typebuf[k] & EMPHASIS) haveEmphasis = 1;\n\t\t}\n\t} else\n\t\tmemset(typebuf, 0, input->length * sizeof(formtype));\n\n\tif ((wordBuffer = _lou_allocMem(alloc_wordBuffer, 0, input->length, *outlen)))\n\t\tmemset(wordBuffer, 0, (input->length + 4) * sizeof(unsigned int));\n\telse\n\t\treturn 0;\n\tif ((emphasisBuffer = _lou_allocMem(alloc_emphasisBuffer, 0, input->length, *outlen)))\n\t\tmemset(emphasisBuffer, 0, (input->length + 4) * sizeof(EmphasisInfo));\n\telse\n\t\treturn 0;\n\n\tif (!(spacing == NULL || *spacing == 'X'))\n\t\tsrcSpacing = (unsigned char *)spacing;\n\telse\n\t\tsrcSpacing = NULL;\n\tif (outputPos != NULL)\n\t\tfor (k = 0; k < input->length; k++) outputPos[k] = -1;\n\tif (cursorPos != NULL && *cursorPos >= 0) {\n\t\tcursorStatus = 0;\n\t\tcursorPosition = *cursorPos;\n\t\tif ((mode & (compbrlAtCursor | compbrlLeftCursor))) {\n\t\t\tcompbrlStart = cursorPosition;\n\t\t\tif (checkAttr(input->chars[compbrlStart], CTC_Space, 0, table))\n\t\t\t\tcompbrlEnd = compbrlStart + 1;\n\t\t\telse {\n\t\t\t\twhile (compbrlStart >= 0 &&\n\t\t\t\t\t\t!checkAttr(input->chars[compbrlStart], CTC_Space, 0, table))\n\t\t\t\t\tcompbrlStart--;\n\t\t\t\tcompbrlStart++;\n\t\t\t\tcompbrlEnd = cursorPosition;\n\t\t\t\tif (!(mode & compbrlLeftCursor))\n\t\t\t\t\twhile (compbrlEnd < input->length &&\n\t\t\t\t\t\t\t!checkAttr(input->chars[compbrlEnd], CTC_Space, 0, table))\n\t\t\t\t\t\tcompbrlEnd++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcursorPosition = -1;\n\t\tcursorStatus = 1; /* so it won't check cursor position */\n\t}\n\tif (!(posMapping1 = _lou_allocMem(alloc_posMapping1, 0, input->length, *outlen)))\n\t\treturn 0;\n\tif (table->numPasses > 1 || table->corrections) {\n\t\tif (!(posMapping2 = _lou_allocMem(alloc_posMapping2, 0, input->length, *outlen)))\n\t\t\treturn 0;\n\t\tif (!(posMapping3 = _lou_allocMem(alloc_posMapping3, 0, input->length, *outlen)))\n\t\t\treturn 0;\n\t}\n\tif (srcSpacing != NULL) {\n\t\tif (!(destSpacing = _lou_allocMem(alloc_destSpacing, 0, input->length, *outlen)))\n\t\t\tgoodTrans = 0;\n\t\telse\n\t\t\tmemset(destSpacing, '*', *outlen);\n\t} else\n\t\tdestSpacing = NULL;\n\tappliedRulesCount = 0;\n\tif (rules != NULL && rulesLen != NULL) {\n\t\tappliedRules = rules;\n\t\tmaxAppliedRules = *rulesLen;\n\t} else {\n\t\tappliedRules = NULL;\n\t\tmaxAppliedRules = 0;\n\t}\n\t{\n\t\tint idx;\n\t\tif (!stringBufferPool) initStringBufferPool();\n\t\tfor (idx = 0; idx < stringBufferPool->size; idx++) releaseStringBuffer(idx);\n\t\tidx = getStringBuffer(*outlen);\n\t\toutput = (OutString){.chars = stringBufferPool->buffers[idx],\n\t\t\t.maxlength = *outlen,\n\t\t\t.length = 0,\n\t\t\t.bufferIndex = idx };\n\t}\n\tposMapping = posMapping1;\n\n\tint currentPass = table->corrections ? 0 : 1;\n\tint *passPosMapping = posMapping;\n\twhile (1) {\n\t\tint realInlen;\n\t\tswitch (currentPass) {\n\t\tcase 0:\n\t\t\tgoodTrans = makeCorrections(table, input, &output, passPosMapping, typebuf,\n\t\t\t\t\t&realInlen, &posIncremented, &cursorPosition, &cursorStatus);\n\t\t\tbreak;\n\t\tcase 1: {\n\t\t\tgoodTrans = translateString(table, mode, currentPass, input, &output,\n\t\t\t\t\tpassPosMapping, typebuf, srcSpacing, destSpacing, wordBuffer,\n\t\t\t\t\temphasisBuffer, haveEmphasis, &realInlen, &posIncremented,\n\t\t\t\t\t&cursorPosition, &cursorStatus, compbrlStart, compbrlEnd);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tgoodTrans = translatePass(table, currentPass, input, &output, passPosMapping,\n\t\t\t\t\t&realInlen, &posIncremented, &cursorPosition, &cursorStatus);\n\t\t\tbreak;\n\t\t}\n\t\tpassPosMapping[output.length] = realInlen;\n\t\tif (passPosMapping == posMapping) {\n\t\t\tpassPosMapping = posMapping2;\n\t\t} else {\n\t\t\tint *prevPosMapping = posMapping3;\n\t\t\tmemcpy((int *)prevPosMapping, posMapping, (*outlen + 1) * sizeof(int));\n\t\t\tfor (k = 0; k <= output.length; k++)\n\t\t\t\tif (passPosMapping[k] < 0)\n\t\t\t\t\tposMapping[k] = prevPosMapping[0];\n\t\t\t\telse\n\t\t\t\t\tposMapping[k] = prevPosMapping[passPosMapping[k]];\n\t\t}\n\t\tcurrentPass++;\n\t\tif (currentPass <= table->numPasses && goodTrans) {\n\t\t\tint idx;\n\t\t\treleaseStringBuffer(input->bufferIndex);\n\t\t\tinput = &(InString){.chars = output.chars,\n\t\t\t\t.length = output.length,\n\t\t\t\t.bufferIndex = output.bufferIndex };\n\t\t\tidx = getStringBuffer(*outlen);\n\t\t\toutput = (OutString){.chars = stringBufferPool->buffers[idx],\n\t\t\t\t.maxlength = *outlen,\n\t\t\t\t.length = 0,\n\t\t\t\t.bufferIndex = idx };\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tif (goodTrans) {\n\t\tfor (k = 0; k < output.length; k++) {\n\t\t\tif (typeform != NULL) {\n\t\t\t\tif ((output.chars[k] & (B7 | B8)))\n\t\t\t\t\ttypeform[k] = '8';\n\t\t\t\telse\n\t\t\t\t\ttypeform[k] = '0';\n\t\t\t}\n\t\t\tif ((mode & dotsIO)) {\n\t\t\t\tif ((mode & ucBrl))\n\t\t\t\t\toutbuf[k] = ((output.chars[k] & 0xff) | 0x2800);\n\t\t\t\telse\n\t\t\t\t\toutbuf[k] = output.chars[k];\n\t\t\t} else\n\t\t\t\toutbuf[k] = _lou_getCharFromDots(output.chars[k]);\n\t\t}\n\t\t*inlen = posMapping[output.length];\n\t\t*outlen = output.length;\n\t\t// Compute inputPos and outputPos from posMapping. The value at the last index of\n\t\t// posMapping is currectly not used.\n\t\tif (inputPos != NULL) {\n\t\t\tfor (k = 0; k < *outlen; k++)\n\t\t\t\tif (posMapping[k] < 0)\n\t\t\t\t\tinputPos[k] = 0;\n\t\t\t\telse if (posMapping[k] > *inlen - 1)\n\t\t\t\t\tinputPos[k] = *inlen - 1;\n\t\t\t\telse\n\t\t\t\t\tinputPos[k] = posMapping[k];\n\t\t}\n\t\tif (outputPos != NULL) {\n\t\t\tint inpos = -1;\n\t\t\tint outpos = -1;\n\t\t\tfor (k = 0; k < *outlen; k++)\n\t\t\t\tif (posMapping[k] > inpos) {\n\t\t\t\t\twhile (inpos < posMapping[k]) {\n\t\t\t\t\t\tif (inpos >= 0 && inpos < *inlen)\n\t\t\t\t\t\t\toutputPos[inpos] = outpos < 0 ? 0 : outpos;\n\t\t\t\t\t\tinpos++;\n\t\t\t\t\t}\n\t\t\t\t\toutpos = k;\n\t\t\t\t}\n\t\t\tif (inpos < 0) inpos = 0;\n\t\t\twhile (inpos < *inlen) outputPos[inpos++] = outpos;\n\t\t}\n\t}\n\tif (destSpacing != NULL) {\n\t\tmemcpy(srcSpacing, destSpacing, input->length);\n\t\tsrcSpacing[input->length] = 0;\n\t}\n\tif (cursorPos != NULL && *cursorPos != -1) {\n\t\tif (outputPos != NULL)\n\t\t\t*cursorPos = outputPos[*cursorPos];\n\t\telse\n\t\t\t*cursorPos = cursorPosition;\n\t}\n\tif (rulesLen != NULL) *rulesLen = appliedRulesCount;\n\t_lou_logMessage(LOG_ALL, \"Translation complete: outlen=%d\", *outlen);\n\t_lou_logWidecharBuf(LOG_ALL, \"Outbuf=\", (const widechar *)outbuf, *outlen);\n\n\treturn goodTrans;\n}\n\nint EXPORT_CALL\nlou_translatePrehyphenated(const char *tableList, const widechar *inbufx, int *inlen,\n\t\twidechar *outbuf, int *outlen, formtype *typeform, char *spacing, int *outputPos,\n\t\tint *inputPos, int *cursorPos, char *inputHyphens, char *outputHyphens,\n\t\tint mode) {\n\tint rv = 1;\n\tint *alloc_inputPos = NULL;\n\tif (inputHyphens != NULL) {\n\t\tif (outputHyphens == NULL) return 0;\n\t\tif (inputPos == NULL) {\n\t\t\tif ((alloc_inputPos = malloc(*outlen * sizeof(int))) == NULL)\n\t\t\t\t_lou_outOfMemory();\n\t\t\tinputPos = alloc_inputPos;\n\t\t}\n\t}\n\tif (lou_translate(tableList, inbufx, inlen, outbuf, outlen, typeform, spacing,\n\t\t\t\toutputPos, inputPos, cursorPos, mode)) {\n\t\tif (inputHyphens != NULL) {\n\t\t\tint inpos = 0;\n\t\t\tint outpos;\n\t\t\tfor (outpos = 0; outpos < *outlen; outpos++) {\n\t\t\t\tint new_inpos = inputPos[outpos];\n\t\t\t\tif (new_inpos < inpos) {\n\t\t\t\t\trv = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (new_inpos > inpos)\n\t\t\t\t\toutputHyphens[outpos] = inputHyphens[new_inpos];\n\t\t\t\telse\n\t\t\t\t\toutputHyphens[outpos] = '0';\n\t\t\t\tinpos = new_inpos;\n\t\t\t}\n\t\t}\n\t}\n\tif (alloc_inputPos != NULL) free(alloc_inputPos);\n\treturn rv;\n}\n\nstatic int\nhyphenate(const widechar *word, int wordSize, char *hyphens,\n\t\tconst TranslationTableHeader *table) {\n\twidechar *prepWord;\n\tint i, k, limit;\n\tint stateNum;\n\twidechar ch;\n\tHyphenationState *statesArray =\n\t\t\t(HyphenationState *)&table->ruleArea[table->hyphenStatesArray];\n\tHyphenationState *currentState;\n\tHyphenationTrans *transitionsArray;\n\tchar *hyphenPattern;\n\tint patternOffset;\n\tif (!table->hyphenStatesArray || (wordSize + 3) > MAXSTRING) return 0;\n\tprepWord = (widechar *)calloc(wordSize + 3, sizeof(widechar));\n\t/* prepWord is of the format \".hello.\"\n\t * hyphens is the length of the word \"hello\" \"00000\" */\n\tprepWord[0] = '.';\n\tfor (i = 0; i < wordSize; i++) {\n\t\tprepWord[i + 1] = (findCharOrDots(word[i], 0, table))->lowercase;\n\t\thyphens[i] = '0';\n\t}\n\tprepWord[wordSize + 1] = '.';\n\n\t/* now, run the finite state machine */\n\tstateNum = 0;\n\n\t// we need to walk all of \".hello.\"\n\tfor (i = 0; i < wordSize + 2; i++) {\n\t\tch = prepWord[i];\n\t\twhile (1) {\n\t\t\tif (stateNum == 0xffff) {\n\t\t\t\tstateNum = 0;\n\t\t\t\tgoto nextLetter;\n\t\t\t}\n\t\t\tcurrentState = &statesArray[stateNum];\n\t\t\tif (currentState->trans.offset) {\n\t\t\t\ttransitionsArray =\n\t\t\t\t\t\t(HyphenationTrans *)&table->ruleArea[currentState->trans.offset];\n\t\t\t\tfor (k = 0; k < currentState->numTrans; k++) {\n\t\t\t\t\tif (transitionsArray[k].ch == ch) {\n\t\t\t\t\t\tstateNum = transitionsArray[k].newState;\n\t\t\t\t\t\tgoto stateFound;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstateNum = currentState->fallbackState;\n\t\t}\n\tstateFound:\n\t\tcurrentState = &statesArray[stateNum];\n\t\tif (currentState->hyphenPattern) {\n\t\t\thyphenPattern = (char *)&table->ruleArea[currentState->hyphenPattern];\n\t\t\tpatternOffset = i + 1 - (int)strlen(hyphenPattern);\n\n\t\t\t/* Need to ensure that we don't overrun hyphens,\n\t\t\t * in some cases hyphenPattern is longer than the remaining letters,\n\t\t\t * and if we write out all of it we would have overshot our buffer. */\n\t\t\tlimit = MIN((int)strlen(hyphenPattern), wordSize - patternOffset);\n\t\t\tfor (k = 0; k < limit; k++) {\n\t\t\t\tif (hyphens[patternOffset + k] < hyphenPattern[k])\n\t\t\t\t\thyphens[patternOffset + k] = hyphenPattern[k];\n\t\t\t}\n\t\t}\n\tnextLetter:;\n\t}\n\thyphens[wordSize] = 0;\n\tfree(prepWord);\n\treturn 1;\n}\n\nstatic int\ndoCompTrans(int start, int end, const TranslationTableHeader *table, int *pos,\n\t\tconst InString *input, OutString *output, int *posMapping,\n\t\tEmphasisInfo *emphasisBuffer, const TranslationTableRule **transRule,\n\t\tint *cursorPosition, int *cursorStatus);\n\nstatic int\nfor_updatePositions(const widechar *outChars, int inLength, int outLength, int shift,\n\t\tint pos, const InString *input, OutString *output, int *posMapping,\n\t\tint *cursorPosition, int *cursorStatus) {\n\tint k;\n\tif ((output->length + outLength) > output->maxlength ||\n\t\t\t(pos + inLength) > input->length)\n\t\treturn 0;\n\tmemcpy(&output->chars[output->length], outChars, outLength * CHARSIZE);\n\tif (!*cursorStatus) {\n\t\tif (*cursorPosition >= pos && *cursorPosition < (pos + inLength)) {\n\t\t\t*cursorPosition = output->length;\n\t\t\t*cursorStatus = 1;\n\t\t} else if (input->chars[*cursorPosition] == 0 &&\n\t\t\t\t*cursorPosition == (pos + inLength)) {\n\t\t\t*cursorPosition = output->length + outLength / 2 + 1;\n\t\t\t*cursorStatus = 1;\n\t\t}\n\t} else if (*cursorStatus == 2 && *cursorPosition == pos)\n\t\t*cursorPosition = output->length;\n\tfor (k = 0; k < outLength; k++) posMapping[output->length + k] = pos + shift;\n\toutput->length += outLength;\n\treturn 1;\n}\n\nstatic int\nsyllableBreak(const TranslationTableHeader *table, int pos, const InString *input,\n\t\tint transCharslen) {\n\tint wordStart = 0;\n\tint wordEnd = 0;\n\tint wordSize = 0;\n\tint k = 0;\n\tchar *hyphens = NULL;\n\tfor (wordStart = pos; wordStart >= 0; wordStart--)\n\t\tif (!((findCharOrDots(input->chars[wordStart], 0, table))->attributes &\n\t\t\t\t\tCTC_Letter)) {\n\t\t\twordStart++;\n\t\t\tbreak;\n\t\t}\n\tif (wordStart < 0) wordStart = 0;\n\tfor (wordEnd = pos; wordEnd < input->length; wordEnd++)\n\t\tif (!((findCharOrDots(input->chars[wordEnd], 0, table))->attributes &\n\t\t\t\t\tCTC_Letter)) {\n\t\t\twordEnd--;\n\t\t\tbreak;\n\t\t}\n\tif (wordEnd == input->length) wordEnd--;\n\t/* At this stage wordStart is the 0 based index of the first letter in the word,\n\t * wordEnd is the 0 based index of the last letter in the word.\n\t * example: \"hello\" wordstart=0, wordEnd=4. */\n\twordSize = wordEnd - wordStart + 1;\n\thyphens = (char *)calloc(wordSize + 1, sizeof(char));\n\tif (!hyphenate(&input->chars[wordStart], wordSize, hyphens, table)) {\n\t\tfree(hyphens);\n\t\treturn 0;\n\t}\n\tfor (k = pos - wordStart + 1; k < (pos - wordStart + transCharslen); k++)\n\t\tif (hyphens[k] & 1) {\n\t\t\tfree(hyphens);\n\t\t\treturn 1;\n\t\t}\n\tfree(hyphens);\n\treturn 0;\n}\n\nstatic void\nsetBefore(const TranslationTableHeader *table, int pos, const InString *input,\n\t\tTranslationTableCharacterAttributes *beforeAttributes) {\n\twidechar before;\n\tif (pos >= 2 && input->chars[pos - 1] == ENDSEGMENT)\n\t\tbefore = input->chars[pos - 2];\n\telse\n\t\tbefore = (pos == 0) ? ' ' : input->chars[pos - 1];\n\t*beforeAttributes = (findCharOrDots(before, 0, table))->attributes;\n}\n\nstatic void\nsetAfter(int length, const TranslationTableHeader *table, int pos, const InString *input,\n\t\tTranslationTableCharacterAttributes *afterAttributes) {\n\twidechar after;\n\tif ((pos + length + 2) < input->length && input->chars[pos + 1] == ENDSEGMENT)\n\t\tafter = input->chars[pos + 2];\n\telse\n\t\tafter = (pos + length < input->length) ? input->chars[pos + length] : ' ';\n\t*afterAttributes = (findCharOrDots(after, 0, table))->attributes;\n}\n\nstatic int\nbrailleIndicatorDefined(TranslationTableOffset offset,\n\t\tconst TranslationTableHeader *table, const TranslationTableRule **indicRule) {\n\tif (!offset) return 0;\n\t*indicRule = (TranslationTableRule *)&table->ruleArea[offset];\n\treturn 1;\n}\n\nstatic int\nvalidMatch(const TranslationTableHeader *table, int pos, const InString *input,\n\t\tformtype *typebuf, const TranslationTableRule *transRule, int transCharslen) {\n\t/* Analyze the typeform parameter and also check for capitalization */\n\tTranslationTableCharacter *inputChar;\n\tTranslationTableCharacter *ruleChar;\n\tTranslationTableCharacterAttributes prevAttr = 0;\n\tint k;\n\tint kk = 0;\n\tif (!transCharslen) return 0;\n\tfor (k = pos; k < pos + transCharslen; k++) {\n\t\tif (input->chars[k] == ENDSEGMENT) {\n\t\t\tif (k == pos && transCharslen == 1)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t\tinputChar = findCharOrDots(input->chars[k], 0, table);\n\t\tif (k == pos) prevAttr = inputChar->attributes;\n\t\truleChar = findCharOrDots(transRule->charsdots[kk++], 0, table);\n\t\tif ((inputChar->lowercase != ruleChar->lowercase)) return 0;\n\t\tif (typebuf != NULL && (typebuf[pos] & CAPSEMPH) == 0 &&\n\t\t\t\t(typebuf[k] | typebuf[pos]) != typebuf[pos])\n\t\t\treturn 0;\n\t\tif (inputChar->attributes != CTC_Letter) {\n\t\t\tif (k != (pos + 1) && (prevAttr & CTC_Letter) &&\n\t\t\t\t\t(inputChar->attributes & CTC_Letter) &&\n\t\t\t\t\t((inputChar->attributes &\n\t\t\t\t\t\t\t (CTC_LowerCase | CTC_UpperCase | CTC_Letter)) !=\n\t\t\t\t\t\t\t(prevAttr & (CTC_LowerCase | CTC_UpperCase | CTC_Letter))))\n\t\t\t\treturn 0;\n\t\t}\n\t\tprevAttr = inputChar->attributes;\n\t}\n\treturn 1;\n}\n\nstatic int\ninsertBrailleIndicators(int finish, const TranslationTableHeader *table, int pos,\n\t\tconst InString *input, OutString *output, int *posMapping, formtype *typebuf,\n\t\tint haveEmphasis, int transOpcode, int prevTransOpcode, int *cursorPosition,\n\t\tint *cursorStatus, TranslationTableCharacterAttributes beforeAttributes,\n\t\tint *prevType, int *curType, int *prevTypeform, int prevPos) {\n\t/* Insert braille indicators such as letter, number, etc. */\n\ttypedef enum {\n\t\tcheckNothing,\n\t\tcheckBeginTypeform,\n\t\tcheckEndTypeform,\n\t\tcheckNumber,\n\t\tcheckLetter\n\t} checkThis;\n\tcheckThis checkWhat = checkNothing;\n\tint ok = 0;\n\tint k;\n\t{\n\t\tif (pos == prevPos && !finish) return 1;\n\t\tif (pos != prevPos) {\n\t\t\tif (haveEmphasis && (typebuf[pos] & EMPHASIS) != *prevTypeform) {\n\t\t\t\t*prevType = *prevTypeform & EMPHASIS;\n\t\t\t\t*curType = typebuf[pos] & EMPHASIS;\n\t\t\t\tcheckWhat = checkEndTypeform;\n\t\t\t} else if (!finish)\n\t\t\t\tcheckWhat = checkNothing;\n\t\t\telse\n\t\t\t\tcheckWhat = checkNumber;\n\t\t}\n\t\tif (finish == 1) checkWhat = checkNumber;\n\t}\n\tdo {\n\t\tconst TranslationTableRule *indicRule;\n\t\tok = 0;\n\t\tswitch (checkWhat) {\n\t\tcase checkNothing:\n\t\t\tok = 0;\n\t\t\tbreak;\n\t\tcase checkBeginTypeform:\n\t\t\tif (haveEmphasis) {\n\t\t\t\tok = 0;\n\t\t\t\t*curType = 0;\n\t\t\t}\n\t\t\tif (*curType == plain_text) {\n\t\t\t\tif (!finish)\n\t\t\t\t\tcheckWhat = checkNothing;\n\t\t\t\telse\n\t\t\t\t\tcheckWhat = checkNumber;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase checkEndTypeform:\n\t\t\tif (haveEmphasis) {\n\t\t\t\tok = 0;\n\t\t\t\t*prevType = plain_text;\n\t\t\t}\n\t\t\tif (*prevType == plain_text) {\n\t\t\t\tcheckWhat = checkBeginTypeform;\n\t\t\t\t*prevTypeform = typebuf[pos] & EMPHASIS;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase checkNumber:\n\t\t\tif (brailleIndicatorDefined(table->numberSign, table, &indicRule) &&\n\t\t\t\t\tcheckAttr_safe(input, pos, CTC_Digit, 0, table) &&\n\t\t\t\t\t(prevTransOpcode == CTO_ExactDots ||\n\t\t\t\t\t\t\t!(beforeAttributes & CTC_Digit)) &&\n\t\t\t\t\tprevTransOpcode != CTO_MidNum) {\n\t\t\t\tok = !table->usesNumericMode;\n\t\t\t\tcheckWhat = checkNothing;\n\t\t\t} else\n\t\t\t\tcheckWhat = checkLetter;\n\t\t\tbreak;\n\t\tcase checkLetter:\n\t\t\tif (!brailleIndicatorDefined(table->letterSign, table, &indicRule)) {\n\t\t\t\tok = 0;\n\t\t\t\tcheckWhat = checkNothing;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (transOpcode == CTO_Contraction) {\n\t\t\t\tok = 1;\n\t\t\t\tcheckWhat = checkNothing;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((checkAttr_safe(input, pos, CTC_Letter, 0, table) &&\n\t\t\t\t\t\t!(beforeAttributes & CTC_Letter)) &&\n\t\t\t\t\t(!checkAttr_safe(input, pos + 1, CTC_Letter, 0, table) ||\n\t\t\t\t\t\t\t(beforeAttributes & CTC_Digit))) {\n\t\t\t\tok = 1;\n\t\t\t\tif (pos > 0)\n\t\t\t\t\tfor (k = 0; k < table->noLetsignBeforeCount; k++)\n\t\t\t\t\t\tif (input->chars[pos - 1] == table->noLetsignBefore[k]) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\tfor (k = 0; k < table->noLetsignCount; k++)\n\t\t\t\t\tif (input->chars[pos] == table->noLetsign[k]) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tif (pos + 1 < input->length)\n\t\t\t\t\tfor (k = 0; k < table->noLetsignAfterCount; k++)\n\t\t\t\t\t\tif (input->chars[pos + 1] == table->noLetsignAfter[k]) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t}\n\t\t\tcheckWhat = checkNothing;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tok = 0;\n\t\t\tcheckWhat = checkNothing;\n\t\t\tbreak;\n\t\t}\n\t\tif (ok && indicRule != NULL) {\n\t\t\tif (!for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0,\n\t\t\t\t\t\tpos, input, output, posMapping, cursorPosition, cursorStatus))\n\t\t\t\treturn 0;\n\t\t}\n\t} while (checkWhat != checkNothing);\n\treturn 1;\n}\n\nstatic int\nonlyLettersBehind(const TranslationTableHeader *table, int pos, const InString *input,\n\t\tTranslationTableCharacterAttributes beforeAttributes) {\n\t/* Actually, spaces, then letters */\n\tint k;\n\tif (!(beforeAttributes & CTC_Space)) return 0;\n\tfor (k = pos - 2; k >= 0; k--) {\n\t\tTranslationTableCharacterAttributes attr =\n\t\t\t\t(findCharOrDots(input->chars[k], 0, table))->attributes;\n\t\tif ((attr & CTC_Space)) continue;\n\t\tif ((attr & CTC_Letter))\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int\nonlyLettersAhead(const TranslationTableHeader *table, int pos, const InString *input,\n\t\tint transCharslen, TranslationTableCharacterAttributes afterAttributes) {\n\t/* Actullly, spaces, then letters */\n\tint k;\n\tif (!(afterAttributes & CTC_Space)) return 0;\n\tfor (k = pos + transCharslen + 1; k < input->length; k++) {\n\t\tTranslationTableCharacterAttributes attr =\n\t\t\t\t(findCharOrDots(input->chars[k], 0, table))->attributes;\n\t\tif ((attr & CTC_Space)) continue;\n\t\tif ((attr & (CTC_Letter | CTC_LitDigit)))\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstatic int\nnoCompbrlAhead(const TranslationTableHeader *table, int pos, int mode,\n\t\tconst InString *input, int transOpcode, int transCharslen, int cursorPosition) {\n\tint start = pos + transCharslen;\n\tint end;\n\tint p;\n\tif (start >= input->length) return 1;\n\twhile (start < input->length && checkAttr(input->chars[start], CTC_Space, 0, table))\n\t\tstart++;\n\tif (start == input->length ||\n\t\t\t(transOpcode == CTO_JoinableWord &&\n\t\t\t\t\t(!checkAttr(input->chars[start], CTC_Letter | CTC_Digit, 0, table) ||\n\t\t\t\t\t\t\t!checkAttr(input->chars[start - 1], CTC_Space, 0, table))))\n\t\treturn 1;\n\tend = start;\n\twhile (end < input->length && !checkAttr(input->chars[end], CTC_Space, 0, table))\n\t\tend++;\n\tif ((mode & (compbrlAtCursor | compbrlLeftCursor)) && cursorPosition >= start &&\n\t\t\tcursorPosition < end)\n\t\treturn 0;\n\t/* Look ahead for rules with CTO_CompBrl */\n\tfor (p = start; p < end; p++) {\n\t\tint length = input->length - p;\n\t\tint tryThis;\n\t\tconst TranslationTableCharacter *character1;\n\t\tconst TranslationTableCharacter *character2;\n\t\tint k;\n\t\tcharacter1 = findCharOrDots(input->chars[p], 0, table);\n\t\tfor (tryThis = 0; tryThis < 2; tryThis++) {\n\t\t\tTranslationTableOffset ruleOffset = 0;\n\t\t\tTranslationTableRule *testRule;\n\t\t\tunsigned long int makeHash = 0;\n\t\t\tswitch (tryThis) {\n\t\t\tcase 0:\n\t\t\t\tif (!(length >= 2)) break;\n\t\t\t\t/* Hash function optimized for forward translation */\n\t\t\t\tmakeHash = (unsigned long int)character1->lowercase << 8;\n\t\t\t\tcharacter2 = findCharOrDots(input->chars[p + 1], 0, table);\n\t\t\t\tmakeHash += (unsigned long int)character2->lowercase;\n\t\t\t\tmakeHash %= HASHNUM;\n\t\t\t\truleOffset = table->forRules[makeHash];\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif (!(length >= 1)) break;\n\t\t\t\tlength = 1;\n\t\t\t\truleOffset = character1->otherRules;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (ruleOffset) {\n\t\t\t\ttestRule = (TranslationTableRule *)&table->ruleArea[ruleOffset];\n\t\t\t\tfor (k = 0; k < testRule->charslen; k++) {\n\t\t\t\t\tcharacter1 = findCharOrDots(testRule->charsdots[k], 0, table);\n\t\t\t\t\tcharacter2 = findCharOrDots(input->chars[p + k], 0, table);\n\t\t\t\t\tif (character1->lowercase != character2->lowercase) break;\n\t\t\t\t}\n\t\t\t\tif (tryThis == 1 || k == testRule->charslen) {\n\t\t\t\t\tif (testRule->opcode == CTO_CompBrl ||\n\t\t\t\t\t\t\ttestRule->opcode == CTO_Literal)\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\truleOffset = testRule->charsnext;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int\nisRepeatedWord(const TranslationTableHeader *table, int pos, const InString *input,\n\t\tint transCharslen, const widechar **repwordStart, int *repwordLength) {\n\tint start;\n\tif (pos == 0 || !checkAttr(input->chars[pos - 1], CTC_Letter, 0, table)) return 0;\n\tif ((pos + transCharslen) >= input->length ||\n\t\t\t!checkAttr(input->chars[pos + transCharslen], CTC_Letter, 0, table))\n\t\treturn 0;\n\tfor (start = pos - 2;\n\t\t\tstart >= 0 && checkAttr(input->chars[start], CTC_Letter, 0, table); start--)\n\t\t;\n\tstart++;\n\t*repwordStart = &input->chars[start];\n\t*repwordLength = pos - start;\n\tif (compareChars(*repwordStart, &input->chars[pos + transCharslen], *repwordLength, 0,\n\t\t\t\ttable))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int\ncheckEmphasisChange(const int skip, int pos, EmphasisInfo *emphasisBuffer,\n\t\tconst TranslationTableRule *transRule) {\n\tint i;\n\tfor (i = pos + (skip + 1); i < pos + transRule->charslen; i++)\n\t\tif (emphasisBuffer[i].begin || emphasisBuffer[i].end || emphasisBuffer[i].word ||\n\t\t\t\temphasisBuffer[i].symbol)\n\t\t\treturn 1;\n\treturn 0;\n}\n\nstatic int\ninSequence(const TranslationTableHeader *table, int pos, const InString *input,\n\t\tconst TranslationTableRule *transRule) {\n\tint i, j, s, match;\n\t// TODO: all caps words\n\t// const TranslationTableCharacter *c = NULL;\n\n\t/* check before sequence */\n\tfor (i = pos - 1; i >= 0; i--) {\n\t\tif (checkAttr(input->chars[i], CTC_SeqBefore, 0, table)) continue;\n\t\tif (!(checkAttr(input->chars[i], CTC_Space | CTC_SeqDelimiter, 0, table)))\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\n\t/* check after sequence */\n\tfor (i = pos + transRule->charslen; i < input->length; i++) {\n\t\t/* check sequence after patterns */\n\t\tif (table->seqPatternsCount) {\n\t\t\tmatch = 0;\n\t\t\tfor (j = i, s = 0; j <= input->length && s < table->seqPatternsCount;\n\t\t\t\t\tj++, s++) {\n\t\t\t\t/* matching */\n\t\t\t\tif (match == 1) {\n\t\t\t\t\tif (table->seqPatterns[s]) {\n\t\t\t\t\t\tif (input->chars[j] == table->seqPatterns[s])\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tmatch = -1;\n\t\t\t\t\t\t\tj = i - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* found match */\n\t\t\t\t\telse {\n\t\t\t\t\t\t/* pattern at end of input */\n\t\t\t\t\t\tif (j >= input->length) return 1;\n\n\t\t\t\t\t\ti = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* looking for match */\n\t\t\t\telse if (match == 0) {\n\t\t\t\t\tif (table->seqPatterns[s]) {\n\t\t\t\t\t\tif (input->chars[j] == table->seqPatterns[s])\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tmatch = -1;\n\t\t\t\t\t\t\tj = i - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* next pattarn */\n\t\t\t\telse if (match == -1) {\n\t\t\t\t\tif (!table->seqPatterns[s]) {\n\t\t\t\t\t\tmatch = 0;\n\t\t\t\t\t\tj = i - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (checkAttr(input->chars[i], CTC_SeqAfter, 0, table)) continue;\n\t\tif (!(checkAttr(input->chars[i], CTC_Space | CTC_SeqDelimiter, 0, table)))\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\n\treturn 1;\n}\n\nstatic void\nfor_selectRule(const TranslationTableHeader *table, int pos, OutString output, int mode,\n\t\tconst InString *input, formtype *typebuf, EmphasisInfo *emphasisBuffer,\n\t\tint *transOpcode, int prevTransOpcode, const TranslationTableRule **transRule,\n\t\tint *transCharslen, int *passCharDots, widechar const **passInstructions,\n\t\tint *passIC, PassRuleMatch *patternMatch, int posIncremented, int cursorPosition,\n\t\tconst widechar **repwordStart, int *repwordLength, int dontContract,\n\t\tint compbrlStart, int compbrlEnd,\n\t\tTranslationTableCharacterAttributes beforeAttributes,\n\t\tTranslationTableCharacter **curCharDef, TranslationTableRule **groupingRule,\n\t\twidechar *groupingOp) {\n\t/* check for valid Translations. Return value is in transRule. */\n\tstatic TranslationTableRule pseudoRule = { 0 };\n\tint length = ((pos < compbrlStart) ? compbrlStart : input->length) - pos;\n\tint tryThis;\n\tconst TranslationTableCharacter *character2;\n\tint k;\n\tTranslationTableOffset ruleOffset = 0;\n\t*curCharDef = findCharOrDots(input->chars[pos], 0, table);\n\tfor (tryThis = 0; tryThis < 3; tryThis++) {\n\t\tunsigned long int makeHash = 0;\n\t\tswitch (tryThis) {\n\t\tcase 0:\n\t\t\tif (!(length >= 2)) break;\n\t\t\t/* Hash function optimized for forward translation */\n\t\t\tmakeHash = (unsigned long int)(*curCharDef)->lowercase << 8;\n\t\t\tcharacter2 = findCharOrDots(input->chars[pos + 1], 0, table);\n\t\t\tmakeHash += (unsigned long int)character2->lowercase;\n\t\t\tmakeHash %= HASHNUM;\n\t\t\truleOffset = table->forRules[makeHash];\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (!(length >= 1)) break;\n\t\t\tlength = 1;\n\t\t\truleOffset = (*curCharDef)->otherRules;\n\t\t\tbreak;\n\t\tcase 2: /* No rule found */\n\t\t\t*transRule = &pseudoRule;\n\t\t\t*transOpcode = pseudoRule.opcode = CTO_None;\n\t\t\t*transCharslen = pseudoRule.charslen = 1;\n\t\t\tpseudoRule.charsdots[0] = input->chars[pos];\n\t\t\tpseudoRule.dotslen = 0;\n\t\t\treturn;\n\t\t\tbreak;\n\t\t}\n\t\twhile (ruleOffset) {\n\t\t\t*transRule = (TranslationTableRule *)&table->ruleArea[ruleOffset];\n\t\t\t*transOpcode = (*transRule)->opcode;\n\t\t\t*transCharslen = (*transRule)->charslen;\n\t\t\tif (tryThis == 1 ||\n\t\t\t\t\t((*transCharslen <= length) && validMatch(table, pos, input, typebuf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   *transRule, *transCharslen))) {\n\t\t\t\tTranslationTableCharacterAttributes afterAttributes;\n\t\t\t\t/* check before emphasis match */\n\t\t\t\tif ((*transRule)->before & CTC_EmpMatch) {\n\t\t\t\t\tif (emphasisBuffer[pos].begin || emphasisBuffer[pos].end ||\n\t\t\t\t\t\t\temphasisBuffer[pos].word || emphasisBuffer[pos].symbol)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* check after emphasis match */\n\t\t\t\tif ((*transRule)->after & CTC_EmpMatch) {\n\t\t\t\t\tif (emphasisBuffer[pos + *transCharslen].begin ||\n\t\t\t\t\t\t\temphasisBuffer[pos + *transCharslen].end ||\n\t\t\t\t\t\t\temphasisBuffer[pos + *transCharslen].word ||\n\t\t\t\t\t\t\temphasisBuffer[pos + *transCharslen].symbol)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* check this rule */\n\t\t\t\tsetAfter(*transCharslen, table, pos, input, &afterAttributes);\n\t\t\t\tif ((!((*transRule)->after & ~CTC_EmpMatch) ||\n\t\t\t\t\t\t\t(beforeAttributes & (*transRule)->after)) &&\n\t\t\t\t\t\t(!((*transRule)->before & ~CTC_EmpMatch) ||\n\t\t\t\t\t\t\t\t(afterAttributes & (*transRule)->before)))\n\t\t\t\t\tswitch (*transOpcode) { /* check validity of this Translation */\n\t\t\t\t\tcase CTO_Space:\n\t\t\t\t\tcase CTO_Letter:\n\t\t\t\t\tcase CTO_UpperCase:\n\t\t\t\t\tcase CTO_LowerCase:\n\t\t\t\t\tcase CTO_Digit:\n\t\t\t\t\tcase CTO_LitDigit:\n\t\t\t\t\tcase CTO_Punctuation:\n\t\t\t\t\tcase CTO_Math:\n\t\t\t\t\tcase CTO_Sign:\n\t\t\t\t\tcase CTO_Hyphen:\n\t\t\t\t\tcase CTO_Replace:\n\t\t\t\t\tcase CTO_CompBrl:\n\t\t\t\t\tcase CTO_Literal:\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase CTO_Repeated:\n\t\t\t\t\t\tif ((mode & (compbrlAtCursor | compbrlLeftCursor)) &&\n\t\t\t\t\t\t\t\tpos >= compbrlStart && pos <= compbrlEnd)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase CTO_RepWord:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif (isRepeatedWord(table, pos, input, *transCharslen,\n\t\t\t\t\t\t\t\t\trepwordStart, repwordLength))\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_NoCont:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase CTO_Syllable:\n\t\t\t\t\t\t*transOpcode = CTO_Always;\n\t\t\t\t\tcase CTO_Always:\n\t\t\t\t\t\tif (checkEmphasisChange(0, pos, emphasisBuffer, *transRule))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase CTO_ExactDots:\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase CTO_NoCross:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif (syllableBreak(table, pos, input, *transCharslen)) break;\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase CTO_Context:\n\t\t\t\t\t\tif (!posIncremented ||\n\t\t\t\t\t\t\t\t!passDoTest(table, pos, input, *transOpcode, *transRule,\n\t\t\t\t\t\t\t\t\t\tpassCharDots, passInstructions, passIC,\n\t\t\t\t\t\t\t\t\t\tpatternMatch, groupingRule, groupingOp))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase CTO_LargeSign:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif (!((beforeAttributes & (CTC_Space | CTC_Punctuation)) ||\n\t\t\t\t\t\t\t\t\tonlyLettersBehind(\n\t\t\t\t\t\t\t\t\t\t\ttable, pos, input, beforeAttributes)) ||\n\t\t\t\t\t\t\t\t!((afterAttributes & CTC_Space) ||\n\t\t\t\t\t\t\t\t\t\tprevTransOpcode == CTO_LargeSign) ||\n\t\t\t\t\t\t\t\t(afterAttributes & CTC_Letter) ||\n\t\t\t\t\t\t\t\t!noCompbrlAhead(table, pos, mode, input, *transOpcode,\n\t\t\t\t\t\t\t\t\t\t*transCharslen, cursorPosition))\n\t\t\t\t\t\t\t*transOpcode = CTO_Always;\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase CTO_WholeWord:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif (checkEmphasisChange(0, pos, emphasisBuffer, *transRule))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_Contraction:\n\t\t\t\t\t\tif (table->usesSequences) {\n\t\t\t\t\t\t\tif (inSequence(table, pos, input, *transRule)) return;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ((beforeAttributes & (CTC_Space | CTC_Punctuation)) &&\n\t\t\t\t\t\t\t\t\t(afterAttributes & (CTC_Space | CTC_Punctuation)))\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_PartWord:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif ((beforeAttributes & CTC_Letter) ||\n\t\t\t\t\t\t\t\t(afterAttributes & CTC_Letter))\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_JoinNum:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif ((beforeAttributes & (CTC_Space | CTC_Punctuation)) &&\n\t\t\t\t\t\t\t\t(afterAttributes & CTC_Space) &&\n\t\t\t\t\t\t\t\t(output.length + (*transRule)->dotslen <\n\t\t\t\t\t\t\t\t\t\toutput.maxlength)) {\n\t\t\t\t\t\t\tint p = pos + *transCharslen + 1;\n\t\t\t\t\t\t\twhile (p < input->length) {\n\t\t\t\t\t\t\t\tif (!checkAttr(input->chars[p], CTC_Space, 0, table)) {\n\t\t\t\t\t\t\t\t\tif (checkAttr(input->chars[p], CTC_Digit, 0, table))\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_LowWord:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif ((beforeAttributes & CTC_Space) &&\n\t\t\t\t\t\t\t\t(afterAttributes & CTC_Space) &&\n\t\t\t\t\t\t\t\t(prevTransOpcode != CTO_JoinableWord))\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_JoinableWord:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif (beforeAttributes & (CTC_Space | CTC_Punctuation) &&\n\t\t\t\t\t\t\t\tonlyLettersAhead(table, pos, input, *transCharslen,\n\t\t\t\t\t\t\t\t\t\tafterAttributes) &&\n\t\t\t\t\t\t\t\tnoCompbrlAhead(table, pos, mode, input, *transOpcode,\n\t\t\t\t\t\t\t\t\t\t*transCharslen, cursorPosition))\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_SuffixableWord:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif ((beforeAttributes & (CTC_Space | CTC_Punctuation)) &&\n\t\t\t\t\t\t\t\t(afterAttributes &\n\t\t\t\t\t\t\t\t\t\t(CTC_Space | CTC_Letter | CTC_Punctuation)))\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_PrefixableWord:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif ((beforeAttributes &\n\t\t\t\t\t\t\t\t\t(CTC_Space | CTC_Letter | CTC_Punctuation)) &&\n\t\t\t\t\t\t\t\t(afterAttributes & (CTC_Space | CTC_Punctuation)))\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_BegWord:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif ((beforeAttributes & (CTC_Space | CTC_Punctuation)) &&\n\t\t\t\t\t\t\t\t(afterAttributes & CTC_Letter))\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_BegMidWord:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif ((beforeAttributes &\n\t\t\t\t\t\t\t\t\t(CTC_Letter | CTC_Space | CTC_Punctuation)) &&\n\t\t\t\t\t\t\t\t(afterAttributes & CTC_Letter))\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_MidWord:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif (beforeAttributes & CTC_Letter && afterAttributes & CTC_Letter)\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_MidEndWord:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif (beforeAttributes & CTC_Letter &&\n\t\t\t\t\t\t\t\tafterAttributes &\n\t\t\t\t\t\t\t\t\t\t(CTC_Letter | CTC_Space | CTC_Punctuation))\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_EndWord:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif (beforeAttributes & CTC_Letter &&\n\t\t\t\t\t\t\t\tafterAttributes & (CTC_Space | CTC_Punctuation))\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_BegNum:\n\t\t\t\t\t\tif (beforeAttributes & (CTC_Space | CTC_Punctuation) &&\n\t\t\t\t\t\t\t\tafterAttributes & CTC_Digit)\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_MidNum:\n\t\t\t\t\t\tif (prevTransOpcode != CTO_ExactDots &&\n\t\t\t\t\t\t\t\tbeforeAttributes & CTC_Digit &&\n\t\t\t\t\t\t\t\tafterAttributes & CTC_Digit)\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_EndNum:\n\t\t\t\t\t\tif (beforeAttributes & CTC_Digit &&\n\t\t\t\t\t\t\t\tprevTransOpcode != CTO_ExactDots)\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_DecPoint:\n\t\t\t\t\t\tif (!(afterAttributes & CTC_Digit)) break;\n\t\t\t\t\t\tif (beforeAttributes & CTC_Digit) *transOpcode = CTO_MidNum;\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase CTO_PrePunc:\n\t\t\t\t\t\tif (!checkAttr(input->chars[pos], CTC_Punctuation, 0, table) ||\n\t\t\t\t\t\t\t\t(pos > 0 && checkAttr(input->chars[pos - 1], CTC_Letter,\n\t\t\t\t\t\t\t\t\t\t\t\t\t0, table)))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tfor (k = pos + *transCharslen; k < input->length; k++) {\n\t\t\t\t\t\t\tif (checkAttr(input->chars[k], (CTC_Letter | CTC_Digit), 0,\n\t\t\t\t\t\t\t\t\t\ttable))\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\tif (checkAttr(input->chars[k], CTC_Space, 0, table)) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_PostPunc:\n\t\t\t\t\t\tif (!checkAttr(input->chars[pos], CTC_Punctuation, 0, table) ||\n\t\t\t\t\t\t\t\t(pos < (input->length - 1) &&\n\t\t\t\t\t\t\t\t\t\tcheckAttr(input->chars[pos + 1], CTC_Letter, 0,\n\t\t\t\t\t\t\t\t\t\t\t\ttable)))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tfor (k = pos; k >= 0; k--) {\n\t\t\t\t\t\t\tif (checkAttr(input->chars[k], (CTC_Letter | CTC_Digit), 0,\n\t\t\t\t\t\t\t\t\t\ttable))\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\tif (checkAttr(input->chars[k], CTC_Space, 0, table)) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CTO_Match: {\n\t\t\t\t\t\twidechar *patterns, *pattern;\n\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif (checkEmphasisChange(0, pos, emphasisBuffer, *transRule))\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tpatterns = (widechar *)&table->ruleArea[(*transRule)->patterns];\n\n\t\t\t\t\t\t/* check before pattern */\n\t\t\t\t\t\tpattern = &patterns[1];\n\t\t\t\t\t\tif (!_lou_pattern_check(\n\t\t\t\t\t\t\t\t\tinput->chars, pos - 1, -1, -1, pattern, table))\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t/* check after pattern */\n\t\t\t\t\t\tpattern = &patterns[patterns[0]];\n\t\t\t\t\t\tif (!_lou_pattern_check(input->chars,\n\t\t\t\t\t\t\t\t\tpos + (*transRule)->charslen, input->length, 1,\n\t\t\t\t\t\t\t\t\tpattern, table))\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\t/* Done with checking this rule */\n\t\t\truleOffset = (*transRule)->charsnext;\n\t\t}\n\t}\n}\n\nstatic int\nundefinedCharacter(widechar c, const TranslationTableHeader *table, int pos,\n\t\tconst InString *input, OutString *output, int *posMapping, int *cursorPosition,\n\t\tint *cursorStatus) {\n\t/* Display an undefined character in the output buffer */\n\tint k;\n\tchar *display;\n\twidechar displayDots[20];\n\tif (table->undefined) {\n\t\tTranslationTableRule *rule =\n\t\t\t\t(TranslationTableRule *)&table->ruleArea[table->undefined];\n\t\tif (!for_updatePositions(&rule->charsdots[rule->charslen], rule->charslen,\n\t\t\t\t\trule->dotslen, 0, pos, input, output, posMapping, cursorPosition,\n\t\t\t\t\tcursorStatus))\n\t\t\treturn 0;\n\t\treturn 1;\n\t}\n\tdisplay = _lou_showString(&c, 1);\n\tfor (k = 0; k < (int)strlen(display); k++)\n\t\tdisplayDots[k] = _lou_getDotsForChar(display[k]);\n\tif (!for_updatePositions(displayDots, 1, (int)strlen(display), 0, pos, input, output,\n\t\t\t\tposMapping, cursorPosition, cursorStatus))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int\nputCharacter(widechar character, const TranslationTableHeader *table, int pos,\n\t\tconst InString *input, OutString *output, int *posMapping, int *cursorPosition,\n\t\tint *cursorStatus) {\n\t/* Insert the dots equivalent of a character into the output buffer */\n\tconst TranslationTableRule *rule = NULL;\n\tTranslationTableCharacter *chardef = NULL;\n\tTranslationTableOffset offset;\n\twidechar d;\n\tchardef = (findCharOrDots(character, 0, table));\n\tif ((chardef->attributes & CTC_Letter) && (chardef->attributes & CTC_UpperCase))\n\t\tchardef = findCharOrDots(chardef->lowercase, 0, table);\n\t// TODO: for_selectRule and this function screw up Digit and LitDigit\n\t// NOTE: removed Litdigit from tables.\n\t// if(!chardef->otherRules)\n\toffset = chardef->definitionRule;\n\t// else\n\t//{\n\t//\toffset = chardef->otherRules;\n\t//\trule = (TranslationTableRule *)&table->ruleArea[offset];\n\t//\twhile(rule->charsnext && rule->charsnext != chardef->definitionRule)\n\t//\t{\n\t//\t\trule = (TranslationTableRule *)&table->ruleArea[offset];\n\t//\t\tif(rule->charsnext)\n\t//\t\t\toffset = rule->charsnext;\n\t//\t}\n\t//}\n\tif (offset) {\n\t\trule = (TranslationTableRule *)&table->ruleArea[offset];\n\t\tif (rule->dotslen)\n\t\t\treturn for_updatePositions(&rule->charsdots[1], 1, rule->dotslen, 0, pos,\n\t\t\t\t\tinput, output, posMapping, cursorPosition, cursorStatus);\n\t\td = _lou_getDotsForChar(character);\n\t\treturn for_updatePositions(&d, 1, 1, 0, pos, input, output, posMapping,\n\t\t\t\tcursorPosition, cursorStatus);\n\t}\n\treturn undefinedCharacter(character, table, pos, input, output, posMapping,\n\t\t\tcursorPosition, cursorStatus);\n}\n\nstatic int\nputCharacters(const widechar *characters, int count, const TranslationTableHeader *table,\n\t\tint pos, const InString *input, OutString *output, int *posMapping,\n\t\tint *cursorPosition, int *cursorStatus) {\n\t/* Insert the dot equivalents of a series of characters in the output\n\t * buffer */\n\tint k;\n\tfor (k = 0; k < count; k++)\n\t\tif (!putCharacter(characters[k], table, pos, input, output, posMapping,\n\t\t\t\t\tcursorPosition, cursorStatus))\n\t\t\treturn 0;\n\treturn 1;\n}\n\nstatic int\ndoCompbrl(const TranslationTableHeader *table, int *pos, const InString *input,\n\t\tOutString *output, int *posMapping, EmphasisInfo *emphasisBuffer,\n\t\tconst TranslationTableRule **transRule, int *cursorPosition, int *cursorStatus,\n\t\tint destword, int srcword) {\n\t/* Handle strings containing substrings defined by the compbrl opcode */\n\tint stringStart, stringEnd;\n\tif (checkAttr(input->chars[*pos], CTC_Space, 0, table)) return 1;\n\tif (destword) {\n\t\t*pos = srcword;\n\t\toutput->length = destword;\n\t} else {\n\t\t*pos = 0;\n\t\toutput->length = 0;\n\t}\n\tfor (stringStart = *pos; stringStart >= 0; stringStart--)\n\t\tif (checkAttr(input->chars[stringStart], CTC_Space, 0, table)) break;\n\tstringStart++;\n\tfor (stringEnd = *pos; stringEnd < input->length; stringEnd++)\n\t\tif (checkAttr(input->chars[stringEnd], CTC_Space, 0, table)) break;\n\treturn doCompTrans(stringStart, stringEnd, table, pos, input, output, posMapping,\n\t\t\temphasisBuffer, transRule, cursorPosition, cursorStatus);\n}\n\nstatic int\nputCompChar(widechar character, const TranslationTableHeader *table, int pos,\n\t\tconst InString *input, OutString *output, int *posMapping, int *cursorPosition,\n\t\tint *cursorStatus) {\n\t/* Insert the dots equivalent of a character into the output buffer */\n\twidechar d;\n\tTranslationTableOffset offset = (findCharOrDots(character, 0, table))->definitionRule;\n\tif (offset) {\n\t\tconst TranslationTableRule *rule =\n\t\t\t\t(TranslationTableRule *)&table->ruleArea[offset];\n\t\tif (rule->dotslen)\n\t\t\treturn for_updatePositions(&rule->charsdots[1], 1, rule->dotslen, 0, pos,\n\t\t\t\t\tinput, output, posMapping, cursorPosition, cursorStatus);\n\t\td = _lou_getDotsForChar(character);\n\t\treturn for_updatePositions(&d, 1, 1, 0, pos, input, output, posMapping,\n\t\t\t\tcursorPosition, cursorStatus);\n\t}\n\treturn undefinedCharacter(character, table, pos, input, output, posMapping,\n\t\t\tcursorPosition, cursorStatus);\n}\n\nstatic int\ndoCompTrans(int start, int end, const TranslationTableHeader *table, int *pos,\n\t\tconst InString *input, OutString *output, int *posMapping,\n\t\tEmphasisInfo *emphasisBuffer, const TranslationTableRule **transRule,\n\t\tint *cursorPosition, int *cursorStatus) {\n\tconst TranslationTableRule *indicRule;\n\tint k;\n\tint haveEndsegment = 0;\n\tif (*cursorStatus != 2 && brailleIndicatorDefined(table->begComp, table, &indicRule))\n\t\tif (!for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0, *pos,\n\t\t\t\t\tinput, output, posMapping, cursorPosition, cursorStatus))\n\t\t\treturn 0;\n\tfor (k = start; k < end; k++) {\n\t\tTranslationTableOffset compdots = 0;\n\t\t/* HACK: computer braille is one-to-one so it\n\t\t * can't have any emphasis indicators.\n\t\t * A better solution is to treat computer braille as its own mode. */\n\t\temphasisBuffer[k] = (EmphasisInfo){ 0 };\n\t\tif (input->chars[k] == ENDSEGMENT) {\n\t\t\thaveEndsegment = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t*pos = k;\n\t\tif (input->chars[k] < 256) compdots = table->compdotsPattern[input->chars[k]];\n\t\tif (compdots != 0) {\n\t\t\t*transRule = (TranslationTableRule *)&table->ruleArea[compdots];\n\t\t\tif (!for_updatePositions(&(*transRule)->charsdots[(*transRule)->charslen],\n\t\t\t\t\t\t(*transRule)->charslen, (*transRule)->dotslen, 0, *pos, input,\n\t\t\t\t\t\toutput, posMapping, cursorPosition, cursorStatus))\n\t\t\t\treturn 0;\n\t\t} else if (!putCompChar(input->chars[k], table, *pos, input, output, posMapping,\n\t\t\t\t\t\t   cursorPosition, cursorStatus))\n\t\t\treturn 0;\n\t}\n\tif (*cursorStatus != 2 && brailleIndicatorDefined(table->endComp, table, &indicRule))\n\t\tif (!for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0, *pos,\n\t\t\t\t\tinput, output, posMapping, cursorPosition, cursorStatus))\n\t\t\treturn 0;\n\t*pos = end;\n\tif (haveEndsegment) {\n\t\twidechar endSegment = ENDSEGMENT;\n\t\tif (!for_updatePositions(&endSegment, 0, 1, 0, *pos, input, output, posMapping,\n\t\t\t\t\tcursorPosition, cursorStatus))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int\ndoNocont(const TranslationTableHeader *table, int *pos, OutString *output, int mode,\n\t\tconst InString *input, int destword, int srcword, int *dontContract) {\n\t/* Handle strings containing substrings defined by the nocont opcode */\n\tif (checkAttr(input->chars[*pos], CTC_Space, 0, table) || *dontContract ||\n\t\t\t(mode & noContractions))\n\t\treturn 1;\n\tif (destword) {\n\t\t*pos = srcword;\n\t\toutput->length = destword;\n\t} else {\n\t\t*pos = 0;\n\t\toutput->length = 0;\n\t}\n\t*dontContract = 1;\n\treturn 1;\n}\n\nstatic int\nmarkSyllables(const TranslationTableHeader *table, const InString *input,\n\t\tformtype *typebuf, int *transOpcode, const TranslationTableRule **transRule,\n\t\tint *transCharslen) {\n\tint pos;\n\tint k;\n\tint currentMark = 0;\n\tint const syllable_marks[] = { SYLLABLE_MARKER_1, SYLLABLE_MARKER_2 };\n\tint syllable_mark_selector = 0;\n\n\tif (typebuf == NULL || !table->syllables) return 1;\n\tpos = 0;\n\twhile (pos < input->length) { /* the main multipass translation loop */\n\t\tint length = input->length - pos;\n\t\tconst TranslationTableCharacter *character =\n\t\t\t\tfindCharOrDots(input->chars[pos], 0, table);\n\t\tconst TranslationTableCharacter *character2;\n\t\tint tryThis = 0;\n\t\twhile (tryThis < 3) {\n\t\t\tTranslationTableOffset ruleOffset = 0;\n\t\t\tunsigned long int makeHash = 0;\n\t\t\tswitch (tryThis) {\n\t\t\tcase 0:\n\t\t\t\tif (!(length >= 2)) break;\n\t\t\t\tmakeHash = (unsigned long int)character->lowercase << 8;\n\t\t\t\t// memory overflow when pos == input->length - 1\n\t\t\t\tcharacter2 = findCharOrDots(input->chars[pos + 1], 0, table);\n\t\t\t\tmakeHash += (unsigned long int)character2->lowercase;\n\t\t\t\tmakeHash %= HASHNUM;\n\t\t\t\truleOffset = table->forRules[makeHash];\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif (!(length >= 1)) break;\n\t\t\t\tlength = 1;\n\t\t\t\truleOffset = character->otherRules;\n\t\t\t\tbreak;\n\t\t\tcase 2: /* No rule found */\n\t\t\t\t*transOpcode = CTO_Always;\n\t\t\t\truleOffset = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (ruleOffset) {\n\t\t\t\t*transRule = (TranslationTableRule *)&table->ruleArea[ruleOffset];\n\t\t\t\t*transOpcode = (*transRule)->opcode;\n\t\t\t\t*transCharslen = (*transRule)->charslen;\n\t\t\t\tif (tryThis == 1 ||\n\t\t\t\t\t\t(*transCharslen <= length &&\n\t\t\t\t\t\t\t\tcompareChars(&(*transRule)->charsdots[0],\n\t\t\t\t\t\t\t\t\t\t&input->chars[pos], *transCharslen, 0, table))) {\n\t\t\t\t\tif (*transOpcode == CTO_Syllable) {\n\t\t\t\t\t\ttryThis = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\truleOffset = (*transRule)->charsnext;\n\t\t\t}\n\t\t\ttryThis++;\n\t\t}\n\t\tswitch (*transOpcode) {\n\t\tcase CTO_Always:\n\t\t\tif (pos >= input->length) return 0;\n\t\t\ttypebuf[pos++] |= currentMark;\n\t\t\tbreak;\n\t\tcase CTO_Syllable:\n\t\t\t/* cycle between SYLLABLE_MARKER_1 and SYLLABLE_MARKER_2 so\n\t\t\t * we can distinguinsh two consequtive syllables */\n\t\t\tcurrentMark = syllable_marks[syllable_mark_selector];\n\t\t\tsyllable_mark_selector = (syllable_mark_selector + 1) % 2;\n\n\t\t\tif ((pos + *transCharslen) > input->length) return 0;\n\t\t\tfor (k = 0; k < *transCharslen; k++) typebuf[pos++] |= currentMark;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic const EmphasisClass capsEmphClass = 0x1;\nstatic const EmphasisClass *emphClasses = NULL;\n\n/* An emphasis class is a bit field that contains a single \"1\" */\nstatic void\ninitEmphClasses() {\n\tEmphasisClass *classes = malloc(10 * sizeof(EmphasisClass));\n\tint j;\n\tif (!classes) _lou_outOfMemory();\n\tfor (j = 0; j < 10; j++) {\n\t\tclasses[j] = 0x1 << (j + 1);\n\t}\n\temphClasses = classes;\n}\n\nstatic void\nresolveEmphasisWords(EmphasisInfo *buffer, const EmphasisClass class,\n\t\tconst InString *input, unsigned int *wordBuffer) {\n\tint in_word = 0, in_emp = 0, word_stop;  // booleans\n\tint word_start = -1;\t\t\t\t\t // input position\n\tunsigned int word_whole = 0;\t\t\t // wordBuffer value\n\tint i;\n\n\tfor (i = 0; i < input->length; i++) {\n\t\t// TODO: give each emphasis its own whole word bit?\n\t\t/* clear out previous whole word markings */\n\t\twordBuffer[i] &= ~WORD_WHOLE;\n\n\t\t/* check if at beginning of emphasis */\n\t\tif (!in_emp)\n\t\t\tif (buffer[i].begin & class) {\n\t\t\t\tin_emp = 1;\n\t\t\t\tbuffer[i].begin &= ~class;\n\n\t\t\t\t/* emphasis started inside word */\n\t\t\t\tif (in_word) {\n\t\t\t\t\tword_start = i;\n\t\t\t\t\tword_whole = 0;\n\t\t\t\t}\n\n\t\t\t\t/* emphasis started on space */\n\t\t\t\tif (!(wordBuffer[i] & WORD_CHAR)) word_start = -1;\n\t\t\t}\n\n\t\t/* check if at end of emphasis */\n\t\tif (in_emp)\n\t\t\tif (buffer[i].end & class) {\n\t\t\t\tin_emp = 0;\n\t\t\t\tbuffer[i].end &= ~class;\n\n\t\t\t\tif (in_word && word_start >= 0) {\n\t\t\t\t\t/* check if emphasis ended inside a word */\n\t\t\t\t\tword_stop = 1;\n\t\t\t\t\tif (wordBuffer[i] & WORD_CHAR)\n\t\t\t\t\t\tword_whole = 0;\n\t\t\t\t\telse\n\t\t\t\t\t\tword_stop = 0;\n\n\t\t\t\t\t/* if whole word is one symbol,\n\t\t\t\t\t * turn it into a symbol */\n\t\t\t\t\tif (word_start + 1 == i)\n\t\t\t\t\t\tbuffer[word_start].symbol |= class;\n\t\t\t\t\telse {\n\t\t\t\t\t\tbuffer[word_start].word |= class;\n\t\t\t\t\t\tif (word_stop) {\n\t\t\t\t\t\t\tbuffer[i].end |= class;\n\t\t\t\t\t\t\tbuffer[i].word |= class;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\twordBuffer[word_start] |= word_whole;\n\t\t\t\t}\n\t\t\t}\n\n\t\t/* check if at beginning of word */\n\t\tif (!in_word)\n\t\t\tif (wordBuffer[i] & WORD_CHAR) {\n\t\t\t\tin_word = 1;\n\t\t\t\tif (in_emp) {\n\t\t\t\t\tword_whole = WORD_WHOLE;\n\t\t\t\t\tword_start = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t/* check if at end of word */\n\t\tif (in_word)\n\t\t\tif (!(wordBuffer[i] & WORD_CHAR)) {\n\t\t\t\t/* made it through whole word */\n\t\t\t\tif (in_emp && word_start >= 0) {\n\t\t\t\t\t/* if word is one symbol,\n\t\t\t\t\t * turn it into a symbol */\n\t\t\t\t\tif (word_start + 1 == i)\n\t\t\t\t\t\tbuffer[word_start].symbol |= class;\n\t\t\t\t\telse\n\t\t\t\t\t\tbuffer[word_start].word |= class;\n\t\t\t\t\twordBuffer[word_start] |= word_whole;\n\t\t\t\t}\n\n\t\t\t\tin_word = 0;\n\t\t\t\tword_whole = 0;\n\t\t\t\tword_start = -1;\n\t\t\t}\n\t}\n\n\t/* clean up end */\n\tif (in_emp) {\n\t\tbuffer[i].end &= ~class;\n\n\t\tif (in_word)\n\t\t\tif (word_start >= 0) {\n\t\t\t\t/* if word is one symbol,\n\t\t\t\t * turn it into a symbol */\n\t\t\t\tif (word_start + 1 == i)\n\t\t\t\t\tbuffer[word_start].symbol |= class;\n\t\t\t\telse\n\t\t\t\t\tbuffer[word_start].word |= class;\n\t\t\t\twordBuffer[word_start] |= word_whole;\n\t\t\t}\n\t}\n}\n\nstatic void\nconvertToPassage(const int pass_start, const int pass_end, const int word_start,\n\t\tEmphasisInfo *buffer, const EmphRuleNumber emphRule, const EmphasisClass class,\n\t\tconst TranslationTableHeader *table, unsigned int *wordBuffer) {\n\tint i;\n\tconst TranslationTableRule *indicRule;\n\n\tfor (i = pass_start; i <= pass_end; i++)\n\t\tif (wordBuffer[i] & WORD_WHOLE) {\n\t\t\tbuffer[i].symbol &= ~class;\n\t\t\tbuffer[i].word &= ~class;\n\t\t\twordBuffer[i] &= ~WORD_WHOLE;\n\t\t}\n\n\tbuffer[pass_start].begin |= class;\n\tif (brailleIndicatorDefined(\n\t\t\t\ttable->emphRules[emphRule][endOffset], table, &indicRule) ||\n\t\t\tbrailleIndicatorDefined(\n\t\t\t\t\ttable->emphRules[emphRule][endPhraseAfterOffset], table, &indicRule))\n\t\tbuffer[pass_end].end |= class;\n\telse if (brailleIndicatorDefined(table->emphRules[emphRule][endPhraseBeforeOffset],\n\t\t\t\t\t table, &indicRule))\n\t\tbuffer[word_start].end |= class;\n}\n\nstatic void\nresolveEmphasisPassages(EmphasisInfo *buffer, const EmphRuleNumber emphRule,\n\t\tconst EmphasisClass class, const TranslationTableHeader *table,\n\t\tconst InString *input, unsigned int *wordBuffer) {\n\tunsigned int word_cnt = 0;\n\tint pass_start = -1, pass_end = -1, word_start = -1, in_word = 0, in_pass = 0;\n\tint i;\n\n\tfor (i = 0; i < input->length; i++) {\n\t\t/* check if at beginning of word */\n\t\tif (!in_word)\n\t\t\tif (wordBuffer[i] & WORD_CHAR) {\n\t\t\t\tin_word = 1;\n\t\t\t\tif (wordBuffer[i] & WORD_WHOLE) {\n\t\t\t\t\tif (!in_pass) {\n\t\t\t\t\t\tin_pass = 1;\n\t\t\t\t\t\tpass_start = i;\n\t\t\t\t\t\tpass_end = -1;\n\t\t\t\t\t\tword_cnt = 1;\n\t\t\t\t\t} else\n\t\t\t\t\t\tword_cnt++;\n\t\t\t\t\tword_start = i;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (in_pass) {\n\t\t\t\t\tif (word_cnt >= table->emphRules[emphRule][lenPhraseOffset])\n\t\t\t\t\t\tif (pass_end >= 0) {\n\t\t\t\t\t\t\tconvertToPassage(pass_start, pass_end, word_start, buffer,\n\t\t\t\t\t\t\t\t\temphRule, class, table, wordBuffer);\n\t\t\t\t\t\t}\n\t\t\t\t\tin_pass = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t/* check if at end of word */\n\t\tif (in_word)\n\t\t\tif (!(wordBuffer[i] & WORD_CHAR)) {\n\t\t\t\tin_word = 0;\n\t\t\t\tif (in_pass) pass_end = i;\n\t\t\t}\n\n\t\tif (in_pass)\n\t\t\tif ((buffer[i].begin | buffer[i].end | buffer[i].word | buffer[i].symbol) &\n\t\t\t\t\tclass) {\n\t\t\t\tif (word_cnt >= table->emphRules[emphRule][lenPhraseOffset])\n\t\t\t\t\tif (pass_end >= 0) {\n\t\t\t\t\t\tconvertToPassage(pass_start, pass_end, word_start, buffer,\n\t\t\t\t\t\t\t\temphRule, class, table, wordBuffer);\n\t\t\t\t\t}\n\t\t\t\tin_pass = 0;\n\t\t\t}\n\t}\n\n\tif (in_pass) {\n\t\tif (word_cnt >= table->emphRules[emphRule][lenPhraseOffset]) {\n\t\t\tif (pass_end >= 0) {\n\t\t\t\tif (in_word) {\n\t\t\t\t\tconvertToPassage(pass_start, i, word_start, buffer, emphRule, class,\n\t\t\t\t\t\t\ttable, wordBuffer);\n\t\t\t\t} else {\n\t\t\t\t\tconvertToPassage(pass_start, pass_end, word_start, buffer, emphRule,\n\t\t\t\t\t\t\tclass, table, wordBuffer);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void\nresolveEmphasisSingleSymbols(\n\t\tEmphasisInfo *buffer, const EmphasisClass class, const InString *input) {\n\tint i;\n\n\tfor (i = 0; i < input->length; i++) {\n\t\tif (buffer[i].begin & class)\n\t\t\tif (buffer[i + 1].end & class) {\n\t\t\t\tbuffer[i].begin &= ~class;\n\t\t\t\tbuffer[i + 1].end &= ~class;\n\t\t\t\tbuffer[i].symbol |= class;\n\t\t\t}\n\t}\n}\n\nstatic void\nresolveEmphasisAllCapsSymbols(\n\t\tEmphasisInfo *buffer, formtype *typebuf, const InString *input) {\n\t/* Marks every caps letter with capsEmphClass symbol.\n\t * Used in the special case where capsnocont has been defined and capsword has not\n\t * been defined. */\n\n\tint inEmphasis = 0, i;\n\n\tfor (i = 0; i < input->length; i++) {\n\t\tif (buffer[i].end & capsEmphClass) {\n\t\t\tinEmphasis = 0;\n\t\t\tbuffer[i].end &= ~capsEmphClass;\n\t\t} else {\n\t\t\tif (buffer[i].begin & capsEmphClass) {\n\t\t\t\tbuffer[i].begin &= ~capsEmphClass;\n\t\t\t\tinEmphasis = 1;\n\t\t\t}\n\t\t\tif (inEmphasis) {\n\t\t\t\tif (typebuf[i] & CAPSEMPH)\n\t\t\t\t\t/* Only mark if actually a capital letter (don't mark spaces or\n\t\t\t\t\t * punctuation). */\n\t\t\t\t\tbuffer[i].symbol |= capsEmphClass;\n\t\t\t} /* In emphasis */\n\t\t}\t /* Not caps end */\n\t}\n}\n\nstatic void\nresolveEmphasisResets(EmphasisInfo *buffer, const EmphasisClass class,\n\t\tconst TranslationTableHeader *table, const InString *input,\n\t\tunsigned int *wordBuffer) {\n\tint in_word = 0, in_pass = 0, word_start = -1, word_reset = 0, orig_reset = -1,\n\t\tletter_cnt = 0;\n\tint i, j;\n\n\tfor (i = 0; i < input->length; i++) {\n\t\tif (in_pass)\n\t\t\tif (buffer[i].end & class) in_pass = 0;\n\n\t\tif (!in_pass) {\n\t\t\tif (buffer[i].begin & class)\n\t\t\t\tin_pass = 1;\n\t\t\telse {\n\t\t\t\tif (!in_word) {\n\t\t\t\t\tif (buffer[i].word & class) {\n\t\t\t\t\t\t/* deal with case when reset\n\t\t\t\t\t\t * was at beginning of word */\n\t\t\t\t\t\tif (wordBuffer[i] & WORD_RESET ||\n\t\t\t\t\t\t\t\t!checkAttr(input->chars[i], CTC_Letter, 0, table)) {\n\t\t\t\t\t\t\t/* not just one reset by itself */\n\t\t\t\t\t\t\tif (wordBuffer[i + 1] & WORD_CHAR) {\n\t\t\t\t\t\t\t\tbuffer[i + 1].word |= class;\n\t\t\t\t\t\t\t\tif (wordBuffer[i] & WORD_WHOLE)\n\t\t\t\t\t\t\t\t\twordBuffer[i + 1] |= WORD_WHOLE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbuffer[i].word &= ~class;\n\t\t\t\t\t\t\twordBuffer[i] &= ~WORD_WHOLE;\n\n\t\t\t\t\t\t\t/* if reset is a letter, make it a symbol */\n\t\t\t\t\t\t\tif (checkAttr(input->chars[i], CTC_Letter, 0, table))\n\t\t\t\t\t\t\t\tbuffer[i].symbol |= class;\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tin_word = 1;\n\t\t\t\t\t\tword_start = i;\n\t\t\t\t\t\tletter_cnt = 0;\n\t\t\t\t\t\tword_reset = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* it is possible for a character to have been\n\t\t\t\t\t * marked as a symbol when it should not be one */\n\t\t\t\t\telse if (buffer[i].symbol & class) {\n\t\t\t\t\t\tif (wordBuffer[i] & WORD_RESET ||\n\t\t\t\t\t\t\t\t!checkAttr(input->chars[i], CTC_Letter, 0, table))\n\t\t\t\t\t\t\tbuffer[i].symbol &= ~class;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (in_word) {\n\n\t\t\t\t\t/* at end of word */\n\t\t\t\t\tif (!(wordBuffer[i] & WORD_CHAR) ||\n\t\t\t\t\t\t\t(buffer[i].word & class && buffer[i].end & class)) {\n\t\t\t\t\t\tin_word = 0;\n\n\t\t\t\t\t\t/* check if symbol */\n\t\t\t\t\t\tif (letter_cnt == 1) {\n\t\t\t\t\t\t\tbuffer[word_start].symbol |= class;\n\t\t\t\t\t\t\tbuffer[word_start].word &= ~class;\n\t\t\t\t\t\t\twordBuffer[word_start] &= ~WORD_WHOLE;\n\t\t\t\t\t\t\tbuffer[i].end &= ~class;\n\t\t\t\t\t\t\tbuffer[i].word &= ~class;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* if word ended on a reset or last char was a reset,\n\t\t\t\t\t\t * get rid of end bits */\n\t\t\t\t\t\tif (word_reset || wordBuffer[i] & WORD_RESET ||\n\t\t\t\t\t\t\t\t!checkAttr(input->chars[i], CTC_Letter, 0, table)) {\n\t\t\t\t\t\t\tbuffer[i].end &= ~class;\n\t\t\t\t\t\t\tbuffer[i].word &= ~class;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* if word ended when it began, get rid of all bits */\n\t\t\t\t\t\tif (i == word_start) {\n\t\t\t\t\t\t\twordBuffer[word_start] &= ~WORD_WHOLE;\n\t\t\t\t\t\t\tbuffer[i].end &= ~class;\n\t\t\t\t\t\t\tbuffer[i].word &= ~class;\n\t\t\t\t\t\t}\n\t\t\t\t\t\torig_reset = -1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* hit reset */\n\t\t\t\t\t\tif (wordBuffer[i] & WORD_RESET ||\n\t\t\t\t\t\t\t\t!checkAttr(input->chars[i], CTC_Letter, 0, table)) {\n\t\t\t\t\t\t\tif (!checkAttr(input->chars[i], CTC_Letter, 0, table)) {\n\t\t\t\t\t\t\t\tif (checkAttr(input->chars[i], CTC_CapsMode, 0, table)) {\n\t\t\t\t\t\t\t\t\t/* chars marked as not resetting */\n\t\t\t\t\t\t\t\t\torig_reset = i;\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t} else if (orig_reset >= 0) {\n\t\t\t\t\t\t\t\t\t/* invalid no reset sequence */\n\t\t\t\t\t\t\t\t\tfor (j = orig_reset; j < i; j++)\n\t\t\t\t\t\t\t\t\t\tbuffer[j].word &= ~class;\n\t\t\t\t\t\t\t\t\t// word_reset = 1;\n\t\t\t\t\t\t\t\t\torig_reset = -1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* check if symbol is not already resetting */\n\t\t\t\t\t\t\tif (letter_cnt == 1) {\n\t\t\t\t\t\t\t\tbuffer[word_start].symbol |= class;\n\t\t\t\t\t\t\t\tbuffer[word_start].word &= ~class;\n\t\t\t\t\t\t\t\twordBuffer[word_start] &= ~WORD_WHOLE;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* if reset is a letter, make it the new word_start */\n\t\t\t\t\t\t\tif (checkAttr(input->chars[i], CTC_Letter, 0, table)) {\n\t\t\t\t\t\t\t\tword_reset = 0;\n\t\t\t\t\t\t\t\tword_start = i;\n\t\t\t\t\t\t\t\tletter_cnt = 1;\n\t\t\t\t\t\t\t\tbuffer[i].word |= class;\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tword_reset = 1;\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (word_reset) {\n\t\t\t\t\t\t\tword_reset = 0;\n\t\t\t\t\t\t\tword_start = i;\n\t\t\t\t\t\t\tletter_cnt = 0;\n\t\t\t\t\t\t\tbuffer[i].word |= class;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tletter_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* clean up end */\n\tif (in_word) {\n\t\t/* check if symbol */\n\t\tif (letter_cnt == 1) {\n\t\t\tbuffer[word_start].symbol |= class;\n\t\t\tbuffer[word_start].word &= ~class;\n\t\t\twordBuffer[word_start] &= ~WORD_WHOLE;\n\t\t\tbuffer[i].end &= ~class;\n\t\t\tbuffer[i].word &= ~class;\n\t\t}\n\n\t\tif (word_reset) {\n\t\t\tbuffer[i].end &= ~class;\n\t\t\tbuffer[i].word &= ~class;\n\t\t}\n\t}\n}\n\nstatic void\nmarkEmphases(const TranslationTableHeader *table, const InString *input,\n\t\tformtype *typebuf, unsigned int *wordBuffer, EmphasisInfo *emphasisBuffer,\n\t\tint haveEmphasis) {\n\t/* Relies on the order of typeforms emph_1..emph_10. */\n\tint caps_start = -1, last_caps = -1, caps_cnt = 0;\n\tint emph_start[10] = { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 };\n\tint i, j;\n\n\t// initialize static variable emphClasses\n\tif (haveEmphasis && !emphClasses) {\n\t\tinitEmphClasses();\n\t}\n\n\tfor (i = 0; i < input->length; i++) {\n\t\tif (!checkAttr(input->chars[i], CTC_Space, 0, table)) {\n\t\t\twordBuffer[i] |= WORD_CHAR;\n\t\t} else if (caps_cnt > 0) {\n\t\t\tlast_caps = i;\n\t\t\tcaps_cnt = 0;\n\t\t}\n\n\t\tif (checkAttr(input->chars[i], CTC_UpperCase, 0, table)) {\n\t\t\tif (caps_start < 0) caps_start = i;\n\t\t\tcaps_cnt++;\n\t\t} else if (caps_start >= 0) {\n\t\t\t/* caps should keep going until this */\n\t\t\tif (checkAttr(input->chars[i], CTC_Letter, 0, table) &&\n\t\t\t\t\tcheckAttr(input->chars[i], CTC_LowerCase, 0, table)) {\n\t\t\t\temphasisBuffer[caps_start].begin |= capsEmphClass;\n\t\t\t\tif (caps_cnt > 0)\n\t\t\t\t\temphasisBuffer[i].end |= capsEmphClass;\n\t\t\t\telse\n\t\t\t\t\temphasisBuffer[last_caps].end |= capsEmphClass;\n\t\t\t\tcaps_start = -1;\n\t\t\t\tlast_caps = -1;\n\t\t\t\tcaps_cnt = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (!haveEmphasis) continue;\n\n\t\tfor (j = 0; j < 10; j++) {\n\t\t\tif (typebuf[i] & (emph_1 << j)) {\n\t\t\t\tif (emph_start[j] < 0) emph_start[j] = i;\n\t\t\t} else if (emph_start[j] >= 0) {\n\t\t\t\temphasisBuffer[emph_start[j]].begin |= emphClasses[j];\n\t\t\t\temphasisBuffer[i].end |= emphClasses[j];\n\t\t\t\temph_start[j] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* clean up input->length */\n\tif (caps_start >= 0) {\n\t\temphasisBuffer[caps_start].begin |= capsEmphClass;\n\t\tif (caps_cnt > 0)\n\t\t\temphasisBuffer[input->length].end |= capsEmphClass;\n\t\telse\n\t\t\temphasisBuffer[last_caps].end |= capsEmphClass;\n\t}\n\n\tif (haveEmphasis) {\n\t\tfor (j = 0; j < 10; j++) {\n\t\t\tif (emph_start[j] >= 0) {\n\t\t\t\temphasisBuffer[emph_start[j]].begin |= emphClasses[j];\n\t\t\t\temphasisBuffer[input->length].end |= emphClasses[j];\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Handle capsnocont */\n\tif (table->capsNoCont) {\n\t\tint inCaps = 0;\n\t\tfor (i = 0; i < input->length; i++) {\n\t\t\tif (emphasisBuffer[i].end & capsEmphClass) {\n\t\t\t\tinCaps = 0;\n\t\t\t} else {\n\t\t\t\tif ((emphasisBuffer[i].begin & capsEmphClass) &&\n\t\t\t\t\t\t!(emphasisBuffer[i + 1].end & capsEmphClass))\n\t\t\t\t\tinCaps = 1;\n\t\t\t\tif (inCaps) typebuf[i] |= no_contract;\n\t\t\t}\n\t\t}\n\t}\n\tif (table->emphRules[capsRule][begWordOffset]) {\n\t\tresolveEmphasisWords(emphasisBuffer, capsEmphClass, input, wordBuffer);\n\t\tif (table->emphRules[capsRule][lenPhraseOffset])\n\t\t\tresolveEmphasisPassages(\n\t\t\t\t\temphasisBuffer, capsRule, capsEmphClass, table, input, wordBuffer);\n\t\tresolveEmphasisResets(emphasisBuffer, capsEmphClass, table, input, wordBuffer);\n\t} else if (table->emphRules[capsRule][letterOffset]) {\n\t\tif (table->capsNoCont) /* capsnocont and no capsword */\n\t\t\tresolveEmphasisAllCapsSymbols(emphasisBuffer, typebuf, input);\n\t\telse\n\t\t\tresolveEmphasisSingleSymbols(emphasisBuffer, capsEmphClass, input);\n\t}\n\tif (!haveEmphasis) return;\n\n\tfor (j = 0; j < 10; j++) {\n\t\tif (table->emphRules[emph1Rule + j][begWordOffset]) {\n\t\t\tresolveEmphasisWords(emphasisBuffer, emphClasses[j], input, wordBuffer);\n\t\t\tif (table->emphRules[emph1Rule + j][lenPhraseOffset])\n\t\t\t\tresolveEmphasisPassages(emphasisBuffer, emph1Rule + j, emphClasses[j],\n\t\t\t\t\t\ttable, input, wordBuffer);\n\t\t} else if (table->emphRules[emph1Rule + j][letterOffset])\n\t\t\tresolveEmphasisSingleSymbols(emphasisBuffer, emphClasses[j], input);\n\t}\n}\n\nstatic void\ninsertEmphasisSymbol(const EmphasisInfo *buffer, const int at,\n\t\tconst EmphRuleNumber emphRule, const EmphasisClass class,\n\t\tconst TranslationTableHeader *table, int pos, const InString *input,\n\t\tOutString *output, int *posMapping, int *cursorPosition, int *cursorStatus) {\n\tif (buffer[at].symbol & class) {\n\t\tconst TranslationTableRule *indicRule;\n\t\tif (brailleIndicatorDefined(\n\t\t\t\t\ttable->emphRules[emphRule][letterOffset], table, &indicRule))\n\t\t\tfor_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0, pos,\n\t\t\t\t\tinput, output, posMapping, cursorPosition, cursorStatus);\n\t}\n}\n\nstatic void\ninsertEmphasisBegin(const EmphasisInfo *buffer, const int at,\n\t\tconst EmphRuleNumber emphRule, const EmphasisClass class,\n\t\tconst TranslationTableHeader *table, int pos, const InString *input,\n\t\tOutString *output, int *posMapping, int *cursorPosition, int *cursorStatus) {\n\tconst TranslationTableRule *indicRule;\n\tif (buffer[at].begin & class) {\n\t\tif (brailleIndicatorDefined(\n\t\t\t\t\ttable->emphRules[emphRule][begPhraseOffset], table, &indicRule))\n\t\t\tfor_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0, pos,\n\t\t\t\t\tinput, output, posMapping, cursorPosition, cursorStatus);\n\t\telse if (brailleIndicatorDefined(\n\t\t\t\t\t\t table->emphRules[emphRule][begOffset], table, &indicRule))\n\t\t\tfor_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0, pos,\n\t\t\t\t\tinput, output, posMapping, cursorPosition, cursorStatus);\n\t}\n\n\tif (buffer[at].word & class\n\t\t\t// && !(buffer[at].begin & class)\n\t\t\t&& !(buffer[at].end & class)) {\n\t\tif (brailleIndicatorDefined(\n\t\t\t\t\ttable->emphRules[emphRule][begWordOffset], table, &indicRule))\n\t\t\tfor_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0, pos,\n\t\t\t\t\tinput, output, posMapping, cursorPosition, cursorStatus);\n\t}\n}\n\nstatic void\ninsertEmphasisEnd(const EmphasisInfo *buffer, const int at, const EmphRuleNumber emphRule,\n\t\tconst EmphasisClass class, const TranslationTableHeader *table, int pos,\n\t\tconst InString *input, OutString *output, int *posMapping, int *cursorPosition,\n\t\tint *cursorStatus) {\n\tif (buffer[at].end & class) {\n\t\tconst TranslationTableRule *indicRule;\n\t\tif (buffer[at].word & class) {\n\t\t\tif (brailleIndicatorDefined(\n\t\t\t\t\t\ttable->emphRules[emphRule][endWordOffset], table, &indicRule))\n\t\t\t\tfor_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, -1,\n\t\t\t\t\t\tpos, input, output, posMapping, cursorPosition, cursorStatus);\n\t\t} else {\n\t\t\tif (brailleIndicatorDefined(\n\t\t\t\t\t\ttable->emphRules[emphRule][endOffset], table, &indicRule))\n\t\t\t\tfor_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, -1,\n\t\t\t\t\t\tpos, input, output, posMapping, cursorPosition, cursorStatus);\n\t\t\telse if (brailleIndicatorDefined(\n\t\t\t\t\t\t\t table->emphRules[emphRule][endPhraseAfterOffset], table,\n\t\t\t\t\t\t\t &indicRule))\n\t\t\t\tfor_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, -1,\n\t\t\t\t\t\tpos, input, output, posMapping, cursorPosition, cursorStatus);\n\t\t\telse if (brailleIndicatorDefined(\n\t\t\t\t\t\t\t table->emphRules[emphRule][endPhraseBeforeOffset], table,\n\t\t\t\t\t\t\t &indicRule))\n\t\t\t\tfor_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0,\n\t\t\t\t\t\tpos, input, output, posMapping, cursorPosition, cursorStatus);\n\t\t}\n\t}\n}\n\nstatic int\nendCount(const EmphasisInfo *buffer, const int at, const EmphasisClass class) {\n\tint i, cnt = 1;\n\tif (!(buffer[at].end & class)) return 0;\n\tfor (i = at - 1; i >= 0; i--)\n\t\tif (buffer[i].begin & class || buffer[i].word & class)\n\t\t\tbreak;\n\t\telse\n\t\t\tcnt++;\n\treturn cnt;\n}\n\nstatic int\nbeginCount(const EmphasisInfo *buffer, const int at, const EmphasisClass class,\n\t\tconst TranslationTableHeader *table, const InString *input) {\n\tif (buffer[at].begin & class) {\n\t\tint i, cnt = 1;\n\t\tfor (i = at + 1; i < input->length; i++)\n\t\t\tif (buffer[i].end & class)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tcnt++;\n\t\treturn cnt;\n\t} else if (buffer[at].word & class) {\n\t\tint i, cnt = 1;\n\t\tfor (i = at + 1; i < input->length; i++)\n\t\t\tif (buffer[i].end & class) break;\n\t\t\t// TODO: WORD_RESET?\n\t\t\telse if (checkAttr(input->chars[i], CTC_SeqDelimiter | CTC_Space, 0, table))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tcnt++;\n\t\treturn cnt;\n\t}\n\treturn 0;\n}\n\nstatic void\ninsertEmphasesAt(const int at, const TranslationTableHeader *table, int pos,\n\t\tconst InString *input, OutString *output, int *posMapping,\n\t\tconst EmphasisInfo *emphasisBuffer, int haveEmphasis, int transOpcode,\n\t\tint *cursorPosition, int *cursorStatus) {\n\tint type_counts[10];\n\tint i, j, min, max;\n\n\t/* simple case */\n\tif (!haveEmphasis) {\n\t\t/* insert graded 1 mode indicator */\n\t\tif (transOpcode == CTO_Contraction) {\n\t\t\tconst TranslationTableRule *indicRule;\n\t\t\tif (brailleIndicatorDefined(table->noContractSign, table, &indicRule))\n\t\t\t\tfor_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0,\n\t\t\t\t\t\tpos, input, output, posMapping, cursorPosition, cursorStatus);\n\t\t}\n\n\t\tif ((emphasisBuffer[at].begin | emphasisBuffer[at].end | emphasisBuffer[at].word |\n\t\t\t\t\temphasisBuffer[at].symbol) &\n\t\t\t\tcapsEmphClass) {\n\t\t\tinsertEmphasisEnd(emphasisBuffer, at, capsRule, capsEmphClass, table, pos,\n\t\t\t\t\tinput, output, posMapping, cursorPosition, cursorStatus);\n\t\t\tinsertEmphasisBegin(emphasisBuffer, at, capsRule, capsEmphClass, table, pos,\n\t\t\t\t\tinput, output, posMapping, cursorPosition, cursorStatus);\n\t\t\tinsertEmphasisSymbol(emphasisBuffer, at, capsRule, capsEmphClass, table, pos,\n\t\t\t\t\tinput, output, posMapping, cursorPosition, cursorStatus);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* The order of inserting the end symbols must be the reverse\n\t * of the insertions of the begin symbols so that they will\n\t * nest properly when multiple emphases start and end at\n\t * the same place */\n\t// TODO: ordering with partial word\n\n\tif ((emphasisBuffer[at].begin | emphasisBuffer[at].end | emphasisBuffer[at].word |\n\t\t\t\temphasisBuffer[at].symbol) &\n\t\t\tcapsEmphClass)\n\t\tinsertEmphasisEnd(emphasisBuffer, at, capsRule, capsEmphClass, table, pos, input,\n\t\t\t\toutput, posMapping, cursorPosition, cursorStatus);\n\n\t/* end bits */\n\tfor (i = 0; i < 10; i++)\n\t\ttype_counts[i] = endCount(emphasisBuffer, at, emphClasses[i]);\n\n\tfor (i = 0; i < 10; i++) {\n\t\tmin = -1;\n\t\tfor (j = 0; j < 10; j++)\n\t\t\tif (type_counts[j] > 0)\n\t\t\t\tif (min < 0 || type_counts[j] < type_counts[min]) min = j;\n\t\tif (min < 0) break;\n\t\ttype_counts[min] = 0;\n\t\tinsertEmphasisEnd(emphasisBuffer, at, emph1Rule + min, emphClasses[min], table,\n\t\t\t\tpos, input, output, posMapping, cursorPosition, cursorStatus);\n\t}\n\n\t/* begin and word bits */\n\tfor (i = 0; i < 10; i++)\n\t\ttype_counts[i] = beginCount(emphasisBuffer, at, emphClasses[i], table, input);\n\n\tfor (i = 9; i >= 0; i--) {\n\t\tmax = 9;\n\t\tfor (j = 9; j >= 0; j--)\n\t\t\tif (type_counts[max] < type_counts[j]) max = j;\n\t\tif (!type_counts[max]) break;\n\t\ttype_counts[max] = 0;\n\t\tinsertEmphasisBegin(emphasisBuffer, at, emph1Rule + max, emphClasses[max], table,\n\t\t\t\tpos, input, output, posMapping, cursorPosition, cursorStatus);\n\t}\n\n\t/* symbol bits */\n\tfor (i = 9; i >= 0; i--)\n\t\tif ((emphasisBuffer[at].begin | emphasisBuffer[at].end | emphasisBuffer[at].word |\n\t\t\t\t\temphasisBuffer[at].symbol) &\n\t\t\t\temphClasses[i])\n\t\t\tinsertEmphasisSymbol(emphasisBuffer, at, emph1Rule + i, emphClasses[i], table,\n\t\t\t\t\tpos, input, output, posMapping, cursorPosition, cursorStatus);\n\n\t/* insert graded 1 mode indicator */\n\tif (transOpcode == CTO_Contraction) {\n\t\tconst TranslationTableRule *indicRule;\n\t\tif (brailleIndicatorDefined(table->noContractSign, table, &indicRule))\n\t\t\tfor_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0, pos,\n\t\t\t\t\tinput, output, posMapping, cursorPosition, cursorStatus);\n\t}\n\n\t/* insert capitalization last so it will be closest to word */\n\tif ((emphasisBuffer[at].begin | emphasisBuffer[at].end | emphasisBuffer[at].word |\n\t\t\t\temphasisBuffer[at].symbol) &\n\t\t\tcapsEmphClass) {\n\t\tinsertEmphasisBegin(emphasisBuffer, at, capsRule, capsEmphClass, table, pos,\n\t\t\t\tinput, output, posMapping, cursorPosition, cursorStatus);\n\t\tinsertEmphasisSymbol(emphasisBuffer, at, capsRule, capsEmphClass, table, pos,\n\t\t\t\tinput, output, posMapping, cursorPosition, cursorStatus);\n\t}\n}\n\nstatic void\ninsertEmphases(const TranslationTableHeader *table, int pos, const InString *input,\n\t\tOutString *output, int *posMapping, const EmphasisInfo *emphasisBuffer,\n\t\tint haveEmphasis, int transOpcode, int *cursorPosition, int *cursorStatus,\n\t\tint *pre_src) {\n\tint at;\n\n\tfor (at = *pre_src; at <= pos; at++)\n\t\tinsertEmphasesAt(at, table, pos, input, output, posMapping, emphasisBuffer,\n\t\t\t\thaveEmphasis, transOpcode, cursorPosition, cursorStatus);\n\n\t*pre_src = pos + 1;\n}\n\nstatic void\ncheckNumericMode(const TranslationTableHeader *table, int pos, const InString *input,\n\t\tOutString *output, int *posMapping, int *cursorPosition, int *cursorStatus,\n\t\tint *dontContract, int *numericMode) {\n\tint i;\n\tconst TranslationTableRule *indicRule;\n\tif (!brailleIndicatorDefined(table->numberSign, table, &indicRule)) return;\n\n\t/* not in numeric mode */\n\tif (!*numericMode) {\n\t\tif (checkAttr(input->chars[pos], CTC_Digit | CTC_LitDigit, 0, table)) {\n\t\t\t*numericMode = 1;\n\t\t\t*dontContract = 1;\n\t\t\tfor_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0, pos,\n\t\t\t\t\tinput, output, posMapping, cursorPosition, cursorStatus);\n\t\t} else if (checkAttr(input->chars[pos], CTC_NumericMode, 0, table)) {\n\t\t\tfor (i = pos + 1; i < input->length; i++) {\n\t\t\t\tif (checkAttr(input->chars[i], CTC_Digit | CTC_LitDigit, 0, table)) {\n\t\t\t\t\t*numericMode = 1;\n\t\t\t\t\tfor_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen,\n\t\t\t\t\t\t\t0, pos, input, output, posMapping, cursorPosition,\n\t\t\t\t\t\t\tcursorStatus);\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (!checkAttr(input->chars[i], CTC_NumericMode, 0, table))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* in numeric mode */\n\telse {\n\t\tif (!checkAttr(input->chars[pos],\n\t\t\t\t\tCTC_Digit | CTC_LitDigit | CTC_NumericMode | CTC_MidEndNumericMode, 0,\n\t\t\t\t\ttable)) {\n\t\t\t*numericMode = 0;\n\t\t\tif (brailleIndicatorDefined(table->noContractSign, table, &indicRule))\n\t\t\t\tif (checkAttr(input->chars[pos], CTC_NumericNoContract, 0, table))\n\t\t\t\t\tfor_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen,\n\t\t\t\t\t\t\t0, pos, input, output, posMapping, cursorPosition,\n\t\t\t\t\t\t\tcursorStatus);\n\t\t}\n\t}\n}\n\nstatic int\ntranslateString(const TranslationTableHeader *table, int mode, int currentPass,\n\t\tconst InString *input, OutString *output, int *posMapping, formtype *typebuf,\n\t\tunsigned char *srcSpacing, unsigned char *destSpacing, unsigned int *wordBuffer,\n\t\tEmphasisInfo *emphasisBuffer, int haveEmphasis, int *realInlen,\n\t\tint *posIncremented, int *cursorPosition, int *cursorStatus, int compbrlStart,\n\t\tint compbrlEnd) {\n\tint pos;\n\tint transOpcode;\n\tint prevTransOpcode;\n\tconst TranslationTableRule *transRule;\n\tint transCharslen;\n\tint passCharDots;\n\tconst widechar *passInstructions;\n\tint passIC; /* Instruction counter */\n\tPassRuleMatch patternMatch;\n\tTranslationTableRule *groupingRule;\n\twidechar groupingOp;\n\tint numericMode;\n\tint dontContract;\n\tint destword;\n\tint srcword;\n\tint pre_src;\n\tTranslationTableCharacter *curCharDef;\n\tconst widechar *repwordStart;\n\tint repwordLength;\n\tint curType;\n\tint prevType;\n\tint prevTypeform;\n\tint prevPos;\n\tconst InString *origInput = input;\n\t/* Main translation routine */\n\tint k;\n\ttranslation_direction = 1;\n\tmarkSyllables(table, input, typebuf, &transOpcode, &transRule, &transCharslen);\n\tnumericMode = 0;\n\tsrcword = 0;\n\tdestword = 0; /* last word translated */\n\tdontContract = 0;\n\tprevTransOpcode = CTO_None;\n\tprevType = curType = prevTypeform = plain_text;\n\tprevPos = -1;\n\tpos = output->length = 0;\n\t*posIncremented = 1;\n\tpre_src = 0;\n\t_lou_resetPassVariables();\n\tif (typebuf && table->emphRules[capsRule][letterOffset])\n\t\tfor (k = 0; k < input->length; k++)\n\t\t\tif (checkAttr(input->chars[k], CTC_UpperCase, 0, table))\n\t\t\t\ttypebuf[k] |= CAPSEMPH;\n\n\tmarkEmphases(table, input, typebuf, wordBuffer, emphasisBuffer, haveEmphasis);\n\n\twhile (pos < input->length) { /* the main translation loop */\n\t\tif ((pos >= compbrlStart) && (pos < compbrlEnd)) {\n\t\t\tint cs = 2;  // cursor status for this call\n\t\t\tif (!doCompTrans(pos, compbrlEnd, table, &pos, input, output, posMapping,\n\t\t\t\t\t\temphasisBuffer, &transRule, cursorPosition, &cs))\n\t\t\t\tgoto failure;\n\t\t\tcontinue;\n\t\t}\n\t\tTranslationTableCharacterAttributes beforeAttributes;\n\t\tsetBefore(table, pos, input, &beforeAttributes);\n\t\tif (!insertBrailleIndicators(0, table, pos, input, output, posMapping, typebuf,\n\t\t\t\t\thaveEmphasis, transOpcode, prevTransOpcode, cursorPosition,\n\t\t\t\t\tcursorStatus, beforeAttributes, &prevType, &curType, &prevTypeform,\n\t\t\t\t\tprevPos))\n\t\t\tgoto failure;\n\t\tif (pos >= input->length) break;\n\n\t\t// insertEmphases();\n\t\tif (!dontContract) dontContract = typebuf[pos] & no_contract;\n\t\tif (typebuf[pos] & no_translate) {\n\t\t\twidechar c = _lou_getDotsForChar(input->chars[pos]);\n\t\t\tif (input->chars[pos] < 32 || input->chars[pos] > 126) goto failure;\n\t\t\tif (!for_updatePositions(&c, 1, 1, 0, pos, input, output, posMapping,\n\t\t\t\t\t\tcursorPosition, cursorStatus))\n\t\t\t\tgoto failure;\n\t\t\tpos++;\n\t\t\t/* because we don't call insertEmphasis */\n\t\t\tpre_src = pos;\n\t\t\tcontinue;\n\t\t}\n\t\tfor_selectRule(table, pos, *output, mode, input, typebuf, emphasisBuffer,\n\t\t\t\t&transOpcode, prevTransOpcode, &transRule, &transCharslen, &passCharDots,\n\t\t\t\t&passInstructions, &passIC, &patternMatch, *posIncremented,\n\t\t\t\t*cursorPosition, &repwordStart, &repwordLength, dontContract,\n\t\t\t\tcompbrlStart, compbrlEnd, beforeAttributes, &curCharDef, &groupingRule,\n\t\t\t\t&groupingOp);\n\n\t\tif (transOpcode != CTO_Context)\n\t\t\tif (appliedRules != NULL && appliedRulesCount < maxAppliedRules)\n\t\t\t\tappliedRules[appliedRulesCount++] = transRule;\n\t\t*posIncremented = 1;\n\t\tprevPos = pos;\n\t\tswitch (transOpcode) /* Rules that pre-empt context and swap */\n\t\t{\n\t\tcase CTO_CompBrl:\n\t\tcase CTO_Literal:\n\t\t\tif (!doCompbrl(table, &pos, input, output, posMapping, emphasisBuffer,\n\t\t\t\t\t\t&transRule, cursorPosition, cursorStatus, destword, srcword))\n\t\t\t\tgoto failure;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (!insertBrailleIndicators(1, table, pos, input, output, posMapping, typebuf,\n\t\t\t\t\thaveEmphasis, transOpcode, prevTransOpcode, cursorPosition,\n\t\t\t\t\tcursorStatus, beforeAttributes, &prevType, &curType, &prevTypeform,\n\t\t\t\t\tprevPos))\n\t\t\tgoto failure;\n\n\t\t//\t\tif(transOpcode == CTO_Contraction)\n\t\t//\t\tif(brailleIndicatorDefined(table->noContractSign))\n\t\t//\t\tif(!for_updatePositions(\n\t\t//\t\t\t&indicRule->charsdots[0], 0, indicRule->dotslen, 0))\n\t\t//\t\t\tgoto failure;\n\t\tinsertEmphases(table, pos, input, output, posMapping, emphasisBuffer,\n\t\t\t\thaveEmphasis, transOpcode, cursorPosition, cursorStatus, &pre_src);\n\t\tif (table->usesNumericMode)\n\t\t\tcheckNumericMode(table, pos, input, output, posMapping, cursorPosition,\n\t\t\t\t\tcursorStatus, &dontContract, &numericMode);\n\n\t\tif (transOpcode == CTO_Context ||\n\t\t\t\tfindForPassRule(table, pos, currentPass, input, &transOpcode, &transRule,\n\t\t\t\t\t\t&transCharslen, &passCharDots, &passInstructions, &passIC,\n\t\t\t\t\t\t&patternMatch, &groupingRule, &groupingOp))\n\t\t\tswitch (transOpcode) {\n\t\t\tcase CTO_Context: {\n\t\t\t\tconst InString *inputBefore = input;\n\t\t\t\tint posBefore = pos;\n\t\t\t\tif (appliedRules != NULL && appliedRulesCount < maxAppliedRules)\n\t\t\t\t\tappliedRules[appliedRulesCount++] = transRule;\n\t\t\t\tif (!passDoAction(table, &input, output, posMapping, transOpcode,\n\t\t\t\t\t\t\t&transRule, passCharDots, passInstructions, passIC, &pos,\n\t\t\t\t\t\t\tpatternMatch, cursorPosition, cursorStatus, groupingRule,\n\t\t\t\t\t\t\tgroupingOp))\n\t\t\t\t\tgoto failure;\n\t\t\t\tif (input->bufferIndex != inputBefore->bufferIndex &&\n\t\t\t\t\t\tinputBefore->bufferIndex != origInput->bufferIndex)\n\t\t\t\t\treleaseStringBuffer(inputBefore->bufferIndex);\n\t\t\t\tif (pos == posBefore) *posIncremented = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t/* Processing before replacement */\n\n\t\t/* check if leaving no contraction (grade 1) mode */\n\t\tif (checkAttr(input->chars[pos], CTC_SeqDelimiter | CTC_Space, 0, table))\n\t\t\tdontContract = 0;\n\n\t\tswitch (transOpcode) {\n\t\tcase CTO_EndNum:\n\t\t\tif (table->letterSign && checkAttr(input->chars[pos], CTC_Letter, 0, table))\n\t\t\t\toutput->length--;\n\t\t\tbreak;\n\t\tcase CTO_Repeated:\n\t\tcase CTO_Space:\n\t\t\tdontContract = 0;\n\t\t\tbreak;\n\t\tcase CTO_LargeSign:\n\t\t\tif (prevTransOpcode == CTO_LargeSign) {\n\t\t\t\tint hasEndSegment = 0;\n\t\t\t\twhile (output->length > 0 && checkAttr(output->chars[output->length - 1],\n\t\t\t\t\t\t\t\t\t\t\t\t\t CTC_Space, 1, table)) {\n\t\t\t\t\tif (output->chars[output->length - 1] == ENDSEGMENT) {\n\t\t\t\t\t\thasEndSegment = 1;\n\t\t\t\t\t}\n\t\t\t\t\toutput->length--;\n\t\t\t\t}\n\t\t\t\tif (hasEndSegment != 0) {\n\t\t\t\t\toutput->chars[output->length] = 0xffff;\n\t\t\t\t\toutput->length++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CTO_DecPoint:\n\t\t\tif (!table->usesNumericMode && table->numberSign) {\n\t\t\t\tTranslationTableRule *numRule =\n\t\t\t\t\t\t(TranslationTableRule *)&table->ruleArea[table->numberSign];\n\t\t\t\tif (!for_updatePositions(&numRule->charsdots[numRule->charslen],\n\t\t\t\t\t\t\tnumRule->charslen, numRule->dotslen, 0, pos, input, output,\n\t\t\t\t\t\t\tposMapping, cursorPosition, cursorStatus))\n\t\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\ttransOpcode = CTO_MidNum;\n\t\t\tbreak;\n\t\tcase CTO_NoCont:\n\t\t\tif (!dontContract)\n\t\t\t\tdoNocont(table, &pos, output, mode, input, destword, srcword,\n\t\t\t\t\t\t&dontContract);\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tbreak;\n\t\t} /* end of action */\n\n\t\t/* replacement processing */\n\t\tswitch (transOpcode) {\n\t\tcase CTO_Replace:\n\t\t\tpos += transCharslen;\n\t\t\tif (!putCharacters(&transRule->charsdots[transCharslen], transRule->dotslen,\n\t\t\t\t\t\ttable, pos, input, output, posMapping, cursorPosition,\n\t\t\t\t\t\tcursorStatus))\n\t\t\t\tgoto failure;\n\t\t\tbreak;\n\t\tcase CTO_None:\n\t\t\tif (!undefinedCharacter(input->chars[pos], table, pos, input, output,\n\t\t\t\t\t\tposMapping, cursorPosition, cursorStatus))\n\t\t\t\tgoto failure;\n\t\t\tpos++;\n\t\t\tbreak;\n\t\tcase CTO_UpperCase:\n\t\t\t/* Only needs special handling if not within compbrl and\n\t\t\t * the table defines a capital sign. */\n\t\t\tif (!(mode & (compbrlAtCursor | compbrlLeftCursor)) &&\n\t\t\t\t\t(transRule->dotslen == 1 &&\n\t\t\t\t\t\t\ttable->emphRules[capsRule][letterOffset])) {\n\t\t\t\tif (!putCharacter(curCharDef->lowercase, table, pos, input, output,\n\t\t\t\t\t\t\tposMapping, cursorPosition, cursorStatus))\n\t\t\t\t\tgoto failure;\n\t\t\t\tpos++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t//\t\tcase CTO_Contraction:\n\t\t//\n\t\t//\t\t\tif(brailleIndicatorDefined(table->noContractSign))\n\t\t//\t\t\tif(!for_updatePositions(\n\t\t//\t\t\t\t&indicRule->charsdots[0], 0, indicRule->dotslen, 0))\n\t\t//\t\t\t\tgoto failure;\n\n\t\tdefault:\n\t\t\tif (transRule->dotslen) {\n\t\t\t\tif (!for_updatePositions(&transRule->charsdots[transCharslen],\n\t\t\t\t\t\t\ttransCharslen, transRule->dotslen, 0, pos, input, output,\n\t\t\t\t\t\t\tposMapping, cursorPosition, cursorStatus))\n\t\t\t\t\tgoto failure;\n\t\t\t\tpos += transCharslen;\n\t\t\t} else {\n\t\t\t\tfor (k = 0; k < transCharslen; k++) {\n\t\t\t\t\tif (!putCharacter(input->chars[pos], table, pos, input, output,\n\t\t\t\t\t\t\t\tposMapping, cursorPosition, cursorStatus))\n\t\t\t\t\t\tgoto failure;\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* processing after replacement */\n\t\tswitch (transOpcode) {\n\t\tcase CTO_Repeated: {\n\t\t\t/* Skip repeated characters. */\n\t\t\tint srclim = input->length - transCharslen;\n\t\t\tif (mode & (compbrlAtCursor | compbrlLeftCursor) && compbrlStart < srclim)\n\t\t\t\t/* Don't skip characters from compbrlStart onwards. */\n\t\t\t\tsrclim = compbrlStart - 1;\n\t\t\twhile ((pos <= srclim) &&\n\t\t\t\t\tcompareChars(&transRule->charsdots[0], &input->chars[pos],\n\t\t\t\t\t\t\ttransCharslen, 0, table)) {\n\t\t\t\t/* Map skipped input positions to the previous output position. */\n\t\t\t\t/* if (posMapping.outputPositions != NULL) { */\n\t\t\t\t/* \tint tcc; */\n\t\t\t\t/* \tfor (tcc = 0; tcc < transCharslen; tcc++) */\n\t\t\t\t/* \t\tposMapping.outputPositions[posMapping.prev[pos + tcc]] = */\n\t\t\t\t/* \t\t\t\toutput->length - 1; */\n\t\t\t\t/* } */\n\t\t\t\tif (!*cursorStatus && pos <= *cursorPosition &&\n\t\t\t\t\t\t*cursorPosition < pos + transCharslen) {\n\t\t\t\t\t*cursorStatus = 1;\n\t\t\t\t\t*cursorPosition = output->length - 1;\n\t\t\t\t}\n\t\t\t\tpos += transCharslen;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase CTO_RepWord: {\n\t\t\t/* Skip repeated characters. */\n\t\t\tint srclim = input->length - transCharslen;\n\t\t\tif (mode & (compbrlAtCursor | compbrlLeftCursor) && compbrlStart < srclim)\n\t\t\t\t/* Don't skip characters from compbrlStart onwards. */\n\t\t\t\tsrclim = compbrlStart - 1;\n\t\t\twhile ((pos <= srclim) && compareChars(repwordStart, &input->chars[pos],\n\t\t\t\t\t\t\t\t\t\t\t  repwordLength, 0, table)) {\n\t\t\t\t/* Map skipped input positions to the previous output position. */\n\t\t\t\t/* if (posMapping.outputPositions != NULL) { */\n\t\t\t\t/* \tint tcc; */\n\t\t\t\t/* \tfor (tcc = 0; tcc < transCharslen; tcc++) */\n\t\t\t\t/* \t\tposMapping.outputPositions[posMapping.prev[pos + tcc]] = */\n\t\t\t\t/* \t\t\t\toutput->length - 1; */\n\t\t\t\t/* } */\n\t\t\t\tif (!*cursorStatus && pos <= *cursorPosition &&\n\t\t\t\t\t\t*cursorPosition < pos + transCharslen) {\n\t\t\t\t\t*cursorStatus = 1;\n\t\t\t\t\t*cursorPosition = output->length - 1;\n\t\t\t\t}\n\t\t\t\tpos += repwordLength + transCharslen;\n\t\t\t}\n\t\t\tpos -= transCharslen;\n\t\t\tbreak;\n\t\t}\n\t\tcase CTO_JoinNum:\n\t\tcase CTO_JoinableWord:\n\t\t\twhile (pos < input->length &&\n\t\t\t\t\tcheckAttr(input->chars[pos], CTC_Space, 0, table) &&\n\t\t\t\t\tinput->chars[pos] != ENDSEGMENT)\n\t\t\t\tpos++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (((pos > 0) && checkAttr(input->chars[pos - 1], CTC_Space, 0, table) &&\n\t\t\t\t\t(transOpcode != CTO_JoinableWord))) {\n\t\t\tsrcword = pos;\n\t\t\tdestword = output->length;\n\t\t}\n\t\tif (srcSpacing != NULL && srcSpacing[pos] >= '0' && srcSpacing[pos] <= '9')\n\t\t\tdestSpacing[output->length] = srcSpacing[pos];\n\t\tif ((transOpcode >= CTO_Always && transOpcode <= CTO_None) ||\n\t\t\t\t(transOpcode >= CTO_Digit && transOpcode <= CTO_LitDigit))\n\t\t\tprevTransOpcode = transOpcode;\n\t}\n\n\ttransOpcode = CTO_Space;\n\tinsertEmphases(table, pos, input, output, posMapping, emphasisBuffer, haveEmphasis,\n\t\t\ttransOpcode, cursorPosition, cursorStatus, &pre_src);\n\nfailure:\n\tif (destword != 0 && pos < input->length &&\n\t\t\t!checkAttr(input->chars[pos], CTC_Space, 0, table)) {\n\t\tpos = srcword;\n\t\toutput->length = destword;\n\t}\n\tif (pos < input->length) {\n\t\twhile (checkAttr(input->chars[pos], CTC_Space, 0, table))\n\t\t\tif (++pos == input->length) break;\n\t}\n\t*realInlen = pos;\n\tif (input->bufferIndex != origInput->bufferIndex)\n\t\treleaseStringBuffer(input->bufferIndex);\n\treturn 1;\n} /* first pass translation completed */\n\nint EXPORT_CALL\nlou_hyphenate(const char *tableList, const widechar *inbuf, int inlen, char *hyphens,\n\t\tint mode) {\n#define HYPHSTRING 100\n\tconst TranslationTableHeader *table;\n\twidechar workingBuffer[HYPHSTRING];\n\tint k, kk;\n\tint wordStart;\n\tint wordEnd;\n\ttable = lou_getTable(tableList);\n\tif (table == NULL || inbuf == NULL || hyphens == NULL ||\n\t\t\ttable->hyphenStatesArray == 0 || inlen >= HYPHSTRING)\n\t\treturn 0;\n\tif (mode != 0) {\n\t\tk = inlen;\n\t\tkk = HYPHSTRING;\n\t\tif (!lou_backTranslate(tableList, inbuf, &k, &workingBuffer[0], &kk, NULL, NULL,\n\t\t\t\t\tNULL, NULL, NULL, 0))\n\t\t\treturn 0;\n\t} else {\n\t\tmemcpy(&workingBuffer[0], inbuf, CHARSIZE * inlen);\n\t\tkk = inlen;\n\t}\n\tfor (wordStart = 0; wordStart < kk; wordStart++)\n\t\tif (((findCharOrDots(workingBuffer[wordStart], 0, table))->attributes &\n\t\t\t\t\tCTC_Letter))\n\t\t\tbreak;\n\tif (wordStart == kk) return 0;\n\tfor (wordEnd = kk - 1; wordEnd >= 0; wordEnd--)\n\t\tif (((findCharOrDots(workingBuffer[wordEnd], 0, table))->attributes & CTC_Letter))\n\t\t\tbreak;\n\tfor (k = wordStart; k <= wordEnd; k++) {\n\t\tTranslationTableCharacter *c = findCharOrDots(workingBuffer[k], 0, table);\n\t\tif (!(c->attributes & CTC_Letter)) return 0;\n\t}\n\tif (!hyphenate(&workingBuffer[wordStart], wordEnd - wordStart + 1,\n\t\t\t\t&hyphens[wordStart], table))\n\t\treturn 0;\n\tfor (k = 0; k <= wordStart; k++) hyphens[k] = '0';\n\tif (mode != 0) {\n\t\twidechar workingBuffer2[HYPHSTRING];\n\t\tint outputPos[HYPHSTRING];\n\t\tchar hyphens2[HYPHSTRING];\n\t\tkk = wordEnd - wordStart + 1;\n\t\tk = HYPHSTRING;\n\t\tif (!lou_translate(tableList, &workingBuffer[wordStart], &kk, &workingBuffer2[0],\n\t\t\t\t\t&k, NULL, NULL, &outputPos[0], NULL, NULL, 0))\n\t\t\treturn 0;\n\t\tfor (kk = 0; kk < k; kk++) {\n\t\t\tint hyphPos = outputPos[kk];\n\t\t\tif (hyphPos > k || hyphPos < 0) break;\n\t\t\tif (hyphens[wordStart + kk] & 1)\n\t\t\t\thyphens2[hyphPos] = '1';\n\t\t\telse\n\t\t\t\thyphens2[hyphPos] = '0';\n\t\t}\n\t\tfor (kk = wordStart; kk < wordStart + k; kk++)\n\t\t\tif (hyphens2[kk] == '0') hyphens[kk] = hyphens2[kk];\n\t}\n\tfor (k = 0; k < inlen; k++)\n\t\tif (hyphens[k] & 1)\n\t\t\thyphens[k] = '1';\n\t\telse\n\t\t\thyphens[k] = '0';\n\thyphens[inlen] = 0;\n\treturn 1;\n}\n\nint EXPORT_CALL\nlou_dotsToChar(\n\t\tconst char *tableList, widechar *inbuf, widechar *outbuf, int length, int mode) {\n\tconst TranslationTableHeader *table;\n\tint k;\n\twidechar dots;\n\tif (tableList == NULL || inbuf == NULL || outbuf == NULL) return 0;\n\n\ttable = lou_getTable(tableList);\n\tif (table == NULL || length <= 0) return 0;\n\tfor (k = 0; k < length; k++) {\n\t\tdots = inbuf[k];\n\t\tif (!(dots & B16) && (dots & 0xff00) == 0x2800) /* Unicode braille */\n\t\t\tdots = (dots & 0x00ff) | B16;\n\t\toutbuf[k] = _lou_getCharFromDots(dots);\n\t}\n\treturn 1;\n}\n\nint EXPORT_CALL\nlou_charToDots(const char *tableList, const widechar *inbuf, widechar *outbuf, int length,\n\t\tint mode) {\n\tconst TranslationTableHeader *table;\n\tint k;\n\tif (tableList == NULL || inbuf == NULL || outbuf == NULL) return 0;\n\n\ttable = lou_getTable(tableList);\n\tif (table == NULL || length <= 0) return 0;\n\tfor (k = 0; k < length; k++)\n\t\tif ((mode & ucBrl))\n\t\t\toutbuf[k] = ((_lou_getDotsForChar(inbuf[k]) & 0xff) | 0x2800);\n\t\telse\n\t\t\toutbuf[k] = _lou_getDotsForChar(inbuf[k]);\n\treturn 1;\n}\n"], "fixing_code": ["/* liblouis Braille Translation and Back-Translation Library\n\n   Based on the Linux screenreader BRLTTY, copyright (C) 1999-2006 by The\n   BRLTTY Team\n\n   Copyright (C) 2004, 2005, 2006 ViewPlus Technologies, Inc. www.viewplus.com\n   Copyright (C) 2004, 2005, 2006 JJB Software, Inc. www.jjb-software.com\n   Copyright (C) 2016 Mike Gray, American Printing House for the Blind\n   Copyright (C) 2016 Davy Kager, Dedicon\n\n   This file is part of liblouis.\n\n   liblouis is free software: you can redistribute it and/or modify it\n   under the terms of the GNU Lesser General Public License as published\n   by the Free Software Foundation, either version 2.1 of the License, or\n   (at your option) any later version.\n\n   liblouis is distributed in the hope that it will be useful, but\n   WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with liblouis. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * @file\n * @brief Translate to braille\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"internal.h\"\n\n/* additional bits in typebuf */\n#define SYLLABLE_MARKER_1 0x2000\n#define SYLLABLE_MARKER_2 0x4000\n#define CAPSEMPH 0x8000\n\n#define EMPHASIS 0x3fff  // all typeform bits that can be used\n\n/* bits for wordBuffer */\n#define WORD_CHAR 0x00000001\n#define WORD_RESET 0x00000002\n#define WORD_STOP 0x00000004\n#define WORD_WHOLE 0x00000008\n\ntypedef struct {\n\tint size;\n\twidechar **buffers;\n\tint *inUse;\n\twidechar *(*alloc)(int index, int length);\n\tvoid (*free)(widechar *);\n} StringBufferPool;\n\nstatic widechar *\nallocStringBuffer(int index, int length) {\n\treturn _lou_allocMem(alloc_passbuf, index, 0, length);\n}\n\nstatic const StringBufferPool *stringBufferPool = NULL;\n\nstatic void\ninitStringBufferPool() {\n\tstatic widechar *stringBuffers[MAXPASSBUF] = { NULL };\n\tstatic int stringBuffersInUse[MAXPASSBUF] = { 0 };\n\tStringBufferPool *pool = malloc(sizeof(StringBufferPool));\n\tpool->size = MAXPASSBUF;\n\tpool->buffers = stringBuffers;\n\tpool->inUse = stringBuffersInUse;\n\tpool->alloc = &allocStringBuffer;\n\tpool->free = NULL;\n\tstringBufferPool = pool;\n}\n\nstatic int\ngetStringBuffer(int length) {\n\tint i;\n\tfor (i = 0; i < stringBufferPool->size; i++) {\n\t\tif (!stringBufferPool->inUse[i]) {\n\t\t\tstringBufferPool->buffers[i] = stringBufferPool->alloc(i, length);\n\t\t\tstringBufferPool->inUse[i] = 1;\n\t\t\treturn i;\n\t\t}\n\t}\n\t_lou_outOfMemory();\n\treturn -1;\n}\n\nstatic int\nreleaseStringBuffer(int idx) {\n\tif (idx >= 0 && idx < stringBufferPool->size) {\n\t\tint inUse = stringBufferPool->inUse[idx];\n\t\tif (inUse && stringBufferPool->free)\n\t\t\tstringBufferPool->free(stringBufferPool->buffers[idx]);\n\t\tstringBufferPool->inUse[idx] = 0;\n\t\treturn inUse;\n\t}\n\treturn 0;\n}\n\ntypedef struct {\n\tint bufferIndex;\n\tconst widechar *chars;\n\tint length;\n} InString;\n\ntypedef struct {\n\tint bufferIndex;\n\twidechar *chars;\n\tint maxlength;\n\tint length;\n} OutString;\n\ntypedef struct {\n\tint startMatch;\n\tint startReplace;\n\tint endReplace;\n\tint endMatch;\n} PassRuleMatch;\n\nstatic int\nputCharacter(widechar c, const TranslationTableHeader *table, int pos,\n\t\tconst InString *input, OutString *output, int *posMapping, int *cursorPosition,\n\t\tint *cursorStatus);\nstatic int\npassDoTest(const TranslationTableHeader *table, int pos, const InString *input,\n\t\tint transOpcode, const TranslationTableRule *transRule, int *passCharDots,\n\t\tconst widechar **passInstructions, int *passIC, PassRuleMatch *match,\n\t\tTranslationTableRule **groupingRule, widechar *groupingOp);\nstatic int\npassDoAction(const TranslationTableHeader *table, const InString **input,\n\t\tOutString *output, int *posMapping, int transOpcode,\n\t\tconst TranslationTableRule **transRule, int passCharDots,\n\t\tconst widechar *passInstructions, int passIC, int *pos, PassRuleMatch match,\n\t\tint *cursorPosition, int *cursorStatus, TranslationTableRule *groupingRule,\n\t\twidechar groupingOp);\n\nstatic const TranslationTableRule **appliedRules;\nstatic int maxAppliedRules;\nstatic int appliedRulesCount;\n\nstatic TranslationTableCharacter *\nfindCharOrDots(widechar c, int m, const TranslationTableHeader *table) {\n\t/* Look up character or dot pattern in the appropriate\n\t * table. */\n\tstatic TranslationTableCharacter noChar = { 0, 0, 0, CTC_Space, 32, 32, 32 };\n\tstatic TranslationTableCharacter noDots = { 0, 0, 0, CTC_Space, B16, B16, B16 };\n\tTranslationTableCharacter *notFound;\n\tTranslationTableCharacter *character;\n\tTranslationTableOffset bucket;\n\tunsigned long int makeHash = (unsigned long int)c % HASHNUM;\n\tif (m == 0) {\n\t\tbucket = table->characters[makeHash];\n\t\tnotFound = &noChar;\n\t} else {\n\t\tbucket = table->dots[makeHash];\n\t\tnotFound = &noDots;\n\t}\n\twhile (bucket) {\n\t\tcharacter = (TranslationTableCharacter *)&table->ruleArea[bucket];\n\t\tif (character->realchar == c) return character;\n\t\tbucket = character->next;\n\t}\n\tnotFound->realchar = notFound->uppercase = notFound->lowercase = c;\n\treturn notFound;\n}\n\nstatic int\ncheckAttr(const widechar c, const TranslationTableCharacterAttributes a, int m,\n\t\tconst TranslationTableHeader *table) {\n\tstatic widechar prevc = 0;\n\tstatic TranslationTableCharacterAttributes preva = 0;\n\tif (c != prevc) {\n\t\tpreva = (findCharOrDots(c, m, table))->attributes;\n\t\tprevc = c;\n\t}\n\treturn ((preva & a) ? 1 : 0);\n}\n\nstatic int\ncheckAttr_safe(const InString *input, int pos,\n\t\tconst TranslationTableCharacterAttributes a, int m,\n\t\tconst TranslationTableHeader *table) {\n\treturn ((pos < input->length) ? checkAttr(input->chars[pos], a, m, table) : 0);\n}\n\nstatic int\nfindForPassRule(const TranslationTableHeader *table, int pos, int currentPass,\n\t\tconst InString *input, int *transOpcode, const TranslationTableRule **transRule,\n\t\tint *transCharslen, int *passCharDots, widechar const **passInstructions,\n\t\tint *passIC, PassRuleMatch *match, TranslationTableRule **groupingRule,\n\t\twidechar *groupingOp) {\n\tint save_transCharslen = *transCharslen;\n\tconst TranslationTableRule *save_transRule = *transRule;\n\tTranslationTableOpcode save_transOpcode = *transOpcode;\n\tTranslationTableOffset ruleOffset;\n\truleOffset = table->forPassRules[currentPass];\n\t*transCharslen = 0;\n\twhile (ruleOffset) {\n\t\t*transRule = (TranslationTableRule *)&table->ruleArea[ruleOffset];\n\t\t*transOpcode = (*transRule)->opcode;\n\t\tif (passDoTest(table, pos, input, *transOpcode, *transRule, passCharDots,\n\t\t\t\t\tpassInstructions, passIC, match, groupingRule, groupingOp))\n\t\t\treturn 1;\n\t\truleOffset = (*transRule)->charsnext;\n\t}\n\t*transCharslen = save_transCharslen;\n\t*transRule = save_transRule;\n\t*transOpcode = save_transOpcode;\n\treturn 0;\n}\n\nstatic int\ncompareChars(const widechar *address1, const widechar *address2, int count, int m,\n\t\tconst TranslationTableHeader *table) {\n\tint k;\n\tif (!count) return 0;\n\tfor (k = 0; k < count; k++)\n\t\tif ((findCharOrDots(address1[k], m, table))->lowercase !=\n\t\t\t\t(findCharOrDots(address2[k], m, table))->lowercase)\n\t\t\treturn 0;\n\treturn 1;\n}\n\nstatic int\nmakeCorrections(const TranslationTableHeader *table, const InString *input,\n\t\tOutString *output, int *posMapping, formtype *typebuf, int *realInlen,\n\t\tint *posIncremented, int *cursorPosition, int *cursorStatus) {\n\tint pos;\n\tint transOpcode;\n\tconst TranslationTableRule *transRule;\n\tint transCharslen;\n\tint passCharDots;\n\tconst widechar *passInstructions;\n\tint passIC; /* Instruction counter */\n\tPassRuleMatch patternMatch;\n\tTranslationTableRule *groupingRule;\n\twidechar groupingOp;\n\tconst InString *origInput = input;\n\tif (!table->corrections) return 1;\n\tpos = 0;\n\toutput->length = 0;\n\t*posIncremented = 1;\n\t_lou_resetPassVariables();\n\twhile (pos < input->length) {\n\t\tint length = input->length - pos;\n\t\tconst TranslationTableCharacter *character =\n\t\t\t\tfindCharOrDots(input->chars[pos], 0, table);\n\t\tconst TranslationTableCharacter *character2;\n\t\tint tryThis = 0;\n\t\tif (!findForPassRule(table, pos, 0, input, &transOpcode, &transRule,\n\t\t\t\t\t&transCharslen, &passCharDots, &passInstructions, &passIC,\n\t\t\t\t\t&patternMatch, &groupingRule, &groupingOp))\n\t\t\twhile (tryThis < 3) {\n\t\t\t\tTranslationTableOffset ruleOffset = 0;\n\t\t\t\tunsigned long int makeHash = 0;\n\t\t\t\tswitch (tryThis) {\n\t\t\t\tcase 0:\n\t\t\t\t\tif (!(length >= 2)) break;\n\t\t\t\t\tmakeHash = (unsigned long int)character->lowercase << 8;\n\t\t\t\t\tcharacter2 = findCharOrDots(input->chars[pos + 1], 0, table);\n\t\t\t\t\tmakeHash += (unsigned long int)character2->lowercase;\n\t\t\t\t\tmakeHash %= HASHNUM;\n\t\t\t\t\truleOffset = table->forRules[makeHash];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tif (!(length >= 1)) break;\n\t\t\t\t\tlength = 1;\n\t\t\t\t\truleOffset = character->otherRules;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2: /* No rule found */\n\t\t\t\t\ttransOpcode = CTO_Always;\n\t\t\t\t\truleOffset = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twhile (ruleOffset) {\n\t\t\t\t\ttransRule = (TranslationTableRule *)&table->ruleArea[ruleOffset];\n\t\t\t\t\ttransOpcode = transRule->opcode;\n\t\t\t\t\ttransCharslen = transRule->charslen;\n\t\t\t\t\tif (tryThis == 1 || (transCharslen <= length &&\n\t\t\t\t\t\t\t\t\t\t\t\tcompareChars(&transRule->charsdots[0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t&input->chars[pos], transCharslen,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t0, table))) {\n\t\t\t\t\t\tif (*posIncremented && transOpcode == CTO_Correct &&\n\t\t\t\t\t\t\t\tpassDoTest(table, pos, input, transOpcode, transRule,\n\t\t\t\t\t\t\t\t\t\t&passCharDots, &passInstructions, &passIC,\n\t\t\t\t\t\t\t\t\t\t&patternMatch, &groupingRule, &groupingOp)) {\n\t\t\t\t\t\t\ttryThis = 4;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\truleOffset = transRule->charsnext;\n\t\t\t\t}\n\t\t\t\ttryThis++;\n\t\t\t}\n\t\t*posIncremented = 1;\n\n\t\tswitch (transOpcode) {\n\t\tcase CTO_Always:\n\t\t\tif (output->length >= output->maxlength) goto failure;\n\t\t\tposMapping[output->length] = pos;\n\t\t\toutput->chars[output->length++] = input->chars[pos++];\n\t\t\tbreak;\n\t\tcase CTO_Correct: {\n\t\t\tconst InString *inputBefore = input;\n\t\t\tint posBefore = pos;\n\t\t\tif (appliedRules != NULL && appliedRulesCount < maxAppliedRules)\n\t\t\t\tappliedRules[appliedRulesCount++] = transRule;\n\t\t\tif (!passDoAction(table, &input, output, posMapping, transOpcode, &transRule,\n\t\t\t\t\t\tpassCharDots, passInstructions, passIC, &pos, patternMatch,\n\t\t\t\t\t\tcursorPosition, cursorStatus, groupingRule, groupingOp))\n\t\t\t\tgoto failure;\n\t\t\tif (input->bufferIndex != inputBefore->bufferIndex &&\n\t\t\t\t\tinputBefore->bufferIndex != origInput->bufferIndex)\n\t\t\t\treleaseStringBuffer(inputBefore->bufferIndex);\n\t\t\tif (pos == posBefore) *posIncremented = 0;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t{  // We have to transform typebuf accordingly\n\t\tint k;\n\t\tformtype *typebuf_temp;\n\t\tif ((typebuf_temp = malloc(output->length * sizeof(formtype))) == NULL)\n\t\t\t_lou_outOfMemory();\n\t\tfor (k = 0; k < output->length; k++)\n\t\t\t// posMapping will never be < 0 but in theory it could\n\t\t\tif (posMapping[k] < 0)\n\t\t\t\ttypebuf_temp[k] = typebuf[0];  // prepend to next\n\t\t\telse if (posMapping[k] >= input->length)\n\t\t\t\ttypebuf_temp[k] = typebuf[input->length - 1];  // append to previous\n\t\t\telse\n\t\t\t\ttypebuf_temp[k] = typebuf[posMapping[k]];\n\t\tmemcpy(typebuf, typebuf_temp, output->length * sizeof(formtype));\n\t\tfree(typebuf_temp);\n\t}\n\nfailure:\n\t*realInlen = pos;\n\tif (input->bufferIndex != origInput->bufferIndex)\n\t\treleaseStringBuffer(input->bufferIndex);\n\treturn 1;\n}\n\nstatic int\nmatchCurrentInput(\n\t\tconst InString *input, int pos, const widechar *passInstructions, int passIC) {\n\tint k;\n\tint kk = pos;\n\tfor (k = passIC + 2;\n\t\t\t((k < passIC + 2 + passInstructions[passIC + 1]) && (kk < input->length));\n\t\t\tk++)\n\t\tif (input->chars[kk] == ENDSEGMENT || passInstructions[k] != input->chars[kk++])\n\t\t\treturn 0;\n\treturn 1;\n}\n\nstatic int\nswapTest(int swapIC, int *pos, const TranslationTableHeader *table, const InString *input,\n\t\tconst widechar *passInstructions) {\n\tint p = *pos;\n\tTranslationTableOffset swapRuleOffset;\n\tTranslationTableRule *swapRule;\n\tswapRuleOffset = (passInstructions[swapIC + 1] << 16) | passInstructions[swapIC + 2];\n\tswapRule = (TranslationTableRule *)&table->ruleArea[swapRuleOffset];\n\twhile (p - *pos < passInstructions[swapIC + 3]) {\n\t\tint test;\n\t\tif (swapRule->opcode == CTO_SwapDd) {\n\t\t\tfor (test = 1; test < swapRule->charslen; test += 2) {\n\t\t\t\tif (input->chars[p] == swapRule->charsdots[test]) break;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (test = 0; test < swapRule->charslen; test++) {\n\t\t\t\tif (input->chars[p] == swapRule->charsdots[test]) break;\n\t\t\t}\n\t\t}\n\t\tif (test >= swapRule->charslen) return 0;\n\t\tp++;\n\t}\n\tif (passInstructions[swapIC + 3] == passInstructions[swapIC + 4]) {\n\t\t*pos = p;\n\t\treturn 1;\n\t}\n\twhile (p - *pos < passInstructions[swapIC + 4]) {\n\t\tint test;\n\t\tif (swapRule->opcode == CTO_SwapDd) {\n\t\t\tfor (test = 1; test < swapRule->charslen; test += 2) {\n\t\t\t\tif (input->chars[p] == swapRule->charsdots[test]) break;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (test = 0; test < swapRule->charslen; test++) {\n\t\t\t\tif (input->chars[p] == swapRule->charsdots[test]) break;\n\t\t\t}\n\t\t}\n\t\tif (test >= swapRule->charslen) {\n\t\t\t*pos = p;\n\t\t\treturn 1;\n\t\t}\n\t\tp++;\n\t}\n\t*pos = p;\n\treturn 1;\n}\n\nstatic int\nswapReplace(int start, int end, const TranslationTableHeader *table,\n\t\tconst InString *input, OutString *output, int *posMapping,\n\t\tconst widechar *passInstructions, int passIC) {\n\tTranslationTableOffset swapRuleOffset;\n\tTranslationTableRule *swapRule;\n\twidechar *replacements;\n\tint p;\n\tswapRuleOffset = (passInstructions[passIC + 1] << 16) | passInstructions[passIC + 2];\n\tswapRule = (TranslationTableRule *)&table->ruleArea[swapRuleOffset];\n\treplacements = &swapRule->charsdots[swapRule->charslen];\n\tfor (p = start; p < end; p++) {\n\t\tint rep;\n\t\tint test;\n\t\tint k;\n\t\tif (swapRule->opcode == CTO_SwapDd) {\n\t\t\t// A sequence of dot patterns is encoded as the length of the first dot\n\t\t\t// pattern (single widechar) followed by the contents of the first dot pattern\n\t\t\t// (one widechar per cell) followed by the length of the second dot pattern,\n\t\t\t// etc. See the function `compileSwapDots'. Because the third operand of a\n\t\t\t// swapdd rule can only contain single-cell dot patterns, the elements at\n\t\t\t// index 0, 2, ... are \"1\" and the elements at index 1, 3, ... are the dot\n\t\t\t// patterns.\n\t\t\tfor (test = 0; test * 2 + 1 < swapRule->charslen; test++)\n\t\t\t\tif (input->chars[p] == swapRule->charsdots[test * 2 + 1]) break;\n\t\t\tif (test * 2 == swapRule->charslen) continue;\n\t\t} else {\n\t\t\tfor (test = 0; test < swapRule->charslen; test++)\n\t\t\t\tif (input->chars[p] == swapRule->charsdots[test]) break;\n\t\t\tif (test == swapRule->charslen) continue;\n\t\t}\n\t\tk = 0;\n\t\tfor (rep = 0; rep < test; rep++)\n\t\t\tif (swapRule->opcode == CTO_SwapCc)\n\t\t\t\tk++;\n\t\t\telse\n\t\t\t\tk += replacements[k];\n\t\tif (swapRule->opcode == CTO_SwapCc) {\n\t\t\tif ((output->length + 1) > output->maxlength) return 0;\n\t\t\tposMapping[output->length] = p;\n\t\t\toutput->chars[output->length++] = replacements[k];\n\t\t} else {\n\t\t\tint l = replacements[k] - 1;\n\t\t\tint d = output->length + l;\n\t\t\tif (d > output->maxlength) return 0;\n\t\t\twhile (--d >= output->length) posMapping[d] = p;\n\t\t\tmemcpy(&output->chars[output->length], &replacements[k + 1],\n\t\t\t\t\tl * sizeof(*output->chars));\n\t\t\toutput->length += l;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int\nreplaceGrouping(const TranslationTableHeader *table, const InString **input,\n\t\tOutString *output, int transOpcode, int passCharDots,\n\t\tconst widechar *passInstructions, int passIC, int startReplace,\n\t\tTranslationTableRule *groupingRule, widechar groupingOp) {\n\twidechar startCharDots = groupingRule->charsdots[2 * passCharDots];\n\twidechar endCharDots = groupingRule->charsdots[2 * passCharDots + 1];\n\tint p;\n\tint level = 0;\n\tTranslationTableOffset replaceOffset =\n\t\t\tpassInstructions[passIC + 1] << 16 | (passInstructions[passIC + 2] & 0xff);\n\tTranslationTableRule *replaceRule =\n\t\t\t(TranslationTableRule *)&table->ruleArea[replaceOffset];\n\twidechar replaceStart = replaceRule->charsdots[2 * passCharDots];\n\twidechar replaceEnd = replaceRule->charsdots[2 * passCharDots + 1];\n\tif (groupingOp == pass_groupstart) {\n\t\tfor (p = startReplace + 1; p < (*input)->length; p++) {\n\t\t\tif ((*input)->chars[p] == startCharDots) level--;\n\t\t\tif ((*input)->chars[p] == endCharDots) level++;\n\t\t\tif (level == 1) break;\n\t\t}\n\t\tif (p == (*input)->length)\n\t\t\treturn 0;\n\t\telse {\n\t\t\t// Create a new string instead of modifying it. This is slightly less\n\t\t\t// efficient, but makes the code more readable. Grouping is not a much used\n\t\t\t// feature anyway.\n\t\t\tint idx = getStringBuffer((*input)->length);\n\t\t\twidechar *chars = stringBufferPool->buffers[idx];\n\t\t\tmemcpy(chars, (*input)->chars, (*input)->length * sizeof(widechar));\n\t\t\tchars[startReplace] = replaceStart;\n\t\t\tchars[p] = replaceEnd;\n\t\t\t*input = &(InString){\n\t\t\t\t.chars = chars, .length = (*input)->length, .bufferIndex = idx\n\t\t\t};\n\t\t}\n\t} else {\n\t\tif (transOpcode == CTO_Context) {\n\t\t\tstartCharDots = groupingRule->charsdots[2];\n\t\t\tendCharDots = groupingRule->charsdots[3];\n\t\t\treplaceStart = replaceRule->charsdots[2];\n\t\t\treplaceEnd = replaceRule->charsdots[3];\n\t\t}\n\t\toutput->chars[output->length] = replaceEnd;\n\t\tfor (p = output->length - 1; p >= 0; p--) {\n\t\t\tif (output->chars[p] == endCharDots) level--;\n\t\t\tif (output->chars[p] == startCharDots) level++;\n\t\t\tif (level == 1) break;\n\t\t}\n\t\tif (p < 0) return 0;\n\t\toutput->chars[p] = replaceStart;\n\t\toutput->length++;\n\t}\n\treturn 1;\n}\n\nstatic int\nremoveGrouping(const InString **input, OutString *output, int passCharDots,\n\t\tint startReplace, TranslationTableRule *groupingRule, widechar groupingOp) {\n\twidechar startCharDots = groupingRule->charsdots[2 * passCharDots];\n\twidechar endCharDots = groupingRule->charsdots[2 * passCharDots + 1];\n\tint p;\n\tint level = 0;\n\tif (groupingOp == pass_groupstart) {\n\t\tfor (p = startReplace + 1; p < (*input)->length; p++) {\n\t\t\tif ((*input)->chars[p] == startCharDots) level--;\n\t\t\tif ((*input)->chars[p] == endCharDots) level++;\n\t\t\tif (level == 1) break;\n\t\t}\n\t\tif (p == (*input)->length)\n\t\t\treturn 0;\n\t\telse {\n\t\t\t// Create a new string instead of modifying it. This is slightly less\n\t\t\t// efficient, but makes the code more readable. Grouping is not a much used\n\t\t\t// feature anyway.\n\t\t\tint idx = getStringBuffer((*input)->length);\n\t\t\twidechar *chars = stringBufferPool->buffers[idx];\n\t\t\tint len = 0;\n\t\t\tint k;\n\t\t\tfor (k = 0; k < (*input)->length; k++) {\n\t\t\t\tif (k == p) continue;\n\t\t\t\tchars[len++] = (*input)->chars[k];\n\t\t\t}\n\t\t\t*input = &(InString){.chars = chars, .length = len, .bufferIndex = idx };\n\t\t}\n\t} else {\n\t\tfor (p = output->length - 1; p >= 0; p--) {\n\t\t\tif (output->chars[p] == endCharDots) level--;\n\t\t\tif (output->chars[p] == startCharDots) level++;\n\t\t\tif (level == 1) break;\n\t\t}\n\t\tif (p < 0) return 0;\n\t\tp++;\n\t\tfor (; p < output->length; p++) output->chars[p - 1] = output->chars[p];\n\t\toutput->length--;\n\t}\n\treturn 1;\n}\n\nstatic int\ndoPassSearch(const TranslationTableHeader *table, const InString *input,\n\t\tconst TranslationTableRule *transRule, int passCharDots, int pos,\n\t\tconst widechar *passInstructions, int passIC, int *searchIC, int *searchPos,\n\t\tTranslationTableRule *groupingRule, widechar groupingOp) {\n\tint level = 0;\n\tint k, kk;\n\tint not = 0;  // whether next operand should be reversed\n\tTranslationTableOffset ruleOffset;\n\tTranslationTableRule *rule;\n\tTranslationTableCharacterAttributes attributes;\n\twhile (pos < input->length) {\n\t\t*searchIC = passIC + 1;\n\t\t*searchPos = pos;\n\t\twhile (*searchIC < transRule->dotslen) {\n\t\t\tint itsTrue = 1;  // whether we have a match or not\n\t\t\tif (*searchPos > input->length) return 0;\n\t\t\tswitch (passInstructions[*searchIC]) {\n\t\t\tcase pass_lookback:\n\t\t\t\t*searchPos -= passInstructions[*searchIC + 1];\n\t\t\t\tif (*searchPos < 0) {\n\t\t\t\t\t*searchPos = 0;\n\t\t\t\t\titsTrue = 0;\n\t\t\t\t}\n\t\t\t\t*searchIC += 2;\n\t\t\t\tbreak;\n\t\t\tcase pass_not:\n\t\t\t\tnot = !not;\n\t\t\t\t(*searchIC)++;\n\t\t\t\tcontinue;\n\t\t\tcase pass_string:\n\t\t\tcase pass_dots:\n\t\t\t\tkk = *searchPos;\n\t\t\t\tfor (k = *searchIC + 2;\n\t\t\t\t\t\tk < *searchIC + 2 + passInstructions[*searchIC + 1]; k++)\n\t\t\t\t\tif (input->chars[kk] == ENDSEGMENT ||\n\t\t\t\t\t\t\tpassInstructions[k] != input->chars[kk++]) {\n\t\t\t\t\t\titsTrue = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t*searchPos += passInstructions[*searchIC + 1];\n\t\t\t\t*searchIC += passInstructions[*searchIC + 1] + 2;\n\t\t\t\tbreak;\n\t\t\tcase pass_startReplace:\n\t\t\t\t(*searchIC)++;\n\t\t\t\tbreak;\n\t\t\tcase pass_endReplace:\n\t\t\t\t(*searchIC)++;\n\t\t\t\tbreak;\n\t\t\tcase pass_attributes:\n\t\t\t\tattributes = (passInstructions[*searchIC + 1] << 16) |\n\t\t\t\t\t\tpassInstructions[*searchIC + 2];\n\t\t\t\tfor (k = 0; k < passInstructions[*searchIC + 3]; k++) {\n\t\t\t\t\tif (input->chars[*searchPos] == ENDSEGMENT)\n\t\t\t\t\t\titsTrue = 0;\n\t\t\t\t\telse {\n\t\t\t\t\t\titsTrue = ((findCharOrDots(input->chars[(*searchPos)++],\n\t\t\t\t\t\t\t\t\t\t\tpassCharDots,\n\t\t\t\t\t\t\t\t\t\t\ttable)->attributes &\n\t\t\t\t\t\t\t\t\t\t   attributes)\n\t\t\t\t\t\t\t\t\t\t? 1\n\t\t\t\t\t\t\t\t\t\t: 0);\n\t\t\t\t\t\tif (not) itsTrue = !itsTrue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!itsTrue) break;\n\t\t\t\t}\n\t\t\t\tif (itsTrue) {\n\t\t\t\t\tfor (k = passInstructions[*searchIC + 3];\n\t\t\t\t\t\t\tk < passInstructions[*searchIC + 4]; k++) {\n\t\t\t\t\t\tif (input->chars[*searchPos] == ENDSEGMENT) {\n\t\t\t\t\t\t\titsTrue = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!(findCharOrDots(input->chars[*searchPos], passCharDots,\n\t\t\t\t\t\t\t\t\t  table)->attributes &\n\t\t\t\t\t\t\t\t\tattributes)) {\n\t\t\t\t\t\t\tif (!not) break;\n\t\t\t\t\t\t} else if (not)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t(*searchPos)++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnot = 0;\n\t\t\t\t*searchIC += 5;\n\t\t\t\tbreak;\n\t\t\tcase pass_groupstart:\n\t\t\tcase pass_groupend:\n\t\t\t\truleOffset = (passInstructions[*searchIC + 1] << 16) |\n\t\t\t\t\t\tpassInstructions[*searchIC + 2];\n\t\t\t\trule = (TranslationTableRule *)&table->ruleArea[ruleOffset];\n\t\t\t\tif (passInstructions[*searchIC] == pass_groupstart)\n\t\t\t\t\titsTrue = (input->chars[*searchPos] ==\n\t\t\t\t\t\t\t\t\t  rule->charsdots[2 * passCharDots])\n\t\t\t\t\t\t\t? 1\n\t\t\t\t\t\t\t: 0;\n\t\t\t\telse\n\t\t\t\t\titsTrue = (input->chars[*searchPos] ==\n\t\t\t\t\t\t\t\t\t  rule->charsdots[2 * passCharDots + 1])\n\t\t\t\t\t\t\t? 1\n\t\t\t\t\t\t\t: 0;\n\t\t\t\tif (groupingRule != NULL && groupingOp == pass_groupstart &&\n\t\t\t\t\t\trule == groupingRule) {\n\t\t\t\t\tif (input->chars[*searchPos] == rule->charsdots[2 * passCharDots])\n\t\t\t\t\t\tlevel--;\n\t\t\t\t\telse if (input->chars[*searchPos] ==\n\t\t\t\t\t\t\trule->charsdots[2 * passCharDots + 1])\n\t\t\t\t\t\tlevel++;\n\t\t\t\t}\n\t\t\t\t(*searchPos)++;\n\t\t\t\t*searchIC += 3;\n\t\t\t\tbreak;\n\t\t\tcase pass_swap:\n\t\t\t\titsTrue = swapTest(*searchIC, searchPos, table, input, passInstructions);\n\t\t\t\t*searchIC += 5;\n\t\t\t\tbreak;\n\t\t\tcase pass_endTest:\n\t\t\t\tif (itsTrue) {\n\t\t\t\t\tif ((groupingRule && level == 1) || !groupingRule) return 1;\n\t\t\t\t}\n\t\t\t\t*searchIC = transRule->dotslen;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (_lou_handlePassVariableTest(passInstructions, searchIC, &itsTrue))\n\t\t\t\t\tbreak;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((!not&&!itsTrue) || (not&&itsTrue)) break;\n\t\t\tnot = 0;\n\t\t}\n\t\tpos++;\n\t}\n\treturn 0;\n}\n\nstatic int\npassDoTest(const TranslationTableHeader *table, int pos, const InString *input,\n\t\tint transOpcode, const TranslationTableRule *transRule, int *passCharDots,\n\t\twidechar const **passInstructions, int *passIC, PassRuleMatch *match,\n\t\tTranslationTableRule **groupingRule, widechar *groupingOp) {\n\tint searchIC, searchPos;\n\tint k;\n\tint not = 0;  // whether next operand should be reversed\n\tTranslationTableOffset ruleOffset = 0;\n\tTranslationTableRule *rule = NULL;\n\tTranslationTableCharacterAttributes attributes = 0;\n\tint startMatch = pos;\n\tint endMatch = pos;\n\tint startReplace = -1;\n\tint endReplace = -1;\n\t*groupingRule = NULL;\n\t*passInstructions = &transRule->charsdots[transRule->charslen];\n\t*passIC = 0;\n\tif (transOpcode == CTO_Context || transOpcode == CTO_Correct)\n\t\t*passCharDots = 0;\n\telse\n\t\t*passCharDots = 1;\n\twhile (*passIC < transRule->dotslen) {\n\t\tint itsTrue = 1;  // whether we have a match or not\n\t\tif (pos > input->length) return 0;\n\t\tswitch ((*passInstructions)[*passIC]) {\n\t\tcase pass_first:\n\t\t\tif (pos != 0) itsTrue = 0;\n\t\t\t(*passIC)++;\n\t\t\tbreak;\n\t\tcase pass_last:\n\t\t\tif (pos != input->length) itsTrue = 0;\n\t\t\t(*passIC)++;\n\t\t\tbreak;\n\t\tcase pass_lookback:\n\t\t\tpos -= (*passInstructions)[*passIC + 1];\n\t\t\tif (pos < 0) {\n\t\t\t\tsearchPos = 0;\n\t\t\t\titsTrue = 0;\n\t\t\t}\n\t\t\t*passIC += 2;\n\t\t\tbreak;\n\t\tcase pass_not:\n\t\t\tnot = !not;\n\t\t\t(*passIC)++;\n\t\t\tcontinue;\n\t\tcase pass_string:\n\t\tcase pass_dots:\n\t\t\titsTrue = matchCurrentInput(input, pos, *passInstructions, *passIC);\n\t\t\tpos += (*passInstructions)[*passIC + 1];\n\t\t\t*passIC += (*passInstructions)[*passIC + 1] + 2;\n\t\t\tbreak;\n\t\tcase pass_startReplace:\n\t\t\tstartReplace = pos;\n\t\t\t(*passIC)++;\n\t\t\tbreak;\n\t\tcase pass_endReplace:\n\t\t\tendReplace = pos;\n\t\t\t(*passIC)++;\n\t\t\tbreak;\n\t\tcase pass_attributes:\n\t\t\tattributes = ((*passInstructions)[*passIC + 1] << 16) |\n\t\t\t\t\t(*passInstructions)[*passIC + 2];\n\t\t\tfor (k = 0; k < (*passInstructions)[*passIC + 3]; k++) {\n\t\t\t\tif (pos >= input->length) {\n\t\t\t\t\titsTrue = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (input->chars[pos] == ENDSEGMENT) {\n\t\t\t\t\titsTrue = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!(findCharOrDots(input->chars[pos], *passCharDots,\n\t\t\t\t\t\t\t  table)->attributes &\n\t\t\t\t\t\t\tattributes)) {\n\t\t\t\t\tif (!not) {\n\t\t\t\t\t\titsTrue = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (not) {\n\t\t\t\t\titsTrue = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tif (itsTrue) {\n\t\t\t\tfor (k = (*passInstructions)[*passIC + 3];\n\t\t\t\t\t\tk < (*passInstructions)[*passIC + 4] && pos < input->length;\n\t\t\t\t\t\tk++) {\n\t\t\t\t\tif (input->chars[pos] == ENDSEGMENT) {\n\t\t\t\t\t\titsTrue = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (!(findCharOrDots(input->chars[pos], *passCharDots,\n\t\t\t\t\t\t\t\t  table)->attributes &\n\t\t\t\t\t\t\t\tattributes)) {\n\t\t\t\t\t\tif (!not) break;\n\t\t\t\t\t} else if (not)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnot = 0;\n\t\t\t*passIC += 5;\n\t\t\tbreak;\n\t\tcase pass_groupstart:\n\t\tcase pass_groupend:\n\t\t\truleOffset = ((*passInstructions)[*passIC + 1] << 16) |\n\t\t\t\t\t(*passInstructions)[*passIC + 2];\n\t\t\trule = (TranslationTableRule *)&table->ruleArea[ruleOffset];\n\t\t\tif (*passIC == 0 ||\n\t\t\t\t\t(*passIC > 0 &&\n\t\t\t\t\t\t\t(*passInstructions)[*passIC - 1] == pass_startReplace)) {\n\t\t\t\t*groupingRule = rule;\n\t\t\t\t*groupingOp = (*passInstructions)[*passIC];\n\t\t\t}\n\t\t\tif ((*passInstructions)[*passIC] == pass_groupstart)\n\t\t\t\titsTrue =\n\t\t\t\t\t\t(input->chars[pos] == rule->charsdots[2 * *passCharDots]) ? 1 : 0;\n\t\t\telse\n\t\t\t\titsTrue = (input->chars[pos] == rule->charsdots[2 * *passCharDots + 1])\n\t\t\t\t\t\t? 1\n\t\t\t\t\t\t: 0;\n\t\t\tpos++;\n\t\t\t*passIC += 3;\n\t\t\tbreak;\n\t\tcase pass_swap:\n\t\t\titsTrue = swapTest(*passIC, &pos, table, input, *passInstructions);\n\t\t\t*passIC += 5;\n\t\t\tbreak;\n\t\tcase pass_search:\n\t\t\titsTrue = doPassSearch(table, input, transRule, *passCharDots, pos,\n\t\t\t\t\t*passInstructions, *passIC, &searchIC, &searchPos, *groupingRule,\n\t\t\t\t\t*groupingOp);\n\t\t\tif ((!not&&!itsTrue) || (not&&itsTrue)) return 0;\n\t\t\t*passIC = searchIC;\n\t\t\tpos = searchPos;\n\t\tcase pass_endTest:\n\t\t\t(*passIC)++;\n\t\t\tendMatch = pos;\n\t\t\tif (startReplace == -1) {\n\t\t\t\tstartReplace = startMatch;\n\t\t\t\tendReplace = endMatch;\n\t\t\t}\n\t\t\t*match = (PassRuleMatch){.startMatch = startMatch,\n\t\t\t\t.startReplace = startReplace,\n\t\t\t\t.endReplace = endReplace,\n\t\t\t\t.endMatch = endMatch };\n\t\t\treturn 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (_lou_handlePassVariableTest(*passInstructions, passIC, &itsTrue)) break;\n\t\t\treturn 0;\n\t\t}\n\t\tif ((!not&&!itsTrue) || (not&&itsTrue)) return 0;\n\t\tnot = 0;\n\t}\n\treturn 0;\n}\n\nstatic int\ncopyCharacters(int from, int to, const TranslationTableHeader *table,\n\t\tconst InString *input, OutString *output, int *posMapping, int transOpcode,\n\t\tint *cursorPosition, int *cursorStatus) {\n\tif (transOpcode == CTO_Context) {\n\t\twhile (from < to) {\n\t\t\tif (!putCharacter(input->chars[from], table, from, input, output, posMapping,\n\t\t\t\t\t\tcursorPosition, cursorStatus))\n\t\t\t\treturn 0;\n\t\t\tfrom++;\n\t\t}\n\t} else {\n\t\tif (to > from) {\n\t\t\tif ((output->length + to - from) > output->maxlength) return 0;\n\t\t\twhile (to > from) {\n\t\t\t\tposMapping[output->length] = from;\n\t\t\t\toutput->chars[output->length] = input->chars[from];\n\t\t\t\toutput->length++;\n\t\t\t\tfrom++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic int\npassDoAction(const TranslationTableHeader *table, const InString **input,\n\t\tOutString *output, int *posMapping, int transOpcode,\n\t\tconst TranslationTableRule **transRule, int passCharDots,\n\t\tconst widechar *passInstructions, int passIC, int *pos, PassRuleMatch match,\n\t\tint *cursorPosition, int *cursorStatus, TranslationTableRule *groupingRule,\n\t\twidechar groupingOp) {\n\tint k;\n\tTranslationTableOffset ruleOffset = 0;\n\tTranslationTableRule *rule = NULL;\n\tint destStartMatch = output->length;\n\tint destStartReplace;\n\tint newPos = match.endReplace;\n\n\tif (!copyCharacters(match.startMatch, match.startReplace, table, *input, output,\n\t\t\t\tposMapping, transOpcode, cursorPosition, cursorStatus))\n\t\treturn 0;\n\tdestStartReplace = output->length;\n\n\twhile (passIC < (*transRule)->dotslen) switch (passInstructions[passIC]) {\n\t\tcase pass_string:\n\t\tcase pass_dots:\n\t\t\tif ((output->length + passInstructions[passIC + 1]) > output->maxlength)\n\t\t\t\treturn 0;\n\t\t\tfor (k = 0; k < passInstructions[passIC + 1]; ++k)\n\t\t\t\tposMapping[output->length + k] = match.startReplace;\n\t\t\tmemcpy(&output->chars[output->length], &passInstructions[passIC + 2],\n\t\t\t\t\tpassInstructions[passIC + 1] * CHARSIZE);\n\t\t\toutput->length += passInstructions[passIC + 1];\n\t\t\tpassIC += passInstructions[passIC + 1] + 2;\n\t\t\tbreak;\n\t\tcase pass_groupstart:\n\t\t\truleOffset =\n\t\t\t\t\t(passInstructions[passIC + 1] << 16) | passInstructions[passIC + 2];\n\t\t\trule = (TranslationTableRule *)&table->ruleArea[ruleOffset];\n\t\t\tposMapping[output->length] = match.startMatch;\n\t\t\toutput->chars[output->length++] = rule->charsdots[2 * passCharDots];\n\t\t\tpassIC += 3;\n\t\t\tbreak;\n\t\tcase pass_groupend:\n\t\t\truleOffset =\n\t\t\t\t\t(passInstructions[passIC + 1] << 16) | passInstructions[passIC + 2];\n\t\t\trule = (TranslationTableRule *)&table->ruleArea[ruleOffset];\n\t\t\tposMapping[output->length] = match.startMatch;\n\t\t\toutput->chars[output->length++] = rule->charsdots[2 * passCharDots + 1];\n\t\t\tpassIC += 3;\n\t\t\tbreak;\n\t\tcase pass_swap:\n\t\t\tif (!swapReplace(match.startReplace, match.endReplace, table, *input, output,\n\t\t\t\t\t\tposMapping, passInstructions, passIC))\n\t\t\t\treturn 0;\n\t\t\tpassIC += 3;\n\t\t\tbreak;\n\t\tcase pass_groupreplace:\n\t\t\tif (!groupingRule ||\n\t\t\t\t\t!replaceGrouping(table, input, output, transOpcode, passCharDots,\n\t\t\t\t\t\t\tpassInstructions, passIC, match.startReplace, groupingRule,\n\t\t\t\t\t\t\tgroupingOp))\n\t\t\t\treturn 0;\n\t\t\tpassIC += 3;\n\t\t\tbreak;\n\t\tcase pass_omit:\n\t\t\tif (groupingRule)\n\t\t\t\tremoveGrouping(input, output, passCharDots, match.startReplace,\n\t\t\t\t\t\tgroupingRule, groupingOp);\n\t\t\tpassIC++;\n\t\t\tbreak;\n\t\tcase pass_copy: {\n\t\t\tint count = destStartReplace - destStartMatch;\n\t\t\tif (count > 0) {\n\t\t\t\tmemmove(&output->chars[destStartMatch], &output->chars[destStartReplace],\n\t\t\t\t\t\tcount * sizeof(*output->chars));\n\t\t\t\toutput->length -= count;\n\t\t\t\tdestStartReplace = destStartMatch;\n\t\t\t}\n\t\t}\n\n\t\t\tif (!copyCharacters(match.startReplace, match.endReplace, table, *input,\n\t\t\t\t\t\toutput, posMapping, transOpcode, cursorPosition, cursorStatus))\n\t\t\t\treturn 0;\n\t\t\tnewPos = match.endMatch;\n\t\t\tpassIC++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (_lou_handlePassVariableAction(passInstructions, &passIC)) break;\n\t\t\treturn 0;\n\t\t}\n\t*pos = newPos;\n\treturn 1;\n}\n\nstatic void\npassSelectRule(const TranslationTableHeader *table, int pos, int currentPass,\n\t\tconst InString *input, int *transOpcode, const TranslationTableRule **transRule,\n\t\tint *transCharslen, int *passCharDots, widechar const **passInstructions,\n\t\tint *passIC, PassRuleMatch *match, TranslationTableRule **groupingRule,\n\t\twidechar *groupingOp) {\n\tif (!findForPassRule(table, pos, currentPass, input, transOpcode, transRule,\n\t\t\t\ttransCharslen, passCharDots, passInstructions, passIC, match,\n\t\t\t\tgroupingRule, groupingOp)) {\n\t\t*transOpcode = CTO_Always;\n\t}\n}\n\nstatic int\ntranslatePass(const TranslationTableHeader *table, int currentPass, const InString *input,\n\t\tOutString *output, int *posMapping, int *realInlen, int *posIncremented,\n\t\tint *cursorPosition, int *cursorStatus) {\n\tint pos;\n\tint transOpcode;\n\tconst TranslationTableRule *transRule;\n\tint transCharslen;\n\tint passCharDots;\n\tconst widechar *passInstructions;\n\tint passIC; /* Instruction counter */\n\tPassRuleMatch patternMatch;\n\tTranslationTableRule *groupingRule;\n\twidechar groupingOp;\n\tconst InString *origInput = input;\n\tpos = output->length = 0;\n\t*posIncremented = 1;\n\t_lou_resetPassVariables();\n\twhile (pos < input->length) { /* the main multipass translation loop */\n\t\tpassSelectRule(table, pos, currentPass, input, &transOpcode, &transRule,\n\t\t\t\t&transCharslen, &passCharDots, &passInstructions, &passIC, &patternMatch,\n\t\t\t\t&groupingRule, &groupingOp);\n\t\t*posIncremented = 1;\n\t\tswitch (transOpcode) {\n\t\tcase CTO_Context:\n\t\tcase CTO_Pass2:\n\t\tcase CTO_Pass3:\n\t\tcase CTO_Pass4: {\n\t\t\tconst InString *inputBefore = input;\n\t\t\tint posBefore = pos;\n\t\t\tif (appliedRules != NULL && appliedRulesCount < maxAppliedRules)\n\t\t\t\tappliedRules[appliedRulesCount++] = transRule;\n\t\t\tif (!passDoAction(table, &input, output, posMapping, transOpcode, &transRule,\n\t\t\t\t\t\tpassCharDots, passInstructions, passIC, &pos, patternMatch,\n\t\t\t\t\t\tcursorPosition, cursorStatus, groupingRule, groupingOp))\n\t\t\t\tgoto failure;\n\t\t\tif (input->bufferIndex != inputBefore->bufferIndex &&\n\t\t\t\t\tinputBefore->bufferIndex != origInput->bufferIndex)\n\t\t\t\treleaseStringBuffer(inputBefore->bufferIndex);\n\t\t\tif (pos == posBefore) *posIncremented = 0;\n\t\t\tbreak;\n\t\t}\n\t\tcase CTO_Always:\n\t\t\tif ((output->length + 1) > output->maxlength) goto failure;\n\t\t\tposMapping[output->length] = pos;\n\t\t\toutput->chars[output->length++] = input->chars[pos++];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto failure;\n\t\t}\n\t}\nfailure:\n\tif (pos < input->length) {\n\t\twhile (checkAttr(input->chars[pos], CTC_Space, 1, table))\n\t\t\tif (++pos == input->length) break;\n\t}\n\t*realInlen = pos;\n\tif (input->bufferIndex != origInput->bufferIndex)\n\t\treleaseStringBuffer(input->bufferIndex);\n\treturn 1;\n}\n\n#define MIN(a, b) (((a) < (b)) ? (a) : (b))\n\nstatic int\ntranslateString(const TranslationTableHeader *table, int mode, int currentPass,\n\t\tconst InString *input, OutString *output, int *posMapping, formtype *typebuf,\n\t\tunsigned char *srcSpacing, unsigned char *destSpacing, unsigned int *wordBuffer,\n\t\tEmphasisInfo *emphasisBuffer, int haveEmphasis, int *realInlen,\n\t\tint *posIncremented, int *cursorPosition, int *cursorStatus, int compbrlStart,\n\t\tint compbrlEnd);\n\nint EXPORT_CALL\nlou_translateString(const char *tableList, const widechar *inbufx, int *inlen,\n\t\twidechar *outbuf, int *outlen, formtype *typeform, char *spacing, int mode) {\n\treturn lou_translate(tableList, inbufx, inlen, outbuf, outlen, typeform, spacing,\n\t\t\tNULL, NULL, NULL, mode);\n}\n\nint EXPORT_CALL\nlou_translate(const char *tableList, const widechar *inbufx, int *inlen, widechar *outbuf,\n\t\tint *outlen, formtype *typeform, char *spacing, int *outputPos, int *inputPos,\n\t\tint *cursorPos, int mode) {\n\treturn _lou_translateWithTracing(tableList, inbufx, inlen, outbuf, outlen, typeform,\n\t\t\tspacing, outputPos, inputPos, cursorPos, mode, NULL, NULL);\n}\n\nint EXPORT_CALL\n_lou_translateWithTracing(const char *tableList, const widechar *inbufx, int *inlen,\n\t\twidechar *outbuf, int *outlen, formtype *typeform, char *spacing, int *outputPos,\n\t\tint *inputPos, int *cursorPos, int mode, const TranslationTableRule **rules,\n\t\tint *rulesLen) {\n\t// int i;\n\t// for(i = 0; i < *inlen; i++)\n\t// {\n\t// \toutbuf[i] = inbufx[i];\n\t// \tif(inputPos)\n\t// \t\tinputPos[i] = i;\n\t// \tif(outputPos)\n\t// \t\toutputPos[i] = i;\n\t// }\n\t// *inlen = i;\n\t// *outlen = i;\n\t// return 1;\n\tconst TranslationTableHeader *table;\n\tconst InString *input;\n\tOutString output;\n\t// posMapping contains position mapping info between the initial input and the output\n\t// of the current pass. It is 1 longer than the output. The values are monotonically\n\t// increasing and can range between -1 and the input length. At the end the position\n\t// info is passed to the user as an inputPos and outputPos array. inputPos has the\n\t// length of the final output and has values ranging from 0 to inlen-1. outputPos has\n\t// the length of the initial input and has values ranging from 0 to outlen-1.\n\tint *posMapping;\n\tint *posMapping1;\n\tint *posMapping2;\n\tint *posMapping3;\n\tformtype *typebuf;\n\tunsigned char *srcSpacing;\n\tunsigned char *destSpacing;\n\tunsigned int *wordBuffer;\n\tEmphasisInfo *emphasisBuffer;\n\tint cursorPosition;\n\tint cursorStatus;\n\tint haveEmphasis;\n\tint compbrlStart = -1;\n\tint compbrlEnd = -1;\n\tint k;\n\tint goodTrans = 1;\n\tint posIncremented;\n\tif (tableList == NULL || inbufx == NULL || inlen == NULL || outbuf == NULL ||\n\t\t\toutlen == NULL)\n\t\treturn 0;\n\t_lou_logMessage(\n\t\t\tLOG_ALL, \"Performing translation: tableList=%s, inlen=%d\", tableList, *inlen);\n\t_lou_logWidecharBuf(LOG_ALL, \"Inbuf=\", inbufx, *inlen);\n\n\tif (mode & pass1Only) {\n\t\t_lou_logMessage(LOG_WARN, \"warning: pass1Only mode is no longer supported.\");\n\t}\n\n\ttable = lou_getTable(tableList);\n\tif (table == NULL || *inlen < 0 || *outlen < 0) return 0;\n\tk = 0;\n\twhile (k < *inlen && inbufx[k]) k++;\n\tinput = &(InString){.chars = inbufx, .length = k, .bufferIndex = -1 };\n\thaveEmphasis = 0;\n\tif (!(typebuf = _lou_allocMem(alloc_typebuf, 0, input->length, *outlen))) return 0;\n\tif (typeform != NULL) {\n\t\tfor (k = 0; k < input->length; k++) {\n\t\t\ttypebuf[k] = typeform[k];\n\t\t\tif (typebuf[k] & EMPHASIS) haveEmphasis = 1;\n\t\t}\n\t} else\n\t\tmemset(typebuf, 0, input->length * sizeof(formtype));\n\n\tif ((wordBuffer = _lou_allocMem(alloc_wordBuffer, 0, input->length, *outlen)))\n\t\tmemset(wordBuffer, 0, (input->length + 4) * sizeof(unsigned int));\n\telse\n\t\treturn 0;\n\tif ((emphasisBuffer = _lou_allocMem(alloc_emphasisBuffer, 0, input->length, *outlen)))\n\t\tmemset(emphasisBuffer, 0, (input->length + 4) * sizeof(EmphasisInfo));\n\telse\n\t\treturn 0;\n\n\tif (!(spacing == NULL || *spacing == 'X'))\n\t\tsrcSpacing = (unsigned char *)spacing;\n\telse\n\t\tsrcSpacing = NULL;\n\tif (outputPos != NULL)\n\t\tfor (k = 0; k < input->length; k++) outputPos[k] = -1;\n\tif (cursorPos != NULL && *cursorPos >= 0) {\n\t\tcursorStatus = 0;\n\t\tcursorPosition = *cursorPos;\n\t\tif ((mode & (compbrlAtCursor | compbrlLeftCursor))) {\n\t\t\tcompbrlStart = cursorPosition;\n\t\t\tif (checkAttr(input->chars[compbrlStart], CTC_Space, 0, table))\n\t\t\t\tcompbrlEnd = compbrlStart + 1;\n\t\t\telse {\n\t\t\t\twhile (compbrlStart >= 0 &&\n\t\t\t\t\t\t!checkAttr(input->chars[compbrlStart], CTC_Space, 0, table))\n\t\t\t\t\tcompbrlStart--;\n\t\t\t\tcompbrlStart++;\n\t\t\t\tcompbrlEnd = cursorPosition;\n\t\t\t\tif (!(mode & compbrlLeftCursor))\n\t\t\t\t\twhile (compbrlEnd < input->length &&\n\t\t\t\t\t\t\t!checkAttr(input->chars[compbrlEnd], CTC_Space, 0, table))\n\t\t\t\t\t\tcompbrlEnd++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcursorPosition = -1;\n\t\tcursorStatus = 1; /* so it won't check cursor position */\n\t}\n\tif (!(posMapping1 = _lou_allocMem(alloc_posMapping1, 0, input->length, *outlen)))\n\t\treturn 0;\n\tif (table->numPasses > 1 || table->corrections) {\n\t\tif (!(posMapping2 = _lou_allocMem(alloc_posMapping2, 0, input->length, *outlen)))\n\t\t\treturn 0;\n\t\tif (!(posMapping3 = _lou_allocMem(alloc_posMapping3, 0, input->length, *outlen)))\n\t\t\treturn 0;\n\t}\n\tif (srcSpacing != NULL) {\n\t\tif (!(destSpacing = _lou_allocMem(alloc_destSpacing, 0, input->length, *outlen)))\n\t\t\tgoodTrans = 0;\n\t\telse\n\t\t\tmemset(destSpacing, '*', *outlen);\n\t} else\n\t\tdestSpacing = NULL;\n\tappliedRulesCount = 0;\n\tif (rules != NULL && rulesLen != NULL) {\n\t\tappliedRules = rules;\n\t\tmaxAppliedRules = *rulesLen;\n\t} else {\n\t\tappliedRules = NULL;\n\t\tmaxAppliedRules = 0;\n\t}\n\t{\n\t\tint idx;\n\t\tif (!stringBufferPool) initStringBufferPool();\n\t\tfor (idx = 0; idx < stringBufferPool->size; idx++) releaseStringBuffer(idx);\n\t\tidx = getStringBuffer(*outlen);\n\t\toutput = (OutString){.chars = stringBufferPool->buffers[idx],\n\t\t\t.maxlength = *outlen,\n\t\t\t.length = 0,\n\t\t\t.bufferIndex = idx };\n\t}\n\tposMapping = posMapping1;\n\n\tint currentPass = table->corrections ? 0 : 1;\n\tint *passPosMapping = posMapping;\n\twhile (1) {\n\t\tint realInlen;\n\t\tswitch (currentPass) {\n\t\tcase 0:\n\t\t\tgoodTrans = makeCorrections(table, input, &output, passPosMapping, typebuf,\n\t\t\t\t\t&realInlen, &posIncremented, &cursorPosition, &cursorStatus);\n\t\t\tbreak;\n\t\tcase 1: {\n\t\t\tgoodTrans = translateString(table, mode, currentPass, input, &output,\n\t\t\t\t\tpassPosMapping, typebuf, srcSpacing, destSpacing, wordBuffer,\n\t\t\t\t\temphasisBuffer, haveEmphasis, &realInlen, &posIncremented,\n\t\t\t\t\t&cursorPosition, &cursorStatus, compbrlStart, compbrlEnd);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tgoodTrans = translatePass(table, currentPass, input, &output, passPosMapping,\n\t\t\t\t\t&realInlen, &posIncremented, &cursorPosition, &cursorStatus);\n\t\t\tbreak;\n\t\t}\n\t\tpassPosMapping[output.length] = realInlen;\n\t\tif (passPosMapping == posMapping) {\n\t\t\tpassPosMapping = posMapping2;\n\t\t} else {\n\t\t\tint *prevPosMapping = posMapping3;\n\t\t\tmemcpy((int *)prevPosMapping, posMapping, (*outlen + 1) * sizeof(int));\n\t\t\tfor (k = 0; k <= output.length; k++)\n\t\t\t\tif (passPosMapping[k] < 0)\n\t\t\t\t\tposMapping[k] = prevPosMapping[0];\n\t\t\t\telse\n\t\t\t\t\tposMapping[k] = prevPosMapping[passPosMapping[k]];\n\t\t}\n\t\tcurrentPass++;\n\t\tif (currentPass <= table->numPasses && goodTrans) {\n\t\t\tint idx;\n\t\t\treleaseStringBuffer(input->bufferIndex);\n\t\t\tinput = &(InString){.chars = output.chars,\n\t\t\t\t.length = output.length,\n\t\t\t\t.bufferIndex = output.bufferIndex };\n\t\t\tidx = getStringBuffer(*outlen);\n\t\t\toutput = (OutString){.chars = stringBufferPool->buffers[idx],\n\t\t\t\t.maxlength = *outlen,\n\t\t\t\t.length = 0,\n\t\t\t\t.bufferIndex = idx };\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tif (goodTrans) {\n\t\tfor (k = 0; k < output.length; k++) {\n\t\t\tif (typeform != NULL) {\n\t\t\t\tif ((output.chars[k] & (B7 | B8)))\n\t\t\t\t\ttypeform[k] = '8';\n\t\t\t\telse\n\t\t\t\t\ttypeform[k] = '0';\n\t\t\t}\n\t\t\tif ((mode & dotsIO)) {\n\t\t\t\tif ((mode & ucBrl))\n\t\t\t\t\toutbuf[k] = ((output.chars[k] & 0xff) | 0x2800);\n\t\t\t\telse\n\t\t\t\t\toutbuf[k] = output.chars[k];\n\t\t\t} else\n\t\t\t\toutbuf[k] = _lou_getCharFromDots(output.chars[k]);\n\t\t}\n\t\t*inlen = posMapping[output.length];\n\t\t*outlen = output.length;\n\t\t// Compute inputPos and outputPos from posMapping. The value at the last index of\n\t\t// posMapping is currectly not used.\n\t\tif (inputPos != NULL) {\n\t\t\tfor (k = 0; k < *outlen; k++)\n\t\t\t\tif (posMapping[k] < 0)\n\t\t\t\t\tinputPos[k] = 0;\n\t\t\t\telse if (posMapping[k] > *inlen - 1)\n\t\t\t\t\tinputPos[k] = *inlen - 1;\n\t\t\t\telse\n\t\t\t\t\tinputPos[k] = posMapping[k];\n\t\t}\n\t\tif (outputPos != NULL) {\n\t\t\tint inpos = -1;\n\t\t\tint outpos = -1;\n\t\t\tfor (k = 0; k < *outlen; k++)\n\t\t\t\tif (posMapping[k] > inpos) {\n\t\t\t\t\twhile (inpos < posMapping[k]) {\n\t\t\t\t\t\tif (inpos >= 0 && inpos < *inlen)\n\t\t\t\t\t\t\toutputPos[inpos] = outpos < 0 ? 0 : outpos;\n\t\t\t\t\t\tinpos++;\n\t\t\t\t\t}\n\t\t\t\t\toutpos = k;\n\t\t\t\t}\n\t\t\tif (inpos < 0) inpos = 0;\n\t\t\twhile (inpos < *inlen) outputPos[inpos++] = outpos;\n\t\t}\n\t}\n\tif (destSpacing != NULL) {\n\t\tmemcpy(srcSpacing, destSpacing, input->length);\n\t\tsrcSpacing[input->length] = 0;\n\t}\n\tif (cursorPos != NULL && *cursorPos != -1) {\n\t\tif (outputPos != NULL)\n\t\t\t*cursorPos = outputPos[*cursorPos];\n\t\telse\n\t\t\t*cursorPos = cursorPosition;\n\t}\n\tif (rulesLen != NULL) *rulesLen = appliedRulesCount;\n\t_lou_logMessage(LOG_ALL, \"Translation complete: outlen=%d\", *outlen);\n\t_lou_logWidecharBuf(LOG_ALL, \"Outbuf=\", (const widechar *)outbuf, *outlen);\n\n\treturn goodTrans;\n}\n\nint EXPORT_CALL\nlou_translatePrehyphenated(const char *tableList, const widechar *inbufx, int *inlen,\n\t\twidechar *outbuf, int *outlen, formtype *typeform, char *spacing, int *outputPos,\n\t\tint *inputPos, int *cursorPos, char *inputHyphens, char *outputHyphens,\n\t\tint mode) {\n\tint rv = 1;\n\tint *alloc_inputPos = NULL;\n\tif (inputHyphens != NULL) {\n\t\tif (outputHyphens == NULL) return 0;\n\t\tif (inputPos == NULL) {\n\t\t\tif ((alloc_inputPos = malloc(*outlen * sizeof(int))) == NULL)\n\t\t\t\t_lou_outOfMemory();\n\t\t\tinputPos = alloc_inputPos;\n\t\t}\n\t}\n\tif (lou_translate(tableList, inbufx, inlen, outbuf, outlen, typeform, spacing,\n\t\t\t\toutputPos, inputPos, cursorPos, mode)) {\n\t\tif (inputHyphens != NULL) {\n\t\t\tint inpos = 0;\n\t\t\tint outpos;\n\t\t\tfor (outpos = 0; outpos < *outlen; outpos++) {\n\t\t\t\tint new_inpos = inputPos[outpos];\n\t\t\t\tif (new_inpos < inpos) {\n\t\t\t\t\trv = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (new_inpos > inpos)\n\t\t\t\t\toutputHyphens[outpos] = inputHyphens[new_inpos];\n\t\t\t\telse\n\t\t\t\t\toutputHyphens[outpos] = '0';\n\t\t\t\tinpos = new_inpos;\n\t\t\t}\n\t\t}\n\t}\n\tif (alloc_inputPos != NULL) free(alloc_inputPos);\n\treturn rv;\n}\n\nstatic int\nhyphenate(const widechar *word, int wordSize, char *hyphens,\n\t\tconst TranslationTableHeader *table) {\n\twidechar *prepWord;\n\tint i, k, limit;\n\tint stateNum;\n\twidechar ch;\n\tHyphenationState *statesArray =\n\t\t\t(HyphenationState *)&table->ruleArea[table->hyphenStatesArray];\n\tHyphenationState *currentState;\n\tHyphenationTrans *transitionsArray;\n\tchar *hyphenPattern;\n\tint patternOffset;\n\tif (!table->hyphenStatesArray || (wordSize + 3) > MAXSTRING) return 0;\n\tprepWord = (widechar *)calloc(wordSize + 3, sizeof(widechar));\n\t/* prepWord is of the format \".hello.\"\n\t * hyphens is the length of the word \"hello\" \"00000\" */\n\tprepWord[0] = '.';\n\tfor (i = 0; i < wordSize; i++) {\n\t\tprepWord[i + 1] = (findCharOrDots(word[i], 0, table))->lowercase;\n\t\thyphens[i] = '0';\n\t}\n\tprepWord[wordSize + 1] = '.';\n\n\t/* now, run the finite state machine */\n\tstateNum = 0;\n\n\t// we need to walk all of \".hello.\"\n\tfor (i = 0; i < wordSize + 2; i++) {\n\t\tch = prepWord[i];\n\t\twhile (1) {\n\t\t\tif (stateNum == 0xffff) {\n\t\t\t\tstateNum = 0;\n\t\t\t\tgoto nextLetter;\n\t\t\t}\n\t\t\tcurrentState = &statesArray[stateNum];\n\t\t\tif (currentState->trans.offset) {\n\t\t\t\ttransitionsArray =\n\t\t\t\t\t\t(HyphenationTrans *)&table->ruleArea[currentState->trans.offset];\n\t\t\t\tfor (k = 0; k < currentState->numTrans; k++) {\n\t\t\t\t\tif (transitionsArray[k].ch == ch) {\n\t\t\t\t\t\tstateNum = transitionsArray[k].newState;\n\t\t\t\t\t\tgoto stateFound;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstateNum = currentState->fallbackState;\n\t\t}\n\tstateFound:\n\t\tcurrentState = &statesArray[stateNum];\n\t\tif (currentState->hyphenPattern) {\n\t\t\thyphenPattern = (char *)&table->ruleArea[currentState->hyphenPattern];\n\t\t\tpatternOffset = i + 1 - (int)strlen(hyphenPattern);\n\n\t\t\t/* Need to ensure that we don't overrun hyphens,\n\t\t\t * in some cases hyphenPattern is longer than the remaining letters,\n\t\t\t * and if we write out all of it we would have overshot our buffer. */\n\t\t\tlimit = MIN((int)strlen(hyphenPattern), wordSize - patternOffset);\n\t\t\tfor (k = 0; k < limit; k++) {\n\t\t\t\tif (hyphens[patternOffset + k] < hyphenPattern[k])\n\t\t\t\t\thyphens[patternOffset + k] = hyphenPattern[k];\n\t\t\t}\n\t\t}\n\tnextLetter:;\n\t}\n\thyphens[wordSize] = 0;\n\tfree(prepWord);\n\treturn 1;\n}\n\nstatic int\ndoCompTrans(int start, int end, const TranslationTableHeader *table, int *pos,\n\t\tconst InString *input, OutString *output, int *posMapping,\n\t\tEmphasisInfo *emphasisBuffer, const TranslationTableRule **transRule,\n\t\tint *cursorPosition, int *cursorStatus);\n\nstatic int\nfor_updatePositions(const widechar *outChars, int inLength, int outLength, int shift,\n\t\tint pos, const InString *input, OutString *output, int *posMapping,\n\t\tint *cursorPosition, int *cursorStatus) {\n\tint k;\n\tif ((output->length + outLength) > output->maxlength ||\n\t\t\t(pos + inLength) > input->length)\n\t\treturn 0;\n\tmemcpy(&output->chars[output->length], outChars, outLength * CHARSIZE);\n\tif (!*cursorStatus) {\n\t\tif (*cursorPosition >= pos && *cursorPosition < (pos + inLength)) {\n\t\t\t*cursorPosition = output->length;\n\t\t\t*cursorStatus = 1;\n\t\t} else if (input->chars[*cursorPosition] == 0 &&\n\t\t\t\t*cursorPosition == (pos + inLength)) {\n\t\t\t*cursorPosition = output->length + outLength / 2 + 1;\n\t\t\t*cursorStatus = 1;\n\t\t}\n\t} else if (*cursorStatus == 2 && *cursorPosition == pos)\n\t\t*cursorPosition = output->length;\n\tfor (k = 0; k < outLength; k++) posMapping[output->length + k] = pos + shift;\n\toutput->length += outLength;\n\treturn 1;\n}\n\nstatic int\nsyllableBreak(const TranslationTableHeader *table, int pos, const InString *input,\n\t\tint transCharslen) {\n\tint wordStart = 0;\n\tint wordEnd = 0;\n\tint wordSize = 0;\n\tint k = 0;\n\tchar *hyphens = NULL;\n\tfor (wordStart = pos; wordStart >= 0; wordStart--)\n\t\tif (!((findCharOrDots(input->chars[wordStart], 0, table))->attributes &\n\t\t\t\t\tCTC_Letter)) {\n\t\t\twordStart++;\n\t\t\tbreak;\n\t\t}\n\tif (wordStart < 0) wordStart = 0;\n\tfor (wordEnd = pos; wordEnd < input->length; wordEnd++)\n\t\tif (!((findCharOrDots(input->chars[wordEnd], 0, table))->attributes &\n\t\t\t\t\tCTC_Letter)) {\n\t\t\twordEnd--;\n\t\t\tbreak;\n\t\t}\n\tif (wordEnd == input->length) wordEnd--;\n\t/* At this stage wordStart is the 0 based index of the first letter in the word,\n\t * wordEnd is the 0 based index of the last letter in the word.\n\t * example: \"hello\" wordstart=0, wordEnd=4. */\n\twordSize = wordEnd - wordStart + 1;\n\thyphens = (char *)calloc(wordSize + 1, sizeof(char));\n\tif (!hyphenate(&input->chars[wordStart], wordSize, hyphens, table)) {\n\t\tfree(hyphens);\n\t\treturn 0;\n\t}\n\tfor (k = pos - wordStart + 1; k < (pos - wordStart + transCharslen); k++)\n\t\tif (hyphens[k] & 1) {\n\t\t\tfree(hyphens);\n\t\t\treturn 1;\n\t\t}\n\tfree(hyphens);\n\treturn 0;\n}\n\nstatic void\nsetBefore(const TranslationTableHeader *table, int pos, const InString *input,\n\t\tTranslationTableCharacterAttributes *beforeAttributes) {\n\twidechar before;\n\tif (pos >= 2 && input->chars[pos - 1] == ENDSEGMENT)\n\t\tbefore = input->chars[pos - 2];\n\telse\n\t\tbefore = (pos == 0) ? ' ' : input->chars[pos - 1];\n\t*beforeAttributes = (findCharOrDots(before, 0, table))->attributes;\n}\n\nstatic void\nsetAfter(int length, const TranslationTableHeader *table, int pos, const InString *input,\n\t\tTranslationTableCharacterAttributes *afterAttributes) {\n\twidechar after;\n\tif ((pos + length + 2) < input->length && input->chars[pos + 1] == ENDSEGMENT)\n\t\tafter = input->chars[pos + 2];\n\telse\n\t\tafter = (pos + length < input->length) ? input->chars[pos + length] : ' ';\n\t*afterAttributes = (findCharOrDots(after, 0, table))->attributes;\n}\n\nstatic int\nbrailleIndicatorDefined(TranslationTableOffset offset,\n\t\tconst TranslationTableHeader *table, const TranslationTableRule **indicRule) {\n\tif (!offset) return 0;\n\t*indicRule = (TranslationTableRule *)&table->ruleArea[offset];\n\treturn 1;\n}\n\nstatic int\nvalidMatch(const TranslationTableHeader *table, int pos, const InString *input,\n\t\tformtype *typebuf, const TranslationTableRule *transRule, int transCharslen) {\n\t/* Analyze the typeform parameter and also check for capitalization */\n\tTranslationTableCharacter *inputChar;\n\tTranslationTableCharacter *ruleChar;\n\tTranslationTableCharacterAttributes prevAttr = 0;\n\tint k;\n\tint kk = 0;\n\tif (!transCharslen) return 0;\n\tfor (k = pos; k < pos + transCharslen; k++) {\n\t\tif (input->chars[k] == ENDSEGMENT) {\n\t\t\tif (k == pos && transCharslen == 1)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t\tinputChar = findCharOrDots(input->chars[k], 0, table);\n\t\tif (k == pos) prevAttr = inputChar->attributes;\n\t\truleChar = findCharOrDots(transRule->charsdots[kk++], 0, table);\n\t\tif ((inputChar->lowercase != ruleChar->lowercase)) return 0;\n\t\tif (typebuf != NULL && (typebuf[pos] & CAPSEMPH) == 0 &&\n\t\t\t\t(typebuf[k] | typebuf[pos]) != typebuf[pos])\n\t\t\treturn 0;\n\t\tif (inputChar->attributes != CTC_Letter) {\n\t\t\tif (k != (pos + 1) && (prevAttr & CTC_Letter) &&\n\t\t\t\t\t(inputChar->attributes & CTC_Letter) &&\n\t\t\t\t\t((inputChar->attributes &\n\t\t\t\t\t\t\t (CTC_LowerCase | CTC_UpperCase | CTC_Letter)) !=\n\t\t\t\t\t\t\t(prevAttr & (CTC_LowerCase | CTC_UpperCase | CTC_Letter))))\n\t\t\t\treturn 0;\n\t\t}\n\t\tprevAttr = inputChar->attributes;\n\t}\n\treturn 1;\n}\n\nstatic int\ninsertBrailleIndicators(int finish, const TranslationTableHeader *table, int pos,\n\t\tconst InString *input, OutString *output, int *posMapping, formtype *typebuf,\n\t\tint haveEmphasis, int transOpcode, int prevTransOpcode, int *cursorPosition,\n\t\tint *cursorStatus, TranslationTableCharacterAttributes beforeAttributes,\n\t\tint *prevType, int *curType, int *prevTypeform, int prevPos) {\n\t/* Insert braille indicators such as letter, number, etc. */\n\ttypedef enum {\n\t\tcheckNothing,\n\t\tcheckBeginTypeform,\n\t\tcheckEndTypeform,\n\t\tcheckNumber,\n\t\tcheckLetter\n\t} checkThis;\n\tcheckThis checkWhat = checkNothing;\n\tint ok = 0;\n\tint k;\n\t{\n\t\tif (pos == prevPos && !finish) return 1;\n\t\tif (pos != prevPos) {\n\t\t\tif (haveEmphasis && (typebuf[pos] & EMPHASIS) != *prevTypeform) {\n\t\t\t\t*prevType = *prevTypeform & EMPHASIS;\n\t\t\t\t*curType = typebuf[pos] & EMPHASIS;\n\t\t\t\tcheckWhat = checkEndTypeform;\n\t\t\t} else if (!finish)\n\t\t\t\tcheckWhat = checkNothing;\n\t\t\telse\n\t\t\t\tcheckWhat = checkNumber;\n\t\t}\n\t\tif (finish == 1) checkWhat = checkNumber;\n\t}\n\tdo {\n\t\tconst TranslationTableRule *indicRule;\n\t\tok = 0;\n\t\tswitch (checkWhat) {\n\t\tcase checkNothing:\n\t\t\tok = 0;\n\t\t\tbreak;\n\t\tcase checkBeginTypeform:\n\t\t\tif (haveEmphasis) {\n\t\t\t\tok = 0;\n\t\t\t\t*curType = 0;\n\t\t\t}\n\t\t\tif (*curType == plain_text) {\n\t\t\t\tif (!finish)\n\t\t\t\t\tcheckWhat = checkNothing;\n\t\t\t\telse\n\t\t\t\t\tcheckWhat = checkNumber;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase checkEndTypeform:\n\t\t\tif (haveEmphasis) {\n\t\t\t\tok = 0;\n\t\t\t\t*prevType = plain_text;\n\t\t\t}\n\t\t\tif (*prevType == plain_text) {\n\t\t\t\tcheckWhat = checkBeginTypeform;\n\t\t\t\t*prevTypeform = typebuf[pos] & EMPHASIS;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase checkNumber:\n\t\t\tif (brailleIndicatorDefined(table->numberSign, table, &indicRule) &&\n\t\t\t\t\tcheckAttr_safe(input, pos, CTC_Digit, 0, table) &&\n\t\t\t\t\t(prevTransOpcode == CTO_ExactDots ||\n\t\t\t\t\t\t\t!(beforeAttributes & CTC_Digit)) &&\n\t\t\t\t\tprevTransOpcode != CTO_MidNum) {\n\t\t\t\tok = !table->usesNumericMode;\n\t\t\t\tcheckWhat = checkNothing;\n\t\t\t} else\n\t\t\t\tcheckWhat = checkLetter;\n\t\t\tbreak;\n\t\tcase checkLetter:\n\t\t\tif (!brailleIndicatorDefined(table->letterSign, table, &indicRule)) {\n\t\t\t\tok = 0;\n\t\t\t\tcheckWhat = checkNothing;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (transOpcode == CTO_Contraction) {\n\t\t\t\tok = 1;\n\t\t\t\tcheckWhat = checkNothing;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((checkAttr_safe(input, pos, CTC_Letter, 0, table) &&\n\t\t\t\t\t\t!(beforeAttributes & CTC_Letter)) &&\n\t\t\t\t\t(!checkAttr_safe(input, pos + 1, CTC_Letter, 0, table) ||\n\t\t\t\t\t\t\t(beforeAttributes & CTC_Digit))) {\n\t\t\t\tok = 1;\n\t\t\t\tif (pos > 0)\n\t\t\t\t\tfor (k = 0; k < table->noLetsignBeforeCount; k++)\n\t\t\t\t\t\tif (input->chars[pos - 1] == table->noLetsignBefore[k]) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\tfor (k = 0; k < table->noLetsignCount; k++)\n\t\t\t\t\tif (input->chars[pos] == table->noLetsign[k]) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tif (pos + 1 < input->length)\n\t\t\t\t\tfor (k = 0; k < table->noLetsignAfterCount; k++)\n\t\t\t\t\t\tif (input->chars[pos + 1] == table->noLetsignAfter[k]) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t}\n\t\t\tcheckWhat = checkNothing;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tok = 0;\n\t\t\tcheckWhat = checkNothing;\n\t\t\tbreak;\n\t\t}\n\t\tif (ok && indicRule != NULL) {\n\t\t\tif (!for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0,\n\t\t\t\t\t\tpos, input, output, posMapping, cursorPosition, cursorStatus))\n\t\t\t\treturn 0;\n\t\t}\n\t} while (checkWhat != checkNothing);\n\treturn 1;\n}\n\nstatic int\nonlyLettersBehind(const TranslationTableHeader *table, int pos, const InString *input,\n\t\tTranslationTableCharacterAttributes beforeAttributes) {\n\t/* Actually, spaces, then letters */\n\tint k;\n\tif (!(beforeAttributes & CTC_Space)) return 0;\n\tfor (k = pos - 2; k >= 0; k--) {\n\t\tTranslationTableCharacterAttributes attr =\n\t\t\t\t(findCharOrDots(input->chars[k], 0, table))->attributes;\n\t\tif ((attr & CTC_Space)) continue;\n\t\tif ((attr & CTC_Letter))\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int\nonlyLettersAhead(const TranslationTableHeader *table, int pos, const InString *input,\n\t\tint transCharslen, TranslationTableCharacterAttributes afterAttributes) {\n\t/* Actullly, spaces, then letters */\n\tint k;\n\tif (!(afterAttributes & CTC_Space)) return 0;\n\tfor (k = pos + transCharslen + 1; k < input->length; k++) {\n\t\tTranslationTableCharacterAttributes attr =\n\t\t\t\t(findCharOrDots(input->chars[k], 0, table))->attributes;\n\t\tif ((attr & CTC_Space)) continue;\n\t\tif ((attr & (CTC_Letter | CTC_LitDigit)))\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstatic int\nnoCompbrlAhead(const TranslationTableHeader *table, int pos, int mode,\n\t\tconst InString *input, int transOpcode, int transCharslen, int cursorPosition) {\n\tint start = pos + transCharslen;\n\tint end;\n\tint p;\n\tif (start >= input->length) return 1;\n\twhile (start < input->length && checkAttr(input->chars[start], CTC_Space, 0, table))\n\t\tstart++;\n\tif (start == input->length ||\n\t\t\t(transOpcode == CTO_JoinableWord &&\n\t\t\t\t\t(!checkAttr(input->chars[start], CTC_Letter | CTC_Digit, 0, table) ||\n\t\t\t\t\t\t\t!checkAttr(input->chars[start - 1], CTC_Space, 0, table))))\n\t\treturn 1;\n\tend = start;\n\twhile (end < input->length && !checkAttr(input->chars[end], CTC_Space, 0, table))\n\t\tend++;\n\tif ((mode & (compbrlAtCursor | compbrlLeftCursor)) && cursorPosition >= start &&\n\t\t\tcursorPosition < end)\n\t\treturn 0;\n\t/* Look ahead for rules with CTO_CompBrl */\n\tfor (p = start; p < end; p++) {\n\t\tint length = input->length - p;\n\t\tint tryThis;\n\t\tconst TranslationTableCharacter *character1;\n\t\tconst TranslationTableCharacter *character2;\n\t\tint k;\n\t\tcharacter1 = findCharOrDots(input->chars[p], 0, table);\n\t\tfor (tryThis = 0; tryThis < 2; tryThis++) {\n\t\t\tTranslationTableOffset ruleOffset = 0;\n\t\t\tTranslationTableRule *testRule;\n\t\t\tunsigned long int makeHash = 0;\n\t\t\tswitch (tryThis) {\n\t\t\tcase 0:\n\t\t\t\tif (!(length >= 2)) break;\n\t\t\t\t/* Hash function optimized for forward translation */\n\t\t\t\tmakeHash = (unsigned long int)character1->lowercase << 8;\n\t\t\t\tcharacter2 = findCharOrDots(input->chars[p + 1], 0, table);\n\t\t\t\tmakeHash += (unsigned long int)character2->lowercase;\n\t\t\t\tmakeHash %= HASHNUM;\n\t\t\t\truleOffset = table->forRules[makeHash];\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif (!(length >= 1)) break;\n\t\t\t\tlength = 1;\n\t\t\t\truleOffset = character1->otherRules;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (ruleOffset) {\n\t\t\t\ttestRule = (TranslationTableRule *)&table->ruleArea[ruleOffset];\n\t\t\t\tfor (k = 0; k < testRule->charslen; k++) {\n\t\t\t\t\tcharacter1 = findCharOrDots(testRule->charsdots[k], 0, table);\n\t\t\t\t\tcharacter2 = findCharOrDots(input->chars[p + k], 0, table);\n\t\t\t\t\tif (character1->lowercase != character2->lowercase) break;\n\t\t\t\t}\n\t\t\t\tif (tryThis == 1 || k == testRule->charslen) {\n\t\t\t\t\tif (testRule->opcode == CTO_CompBrl ||\n\t\t\t\t\t\t\ttestRule->opcode == CTO_Literal)\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\truleOffset = testRule->charsnext;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int\nisRepeatedWord(const TranslationTableHeader *table, int pos, const InString *input,\n\t\tint transCharslen, const widechar **repwordStart, int *repwordLength) {\n\tint start;\n\tif (pos == 0 || !checkAttr(input->chars[pos - 1], CTC_Letter, 0, table)) return 0;\n\tif ((pos + transCharslen) >= input->length ||\n\t\t\t!checkAttr(input->chars[pos + transCharslen], CTC_Letter, 0, table))\n\t\treturn 0;\n\tfor (start = pos - 2;\n\t\t\tstart >= 0 && checkAttr(input->chars[start], CTC_Letter, 0, table); start--)\n\t\t;\n\tstart++;\n\t*repwordStart = &input->chars[start];\n\t*repwordLength = pos - start;\n\tif (compareChars(*repwordStart, &input->chars[pos + transCharslen], *repwordLength, 0,\n\t\t\t\ttable))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int\ncheckEmphasisChange(const int skip, int pos, EmphasisInfo *emphasisBuffer,\n\t\tconst TranslationTableRule *transRule) {\n\tint i;\n\tfor (i = pos + (skip + 1); i < pos + transRule->charslen; i++)\n\t\tif (emphasisBuffer[i].begin || emphasisBuffer[i].end || emphasisBuffer[i].word ||\n\t\t\t\temphasisBuffer[i].symbol)\n\t\t\treturn 1;\n\treturn 0;\n}\n\nstatic int\ninSequence(const TranslationTableHeader *table, int pos, const InString *input,\n\t\tconst TranslationTableRule *transRule) {\n\tint i, j, s, match;\n\t// TODO: all caps words\n\t// const TranslationTableCharacter *c = NULL;\n\n\t/* check before sequence */\n\tfor (i = pos - 1; i >= 0; i--) {\n\t\tif (checkAttr(input->chars[i], CTC_SeqBefore, 0, table)) continue;\n\t\tif (!(checkAttr(input->chars[i], CTC_Space | CTC_SeqDelimiter, 0, table)))\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\n\t/* check after sequence */\n\tfor (i = pos + transRule->charslen; i < input->length; i++) {\n\t\t/* check sequence after patterns */\n\t\tif (table->seqPatternsCount) {\n\t\t\tmatch = 0;\n\t\t\tfor (j = i, s = 0; j <= input->length && s < table->seqPatternsCount;\n\t\t\t\t\tj++, s++) {\n\t\t\t\t/* matching */\n\t\t\t\tif (match == 1) {\n\t\t\t\t\tif (table->seqPatterns[s]) {\n\t\t\t\t\t\tif (input->chars[j] == table->seqPatterns[s])\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tmatch = -1;\n\t\t\t\t\t\t\tj = i - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* found match */\n\t\t\t\t\telse {\n\t\t\t\t\t\t/* pattern at end of input */\n\t\t\t\t\t\tif (j >= input->length) return 1;\n\n\t\t\t\t\t\ti = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* looking for match */\n\t\t\t\telse if (match == 0) {\n\t\t\t\t\tif (table->seqPatterns[s]) {\n\t\t\t\t\t\tif (input->chars[j] == table->seqPatterns[s])\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tmatch = -1;\n\t\t\t\t\t\t\tj = i - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* next pattarn */\n\t\t\t\telse if (match == -1) {\n\t\t\t\t\tif (!table->seqPatterns[s]) {\n\t\t\t\t\t\tmatch = 0;\n\t\t\t\t\t\tj = i - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (checkAttr(input->chars[i], CTC_SeqAfter, 0, table)) continue;\n\t\tif (!(checkAttr(input->chars[i], CTC_Space | CTC_SeqDelimiter, 0, table)))\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\n\treturn 1;\n}\n\nstatic void\nfor_selectRule(const TranslationTableHeader *table, int pos, OutString output, int mode,\n\t\tconst InString *input, formtype *typebuf, EmphasisInfo *emphasisBuffer,\n\t\tint *transOpcode, int prevTransOpcode, const TranslationTableRule **transRule,\n\t\tint *transCharslen, int *passCharDots, widechar const **passInstructions,\n\t\tint *passIC, PassRuleMatch *patternMatch, int posIncremented, int cursorPosition,\n\t\tconst widechar **repwordStart, int *repwordLength, int dontContract,\n\t\tint compbrlStart, int compbrlEnd,\n\t\tTranslationTableCharacterAttributes beforeAttributes,\n\t\tTranslationTableCharacter **curCharDef, TranslationTableRule **groupingRule,\n\t\twidechar *groupingOp) {\n\t/* check for valid Translations. Return value is in transRule. */\n\tstatic TranslationTableRule pseudoRule = { 0 };\n\tint length = ((pos < compbrlStart) ? compbrlStart : input->length) - pos;\n\tint tryThis;\n\tconst TranslationTableCharacter *character2;\n\tint k;\n\tTranslationTableOffset ruleOffset = 0;\n\t*curCharDef = findCharOrDots(input->chars[pos], 0, table);\n\tfor (tryThis = 0; tryThis < 3; tryThis++) {\n\t\tunsigned long int makeHash = 0;\n\t\tswitch (tryThis) {\n\t\tcase 0:\n\t\t\tif (!(length >= 2)) break;\n\t\t\t/* Hash function optimized for forward translation */\n\t\t\tmakeHash = (unsigned long int)(*curCharDef)->lowercase << 8;\n\t\t\tcharacter2 = findCharOrDots(input->chars[pos + 1], 0, table);\n\t\t\tmakeHash += (unsigned long int)character2->lowercase;\n\t\t\tmakeHash %= HASHNUM;\n\t\t\truleOffset = table->forRules[makeHash];\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (!(length >= 1)) break;\n\t\t\tlength = 1;\n\t\t\truleOffset = (*curCharDef)->otherRules;\n\t\t\tbreak;\n\t\tcase 2: /* No rule found */\n\t\t\t*transRule = &pseudoRule;\n\t\t\t*transOpcode = pseudoRule.opcode = CTO_None;\n\t\t\t*transCharslen = pseudoRule.charslen = 1;\n\t\t\tpseudoRule.charsdots[0] = input->chars[pos];\n\t\t\tpseudoRule.dotslen = 0;\n\t\t\treturn;\n\t\t\tbreak;\n\t\t}\n\t\twhile (ruleOffset) {\n\t\t\t*transRule = (TranslationTableRule *)&table->ruleArea[ruleOffset];\n\t\t\t*transOpcode = (*transRule)->opcode;\n\t\t\t*transCharslen = (*transRule)->charslen;\n\t\t\tif (tryThis == 1 ||\n\t\t\t\t\t((*transCharslen <= length) && validMatch(table, pos, input, typebuf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   *transRule, *transCharslen))) {\n\t\t\t\tTranslationTableCharacterAttributes afterAttributes;\n\t\t\t\t/* check before emphasis match */\n\t\t\t\tif ((*transRule)->before & CTC_EmpMatch) {\n\t\t\t\t\tif (emphasisBuffer[pos].begin || emphasisBuffer[pos].end ||\n\t\t\t\t\t\t\temphasisBuffer[pos].word || emphasisBuffer[pos].symbol)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* check after emphasis match */\n\t\t\t\tif ((*transRule)->after & CTC_EmpMatch) {\n\t\t\t\t\tif (emphasisBuffer[pos + *transCharslen].begin ||\n\t\t\t\t\t\t\temphasisBuffer[pos + *transCharslen].end ||\n\t\t\t\t\t\t\temphasisBuffer[pos + *transCharslen].word ||\n\t\t\t\t\t\t\temphasisBuffer[pos + *transCharslen].symbol)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* check this rule */\n\t\t\t\tsetAfter(*transCharslen, table, pos, input, &afterAttributes);\n\t\t\t\tif ((!((*transRule)->after & ~CTC_EmpMatch) ||\n\t\t\t\t\t\t\t(beforeAttributes & (*transRule)->after)) &&\n\t\t\t\t\t\t(!((*transRule)->before & ~CTC_EmpMatch) ||\n\t\t\t\t\t\t\t\t(afterAttributes & (*transRule)->before)))\n\t\t\t\t\tswitch (*transOpcode) { /* check validity of this Translation */\n\t\t\t\t\tcase CTO_Space:\n\t\t\t\t\tcase CTO_Letter:\n\t\t\t\t\tcase CTO_UpperCase:\n\t\t\t\t\tcase CTO_LowerCase:\n\t\t\t\t\tcase CTO_Digit:\n\t\t\t\t\tcase CTO_LitDigit:\n\t\t\t\t\tcase CTO_Punctuation:\n\t\t\t\t\tcase CTO_Math:\n\t\t\t\t\tcase CTO_Sign:\n\t\t\t\t\tcase CTO_Hyphen:\n\t\t\t\t\tcase CTO_Replace:\n\t\t\t\t\tcase CTO_CompBrl:\n\t\t\t\t\tcase CTO_Literal:\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase CTO_Repeated:\n\t\t\t\t\t\tif ((mode & (compbrlAtCursor | compbrlLeftCursor)) &&\n\t\t\t\t\t\t\t\tpos >= compbrlStart && pos <= compbrlEnd)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase CTO_RepWord:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif (isRepeatedWord(table, pos, input, *transCharslen,\n\t\t\t\t\t\t\t\t\trepwordStart, repwordLength))\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_NoCont:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase CTO_Syllable:\n\t\t\t\t\t\t*transOpcode = CTO_Always;\n\t\t\t\t\tcase CTO_Always:\n\t\t\t\t\t\tif (checkEmphasisChange(0, pos, emphasisBuffer, *transRule))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase CTO_ExactDots:\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase CTO_NoCross:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif (syllableBreak(table, pos, input, *transCharslen)) break;\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase CTO_Context:\n\t\t\t\t\t\tif (!posIncremented ||\n\t\t\t\t\t\t\t\t!passDoTest(table, pos, input, *transOpcode, *transRule,\n\t\t\t\t\t\t\t\t\t\tpassCharDots, passInstructions, passIC,\n\t\t\t\t\t\t\t\t\t\tpatternMatch, groupingRule, groupingOp))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase CTO_LargeSign:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif (!((beforeAttributes & (CTC_Space | CTC_Punctuation)) ||\n\t\t\t\t\t\t\t\t\tonlyLettersBehind(\n\t\t\t\t\t\t\t\t\t\t\ttable, pos, input, beforeAttributes)) ||\n\t\t\t\t\t\t\t\t!((afterAttributes & CTC_Space) ||\n\t\t\t\t\t\t\t\t\t\tprevTransOpcode == CTO_LargeSign) ||\n\t\t\t\t\t\t\t\t(afterAttributes & CTC_Letter) ||\n\t\t\t\t\t\t\t\t!noCompbrlAhead(table, pos, mode, input, *transOpcode,\n\t\t\t\t\t\t\t\t\t\t*transCharslen, cursorPosition))\n\t\t\t\t\t\t\t*transOpcode = CTO_Always;\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase CTO_WholeWord:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif (checkEmphasisChange(0, pos, emphasisBuffer, *transRule))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_Contraction:\n\t\t\t\t\t\tif (table->usesSequences) {\n\t\t\t\t\t\t\tif (inSequence(table, pos, input, *transRule)) return;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ((beforeAttributes & (CTC_Space | CTC_Punctuation)) &&\n\t\t\t\t\t\t\t\t\t(afterAttributes & (CTC_Space | CTC_Punctuation)))\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_PartWord:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif ((beforeAttributes & CTC_Letter) ||\n\t\t\t\t\t\t\t\t(afterAttributes & CTC_Letter))\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_JoinNum:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif ((beforeAttributes & (CTC_Space | CTC_Punctuation)) &&\n\t\t\t\t\t\t\t\t(afterAttributes & CTC_Space) &&\n\t\t\t\t\t\t\t\t(output.length + (*transRule)->dotslen <\n\t\t\t\t\t\t\t\t\t\toutput.maxlength)) {\n\t\t\t\t\t\t\tint p = pos + *transCharslen + 1;\n\t\t\t\t\t\t\twhile (p < input->length) {\n\t\t\t\t\t\t\t\tif (!checkAttr(input->chars[p], CTC_Space, 0, table)) {\n\t\t\t\t\t\t\t\t\tif (checkAttr(input->chars[p], CTC_Digit, 0, table))\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_LowWord:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif ((beforeAttributes & CTC_Space) &&\n\t\t\t\t\t\t\t\t(afterAttributes & CTC_Space) &&\n\t\t\t\t\t\t\t\t(prevTransOpcode != CTO_JoinableWord))\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_JoinableWord:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif (beforeAttributes & (CTC_Space | CTC_Punctuation) &&\n\t\t\t\t\t\t\t\tonlyLettersAhead(table, pos, input, *transCharslen,\n\t\t\t\t\t\t\t\t\t\tafterAttributes) &&\n\t\t\t\t\t\t\t\tnoCompbrlAhead(table, pos, mode, input, *transOpcode,\n\t\t\t\t\t\t\t\t\t\t*transCharslen, cursorPosition))\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_SuffixableWord:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif ((beforeAttributes & (CTC_Space | CTC_Punctuation)) &&\n\t\t\t\t\t\t\t\t(afterAttributes &\n\t\t\t\t\t\t\t\t\t\t(CTC_Space | CTC_Letter | CTC_Punctuation)))\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_PrefixableWord:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif ((beforeAttributes &\n\t\t\t\t\t\t\t\t\t(CTC_Space | CTC_Letter | CTC_Punctuation)) &&\n\t\t\t\t\t\t\t\t(afterAttributes & (CTC_Space | CTC_Punctuation)))\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_BegWord:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif ((beforeAttributes & (CTC_Space | CTC_Punctuation)) &&\n\t\t\t\t\t\t\t\t(afterAttributes & CTC_Letter))\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_BegMidWord:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif ((beforeAttributes &\n\t\t\t\t\t\t\t\t\t(CTC_Letter | CTC_Space | CTC_Punctuation)) &&\n\t\t\t\t\t\t\t\t(afterAttributes & CTC_Letter))\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_MidWord:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif (beforeAttributes & CTC_Letter && afterAttributes & CTC_Letter)\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_MidEndWord:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif (beforeAttributes & CTC_Letter &&\n\t\t\t\t\t\t\t\tafterAttributes &\n\t\t\t\t\t\t\t\t\t\t(CTC_Letter | CTC_Space | CTC_Punctuation))\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_EndWord:\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif (beforeAttributes & CTC_Letter &&\n\t\t\t\t\t\t\t\tafterAttributes & (CTC_Space | CTC_Punctuation))\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_BegNum:\n\t\t\t\t\t\tif (beforeAttributes & (CTC_Space | CTC_Punctuation) &&\n\t\t\t\t\t\t\t\tafterAttributes & CTC_Digit)\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_MidNum:\n\t\t\t\t\t\tif (prevTransOpcode != CTO_ExactDots &&\n\t\t\t\t\t\t\t\tbeforeAttributes & CTC_Digit &&\n\t\t\t\t\t\t\t\tafterAttributes & CTC_Digit)\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_EndNum:\n\t\t\t\t\t\tif (beforeAttributes & CTC_Digit &&\n\t\t\t\t\t\t\t\tprevTransOpcode != CTO_ExactDots)\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_DecPoint:\n\t\t\t\t\t\tif (!(afterAttributes & CTC_Digit)) break;\n\t\t\t\t\t\tif (beforeAttributes & CTC_Digit) *transOpcode = CTO_MidNum;\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase CTO_PrePunc:\n\t\t\t\t\t\tif (!checkAttr(input->chars[pos], CTC_Punctuation, 0, table) ||\n\t\t\t\t\t\t\t\t(pos > 0 && checkAttr(input->chars[pos - 1], CTC_Letter,\n\t\t\t\t\t\t\t\t\t\t\t\t\t0, table)))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tfor (k = pos + *transCharslen; k < input->length; k++) {\n\t\t\t\t\t\t\tif (checkAttr(input->chars[k], (CTC_Letter | CTC_Digit), 0,\n\t\t\t\t\t\t\t\t\t\ttable))\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\tif (checkAttr(input->chars[k], CTC_Space, 0, table)) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CTO_PostPunc:\n\t\t\t\t\t\tif (!checkAttr(input->chars[pos], CTC_Punctuation, 0, table) ||\n\t\t\t\t\t\t\t\t(pos < (input->length - 1) &&\n\t\t\t\t\t\t\t\t\t\tcheckAttr(input->chars[pos + 1], CTC_Letter, 0,\n\t\t\t\t\t\t\t\t\t\t\t\ttable)))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tfor (k = pos; k >= 0; k--) {\n\t\t\t\t\t\t\tif (checkAttr(input->chars[k], (CTC_Letter | CTC_Digit), 0,\n\t\t\t\t\t\t\t\t\t\ttable))\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\tif (checkAttr(input->chars[k], CTC_Space, 0, table)) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CTO_Match: {\n\t\t\t\t\t\twidechar *patterns, *pattern;\n\n\t\t\t\t\t\tif (dontContract || (mode & noContractions)) break;\n\t\t\t\t\t\tif (checkEmphasisChange(0, pos, emphasisBuffer, *transRule))\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tpatterns = (widechar *)&table->ruleArea[(*transRule)->patterns];\n\n\t\t\t\t\t\t/* check before pattern */\n\t\t\t\t\t\tpattern = &patterns[1];\n\t\t\t\t\t\tif (!_lou_pattern_check(\n\t\t\t\t\t\t\t\t\tinput->chars, pos - 1, -1, -1, pattern, table))\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t/* check after pattern */\n\t\t\t\t\t\tpattern = &patterns[patterns[0]];\n\t\t\t\t\t\tif (!_lou_pattern_check(input->chars,\n\t\t\t\t\t\t\t\t\tpos + (*transRule)->charslen, input->length, 1,\n\t\t\t\t\t\t\t\t\tpattern, table))\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\t/* Done with checking this rule */\n\t\t\truleOffset = (*transRule)->charsnext;\n\t\t}\n\t}\n}\n\nstatic int\nundefinedCharacter(widechar c, const TranslationTableHeader *table, int pos,\n\t\tconst InString *input, OutString *output, int *posMapping, int *cursorPosition,\n\t\tint *cursorStatus) {\n\t/* Display an undefined character in the output buffer */\n\tint k;\n\tchar *display;\n\twidechar displayDots[20];\n\tif (table->undefined) {\n\t\tTranslationTableRule *rule =\n\t\t\t\t(TranslationTableRule *)&table->ruleArea[table->undefined];\n\t\tif (!for_updatePositions(&rule->charsdots[rule->charslen], rule->charslen,\n\t\t\t\t\trule->dotslen, 0, pos, input, output, posMapping, cursorPosition,\n\t\t\t\t\tcursorStatus))\n\t\t\treturn 0;\n\t\treturn 1;\n\t}\n\tdisplay = _lou_showString(&c, 1);\n\tfor (k = 0; k < (int)strlen(display); k++)\n\t\tdisplayDots[k] = _lou_getDotsForChar(display[k]);\n\tif (!for_updatePositions(displayDots, 1, (int)strlen(display), 0, pos, input, output,\n\t\t\t\tposMapping, cursorPosition, cursorStatus))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int\nputCharacter(widechar character, const TranslationTableHeader *table, int pos,\n\t\tconst InString *input, OutString *output, int *posMapping, int *cursorPosition,\n\t\tint *cursorStatus) {\n\t/* Insert the dots equivalent of a character into the output buffer */\n\tconst TranslationTableRule *rule = NULL;\n\tTranslationTableCharacter *chardef = NULL;\n\tTranslationTableOffset offset;\n\twidechar d;\n\tchardef = (findCharOrDots(character, 0, table));\n\tif ((chardef->attributes & CTC_Letter) && (chardef->attributes & CTC_UpperCase))\n\t\tchardef = findCharOrDots(chardef->lowercase, 0, table);\n\t// TODO: for_selectRule and this function screw up Digit and LitDigit\n\t// NOTE: removed Litdigit from tables.\n\t// if(!chardef->otherRules)\n\toffset = chardef->definitionRule;\n\t// else\n\t//{\n\t//\toffset = chardef->otherRules;\n\t//\trule = (TranslationTableRule *)&table->ruleArea[offset];\n\t//\twhile(rule->charsnext && rule->charsnext != chardef->definitionRule)\n\t//\t{\n\t//\t\trule = (TranslationTableRule *)&table->ruleArea[offset];\n\t//\t\tif(rule->charsnext)\n\t//\t\t\toffset = rule->charsnext;\n\t//\t}\n\t//}\n\tif (offset) {\n\t\trule = (TranslationTableRule *)&table->ruleArea[offset];\n\t\tif (rule->dotslen)\n\t\t\treturn for_updatePositions(&rule->charsdots[1], 1, rule->dotslen, 0, pos,\n\t\t\t\t\tinput, output, posMapping, cursorPosition, cursorStatus);\n\t\td = _lou_getDotsForChar(character);\n\t\treturn for_updatePositions(&d, 1, 1, 0, pos, input, output, posMapping,\n\t\t\t\tcursorPosition, cursorStatus);\n\t}\n\treturn undefinedCharacter(character, table, pos, input, output, posMapping,\n\t\t\tcursorPosition, cursorStatus);\n}\n\nstatic int\nputCharacters(const widechar *characters, int count, const TranslationTableHeader *table,\n\t\tint pos, const InString *input, OutString *output, int *posMapping,\n\t\tint *cursorPosition, int *cursorStatus) {\n\t/* Insert the dot equivalents of a series of characters in the output\n\t * buffer */\n\tint k;\n\tfor (k = 0; k < count; k++)\n\t\tif (!putCharacter(characters[k], table, pos, input, output, posMapping,\n\t\t\t\t\tcursorPosition, cursorStatus))\n\t\t\treturn 0;\n\treturn 1;\n}\n\nstatic int\ndoCompbrl(const TranslationTableHeader *table, int *pos, const InString *input,\n\t\tOutString *output, int *posMapping, EmphasisInfo *emphasisBuffer,\n\t\tconst TranslationTableRule **transRule, int *cursorPosition, int *cursorStatus,\n\t\tint destword, int srcword) {\n\t/* Handle strings containing substrings defined by the compbrl opcode */\n\tint stringStart, stringEnd;\n\tif (checkAttr(input->chars[*pos], CTC_Space, 0, table)) return 1;\n\tif (destword) {\n\t\t*pos = srcword;\n\t\toutput->length = destword;\n\t} else {\n\t\t*pos = 0;\n\t\toutput->length = 0;\n\t}\n\tfor (stringStart = *pos; stringStart >= 0; stringStart--)\n\t\tif (checkAttr(input->chars[stringStart], CTC_Space, 0, table)) break;\n\tstringStart++;\n\tfor (stringEnd = *pos; stringEnd < input->length; stringEnd++)\n\t\tif (checkAttr(input->chars[stringEnd], CTC_Space, 0, table)) break;\n\treturn doCompTrans(stringStart, stringEnd, table, pos, input, output, posMapping,\n\t\t\temphasisBuffer, transRule, cursorPosition, cursorStatus);\n}\n\nstatic int\nputCompChar(widechar character, const TranslationTableHeader *table, int pos,\n\t\tconst InString *input, OutString *output, int *posMapping, int *cursorPosition,\n\t\tint *cursorStatus) {\n\t/* Insert the dots equivalent of a character into the output buffer */\n\twidechar d;\n\tTranslationTableOffset offset = (findCharOrDots(character, 0, table))->definitionRule;\n\tif (offset) {\n\t\tconst TranslationTableRule *rule =\n\t\t\t\t(TranslationTableRule *)&table->ruleArea[offset];\n\t\tif (rule->dotslen)\n\t\t\treturn for_updatePositions(&rule->charsdots[1], 1, rule->dotslen, 0, pos,\n\t\t\t\t\tinput, output, posMapping, cursorPosition, cursorStatus);\n\t\td = _lou_getDotsForChar(character);\n\t\treturn for_updatePositions(&d, 1, 1, 0, pos, input, output, posMapping,\n\t\t\t\tcursorPosition, cursorStatus);\n\t}\n\treturn undefinedCharacter(character, table, pos, input, output, posMapping,\n\t\t\tcursorPosition, cursorStatus);\n}\n\nstatic int\ndoCompTrans(int start, int end, const TranslationTableHeader *table, int *pos,\n\t\tconst InString *input, OutString *output, int *posMapping,\n\t\tEmphasisInfo *emphasisBuffer, const TranslationTableRule **transRule,\n\t\tint *cursorPosition, int *cursorStatus) {\n\tconst TranslationTableRule *indicRule;\n\tint k;\n\tint haveEndsegment = 0;\n\tif (*cursorStatus != 2 && brailleIndicatorDefined(table->begComp, table, &indicRule))\n\t\tif (!for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0, *pos,\n\t\t\t\t\tinput, output, posMapping, cursorPosition, cursorStatus))\n\t\t\treturn 0;\n\tfor (k = start; k < end; k++) {\n\t\tTranslationTableOffset compdots = 0;\n\t\t/* HACK: computer braille is one-to-one so it\n\t\t * can't have any emphasis indicators.\n\t\t * A better solution is to treat computer braille as its own mode. */\n\t\temphasisBuffer[k] = (EmphasisInfo){ 0 };\n\t\tif (input->chars[k] == ENDSEGMENT) {\n\t\t\thaveEndsegment = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t*pos = k;\n\t\tif (input->chars[k] < 256) compdots = table->compdotsPattern[input->chars[k]];\n\t\tif (compdots != 0) {\n\t\t\t*transRule = (TranslationTableRule *)&table->ruleArea[compdots];\n\t\t\tif (!for_updatePositions(&(*transRule)->charsdots[(*transRule)->charslen],\n\t\t\t\t\t\t(*transRule)->charslen, (*transRule)->dotslen, 0, *pos, input,\n\t\t\t\t\t\toutput, posMapping, cursorPosition, cursorStatus))\n\t\t\t\treturn 0;\n\t\t} else if (!putCompChar(input->chars[k], table, *pos, input, output, posMapping,\n\t\t\t\t\t\t   cursorPosition, cursorStatus))\n\t\t\treturn 0;\n\t}\n\tif (*cursorStatus != 2 && brailleIndicatorDefined(table->endComp, table, &indicRule))\n\t\tif (!for_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0, *pos,\n\t\t\t\t\tinput, output, posMapping, cursorPosition, cursorStatus))\n\t\t\treturn 0;\n\t*pos = end;\n\tif (haveEndsegment) {\n\t\twidechar endSegment = ENDSEGMENT;\n\t\tif (!for_updatePositions(&endSegment, 0, 1, 0, *pos, input, output, posMapping,\n\t\t\t\t\tcursorPosition, cursorStatus))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int\ndoNocont(const TranslationTableHeader *table, int *pos, OutString *output, int mode,\n\t\tconst InString *input, int destword, int srcword, int *dontContract) {\n\t/* Handle strings containing substrings defined by the nocont opcode */\n\tif (checkAttr(input->chars[*pos], CTC_Space, 0, table) || *dontContract ||\n\t\t\t(mode & noContractions))\n\t\treturn 1;\n\tif (destword) {\n\t\t*pos = srcword;\n\t\toutput->length = destword;\n\t} else {\n\t\t*pos = 0;\n\t\toutput->length = 0;\n\t}\n\t*dontContract = 1;\n\treturn 1;\n}\n\nstatic int\nmarkSyllables(const TranslationTableHeader *table, const InString *input,\n\t\tformtype *typebuf, int *transOpcode, const TranslationTableRule **transRule,\n\t\tint *transCharslen) {\n\tint pos;\n\tint k;\n\tint currentMark = 0;\n\tint const syllable_marks[] = { SYLLABLE_MARKER_1, SYLLABLE_MARKER_2 };\n\tint syllable_mark_selector = 0;\n\n\tif (typebuf == NULL || !table->syllables) return 1;\n\tpos = 0;\n\twhile (pos < input->length) { /* the main multipass translation loop */\n\t\tint length = input->length - pos;\n\t\tconst TranslationTableCharacter *character =\n\t\t\t\tfindCharOrDots(input->chars[pos], 0, table);\n\t\tconst TranslationTableCharacter *character2;\n\t\tint tryThis = 0;\n\t\twhile (tryThis < 3) {\n\t\t\tTranslationTableOffset ruleOffset = 0;\n\t\t\tunsigned long int makeHash = 0;\n\t\t\tswitch (tryThis) {\n\t\t\tcase 0:\n\t\t\t\tif (!(length >= 2)) break;\n\t\t\t\tmakeHash = (unsigned long int)character->lowercase << 8;\n\t\t\t\t// memory overflow when pos == input->length - 1\n\t\t\t\tcharacter2 = findCharOrDots(input->chars[pos + 1], 0, table);\n\t\t\t\tmakeHash += (unsigned long int)character2->lowercase;\n\t\t\t\tmakeHash %= HASHNUM;\n\t\t\t\truleOffset = table->forRules[makeHash];\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif (!(length >= 1)) break;\n\t\t\t\tlength = 1;\n\t\t\t\truleOffset = character->otherRules;\n\t\t\t\tbreak;\n\t\t\tcase 2: /* No rule found */\n\t\t\t\t*transOpcode = CTO_Always;\n\t\t\t\truleOffset = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (ruleOffset) {\n\t\t\t\t*transRule = (TranslationTableRule *)&table->ruleArea[ruleOffset];\n\t\t\t\t*transOpcode = (*transRule)->opcode;\n\t\t\t\t*transCharslen = (*transRule)->charslen;\n\t\t\t\tif (tryThis == 1 ||\n\t\t\t\t\t\t(*transCharslen <= length &&\n\t\t\t\t\t\t\t\tcompareChars(&(*transRule)->charsdots[0],\n\t\t\t\t\t\t\t\t\t\t&input->chars[pos], *transCharslen, 0, table))) {\n\t\t\t\t\tif (*transOpcode == CTO_Syllable) {\n\t\t\t\t\t\ttryThis = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\truleOffset = (*transRule)->charsnext;\n\t\t\t}\n\t\t\ttryThis++;\n\t\t}\n\t\tswitch (*transOpcode) {\n\t\tcase CTO_Always:\n\t\t\tif (pos >= input->length) return 0;\n\t\t\ttypebuf[pos++] |= currentMark;\n\t\t\tbreak;\n\t\tcase CTO_Syllable:\n\t\t\t/* cycle between SYLLABLE_MARKER_1 and SYLLABLE_MARKER_2 so\n\t\t\t * we can distinguinsh two consequtive syllables */\n\t\t\tcurrentMark = syllable_marks[syllable_mark_selector];\n\t\t\tsyllable_mark_selector = (syllable_mark_selector + 1) % 2;\n\n\t\t\tif ((pos + *transCharslen) > input->length) return 0;\n\t\t\tfor (k = 0; k < *transCharslen; k++) typebuf[pos++] |= currentMark;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic const EmphasisClass capsEmphClass = 0x1;\nstatic const EmphasisClass *emphClasses = NULL;\n\n/* An emphasis class is a bit field that contains a single \"1\" */\nstatic void\ninitEmphClasses() {\n\tEmphasisClass *classes = malloc(10 * sizeof(EmphasisClass));\n\tint j;\n\tif (!classes) _lou_outOfMemory();\n\tfor (j = 0; j < 10; j++) {\n\t\tclasses[j] = 0x1 << (j + 1);\n\t}\n\temphClasses = classes;\n}\n\nstatic void\nresolveEmphasisWords(EmphasisInfo *buffer, const EmphasisClass class,\n\t\tconst InString *input, unsigned int *wordBuffer) {\n\tint in_word = 0, in_emp = 0, word_stop;  // booleans\n\tint word_start = -1;\t\t\t\t\t // input position\n\tunsigned int word_whole = 0;\t\t\t // wordBuffer value\n\tint i;\n\n\tfor (i = 0; i < input->length; i++) {\n\t\t// TODO: give each emphasis its own whole word bit?\n\t\t/* clear out previous whole word markings */\n\t\twordBuffer[i] &= ~WORD_WHOLE;\n\n\t\t/* check if at beginning of emphasis */\n\t\tif (!in_emp)\n\t\t\tif (buffer[i].begin & class) {\n\t\t\t\tin_emp = 1;\n\t\t\t\tbuffer[i].begin &= ~class;\n\n\t\t\t\t/* emphasis started inside word */\n\t\t\t\tif (in_word) {\n\t\t\t\t\tword_start = i;\n\t\t\t\t\tword_whole = 0;\n\t\t\t\t}\n\n\t\t\t\t/* emphasis started on space */\n\t\t\t\tif (!(wordBuffer[i] & WORD_CHAR)) word_start = -1;\n\t\t\t}\n\n\t\t/* check if at end of emphasis */\n\t\tif (in_emp)\n\t\t\tif (buffer[i].end & class) {\n\t\t\t\tin_emp = 0;\n\t\t\t\tbuffer[i].end &= ~class;\n\n\t\t\t\tif (in_word && word_start >= 0) {\n\t\t\t\t\t/* check if emphasis ended inside a word */\n\t\t\t\t\tword_stop = 1;\n\t\t\t\t\tif (wordBuffer[i] & WORD_CHAR)\n\t\t\t\t\t\tword_whole = 0;\n\t\t\t\t\telse\n\t\t\t\t\t\tword_stop = 0;\n\n\t\t\t\t\t/* if whole word is one symbol,\n\t\t\t\t\t * turn it into a symbol */\n\t\t\t\t\tif (word_start + 1 == i)\n\t\t\t\t\t\tbuffer[word_start].symbol |= class;\n\t\t\t\t\telse {\n\t\t\t\t\t\tbuffer[word_start].word |= class;\n\t\t\t\t\t\tif (word_stop) {\n\t\t\t\t\t\t\tbuffer[i].end |= class;\n\t\t\t\t\t\t\tbuffer[i].word |= class;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\twordBuffer[word_start] |= word_whole;\n\t\t\t\t}\n\t\t\t}\n\n\t\t/* check if at beginning of word */\n\t\tif (!in_word)\n\t\t\tif (wordBuffer[i] & WORD_CHAR) {\n\t\t\t\tin_word = 1;\n\t\t\t\tif (in_emp) {\n\t\t\t\t\tword_whole = WORD_WHOLE;\n\t\t\t\t\tword_start = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t/* check if at end of word */\n\t\tif (in_word)\n\t\t\tif (!(wordBuffer[i] & WORD_CHAR)) {\n\t\t\t\t/* made it through whole word */\n\t\t\t\tif (in_emp && word_start >= 0) {\n\t\t\t\t\t/* if word is one symbol,\n\t\t\t\t\t * turn it into a symbol */\n\t\t\t\t\tif (word_start + 1 == i)\n\t\t\t\t\t\tbuffer[word_start].symbol |= class;\n\t\t\t\t\telse\n\t\t\t\t\t\tbuffer[word_start].word |= class;\n\t\t\t\t\twordBuffer[word_start] |= word_whole;\n\t\t\t\t}\n\n\t\t\t\tin_word = 0;\n\t\t\t\tword_whole = 0;\n\t\t\t\tword_start = -1;\n\t\t\t}\n\t}\n\n\t/* clean up end */\n\tif (in_emp) {\n\t\tbuffer[i].end &= ~class;\n\n\t\tif (in_word)\n\t\t\tif (word_start >= 0) {\n\t\t\t\t/* if word is one symbol,\n\t\t\t\t * turn it into a symbol */\n\t\t\t\tif (word_start + 1 == i)\n\t\t\t\t\tbuffer[word_start].symbol |= class;\n\t\t\t\telse\n\t\t\t\t\tbuffer[word_start].word |= class;\n\t\t\t\twordBuffer[word_start] |= word_whole;\n\t\t\t}\n\t}\n}\n\nstatic void\nconvertToPassage(const int pass_start, const int pass_end, const int word_start,\n\t\tEmphasisInfo *buffer, const EmphRuleNumber emphRule, const EmphasisClass class,\n\t\tconst TranslationTableHeader *table, unsigned int *wordBuffer) {\n\tint i;\n\tconst TranslationTableRule *indicRule;\n\n\tfor (i = pass_start; i <= pass_end; i++)\n\t\tif (wordBuffer[i] & WORD_WHOLE) {\n\t\t\tbuffer[i].symbol &= ~class;\n\t\t\tbuffer[i].word &= ~class;\n\t\t\twordBuffer[i] &= ~WORD_WHOLE;\n\t\t}\n\n\tbuffer[pass_start].begin |= class;\n\tif (brailleIndicatorDefined(\n\t\t\t\ttable->emphRules[emphRule][endOffset], table, &indicRule) ||\n\t\t\tbrailleIndicatorDefined(\n\t\t\t\t\ttable->emphRules[emphRule][endPhraseAfterOffset], table, &indicRule))\n\t\tbuffer[pass_end].end |= class;\n\telse if (brailleIndicatorDefined(table->emphRules[emphRule][endPhraseBeforeOffset],\n\t\t\t\t\t table, &indicRule))\n\t\tbuffer[word_start].end |= class;\n}\n\nstatic void\nresolveEmphasisPassages(EmphasisInfo *buffer, const EmphRuleNumber emphRule,\n\t\tconst EmphasisClass class, const TranslationTableHeader *table,\n\t\tconst InString *input, unsigned int *wordBuffer) {\n\tunsigned int word_cnt = 0;\n\tint pass_start = -1, pass_end = -1, word_start = -1, in_word = 0, in_pass = 0;\n\tint i;\n\n\tfor (i = 0; i < input->length; i++) {\n\t\t/* check if at beginning of word */\n\t\tif (!in_word)\n\t\t\tif (wordBuffer[i] & WORD_CHAR) {\n\t\t\t\tin_word = 1;\n\t\t\t\tif (wordBuffer[i] & WORD_WHOLE) {\n\t\t\t\t\tif (!in_pass) {\n\t\t\t\t\t\tin_pass = 1;\n\t\t\t\t\t\tpass_start = i;\n\t\t\t\t\t\tpass_end = -1;\n\t\t\t\t\t\tword_cnt = 1;\n\t\t\t\t\t} else\n\t\t\t\t\t\tword_cnt++;\n\t\t\t\t\tword_start = i;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (in_pass) {\n\t\t\t\t\tif (word_cnt >= table->emphRules[emphRule][lenPhraseOffset])\n\t\t\t\t\t\tif (pass_end >= 0) {\n\t\t\t\t\t\t\tconvertToPassage(pass_start, pass_end, word_start, buffer,\n\t\t\t\t\t\t\t\t\temphRule, class, table, wordBuffer);\n\t\t\t\t\t\t}\n\t\t\t\t\tin_pass = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t/* check if at end of word */\n\t\tif (in_word)\n\t\t\tif (!(wordBuffer[i] & WORD_CHAR)) {\n\t\t\t\tin_word = 0;\n\t\t\t\tif (in_pass) pass_end = i;\n\t\t\t}\n\n\t\tif (in_pass)\n\t\t\tif ((buffer[i].begin | buffer[i].end | buffer[i].word | buffer[i].symbol) &\n\t\t\t\t\tclass) {\n\t\t\t\tif (word_cnt >= table->emphRules[emphRule][lenPhraseOffset])\n\t\t\t\t\tif (pass_end >= 0) {\n\t\t\t\t\t\tconvertToPassage(pass_start, pass_end, word_start, buffer,\n\t\t\t\t\t\t\t\temphRule, class, table, wordBuffer);\n\t\t\t\t\t}\n\t\t\t\tin_pass = 0;\n\t\t\t}\n\t}\n\n\tif (in_pass) {\n\t\tif (word_cnt >= table->emphRules[emphRule][lenPhraseOffset]) {\n\t\t\tif (pass_end >= 0) {\n\t\t\t\tif (in_word) {\n\t\t\t\t\tconvertToPassage(pass_start, i, word_start, buffer, emphRule, class,\n\t\t\t\t\t\t\ttable, wordBuffer);\n\t\t\t\t} else {\n\t\t\t\t\tconvertToPassage(pass_start, pass_end, word_start, buffer, emphRule,\n\t\t\t\t\t\t\tclass, table, wordBuffer);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void\nresolveEmphasisSingleSymbols(\n\t\tEmphasisInfo *buffer, const EmphasisClass class, const InString *input) {\n\tint i;\n\n\tfor (i = 0; i < input->length; i++) {\n\t\tif (buffer[i].begin & class)\n\t\t\tif (buffer[i + 1].end & class) {\n\t\t\t\tbuffer[i].begin &= ~class;\n\t\t\t\tbuffer[i + 1].end &= ~class;\n\t\t\t\tbuffer[i].symbol |= class;\n\t\t\t}\n\t}\n}\n\nstatic void\nresolveEmphasisAllCapsSymbols(\n\t\tEmphasisInfo *buffer, formtype *typebuf, const InString *input) {\n\t/* Marks every caps letter with capsEmphClass symbol.\n\t * Used in the special case where capsnocont has been defined and capsword has not\n\t * been defined. */\n\n\tint inEmphasis = 0, i;\n\n\tfor (i = 0; i < input->length; i++) {\n\t\tif (buffer[i].end & capsEmphClass) {\n\t\t\tinEmphasis = 0;\n\t\t\tbuffer[i].end &= ~capsEmphClass;\n\t\t} else {\n\t\t\tif (buffer[i].begin & capsEmphClass) {\n\t\t\t\tbuffer[i].begin &= ~capsEmphClass;\n\t\t\t\tinEmphasis = 1;\n\t\t\t}\n\t\t\tif (inEmphasis) {\n\t\t\t\tif (typebuf[i] & CAPSEMPH)\n\t\t\t\t\t/* Only mark if actually a capital letter (don't mark spaces or\n\t\t\t\t\t * punctuation). */\n\t\t\t\t\tbuffer[i].symbol |= capsEmphClass;\n\t\t\t} /* In emphasis */\n\t\t}\t /* Not caps end */\n\t}\n}\n\nstatic void\nresolveEmphasisResets(EmphasisInfo *buffer, const EmphasisClass class,\n\t\tconst TranslationTableHeader *table, const InString *input,\n\t\tunsigned int *wordBuffer) {\n\tint in_word = 0, in_pass = 0, word_start = -1, word_reset = 0, orig_reset = -1,\n\t\tletter_cnt = 0;\n\tint i, j;\n\n\tfor (i = 0; i < input->length; i++) {\n\t\tif (in_pass)\n\t\t\tif (buffer[i].end & class) in_pass = 0;\n\n\t\tif (!in_pass) {\n\t\t\tif (buffer[i].begin & class)\n\t\t\t\tin_pass = 1;\n\t\t\telse {\n\t\t\t\tif (!in_word) {\n\t\t\t\t\tif (buffer[i].word & class) {\n\t\t\t\t\t\t/* deal with case when reset\n\t\t\t\t\t\t * was at beginning of word */\n\t\t\t\t\t\tif (wordBuffer[i] & WORD_RESET ||\n\t\t\t\t\t\t\t\t!checkAttr(input->chars[i], CTC_Letter, 0, table)) {\n\t\t\t\t\t\t\t/* not just one reset by itself */\n\t\t\t\t\t\t\tif (wordBuffer[i + 1] & WORD_CHAR) {\n\t\t\t\t\t\t\t\tbuffer[i + 1].word |= class;\n\t\t\t\t\t\t\t\tif (wordBuffer[i] & WORD_WHOLE)\n\t\t\t\t\t\t\t\t\twordBuffer[i + 1] |= WORD_WHOLE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbuffer[i].word &= ~class;\n\t\t\t\t\t\t\twordBuffer[i] &= ~WORD_WHOLE;\n\n\t\t\t\t\t\t\t/* if reset is a letter, make it a symbol */\n\t\t\t\t\t\t\tif (checkAttr(input->chars[i], CTC_Letter, 0, table))\n\t\t\t\t\t\t\t\tbuffer[i].symbol |= class;\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tin_word = 1;\n\t\t\t\t\t\tword_start = i;\n\t\t\t\t\t\tletter_cnt = 0;\n\t\t\t\t\t\tword_reset = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* it is possible for a character to have been\n\t\t\t\t\t * marked as a symbol when it should not be one */\n\t\t\t\t\telse if (buffer[i].symbol & class) {\n\t\t\t\t\t\tif (wordBuffer[i] & WORD_RESET ||\n\t\t\t\t\t\t\t\t!checkAttr(input->chars[i], CTC_Letter, 0, table))\n\t\t\t\t\t\t\tbuffer[i].symbol &= ~class;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (in_word) {\n\n\t\t\t\t\t/* at end of word */\n\t\t\t\t\tif (!(wordBuffer[i] & WORD_CHAR) ||\n\t\t\t\t\t\t\t(buffer[i].word & class && buffer[i].end & class)) {\n\t\t\t\t\t\tin_word = 0;\n\n\t\t\t\t\t\t/* check if symbol */\n\t\t\t\t\t\tif (letter_cnt == 1) {\n\t\t\t\t\t\t\tbuffer[word_start].symbol |= class;\n\t\t\t\t\t\t\tbuffer[word_start].word &= ~class;\n\t\t\t\t\t\t\twordBuffer[word_start] &= ~WORD_WHOLE;\n\t\t\t\t\t\t\tbuffer[i].end &= ~class;\n\t\t\t\t\t\t\tbuffer[i].word &= ~class;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* if word ended on a reset or last char was a reset,\n\t\t\t\t\t\t * get rid of end bits */\n\t\t\t\t\t\tif (word_reset || wordBuffer[i] & WORD_RESET ||\n\t\t\t\t\t\t\t\t!checkAttr(input->chars[i], CTC_Letter, 0, table)) {\n\t\t\t\t\t\t\tbuffer[i].end &= ~class;\n\t\t\t\t\t\t\tbuffer[i].word &= ~class;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* if word ended when it began, get rid of all bits */\n\t\t\t\t\t\tif (i == word_start) {\n\t\t\t\t\t\t\twordBuffer[word_start] &= ~WORD_WHOLE;\n\t\t\t\t\t\t\tbuffer[i].end &= ~class;\n\t\t\t\t\t\t\tbuffer[i].word &= ~class;\n\t\t\t\t\t\t}\n\t\t\t\t\t\torig_reset = -1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* hit reset */\n\t\t\t\t\t\tif (wordBuffer[i] & WORD_RESET ||\n\t\t\t\t\t\t\t\t!checkAttr(input->chars[i], CTC_Letter, 0, table)) {\n\t\t\t\t\t\t\tif (!checkAttr(input->chars[i], CTC_Letter, 0, table)) {\n\t\t\t\t\t\t\t\tif (checkAttr(input->chars[i], CTC_CapsMode, 0, table)) {\n\t\t\t\t\t\t\t\t\t/* chars marked as not resetting */\n\t\t\t\t\t\t\t\t\torig_reset = i;\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t} else if (orig_reset >= 0) {\n\t\t\t\t\t\t\t\t\t/* invalid no reset sequence */\n\t\t\t\t\t\t\t\t\tfor (j = orig_reset; j < i; j++)\n\t\t\t\t\t\t\t\t\t\tbuffer[j].word &= ~class;\n\t\t\t\t\t\t\t\t\t// word_reset = 1;\n\t\t\t\t\t\t\t\t\torig_reset = -1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* check if symbol is not already resetting */\n\t\t\t\t\t\t\tif (letter_cnt == 1) {\n\t\t\t\t\t\t\t\tbuffer[word_start].symbol |= class;\n\t\t\t\t\t\t\t\tbuffer[word_start].word &= ~class;\n\t\t\t\t\t\t\t\twordBuffer[word_start] &= ~WORD_WHOLE;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* if reset is a letter, make it the new word_start */\n\t\t\t\t\t\t\tif (checkAttr(input->chars[i], CTC_Letter, 0, table)) {\n\t\t\t\t\t\t\t\tword_reset = 0;\n\t\t\t\t\t\t\t\tword_start = i;\n\t\t\t\t\t\t\t\tletter_cnt = 1;\n\t\t\t\t\t\t\t\tbuffer[i].word |= class;\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tword_reset = 1;\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (word_reset) {\n\t\t\t\t\t\t\tword_reset = 0;\n\t\t\t\t\t\t\tword_start = i;\n\t\t\t\t\t\t\tletter_cnt = 0;\n\t\t\t\t\t\t\tbuffer[i].word |= class;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tletter_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* clean up end */\n\tif (in_word) {\n\t\t/* check if symbol */\n\t\tif (letter_cnt == 1) {\n\t\t\tbuffer[word_start].symbol |= class;\n\t\t\tbuffer[word_start].word &= ~class;\n\t\t\twordBuffer[word_start] &= ~WORD_WHOLE;\n\t\t\tbuffer[i].end &= ~class;\n\t\t\tbuffer[i].word &= ~class;\n\t\t}\n\n\t\tif (word_reset) {\n\t\t\tbuffer[i].end &= ~class;\n\t\t\tbuffer[i].word &= ~class;\n\t\t}\n\t}\n}\n\nstatic void\nmarkEmphases(const TranslationTableHeader *table, const InString *input,\n\t\tformtype *typebuf, unsigned int *wordBuffer, EmphasisInfo *emphasisBuffer,\n\t\tint haveEmphasis) {\n\t/* Relies on the order of typeforms emph_1..emph_10. */\n\tint caps_start = -1, last_caps = -1, caps_cnt = 0;\n\tint emph_start[10] = { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 };\n\tint i, j;\n\n\t// initialize static variable emphClasses\n\tif (haveEmphasis && !emphClasses) {\n\t\tinitEmphClasses();\n\t}\n\n\tfor (i = 0; i < input->length; i++) {\n\t\tif (!checkAttr(input->chars[i], CTC_Space, 0, table)) {\n\t\t\twordBuffer[i] |= WORD_CHAR;\n\t\t} else if (caps_cnt > 0) {\n\t\t\tlast_caps = i;\n\t\t\tcaps_cnt = 0;\n\t\t}\n\n\t\tif (checkAttr(input->chars[i], CTC_UpperCase, 0, table)) {\n\t\t\tif (caps_start < 0) caps_start = i;\n\t\t\tcaps_cnt++;\n\t\t} else if (caps_start >= 0) {\n\t\t\t/* caps should keep going until this */\n\t\t\tif (checkAttr(input->chars[i], CTC_Letter, 0, table) &&\n\t\t\t\t\tcheckAttr(input->chars[i], CTC_LowerCase, 0, table)) {\n\t\t\t\temphasisBuffer[caps_start].begin |= capsEmphClass;\n\t\t\t\tif (caps_cnt > 0)\n\t\t\t\t\temphasisBuffer[i].end |= capsEmphClass;\n\t\t\t\telse\n\t\t\t\t\temphasisBuffer[last_caps].end |= capsEmphClass;\n\t\t\t\tcaps_start = -1;\n\t\t\t\tlast_caps = -1;\n\t\t\t\tcaps_cnt = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (!haveEmphasis) continue;\n\n\t\tfor (j = 0; j < 10; j++) {\n\t\t\tif (typebuf[i] & (emph_1 << j)) {\n\t\t\t\tif (emph_start[j] < 0) emph_start[j] = i;\n\t\t\t} else if (emph_start[j] >= 0) {\n\t\t\t\temphasisBuffer[emph_start[j]].begin |= emphClasses[j];\n\t\t\t\temphasisBuffer[i].end |= emphClasses[j];\n\t\t\t\temph_start[j] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* clean up input->length */\n\tif (caps_start >= 0) {\n\t\temphasisBuffer[caps_start].begin |= capsEmphClass;\n\t\tif (caps_cnt > 0)\n\t\t\temphasisBuffer[input->length].end |= capsEmphClass;\n\t\telse\n\t\t\temphasisBuffer[last_caps].end |= capsEmphClass;\n\t}\n\n\tif (haveEmphasis) {\n\t\tfor (j = 0; j < 10; j++) {\n\t\t\tif (emph_start[j] >= 0) {\n\t\t\t\temphasisBuffer[emph_start[j]].begin |= emphClasses[j];\n\t\t\t\temphasisBuffer[input->length].end |= emphClasses[j];\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Handle capsnocont */\n\tif (table->capsNoCont) {\n\t\tint inCaps = 0;\n\t\tfor (i = 0; i < input->length; i++) {\n\t\t\tif (emphasisBuffer[i].end & capsEmphClass) {\n\t\t\t\tinCaps = 0;\n\t\t\t} else {\n\t\t\t\tif ((emphasisBuffer[i].begin & capsEmphClass) &&\n\t\t\t\t\t\t!(emphasisBuffer[i + 1].end & capsEmphClass))\n\t\t\t\t\tinCaps = 1;\n\t\t\t\tif (inCaps) typebuf[i] |= no_contract;\n\t\t\t}\n\t\t}\n\t}\n\tif (table->emphRules[capsRule][begWordOffset]) {\n\t\tresolveEmphasisWords(emphasisBuffer, capsEmphClass, input, wordBuffer);\n\t\tif (table->emphRules[capsRule][lenPhraseOffset])\n\t\t\tresolveEmphasisPassages(\n\t\t\t\t\temphasisBuffer, capsRule, capsEmphClass, table, input, wordBuffer);\n\t\tresolveEmphasisResets(emphasisBuffer, capsEmphClass, table, input, wordBuffer);\n\t} else if (table->emphRules[capsRule][letterOffset]) {\n\t\tif (table->capsNoCont) /* capsnocont and no capsword */\n\t\t\tresolveEmphasisAllCapsSymbols(emphasisBuffer, typebuf, input);\n\t\telse\n\t\t\tresolveEmphasisSingleSymbols(emphasisBuffer, capsEmphClass, input);\n\t}\n\tif (!haveEmphasis) return;\n\n\tfor (j = 0; j < 10; j++) {\n\t\tif (table->emphRules[emph1Rule + j][begWordOffset]) {\n\t\t\tresolveEmphasisWords(emphasisBuffer, emphClasses[j], input, wordBuffer);\n\t\t\tif (table->emphRules[emph1Rule + j][lenPhraseOffset])\n\t\t\t\tresolveEmphasisPassages(emphasisBuffer, emph1Rule + j, emphClasses[j],\n\t\t\t\t\t\ttable, input, wordBuffer);\n\t\t} else if (table->emphRules[emph1Rule + j][letterOffset])\n\t\t\tresolveEmphasisSingleSymbols(emphasisBuffer, emphClasses[j], input);\n\t}\n}\n\nstatic void\ninsertEmphasisSymbol(const EmphasisInfo *buffer, const int at,\n\t\tconst EmphRuleNumber emphRule, const EmphasisClass class,\n\t\tconst TranslationTableHeader *table, int pos, const InString *input,\n\t\tOutString *output, int *posMapping, int *cursorPosition, int *cursorStatus) {\n\tif (buffer[at].symbol & class) {\n\t\tconst TranslationTableRule *indicRule;\n\t\tif (brailleIndicatorDefined(\n\t\t\t\t\ttable->emphRules[emphRule][letterOffset], table, &indicRule))\n\t\t\tfor_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0, pos,\n\t\t\t\t\tinput, output, posMapping, cursorPosition, cursorStatus);\n\t}\n}\n\nstatic void\ninsertEmphasisBegin(const EmphasisInfo *buffer, const int at,\n\t\tconst EmphRuleNumber emphRule, const EmphasisClass class,\n\t\tconst TranslationTableHeader *table, int pos, const InString *input,\n\t\tOutString *output, int *posMapping, int *cursorPosition, int *cursorStatus) {\n\tconst TranslationTableRule *indicRule;\n\tif (buffer[at].begin & class) {\n\t\tif (brailleIndicatorDefined(\n\t\t\t\t\ttable->emphRules[emphRule][begPhraseOffset], table, &indicRule))\n\t\t\tfor_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0, pos,\n\t\t\t\t\tinput, output, posMapping, cursorPosition, cursorStatus);\n\t\telse if (brailleIndicatorDefined(\n\t\t\t\t\t\t table->emphRules[emphRule][begOffset], table, &indicRule))\n\t\t\tfor_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0, pos,\n\t\t\t\t\tinput, output, posMapping, cursorPosition, cursorStatus);\n\t}\n\n\tif (buffer[at].word & class\n\t\t\t// && !(buffer[at].begin & class)\n\t\t\t&& !(buffer[at].end & class)) {\n\t\tif (brailleIndicatorDefined(\n\t\t\t\t\ttable->emphRules[emphRule][begWordOffset], table, &indicRule))\n\t\t\tfor_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0, pos,\n\t\t\t\t\tinput, output, posMapping, cursorPosition, cursorStatus);\n\t}\n}\n\nstatic void\ninsertEmphasisEnd(const EmphasisInfo *buffer, const int at, const EmphRuleNumber emphRule,\n\t\tconst EmphasisClass class, const TranslationTableHeader *table, int pos,\n\t\tconst InString *input, OutString *output, int *posMapping, int *cursorPosition,\n\t\tint *cursorStatus) {\n\tif (buffer[at].end & class) {\n\t\tconst TranslationTableRule *indicRule;\n\t\tif (buffer[at].word & class) {\n\t\t\tif (brailleIndicatorDefined(\n\t\t\t\t\t\ttable->emphRules[emphRule][endWordOffset], table, &indicRule))\n\t\t\t\tfor_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, -1,\n\t\t\t\t\t\tpos, input, output, posMapping, cursorPosition, cursorStatus);\n\t\t} else {\n\t\t\tif (brailleIndicatorDefined(\n\t\t\t\t\t\ttable->emphRules[emphRule][endOffset], table, &indicRule))\n\t\t\t\tfor_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, -1,\n\t\t\t\t\t\tpos, input, output, posMapping, cursorPosition, cursorStatus);\n\t\t\telse if (brailleIndicatorDefined(\n\t\t\t\t\t\t\t table->emphRules[emphRule][endPhraseAfterOffset], table,\n\t\t\t\t\t\t\t &indicRule))\n\t\t\t\tfor_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, -1,\n\t\t\t\t\t\tpos, input, output, posMapping, cursorPosition, cursorStatus);\n\t\t\telse if (brailleIndicatorDefined(\n\t\t\t\t\t\t\t table->emphRules[emphRule][endPhraseBeforeOffset], table,\n\t\t\t\t\t\t\t &indicRule))\n\t\t\t\tfor_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0,\n\t\t\t\t\t\tpos, input, output, posMapping, cursorPosition, cursorStatus);\n\t\t}\n\t}\n}\n\nstatic int\nendCount(const EmphasisInfo *buffer, const int at, const EmphasisClass class) {\n\tint i, cnt = 1;\n\tif (!(buffer[at].end & class)) return 0;\n\tfor (i = at - 1; i >= 0; i--)\n\t\tif (buffer[i].begin & class || buffer[i].word & class)\n\t\t\tbreak;\n\t\telse\n\t\t\tcnt++;\n\treturn cnt;\n}\n\nstatic int\nbeginCount(const EmphasisInfo *buffer, const int at, const EmphasisClass class,\n\t\tconst TranslationTableHeader *table, const InString *input) {\n\tif (buffer[at].begin & class) {\n\t\tint i, cnt = 1;\n\t\tfor (i = at + 1; i < input->length; i++)\n\t\t\tif (buffer[i].end & class)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tcnt++;\n\t\treturn cnt;\n\t} else if (buffer[at].word & class) {\n\t\tint i, cnt = 1;\n\t\tfor (i = at + 1; i < input->length; i++)\n\t\t\tif (buffer[i].end & class) break;\n\t\t\t// TODO: WORD_RESET?\n\t\t\telse if (checkAttr(input->chars[i], CTC_SeqDelimiter | CTC_Space, 0, table))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tcnt++;\n\t\treturn cnt;\n\t}\n\treturn 0;\n}\n\nstatic void\ninsertEmphasesAt(const int at, const TranslationTableHeader *table, int pos,\n\t\tconst InString *input, OutString *output, int *posMapping,\n\t\tconst EmphasisInfo *emphasisBuffer, int haveEmphasis, int transOpcode,\n\t\tint *cursorPosition, int *cursorStatus) {\n\tint type_counts[10];\n\tint i, j, min, max;\n\n\t/* simple case */\n\tif (!haveEmphasis) {\n\t\t/* insert graded 1 mode indicator */\n\t\tif (transOpcode == CTO_Contraction) {\n\t\t\tconst TranslationTableRule *indicRule;\n\t\t\tif (brailleIndicatorDefined(table->noContractSign, table, &indicRule))\n\t\t\t\tfor_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0,\n\t\t\t\t\t\tpos, input, output, posMapping, cursorPosition, cursorStatus);\n\t\t}\n\n\t\tif ((emphasisBuffer[at].begin | emphasisBuffer[at].end | emphasisBuffer[at].word |\n\t\t\t\t\temphasisBuffer[at].symbol) &\n\t\t\t\tcapsEmphClass) {\n\t\t\tinsertEmphasisEnd(emphasisBuffer, at, capsRule, capsEmphClass, table, pos,\n\t\t\t\t\tinput, output, posMapping, cursorPosition, cursorStatus);\n\t\t\tinsertEmphasisBegin(emphasisBuffer, at, capsRule, capsEmphClass, table, pos,\n\t\t\t\t\tinput, output, posMapping, cursorPosition, cursorStatus);\n\t\t\tinsertEmphasisSymbol(emphasisBuffer, at, capsRule, capsEmphClass, table, pos,\n\t\t\t\t\tinput, output, posMapping, cursorPosition, cursorStatus);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* The order of inserting the end symbols must be the reverse\n\t * of the insertions of the begin symbols so that they will\n\t * nest properly when multiple emphases start and end at\n\t * the same place */\n\t// TODO: ordering with partial word\n\n\tif ((emphasisBuffer[at].begin | emphasisBuffer[at].end | emphasisBuffer[at].word |\n\t\t\t\temphasisBuffer[at].symbol) &\n\t\t\tcapsEmphClass)\n\t\tinsertEmphasisEnd(emphasisBuffer, at, capsRule, capsEmphClass, table, pos, input,\n\t\t\t\toutput, posMapping, cursorPosition, cursorStatus);\n\n\t/* end bits */\n\tfor (i = 0; i < 10; i++)\n\t\ttype_counts[i] = endCount(emphasisBuffer, at, emphClasses[i]);\n\n\tfor (i = 0; i < 10; i++) {\n\t\tmin = -1;\n\t\tfor (j = 0; j < 10; j++)\n\t\t\tif (type_counts[j] > 0)\n\t\t\t\tif (min < 0 || type_counts[j] < type_counts[min]) min = j;\n\t\tif (min < 0) break;\n\t\ttype_counts[min] = 0;\n\t\tinsertEmphasisEnd(emphasisBuffer, at, emph1Rule + min, emphClasses[min], table,\n\t\t\t\tpos, input, output, posMapping, cursorPosition, cursorStatus);\n\t}\n\n\t/* begin and word bits */\n\tfor (i = 0; i < 10; i++)\n\t\ttype_counts[i] = beginCount(emphasisBuffer, at, emphClasses[i], table, input);\n\n\tfor (i = 9; i >= 0; i--) {\n\t\tmax = 9;\n\t\tfor (j = 9; j >= 0; j--)\n\t\t\tif (type_counts[max] < type_counts[j]) max = j;\n\t\tif (!type_counts[max]) break;\n\t\ttype_counts[max] = 0;\n\t\tinsertEmphasisBegin(emphasisBuffer, at, emph1Rule + max, emphClasses[max], table,\n\t\t\t\tpos, input, output, posMapping, cursorPosition, cursorStatus);\n\t}\n\n\t/* symbol bits */\n\tfor (i = 9; i >= 0; i--)\n\t\tif ((emphasisBuffer[at].begin | emphasisBuffer[at].end | emphasisBuffer[at].word |\n\t\t\t\t\temphasisBuffer[at].symbol) &\n\t\t\t\temphClasses[i])\n\t\t\tinsertEmphasisSymbol(emphasisBuffer, at, emph1Rule + i, emphClasses[i], table,\n\t\t\t\t\tpos, input, output, posMapping, cursorPosition, cursorStatus);\n\n\t/* insert graded 1 mode indicator */\n\tif (transOpcode == CTO_Contraction) {\n\t\tconst TranslationTableRule *indicRule;\n\t\tif (brailleIndicatorDefined(table->noContractSign, table, &indicRule))\n\t\t\tfor_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0, pos,\n\t\t\t\t\tinput, output, posMapping, cursorPosition, cursorStatus);\n\t}\n\n\t/* insert capitalization last so it will be closest to word */\n\tif ((emphasisBuffer[at].begin | emphasisBuffer[at].end | emphasisBuffer[at].word |\n\t\t\t\temphasisBuffer[at].symbol) &\n\t\t\tcapsEmphClass) {\n\t\tinsertEmphasisBegin(emphasisBuffer, at, capsRule, capsEmphClass, table, pos,\n\t\t\t\tinput, output, posMapping, cursorPosition, cursorStatus);\n\t\tinsertEmphasisSymbol(emphasisBuffer, at, capsRule, capsEmphClass, table, pos,\n\t\t\t\tinput, output, posMapping, cursorPosition, cursorStatus);\n\t}\n}\n\nstatic void\ninsertEmphases(const TranslationTableHeader *table, int pos, const InString *input,\n\t\tOutString *output, int *posMapping, const EmphasisInfo *emphasisBuffer,\n\t\tint haveEmphasis, int transOpcode, int *cursorPosition, int *cursorStatus,\n\t\tint *pre_src) {\n\tint at;\n\n\tfor (at = *pre_src; at <= pos; at++)\n\t\tinsertEmphasesAt(at, table, pos, input, output, posMapping, emphasisBuffer,\n\t\t\t\thaveEmphasis, transOpcode, cursorPosition, cursorStatus);\n\n\t*pre_src = pos + 1;\n}\n\nstatic void\ncheckNumericMode(const TranslationTableHeader *table, int pos, const InString *input,\n\t\tOutString *output, int *posMapping, int *cursorPosition, int *cursorStatus,\n\t\tint *dontContract, int *numericMode) {\n\tint i;\n\tconst TranslationTableRule *indicRule;\n\tif (!brailleIndicatorDefined(table->numberSign, table, &indicRule)) return;\n\n\t/* not in numeric mode */\n\tif (!*numericMode) {\n\t\tif (checkAttr(input->chars[pos], CTC_Digit | CTC_LitDigit, 0, table)) {\n\t\t\t*numericMode = 1;\n\t\t\t*dontContract = 1;\n\t\t\tfor_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen, 0, pos,\n\t\t\t\t\tinput, output, posMapping, cursorPosition, cursorStatus);\n\t\t} else if (checkAttr(input->chars[pos], CTC_NumericMode, 0, table)) {\n\t\t\tfor (i = pos + 1; i < input->length; i++) {\n\t\t\t\tif (checkAttr(input->chars[i], CTC_Digit | CTC_LitDigit, 0, table)) {\n\t\t\t\t\t*numericMode = 1;\n\t\t\t\t\tfor_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen,\n\t\t\t\t\t\t\t0, pos, input, output, posMapping, cursorPosition,\n\t\t\t\t\t\t\tcursorStatus);\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (!checkAttr(input->chars[i], CTC_NumericMode, 0, table))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* in numeric mode */\n\telse {\n\t\tif (!checkAttr(input->chars[pos],\n\t\t\t\t\tCTC_Digit | CTC_LitDigit | CTC_NumericMode | CTC_MidEndNumericMode, 0,\n\t\t\t\t\ttable)) {\n\t\t\t*numericMode = 0;\n\t\t\tif (brailleIndicatorDefined(table->noContractSign, table, &indicRule))\n\t\t\t\tif (checkAttr(input->chars[pos], CTC_NumericNoContract, 0, table))\n\t\t\t\t\tfor_updatePositions(&indicRule->charsdots[0], 0, indicRule->dotslen,\n\t\t\t\t\t\t\t0, pos, input, output, posMapping, cursorPosition,\n\t\t\t\t\t\t\tcursorStatus);\n\t\t}\n\t}\n}\n\nstatic int\ntranslateString(const TranslationTableHeader *table, int mode, int currentPass,\n\t\tconst InString *input, OutString *output, int *posMapping, formtype *typebuf,\n\t\tunsigned char *srcSpacing, unsigned char *destSpacing, unsigned int *wordBuffer,\n\t\tEmphasisInfo *emphasisBuffer, int haveEmphasis, int *realInlen,\n\t\tint *posIncremented, int *cursorPosition, int *cursorStatus, int compbrlStart,\n\t\tint compbrlEnd) {\n\tint pos;\n\tint transOpcode;\n\tint prevTransOpcode;\n\tconst TranslationTableRule *transRule;\n\tint transCharslen;\n\tint passCharDots;\n\tconst widechar *passInstructions;\n\tint passIC; /* Instruction counter */\n\tPassRuleMatch patternMatch;\n\tTranslationTableRule *groupingRule;\n\twidechar groupingOp;\n\tint numericMode;\n\tint dontContract;\n\tint destword;\n\tint srcword;\n\tint pre_src;\n\tTranslationTableCharacter *curCharDef;\n\tconst widechar *repwordStart;\n\tint repwordLength;\n\tint curType;\n\tint prevType;\n\tint prevTypeform;\n\tint prevPos;\n\tconst InString *origInput = input;\n\t/* Main translation routine */\n\tint k;\n\ttranslation_direction = 1;\n\tmarkSyllables(table, input, typebuf, &transOpcode, &transRule, &transCharslen);\n\tnumericMode = 0;\n\tsrcword = 0;\n\tdestword = 0; /* last word translated */\n\tdontContract = 0;\n\tprevTransOpcode = CTO_None;\n\tprevType = curType = prevTypeform = plain_text;\n\tprevPos = -1;\n\tpos = output->length = 0;\n\t*posIncremented = 1;\n\tpre_src = 0;\n\t_lou_resetPassVariables();\n\tif (typebuf && table->emphRules[capsRule][letterOffset])\n\t\tfor (k = 0; k < input->length; k++)\n\t\t\tif (checkAttr(input->chars[k], CTC_UpperCase, 0, table))\n\t\t\t\ttypebuf[k] |= CAPSEMPH;\n\n\tmarkEmphases(table, input, typebuf, wordBuffer, emphasisBuffer, haveEmphasis);\n\n\twhile (pos < input->length) { /* the main translation loop */\n\t\tif ((pos >= compbrlStart) && (pos < compbrlEnd)) {\n\t\t\tint cs = 2;  // cursor status for this call\n\t\t\tif (!doCompTrans(pos, compbrlEnd, table, &pos, input, output, posMapping,\n\t\t\t\t\t\temphasisBuffer, &transRule, cursorPosition, &cs))\n\t\t\t\tgoto failure;\n\t\t\tcontinue;\n\t\t}\n\t\tTranslationTableCharacterAttributes beforeAttributes;\n\t\tsetBefore(table, pos, input, &beforeAttributes);\n\t\tif (!insertBrailleIndicators(0, table, pos, input, output, posMapping, typebuf,\n\t\t\t\t\thaveEmphasis, transOpcode, prevTransOpcode, cursorPosition,\n\t\t\t\t\tcursorStatus, beforeAttributes, &prevType, &curType, &prevTypeform,\n\t\t\t\t\tprevPos))\n\t\t\tgoto failure;\n\t\tif (pos >= input->length) break;\n\n\t\t// insertEmphases();\n\t\tif (!dontContract) dontContract = typebuf[pos] & no_contract;\n\t\tif (typebuf[pos] & no_translate) {\n\t\t\twidechar c = _lou_getDotsForChar(input->chars[pos]);\n\t\t\tif (input->chars[pos] < 32 || input->chars[pos] > 126) goto failure;\n\t\t\tif (!for_updatePositions(&c, 1, 1, 0, pos, input, output, posMapping,\n\t\t\t\t\t\tcursorPosition, cursorStatus))\n\t\t\t\tgoto failure;\n\t\t\tpos++;\n\t\t\t/* because we don't call insertEmphasis */\n\t\t\tpre_src = pos;\n\t\t\tcontinue;\n\t\t}\n\t\tfor_selectRule(table, pos, *output, mode, input, typebuf, emphasisBuffer,\n\t\t\t\t&transOpcode, prevTransOpcode, &transRule, &transCharslen, &passCharDots,\n\t\t\t\t&passInstructions, &passIC, &patternMatch, *posIncremented,\n\t\t\t\t*cursorPosition, &repwordStart, &repwordLength, dontContract,\n\t\t\t\tcompbrlStart, compbrlEnd, beforeAttributes, &curCharDef, &groupingRule,\n\t\t\t\t&groupingOp);\n\n\t\tif (transOpcode != CTO_Context)\n\t\t\tif (appliedRules != NULL && appliedRulesCount < maxAppliedRules)\n\t\t\t\tappliedRules[appliedRulesCount++] = transRule;\n\t\t*posIncremented = 1;\n\t\tprevPos = pos;\n\t\tswitch (transOpcode) /* Rules that pre-empt context and swap */\n\t\t{\n\t\tcase CTO_CompBrl:\n\t\tcase CTO_Literal:\n\t\t\tif (!doCompbrl(table, &pos, input, output, posMapping, emphasisBuffer,\n\t\t\t\t\t\t&transRule, cursorPosition, cursorStatus, destword, srcword))\n\t\t\t\tgoto failure;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (!insertBrailleIndicators(1, table, pos, input, output, posMapping, typebuf,\n\t\t\t\t\thaveEmphasis, transOpcode, prevTransOpcode, cursorPosition,\n\t\t\t\t\tcursorStatus, beforeAttributes, &prevType, &curType, &prevTypeform,\n\t\t\t\t\tprevPos))\n\t\t\tgoto failure;\n\n\t\t//\t\tif(transOpcode == CTO_Contraction)\n\t\t//\t\tif(brailleIndicatorDefined(table->noContractSign))\n\t\t//\t\tif(!for_updatePositions(\n\t\t//\t\t\t&indicRule->charsdots[0], 0, indicRule->dotslen, 0))\n\t\t//\t\t\tgoto failure;\n\t\tinsertEmphases(table, pos, input, output, posMapping, emphasisBuffer,\n\t\t\t\thaveEmphasis, transOpcode, cursorPosition, cursorStatus, &pre_src);\n\t\tif (table->usesNumericMode)\n\t\t\tcheckNumericMode(table, pos, input, output, posMapping, cursorPosition,\n\t\t\t\t\tcursorStatus, &dontContract, &numericMode);\n\n\t\tif (transOpcode == CTO_Context ||\n\t\t\t\tfindForPassRule(table, pos, currentPass, input, &transOpcode, &transRule,\n\t\t\t\t\t\t&transCharslen, &passCharDots, &passInstructions, &passIC,\n\t\t\t\t\t\t&patternMatch, &groupingRule, &groupingOp))\n\t\t\tswitch (transOpcode) {\n\t\t\tcase CTO_Context: {\n\t\t\t\tconst InString *inputBefore = input;\n\t\t\t\tint posBefore = pos;\n\t\t\t\tif (appliedRules != NULL && appliedRulesCount < maxAppliedRules)\n\t\t\t\t\tappliedRules[appliedRulesCount++] = transRule;\n\t\t\t\tif (!passDoAction(table, &input, output, posMapping, transOpcode,\n\t\t\t\t\t\t\t&transRule, passCharDots, passInstructions, passIC, &pos,\n\t\t\t\t\t\t\tpatternMatch, cursorPosition, cursorStatus, groupingRule,\n\t\t\t\t\t\t\tgroupingOp))\n\t\t\t\t\tgoto failure;\n\t\t\t\tif (input->bufferIndex != inputBefore->bufferIndex &&\n\t\t\t\t\t\tinputBefore->bufferIndex != origInput->bufferIndex)\n\t\t\t\t\treleaseStringBuffer(inputBefore->bufferIndex);\n\t\t\t\tif (pos == posBefore) *posIncremented = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t/* Processing before replacement */\n\n\t\t/* check if leaving no contraction (grade 1) mode */\n\t\tif (checkAttr(input->chars[pos], CTC_SeqDelimiter | CTC_Space, 0, table))\n\t\t\tdontContract = 0;\n\n\t\tswitch (transOpcode) {\n\t\tcase CTO_EndNum:\n\t\t\tif (table->letterSign && checkAttr(input->chars[pos], CTC_Letter, 0, table))\n\t\t\t\toutput->length--;\n\t\t\tbreak;\n\t\tcase CTO_Repeated:\n\t\tcase CTO_Space:\n\t\t\tdontContract = 0;\n\t\t\tbreak;\n\t\tcase CTO_LargeSign:\n\t\t\tif (prevTransOpcode == CTO_LargeSign) {\n\t\t\t\tint hasEndSegment = 0;\n\t\t\t\twhile (output->length > 0 && checkAttr(output->chars[output->length - 1],\n\t\t\t\t\t\t\t\t\t\t\t\t\t CTC_Space, 1, table)) {\n\t\t\t\t\tif (output->chars[output->length - 1] == ENDSEGMENT) {\n\t\t\t\t\t\thasEndSegment = 1;\n\t\t\t\t\t}\n\t\t\t\t\toutput->length--;\n\t\t\t\t}\n\t\t\t\tif (hasEndSegment != 0) {\n\t\t\t\t\toutput->chars[output->length] = 0xffff;\n\t\t\t\t\toutput->length++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CTO_DecPoint:\n\t\t\tif (!table->usesNumericMode && table->numberSign) {\n\t\t\t\tTranslationTableRule *numRule =\n\t\t\t\t\t\t(TranslationTableRule *)&table->ruleArea[table->numberSign];\n\t\t\t\tif (!for_updatePositions(&numRule->charsdots[numRule->charslen],\n\t\t\t\t\t\t\tnumRule->charslen, numRule->dotslen, 0, pos, input, output,\n\t\t\t\t\t\t\tposMapping, cursorPosition, cursorStatus))\n\t\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\ttransOpcode = CTO_MidNum;\n\t\t\tbreak;\n\t\tcase CTO_NoCont:\n\t\t\tif (!dontContract)\n\t\t\t\tdoNocont(table, &pos, output, mode, input, destword, srcword,\n\t\t\t\t\t\t&dontContract);\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tbreak;\n\t\t} /* end of action */\n\n\t\t/* replacement processing */\n\t\tswitch (transOpcode) {\n\t\tcase CTO_Replace:\n\t\t\tpos += transCharslen;\n\t\t\tif (!putCharacters(&transRule->charsdots[transCharslen], transRule->dotslen,\n\t\t\t\t\t\ttable, pos, input, output, posMapping, cursorPosition,\n\t\t\t\t\t\tcursorStatus))\n\t\t\t\tgoto failure;\n\t\t\tbreak;\n\t\tcase CTO_None:\n\t\t\tif (!undefinedCharacter(input->chars[pos], table, pos, input, output,\n\t\t\t\t\t\tposMapping, cursorPosition, cursorStatus))\n\t\t\t\tgoto failure;\n\t\t\tpos++;\n\t\t\tbreak;\n\t\tcase CTO_UpperCase:\n\t\t\t/* Only needs special handling if not within compbrl and\n\t\t\t * the table defines a capital sign. */\n\t\t\tif (!(mode & (compbrlAtCursor | compbrlLeftCursor)) &&\n\t\t\t\t\t(transRule->dotslen == 1 &&\n\t\t\t\t\t\t\ttable->emphRules[capsRule][letterOffset])) {\n\t\t\t\tif (!putCharacter(curCharDef->lowercase, table, pos, input, output,\n\t\t\t\t\t\t\tposMapping, cursorPosition, cursorStatus))\n\t\t\t\t\tgoto failure;\n\t\t\t\tpos++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t//\t\tcase CTO_Contraction:\n\t\t//\n\t\t//\t\t\tif(brailleIndicatorDefined(table->noContractSign))\n\t\t//\t\t\tif(!for_updatePositions(\n\t\t//\t\t\t\t&indicRule->charsdots[0], 0, indicRule->dotslen, 0))\n\t\t//\t\t\t\tgoto failure;\n\n\t\tdefault:\n\t\t\tif (transRule->dotslen) {\n\t\t\t\tif (!for_updatePositions(&transRule->charsdots[transCharslen],\n\t\t\t\t\t\t\ttransCharslen, transRule->dotslen, 0, pos, input, output,\n\t\t\t\t\t\t\tposMapping, cursorPosition, cursorStatus))\n\t\t\t\t\tgoto failure;\n\t\t\t\tpos += transCharslen;\n\t\t\t} else {\n\t\t\t\tfor (k = 0; k < transCharslen; k++) {\n\t\t\t\t\tif (!putCharacter(input->chars[pos], table, pos, input, output,\n\t\t\t\t\t\t\t\tposMapping, cursorPosition, cursorStatus))\n\t\t\t\t\t\tgoto failure;\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* processing after replacement */\n\t\tswitch (transOpcode) {\n\t\tcase CTO_Repeated: {\n\t\t\t/* Skip repeated characters. */\n\t\t\tint srclim = input->length - transCharslen;\n\t\t\tif (mode & (compbrlAtCursor | compbrlLeftCursor) && compbrlStart < srclim)\n\t\t\t\t/* Don't skip characters from compbrlStart onwards. */\n\t\t\t\tsrclim = compbrlStart - 1;\n\t\t\twhile ((pos <= srclim) &&\n\t\t\t\t\tcompareChars(&transRule->charsdots[0], &input->chars[pos],\n\t\t\t\t\t\t\ttransCharslen, 0, table)) {\n\t\t\t\t/* Map skipped input positions to the previous output position. */\n\t\t\t\t/* if (posMapping.outputPositions != NULL) { */\n\t\t\t\t/* \tint tcc; */\n\t\t\t\t/* \tfor (tcc = 0; tcc < transCharslen; tcc++) */\n\t\t\t\t/* \t\tposMapping.outputPositions[posMapping.prev[pos + tcc]] = */\n\t\t\t\t/* \t\t\t\toutput->length - 1; */\n\t\t\t\t/* } */\n\t\t\t\tif (!*cursorStatus && pos <= *cursorPosition &&\n\t\t\t\t\t\t*cursorPosition < pos + transCharslen) {\n\t\t\t\t\t*cursorStatus = 1;\n\t\t\t\t\t*cursorPosition = output->length - 1;\n\t\t\t\t}\n\t\t\t\tpos += transCharslen;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase CTO_RepWord: {\n\t\t\t/* Skip repeated characters. */\n\t\t\tint srclim = input->length - transCharslen;\n\t\t\tif (mode & (compbrlAtCursor | compbrlLeftCursor) && compbrlStart < srclim)\n\t\t\t\t/* Don't skip characters from compbrlStart onwards. */\n\t\t\t\tsrclim = compbrlStart - 1;\n\t\t\twhile ((pos <= srclim) && compareChars(repwordStart, &input->chars[pos],\n\t\t\t\t\t\t\t\t\t\t\t  repwordLength, 0, table)) {\n\t\t\t\t/* Map skipped input positions to the previous output position. */\n\t\t\t\t/* if (posMapping.outputPositions != NULL) { */\n\t\t\t\t/* \tint tcc; */\n\t\t\t\t/* \tfor (tcc = 0; tcc < transCharslen; tcc++) */\n\t\t\t\t/* \t\tposMapping.outputPositions[posMapping.prev[pos + tcc]] = */\n\t\t\t\t/* \t\t\t\toutput->length - 1; */\n\t\t\t\t/* } */\n\t\t\t\tif (!*cursorStatus && pos <= *cursorPosition &&\n\t\t\t\t\t\t*cursorPosition < pos + transCharslen) {\n\t\t\t\t\t*cursorStatus = 1;\n\t\t\t\t\t*cursorPosition = output->length - 1;\n\t\t\t\t}\n\t\t\t\tpos += repwordLength + transCharslen;\n\t\t\t}\n\t\t\tpos -= transCharslen;\n\t\t\tbreak;\n\t\t}\n\t\tcase CTO_JoinNum:\n\t\tcase CTO_JoinableWord:\n\t\t\twhile (pos < input->length &&\n\t\t\t\t\tcheckAttr(input->chars[pos], CTC_Space, 0, table) &&\n\t\t\t\t\tinput->chars[pos] != ENDSEGMENT)\n\t\t\t\tpos++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (((pos > 0) && checkAttr(input->chars[pos - 1], CTC_Space, 0, table) &&\n\t\t\t\t\t(transOpcode != CTO_JoinableWord))) {\n\t\t\tsrcword = pos;\n\t\t\tdestword = output->length;\n\t\t}\n\t\tif (srcSpacing != NULL && srcSpacing[pos] >= '0' && srcSpacing[pos] <= '9')\n\t\t\tdestSpacing[output->length] = srcSpacing[pos];\n\t\tif ((transOpcode >= CTO_Always && transOpcode <= CTO_None) ||\n\t\t\t\t(transOpcode >= CTO_Digit && transOpcode <= CTO_LitDigit))\n\t\t\tprevTransOpcode = transOpcode;\n\t}\n\n\ttransOpcode = CTO_Space;\n\tinsertEmphases(table, pos, input, output, posMapping, emphasisBuffer, haveEmphasis,\n\t\t\ttransOpcode, cursorPosition, cursorStatus, &pre_src);\n\nfailure:\n\tif (destword != 0 && pos < input->length &&\n\t\t\t!checkAttr(input->chars[pos], CTC_Space, 0, table)) {\n\t\tpos = srcword;\n\t\toutput->length = destword;\n\t}\n\tif (pos < input->length) {\n\t\twhile (checkAttr(input->chars[pos], CTC_Space, 0, table))\n\t\t\tif (++pos == input->length) break;\n\t}\n\t*realInlen = pos;\n\tif (input->bufferIndex != origInput->bufferIndex)\n\t\treleaseStringBuffer(input->bufferIndex);\n\treturn 1;\n} /* first pass translation completed */\n\nint EXPORT_CALL\nlou_hyphenate(const char *tableList, const widechar *inbuf, int inlen, char *hyphens,\n\t\tint mode) {\n#define HYPHSTRING 100\n\tconst TranslationTableHeader *table;\n\twidechar workingBuffer[HYPHSTRING];\n\tint k, kk;\n\tint wordStart;\n\tint wordEnd;\n\ttable = lou_getTable(tableList);\n\tif (table == NULL || inbuf == NULL || hyphens == NULL ||\n\t\t\ttable->hyphenStatesArray == 0 || inlen >= HYPHSTRING)\n\t\treturn 0;\n\tif (mode != 0) {\n\t\tk = inlen;\n\t\tkk = HYPHSTRING;\n\t\tif (!lou_backTranslate(tableList, inbuf, &k, &workingBuffer[0], &kk, NULL, NULL,\n\t\t\t\t\tNULL, NULL, NULL, 0))\n\t\t\treturn 0;\n\t} else {\n\t\tmemcpy(&workingBuffer[0], inbuf, CHARSIZE * inlen);\n\t\tkk = inlen;\n\t}\n\tfor (wordStart = 0; wordStart < kk; wordStart++)\n\t\tif (((findCharOrDots(workingBuffer[wordStart], 0, table))->attributes &\n\t\t\t\t\tCTC_Letter))\n\t\t\tbreak;\n\tif (wordStart == kk) return 0;\n\tfor (wordEnd = kk - 1; wordEnd >= 0; wordEnd--)\n\t\tif (((findCharOrDots(workingBuffer[wordEnd], 0, table))->attributes & CTC_Letter))\n\t\t\tbreak;\n\tfor (k = wordStart; k <= wordEnd; k++) {\n\t\tTranslationTableCharacter *c = findCharOrDots(workingBuffer[k], 0, table);\n\t\tif (!(c->attributes & CTC_Letter)) return 0;\n\t}\n\tif (!hyphenate(&workingBuffer[wordStart], wordEnd - wordStart + 1,\n\t\t\t\t&hyphens[wordStart], table))\n\t\treturn 0;\n\tfor (k = 0; k <= wordStart; k++) hyphens[k] = '0';\n\tif (mode != 0) {\n\t\twidechar workingBuffer2[HYPHSTRING];\n\t\tint outputPos[HYPHSTRING];\n\t\tchar hyphens2[HYPHSTRING];\n\t\tkk = wordEnd - wordStart + 1;\n\t\tk = HYPHSTRING;\n\t\tif (!lou_translate(tableList, &workingBuffer[wordStart], &kk, &workingBuffer2[0],\n\t\t\t\t\t&k, NULL, NULL, &outputPos[0], NULL, NULL, 0))\n\t\t\treturn 0;\n\t\tfor (kk = 0; kk < k; kk++) {\n\t\t\tint hyphPos = outputPos[kk];\n\t\t\tif (hyphPos > k || hyphPos < 0) break;\n\t\t\tif (hyphens[wordStart + kk] & 1)\n\t\t\t\thyphens2[hyphPos] = '1';\n\t\t\telse\n\t\t\t\thyphens2[hyphPos] = '0';\n\t\t}\n\t\tfor (kk = wordStart; kk < wordStart + k; kk++)\n\t\t\tif (hyphens2[kk] == '0') hyphens[kk] = hyphens2[kk];\n\t}\n\tfor (k = 0; k < inlen; k++)\n\t\tif (hyphens[k] & 1)\n\t\t\thyphens[k] = '1';\n\t\telse\n\t\t\thyphens[k] = '0';\n\thyphens[inlen] = 0;\n\treturn 1;\n}\n\nint EXPORT_CALL\nlou_dotsToChar(\n\t\tconst char *tableList, widechar *inbuf, widechar *outbuf, int length, int mode) {\n\tconst TranslationTableHeader *table;\n\tint k;\n\twidechar dots;\n\tif (tableList == NULL || inbuf == NULL || outbuf == NULL) return 0;\n\n\ttable = lou_getTable(tableList);\n\tif (table == NULL || length <= 0) return 0;\n\tfor (k = 0; k < length; k++) {\n\t\tdots = inbuf[k];\n\t\tif (!(dots & B16) && (dots & 0xff00) == 0x2800) /* Unicode braille */\n\t\t\tdots = (dots & 0x00ff) | B16;\n\t\toutbuf[k] = _lou_getCharFromDots(dots);\n\t}\n\treturn 1;\n}\n\nint EXPORT_CALL\nlou_charToDots(const char *tableList, const widechar *inbuf, widechar *outbuf, int length,\n\t\tint mode) {\n\tconst TranslationTableHeader *table;\n\tint k;\n\tif (tableList == NULL || inbuf == NULL || outbuf == NULL) return 0;\n\n\ttable = lou_getTable(tableList);\n\tif (table == NULL || length <= 0) return 0;\n\tfor (k = 0; k < length; k++)\n\t\tif ((mode & ucBrl))\n\t\t\toutbuf[k] = ((_lou_getDotsForChar(inbuf[k]) & 0xff) | 0x2800);\n\t\telse\n\t\t\toutbuf[k] = _lou_getDotsForChar(inbuf[k]);\n\treturn 1;\n}\n"], "filenames": ["liblouis/lou_translateString.c"], "buggy_code_start_loc": [357], "buggy_code_end_loc": [358], "fixing_code_start_loc": [357], "fixing_code_end_loc": [360], "type": "CWE-125", "message": "The matchCurrentInput function inside lou_translateString.c of Liblouis prior to 3.7 does not check the input string's length, allowing attackers to cause a denial of service (application crash via out-of-bounds read) by crafting an input file with certain translation dictionaries.", "other": {"cve": {"id": "CVE-2018-17294", "sourceIdentifier": "cve@mitre.org", "published": "2018-09-21T07:29:00.617", "lastModified": "2019-04-18T16:09:24.637", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The matchCurrentInput function inside lou_translateString.c of Liblouis prior to 3.7 does not check the input string's length, allowing attackers to cause a denial of service (application crash via out-of-bounds read) by crafting an input file with certain translation dictionaries."}, {"lang": "es", "value": "La funci\u00f3n matchCurrentInput dentro de lou_translateString.c de Liblouis en versiones anteriores a la 3.7 no comprueba la longitud de la cadena entrante, permitiendo a los atacantes provocar una denegaci\u00f3n de servicio (cierre inesperado de la aplicaci\u00f3n mediante una lectura fuera de l\u00edmites) creando un archivo entrante con determinados diccionarios de traducci\u00f3n."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:liblouis:liblouis:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.7.0", "matchCriteriaId": "5A1015DA-3326-4985-8112-D9E4E007F5F3"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-04/msg00038.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/105511", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/liblouis/liblouis/commit/5e4089659bb49b3095fa541fa6387b4c40d7396e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/liblouis/liblouis/issues/635", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3782-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/liblouis/liblouis/commit/5e4089659bb49b3095fa541fa6387b4c40d7396e"}}