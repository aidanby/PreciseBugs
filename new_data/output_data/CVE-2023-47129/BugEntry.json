{"buggy_code": ["<?php\n\nnamespace Statamic\\Http\\Controllers;\n\nuse Illuminate\\Http\\RedirectResponse;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Http\\Response;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\MessageBag;\nuse Illuminate\\Support\\Traits\\Localizable;\nuse Illuminate\\Validation\\ValidationException;\nuse Statamic\\Contracts\\Forms\\Submission;\nuse Statamic\\Events\\FormSubmitted;\nuse Statamic\\Events\\SubmissionCreated;\nuse Statamic\\Exceptions\\SilentFormFailureException;\nuse Statamic\\Facades\\Site;\nuse Statamic\\Forms\\Exceptions\\FileContentTypeRequiredException;\nuse Statamic\\Forms\\SendEmails;\nuse Statamic\\Support\\Arr;\nuse Statamic\\Support\\Str;\n\nclass FormController extends Controller\n{\n    use Localizable;\n\n    /**\n     * Handle a form submission request.\n     *\n     * @return mixed\n     */\n    public function submit(Request $request, $form)\n    {\n        $site = Site::findByUrl(URL::previous()) ?? Site::default();\n        $fields = $form->blueprint()->fields();\n        $this->validateContentType($request, $form);\n        $values = array_merge($request->all(), $assets = $this->normalizeAssetsValues($fields, $request));\n        $params = collect($request->all())->filter(function ($value, $key) {\n            return Str::startsWith($key, '_');\n        })->all();\n\n        $fields = $fields->addValues($values);\n\n        $submission = $form->makeSubmission();\n\n        try {\n            $this->withLocale($site->lang(), function () use ($fields) {\n                $fields->validate($this->extraRules($fields));\n            });\n\n            throw_if(Arr::get($values, $form->honeypot()), new SilentFormFailureException);\n\n            $values = array_merge($values, $submission->uploadFiles($assets));\n\n            $submission->data(\n                $fields->addValues($values)->process()->values()\n            );\n\n            // If any event listeners return false, we'll do a silent failure.\n            // If they want to add validation errors, they can throw an exception.\n            throw_if(FormSubmitted::dispatch($submission) === false, new SilentFormFailureException);\n        } catch (ValidationException $e) {\n            return $this->formFailure($params, $e->errors(), $form->handle());\n        } catch (SilentFormFailureException $e) {\n            return $this->formSuccess($params, $submission, true);\n        }\n\n        if ($form->store()) {\n            $submission->save();\n        } else {\n            // When the submission is saved, this same created event will be dispatched.\n            // We'll also fire it here if submissions are not configured to be stored\n            // so that developers may continue to listen and modify it as needed.\n            SubmissionCreated::dispatch($submission);\n        }\n\n        SendEmails::dispatch($submission, $site);\n\n        return $this->formSuccess($params, $submission);\n    }\n\n    private function validateContentType($request, $form)\n    {\n        $type = Str::before($request->headers->get('CONTENT_TYPE'), ';');\n\n        if ($type !== 'multipart/form-data' && $form->hasFiles()) {\n            throw new FileContentTypeRequiredException;\n        }\n    }\n\n    /**\n     * The steps for a successful form submission.\n     *\n     * Used for actual success and by honeypot.\n     *\n     * @param  array  $params\n     * @param  Submission  $submission\n     * @param  bool  $silentFailure\n     * @return Response\n     */\n    private function formSuccess($params, $submission, $silentFailure = false)\n    {\n        if (request()->ajax() || request()->wantsJson()) {\n            return response([\n                'success' => true,\n                'submission_created' => ! $silentFailure,\n                'submission' => $submission->data(),\n            ]);\n        }\n\n        $redirect = Arr::get($params, '_redirect');\n\n        $response = $redirect ? redirect($redirect) : back();\n\n        session()->flash(\"form.{$submission->form()->handle()}.success\", __('Submission successful.'));\n        session()->flash(\"form.{$submission->form()->handle()}.submission_created\", ! $silentFailure);\n        session()->flash('submission', $submission);\n\n        return $response;\n    }\n\n    /**\n     * The steps for a failed form submission.\n     *\n     * @param  array  $params\n     * @param  array  $submission\n     * @param  string  $form\n     * @return Response|RedirectResponse\n     */\n    private function formFailure($params, $errors, $form)\n    {\n        if (request()->ajax()) {\n            return response([\n                'errors' => (new MessageBag($errors))->all(),\n                'error' => collect($errors)->map(function ($errors, $field) {\n                    return $errors[0];\n                })->all(),\n            ], 400);\n        }\n\n        $redirect = Arr::get($params, '_error_redirect');\n\n        $response = $redirect ? redirect($redirect) : back();\n\n        return $response->withInput()->withErrors($errors, 'form.'.$form);\n    }\n\n    protected function normalizeAssetsValues($fields, $request)\n    {\n        // The assets fieldtype is expecting an array, even for `max_files: 1`, but we don't want to force that on the front end.\n        return $fields->all()\n            ->filter(function ($field) {\n                return $field->fieldtype()->handle() === 'assets' && request()->hasFile($field->handle());\n            })\n            ->map(function ($field) use ($request) {\n                return Arr::wrap($request->file($field->handle()));\n            })\n            ->all();\n    }\n\n    protected function extraRules($fields)\n    {\n        $assetFieldRules = $fields->all()\n            ->filter(function ($field) {\n                return $field->fieldtype()->handle() === 'assets';\n            })\n            ->mapWithKeys(function ($field) {\n                return [$field->handle().'.*' => 'file'];\n            })\n            ->all();\n\n        return $assetFieldRules;\n    }\n}\n"], "fixing_code": ["<?php\n\nnamespace Statamic\\Http\\Controllers;\n\nuse Illuminate\\Http\\RedirectResponse;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Http\\Response;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\MessageBag;\nuse Illuminate\\Support\\Traits\\Localizable;\nuse Illuminate\\Validation\\ValidationException;\nuse Statamic\\Contracts\\Forms\\Submission;\nuse Statamic\\Events\\FormSubmitted;\nuse Statamic\\Events\\SubmissionCreated;\nuse Statamic\\Exceptions\\SilentFormFailureException;\nuse Statamic\\Facades\\Site;\nuse Statamic\\Forms\\Exceptions\\FileContentTypeRequiredException;\nuse Statamic\\Forms\\SendEmails;\nuse Statamic\\Support\\Arr;\nuse Statamic\\Support\\Str;\n\nclass FormController extends Controller\n{\n    use Localizable;\n\n    /**\n     * Handle a form submission request.\n     *\n     * @return mixed\n     */\n    public function submit(Request $request, $form)\n    {\n        $site = Site::findByUrl(URL::previous()) ?? Site::default();\n        $fields = $form->blueprint()->fields();\n        $this->validateContentType($request, $form);\n        $values = array_merge($request->all(), $assets = $this->normalizeAssetsValues($fields, $request));\n        $params = collect($request->all())->filter(function ($value, $key) {\n            return Str::startsWith($key, '_');\n        })->all();\n\n        $fields = $fields->addValues($values);\n\n        $submission = $form->makeSubmission();\n\n        try {\n            $this->withLocale($site->lang(), function () use ($fields) {\n                $fields->validate($this->extraRules($fields));\n            });\n\n            throw_if(Arr::get($values, $form->honeypot()), new SilentFormFailureException);\n\n            $values = array_merge($values, $submission->uploadFiles($assets));\n\n            $submission->data(\n                $fields->addValues($values)->process()->values()\n            );\n\n            // If any event listeners return false, we'll do a silent failure.\n            // If they want to add validation errors, they can throw an exception.\n            throw_if(FormSubmitted::dispatch($submission) === false, new SilentFormFailureException);\n        } catch (ValidationException $e) {\n            return $this->formFailure($params, $e->errors(), $form->handle());\n        } catch (SilentFormFailureException $e) {\n            return $this->formSuccess($params, $submission, true);\n        }\n\n        if ($form->store()) {\n            $submission->save();\n        } else {\n            // When the submission is saved, this same created event will be dispatched.\n            // We'll also fire it here if submissions are not configured to be stored\n            // so that developers may continue to listen and modify it as needed.\n            SubmissionCreated::dispatch($submission);\n        }\n\n        SendEmails::dispatch($submission, $site);\n\n        return $this->formSuccess($params, $submission);\n    }\n\n    private function validateContentType($request, $form)\n    {\n        $type = Str::before($request->headers->get('CONTENT_TYPE'), ';');\n\n        if ($type !== 'multipart/form-data' && $form->hasFiles()) {\n            throw new FileContentTypeRequiredException;\n        }\n    }\n\n    /**\n     * The steps for a successful form submission.\n     *\n     * Used for actual success and by honeypot.\n     *\n     * @param  array  $params\n     * @param  Submission  $submission\n     * @param  bool  $silentFailure\n     * @return Response\n     */\n    private function formSuccess($params, $submission, $silentFailure = false)\n    {\n        if (request()->ajax() || request()->wantsJson()) {\n            return response([\n                'success' => true,\n                'submission_created' => ! $silentFailure,\n                'submission' => $submission->data(),\n            ]);\n        }\n\n        $redirect = Arr::get($params, '_redirect');\n\n        $response = $redirect ? redirect($redirect) : back();\n\n        session()->flash(\"form.{$submission->form()->handle()}.success\", __('Submission successful.'));\n        session()->flash(\"form.{$submission->form()->handle()}.submission_created\", ! $silentFailure);\n        session()->flash('submission', $submission);\n\n        return $response;\n    }\n\n    /**\n     * The steps for a failed form submission.\n     *\n     * @param  array  $params\n     * @param  array  $submission\n     * @param  string  $form\n     * @return Response|RedirectResponse\n     */\n    private function formFailure($params, $errors, $form)\n    {\n        if (request()->ajax()) {\n            return response([\n                'errors' => (new MessageBag($errors))->all(),\n                'error' => collect($errors)->map(function ($errors, $field) {\n                    return $errors[0];\n                })->all(),\n            ], 400);\n        }\n\n        $redirect = Arr::get($params, '_error_redirect');\n\n        $response = $redirect ? redirect($redirect) : back();\n\n        return $response->withInput()->withErrors($errors, 'form.'.$form);\n    }\n\n    protected function normalizeAssetsValues($fields, $request)\n    {\n        // The assets fieldtype is expecting an array, even for `max_files: 1`, but we don't want to force that on the front end.\n        return $fields->all()\n            ->filter(function ($field) {\n                return $field->fieldtype()->handle() === 'assets' && request()->hasFile($field->handle());\n            })\n            ->map(function ($field) use ($request) {\n                return Arr::wrap($request->file($field->handle()));\n            })\n            ->all();\n    }\n\n    protected function extraRules($fields)\n    {\n        $assetFieldRules = $fields->all()\n            ->filter(function ($field) {\n                return $field->fieldtype()->handle() === 'assets';\n            })\n            ->mapWithKeys(function ($field) {\n                return [$field->handle().'.*' => ['file', function ($attribute, $value, $fail) {\n                    if (in_array(trim(strtolower($value->getClientOriginalExtension())), ['php', 'php3', 'php4', 'php5', 'phtml'])) {\n                        $fail(__('validation.uploaded'));\n                    }\n                }]];\n            })\n            ->all();\n\n        return $assetFieldRules;\n    }\n}\n"], "filenames": ["src/Http/Controllers/FormController.php"], "buggy_code_start_loc": [167], "buggy_code_end_loc": [168], "fixing_code_start_loc": [167], "fixing_code_end_loc": [172], "type": "CWE-434", "message": "Statmic is a core Laravel content management system Composer package. Prior to versions 3.4.13 and 4.33.0, on front-end forms with an asset upload field, PHP files crafted to look like images may be uploaded. This only affects forms using the \"Forms\" feature and not just _any_ arbitrary form. This does not affect the control panel. This issue has been patched in 3.4.13 and 4.33.0.\n", "other": {"cve": {"id": "CVE-2023-47129", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-10T19:15:16.617", "lastModified": "2023-11-17T17:15:02.653", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Statmic is a core Laravel content management system Composer package. Prior to versions 3.4.13 and 4.33.0, on front-end forms with an asset upload field, PHP files crafted to look like images may be uploaded. This only affects forms using the \"Forms\" feature and not just _any_ arbitrary form. This does not affect the control panel. This issue has been patched in 3.4.13 and 4.33.0.\n"}, {"lang": "es", "value": "Statmic es un paquete Composer central del sistema de gesti\u00f3n de contenidos Laravel. Antes de las versiones 3.4.13 y 4.33.0, en los formularios frontales con un campo de carga de activos, se pod\u00edan cargar archivos PHP manipulados para que parecieran im\u00e1genes. Esto s\u00f3lo afecta a los formularios que utilizan la funci\u00f3n \"Formularios\" y no s\u00f3lo a cualquier formulario arbitrario. Esto no afecta al panel de control. Este problema se solucion\u00f3 en 3.4.13 y 4.33.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 6.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-434"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-434"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:statamic:statamic:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.4.13", "matchCriteriaId": "F2755BEC-12A8-4B61-9C45-54C8A4C0B5F6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:statamic:statamic:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0.0", "versionEndExcluding": "4.33.0", "matchCriteriaId": "21D3DF89-2CCF-4A98-8EC7-9C02324CB93C"}]}]}], "references": [{"url": "https://github.com/statamic/cms/commit/098ef8024d97286ca501273c18ae75b646262d75", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/statamic/cms/commit/f6c688154f6bdbd0b67039f8f11dcd98ba061e77", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/statamic/cms/security/advisories/GHSA-72hg-5wr5-rmfc", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/statamic/cms/commit/098ef8024d97286ca501273c18ae75b646262d75"}}