{"buggy_code": ["<?php namespace October\\Rain\\Auth;\n\nuse Cookie;\nuse Session;\nuse Request;\nuse Illuminate\\Contracts\\Auth\\Authenticatable;\n\n/**\n * Authentication manager\n */\nclass Manager implements \\Illuminate\\Contracts\\Auth\\StatefulGuard\n{\n    use \\October\\Rain\\Support\\Traits\\Singleton;\n\n    /**\n     * @var Models\\User The currently logged in user\n     */\n    protected $user;\n\n    /**\n     * @var array In memory throttle cache [md5($userId.$ipAddress) => $this->throttleModel]\n     */\n    protected $throttle = [];\n\n    /**\n     * @var string User Model Class\n     */\n    protected $userModel = Models\\User::class;\n\n    /**\n     * @var string User Group Model Class\n     */\n    protected $groupModel = Models\\Group::class;\n\n    /**\n     * @var string Throttle Model Class\n     */\n    protected $throttleModel = Models\\Throttle::class;\n\n    /**\n     * @var bool Flag to enable login throttling\n     */\n    protected $useThrottle = true;\n\n    /**\n     * @var bool Internal flag to toggle using the session for the current authentication request\n     */\n    protected $useSession = true;\n\n    /**\n     * @var bool Flag to require users to be activated to login\n     */\n    protected $requireActivation = true;\n\n    /**\n     * @var string Key to store the auth session data in\n     */\n    protected $sessionKey = 'october_auth';\n\n    /**\n     * @var bool Indicates if the user was authenticated via a recaller cookie.\n     */\n    protected $viaRemember = false;\n\n    /**\n     * @var string The IP address of this request\n     */\n    public $ipAddress = '0.0.0.0';\n\n    /**\n     * Initializes the singleton\n     */\n    protected function init()\n    {\n        $this->ipAddress = Request::ip();\n    }\n\n    //\n    // User\n    //\n\n    /**\n     * Creates a new instance of the user model\n     *\n     * @return Models\\User\n     */\n    public function createUserModel()\n    {\n        $class = '\\\\'.ltrim($this->userModel, '\\\\');\n        return new $class();\n    }\n\n    /**\n     * Prepares a query derived from the user model.\n     *\n     * @return \\October\\Rain\\Database\\Builder $query\n     */\n    protected function createUserModelQuery()\n    {\n        $model = $this->createUserModel();\n        $query = $model->newQuery();\n        $this->extendUserQuery($query);\n\n        return $query;\n    }\n\n    /**\n     * Extend the query used for finding the user.\n     * @param \\October\\Rain\\Database\\Builder $query\n     * @return void\n     */\n    public function extendUserQuery($query)\n    {\n    }\n\n    /**\n     * Registers a user with the provided credentials with optional flags\n     * for activating the newly created user and automatically logging them in\n     *\n     * @param array $credentials\n     * @param bool $activate\n     * @param bool $autoLogin\n     * @return Models\\User\n     */\n    public function register(array $credentials, $activate = false, $autoLogin = true)\n    {\n        $user = $this->createUserModel();\n        $user->fill($credentials);\n        $user->save();\n\n        if ($activate) {\n            $user->attemptActivation($user->getActivationCode());\n        }\n\n        // Prevents revalidation of the password field\n        // on subsequent saves to this model object\n        $user->password = null;\n\n        if ($autoLogin) {\n            $this->user = $user;\n        }\n\n        return $user;\n    }\n\n    /**\n     * Sets the user\n     */\n    public function setUser(Authenticatable $user)\n    {\n        $this->user = $user;\n    }\n\n    /**\n     * Returns the current user, if any.\n     *\n     * @return mixed (Models\\User || null)\n     */\n    public function getUser()\n    {\n        if (is_null($this->user)) {\n            $this->check();\n        }\n\n        return $this->user;\n    }\n\n    /**\n     * Finds a user by the login value.\n     *\n     * @param string $id\n     * @return mixed (Models\\User || null)\n     */\n    public function findUserById($id)\n    {\n        $query = $this->createUserModelQuery();\n\n        $user = $query->find($id);\n\n        return $this->validateUserModel($user) ? $user : null;\n    }\n\n    /**\n     * Finds a user by the login value.\n     *\n     * @param string $login\n     * @return mixed (Models\\User || null)\n     */\n    public function findUserByLogin($login)\n    {\n        $model = $this->createUserModel();\n\n        $query = $this->createUserModelQuery();\n\n        $user = $query->where($model->getLoginName(), $login)->first();\n\n        return $this->validateUserModel($user) ? $user : null;\n    }\n\n    /**\n     * Finds a user by the given credentials.\n     *\n     * @param array $credentials The credentials to find a user by\n     * @throws AuthException If the credentials are invalid\n     * @return Models\\User The requested user\n     */\n    public function findUserByCredentials(array $credentials)\n    {\n        $model = $this->createUserModel();\n        $loginName = $model->getLoginName();\n\n        if (!array_key_exists($loginName, $credentials)) {\n            throw new AuthException(sprintf('Login attribute \"%s\" was not provided.', $loginName));\n        }\n\n        $query = $this->createUserModelQuery();\n        $hashableAttributes = $model->getHashableAttributes();\n        $hashedCredentials = [];\n\n        /*\n         * Build query from given credentials\n         */\n        foreach ($credentials as $credential => $value) {\n            // All excepted the hashed attributes\n            if (in_array($credential, $hashableAttributes)) {\n                $hashedCredentials = array_merge($hashedCredentials, [$credential => $value]);\n            }\n            else {\n                $query = $query->where($credential, '=', $value);\n            }\n        }\n\n        $user = $query->first();\n        if (!$this->validateUserModel($user)) {\n            throw new AuthException('A user was not found with the given credentials.');\n        }\n\n        /*\n         * Check the hashed credentials match\n         */\n        foreach ($hashedCredentials as $credential => $value) {\n            if (!$user->checkHashValue($credential, $value)) {\n                // Incorrect password\n                if ($credential == 'password') {\n                    throw new AuthException(sprintf(\n                        'A user was found to match all plain text credentials however hashed credential \"%s\" did not match.',\n                        $credential\n                    ));\n                }\n\n                // User not found\n                throw new AuthException('A user was not found with the given credentials.');\n            }\n        }\n\n        return $user;\n    }\n\n    /**\n     * Perform additional checks on the user model.\n     *\n     * @param $user\n     * @return boolean\n     */\n    protected function validateUserModel($user)\n    {\n        return $user instanceof $this->userModel;\n    }\n\n    //\n    // Throttle\n    //\n\n    /**\n     * Creates an instance of the throttle model\n     *\n     * @return Models\\Throttle\n     */\n    public function createThrottleModel()\n    {\n        $class = '\\\\'.ltrim($this->throttleModel, '\\\\');\n        return new $class();\n    }\n\n    /**\n     * Find a throttle record by login and ip address\n     *\n     * @param string $loginName\n     * @param string $ipAddress\n     * @return Models\\Throttle\n     */\n    public function findThrottleByLogin($loginName, $ipAddress)\n    {\n        $user = $this->findUserByLogin($loginName);\n        if (!$user) {\n            throw new AuthException(\"A user was not found with the given credentials.\");\n        }\n\n        $userId = $user->getKey();\n        return $this->findThrottleByUserId($userId, $ipAddress);\n    }\n\n    /**\n     * Find a throttle record by user id and ip address\n     *\n     * @param integer $userId\n     * @param string $ipAddress\n     * @return Models\\Throttle\n     */\n    public function findThrottleByUserId($userId, $ipAddress = null)\n    {\n        $cacheKey = md5($userId.$ipAddress);\n        if (isset($this->throttle[$cacheKey])) {\n            return $this->throttle[$cacheKey];\n        }\n\n        $model = $this->createThrottleModel();\n        $query = $model->where('user_id', '=', $userId);\n\n        if ($ipAddress) {\n            $query->where(function ($query) use ($ipAddress) {\n                $query->where('ip_address', '=', $ipAddress);\n                $query->orWhere('ip_address', '=', null);\n            });\n        }\n\n        if (!$throttle = $query->first()) {\n            $throttle = $this->createThrottleModel();\n            $throttle->user_id = $userId;\n            if ($ipAddress) {\n                $throttle->ip_address = $ipAddress;\n            }\n\n            $throttle->save();\n        }\n\n        return $this->throttle[$cacheKey] = $throttle;\n    }\n\n    //\n    // Business Logic\n    //\n\n    /**\n     * Attempt to authenticate a user using the given credentials.\n     *\n     * @param array $credentials The user login details\n     * @param bool $remember Store a non-expire cookie for the user\n     * @throws AuthException If authentication fails\n     * @return Models\\User The successfully logged in user\n     */\n    public function attempt(array $credentials = [], $remember = false)\n    {\n        return !!$this->authenticate($credentials, $remember);\n    }\n\n    /**\n     * Validate a user's credentials.\n     *\n     * @param  array  $credentials\n     * @return bool\n     */\n    public function validate(array $credentials = [])\n    {\n        return !!$this->validateInternal($credentials);\n    }\n\n    /**\n     * Validate a user's credentials, method used internally.\n     *\n     * @param  array  $credentials\n     * @return User\n     */\n    protected function validateInternal(array $credentials = [])\n    {\n        /*\n         * Default to the login name field or fallback to a hard-coded 'login' value\n         */\n        $loginName = $this->createUserModel()->getLoginName();\n        $loginCredentialKey = isset($credentials[$loginName]) ? $loginName : 'login';\n\n        if (empty($credentials[$loginCredentialKey])) {\n            throw new AuthException(sprintf('The \"%s\" attribute is required.', $loginCredentialKey));\n        }\n\n        if (empty($credentials['password'])) {\n            throw new AuthException('The password attribute is required.');\n        }\n\n        /*\n         * If the fallback 'login' was provided and did not match the necessary\n         * login name, swap it over\n         */\n        if ($loginCredentialKey !== $loginName) {\n            $credentials[$loginName] = $credentials[$loginCredentialKey];\n            unset($credentials[$loginCredentialKey]);\n        }\n\n        /*\n         * If throttling is enabled, check they are not locked out first and foremost.\n         */\n        if ($this->useThrottle) {\n            $throttle = $this->findThrottleByLogin($credentials[$loginName], $this->ipAddress);\n            $throttle->check();\n        }\n\n        /*\n         * Look up the user by authentication credentials.\n         */\n        try {\n            $user = $this->findUserByCredentials($credentials);\n        }\n        catch (AuthException $ex) {\n            if ($this->useThrottle) {\n                $throttle->addLoginAttempt();\n            }\n\n            throw $ex;\n        }\n\n        if ($this->useThrottle) {\n            $throttle->clearLoginAttempts();\n        }\n\n        return $user;\n    }\n\n    /**\n     * Attempts to authenticate the given user according to the passed credentials.\n     *\n     * @param array $credentials The user login details\n     * @param bool $remember Store a non-expire cookie for the user\n     */\n    public function authenticate(array $credentials, $remember = true)\n    {\n        $user = $this->validateInternal($credentials);\n\n        $user->clearResetPassword();\n\n        $this->login($user, $remember);\n\n        return $this->user;\n    }\n\n    /**\n     * Check to see if the user is logged in and activated, and hasn't been banned or suspended.\n     *\n     * @return bool\n     */\n    public function check()\n    {\n        if (is_null($this->user)) {\n            /*\n             * Check session first, follow by cookie\n             */\n            if ($sessionArray = Session::get($this->sessionKey)) {\n                $userArray = $sessionArray;\n            }\n            elseif ($cookieArray = Cookie::get($this->sessionKey)) {\n                $this->viaRemember = true;\n                /*\n                 * Shift gracefully to unserialized cookies\n                 * @todo Remove if statement below if year >= 2021 or build >= 475\n                 */\n                if (is_array($cookieArray)) {\n                    $userArray = $cookieArray;\n                }\n                else {\n                    $userArray = @json_decode($cookieArray, true);\n                }\n            }\n            else {\n                return false;\n            }\n\n            /*\n             * Check supplied session/cookie is an array (user id, persist code)\n             */\n            if (!is_array($userArray) || count($userArray) !== 2) {\n                return false;\n            }\n\n            list($id, $persistCode) = $userArray;\n\n            /*\n             * Look up user\n             */\n            if (!$user = $this->findUserById($id)) {\n                return false;\n            }\n\n            /*\n             * Confirm the persistence code is valid, otherwise reject\n             */\n            if (!$user->checkPersistCode($persistCode)) {\n                return false;\n            }\n\n            /*\n             * Pass\n             */\n            $this->user = $user;\n        }\n\n        /*\n         * Check cached user is activated\n         */\n        if (!($user = $this->getUser()) || ($this->requireActivation && !$user->is_activated)) {\n            return false;\n        }\n\n        /*\n         * Throttle check\n         */\n        if ($this->useThrottle) {\n            $throttle = $this->findThrottleByUserId($user->getKey(), $this->ipAddress);\n\n            if ($throttle->is_banned || $throttle->checkSuspended()) {\n                $this->logout();\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Determine if the current user is a guest.\n     *\n     * @return bool\n     */\n    public function guest()\n    {\n        return false;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        return $this->getUser();\n    }\n\n    /**\n     * Get the ID for the currently authenticated user.\n     *\n     * @return int|null\n     */\n    public function id()\n    {\n        if ($user = $this->getUser()) {\n            return $user->getAuthIdentifier();\n        }\n\n        return null;\n    }\n\n    /**\n     * Log a user into the application without sessions or cookies.\n     *\n     * @param  array  $credentials\n     * @return bool\n     */\n    public function once(array $credentials = [])\n    {\n        $this->useSession = false;\n\n        $user = $this->authenticate($credentials);\n\n        $this->useSession = true;\n\n        return !!$user;\n    }\n\n    /**\n     * Log the given user ID into the application without sessions or cookies.\n     *\n     * @param  mixed  $id\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|false\n     */\n    public function onceUsingId($id)\n    {\n        if (!is_null($user = $this->findUserById($id))) {\n            $this->setUser($user);\n\n            return $user;\n        }\n\n        return false;\n    }\n\n    /**\n     * Logs in the given user and sets properties\n     * in the session.\n     * @throws AuthException If the user is not activated and $this->requireActivation = true\n     */\n    public function login(Authenticatable $user, $remember = true)\n    {\n        /*\n         * Fire the 'beforeLogin' event\n         */\n        $user->beforeLogin();\n\n        /*\n         * Activation is required, user not activated\n         */\n        if ($this->requireActivation && !$user->is_activated) {\n            $login = $user->getLogin();\n            throw new AuthException(sprintf(\n                'Cannot login user \"%s\" as they are not activated.',\n                $login\n            ));\n        }\n\n        $this->user = $user;\n\n        /*\n         * Create session/cookie data to persist the session\n         */\n        if ($this->useSession) {\n            $toPersist = [$user->getKey(), $user->getPersistCode()];\n            Session::put($this->sessionKey, $toPersist);\n\n            if ($remember) {\n                Cookie::queue(Cookie::forever($this->sessionKey, json_encode($toPersist)));\n            }\n        }\n\n        /*\n         * Fire the 'afterLogin' event\n         */\n        $user->afterLogin();\n    }\n\n    /**\n     * Log the given user ID into the application.\n     *\n     * @param  mixed  $id\n     * @param  bool   $remember\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable\n     */\n    public function loginUsingId($id, $remember = false)\n    {\n        if (!is_null($user = $this->findUserById($id))) {\n            $this->login($user, $remember);\n\n            return $user;\n        }\n\n        return false;\n    }\n\n    /**\n     * Determine if the user was authenticated via \"remember me\" cookie.\n     *\n     * @return bool\n     */\n    public function viaRemember()\n    {\n        return $this->viaRemember;\n    }\n\n    /**\n     * Logs the current user out.\n     */\n    public function logout()\n    {\n        // Initialize the current auth session before trying to remove it\n        if (is_null($this->user) && !$this->check()) {\n            return;\n        }\n\n        if ($this->isImpersonator()) {\n            $this->user = $this->getImpersonator();\n            $this->stopImpersonate();\n            return;\n        }\n\n        if ($this->user) {\n            $this->user->setRememberToken(null);\n            $this->user->forceSave();\n        }\n\n        $this->user = null;\n\n        Session::flush();\n        Cookie::queue(Cookie::forget($this->sessionKey));\n    }\n\n    //\n    // Impersonation\n    //\n\n    /**\n     * Impersonates the given user and sets properties\n     * in the session but not the cookie.\n     */\n    public function impersonate($user)\n    {\n        $oldSession = Session::get($this->sessionKey);\n        $oldUser = !empty($oldSession[0]) ? $this->findUserById($oldSession[0]) : false;\n\n        /**\n         * @event model.auth.beforeImpersonate\n         * Called after the model is booted\n         *\n         * Example usage:\n         *\n         *     $model->bindEvent('model.auth.beforeImpersonate', function (\\October\\Rain\\Database\\Model|false $oldUser) use (\\October\\Rain\\Database\\Model $model) {\n         *         \\Log::info($oldUser->full_name . ' is now impersonating ' . $model->full_name);\n         *     });\n         *\n         */\n        $user->fireEvent('model.auth.beforeImpersonate', [$oldUser]);\n\n        $this->login($user, false);\n\n        if (!$this->isImpersonator()) {\n            Session::put($this->sessionKey.'_impersonate', $oldSession);\n        }\n    }\n\n    /**\n     * Stop the current session being impersonated and\n     * authenticate as the impersonator again\n     */\n    public function stopImpersonate()\n    {\n        $currentSession = Session::get($this->sessionKey);\n        $currentUser = !empty($currentSession[0]) ? $this->findUserById($currentSession[0]) : false;\n        $oldSession = Session::pull($this->sessionKey.'_impersonate');\n        $oldUser = !empty($oldSession[0]) ? $this->findUserById($oldSession[0]) : false;\n\n        if ($currentUser) {\n            /**\n             * @event model.auth.afterImpersonate\n             * Called after the model is booted\n             *\n             * Example usage:\n             *\n             *     $model->bindEvent('model.auth.afterImpersonate', function (\\October\\Rain\\Database\\Model|false $oldUser) use (\\October\\Rain\\Database\\Model $model) {\n             *         \\Log::info($oldUser->full_name . ' has stopped impersonating ' . $model->full_name);\n             *     });\n             *\n             */\n            $currentUser->fireEvent('model.auth.afterImpersonate', [$oldUser]);\n        }\n\n        Session::put($this->sessionKey, $oldSession);\n    }\n\n    /**\n     * Check to see if the current session is being impersonated\n     *\n     * @return bool\n     */\n    public function isImpersonator()\n    {\n        return !empty(Session::has($this->sessionKey.'_impersonate'));\n    }\n\n    /**\n     * Get the original user doing the impersonation\n     *\n     * @return mixed Returns the User model for the impersonator if able, false if not\n     */\n    public function getImpersonator()\n    {\n        $impersonateArray = Session::get($this->sessionKey.'_impersonate');\n\n        /*\n         * Check supplied session/cookie is an array (user id, persist code)\n         */\n        if (!is_array($impersonateArray) || count($impersonateArray) !== 2) {\n            return false;\n        }\n\n        $id = $impersonateArray[0];\n\n        return $this->createUserModel()->find($id);\n    }\n}\n"], "fixing_code": ["<?php namespace October\\Rain\\Auth;\n\nuse Cookie;\nuse Session;\nuse Request;\nuse Illuminate\\Contracts\\Auth\\Authenticatable;\n\n/**\n * Authentication manager\n */\nclass Manager implements \\Illuminate\\Contracts\\Auth\\StatefulGuard\n{\n    use \\October\\Rain\\Support\\Traits\\Singleton;\n\n    /**\n     * @var Models\\User The currently logged in user\n     */\n    protected $user;\n\n    /**\n     * @var array In memory throttle cache [md5($userId.$ipAddress) => $this->throttleModel]\n     */\n    protected $throttle = [];\n\n    /**\n     * @var string User Model Class\n     */\n    protected $userModel = Models\\User::class;\n\n    /**\n     * @var string User Group Model Class\n     */\n    protected $groupModel = Models\\Group::class;\n\n    /**\n     * @var string Throttle Model Class\n     */\n    protected $throttleModel = Models\\Throttle::class;\n\n    /**\n     * @var bool Flag to enable login throttling\n     */\n    protected $useThrottle = true;\n\n    /**\n     * @var bool Internal flag to toggle using the session for the current authentication request\n     */\n    protected $useSession = true;\n\n    /**\n     * @var bool Flag to require users to be activated to login\n     */\n    protected $requireActivation = true;\n\n    /**\n     * @var string Key to store the auth session data in\n     */\n    protected $sessionKey = 'october_auth';\n\n    /**\n     * @var bool Indicates if the user was authenticated via a recaller cookie.\n     */\n    protected $viaRemember = false;\n\n    /**\n     * @var string The IP address of this request\n     */\n    public $ipAddress = '0.0.0.0';\n\n    /**\n     * Initializes the singleton\n     */\n    protected function init()\n    {\n        $this->ipAddress = Request::ip();\n    }\n\n    //\n    // User\n    //\n\n    /**\n     * Creates a new instance of the user model\n     *\n     * @return Models\\User\n     */\n    public function createUserModel()\n    {\n        $class = '\\\\'.ltrim($this->userModel, '\\\\');\n        return new $class();\n    }\n\n    /**\n     * Prepares a query derived from the user model.\n     *\n     * @return \\October\\Rain\\Database\\Builder $query\n     */\n    protected function createUserModelQuery()\n    {\n        $model = $this->createUserModel();\n        $query = $model->newQuery();\n        $this->extendUserQuery($query);\n\n        return $query;\n    }\n\n    /**\n     * Extend the query used for finding the user.\n     * @param \\October\\Rain\\Database\\Builder $query\n     * @return void\n     */\n    public function extendUserQuery($query)\n    {\n    }\n\n    /**\n     * Registers a user with the provided credentials with optional flags\n     * for activating the newly created user and automatically logging them in\n     *\n     * @param array $credentials\n     * @param bool $activate\n     * @param bool $autoLogin\n     * @return Models\\User\n     */\n    public function register(array $credentials, $activate = false, $autoLogin = true)\n    {\n        $user = $this->createUserModel();\n        $user->fill($credentials);\n        $user->save();\n\n        if ($activate) {\n            $user->attemptActivation($user->getActivationCode());\n        }\n\n        // Prevents revalidation of the password field\n        // on subsequent saves to this model object\n        $user->password = null;\n\n        if ($autoLogin) {\n            $this->user = $user;\n        }\n\n        return $user;\n    }\n\n    /**\n     * Sets the user\n     */\n    public function setUser(Authenticatable $user)\n    {\n        $this->user = $user;\n    }\n\n    /**\n     * Returns the current user, if any.\n     *\n     * @return mixed (Models\\User || null)\n     */\n    public function getUser()\n    {\n        if (is_null($this->user)) {\n            $this->check();\n        }\n\n        return $this->user;\n    }\n\n    /**\n     * Finds a user by the login value.\n     *\n     * @param string $id\n     * @return mixed (Models\\User || null)\n     */\n    public function findUserById($id)\n    {\n        $query = $this->createUserModelQuery();\n\n        $user = $query->find($id);\n\n        return $this->validateUserModel($user) ? $user : null;\n    }\n\n    /**\n     * Finds a user by the login value.\n     *\n     * @param string $login\n     * @return mixed (Models\\User || null)\n     */\n    public function findUserByLogin($login)\n    {\n        $model = $this->createUserModel();\n\n        $query = $this->createUserModelQuery();\n\n        $user = $query->where($model->getLoginName(), $login)->first();\n\n        return $this->validateUserModel($user) ? $user : null;\n    }\n\n    /**\n     * Finds a user by the given credentials.\n     *\n     * @param array $credentials The credentials to find a user by\n     * @throws AuthException If the credentials are invalid\n     * @return Models\\User The requested user\n     */\n    public function findUserByCredentials(array $credentials)\n    {\n        $model = $this->createUserModel();\n        $loginName = $model->getLoginName();\n\n        if (!array_key_exists($loginName, $credentials)) {\n            throw new AuthException(sprintf('Login attribute \"%s\" was not provided.', $loginName));\n        }\n\n        $query = $this->createUserModelQuery();\n        $hashableAttributes = $model->getHashableAttributes();\n        $hashedCredentials = [];\n\n        /*\n         * Build query from given credentials\n         */\n        foreach ($credentials as $credential => $value) {\n            // All excepted the hashed attributes\n            if (in_array($credential, $hashableAttributes)) {\n                $hashedCredentials = array_merge($hashedCredentials, [$credential => $value]);\n            }\n            else {\n                $query = $query->where($credential, '=', $value);\n            }\n        }\n\n        $user = $query->first();\n        if (!$this->validateUserModel($user)) {\n            throw new AuthException('A user was not found with the given credentials.');\n        }\n\n        /*\n         * Check the hashed credentials match\n         */\n        foreach ($hashedCredentials as $credential => $value) {\n            if (!$user->checkHashValue($credential, $value)) {\n                // Incorrect password\n                if ($credential == 'password') {\n                    throw new AuthException(sprintf(\n                        'A user was found to match all plain text credentials however hashed credential \"%s\" did not match.',\n                        $credential\n                    ));\n                }\n\n                // User not found\n                throw new AuthException('A user was not found with the given credentials.');\n            }\n        }\n\n        return $user;\n    }\n\n    /**\n     * Perform additional checks on the user model.\n     *\n     * @param $user\n     * @return boolean\n     */\n    protected function validateUserModel($user)\n    {\n        return $user instanceof $this->userModel;\n    }\n\n    //\n    // Throttle\n    //\n\n    /**\n     * Creates an instance of the throttle model\n     *\n     * @return Models\\Throttle\n     */\n    public function createThrottleModel()\n    {\n        $class = '\\\\'.ltrim($this->throttleModel, '\\\\');\n        return new $class();\n    }\n\n    /**\n     * Find a throttle record by login and ip address\n     *\n     * @param string $loginName\n     * @param string $ipAddress\n     * @return Models\\Throttle\n     */\n    public function findThrottleByLogin($loginName, $ipAddress)\n    {\n        $user = $this->findUserByLogin($loginName);\n        if (!$user) {\n            throw new AuthException(\"A user was not found with the given credentials.\");\n        }\n\n        $userId = $user->getKey();\n        return $this->findThrottleByUserId($userId, $ipAddress);\n    }\n\n    /**\n     * Find a throttle record by user id and ip address\n     *\n     * @param integer $userId\n     * @param string $ipAddress\n     * @return Models\\Throttle\n     */\n    public function findThrottleByUserId($userId, $ipAddress = null)\n    {\n        $cacheKey = md5($userId.$ipAddress);\n        if (isset($this->throttle[$cacheKey])) {\n            return $this->throttle[$cacheKey];\n        }\n\n        $model = $this->createThrottleModel();\n        $query = $model->where('user_id', '=', $userId);\n\n        if ($ipAddress) {\n            $query->where(function ($query) use ($ipAddress) {\n                $query->where('ip_address', '=', $ipAddress);\n                $query->orWhere('ip_address', '=', null);\n            });\n        }\n\n        if (!$throttle = $query->first()) {\n            $throttle = $this->createThrottleModel();\n            $throttle->user_id = $userId;\n            if ($ipAddress) {\n                $throttle->ip_address = $ipAddress;\n            }\n\n            $throttle->save();\n        }\n\n        return $this->throttle[$cacheKey] = $throttle;\n    }\n\n    //\n    // Business Logic\n    //\n\n    /**\n     * Attempt to authenticate a user using the given credentials.\n     *\n     * @param array $credentials The user login details\n     * @param bool $remember Store a non-expire cookie for the user\n     * @throws AuthException If authentication fails\n     * @return Models\\User The successfully logged in user\n     */\n    public function attempt(array $credentials = [], $remember = false)\n    {\n        return !!$this->authenticate($credentials, $remember);\n    }\n\n    /**\n     * Validate a user's credentials.\n     *\n     * @param  array  $credentials\n     * @return bool\n     */\n    public function validate(array $credentials = [])\n    {\n        return !!$this->validateInternal($credentials);\n    }\n\n    /**\n     * Validate a user's credentials, method used internally.\n     *\n     * @param  array  $credentials\n     * @return User\n     */\n    protected function validateInternal(array $credentials = [])\n    {\n        /*\n         * Default to the login name field or fallback to a hard-coded 'login' value\n         */\n        $loginName = $this->createUserModel()->getLoginName();\n        $loginCredentialKey = isset($credentials[$loginName]) ? $loginName : 'login';\n\n        if (empty($credentials[$loginCredentialKey])) {\n            throw new AuthException(sprintf('The \"%s\" attribute is required.', $loginCredentialKey));\n        }\n\n        if (empty($credentials['password'])) {\n            throw new AuthException('The password attribute is required.');\n        }\n\n        /*\n         * If the fallback 'login' was provided and did not match the necessary\n         * login name, swap it over\n         */\n        if ($loginCredentialKey !== $loginName) {\n            $credentials[$loginName] = $credentials[$loginCredentialKey];\n            unset($credentials[$loginCredentialKey]);\n        }\n\n        /*\n         * If throttling is enabled, check they are not locked out first and foremost.\n         */\n        if ($this->useThrottle) {\n            $throttle = $this->findThrottleByLogin($credentials[$loginName], $this->ipAddress);\n            $throttle->check();\n        }\n\n        /*\n         * Look up the user by authentication credentials.\n         */\n        try {\n            $user = $this->findUserByCredentials($credentials);\n        }\n        catch (AuthException $ex) {\n            if ($this->useThrottle) {\n                $throttle->addLoginAttempt();\n            }\n\n            throw $ex;\n        }\n\n        if ($this->useThrottle) {\n            $throttle->clearLoginAttempts();\n        }\n\n        return $user;\n    }\n\n    /**\n     * Attempts to authenticate the given user according to the passed credentials.\n     *\n     * @param array $credentials The user login details\n     * @param bool $remember Store a non-expire cookie for the user\n     */\n    public function authenticate(array $credentials, $remember = true)\n    {\n        $user = $this->validateInternal($credentials);\n\n        $user->clearResetPassword();\n\n        $this->login($user, $remember);\n\n        return $this->user;\n    }\n\n    /**\n     * Check to see if the user is logged in and activated, and hasn't been banned or suspended.\n     *\n     * @return bool\n     */\n    public function check()\n    {\n        if (is_null($this->user)) {\n            /*\n             * Check session first, follow by cookie\n             */\n            if ($sessionArray = Session::get($this->sessionKey)) {\n                $userArray = $sessionArray;\n            }\n            elseif ($cookieArray = Cookie::get($this->sessionKey)) {\n                $this->viaRemember = true;\n                /*\n                 * Shift gracefully to unserialized cookies\n                 * @todo Remove if statement below if year >= 2021 or build >= 475\n                 */\n                if (is_array($cookieArray)) {\n                    $userArray = $cookieArray;\n                }\n                else {\n                    $userArray = @json_decode($cookieArray, true);\n                }\n            }\n            else {\n                return false;\n            }\n\n            /*\n             * Check supplied session/cookie is an array (user id, persist code)\n             */\n            if (!is_array($userArray) || count($userArray) !== 2) {\n                return false;\n            }\n\n            list($id, $persistCode) = $userArray;\n\n            /*\n             * Look up user\n             */\n            if (!$user = $this->findUserById($id)) {\n                return false;\n            }\n\n            /*\n             * Confirm the persistence code is valid, otherwise reject\n             */\n            if (!$user->checkPersistCode($persistCode)) {\n                return false;\n            }\n\n            /*\n             * Pass\n             */\n            $this->user = $user;\n        }\n\n        /*\n         * Check cached user is activated\n         */\n        if (!($user = $this->getUser()) || ($this->requireActivation && !$user->is_activated)) {\n            return false;\n        }\n\n        /*\n         * Throttle check\n         */\n        if ($this->useThrottle) {\n            $throttle = $this->findThrottleByUserId($user->getKey(), $this->ipAddress);\n\n            if ($throttle->is_banned || $throttle->checkSuspended()) {\n                $this->logout();\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Determine if the current user is a guest.\n     *\n     * @return bool\n     */\n    public function guest()\n    {\n        return false;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        return $this->getUser();\n    }\n\n    /**\n     * Get the ID for the currently authenticated user.\n     *\n     * @return int|null\n     */\n    public function id()\n    {\n        if ($user = $this->getUser()) {\n            return $user->getAuthIdentifier();\n        }\n\n        return null;\n    }\n\n    /**\n     * Log a user into the application without sessions or cookies.\n     *\n     * @param  array  $credentials\n     * @return bool\n     */\n    public function once(array $credentials = [])\n    {\n        $this->useSession = false;\n\n        $user = $this->authenticate($credentials);\n\n        $this->useSession = true;\n\n        return !!$user;\n    }\n\n    /**\n     * Log the given user ID into the application without sessions or cookies.\n     *\n     * @param  mixed  $id\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|false\n     */\n    public function onceUsingId($id)\n    {\n        if (!is_null($user = $this->findUserById($id))) {\n            $this->setUser($user);\n\n            return $user;\n        }\n\n        return false;\n    }\n\n    /**\n     * Logs in the given user and sets properties\n     * in the session.\n     * @throws AuthException If the user is not activated and $this->requireActivation = true\n     */\n    public function login(Authenticatable $user, $remember = true)\n    {\n        /*\n         * Fire the 'beforeLogin' event\n         */\n        $user->beforeLogin();\n\n        /*\n         * Activation is required, user not activated\n         */\n        if ($this->requireActivation && !$user->is_activated) {\n            $login = $user->getLogin();\n            throw new AuthException(sprintf(\n                'Cannot login user \"%s\" as they are not activated.',\n                $login\n            ));\n        }\n\n        $this->user = $user;\n\n        /*\n         * Create session/cookie data to persist the session\n         */\n        if ($this->useSession) {\n            $toPersist = [$user->getKey(), $user->getPersistCode()];\n            Session::put($this->sessionKey, $toPersist);\n\n            if ($remember) {\n                Cookie::queue(Cookie::forever($this->sessionKey, json_encode($toPersist)));\n            }\n        }\n\n        /*\n         * Fire the 'afterLogin' event\n         */\n        $user->afterLogin();\n    }\n\n    /**\n     * Log the given user ID into the application.\n     *\n     * @param  mixed  $id\n     * @param  bool   $remember\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable\n     */\n    public function loginUsingId($id, $remember = false)\n    {\n        if (!is_null($user = $this->findUserById($id))) {\n            $this->login($user, $remember);\n\n            return $user;\n        }\n\n        return false;\n    }\n\n    /**\n     * Determine if the user was authenticated via \"remember me\" cookie.\n     *\n     * @return bool\n     */\n    public function viaRemember()\n    {\n        return $this->viaRemember;\n    }\n\n    /**\n     * Logs the current user out.\n     */\n    public function logout()\n    {\n        // Initialize the current auth session before trying to remove it\n        if (is_null($this->user) && !$this->check()) {\n            return;\n        }\n\n        if ($this->isImpersonator()) {\n            $this->user = $this->getImpersonator();\n            $this->stopImpersonate();\n            return;\n        }\n\n        if ($this->user) {\n            $this->user->setRememberToken(null);\n            $this->user->forceSave();\n        }\n\n        $this->user = null;\n\n        Session::invalidate();\n        Cookie::queue(Cookie::forget($this->sessionKey));\n    }\n\n    //\n    // Impersonation\n    //\n\n    /**\n     * Impersonates the given user and sets properties\n     * in the session but not the cookie.\n     */\n    public function impersonate($user)\n    {\n        $oldSession = Session::get($this->sessionKey);\n        $oldUser = !empty($oldSession[0]) ? $this->findUserById($oldSession[0]) : false;\n\n        /**\n         * @event model.auth.beforeImpersonate\n         * Called after the model is booted\n         *\n         * Example usage:\n         *\n         *     $model->bindEvent('model.auth.beforeImpersonate', function (\\October\\Rain\\Database\\Model|false $oldUser) use (\\October\\Rain\\Database\\Model $model) {\n         *         \\Log::info($oldUser->full_name . ' is now impersonating ' . $model->full_name);\n         *     });\n         *\n         */\n        $user->fireEvent('model.auth.beforeImpersonate', [$oldUser]);\n\n        $this->login($user, false);\n\n        if (!$this->isImpersonator()) {\n            Session::put($this->sessionKey.'_impersonate', $oldSession);\n        }\n    }\n\n    /**\n     * Stop the current session being impersonated and\n     * authenticate as the impersonator again\n     */\n    public function stopImpersonate()\n    {\n        $currentSession = Session::get($this->sessionKey);\n        $currentUser = !empty($currentSession[0]) ? $this->findUserById($currentSession[0]) : false;\n        $oldSession = Session::pull($this->sessionKey.'_impersonate');\n        $oldUser = !empty($oldSession[0]) ? $this->findUserById($oldSession[0]) : false;\n\n        if ($currentUser) {\n            /**\n             * @event model.auth.afterImpersonate\n             * Called after the model is booted\n             *\n             * Example usage:\n             *\n             *     $model->bindEvent('model.auth.afterImpersonate', function (\\October\\Rain\\Database\\Model|false $oldUser) use (\\October\\Rain\\Database\\Model $model) {\n             *         \\Log::info($oldUser->full_name . ' has stopped impersonating ' . $model->full_name);\n             *     });\n             *\n             */\n            $currentUser->fireEvent('model.auth.afterImpersonate', [$oldUser]);\n        }\n\n        Session::put($this->sessionKey, $oldSession);\n    }\n\n    /**\n     * Check to see if the current session is being impersonated\n     *\n     * @return bool\n     */\n    public function isImpersonator()\n    {\n        return !empty(Session::has($this->sessionKey.'_impersonate'));\n    }\n\n    /**\n     * Get the original user doing the impersonation\n     *\n     * @return mixed Returns the User model for the impersonator if able, false if not\n     */\n    public function getImpersonator()\n    {\n        $impersonateArray = Session::get($this->sessionKey.'_impersonate');\n\n        /*\n         * Check supplied session/cookie is an array (user id, persist code)\n         */\n        if (!is_array($impersonateArray) || count($impersonateArray) !== 2) {\n            return false;\n        }\n\n        $id = $impersonateArray[0];\n\n        return $this->createUserModel()->find($id);\n    }\n}\n"], "filenames": ["src/Auth/Manager.php"], "buggy_code_start_loc": [689], "buggy_code_end_loc": [690], "fixing_code_start_loc": [689], "fixing_code_end_loc": [690], "type": "CWE-613", "message": "An issue was discovered in October through build 471. It reactivates an old session ID (which had been invalid after a logout) once a new login occurs. NOTE: this violates the intended Auth/Manager.php authentication behavior but, admittedly, is only relevant if an old session ID is known to an attacker.", "other": {"cve": {"id": "CVE-2021-3311", "sourceIdentifier": "cve@mitre.org", "published": "2021-02-05T14:15:19.153", "lastModified": "2021-03-15T17:34:39.103", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in October through build 471. It reactivates an old session ID (which had been invalid after a logout) once a new login occurs. NOTE: this violates the intended Auth/Manager.php authentication behavior but, admittedly, is only relevant if an old session ID is known to an attacker."}, {"lang": "es", "value": "Se detect\u00f3 un problema en October hasta el build 471. Reactiva una ID de una sesi\u00f3n anterior (que hab\u00eda sido no v\u00e1lida despu\u00e9s de cerrar la sesi\u00f3n) una vez que se produce un nuevo inicio de sesi\u00f3n.&#xa0;NOTA: esto viola el comportamiento de autenticaci\u00f3n del archivo Auth/Manager.php previsto pero, cierto es que, solo es relevante si un ID de sesi\u00f3n antiguo es conocido por el atacante"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-613"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:octobercms:october:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.0.471", "matchCriteriaId": "C6BF448C-7017-428E-B9BF-40069ACD3990"}]}]}], "references": [{"url": "https://anisiosantos.me/october-cms-token-reactivation", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/octobercms/library/commit/642f597489e6f644d4bd9a0c267e864cabead024", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://octobercms.com/forum/chan/announcements", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/octobercms/library/commit/642f597489e6f644d4bd9a0c267e864cabead024"}}