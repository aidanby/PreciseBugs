{"buggy_code": ["<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests\\Appointment\\CreateAppointmentCalendarRequest;\nuse App\\Http\\Requests\\Appointment\\UpdateAppointmentCalendarRequest;\nuse App\\Models\\Appointment;\nuse App\\Models\\User;\nuse App\\Models\\Client;\nuse Carbon\\Carbon;\nuse Illuminate\\Http\\Request;\nuse Ramsey\\Uuid\\Uuid;\n\nclass AppointmentsController extends Controller\n{\n    public function calendar()\n    {\n        return view('appointments.calendar');\n    }\n\n    public function appointmentsJson()\n    {\n        return Appointment::with(['user:id,name,external_id', 'user.department:name'])\n            ->whereBetween('start_at', [today()->subWeeks(2)->startOfDay(), today()->addWeeks(4)->endOfDay()])\n            ->orWhereBetween('end_at', [today()->subWeeks(2)->startOfDay(), today()->addWeeks(4)->endOfDay()])\n                ->get();\n    }\n\n    public function update(UpdateAppointmentCalendarRequest $request, Appointment $appointment)\n    {\n        $appointment->start_at = Carbon::parse($request->start)->setTimezone(\"Europe/Copenhagen\");\n        $appointment->end_at = Carbon::parse($request->end)->setTimezone(\"Europe/Copenhagen\");\n        $appointment->user()->associate(User::where('external_id', $request->group)->first());\n        $appointment->save();\n\n        return response($appointment);\n    }\n\n    public function store(CreateAppointmentCalendarRequest $request)\n    {\n \n        $client_id = null;\n        $user = User::where('external_id', $request->user)->first();\n\n        if ($request->client_external_id) {\n            $client_id = Client::where('external_id', $request->client_external_id)->first()->id;\n            if (!$client_id) {\n                return response(__(\"Client not found\"), 422);\n            }\n        }\n\n        $request_type = null;\n        $request_id = null;\n        if ($request->source_type && $request->source_external_id) {\n            $request_type = $request->source_type;\n\n            $entry = $request_type::whereExternalId($request->source_external_id);\n            $request_id = $entry->id;\n        }\n\n        if (!$user) {\n            return response(__(\"User not found\"), 422);\n        }\n\n        $startTime = str_replace([\"am\", \"pm\", ' '], \"\", $request->start_time) . ':00';\n        $endTime = str_replace([\"am\", \"pm\", ' '], \"\", $request->end_time) . ':00';\n\n     \n\n        $appointment = Appointment::create([\n            'external_id' => Uuid::uuid4()->toString(),\n            'source_type' => $request_type,\n            'source_id' => $request_id,\n            'client_id' => $client_id,\n            'title' => $request->title,\n            'start_at' => Carbon::parse($request->start_date . \" \" . $startTime),\n            'end_at' => Carbon::parse($request->end_date . \" \" . $endTime),\n            'user_id' => $user->id,\n            'color' => $request->color\n        ]);\n        $appointment->user_external_id = $user->external_id;\n        $appointment->start_at = $appointment->start_at;\n\n        return response($appointment);\n    }\n\n    public function destroy(Appointment $appointment)\n    {\n        if (!auth()->user()->can(\"appointment-create\")) {\n            return response(\"Access denied\", 403);\n        }\n\n        $deleted = $appointment->delete();\n        if ($deleted) {\n            return response(\"Success\");\n        }\n        return response(\"Error\", 503);\n    }\n}\n", "<?php\n\nnamespace App\\Http\\Requests\\User;\n\nuse Illuminate\\Foundation\\Http\\FormRequest;\n\nclass StoreUserRequest extends FormRequest\n{\n    /**\n     * Determine if the user is authorized to make this request.\n     *\n     * @return bool\n     */\n    public function authorize()\n    {\n        return auth()->user()->can('user-create');\n    }\n\n    /**\n     * Get the validation rules that apply to the request.\n     *\n     * @return array\n     */\n    public function rules()\n    {\n        return [\n            'name' => 'required',\n            'email' => 'required|email',\n            'address' => '',\n            'primary_number' => 'numeric',\n            'secondary_number' => 'numeric',\n            'password' => 'required|min:5|confirmed',\n            'password_confirmation' => 'required|min:5',\n            'image_path' => '',\n            'roles' => 'required',\n            'departments' => 'required'\n        ];\n    }\n}\n", "<?php\n\nnamespace App\\Http\\Requests\\User;\n\nuse Illuminate\\Foundation\\Http\\FormRequest;\n\nclass UpdateUserRequest extends FormRequest\n{\n    /**\n     * Determine if the user is authorized to make this request.\n     *\n     * @return bool\n     */\n    public function authorize()\n    {\n        return auth()->user()->can('user-update');\n    }\n\n    /**\n     * Get the validation rules that apply to the request.\n     *\n     * @return array\n     */\n    public function rules()\n    {\n        return [\n            'name' => 'required',\n            'email' => 'required|email',\n            'address' => '',\n            'primary_number' => 'numeric',\n            'secondary_number' => 'numeric',\n            'password' => 'sometimes',\n            'password_confirmation' => 'sometimes',\n            'image_path' => '',\n            'departments' => 'required'\n        ];\n    }\n}\n"], "fixing_code": ["<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests\\Appointment\\CreateAppointmentCalendarRequest;\nuse App\\Http\\Requests\\Appointment\\UpdateAppointmentCalendarRequest;\nuse App\\Models\\Appointment;\nuse App\\Models\\User;\nuse App\\Models\\Client;\nuse Carbon\\Carbon;\nuse Illuminate\\Http\\Request;\nuse Ramsey\\Uuid\\Uuid;\n\nclass AppointmentsController extends Controller\n{\n    public function calendar()\n    {\n        if (!auth()->user()->can(\"calendar-view\")) {\n            session()->flash('flash_message_warning', __('You do not have permission to view this page'));\n            return redirect()->back();\n        }\n        return view('appointments.calendar');\n    }\n\n    public function appointmentsJson()\n    {\n        return Appointment::with(['user:id,name,external_id', 'user.department:name'])\n            ->whereBetween('start_at', [today()->subWeeks(2)->startOfDay(), today()->addWeeks(4)->endOfDay()])\n            ->orWhereBetween('end_at', [today()->subWeeks(2)->startOfDay(), today()->addWeeks(4)->endOfDay()])\n                ->get();\n    }\n\n    public function update(UpdateAppointmentCalendarRequest $request, Appointment $appointment)\n    {\n        $appointment->start_at = Carbon::parse($request->start)->setTimezone(\"Europe/Copenhagen\");\n        $appointment->end_at = Carbon::parse($request->end)->setTimezone(\"Europe/Copenhagen\");\n        $appointment->user()->associate(User::where('external_id', $request->group)->first());\n        $appointment->save();\n\n        return response($appointment);\n    }\n\n    public function store(CreateAppointmentCalendarRequest $request)\n    {\n        $client_id = null;\n        $user = User::where('external_id', $request->user)->first();\n\n        if ($request->client_external_id) {\n            $client_id = Client::where('external_id', $request->client_external_id)->first()->id;\n            if (!$client_id) {\n                return response(__(\"Client not found\"), 422);\n            }\n        }\n\n        $request_type = null;\n        $request_id = null;\n        if ($request->source_type && $request->source_external_id) {\n            $request_type = $request->source_type;\n\n            $entry = $request_type::whereExternalId($request->source_external_id);\n            $request_id = $entry->id;\n        }\n\n        if (!$user) {\n            return response(__(\"User not found\"), 422);\n        }\n\n        $startTime = str_replace([\"am\", \"pm\", ' '], \"\", $request->start_time) . ':00';\n        $endTime = str_replace([\"am\", \"pm\", ' '], \"\", $request->end_time) . ':00';\n\n     \n\n        $appointment = Appointment::create([\n            'external_id' => Uuid::uuid4()->toString(),\n            'source_type' => $request_type,\n            'source_id' => $request_id,\n            'client_id' => $client_id,\n            'title' => $request->title,\n            'start_at' => Carbon::parse($request->start_date . \" \" . $startTime),\n            'end_at' => Carbon::parse($request->end_date . \" \" . $endTime),\n            'user_id' => $user->id,\n            'color' => $request->color\n        ]);\n        $appointment->user_external_id = $user->external_id;\n        $appointment->start_at = $appointment->start_at;\n\n        return response($appointment);\n    }\n\n    public function destroy(Appointment $appointment)\n    {\n        if (!auth()->user()->can(\"appointment-delete\")) {\n            return response(\"Access denied\", 403);\n        }\n\n        $deleted = $appointment->delete();\n        if ($deleted) {\n            return response(\"Success\");\n        }\n        return response(\"Error\", 503);\n    }\n}\n", "<?php\n\nnamespace App\\Http\\Requests\\User;\n\nuse Illuminate\\Foundation\\Http\\FormRequest;\n\nclass StoreUserRequest extends FormRequest\n{\n    /**\n     * Determine if the user is authorized to make this request.\n     *\n     * @return bool\n     */\n    public function authorize()\n    {\n        return auth()->user()->can('user-create');\n    }\n\n    /**\n     * Get the validation rules that apply to the request.\n     *\n     * @return array\n     */\n    public function rules()\n    {\n        return [\n            'name' => 'required',\n            'email' => 'required|email',\n            'address' => '',\n            'primary_number' => 'numeric',\n            'secondary_number' => 'numeric',\n            'password' => 'required|min:6|confirmed',\n            'password_confirmation' => 'required|min:6',\n            'image_path' => '',\n            'roles' => 'required',\n            'departments' => 'required'\n        ];\n    }\n}\n", "<?php\n\nnamespace App\\Http\\Requests\\User;\n\nuse Illuminate\\Foundation\\Http\\FormRequest;\n\nclass UpdateUserRequest extends FormRequest\n{\n    /**\n     * Determine if the user is authorized to make this request.\n     *\n     * @return bool\n     */\n    public function authorize()\n    {\n        return auth()->user()->can('user-update');\n    }\n\n    /**\n     * Get the validation rules that apply to the request.\n     *\n     * @return array\n     */\n    public function rules()\n    {\n        return [\n            'name' => 'required',\n            'email' => 'required|email',\n            'address' => '',\n            'primary_number' => 'numeric',\n            'secondary_number' => 'numeric',\n            'password' => 'sometimes|min:6|confirmed',\n            'password_confirmation' => 'sometimes|min:6',\n            'image_path' => '',\n            'departments' => 'required'\n        ];\n    }\n}\n"], "filenames": ["app/Http/Controllers/AppointmentsController.php", "app/Http/Requests/User/StoreUserRequest.php", "app/Http/Requests/User/UpdateUserRequest.php"], "buggy_code_start_loc": [17, 32, 32], "buggy_code_end_loc": [90, 34, 34], "fixing_code_start_loc": [18, 32, 32], "fixing_code_end_loc": [93, 34, 34], "type": "CWE-862", "message": "In Daybyday CRM, versions 2.0.0 through 2.2.0 are vulnerable to Missing Authorization. An attacker that has the lowest privileges account (employee type user), can view the appointments of all users in the system including administrators. However, this type of user is not authorized to view the calendar at all.", "other": {"cve": {"id": "CVE-2022-22107", "sourceIdentifier": "vulnerabilitylab@mend.io", "published": "2022-01-05T15:15:07.720", "lastModified": "2022-01-08T02:49:40.197", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Daybyday CRM, versions 2.0.0 through 2.2.0 are vulnerable to Missing Authorization. An attacker that has the lowest privileges account (employee type user), can view the appointments of all users in the system including administrators. However, this type of user is not authorized to view the calendar at all."}, {"lang": "es", "value": "En Daybyday CRM, versiones 2.0.0 hasta 2.2.0, son vulnerables a una falta de autorizaci\u00f3n. Un atacante que tenga la cuenta con menos privilegios (usuario de tipo empleado), puede visualizar las citas de todos los usuarios del sistema, incluidos los administradores. Sin embargo, este tipo de usuario no est\u00e1 autorizado a visualizar el calendario en absoluto."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "vulnerabilitylab@mend.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-862"}]}, {"source": "vulnerabilitylab@mend.io", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-862"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:daybydaycrm:daybyday_crm:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndIncluding": "2.2.0", "matchCriteriaId": "ADAFF08E-EF6E-45ED-A139-DD7DDD947C52"}]}]}], "references": [{"url": "https://github.com/Bottelet/DaybydayCRM/commit/a0392f4a4a14e1e3fedaf6817aefce69b6bd661b", "source": "vulnerabilitylab@mend.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.whitesourcesoftware.com/vulnerability-database/CVE-2022-22107", "source": "vulnerabilitylab@mend.io", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Bottelet/DaybydayCRM/commit/a0392f4a4a14e1e3fedaf6817aefce69b6bd661b"}}